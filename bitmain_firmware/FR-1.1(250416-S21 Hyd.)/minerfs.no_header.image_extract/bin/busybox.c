/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_13430();
// FILE *fdopen(int fd, const char *modes);
// void endgrent(void);
// int __fastcall fputs_unlocked(_DWORD, _DWORD); weak
// char *strstr(const char *haystack, const char *needle);
// unsigned int gnu_dev_major(unsigned __int64 dev);
// int ether_hostton(const char *hostname, struct ether_addr *addr);
// int raise(int sig);
// int vasprintf(char **, const char *, va_list);
// int __fastcall sendfile64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// double log(double x);
// int __fastcall strverscmp(_DWORD, _DWORD); weak
// int inet_aton(const char *cp, struct in_addr *inp);
// struct passwd *getpwnam(const char *name);
// int fsync(int fd);
// void setbuf(FILE *stream, char *buf);
// int __fastcall strcasestr(_DWORD, _DWORD); weak
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// struct passwd *getpwuid(__uid_t uid);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// size_t strcspn(const char *s, const char *reject);
// clock_t times(struct tms *buffer);
// int dprintf(_DWORD, const char *, ...); weak
// int clearenv(void);
// int printf(const char *format, ...);
// const char *hstrerror(int err_num);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// size_t regerror(int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size);
// int __fastcall setrlimit64(_DWORD, _DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int tcflush(int fd, int queue_selector);
// time_t mktime(struct tm *tp);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int fflush(FILE *stream);
// __uid_t getuid(void);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int setjmp(jmp_buf env);
// void *memmove(void *dest, const void *src, size_t n);
// int lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags);
// int strchrnul(const char *, ...); weak
// void free(void *ptr);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int fileno_unlocked(FILE *stream);
// int inet_pton(int af, const char *cp, void *buf);
// void exit(int status);
// struct utmpx *pututxline(const struct utmpx *utmpx);
// void *memcpy(void *dest, const void *src, size_t n);
// int execvp(const char *file, char *const argv[]);
// int execlp(const char *file, const char *arg, ...);
// int __fastcall shmget(_DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// int rmdir(const char *path);
// int gethostid(void);
// int tcsetpgrp(int fd, __pid_t pgrp_id);
// ssize_t sendmsg(int fd, const struct msghdr *message, int flags);
// double pow(double x, double y);
// int __fastcall ftruncate64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// char *inet_ntoa(struct in_addr in);
// unsigned int sleep(unsigned int seconds);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// int getc_unlocked(FILE *stream);
// int uname(struct utsname *name);
// char *ctime(const time_t *timer);
// int removexattr(const char *path, const char *name);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// char *strdup(const char *s);
// void setutxent(void);
// speed_t cfgetispeed(const struct termios *termios_p);
// unsigned int alarm(unsigned int seconds);
// int sysconf(int name);
// int unlink(const char *name);
// int dup2(int fd, int fd2);
// int reboot(int howto);
// void *realloc(void *ptr, size_t size);
// int killpg(__pid_t pgrp, int sig);
// int strptime(_DWORD, const char *, ...); weak
// int dup(int fd);
// int getpriority(__priority_which_t which, id_t who);
// int initgroups(const char *, __gid_t group);
// int regexec(const regex_t *preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// __pid_t wait(void *stat_loc);
// int getlogin_r(char *name, size_t name_len);
// int __fastcall shmat(_DWORD, _DWORD); weak
// int chdir(const char *path);
// int strcasecmp(const char *s1, const char *s2);
// __pid_t getpgrp(void);
// __uid_t geteuid(void);
// int __fastcall strsignal(_DWORD); weak
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// int setgroups(size_t n, const __gid_t *groups);
// int cfsetospeed(struct termios *termios_p, speed_t speed);
// int semop(int semid, struct sembuf *sops, size_t nsops);
int j___fxstat64();
// int _fxstat64(void); weak
// ssize_t readlink(const char *path, char *buf, size_t len);
// __gid_t getegid(void);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int ioctl(int fd, unsigned int request, ...);
// __int64 __fastcall lseek64(_DWORD, _DWORD); weak
// void regfree(regex_t *preg);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int __fastcall capget(_DWORD, _DWORD); weak
// int usleep(__useconds_t useconds);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// char *strcpy(char *dest, const char *src);
// int chroot(const char *path);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
// int ferror_unlocked(FILE *stream);
// int __fastcall shmctl(_DWORD, _DWORD); weak
// struct mntent *getmntent(FILE *stream);
// DIR *opendir(const char *name);
// int umount2(const char *special_file, int flags);
// int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);
// int fnmatch(const char *pattern, const char *name, int flags);
// int __fastcall open64(_DWORD, _DWORD); weak
// char *getenv(const char *name);
// int setpriority(__priority_which_t which, id_t who, int prio);
// int __fastcall mkstemp64(_DWORD); weak
// int puts(const char *s);
// int setgid(__gid_t gid);
// void *malloc(size_t size);
// int sigaddset(sigset_t *set, int signo);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int tcdrain(int fd);
// int *_h_errno_location(void);
// struct tm *localtime(const time_t *timer);
// char *strsep(char **stringp, const char *delim);
// int lremovexattr(const char *path, const char *name);
// char *mktemp(char *template);
// void closelog(void);
// int sethostname(const char *name, size_t len);
// char *dirname(char *path);
// int _gmon_start__(void); weak
// int rename(const char *old, const char *new);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// int kill(__pid_t pid, int sig);
// char *getcwd(char *buf, size_t size);
// __pid_t getpid(void);
// void exit(int status);
// int syscall(int sysno, ...);
// double sin(double x);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// __pid_t tcgetpgrp(int fd);
// size_t strlen(const char *s);
// int getchar_unlocked(void);
// __pid_t setsid(void);
// int vprintf(const char *format, __gnuc_va_list arg);
// char *strchr(const char *s, int c);
// void srand(unsigned int seed);
// int setenv(const char *name, const char *value, int replace);
// int personality(unsigned int persona);
// int __fastcall memrchr(_DWORD, _DWORD, _DWORD); weak
// int ttyname_r(int fd, char *buf, size_t buflen);
// int fchown(int fd, __uid_t owner, __gid_t group);
// int execve(const char *path, char *const argv[], char *const envp[]);
// int getopt(int argc, char *const *argv, const char *shortopts);
// int fprintf(FILE *stream, const char *format, ...);
// int getpagesize(void);
// int cfsetispeed(struct termios *termios_p, speed_t speed);
// int chown(const char *file, __uid_t owner, __gid_t group);
// int ungetc(int c, FILE *stream);
// int fcntl(int fd, int cmd, ...);
// int execv(const char *path, char *const argv[]);
// double sqrt(double x);
// speed_t cfgetospeed(const struct termios *termios_p);
// int sigfillset(sigset_t *set);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int klogctl(int type, char *bufp, int len);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int mkdir(const char *path, __mode_t mode);
// int semget(key_t key, int nsems, int semflg);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// struct servent *getservbyport(int port, const char *proto);
// __gid_t getgid(void);
// int getgrouplist(const char *, __gid_t group, __gid_t *groups, int *ngroups);
// void *memset(void *s, int c, size_t n);
// struct mntent *getmntent_r(FILE *stream, struct mntent *result, char *buffer, int bufsize);
// void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int utimes(const char *file, const struct timeval tvp[2]);
// char *strncpy(char *dest, const char *src, size_t n);
// int fscanf(FILE *stream, const char *format, ...);
// int mallopt(int param, int val);
// int sigsuspend(const sigset_t *set);
// unsigned __int64 strtoull(const char *nptr, char **endptr, int base);
// int __fastcall statvfs64(_DWORD, _DWORD); weak
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// int link(const char *from, const char *to);
// ssize_t write(int fd, const void *buf, size_t n);
// int sigdelset(sigset_t *set, int signo);
// struct ether_addr *ether_aton_r(const char *asc, struct ether_addr *addr);
// int __fastcall shmdt(_DWORD); weak
// __pid_t vfork(void);
// void *memchr(const void *s, int c, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// int access(const char *name, int type);
// int rand(void);
// int fclose(FILE *stream);
// int __fastcall getsid(_DWORD); weak
// int __fastcall strnlen(_DWORD, _DWORD); weak
// int pipe(int pipedes[2]);
// int __fastcall fseeko64(_DWORD); weak
// int endmntent(FILE *stream);
// int __fastcall posix_fallocate64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// char *strtok(char *s, const char *delim);
// int semctl(int semid, int semnum, int cmd, ...);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// void endutxent(void);
// int sigemptyset(sigset_t *set);
// FILE *popen(const char *command, const char *modes);
// __pid_t fork(void);
// int putenv(char *string);
// int stime(const time_t *when);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// char *strrchr(const char *s, int c);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int lchown(const char *file, __uid_t owner, __gid_t group);
// void syslog(int pri, const char *fmt, ...);
// int symlink(const char *from, const char *to);
// int __fastcall updwtmpx(_DWORD, _DWORD); weak
// int setuid(__uid_t uid);
// int sscanf(const char *s, const char *format, ...);
// int setpgid(__pid_t pid, __pid_t pgid);
// void clearerr(FILE *stream);
// int sprintf(char *s, const char *format, ...);
// int __fastcall readdir64(_DWORD); weak
// char *mkdtemp(char *template);
// void openlog(const char *ident, int option, int facility);
// int regcomp(regex_t *preg, const char *pattern, int cflags);
// int getgroups(int size, __gid_t list[]);
// double exp(double x);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// __pid_t getppid(void);
// int atoi(const char *nptr);
// ssize_t recvmsg(int fd, struct msghdr *message, int flags);
// int fchdir(int fd);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *strpbrk(const char *s, const char *accept);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int __fastcall capset(_DWORD, _DWORD); weak
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int __fastcall fgets_unlocked(_DWORD, _DWORD, _DWORD); weak
// int socket(int domain, int type, int protocol);
// int __fastcall sched_getaffinity(_DWORD, _DWORD, _DWORD); weak
// FILE *setmntent(const char *file, const char *mode);
// int cfsetspeed(struct termios *termios_p, speed_t speed);
// double atof(const char *nptr);
// in_addr_t inet_addr(const char *cp);
// struct cmsghdr *_cmsg_nxthdr(struct msghdr *mhdr, struct cmsghdr *cmsg);
// void sync(void);
// int __fastcall getline(_DWORD, _DWORD, _DWORD); weak
// int __fastcall if_nametoindex(_DWORD); weak
// int getspnam_r(const char *name, struct spwd *result_buf, char *buffer, size_t buflen, struct spwd **result);
// __mode_t umask(__mode_t mask);
// int chmod(const char *file, __mode_t mode);
// struct hostent *gethostbyname(const char *name);
int sub_140FC();
// int _xstat64(void); weak
// int isatty(int fd);
// int _xmknod(int ver, const char *path, __mode_t mode, __dev_t *dev);
// int unsetenv(const char *name);
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// int feof_unlocked(FILE *stream);
// struct utmpx *getutxent(void);
// char *realpath(const char *name, char *resolved);
// int close(int fd);
int sub_14178();
// int _lxstat64(void); weak
// int mkfifo(const char *path, __mode_t mode);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int closedir(DIR *dirp);
// struct group *getgrgid(__gid_t gid);
// div_t *div(div_t *__return_ptr __struct_ptr retstr, int numer, int denom);
// struct group *getgrnam(const char *name);
// double atan2(double y, double x);
// int putchar_unlocked(int c);
// size_t strspn(const char *s, const char *accept);
// int fchmod(int fd, __mode_t mode);
// double cos(double x);
// int tcgetattr(int fd, struct termios *termios_p);
// int putc_unlocked(int c, FILE *stream);
// int __fastcall tcgetsid(_DWORD); weak
// __int64 __fastcall ftello64(_DWORD); weak
// int pclose(FILE *stream);
// int mount(const char *special_file, const char *dir, const char *fstype, unsigned int rwflag, const void *data);
int __fastcall sub_14258(int a1, char **a2);
int __fastcall sub_14600(int a1, int a2);
int __fastcall sub_14790(unsigned int *a1, int a2);
void __fastcall __noreturn sub_15610(int a1, char **a2);
_BYTE *__fastcall sub_15A98(unsigned __int64 a1, _BYTE *a2, int a3);
unsigned int __fastcall sub_15CA0(unsigned int result, unsigned int a2);
unsigned int __fastcall sub_15EFC(unsigned int a1, unsigned int a2);
int __fastcall sub_15F18(int a1, int a2);
int __fastcall sub_15F1E(int result, unsigned int a2);
int __fastcall sub_161AC(int a1, unsigned int a2);
unsigned int __fastcall sub_161C8(double a1);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_16238();
void *sub_1625C();
__int64 sub_16280();
void *sub_162AC();
int __fastcall sub_162C8(_DWORD *a1);
void __noreturn sub_162F0();
int *__fastcall sub_163D4(int a1);
void __fastcall __noreturn sub_163FC(int a1, int a2, int a3);
void __fastcall __noreturn sub_16490(unsigned __int8 *a1, const char **a2);
unsigned __int8 *__fastcall sub_1684C(unsigned __int8 *a1, int a2);
int __fastcall sub_16880(char *s1, char *s2); // idb
int __fastcall sub_168D4(const char *a1, char *s);
char *__fastcall sub_16964(char *s, int a2);
char *__fastcall sub_16998(const char *a1, _BYTE *a2);
char *__fastcall sub_169FC(const char *a1);
char *__fastcall sub_16A1C(const char *a1);
char *__fastcall sub_16A54(const char *a1);
const char *__fastcall sub_16AA8(const char *a1, int a2);
void sub_16AF4(const char *a1, ...);
void __noreturn sub_16B40(const char *a1, ...);
void __fastcall sub_16B80(const char *a1);
void __fastcall __noreturn sub_16B90(const char *a1);
void __fastcall sub_16BA4(const char *a1, char *a2, const char *a3);
void __noreturn sub_16DBC(const char *a1, ...);
void sub_16DDC(const char *a1, ...);
void __noreturn sub_16E08();
int __fastcall sub_16E34(int a1);
int __fastcall sub_16E68(int a1);
int __fastcall sub_16E9C(int a1);
char *__fastcall sub_16EA8(char *a1, const char *a2);
_BYTE *__fastcall sub_16EB0(unsigned int a1, _BYTE *a2, int a3);
_BYTE *__fastcall sub_16F38(signed int a1, _BYTE *a2, int a3);
_BYTE *__fastcall sub_16F64(unsigned int a1);
_BYTE *__fastcall sub_16F8C(signed int a1);
int __fastcall sub_16FB4(int a1, unsigned __int8 *a2, int a3);
_BYTE *__fastcall sub_17000(_BYTE *result, unsigned __int8 *a2, int a3);
ssize_t __fastcall sub_170EC(char a1, int a2, int a3);
ssize_t __fastcall sub_1710C(char *a1);
ssize_t __fastcall sub_1712C(char *a1);
int __fastcall sub_1714C(int fd, int *a2, int *a3);
int __fastcall sub_17280(int a1, int a2, int a3);
int __fastcall sub_1729C(struct termios *termios_p); // idb
int __fastcall sub_172AC(int a1, int a2, struct termios *s, char a4);
int __fastcall sub_17364(int a1, struct termios *s, char a3);
__pid_t __fastcall sub_17398(__pid_t pid, int *stat_loc, int options);
__pid_t __fastcall sub_173DC(int *stat_loc);
int __fastcall sub_173EC(__pid_t a1, int a2, int a3);
void __noreturn sub_17440();
void *__fastcall sub_17450(size_t a1);
void *__fastcall sub_1748C(size_t a1);
void *__fastcall sub_174B4(void *a1, size_t a2);
void *__fastcall sub_174DC(size_t a1);
char *__fastcall sub_174F8(const char *a1);
void *__fastcall sub_1751C(char *a1, int a2);
void *__fastcall sub_1756C(const void *a1, size_t a2);
int __fastcall sub_17590(const char *a1, int a2);
int __fastcall sub_175B4(const char *a1, int a2);
int __fastcall sub_175D8(const char *a1, int a2);
int __fastcall sub_175E0(const char *a1, int a2);
int __fastcall sub_1760C(const char *a1, int a2);
int __fastcall sub_17614(const char *a1);
int __fastcall sub_1761C(const char *a1);
int __fastcall sub_17640(const char *a1, const char *a2);
int __fastcall sub_1766C(int *a1);
int __fastcall sub_17688(int a1, int a2);
int __fastcall sub_176A8(int result, int a2);
ssize_t __fastcall sub_176C8(ssize_t result, char *a2, size_t a3);
int __fastcall sub_17700(int a1);
int __fastcall sub_1771C(int a1, int a2, __int64 a3, int a4);
int __fastcall sub_17778(const char *a1);
int __fastcall sub_1779C(FILE *a1, const char *a2);
int sub_177C0();
int sub_177D8();
int j_putchar_unlocked(int c);
char *sub_177E4(const char *a1, ...);
int __fastcall sub_17820(const char *a1, const char *a2);
void __fastcall sub_17838(const char *a1);
void __fastcall sub_178AC(char *a1);
int __fastcall sub_178C4(__gid_t a1);
int __fastcall sub_178E0(__uid_t a1);
int __fastcall sub_178FC(const char *a1);
int __fastcall sub_17920(const char *a1);
DIR *__fastcall sub_17954(const char *a1);
DIR *__fastcall sub_17980(const char *a1);
int __fastcall sub_179A4(int a1, int a2, int a3);
int __fastcall sub_179C0(int a1, const struct sockaddr *a2, socklen_t a3);
ssize_t __fastcall sub_179DC(int a1, const void *a2, size_t a3, const struct sockaddr *a4, socklen_t a5);
int __fastcall sub_17A0C(const char *a1);
int __fastcall sub_17A30(int a1, int a2, const char *a3);
int sub_17A4C(int a1, unsigned int a2, int a3, const char *a4, ...);
int sub_17AA0(int a1, unsigned int a2, int a3, const char *a4, ...);
int __fastcall sub_17AF4(int a1, unsigned int a2, int a3, const char *a4);
int __fastcall sub_17B18(int a1, unsigned int a2, int a3, const char *a4);
char *__fastcall sub_17B34(int a1);
__pid_t sub_17B64();
void *__fastcall sub_17B80(const char *a1);
char *__fastcall sub_17BE4(const char *a1);
void *__fastcall sub_17C9C(const char *a1);
char *__fastcall sub_17CF0(const char *a1);
_BYTE *__fastcall sub_17CF8(const char *a1);
__int64 __fastcall sub_17D9C(int fd, int a2, __int64 a3);
__int64 __fastcall sub_17F2C(int a1, int a2, __int64 a3);
__int64 __fastcall sub_17F58(int a1, int a2, __int64 a3);
__int64 __fastcall sub_17FAC(int a1, int a2);
ssize_t __fastcall sub_17FB8(int fd, char *buf, size_t n);
ssize_t __fastcall sub_1800C(int fd, void *buf, size_t nbytes);
ssize_t __fastcall sub_18050(int fd, char *buf, size_t nbytes);
ssize_t __fastcall sub_180A8(int a1, char *a2, size_t a3);
ssize_t __fastcall sub_180C8(int a1, char *a2, size_t a3);
ssize_t __fastcall sub_180F4(int fd, void *buf, size_t n);
void __fastcall sub_18140(int a1); // idb
int __fastcall sub_18150(int a1, const struct sigaction *a2);
int __fastcall sub_18158(int a1);
__sighandler_t __fastcall sub_18184(__sighandler_t result, void (*a2)(int));
void *__fastcall sub_181C4(int a1, void (*a2)(int));
int __fastcall sub_18228(int a1);
void __fastcall __noreturn sub_18260(int a1);
int __fastcall sub_18288(int a1, void (*a2)(int));
int __fastcall sub_182C0(int a1);
struct tm *__fastcall sub_182E8(int a1, int *a2);
time_t __fastcall sub_18740(const char *a1, struct tm *tp);
char *__fastcall sub_18768(char *a1, size_t a2, time_t a3);
__int64 __fastcall sub_187B0(int a1, int a2, int a3);
__int64 __fastcall sub_187F0(int a1, int a2, int a3);
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_1882C(int a1, int a2, int a3);
__int64 __fastcall sub_18844(int a1, int a2, _BYTE *a3);
__int64 __fastcall sub_188A4(const char *a1, char *a2, int a3);
__int64 __fastcall sub_18914(char *a1, char *a2, int a3);
int __fastcall sub_18990(const char *a1, char *a2, char *a3);
int __fastcall sub_189FC(char *a1, char *a2, int a3);
int __fastcall sub_18A74(int a1, char **a2);
unsigned int sub_18B5C();
int __fastcall sub_18B64(const char *a1);
int sub_18B84();
ssize_t sub_18BB0();
void __fastcall __noreturn handler(int a1);
void __fastcall __noreturn sub_18C40(int a1, char **a2);
void __fastcall __noreturn sub_193A4(int a1);
int __fastcall sub_193E0(int a1, char **a2);
int __fastcall sub_19818(int a1, char **a2);
int sub_19C70();
int __fastcall sub_19CE8(int a1);
int sub_19D1C();
int sub_19D44();
void __fastcall __noreturn sub_19D64(int a1);
void __fastcall __noreturn sub_19DAC(int a1);
int __fastcall sub_19DB8(const char *a1);
char *__fastcall sub_19DEC(char *result);
void sub_19E98();
void __fastcall sub_1A254(int a1);
void sub_1A2F4();
void sub_1A388();
void sub_1A488();
void sub_1A5D0();
void sub_1A670();
void sub_1A9BC();
void sub_1AAA0();
void __fastcall sub_1AB68(int a1);
void __fastcall sub_1ABF0(int a1);
void __fastcall sub_1AC44(int a1);
void __fastcall sub_1ACA0(int a1, int a2);
void __fastcall sub_1ACEC(int a1);
int sub_1AD6C();
unsigned int __fastcall sub_1AE78(int a1);
_BYTE *__fastcall sub_1AEC8(int a1);
void sub_1AF9C();
void sub_1B028();
int __fastcall sub_1B150(int a1, char **a2);
int __fastcall sub_1BC28(int a1, char **a2);
int __fastcall sub_1BD18(char *s1, char *s2); // idb
int __fastcall sub_1BD6C(char *a1);
int __fastcall sub_1BD78(int fd, char a2, int a3);
int __fastcall sub_1BE28(int a1, char **a2);
int __fastcall sub_1C3E0(int a1, char **a2);
int __fastcall sub_1C680(const char *a1, int a2);
int __fastcall sub_1C70C(int a1, char **a2);
unsigned int __fastcall sub_1C868(int a1, int a2);
int __fastcall sub_1CC24(unsigned __int8 *a1);
int __fastcall sub_1CCA4(const char *a1, struct in_addr *a2);
const char *__fastcall sub_1CCAC(_WORD *a1, unsigned int a2);
int __fastcall sub_1CCE4(unsigned __int8 *a1);
char *__fastcall sub_1CD24(int *a1, char *s2);
int __fastcall sub_1CDA8(int *a1, const char *a2);
int __fastcall sub_1CFBC(unsigned __int64 a1, __int64 a2);
int __fastcall sub_1D04C(int a1);
int __fastcall sub_1D074(int a1, int a2);
unsigned int __fastcall sub_1D6FC(char *a1);
void __noreturn sub_1D814();
int __fastcall sub_1D81C(int a1, int a2);
int __fastcall sub_1D830(int a1, int a2);
int __fastcall sub_1D844(int a1, int a2);
int __fastcall sub_1D858(int a1, int a2);
int __fastcall sub_1D8A4(const char *a1);
char *__fastcall sub_1DB4C(const struct sockaddr *a1, unsigned int a2, const char *a3, int a4);
int __fastcall sub_1DBE4(const char *a1, int a2, int a3, int a4);
int __fastcall sub_1DCCC(const char *a1, unsigned __int8 *a2, const char *a3);
int __fastcall sub_1DDF0(const char *a1, int (*a2)(void));
int __fastcall sub_1DE70(int a1, char *s); // idb
void __fastcall sub_1DF24(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_1E040(char *s); // idb
int __fastcall sub_1E090(char *a1);
int __fastcall sub_1E110(char *a1);
int __fastcall sub_1E174(int a1, char **a2);
void __fastcall __noreturn sub_1E3B8(int a1);
void __fastcall sub_1E4CC(int a1); // idb
void __fastcall __noreturn sub_1E62C(int a1, char **a2);
int __fastcall sub_1EBB8(const char *a1, const char ***a2);
int __fastcall sub_1EC38(int a1, const char **a2);
int __fastcall sub_1EFDC(int a1, int a2);
int __fastcall sub_1F1F0(int a1, const char **a2, const char **a3, char *a4);
_BYTE **__fastcall sub_1F300(_BYTE **a1);
int __fastcall sub_1F408(int a1, _DWORD *a2, _DWORD *a3);
int sub_1F468();
int __fastcall sub_1F4B8(int a1, int a2);
int __fastcall sub_1F9AC(int a1);
int __fastcall sub_1FD4C(int a1, __int16 a2, char **a3);
int __fastcall sub_20204(char **a1, speed_t c_ospeed);
int __fastcall sub_20798(char **a1);
int sub_20840();
int __fastcall sub_20888(const char *a1, int a2);
int __fastcall sub_20924(char **a1, int a2);
int __fastcall sub_20E98(char **a1);
_BYTE *sub_21434();
int sub_21468();
int __fastcall sub_214B8(int a1, int *a2);
int __fastcall sub_21C00(const char **a1);
int __fastcall sub_21F58(char **a1, int a2);
int __fastcall sub_22544(int a1, __int16 a2, char **a3);
int __fastcall sub_229FC(char **a1);
time_t __fastcall sub_22AF4(int *a1);
ssize_t __fastcall sub_22B54(int *a1, const void *a2, size_t a3);
ssize_t __fastcall sub_22B8C(int *a1, int a2, __int16 a3, int a4);
int __fastcall sub_22BD8(int *a1, int (__fastcall *a2)(char *, unsigned int *, int), int a3);
int __fastcall sub_22DD4(int *a1, int a2, void *a3);
int __fastcall sub_23060(unsigned int *a1, signed int a2, __int16 a3, int a4);
int __fastcall sub_230B4(size_t *a1, int a2, __int16 a3, void *src, size_t n);
int __fastcall sub_23120(_WORD *a1, unsigned int a2, __int16 a3, int a4);
void __fastcall sub_23174(void *a1, int a2, unsigned __int16 *a3, int a4);
const char *__fastcall sub_231F8(unsigned __int8 *cp, int a2, int a3, char *buf, socklen_t len);
int __fastcall sub_232C0(_DWORD *a1, int a2, char *s);
_DWORD *__fastcall sub_233A4(int a1);
int __fastcall sub_233E8(int a1, int a2);
const char *__fastcall sub_2350C(int a1);
_DWORD *__fastcall sub_23550(int a1);
int __fastcall sub_23574(const char *a1);
int __fastcall sub_23598(int *a1, int a2, int a3, int a4);
const char *__fastcall sub_235C8(int a1, char *a2);
void __fastcall sub_2362C(const char *a1, int a2);
void sub_236E0();
int __fastcall sub_23754(int a1, unsigned int *a2, char *s2, char *a4);
int __fastcall sub_237F8(unsigned int *a1, char *s2);
_BYTE *__fastcall sub_23888(unsigned int a1);
int __fastcall sub_238C8(unsigned int *a1, char *a2);
char *__fastcall sub_238F8(signed int a1);
int __fastcall sub_239C8(unsigned int *a1, char *a2, char *a3);
int __fastcall sub_23ADC(int a1, int a2, int a3);
unsigned int __fastcall sub_23B64(_BYTE *a1, const char *a2, int a3);
unsigned int __fastcall sub_23CCC(_BYTE *a1, const char *a2, int a3);
unsigned int __fastcall sub_23D18(_WORD *a1, const char *a2, int a3);
int __fastcall sub_23EC4(int a1);
void __fastcall __noreturn sub_23EE8(const char *a1, const char *a2);
unsigned int __fastcall sub_23F00(const char *a1, char *a2, char *a3);
int __fastcall sub_23F48(_DWORD, _DWORD); // weak
unsigned int __fastcall sub_23F4C(const char *a1, char *a2, char *a3);
void __fastcall __noreturn sub_23FAC(const char *a1, const char *a2);
void __fastcall __noreturn sub_23FC4(const char *a1, const char *a2);
int __fastcall sub_23FDC(int a1, int a2, int a3);
const char *__fastcall sub_24048(int a1, const void *a2);
_BYTE *__fastcall sub_24094(char a1, const void *a2, int a3);
void __fastcall sub_240E8(int a1, unsigned int a2);
void __fastcall sub_24168(__int64 a1);
ssize_t __fastcall sub_24274(const void *a1, int a2);
ssize_t __fastcall sub_242B0(int a1, int a2);
ssize_t __fastcall sub_24318(int a1, int a2, int a3);
ssize_t __fastcall sub_24390(int a1, int a2);
ssize_t __fastcall sub_243F4(int a1, int a2, int a3);
int __fastcall sub_24478(void *a1, int a2);
int sub_24728();
int __fastcall sub_2475C(char *a1, const char *a2, unsigned __int8 *a3);
void __fastcall sub_24794(int a1);
char *__fastcall sub_24928(int a1, char a2, const char *a3);
void __fastcall sub_24D00(int a1, const char *a2);
ssize_t __fastcall sub_250B8(int a1, int a2);
void __fastcall sub_25138(int a1, int a2, int a3, int a4);
int __fastcall sub_251CC(int a1, char **a2);
void *__fastcall sub_25D4C(int a1, unsigned int a2, const char *a3);
char *__fastcall sub_25EA0(int a1, int a2, char *s, _DWORD *a4);
void __fastcall sub_26090(void *a1, unsigned int a2);
void __fastcall sub_26110(int a1);
int __fastcall sub_26190(_DWORD *a1, int a2);
ssize_t __fastcall sub_26248(const void *a1, int a2, unsigned int a3, int a4, unsigned int a5, int *a6, int a7);
int __fastcall sub_26400(void *a1, int a2, unsigned int a3, int a4, unsigned int a5);
void __fastcall sub_26530(char a1, int a2, int a3);
__sighandler_t sub_26580();
int __fastcall sub_265C8(int result, int a2);
int __fastcall sub_26614(int a1, int a2, int a3);
int __fastcall sub_26644(const char *a1, _DWORD *a2, _DWORD *a3, unsigned __int8 *a4);
int __fastcall sub_267E0(unsigned int a1, const char *a2);
int __fastcall sub_268C4(int a1, const void *a2, int a3, int *a4, const char *a5, unsigned int a6);
void __fastcall sub_26AD0(const char *a1, unsigned __int8 *a2);
int __fastcall sub_26B2C(char *s2, char *s1); // idb
unsigned __int8 *__fastcall sub_26BB4(unsigned __int8 *a1, int a2);
unsigned __int8 *__fastcall sub_26CBC(unsigned __int8 *a1, int a2);
int __fastcall sub_26CDC(int a1);
void __fastcall sub_26D10(int a1, const void *a2);
void __fastcall sub_26D7C(__int64 a1, int a2);
unsigned __int8 *__fastcall sub_26DE4(unsigned __int8 *result, unsigned int a2);
void __fastcall sub_26E10(unsigned __int8 **a1, _BYTE *a2, const char *a3, size_t a4);
int __fastcall sub_27004(const char *a1, _DWORD *a2);
int __fastcall sub_27038(char *a1, unsigned __int8 **a2, int a3, char *a4);
int __fastcall sub_27340(char *a1, unsigned __int8 *a2);
int __fastcall sub_273A8(int a1, int a2, int a3);
char *__fastcall sub_276E4(int a1, const char **a2);
int __fastcall sub_27800(int a1, int a2);
int __fastcall sub_27810(_DWORD *a1, _DWORD *a2);
int __fastcall sub_27834(int a1, int a2);
int __fastcall sub_27844(int a1, int a2);
int __fastcall sub_27868(const void *a1, const void *a2); // idb
char *__fastcall sub_278BC(char *a1, unsigned int a2, unsigned int a3);
int __fastcall sub_27970(int a1, int a2);
void sub_27A88();
int __fastcall sub_27BD0(int a1, int a2);
int __fastcall sub_280C8(int a1, unsigned int seconds); // idb
void sub_282A0();
int sub_282C8();
void __fastcall __noreturn sub_282F0(int a1);
int __fastcall sub_28304(int a1, const char **a2);
int __fastcall sub_28600(const char *a1, const char *a2);
int __fastcall sub_28678(const char *a1);
int __fastcall sub_2869C(const char *a1);
int __fastcall sub_286C0(const char *a1);
bool sub_28868();
void __fastcall __noreturn sub_2894C(const char *a1);
int sub_28968();
int sub_28A80();
int __fastcall sub_28B50(int a1);
int __fastcall sub_28D20(const char *a1);
int __fastcall sub_28E30(int a1, char **a2);
int __fastcall sub_294E4(int a1, int a2);
bool __fastcall sub_29594(int a1);
int __fastcall sub_295C0(int result);
unsigned __int8 *__fastcall sub_295E8(unsigned __int8 *result, int a2);
int __fastcall sub_2960C(unsigned __int8 *a1);
int __fastcall sub_29638(int a1, int a2);
int __fastcall sub_29678(unsigned __int8 *a1);
int __fastcall sub_296C0(int *a1, int *a2);
_DWORD *__fastcall sub_296CC(_DWORD *a1, int a2);
int __fastcall sub_29708(int result, int a2);
int __fastcall sub_29780(int a1);
int sub_29804();
int sub_29844();
int sub_2984C();
int sub_29854();
void sub_29868();
void sub_2989C();
void *sub_298B8();
int __fastcall sub_298E4(int *a1);
void *__fastcall sub_29978(void *a1);
void __fastcall sub_299BC(int a1);
void __fastcall sub_299F4(void *ptr);
int __fastcall sub_29A14(int a1, char a2);
char *__fastcall sub_29AB0(const char *a1);
int *__fastcall sub_29AE4(int *a1);
int __fastcall sub_29C7C(_DWORD *a1, int a2, int a3);
int *__fastcall sub_29CD0(const char *a1);
int __fastcall compar(const char *a1, const void *a2);
char *__fastcall sub_29D4C(const char *a1, char a2);
int __fastcall sub_29E14(const char *a1, const char **a2);
_DWORD *__fastcall sub_29E1C(_DWORD *result, int a2, int a3);
void __fastcall __noreturn sub_29EE0(int a1);
void __fastcall sub_29F0C(int a1);
int __fastcall sub_29F94(int sig); // idb
__sighandler_t __fastcall sub_2A140(__sighandler_t result);
void __noreturn sub_2A17C();
int __fastcall sub_2A1D8(int result);
void sub_2A248();
int sub_2A2A4();
_DWORD *__fastcall sub_2A2CC(_DWORD *result);
_DWORD *__fastcall sub_2A368(unsigned __int8 *a1);
_DWORD *sub_2A454();
int __fastcall sub_2A4C4(const char *a1);
void sub_2A514();
void sub_2A5FC();
size_t __fastcall sub_2A67C(const char *a1);
_DWORD *__fastcall sub_2A6D4(const char *a1, int a2);
void sub_2A794();
int sub_2A7EC();
int __fastcall sub_2A834(int result, int a2, int a3);
int __fastcall sub_2A8A4(int result);
int __fastcall sub_2A9BC(int a1);
_DWORD *__fastcall sub_2AA40(_DWORD *result);
int __fastcall sub_2AAB8(int fd, int a2);
int __fastcall sub_2AAFC(FILE *stream); // idb
int __fastcall sub_2AB38(const char *a1, void *a2);
void __noreturn sub_2ABFC(const char *a1, ...);
_DWORD *__fastcall sub_2AC34(unsigned __int8 *a1, int a2);
_DWORD *__fastcall sub_2ADC0(_DWORD *result, int a2);
_DWORD *__fastcall sub_2AE08(unsigned __int8 *a1, const char *a2, int a3);
unsigned int __fastcall sub_2AEF8(const char *a1);
_DWORD *__fastcall sub_2AF78(unsigned __int8 *a1);
_DWORD *__fastcall sub_2AF84(unsigned __int8 *a1, const char *a2);
int __fastcall sub_2AF8C(unsigned __int8 *a1);
int __fastcall sub_2AFB8(unsigned __int8 *a1);
int __fastcall sub_2B000(int a1, int a2);
int __fastcall sub_2B0C8(int a1, int a2);
int __fastcall sub_2B0FC(int a1, int a2, int a3, int a4);
void __fastcall sub_2B138(int a1);
int __fastcall sub_2B1EC(int a1, __pid_t a2);
int __fastcall sub_2B208(int a1);
int __fastcall sub_2B2B0(_DWORD *a1, int a2);
int __fastcall sub_2B2DC(_DWORD *a1);
void *__fastcall sub_2B310(const char *a1);
int __fastcall sub_2B338(int a1, char a2);
void __fastcall __noreturn sub_2B44C(const char *a1);
int __fastcall sub_2B480(unsigned __int8 *a1);
char *sub_2B5A0();
int sub_2B618();
int sub_2B6FC();
int __fastcall sub_2B738(int a1, int a2);
int __fastcall sub_2B8B0(int fd, int a2);
int __fastcall sub_2B91C(int a1, _BYTE **a2);
int sub_2B9AC(const char *a1, ...);
int __fastcall sub_2B9D4(int result);
int sub_2BB6C();
const char *__fastcall sub_2BBE4(int a1);
int sub_2BD78();
_DWORD *__fastcall sub_2BDBC(const char *a1, int a2);
int sub_2BEA0(const char *a1, ...);
int __fastcall sub_2BEEC(int a1, _DWORD *a2);
int sub_2C1AC();
int sub_2C204();
int __fastcall sub_2C294(int a1);
int sub_2C2CC();
int __fastcall sub_2C32C(int a1, int a2);
void *__fastcall sub_2C370(size_t a1);
_DWORD *sub_2C38C();
void *__fastcall sub_2C3C4(const char *a1);
void *__fastcall sub_2C3FC(const void *a1);
void *__fastcall sub_2C428(const void *a1);
int sub_2C454(char *a1, size_t a2, const char *a3, ...);
int __fastcall sub_2C4A0(char *a1, __int16 a2, int a3);
__pid_t __fastcall sub_2C558(int a1, int a2);
int sub_2C790();
int __fastcall sub_2C8C0(int a1);
int __fastcall sub_2C964(int a1, char a2, int a3, int *a4);
__pid_t __fastcall sub_2CB60(char a1);
int sub_2CBBC();
int sub_2CC38();
unsigned __int8 *__fastcall sub_2CDA4(unsigned __int8 *a1, char *name, int a3, char *pattern, int a5, int a6);
char *__fastcall sub_2CE20(unsigned int a1, char *name, char *a3, char *pattern, int a5, int a6);
__int64 __fastcall sub_2CECC(unsigned __int8 *a1);
int __fastcall sub_2CF3C(unsigned __int8 *a1);
bool __fastcall sub_2CF74(int a1, int a2);
int __fastcall sub_2CFB8(int a1);
char *sub_2D148();
int __fastcall sub_2D210(unsigned int a1, int a2);
int __fastcall sub_2D250(const char *a1);
int __fastcall sub_2D320(int a1);
int __fastcall sub_2D348(int a1, int a2);
const char *__fastcall sub_2D4B4(const char *a1);
int __fastcall sub_2D500(int result, unsigned int a2, int a3, char a4);
char *__fastcall sub_2D5C8(const char *a1, int a2);
int __fastcall sub_2D5F8(__int64 a1);
char *__fastcall sub_2D644(const char *a1, char a2, _DWORD *a3);
_BYTE *__fastcall sub_2D828(const char *a1, int a2);
int sub_2DA0C();
_BYTE *__fastcall sub_2DA30(char a1, _BYTE *a2);
int __fastcall sub_2DA60(int a1, int a2, _DWORD *a3);
int __fastcall sub_2DB08(const void **a1, char *s);
__sighandler_t __fastcall sub_2DC30(int a1, _DWORD *a2, int a3);
int __fastcall sub_2DF0C(char *path, char **argv, char **envp); // idb
char *__fastcall sub_2DF6C(int a1, int a2);
int sub_2DF84();
int sub_2E0EC();
int __fastcall sub_2E18C(const char *a1, int a2, int a3);
int __fastcall sub_2E254(int a1, int a2);
int __fastcall sub_2E2C8(int a1, const char **a2);
int __fastcall sub_2E3B4(int a1, int a2, int a3, int a4);
int sub_2E4BC();
DIR *__fastcall sub_2E4E0(int a1, const char *a2, int a3, int a4);
void __fastcall __noreturn sub_2E7E4(int a1);
size_t __fastcall sub_2E87C(int a1, int a2);
_BYTE *__fastcall sub_2EA30(_BYTE *result, int a2);
int __fastcall sub_2EDE0(int a1, _BYTE *a2, int a3);
void __noreturn sub_2EF58(int a1, int a2, ...);
void __fastcall __noreturn sub_2EF80(char *a1, char **a2, const void *a3, int a4);
int sub_2F094();
int __fastcall sub_2F134(int a1);
int __fastcall sub_2F168(int a1, unsigned __int8 **a2);
unsigned __int8 *__fastcall sub_2F2F4(unsigned __int8 *a1);
_DWORD *sub_2F3A8();
int __fastcall sub_2F584(char *a1, int a2, int a3, int *a4);
const char *sub_2F840();
int __fastcall sub_2F9C4(int a1, int a2);
int sub_2FCC4();
int sub_30080();
int sub_3037C();
int sub_30394();
int sub_304C4();
void *sub_305AC();
int __fastcall sub_306F0(int a1);
int __fastcall sub_308C0(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_317CC(const char *a1, int a2);
_DWORD *__fastcall sub_318E0(_DWORD *result, int a2);
_DWORD *sub_3199C();
int sub_319C8();
int __fastcall sub_319FC(_DWORD *a1);
int __fastcall sub_31A54(const char *a1, int a2);
int __fastcall sub_31B70(int a1, int a2, int *a3, char a4);
void sub_31CF8();
int __fastcall sub_31D94(int a1, int a2);
int __fastcall sub_32080(char *a1, unsigned int a2);
char *__fastcall sub_32618(unsigned __int8 *a1, unsigned __int8 *a2, int a3, unsigned int a4, int a5, char a6, char a7);
unsigned __int8 *__fastcall sub_32CE0(unsigned __int8 *a1, int a2);
_DWORD *__fastcall sub_32FC4(int a1, int a2, unsigned int a3);
int __fastcall sub_33454(int result, int a2);
int __fastcall sub_339A4(int a1);
int __fastcall sub_33A58(int result, int *a2, int a3);
int __fastcall sub_33B88(int *a1, int a2);
int __fastcall sub_33C88(_DWORD *a1, int a2);
int __fastcall sub_33E14(_DWORD *a1, char a2);
int __fastcall sub_33EB0(int a1, char a2);
void __noreturn sub_33FBC();
int __fastcall sub_34044(char a1);
int sub_3414C();
void __fastcall sub_342BC(const char *a1);
void sub_342E8();
_DWORD *sub_3437C();
_DWORD *sub_34BB8();
void __fastcall sub_34C98(int a1);
int __fastcall sub_34E1C(_DWORD *a1, int a2, int a3, char a4);
void __fastcall sub_34F90(char *a1, int *a2, int a3, char *a4);
int __fastcall sub_353B0(int a1, char *a2, int a3);
int __fastcall sub_35554(int a1, int a2);
int sub_355B0();
_DWORD *__fastcall sub_35620(int a1, int a2, int a3, int a4);
int sub_357CC();
int __fastcall sub_35964(int a1, char a2);
void __fastcall __noreturn sub_36054(int a1, unsigned __int8 **a2);
const char *__fastcall sub_365CC(int a1, int a2, int a3, int *a4);
unsigned __int64 __fastcall sub_36A80(int *a1, unsigned __int8 *a2);
const char *__fastcall sub_36DF4(int *a1, int a2, int a3);
unsigned __int64 __fastcall sub_36E9C(int *a1, unsigned __int8 *a2);
int __fastcall sub_36EAC(__pid_t *a1);
int __fastcall sub_36F68(char a1, unsigned __int64 *a2, _BYTE *a3);
unsigned __int8 *__fastcall sub_36FC8(unsigned __int8 *result, int a2);
const char *__fastcall sub_37024(__int64 a1, const char *a2, char a3, const char *a4, int a5, const char *a6, const char *a7, unsigned __int8 *a8);
int sub_377A8();
ssize_t __fastcall sub_37840(int a1, char *a2, int a3);
void __fastcall __noreturn sub_37CB0(int a1, char **a2);
int __fastcall sub_38134(int a1, char **a2);
int __fastcall sub_38288(int a1, char **a2);
int __fastcall sub_3834C(int a1, int a2);
int __fastcall sub_3838C(int a1, char **a2);
int __fastcall sub_383F4(int a1, int a2);
int sub_384B0();
void __fastcall __noreturn sub_384DC(int a1, int a2, int a3);
int __fastcall sub_38504(int a1, char **a2);
int __fastcall sub_387E4(char *s, const char **a2);
void __fastcall sub_388F8(void **a1, const char *a2);
int __fastcall sub_389E8(const char **a1, int a2, void *data);
int __fastcall sub_38A7C(const char **a1, char a2);
int __fastcall sub_38F94(int a1, char **a2);
void __fastcall __noreturn sub_3948C(int a1, char **a2);
unsigned int __fastcall sub_39514(const char *a1, unsigned int a2);
void __fastcall __noreturn sub_39544(int a1, char **a2);
int __fastcall sub_3973C(int a1, char **a2);
int __fastcall sub_399D0(int result, int a2, int a3, int a4);
int __fastcall sub_399F8(_DWORD *a1);
bool __fastcall sub_3A0CC(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_3A320(_DWORD *result, int a2, int a3);
_DWORD *__fastcall sub_3A73C(_DWORD *result);
int __fastcall sub_3A850(int result);
_DWORD *__fastcall sub_3A88C(_DWORD *result, int a2, int a3);
_DWORD *__fastcall sub_3A8EC(_DWORD *result, int a2);
int __fastcall sub_3A944(int result);
_DWORD *__fastcall sub_3A98C(_DWORD *a1, unsigned int a2);
_DWORD *__fastcall sub_3A9A8(_DWORD *result);
int __fastcall sub_3AB44(_DWORD *a1);
int __fastcall sub_3AF30(_DWORD *a1);
_DWORD *__fastcall sub_3AFB8(_DWORD *a1);
_DWORD *__fastcall sub_3BA6C(_DWORD *result, int a2);
_BYTE *__fastcall sub_3BB70(_DWORD *a1);
unsigned int sub_3BDB8();
int __fastcall sub_3C048(int a1, char **a2);
int __fastcall sub_3C0AC(_DWORD *a1, int a2, _DWORD *a3);
void *__fastcall sub_3C124(void *a1, size_t a2, __int64 a3);
int __fastcall sub_3C178(ssize_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_3C4AC(const char *a1, int a2, int a3);
int __fastcall sub_3C720(int a1, const char *a2);
int __fastcall sub_3C7FC(int *a1, int a2, int **a3, const char *a4);
int __fastcall sub_3C90C(int a1, int a2);
const char *__fastcall sub_3CD38(const char *a1, const char *a2);
char *__fastcall sub_3CD78(const char *a1, const char *a2);
int __fastcall sub_3CD8C(int *a1, int (__fastcall *a2)(_BYTE *), int (__fastcall *a3)(int, int), int a4);
int __fastcall sub_3D008(int a1, char **a2);
void __fastcall sub_3D050(_DWORD *a1);
__int64 __fastcall sub_3D420(int a1);
int __fastcall sub_3D434(int a1);
int __fastcall sub_3D448(int a1, int a2);
int __fastcall sub_3D504(_DWORD *a1);
int __fastcall sub_3DBE8(_DWORD *a1, _BYTE *a2, int a3);
int __fastcall sub_3DD44(int a1, _DWORD *a2, int a3, const void *a4, size_t a5);
void __fastcall sub_3DE14(void **a1);
int __fastcall sub_3DE30(int *a1);
void __fastcall sub_3DFC8(int a1);
int __fastcall sub_3DFE8(int *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7);
void __fastcall __noreturn sub_3E4B0(int a1);
int __fastcall sub_3E4E0(int a1, int a2, unsigned int *a3, unsigned int a4);
bool __fastcall sub_3E5C0(int a1, signed int a2);
int __fastcall sub_3E64C(int a1, unsigned int *a2);
int __fastcall sub_3EC34(int a1);
int __fastcall sub_3EF78(int a1, int *a2);
int __fastcall sub_3F2A0(int *a1);
int **__fastcall sub_3F500(int a1);
int __fastcall sub_3F54C(int a1, char *name); // idb
int **__fastcall sub_3F588(int **a1, int a2);
unsigned __int64 __fastcall sub_3F644(const char *a1, char *a2, char *a3);
int __fastcall sub_3F6D0(int a1);
int __fastcall sub_3FC40(const char **a1);
int __fastcall sub_3FC48(int a1);
_DWORD *sub_3FD30();
_DWORD *__fastcall sub_3FD84(ssize_t a1, int a2);
void *__fastcall sub_3FDF0(void *a1);
int __fastcall sub_3FDFC(_DWORD *a1, int a2);
ssize_t __fastcall sub_3FE5C(int *a1, void *a2, size_t a3);
__pid_t __fastcall sub_3FF04(int a1, int a2, int a3);
int __fastcall sub_3FF4C(int a1, int a2, int (__fastcall *a3)(_DWORD *));
int __fastcall sub_3FFC0(ssize_t a1, int a2);
int __fastcall sub_40000(int a1, int a2);
int __fastcall sub_4007C(__int64 a1, __int64 a2);
int __fastcall sub_400F8(int result, __int64 a2);
unsigned __int8 *__fastcall sub_40108(const char *a1);
_DWORD *__fastcall sub_401A0(_DWORD *a1, char *haystack, const char *a3, int a4);
int __fastcall sub_40244(int result);
int __fastcall sub_402D8(int a1, unsigned int a2);
bool __fastcall sub_4033C(int a1);
int nullsub_2(); // weak
bool __fastcall sub_40354(int a1, int a2);
int __fastcall sub_40404(int a1, char **a2);
int __fastcall sub_405D0(const char *a1, int a2, const char *a3, int a4);
int __fastcall sub_40654(int a1, char **a2);
int __fastcall sub_40734(const char *a1, int a2, int *a3);
int __fastcall sub_40788(int a1, char **a2);
void __fastcall __noreturn sub_40834(int a1, const char **a2);
void __fastcall __noreturn sub_4087C(int a1, int a2, int a3);
int __fastcall sub_409A4(int a1, char **a2);
int __fastcall sub_40B14(_DWORD *a1, _DWORD *a2);
void __fastcall __noreturn sub_40B24(int a1, char **a2);
int __fastcall sub_40FA8(int a1, char **a2);
int __fastcall sub_41308(int a1, int a2);
unsigned __int64 __fastcall sub_41324(const char *a1);
void __fastcall __noreturn sub_41530(int a1, char **a2);
int __fastcall sub_41704(int a1, int a2, unsigned __int8 *a3);
void __fastcall __noreturn sub_418A4(int a1, char **a2);
int __fastcall sub_419B0(int a1);
char *__fastcall sub_41A08(char *result);
_DWORD *__fastcall sub_41A3C(const char *a1);
int __fastcall sub_41A6C(_DWORD *a1, char *a2);
signed __int64 __fastcall sub_41AD4(int a1, int a2, int a3);
void __fastcall sub_41B9C(void **a1);
const char *__fastcall sub_41BC4(const char *a1);
_QWORD *__fastcall sub_41C04(int a1, int a2);
void **sub_41D30();
void **sub_41DA0();
void **sub_41E54();
_DWORD *sub_41EF0();
void **sub_420CC();
void **sub_4216C();
_DWORD *sub_421E4();
void __fastcall __noreturn sub_4249C(int a1, int a2);
int __fastcall sub_4252C(unsigned __int64 a1);
int __fastcall sub_42648(const char *a1);
int __fastcall sub_426AC(int a1, int a2, int a3);
int sub_42748();
unsigned int __fastcall sub_42750(int a1, int a2);
size_t __fastcall sub_427A4(const void *a1, size_t a2);
void __fastcall __noreturn sub_427BC(int a1, char **a2);
void __fastcall __noreturn sub_42A10(int a1, int a2);
int __fastcall sub_42D90(int a1, int a2);
int __fastcall sub_42DC0(const char *a1, __gid_t a2, __gid_t list[], int *a4);
int __fastcall sub_42E3C(int a1, int a2, const char *a3);
int __fastcall sub_42EE0(__uid_t a1, const char *a2);
int __fastcall sub_42F04(__gid_t a1, const char *a2);
int __fastcall sub_42F28(int a1, char **a2, int a3);
int __fastcall sub_43180(int a1, char **a2);
int __fastcall sub_431D8(int a1, char **a2);
int __fastcall sub_4344C(int a1, int a2);
int __fastcall sub_43498(unsigned __int16 a1);
int __fastcall sub_43504(int a1, int a2);
void *__fastcall sub_43588(void *result);
_DWORD *__fastcall sub_4359C(int a1, int a2);
_DWORD *__fastcall sub_4363C(const char *a1, int a2, int a3);
int __fastcall sub_43784(_BYTE *a1);
void __fastcall sub_43820(void *a1, size_t a2);
int __fastcall sub_43830(int *a1, int **a2);
int __fastcall sub_43940(int a1);
unsigned int __fastcall sub_43D70(unsigned int result, unsigned int a2);
void __fastcall sub_43F1C(int a1, int a2);
tcflag_t __fastcall sub_44140(int a1, char **a2);
void *__fastcall sub_44448(const char *a1);
int __fastcall sub_44554(int a1, char **a2);
int __fastcall sub_44738(int a1, char **a2, int a3);
int __fastcall sub_447FC(int a1, char **a2, int a3);
int __fastcall sub_44868(int a1, char **a2, int a3);
int __fastcall sub_4497C(int a1, char **a2, const char *a3);
int __fastcall sub_44A78(int a1, char **a2);
void __fastcall __noreturn sub_44CD8(int a1, int a2);
void __fastcall __noreturn sub_44DB0(int a1, int a2);
int sub_44EB0();
void __fastcall __noreturn sub_44F28(int a1, char **a2);
void __fastcall __noreturn sub_4515C(int a1, int a2);
int __fastcall sub_451D4(char *a1);
__int64 __fastcall sub_45218(char *a1, __int64 *a2);
int __fastcall sub_45234(const char *a1, int a2, void (__fastcall *a3)(const char *, int));
char *__fastcall sub_452A4(const char *a1, int a2, const char *a3, const char *a4, const char *a5);
__int64 __fastcall sub_454C0(char *a1, __int64 *a2);
double __fastcall sub_4550C(const char *a1, char *a2);
int __fastcall sub_45558(int a1, int a2);
int sub_45958();
int __fastcall sub_45988(int a1, char **a2);
void __fastcall __noreturn sub_45A1C(int a1, int a2);
int __fastcall sub_45A78(int a1, char **a2);
int __fastcall sub_45B54(int a1, char **a2);
int __fastcall sub_45C4C(int a1, char **a2);
unsigned int __fastcall sub_45E58(const char **endptr);
char *__fastcall sub_45E94(char *s, _DWORD *a2, int a3);
int __fastcall sub_46148(char **a1, char **a2);
int __fastcall sub_46458(int a1, char **a2);
unsigned int __fastcall sub_4689C(unsigned int result, int a2, unsigned int *a3);
int __fastcall sub_46C5C(_DWORD *a1);
int sub_46CB4(const char *a1, ...);
int sub_46D90();
int __fastcall sub_46DB0(char *s2); // idb
int __fastcall sub_46DDC(char *s2); // idb
unsigned __int8 *__fastcall sub_46E0C(unsigned __int8 *result, const char *a2, int a3);
void __fastcall sub_46EC8(int a1, int a2);
int __fastcall sub_46F5C(const struct termios *a1, int a2);
int __fastcall sub_46FD8(const struct termios *a1, int a2);
bool __fastcall sub_471B0(const char *a1, int a2);
int __fastcall sub_4727C(int a1, const char *a2, struct termios *a3);
void __fastcall __noreturn sub_472C8(const char *a1);
void __fastcall sub_472DC(int a1, int a2, int a3, int a4);
int __fastcall sub_47378(int a1, int a2);
int sub_478C8();
unsigned int __fastcall sub_478D8(const char *a1);
int __fastcall sub_4790C(int a1, char **a2);
void __fastcall __noreturn sub_48094(int a1, char **a2);
void __fastcall __noreturn sub_48224(const char *a1, const char *a2);
__int64 __fastcall sub_48278(const char *a1, char *a2, char *a3);
int __fastcall sub_482F8(int s2);
bool sub_4834C();
__int64 __fastcall sub_48568(int a1);
__int64 __fastcall sub_48914(int a1);
__int64 __fastcall sub_48994(int a1);
int __fastcall sub_48A14(int a1, const char **a2);
int __fastcall sub_48C48(int a1, char **a2);
size_t __fastcall sub_48CFC(void *s, size_t n);
int __fastcall sub_48D64(unsigned __int8 *a1, void **a2);
ssize_t __fastcall sub_490B4(int a1, char **a2);
int sub_492C0();
int __fastcall sub_492C8(int a1, char **a2);
void __fastcall __noreturn sub_493C8(int a1, char **a2);
void __fastcall __noreturn sub_49428(int a1, char **a2);
int __fastcall sub_49560(int a1, char **a2);
int __fastcall sub_49594(int a1, int a2);
void __fastcall __noreturn sub_495B8(int a1, char **a2);
void __fastcall __noreturn sub_496B4(int a1, char **a2);
struct utmpx *__fastcall sub_49948(int a1, char **a2);
void __fastcall __noreturn sub_49AC4(int a1, _DWORD *a2);
int __fastcall sub_49B28(const char *a1, int a2, int (*a3)(void));
int __fastcall sub_49B90(const char *a1, int a2);
int __fastcall sub_49B9C(char **a1, int a2, int a3);
char *__fastcall sub_49BF0(int a1);
unsigned int __fastcall sub_49DA8(int a1, char **a2);
int __fastcall sub_4A270(int a1, char **a2);
int __fastcall sub_4A364(int a1);
unsigned __int8 *__fastcall sub_4A384(unsigned __int8 *result);
int __fastcall sub_4A3D0(int *a1);
void sub_4A3F4();
_DWORD *__fastcall sub_4A40C(_DWORD **a1);
_DWORD *sub_4A444();
int __fastcall sub_4A470(int *a1);
_DWORD *__fastcall sub_4A4AC(int a1);
_DWORD *__fastcall sub_4A4D8(int a1);
void *__fastcall sub_4A59C(void *result, int a2, int *a3);
int __fastcall sub_4A5C4(int a1);
int __fastcall sub_4A60C(int result);
void __fastcall sub_4A6AC(_DWORD *a1);
_DWORD *__fastcall sub_4A710(int a1);
int __fastcall sub_4A79C(const char *a1, int a2);
int __fastcall sub_4A828(double a1);
int __fastcall sub_4A8BC(double a1);
int __fastcall sub_4A910(double a1);
int __fastcall sub_4A93C(int a1, const char *a2);
char *__fastcall sub_4A98C(unsigned int *a1, const char *a2);
void __fastcall sub_4AAB0(int *a1, const char *a2);
int __fastcall sub_4AB34(unsigned __int8 **a1);
int __fastcall sub_4AB88(unsigned __int8 *a1, int a2, unsigned __int8 *a3);
time_t __fastcall sub_4ABB4(const char *a1);
void __fastcall __noreturn sub_4AC50(const char *a1);
int __fastcall sub_4AC78(char *a1, size_t a2, const char *a3, int a4);
char *__fastcall sub_4AD78(int *a1);
int __fastcall sub_4ADF8(const char *a1, int a2, _DWORD *a3);
int __fastcall sub_4B08C(int a1, int a2);
int __fastcall sub_4B14C(double a1);
int __fastcall sub_4B308(int a1, int a2);
int __fastcall sub_4B32C(int a1, const char *a2);
_DWORD *__fastcall sub_4B360(int a1, const char *a2);
int __fastcall sub_4B378(const char *a1);
_DWORD *__fastcall sub_4B424(int *a1, signed int a2, const char *a3);
int __fastcall sub_4B458(int a1);
int __fastcall sub_4B490(double a1);
int __fastcall sub_4B4B0(double a1);
int __fastcall sub_4B50C(double a1);
unsigned int __fastcall sub_4B604(unsigned int result);
int __fastcall sub_4B6F4(int a1, _DWORD *a2);
void __fastcall __noreturn sub_4B9E0(int a1);
regex_t *__fastcall sub_4BA78(_DWORD *a1, regex_t *a2);
int __fastcall sub_4BB1C(_DWORD *a1, const char *a2, int a3, int *a4, int a5, char a6);
int __fastcall sub_4BD98(unsigned int *a1, int a2);
_BYTE *__fastcall sub_4C344(_DWORD *a1);
int __fastcall sub_4C558(int a1);
int __fastcall sub_4C578(unsigned int a1);
int sub_4C960();
int __fastcall sub_4C978(int a1);
void __fastcall sub_4CCC0(int a1);
void sub_4CCF8();
_DWORD *__fastcall sub_4CFB0(int a1);
int __fastcall sub_4D030(int a1);
int __fastcall sub_4D18C(_DWORD *a1, _DWORD *a2);
int __fastcall sub_4D1AC(int result, __int64 a2);
unsigned int __fastcall sub_4D1E4(int a1, int a2);
_DWORD *__fastcall sub_4D2B8(int a1, int *a2, _DWORD *a3);
int __fastcall sub_4DB30(int result, int a2, int a3, int a4, int a5);
int __fastcall sub_4DC54(int a1, char **a2);
_DWORD *__fastcall sub_4E5A0(int *a1, int a2);
void __fastcall sub_4E5E4(void **a1);
void sub_4E648();
void __fastcall sub_4E6E0(void **a1);
void sub_4E70C();
int __fastcall sub_4E7B0(int a1, char **a2);
int __fastcall sub_4F0D0(int a1, int a2);
tcflag_t sub_4F18C();
_BYTE *__fastcall sub_4F1A4(int a1, char *s, int a3, int a4, unsigned __int8 a5);
char *__fastcall sub_4F25C(char *a1, _BYTE *a2);
char *__fastcall sub_4F2BC(int a1, char *a2, regex_t **a3);
_BYTE *__fastcall sub_4F3C8(_BYTE *a1, char **a2, char **a3);
unsigned __int8 *__fastcall sub_4F448(char *a1, void **a2);
void __fastcall sub_4F4E8(char *s);
void __fastcall sub_4FAD0(const char *a1);
void *__fastcall sub_4FB18(char a1);
int __fastcall sub_4FB6C(_BYTE *a1, FILE *a2, _BYTE *a3, int a4);
_BYTE *__fastcall sub_4FC1C(_BYTE *a1);
_BYTE *__fastcall sub_4FC5C(_BYTE *a1, _BYTE *a2, int a3);
void __fastcall sub_4FD84(int a1, int a2, int a3);
int __fastcall sub_5085C(int a1, int a2);
unsigned int sub_50B80();
int sub_50BD8();
void *sub_50C04();
char *__fastcall sub_50C20(char *src, signed int a2);
int __fastcall sub_50CDC(int result, size_t a2, int a3);
void *__fastcall sub_50E58(char *dest, unsigned int a2, int a3);
int sub_50F44();
int sub_50F90();
int sub_50FC8();
char *sub_51000(const char *a1, ...);
char *__fastcall sub_51068(const char *a1);
int sub_51168(const char *a1, ...);
unsigned __int8 *__fastcall sub_511A8(unsigned __int8 *a1, int a2, int a3, int a4);
int __fastcall sub_512E4(unsigned int a1);
int __fastcall sub_51324(unsigned int a1);
int sub_51358();
unsigned __int8 *__fastcall sub_5137C(unsigned int a1, int a2);
int sub_513FC();
void *__fastcall sub_51420(const void *a1);
_BYTE *__fastcall sub_51464(const void *a1);
_BYTE *__fastcall sub_51498(int a1);
char *__fastcall sub_514C4(char *a1, char *s, int a3, int a4);
_BYTE *sub_5159C();
int __fastcall sub_515C0(const void *a1, const void *a2, int a3, const void *a4);
const char *__fastcall sub_51630(const char *a1, int *a2, int a3);
void *sub_51740();
unsigned int __fastcall sub_5177C(int a1, int a2);
void *sub_517F0();
int __fastcall sub_51814(int a1, char *a2, int a3);
int sub_51894();
int __fastcall sub_518B4(int a1);
int __fastcall sub_518C4(int a1, int a2);
int sub_51920();
int sub_51950();
char *__fastcall sub_519AC(char *result, char *dest, int a3);
int __fastcall sub_51A00(const char *a1, char *a2, int a3);
unsigned __int8 *__fastcall sub_51B48(unsigned __int8 *a1, unsigned int *a2, _DWORD *a3);
int __fastcall sub_51CCC(int a1);
char *__fastcall sub_51F9C(char *src, int a2, int a3);
int __fastcall sub_52108(const char *a1);
const char *__fastcall sub_521B8(char *src);
int __fastcall sub_522A0(int a1);
int sub_522E8();
int __fastcall sub_5232C(int a1, int a2, int a3);
int __fastcall sub_524D4(int a1, int a2);
unsigned int __fastcall sub_52554(unsigned int a1, int a2);
unsigned int __fastcall sub_525A0(const char *a1, int a2, int a3);
int __fastcall sub_52FF8(int a1, int a2, int a3);
int __fastcall sub_54414(unsigned int *a1, char **a2, int c);
int __fastcall sub_54680(int a1, char *const *a2);
bool __fastcall sub_54940(int a1, int a2, int a3);
bool __fastcall sub_5495C(int a1, int a2, int a3);
bool __fastcall sub_54978(int a1, int a2, int a3);
int __fastcall sub_549C8(char *s, int a2);
int __fastcall sub_54A70(const char *a1);
_BYTE *__fastcall sub_54A80(int *a1, size_t a2, int a3);
bool __fastcall sub_54AE8(char *name, int a2, int a3);
unsigned int __fastcall sub_54B18(const char *a1, int a2, int a3);
bool __fastcall sub_54BD4(_DWORD *a1, const char *a2);
int __fastcall sub_54D10(const char *a1, int a2, _DWORD *a3);
int __fastcall sub_54DA4(int a1, _DWORD *a2);
int __fastcall sub_55398(int result, int a2, int a3);
int __fastcall sub_55478(FILE *a1, int a2, int a3);
int __fastcall sub_55A24(const char *a1, int a2, _DWORD *a3);
unsigned int __fastcall sub_55AFC(int a1, char **a2);
tcflag_t __fastcall sub_55F3C(int a1);
const char *__fastcall sub_55F84(int a1, int a2, const char *a3);
char *__fastcall sub_56078(int a1, int a2, char *s);
const char *__fastcall sub_560F0(int a1, int a2, char *s);
int __fastcall sub_56258(int a1, int a2, int a3);
int __fastcall sub_563E4(int a1, char **a2);
int sub_56724();
int __fastcall sub_567A0(int a1, char **a2, unsigned int a3);
unsigned int sub_568D8();
int sub_568E4();
char *__fastcall sub_56964(char a1, char *s2, const char *a3);
void __fastcall __noreturn sub_56A1C(int a1);
int sub_56A58();
_DWORD *__fastcall sub_56A78(__pid_t a1);
__sighandler_t sub_56AC4();
void sub_56B2C(char a1, const char *a2, ...);
void sub_56BF0();
int __fastcall sub_56DB8(const char *a1);
void __fastcall sub_56E24(const char *a1);
__pid_t __fastcall sub_56F5C(int a1);
__pid_t __fastcall sub_57070(__pid_t result);
void sub_57118();
int sub_57190();
int __fastcall sub_57350(int a1, const char **a2);
bool __fastcall sub_576AC(FILE *a1);
bool sub_57700();
int __fastcall sub_57710(int a1);
int nullsub_1(); // weak
_BYTE *__fastcall sub_57750(int a1, unsigned int a2, int a3);
_BYTE *__fastcall sub_578F0(int a1);
unsigned int __fastcall sub_57900(int a1, unsigned int a2);
int __fastcall sub_57910(int *a1);
signed int __fastcall sub_57988(signed int a1);
void *__fastcall sub_579BC(int *a1, void *a2);
int __fastcall sub_57A54(int a1, struct sockaddr *a2, socklen_t a3);
struct passwd *__fastcall sub_57A70(const char *a1);
struct group *__fastcall sub_57A94(const char *a1);
struct passwd *__fastcall sub_57AB8(__uid_t a1);
char *__fastcall sub_57ADC(__uid_t a1);
struct passwd *__fastcall sub_57AEC(__uid_t a1);
struct group *__fastcall sub_57B00(__gid_t a1);
struct passwd *__fastcall sub_57B14(__uid_t a1);
struct group *__fastcall sub_57B34(__gid_t a1);
__uid_t __fastcall sub_57B54(const char *a1);
__gid_t __fastcall sub_57B64(const char *a1);
int __fastcall sub_57B74(const char *a1, int (__fastcall *a2)(const char *));
unsigned int __fastcall sub_57BB4(const char *a1, unsigned int a2);
int __fastcall sub_57C28(int *a1);
__uid_t __fastcall sub_57CD8(int a1);
const char *__fastcall sub_57D48(const char *a1);
char *__fastcall sub_57D64(const char *a1, _BYTE *a2);
int __fastcall sub_57DA4(char *name, char a2);
int __fastcall sub_57E30(const char *a1, char *a2, int a3);
char *__fastcall sub_5848C(int a1, char *buffer);
int __fastcall sub_58510(int a1, char *a2);
int __fastcall sub_58570(int a1, unsigned int a2, int a3);
int __fastcall sub_585DC(int a1);
_DWORD *__fastcall sub_585EC(_DWORD *result, int a2);
_DWORD *sub_58678();
unsigned int __fastcall sub_58684(unsigned int result, unsigned __int8 *a2, int a3, int a4);
unsigned int __fastcall sub_586A4(unsigned int result, char *a2, int a3, int a4);
int __fastcall sub_586C8(int a1, int a2);
unsigned __int8 *__fastcall sub_5871C(unsigned __int8 *result);
bool __fastcall sub_58760(const char *a1);
char *__fastcall sub_587B4(_BYTE *a1, char **a2);
void __fastcall __noreturn sub_58840(const char **argv);
int __fastcall sub_5888C(FILE *a1);
void __fastcall __noreturn sub_588D8(char a1);
char *__fastcall sub_58910(FILE *a1, char *s, int a3, signed int *a4);
char *__fastcall sub_589FC(FILE *a1, char *a2, signed int a3);
struct mntent *__fastcall sub_58A20(const char *a1, int a2);
void *__fastcall sub_58B44(const char *a1);
void *__fastcall sub_58C58(FILE *stream, _DWORD *a2);
void *__fastcall sub_58D10(FILE *a1, int a2, int a3);
_BYTE *__fastcall sub_58D24(FILE *a1, int a2, int a3);
char *sub_58D5C();
int __fastcall sub_58DBC(char **a1, const char *a2, const char *a3, int *a4);
int sub_593CC(char **a1, const char *a2, ...);
int sub_593F8(char **a1, const char *a2, const char *a3, ...);
const char *__fastcall sub_59420(const char **a1);
_DWORD *__fastcall sub_59468(_DWORD *result);
int __fastcall sub_597A4(int a1, int a2);
unsigned int __fastcall sub_5981C(int a1);
_DWORD *__fastcall sub_59C58(_DWORD *result);
_DWORD *__fastcall sub_59E14(_DWORD *result);
int __fastcall sub_59FE0(int result);
void *__fastcall sub_5A024(int a1, char *src, size_t n);
int __fastcall sub_5A08C(int a1, _DWORD *a2);
int __fastcall sub_5A0C4(int a1);
int __fastcall sub_5A10C(int a1);
void *__fastcall sub_5A150(__int64 *a1, char *src, size_t n);
size_t __fastcall sub_5A1E8(int a1, void *a2);
int __fastcall sub_5A248(int a1, _DWORD *a2);
char *__fastcall sub_5A318(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __fastcall sub_5A454(unsigned __int8 *a1, _WORD *a2);
int __fastcall sub_5A500(unsigned __int16 *a1, int a2);
int __fastcall sub_5A53C(const char *a1, struct in_addr *a2);
char *__fastcall sub_5A5B0(int a1, unsigned int a2, int a3);
int __fastcall sub_5A6C0(int a1);
unsigned int __fastcall sub_5A754(int a1, char *s);
void sub_5A7F4();
bool __fastcall sub_5A854(int a1, int a2);
int __fastcall sub_5A898(unsigned int a1, unsigned int a2);
int sub_5A8E8();
bool __fastcall sub_5A944(unsigned int a1);
_WORD *__fastcall sub_5A974(_WORD *result, int a2, int a3);
int __fastcall sub_5A9A4(int a1);
int sub_5ACDC();
unsigned int __fastcall sub_5ACE4(unsigned int result);
unsigned int sub_5ADB8();
void sub_5AE2C();
int sub_5AE74();
int sub_5AEC8();
void sub_5AF1C();
void sub_5AF68();
size_t __fastcall sub_5AFAC(_DWORD *a1);
void sub_5B0F4();
_BYTE *sub_5B1C8();
unsigned int __fastcall sub_5B25C(int a1);
unsigned int __fastcall sub_5B2AC(unsigned __int8 *a1);
int sub_5B628();
int sub_5B698();
int __fastcall sub_5B6B4(int a1);
int __fastcall sub_5B7A4(int result);
void sub_5B81C();
int sub_5B900();
void sub_5B970();
int sub_5B9F0();
int sub_5BA14();
unsigned int __fastcall sub_5BA4C(int a1, unsigned int a2, int a3);
unsigned int __fastcall sub_5BA98(int a1, int a2, int a3);
int __fastcall sub_5BAEC(int result, int a2);
unsigned int __fastcall sub_5BB38(unsigned int result);
unsigned int sub_5BBE0();
size_t __fastcall sub_5BC10(const char *a1);
_BYTE *__fastcall sub_5BC3C(const char *a1);
size_t __fastcall sub_5BCA8(const char *a1, int a2);
int __fastcall sub_5BF98(char *a1, int a2);
void __fastcall sub_5BFD8(_DWORD *a1);
_DWORD *__fastcall sub_5C3B4(int a1);
int __fastcall sub_5C3DC(int result);
size_t __fastcall sub_5C41C(int a1, unsigned __int8 *a2, char *a3, int a4);
_DWORD *__fastcall sub_5D2A0(int *a1, int a2);
_DWORD *__fastcall sub_5D2C8(_DWORD *a1, int a2);
int __fastcall sub_5D2FC(_DWORD **a1);
int __fastcall sub_5D328(int a1, struct utsname *a2);
void sub_5D4C4();
int sub_5D500();
int __fastcall sub_5D55C(int a1);
int __fastcall sub_5D594(char **a1, const char *a2, int a3, int a4, int a5);
int __fastcall sub_5D824(char *path, __mode_t a2, int a3);
unsigned __int64 j_gnu_dev_makedev(unsigned int major, unsigned int minor);
int __fastcall sub_5D9F8(int a1, unsigned __int8 *a2);
char *__fastcall sub_5DA78(int a1);
_BYTE *__fastcall sub_5DB1C(_BYTE *result);
bool __fastcall sub_5DB40(int a1, int a2);
int __fastcall sub_5DB80(const char *a1, int a2);
int __fastcall sub_5DBFC(_BYTE *a1, const char *a2, int *a3);
_DWORD *__fastcall sub_5DDC4(int a1, int (*a2)(void));
void __fastcall sub_5DDEC(int a1);
int __fastcall sub_5DE1C(_DWORD *a1, void *a2, int a3, const char *a4);
unsigned int __fastcall sub_5E0F4(const char *a1, unsigned int nptr);
void __noreturn sub_5E304();
int __fastcall sub_5E30C(int result);
int __fastcall sub_5E3AC(int a1, char *s, int a3, const char *a4);
int __fastcall sub_5E42C(int a1, int a2);
int __fastcall sub_5E4E0(__int16 a1, FILE *stream);
unsigned int __fastcall sub_5E550(unsigned int result, _BYTE *a2, char a3);
const char *__fastcall sub_5E5D0(int *a1, _BYTE *a2);
int __fastcall sub_5E668(unsigned __int8 **a1);
_BYTE *__fastcall sub_5E730(_BYTE *a1, unsigned __int8 *a2, unsigned __int8 *a3);
int __fastcall sub_5E780(int a1, int a2, int (__fastcall *a3)(int));
ssize_t __fastcall sub_5E80C(int a1, void *a2);
void sub_5E854();
int __fastcall sub_5E890(int a1);
int __fastcall sub_5E8A8(int a1);
void __fastcall sub_5E8C0(int a1);
char *__fastcall sub_5E8EC(char *a1, int a2);
char *__fastcall sub_5EBFC(char *a1, signed int a2, int a3, const char *a4);
int __fastcall sub_5ED54(char a1);
_BYTE *__fastcall sub_5ED94(_BYTE *result, unsigned int a2, int a3);
unsigned int __fastcall sub_5EDC8(unsigned int a1);
int __fastcall sub_5EE14(int a1, unsigned int a2);
char *__fastcall sub_5EE50(char *a1, char *a2, char *a3);
_BYTE *__fastcall sub_5F09C(const char *a1, char *s);
unsigned __int8 *__fastcall sub_5F5A4(int *a1, unsigned __int8 *a2, _BYTE *a3, unsigned __int8 *a4);
int __fastcall sub_5FB14(int a1, int a2);
int __fastcall sub_5FB7C(_BYTE *a1, const char *a2);
void *__fastcall sub_5FBFC(char *a1, char *a2, int a3);
int __fastcall sub_60068(int fd, char *a2, int a3);
ssize_t __fastcall sub_60320(int fd, void *buf, size_t nbytes);
void *__fastcall sub_60388(int a1, unsigned int *a2);
ssize_t __fastcall sub_60448(ssize_t result, char *a2, size_t a3);
int sub_6046C();
int __fastcall sub_60474(const char *a1, int a2, int (*a3)(), int (*a4)(), int a5, int a6);
int __fastcall sub_6065C(const char *a1, int a2);
int __fastcall sub_608E0(const char *a1, char *s);
char *__fastcall sub_60924(const char *a1, int a2, char *s, const char *a4);
void __fastcall __noreturn sub_609D8(const char *a1, int a2, int *a3);
void *sub_60AA0();
int __fastcall sub_60AD4(struct pollfd *fds, nfds_t nfds, int timeout); // idb
char *__fastcall sub_60B34(char *result, const char *a2, int a3);
int __fastcall sub_60B4C(int result, int a2);
char *__fastcall sub_60B70(const char *a1);
const char *__fastcall sub_60C00(const char *result, char a2, int a3);
_BYTE *__fastcall sub_60D24(_BYTE *a1);
char *__fastcall sub_60DE0(char *a1);
int __fastcall sub_60E30(int a1);
unsigned __int8 *__fastcall sub_60E74(unsigned __int8 *a1);
unsigned __int8 *__fastcall sub_60E94(unsigned __int8 *a1);
unsigned __int8 *__fastcall sub_60EB8(unsigned __int8 *a1);
int __fastcall sub_60ED8(int a1);
int __fastcall sub_60F24(int a1);
unsigned int sub_60F68();
int sub_60F80();
char *__fastcall sub_60F88(char *a1);
unsigned int __fastcall sub_61000(const char *a1);
char *__fastcall sub_61144(unsigned int a1);
int sub_61174();
int __fastcall sub_611D0(const char *a1, const char *a2, const char *a3);
int sub_6156C();
int __fastcall sub_615A0(__pid_t a1, __int16 a2, unsigned __int8 *a3, const char *a4, const char *a5);
void __fastcall sub_61694(__pid_t a1, int a2, unsigned __int8 *a3, const char *a4, const char *a5);
void __fastcall sub_617C8(__pid_t a1);
_BYTE *__fastcall sub_617E8(_BYTE *result, int a2, int a3, int a4);
_BYTE *__fastcall sub_618B0(_BYTE **a1, _BYTE *a2, int a3);
int __fastcall sub_61998(FILE *stream, FILE *a2, __int16 a3);
__pid_t __fastcall sub_61AB4(const char **a1);
int __fastcall sub_61B38(const char **a1);
int __fastcall sub_61B48(char a1);
int sub_61C40();
FILE *__fastcall sub_61C48(unsigned int a1);
int __fastcall sub_61C78(const char *a1, int a2);
int __fastcall sub_61C9C(int a1);
int __fastcall sub_61CA8(const char *a1);
int __fastcall sub_61CB4(int a1);
int __fastcall sub_61CC0(const char *a1);
FILE *__fastcall sub_61CCC(int a1);
int __fastcall sub_61CD8(int a1);
int __fastcall sub_61D20(int a1);
int __fastcall sub_61D34(int a1);
int __fastcall sub_61D6C(int a1);
unsigned __int64 __fastcall sub_61D80(const char *a1, int base, unsigned __int64 a3, unsigned __int64 a4, int a5);
unsigned __int64 __fastcall sub_61EE8(const char *a1, int a2);
unsigned int __fastcall sub_61F14(const char *a1, int base, unsigned int a3, unsigned int a4, int a5);
unsigned int __fastcall sub_62034(const char *a1, int a2, unsigned int a3, unsigned int a4);
unsigned int __fastcall sub_6204C(const char *a1, unsigned int a2, unsigned int a3, int a4);
unsigned int __fastcall sub_6206C(const char *a1, unsigned int a2, unsigned int a3);
unsigned int __fastcall sub_62090(const char *a1, int a2);
unsigned int __fastcall sub_620B0(const char *a1);
signed int __fastcall sub_620B8(const char *a1, int a2, signed int a3, signed int a4, int a5);
signed int __fastcall sub_62154(const char *a1, signed int a2, signed int a3);
signed int __fastcall sub_62178(const char *a1);
unsigned int __fastcall sub_6219C(const char *a1);
int __fastcall sub_621A8(const char *a1);
_WORD *__fastcall sub_621C0(const char *a1, unsigned int a2, int a3);
char *__fastcall sub_62364(const struct sockaddr *a1, int a2);
int __fastcall sub_623D0(int a1, int a2, int a3, int a4);
int __fastcall sub_623F4(int a1, int a2, int a3);
int __fastcall sub_623FC(int a1, int a2, int a3);
int __fastcall sub_62414(int a1);
void sub_6241C();
int __fastcall sub_62424(int a1, const char *a2);
_WORD *__fastcall sub_6247C(const char *a1, unsigned int a2);
_WORD *__fastcall sub_62484(const char *a1, unsigned int a2);
_WORD *__fastcall sub_6248C(const char *a1, unsigned int a2);
char *__fastcall sub_62494(const struct sockaddr *a1);
char *__fastcall sub_6249C(const struct sockaddr *a1);
void *__fastcall sub_624A4(void *a1);
struct hostent *__fastcall sub_62520(const char *a1);
char *__fastcall sub_62544(void *a1, unsigned int a2, int a3);
char *__fastcall sub_62594(regex_t *a1, const char *a2, int a3);
char *__fastcall sub_625E4(regex_t *a1, const char *a2, int a3);
int __fastcall sub_62608(const char **a1, const char **a2);
void __fastcall sub_62614(void *a1, size_t a2);
void __noreturn sub_62624(const char *a1, ...);
void sub_62654();
int __fastcall sub_6265C(__uid_t *a1, char *s);
int __fastcall sub_62768(__uid_t *a1, char *a2);
__uid_t __fastcall sub_6278C(__uid_t *a1, char *s);
int __fastcall sub_62B38(__int64 a1);
int __fastcall sub_62B48(__int64 a1);
int __fastcall sub_62BA4(signed __int64 a1, signed __int64 a2);
int __fastcall sub_62C44(unsigned __int64 a1, unsigned __int64 a2);
unsigned int __fastcall sub_62C80(double a1);
int __fastcall sub_62CA4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall init(int a1, int a2, int a3);
int nullsub_3(); // weak
int sub_62DFC();
int sub_62E08();
int sub_62E14();
int __fastcall sub_62E20(char *path, __mode_t mode, __dev_t a3);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

int dword_10080 = 65876; // weak
int dword_10120 = 0; // weak
int elf_hash_bucket[263] =
{
  0,
  163,
  0,
  0,
  0,
  261,
  281,
  263,
  232,
  39,
  249,
  0,
  224,
  300,
  0,
  308,
  304,
  0,
  0,
  264,
  46,
  0,
  0,
  280,
  113,
  0,
  47,
  279,
  0,
  0,
  38,
  76,
  74,
  108,
  15,
  0,
  90,
  0,
  0,
  0,
  203,
  124,
  0,
  306,
  217,
  176,
  296,
  228,
  243,
  213,
  242,
  222,
  63,
  277,
  295,
  172,
  202,
  136,
  0,
  130,
  0,
  0,
  294,
  149,
  31,
  231,
  102,
  262,
  292,
  221,
  148,
  206,
  233,
  42,
  0,
  0,
  252,
  260,
  61,
  185,
  78,
  4,
  205,
  92,
  0,
  48,
  16,
  106,
  158,
  112,
  0,
  237,
  37,
  196,
  173,
  0,
  0,
  164,
  0,
  255,
  0,
  178,
  278,
  0,
  303,
  3,
  0,
  0,
  250,
  0,
  245,
  9,
  0,
  41,
  259,
  0,
  0,
  288,
  301,
  211,
  266,
  88,
  195,
  0,
  0,
  0,
  0,
  275,
  271,
  197,
  34,
  179,
  257,
  0,
  284,
  305,
  116,
  208,
  293,
  0,
  129,
  160,
  297,
  291,
  0,
  282,
  302,
  21,
  0,
  159,
  89,
  0,
  240,
  80,
  258,
  220,
  0,
  0,
  0,
  225,
  0,
  0,
  53,
  151,
  154,
  25,
  0,
  155,
  285,
  146,
  265,
  40,
  236,
  0,
  0,
  0,
  0,
  273,
  0,
  0,
  241,
  0,
  100,
  0,
  49,
  0,
  219,
  0,
  104,
  283,
  230,
  0,
  274,
  123,
  147,
  0,
  270,
  307,
  269,
  253,
  286,
  0,
  85,
  194,
  122,
  126,
  139,
  52,
  0,
  299,
  0,
  174,
  235,
  0,
  251,
  26,
  182,
  198,
  27,
  144,
  0,
  256,
  0,
  75,
  193,
  137,
  175,
  227,
  120,
  0,
  272,
  290,
  84,
  239,
  0,
  0,
  212,
  187,
  119,
  0,
  276,
  99,
  169,
  234,
  0,
  226,
  210,
  216,
  214,
  0,
  229,
  69,
  166,
  6,
  267,
  0,
  298,
  0,
  56,
  2,
  0,
  186,
  0
}; // weak
int elf_hash_chain[309] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  23,
  0,
  0,
  17,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  0,
  18,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  22,
  0,
  77,
  0,
  59,
  32,
  0,
  0,
  64,
  0,
  0,
  0,
  0,
  71,
  86,
  45,
  0,
  0,
  0,
  0,
  0,
  0,
  57,
  0,
  0,
  0,
  0,
  0,
  97,
  0,
  73,
  0,
  0,
  0,
  0,
  0,
  0,
  114,
  7,
  0,
  0,
  0,
  82,
  96,
  109,
  58,
  79,
  101,
  110,
  30,
  36,
  0,
  60,
  35,
  0,
  0,
  0,
  0,
  0,
  83,
  0,
  0,
  12,
  0,
  67,
  0,
  0,
  0,
  0,
  0,
  68,
  0,
  121,
  135,
  0,
  0,
  81,
  70,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  1,
  65,
  131,
  0,
  0,
  20,
  0,
  0,
  72,
  0,
  157,
  19,
  0,
  141,
  125,
  0,
  0,
  51,
  0,
  55,
  0,
  0,
  127,
  138,
  0,
  44,
  0,
  111,
  0,
  43,
  94,
  0,
  0,
  170,
  98,
  0,
  0,
  183,
  11,
  103,
  177,
  0,
  0,
  162,
  107,
  105,
  171,
  0,
  167,
  54,
  117,
  93,
  152,
  161,
  0,
  0,
  0,
  0,
  133,
  0,
  0,
  33,
  150,
  190,
  134,
  0,
  223,
  0,
  153,
  0,
  168,
  204,
  0,
  0,
  145,
  184,
  0,
  91,
  165,
  0,
  143,
  0,
  0,
  181,
  189,
  192,
  87,
  0,
  5,
  0,
  0,
  0,
  0,
  95,
  0,
  207,
  0,
  0,
  0,
  200,
  218,
  199,
  0,
  254,
  50,
  156,
  0,
  268,
  191,
  29,
  0,
  0,
  0,
  128,
  0,
  142,
  0,
  13,
  248,
  115,
  0,
  238,
  0,
  209,
  0,
  215,
  132,
  14,
  247,
  289,
  140,
  246,
  0,
  66,
  244,
  0,
  0,
  118,
  0,
  287,
  180,
  0,
  0,
  201,
  62,
  188
}; // weak
Elf32_Sym stru_10DFC = { 240u, 0u, 0u, 18u, 0u, 0u }; // weak
_UNKNOWN loc_15CD8; // weak
_UNKNOWN loc_15F60; // weak
_UNKNOWN loc_162F8; // weak
_UNKNOWN main;
_UNKNOWN loc_2A270; // weak
_UNKNOWN unk_62E48; // weak
int (*off_630C8[2])() = { &sub_48A14, &sub_48A14 }; // weak
_UNKNOWN *off_632B4 = (_UNKNOWN *)0x64A30; // weak
_UNKNOWN unk_632C8; // weak
char *off_632CC = "SIFMETRIC"; // weak
char *off_6330C = "SIFADDR"; // weak
char *off_63314 = "metric"; // weak
_UNKNOWN unk_63398; // weak
_UNKNOWN unk_633C4; // weak
char *off_633DC[7] = { "unknown", "10base2", "10baseT", "AUI", "100baseT", "100baseTX", "100baseFX" }; // weak
char *off_63468[5] =
{
  "%n%llu%u%u%u%u%n%n%n%llu%u%u%u%u%u",
  "%llu%llu%u%u%u%u%n%n%llu%llu%u%u%u%u%u",
  "%llu%llu%u%u%u%u%u%u%llu%llu%u%u%u%u%u%u",
  "unspec",
  "UNSPEC"
}; // weak
void (__noreturn *off_634C0)() = &sub_1D814; // weak
char *off_634D4[5] = { "STREAM", "DGRAM", "RAW", "RDM", "SEQPACKET" }; // weak
_UNKNOWN *off_634E8 = (_UNKNOWN *)0x6B39E; // weak
_UNKNOWN unk_63564; // weak
char *off_63580[3] = { "none", "redirect", "kernel" }; // weak
char *off_635B0[2] = { "bird", "3." }; // weak
char *off_635B4 = "3."; // weak
char *off_635FC = "2command"; // weak
char *off_63614 = "3eval"; // weak
char *off_6361C = "3exec"; // weak
_UNKNOWN off_63714; // weak
char *off_6371C[13] =
{
  "eerrexit",
  "fnoglob",
  "Iignoreeof",
  "iinteractive",
  "mmonitor",
  "nnoexec",
  "sstdin",
  "xxtrace",
  "vverbose",
  "Cnoclobber",
  "aallexport",
  "bnotify",
  "unounset"
}; // weak
_UNKNOWN *off_63758 = (_UNKNOWN *)0x693DA; // weak
_UNKNOWN *off_6378C = (_UNKNOWN *)0x6B864; // weak
_UNKNOWN unk_637D0; // weak
char *off_638A4 = "/var/log/messages"; // weak
_DWORD dword_638F0[40] =
{
  0,
  0,
  536870912,
  1073741824,
  1073741824,
  0,
  2,
  -3,
  -5,
  4,
  -9,
  8,
  16,
  128,
  -17,
  -1025,
  1024,
  -2049,
  2048,
  64,
  -65,
  2097152,
  -2097153,
  16777216,
  -32769,
  20480,
  256,
  4096,
  8192,
  1048576,
  524288,
  262144,
  131072,
  1064960,
  540672,
  278528,
  147456,
  1,
  -2,
  32
}; // weak
_DWORD dword_63990[14] =
{
  1,
  4,
  13,
  40,
  121,
  364,
  1093,
  3280,
  9841,
  29524,
  88573,
  265720,
  797161,
  2391484
}; // weak
_DWORD dword_639C8[3] = { 4096, 8192, 24576 }; // weak
_UNKNOWN unk_639D4; // weak
_UNKNOWN unk_639FC; // weak
_UNKNOWN unk_63A04; // weak
_UNKNOWN unk_63A0C; // weak
_UNKNOWN unk_63A14; // weak
_UNKNOWN unk_63A1C; // weak
_UNKNOWN unk_63A24; // weak
_UNKNOWN unk_63A2C; // weak
_UNKNOWN unk_63A34; // weak
_UNKNOWN unk_63A3C; // weak
_UNKNOWN unk_63A44; // weak
_UNKNOWN unk_63A4C; // weak
_UNKNOWN unk_63A54; // weak
_UNKNOWN unk_63A5C; // weak
_UNKNOWN unk_63A64; // weak
_UNKNOWN unk_63A6C; // weak
_UNKNOWN unk_63A74; // weak
_UNKNOWN unk_63A7C; // weak
_UNKNOWN unk_63CC4; // weak
_UNKNOWN unk_63CE4; // weak
_UNKNOWN unk_63E74; // weak
_DWORD dword_63EA4[3] = { -839974621, 1126301404, 19088743 }; // weak
_DWORD dword_63EB0[3] = { 10, 12, 15 }; // weak
char *off_63EBC[5] = { "chown", "dac_override", "dac_read_search", "fowner", "fsetid" }; // weak
_UNKNOWN *off_63F54 = (_UNKNOWN *)0x6AE7E; // weak
_UNKNOWN unk_63F5C; // weak
_UNKNOWN unk_63F7C; // weak
_UNKNOWN unk_63FBC; // weak
_UNKNOWN unk_63FFC; // weak
_UNKNOWN unk_6403C; // weak
_DWORD dword_6406C[10] =
{
  0,
  0,
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
}; // weak
_DWORD dword_64094[10] =
{
  0,
  0,
  -205731576,
  -2067093701,
  -23791573,
  1595750129,
  -1377402159,
  725511199,
  -79577749,
  327033209
}; // weak
_DWORD dword_640BC[4] = { 1518500249, 1859775393, -1894007588, -899497514 }; // weak
_DWORD dword_640CC[6] = { 292, 146, 73, 73, 3072, 512 }; // weak
_DWORD dword_640E4[4] = { 4095, 2496, 1080, 7 }; // weak
_DWORD dword_640F4[32] =
{
  2147483648,
  1073741824,
  536870912,
  268435456,
  134217728,
  67108864,
  33554432,
  16777216,
  8388608,
  4194304,
  2097152,
  1048576,
  524288,
  262144,
  131072,
  65536,
  32768,
  16384,
  8192,
  4096,
  2048,
  1024,
  512,
  256,
  128,
  64,
  32,
  16,
  8,
  4,
  2,
  1
}; // weak
_UNKNOWN unk_64174; // weak
_UNKNOWN unk_641AC; // weak
_UNKNOWN unk_64214; // weak
unsigned __int16 word_64294[15] =
{
  0u,
  16u,
  32u,
  4096u,
  4112u,
  48u,
  4u,
  2u,
  1u,
  64u,
  128u,
  8u,
  256u,
  512u,
  1024u
}; // weak
_UNKNOWN unk_642B2; // weak
_WORD word_642CE[3] = { 512, 32, 16 }; // weak
_UNKNOWN unk_642D4; // weak
_UNKNOWN unk_642E0; // weak
_UNKNOWN unk_64306; // weak
int dword_64308 = -1; // weak
unsigned __int16 word_6430E[12] =
{
  61165u,
  13u,
  4369u,
  3264u,
  84u,
  28791u,
  1283u,
  36877u,
  40973u,
  11298u,
  24678u,
  32904u
}; // weak
_UNKNOWN unk_64326; // weak
_UNKNOWN unk_64362; // weak
unsigned __int16 word_643A0[17] =
{
  0u,
  1u,
  3u,
  7u,
  15u,
  31u,
  63u,
  127u,
  255u,
  511u,
  1023u,
  2047u,
  4095u,
  8191u,
  16383u,
  32767u,
  65535u
}; // weak
unsigned __int8 byte_643C2[30] =
{
  3u,
  0u,
  28u,
  1u,
  127u,
  2u,
  21u,
  3u,
  4u,
  4u,
  0u,
  11u,
  0u,
  16u,
  0u,
  7u,
  17u,
  8u,
  19u,
  9u,
  26u,
  10u,
  18u,
  12u,
  23u,
  14u,
  22u,
  15u,
  15u,
  13u
}; // weak
_UNKNOWN unk_643E0; // weak
_UNKNOWN unk_643E2; // weak
_UNKNOWN unk_643E4; // weak
unsigned __int16 word_643F4[5] = { 251u, 1021u, 4093u, 16381u, 65521u }; // weak
unsigned __int16 word_643FE[62] =
{
  0u,
  0u,
  1u,
  50u,
  2u,
  75u,
  3u,
  110u,
  4u,
  134u,
  5u,
  150u,
  6u,
  200u,
  7u,
  300u,
  8u,
  600u,
  9u,
  1200u,
  10u,
  1800u,
  11u,
  2400u,
  12u,
  4800u,
  13u,
  9600u,
  14u,
  19200u,
  15u,
  32960u,
  4097u,
  33056u,
  4098u,
  33344u,
  4099u,
  33920u,
  4100u,
  35072u,
  4102u,
  35648u,
  4103u,
  37376u,
  4105u,
  38528u,
  4101u,
  35268u,
  4104u,
  37768u,
  4106u,
  40268u,
  4107u,
  42768u,
  4108u,
  45268u,
  4109u,
  47768u,
  4110u,
  50268u,
  4111u,
  52768u
}; // weak
unsigned __int8 byte_6447A[62] =
{
  51u,
  17u,
  19u,
  51u,
  17u,
  65u,
  19u,
  51u,
  17u,
  51u,
  17u,
  19u,
  49u,
  52u,
  51u,
  17u,
  51u,
  66u,
  18u,
  50u,
  19u,
  35u,
  34u,
  34u,
  18u,
  51u,
  17u,
  16u,
  49u,
  49u,
  19u,
  19u,
  17u,
  17u,
  17u,
  51u,
  51u,
  19u,
  18u,
  19u,
  49u,
  35u,
  17u,
  18u,
  51u,
  17u,
  49u,
  49u,
  18u,
  51u,
  33u,
  19u,
  51u,
  19u,
  19u,
  51u,
  18u,
  49u,
  17u,
  51u,
  51u,
  3u
}; // weak
_UNKNOWN unk_644B8; // weak
char a0123456789abcd[17] = "0123456789ABCDEF"; // weak
const char reject = '\x01'; // idb
_UNKNOWN unk_65759; // weak
const char asc_662A2[] = "\a"; // idb
const char asc_662B1[] = "\t"; // idb
char byte_66319[21] =
{
  '\x06',
  '\x01',
  'a',
  'd',
  'd',
  '\0',
  '\x06',
  '\x02',
  'd',
  'e',
  'l',
  '\0',
  '\b',
  '\x02',
  'd',
  'e',
  'l',
  'e',
  't',
  'e',
  '\0'
}; // weak
_BYTE byte_6632E[3] = { 2, 10, 17 }; // weak
unsigned __int8 byte_66EEC[14] = { 0u, 17u, 34u, 1u, 1u, 5u, 7u, 12u, 13u, 0u, 36u, 65u, 1u, 17u }; // weak
_UNKNOWN unk_67632; // weak
_UNKNOWN unk_67633; // weak
_BYTE byte_67678[14] = { 0, 4, 8, 1, 1, 1, 2, 4, 4, 0, 5, 12, 1, 1 }; // weak
const char accept[4] = "*?[\\"; // idb
_UNKNOWN unk_67F99; // weak
_UNKNOWN unk_67F9A; // weak
unsigned __int8 byte_681B5[27] =
{
  24u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  24u,
  16u,
  16u,
  16u,
  16u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  16u,
  16u,
  8u
}; // weak
char aOgutmout[9] = "oguTMOUT"; // weak
_UNKNOWN unk_6828A; // weak
_UNKNOWN unk_6828B; // weak
_UNKNOWN unk_68406; // weak
_UNKNOWN unk_68407; // weak
_UNKNOWN unk_68408; // weak
unsigned __int8 byte_68671[25] =
{
  1u,
  2u,
  1u,
  3u,
  4u,
  5u,
  1u,
  6u,
  7u,
  8u,
  3u,
  3u,
  3u,
  1u,
  1u,
  3u,
  1u,
  3u,
  3u,
  9u,
  3u,
  10u,
  1u,
  11u,
  3u
}; // weak
_UNKNOWN unk_6869A; // weak
_UNKNOWN unk_68703; // weak
unsigned __int8 byte_6875A[10] = { 1u, 9u, 10u, 5u, 8u, 4u, 0u, 6u, 7u, 11u }; // weak
_UNKNOWN unk_6885F; // weak
_UNKNOWN unk_68860; // weak
char aEtcFilesystems[17] = "/etc/filesystems"; // weak
const char asc_68F41[] = "+"; // idb
const char aTxcFOopvkchtXZ[] = "^txC:f:OopvkchT:*X:*zm"; // idb
unsigned __int8 byte_6937F[19] =
{
  16u,
  17u,
  18u,
  0u,
  8u,
  7u,
  9u,
  6u,
  10u,
  5u,
  11u,
  4u,
  12u,
  3u,
  13u,
  2u,
  14u,
  1u,
  15u
}; // weak
_UNKNOWN unk_69392; // weak
_UNKNOWN unk_693B0; // weak
const char a0123456789[] = "0123456789"; // idb
unsigned __int8 byte_69AE3[51] =
{
  0u,
  124u,
  0u,
  0u,
  47u,
  0u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  61u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  1u,
  7u,
  1u,
  7u,
  1u,
  7u,
  0u,
  7u,
  1u,
  7u,
  1u,
  7u,
  7u,
  1u,
  0u,
  31u,
  35u,
  35u,
  37u,
  34u,
  37u,
  35u,
  35u,
  0u,
  37u,
  36u,
  37u,
  35u,
  37u,
  37u,
  32u,
  0u
}; // weak
char asc_6A3C6[2] = "\b"; // weak
char aW_1[2] = "w"; // weak
_UNKNOWN unk_6A482; // weak
_UNKNOWN unk_6A484; // weak
_UNKNOWN unk_6AAC2; // weak
char asc_6AED1[3] = "+-"; // weak
char asc_6AED4[3] = "-+"; // weak
char aIr[5] = "-IR-"; // weak
const char asc_6B2F3[] = "()[]{}"; // idb
const char a0bbeeftLh[14] = "^0bBeEft%$ lh\b"; // idb
const char a0bbeefth[12] = "^%$0bBeEfth\b"; // idb
const char a0bbh[6] = "^0bBh\b"; // idb
char aHpr[4] = "hpr"; // weak
unsigned __int8 byte_6BA6C[3] = { 2u, 2u, 1u }; // weak
_UNKNOWN unk_6BBD2; // weak
_UNKNOWN unk_6BBE2; // weak
_UNKNOWN unk_6BBF2; // weak
char a123456789[11] = " 123456789"; // weak
_UNKNOWN unk_6BC1B; // weak
_UNKNOWN unk_6BC3E; // weak
char aRwxststPcDBLSS[47] = "rwxSTst?pc?d?b?-?l?s???similar to old password"; // weak
_BYTE byte_6BF03[64] =
{
  58,
  50,
  42,
  34,
  26,
  18,
  10,
  2,
  60,
  52,
  44,
  36,
  28,
  20,
  12,
  4,
  62,
  54,
  46,
  38,
  30,
  22,
  14,
  6,
  64,
  56,
  48,
  40,
  32,
  24,
  16,
  8,
  57,
  49,
  41,
  33,
  25,
  17,
  9,
  1,
  59,
  51,
  43,
  35,
  27,
  19,
  11,
  3,
  61,
  53,
  45,
  37,
  29,
  21,
  13,
  5,
  63,
  55,
  47,
  39,
  31,
  23,
  15,
  7
}; // weak
unsigned __int8 byte_6BF43[8] = { 128u, 64u, 32u, 16u, 8u, 4u, 2u, 1u }; // weak
unsigned __int8 byte_6BF4B[48] =
{
  14u,
  17u,
  11u,
  24u,
  1u,
  5u,
  3u,
  28u,
  15u,
  6u,
  21u,
  10u,
  23u,
  19u,
  12u,
  4u,
  26u,
  8u,
  16u,
  7u,
  27u,
  20u,
  13u,
  2u,
  41u,
  52u,
  31u,
  37u,
  47u,
  55u,
  30u,
  40u,
  51u,
  45u,
  33u,
  48u,
  44u,
  49u,
  39u,
  56u,
  34u,
  53u,
  46u,
  42u,
  50u,
  36u,
  29u,
  32u
}; // weak
unsigned __int8 byte_6BF7B[55] =
{
  57u,
  49u,
  41u,
  33u,
  25u,
  17u,
  9u,
  1u,
  58u,
  50u,
  42u,
  34u,
  26u,
  18u,
  10u,
  2u,
  59u,
  51u,
  43u,
  35u,
  27u,
  19u,
  11u,
  3u,
  60u,
  52u,
  44u,
  36u,
  63u,
  55u,
  47u,
  39u,
  31u,
  23u,
  15u,
  7u,
  62u,
  54u,
  46u,
  38u,
  30u,
  22u,
  14u,
  6u,
  61u,
  53u,
  45u,
  37u,
  29u,
  21u,
  13u,
  5u,
  28u,
  20u,
  12u
}; // weak
_UNKNOWN unk_6BFB2; // weak
unsigned __int8 byte_6BFC3[32] =
{
  16u,
  7u,
  20u,
  21u,
  29u,
  12u,
  28u,
  17u,
  1u,
  15u,
  23u,
  26u,
  5u,
  18u,
  31u,
  10u,
  2u,
  8u,
  24u,
  14u,
  32u,
  27u,
  3u,
  9u,
  19u,
  13u,
  30u,
  6u,
  22u,
  11u,
  4u,
  25u
}; // weak
_UNKNOWN unk_6BFEE; // weak
_UNKNOWN unk_6C0EE; // weak
char aExit_0[231] =
{
  'E',
  'X',
  'I',
  'T',
  '\0',
  '\0',
  '\0',
  'H',
  'U',
  'P',
  '\0',
  '\0',
  '\0',
  '\0',
  'I',
  'N',
  'T',
  '\0',
  '\0',
  '\0',
  '\0',
  'Q',
  'U',
  'I',
  'T',
  '\0',
  '\0',
  '\0',
  'I',
  'L',
  'L',
  '\0',
  '\0',
  '\0',
  '\0',
  'T',
  'R',
  'A',
  'P',
  '\0',
  '\0',
  '\0',
  'A',
  'B',
  'R',
  'T',
  '\0',
  '\0',
  '\0',
  'B',
  'U',
  'S',
  '\0',
  '\0',
  '\0',
  '\0',
  'F',
  'P',
  'E',
  '\0',
  '\0',
  '\0',
  '\0',
  'K',
  'I',
  'L',
  'L',
  '\0',
  '\0',
  '\0',
  'U',
  'S',
  'R',
  '1',
  '\0',
  '\0',
  '\0',
  'S',
  'E',
  'G',
  'V',
  '\0',
  '\0',
  '\0',
  'U',
  'S',
  'R',
  '2',
  '\0',
  '\0',
  '\0',
  'P',
  'I',
  'P',
  'E',
  '\0',
  '\0',
  '\0',
  'A',
  'L',
  'R',
  'M',
  '\0',
  '\0',
  '\0',
  'T',
  'E',
  'R',
  'M',
  '\0',
  '\0',
  '\0',
  'S',
  'T',
  'K',
  'F',
  'L',
  'T',
  '\0',
  'C',
  'H',
  'L',
  'D',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'T',
  '\0',
  '\0',
  '\0',
  'S',
  'T',
  'O',
  'P',
  '\0',
  '\0',
  '\0',
  'T',
  'S',
  'T',
  'P',
  '\0',
  '\0',
  '\0',
  'T',
  'T',
  'I',
  'N',
  '\0',
  '\0',
  '\0',
  'T',
  'T',
  'O',
  'U',
  '\0',
  '\0',
  '\0',
  'U',
  'R',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  'X',
  'C',
  'P',
  'U',
  '\0',
  '\0',
  '\0',
  'X',
  'F',
  'S',
  'Z',
  '\0',
  '\0',
  '\0',
  'V',
  'T',
  'A',
  'L',
  'R',
  'M',
  '\0',
  'P',
  'R',
  'O',
  'F',
  '\0',
  '\0',
  '\0',
  'W',
  'I',
  'N',
  'C',
  'H',
  '\0',
  '\0',
  'P',
  'O',
  'L',
  'L',
  '\0',
  '\0',
  '\0',
  'P',
  'W',
  'R',
  '\0',
  '\0',
  '\0',
  '\0',
  'S',
  'Y',
  'S',
  '\0',
  '\0',
  '\0',
  '\0',
  'R',
  'T',
  'M',
  'I',
  'N',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_6C2FD; // weak
_UNKNOWN *off_7CF08 = (_UNKNOWN *)0x162C5; // weak
_UNKNOWN *off_7CF0C = (_UNKNOWN *)0x162AD; // weak
int dword_7D4BC = 1; // weak
_UNKNOWN *off_7D4C0 = (_UNKNOWN *)0x6B0D4; // weak
int dword_7D4C4 = 3; // weak
int dword_7D4C8 = -1; // weak
int dword_7D4CC = -1; // weak
_UNKNOWN *off_7D4D0 = &unk_7D64C; // weak
int dword_7D4D4 = -1; // weak
char *off_7D4E0 = "authpriv"; // weak
char *off_7D598 = "crit"; // weak
char byte_7D5F8 = '\x01'; // weak
_UNKNOWN unk_7D5FC; // weak
int _environ; // weak
int optind; // weak
int stderr; // weak
int stdin; // weak
int stdout; // weak
int optarg; // weak
int dword_7D61C; // weak
int dword_7D620; // weak
int dword_7D624; // weak
int dword_7D628; // weak
int dword_7D62C; // weak
int dword_7D630; // weak
int dword_7D634; // weak
int dword_7D638; // weak
int dword_7D63C; // weak
int dword_7D640; // weak
int dword_7D644; // weak
int dword_7D648; // weak
_UNKNOWN unk_7D64C; // weak
int dword_7D650; // weak
int dword_7D654; // weak
int dword_7D660; // weak
int dword_7D664; // weak
int dword_7D698; // weak
int dword_7D69C; // weak
int dword_7D6A0; // weak
int dword_7D6A4; // weak
int dword_7D6A8; // weak
int dword_7D6AC; // weak
int dword_7D6B0; // weak
int dword_7D6B4; // weak
int dword_7D6B8; // weak
int dword_7D6BC; // weak
int dword_7D6C0; // weak
int dword_7D6C4; // weak
int dword_7D6C8; // weak
int dword_7D6CC; // weak
int dword_7D6D0; // weak
int dword_7D6D4; // weak
int dword_7D6D8; // weak
int dword_7D6DC; // weak
int dword_7D6E0; // weak
int dword_7D6E4; // weak
int dword_7D6EC; // weak
int dword_7D6F0; // weak
int dword_7D6F4; // weak
int dword_7D6F8; // weak
int dword_7D6FC; // weak
int dword_7D700; // weak
int dword_7D704; // weak
int dword_7D708; // weak
int dword_7D70C; // weak
int dword_7D710; // weak
int dword_7D714; // weak
int dword_7D718; // weak
int dword_7D71C; // weak
int dword_7D720; // weak
int dword_7D724; // weak
int dword_7D728; // weak
int dword_7D72C; // weak
int dword_7D730; // weak
int dword_7D734; // weak
int dword_7D738; // weak
int dword_7D73C; // weak
int dword_7D740; // weak
_UNKNOWN unk_7D744; // weak
int dword_7D754; // weak
int dword_7D758; // weak
int dword_7D75C; // weak
int dword_7D760; // weak
int dword_7D764; // weak
int dword_7D768; // weak
int dword_7D76C; // weak
int dword_7D770; // weak
char byte_7D774; // weak
_BYTE byte_7D775[12]; // weak
char byte_7D781; // weak
char byte_7D782; // weak
char byte_7D783; // weak
char byte_7D784[]; // weak
struct termios buf; // idb
int dword_7D7CC; // weak
int dword_7D7D0; // weak
int dword_7D7D4; // weak
int dword_7D7D8; // weak
int dword_7D7DC; // weak
int dword_7D7E0; // weak
int dword_7D7E4; // weak
_UNKNOWN unk_7D7E8; // weak
char byte_7D7F4; // weak
__int16 word_7D7F6; // weak
int dword_7D808; // weak
int dword_7D80C; // weak
int dword_7D810; // weak
_DWORD *dword_7D814; // weak
int dword_7D818; // weak
int dword_7D81C; // weak
int dword_7D820; // weak
int dword_7D824; // weak
int dword_7D990; // weak
__int16 word_7D994; // weak
int dword_7D998[9]; // weak
int dword_7D9BC; // weak
int dword_7D9C0; // weak
int dword_7D9C4; // weak
int dword_7D9C8; // weak
int dword_7D9CC; // weak
int dword_7D9D0; // weak
int dword_7D9D4; // weak
int dword_7D9D8; // weak
__int16 word_7D9DC; // weak
__int16 word_7D9DE; // weak
int dword_7DB90; // weak
int dword_7DB94; // weak
int dword_7DB98; // weak
int (*off_7DB9C)(void); // weak
int dword_7DBA0; // weak
int dword_7DBA4; // weak
char byte_7DBA8; // weak
int dword_7DBAC; // weak
int dword_7DBB0; // weak
int dword_7DBB4; // weak
int dword_7DBB8; // weak
int dword_7DBBC; // weak
int dword_7DBC0; // weak
int dword_7DBC4; // weak
int dword_7DBC8; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00013424) --------------------------------------------------------
int init_proc()
{
  return sub_16238();
}

//----- (00013430) --------------------------------------------------------
void sub_13430()
{
  JUMPOUT(0);
}
// 1343C: control flows out of bounds to 0

//----- (000138D0) --------------------------------------------------------
// attributes: thunk
int j___fxstat64()
{
  return _fxstat64();
}
// 138D4: using guessed type int _fxstat64(void);

//----- (000140FC) --------------------------------------------------------
// attributes: thunk
int sub_140FC()
{
  return _xstat64();
}
// 14100: using guessed type int _xstat64(void);

//----- (00014178) --------------------------------------------------------
// attributes: thunk
int sub_14178()
{
  return _lxstat64();
}
// 1417C: using guessed type int _lxstat64(void);

//----- (00014258) --------------------------------------------------------
int __fastcall sub_14258(int a1, char **a2)
{
  char v3; // r0
  char v4; // r6
  unsigned int v5; // r4
  int v6; // r11
  char *v7; // r2
  unsigned int v8; // r3
  char *v9; // r0
  const char *v10; // r1
  const char *v11; // r3
  const char **v12; // r6
  FILE *v13; // r5
  int v14; // r7
  struct mntent *v15; // r9
  const char **v17; // r8
  const char *v18; // r6
  const char *mnt_fsname; // r10
  const char *mnt_dir; // r8
  _BOOL4 v21; // r2
  unsigned int v22; // r9
  char *v25; // r0
  char *v26; // r0
  char *v27; // r0
  unsigned __int64 v28; // [sp+0h] [bp-7Ch]
  unsigned __int64 v29; // [sp+8h] [bp-74h]
  int v30; // [sp+10h] [bp-6Ch]
  const char *mnt_type; // [sp+14h] [bp-68h]
  unsigned int v32; // [sp+18h] [bp-64h] BYREF
  unsigned int v33; // [sp+1Ch] [bp-60h]
  unsigned __int64 v34; // [sp+20h] [bp-5Ch]
  __int64 v35; // [sp+28h] [bp-54h]
  unsigned __int64 v36; // [sp+30h] [bp-4Ch]

  v3 = sub_593CC(a2, "^kPThm");
  v4 = v3;
  if ( (v3 & 0x10) != 0 )
    v5 = 0x100000;
  else
    v5 = 1024;
  v6 = v3 & 2;
  if ( getenv("POSIXLY_CORRECT") )
    v5 = 512;
  if ( (v4 & 8) != 0 )
  {
    v5 = 0;
    v7 = "     Size";
  }
  else
  {
    v8 = v4 & 2;
    if ( v6 )
      v8 = 1;
    v9 = sub_5A318(v5, 0, v8);
    v7 = sub_177E4("%s-blocks", v9);
  }
  v30 = v4 & 4;
  v10 = "";
  if ( (v4 & 4) != 0 )
    v10 = "Type       ";
  v11 = "Capacity";
  if ( !v6 )
    v11 = "Use%";
  printf("Filesystem           %s%-15sUsed Available %s Mounted on\n", v10, v7, v11);
  v12 = (const char **)&a2[optind];
  if ( *v12 )
  {
    v13 = 0;
  }
  else
  {
    v13 = setmntent("/proc/mounts", "r");
    if ( !v13 )
      sub_16B40("/proc/mounts");
  }
  v14 = 0;
  while ( v13 )
  {
    v15 = getmntent(v13);
    if ( !v15 )
    {
      endmntent(v13);
      return v14;
    }
LABEL_28:
    mnt_fsname = v15->mnt_fsname;
    if ( strcmp(v15->mnt_fsname, "rootfs") )
    {
      mnt_dir = v15->mnt_dir;
      mnt_type = v15->mnt_type;
      if ( statvfs64(mnt_dir, &v32) )
      {
        v14 = 1;
        sub_16B80(mnt_dir);
      }
      else
      {
        if ( !v33 )
          v33 = v32;
        v21 = v34 != 0;
        if ( !v13 )
          v21 = 1;
        if ( v21 )
        {
          v29 = v34 - v35;
          LODWORD(v28) = v34 - v35 + v36;
          HIDWORD(v28) = v28;
          if ( (_DWORD)v28 )
          {
            while ( v28 > 0x1446F85 )
            {
              v28 >>= 1;
              v29 >>= 1;
            }
            v22 = sub_15CA0(((unsigned int)v28 >> 1) + 100 * v29, v28);
          }
          else
          {
            v22 = 0;
          }
          if ( printf("%-20s", mnt_fsname) > 20 && v6 == 0 )
            printf("\n%-20s", "");
          if ( v30 )
          {
            if ( printf(" %-10s", mnt_type) > 11 && v6 == 0 )
              printf("\n%-30s", "");
          }
          v25 = sub_5A318(v34, v33, v5);
          printf(" %9s ", v25);
          v26 = sub_5A318(v34 - v35, v33, v5);
          printf("%9s ", v26);
          v27 = sub_5A318(v36, v33, v5);
          printf("%9s %3u%% %s\n", v27, v22, mnt_dir);
        }
      }
    }
  }
  while ( 1 )
  {
    v17 = v12 + 1;
    v18 = *v12;
    if ( !v18 )
      return v14;
    v15 = sub_58A20(v18, 1);
    if ( v15 )
    {
      v12 = v17;
      goto LABEL_28;
    }
    sub_16DDC("%s: can't find mount point", v18);
    v12 = v17;
    v14 = 1;
  }
}
// 13D78: using guessed type int __fastcall statvfs64(_DWORD, _DWORD);
// 7D604: using guessed type int optind;

//----- (00014600) --------------------------------------------------------
int __fastcall sub_14600(int a1, int a2)
{
  double v2; // d0
  int v3; // r7
  double v4; // d8
  _DWORD *v5; // r5
  const char *v6; // r4
  size_t v7; // r0
  char v8; // r11
  size_t v9; // r6
  const char *v10; // r8
  char v11; // r4
  unsigned int v12; // r0
  int v13; // t1
  struct timespec v15; // [sp+0h] [bp-Ch] BYREF

  if ( !*(_DWORD *)(a2 + 4) )
LABEL_2:
    sub_162F0();
  v3 = a2 + 4;
  v4 = 0.0;
  v5 = (_DWORD *)dword_7DB94;
  do
  {
    v6 = *(const char **)v3;
    if ( strchr(*(const char **)v3, 46) )
    {
      v7 = strspn(v6, "0123456789.");
      v8 = v6[v7];
      v9 = v7;
      v6[v7] = 0;
      v10 = &v6[v7];
      *v5 = 0;
      strtod(v6, (char **)&v15);
      if ( *v5 || *(_BYTE *)v15.tv_sec )
        goto LABEL_2;
      v6[v9] = v8;
      v11 = *(v10 - 1);
      *((_BYTE *)v10 - 1) = 49;
      v12 = sub_62090(v10 - 1, (int)&unk_639D4);
      *((_BYTE *)v10 - 1) = v11;
      v4 = v4 + (double)v12 * v2;
    }
    else
    {
      v4 = v4 + (double)sub_62090(v6, (int)&unk_639D4);
    }
    v13 = *(_DWORD *)(v3 + 4);
    v3 += 4;
  }
  while ( v13 );
  v15.tv_sec = 0x7FFFFFFF;
  v15.tv_nsec = 0;
  if ( v4 >= 0.0 && v4 < 2147483650.0 )
  {
    v15.tv_sec = (int)v4;
    v15.tv_nsec = (int)((v4 - (double)(int)v4) * 1000000000.0);
  }
  do
  {
    *v5 = 0;
    nanosleep(&v15, &v15);
  }
  while ( *v5 == 4 );
  return 0;
}
// 146C4: variable 'v2' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;

//----- (00014790) --------------------------------------------------------
int __fastcall sub_14790(unsigned int *a1, int a2)
{
  int *v2; // r7
  char *v3; // r9
  int *v4; // r10
  double v5; // d0
  double v6; // d8
  double v7; // d9
  unsigned int *v8; // r4
  int *v9; // r5
  double v11; // r0
  int v12; // r8
  int v13; // r6
  int v14; // r3
  int *v15; // r6
  int v16; // r0
  int *v17; // r0
  char *v18; // r8
  int *v19; // r0
  unsigned int v20; // r3
  const char *v21; // r0
  _DWORD *v22; // r0
  int v23; // r0
  int v24; // r2
  int v25; // r3
  int v26; // r0
  int v27; // r8
  int v28; // r3
  char **v29; // r6
  unsigned int v30; // r8
  int v31; // r11
  int *v32; // r0
  int v33; // r6
  const char *v34; // r0
  FILE *v35; // r11
  char *v36; // r11
  char *v37; // r1
  FILE *v38; // r0
  int v39; // r8
  char *v40; // r0
  char *v41; // r0
  _DWORD *v42; // r0
  int *v43; // r0
  char *v44; // r6
  double v45; // r0
  char *v46; // r0
  char *v47; // r0
  _BYTE *v48; // r6
  unsigned int *v49; // r0
  int v50; // r0
  int *v51; // r0
  regex_t *v52; // r6
  regex_t *v53; // r11
  int v54; // r0
  int v55; // r3
  int v56; // r8
  int v57; // s0
  int v58; // r0
  unsigned int v59; // r3
  int v60; // r0
  _DWORD *v61; // r3
  char *v62; // r11
  char *v63; // r8
  _DWORD *v64; // r0
  int v65; // r3
  unsigned int v66; // r3
  int v67; // r8
  int v68; // r11
  int v69; // r0
  char *v70; // r6
  double v71; // r0
  int v72; // r8
  int v73; // r6
  double v74; // r0
  int v75; // s15
  __int64 v76; // r0
  int v77; // r1
  double v78; // d0
  time_t v79; // r0
  time_t v80; // r0
  int v81; // s15
  FILE *v82; // r0
  FILE **v83; // r0
  FILE **v84; // r11
  FILE *v85; // r8
  FILE *v86; // r0
  char *v87; // r0
  double v88; // r0
  double v89; // d10
  int v90; // r5
  char *v91; // r2
  double v92; // r0
  double v93; // r2
  int v94; // r0
  __int64 v95; // r0
  double v96; // r0
  double v97; // r0
  double v98; // r0
  double v99; // r0
  double v100; // d0
  int v101; // r3
  _BOOL4 v102; // r3
  char *v103; // r8
  char *v104; // r1
  int v105; // r0
  unsigned int v106; // [sp+8h] [bp-24h]
  _DWORD *v107; // [sp+Ch] [bp-20h]
  char *command; // [sp+10h] [bp-1Ch]
  _BOOL4 v109; // [sp+14h] [bp-18h]
  int v110; // [sp+18h] [bp-14h]
  int v111; // [sp+18h] [bp-14h]
  char *v112; // [sp+18h] [bp-14h]
  int v113; // [sp+18h] [bp-14h]
  int v114; // [sp+18h] [bp-14h]
  int *v115; // [sp+1Ch] [bp-10h]
  _DWORD *v116[2]; // [sp+24h] [bp-8h] BYREF

  v8 = a1;
  v9 = (int *)a2;
  if ( a1 )
  {
    v107 = sub_4A4D8(2);
    while ( 1 )
    {
      LODWORD(v11) = v8[2];
      v106 = *v8;
      v12 = *v8 & 0x7F;
      v13 = dword_7DB98;
      *(_DWORD *)(dword_7DB98 - 56) = v8[1];
      v116[0] = (_DWORD *)LODWORD(v11);
      if ( BYTE1(v106) == 1 )
      {
        v14 = *(_DWORD *)LODWORD(v11) & 0xFF00;
        if ( v14 == 9984 )
        {
          v15 = *(int **)(LODWORD(v11) + 8);
        }
        else
        {
          if ( v14 != 6144 )
          {
            v21 = "Not an array";
            goto LABEL_19;
          }
          v15 = (int *)(*(_DWORD *)(v13 + 140) + 24 * *(_DWORD *)(LODWORD(v11) + 8));
        }
        v16 = *(_DWORD *)(LODWORD(v11) + 12);
        if ( v16 )
        {
          v17 = (int *)sub_14790(v16, v107);
          v18 = sub_4AD78(v17);
          v19 = (int *)sub_4A470(v15);
          sub_4AAB0(v19, v18);
        }
        else
        {
          v22 = (_DWORD *)sub_4A470(v15);
          sub_4A6AC(v22);
        }
      }
      else
      {
        if ( (v106 & 0x10000) != 0 )
        {
          LODWORD(v11) = sub_14790(LODWORD(v11), v107);
          v2 = (int *)LODWORD(v11);
        }
        if ( (v106 & 0x20000) != 0 )
        {
          LODWORD(v11) = sub_14790(v8[3], v107 + 6);
          v4 = (int *)LODWORD(v11);
        }
        if ( (v106 & 0x40000) != 0 )
        {
          LODWORD(v11) = sub_4AD78(v2);
          v3 = (char *)LODWORD(v11);
        }
        if ( (v106 & 0x80000) != 0 )
        {
          LODWORD(v11) = sub_4AD78(v4);
          command = (char *)LODWORD(v11);
        }
        if ( (v106 & 0x100000) != 0 )
        {
          LODWORD(v11) = v2;
          LODWORD(v11) = sub_4A828(v11);
          v7 = v5;
        }
        switch ( BYTE1(v106) )
        {
          case 2:
            break;
          case 3:
            *(_DWORD *)(v13 - 60) = v8[2];
            break;
          case 4:
          case 5:
            v35 = (FILE *)stdout;
            if ( v8[3] )
            {
              v36 = sub_4A98C(*(unsigned int **)(v13 - 68), command);
              if ( !*(_DWORD *)v36 )
              {
                v37 = "w";
                if ( v12 == 124 )
                {
                  v38 = popen(command, "w");
                  *(_DWORD *)v36 = v38;
                  if ( !v38 )
                    sub_16B40("popen");
                  *((_DWORD *)v36 + 5) = 1;
                }
                else
                {
                  if ( v12 != 119 )
                    v37 = "a";
                  *(_DWORD *)v36 = sub_17590(command, (int)v37);
                }
              }
              v35 = *(FILE **)v36;
            }
            if ( (v106 & 0xFF00) == 0x400 )
            {
              if ( v116[0] )
              {
                v39 = dword_7DB98;
                while ( v116[0] )
                {
                  v42 = sub_4A40C(v116);
                  v43 = (int *)sub_14790(v42, v107);
                  if ( (*v43 & 1) != 0 )
                  {
                    v115 = v43;
                    v44 = *(char **)(v39 - 32);
                    v112 = sub_4AD78(*(int **)(v39 + 20));
                    LODWORD(v45) = v115;
                    sub_4A828(v45);
                    sub_4AC78(v44, 0xF0u, v112, 1);
                    v46 = *(char **)(v39 - 32);
                  }
                  else
                  {
                    v46 = sub_4AD78(v43);
                  }
                  fputs_unlocked(v46, v35);
                  if ( v116[0] )
                  {
                    v47 = sub_4AD78(*(int **)(v39 + 28));
                    fputs_unlocked(v47, v35);
                  }
                }
              }
              else
              {
                v40 = sub_4AD78(*(int **)(v13 + 52));
                fputs_unlocked(v40, v35);
              }
              v41 = sub_4AD78(*(int **)(dword_7DB98 + 32));
              fputs_unlocked(v41, v35);
            }
            else
            {
              v48 = sub_4C344(v116[0]);
              fputs_unlocked(v48, v35);
              free(v48);
            }
            fflush(v35);
            break;
          case 6:
            v23 = sub_4A470(v4);
            v24 = *v2;
            v25 = v23;
            v26 = *(_DWORD *)(v23 + 12);
            v110 = v25;
            v27 = *v2 & 0x800;
            if ( v27 )
              v27 = v2[5];
            else
              v24 |= 0x800u;
            if ( (*v2 & 0x800) == 0 )
              *v2 = v24;
            LODWORD(v11) = sub_174DC(v26 + 17);
            v28 = v110;
            v2[5] = LODWORD(v11);
            v29 = (char **)LODWORD(v11);
            *(_DWORD *)(LODWORD(v11) + 4) = LODWORD(v11) + 12;
            *(_DWORD *)(LODWORD(v11) + 8) = v27;
            v30 = 0;
            *(_DWORD *)LODWORD(v11) = LODWORD(v11) + 12;
            while ( v30 < *(_DWORD *)(v28 + 4) )
            {
              v31 = *(_DWORD *)(*(_DWORD *)(v28 + 16) + 4 * v30);
              while ( v31 )
              {
                v111 = v28;
                strcpy(*v29, (const char *)(v31 + 28));
                sub_4A3D0((int *)v29);
                v31 = *(_DWORD *)(v31 + 24);
                v28 = v111;
              }
              ++v30;
            }
            break;
          case 7:
            LODWORD(v11) = v2;
            LODWORD(v11) = sub_4A8BC(v11);
            goto LABEL_40;
          case 0xA:
            sub_4B9E0((int)v7);
          case 0xB:
            goto LABEL_84;
          case 0xC:
            *(_DWORD *)(v13 - 16) = 1;
LABEL_84:
            *(_DWORD *)(v13 - 20) = 1;
            goto LABEL_85;
          case 0xD:
            if ( (*v116[0] & 0xFF00) == 0x1300 )
            {
              if ( (v106 & 0x200000) == 0 && !sub_4C558(v116[0][2]) )
                goto LABEL_38;
              *v8 |= 0x200000u;
              if ( sub_4C558(v116[0][3]) )
                *v8 &= ~0x200000u;
            }
            else
            {
              LODWORD(v11) = sub_4C558((int)v116[0]);
LABEL_40:
              if ( !LODWORD(v11) )
                goto LABEL_38;
            }
            goto LABEL_36;
          case 0xE:
            v32 = (int *)v2[5];
            if ( v32[1] < (unsigned int)*v32 )
            {
              v34 = (const char *)sub_4A3D0(v32 + 1);
              sub_4B32C((int)v2, v34);
LABEL_36:
              v8 = (unsigned int *)v8[4];
            }
            else
            {
              v33 = v32[2];
              free(v32);
              v2[5] = v33;
LABEL_38:
              v8 = (unsigned int *)v8[3];
            }
            break;
          case 0x10:
          case 0x22:
            LODWORD(v11) = v4;
            LODWORD(v92) = sub_4A828(v11);
            switch ( v12 )
            {
              case '%':
                if ( v5 == 0.0 )
                  goto LABEL_224;
                LODWORD(v95) = sub_62C80(v7 / v5);
                LODWORD(v96) = sub_62B48(v95);
                v7 = v7 - v96 * v5;
                goto LABEL_217;
              case '&':
                pow(v92, v93);
                goto LABEL_217;
              case '*':
                v7 = v7 * v5;
                goto LABEL_217;
              case '+':
                v7 = v7 + v5;
                goto LABEL_217;
              case '-':
                v7 = v7 - v5;
                goto LABEL_217;
              case '/':
                if ( v5 == 0.0 )
                {
LABEL_224:
                  v21 = "Division by zero";
LABEL_19:
                  sub_4AC50(v21);
                }
                v7 = v7 / v5;
LABEL_217:
                v5 = v7;
                if ( (v106 & 0xFF00) == 0x1000 )
                  v94 = (int)v9;
                else
                  v94 = (int)v2;
                LODWORD(v11) = sub_4B458(v94);
LABEL_91:
                v9 = (int *)LODWORD(v11);
                break;
              default:
                goto LABEL_217;
            }
            break;
          case 0x11:
            LODWORD(v11) = sub_4BD98(v8, (int)v9);
            goto LABEL_91;
          case 0x13:
          case 0x15:
            if ( (v106 & 0xFF00) == 0x1300 )
              v91 = sub_4AD78(*(int **)(v13 + 48));
            else
              v91 = "";
            v87 = sub_177E4("%s%s%s", v3, v91, command);
            goto LABEL_180;
          case 0x14:
            LODWORD(v11) = v2;
            sub_4A828(v11);
            if ( ((*v2 ^ 0x4000) & 0x4201) != 0 && (LODWORD(v97) = v4, sub_4A828(v97), ((*v4 ^ 0x4000) & 0x4201) != 0) )
            {
              LODWORD(v98) = v2;
              sub_4A828(v98);
              LODWORD(v99) = v4;
              sub_4A828(v99);
              v100 = v5 - v5;
            }
            else
            {
              v103 = sub_4AD78(v2);
              v104 = sub_4AD78(v4);
              if ( *(_DWORD *)(v13 - 28) )
                v105 = strcasecmp(v103, v104);
              else
                v105 = strcmp(v103, v104);
              v100 = (double)v105;
            }
            v101 = v106 & 0x7E;
            if ( v101 == 2 )
            {
              v102 = v100 >= 0.0;
            }
            else if ( v101 == 4 )
            {
              v102 = v100 == 0.0;
            }
            else
            {
              if ( (v106 & 0x7E) != 0 )
                goto LABEL_237;
              v102 = v100 > 0.0;
            }
            v109 = v102;
LABEL_237:
            v57 = ((v106 & 1) == 0) ^ v109;
LABEL_102:
            v5 = (double)v57;
            goto LABEL_95;
          case 0x16:
            switch ( v12 )
            {
              case 0:
                LODWORD(v76) = sub_62C80(v7);
                LODWORD(v6) = sub_62B48(v76);
                HIDWORD(v6) = v77;
                goto LABEL_137;
              case 1:
                v6 = (double)rand() / 2147483650.0;
                goto LABEL_137;
              case 2:
                v78 = v7;
                cos(v11);
                goto LABEL_140;
              case 3:
                v78 = v7;
                exp(v11);
                goto LABEL_140;
              case 4:
                v78 = v7;
                log(v11);
                goto LABEL_140;
              case 5:
                v78 = v7;
                sin(v11);
                goto LABEL_140;
              case 6:
                v78 = v7;
                sqrt(v11);
LABEL_140:
                v6 = v78;
                goto LABEL_137;
              case 7:
                v6 = (double)*(unsigned int *)(v13 + 144);
                if ( v116[0] )
                  v79 = (unsigned int)v7;
                else
                  v79 = time(0);
                *(_DWORD *)(v13 + 144) = v79;
                srand(v79);
                goto LABEL_137;
              case 8:
                v80 = time(0);
                goto LABEL_150;
              case 9:
                if ( !v116[0] )
                {
                  v3 = sub_4AD78(*(int **)(v13 + 52));
LABEL_154:
                  v6 = (double)strlen(v3);
                  goto LABEL_137;
                }
                if ( (*v2 & 2) == 0 )
                  goto LABEL_154;
                v6 = (double)*(unsigned int *)v2[5];
                goto LABEL_137;
              case 10:
                sub_177D8();
                if ( v3 && *v3 )
                {
                  v80 = system(v3) >> 8;
LABEL_150:
                  v81 = v80;
LABEL_151:
                  v6 = (double)v81;
                }
                else
                {
                  v6 = 0.0;
                }
                goto LABEL_137;
              case 11:
                if ( !v116[0] )
                {
                  v82 = (FILE *)stdout;
LABEL_166:
                  fflush(v82);
                  goto LABEL_137;
                }
                if ( v3 && *v3 )
                {
                  v82 = *(FILE **)sub_4A98C(*(unsigned int **)(v13 - 68), v3);
                  goto LABEL_166;
                }
                sub_177D8();
LABEL_137:
                v5 = v6;
                break;
              case 12:
                v83 = (FILE **)sub_4A93C(*(_DWORD *)(v13 - 68), v3);
                v84 = v83;
                if ( v83 )
                {
                  v86 = *v83;
                  if ( *v84 )
                  {
                    if ( v84[5] )
                      v86 = (FILE *)pclose(v86);
                    else
                      v86 = (FILE *)fclose(v86);
                  }
                  v85 = v86;
                  free(v84[1]);
                  sub_4AAB0(*(int **)(v13 - 68), v3);
                  if ( v85 )
                    sub_4B458(*(_DWORD *)(v13 + 68));
                }
                else
                {
                  v85 = 0;
                }
                v81 = (int)v85;
                goto LABEL_151;
              default:
                goto LABEL_137;
            }
            goto LABEL_95;
          case 0x17:
            LODWORD(v11) = v4;
            LODWORD(v11) = sub_4A828(v11);
            v90 = (int)v5;
            if ( (int)v5 < 0 )
            {
              v21 = "Access to negative field";
              goto LABEL_19;
            }
            if ( (int)v5 )
            {
              sub_4B08C(SLODWORD(v11), SHIDWORD(v11));
              if ( *(_DWORD *)(v13 - 52) < v90 )
                sub_4A60C((int)v5);
              v9 = (int *)(*(_DWORD *)(v13 - 44) + 24 * v90 - 24);
            }
            else
            {
              v9 = *(int **)(v13 + 52);
            }
            break;
          case 0x18:
            v9 = (int *)(*(_DWORD *)(v13 + 140) + 24 * v8[2]);
            goto LABEL_89;
          case 0x19:
            v61 = (_DWORD *)v8[3];
            if ( !*v61 && !v61[1] )
            {
              v21 = "Call to undefined function";
              goto LABEL_19;
            }
            v62 = (char *)sub_4A4D8(*v61 + 1);
            v63 = v62 + 24;
            do
            {
              if ( !v116[0] )
                break;
              v64 = sub_4A40C(v116);
              v114 = sub_14790(v64, v107);
              sub_4B4B0(COERCE_DOUBLE(__PAIR64__(v114, (unsigned int)(v63 - 24))));
              *((_DWORD *)v63 - 6) |= 0x2000u;
              *((_DWORD *)v63 - 1) = v114;
              v65 = (v63 - v62) >> 3;
              v63 += 24;
            }
            while ( (unsigned int)(-1431655765 * v65) < *(_DWORD *)v8[3] );
            v66 = v8[3];
            v67 = *(_DWORD *)(v13 + 140);
            *(_DWORD *)(v13 + 140) = v62;
            v68 = *(_DWORD *)(v13 - 60);
            v69 = sub_14790(*(_DWORD *)(v66 + 4), v9);
            *(_DWORD *)(v13 - 60) = v68;
            v9 = (int *)v69;
            sub_4B604(*(_DWORD *)(v13 + 140));
            *(_DWORD *)(v13 + 140) = v67;
            break;
          case 0x1A:
          case 0x20:
            if ( v116[0] )
            {
              v70 = sub_4A98C(*(unsigned int **)(v13 - 68), v3);
              if ( !*(_DWORD *)v70 )
              {
                if ( (v106 & 0xFF00) == 0x2000 )
                {
                  *(_DWORD *)v70 = popen(v3, "r");
                  *((_DWORD *)v70 + 5) = 1;
                }
                else
                {
                  *(_DWORD *)v70 = sub_61C9C((int)v3);
                }
              }
            }
            else
            {
              if ( !*(_DWORD *)(v13 - 80) )
                *(_DWORD *)(v13 - 80) = sub_4B50C(v11);
              v70 = *(char **)(v13 - 80);
              if ( !v70 )
              {
LABEL_134:
                sub_4B458(*(_DWORD *)(dword_7DB98 + 68));
                v5 = -1.0;
                goto LABEL_95;
              }
            }
            if ( !*(_DWORD *)v70 )
              goto LABEL_134;
            if ( !v8[3] )
              v4 = *(int **)(dword_7DB98 + 52);
            v72 = sub_4B6F4((int)v70, v4);
            if ( v72 > 0 && !v116[0] )
            {
              v73 = dword_7DB98;
              LODWORD(v71) = *(_DWORD *)(dword_7DB98 + 72);
              sub_4B490(v71);
              LODWORD(v74) = *(_DWORD *)(v73 + 76);
              sub_4B490(v74);
            }
            v75 = v72;
LABEL_129:
            v5 = (double)v75;
            goto LABEL_95;
          case 0x1B:
            v50 = sub_4A470(v4);
            v5 = 1.0;
            if ( !sub_4A93C(v50, v3) )
              v5 = 0.0;
            goto LABEL_95;
          case 0x1C:
            LODWORD(v11) = v2;
            if ( sub_4A8BC(v11) )
              goto LABEL_211;
            v5 = 0.0;
            goto LABEL_95;
          case 0x1D:
            LODWORD(v11) = v2;
            if ( !sub_4A8BC(v11) )
            {
LABEL_211:
              v75 = sub_4C558(v8[3]);
              goto LABEL_129;
            }
            v5 = 1.0;
            goto LABEL_95;
          case 0x1E:
            v116[0] = (_DWORD *)v8[3];
            goto LABEL_97;
          case 0x1F:
            LODWORD(v11) = sub_4B4B0(COERCE_DOUBLE(__PAIR64__((unsigned int)v4, (unsigned int)v2)));
            goto LABEL_91;
          case 0x21:
            v51 = *(int **)(v13 + 52);
            v116[0] = v8;
            v3 = sub_4AD78(v51);
LABEL_97:
            v52 = (regex_t *)(v13 + 148);
            v53 = sub_4BA78(v116[0], v52);
            v54 = regexec(v53, v3, 0, 0, 0);
            v55 = v54;
            if ( v52 == v53 )
            {
              v113 = v54;
              regfree(v52);
              v55 = v113;
            }
            v56 = v12 == 33;
            if ( !v55 )
              v56 ^= 1u;
            v57 = v56;
            goto LABEL_102;
          case 0x23:
            sub_4B4B0(COERCE_DOUBLE(__PAIR64__((unsigned int)v2, (unsigned int)v9)));
            break;
          case 0x24:
            v87 = sub_4C344(v116[0]);
LABEL_180:
            sub_4B308((int)v9, (int)v87);
            break;
          case 0x25:
            if ( (*(_DWORD *)v8[3] & 0xFF00) != 0x1200 )
              goto LABEL_106;
            LODWORD(v11) = v2;
            v58 = sub_4A8BC(v11);
            v59 = v8[3];
            if ( v58 )
              v60 = *(_DWORD *)(v59 + 8);
            else
              v60 = *(_DWORD *)(v59 + 12);
            LODWORD(v11) = sub_14790(v60, v9);
            goto LABEL_91;
          case 0x26:
            LODWORD(v11) = v4;
            sub_4A828(v11);
            v89 = v5;
            if ( v12 == 77 )
            {
              v89 = v5 - 1.0;
LABEL_192:
              sub_4B458((int)v4);
              goto LABEL_186;
            }
            if ( v12 > 77 )
            {
              if ( v12 != 109 && v12 != 112 )
              {
                if ( v12 != 80 )
                  goto LABEL_186;
                v89 = v5 + 1.0;
              }
              goto LABEL_192;
            }
            if ( v12 == 33 )
            {
              LODWORD(v88) = v4;
              v89 = 1.0;
              if ( sub_4A8BC(v88) )
                v89 = 0.0;
            }
            else if ( v12 == 45 )
            {
              v89 = -v5;
            }
LABEL_186:
            v5 = v89;
LABEL_95:
            sub_4B458((int)v9);
            break;
          case 0x27:
            v9 = (int *)v8[2];
            if ( v9 == *(int **)(v13 + 80) )
              sub_4B08C(SLODWORD(v11), SHIDWORD(v11));
LABEL_89:
            if ( !v8[3] )
              break;
            v49 = (unsigned int *)sub_4A470(v9);
            LODWORD(v11) = sub_4A98C(v49, command);
            goto LABEL_91;
          case 0x28:
LABEL_85:
            sub_4A5C4((int)v9);
            break;
          default:
LABEL_106:
            v21 = "Possible syntax error";
            goto LABEL_19;
        }
      }
      v20 = v106 & 0xFF00;
      if ( v20 > 0x600 )
      {
        if ( v20 >= 0x1000 )
          goto LABEL_17;
      }
      else
      {
        v8 = (unsigned int *)v8[4];
      }
      if ( *(_DWORD *)(dword_7DB98 - 20) || !v8 )
      {
LABEL_17:
        sub_4B604((unsigned int)v107);
        return (int)v9;
      }
    }
  }
  return sub_4B308(a2, 0);
}
// 14954: control flows out of bounds to 14958
// 15068: control flows out of bounds to 1506C
// 1542C: control flows out of bounds to 15430
// 1490C: variable 'v2' is possibly undefined
// 14924: variable 'v4' is possibly undefined
// 1493C: variable 'v11' is possibly undefined
// 14940: variable 'v5' is possibly undefined
// 14B60: variable 'command' is possibly undefined
// 14C8C: variable 'v45' is possibly undefined
// 14D40: variable 'v7' is possibly undefined
// 14DA0: variable 'v3' is possibly undefined
// 14FF4: variable 'v71' is possibly undefined
// 14FFC: variable 'v74' is possibly undefined
// 150A8: variable 'v76' is possibly undefined
// 150AC: variable 'v77' is possibly undefined
// 150B0: variable 'v6' is possibly undefined
// 15340: variable 'v88' is possibly undefined
// 154D8: variable 'v92' is possibly undefined
// 154D8: variable 'v93' is possibly undefined
// 154FC: variable 'v95' is possibly undefined
// 15504: variable 'v96' is possibly undefined
// 1552C: variable 'v97' is possibly undefined
// 15544: variable 'v98' is possibly undefined
// 15550: variable 'v99' is possibly undefined
// 155A0: variable 'v109' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;

//----- (00015610) --------------------------------------------------------
void __fastcall __noreturn sub_15610(int a1, char **a2)
{
  int v2; // r5
  _DWORD *v4; // r0
  char *v5; // r4
  double v6; // r0
  double v7; // r0
  int v8; // r5
  int v9; // r1
  unsigned __int8 *v10; // r2
  char v11; // r9
  char **v12; // r7
  int v13; // r0
  signed int v14; // r5
  const char *v15; // r2
  double v16; // r0
  unsigned int *v17; // r6
  const char *v18; // r0
  char *v19; // r0
  char *v20; // r6
  const char *v21; // r0
  const char *v22; // r3
  char *v23; // r0
  char *v24; // r11
  unsigned int *v25; // r0
  char *v26; // r0
  const char *v27; // r7
  const char *v28; // t1
  const char *v29; // r0
  char *v30; // r5
  int v31; // r0
  int v32; // r6
  FILE *v33; // r11
  signed int v34; // r0
  int v35; // r0
  char *v36; // r0
  double v37; // r0
  int v38; // [sp+10h] [bp-3Ch]
  unsigned __int8 *v39; // [sp+18h] [bp-34h] BYREF
  _DWORD *v40; // [sp+1Ch] [bp-30h] BYREF
  _DWORD *v41; // [sp+20h] [bp-2Ch] BYREF
  _DWORD *v42; // [sp+24h] [bp-28h] BYREF
  const char *v43; // [sp+28h] [bp-24h] BYREF
  const char *v44; // [sp+2Ch] [bp-20h] BYREF
  _BYTE s[28]; // [sp+30h] [bp-1Ch] BYREF

  v2 = 0;
  v43 = "CONVFMT";
  v40 = 0;
  v41 = 0;
  v44 = "%.6g";
  v42 = 0;
  v4 = sub_174DC(0x258u);
  v5 = (char *)(v4 + 34);
  dword_7DB98 = (int)(v4 + 34);
  v4[60] = 49152;
  v4[70] = 1;
  memset(s, 0, 0x18u);
  *((_DWORD *)v5 - 8) = sub_1748C(0xF1u);
  *((_DWORD *)v5 - 19) = sub_4A444();
  *((_DWORD *)v5 - 18) = sub_4A444();
  *((_DWORD *)v5 - 17) = sub_4A444();
  *((_DWORD *)v5 - 16) = sub_4A444();
  while ( *v43 )
  {
    v17 = (unsigned int *)*((_DWORD *)v5 - 19);
    v18 = (const char *)sub_4A3D0((int *)&v43);
    v19 = sub_4A98C(v17, v18);
    v20 = v19;
    *(_DWORD *)&v5[4 * v2 + 16] = v19;
    if ( *(unsigned __int8 *)v44 == 255 )
    {
      sub_4B458((int)v19);
    }
    else
    {
      v21 = (const char *)sub_4A3D0((int *)&v44);
      sub_4B32C((int)v20, v21);
    }
    ++v2;
    if ( *v43 == 42 )
    {
      v22 = v43 + 1;
      *(_DWORD *)v20 |= 0x400u;
      v43 = v22;
    }
  }
  LODWORD(v6) = *((_DWORD *)v5 + 6);
  sub_4B14C(v6);
  LODWORD(v7) = *((_DWORD *)v5 + 9);
  sub_4B14C(v7);
  *(_DWORD *)sub_4A98C(*((unsigned int **)v5 - 17), "/dev/stdin") = stdin;
  *(_DWORD *)sub_4A98C(*((unsigned int **)v5 - 17), "/dev/stdout") = stdout;
  *(_DWORD *)sub_4A98C(*((unsigned int **)v5 - 17), "/dev/stderr") = stderr;
  if ( _environ )
  {
    v8 = _environ - 4;
    while ( 1 )
    {
      v28 = *(const char **)(v8 + 4);
      v8 += 4;
      v27 = v28;
      if ( !v28 )
        break;
      v23 = strchr(v27, 61);
      v24 = v23;
      if ( v23 )
      {
        *v23 = 0;
        v25 = (unsigned int *)sub_4A470(*((int **)v5 + 22));
        v26 = sub_4A98C(v25, v27);
        sub_4B360((int)v26, v24 + 1);
        *v24 = 61;
      }
    }
  }
  v11 = sub_593CC(a2, "+F:v:*f:*e:*W:", &v39, &v40, &v41, &v42, 0);
  v38 = optind;
  v12 = &a2[optind];
  if ( (v11 & 0x10) != 0 )
    sub_16DDC("warning: option -W is ignored");
  if ( (v11 & 1) != 0 )
  {
    sub_4AB88(v39, v9, v10);
    sub_4B32C(*((_DWORD *)v5 + 6), (const char *)v39);
  }
  while ( v40 )
  {
    v29 = (const char *)sub_5D2FC(&v40);
    if ( !sub_4B378(v29) )
      goto LABEL_32;
  }
  while ( v41 )
  {
    v30 = 0;
    v31 = sub_5D2FC(&v41);
    *((_DWORD *)v5 - 15) = v31;
    v32 = 1;
    v33 = (FILE *)sub_61D20(v31);
    do
    {
      v30 = (char *)sub_174B4(v30, v32 + 4096);
      v34 = fread(&v30[v32], 1u, 0xFFEu, v33);
      v32 += v34;
    }
    while ( v34 > 0 );
    v30[v32] = 0;
    fclose(v33);
    sub_4D030((int)(v30 + 1));
    free(v30);
  }
  *((_DWORD *)v5 - 15) = "cmd. line";
  while ( v42 )
  {
    v35 = sub_5D2FC(&v42);
    sub_4D030(v35);
  }
  if ( (v11 & 0xC) == 0 )
  {
    v13 = (int)a2[v38];
    if ( !v13 )
LABEL_32:
      sub_162F0();
    ++v12;
    sub_4D030(v13);
  }
  v14 = 0;
  sub_4B424(*((int **)v5 + 16), 0, "awk");
  while ( 1 )
  {
    v15 = v12[v14++];
    if ( !v15 )
      break;
    sub_4B424(*((int **)v5 + 16), v14, v15);
  }
  sub_4B458(*((_DWORD *)v5 + 15));
  LODWORD(v16) = sub_14790(*((unsigned int **)v5 - 32), (int)s);
  if ( *((_DWORD *)v5 - 29) || *((_DWORD *)v5 - 26) )
  {
    if ( *((_DWORD *)v5 - 20) )
      goto LABEL_40;
LABEL_39:
    while ( 1 )
    {
      *((_DWORD *)v5 - 20) = sub_4B50C(v16);
LABEL_40:
      if ( !*((_DWORD *)v5 - 20) )
        break;
      *((_DWORD *)v5 - 4) = 0;
      sub_4B458(*((_DWORD *)v5 + 18));
      while ( 1 )
      {
        LODWORD(v16) = sub_4B6F4(*((_DWORD *)v5 - 20), *((_DWORD **)v5 + 13));
        if ( SLODWORD(v16) <= 0 )
          break;
        *((_DWORD *)v5 - 5) = 0;
        LODWORD(v16) = *((_DWORD *)v5 + 19);
        sub_4B490(v16);
        LODWORD(v37) = *((_DWORD *)v5 + 18);
        sub_4B490(v37);
        LODWORD(v16) = sub_14790(*((unsigned int **)v5 - 29), (int)s);
        if ( *((_DWORD *)v5 - 4) )
          goto LABEL_39;
      }
      if ( LODWORD(v16) )
      {
        v36 = strerror(*(_DWORD *)dword_7DB94);
        sub_4AC50(v36);
      }
    }
  }
  sub_4B9E0(0);
}
// 156B8: variable 'v6' is possibly undefined
// 156C0: variable 'v7' is possibly undefined
// 15778: variable 'v9' is possibly undefined
// 15778: variable 'v10' is possibly undefined
// 159BC: variable 'v16' is possibly undefined
// 15A24: variable 'v37' is possibly undefined
// 7D600: using guessed type int _environ;
// 7D604: using guessed type int optind;
// 7D608: using guessed type int stderr;
// 7D610: using guessed type int stdin;
// 7D614: using guessed type int stdout;
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;

//----- (00015A98) --------------------------------------------------------
_BYTE *__fastcall sub_15A98(unsigned __int64 a1, _BYTE *a2, int a3)
{
  __int64 v3; // r4
  int v5; // r11
  unsigned int v6; // r3
  bool v7; // cc
  unsigned int v8; // r8
  unsigned int v9; // r9
  int v10; // r1
  int v11; // r10
  int v12; // r4
  const char *v13; // r4
  int v14; // r1
  int v15; // r2
  int v16; // r1
  int v17; // r3
  int v18; // r1
  char v19; // r3
  int v21; // r4
  const char *v22; // r4
  int v23; // r1
  int v24; // r1
  int v25; // r1
  int v26; // r1
  char v27; // r3
  unsigned int v28; // r0
  int v29; // r4
  const char *v30; // r4
  int v31; // r1
  unsigned int v32; // [sp+0h] [bp-Ch]

  LODWORD(v3) = a1;
  if ( a1 > 0x1869F )
  {
    v5 = 0;
    v3 = 10 * a1;
    do
    {
      v6 = v3 >> 10;
      v7 = HIDWORD(v3) >> 10 != 0;
      HIDWORD(v3) >>= 10;
      if ( !HIDWORD(v3) )
        v7 = v6 > 0x1869F;
      LODWORD(v3) = v6;
      ++v5;
    }
    while ( v7 );
  }
  else
  {
    v5 = 0;
  }
  v8 = v3;
  v9 = (unsigned int)v3 / 0xA;
  sub_161AC(v3, 0xAu);
  v11 = v10;
  v32 = (unsigned int)v3 / 0x64;
  if ( v5 )
  {
    if ( v9 <= 0x63 )
    {
      v28 = (unsigned int)v3 / 0xA;
      v29 = (unsigned __int8)a123456789[v32];
      *a2 = v29;
      if ( v29 == 32 )
        v30 = " 123456789";
      else
        v30 = "0123456789";
      sub_15EFC(v28, 0xAu);
      a2[1] = v30[v31];
      v27 = 46;
    }
    else
    {
      v21 = (unsigned __int8)a123456789[(unsigned int)v3 / 0x2710];
      *a2 = v21;
      if ( v21 == 32 )
        v22 = " 123456789";
      else
        v22 = "0123456789";
      sub_15EFC(v8 / 0x3E8, 0xAu);
      v24 = (unsigned __int8)v22[v23];
      a2[1] = v24;
      if ( v24 != 32 )
        v22 = "0123456789";
      sub_15EFC(v9, 0xAu);
      v11 = v25;
      sub_15EFC(v32, 0xAu);
      v27 = v22[v26];
    }
    a2[2] = v27;
    a2[3] = a0123456789[v11];
    v19 = *(_BYTE *)(a3 + v5);
  }
  else
  {
    v12 = (unsigned __int8)a123456789[(unsigned int)v3 / 0x2710];
    *a2 = v12;
    if ( v12 == 32 )
      v13 = " 123456789";
    else
      v13 = "0123456789";
    sub_15EFC(v8 / 0x3E8, 0xAu);
    v15 = (unsigned __int8)v13[v14];
    a2[1] = v15;
    if ( v15 != 32 )
      v13 = "0123456789";
    sub_15EFC(v32, 0xAu);
    v17 = (unsigned __int8)v13[v16];
    a2[2] = v17;
    if ( v17 != 32 )
      v13 = "0123456789";
    sub_15EFC(v9, 0xAu);
    a2[3] = v13[v18];
    v19 = a0123456789[v11];
  }
  a2[4] = v19;
  return a2 + 5;
}
// 15B20: variable 'v10' is possibly undefined
// 15B70: variable 'v14' is possibly undefined
// 15B8C: variable 'v16' is possibly undefined
// 15BA8: variable 'v18' is possibly undefined
// 15C00: variable 'v23' is possibly undefined
// 15C20: variable 'v25' is possibly undefined
// 15C2C: variable 'v26' is possibly undefined
// 15C6C: variable 'v31' is possibly undefined

//----- (00015CA0) --------------------------------------------------------
unsigned int __fastcall sub_15CA0(unsigned int result, unsigned int a2)
{
  if ( a2 != 1 )
  {
    if ( !a2 )
      JUMPOUT(0x62C74);
    if ( result <= a2 )
    {
      return result == a2;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (*)(void))((char *)&loc_15CD8 + 16 * (31 - (__clz(a2) - __clz(result)))))();
    }
    else
    {
      result >>= 31 - __clz(a2);
    }
  }
  return result;
}
// 15EF8: control flows out of bounds to 62C74

//----- (00015EFC) --------------------------------------------------------
unsigned int __fastcall sub_15EFC(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x15EF2);
  return sub_15CA0(a1, a2);
}
// 15EFE: control flows out of bounds to 15EF2

//----- (00015F18) --------------------------------------------------------
int __fastcall sub_15F18(int a1, int a2)
{
  if ( !a2 )
    JUMPOUT(0x62C74);
  return sub_15F1E();
}
// 161A8: control flows out of bounds to 62C74
// 15F1E: using guessed type int sub_15F1E(void);

//----- (00015F1E) --------------------------------------------------------
int __fastcall sub_15F1E(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_15F60 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 15F22: variable 'v2' is possibly undefined

//----- (000161AC) --------------------------------------------------------
int __fastcall sub_161AC(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x62C74);
  return sub_15F1E(a1, a2);
}
// 161A8: control flows out of bounds to 62C74

//----- (000161C8) --------------------------------------------------------
unsigned int __fastcall sub_161C8(double a1)
{
  return (unsigned int)(a1 - (double)(unsigned int)(a1 * 2.32830644e-10) * 4294967300.0);
}

//----- (00016208) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_3,
    a1,
    va);
  abort();
}
// 16212: positive sp value 4 has been found
// 16224: variable 'v4' is possibly undefined
// 62DBC: using guessed type int init();
// 62DF8: using guessed type int nullsub_3();

//----- (00016238) --------------------------------------------------------
int sub_16238()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 13AFC: using guessed type int _gmon_start__(void);

//----- (0001625C) --------------------------------------------------------
void *sub_1625C()
{
  return &unk_7D5FC;
}

//----- (00016280) --------------------------------------------------------
__int64 sub_16280()
{
  __int64 result; // r0

  LODWORD(result) = &unk_7D5FC;
  HIDWORD(result) = 0;
  return result;
}

//----- (000162AC) --------------------------------------------------------
void *sub_162AC()
{
  void *result; // r0

  if ( !byte_7D774 )
  {
    result = sub_1625C();
    byte_7D774 = 1;
  }
  return result;
}
// 7D774: using guessed type char byte_7D774;

//----- (000162C8) --------------------------------------------------------
int __fastcall sub_162C8(_DWORD *a1)
{
  _DWORD *i; // r3

  for ( i = a1; *i; ++i )
    ;
  return i - a1;
}

//----- (000162F0) --------------------------------------------------------
void __noreturn sub_162F0()
{
  sub_16E08();
}

//----- (000163D4) --------------------------------------------------------
int *__fastcall sub_163D4(int a1)
{
  int *result; // r0

  result = _errno_location();
  dword_7DB94 = (int)result;
  dword_7DB90 = a1;
  return result;
}
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;

//----- (000163FC) --------------------------------------------------------
void __fastcall __noreturn sub_163FC(int a1, int a2, int a3)
{
  int v6; // r0
  int v7; // r7
  bool v8; // zf
  char v9; // r3
  int v10; // r3
  int v11; // r0

  v6 = sub_162C8((_DWORD *)a3);
  v7 = v6;
  dword_7DB90 = a2;
  v8 = (a1 & 0xFFFFFFFB) == 105;
  if ( (a1 & 0xFFFFFFFB) != 0x69 )
    v8 = a1 == 30;
  v9 = !v8;
  if ( v6 == 2 )
    v10 = v9 & 1;
  else
    v10 = 0;
  if ( !v10 || (v11 = strcmp(*(const char **)(a3 + 4), "--help")) != 0 )
    LOBYTE(v11) = ((int (__fastcall *)(int, int))off_630C8[a1])(v7, a3);
  byte_7D5F8 = v11;
  sub_16E08();
}
// 630C8: using guessed type int (*off_630C8[2])();
// 7D5F8: using guessed type char byte_7D5F8;
// 7DB90: using guessed type int dword_7DB90;

//----- (00016490) --------------------------------------------------------
void __fastcall __noreturn sub_16490(unsigned __int8 *a1, const char **a2)
{
  int v4; // r1
  int v5; // r2
  unsigned __int8 *v6; // r0
  char *v7; // r4
  int v8; // r7
  int v9; // r7
  int v10; // r5
  size_t v11; // r0
  size_t v12; // r11
  size_t v13; // r6
  char *v14; // r5
  unsigned int v15; // r6
  unsigned int v16; // r3
  unsigned int v17; // r3
  const char *v19; // r5
  int v20; // r7
  const char *v21; // r5
  const char *v22; // r0
  bool v23; // zf
  _BYTE *v24; // r7
  const char *v25; // r8
  unsigned int v26; // r4
  int (*v27)(const char *, const char *); // r6
  const char *v28; // r0
  unsigned int v29; // r3
  unsigned int v30; // r3
  char *v31; // r9
  const char *v33; // r3

  if ( !sub_1684C(a1, (int)"busybox") )
    ((void (__fastcall __noreturn *)(unsigned __int8 *))loc_162F8)(a1);
  v6 = (unsigned __int8 *)a2[1];
  if ( !v6 )
    goto LABEL_3;
  if ( sub_1684C(v6, (int)"--list") )
  {
    v14 = (char *)&unk_644B8;
    v15 = 0;
    dup2(1, 2);
    while ( *v14 )
    {
      if ( a2[1][6] )
      {
        v16 = byte_6447A[v15 >> 1];
        if ( (v15 & 1) != 0 )
          v17 = v16 >> 4;
        else
          v17 = v16 & 0xF;
        sub_1712C((char *)*(&off_632B4 + v17) + 1);
      }
      ++v15;
      sub_1712C(v14);
      sub_1712C((char *)"\n");
      while ( *v14++ )
        ;
    }
  }
  else
  {
    v19 = a2[1];
    v20 = strcmp(v19, "--install");
    if ( v20 )
    {
      if ( !strcmp(v19, "--help") )
      {
        v33 = a2[2];
        if ( !v33 )
        {
LABEL_3:
          v7 = (char *)&unk_644B8;
          v8 = sub_17280(2, v4, v5);
          dup2(1, 2);
          v9 = v8 - 1;
          sub_1712C("BusyBox v1.29.3 (2025-04-16 10:16:12 CST)");
          v10 = 0;
          sub_1712C(" multi-call binary.\n");
          sub_1712C(
            "BusyBox is copyrighted by many authors between 1998-2015.\n"
            "Licensed under GPLv2. See source distribution for detailed\n"
            "copyright notices.\n"
            "\n"
            "Usage: busybox [function [arguments]...]\n"
            "   or: busybox --list[-full]\n"
            "   or: busybox --install [-s] [DIR]\n"
            "   or: function [arguments]...\n"
            "\n"
            "\tBusyBox is a multi-call binary that combines many common Unix\n"
            "\tutilities into a single executable.  Most people will create a\n"
            "\tlink to busybox for each function they wish to use and BusyBox\n"
            "\twill act like whatever it was invoked as.\n"
            "\n"
            "Currently defined functions:\n");
          while ( 1 )
          {
            if ( !*v7 )
            {
              sub_1712C((char *)"\n");
              goto LABEL_6;
            }
            v11 = strlen(v7);
            v12 = v11 + 2;
            v13 = v11;
            if ( (int)(v9 - (v11 + 2)) <= v10 )
              break;
            if ( !v10 )
              goto LABEL_9;
            sub_1712C((char *)", ");
LABEL_10:
            sub_1712C(v7);
            v10 += v12;
            v7 += v13 + 1;
          }
          sub_1712C(",\n");
LABEL_9:
          v10 = 6;
          sub_1712C("\t");
          goto LABEL_10;
        }
        *a2 = v33;
        a2[2] = 0;
      }
      else
      {
        ++a2;
      }
      dword_7DB90 = (int)sub_16A1C(*a2);
      sub_16490();
    }
    v21 = (const char *)sub_17B80("/proc/self/exe");
    if ( !v21 )
    {
      v21 = *a2;
      if ( **a2 != 47 )
        sub_16DBC("'%s' is not an absolute path", *a2);
    }
    v22 = a2[2];
    if ( v22 && !strcmp(v22, "-s") )
      v20 = ++a2 != 0;
    v23 = v20 == 0;
    v24 = &unk_644B8;
    v25 = a2[2];
    v26 = 0;
    v27 = symlink;
    if ( v23 )
      v27 = link;
    do
    {
      if ( v25 )
      {
        v28 = v25;
      }
      else
      {
        v29 = byte_6447A[v26 >> 1];
        if ( (v26 & 1) != 0 )
          v30 = v29 >> 4;
        else
          v30 = v29 & 0xF;
        v28 = (const char *)*(&off_632B4 + v30);
      }
      v31 = sub_16998(v28, v24);
      if ( v27(v21, v31) && *(_DWORD *)dword_7DB94 != 17 )
        sub_16B80(v31);
      free(v31);
      while ( *v24++ )
        ;
      ++v26;
    }
    while ( v26 != 123 );
  }
LABEL_6:
  exit(0);
}
// 164C0: variable 'v4' is possibly undefined
// 164C0: variable 'v5' is possibly undefined
// 632B4: using guessed type _UNKNOWN *off_632B4;
// 6447A: using guessed type unsigned __int8 byte_6447A[62];
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;

//----- (000167EC) --------------------------------------------------------
void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  mallopt(-1, 0x2000);
  mallopt(-3, 32512);
  sub_163D4((int)"busybox");
  dword_7DB90 = (int)*a2;
  if ( *(_BYTE *)dword_7DB90 == 45 )
    ++dword_7DB90;
  dword_7DB90 = (int)sub_169FC((const char *)dword_7DB90);
  sub_16490((unsigned __int8 *)dword_7DB90, a2);
}
// 7DB90: using guessed type int dword_7DB90;

//----- (0001684C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_1684C(unsigned __int8 *a1, int a2)
{
  int v2; // r1
  int v3; // r2
  int v4; // t1
  unsigned __int8 *v5; // r3

  v2 = a2 - 1;
  while ( 1 )
  {
    v4 = *(unsigned __int8 *)++v2;
    v3 = v4;
    v5 = a1;
    if ( !v4 )
      break;
    ++a1;
    if ( *v5 != v3 )
      return 0;
  }
  return v5;
}

//----- (00016880) --------------------------------------------------------
int __fastcall sub_16880(char *s1, char *s2)
{
  int v4; // r5

  v4 = 0;
  while ( *s1 )
  {
    if ( !strcmp(s1, s2) )
      return v4;
    ++v4;
    s1 += strlen(s1) + 1;
  }
  return -1;
}

//----- (000168D4) --------------------------------------------------------
int __fastcall sub_168D4(const char *a1, char *s)
{
  size_t v4; // r7
  int v5; // r4
  int v6; // r6

  v4 = strlen(s);
  if ( !v4 )
    return -1;
  v6 = 0;
  v5 = -1;
  while ( *a1 )
  {
    if ( !strncmp(a1, s, v4) )
    {
      if ( !a1[v4] )
        return v6;
      if ( v5 != -1 )
        return -1;
      v5 = v6;
    }
    ++v6;
    a1 += strlen(a1) + 1;
  }
  return v5;
}

//----- (00016964) --------------------------------------------------------
char *__fastcall sub_16964(char *s, int a2)
{
  while ( a2 )
  {
    --a2;
    s += strlen(s) + 1;
  }
  return s;
}

//----- (00016998) --------------------------------------------------------
char *__fastcall sub_16998(const char *a1, _BYTE *a2)
{
  const char *v2; // r5
  const char *v4; // r0
  _BYTE *v5; // r1
  _BYTE *v6; // r3
  char *v7; // r2

  v2 = "";
  if ( a1 )
    v2 = a1;
  v4 = sub_16AA8(v2, 47);
  v5 = a2;
  do
    v6 = v5++;
  while ( *v6 == 47 );
  v7 = "/";
  if ( v4 )
    v7 = "";
  return sub_177E4("%s%s%s", v2, v7);
}

//----- (000169FC) --------------------------------------------------------
char *__fastcall sub_169FC(const char *a1)
{
  const char *v1; // r4
  char *v2; // r0

  v1 = a1;
  v2 = strrchr(a1, 47);
  if ( v2 )
    return v2 + 1;
  return (char *)v1;
}

//----- (00016A1C) --------------------------------------------------------
char *__fastcall sub_16A1C(const char *a1)
{
  const char *v1; // r4
  char *v2; // r0

  v1 = a1;
  v2 = strrchr(a1, 47);
  if ( v2 && (v1 != v2 || v1[1]) )
    return v2 + 1;
  return (char *)v1;
}

//----- (00016A54) --------------------------------------------------------
char *__fastcall sub_16A54(const char *a1)
{
  const char *v2; // r0
  const char *i; // r0
  int v5; // t1
  _BOOL4 v6; // r3

  v2 = sub_16AA8(a1, 47);
  if ( v2 )
  {
    for ( i = v2 + 1; ; *i = 0 )
    {
      v5 = *(unsigned __int8 *)--i;
      v6 = v5 == 47;
      if ( a1 == i )
        v6 = 0;
      if ( !v6 )
        break;
    }
  }
  return sub_16A1C(a1);
}

//----- (00016AA8) --------------------------------------------------------
const char *__fastcall sub_16AA8(const char *a1, int a2)
{
  size_t v4; // r0

  if ( !a1 )
    return 0;
  if ( !*a1 )
    return (const char *)*(unsigned __int8 *)a1;
  v4 = strlen(a1) - 1;
  if ( (unsigned __int8)a1[v4] == a2 )
    return &a1[v4];
  else
    return 0;
}

//----- (00016AF4) --------------------------------------------------------
void sub_16AF4(const char *a1, ...)
{
  char *v1; // r0
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  v1 = *(char **)dword_7DB94;
  if ( *(_DWORD *)dword_7DB94 )
    v1 = strerror((int)v1);
  sub_16BA4(a1, (char *)varg_r1, v1);
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00016B40) --------------------------------------------------------
void __noreturn sub_16B40(const char *a1, ...)
{
  char *v1; // r0
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  v1 = *(char **)dword_7DB94;
  if ( *(_DWORD *)dword_7DB94 )
    v1 = strerror((int)v1);
  sub_16BA4(a1, (char *)varg_r1, v1);
  sub_16E08();
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00016B80) --------------------------------------------------------
void __fastcall sub_16B80(const char *a1)
{
  sub_16AF4("%s", a1);
}

//----- (00016B90) --------------------------------------------------------
void __fastcall __noreturn sub_16B90(const char *a1)
{
  sub_16B40("%s", a1);
}

//----- (00016BA4) --------------------------------------------------------
void __fastcall sub_16BA4(const char *a1, char *a2, const char *a3)
{
  const char *v4; // r4
  size_t v6; // r0
  size_t v7; // r5
  size_t v8; // r9
  size_t v9; // r7
  size_t v10; // r8
  signed int v11; // r11
  int v12; // r0
  size_t v13; // r10
  char *v14; // r0
  size_t v15; // r8
  int v16; // r3
  char *v17; // r0
  size_t v18; // [sp+4h] [bp-68h]
  char *dest[2]; // [sp+10h] [bp-5Ch] BYREF
  char v20[84]; // [sp+18h] [bp-54h] BYREF

  if ( !dword_7D4BC )
    return;
  v4 = a1;
  if ( !a1 )
    v4 = "";
  v6 = strlen((const char *)dword_7DB90);
  v7 = v6 + 2;
  v8 = v6;
  v18 = v6 + 2;
  if ( a3 )
    v9 = strlen(a3);
  else
    v9 = 0;
  v10 = strlen((const char *)off_7D4C0);
  if ( (int)(80 - v7) > 0 )
  {
    dest[1] = a2;
    dest[0] = v20;
    v11 = v7 + vsnprintf(&v20[v7], 80 - v7, v4, a2);
    if ( (int)(77 - v10 - v9) > v11 )
      goto LABEL_20;
  }
  v12 = vasprintf(dest, v4, a2);
  v13 = v12;
  if ( v12 < 0 )
    return;
  v11 = v7 + v12;
  v14 = (char *)realloc(dest[0], v7 + v12 + v9 + v10 + 3);
  if ( v14 )
  {
    dest[0] = v14;
    memmove(&v14[v7], v14, v13);
LABEL_20:
    strcpy(dest[0], (const char *)dword_7DB90);
    dest[0][v8] = 58;
    dest[0][v8 + 1] = 32;
    if ( a3 )
    {
      if ( *v4 )
      {
        dest[0][v11] = 58;
        v16 = v11 + 1;
        v11 += 2;
        dest[0][v16] = 32;
      }
      v17 = &dest[0][v11];
      v11 += v9;
      strcpy(v17, a3);
    }
    v15 = v11 + v10;
    strcpy(&dest[0][v11], (const char *)off_7D4C0);
    goto LABEL_12;
  }
  v15 = v13 + 1;
  v18 = 0;
  dest[0][v13] = 10;
LABEL_12:
  if ( (dword_7D4BC & 1) != 0 )
  {
    sub_177D8();
    sub_17FB8(2, dest[0], v15);
  }
  if ( (dword_7D4BC & 2) != 0 )
    syslog(dword_7D4C4, "%s", &dest[0][v18]);
  if ( dest[0] != v20 )
    free(dest[0]);
}
// 7D4BC: using guessed type int dword_7D4BC;
// 7D4C0: using guessed type _UNKNOWN *off_7D4C0;
// 7D4C4: using guessed type int dword_7D4C4;
// 7DB90: using guessed type int dword_7DB90;

//----- (00016DBC) --------------------------------------------------------
void __noreturn sub_16DBC(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  sub_16BA4(a1, (char *)varg_r1, 0);
  sub_16E08();
}

//----- (00016DDC) --------------------------------------------------------
void sub_16DDC(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  sub_16BA4(a1, (char *)varg_r1, 0);
}

//----- (00016E08) --------------------------------------------------------
void __noreturn sub_16E08()
{
  if ( off_7DB9C )
    off_7DB9C();
  exit((unsigned __int8)byte_7D5F8);
}
// 7D5F8: using guessed type char byte_7D5F8;
// 7DB9C: using guessed type int (*off_7DB9C)(void);

//----- (00016E34) --------------------------------------------------------
int __fastcall sub_16E34(int a1)
{
  int v2; // r0
  int v3; // r4

  v2 = fcntl(a1, 3);
  v3 = v2;
  if ( (v2 & 0x800) == 0 )
    fcntl(a1, 4, v2 | 0x800);
  return v3;
}

//----- (00016E68) --------------------------------------------------------
int __fastcall sub_16E68(int a1)
{
  int v2; // r0
  int v3; // r4

  v2 = fcntl(a1, 3);
  v3 = v2;
  if ( (v2 & 0x800) != 0 )
    fcntl(a1, 4, v2 & 0xFFFFF7FF);
  return v3;
}

//----- (00016E9C) --------------------------------------------------------
int __fastcall sub_16E9C(int a1)
{
  return fcntl(a1, 2, 1);
}

//----- (00016EA8) --------------------------------------------------------
char *__fastcall sub_16EA8(char *a1, const char *a2)
{
  return strncpy(a1, a2, 0x10u);
}

//----- (00016EB0) --------------------------------------------------------
_BYTE *__fastcall sub_16EB0(unsigned int a1, _BYTE *a2, int a3)
{
  int v3; // r9
  unsigned int v5; // r4
  int v6; // r8
  int v7; // r7
  unsigned int v8; // r2
  unsigned int v9; // r1
  _BOOL4 v10; // r3

  v3 = a3;
  if ( a3 )
  {
    v5 = 1000000000;
    v6 = 10;
    v7 = 0;
    do
    {
      v8 = sub_15EFC(a1, v5);
      a1 = v9;
      v10 = (v8 | v7) != 0;
      if ( v5 == 1 )
        v10 = 1;
      if ( v10 )
      {
        if ( !--v3 )
          return a2;
        ++v7;
        *a2++ = v8 + 48;
      }
      else
      {
        v7 = 0;
      }
      --v6;
      v5 /= 0xAu;
    }
    while ( v6 );
  }
  return a2;
}
// 16EDC: variable 'v9' is possibly undefined

//----- (00016F38) --------------------------------------------------------
_BYTE *__fastcall sub_16F38(signed int a1, _BYTE *a2, int a3)
{
  if ( !a3 )
    return a2;
  if ( a1 < 0 )
  {
    a1 = -a1;
    *a2 = 45;
    --a3;
    ++a2;
  }
  return sub_16EB0(a1, a2, a3);
}

//----- (00016F64) --------------------------------------------------------
_BYTE *__fastcall sub_16F64(unsigned int a1)
{
  *sub_16EB0(a1, byte_7D775, 11) = 0;
  return byte_7D775;
}
// 7D775: using guessed type _BYTE byte_7D775[12];

//----- (00016F8C) --------------------------------------------------------
_BYTE *__fastcall sub_16F8C(signed int a1)
{
  *sub_16F38(a1, byte_7D775, 11) = 0;
  return byte_7D775;
}
// 7D775: using guessed type _BYTE byte_7D775[12];

//----- (00016FB4) --------------------------------------------------------
int __fastcall sub_16FB4(int a1, unsigned __int8 *a2, int a3)
{
  int v3; // r3
  unsigned __int8 *v4; // r5
  unsigned int v6; // t1
  char v7; // r12

  v3 = a1;
  v4 = &a2[a3];
  while ( 1 )
  {
    v3 += 2;
    if ( a2 == v4 )
      break;
    v6 = *a2++;
    v7 = a0123456789abcd[v6 & 0xF] | 0x20;
    *(_BYTE *)(v3 - 2) = a0123456789abcd[v6 >> 4] | 0x20;
    *(_BYTE *)(v3 - 1) = v7;
  }
  return a1 + 2 * a3;
}

//----- (00017000) --------------------------------------------------------
_BYTE *__fastcall sub_17000(_BYTE *result, unsigned __int8 *a2, int a3)
{
  _BYTE *v3; // r2
  int *v4; // lr
  int v5; // r12
  int v6; // r3
  unsigned __int8 *v7; // r4
  unsigned int v8; // r3
  int v9; // r12
  unsigned int v10; // r3
  unsigned int v11; // r5
  bool v12; // zf

  v3 = &result[a3];
  v4 = (int *)dword_7DB94;
  *(_DWORD *)dword_7DB94 = 22;
  while ( 1 )
  {
    v5 = *a2;
    if ( !*a2 )
    {
      v6 = *a2;
      goto LABEL_5;
    }
    if ( result == v3 )
    {
      v6 = 34;
LABEL_5:
      *v4 = v6;
      return result;
    }
    v7 = a2 + 1;
    v8 = (unsigned __int8)(v5 - 48);
    if ( v8 > 9 )
    {
      if ( (v5 | 0x20u) - 97 > 5 )
        return 0;
      LOBYTE(v8) = (v5 | 0x20) - 87;
    }
    v9 = a2[1];
    v10 = (unsigned __int8)(16 * v8);
    v11 = (unsigned __int8)(v9 - 48);
    if ( v11 <= 9 )
    {
      LOBYTE(v10) = v11 | v10;
      goto LABEL_18;
    }
    if ( (v9 | 0x20u) - 97 <= 5 )
    {
      LOBYTE(v10) = ((v9 | 0x20) - 87) | v10;
      goto LABEL_18;
    }
    v12 = v9 == 0;
    if ( a2[1] )
      v12 = v9 == 58;
    if ( !v12 )
      return 0;
    v10 >>= 4;
LABEL_18:
    *result++ = v10;
    if ( v9 )
      v7 = a2 + 2;
    if ( *v7 == 58 )
      ++v7;
    a2 = v7;
  }
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000170EC) --------------------------------------------------------
ssize_t __fastcall sub_170EC(char a1, int a2, int a3)
{
  char v4; // [sp+7h] [bp-5h] BYREF
  int v5; // [sp+8h] [bp-4h]

  v5 = a3;
  v4 = a1;
  return write(2, &v4, 1u);
}

//----- (0001710C) --------------------------------------------------------
ssize_t __fastcall sub_1710C(char *a1)
{
  size_t v2; // r0

  v2 = strlen(a1);
  return sub_17FB8(1, a1, v2);
}

//----- (0001712C) --------------------------------------------------------
ssize_t __fastcall sub_1712C(char *a1)
{
  size_t v2; // r0

  v2 = strlen(a1);
  return sub_17FB8(2, a1, v2);
}

//----- (0001714C) --------------------------------------------------------
int __fastcall sub_1714C(int fd, int *a2, int *a3)
{
  int v3; // r5
  int v6; // r4
  int v7; // r0
  int v8; // r4
  int v9; // r6
  char *v10; // r0
  int v11; // r6
  char *v12; // r0
  _DWORD v14[2]; // [sp+0h] [bp-8h] BYREF

  v14[0] = fd;
  v14[1] = a2;
  v3 = fd;
  if ( fd == -1 )
  {
    if ( isatty(1) )
    {
      v6 = 1;
    }
    else
    {
      v6 = isatty(2);
      if ( v6 )
      {
        v6 = 2;
      }
      else if ( !isatty(0) )
      {
        v6 = open64("/dev/tty", 0);
        v3 = v6;
      }
    }
  }
  else
  {
    v6 = fd;
    v3 = -1;
  }
  v14[0] = 0;
  v7 = ioctl(v6, 0x5413u, v14, 0);
  if ( v7 )
    v8 = 1;
  else
    v8 = LOWORD(v14[0]);
  if ( !v7 )
    v8 = v8 == 0;
  if ( a3 )
  {
    v9 = LOWORD(v14[0]);
    v10 = getenv("LINES");
    if ( v10 )
    {
      v8 = 0;
      v9 = atoi(v10);
    }
    if ( (unsigned int)(v9 - 2) > 0x752D )
      v9 = 24;
    *a3 = v9;
  }
  if ( a2 )
  {
    v11 = HIWORD(v14[0]);
    v12 = getenv("COLUMNS");
    if ( v12 )
    {
      v8 = 0;
      v11 = atoi(v12);
    }
    if ( (unsigned int)(v11 - 2) > 0x752D )
      v11 = 80;
    *a2 = v11;
  }
  if ( v3 >= 0 )
    close(v3);
  return v8;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00017280) --------------------------------------------------------
int __fastcall sub_17280(int a1, int a2, int a3)
{
  int v4[2]; // [sp+4h] [bp-8h] BYREF

  v4[0] = a2;
  v4[1] = a3;
  sub_1714C(a1, v4, 0);
  return v4[0];
}

//----- (0001729C) --------------------------------------------------------
int __fastcall sub_1729C(struct termios *termios_p)
{
  return tcsetattr(0, 0, termios_p);
}

//----- (000172AC) --------------------------------------------------------
int __fastcall sub_172AC(int a1, int a2, struct termios *s, char a4)
{
  int v8; // r7
  tcflag_t c_oflag; // r1
  tcflag_t c_cflag; // r2
  tcflag_t c_lflag; // r3
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r3
  speed_t c_ispeed; // r1
  speed_t c_ospeed; // r2
  unsigned int v21; // r2
  int result; // r0

  memset(s, 0, sizeof(struct termios));
  v8 = tcgetattr(a1, s);
  c_oflag = s->c_oflag;
  c_cflag = s->c_cflag;
  c_lflag = s->c_lflag;
  *(_DWORD *)a2 = s->c_iflag;
  *(_DWORD *)(a2 + 4) = c_oflag;
  *(_DWORD *)(a2 + 8) = c_cflag;
  *(_DWORD *)(a2 + 12) = c_lflag;
  v12 = *(_DWORD *)&s->c_cc[3];
  v13 = *(_DWORD *)&s->c_cc[7];
  v14 = *(_DWORD *)&s->c_cc[11];
  *(_DWORD *)(a2 + 16) = *(_DWORD *)&s->c_line;
  *(_DWORD *)(a2 + 20) = v12;
  *(_DWORD *)(a2 + 24) = v13;
  *(_DWORD *)(a2 + 28) = v14;
  v15 = *(_DWORD *)&s->c_cc[19];
  v16 = *(_DWORD *)&s->c_cc[23];
  v17 = *(_DWORD *)&s->c_cc[27];
  *(_DWORD *)(a2 + 32) = *(_DWORD *)&s->c_cc[15];
  *(_DWORD *)(a2 + 36) = v15;
  *(_DWORD *)(a2 + 40) = v16;
  *(_DWORD *)(a2 + 44) = v17;
  v18 = *(_DWORD *)(a2 + 12);
  c_ispeed = s->c_ispeed;
  c_ospeed = s->c_ospeed;
  *(_DWORD *)(a2 + 48) = *(_DWORD *)&s->c_cc[31];
  *(_DWORD *)(a2 + 52) = c_ispeed;
  *(_DWORD *)(a2 + 56) = c_ospeed;
  v21 = v18 & 0xFFFFFFB5;
  if ( (a4 & 1) != 0 )
    v18 &= 0xFFFFFFB4;
  *(_DWORD *)(a2 + 12) = v21;
  result = v8;
  if ( (a4 & 1) != 0 )
    *(_DWORD *)(a2 + 12) = v18;
  *(_WORD *)(a2 + 22) = 256;
  if ( (a4 & 2) != 0 )
    *(_DWORD *)a2 &= 0xFFFFFAFF;
  if ( (a4 & 4) != 0 )
    *(_DWORD *)(a2 + 4) &= ~4u;
  if ( (a4 & 8) != 0 )
    *(_DWORD *)a2 &= 0xFFFFC0BD;
  return result;
}

//----- (00017364) --------------------------------------------------------
int __fastcall sub_17364(int a1, struct termios *s, char a3)
{
  struct termios termios_p; // [sp+4h] [bp-3Ch] BYREF

  sub_172AC(a1, (int)&termios_p, s, a3);
  return tcsetattr(a1, 0, &termios_p);
}

//----- (00017398) --------------------------------------------------------
__pid_t __fastcall sub_17398(__pid_t pid, int *stat_loc, int options)
{
  __pid_t result; // r0

  do
    result = waitpid(pid, stat_loc, options);
  while ( result == -1 && *(_DWORD *)dword_7DB94 == 4 );
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000173DC) --------------------------------------------------------
__pid_t __fastcall sub_173DC(int *stat_loc)
{
  return sub_17398(-1, stat_loc, 1);
}

//----- (000173EC) --------------------------------------------------------
int __fastcall sub_173EC(__pid_t a1, int a2, int a3)
{
  int v4; // r0
  int stat_loc[2]; // [sp+4h] [bp-8h] BYREF

  stat_loc[0] = a2;
  stat_loc[1] = a3;
  if ( a1 <= 0 || sub_17398(a1, stat_loc, 0) == -1 )
    return -1;
  v4 = stat_loc[0] & 0x7F;
  if ( (stat_loc[0] & 0x7F) == 0 )
    return BYTE1(stat_loc[0]);
  if ( (v4 + 1) << 24 >> 25 <= 0 )
    return 0;
  return v4 + 384;
}

//----- (00017440) --------------------------------------------------------
void __noreturn sub_17440()
{
  sub_16DBC("out of memory");
}

//----- (00017450) --------------------------------------------------------
void *__fastcall sub_17450(size_t a1)
{
  void *v2; // r5
  _BOOL4 v3; // r4

  v2 = malloc(a1);
  v3 = a1 != 0;
  if ( v2 )
    v3 = 0;
  if ( v3 )
    sub_16DDC("out of memory");
  return v2;
}

//----- (0001748C) --------------------------------------------------------
void *__fastcall sub_1748C(size_t a1)
{
  void *result; // r0
  _BOOL4 v3; // r4

  result = malloc(a1);
  v3 = a1 != 0;
  if ( result )
    v3 = 0;
  if ( v3 )
    sub_17440();
  return result;
}

//----- (000174B4) --------------------------------------------------------
void *__fastcall sub_174B4(void *a1, size_t a2)
{
  void *result; // r0
  _BOOL4 v4; // r4

  result = realloc(a1, a2);
  v4 = a2 != 0;
  if ( result )
    v4 = 0;
  if ( v4 )
    sub_17440();
  return result;
}

//----- (000174DC) --------------------------------------------------------
void *__fastcall sub_174DC(size_t a1)
{
  void *v2; // r0

  v2 = sub_1748C(a1);
  return memset(v2, 0, a1);
}

//----- (000174F8) --------------------------------------------------------
char *__fastcall sub_174F8(const char *a1)
{
  char *result; // r0

  if ( !a1 )
    return 0;
  result = strdup(a1);
  if ( !result )
    sub_17440();
  return result;
}

//----- (0001751C) --------------------------------------------------------
void *__fastcall sub_1751C(char *a1, int a2)
{
  char *v2; // r3
  int i; // r4
  size_t v5; // r4
  _BYTE *v6; // r0

  v2 = a1 - 1;
  for ( i = a2; i; --i )
  {
    if ( !*++v2 )
      break;
  }
  v5 = a2 - i;
  v6 = sub_1748C(v5 + 1);
  v6[v5] = 0;
  return memcpy(v6, a1, v5);
}

//----- (0001756C) --------------------------------------------------------
void *__fastcall sub_1756C(const void *a1, size_t a2)
{
  void *v4; // r0

  v4 = sub_1748C(a2);
  return memcpy(v4, a1, a2);
}

//----- (00017590) --------------------------------------------------------
int __fastcall sub_17590(const char *a1, int a2)
{
  int result; // r0

  result = fopen64(a1, a2);
  if ( !result )
    sub_16B40("can't open '%s'", a1);
  return result;
}
// 13FF4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (000175B4) --------------------------------------------------------
int __fastcall sub_175B4(const char *a1, int a2)
{
  int result; // r0

  result = open64(a1, a2);
  if ( result < 0 )
    sub_16B40("can't open '%s'", a1);
  return result;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (000175D8) --------------------------------------------------------
int __fastcall sub_175D8(const char *a1, int a2)
{
  return sub_175B4(a1, a2);
}

//----- (000175E0) --------------------------------------------------------
int __fastcall sub_175E0(const char *a1, int a2)
{
  int v3; // r4

  v3 = open64(a1, a2);
  if ( v3 < 0 )
    sub_16AF4("can't open '%s'", a1);
  return v3;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (0001760C) --------------------------------------------------------
int __fastcall sub_1760C(const char *a1, int a2)
{
  return sub_175E0(a1, a2);
}

//----- (00017614) --------------------------------------------------------
int __fastcall sub_17614(const char *a1)
{
  return sub_175D8(a1, 2048);
}

//----- (0001761C) --------------------------------------------------------
int __fastcall sub_1761C(const char *a1)
{
  int result; // r0

  result = unlink(a1);
  if ( result )
    sub_16B40("can't remove file '%s'", a1);
  return result;
}

//----- (00017640) --------------------------------------------------------
int __fastcall sub_17640(const char *a1, const char *a2)
{
  int result; // r0

  result = rename(a1, a2);
  if ( result )
    sub_16B40("can't move '%s' to '%s'", a1, a2);
  return result;
}

//----- (0001766C) --------------------------------------------------------
int __fastcall sub_1766C(int *a1)
{
  int result; // r0

  result = pipe(a1);
  if ( result )
    sub_16B40("can't create pipe");
  return result;
}

//----- (00017688) --------------------------------------------------------
int __fastcall sub_17688(int a1, int a2)
{
  int result; // r0

  result = dup2(a1, a2);
  if ( result != a2 )
    sub_16B40("can't duplicate file descriptor");
  return result;
}

//----- (000176A8) --------------------------------------------------------
int __fastcall sub_176A8(int result, int a2)
{
  int v2; // r4

  if ( result != a2 )
  {
    v2 = result;
    sub_17688(result, a2);
    return close(v2);
  }
  return result;
}

//----- (000176C8) --------------------------------------------------------
ssize_t __fastcall sub_176C8(ssize_t result, char *a2, size_t a3)
{
  int v4; // r1

  if ( a3 )
  {
    result = sub_17FB8(result, a2, a3);
    if ( result != a3 )
    {
      if ( result >= 0 )
        sub_16B40("short write", v4, "short write", "write error");
      sub_16B40("write error", v4, "short write", "write error");
    }
  }
  return result;
}
// 176ED: variable 'v4' is possibly undefined

//----- (00017700) --------------------------------------------------------
int __fastcall sub_17700(int a1)
{
  int result; // r0

  result = close(a1);
  if ( result )
    sub_16B40("close failed");
  return result;
}

//----- (0001771C) --------------------------------------------------------
int __fastcall sub_1771C(int a1, int a2, __int64 a3, int a4)
{
  __int64 v5; // r0

  LODWORD(v5) = lseek64(a1, a2);
  if ( v5 == -1 )
  {
    if ( !a4 )
      sub_16B40("lseek(%llu)", a3);
    sub_16B40("lseek");
  }
  return v5;
}
// 17744: variable 'v5' is possibly undefined
// 13928: using guessed type int __fastcall lseek64(_DWORD, _DWORD);

//----- (00017778) --------------------------------------------------------
int __fastcall sub_17778(const char *a1)
{
  int result; // r0

  result = mkstemp64(a1);
  if ( result < 0 )
    sub_16B40("can't create temp file '%s'", a1);
  return result;
}
// 13A24: using guessed type int __fastcall mkstemp64(_DWORD);

//----- (0001779C) --------------------------------------------------------
int __fastcall sub_1779C(FILE *a1, const char *a2)
{
  int result; // r0

  result = ferror_unlocked(a1);
  if ( result )
    sub_16DBC("%s: I/O error", a2);
  return result;
}

//----- (000177C0) --------------------------------------------------------
int sub_177C0()
{
  return sub_1779C((FILE *)stdout, "standard output");
}
// 7D614: using guessed type int stdout;

//----- (000177D8) --------------------------------------------------------
int sub_177D8()
{
  return fflush(0);
}

//----- (000177E4) --------------------------------------------------------
char *sub_177E4(const char *a1, ...)
{
  char *var8[3]; // [sp+4h] [bp-8h] BYREF
  char *varg_r1; // [sp+14h] [bp+8h] BYREF
  va_list varg_r1a; // [sp+14h] [bp+8h]
  char *varg_r2; // [sp+18h] [bp+Ch]
  va_list varg_r3; // [sp+1Ch] [bp+10h] BYREF

  va_start(varg_r3, a1);
  va_start(varg_r1a, a1);
  varg_r1 = va_arg(varg_r3, char *);
  varg_r2 = va_arg(varg_r3, char *);
  var8[0] = varg_r1;
  var8[1] = varg_r2;
  if ( vasprintf(var8, a1, varg_r1a) < 0 )
    sub_17440();
  return var8[0];
}

//----- (00017820) --------------------------------------------------------
int __fastcall sub_17820(const char *a1, const char *a2)
{
  int result; // r0

  result = setenv(a1, a2, 1);
  if ( result )
    sub_17440();
  return result;
}

//----- (00017838) --------------------------------------------------------
void __fastcall sub_17838(const char *a1)
{
  char *v1; // r5
  char *v2; // r0
  char *v3; // r4
  size_t v4; // r6
  char *v5; // r1
  _BYTE v6[112]; // [sp+0h] [bp-70h] BYREF

  v1 = (char *)a1;
  v2 = strchr(a1, 61);
  v3 = v2;
  if ( v2 )
  {
    v4 = v2 - v1;
    if ( (unsigned int)(v2 - v1) > 0x6F )
    {
      v1 = (char *)sub_1751C(v1, v2 - v1);
      v3 = v1;
    }
    else
    {
      v5 = v1;
      v1 = v6;
      v3 = 0;
      *((_BYTE *)memcpy(v6, v5, v4) + v4) = 0;
    }
  }
  unsetenv(v1);
  free(v3);
}

//----- (000178AC) --------------------------------------------------------
void __fastcall sub_178AC(char *a1)
{
  sub_17838(a1);
  free(a1);
}

//----- (000178C4) --------------------------------------------------------
int __fastcall sub_178C4(__gid_t a1)
{
  int result; // r0

  result = setgid(a1);
  if ( result )
    sub_16B40("setgid");
  return result;
}

//----- (000178E0) --------------------------------------------------------
int __fastcall sub_178E0(__uid_t a1)
{
  int result; // r0

  result = setuid(a1);
  if ( result )
    sub_16B40("setuid");
  return result;
}

//----- (000178FC) --------------------------------------------------------
int __fastcall sub_178FC(const char *a1)
{
  int result; // r0

  result = chdir(a1);
  if ( result )
    sub_16B40("can't change directory to '%s'", a1);
  return result;
}

//----- (00017920) --------------------------------------------------------
int __fastcall sub_17920(const char *a1)
{
  if ( chroot(a1) )
    sub_16B40("can't change root directory to '%s'", a1);
  return sub_178FC("/");
}

//----- (00017954) --------------------------------------------------------
DIR *__fastcall sub_17954(const char *a1)
{
  DIR *v2; // r4

  v2 = opendir(a1);
  if ( !v2 )
    sub_16AF4("can't open '%s'", a1);
  return v2;
}

//----- (00017980) --------------------------------------------------------
DIR *__fastcall sub_17980(const char *a1)
{
  DIR *result; // r0

  result = opendir(a1);
  if ( !result )
    sub_16B40("can't open '%s'", a1);
  return result;
}

//----- (000179A4) --------------------------------------------------------
int __fastcall sub_179A4(int a1, int a2, int a3)
{
  int result; // r0

  result = socket(a1, a2, a3);
  if ( result < 0 )
    sub_16B40("socket");
  return result;
}

//----- (000179C0) --------------------------------------------------------
int __fastcall sub_179C0(int a1, const struct sockaddr *a2, socklen_t a3)
{
  int result; // r0

  result = bind(a1, a2, a3);
  if ( result )
    sub_16B40("bind");
  return result;
}

//----- (000179DC) --------------------------------------------------------
ssize_t __fastcall sub_179DC(int a1, const void *a2, size_t a3, const struct sockaddr *a4, socklen_t a5)
{
  ssize_t result; // r0

  result = sendto(a1, a2, a3, 0, a4, a5);
  if ( result < 0 )
    sub_16B40("sendto");
  return result;
}

//----- (00017A0C) --------------------------------------------------------
int __fastcall sub_17A0C(const char *a1)
{
  int result; // r0

  result = sub_62DFC();
  if ( result )
    sub_16B40("can't stat '%s'", a1);
  return result;
}

//----- (00017A30) --------------------------------------------------------
int __fastcall sub_17A30(int a1, int a2, const char *a3)
{
  int result; // r0

  result = sub_62E08();
  if ( result )
    sub_16B90(a3);
  return result;
}

//----- (00017A4C) --------------------------------------------------------
int sub_17A4C(int a1, unsigned int a2, int a3, const char *a4, ...)
{
  int result; // r0
  char *v5; // r0
  va_list va; // [sp+10h] [bp+8h] BYREF

  va_start(va, a4);
  result = ioctl(a1, a2);
  if ( result < 0 )
  {
    v5 = strerror(*(_DWORD *)dword_7DB94);
    sub_16BA4(a4, (char *)va, v5);
    sub_16E08();
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00017AA0) --------------------------------------------------------
int sub_17AA0(int a1, unsigned int a2, int a3, const char *a4, ...)
{
  int v4; // r4
  char *v5; // r0
  va_list va; // [sp+18h] [bp+Ch] BYREF

  va_start(va, a4);
  v4 = ioctl(a1, a2);
  if ( v4 < 0 )
  {
    v5 = strerror(*(_DWORD *)dword_7DB94);
    sub_16BA4(a4, (char *)va, v5);
  }
  return v4;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00017AF4) --------------------------------------------------------
int __fastcall sub_17AF4(int a1, unsigned int a2, int a3, const char *a4)
{
  int v5; // r4

  v5 = ioctl(a1, a2);
  if ( v5 < 0 )
    sub_16B80(a4);
  return v5;
}

//----- (00017B18) --------------------------------------------------------
int __fastcall sub_17B18(int a1, unsigned int a2, int a3, const char *a4)
{
  int result; // r0

  result = ioctl(a1, a2);
  if ( result < 0 )
    sub_16B90(a4);
  return result;
}

//----- (00017B34) --------------------------------------------------------
char *__fastcall sub_17B34(int a1)
{
  char v2[132]; // [sp+0h] [bp-84h] BYREF

  if ( ttyname_r(a1, v2, 0x7Fu) )
    return 0;
  else
    return sub_174F8(v2);
}

//----- (00017B64) --------------------------------------------------------
__pid_t sub_17B64()
{
  __pid_t result; // r0

  result = fork();
  if ( result < 0 )
    sub_16B40("fork");
  return result;
}

//----- (00017B80) --------------------------------------------------------
void *__fastcall sub_17B80(const char *a1)
{
  signed int v1; // r5
  void *v3; // r4
  ssize_t v4; // r0
  void *v5; // r0

  v1 = 0;
  v3 = 0;
  do
  {
    v1 += 80;
    v3 = sub_174B4(v3, v1);
    v4 = readlink(a1, (char *)v3, v1);
    if ( v4 == -1 )
    {
      v5 = v3;
      v3 = 0;
      free(v5);
      return v3;
    }
  }
  while ( v1 <= v4 );
  *((_BYTE *)v3 + v4) = 0;
  return v3;
}

//----- (00017BE4) --------------------------------------------------------
char *__fastcall sub_17BE4(const char *a1)
{
  int v1; // r7
  char *v2; // r4
  size_t v3; // r6
  char *v4; // r0
  char *v5; // r0
  char *v6; // r5
  bool v7; // zf
  char *v8; // r0
  char *v10; // r0

  v1 = 21;
  v2 = sub_174F8(a1);
LABEL_2:
  v3 = strlen(v2) + 1;
  while ( 1 )
  {
    v5 = (char *)sub_17B80(v2);
    v6 = v5;
    if ( !v5 )
      break;
    if ( !--v1 )
    {
      free(v5);
LABEL_11:
      v8 = v2;
      v2 = 0;
      free(v8);
      return v2;
    }
    if ( *v5 == 47 )
    {
      v10 = v2;
      v2 = v6;
      free(v10);
      goto LABEL_2;
    }
    v3 += strlen(v5);
    v2 = (char *)sub_174B4(v2, v3);
    v4 = sub_16A54(v2);
    strcpy(v4, v6);
    free(v6);
  }
  v7 = *(_DWORD *)dword_7DB94 == 2;
  if ( *(_DWORD *)dword_7DB94 != 2 )
    v7 = *(_DWORD *)dword_7DB94 == 22;
  if ( !v7 )
    goto LABEL_11;
  return v2;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00017C9C) --------------------------------------------------------
void *__fastcall sub_17C9C(const char *a1)
{
  void *v2; // r4
  char *v3; // r2

  v2 = sub_17B80(a1);
  if ( !v2 )
  {
    if ( *(_DWORD *)dword_7DB94 == 22 )
      v3 = "not a symlink";
    else
      v3 = strerror(*(_DWORD *)dword_7DB94);
    sub_16DDC("%s: cannot read link: %s", a1, v3);
  }
  return v2;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00017CF0) --------------------------------------------------------
char *__fastcall sub_17CF0(const char *a1)
{
  return realpath(a1, 0);
}

//----- (00017CF8) --------------------------------------------------------
_BYTE *__fastcall sub_17CF8(const char *a1)
{
  _DWORD *v2; // r6
  _BYTE *v3; // r4
  char *v4; // r0
  const char *v5; // r6
  char *v6; // r0
  char *v7; // r7
  size_t v8; // r5
  size_t v9; // r0

  v2 = (_DWORD *)dword_7DB94;
  *(_DWORD *)dword_7DB94 = 0;
  v3 = sub_17CF0(a1);
  if ( !v3 && *v2 == 2 )
  {
    v4 = strrchr(a1, 47);
    if ( v4 )
    {
      *v4 = 0;
      v5 = v4 + 1;
      v6 = sub_17CF0(a1);
      v7 = v6;
      if ( v6 )
      {
        v8 = strlen(v6);
        v9 = strlen(v5);
        v3 = sub_174B4(v7, v9 + v8 + 2);
        v3[v8] = 47;
        strcpy(&v3[v8 + 1], v5);
      }
    }
  }
  return v3;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00017D9C) --------------------------------------------------------
__int64 __fastcall sub_17D9C(int fd, int a2, __int64 a3)
{
  __int64 v5; // r4
  int v6; // r11
  __int64 v7; // r6
  int v8; // r8
  size_t v9; // r2
  ssize_t v10; // r0
  int v11; // r3
  ssize_t v12; // r0
  int v13; // r2
  int v14; // r0
  __int64 v15; // r2
  int v17; // [sp+0h] [bp-100Ch]
  ssize_t v18; // [sp+4h] [bp-1008h]
  char buf[4100]; // [sp+8h] [bp-1004h] BYREF

  v5 = a3;
  if ( a3 >= 0 )
  {
    if ( fd >= 0 )
    {
      v6 = 0;
      if ( !a3 )
      {
        v5 = 0x1000000;
        v17 = 1;
LABEL_8:
        v7 = 0;
        v8 = 0x1000000;
        while ( 1 )
        {
          if ( !v8 )
            goto LABEL_10;
          v13 = v8;
          if ( v5 < v8 )
            v13 = v5;
          v14 = sendfile64(a2, fd, 0, v13);
          v11 = v14;
          if ( v14 >= 0 )
          {
            if ( !v14 )
              return v7;
          }
          else
          {
LABEL_10:
            v9 = v5;
            if ( v5 > 4096 )
              v9 = 4096;
            v10 = sub_1800C(fd, buf, v9);
            v11 = v10;
            if ( v10 < 0 )
            {
              sub_16AF4("read error");
              return -1;
            }
            if ( !v10 )
              return v7;
            if ( a2 < 0 || (v18 = v10, v12 = sub_17FB8(a2, buf, v10), v11 = v18, v18 <= v12) )
            {
              v8 = 0;
            }
            else
            {
              if ( !v6 )
              {
                sub_16AF4("write error");
                return -1;
              }
              v8 = 0;
              a2 = -1;
            }
          }
          v15 = v11;
          v7 += v15;
          if ( v17 == -1 )
          {
            v5 -= v15;
            if ( !v5 )
              return v7;
          }
        }
      }
LABEL_18:
      v17 = -1;
      goto LABEL_8;
    }
  }
  else
  {
    v5 = -a3;
    if ( fd >= 0 )
    {
      v6 = 1;
      goto LABEL_18;
    }
  }
  return -1;
}
// 134A4: using guessed type int __fastcall sendfile64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00017F2C) --------------------------------------------------------
__int64 __fastcall sub_17F2C(int a1, int a2, __int64 a3)
{
  if ( a3 )
    return sub_17D9C(a1, a2, a3);
  else
    return 0;
}

//----- (00017F58) --------------------------------------------------------
__int64 __fastcall sub_17F58(int a1, int a2, __int64 a3)
{
  int v3; // r6
  unsigned int v4; // r7
  __int64 result; // r0

  v3 = HIDWORD(a3);
  v4 = a3;
  result = sub_17F2C(a1, a2, a3);
  if ( __PAIR64__((v3 >> 31) ^ (unsigned int)v3, (v3 >> 31) ^ v4) - __PAIR64__(v3 >> 31, v3 >> 31) != result )
  {
    if ( result != -1 )
      sub_16DBC("short read");
    sub_16E08();
  }
  return result;
}

//----- (00017FAC) --------------------------------------------------------
__int64 __fastcall sub_17FAC(int a1, int a2)
{
  return sub_17D9C(a1, a2, 0);
}

//----- (00017FB8) --------------------------------------------------------
ssize_t __fastcall sub_17FB8(int fd, char *buf, size_t n)
{
  int v6; // r4
  ssize_t v7; // r0

  v6 = 0;
  while ( n )
  {
    v7 = sub_180F4(fd, buf, n);
    if ( v7 < 0 )
    {
      if ( !v6 )
        return v7;
      return v6;
    }
    v6 += v7;
    buf += v7;
    n -= v7;
  }
  return v6;
}

//----- (0001800C) --------------------------------------------------------
ssize_t __fastcall sub_1800C(int fd, void *buf, size_t nbytes)
{
  ssize_t result; // r0

  do
    result = read(fd, buf, nbytes);
  while ( result < 0 && *(_DWORD *)dword_7DB94 == 4 );
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00018050) --------------------------------------------------------
ssize_t __fastcall sub_18050(int fd, char *buf, size_t nbytes)
{
  int v6; // r4
  ssize_t v7; // r0

  v6 = 0;
  while ( nbytes )
  {
    v7 = sub_1800C(fd, buf, nbytes);
    if ( v7 < 0 )
    {
      if ( !v6 )
        return v7;
      return v6;
    }
    if ( !v7 )
      return v6;
    buf += v7;
    v6 += v7;
    nbytes -= v7;
  }
  return v6;
}

//----- (000180A8) --------------------------------------------------------
ssize_t __fastcall sub_180A8(int a1, char *a2, size_t a3)
{
  ssize_t v4; // r4

  v4 = sub_18050(a1, a2, a3);
  close(a1);
  return v4;
}

//----- (000180C8) --------------------------------------------------------
ssize_t __fastcall sub_180C8(int a1, char *a2, size_t a3)
{
  ssize_t result; // r0

  result = open64(a1, 0);
  if ( result >= 0 )
    return sub_180A8(result, a2, a3);
  return result;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (000180F4) --------------------------------------------------------
ssize_t __fastcall sub_180F4(int fd, void *buf, size_t n)
{
  ssize_t result; // r0

  while ( 1 )
  {
    result = write(fd, buf, n);
    if ( result >= 0 || *(_DWORD *)dword_7DB94 != 4 )
      break;
    *(_DWORD *)dword_7DB94 = 0;
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00018140) --------------------------------------------------------
void __fastcall sub_18140(int a1)
{
  dword_7DBA0 = a1;
}
// 7DBA0: using guessed type int dword_7DBA0;

//----- (00018150) --------------------------------------------------------
int __fastcall sub_18150(int a1, const struct sigaction *a2)
{
  return sigaction(a1, a2, 0);
}

//----- (00018158) --------------------------------------------------------
int __fastcall sub_18158(int a1)
{
  sigset_t v3; // [sp+0h] [bp-80h] BYREF

  sigfillset(&v3);
  return sigprocmask(a1, &v3, 0);
}

//----- (00018184) --------------------------------------------------------
__sighandler_t __fastcall sub_18184(__sighandler_t result, void (*a2)(int))
{
  __sighandler_t v2; // r4
  int v4; // r5
  int v5; // r6

  v2 = result;
  v4 = 1;
  v5 = 0;
  while ( v2 )
  {
    if ( ((unsigned int)v2 & v4) != 0 )
    {
      v2 = (__sighandler_t)((char *)v2 - v4);
      result = signal(v5, a2);
    }
    ++v5;
    v4 *= 2;
  }
  return result;
}

//----- (000181C4) --------------------------------------------------------
void *__fastcall sub_181C4(int a1, void (*a2)(int))
{
  void *result; // r0
  int v5; // r6
  int v6; // r5
  struct sigaction v7; // [sp+4h] [bp-8Ch] BYREF

  result = memset(&v7.sa_mask, 0, 0x88u);
  v5 = 0;
  v7.sa_handler = a2;
  v6 = 1;
  while ( a1 )
  {
    if ( (a1 & v6) != 0 )
    {
      a1 -= v6;
      result = (void *)sub_18150(v5, &v7);
    }
    ++v5;
    v6 *= 2;
  }
  return result;
}

//----- (00018228) --------------------------------------------------------
int __fastcall sub_18228(int a1)
{
  sigset_t v3; // [sp+0h] [bp-80h] BYREF

  sigemptyset(&v3);
  sigaddset(&v3, a1);
  return sigprocmask(1, &v3, 0);
}

//----- (00018260) --------------------------------------------------------
void __fastcall __noreturn sub_18260(int a1)
{
  signal(a1, 0);
  sub_18228(a1);
  raise(a1);
  exit(a1 | 0x80);
}

//----- (00018288) --------------------------------------------------------
int __fastcall sub_18288(int a1, void (*a2)(int))
{
  struct sigaction v5; // [sp+4h] [bp-90h] BYREF

  memset(&v5.sa_mask, 0, 0x88u);
  v5.sa_handler = a2;
  return sub_18150(a1, &v5);
}

//----- (000182C0) --------------------------------------------------------
int __fastcall sub_182C0(int a1)
{
  int result; // r0

  result = syscall(263, 1, a1);
  if ( result )
    sub_16DBC("clock_gettime(MONOTONIC) failed");
  return result;
}

//----- (000182E8) --------------------------------------------------------
struct tm *__fastcall sub_182E8(int a1, int *a2)
{
  struct tm *result; // r0
  char v5; // r3
  int tm_min; // r1
  int tm_hour; // r2
  int tm_mday; // r3
  int *v9; // r4
  int tm_year; // r1
  int tm_wday; // r2
  int tm_yday; // r3
  int *p_tm_isdst; // r12
  int v14; // r1
  int v15; // r2
  int v16; // r0
  int v17; // r7
  bool v18; // cc
  int v19; // r1
  char *v20; // r0
  _DWORD *v21; // r2
  unsigned int v22; // r3
  unsigned int v23; // r2
  unsigned int v24; // r7
  unsigned int v25; // r3
  char *v26; // [sp+14h] [bp-10h]
  _BYTE c[9]; // [sp+1Bh] [bp-9h] BYREF

  c[0] = 0;
  v26 = strrchr((const char *)a1, 58);
  if ( v26 )
  {
    result = (struct tm *)sscanf((const char *)a1, "%u:%u%c", a2 + 2, a2 + 1, c);
    if ( (int)result > 1 )
    {
LABEL_5:
      if ( c[0] != 58 )
        goto LABEL_9;
      result = (struct tm *)sscanf(v26 + 1, "%u%c", a2, c);
      goto LABEL_7;
    }
    result = (struct tm *)sscanf((const char *)a1, "%u.%u-%u:%u%c", a2 + 4, a2 + 3, a2 + 2, a2 + 1, c);
    if ( (int)result > 3 )
    {
LABEL_4:
      --a2[4];
      goto LABEL_5;
    }
    result = (struct tm *)sscanf((const char *)a1, "%u.%u.%u-%u:%u%c", a2 + 5, a2 + 4, a2 + 3, a2 + 2, a2 + 1, c);
    if ( (int)result > 4
      || (result = (struct tm *)sscanf((const char *)a1, "%u-%u-%u %u:%u%c", a2 + 5, a2 + 4, a2 + 3, a2 + 2, a2 + 1, c),
          (int)result > 4) )
    {
      a2[5] -= 1900;
      goto LABEL_4;
    }
LABEL_14:
    sub_16DBC("invalid date '%s'", (const char *)a1);
  }
  if ( strchr((const char *)a1, 45) )
  {
    result = (struct tm *)sscanf((const char *)a1, "%u-%u-%u %u%c", a2 + 5, a2 + 4, a2 + 3, a2 + 2, c);
    if ( (int)result > 3
      || (result = (struct tm *)sscanf((const char *)a1, "%u-%u-%u%c", a2 + 5, a2 + 4, a2 + 3, c), (int)result > 2) )
    {
      a2[5] -= 1900;
      --a2[4];
      goto LABEL_9;
    }
  }
  if ( *(_BYTE *)a1 == 64 )
  {
    result = (struct tm *)sub_189FC((char *)(a1 + 1), 0, 10);
    *(_DWORD *)&c[1] = result;
    if ( !*(_DWORD *)dword_7DB94 )
    {
      result = localtime((const time_t *)&c[1]);
      if ( result )
      {
        tm_min = result->tm_min;
        tm_hour = result->tm_hour;
        tm_mday = result->tm_mday;
        *a2 = result->tm_sec;
        a2[1] = tm_min;
        a2[2] = tm_hour;
        a2[3] = tm_mday;
        v9 = a2 + 4;
        tm_year = result->tm_year;
        tm_wday = result->tm_wday;
        tm_yday = result->tm_yday;
        p_tm_isdst = &result->tm_isdst;
        *v9 = result->tm_mon;
        v9[1] = tm_year;
        v9[2] = tm_wday;
        v9[3] = tm_yday;
        v9 += 4;
        result = (struct tm *)result->tm_isdst;
        v14 = p_tm_isdst[1];
        v15 = p_tm_isdst[2];
        *v9 = *p_tm_isdst;
        v9[1] = v14;
        v9[2] = v15;
        return result;
      }
    }
    v5 = 49;
LABEL_24:
    c[0] = v5;
    goto LABEL_9;
  }
  v16 = strchrnul((const char *)a1, 46) - a1;
  v17 = a2[5];
  switch ( v16 )
  {
    case 2:
      result = (struct tm *)sscanf((const char *)a1, "%2u%c", a2 + 1, c);
      v18 = (int)result <= 0;
      goto LABEL_27;
    case 4:
      result = (struct tm *)sscanf((const char *)a1, "%2u%2u%c", a2 + 2, a2 + 1, c);
      v18 = (int)result <= 1;
      goto LABEL_27;
    case 6:
      result = (struct tm *)sscanf((const char *)a1, "%2u%2u%2u%c", a2 + 3, a2 + 2, a2 + 1, c);
      v18 = (int)result <= 2;
LABEL_27:
      if ( v18 )
        goto LABEL_14;
      goto LABEL_28;
    case 8:
      result = (struct tm *)sscanf((const char *)a1, "%2u%2u%2u%2u%c", a2 + 4, a2 + 3, a2 + 2, a2 + 1, c);
      if ( (int)result <= 3 )
        goto LABEL_14;
LABEL_36:
      --a2[4];
      goto LABEL_28;
  }
  v21 = a2 + 5;
  if ( v16 != 10 )
  {
    if ( v16 != 12 )
      goto LABEL_14;
    result = (struct tm *)sscanf((const char *)a1, "%4u%2u%2u%2u%2u%c", v21, a2 + 4, a2 + 3, a2 + 2, a2 + 1, c);
    if ( (int)result <= 4 )
      goto LABEL_14;
    a2[5] -= 1900;
    goto LABEL_36;
  }
  result = (struct tm *)sscanf((const char *)a1, "%2u%2u%2u%2u%2u%c", v21, a2 + 4, a2 + 3, a2 + 2, a2 + 1, c);
  if ( (int)result <= 4 )
    goto LABEL_14;
  --a2[4];
  if ( v17 > 49 )
  {
    v22 = a2[5] + 100 * (v17 / 0x64u);
    v23 = v17 - 50;
    v24 = v17 + 50;
    a2[5] = v22;
    if ( v22 < v23 )
      a2[5] = v22 + 100;
    v25 = a2[5];
    if ( v25 > v24 )
      a2[5] = v25 - 100;
  }
LABEL_28:
  v19 = c[0];
  *a2 = 0;
  if ( v19 == 46 )
  {
    v20 = strchr((const char *)a1, 46);
    result = (struct tm *)sscanf(v20 + 1, "%u%c", a2, c);
LABEL_7:
    if ( result != (struct tm *)1 )
      goto LABEL_9;
    v5 = 0;
    goto LABEL_24;
  }
LABEL_9:
  if ( c[0] )
    goto LABEL_14;
  return result;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DB94: using guessed type int dword_7DB94;

//----- (00018740) --------------------------------------------------------
time_t __fastcall sub_18740(const char *a1, struct tm *tp)
{
  time_t result; // r0

  result = mktime(tp);
  if ( result == -1 )
    sub_16DBC("invalid date '%s'", a1);
  return result;
}

//----- (00018768) --------------------------------------------------------
char *__fastcall sub_18768(char *a1, size_t a2, time_t a3)
{
  time_t *v4; // r0
  struct tm *v6; // r0
  time_t timer[2]; // [sp+4h] [bp-8h] BYREF

  timer[0] = a2;
  timer[1] = a3;
  v4 = (time_t *)a3;
  if ( !a3 )
  {
    time(timer);
    v4 = timer;
  }
  v6 = localtime(v4);
  return &a1[strftime(a1, a2, "%H:%M:%S", v6)];
}

//----- (000187B0) --------------------------------------------------------
__int64 __fastcall sub_187B0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-Ch] BYREF
  int v5; // [sp+4h] [bp-8h]
  int v6; // [sp+8h] [bp-4h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  sub_182C0((int)&v4);
  return 1000000LL * v4 + v5 / 1000;
}

//----- (000187F0) --------------------------------------------------------
__int64 __fastcall sub_187F0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-Ch] BYREF
  int v5; // [sp+4h] [bp-8h]
  int v6; // [sp+8h] [bp-4h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  sub_182C0((int)&v4);
  return 1000LL * v4 + v5 / 1000000;
}

//----- (0001882C) --------------------------------------------------------
void __fastcall __spoils<R1,R2,R3,R12,LR> sub_1882C(int a1, int a2, int a3)
{
  _DWORD v3[3]; // [sp+0h] [bp-Ch] BYREF

  v3[1] = a2;
  v3[2] = a3;
  sub_182C0((int)v3);
}

//----- (00018844) --------------------------------------------------------
__int64 __fastcall sub_18844(int a1, int a2, _BYTE *a3)
{
  int v3; // r3
  __int64 result; // r0

  v3 = (unsigned __int8)*a3;
  if ( *a3 )
  {
    if ( (unsigned int)(v3 - 48) <= 9 || (v3 | 0x20u) - 97 <= 0x19 || *(_DWORD *)dword_7DB94 )
    {
      *(_DWORD *)dword_7DB94 = 34;
      return -1;
    }
    else
    {
      *(_DWORD *)dword_7DB94 = 22;
    }
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000188A4) --------------------------------------------------------
__int64 __fastcall sub_188A4(const char *a1, char *a2, int a3)
{
  char **p_endptr; // r4
  int v4; // r3
  __int64 result; // r0
  unsigned __int64 v6; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  endptr = a2;
  p_endptr = (char **)a2;
  if ( !a2 )
    p_endptr = &endptr;
  *p_endptr = (char *)a1;
  v4 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v4 - 48) <= 9 || (v4 | 0x20u) - 97 <= 0x19 )
  {
    *(_DWORD *)dword_7DB94 = 0;
    v6 = strtoull(a1, p_endptr, a3);
    return sub_18844(v6, SHIDWORD(v6), *p_endptr);
  }
  else
  {
    result = -1;
    *(_DWORD *)dword_7DB94 = 34;
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00018914) --------------------------------------------------------
__int64 __fastcall sub_18914(char *a1, char *a2, int a3)
{
  char **p_endptr; // r4
  int v4; // r3
  __int64 result; // r0
  __int64 v6; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  endptr = a2;
  p_endptr = (char **)a2;
  if ( !a2 )
    p_endptr = &endptr;
  *p_endptr = a1;
  v4 = (unsigned __int8)*a1;
  if ( v4 == 45 )
    v4 = (unsigned __int8)a1[1];
  if ( (unsigned int)(v4 - 48) <= 9 || (unsigned __int8)((v4 | 0x20) - 97) <= 0x19u )
  {
    *(_DWORD *)dword_7DB94 = 0;
    v6 = strtoll(a1, p_endptr, a3);
    return sub_18844(v6, SHIDWORD(v6), *p_endptr);
  }
  else
  {
    result = -1;
    *(_DWORD *)dword_7DB94 = 34;
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00018990) --------------------------------------------------------
int __fastcall sub_18990(const char *a1, char *a2, char *a3)
{
  char **v3; // r4
  int v4; // r3
  unsigned int v6; // r0
  char *endptr[2]; // [sp+4h] [bp-8h] BYREF

  endptr[0] = a2;
  endptr[1] = a3;
  v3 = (char **)a2;
  if ( !a2 )
    v3 = endptr;
  *v3 = (char *)a1;
  v4 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v4 - 48) <= 9 || (v4 | 0x20u) - 97 <= 0x19 )
  {
    *(_DWORD *)dword_7DB94 = 0;
    v6 = strtoul(a1, v3, (int)a3);
    return sub_18844(v6, 0, *v3);
  }
  else
  {
    *(_DWORD *)dword_7DB94 = 34;
    return -1;
  }
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000189FC) --------------------------------------------------------
int __fastcall sub_189FC(char *a1, char *a2, int a3)
{
  char **p_endptr; // r4
  int v4; // r3
  int v6; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  endptr = a2;
  p_endptr = (char **)a2;
  if ( !a2 )
    p_endptr = &endptr;
  *p_endptr = a1;
  v4 = (unsigned __int8)*a1;
  if ( v4 == 45 )
    v4 = (unsigned __int8)a1[1];
  if ( (unsigned int)(v4 - 48) <= 9 || (unsigned __int8)((v4 | 0x20) - 97) <= 0x19u )
  {
    *(_DWORD *)dword_7DB94 = 0;
    v6 = strtol(a1, p_endptr, a3);
    return sub_18844(v6, v6 >> 31, *p_endptr);
  }
  else
  {
    *(_DWORD *)dword_7DB94 = 34;
    return -1;
  }
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00018A74) --------------------------------------------------------
int __fastcall sub_18A74(int a1, char **a2)
{
  int v3; // r5
  char *v4; // r0
  int v5; // r1
  int v6; // r2
  char *v7; // r0
  const char *v8; // r0
  const char *v10; // [sp+14h] [bp-38h] BYREF
  const char *v11; // [sp+18h] [bp-34h] BYREF
  int v12; // [sp+1Ch] [bp-30h] BYREF
  char v13[44]; // [sp+20h] [bp-2Ch] BYREF

  v12 = 0;
  v10 = "sha512";
  v11 = 0;
  sub_593F8(a2, "^sP:+S:m:a:", "stdin", &v12, &v11, &v10, &v10);
  v3 = optind;
  if ( a2[optind] && !v11 )
    v11 = a2[optind + 1];
  v4 = (char *)sub_5FB7C(v13, v10);
  if ( v11 )
    sub_60B34(v4, v11, 35);
  sub_176A8(v12, 0);
  v7 = a2[v3];
  if ( v7 || (v7 = sub_58D24((FILE *)stdin, v5, v6)) != 0 )
  {
    v8 = (const char *)sub_5FBFC(v7, v13, 1);
    puts(v8);
  }
  return 0;
}
// 18B20: variable 'v5' is possibly undefined
// 18B20: variable 'v6' is possibly undefined
// 7D604: using guessed type int optind;
// 7D610: using guessed type int stdin;

//----- (00018B5C) --------------------------------------------------------
unsigned int sub_18B5C()
{
  return sleep(0xAu);
}

//----- (00018B64) --------------------------------------------------------
int __fastcall sub_18B64(const char *a1)
{
  int result; // r0

  result = sub_18990(a1, 0, (char *)0xA);
  if ( result >= 0 )
    return sub_60F24(result);
  return result;
}

//----- (00018B84) --------------------------------------------------------
int sub_18B84()
{
  int result; // r0

  result = sub_1729C((struct termios *)(dword_7DB98 + 72));
  if ( result < 0 )
    sub_16B40("tcsetattr");
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00018BB0) --------------------------------------------------------
ssize_t sub_18BB0()
{
  int v0; // r3
  int v1; // r2

  v0 = dword_7DB98;
  v1 = *(_DWORD *)(dword_7DB98 + 72);
  *(_DWORD *)(dword_7DB98 + 72) = v1 | 0x1400;
  if ( *(_BYTE *)(v0 + 68) == 13 )
    *(_DWORD *)(v0 + 72) = v1 | 0x1500;
  *(_DWORD *)(v0 + 84) |= 0xA3Bu;
  *(_BYTE *)(v0 + 89) = 3;
  *(_BYTE *)(v0 + 90) = 28;
  *(_BYTE *)(v0 + 100) = 10;
  *(_BYTE *)(v0 + 96) = 0;
  *(_WORD *)(v0 + 92) = 1045;
  sub_18B84();
  return sub_17FB8(1, (char *)"\n", 1u);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00018C30) --------------------------------------------------------
void __fastcall __noreturn handler(int a1)
{
  sub_18BB0();
  exit(0);
}

//----- (00018C40) --------------------------------------------------------
void __fastcall __noreturn sub_18C40(int a1, char **a2)
{
  char *v3; // r4
  char *v4; // r0
  unsigned __int8 *v5; // r2
  char *v6; // r2
  char **v7; // r8
  char *v8; // r3
  char *v9; // r0
  char *v10; // r7
  const char *v11; // r1
  int v12; // r5
  __pid_t v13; // r6
  int v14; // r6
  void (*v15)(int); // r8
  int v16; // r6
  unsigned __int8 *v17; // r3
  int v18; // r2
  int v19; // r6
  int v20; // r6
  int v21; // r0
  int v22; // r3
  int v23; // r3
  unsigned __int8 *v24; // r0
  unsigned int v25; // r0
  char *v26; // r0
  speed_t v27; // r5
  int v28; // r3
  char v29; // r2
  ssize_t v30; // r0
  const char *v31; // r1
  const char *v32; // r3
  const char *v33; // r0
  signed int v34; // r1
  int v35; // r5
  char *v36; // r11
  bool v37; // zf
  signed int v38; // r1
  int v39; // r1
  _DWORD *v40; // [sp+14h] [bp-10h]
  unsigned __int8 buf; // [sp+1Bh] [bp-9h] BYREF
  char *v42; // [sp+1Ch] [bp-8h] BYREF

  v3 = (char *)sub_174DC(0x104u);
  dword_7DB98 = (int)v3;
  *((_DWORD *)v3 + 1) = "/bin/login";
  *((_DWORD *)v3 + 5) = "/etc/issue";
  v3[68] = 13;
  if ( (sub_593CC(a2, "^I:LH:f:hil:mt:+wn", v3 + 16, v3 + 8, v3 + 20, v3 + 4, v3) & 1) != 0 )
  {
    v4 = sub_174F8(*((const char **)v3 + 4));
    *((_DWORD *)v3 + 4) = v4;
    sub_5E730(v4, (unsigned __int8 *)v4, v5);
  }
  v6 = a2[optind];
  v7 = &a2[optind];
  *((_DWORD *)v3 + 3) = v6;
  v8 = v7[1];
  if ( (unsigned int)(unsigned __int8)*v6 - 48 <= 9 )
  {
    *((_DWORD *)v3 + 3) = v8;
    v8 = v6;
  }
  v42 = v8;
  while ( 1 )
  {
    v9 = strsep(&v42, ",");
    v10 = v9;
    if ( !v9 )
      break;
    v20 = *((_DWORD *)v3 + 6);
    v21 = sub_18B64(v9);
    v22 = *((_DWORD *)v3 + 6);
    *(_DWORD *)&v3[4 * v20 + 28] = v21;
    if ( *(int *)&v3[4 * v22 + 28] < 0 )
      sub_16DBC("bad speed: %s", v10);
    v23 = v22 + 1;
    *((_DWORD *)v3 + 6) = v23;
    if ( v23 > 10 )
      sub_16DBC("too many alternate speeds");
  }
  v11 = v7[2];
  if ( v11 )
    sub_17820("TERM", v11);
  v12 = setsid();
  if ( v12 < 0 )
  {
    v13 = getpid();
    v12 = getsid(0);
    if ( v12 != v13 )
      sub_16B40("setsid");
    v14 = open64("/dev/tty", 2050);
    if ( v14 >= 0 )
    {
      v15 = signal(1, (__sighandler_t)1);
      ioctl(v14, 0x5422u);
      close(v14);
      signal(1, v15);
    }
  }
  v16 = sub_175D8("/dev/null", 2);
  sub_17688(v16, 1);
  sub_17688(v16, 2);
  while ( v16 > 2 )
    close(v16--);
  off_7DB9C = (int (*)(void))sub_18B5C;
  off_7D4C0 = "\r\n";
  openlog((const char *)dword_7DB90, 1, 32);
  dword_7D4BC = 3;
  v17 = (unsigned __int8 *)*((_DWORD *)v3 + 3);
  v18 = *v17;
  if ( v18 == 45 )
  {
    v19 = v17[1];
    if ( !v17[1] )
    {
      if ( (fcntl(v17[1], 3) & 3) != 2 )
        sub_16DBC("stdin is not open for read/write");
      v26 = sub_17B34(v19);
      if ( v26 )
        *((_DWORD *)v3 + 3) = v26;
      goto LABEL_28;
    }
  }
  else if ( v18 == 47 )
  {
LABEL_27:
    close(0);
    sub_175D8(*((const char **)v3 + 3), 2050);
    fchown(0, 0, 0);
    fchmod(0, 0x190u);
LABEL_28:
    v24 = sub_60EB8(*((unsigned __int8 **)v3 + 3));
    dword_7DB90 = (int)sub_177E4("getty: %s", (const char *)v24);
    sub_16E68(0);
    sub_17688(0, 1);
    sub_17688(0, 2);
    v25 = tcgetsid(0);
    if ( (v12 != v25) | (v25 >> 31) && ioctl(0, 0x540Eu, 1) < 0 )
      sub_16B40("TIOCSCTTY");
    if ( tcsetpgrp(0, v12) < 0 )
      sub_16B40("tcsetpgrp");
    if ( tcgetattr(0, (struct termios *)(v3 + 72)) < 0 )
      sub_16B40("tcgetattr");
    sub_61694(v12, 6, *((unsigned __int8 **)v3 + 3), "LOGIN", *((const char **)v3 + 2));
    v27 = *((_DWORD *)v3 + 7);
    sub_18288(14, sub_18140);
    alarm(5u);
    tcdrain(0);
    alarm(0);
    tcflush(0, 2);
    if ( v27 )
      cfsetspeed((struct termios *)(v3 + 72), v27);
    v28 = *((_DWORD *)v3 + 20) & 0x500F134F;
    *((_DWORD *)v3 + 20) = v28 | 0x4B0;
    v29 = dword_7DBC0;
    if ( (dword_7DBC0 & 2) != 0 )
    {
      v28 |= 0xCB0u;
      *((_DWORD *)v3 + 20) = v28;
    }
    if ( (v29 & 0x10) != 0 )
      v28 = *((_DWORD *)v3 + 20);
    *((_DWORD *)v3 + 19) = 5;
    *((_WORD *)v3 + 47) = 256;
    if ( (v29 & 0x10) != 0 )
      *((_DWORD *)v3 + 20) = v28 | 0x80000000;
    *((_DWORD *)v3 + 18) = 0;
    *((_DWORD *)v3 + 21) = 0;
    v3[88] = 0;
    sub_18B84();
    if ( (dword_7DBC0 & 1) != 0 )
      sub_1710C(*((char **)v3 + 4));
    if ( (dword_7DBC0 & 0x80) != 0 )
    {
      v3[95] = 0;
      sub_18B84();
      sleep(1u);
      v30 = sub_1800C(0, v3 + 132, 0x7Fu);
      if ( v30 > 0 )
      {
        v31 = v3 + 132;
        v3[v30 + 132] = 0;
        v32 = &v3[v30 + 132];
        do
        {
          v33 = v31;
          if ( v31 >= v32 )
            goto LABEL_55;
          ++v31;
        }
        while ( (unsigned int)*(unsigned __int8 *)v33 - 48 > 9 );
        v34 = sub_18B64(v33);
        if ( v34 > 0 )
          cfsetspeed((struct termios *)(v3 + 72), v34);
      }
LABEL_55:
      v3[95] = 1;
      sub_18B84();
    }
    signal(14, (__sighandler_t)handler);
    alarm(*(_DWORD *)v3);
    if ( (dword_7DBC0 & 0x200) != 0 )
    {
      do
      {
        if ( sub_1800C(0, &buf, 1u) != 1 )
          break;
        v37 = buf == 13;
        if ( buf != 13 )
          v37 = buf == 10;
      }
      while ( !v37 );
    }
    v35 = dword_7DBC0 & 0x400;
    if ( (dword_7DBC0 & 0x400) != 0 )
    {
LABEL_87:
      alarm(0);
      sub_18BB0();
      execlp(*((const char **)v3 + 1), *((const char **)v3 + 1), "--", v10, 0);
      sub_16DBC("can't execute '%s'", *((_DWORD *)v3 + 1));
    }
LABEL_58:
    usleep(0x186A0u);
    tcflush(0, 0);
LABEL_59:
    if ( (dword_7DBC0 & 0x20) == 0 )
      sub_5D328(*((_DWORD *)v3 + 5), *((struct utsname **)v3 + 3));
    sub_5D4C4();
    v10 = v3 + 132;
    v36 = v3 + 132;
    v40 = (_DWORD *)dword_7DB94;
    while ( 1 )
    {
      *v40 = 4;
      if ( read(0, &buf, 1u) <= 0 )
      {
        sub_18BB0();
        if ( (unsigned int)(*v40 - 4) > 1 )
          sub_16B40("read error");
LABEL_64:
        exit(0);
      }
      if ( buf == 8 )
        goto LABEL_84;
      if ( buf > 8u )
      {
        if ( buf == 13 )
          goto LABEL_86;
        if ( buf <= 0xDu )
        {
          if ( buf == 10 )
          {
LABEL_86:
            *v36 = 0;
            v3[68] = buf;
            if ( v3[132] )
              goto LABEL_87;
            goto LABEL_59;
          }
          goto LABEL_79;
        }
        if ( buf == 21 )
        {
          while ( v10 < v36 )
          {
            --v36;
            sub_17FB8(1, "\b \b", 3u);
          }
        }
        else
        {
          if ( buf != 127 )
            goto LABEL_79;
LABEL_84:
          v3[91] = buf;
          if ( v10 < v36 )
          {
            --v36;
            sub_17FB8(1, "\b \b", 3u);
          }
        }
      }
      else if ( buf )
      {
        if ( (unsigned int)buf - 3 <= 1 )
        {
          sub_18BB0();
          goto LABEL_64;
        }
LABEL_79:
        if ( buf > 0x1Fu && (unsigned int)(v36 - v10) <= 0x7E )
        {
          ++v36;
          sub_17FB8(1, (char *)&buf, 1u);
          *(v36 - 1) = buf;
        }
      }
      else
      {
        v38 = *((_DWORD *)v3 + 6);
        if ( v38 > 1 )
        {
          sub_161AC(v35 + 1, v38);
          v35 = v39;
          cfsetspeed((struct termios *)(v3 + 72), *(_DWORD *)&v3[4 * v39 + 28]);
          sub_18B84();
          goto LABEL_58;
        }
      }
    }
  }
  *((_DWORD *)v3 + 3) = sub_177E4("/dev/%s", *((const char **)v3 + 3));
  goto LABEL_27;
}
// 18CB8: variable 'v5' is possibly undefined
// 19300: variable 'v39' is possibly undefined
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 13E20: using guessed type int __fastcall getsid(_DWORD);
// 14224: using guessed type int __fastcall tcgetsid(_DWORD);
// 7D4BC: using guessed type int dword_7D4BC;
// 7D4C0: using guessed type _UNKNOWN *off_7D4C0;
// 7D604: using guessed type int optind;
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;
// 7DB9C: using guessed type int (*off_7DB9C)(void);
// 7DBC0: using guessed type int dword_7DBC0;

//----- (000193A4) --------------------------------------------------------
void __fastcall __noreturn sub_193A4(int a1)
{
  sub_16E34(1);
  sub_1729C(&buf);
  printf("\r\nLogin timed out after %u seconds\r\n", 60);
  sub_177D8();
  sub_16E68(1);
  exit(0);
}

//----- (000193E0) --------------------------------------------------------
int __fastcall sub_193E0(int a1, char **a2)
{
  int v3; // r9
  char v4; // r5
  const char *v5; // r1
  unsigned __int8 *v6; // r0
  unsigned __int8 *v7; // r0
  unsigned __int8 *v8; // r6
  char *v9; // r0
  int v10; // r8
  const char *v11; // r7
  int v12; // r4
  int v13; // r0
  bool v14; // cc
  char *v15; // r3
  char *v16; // r2
  struct passwd *v17; // r0
  int v18; // r4
  int v19; // r3
  bool v20; // zf
  FILE *v21; // r8
  int i; // r5
  __pid_t v23; // r0
  const char *v24; // r3
  char v25; // r1
  int v26; // r5
  int v28; // r0
  int v29; // r4
  const char *v30; // [sp+8h] [bp-4Ch] BYREF
  const char *v31; // [sp+Ch] [bp-48h] BYREF
  char name[68]; // [sp+10h] [bp-44h] BYREF

  v30 = 0;
  v3 = sub_5D500();
  sub_61B48(12);
  name[0] = 0;
  v4 = sub_593CC(a2, "f:h:p", &v31, &v30);
  if ( (v4 & 1) != 0 )
  {
    if ( v3 )
      sub_16DBC("-f is for root only");
    sub_60B34(name, v31, 64);
  }
  v5 = a2[optind];
  if ( v5 )
    sub_60B34(name, v5, 64);
  if ( tcgetattr(0, &buf) < 0 || !isatty(1) )
    return 1;
  signal(14, (__sighandler_t)sub_193A4);
  alarm(0x3Cu);
  v6 = (unsigned __int8 *)sub_17B34(0);
  if ( !v6 )
    v6 = (unsigned __int8 *)sub_174F8("UNKNOWN");
  v7 = sub_60EB8(v6);
  v8 = v7;
  if ( v30 )
    v9 = sub_177E4(" on '%s' from '%s'", (const char *)v7, v30);
  else
    v9 = sub_177E4(" on '%s'", (const char *)v7);
  v10 = 3;
  v11 = v9;
  openlog((const char *)dword_7DB90, 3, 32);
  while ( 2 )
  {
    tcflush(0, 0);
    if ( name[0] )
      goto LABEL_32;
    v12 = 10;
LABEL_16:
    sub_5D4C4();
    do
    {
      v13 = getchar_unlocked();
      if ( v13 == -1 )
        goto LABEL_18;
      if ( v13 == 10 )
      {
        if ( !--v12 )
          goto LABEL_18;
        goto LABEL_16;
      }
      v14 = (unsigned __int8)v13 > 0x20u;
      if ( (unsigned __int8)v13 != 32 )
        v14 = (unsigned int)(unsigned __int8)v13 - 9 > 4;
    }
    while ( !v14 );
    name[0] = v13;
    if ( !fgets_unlocked(&name[1], 62, stdin) || !strchr(&name[1], 10) )
LABEL_18:
      exit(1);
    v15 = &name[1];
    do
      v16 = v15++;
    while ( (unsigned __int8)*v16 > 0x20u );
    *v16 = 0;
LABEL_32:
    v17 = getpwnam(name);
    v18 = (int)v17;
    if ( !v17 )
    {
      strcpy(name, "UNKNOWN");
      goto LABEL_34;
    }
    v19 = *(unsigned __int8 *)v17->pw_passwd;
    v20 = v19 == 42;
    if ( v19 != 42 )
      v20 = v19 == 33;
    if ( !v20 )
    {
      if ( (v4 & 1) != 0 )
        goto LABEL_45;
      if ( v17->pw_uid || sub_60B70((const char *)v8) )
      {
        if ( !**(_BYTE **)(v18 + 4) )
          goto LABEL_45;
LABEL_34:
        if ( sub_585DC(v18) > 0 )
        {
LABEL_45:
          alarm(0);
          if ( !*(_DWORD *)(v18 + 8) || (v21 = (FILE *)sub_61C9C((int)"/etc/nologin")) == 0 )
          {
            fchown(0, *(_DWORD *)(v18 + 8), *(_DWORD *)(v18 + 12));
            fchmod(0, 0x180u);
            v23 = getpid();
            if ( v3 )
              v24 = 0;
            else
              v24 = v30;
            sub_61694(v23, 7, v8, name, v24);
            sub_57CD8(v18);
            if ( (v4 & 4) != 0 )
              v25 = 1;
            else
              v25 = 3;
            sub_60C00(*(const char **)(v18 + 24), v25, v18);
            if ( access(".hushlogin", 0) )
            {
              v26 = open64("/etc/motd", 0);
              if ( v26 >= 0 )
              {
                sub_177D8();
                sub_17FAC(v26, 1);
                close(v26);
              }
            }
            if ( !*(_DWORD *)(v18 + 8) )
              syslog(6, "root login%s", v11);
            signal(2, 0);
            sub_609D8(*(const char **)(v18 + 24), 1, 0);
          }
          for ( i = 1; ; i = 0 )
          {
            v28 = getc_unlocked(v21);
            v29 = v28;
            if ( v28 == -1 )
              break;
            if ( v28 == 10 )
              j_putchar_unlocked(13);
            j_putchar_unlocked(v29);
          }
          if ( i )
            puts("\r\nSystem closed for routine maintenance\r");
          fclose(v21);
          sub_177D8();
          tcdrain(1);
          goto LABEL_18;
        }
      }
    }
    v4 &= ~1u;
    sub_57988(3);
    puts("Login incorrect");
    if ( --v10 )
    {
      name[0] = 0;
      continue;
    }
    break;
  }
  syslog(4, "invalid password for '%s'%s", name, v11);
  return 1;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 14048: using guessed type int __fastcall fgets_unlocked(_DWORD, _DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7D610: using guessed type int stdin;
// 7DB90: using guessed type int dword_7DB90;

//----- (00019818) --------------------------------------------------------
int __fastcall sub_19818(int a1, char **a2)
{
  char v3; // r8
  int v4; // r5
  __uid_t v5; // r0
  char *v6; // r7
  __uid_t v7; // r10
  char *v8; // r0
  char *v9; // r0
  const char *v10; // r6
  const char *v11; // r11
  struct passwd *v12; // r0
  const char **p_pw_name; // r4
  const char *v14; // r0
  char *v15; // r2
  const char *v16; // r1
  int v17; // r2
  struct spwd *v18; // r5
  const char *v19; // r1
  int v20; // r5
  int v21; // r3
  char *v22; // r0
  char *v23; // r10
  const char *v24; // r0
  const char *v25; // r4
  char *v26; // r5
  const char *v27; // r0
  const char *v28; // r0
  char *v29; // r0
  int v30; // r0
  const char *v32; // r1
  _DWORD *v33; // [sp+8h] [bp-14Ch]
  const char *v34; // [sp+8h] [bp-14Ch]
  const char *v35; // [sp+14h] [bp-140h] BYREF
  struct spwd *v36[5]; // [sp+18h] [bp-13Ch] BYREF
  struct spwd result_buf; // [sp+2Ch] [bp-128h] BYREF
  char buffer[256]; // [sp+50h] [bp-104h] BYREF

  v35 = "sha512";
  dword_7D4BC = 3;
  openlog((const char *)dword_7DB90, 0, 32);
  v3 = sub_593CC(a2, "a:lud", &v35);
  v4 = optind;
  v5 = getuid();
  v6 = (char *)(v3 & 0xE);
  v7 = v5;
  if ( (v3 & 0xE) != 0 && (v5 || !a2[v4]) )
    sub_162F0();
  v8 = sub_57ADC(v5);
  v9 = sub_174F8(v8);
  v10 = a2[v4];
  v11 = v9;
  if ( !v10 )
    v10 = v9;
  v12 = sub_57A70(v10);
  p_pw_name = (const char **)&v12->pw_name;
  if ( v7 && v12->pw_uid != v7 )
  {
    v14 = "%s can't change password for %s";
    v15 = (char *)v10;
    v16 = v11;
    goto LABEL_10;
  }
  v36[0] = 0;
  v17 = dword_7DB94;
  *(_DWORD *)dword_7DB94 = 0;
  v33 = (_DWORD *)v17;
  if ( !getspnam_r(v12->pw_name, &result_buf, buffer, 0x100u, v36)
    && (v18 = v36[0]) != 0
    && !strcmp(v36[0]->sp_namp, *p_pw_name) )
  {
    p_pw_name[1] = v18->sp_pwdp;
  }
  else if ( *v33 != 2 )
  {
    sub_16AF4("no record of %s in %s, using %s", v10, "/etc/shadow", "/etc/passwd");
  }
  v19 = p_pw_name[1];
  if ( (v3 & 0xE) == 0 )
  {
    v20 = v7;
    if ( v7 )
      v20 = 1;
    if ( *v19 == 33 )
      v21 = v20;
    else
      v21 = 0;
    if ( v21 )
      sub_16DBC("can't change locked password for %s", v10);
    printf("Changing password for %s\n", v10);
    v34 = v35;
    if ( v7 && *p_pw_name[1] )
    {
      v22 = sub_578F0((int)"Old password: ");
      v23 = v22;
      if ( !v22 )
      {
LABEL_30:
        v25 = (const char *)(v3 & 0xE);
        v26 = (char *)v25;
        goto LABEL_43;
      }
      v24 = (const char *)sub_5FBFC(v22, (char *)p_pw_name[1], 1);
      if ( strcmp(v24, p_pw_name[1]) )
      {
        syslog(4, "incorrect password for %s", *p_pw_name);
        sub_57988(3);
        puts("Incorrect password");
        goto LABEL_30;
      }
    }
    else
    {
      v23 = "";
    }
    v27 = sub_578F0((int)"New password: ");
    v6 = (char *)v27;
    if ( v27 )
    {
      if ( sub_5DBFC(v23, v27, (int *)p_pw_name) )
        v25 = (const char *)v20;
      else
        v25 = 0;
      if ( v25 )
      {
        v25 = 0;
        v26 = 0;
      }
      else
      {
        v28 = sub_578F0((int)"Retype password: ");
        v26 = (char *)v28;
        if ( v28 )
        {
          if ( !strcmp(v28, v6) )
          {
            sub_5FB7C(v36, v34);
            v25 = (const char *)sub_5FBFC(v6, (char *)v36, 1);
          }
          else
          {
            puts("Passwords don't match");
          }
        }
        else
        {
          v25 = 0;
        }
      }
    }
    else
    {
      v25 = 0;
      v26 = 0;
    }
LABEL_43:
    sub_5DB1C(v23);
    sub_5DB1C(v6);
    sub_5DB1C(v26);
    if ( !v25 )
    {
      dword_7D4BC = 1;
      sub_16DBC("password for %s is unchanged", v10);
    }
    goto LABEL_53;
  }
  if ( (v3 & 2) != 0 )
  {
    if ( *v19 == 33 )
      goto LABEL_48;
    v29 = sub_177E4("!%s", v19);
LABEL_52:
    v25 = v29;
    goto LABEL_53;
  }
  if ( (v3 & 4) != 0 )
  {
    if ( *v19 != 33 )
      goto LABEL_48;
    v29 = sub_174F8(v19 + 1);
    goto LABEL_52;
  }
  v25 = "";
  if ( (v3 & 8) == 0 )
    v25 = 0;
LABEL_53:
  v36[2] = (struct spwd *)15360000;
  v36[3] = 0;
  v36[0] = (struct spwd *)15360000;
  v36[1] = 0;
  setrlimit64(1, v36);
  sub_18184((__sighandler_t)0xE, (void (*)(int))1);
  umask(0x3Fu);
  sub_178E0(0);
  v30 = sub_611D0("/etc/shadow", v10, v25);
  if ( v30 > 0 )
  {
    v25 = "x";
  }
  else if ( v30 )
  {
    v32 = "/etc/shadow";
    goto LABEL_67;
  }
  if ( sub_611D0("/etc/passwd", v10, v25) < 0 )
  {
    v32 = "/etc/passwd";
LABEL_67:
    sub_16DBC("can't update password file %s", v32);
  }
  sub_16DDC("password for %s changed by %s", v10, v11);
  if ( !v25 )
  {
LABEL_48:
    v15 = "un";
    v16 = v10;
    v14 = "password for %s is already %slocked";
    if ( (v3 & 4) == 0 )
      v15 = "";
LABEL_10:
    sub_16DBC(v14, v16, v15);
  }
  return 0;
}
// 135A0: using guessed type int __fastcall setrlimit64(_DWORD, _DWORD);
// 7D4BC: using guessed type int dword_7D4BC;
// 7D604: using guessed type int optind;
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;

//----- (00019C70) --------------------------------------------------------
int sub_19C70()
{
  unsigned int v0; // r1
  unsigned int v1; // r3

  v0 = *(_DWORD *)(dword_7DB98 + 20);
  v1 = *(_DWORD *)dword_7DB98;
  if ( (dword_7DBC0 & 0x80) == 0 )
    return v1 + *(_DWORD *)(dword_7DB98 + 28) >= v0;
  if ( v0 < v1 )
    return 1;
  return *(_DWORD *)(dword_7DB98 + 24) <= (unsigned int)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_7DB98 + 52) + 4 * v1)
                                                                   - 4)
                                                       + *(_DWORD *)(dword_7DB98 + 28));
}
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00019CE8) --------------------------------------------------------
int __fastcall sub_19CE8(int a1)
{
  unsigned int v1; // r2

  v1 = *(_DWORD *)(dword_7DB98 + 20);
  if ( v1 <= a1 )
    a1 = v1 - 1;
  if ( a1 < 0 )
    return 0;
  else
    return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_7DB98 + 52) + 4 * a1) - 4) + 1;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00019D1C) --------------------------------------------------------
int sub_19D1C()
{
  sub_177D8();
  return tcsetattr(*(_DWORD *)(dword_7DB98 + 4), 0, (const struct termios *)(dword_7DB98 + 140));
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00019D44) --------------------------------------------------------
int sub_19D44()
{
  return printf("\x1B[%u;0H\x1B[K", *(_DWORD *)(dword_7DB98 + 28) + 2);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00019D64) --------------------------------------------------------
void __fastcall __noreturn sub_19D64(int a1)
{
  sub_19D1C();
  if ( (*(_DWORD *)(dword_7DB98 + 8) & 0x800) == 0 )
    sub_16E68(*(_DWORD *)(dword_7DB98 + 4));
  sub_19D44();
  if ( a1 < 0 )
    sub_18260(-a1);
  exit(a1);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00019DAC) --------------------------------------------------------
void __fastcall __noreturn sub_19DAC(int a1)
{
  sub_19D64(-a1);
}

//----- (00019DB8) --------------------------------------------------------
int __fastcall sub_19DB8(const char *a1)
{
  sub_19D44();
  return printf("\x1B[7m%.*s\x1B[m", *(_DWORD *)(dword_7DB98 + 32) - 1, a1);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00019DEC) --------------------------------------------------------
char *__fastcall sub_19DEC(char *result)
{
  int v1; // r4
  int v2; // r6
  char *i; // r5
  int v4; // r2
  int v5; // r3

  v1 = dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 + 128) )
  {
    v2 = 4 * (_DWORD)result;
    for ( i = result; *(_DWORD *)(v1 + 20) >= (unsigned int)i; ++i )
    {
      result = (char *)regexec((const regex_t *)(v1 + 96), *(const char **)(*(_DWORD *)(v1 + 52) + v2), 0, 0, 0);
      if ( !result )
      {
        v4 = *(_DWORD *)(v1 + 92);
        result = *(char **)(v1 + 80);
        if ( !v4 || *(char **)&result[4 * v4 - 4] != i )
        {
          result = sub_62544(result, 0x404u, v4);
          v5 = *(_DWORD *)(v1 + 92);
          *(_DWORD *)(v1 + 80) = result;
          *(_DWORD *)(v1 + 92) = v5 + 1;
          *(_DWORD *)&result[4 * v5] = i;
        }
      }
      v2 += 4;
    }
  }
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00019E98) --------------------------------------------------------
void sub_19E98()
{
  _DWORD *v0; // r4
  char *v1; // r9
  signed int v2; // r11
  int v3; // r6
  char *v4; // r0
  const char *v5; // r5
  int v6; // r3
  int v7; // r4
  char *v8; // r10
  _DWORD *v9; // r4
  time_t v10; // r7
  time_t v11; // r0
  int v12; // r2
  int v13; // r1
  int v14; // r2
  int v15; // r0
  bool v16; // zf
  int v17; // r0
  signed int v18; // r12
  _DWORD *v19; // r10
  size_t v20; // r0
  _DWORD *v21; // r0
  unsigned int v22; // r2
  int v23; // r3
  int v24; // [sp+4h] [bp-18h]
  _DWORD *v25; // [sp+8h] [bp-14h]
  int v26; // [sp+10h] [bp-Ch]
  time_t v27; // [sp+14h] [bp-8h]

  v0 = (_DWORD *)dword_7DB98;
  v1 = *(char **)(dword_7DB98 + 20);
  v2 = *(_DWORD *)(dword_7DB98 + 32);
  v3 = *(unsigned __int8 *)(dword_7DB98 + 136);
  if ( (unsigned int)(v1 + 1) > 0x98967F )
    return;
  if ( (dword_7DBC0 & 8) != 0 )
    v2 -= 8;
  v4 = (char *)sub_1748C(v2 + 5);
  v5 = v4 + 4;
  v6 = v0[5];
  if ( v3 )
  {
    v8 = v4 + 4;
    v0[5] = v6 + 1;
    v0[4] = 0;
  }
  else
  {
    v7 = *(_DWORD *)(v0[13] + 4 * v6);
    v8 = (char *)stpcpy(v4 + 4, v7);
    free((void *)(v7 - 4));
  }
  v9 = (_DWORD *)dword_7DB98;
  v10 = 0;
  v24 = 2;
  while ( 2 )
  {
    *v8 = 0;
    v9[34] = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( v9[10] >= v9[11] )
          {
            v26 = sub_16E34(0);
            v25 = (_DWORD *)dword_7DB94;
            while ( 1 )
            {
              *v25 = 0;
              v9[9] = sub_1800C(0, &buf, 0x400u);
              if ( *v25 != 11 )
                break;
              v11 = time(0);
              if ( v10 != v11 && --v24 < 0 )
              {
                v10 = v11;
                break;
              }
              v27 = v11;
              sched_yield();
              v10 = v27;
            }
            fcntl(0, 4, v26);
            v12 = v9[9];
            v9[10] = 0;
            v9[11] = v12;
            if ( v12 <= 0 )
              goto LABEL_36;
            v24 = 1;
          }
          v13 = v9[10];
          v14 = *((unsigned __int8 *)&buf.c_iflag + v13);
          if ( v14 != 8 )
            break;
          v15 = v9[4];
          if ( !v15 || *(v8 - 1) == 9 )
            break;
          v9[10] = v13 + 1;
          --v8;
          v9[4] = v15 - 1;
          *v8 = 0;
        }
        if ( (dword_7DBC0 & 0x100) == 0 )
          break;
        if ( v14 != 27 )
        {
          if ( !v9[33] )
            break;
          if ( (unsigned __int8)(v14 - 48) > 9u )
          {
            v16 = (((_BYTE)v14 - 59) & 0xDF) == 0;
            if ( (((_BYTE)v14 - 59) & 0xDF) != 0 )
              v16 = v14 == 109;
            if ( !v16 )
            {
              v9[33] = 0;
              break;
            }
          }
        }
        v9[10] = v13 + 1;
        v9[33] = v14 != 109;
      }
      v17 = v9[4];
      v18 = v17 + 1;
      if ( v14 == 9 )
        v18 = (v17 + 8) & 0xFFFFFFF8;
      if ( v18 > v2 )
        goto LABEL_36;
      v9[4] = v18;
      v9[10] = v13 + 1;
      if ( v14 == 10 )
        break;
      v8[1] = 0;
      if ( !v14 )
        LOBYTE(v14) = 10;
      *v8++ = v14;
    }
    v9[4] = 0;
    v9[34] = 1;
LABEL_36:
    v19 = (_DWORD *)dword_7DB98;
    v19[13] = sub_62544(*(void **)(dword_7DB98 + 52), 0x408u, *(_DWORD *)(dword_7DB98 + 20));
    v20 = strlen(v5);
    v21 = sub_174B4((void *)(v5 - 4), v20 + 5);
    *(_DWORD *)(v19[13] + 4 * v19[5]) = v21 + 1;
    *v21 = v19[6];
    v22 = v19[5];
    if ( v19[34] )
      ++v19[6];
    if ( v22 <= 0x98967E )
    {
      if ( sub_19C70() )
        goto LABEL_53;
      if ( v19[22] >= v19[23] )
      {
        sub_19DEC(v1);
        v1 = (char *)v19[5];
      }
      if ( v19[22] >= v19[23] )
      {
LABEL_53:
        if ( (int)v19[9] > 0 )
        {
          ++v19[5];
          v5 = (char *)sub_1748C(v2 + 5) + 4;
          v19[4] = 0;
          v8 = (char *)v5;
          continue;
        }
      }
    }
    else
    {
      v19[9] = 0;
    }
    break;
  }
  v23 = v19[9];
  if ( v23 >= 0 )
  {
    if ( !v23 )
      v19[19] = v19[6];
  }
  else if ( *(_DWORD *)dword_7DB94 == 11 )
  {
    v19[9] = 1;
  }
  else
  {
    sub_19DB8("read error");
  }
  sub_19DEC(v1);
  v19[22] = -1;
}
// 1372C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001A254) --------------------------------------------------------
void __fastcall sub_1A254(int a1)
{
  unsigned int *v2; // r4
  int v3; // r2
  int v4; // r3
  int v5; // r1
  bool v6; // cc
  unsigned int v7; // r3

  v2 = (unsigned int *)dword_7DB98;
  if ( a1 > 0 )
  {
    v3 = *(_DWORD *)(dword_7DB98 + 52);
    if ( *(_DWORD *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)dword_7DB98) - 4) < (unsigned int)a1 )
    {
      while ( 1 )
      {
        v7 = *v2;
        if ( a1 == *(_DWORD *)(*(_DWORD *)(v2[13] + 4 * *v2) - 4) )
          break;
        if ( v7 < v2[5] )
        {
          *v2 = v7 + 1;
        }
        else
        {
          if ( (int)v2[9] <= 0 )
            return;
          sub_19E98();
        }
      }
    }
    else
    {
      while ( 1 )
      {
        v4 = *v2;
        v5 = *(_DWORD *)(*(_DWORD *)(v3 + 4 * *v2) - 4);
        v6 = v5 <= a1;
        if ( v5 != a1 )
          v6 = v4 <= 0;
        if ( v6 )
          break;
        *v2 = v4 - 1;
      }
    }
  }
  else
  {
    *(_DWORD *)dword_7DB98 = 0;
  }
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001A2F4) --------------------------------------------------------
void sub_1A2F4()
{
  int *v0; // r3
  unsigned int v1; // r1
  int v2; // r0
  unsigned int v3; // r2
  unsigned int v4; // r2
  unsigned int v5; // r2

  v0 = (int *)dword_7DB98;
  v1 = *(_DWORD *)dword_7DB98;
  v2 = *(_DWORD *)(dword_7DB98 + 28);
  v3 = *(_DWORD *)(dword_7DB98 + 20);
  if ( (dword_7DBC0 & 0x80) != 0 )
  {
    if ( v1 > v3 )
      *(_DWORD *)dword_7DB98 = v3;
    v4 = v0[6] + 1;
    if ( v2 + *(_DWORD *)(*(_DWORD *)(v0[13] + 4 * *v0) - 4) > v4 )
    {
      sub_1A254(v4 - v2);
      sub_19E98();
    }
  }
  else
  {
    v5 = v3 + 1;
    if ( v1 + v2 > v5 )
      *(_DWORD *)dword_7DB98 = v5 - v2;
    if ( *v0 < 0 )
      *v0 = 0;
  }
}
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001A388) --------------------------------------------------------
void sub_1A388()
{
  int v0; // r4
  int v1; // r6
  int v2; // r5
  int v3; // r3
  ssize_t v4; // r0
  __int16 v5; // [sp+10h] [bp-1058h]
  _BYTE v6[4096]; // [sp+68h] [bp-1000h] BYREF

  v0 = dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 + 76) >= 0xFFFFFFFE )
  {
    v1 = open64("/proc/self/fd/0", 0);
    if ( v1 >= 0 || *(_DWORD *)(v0 + 76) == -1 && (v1 = open64(*(_DWORD *)(v0 + 68), 0), v1 >= 0) )
    {
      v2 = sub_62E08();
      if ( !v2 && (v5 & 0xF000) == 0x8000 )
      {
LABEL_15:
        v4 = sub_1800C(v1, v6, 0x1000u);
        if ( v4 > 0 )
        {
          v3 = 0;
          while ( v6[v3] != 10 || ++v2 != 9999999 )
          {
            if ( v4 == ++v3 )
              goto LABEL_15;
          }
        }
        *(_DWORD *)(v0 + 76) = v2;
      }
      else
      {
        *(_DWORD *)(v0 + 76) = -3;
      }
      close(v1);
    }
    else
    {
      *(_DWORD *)(v0 + 76) = -3;
    }
  }
}
// 1A40C: variable 'v5' is possibly undefined
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (0001A488) --------------------------------------------------------
void sub_1A488()
{
  int v0; // r4
  unsigned int v1; // r2
  int v2; // r5
  int v3; // r1
  int v4; // r0
  unsigned int v5; // r5
  unsigned int v6; // r0
  int v7; // r1
  unsigned int v8; // r2
  int v9; // r3
  int v10; // r1
  unsigned int v11; // r0
  int v12; // r1

  v0 = dword_7DB98;
  if ( *(int *)(dword_7DB98 + 12) < 0 )
  {
    sub_19D44();
    printf("\x1B[7m%s", *(const char **)(v0 + 68));
    v1 = *(_DWORD *)(v0 + 60);
    if ( v1 > 1 )
      printf(" (file %i of %i)", *(_DWORD *)(v0 + 64), v1);
    v2 = *(_DWORD *)v0;
    v3 = sub_19CE8(*(_DWORD *)v0);
    v4 = *(_DWORD *)(v0 + 28);
    if ( (dword_7DBC0 & 0x80) != 0 )
    {
      v5 = *(_DWORD *)(v0 + 24);
      v6 = v3 + v4;
      if ( v6 < v5 )
        v5 = v6;
    }
    else
    {
      v5 = sub_19CE8(v2 + v4);
    }
    printf(" lines %i-%i", v3, v5);
    sub_1A388();
    v7 = *(_DWORD *)(v0 + 76);
    if ( v7 >= 0 )
      printf("/%i", v7);
    if ( sub_19C70() )
    {
      printf(" (END)");
      v8 = *(_DWORD *)(v0 + 60);
      if ( v8 > 1 )
      {
        v9 = *(_DWORD *)(v0 + 64);
        if ( v8 != v9 )
          printf(" - next: %s", *(_DWORD *)(*(_DWORD *)(v0 + 72) + 4 * v9));
      }
    }
    else
    {
      v10 = *(_DWORD *)(v0 + 76);
      if ( v10 > 0 )
      {
        v11 = sub_15F18((v10 >> 1) + 100 * v5, v10);
        if ( v11 >= 0x64 )
          v12 = 100;
        else
          v12 = v11;
        printf(" %i%%", v12);
      }
    }
    printf("\x1B[m");
  }
}
// 1A504: variable 'v3' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001A5D0) --------------------------------------------------------
void sub_1A5D0()
{
  _DWORD *v0; // r4
  const char *v1; // r1

  v0 = (_DWORD *)dword_7DB98;
  if ( *(int *)(dword_7DB98 + 12) < 0 )
  {
    if ( (dword_7DBC0 & 6) != 0 )
    {
      sub_1A488();
      return;
    }
    sub_19D44();
    if ( *v0 )
    {
      if ( !sub_19C70() )
      {
        j_putchar_unlocked(58);
        return;
      }
      v1 = "(END)";
    }
    else
    {
      v1 = (const char *)v0[17];
    }
    if ( v0[15] <= 1u )
      printf("\x1B[7m%s\x1B[m", v1);
    else
      printf("\x1B[7m%s (file %i of %i)\x1B[m", v1, v0[16]);
  }
}
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001A670) --------------------------------------------------------
void sub_1A670()
{
  const char *v0; // r10
  unsigned int v1; // r9
  const regex_t *v2; // r5
  unsigned int v3; // r2
  int v4; // r1
  size_t re_nsub; // r2
  int v6; // r3
  bool v7; // zf
  const char *v8; // r0
  const char *v9; // r4
  const char *v10; // r6
  char *v11; // r8
  char *v12; // r7
  const char *v13; // r1
  char *v14; // r6
  int i; // r3
  const char *v17; // r1
  size_t v18; // r0
  size_t v19; // r10
  size_t v20; // r10
  const char *v21; // r1
  size_t v22; // r0
  const char *v23; // r2
  size_t v24; // r0
  const char *v25; // r1
  char *v26; // r3
  int v27; // r2
  int v28; // t1
  int eflags; // [sp+0h] [bp-44h] BYREF
  char *v30; // [sp+4h] [bp-40h]
  char dest[4]; // [sp+8h] [bp-3Ch] BYREF
  char *v32; // [sp+Ch] [bp-38h]
  int *p_eflags; // [sp+10h] [bp-34h]
  int v34; // [sp+14h] [bp-30h]
  regmatch_t pmatch; // [sp+18h] [bp-2Ch] BYREF

  v1 = 0;
  printf("\x1B[%u;%uH", 0, 0);
  while ( 1 )
  {
    v2 = (const regex_t *)dword_7DB98;
    v3 = *(_DWORD *)(dword_7DB98 + 28);
    if ( v3 < v1 )
      break;
    printf("\x1B[K");
    if ( (dword_7DBC0 & 8) != 0 )
    {
      re_nsub = v2[1].re_nsub;
      v6 = *(_DWORD *)&v2[1].fastmap[4 * v1];
      v7 = v6 == re_nsub;
      if ( v6 == re_nsub )
      {
        v8 = "        ";
      }
      else
      {
        v6 = *(_DWORD *)(v6 - 4);
        v8 = "%7u ";
      }
      if ( !v7 )
        v34 = v6 + 1;
      printf(v8, v34);
    }
    v9 = *(const char **)&v2[1].fastmap[4 * v1];
    if ( v2[4].buffer )
    {
      p_eflags = &eflags;
      v10 = v9;
      v11 = dest;
      v12 = dest;
      while ( *v10 )
      {
        v18 = strcspn(v10, &reject);
        v19 = v18;
        if ( v18 )
        {
          if ( !v10[v18] )
            break;
          v32 = (char *)&v10[v18];
          memcpy(v12, v10, v18);
          v12 += v19;
          v10 = v32;
        }
        v20 = strspn(v10, &reject);
        memset(v12, 46, v20);
        v12 += v20;
        v10 += v20;
      }
      v0 = "%s%.*s\x1B[7m%.*s\x1B[m";
      v13 = v10;
      v14 = 0;
      strcpy(v12, v13);
      for ( i = 0; !regexec(v2 + 3, v9, 1u, &pmatch, i) && pmatch.rm_eo > pmatch.rm_so; i = 1 )
      {
        v30 = &v11[pmatch.rm_so];
        eflags = pmatch.rm_eo - pmatch.rm_so;
        if ( v14 )
          v21 = v14;
        else
          v21 = "";
        v32 = sub_177E4("%s%.*s\x1B[7m%.*s\x1B[m", v21, pmatch.rm_so, v11, eflags, v30);
        free(v14);
        v11 += pmatch.rm_eo;
        v9 += pmatch.rm_eo;
        v14 = v32;
      }
      v17 = "";
      if ( v14 )
        v17 = v14;
      printf("%s%s\n", v17, v11);
      free(v14);
    }
    else
    {
      while ( *v9 )
      {
        v22 = strcspn(v9, &reject);
        if ( v22 )
        {
          if ( !v9[v22] )
            break;
          v23 = v9;
          v9 += v22;
          printf("%.*s", v22, v23);
        }
        v24 = strspn(v9, &reject);
        v25 = v9 - 1;
        v26 = dest;
        do
        {
          v28 = *(unsigned __int8 *)++v25;
          v27 = v28;
          ++v26;
          if ( v28 == 127 )
          {
            *(v26 - 1) = 63;
          }
          else
          {
            if ( v27 == 155 )
              *(v26 - 1) = 123;
            else
              v0 = "@ABCDEFGHI@KLMNOPQRSTUVWXYZ[\\]^_";
            if ( v27 != 155 )
              *(v26 - 1) = v0[v27];
          }
        }
        while ( &dest[v24] != v26 );
        v9 += v24;
        dest[v24] = 0;
        printf("\x1B[7m%s\x1B[m", dest);
      }
      puts(v9);
    }
    ++v1;
  }
  if ( (dword_7DBC0 & 0x41) != 0 && *(int *)(dword_7DB98 + 36) <= 0 )
  {
    if ( (dword_7DBC0 & 0x40) != 0 )
      v4 = 0;
    else
      v4 = *(_DWORD *)dword_7DB98;
    if ( v3 >= *(_DWORD *)(dword_7DB98 + 20) - v4 )
      sub_19D64(0);
  }
  sub_1A5D0();
}
// 1A950: variable 'v0' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001A9BC) --------------------------------------------------------
void sub_1A9BC()
{
  _DWORD *v0; // r1
  unsigned int v1; // r3
  int v2; // r7
  int v3; // r0
  unsigned int v4; // r12
  unsigned int v5; // r2
  unsigned int v6; // lr
  unsigned int v7; // r4
  int v8; // r0
  int v9; // r2
  int v10; // r2
  int v11; // t1
  int v12; // r5
  int v13; // r6
  int v14; // r8
  _BOOL4 v15; // r0

  v0 = (_DWORD *)dword_7DB98;
  v1 = *(_DWORD *)dword_7DB98;
  v2 = dword_7DBC0 & 0x80;
  if ( (dword_7DBC0 & 0x80) != 0 )
  {
    v3 = 4 * v1;
    while ( v1 )
    {
      v9 = *(_DWORD *)(dword_7DB98 + 52);
      v11 = *(_DWORD *)(v9 + v3);
      v10 = v9 + v3;
      v3 -= 4;
      if ( *(_DWORD *)(v11 - 4) != *(_DWORD *)(*(_DWORD *)(v10 - 4) - 4) )
        break;
      --v1;
    }
  }
  v4 = *(_DWORD *)(dword_7DB98 + 28);
  v5 = 0;
  while ( v4 >= v5 )
  {
    v6 = v0[5];
    v7 = v5 + 1;
    v8 = v0[12];
    if ( v6 < v1 )
    {
      do
        *(_DWORD *)(v8 + 4 * v5++) = v0[14];
      while ( v4 >= v5 );
      break;
    }
    v12 = v0[13];
    v13 = *(_DWORD *)(v12 + 4 * v1);
    v14 = *(_DWORD *)(v13 - 4);
    *(_DWORD *)(v8 + 4 * v5) = v13;
    do
    {
      ++v1;
      v5 = v7;
      v15 = v6 >= v1;
      if ( !v2 )
        v15 = 0;
    }
    while ( v15 && v14 == *(_DWORD *)(*(_DWORD *)(v12 + 4 * v1) - 4) );
  }
  sub_1A670();
}
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001AAA0) --------------------------------------------------------
void sub_1AAA0()
{
  _DWORD *v0; // r4
  const char *v1; // r0
  int v2; // r0
  int v3; // r0
  unsigned int i; // r5
  _DWORD *v5; // r0

  v0 = (_DWORD *)dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 + 52) )
  {
    for ( i = 0; ; ++i )
    {
      v5 = (_DWORD *)v0[13];
      if ( v0[5] < i )
        break;
      v3 = v5[i];
      free((void *)(v3 - 4));
    }
    free(v5);
    v0[13] = 0;
  }
  v1 = (const char *)v0[17];
  *v0 = 0;
  v0[5] = -1;
  v0[6] = 0;
  if ( v1 )
  {
    v2 = sub_175D8(v1, 0);
    sub_176A8(v2, 0);
    v0[19] = -1;
  }
  else
  {
    v0[17] = sub_174F8("standard input");
    v0[19] = -2;
  }
  v0[10] = 0;
  v0[11] = 0;
  v0[4] = 0;
  v0[34] = 1;
  sub_19E98();
  sub_1A9BC();
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001AB68) --------------------------------------------------------
void __fastcall sub_1AB68(int a1)
{
  int v1; // r4
  int v2; // r3
  const char *v3; // r0
  int v4; // r0

  v1 = dword_7DB98;
  v2 = *(_DWORD *)(dword_7DB98 + 64);
  if ( a1 != 1 )
  {
    if ( v2 == 1 )
    {
      v3 = "No previous file";
      goto LABEL_11;
    }
    if ( !a1 )
    {
      v4 = 1;
      goto LABEL_9;
    }
LABEL_4:
    v4 = a1 + v2;
LABEL_9:
    *(_DWORD *)(dword_7DB98 + 64) = v4;
    free(*(void **)(v1 + 68));
    *(_DWORD *)(v1 + 68) = sub_174F8(*(const char **)(*(_DWORD *)(v1 + 72) + 4 * (*(_DWORD *)(v1 + 64) + 0x3FFFFFFF)));
    sub_1AAA0();
    return;
  }
  if ( v2 != *(_DWORD *)(dword_7DB98 + 60) )
    goto LABEL_4;
  v3 = "No next file";
LABEL_11:
  sub_19DB8(v3);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001ABF0) --------------------------------------------------------
void __fastcall sub_1ABF0(int a1)
{
  int v1; // r2

  v1 = *(_DWORD *)dword_7DB98;
  if ( (dword_7DBC0 & 0x80) != 0 )
    sub_1A254(a1 + *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_7DB98 + 52) + 4 * v1) - 4));
  else
    *(_DWORD *)dword_7DB98 = a1 + v1;
  sub_19E98();
  sub_1A2F4();
  sub_1A9BC();
}
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001AC44) --------------------------------------------------------
void __fastcall sub_1AC44(int a1)
{
  int v1; // r3
  int v2; // r0

  v1 = *(_DWORD *)dword_7DB98;
  if ( (dword_7DBC0 & 0x80) != 0 )
  {
    sub_1A254(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_7DB98 + 52) + 4 * v1) - 4) - a1);
  }
  else
  {
    v2 = v1 - a1;
    if ( v2 < 0 )
      v2 = dword_7DBC0 & 0x80;
    *(_DWORD *)dword_7DB98 = v2;
  }
  sub_19E98();
  sub_1A9BC();
}
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001ACA0) --------------------------------------------------------
void __fastcall sub_1ACA0(int a1, int a2)
{
  int v2; // r2
  int *v3; // r3

  v2 = a1;
  if ( a1 > 0 )
  {
    if ( a2 )
    {
      sub_1A254(a1);
      goto LABEL_6;
    }
    v3 = (int *)dword_7DB98;
  }
  else
  {
    v2 = 0;
    v3 = (int *)dword_7DB98;
  }
  *v3 = v2;
LABEL_6:
  sub_19E98();
  sub_1A2F4();
  sub_1A9BC();
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001ACEC) --------------------------------------------------------
void __fastcall sub_1ACEC(int a1)
{
  _DWORD *v1; // r5
  int v2; // r4
  int v3; // r3
  bool v4; // cc
  int v5; // r3

  v1 = (_DWORD *)dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 + 128) )
  {
    v2 = a1 & ~(a1 >> 31);
    if ( *(_DWORD *)(dword_7DB98 + 92) <= v2 && *(int *)(dword_7DB98 + 36) > 0 )
    {
      *(_DWORD *)(dword_7DB98 + 88) = v2;
      sub_19E98();
    }
    v3 = v1[23];
    if ( v3 )
    {
      v4 = v3 <= v2;
      if ( v3 <= v2 )
        v2 = v3 - 1;
      v5 = v1[20];
      if ( v4 )
        v2 &= ~(v2 >> 31);
      v1[21] = v2;
      sub_1ACA0(*(_DWORD *)(v5 + 4 * v2), 0);
    }
    else
    {
      sub_19DB8("No matches found");
    }
  }
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001AD6C) --------------------------------------------------------
int sub_1AD6C()
{
  int v0; // r4
  int v1; // r2
  const struct termios *v2; // r6
  _BOOL4 v3; // r5
  int v4; // r2
  int v5; // r5
  int v7; // [sp+0h] [bp-14h] BYREF
  __int16 v8; // [sp+4h] [bp-10h]
  int v9; // [sp+8h] [bp-Ch]
  __int16 v10; // [sp+Ch] [bp-8h]

  v0 = dword_7DB98;
  v7 = 0;
  v1 = *(_DWORD *)(dword_7DB98 + 4);
  v2 = (const struct termios *)(dword_7DB98 + 200);
  v8 = 1;
  v10 = 1;
  v9 = v1;
  while ( 1 )
  {
    tcsetattr(*(_DWORD *)(v0 + 4), 0, v2);
    if ( sub_19C70() )
      v3 = *(_DWORD *)(v0 + 36) <= 0;
    else
      v3 = 1;
    v4 = *(_DWORD *)(v0 + 12);
    if ( v4 >= 0 )
      printf("\x1B[%u;%uH", *(_DWORD *)(v0 + 28) + 2, v4 + 1);
    sub_177D8();
    if ( !*(_BYTE *)(v0 + 260) )
      sub_60AD4((struct pollfd *)&v7 + v3, 2 - v3, -1);
    v5 = sub_60068(*(_DWORD *)(v0 + 4), (char *)(v0 + 260), -2);
    if ( v5 != -1 )
      break;
    if ( *(_DWORD *)dword_7DB94 != 11 )
      sub_19D64(0);
    sub_19E98();
    sub_1A9BC();
  }
  sub_19D1C();
  return v5;
}
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;

//----- (0001AE78) --------------------------------------------------------
unsigned int __fastcall sub_1AE78(int a1)
{
  int v2; // r4
  unsigned int result; // r0
  bool v4; // r3

  v2 = dword_7DB98;
  do
  {
    *(_DWORD *)(v2 + 12) = a1;
    result = sub_1AD6C();
    *(_DWORD *)(v2 + 12) = -1;
    v4 = result <= 0x1F;
    if ( result == 13 )
      v4 = 0;
  }
  while ( result != 8 && v4 );
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001AEC8) --------------------------------------------------------
_BYTE *__fastcall sub_1AEC8(int a1)
{
  unsigned int v2; // r4
  _BYTE *v3; // r6
  int v4; // r7
  int v5; // r0
  int v6; // r5
  _BOOL4 v7; // r3
  size_t v8; // r1

  v2 = 0;
  v3 = sub_174DC(1u);
  v4 = dword_7DB98;
  while ( 1 )
  {
    *(_DWORD *)(v4 + 12) = a1 + v2;
    v5 = sub_1AD6C();
    v6 = v5;
    if ( v5 == 13 )
      break;
    if ( v5 == 127 )
      v6 = 8;
    v7 = v6 == 8;
    if ( !v2 )
      v7 = 0;
    if ( v7 )
    {
      --v2;
      printf("\b \b");
    }
    else if ( v6 > 31 && *(_DWORD *)(v4 + 32) - 1 - a1 > v2 )
    {
      j_putchar_unlocked(v6);
      v3[v2] = v6;
      v8 = v2 + 2;
      ++v2;
      v3 = sub_174B4(v3, v8);
    }
  }
  v3[v2] = 0;
  *(_DWORD *)(v4 + 12) = -1;
  return v3;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001AF9C) --------------------------------------------------------
void sub_1AF9C()
{
  const char *v0; // r0
  char *v1; // r5
  _DWORD *v2; // r4
  char **v3; // r3

  sub_19DB8("Examine: ");
  v0 = sub_1AEC8(9);
  v1 = (char *)v0;
  if ( !*v0 )
  {
    sub_1A5D0();
LABEL_3:
    free(v1);
    return;
  }
  if ( access(v0, 4) )
  {
    sub_19DB8("Cannot read this file");
    goto LABEL_3;
  }
  v2 = (_DWORD *)dword_7DB98;
  free(*(void **)(dword_7DB98 + 68));
  v3 = (char **)v2[18];
  v2[17] = v1;
  *v3 = v1;
  v2[16] = 1;
  v2[15] = 1;
  sub_1AAA0();
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001B028) --------------------------------------------------------
void sub_1B028()
{
  int v0; // r4
  int v1; // r3
  int v2; // r0
  char *v3; // r0
  char *v4; // r6
  char *v5; // r5
  int v6; // r2
  int v7; // r3

  v0 = dword_7DB98;
  free(*(void **)(dword_7DB98 + 80));
  v1 = *(_DWORD *)(v0 + 128);
  *(_DWORD *)(v0 + 80) = 0;
  *(_DWORD *)(v0 + 84) = 0;
  *(_DWORD *)(v0 + 92) = 0;
  if ( v1 )
  {
    regfree((regex_t *)(v0 + 96));
    *(_DWORD *)(v0 + 128) = 0;
  }
  sub_19D44();
  if ( (dword_7DBC0 & 0x8000) != 0 )
    v2 = 63;
  else
    v2 = 47;
  j_putchar_unlocked(v2);
  v3 = sub_1AEC8(1);
  v4 = v3;
  if ( *v3 )
  {
    v5 = sub_62594((regex_t *)(v0 + 96), v3, ((unsigned int)dword_7DBC0 >> 4) & 2);
    free(v4);
    if ( v5 )
    {
      sub_19DB8(v5);
      free(v5);
    }
    else
    {
      *(_DWORD *)(v0 + 84) = 0;
      *(_DWORD *)(v0 + 128) = 1;
      sub_19DEC(0);
      v6 = *(_DWORD *)(v0 + 92);
      while ( 1 )
      {
        v7 = *(_DWORD *)(v0 + 84);
        if ( v7 >= v6 || *(_DWORD *)(*(_DWORD *)(v0 + 80) + 4 * v7) > *(_DWORD *)v0 )
          break;
        *(_DWORD *)(v0 + 84) = v7 + 1;
      }
      if ( (dword_7DBC0 & 0x8000) != 0 )
        *(_DWORD *)(v0 + 84) = v7 - 1;
      sub_1ACEC(*(_DWORD *)(v0 + 84));
    }
  }
  else
  {
    free(v3);
    sub_1A670();
  }
}
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001B150) --------------------------------------------------------
int __fastcall sub_1B150(int a1, char **a2)
{
  char *v4; // r4
  int *v5; // r5
  char *v6; // r0
  char *v7; // r0
  unsigned int v8; // r2
  unsigned int v9; // t1
  int v10; // r2
  char *v11; // r0
  char *v12; // r7
  int v13; // r0
  int v14; // r6
  unsigned int v15; // r3
  signed int v17; // r0
  int v18; // r4
  bool v19; // zf
  int v20; // r5
  int v21; // r7
  unsigned int v22; // r0
  int v23; // r4
  int v24; // r5
  unsigned int v25; // r0
  bool v26; // zf
  unsigned int v27; // r0
  signed int v28; // r0
  int v29; // r3
  int v30; // r0
  int *v31; // r5
  int v32; // r0
  unsigned int v33; // r0
  _BYTE *v34; // r0
  void *v35; // r7
  const char *v36; // r0
  FILE *v37; // r8
  int v38; // r9
  unsigned int i; // r5
  const char *v40; // r2
  int v41; // r3
  char *v42; // r8
  int *v43; // r7
  unsigned int v44; // r9
  void *v45; // r3
  int *v46; // r2
  unsigned __int8 *v47; // r10
  int v48; // r5
  int v49; // r3
  _DWORD *v50; // r0
  void *v51; // r1
  int v52; // r2
  char *v53; // r0
  int v54; // r2
  int v55; // r3
  unsigned int v56; // r1
  int v57; // r3
  int v58; // r2
  _DWORD *v59; // r5
  unsigned int v60; // r3
  int v61; // r0
  unsigned int v62; // r2
  int v63; // r1
  int v64; // r1
  int v65; // t1
  unsigned int v66; // r3
  int v67; // r0
  unsigned int v68; // r2
  int v69; // r1
  int v70; // r1
  int v71; // t1
  int v72; // r0
  bool v73; // zf
  int v74; // r3
  bool v75; // zf
  int v76; // r2
  int v77; // [sp+0h] [bp-5Ch] BYREF
  int *v78; // [sp+4h] [bp-58h]
  int v79; // [sp+8h] [bp-54h]
  int *v80; // [sp+Ch] [bp-50h]
  int v81; // [sp+10h] [bp-4Ch]
  int v82; // [sp+14h] [bp-48h]
  void *ptr; // [sp+18h] [bp-44h]
  void *src; // [sp+1Ch] [bp-40h]
  int v85; // [sp+20h] [bp-3Ch]
  int v86; // [sp+24h] [bp-38h]
  char v87[20]; // [sp+28h] [bp-34h] BYREF

  v4 = (char *)sub_174DC(0x114u);
  dword_7DB98 = (int)v4;
  *((_DWORD *)v4 + 3) = -1;
  *((_DWORD *)v4 + 22) = -1;
  *((_DWORD *)v4 + 14) = "~";
  *((_DWORD *)v4 + 16) = 1;
  *((_DWORD *)v4 + 9) = 1;
  *((_DWORD *)v4 + 34) = 1;
  sub_593CC(a2, "EMmN~IFSRs");
  v5 = (int *)&a2[optind];
  *((_DWORD *)v4 + 15) = a1 - optind;
  *((_DWORD *)v4 + 18) = v5;
  v6 = getenv("LESS");
  if ( v6 )
  {
    v7 = v6 - 1;
    while ( 1 )
    {
      v9 = (unsigned __int8)*++v7;
      v8 = v9;
      if ( !v9 )
        goto LABEL_3;
      if ( v8 == 77 )
        break;
      if ( v8 > 0x4D )
      {
        if ( v8 == 82 )
        {
          v10 = dword_7DBC0 | 0x100;
LABEL_16:
          dword_7DBC0 = v10;
        }
        else if ( v8 == 83 )
        {
          v10 = dword_7DBC0 | 0x80;
          goto LABEL_16;
        }
      }
      else if ( v8 == 70 )
      {
        v10 = dword_7DBC0 | 0x40;
        goto LABEL_16;
      }
    }
    v10 = dword_7DBC0 | 2;
    goto LABEL_16;
  }
LABEL_3:
  if ( isatty(1) )
  {
    if ( *((_DWORD *)v4 + 15) )
    {
      *((_DWORD *)v4 + 17) = sub_174F8(**((const char ***)v4 + 18));
    }
    else if ( isatty(0) )
    {
      sub_162F0();
    }
    if ( (dword_7DBC0 & 0x10) != 0 )
      *((_DWORD *)v4 + 14) = "";
    v11 = sub_17B34(1);
    v12 = v11;
    if ( !v11 || (v14 = open64(v11, 0), free(v12), v14 < 0) )
    {
      v13 = open64("/dev/tty", 0);
      if ( v13 < 0 )
        v14 = 1;
      else
        v14 = v13;
    }
    *((_DWORD *)v4 + 2) = sub_16E34(v14);
    *((_DWORD *)v4 + 1) = v14;
    sub_172AC(v14, (int)(v4 + 200), (struct termios *)(v4 + 140), 2);
    sub_1714C(v14, (int *)v4 + 8, (int *)v4 + 7);
    if ( *((_DWORD *)v4 + 8) > 0x13u )
    {
      v15 = *((_DWORD *)v4 + 7);
      if ( v15 > 2 )
      {
        *((_DWORD *)v4 + 7) = v15 - 2;
        sub_18184((__sighandler_t)0x700F44E, (void (*)(int))sub_19DAC);
        *((_DWORD *)v4 + 12) = sub_1748C(4 * (*((_DWORD *)v4 + 7) + 1));
        sub_1AAA0();
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
                    do
                    {
                      v17 = sub_1AE78(-1);
                      v18 = v17;
                      if ( v17 == 78 )
                      {
                        v32 = *(_DWORD *)(dword_7DB98 + 84) - 1;
                        goto LABEL_96;
                      }
                      if ( v17 > 78 )
                      {
                        if ( v17 == 107 )
                          goto LABEL_105;
                        if ( v17 <= 107 )
                        {
                          if ( v17 == 100 )
                          {
                            v27 = (unsigned int)(*(_DWORD *)(dword_7DB98 + 28) + 1) >> 1;
                            goto LABEL_55;
                          }
                          if ( v17 > 100 )
                          {
                            if ( v17 == 102 )
                              goto LABEL_107;
                            if ( v17 < 102 )
                              goto LABEL_54;
                            if ( v17 != 103 )
                            {
                              v26 = v17 == 106;
                              goto LABEL_52;
                            }
                            goto LABEL_71;
                          }
                          if ( v17 == 82 )
                            goto LABEL_98;
                          if ( v17 == 98 )
                            goto LABEL_108;
                          if ( v17 != 81 )
                            continue;
LABEL_85:
                          sub_19D64(0);
                        }
                        if ( v17 == 115 )
                        {
                          sub_19DB8("Log file: ");
                          v34 = sub_1AEC8(10);
                          v35 = v34;
                          if ( *v34 )
                          {
                            v37 = (FILE *)sub_61CB4((int)v34);
                            if ( v37 )
                            {
                              v38 = dword_7DB98;
                              for ( i = 0; i <= *(_DWORD *)(v38 + 20); ++i )
                              {
                                v40 = *(const char **)(*(_DWORD *)(v38 + 52) + 4 * i);
                                fprintf(v37, "%s\n", v40);
                              }
                              fclose(v37);
                              v36 = "Done";
                            }
                            else
                            {
                              v36 = "Error opening log file";
                            }
                          }
                          else
                          {
                            v36 = "";
                          }
                          sub_19DB8(v36);
                          free(v35);
                          continue;
                        }
                        if ( v17 > 115 )
                        {
                          if ( v17 == 119 )
                            goto LABEL_108;
                          if ( v17 <= 119 )
                          {
                            if ( v17 != 117 )
                              continue;
                            v33 = (unsigned int)(*(_DWORD *)(dword_7DB98 + 28) + 1) >> 1;
                            goto LABEL_106;
                          }
                          if ( v17 != 121 )
                          {
                            v19 = v17 == 122;
                            goto LABEL_41;
                          }
                          goto LABEL_105;
                        }
                        if ( v17 == 112 )
                          goto LABEL_71;
                        if ( v17 > 112 )
                        {
                          if ( v17 != 113 )
                            goto LABEL_98;
                          goto LABEL_85;
                        }
                        if ( v17 != 110 )
                          continue;
                        v32 = *(_DWORD *)(dword_7DB98 + 84) + 1;
LABEL_96:
                        sub_1ACEC(v32);
                        continue;
                      }
                      if ( v17 == 37 )
                        goto LABEL_71;
                      if ( v17 <= 37 )
                      {
                        if ( v17 != -6 )
                        {
                          if ( v17 <= -6 )
                          {
                            if ( v17 != -10 )
                            {
                              if ( v17 != -7 )
                              {
                                v19 = v17 == -11;
LABEL_41:
                                if ( !v19 )
                                  continue;
LABEL_107:
                                v27 = *(_DWORD *)(dword_7DB98 + 28) + 1;
LABEL_55:
                                sub_1ABF0(v27);
                                continue;
                              }
LABEL_77:
                              v31 = (int *)dword_7DB98;
                              *(_DWORD *)dword_7DB98 = 9999999;
                              sub_19E98();
                              v30 = *v31;
LABEL_72:
                              sub_1ACA0(v30, 0);
                              continue;
                            }
LABEL_108:
                            v33 = *(_DWORD *)(dword_7DB98 + 28) + 1;
LABEL_106:
                            sub_1AC44(v33);
                            continue;
                          }
                          if ( v17 != -2 )
                          {
                            if ( v17 > -2 )
                            {
                              if ( v17 != 13 )
                              {
                                v19 = v17 == 32;
                                goto LABEL_41;
                              }
                            }
                            else
                            {
                              v26 = v17 == -3;
LABEL_52:
                              if ( !v26 )
                                continue;
                            }
LABEL_54:
                            v27 = 1;
                            goto LABEL_55;
                          }
LABEL_105:
                          v33 = 1;
                          goto LABEL_106;
                        }
LABEL_71:
                        v30 = 0;
                        goto LABEL_72;
                      }
                      if ( v17 == 61 )
                      {
LABEL_120:
                        sub_1A488();
                        continue;
                      }
                      if ( v17 > 61 )
                      {
                        if ( v17 != 63 )
                        {
                          if ( v17 >= 63 )
                          {
                            if ( v17 == 69 )
                            {
LABEL_119:
                              sub_1AF9C();
                              continue;
                            }
                            if ( v17 != 71 )
                              continue;
                          }
                          goto LABEL_77;
                        }
                        v41 = dword_7DBC0 | 0x8000;
LABEL_122:
                        dword_7DBC0 = v41;
                        sub_1B028();
                        continue;
                      }
                      if ( v17 == 47 )
                      {
                        v41 = dword_7DBC0 & 0xFFFF7FFF;
                        goto LABEL_122;
                      }
                      if ( v17 > 47 )
                      {
                        if ( v17 == 58 )
                        {
                          sub_19DB8(" :");
                          switch ( sub_1AE78(2) )
                          {
                            case 'd':
                              v59 = (_DWORD *)dword_7DB98;
                              if ( *(_DWORD *)(dword_7DB98 + 60) > 1u )
                              {
                                if ( *(_DWORD *)(dword_7DB98 + 64) == 1 )
                                {
                                  sub_1AB68(1);
                                  v66 = v59[15];
                                  v67 = 4;
                                  v68 = 2;
                                  while ( v68 <= v66 )
                                  {
                                    v69 = v59[18];
                                    ++v68;
                                    v71 = *(_DWORD *)(v69 + v67);
                                    v70 = v69 + v67;
                                    v67 += 4;
                                    *(_DWORD *)(v70 - 4) = v71;
                                  }
                                  v59[15] = v66 - 1;
                                  --v59[16];
                                }
                                else
                                {
                                  sub_1AB68(-1);
                                  v60 = v59[15];
                                  v61 = 8;
                                  v62 = 3;
                                  while ( v62 <= v60 )
                                  {
                                    v63 = v59[18];
                                    ++v62;
                                    v65 = *(_DWORD *)(v63 + v61);
                                    v64 = v63 + v61;
                                    v61 += 4;
                                    *(_DWORD *)(v64 - 4) = v65;
                                  }
                                  v59[15] = v60 - 1;
                                }
                              }
                              continue;
                            case 'e':
                              goto LABEL_119;
                            case 'f':
                              goto LABEL_120;
                            case 'n':
                              v72 = 1;
                              goto LABEL_168;
                            case 'p':
                              v72 = -1;
                              goto LABEL_168;
                            case 'q':
                              goto LABEL_85;
                            case 'x':
                              v72 = 0;
LABEL_168:
                              sub_1AB68(v72);
                              break;
                            default:
                              continue;
                          }
                          continue;
                        }
                        if ( v17 != 60 )
                          continue;
                        goto LABEL_71;
                      }
                      if ( v17 != 45 )
                        continue;
                      sub_19D44();
                      j_putchar_unlocked(v18);
                      v28 = sub_1AE78(1);
                      if ( v28 != 78 )
                      {
                        if ( v28 > 78 )
                        {
                          switch ( v28 )
                          {
                            case 'm':
                              v29 = dword_7DBC0 ^ 4;
                              break;
                            case '~':
                              v29 = dword_7DBC0 ^ 0x10;
                              break;
                            case 'S':
                              dword_7DBC0 ^= 0x80u;
                              goto LABEL_129;
                            default:
                              goto LABEL_98;
                          }
                        }
                        else if ( v28 == 69 )
                        {
                          v29 = dword_7DBC0 ^ 1;
                        }
                        else
                        {
                          if ( v28 != 77 )
                            goto LABEL_98;
                          v29 = dword_7DBC0 ^ 2;
                        }
                        dword_7DBC0 = v29;
                        goto LABEL_98;
                      }
                      v42 = 0;
                      v43 = (int *)dword_7DB98;
                      v44 = 0;
                      v80 = &v77;
                      v81 = 0;
                      v86 = 0;
                      v19 = (dword_7DBC0 & 8) == 0;
                      dword_7DBC0 ^= 8u;
                      v85 = *(_DWORD *)(dword_7DB98 + 32);
                      v45 = *(void **)(dword_7DB98 + 52);
                      src = &v77;
                      v46 = &v77;
                      ptr = v45;
                      if ( v19 )
                        v85 -= 8;
                      v47 = *(unsigned __int8 **)ptr;
                      v82 = *(_DWORD *)(*(_DWORD *)ptr - 4);
                      while ( 1 )
                      {
                        v48 = 0;
                        while ( 1 )
                        {
                          while ( 1 )
                          {
                            v49 = *v47;
                            *(_BYTE *)v46 = v49;
                            if ( v49 )
                              break;
                            v78 = v46;
                            v79 = 4 * v44;
                            free((void *)(*((_DWORD *)ptr + v44) - 4));
                            v55 = v81;
                            v19 = v44 == *v43;
                            v56 = v43[5];
                            ++v44;
                            if ( v19 )
                              v55 = v86;
                            v81 = v55;
                            v46 = v78;
                            if ( v56 >= v44 )
                            {
                              v47 = *(unsigned __int8 **)((char *)ptr + v79 + 4);
                              if ( v82 == *((_DWORD *)v47 - 1) )
                                continue;
                            }
                            goto LABEL_146;
                          }
                          if ( v49 == 9 )
                            v48 += 8;
                          else
                            ++v48;
                          ++v47;
                          if ( v49 == 9 )
                            v48 &= 0xFFFFFFF8;
                          if ( v48 >= v85 )
                            break;
                          v46 = (int *)((char *)v46 + 1);
                        }
                        *((_BYTE *)v46 + 1) = 0;
                        v46 = (int *)((char *)v46 + 1);
LABEL_146:
                        v79 = (char *)v46 - (_BYTE *)src;
                        v50 = sub_1748C((char *)v46 - (_BYTE *)src + 5);
                        v51 = src;
                        *v50 = v82;
                        v52 = v79;
                        v79 = (int)(v50 + 1);
                        memcpy(v50 + 1, v51, v52 + 1);
                        v53 = sub_62544(v42, 0x408u, v86);
                        v54 = v86;
                        v42 = v53;
                        *(_DWORD *)&v53[4 * v86] = v79;
                        v86 = v54 + 1;
                        if ( v85 > v48 )
                          break;
LABEL_149:
                        v46 = (int *)src;
                      }
                      if ( v43[5] >= v44 )
                      {
                        v82 = *((_DWORD *)v47 - 1);
                        goto LABEL_149;
                      }
                      v86 = v54;
                      free(ptr);
                      v57 = v81;
                      v58 = v86;
                      v43[13] = (int)v42;
                      *v43 = v57;
                      v43[5] = v58;
                      v43[4] = v48;
                      v43[32] = 0;
LABEL_129:
                      sub_1A9BC();
LABEL_98:
                      sub_1A670();
                    }
                    while ( (unsigned int)(unsigned __int8)v18 - 48 > 9 );
                    v20 = 1;
                    v87[0] = v18;
                    sub_19D44();
                    printf(":%c", v18);
                    do
                    {
                      v21 = v20 + 1;
                      v22 = sub_1AE78(v20 + 1);
                      v23 = v22;
                      if ( v22 > 0xFF )
                        break;
                      if ( (unsigned int)(unsigned __int8)v22 - 48 > 9 )
                        break;
                      ++v20;
                      v87[v21 - 1] = v22;
                      j_putchar_unlocked(v22);
                    }
                    while ( v21 != 15 );
                    v87[v20] = 0;
                    v24 = sub_18990(v87, 0, (char *)0xA);
                    v25 = v24 - 1;
                    if ( (unsigned int)(v24 - 1) <= 0x98967E )
                      break;
                    sub_1A670();
                  }
                  if ( v23 != 71 )
                    break;
LABEL_200:
                  sub_1ACA0(v25, 1);
                }
                if ( v23 > 71 )
                  break;
                if ( v23 == 37 )
                  goto LABEL_207;
                if ( v23 > 37 )
                {
                  if ( v23 == 60 )
                    goto LABEL_200;
                  if ( v23 > 60 )
                  {
                    if ( v23 == 62 )
                      goto LABEL_200;
                    if ( v23 == 63 )
                    {
                      v74 = dword_7DBC0 | 0x8000;
LABEL_187:
                      dword_7DBC0 = v74;
                      sub_1B028();
                    }
                  }
                  else if ( v23 == 47 )
                  {
                    v74 = dword_7DBC0 & 0xFFFF7FFF;
                    goto LABEL_187;
                  }
                }
                else
                {
                  if ( v23 == -2 )
                    goto LABEL_198;
                  if ( v23 > -2 )
                  {
                    if ( v23 != 13 )
                    {
                      v73 = v23 == 32;
                      goto LABEL_178;
                    }
LABEL_180:
                    sub_1ABF0(v24);
                  }
                  else
                  {
                    v73 = v23 == -3;
LABEL_178:
                    if ( v73 )
                      goto LABEL_180;
                  }
                }
              }
              if ( v23 != 110 )
                break;
              sub_1ACEC(v24 + *(_DWORD *)(dword_7DB98 + 84));
            }
            if ( v23 > 110 )
              break;
            if ( v23 > 101 )
            {
              if ( v23 == 103 )
                goto LABEL_200;
            }
            else
            {
              if ( v23 >= 100 )
                goto LABEL_180;
              v75 = v23 == 98;
LABEL_196:
              if ( v75 )
                goto LABEL_198;
            }
          }
          if ( v23 != 119 )
          {
            if ( v23 <= 119 )
            {
              if ( v23 == 112 )
              {
LABEL_207:
                sub_1A388();
                v76 = *(_DWORD *)(dword_7DB98 + 76);
                if ( v76 <= 0 )
                  v76 = *(_DWORD *)(dword_7DB98 + 24);
                v25 = v76 * v24 / 0x64u;
                goto LABEL_200;
              }
              v75 = v23 == 117;
              goto LABEL_196;
            }
            if ( v23 != 121 )
            {
              v73 = v23 == 122;
              goto LABEL_178;
            }
          }
LABEL_198:
          sub_1AC44(v24);
        }
      }
    }
  }
  return sub_57910(v5);
}
// 1B97C: control flows out of bounds to 1B980
// 1B5D0: conditional instruction was optimized away because r0.4==72
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001BC28) --------------------------------------------------------
int __fastcall sub_1BC28(int a1, char **a2)
{
  int v3; // r8
  int (*v4)(const char *, const char *, const void *, size_t, int); // r7
  char v5; // r0
  int v6; // r5
  int (*v7)(const char *, const char *); // r6
  const char **v8; // r4
  int v9; // r0
  const char *v10; // t1
  size_t v12; // r0
  char *name; // [sp+8h] [bp-Ch] BYREF
  char *s; // [sp+Ch] [bp-8h]

  v3 = 0;
  s = "";
  v4 = lsetxattr;
  v5 = sub_593CC(a2, "^hx:n:v:", &name);
  v6 = v5 & 2;
  v7 = lremovexattr;
  v8 = (const char **)&a2[optind];
  if ( (v5 & 1) == 0 )
  {
    v4 = setxattr;
    v7 = removexattr;
  }
  do
  {
    if ( v6 )
    {
      v9 = v7(*v8, name);
    }
    else
    {
      v12 = strlen(s);
      v9 = v4(*v8, name, s, v12, 0);
    }
    if ( v9 )
    {
      v3 = 1;
      sub_16B80(*v8);
    }
    v10 = v8[1];
    ++v8;
  }
  while ( v10 );
  return v3;
}
// 7D604: using guessed type int optind;

//----- (0001BD18) --------------------------------------------------------
int __fastcall sub_1BD18(char *s1, char *s2)
{
  int v4; // r5

  v4 = 0;
  while ( *s1 )
  {
    if ( !strcasecmp(s1, s2) )
      return v4;
    ++v4;
    s1 += strlen(s1) + 1;
  }
  return -1;
}

//----- (0001BD6C) --------------------------------------------------------
int __fastcall sub_1BD6C(char *a1)
{
  return sub_189FC(a1, 0, 0);
}

//----- (0001BD78) --------------------------------------------------------
int __fastcall sub_1BD78(int fd, char a2, int a3)
{
  int v3; // r5
  const char *v8; // r0

  v3 = a2 & 1;
  if ( (a2 & 1) != 0 && (v3 = ioctl(fd, 0x541Fu), v3 < 0) )
  {
    v8 = "can't set serial info";
  }
  else if ( (a2 & 2) != 0 && (v3 = ioctl(fd, 0x5453u), v3 < 0) )
  {
    v8 = "can't autoconfigure port";
  }
  else
  {
    if ( (a2 & 4) == 0 )
      goto LABEL_7;
    v3 = ioctl(fd, 0x541Eu, a3);
    if ( v3 >= 0 )
      goto LABEL_7;
    v8 = "can't get serial info";
  }
  sub_16B80(v8);
  if ( (a2 & 0x10) == 0 )
    exit(1);
LABEL_7:
  if ( (a2 & 8) != 0 )
    close(fd);
  return v3;
}

//----- (0001BE28) --------------------------------------------------------
int __fastcall sub_1BE28(int a1, char **a2)
{
  char v3; // r0
  char v4; // r5
  int *v5; // r7
  const char *v6; // r4
  int v7; // r0
  int v8; // r8
  int v9; // r2
  char *v10; // r4
  int v11; // r0
  char **v12; // r6
  int v13; // r3
  char *v14; // r3
  const char *v15; // r4
  int v16; // r0
  int v17; // t1
  char *v19; // r4
  int v20; // r0
  char *v21; // r4
  int v22; // r0
  char *v23; // r2
  char *v24; // r6
  const char *v25; // r4
  const char *v26; // r1
  unsigned __int16 v27; // r11
  int v28; // r3
  int v29; // r1
  const char *v30; // r3
  const char *v31; // r1
  const char *v32; // r0
  char *v33; // r2
  int i; // r8
  char *v35; // r0
  const char *v36; // r0
  int v37; // [sp+8h] [bp-4Ch]
  const char *v38; // [sp+8h] [bp-4Ch]
  char *v39; // [sp+Ch] [bp-48h]
  int v40[2]; // [sp+14h] [bp-40h] BYREF
  int v41; // [sp+1Ch] [bp-38h]
  int v42; // [sp+20h] [bp-34h]
  int v43; // [sp+24h] [bp-30h]
  int v44; // [sp+2Ch] [bp-28h]
  int v45; // [sp+30h] [bp-24h]
  unsigned __int16 v46; // [sp+34h] [bp-20h]
  unsigned __int16 v47; // [sp+3Ch] [bp-18h]

  v3 = sub_593CC(a2, "^bGavzgq");
  v4 = v3;
  v5 = (int *)&a2[optind];
  if ( !v5[1] )
    v4 = v3 | 0x20;
  if ( (v4 & 0x20) == 0 )
  {
    v6 = a2[optind];
    v7 = sub_586C8((int)v6, 2050);
    v8 = v7;
    if ( v7 < 0 )
    {
      sub_16B80(v6);
      exit(201);
    }
    sub_1BD78(v7, 4, (int)v40);
    v14 = (char *)v5;
    if ( (v4 & 0x10) != 0 )
      v43 = v4 & 0x20;
    while ( 1 )
    {
      v10 = (char *)*((_DWORD *)v14 + 1);
      v12 = (char **)(v14 + 4);
      if ( !v10 )
        break;
      v9 = (unsigned __int8)*v10;
      v39 = v14;
      if ( v9 == 94 )
        ++v10;
      v37 = v9;
      v11 = sub_1BD18("spd_normal", v10);
      if ( v11 < 0 )
        sub_16DBC("invalid flag: %s", v10);
      if ( (unsigned int)(v11 - 16) <= 6 )
      {
        v12 = (char **)(v39 + 8);
        if ( !*((_DWORD *)v39 + 2) )
          sub_16DBC("%s requires an argument", v10);
      }
      if ( v37 != 94 )
      {
        switch ( v11 )
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            v43 &= 0xFFFFEFCF;
            goto LABEL_18;
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
LABEL_18:
            v13 = v43 | word_64294[v11];
            goto LABEL_20;
          case 16:
            v41 = sub_1BD6C(*v12);
            goto LABEL_21;
          case 17:
            v42 = sub_1BD6C(*v12);
            goto LABEL_21;
          case 18:
            v44 = sub_1BD6C(*v12);
            goto LABEL_21;
          case 19:
            v19 = *v12;
            v20 = sub_1BD18("unknown", *v12);
            if ( v20 < 0 )
              sub_16DBC("illegal UART type: %s", v19);
            v40[0] = v20;
            goto LABEL_21;
          case 20:
            v45 = sub_1BD6C(*v12);
            goto LABEL_21;
          case 21:
            v46 = sub_1BD6C(*v12);
            goto LABEL_21;
          case 22:
            v21 = *v12;
            if ( !strcasecmp(*v12, "none") )
            {
              LOWORD(v22) = -1;
            }
            else
            {
              v22 = strcasecmp(v21, "infinite");
              if ( v22 )
                LOWORD(v22) = sub_1BD6C(v21);
            }
            v47 = v22;
            goto LABEL_21;
          case 23:
            sub_1BD78(v8, 7, (int)v40);
            goto LABEL_21;
          default:
            goto LABEL_21;
        }
      }
      if ( (unsigned int)(v11 - 6) > 9 )
        sub_16DBC("can't invert %s", v10);
      v13 = v43 & ~word_64294[v11];
LABEL_20:
      v43 = v13;
LABEL_21:
      v14 = (char *)v12;
    }
    sub_1BD78(v8, 9, (int)v40);
    v5[1] = 0;
  }
  if ( (v4 & 0x28) != 0 )
  {
    while ( 1 )
    {
      v15 = (const char *)*v5;
      v16 = sub_586C8(*v5, 2050);
      if ( (((v4 & 7) != 1) & ((unsigned int)v16 >> 31)) != 0 )
      {
        sub_16B80(v15);
        goto LABEL_27;
      }
      if ( v16 < 0 || sub_1BD78(v16, 28, (int)v40) < 0 )
        goto LABEL_27;
      if ( v40[0] <= 19 )
        v23 = sub_16964("unknown", v40[0]);
      else
        v23 = "undefined";
      switch ( v4 & 7 )
      {
        case 0:
          printf("%s, UART: %s, Port: 0x%.4x, IRQ: %d", v15, v23, v41, v42);
          goto LABEL_50;
        case 1:
          if ( !v40[0] )
            goto LABEL_27;
          v26 = v15;
          v24 = ")";
          v25 = " (";
          printf("%s at 0x%.4x (irq = %d) is a %s", v26, v41, v42, v23);
          goto LABEL_53;
        case 2:
          v31 = v15;
          v24 = "";
          v25 = " ";
          printf("%s uart %s port 0x%.4x irq %d baud_base %d", v31, v23, v41, v42, v45);
          goto LABEL_53;
        case 4:
          printf("%s, Line %d, UART: %s, Port: 0x%.4x, IRQ: %d\n", v15, v40[1], v23, v41, v42);
          printf("\tBaud_base: %d, close_delay: %u, divisor: %d\n", v45, v46, v44);
          printf("\tclosing_wait: ");
          if ( v47 )
          {
            if ( v47 != 0xFFFF )
            {
              printf("%u\n", v47);
              goto LABEL_67;
            }
            v32 = "none";
          }
          else
          {
            v32 = "infinite";
          }
          puts(v32);
LABEL_67:
          v24 = (char *)"\n";
          v25 = "\tFlags: ";
LABEL_53:
          v27 = v43;
          v28 = v43 & 0x1030;
          if ( v28 == 48 )
          {
            v29 = 5;
            goto LABEL_72;
          }
          if ( (v43 & 0x1030u) > 0x30 )
          {
            if ( v28 == 4096 )
            {
              v29 = 3;
              goto LABEL_72;
            }
            if ( v28 == 4112 )
            {
              v29 = 4;
              goto LABEL_72;
            }
          }
          else
          {
            if ( v28 == 16 )
            {
              v29 = 1;
              goto LABEL_72;
            }
            if ( v28 == 32 )
            {
              v29 = 2;
              goto LABEL_72;
            }
          }
          if ( (v4 & 7u) <= 1 )
            goto LABEL_59;
          v29 = 0;
LABEL_72:
          v33 = sub_16964("spd_normal", v29);
          if ( !v33 )
          {
LABEL_59:
            v30 = v25;
            goto LABEL_74;
          }
          printf("%s%s", v25, v33);
          v30 = " ";
LABEL_74:
          for ( i = 6; i != 16; ++i )
          {
            if ( (word_64294[i] & v27) != 0 && ((v4 & 7u) > 1 || (unsigned int)(i - 9) > 5) )
            {
              v38 = v30;
              v35 = sub_16964("spd_normal", i);
              printf("%s%s", v38, v35);
              v30 = " ";
            }
          }
          v36 = "";
          if ( v25 != v30 )
            v36 = v24;
          puts(v36);
LABEL_27:
          v17 = v5[1];
          ++v5;
          if ( !v17 )
            return 0;
          break;
        default:
LABEL_50:
          v24 = "";
          v25 = ", Flags: ";
          goto LABEL_53;
      }
    }
  }
  return 0;
}
// 1BF10: control flows out of bounds to 1BF14
// 1C138: control flows out of bounds to 1C13C
// 64294: using guessed type unsigned __int16 word_64294[15];
// 7D604: using guessed type int optind;

//----- (0001C3E0) --------------------------------------------------------
int __fastcall sub_1C3E0(int a1, char **a2)
{
  char v3; // r0
  signed int v4; // r4
  char v5; // r6
  char *v6; // r7
  int v7; // r7
  const char *v8; // r9
  struct ether_addr *v9; // r0
  __int16 v10; // r1
  int v11; // r3
  char *v12; // r2
  bool v13; // zf
  size_t v14; // r2
  int v15; // r0
  signed int i; // r3
  const char *v18; // [sp+10h] [bp-D8h] BYREF
  char *s; // [sp+14h] [bp-D4h] BYREF
  _BYTE src[8]; // [sp+18h] [bp-D0h] BYREF
  struct ether_addr addr; // [sp+20h] [bp-C8h] BYREF
  _DWORD v22[5]; // [sp+28h] [bp-C0h] BYREF
  char v23[16]; // [sp+3Ch] [bp-ACh] BYREF
  _BYTE v24[6]; // [sp+4Ch] [bp-9Ch]
  __int16 v25; // [sp+52h] [bp-96h]
  int v26; // [sp+5Ch] [bp-8Ch] BYREF
  __int16 v27; // [sp+60h] [bp-88h] BYREF
  int v28; // [sp+62h] [bp-86h] BYREF
  __int16 v29; // [sp+66h] [bp-82h]
  __int16 v30; // [sp+68h] [bp-80h] BYREF
  int v31; // [sp+6Ah] [bp-7Eh] BYREF
  __int16 v32; // [sp+6Eh] [bp-7Ah]
  char v33; // [sp+70h] [bp-78h] BYREF
  _BYTE dest[24]; // [sp+D0h] [bp-18h] BYREF

  v18 = "eth0";
  v3 = sub_593CC(a2, "^bi:p:", &v18, &s);
  v4 = v3 & 4;
  v5 = v3;
  if ( (v3 & 4) != 0 )
  {
    v6 = s;
    v4 = sscanf(s, "%2x:%2x:%2x:%2x:%2x:%2x", &v26, &v27, (char *)&v28 + 2, &v30, (char *)&v31 + 2, &v33);
    if ( v4 > 3 || (v4 = sscanf(v6, "%u.%u.%u.%u", &v26, &v27, (char *)&v28 + 2, &v30), v4 > 3) )
    {
      for ( i = 0; i < v4; ++i )
        src[i] = *(&v26 + i);
    }
    else
    {
      v4 = 0;
      sub_16DDC("can't read Wake-On-LAN pass");
    }
  }
  v7 = sub_179A4(17, 3, 0);
  v8 = a2[optind];
  v9 = ether_aton_r(v8, &addr);
  if ( !v9 )
  {
    v9 = (struct ether_addr *)ether_hostton(v8, &addr);
    if ( v9 )
      sub_162F0();
  }
  v26 = -1;
  v27 = -1;
  if ( (v5 & 1) == 0 )
  {
    v9 = *(struct ether_addr **)addr.ether_addr_octet;
    v10 = *(_WORD *)&addr.ether_addr_octet[4];
  }
  v29 = *(_WORD *)&addr.ether_addr_octet[4];
  if ( (v5 & 1) == 0 )
    v26 = (int)v9;
  v30 = 16904;
  v31 = -1;
  v32 = -1;
  v11 = 0;
  if ( (v5 & 1) == 0 )
    v27 = v10;
  v28 = *(_DWORD *)addr.ether_addr_octet;
  do
  {
    v12 = (char *)&v26 + v11;
    v11 += 6;
    *(struct ether_addr *)(v12 + 20) = addr;
  }
  while ( v11 != 96 );
  sub_16EA8(v23, v18);
  sub_17A4C(v7, 0x8927u, (int)v23, "SIOCGIFHWADDR on %s failed", v18);
  v13 = v4 == 0;
  if ( !v4 )
    v4 = 116;
  v28 = *(_DWORD *)&v24[2];
  v29 = v25;
  if ( !v13 )
  {
    v14 = v4;
    v4 += 116;
    memcpy(dest, src, v14);
  }
  if ( (v5 & 1) != 0 )
  {
    sub_6241C();
    if ( v15 )
      sub_16AF4("SO_BROADCAST");
  }
  sub_16EA8(v23, v18);
  sub_17B18(v7, 0x8933u, (int)v23, "SIOCGIFINDEX");
  memset((char *)v22 + 2, 0, 0x12u);
  LOWORD(v22[0]) = 17;
  v22[3] = v26;
  LOWORD(v22[4]) = v27;
  v22[1] = *(_DWORD *)v24;
  HIBYTE(v22[2]) = 6;
  sub_179DC(v7, &v26, v4, (const struct sockaddr *)v22, 0x14u);
  return 0;
}
// 1C51C: variable 'v10' is possibly undefined
// 1C5B4: variable 'v15' is possibly undefined
// 7D604: using guessed type int optind;

//----- (0001C680) --------------------------------------------------------
int __fastcall sub_1C680(const char *a1, int a2)
{
  _DWORD *v2; // r4
  int result; // r0
  size_t v5; // r0
  const char *v6; // [sp+4h] [bp-4h] BYREF

  v6 = a1;
  if ( a2 )
  {
    v2 = sub_5DDC4((int)a1, (int (*)(void))sub_61CA8);
    while ( 1 )
    {
      result = sub_5DE1C(v2, &v6, 4391169, "# \t");
      if ( !result )
        break;
      sub_1C680(v6, 0);
    }
  }
  else
  {
    v5 = strlen(a1);
    result = sethostname(a1, v5);
    if ( result )
      sub_16B40("sethostname");
  }
  return result;
}

//----- (0001C70C) --------------------------------------------------------
int __fastcall sub_1C70C(int a1, char **a2)
{
  char v3; // r4
  int v4; // r6
  const char *v5; // r0
  struct hostent *v6; // r0
  const char *h_name; // r6
  struct hostent *v8; // r5
  _BYTE *v9; // r0
  struct in_addr **h_addr_list; // r4
  struct in_addr *v12; // r3
  struct in_addr *v13; // t1
  const char *v14; // r5
  char *v15; // r0
  const char *v16; // r7
  int v17; // r1
  const char *v18; // r0
  char **v19; // [sp+4h] [bp-4h] BYREF

  v19 = a2;
  v3 = sub_593CC(a2, "dfisF:v", &v19, "domain", a1);
  v4 = optind;
  v5 = (const char *)sub_60AA0();
  if ( *(_BYTE *)dword_7DB90 == 100 )
    v3 = 1;
  if ( (v3 & 7) == 0 )
  {
    if ( (v3 & 8) == 0 )
    {
      v17 = v3 & 0x10;
      if ( (v3 & 0x10) != 0 )
      {
        v17 = 1;
        v18 = (const char *)v19;
      }
      else
      {
        if ( !a2[v4] )
          goto LABEL_22;
        v18 = a2[v4];
      }
      sub_1C680(v18, v17);
      return 0;
    }
    v16 = v5;
    *(_BYTE *)strchrnul(v5, 46) = 0;
    v5 = v16;
LABEL_22:
    puts(v5);
    return 0;
  }
  v6 = sub_62520(v5);
  h_name = v6->h_name;
  v8 = v6;
  v9 = (_BYTE *)strchrnul(v6->h_name, 46);
  if ( (v3 & 2) != 0 )
  {
    v5 = h_name;
    goto LABEL_22;
  }
  if ( (v3 & 8) != 0 )
  {
    *v9 = 0;
    v5 = v8->h_name;
    goto LABEL_22;
  }
  if ( (v3 & 1) != 0 )
  {
    if ( *v9 )
    {
      v5 = v9 + 1;
      goto LABEL_22;
    }
  }
  else if ( v8->h_length == 4 )
  {
    h_addr_list = (struct in_addr **)v8->h_addr_list;
    while ( 1 )
    {
      v13 = *h_addr_list++;
      v12 = v13;
      if ( !v13 )
        break;
      if ( *h_addr_list )
        v14 = "%s ";
      else
        v14 = "%s";
      v15 = inet_ntoa((struct in_addr)v12->s_addr);
      printf(v14, v15);
    }
    j_putchar_unlocked(10);
  }
  return 0;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7D604: using guessed type int optind;
// 7DB90: using guessed type int dword_7DB90;

//----- (0001C868) --------------------------------------------------------
unsigned int __fastcall sub_1C868(int a1, int a2)
{
  int v2; // r3
  int v3; // r7
  char *v4; // r0
  int v6; // r10
  int v7; // r11
  const char *v8; // r6
  int v9; // r8
  int v10; // r4
  int v11; // r3
  const char *v12; // r1
  char **v13; // r9
  char **v14; // r6
  unsigned int v15; // r4
  const char *v16; // r7
  int v17; // r3
  int *v18; // r3
  int *v19; // lr
  char *v20; // r2
  int v21; // r1
  bool v22; // zf
  char *v23; // r2
  int v24; // r3
  char *v25; // r0
  int v26; // r1
  int v27; // t1
  int v28; // r0
  char v29; // r4
  __int16 v30; // r2
  __int16 v31; // r3
  int v32; // r0
  int v33; // r7
  int v34; // [sp+Ch] [bp-50h]
  int v35; // [sp+10h] [bp-4Ch]
  int v36; // [sp+14h] [bp-48h]
  int v37; // [sp+18h] [bp-44h] BYREF
  int v38; // [sp+1Ch] [bp-40h]
  _WORD v39[8]; // [sp+28h] [bp-34h] BYREF
  char v40[16]; // [sp+38h] [bp-24h] BYREF
  __int16 v41; // [sp+48h] [bp-14h]

  v2 = *(_DWORD *)(a2 + 4);
  v3 = a2 + 4;
  if ( v2 )
  {
    if ( *(_BYTE *)v2 == 45 && *(_BYTE *)(v2 + 1) == 97 && !*(_BYTE *)(v2 + 2) )
    {
      v3 = a2 + 8;
      v2 = 1;
    }
    else
    {
      v2 = 0;
    }
  }
  v4 = *(char **)v3;
  if ( !*(_DWORD *)v3 )
  {
    v4 = (char *)v2;
    return sub_1D6FC(v4);
  }
  if ( !*(_DWORD *)(v3 + 4) )
    return sub_1D6FC(v4);
  v6 = 0;
  v7 = 0;
  v34 = sub_179A4(2, 2, 0);
  sub_16EA8(v40, *(const char **)v3);
  v35 = 0;
  while ( 1 )
  {
    v8 = *(const char **)(v3 + 4);
    v9 = v3 + 4;
    if ( !v8 )
      return 0;
    v10 = 0;
    if ( *v8 == 45 )
    {
      ++v8;
      v11 = 42;
    }
    else
    {
      v11 = 21;
    }
    do
    {
      v12 = (&off_63314)[v10];
      v13 = &(&off_63314)[v10];
      if ( !v12 )
      {
        v14 = &off_6330C;
        v15 = *((unsigned __int16 *)v13 + 2) >> 6;
        goto LABEL_20;
      }
      v36 = v11;
      v28 = strcmp(v8, v12);
      v10 += 2;
      v11 = v36;
    }
    while ( v28 );
    v29 = (_BYTE)v13[1] & v36;
    if ( !v29 )
      sub_16DBC("bad: '%s'", v8 - 1);
    if ( ((_BYTE)v13[1] & (unsigned __int8)v36 & 0x30) == 0 )
      goto LABEL_57;
    v15 = *((unsigned __int16 *)v13 + 2) >> 6;
    if ( (v7 & 0x20 & (unsigned __int8)v15) != 0 )
      goto LABEL_51;
    v14 = (char **)((char *)&off_632CC + (char *)v13 - (char *)&off_63314);
    if ( !*(_DWORD *)(v3 + 8) )
    {
      if ( (v15 & 0x10) == 0 )
      {
        LOBYTE(v15) = v15 & 0x40;
        goto LABEL_55;
      }
LABEL_51:
      sub_162F0();
    }
    v9 = v3 + 8;
LABEL_20:
    v16 = *(const char **)v9;
    v7 |= v15 & 0x120;
    if ( (v15 & 2) != 0 )
    {
      if ( (v15 & 1) != 0 )
      {
        if ( !strcmp(*(const char **)v9, "inet") )
          goto LABEL_45;
        v37 = 2;
        if ( !strcmp(v16, "default") )
        {
          v38 = 0;
        }
        else
        {
          if ( *v16 == 43 && !v16[1] && ((v7 == 288) & (v15 >> 9)) != 0 )
            v17 = ~v6 | v35;
          else
            v17 = *((_DWORD *)sub_62484(v16, 0) + 2);
          v38 = v17;
        }
        if ( (v15 & 0x100) != 0 )
          v35 = v38;
        if ( (v15 & 0x20) != 0 )
          v6 = v38;
        v18 = &v37;
      }
      else
      {
        v32 = sub_168D4("ether", *(char **)v9) + 1;
        if ( !v32 )
          goto LABEL_51;
        v33 = *(_DWORD *)(v9 + 4);
        if ( !v33 )
          goto LABEL_51;
        if ( v32 != 1 || sub_5A454(*(unsigned __int8 **)(v9 + 4), v39) )
          sub_16DBC("invalid hw-addr %s", v33);
        v9 += 4;
        v18 = (int *)v39;
      }
      v19 = v18 + 4;
      v20 = &v40[*((unsigned __int16 *)v14 + 3)];
      do
      {
        v20 += 8;
        v21 = v18[1];
        v22 = v18 + 2 == v19;
        *((_DWORD *)v20 - 2) = *v18;
        *((_DWORD *)v20 - 1) = v21;
        v18 += 2;
      }
      while ( !v22 );
    }
    else
    {
      *(_DWORD *)&v40[*((unsigned __int16 *)v14 + 3)] = strtoul(*(const char **)v9, 0, 0);
    }
    sub_17A4C(v34, *((unsigned __int16 *)v14 + 2), (int)v40, "SIOC%s", *v14);
    if ( (v15 & 0x80) == 0 )
      goto LABEL_55;
    v23 = v40;
    v24 = 0;
    while ( 1 )
    {
      v25 = v23;
      v27 = (unsigned __int8)*v23++;
      v26 = v27;
      if ( !v27 )
        break;
      if ( v26 == 58 )
        v24 = (__int16)(v24 + 1);
    }
    if ( !v24 || *(v25 - 1) != 45 )
    {
LABEL_55:
      if ( (v15 & 0x40) == 0 )
        goto LABEL_45;
      v29 = 4;
LABEL_57:
      sub_17B18(v34, 0x8913u, (int)v40, "SIOCGIFFLAGS");
      v30 = *((_WORD *)v13 + 3);
      if ( (v29 & 0xC) != 0 )
        v31 = v41 | v30;
      else
        v31 = v41 & ~v30;
      v41 = v31;
      sub_17B18(v34, 0x8914u, (int)v40, "SIOCSIFFLAGS");
    }
LABEL_45:
    v3 = v9;
  }
}
// 632CC: using guessed type char *off_632CC;
// 6330C: using guessed type char *off_6330C;
// 63314: using guessed type char *off_63314;

//----- (0001CC24) --------------------------------------------------------
int __fastcall sub_1CC24(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r4
  unsigned __int8 *v2; // r7
  void *v3; // r0
  int v4; // r5
  char *v5; // r6
  int v6; // t1
  char *v7; // r0

  v1 = a1;
  v2 = a1 + 16;
  v3 = sub_1748C(0x31u);
  v4 = sub_57710((int)v3);
  v5 = (char *)v4;
  do
  {
    v6 = *v1++;
    v7 = v5;
    v5 += 3;
    sprintf(v7, "%02X-", v6);
  }
  while ( v2 != v1 );
  *(_BYTE *)(v4 + 47) = 0;
  return v4;
}

//----- (0001CCA4) --------------------------------------------------------
int __fastcall sub_1CCA4(const char *a1, struct in_addr *a2)
{
  return sub_5A53C(a1, a2);
}

//----- (0001CCAC) --------------------------------------------------------
const char *__fastcall sub_1CCAC(_WORD *a1, unsigned int a2)
{
  char *v2; // r0

  if ( (unsigned __int16)(*a1 - 1) > 0xFFFDu )
    return "[NONE SET]";
  v2 = sub_5A5B0((int)a1, a2, -256);
  return (const char *)sub_57710((int)v2);
}

//----- (0001CCE4) --------------------------------------------------------
int __fastcall sub_1CCE4(unsigned __int8 *a1)
{
  char *v1; // r0

  v1 = sub_177E4("%02X:%02X:%02X:%02X:%02X:%02X", *a1, a1[1], a1[2], a1[3], a1[4], a1[5]);
  return sub_57710((int)v1);
}

//----- (0001CD24) --------------------------------------------------------
char *__fastcall sub_1CD24(int *a1, char *s2)
{
  char *i; // r4
  char *v5; // r5
  int *v6; // r2
  int v7; // r3
  bool v8; // zf
  int v10; // r0

  for ( i = (char *)a1[1]; i; i = (char *)*((_DWORD *)i + 1) )
  {
    v10 = strcmp(i + 8, s2);
    if ( !v10 )
      return i;
    if ( v10 < 0 )
      break;
  }
  v5 = (char *)sub_174DC(0x110u);
  sub_16EA8(v5 + 8, s2);
  *((_DWORD *)v5 + 1) = i;
  if ( i )
    v6 = (int *)i;
  else
    v6 = a1;
  v7 = *v6;
  i = v5;
  v8 = *v6 == 0;
  *(_DWORD *)v5 = *v6;
  if ( v8 )
    a1[1] = (int)v5;
  else
    *(_DWORD *)(v7 + 4) = v5;
  *v6 = (int)v5;
  return i;
}

//----- (0001CDA8) --------------------------------------------------------
int __fastcall sub_1CDA8(int *a1, const char *a2)
{
  int v4; // r0
  FILE *v5; // r6
  int v6; // r4
  int v7; // r7
  unsigned __int8 *v8; // r0
  char *v9; // r5
  size_t v10; // r4
  int v11; // t1
  char *v12; // r4
  void *v13; // r0
  char dest[16]; // [sp+38h] [bp-214h] BYREF
  char haystack[512]; // [sp+48h] [bp-204h] BYREF

  v4 = sub_61C78("/proc/net/dev", (int)"r");
  v5 = (FILE *)v4;
  if ( !v4 )
    return 0;
  fgets_unlocked(haystack, 512, v4);
  fgets_unlocked(haystack, 512, v5);
  if ( strstr(haystack, "compressed") )
    v7 = 2;
  else
    v7 = strstr(haystack, "bytes") != 0;
  while ( 1 )
  {
    v6 = fgets_unlocked(haystack, 512, v5);
    if ( !v6 )
      break;
    v8 = sub_60E74((unsigned __int8 *)haystack);
    v9 = (char *)v8;
    do
    {
      v10 = v9 - (char *)v8;
      if ( v9 - (char *)v8 > 15 )
        break;
      v11 = (unsigned __int8)*v9++;
      if ( v11 == 58 )
      {
        memcpy(dest, v8, v10);
        dest[v10] = 0;
        goto LABEL_11;
      }
    }
    while ( (unsigned __int8)*v9 > 0x20u );
    v9 = haystack;
    dest[0] = 0;
LABEL_11:
    v12 = sub_1CD24(a1, dest);
    v13 = memset(v12 + 160, 0, 0x70u);
    sscanf(
      v9,
      off_63468[v7],
      v12 + 176,
      v13,
      v12 + 192,
      v12 + 200,
      v12 + 240,
      v12 + 236,
      v12 + 212,
      v12 + 208,
      v12 + 184,
      v12 + 168,
      v12 + 196,
      v12 + 204,
      v12 + 256,
      v12 + 220,
      v12 + 252,
      v12 + 216);
    if ( v7 != 2 )
    {
      if ( !v7 )
      {
        *((_QWORD *)v12 + 22) = 0;
        *((_QWORD *)v12 + 23) = 0;
      }
      *((_DWORD *)v12 + 52) = 0;
      *((_DWORD *)v12 + 53) = 0;
      *((_DWORD *)v12 + 54) = 0;
    }
    *((_DWORD *)v12 + 39) = 1;
    if ( a2 && !strcmp(a2, dest) )
    {
      v6 = 1;
      break;
    }
  }
  fclose(v5);
  return v6;
}
// 14048: using guessed type int __fastcall fgets_unlocked(_DWORD, _DWORD, _DWORD);
// 63468: using guessed type char *off_63468[5];

//----- (0001CFBC) --------------------------------------------------------
int __fastcall sub_1CFBC(unsigned __int64 a1, __int64 a2)
{
  const char *v2; // lr
  unsigned __int64 v3; // r4
  int v4; // r8
  unsigned int v5; // r12
  unsigned int v6; // r12
  const char *v8; // [sp+10h] [bp-8h]

  HIDWORD(a2) = HIDWORD(a1);
  v2 = (const char *)&unk_65759;
  v3 = a1;
  v4 = 4;
  v5 = 0;
  do
  {
    if ( v3 > 0x3FF )
    {
      v6 = 10 * (v3 & 0x3FF);
      v2 += 3;
      v3 >>= 10;
      v5 = v6 >> 10;
    }
    --v4;
  }
  while ( v4 );
  v8 = (const char *)a2;
  LODWORD(a2) = a1;
  return printf("X bytes:%llu (%llu.%u %sB)%s", a2, v3, v5, v2, v8);
}

//----- (0001D04C) --------------------------------------------------------
int __fastcall sub_1D04C(int a1)
{
  _DWORD *v1; // r2
  int v2; // r3
  int v3; // t1

  v1 = &unk_633C4;
  do
  {
    v3 = v1[1];
    ++v1;
    v2 = v3;
  }
  while ( v3 && *(_DWORD *)(v2 + 8) != a1 );
  return v2;
}

//----- (0001D074) --------------------------------------------------------
int __fastcall sub_1D074(int a1, int a2)
{
  const char *v3; // r6
  int v5; // r7
  char *v6; // r2
  int result; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r3
  _DWORD *v23; // r3
  _DWORD *v24; // r2
  int v25; // r5
  int v26; // t1
  int v27; // t1
  int v28; // r0
  unsigned int v29; // r8
  int v30; // r7
  int (*v31)(void); // r2
  unsigned __int8 *v32; // r3
  const char *v33; // r6
  const char *v34; // r0
  const char *v35; // r0
  const char *v36; // r0
  const char *v37; // r0
  int v38; // r2
  int v39; // r1
  __int64 v40; // r2
  __int64 v41; // r2
  unsigned int v42; // r1
  int v43; // r1
  const char *v45; // r0
  unsigned __int16 *v46; // r6
  const char *v47; // r5
  int v48; // t1
  size_t v49; // r0
  int v50; // t1
  char v51[16]; // [sp+10h] [bp-20h] BYREF
  _DWORD v52[3]; // [sp+20h] [bp-10h]
  int v53; // [sp+2Ch] [bp-4h]

  v3 = (const char *)(a1 + 8);
  v5 = sub_179A4(2, 2, 0);
  sub_16EA8(v51, v3);
  if ( ioctl(v5, 0x8913u, v51) >= 0 )
  {
    *(_WORD *)(a1 + 26) = v52[0];
    *(_DWORD *)(a1 + 28) = -1;
    memset((void *)(a1 + 32), 0, 0x78u);
    sub_16EA8(v51, v3);
    if ( ioctl(v5, 0x8927u, v51) >= 0 )
    {
      *(_DWORD *)(a1 + 120) = *(_DWORD *)((char *)v52 + 2);
      *(_DWORD *)(a1 + 124) = *(_DWORD *)((char *)&v52[1] + 2);
    }
    *(_WORD *)(a1 + 24) = v52[0];
    sub_16EA8(v51, v3);
    if ( ioctl(v5, 0x891Du, v51) >= 0 )
      *(_DWORD *)(a1 + 32) = v52[0];
    sub_16EA8(v51, v3);
    if ( ioctl(v5, 0x8921u, v51) >= 0 )
      *(_DWORD *)(a1 + 36) = v52[0];
    sub_16EA8(v51, v3);
    if ( !ioctl(v5, 0x8970u, v51) )
    {
      v8 = v52[1];
      v9 = v52[2];
      v10 = v53;
      *(_DWORD *)(a1 + 40) = v52[0];
      *(_DWORD *)(a1 + 44) = v8;
      *(_DWORD *)(a1 + 48) = v9;
      *(_DWORD *)(a1 + 52) = v10;
    }
    sub_16EA8(v51, v3);
    if ( ioctl(v5, 0x8942u, v51) >= 0 )
      *(_DWORD *)(a1 + 28) = v52[0];
    sub_16EA8(v51, v3);
    LOWORD(v52[0]) = 2;
    if ( !ioctl(v5, 0x8915u, v51) )
    {
      *(_DWORD *)(a1 + 152) = 1;
      v11 = v52[1];
      v12 = v52[2];
      v13 = v53;
      *(_DWORD *)(a1 + 56) = v52[0];
      *(_DWORD *)(a1 + 60) = v11;
      *(_DWORD *)(a1 + 64) = v12;
      *(_DWORD *)(a1 + 68) = v13;
      sub_16EA8(v51, v3);
      if ( ioctl(v5, 0x8917u, v51) >= 0 )
      {
        v14 = v52[1];
        v15 = v52[2];
        v16 = v53;
        *(_DWORD *)(a1 + 72) = v52[0];
        *(_DWORD *)(a1 + 76) = v14;
        *(_DWORD *)(a1 + 80) = v15;
        *(_DWORD *)(a1 + 84) = v16;
      }
      sub_16EA8(v51, v3);
      if ( ioctl(v5, 0x8919u, v51) >= 0 )
      {
        v17 = v52[1];
        v18 = v52[2];
        v19 = v53;
        *(_DWORD *)(a1 + 88) = v52[0];
        *(_DWORD *)(a1 + 92) = v17;
        *(_DWORD *)(a1 + 96) = v18;
        *(_DWORD *)(a1 + 100) = v19;
      }
      sub_16EA8(v51, v3);
      if ( ioctl(v5, 0x891Bu, v51) >= 0 )
      {
        v20 = v52[1];
        v21 = v52[2];
        v22 = v53;
        *(_DWORD *)(a1 + 104) = v52[0];
        *(_DWORD *)(a1 + 108) = v20;
        *(_DWORD *)(a1 + 112) = v21;
        *(_DWORD *)(a1 + 116) = v22;
      }
    }
    close(v5);
    result = *(_WORD *)(a1 + 26) & 1 | a2;
    if ( result )
    {
      v23 = &unk_63398;
      v24 = &unk_63398;
      while ( 1 )
      {
        v26 = v24[1];
        ++v24;
        v25 = v26;
        if ( !v26 )
          break;
        if ( *(unsigned __int16 *)(a1 + 56) == *(_DWORD *)(v25 + 8) )
          goto LABEL_30;
      }
      do
      {
        v27 = v23[1];
        ++v23;
        v25 = v27;
      }
      while ( v27 && *(_DWORD *)(v25 + 8) );
LABEL_30:
      v28 = *(__int16 *)(a1 + 24);
      v29 = v28 & 0xFFFFFFFD;
      v30 = sub_1D04C(v28);
      if ( !v30 )
        v30 = sub_1D04C(-1);
      printf("%-9s Link encap:%s  ", v3, *(const char **)(v30 + 4));
      v31 = *(int (**)(void))(v30 + 16);
      if ( v31 )
      {
        v32 = (unsigned __int8 *)(a1 + 120);
        while ( *(_DWORD *)(v30 + 12) > (int)&v32[-a1 - 120] )
        {
          if ( *v32++ )
            goto LABEL_71;
        }
        if ( *(_DWORD *)(v30 + 28) )
          goto LABEL_34;
LABEL_71:
        v45 = (const char *)v31();
        printf("HWaddr %s  ", v45);
      }
LABEL_34:
      if ( (*(_WORD *)(a1 + 26) & 0x2000) != 0 )
      {
        printf("Media:%s", off_633DC[*(unsigned __int8 *)(a1 + 52)]);
        if ( (*(_WORD *)(a1 + 26) & 0x4000) != 0 )
          printf("(auto)");
      }
      j_putchar_unlocked(10);
      if ( *(_DWORD *)(a1 + 152) )
      {
        v33 = *(const char **)v25;
        v34 = (const char *)(*(int (__fastcall **)(int, int))(v25 + 20))(a1 + 56, 1);
        printf("          %s addr:%s ", v33, v34);
        if ( (*(_WORD *)(a1 + 26) & 0x10) != 0 )
        {
          v35 = (const char *)(*(int (__fastcall **)(int, int))(v25 + 20))(a1 + 72, 1);
          printf(" P-t-P:%s ", v35);
        }
        if ( (*(_WORD *)(a1 + 26) & 2) != 0 )
        {
          v36 = (const char *)(*(int (__fastcall **)(int, int))(v25 + 20))(a1 + 88, 1);
          printf(" Bcast:%s ", v36);
        }
        v37 = (const char *)(*(int (__fastcall **)(int, int))(v25 + 20))(a1 + 104, 1);
        printf(" Mask:%s\n", v37);
      }
      printf("          ");
      if ( *(_WORD *)(a1 + 26) )
      {
        v46 = (unsigned __int16 *)&unk_642B2;
        v47 = "UP";
        do
        {
          v48 = v46[1];
          ++v46;
          if ( (*(__int16 *)(a1 + 26) & v48) != 0 )
            printf("%s ", v47);
          v49 = strlen(v47) + 1;
          v50 = (unsigned __int8)v47[v49];
          v47 += v49;
        }
        while ( v50 );
      }
      else
      {
        printf("[NO FLAGS] ");
      }
      v38 = *(_DWORD *)(a1 + 32);
      if ( !v38 )
        v38 = 1;
      printf(" MTU:%d  Metric:%d", *(_DWORD *)(a1 + 36), v38);
      j_putchar_unlocked(10);
      if ( *(_DWORD *)(a1 + 156) )
      {
        printf("          ");
        printf(
          "RX packets:%llu errors:%lu dropped:%lu overruns:%lu frame:%lu\n",
          *(_QWORD *)(a1 + 160),
          *(_DWORD *)(a1 + 192),
          *(_DWORD *)(a1 + 200),
          *(_DWORD *)(a1 + 240),
          *(_DWORD *)(a1 + 236));
        if ( v29 == 257 )
          printf("             compressed:%lu\n", *(_DWORD *)(a1 + 212));
        printf("          ");
        printf(
          "TX packets:%llu errors:%lu dropped:%lu overruns:%lu carrier:%lu\n",
          *(_QWORD *)(a1 + 168),
          *(_DWORD *)(a1 + 196),
          *(_DWORD *)(a1 + 204),
          *(_DWORD *)(a1 + 256),
          *(_DWORD *)(a1 + 252));
        printf("          collisions:%lu ", *(_DWORD *)(a1 + 220));
        if ( v29 == 257 )
          printf("compressed:%lu ", *(_DWORD *)(a1 + 216));
        v39 = *(_DWORD *)(a1 + 28);
        if ( v39 != -1 )
          printf("txqueuelen:%d ", v39);
        printf("\n          R");
        LODWORD(v40) = "  T";
        sub_1CFBC(*(_QWORD *)(a1 + 176), v40);
        LODWORD(v41) = "\n";
        sub_1CFBC(*(_QWORD *)(a1 + 184), v41);
      }
      if ( *(_BYTE *)(a1 + 50) || *(_DWORD *)(a1 + 40) || (*(_DWORD *)(a1 + 48) & 0xFF00FFFF) != 0 )
      {
        printf("          ");
        if ( *(_BYTE *)(a1 + 50) )
          printf("Interrupt:%d ", *(unsigned __int8 *)(a1 + 50));
        v42 = *(unsigned __int16 *)(a1 + 48);
        if ( v42 > 0xFF )
          printf("Base address:0x%lx ", v42);
        v43 = *(_DWORD *)(a1 + 40);
        if ( v43 )
          printf("Memory:%lx-%lx ", v43, *(_DWORD *)(a1 + 44));
        if ( *(_BYTE *)(a1 + 51) )
          printf("DMA chan:%x ", *(unsigned __int8 *)(a1 + 51));
        j_putchar_unlocked(10);
      }
      j_putchar_unlocked(10);
      return 0;
    }
  }
  else
  {
    close(v5);
    if ( *(_DWORD *)dword_7DB94 == 19 )
      v6 = "Device not found";
    else
      v6 = strerror(*(_DWORD *)dword_7DB94);
    sub_16DDC("%s: error fetching interface information: %s", v3, v6);
    return -1;
  }
  return result;
}
// 1D558: variable 'v40' is possibly undefined
// 1D564: variable 'v41' is possibly undefined
// 633DC: using guessed type char *off_633DC[7];
// 7DB94: using guessed type int dword_7DB94;

//----- (0001D6FC) --------------------------------------------------------
unsigned int __fastcall sub_1D6FC(char *a1)
{
  const char *v1; // r1
  int v3; // r4
  size_t v4; // r6
  int v5; // r8
  bool v6; // zf
  char *v7; // r6
  _DWORD *i; // r4
  char *v9; // r0
  int v10; // r0
  int v12[2]; // [sp+0h] [bp-14h] BYREF
  signed int v13; // [sp+8h] [bp-Ch] BYREF
  void *ptr; // [sp+Ch] [bp-8h]

  if ( a1 == (char *)1 )
    v1 = 0;
  else
    v1 = a1;
  v12[0] = 0;
  v12[1] = 0;
  v3 = sub_1CDA8(v12, v1);
  if ( !v3 )
  {
    ptr = 0;
    v4 = 960;
    v5 = sub_179A4(2, 2, 0);
    do
    {
      v13 = v4;
      ptr = sub_174B4(ptr, v4);
      sub_17B18(v5, 0x8912u, (int)&v13, "SIOCGIFCONF");
      v6 = v4 == v13;
      v4 += 320;
    }
    while ( v6 );
    v7 = (char *)ptr;
    while ( v3 < v13 )
    {
      sub_1CD24(v12, &v7[v3]);
      v3 += 32;
    }
    close(v5);
    free(ptr);
  }
  if ( (unsigned int)a1 > 1 )
  {
    v9 = sub_1CD24(v12, a1);
    v10 = sub_1D074((int)v9, 1);
    return (unsigned int)v10 >> 31;
  }
  else
  {
    for ( i = (_DWORD *)v12[0]; i; i = (_DWORD *)*i )
    {
      v10 = sub_1D074((int)i, (int)a1);
      if ( v10 < 0 )
        return (unsigned int)v10 >> 31;
    }
    return 0;
  }
}

//----- (0001D814) --------------------------------------------------------
void __noreturn sub_1D814()
{
  sub_162F0();
}

//----- (0001D81C) --------------------------------------------------------
int __fastcall sub_1D81C(int a1, int a2)
{
  char **v2; // r0

  v2 = sub_1F300((_BYTE **)(a2 + 4));
  return sub_20798(v2);
}

//----- (0001D830) --------------------------------------------------------
int __fastcall sub_1D830(int a1, int a2)
{
  char **v2; // r0

  v2 = sub_1F300((_BYTE **)(a2 + 4));
  return sub_20E98(v2);
}

//----- (0001D844) --------------------------------------------------------
int __fastcall sub_1D844(int a1, int a2)
{
  char **v2; // r0

  v2 = sub_1F300((_BYTE **)(a2 + 4));
  return sub_229FC(v2);
}

//----- (0001D858) --------------------------------------------------------
int __fastcall sub_1D858(int a1, int a2)
{
  char **v2; // r4
  char *v3; // r1
  int v4; // r0

  v2 = sub_1F300((_BYTE **)(a2 + 4));
  v3 = *v2;
  if ( *v2 )
  {
    ++v2;
    v4 = sub_168D4("address", v3);
  }
  else
  {
    v4 = -1;
  }
  return ((int (__fastcall *)(char **))*(&off_634C0 + v4 + 1))(v2);
}
// 634C0: using guessed type void (__noreturn *off_634C0)();

//----- (0001D8A4) --------------------------------------------------------
int __fastcall sub_1D8A4(const char *a1)
{
  const char *v1; // r9
  int v4; // r8
  bool v5; // zf
  char **v6; // r1
  const char *v7; // r6
  int v8; // r7
  int v9; // r10
  const char *v10; // r4
  unsigned int v11; // r4
  int v12; // r1
  _DWORD *i; // r1
  const char *v14; // r1
  const char *v15; // r0
  int v16; // r5
  __int16 v17; // r4
  int v18; // t1
  int v19; // [sp+1Ch] [bp-5Ch] BYREF
  char **v20; // [sp+20h] [bp-58h] BYREF
  int v21; // [sp+24h] [bp-54h] BYREF
  unsigned int v22; // [sp+28h] [bp-50h] BYREF
  int v23; // [sp+2Ch] [bp-4Ch] BYREF
  int v24; // [sp+30h] [bp-48h] BYREF
  int v25; // [sp+34h] [bp-44h] BYREF
  char dest[52]; // [sp+38h] [bp-40h] BYREF
  const char *v27; // [sp+6Ch] [bp-Ch]

  if ( !*a1 )
    return 0;
  v27 = v1;
  v25 = 0;
  if ( sscanf(a1, "%*p: %lX %lX %lX %X %X %lu %n", &v19, &v20, &v21, &v23, &v24, &v22, &v25) <= 5 )
    return 1;
  v4 = dword_7DB98;
  if ( (*(_DWORD *)dword_7DB98 & 3) == 3
    || (v24 != 1 || (v21 & 0x10000) == 0
      ? (v5 = (*(_DWORD *)dword_7DB98 & 1) == 0)
      : (v5 = (*(_DWORD *)dword_7DB98 & 2) == 0),
        !v5) )
  {
    v6 = v20;
    v7 = "unix";
    v8 = v21;
    if ( v20 )
      v7 = "??";
    v9 = v21 & 0x10000;
    if ( (unsigned int)(v23 - 1) > 4 )
      v1 = "UNKNOWN";
    else
      v6 = off_634D4;
    if ( (unsigned int)(v23 - 1) <= 4 )
      v1 = v6[v23 - 1];
    switch ( v24 )
    {
      case 0:
        v10 = "FREE";
        break;
      case 1:
        v10 = "LISTENING";
        if ( !v9 )
          v10 = "";
        break;
      case 2:
        v10 = "CONNECTING";
        break;
      case 3:
        v10 = "CONNECTED";
        break;
      case 4:
        v10 = "DISCONNECTING";
        break;
      default:
        v10 = "UNKNOWN";
        break;
    }
    strcpy(dest, "[ ");
    if ( v9 )
      strcat(dest, "ACC ");
    if ( (v8 & 0x20000) != 0 )
      strcat(dest, "W ");
    if ( (v8 & 0x40000) != 0 )
      strcat(dest, "N ");
    strcat(dest, "]");
    printf("%-5s %-6lu %-11s %-10s %-13s %6lu ", v7, v19, dest, v1, v10, v22);
    if ( (dword_7DBC0 & 0x200) != 0 )
    {
      v11 = v22;
      sub_15EFC(v22, 0xD3u);
      for ( i = *(_DWORD **)(v4 + 4 * (v12 + 2)); ; i = (_DWORD *)*i )
      {
        if ( !i )
        {
          v14 = "-";
          goto LABEL_39;
        }
        if ( v11 == i[1] )
          break;
      }
      v14 = (const char *)(i + 2);
LABEL_39:
      printf("%-20s", v14);
    }
    v15 = &a1[v25];
    v16 = (int)&a1[v25 - 1];
    sub_57D48(v15);
    while ( 1 )
    {
      v18 = *(unsigned __int8 *)++v16;
      v17 = v18;
      if ( !v18 )
        break;
      sub_5E4E0(v17, (FILE *)stdout);
    }
    j_putchar_unlocked(10);
  }
  return 0;
}
// 1D984: control flows out of bounds to 1D988
// 1D8B8: variable 'v1' is possibly undefined
// 1DA40: variable 'v12' is possibly undefined
// 634D4: using guessed type char *off_634D4[5];
// 7D614: using guessed type int stdout;
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001DB4C) --------------------------------------------------------
char *__fastcall sub_1DB4C(const struct sockaddr *a1, unsigned int a2, const char *a3, int a4)
{
  char *v8; // r4
  int v9; // r0
  const char *s_name; // r2
  struct servent *v11; // r0
  char *v12; // r5

  if ( a4 || (v8 = sub_62494(a1)) == 0 )
    v8 = sub_6249C(a1);
  v9 = (unsigned __int16)__rev16(a2);
  if ( (_WORD)v9 )
  {
    if ( a4 || (v11 = getservbyport(v9, a3)) == 0 )
      s_name = sub_16F8C((unsigned __int16)a2);
    else
      s_name = v11->s_name;
  }
  else
  {
    s_name = "*";
  }
  v12 = sub_177E4("%s:%s", v8, s_name);
  free(v8);
  return v12;
}

//----- (0001DBE4) --------------------------------------------------------
int __fastcall sub_1DBE4(const char *a1, int a2, int a3, int a4)
{
  const char *v4; // r6
  int v5; // r5
  ssize_t v6; // r0
  char *v8; // r0
  char *v9; // r5
  int v10; // r4
  char s[32]; // [sp+8h] [bp-230h] BYREF
  char v12[528]; // [sp+28h] [bp-210h] BYREF

  if ( !a4 )
    return 1;
  v4 = a1 + 6;
  if ( (unsigned int)*((unsigned __int8 *)a1 + 6) - 48 > 9 )
    return 2;
  v5 = snprintf(s, 0x1Du, "%s/cmdline", a1);
  v6 = sub_180C8((int)s, v12, 0x1FFu);
  if ( v6 < 0 )
    return 0;
  v12[v6] = 0;
  strcpy(&s[v5 - 7], "fd");
  v8 = sub_169FC(v12);
  v9 = sub_16998(v4, v8);
  v10 = sub_60474(s, 33, (int (*)())sub_1DCCC, 0, (int)v9, 0);
  free(v9);
  if ( v10 )
    return 2;
  else
    return 0;
}

//----- (0001DCCC) --------------------------------------------------------
int __fastcall sub_1DCCC(const char *a1, unsigned __int8 *a2, const char *a3)
{
  unsigned __int8 *v4; // r0
  unsigned __int8 *v5; // r4
  signed int v6; // r5
  bool v7; // zf
  int v8; // r4
  int v9; // r1
  int i; // r4
  void *v11; // r0
  char *v13; // [sp+4h] [bp-4h] BYREF

  v13 = (char *)a2;
  v4 = (unsigned __int8 *)sub_17B80(a1);
  v5 = v4;
  if ( !v4 )
    return 1;
  v13 = (char *)v4;
  if ( sub_1684C(v4, (int)"socket:[") )
  {
    v6 = sub_18990(v13 + 8, (char *)&v13, 0);
    v7 = *v13 == 93;
    goto LABEL_4;
  }
  if ( sub_1684C((unsigned __int8 *)v13, (int)"[0000]:") )
  {
    v6 = sub_18990(v13 + 7, 0, 0);
    v7 = *(_DWORD *)dword_7DB94 == 0;
LABEL_4:
    if ( v7 )
      goto LABEL_6;
  }
  v6 = -1;
LABEL_6:
  free(v5);
  if ( v6 >= 0 )
  {
    v8 = dword_7DB98;
    *(_DWORD *)(dword_7DB98 + 4) = 2;
    sub_15EFC(v6, 0xD3u);
    for ( i = v8 + 8 + 4 * v9; *(_DWORD *)i; i = *(_DWORD *)i )
    {
      if ( v6 == *(_DWORD *)(*(_DWORD *)i + 4) )
        return 1;
    }
    v11 = sub_174DC(0x1Cu);
    *(_DWORD *)i = v11;
    *((_DWORD *)v11 + 1) = v6;
    sub_60B34((char *)v11 + 8, a3, 20);
  }
  return 1;
}
// 1DD50: variable 'v9' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;

//----- (0001DDF0) --------------------------------------------------------
int __fastcall sub_1DDF0(const char *a1, int (*a2)(void))
{
  int result; // r0
  signed int v5; // r2
  FILE *v6; // r5
  int v7; // r4
  char *v8; // r6

  result = sub_61CD8((int)a1);
  v6 = (FILE *)result;
  if ( result )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = sub_589FC(v6, (char *)"\n", v5);
      if ( !v8 )
        break;
      if ( ++v7 != 1 )
      {
        if ( a2() )
          sub_16DDC("%s: bogus data on line %d", a1, v7);
      }
      free(v8);
    }
    return fclose(v6);
  }
  return result;
}
// 1DE1C: variable 'v5' is possibly undefined

//----- (0001DE70) --------------------------------------------------------
int __fastcall sub_1DE70(int a1, char *s)
{
  char sa[36]; // [sp+20h] [bp-48h] BYREF
  char v5[36]; // [sp+44h] [bp-24h] BYREF

  if ( sscanf(
         s,
         "%*d: %32[0-9A-Fa-f]:%X %32[0-9A-Fa-f]:%X %X %lX:%lX %*X:%*X %*X %d %*d %lu ",
         sa,
         a1,
         v5,
         a1 + 4,
         a1 + 8,
         a1 + 52,
         a1 + 48,
         a1 + 12,
         a1 + 56) <= 8 )
    return 1;
  if ( strlen(sa) <= 8 )
  {
    sscanf(sa, "%X", a1 + 20);
    *(_WORD *)(a1 + 16) = 2;
    sscanf(v5, "%X", a1 + 36);
    *(_WORD *)(a1 + 32) = 2;
  }
  return 0;
}

//----- (0001DF24) --------------------------------------------------------
void __fastcall sub_1DF24(int a1, const char *a2, const char *a3, int a4)
{
  _DWORD *v4; // r6
  bool v5; // zf
  char *v10; // r9
  char *v11; // r8
  unsigned int v12; // r4
  int v13; // r1
  _DWORD *i; // r1
  const char *v15; // r1

  v4 = (_DWORD *)dword_7DB98;
  if ( a4 )
    v5 = (*(_DWORD *)dword_7DB98 & 1) == 0;
  else
    v5 = (*(_DWORD *)dword_7DB98 & 2) == 0;
  if ( !v5 )
  {
    v10 = sub_1DB4C((const struct sockaddr *)(a1 + 16), *(_DWORD *)a1, a3, *(_DWORD *)dword_7DB98 & 4);
    v11 = sub_1DB4C((const struct sockaddr *)(a1 + 32), *(_DWORD *)(a1 + 4), a3, *v4 & 4);
    printf("%s   %6lu %6lu %-23s %-23s %-12s", a3, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), v10, v11, a2);
    if ( (dword_7DBC0 & 0x200) != 0 )
    {
      v12 = *(_DWORD *)(a1 + 56);
      sub_15EFC(v12, 0xD3u);
      for ( i = (_DWORD *)v4[v13 + 2]; ; i = (_DWORD *)*i )
      {
        if ( !i )
        {
          v15 = "-";
          goto LABEL_11;
        }
        if ( v12 == i[1] )
          break;
      }
      v15 = (const char *)(i + 2);
LABEL_11:
      printf("%.20s", v15);
    }
    j_putchar_unlocked(10);
    free(v10);
    free(v11);
  }
}
// 1DFC4: variable 'v13' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001E040) --------------------------------------------------------
int __fastcall sub_1E040(char *s)
{
  int v1; // r4
  int v2; // r5
  const char *v3; // r0
  _BYTE v5[8]; // [sp+4h] [bp-40h] BYREF
  signed int v6; // [sp+Ch] [bp-38h]
  int v7; // [sp+28h] [bp-1Ch]

  v1 = sub_1DE70((int)v5, s);
  if ( v1 )
    return 1;
  v2 = v7;
  v3 = sub_16F8C(v6);
  sub_1DF24((int)v5, v3, "raw", v2);
  return v1;
}

//----- (0001E090) --------------------------------------------------------
int __fastcall sub_1E090(char *a1)
{
  int v2; // r4
  const char *v3; // r1
  _DWORD s[15]; // [sp+4h] [bp-3Ch] BYREF

  memset(s, 0, sizeof(s));
  v2 = sub_1DE70((int)s, a1);
  if ( v2 )
    return 1;
  if ( s[2] == 1 )
  {
    v3 = "ESTABLISHED";
  }
  else
  {
    v3 = "";
    if ( s[2] != 7 )
      v3 = "UNKNOWN";
  }
  sub_1DF24((int)s, v3, "udp", s[9]);
  return v2;
}

//----- (0001E110) --------------------------------------------------------
int __fastcall sub_1E110(char *a1)
{
  int v2; // r4
  int s[15]; // [sp+4h] [bp-3Ch] BYREF

  memset(s, 0, sizeof(s));
  v2 = sub_1DE70((int)s, a1);
  if ( v2 )
    return 1;
  sub_1DF24((int)s, (const char *)*(&off_634E8 + s[2]), "tcp", s[1]);
  return v2;
}
// 634E8: using guessed type _UNKNOWN *off_634E8;

//----- (0001E174) --------------------------------------------------------
int __fastcall sub_1E174(int a1, char **a2)
{
  _DWORD *v3; // r4
  int v4; // r0
  char v5; // r5
  int v7; // r5

  v3 = sub_174DC(0x358u);
  dword_7DB98 = (int)v3;
  *v3 = 241;
  v4 = sub_593CC(a2, "laentuwxrp");
  v5 = v4;
  if ( (v4 & 1) != 0 )
    *v3 = *v3 & 0xFFFFFFFC | 2;
  if ( (v4 & 2) != 0 )
    *v3 |= 3u;
  if ( (v4 & 8) != 0 )
    *v3 |= 4u;
  if ( (v4 & 0x100) != 0 )
  {
    sub_1EFDC(*v3 & 4, ((v4 ^ 4u) >> 2) & 1);
  }
  else
  {
    v3[213] = "";
    if ( (v4 & 0x200) != 0 )
    {
      v3[213] = "PID/Program name    ";
      v3[1] = 1;
      if ( !sub_60474("/proc", 33, 0, (int (*)())sub_1DBE4, v4 & 0x100, v4 & 0x100) )
      {
        if ( v3[1] == 1 )
          sub_16DDC("can't scan /proc - are you root?");
        else
          sub_16DDC("showing only processes with your user ID");
      }
    }
    v7 = v5 & 0xF0;
    if ( v7 )
      *v3 = *v3 & 0xFFFFFF0F | v7;
    if ( (*v3 & 0x70) != 0 )
    {
      printf("Active Internet connections ");
      if ( (*v3 & 3) == 3 )
      {
        printf("(servers and established)");
      }
      else if ( (*v3 & 2) != 0 )
      {
        printf("(only servers)");
      }
      else
      {
        printf("(w/o servers)");
      }
      printf(
        "\nProto Recv-Q Send-Q %-23s %-23s State       %s\n",
        "Local Address",
        "Foreign Address",
        (const char *)v3[213]);
    }
    if ( (*v3 & 0x10) != 0 )
      sub_1DDF0("/proc/net/tcp", (int (*)(void))sub_1E110);
    if ( (*v3 & 0x20) != 0 )
      sub_1DDF0("/proc/net/udp", (int (*)(void))sub_1E090);
    if ( (*v3 & 0x40) != 0 )
      sub_1DDF0("/proc/net/raw", (int (*)(void))sub_1E040);
    if ( (*v3 & 0x80) != 0 )
    {
      printf("Active UNIX domain sockets ");
      if ( (*v3 & 3) == 3 )
      {
        printf("(servers and established)");
      }
      else if ( (*v3 & 2) != 0 )
      {
        printf("(only servers)");
      }
      else
      {
        printf("(w/o servers)");
      }
      printf("\nProto RefCnt Flags       Type       State         I-Node %sPath\n", (const char *)v3[213]);
      sub_1DDF0("/proc/net/unix", (int (*)(void))sub_1D8A4);
    }
  }
  return 0;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0001E3B8) --------------------------------------------------------
void __fastcall __noreturn sub_1E3B8(int a1)
{
  unsigned int v1; // r5
  unsigned int v2; // r1
  unsigned int v3; // r8
  unsigned int v4; // r0
  int v5; // r0

  signal(2, (__sighandler_t)1);
  v1 = *(_DWORD *)&buf.c_cc[11];
  printf(
    "\n--- %s ping statistics ---\n%lu packets transmitted, %lu packets received, ",
    (const char *)dword_7D7E0,
    *(_DWORD *)&buf.c_cc[7],
    *(_DWORD *)&buf.c_cc[11]);
  if ( *(_DWORD *)&buf.c_cc[15] )
    printf("%lu duplicates, ", *(_DWORD *)&buf.c_cc[15]);
  v2 = *(_DWORD *)&buf.c_cc[7];
  if ( *(_DWORD *)&buf.c_cc[7] )
    v2 = sub_15CA0(100 * (*(_DWORD *)&buf.c_cc[7] - v1), *(unsigned int *)&buf.c_cc[7]);
  printf("%lu%% packet loss\n", v2);
  v3 = *(_DWORD *)&buf.c_cc[23];
  if ( *(_DWORD *)&buf.c_cc[23] != -1 )
  {
    v4 = sub_62C44(*(unsigned __int64 *)&buf.c_cc[31], *(_DWORD *)&buf.c_cc[15] + v1);
    printf(
      "round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\n",
      v3 / 0x3E8,
      v3 % 0x3E8,
      v4 / 0x3E8,
      v4 % 0x3E8,
      *(_DWORD *)&buf.c_cc[27] / 0x3E8u,
      *(_DWORD *)&buf.c_cc[27] % 0x3E8u);
  }
  if ( v1 )
  {
    v5 = dword_7D7CC;
    if ( dword_7D7CC )
      v5 = *(_DWORD *)&buf.c_line > v1;
  }
  else
  {
    v5 = 1;
  }
  exit(v5);
}
// 7D7CC: using guessed type int dword_7D7CC;
// 7D7E0: using guessed type int dword_7D7E0;

//----- (0001E4CC) --------------------------------------------------------
void __fastcall sub_1E4CC(int a1)
{
  int v1; // r5
  void *v2; // r0
  int v3; // r1
  int v4; // r2
  int v5; // r3
  size_t v6; // r6
  unsigned int v7; // r0
  int v8; // r4

  v1 = dword_7D7DC;
  v2 = memset((void *)dword_7D7DC, buf.c_cc[21], buf.c_lflag + 12);
  *(_WORD *)(v1 + 2) = 0;
  *(_BYTE *)v1 = 8;
  *(_WORD *)(v1 + 6) = __rev16(*(unsigned int *)&buf.c_cc[7]);
  *(_WORD *)(v1 + 4) = *(_WORD *)&buf.c_cc[19];
  buf.c_ospeed = sub_187B0((int)v2, v3, v4);
  *(_DWORD *)(v1 + 8) = buf.c_ospeed;
  *(_WORD *)(v1 + 2) = sub_5A500((unsigned __int16 *)v1, buf.c_lflag + 8);
  v5 = *(_DWORD *)&buf.c_cc[7];
  *((_BYTE *)&buf + ((*(_DWORD *)&buf.c_cc[7] >> 3) & 0x7F) + 104) &= ~(1 << (buf.c_cc[7] & 7));
  *(_DWORD *)&buf.c_cc[7] = v5 + 1;
  if ( dword_7D7CC && (signed int)(buf.c_ospeed - dword_7D7CC) >= 0 )
    sub_1E3B8(0);
  v6 = buf.c_lflag + 8;
  if ( v6 != sub_179DC(0, (const void *)dword_7D7DC, v6, (const struct sockaddr *)&unk_7D7E8, 0x10u) )
    sub_16DBC("write error");
  if ( *(_DWORD *)&buf.c_line && *(_DWORD *)&buf.c_line <= *(_DWORD *)&buf.c_cc[7] )
  {
    v8 = dword_7D7D0;
    if ( *(_DWORD *)&buf.c_cc[11] )
    {
      v8 = *(_DWORD *)&buf.c_cc[27] >> 19;
      if ( !(*(_DWORD *)&buf.c_cc[27] >> 19) )
        v8 = 1;
    }
    signal(14, (__sighandler_t)sub_1E3B8);
    v7 = v8;
  }
  else
  {
    signal(14, sub_1E4CC);
    v7 = 1;
  }
  alarm(v7);
}
// 1E510: variable 'v3' is possibly undefined
// 1E510: variable 'v4' is possibly undefined
// 7D7CC: using guessed type int dword_7D7CC;
// 7D7D0: using guessed type int dword_7D7D0;
// 7D7DC: using guessed type int dword_7D7DC;

//----- (0001E62C) --------------------------------------------------------
void __fastcall __noreturn sub_1E62C(int a1, char **a2)
{
  unsigned int v2; // r6
  int v4; // r0
  int v5; // r1
  int v6; // r2
  __int16 v7; // r8
  unsigned int v8; // r5
  int v9; // r0
  _WORD *v10; // r0
  _WORD *v11; // r5
  char *v12; // r0
  int v13; // r0
  void *v14; // r0
  _DWORD *v15; // lr
  _DWORD *v16; // r3
  int v17; // r1
  ssize_t v18; // r0
  char *v19; // r10
  int v20; // r3
  unsigned int v21; // r8
  int v22; // r5
  unsigned int v23; // r7
  _DWORD *v24; // r5
  char *v25; // r0
  int v26; // r1
  unsigned __int16 v27; // r7
  const char *v28; // r2
  int v29; // r3
  int v30; // r0
  int v31; // r12
  int v32; // r1
  bool v33; // zf
  int v34; // r1
  int v35; // r1
  int v36; // r1
  int v37; // r3
  char *v38; // [sp+18h] [bp-2Ch]
  int v39; // [sp+1Ch] [bp-28h]
  const char *v40; // [sp+24h] [bp-20h] BYREF
  const char *v41; // [sp+28h] [bp-1Ch] BYREF
  socklen_t addr_len; // [sp+2Ch] [bp-18h] BYREF
  struct sockaddr addr; // [sp+30h] [bp-14h] BYREF

  buf.c_cc[23] = -1;
  buf.c_cc[24] = -1;
  buf.c_cc[25] = -1;
  buf.c_cc[26] = -1;
  buf.c_lflag = 56;
  dword_7D7D0 = 10;
  v4 = sub_593CC(
         a2,
         "^qvAc:+s:t:+w:+W:+I:np:4",
         &buf.c_line,
         &v40,
         &buf.c_cc[3],
         &dword_7D7CC,
         &dword_7D7D0,
         &buf.c_oflag,
         &v41);
  v7 = v4;
  if ( (v4 & 0x10) != 0 )
  {
    v4 = sub_621A8(v40);
    buf.c_lflag = v4;
  }
  if ( (v7 & 0x100) != 0 )
  {
    v4 = if_nametoindex(buf.c_oflag);
    buf.c_iflag = v4;
    if ( !v4 )
    {
      v4 = (int)sub_6248C((const char *)buf.c_oflag, 0);
      buf.c_oflag = 0;
      buf.c_cflag = v4;
    }
  }
  if ( (v7 & 0x400) != 0 )
  {
    v4 = sub_62034(v41, 16, 0, 0xFFu);
    buf.c_cc[21] = v4;
  }
  v8 = dword_7D7CC;
  if ( dword_7D7CC )
  {
    v9 = sub_187B0(v4, v5, v6);
    if ( v8 >= 0x863 )
      v8 = 2147;
    dword_7D7CC = (v9 + 1000000 * v8) | 1;
  }
  *(_WORD *)&buf.c_cc[19] = getpid();
  dword_7D7E0 = (int)a2[optind];
  v10 = sub_62484((const char *)dword_7D7E0, 0);
  v11 = v10;
  if ( buf.c_cflag && *(unsigned __int16 *)(buf.c_cflag + 4) != (unsigned __int16)v10[2] )
    buf.c_cflag = 0;
  dword_7D7E4 = (int)sub_6249C((const struct sockaddr *)(v10 + 2));
  printf("PING %s (%s)", (const char *)dword_7D7E0, (const char *)dword_7D7E4);
  if ( buf.c_cflag )
  {
    v12 = sub_6249C((const struct sockaddr *)(buf.c_cflag + 4));
    printf(" from %s", v12);
  }
  printf(": %d data bytes\n", buf.c_lflag);
  v13 = socket(2, 3, 1);
  if ( v13 < 0 )
  {
    if ( *(_DWORD *)dword_7DB94 == 1 )
      sub_16DBC("permission denied (are you root?)");
    sub_16B40("can't create raw socket");
  }
  sub_176A8(v13, 0);
  if ( buf.c_oflag )
    sub_62424(0, (const char *)buf.c_oflag);
  dword_7D7D4 = buf.c_lflag + 136;
  dword_7D7D8 = (int)sub_174DC(buf.c_lflag + 136);
  v14 = sub_174DC(buf.c_lflag + 12);
  v15 = &unk_7D7E8;
  v16 = v11 + 2;
  dword_7D7DC = (int)v14;
  do
  {
    v15 += 2;
    v17 = v16[1];
    v33 = v16 + 2 == (_DWORD *)(v11 + 10);
    *(v15 - 2) = *v16;
    *(v15 - 1) = v17;
    v16 += 2;
  }
  while ( !v33 );
  if ( buf.c_cflag )
  {
    if ( setsockopt(0, 0, 32, (const void *)(buf.c_cflag + 4), *(_DWORD *)buf.c_cflag) )
      sub_16DBC("can't set multicast source interface");
    sub_179C0(0, (const struct sockaddr *)(buf.c_cflag + 4), *(_DWORD *)buf.c_cflag);
  }
  sub_6241C();
  sub_623FC(0, 8, 2 * (buf.c_lflag + 3584));
  if ( *(_DWORD *)&buf.c_cc[3] )
  {
    sub_623D0(0, 0, 2, *(int *)&buf.c_cc[3]);
    sub_623D0(0, 0, 33, *(int *)&buf.c_cc[3]);
  }
  signal(2, (__sighandler_t)sub_1E3B8);
LABEL_33:
  sub_1E4CC(0);
  while ( 1 )
  {
    while ( 1 )
    {
      addr_len = 16;
      v18 = recvfrom(0, (void *)dword_7D7D8, dword_7D7D4, 0, &addr, &addr_len);
      if ( v18 >= 0 )
        break;
      if ( *(_DWORD *)dword_7DB94 != 4 )
        sub_16AF4("recvfrom");
    }
    v19 = (char *)dword_7D7D8;
    if ( buf.c_lflag + 8 <= v18 )
    {
      v20 = *(_BYTE *)dword_7D7D8 & 0xF;
      v21 = v18 - 4 * v20;
      v22 = dword_7D7D8 + 4 * v20;
      if ( *(unsigned __int16 *)(v22 + 4) == *(unsigned __int16 *)&buf.c_cc[19] )
      {
        if ( !*(_BYTE *)(dword_7D7D8 + 4 * v20) )
        {
          v23 = *(unsigned __int16 *)(v22 + 6);
          if ( v21 <= 0xB )
            v24 = (_DWORD *)*(unsigned __int8 *)(dword_7D7D8 + 4 * v20);
          else
            v24 = (_DWORD *)(v22 + 8);
          v25 = inet_ntoa(*(struct in_addr *)&addr.sa_data[2]);
          v27 = __rev16(v23);
          v28 = v25;
          v29 = (unsigned __int8)v19[8];
          if ( v24 )
          {
            v38 = v25;
            v39 = (unsigned __int8)v19[8];
            v2 = sub_187B0((int)v25, v26, (int)v25) - *v24;
            v28 = v38;
            v29 = v39;
            *(_QWORD *)&buf.c_cc[31] += v2;
            if ( v2 < *(_DWORD *)&buf.c_cc[23] )
              *(_DWORD *)&buf.c_cc[23] = v2;
            if ( v2 > *(_DWORD *)&buf.c_cc[27] )
              *(_DWORD *)&buf.c_cc[27] = v2;
          }
          v30 = ((v27 >> 3) & 0x7F) + 104;
          v31 = *((unsigned __int8 *)&buf.c_iflag + v30);
          v32 = (unsigned __int8)(1 << (v27 & 7));
          v33 = (v32 & v31) == 0;
          if ( (v32 & v31) != 0 )
            v34 = *(_DWORD *)&buf.c_cc[15];
          else
            v34 = v32 | v31;
          if ( v33 )
          {
            *((_BYTE *)&buf.c_iflag + v30) = v34;
            v35 = *(_DWORD *)&buf.c_cc[11];
          }
          else
          {
            v35 = v34 + 1;
            v19 = " (DUP!)";
            *(_DWORD *)&buf.c_cc[15] = v35;
          }
          if ( v33 )
          {
            v19 = "";
            *(_DWORD *)&buf.c_cc[11] = v35 + 1;
          }
          if ( (dword_7DBC0 & 1) == 0 )
          {
            printf("%d bytes from %s: seq=%u ttl=%d", v21, v28, v27, v29);
            if ( v24 )
            {
              sub_15EFC(v2, 0x3E8u);
              printf(" time=%u.%03u ms", v2 / 0x3E8, v36);
            }
            puts(v19);
            sub_177D8();
          }
          v37 = 1;
          goto LABEL_61;
        }
        if ( *(_BYTE *)(dword_7D7D8 + 4 * v20) != 8 )
          sub_16DDC("warning: got ICMP %d (%s)");
      }
    }
    v37 = 0;
LABEL_61:
    if ( *(_DWORD *)&buf.c_line && *(_DWORD *)&buf.c_line <= *(_DWORD *)&buf.c_cc[11] )
      sub_1E3B8(0);
    if ( v37 && (dword_7DBC0 & 4) != 0 )
      goto LABEL_33;
  }
}
// 1E73C: variable 'v5' is possibly undefined
// 1E73C: variable 'v6' is possibly undefined
// 1EA1C: variable 'v26' is possibly undefined
// 1EAD4: variable 'v2' is possibly undefined
// 1EAE8: variable 'v36' is possibly undefined
// 140C0: using guessed type int __fastcall if_nametoindex(_DWORD);
// 7D604: using guessed type int optind;
// 7D7CC: using guessed type int dword_7D7CC;
// 7D7D0: using guessed type int dword_7D7D0;
// 7D7D4: using guessed type int dword_7D7D4;
// 7D7D8: using guessed type int dword_7D7D8;
// 7D7DC: using guessed type int dword_7D7DC;
// 7D7E0: using guessed type int dword_7D7E0;
// 7D7E4: using guessed type int dword_7D7E4;
// 7DB94: using guessed type int dword_7DB94;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0001EBB8) --------------------------------------------------------
int __fastcall sub_1EBB8(const char *a1, const char ***a2)
{
  const char **v2; // r6
  const char *v3; // r4
  int result; // r0
  int v7; // r3
  int v8; // t1

  v2 = *a2;
  v3 = **a2;
  if ( !v3 )
    return 0;
  while ( strcmp(a1 + 2, v3) )
  {
    v7 = *(unsigned __int8 *)a1;
    v8 = (unsigned __int8)a1[v7];
    a1 += v7;
    result = v8;
    if ( !v8 )
      return result;
  }
  *a2 = v2 + 1;
  if ( (a1[1] & 0x10) != 0 )
  {
    if ( !v2[1] )
      sub_162F0();
    *a2 = v2 + 2;
  }
  return *((unsigned __int8 *)a1 + 1);
}

//----- (0001EC38) --------------------------------------------------------
int __fastcall sub_1EC38(int a1, const char **a2)
{
  int v3; // r0
  int v4; // r7
  const char *v5; // r8
  char *v6; // r0
  char *v7; // r9
  int v8; // r0
  __int16 v9; // r3
  unsigned int v10; // r3
  int v11; // r12
  int v12; // r0
  int v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r3
  int v18; // r0
  const char *v19; // r3
  unsigned int v20; // r1
  const char **v22[2]; // [sp+4h] [bp-6Ch] BYREF
  struct in_addr v23[4]; // [sp+Ch] [bp-64h] BYREF
  struct in_addr s[21]; // [sp+1Ch] [bp-54h] BYREF

  v22[0] = a2;
  v3 = sub_1EBB8(asc_662A2, v22);
  if ( !*v22[0] )
LABEL_2:
    sub_162F0();
  v4 = v3;
  memset(s, 0, sizeof(s));
  v5 = *v22[0]++;
  v6 = strchr(v5, 47);
  v7 = v6;
  if ( v6 )
  {
    s[10].s_addr = bswap32(~(0xFFFFFFFF >> sub_6206C(v6 + 1, 0, 0x20u)));
    *v7 = 0;
    LOWORD(s[9].s_addr) = 2;
  }
  v8 = sub_5A53C(v5, &s[1]);
  if ( v8 < 0 )
LABEL_34:
    sub_16DBC("resolving %s");
  if ( v7 )
    *v7 = 47;
  if ( v4 )
    v8 = v4 & 1;
  if ( v8 )
    v9 = 1;
  else
    v9 = 5;
  LOWORD(s[13].s_addr) = v9;
  while ( *v22[0] )
  {
    v12 = sub_1EBB8(asc_662B1, v22);
    if ( (v12 & 0x20) != 0 )
    {
      LOWORD(s[13].s_addr) |= word_642CE[v12 & 3];
    }
    else
    {
      switch ( v12 )
      {
        case 16:
          LOWORD(s[16].s_addr) = sub_620B0(*(v22[0] - 1)) + 1;
          break;
        case 17:
          if ( s[10].s_addr )
            goto LABEL_2;
          if ( sub_5A53C(*(v22[0] - 1), v23) < 0 )
            goto LABEL_34;
          s[9] = v23[0];
          s[10] = v23[1];
          s[11] = v23[2];
          s[12] = v23[3];
          break;
        case 18:
          if ( (s[13].s_addr & 2) != 0 )
            goto LABEL_2;
          v13 = sub_5A53C(*(v22[0] - 1), &s[5]);
          LOWORD(s[13].s_addr) |= 2u;
          if ( v13 )
          {
            if ( v13 >= 0 )
              sub_16DBC("gateway %s is a NETWORK");
            goto LABEL_34;
          }
          break;
        case 19:
          v14 = *(v22[0] - 1);
          LOWORD(s[13].s_addr) |= 0x40u;
          s[18].s_addr = sub_6206C(v14, 0x40u, 0x8000u);
          break;
        case 20:
          v15 = *(v22[0] - 1);
          LOWORD(s[13].s_addr) |= 0x80u;
          s[19].s_addr = sub_6206C(v15, 0x80u, 0x7FFFFFFFu);
          break;
        case 21:
          v16 = *(v22[0] - 1);
          LOWORD(s[13].s_addr) |= 0x100u;
          LOWORD(s[20].s_addr) = sub_620B0(v16);
          LOWORD(s[20].s_addr) *= (unsigned __int16)(sub_60F80() / 0x64u);
          break;
        default:
          if ( s[17].s_addr )
            goto LABEL_2;
          if ( v12 != 22 )
          {
            if ( v12 )
              goto LABEL_2;
            v17 = v22[0][1];
            ++v22[0];
            if ( v17 )
              goto LABEL_2;
          }
          s[17] = (struct in_addr)*(v22[0] - 1);
          break;
      }
    }
  }
  if ( (s[13].s_addr & 0x200) != 0 && !s[17].s_addr )
    s[17].s_addr = (in_addr_t)"lo";
  if ( s[10].s_addr )
  {
    v10 = bswap32(s[10].s_addr);
    v11 = -v10;
    if ( v10 )
      LOWORD(v11) = 1;
    if ( (v11 & (LOWORD(s[13].s_addr) >> 2)) != 0 )
      sub_16DBC("netmask %.8x and host route conflict");
    if ( (-v10 & ~v10) != 0 )
      sub_16DBC("bogus netmask %s");
    if ( (s[2].s_addr & ~s[10].s_addr) != 0 )
      sub_16DBC("netmask and route address conflict");
  }
  if ( a1 == 1 && (s[13].s_addr & 4) != 0 )
    s[10].s_addr = -1;
  v18 = sub_179A4(2, 2, 0);
  if ( a1 == 1 )
  {
    v19 = "SIOCADDRT";
    v20 = 35083;
  }
  else
  {
    v19 = "SIOCDELRT";
    v20 = 35084;
  }
  return sub_17B18(v18, v20, (int)s, v19);
}
// 642CE: using guessed type _WORD word_642CE[3];

//----- (0001EFDC) --------------------------------------------------------
int __fastcall sub_1EFDC(int a1, int a2)
{
  int v4; // r0
  const char *v5; // r1
  FILE *v6; // r4
  int v7; // r0
  __int16 v8; // r1
  char *v9; // r12
  int v10; // r8
  unsigned __int16 *v11; // lr
  char *v12; // r2
  int v13; // t1
  char *v14; // r9
  char *v15; // r8
  char *v16; // r0
  int v17; // t1
  int v19; // [sp+28h] [bp-8Ch] BYREF
  int v20; // [sp+2Ch] [bp-88h] BYREF
  struct in_addr in; // [sp+30h] [bp-84h] BYREF
  int v22; // [sp+34h] [bp-80h] BYREF
  int v23; // [sp+38h] [bp-7Ch] BYREF
  int v24; // [sp+3Ch] [bp-78h] BYREF
  int v25; // [sp+40h] [bp-74h] BYREF
  int v26; // [sp+44h] [bp-70h] BYREF
  int v27; // [sp+48h] [bp-6Ch] BYREF
  int v28; // [sp+4Ch] [bp-68h] BYREF
  char v29[16]; // [sp+50h] [bp-64h] BYREF
  _DWORD v30[4]; // [sp+60h] [bp-54h] BYREF
  _BYTE v31[68]; // [sp+70h] [bp-44h] BYREF

  v4 = sub_61CA8("/proc/net/route");
  v5 = "  MSS Window  irtt";
  v6 = (FILE *)v4;
  if ( !a2 )
    v5 = "Metric Ref    Use";
  printf("Kernel IP routing table\nDestination     Gateway         Genmask         Flags %s Iface\n", v5);
  if ( fscanf(v6, "%*[^\n]\n") >= 0 )
  {
    while ( 1 )
    {
      v7 = fscanf(v6, "%63s%lx%lx%X%d%d%d%lx%d%d%d\n", v31, &v19, &v20, &v22, &v23, &v24, &v25, &in, &v26, &v27, &v28);
      if ( v7 != 11 )
        break;
      v8 = v22;
      if ( (v22 & 1) != 0 )
      {
        v9 = "";
        v10 = v22 & 0x3F;
        v11 = (unsigned __int16 *)&unk_642D4;
        v12 = v29;
        while ( 1 )
        {
          v13 = (unsigned __int8)*++v9;
          *v12 = v13;
          if ( !v13 )
            break;
          v17 = v11[1];
          ++v11;
          if ( (v17 & v10) != 0 )
            ++v12;
        }
        if ( (v8 & 0x200) != 0 )
          v29[0] = 33;
        memset((char *)v30 + 2, 0, 0xEu);
        LOWORD(v30[0]) = 2;
        v30[1] = v19;
        v14 = sub_5A5B0((int)v30, a1 | 0x8000, in.s_addr);
        v30[1] = v20;
        v15 = sub_5A5B0((int)v30, a1 | 0x4000, in.s_addr);
        v16 = inet_ntoa(in);
        printf("%-15.15s %-15.15s %-16s%-6s", v14, v15, v16, v29);
        free(v14);
        free(v15);
        if ( a2 )
          printf("%5d %-5d %6d %s\n", v26, v27, v28, v31);
        else
          printf("%-6d %-2d %7d %s\n", v25, v23, v24, v31);
      }
    }
    if ( v7 >= 0 )
      goto LABEL_7;
  }
  if ( !feof_unlocked(v6) )
LABEL_7:
    sub_16B40("read error");
  return fclose(v6);
}

//----- (0001F1F0) --------------------------------------------------------
int __fastcall sub_1F1F0(int a1, const char **a2, const char **a3, char *a4)
{
  const char **v4; // r5
  char *v5; // r4
  char *v6; // t1
  char v7; // r4
  const char *v8; // r5
  int v9; // r0
  int v10; // r0
  const char **v12[2]; // [sp+4h] [bp-Ch] BYREF
  char *s1; // [sp+Ch] [bp-4h] BYREF

  v12[1] = a3;
  s1 = a4;
  v4 = a2;
  v12[0] = a2;
  while ( 1 )
  {
    v6 = (char *)v4[1];
    ++v4;
    v5 = v6;
    if ( !v6 )
      break;
    if ( !strcmp(v5, "-net") || !strcmp(v5, "-host") )
      *v5 = 35;
  }
  v7 = sub_593CC((char **)v12[0], "A:ne", &s1);
  if ( (v7 & 1) != 0 && strcmp(s1, "inet") )
    goto LABEL_5;
  v8 = v12[0][optind];
  v12[0] += optind;
  if ( !v8 )
  {
    v9 = 4095;
    if ( (v7 & 2) == 0 )
      v9 = 0;
    sub_1EFDC(v9, v7 & 4);
    sub_588D8(0);
  }
  v10 = sub_1EBB8(byte_66319, v12);
  if ( !v10 || !*v12[0] )
LABEL_5:
    sub_162F0();
  sub_1EC38(v10, v12[0]);
  return 0;
}
// 7D604: using guessed type int optind;

//----- (0001F300) --------------------------------------------------------
_BYTE **__fastcall sub_1F300(_BYTE **a1)
{
  _BYTE *v2; // r3
  char *v3; // r1
  _BYTE **v4; // r5
  _BYTE **result; // r0
  char v6; // r2
  int v7; // r0
  char *v8; // r1
  int v9; // r0

  while ( 1 )
  {
    v2 = *a1;
    if ( !*a1 || *v2 != 45 )
      break;
    v3 = v2 + 1;
    v4 = a1 + 1;
    if ( v2[1] == 45 )
    {
      v3 = v2 + 2;
      if ( !v2[2] )
      {
        ++a1;
        break;
      }
    }
    v7 = sub_168D4("oneline", v3);
    if ( v7 < 0 )
      goto LABEL_11;
    v8 = a1[1];
    if ( v7 )
    {
      if ( v7 == 1 )
      {
        if ( !v8 )
LABEL_11:
          sub_162F0();
        v9 = sub_16880("inet", v8);
        if ( v9 < 0 )
          sub_23EE8(a1[1], "family");
      }
      else
      {
        v9 = v7 - 2;
        v4 = a1;
      }
      ++v4;
      byte_7D781 = byte_6632E[v9];
    }
    else
    {
      dword_7DBA4 = 1;
    }
    a1 = v4;
  }
  result = a1;
  if ( dword_7DBA4 )
    v6 = 92;
  else
    v6 = 10;
  byte_7DBA8 = v6;
  return result;
}
// 6632E: using guessed type _BYTE byte_6632E[3];
// 7D781: using guessed type char byte_7D781;
// 7DBA4: using guessed type int dword_7DBA4;
// 7DBA8: using guessed type char byte_7DBA8;

//----- (0001F408) --------------------------------------------------------
int __fastcall sub_1F408(int a1, _DWORD *a2, _DWORD *a3)
{
  char *v6; // r7

  v6 = (char *)sub_174DC(*a2 + 4);
  memcpy(v6 + 4, a2, *a2);
  while ( *a3 )
    a3 = (_DWORD *)*a3;
  *a3 = v6;
  sub_233E8(a1, (int)a2);
  return 0;
}

//----- (0001F468) --------------------------------------------------------
int sub_1F468()
{
  if ( sub_22B54((int *)buf.c_cflag, (const void *)buf.c_oflag, *(size_t *)&buf.c_cc[11]) >= 0 )
  {
    buf.c_cc[11] = 0;
    buf.c_cc[12] = 0;
    buf.c_cc[13] = 0;
    buf.c_cc[14] = 0;
    return 0;
  }
  else
  {
    sub_16AF4("can't send flush request");
    return -1;
  }
}

//----- (0001F4B8) --------------------------------------------------------
int __fastcall sub_1F4B8(int a1, int a2)
{
  int v2; // r2
  int v3; // r6
  int v5; // r3
  bool v7; // zf
  _DWORD *v8; // r0
  int v9; // r2
  const char *v10; // r1
  int v11; // r5
  const char *v12; // r0
  int v13; // r1
  const char *v14; // r0
  const void *v15; // r5
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  int v19; // r4
  int v20; // r2
  int v21; // r4
  char *v22; // r0
  const char *v23; // r0
  _BYTE v24[4]; // [sp+4h] [bp-A8h] BYREF
  unsigned __int16 *v25; // [sp+8h] [bp-A4h]
  unsigned __int16 *v26; // [sp+Ch] [bp-A0h]
  int v27; // [sp+10h] [bp-9Ch]
  int v28; // [sp+14h] [bp-98h]
  int v29; // [sp+18h] [bp-94h]
  int v30; // [sp+1Ch] [bp-90h]
  char s[132]; // [sp+28h] [bp-84h] BYREF

  v2 = *(unsigned __int16 *)(a2 + 4);
  if ( (unsigned int)(v2 - 20) > 1 )
    return 0;
  v5 = *(_DWORD *)a2 - 24;
  if ( v5 < 0 )
  {
    sub_16DDC("wrong nlmsg len %d", v5);
    return -1;
  }
  v7 = buf.c_oflag == 0;
  if ( buf.c_oflag )
    v7 = v2 == 20;
  if ( !v7 )
    return 0;
  sub_23174(v24, 8, (unsigned __int16 *)(a2 + 24), v5);
  if ( !v26 )
    v26 = v25;
  if ( !v25 )
    v25 = v26;
  if ( *(_DWORD *)&buf.c_cc[19] && *(_DWORD *)&buf.c_cc[19] != *(_DWORD *)(a2 + 20) )
    return 0;
  if ( ((buf.c_lflag ^ *(unsigned __int8 *)(a2 + 19)) & *(_DWORD *)&buf.c_line) != 0 )
    return 0;
  v3 = (*(_DWORD *)&buf.c_cc[3] ^ *(unsigned __int8 *)(a2 + 18)) & *(_DWORD *)&buf.c_cc[7];
  if ( v3 )
    return 0;
  if ( buf.c_iflag )
  {
    v10 = v27 ? (const char *)(v27 + 4) : sub_2350C(*(_DWORD *)(a2 + 20));
    if ( fnmatch((const char *)buf.c_iflag, v10, 0) )
      return 0;
  }
  if ( !(_BYTE)dword_7D7CC
    || !v26
    || (memset(s, 0, 0x14u),
        s[0] = *(_BYTE *)(a2 + 16),
        memcpy(&s[4], v26 + 2, *v26 - 4),
        !sub_23FDC((int)s, (int)&dword_7D7CC, SHIWORD(dword_7D7CC))) )
  {
    if ( buf.c_oflag )
    {
      if ( ((*(_DWORD *)&buf.c_cc[11] + 3) & 0xFFFFFFFC) + *(_DWORD *)a2 <= *(_DWORD *)&buf.c_cc[15] || !sub_1F468() )
      {
        v8 = memcpy(
               (void *)(buf.c_oflag + ((*(_DWORD *)&buf.c_cc[11] + 3) & 0xFFFFFFFC)),
               (const void *)a2,
               *(_DWORD *)a2);
        v8[1] = 65557;
        v9 = *(_DWORD *)(buf.c_cflag + 28) + 1;
        *(_DWORD *)(buf.c_cflag + 28) = v9;
        v8[2] = v9;
        *(_DWORD *)&buf.c_cc[11] = (char *)v8 + *(_DWORD *)a2 - buf.c_oflag;
        buf.c_ospeed = 1;
        return v3;
      }
      return -1;
    }
    if ( *(_WORD *)(a2 + 4) == 21 )
      printf("Deleted ");
    if ( *(_DWORD *)&buf.c_cc[31] )
    {
      v11 = *(_DWORD *)(a2 + 20);
      v12 = sub_2350C(v11);
      printf("%u: %s", v11, v12);
    }
    v13 = *(unsigned __int8 *)(a2 + 16);
    if ( v13 == 2 )
    {
      printf("    inet ");
    }
    else if ( v13 == 10 )
    {
      printf("    inet6 ");
    }
    else
    {
      printf("    family %d ", v13);
    }
    if ( v26 )
    {
      v14 = sub_24048(*(unsigned __int8 *)(a2 + 16), v26 + 2);
      fputs_unlocked(v14, stdout);
      if ( v25 && (v15 = v25 + 2, memcmp(v25 + 2, v26 + 2, 4u)) )
      {
        v23 = sub_24048(*(unsigned __int8 *)(a2 + 16), v15);
        printf(" peer %s/%d ", v23, *(unsigned __int8 *)(a2 + 17));
      }
      else
      {
        printf("/%d ", *(unsigned __int8 *)(a2 + 17));
      }
    }
    if ( v28 )
    {
      v16 = sub_24048(*(unsigned __int8 *)(a2 + 16), (const void *)(v28 + 4));
      printf("brd %s ", v16);
    }
    if ( v29 )
    {
      v17 = sub_24048(*(unsigned __int8 *)(a2 + 16), (const void *)(v29 + 4));
      printf("any %s ", v17);
    }
    v18 = sub_23888(*(unsigned __int8 *)(a2 + 19));
    printf("scope %s ", v18);
    if ( (*(_BYTE *)(a2 + 18) & 1) != 0 )
    {
      *(_BYTE *)(a2 + 18) &= ~1u;
      printf("secondary ");
    }
    if ( (*(_BYTE *)(a2 + 18) & 0x40) != 0 )
    {
      *(_BYTE *)(a2 + 18) &= ~0x40u;
      printf("tentative ");
    }
    if ( (*(_BYTE *)(a2 + 18) & 0x20) != 0 )
    {
      *(_BYTE *)(a2 + 18) &= ~0x20u;
      printf("deprecated ");
    }
    if ( (*(_BYTE *)(a2 + 18) & 0x80) != 0 )
      *(_BYTE *)(a2 + 18) &= ~0x80u;
    else
      printf("dynamic ");
    if ( *(_BYTE *)(a2 + 18) )
      printf("flags %02x ", *(unsigned __int8 *)(a2 + 18));
    if ( v27 )
      fputs_unlocked(v27 + 4, stdout);
    v19 = v30;
    if ( v30 )
    {
      j_putchar_unlocked((unsigned __int8)byte_7DBA8);
      v20 = *(_DWORD *)(v19 + 8);
      if ( v20 == -1 )
        strcpy(s, "valid_lft forever");
      else
        sprintf(s, "valid_lft %dsec", v20);
      v21 = *(_DWORD *)(v19 + 4);
      v22 = &s[strlen(s)];
      if ( v21 == -1 )
        strcpy(v22, " preferred_lft forever");
      else
        sprintf(v22, " preferred_lft %dsec", v21);
      printf("       %s", s);
    }
    j_putchar_unlocked(10);
  }
  return v3;
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;
// 7D7CC: using guessed type int dword_7D7CC;
// 7DBA8: using guessed type char byte_7DBA8;

//----- (0001F9AC) --------------------------------------------------------
int __fastcall sub_1F9AC(int a1)
{
  int v2; // r3
  int v4; // r5
  const char *v5; // r0
  int v6; // r7
  int v7; // r1
  const char *v8; // r0
  int v9; // r7
  int v10; // r5
  const char *v11; // r7
  bool v12; // zf
  int v13; // r5
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  bool v17; // zf
  _DWORD s[16]; // [sp+8h] [bp-108h] BYREF
  _BYTE v19[4]; // [sp+48h] [bp-C8h] BYREF
  unsigned __int8 *v20; // [sp+4Ch] [bp-C4h]
  unsigned __int8 *v21; // [sp+50h] [bp-C0h]
  int v22; // [sp+54h] [bp-BCh]
  int v23; // [sp+58h] [bp-B8h]
  int v24; // [sp+5Ch] [bp-B4h]
  int v25; // [sp+60h] [bp-B0h]
  int v26; // [sp+70h] [bp-A0h]

  if ( (unsigned int)*(unsigned __int16 *)(a1 + 4) - 16 > 1 )
    return 0;
  v2 = *(_DWORD *)a1 - 32;
  if ( v2 < 0 )
    return -1;
  if ( (!*(_DWORD *)&buf.c_cc[19] || *(_DWORD *)&buf.c_cc[19] == *(_DWORD *)(a1 + 20))
    && (!buf.c_ispeed || (*(_DWORD *)(a1 + 24) & 1) != 0) )
  {
    sub_23174(v19, 43, (unsigned __int16 *)(a1 + 32), v2);
    if ( !v22 )
    {
      sub_16DDC("nil ifname");
      return -1;
    }
    if ( !buf.c_iflag )
      goto LABEL_11;
    v17 = buf.c_cc[23] == 17;
    if ( buf.c_cc[23] != 17 )
      v17 = buf.c_cc[23] == 0;
    if ( !v17 || !fnmatch((const char *)buf.c_iflag, (const char *)(v22 + 4), 0) )
    {
LABEL_11:
      if ( *(_WORD *)(a1 + 4) == 17 )
        printf("Deleted ");
      printf("%d: %s", *(_DWORD *)(a1 + 20), (const char *)(v22 + 4));
      v4 = v24;
      if ( v24 )
      {
        v4 = *(_DWORD *)(v24 + 4);
        if ( v4 )
        {
          v5 = sub_2350C(v4);
          printf("@%s: ", v5);
          v4 = ((unsigned __int8)sub_23550(v4) & 1) == 0;
        }
        else
        {
          printf("@NONE: ");
        }
      }
      else
      {
        printf(": ");
      }
      v6 = *(_DWORD *)(a1 + 24);
      j_putchar_unlocked(60);
      if ( (v6 & 0x41) == 1 )
        printf("NO-CARRIER,");
      v7 = sub_5E3AC((int)&unk_63564, "LOOPBACK", v6 & 0xFFFFFFBF, ",");
      if ( v7 )
        printf("%x", v7);
      if ( v4 )
        printf(",M-DOWN");
      printf("> ");
      if ( v23 )
        printf("mtu %u ", *(_DWORD *)(v23 + 4));
      if ( v25 )
        printf("qdisc %s ", (const char *)(v25 + 4));
      if ( v26 )
      {
        v8 = sub_2350C(*(_DWORD *)(v26 + 4));
        printf("master %s ", v8);
      }
      if ( *(_DWORD *)&buf.c_cc[27] )
      {
        v9 = v22;
        v10 = socket(2, 1, 0);
        v11 = (const char *)(v9 + 4);
        if ( v10 >= 0 )
        {
          memset(s, 0, 0x20u);
          sub_16EA8((char *)s, v11);
          if ( sub_17AF4(v10, 0x8942u, (int)s, "SIOCGIFTXQLEN") < 0 )
          {
            close(v10);
          }
          else
          {
            close(v10);
            if ( s[4] )
              printf("qlen %d", s[4]);
          }
        }
      }
      v12 = buf.c_cc[23] == 17;
      if ( buf.c_cc[23] != 17 )
        v12 = buf.c_cc[23] == 0;
      if ( v12 )
      {
        v13 = (unsigned __int8)byte_7DBA8;
        v14 = sub_235C8(*(unsigned __int16 *)(a1 + 18), (char *)s);
        printf("%c    link/%s ", v13, v14);
        if ( v20 )
        {
          v15 = sub_231F8(v20 + 4, *(unsigned __int16 *)v20 - 4, *(unsigned __int16 *)(a1 + 18), (char *)s, 0x40u);
          fputs_unlocked(v15, stdout);
        }
        if ( v21 )
        {
          if ( (*(_DWORD *)(a1 + 24) & 0x10) != 0 )
            printf(" peer ");
          else
            printf(" brd ");
          v16 = sub_231F8(v21 + 4, *(unsigned __int16 *)v21 - 4, *(unsigned __int16 *)(a1 + 18), (char *)s, 0x40u);
          fputs_unlocked(v16, stdout);
        }
      }
      j_putchar_unlocked(10);
    }
  }
  return 0;
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;
// 7DBA8: using guessed type char byte_7DBA8;

//----- (0001FD4C) --------------------------------------------------------
int __fastcall sub_1FD4C(int a1, __int16 a2, char **a3)
{
  int v5; // r5
  unsigned int v6; // r6
  int v7; // r10
  int v8; // r7
  char *v9; // r11
  const char *v10; // r9
  int v11; // r3
  int v12; // r0
  char *v13; // r4
  const char *v14; // r0
  const char *v15; // r1
  int v16; // r3
  size_t v17; // r0
  _BOOL4 v18; // r4
  _BOOL4 v19; // r7
  _BOOL4 v20; // r10
  int v21; // r2
  int v22; // r3
  int v23; // r1
  char v24; // r3
  int v25; // r1
  int v26; // r2
  int v27; // r3
  unsigned int v29; // r3
  unsigned int v30; // r3
  int v31; // [sp+Ch] [bp-178h]
  int v33; // [sp+14h] [bp-170h]
  __int64 v34; // [sp+1Ch] [bp-168h] BYREF
  int v35; // [sp+24h] [bp-160h]
  int v36; // [sp+28h] [bp-15Ch]
  int v37; // [sp+2Ch] [bp-158h]
  __int64 v38; // [sp+30h] [bp-154h] BYREF
  int v39; // [sp+38h] [bp-14Ch]
  int v40; // [sp+3Ch] [bp-148h]
  int v41; // [sp+40h] [bp-144h]
  __int64 v42; // [sp+44h] [bp-140h] BYREF
  int v43; // [sp+4Ch] [bp-138h]
  int v44; // [sp+50h] [bp-134h]
  int v45; // [sp+54h] [bp-130h]
  size_t s[70]; // [sp+68h] [bp-11Ch] BYREF

  memset(s, 0, sizeof(s));
  v5 = 0;
  s[0] = 24;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  LOWORD(s[1]) = a1;
  HIWORD(s[1]) = a2 | 1;
  v31 = 0;
  LOBYTE(s[4]) = byte_7D781;
  while ( *a3 )
  {
    v11 = sub_16880("peer", *a3);
    if ( v11 >= 0 )
    {
      v33 = v11;
      v12 = sub_23EC4((int)a3);
      v11 = v33;
      a3 = (char **)v12;
    }
    v13 = *a3;
    if ( (unsigned int)v11 > 1 )
    {
      if ( (unsigned int)v11 > 3 )
      {
        switch ( v11 )
        {
          case 4:
            if ( v31 )
            {
              v15 = *a3;
              v14 = "anycast";
LABEL_13:
              sub_23FAC(v14, v15);
            }
            sub_23CCC(&v42, v13, LOBYTE(s[4]));
            if ( !LOBYTE(s[4]) )
              LOBYTE(s[4]) = v42;
            sub_230B4(s, 280, 5, (char *)&v42 + 4, BYTE1(v42));
            v31 = BYTE1(v42);
            break;
          case 5:
            LODWORD(v42) = 0;
            if ( sub_238C8((unsigned int *)&v42, v13) )
              sub_23EE8(*a3, "scope");
            v5 = 1;
            HIBYTE(s[4]) = v42;
            break;
          case 6:
            v10 = *a3;
            break;
          case 7:
            v9 = *a3;
            v17 = strlen(*a3);
            sub_230B4(s, 280, 3, v13, v17 + 1);
            break;
          default:
            if ( v8 )
              sub_23FC4("local", *a3);
            sub_23D18(&v34, *a3, LOBYTE(s[4]));
            if ( !LOBYTE(s[4]) )
              LOBYTE(s[4]) = v34;
            sub_230B4(s, 280, 2, (char *)&v34 + 4, BYTE1(v34));
            v8 = BYTE1(v34);
            break;
        }
      }
      else
      {
        if ( v6 )
        {
          v15 = *a3;
          v14 = "broadcast";
          goto LABEL_13;
        }
        v16 = (unsigned __int8)*v13;
        if ( v16 == 43 )
        {
          if ( !v13[1] )
          {
            v6 = -1;
            goto LABEL_17;
          }
        }
        else if ( v16 == 45 && !v13[1] )
        {
          v6 = -2;
          goto LABEL_17;
        }
        sub_23CCC(&v42, *a3, LOBYTE(s[4]));
        if ( !LOBYTE(s[4]) )
          LOBYTE(s[4]) = v42;
        sub_230B4(s, 280, 4, (char *)&v42 + 4, BYTE1(v42));
        v6 = BYTE1(v42);
      }
    }
    else
    {
      if ( v7 )
      {
        v14 = "peer";
        v15 = *a3;
        goto LABEL_13;
      }
      sub_23D18(&v38, *a3, LOBYTE(s[4]));
      v7 = BYTE1(v38);
      if ( !LOBYTE(s[4]) )
        LOBYTE(s[4]) = v38;
      sub_230B4(s, 280, 1, (char *)&v38 + 4, BYTE1(v38));
      BYTE1(s[4]) = BYTE2(v38);
    }
LABEL_17:
    ++a3;
  }
  if ( !v10 )
    sub_16DBC("need \"dev IFACE\"");
  if ( v9 && !sub_1684C((unsigned __int8 *)v9, (int)v10) )
    sub_16DBC("\"dev\" (%s) must match \"label\" (%s)", v10, v9);
  v18 = a1 != 21;
  v19 = v8 != 0;
  if ( v7 )
    v20 = 0;
  else
    v20 = v19;
  if ( v18 && v20 )
  {
    v38 = v34;
    v39 = v35;
    v40 = v36;
    v41 = v37;
    sub_230B4(s, 280, 1, (char *)&v34 + 4, BYTE1(v34));
  }
  if ( !BYTE1(s[4]) )
    BYTE1(s[4]) = BYTE2(v34);
  if ( (v18 & (v6 >> 31)) != 0 )
  {
    if ( LOBYTE(s[4]) != 2 )
      sub_16DBC("broadcast can be set only for IPv4 addresses");
    v42 = v38;
    v43 = v39;
    v44 = v40;
    v45 = v41;
    if ( SWORD1(v38) <= 30 )
    {
      v21 = HIDWORD(v42);
      v22 = 0;
      v23 = 31;
      while ( SWORD1(v38) <= v23 )
      {
        v29 = 1 << (31 - v23--);
        v30 = bswap32(v29);
        if ( v6 == -1 )
          v21 |= v30;
        else
          v21 &= ~v30;
        v22 = v18 & (v6 >> 31);
      }
      if ( v22 )
        HIDWORD(v42) = v21;
      sub_230B4(s, 280, 4, (char *)&v42 + 4, BYTE1(v42));
    }
  }
  if ( (v18 & (v5 ^ 1)) != 0 )
  {
    if ( (unsigned __int8)v34 == 2 )
    {
      v24 = BYTE1(v34);
      if ( BYTE1(v34) )
      {
        if ( BYTE4(v34) == 127 )
          v24 = -2;
        else
          v24 = 0;
      }
    }
    else
    {
      v24 = 0;
    }
    HIBYTE(s[4]) = v24;
  }
  sub_22AF4((int *)&v42);
  sub_23598((int *)&v42, v25, v26, v27);
  s[5] = sub_23574(v10);
  if ( sub_22DD4((int *)&v42, (int)s, 0) >= 0 )
    return 0;
  else
    return 2;
}
// 20188: variable 'v25' is possibly undefined
// 20188: variable 'v26' is possibly undefined
// 20188: variable 'v27' is possibly undefined
// 7D781: using guessed type char byte_7D781;

//----- (00020204) --------------------------------------------------------
int __fastcall sub_20204(char **a1, speed_t c_ospeed)
{
  int v4; // r0
  int v5; // r3
  int v6; // r3
  char **v8; // r0
  const char *v9; // r8
  _BOOL4 v10; // r7
  _DWORD **v11; // r8
  _DWORD *v12; // r10
  _DWORD *j; // r8
  unsigned __int16 *i; // r5
  const char *v15; // r1
  int v16; // r10
  unsigned __int16 *k; // r5
  const char *v18; // [sp+0h] [bp-E4Ch]
  _DWORD *v19; // [sp+8h] [bp-E44h] BYREF
  unsigned __int16 *v20; // [sp+Ch] [bp-E40h] BYREF
  _BYTE v21[20]; // [sp+10h] [bp-E3Ch] BYREF
  int v22[9]; // [sp+24h] [bp-E28h] BYREF
  unsigned int v23[2]; // [sp+48h] [bp-E04h] BYREF
  unsigned __int16 *v24; // [sp+50h] [bp-DFCh]
  int v25; // [sp+54h] [bp-DF8h]

  v19 = 0;
  v20 = 0;
  memset(&buf, 0, 0x50u);
  *(_DWORD *)&buf.c_cc[31] = dword_7DBA4;
  buf.c_cc[27] = 1;
  buf.c_cc[28] = 0;
  buf.c_cc[29] = 0;
  buf.c_cc[30] = 0;
  buf.c_cc[23] = byte_7D781;
  if ( c_ospeed )
  {
    if ( !*a1 )
      sub_16DBC("%s requires an argument", "flush");
    if ( buf.c_cc[23] == 17 )
      sub_16DBC("can't flush link addresses");
  }
  v9 = 0;
  while ( *a1 )
  {
    v4 = sub_16880("to", *a1);
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        v23[0] = 0;
        v8 = (char **)sub_23EC4((int)a1);
        buf.c_line = -1;
        a1 = v8;
        buf.c_cc[0] = -1;
        buf.c_cc[1] = -1;
        buf.c_cc[2] = -1;
        if ( sub_238C8(v23, *v8) )
        {
          v18 = *a1;
          if ( strcmp(*a1, "all") )
            sub_23EE8(v18, "scope");
          buf.c_line = 0;
          v23[0] = 255;
          buf.c_cc[0] = 0;
          buf.c_cc[1] = 0;
          buf.c_cc[2] = 0;
        }
        buf.c_lflag = v23[0];
      }
      else if ( v4 == 2 )
      {
        buf.c_ispeed = 1;
      }
      else if ( v4 == 3 )
      {
        a1 = (char **)sub_23EC4((int)a1);
        buf.c_iflag = (tcflag_t)*a1;
      }
      else
      {
        if ( v4 == 4 )
          a1 = (char **)sub_23EC4((int)a1);
        if ( v9 )
          sub_23FC4("dev", *a1);
        v9 = *a1;
      }
    }
    else
    {
      a1 = (char **)sub_23EC4((int)a1);
      sub_23D18(&dword_7D7CC, *a1, (char)buf.c_cc[23]);
      if ( !buf.c_cc[23] )
        buf.c_cc[23] = dword_7D7CC;
    }
    ++a1;
  }
  sub_22AF4(v22);
  sub_22B8C(v22, byte_7D781, 18, (int)&byte_7D781);
  sub_22BD8(v22, (int (__fastcall *)(char *, unsigned int *, int))sub_1F408, (int)&v19);
  if ( v9 )
    *(_DWORD *)&buf.c_cc[19] = sub_23574(v9);
  if ( c_ospeed )
  {
    buf.c_oflag = (tcflag_t)v23;
    v6 = 0;
    buf.c_cc[11] = 0;
    buf.c_cc[12] = 0;
    buf.c_cc[13] = 0;
    buf.c_cc[14] = 0;
    buf.c_cc[15] = 0;
    buf.c_cc[16] = 14;
    buf.c_cc[17] = 0;
    buf.c_cc[18] = 0;
    buf.c_cflag = (tcflag_t)v22;
    while ( 1 )
    {
      sub_22B8C(v22, (char)buf.c_cc[23], 22, v6);
      buf.c_ospeed = 0;
      sub_22BD8(v22, (int (__fastcall *)(char *, unsigned int *, int))sub_1F4B8, 0);
      c_ospeed = buf.c_ospeed;
      if ( !buf.c_ospeed )
        break;
      if ( sub_1F468() < 0 )
        return 1;
    }
  }
  else
  {
    if ( buf.c_cc[23] != 17 )
    {
      sub_22B8C(v22, (char)buf.c_cc[23], 22, v5);
      sub_22BD8(v22, (int (__fastcall *)(char *, unsigned int *, int))sub_1F408, (int)&v20);
    }
    v10 = buf.c_cc[23] != 17;
    if ( !buf.c_cc[23] )
      v10 = 0;
    if ( v10 )
    {
      v11 = &v19;
      v10 = *(_DWORD *)&buf.c_cc[31] != 0;
LABEL_41:
      while ( 1 )
      {
        v12 = *v11;
        if ( !*v11 )
          break;
        for ( i = v20; ; i = *(unsigned __int16 **)i )
        {
          if ( !i )
          {
            *v11 = (_DWORD *)*v12;
            goto LABEL_41;
          }
          if ( *((_DWORD *)i + 6) == v12[6]
            && (!buf.c_cc[23] || (char)buf.c_cc[23] == *((unsigned __int8 *)i + 20))
            && ((buf.c_lflag ^ *((unsigned __int8 *)i + 23)) & *(_DWORD *)&buf.c_line) == 0
            && ((*(_DWORD *)&buf.c_cc[3] ^ *((unsigned __int8 *)i + 22)) & *(_DWORD *)&buf.c_cc[7]) == 0 )
          {
            if ( !(_BYTE)dword_7D7CC && !buf.c_iflag )
              break;
            sub_23174(v23, 8, i + 14, *((_DWORD *)i + 1) - 24);
            if ( !v24 )
              v24 = (unsigned __int16 *)v23[1];
            if ( !(_BYTE)dword_7D7CC
              || !v24
              || (memset(v21, 0, sizeof(v21)),
                  v21[0] = *((_BYTE *)i + 20),
                  memcpy(&v21[4], v24 + 2, *v24 - 4),
                  !sub_23FDC((int)v21, (int)&dword_7D7CC, SHIWORD(dword_7D7CC))) )
            {
              if ( !buf.c_iflag )
                break;
              v15 = v25 ? (const char *)(v25 + 4) : sub_2350C(*((_DWORD *)i + 6));
              if ( !fnmatch((const char *)buf.c_iflag, v15, 0) )
                break;
            }
          }
        }
        v11 = (_DWORD **)v12;
      }
    }
    for ( j = v19; j; j = (_DWORD *)*j )
    {
      if ( (v10 || dword_7DBA4 || !sub_1F9AC((int)(j + 1))) && buf.c_cc[23] != 17 )
      {
        v16 = j[6];
        for ( k = v20; k; k = *(unsigned __int16 **)k )
        {
          if ( k[4] == 20 )
          {
            if ( *((_DWORD *)k + 1) <= 0x13u )
              break;
            if ( *((_DWORD *)k + 6) == v16 && (!buf.c_cc[23] || (char)buf.c_cc[23] == *((unsigned __int8 *)k + 20)) )
              sub_1F4B8(0, (int)(k + 2));
          }
        }
      }
    }
  }
  return c_ospeed;
}
// 2037C: variable 'v6' is possibly undefined
// 2050C: variable 'v5' is possibly undefined
// 7D781: using guessed type char byte_7D781;
// 7D7CC: using guessed type int dword_7D7CC;
// 7DBA4: using guessed type int dword_7DBA4;

//----- (00020798) --------------------------------------------------------
int __fastcall sub_20798(char **a1)
{
  const char **v1; // r4
  int v2; // r0
  int v3; // r1
  int v4; // r0
  __int16 v5; // r1

  v1 = (const char **)a1;
  if ( *a1 )
  {
    v2 = sub_168D4("add", *a1);
    v3 = v2;
    if ( v2 < 0 )
      sub_23EE8(*v1, (const char *)dword_7DB90);
    ++v1;
    if ( v2 <= 4 )
    {
      if ( v2 == 4 )
      {
        v4 = 21;
      }
      else
      {
        v4 = 20;
        if ( !v3 )
        {
          v5 = 1536;
          return sub_1FD4C(v4, v5, (char **)v1);
        }
      }
      if ( (unsigned int)(v3 - 1) > 1 )
      {
        if ( v3 == 3 )
          v5 = 1280;
        else
          v5 = 0;
      }
      else
      {
        v5 = 256;
      }
      return sub_1FD4C(v4, v5, (char **)v1);
    }
  }
  else
  {
    v3 = 2;
  }
  return sub_20204((char **)v1, v3 == 8);
}
// 7DB90: using guessed type int dword_7DB90;

//----- (00020840) --------------------------------------------------------
int sub_20840()
{
  int result; // r0

  result = socket(2, 2, 0);
  if ( result < 0 )
  {
    result = socket(17, 2, 0);
    if ( result < 0 )
      return sub_179A4(10, 2, 0);
  }
  return result;
}

//----- (00020888) --------------------------------------------------------
int __fastcall sub_20888(const char *a1, int a2)
{
  int result; // r0
  int src; // [sp+Ch] [bp-44Ch] BYREF
  int v5[9]; // [sp+14h] [bp-444h] BYREF
  size_t s[264]; // [sp+38h] [bp-420h] BYREF

  src = a2;
  memset(s, 0, sizeof(s));
  s[0] = 32;
  s[1] = 65552;
  LOBYTE(s[4]) = byte_7D781;
  sub_22AF4(v5);
  s[5] = sub_23574(a1);
  sub_230B4(s, 1056, 10, &src, 4u);
  result = sub_22DD4(v5, (int)s, 0);
  if ( result < 0 )
    sub_16E08();
  return result;
}
// 7D781: using guessed type char byte_7D781;

//----- (00020924) --------------------------------------------------------
int __fastcall sub_20924(char **a1, int a2)
{
  char *v4; // r8
  char *v5; // r5
  char *v6; // r9
  char *v7; // r7
  int v8; // r0
  char **v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  size_t n; // r0
  char *v14; // r7
  const char *v15; // r1
  const char *v16; // r0
  int v17; // r10
  const char **v18; // r0
  char *v19; // r2
  const char **v20; // r4
  const char *v21; // r0
  size_t v22; // r0
  char *v24; // r1
  int v25; // r0
  __int16 v26; // r3
  int v27; // r0
  char *v28; // r1
  unsigned int v29; // r3
  int v30; // r3
  unsigned int v31; // r3
  unsigned int v32; // r3
  unsigned int v33; // r3
  _DWORD *v34; // r0
  signed int v35; // r0
  const char *v36; // [sp+Ch] [bp-478h]
  size_t v37; // [sp+10h] [bp-474h]
  size_t v38; // [sp+14h] [bp-470h]
  __int16 src; // [sp+18h] [bp-46Ch] BYREF
  __int16 v40; // [sp+1Ah] [bp-46Ah] BYREF
  int v41; // [sp+1Ch] [bp-468h] BYREF
  int v42; // [sp+20h] [bp-464h]
  int v43[9]; // [sp+3Ch] [bp-448h] BYREF
  size_t s[265]; // [sp+60h] [bp-424h] BYREF

  memset(s, 0, 0x420u);
  v4 = 0;
  s[0] = 32;
  HIWORD(s[1]) = 1;
  v5 = 0;
  v6 = 0;
  LOWORD(s[1]) = a2;
  v36 = 0;
  LOBYTE(s[4]) = byte_7D781;
  if ( a2 == 16 )
    HIWORD(s[1]) = 1537;
  while ( 1 )
  {
    v7 = *a1;
    if ( !*a1 )
      break;
    v8 = sub_168D4("link", *a1);
    if ( v8 == 2 )
    {
      v9 = (char **)sub_23EC4((int)a1);
      v7 = *v9;
      a1 = v9 + 1;
      break;
    }
    if ( v8 )
    {
      if ( v8 == 1 )
      {
        a1 = (char **)sub_23EC4((int)a1);
        v6 = *a1;
      }
      else if ( v8 == 4 )
      {
        a1 = (char **)sub_23EC4((int)a1);
        v4 = *a1;
      }
      else
      {
        if ( v8 == 3 )
        {
          if ( v5 )
            sub_23FAC(*a1, "dev");
          a1 = (char **)sub_23EC4((int)a1);
        }
        v5 = *a1;
      }
    }
    else
    {
      a1 = (char **)sub_23EC4((int)a1);
      v36 = *a1;
    }
    ++a1;
  }
  sub_22AF4(v43);
  sub_23598(v43, v10, v11, v12);
  if ( v7 )
  {
    v37 = (s[0] + 3) & 0xFFFFFFFC;
    sub_230B4(s, 1056, 18, 0, 0);
    n = strlen(v7);
    sub_230B4(s, 1056, 1, v7, n);
    if ( *a1 )
    {
      v38 = (s[0] + 3) & 0xFFFFFFFC;
      sub_230B4(s, 1056, 2, 0, 0);
      if ( !strcmp(v7, "vlan") )
      {
        v41 = 0;
        v42 = 0;
        while ( 1 )
        {
          if ( !*a1 )
          {
            if ( v42 )
              sub_230B4(s, 1056, 2, &v41, 8u);
            goto LABEL_34;
          }
          v17 = sub_168D4("id", *a1);
          if ( v17 < 0 )
          {
            v15 = "type vlan";
            v16 = *a1;
            goto LABEL_27;
          }
          v18 = (const char **)sub_23EC4((int)a1);
          v20 = v18;
          if ( !v17 )
          {
            src = sub_23F4C(*v18, "id", v19);
            sub_230B4(s, 1056, 1, &src, 2u);
            goto LABEL_30;
          }
          v24 = (char *)*v18;
          if ( v17 == 5 )
          {
            v25 = sub_168D4("802.1q", v24);
            if ( v25 )
            {
              if ( v25 != 1 )
                sub_16DBC("unknown VLAN encapsulation protocol '%s'", *v20);
              v26 = -30552;
            }
            else
            {
              v26 = -32512;
            }
            v40 = v26;
            sub_230B4(s, 1056, 5, &v40, 2u);
          }
          else
          {
            v27 = sub_16880("on", v24);
            if ( v27 < 0 )
            {
              v28 = sub_16964("id", v17);
              sub_16DBC("argument of \"%s\" must be \"on\" or \"off\"", v28);
            }
            switch ( v17 )
            {
              case 1:
                v29 = v41 & 0xFFFFFFFE;
                v41 &= ~1u;
                v42 |= 1u;
                if ( !v27 )
                {
                  v30 = v29 | 1;
LABEL_60:
                  v41 = v30;
                }
                break;
              case 2:
                v31 = v41 & 0xFFFFFFFD;
                v41 &= ~2u;
                v42 |= 2u;
                if ( !v27 )
                {
                  v30 = v31 | 2;
                  goto LABEL_60;
                }
                break;
              case 3:
                v32 = v41 & 0xFFFFFFF7;
                v41 &= ~8u;
                v42 |= 8u;
                if ( !v27 )
                {
                  v30 = v32 | 8;
                  goto LABEL_60;
                }
                break;
              default:
                v33 = v41 & 0xFFFFFFFB;
                v42 |= 4u;
                v41 &= ~4u;
                if ( !v27 )
                {
                  v30 = v33 | 4;
                  goto LABEL_60;
                }
                break;
            }
          }
LABEL_30:
          a1 = (char **)(v20 + 1);
        }
      }
      if ( !strcmp(v7, "vrf") )
      {
        v14 = *a1;
        if ( strcmp(*a1, "table") )
        {
          v15 = "type vrf";
          v16 = v14;
          goto LABEL_27;
        }
        v34 = (_DWORD *)sub_23EC4((int)a1);
        v41 = sub_23F48(*v34, "table");
        sub_230B4(s, 1056, 1, &v41, 4u);
      }
LABEL_34:
      *(_WORD *)((char *)s + v38) = ((LOWORD(s[0]) + 3) & 0xFFFC) - v38;
    }
    *(_WORD *)((char *)s + v37) = ((LOWORD(s[0]) + 3) & 0xFFFC) - v37;
  }
  if ( a2 == 16 )
  {
    if ( v6 )
      v5 = v6;
    if ( v36 )
    {
      v41 = sub_23574(v36);
      sub_230B4(s, 1056, 5, &v41, 4u);
    }
    if ( v4 )
    {
      v35 = sub_232C0(&v41, 32, v4);
      if ( v35 < 0 )
        return -1;
      sub_230B4(s, 1056, 1, &v41, v35);
    }
  }
  else
  {
    if ( !v5 )
      return 1;
    v21 = v5;
    v5 = v6;
    s[5] = sub_23574(v21);
  }
  if ( v5 )
  {
    v22 = strlen(v5);
    if ( v22 - 1 > 0xE )
    {
      v15 = "name";
      v16 = v5;
LABEL_27:
      sub_23EE8(v16, v15);
    }
    sub_230B4(s, 1056, 3, v5, v22 + 1);
  }
  if ( sub_22DD4(v43, (int)s, 0) < 0 )
    return 2;
  else
    return 0;
}
// 209C8: variable 'v10' is possibly undefined
// 209C8: variable 'v11' is possibly undefined
// 209C8: variable 'v12' is possibly undefined
// 20B70: variable 'v19' is possibly undefined
// 23F48: using guessed type int __fastcall sub_23F48(_DWORD, _DWORD);
// 7D781: using guessed type char byte_7D781;

//----- (00020E98) --------------------------------------------------------
int __fastcall sub_20E98(char **a1)
{
  const char **v1; // r11
  int v2; // r0
  int v3; // r1
  unsigned int v5; // r0
  unsigned int v6; // r8
  int v7; // r5
  int v8; // r4
  const char **v9; // r0
  const char *v10; // r7
  const char **v11; // r0
  char *v12; // r2
  const char *v13; // r1
  const char *v14; // r0
  const char **v15; // r0
  char *v16; // r2
  unsigned int v17; // r10
  int v18; // r9
  int v19; // r0
  const char *v20; // r1
  const char *v21; // r6
  int v22; // r11
  int v23; // r11
  int v24; // r1
  int v25; // r0
  int v26; // r8
  int v27; // r6
  int v28; // r0
  int v29; // r7
  int v30; // r7
  int v31; // r6
  unsigned int v32; // [sp+4h] [bp-50h]
  char *v33; // [sp+8h] [bp-4Ch]
  int v34; // [sp+Ch] [bp-48h]
  struct sockaddr s[2]; // [sp+10h] [bp-44h] BYREF
  _DWORD v36[9]; // [sp+30h] [bp-24h] BYREF

  v1 = (const char **)a1;
  byte_7D5F8 = 2;
  if ( !*a1 )
    goto LABEL_11;
  v2 = sub_168D4("add", *a1);
  if ( v2 < 0 )
    sub_23EE8(*v1, (const char *)dword_7DB90);
  ++v1;
  if ( v2 <= 1 )
  {
    if ( v2 )
      v3 = 17;
    else
      v3 = 16;
    return sub_20924((char **)v1, v3);
  }
  if ( v2 != 2 )
  {
LABEL_11:
    byte_7D781 = 17;
    return sub_20204((char **)v1, 0);
  }
  v10 = 0;
  v18 = -1;
  v33 = 0;
  v17 = -1;
  v32 = -1;
  v8 = 0;
  v7 = 0;
  v21 = 0;
  while ( *v1 )
  {
    v5 = sub_168D4("up", (char *)*v1);
    v6 = v5;
    if ( v5 )
    {
      switch ( v5 )
      {
        case 1u:
          v7 |= 1u;
          v8 &= ~1u;
          break;
        case 2u:
          v9 = (const char **)sub_23EC4((int)v1);
          v10 = *v9;
          v1 = v9;
          break;
        case 3u:
          v11 = (const char **)sub_23EC4((int)v1);
          v1 = v11;
          if ( v32 != -1 )
          {
            v13 = *v11;
            v14 = "mtu";
            goto LABEL_25;
          }
          v32 = sub_23F00(*v11, "mtu", v12);
          break;
        case 4u:
          v15 = (const char **)sub_23EC4((int)v1);
          v1 = v15;
          if ( v17 != -1 )
          {
            v13 = *v15;
            v14 = "qlen";
LABEL_25:
            sub_23FAC(v14, v13);
          }
          v17 = sub_23F00(*v15, "qlen", v16);
          break;
        case 8u:
          v1 = (const char **)sub_23EC4((int)v1);
          v33 = (char *)*v1;
          break;
        case 9u:
          v1 = (const char **)sub_23EC4((int)v1);
          v18 = sub_23574(*v1);
          break;
        case 0xAu:
          v18 = 0;
          break;
        default:
          if ( v5 > 0xA )
          {
            if ( v5 == 11 )
              v1 = (const char **)sub_23EC4((int)v1);
            if ( v21 )
              sub_23FC4("dev", *v1);
            v21 = *v1;
          }
          else
          {
            v1 = (const char **)sub_23EC4((int)v1);
            v19 = sub_16880("on", (char *)*v1);
            switch ( v6 )
            {
              case 5u:
                if ( v19 < 0 )
                {
                  v20 = "multicast";
                  goto LABEL_45;
                }
                v7 |= 0x1000u;
                if ( v19 )
                  v8 &= ~0x1000u;
                else
                  v8 |= 0x1000u;
                break;
              case 6u:
                if ( v19 < 0 )
                {
                  v20 = "arp";
                  goto LABEL_45;
                }
                v7 |= 0x80u;
                if ( v19 )
                  v8 |= 0x80u;
                else
                  v8 &= ~0x80u;
                break;
              case 7u:
                if ( v19 < 0 )
                {
                  v20 = "promisc";
LABEL_45:
                  sub_16DBC("argument of \"%s\" must be \"on\" or \"off\"", v20);
                }
                v7 |= 0x100u;
                if ( v19 )
                  v8 &= ~0x100u;
                else
                  v8 |= 0x100u;
                break;
            }
          }
          break;
      }
    }
    else
    {
      v7 |= 1u;
      v8 |= 1u;
    }
    ++v1;
  }
  if ( !v21 )
    sub_16DBC("%s requires an argument", "\"dev\"");
  if ( v33 )
  {
    v22 = sub_179A4(17, 2, (int)*v1);
    sub_16EA8((char *)v36, v21);
    sub_17B18(v22, 0x8933u, (int)v36, "SIOCGIFINDEX");
    *(_DWORD *)&s[0].sa_data[6] = 0;
    *(_DWORD *)&s[0].sa_data[2] = v36[4];
    *(_DWORD *)&s[0].sa_data[10] = 0;
    *(_DWORD *)&s[1].sa_family = 0;
    *(_DWORD *)&s[0].sa_family = 1610612753;
    sub_179C0(v22, s, 0x14u);
    sub_57A54(v22, s, 0x14u);
    close(v22);
    v23 = (unsigned __int8)s[0].sa_data[9];
    v34 = *(unsigned __int16 *)&s[0].sa_data[6];
    memset(s, 0, sizeof(s));
    sub_16EA8((char *)s, v21);
    s[1].sa_family = v34;
    if ( v34 == 1 )
      v24 = 14;
    else
      v24 = 19;
    v25 = sub_232C0(s[1].sa_data, v24, v33);
    if ( v25 < 0 )
      exit(1);
    if ( v25 != v23 )
      sub_16DBC("wrong address (%s) length: expected %d bytes", v33, v23);
    v26 = sub_20840();
    sub_17B18(v26, 0x8924u, (int)s, "SIOCSIFHWADDR");
    close(v26);
  }
  if ( v10 && strcmp(v21, v10) )
  {
    sub_16EA8((char *)v36, v21);
    sub_16EA8((char *)&v36[4], v10);
    v27 = sub_20840();
    sub_17B18(v27, 0x8923u, (int)v36, "SIOCSIFNAME");
    v28 = v27;
    v21 = v10;
    close(v28);
  }
  if ( v17 != -1 )
  {
    v29 = sub_20840();
    memset(v36, 0, 0x20u);
    sub_16EA8((char *)v36, v21);
    v36[4] = v17;
    sub_17B18(v29, 0x8943u, (int)v36, "SIOCSIFTXQLEN");
    close(v29);
  }
  if ( v32 != -1 )
  {
    v30 = sub_20840();
    memset(v36, 0, 0x20u);
    sub_16EA8((char *)v36, v21);
    v36[4] = v32;
    sub_17B18(v30, 0x8922u, (int)v36, "SIOCSIFMTU");
    close(v30);
  }
  if ( v18 != -1 )
    sub_20888(v21, v18);
  if ( v7 )
  {
    sub_16EA8((char *)v36, v21);
    v31 = sub_20840();
    sub_17B18(v31, 0x8913u, (int)v36, "SIOCGIFFLAGS");
    if ( ((SLOWORD(v36[4]) ^ v8) & v7) != 0 )
    {
      LOWORD(v36[4]) ^= (unsigned __int16)v7 & (v8 ^ LOWORD(v36[4]));
      sub_17B18(v31, 0x8914u, (int)v36, "SIOCSIFFLAGS");
    }
    close(v31);
  }
  return 0;
}
// 20FC4: variable 'v12' is possibly undefined
// 20FFC: variable 'v16' is possibly undefined
// 7D5F8: using guessed type char byte_7D5F8;
// 7D781: using guessed type char byte_7D781;
// 7DB90: using guessed type int dword_7DB90;

//----- (00021434) --------------------------------------------------------
_BYTE *sub_21434()
{
  _BYTE *result; // r0

  result = memset(&buf, 0, 0x8Cu);
  result[82] = -1;
  result[83] = -1;
  result[122] = -1;
  result[123] = -1;
  return result;
}

//----- (00021468) --------------------------------------------------------
int sub_21468()
{
  if ( sub_22B54(*(int **)&buf.c_cc[3], (const void *)buf.c_cflag, buf.c_lflag) >= 0 )
  {
    buf.c_lflag = 0;
    return 0;
  }
  else
  {
    sub_16AF4("can't send flush request");
    return -1;
  }
}

//----- (000214B8) --------------------------------------------------------
int __fastcall sub_214B8(int a1, int *a2)
{
  int v2; // r3
  int v4; // r2
  bool v6; // zf
  int v7; // r7
  int v8; // r2
  int v9; // r6
  int v10; // r8
  size_t v11; // r2
  size_t v12; // r2
  bool v13; // zf
  _DWORD *v14; // r0
  int v15; // r2
  signed int v16; // r0
  char *v17; // r0
  int v18; // r0
  const void *v19; // r1
  const char *v20; // r0
  int v21; // r0
  int v22; // r2
  int v23; // r0
  const void *v24; // r1
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  int v29; // r1
  const char *v30; // r0
  int v31; // r5
  int v32; // r1
  const char *v33; // r0
  const char *v34; // r1
  const char *v35; // r1
  unsigned int v36; // r4
  unsigned int v37; // r0
  unsigned int v38; // r0
  int v39; // r2
  _WORD v40[10]; // [sp+8h] [bp-90h] BYREF
  _WORD s[10]; // [sp+1Ch] [bp-7Ch] BYREF
  _BYTE v42[4]; // [sp+30h] [bp-68h] BYREF
  int v43; // [sp+34h] [bp-64h]
  int v44; // [sp+38h] [bp-60h]
  int v45; // [sp+3Ch] [bp-5Ch]
  int v46; // [sp+40h] [bp-58h]
  int v47; // [sp+44h] [bp-54h]
  int v48; // [sp+48h] [bp-50h]
  int v49; // [sp+4Ch] [bp-4Ch]
  int v50; // [sp+60h] [bp-38h]
  int v51; // [sp+6Ch] [bp-2Ch]

  v2 = *((unsigned __int16 *)a2 + 2);
  v4 = *a2;
  if ( (unsigned int)(v2 - 24) > 1 )
  {
    fprintf((FILE *)stderr, "Not a route: %08x %08x %08x\n", v4, v2, *((unsigned __int16 *)a2 + 3));
    return 0;
  }
  v6 = buf.c_cflag == 0;
  if ( buf.c_cflag )
    v6 = v2 == 24;
  if ( v6 )
  {
    if ( v4 - 28 < 0 )
      sub_16DBC("wrong nlmsg len %d", v4 - 28);
    sub_23174(v42, 25, (unsigned __int16 *)a2 + 14, v4 - 28);
    v7 = *((unsigned __int8 *)a2 + 16);
    if ( v51 )
      v8 = *(_DWORD *)(v51 + 4);
    else
      v8 = *((unsigned __int8 *)a2 + 20);
    if ( v7 != 10 )
    {
      if ( v7 == 2 )
        v9 = 32;
      else
        v9 = -1;
      if ( (int)buf.c_iflag > 0 && buf.c_iflag != v8 )
        return 0;
LABEL_18:
      if ( ((*(_DWORD *)&buf.c_cc[7] ^ *((unsigned __int8 *)a2 + 22)) & *(_DWORD *)&buf.c_cc[11]) != 0 )
        return 0;
      v10 = (unsigned __int8)dword_7D7CC;
      if ( (_BYTE)dword_7D7CC )
      {
        if ( v7 != (unsigned __int8)dword_7D7CC || SHIWORD(dword_7D7CC) > (int)*((unsigned __int8 *)a2 + 17) )
          return 0;
      }
      if ( (_BYTE)dword_7D7E0
        && (v7 != (unsigned __int8)dword_7D7E0
         || dword_7D7E0 >= 0 && SHIWORD(dword_7D7E0) < (int)*((unsigned __int8 *)a2 + 17))
        || byte_7D7F4 && (v7 != (unsigned __int8)byte_7D7F4 || word_7D7F6 > (int)*((unsigned __int8 *)a2 + 18))
        || (_BYTE)dword_7D808
        && (v7 != (unsigned __int8)dword_7D808
         || dword_7D808 >= 0 && SHIWORD(dword_7D808) < (int)*((unsigned __int8 *)a2 + 18)) )
      {
        return 0;
      }
      memset(s, 0, sizeof(s));
      memset(v40, 0, sizeof(v40));
      if ( v44 )
      {
        if ( v7 == 10 )
          v11 = 16;
        else
          v11 = 4;
        s[1] = *((unsigned __int8 *)a2 + 18);
        HIBYTE(s[0]) = v11;
        memcpy(&s[2], (const void *)(v44 + 4), v11);
      }
      if ( v43 )
      {
        if ( v7 == 10 )
          v12 = 16;
        else
          v12 = 4;
        v40[1] = *((unsigned __int8 *)a2 + 17);
        HIBYTE(v40[0]) = v12;
        memcpy(&v40[2], (const void *)(v43 + 4), v12);
      }
      if ( v10 && sub_23FDC((int)v40, (int)&dword_7D7CC, SHIWORD(dword_7D7CC))
        || (_BYTE)dword_7D7E0
        && dword_7D7E0 >= 0
        && sub_23FDC((int)v40, (int)&dword_7D7E0, *((unsigned __int8 *)a2 + 17))
        || byte_7D7F4 && sub_23FDC((int)s, (int)&byte_7D7F4, word_7D7F6)
        || (_BYTE)dword_7D808 && dword_7D808 >= 0 && sub_23FDC((int)s, (int)&dword_7D808, *((unsigned __int8 *)a2 + 18))
        || *(_DWORD *)&buf.c_cc[19] && (!v46 || *(_DWORD *)&buf.c_cc[19] != *(_DWORD *)(v46 + 4)) )
      {
        return 0;
      }
      if ( buf.c_cflag )
      {
        if ( *((_WORD *)a2 + 8) != 10 || *((_BYTE *)a2 + 23) != 7 || !v48 || *(_DWORD *)(v48 + 4) != -1 )
        {
          if ( ((buf.c_lflag + 3) & 0xFFFFFFFC) + *a2 > *(_DWORD *)&buf.c_line && sub_21468() )
            sub_16E08();
          v14 = memcpy((void *)(buf.c_cflag + ((buf.c_lflag + 3) & 0xFFFFFFFC)), a2, *a2);
          v14[1] = 65561;
          v15 = *(_DWORD *)(*(_DWORD *)&buf.c_cc[3] + 28) + 1;
          *(_DWORD *)(*(_DWORD *)&buf.c_cc[3] + 28) = v15;
          v14[2] = v15;
          buf.c_lflag = (tcflag_t)v14 + *a2 - buf.c_cflag;
          buf.c_oflag = 1;
        }
        return 0;
      }
      if ( *((_WORD *)a2 + 2) == 25 )
        printf("Deleted ");
      v16 = *((unsigned __int8 *)a2 + 23);
      if ( v16 != 1 )
      {
        v17 = sub_238F8(v16);
        printf("%s ", v17);
      }
      if ( v43 )
      {
        v18 = *((unsigned __int8 *)a2 + 16);
        v19 = (const void *)(v43 + 4);
        if ( *((unsigned __int8 *)a2 + 17) == v9 )
        {
          v34 = sub_24048(v18, v19);
          v21 = printf("%s ", v34);
        }
        else
        {
          v20 = sub_24048(v18, v19);
          v21 = printf("%s/%u ", v20, *((unsigned __int8 *)a2 + 17));
        }
      }
      else if ( *((_BYTE *)a2 + 17) )
      {
        v21 = printf("0/%d ", *((unsigned __int8 *)a2 + 17));
      }
      else
      {
        v21 = printf("default ");
      }
      v22 = *((unsigned __int8 *)a2 + 18);
      if ( v44 )
      {
        v23 = *((unsigned __int8 *)a2 + 16);
        v24 = (const void *)(v44 + 4);
        if ( v22 == v9 )
        {
          v35 = sub_24048(v23, v24);
          v21 = printf("from %s ", v35);
        }
        else
        {
          v25 = sub_24048(v23, v24);
          v21 = printf("from %s/%u ", v25, *((unsigned __int8 *)a2 + 18));
        }
      }
      else if ( *((_BYTE *)a2 + 18) )
      {
        v21 = printf("from 0/%u ", *((unsigned __int8 *)a2 + 18));
      }
      if ( v47 && *(__int16 *)&buf.c_cc[25] != v9 )
      {
        v26 = sub_24048(*((unsigned __int8 *)a2 + 16), (const void *)(v47 + 4));
        v21 = printf("via %s ", v26);
      }
      if ( v46 )
      {
        v27 = sub_2350C(*(_DWORD *)(v46 + 4));
        v21 = printf("dev %s ", v27);
      }
      if ( (a2[6] & 0x200) == 0 )
      {
        v21 = *((unsigned __int8 *)a2 + 22);
        if ( *((_BYTE *)a2 + 22) )
        {
          if ( *(_DWORD *)&buf.c_cc[11] != -1 )
          {
            v28 = sub_23888(v21);
            v21 = printf("scope %s ", v28);
          }
        }
      }
      v29 = v49;
      if ( v49 )
      {
        v30 = sub_24048(*((unsigned __int8 *)a2 + 16), (const void *)(v49 + 4));
        v21 = printf(" src %s ", v30);
      }
      if ( v48 )
        v21 = printf(" metric %d ", *(_DWORD *)(v48 + 4));
      if ( (a2[6] & 1) != 0 )
        v21 = printf("dead ");
      if ( (a2[6] & 4) != 0 )
        v21 = printf("onlink ");
      if ( (a2[6] & 2) != 0 )
        v21 = printf("pervasive ");
      if ( (a2[6] & 0x100) != 0 )
        v21 = printf("notify ");
      if ( *((_BYTE *)a2 + 16) == 10 )
      {
        v31 = v50;
        if ( v50 )
          v31 = v50 + 4;
        if ( (a2[6] & 0x200) != 0 )
        {
          v21 = printf("%c    cache ", (unsigned __int8)byte_7DBA8);
          goto LABEL_129;
        }
        if ( v31 )
        {
          if ( !*(_DWORD *)(v31 + 8) )
          {
LABEL_115:
            v32 = *(_DWORD *)(v31 + 12);
            if ( v32 )
              printf(" error %d", v32);
            goto LABEL_117;
          }
LABEL_129:
          v36 = *(_DWORD *)(v31 + 8);
          if ( v36 )
          {
            v37 = sub_23ADC(v21, v29, v22);
            v38 = sub_15CA0(v36, v37);
            printf(" expires %dsec", v38);
          }
          goto LABEL_115;
        }
      }
LABEL_117:
      if ( v45 && !*(_DWORD *)&buf.c_cc[15] )
      {
        v33 = sub_2350C(*(_DWORD *)(v45 + 4));
        printf(" iif %s", v33);
      }
      j_putchar_unlocked(10);
      return 0;
    }
    if ( buf.c_iflag )
    {
      v39 = a2[6] & 0x200;
      if ( (buf.c_iflag & 0x80000000) == 0 )
      {
        if ( v39 )
          return 0;
        if ( buf.c_iflag == 255 )
        {
          if ( *((_BYTE *)a2 + 23) != 2 )
            return 0;
          goto LABEL_59;
        }
        if ( buf.c_iflag != 254 )
          return 0;
        v13 = *((_BYTE *)a2 + 23) == 2;
      }
      else
      {
        v13 = v39 == 0;
      }
      if ( v13 )
        return 0;
    }
LABEL_59:
    v9 = 128;
    goto LABEL_18;
  }
  return 0;
}
// 219C0: conditional instruction was optimized away because r6.4 is in (==20|==80|==FFFFFFFF)
// 21B44: variable 'v29' is possibly undefined
// 21B44: variable 'v22' is possibly undefined
// 7D608: using guessed type int stderr;
// 7D7CC: using guessed type int dword_7D7CC;
// 7D7E0: using guessed type int dword_7D7E0;
// 7D7F4: using guessed type char byte_7D7F4;
// 7D7F6: using guessed type __int16 word_7D7F6;
// 7D808: using guessed type int dword_7D808;
// 7DBA8: using guessed type char byte_7DBA8;

//----- (00021C00) --------------------------------------------------------
int __fastcall sub_21C00(const char **a1)
{
  int v2; // r5
  int v3; // r8
  __int64 v4; // r6
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r0
  size_t v9; // r4
  int v10; // r0
  _WORD *v11; // r3
  int v13[9]; // [sp+8h] [bp-4ACh] BYREF
  char v14; // [sp+2Ch] [bp-488h] BYREF
  unsigned __int8 src; // [sp+2Dh] [bp-487h]
  char src_1; // [sp+2Eh] [bp-486h]
  _DWORD src_3[2]; // [sp+30h] [bp-484h] BYREF
  int v18; // [sp+38h] [bp-47Ch]
  int v19; // [sp+3Ch] [bp-478h]
  int v20; // [sp+40h] [bp-474h]
  _WORD *v21; // [sp+48h] [bp-46Ch]
  size_t s[264]; // [sp+94h] [bp-420h] BYREF

  v2 = 0;
  memset(s, 0, 0x41Cu);
  sub_21434();
  v3 = 0;
  v4 = 0;
  s[0] = 28;
  s[1] = 65562;
  LOBYTE(s[4]) = byte_7D781;
  while ( *a1 )
  {
    switch ( sub_16880("from", (char *)*a1) )
    {
      case 0:
        a1 = (const char **)sub_23EC4((int)a1);
        sub_23D18(&v14, *a1, LOBYTE(s[4]));
        if ( !LOBYTE(s[4]) )
          LOBYTE(s[4]) = v14;
        if ( src )
          sub_230B4(s, 1052, 2, src_3, src);
        v2 = 1;
        BYTE2(s[4]) = src_1;
        break;
      case 1:
        a1 = (const char **)sub_23EC4((int)a1);
        LODWORD(v4) = *a1;
        break;
      case 2:
      case 3:
        a1 = (const char **)sub_23EC4((int)a1);
        HIDWORD(v4) = *a1;
        break;
      case 4:
        s[6] |= 0x100u;
        break;
      case 5:
        v3 = 1;
        break;
      case 6:
        a1 = (const char **)sub_23EC4((int)a1);
        goto LABEL_25;
      default:
LABEL_25:
        sub_23D18(&v14, *a1, LOBYTE(s[4]));
        if ( !LOBYTE(s[4]) )
          LOBYTE(s[4]) = v14;
        if ( src )
          sub_230B4(s, 1052, 1, src_3, src);
        BYTE1(s[4]) = src_1;
        break;
    }
    ++a1;
  }
  if ( !BYTE1(s[4]) )
    sub_16DBC("need at least destination address");
  sub_22AF4(v13);
  sub_23598(v13, v5, v6, v7);
  if ( v4 )
  {
    if ( !(_DWORD)v4 || (v10 = sub_23574((const char *)v4), sub_23060(s, 1052, 3, v10), HIDWORD(v4)) )
    {
      v8 = sub_23574((const char *)HIDWORD(v4));
      sub_23060(s, 1052, 4, v8);
    }
  }
  if ( !LOBYTE(s[4]) )
    LOBYTE(s[4]) = 2;
  if ( sub_22DD4(v13, (int)s, s) < 0 )
    return 2;
  if ( (v3 & (v2 ^ 1)) != 0 )
  {
    v9 = s[0];
    sub_214B8(0, (int *)s);
    if ( LOWORD(s[1]) != 24 )
      sub_16DBC("not a route?");
    if ( (int)(v9 - 28) < 0 )
      sub_16DBC("wrong len %d", v9 - 28);
    sub_23174(&v14, 25, (unsigned __int16 *)&s[7], v9 - 28);
    v11 = v21;
    if ( v21 )
    {
      v21[1] = 2;
      BYTE2(s[4]) = 8 * (*v11 - 4);
    }
    else if ( !src_3[1] )
    {
      sub_16DBC("can't connect the route");
    }
    if ( !HIDWORD(v4) && v19 )
      *(_WORD *)(v19 + 2) = 0;
    if ( v20 )
      *(_WORD *)(v20 + 2) = 0;
    if ( !(_DWORD)v4 )
    {
      if ( v18 )
        *(_WORD *)(v18 + 2) = 0;
    }
    s[1] = 65562;
    if ( sub_22DD4(v13, (int)s, s) < 0 )
      return 2;
  }
  sub_214B8(0, (int *)s);
  return 0;
}
// 21D18: control flows out of bounds to 21D1C
// 21C78: variable 'v5' is possibly undefined
// 21C78: variable 'v6' is possibly undefined
// 21C78: variable 'v7' is possibly undefined
// 7D781: using guessed type char byte_7D781;

//----- (00021F58) --------------------------------------------------------
int __fastcall sub_21F58(char **a1, int a2)
{
  const char *v2; // r7
  tcflag_t c_iflag; // r5
  int v6; // r0
  const char *v7; // r1
  const char *v8; // r0
  const char **v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  bool v13; // zf
  _BOOL4 v14; // r2
  int v15; // r3
  const char *v17; // r8
  const char *v18; // r1
  int *v19; // r0
  int v20; // r2
  int v21; // r0
  char v22; // r2
  int v23; // r0
  const char **v24; // r0
  const char **v25; // r0
  int *v26; // r2
  char *v27; // r1
  int v28; // t1
  const char **v29; // r0
  const char **v30; // r0
  char *v31; // r2
  int *v32; // r1
  int v33; // t1
  int v34; // r0
  int v35; // r7
  char *v36; // [sp+8h] [bp-E3Ch]
  struct sockaddr v37[2]; // [sp+10h] [bp-E34h] BYREF
  unsigned int v38; // [sp+38h] [bp-E0Ch]
  unsigned int v39; // [sp+3Ch] [bp-E08h]
  unsigned int v40[896]; // [sp+40h] [bp-E04h] BYREF

  v2 = 0;
  c_iflag = byte_7D781;
  sub_21434();
  buf.c_iflag = 254;
  if ( a2 )
  {
    if ( !*a1 )
      sub_16DBC("%s requires an argument", "\"ip route flush\"");
    v17 = 0;
  }
  else
  {
    v2 = 0;
    v17 = 0;
  }
  while ( *a1 )
  {
    v6 = sub_168D4("protocol", *a1);
    if ( v6 )
    {
      if ( (unsigned int)(v6 - 1) <= 1 )
      {
        v9 = (const char **)sub_23EC4((int)a1);
        v2 = *v9;
        a1 = (char **)v9;
        goto LABEL_12;
      }
      if ( v6 == 3 )
      {
        a1 = (char **)sub_23EC4((int)a1);
        v17 = *a1;
        goto LABEL_12;
      }
      if ( v6 == 4 )
      {
        a1 = (char **)sub_23EC4((int)a1);
        v18 = *a1;
        v19 = (int *)&buf.c_cc[23];
        v20 = c_iflag;
LABEL_34:
        sub_23D18(v19, v18, v20);
        goto LABEL_12;
      }
      if ( v6 == 5 )
      {
        a1 = (char **)sub_23EC4((int)a1);
        v21 = sub_168D4("protocol", *a1);
        if ( v21 == 6 )
          goto LABEL_37;
        if ( v21 == 10 )
        {
          v22 = 0;
          goto LABEL_40;
        }
        if ( v21 != 14 )
        {
          v7 = "table";
LABEL_8:
          v8 = *a1;
LABEL_9:
          sub_23EE8(v8, v7);
        }
      }
      else
      {
        if ( v6 == 6 )
        {
LABEL_37:
          v22 = -1;
LABEL_40:
          LOBYTE(buf.c_iflag) = v22;
          BYTE1(buf.c_iflag) = v22;
          BYTE2(buf.c_iflag) = v22;
          HIBYTE(buf.c_iflag) = v22;
          goto LABEL_12;
        }
        if ( v6 == 9 )
        {
          a1 = (char **)sub_23EC4((int)a1);
          buf.c_cc[11] = -1;
          buf.c_cc[12] = -1;
          buf.c_cc[13] = -1;
          buf.c_cc[14] = -1;
          if ( sub_238C8(v40, *a1) )
          {
            v36 = *a1;
            if ( strcmp(*a1, "all") )
            {
              v7 = "scope";
              v8 = v36;
              goto LABEL_9;
            }
            v40[0] = 255;
            buf.c_cc[11] = 0;
            buf.c_cc[12] = 0;
            buf.c_cc[13] = 0;
            buf.c_cc[14] = 0;
          }
          *(_DWORD *)&buf.c_cc[7] = v40[0];
        }
        else if ( v6 == 7 )
        {
          a1 = (char **)sub_23EC4((int)a1);
          v23 = sub_168D4("protocol", *a1);
          switch ( v23 )
          {
            case 11:
              v24 = (const char **)sub_23EC4((int)a1);
              v20 = c_iflag;
              a1 = (char **)v24;
              v18 = *v24;
              v19 = (int *)&byte_7D7F4;
              goto LABEL_34;
            case 12:
              v25 = (const char **)sub_23EC4((int)a1);
              v20 = c_iflag;
              a1 = (char **)v25;
              v18 = *v25;
              v19 = &dword_7D808;
              goto LABEL_34;
            case 13:
              a1 = (char **)sub_23EC4((int)a1);
              break;
          }
          sub_23D18(&dword_7D808, *a1, c_iflag);
          v26 = &dword_7D808;
          v27 = &byte_7D7F4;
          do
          {
            v28 = *v26++;
            *(_DWORD *)v27 = v28;
            v27 += 4;
          }
          while ( v26 != &dword_7D81C );
        }
        else
        {
          if ( v6 == 8 )
          {
            a1 = (char **)sub_23EC4((int)a1);
            v6 = sub_168D4("protocol", *a1);
          }
          switch ( v6 )
          {
            case 11:
              v29 = (const char **)sub_23EC4((int)a1);
              v20 = c_iflag;
              a1 = (char **)v29;
              v18 = *v29;
              v19 = &dword_7D7CC;
              goto LABEL_34;
            case 12:
              v30 = (const char **)sub_23EC4((int)a1);
              v20 = c_iflag;
              a1 = (char **)v30;
              v18 = *v30;
              v19 = &dword_7D7E0;
              goto LABEL_34;
            case 13:
              a1 = (char **)sub_23EC4((int)a1);
              break;
          }
          sub_23D18(&dword_7D7E0, *a1, c_iflag);
          v31 = (char *)&dword_7D7E0;
          v32 = &dword_7D7CC;
          do
          {
            v33 = *(_DWORD *)v31;
            v31 += 4;
            *v32++ = v33;
          }
          while ( v31 != &byte_7D7F4 );
        }
      }
    }
    else
    {
      v40[0] = 0;
      a1 = (char **)sub_23EC4((int)a1);
      if ( sub_237F8(v40, *a1) && sub_16880("protocol", *a1) != 10 )
      {
        v7 = "protocol";
        goto LABEL_8;
      }
    }
LABEL_12:
    ++a1;
  }
  if ( !c_iflag )
  {
    c_iflag = buf.c_iflag;
    if ( buf.c_iflag )
      c_iflag = 2;
  }
  sub_22AF4((int *)&v37[0].sa_data[10]);
  sub_23598((int *)&v37[0].sa_data[10], v10, v11, v12);
  v13 = v2 == 0;
  if ( !v2 )
    v13 = v17 == 0;
  if ( !v13 )
  {
    if ( !v17 || (*(_DWORD *)&buf.c_cc[15] = sub_23574(v17), v2) )
      *(_DWORD *)&buf.c_cc[19] = sub_23574(v2);
  }
  if ( a2 )
  {
    v14 = c_iflag != 10;
    if ( buf.c_iflag != -1 )
      v14 = 0;
    if ( !v14 )
      goto LABEL_26;
    v34 = sub_1760C("/proc/sys/net/ipv4/route/flush", 1);
    v35 = v34;
    if ( v34 >= 0 )
    {
      if ( write(v34, "-1", 2u) > 1 )
        close(v35);
      else
        sub_16AF4("can't flush routing cache");
    }
    if ( c_iflag != 2 )
    {
LABEL_26:
      buf.c_cflag = (tcflag_t)v40;
      v15 = 0;
      buf.c_lflag = 0;
      buf.c_line = 0;
      buf.c_cc[0] = 14;
      buf.c_cc[1] = 0;
      buf.c_cc[2] = 0;
      *(_DWORD *)&buf.c_cc[3] = &v37[0].sa_data[10];
      while ( 1 )
      {
        sub_22B8C((int *)&v37[0].sa_data[10], c_iflag, 26, v15);
        buf.c_oflag = 0;
        sub_22BD8((int *)&v37[0].sa_data[10], (int (__fastcall *)(char *, unsigned int *, int))sub_214B8, 0);
        if ( !buf.c_oflag )
          break;
        if ( sub_21468() )
          return a2;
      }
    }
    return 0;
  }
  else
  {
    if ( buf.c_iflag == -1 )
    {
      v37[0].sa_family = 16;
      v40[0] = 28;
      v40[1] = 16842778;
      *(_DWORD *)v37[0].sa_data = 0;
      *(_DWORD *)&v37[0].sa_data[4] = 0;
      *(_WORD *)&v37[0].sa_data[8] = 0;
      v39 = ++v38;
      v40[2] = v38;
      v40[6] = 512;
      v40[3] = 0;
      v40[5] = 0;
      v40[4] = (unsigned __int8)c_iflag;
      if ( sub_179DC(*(int *)&v37[0].sa_data[10], v40, 0x1Cu, v37, 0xCu) < 0 )
        sub_16B40("can't send dump request");
    }
    else
    {
      sub_22B8C((int *)&v37[0].sa_data[10], c_iflag, 26, buf.c_iflag);
    }
    sub_22BD8((int *)&v37[0].sa_data[10], (int (__fastcall *)(char *, unsigned int *, int))sub_214B8, 0);
  }
  return a2;
}
// 22068: variable 'v10' is possibly undefined
// 22068: variable 'v11' is possibly undefined
// 22068: variable 'v12' is possibly undefined
// 220F8: variable 'v15' is possibly undefined
// 7D781: using guessed type char byte_7D781;
// 7D7CC: using guessed type int dword_7D7CC;
// 7D7E0: using guessed type int dword_7D7E0;
// 7D7F4: using guessed type char byte_7D7F4;
// 7D808: using guessed type int dword_7D808;
// 7D81C: using guessed type int dword_7D81C;

//----- (00022544) --------------------------------------------------------
int __fastcall sub_22544(int a1, __int16 a2, char **a3)
{
  int v6; // r8
  const char *v7; // r10
  int v8; // r6
  int v9; // r7
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r0
  char v14; // r3
  int v16; // r0
  char *v17; // r2
  __int16 v18; // r2
  char *v19; // r2
  unsigned int v20; // r0
  __int16 v21; // r2
  int v22; // r3
  char *v23; // r2
  unsigned int v24; // r0
  const char *v25; // r1
  int v26; // r0
  const char *v27; // r1
  unsigned int v28; // [sp+Ch] [bp-548h] BYREF
  size_t v29; // [sp+10h] [bp-544h] BYREF
  _BYTE v30[32]; // [sp+14h] [bp-540h] BYREF
  int v31; // [sp+34h] [bp-520h] BYREF
  _BYTE src[252]; // [sp+38h] [bp-51Ch] BYREF
  size_t s[264]; // [sp+134h] [bp-420h] BYREF

  memset(s, 0, 0x41Cu);
  s[0] = 28;
  v6 = 0;
  HIWORD(s[1]) = a2 | 1;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  LOWORD(s[1]) = a1;
  LOBYTE(s[4]) = byte_7D781;
  LOBYTE(s[5]) = -2;
  BYTE2(s[5]) = -1;
  if ( a1 != 25 )
  {
    *(_WORD *)((char *)&s[5] + 1) = 3;
    HIBYTE(s[5]) = 1;
  }
  v31 = 524292;
  while ( *a3 )
  {
    v16 = sub_168D4("src", *a3);
    switch ( v16 )
    {
      case 0:
        a3 = (char **)sub_23EC4((int)a3);
        sub_23CCC(&v29, *a3, LOBYTE(s[4]));
        v18 = 7;
        if ( !LOBYTE(s[4]) )
          LOBYTE(s[4]) = v29;
LABEL_25:
        sub_230B4(s, 1052, v18, v30, BYTE1(v29));
        break;
      case 1:
        v8 |= 1u;
        a3 = (char **)sub_23EC4((int)a3);
        sub_23CCC(&v29, *a3, LOBYTE(s[4]));
        v18 = 5;
        if ( !LOBYTE(s[4]) )
          LOBYTE(s[4]) = v29;
        goto LABEL_25;
      case 2:
        a3 = (char **)sub_23EC4((int)a3);
        if ( !strcmp(*a3, "lock") )
        {
          v9 |= 4u;
          a3 = (char **)sub_23EC4((int)a3);
        }
        v20 = sub_23F00(*a3, "mtu", v19);
        v21 = 2;
        v22 = v20;
LABEL_34:
        sub_23120(&v31, 0x100u, v21, v22);
        break;
      case 3:
        a3 = (char **)sub_23EC4((int)a3);
        if ( !strcmp(*a3, "lock") )
        {
          v9 |= 0x100u;
          a3 = (char **)sub_23EC4((int)a3);
        }
        v24 = sub_23F00(*a3, "advmss", v23);
        v21 = 8;
        v22 = v24;
        goto LABEL_34;
      case 4:
        a3 = (char **)sub_23EC4((int)a3);
        if ( sub_238C8(&v29, *a3) )
        {
          v25 = "scope";
          goto LABEL_43;
        }
        v6 = 1;
        BYTE2(s[5]) = v29;
        break;
      case 5:
        a3 = (char **)sub_23EC4((int)a3);
        if ( sub_237F8(&v29, *a3) )
        {
          v25 = "protocol";
LABEL_43:
          sub_23EE8(*a3, v25);
        }
        v8 |= 4u;
        BYTE1(s[5]) = v29;
        break;
      default:
        if ( (unsigned int)(v16 - 6) > 1 )
        {
          if ( v16 == 9 )
          {
            a3 = (char **)sub_23EC4((int)a3);
            v26 = sub_23F48(*a3, "metric");
            sub_23060(s, 1052, 6, v26);
          }
          else if ( v16 == 10 )
          {
            s[6] |= 4u;
          }
          else
          {
            if ( v16 == 8 )
              a3 = (char **)sub_23EC4((int)a3);
            if ( (unsigned int)(unsigned __int8)**a3 - 48 > 9 && !sub_239C8(&v28, *a3, v17) )
            {
              v8 |= 8u;
              a3 = (char **)sub_23EC4((int)a3);
              HIBYTE(s[5]) = v28;
            }
            v27 = *a3;
            if ( (v8 & 2) != 0 )
              sub_23FC4("to", v27);
            sub_23D18(&v29, v27, LOBYTE(s[4]));
            v8 |= 2u;
            if ( !LOBYTE(s[4]) )
              LOBYTE(s[4]) = v29;
            BYTE1(s[4]) = BYTE2(v29);
            if ( BYTE1(v29) )
              sub_230B4(s, 1052, 1, v30, BYTE1(v29));
          }
        }
        else
        {
          a3 = (char **)sub_23EC4((int)a3);
          v7 = *a3;
        }
        break;
    }
    ++a3;
  }
  sub_22AF4((int *)&v29);
  if ( v7 )
  {
    sub_23598((int *)&v29, v10, v11, v12);
    v13 = sub_23574(v7);
    sub_23060(s, 1052, 4, v13);
  }
  if ( (unsigned __int16)v31 > 4u )
  {
    if ( v9 )
      sub_23120(&v31, 0x100u, 1, v9);
    sub_230B4(s, 1052, 8, src, (unsigned __int16)v31 - 4);
  }
  if ( !v6 )
  {
    if ( (HIBYTE(s[5]) & 0xF7) == 2 )
    {
      v14 = -2;
      goto LABEL_16;
    }
    if ( (unsigned int)HIBYTE(s[5]) - 3 <= 2 )
    {
LABEL_15:
      v14 = -3;
      goto LABEL_16;
    }
    if ( HIBYTE(s[5]) <= 1u )
    {
      if ( a1 == 25 )
      {
        v14 = -1;
LABEL_16:
        BYTE2(s[5]) = v14;
      }
      else if ( (v8 & 1) == 0 )
      {
        goto LABEL_15;
      }
    }
  }
  if ( !LOBYTE(s[4]) )
    LOBYTE(s[4]) = 2;
  if ( sub_22DD4((int *)&v29, (int)s, 0) >= 0 )
    return 0;
  else
    return 2;
}
// 225F8: variable 'v10' is possibly undefined
// 225F8: variable 'v11' is possibly undefined
// 225F8: variable 'v12' is possibly undefined
// 227B0: variable 'v19' is possibly undefined
// 22810: variable 'v23' is possibly undefined
// 22938: variable 'v17' is possibly undefined
// 23F48: using guessed type int __fastcall sub_23F48(_DWORD, _DWORD);
// 7D781: using guessed type char byte_7D781;

//----- (000229FC) --------------------------------------------------------
int __fastcall sub_229FC(char **a1)
{
  int v1; // r1
  char **v3; // r4
  int v4; // r0
  __int16 v5; // r1

  v1 = (int)*a1;
  if ( *a1 )
  {
    v3 = a1;
    switch ( sub_168D4("a", (char *)v1) )
    {
      case 0:
      case 1:
        v4 = 24;
        v5 = 1536;
        return sub_22544(v4, v5, v3 + 1);
      case 2:
        v4 = 24;
        v5 = 3072;
        return sub_22544(v4, v5, v3 + 1);
      case 3:
      case 4:
        v4 = 24;
        v5 = 256;
        return sub_22544(v4, v5, v3 + 1);
      case 5:
        v4 = 25;
        v5 = 0;
        return sub_22544(v4, v5, v3 + 1);
      case 6:
        return sub_21C00((const char **)v3 + 1);
      case 7:
      case 8:
        v1 = 0;
        goto LABEL_9;
      case 9:
        v4 = 24;
        v5 = 1024;
        return sub_22544(v4, v5, v3 + 1);
      case 10:
        v4 = 24;
        v5 = 1280;
        return sub_22544(v4, v5, v3 + 1);
      case 11:
        v4 = 24;
        v5 = 512;
        return sub_22544(v4, v5, v3 + 1);
      case 12:
        v1 = 1;
LABEL_9:
        a1 = v3 + 1;
        return sub_21F58(a1, v1);
      default:
        sub_23EE8(*v3, (const char *)dword_7DB90);
    }
  }
  return sub_21F58(a1, v1);
}
// 22A28: control flows out of bounds to 22A2C
// 7DB90: using guessed type int dword_7DB90;

//----- (00022AF4) --------------------------------------------------------
time_t __fastcall sub_22AF4(int *a1)
{
  int *v2; // r5
  int v3; // r0
  time_t result; // r0

  v2 = a1;
  memset(a1, 0, 0x24u);
  v3 = sub_179A4(16, 3, 0);
  *a1 = v3;
  *((_WORD *)v2++ + 2) = 16;
  sub_179C0(v3, (const struct sockaddr *)v2, 0xCu);
  sub_57A54(*a1, (struct sockaddr *)v2, 0xCu);
  result = time(0);
  a1[7] = result;
  return result;
}

//----- (00022B54) --------------------------------------------------------
ssize_t __fastcall sub_22B54(int *a1, const void *a2, size_t a3)
{
  struct sockaddr var4; // [sp+Ch] [bp-4h] BYREF

  memset(var4.sa_data, 0, 10);
  var4.sa_family = 16;
  return sub_179DC(*a1, a2, a3, &var4, 0xCu);
}

//----- (00022B8C) --------------------------------------------------------
ssize_t __fastcall sub_22B8C(int *a1, int a2, __int16 a3, int a4)
{
  int v4; // r3
  int v6; // [sp+4h] [bp-Ch] BYREF
  __int16 v7; // [sp+8h] [bp-8h]
  __int16 v8; // [sp+Ah] [bp-6h]
  int v9; // [sp+Ch] [bp-4h]
  int vars0; // [sp+10h] [bp+0h]
  char vars4; // [sp+14h] [bp+4h]

  v6 = a2;
  v7 = a3;
  v9 = a4;
  v8 = 769;
  vars0 = 0;
  v4 = a1[7];
  v7 = a3;
  vars4 = a2;
  ++v4;
  v6 = 20;
  a1[7] = v4;
  a1[8] = v4;
  v9 = v4;
  return sub_22B54(a1, &v6, 0x14u);
}

//----- (00022BD8) --------------------------------------------------------
int __fastcall sub_22BD8(int *a1, int (__fastcall *a2)(char *, unsigned int *, int), int a3)
{
  unsigned int *v6; // r5
  int v7; // r0
  ssize_t v8; // r0
  int v9; // r3
  int v10; // r2
  unsigned int v11; // r2
  unsigned int *i; // r4
  unsigned int v13; // r1
  int v14; // r0
  int v16; // [sp+4h] [bp-38h]
  int v17; // [sp+4h] [bp-38h]
  _DWORD v18[2]; // [sp+8h] [bp-34h] BYREF
  char v19[4]; // [sp+10h] [bp-2Ch] BYREF
  int v20; // [sp+14h] [bp-28h]
  struct msghdr message; // [sp+1Ch] [bp-20h] BYREF

  v6 = (unsigned int *)sub_1748C(0x2000u);
  v18[0] = v6;
  v18[1] = 0x2000;
  while ( 1 )
  {
    while ( 1 )
    {
      message.msg_namelen = 12;
      message.msg_iov = (struct iovec *)v18;
      v7 = *a1;
      message.msg_iovlen = 1;
      message.msg_name = v19;
      memset(&message.msg_control, 0, 12);
      v8 = recvmsg(v7, &message, 0);
      v9 = v8;
      if ( v8 >= 0 )
        break;
      if ( *(_DWORD *)dword_7DB94 != 4 )
        sub_16AF4("OVERRUN");
    }
    if ( !v8 )
      break;
    if ( message.msg_namelen != 12 )
      sub_16DBC("sender address length == %d");
    for ( i = v6; v9 > 15; i = (unsigned int *)((char *)i + v11) )
    {
      v13 = *i;
      if ( *i <= 0xF || v9 < v13 )
        break;
      v10 = v20;
      if ( !v20 && i[3] == a1[2] && i[2] == a1[8] )
      {
        v14 = *((unsigned __int16 *)i + 2);
        if ( v14 == 3 )
          goto LABEL_8;
        if ( v14 == 2 )
        {
          if ( v13 > 0x23 )
          {
            *(_DWORD *)dword_7DB94 = -i[4];
            sub_16AF4("RTNETLINK answers");
          }
          else
          {
            sub_16DDC("ERROR truncated");
          }
          goto LABEL_7;
        }
        v17 = v9;
        v10 = a2(v19, i, a3);
        v9 = v17;
        if ( v10 < 0 )
          goto LABEL_8;
      }
      v11 = (*i + 3) & 0xFFFFFFFC;
      v9 -= v11;
    }
    if ( (message.msg_flags & 0x20) != 0 )
    {
      sub_16DDC("message truncated");
    }
    else if ( v9 )
    {
      sub_16DBC("remnant of size %d!");
    }
  }
  sub_16DDC("EOF on netlink");
LABEL_7:
  v10 = -1;
LABEL_8:
  v16 = v10;
  free(v6);
  if ( v16 )
    sub_16DBC("dump terminated");
  return 0;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00022DD4) --------------------------------------------------------
int __fastcall sub_22DD4(int *a1, int a2, void *a3)
{
  int v3; // r3
  _DWORD *v7; // r8
  __int16 v8; // r3
  int v9; // r5
  int v10; // r5
  int v11; // r0
  int v12; // r0
  ssize_t v13; // r0
  int v14; // r1
  int v15; // r4
  size_t v17; // r2
  int v18; // r0
  unsigned int v19; // r2
  int *v20; // r3
  size_t v21; // [sp+4h] [bp-40h]
  int v22; // [sp+8h] [bp-3Ch]
  int *v23; // [sp+Ch] [bp-38h]
  _DWORD *v24; // [sp+10h] [bp-34h] BYREF
  int v25; // [sp+14h] [bp-30h]
  __int16 v26; // [sp+18h] [bp-2Ch] BYREF
  __int64 v27; // [sp+1Ah] [bp-2Ah]
  __int16 v28; // [sp+22h] [bp-22h]
  struct msghdr message; // [sp+24h] [bp-20h] BYREF

  v3 = *(_DWORD *)a2;
  v24 = (_DWORD *)a2;
  v25 = v3;
  message.msg_name = &v26;
  message.msg_namelen = 12;
  message.msg_iov = (struct iovec *)&v24;
  message.msg_iovlen = 1;
  memset(&message.msg_control, 0, 12);
  v7 = sub_1748C(0x2000u);
  v27 = 0;
  v28 = 0;
  v8 = 16;
  v9 = a1[7];
  v26 = 16;
  if ( !a3 )
    v8 = *(_WORD *)(a2 + 6);
  v10 = v9 + 1;
  v11 = *a1;
  a1[7] = v10;
  if ( !a3 )
    v8 |= 4u;
  *(_DWORD *)(a2 + 8) = v10;
  if ( !a3 )
    *(_WORD *)(a2 + 6) = v8;
  if ( sendmsg(v11, &message, 0) >= 0 )
  {
    v24 = v7;
LABEL_10:
    while ( 1 )
    {
      v12 = *a1;
      v25 = 0x2000;
      v13 = recvmsg(v12, &message, 0);
      v14 = v13;
      if ( v13 >= 0 )
        break;
      if ( *(_DWORD *)dword_7DB94 != 4 )
        sub_16AF4("OVERRUN", v13);
    }
    if ( v13 )
    {
      if ( message.msg_namelen != 12 )
        sub_16DBC("sender address length == %d", message.msg_namelen);
      v20 = v7;
      while ( 1 )
      {
        v15 = *(_DWORD *)((char *)&v27 + 2);
        do
        {
          if ( v14 <= 15 )
          {
            if ( (message.msg_flags & 0x20) != 0 )
            {
              sub_16DDC("message truncated");
            }
            else if ( v14 )
            {
              sub_16DBC("remnant of size %d!", v14);
            }
            goto LABEL_10;
          }
          v17 = *v20;
          v18 = *v20 - 16;
          if ( (v14 < *v20) | ((unsigned int)v18 >> 31) )
          {
            if ( (message.msg_flags & 0x20) == 0 )
              sub_16DBC("malformed message: len=%d!", v17);
            sub_16DDC("truncated message", v14);
            goto LABEL_15;
          }
        }
        while ( *(_DWORD *)((char *)&v27 + 2) );
        if ( v20[3] != a1[2] || v10 != v20[2] )
          continue;
        if ( *((_WORD *)v20 + 2) == 2 )
          break;
        if ( a3 )
        {
LABEL_33:
          memcpy(a3, v20, v17);
          goto LABEL_16;
        }
        v23 = v20;
        v22 = v14;
        v21 = *v20;
        sub_16DDC("unexpected reply!");
        v19 = (v21 + 3) & 0xFFFFFFFC;
        v14 = v22 - v19;
        v20 = (int *)((char *)v23 + v19);
      }
      if ( v18 <= 19 )
      {
        sub_16DDC("ERROR truncated", v14);
        goto LABEL_15;
      }
      v15 = v20[4];
      *(_DWORD *)dword_7DB94 = -v15;
      if ( !v15 )
      {
        if ( !a3 )
          goto LABEL_16;
        v17 = *v20;
        goto LABEL_33;
      }
      sub_16AF4("RTNETLINK answers");
    }
    else
    {
      sub_16DDC("EOF on netlink", 0);
    }
  }
  else
  {
    sub_16AF4("can't talk to rtnetlink");
  }
LABEL_15:
  v15 = -1;
LABEL_16:
  free(v7);
  return v15;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00023060) --------------------------------------------------------
int __fastcall sub_23060(unsigned int *a1, signed int a2, __int16 a3, int a4)
{
  char *v4; // r1

  if ( (int)((*a1 + 11) & 0xFFFFFFFC) > a2 )
    return -1;
  v4 = (char *)a1 + ((*a1 + 3) & 0xFFFFFFFC);
  *((_WORD *)v4 + 1) = a3;
  *(_WORD *)v4 = 8;
  *((_DWORD *)v4 + 1) = a4;
  *a1 = (*a1 + 11) & 0xFFFFFFFC;
  return 0;
}

//----- (000230B4) --------------------------------------------------------
int __fastcall sub_230B4(size_t *a1, int a2, __int16 a3, void *src, size_t n)
{
  size_t v5; // r5
  int v6; // r12
  unsigned int v7; // r12
  char *v9; // r0

  v5 = n + 4;
  v6 = *a1 + 3;
  if ( (int)((n + 4 + v6) & 0xFFFFFFFC) > a2 )
    return -1;
  v7 = v6 & 0xFFFFFFFC;
  v9 = (char *)a1 + v7;
  *((_WORD *)v9 + 1) = a3;
  *(_WORD *)((char *)a1 + v7) = v5;
  memcpy(v9 + 4, src, n);
  *a1 = (*a1 + 3 + v5) & 0xFFFFFFFC;
  return 0;
}

//----- (00023120) --------------------------------------------------------
int __fastcall sub_23120(_WORD *a1, unsigned int a2, __int16 a3, int a4)
{
  int v4; // r12
  char *v5; // r1

  v4 = (unsigned __int16)*a1;
  if ( ((v4 + 11) & 0xFFFFFFFC) > a2 )
    return -1;
  v5 = (char *)a1 + ((v4 + 3) & 0xFFFFFFFC);
  *((_WORD *)v5 + 1) = a3;
  *(_WORD *)v5 = 8;
  *((_DWORD *)v5 + 1) = a4;
  *a1 = (*a1 + 11) & 0xFFFC;
  return 0;
}

//----- (00023174) --------------------------------------------------------
void __fastcall sub_23174(void *a1, int a2, unsigned __int16 *a3, int a4)
{
  unsigned int v8; // r2
  int v9; // r3
  unsigned int v10; // r2

  memset(a1, 0, 4 * (a2 + 1));
  while ( a4 > 3 )
  {
    v8 = *a3;
    if ( v8 <= 3 || (int)v8 > a4 )
      goto LABEL_5;
    v9 = a3[1];
    v10 = (v8 + 3) & 0xFFFFFFFC;
    a4 -= v10;
    if ( v9 <= a2 )
      *((_DWORD *)a1 + v9) = a3;
    a3 = (unsigned __int16 *)((char *)a3 + v10);
  }
  if ( a4 )
LABEL_5:
    sub_16DDC("deficit %d, rta_len=%d!", a4, *a3);
}

//----- (000231F8) --------------------------------------------------------
const char *__fastcall sub_231F8(unsigned __int8 *cp, int a2, int a3, char *buf, socklen_t len)
{
  socklen_t v5; // r8
  bool v6; // zf
  int v7; // r4
  char *v9; // r0
  size_t v10; // r1
  int i; // r5

  v5 = len;
  if ( a2 == 4 )
  {
    v6 = a3 == 778;
    if ( a3 != 778 )
      v6 = (a3 & 0xFFFFFFF7) == 768;
    if ( v6 )
      return inet_ntop(2, cp, buf, len);
    v7 = 0;
  }
  else
  {
    v7 = 0;
  }
  for ( i = 0; i < a2; ++i )
  {
    v9 = &buf[v7];
    v10 = v5;
    if ( i )
    {
      v5 -= 3;
      snprintf(v9, v10, ":%02x", cp[i]);
      v7 += 3;
    }
    else
    {
      v7 += 2;
      v5 -= 2;
      snprintf(v9, v10, "%02x", *cp);
    }
  }
  return buf;
}

//----- (000232C0) --------------------------------------------------------
int __fastcall sub_232C0(_DWORD *a1, int a2, char *s)
{
  const char *v5; // r5
  char *v6; // r4
  char *v8; // r0
  char *v9; // r6
  _DWORD v10[5]; // [sp+4h] [bp-14h] BYREF

  v5 = s;
  v6 = strchr(s, 46);
  if ( v6 )
  {
    if ( sub_23B64(v10, v5, 2) )
    {
LABEL_3:
      sub_16DDC("\"%s\" is invalid lladdr", v5);
    }
    else if ( a2 > 3 )
    {
      *a1 = v10[1];
      return 4;
    }
    return -1;
  }
  else
  {
    while ( (int)v6 < a2 )
    {
      v8 = strchr(v5, 58);
      v9 = v8;
      if ( v8 )
      {
        *v8 = 0;
        v9 = v8 + 1;
      }
      if ( sscanf(v5, "%x", v10) != 1 || v10[0] > 0xFFu )
        goto LABEL_3;
      v6[(_DWORD)a1] = v10[0];
      if ( !v9 )
        break;
      ++v6;
      v5 = v9;
    }
    return (int)(v6 + 1);
  }
}

//----- (000233A4) --------------------------------------------------------
_DWORD *__fastcall sub_233A4(int a1)
{
  _DWORD *result; // r0

  if ( !dword_7D61C )
    return 0;
  for ( result = *(_DWORD **)(dword_7D61C + 4 * (a1 & 0xF)); result && result[1] != a1; result = (_DWORD *)*result )
    ;
  return result;
}
// 7D61C: using guessed type int dword_7D61C;

//----- (000233E8) --------------------------------------------------------
int __fastcall sub_233E8(int a1, int a2)
{
  char *i; // r6
  char *v5; // r4
  unsigned __int16 *v6; // r1
  int v7; // r3
  const void *v8; // r1
  int v9; // t1
  size_t v10; // r2
  _DWORD v11[3]; // [sp+0h] [bp-C0h] BYREF
  int v12; // [sp+Ch] [bp-B4h]

  if ( *(_WORD *)(a2 + 4) != 16 )
    return 0;
  if ( *(_DWORD *)a2 <= 0x13u )
    return -1;
  sub_23174(v11, 43, (unsigned __int16 *)(a2 + 32), *(_DWORD *)a2 - 32);
  if ( v12 )
  {
    if ( !dword_7D61C )
      dword_7D61C = (int)sub_174DC(0x40u);
    for ( i = (char *)(dword_7D61C + 4 * (*(_DWORD *)(a2 + 20) & 0xF)); ; i = *(char **)i )
    {
      v5 = *(char **)i;
      if ( !*(_DWORD *)i )
        break;
      if ( *(_DWORD *)(a2 + 20) == *((_DWORD *)v5 + 1) )
        goto LABEL_10;
    }
    v5 = (char *)sub_1748C(0x2Cu);
    *(_DWORD *)v5 = *(_DWORD *)i;
    *((_DWORD *)v5 + 1) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)i = v5;
LABEL_10:
    v6 = (unsigned __int16 *)v11[1];
    *((_DWORD *)v5 + 2) = *(unsigned __int16 *)(a2 + 18);
    v7 = *(_DWORD *)(a2 + 24);
    if ( !v6 )
    {
      *((_DWORD *)v5 + 3) = 0;
      *((_DWORD *)v5 + 5) = 0;
    }
    *((_DWORD *)v5 + 4) = v7;
    if ( v6 )
    {
      v9 = *v6;
      v8 = v6 + 2;
      v10 = v9 - 4;
      *((_DWORD *)v5 + 3) = v9 - 4;
      if ( v9 - 4 >= 8 )
        v10 = 8;
      memcpy(v5 + 20, v8, v10);
    }
    else
    {
      *((_DWORD *)v5 + 6) = 0;
    }
    strcpy(v5 + 28, (const char *)(v12 + 4));
  }
  return 0;
}
// 7D61C: using guessed type int dword_7D61C;

//----- (0002350C) --------------------------------------------------------
const char *__fastcall sub_2350C(int a1)
{
  _DWORD *v2; // r0
  char *v4; // r0

  if ( !a1 )
    return "*";
  v2 = sub_233A4(a1);
  if ( v2 )
    return (const char *)(v2 + 7);
  v4 = sub_177E4("if%d", a1);
  return (const char *)sub_57710((int)v4);
}

//----- (00023550) --------------------------------------------------------
_DWORD *__fastcall sub_23550(int a1)
{
  _DWORD *result; // r0

  if ( !a1 )
    return 0;
  result = sub_233A4(a1);
  if ( result )
    return (_DWORD *)result[4];
  return result;
}

//----- (00023574) --------------------------------------------------------
int __fastcall sub_23574(const char *a1)
{
  int result; // r0

  result = if_nametoindex();
  if ( result <= 0 )
    sub_16DBC("can't find device '%s'", a1);
  return result;
}
// 140C0: using guessed type int if_nametoindex(void);

//----- (00023598) --------------------------------------------------------
int __fastcall sub_23598(int *a1, int a2, int a3, int a4)
{
  sub_22B8C(a1, 0, 18, a4);
  sub_22BD8(a1, (int (__fastcall *)(char *, unsigned int *, int))sub_233E8, 0);
  return 0;
}

//----- (000235C8) --------------------------------------------------------
const char *__fastcall sub_235C8(int a1, char *a2)
{
  unsigned __int16 *v3; // r5
  const char *v5; // r4
  int v6; // t1

  v3 = (unsigned __int16 *)&unk_642E0;
  v5 = "generic";
  while ( 1 )
  {
    v6 = v3[1];
    ++v3;
    if ( v6 == a1 )
      break;
    v5 += strlen(v5) + 1;
    if ( v3 == (unsigned __int16 *)&unk_64306 )
    {
      v5 = a2;
      sprintf(a2, "[%d]", a1);
      return v5;
    }
  }
  return v5;
}

//----- (0002362C) --------------------------------------------------------
void __fastcall sub_2362C(const char *a1, int a2)
{
  _DWORD *v4; // r4
  unsigned int v5; // r6
  const char *v6[2]; // [sp+4h] [bp-30h] BYREF
  char s[40]; // [sp+Ch] [bp-28h] BYREF

  sprintf(s, "/etc/iproute2/rt_%s", a1);
  v4 = sub_5DDC4((int)s, (int (*)(void))sub_61C9C);
  while ( sub_5DE1C(v4, v6, 4653570, "# \t") )
  {
    v5 = sub_18990(v6[0], 0, 0);
    if ( v5 >= 0x400 )
    {
      sub_16DDC("database %s is corrupted at line %d", a1, v4[6]);
      break;
    }
    *(_DWORD *)(a2 + 4 * v5) = sub_174F8(v6[1]);
  }
  sub_5DDEC((int)v4);
}

//----- (000236E0) --------------------------------------------------------
void sub_236E0()
{
  _DWORD *v0; // r0

  if ( !dword_7D624 )
  {
    v0 = sub_174DC(0x1008u);
    dword_7D624 = (int)v0;
    v0[2] = "global";
    v0[257] = "nowhere";
    v0[256] = "host";
    v0[255] = "link";
    v0[202] = "site";
    sub_2362C("scopes", (int)(v0 + 2));
  }
}
// 7D624: using guessed type int dword_7D624;

//----- (00023754) --------------------------------------------------------
int __fastcall sub_23754(int a1, unsigned int *a2, char *s2, char *a4)
{
  const char *v5; // r0
  int result; // r0
  const char **v10; // r9
  unsigned int i; // r4
  const char *v12; // r8
  const char *v13; // t1
  unsigned int v14; // r0

  v5 = *(const char **)a1;
  if ( !v5 || (result = strcmp(v5, s2)) != 0 )
  {
    v10 = (const char **)(a1 + 8);
    for ( i = 0; i != 1024; ++i )
    {
      v13 = *v10++;
      v12 = v13;
      if ( v13 )
      {
        result = strcmp(v12, s2);
        if ( !result )
        {
          *(_DWORD *)a1 = v12;
          *(_DWORD *)(a1 + 4) = i;
          *a2 = i;
          return result;
        }
      }
    }
    v14 = sub_18990(s2, 0, a4);
    if ( v14 >= 0x400 )
    {
      return -1;
    }
    else
    {
      *a2 = v14;
      return 0;
    }
  }
  else
  {
    *a2 = *(_DWORD *)(a1 + 4);
  }
  return result;
}

//----- (000237F8) --------------------------------------------------------
int __fastcall sub_237F8(unsigned int *a1, char *s2)
{
  char *v4; // r0
  char **v5; // r12
  _DWORD *v6; // r2
  char *v7; // r1
  _DWORD *v8; // lr
  bool v9; // zf

  if ( !dword_7D620 )
  {
    v4 = (char *)sub_174DC(0x1008u);
    v5 = off_63580;
    v6 = v4 + 8;
    dword_7D620 = (int)v4;
    do
    {
      v6 += 2;
      v7 = v5[1];
      v8 = v5 + 2;
      v9 = v5 + 2 == off_635B0;
      *(v6 - 2) = *v5;
      *(v6 - 1) = v7;
      v5 += 2;
    }
    while ( !v9 );
    *v6 = *v8;
    sub_2362C("protos", (int)(v4 + 8));
  }
  return sub_23754(dword_7D620, a1, s2, 0);
}
// 63580: using guessed type char *off_63580[3];
// 635B0: using guessed type char *[2];
// 7D620: using guessed type int dword_7D620;

//----- (00023888) --------------------------------------------------------
_BYTE *__fastcall sub_23888(unsigned int a1)
{
  _BYTE *result; // r0

  if ( a1 >= 0x400 )
    return sub_16F8C(a1);
  sub_236E0();
  result = *(_BYTE **)(dword_7D624 + 4 * (a1 + 2));
  if ( !result )
    return sub_16F8C(a1);
  return result;
}
// 7D624: using guessed type int dword_7D624;

//----- (000238C8) --------------------------------------------------------
int __fastcall sub_238C8(unsigned int *a1, char *a2)
{
  sub_236E0();
  return sub_23754(dword_7D624, a1, a2, 0);
}
// 7D624: using guessed type int dword_7D624;

//----- (000238F8) --------------------------------------------------------
char *__fastcall sub_238F8(signed int a1)
{
  char *result; // r0

  switch ( a1 )
  {
    case 0:
      result = "none";
      break;
    case 1:
      result = "unicast";
      break;
    case 2:
      result = "local";
      break;
    case 3:
      result = "broadcast";
      break;
    case 4:
      result = "anycast";
      break;
    case 5:
      result = "multicast";
      break;
    case 6:
      result = "blackhole";
      break;
    case 7:
      result = "unreachable";
      break;
    case 8:
      result = "prohibit";
      break;
    case 9:
      result = "throw";
      break;
    case 10:
      result = "nat";
      break;
    case 11:
      result = "xresolve";
      break;
    default:
      result = sub_16F8C(a1);
      break;
  }
  return result;
}
// 23900: control flows out of bounds to 23904

//----- (000239C8) --------------------------------------------------------
int __fastcall sub_239C8(unsigned int *a1, char *a2, char *a3)
{
  int v5; // r0
  unsigned int v6; // r0
  bool v7; // zf
  char *endptr[2]; // [sp+4h] [bp-8h] BYREF

  endptr[0] = a2;
  endptr[1] = a3;
  v5 = sub_168D4("local", a2);
  if ( v5 )
  {
    if ( v5 == 1 )
    {
      v6 = 10;
    }
    else if ( (unsigned int)(v5 - 2) <= 1 )
    {
      v6 = 3;
    }
    else
    {
      switch ( v5 )
      {
        case 4:
          v6 = 4;
          break;
        case 5:
          v6 = 5;
          break;
        case 6:
          v6 = 8;
          break;
        case 7:
          v6 = 7;
          break;
        case 8:
          v6 = 6;
          break;
        case 9:
          v6 = 11;
          break;
        case 10:
          v6 = 1;
          break;
        case 11:
          v6 = 9;
          break;
        default:
          v6 = strtoul(a2, endptr, 0);
          if ( endptr[0] == a2 )
            return -1;
          v7 = v6 == 255;
          if ( v6 <= 0xFF )
            v7 = *endptr[0] == 0;
          if ( !v7 )
            return -1;
          break;
      }
    }
  }
  else
  {
    v6 = 2;
  }
  *a1 = v6;
  return 0;
}

//----- (00023ADC) --------------------------------------------------------
int __fastcall sub_23ADC(int a1, int a2, int a3)
{
  int result; // r0
  FILE *v4; // r0
  FILE *v5; // r5
  int v6; // [sp+0h] [bp-Ch] BYREF
  int v7; // [sp+4h] [bp-8h] BYREF
  int v8; // [sp+8h] [bp-4h]

  v6 = a1;
  v7 = a2;
  v8 = a3;
  result = dword_7D628;
  if ( !dword_7D628 )
  {
    v4 = (FILE *)sub_61C9C((int)"/proc/net/psched");
    v5 = v4;
    if ( v4 )
    {
      if ( fscanf(v4, "%*08x%*08x%08x%08x", &v6, &v7) == 2 && v6 == 1000000 )
        dword_7D628 = v7;
      fclose(v5);
    }
    if ( !dword_7D628 )
      dword_7D628 = sub_60F80();
    return dword_7D628;
  }
  return result;
}
// 7D628: using guessed type int dword_7D628;

//----- (00023B64) --------------------------------------------------------
unsigned int __fastcall sub_23B64(_BYTE *a1, const char *a2, int a3)
{
  char v6; // r3
  unsigned int result; // r0
  _BOOL4 v8; // r4
  const char *v9; // r6
  int v10; // r2
  unsigned int v11; // r3
  int v12; // r12
  int v13; // t1
  unsigned int v14; // r1

  memset(a1, 0, 0x14u);
  if ( !strcmp(a2, "default") || !strcmp(a2, "all") || !strcmp(a2, "any") )
  {
    *a1 = a3;
    if ( a3 == 10 )
      v6 = 16;
    else
      v6 = 4;
    goto LABEL_7;
  }
  if ( strchr(a2, 58) )
  {
    *a1 = 10;
    if ( a3 )
      v8 = a3 != 10;
    else
      v8 = 0;
    if ( !v8 && inet_pton(10, a2, a1 + 4) > 0 )
    {
      v6 = 16;
LABEL_7:
      a1[1] = v6;
      *((_WORD *)a1 + 1) = -1;
      return 0;
    }
    return -1;
  }
  result = a3 & 0xFFFFFFFD;
  if ( (a3 & 0xFFFFFFFD) != 0 )
    return -1;
  v9 = a2 - 1;
  *a1 = 2;
  v10 = 0;
  v11 = 0;
  while ( 1 )
  {
    v13 = *(unsigned __int8 *)++v9;
    v12 = v13;
    if ( !v13 )
      break;
    v14 = (unsigned __int8)(v12 - 48);
    if ( v14 > 9 )
    {
      if ( v12 != 46 )
        return -1;
      if ( (unsigned int)++v10 > 3 )
        return -1;
      v11 = 0;
    }
    else
    {
      v11 = v14 + 10 * v11;
      if ( v11 > 0xFF )
        return -1;
      a1[v10 + 4] = v11;
    }
  }
  a1[1] = 4;
  *((_WORD *)a1 + 1) = -1;
  return result;
}

//----- (00023CCC) --------------------------------------------------------
unsigned int __fastcall sub_23CCC(_BYTE *a1, const char *a2, int a3)
{
  unsigned int result; // r0

  if ( a3 == 17 )
    sub_16DBC("\"%s\" may be inet %s, but it is not allowed in this context", a2, "address");
  result = sub_23B64(a1, a2, a3);
  if ( result )
    sub_16DBC("an %s %s is expected rather than \"%s\"", "inet", "address", a2);
  return result;
}

//----- (00023D18) --------------------------------------------------------
unsigned int __fastcall sub_23D18(_WORD *a1, const char *a2, int a3)
{
  unsigned int result; // r0
  char *v7; // r0
  char *v8; // r7
  __int16 v9; // r3
  unsigned int v10; // r4
  unsigned int v11; // r3
  _BYTE v12[4]; // [sp+4h] [bp-18h] BYREF
  unsigned int v13; // [sp+8h] [bp-14h]

  if ( a3 == 17 )
    sub_16DBC("\"%s\" may be inet %s, but it is not allowed in this context", a2, "prefix");
  memset(a1, 0, 0x14u);
  result = strcmp(a2, "default");
  if ( !result || (result = strcmp(a2, "all")) == 0 || (result = strcmp(a2, "any")) == 0 )
  {
    *(_BYTE *)a1 = a3;
    return result;
  }
  v7 = strchr(a2, 47);
  v8 = v7;
  if ( v7 )
    *v7 = 0;
  result = sub_23B64(a1, a2, a3);
  if ( result )
  {
    if ( v8 )
LABEL_19:
      *v8 = 47;
  }
  else
  {
    if ( *(_BYTE *)a1 == 10 )
      v9 = 128;
    else
      v9 = 32;
    a1[1] = v9;
    if ( v8 )
    {
      v12[0] = 0;
      result = sub_18990(v8 + 1, 0, 0);
      LOWORD(v10) = result;
      if ( *(_DWORD *)dword_7DB94 || result > (__int16)a1[1] )
      {
        result = sub_23B64(v12, v8 + 1, a3);
        if ( result )
          goto LABEL_21;
      }
      if ( v12[0] == 2 )
      {
        v11 = bswap32(v13);
        v10 = -v11 & ~v11;
        if ( v10 )
          goto LABEL_21;
        while ( v11 )
        {
          ++v10;
          v11 *= 2;
        }
        if ( v10 > (__int16)a1[1] )
LABEL_21:
          sub_16DBC("an %s %s is expected rather than \"%s\"", "inet", "prefix", a2);
      }
      a1[1] = v10;
      goto LABEL_19;
    }
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00023EC4) --------------------------------------------------------
int __fastcall sub_23EC4(int a1)
{
  if ( !*(_DWORD *)(a1 + 4) )
    sub_16DBC("command line is not complete, try \"help\"");
  return a1 + 4;
}

//----- (00023EE8) --------------------------------------------------------
void __fastcall __noreturn sub_23EE8(const char *a1, const char *a2)
{
  sub_16DBC("invalid argument '%s' to '%s'", a1, a2);
}

//----- (00023F00) --------------------------------------------------------
unsigned int __fastcall sub_23F00(const char *a1, char *a2, char *a3)
{
  unsigned int result; // r0
  char *endptr[2]; // [sp+4h] [bp-8h] BYREF

  endptr[0] = a2;
  endptr[1] = a3;
  if ( !*a1 || (result = strtoul(a1, endptr, 0), *endptr[0]) )
    sub_23EE8(a1, a2);
  return result;
}

//----- (00023F4C) --------------------------------------------------------
unsigned int __fastcall sub_23F4C(const char *a1, char *a2, char *a3)
{
  unsigned int result; // r0
  _BOOL4 v6; // r3
  char *endptr[2]; // [sp+4h] [bp-8h] BYREF

  endptr[0] = a2;
  endptr[1] = a3;
  if ( !*a1 )
    goto LABEL_5;
  result = strtoul(a1, endptr, 0);
  v6 = result < 0x10000;
  if ( *endptr[0] )
    v6 = 0;
  if ( !v6 )
LABEL_5:
    sub_23EE8(a1, a2);
  return (unsigned __int16)result;
}

//----- (00023FAC) --------------------------------------------------------
void __fastcall __noreturn sub_23FAC(const char *a1, const char *a2)
{
  sub_16DBC("duplicate \"%s\": \"%s\" is the second value", a1, a2);
}

//----- (00023FC4) --------------------------------------------------------
void __fastcall __noreturn sub_23FC4(const char *a1, const char *a2)
{
  sub_16DBC("either \"%s\" is duplicate, or \"%s\" is garbage", a1, a2);
}

//----- (00023FDC) --------------------------------------------------------
int __fastcall sub_23FDC(int a1, int a2, int a3)
{
  int v3; // r5
  int v4; // r7
  int v5; // r6
  int v6; // r4

  v3 = a3 >> 5;
  v4 = a1 + 4;
  v5 = a2 + 4;
  v6 = a3 & 0x1F;
  if ( a3 >> 5 && memcmp((const void *)(a1 + 4), (const void *)(a2 + 4), 4 * v3) )
    return -1;
  if ( v6 )
    return ((*(_DWORD *)(v4 + 4 * v3) ^ *(_DWORD *)(v5 + 4 * v3)) & bswap32(-1 << (32 - v6))) != 0;
  return v6;
}

//----- (00024048) --------------------------------------------------------
const char *__fastcall sub_24048(int a1, const void *a2)
{
  void *v4; // r0
  char *v5; // r0

  if ( a1 != 2 && a1 != 10 )
    return "???";
  v4 = sub_174DC(0x2Eu);
  v5 = (char *)sub_57710((int)v4);
  return inet_ntop(a1, a2, v5, 0x2Eu);
}

//----- (00024094) --------------------------------------------------------
_BYTE *__fastcall sub_24094(char a1, const void *a2, int a3)
{
  int v6; // r0
  char v7; // r8
  size_t v8; // r7
  _BYTE *v9; // r4

  v6 = strnlen(a2, 255);
  v7 = v6 + a3;
  v8 = v6;
  v9 = sub_174DC(v6 + a3 + 2);
  *v9 = a1;
  v9[1] = v7;
  memcpy(&v9[a3 + 2], a2, v8);
  return v9;
}
// 13E2C: using guessed type int __fastcall strnlen(_DWORD, _DWORD);

//----- (000240E8) --------------------------------------------------------
void __fastcall sub_240E8(int a1, unsigned int a2)
{
  int v3; // r0
  int v4; // r1
  int v5; // r2

  sub_26090((void *)a1, a2);
  v3 = rand();
  *(_DWORD *)(a1 + 4) = v3;
  sub_1882C(v3, v4, v5);
  word_7D9DE = v3;
  if ( !word_7D9DC )
    word_7D9DC = v3;
  *(_WORD *)(a1 + 8) = __rev16((unsigned __int16)v3 - (unsigned __int16)word_7D9DC);
  *(_DWORD *)(a1 + 28) = dword_7D990;
  *(_WORD *)(a1 + 32) = word_7D994;
  if ( dword_7D9CC )
    sub_26D10(a1, (const void *)dword_7D9CC);
}
// 240FC: variable 'v4' is possibly undefined
// 240FC: variable 'v5' is possibly undefined
// 7D990: using guessed type int dword_7D990;
// 7D994: using guessed type __int16 word_7D994;
// 7D9CC: using guessed type int dword_7D9CC;
// 7D9DC: using guessed type __int16 word_7D9DC;
// 7D9DE: using guessed type __int16 word_7D9DE;

//----- (00024168) --------------------------------------------------------
void __fastcall sub_24168(__int64 a1)
{
  int v1; // r4
  int v2; // r0
  int v3; // r3
  int i; // r2
  int v5; // r1
  int v6; // r2
  int j; // r5

  v1 = a1;
  HIDWORD(a1) = 57;
  sub_26D7C(a1, 16386);
  v2 = sub_26CDC(v1 + 240);
  v3 = 0;
  for ( i = 1; i != 255; ++i )
  {
    if ( (((int)*((unsigned __int8 *)&buf + (i >> 3) + 524) >> (i & 7)) & 1) != 0 )
    {
      v5 = v1 + v3++;
      *(_BYTE *)(v5 + v2 + 242) = i;
    }
  }
  if ( v3 )
  {
    v6 = v1 + v2;
    *(_BYTE *)(v6 + 241) = v3;
    *(_BYTE *)(v6 + 240) = 55;
    *(_BYTE *)(v1 + v3 + v2 + 242) = -1;
  }
  if ( dword_7D9D0 )
    sub_26D10(v1, (const void *)dword_7D9D0);
  if ( dword_7D9D4 )
    sub_26D10(v1, (const void *)dword_7D9D4);
  if ( dword_7D9D8 )
    sub_26D10(v1, (const void *)dword_7D9D8);
  if ( (dword_7DBC0 & 0x100000) != 0 && !*(_DWORD *)(v1 + 12) )
    *(_WORD *)(v1 + 10) |= 0x80u;
  for ( j = dword_7D9C8; j; j = *(_DWORD *)(j + 4) )
    sub_26D10(v1, *(const void **)j);
}
// 7D9C8: using guessed type int dword_7D9C8;
// 7D9D0: using guessed type int dword_7D9D0;
// 7D9D4: using guessed type int dword_7D9D4;
// 7D9D8: using guessed type int dword_7D9D8;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00024274) --------------------------------------------------------
ssize_t __fastcall sub_24274(const void *a1, int a2)
{
  return sub_26248(a1, a2, 0x44u, -1, 0x43u, &dword_64308, dword_7D998);
}
// 64308: using guessed type int dword_64308;
// 7D998: using guessed type int dword_7D998;

//----- (000242B0) --------------------------------------------------------
ssize_t __fastcall sub_242B0(int a1, int a2)
{
  __int64 v4; // r0
  __int64 v5; // r0
  _BYTE v7[4]; // [sp+4h] [bp-278h] BYREF
  int v8; // [sp+8h] [bp-274h]

  sub_240E8((int)v7, 1u);
  v8 = a1;
  if ( a2 )
  {
    HIDWORD(v5) = 50;
    LODWORD(v5) = v7;
    sub_26D7C(v5, a2);
  }
  LODWORD(v4) = v7;
  sub_24168(v4);
  sub_16DDC("sending %s", "discover");
  return sub_24274(v7, 0);
}
// 242EC: variable 'v4' is possibly undefined

//----- (00024318) --------------------------------------------------------
ssize_t __fastcall sub_24318(int a1, int a2, int a3)
{
  __int64 v6; // r0
  __int64 v7; // r0
  __int64 v8; // r0
  char *v9; // r0
  _BYTE v11[4]; // [sp+4h] [bp-274h] BYREF
  int v12; // [sp+8h] [bp-270h]

  sub_240E8((int)v11, 3u);
  LODWORD(v6) = v11;
  HIDWORD(v6) = 50;
  v12 = a1;
  sub_26D7C(v6, a3);
  HIDWORD(v7) = 54;
  LODWORD(v7) = v11;
  sub_26D7C(v7, a2);
  LODWORD(v8) = v11;
  sub_24168(v8);
  v9 = inet_ntoa((struct in_addr)a3);
  sub_16DDC("sending select for %s", v9);
  return sub_24274(v11, 0);
}
// 24360: variable 'v8' is possibly undefined

//----- (00024390) --------------------------------------------------------
ssize_t __fastcall sub_24390(int a1, int a2)
{
  __int64 v4; // r0
  __int64 v5; // r0
  _BYTE v7[632]; // [sp+4h] [bp-278h] BYREF

  sub_240E8((int)v7, 4u);
  LODWORD(v4) = v7;
  HIDWORD(v4) = 50;
  sub_26D7C(v4, a2);
  LODWORD(v5) = v7;
  HIDWORD(v5) = 54;
  sub_26D7C(v5, a1);
  sub_16DDC("sending %s", "decline");
  return sub_24274(v7, 0);
}

//----- (000243F4) --------------------------------------------------------
ssize_t __fastcall sub_243F4(int a1, int a2, int a3)
{
  __int64 v6; // r0
  char *v7; // r0
  _BYTE v9[4]; // [sp+Ch] [bp-274h] BYREF
  int v10; // [sp+10h] [bp-270h]
  int v11; // [sp+18h] [bp-268h]

  sub_240E8((int)v9, 3u);
  LODWORD(v6) = v9;
  v10 = a1;
  v11 = a3;
  sub_24168(v6);
  v7 = inet_ntoa((struct in_addr)a2);
  sub_16DDC("sending renew to %s", v7);
  if ( a2 )
    return sub_26400(v9, a3, 0x44u, a2, 0x43u);
  else
    return sub_24274(v9, a3);
}
// 24420: variable 'v6' is possibly undefined

//----- (00024478) --------------------------------------------------------
int __fastcall sub_24478(void *a1, int a2)
{
  ssize_t v4; // r0
  int v5; // r5
  int v7; // r6
  int v8; // r5
  int v9; // r5
  struct cmsghdr *i; // r1
  _DWORD v11[2]; // [sp+4h] [bp-2D4h] BYREF
  struct msghdr s; // [sp+Ch] [bp-2CCh] BYREF
  char v13; // [sp+28h] [bp-2B0h] BYREF
  unsigned __int16 v14; // [sp+48h] [bp-290h] BYREF
  unsigned __int16 v15; // [sp+4Ah] [bp-28Eh]
  int v16; // [sp+4Ch] [bp-28Ch]
  char v17; // [sp+50h] [bp-288h]
  char v18; // [sp+51h] [bp-287h]
  unsigned __int16 v19; // [sp+52h] [bp-286h]
  __int16 v20; // [sp+5Eh] [bp-27Ah]
  unsigned __int16 v21; // [sp+60h] [bp-278h]
  unsigned __int16 v22; // [sp+62h] [bp-276h]
  _BYTE src[236]; // [sp+64h] [bp-274h] BYREF
  int v24; // [sp+150h] [bp-188h]

  v11[1] = 656;
  v11[0] = &v14;
  memset(&s, 0, sizeof(s));
  s.msg_iov = (struct iovec *)v11;
  s.msg_iovlen = 1;
  s.msg_control = &v13;
  s.msg_controllen = 32;
  while ( 1 )
  {
    v4 = recvmsg(a2, &s, 0);
    v5 = v4;
    if ( v4 >= 0 )
      break;
    if ( *(_DWORD *)dword_7DB94 != 4 )
    {
      if ( dword_7DBAC )
        sub_16DDC("packet read error, ignoring");
      return v5;
    }
  }
  if ( v4 <= 27 )
  {
    if ( dword_7DBAC )
      sub_16DDC("packet is too short, ignoring");
    return -2;
  }
  v7 = (unsigned __int16)__rev16(v15);
  if ( (unsigned __int16)v7 > v4 )
  {
    if ( dword_7DBAC )
      sub_16DDC("oversized packet, ignoring");
    return -2;
  }
  if ( v18 != 17
    || (unsigned __int8)v14 != 69
    || v20 != 17408
    || (unsigned __int16)__rev16(v21) != (unsigned __int16)(v7 - 20) )
  {
    if ( dword_7DBAC )
      sub_16DDC("unrelated/bogus packet, ignoring");
    return -2;
  }
  v8 = v19;
  v19 = 0;
  if ( sub_5A500(&v14, 20) != v8 )
  {
    if ( dword_7DBAC )
      sub_16DDC("bad IP header checksum, ignoring");
    return -2;
  }
  if ( s.msg_controllen > 0xB )
  {
    for ( i = (struct cmsghdr *)s.msg_control; i; i = _cmsg_nxthdr(&s, i) )
    {
      if ( i->cmsg_level == 263 && i->cmsg_type == 8 && (i[1].cmsg_len & 8) != 0 )
        goto LABEL_28;
    }
  }
  v14 = 0;
  v9 = v22;
  v16 = 0;
  v17 = 0;
  v15 = v21;
  v22 = 0;
  if ( v9 && sub_5A500(&v14, (unsigned __int16)v7) != v9 )
  {
    if ( dword_7DBAC )
      sub_16DDC("packet with bad UDP checksum received, ignoring");
    return -2;
  }
LABEL_28:
  if ( v24 != 1666417251 )
  {
    sub_16DDC("packet with bad magic, ignoring");
    return -2;
  }
  if ( dword_7DBAC )
    sub_16DDC("received %s", "a packet");
  v5 = (unsigned __int16)v7 - 28;
  sub_26110((int)src);
  memcpy(a1, src, v7 - 28);
  return v5;
}
// 7DB94: using guessed type int dword_7DB94;
// 7DBAC: using guessed type int dword_7DBAC;

//----- (00024728) --------------------------------------------------------
int sub_24728()
{
  sub_61B48(0);
  dword_7D4BC &= ~1u;
  return sub_5E30C(dword_7D9C0);
}
// 7D4BC: using guessed type int dword_7D4BC;
// 7D9C0: using guessed type int dword_7D9C0;

//----- (0002475C) --------------------------------------------------------
int __fastcall sub_2475C(char *a1, const char *a2, unsigned __int8 *a3)
{
  return sprintf(a1, "%s%u.%u.%u.%u", a2, *a3, a3[1], a3[2], a3[3]);
}

//----- (00024794) --------------------------------------------------------
void __fastcall sub_24794(int a1)
{
  const char *v2; // r1
  int v3; // r7
  int v4; // r6
  struct sockaddr v5; // [sp+4h] [bp-18h] BYREF
  int v6; // [sp+14h] [bp-8h]

  if ( dword_7DBAC )
  {
    if ( a1 )
    {
      v2 = "raw";
      if ( a1 == 1 )
        v2 = "kernel";
    }
    else
    {
      v2 = "none";
    }
    sub_16DDC("entering listen mode: %s", v2);
  }
  dword_7D62C = a1;
  if ( dword_7D4C8 >= 0 )
  {
    close(dword_7D4C8);
    dword_7D4C8 = -1;
  }
  if ( a1 == 1 )
  {
    dword_7D4C8 = sub_267E0(0x44u, (const char *)dword_7D9BC);
  }
  else if ( a1 )
  {
    v3 = dword_7D998;
    if ( (unsigned int)dword_7DBAC > 1 )
      sub_16DDC("opening raw socket on ifindex %d", dword_7D998);
    v4 = sub_179A4(17, 2, 8);
    if ( (unsigned int)dword_7DBAC > 1 )
      sub_16DDC("got raw socket fd");
    *(_DWORD *)&v5.sa_data[6] = 0;
    *(_DWORD *)&v5.sa_data[10] = 0;
    v6 = 0;
    *(_DWORD *)&v5.sa_family = 524305;
    *(_DWORD *)&v5.sa_data[2] = v3;
    sub_179C0(v4, &v5, 0x14u);
    if ( sub_623F4(v4, 263, 8) && *(_DWORD *)dword_7DB94 != 92 && dword_7DBAC )
      sub_16DDC("can't set PACKET_AUXDATA on raw socket");
    if ( dword_7DBAC )
      sub_16DDC("created raw socket");
    dword_7D4C8 = v4;
  }
}
// 7D4C8: using guessed type int dword_7D4C8;
// 7D62C: using guessed type int dword_7D62C;
// 7D998: using guessed type int dword_7D998;
// 7D9BC: using guessed type int dword_7D9BC;
// 7DB94: using guessed type int dword_7DB94;
// 7DBAC: using guessed type int dword_7DBAC;

//----- (00024928) --------------------------------------------------------
char *__fastcall sub_24928(int a1, char a2, const char *a3)
{
  int v3; // r9
  int v4; // r5
  signed int v6; // r8
  unsigned __int8 *v7; // r7
  unsigned int v8; // r4
  size_t v9; // r0
  char *v10; // r6
  int v11; // r0
  char *v12; // r2
  char *v13; // r4
  unsigned int *v14; // r11
  unsigned __int8 *v15; // r2
  int v16; // r0
  int v17; // r2
  char *v18; // r2
  char *v19; // r0
  int v20; // r3
  int v21; // t1
  bool v22; // zf
  bool v23; // zf
  unsigned int v24; // r10
  unsigned __int8 *v25; // r7
  int v26; // r5
  unsigned int v27; // r0
  char *v28; // r2
  int v29; // r3
  int v30; // r5
  unsigned __int8 *v31; // r7
  char *v32; // r4
  char *v33; // r4
  int v34; // r0
  const char *v35; // r1
  unsigned __int8 v36; // t1
  unsigned int v37; // r2
  char *v38; // r4
  char *v39; // r4
  int v40; // r5
  char *v41; // r4
  unsigned __int8 *v42; // r7
  int v43; // r0
  const char *v44; // r2
  unsigned int v45; // r1
  int v46; // r0
  char *v47; // r4
  char *v48; // r0
  int v49; // r7
  const char *v50; // r1
  char *v51; // r5
  unsigned __int8 *v52; // r2
  int v53; // r0
  const char *v55; // [sp+4h] [bp-10h]
  unsigned __int8 v56[8]; // [sp+Ch] [bp-8h] BYREF

  v3 = a2 & 0xF;
  v4 = *(unsigned __int8 *)(a1 - 1);
  v6 = (unsigned __int8)byte_67678[v3];
  v7 = (unsigned __int8 *)(a1 + 4);
  v8 = byte_66EEC[v3] * sub_15CA0(v4 + v6, v6);
  v9 = strlen(a3);
  v10 = (char *)sub_1748C(v8 + 2 + v9);
  v11 = sprintf(v10, "%s=", a3);
  v12 = "%lu";
  v13 = &v10[v11];
  if ( v3 != 7 )
    v12 = "%ld";
  v55 = v12;
  while ( 2 )
  {
    v14 = (unsigned int *)(v7 - 4);
    v15 = v7 - 4;
    if ( v6 <= v4 )
    {
      switch ( v3 )
      {
        case 1:
        case 2:
          v13 += sub_2475C(v13, "", v7 - 4);
          if ( v3 == 1 )
            goto LABEL_9;
          v16 = sub_2475C(v13, "/", v7);
          goto LABEL_8;
        case 3:
        case 4:
          memcpy(v13, v7 - 4, v4);
          v13[v4] = 0;
          if ( v3 != 4 )
            return v10;
          v18 = v13;
          break;
        case 5:
          v17 = *(v7 - 4);
          goto LABEL_12;
        case 6:
          v17 = (unsigned __int16)__rev16(*(unsigned __int16 *)v14);
LABEL_12:
          v16 = sprintf(v13, "%u", v17);
          goto LABEL_8;
        case 7:
        case 8:
          v16 = sprintf(v13, v55, bswap32(*v14));
LABEL_8:
          v13 += v16;
          goto LABEL_9;
        case 10:
          v35 = "";
          while ( v4 > 4 )
          {
            v24 = *v15;
            v25 = v15 + 1;
            if ( v24 > 0x20 )
              break;
            v26 = v4 - 1;
            v27 = (v24 + 7) >> 3;
            v28 = (char *)(v15 + 1);
            v29 = 0;
            *(_DWORD *)v56 = 0;
            while ( v27 != v29 )
            {
              v36 = *v28++;
              v56[v29++] = v36;
            }
            v30 = v26 - v27;
            v31 = &v25[v27];
            if ( v30 <= 3 )
              break;
            v32 = &v13[sub_2475C(v13, v35, v56)];
            v33 = &v32[sprintf(v32, "/%u ", v24)];
            v34 = sub_2475C(v33, "", v31);
            v35 = " ";
            v13 = &v33[v34];
            v15 = v31 + 4;
            v4 = v30 - 4;
          }
          return v10;
        case 11:
          if ( v4 > 21 )
          {
            v37 = *(unsigned __int8 *)v14;
            if ( v37 <= 0x20 && (int)(*(v7 - 3) + 32 - v37) <= 128 )
            {
              v38 = &v13[sprintf(v13, "%u ", v37)];
              v39 = &v38[sprintf(v38, "%u ", *(v7 - 3))];
              v40 = v4 - 22;
              v41 = &v39[sub_27340(v39, v7 - 2)];
              v42 = &v7[v40 + 14];
              do
              {
                v43 = sub_2475C(v41, " ", &v42[-v40]);
                v40 -= 4;
                v41 += v43;
              }
              while ( v40 >= 0 );
            }
          }
          return v10;
        case 12:
          v44 = v10;
          v45 = v4;
          v46 = (int)(v7 - 4);
          goto LABEL_43;
        case 13:
          v46 = (int)(v7 - 3);
          v49 = v4 - 1;
          if ( *(_BYTE *)v14 )
          {
            if ( *(_BYTE *)v14 == 1 )
            {
              v50 = "";
              v51 = (char *)v14 + v4;
              while ( 1 )
              {
                v52 = (unsigned __int8 *)&v51[-v49];
                v49 -= 4;
                if ( v49 < 0 )
                  break;
                v53 = sub_2475C(v13, v50, v52);
                v50 = " ";
                v13 += v53;
              }
            }
          }
          else
          {
            v44 = v10;
            v45 = v4 - 1;
LABEL_43:
            v47 = (char *)sub_25D4C(v46, v45, v44);
            if ( v47 )
            {
              v48 = v10;
              v10 = v47;
              free(v48);
            }
          }
          return v10;
        default:
LABEL_9:
          v4 -= v6;
          v7 += v6;
          if ( v6 > v4 )
            return v10;
          *v13++ = 32;
          *v13 = 0;
          continue;
      }
      do
      {
        while ( 1 )
        {
          do
          {
            do
            {
              v19 = v18;
              v21 = (unsigned __int8)*v18++;
              v20 = v21;
            }
            while ( (v21 | 0x20u) - 97 <= 0x19 );
          }
          while ( (unsigned int)(v20 - 48) <= 9 );
          v22 = v20 == 46;
          if ( v20 != 46 )
            v22 = v20 == 0;
          if ( !v22 )
            break;
          if ( v20 )
          {
            v18 = v19 + 1;
            if ( v19[1] )
              continue;
          }
          return v10;
        }
        v23 = v20 == 45;
        if ( v20 != 45 )
          v23 = v20 == 95;
      }
      while ( v23 );
      sub_60B34(v13, "bad", v4);
    }
    return v10;
  }
}
// 249C0: control flows out of bounds to 249C4
// 66EEC: using guessed type unsigned __int8 byte_66EEC[14];
// 67678: using guessed type _BYTE byte_67678[14];

//----- (00024D00) --------------------------------------------------------
void __fastcall sub_24D00(int a1, const char *a2)
{
  char v3; // r7
  int v4; // r6
  unsigned int v5; // r5
  unsigned __int8 *v6; // r0
  char **v7; // r6
  char *v8; // r0
  char **v9; // r5
  char *v10; // r8
  char *v11; // r8
  char *v12; // r0
  char *v13; // r0
  unsigned __int8 *v14; // r8
  const char *i; // r7
  int v16; // r7
  unsigned int v17; // r2
  unsigned __int8 *v18; // r0
  int v19; // r11
  unsigned __int8 *v20; // r9
  char *v21; // r8
  int v22; // r0
  char **v23; // r5
  char *v24; // r4
  char *v25; // t1
  unsigned int v26; // r9
  int v27; // r1
  const char **v28; // r3
  int v29; // r2
  char **v30; // r10
  int v31; // r2
  int v32; // r1
  char *v33; // r0
  int v34; // r1
  unsigned int j; // r3
  char *v36; // r0
  unsigned __int8 *v38; // [sp+Ch] [bp-28h]
  const char *s[9]; // [sp+10h] [bp-24h] BYREF

  memset(s, 0, 0x20u);
  if ( a1 )
  {
    v5 = 1;
    v4 = 6;
    v3 = 0;
    do
    {
      v6 = sub_26BB4((unsigned __int8 *)a1, v5);
      if ( v6 )
      {
        if ( v5 == 52 )
        {
          v3 |= *v6;
        }
        else if ( v5 == 1 )
        {
          ++v4;
        }
        ++v4;
        s[v5 >> 5] = (const char *)((unsigned int)s[v5 >> 5] | (1 << (v5 & 0x1F)));
      }
      ++v5;
    }
    while ( v5 != 255 );
  }
  else
  {
    v3 = 0;
    v4 = 6;
  }
  v7 = (char **)sub_174DC(4 * v4);
  v8 = sub_177E4("interface=%s", (const char *)dword_7D9BC);
  *v7 = v8;
  putenv(v8);
  if ( a1 )
  {
    v9 = v7 + 2;
    v10 = (char *)sub_1748C(0x13u);
    v7[1] = v10;
    sub_2475C(v10, "ip=", (unsigned __int8 *)(a1 + 16));
    putenv(v10);
    if ( *(_DWORD *)(a1 + 20) )
    {
      v9 = v7 + 3;
      v11 = (char *)sub_1748C(0x17u);
      v7[2] = v11;
      sub_2475C(v11, "siaddr=", (unsigned __int8 *)(a1 + 20));
      putenv(v11);
    }
    if ( (v3 & 1) == 0 && *(_BYTE *)(a1 + 108) )
    {
      v12 = sub_177E4("boot_file=%.128s", (const char *)(a1 + 108));
      *v9++ = v12;
      putenv(v12);
    }
    if ( (v3 & 2) == 0 && *(_BYTE *)(a1 + 44) )
    {
      v13 = sub_177E4("sname=%.64s", (const char *)(a1 + 44));
      *v9++ = v13;
      putenv(v13);
    }
    v14 = (unsigned __int8 *)&unk_67633;
    for ( i = "subnet"; *i; i += strlen(i) + 1 )
    {
      v26 = *v14;
      v27 = 1 << (v26 & 0x1F);
      v28 = &s[(v26 >> 5) + 8];
      v29 = (int)*(v28 - 8);
      if ( (v27 & v29) != 0 )
      {
        v31 = v29 & ~v27;
        v32 = *v14;
        *(v28 - 8) = (const char *)v31;
        v38 = sub_26BB4((unsigned __int8 *)a1, v32);
        v33 = sub_24928((int)v38, *(v14 - 1), i);
        *v9 = v33;
        v30 = v9 + 1;
        putenv(v33);
        if ( v26 == 1 && *(v38 - 1) == 4 )
        {
          v34 = 0;
          for ( j = bswap32(*(_DWORD *)v38); j; j *= 2 )
            ++v34;
          v30 = v9 + 2;
          v36 = sub_177E4("mask=%u", v34);
          v9[1] = v36;
          putenv(v36);
        }
      }
      else
      {
        v30 = v9;
      }
      v14 += 2;
      v9 = v30;
    }
    v16 = *(unsigned __int8 *)i;
    do
    {
      v17 = (unsigned int)s[(unsigned int)v16 >> 5];
      if ( v17 )
      {
        if ( (v17 & (1 << (v16 & 0x1F))) != 0 )
        {
          v18 = sub_26BB4((unsigned __int8 *)a1, v16);
          v19 = *(v18 - 1);
          v20 = v18;
          v21 = (char *)sub_1748C(2 * v19 + 9);
          *v9++ = v21;
          v22 = sprintf(v21, "opt%u=", v16);
          *(_BYTE *)sub_16FB4((int)&v21[v22], v20, v19) = 0;
          putenv(v21);
        }
        ++v16;
      }
      else
      {
        v16 += 32;
      }
    }
    while ( v16 <= 255 );
  }
  if ( dword_7DBAC )
    sub_16DDC("executing %s %s", (const char *)dword_7D9C4, a2);
  v23 = v7 - 1;
  s[0] = (const char *)dword_7D9C4;
  s[1] = a2;
  s[2] = 0;
  sub_61B38(s);
  while ( 1 )
  {
    v25 = v23[1];
    ++v23;
    v24 = v25;
    if ( !v25 )
      break;
    if ( (unsigned int)dword_7DBAC > 1 )
      sub_16DDC(" %s", v24);
    sub_178AC(v24);
  }
  free(v7);
}
// 7D9BC: using guessed type int dword_7D9BC;
// 7D9C4: using guessed type int dword_7D9C4;
// 7DBAC: using guessed type int dword_7DBAC;

//----- (000250B8) --------------------------------------------------------
ssize_t __fastcall sub_250B8(int a1, int a2)
{
  __int64 v4; // r0
  _BYTE v6[12]; // [sp+Ch] [bp-278h] BYREF
  int v7; // [sp+18h] [bp-26Ch]

  sub_240E8((int)v6, 7u);
  HIDWORD(v4) = 54;
  LODWORD(v4) = v6;
  v7 = a2;
  sub_26D7C(v4, a1);
  sub_16DDC("sending %s", "release");
  if ( a1 )
    return sub_26400(v6, a2, 0x44u, a1, 0x43u);
  else
    return sub_24274(v6, a2);
}

//----- (00025138) --------------------------------------------------------
void __fastcall sub_25138(int a1, int a2, int a3, int a4)
{
  char *v6; // r0
  char *v7; // r0
  _DWORD v8[4]; // [sp+0h] [bp-10h] BYREF

  v8[0] = a1;
  v8[1] = a2;
  v8[2] = a3;
  v8[3] = a4;
  if ( (unsigned int)(dword_7D630 - 2) <= 3 )
  {
    v6 = inet_ntoa((struct in_addr)a1);
    strcpy((char *)v8, v6);
    v7 = inet_ntoa((struct in_addr)a2);
    sub_16DDC("unicasting a release of %s to %s", v7, (const char *)v8);
    sub_250B8(a1, a2);
  }
  sub_16DDC("entering released state");
  sub_24D00(0, "deconfig");
  sub_24794(0);
  dword_7D630 = 6;
}
// 7D630: using guessed type int dword_7D630;

//----- (000251CC) --------------------------------------------------------
int __fastcall sub_251CC(int a1, char **a2)
{
  unsigned int v2; // r6
  int s_addr; // r8
  _BYTE *i; // r2
  unsigned int v5; // r0
  bool v6; // zf
  char v7; // r1
  unsigned int v8; // r3
  const char *v9; // r0
  char *v10; // r11
  int v11; // r11
  int v12; // r4
  int v13; // r5
  __sighandler_t v14; // r0
  int v15; // r1
  int v16; // r2
  unsigned int v17; // r0
  unsigned int v18; // r7
  int v19; // r10
  int v20; // r0
  int v21; // r1
  int v22; // r2
  int v23; // r2
  int v24; // r3
  int v25; // r9
  int v26; // r2
  int v27; // r0
  int v28; // r1
  int v29; // r2
  int v30; // r0
  int v31; // r2
  int v32; // r3
  _BOOL4 v33; // r3
  int v35; // r3
  int v36; // r0
  int v37; // r1
  int v38; // r2
  int v39; // r10
  int v40; // r10
  unsigned __int8 *v41; // r0
  unsigned __int8 *v42; // r0
  int v43; // r3
  unsigned __int8 *v44; // r0
  unsigned int v45; // r4
  unsigned int v46; // r3
  char *v47; // r0
  unsigned int v48; // r2
  unsigned int v49; // r4
  int v50; // r0
  int v51; // r1
  int v52; // r2
  int v53; // r7
  const char *v54; // r1
  int v55; // r0
  int v56; // r1
  int v57; // r2
  unsigned __int8 *v58; // r0
  int v59; // [sp+3Ch] [bp-34h]
  int v60; // [sp+40h] [bp-30h]
  char *s2; // [sp+44h] [bp-2Ch]
  int s2a; // [sp+44h] [bp-2Ch]
  int v63; // [sp+48h] [bp-28h]
  unsigned int v64; // [sp+4Ch] [bp-24h]
  const char *v65; // [sp+5Ch] [bp-14h] BYREF
  const void *v66; // [sp+60h] [bp-10h] BYREF
  const void *v67; // [sp+64h] [bp-Ch] BYREF
  char *cp; // [sp+68h] [bp-8h] BYREF
  const char *v69; // [sp+6Ch] [bp-4h] BYREF
  _DWORD *v70; // [sp+70h] [bp+0h] BYREF
  _DWORD *v71; // [sp+74h] [bp+4h] BYREF
  int v72; // [sp+78h] [bp+8h] BYREF
  unsigned int seconds; // [sp+7Ch] [bp+Ch] BYREF
  int v74; // [sp+80h] [bp+10h] BYREF
  struct pollfd fds; // [sp+84h] [bp+14h] BYREF
  __int16 v76; // [sp+92h] [bp+22h]
  int v77; // [sp+94h] [bp+24h] BYREF
  int n_2; // [sp+98h] [bp+28h]
  struct in_addr in; // [sp+A4h] [bp+34h]
  _BYTE s1[600]; // [sp+B0h] [bp+40h] BYREF

  v69 = "2000";
  v72 = 20;
  seconds = 3;
  v74 = 3;
  v70 = 0;
  v71 = 0;
  dword_7D9BC = (int)"eth0";
  dword_7D9C4 = (int)"/etc/udhcpc/default.script";
  v65 = "udhcp 1.29.3";
  v2 = sub_593F8(
         a2,
         "^CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fBba::v",
         "clientid-none",
         &v65,
         &v66,
         &v66,
         &v67,
         &dword_7D9BC,
         &dword_7D9C0,
         &cp,
         &dword_7D9C4,
         &seconds,
         &v74,
         &v72,
         &v70,
         &v71,
         &v69,
         &dword_7DBAC);
  if ( (v2 & 0xC) != 0 )
  {
    sub_16DDC("option -h NAME is deprecated, use -x hostname:NAME");
    dword_7D9D4 = (int)sub_24094(12, v66, 0);
  }
  if ( (v2 & 0x10) != 0 )
  {
    dword_7D9D8 = (int)sub_24094(81, v67, 3);
    *(_BYTE *)(dword_7D9D8 + 2) = 1;
  }
  s_addr = v2 & 0x400;
  if ( (v2 & 0x400) != 0 )
    s_addr = inet_addr(cp);
  v64 = sub_620B0(v69);
  while ( v70 )
  {
    s2 = (char *)sub_5D2FC(&v70);
    v5 = sub_18990(s2, 0, 0);
    v6 = v5 == 254;
    if ( v5 <= 0xFE )
      v6 = *(_DWORD *)dword_7DB94 == 0;
    if ( !v6 )
      v5 = *((unsigned __int8 *)&unk_67632 + 2 * sub_26B2C(s2, "subnet") + 1);
    *((_BYTE *)&buf + (v5 >> 3) + 524) |= 1 << (v5 & 7);
  }
  if ( (v2 & 0x20000) == 0 )
  {
    for ( i = &unk_67633; ; i += 2 )
    {
      v8 = (unsigned __int8)*i;
      if ( !*i )
        break;
      v7 = *(i - 1);
      if ( (v7 & 0x10) != 0 )
        *((_BYTE *)&buf + (v8 >> 3) + 524) |= 1 << (v8 & 7);
    }
  }
  while ( v71 )
  {
    v9 = (const char *)sub_5D2FC(&v71);
    v10 = sub_174F8(v9);
    sub_27038(v10, (unsigned __int8 **)&dword_7D9C8, (int)&unk_67632, "subnet");
    free(v10);
  }
  s2a = sub_26644((const char *)dword_7D9BC, dword_7D998, 0, (unsigned __int8 *)&dword_7D990);
  if ( s2a )
    return 1;
  if ( (v2 & 1) != 0 || sub_26DE4((unsigned __int8 *)dword_7D9C8, 0x3Du) )
  {
    v11 = 0;
  }
  else
  {
    dword_7D9CC = (int)sub_24094(61, "", 7);
    *(_BYTE *)(dword_7D9CC + 2) = 1;
    v11 = dword_7D9CC + 3;
    *(_DWORD *)(dword_7D9CC + 3) = dword_7D990;
    *(_WORD *)(v11 + 4) = word_7D994;
  }
  if ( *v65 )
    dword_7D9D0 = (int)sub_24094(60, v65, 0);
  if ( (v2 & 0x4000) != 0 )
  {
    openlog((const char *)dword_7DB90, 1, 24);
    dword_7D4BC |= 2u;
  }
  sub_61C40();
  v12 = 0;
  sub_5E30C(dword_7D9C0);
  v13 = 0;
  sub_16DDC("started, v1.29.3");
  v14 = sub_26580();
  v17 = sub_187B0((int)v14, v15, v16);
  srand(v17);
  v18 = 0;
  dword_7D630 = 0;
  sub_24D00(0, "deconfig");
  sub_24794(2);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
LABEL_31:
        v19 = v12 - v18;
        v20 = sub_265C8((int)&fds, dword_7D4C8);
        if ( (int)(v12 - v18) <= 0 )
        {
LABEL_32:
          if ( sub_26644((const char *)dword_7D9BC, dword_7D998, 0, (unsigned __int8 *)&dword_7D990) )
            goto LABEL_97;
          if ( v11 )
          {
            *(_DWORD *)v11 = dword_7D990;
            *(_WORD *)(v11 + 4) = word_7D994;
          }
          switch ( dword_7D630 )
          {
            case 0:
              v33 = v74 > v13;
              if ( !v74 )
                v33 = 1;
              if ( !v33 )
                goto LABEL_70;
              if ( !v13 )
                v60 = rand();
              sub_242B0(v60, s_addr);
              goto LABEL_60;
            case 1:
              if ( v13 <= 2 )
              {
                sub_24318(v60, v59, s_addr);
LABEL_60:
                v12 = seconds;
                ++v13;
                goto LABEL_61;
              }
              sub_24794(2);
              dword_7D630 = 0;
LABEL_70:
              sub_24D00(0, "leasefail");
              if ( (v2 & 0x200000) != 0 )
              {
                v2 = v2 & 0xFFD7FFFF | 0x80000;
                sub_16DDC("no lease, forking to background");
                sub_24728();
              }
              else if ( (v2 & 0x40) != 0 )
              {
                sub_16DDC("no lease, failing");
                s2a = 1;
                goto LABEL_64;
              }
              v12 = v72;
              break;
            case 2:
              dword_7D630 = 3;
              word_7D9DC = 0;
              sub_24794(1);
              if ( dword_7DBAC )
              {
                sub_16DDC("entering renew state");
                goto LABEL_76;
              }
              if ( v12 <= 60 )
                goto LABEL_81;
              goto LABEL_77;
            case 3:
            case 5:
              goto LABEL_76;
            case 4:
              goto LABEL_82;
            default:
              v18 = 0;
              goto LABEL_95;
          }
          goto LABEL_73;
        }
        if ( dword_7DBAC )
          sub_16DDC("waiting %u seconds", v12 - v18);
        sub_1882C(v20, v21, v22);
        v25 = v20;
        if ( v19 > 2147482 )
          v26 = 0x7FFFFFFF;
        else
          v26 = 1000;
        if ( v19 <= 2147482 )
          v26 *= v19;
        v27 = poll(&fds, 2u, v26);
        if ( v27 >= 0 )
          break;
        if ( *(_DWORD *)dword_7DB94 != 4 )
          sub_16B40("poll");
        sub_1882C(v27, v28, v29);
        v18 = v27 + v18 - v25;
      }
      if ( !v27 )
        goto LABEL_32;
      v30 = sub_26614(v27, v28, v29);
      if ( v30 != 12 )
        break;
      sub_25138(v59, s_addr, v31, v32);
LABEL_95:
      v12 = 0x7FFFFFFF;
    }
    if ( v30 == 15 )
      break;
    if ( v30 == 10 )
    {
      word_7D9DC = 0;
      sub_16DDC("performing DHCP renew");
      switch ( dword_7D630 )
      {
        case 1:
        case 6:
          goto LABEL_93;
        case 2:
          sub_24794(1);
          goto LABEL_86;
        case 3:
        case 4:
LABEL_86:
          v35 = 5;
          goto LABEL_87;
        case 5:
          sub_24D00(0, "deconfig");
LABEL_93:
          sub_24794(2);
          v35 = 0;
LABEL_87:
          dword_7D630 = v35;
          break;
        default:
          break;
      }
      if ( dword_7D630 != 5 )
      {
        v12 = 0;
LABEL_73:
        v13 = 0;
        goto LABEL_61;
      }
      if ( v12 >= v72 )
        v12 = v72;
LABEL_76:
      if ( v12 > 60 )
      {
LABEL_77:
        if ( sub_243F4(v60, v59, s_addr) >= 0 )
          goto LABEL_78;
      }
      if ( dword_7DBAC )
        sub_16DDC("entering rebinding state");
LABEL_81:
      dword_7D630 = 4;
LABEL_82:
      sub_24794(2);
      if ( v12 > 0 )
      {
        sub_243F4(v60, 0, s_addr);
LABEL_78:
        v12 >>= 1;
        goto LABEL_61;
      }
      v13 = 0;
      sub_16DDC("lease lost, entering init state");
      sub_24D00(0, "deconfig");
      dword_7D630 = 0;
      word_7D9DC = 0;
LABEL_61:
      v18 = 0;
    }
    else if ( v76 )
    {
      if ( dword_7D62C == 1 )
        v36 = sub_26190(&v77, dword_7D4C8);
      else
        v36 = sub_24478(&v77, dword_7D4C8);
      v39 = v36;
      if ( v36 == -1 )
      {
        sub_16DDC("read error: %m, reopening socket");
        sleep(seconds);
        sub_24794(dword_7D62C);
      }
      sub_1882C(v36, v37, v38);
      v18 = v36 + v18 - v25;
      if ( v39 >= 0 )
      {
        if ( n_2 == v60 )
        {
          if ( BYTE2(v77) == 6 && (v40 = memcmp(s1, &dword_7D990, 6u)) == 0 )
          {
            v41 = sub_26BB4((unsigned __int8 *)&v77, 53);
            if ( v41 )
            {
              v63 = dword_7D630;
              switch ( dword_7D630 )
              {
                case 0:
                  if ( *v41 != 2 )
                    goto LABEL_31;
                  v42 = sub_26CBC((unsigned __int8 *)&v77, 54);
                  if ( v42 )
                  {
                    v59 = *(_DWORD *)v42;
                  }
                  else
                  {
                    sub_16DDC("no server ID, using 0.0.0.0");
                    v59 = 0;
                  }
                  v12 = v63;
                  s_addr = in.s_addr;
                  dword_7D630 = 1;
                  v13 = v63;
                  goto LABEL_61;
                case 1:
                case 3:
                case 4:
                case 5:
                  v43 = *v41;
                  if ( v43 == 5 )
                  {
                    v44 = sub_26CBC((unsigned __int8 *)&v77, 51);
                    if ( v44 )
                    {
                      v45 = bswap32(*(_DWORD *)v44);
                      if ( v45 < 0x10 )
                        v45 = 16;
                    }
                    else
                    {
                      v45 = 3600;
                      sub_16DDC("no lease time with ACK, using 1 hour lease");
                    }
                    if ( (v2 & 0x400000) == 0
                      || sub_268C4(in.s_addr, 0, 0, &dword_7D990, (const char *)dword_7D9BC, v64) )
                    {
                      v47 = inet_ntoa(in);
                      v48 = v45;
                      v49 = v45 >> 1;
                      sub_16DDC("lease of %s obtained, lease time %u", v47, v48);
                      s_addr = in.s_addr;
                      sub_1882C(v50, v51, v52);
                      v53 = v50;
                      if ( dword_7D630 == 1 )
                        v54 = "bound";
                      else
                        v54 = "renew";
                      sub_24D00((int)&v77, v54);
                      sub_1882C(v55, v56, v57);
                      v18 = v55 - v53;
                      if ( v49 < v18 )
                        v18 = 0;
                      else
                        v40 = v49;
                      dword_7D630 = 2;
                      sub_24794(0);
                      if ( (v2 & 0x100) != 0 )
                        goto LABEL_97;
                      v46 = v2 & 0xFFFFFFBF;
                      if ( (v2 & 0x80000) == 0 )
                      {
                        sub_24728();
                        v46 = v2 & 0xFFD7FFBF | 0x80000;
                      }
                    }
                    else
                    {
                      sub_16DDC("offered address is in use (got ARP reply), declining");
                      sub_24390(v59, in.s_addr);
                      if ( dword_7D630 != 1 )
                        sub_24D00(0, "deconfig");
                      v13 = 0;
                      sub_24794(2);
                      v18 = 0;
                      dword_7D630 = 0;
                      s_addr = 0;
                      word_7D9DC = 0;
                      v46 = v2;
                      v40 = v72;
                    }
                    v2 = v46;
                    v12 = v40;
                  }
                  else if ( v43 == 6 )
                  {
                    if ( !v59 || (v58 = sub_26CBC((unsigned __int8 *)&v77, 54)) != 0 && *(_DWORD *)v58 == v59 )
                    {
                      sub_16DDC("received %s", "DHCP NAK");
                      sub_24D00((int)&v77, "nak");
                      if ( dword_7D630 != 1 )
                        sub_24D00(0, "deconfig");
                      v12 = 0;
                      sub_24794(2);
                      v13 = 0;
                      sleep(3u);
                      v18 = 0;
                      dword_7D630 = 0;
                      s_addr = 0;
                      word_7D9DC = 0;
                    }
                    else if ( dword_7DBAC )
                    {
                      sub_16DDC("received DHCP NAK with wrong server ID, ignoring packet");
                    }
                  }
                  break;
                default:
                  goto LABEL_31;
              }
            }
            else
            {
              sub_16DDC("no message type option, ignoring packet");
            }
          }
          else if ( dword_7DBAC )
          {
            sub_16DDC("chaddr does not match, ignoring packet");
          }
        }
        else if ( dword_7DBAC )
        {
          sub_16DDC("xid %x (our is %x), ignoring packet", n_2, v60);
        }
      }
    }
  }
  sub_16DDC("received %s", "SIGTERM");
LABEL_97:
  if ( (v2 & 0x200) != 0 )
    sub_25138(v59, s_addr, v23, v24);
LABEL_64:
  if ( dword_7DBC8 )
    unlink((const char *)dword_7D9C0);
  return s2a;
}
// 2552C: control flows out of bounds to 25530
// 25658: control flows out of bounds to 2565C
// 259C0: control flows out of bounds to 259C4
// 25498: variable 'v15' is possibly undefined
// 25498: variable 'v16' is possibly undefined
// 255B0: variable 'v20' is possibly undefined
// 255B0: variable 'v21' is possibly undefined
// 255B0: variable 'v22' is possibly undefined
// 255F8: variable 'v28' is possibly undefined
// 255F8: variable 'v29' is possibly undefined
// 256AC: variable 'v60' is possibly undefined
// 25714: variable 'v59' is possibly undefined
// 25888: variable 'v31' is possibly undefined
// 25888: variable 'v32' is possibly undefined
// 258B0: variable 'v23' is possibly undefined
// 258B0: variable 'v24' is possibly undefined
// 2590C: variable 'v36' is possibly undefined
// 2590C: variable 'v37' is possibly undefined
// 2590C: variable 'v38' is possibly undefined
// 25B2C: variable 'v50' is possibly undefined
// 25B2C: variable 'v51' is possibly undefined
// 25B2C: variable 'v52' is possibly undefined
// 25B54: variable 'v55' is possibly undefined
// 25B54: variable 'v56' is possibly undefined
// 25B54: variable 'v57' is possibly undefined
// 7D4BC: using guessed type int dword_7D4BC;
// 7D4C8: using guessed type int dword_7D4C8;
// 7D62C: using guessed type int dword_7D62C;
// 7D630: using guessed type int dword_7D630;
// 7D990: using guessed type int dword_7D990;
// 7D994: using guessed type __int16 word_7D994;
// 7D998: using guessed type int dword_7D998[9];
// 7D9BC: using guessed type int dword_7D9BC;
// 7D9C0: using guessed type int dword_7D9C0;
// 7D9C4: using guessed type int dword_7D9C4;
// 7D9C8: using guessed type int dword_7D9C8;
// 7D9CC: using guessed type int dword_7D9CC;
// 7D9D0: using guessed type int dword_7D9D0;
// 7D9D4: using guessed type int dword_7D9D4;
// 7D9D8: using guessed type int dword_7D9D8;
// 7D9DC: using guessed type __int16 word_7D9DC;
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;
// 7DBAC: using guessed type int dword_7DBAC;
// 7DBC8: using guessed type int dword_7DBC8;

//----- (00025D4C) --------------------------------------------------------
void *__fastcall sub_25D4C(int a1, unsigned int a2, const char *a3)
{
  void *v3; // r10
  int v5; // r7
  unsigned int v6; // r5
  unsigned int v7; // r9
  int v8; // r6
  unsigned int v9; // r4
  size_t v10; // r0
  size_t v11; // r8
  int v12; // r1
  unsigned int v13; // r4
  bool v15; // cc

  v3 = 0;
  v5 = 0;
  while ( 2 )
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    while ( a2 > v9 )
    {
      v11 = *(unsigned __int8 *)(a1 + v9);
      v12 = a1 + v9;
      if ( (v11 & 0xC0) == 0xC0 )
      {
        v13 = v9 + 2;
        if ( v13 > a2 )
          return 0;
        if ( !v8 )
          v8 = v13;
        ++v7;
        v9 = ((_WORD)v11 << 8) & 0x3F00 | *(unsigned __int8 *)(v12 + 1);
      }
      else if ( *(_BYTE *)(a1 + v9) )
      {
        v9 += 1 + v11;
        if ( v9 > a2 )
          return 0;
        if ( v5 )
          *((_BYTE *)memcpy((void *)(v5 + v6), (const void *)(v12 + 1), v11) + v11) = 46;
        v6 += v11 + 1;
      }
      else
      {
        if ( v8 )
        {
          v9 = v8;
          v7 = 0;
        }
        else
        {
          ++v9;
        }
        v8 = v6;
        if ( v6 )
          v8 = 1;
        if ( !v5 )
          v8 = 0;
        if ( v8 )
        {
          *(_BYTE *)(v5 + v6 - 1) = 32;
          v8 = 0;
        }
      }
      v15 = v6 > 0x1806;
      if ( v6 <= 0x1806 )
        v15 = v7 > 6;
      if ( v15 )
        return 0;
    }
    if ( !v6 )
      return 0;
    if ( !v5 )
    {
      v10 = strlen(a3);
      v3 = sub_1748C(v6 + v10);
      v5 = stpcpy(v3, a3);
      continue;
    }
    break;
  }
  *(_BYTE *)(v5 + v6 - 1) = 0;
  return v3;
}
// 1372C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);

//----- (00025EA0) --------------------------------------------------------
char *__fastcall sub_25EA0(int a1, int a2, char *s, _DWORD *a4)
{
  char *v5; // r5
  size_t v6; // r0
  char *v7; // r4
  _BYTE *v8; // r1
  _BYTE *i; // lr
  int v10; // r3
  int v11; // t1
  _BYTE *v12; // r12
  bool v13; // zf
  int v14; // r2
  _BOOL4 v15; // r0
  char *j; // r5
  int v18; // r10
  int v19; // r6
  int v20; // r8
  unsigned __int8 *v21; // r7
  char *v22; // r3
  size_t v23; // r9
  __int16 v24; // r2
  __int16 v25; // t1
  char *v28; // [sp+Ch] [bp-8h]

  v5 = s;
  v6 = strlen(s);
  v7 = (char *)sub_1748C(v6 + 2);
  v8 = v7 + 1;
  for ( i = v7; ; i = v12 )
  {
    v11 = (unsigned __int8)*v5++;
    v10 = v11;
    v12 = v8;
    v13 = v11 == 0;
    if ( v11 )
      v13 = v10 == 46;
    if ( !v13 )
    {
      v12 = i;
      if ( (unsigned int)(v10 - 65) <= 0x19 )
        LOBYTE(v10) = v10 + 32;
      *v8 = v10;
      goto LABEL_16;
    }
    v14 = v8 - i - 1;
    v15 = v8 - i == 1;
    if ( v14 > 63 )
      v15 = 1;
    if ( v15 || v10 == 46 && *v5 == 46 )
      goto LABEL_11;
    *i = v14;
    if ( !v10 || !*v5 )
      break;
LABEL_16:
    ++v8;
  }
  if ( v8 - v7 > 254 )
  {
LABEL_11:
    free(v7);
LABEL_12:
    v7 = 0;
    *a4 = 0;
    return v7;
  }
  *v8 = 0;
  if ( !v7 )
    goto LABEL_12;
  for ( j = v7; ; j += v18 + 1 )
  {
    v18 = (unsigned __int8)*j;
    if ( !*j )
      break;
    if ( a1 )
    {
      v19 = 0;
LABEL_28:
      while ( a2 > v19 )
      {
        v20 = *(unsigned __int8 *)(a1 + v19);
        v21 = (unsigned __int8 *)(a1 + v19);
        if ( (v20 & 0xC0) == 0xC0 )
        {
          v19 += 2;
        }
        else
        {
          if ( *(_BYTE *)(a1 + v19) )
          {
            v22 = j;
            while ( 1 )
            {
              v28 = v22;
              v23 = *v21 + 1;
              if ( memcmp(v21, v22, v23) )
              {
                v19 += v20 + 1;
                goto LABEL_28;
              }
              if ( v23 == 1 )
                break;
              v25 = v21[v23];
              v21 += v23;
              v24 = v25;
              v22 = &v28[v23];
              if ( (v25 & 0xC0) == 0xC0 )
                v21 = (unsigned __int8 *)(a1 + ((v24 << 8) & 0x3F00 | v21[1]));
            }
            if ( v19 >= 0 )
            {
              *++j = v19;
              *(j - 1) = BYTE1(v19) | 0xC0;
              goto LABEL_42;
            }
            break;
          }
          ++v19;
        }
      }
    }
  }
LABEL_42:
  *a4 = j - v7 + 1;
  return v7;
}

//----- (00026090) --------------------------------------------------------
void __fastcall sub_26090(void *a1, unsigned int a2)
{
  __int64 v3; // r0

  LODWORD(v3) = memset(a1, 0, 0x274u);
  *(_BYTE *)v3 = 1;
  if ( a2 <= 6 && ((1 << a2) & 0x64) != 0 )
    *(_BYTE *)v3 = 2;
  *(_BYTE *)(v3 + 1) = 1;
  *(_BYTE *)(v3 + 2) = 6;
  *(_BYTE *)(v3 + 236) = 99;
  *(_BYTE *)(v3 + 237) = -126;
  *(_BYTE *)(v3 + 239) = 99;
  *(_BYTE *)(v3 + 240) = -1;
  *(_BYTE *)(v3 + 238) = 83;
  HIDWORD(v3) = 53;
  sub_26D7C(v3, a2);
}

//----- (00026110) --------------------------------------------------------
void __fastcall sub_26110(int a1)
{
  char v2[44]; // [sp+14h] [bp-2Ch] BYREF

  if ( (unsigned int)dword_7DBAC > 1 )
  {
    sub_16DDC(
      " hlen %x xid %x ciaddr %x yiaddr %x siaddr %x giaddr %x",
      *(unsigned __int8 *)(a1 + 2),
      *(_DWORD *)(a1 + 4),
      *(_DWORD *)(a1 + 12),
      *(_DWORD *)(a1 + 16),
      *(_DWORD *)(a1 + 20),
      *(_DWORD *)(a1 + 24));
    *(_BYTE *)sub_16FB4((int)v2, (unsigned __int8 *)(a1 + 28), 16) = 0;
    sub_16DDC(" chaddr %s", v2);
  }
}
// 7DBAC: using guessed type int dword_7DBAC;

//----- (00026190) --------------------------------------------------------
int __fastcall sub_26190(_DWORD *a1, int a2)
{
  ssize_t v4; // r0
  int v5; // r4

  memset(a1, 0, 0x274u);
  v4 = sub_1800C(a2, a1, 0x274u);
  v5 = v4;
  if ( v4 >= 0 )
  {
    if ( v4 > 239 && a1[59] == 1666417251 )
    {
      if ( dword_7DBAC )
        sub_16DDC("received %s", "a packet");
      sub_26110((int)a1);
    }
    else
    {
      v5 = -2;
      sub_16DDC("packet with bad magic, ignoring");
    }
  }
  else if ( dword_7DBAC )
  {
    sub_16DDC("packet read error, ignoring");
  }
  return v5;
}
// 7DBAC: using guessed type int dword_7DBAC;

//----- (00026248) --------------------------------------------------------
ssize_t __fastcall sub_26248(const void *a1, int a2, unsigned int a3, int a4, unsigned int a5, int *a6, int a7)
{
  int v11; // r6
  int v12; // r0
  const char *v13; // r5
  ssize_t v14; // r4
  __int16 v15; // r4
  unsigned int v16; // r0
  size_t v17; // r9
  __int16 v18; // r4
  struct sockaddr addr; // [sp+Ch] [bp-2A8h] BYREF
  int v21; // [sp+1Ch] [bp-298h]
  _DWORD s[7]; // [sp+20h] [bp-294h] BYREF
  _BYTE dest[632]; // [sp+3Ch] [bp-278h] BYREF

  v11 = socket(17, 2, 8);
  if ( v11 < 0 )
  {
    v14 = -1;
    sub_16AF4("socket(%s)", "PACKET");
  }
  else
  {
    *(_DWORD *)&addr.sa_data[6] = 0;
    *(_DWORD *)&addr.sa_data[10] = 0;
    v21 = 0;
    memset(s, 0, sizeof(s));
    memcpy(dest, a1, 0x274u);
    v12 = *a6;
    *(_DWORD *)&addr.sa_family = 524305;
    *(_DWORD *)&addr.sa_data[10] = v12;
    *(_DWORD *)&addr.sa_data[2] = a7;
    addr.sa_data[9] = 6;
    LOWORD(v21) = *((_WORD *)a6 + 2);
    if ( bind(v11, &addr, 0x14u) >= 0 )
    {
      v15 = __rev16(a3);
      v16 = 307 - sub_26CDC((int)&dest[240]);
      BYTE1(s[2]) = 17;
      if ( v16 >= 0xF8 )
        v16 = 248;
      LOWORD(s[5]) = v15;
      v17 = 576 - v16;
      s[3] = a2;
      HIWORD(s[5]) = __rev16(a5);
      LOWORD(s[6]) = __rev16(556 - (unsigned __int16)v16);
      HIWORD(s[0]) = s[6];
      s[4] = a4;
      v18 = __rev16(576 - (unsigned __int16)v16);
      HIWORD(s[6]) = sub_5A500((unsigned __int16 *)s, 576 - v16);
      LOBYTE(s[0]) = 69;
      LOBYTE(s[2]) = 64;
      HIWORD(s[0]) = v18;
      HIWORD(s[2]) = sub_5A500((unsigned __int16 *)s, 20);
      sub_26110((int)a1);
      v13 = "sendto";
      v14 = sendto(v11, s, v17, 0, &addr, 0x14u);
    }
    else
    {
      v13 = "bind(%s)";
      v14 = -1;
    }
    close(v11);
    if ( v14 < 0 )
      sub_16AF4(v13, "PACKET");
  }
  return v14;
}

//----- (00026400) --------------------------------------------------------
int __fastcall sub_26400(void *a1, int a2, unsigned int a3, int a4, unsigned int a5)
{
  int v9; // r0
  int v10; // r6
  int v11; // r4
  const char *v12; // r5
  unsigned int v13; // r0
  int v14; // r2
  struct sockaddr v16; // [sp+0h] [bp-10h] BYREF

  *(_DWORD *)&v16.sa_family = a1;
  *(_DWORD *)&v16.sa_data[2] = a2;
  *(_DWORD *)&v16.sa_data[6] = a3;
  *(_DWORD *)&v16.sa_data[10] = a4;
  v9 = socket(2, 2, 17);
  v10 = v9;
  if ( v9 < 0 )
  {
    v11 = -1;
    sub_16AF4("socket(%s)", "UDP");
  }
  else
  {
    sub_62414(v9);
    *(_DWORD *)&v16.sa_data[6] = 0;
    *(_DWORD *)&v16.sa_data[10] = 0;
    *(_WORD *)v16.sa_data = __rev16(a3);
    v16.sa_family = 2;
    *(_DWORD *)&v16.sa_data[2] = a2;
    v11 = bind(v10, &v16, 0x10u);
    if ( v11 == -1 )
    {
      v12 = "bind(%s)";
    }
    else
    {
      *(_DWORD *)&v16.sa_data[6] = 0;
      *(_DWORD *)&v16.sa_data[10] = 0;
      v16.sa_family = 2;
      *(_WORD *)v16.sa_data = __rev16(a5);
      *(_DWORD *)&v16.sa_data[2] = a4;
      v11 = connect(v10, &v16, 0x10u);
      if ( v11 == -1 )
      {
        v12 = "connect";
      }
      else
      {
        v12 = "write";
        sub_26110((int)a1);
        v13 = 307 - sub_26CDC((int)a1 + 240);
        if ( v13 >= 0xF8 )
          v14 = 248;
        else
          v14 = v13;
        v11 = sub_180F4(v10, a1, 548 - v14);
      }
    }
    close(v10);
    if ( v11 < 0 )
      sub_16AF4(v12, "UDP");
  }
  return v11;
}

//----- (00026530) --------------------------------------------------------
void __fastcall sub_26530(char a1, int a2, int a3)
{
  _DWORD *v3; // r4
  int v4; // r5
  char v5; // [sp+7h] [bp-5h] BYREF
  int v6; // [sp+8h] [bp-4h]

  v5 = HIBYTE(a2);
  v6 = a3;
  v3 = (_DWORD *)dword_7DB94;
  v4 = *(_DWORD *)dword_7DB94;
  v5 = a1;
  if ( write(dword_7D638, &v5, 1u) != 1 )
    sub_16AF4("can't send signal");
  *v3 = v4;
}
// 7D638: using guessed type int dword_7D638;
// 7DB94: using guessed type int dword_7DB94;

//----- (00026580) --------------------------------------------------------
__sighandler_t sub_26580()
{
  sub_1766C(&dword_7D634);
  sub_16E9C(dword_7D634);
  sub_16E9C(dword_7D638);
  sub_16E34(dword_7D634);
  sub_16E34(dword_7D638);
  return sub_18184((__sighandler_t)0x9400, (void (*)(int))sub_26530);
}
// 7D634: using guessed type int dword_7D634;
// 7D638: using guessed type int dword_7D638;

//----- (000265C8) --------------------------------------------------------
int __fastcall sub_265C8(int result, int a2)
{
  int v3; // r4
  int v4; // r3

  v3 = result;
  v4 = dword_7D634;
  *(_WORD *)(result + 4) = 1;
  *(_DWORD *)result = v4;
  *(_DWORD *)(result + 8) = -1;
  if ( a2 >= 0 )
  {
    result = sub_16E9C(a2);
    *(_DWORD *)(v3 + 8) = a2;
    *(_WORD *)(v3 + 12) = 1;
  }
  *(_WORD *)(v3 + 14) = 0;
  return result;
}
// 7D634: using guessed type int dword_7D634;

//----- (00026614) --------------------------------------------------------
int __fastcall sub_26614(int a1, int a2, int a3)
{
  unsigned __int8 buf; // [sp+7h] [bp-5h] BYREF
  int v5; // [sp+8h] [bp-4h]

  buf = HIBYTE(a2);
  v5 = a3;
  if ( sub_1800C(dword_7D634, &buf, 1u) == 1 )
    return buf;
  else
    return 0;
}
// 7D634: using guessed type int dword_7D634;

//----- (00026644) --------------------------------------------------------
int __fastcall sub_26644(const char *a1, _DWORD *a2, _DWORD *a3, unsigned __int8 *a4)
{
  int v8; // r5
  struct in_addr v10; // r0
  char *v11; // r0
  __int16 v12; // r3
  _DWORD s[8]; // [sp+10h] [bp-20h] BYREF

  memset(s, 0, sizeof(s));
  v8 = sub_179A4(2, 3, 255);
  LOWORD(s[4]) = 2;
  sub_16EA8((char *)s, a1);
  if ( !a3 )
    goto LABEL_7;
  if ( !sub_17AA0(v8, 0x8915u, (int)s, "is interface %s up and configured?", a1) )
  {
    v10.s_addr = s[5];
    *a3 = s[5];
    if ( dword_7DBAC )
    {
      v11 = inet_ntoa(v10);
      sub_16DDC("IP %s", v11);
    }
LABEL_7:
    if ( a2 )
    {
      if ( sub_17AF4(v8, 0x8933u, (int)s, "SIOCGIFINDEX") )
        goto LABEL_3;
      if ( (unsigned int)dword_7DBAC > 1 )
        sub_16DDC("ifindex %d", s[4]);
      *a2 = s[4];
    }
    if ( a4 )
    {
      if ( sub_17AF4(v8, 0x8927u, (int)s, "SIOCGIFHWADDR") )
        goto LABEL_3;
      v12 = HIWORD(s[5]);
      *(_DWORD *)a4 = *(_DWORD *)((char *)&s[4] + 2);
      *((_WORD *)a4 + 2) = v12;
      if ( (unsigned int)dword_7DBAC > 1 )
        sub_16DDC("MAC %02x:%02x:%02x:%02x:%02x:%02x", *a4, a4[1], a4[2], a4[3], a4[4], a4[5]);
    }
    close(v8);
    return 0;
  }
LABEL_3:
  close(v8);
  return -1;
}
// 7DBAC: using guessed type int dword_7DBAC;

//----- (000267E0) --------------------------------------------------------
int __fastcall sub_267E0(unsigned int a1, const char *a2)
{
  int v4; // r4
  int v5; // r0
  char *v6; // r6
  char v7; // r3
  __int16 v8; // r5
  struct sockaddr v10; // [sp+0h] [bp-14h] BYREF

  if ( dword_7DBAC )
    sub_16DDC("opening listen socket on *:%d %s", a1, a2);
  v4 = sub_179A4(2, 2, 17);
  sub_62414(v4);
  sub_6241C();
  if ( v5 == -1 )
    sub_16B40("SO_BROADCAST");
  v6 = strrchr(a2, 58);
  if ( v6 )
    *v6 = 0;
  if ( sub_62424(v4, a2) )
    sub_16E08();
  if ( v6 )
    v7 = 58;
  v8 = __rev16(a1);
  if ( v6 )
    *v6 = v7;
  memset(&v10.sa_data[2], 0, 12);
  v10.sa_family = 2;
  *(_WORD *)v10.sa_data = v8;
  sub_179C0(v4, &v10, 0x10u);
  return v4;
}
// 26834: variable 'v5' is possibly undefined
// 26880: variable 'v7' is possibly undefined
// 7DBAC: using guessed type int dword_7DBAC;

//----- (000268C4) --------------------------------------------------------
int __fastcall sub_268C4(int a1, const void *a2, int a3, int *a4, const char *a5, unsigned int a6)
{
  int v6; // r4
  int v12; // r0
  const char *v13; // r1
  int v14; // r2
  __int16 v15; // r3
  __int64 v16; // r0
  int v17; // r2
  unsigned int v18; // r6
  int v19; // r4
  ssize_t v20; // r0
  int v21; // r1
  int v22; // r2
  struct pollfd fd; // [sp+Ch] [bp-58h] BYREF
  struct sockaddr v24; // [sp+14h] [bp-50h] BYREF
  int buf; // [sp+24h] [bp-40h] BYREF
  __int16 v26; // [sp+28h] [bp-3Ch]
  int v27; // [sp+2Ah] [bp-3Ah]
  __int16 v28; // [sp+2Eh] [bp-36h]
  int v29; // [sp+30h] [bp-34h]
  int v30; // [sp+34h] [bp-30h]
  __int16 v31; // [sp+38h] [bp-2Ch]
  int s2; // [sp+3Ah] [bp-2Ah] BYREF
  __int16 v33; // [sp+3Eh] [bp-26h]
  int v34; // [sp+40h] [bp-24h]
  _WORD s[14]; // [sp+44h] [bp-20h] BYREF

  if ( !a6 )
    return 1;
  v6 = socket(17, 10, 1544);
  fd.fd = v6;
  if ( v6 == -1 )
  {
    sub_16AF4("can't create raw socket");
  }
  else
  {
    sub_6241C();
    if ( v12 == -1 )
    {
      sub_16AF4("can't enable bcast on raw socket");
    }
    else
    {
      memset(s, 0, sizeof(s));
      v14 = *a4;
      buf = -1;
      v26 = -1;
      v15 = *((_WORD *)a4 + 2);
      v29 = 16778760;
      v30 = 67502088;
      v27 = v14;
      v31 = 256;
      s2 = v14;
      v28 = v15;
      v33 = v15;
      v34 = a3;
      *(_DWORD *)&s[3] = a1;
      memset(&v24, 0, sizeof(v24));
      sub_60B34(v24.sa_data, a5, 14);
      LODWORD(v16) = sendto(fd.fd, &buf, 0x3Cu, 0, &v24, 0x10u);
      if ( (int)v16 >= 0 )
      {
        v18 = a6;
        do
        {
          v19 = sub_187F0(v16, SHIDWORD(v16), v17);
          fd.events = 1;
          v20 = sub_60AD4(&fd, 1u, v18);
          if ( v20 < 0 )
            break;
          if ( v20 )
          {
            v20 = sub_1800C(fd.fd, &buf, 0x3Cu);
            if ( v20 < 0 )
              break;
            if ( v20 > 41 && v31 == 512 && v34 == a1 )
            {
              if ( !a2 || memcmp(a2, &s2, 6u) )
              {
                v6 = 0;
                goto LABEL_9;
              }
              break;
            }
          }
          v16 = sub_187F0(v20, v21, v22);
          v18 = v18 + v19 - 1 - v16;
        }
        while ( v18 <= a6 );
      }
    }
    v6 = 1;
LABEL_9:
    close(fd.fd);
    if ( dword_7DBAC )
    {
      v13 = "no a";
      if ( !v6 )
        v13 = "A";
      sub_16DDC("%srp reply received for this address", v13);
    }
  }
  return v6;
}
// 26928: variable 'v12' is possibly undefined
// 26A0C: variable 'v16' is possibly undefined
// 26A0C: variable 'v17' is possibly undefined
// 26A9C: variable 'v21' is possibly undefined
// 26A9C: variable 'v22' is possibly undefined
// 7DBAC: using guessed type int dword_7DBAC;

//----- (00026AD0) --------------------------------------------------------
void __fastcall sub_26AD0(const char *a1, unsigned __int8 *a2)
{
  char v4[532]; // [sp+4h] [bp-214h] BYREF

  if ( (unsigned int)dword_7DBAC > 1 )
  {
    *(_BYTE *)sub_16FB4((int)v4, a2 + 2, a2[1]) = 0;
    sub_16DDC("%s: 0x%02x %s", a1, *a2, v4);
  }
}
// 7DBAC: using guessed type int dword_7DBAC;

//----- (00026B2C) --------------------------------------------------------
int __fastcall sub_26B2C(char *s2, char *s1)
{
  char *v2; // r4
  int result; // r0
  const char *i; // r5
  const char *v6; // r2
  char *j; // r1
  int v8; // r3
  int v9; // r0
  int v10; // t1

  v2 = s1;
  result = sub_16880(s1, s2);
  if ( result < 0 )
  {
    for ( i = v2; *i; i += strlen(i) + 1 )
      ;
    v6 = (const char *)sub_174DC(i - v2);
    for ( j = (char *)v6; ; ++j )
    {
      v8 = (unsigned __int8)*v2;
      v10 = (unsigned __int8)*++v2;
      v9 = v10;
      if ( !v8 )
      {
        if ( !v9 )
          sub_16DBC("unknown option '%s', known options: %s", s2, v6);
        LOBYTE(v8) = 32;
      }
      *j = v8;
    }
  }
  return result;
}

//----- (00026BB4) --------------------------------------------------------
unsigned __int8 *__fastcall sub_26BB4(unsigned __int8 *a1, int a2)
{
  int v2; // r2
  unsigned __int8 *v3; // r4
  int i; // r3
  int v5; // lr
  int v6; // r12
  _BOOL4 v8; // r7

  v2 = 0;
  v3 = a1 + 240;
  for ( i = 388; ; i = 64 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = *v3;
        if ( !*v3 )
        {
          --i;
          ++v3;
          goto LABEL_20;
        }
        if ( v5 == 255 )
          break;
        if ( i == 1 )
          goto LABEL_21;
        v6 = v3[1] + 2;
        i -= v6;
        if ( i < 0 )
          goto LABEL_21;
        if ( v5 == a2 )
        {
          if ( v3[1] )
          {
            sub_26AD0("option found", v3);
            return v3 + 2;
          }
LABEL_21:
          sub_16DDC("bad packet, malformed option field", a2, v2);
          return 0;
        }
        v8 = v6 != 2;
        if ( v5 != 52 )
          v8 = 0;
        if ( v8 )
          v5 = v3[2];
        v3 += v6;
        if ( v8 )
          v2 |= v5;
LABEL_20:
        if ( !i )
          goto LABEL_21;
      }
      if ( (v2 & 0x101) != 1 )
        break;
      v2 |= 0x101u;
      v3 = a1 + 108;
      i = 128;
    }
    if ( (v2 & 0x202) != 2 )
      break;
    v2 |= 0x202u;
    v3 = a1 + 44;
  }
  if ( (unsigned int)dword_7DBAC > 2 )
    sub_16DDC("option 0x%02x not found", a2);
  return 0;
}
// 7DBAC: using guessed type int dword_7DBAC;

//----- (00026CBC) --------------------------------------------------------
unsigned __int8 *__fastcall sub_26CBC(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *result; // r0

  result = sub_26BB4(a1, a2);
  if ( result )
  {
    if ( *(result - 1) != 4 )
      return 0;
  }
  return result;
}

//----- (00026CDC) --------------------------------------------------------
int __fastcall sub_26CDC(int a1)
{
  int i; // r3

  for ( i = 0; *(unsigned __int8 *)(a1 + i) != 255; ++i )
  {
    if ( *(_BYTE *)(a1 + i) )
      i += *(unsigned __int8 *)(a1 + i + 1) + 1;
  }
  return i;
}

//----- (00026D10) --------------------------------------------------------
void __fastcall sub_26D10(int a1, const void *a2)
{
  int v2; // r6
  int v4; // r0
  unsigned __int8 *v5; // r1
  size_t v6; // r5
  size_t v7; // r7
  int v8; // r8

  v2 = a1 + 240;
  v4 = sub_26CDC(a1 + 240);
  v6 = v5[1] + 2;
  v7 = v4 + v6;
  if ( v4 + v6 + 1 < 0x134 )
  {
    v8 = v4;
    sub_26AD0("adding option", v5);
    memcpy((void *)(v2 + v8), a2, v6);
    *(_BYTE *)(v2 + v7) = -1;
  }
  else
  {
    sub_16DDC("option 0x%02x did not fit into the packet", *v5);
  }
}
// 26D24: variable 'v5' is possibly undefined

//----- (00026D7C) --------------------------------------------------------
void __fastcall sub_26D7C(__int64 a1, int a2)
{
  char *v2; // r3
  char v3; // r3
  __int64 v4; // [sp+0h] [bp-Ch] BYREF
  int v5; // [sp+8h] [bp-4h]

  v2 = (char *)&unk_67632;
  v4 = a1;
  v5 = a2;
  while ( 1 )
  {
    if ( !v2[1] )
    {
      sub_16DDC("can't add option 0x%02x", HIDWORD(a1));
      return;
    }
    if ( (unsigned __int8)v2[1] == HIDWORD(a1) )
      break;
    v2 += 2;
  }
  v3 = *v2;
  LOBYTE(v4) = BYTE4(a1);
  *(_DWORD *)((char *)&v4 + 2) = a2;
  BYTE1(v4) = byte_67678[v3 & 0xF];
  sub_26D10(a1, &v4);
}
// 67678: using guessed type _BYTE byte_67678[14];

//----- (00026DE4) --------------------------------------------------------
unsigned __int8 *__fastcall sub_26DE4(unsigned __int8 *result, unsigned int a2)
{
  unsigned int v2; // r3

  while ( result )
  {
    v2 = **(unsigned __int8 **)result;
    if ( v2 >= a2 )
    {
      if ( v2 != a2 )
        return 0;
      return result;
    }
    result = (unsigned __int8 *)*((_DWORD *)result + 1);
  }
  return result;
}

//----- (00026E10) --------------------------------------------------------
void __fastcall sub_26E10(unsigned __int8 **a1, _BYTE *a2, const char *a3, size_t a4)
{
  unsigned __int8 *v6; // r5
  char *v7; // r4
  _BYTE *v8; // r0
  int v9; // r1
  unsigned __int8 *v10; // r8
  unsigned __int8 *v11; // r8
  _BYTE *v12; // r0
  const void *v13; // r1
  unsigned int v14; // r7
  size_t v15; // r2
  char *v16; // r0
  unsigned __int8 *v17; // r3
  int v18; // r6
  _BYTE *v19; // r0
  int v20; // r2
  const void *v21; // r1
  size_t n; // [sp+4h] [bp-4h] BYREF

  n = a4;
  v6 = (unsigned __int8 *)a3;
  if ( (*a2 & 0xF) == 9 )
  {
    v7 = sub_174F8(a3);
    v8 = sub_17000(v7, v6, 255);
    if ( *(_DWORD *)dword_7DB94 )
      sub_16DBC("malformed hex string '%s'", (const char *)v6);
    n = v8 - v7;
  }
  else
  {
    v7 = 0;
  }
  if ( (*a2 & 0xF) == 0xC )
  {
    v6 = (unsigned __int8 *)sub_25EA0(0, 0, (char *)v6, &n);
    v7 = (char *)v6;
  }
  v10 = sub_26DE4(*a1, (unsigned __int8)a2[1]);
  if ( v10 )
  {
    if ( (*a2 & 0x20) != 0 )
    {
      if ( (unsigned int)dword_7DBAC > 1 )
        sub_16DDC("attaching option %02x to existing member of list", v9);
      v18 = *(unsigned __int8 *)(*(_DWORD *)v10 + 1);
      if ( v18 + n <= 0xFE )
      {
        v19 = sub_174B4(*(void **)v10, v18 + n + 3);
        *(_DWORD *)v10 = v19;
        v20 = v18 + 2;
        if ( (*a2 & 0xFu) - 3 <= 1 )
        {
          ++v18;
          v19[v20] = 32;
        }
        if ( v7 )
          v21 = v7;
        else
          v21 = v6;
        memcpy((void *)(*(_DWORD *)v10 + v18 + 2), v21, n);
        *(_BYTE *)(*(_DWORD *)v10 + 1) = n + v18;
      }
    }
  }
  else
  {
    if ( (unsigned int)dword_7DBAC > 1 )
      sub_16DDC("attaching option %02x to list", v9);
    v11 = (unsigned __int8 *)sub_1748C(8u);
    v12 = sub_1748C(n + 2);
    v14 = (unsigned __int8)a2[1];
    v15 = n;
    if ( v7 )
      v13 = v7;
    *(_DWORD *)v11 = v12;
    if ( !v7 )
      v13 = v6;
    *v12 = v14;
    v16 = v12 + 2;
    *(v16 - 1) = v15;
    memcpy(v16, v13, v15);
    while ( 1 )
    {
      v17 = *a1;
      if ( !*a1 || **(unsigned __int8 **)v17 >= v14 )
        break;
      a1 = (unsigned __int8 **)(v17 + 4);
    }
    *((_DWORD *)v11 + 1) = v17;
    *a1 = v11;
  }
  free(v7);
}
// 26ECC: variable 'v9' is possibly undefined
// 26F0C: variable 'v13' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;
// 7DBAC: using guessed type int dword_7DBAC;

//----- (00027004) --------------------------------------------------------
int __fastcall sub_27004(const char *a1, _DWORD *a2)
{
  _DWORD *v3; // r0

  v3 = sub_6247C(a1, 0);
  if ( !v3 )
    return 0;
  *a2 = v3[2];
  free(v3);
  return 1;
}

//----- (00027038) --------------------------------------------------------
int __fastcall sub_27038(char *a1, unsigned __int8 **a2, int a3, char *a4)
{
  char *v7; // r0
  char *v8; // r4
  unsigned int v9; // r0
  bool v10; // zf
  int v11; // r4
  char *v12; // r5
  signed int v13; // r8
  _BYTE *v14; // r7
  unsigned int *v15; // r1
  char *v16; // r0
  int v17; // r4
  bool v18; // zf
  unsigned int v20; // r0
  char *v21; // r0
  char *v22; // r4
  int v23; // r5
  unsigned int v24; // r4
  _BOOL4 v25; // r3
  _BOOL4 v26; // r5
  unsigned int v27; // r1
  int v28; // r1
  bool v29; // zf
  const char *v30; // r0
  _BYTE v31[4]; // [sp+0h] [bp-14h] BYREF
  unsigned int v32; // [sp+4h] [bp-10h] BYREF
  char v33; // [sp+8h] [bp-Ch] BYREF

  v7 = strtok(a1, " \t=:");
  v8 = v7;
  if ( !v7 )
    return 0;
  v9 = sub_18990(v7, 0, 0);
  v10 = v9 == 254;
  if ( v9 <= 0xFE )
    v10 = *(_DWORD *)dword_7DB94 == 0;
  if ( v10 )
  {
    v14 = v31;
    v31[0] = 9;
    v31[1] = v9;
  }
  else
  {
    v14 = (_BYTE *)(a3 + 2 * sub_26B2C(v8, a4));
  }
  v11 = 0;
  while ( 2 )
  {
    if ( *v14 == 9 )
    {
      v12 = strtok(0, "");
      sub_60F88(v12);
    }
    else
    {
      v12 = strtok(0, ", \t");
    }
    if ( v12 )
    {
      v13 = (unsigned __int8)byte_67678[*v14 & 0xF];
      switch ( *v14 & 0xF )
      {
        case 1:
          v15 = &v32;
          v16 = v12;
          goto LABEL_14;
        case 2:
          v17 = sub_27004(v12, &v32);
          v16 = strtok(0, ", \t/-");
          v18 = v16 == 0;
          if ( v16 )
            v18 = v17 == 0;
          if ( v18 )
            return 0;
          v15 = (unsigned int *)&v33;
          goto LABEL_14;
        case 3:
        case 4:
        case 0xC:
          goto LABEL_43;
        case 5:
          LOBYTE(v32) = sub_18990(v12, 0, 0);
          goto LABEL_20;
        case 6:
          LOWORD(v32) = __rev16(sub_18990(v12, 0, 0));
          goto LABEL_20;
        case 7:
          v20 = sub_18990(v12, 0, 0);
          goto LABEL_27;
        case 8:
          v20 = sub_189FC(v12, 0, 0);
LABEL_27:
          v32 = bswap32(v20);
LABEL_20:
          v11 = *(_DWORD *)dword_7DB94 == 0;
          goto LABEL_21;
        case 9:
          v28 = (unsigned __int8)*v12;
          v29 = v28 == 39;
          if ( v28 != 39 )
            v29 = v28 == 34;
          if ( v29 )
          {
            v30 = sub_16AA8(v12 + 1, v28);
            if ( v30 )
            {
              ++v12;
              *v30 = 0;
              v31[0] = 3;
LABEL_43:
              v13 = strnlen(v12, 254);
              if ( v13 <= 0 )
                return 0;
            }
          }
          v11 = 1;
          goto LABEL_23;
        case 0xA:
          v21 = strchr(v12, 47);
          v22 = v21;
          if ( !v21 )
            return 0;
          *v21 = 0;
          v23 = sub_27004(v12, (unsigned int *)((char *)&v32 + 1));
          v24 = sub_18990(v22 + 1, 0, (char *)0xA);
          LOBYTE(v32) = v24;
          v16 = strtok(0, ", \t/-");
          v25 = v24 > 0x20;
          if ( !v16 )
            v25 = 1;
          if ( v25 )
            return 0;
          v26 = v23 != 0;
          if ( *(_DWORD *)dword_7DB94 )
            v26 = 0;
          if ( !v26 )
            return 0;
          v27 = (v24 + 7) >> 3;
          v13 = v27 + 5;
          v15 = (unsigned int *)((char *)&v32 + v27 + 1);
LABEL_14:
          v11 = sub_27004(v16, v15);
LABEL_21:
          if ( !v11 )
            return 0;
          v12 = (char *)&v32;
LABEL_23:
          sub_26E10(a2, v14, v12, v13);
          if ( (*v14 & 0x20) == 0 )
            return v11;
          continue;
        default:
          return 0;
      }
    }
    return v11;
  }
}
// 270DC: control flows out of bounds to 270E0
// 13E2C: using guessed type int __fastcall strnlen(_DWORD, _DWORD);
// 67678: using guessed type _BYTE byte_67678[14];
// 7DB94: using guessed type int dword_7DB94;

//----- (00027340) --------------------------------------------------------
int __fastcall sub_27340(char *a1, unsigned __int8 *a2)
{
  char v4[4]; // [sp+18h] [bp-20h] BYREF
  char v5[4]; // [sp+1Ch] [bp-1Ch] BYREF
  char v6[4]; // [sp+20h] [bp-18h] BYREF
  char v7[4]; // [sp+24h] [bp-14h] BYREF
  char v8[4]; // [sp+28h] [bp-10h] BYREF
  char v9[4]; // [sp+2Ch] [bp-Ch] BYREF
  char v10[4]; // [sp+30h] [bp-8h] BYREF
  char v11[4]; // [sp+34h] [bp-4h] BYREF

  sub_16FB4((int)v4, a2, 16);
  return sprintf(a1, "%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s", v4, v5, v6, v7, v8, v9, v10, v11);
}

//----- (000273A8) --------------------------------------------------------
int __fastcall sub_273A8(int a1, int a2, int a3)
{
  int v3; // r5
  int v5; // r10
  int v6; // r8
  int v7; // r6
  int v8; // r5
  const char *v9; // r4
  char v10; // r0
  char *v12; // r0
  const char *v13; // t1
  signed int v14; // r1
  bool v15; // zf
  int v16; // r6
  int v17; // r3
  const char *v18; // r4
  const char *v19; // r1
  _BOOL4 v20; // r2
  signed int v21; // r7
  __pid_t v22; // r9
  _DWORD *v23; // r0
  void *v24; // r8
  _DWORD *v25; // r10
  int v26; // t1
  __pid_t v27; // r0
  __pid_t v28; // t1
  __pid_t v29; // r0
  __pid_t v30; // r6
  int v31; // t1
  _DWORD v32[2]; // [sp+4h] [bp-8h] BYREF

  v32[0] = a2;
  v32[1] = a3;
  v3 = a2 + 4;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(unsigned __int8 *)(*(_DWORD *)a2 + strlen(*(const char **)a2) - 3);
  if ( !v5 || *(_BYTE *)v5 != 45 )
  {
    v16 = 0;
    goto LABEL_40;
  }
  v7 = *(unsigned __int8 *)(v5 + 1);
  if ( v7 != 108 || *(_BYTE *)(v5 + 2) )
  {
    v15 = v6 == 97;
    if ( v6 == 97 )
      v15 = v7 == 113;
    if ( !v15 )
    {
      v16 = 0;
      goto LABEL_25;
    }
    if ( *(_BYTE *)(v5 + 2) )
    {
      v16 = 0;
LABEL_25:
      v17 = *(unsigned __int8 *)(v5 + 1);
      v18 = (const char *)(v5 + 1);
      if ( v17 == 45 && !*(_BYTE *)(v5 + 2) )
      {
        v21 = 15;
      }
      else
      {
        v19 = *(const char **)(v3 + 4);
        v20 = v17 == 115;
        if ( !v19 )
          v20 = 0;
        if ( v20 && !*(_BYTE *)(v5 + 2) )
        {
          v3 += 4;
          v18 = v19;
        }
        v21 = sub_61000(v18);
        if ( v21 < 0 )
        {
          sub_16DDC("bad signal name '%s'", v18);
          return 1;
        }
      }
      v5 = *(_DWORD *)(v3 + 4);
      v3 += 4;
      goto LABEL_37;
    }
    v5 = *(_DWORD *)(a2 + 8);
    v3 = a2 + 8;
    if ( !v5 )
      sub_162F0();
    v16 = 1;
    if ( *(_BYTE *)v5 == 45 )
      goto LABEL_25;
LABEL_40:
    v21 = 15;
LABEL_37:
    v22 = getpid();
    if ( !v5 )
    {
      sub_16DDC("you need to specify whom to kill");
      return 1;
    }
    v9 = 0;
    if ( v6 == 97 )
    {
      do
      {
        v23 = sub_58B44((const char *)v5);
        v24 = v23;
        if ( *v23 )
        {
          v25 = v23 - 1;
          while ( 1 )
          {
            v28 = v25[1];
            ++v25;
            v27 = v28;
            if ( !v28 )
              break;
            if ( v27 != v22 )
            {
              if ( kill(v27, v21) )
              {
                ++v9;
                if ( !v16 )
                  sub_16AF4("can't kill pid %d", *v25);
              }
            }
          }
        }
        else
        {
          ++v9;
          if ( !v16 )
            sub_16DDC("%s: no process killed", (const char *)v5);
        }
        free(v24);
        v26 = *(_DWORD *)(v3 + 4);
        v3 += 4;
        v5 = v26;
      }
      while ( v26 );
      return (int)v9;
    }
    while ( 1 )
    {
      while ( !*(_BYTE *)v5 )
      {
LABEL_64:
        v31 = *(_DWORD *)(v3 + 4);
        v3 += 4;
        v5 = v31;
        if ( !v31 )
          return (int)v9;
      }
      if ( *(_BYTE *)v5 == 32 )
        ++v5;
      v29 = sub_189FC((char *)v5, (char *)v32, 10);
      v30 = v29;
      if ( *(_DWORD *)dword_7DB94 && (*(_DWORD *)dword_7DB94 != 22 || *(_BYTE *)v32[0] != 32) )
      {
        ++v9;
        sub_16DDC("invalid number '%s'", (const char *)v5);
        goto LABEL_64;
      }
      if ( kill(v29, v21) )
      {
        ++v9;
        sub_16AF4("can't kill pid %d", v30);
      }
      v5 = v32[0];
    }
  }
  v8 = a2 + 8;
  v9 = *(const char **)(a2 + 8);
  if ( v9 )
  {
    while ( 1 )
    {
      if ( (unsigned int)*(unsigned __int8 *)v9 - 48 > 9 )
      {
        v14 = sub_61000(v9);
        if ( v14 < 0 )
        {
LABEL_8:
          sub_16DDC("unknown signal '%s'", v9);
          return 1;
        }
        printf("%d\n", v14);
      }
      else
      {
        v10 = sub_18990(v9, 0, (char *)0xA);
        if ( *(_DWORD *)dword_7DB94 )
          goto LABEL_8;
        v12 = sub_61144(v10 & 0x7F);
        puts(v12);
      }
      v13 = *(const char **)(v8 + 4);
      v8 += 4;
      v9 = v13;
      if ( !v13 )
        return (int)v9;
    }
  }
  sub_61174();
  return (int)v9;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000276E4) --------------------------------------------------------
char *__fastcall sub_276E4(int a1, const char **a2)
{
  int v3; // r1
  int v4; // r2
  unsigned int v5; // r5
  char *v6; // r4
  char *result; // r0
  const char *v8; // r0
  signed int v9; // r1
  char v10[4]; // [sp+8h] [bp-2Ch] BYREF
  int v11; // [sp+Ch] [bp-28h] BYREF
  char v12[8]; // [sp+10h] [bp-24h] BYREF

  v11 = 0;
  sub_59420(a2);
  sub_593CC((char **)a2, "^w", &v11);
  if ( v11 )
  {
    if ( v11 == 1 )
      v5 = 132;
    else
      v5 = 2048;
  }
  else
  {
    v5 = sub_17280(0, v3, v4) - 1;
    if ( v5 >= 0x800 )
      v5 = 2048;
  }
  v6 = 0;
  puts("  PID USER       VSZ STAT COMMAND");
  while ( 1 )
  {
    result = sub_5E8EC(v6, 1585);
    v6 = result;
    if ( !result )
      break;
    *sub_15A98(*((unsigned int *)result + 4), v12, (int)" mgtpezy") = 0;
    v8 = (const char *)sub_5E890(*((_DWORD *)v6 + 13));
    v9 = v5 - printf("%5u %-8.8s %s %s  ", *((_DWORD *)v6 + 9), v8, v12, v6 + 68);
    if ( v9 >= 0 )
    {
      sub_5EBFC(v10, v9, *((_DWORD *)v6 + 9), v6 + 72);
      puts(v10);
    }
  }
  return result;
}
// 27760: variable 'v3' is possibly undefined
// 27760: variable 'v4' is possibly undefined

//----- (00027800) --------------------------------------------------------
int __fastcall sub_27800(int a1, int a2)
{
  return *(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12);
}

//----- (00027810) --------------------------------------------------------
int __fastcall sub_27810(_DWORD *a1, _DWORD *a2)
{
  if ( *a2 < *a1 )
    return -1;
  else
    return *a2 != *a1;
}

//----- (00027834) --------------------------------------------------------
int __fastcall sub_27834(int a1, int a2)
{
  return *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 8);
}

//----- (00027844) --------------------------------------------------------
int __fastcall sub_27844(int a1, int a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r3

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a1 + 4);
  if ( v2 < v3 )
    return -1;
  else
    return v2 != v3;
}

//----- (00027868) --------------------------------------------------------
int __fastcall sub_27868(const void *a1, const void *a2)
{
  int v4; // r4
  int v5; // r5
  int result; // r0

  v4 = 0;
  v5 = dword_7DB98;
  do
  {
    result = (*(int (__fastcall **)(const void *, const void *))(v5 + 4 * (v4 + 20)))(a1, a2);
    if ( result )
      break;
    ++v4;
  }
  while ( v4 != 3 );
  if ( *(_DWORD *)(v5 + 8) )
    return -result;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000278BC) --------------------------------------------------------
char *__fastcall sub_278BC(char *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v5; // r0
  unsigned int v6; // r2
  unsigned int v7; // r0
  char v8; // r3
  char v9; // r1

  if ( a2 < a3 )
  {
    v5 = sub_15CA0(1000 * a2, a3);
    v6 = v5 / 0x64;
    v7 = v5 % 0x64;
    v8 = 32;
    *a1 = 32;
    if ( v6 )
      v8 = v6 + 48;
    a1[1] = v8;
    a1[2] = v7 / 0xA + 48;
    a1[3] = 46;
    sub_161AC(v7, 0xAu);
    a1[5] = 37;
    a1[6] = 32;
    a1[4] = v9 + 48;
    a1[7] = 0;
  }
  else
  {
    strcpy(a1, "  100% ");
  }
  return a1;
}
// 27944: variable 'v9' is possibly undefined

//----- (00027970) --------------------------------------------------------
int __fastcall sub_27970(int a1, int a2)
{
  int v3; // r6
  const char *v4; // r5
  int result; // r0
  unsigned int v6; // lr
  unsigned int v7; // r12
  unsigned int v8; // r2
  unsigned int v9; // r1
  unsigned __int64 v10; // kr10_8

  v3 = dword_7DB98;
  v4 = (const char *)(dword_7DB98 + 284);
  result = fgets_unlocked(dword_7DB98 + 284, 448, a1);
  if ( result )
  {
    if ( *(_BYTE *)(v3 + 284) == 99 )
    {
      result = sscanf(
                 v4,
                 "cpu %llu %llu %llu %llu %llu %llu %llu %llu",
                 a2,
                 a2 + 8,
                 a2 + 16,
                 a2 + 24,
                 a2 + 32,
                 a2 + 40,
                 a2 + 48,
                 a2 + 56);
      if ( result > 3 )
      {
        v6 = *(_DWORD *)(a2 + 24);
        v7 = *(_DWORD *)(a2 + 28);
        v8 = *(_DWORD *)(a2 + 32);
        v9 = *(_DWORD *)(a2 + 36);
        v10 = *(_QWORD *)a2
            + *(_QWORD *)(a2 + 8)
            + *(_QWORD *)(a2 + 16)
            + __PAIR64__(v7, v6)
            + __PAIR64__(v9, v8)
            + *(_QWORD *)(a2 + 40)
            + *(_QWORD *)(a2 + 48)
            + *(_QWORD *)(a2 + 56);
        *(_QWORD *)(a2 + 64) = v10;
        *(_QWORD *)(a2 + 72) = v10 - __PAIR64__(v7, v6) - __PAIR64__(v9, v8);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 14048: using guessed type int __fastcall fgets_unlocked(_DWORD, _DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (00027A88) --------------------------------------------------------
void sub_27A88()
{
  int v0; // r5
  _DWORD *v1; // r4
  int v2; // r6
  FILE *v3; // r0
  int v4; // r5
  int v5; // r0
  int v6; // r6
  _DWORD *v7; // r0
  char *v8; // r9
  _DWORD *v9; // r8
  int v10; // r3
  _DWORD *v11; // r7
  int v12; // r3
  int v13; // r11
  unsigned int v14; // r10
  int v15; // r0
  char *v16; // r1
  int v17; // r11
  int v18; // r3
  int v19; // r1
  int v20; // [sp+0h] [bp-Ch]
  int v21; // [sp+4h] [bp-8h]

  v0 = sub_61CA8("stat");
  v1 = (_DWORD *)dword_7DB98;
  v2 = dword_7DB98 + 104;
  memcpy((void *)(dword_7DB98 + 184), (const void *)(dword_7DB98 + 104), 0x50u);
  if ( sub_27970(v0, v2) <= 3 )
    sub_16DBC("can't read '%s'", "/proc/stat");
  v3 = (FILE *)v0;
  v4 = 0;
  fclose(v3);
  v5 = v1[1];
  v6 = 0;
  v1[66] = 0;
  v7 = sub_1748C(8 * v5);
  v8 = (char *)v1[23];
  v9 = v7;
  v20 = v1[1];
  while ( v20 > v6 )
  {
    v11 = (_DWORD *)(*v1 + 44 * v6);
    v12 = v11[3];
    v13 = v11[1];
    v9[2 * v6] = v13;
    v9[2 * v6 + 1] = v12;
    v14 = v1[24];
    v11[2] = 0;
    if ( v14 )
    {
      v15 = v4;
      while ( 1 )
      {
        v16 = &v8[8 * v15];
        if ( *((_DWORD *)v16 + 1) == v12 )
          break;
        v21 = v12;
        sub_15EFC(v15 + 1, v14);
        v15 = v19;
        v12 = v21;
        if ( v4 == v19 )
          goto LABEL_10;
      }
      v4 = v15;
      v17 = v13 - *(_DWORD *)v16;
      v18 = v1[66];
      v11[2] = v17;
      v1[66] = v18 + v17;
    }
LABEL_10:
    ++v6;
  }
  free(v8);
  v10 = v1[1];
  v1[23] = v9;
  v1[24] = v10;
}
// 27BAC: variable 'v19' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (00027BD0) --------------------------------------------------------
int __fastcall sub_27BD0(int a1, int a2)
{
  size_t v2; // r6
  FILE *v5; // r5
  unsigned int v6; // r8
  int v7; // r11
  const char *v8; // r0
  int v9; // r4
  int v10; // r5
  int v11; // r3
  unsigned int v12; // r5
  char *v13; // r0
  char *v14; // r5
  char v15; // r9
  const char *v16; // r0
  unsigned int i; // r10
  char v18; // r8
  unsigned int v19; // r5
  unsigned int v20; // r5
  unsigned int v21; // r1
  int v22; // r3
  const char *j; // r6
  int v24; // r0
  char *v26; // r0
  int v27; // r4
  unsigned int v28; // r7
  const char *v29; // r0
  int v30; // r0
  char *maxlena; // [sp+20h] [bp-ECh]
  size_t maxlen; // [sp+20h] [bp-ECh]
  char *v33; // [sp+24h] [bp-E8h]
  char *v34; // [sp+28h] [bp-E4h]
  char *v35; // [sp+2Ch] [bp-E0h]
  int v36; // [sp+2Ch] [bp-E0h]
  char *v37; // [sp+30h] [bp-DCh]
  int v38; // [sp+30h] [bp-DCh]
  char *v39; // [sp+34h] [bp-D8h]
  char v40[8]; // [sp+38h] [bp-D4h] BYREF
  char v41[8]; // [sp+40h] [bp-CCh] BYREF
  char v42[8]; // [sp+48h] [bp-C4h] BYREF
  char v43[8]; // [sp+50h] [bp-BCh] BYREF
  char v44[8]; // [sp+58h] [bp-B4h] BYREF
  char v45[8]; // [sp+60h] [bp-ACh] BYREF
  char v46[8]; // [sp+68h] [bp-A4h] BYREF
  _BYTE s[52]; // [sp+70h] [bp-9Ch] BYREF
  div_t v48; // [sp+A4h] [bp-68h] BYREF

  memset(s, 0, sizeof(s));
  v5 = (FILE *)sub_61CA8("meminfo");
  while ( fgets_unlocked(&v48, 60, v5) )
  {
    v26 = strchr((const char *)&v48, 58);
    v2 = (size_t)v26;
    if ( v26 )
    {
      *v26 = 0;
      v27 = sub_16880("MemTotal", (char *)&v48);
      if ( v27 >= 0 )
        *(_DWORD *)&s[4 * v27] = strtoul((const char *)(v2 + 1), 0, 10);
    }
  }
  fclose(v5);
  if ( a2 < 100 )
    v2 = a2;
  v6 = *(_DWORD *)s;
  if ( a2 >= 100 )
    v2 = 100;
  v7 = a1 - 4;
  snprintf(
    (char *)&v48,
    v2,
    "Mem: %luK used, %luK free, %luK shrd, %luK buff, %luK cached",
    *(_DWORD *)s - *(_DWORD *)&s[4],
    *(_DWORD *)&s[4],
    *(_DWORD *)&s[8] + *(_DWORD *)&s[12],
    *(_DWORD *)&s[16],
    *(_DWORD *)&s[20]);
  v8 = "%s\n";
  if ( (dword_7DBC0 & 4) == 0 )
    v8 = "\x1B[H\x1B[J%s\n";
  printf(v8, &v48);
  v9 = dword_7DB98;
  v10 = *(_DWORD *)(dword_7DB98 + 168);
  v11 = *(_DWORD *)(dword_7DB98 + 248);
  if ( v10 == v11 )
    v12 = 1;
  else
    v12 = v10 - v11;
  v39 = sub_278BC(v40, *(_DWORD *)(dword_7DB98 + 104) - *(_DWORD *)(dword_7DB98 + 184), v12);
  maxlena = sub_278BC(v41, *(_DWORD *)(v9 + 120) - *(_DWORD *)(v9 + 200), v12);
  v33 = sub_278BC(v42, *(_DWORD *)(v9 + 112) - *(_DWORD *)(v9 + 192), v12);
  v34 = sub_278BC(v43, *(_DWORD *)(v9 + 128) - *(_DWORD *)(v9 + 208), v12);
  v35 = sub_278BC(v44, *(_DWORD *)(v9 + 136) - *(_DWORD *)(v9 + 216), v12);
  v37 = sub_278BC(v45, *(_DWORD *)(v9 + 144) - *(_DWORD *)(v9 + 224), v12);
  v13 = sub_278BC(v46, *(_DWORD *)(v9 + 152) - *(_DWORD *)(v9 + 232), v12);
  snprintf((char *)&v48, v2, "CPU:%susr%ssys%snic%sidle%sio%sirq%ssirq", v39, maxlena, v33, v34, v35, v37, v13);
  puts((const char *)&v48);
  v14 = (char *)stpcpy(&v48, "Load average: ");
  sub_180C8((int)"loadavg", v14, 0x55u);
  s[v2 + 51] = 0;
  *(_BYTE *)strchrnul(v14, 10) = 0;
  puts((const char *)&v48);
  v15 = 21;
  v16 = "%.*s";
  if ( (dword_7DBC0 & 4) == 0 )
    v16 = "\x1B[7m%.*s\x1B[m";
  printf(v16, a2, "  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND");
  for ( i = sub_15CA0(0x7D000000u, v6); i >= 0x200; i >>= 2 )
    v15 -= 2;
  v18 = 6;
  v19 = *(_DWORD *)(v9 + 176) - *(_DWORD *)(v9 + 256);
  if ( *(_DWORD *)(v9 + 264) < v19 )
    *(_DWORD *)(v9 + 264) = v19;
  v20 = 64000 * (unsigned __int16)v19;
  if ( !v20 )
    v20 = 1;
  while ( v20 <= 0x3FFFFFFF )
  {
    v20 *= 4;
    v18 += 2;
  }
  v21 = *(_DWORD *)(v9 + 264) * (unsigned __int16)(*(_WORD *)(v9 + 168) - *(_WORD *)(v9 + 248));
  if ( v21 )
    v20 = sub_15CA0(v20, v21);
  while ( v20 >= 0x400 )
  {
    v20 >>= 2;
    v18 -= 2;
  }
  maxlen = a2 + 2;
  v22 = *(_DWORD *)(v9 + 76);
  if ( *(_DWORD *)(v9 + 4) - v22 < v7 )
    v7 = *(_DWORD *)(v9 + 4) - v22;
  for ( j = (const char *)(*(_DWORD *)v9 + 44 * v22 + 24); --v7 >= 0; j += 44 )
  {
    v28 = *((_DWORD *)j - 6);
    div((div_t *)s, ((1 << v15) / 0x14u + i * v28) >> v15, 10);
    div(&v48, ((1 << v18) / 0x14u + *((_DWORD *)j - 4) * v20) >> v18, 10);
    sub_15A98(v28, v46, (int)" mgtpezy");
    v38 = *((_DWORD *)j - 3);
    v36 = *((_DWORD *)j - 2);
    v29 = (const char *)sub_5E890(*((_DWORD *)j - 1));
    v30 = snprintf(
            (char *)(v9 + 284),
            maxlen,
            "\n%5u%6u %-8.8s %s  %.5s%3u.%c%3u.%c ",
            v38,
            v36,
            v29,
            j,
            v46,
            *(_DWORD *)s,
            *(_DWORD *)&s[4] + 48,
            v48.quot,
            v48.rem + 48);
    if ( (int)(maxlen - v30) > 1 )
      sub_5EBFC((char *)(v9 + 284 + v30), maxlen - v30, *((_DWORD *)j - 3), j + 4);
    fputs_unlocked(v9 + 284, stdout);
  }
  if ( (dword_7DBC0 & 4) != 0 )
    v24 = 10;
  else
    v24 = 13;
  j_putchar_unlocked(v24);
  return sub_177D8();
}
// 27C70: variable 'v2' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 13624: using guessed type int strchrnul(const char *, ...);
// 1372C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 14048: using guessed type int __fastcall fgets_unlocked(_DWORD, _DWORD, _DWORD);
// 7D614: using guessed type int stdout;
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (000280C8) --------------------------------------------------------
int __fastcall sub_280C8(int a1, unsigned int seconds)
{
  int v3; // r4
  char *v4; // r7
  int v5; // r0
  int v7; // r3
  int v8; // r3
  unsigned int v9; // r2
  int v10; // r3
  int v11; // r0
  void *v12; // r3
  int (__fastcall *v13)(int, int); // r3

  if ( (dword_7DBC0 & 0x10) != 0 )
  {
    sleep(seconds);
    return a1;
  }
  v3 = dword_7DB98;
  v4 = (char *)(dword_7DB98 + 268);
  while ( 1 )
  {
    v5 = sub_60068(0, v4, 1000 * seconds);
    if ( v5 == -1 && *(_DWORD *)dword_7DB94 != 11 )
    {
      dword_7DBC0 |= 0x10u;
      return a1;
    }
    if ( *(unsigned __int8 *)(v3 + 33) == v5 || *(unsigned __int8 *)(v3 + 37) == v5 )
      return 0;
    switch ( v5 )
    {
      case -2:
        v7 = *(_DWORD *)(v3 + 76) - 1;
        goto LABEL_12;
      case -3:
        v7 = *(_DWORD *)(v3 + 76) + 1;
        goto LABEL_12;
      case -6:
        v7 = 0;
        goto LABEL_12;
      case -7:
        v9 = *(_DWORD *)(v3 + 12);
        v10 = *(_DWORD *)(v3 + 4);
LABEL_23:
        v7 = v10 - (v9 >> 1);
        goto LABEL_12;
      case -10:
        v9 = *(_DWORD *)(v3 + 12);
        v10 = *(_DWORD *)(v3 + 76);
        goto LABEL_23;
    }
    if ( v5 == -11 )
      break;
    v11 = v5 | 0x20;
    switch ( v11 )
    {
      case 'q':
        return 0;
      case 'n':
        *(_DWORD *)(v3 + 80) = sub_27800;
        goto LABEL_35;
      case 'm':
        *(_DWORD *)(v3 + 80) = sub_27810;
        v12 = sub_27834;
        goto LABEL_33;
      case 'p':
        *(_DWORD *)(v3 + 80) = sub_27834;
        v12 = sub_27810;
LABEL_33:
        *(_DWORD *)(v3 + 84) = v12;
        v13 = sub_27844;
LABEL_34:
        *(_DWORD *)(v3 + 88) = v13;
        goto LABEL_35;
      case 't':
        *(_DWORD *)(v3 + 80) = sub_27844;
        *(_DWORD *)(v3 + 84) = sub_27810;
        v13 = sub_27834;
        goto LABEL_34;
    }
    if ( v11 != 114 )
      return a1;
    *(_DWORD *)(v3 + 8) ^= 1u;
LABEL_35:
    seconds = 0;
  }
  v7 = *(_DWORD *)(v3 + 76) + (*(_DWORD *)(v3 + 12) >> 1);
LABEL_12:
  *(_DWORD *)(v3 + 76) = v7;
  a1 = -1;
  v8 = *(_DWORD *)(v3 + 4);
  if ( *(_DWORD *)(v3 + 76) >= v8 )
    *(_DWORD *)(v3 + 76) = v8 - 1;
  if ( *(int *)(v3 + 76) < 0 )
    *(_DWORD *)(v3 + 76) = 0;
  return a1;
}
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (000282A0) --------------------------------------------------------
void sub_282A0()
{
  _DWORD *v0; // r4

  sub_5E854();
  v0 = (_DWORD *)dword_7DB98;
  free(*(void **)dword_7DB98);
  *v0 = 0;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000282C8) --------------------------------------------------------
int sub_282C8()
{
  int result; // r0

  if ( (dword_7DBC0 & 4) == 0 )
    return sub_1729C((struct termios *)(dword_7DB98 + 16));
  return result;
}
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (000282F0) --------------------------------------------------------
void __fastcall __noreturn sub_282F0(int a1)
{
  sub_282C8();
  sub_18260(a1);
}

//----- (00028304) --------------------------------------------------------
int __fastcall sub_28304(int a1, const char **a2)
{
  unsigned int v3; // r10
  int v4; // r5
  int v5; // r1
  int v6; // r9
  int v7; // r4
  char *v8; // r6
  int v9; // r3
  char *v11; // r0
  int v12; // r1
  char *v13; // r2
  int v14; // r6
  int v15; // [sp+4h] [bp-18h]
  unsigned int v16; // [sp+Ch] [bp-10h] BYREF
  const char *v17; // [sp+10h] [bp-Ch] BYREF
  const char *v18; // [sp+14h] [bp-8h] BYREF

  dword_7DB98 = (int)sub_174DC(0x2E0u);
  sub_59420(a2);
  v16 = sub_593CC((char **)a2, "d:n:b", &v17, &v18);
  if ( (v16 & 1) != 0 )
  {
    if ( *v17 == 45 )
      ++v17;
    v3 = sub_621A8(v17);
  }
  else
  {
    v3 = 5;
  }
  v4 = v16 & 2;
  if ( (v16 & 2) != 0 )
  {
    if ( *v18 == 45 )
      ++v18;
    v4 = sub_620B0(v18);
  }
  sub_178FC("/proc");
  v5 = dword_7DB98;
  *(_DWORD *)(dword_7DB98 + 80) = sub_27834;
  *(_DWORD *)(v5 + 84) = sub_27810;
  *(_DWORD *)(v5 + 88) = sub_27844;
  if ( (dword_7DBC0 & 4) != 0 )
  {
    dword_7DBC0 |= 0x10u;
  }
  else
  {
    sub_17364(0, (struct termios *)(v5 + 16), 1);
    off_7DB9C = sub_282C8;
  }
  sub_18184((__sighandler_t)0x700F44E, (void (*)(int))sub_282F0);
  v6 = sub_280C8(13875, 0);
LABEL_14:
  while ( v6 )
  {
    v7 = dword_7DB98;
    if ( (dword_7DBC0 & 4) != 0 )
    {
      *(_DWORD *)(dword_7DB98 + 12) = 0x7FFFFFFF;
LABEL_21:
      v16 = 446;
      goto LABEL_22;
    }
    *(_DWORD *)(dword_7DB98 + 12) = 24;
    v16 = 79;
    sub_1714C(1, (int *)&v16, (int *)(v7 + 12));
    if ( *(_DWORD *)(v7 + 12) > 4u && v16 > 9 )
    {
      if ( v16 > 0x1BE )
        goto LABEL_21;
LABEL_22:
      v8 = 0;
      *(_DWORD *)(v7 + 4) = 0;
      while ( 1 )
      {
        v8 = sub_5E8EC(v8, v6);
        v9 = *(_DWORD *)(v7 + 4);
        if ( !v8 )
          break;
        *(_DWORD *)(v7 + 4) = v9 + 1;
        v15 = v9;
        v11 = sub_62544(*(void **)v7, 0x2C06u, v9);
        v12 = *((_DWORD *)v8 + 9);
        *(_DWORD *)v7 = v11;
        v13 = &v11[44 * v15];
        v15 *= 44;
        *((_DWORD *)v13 + 3) = v12;
        *((_DWORD *)v13 + 4) = *((_DWORD *)v8 + 10);
        *(_DWORD *)&v11[v15] = *((_DWORD *)v8 + 4);
        *((_DWORD *)v13 + 1) = *((_DWORD *)v8 + 7) + *((_DWORD *)v8 + 6);
        *((_DWORD *)v13 + 5) = *((_DWORD *)v8 + 13);
        strcpy(&v11[v15 + 24], v8 + 68);
        strcpy((char *)(*(_DWORD *)v7 + v15 + 28), v8 + 72);
      }
      if ( !v9 )
      {
        sub_16DDC("no process info in /proc");
        break;
      }
      if ( *(_DWORD *)(v7 + 96) )
      {
        sub_27A88();
        qsort(*(void **)v7, *(_DWORD *)(v7 + 4), 0x2Cu, sub_27868);
        while ( 1 )
        {
          sub_27BD0(*(_DWORD *)(v7 + 12), v16);
          if ( v4 >= 0 && !--v4 )
            goto LABEL_26;
          v14 = sub_280C8(v6, v3);
          if ( v14 != -1 )
          {
            sub_282A0();
            v6 = v14;
            goto LABEL_14;
          }
        }
      }
      sub_27A88();
      usleep(0x186A0u);
      sub_282A0();
    }
    else
    {
      sleep(v3);
    }
  }
LABEL_26:
  j_putchar_unlocked(10);
  sub_282C8();
  return 0;
}
// 7DB98: using guessed type int dword_7DB98;
// 7DB9C: using guessed type int (*off_7DB9C)(void);
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00028600) --------------------------------------------------------
int __fastcall sub_28600(const char *a1, const char *a2)
{
  const char *v2; // r3

  v2 = "/log";
  if ( !buf.c_ispeed )
    v2 = "";
  printf("%s%s%s: %s", a1, *(const char **)buf.c_oflag, v2, a2);
  if ( *(_DWORD *)dword_7DB94 )
    printf(": %m");
  return j_putchar_unlocked(10);
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00028678) --------------------------------------------------------
int __fastcall sub_28678(const char *a1)
{
  ++buf.c_cflag;
  return sub_28600("warning: ", a1);
}

//----- (0002869C) --------------------------------------------------------
int __fastcall sub_2869C(const char *a1)
{
  ++buf.c_cflag;
  return sub_28600("fail: ", a1);
}

//----- (000286C0) --------------------------------------------------------
int __fastcall sub_286C0(const char *a1)
{
  int v3; // r5
  int v4; // r6
  unsigned int v5; // r7

  if ( sub_62DFC() == -1 )
  {
    if ( *(_DWORD *)dword_7DB94 != 2 )
    {
      sub_16AF4("warning: can't stat %s/down", *(const char **)buf.c_oflag);
      return 0;
    }
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  v4 = *(_DWORD *)&buf.c_cc[27];
  v5 = sub_57900(*(int *)&buf.c_cc[15], *(unsigned int *)&buf.c_cc[19]);
  if ( buf.c_cc[34] == 1 )
  {
    printf("run: ");
  }
  else if ( buf.c_cc[34] )
  {
    if ( buf.c_cc[34] == 2 )
      printf("finish: ");
  }
  else
  {
    printf("down: ");
  }
  printf("%s: ", a1);
  if ( buf.c_cc[34] )
    printf("(pid %d) ", v4);
  printf("%us", (*(_DWORD *)&buf.c_cc[7] - v5) & ~((int)(*(_DWORD *)&buf.c_cc[7] - v5) >> 31));
  if ( v4 )
  {
    if ( !v3 )
      printf(", normally down");
    if ( buf.c_cc[31] )
      printf(", paused");
    if ( buf.c_cc[32] == 100 )
      printf(", want down");
    if ( buf.c_cc[33] )
      printf(", got TERM");
    return 1;
  }
  else
  {
    if ( v3 )
      printf(", normally up");
    if ( buf.c_cc[32] == 117 )
      printf(", want up");
    return 2;
  }
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00028868) --------------------------------------------------------
bool sub_28868()
{
  int v1; // r0
  const char *v2; // r1
  const char *v3; // r2
  int stat_loc; // [sp+4h] [bp-74h] BYREF
  const char *v5[2]; // [sp+8h] [bp-70h] BYREF

  if ( sub_62DFC() == -1 )
  {
    if ( *(_DWORD *)dword_7DB94 == 2 )
      return 1;
    sub_16AF4("warning: can't stat %s/check", *(const char **)buf.c_oflag);
  }
  else
  {
    v5[1] = 0;
    v5[0] = "./check";
    v1 = sub_61AB4(v5);
    if ( v1 > 0 )
    {
      if ( sub_17398(v1, &stat_loc, 0) != -1 )
        return BYTE1(stat_loc) == 0;
      v2 = "wait for";
      v3 = *(const char **)buf.c_oflag;
    }
    else
    {
      v2 = "run";
      v3 = *(const char **)buf.c_oflag;
    }
    sub_16AF4("warning: can't %s child %s/check", v2, v3);
  }
  return 0;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (0002894C) --------------------------------------------------------
void __fastcall __noreturn sub_2894C(const char *a1)
{
  sub_16AF4("fatal: can't %s", a1);
  exit(151);
}

//----- (00028968) --------------------------------------------------------
int sub_28968()
{
  int v0; // r0
  int v1; // r4
  int v2; // r2
  const char *v4; // r0
  int v5; // r0
  ssize_t v6; // r5
  const char *v7; // r0

  v0 = open64("supervise/ok", 2049);
  if ( v0 != -1 )
  {
    close(v0);
    v5 = open64("supervise/status", 2048);
    v1 = v5;
    if ( v5 != -1 )
    {
      v6 = read(v5, &buf.c_cc[15], 0x14u);
      close(v1);
      if ( v6 == -1 )
      {
        v7 = "can't read supervise/status";
      }
      else
      {
        if ( v6 == 20 )
          return 1;
        v7 = "can't read supervise/status: bad format";
        *(_DWORD *)dword_7DB94 = 0;
      }
      sub_28678(v7);
      return -1;
    }
    v4 = "can't open supervise/status";
    goto LABEL_8;
  }
  if ( *(_DWORD *)dword_7DB94 != 19 )
  {
    v1 = -1;
    v4 = "can't open supervise/ok";
LABEL_8:
    sub_28678(v4);
    return v1;
  }
  v1 = 0;
  v2 = *(unsigned __int8 *)buf.c_iflag;
  *(_DWORD *)dword_7DB94 = 0;
  if ( v2 == 120 )
    sub_28600("ok: ", "runsv not running");
  else
    sub_2869C("runsv not running");
  return v1;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7DB94: using guessed type int dword_7DB94;

//----- (00028A80) --------------------------------------------------------
int sub_28A80()
{
  int v0; // r5

  if ( sub_28968() > 0 )
  {
    v0 = sub_286C0(*(const char **)buf.c_oflag);
    buf.c_ispeed = 1;
    if ( chdir("log") == -1 )
    {
      if ( *(_DWORD *)dword_7DB94 != 2 )
      {
        printf("; ");
        sub_28678("can't change directory");
LABEL_6:
        buf.c_ispeed = 0;
        return v0;
      }
    }
    else
    {
      printf("; ");
      if ( !sub_28968() )
        goto LABEL_6;
      v0 = sub_286C0("log");
    }
    j_putchar_unlocked(10);
    goto LABEL_6;
  }
  return 0;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00028B50) --------------------------------------------------------
int __fastcall sub_28B50(int a1)
{
  int v2; // r0
  int v3; // r7
  int v4; // r6
  unsigned int v5; // r3
  unsigned int v6; // t1
  int v8; // r5
  bool v9; // zf
  unsigned __int64 v10; // r0
  _BOOL4 v11; // r5
  bool v12; // zf
  int v13; // r3
  bool v14; // zf
  unsigned __int64 v15; // r0

  v2 = sub_28968();
  if ( v2 == -1 )
    return -1;
  v3 = v2;
  v4 = a1 - 1;
  do
  {
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v6 = *(unsigned __int8 *)++v4;
              v5 = v6;
              if ( !v6 )
              {
                printf("ok: ");
                sub_286C0(*(const char **)buf.c_oflag);
                j_putchar_unlocked(10);
                return 1;
              }
              if ( !v3 )
              {
                if ( v5 == 120 )
                  return 1;
                return -1;
              }
              v8 = *(_DWORD *)&buf.c_cc[27];
              if ( v5 != 111 )
                break;
              LODWORD(v15) = sub_57900(*(int *)&buf.c_cc[15], *(unsigned int *)&buf.c_cc[19]);
              if ( v8 )
              {
                v14 = buf.c_cc[32] == 100;
                goto LABEL_47;
              }
              if ( *(_QWORD *)&buf.c_line > v15 )
                return 0;
            }
            if ( v5 <= 0x6F )
              break;
            if ( v5 == 116 )
              goto LABEL_18;
            if ( v5 > 0x74 )
            {
              if ( v5 != 117 )
              {
                v9 = v5 == 120;
                goto LABEL_32;
              }
              if ( !*(_DWORD *)&buf.c_cc[27] )
                return 0;
              v12 = buf.c_cc[34] == 1;
              goto LABEL_37;
            }
            if ( v5 == 112 && *(_DWORD *)&buf.c_cc[27] )
            {
              v9 = buf.c_cc[31] == 0;
              goto LABEL_32;
            }
          }
          if ( v5 != 99 )
            break;
          if ( *(_DWORD *)&buf.c_cc[27] )
          {
            v13 = buf.c_cc[31];
LABEL_42:
            v14 = v13 == 0;
LABEL_47:
            if ( !v14 )
              return 0;
          }
        }
        if ( v5 > 0x63 )
          break;
        if ( v5 == 67 && *(_DWORD *)&buf.c_cc[27] )
        {
LABEL_15:
          v9 = !sub_28868();
LABEL_32:
          if ( v9 )
            return 0;
        }
      }
      if ( v5 == 100 )
      {
        if ( *(_DWORD *)&buf.c_cc[27] )
          return 0;
        v13 = buf.c_cc[34];
        goto LABEL_42;
      }
    }
    while ( v5 != 107 );
LABEL_18:
    ;
  }
  while ( !*(_DWORD *)&buf.c_cc[27] && buf.c_cc[32] == 100 );
  LODWORD(v10) = sub_57900(*(int *)&buf.c_cc[15], *(unsigned int *)&buf.c_cc[19]);
  if ( v8 )
    v11 = *(_QWORD *)&buf.c_line > v10;
  else
    v11 = 1;
  if ( !v11 )
  {
    v12 = buf.c_cc[33] == 0;
LABEL_37:
    if ( !v12 )
      return 0;
    goto LABEL_15;
  }
  return 0;
}
// 28C34: variable 'v10' is possibly undefined
// 28CF0: variable 'v15' is possibly undefined

//----- (00028D20) --------------------------------------------------------
int __fastcall sub_28D20(const char *a1)
{
  int v2; // r2
  int v3; // r4
  bool v5; // zf
  size_t v6; // r6
  ssize_t v7; // r5

  if ( sub_28968() <= 0 )
    return -1;
  v2 = *(unsigned __int8 *)a1;
  if ( v2 == buf.c_cc[32] && (v2 != 100 || buf.c_cc[33] == 1) )
    return 0;
  v3 = open64("supervise/control", 2049);
  if ( v3 != -1 )
  {
    v6 = strlen(a1);
    v7 = write(v3, a1, v6);
    close(v3);
    if ( v6 == v7 )
      return 1;
    sub_28678("can't write to supervise/control");
    return -1;
  }
  if ( *(_DWORD *)dword_7DB94 == 19 )
  {
    v5 = *a1 == 120;
    *(_DWORD *)dword_7DB94 = 0;
    if ( v5 )
      sub_28600("ok: ", "runsv not running");
    else
      sub_2869C("runsv not running");
  }
  else
  {
    sub_28678("can't open supervise/control");
  }
  return v3;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7DB94: using guessed type int dword_7DB94;

//----- (00028E30) --------------------------------------------------------
int __fastcall sub_28E30(int a1, char **a2)
{
  int v3; // r0
  const char *v4; // r2
  char **v5; // r3
  bool v6; // zf
  char **v7; // r9
  unsigned int v8; // r7
  char *v10; // r0
  char *v11; // r3
  char *v12; // r0
  const char *v13; // r6
  char **v14; // r3
  int v15; // r11
  const char *v16; // r0
  unsigned int v17; // r3
  char *v18; // r3
  bool v19; // zf
  bool v20; // zf
  int (__fastcall *v21)(int); // r6
  int (__fastcall *v22)(tcflag_t); // r10
  int v23; // r5
  char *v24; // r3
  const char *v25; // r8
  const char *v26; // r2
  int v27; // r8
  const char *v28; // r10
  int v29; // r3
  int v30; // r0
  int v31; // r3
  const char *v32; // [sp+4h] [bp-30h]
  char *path; // [sp+8h] [bp-2Ch]
  tcflag_t v34; // [sp+Ch] [bp-28h]
  unsigned int v35; // [sp+14h] [bp-20h]
  char *format; // [sp+18h] [bp-1Ch]
  int v37; // [sp+1Ch] [bp-18h]
  _BYTE v38[4]; // [sp+24h] [bp-10h] BYREF
  unsigned int v39; // [sp+28h] [bp-Ch] BYREF
  int v40; // [sp+2Ch] [bp-8h] BYREF

  v3 = sub_593CC(a2, "udopchaitkx");
  v4 = (const char *)optind;
  v5 = &a2[optind];
  v6 = v3 == 0;
  if ( v3 )
    v6 = a2[optind] == 0;
  if ( v6 )
LABEL_5:
    sub_162F0();
  v7 = v5 - 2;
  if ( optind > 2 )
  {
    v4 = "--";
    v7 = v5 - 3;
  }
  v8 = v3;
  if ( optind > 2 )
    *(v5 - 1) = (char *)v4;
  *v7 = "sv";
  v7[1] = v38;
  v38[1] = 0;
  v32 = "udopchaitkx";
  while ( 2 )
  {
    if ( (v8 & 1) == 0 )
      goto LABEL_12;
    v40 = 0;
    v38[0] = *v32;
    optind = 0;
    v39 = 7;
    memset(&buf, 0, 0x38u);
    byte_7D5F8 = 100;
    v10 = getenv("SVDIR");
    v11 = "";
    if ( v10 )
      v11 = v10;
    path = v11;
    v12 = getenv("SVWAIT");
    if ( v12 )
      v39 = sub_620B0(v12);
    sub_593CC(v7, "^w:+v", &v39, &v40);
    v13 = v7[optind];
    v14 = &v7[optind];
    v34 = (tcflag_t)(v14 + 1);
    if ( !v13 || !v14[1] )
      goto LABEL_5;
    *(_QWORD *)&buf.c_cc[7] = time(0) + 0x400000000000000ALL;
    *(_QWORD *)&buf.c_line = *(_QWORD *)&buf.c_cc[7];
    v15 = open64(".", 2048);
    if ( v15 == -1 )
    {
      v16 = "open current directory";
      goto LABEL_22;
    }
    buf.c_iflag = (tcflag_t)"s";
    v17 = *(unsigned __int8 *)v13;
    if ( v17 == 102 )
    {
      if ( strcmp(v13, "force-reload") )
      {
        if ( !strcmp(v13, "force-restart") )
        {
          v18 = "tcu";
          goto LABEL_86;
        }
        if ( !strcmp(v13, "force-shutdown") )
          goto LABEL_32;
        if ( strcmp(v13, "force-stop") )
          goto LABEL_5;
        goto LABEL_91;
      }
      goto LABEL_85;
    }
    if ( v17 > 0x66 )
    {
      if ( v17 <= 0x71 )
      {
        if ( v17 >= 0x6F )
          goto LABEL_30;
        if ( v17 < 0x68 )
          goto LABEL_5;
        if ( v17 <= 0x69 )
          goto LABEL_30;
        v19 = v17 == 107;
        goto LABEL_37;
      }
      if ( v17 == 116 )
      {
        v23 = strcmp(v13, "try-restart");
        if ( v23 )
          goto LABEL_67;
        v24 = "tc";
      }
      else
      {
        if ( v17 > 0x74 )
        {
          if ( v17 != 117 )
          {
            v20 = v17 == 120;
            goto LABEL_41;
          }
LABEL_30:
          *((_BYTE *)v13 + 1) = 0;
          buf.c_iflag = (tcflag_t)v13;
          goto LABEL_44;
        }
        if ( v17 == 114 )
        {
          v23 = strcmp(v13, "restart");
          if ( v23 )
          {
            v23 = strcmp(v13, "reload");
            if ( v23 )
              goto LABEL_5;
            v24 = "h";
          }
          else
          {
            v24 = "tcu";
          }
        }
        else
        {
          v23 = strcmp(v13, "shutdown");
          if ( v23 )
          {
            v23 = strcmp(v13, "start");
            if ( v23 )
            {
              v23 = strcmp(v13, "stop");
              if ( v23 )
              {
                v22 = (int (__fastcall *)(tcflag_t))sub_28A80;
                v21 = 0;
                goto LABEL_62;
              }
              v24 = (char *)"d";
            }
            else
            {
              v24 = "u";
            }
          }
          else
          {
            v24 = "x";
          }
        }
      }
      buf.c_iflag = (tcflag_t)v24;
      v21 = sub_28B50;
      v22 = (int (__fastcall *)(tcflag_t))sub_28D20;
      goto LABEL_69;
    }
    if ( v17 == 84 )
    {
LABEL_85:
      v18 = "tc";
      goto LABEL_86;
    }
    if ( v17 <= 0x54 )
    {
      if ( v17 != 68 )
      {
        if ( v17 <= 0x44 )
        {
          if ( v17 - 49 > 1 )
            goto LABEL_5;
          goto LABEL_30;
        }
        if ( v17 != 69 )
          goto LABEL_5;
        goto LABEL_32;
      }
LABEL_91:
      v18 = (char *)"d";
      goto LABEL_86;
    }
    if ( v17 == 99 )
    {
LABEL_67:
      v23 = strcmp(v13, "check");
      if ( !v23 )
      {
        v21 = sub_28B50;
        v22 = 0;
        buf.c_iflag = (tcflag_t)"C";
        goto LABEL_69;
      }
      goto LABEL_30;
    }
    if ( v17 <= 0x63 )
    {
      if ( v17 == 88 )
      {
LABEL_32:
        v18 = "x";
LABEL_86:
        buf.c_iflag = (tcflag_t)v18;
        v23 = 1;
        v21 = sub_28B50;
        v22 = (int (__fastcall *)(tcflag_t))sub_28D20;
        goto LABEL_69;
      }
      v19 = v17 == 97;
LABEL_37:
      if ( !v19 )
        goto LABEL_5;
      goto LABEL_30;
    }
    if ( v17 == 100 )
      goto LABEL_30;
    v20 = v17 == 101;
LABEL_41:
    if ( !v20 )
      goto LABEL_5;
    buf.c_iflag = (tcflag_t)"x";
LABEL_44:
    if ( !v40 )
    {
      v21 = 0;
      v22 = (int (__fastcall *)(tcflag_t))sub_28D20;
LABEL_62:
      v23 = 0;
      goto LABEL_69;
    }
    v21 = sub_28B50;
    v23 = 0;
    v22 = (int (__fastcall *)(tcflag_t))sub_28D20;
LABEL_69:
    for ( buf.c_oflag = v34; ; buf.c_oflag += 4 )
    {
      v25 = *(const char **)buf.c_oflag;
      if ( !*(_DWORD *)buf.c_oflag )
        break;
      if ( (unsigned int)*(unsigned __int8 *)v25 - 46 > 1
        && !sub_16AA8(*(const char **)buf.c_oflag, 47)
        && chdir(path) == -1
        || chdir(v25) == -1 )
      {
        sub_2869C("can't change to service directory");
LABEL_101:
        *(_DWORD *)buf.c_oflag = -1;
        goto LABEL_96;
      }
      if ( v22 && v22(buf.c_iflag) == -1 )
        goto LABEL_101;
LABEL_96:
      if ( fchdir(v15) == -1 )
      {
LABEL_97:
        v16 = "change to original directory";
LABEL_22:
        sub_2894C(v16);
      }
    }
    if ( !v21 )
      goto LABEL_118;
    v26 = "kill: ";
    if ( !v23 )
      v26 = "timeout: ";
    format = (char *)v26;
    while ( 2 )
    {
      v27 = 1;
      v35 = *(_DWORD *)&buf.c_cc[7] - *(_DWORD *)&buf.c_line;
      buf.c_oflag = v34;
      while ( 2 )
      {
        v28 = *(const char **)buf.c_oflag;
        if ( *(_DWORD *)buf.c_oflag )
        {
          if ( v28 == (const char *)-1 )
          {
            v31 = v27;
          }
          else
          {
            if ( (unsigned int)*(unsigned __int8 *)v28 - 46 > 1 && chdir(path) == -1 || chdir(v28) == -1 )
            {
              sub_2869C("can't change to service directory");
              goto LABEL_114;
            }
            v29 = v21(buf.c_iflag);
            if ( v29 )
              goto LABEL_114;
            if ( v35 >= v39 )
            {
              printf(format);
              if ( sub_28968() > 0 )
              {
                sub_286C0(v28);
                ++buf.c_cflag;
              }
              j_putchar_unlocked(10);
              v27 = 0;
              if ( v23 )
                sub_28D20("k");
LABEL_114:
              *(_DWORD *)buf.c_oflag = -1;
              v29 = v27;
            }
            v37 = v29;
            v30 = fchdir(v15);
            v31 = v37;
            if ( v30 == -1 )
              goto LABEL_97;
          }
          v27 = v31;
          buf.c_oflag += 4;
          continue;
        }
        break;
      }
      if ( !v27 )
      {
        usleep((__useconds_t)"lush\"");
        *(_QWORD *)&buf.c_cc[7] = time(0) + 0x400000000000000ALL;
        continue;
      }
      break;
    }
LABEL_118:
    if ( !buf.c_cflag )
    {
LABEL_12:
      v8 >>= 1;
      ++v32;
      if ( !v8 )
        return 0;
      continue;
    }
    return 1;
  }
}
// 290B8: conditional instruction was optimized away because r3.4==73
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D5F8: using guessed type char byte_7D5F8;
// 7D604: using guessed type int optind;

//----- (000294E4) --------------------------------------------------------
int __fastcall sub_294E4(int a1, int a2)
{
  const char *v2; // r4

  v2 = *(const char **)(a2 + 4);
  if ( !v2 )
    sub_162F0();
  byte_7D5F8 = 111;
  if ( (unsigned int)*(unsigned __int8 *)v2 - 46 > 1 && !sub_16AA8(v2, 47) )
    sub_178FC("");
  sub_178FC(v2);
  if ( open64("supervise/ok", 1) >= 0 )
    return 0;
  if ( (*(_DWORD *)dword_7DB94 & 0xFFFFFFFB) != 2 )
    sub_16B40("can't open '%s'", "supervise/ok");
  return 100;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D5F8: using guessed type char byte_7D5F8;
// 7DB94: using guessed type int dword_7DB94;

//----- (00029594) --------------------------------------------------------
bool __fastcall sub_29594(int a1)
{
  int v1; // r3
  int v2; // r0
  int v3; // r2
  int v4; // t1

  v1 = a1 - 1;
  v2 = a1 + 9;
  do
  {
    v4 = *(unsigned __int8 *)++v1;
    v3 = v4;
  }
  while ( v1 != v2 && (unsigned int)(v3 - 48) <= 9 );
  return v3 == 0;
}

//----- (000295C0) --------------------------------------------------------
int __fastcall sub_295C0(int result)
{
  int v1; // r3
  int v2; // r2

  v1 = dword_7DBB8;
  v2 = *(_DWORD *)(dword_7DBB8 + 4);
  *(_DWORD *)(dword_7DBB8 + 4) = result;
  *(_DWORD *)(v1 + 12) += v2 - result;
  return result;
}
// 7DBB8: using guessed type int dword_7DBB8;

//----- (000295E8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_295E8(unsigned __int8 *result, int a2)
{
  int v2; // r1
  int v3; // r3
  int v4; // t1
  int v5; // t1

  v2 = a2 - 1;
  while ( 1 )
  {
    v4 = *(unsigned __int8 *)++v2;
    v3 = v4;
    if ( !v4 )
      break;
    v5 = *result++;
    if ( v5 != v3 )
      return 0;
  }
  return result;
}

//----- (0002960C) --------------------------------------------------------
int __fastcall sub_2960C(unsigned __int8 *a1)
{
  while ( (unsigned int)*a1 - 48 <= 9 )
  {
    if ( !*++a1 )
      return 1;
  }
  return 0;
}

//----- (00029638) --------------------------------------------------------
int __fastcall sub_29638(int a1, int a2)
{
  int v2; // r0
  int v3; // r1
  int v4; // r3
  int v5; // t1
  int v6; // r2
  int v7; // t1
  bool v8; // zf

  v2 = a1 - 1;
  v3 = a2 - 1;
  while ( 1 )
  {
    v5 = *(unsigned __int8 *)++v2;
    v4 = v5;
    v7 = *(unsigned __int8 *)++v3;
    v6 = v7;
    if ( v4 != v7 )
      break;
    v8 = v4 == 61;
    if ( v4 != 61 )
      v8 = v4 == 0;
    if ( v8 )
      return v4 - v6;
  }
  if ( v4 == 61 )
    v4 = 0;
  if ( v6 == 61 )
    v6 = 0;
  return v4 - v6;
}

//----- (00029678) --------------------------------------------------------
int __fastcall sub_29678(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r0
  int v2; // t1
  unsigned int i; // r3
  int v4; // r2
  int v5; // t1
  bool v6; // zf
  int v7; // r1

  v2 = *a1;
  v1 = a1 - 1;
  for ( i = 16 * v2; ; i += v4 )
  {
    v5 = *++v1;
    v4 = v5;
    v6 = v5 == 0;
    if ( v5 )
      v6 = v4 == 61;
    if ( v6 )
      break;
  }
  sub_15EFC(i, 0x27u);
  return dword_7DBB4 + 4 * (v7 + 7);
}
// 296A4: variable 'v7' is possibly undefined
// 7DBB4: using guessed type int dword_7DBB4;

//----- (000296C0) --------------------------------------------------------
int __fastcall sub_296C0(int *a1, int *a2)
{
  return sub_29638(*a1, *a2);
}

//----- (000296CC) --------------------------------------------------------
_DWORD *__fastcall sub_296CC(_DWORD *a1, int a2)
{
  _DWORD *v4; // r5

  while ( 1 )
  {
    v4 = (_DWORD *)*a1;
    if ( !*a1 || !sub_29638(v4[2], a2) )
      break;
    a1 = v4;
  }
  return a1;
}

//----- (00029708) --------------------------------------------------------
int __fastcall sub_29708(int result, int a2)
{
  int *v2; // r2
  int i; // r3
  int v4; // r2
  int *v5; // r1

  v2 = &dword_7D6AC;
  for ( i = dword_7D6AC; i != result; i = *(_DWORD *)(i + 28) )
    v2 = (int *)(i + 28);
  *v2 = *(_DWORD *)(i + 28);
  if ( a2 )
  {
    if ( a2 != 1 )
      return result;
    v4 = dword_7D6AC;
    v5 = &dword_7D6AC;
    while ( v4 )
    {
      result = *(unsigned __int8 *)(v4 + 24);
      if ( result != 1 )
        break;
      v5 = (int *)(v4 + 28);
      v4 = *(_DWORD *)(v4 + 28);
    }
  }
  else
  {
    v5 = &dword_7D6AC;
  }
  *(_DWORD *)(i + 28) = *v5;
  *v5 = i;
  return result;
}
// 7D6AC: using guessed type int dword_7D6AC;

//----- (00029780) --------------------------------------------------------
int __fastcall sub_29780(int a1)
{
  int v2; // r3
  unsigned int v3; // r0
  unsigned int v4; // r3
  int v5; // r2
  int v6; // r3
  int result; // r0

  v2 = *(_DWORD *)(a1 + 20);
  v3 = *(_DWORD *)(a1 + 12);
  v4 = v3 + 12 * v2 - 12;
  v5 = *(_DWORD *)(v4 + 4);
  if ( *(_BYTE *)(dword_7DBB0 + 75) )
  {
    while ( !v5 )
    {
      v4 -= 12;
      if ( v3 > v4 )
        break;
      v5 = *(_DWORD *)(v4 + 4);
    }
  }
  v6 = v5 & 0x7F;
  result = BYTE1(v5);
  if ( (v5 & 0x7F) != 0 )
  {
    if ( (unsigned __int8)v5 == 127 )
    {
      v6 = BYTE1(v5);
    }
    else if ( v6 == 2 )
    {
      *(_BYTE *)(a1 + 25) |= 1u;
    }
    return v6 + 128;
  }
  return result;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (00029804) --------------------------------------------------------
int sub_29804()
{
  int result; // r0
  int v1; // r3
  bool v2; // cc

  result = dword_7D6B8;
  if ( (unsigned int)(dword_7D6B8 - 1) <= 1 )
  {
    v1 = dword_7D730 - 1;
    v2 = --dword_7D730 <= 0;
    if ( dword_7D730 > 0 )
      result = 1;
    else
      v1 = 0;
    if ( v2 )
      dword_7D6B8 = v1;
  }
  return result;
}
// 7D6B8: using guessed type int dword_7D6B8;
// 7D730: using guessed type int dword_7D730;

//----- (00029844) --------------------------------------------------------
int sub_29844()
{
  return 1;
}

//----- (0002984C) --------------------------------------------------------
int sub_2984C()
{
  return 0;
}

//----- (00029854) --------------------------------------------------------
int sub_29854()
{
  return *(unsigned __int8 *)(dword_7DBB0 + 1);
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (00029868) --------------------------------------------------------
void sub_29868()
{
  ++*((_DWORD *)off_7D4D0 + 1);
  dword_7D714 = dword_7D6B4;
}
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D6B4: using guessed type int dword_7D6B4;
// 7D714: using guessed type int dword_7D714;

//----- (0002989C) --------------------------------------------------------
void sub_2989C()
{
  ++*((_DWORD *)off_7D4D0 + 18);
}
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;

//----- (000298B8) --------------------------------------------------------
void *sub_298B8()
{
  void *result; // r0
  void *v1; // r2

  result = sub_174DC(0x4Cu);
  v1 = off_7D4D0;
  off_7D4D0 = result;
  *(_DWORD *)result = v1;
  *((_DWORD *)result + 2) = -1;
  return result;
}
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;

//----- (000298E4) --------------------------------------------------------
int __fastcall sub_298E4(int *a1)
{
  int v1; // r6
  int result; // r0
  int v3; // r5
  int v4; // r2
  _DWORD *v5; // r2
  _DWORD *v6; // r3

  v1 = dword_7DBB4;
  if ( !a1 )
    return *(_DWORD *)(dword_7DBB4 + 20);
  v3 = 0;
  do
  {
    v4 = *a1;
    a1 = (int *)a1[1];
    if ( v4 == 17 )
      v3 += 2;
    else
      ++v3;
  }
  while ( a1 );
  v5 = sub_174DC(8 * (v3 + 1));
  v6 = &v5[2 * v3];
  v5[1] = v3;
  while ( 1 )
  {
    --v3;
    v6 -= 2;
    if ( v3 == -1 )
      break;
    v6[3] = -2;
    v6[2] = -2;
  }
  result = *(_DWORD *)(v1 + 20);
  *v5 = result;
  *(_DWORD *)(v1 + 20) = v5;
  return result;
}
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00029978) --------------------------------------------------------
void *__fastcall sub_29978(void *a1)
{
  int v1; // r3
  void *v2; // r5

  v1 = *((_DWORD *)a1 + 3);
  if ( (v1 & 1) != 0 )
  {
    v2 = a1;
    *((_DWORD *)a1 + 3) = v1 | 2;
  }
  else
  {
    v2 = *(void **)a1;
    free(*((void **)a1 + 1));
    free(*((void **)a1 + 2));
    free(a1);
  }
  return v2;
}

//----- (000299BC) --------------------------------------------------------
void __fastcall sub_299BC(int a1)
{
  char *v1; // r4
  char *v2; // r5
  void *v3; // r0
  void *v4; // t1

  if ( *(_BYTE *)(a1 + 12) )
  {
    v1 = *(char **)(a1 + 16);
    v2 = v1 - 4;
    while ( 1 )
    {
      v4 = (void *)*((_DWORD *)v2 + 1);
      v2 += 4;
      v3 = v4;
      if ( !v4 )
        break;
      free(v3);
    }
    free(v1);
  }
}

//----- (000299F4) --------------------------------------------------------
void __fastcall sub_299F4(void *ptr)
{
  int v1; // r3

  if ( ptr )
  {
    v1 = *(_DWORD *)ptr - 1;
    *(_DWORD *)ptr = v1;
    if ( v1 < 0 )
      free(ptr);
  }
}

//----- (00029A14) --------------------------------------------------------
int __fastcall sub_29A14(int a1, char a2)
{
  unsigned __int8 *v3; // r0
  int v4; // r3

  if ( a1 == 256 )
    return 11;
  if ( a1 == 257 )
  {
    v4 = 0;
    return ((int)word_6430E[v4] >> (4 * a2)) & 0xF;
  }
  if ( (unsigned __int8)(a1 + 127) <= 7u )
    return 12;
  v3 = (unsigned __int8 *)strchrnul("\t\n !\"$&'()*-:;<=>?[\\]`|}~", a1);
  if ( *v3 )
  {
    v4 = byte_68671[v3 - "\t\n !\"$&'()*-:;<=>?[\\]`|}~"];
    return ((int)word_6430E[v4] >> (4 * a2)) & 0xF;
  }
  return *v3;
}
// 13624: using guessed type int __fastcall strchrnul(_DWORD, _DWORD);
// 6430E: using guessed type unsigned __int16 word_6430E[12];
// 68671: using guessed type unsigned __int8 byte_68671[25];

//----- (00029AB0) --------------------------------------------------------
char *__fastcall sub_29AB0(const char *a1)
{
  dword_7D6D0 -= (strlen(a1) + 8) & 0xFFFFFFF8;
  return strcpy((char *)dword_7D6D0, a1);
}
// 7D6D0: using guessed type int dword_7D6D0;

//----- (00029AE4) --------------------------------------------------------
int *__fastcall sub_29AE4(int *a1)
{
  int *v1; // r4
  int v2; // r3
  int *v3; // r5
  int v4; // r2
  char *v5; // r0
  char *v6; // r0
  int v7; // r3
  char *v9; // r0
  int v10; // r0
  int v11; // r3

  v1 = a1;
  if ( a1 )
  {
    v2 = *a1;
    v3 = (int *)dword_7D6C8;
    v4 = dword_7D6C8 + byte_681B5[*a1];
    dword_7D6C8 = v4;
    switch ( v2 )
    {
      case 0:
        v5 = (char *)sub_29AE4(a1[4]);
        goto LABEL_4;
      case 1:
        v6 = (char *)sub_29C7C((_DWORD *)a1[2], (int)&dword_7D6C8, v4);
        goto LABEL_7;
      case 2:
      case 3:
      case 4:
      case 12:
        goto LABEL_5;
      case 5:
      case 6:
      case 7:
      case 9:
      case 10:
        goto LABEL_11;
      case 8:
      case 13:
        v3[3] = sub_29AE4(a1[3]);
LABEL_11:
        v9 = (char *)sub_29AE4(v1[2]);
        goto LABEL_12;
      case 11:
        v5 = sub_29AB0((const char *)a1[4]);
LABEL_4:
        v3[4] = (int)v5;
LABEL_5:
        v3[3] = sub_29AE4(v1[3]);
        v6 = (char *)sub_29AE4(v1[2]);
        goto LABEL_7;
      case 14:
        v3[3] = sub_29AE4(a1[3]);
        v6 = sub_29AB0((const char *)v1[2]);
LABEL_7:
        v3[2] = (int)v6;
        v3[1] = v1[1];
        break;
      case 15:
        v3[3] = sub_29C7C((_DWORD *)a1[3], (int)&dword_7D6C8, v4);
        v9 = sub_29AB0((const char *)v1[2]);
LABEL_12:
        v3[2] = (int)v9;
        goto LABEL_13;
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
        v3[4] = sub_29AE4(a1[4]);
        goto LABEL_18;
      case 22:
      case 23:
        v10 = sub_29AE4(a1[4]);
        v11 = v1[3];
        v3[4] = v10;
        v3[3] = v11;
        goto LABEL_18;
      case 24:
      case 25:
        v3[3] = sub_29AE4(a1[3]);
LABEL_18:
        v3[2] = v1[2];
        goto LABEL_13;
      case 26:
LABEL_13:
        v3[1] = sub_29AE4(v1[1]);
        break;
      default:
        break;
    }
    v7 = *v1;
    v1 = v3;
    *v3 = v7;
  }
  return v1;
}
// 29B14: control flows out of bounds to 29B18
// 681B5: using guessed type unsigned __int8 byte_681B5[27];
// 7D6C8: using guessed type int dword_7D6C8;

//----- (00029C7C) --------------------------------------------------------
int __fastcall sub_29C7C(_DWORD *a1, int a2, int a3)
{
  _DWORD *v4; // r5
  int v6; // r6
  int v7; // r0
  int v8; // r0
  _DWORD v9[2]; // [sp+4h] [bp-8h] BYREF

  v9[0] = a2;
  v9[1] = a3;
  v4 = v9;
  while ( a1 )
  {
    v6 = dword_7D6C8;
    v7 = a1[1];
    *v4 = dword_7D6C8;
    dword_7D6C8 = v6 + 8;
    v8 = sub_29AE4(v7);
    a1 = (_DWORD *)*a1;
    *(_DWORD *)(v6 + 4) = v8;
    v4 = (_DWORD *)*v4;
  }
  *v4 = 0;
  return v9[0];
}
// 29AE4: using guessed type int __fastcall sub_29AE4(_DWORD);
// 7D6C8: using guessed type int dword_7D6C8;

//----- (00029CD0) --------------------------------------------------------
int *__fastcall sub_29CD0(const char *a1)
{
  int v2; // r3
  const char *v3; // r2
  unsigned int v4; // r0
  int v5; // r1
  int *i; // r4
  int v7; // r5
  int v9; // t1

  v2 = *(unsigned __int8 *)a1;
  v3 = a1;
  v4 = 16 * v2;
  while ( v2 )
  {
    v4 += v2;
    v9 = *(unsigned __int8 *)++v3;
    v2 = v9;
  }
  sub_15EFC(v4, 0x27u);
  for ( i = (int *)(dword_7D644 + 4 * v5); ; i = (int *)v7 )
  {
    v7 = *i;
    if ( !*i || !strcmp(a1, *(const char **)(v7 + 4)) )
      break;
  }
  return i;
}
// 29CFC: variable 'v5' is possibly undefined
// 7D644: using guessed type int dword_7D644;

//----- (00029D40) --------------------------------------------------------
int __fastcall compar(const char *a1, const void *a2)
{
  return strcmp(a1, (const char *)(*(_DWORD *)a2 + 1));
}

//----- (00029D4C) --------------------------------------------------------
char *__fastcall sub_29D4C(const char *a1, char a2)
{
  const char *v3; // r3
  __int16 i; // r0
  __int16 v6; // r2
  int v7; // t1
  int v8; // r1
  char *v9; // r4
  char **v10; // r6
  int v11; // r7
  size_t v12; // r0
  char *v13; // r0

  v3 = a1 - 1;
  for ( i = 16 * *(unsigned __int8 *)a1; ; i += v6 )
  {
    v7 = *(unsigned __int8 *)++v3;
    v6 = v7;
    if ( !v7 )
      break;
  }
  sub_15EFC(i & 0x7FFF, 0x1Fu);
  v9 = *(char **)(dword_7D6A4 + 4 * v8);
  v10 = (char **)(dword_7D6A4 + 4 * v8);
  while ( v9 && strcmp(v9 + 13, a1) )
  {
    v10 = (char **)v9;
    v9 = *(char **)v9;
  }
  if ( v9 )
    v11 = 0;
  else
    v11 = a2 & 1;
  if ( v11 )
  {
    v12 = strlen(a1);
    v13 = (char *)sub_174DC(v12 + 16);
    *v10 = v13;
    v9 = v13;
    *((_DWORD *)v13 + 2) = -1;
    strcpy(v13 + 13, a1);
  }
  dword_7D700 = (int)v10;
  return v9;
}
// 29D84: variable 'v8' is possibly undefined
// 7D6A4: using guessed type int dword_7D6A4;
// 7D700: using guessed type int dword_7D700;

//----- (00029E14) --------------------------------------------------------
int __fastcall sub_29E14(const char *a1, const char **a2)
{
  return strcmp(a1, *a2);
}

//----- (00029E1C) --------------------------------------------------------
_DWORD *__fastcall sub_29E1C(_DWORD *result, int a2, int a3)
{
  _DWORD *v3; // r5
  int v4; // r3
  _DWORD *v5; // r2
  int v7; // r4
  int *v8; // r6
  int v9; // r5
  int v10; // r3
  _DWORD v11[2]; // [sp+4h] [bp-8h] BYREF

  v11[1] = a3;
  v11[0] = result;
  if ( a2 <= 1 )
    return result;
  v3 = result;
  v4 = a2 >> 1;
  v5 = 0;
  while ( v4-- != 0 )
  {
    v5 = v3;
    v3 = (_DWORD *)*v3;
  }
  *v5 = 0;
  v7 = sub_29E1C(result);
  v8 = v11;
  v9 = sub_29E1C(v3);
  while ( strcmp(*(const char **)(v9 + 4), *(const char **)(v7 + 4)) < 0 )
  {
    *v8 = v9;
    v8 = (int *)v9;
    if ( !*(_DWORD *)v9 )
    {
      *(_DWORD *)v9 = v7;
      return (_DWORD *)v11[0];
    }
    v10 = v7;
    v9 = *(_DWORD *)v9;
LABEL_12:
    v7 = v10;
  }
  *v8 = v7;
  v8 = (int *)v7;
  v10 = *(_DWORD *)v7;
  if ( *(_DWORD *)v7 )
    goto LABEL_12;
  *(_DWORD *)v7 = v9;
  return (_DWORD *)v11[0];
}

//----- (00029EE0) --------------------------------------------------------
void __fastcall __noreturn sub_29EE0(int a1)
{
  int v1; // r3

  v1 = dword_7DBB0;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  *(_DWORD *)(v1 + 56) = a1;
  longjmp(*(struct __jmp_buf_tag **)(v1 + 36), 1);
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (00029F0C) --------------------------------------------------------
void __fastcall sub_29F0C(int a1)
{
  int i; // r5
  int v2; // r4
  char **v3; // r7
  char **j; // r6
  const char *v5; // r0
  const char *v6; // t1
  int v7; // r4

  for ( i = 0; *(_DWORD *)(a1 + 4 * i); ++i )
    ;
  v2 = a1 - 4;
  v3 = (char **)sub_1748C(4 * (i + 1));
  for ( j = v3; ; ++j )
  {
    v6 = *(const char **)(v2 + 4);
    v2 += 4;
    v5 = v6;
    if ( !v6 )
      break;
    *j = sub_174F8(v5);
  }
  *j = 0;
  v7 = dword_7DBB4;
  sub_299BC(dword_7DBB4);
  *(_DWORD *)v7 = i;
  *(_BYTE *)(v7 + 12) = 1;
  *(_DWORD *)(v7 + 4) = 1;
  *(_DWORD *)(v7 + 16) = v3;
  *(_DWORD *)(v7 + 8) = -1;
}
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00029F94) --------------------------------------------------------
int __fastcall sub_29F94(int sig)
{
  int v1; // r5
  int v2; // r6
  _BYTE *v3; // r3
  int v4; // r4
  int v5; // r3
  bool v6; // zf
  bool v7; // zf
  int v8; // r8
  int v9; // r7
  bool v10; // zf
  int v11; // r2
  struct sigaction oact; // [sp+4h] [bp-8Ch] BYREF

  v1 = sig;
  v2 = dword_7DBB0;
  v3 = *(_BYTE **)(dword_7DBB0 + 4 * (sig + 52));
  if ( v3 )
  {
    if ( *v3 )
      v4 = 2;
    else
      v4 = 3;
  }
  else
  {
    v4 = 1;
  }
  v5 = *(_DWORD *)(dword_7DBB0 + 12);
  v6 = v5 == 0;
  if ( !v5 )
    v6 = v4 == 1;
  if ( !v6 )
    goto LABEL_20;
  if ( sig == 15 )
  {
    if ( *(_BYTE *)(dword_7DBB0 + 64) )
      v4 = 3;
    else
      v4 = 1;
    goto LABEL_31;
  }
  if ( sig <= 15 )
  {
    if ( sig == 2 )
    {
      if ( !*(_BYTE *)(dword_7DBB0 + 64) && !*(_DWORD *)(dword_7DBB0 + 20) )
      {
        v7 = *(_BYTE *)(dword_7DBB0 + 67) == 0;
        if ( *(_BYTE *)(dword_7DBB0 + 67) )
          v4 = 1;
        goto LABEL_25;
      }
    }
    else if ( sig != 3 )
    {
      goto LABEL_14;
    }
    v4 = sig;
    goto LABEL_31;
  }
  if ( sig == 20 || sig == 22 )
  {
    if ( *(_BYTE *)(dword_7DBB0 + 65) )
      v4 = 3;
    else
      v4 = 1;
    goto LABEL_20;
  }
LABEL_14:
  v4 = 1;
LABEL_20:
  v7 = sig == 17;
LABEL_25:
  if ( v7 )
    v4 = 2;
LABEL_31:
  v8 = dword_7DBB0 + sig - 1;
  v9 = *(unsigned __int8 *)(v8 + 76);
  if ( !*(_BYTE *)(v8 + 76) )
  {
    sig = sigaction(sig, (const struct sigaction *)*(unsigned __int8 *)(v8 + 76), &oact);
    if ( sig )
      return sig;
    if ( oact.sa_handler == (__sighandler_t)1 )
    {
      if ( *(_BYTE *)(v2 + 65) )
      {
        if ( (unsigned int)(v1 - 20) >= 3 )
          v9 = 4;
        else
          v9 = 3;
      }
      else
      {
        v9 = 4;
      }
    }
    else
    {
      if ( oact.sa_handler )
        goto LABEL_42;
      if ( v4 == 1 )
      {
        *(_BYTE *)(v8 + 76) = 1;
        return sig;
      }
    }
  }
  v10 = v9 == v4;
  if ( v9 != v4 )
    v10 = v9 == 4;
  if ( !v10 )
  {
LABEL_42:
    *(_BYTE *)(v8 + 76) = v4;
    oact.sa_handler = 0;
    if ( v4 == 2 )
    {
      v11 = (int)sub_2A1D8;
    }
    else
    {
      if ( v4 != 3 )
      {
LABEL_44:
        oact.sa_flags = 0;
        sigfillset(&oact.sa_mask);
        return sub_18150(v1, &oact);
      }
      v11 = 1;
    }
    oact.sa_handler = (__sighandler_t)v11;
    goto LABEL_44;
  }
  return sig;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A140) --------------------------------------------------------
__sighandler_t __fastcall sub_2A140(__sighandler_t result)
{
  int v1; // r4

  v1 = (int)result + dword_7DBB0 - 1;
  if ( (unsigned int)*(unsigned __int8 *)(v1 + 76) - 3 > 1 )
    result = signal((int)result, (__sighandler_t)1);
  *(_BYTE *)(v1 + 76) = 4;
  return result;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A17C) --------------------------------------------------------
void __noreturn sub_2A17C()
{
  int v0; // r4

  v0 = dword_7DBB0;
  *(_DWORD *)(dword_7DBB0 + 44) = 0;
  sub_18158(1);
  if ( *(_DWORD *)(v0 + 12) || !*(_BYTE *)(v0 + 64) )
  {
    signal(2, 0);
    raise(2);
  }
  *(_BYTE *)v0 = -126;
  sub_29EE0(0);
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A1D8) --------------------------------------------------------
int __fastcall sub_2A1D8(int result)
{
  _DWORD *v1; // r3

  v1 = (_DWORD *)dword_7DBB0;
  if ( result != 17 || (*(_DWORD *)(dword_7DBB0 + 48) = 1, v1[69]) )
  {
    *((_BYTE *)v1 + result + 139) = 1;
    v1[13] = result;
    if ( result == 2 && !v1[54] )
    {
      if ( !v1[10] )
      {
        v1[13] = 0;
        sub_2A17C();
      }
      v1[11] = 1;
    }
  }
  return result;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A248) --------------------------------------------------------
void sub_2A248()
{
  int v0; // r3

  v0 = dword_7DBB0;
  *(_DWORD *)(dword_7DBB0 + 40) = 0;
  if ( *(_DWORD *)(v0 + 44) )
    sub_2A17C();
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A2A4) --------------------------------------------------------
int sub_2A2A4()
{
  int v0; // r2
  int result; // r0

  ++*(_DWORD *)(dword_7DBB0 + 40);
  result = sub_177D8();
  v0 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v0 + 44) )
      sub_2A17C();
  }
  return result;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A2CC) --------------------------------------------------------
_DWORD *__fastcall sub_2A2CC(_DWORD *result)
{
  int v1; // r2
  _DWORD *v3; // r6
  int v4; // r4
  int v5; // r7
  int v6; // r3
  int v7; // r3
  _DWORD **v8; // r5
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_16; // [sp+10h] [bp+10h]

  v3 = result;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v4 = dword_7D6A4;
  v5 = dword_7D6A4 + 124;
LABEL_2:
  if ( v4 != v5 )
  {
    v8 = (_DWORD **)v4;
    while ( 1 )
    {
      result = *v8;
      if ( !*v8 )
      {
        v4 += 4;
        goto LABEL_2;
      }
      v6 = result[2];
      if ( v6 )
      {
        if ( v6 != 2 )
          goto LABEL_12;
        v7 = dword_7D4CC;
      }
      else
      {
        v7 = result[1];
      }
      if ( v7 < (int)v3 )
      {
LABEL_12:
        v8 = (_DWORD **)*v8;
      }
      else
      {
        *v8 = (_DWORD *)*result;
        free(result);
      }
    }
  }
  v1 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v1 + 44) )
    {
      savedregs_16 = savedregs;
      sub_2A17C(result);
    }
  }
  return result;
}
// 2A298: variable 'savedregs' is possibly undefined
// 2A17C: using guessed type void __fastcall __noreturn sub_2A17C(_DWORD);
// 7D4CC: using guessed type int dword_7D4CC;
// 7D6A4: using guessed type int dword_7D6A4;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A368) --------------------------------------------------------
_DWORD *__fastcall sub_2A368(unsigned __int8 *a1)
{
  int v2; // r4
  int v3; // r5
  int v4; // r6
  unsigned __int8 *i; // r2
  unsigned __int8 *v6; // r8
  int v7; // r1
  int v8; // r3
  int v9; // t1
  bool v10; // zf
  bool v11; // zf
  _DWORD *v12; // r0
  _DWORD *result; // r0

  v2 = -1;
  v3 = 0;
  v4 = 9999;
  for ( i = (unsigned __int8 *)(*(_DWORD *)(dword_7DBB4 + 208) + 5); ; i = v6 + 1 )
  {
    v6 = a1;
    v7 = *i;
    v9 = *a1++;
    v8 = v9;
    if ( v7 == v9 )
    {
      v6 = i;
      goto LABEL_12;
    }
    if ( *i )
    {
      v10 = v8 == 0;
      if ( !v8 )
        v10 = v7 == 58;
      if ( !v10 )
      {
LABEL_6:
        v4 = v3;
        goto LABEL_12;
      }
    }
    else if ( v8 != 58 )
    {
      goto LABEL_6;
    }
    v4 = v3 + 1;
LABEL_12:
    if ( !v8 )
      break;
    if ( v8 == 37 )
    {
      if ( v2 == -1 )
      {
        if ( sub_295E8(a1, (int)"builtin") )
          v2 = v3;
      }
    }
    else if ( v8 == 58 )
    {
      ++v3;
    }
  }
  if ( ((v2 != -1) & ((unsigned int)dword_7D4CC >> 31)) != 0 )
    dword_7D4CC = v2;
  v11 = dword_7D4CC == 0;
  if ( dword_7D4CC >= 0 )
    v11 = v2 == -1;
  if ( v11 )
    v12 = 0;
  else
    v12 = (_DWORD *)v4;
  result = sub_2A2CC(v12);
  dword_7D4CC = v2;
  return result;
}
// 7D4CC: using guessed type int dword_7D4CC;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002A454) --------------------------------------------------------
_DWORD *sub_2A454()
{
  _DWORD *result; // r0
  _DWORD *v1; // r5

  result = (_DWORD *)dword_7D6DC;
  if ( dword_7D6DC )
  {
    ++*(_DWORD *)(dword_7DBB0 + 40);
    do
    {
      v1 = (_DWORD *)*result;
      free(result);
      result = v1;
    }
    while ( v1 );
    dword_7D6DC = 0;
    result = (_DWORD *)((int (*)(void))loc_2A270)();
    dword_7D6EC = 0;
  }
  else
  {
    dword_7D6EC = 0;
  }
  return result;
}
// 7D6DC: using guessed type int dword_7D6DC;
// 7D6EC: using guessed type int dword_7D6EC;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A4C4) --------------------------------------------------------
int __fastcall sub_2A4C4(const char *a1)
{
  void **v1; // r0

  v1 = (void **)sub_29CD0(a1);
  if ( !*v1 )
    return 1;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  *v1 = sub_29978(*v1);
  ((void (*)(void))loc_2A270)();
  return 0;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A514) --------------------------------------------------------
void sub_2A514()
{
  int v0; // r2
  _DWORD *v1; // r4
  int v2; // r2
  void *v3; // r0
  int v4; // r3
  bool v5; // zf
  int v6; // r3
  int v7; // r2
  _DWORD *v8; // r3
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_8; // [sp+8h] [bp+8h]

  v1 = (_DWORD *)*((_DWORD *)off_7D4D0 + 7);
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v2 = v1[3];
  if ( v2 )
  {
    v3 = (void *)v1[4];
    v4 = *(unsigned __int8 *)(*((_DWORD *)off_7D4D0 + 5) - 1);
    v5 = v4 == 9;
    if ( v4 != 9 )
      v5 = v4 == 32;
    if ( v5 )
      dword_7D698 |= 1u;
    if ( v3 != *(void **)(v2 + 8) )
      free(v3);
    v6 = v1[3];
    v7 = *(_DWORD *)(v6 + 12);
    *(_DWORD *)(v6 + 12) = v7 & 0xFFFFFFFE;
    if ( (v7 & 2) != 0 )
      sub_2A4C4(*(const char **)(v6 + 4));
  }
  v8 = (_DWORD *)((char *)off_7D4D0 + 32);
  *((_DWORD *)off_7D4D0 + 5) = v1[1];
  *(v8 - 5) = v1[2];
  v8[10] = v1[7];
  v8[8] = v1[5];
  v8[9] = v1[6];
  *(v8 - 1) = *v1;
  if ( v1 != v8 )
    free(v1);
  v0 = dword_7DBB0;
  v5 = (*(_DWORD *)(dword_7DBB0 + 40))-- == 1;
  if ( v5 )
  {
    if ( *(_DWORD *)(v0 + 44) )
    {
      savedregs_8 = savedregs;
      sub_2A17C();
    }
  }
}
// 2A298: variable 'savedregs' is possibly undefined
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D698: using guessed type int dword_7D698;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A5FC) --------------------------------------------------------
void sub_2A5FC()
{
  int v0; // r2
  void *v2; // r4
  int v3; // r0
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_8; // [sp+8h] [bp+8h]

  v2 = off_7D4D0;
  if ( off_7D4D0 != &unk_7D64C )
  {
    ++*(_DWORD *)(dword_7DBB0 + 40);
    v3 = *((_DWORD *)v2 + 2);
    if ( v3 >= 0 )
      close(v3);
    free(*((void **)v2 + 6));
    while ( *((_DWORD *)v2 + 7) )
      sub_2A514();
    off_7D4D0 = *(_UNKNOWN **)v2;
    free(v2);
    v0 = dword_7DBB0;
    if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
    {
      if ( *(_DWORD *)(v0 + 44) )
      {
        savedregs_8 = savedregs;
        sub_2A17C();
      }
    }
  }
}
// 2A298: variable 'savedregs' is possibly undefined
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A67C) --------------------------------------------------------
size_t __fastcall sub_2A67C(const char *a1)
{
  int v1; // r2
  _DWORD *v4; // r4
  size_t result; // r0
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_8; // [sp+8h] [bp+8h]

  ++*(_DWORD *)(dword_7DBB0 + 40);
  sub_298B8();
  v4 = off_7D4D0;
  *((_DWORD *)off_7D4D0 + 5) = a1;
  result = strlen(a1);
  v4[3] = result;
  v4[6] = 0;
  v4[1] = 1;
  v1 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v1 + 44) )
    {
      savedregs_8 = savedregs;
      sub_2A17C();
    }
  }
  return result;
}
// 2A298: variable 'savedregs' is possibly undefined
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A6D4) --------------------------------------------------------
_DWORD *__fastcall sub_2A6D4(const char *a1, int a2)
{
  int v2; // r2
  size_t v6; // r7
  _DWORD *result; // r0
  _DWORD *v8; // r3
  int v9; // r2
  int v10; // r2
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_16; // [sp+10h] [bp+10h]

  v6 = strlen(a1);
  ++*(_DWORD *)(dword_7DBB0 + 40);
  if ( *((_DWORD *)off_7D4D0 + 7) )
  {
    result = sub_174DC(0x20u);
    *result = *((_DWORD *)off_7D4D0 + 7);
  }
  else
  {
    result = (_DWORD *)((char *)off_7D4D0 + 32);
  }
  v8 = off_7D4D0;
  v9 = *((_DWORD *)off_7D4D0 + 5);
  *((_DWORD *)off_7D4D0 + 7) = result;
  result[1] = v9;
  result[2] = v8[3];
  result[7] = v8[18];
  result[5] = v8[16];
  v10 = v8[17];
  result[3] = a2;
  result[6] = v10;
  if ( a2 )
  {
    *(_DWORD *)(a2 + 12) |= 1u;
    result[4] = a1;
  }
  v8[5] = a1;
  v8[3] = v6;
  v8[18] = 0;
  v2 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v2 + 44) )
    {
      savedregs_16 = savedregs;
      sub_2A17C();
    }
  }
  return result;
}
// 2A298: variable 'savedregs' is possibly undefined
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A794) --------------------------------------------------------
void sub_2A794()
{
  int v0; // r2
  int v2; // r4

  ++*(_DWORD *)(dword_7DBB0 + 40);
  v2 = *(_DWORD *)dword_7D700;
  *(_DWORD *)dword_7D700 = **(_DWORD **)dword_7D700;
  if ( *(_DWORD *)(v2 + 8) == 1 )
    sub_299F4(*(void **)(v2 + 4));
  free((void *)v2);
  v0 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v0 + 44) )
      sub_2A17C();
  }
}
// 7D700: using guessed type int dword_7D700;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A7EC) --------------------------------------------------------
int sub_2A7EC()
{
  void *v0; // r4
  int v1; // r2

  ++*(_DWORD *)(dword_7DBB0 + 40);
  v0 = sub_174DC(8u);
  v1 = dword_7D70C;
  dword_7D70C = (int)v0;
  *(_DWORD *)v0 = v1;
  ((void (*)(void))loc_2A270)();
  return *(_DWORD *)v0;
}
// 7D70C: using guessed type int dword_7D70C;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A834) --------------------------------------------------------
int __fastcall sub_2A834(int result, int a2, int a3)
{
  int v3; // r8
  int *v6; // r4

  v3 = result;
  if ( dword_7D6EC )
  {
    ++*(_DWORD *)(dword_7DBB0 + 40);
    v6 = (int *)sub_174DC(0x10u);
    *(_DWORD *)dword_7D6EC = v6;
    result = ((int (*)(void))loc_2A270)();
  }
  else
  {
    v6 = &dword_7D6DC;
  }
  dword_7D6EC = (int)v6;
  v6[1] = v3;
  v6[2] = a2;
  v6[3] = a3;
  return result;
}
// 7D6DC: using guessed type int dword_7D6DC;
// 7D6EC: using guessed type int dword_7D6EC;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A8A4) --------------------------------------------------------
int __fastcall sub_2A8A4(int result)
{
  int *v1; // r3
  int v2; // r5
  int v3; // r2
  int v4; // r3
  int v5; // r8
  _DWORD *v6; // r6
  int v7; // r8

  if ( dword_7D6EC )
  {
    v1 = &dword_7D6DC;
    v2 = result;
    if ( dword_7D6E4 > result )
    {
      while ( dword_7D6DC )
      {
        ++*(_DWORD *)(dword_7DBB0 + 40);
        v5 = *(_DWORD *)dword_7D6DC;
        free((void *)dword_7D6DC);
        dword_7D6DC = v5;
        result = ((int (*)(void))loc_2A270)();
      }
      if ( dword_7D6E0 <= v2 )
      {
        dword_7D6EC = (int)&dword_7D6DC;
        dword_7D6E4 = v2;
      }
      else
      {
        dword_7D6EC = dword_7D6DC;
      }
    }
    else
    {
      v3 = 0;
      dword_7D6EC = (int)&dword_7D6DC;
      while ( *v1 )
      {
        result = *(_DWORD *)(*v1 + 4);
        if ( result >= v2 )
        {
          if ( v3 )
            dword_7D6EC = (int)v1;
          while ( 1 )
          {
            v4 = dword_7D6EC;
            if ( !*(_DWORD *)dword_7D6EC )
              break;
            ++*(_DWORD *)(dword_7DBB0 + 40);
            v6 = (_DWORD *)dword_7D6EC;
            v7 = **(_DWORD **)dword_7D6EC;
            free(*(void **)dword_7D6EC);
            *v6 = v7;
            result = ((int (*)(void))loc_2A270)();
          }
          goto LABEL_9;
        }
        v3 = 1;
        v1 = (int *)*v1;
      }
      if ( v3 )
        dword_7D6EC = (int)v1;
      v4 = dword_7D6EC;
LABEL_9:
      if ( *(_DWORD *)(v4 + 8) > v2 )
        *(_DWORD *)(v4 + 8) = v2;
    }
  }
  return result;
}
// 7D6DC: using guessed type int dword_7D6DC;
// 7D6E0: using guessed type int dword_7D6E0;
// 7D6E4: using guessed type int dword_7D6E4;
// 7D6EC: using guessed type int dword_7D6EC;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002A9BC) --------------------------------------------------------
int __fastcall sub_2A9BC(int a1)
{
  int v1; // r2
  int v4; // r6
  int i; // r7
  void *v6; // r0
  int result; // r0
  void *v8; // r0
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_16; // [sp+10h] [bp+10h]

  ++*(_DWORD *)(dword_7DBB0 + 40);
  v4 = *(_DWORD *)(a1 + 20);
  for ( i = *(_DWORD *)(a1 + 12); --v4 >= 0; i += 12 )
  {
    v8 = *(void **)(i + 8);
    if ( v8 != (void *)(dword_7DBB0 + 60) )
      free(v8);
  }
  v6 = *(void **)(a1 + 12);
  if ( v6 != (void *)a1 )
    free(v6);
  *(_BYTE *)(a1 + 25) &= ~8u;
  result = sub_29708(a1, 2);
  v1 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v1 + 44) )
    {
      savedregs_16 = savedregs;
      sub_2A17C();
    }
  }
  return result;
}
// 2A298: variable 'savedregs' is possibly undefined
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002AA40) --------------------------------------------------------
_DWORD *__fastcall sub_2AA40(_DWORD *result)
{
  int v1; // r2
  _DWORD *v3; // r4
  int v4; // r5
  int v5; // r3
  int v6; // r2

  if ( *result )
  {
    v3 = result;
    ++*(_DWORD *)(dword_7DBB0 + 40);
    v4 = dword_7DBB8;
    while ( 1 )
    {
      result = *(_DWORD **)v4;
      if ( *(_DWORD *)v4 == *v3 )
        break;
      *(_DWORD *)v4 = *result;
      free(result);
    }
    v5 = v3[1];
    v6 = v3[2];
    *(_DWORD *)(v4 + 4) = v5;
    *(_DWORD *)(v4 + 12) = v6;
    *(_DWORD *)(v4 + 8) = v5 + v6;
    v1 = dword_7DBB0;
    if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
    {
      if ( *(_DWORD *)(v1 + 44) )
        sub_2A17C(result);
    }
  }
  return result;
}
// 2A17C: using guessed type void __fastcall __noreturn sub_2A17C(_DWORD);
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002AAB8) --------------------------------------------------------
int __fastcall sub_2AAB8(int fd, int a2)
{
  int v3; // r6
  int result; // r0
  bool v5; // zf

  v3 = a2 + 1;
  do
  {
    result = fcntl(fd, 1030, v3);
    if ( result >= 0 )
      break;
    v5 = *(_DWORD *)dword_7DB94 == 16;
    if ( *(_DWORD *)dword_7DB94 != 16 )
      v5 = *(_DWORD *)dword_7DB94 == 4;
  }
  while ( v5 );
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (0002AAFC) --------------------------------------------------------
int __fastcall sub_2AAFC(FILE *stream)
{
  int v1; // r2
  int result; // r0

  ++*(_DWORD *)(dword_7DBB0 + 40);
  putc_unlocked(10, stream);
  result = fflush(stream);
  v1 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v1 + 44) )
      sub_2A17C(result);
  }
  return result;
}
// 2A17C: using guessed type void __fastcall __noreturn sub_2A17C(_DWORD);
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002AB38) --------------------------------------------------------
int __fastcall sub_2AB38(const char *a1, void *a2)
{
  int v4; // r6
  const char *v5; // r5

  v4 = dword_7DBB0;
  fprintf((FILE *)stderr, "%s: ", *(const char **)(dword_7DBB0 + 32));
  v5 = (const char *)dword_7D6A8;
  if ( dword_7D6A8 )
  {
    if ( strcmp(*(const char **)(v4 + 32), (const char *)dword_7D6A8) )
      fprintf((FILE *)stderr, "%s: ", v5);
    if ( !*(_BYTE *)(v4 + 64) || *((int *)off_7D4D0 + 2) > 0 )
      fprintf((FILE *)stderr, "line %d: ", *(_DWORD *)(v4 + 16));
  }
  vfprintf((FILE *)stderr, a1, a2);
  return sub_2AAFC((FILE *)stderr);
}
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D608: using guessed type int stderr;
// 7D6A8: using guessed type int dword_7D6A8;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002ABFC) --------------------------------------------------------
void __noreturn sub_2ABFC(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  *(_BYTE *)dword_7DBB0 = 2;
  sub_2AB38(a1, varg_r1);
  sub_2A2A4();
  sub_29EE0(1);
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002AC34) --------------------------------------------------------
_DWORD *__fastcall sub_2AC34(unsigned __int8 *a1, int a2)
{
  char *v3; // r6
  _DWORD *v4; // r0
  _BYTE *v5; // r8
  _DWORD *v6; // r7
  int v7; // r4
  _DWORD *v8; // r5
  const char *v9; // r4
  int v10; // r0
  void (__fastcall *v11)(char *); // r2
  char *v12; // r3
  char *v14; // r0
  int v15; // r1
  int v16; // t1

  v3 = (char *)a1;
  v4 = (_DWORD *)sub_29678(a1);
  v5 = (_BYTE *)dword_7DBB0;
  v6 = sub_296CC(v4, (int)v3);
  v7 = v5[71] & 1 | a2;
  v8 = (_DWORD *)*v6;
  if ( !*v6 )
  {
    if ( (v7 & 0x80) != 0 )
      return v8;
    if ( (v7 & 0x27) == 0x20 )
      goto LABEL_14;
    v8 = sub_174DC(0x10u);
    *v8 = *v6;
    *v6 = v8;
LABEL_21:
    if ( (v7 & 0x118) == 0 )
      v3 = sub_174F8(v3);
    v8[1] = v7;
    v8[2] = v3;
    return v8;
  }
  if ( (v8[1] & 0x202) == 2 )
  {
    if ( (v7 & 0x100) != 0 )
      free(v3);
    v9 = (const char *)v8[2];
    *v5 = 1;
    v10 = strchrnul(v9, 61);
    sub_2ABFC("%.*s: is read only", v10 - (_DWORD)v9, v9);
  }
  if ( (v7 & 0x80) == 0 )
  {
    v11 = (void (__fastcall *)(char *))v8[3];
    if ( v11 && (v7 & 0x40) == 0 )
    {
      v12 = v3;
      do
      {
        v14 = v12;
        v16 = (unsigned __int8)*v12++;
        v15 = v16;
        if ( !v16 )
          break;
        v14 = v12;
      }
      while ( v15 != 61 );
      v11(v14);
    }
    if ( (v8[1] & 0x18) == 0 )
      free((void *)v8[2]);
    if ( (v7 & 0x27 | v8[1] & 4) == 0x20 )
    {
      *v6 = *v8;
      free(v8);
LABEL_14:
      if ( (v7 & 0x118) == 0x100 )
        free(v3);
      return v8;
    }
    v7 |= v8[1] & 0xFFFFFEC7;
    goto LABEL_21;
  }
  return v8;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002ADC0) --------------------------------------------------------
_DWORD *__fastcall sub_2ADC0(_DWORD *result, int a2)
{
  int v2; // r2
  _DWORD *v4; // r4
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_8; // [sp+8h] [bp+8h]

  v4 = result;
  if ( result )
  {
    ++*(_DWORD *)(dword_7DBB0 + 40);
    do
    {
      result = sub_2AC34((unsigned __int8 *)v4[1], a2);
      v4 = (_DWORD *)*v4;
    }
    while ( v4 );
    v2 = dword_7DBB0;
    if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
    {
      if ( *(_DWORD *)(v2 + 44) )
      {
        savedregs_8 = savedregs;
        sub_2A17C();
      }
    }
  }
  return result;
}
// 2A298: variable 'savedregs' is possibly undefined
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002AE08) --------------------------------------------------------
_DWORD *__fastcall sub_2AE08(unsigned __int8 *a1, const char *a2, int a3)
{
  unsigned __int8 *v6; // r6
  int v7; // r0
  size_t v8; // r5
  _BOOL4 v9; // r6
  int v10; // r0
  size_t v11; // r6
  void *v12; // r9
  _BYTE *v13; // r0
  char *v14; // r3
  _DWORD *v15; // r4

  v6 = sub_5871C(a1);
  v7 = strchrnul((const char *)v6, 61);
  v8 = v7 - (_DWORD)a1;
  v9 = v6 != (unsigned __int8 *)v7;
  if ( (unsigned __int8 *)v7 == a1 )
    v10 = v9 | 1;
  else
    v10 = v9;
  if ( v10 )
    sub_2ABFC("%.*s: bad variable name", v8, (const char *)a1);
  if ( a2 )
  {
    v11 = strlen(a2);
  }
  else
  {
    a3 |= 0x20u;
    v11 = 0;
  }
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v12 = sub_1748C(v8 + 2 + v11);
  v13 = memcpy(v12, a1, v8);
  v14 = &v13[v8];
  if ( a2 )
  {
    v13[v8] = 61;
    v14 = (char *)memcpy(v14 + 1, a2, v11) + v11;
  }
  *v14 = 0;
  v15 = sub_2AC34((unsigned __int8 *)v12, a3 | 0x100);
  ((void (*)(void))loc_2A270)();
  return v15;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002AEF8) --------------------------------------------------------
unsigned int __fastcall sub_2AEF8(const char *a1)
{
  _DWORD *v1; // r4
  unsigned int v2; // r0
  int v3; // r4
  unsigned __int8 *v4; // r5
  const char *v5; // r0
  unsigned int result; // r0
  int v7; // r3

  v1 = (_DWORD *)dword_7DBB0;
  if ( a1 )
  {
    result = strtoul(a1, 0, 10);
    v1[121] = result;
    if ( result )
      v7 = result;
    else
      v7 = 1;
    v1[120] = v7;
    v1[118] = v7;
    v1[119] = result;
  }
  else
  {
    v2 = sub_36EAC((__pid_t *)(dword_7DBB0 + 472));
    v3 = dword_7DBB4;
    v4 = *(unsigned __int8 **)(dword_7DBB4 + 304);
    v5 = sub_16F64(v2);
    result = (unsigned int)sub_2AE08(v4, v5, 64);
    *(_DWORD *)(v3 + 300) &= ~0x40u;
  }
  return result;
}
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002AF78) --------------------------------------------------------
_DWORD *__fastcall sub_2AF78(unsigned __int8 *a1)
{
  return sub_2AE08(a1, 0, 0);
}

//----- (0002AF84) --------------------------------------------------------
_DWORD *__fastcall sub_2AF84(unsigned __int8 *a1, const char *a2)
{
  return sub_2AE08(a1, a2, 0);
}

//----- (0002AF8C) --------------------------------------------------------
int __fastcall sub_2AF8C(unsigned __int8 *a1)
{
  const char *v1; // r1

  if ( !sub_2960C(a1) )
    sub_2ABFC("Illegal number: %s", v1);
  return atoi(v1);
}
// 2AFA4: variable 'v1' is possibly undefined

//----- (0002AFB8) --------------------------------------------------------
int __fastcall sub_2AFB8(unsigned __int8 *a1)
{
  int v1; // r4
  int result; // r0
  unsigned __int8 *v3; // r2

  v1 = dword_7DBB4;
  *(_DWORD *)(dword_7DBB4 + 4) = 1;
  result = sub_2960C(a1);
  if ( result )
  {
    result = sub_2AF8C(v3);
    if ( !result )
      result = 1;
    *(_DWORD *)(v1 + 4) = result;
  }
  *(_DWORD *)(v1 + 8) = -1;
  return result;
}
// 2AFE0: variable 'v3' is possibly undefined
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002B000) --------------------------------------------------------
int __fastcall sub_2B000(int a1, int a2)
{
  unsigned __int8 *v2; // r0
  int v3; // r5
  int v4; // r4
  void **v5; // r6
  int v6; // r7
  void **v7; // r8
  void **v8; // r5
  int v9; // r3
  int v10; // t1

  v2 = *(unsigned __int8 **)(a2 + 4);
  if ( v2 )
    v3 = sub_2AF8C(v2);
  else
    v3 = 1;
  v4 = dword_7DBB4;
  if ( *(_DWORD *)dword_7DBB4 < v3 )
    return 1;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v5 = *(void ***)(v4 + 16);
  v6 = v3;
  v7 = v5;
  *(_DWORD *)v4 -= v3;
  while ( --v6 >= 0 )
  {
    if ( *(_BYTE *)(v4 + 12) )
      free(*v7);
    ++v7;
  }
  v8 = &v5[v3 & ~(v3 >> 31)];
  v9 = *(_DWORD *)(v4 + 16) - 4;
  do
  {
    v10 = (int)*v8++;
    *(_DWORD *)(v9 + 4) = v10;
    v9 += 4;
  }
  while ( v10 );
  *(_QWORD *)(v4 + 4) = 0xFFFFFFFF00000001LL;
  ((void (*)(void))loc_2A270)();
  return 0;
}
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002B0C8) --------------------------------------------------------
int __fastcall sub_2B0C8(int a1, int a2)
{
  unsigned __int8 *v2; // r0

  v2 = *(unsigned __int8 **)(a2 + 4);
  dword_7D6B8 = 4;
  if ( v2 )
    return sub_2AF8C(v2);
  else
    return *(unsigned __int8 *)dword_7DBB0;
}
// 7D6B8: using guessed type int dword_7D6B8;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002B0FC) --------------------------------------------------------
int __fastcall sub_2B0FC(int a1, int a2, int a3, int a4)
{
  if ( a1 == a2 )
    a4 = a2;
  if ( a1 != a2 )
    a4 = dup2(a1, a2);
  if ( a4 < 0 )
    sub_2ABFC("%d: %m", a1);
  return a4;
}

//----- (0002B138) --------------------------------------------------------
void __fastcall sub_2B138(int a1)
{
  int v1; // r2
  int v3; // r8
  int v5; // r2
  _DWORD *v6; // r4
  int v7; // r9
  _DWORD *i; // r5
  int v9; // r3
  int v10; // r7
  int v11; // r0
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_24; // [sp+18h] [bp+18h]

  v3 = dword_7DBB4;
  if ( !*(_DWORD *)(dword_7DBB4 + 20) )
    return;
  v5 = dword_7DBB0;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v6 = *(_DWORD **)(v3 + 20);
  v7 = 0;
  for ( i = v6; ; i += 2 )
  {
    v9 = v6[1];
    if ( v9 <= v7 )
      break;
    v10 = i[3];
    if ( v10 == -1 )
    {
      if ( a1 )
        goto LABEL_8;
      v11 = i[2];
    }
    else
    {
      if ( v10 == -2 )
        goto LABEL_8;
      if ( !a1 )
        sub_2B0FC(i[3], i[2], v5, v9);
      v11 = v10;
    }
    close(v11);
LABEL_8:
    ++v7;
  }
  *(_DWORD *)(v3 + 20) = *v6;
  free(v6);
  v1 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v1 + 44) )
    {
      savedregs_24 = savedregs;
      sub_2A17C();
    }
  }
}
// 2B1D4: variable 'v5' is possibly undefined
// 2A298: variable 'savedregs' is possibly undefined
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002B1EC) --------------------------------------------------------
int __fastcall sub_2B1EC(int a1, __pid_t a2)
{
  int result; // r0

  result = tcsetpgrp(a1, a2);
  if ( result )
    sub_2ABFC("can't set tty process group: %m");
  return result;
}

//----- (0002B208) --------------------------------------------------------
int __fastcall sub_2B208(int a1)
{
  unsigned int v1; // r4
  _DWORD *v2; // r5
  unsigned int v3; // r6
  _DWORD *v4; // r0
  int v5; // r3
  int result; // r0

  v1 = (a1 + 7) & 0xFFFFFFF8;
  v2 = (_DWORD *)dword_7DBB8;
  if ( *(_DWORD *)(dword_7DBB8 + 12) < v1 )
  {
    if ( v1 < 0x1F8 )
      v3 = 504;
    else
      v3 = (a1 + 7) & 0xFFFFFFF8;
    ++*(_DWORD *)(dword_7DBB0 + 40);
    v4 = sub_1748C(v3 + 4);
    *v4 = *v2;
    v2[1] = v4 + 1;
    v2[3] = v3;
    v2[2] = (char *)v4 + v3 + 4;
    *v2 = v4;
    ((void (*)(void))loc_2A270)();
  }
  v5 = dword_7DBB8;
  result = *(_DWORD *)(dword_7DBB8 + 4);
  *(_DWORD *)(dword_7DBB8 + 4) = result + v1;
  *(_DWORD *)(v5 + 12) -= v1;
  return result;
}
// 2B23C: conditional instruction was optimized away because r6.4 is in (1F8..FFFFFFF8)
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002B2B0) --------------------------------------------------------
int __fastcall sub_2B2B0(_DWORD *a1, int a2)
{
  int v2; // r3
  int v3; // r2
  int v4; // r3

  v2 = dword_7DBB8;
  *a1 = *(_DWORD *)dword_7DBB8;
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_DWORD *)(v2 + 12);
  a1[1] = v3;
  a1[2] = v4;
  return sub_2B208(a2);
}
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002B2DC) --------------------------------------------------------
int __fastcall sub_2B2DC(_DWORD *a1)
{
  int v1; // r1

  v1 = *(_DWORD *)(dword_7DBB8 + 4) == *(_DWORD *)dword_7DBB8 + 4 && *(_DWORD *)dword_7DBB8 != dword_7DBB8 + 16;
  return sub_2B2B0(a1, v1);
}
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002B310) --------------------------------------------------------
void *__fastcall sub_2B310(const char *a1)
{
  size_t v2; // r4
  void *v3; // r0

  v2 = strlen(a1) + 1;
  v3 = (void *)sub_2B208(v2);
  return memcpy(v3, a1, v2);
}

//----- (0002B338) --------------------------------------------------------
int __fastcall sub_2B338(int a1, char a2)
{
  _BYTE *v4; // r5
  int v5; // r0
  int v6; // r4
  int v7; // r5
  _DWORD *v8; // r6
  int v9; // r3
  _DWORD *v10; // r3

  v4 = (_BYTE *)dword_7DBB0;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v5 = open64(a1, 0x80000);
  v6 = v5;
  if ( v5 < 0 )
  {
    if ( (a2 & 2) == 0 )
    {
      *v4 = 127;
      sub_2ABFC("can't open '%s': %m", a1);
    }
    goto LABEL_15;
  }
  if ( v5 > 9 )
  {
    v7 = v5;
    goto LABEL_10;
  }
  v7 = fcntl(v5, 1030, 10);
  if ( v7 >= 0 )
    goto LABEL_9;
  if ( *(_DWORD *)dword_7DB94 != 9 )
  {
    if ( *(_DWORD *)dword_7DB94 )
      sub_2ABFC("%d: %m", v6);
LABEL_9:
    close(v6);
  }
LABEL_10:
  if ( (a2 & 1) != 0 )
  {
    sub_298B8();
    *((_DWORD *)off_7D4D0 + 6) = 0;
  }
  v8 = off_7D4D0;
  v9 = *((_DWORD *)off_7D4D0 + 6);
  *((_DWORD *)off_7D4D0 + 2) = v7;
  if ( !v9 )
    v8[6] = sub_1748C(0x400u);
  v10 = off_7D4D0;
  v6 = v7;
  *((_DWORD *)off_7D4D0 + 4) = 0;
  v10[3] = 0;
  v10[1] = 1;
LABEL_15:
  ((void (*)(void))loc_2A270)();
  return v6;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7DB94: using guessed type int dword_7DB94;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002B44C) --------------------------------------------------------
void __fastcall __noreturn sub_2B44C(const char *a1)
{
  *(_DWORD *)(dword_7DBB0 + 16) = *((_DWORD *)off_7D4D0 + 1);
  sub_2ABFC("syntax error: %s", a1);
}
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002B480) --------------------------------------------------------
int __fastcall sub_2B480(unsigned __int8 *a1)
{
  unsigned __int8 *v2; // r2
  _BYTE *v3; // r1
  int result; // r0
  int v5; // r12
  int v6; // r12
  int *v7; // r3

  v2 = (unsigned __int8 *)dword_7D720;
  if ( !dword_7D720 || !*(_BYTE *)dword_7D720 )
  {
    v3 = *(_BYTE **)dword_7D640;
    if ( !*(_DWORD *)dword_7D640 )
      return 0;
    if ( *v3 != 45 )
      return 0;
    v5 = (unsigned __int8)v3[1];
    v2 = v3 + 1;
    if ( !v3[1] )
      return 0;
    dword_7D640 += 4;
    if ( v5 == 45 && !v3[2] )
      return 0;
  }
  v6 = (int)(v2 + 1);
  while ( *a1 != *v2 )
  {
    if ( !*a1 )
      sub_2ABFC("illegal option -%c");
    if ( a1[1] == 58 )
      a1 += 2;
    else
      ++a1;
  }
  result = *v2;
  if ( a1[1] == 58 )
  {
    if ( !v2[1] )
    {
      v7 = (int *)dword_7D640;
      dword_7D640 += 4;
      v6 = *v7;
      if ( !*v7 )
        sub_2ABFC("no arg for -%c option");
    }
    dword_7D71C = v6;
    v6 = 0;
  }
  dword_7D720 = v6;
  return result;
}
// 7D640: using guessed type int dword_7D640;
// 7D71C: using guessed type int dword_7D71C;
// 7D720: using guessed type int dword_7D720;

//----- (0002B5A0) --------------------------------------------------------
char *sub_2B5A0()
{
  int i; // r5
  int v1; // r0
  int v2; // r4
  char *result; // r0
  char *v4; // t1
  char *v5; // r0

  for ( i = 0; ; i = v1 )
  {
    v1 = sub_2B480("vf");
    if ( !v1 )
      break;
  }
  v2 = dword_7D640 - 4;
  while ( 1 )
  {
    v4 = *(char **)(v2 + 4);
    v2 += 4;
    result = v4;
    if ( !v4 )
      break;
    if ( i == 102 )
    {
      v5 = sub_29D4C(result, 0);
      if ( v5 )
      {
        if ( *((_DWORD *)v5 + 2) == 1 )
          sub_2A794();
      }
    }
    else
    {
      sub_2AF78((unsigned __int8 *)result);
    }
  }
  return result;
}
// 7D640: using guessed type int dword_7D640;

//----- (0002B618) --------------------------------------------------------
int sub_2B618()
{
  int v0; // r4
  const char **v1; // r5
  int i; // r5
  void **v3; // r6
  void *v5; // r0

  v0 = sub_2B480((unsigned __int8 *)"a");
  if ( v0 )
  {
    ++*(_DWORD *)(dword_7DBB0 + 40);
    for ( i = 0; i != 156; i += 4 )
    {
      v0 = *(_DWORD *)(dword_7D644 + i);
      v3 = (void **)(dword_7D644 + i);
      while ( v0 )
      {
        v5 = sub_29978(*v3);
        *v3 = v5;
        if ( v5 == (void *)v0 )
          v3 = (void **)v0;
        v0 = (int)*v3;
      }
    }
    ((void (*)(void))loc_2A270)();
  }
  else
  {
    while ( 1 )
    {
      v1 = (const char **)dword_7D640;
      if ( !*(_DWORD *)dword_7D640 )
        break;
      if ( sub_2A4C4(*(const char **)dword_7D640) )
      {
        v0 = 1;
        fprintf((FILE *)stderr, "%s: %s not found\n", "unalias", *v1);
      }
      dword_7D640 += 4;
    }
  }
  return v0;
}
// 7D608: using guessed type int stderr;
// 7D640: using guessed type int dword_7D640;
// 7D644: using guessed type int dword_7D644;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002B6FC) --------------------------------------------------------
int sub_2B6FC()
{
  int v0; // r5
  int v1; // r4
  int v2; // r0
  bool v4; // zf

  v0 = 76;
  v1 = 0;
  while ( 1 )
  {
    v2 = sub_2B480((unsigned __int8 *)"LP");
    if ( !v2 )
      break;
    v4 = v0 == v2;
    v0 = v2;
    if ( !v4 )
      v1 ^= 1u;
  }
  return v1;
}

//----- (0002B738) --------------------------------------------------------
int __fastcall sub_2B738(int a1, int a2)
{
  int (__fastcall *v2)(_DWORD, int); // r10
  int v5; // r4
  int v6; // r5
  int v7; // r8
  bool v8; // zf
  const char *v9; // r5
  unsigned int v11; // r0
  int v12; // r7

  v5 = dword_7D6AC;
  if ( !a1 )
    goto LABEL_12;
  if ( *(_BYTE *)a1 != 37 )
  {
LABEL_21:
    v9 = "%s: no such job";
LABEL_22:
    sub_2ABFC(v9, a1);
  }
  v6 = *(unsigned __int8 *)(a1 + 1);
  v7 = a1 + 1;
  if ( !*(_BYTE *)(a1 + 1) )
    goto LABEL_12;
  if ( *(_BYTE *)(a1 + 2) )
    goto LABEL_17;
  v8 = v6 == 37;
  if ( v6 != 37 )
    v8 = v6 == 43;
  if ( v8 )
  {
LABEL_12:
    v9 = "No current job";
    goto LABEL_13;
  }
  if ( v6 == 45 )
  {
    if ( !dword_7D6AC )
      sub_2ABFC("No previous job", a1);
    v5 = *(_DWORD *)(dword_7D6AC + 28);
    v9 = "No previous job";
    goto LABEL_13;
  }
LABEL_17:
  if ( sub_2960C((unsigned __int8 *)(a1 + 1)) )
  {
    v11 = atoi((const char *)(a1 + 1));
    if ( v11 )
    {
      if ( dword_7D718 >= v11 )
      {
        v5 = dword_7D6FC + 32 * (v11 + 0x7FFFFFF);
        if ( (*(_BYTE *)(v5 + 25) & 8) != 0 )
          goto LABEL_14;
        goto LABEL_21;
      }
    }
  }
  if ( v6 == 63 )
    v2 = (int (__fastcall *)(_DWORD, int))strstr;
  v12 = v5;
  if ( v6 == 63 )
    v7 = a1 + 2;
  else
    v2 = (int (__fastcall *)(_DWORD, int))sub_295E8;
  v9 = "%s: no such job";
  v5 = 0;
  while ( v12 )
  {
    if ( v2(*(_DWORD *)(*(_DWORD *)(v12 + 12) + 8), v7) )
    {
      if ( v5 )
        goto LABEL_22;
      v5 = v12;
      v9 = "%s: ambiguous";
    }
    v12 = *(_DWORD *)(v12 + 28);
  }
LABEL_13:
  if ( !v5 )
    goto LABEL_22;
LABEL_14:
  if ( a2 && (*(_BYTE *)(v5 + 25) & 2) == 0 )
    sub_2ABFC("job %s not created under job control", a1);
  return v5;
}
// 2B85C: variable 'v2' is possibly undefined
// 7D6AC: using guessed type int dword_7D6AC;
// 7D6FC: using guessed type int dword_7D6FC;
// 7D718: using guessed type int dword_7D718;

//----- (0002B8B0) --------------------------------------------------------
int __fastcall sub_2B8B0(int fd, int a2)
{
  int v3; // r7
  int v4; // r0
  int v5; // r5
  int v6; // r3
  bool v7; // zf
  int v8; // r0

  v3 = a2 + 1;
  do
  {
    v4 = fcntl(fd, 1030, v3);
    v5 = v4;
    if ( v4 >= 0 )
    {
      v8 = fd;
      fd = v5;
      close(v8);
      return fd;
    }
    v6 = *(_DWORD *)dword_7DB94;
    v7 = *(_DWORD *)dword_7DB94 == 16;
    if ( *(_DWORD *)dword_7DB94 != 16 )
      v7 = v6 == 4;
  }
  while ( v7 );
  if ( v6 != 9 )
    sub_2ABFC("%d: %m", v4);
  return fd;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (0002B91C) --------------------------------------------------------
int __fastcall sub_2B91C(int a1, _BYTE **a2)
{
  const char *v3; // r4
  int v4; // r0
  int v5; // r3
  int v6; // r1

  v3 = a2[1];
  if ( v3 )
  {
    v4 = sub_2AF8C(a2[1]);
    if ( v4 <= 0 )
      sub_2ABFC("Illegal number: %s", v3);
  }
  else
  {
    v4 = 1;
  }
  v5 = dword_7D710;
  if ( v4 <= dword_7D710 )
  {
    v5 = v4;
  }
  else if ( dword_7D710 <= 0 )
  {
    return 0;
  }
  if ( **a2 == 99 )
    v6 = 2;
  else
    v6 = 1;
  dword_7D6B8 = v6;
  dword_7D730 = v5;
  return 0;
}
// 7D6B8: using guessed type int dword_7D6B8;
// 7D710: using guessed type int dword_7D710;
// 7D730: using guessed type int dword_7D730;

//----- (0002B9AC) --------------------------------------------------------
int sub_2B9AC(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  return sub_2AB38(a1, varg_r1);
}

//----- (0002B9D4) --------------------------------------------------------
int __fastcall sub_2B9D4(int result)
{
  int v1; // r8
  int v2; // r7
  int v3; // r5
  int v4; // r0
  int v5; // r9
  int v6; // r4
  __pid_t v8; // r9
  __pid_t v9; // r0
  __pid_t v10; // r7
  __pid_t v11; // r1
  __pid_t v12; // r5

  if ( dword_7D6B0 != result )
  {
    v1 = dword_7DBB0;
    v2 = *(_DWORD *)(dword_7DBB0 + 12);
    if ( !v2 )
    {
      v3 = result;
      if ( result )
      {
        v4 = open64("/dev/tty", 2);
        v5 = v4;
        if ( v4 < 0 )
        {
          v6 = 2;
          while ( !isatty(v6) )
          {
            if ( v6-- == 0 )
              goto LABEL_15;
          }
        }
        else
        {
          v6 = v4;
        }
        v6 = fcntl(v6, 1030, 10);
        if ( v5 >= 0 )
          close(v5);
        if ( v6 >= 0 )
        {
          while ( 1 )
          {
            v8 = tcgetpgrp(v6);
            if ( v8 < 0 )
              break;
            v9 = getpgrp();
            if ( v9 == v8 )
            {
              dword_7D6F0 = v9;
              sub_29F94(20);
              sub_29F94(22);
              sub_29F94(21);
              v10 = *(_DWORD *)(v1 + 8);
              setpgid(0, v10);
              v11 = v10;
              v2 = v3;
              result = sub_2B1EC(v6, v11);
              goto LABEL_22;
            }
            killpg(0, 21);
          }
        }
LABEL_15:
        result = sub_2B9AC("can't access tty; job control turned off");
        *(_BYTE *)(v1 + 65) = 0;
      }
      else
      {
        v6 = dword_7D4D4;
        v12 = dword_7D6F0;
        tcsetpgrp(dword_7D4D4, dword_7D6F0);
        setpgid(0, v12);
        sub_29F94(20);
        sub_29F94(22);
        result = sub_29F94(21);
      }
      if ( v6 >= 0 )
        result = close(v6);
      v6 = -1;
LABEL_22:
      dword_7D6B0 = v2;
      dword_7D4D4 = v6;
    }
  }
  return result;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D4D4: using guessed type int dword_7D4D4;
// 7D6B0: using guessed type int dword_7D6B0;
// 7D6F0: using guessed type int dword_7D6F0;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002BB6C) --------------------------------------------------------
int sub_2BB6C()
{
  int v0; // r4
  int result; // r0
  int v2; // r3
  unsigned int v3; // r3

  v0 = dword_7DBB0;
  if ( *(unsigned __int8 *)(dword_7DBB0 + 64) + 1 != dword_7D6F4 )
  {
    dword_7D6F4 = *(unsigned __int8 *)(dword_7DBB0 + 64) + 1;
    sub_29F94(2);
    sub_29F94(3);
    sub_29F94(15);
  }
  result = sub_2B9D4(*(unsigned __int8 *)(v0 + 65));
  v2 = *(_DWORD *)dword_7D708;
  if ( *(_BYTE *)(v0 + 74) )
    v3 = v2 | 8;
  else
    v3 = v2 & 0xFFFFFFF7;
  *(_DWORD *)dword_7D708 = v3;
  return result;
}
// 7D6F4: using guessed type int dword_7D6F4;
// 7D708: using guessed type int dword_7D708;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002BBE4) --------------------------------------------------------
const char *__fastcall sub_2BBE4(int a1)
{
  int v1; // r2
  char *v4; // r8
  _DWORD *i; // r6
  _DWORD *v6; // r6
  const char *result; // r0
  char *v8; // r2
  int v9; // r3
  int v10; // r1
  int v11; // t1
  const char *v12; // r5
  int v13; // r3
  int v14; // r3
  _DWORD *v15; // r0
  const char **v16; // r0
  int v17; // r3
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_16; // [sp+10h] [bp+10h]

  v4 = strchr((const char *)a1, 61);
  ++*(_DWORD *)(dword_7DBB0 + 40);
  for ( i = *(_DWORD **)(dword_7D70C + 4); ; i = (_DWORD *)*i )
  {
    if ( !i )
    {
      v6 = sub_174DC(0x10u);
      if ( *(_BYTE *)a1 != 45 || *(_BYTE *)(a1 + 1) )
      {
        v15 = (_DWORD *)sub_29678((unsigned __int8 *)a1);
        v16 = (const char **)sub_296CC(v15, a1);
        v12 = *v16;
        if ( *v16 )
        {
          v6[3] = *((_DWORD *)v12 + 2);
          v17 = *((_DWORD *)v12 + 1);
          v6[2] = v17;
          *((_DWORD *)v12 + 1) = v17 | 0xC;
          if ( v4 )
            result = (const char *)sub_2AC34((unsigned __int8 *)a1, 0);
          else
            result = (const char *)sub_2AF84((unsigned __int8 *)a1, 0);
        }
        else
        {
          if ( v4 )
            result = (const char *)sub_2AC34((unsigned __int8 *)a1, 4);
          else
            result = (const char *)sub_2AE08((unsigned __int8 *)a1, *v16, 4);
          v12 = result;
          v6[2] = 32;
        }
      }
      else
      {
        result = (const char *)sub_1748C(0xFu);
        v8 = (char *)result;
        v9 = dword_7DBB0 + 61;
        v10 = dword_7DBB0 + 73;
        do
        {
          v11 = *(_DWORD *)v9;
          v9 += 4;
          *(_DWORD *)v8 = v11;
          v8 += 4;
        }
        while ( v9 != v10 );
        v12 = 0;
        *(_WORD *)v8 = *(_WORD *)v9;
        v8[2] = *(_BYTE *)(v9 + 2);
        v6[3] = result;
      }
      v13 = dword_7D70C;
      v6[1] = v12;
      *v6 = *(_DWORD *)(v13 + 4);
      *(_DWORD *)(v13 + 4) = v6;
      goto LABEL_23;
    }
    v14 = i[1];
    if ( v14 )
    {
      result = (const char *)sub_29638(*(_DWORD *)(v14 + 8), a1);
      if ( !result )
        break;
    }
  }
  if ( v4 )
    result = (const char *)sub_2AC34((unsigned __int8 *)a1, 0);
LABEL_23:
  v1 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v1 + 44) )
    {
      savedregs_16 = savedregs;
      sub_2A17C();
    }
  }
  return result;
}
// 2A298: variable 'savedregs' is possibly undefined
// 7D70C: using guessed type int dword_7D70C;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002BD78) --------------------------------------------------------
int sub_2BD78()
{
  int *v0; // r4
  int result; // r0
  int v2; // t1

  if ( !dword_7D70C )
    sub_2ABFC("not in a function");
  v0 = (int *)dword_7D640;
  while ( 1 )
  {
    v2 = *v0++;
    result = v2;
    if ( !v2 )
      break;
    sub_2BBE4(result);
  }
  return result;
}
// 7D640: using guessed type int dword_7D640;
// 7D70C: using guessed type int dword_7D70C;

//----- (0002BDBC) --------------------------------------------------------
_DWORD *__fastcall sub_2BDBC(const char *a1, int a2)
{
  int v3; // r6
  char *v4; // r4
  int v5; // r9
  char *v6; // r0
  int v7; // r7
  bool v8; // zf
  char *v9; // r0
  char *v11; // r6

  v3 = dword_7DBB0;
  v4 = *(char **)(dword_7DBB0 + 24);
  if ( a2 )
    sub_2AE08("OLDPWD", *(const char **)(dword_7DBB0 + 24), 1);
  ++*(_DWORD *)(v3 + 40);
  v5 = dword_7DBB0;
  v6 = *(char **)(dword_7DBB0 + 28);
  v7 = dword_7DBB0 + 60;
  if ( v6 != (char *)(dword_7DBB0 + 60) )
  {
    if ( v6 != v4 )
      free(v6);
    *(_DWORD *)(v5 + 28) = v7;
  }
  v8 = a1 == 0;
  if ( a1 )
    v8 = v4 == a1;
  if ( v8 )
  {
    v9 = getcwd(0, 0);
    if ( v9 )
      v11 = v9;
    else
      v11 = (char *)v7;
    *(_DWORD *)(v5 + 28) = v11;
    if ( a1 )
      goto LABEL_15;
  }
  else
  {
    v11 = sub_174F8(a1);
  }
  if ( v11 != v4 )
  {
    if ( (char *)v7 != v4 )
      free(v4);
    v4 = v11;
  }
LABEL_15:
  *(_DWORD *)(dword_7DBB0 + 24) = v4;
  ((void (*)(void))loc_2A270)();
  return sub_2AE08((unsigned __int8 *)"PWD", v4, 1);
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002BEA0) --------------------------------------------------------
int sub_2BEA0(const char *a1, ...)
{
  int v1; // r4
  int v2; // r1
  int varg_r1; // [sp+14h] [bp+Ch] BYREF
  va_list varg_r1a; // [sp+14h] [bp+Ch]
  va_list varg_r2; // [sp+18h] [bp+10h] BYREF

  va_start(varg_r2, a1);
  va_start(varg_r1a, a1);
  varg_r1 = va_arg(varg_r2, _DWORD);
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v1 = vprintf(a1, varg_r1a);
  ((void (__fastcall *)(int, int))loc_2A270)(v1, v2);
  return v1;
}
// 2BED0: variable 'v2' is possibly undefined
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002BEEC) --------------------------------------------------------
int __fastcall sub_2BEEC(int a1, _DWORD *a2)
{
  int v2; // r6
  int v4; // r2
  unsigned __int8 *v5; // r3
  int v6; // r12
  const char *v7; // r8
  int v8; // r4
  int v10; // r0
  int v11; // r11
  int v12; // r2
  int v13; // t1
  const char *v14; // r5
  int v15; // r1
  int v16; // r1
  char *v17; // r3
  const char *v18; // r0
  char *v19; // r2
  int v20; // r1
  int v21; // r1
  _BOOL4 v22; // r0
  int v23; // r1
  int v24; // [sp+4h] [bp-8h]

  v2 = a1;
  if ( a1 )
    *(_DWORD *)(dword_7DBB0 + 20) = 0;
  while ( 1 )
  {
LABEL_3:
    v4 = dword_7D640;
    v5 = *(unsigned __int8 **)dword_7D640;
    if ( !*(_DWORD *)dword_7D640 )
      return 0;
    v6 = *v5;
    v7 = (const char *)(v5 + 1);
    v8 = ((_BYTE)v6 - 43) & 0xFD;
    if ( (((_BYTE)v6 - 43) & 0xFD) != 0 )
      return 0;
    v10 = dword_7D640 + 4;
    dword_7D640 += 4;
    if ( v6 != 45 )
      goto LABEL_18;
    if ( !v5[1] )
      break;
    if ( v5[1] == 45 && !v5[2] )
    {
      if ( !v2 && !*(_DWORD *)(v4 + 4) )
      {
        sub_29F0C(v10);
        return v2;
      }
      return 0;
    }
    v8 = 1;
LABEL_18:
    while ( 1 )
    {
      v13 = *(unsigned __int8 *)v7++;
      v12 = v13;
      if ( !v13 )
        break;
      if ( v12 == 99 )
        v11 = v2 & 1;
      else
        v11 = 0;
      if ( v11 )
      {
        *(_DWORD *)(dword_7DBB0 + 20) = v7;
      }
      else if ( v12 == 111 )
      {
        v14 = *(const char **)dword_7D640;
        if ( *(_DWORD *)dword_7D640 )
        {
          do
          {
            if ( !strcmp(v14, off_6371C[v11] + 1) )
            {
              *(_BYTE *)(dword_7DBB0 + v11 + 61) = v8;
              goto LABEL_24;
            }
            ++v11;
          }
          while ( v11 != 15 );
          if ( v8 )
            v15 = 45;
          else
            v15 = 43;
          v2 = 1;
          sub_2B9AC("illegal option %co %s", v15, v14);
          return v2;
        }
        v24 = dword_7DBB0;
        do
        {
          v16 = (int)(off_6371C[(_DWORD)v14] + 1);
          if ( v8 )
          {
            v17 = "off";
            if ( v14[v24 + 61] )
              v17 = "on";
            v18 = "%-16s%s\n";
            v19 = v17;
          }
          else
          {
            v18 = "set %co %s\n";
            v19 = off_6371C[(_DWORD)v14] + 1;
            if ( v14[v24 + 61] )
              v16 = 45;
            else
              v16 = 43;
          }
          ++v14;
          sub_2BEA0(v18, v16, v19);
        }
        while ( v14 != (const char *)15 );
LABEL_24:
        if ( *(_DWORD *)dword_7D640 )
          dword_7D640 += 4;
      }
      else
      {
        if ( v12 == 108 )
          v20 = v2 & 1;
        else
          v20 = 0;
        if ( v20 )
        {
          if ( a2 )
            *a2 = 1;
        }
        else
        {
          if ( v12 == 45 )
            v21 = (unsigned __int8)v2 & (unsigned __int8)v8 & 1;
          else
            v21 = 0;
          if ( v21 )
          {
            v22 = strcmp(v7, "login") == 0;
            if ( !a2 )
              v22 = 0;
            if ( v22 )
              *a2 = 1;
            goto LABEL_3;
          }
          while ( v12 != (unsigned __int8)*off_6371C[v21] )
          {
            if ( ++v21 == 15 )
            {
              if ( v8 )
                v23 = 45;
              else
                v23 = 43;
              sub_2ABFC("illegal option %c%c", v23);
            }
          }
          *(_BYTE *)(dword_7DBB0 + v21 + 61) = v8;
        }
      }
    }
  }
  if ( v2 )
    return 0;
  *(_WORD *)(dword_7DBB0 + 68) = 0;
  return v2;
}
// 6371C: using guessed type char *off_6371C[13];
// 7D640: using guessed type int dword_7D640;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C1AC) --------------------------------------------------------
int sub_2C1AC()
{
  int v0; // r4
  const char *v1; // r5

  v0 = dword_7DBB0;
  v1 = *(const char **)(dword_7DBB0 + 24);
  if ( sub_2B6FC() )
  {
    if ( *(_DWORD *)(v0 + 28) == v0 + 60 )
      sub_2BDBC(v1, 0);
    v1 = *(const char **)(v0 + 28);
  }
  sub_2BEA0("%s\n", v1);
  return 0;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C204) --------------------------------------------------------
int sub_2C204()
{
  int v0; // r4
  unsigned int v1; // r5
  int v2; // r1

  v0 = 0;
  v1 = 0;
  sub_2BEA0("Built-in commands:\n------------------\n");
  v2 = 9;
  while ( 1 )
  {
    v1 += sub_2BEA0("%c%s", v2, (&off_635B4)[2 * v0] + 1);
    if ( v1 > 0x3C )
    {
      v1 = 0;
      sub_2BEA0("\n");
    }
    if ( ++v0 == 44 )
      break;
    if ( v1 )
      v2 = 32;
    else
      v2 = 9;
  }
  sub_2AAFC((FILE *)stdout);
  return 0;
}
// 635B4: using guessed type char *off_635B4;
// 7D614: using guessed type int stdout;

//----- (0002C294) --------------------------------------------------------
int __fastcall sub_2C294(int a1)
{
  int v1; // r1
  int v2; // r0

  v1 = stderr;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v2 = fputs_unlocked(a1, v1);
  ((void (__fastcall *)(int))loc_2A270)(v2);
  return sub_2A2A4();
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D608: using guessed type int stderr;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C2CC) --------------------------------------------------------
int sub_2C2CC()
{
  int v0; // r5
  int result; // r0

  v0 = dword_7DBB0;
  result = *(_DWORD *)(dword_7DBB0 + 4);
  if ( result || !dword_7D6AC )
    return 0;
  if ( *(_BYTE *)(dword_7D6AC + 24) == 1 )
  {
    sub_2C294((int)"You have stopped jobs.\n");
    result = 1;
    *(_DWORD *)(v0 + 4) = 2;
  }
  return result;
}
// 7D6AC: using guessed type int dword_7D6AC;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C32C) --------------------------------------------------------
int __fastcall sub_2C32C(int a1, int a2)
{
  unsigned __int8 *v3; // r0

  if ( !sub_2C2CC() )
  {
    v3 = *(unsigned __int8 **)(a2 + 4);
    if ( v3 )
      *(_BYTE *)dword_7DBB0 = sub_2AF8C(v3);
    sub_29EE0(4);
  }
  return 0;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C370) --------------------------------------------------------
void *__fastcall sub_2C370(size_t a1)
{
  void *v2; // r0

  v2 = (void *)sub_2B208(a1);
  return memset(v2, 0, a1);
}

//----- (0002C38C) --------------------------------------------------------
_DWORD *sub_2C38C()
{
  _DWORD *result; // r0

  result = sub_2C370(0x10u);
  *result = 15;
  result[2] = dword_7D738;
  result[3] = dword_7D648;
  return result;
}
// 7D648: using guessed type int dword_7D648;
// 7D738: using guessed type int dword_7D738;

//----- (0002C3C4) --------------------------------------------------------
void *__fastcall sub_2C3C4(const char *a1)
{
  _DWORD *v2; // r4
  void *result; // r0

  v2 = sub_2C370(8u);
  result = sub_2B310(a1);
  v2[1] = result;
  *(_DWORD *)dword_7D6C0 = v2;
  dword_7D6C0 = (int)v2;
  return result;
}
// 7D6C0: using guessed type int dword_7D6C0;

//----- (0002C3FC) --------------------------------------------------------
void *__fastcall sub_2C3FC(const void *a1)
{
  return bsearch(a1, &off_635B4, 0x2Cu, 8u, (__compar_fn_t)compar);
}
// 635B4: using guessed type char *off_635B4;

//----- (0002C428) --------------------------------------------------------
void *__fastcall sub_2C428(const void *a1)
{
  return bsearch(a1, &off_6378C, 0x11u, 4u, (__compar_fn_t)sub_29E14);
}
// 6378C: using guessed type _UNKNOWN *off_6378C;

//----- (0002C454) --------------------------------------------------------
int sub_2C454(char *a1, size_t a2, const char *a3, ...)
{
  int v3; // r4
  int v4; // r1
  va_list varg_r3; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r3, a3);
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v3 = vsnprintf(a1, a2, a3, varg_r3);
  ((void (__fastcall *)(int, int))loc_2A270)(v3, v4);
  return v3;
}
// 2C484: variable 'v4' is possibly undefined
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C4A0) --------------------------------------------------------
int __fastcall sub_2C4A0(char *a1, __int16 a2, int a3)
{
  int v3; // r4
  char v5; // r5
  const char *v6; // r0
  int v7; // r0
  bool v9; // zf
  const char *v10; // r2

  v3 = a2 & 0x7F;
  if ( (a2 & 0x7F) != 0 )
  {
    if ( (unsigned __int8)a2 == 127 )
    {
      LOBYTE(v3) = HIBYTE(a2);
      if ( !a3 )
      {
LABEL_4:
        v5 = a2;
        v6 = (const char *)strsignal(v3 & 0x7F);
        v7 = sub_2C454(a1, 0x20u, v6);
        v3 = v7;
        if ( v5 < 0 )
        {
          v3 = v7 + 14;
          strcpy(&a1[v7], " (core dumped)");
        }
        return v3;
      }
    }
    else
    {
      if ( !a3 )
        goto LABEL_4;
      v9 = v3 == 13;
      if ( v3 != 13 )
        v9 = v3 == 2;
      if ( !v9 )
        goto LABEL_4;
    }
    return 0;
  }
  if ( a3 )
    return v3;
  v10 = "Done(%d)";
  if ( !HIBYTE(a2) )
    v10 = "Done";
  return sub_2C454(a1, 0x10u, v10);
}
// 13894: using guessed type int __fastcall strsignal(_DWORD);

//----- (0002C558) --------------------------------------------------------
__pid_t __fastcall sub_2C558(int a1, int a2)
{
  int v3; // r5
  int v4; // r3
  int v5; // r2
  __pid_t v6; // r7
  int v7; // r4
  _BOOL4 v8; // r6
  _BOOL4 v9; // r4
  int v10; // r0
  _BYTE *v11; // r0
  int v13; // r2
  int v14; // r1
  int i; // r3
  _DWORD *v16; // r2
  int v17; // lr
  _DWORD *v18; // r0
  int v19; // r12
  bool v20; // zf
  int stat_loc; // [sp+4h] [bp-88h] BYREF
  sigset_t set; // [sp+8h] [bp-84h] BYREF
  _BYTE v23[4]; // [sp+88h] [bp-4h] BYREF

  v3 = dword_7DBB0;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  if ( a1 == 2 )
  {
    while ( 1 )
    {
      v4 = dword_7D6B0;
      *(_DWORD *)(v3 + 48) = 0;
      v5 = v4 ? 3 : 1;
      v6 = waitpid(-1, &stat_loc, v5);
      if ( v6 )
        break;
      sigfillset(&set);
      sigprocmask(2, &set, &set);
      while ( !*(_DWORD *)(v3 + 48) && !*(_DWORD *)(v3 + 52) )
        sigsuspend(&set);
      sigprocmask(2, &set, 0);
      v7 = *(_DWORD *)(v3 + 48);
      if ( !v7 )
        goto LABEL_10;
    }
  }
  else
  {
    v13 = a1 ^ 1;
    if ( dword_7D6B0 )
      v13 |= 2u;
    v6 = waitpid(-1, &stat_loc, v13);
  }
  if ( v6 > 0 )
  {
    v14 = stat_loc;
    for ( i = dword_7D6AC; ; i = *(_DWORD *)(i + 28) )
    {
      if ( !i )
      {
        v7 = 0;
        if ( (unsigned __int8)v14 != 127 )
          --dword_7D6F8;
        goto LABEL_10;
      }
      if ( *(_BYTE *)(i + 24) != 2 )
      {
        v16 = *(_DWORD **)(i + 12);
        v17 = 2;
        v7 = 0;
        v18 = &v16[3 * *(_DWORD *)(i + 20)];
        do
        {
          if ( *v16 == v6 )
          {
            v16[1] = v14;
            v7 = i;
          }
          v19 = v16[1];
          v20 = v19 == -1;
          if ( v19 != -1 )
            v20 = v17 == 0;
          if ( v20 )
          {
            v17 = 0;
          }
          else if ( (unsigned __int8)v19 == 127 )
          {
            v17 = 1;
            *(_DWORD *)(i + 16) = v19;
          }
          v16 += 3;
        }
        while ( v18 > v16 );
        if ( v7 )
          break;
      }
    }
    if ( v17 )
    {
      *(_BYTE *)(v7 + 25) |= 0x10u;
      if ( *(unsigned __int8 *)(v7 + 24) != v17 )
      {
        *(_BYTE *)(v7 + 24) = v17;
        if ( v17 == 1 )
          sub_29708(v7, 0);
      }
    }
  }
  else
  {
    v7 = 0;
  }
LABEL_10:
  v8 = v7 == a2;
  ((void (*)(void))loc_2A270)();
  if ( v7 )
    v9 = v8;
  else
    v9 = 0;
  if ( v9 )
  {
    v10 = sub_2C4A0((char *)&set, stat_loc, 1);
    if ( v10 )
    {
      v11 = &v23[v10];
      *(v11 - 128) = 10;
      *(v11 - 127) = 0;
      sub_2C294((int)&set);
    }
  }
  return v6;
}
// 7D6AC: using guessed type int dword_7D6AC;
// 7D6B0: using guessed type int dword_7D6B0;
// 7D6F8: using guessed type int dword_7D6F8;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C790) --------------------------------------------------------
int sub_2C790()
{
  int v0; // r6
  int v1; // r7
  int j; // r0
  int v3; // r4
  unsigned __int8 *v4; // r0
  int v5; // r0
  int i; // r5
  int v7; // t1

  v0 = dword_7DBB0;
  sub_2B480((unsigned __int8 *)(dword_7DBB0 + 60));
  v1 = dword_7D640;
  if ( *(_DWORD *)dword_7D640 )
  {
    v3 = 127;
    do
    {
      v4 = *(unsigned __int8 **)v1;
      if ( **(_BYTE **)v1 == 37 )
      {
        i = sub_2B738((int)v4, 0);
LABEL_15:
        while ( !*(_BYTE *)(i + 24) )
        {
          sub_2C558(2, *(unsigned __int8 *)(i + 24));
          if ( *(_DWORD *)(v0 + 52) )
            return *(_DWORD *)(v0 + 52) + 128;
        }
        *(_BYTE *)(i + 25) |= 4u;
        v3 = sub_29780(i);
      }
      else
      {
        v5 = sub_2AF8C(v4);
        for ( i = dword_7D6AC; i; i = *(_DWORD *)(i + 28) )
        {
          if ( *(_DWORD *)(*(_DWORD *)(i + 12) + 12 * *(_DWORD *)(i + 20) - 12) == v5 )
            goto LABEL_15;
        }
      }
      v7 = *(_DWORD *)(v1 + 4);
      v1 += 4;
    }
    while ( v7 );
  }
  else
  {
    while ( 2 )
    {
      for ( j = dword_7D6AC; ; j = *(_DWORD *)(j + 28) )
      {
        if ( !j )
          return 0;
        if ( !*(_BYTE *)(j + 24) )
          break;
        *(_BYTE *)(j + 25) |= 4u;
      }
      sub_2C558(2, *(unsigned __int8 *)(j + 24));
      if ( !*(_DWORD *)(v0 + 52) )
        continue;
      break;
    }
    return *(_DWORD *)(v0 + 52) + 128;
  }
  return v3;
}
// 7D640: using guessed type int dword_7D640;
// 7D6AC: using guessed type int dword_7D6AC;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C8C0) --------------------------------------------------------
int __fastcall sub_2C8C0(int a1)
{
  int v2; // r6

  ++*(_DWORD *)(dword_7DBB0 + 40);
  while ( !*(_BYTE *)(a1 + 24) )
    sub_2C558(1, a1);
  ((void (*)(void))loc_2A270)();
  v2 = sub_29780(a1);
  if ( (*(_BYTE *)(a1 + 25) & 2) != 0 )
  {
    sub_2B1EC(dword_7D4D4, *(_DWORD *)(dword_7DBB0 + 8));
    if ( (*(_BYTE *)(a1 + 25) & 1) != 0 )
      raise(2);
  }
  if ( *(_BYTE *)(a1 + 24) == 2 )
    sub_2A9BC(a1);
  return v2;
}
// 7D4D4: using guessed type int dword_7D4D4;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002C964) --------------------------------------------------------
int __fastcall sub_2C964(int a1, char a2, int a3, int *a4)
{
  _DWORD *v6; // r5
  FILE *v7; // r8
  int result; // r0
  int v9; // r0
  int v10; // r7
  char v11; // r2
  int v12; // r6
  char *v13; // r0
  int v14; // r10
  char *v15; // r0
  _DWORD *v16; // r9
  int v17; // r0
  int v18; // r0
  char *v19; // r2
  bool v20; // zf
  int v21; // r1
  char v22[84]; // [sp+10h] [bp-54h] BYREF

  if ( (a2 & 8) != 0 )
    a4 = &stderr;
  if ( (a2 & 8) == 0 )
    a4 = &stdout;
  v6 = *(_DWORD **)(a1 + 12);
  v7 = (FILE *)*a4;
  if ( (a2 & 1) != 0 )
    return fprintf((FILE *)*a4, "%d\n", *v6);
  v9 = sub_2C454(v22, 0x10u, "[%d]   ", ((a1 - dword_7D6FC) >> 5) + 1);
  v10 = v9;
  if ( dword_7D6AC == a1 )
  {
    v11 = 43;
LABEL_13:
    v22[v9 - 3] = v11;
    goto LABEL_14;
  }
  if ( dword_7D6AC && *(_DWORD *)(dword_7D6AC + 28) == a1 )
  {
    v11 = 45;
    goto LABEL_13;
  }
LABEL_14:
  v12 = a2 & 2;
  v13 = &v22[v9];
  if ( v12 )
    v14 = v10 + sub_2C454(v13, 0x10u, "%d ", *v6);
  else
    v14 = v10;
  v15 = &v22[v14];
  v16 = &v6[3 * *(_DWORD *)(a1 + 20)];
  if ( *(_BYTE *)(a1 + 24) )
  {
    v21 = *(v16 - 2);
    if ( *(_BYTE *)(a1 + 24) == 1 )
      v21 = *(_DWORD *)(a1 + 16);
    v17 = v14 + sub_2C4A0(v15, v21, 0);
  }
  else
  {
    strcpy(v15, "Running");
    v17 = v14 + 7;
  }
  while ( 1 )
  {
    v18 = 33 - v17;
    v19 = "";
    v20 = *(_DWORD *)(a1 + 12) == (_DWORD)v6;
    v6 += 3;
    if ( !v20 )
      v19 = "| ";
    fprintf(v7, "%s%*c%s%s", v22, v18 & ~(v18 >> 31), 32, v19, *(v6 - 1));
    if ( v16 == v6 )
      break;
    v22[0] = 0;
    if ( v12 )
      v17 = sub_2C454(v22, 0x30u, "\n%*c%d ", v10, 32, *v6) - 1;
    else
      v17 = 33;
  }
  result = sub_2AAFC(v7);
  *(_BYTE *)(a1 + 25) &= ~0x10u;
  if ( *(_BYTE *)(a1 + 24) == 2 )
    return sub_2A9BC(a1);
  return result;
}
// 7D608: using guessed type int stderr;
// 7D614: using guessed type int stdout;
// 7D6AC: using guessed type int dword_7D6AC;
// 7D6FC: using guessed type int dword_7D6FC;

//----- (0002CB60) --------------------------------------------------------
__pid_t __fastcall sub_2CB60(char a1)
{
  __pid_t result; // r0
  int v3; // r2
  int *v4; // r3
  int i; // r4

  do
    result = sub_2C558(0, 0);
  while ( result > 0 );
  v4 = &dword_7D6AC;
  for ( i = dword_7D6AC; i; i = *(_DWORD *)(i + 28) )
  {
    if ( (a1 & 4) != 0 )
    {
      v4 = (int *)*(unsigned __int8 *)(i + 25);
      if ( ((unsigned __int8)v4 & 0x10) == 0 )
        continue;
    }
    result = sub_2C964(i, a1, v3, v4);
  }
  return result;
}
// 2CBAC: variable 'v3' is possibly undefined
// 2CBAC: variable 'v4' is possibly undefined
// 7D6AC: using guessed type int dword_7D6AC;

//----- (0002CBBC) --------------------------------------------------------
int sub_2CBBC()
{
  int v0; // r4
  int v1; // r0
  int *v2; // r5
  int v3; // r0
  int v4; // r2
  int *v5; // r3
  int v6; // t1

  v0 = 0;
  while ( 1 )
  {
    v1 = sub_2B480((unsigned __int8 *)"lp");
    if ( !v1 )
      break;
    if ( v1 == 108 )
      v0 |= 2u;
    else
      v0 |= 1u;
  }
  v2 = (int *)dword_7D640;
  if ( *(_DWORD *)dword_7D640 )
  {
    do
    {
      v3 = sub_2B738(*v2, 0);
      sub_2C964(v3, v0, v4, v5);
      v6 = v2[1];
      ++v2;
    }
    while ( v6 );
  }
  else
  {
    sub_2CB60(v0);
  }
  return 0;
}
// 2CBFC: variable 'v4' is possibly undefined
// 2CBFC: variable 'v5' is possibly undefined
// 7D640: using guessed type int dword_7D640;

//----- (0002CC38) --------------------------------------------------------
int sub_2CC38()
{
  int v0; // r6
  __mode_t v1; // r4
  __mode_t v2; // r0
  const char *v3; // r5
  int v4; // r2
  char *v5; // r3
  char v6; // r1
  char *v7; // r1
  bool v8; // zf
  __mode_t v11; // r0
  char v12; // [sp+4h] [bp-18h] BYREF
  char s[23]; // [sp+5h] [bp-17h] BYREF

  v0 = 0;
  while ( sub_2B480((unsigned __int8 *)"S") )
    v0 = 1;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v1 = umask(0);
  v2 = umask(v1);
  ((void (__fastcall *)(__mode_t))loc_2A270)(v2);
  v3 = *(const char **)dword_7D640;
  if ( *(_DWORD *)dword_7D640 )
  {
    if ( (unsigned int)*(unsigned __int8 *)v3 - 48 > 9 )
      v1 ^= 0x1FFu;
    v11 = sub_5E0F4(*(const char **)dword_7D640, v1);
    if ( v11 >= 0x200 )
      sub_2ABFC("illegal mode: %s", v3);
    if ( (unsigned int)*(unsigned __int8 *)v3 - 48 > 9 )
      v11 ^= 0x1FFu;
    umask(v11);
  }
  else if ( v0 )
  {
    v4 = 2;
    v5 = &v12;
    do
    {
      v6 = aOgutmout[v4];
      if ( (v1 & 0x100) == 0 )
        v5[3] = 114;
      *v5 = 44;
      v5[1] = v6;
      v7 = v5 + 3;
      if ( (v1 & 0x100) == 0 )
        v7 = v5 + 4;
      v5[2] = 61;
      if ( (v1 & 0x80) != 0 )
      {
        v5 = v7;
      }
      else
      {
        v5 = v7 + 1;
        *v7 = 119;
      }
      v8 = (v1 & 0x40) == 0;
      LOWORD(v1) = 8 * v1;
      if ( v8 )
        *v5++ = 120;
    }
    while ( v4-- != 0 );
    *v5 = 0;
    puts(s);
  }
  else
  {
    sub_2BEA0("%04o\n", v1);
  }
  return 0;
}
// 7D640: using guessed type int dword_7D640;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002CDA4) --------------------------------------------------------
unsigned __int8 *__fastcall sub_2CDA4(unsigned __int8 *a1, char *name, int a3, char *pattern, int a5, int a6)
{
  char *v8; // r5
  const char *v10; // r1
  int v11; // r6
  int v12; // t1
  int v13; // r0

  v8 = name;
  while ( 1 )
  {
    v10 = v8;
    v12 = (unsigned __int8)*v8++;
    v11 = v12;
    if ( a6 )
    {
      v10 = name;
      *(v8 - 1) = 0;
    }
    v13 = fnmatch(pattern, v10, 0);
    *(v8 - 1) = v11;
    if ( !v13 )
      break;
    if ( a5 && *a1 == 129 )
      ++a1;
    ++a1;
    if ( !v11 )
      return 0;
  }
  return a1;
}

//----- (0002CE20) --------------------------------------------------------
char *__fastcall sub_2CE20(unsigned int a1, char *name, char *a3, char *pattern, int a5, int a6)
{
  char *v6; // r4
  char *v8; // r9
  char *i; // r5
  char v13; // r10
  int v14; // r0
  char *v15; // r3
  unsigned int v16; // r2
  char *v17; // t1

  v6 = 0;
  v8 = name;
  for ( i = pattern - 1; (unsigned int)i >= a1; i = v15 )
  {
    v13 = *a3;
    if ( a6 )
      *a3 = 0;
    else
      name = a3;
    if ( a6 )
      name = v8;
    v14 = fnmatch(pattern, name, 0);
    *a3-- = v13;
    if ( !v14 )
      return i;
    v15 = i - 1;
    if ( a5 )
    {
      if ( (int)--v6 < 0 )
      {
        v16 = (unsigned int)(i - 1);
        do
        {
          v6 = &v15[-v16];
          if ( a1 >= v16 )
            break;
          v17 = (char *)*(unsigned __int8 *)--v16;
          name = v17;
        }
        while ( v17 == (char *)129 );
      }
      if ( ((unsigned __int8)v6 & 1) != 0 )
      {
        --v6;
        v15 = i - 2;
      }
    }
  }
  return 0;
}
// 2CE74: variable 'name' is possibly undefined

//----- (0002CECC) --------------------------------------------------------
__int64 __fastcall sub_2CECC(unsigned __int8 *a1)
{
  unsigned __int64 v1; // r0
  __int64 v2; // r4
  const char *v4[5]; // [sp+0h] [bp-14h] BYREF

  v4[1] = (const char *)sub_2F2F4;
  v4[2] = (const char *)sub_2AF84;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v1 = sub_36E9C((int *)v4, a1);
  LODWORD(v2) = v1;
  if ( v4[0] )
    sub_2ABFC(v4[0], HIDWORD(v1));
  HIDWORD(v2) = HIDWORD(v1);
  ((void (*)(void))loc_2A270)();
  return v2;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002CF3C) --------------------------------------------------------
int __fastcall sub_2CF3C(unsigned __int8 *a1)
{
  __int64 v1; // r0

  v1 = sub_2CECC(a1);
  if ( v1 < (__int64)0xFFFFFFFF80000000LL )
    v1 = 0xFFFFFFFF80000000LL;
  if ( v1 > 0x7FFFFFFF )
    LODWORD(v1) = 0x7FFFFFFF;
  return v1;
}

//----- (0002CF74) --------------------------------------------------------
bool __fastcall sub_2CF74(int a1, int a2)
{
  int v2; // r4
  __int64 v3; // r0
  int v4; // t1

  if ( !*(_DWORD *)(a2 + 4) )
    sub_2ABFC("expression expected");
  v2 = a2 + 4;
  do
  {
    v3 = sub_2CECC((unsigned __int8 *)*(_DWORD *)v2);
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
  }
  while ( v4 );
  return v3 == 0;
}

//----- (0002CFB8) --------------------------------------------------------
int __fastcall sub_2CFB8(int a1)
{
  int v2; // r5
  int v3; // r1
  int i; // r4
  int v5; // r10
  char *v6; // r0
  char *v7; // r12
  char *v8; // r2
  int v9; // r3
  int v10; // r3
  int v11; // r2
  char v12; // r3
  int v14; // r1
  int v15; // r1

  v2 = dword_7D6FC;
  v3 = dword_7D718;
  for ( i = dword_7D6FC; --v3 >= 0; i += 32 )
  {
    if ( (*(_BYTE *)(i + 25) & 8) == 0 )
      goto LABEL_6;
    if ( (*(_WORD *)(i + 24) & 0x4FF) == 0x402 && !dword_7D6B0 )
    {
      sub_2A9BC(i);
      goto LABEL_6;
    }
  }
  v5 = 32 * dword_7D718;
  v6 = (char *)sub_174B4((void *)dword_7D6FC, 32 * dword_7D718 + 128);
  v7 = &v6[-v2];
  i = (int)&v6[v5];
  if ( v6 != (char *)v2 )
  {
    v8 = &v6[v5];
    v9 = v5;
    while ( v9 )
    {
      v14 = *((_DWORD *)v8 - 5);
      v9 -= 32;
      v8 -= 32;
      if ( v14 == v2 + v9 )
        *((_DWORD *)v8 + 3) = &v7[v14];
      v15 = *((_DWORD *)v8 + 7);
      if ( v15 )
        *((_DWORD *)v8 + 7) = &v7[v15];
    }
    if ( dword_7D6AC )
      dword_7D6AC += (int)v7;
  }
  dword_7D6FC = (int)v6;
  dword_7D718 += 4;
  *(_BYTE *)(i + 121) &= ~8u;
  *(_BYTE *)(i + 89) &= ~8u;
  *(_BYTE *)(i + 57) &= ~8u;
  *(_BYTE *)(i + 25) &= ~8u;
LABEL_6:
  memset((void *)i, 0, 0x20u);
  v10 = dword_7D6B0;
  *(_DWORD *)(i + 12) = i;
  if ( v10 )
    *(_BYTE *)(i + 25) |= 2u;
  v11 = dword_7D6AC;
  dword_7D6AC = i;
  v12 = *(_BYTE *)(i + 25);
  *(_DWORD *)(i + 28) = v11;
  *(_BYTE *)(i + 25) = v12 | 8;
  if ( a1 > 1 )
    *(_DWORD *)(i + 12) = sub_1748C(12 * a1);
  return i;
}
// 7D6AC: using guessed type int dword_7D6AC;
// 7D6B0: using guessed type int dword_7D6B0;
// 7D6FC: using guessed type int dword_7D6FC;
// 7D718: using guessed type int dword_7D718;

//----- (0002D148) --------------------------------------------------------
char *sub_2D148()
{
  int v0; // r2
  int v2; // r5
  size_t v3; // r6
  unsigned int v4; // r4
  int v5; // r2
  const void *v6; // r7
  _DWORD *v7; // r5
  int v8; // r6
  _DWORD *v9; // r0
  char *result; // r0
  void *v11; // r0
  int v12; // r3
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_16; // [sp+10h] [bp+10h]

  v2 = dword_7DBB8;
  v3 = *(_DWORD *)(dword_7DBB8 + 12);
  v4 = 2 * v3;
  if ( v3 > 2 * v3 )
    sub_2ABFC("out of memory");
  v5 = *(_DWORD *)dword_7DBB8;
  v6 = *(const void **)(dword_7DBB8 + 4);
  if ( v4 <= 0x7F )
    v4 += 128;
  if ( v6 != (const void *)(v5 + 4) || v5 == dword_7DBB8 + 16 )
  {
    v11 = (void *)sub_2B208(v4);
    result = (char *)memcpy(v11, v6, v3);
    v12 = *(_DWORD *)(v2 + 12);
    *(_DWORD *)(v2 + 4) = result;
    *(_DWORD *)(v2 + 12) = v12 + v4;
  }
  else
  {
    ++*(_DWORD *)(dword_7DBB0 + 40);
    v7 = (_DWORD *)dword_7DBB8;
    v8 = **(_DWORD **)dword_7DBB8;
    v9 = sub_174B4(*(void **)dword_7DBB8, v4 + 4);
    *v9 = v8;
    *v7 = v9++;
    v7[1] = v9;
    result = (char *)v9 + v4;
    v7[3] = v4;
    v7[2] = result;
    v0 = dword_7DBB0;
    if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
    {
      if ( *(_DWORD *)(v0 + 44) )
      {
        savedregs_16 = savedregs;
        sub_2A17C();
      }
    }
  }
  return result;
}
// 2A298: variable 'savedregs' is possibly undefined
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002D210) --------------------------------------------------------
int __fastcall sub_2D210(unsigned int a1, int a2)
{
  int v3; // r5
  int v4; // r4

  v3 = dword_7DBB8;
  v4 = a2 - *(_DWORD *)(dword_7DBB8 + 4);
  while ( *(_DWORD *)(v3 + 12) - v4 < a1 )
    sub_2D148();
  return *(_DWORD *)(v3 + 4) + v4;
}
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002D250) --------------------------------------------------------
int __fastcall sub_2D250(const char *a1)
{
  int v2; // r8
  _BYTE *v3; // r4
  int v4; // r0
  size_t v5; // r6
  const char *v6; // r7
  _BYTE *v7; // r0
  _BYTE *v8; // r0
  int i; // r6
  int v10; // t1
  int v11; // r7
  _BYTE *v12; // r0
  _BYTE *v13; // r0

  v2 = dword_7DBB8;
  v3 = *(_BYTE **)(dword_7DBB8 + 4);
  do
  {
    v4 = strchrnul(a1, 39);
    v5 = v4 - (_DWORD)a1;
    v6 = (const char *)v4;
    v7 = (_BYTE *)sub_2D210(v4 - (_DWORD)a1 + 3, (int)v3);
    *v7 = 39;
    v8 = memcpy(v7 + 1, a1, v5);
    v8[v5] = 39;
    v3 = &v8[v5 + 1];
    if ( *v6 != 39 )
      break;
    a1 = v6;
    for ( i = 0; ; ++i )
    {
      v10 = *(unsigned __int8 *)++a1;
      v11 = i + 1;
      if ( v10 != 39 )
        break;
    }
    v12 = (_BYTE *)sub_2D210(i + 4, (int)v3);
    *v12 = 34;
    v13 = memcpy(v12 + 1, &a1[~i], i + 1);
    v13[v11] = 34;
    v3 = &v13[v11 + 1];
  }
  while ( *a1 );
  *v3 = 0;
  return *(_DWORD *)(v2 + 4);
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002D320) --------------------------------------------------------
int __fastcall sub_2D320(int a1)
{
  const char *v1; // r4
  const char *v2; // r0

  v1 = *(const char **)(a1 + 4);
  v2 = (const char *)sub_2D250(*(const char **)(a1 + 8));
  return sub_2BEA0("%s=%s\n", v1, v2);
}

//----- (0002D348) --------------------------------------------------------
int __fastcall sub_2D348(int a1, int a2)
{
  int v2; // r4
  _DWORD *i; // r5
  int v4; // r6
  char *v6; // r0
  int v7; // r0
  const char *v8; // r4
  int v9; // r7
  const char *v10; // t1
  const char *v11; // r8
  int *v12; // r0
  int v13; // r5
  char *v14; // r0
  int v15; // r3
  _DWORD *v16; // r5
  int *v17; // [sp+4h] [bp-8h]

  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 )
  {
    v9 = a2;
    v4 = 0;
    while ( 1 )
    {
      v10 = *(const char **)(v9 + 4);
      v9 += 4;
      v8 = v10;
      if ( !v10 )
        break;
      v6 = strchr(v8 + 1, 61);
      if ( v6 )
      {
        v11 = v6 + 1;
        *v6 = 0;
        v12 = sub_29CD0(v8);
        v13 = *v12;
        ++*(_DWORD *)(dword_7DBB0 + 40);
        if ( v13 )
        {
          if ( (*(_DWORD *)(v13 + 12) & 1) == 0 )
            free(*(void **)(v13 + 8));
          v14 = sub_174F8(v11);
          v15 = *(_DWORD *)(v13 + 12);
          *(_DWORD *)(v13 + 8) = v14;
          *(_DWORD *)(v13 + 12) = v15 & 0xFFFFFFFD;
        }
        else
        {
          v17 = v12;
          v16 = sub_174DC(0x10u);
          v16[1] = sub_174F8(v8);
          v14 = sub_174F8(v11);
          v16[2] = v14;
          *v17 = (int)v16;
        }
        ((void (__fastcall *)(char *))loc_2A270)(v14);
      }
      else
      {
        v7 = *sub_29CD0(v8);
        if ( v7 )
        {
          sub_2D320(v7);
        }
        else
        {
          v4 = 1;
          fprintf((FILE *)stderr, "%s: %s not found\n", "alias", v8);
        }
      }
    }
  }
  else
  {
    do
    {
      for ( i = *(_DWORD **)(dword_7D644 + v2); i; i = (_DWORD *)*i )
        sub_2D320((int)i);
      v2 += 4;
    }
    while ( v2 != 156 );
    return 0;
  }
  return v4;
}
// 7D608: using guessed type int stderr;
// 7D644: using guessed type int dword_7D644;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002D4B4) --------------------------------------------------------
const char *__fastcall sub_2D4B4(const char *a1)
{
  const char *v1; // r1
  unsigned int v2; // r3
  unsigned int v3; // t1
  bool v4; // cc
  unsigned int v5; // r3
  _BOOL4 v6; // r2

  v1 = a1 - 1;
  while ( 1 )
  {
    v3 = *(unsigned __int8 *)++v1;
    v2 = v3;
    if ( !v3 )
      break;
    if ( v2 - 43 <= 0x4F )
    {
      v4 = v2 > 0x60;
      if ( v2 != 96 )
        v4 = v2 - 59 > 4;
      v5 = v2 - 91;
      v6 = !v4;
      if ( !(v5 <= 1 ? v6 | 1 : v6) )
        continue;
    }
    return (const char *)sub_2D250(a1);
  }
  return a1;
}

//----- (0002D500) --------------------------------------------------------
int __fastcall sub_2D500(int result, unsigned int a2, int a3, char a4)
{
  int v5; // r11
  unsigned __int8 *v6; // r8
  unsigned int v8; // r0
  int v10; // r2
  _BYTE *v11; // r5
  unsigned __int8 *v12; // r6
  int v13; // r4
  int v14; // r9
  int v15; // t1
  int v16; // [sp+4h] [bp-8h]

  if ( a2 )
  {
    v5 = a4 & 0x11;
    v6 = (unsigned __int8 *)result;
    if ( (a4 & 0x11) != 0 )
      v8 = 2 * a2;
    else
      v8 = a2;
    result = sub_2D210(v8, dword_7D6C4);
    v10 = a4 & 2;
    v11 = (_BYTE *)result;
    v12 = &v6[a2];
    v13 = a4 & 1 | a3;
    while ( 1 )
    {
      v15 = *v6++;
      v14 = v15;
      if ( v15 )
      {
        if ( v5 )
        {
          v16 = v10;
          result = sub_29A14(v14, a3);
          v10 = v16;
          if ( result == 12 )
            goto LABEL_12;
          result = result == 2;
          if ( !v13 )
            result = 0;
          if ( result )
LABEL_12:
            *v11++ = -127;
        }
      }
      else if ( !v10 )
      {
        goto LABEL_15;
      }
      *v11++ = v14;
LABEL_15:
      if ( v6 == v12 )
      {
        dword_7D6C4 = (int)v11;
        return result;
      }
    }
  }
  return result;
}
// 7D6C4: using guessed type int dword_7D6C4;

//----- (0002D5C8) --------------------------------------------------------
char *__fastcall sub_2D5C8(const char *a1, int a2)
{
  size_t v4; // r4
  void *v5; // r0

  v4 = strlen(a1);
  v5 = (void *)sub_2D210(v4, a2);
  return (char *)memcpy(v5, a1, v4) + v4;
}

//----- (0002D5F8) --------------------------------------------------------
int __fastcall sub_2D5F8(__int64 a1)
{
  int result; // r0

  dword_7D6C4 = sub_2D210(0x18u, dword_7D6C4);
  result = sub_2C454((char *)dword_7D6C4, 0x18u, "%lld", a1);
  dword_7D6C4 += result;
  return result;
}
// 7D6C4: using guessed type int dword_7D6C4;

//----- (0002D644) --------------------------------------------------------
char *__fastcall sub_2D644(const char *a1, char a2, _DWORD *a3)
{
  const char *v4; // r1
  char *v5; // r4
  _DWORD *v6; // r5
  char *v7; // r0
  char *v8; // r8
  char *v9; // r2
  char *v10; // r7
  size_t v11; // r10
  size_t v12; // r0
  int v13; // r8
  char *v14; // r7
  int v15; // r1
  int v16; // r0
  int v17; // r3
  char *v19; // r0
  unsigned __int8 *v20; // r12
  int v21; // r8
  int v22; // r3
  int v23; // r3
  unsigned int v24; // r1
  unsigned int v25; // r3
  _BOOL4 v26; // r1
  bool v27; // cc
  unsigned int v28; // r3
  char v29; // r1

  v4 = (const char *)&unk_6828A;
  v5 = (char *)a1;
  v6 = a3;
  if ( !a3 )
    v4 = (const char *)&unk_6828B;
  v7 = strpbrk(a1, v4);
  v8 = v7;
  if ( v7 )
  {
    if ( (a2 & 1) != 0 )
    {
      v11 = v7 - v5;
      v12 = v7 - v5 + 1 + strlen(v7);
      if ( (a2 & 8) != 0 )
      {
        v13 = dword_7DBB8;
        v14 = &v5[-*(_DWORD *)(dword_7DBB8 + 4)];
        v5 = (char *)sub_2D210(v12, dword_7D6C4);
        v10 = &v14[*(_DWORD *)(v13 + 4)];
        v8 = &v10[v11];
      }
      else
      {
        if ( (a2 & 0x10) != 0 )
          v19 = (char *)sub_1748C(v12);
        else
          v19 = (char *)sub_2B208(v12);
        v10 = v5;
        v5 = v19;
      }
      if ( v11 )
      {
        memcpy(v5, v10, v11);
        v9 = &v5[v11];
      }
      else
      {
        v9 = v5;
      }
    }
    else
    {
      v9 = v7;
      v10 = v5;
    }
    v15 = a2 & 2;
    v16 = v15;
    while ( 1 )
    {
      v17 = (unsigned __int8)*v8;
      if ( !*v8 )
        break;
      v20 = (unsigned __int8 *)(v8 + 1);
      if ( v17 == 136 )
      {
        v21 = v16;
      }
      else
      {
        if ( v17 == 92 )
        {
          v22 = 0;
        }
        else if ( v17 == 129 )
        {
          v23 = (unsigned __int8)v8[1];
          if ( !v15 )
            goto LABEL_33;
          v24 = v23 - 91;
          v25 = (unsigned __int8)(v23 - 33);
          v26 = v24 <= 3;
          v27 = v25 > 0x1E;
          if ( v25 > 0x1E )
            v28 = 1;
          else
            v28 = ~(0x40001201u >> v25);
          if ( !v27 )
            v28 &= 1u;
          if ( v26 | v28 ^ 1 )
          {
            *v9 = 92;
            v22 = v16;
            ++v9;
          }
          else
          {
LABEL_33:
            v22 = v16;
          }
          ++v8;
        }
        else if ( v6 && v8 == &v10[*v6] )
        {
          v16 = 0;
          *v6 = v9 - v5;
          v22 = 0;
          v6 = 0;
        }
        else
        {
          v22 = v16;
        }
        v29 = *v8;
        v20 = (unsigned __int8 *)(v8 + 1);
        ++v9;
        v21 = v16;
        v16 = v22;
        *(v9 - 1) = v29;
      }
      v15 = v16;
      v16 = v21;
      v8 = (char *)v20;
    }
    *v9 = v17;
    if ( (a2 & 8) != 0 )
      dword_7D6C4 = (int)(v9 + 1);
  }
  return v5;
}
// 7D6C4: using guessed type int dword_7D6C4;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002D828) --------------------------------------------------------
_BYTE *__fastcall sub_2D828(const char *a1, int a2)
{
  const char *v2; // r4
  size_t v3; // r0
  _BYTE *result; // r0
  int v5; // r2
  int v6; // r1
  unsigned int v7; // r10
  unsigned __int8 *v8; // lr
  bool v9; // zf
  char *v10; // r3
  _BYTE *i; // r4
  char v12; // r0
  int v13; // t1
  int v14; // [sp+4h] [bp-4h] BYREF

  v14 = a2;
  v2 = a1;
  BYTE1(v14) = 0;
  v3 = strlen(a1);
  result = (_BYTE *)sub_2D210(8 * (v3 + 1), dword_7D6A0);
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    v7 = *(unsigned __int8 *)v2;
    v8 = (unsigned __int8 *)(v2 + 1);
    if ( !*v2 )
      break;
    if ( v7 == 129 )
    {
      v8 = (unsigned __int8 *)(v2 + 2);
      LOBYTE(v7) = v2[1];
    }
    else if ( v7 > 0x81 )
    {
      if ( v7 == 132 )
      {
        v10 = "$(...)";
        goto LABEL_28;
      }
      if ( v7 <= 0x84 )
      {
        if ( v7 == 130 )
        {
          v6 = *((unsigned __int8 *)v2 + 1);
          v8 = (unsigned __int8 *)(v2 + 2);
          if ( (v6 & 0xF) == 0xA )
            v10 = "${#";
          else
            v10 = "${";
        }
        else
        {
          v6 = 0;
          if ( (v5 & 1) != 0 )
            v10 = "\"}";
          else
            v10 = "}";
          v5 >>= 1;
        }
        goto LABEL_28;
      }
      switch ( v7 )
      {
        case 0x87u:
          v10 = "))";
          goto LABEL_28;
        case 0x88u:
          v5 ^= 1u;
          LOBYTE(v7) = 34;
          break;
        case 0x86u:
          v10 = "$((";
          goto LABEL_28;
      }
    }
    else
    {
      if ( v7 == 39 )
        goto LABEL_40;
      if ( v7 > 0x27 )
      {
        if ( v7 == 61 )
        {
          if ( v6 )
          {
            if ( (v6 & 0xF) != 1 )
              v5 *= 2;
            v10 = (char *)&unk_68703 + 3 * (v6 & 0xF);
            if ( (v6 & 0x10) == 0 )
              goto LABEL_28;
            LOBYTE(v7) = 58;
            goto LABEL_41;
          }
          goto LABEL_13;
        }
        v9 = v7 == 92;
      }
      else
      {
        if ( v7 == 34 )
          goto LABEL_40;
        v9 = v7 == 36;
      }
      if ( v9 )
      {
LABEL_40:
        LOBYTE(v14) = *v2;
        v10 = (char *)&v14;
        LOBYTE(v7) = 92;
        goto LABEL_41;
      }
    }
LABEL_13:
    v10 = 0;
LABEL_41:
    i = result + 1;
    *result = v7;
    if ( !v10 )
      goto LABEL_43;
    ++result;
LABEL_28:
    for ( i = result; ; ++i )
    {
      v13 = (unsigned __int8)*v10++;
      v12 = v13;
      if ( !v13 )
        break;
      *i = v12;
    }
LABEL_43:
    result = i;
    v2 = (const char *)v8;
  }
  if ( (v5 & 1) != 0 )
    *result++ = 34;
  dword_7D6A0 = (int)result;
  *result = 0;
  return result;
}
// 2D8FC: conditional instruction was optimized away because r10.4==83
// 7D6A0: using guessed type int dword_7D6A0;

//----- (0002DA0C) --------------------------------------------------------
int sub_2DA0C()
{
  int v0; // r4
  int v1; // r5

  v0 = dword_7DBB8;
  v1 = *(_DWORD *)(dword_7DBB8 + 12);
  sub_2D148();
  return *(_DWORD *)(v0 + 4) + v1;
}
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002DA30) --------------------------------------------------------
_BYTE *__fastcall sub_2DA30(char a1, _BYTE *a2)
{
  _BYTE *v3; // r0

  if ( *(_BYTE **)(dword_7DBB8 + 8) == a2 )
    v3 = (_BYTE *)sub_2DA0C();
  else
    v3 = a2;
  *v3 = a1;
  return v3 + 1;
}
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002DA60) --------------------------------------------------------
int __fastcall sub_2DA60(int a1, int a2, _DWORD *a3)
{
  int v5; // r9
  int v6; // r5
  _DWORD *v7; // r0
  _DWORD *v8; // r8
  unsigned int v9; // r10
  _DWORD *i; // r4
  _DWORD *v11; // t1
  _DWORD *v12; // r2

  v5 = a1 | a2;
  v6 = dword_7DBB8;
  v7 = *(_DWORD **)(dword_7DBB8 + 4);
  v8 = (_DWORD *)(dword_7DBB4 + 28);
  v9 = dword_7DBB4 + 184;
  do
  {
    v11 = (_DWORD *)*v8++;
    for ( i = v11; ; i = (_DWORD *)*i )
    {
      v12 = *(_DWORD **)(v6 + 8);
      if ( !i )
        break;
      if ( (i[1] & v5) == a1 )
      {
        if ( v7 == v12 )
          v7 = (_DWORD *)sub_2DA0C();
        *v7++ = i[2];
      }
    }
  }
  while ( v9 > (unsigned int)v8 );
  if ( v7 == v12 )
    v7 = (_DWORD *)sub_2DA0C();
  if ( a3 )
    *a3 = v7;
  *v7 = 0;
  return sub_2B208((int)v7 - *(_DWORD *)(v6 + 4) + 4);
}
// 7DBB4: using guessed type int dword_7DBB4;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002DB08) --------------------------------------------------------
int __fastcall sub_2DB08(const void **a1, char *s)
{
  unsigned __int8 *v2; // r5
  unsigned __int8 *i; // r6
  unsigned __int8 *v5; // r8
  int v6; // r2
  unsigned __int8 *v7; // r4
  bool v8; // r3
  int v12; // r11
  unsigned int v13; // r9
  int j; // r3
  char *v15; // r0
  _BYTE *v16; // r2
  int v17; // r3
  int v18; // t1
  bool v19; // zf
  const void *v20; // r3
  bool v21; // zf
  int v22; // [sp+4h] [bp-8h]

  v2 = (unsigned __int8 *)*a1;
  if ( !*a1 )
    return 0;
  for ( i = (unsigned __int8 *)*a1; ; ++i )
  {
    v5 = i;
    v7 = i + 1;
    v6 = *i;
    v8 = v6 != 58;
    if ( !*i )
      v8 = 0;
    if ( v6 == 37 || !v8 )
      break;
  }
  v12 = i - v2;
  v13 = strlen(s) + 2 + i - v2;
  for ( j = dword_7DBB8; *(_DWORD *)(j + 12) < v13; j = v22 )
  {
    v22 = j;
    sub_2D148();
  }
  v15 = *(char **)(j + 4);
  if ( v2 != i )
  {
    v16 = memcpy(v15, v2, i - v2);
    v15 = &v16[v12 + 1];
    v16[v12] = 47;
  }
  strcpy(v15, s);
  dword_7D724 = 0;
  if ( *i == 37 )
  {
    dword_7D724 = (int)(i + 1);
    do
    {
      v5 = v7;
      v18 = *v7++;
      v17 = v18;
      v19 = v18 == 0;
      if ( v18 )
        v19 = v17 == 58;
    }
    while ( !v19 );
  }
  v20 = (const void *)*v5;
  v21 = v20 == (const void *)58;
  if ( v20 == (const void *)58 )
    ++v5;
  else
    v20 = 0;
  if ( v21 )
    *a1 = v5;
  else
    *a1 = v20;
  return sub_2B208(v13);
}
// 7D724: using guessed type int dword_7D724;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002DC30) --------------------------------------------------------
__sighandler_t __fastcall sub_2DC30(int a1, _DWORD *a2, int a3)
{
  int v6; // r4
  int v7; // r9
  _BYTE *v8; // r0
  _BOOL4 v9; // r3
  int v10; // r10
  int v11; // r10
  int v12; // r11
  _BYTE **v13; // r5
  __sighandler_t result; // r0
  __pid_t v15; // r5
  int v16; // r4
  int v17; // r3
  unsigned int v18; // [sp+4h] [bp-8h]

  v6 = dword_7DBB0;
  v7 = *(_DWORD *)(dword_7DBB0 + 12);
  *(_DWORD *)(dword_7DBB0 + 12) = v7 + 1;
  while ( off_7D4D0 != &unk_7D64C )
    sub_2A5FC();
  v8 = (_BYTE *)dword_7D654;
  if ( dword_7D654 > 0 )
  {
    v8 = (_BYTE *)close(dword_7D654);
    *((_DWORD *)off_7D4D0 + 2) = 0;
  }
  v9 = a3 == 2;
  if ( !a2 )
    v9 = 0;
  if ( v9 && !*a2 )
  {
    v10 = a2[3];
    if ( v10 )
    {
      v8 = (_BYTE *)strcmp(*(const char **)(v10 + 8), "trap");
      if ( !v8 && !*(_DWORD *)(v10 + 4) )
      {
        v8 = sub_1756C((const void *)(v6 + 208), 0x104u);
        *(_DWORD *)(v6 + 468) = v8;
      }
    }
  }
  ++*(_DWORD *)(v6 + 40);
  v11 = dword_7DBB0;
  v12 = dword_7DBB0 + 208;
  v13 = (_BYTE **)(dword_7DBB0 + 208);
  v18 = dword_7DBB0 + 468;
  while ( (unsigned int)v13 < v18 )
  {
    v8 = *v13;
    if ( *v13 && *v8 )
    {
      if ( v12 == *(_DWORD *)(v11 + 468) )
        free(v8);
      *v13 = 0;
      if ( v13 != (_BYTE **)v12 )
        v8 = (_BYTE *)sub_29F94(((int)v13 - v12) >> 2);
    }
    ++v13;
  }
  *(_BYTE *)(v11 + 204) = 0;
  result = (__sighandler_t)((int (__fastcall *)(_BYTE *))loc_2A270)(v8);
  dword_7D6B0 = 0;
  if ( a3 == 2 )
  {
LABEL_39:
    if ( v7 )
      goto LABEL_40;
    goto LABEL_24;
  }
  if ( (*(_BYTE *)(a1 + 25) & 2) == 0 )
  {
    if ( a3 != 1 )
      goto LABEL_39;
    goto LABEL_36;
  }
  if ( v7 )
  {
    if ( a3 != 1 )
      goto LABEL_40;
LABEL_36:
    sub_2A140((__sighandler_t)2);
    result = sub_2A140((__sighandler_t)3);
    if ( !*(_DWORD *)(a1 + 20) )
    {
      close(0);
      result = (__sighandler_t)open64("/dev/null", 0);
      if ( result )
        sub_2ABFC("can't open '%s': %m", "/dev/null");
    }
    goto LABEL_39;
  }
  if ( *(_DWORD *)(a1 + 20) )
    v15 = **(_DWORD **)(a1 + 12);
  else
    v15 = getpid();
  setpgid(0, v15);
  if ( !a3 )
    sub_2B1EC(dword_7D4D4, v15);
  sub_29F94(20);
  sub_29F94(22);
LABEL_24:
  if ( *(_BYTE *)(v6 + 64) )
  {
    sub_29F94(2);
    sub_29F94(15);
  }
  result = (__sighandler_t)sub_29F94(3);
LABEL_40:
  v16 = dword_7D6AC;
  if ( a2 )
  {
    if ( !*a2 )
    {
      v17 = a2[3];
      if ( v17 )
      {
        result = (__sighandler_t)strcmp(*(const char **)(v17 + 8), "jobs");
        if ( !result )
          return (__sighandler_t)sub_2A9BC(v16);
      }
    }
  }
  while ( v16 )
  {
    result = (__sighandler_t)sub_2A9BC(v16);
    v16 = *(_DWORD *)(v16 + 28);
  }
  dword_7D6F8 = 0;
  return result;
}
// 2DD1C: variable 'v8' is possibly undefined
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D4D4: using guessed type int dword_7D4D4;
// 7D654: using guessed type int dword_7D654;
// 7D6AC: using guessed type int dword_7D6AC;
// 7D6B0: using guessed type int dword_7D6B0;
// 7D6F8: using guessed type int dword_7D6F8;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002DF0C) --------------------------------------------------------
int __fastcall sub_2DF0C(char *path, char **argv, char **envp)
{
  int result; // r0

  while ( 1 )
  {
    result = execve(path, argv, envp);
    if ( path == "/proc/self/exe" || *(_DWORD *)dword_7DB94 != 8 )
      break;
    *argv = path;
    path = "/proc/self/exe";
    *--argv = "ash";
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (0002DF6C) --------------------------------------------------------
char *__fastcall sub_2DF6C(int a1, int a2)
{
  bool v2; // zf

  v2 = a1 == 20;
  if ( a1 != 20 )
    v2 = a1 == 2;
  if ( v2 )
    return (char *)a2;
  else
    return strerror(a1);
}

//----- (0002DF84) --------------------------------------------------------
int sub_2DF84()
{
  int v0; // r5
  int v1; // r1
  unsigned int i; // r4
  const char *v3; // r0
  const char *v4; // r7
  char *v5; // r0
  int v6; // r8
  char *v8; // r4
  char *v9; // r2
  int v10; // r5
  const char *v11; // r0
  const char *v12; // t1
  signed int v13; // r11
  int v14; // r7
  int v15; // r0

  v0 = dword_7DBB0;
  sub_2B480((unsigned __int8 *)(dword_7DBB0 + 60));
  v1 = dword_7D640;
  if ( *(_DWORD *)dword_7D640 )
  {
    v8 = *(char **)(dword_7D640 + 4);
    if ( v8 )
    {
      if ( sub_2960C(*(unsigned __int8 **)dword_7D640) )
      {
        v8 = 0;
      }
      else
      {
        v1 += 4;
        v8 = v9;
      }
    }
    v10 = v1 - 4;
    v6 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = *(const char **)(v10 + 4);
        v10 += 4;
        v11 = v12;
        if ( !v12 )
          return v6;
        v13 = sub_61000(v11);
        if ( v13 >= 0 )
          break;
        sub_2B9AC("%s: invalid signal specification", *(const char **)v10);
        v6 = 1;
      }
      ++*(_DWORD *)(dword_7DBB0 + 40);
      if ( v8 )
        break;
LABEL_23:
      v14 = dword_7DBB0 + 4 * v13;
      free(*(void **)(v14 + 208));
      *(_DWORD *)(v14 + 208) = v8;
      if ( v13 )
        v15 = sub_29F94(v13);
      ((void (__fastcall *)(int))loc_2A270)(v15);
    }
    if ( *v8 == 45 )
    {
      if ( !v8[1] )
      {
        v8 = (char *)(unsigned __int8)v8[1];
        goto LABEL_23;
      }
    }
    else if ( !*v8 )
    {
      goto LABEL_22;
    }
    *(_BYTE *)(dword_7DBB0 + 204) = 1;
LABEL_22:
    v8 = sub_174F8(v8);
    goto LABEL_23;
  }
  for ( i = 0; i != 65; ++i )
  {
    v3 = *(const char **)(*(_DWORD *)(v0 + 468) + 4 * i);
    if ( v3 )
    {
      v4 = (const char *)sub_2D250(v3);
      v5 = sub_61144(i);
      sub_2BEA0("trap -- %s %s\n", v4, v5);
    }
  }
  return 0;
}
// 2E014: variable 'v1' is possibly undefined
// 2E018: variable 'v9' is possibly undefined
// 2E0D4: variable 'v15' is possibly undefined
// 7D640: using guessed type int dword_7D640;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002E0EC) --------------------------------------------------------
int sub_2E0EC()
{
  unsigned __int8 *v0; // r4
  unsigned int v1; // r5
  unsigned int v2; // r6
  int v3; // r1
  unsigned int v4; // r11
  int v5; // r1
  int result; // r0
  int v7; // t1
  struct tms buffer; // [sp+8h] [bp-14h] BYREF

  v0 = (unsigned __int8 *)&unk_6869A;
  v1 = sub_60F80();
  times(&buffer);
  do
  {
    v2 = sub_15EFC(*(clock_t *)((char *)&buffer.tms_utime + *(v0 - 1)), v1);
    v4 = sub_15CA0(1000 * v3, v1);
    sub_15EFC(v2, 0x3Cu);
    sub_2BEA0("%um%u.%03us%c", v2 / 0x3C, v5, v4, *(v0 - 2));
    v7 = *v0;
    v0 += 2;
    result = v7;
  }
  while ( v7 );
  return result;
}
// 2E130: variable 'v3' is possibly undefined
// 2E168: variable 'v5' is possibly undefined

//----- (0002E18C) --------------------------------------------------------
int __fastcall sub_2E18C(const char *a1, int a2, int a3)
{
  unsigned __int8 **v4; // r4
  const char *v5; // r6
  unsigned __int8 *v7; // r5
  const char *v8; // r0
  unsigned __int8 *v9; // t1
  unsigned int v10; // [sp+Ch] [bp-8h] BYREF

  v4 = (unsigned __int8 **)sub_2DA60(a2, a3, &v10);
  v5 = " ";
  qsort(v4, (int)(v10 - (_DWORD)v4) >> 2, 4u, (__compar_fn_t)sub_296C0);
  if ( !*a1 )
    v5 = a1;
  while ( v10 > (unsigned int)v4 )
  {
    v7 = sub_5871C(*v4);
    v8 = (const char *)(dword_7DBB0 + 60);
    if ( *v7 == 61 )
      v8 = (const char *)sub_2D250((const char *)++v7);
    v9 = *v4++;
    sub_2BEA0("%s%s%.*s%s\n", a1, v5, v7 - v9, (const char *)v9, v8);
  }
  return 0;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002E254) --------------------------------------------------------
int __fastcall sub_2E254(int a1, int a2)
{
  int v3; // r4

  if ( !*(_DWORD *)(a2 + 4) )
    return sub_2E18C((const char *)(dword_7DBB0 + 60), 0, 32);
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v3 = sub_2BEEC(0, 0);
  if ( !v3 )
  {
    sub_2BB6C();
    if ( *(_DWORD *)dword_7D640 )
      sub_29F0C(dword_7D640);
  }
  ((void (*)(void))loc_2A270)();
  return v3;
}
// 7D640: using guessed type int dword_7D640;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002E2C8) --------------------------------------------------------
int __fastcall sub_2E2C8(int a1, const char **a2)
{
  int v3; // r6
  int v4; // r4
  char v5; // r0
  const char *v6; // r0
  bool v7; // zf
  int v8; // r5
  int v9; // r7
  char *v10; // r4
  char *v11; // r0
  const char *v12; // r9
  _DWORD *v13; // r0
  int v14; // r2
  char *v15; // t1

  v3 = (int)"np";
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_2B480("np");
    if ( !v5 )
      break;
    if ( v5 == 110 )
      v4 = 1;
  }
  v6 = *a2;
  v7 = **a2 == 114;
  if ( **a2 == 114 )
    v4 = 0;
  else
    v3 = 1;
  v8 = ~v4;
  if ( v7 )
    v3 = 2;
  v9 = dword_7D640;
  v10 = *(char **)dword_7D640;
  if ( *(_DWORD *)dword_7D640 )
  {
    while ( 1 )
    {
      v11 = strchr(v10, 61);
      v12 = v11;
      if ( v11 )
        break;
      v13 = (_DWORD *)sub_29678((unsigned __int8 *)v10);
      v14 = *sub_296CC(v13, (int)v10);
      if ( !v14 )
        goto LABEL_18;
      *(_DWORD *)(v14 + 4) = (v3 | *(_DWORD *)(v14 + 4)) & v8;
LABEL_13:
      v15 = *(char **)(v9 + 4);
      v9 += 4;
      v10 = v15;
      if ( !v15 )
        return 0;
    }
    v12 = v11 + 1;
LABEL_18:
    sub_2AE08((unsigned __int8 *)v10, v12, v3 & v8);
    goto LABEL_13;
  }
  sub_2E18C(v6, v3, 0);
  return 0;
}
// 7D640: using guessed type int dword_7D640;

//----- (0002E3B4) --------------------------------------------------------
int __fastcall sub_2E3B4(int a1, int a2, int a3, int a4)
{
  const char *v5; // r0
  int *v7; // r5
  int v8; // r7
  int v9; // r8
  int v10; // r6
  char *v11; // r4
  int v12; // t1
  int v14; // r0
  const char *v15; // r1
  int v16; // [sp+0h] [bp-24h] BYREF

  v16 = a4;
  v5 = *(const char **)(a2 + 4);
  if ( v5 && strcmp(v5, "-l") )
  {
    v7 = (int *)(a2 + 4);
    do
    {
      if ( *(_BYTE *)*v7 == 37 )
      {
        v8 = 0;
        v9 = sub_2B738(*v7, 0);
        v10 = *(_DWORD *)(v9 + 20);
        if ( (*(_BYTE *)(v9 + 25) & 2) != 0 )
          v10 = 1;
        v11 = (char *)&v16;
        *v7 = (int)&v16;
        while ( v8 < v10 )
        {
          v14 = *(_DWORD *)(v9 + 12);
          a3 = *(_DWORD *)(v14 + 12 * v8 + 4);
          if ( a3 == -1 || (a3 = (unsigned __int8)a3, (unsigned __int8)a3 == 127) )
          {
            v15 = " %u";
            if ( (*(_BYTE *)(v9 + 25) & 2) != 0 )
              v15 = " -%u";
            v11 += sprintf(v11, v15, *(_DWORD *)(v14 + 12 * v8));
          }
          ++v8;
        }
        *v11 = 0;
      }
      v12 = v7[1];
      ++v7;
    }
    while ( v12 );
  }
  return sub_273A8(a1, a2, a3);
}
// 2E450: variable 'a3' is possibly undefined

//----- (0002E4BC) --------------------------------------------------------
int sub_2E4BC()
{
  sub_5C3DC(dword_7D708);
  return 0;
}
// 7D708: using guessed type int dword_7D708;

//----- (0002E4E0) --------------------------------------------------------
DIR *__fastcall sub_2E4E0(int a1, const char *a2, int a3, int a4)
{
  const char *v5; // r6
  const char *v6; // r10
  const char *v7; // r8
  const char *v8; // r5
  DIR *result; // r0
  char *v10; // r6
  int v11; // r4
  char *v12; // r3
  bool v13; // zf
  unsigned __int8 *v14; // r1
  unsigned __int8 *v15; // r12
  int v16; // r4
  bool v17; // zf
  char *v18; // r3
  char *v19; // r1
  int v20; // r9
  char *v21; // r0
  DIR *v22; // r11
  int v23; // r10
  const char *v24; // r3
  int v25; // r4
  char v26; // r3
  _BYTE *v27; // r6
  int v28; // r6
  int v29; // r0
  _BOOL4 v30; // r1
  int v32; // [sp+0h] [bp-7Ch]
  int v33; // [sp+4h] [bp-78h]
  char *v34; // [sp+8h] [bp-74h]
  char *src; // [sp+Ch] [bp-70h]

  v5 = *(const char **)a1;
  v6 = a2;
  v7 = a2;
  v8 = a2;
  result = 0;
  v10 = (char *)&v5[a4];
  while ( 1 )
  {
    v11 = *(unsigned __int8 *)v8;
    if ( !*v8 )
      break;
    v13 = v11 == 63;
    if ( v11 != 63 )
      v13 = v11 == 42;
    if ( v13 )
    {
      v11 = 0;
LABEL_28:
      result = (DIR *)1;
    }
    else if ( v11 == 91 )
    {
      v14 = (unsigned __int8 *)(v8 + 1);
      if ( v8[1] == 33 )
        v14 = (unsigned __int8 *)(v8 + 2);
      while ( 1 )
      {
        if ( *v14 == 92 )
          v15 = v14 + 1;
        else
          v15 = v14;
        v16 = *v15;
        v17 = v16 == 0;
        if ( *v15 )
          v17 = v16 == 47;
        v11 = v17;
        if ( v17 )
          break;
        v14 = v15 + 1;
        if ( v15[1] == 93 )
          goto LABEL_28;
      }
      v11 = 0;
    }
    else
    {
      v11 = v11 == 92;
      if ( v8[v11] == 47 )
      {
        if ( result )
          goto LABEL_35;
        v7 = &v8[v11 + 1];
      }
    }
    v8 += v11 + 1;
  }
  if ( !result )
  {
    if ( a4 )
    {
      do
      {
        if ( *v6 == 92 )
          v12 = (char *)(v6 + 1);
        else
          v12 = (char *)v6;
        v6 = v12 + 1;
        *v10++ = *v12;
      }
      while ( *v12 );
      result = (DIR *)sub_62E14();
      if ( !result )
        return (DIR *)sub_2C3C4(*(const char **)a1);
    }
    return result;
  }
LABEL_35:
  if ( v7 > v6 )
  {
    v18 = (char *)v6;
    do
    {
      if ( *v18 == 92 )
        v19 = v18 + 1;
      else
        v19 = v18;
      v18 = v19 + 1;
      *v10++ = *v19;
    }
    while ( v7 > v19 + 1 );
  }
  v20 = 0;
  *v10 = 0;
  v21 = ".";
  if ( v10 != *(char **)a1 )
    v21 = *(char **)a1;
  v34 = &v10[-*(_DWORD *)a1];
  result = opendir(v21);
  v22 = result;
  if ( result )
  {
    if ( *v8 )
    {
      *v8 = 0;
      v8 += v11 + 1;
    }
    else
    {
      v20 = 1;
    }
    v23 = a3 - (v8 - v6);
    v24 = *v7 == 92 ? v7 + 1 : v7;
    v32 = *(unsigned __int8 *)v24;
    v33 = dword_7DBB0;
    while ( !*(_DWORD *)(v33 + 44) )
    {
      v29 = readdir64(v22);
      if ( !v29 )
        break;
      v30 = *(unsigned __int8 *)(v29 + 19) == 46;
      if ( v32 == 46 )
        v30 = 0;
      if ( !v30 )
      {
        src = (char *)(v29 + 19);
        if ( !fnmatch(v7, (const char *)(v29 + 19), 0) )
        {
          if ( v20 )
          {
            strcpy(v10, src);
            sub_2C3C4(*(const char **)a1);
          }
          else
          {
            v27 = (_BYTE *)stpcpy(v10, src);
            *v27 = 47;
            v28 = (int)&v27[-*(_DWORD *)a1 + 1];
            if ( *(_DWORD *)(a1 + 4) < (unsigned int)(v23 + v28 + 255) )
            {
              *(_DWORD *)a1 = sub_174B4(*(void **)a1, v23 + v28 + 4351);
              *(_DWORD *)(a1 + 4) = v23 + v28 + 4351;
            }
            sub_2E4E0(a1, v8, v23, v28);
            v10 = &v34[*(_DWORD *)a1];
          }
        }
      }
    }
    result = (DIR *)closedir(v22);
    if ( !v20 )
    {
      v13 = v11 == 0;
      v25 = ~v11;
      if ( v13 )
        v26 = 47;
      else
        v26 = 92;
      v8[v25] = v26;
    }
  }
  return result;
}
// 1372C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002E7E4) --------------------------------------------------------
void __fastcall __noreturn sub_2E7E4(int a1)
{
  const char *v2; // r2
  int v3; // r0
  char *v4; // r5
  const char *v5; // r2
  char v6[16]; // [sp+0h] [bp-54h] BYREF
  char s[68]; // [sp+10h] [bp-44h] BYREF

  v2 = (const char *)*(&off_63758 + dword_7D704);
  if ( dword_7D704 > 3 )
  {
    sprintf(v6, "\"%s\"", v2);
    v2 = v6;
  }
  v3 = sprintf(s, "unexpected %s", v2);
  if ( a1 != -1 )
  {
    v4 = &s[v3];
    v5 = (const char *)*(&off_63758 + a1);
    if ( a1 > 3 )
    {
      sprintf(v6, "\"%s\"", v5);
      v5 = v6;
    }
    sprintf(v4, " (expecting %s)", v5);
  }
  sub_2B44C(s);
}
// 63758: using guessed type _UNKNOWN *off_63758;
// 7D704: using guessed type int dword_7D704;

//----- (0002E87C) --------------------------------------------------------
size_t __fastcall sub_2E87C(int a1, int a2)
{
  int v4; // r0
  int v5; // r1
  int v6; // r0
  _DWORD *v7; // r4
  int v9; // r0
  int v10; // r1
  int v11; // r0
  size_t v12; // r0
  int v13; // r6
  _DWORD *v14; // r6
  int v15; // r0

  while ( 2 )
  {
    if ( a2 )
    {
      a1 += byte_681B5[*(_DWORD *)a2];
      switch ( *(_DWORD *)a2 )
      {
        case 0:
          v4 = sub_2E87C(a1, *(_DWORD *)(a2 + 16));
          v5 = *(_DWORD *)(a2 + 12);
          goto LABEL_4;
        case 1:
          v7 = *(_DWORD **)(a2 + 8);
          while ( v7 )
          {
            v9 = sub_2E87C(a1 + 8, v7[1]);
            v7 = (_DWORD *)*v7;
            a1 = v9;
          }
          return a1;
        case 2:
        case 3:
        case 4:
        case 0xC:
          v5 = *(_DWORD *)(a2 + 12);
          v4 = a1;
          goto LABEL_4;
        case 5:
        case 6:
        case 7:
        case 9:
        case 0xA:
          v10 = *(_DWORD *)(a2 + 8);
          goto LABEL_10;
        case 8:
        case 0xD:
          v11 = sub_2E87C(a1, *(_DWORD *)(a2 + 12));
          v10 = *(_DWORD *)(a2 + 8);
          goto LABEL_14;
        case 0xB:
          v12 = strlen(*(const char **)(a2 + 16));
          v5 = *(_DWORD *)(a2 + 12);
          v4 = ((v12 + 8) & 0xFFFFFFF8) + a1;
LABEL_4:
          v6 = sub_2E87C(v4, v5);
          a2 = *(_DWORD *)(a2 + 8);
          a1 = v6;
          continue;
        case 0xE:
          v13 = sub_2E87C(a1, *(_DWORD *)(a2 + 12));
          return ((strlen(*(const char **)(a2 + 8)) + 8) & 0xFFFFFFF8) + v13;
        case 0xF:
          v14 = *(_DWORD **)(a2 + 12);
          while ( v14 )
          {
            v15 = sub_2E87C(a1 + 8, v14[1]);
            v14 = (_DWORD *)*v14;
            a1 = v15;
          }
          a1 += (strlen(*(const char **)(a2 + 8)) + 8) & 0xFFFFFFF8;
          goto LABEL_19;
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x16:
        case 0x17:
          v10 = *(_DWORD *)(a2 + 16);
          goto LABEL_10;
        case 0x18:
        case 0x19:
          v10 = *(_DWORD *)(a2 + 12);
LABEL_10:
          v11 = a1;
LABEL_14:
          a1 = sub_2E87C(v11, v10);
          goto LABEL_19;
        case 0x1A:
LABEL_19:
          a2 = *(_DWORD *)(a2 + 4);
          continue;
        default:
          return a1;
      }
    }
    return a1;
  }
}
// 2E8A8: control flows out of bounds to 2E8AC
// 681B5: using guessed type unsigned __int8 byte_681B5[27];

//----- (0002EA30) --------------------------------------------------------
_BYTE *__fastcall sub_2EA30(_BYTE *result, int a2)
{
  _BYTE *v2; // r4
  const char *v3; // r5
  const char *v4; // r0
  int v5; // r1
  int v6; // r1
  signed int v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  int v10; // r1
  int v11; // r5
  char *v12; // r4
  const char *v13; // r5
  int v14; // r1
  _DWORD *v15; // r4
  int v16; // r1
  int v17; // r1
  int v18; // r1
  int v19; // r1
  int v20; // r1
  int k; // r5
  int i; // r5
  int j; // r4
  int v24; // r1
  int v25; // r1
  _DWORD *m; // r4
  int v27; // r1
  int v28; // r1

  v2 = result;
  while ( 2 )
  {
    if ( !v2 )
      return result;
    switch ( *(_DWORD *)v2 )
    {
      case 0:
        for ( i = *((_DWORD *)v2 + 3); i; i = *(_DWORD *)(i + 4) )
        {
          result = (_BYTE *)sub_2EA30(i);
          if ( *(_DWORD *)(i + 4) )
            result = sub_2D828(" ", a2);
        }
        for ( j = *((_DWORD *)v2 + 4); j; j = *(_DWORD *)(j + 4) )
        {
          sub_2D828(" ", a2);
          result = (_BYTE *)sub_2EA30(j);
        }
        return result;
      case 2:
      case 3:
        goto LABEL_15;
      case 4:
        sub_2D828("(", a2);
        v11 = *((_DWORD *)v2 + 2);
        v12 = ")";
        goto LABEL_26;
      case 5:
        v13 = " && ";
        goto LABEL_14;
      case 6:
        v13 = " || ";
        goto LABEL_14;
      case 7:
        v13 = "; ";
LABEL_14:
        sub_2EA30(*((_DWORD *)v2 + 1));
        result = sub_2D828(v13, v14);
LABEL_15:
        v2 = (_BYTE *)*((_DWORD *)v2 + 2);
        continue;
      case 8:
        sub_2D828("if ", a2);
        sub_2EA30(*((_DWORD *)v2 + 1));
        sub_2D828("; then ", v17);
        if ( *((_DWORD *)v2 + 3) )
        {
          sub_2EA30(*((_DWORD *)v2 + 2));
          sub_2D828("; else ", v18);
          v11 = *((_DWORD *)v2 + 3);
        }
        else
        {
          v11 = *((_DWORD *)v2 + 2);
        }
        v12 = "; fi";
        goto LABEL_26;
      case 9:
        v9 = "while ";
        goto LABEL_11;
      case 0xA:
        v9 = "until ";
LABEL_11:
        sub_2D828(v9, a2);
        sub_2EA30(*((_DWORD *)v2 + 1));
        v11 = *((_DWORD *)v2 + 2);
        goto LABEL_12;
      case 0xB:
        sub_2D828("for ", a2);
        sub_2D828(*((const char **)v2 + 4), v19);
        sub_2D828(" in ", v20);
        for ( k = *((_DWORD *)v2 + 2); k; k = *(_DWORD *)(k + 4) )
        {
          sub_2EA30(k);
          if ( *(_DWORD *)(k + 4) )
            sub_2D828(" ", v10);
        }
        v11 = *((_DWORD *)v2 + 3);
LABEL_12:
        sub_2D828("; do ", v10);
        v12 = "; done";
LABEL_26:
        sub_2EA30(v11);
        goto LABEL_27;
      case 0xC:
        sub_2D828("case ", a2);
        sub_2D828(*(const char **)(*((_DWORD *)v2 + 2) + 8), v24);
        sub_2D828(" in ", v25);
        for ( m = (_DWORD *)*((_DWORD *)v2 + 3); m; m = (_DWORD *)m[1] )
        {
          sub_2EA30(m[2]);
          sub_2D828(") ", v27);
          sub_2EA30(m[3]);
          sub_2D828(";; ", v28);
        }
        v12 = "esac";
        goto LABEL_27;
      case 0xE:
        sub_2D828(*((const char **)v2 + 2), a2);
        v12 = "() { ... }";
        goto LABEL_27;
      case 0xF:
        v12 = (char *)*((_DWORD *)v2 + 2);
        goto LABEL_27;
      case 0x10:
        v3 = ">";
        goto LABEL_6;
      case 0x11:
      case 0x16:
        v3 = ">&";
        goto LABEL_6;
      case 0x12:
        v3 = ">|";
        goto LABEL_6;
      case 0x13:
        v3 = "<";
        goto LABEL_6;
      case 0x14:
        v3 = "<>";
        goto LABEL_6;
      case 0x15:
        v3 = ">>";
        goto LABEL_6;
      case 0x17:
        v3 = "<&";
LABEL_6:
        v4 = sub_16F64(*((_DWORD *)v2 + 2));
        sub_2D828(v4, v5);
        result = sub_2D828(v3, v6);
        if ( (unsigned int)(*(_DWORD *)v2 - 22) > 1 )
        {
          v2 = (_BYTE *)*((_DWORD *)v2 + 4);
          continue;
        }
        v7 = *((_DWORD *)v2 + 3);
        if ( v7 >= 0 )
          v8 = sub_16F64(v7);
        else
          v8 = "-";
        return sub_2D828(v8, a2);
      case 0x18:
      case 0x19:
        v12 = "<<...";
LABEL_27:
        v8 = v12;
        return sub_2D828(v8, a2);
      case 0x1A:
        result = sub_2D828("!", a2);
        v2 = (_BYTE *)*((_DWORD *)v2 + 1);
        continue;
      default:
        v15 = (_DWORD *)*((_DWORD *)v2 + 2);
        while ( 1 )
        {
          result = (_BYTE *)sub_2EA30(v15[1]);
          v15 = (_DWORD *)*v15;
          if ( !v15 )
            break;
          sub_2D828(" | ", v16);
        }
        return result;
    }
  }
}
// 2EA58: control flows out of bounds to 2EA5C
// 2EAD4: variable 'v5' is possibly undefined
// 2EADC: variable 'v6' is possibly undefined
// 2EB0C: variable 'a2' is possibly undefined
// 2EB20: variable 'v10' is possibly undefined
// 2EB3C: variable 'v14' is possibly undefined
// 2EB68: variable 'v16' is possibly undefined
// 2EBA4: variable 'v17' is possibly undefined
// 2EBC4: variable 'v18' is possibly undefined
// 2EC0C: variable 'v19' is possibly undefined
// 2EC14: variable 'v20' is possibly undefined
// 2ECE4: variable 'v24' is possibly undefined
// 2ECEC: variable 'v25' is possibly undefined
// 2ED0C: variable 'v27' is possibly undefined
// 2ED1C: variable 'v28' is possibly undefined

//----- (0002EDE0) --------------------------------------------------------
int __fastcall sub_2EDE0(int a1, _BYTE *a2, int a3)
{
  int v6; // r0
  __pid_t v7; // r1
  int v8; // r5
  __pid_t *v10; // r3
  bool v11; // zf
  int v12; // r1
  int v13; // r2
  int *v14; // r4
  bool v15; // zf
  int v16; // r6

  v6 = fork();
  v8 = v6;
  if ( v6 < 0 )
  {
    if ( a1 )
      sub_2A9BC(a1);
    sub_2ABFC("can't fork: %m");
  }
  if ( v6 )
  {
    if ( a1 )
    {
      if ( a3 != 2 )
      {
        if ( (*(_BYTE *)(a1 + 25) & 2) != 0 )
        {
          v10 = *(__pid_t **)(a1 + 20);
          v11 = v10 == 0;
          if ( v10 )
            v10 = *(__pid_t **)(a1 + 12);
          else
            v7 = v6;
          if ( !v11 )
            v7 = *v10;
          setpgid(v6, v7);
        }
        if ( a3 == 1 )
        {
          *(_DWORD *)(dword_7DBB0 + 488) = v8;
          sub_29708(a1, 1);
        }
      }
      v12 = *(_DWORD *)(a1 + 20);
      v13 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 20) = v12 + 1;
      v14 = (int *)(v13 + 12 * v12);
      *v14 = v8;
      v14[1] = -1;
      v14[2] = dword_7DBB0 + 60;
      v15 = dword_7D6B0 == 0;
      if ( dword_7D6B0 )
        v15 = a2 == 0;
      if ( !v15 )
      {
        v16 = dword_7DBB8;
        dword_7D6A0 = *(_DWORD *)(dword_7DBB8 + 4);
        sub_2EA30(a2, v12);
        v14[2] = (int)sub_174F8(*(const char **)(v16 + 4));
      }
    }
    else
    {
      while ( dword_7D6F8 && sub_2C558(0, 0) > 0 )
        ;
      ++dword_7D6F8;
    }
  }
  else
  {
    *(_DWORD *)(dword_7DBB0 + 472) = 0;
    sub_2DC30(a1, a2, a3);
  }
  return v8;
}
// 2EEAC: variable 'v7' is possibly undefined
// 7D6A0: using guessed type int dword_7D6A0;
// 7D6B0: using guessed type int dword_7D6B0;
// 7D6F8: using guessed type int dword_7D6F8;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0002EF58) --------------------------------------------------------
void __noreturn sub_2EF58(int a1, int a2, ...)
{
  va_list varg_r2; // [sp+10h] [bp+8h] BYREF

  va_start(varg_r2, a2);
  sub_2AB38("%s: %s", varg_r2);
  sub_2A2A4();
  sub_29EE0(4);
}

//----- (0002EF80) --------------------------------------------------------
void __fastcall __noreturn sub_2EF80(char *a1, char **a2, const void *a3, int a4)
{
  char **v7; // r7
  int v8; // r4
  char v9; // r3
  char *v10; // r0
  bool v11; // zf
  char *v12; // r0
  int v13; // r11
  const void *v14[2]; // [sp+4h] [bp-8h] BYREF

  v14[1] = a3;
  v14[0] = a3;
  v7 = (char **)sub_2DA60(1, 32, 0);
  if ( strchr(a1, 47) )
  {
    sub_2DF0C(a1, a2, v7);
    v8 = *(_DWORD *)dword_7DB94;
  }
  else
  {
    v8 = 2;
    while ( 1 )
    {
      v12 = (char *)sub_2DB08(v14, a1);
      v13 = (int)v12;
      if ( !v12 )
        break;
      if ( --a4 < 0 && !dword_7D724 )
      {
        sub_2DF0C(v12, a2, v7);
        v11 = *(_DWORD *)dword_7DB94 == 2;
        if ( *(_DWORD *)dword_7DB94 != 2 )
          v11 = *(_DWORD *)dword_7DB94 == 20;
        if ( !v11 )
          v8 = *(_DWORD *)dword_7DB94;
      }
      sub_295C0(v13);
    }
  }
  if ( v8 == 2 )
  {
    v9 = 127;
  }
  else if ( v8 == 13 )
  {
    v9 = 126;
  }
  else
  {
    v9 = 2;
  }
  *(_BYTE *)dword_7DBB0 = v9;
  v10 = sub_2DF6C(v8, (int)"not found");
  sub_2EF58(4, (int)"%s: %s", a1, v10);
}
// 7D724: using guessed type int dword_7D724;
// 7DB94: using guessed type int dword_7DB94;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002F094) --------------------------------------------------------
int sub_2F094()
{
  int result; // r0
  char **v1; // r4
  int v2; // r5
  char *v3; // r0

  dword_7D71C = 0;
  do
    result = sub_2B480((unsigned __int8 *)"a:");
  while ( result );
  v1 = (char **)dword_7D640;
  if ( *(_DWORD *)dword_7D640 )
  {
    v2 = dword_7DBB0;
    *(_WORD *)(dword_7DBB0 + 64) = 0;
    sub_2BB6C();
    ++*(_DWORD *)(v2 + 12);
    sub_29F94(3);
    v3 = *v1;
    if ( dword_7D71C )
      *v1 = (char *)dword_7D71C;
    sub_2EF80(v3, v1, (const void *)(*(_DWORD *)(dword_7DBB4 + 208) + 5), 0);
  }
  return result;
}
// 7D640: using guessed type int dword_7D640;
// 7D71C: using guessed type int dword_7D71C;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002F134) --------------------------------------------------------
int __fastcall sub_2F134(int a1)
{
  int v1; // r2
  int v3; // r1
  int result; // r0

  v3 = stdout;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  result = fputs_unlocked(a1, v3);
  v1 = dword_7DBB0;
  if ( (*(_DWORD *)(dword_7DBB0 + 40))-- == 1 )
  {
    if ( *(_DWORD *)(v1 + 44) )
      sub_2A17C(result);
  }
  return result;
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 2A17C: using guessed type void __fastcall __noreturn sub_2A17C(_DWORD);
// 7D614: using guessed type int stdout;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002F168) --------------------------------------------------------
int __fastcall sub_2F168(int a1, unsigned __int8 **a2)
{
  int v2; // r8
  int *v3; // r6
  int v4; // r0
  int v5; // r4
  int v6; // r5
  unsigned int v7; // r3
  unsigned int i; // r5
  int v9; // r0
  __pid_t v10; // r5
  int v11; // r3
  int v12; // r2
  int v13; // r4
  int v14; // t1
  const char *v16; // r1
  unsigned int v17; // [sp+4h] [bp-8h]

  v2 = **a2;
  sub_2B480((unsigned __int8 *)(dword_7DBB0 + 60));
  v3 = (int *)dword_7D640;
  do
  {
    v4 = sub_2B738(*v3, 1);
    v5 = v4;
    if ( v2 != 102 )
    {
      sub_29708(v4, 1);
      printf("[%d] ", ((v5 - dword_7D6FC) >> 5) + 1);
    }
    sub_2F134(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 8));
    v6 = *(_DWORD *)(v5 + 12);
    v7 = v6 + 12 * *(_DWORD *)(v5 + 20);
    for ( i = v6 + 12; v7 > i; i += 12 )
    {
      v16 = *(const char **)(i + 8);
      v17 = v7;
      printf(" | %s", v16);
      v7 = v17;
    }
    sub_2AAFC((FILE *)stdout);
    v9 = sub_2A2A4();
    ++*(_DWORD *)(dword_7DBB0 + 40);
    if ( *(_BYTE *)(v5 + 24) != 2 )
    {
      *(_BYTE *)(v5 + 24) = 0;
      v10 = **(_DWORD **)(v5 + 12);
      if ( v2 == 102 )
        sub_2B1EC(dword_7D4D4, v10);
      killpg(v10, 18);
      v11 = *(_DWORD *)(v5 + 12);
      v12 = *(_DWORD *)(v5 + 20);
      do
      {
        v9 = *(unsigned __int8 *)(v11 + 4);
        v11 += 12;
        if ( v9 == 127 )
          *(_DWORD *)(v11 - 8) = -1;
        --v12;
      }
      while ( v12 );
    }
    if ( v2 == 102 )
    {
      v9 = sub_2C8C0(v5);
      v13 = v9;
    }
    else
    {
      v13 = 0;
    }
    ((void (__fastcall *)(int))loc_2A270)(v9);
    if ( !*v3 )
      break;
    v14 = v3[1];
    ++v3;
  }
  while ( v14 );
  return v13;
}
// 7D4D4: using guessed type int dword_7D4D4;
// 7D614: using guessed type int stdout;
// 7D640: using guessed type int dword_7D640;
// 7D6FC: using guessed type int dword_7D6FC;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002F2F4) --------------------------------------------------------
unsigned __int8 *__fastcall sub_2F2F4(unsigned __int8 *a1)
{
  _DWORD *v2; // r0
  int v3; // r4
  unsigned __int8 *result; // r0
  unsigned __int8 *v5; // r3
  int v6; // r2
  int v7; // t1

  v2 = (_DWORD *)sub_29678(a1);
  v3 = *sub_296CC(v2, (int)a1);
  if ( !v3 )
    return 0;
  if ( (*(_DWORD *)(v3 + 4) & 0x200) != 0 )
    (*(void (__fastcall **)(_DWORD))(v3 + 12))(0);
  if ( (*(_DWORD *)(v3 + 4) & 0x20) != 0 )
    return 0;
  if ( v3 == dword_7DBB4 + 280 && *(_DWORD *)(dword_7DBB4 + 288) == dword_7DBB4 + 332 )
    sub_2C454((char *)(dword_7DBB4 + 339), 0xDu, "%d", *(_DWORD *)(dword_7DBB4 + 328));
  v5 = *(unsigned __int8 **)(v3 + 8);
  do
  {
    result = v5;
    v7 = *v5++;
    v6 = v7;
    if ( !v7 )
      break;
    result = v5;
  }
  while ( v6 != 61 );
  return result;
}
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002F3A8) --------------------------------------------------------
_DWORD *sub_2F3A8()
{
  unsigned int v0; // r4
  unsigned int v1; // r5
  unsigned int *v2; // r0
  unsigned __int8 **v3; // r5
  unsigned __int8 *v4; // r4
  unsigned __int8 *v5; // t1
  __pid_t v6; // r0
  const char *v7; // r0
  unsigned __int8 *v8; // r0
  unsigned int v9; // r0
  const char *v10; // r0
  unsigned __int8 *v11; // r0
  const char *v12; // r4
  __int64 v14; // [sp+0h] [bp-1F4h]
  __int64 v15; // [sp+60h] [bp-194h]
  struct utsname name; // [sp+68h] [bp-18Ch] BYREF

  dword_7D664 = (int)sub_1748C(0x400u);
  dword_7D660 = dword_7D664;
  dword_7D650 = 1;
  *(_BYTE *)(dword_7DBB0 + 92) = 1;
  sub_29F94(17);
  signal(1, 0);
  v0 = dword_7DBB4 + 184;
  v1 = dword_7DBB4 + 328;
  *(_DWORD *)(dword_7DBB4 + 224) = "PS1=\\w \\$ ";
  do
  {
    v2 = (unsigned int *)sub_29678(*(unsigned __int8 **)(v0 + 8));
    *(_DWORD *)v0 = *v2;
    *v2 = v0;
    v0 += 16;
  }
  while ( v1 > v0 );
  v3 = (unsigned __int8 **)_environ;
  while ( v3 )
  {
    v5 = *v3++;
    v4 = v5;
    if ( !v5 )
      break;
    if ( strchr((const char *)v4, 61) )
      sub_2AC34(v4, 9);
  }
  sub_2AC34("OPTIND=1", 8);
  v6 = getppid();
  v7 = sub_16F64(v6);
  sub_2AF84("PPID", v7);
  v8 = sub_2F2F4("SHLVL");
  if ( v8 )
    v9 = atoi((const char *)v8) + 1;
  else
    v9 = 1;
  v10 = sub_16F64(v9);
  sub_2AE08("SHLVL", v10, 1);
  if ( !sub_2F2F4("HOSTNAME") )
  {
    uname(&name);
    sub_2AF84("HOSTNAME", name.nodename);
  }
  v11 = sub_2F2F4((unsigned __int8 *)"PWD");
  v12 = (const char *)v11;
  if ( v11
    && (*v11 != 47
     || sub_62DFC()
     || sub_62DFC()
     || v14 != *(_QWORD *)name.sysname
     || v15 != *(_QWORD *)&name.nodename[31]) )
  {
    v12 = 0;
  }
  return sub_2BDBC(v12, 0);
}
// 2F504: variable 'v14' is possibly undefined
// 2F518: variable 'v15' is possibly undefined
// 7D600: using guessed type int _environ;
// 7D650: using guessed type int dword_7D650;
// 7D660: using guessed type int dword_7D660;
// 7D664: using guessed type int dword_7D664;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002F584) --------------------------------------------------------
int __fastcall sub_2F584(char *a1, int a2, int a3, int *a4)
{
  char v4; // r7
  int v5; // r6
  bool v6; // zf
  int v7; // r12
  __int16 v8; // r2
  int v9; // r5
  unsigned int v10; // r2
  char v11; // r7
  int v12; // r8
  int v13; // r1
  int v14; // r2
  int v15; // r0
  bool v16; // zf
  int *v17; // r3
  unsigned int v18; // r4
  int v19; // r2
  const char **v20; // r9
  int v21; // r0
  _BYTE *v23; // r0
  int v24; // r1
  int v25; // r3
  unsigned __int8 *v26; // r2
  int v27; // t1
  size_t v29; // r0
  bool v30; // zf
  const char *v31; // r10
  const char *v32; // t1
  char v33; // [sp+7h] [bp-5h] BYREF
  int v34; // [sp+8h] [bp-4h]

  v33 = HIBYTE(a2);
  v34 = a3;
  v5 = a2 & 0xF;
  v6 = v5 == 10;
  if ( v5 != 10 )
    v6 = v5 == 3;
  v7 = *a4;
  if ( !v6 )
    v4 = a3 & 0x11;
  v8 = (_WORD)a3 << 8;
  if ( v6 )
    v5 = 1;
  v9 = v8 & 0x100;
  v10 = (unsigned __int8)*a1;
  if ( v6 )
  {
    v11 = 2;
  }
  else
  {
    v5 = 0;
    v11 = v4 | 2;
  }
  v12 = *a4;
  if ( v7 )
    v12 = 1;
  if ( v10 == 45 )
  {
    v23 = (_BYTE *)sub_2D210(0xFu, dword_7D6C4);
    v24 = 0;
    v18 = 0;
    dword_7D6C4 = (int)v23;
    v25 = 14;
    v26 = (unsigned __int8 *)(dword_7DBB0 + 75);
    do
    {
      v27 = *v26--;
      if ( v27 && *off_6371C[v25] )
      {
        *v23 = *off_6371C[v25];
        ++v18;
        ++v23;
        v24 = 1;
      }
    }
    while ( v25-- != 0 );
    if ( v24 )
      dword_7D6C4 = (int)v23;
    goto LABEL_52;
  }
  if ( v10 > 0x2D )
  {
    if ( v10 == 63 )
    {
      v21 = *(unsigned __int8 *)dword_7DBB0;
      goto LABEL_51;
    }
    if ( v10 <= 0x3F )
    {
      if ( v10 - 48 <= 9 )
      {
        v15 = atoi(a1);
        if ( v15 < 0 || *(_DWORD *)dword_7DBB4 < v15 )
          return -1;
        v16 = v15 == 0;
        if ( v15 )
        {
          v15 += 0x3FFFFFFF;
          v17 = *(int **)(dword_7DBB4 + 16);
        }
        else
        {
          v17 = &dword_7DBB0;
        }
        if ( v16 )
          v17 = (int *)*v17;
        else
          v9 = v17[v15];
        if ( v16 )
          v9 = v17[8];
        goto LABEL_41;
      }
LABEL_17:
      v9 = (int)sub_2F2F4((unsigned __int8 *)a1);
LABEL_41:
      if ( v9 )
      {
        v18 = strlen((const char *)v9);
        sub_2D500(v9, v18, v12, v11);
        goto LABEL_52;
      }
      return -1;
    }
    if ( v10 != 64 )
      goto LABEL_17;
    if ( v9 )
      v19 = v12;
    else
      v19 = 0;
    if ( v19 )
    {
LABEL_48:
      v33 = v9;
      *a4 = (unsigned __int8)v9 == 0;
      v20 = *(const char ***)(dword_7DBB4 + 16);
      if ( v20 )
      {
        v18 = 0;
        while ( 1 )
        {
          v32 = *v20++;
          v31 = v32;
          if ( !v32 )
            break;
          v29 = strlen(v31);
          v18 += v29;
          sub_2D500((int)v31, v29, v12, v11);
          v30 = *v20 == 0;
          if ( *v20 )
            v30 = v9 == 0;
          if ( !v30 )
          {
            ++v18;
            sub_2D500((int)&v33, 1u, v12, v11);
          }
        }
        goto LABEL_52;
      }
      return -1;
    }
LABEL_20:
    if ( v7 )
      v9 = 0;
    v13 = *(_DWORD *)(dword_7DBB4 + 188);
    if ( (v13 & 0x20) != 0 )
      v14 = 32;
    else
      v14 = *(_DWORD *)(dword_7DBB4 + 192);
    if ( (v13 & 0x20) == 0 )
      v14 = *(unsigned __int8 *)(v14 + 4);
    v9 |= v14;
    goto LABEL_48;
  }
  if ( v10 == 35 )
  {
    v21 = *(_DWORD *)dword_7DBB4;
    goto LABEL_51;
  }
  if ( v10 > 0x23 )
  {
    if ( v10 == 36 )
    {
      v21 = *(_DWORD *)(dword_7DBB0 + 8);
      goto LABEL_51;
    }
    if ( v10 != 42 )
      goto LABEL_17;
    goto LABEL_20;
  }
  if ( v10 != 33 )
    goto LABEL_17;
  v21 = *(_DWORD *)(dword_7DBB0 + 488);
  if ( !v21 )
    return -1;
LABEL_51:
  v18 = sub_2D5F8(v21);
LABEL_52:
  if ( v5 )
    dword_7D6C4 -= v18;
  return v18;
}
// 2F5B0: variable 'v4' is possibly undefined
// 6371C: using guessed type char *off_6371C[13];
// 7D6C4: using guessed type int dword_7D6C4;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002F840) --------------------------------------------------------
const char *sub_2F840()
{
  int v0; // r4
  unsigned __int8 *v1; // r9
  const char *v2; // r8
  const char *v3; // r7
  int v4; // r6
  const char *v5; // r5
  int v6; // r0
  unsigned __int8 *v7; // r2
  __int64 v8; // r0
  const char *result; // r0
  int v10; // [sp+18h] [bp-Ch]
  int v11; // [sp+1Ch] [bp-8h]
  const char *v12; // [sp+1Ch] [bp-8h]

  v0 = 0;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  while ( 1 )
  {
    v6 = sub_2B480("p:u:rt:n:sd:");
    if ( !v6 )
      break;
    switch ( v6 )
    {
      case 'd':
        v1 = (unsigned __int8 *)dword_7D71C;
        break;
      case 'n':
        v5 = (const char *)dword_7D71C;
        break;
      case 'p':
        v4 = dword_7D71C;
        break;
      case 'r':
        v0 |= 2u;
        break;
      case 's':
        v0 |= 1u;
        break;
      case 't':
        v3 = (const char *)dword_7D71C;
        break;
      case 'u':
        v2 = (const char *)dword_7D71C;
        break;
      default:
        continue;
    }
  }
  v10 = dword_7DBB0;
  while ( 1 )
  {
    ++*(_DWORD *)(v10 + 40);
    v11 = dword_7D640;
    v7 = sub_2F2F4("IFS");
    HIDWORD(v8) = v11;
    LODWORD(v8) = sub_2AF84;
    v12 = sub_37024(v8, (const char *)v7, v0, v5, v4, v3, v2, v1);
    ((void (*)(void))loc_2A270)();
    result = v12;
    if ( v12 != (const char *)1 )
      break;
    if ( *(_DWORD *)dword_7DB94 != 4 || *(_DWORD *)(v10 + 52) )
      return result;
  }
  if ( (unsigned int)v12 > 1 )
    sub_2ABFC(v12);
  return result;
}
// 2F91C: control flows out of bounds to 2F920
// 7D640: using guessed type int dword_7D640;
// 7D71C: using guessed type int dword_7D71C;
// 7DB94: using guessed type int dword_7DB94;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0002F9C4) --------------------------------------------------------
int __fastcall sub_2F9C4(int a1, int a2)
{
  int v2; // r5
  unsigned int v3; // r2
  int v4; // r8
  bool v5; // cf
  int v6; // r3
  signed int v7; // r4
  unsigned __int8 *v8; // r9
  unsigned __int8 *v9; // r10
  int *v10; // r6
  const char *v11; // r7
  const char *v12; // r2
  _BYTE *v13; // r3
  int v14; // r9
  int v15; // r7
  int v16; // r4
  signed int v17; // r8
  const char *v18; // r0
  int v19; // r3
  bool v20; // zf
  int result; // r0
  unsigned __int8 *v22; // r3
  _BYTE *v23; // r3
  unsigned __int8 *v24; // r0
  unsigned __int8 *v25; // r0
  int v26; // [sp+4h] [bp-4h] BYREF

  v26 = a2;
  if ( a1 <= 2 )
    sub_2ABFC("usage: getopts optstring var [arg]");
  v2 = dword_7DBB4;
  v3 = *(_DWORD *)(dword_7DBB4 + 4);
  if ( a1 == 3 )
  {
    v4 = *(_DWORD *)(dword_7DBB4 + 16);
    v5 = *(_DWORD *)dword_7DBB4 + 1 >= v3;
  }
  else
  {
    v4 = a2 + 12;
    v5 = a1 - 2 >= v3;
  }
  if ( !v5 )
    *(_QWORD *)(dword_7DBB4 + 4) = 0xFFFFFFFF00000001LL;
  v6 = *(_DWORD *)(v2 + 4);
  v7 = *(_DWORD *)(v2 + 8);
  BYTE1(v26) = 0;
  v8 = *(unsigned __int8 **)(a2 + 4);
  v9 = *(unsigned __int8 **)(a2 + 8);
  *(_DWORD *)(v2 + 4) = -1;
  v10 = (int *)(v4 + 4 * (v6 + 0x3FFFFFFF));
  if ( (v6 <= 1) | ((unsigned int)v7 >> 31)
    || (v11 = (const char *)*(v10 - 1), v7 > (int)strlen(v11))
    || (v12 = &v11[v7]) == 0
    || !v11[v7] )
  {
    v13 = (_BYTE *)*v10;
    if ( !*v10 || *v13 != 45 || (v12 = v13 + 1, !v13[1]) || (++v10, v13[1] == 45) && !v13[2] )
    {
      v14 = 1;
      LOBYTE(v15) = 63;
      v16 = 0;
      sub_2AF78("OPTARG");
      goto LABEL_15;
    }
  }
  v15 = *(unsigned __int8 *)v12;
  v16 = (int)(v12 + 1);
  v22 = v8;
  while ( 1 )
  {
    if ( v15 == *v22 )
    {
      if ( v22[1] != 58 )
      {
        sub_2AF84("OPTARG", (const char *)(dword_7DBB0 + 60));
        goto LABEL_35;
      }
      v23 = (_BYTE *)*v10;
      if ( v12[1] )
      {
        if ( (_BYTE *)v16 != v23 )
        {
LABEL_50:
          sub_2AF84("OPTARG", (const char *)v16);
LABEL_34:
          v16 = 0;
LABEL_35:
          v14 = 0;
          goto LABEL_15;
        }
      }
      else
      {
        if ( !v23 )
        {
          v24 = sub_2F2F4("OPTERR");
          if ( (!v24 || *v24 != 48 || v24[1]) && *v8 != 58 )
          {
            v16 = 0;
            fprintf((FILE *)stderr, "No arg for -%c option\n", v15);
            sub_2AF78("OPTARG");
            goto LABEL_42;
          }
          LOBYTE(v26) = v15;
          LOBYTE(v15) = 58;
          sub_2AF84("OPTARG", (const char *)&v26);
          goto LABEL_34;
        }
        v16 = *v10;
      }
      ++v10;
      goto LABEL_50;
    }
    if ( !*v22 )
      break;
    if ( v22[1] == 58 )
      v22 += 2;
    else
      ++v22;
  }
  v25 = sub_2F2F4("OPTERR");
  if ( v25 && *v25 == 48 && !v25[1] || *v8 == 58 )
  {
    LOBYTE(v26) = v15;
    sub_2AF84("OPTARG", (const char *)&v26);
  }
  else
  {
    fprintf((FILE *)stderr, "Illegal option -%c\n", v15);
    sub_2AF78("OPTARG");
  }
LABEL_42:
  v14 = 0;
  LOBYTE(v15) = 63;
LABEL_15:
  v17 = (((int)v10 - v4) >> 2) + 1;
  v18 = sub_16F8C(v17);
  sub_2AE08("OPTIND", v18, 64);
  LOBYTE(v26) = v15;
  sub_2AF84(v9, (const char *)&v26);
  v20 = v16 == 0;
  result = v14;
  if ( v16 )
    v19 = *(v10 - 1);
  else
    v16 = -1;
  *(_DWORD *)(v2 + 4) = v17;
  if ( !v20 )
    v16 -= v19;
  *(_DWORD *)(v2 + 8) = v16;
  return result;
}
// 2FAE8: variable 'v19' is possibly undefined
// 7D608: using guessed type int stderr;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0002FCC4) --------------------------------------------------------
int sub_2FCC4()
{
  char v0; // r6
  unsigned __int8 *v1; // r4
  int v2; // r3
  int v3; // r3
  char *v4; // r7
  int v5; // r8
  bool v6; // zf
  int v7; // r11
  const char *v8; // r5
  char *v9; // r10
  char *v10; // r9
  const char *v11; // r0
  size_t v12; // r0
  _BYTE *v13; // r0
  int v14; // r2
  unsigned int v15; // r9
  int v16; // r1
  bool v17; // zf
  _BYTE *v18; // r5
  char *i; // r0
  int v20; // r4
  char *v21; // r0
  int v22; // r12
  int v23; // r1
  int v24; // r2
  int *j; // r3
  int *v26; // t1
  int v27; // r0
  int v29; // [sp+4h] [bp-78h]
  unsigned __int8 *v30; // [sp+Ch] [bp-70h] BYREF
  int v31; // [sp+20h] [bp-5Ch]

  v0 = sub_2B6FC();
  v1 = *(unsigned __int8 **)dword_7D640;
  if ( *(_DWORD *)dword_7D640 )
  {
    if ( *v1 != 45 || v1[1] )
      goto LABEL_5;
    v0 |= 2u;
    v1 = sub_2F2F4("OLDPWD");
  }
  else
  {
    v1 = sub_2F2F4("HOME");
  }
  if ( !v1 )
    v1 = (unsigned __int8 *)(dword_7DBB0 + 60);
LABEL_5:
  v2 = *v1;
  if ( v2 == 47 )
    goto LABEL_51;
  if ( v2 == 46 )
  {
    v3 = v1[1];
    if ( v3 == 46 )
    {
      v3 = v1[2];
      if ( v3 == 46 )
        goto LABEL_10;
    }
    if ( v3 != 47 && v3 )
      goto LABEL_10;
LABEL_51:
    v4 = (char *)v1;
    goto LABEL_28;
  }
  if ( *v1 )
  {
LABEL_10:
    v4 = (char *)v1;
    goto LABEL_19;
  }
  v4 = ".";
LABEL_19:
  v30 = sub_2F2F4("CDPATH");
  do
  {
    if ( !v30 )
    {
      v1 = (unsigned __int8 *)v4;
      goto LABEL_28;
    }
    v5 = *v30;
    v1 = (unsigned __int8 *)sub_2DB08((const void **)&v30, v4);
  }
  while ( sub_62DFC() < 0 || (v31 & 0xF000) != 0x4000 );
  v6 = v5 == 0;
  if ( v5 )
    v6 = v5 == 58;
  if ( !v6 )
    v0 |= 2u;
LABEL_28:
  v7 = dword_7DBB0;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v8 = (const char *)(v0 & 1);
  if ( (v0 & 1) != 0 )
  {
    v8 = 0;
    goto LABEL_48;
  }
  v9 = (char *)sub_2B310((const char *)v1);
  v29 = dword_7DBB8;
  v10 = *(char **)(dword_7DBB8 + 4);
  if ( *v1 != 47 )
  {
    v11 = *(const char **)(v7 + 24);
    if ( v11 == (const char *)(v7 + 60) )
      goto LABEL_48;
    v10 = sub_2D5C8(v11, *(_DWORD *)(dword_7DBB8 + 4));
  }
  v12 = strlen((const char *)v1);
  v13 = (_BYTE *)sub_2D210(v12 + 2, (int)v10);
  v14 = *(_DWORD *)(v29 + 4);
  v15 = v14 + 1;
  if ( *v1 == 47 )
  {
    *v13 = 47;
    v18 = v13 + 1;
    if ( v1[1] != 47 || v1[2] == 47 )
    {
      ++v9;
      goto LABEL_42;
    }
    v18 = v13 + 2;
    v13[1] = 47;
    v9 += 2;
  }
  else
  {
    v16 = (unsigned __int8)*(v13 - 1);
    v17 = v16 == 47;
    if ( v16 == 47 )
    {
      v18 = v13;
    }
    else
    {
      LOBYTE(v16) = 47;
      v18 = v13 + 1;
    }
    if ( !v17 )
      *v13 = v16;
    if ( v15 >= (unsigned int)v18 || *(_BYTE *)(v14 + 1) != 47 )
      goto LABEL_42;
  }
  v15 = v14 + 2;
LABEL_42:
  for ( i = strtok(v9, "/"); i; i = strtok(0, "/") )
  {
    if ( *i != 46 )
      goto LABEL_59;
    if ( i[1] == 46 )
    {
      if ( i[2] )
        goto LABEL_59;
      do
      {
        if ( (unsigned int)v18 <= v15 )
          break;
        --v18;
      }
      while ( *(v18 - 1) != 47 );
    }
    else if ( i[1] )
    {
LABEL_59:
      v21 = sub_2D5C8(i, (int)v18);
      v18 = v21 + 1;
      *v21 = 47;
      continue;
    }
  }
  if ( v15 < (unsigned int)v18 )
    --v18;
  *v18 = 0;
  v8 = *(const char **)(v29 + 4);
  if ( v8 )
    v1 = *(unsigned __int8 **)(v29 + 4);
LABEL_48:
  v20 = chdir((const char *)v1);
  if ( !v20 )
  {
    sub_2BDBC(v8, 1);
    v22 = dword_7D4CC;
    v23 = dword_7D6A4 - 4;
    v24 = dword_7D6A4 + 120;
    while ( v23 != v24 )
    {
      v26 = *(int **)(v23 + 4);
      v23 += 4;
      for ( j = v26; j; j = (int *)*j )
      {
        v27 = j[2];
        if ( !v27 || v27 == 2 && (**(_BYTE **)j[1] & 2) == 0 && v22 > 0 )
          *((_BYTE *)j + 12) = 1;
      }
    }
  }
  ((void (*)(void))loc_2A270)();
  if ( v20 )
    sub_2ABFC("can't cd to %s: %m", v4);
  if ( (v0 & 2) != 0 )
    sub_2BEA0("%s\n", *(const char **)(dword_7DBB0 + 24));
  return 0;
}
// 7D4CC: using guessed type int dword_7D4CC;
// 7D640: using guessed type int dword_7D640;
// 7D6A4: using guessed type int dword_7D6A4;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (00030080) --------------------------------------------------------
int sub_30080()
{
  _DWORD *v0; // r3
  int v1; // r2
  int result; // r0
  int v3; // r2
  unsigned __int8 *v4; // r2
  _DWORD *v5; // r3
  int v6; // r2
  int v7; // r1
  int v8; // r3
  bool v9; // zf
  int v10; // r0
  ssize_t v11; // r4
  _BYTE *v12; // r7
  int v13; // r8
  int v14; // r0
  _DWORD *v15; // r7
  char *v16; // r6
  char *v17; // r1
  int v18; // r3
  unsigned __int8 *v19; // r0
  int v20; // r6
  int v21; // r0
  int v22; // r3
  unsigned __int8 *v23; // r1
  signed int v24; // r0
  _BOOL4 v25; // r3
  char v26; // r4
  unsigned __int8 *v27; // r3

  v0 = off_7D4D0;
  v1 = *((_DWORD *)off_7D4D0 + 18);
  if ( v1 )
  {
    *((_DWORD *)off_7D4D0 + 18) = v1 - 1;
    return v0[v1 + 15];
  }
  v3 = *((_DWORD *)off_7D4D0 + 3) - 1;
  *((_DWORD *)off_7D4D0 + 3) = v3;
  if ( v3 < 0 )
  {
    v7 = v0[7];
    if ( v7 )
    {
      if ( v3 != -1 || !*(_DWORD *)(v7 + 12) )
        goto LABEL_13;
      v8 = *(unsigned __int8 *)(v0[5] - 1);
      v9 = v8 == 32;
      if ( v8 != 32 )
        v9 = v8 == 9;
      if ( !v9 )
      {
        result = 257;
      }
      else
      {
LABEL_13:
        sub_2A514();
        result = sub_30080(v10);
      }
    }
    else
    {
      if ( v3 >= -90 && v0[6] )
      {
        v11 = v0[4];
        if ( v11 > 0 )
        {
LABEL_23:
          v15 = off_7D4D0;
          v16 = (char *)*((_DWORD *)off_7D4D0 + 5);
          do
          {
            --v11;
            v17 = v16 + 1;
            if ( *v16 )
            {
              if ( *v16 == 10 )
              {
                ++v16;
                v15[3] = &v17[-v15[5] - 1];
                goto LABEL_45;
              }
              ++v16;
            }
            else
            {
              memmove(v16, v17, v11);
            }
          }
          while ( v11 );
          v18 = (int)&v16[-v15[5] - 1];
          v15[3] = v18;
          if ( v18 < 0 )
            goto LABEL_19;
LABEL_45:
          v15[4] = v11;
          if ( *(_BYTE *)(dword_7DBB0 + 69) )
          {
            v26 = *v16;
            *v16 = 0;
            sub_2C294(v15[5]);
            *v16 = v26;
          }
          v27 = (unsigned __int8 *)*((_DWORD *)off_7D4D0 + 5);
          *((_DWORD *)off_7D4D0 + 5) = v27 + 1;
          result = *v27;
          goto LABEL_5;
        }
        sub_2A2A4();
LABEL_19:
        v12 = (_BYTE *)*((_DWORD *)off_7D4D0 + 6);
        *((_DWORD *)off_7D4D0 + 5) = v12;
        v13 = dword_7DBB0;
        while ( 1 )
        {
          v14 = *((_DWORD *)off_7D4D0 + 2);
          if ( !*(_BYTE *)(v13 + 64) || v14 )
          {
            v11 = sub_60320(v14, v12, 0x3FFu);
            if ( v11 > 0 )
              goto LABEL_23;
            goto LABEL_42;
          }
          v19 = sub_2F2F4((unsigned __int8 *)"TMOUT");
          if ( v19 )
          {
            v20 = 1000 * atoi((const char *)v19);
            if ( v20 <= 0 )
              v20 = -1;
          }
          else
          {
            v20 = -1;
          }
          v21 = dword_7D708;
          v22 = dword_7DBB4;
          *(_DWORD *)(dword_7D708 + 4) = v20;
          v23 = (unsigned __int8 *)dword_7D69C;
          *(_DWORD *)(v21 + 8) = *(_DWORD *)(v22 + 208) + 5;
          v24 = sub_5C41C(v21, v23, v12, 1024);
          v11 = v24;
          if ( v24 )
            break;
          write(1, "^C", 2u);
          if ( *(_DWORD *)(v13 + 216) )
          {
            v12[1] = 0;
            *v12 = 10;
            raise(2);
            v11 = 1;
            goto LABEL_23;
          }
          *(_BYTE *)v13 = -126;
          j_putchar_unlocked(10);
        }
        if ( v24 >= 0 )
          goto LABEL_23;
        v25 = *(_DWORD *)dword_7DB94 == 11;
        if ( v20 <= 0 )
          v25 = 0;
        if ( v25 )
        {
          puts("\atimed out waiting for input: auto-logout");
          sub_33FBC();
        }
LABEL_42:
        v0 = off_7D4D0;
        *((_DWORD *)off_7D4D0 + 3) = -99;
      }
      result = 256;
      ++v0[5];
    }
  }
  else
  {
    v4 = (unsigned __int8 *)v0[5];
    v0[5] = v4 + 1;
    result = *v4;
  }
LABEL_5:
  v5 = off_7D4D0;
  v6 = *((_DWORD *)off_7D4D0 + 16);
  *((_DWORD *)off_7D4D0 + 16) = result;
  v5[17] = v6;
  return result;
}
// 30120: variable 'v10' is possibly undefined
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D69C: using guessed type int dword_7D69C;
// 7D708: using guessed type int dword_7D708;
// 7DB94: using guessed type int dword_7DB94;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (0003037C) --------------------------------------------------------
int sub_3037C()
{
  int result; // r0

  do
    result = sub_30080();
  while ( result == 257 );
  return result;
}
// 30080: using guessed type int sub_30080(void);

//----- (00030394) --------------------------------------------------------
int sub_30394()
{
  int result; // r0
  int v1; // r0
  bool v2; // zf
  int v3; // r4
  int v4; // r3
  int v5; // r0
  bool v6; // zf
  char *v7; // r0
  const char *v8; // r5
  int v9; // r0
  bool v10; // zf

  if ( dword_7D734 )
  {
    dword_7D734 = 0;
    return dword_7D704;
  }
  sub_318E0((_DWORD *)dword_7D714, 2);
  while ( 1 )
  {
    do
    {
      v1 = sub_319C8();
      v2 = v1 == 9;
      if ( v1 != 9 )
        v2 = v1 == 32;
      v3 = v1;
      v4 = v2;
      if ( v1 == 257 )
        v4 |= 1u;
    }
    while ( v4 );
    if ( v1 != 35 )
      break;
    do
    {
      v5 = sub_30080();
      v6 = v5 == 256;
      if ( v5 != 256 )
        v6 = v5 == 10;
    }
    while ( !v6 );
    sub_2989C();
  }
  if ( v1 != 92 )
  {
    if ( v1 == 256 )
    {
      v8 = "";
      goto LABEL_29;
    }
    if ( v1 == 10 )
      sub_29868();
    v7 = strchr("\n()&|;", v3);
    v8 = v7;
    if ( v7 )
    {
      if ( v7 - "\n()&|;" <= 2 )
      {
LABEL_29:
        result = byte_6875A[v8 - "\n()&|;"];
        dword_7D704 = result;
        return result;
      }
      if ( v3 == sub_319C8() )
      {
        v8 += 4;
        goto LABEL_29;
      }
      sub_2989C();
      v10 = v3 == 38;
      if ( v3 == 38 )
        v10 = v9 == 62;
      if ( !v10 )
        goto LABEL_29;
    }
  }
  return sub_308C0(v3, 0, 0, 0);
}
// 30470: variable 'v9' is possibly undefined
// 6875A: using guessed type unsigned __int8 byte_6875A[10];
// 7D704: using guessed type int dword_7D704;
// 7D714: using guessed type int dword_7D714;
// 7D734: using guessed type int dword_7D734;

//----- (000304C4) --------------------------------------------------------
int sub_304C4()
{
  char v0; // r6
  int v1; // r4
  _BYTE *v2; // r0
  int v4; // r1
  const char *v5; // r0

  v0 = dword_7D698;
  while ( 1 )
  {
    v1 = sub_30394();
    if ( (v0 & 4) != 0 )
    {
      while ( v1 == 1 )
      {
        sub_342E8();
        v1 = sub_30394();
      }
    }
    if ( v1 != 3 || dword_7D728 )
      break;
    if ( (v0 & 2) != 0 )
    {
      v2 = sub_2C428((const void *)dword_7D738);
      if ( v2 )
      {
        v1 = (v2 - (_BYTE *)&off_63758) >> 2;
        dword_7D704 = v1;
        break;
      }
    }
    if ( (dword_7D698 & 1) == 0 )
      break;
    v4 = *sub_29CD0((const char *)dword_7D738);
    if ( !v4 || (*(_DWORD *)(v4 + 12) & 1) != 0 )
      break;
    v5 = *(const char **)(v4 + 8);
    if ( *v5 )
      sub_2A6D4(v5, v4);
  }
  dword_7D698 = 0;
  return v1;
}
// 63758: using guessed type _UNKNOWN *off_63758;
// 7D698: using guessed type int dword_7D698;
// 7D704: using guessed type int dword_7D704;
// 7D728: using guessed type int dword_7D728;
// 7D738: using guessed type int dword_7D738;

//----- (000305AC) --------------------------------------------------------
void *sub_305AC()
{
  _DWORD *v0; // r4
  _DWORD *v1; // r5
  void *result; // r0
  _DWORD *v3; // r3
  _BYTE *v4; // r5
  bool v5; // zf

  v0 = (_DWORD *)dword_7D72C;
  if ( *(_DWORD *)dword_7D72C == 24 )
    dword_7D698 = 8;
  if ( sub_304C4() != 3 )
    sub_2E7E4(-1);
  if ( *v0 == 24 )
  {
    v1 = (_DWORD *)dword_7D6D4;
    if ( !dword_7D728 )
      *v0 = 25;
    result = sub_2D644((const char *)dword_7D738, 0, 0);
    v1[2] = dword_7D738;
    *v1 = 0;
    v3 = (_DWORD *)dword_7D6D8;
    if ( dword_7D6D8 )
    {
      while ( *v3 )
        v3 = (_DWORD *)*v3;
      *v3 = v1;
    }
    else
    {
      dword_7D6D8 = (int)v1;
    }
  }
  else
  {
    if ( (unsigned int)(*v0 - 22) > 1 )
      goto LABEL_22;
    v0[4] = 0;
    v4 = (_BYTE *)dword_7D738;
    result = (void *)sub_18990((const char *)dword_7D738, 0, (char *)0xA);
    v5 = result == 0;
    if ( (int)result >= 0 )
      v5 = *(_DWORD *)dword_7DB94 == 0;
    if ( v5 )
    {
      v0[3] = result;
      return result;
    }
    if ( *v4 != 45 || v4[1] )
    {
LABEL_22:
      result = sub_2C38C();
      v0[4] = result;
    }
    else
    {
      v0[3] = -1;
    }
  }
  return result;
}
// 7D698: using guessed type int dword_7D698;
// 7D6D4: using guessed type int dword_7D6D4;
// 7D6D8: using guessed type int dword_7D6D8;
// 7D728: using guessed type int dword_7D728;
// 7D72C: using guessed type int dword_7D72C;
// 7D738: using guessed type int dword_7D738;
// 7DB94: using guessed type int dword_7DB94;

//----- (000306F0) --------------------------------------------------------
int __fastcall sub_306F0(int a1)
{
  int v2; // r4
  int v3; // r0
  _DWORD *v5; // r9
  int v6; // r0
  int v7; // r7
  _DWORD *v8; // r0
  char v9; // r0
  int v10; // r2
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // [sp+8h] [bp-Ch]
  int v14; // [sp+Ch] [bp-8h]

  v2 = 0;
  while ( 2 )
  {
    v3 = sub_304C4();
    dword_7D734 = 1;
    if ( !v3 )
    {
      if ( !v2 )
      {
        if ( (a1 & 1) != 0 )
          v2 = -1;
        else
          v2 = 0;
      }
LABEL_5:
      sub_342E8();
      return v2;
    }
    if ( v3 == 1 && (a1 & 1) != 0 )
      goto LABEL_5;
    dword_7D698 = 7;
    if ( a1 == 2 )
    {
      v9 = sub_304C4();
      dword_7D734 = 1;
      if ( ((572496897 >> v9) & 1) != 0 )
        return v2;
    }
    v5 = sub_34BB8();
    while ( 1 )
    {
      v6 = sub_304C4();
      if ( v6 == 6 )
      {
        v10 = 5;
        goto LABEL_22;
      }
      if ( v6 != 7 )
        break;
      v10 = 6;
LABEL_22:
      v14 = v10;
      dword_7D698 = 7;
      v13 = sub_34BB8();
      v11 = sub_2C370(0xCu);
      *v11 = v14;
      v11[1] = v5;
      v5 = v11;
      v11[2] = v13;
    }
    dword_7D734 = 1;
    v7 = sub_304C4();
    if ( v7 == 5 )
    {
      if ( *v5 == 1 )
      {
        v5[1] = 1;
      }
      else
      {
        if ( *v5 != 2 )
        {
          v12 = sub_2C370(0x10u);
          v12[2] = v5;
          v5 = v12;
        }
        *v5 = 3;
      }
      if ( v2 )
      {
LABEL_17:
        v8 = sub_2C370(0xCu);
        *v8 = 7;
        v8[1] = v2;
        v8[2] = v5;
        v5 = v8;
        goto LABEL_18;
      }
LABEL_32:
      v2 = (int)v5;
      a1 |= 2u;
      continue;
    }
    break;
  }
  if ( v2 )
    goto LABEL_17;
LABEL_18:
  switch ( v7 )
  {
    case 0:
    case 1:
      dword_7D734 = 1;
      goto LABEL_32;
    case 4:
    case 5:
      goto LABEL_32;
    default:
      if ( (a1 & 1) != 0 )
        sub_2E7E4(-1);
      v2 = (int)v5;
      dword_7D734 = 1;
      break;
  }
  return v2;
}
// 307D0: control flows out of bounds to 307D4
// 7D698: using guessed type int dword_7D698;
// 7D734: using guessed type int dword_7D734;

//----- (000308C0) --------------------------------------------------------
int __fastcall sub_308C0(int a1, int a2, unsigned int a3, int a4)
{
  int *v7; // r5
  int v8; // r10
  unsigned int v9; // r4
  int v10; // r9
  int v11; // r7
  _BYTE *v12; // r0
  int v13; // r2
  int v14; // t1
  bool v15; // zf
  _BYTE *v16; // r4
  int v17; // r7
  _DWORD *v18; // r0
  _BOOL4 v19; // r3
  int v20; // r8
  unsigned __int8 v21; // r0
  int v22; // r0
  unsigned __int8 v23; // r0
  bool v24; // zf
  int v25; // r9
  int v26; // r0
  _BYTE *v27; // r1
  int v28; // r2
  bool v29; // zf
  int v30; // r3
  char v31; // r2
  char v32; // r2
  int v33; // r3
  int v34; // r3
  int v35; // r3
  int v36; // r3
  int v37; // r3
  const char *v38; // r0
  _BOOL4 v39; // r3
  const char *v40; // r5
  int v41; // r4
  bool v42; // zf
  int result; // r0
  int v44; // r2
  _BYTE *v45; // r1
  size_t v46; // r4
  const char *v47; // r0
  int v48; // r5
  _DWORD *v49; // r0
  _DWORD *v50; // r4
  int v51; // r0
  int v52; // r3
  int v53; // r3
  int v54; // r0
  _DWORD *v55; // r0
  int v56; // r0
  int v57; // r3
  unsigned int v58; // r2
  bool v59; // zf
  _BOOL4 v60; // r2
  int v61; // r3
  int v62; // r8
  _BYTE *v63; // r10
  size_t v64; // r4
  int *v65; // r9
  int v66; // r0
  int v67; // r2
  int v68; // r8
  _BYTE *v69; // r9
  int v70; // r0
  _BOOL4 v71; // r4
  char *v72; // r0
  int v73; // r0
  int v74; // r3
  int v75; // r2
  bool v76; // zf
  int v77; // r0
  char *v78; // r0
  int *v79; // r4
  int v80; // r0
  bool v81; // zf
  unsigned int v82; // r1
  _BYTE *v83; // r0
  _BYTE *v84; // r0
  const char *v85; // r0
  _DWORD *i; // r3
  void *v87; // r0
  int *v88; // r1
  int v89; // r2
  int v90; // r3
  int v91; // r0
  int *v92; // r1
  int v93; // r3
  int v94; // r0
  _BYTE *v95; // r3
  int *v96; // r8
  int v97; // [sp+0h] [bp-94h] BYREF
  int v98; // [sp+28h] [bp-6Ch] BYREF
  int v99; // [sp+2Ch] [bp-68h]
  int v100; // [sp+30h] [bp-64h]
  int v101; // [sp+34h] [bp-60h]
  _BOOL4 v102; // [sp+38h] [bp-5Ch]
  _BYTE v103[12]; // [sp+3Ch] [bp-58h]
  int v104; // [sp+48h] [bp-4Ch] BYREF
  char *v105; // [sp+4Ch] [bp-48h] BYREF
  char v106; // [sp+50h] [bp-44h] BYREF
  char v107; // [sp+51h] [bp-43h] BYREF
  _DWORD v108[7]; // [sp+54h] [bp-40h] BYREF

  v100 = a4;
  memset(&v108[1], 0, 0x18u);
  v102 = a2 == 4;
  if ( a2 == 4 )
  {
    v108[0] = 1;
LABEL_4:
    LOBYTE(v108[1]) |= 4u;
    goto LABEL_5;
  }
  v108[0] = a2;
  if ( a2 == 1 )
    goto LABEL_4;
LABEL_5:
  v7 = v108;
  v104 = 0;
  *(_DWORD *)&v103[8] = 0;
  v8 = *(_DWORD *)(dword_7DBB8 + 4);
  *(_QWORD *)v103 = (unsigned int)&dword_7DBB8;
  while ( 2 )
  {
    if ( a3 > 1 )
    {
      if ( a1 == 257 )
        a1 = sub_3037C();
      if ( v100 )
      {
        while ( a1 == 9 )
          a1 = sub_3037C();
      }
      v9 = a3 - 1;
      v10 = **(_DWORD **)v103;
      v11 = v8 - *(_DWORD *)(**(_DWORD **)v103 + 4);
      while ( 1 )
      {
        v12 = sub_2DA30(a1, (_BYTE *)v8);
        v14 = *(unsigned __int8 *)++v9;
        v13 = v14;
        v8 = (int)v12;
        if ( !v14 )
          break;
        if ( v13 != a1 )
          goto LABEL_142;
        a1 = sub_3037C();
      }
      v15 = a1 == 256;
      if ( a1 != 256 )
        v15 = a1 == 10;
      if ( v15 )
      {
        a1 = 256;
        ++*((_DWORD *)off_7D4D0 + 1);
        dword_7D714 = dword_7D6B4;
        goto LABEL_17;
      }
LABEL_142:
      v44 = *(_DWORD *)(v10 + 4);
      v45 = (_BYTE *)(v44 + v11 + 1);
      v46 = v12 - v45;
      if ( v12 != v45 )
      {
        if ( a1 > 255 )
          --v46;
        a1 = *(unsigned __int8 *)(v44 + v11);
        if ( v46 )
        {
          v47 = (const char *)memcpy(&v98, v45, v46);
          v47[v46] = 0;
          sub_2A6D4(v47, 0);
        }
      }
LABEL_17:
      v8 = *(_DWORD *)(v10 + 4) + v11;
    }
    v16 = (_BYTE *)v8;
    v17 = **(_DWORD **)v103;
    v99 = 1 - (_DWORD)"}-+?=";
LABEL_56:
    if ( (unsigned int)(*(_DWORD *)(v17 + 8) - (_DWORD)v16) <= 3 )
      v16 = (_BYTE *)sub_2D210(4u, (int)v16);
    v25 = *v7;
    switch ( sub_29A14(a1, *v7) )
    {
      case 0:
        goto LABEL_36;
      case 1:
        if ( !v25 && !v7[2] )
          goto LABEL_116;
        *v16 = a1;
        v8 = (int)(v16 + 1);
        v18 = sub_3199C();
        a1 = sub_30080(v18);
        continue;
      case 2:
        v26 = sub_3037C();
        switch ( v26 )
        {
          case 256:
            *v16 = -127;
            v16[1] = 92;
            sub_2989C();
            v16 = v27;
            goto LABEL_55;
          case 10:
            sub_3199C();
            goto LABEL_55;
          case 36:
            v28 = v102;
            break;
          default:
            v28 = 0;
            break;
        }
        if ( v28 )
        {
          *v16 = -127;
          v16[1] = 92;
          v16 += 2;
        }
        if ( (v7[1] & 4) == 0 )
          goto LABEL_75;
        v29 = v26 == 36;
        if ( v26 != 36 )
          v29 = ((v26 - 92) & 0xFFFFFFFB) == 0;
        if ( v29 )
          goto LABEL_75;
        if ( v26 == 34 )
        {
          if ( !a3 )
            goto LABEL_75;
        }
        else if ( v26 != 125 )
        {
          goto LABEL_78;
        }
        if ( v7[2] )
          goto LABEL_75;
LABEL_78:
        *v16 = -127;
        v16[1] = 92;
        v16 += 2;
LABEL_75:
        *v16 = -127;
        v16[1] = v26;
        v16 += 2;
        goto LABEL_76;
      case 3:
        *v7 = 2;
        goto LABEL_80;
      case 4:
        *v7 = 1;
        *((_BYTE *)v7 + 4) |= 4u;
        goto LABEL_85;
      case 5:
        if ( a3 )
        {
          *(_DWORD *)&v103[8] = v7[2];
          if ( !*(_DWORD *)&v103[8] )
            goto LABEL_36;
        }
        v30 = v7[3];
        *(_QWORD *)&v103[4] = 1;
        if ( !v30 )
        {
          v31 = *((_BYTE *)v7 + 4);
          *v7 = 0;
          *((_BYTE *)v7 + 4) = v31 & 0xFB;
        }
        if ( a1 == 34 )
        {
LABEL_85:
          if ( v7[2] )
            *((_BYTE *)v7 + 4) = v7[1] & 0xFE | !(v7[1] & 1);
        }
LABEL_80:
        if ( a3 )
          goto LABEL_55;
        *v16 = -120;
        goto LABEL_83;
      case 6:
        if ( (dword_7D698 & 8) == 0 )
        {
          v62 = 1;
          goto LABEL_200;
        }
        *v16++ = 96;
LABEL_76:
        *(_DWORD *)&v103[4] = 1;
        goto LABEL_55;
      case 7:
        v56 = sub_319C8();
        v57 = v56;
        v58 = ((unsigned int)dword_7D698 >> 3) & 1;
        if ( v56 > 255 )
          v58 = 1;
        if ( v58 )
          goto LABEL_188;
        v59 = v56 == 40;
        if ( v56 != 40 )
          v59 = v56 == 123;
        LOBYTE(v58) = !v59;
        if ( v56 == 95 )
          v58 = 0;
        if ( v58
          && (unsigned __int8)((v56 | 0x20) - 97) > 0x19u
          && ((unsigned int)(v56 - 33) > 0x1F || ((0xC1FF920D >> (v56 - 33)) & 1) == 0) )
        {
LABEL_188:
          v60 = *v7 != 1;
          if ( v56 != 39 )
            v60 = 0;
          if ( v60 )
            v61 = 1;
          else
            v61 = 36;
          if ( v60 )
            *(_DWORD *)&v103[8] = v61;
          else
            *v16++ = v61;
          sub_2989C();
          goto LABEL_55;
        }
        if ( v56 != 40 )
        {
          v68 = *v7;
          *v16 = -126;
          v69 = v16 + 2;
          if ( v56 != 123 )
            v8 = 1;
          v101 = (int)&v16[-*(_DWORD *)(v17 + 4) + 1];
          if ( v56 == 123 )
          {
            v8 = 0;
            v57 = sub_319C8();
          }
          while ( 1 )
          {
            if ( v57 == 95 || ((unsigned __int8)v57 | 0x20u) - 97 <= 0x19 )
              goto LABEL_214;
            if ( (unsigned int)(unsigned __int8)v57 - 48 <= 9 )
            {
              do
              {
                v69 = sub_2DA30(v57, v69);
                v57 = sub_319C8();
              }
              while ( (unsigned __int8)(v57 - 48) <= 9u );
              goto LABEL_217;
            }
            v98 = v57;
            v73 = sub_319C8();
            v74 = v98;
            v75 = v73;
            v76 = v8 == 0;
            if ( !v8 )
              v76 = v98 == 35;
            if ( !v76 )
              goto LABEL_245;
            if ( v73 == 95 )
              break;
            if ( (unsigned int)(unsigned __int8)v73 - 48 > 9 && ((unsigned __int8)v73 | 0x20u) - 97 > 0x19 )
            {
              v98 = v73;
              v77 = sub_319C8() != 125;
              if ( v98 == 125 )
                v77 |= 1u;
              if ( v77 )
              {
                sub_2989C();
                v75 = v98;
                v74 = 35;
                v8 = 0;
              }
              else
              {
                v74 = v98;
                v8 = 10;
                v75 = 125;
              }
LABEL_245:
              if ( (unsigned int)(v74 - 33) <= 0x1F && ((0xC1FF920D >> (v74 - 33)) & 1) != 0 )
              {
                v16[2] = v74;
                v69 = v16 + 3;
                v57 = v75;
                goto LABEL_217;
              }
              if ( v8 == 10 )
                v8 = 0;
LABEL_249:
              sub_2989C();
LABEL_255:
              if ( v68 == 3 )
                v68 = 1;
LABEL_264:
              if ( (*v7 != v68 || (v7[1] & 1) != 0) && v8 != 1 )
              {
                v79 = (int *)v7[5];
                if ( !v79 )
                  v79 = &v97;
                memset(v79 + 1, 0, 0x14u);
                *v79 = v68;
                v79[6] = (int)v7;
                v7[5] = (int)v79;
                v7 = v79;
                *((_BYTE *)v79 + 4) = v79[1] & 0xF9 | 2 | (4 * (v68 != 0));
              }
              *(_BYTE *)(*(_DWORD *)(**(_DWORD **)v103 + 4) + v101) = v8;
              if ( v8 != 1 )
              {
                ++v7[2];
                if ( (v7[1] & 4) != 0 )
                  ++v7[3];
              }
              v16 = sub_2DA30(61, v69);
              goto LABEL_55;
            }
            v8 = 10;
            v57 = v73;
          }
          LOBYTE(v57) = 95;
          v8 = 10;
          do
          {
            do
            {
LABEL_214:
              v69 = sub_2DA30(v57, v69);
              v70 = sub_319C8();
              v57 = v70;
            }
            while ( v70 == 95 );
          }
          while ( (unsigned int)(unsigned __int8)v70 - 48 <= 9 || ((unsigned __int8)v70 | 0x20u) - 97 <= 0x19 );
LABEL_217:
          v71 = v57 != 125;
          if ( v8 != 10 )
            v71 = 0;
          if ( v71 )
          {
            v8 = 10;
            goto LABEL_249;
          }
          if ( v8 )
            goto LABEL_249;
          if ( v57 == 37 )
          {
            v8 = 6;
          }
          else
          {
            if ( v57 > 37 )
            {
              if ( v57 == 47 )
              {
                if ( sub_319C8() != 47 )
                {
                  v68 = 0;
                  v8 = 13;
                  goto LABEL_249;
                }
                v8 = 14;
                v68 = 0;
                goto LABEL_264;
              }
              if ( v57 == 58 )
              {
                v98 = sub_319C8();
                v78 = strchr("}-+?=", v98);
                v57 = v98;
                if ( !v78 )
                {
                  v8 = 12;
                  sub_2989C();
                  goto LABEL_255;
                }
                v8 = 16;
              }
LABEL_224:
              v72 = strchr("}-+?=", v57);
              if ( v72 )
                v8 = (unsigned __int8)(((_BYTE)v72 + v99) | v8);
              goto LABEL_255;
            }
            if ( v57 != 35 )
              goto LABEL_224;
            v8 = 8;
          }
          v98 = v57;
          if ( v57 == sub_319C8() )
            v8 = (unsigned __int8)(v8 + 1);
          else
            sub_2989C();
          v68 = 0;
          goto LABEL_264;
        }
        if ( sub_319C8() == 40 )
        {
          v96 = (int *)v7[5];
          if ( !v96 )
            v96 = &v97;
          memset(v96 + 1, 0, 0x14u);
          v96[6] = (int)v7;
          *v96 = 3;
          v7[5] = (int)v96;
          v7 = v96;
          *((_BYTE *)v96 + 4) |= 4u;
          *v16 = -122;
          goto LABEL_83;
        }
        v62 = 0;
        sub_2989C();
LABEL_200:
        v63 = *(_BYTE **)(v17 + 4);
        v64 = v16 - v63;
        if ( v64 )
        {
          v65 = &v98;
          memcpy(&v98, *(const void **)(v17 + 4), v64);
        }
        else
        {
          v65 = 0;
        }
        if ( v62 )
        {
          while ( 1 )
          {
            sub_318E0((_DWORD *)dword_7D714, 2);
            v66 = sub_319C8();
            LOBYTE(v67) = v66;
            if ( v66 == 96 )
              break;
            if ( v66 > 96 )
            {
              if ( (unsigned int)(v66 - 256) <= 1 )
                goto LABEL_281;
            }
            else if ( v66 == 10 )
            {
              v101 = 10;
              sub_29868();
              LOBYTE(v67) = v101;
            }
            else if ( v66 == 92 )
            {
              v80 = ((int (*)(void))sub_30080)();
              v67 = v80;
              v81 = v80 == 36;
              if ( v80 != 36 )
                v81 = ((v80 - 92) & 0xFFFFFFFB) == 0;
              if ( !v81 )
              {
                v82 = ((*((unsigned __int8 *)v7 + 4) ^ 4u) >> 2) & 1;
                if ( v80 != 34 )
                  v82 = 1;
                if ( v82 )
                {
                  v101 = v80;
                  v83 = sub_2DA30(92, v63);
                  v67 = v101;
                  v63 = v83;
                }
              }
              if ( v67 > 255 )
              {
LABEL_281:
                v38 = "EOF in backquote substitution";
LABEL_122:
                sub_2B44C(v38);
              }
            }
            v63 = sub_2DA30(v67, v63);
          }
          v84 = &sub_2DA30(0, v63)[-*(_DWORD *)(v17 + 4)];
          if ( v84 )
          {
            v85 = (const char *)sub_2B208((int)v84);
            sub_2A67C(v85);
          }
        }
        v8 = (int)&v104;
        for ( i = (_DWORD *)v104; i; i = (_DWORD *)*i )
          v8 = (int)i;
        v101 = 0;
        v87 = sub_2C370(8u);
        v90 = v101;
        if ( v62 )
          v88 = &dword_7D6B4;
        else
          v89 = 0;
        *(_DWORD *)v8 = v87;
        if ( v62 )
        {
          v89 = *v88;
          *v88 = v90;
        }
        v101 = v89;
        v91 = sub_306F0(2, v88);
        if ( v62 )
          v92 = &dword_7D6B4;
        v93 = v91;
        if ( v62 )
        {
          *v92 = v101;
        }
        else
        {
          v101 = v91;
          v94 = sub_304C4();
          v93 = v101;
          if ( v94 != 10 )
            sub_2E7E4(10);
        }
        *(_DWORD *)(*(_DWORD *)v8 + 4) = v93;
        if ( v62 )
        {
          sub_2A5FC();
          dword_7D734 = 0;
        }
        while ( *(_DWORD *)(v17 + 12) <= v64 )
          sub_2D148();
        v95 = *(_BYTE **)(v17 + 4);
        if ( v65 )
          v95 = (char *)memcpy(*(void **)(v17 + 4), v65, v64) + v64;
        v16 = v95 + 1;
        *v95 = -124;
        goto LABEL_55;
      case 8:
        v32 = *((_BYTE *)v7 + 4);
        if ( (v32 & 1) == 0 )
        {
          v33 = v7[2];
          if ( v33 > 0 )
          {
            v34 = v33 - 1;
            v7[2] = v34;
            if ( v34 || (v32 & 2) == 0 )
            {
              v35 = v7[3];
              if ( v35 > 0 )
                v7[3] = v35 - 1;
            }
            else
            {
              v7 = (int *)v7[6];
            }
            LOBYTE(a1) = -125;
          }
        }
        goto LABEL_36;
      case 9:
        v36 = v7[4] + 1;
        goto LABEL_103;
      case 10:
        v37 = v7[4];
        if ( v37 <= 0 )
        {
          if ( sub_319C8() == 41 )
          {
            v7 = (int *)v7[6];
            LOBYTE(a1) = -121;
          }
          else
          {
            sub_2989C();
          }
        }
        else
        {
          v36 = v37 - 1;
LABEL_103:
          v7[4] = v36;
        }
        goto LABEL_36;
      case 11:
        goto LABEL_116;
      case 12:
        v19 = a1 == 92;
        if ( !*(_DWORD *)&v103[8] )
          v19 = 0;
        if ( !v19 )
          goto LABEL_32;
        a1 = ((int (*)(void))sub_30080)();
        v105 = strchr("nrbtfavx\\01234567", a1);
        if ( !v105 )
        {
          v24 = a1 == 39;
          if ( a1 != 39 )
            v24 = a1 == 34;
          if ( v24 )
          {
            if ( !a1 )
              goto LABEL_55;
          }
          else
          {
LABEL_43:
            LOWORD(a1) = a1 | 0x100;
          }
          if ( (a1 & 0x100) != 0 )
          {
            if ( !a3 || (v7[1] & 4) != 0 )
              *v16++ = -127;
            *v16++ = 92;
          }
          goto LABEL_32;
        }
        v106 = a1;
        v105 = &v106;
        if ( (unsigned int)(unsigned __int8)a1 - 48 > 7 )
        {
          if ( a1 == 120 )
          {
            v8 = 3;
            do
            {
              v23 = ((int (*)(void))sub_30080)();
              *++v105 = v23;
              if ( (unsigned int)v23 - 48 > 9 && (v23 | 0x20u) - 97 > 5 )
                break;
              --v8;
            }
            while ( v8 );
            sub_2989C();
            if ( v8 == 3 )
              goto LABEL_43;
          }
          else
          {
            v105 = &v107;
          }
        }
        else
        {
          v20 = 3;
          do
          {
            v21 = ((int (*)(void))sub_30080)();
            *++v105 = v21;
            if ( (unsigned int)v21 - 48 > 7 )
              break;
            --v20;
          }
          while ( v20 );
          sub_2989C();
        }
        *v105 = 0;
        v105 = &v106;
        v22 = sub_5E668((unsigned __int8 **)&v105);
        LOBYTE(a1) = v22;
        if ( !v22 )
          goto LABEL_55;
LABEL_32:
        if ( !a3 || (v7[1] & 4) != 0 || v7[2] )
          *v16++ = -127;
        goto LABEL_36;
      case 14:
        goto LABEL_55;
      default:
        if ( v7[2] )
        {
          if ( a1 != 257 )
          {
LABEL_36:
            *v16 = a1;
LABEL_83:
            ++v16;
          }
LABEL_55:
          a1 = ((int (*)(void))sub_30080)();
          goto LABEL_56;
        }
        if ( a1 == 38 )
        {
          if ( ((int (*)(void))sub_30080)() == 62 )
            a1 = 318;
          sub_2989C();
        }
LABEL_116:
        if ( *v7 == 3 )
        {
          v38 = "missing '))'";
          goto LABEL_122;
        }
        v39 = a3 == 0;
        if ( !*v7 )
          v39 = 0;
        if ( v39 )
        {
          v38 = "unterminated quoted string";
          goto LABEL_122;
        }
        if ( v7[2] )
        {
          v38 = "missing '}'";
          goto LABEL_122;
        }
        *v16 = 0;
        v40 = *(const char **)(v17 + 4);
        v41 = v16 + 1 - v40;
        if ( a3 )
        {
LABEL_135:
          dword_7D728 = *(_DWORD *)&v103[4];
          dword_7D648 = v104;
          sub_2B208(v41);
          result = 3;
          dword_7D738 = (int)v40;
        }
        else
        {
          v42 = a1 == 318;
          if ( a1 != 318 )
            v42 = (a1 & 0xFFFFFFFD) == 60;
          if ( !v42 || *(_DWORD *)&v103[4] || !sub_29594((int)v40) )
          {
            sub_2989C();
            goto LABEL_135;
          }
          if ( *v40 )
            v48 = atoi(v40);
          else
            v48 = -1;
          v49 = sub_2C370(0x18u);
          v50 = v49;
          if ( a1 == 62 )
          {
            v49[2] = 1;
            v51 = sub_319C8();
            switch ( v51 )
            {
              case '>':
                v52 = 21;
                goto LABEL_158;
              case '|':
                v52 = 18;
                goto LABEL_158;
              case '&':
                v52 = 22;
                goto LABEL_158;
            }
            v53 = 16;
LABEL_168:
            *v50 = v53;
LABEL_171:
            sub_2989C();
            goto LABEL_159;
          }
          if ( a1 == 318 )
          {
            v49[2] = 1;
            ((void (*)(void))sub_30080)();
            v52 = 17;
LABEL_158:
            *v50 = v52;
            goto LABEL_159;
          }
          v54 = sub_319C8();
          if ( v54 != 60 )
          {
            if ( v54 == 62 )
            {
              v52 = 20;
            }
            else
            {
              if ( v54 != 38 )
              {
                v53 = 19;
                goto LABEL_168;
              }
              v52 = 23;
            }
            goto LABEL_158;
          }
          v50 = sub_2C370(0x10u);
          *v50 = 24;
          v55 = sub_2C370(0x10u);
          v55[1] = v50;
          dword_7D6D4 = (int)v55;
          if ( sub_319C8() != 45 )
            goto LABEL_171;
          *(_DWORD *)(dword_7D6D4 + 12) = 1;
LABEL_159:
          if ( v48 >= 0 )
            v50[2] = v48;
          result = 2;
          dword_7D72C = (int)v50;
        }
        dword_7D704 = result;
        return result;
    }
  }
}
// 30BF8: control flows out of bounds to 30BFC
// 31138: masking with 0x1 was optimized away because r2.4 <= 0x1
// 30C5C: variable 'v27' is possibly undefined
// 31680: variable 'v88' is possibly undefined
// 31688: variable 'v89' is possibly undefined
// 316A0: variable 'v92' is possibly undefined
// 30080: using guessed type int __fastcall sub_30080(_DWORD);
// 304C4: using guessed type int sub_304C4(void);
// 306F0: using guessed type int __fastcall sub_306F0(_DWORD, _DWORD);
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D648: using guessed type int dword_7D648;
// 7D698: using guessed type int dword_7D698;
// 7D6B4: using guessed type int dword_7D6B4;
// 7D6D4: using guessed type int dword_7D6D4;
// 7D704: using guessed type int dword_7D704;
// 7D714: using guessed type int dword_7D714;
// 7D728: using guessed type int dword_7D728;
// 7D72C: using guessed type int dword_7D72C;
// 7D734: using guessed type int dword_7D734;
// 7D738: using guessed type int dword_7D738;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (000317CC) --------------------------------------------------------
int __fastcall sub_317CC(const char *a1, int a2)
{
  int v2; // r5
  int v3; // r4
  int v4; // r3
  int v6; // r0
  int v7; // [sp+0h] [bp-1B4h]
  int v9; // [sp+8h] [bp-1ACh]
  int v10; // [sp+Ch] [bp-1A8h]
  _DWORD v11[6]; // [sp+10h] [bp-1A4h] BYREF
  jmp_buf env; // [sp+28h] [bp-18Ch] BYREF

  sub_2A67C(a1);
  v7 = dword_7D6B4;
  dword_7D6B4 = 0;
  v10 = *(_DWORD *)(dword_7DBB0 + 36);
  v9 = *(_DWORD *)(dword_7DBB0 + 40);
  v2 = setjmp(env);
  v3 = dword_7DBB0;
  if ( !v2 )
  {
    *(_DWORD *)(dword_7DBB0 + 36) = env;
    v6 = sub_30080(0);
    sub_308C0(v6, a2, 1u, 0);
  }
  *(_DWORD *)(v3 + 36) = v10;
  v4 = dword_7DBB0;
  *(_DWORD *)(dword_7DBB0 + 40) = v9;
  if ( !*(_DWORD *)(v4 + 40) && *(_DWORD *)(v4 + 44) )
    sub_2A17C();
  dword_7D6B4 = v7;
  sub_2A5FC();
  v11[0] = 15;
  v11[1] = 0;
  v11[2] = dword_7D738;
  v11[3] = dword_7D648;
  sub_32FC4((int)v11, 0, 0x80u);
  return *(_DWORD *)(dword_7DBB8 + 4);
}
// 30080: using guessed type int __fastcall sub_30080(_DWORD);
// 7D648: using guessed type int dword_7D648;
// 7D6B4: using guessed type int dword_7D6B4;
// 7D738: using guessed type int dword_7D738;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (000318E0) --------------------------------------------------------
_DWORD *__fastcall sub_318E0(_DWORD *result, int a2)
{
  int v2; // r4
  int v3; // r4
  const char *v4; // r5
  _DWORD v5[7]; // [sp+4h] [bp-1Ch] BYREF

  if ( result )
  {
    dword_7D714 = 0;
    if ( a2 == 1 )
    {
      v3 = *(_DWORD *)(dword_7DBB4 + 224);
    }
    else
    {
      if ( a2 != 2 )
      {
        v2 = dword_7DBB0 + 60;
LABEL_7:
        sub_2B2B0(v5, *(_DWORD *)(dword_7DBB8 + 12));
        v4 = (const char *)sub_317CC(v2, 4);
        free((void *)dword_7D69C);
        dword_7D69C = (int)sub_174F8(v4);
        return sub_2AA40(v5);
      }
      v3 = *(_DWORD *)(dword_7DBB4 + 240);
    }
    v2 = v3 + 4;
    goto LABEL_7;
  }
  return result;
}
// 317CC: using guessed type int __fastcall sub_317CC(_DWORD, _DWORD);
// 7D69C: using guessed type int dword_7D69C;
// 7D714: using guessed type int dword_7D714;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (0003199C) --------------------------------------------------------
_DWORD *sub_3199C()
{
  ++*((_DWORD *)off_7D4D0 + 1);
  return sub_318E0((_DWORD *)dword_7D6B4, 2);
}
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D6B4: using guessed type int dword_7D6B4;

//----- (000319C8) --------------------------------------------------------
int sub_319C8()
{
  int v0; // r4

  while ( 1 )
  {
    v0 = sub_30080();
    if ( v0 != 92 )
      break;
    if ( sub_30080() != 10 )
    {
      sub_2989C();
      return v0;
    }
    sub_3199C();
  }
  return v0;
}
// 30080: using guessed type int sub_30080(void);

//----- (000319FC) --------------------------------------------------------
int __fastcall sub_319FC(_DWORD *a1)
{
  dword_7D734 = 0;
  dword_7D698 = 0;
  dword_7D6D8 = 0;
  dword_7D6B4 = (int)a1;
  sub_318E0(a1, (int)a1);
  dword_7D714 = 0;
  return sub_306F0(1);
}
// 7D698: using guessed type int dword_7D698;
// 7D6B4: using guessed type int dword_7D6B4;
// 7D6D8: using guessed type int dword_7D6D8;
// 7D714: using guessed type int dword_7D714;
// 7D734: using guessed type int dword_7D734;

//----- (00031A54) --------------------------------------------------------
int __fastcall sub_31A54(const char *a1, int a2)
{
  int v2; // r4
  int v3; // r0
  int v4; // r5
  int v5; // r1
  int v6; // r0
  int v7; // r3
  int v9; // [sp+4h] [bp-1A4h]
  const char *v10; // [sp+8h] [bp-1A0h]
  struct __jmp_buf_tag *v12; // [sp+10h] [bp-198h]
  _DWORD v13[3]; // [sp+14h] [bp-194h] BYREF
  jmp_buf env; // [sp+20h] [bp-188h] BYREF

  v10 = (const char *)sub_2B310(a1);
  sub_2A67C(v10);
  sub_2B2DC(v13);
  v12 = *(struct __jmp_buf_tag **)(dword_7DBB0 + 36);
  v9 = 0;
  v2 = setjmp(env);
  if ( !v2 )
  {
    *(_DWORD *)(dword_7DBB0 + 36) = env;
    do
    {
      v3 = sub_319FC(0);
      v4 = v3;
      if ( v3 == -1 )
        break;
      if ( dword_7D734 )
        v5 = dword_7D704;
      else
        v5 = 0;
      if ( dword_7D734 )
        v5 = v5 == 0;
      v6 = sub_31D94(v3, ~(v5 ^ 1) & a2);
      v7 = v9;
      if ( v4 )
        v7 = v6;
      v9 = v7;
      sub_2AA40(v13);
    }
    while ( !dword_7D6B8 );
  }
  sub_2AA40(v13);
  sub_2A5FC();
  sub_295C0((int)v10);
  *(_DWORD *)(dword_7DBB0 + 36) = v12;
  if ( v2 )
    longjmp(v12, v2);
  return v9;
}
// 319FC: using guessed type int __fastcall sub_319FC(_DWORD);
// 7D6B8: using guessed type int dword_7D6B8;
// 7D704: using guessed type int dword_7D704;
// 7D734: using guessed type int dword_7D734;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (00031B70) --------------------------------------------------------
int __fastcall sub_31B70(int a1, int a2, int *a3, char a4)
{
  int v4; // r5
  const char *v5; // r4
  char v6; // r4
  const char **v7; // r7
  int v8; // r6
  _BYTE *i; // r1
  char *v10; // r0
  const char *v11; // t1
  _BYTE *v12; // r0
  char v13; // r0
  int v16; // [sp+8h] [bp-1A0h]
  int v20; // [sp+18h] [bp-190h]
  int v21; // [sp+1Ch] [bp-18Ch]
  jmp_buf env; // [sp+20h] [bp-188h] BYREF

  v20 = dword_7D6A8;
  v16 = dword_7DBB0;
  v21 = *(_DWORD *)(dword_7DBB0 + 36);
  v4 = setjmp(env);
  if ( !v4 )
  {
    *(_DWORD *)(v16 + 36) = env;
    dword_7D6A8 = *a3;
    dword_7D640 = (int)(a3 + 1);
    dword_7D720 = 0;
    if ( (char **)a1 == &off_63614 )
    {
      v5 = (const char *)a3[1];
      if ( !v5 )
      {
        v6 = 0;
LABEL_12:
        sub_2A2A4();
        *(_BYTE *)v16 = v6 | ferror_unlocked((FILE *)stdout);
        goto LABEL_13;
      }
      v7 = (const char **)(a3 + 2);
      if ( a3[2] )
      {
        v8 = dword_7DBB8;
        for ( i = *(_BYTE **)(dword_7DBB8 + 4); ; i = sub_2DA30(32, v10) )
        {
          v10 = sub_2D5C8(v5, (int)i);
          v11 = *v7++;
          v5 = v11;
          if ( !v11 )
            break;
        }
        v12 = sub_2DA30(0, v10);
        v5 = (const char *)sub_2B208((int)&v12[-*(_DWORD *)(v8 + 4)]);
      }
      v13 = sub_31A54(v5, a4 & 2);
    }
    else
    {
      v13 = (*(int (__fastcall **)(int, int *))(a1 + 4))(a2, a3);
    }
    v6 = v13;
    goto LABEL_12;
  }
LABEL_13:
  clearerr((FILE *)stdout);
  dword_7D6A8 = v20;
  *(_DWORD *)(v16 + 36) = v21;
  return v4;
}
// 31A54: using guessed type int __fastcall sub_31A54(_DWORD, _DWORD);
// 63614: using guessed type char *off_63614;
// 7D614: using guessed type int stdout;
// 7D640: using guessed type int dword_7D640;
// 7D6A8: using guessed type int dword_7D6A8;
// 7D720: using guessed type int dword_7D720;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (00031CF8) --------------------------------------------------------
void sub_31CF8()
{
  int v0; // r4
  char v1; // r8
  char *v2; // r7
  int *v3; // r6
  int v4; // r5
  int v6; // r0
  bool v7; // zf
  char v8; // r1

  v0 = dword_7DBB0;
  if ( !*(_DWORD *)(dword_7DBB0 + 52) )
    return;
  v1 = *(_BYTE *)dword_7DBB0;
  *(_DWORD *)(dword_7DBB0 + 52) = 0;
  v2 = (char *)(v0 + 139);
  v3 = (int *)(v0 + 212);
  v4 = 1;
  while ( !*++v2 )
  {
LABEL_15:
    ++v4;
    ++v3;
    if ( v4 == 65 )
      goto LABEL_6;
  }
  if ( !dword_7D6B8 )
  {
    v6 = *v3;
    v7 = v4 == 2;
    if ( v4 == 2 )
      v7 = v6 == 0;
    v8 = v7;
    if ( !v7 )
    {
      *v2 = v8;
      if ( v6 )
        sub_31A54();
    }
    goto LABEL_15;
  }
  *(_DWORD *)(v0 + 52) = v4;
LABEL_6:
  *(_BYTE *)v0 = v1;
}
// 31A54: using guessed type int sub_31A54(void);
// 7D6B8: using guessed type int dword_7D6B8;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (00031D94) --------------------------------------------------------
int __fastcall sub_31D94(int a1, int a2)
{
  int v4; // r3
  int (__fastcall *v5)(int, int); // r3
  int v6; // r4
  int v7; // r0
  int v8; // r5
  int v9; // r2
  int v10; // r0
  int *v11; // r1
  int v12; // r3
  int v13; // r2
  int v14; // r8
  int v15; // r0
  size_t v16; // r4
  void *v17; // r8
  char *v18; // r0
  char *v19; // r5

  if ( a1 )
  {
    sub_31CF8();
    v4 = *(_DWORD *)a1;
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v5 = (int (__fastcall *)(int, int))sub_35964;
        goto LABEL_6;
      case 1:
        v5 = (int (__fastcall *)(int, int))sub_35620;
        goto LABEL_6;
      case 2:
        v9 = dword_7DBB0;
        v10 = *(_DWORD *)(a1 + 12);
        v11 = (int *)dword_7DBB4;
        v12 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(dword_7DBB4 + 328) = v12;
        *(_DWORD *)(v9 + 16) = v12;
        v13 = dword_7D6CC;
        if ( dword_7D6CC )
        {
          v13 = dword_7D6CC - 1;
          v11[82] = v12 - (dword_7D6CC - 1);
        }
        sub_33A58(v10, v11, v13);
        sub_298E4(*(int **)(a1 + 12));
        v6 = sub_339A4(*(_DWORD *)(a1 + 12));
        if ( !v6 )
          v6 = sub_31D94(*(_DWORD *)(a1 + 8), a2 & 2);
        v8 = *(_DWORD *)(a1 + 12);
        if ( !v8 )
          goto LABEL_14;
        sub_2B138(0);
        goto LABEL_13;
      case 3:
      case 4:
        v5 = (int (__fastcall *)(int, int))sub_33B88;
LABEL_6:
        v6 = *(unsigned __int8 *)(dword_7DBB0 + 61);
        if ( *(_BYTE *)(dword_7DBB0 + 61) )
        {
          if ( (a2 & 2) != 0 )
            v6 = 0;
          else
            v6 = -1;
        }
        goto LABEL_10;
      case 5:
      case 6:
      case 7:
        v14 = v4 - 5;
        v6 = sub_31D94(
               *(_DWORD *)(a1 + 4),
               ((unsigned __int8)(((unsigned int)(v4 - 5) >> 1) - 1) | (unsigned __int8)a2) & 2);
        if ( (v6 == 0) == v14 || dword_7D6B8 )
          goto LABEL_29;
        v8 = *(_DWORD *)(a1 + 8);
        goto LABEL_36;
      case 8:
        v15 = sub_31D94(*(_DWORD *)(a1 + 4), 2);
        v6 = v15;
        if ( dword_7D6B8 )
          goto LABEL_29;
        if ( !v15 )
        {
          v7 = sub_31D94(*(_DWORD *)(a1 + 8), a2);
LABEL_11:
          v8 = v6;
          v6 = v7;
          goto LABEL_14;
        }
        v8 = *(_DWORD *)(a1 + 12);
        if ( v8 )
        {
LABEL_36:
          v6 = 0;
          v7 = sub_31D94(v8, a2);
          goto LABEL_11;
        }
        v6 = 0;
LABEL_14:
        *(_BYTE *)dword_7DBB0 = v6;
        break;
      case 9:
      case 0xA:
        v5 = (int (__fastcall *)(int, int))sub_33E14;
        goto LABEL_4;
      case 0xB:
        v5 = (int (__fastcall *)(int, int))sub_33EB0;
        goto LABEL_4;
      case 0xC:
        v5 = (int (__fastcall *)(int, int))sub_33C88;
LABEL_4:
        v6 = 0;
LABEL_10:
        v7 = v5(a1, a2);
        goto LABEL_11;
      case 0xE:
        ++*(_DWORD *)(dword_7DBB0 + 40);
        v16 = sub_2E87C(0, a1) + 4;
        v17 = sub_174DC(v16);
        dword_7D6C8 = (int)v17 + 4;
        dword_7D6D0 = (int)v17 + v16;
        sub_29AE4((int *)a1);
        v18 = sub_29D4C(*(const char **)(a1 + 8), 1);
        v19 = v18;
        if ( *((_DWORD *)v18 + 2) == 1 )
          sub_299F4(*((void **)v18 + 1));
        v6 = 0;
        *((_DWORD *)v19 + 2) = 1;
        *((_DWORD *)v19 + 1) = v17;
        v19[12] = 0;
        v8 = 0;
        ((void (*)(void))loc_2A270)();
        goto LABEL_14;
      default:
        v6 = sub_31D94(*(_DWORD *)(a1 + 4), 2) == 0;
LABEL_13:
        v8 = 0;
        goto LABEL_14;
    }
  }
  else
  {
    v6 = 0;
LABEL_29:
    v8 = 0;
  }
  sub_31CF8();
  if ( (v8 & v6) != 0 || (a2 & 1) != 0 )
    sub_29EE0(4);
  return *(unsigned __int8 *)dword_7DBB0;
}
// 31DB8: control flows out of bounds to 31DBC
// 7D6B8: using guessed type int dword_7D6B8;
// 7D6C8: using guessed type int dword_7D6C8;
// 7D6CC: using guessed type int dword_7D6CC;
// 7D6D0: using guessed type int dword_7D6D0;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00032080) --------------------------------------------------------
int __fastcall sub_32080(char *a1, unsigned int a2)
{
  unsigned int v3; // r4
  char *v4; // r3
  int v5; // r11
  char *i; // r10
  unsigned int v7; // r9
  int v8; // r9
  int v9; // r3
  int result; // r0
  unsigned int v11; // r7
  int v12; // r9
  unsigned int v13; // r2
  int v14; // r8
  void *v15; // r0
  void *v16; // r0
  _BOOL4 v17; // r2
  unsigned __int8 *v18; // r6
  const char *pw_dir; // r6
  size_t v20; // r0
  struct passwd *v21; // r0
  int v22; // r3
  _BYTE *v23; // r7
  int v24; // r8
  int v25; // r2
  int v26; // r3
  int v27; // r7
  ssize_t v28; // r1
  unsigned int v29; // r1
  int v30; // r8
  unsigned int v31; // r7
  unsigned __int8 *j; // r8
  unsigned __int8 *v33; // r2
  unsigned int v34; // r3
  int v35; // t1
  int v36; // r7
  char *v37; // r8
  __int64 v38; // r0
  int v39; // r0
  unsigned int v40; // r3
  int v41; // r1
  char *reject; // [sp+4h] [bp-A8h]
  int v43; // [sp+8h] [bp-A4h]
  int v44; // [sp+8h] [bp-A4h]
  int v45; // [sp+Ch] [bp-A0h]
  int v46; // [sp+Ch] [bp-A0h]
  _BOOL4 v47; // [sp+10h] [bp-9Ch]
  _DWORD v48[3]; // [sp+1Ch] [bp-90h] BYREF
  int pipedes[33]; // [sp+28h] [bp-84h] BYREF

  v3 = a2;
  v47 = (a2 & 0xC0) == 64;
  if ( (a2 & 4) != 0 )
  {
    v4 = (char *)&unk_68407;
    if ( (a2 & 0x20) == 0 )
      v4 = (char *)&unk_68406;
  }
  else
  {
    v4 = (char *)&unk_68408;
  }
  v5 = a2 & 2;
  reject = v4;
  if ( (a2 & 2) == 0 )
    goto LABEL_17;
  v3 = a2 & 0xFFFFFFFD;
  v5 = 0;
LABEL_7:
  if ( *a1 != 126 )
    goto LABEL_17;
  for ( i = a1; ; ++i )
  {
    v7 = (unsigned __int8)i[1];
    if ( !i[1] )
      break;
    if ( v7 == 129 )
      goto LABEL_17;
    if ( v7 > 0x81 )
    {
      if ( v7 == 131 )
        break;
      if ( v7 == 136 )
        goto LABEL_17;
    }
    else if ( v7 == 47 || v7 == 58 && (v3 & 4) != 0 )
    {
      break;
    }
  }
  i[1] = 0;
  if ( a1[1] )
  {
    v21 = getpwnam(a1 + 1);
    if ( !v21 )
    {
LABEL_43:
      i[1] = v7;
      goto LABEL_17;
    }
    pw_dir = v21->pw_dir;
  }
  else
  {
    pw_dir = (const char *)sub_2F2F4("HOME");
  }
  if ( !pw_dir || !*pw_dir )
    goto LABEL_43;
  i[1] = v7;
  v20 = strlen(pw_dir);
  sub_2D500((int)pw_dir, v20, 2, v3 & 0x11);
  a1 = i + 1;
LABEL_17:
  while ( 2 )
  {
    v8 = 0;
    v43 = dword_7DBB8;
    v9 = dword_7D6C4 - *(_DWORD *)(dword_7DBB8 + 4);
    while ( 1 )
    {
      v45 = v9;
      result = strcspn(&a1[v8], reject);
      v11 = result + v8;
      v12 = (unsigned __int8)a1[result + v8];
      if ( v12 )
      {
        v13 = ((unsigned int)~v12 >> 7) & 1;
        if ( v12 == 135 )
          v13 = 1;
        if ( v13 )
          ++v11;
      }
      if ( v11 )
      {
        v15 = (void *)sub_2D210(v11, dword_7D6C4);
        v16 = memcpy(v15, a1, v11);
        v17 = v47;
        result = (int)v16 + v11;
        if ( v5 )
          LOBYTE(v17) = 0;
        dword_7D6C4 = result;
        v14 = result - *(_DWORD *)(v43 + 4);
        if ( v45 >= v14 )
          v17 = 0;
        if ( v17 )
          result = sub_2A834(v45, result - *(_DWORD *)(v43 + 4), 0);
      }
      else
      {
        v14 = v45;
      }
      v18 = (unsigned __int8 *)&a1[v11 + 1];
      if ( v12 == 58 )
        goto LABEL_49;
      if ( v12 != 61 )
        break;
      if ( (v3 & 0x20) != 0 )
      {
        v18 = (unsigned __int8 *)&a1[v11];
        goto LABEL_45;
      }
      v3 |= 0x20u;
      ++reject;
LABEL_49:
      v22 = (unsigned __int8)a1[v11];
      a1 += v11;
      if ( v22 == 126 )
        goto LABEL_7;
      v18 = (unsigned __int8 *)a1;
LABEL_45:
      v8 = 0;
LABEL_46:
      v9 = v14;
      a1 = (char *)v18;
    }
    if ( v12 )
    {
      switch ( v12 )
      {
        case 129:
          ++v14;
          v8 = 1;
          goto LABEL_56;
        case 130:
          v18 = sub_32CE0((unsigned __int8 *)&a1[v11 + 1], v3 | v5);
          goto LABEL_54;
        case 131:
          return result;
        case 132:
          v23 = *(_BYTE **)(dword_7D63C + 4);
          ++*(_DWORD *)(dword_7DBB0 + 40);
          v44 = dword_7DBB8;
          v46 = dword_7D6C4 - *(_DWORD *)(dword_7DBB8 + 4);
          sub_2B2B0(v48, v46);
          if ( v23 )
          {
            if ( pipe(pipedes) < 0 )
              sub_2ABFC("can't create pipe: %m");
            v24 = sub_2CFB8(1);
            if ( !sub_2EDE0(v24, v23, 2) )
            {
              sub_2A248();
              close(pipedes[0]);
              if ( pipedes[1] != 1 )
              {
                sub_2B0FC(pipedes[1], 1, v25, v26);
                close(pipedes[1]);
              }
              *(_BYTE *)(dword_7DBB0 + 61) = 0;
              sub_2A454();
              sub_31D94(v23, 1);
            }
            close(pipedes[1]);
            v27 = pipedes[0];
          }
          else
          {
            v24 = 0;
            v27 = -1;
          }
          sub_2AA40(v48);
          while ( 2 )
          {
            if ( v27 >= 0 )
            {
              v28 = sub_60320(v27, pipedes, 0x80u);
              if ( v28 > 0 )
              {
                sub_2D500((int)pipedes, v28, ((v3 | v5) >> 7) & 1, (v3 | v5) & 0x11);
                continue;
              }
              close(v27);
              *(_BYTE *)(dword_7DBB0 + 1) = sub_2C8C0(v24);
            }
            break;
          }
          ((void (*)(void))loc_2A270)();
          v29 = dword_7D6C4;
          v40 = *(_DWORD *)(v44 + 4);
          while ( v29 > v40 && *(_BYTE *)(v29 - 1) == 10 )
            --v29;
          dword_7D6C4 = v29;
          v41 = v29 - v40;
          if ( (((unsigned __int8)v3 | (unsigned __int8)v5) & 0x80) == 0 )
            sub_2A834(v46, v41, 0);
          dword_7D63C = *(_DWORD *)dword_7D63C;
          goto LABEL_54;
        case 135:
          v18 = (unsigned __int8 *)&a1[v11];
          v30 = dword_7D6C4;
          v31 = *(_DWORD *)(v43 + 4);
          *(_BYTE *)(dword_7D6C4 - 1) = 0;
          for ( j = (unsigned __int8 *)(v30 - 2); ; j += ~v34 )
          {
            while ( *j != 134 )
              --j;
            v33 = j;
            do
            {
              v34 = j - v33;
              if ( v31 >= (unsigned int)v33 )
                break;
              v35 = *--v33;
            }
            while ( v35 == 129 );
            if ( (v34 & 1) == 0 )
              break;
          }
          v36 = (int)&j[-v31];
          sub_2A8A4(v36);
          dword_7D6C4 = (int)j;
          v37 = (char *)(j + 1);
          if ( (((unsigned __int8)v3 | (unsigned __int8)v5) & 0x11) != 0 )
            sub_2D644(v37, 0, 0);
          v38 = sub_2CECC((unsigned __int8 *)v37);
          v39 = sub_2D5F8(v38);
          if ( (((unsigned __int8)v3 | (unsigned __int8)v5) & 0x80) == 0 )
            sub_2A834(v36, v36 + v39, 0);
          goto LABEL_54;
        case 136:
          if ( v5 || memcmp(&a1[v11 + 1], &unk_67F9A, 5u) )
          {
            v5 ^= 0x80u;
            v8 = 0;
LABEL_56:
            if ( (v3 & 0x11) != 0 )
            {
              v18 = (unsigned __int8 *)&a1[v11];
              ++v8;
              ++v14;
            }
            goto LABEL_46;
          }
          v18 = sub_32CE0(v18 + 1, v3 | 0x80) + 1;
LABEL_54:
          a1 = (char *)v18;
          break;
        default:
          goto LABEL_45;
      }
      continue;
    }
    return result;
  }
}
// 32230: control flows out of bounds to 32234
// 321E8: masking with 0x1 was optimized away because r2.4 <= 0x1
// 32440: variable 'v25' is possibly undefined
// 32440: variable 'v26' is possibly undefined
// 31D94: using guessed type int __fastcall sub_31D94(_DWORD, _DWORD);
// 7D63C: using guessed type int dword_7D63C;
// 7D6C4: using guessed type int dword_7D6C4;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (00032618) --------------------------------------------------------
char *__fastcall sub_32618(unsigned __int8 *a1, unsigned __int8 *a2, int a3, unsigned int a4, int a5, char a6, char a7)
{
  int v10; // r10
  int v11; // r8
  unsigned __int8 *i; // r11
  int v13; // r3
  bool v14; // cc
  int v15; // r1
  int v16; // r7
  _BYTE *v17; // r0
  int v18; // r11
  char *v19; // r10
  int v20; // r3
  char *v21; // r4
  int v22; // r5
  char *v23; // r3
  int v24; // r5
  char *v25; // r11
  int *v26; // r2
  bool v28; // zf
  const char *v29; // r3
  int v30; // r6
  char *v31; // r4
  int v32; // r0
  char v33; // r3
  int v34; // r5
  unsigned int v35; // r4
  unsigned __int8 *v36; // r0
  int v37; // r0
  unsigned __int8 *j; // r3
  int v39; // r3
  int v40; // t1
  bool v41; // zf
  unsigned int v42; // r4
  char *v43; // r3
  char v44; // r2
  char *v45; // r5
  char *v46; // r0
  _BYTE *v47; // r1
  int v48; // r2
  char *v49; // r2
  int v50; // r3
  int v51; // t1
  char v52; // r0
  int v53; // t1
  int v54; // r3
  size_t v55; // r2
  int v56; // r5
  _BOOL4 v57; // r3
  _BYTE *v58; // r0
  int v59; // r5
  _BYTE *v60; // r0
  int v61; // r3
  int v62; // r6
  int v63; // r5
  char *v64; // r0
  int v66; // [sp+Ch] [bp-30h]
  char *v67; // [sp+10h] [bp-2Ch]
  char *v68; // [sp+14h] [bp-28h]
  unsigned int v69; // [sp+18h] [bp-24h]
  int v70; // [sp+1Ch] [bp-20h]
  int v71; // [sp+20h] [bp-1Ch]
  _BYTE *v72; // [sp+24h] [bp-18h]
  int v73; // [sp+28h] [bp-14h]
  int v74; // [sp+28h] [bp-14h]
  char *v75; // [sp+2Ch] [bp-10h]
  char *v76; // [sp+2Ch] [bp-10h]
  int v77; // [sp+34h] [bp-8h] BYREF

  v10 = dword_7D63C;
  v11 = a7 & 0x11;
  v69 = a4 - 13;
  if ( a4 - 13 <= 1 )
  {
    for ( i = a1; ; ++i )
    {
      v13 = *i;
      if ( !*i )
        break;
      if ( v13 == 47 )
      {
        *i = 0;
        goto LABEL_7;
      }
      if ( v13 == 129 && i[1] )
        ++i;
    }
    i = (unsigned __int8 *)*i;
  }
  else
  {
    i = 0;
  }
LABEL_7:
  v14 = a4 > 0xC;
  if ( a4 != 12 )
    v14 = a4 - 4 > 1;
  if ( v14 )
    v15 = 18;
  else
    v15 = 2;
  sub_32080(a1, v15);
  v77 = -1;
  v16 = dword_7DBB8;
  if ( i )
  {
    v77 = dword_7D6C4 - (*(_DWORD *)(dword_7DBB8 + 4) + a3);
    dword_7D6C4 = (int)sub_2DA30(47, (_BYTE *)dword_7D6C4);
    sub_32080(i + 1, 2);
    *i = 47;
  }
  v17 = sub_2DA30(0, (_BYTE *)dword_7D6C4);
  v18 = *(_DWORD *)(v16 + 4);
  dword_7D6C4 = (int)v17;
  dword_7D63C = v10;
  v19 = (char *)(v18 + a5);
  if ( a4 == 5 )
  {
    sub_2AF84(a2, (const char *)(v18 + a5));
    dword_7D6C4 = v18 + a5;
  }
  else
  {
    if ( a4 == 12 )
    {
      v30 = v18 + a3;
      v31 = strchr((const char *)(v18 + a3), 58);
      if ( v31 )
        *v31 = 0;
      v32 = sub_2CF3C((unsigned __int8 *)(v18 + a3));
      if ( v31 )
        v33 = 58;
      v34 = v32;
      if ( v31 )
        *v31 = v33;
      v35 = a3 - a5 - 1;
      if ( (a7 & 0x11) != 0 )
      {
        for ( j = (unsigned __int8 *)(v18 + a5); (unsigned int)j < v30 - 1; ++j )
        {
          if ( *j == 129 )
          {
            ++j;
            --v35;
          }
        }
      }
      v36 = (unsigned __int8 *)(v30 + 1);
      if ( *(_BYTE *)(v18 + a3) == 58 )
        goto LABEL_56;
      do
      {
        v40 = *v36++;
        v39 = v40;
        v41 = v40 == 0;
        if ( v40 )
          v41 = v39 == 58;
      }
      while ( !v41 );
      if ( v39 == 58 )
LABEL_56:
        v37 = sub_2CF3C(v36);
      else
        v37 = v35;
      if ( v34 < 0 )
        v34 += v35;
      if ( v34 < v35 )
      {
        if ( v37 < 0 )
          v37 += v35 - v34;
      }
      else
      {
        v34 = 0;
        v37 = 0;
      }
      v42 = v35 - v34;
      v43 = (char *)(v18 + a5);
      if ( v42 >= v37 )
        v42 = v37;
      while ( v34 )
      {
        if ( (a7 & 0x11) != 0 && (unsigned __int8)*v43 == 129 )
          ++v43;
        ++v43;
        --v34;
      }
      while ( v42 )
      {
        if ( (a7 & 0x11) != 0 && (unsigned __int8)*v43 == 129 )
        {
          *v19 = -127;
          ++v43;
          ++v19;
        }
        v44 = *v43;
        --v42;
        ++v43;
        *v19++ = v44;
      }
      *v19 = 0;
    }
    else
    {
      if ( a4 == 4 )
      {
        v28 = v19 == 0;
        if ( !v19 )
          v19 = "parameter not set";
        v29 = (const char *)(dword_7DBB0 + 60);
        if ( !v28 && *a1 == 131 )
        {
          v19 = "parameter not set";
          if ( (a6 & 0x10) != 0 )
            v29 = " or null";
        }
        sub_2ABFC("%.*s: %s%s", a1 - a2 - 1, (const char *)a2, v19, v29);
      }
      v72 = &v17[-v18];
      v66 = 0;
      while ( 1 )
      {
LABEL_18:
        v20 = *(_DWORD *)(v16 + 4);
        dword_7D6C4 = (int)&v72[v20];
        v21 = (char *)(v20 + a5);
        if ( (a7 & 0x11) == 0 )
          v19 = (char *)(v20 + a5);
        v22 = v20 + a3;
        if ( (a7 & 0x11) != 0 )
        {
          v19 = sub_2D644((const char *)(v20 + a5), 9, 0);
          if ( v21 != v19 )
          {
            v22 = dword_7D6C4;
            v21 = (char *)(*(_DWORD *)(v16 + 4) + a5);
          }
        }
        v23 = (char *)(v22 - 1);
        v24 = *(_DWORD *)(v16 + 4);
        v67 = v23;
        v25 = (char *)(v24 + a3);
        if ( v66 )
          v26 = 0;
        else
          v26 = v77 >= 0 ? &v77 : 0;
        sub_2D644((const char *)(v24 + a3), 2, v26);
        v70 = dword_7D6C4;
        v71 = *(_DWORD *)(v16 + 4);
        if ( v69 > 1 )
          break;
        if ( !v66 )
        {
          v66 = dword_7DBB0 + 60;
          if ( v77 >= 0 )
          {
            v66 = (int)&v25[v77 + 1];
            v25[v77] = 0;
          }
        }
        if ( !*(_BYTE *)(v24 + a3) )
          return 0;
        v45 = 0;
        v68 = v25 - 1;
        while ( 1 )
        {
          if ( v21 >= v68 )
            goto LABEL_109;
LABEL_92:
          v46 = sub_2CE20((unsigned int)v21, v19, v67, v25, v11, 1);
          if ( !v46 )
            break;
          if ( a4 == 14 )
          {
            while ( v21 < v46 )
            {
              if ( (a7 & 0x11) != 0 && (unsigned __int8)*v21 == 129 )
                ++v21;
              ++v21;
              ++v19;
            }
          }
          else
          {
            v21 = v46;
          }
          v48 = v66 - 1;
          while ( 1 )
          {
            v51 = *(unsigned __int8 *)(v48 + 1);
            v49 = (char *)(v48 + 1);
            v50 = v51;
            if ( !v51 )
              break;
            v57 = v50 == 92;
            if ( (a7 & 0x11) == 0 )
              v57 = 0;
            v74 = *(_DWORD *)(v16 + 4);
            if ( v57 )
            {
              v75 = v49;
              v58 = sub_2DA30(129, (_BYTE *)dword_7D6C4);
              v49 = v75;
              ++v45;
              dword_7D6C4 = (int)v58;
            }
            v76 = v49;
            dword_7D6C4 = (int)sub_2DA30(*v49, (_BYTE *)dword_7D6C4);
            v48 = (int)v76;
            if ( *(_DWORD *)(v16 + 4) != v74 )
              goto LABEL_18;
            ++v45;
          }
          if ( a4 == 13 )
          {
            v19 = (char *)(v45 - v21);
            while ( 1 )
            {
              v45 = &v21[(_DWORD)v19];
              v53 = (unsigned __int8)*v21++;
              v52 = v53;
              if ( !v53 )
                break;
              v59 = *(_DWORD *)(v16 + 4);
              v60 = sub_2DA30(v52, (_BYTE *)dword_7D6C4);
              v61 = *(_DWORD *)(v16 + 4);
              dword_7D6C4 = (int)v60;
              if ( v61 != v59 )
                goto LABEL_18;
            }
LABEL_109:
            sub_2DA30(0, (_BYTE *)dword_7D6C4);
            v54 = *(_DWORD *)(v16 + 4);
            v19 = (char *)(v54 + a5);
            v55 = (size_t)(v45 + 1);
            v56 = (int)&v45[v54 + a5];
            memmove((void *)(v54 + a5), (const void *)(v54 + v70 - v71), v55);
            dword_7D6C4 = v56;
            return v19;
          }
        }
        v73 = *(_DWORD *)(v16 + 4);
        while ( 1 )
        {
          v47 = sub_2DA30(*v21, (_BYTE *)dword_7D6C4);
          dword_7D6C4 = (int)v47;
          if ( (a7 & 0x11) != 0 && (unsigned __int8)*v21 == 129 )
          {
            ++v45;
            dword_7D6C4 = (int)sub_2DA30(*++v21, v47);
          }
          if ( *(_DWORD *)(v16 + 4) != v73 )
            break;
          ++v21;
          ++v45;
          ++v19;
          if ( v68 <= v21 )
            goto LABEL_109;
          if ( *v25 != 42 )
            goto LABEL_92;
        }
      }
      v62 = a4 - 6;
      v63 = v62 >> 1;
      if ( (v62 & 1) == v62 >> 1 )
        v64 = sub_2CE20((unsigned int)v21, v19, v67, v25, v11, v63);
      else
        v64 = (char *)sub_2CDA4((unsigned __int8 *)v21, v19, (int)v67, v25, v11, v63);
      v19 = v64;
      if ( !v64 )
        return 0;
      if ( v63 )
      {
        v19 = &v21[v25 - v64 - 1];
        memmove(v21, v64, v25 - v64);
      }
      *v19 = 0;
    }
    dword_7D6C4 = (int)v19;
  }
  return v19;
}
// 32904: variable 'v33' is possibly undefined
// 32080: using guessed type int __fastcall sub_32080(_DWORD, _DWORD);
// 7D63C: using guessed type int dword_7D63C;
// 7D6C4: using guessed type int dword_7D6C4;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (00032CE0) --------------------------------------------------------
unsigned __int8 *__fastcall sub_32CE0(unsigned __int8 *a1, int a2)
{
  int v2; // r7
  unsigned int v3; // r6
  char *v5; // r10
  int v6; // r9
  int v7; // r8
  unsigned __int8 *v8; // r4
  int v9; // r0
  int v10; // r5
  unsigned __int8 *v12; // r2
  int v13; // lr
  int v14; // r3
  _DWORD *v15; // r12
  int v16; // r10
  int v17; // r0
  int v18; // [sp+14h] [bp-18h]
  int v19; // [sp+24h] [bp-8h] BYREF

  v2 = *a1;
  v3 = v2 & 0xF;
  if ( (v2 & 0xF) == 0 )
    sub_2B44C("bad substitution");
  v5 = (char *)(a1 + 1);
  v19 = a2 & 0x80;
  if ( (a2 & 0x80) != 0 )
  {
    if ( a1[1] == 64 )
    {
      v6 = *(_DWORD *)dword_7DBB4;
      if ( *(_DWORD *)dword_7DBB4 )
        v6 = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = 1;
  }
  v18 = dword_7DBB8;
  v7 = dword_7D6C4 - *(_DWORD *)(dword_7DBB8 + 4);
  v8 = (unsigned __int8 *)(strchr((const char *)a1 + 1, 61) + 1);
  while ( 1 )
  {
    v9 = sub_2F584(v5, v2, a2, &v19);
    v10 = v9;
    if ( (v2 & 0x10) != 0 )
      v10 = v9 - 1;
    if ( v3 == 3 )
    {
      v10 = ~v10;
LABEL_14:
      if ( v10 < 0 )
      {
        sub_32080(v8, a2 | 0x42);
        goto LABEL_16;
      }
LABEL_34:
      if ( !v6 )
        goto LABEL_16;
      goto LABEL_35;
    }
    if ( v3 == 2 )
      goto LABEL_14;
    if ( (unsigned __int8)(v3 - 4) > 1u )
      break;
    if ( v10 >= 0 )
      goto LABEL_34;
    sub_32618(v8, (unsigned __int8 *)v5, 0, v3, v7, v2, a2 & 0xEE);
    v2 &= 0xEFu;
    sub_2A8A4(v7);
  }
  if ( v10 < 0 && *(_BYTE *)(dword_7DBB0 + 73) )
    sub_2ABFC("%.*s: %s%s", v8 - (unsigned __int8 *)v5 - 1, v5, "parameter not set", (const char *)(dword_7DBB0 + 60));
  if ( v3 == 10 )
  {
    sub_2D5F8(v10 & ~(v10 >> 31));
  }
  else
  {
    if ( v3 == 1 )
    {
      if ( !v6 )
        return v8;
      goto LABEL_35;
    }
    if ( v10 < 0 )
      goto LABEL_28;
    dword_7D6C4 = (int)sub_2DA30(0, (_BYTE *)dword_7D6C4);
    v16 = dword_7D6C4 - *(_DWORD *)(v18 + 4);
    if ( !sub_32618(v8, 0, v16, v3, v7, v2, a2) )
      dword_7D6C4 = *(_DWORD *)(v18 + 4) + v16 - 1;
    sub_2A8A4(v7);
  }
  if ( !v6 )
    goto LABEL_28;
LABEL_35:
  sub_2A834(v7, dword_7D6C4 - *(_DWORD *)(v18 + 4), v19);
LABEL_16:
  if ( v3 == 1 )
    return v8;
LABEL_28:
  v12 = v8;
  v13 = 0;
  v14 = 1;
  v15 = (_DWORD *)dword_7D63C;
  while ( 1 )
  {
    v17 = *v12;
    ++v8;
    if ( v17 == 129 )
    {
      v8 = v12 + 2;
      goto LABEL_39;
    }
    if ( v17 == 132 )
    {
      if ( v10 >= 0 )
      {
        v15 = (_DWORD *)*v15;
        v13 = 1;
      }
      goto LABEL_39;
    }
    if ( v17 != 130 )
      break;
    v8 = v12 + 2;
    if ( (v12[1] & 0xF) != 1 )
      ++v14;
LABEL_39:
    v12 = v8;
  }
  if ( v17 != 131 )
    goto LABEL_39;
  if ( --v14 )
    goto LABEL_39;
  if ( v13 )
    dword_7D63C = (int)v15;
  return v8;
}
// 32080: using guessed type int __fastcall sub_32080(_DWORD, _DWORD);
// 7D63C: using guessed type int dword_7D63C;
// 7D6C4: using guessed type int dword_7D6C4;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (00032FC4) --------------------------------------------------------
_DWORD *__fastcall sub_32FC4(int a1, int a2, unsigned int a3)
{
  char v3; // r5
  int v6; // r2
  char *v7; // r0
  int v8; // r6
  _BYTE *v9; // r0
  int v10; // r0
  int v11; // r7
  unsigned __int8 *v12; // r4
  int *v13; // r9
  int v14; // r2
  int *v15; // r3
  int v16; // r8
  _BOOL4 v17; // r10
  unsigned __int8 *v18; // r6
  int v19; // r3
  _DWORD *v20; // r0
  int v21; // r5
  int v22; // r3
  unsigned __int8 *v24; // r5
  unsigned __int8 *v25; // r5
  int v26; // t1
  _DWORD *v28; // r0
  unsigned int v29; // r6
  unsigned __int8 *v30; // r5
  int v31; // r8
  const char *v32; // r0
  const char *v33; // r0
  int v34; // r3
  char *v35; // r0
  char *v36; // r7
  char *v37; // r0
  unsigned int v38; // r3
  _DWORD **v39; // r7
  char *v40; // r8
  int v41; // r2
  int v42; // r1
  _DWORD *i; // r3
  _DWORD *v44; // r0
  _DWORD *v45; // r0
  _DWORD *v46; // r3
  char *s; // [sp+4h] [bp-20h]
  char *sa; // [sp+4h] [bp-20h]
  int *v49; // [sp+8h] [bp-1Ch]
  int v50; // [sp+Ch] [bp-18h]
  int v51; // [sp+10h] [bp-14h]
  int c; // [sp+14h] [bp-10h]
  int ca; // [sp+14h] [bp-10h]
  void *ptr[2]; // [sp+18h] [bp-Ch] BYREF

  v3 = a3;
  v6 = *(_DWORD *)(a1 + 12);
  v7 = *(char **)(a1 + 8);
  dword_7D63C = v6;
  v8 = dword_7DBB8;
  dword_7D6C4 = *(_DWORD *)(dword_7DBB8 + 4);
  sub_32080(v7, a3);
  v9 = sub_2DA30(0, (_BYTE *)dword_7D6C4);
  dword_7D6C4 = (int)(v9 - 1);
  if ( !a2 )
    return sub_2A454();
  v10 = sub_2B208((int)&v9[-*(_DWORD *)(v8 + 4)]);
  v11 = v10;
  dword_7D6C0 = (int)&dword_7D6BC;
  v50 = v3 & 1;
  if ( (v3 & 1) != 0 )
  {
    if ( dword_7D6EC )
    {
      v12 = (unsigned __int8 *)v10;
      v13 = &dword_7D6DC;
      v14 = 0;
      if ( (*(_DWORD *)(dword_7DBB4 + 188) & 0x20) != 0 )
        v15 = (int *)" \t\n";
      else
        v15 = *(int **)(dword_7DBB4 + 192);
      if ( (*(_DWORD *)(dword_7DBB4 + 188) & 0x20) == 0 )
        ++v15;
      v49 = v15;
      while ( 1 )
      {
        v16 = v13[3];
        v17 = 0;
        if ( v16 )
          v15 = &dword_7DBB0;
        v18 = (unsigned __int8 *)(v11 + v13[1]);
        if ( v16 )
          v19 = *v15 + 60;
        else
          v19 = (int)v49;
        s = (char *)v19;
        v15 = (int *)(v16 | v14);
        v51 = v16 | v14;
        while ( (unsigned int)v18 < v11 + v13[2] )
        {
          if ( *v18 == 129 )
            v24 = v18 + 1;
          else
            v24 = v18;
          v26 = *v24;
          v25 = v24 + 1;
          c = v26;
          if ( strchr(s, v26) )
          {
            v15 = (int *)v51;
            if ( !v51 )
              v17 = strchr(" \t\n", c) != 0;
            if ( v18 == v12 && v17 )
            {
              v17 = v50;
LABEL_48:
              v12 = v25;
              goto LABEL_49;
            }
            *v18 = 0;
            v28 = sub_2C370(8u);
            v15 = &dword_7D6BC;
            v28[1] = v12;
            *(_DWORD *)dword_7D6C0 = v28;
            dword_7D6C0 = (int)v28;
            if ( v16 )
              goto LABEL_48;
            v12 = v25;
            v29 = v11 + v13[2];
            while ( v29 > (unsigned int)v12 )
            {
              v30 = *v12 == 129 ? v12 + 1 : v12;
              ca = *v30;
              if ( !strchr(s, ca) )
                break;
              if ( strchr(" \t\n", ca) )
              {
                v12 = v30 + 1;
              }
              else
              {
                if ( !v17 )
                  break;
                v12 = v30 + 1;
                v17 = 0;
              }
            }
            v25 = v12;
          }
LABEL_49:
          v18 = v25;
        }
        v13 = (int *)*v13;
        v14 = v16;
        if ( !v13 )
        {
          if ( !v16 )
            goto LABEL_19;
          goto LABEL_20;
        }
      }
    }
    v12 = (unsigned __int8 *)v10;
LABEL_19:
    if ( *v12 )
    {
LABEL_20:
      v20 = sub_2C370(8u);
      v20[1] = v12;
      *(_DWORD *)dword_7D6C0 = v20;
      dword_7D6C0 = (int)v20;
    }
    *(_DWORD *)dword_7D6C0 = 0;
    v21 = dword_7D6BC;
    dword_7D6C0 = (int)&dword_7D6BC;
    while ( 1 )
    {
      if ( !v21 )
        goto LABEL_23;
      v31 = dword_7DBB0;
      v32 = *(const char **)(v21 + 4);
      if ( !*(_BYTE *)(dword_7DBB0 + 62) )
        break;
LABEL_53:
      v33 = *(const char **)(v21 + 4);
      *(_DWORD *)dword_7D6C0 = v21;
      sub_2D644(v33, 0, 0);
      dword_7D6C0 = v21;
LABEL_54:
      v21 = *(_DWORD *)v21;
    }
    while ( 1 )
    {
      v37 = strpbrk(v32, accept);
      v36 = v37;
      if ( !v37 )
        goto LABEL_53;
      v38 = (unsigned __int8)*v37;
      if ( v38 == 92 )
        break;
      if ( v38 > 0x5C )
      {
        if ( v38 == 129 )
          break;
        if ( v38 != 136 )
          goto LABEL_69;
        while ( 1 )
        {
          v34 = (unsigned __int8)v36[1];
          v35 = v36 + 1;
          if ( v34 == 136 )
            break;
          if ( v34 == 129 )
            v36 += 2;
          else
            ++v36;
          if ( !*v36 )
            goto LABEL_53;
        }
      }
      else
      {
        if ( v38 != 91 || strchr(v37 + 1, 93) )
        {
LABEL_69:
          v39 = (_DWORD **)dword_7D6C0;
          ++*(_DWORD *)(v31 + 40);
          v40 = sub_2D644(*(const char **)(v21 + 4), 19, 0);
          sa = (char *)strlen(v40);
          ptr[1] = sa + 4096;
          ptr[0] = sub_1748C((size_t)(sa + 4096));
          sub_2E4E0((int)ptr, v40, (int)sa, 0);
          free(ptr[0]);
          if ( *(char **)(v21 + 4) != v40 )
            free(v40);
          ((void (*)(void))loc_2A270)();
          if ( v39 != (_DWORD **)dword_7D6C0 )
          {
            *(_DWORD *)dword_7D6C0 = 0;
            v42 = 0;
            for ( i = *v39; i; i = (_DWORD *)*i )
              ++v42;
            v44 = sub_29E1C(*v39, v42, v41);
            *v39 = v44;
            while ( *v44 )
              v44 = (_DWORD *)*v44;
            dword_7D6C0 = (int)v44;
            goto LABEL_54;
          }
          goto LABEL_53;
        }
        v35 = v36;
      }
LABEL_64:
      v32 = v35 + 1;
    }
    v35 = v37 + 1;
    if ( !v36[1] )
      goto LABEL_53;
    goto LABEL_64;
  }
  v45 = sub_2C370(8u);
  v46 = (_DWORD *)dword_7D6C0;
  v45[1] = v11;
  *v46 = v45;
  dword_7D6C0 = (int)v45;
LABEL_23:
  v22 = dword_7D6C0;
  *(_DWORD *)dword_7D6C0 = 0;
  if ( dword_7D6BC )
  {
    **(_DWORD **)(a2 + 4) = dword_7D6BC;
    *(_DWORD *)(a2 + 4) = v22;
  }
  return sub_2A454();
}
// 33098: variable 'v15' is possibly undefined
// 333C4: variable 'v41' is possibly undefined
// 7D63C: using guessed type int dword_7D63C;
// 7D6BC: using guessed type int dword_7D6BC;
// 7D6C0: using guessed type int dword_7D6C0;
// 7D6C4: using guessed type int dword_7D6C4;
// 7D6DC: using guessed type int dword_7D6DC;
// 7D6EC: using guessed type int dword_7D6EC;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (00033454) --------------------------------------------------------
int __fastcall sub_33454(int result, int a2)
{
  int v2; // r6
  int *v3; // r7
  int *v4; // r3
  int v5; // r3
  int v6; // r5
  int k; // r2
  int v8; // r4
  int v9; // r9
  size_t v10; // r0
  size_t v11; // r4
  int v12; // r2
  int v13; // r1
  int v14; // r3
  size_t v15; // r2
  int v16; // r0
  char *v17; // r1
  int v18; // r4
  int v19; // r9
  char *v20; // r0
  int v21; // r1
  char *v22; // r2
  int v23; // r1
  int v24; // r3
  _DWORD *i; // r11
  int j; // r11
  int v27; // r0
  int v28; // r0
  int v29; // r3
  int v30; // r0
  _UNKNOWN **v31; // r3
  bool v32; // zf
  int v34; // [sp+0h] [bp-6Ch] BYREF
  int fd; // [sp+4h] [bp-68h]
  int v36; // [sp+10h] [bp-5Ch]

  v3 = (int *)result;
  if ( result )
  {
    v4 = (int *)(*(_DWORD *)(dword_7DBB0 + 40) + 1);
    *(_DWORD *)(dword_7DBB0 + 40) = v4;
    if ( a2 )
      v4 = &dword_7DBB4;
    else
      v2 = 0;
    if ( a2 )
      v2 = *(_DWORD *)(*v4 + 20);
    while ( 1 )
    {
      v5 = *v3;
      v6 = v3[2];
      k = *v3 - 22;
      if ( (unsigned int)k > 1 )
        break;
      v8 = v3[3];
      if ( v6 != v8 )
      {
        v9 = -1;
        goto LABEL_53;
      }
LABEL_10:
      v3 = (int *)v3[1];
      if ( !v3 )
        return ((int (*)(void))loc_2A270)();
    }
    if ( (unsigned int)(v5 - 24) > 1 )
    {
      v19 = v3[5];
      switch ( v5 )
      {
        case 16:
        case 17:
          if ( !*(_BYTE *)(dword_7DBB0 + 70) )
            goto LABEL_48;
          if ( sub_62DFC() >= 0 )
          {
            if ( (v36 & 0xF000) == 0x8000 )
              goto LABEL_46;
            v8 = open64(v19, 1);
            if ( v8 < 0 )
              goto LABEL_47;
            if ( !sub_62E08() && (v36 & 0xF000) == 0x8000 )
            {
              close(v8);
LABEL_46:
              *(_DWORD *)dword_7DB94 = 17;
LABEL_47:
              v22 = sub_2DF6C(*(_DWORD *)dword_7DB94, (int)"nonexistent directory");
              sub_2ABFC("can't create %s: %s", v19, v22);
            }
          }
          else
          {
            v21 = 193;
LABEL_36:
            v8 = open64(v19, v21);
            if ( v8 < 0 )
              goto LABEL_47;
          }
          break;
        case 18:
LABEL_48:
          v21 = 577;
          goto LABEL_36;
        case 20:
          v21 = 66;
          goto LABEL_36;
        case 21:
          v21 = 1089;
          goto LABEL_36;
        default:
          v8 = open64(v3[5], 0);
          if ( v8 < 0 )
          {
            v20 = sub_2DF6C(*(_DWORD *)dword_7DB94, (int)"no such file");
            sub_2ABFC("can't open %s: %s", v19, v20);
          }
          goto LABEL_20;
      }
      goto LABEL_20;
    }
    if ( pipe(&v34) < 0 )
      sub_2ABFC("can't create pipe: %m");
    if ( *v3 == 24 )
    {
      v10 = strlen(*(const char **)(v3[3] + 8));
      v11 = v10;
      if ( v10 <= 0x1000 )
      {
        sub_17FB8(fd, *(char **)(v3[3] + 8), v10);
LABEL_19:
        close(fd);
        v8 = v34;
LABEL_20:
        if ( v6 == v8 )
        {
          if ( v2 )
          {
            v12 = 1;
            while ( 1 )
            {
              v13 = *(_DWORD *)(v2 + 8 * v12);
              if ( v13 == -2 )
                break;
              ++v12;
              if ( v6 == v13 )
                goto LABEL_10;
            }
            v14 = v2 + 8 * (v12 - 1);
            *(_DWORD *)(v14 + 8) = v6;
            *(_DWORD *)(v14 + 12) = -1;
          }
        }
        else
        {
          v9 = v8;
          while ( 1 )
          {
LABEL_53:
            v23 = v8 < 9 ? 9 : v8;
            if ( v6 == dword_7D4D4 )
            {
              dword_7D4D4 = sub_2B8B0(v6, v23);
LABEL_58:
              v24 = 1;
            }
            else
            {
              if ( v2 )
              {
                if ( v6 )
                {
                  for ( i = off_7D4D0; i; i = (_DWORD *)*i )
                  {
                    if ( v6 == i[2] )
                    {
                      i[2] = sub_2B8B0(v6, v23);
                      goto LABEL_58;
                    }
                  }
                }
                k = v2;
                for ( j = 0; ; ++j )
                {
                  v27 = *(_DWORD *)(k + 8);
                  if ( v27 == -2 )
                    break;
                  if ( v6 == *(_DWORD *)(k + 12) )
                  {
                    v30 = sub_2AAB8(v6, v23);
                    *(_DWORD *)(v2 + 8 * j + 12) = v30;
                    if ( v30 < 0 )
                      goto LABEL_79;
                    goto LABEL_63;
                  }
                  k += 8;
                  if ( v6 == v27 )
                    goto LABEL_63;
                }
                v28 = sub_2AAB8(v6, v23);
                if ( v28 < 0 && *(_DWORD *)dword_7DB94 != 9 )
LABEL_79:
                  sub_16E08();
                v29 = v2 + 8 * j;
                *(_DWORD *)(v29 + 12) = v28;
                *(_DWORD *)(v29 + 8) = v6;
                k = *(_DWORD *)(dword_7DBB4 + 24);
                if ( v6 == k )
                  *(_DWORD *)(dword_7DBB4 + 24) = v28;
              }
LABEL_63:
              v24 = 0;
            }
            if ( v8 == -1 )
              break;
            v31 = (_UNKNOWN **)dword_7D4D4;
            if ( v8 == dword_7D4D4 )
            {
LABEL_104:
              *(_DWORD *)dword_7DB94 = 9;
              sub_2ABFC("%d: %m", v8);
            }
            if ( v8 )
            {
              v31 = &off_7D4D0;
              while ( 1 )
              {
                v31 = (_UNKNOWN **)*v31;
                if ( !v31 )
                  break;
                k = (int)v31[2];
                if ( v8 == k )
                  goto LABEL_104;
              }
            }
            if ( v2 )
            {
              v31 = (_UNKNOWN **)v2;
              for ( k = 0; k < *(_DWORD *)(v2 + 4) && v31[2] != (_UNKNOWN *)-2; ++k )
              {
                v31 += 2;
                if ( (_UNKNOWN *)v8 == v31[1] )
                  goto LABEL_104;
              }
            }
            sub_2B0FC(v8, v6, k, (int)v31);
            if ( v9 >= 0 )
              close(v9);
            v8 = 1;
            v9 = -1;
            v32 = *v3 == 17;
            if ( *v3 == 17 )
              v32 = v6 == 1;
            v6 = 2;
            if ( !v32 )
              goto LABEL_10;
          }
          if ( !v24 )
            close(v6);
        }
        goto LABEL_10;
      }
    }
    else
    {
      v11 = 0;
    }
    if ( !sub_2EDE0(0, 0, 2) )
    {
      close(v34);
      sub_2A140((__sighandler_t)2);
      sub_2A140((__sighandler_t)3);
      sub_2A140((__sighandler_t)1);
      sub_2A140((__sighandler_t)0x14);
      signal(13, 0);
      if ( *v3 == 24 )
      {
        v15 = v11;
        v16 = fd;
        v17 = *(char **)(v3[3] + 8);
      }
      else
      {
        v18 = fd;
        sub_32FC4(v3[3], 0, 0x80u);
        v16 = v18;
        v17 = *(char **)(dword_7DBB8 + 4);
        v15 = dword_7D6C4 - (_DWORD)v17;
      }
      sub_17FB8(v16, v17, v15);
      exit(0);
    }
    goto LABEL_19;
  }
  return result;
}
// 33628: control flows out of bounds to 3362C
// 33540: variable 'v2' is possibly undefined
// 338CC: variable 'k' is possibly undefined
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D4D4: using guessed type int dword_7D4D4;
// 7D6C4: using guessed type int dword_7D6C4;
// 7DB94: using guessed type int dword_7DB94;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (000339A4) --------------------------------------------------------
int __fastcall sub_339A4(int a1)
{
  int v1; // r5
  int v2; // r4
  int v3; // r3
  int v6; // [sp+8h] [bp-194h]
  struct __jmp_buf_tag *v7; // [sp+Ch] [bp-190h]
  jmp_buf env; // [sp+10h] [bp-18Ch] BYREF

  v7 = *(struct __jmp_buf_tag **)(dword_7DBB0 + 36);
  v6 = *(_DWORD *)(dword_7DBB0 + 40);
  v1 = setjmp(env);
  v2 = dword_7DBB0;
  if ( !v1 )
  {
    *(_DWORD *)(dword_7DBB0 + 36) = env;
    sub_33454(a1, 1);
  }
  *(_DWORD *)(v2 + 36) = v7;
  if ( v1 && *(_DWORD *)(v2 + 56) != 1 )
    longjmp(v7, 1);
  v3 = dword_7DBB0;
  *(_DWORD *)(dword_7DBB0 + 40) = v6;
  if ( !*(_DWORD *)(v3 + 40) && *(_DWORD *)(v3 + 44) )
    sub_2A17C();
  return v1;
}
// 7DBB0: using guessed type int dword_7DBB0;

//----- (00033A58) --------------------------------------------------------
int __fastcall sub_33A58(int result, int *a2, int a3)
{
  int *v3; // r4
  int v4; // r3
  int v5; // r5
  bool v6; // zf
  int v7; // [sp+0h] [bp-Ch] BYREF
  int *v8; // [sp+4h] [bp-8h]
  int v9; // [sp+8h] [bp-4h]

  v7 = result;
  v8 = a2;
  v9 = a3;
  v3 = (int *)result;
  while ( v3 )
  {
    v4 = *v3;
    v7 = 0;
    v8 = &v7;
    switch ( v4 )
    {
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
        result = (int)sub_32FC4(v3[4], (int)&v7, 0xAu);
        goto LABEL_5;
      case 22:
      case 23:
        result = v3[4];
        if ( !result )
          goto LABEL_6;
        sub_32FC4(result, (int)&v7, 3u);
        if ( !v7 )
          goto LABEL_9;
        v5 = *(_DWORD *)(v7 + 4);
        result = sub_29594(v5);
        if ( result )
        {
          result = sub_18990((const char *)v5, 0, (char *)0xA);
          v6 = result == 0;
          if ( result >= 0 )
            v6 = *(_DWORD *)dword_7DB94 == 0;
          if ( v6 )
          {
            v3[3] = result;
          }
          else
          {
            if ( *(_BYTE *)v5 != 45 || *(_BYTE *)(v5 + 1) )
              sub_2B44C("bad fd number");
            v3[3] = -1;
          }
        }
        else
        {
          if ( v3[2] != 1 )
LABEL_9:
            sub_2ABFC("redir error");
          *v3 = 17;
LABEL_5:
          v3[5] = *(_DWORD *)(v7 + 4);
        }
LABEL_6:
        v3 = (int *)v3[1];
        break;
      default:
        goto LABEL_6;
    }
  }
  return result;
}
// 33A8C: control flows out of bounds to 33A90
// 7DB94: using guessed type int dword_7DB94;

//----- (00033B88) --------------------------------------------------------
int __fastcall sub_33B88(int *a1, int a2)
{
  int v4; // r7
  int *v5; // r1
  int v6; // r3
  int v7; // r2
  int v8; // r6
  bool v9; // zf
  int v10; // r0
  int v11; // r0
  int v12; // r4

  v4 = dword_7DBB0;
  v5 = (int *)dword_7DBB4;
  v6 = a1[1];
  v7 = dword_7D6CC;
  v8 = *a1;
  *(_DWORD *)(dword_7DBB4 + 328) = v6;
  v9 = v7 == 0;
  *(_DWORD *)(v4 + 16) = v6;
  if ( v7 )
    --v7;
  v10 = a1[3];
  if ( !v9 )
    v5[82] = v6 - v7;
  sub_33A58(v10, v5, v7);
  if ( v8 == 3 || (a2 & 1) == 0 || *(_BYTE *)(v4 + 204) )
  {
    ++*(_DWORD *)(v4 + 40);
    v4 = sub_2CFB8(1);
    v11 = sub_2EDE0(v4, a1, v8 == 3);
    if ( v11 )
      goto LABEL_15;
    ((void (*)(void))loc_2A270)();
    if ( v8 == 3 )
      a2 &= ~2u;
    else
      a2 |= 1u;
    if ( v8 == 3 )
      a2 |= 1u;
  }
  sub_33454(a1[3], 0);
  v11 = sub_31D94(a1[2], a2);
LABEL_15:
  if ( v8 == 3 )
  {
    v12 = 0;
  }
  else
  {
    v11 = sub_2C8C0(v4);
    v12 = v11;
  }
  ((void (__fastcall *)(int))loc_2A270)(v11);
  return v12;
}
// 31D94: using guessed type int __fastcall sub_31D94(_DWORD, _DWORD);
// 7D6CC: using guessed type int dword_7D6CC;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00033C88) --------------------------------------------------------
int __fastcall sub_33C88(_DWORD *a1, int a2)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r0
  _DWORD *v7; // r4
  _DWORD *i; // r5
  const char *v9; // r11
  char *v10; // r0
  int v11; // r9
  char *v12; // r0
  int v13; // r9
  int v14; // r4
  int v16; // r0
  _DWORD v18[2]; // [sp+8h] [bp-24h] BYREF
  _DWORD v19[3]; // [sp+10h] [bp-1Ch] BYREF
  _DWORD v20[3]; // [sp+1Ch] [bp-10h] BYREF

  v3 = dword_7DBB4;
  v4 = dword_7DBB0;
  v5 = a1[1];
  *(_DWORD *)(dword_7DBB4 + 328) = v5;
  *(_DWORD *)(v4 + 16) = v5;
  if ( dword_7D6CC )
    *(_DWORD *)(v3 + 328) = v5 - (dword_7D6CC - 1);
  sub_2B2DC(v19);
  v18[0] = 0;
  v6 = a1[2];
  v18[1] = v18;
  sub_32FC4(v6, (int)v18, 2u);
  v7 = (_DWORD *)a1[3];
LABEL_4:
  if ( !v7 || dword_7D6B8 )
    goto LABEL_13;
  for ( i = (_DWORD *)v7[2]; ; i = (_DWORD *)i[1] )
  {
    if ( !i )
    {
      v7 = (_DWORD *)v7[1];
      goto LABEL_4;
    }
    v9 = *(const char **)(v18[0] + 4);
    sub_2B2DC(v20);
    v10 = (char *)i[2];
    dword_7D63C = i[3];
    v11 = dword_7DBB8;
    dword_7D6C4 = *(_DWORD *)(dword_7DBB8 + 4);
    sub_32080(v10, 0x12u);
    if ( *(_DWORD *)(v11 + 8) == dword_7D6C4 )
      dword_7D6C4 = sub_2DA0C();
    *(_BYTE *)dword_7D6C4 = 0;
    sub_2A454();
    v12 = sub_2D644(*(const char **)(v11 + 4), 2, 0);
    v13 = fnmatch(v12, v9, 0);
    sub_2AA40(v20);
    if ( !v13 )
      break;
  }
  if ( dword_7D6B8 || (v16 = v7[3]) == 0 )
LABEL_13:
    v14 = 0;
  else
    v14 = sub_31D94(v16, a2);
  sub_2AA40(v19);
  return v14;
}
// 31D94: using guessed type int __fastcall sub_31D94(_DWORD, _DWORD);
// 7D63C: using guessed type int dword_7D63C;
// 7D6B8: using guessed type int dword_7D6B8;
// 7D6C4: using guessed type int dword_7D6C4;
// 7D6CC: using guessed type int dword_7D6CC;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (00033E14) --------------------------------------------------------
int __fastcall sub_33E14(_DWORD *a1, char a2)
{
  int v3; // r8
  int v4; // r6
  int v5; // r5
  int v6; // r0

  v3 = a2 & 2;
  v4 = 0;
  ++dword_7D710;
  while ( 1 )
  {
    v5 = sub_31D94(a1[1], 2);
    v6 = sub_29804();
    if ( v6 == 4 )
    {
      v4 = v5;
      goto LABEL_8;
    }
    if ( !v6 )
      break;
LABEL_8:
    if ( (v6 & 0xFFFFFFFD) != 0 )
      goto LABEL_9;
  }
  if ( *a1 != 9 )
    v5 = v5 == 0;
  if ( !v5 )
  {
    v4 = sub_31D94(a1[2], v3);
    v6 = sub_29804();
    goto LABEL_8;
  }
LABEL_9:
  --dword_7D710;
  return v4;
}
// 31D94: using guessed type int __fastcall sub_31D94(_DWORD, _DWORD);
// 7D710: using guessed type int dword_7D710;

//----- (00033EB0) --------------------------------------------------------
int __fastcall sub_33EB0(int a1, char a2)
{
  int v3; // r1
  int v5; // r3
  int v6; // r2
  int v7; // r4
  int v8; // r8
  int **v9; // r6
  int **v11; // [sp+4h] [bp-14h] BYREF
  int **v12; // [sp+8h] [bp-10h]
  _DWORD v13[3]; // [sp+Ch] [bp-Ch] BYREF

  v3 = dword_7DBB4;
  v5 = *(_DWORD *)(a1 + 4);
  v6 = dword_7DBB0;
  *(_DWORD *)(dword_7DBB4 + 328) = v5;
  *(_DWORD *)(v6 + 16) = v5;
  if ( dword_7D6CC )
    *(_DWORD *)(v3 + 328) = v5 - (dword_7D6CC - 1);
  sub_2B2DC(v13);
  v7 = *(_DWORD *)(a1 + 8);
  v11 = 0;
  v12 = (int **)&v11;
  while ( v7 )
  {
    sub_32FC4(v7, (int)&v11, 3u);
    v7 = *(_DWORD *)(v7 + 4);
  }
  v8 = a2 & 2;
  *v12 = 0;
  v9 = v11;
  ++dword_7D710;
  while ( v9 )
  {
    sub_2AF84(*(unsigned __int8 **)(a1 + 16), (const char *)v9[1]);
    v7 = sub_31D94(*(_DWORD *)(a1 + 12), v8);
    if ( (sub_29804() & 0xFFFFFFFD) != 0 )
      break;
    v9 = (int **)*v9;
  }
  --dword_7D710;
  sub_2AA40(v13);
  return v7;
}
// 31D94: using guessed type int __fastcall sub_31D94(_DWORD, _DWORD);
// 7D6CC: using guessed type int dword_7D6CC;
// 7D710: using guessed type int dword_7D710;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00033FBC) --------------------------------------------------------
void __noreturn sub_33FBC()
{
  const char *v0; // r0
  _DWORD *v1; // [sp+0h] [bp-194h]
  int status; // [sp+4h] [bp-190h]
  jmp_buf env; // [sp+8h] [bp-18Ch] BYREF

  v1 = (_DWORD *)dword_7DBB0;
  status = *(unsigned __int8 *)dword_7DBB0;
  if ( setjmp(env) )
  {
    if ( v1[14] == 4 )
      status = *(unsigned __int8 *)v1;
  }
  else
  {
    v0 = (const char *)v1[52];
    v1[9] = env;
    if ( v0 )
    {
      v1[52] = 0;
      dword_7D6B8 = 0;
      sub_31A54(v0, 0);
    }
  }
  sub_2B9D4(0);
  sub_2A2A4();
  exit(status);
}
// 7D6B8: using guessed type int dword_7D6B8;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (00034044) --------------------------------------------------------
int __fastcall sub_34044(char a1)
{
  int v1; // r4
  int v3; // r6
  int v4; // r5
  _DWORD *v5; // r0
  int v6; // r0
  char v7; // r3
  int v9; // r1
  int v10; // r0
  int v11; // [sp+4h] [bp-18h]
  _DWORD v12[4]; // [sp+Ch] [bp-10h] BYREF

  v1 = 0;
  v3 = 0;
  do
  {
    sub_2B2DC(v12);
    if ( dword_7D6B0 )
      sub_2CB60(12);
    v4 = dword_7DBB0;
    if ( *(_BYTE *)(dword_7DBB0 + 64) )
      v5 = (_DWORD *)(a1 & 1);
    else
      v5 = 0;
    v6 = sub_319FC(v5);
    if ( v6 == -1 )
    {
      v7 = a1 ^ 1;
      if ( v1 > 49 )
        v7 |= 1u;
      if ( (v7 & 1) != 0 )
        return v3;
      if ( !sub_2C2CC() )
      {
        if ( !*(_BYTE *)(v4 + 63) )
          return v3;
        sub_2C294((int)"\nUse \"exit\" to leave shell.\n");
      }
      ++v1;
    }
    else if ( !*(_BYTE *)(v4 + 66) )
    {
      v9 = *(unsigned __int8 *)(v4 + 66);
      v11 = v6;
      v1 = v9;
      *(int *)(v4 + 4) >>= 1;
      v10 = sub_31D94(v6, v9);
      if ( v11 )
        v3 = v10;
    }
    sub_2AA40(v12);
  }
  while ( !dword_7D6B8 );
  dword_7D6B8 &= ~4u;
  return v3;
}
// 7D6B0: using guessed type int dword_7D6B0;
// 7D6B8: using guessed type int dword_7D6B8;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (0003414C) --------------------------------------------------------
int sub_3414C()
{
  int v0; // r6
  char *v1; // r5
  const char *v2; // r0
  int *v3; // r4
  int v4; // r7
  int v5; // r7
  int v6; // r6
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int v10; // r2
  int i; // r3
  int v12; // t1
  int v13; // r5
  int v14; // r1
  int v15; // r2
  int v16; // r3
  const void *v18; // [sp+4h] [bp-70h] BYREF
  int v19; // [sp+8h] [bp-6Ch]
  int v20; // [sp+Ch] [bp-68h]
  int v21; // [sp+10h] [bp-64h]
  int v22; // [sp+14h] [bp-60h]
  int v23; // [sp+18h] [bp-5Ch]

  sub_2B480((unsigned __int8 *)(dword_7DBB0 + 60));
  v0 = dword_7D640;
  v1 = *(char **)dword_7D640;
  if ( !*(_DWORD *)dword_7D640 )
    return 2;
  v2 = *(const char **)dword_7D640;
  v3 = (int *)dword_7DBB4;
  v18 = (const void *)(*(_DWORD *)(dword_7DBB4 + 208) + 5);
  if ( !strchr(v2, 47) )
  {
    while ( 1 )
    {
      v4 = sub_2DB08(&v18, v1);
      if ( !v4 )
        sub_2ABFC("%s: not found", v1);
      if ( !sub_62DFC() && (v23 & 0xF000) == 0x8000 )
        break;
      if ( v1 != (char *)v4 )
        sub_295C0(v4);
    }
    v1 = (char *)v4;
  }
  v5 = v0 + 4;
  v6 = *(_DWORD *)(v0 + 4);
  if ( v6 )
  {
    v7 = v3[1];
    v8 = v3[2];
    v9 = v3[3];
    v19 = *v3;
    v20 = v7;
    v21 = v8;
    v22 = v9;
    v10 = v5;
    v23 = v3[4];
    *((_BYTE *)v3 + 12) = 0;
    for ( i = 1; ; ++i )
    {
      v12 = *(_DWORD *)(v10 + 4);
      v10 += 4;
      if ( !v12 )
        break;
    }
    *v3 = i;
    v3[4] = v5;
  }
  sub_2B338((int)v1, 1);
  dword_7D6A8 = (int)v1;
  v13 = sub_34044(0);
  sub_2A5FC();
  if ( v6 )
  {
    sub_299BC((int)v3);
    v14 = v20;
    v15 = v21;
    v16 = v22;
    *v3 = v19;
    v3[1] = v14;
    v3[2] = v15;
    v3[3] = v16;
    v3[4] = v23;
  }
  return v13;
}
// 7D640: using guessed type int dword_7D640;
// 7D6A8: using guessed type int dword_7D6A8;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (000342BC) --------------------------------------------------------
void __fastcall sub_342BC(const char *a1)
{
  int v1; // r0

  v1 = sub_317CC(a1, 1);
  if ( sub_2B338(v1, 3) >= 0 )
  {
    sub_34044(0);
    sub_2A5FC();
  }
}

//----- (000342E8) --------------------------------------------------------
void sub_342E8()
{
  int v0; // r4
  int v1; // r0
  int v2; // r1
  _DWORD *v3; // r0
  int v4; // r3

  v0 = dword_7D6D8;
  dword_7D6D8 = 0;
  while ( v0 )
  {
    sub_318E0((_DWORD *)dword_7D714, 2);
    v1 = sub_30080();
    if ( **(_DWORD **)(v0 + 4) == 24 )
      v2 = 2;
    else
      v2 = 1;
    sub_308C0(v1, v2, *(_DWORD *)(v0 + 8), *(_DWORD *)(v0 + 12));
    v3 = sub_2C370(0x10u);
    *v3 = 15;
    v3[2] = dword_7D738;
    v3[3] = dword_7D648;
    v4 = *(_DWORD *)(v0 + 4);
    v0 = *(_DWORD *)v0;
    *(_DWORD *)(v4 + 12) = v3;
  }
}
// 7D648: using guessed type int dword_7D648;
// 7D6D8: using guessed type int dword_7D6D8;
// 7D714: using guessed type int dword_7D714;
// 7D738: using guessed type int dword_7D738;

//----- (0003437C) --------------------------------------------------------
_DWORD *sub_3437C()
{
  int v0; // r5
  int v1; // r1
  _DWORD *v2; // r10
  int v3; // r1
  int v4; // r1
  int v5; // r0
  _DWORD *v6; // r6
  int v7; // r1
  int v8; // r4
  _DWORD *v9; // r0
  _DWORD *v10; // r4
  int v11; // r1
  int v12; // r1
  _DWORD *v13; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r1
  const char *v17; // r0
  _DWORD *v18; // r0
  int v19; // r1
  _DWORD *v20; // r0
  int v21; // r3
  _DWORD *v22; // r4
  bool v23; // zf
  _DWORD *v24; // r0
  _DWORD *v25; // r9
  _DWORD *v26; // r8
  _DWORD *v27; // r9
  _DWORD *v28; // r0
  int v29; // r1
  int v30; // r0
  int *v31; // r4
  int v32; // r4
  _DWORD *v33; // r0
  int v34; // r1
  int *v35; // r9
  int v36; // r3
  int *v37; // r7
  int v38; // r4
  int v39; // r11
  int v40; // r0
  int v41; // r0
  const char *v42; // r0
  char *v43; // r6
  int *v44; // r2
  unsigned __int8 *v45; // r0
  int *v46; // r3
  unsigned int v47; // r0
  int v48; // r0
  void *v49; // r4
  _BYTE **v50; // r0
  int v52; // r3
  _DWORD *v53; // [sp+0h] [bp-2Ch]
  int *v54; // [sp+0h] [bp-2Ch]
  int v55; // [sp+4h] [bp-28h]
  int v56; // [sp+8h] [bp-24h]
  _DWORD *v57; // [sp+14h] [bp-18h] BYREF
  int v58; // [sp+18h] [bp-14h] BYREF
  int v59; // [sp+1Ch] [bp-10h] BYREF
  int v60; // [sp+20h] [bp-Ch] BYREF
  int v61; // [sp+24h] [bp-8h] BYREF

  v58 = 0;
  v0 = *((_DWORD *)off_7D4D0 + 1);
  switch ( sub_304C4() )
  {
    case 2:
    case 3:
    case 22:
      v35 = &v59;
      v59 = 0;
      v36 = *((_DWORD *)off_7D4D0 + 1);
      v60 = 0;
      v61 = 0;
      v37 = &v61;
      v38 = 0;
      v39 = 0;
      v2 = 0;
      v56 = v36;
      dword_7D734 = 1;
      v55 = 1;
      v54 = &v60;
      do
      {
LABEL_66:
        while ( 2 )
        {
          while ( 1 )
          {
            dword_7D698 = v55;
            v40 = sub_304C4();
            if ( v40 <= 7 )
              break;
            if ( v40 == 9 )
              goto LABEL_96;
            if ( v40 != 22 )
              goto LABEL_70;
            v41 = sub_304C4();
            v38 = 1;
            dword_7D734 = 1;
            if ( v41 != 3 )
            {
LABEL_41:
              v5 = 3;
              goto LABEL_4;
            }
          }
          if ( v40 >= 6 )
          {
            if ( !v39 )
              goto LABEL_70;
            if ( v40 == 6 )
              v42 = "-a";
            else
              v42 = "-o";
            dword_7D738 = (int)v42;
          }
          else
          {
            if ( v40 == 2 )
            {
              v2 = (_DWORD *)dword_7D72C;
              *v37 = dword_7D72C;
              v37 = v2 + 1;
              sub_305AC();
              continue;
            }
            if ( v40 != 3 )
              goto LABEL_70;
          }
          break;
        }
        v2 = sub_2C370(0x10u);
        *v2 = 15;
        v43 = (char *)dword_7D738;
        v2[2] = dword_7D738;
        if ( !strcmp("[[", v43) )
        {
          v39 = 1;
        }
        else if ( !strcmp("]]", v43) )
        {
          v39 = 0;
        }
        v2[3] = dword_7D648;
        v44 = v2 + 1;
        if ( v55 && (v45 = sub_5871C((unsigned __int8 *)v43), v44 = v2 + 1, v43 != (char *)v45) && *v45 == 61 )
        {
          v46 = v54;
          v54 = v2 + 1;
          *v46 = (int)v2;
        }
        else
        {
          *v35 = (int)v2;
          v35 = v44;
          v55 = 0;
        }
      }
      while ( !v38 );
      dword_7D698 = 6;
      v47 = sub_304C4();
      dword_7D734 = 1;
      if ( v47 > 0x1C )
        goto LABEL_38;
      v48 = 1 << v47;
      if ( (v48 & 0x1CA04000) == 0 )
      {
        if ( (v48 & 0x200) != 0 )
        {
          v38 = v48 & 0x1CA04000;
          goto LABEL_66;
        }
        if ( (v48 & 8) == 0 || strcmp("[[", (const char *)dword_7D738) )
          goto LABEL_38;
      }
LABEL_96:
      if ( v59 && v35 == (int *)(v59 + 4) && !v60 && !v61 )
      {
        if ( !v38 && sub_304C4() != 10 )
        {
LABEL_52:
          v5 = 10;
          goto LABEL_4;
        }
        v49 = (void *)v2[2];
        if ( !*sub_5871C((unsigned __int8 *)v49) )
        {
          v50 = (_BYTE **)sub_2C3FC(v49);
          if ( !v50 || (**v50 & 1) == 0 )
          {
            *v2 = 14;
            dword_7D698 = 7;
            v2[1] = *((_DWORD *)off_7D4D0 + 1);
            v2[3] = sub_3437C();
            return v2;
          }
        }
        v17 = "bad function name";
LABEL_25:
        sub_2B44C(v17);
      }
LABEL_70:
      dword_7D734 = 1;
      *v35 = 0;
      *v54 = 0;
      *v37 = 0;
      v2 = sub_2C370(0x14u);
      v2[1] = v56;
      v2[3] = v59;
      v2[2] = v60;
      v2[4] = v61;
      break;
    case 9:
      v8 = 10;
      v2 = sub_2C370(0x10u);
      *v2 = 4;
      v2[1] = v0;
      v2[2] = sub_306F0(0, v34);
      goto LABEL_10;
    case 14:
      v2 = sub_2C370(0x10u);
      *v2 = 12;
      v2[1] = v0;
      if ( sub_304C4() != 3 )
        goto LABEL_41;
      v24 = sub_2C370(0x10u);
      v2[2] = v24;
      *v24 = 15;
      v24[2] = dword_7D738;
      v24[3] = dword_7D648;
      dword_7D698 = 7;
      if ( sub_304C4() != 24 )
      {
        v5 = 24;
        goto LABEL_4;
      }
      v25 = v2 + 3;
      while ( 1 )
      {
        dword_7D698 = 6;
        if ( sub_304C4() == 19 )
          break;
        if ( dword_7D704 == 9 )
          sub_304C4();
        v26 = sub_2C370(0x10u);
        *v25 = v26;
        *v26 = 13;
        v27 = v26 + 2;
        while ( 1 )
        {
          v28 = sub_2C370(0x10u);
          *v27 = v28;
          *v28 = 15;
          v57 = v28;
          v53 = v28;
          v28[2] = dword_7D738;
          v28[3] = dword_7D648;
          if ( sub_304C4() != 8 )
            break;
          v27 = v53 + 1;
          sub_304C4();
        }
        if ( dword_7D704 != 10 )
          goto LABEL_52;
        v25 = v26 + 1;
        v26[3] = sub_306F0(2, v29);
        dword_7D698 = 6;
        v30 = sub_304C4();
        if ( v30 == 19 )
          break;
        if ( v30 != 11 )
        {
          v5 = 11;
          goto LABEL_4;
        }
      }
      *v25 = 0;
      goto LABEL_57;
    case 21:
      if ( sub_304C4() != 3 || dword_7D728 || *sub_5871C((unsigned __int8 *)dword_7D738) )
      {
        v17 = "bad for loop variable";
        goto LABEL_25;
      }
      v2 = sub_2C370(0x14u);
      *v2 = 11;
      v2[1] = v0;
      v2[4] = dword_7D738;
      dword_7D698 = 7;
      if ( sub_304C4() == 24 )
      {
        v22 = &v57;
        while ( sub_304C4() == 3 )
        {
          v20 = sub_2C370(0x10u);
          v21 = dword_7D738;
          *v20 = 15;
          v20[2] = v21;
          v20[3] = dword_7D648;
          *v22 = v20;
          v22 = v20 + 1;
        }
        *v22 = 0;
        v2[2] = v57;
        v23 = dword_7D704 == 1;
        if ( dword_7D704 != 1 )
          v23 = dword_7D704 == 4;
        if ( !v23 )
        {
LABEL_38:
          v5 = -1;
          goto LABEL_4;
        }
      }
      else
      {
        v18 = sub_2C370(0x10u);
        *v18 = 15;
        v18[2] = &unk_67F99;
        v2[2] = v18;
        if ( dword_7D704 != 4 )
          dword_7D734 = 1;
      }
      dword_7D698 = 7;
      if ( sub_304C4() != 15 )
      {
LABEL_20:
        v5 = 15;
        goto LABEL_4;
      }
      v2[3] = sub_306F0(0, v19);
LABEL_22:
      v8 = 16;
LABEL_10:
      if ( sub_304C4() != v8 )
      {
        v5 = v8;
        goto LABEL_4;
      }
LABEL_57:
      v31 = &v58;
      dword_7D698 = 3;
      while ( sub_304C4() == 2 )
      {
        v52 = dword_7D72C;
        *v31 = dword_7D72C;
        v31 = (int *)(v52 + 4);
        sub_305AC();
      }
      dword_7D734 = 1;
      *v31 = 0;
      v32 = v58;
      if ( v58 )
      {
        if ( *v2 != 4 )
        {
          v33 = sub_2C370(0x10u);
          *v33 = 2;
          v33[1] = v0;
          v33[2] = v2;
          v2 = v33;
        }
        v2[3] = v32;
      }
      break;
    case 23:
      v2 = sub_2C370(0x10u);
      *v2 = 8;
      v2[1] = sub_306F0(0, v3);
      if ( sub_304C4() != 25 )
        goto LABEL_3;
      v6 = v2;
      v2[2] = sub_306F0(0, v4);
      while ( 2 )
      {
        if ( sub_304C4() == 17 )
        {
          v9 = sub_2C370(0x10u);
          v6[3] = v9;
          v10 = v9;
          *v9 = 8;
          v9[1] = sub_306F0(0, v11);
          if ( sub_304C4() == 25 )
          {
            v6 = v10;
            v10[2] = sub_306F0(0, v12);
            continue;
          }
LABEL_3:
          v5 = 25;
LABEL_4:
          sub_2E7E4(v5);
        }
        break;
      }
      if ( dword_7D704 == 18 )
      {
        v6[3] = sub_306F0(0, v7);
      }
      else
      {
        v6[3] = 0;
        dword_7D734 = 1;
      }
      v8 = 20;
      goto LABEL_10;
    case 26:
    case 27:
      v13 = sub_2C370(0xCu);
      v2 = v13;
      if ( dword_7D704 == 27 )
        v15 = 9;
      else
        v15 = 10;
      *v13 = v15;
      v13[1] = sub_306F0(0, v14);
      if ( sub_304C4() != 15 )
        goto LABEL_20;
      v2[2] = sub_306F0(0, v16);
      goto LABEL_22;
    case 28:
      v8 = 29;
      v2 = (_DWORD *)sub_306F0(0, v1);
      goto LABEL_10;
    default:
      goto LABEL_38;
  }
  return v2;
}
// 343A8: control flows out of bounds to 343AC
// 34430: variable 'v3' is possibly undefined
// 34454: variable 'v4' is possibly undefined
// 3447C: variable 'v7' is possibly undefined
// 344B4: variable 'v11' is possibly undefined
// 344D0: variable 'v12' is possibly undefined
// 3451C: variable 'v14' is possibly undefined
// 3453C: variable 'v16' is possibly undefined
// 3460C: variable 'v19' is possibly undefined
// 347A0: variable 'v29' is possibly undefined
// 34858: variable 'v34' is possibly undefined
// 3486C: variable 'v1' is possibly undefined
// 306F0: using guessed type int __fastcall sub_306F0(_DWORD, _DWORD);
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D648: using guessed type int dword_7D648;
// 7D698: using guessed type int dword_7D698;
// 7D704: using guessed type int dword_7D704;
// 7D728: using guessed type int dword_7D728;
// 7D72C: using guessed type int dword_7D72C;
// 7D734: using guessed type int dword_7D734;
// 7D738: using guessed type int dword_7D738;

//----- (00034BB8) --------------------------------------------------------
_DWORD *sub_34BB8()
{
  int v0; // r5
  int v1; // r0
  int v2; // r2
  int *v3; // r3
  _DWORD *v4; // r4
  _DWORD *v5; // r7
  _DWORD *v6; // r6
  _DWORD *v7; // r4
  _DWORD *v8; // r0

  v0 = 1;
  v1 = sub_304C4();
  if ( v1 == 13 )
  {
    v3 = &dword_7D698;
    v2 = 3;
  }
  else
  {
    v3 = &dword_7D734;
  }
  if ( v1 == 13 )
  {
    *v3 = v2;
  }
  else
  {
    *v3 = 1;
    v0 = 0;
  }
  v4 = sub_3437C();
  if ( sub_304C4() == 8 )
  {
    v5 = sub_2C370(0xCu);
    *v5 = 1;
    v6 = sub_2C370(8u);
    v5[2] = v6;
    v6[1] = v4;
    do
    {
      v7 = sub_2C370(8u);
      dword_7D698 = 7;
      v7[1] = sub_3437C();
      *v6 = v7;
      v6 = v7;
    }
    while ( sub_304C4() == 8 );
    *v7 = 0;
    v4 = v5;
  }
  dword_7D734 = 1;
  if ( v0 )
  {
    v8 = sub_2C370(8u);
    *v8 = 26;
    v8[1] = v4;
    return v8;
  }
  return v4;
}
// 34BD4: variable 'v2' is possibly undefined
// 7D698: using guessed type int dword_7D698;
// 7D734: using guessed type int dword_7D734;

//----- (00034C98) --------------------------------------------------------
void __fastcall sub_34C98(int a1)
{
  int v1; // r2
  bool v2; // zf
  void *v4; // r0
  void *v5; // r4
  void *v6; // r8
  int v7; // r5
  int v8; // r3
  void *v9; // r0
  int v10; // r2
  int v11; // r3
  int *v12; // r2
  int v13; // r3
  int *v14; // r1
  int v15; // t1
  void *v16; // r0
  void (__fastcall *v17)(unsigned __int8 *); // r2
  unsigned __int8 *v18; // r3
  unsigned __int8 *v19; // r0
  int v20; // r1
  int v21; // t1
  int savedregs; // [sp+0h] [bp+0h]
  int savedregs_16; // [sp+10h] [bp+10h]

  ++*(_DWORD *)(dword_7DBB0 + 40);
  v4 = (void *)dword_7D70C;
  v5 = *(void **)(dword_7D70C + 4);
  dword_7D70C = *(_DWORD *)dword_7D70C;
  free(v4);
  while ( v5 )
  {
    v6 = *(void **)v5;
    v7 = *((_DWORD *)v5 + 1);
    if ( a1 )
    {
      v8 = *((_DWORD *)v5 + 2);
      if ( v8 != 32 )
      {
        v9 = (void *)*((_DWORD *)v5 + 3);
        if ( *(void **)(v7 + 8) == v9 )
        {
          v10 = 12;
          goto LABEL_10;
        }
        if ( (v8 & 0x18) == 0 )
          free(v9);
      }
      v10 = 4;
LABEL_10:
      v11 = (*((_DWORD *)v5 + 2) ^ *(_DWORD *)(v7 + 4)) & v10 ^ *(_DWORD *)(v7 + 4);
      *(_DWORD *)(v7 + 4) = v11;
      if ( (v11 & 0x27) != 0x20 )
        goto LABEL_16;
      goto LABEL_11;
    }
    if ( v7 )
    {
      if ( *((_DWORD *)v5 + 2) == 32 )
      {
        *(_DWORD *)(v7 + 4) &= 0xFFFFFFF9;
LABEL_11:
        sub_2AF78(*(unsigned __int8 **)(v7 + 8));
        goto LABEL_16;
      }
      v17 = *(void (__fastcall **)(unsigned __int8 *))(v7 + 12);
      if ( v17 )
      {
        v18 = (unsigned __int8 *)*((_DWORD *)v5 + 3);
        do
        {
          v19 = v18;
          v21 = *v18++;
          v20 = v21;
          if ( !v21 )
            break;
          v19 = v18;
        }
        while ( v20 != 61 );
        v17(v19);
      }
      if ( (*(_DWORD *)(v7 + 4) & 0x18) == 0 )
        free(*(void **)(v7 + 8));
      *(_DWORD *)(v7 + 4) = *((_DWORD *)v5 + 2);
      *(_DWORD *)(v7 + 8) = *((_DWORD *)v5 + 3);
    }
    else
    {
      v12 = (int *)*((_DWORD *)v5 + 3);
      v13 = dword_7DBB0 + 61;
      v14 = v12 + 3;
      do
      {
        v15 = *v12++;
        *(_DWORD *)v13 = v15;
        v13 += 4;
      }
      while ( v12 != v14 );
      *(_WORD *)v13 = *(_WORD *)v12;
      *(_BYTE *)(v13 + 2) = *((_BYTE *)v12 + 2);
      free(*((void **)v5 + 3));
      sub_2BB6C();
    }
LABEL_16:
    v16 = v5;
    v5 = v6;
    free(v16);
  }
  v1 = dword_7DBB0;
  v2 = (*(_DWORD *)(dword_7DBB0 + 40))-- == 1;
  if ( v2 && *(_DWORD *)(v1 + 44) )
  {
    savedregs_16 = savedregs;
    sub_2A17C();
  }
}
// 2A298: variable 'savedregs' is possibly undefined
// 7D70C: using guessed type int dword_7D70C;
// 7DBB0: using guessed type int dword_7DBB0;

//----- (00034E1C) --------------------------------------------------------
int __fastcall sub_34E1C(_DWORD *a1, int a2, int a3, char a4)
{
  int v4; // r5
  int v5; // r3
  int v6; // r4
  int v7; // r6
  _DWORD *v8; // r4
  int v11; // [sp+8h] [bp-1B0h]
  int v15; // [sp+18h] [bp-1A0h]
  int v16; // [sp+1Ch] [bp-19Ch]
  int v17; // [sp+20h] [bp-198h]
  int v18; // [sp+24h] [bp-194h]
  int v19; // [sp+28h] [bp-190h]
  int v20; // [sp+2Ch] [bp-18Ch]
  jmp_buf env; // [sp+30h] [bp-188h] BYREF

  v16 = *(_DWORD *)dword_7DBB4;
  v17 = *(_DWORD *)(dword_7DBB4 + 4);
  v18 = *(_DWORD *)(dword_7DBB4 + 8);
  v19 = *(_DWORD *)(dword_7DBB4 + 12);
  v20 = *(_DWORD *)(dword_7DBB4 + 16);
  v11 = dword_7D6CC;
  v15 = *(_DWORD *)(dword_7DBB0 + 36);
  v4 = setjmp(env);
  v5 = dword_7DBB0;
  if ( !v4 )
  {
    ++*(_DWORD *)(dword_7DBB0 + 40);
    *(_DWORD *)(v5 + 36) = env;
    v6 = dword_7DBB4;
    *(_BYTE *)(dword_7DBB4 + 12) = 0;
    ++*a1;
    dword_7D6CC = a1[2];
    ((void (*)(void))loc_2A270)();
    *(_QWORD *)(v6 + 4) = 0xFFFFFFFF00000001LL;
    *(_DWORD *)v6 = a2 - 1;
    *(_DWORD *)(v6 + 16) = a3 + 4;
    sub_2A7EC();
    sub_31D94(a1[4], a4 & 2);
    sub_34C98(0);
  }
  v7 = dword_7DBB0;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  dword_7D6CC = v11;
  sub_299F4(a1);
  v8 = (_DWORD *)dword_7DBB4;
  sub_299BC(dword_7DBB4);
  *v8 = v16;
  v8[1] = v17;
  v8[2] = v18;
  v8[3] = v19;
  v8[4] = v20;
  *(_DWORD *)(v7 + 36) = v15;
  ((void (*)(void))loc_2A270)();
  dword_7D6B8 &= ~4u;
  return v4;
}
// 31D94: using guessed type int __fastcall sub_31D94(_DWORD, _DWORD);
// 7D6B8: using guessed type int dword_7D6B8;
// 7D6CC: using guessed type int dword_7D6CC;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00034F90) --------------------------------------------------------
void __fastcall sub_34F90(char *a1, int *a2, int a3, char *a4)
{
  int v7; // r3
  char *v8; // r3
  _BOOL4 v9; // r8
  char *v10; // r0
  char *v11; // r11
  int v12; // r2
  int v13; // r2
  _BYTE **v14; // r0
  int v15; // r3
  int *v16; // r2
  bool v17; // zf
  int v18; // r7
  int v19; // r0
  const char *v20; // r9
  char *v21; // r0
  _DWORD *v22; // r0
  _BYTE **v23; // r3
  unsigned __int8 *v24; // r10
  bool v25; // zf
  _BOOL4 v26; // r3
  int v27; // r3
  bool v28; // zf
  size_t v29; // r0
  char *v30; // r0
  char *v31; // r0
  int v32; // [sp+4h] [bp-90h]
  int i; // [sp+8h] [bp-8Ch]
  _BYTE **v34; // [sp+Ch] [bp-88h]
  _BOOL4 v35; // [sp+10h] [bp-84h]
  char *haystack; // [sp+14h] [bp-80h] BYREF
  _DWORD v37[3]; // [sp+1Ch] [bp-78h] BYREF
  int v38; // [sp+38h] [bp-5Ch]

  haystack = a4;
  if ( strchr(a1, 47) )
  {
    a2[1] = -1;
    if ( (a3 & 2) != 0 && sub_62DFC() < 0 )
LABEL_6:
      v7 = -1;
    else
      v7 = 0;
    *a2 = v7;
    return;
  }
  v8 = (char *)(*(_DWORD *)(dword_7DBB4 + 208) + 5);
  v9 = v8 == haystack;
  if ( v8 != haystack )
  {
    if ( strstr(haystack, "%builtin") )
      a3 |= 0x28u;
    else
      a3 |= 8u;
  }
  v10 = sub_29D4C(a1, 0);
  v11 = v10;
  if ( v10 )
  {
    v12 = *((_DWORD *)v10 + 2);
    if ( v12 == 1 )
    {
      v13 = 4;
    }
    else if ( v12 == 2 )
    {
      v13 = 32;
    }
    else
    {
      v13 = 8;
    }
    if ( (a3 & v13) != 0 )
    {
      v9 = 0;
      v11 = 0;
    }
    else if ( !v10[12] )
    {
      goto LABEL_60;
    }
  }
  v14 = (_BYTE **)sub_2C3FC(a1);
  v15 = (int)v14;
  v34 = v14;
  if ( !v14 )
    goto LABEL_23;
  if ( (**v14 & 2) != 0 )
    goto LABEL_42;
  if ( (a3 & 8) != 0 )
  {
    if ( (a3 & 0x20) != 0 )
      goto LABEL_23;
LABEL_42:
    if ( !v9 )
    {
      *a2 = 2;
      v23 = v34;
      goto LABEL_61;
    }
    ++*(_DWORD *)(dword_7DBB0 + 40);
    v11 = sub_29D4C(a1, 1);
    *((_DWORD *)v11 + 2) = 2;
    *((_DWORD *)v11 + 1) = v34;
LABEL_77:
    ((void (*)(void))loc_2A270)();
    goto LABEL_60;
  }
  if ( dword_7D4CC <= 0 )
    goto LABEL_42;
LABEL_23:
  if ( v11 && v11[12] )
  {
    v16 = (int *)*((_DWORD *)v11 + 2);
    v17 = v16 == (int *)2;
    if ( v16 == (int *)2 )
      v16 = &dword_7D4CC;
    else
      v15 = *((_DWORD *)v11 + 1);
    if ( v17 )
      v15 = *v16;
  }
  else
  {
    v15 = -1;
  }
  v18 = -1;
  v32 = v15;
  for ( i = 2; ; i = v27 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v19 = sub_2DB08((const void **)&haystack, a1);
        v20 = (const char *)v19;
        if ( !v19 )
        {
          if ( !v11 )
            v9 = 0;
          if ( v9 )
            sub_2A794();
          if ( (a3 & 1) != 0 )
          {
            v21 = sub_29D4C("command_not_found_handle", 0);
            if ( v21 && *((_DWORD *)v21 + 2) == 1 )
            {
              v22 = (_DWORD *)*((_DWORD *)v21 + 1);
              v37[0] = "command_not_found_handle";
              v37[1] = a1;
              v37[2] = 0;
              sub_34E1C(v22, 2, (int)v37, 0);
            }
            else
            {
              v31 = sub_2DF6C(i, (int)"not found");
              sub_2B9AC("%s: %s", a1, v31);
            }
          }
          goto LABEL_6;
        }
        sub_295C0(v19);
        ++v18;
        v24 = (unsigned __int8 *)dword_7D724;
        if ( !dword_7D724 )
          break;
        if ( sub_295E8((unsigned __int8 *)dword_7D724, (int)"builtin") )
        {
          if ( v34 )
            goto LABEL_42;
        }
        else if ( (a3 & 4) == 0 && sub_295E8(v24, (int)"func") )
        {
          break;
        }
      }
      v25 = v32 == v18;
      if ( v32 >= v18 )
        v25 = *v20 == 47;
      v26 = v25;
      v35 = v26;
      if ( !v25 )
        break;
      if ( v32 <= v18 )
        goto LABEL_60;
    }
    if ( sub_62DFC() >= 0 )
      break;
    v27 = i;
    v28 = *(_DWORD *)dword_7DB94 == 2;
    if ( *(_DWORD *)dword_7DB94 != 2 )
      v28 = *(_DWORD *)dword_7DB94 == 20;
    if ( !v28 )
      v27 = *(_DWORD *)dword_7DB94;
LABEL_66:
    ;
  }
  if ( (v38 & 0xF000) != 0x8000 )
  {
    v27 = 13;
    goto LABEL_66;
  }
  if ( !v24 )
  {
    if ( !v9 )
    {
      *a2 = 0;
      a2[1] = v18;
      return;
    }
    ++*(_DWORD *)(dword_7DBB0 + 40);
    v11 = sub_29D4C(a1, 1);
    *((_DWORD *)v11 + 1) = v18;
    *((_DWORD *)v11 + 2) = 0;
    goto LABEL_77;
  }
  v29 = strlen(v20);
  sub_2B208(v29 + 1);
  sub_2B338((int)v20, 1);
  sub_34044(v35);
  sub_2A5FC();
  v30 = sub_29D4C(a1, v35);
  v11 = v30;
  if ( !v30 || *((_DWORD *)v30 + 2) != 1 )
    sub_2ABFC("%s not defined in %s", a1, v20);
  sub_295C0((int)v20);
LABEL_60:
  v23 = (_BYTE **)*((_DWORD *)v11 + 1);
  v11[12] = 0;
  *a2 = *((_DWORD *)v11 + 2);
LABEL_61:
  a2[1] = (int)v23;
}
// 34044: using guessed type int __fastcall sub_34044(_DWORD);
// 7D4CC: using guessed type int dword_7D4CC;
// 7D724: using guessed type int dword_7D724;
// 7DB94: using guessed type int dword_7DB94;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (000353B0) --------------------------------------------------------
int __fastcall sub_353B0(int a1, char *a2, int a3)
{
  char *v3; // r5
  int v4; // r4
  const char *v5; // r0
  int v6; // r6
  const char *v8; // r1
  const char *v9; // r0
  unsigned __int8 **v10; // r6
  int v11; // r0
  int v12; // r0
  bool v13; // cf
  int *v14; // r3
  bool v15; // zf
  char *v16; // [sp+4h] [bp-10h] BYREF
  int v17; // [sp+8h] [bp-Ch] BYREF
  unsigned __int8 **v18; // [sp+Ch] [bp-8h]

  v16 = a2;
  v3 = (char *)a1;
  v4 = a3;
  if ( !a2 )
    a2 = (char *)(*(_DWORD *)(dword_7DBB4 + 208) + 5);
  v16 = a2;
  if ( a3 )
    sub_2F134(a1);
  if ( sub_2C428(v3) )
  {
    v5 = " is a shell keyword";
    if ( !v4 )
      v5 = v3;
    goto LABEL_8;
  }
  v6 = *sub_29CD0(v3);
  if ( v6 )
  {
    if ( !v4 )
    {
      sub_2F134((int)"alias ");
      sub_2D320(v6);
      return v4;
    }
    v8 = *(const char **)(v6 + 8);
    v9 = " is an alias for %s";
    goto LABEL_15;
  }
  sub_34F90(v3, &v17, 2, v16);
  switch ( v17 )
  {
    case 1:
      if ( v4 )
      {
        v5 = " is a shell function";
        goto LABEL_8;
      }
LABEL_25:
      v5 = v3;
LABEL_8:
      sub_2F134((int)v5);
LABEL_9:
      v4 = 0;
      sub_2F134((int)"\n");
      return v4;
    case 2:
      if ( v4 )
      {
        v9 = " is a %sshell builtin";
        v14 = (int *)**v18;
        v15 = ((unsigned __int8)v14 & 1) == 0;
        if ( ((unsigned __int8)v14 & 1) != 0 )
          v8 = "special ";
        else
          v14 = &dword_7DBB0;
        if ( v15 )
          v8 = (const char *)(*v14 + 60);
LABEL_15:
        sub_2BEA0(v9, v8);
        goto LABEL_9;
      }
      goto LABEL_25;
    case 0:
      v10 = v18;
      if ( (int)v18 >= 0 )
      {
        do
        {
          v11 = sub_2DB08((const void **)&v16, v3);
          v12 = sub_295C0(v11);
          v13 = v10 != 0;
          v10 = (unsigned __int8 **)((char *)v10 - 1);
        }
        while ( v13 );
        v3 = (char *)v12;
      }
      if ( v4 )
      {
        sub_2BEA0(" is %s", v3);
        goto LABEL_9;
      }
      goto LABEL_25;
  }
  if ( v4 )
    sub_2F134((int)": not found\n");
  return 127;
}
// 35458: variable 'v8' is possibly undefined
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00035554) --------------------------------------------------------
int __fastcall sub_35554(int a1, int a2)
{
  _BYTE *v2; // r3
  int v3; // r5
  int v4; // r4
  int *v5; // r4
  int i; // r6
  int v7; // r0
  int v8; // t1

  v2 = *(_BYTE **)(a2 + 4);
  if ( v2 && *v2 == 45 )
  {
    v3 = 0;
    v4 = 2;
  }
  else
  {
    v3 = 1;
    v4 = 1;
  }
  v5 = (int *)(a2 + 4 * v4);
  for ( i = 0; ; i |= sub_353B0(v7, 0, v3) )
  {
    v8 = *v5++;
    v7 = v8;
    if ( !v8 )
      break;
  }
  return i;
}

//----- (000355B0) --------------------------------------------------------
int sub_355B0()
{
  char *v0; // r4
  int v1; // r5
  int result; // r0

  v0 = 0;
  v1 = 0;
  while ( 1 )
  {
    result = sub_2B480("pvV");
    if ( !result )
      break;
    if ( result == 86 )
    {
      v1 = 2;
    }
    else if ( result != 118 )
    {
      v0 = (char *)"/bin:/usr/bin";
    }
  }
  if ( *(_DWORD *)dword_7D640 )
    return sub_353B0(*(_DWORD *)dword_7D640, v0, v1);
  return result;
}
// 7D640: using guessed type int dword_7D640;

//----- (00035620) --------------------------------------------------------
_DWORD *__fastcall sub_35620(int a1, int a2, int a3, int a4)
{
  _DWORD *v5; // r3
  int v6; // r0
  int v7; // r7
  int v8; // r9
  _DWORD *v9; // r4
  int v10; // r5
  _DWORD *v12; // r8
  int v13; // r3
  unsigned __int8 *v14; // r0
  int fd; // [sp+0h] [bp-10h] BYREF
  int v16; // [sp+4h] [bp-Ch]
  int v17[2]; // [sp+8h] [bp-8h] BYREF

  fd = a1;
  v16 = a2;
  v17[0] = a3;
  v17[1] = a4;
  v5 = *(_DWORD **)(a1 + 8);
  v6 = 0;
  while ( v5 )
  {
    ++v6;
    v5 = (_DWORD *)*v5;
  }
  v7 = a2 | 1;
  ++*(_DWORD *)(dword_7DBB0 + 40);
  v8 = sub_2CFB8(v6);
  v9 = *(_DWORD **)(a1 + 8);
  v10 = -1;
  while ( v9 )
  {
    v12 = (_DWORD *)v9[1];
    if ( !*v12 )
    {
      v13 = v12[3];
      if ( v13 )
      {
        v14 = sub_5871C(*(unsigned __int8 **)(v13 + 8));
        if ( !*v14 )
          sub_34F90(*(char **)(v12[3] + 8), v17, *v14, (char *)(*(_DWORD *)(dword_7DBB4 + 208) + 5));
      }
    }
    v16 = -1;
    if ( *v9 && pipe(&fd) < 0 )
    {
      close(v10);
      sub_2ABFC("can't create pipe: %m");
    }
    if ( !sub_2EDE0(v8, (_BYTE *)v9[1], *(_DWORD *)(a1 + 4)) )
    {
      ((void (*)(void))loc_2A270)();
      if ( v16 >= 0 )
        close(fd);
      if ( v10 > 0 )
      {
        dup2(v10, 0);
        close(v10);
      }
      if ( v16 > 1 )
      {
        dup2(v16, 1);
        close(v16);
      }
      sub_31D94(v9[1], v7);
    }
    if ( v10 >= 0 )
      close(v10);
    v10 = fd;
    if ( v16 != -1 )
      close(v16);
    v9 = (_DWORD *)*v9;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    v9 = (_DWORD *)sub_2C8C0(v8);
  ((void (*)(void))loc_2A270)();
  return v9;
}
// 31D94: using guessed type int __fastcall sub_31D94(_DWORD, _DWORD);
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (000357CC) --------------------------------------------------------
int sub_357CC()
{
  int v0; // r5
  char *v2; // r6
  char *v3; // r0
  int v4; // r3
  int **i; // r7
  int *j; // r4
  int *v7; // t1
  int v8; // r8
  const void **v9; // r3
  char *v10; // r2
  int *v11; // r3
  bool v12; // zf
  int v13; // [sp+4h] [bp-18h]
  const void **v14; // [sp+8h] [bp-14h]
  char *v15; // [sp+Ch] [bp-10h]
  int v16[2]; // [sp+10h] [bp-Ch] BYREF

  v0 = sub_2B480((unsigned __int8 *)"r");
  if ( v0 )
  {
    v0 = 0;
    sub_2A2CC(0);
  }
  else if ( *(_DWORD *)dword_7D640 )
  {
    while ( 1 )
    {
      v2 = *(char **)dword_7D640;
      if ( !*(_DWORD *)dword_7D640 )
        break;
      v3 = sub_29D4C(*(const char **)dword_7D640, 0);
      if ( v3 )
      {
        v4 = *((_DWORD *)v3 + 2);
        if ( !v4 || v4 == 2 && dword_7D4CC >= 0 )
          sub_2A794();
      }
      sub_34F90(v2, v16, 1, (char *)(*(_DWORD *)(dword_7DBB4 + 208) + 5));
      if ( v16[0] == -1 )
        v0 = 1;
      dword_7D640 += 4;
    }
  }
  else
  {
    for ( i = (int **)dword_7D6A4; (unsigned int)i < dword_7D6A4 + 124; ++i )
    {
      v7 = *i;
      for ( j = v7; j; j = (int *)*j )
      {
        if ( !j[2] )
        {
          v8 = j[1];
          v16[0] = *(_DWORD *)(dword_7DBB4 + 208) + 5;
          v9 = (const void **)v16;
          v10 = (char *)j + 13;
          do
          {
            v15 = v10;
            v14 = v9;
            v13 = sub_2DB08(v9, v10);
            sub_295C0(v13);
            --v8;
            v9 = v14;
            v10 = v15;
          }
          while ( v8 >= 0 );
          v11 = (int *)*((unsigned __int8 *)j + 12);
          v12 = v11 == 0;
          if ( *((_BYTE *)j + 12) )
            v10 = (char *)"*";
          else
            v11 = &dword_7DBB0;
          if ( v12 )
            v10 = (char *)(*v11 + 60);
          sub_2BEA0("%s%s\n", v13, v10, v11);
        }
      }
    }
  }
  return v0;
}
// 7D4CC: using guessed type int dword_7D4CC;
// 7D640: using guessed type int dword_7D640;
// 7D6A4: using guessed type int dword_7D6A4;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00035964) --------------------------------------------------------
int __fastcall sub_35964(int a1, char a2)
{
  int v3; // r2
  int v4; // r3
  int v5; // r4
  bool v6; // zf
  int v7; // r1
  int v8; // r0
  int v9; // r4
  const void *v10; // r0
  unsigned __int8 **v11; // r0
  int v12; // r5
  int v13; // r11
  int v14; // r0
  const char *v15; // r3
  char **v16; // r11
  _DWORD *v17; // r2
  int v18; // r1
  int v19; // r1
  int v20; // r0
  int *v21; // r8
  unsigned __int8 *v22; // r0
  const char *v23; // r2
  int v24; // r0
  char *v25; // r5
  int v26; // r6
  int v27; // r9
  int v28; // r9
  const char *v29; // r10
  const char *v30; // r0
  _DWORD *j; // r9
  const char *k; // r9
  int v33; // r2
  int v34; // r8
  int v35; // r5
  unsigned __int8 *v36; // r0
  unsigned int v37; // r2
  const char *i; // r2
  int v39; // r1
  _DWORD **v40; // r10
  int v41; // r10
  int v42; // r0
  const char *v43; // r0
  const char *v44; // r2
  const char *v45; // r0
  const char *v46; // r0
  const char *v47; // r0
  char **v48; // r3
  char *v49; // r2
  char **v50; // r1
  int v51; // r0
  unsigned __int8 *v52; // r12
  char *v53; // r2
  char **v54; // r3
  int v55; // t1
  int v56; // r4
  int v57; // r4
  _BOOL4 v59; // r3
  _BOOL4 v61; // r3
  int v62; // [sp+8h] [bp-4Ch]
  const char **v63; // [sp+8h] [bp-4Ch]
  const char *v64; // [sp+Ch] [bp-48h]
  unsigned __int8 *v65; // [sp+Ch] [bp-48h]
  int v67; // [sp+14h] [bp-40h]
  char *v68; // [sp+14h] [bp-40h]
  const char *v69; // [sp+14h] [bp-40h]
  int v70; // [sp+14h] [bp-40h]
  int v71; // [sp+18h] [bp-3Ch]
  int v72; // [sp+1Ch] [bp-38h]
  const char *v73; // [sp+20h] [bp-34h]
  const char *v74; // [sp+24h] [bp-30h]
  const char *v75; // [sp+2Ch] [bp-28h] BYREF
  const char **v76; // [sp+30h] [bp-24h]
  _DWORD *v77; // [sp+34h] [bp-20h] BYREF
  _DWORD **v78; // [sp+38h] [bp-1Ch]
  int v79; // [sp+3Ch] [bp-18h] BYREF
  char **v80; // [sp+40h] [bp-14h]
  _DWORD v81[4]; // [sp+44h] [bp-10h] BYREF

  v3 = dword_7D6CC;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = dword_7DBB0;
  v6 = dword_7D6CC == 0;
  v7 = dword_7DBB4;
  if ( dword_7D6CC )
    v3 = dword_7D6CC - 1;
  *(_DWORD *)(dword_7DBB4 + 328) = v4;
  *(_DWORD *)(v5 + 16) = v4;
  if ( !v6 )
    *(_DWORD *)(v7 + 328) = v4 - v3;
  sub_2B2DC(v81);
  v8 = sub_2A7EC();
  *(_BYTE *)(v5 + 1) = 0;
  v9 = *(_DWORD *)(a1 + 12);
  v79 = 2;
  v71 = v8;
  v77 = 0;
  v80 = (char **)&off_63714;
  v78 = &v77;
  v76 = &v75;
  v75 = 0;
  if ( v9 )
  {
    v10 = *(const void **)(v9 + 8);
    v9 = 0;
    v11 = (unsigned __int8 **)sub_2C3FC(v10);
    v12 = (int)v11;
    v13 = *(_DWORD *)(a1 + 12);
    if ( v11 )
      v12 = (**v11 >> 2) & 1;
    while ( v13 )
    {
      v63 = v76;
      if ( v12 && (v65 = *(unsigned __int8 **)(v13 + 8), v36 = sub_5871C(v65), v65 != v36) && *v36 == 61 )
        v37 = 4;
      else
        v37 = 3;
      sub_32FC4(v13, (int)&v75, v37);
      for ( i = *v63; i; i = *(const char **)i )
        ++v9;
      v13 = *(_DWORD *)(v13 + 4);
    }
  }
  v14 = sub_2B208(4 * (v9 + 2));
  v15 = v75;
  v16 = (char **)(v14 + 4);
  v17 = (_DWORD *)(v14 + 4);
  while ( v15 )
  {
    v39 = *((_DWORD *)v15 + 1);
    v15 = *(const char **)v15;
    *v17++ = v39;
  }
  v18 = dword_7DBB0;
  *v17 = 0;
  v62 = v18;
  v19 = *(unsigned __int8 *)(v18 + 64);
  if ( v19 )
  {
    v19 = v9;
    if ( v9 )
      v19 = 1;
    if ( dword_7D6CC )
      v19 = 0;
    if ( v19 )
      v15 = (const char *)*(v17 - 1);
  }
  v64 = v15;
  sub_33A58(*(_DWORD *)(a1 + 16), (int *)v19, (int)v17);
  v20 = sub_298E4(*(int **)(a1 + 16));
  v21 = (int *)dword_7DBB4;
  v72 = v20;
  *(_DWORD *)(dword_7DBB4 + 24) = 2;
  if ( *(_BYTE *)(v62 + 68) )
  {
    v22 = sub_2F2F4("BASH_XTRACEFD");
    if ( v22 )
    {
      if ( sub_2960C(v22) )
        v21[6] = atoi(v23);
    }
  }
  v24 = sub_339A4(*(_DWORD *)(a1 + 16));
  v25 = (char *)v21[52];
  v26 = v24;
  v27 = *(_DWORD *)(a1 + 8);
  while ( v27 )
  {
    v40 = v78;
    sub_32FC4(v27, (int)&v77, 4u);
    sub_2BBE4((*v40)[1]);
    v41 = (*v40)[1];
    v42 = sub_29638(v41, (int)v25);
    v27 = *(_DWORD *)(v27 + 4);
    if ( !v42 )
      v25 = (char *)v41;
  }
  if ( *(_BYTE *)(v62 + 68) )
  {
    v28 = v21[6];
    v29 = "";
    v30 = (const char *)sub_317CC((const char *)(v21[64] + 4), 1);
    dprintf(v28, "%s", v30);
    for ( j = v77; j; j = (_DWORD *)*j )
    {
      v69 = (const char *)j[1];
      v43 = (const char *)strchrnul(v69, 61);
      v44 = v69;
      if ( *v43 )
        ++v43;
      v74 = v69;
      v70 = v21[6];
      v73 = (const char *)(v43 - v44);
      v45 = sub_2D4B4(v43);
      dprintf(v70, "%s%.*s%s", v29, (int)v73, v74, v45);
      v29 = " ";
    }
    for ( k = v75; ; k = *(const char **)k )
    {
      v67 = v21[6];
      if ( !k )
        break;
      v6 = sub_2C428(*((const void **)k + 1)) == 0;
      v46 = (const char *)*((_DWORD *)k + 1);
      if ( v6 )
        v47 = sub_2D4B4(v46);
      else
        v47 = (const char *)sub_2D250(v46);
      dprintf(v67, "%s%s", v29, v47);
      v29 = " ";
    }
    sub_180F4(v21[6], (void *)"\n", 1u);
  }
  if ( !v9 )
  {
    if ( v26 )
    {
      *(_BYTE *)v62 = v26;
      goto LABEL_81;
    }
    v34 = -1;
LABEL_75:
    if ( v79 == 1 )
    {
      sub_34C98(1);
      sub_2C558(0, 0);
      v35 = sub_34E1C(v80, v9, (int)v16, a2);
      if ( v35 )
        goto LABEL_108;
      goto LABEL_106;
    }
    if ( v79 == 2 )
    {
      v35 = 0;
      goto LABEL_93;
    }
    if ( (a2 & 1) == 0 || *(_BYTE *)(v62 + 204) )
    {
      ++*(_DWORD *)(v62 + 40);
      v56 = sub_2CFB8(1);
      if ( sub_2EDE0(v56, (_BYTE *)a1, 0) )
      {
        v26 = sub_2C8C0(v56);
        ((void (*)(void))loc_2A270)();
LABEL_81:
        v35 = 0;
        goto LABEL_82;
      }
      sub_2A248();
    }
    sub_2ADC0(v77, 17);
    sub_2EF80(*v16, v16, v25, (int)v80);
  }
  v33 = 1;
  v34 = -1;
  v25 += 5;
  v68 = v25;
  while ( 1 )
  {
    sub_34F90(*v16, &v79, v33, v25);
    if ( v79 == -1 )
    {
      v35 = 0;
      v26 = 127;
      sub_2A2A4();
      goto LABEL_34;
    }
    if ( v79 != 2 )
    {
      if ( v26 )
      {
        v35 = 0;
LABEL_34:
        *(_BYTE *)v62 = v26;
        if ( v34 == 1 )
          sub_29EE0(1);
        goto LABEL_82;
      }
      goto LABEL_75;
    }
    if ( v34 == -1 )
      v34 = **v80 & 1;
    if ( v80 == &off_6361C )
    {
      v35 = 1;
      goto LABEL_112;
    }
    if ( v80 != &off_635FC )
      goto LABEL_114;
    v25 = v68;
    v48 = v16;
LABEL_62:
    v49 = v48[1];
    v50 = v48 + 1;
    if ( !v49 )
      goto LABEL_114;
    if ( *v49 == 45 )
    {
      v51 = (unsigned __int8)v49[1];
      v52 = (unsigned __int8 *)(v49 + 2);
      if ( v49[1] )
        break;
    }
LABEL_69:
    v33 = 5;
    v9 -= v50 - v16;
    v16 = v50;
  }
  if ( v51 == 45 && !v49[2] )
  {
    v53 = v48[2];
    v54 = v48 + 2;
    if ( !v53 )
      goto LABEL_114;
    v50 = v54;
    if ( !v54 )
      goto LABEL_114;
    goto LABEL_69;
  }
  while ( v51 == 112 )
  {
    v55 = *v52++;
    v51 = v55;
    v48 = v50;
    v25 = (char *)"/bin:/usr/bin";
    if ( !v55 )
      goto LABEL_62;
  }
LABEL_114:
  v35 = 0;
LABEL_112:
  if ( v26 )
    goto LABEL_34;
LABEL_93:
  v59 = v9 == 0;
  if ( v34 > 0 )
    v59 = 1;
  if ( v59 )
  {
    sub_34C98(1);
    if ( v9 > 1 ? v35 : 0 )
      sub_2ADC0(v77, 1);
  }
  sub_2C558(0, 0);
  if ( sub_31B70((int)v80, v9, (int *)v16, a2) )
  {
    v61 = *(_DWORD *)(v62 + 56) == 1;
    if ( v34 == 1 )
      v61 = 0;
    if ( v61 )
    {
      sub_2A248();
      goto LABEL_106;
    }
LABEL_108:
    longjmp(*(struct __jmp_buf_tag **)(dword_7DBB0 + 36), 1);
  }
LABEL_106:
  v26 = *(unsigned __int8 *)dword_7DBB0;
LABEL_82:
  if ( *(_DWORD *)(a1 + 16) )
    sub_2B138(v35);
  v57 = dword_7DBB4;
  while ( v72 != *(_DWORD *)(v57 + 20) )
    sub_2B138(0);
  while ( v71 != dword_7D70C )
    sub_34C98(0);
  if ( v64 )
    sub_2AF84("_", v64);
  sub_2AA40(v81);
  return v26;
}
// 35F18: masking with 0x1 was optimized away because r5.4 <= 0x1
// 35AC4: variable 'v23' is possibly undefined
// 13558: using guessed type int dprintf(_DWORD, const char *, ...);
// 13624: using guessed type int strchrnul(const char *, ...);
// 635FC: using guessed type char *;
// 6361C: using guessed type char *off_6361C;
// 7D6CC: using guessed type int dword_7D6CC;
// 7D70C: using guessed type int dword_7D70C;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;

//----- (00036054) --------------------------------------------------------
void __fastcall __noreturn sub_36054(int a1, unsigned __int8 **a2)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r0
  char *v4; // r4
  int *v5; // r2
  char *v6; // r3
  int v7; // r0
  int v8; // r5
  _DWORD *v9; // r2
  int v10; // r4
  int v11; // r4
  const char *v12; // r0
  unsigned __int8 *v13; // r0
  unsigned __int8 *v14; // r0
  char *v15; // r4
  int v16; // r4
  unsigned __int8 *v17; // r6
  unsigned __int8 *v18; // r7
  unsigned __int8 *v19; // r3
  bool v20; // zf
  int *v21; // r5
  int v22; // r8
  int v23; // t1
  int v24; // r0
  int *v25; // r3
  int v26; // r2
  int *v27; // r3
  int v28; // t1
  int v29; // r2
  unsigned __int8 *v30; // r0
  int v32; // [sp+10h] [bp-198h] BYREF
  _DWORD v33[3]; // [sp+14h] [bp-194h] BYREF
  jmp_buf env; // [sp+20h] [bp-188h] BYREF

  v2 = sub_174DC(0x1ECu);
  dword_7DBB0 = (int)v2;
  v2[6] = v2 + 15;
  v2[7] = v2 + 15;
  v2[117] = v2 + 52;
  v3 = sub_174DC(0x20Cu);
  dword_7DBB8 = (int)v3;
  *v3 = v3 + 4;
  v3[1] = v3 + 5;
  v3[3] = 504;
  v3[2] = v3 + 131;
  v4 = (char *)sub_174DC(0x160u);
  dword_7DBB4 = (int)v4;
  v5 = (int *)&unk_637D0;
  v6 = v4;
  do
  {
    v7 = *v5;
    v6 += 16;
    v5 += 3;
    *((_DWORD *)v6 + 43) = v7;
    *((_DWORD *)v6 + 44) = *(v5 - 2);
    *((_DWORD *)v6 + 45) = *(v5 - 1);
  }
  while ( v4 + 144 != v6 );
  *((_DWORD *)v4 + 72) = strcpy(v4 + 332, "LINENO=");
  dword_7D644 = (int)sub_174DC(0x9Cu);
  dword_7D6A4 = (int)sub_174DC(0x7Cu);
  dword_7D708 = (int)sub_5C3B4(19);
  v8 = setjmp(env);
  if ( v8 )
  {
    dword_7D6B8 = 0;
    dword_7D710 = 0;
    sub_2A454();
    v9 = off_7D4D0;
    *((_DWORD *)off_7D4D0 + 4) = 0;
    v9[3] = 0;
    while ( off_7D4D0 != &unk_7D64C )
      sub_2A5FC();
    v10 = dword_7DBB4;
    while ( *(_DWORD *)(v10 + 20) )
      sub_2B138(0);
    while ( dword_7D70C )
      sub_34C98(0);
    goto LABEL_9;
  }
  v16 = dword_7DBB0;
  *(_DWORD *)(dword_7DBB0 + 36) = env;
  v17 = (unsigned __int8 *)(v16 + 61);
  *(_DWORD *)(v16 + 8) = getpid();
  v18 = (unsigned __int8 *)(v16 + 61);
  sub_2F3A8();
  sub_2B2DC(v33);
  v19 = *a2;
  v20 = *a2 == 0;
  if ( *a2 )
    v8 = *v19;
  *(_DWORD *)(v16 + 32) = v19;
  if ( !v20 )
    v8 = v8 == 45;
  v32 = v8;
  do
    *v18++ = 2;
  while ( (unsigned __int8 *)(v16 + 76) != v18 );
  dword_7D640 = (int)(a2 + 1);
  if ( sub_2BEEC(1, &v32) )
    sub_29EE0(1);
  v21 = (int *)dword_7D640;
  v22 = *(_DWORD *)(v16 + 20);
  if ( !*(_DWORD *)dword_7D640 )
  {
    if ( v22 )
      sub_2ABFC("%s requires an argument", "-c");
    *(_BYTE *)(v16 + 67) = 1;
  }
  if ( (*(_DWORD *)(v16 + 64) & 0xFF0000FF) == 0x1000002 && isatty(0) && isatty(1) )
    *(_BYTE *)(v16 + 64) = 1;
  if ( *(_BYTE *)(v16 + 65) == 2 )
    *(_BYTE *)(v16 + 65) = *(_BYTE *)(v16 + 64);
  do
  {
    v23 = *v17++;
    if ( v23 == 2 )
      *(v17 - 1) = 0;
  }
  while ( v17 != v18 );
  v24 = *v21;
  if ( v22 )
  {
    *(_DWORD *)(v16 + 20) = v24;
    v25 = v21 + 1;
    if ( !v21[1] )
      goto LABEL_49;
  }
  else
  {
    if ( *(_BYTE *)(v16 + 67) )
    {
      v25 = v21;
      goto LABEL_49;
    }
    sub_2B338(v24, 0);
    v25 = v21;
  }
  v29 = *v25++;
  *(_DWORD *)(v16 + 32) = v29;
  dword_7D6A8 = v29;
LABEL_49:
  v26 = dword_7DBB4;
  *(_DWORD *)(dword_7DBB4 + 16) = v25;
  v27 = v25 - 1;
  *(_QWORD *)(v26 + 4) = 0xFFFFFFFF00000001LL;
  while ( 1 )
  {
    v28 = v27[1];
    ++v27;
    if ( !v28 )
      break;
    ++*(_DWORD *)v26;
  }
  sub_2BB6C();
  if ( v32 )
  {
    sub_342BC("/etc/profile");
    if ( sub_2F2F4("HOME") )
      sub_342BC("$HOME/.profile");
  }
  if ( *(_BYTE *)(dword_7DBB0 + 64) )
  {
    v30 = sub_2F2F4("ENV");
    if ( v30 )
    {
      if ( *v30 )
        sub_342BC((const char *)v30);
    }
  }
  sub_2AA40(v33);
  v11 = dword_7DBB0;
  v12 = *(const char **)(dword_7DBB0 + 20);
  if ( v12 )
    sub_31A54(v12, *(unsigned __int8 *)(dword_7DBB0 + 67) == 0);
  if ( *(_BYTE *)(v11 + 67) || !*(_DWORD *)(v11 + 20) )
  {
    if ( *(_BYTE *)(v11 + 64) )
    {
      v13 = sub_2F2F4("HISTFILE");
      if ( v13
        || (v14 = sub_2F2F4("HOME")) != 0
        && (++*(_DWORD *)(v11 + 40),
            v15 = sub_16998((const char *)v14, ".ash_history"),
            sub_2AF84("HISTFILE", v15),
            free(v15),
            ((void (*)(void))loc_2A270)(),
            (v13 = sub_2F2F4("HISTFILE")) != 0) )
      {
        *(_DWORD *)(dword_7D708 + 28) = v13;
      }
    }
    sub_34044(1);
  }
LABEL_9:
  sub_33FBC();
}
// 361D4: conditional instruction was optimized away because %var_19C.4==0
// 36230: conditional instruction was optimized away because r4.4==0
// 3626C: conditional instruction was optimized away because r4.4==0
// 3629C: conditional instruction was optimized away because r4.4==0
// 361D8: conditional instruction was optimized away because zf.1==1
// 7D4D0: using guessed type _UNKNOWN *off_7D4D0;
// 7D608: using guessed type int stderr;
// 7D640: using guessed type int dword_7D640;
// 7D644: using guessed type int dword_7D644;
// 7D6A4: using guessed type int dword_7D6A4;
// 7D6A8: using guessed type int dword_7D6A8;
// 7D6B8: using guessed type int dword_7D6B8;
// 7D708: using guessed type int dword_7D708;
// 7D70C: using guessed type int dword_7D70C;
// 7D710: using guessed type int dword_7D710;
// 7DBB0: using guessed type int dword_7DBB0;
// 7DBB4: using guessed type int dword_7DBB4;
// 7DBB8: using guessed type int dword_7DBB8;

//----- (000365CC) --------------------------------------------------------
const char *__fastcall sub_365CC(int a1, int a2, int a3, int *a4)
{
  int v4; // r8
  const char *v5; // r10
  int v6; // r7
  signed __int64 v10; // r4
  unsigned int v11; // r3
  bool v12; // cc
  unsigned __int64 i; // r2
  const char *v15; // r0
  signed __int64 v16; // r0
  bool v17; // zf
  bool v18; // zf
  bool v19; // zf
  bool v20; // zf
  bool v21; // cc
  bool v22; // zf
  bool v23; // nf
  char v24; // r2
  bool v25; // zf
  char v26; // r12
  char v27; // r2
  bool v28; // cc
  bool v29; // zf
  int v30; // r3
  bool v31; // zf
  bool v32; // zf
  int v33; // r12
  bool v34; // zf
  int v35; // r12
  bool v36; // zf
  char s[32]; // [sp+14h] [bp-20h] BYREF

  v4 = *a4;
  if ( *a4 == a3 )
    return "arithmetic syntax error";
  v6 = v4 - 24;
  v5 = sub_36DF4((int *)a1, v4 - 24, a3);
  if ( v5 )
    return v5;
  v10 = *(_QWORD *)(v4 - 24);
  if ( a2 != 17 )
  {
    if ( a2 == 48 )
    {
      LOBYTE(v10) = v10 == 0;
LABEL_17:
      v10 = (unsigned __int8)v10;
      goto LABEL_6;
    }
    if ( a2 == 16 )
    {
      i = ~v10;
LABEL_115:
      v10 = i;
      goto LABEL_6;
    }
    if ( (unsigned int)(a2 - 18) <= 1 )
    {
      ++v10;
      goto LABEL_6;
    }
    if ( (unsigned int)(a2 - 50) <= 1 )
    {
      --v10;
      goto LABEL_6;
    }
    if ( a2 == 49 )
      goto LABEL_6;
    if ( a3 == v6 )
      return "arithmetic syntax error";
    *a4 = v6;
    if ( a2 == 4 )
    {
      if ( !*(_BYTE *)(v4 - 8) )
        return "malformed ?: operator";
      v6 = v4 - 48;
    }
    else
    {
      if ( *(_BYTE *)(v4 - 8) )
        return "malformed ?: operator";
      v6 = v4 - 48;
      if ( a2 == 2 )
      {
LABEL_34:
        v16 = *(_QWORD *)(v4 - 48);
        if ( a2 == 4 )
        {
          if ( !v16 )
            v10 = *(_QWORD *)(v4 - 16);
          goto LABEL_6;
        }
        if ( a2 == 36 )
        {
          if ( a3 == v6 )
            return "malformed ?: operator";
          *(_BYTE *)(v4 - 32) = 36;
          *(_QWORD *)(v4 - 40) = v10;
LABEL_41:
          v10 = v16;
          goto LABEL_6;
        }
        v17 = a2 == 66;
        if ( a2 != 66 )
          v17 = a2 == 7;
        if ( v17 )
        {
          i = v10 | v16;
          goto LABEL_115;
        }
        if ( a2 == 5 )
        {
          v18 = (v10 | v16) == 0;
          if ( v10 | v16 )
            LOBYTE(v10) = 1;
LABEL_49:
          if ( v18 )
            LOBYTE(v10) = 0;
          goto LABEL_17;
        }
        v19 = a2 == 34;
        if ( a2 != 34 )
          v19 = a2 == 9;
        if ( v19 )
        {
          i = v10 & v16;
          goto LABEL_115;
        }
        v20 = a2 == 98;
        if ( a2 != 98 )
          v20 = a2 == 8;
        if ( v20 )
        {
          i = v10 ^ v16;
          goto LABEL_115;
        }
        switch ( a2 )
        {
          case 6:
            v18 = v10 == 0;
            if ( v10 )
              LOBYTE(v10) = v16 != 0;
            goto LABEL_49;
          case 10:
            LOBYTE(v10) = v10 == v16;
            goto LABEL_17;
          case 42:
            LOBYTE(v10) = v10 != v16;
            goto LABEL_17;
          case 75:
            v21 = v16 < v10;
            goto LABEL_70;
        }
        v22 = a2 == 226;
        if ( a2 != 226 )
          v22 = a2 == 44;
        if ( v22 )
        {
          v24 = v10 - 32;
          v23 = (int)v10 - 32 < 0;
          HIDWORD(v10) = SHIDWORD(v16) >> v10;
          LODWORD(v10) = ((unsigned int)v16 >> v10) | (HIDWORD(v16) << (32 - v10));
          if ( !v23 )
            LODWORD(v10) = v10 | (SHIDWORD(v16) >> v24);
          goto LABEL_6;
        }
        v25 = a2 == 194;
        if ( a2 != 194 )
          v25 = a2 == 12;
        if ( v25 )
        {
          HIDWORD(v10) = HIDWORD(v16) << v10;
          v26 = v10 - 32;
          v27 = 32 - v10;
          LODWORD(v10) = (_DWORD)v16 << v10;
          HIDWORD(v10) |= ((_DWORD)v16 << v26) | ((unsigned int)v16 >> v27);
          goto LABEL_6;
        }
        switch ( a2 )
        {
          case 43:
            v28 = v10 < v16;
            goto LABEL_87;
          case 11:
            v28 = v16 < v10;
LABEL_87:
            LOBYTE(v10) = v28;
            goto LABEL_17;
          case 107:
            v21 = v10 < v16;
LABEL_70:
            LOBYTE(v10) = !v21;
            goto LABEL_17;
        }
        v29 = a2 == 3;
        if ( a2 != 3 )
          v29 = a2 == 14;
        if ( v29 )
        {
          v30 = v10 * HIDWORD(v16) + v16 * HIDWORD(v10);
          v10 = (unsigned int)v10 * (unsigned __int64)(unsigned int)v16;
          HIDWORD(v10) += v30;
          goto LABEL_6;
        }
        v31 = a2 == 130;
        if ( a2 != 130 )
          v31 = a2 == 13;
        if ( v31 )
        {
          v10 += v16;
          goto LABEL_6;
        }
        v32 = a2 == 162;
        if ( a2 != 162 )
          v32 = a2 == 45;
        if ( v32 )
        {
          v10 = v16 - v10;
          goto LABEL_6;
        }
        if ( (unsigned int)(a2 - 1) <= 1 )
          goto LABEL_6;
        if ( a2 == 47 )
        {
          if ( v10 < 0 )
            return "exponent less than 0";
          for ( i = 1; --v10 != -1; HIDWORD(i) += v33 )
          {
            v33 = i * HIDWORD(v16) + v16 * HIDWORD(i);
            i = (unsigned int)i * (unsigned __int64)(unsigned int)v16;
          }
          goto LABEL_115;
        }
        if ( !v10 )
          return "divide by zero";
        v34 = a2 == 35;
        if ( a2 != 35 )
          v34 = a2 == 46;
        v35 = v34;
        if ( v34 )
        {
          if ( v10 != -1 )
            goto LABEL_138;
        }
        else
        {
          v36 = a2 == 67;
          if ( a2 != 67 )
            v36 = a2 == 78;
          if ( !v36 )
            goto LABEL_41;
          if ( v10 != -1 )
          {
LABEL_129:
            sub_62BA4(v16, v10);
            goto LABEL_115;
          }
        }
        if ( 2 * v16 )
          v10 = -1;
        else
          v10 = 1;
        if ( !v35 )
          goto LABEL_129;
LABEL_138:
        LODWORD(v16) = sub_62BA4(v16, v10);
        goto LABEL_41;
      }
    }
    v15 = sub_36DF4((int *)a1, v6, *(unsigned __int8 *)(v4 - 8));
    if ( v15 )
      return v15;
    goto LABEL_34;
  }
  v10 = -v10;
LABEL_6:
  v11 = a2 & 0x1F;
  if ( v11 == 3 )
    v11 = 2;
  v12 = v11 > 2;
  if ( v11 != 2 )
    v12 = v11 - 18 > 1;
  if ( v12 )
    goto LABEL_14;
  if ( *(_DWORD *)(v6 + 20) )
  {
    sprintf(s, "%lld", v10);
    (*(void (__fastcall **)(_DWORD, char *))(a1 + 8))(*(_DWORD *)(v6 + 20), s);
    if ( a2 == 19 )
    {
      --v10;
    }
    else if ( a2 == 51 )
    {
      ++v10;
    }
LABEL_14:
    *(_QWORD *)v6 = v10;
    *(_DWORD *)(v6 + 20) = 0;
    return v5;
  }
  return "arithmetic syntax error";
}
// 36784: variable 'v16' is possibly undefined
// 3698C: variable 'i' is possibly undefined

//----- (00036A80) --------------------------------------------------------
unsigned __int64 __fastcall sub_36A80(int *a1, unsigned __int8 *a2)
{
  int v3; // r5
  unsigned __int64 *v4; // r8
  unsigned __int8 *v5; // r0
  int v6; // r6
  int v7; // r0
  unsigned __int8 *v9; // r0
  char *v10; // r1
  char *v11; // r4
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // r4
  unsigned __int64 v15; // r0
  unsigned __int64 *v16; // r3
  int v17; // r2
  int v18; // r3
  unsigned int v19; // r4
  bool v20; // zf
  unsigned int v21; // r6
  bool v22; // cc
  unsigned __int64 *v23; // r2
  const char *v24; // r3
  char *v25; // r2
  int v26; // lr
  const char *v27; // r2
  int v28; // r1
  int v29; // t1
  unsigned int v30; // r3
  bool v31; // zf
  unsigned __int64 v32; // [sp+0h] [bp-3Ch] BYREF
  unsigned __int64 *v33; // [sp+8h] [bp-34h]
  char *endptr; // [sp+Ch] [bp-30h] BYREF
  unsigned __int64 *v35; // [sp+14h] [bp-28h] BYREF
  char v36; // [sp+18h] [bp-24h] BYREF

  v3 = 0;
  v32 = __PAIR64__(&v35, (unsigned int)sub_60E74(a2));
  endptr = (char *)v32;
  strlen((const char *)v32);
  v35 = &v32;
  v4 = (unsigned __int64 *)((char *)&v32 + 1);
  v33 = &v32;
  LOBYTE(v32) = 0;
LABEL_2:
  while ( 2 )
  {
    while ( 2 )
    {
      while ( 2 )
      {
        v5 = sub_60E74((unsigned __int8 *)endptr);
        endptr = (char *)v5;
        v6 = *v5;
        if ( !*v5 )
        {
          if ( (unsigned __int8 *)v32 == v5 )
          {
            v7 = *v5;
            v32 = 0;
          }
          else
          {
            if ( v5 != (unsigned __int8 *)&unk_68860 )
            {
              endptr = (char *)&unk_6885F;
              continue;
            }
            if ( v35 != (unsigned __int64 *)&v36 )
              goto LABEL_50;
            v7 = (int)v35;
            if ( v35 )
              v7 = (int)sub_36DF4(a1, (int)&v32, (int)v35);
          }
          goto LABEL_5;
        }
        break;
      }
      v9 = sub_5871C(v5);
      v10 = endptr;
      v11 = (char *)v9;
      if ( endptr != (char *)v9 )
      {
        v12 = v9 - (unsigned __int8 *)endptr + 1;
        *((_DWORD *)v35 + 5) = &v32;
        sub_60B34((char *)&v32, v10, v12);
        endptr = v11;
LABEL_13:
        v13 = (int)v35;
        v3 = 20;
        *((_BYTE *)v35 + 16) = 0;
        v35 = (unsigned __int64 *)(v13 + 24);
        continue;
      }
      break;
    }
    if ( (unsigned int)(v6 - 48) <= 9 )
    {
      *((_DWORD *)v35 + 5) = 0;
      v14 = (_DWORD *)dword_7DB94;
      *(_DWORD *)dword_7DB94 = 0;
      v15 = strtoull((const char *)v9, &endptr, 0);
      v16 = v35;
      v20 = *v14 == 0;
      *v35 = v15;
      if ( !v20 )
        *v16 = 0;
      goto LABEL_13;
    }
    if ( v3 != 20
      || *((_DWORD *)v35 - 1)
      || (v17 = (unsigned __int8)*endptr, ((v17 - 43) & 0xFD) != 0)
      || (v18 = (unsigned __int8)endptr[1], v18 != v17) )
    {
      v24 = "<<=";
LABEL_43:
      v25 = endptr;
      while ( *v24 )
      {
        v26 = (unsigned __int8)*v25++;
        if ( v26 != *(unsigned __int8 *)v24 )
        {
          do
            v27 = v24++;
          while ( *v27 );
          v24 = v27 + 2;
          if ( !v27[2] )
            goto LABEL_50;
          goto LABEL_43;
        }
        ++v24;
      }
      endptr = v25;
      v19 = *((unsigned __int8 *)v24 + 1);
    }
    else
    {
      if ( v18 == 43 )
        v19 = 13;
      else
        v19 = 45;
      ++endptr;
    }
    v20 = (v3 & 0xDF) == 19;
    if ( (v3 & 0xDF) != 0x13 )
      v20 = v3 == 20;
    if ( v20 )
    {
      v3 = 20;
    }
    else if ( v19 == 19 )
    {
      v19 = 18;
    }
    else if ( v19 > 0x13 )
    {
      if ( v19 == 45 )
      {
        v19 = 17;
      }
      else if ( v19 == 51 )
      {
        v19 = 50;
      }
    }
    else if ( v19 == 13 )
    {
      v19 = 49;
    }
    v21 = v19 & 0x1F;
    v22 = v21 > 0x14;
    if ( v21 != 20 )
      v22 = (v19 & 0x1F) - 1 > 0xE;
    if ( v22 )
    {
      v23 = v4;
      goto LABEL_69;
    }
    if ( v3 != 20 )
      break;
    while ( 1 )
    {
      v23 = v4;
      if ( v4 == v33 )
        break;
      v29 = *((unsigned __int8 *)v4 - 1);
      v4 = (unsigned __int64 *)((char *)v4 - 1);
      v28 = v29;
      if ( v19 == 52 )
      {
        if ( !v28 )
          goto LABEL_2;
        goto LABEL_58;
      }
      v30 = v28 & 0x1F;
      if ( v21 != 3 )
      {
        if ( v30 == 3 )
          v30 = 2;
LABEL_63:
        if ( v30 < v21 )
          goto LABEL_69;
        if ( v30 != v21 )
          goto LABEL_58;
        goto LABEL_65;
      }
      v21 = 2;
      if ( v30 != 3 )
        goto LABEL_63;
LABEL_65:
      v31 = (((_BYTE)v21 - 2) & 0xFD) == 0;
      if ( (((_BYTE)v21 - 2) & 0xFD) != 0 )
        v31 = v21 == 15;
      if ( v31 )
        goto LABEL_69;
LABEL_58:
      v7 = (int)sub_365CC((int)a1, v28, (int)&v32, (int *)HIDWORD(v32));
      if ( v7 )
        goto LABEL_59;
    }
    if ( v19 != 52 )
    {
LABEL_69:
      v4 = (unsigned __int64 *)((char *)v23 + 1);
      *(_BYTE *)v23 = v19;
      v3 = v19;
      continue;
    }
    break;
  }
LABEL_50:
  v7 = (int)"arithmetic syntax error";
LABEL_59:
  v32 = -1;
LABEL_5:
  *a1 = v7;
  return v32;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00036DF4) --------------------------------------------------------
const char *__fastcall sub_36DF4(int *a1, int a2, int a3)
{
  int v3; // r4
  int **v6; // r8
  const char *v7; // r9
  int **i; // r7
  __int64 v9; // r0
  int *v11; // [sp+0h] [bp-Ch] BYREF
  const char *v12; // [sp+4h] [bp-8h]
  int v13; // [sp+8h] [bp-4h]

  v11 = a1;
  v12 = (const char *)a2;
  v13 = a3;
  v3 = *(_DWORD *)(a2 + 20);
  if ( v3 )
  {
    v3 = ((int (__fastcall *)(_DWORD))a1[1])(*(_DWORD *)(a2 + 20));
    if ( v3 )
    {
      v6 = (int **)a1[3];
      v7 = *(const char **)(a2 + 20);
      for ( i = v6; ; i = (int **)*i )
      {
        if ( !i )
        {
          v11 = (int *)v6;
          a1[3] = (int)&v11;
          v12 = v7;
          v9 = sub_36A80(a1, v3);
          v3 = *a1;
          *(_QWORD *)a2 = v9;
          a1[3] = (int)v6;
          return (const char *)v3;
        }
        if ( !strcmp((const char *)i[1], v7) )
          break;
      }
      return "expression recursion loop detected";
    }
    else
    {
      *(_QWORD *)a2 = 0;
    }
  }
  return (const char *)v3;
}
// 36A80: using guessed type __int64 __fastcall sub_36A80(_DWORD, _DWORD);

//----- (00036E9C) --------------------------------------------------------
unsigned __int64 __fastcall sub_36E9C(int *a1, unsigned __int8 *a2)
{
  *a1 = 0;
  a1[3] = 0;
  return sub_36A80(a1, a2);
}

//----- (00036EAC) --------------------------------------------------------
int __fastcall sub_36EAC(__pid_t *a1)
{
  __pid_t v2; // r0
  int v3; // r1
  int v4; // r2
  __pid_t v5; // r0
  unsigned int v6; // r2
  int v7; // r12
  int v8; // r1
  unsigned int v9; // r3
  unsigned int v10; // r3
  int v11; // lr
  int v12; // r0

  if ( !*a1 )
  {
    v2 = getpid();
    a1[2] = v2;
    *a1 = v2;
    v5 = sub_187B0(v2, v3, v4);
    a1[3] = v5;
    a1[1] = v5;
  }
  v6 = a1[3];
  v7 = 1664525 * a1[1] + 1013904223;
  v8 = 2 * *a1;
  v9 = a1[2];
  if ( *a1 < 0 )
    v8 ^= 0x8000000B;
  a1[1] = v7;
  *a1 = v8;
  while ( 1 )
  {
    v10 = v9 ^ (4 * v9);
    v11 = v6 ^ (v6 >> 3) ^ v10;
    v10 >>= 7;
    v12 = v11 ^ v10;
    if ( v11 != v10 )
    {
      a1[2] = v6;
      a1[3] = v12;
      return ((_WORD)v12 + (_WORD)v8 - (_WORD)v7) & 0x7FFF;
    }
    v9 = v6;
    if ( v6 > 2 )
      break;
    v6 = v12;
  }
  a1[3] = v12;
  LOWORD(v12) = 0;
  a1[2] = v6;
  return ((_WORD)v12 + (_WORD)v8 - (_WORD)v7) & 0x7FFF;
}
// 36ECC: variable 'v3' is possibly undefined
// 36ECC: variable 'v4' is possibly undefined

//----- (00036F68) --------------------------------------------------------
int __fastcall sub_36F68(char a1, unsigned __int64 *a2, _BYTE *a3)
{
  unsigned __int64 v3; // r4

  v3 = a2[1];
  if ( (a1 & 1) == 0 )
    v3 = *a2;
  if ( v3 == -1 )
    return puts("unlimited");
  else
    return printf("%llu\n", v3 >> *a3);
}

//----- (00036FC8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_36FC8(unsigned __int8 *result, int a2)
{
  unsigned int v2; // r2
  bool v3; // cc
  unsigned int v4; // r3
  unsigned int v5; // t1
  bool v6; // cc

  if ( result )
  {
    v2 = *result;
    v3 = v2 > 0x5F;
    if ( v2 != 95 )
      v3 = (v2 | 0x20) - 97 > 0x19;
    if ( v3 )
    {
      return 0;
    }
    else
    {
      do
      {
        do
        {
          v5 = *++result;
          v4 = v5;
        }
        while ( v5 - 48 <= 9 );
        v6 = v4 > 0x5F;
        if ( v4 != 95 )
          v6 = (v4 | 0x20) - 97 > 0x19;
      }
      while ( !v6 );
      return (unsigned __int8 *)(v4 == a2);
    }
  }
  return result;
}

//----- (00037024) --------------------------------------------------------
const char *__fastcall sub_37024(
        __int64 a1,
        const char *a2,
        char a3,
        const char *a4,
        int a5,
        const char *a6,
        const char *a7,
        unsigned __int8 *a8)
{
  int *v8; // r6
  int v10; // r11
  int *v11; // r7
  unsigned __int8 *v12; // r4
  unsigned __int8 *v13; // t1
  int v14; // r5
  int v15; // r3
  int v16; // r2
  _BOOL4 v17; // r3
  tcflag_t c_lflag; // r3
  int v19; // r9
  int v20; // r10
  int v21; // r11
  int v22; // r3
  int v23; // r2
  int v24; // r9
  unsigned int v27; // r1
  bool v28; // cc
  unsigned __int8 *v29; // r11
  size_t v30; // r10
  int v31; // r1
  unsigned int v32; // t1
  unsigned int v33; // r3
  bool v34; // cc
  int v35; // r0
  int v36; // t1
  unsigned int v37; // r5
  bool v38; // zf
  bool v39; // cc
  int v40; // t1
  bool v41; // cc
  tcflag_t v42; // [sp+0h] [bp-9Ch]
  int v43; // [sp+4h] [bp-98h]
  int (__fastcall *v45)(int, unsigned __int8 *); // [sp+Ch] [bp-90h]
  int v46; // [sp+10h] [bp-8Ch]
  unsigned __int8 *v47; // [sp+14h] [bp-88h]
  struct pollfd fd; // [sp+18h] [bp-84h] BYREF
  struct termios termios_p; // [sp+20h] [bp-7Ch] BYREF
  struct termios v50; // [sp+5Ch] [bp-40h] BYREF

  v8 = (int *)HIDWORD(a1);
  v10 = HIDWORD(a1) - 4;
  v11 = (int *)dword_7DB94;
  v45 = (int (__fastcall *)(int, unsigned __int8 *))a1;
  *(_DWORD *)dword_7DB94 = 0;
  while ( 1 )
  {
    v13 = *(unsigned __int8 **)(v10 + 4);
    v10 += 4;
    v12 = v13;
    if ( !v13 )
      break;
    LODWORD(a1) = sub_36FC8(v12, 0);
    if ( !(_DWORD)a1 )
    {
      v14 = 1;
      sub_16DDC("read: '%s': not a valid identifier", (const char *)v12);
      return (const char *)v14;
    }
  }
  if ( a4 )
  {
    LODWORD(a1) = sub_18990(a4, 0, (char *)0xA);
    v42 = a1;
    if ( (int)a1 < 0 || *v11 )
      return "invalid count";
  }
  else
  {
    v42 = 0;
  }
  if ( a6 )
  {
    LODWORD(a1) = sub_18990(a6, 0, (char *)0xA);
    if ( *v11 )
      return "invalid timeout";
    if ( (unsigned int)a1 >= 0x1FFFFF )
      LODWORD(a1) = 0x1FFFFF;
    v15 = 1000 * a1;
  }
  else
  {
    v15 = 0;
  }
  HIDWORD(a1) = 0;
  v43 = v15;
  fd.fd = 0;
  if ( a7 )
  {
    LODWORD(a1) = sub_18990(a7, 0, (char *)0xA);
    fd.fd = a1;
    if ( (int)a1 < 0 || *v11 )
      return "invalid file descriptor";
  }
  v16 = (int)a6;
  v17 = v43 == 0;
  if ( !a6 )
    v17 = 0;
  if ( v17 )
  {
    fd.events = 1;
    return (const char *)(poll(&fd, 1u, 0) <= 0);
  }
  if ( a5 )
  {
    LODWORD(a1) = isatty(fd.fd);
    if ( (_DWORD)a1 )
    {
      fputs_unlocked(a5, stderr);
      LODWORD(a1) = sub_177D8();
    }
  }
  if ( !a2 )
    a2 = " \t\n";
  if ( v42 || (a3 & 1) != 0 )
  {
    tcgetattr(fd.fd, &termios_p);
    v50.c_iflag = termios_p.c_iflag;
    v50.c_oflag = termios_p.c_oflag;
    v50.c_cflag = termios_p.c_cflag;
    v50.c_lflag = termios_p.c_lflag;
    *(_DWORD *)&v50.c_line = *(_DWORD *)&termios_p.c_line;
    *(_DWORD *)&v50.c_cc[3] = *(_DWORD *)&termios_p.c_cc[3];
    *(_DWORD *)&v50.c_cc[7] = *(_DWORD *)&termios_p.c_cc[7];
    *(_DWORD *)&v50.c_cc[11] = *(_DWORD *)&termios_p.c_cc[11];
    *(_DWORD *)&v50.c_cc[15] = *(_DWORD *)&termios_p.c_cc[15];
    *(_DWORD *)&v50.c_cc[19] = *(_DWORD *)&termios_p.c_cc[19];
    *(_DWORD *)&v50.c_cc[23] = *(_DWORD *)&termios_p.c_cc[23];
    *(_DWORD *)&v50.c_cc[27] = *(_DWORD *)&termios_p.c_cc[27];
    c_lflag = v42;
    if ( v42 )
      c_lflag = termios_p.c_lflag;
    *(_DWORD *)&v50.c_cc[31] = *(_DWORD *)&termios_p.c_cc[31];
    v50.c_ispeed = termios_p.c_ispeed;
    v50.c_ospeed = termios_p.c_ospeed;
    if ( v42 )
    {
      termios_p.c_lflag = c_lflag & 0xFFFFFFFD;
      *(_WORD *)&termios_p.c_cc[5] = 256;
    }
    if ( (a3 & 1) != 0 )
      termios_p.c_lflag &= 0xFFFFFF97;
    a3 |= 1u;
    LODWORD(a1) = tcsetattr(fd.fd, 0, &termios_p);
  }
  if ( a6 )
  {
    a1 = sub_187F0(a1, SHIDWORD(a1), v16);
    v43 += a1;
  }
  v19 = 0;
  v20 = 1;
  v21 = 0;
  if ( a8 )
    v22 = *a8;
  else
    v22 = 10;
  v46 = v22;
  do
  {
    if ( !(_BYTE)v21 )
    {
      LODWORD(a1) = sub_174B4(v12, v21 + 257);
      v12 = (unsigned __int8 *)a1;
    }
    if ( a6 )
    {
      v23 = v43 - sub_187F0(a1, SHIDWORD(a1), v16);
      if ( v23 <= 0 )
      {
        v14 = 1;
        v24 = 0;
        goto LABEL_42;
      }
    }
    else
    {
      v23 = -1;
    }
    v14 = 1;
    *v11 = 0;
    fd.events = 1;
    if ( poll(&fd, 1u, v23) <= 0 )
    {
      v24 = *v11;
      goto LABEL_42;
    }
    v47 = &v12[v21];
    LODWORD(a1) = read(fd.fd, &v12[v21], 1u);
    if ( (_DWORD)a1 != 1 )
    {
      v24 = *v11;
      goto LABEL_57;
    }
    v37 = v12[v21];
    if ( !v12[v21] )
      goto LABEL_81;
    v16 = a3 & 2;
    if ( (a3 & 2) == 0 )
    {
      if ( v19 )
      {
        v19 = a3 & 2;
        if ( v37 != 10 )
          goto LABEL_107;
        goto LABEL_81;
      }
      if ( v37 == 92 )
      {
        v19 = 1;
        goto LABEL_81;
      }
    }
    if ( v46 == v37 )
      break;
    if ( a8 )
      goto LABEL_107;
    v16 = *v8;
    if ( !*v8 )
      goto LABEL_107;
    LODWORD(a1) = strchr(a2, v12[v21]);
    v16 = a1;
    if ( (_DWORD)a1 )
      v16 = 1;
    v38 = v20 == 0;
    if ( v20 )
      v38 = (_DWORD)a1 == 0;
    if ( v38 )
      goto LABEL_114;
    HIDWORD(a1) = v37 - 9;
    v39 = v37 > 0x20;
    if ( v37 != 32 )
      v39 = HIDWORD(a1) > 4;
    if ( !v39 )
      goto LABEL_81;
    if ( v20 != 2 )
    {
LABEL_114:
      if ( v8[1] )
        v20 = v16;
      else
        v20 = 0;
      if ( v20 )
      {
        v21 = 0;
        *v47 = 0;
        v40 = *v8++;
        LODWORD(a1) = v45(v40, v12);
        v41 = v37 > 0x20;
        if ( v37 != 32 )
          v41 = v37 - 9 > 4;
        if ( v41 )
          v20 = 1;
        else
          v20 = 2;
        goto LABEL_81;
      }
LABEL_107:
      ++v21;
      goto LABEL_81;
    }
    v20 = 1;
LABEL_81:
    --v42;
  }
  while ( v42 );
  v14 = 0;
  v24 = 0;
LABEL_57:
  if ( *v8 )
  {
    do
    {
      if ( v21-- == 0 )
        break;
      v27 = v12[v21];
      v28 = v27 > 0x20;
      if ( v27 != 32 )
        v28 = v27 - 9 > 4;
    }
    while ( !v28 && strchr(a2, v27) );
    v12[v21 + 1] = 0;
    if ( v21 != -1 && strchr(a2, v12[v21]) )
    {
      v29 = &v12[v21];
      do
      {
        v30 = v29 - v12;
        if ( v29 == v12 )
          break;
        v32 = *--v29;
        v31 = v32;
        v33 = v32 - 9;
        v34 = v32 > 0x20;
        if ( v32 != 32 )
          v34 = v33 > 4;
      }
      while ( !v34 && strchr(a2, v31) );
      if ( strcspn((const char *)v12, a2) >= v30 )
        v12[v30] = 0;
    }
    v45(*v8, v12);
    while ( 1 )
    {
      v36 = v8[1];
      ++v8;
      v35 = v36;
      if ( !v36 )
        break;
      v45(v35, (unsigned __int8 *)"");
    }
  }
  else
  {
    v12[v21] = 0;
    v45((int)"REPLY", v12);
  }
LABEL_42:
  free(v12);
  if ( (a3 & 1) != 0 )
    tcsetattr(fd.fd, 0, &v50);
  *v11 = v24;
  return (const char *)v14;
}
// 371E8: variable 'a1' is possibly undefined
// 371E8: variable 'v16' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D608: using guessed type int stderr;
// 7DB94: using guessed type int dword_7DB94;

//----- (000377A8) --------------------------------------------------------
int sub_377A8()
{
  char *v0; // r0
  char *v1; // r4
  int v2; // r4
  struct sockaddr v4[7]; // [sp+0h] [bp-70h] BYREF

  memset(v4[0].sa_data, 0, 0x6Cu);
  v4[0].sa_family = 1;
  strcpy(v4[0].sa_data, "/dev/log");
  v0 = sub_17BE4("/dev/log");
  v1 = v0;
  if ( v0 )
  {
    sub_60B34(v4[0].sa_data, v0, 108);
    free(v1);
  }
  unlink(v4[0].sa_data);
  v2 = sub_179A4(1, 2, 0);
  sub_179C0(v2, v4, 0x6Eu);
  chmod("/dev/log", 0x1B6u);
  return v2;
}

//----- (00037840) --------------------------------------------------------
ssize_t __fastcall sub_37840(int a1, char *a2, int a3)
{
  const char *v4; // r6
  char *v5; // r8
  const char **v6; // r4
  char *v7; // r5
  int v8; // r8
  size_t v9; // r0
  ssize_t result; // r0
  size_t v11; // r7
  const char *v12; // r0
  int v13; // r3
  signed int v14; // r6
  size_t v15; // r9
  char *v16; // r0
  int v17; // r0
  char **v18; // r2
  const char *v19; // r3
  char **v20; // r2
  const char *v21; // r1
  size_t v22; // r6
  char *v23; // r1
  time_t v24; // r6
  size_t v25; // r0
  int v26; // r3
  size_t v27; // r8
  const char *v28; // r3
  const char *v29; // r6
  const char *v30; // r0
  const char *v31; // r6
  int v32; // r0
  int v33; // r0
  int v34; // r4
  int v35; // r0
  __int16 v36; // r3
  int v37; // [sp+0h] [bp-A4h] BYREF
  char v38[4]; // [sp+8h] [bp-9Ch] BYREF
  int *v39; // [sp+Ch] [bp-98h]
  time_t timer; // [sp+14h] [bp-90h] BYREF
  char s[16]; // [sp+18h] [bp-8Ch] BYREF
  int v42; // [sp+28h] [bp-7Ch]
  const char *v43; // [sp+48h] [bp-5Ch]

  v4 = a2;
  if ( a3 > 15 && a2[3] == 32 && a2[6] == 32 && a2[9] == 58 && a2[12] == 58 && a2[15] == 32 )
  {
    v5 = a2;
    timer = 0;
    v4 = a2 + 16;
  }
  else
  {
    time(&timer);
    v5 = ctime(&timer) + 4;
  }
  v5[15] = 0;
  v6 = (const char **)dword_7DB98;
  v7 = (char *)(dword_7DB98 + 1108);
  if ( (dword_7DBC0 & 0x200) != 0 )
  {
    v8 = *(_DWORD *)(dword_7DB98 + 68);
    v9 = sprintf((char *)(dword_7DB98 + 1108), "<%d>%s\n", *(_DWORD *)(dword_7DB98 + 72) & a1, v4);
    return sub_17FB8(v8, v7, v9);
  }
  else
  {
    if ( (dword_7DBC0 & 0x10) != 0 )
    {
      result = sprintf((char *)(dword_7DB98 + 1108), "%s %s\n", v5, v4);
    }
    else
    {
      v18 = &off_7D4E0;
      while ( 1 )
      {
        v19 = *(v18 - 2);
        if ( !v19 )
          break;
        v18 += 2;
        if ( (char *)(a1 & 0x3F8) == *(v18 - 3) )
        {
          v20 = &off_7D598;
          while ( 1 )
          {
            v21 = *(v20 - 2);
            if ( !v21 )
              goto LABEL_25;
            v20 += 2;
            if ( (char *)(a1 & 7) == *(v20 - 3) )
            {
              snprintf(s, 0x14u, "%s.%s", v19, v21);
              goto LABEL_26;
            }
          }
        }
      }
LABEL_25:
      snprintf(s, 0x14u, "<%d>", a1);
LABEL_26:
      result = sprintf(v7, "%s %.64s %s %s\n", v5, v6[20], s, v4);
    }
    if ( (a1 & 7) < (int)v6[5] )
    {
      if ( (dword_7DBC0 & 0x80) != 0 && v6[19] )
      {
        if ( semop((int)v6[9], (struct sembuf *)((char *)v6 + 50), 3u) == -1 )
          sub_16B40("SMwdn");
        v11 = strlen(v7) + 1;
        while ( 1 )
        {
          v12 = v6[19];
          v13 = *((_DWORD *)v12 + 1);
          v14 = *(_DWORD *)v12;
          v15 = v13 + v11;
          v16 = (char *)&v12[v13 + 8];
          if ( (int)(v13 + v11) < v14 )
            break;
          v22 = v14 - v13;
          v23 = v7;
          v7 += v22;
          memcpy(v16, v23, v22);
          v11 -= v22;
          *((_DWORD *)v6[19] + 1) = 0;
        }
        memcpy(v16, v7, v11);
        v17 = (int)v6[9];
        *((_DWORD *)v6[19] + 1) = v15;
        result = semop(v17, (struct sembuf *)(v6 + 11), 1u);
        if ( result == -1 )
          sub_16B40("SMwup");
      }
      else
      {
        v24 = timer;
        v25 = strlen(v7);
        v26 = (int)v6[1];
        v27 = v25;
        if ( v26 <= 1 )
        {
          if ( v26 == 1 )
            goto LABEL_38;
          if ( **v6 == 45 && !(*v6)[1] )
          {
            v6[1] = (const char *)1;
            goto LABEL_38;
          }
          goto LABEL_49;
        }
        if ( !timer )
          v24 = time(0);
        if ( v6[2] == (const char *)v24 )
          goto LABEL_38;
        v6[2] = (const char *)v24;
        while ( 1 )
        {
          close((int)v6[1]);
LABEL_49:
          v32 = open64(*v6, 3393);
          v6[1] = (const char *)v32;
          if ( v32 < 0 )
          {
            v33 = sub_586C8((int)"/dev/console", 2305);
            if ( v33 < 0 )
              v34 = 2;
            else
              v34 = v33;
            result = sub_17FB8(v34, v7, v27);
            if ( v34 != 2 )
              return close(v34);
            return result;
          }
          v35 = sub_62E08();
          if ( v35 )
            v36 = 0;
          else
            v36 = v42;
          if ( !v35 )
            LOBYTE(v36) = (v36 & 0xF000) == 0x8000;
          *((_BYTE *)v6 + 16) = v36;
          v6[3] = v43;
LABEL_38:
          v28 = v6[6];
          if ( !v28 || !*((_BYTE *)v6 + 16) || v28 >= v6[3] )
            break;
          v29 = v6[7];
          v30 = *v6;
          if ( v29 )
          {
            v39 = &v37;
            v31 = v29 - 1;
            strlen(v30);
            while ( 1 )
            {
              sprintf(v38, "%s.%d", *v6, v31);
              if ( !v31 )
                break;
              sprintf(v38, "%s.%d", *v6, --v31);
              rename(v38, v38);
            }
            rename(*v6, v38);
          }
          unlink(*v6);
        }
        result = sub_17FB8((int)v6[1], v7, v27);
        if ( result > 0 )
        {
          result += (ssize_t)v6[3];
          v6[3] = (const char *)result;
        }
      }
    }
  }
  return result;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D4E0: using guessed type char *off_7D4E0;
// 7D598: using guessed type char *off_7D598;
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00037CB0) --------------------------------------------------------
void __fastcall __noreturn sub_37CB0(int a1, char **a2)
{
  void *v3; // r0
  char *v4; // r4
  char v5; // r5
  const char *v6; // r0
  int v7; // r0
  int v8; // r0
  void *v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r3
  int v13; // r11
  char *i; // r3
  char *v15; // r6
  ssize_t v16; // r0
  size_t v17; // r5
  char *v18; // r2
  int v19; // r1
  int v20; // t1
  bool v21; // zf
  int v22; // r0
  int v23; // r0
  int v24; // r0
  _BYTE *j; // r2
  int v26; // r1
  unsigned __int8 *v27; // r1
  char *s1; // [sp+14h] [bp-20h]
  char v29[4]; // [sp+18h] [bp-1Ch] BYREF
  int v30; // [sp+1Ch] [bp-18h] BYREF
  int v31; // [sp+20h] [bp-14h] BYREF
  int v32; // [sp+24h] [bp-10h] BYREF
  int v33; // [sp+28h] [bp-Ch] BYREF
  unsigned int v34; // [sp+2Ch] [bp-8h] BYREF

  v33 = 0;
  v3 = sub_174DC(0x6D4u);
  v4 = (char *)memcpy(v3, &off_638A4, 0x4Cu);
  dword_7DB98 = (int)v4;
  v5 = sub_593CC(a2, "^m:nO:l:Ss:b:C::DK", v29, v4, &v30, &v31, &v32, &v33);
  if ( (v5 & 8) != 0 )
    *((_DWORD *)v4 + 5) = sub_6206C((const char *)v30, 1u, 8u);
  if ( (v5 & 0x20) != 0 )
    *((_DWORD *)v4 + 6) = sub_6206C((const char *)v31, 0, 0x1FFFFFu) << 10;
  if ( (v5 & 0x40) != 0 )
    *((_DWORD *)v4 + 7) = sub_6206C((const char *)v32, 0, 0x63u);
  if ( v33 )
    *((_DWORD *)v4 + 10) = sub_6206C((const char *)v33, 4u, 0x1FFFFFu) << 10;
  v6 = (const char *)sub_60AA0();
  *((_DWORD *)v4 + 20) = v6;
  *(_BYTE *)strchrnul(v6, 46) = 0;
  if ( (v5 & 2) == 0 )
    sub_61B48(1);
  sub_18288(15, sub_18140);
  sub_18288(2, sub_18140);
  signal(1, (__sighandler_t)1);
  v7 = sub_377A8();
  sub_176A8(v7, 0);
  if ( (dword_7DBC0 & 0x80) != 0 )
  {
    v8 = shmget(1095648583, *((_DWORD *)v4 + 10), 932);
    *((_DWORD *)v4 + 8) = v8;
    if ( v8 == -1 )
      sub_16B40("shmget");
    v9 = (void *)shmat(v8, 0);
    *((_DWORD *)v4 + 19) = v9;
    if ( v9 == (void *)-1 )
      sub_16B40("shmat");
    memset(v9, 0, *((_DWORD *)v4 + 10));
    **((_DWORD **)v4 + 19) = *((_DWORD *)v4 + 10) - 9;
    v10 = semget(1095648583, 2, 2047);
    *((_DWORD *)v4 + 9) = v10;
    if ( v10 == -1 )
    {
      if ( *(_DWORD *)dword_7DB94 != 17 || (v11 = semget(1095648583, 2, 0), *((_DWORD *)v4 + 9) = v11, v11 == -1) )
        sub_16B40("semget");
    }
  }
  if ( (dword_7DBC0 & 0x200) != 0 )
  {
    *((_DWORD *)v4 + 17) = sub_175D8("/dev/kmsg", 1);
    if ( sub_5A8E8() > 197887 )
      v12 = -1;
    else
      v12 = 7;
    *((_DWORD *)v4 + 18) = v12;
  }
  sub_37840(46, "syslogd started: BusyBox v1.29.3", 0);
  v13 = -1;
  for ( i = v4 + 84; ; i = v15 )
  {
    if ( dword_7DBA0 )
      goto LABEL_40;
    v15 = v4 + 84 == i ? v4 + 340 : v4 + 84;
LABEL_30:
    s1 = i;
    v16 = read(0, v15, 0xFFu);
    v17 = v16;
    i = s1;
    if ( v16 < 0 )
      break;
    v18 = &v15[v16];
    while ( 1 )
    {
      if ( !v17 )
        goto LABEL_30;
      v20 = (unsigned __int8)*--v18;
      v19 = v20;
      v21 = v20 == 0;
      if ( v20 )
        v21 = v19 == 10;
      if ( !v21 )
        break;
      --v17;
    }
    if ( ((v17 == v13) & ((unsigned int)dword_7DBC0 >> 8)) == 0 || memcmp(s1, v15, v17) )
    {
      v15[v17] = 0;
      v34 = (unsigned int)v15;
      while ( (unsigned int)&v15[v17] > v34 )
      {
        if ( *(_BYTE *)v34 != 60 )
          goto LABEL_54;
        v24 = sub_18990((const char *)(v34 + 1), (char *)&v34, (char *)0xA);
        if ( *(_BYTE *)v34 == 62 )
          ++v34;
        if ( (v24 & 0xFFFFFC00) != 0 )
LABEL_54:
          v24 = 13;
        for ( j = v4 + 596; ; ++j )
        {
          v27 = (unsigned __int8 *)v34++;
          v26 = *v27;
          if ( !v26 )
            break;
          if ( v26 == 10 )
            v26 = 32;
          if ( (v26 & 0xFFFFFFE0) == 0 && v26 != 9 )
          {
            *j = 94;
            LOBYTE(v26) = v26 + 64;
            ++j;
          }
          *j = v26;
        }
        *j = 0;
        sub_37840(v24, v4 + 596, j - (v4 + 596));
      }
      v13 = v17;
    }
  }
  if ( !dword_7DBA0 )
    sub_16AF4("read from %s", "/dev/log");
LABEL_40:
  sub_37840(46, "syslogd exiting", 0);
  if ( *((_DWORD *)v4 + 8) != -1 )
    shmdt(*((_DWORD *)v4 + 19));
  v22 = *((_DWORD *)v4 + 8);
  if ( v22 != -1 )
    shmctl(v22, 0);
  v23 = *((_DWORD *)v4 + 9);
  if ( v23 != -1 )
    semctl(v23, 0, 0);
  sub_18260(dword_7DBA0);
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 1369C: using guessed type int __fastcall shmget(_DWORD, _DWORD, _DWORD);
// 13858: using guessed type int __fastcall shmat(_DWORD, _DWORD);
// 139B8: using guessed type int __fastcall shmctl(_DWORD, _DWORD);
// 13DCC: using guessed type int __fastcall shmdt(_DWORD);
// 638A4: using guessed type char *off_638A4;
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;
// 7DBA0: using guessed type int dword_7DBA0;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00038134) --------------------------------------------------------
int __fastcall sub_38134(int a1, char **a2)
{
  char v2; // r0
  char v3; // r4
  char *v4; // r5
  int v5; // r0
  int v6; // r4
  int v7; // r6
  char *v8; // r3
  int v9; // r2
  int v10; // t1
  bool v11; // zf
  int v13; // r0
  int v14; // [sp+0h] [bp-8h] BYREF
  int len; // [sp+4h] [bp-4h] BYREF

  v14 = a1;
  len = (int)a2;
  v2 = sub_593CC(a2, "cs:+n:+r", &v14, &len);
  if ( (v2 & 4) != 0 )
  {
    if ( klogctl(8, 0, len) )
      goto LABEL_3;
  }
  else
  {
    v3 = v2;
    if ( (v2 & 2) == 0 )
      v14 = klogctl(10, 0, 0);
    if ( v14 < 0x4000 )
      v14 = 0x4000;
    if ( v14 > 0x1000000 )
      v14 = 0x1000000;
    v4 = (char *)sub_1748C(v14);
    v5 = klogctl((v3 & 1) + 3, v4, v14);
    v14 = v5;
    if ( v5 < 0 )
LABEL_3:
      sub_16B40("klogctl");
    if ( v5 )
    {
      v6 = v3 & 8;
      if ( v6 )
      {
        sub_17FB8(1, v4, v5);
        v11 = v4[v14 - 1] == 10;
      }
      else
      {
        v7 = 10;
        do
        {
          v8 = &v4[v6];
          v9 = (unsigned __int8)v4[v6];
          if ( v7 == 10 && v9 == 60 )
          {
            do
            {
              v10 = (unsigned __int8)*v8++;
              ++v6;
            }
            while ( v10 != 62 && v14 > v6 );
          }
          else
          {
            v13 = (unsigned __int8)v4[v6++];
            v7 = v9;
            putchar_unlocked(v13);
          }
        }
        while ( v14 > v6 );
        v11 = v7 == 10;
      }
      if ( !v11 )
        j_putchar_unlocked(10);
    }
  }
  return 0;
}

//----- (00038288) --------------------------------------------------------
int __fastcall sub_38288(int a1, char **a2)
{
  unsigned __int64 v3; // r6
  unsigned __int64 v4; // r8
  int v5; // r5
  int v6; // r0
  int v7; // r1
  int result; // r0
  int v9; // [sp+8h] [bp-Ch] BYREF
  int v10; // [sp+Ch] [bp-8h] BYREF

  v10 = (int)"0";
  if ( (sub_593CC(a2, "^l:o:", &v9, &v10) & 1) == 0 )
    sub_162F0();
  v3 = sub_61EE8((const char *)v10, (int)&unk_64214);
  v4 = sub_61EE8((const char *)v9, (int)&unk_64214);
  v5 = optind;
  v6 = sub_175B4(a2[optind], 66);
  result = posix_fallocate64(v6, v7, v3, HIDWORD(v3), v4, HIDWORD(v4));
  *(_DWORD *)dword_7DB94 = result;
  if ( result )
    sub_16B40("fallocate '%s'", a2[v5]);
  return result;
}
// 38308: variable 'v7' is possibly undefined
// 13E5C: using guessed type int __fastcall posix_fallocate64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7DB94: using guessed type int dword_7DB94;

//----- (0003834C) --------------------------------------------------------
int __fastcall sub_3834C(int a1, int a2)
{
  const char *v3; // r0
  int v4; // r0

  v3 = (const char *)sub_60E30(a2);
  v4 = sub_175D8(v3, 2);
  sub_17A4C(v4, 0x1261u, 0, "%s", *(const char **)(a2 + 4));
  return 0;
}

//----- (0003838C) --------------------------------------------------------
int __fastcall sub_3838C(int a1, char **a2)
{
  char v3; // r5
  int v4; // r0
  unsigned int v5; // r1

  v3 = sub_593F8(a2, "^", "freeze");
  v4 = sub_175D8(a2[optind], 0);
  v5 = -1073457032;
  if ( (v3 & 1) != 0 )
    v5 = -1073457033;
  sub_17B18(v4, v5, 0, "(opts & 1) ? FIFREEZE : FITHAW");
  return 0;
}
// 7D604: using guessed type int optind;

//----- (000383F4) --------------------------------------------------------
int __fastcall sub_383F4(int a1, int a2)
{
  unsigned __int8 *v2; // r4
  const char *v3; // r0
  __mode_t v5; // r1
  int v6; // [sp+0h] [bp-68h] BYREF
  int v7; // [sp+10h] [bp-58h]

  v2 = *(unsigned __int8 **)(a2 + 4);
  if ( v2 )
  {
    if ( *(_DWORD *)(a2 + 8)
      || (v2 = (unsigned __int8 *)*v2, v2 != (unsigned __int8 *)121) && v2 != (unsigned __int8 *)110 )
    {
      sub_162F0();
    }
  }
  if ( !isatty(0) )
    sub_16DBC("not a tty");
  sub_17A30(0, (int)&v6, "stdin");
  if ( v2 )
  {
    if ( v2 == (unsigned __int8 *)121 )
      v5 = v7 | 0x10;
    else
      v5 = v7 & 0xFFFFFFED;
    if ( fchmod(0, v5) )
      sub_5E304();
  }
  else
  {
    v3 = "is n";
    if ( (v7 & 0x12) != 0 )
      v3 = "is y";
    puts(v3);
  }
  return 0;
}

//----- (000384B0) --------------------------------------------------------
int sub_384B0()
{
  int result; // r0

  result = sub_1714C(buf.c_iflag, (int *)&buf.c_oflag, (int *)&buf.c_cflag);
  --buf.c_cflag;
  return result;
}

//----- (000384DC) --------------------------------------------------------
void __fastcall __noreturn sub_384DC(int a1, int a2, int a3)
{
  sub_170EC(10, a2, a3);
  tcsetattr(buf.c_iflag, 0, (const struct termios *)&buf.c_lflag);
  exit(1);
}

//----- (00038504) --------------------------------------------------------
int __fastcall sub_38504(int a1, char **a2)
{
  int *v3; // r4
  FILE *v5; // r0
  unsigned int v6; // r10
  FILE *v7; // r8
  tcflag_t v8; // r9
  int v9; // r5
  tcflag_t v10; // r11
  int v11; // r7
  int v12; // r3
  int i; // r9
  unsigned int v15; // r3
  bool v16; // zf
  _BOOL4 v17; // r2
  bool v19; // cf
  int v20; // t1
  FILE *stream; // [sp+0h] [bp-74h]
  int v22; // [sp+4h] [bp-70h]
  unsigned int v23; // [sp+4h] [bp-70h]
  int v24; // [sp+4h] [bp-70h]

  sub_593CC(a2, "dflsu");
  v3 = (int *)&a2[optind];
  if ( !isatty(1) )
    return sub_57910(v3);
  v5 = (FILE *)sub_61C9C((int)"/dev/tty");
  stream = v5;
  if ( !v5 )
    return sub_57910(v3);
  v6 = 0;
  buf.c_iflag = fileno_unlocked(v5);
  sub_17364(buf.c_iflag, (struct termios *)&buf.c_lflag, 0);
  sub_18184((__sighandler_t)0x700F44E, (void (*)(int))sub_384DC);
  while ( 1 )
  {
    v7 = (FILE *)stdin;
    if ( *v3 )
    {
      v7 = (FILE *)sub_61C78((const char *)*v3, (int)"r");
      if ( !v7 )
        goto LABEL_42;
    }
    v8 = 0;
    v9 = -1;
    fileno_unlocked(v7);
    v10 = 0;
    sub_62E08();
    v11 = 0;
    sub_384B0();
    v12 = 0;
LABEL_8:
    if ( v11 )
    {
      --v11;
      break;
    }
    v22 = v12;
    v9 = getc_unlocked(v7);
    v12 = v22;
    if ( v9 != -1 )
      break;
    fclose(v7);
    sub_177D8();
LABEL_42:
    if ( *v3 )
    {
      v20 = v3[1];
      ++v3;
      if ( v20 )
        continue;
    }
    goto LABEL_44;
  }
  while ( !(v6 == 114 ? 0 : v12) )
  {
LABEL_25:
    if ( v9 == 9 )
      v11 = ~v10;
    ++v10;
    if ( v9 == 9 )
    {
      v9 = 32;
      v11 &= 7u;
    }
    v17 = v10 > buf.c_oflag;
    if ( v9 == 10 || v10 > buf.c_oflag )
    {
      ++v8;
      v10 = 0;
      v19 = v6 >= 0xA;
      if ( v6 != 10 )
        v19 = v8 >= buf.c_cflag;
      if ( v19 )
        v12 = 1;
    }
    if ( v9 == 10 )
      v17 = 0;
    if ( !v17 )
    {
      v24 = v12;
      putchar_unlocked(v9);
      sub_177C0();
      v12 = v24;
      goto LABEL_8;
    }
  }
  for ( i = printf("--More-- "); ; i = printf("(Enter:next line Space:next page Q:quit R:show the rest)") )
  {
    sub_177D8();
    v15 = (unsigned __int8)getc_unlocked(stream);
    if ( v15 - 65 <= 0x19 )
      v15 = (unsigned __int8)(v15 + 32);
    v6 = v15;
    v23 = v15;
    printf("\r%*s\r", i, "");
    if ( v23 == 113 )
      break;
    v16 = v23 == 10;
    if ( v23 != 10 )
      v16 = v23 == 32;
    if ( v16 || v23 == 114 )
    {
      v8 = 0;
      sub_384B0();
      v10 = 0;
      v12 = 0;
      goto LABEL_25;
    }
  }
LABEL_44:
  tcsetattr(buf.c_iflag, 0, (const struct termios *)&buf.c_lflag);
  return 0;
}
// 3862C: conditional instruction was optimized away because %var_3C.8==0
// 3860C: masking with 0x1 was optimized away because r3.4 <= 0x1
// 3874C: masking with 0x1 was optimized away because r2.4 <= 0x1
// 14230: using guessed type __int64 __fastcall ftello64(_DWORD);
// 7D604: using guessed type int optind;
// 7D610: using guessed type int stdin;

//----- (000387E4) --------------------------------------------------------
int __fastcall sub_387E4(char *s, const char **a2)
{
  int v4; // r5
  const char *v5; // r11
  int v6; // r7
  char *v7; // r0
  char *v8; // r8
  size_t v9; // r6
  int v10; // r3
  bool v11; // zf
  size_t v12; // r6
  size_t v13; // r0
  const char *v14; // r0

  v4 = 0x8000;
  while ( 2 )
  {
    v5 = "loop";
    v6 = 0;
    v7 = strchr(s, 44);
    v8 = v7;
    if ( v7 )
      *v7 = 0;
    do
    {
      v9 = strlen(v5);
      if ( !strncasecmp(v5, s, v9) && !s[v9] )
      {
        v10 = dword_638F0[v6];
        if ( v10 >= 0 )
          v4 |= v10;
        else
          v4 &= v10;
        goto LABEL_9;
      }
      ++v6;
      v5 += v9 + 1;
    }
    while ( v6 != 40 );
    v11 = *s == 0;
    if ( *s )
      v11 = a2 == 0;
    if ( !v11 )
    {
      if ( *a2 )
        v12 = strlen(*a2);
      else
        v12 = 0;
      v13 = strlen(s);
      v14 = (const char *)sub_174B4((void *)*a2, v13 + v12 + 2);
      *a2 = v14;
      if ( v12 )
        v14[v12++] = 44;
      strcpy((char *)&v14[v12], s);
    }
LABEL_9:
    if ( v8 )
    {
      *v8 = 44;
      s = v8 + 1;
      continue;
    }
    return v4;
  }
}
// 638F0: using guessed type _DWORD dword_638F0[40];

//----- (000388F8) --------------------------------------------------------
void __fastcall sub_388F8(void **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r6
  const char *v5; // r5
  size_t v6; // r5
  char *v7; // r0
  const char *v8; // r8
  const char *i; // r6
  int v10; // r3
  bool v11; // zf
  char *v12; // r0

  v3 = a2;
  if ( *a1 && *(_BYTE *)*a1 )
  {
    while ( *v3 )
    {
      v6 = strlen(v3);
      v7 = strchr(v3, 44);
      v8 = (const char *)*a1;
      if ( v7 )
        v6 = v7 - v3;
      for ( i = (const char *)*a1; ; i = v12 + 1 )
      {
        if ( !strncmp(i, v3, v6) )
        {
          v10 = (unsigned __int8)i[v6];
          v11 = v10 == 0;
          if ( i[v6] )
            v11 = v10 == 44;
          if ( v11 )
            break;
        }
        v12 = strchr(i, 44);
        if ( !v12 )
        {
          v4 = sub_177E4("%s,%.*s", v8, v6, v3);
          free(*a1);
          *a1 = v4;
          break;
        }
      }
      v5 = &v3[v6];
      do
        v3 = v5++;
      while ( *v3 == 44 );
    }
  }
  else
  {
    *a1 = sub_174F8(a2);
  }
}

//----- (000389E8) --------------------------------------------------------
int __fastcall sub_389E8(const char **a1, int a2, void *data)
{
  unsigned int v5; // r4
  int *v6; // r6
  int result; // r0
  int v8; // r3
  bool v9; // zf

  v5 = a2 & 0x9FFFFFFF;
  v6 = (int *)dword_7DB94;
  while ( 1 )
  {
    *v6 = 0;
    result = mount(*a1, a1[1], a1[2], v5, data);
    if ( !result )
      return result;
    v8 = *v6;
    if ( (v5 & 1) != 0 )
      goto LABEL_12;
    v9 = v8 == 13;
    if ( v8 != 13 )
      v9 = v8 == 30;
    if ( !v9 )
    {
LABEL_12:
      if ( v8 == 1 )
        sub_16DBC("permission denied (are you root?)");
      return result;
    }
    if ( (v5 & 0x8000) == 0 )
      sub_16DDC("%s is write-protected, mounting read-only", *a1);
    v5 |= 1u;
  }
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00038A7C) --------------------------------------------------------
int __fastcall sub_38A7C(const char **a1, char a2)
{
  char *v3; // r0
  int v4; // r6
  const char *v5; // r0
  unsigned __int8 *v6; // r7
  const char *v7; // r5
  int v8; // r3
  bool v9; // zf
  const char *v10; // r5
  size_t v11; // r0
  const char *v12; // r7
  int v13; // r8
  int v14; // r2
  char v15; // r10
  size_t v16; // r0
  int v17; // r12
  size_t v18; // r2
  const char *v19; // r0
  char *v20; // r0
  _WORD *v21; // r5
  char *v22; // r0
  char *v23; // r0
  char *v24; // r2
  const char *v25; // r7
  int v26; // r5
  int v27; // r3
  char *v28; // r0
  int v29; // r7
  int v30; // r4
  bool v31; // zf
  char *v33; // r5
  char *v34; // r7
  _WORD *v35; // r0
  char *v36; // r0
  const char *v37; // r2
  bool v38; // zf
  char *v39; // r11
  char *v40; // r0
  int v41; // r0
  bool v42; // zf
  tcflag_t c_iflag; // r8
  _DWORD *v44; // r10
  bool v45; // zf
  int v46; // r1
  int v47; // r2
  unsigned int v48; // r3
  bool v49; // cc
  const char *v50; // r0
  int v51; // r2
  bool v52; // zf
  int v53; // r3
  char *v54; // r0
  unsigned __int8 *v55; // r0
  unsigned __int8 *v56; // r11
  char *v57; // r2
  const char *v58; // [sp+0h] [bp-84h]
  FILE *v59; // [sp+8h] [bp-7Ch]
  char *haystack; // [sp+10h] [bp-74h] BYREF
  tcflag_t v62; // [sp+14h] [bp-70h] BYREF
  int v63; // [sp+28h] [bp-5Ch]

  haystack = 0;
  v3 = (char *)a1[3];
  *(_DWORD *)dword_7DB94 = 0;
  v4 = sub_387E4(v3, (const char **)&haystack);
  v5 = a1[2];
  if ( v5 && !strcmp(v5, "auto") )
    a1[2] = 0;
  v6 = (unsigned __int8 *)a1[2];
  if ( !v6 || !strcmp(a1[2], "cifs") )
  {
    v7 = *a1;
    v8 = *(unsigned __int8 *)*a1;
    v9 = v8 == 92;
    if ( v8 != 92 )
      v9 = v8 == 47;
    if ( v9 && *((unsigned __int8 *)v7 + 1) == v8 )
    {
      v10 = v7 + 2;
      v11 = strcspn(v10, "/\\");
      v12 = &v10[v11 + 1];
      if ( !v11 )
        goto LABEL_12;
      v15 = v10[v11];
      if ( !v15 || !v10[v11 + 1] )
        goto LABEL_12;
      v10[v11] = 0;
      v16 = strcspn(&v10[v11 + 1], "/\\");
      v17 = (unsigned __int8)v12[v16];
      v18 = v16;
      v58 = &v12[v16 + 1];
      v19 = "unc=\\\\%s\\%.*s,prefixpath=%s";
      if ( !v17 )
        v19 = "unc=\\\\%s\\%.*s";
      v20 = sub_177E4(v19, v10, v18, v12, v58);
      sub_387E4(v20, (const char **)&haystack);
      v21 = sub_6247C(v10, 0);
      *((_BYTE *)v12 - 1) = v15;
      if ( !v21 )
      {
LABEL_12:
        v13 = -1;
LABEL_13:
        if ( *(_DWORD *)dword_7DB94 == 16 )
          v14 = a2 & 1;
        else
          v14 = 0;
        if ( v14 )
          return 0;
        if ( v13 )
          sub_16AF4("mounting %s on %s failed", *a1, a1[1]);
        return v13;
      }
      if ( !sub_1684C((unsigned __int8 *)haystack, (int)"ip=") && !strstr(haystack, ",ip=") )
      {
        v22 = sub_6249C((const struct sockaddr *)(v21 + 2));
        v23 = sub_177E4("ip=%s", v22);
        sub_387E4(v23, (const char **)&haystack);
      }
      v24 = haystack;
      a1[2] = "cifs";
LABEL_29:
      v13 = sub_389E8(a1, v4, v24);
      goto LABEL_13;
    }
    if ( !v6 )
      goto LABEL_31;
  }
  if ( sub_1684C(v6, (int)"nfs") )
  {
LABEL_31:
    v25 = *a1;
    if ( strchr(*a1, 58) )
    {
      v33 = haystack;
      if ( !a1[2] )
        a1[2] = "nfs";
      v34 = strchr(v25, 58);
      *v34 = 0;
      v35 = sub_62484(*a1, 0);
      *v34 = 58;
      v36 = sub_6249C((const struct sockaddr *)(v35 + 2));
      v38 = v33 == 0;
      if ( v33 )
        v37 = ",";
      else
        v33 = "";
      if ( v38 )
        v37 = v33;
      v24 = sub_177E4("%s%saddr=%s", v33, v37, v36);
      goto LABEL_29;
    }
  }
  v26 = sub_62DFC();
  if ( v26 )
  {
    v26 = 0;
    goto LABEL_58;
  }
  if ( (v4 & 0x3020) != 0 )
  {
LABEL_58:
    v29 = -1;
LABEL_59:
    if ( a1[2] || (v4 & 0x3020) != 0 )
    {
      while ( 1 )
      {
        v39 = (char *)a1[2];
        if ( v39 )
        {
          v40 = strchr(a1[2], 44);
          v39 = v40;
          if ( v40 )
            *v40 = 0;
        }
        v41 = sub_389E8(a1, v4, haystack);
        v42 = v39 == 0;
        if ( v39 )
          v42 = v41 == 0;
        v13 = v41;
        if ( v42 )
          break;
        a1[2] = v39 + 1;
      }
    }
    else
    {
      c_iflag = buf.c_iflag;
      if ( !buf.c_iflag )
      {
        v62 = 0;
        while ( 1 )
        {
          v59 = (FILE *)sub_61C9C((int)&aEtcFilesystems[18 * c_iflag]);
          if ( v59 )
          {
            while ( 1 )
            {
              v55 = sub_58D24(v59, v46, v47);
              v56 = v55;
              if ( !v55 )
                break;
              if ( !sub_1684C(v55, (int)"nodev") )
                goto LABEL_87;
              v48 = v56[5];
              v49 = v48 > 0x20;
              if ( v48 != 32 )
                v49 = v48 - 9 > 4;
              if ( v49 )
              {
LABEL_87:
                v50 = (const char *)sub_60E74(v56);
                v51 = *(unsigned __int8 *)v50;
                v52 = v51 == 42;
                if ( v51 != 42 )
                  v52 = v51 == 35;
                v53 = v52;
                if ( !*v50 )
                  v53 = 1;
                if ( !v53 )
                {
                  v54 = sub_174F8(v50);
                  sub_5D2C8(&v62, (int)v54);
                }
              }
              free(v56);
            }
          }
          if ( c_iflag == 1 )
            break;
          c_iflag = 1;
        }
        buf.c_iflag = v62;
      }
      v44 = (_DWORD *)buf.c_iflag;
      v13 = -1;
      while ( v44 )
      {
        v57 = haystack;
        a1[2] = (const char *)v44[1];
        v13 = sub_389E8(a1, v4, v57);
        if ( !v13 )
          break;
        v44 = (_DWORD *)*v44;
      }
    }
    v45 = v13 == 0;
    if ( v13 )
      v45 = v26 == 0;
    if ( !v45 )
      sub_5D55C((int)*a1);
    if ( v29 != -1 )
      close(v29);
    goto LABEL_13;
  }
  v27 = v63 & 0xF000;
  if ( v27 != 0x8000 )
  {
    v26 = (int)a1[2];
    if ( v27 != 0x4000 || v26 )
      v26 = v4 & 0x3020;
    else
      v4 |= 0x1000u;
    goto LABEL_58;
  }
  v28 = sub_60DE0((char *)*a1);
  *a1 = (const char *)(v4 & 0x3020);
  v26 = (int)v28;
  v29 = sub_5D594((char **)a1, v28, 0, 0, v4 & 1 | 4);
  if ( v29 >= 0 )
    goto LABEL_59;
  v30 = dword_7DB94;
  v31 = *(_DWORD *)dword_7DB94 == 13;
  if ( *(_DWORD *)dword_7DB94 != 13 )
    v31 = *(_DWORD *)dword_7DB94 == 1;
  if ( v31 )
    sub_16DDC("permission denied (are you root?)");
  else
    sub_16AF4("can't setup loop device");
  return *(_DWORD *)v30;
}
// 38D7C: variable 'v37' is possibly undefined
// 38F10: variable 'v46' is possibly undefined
// 38F10: variable 'v47' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;

//----- (00038F94) --------------------------------------------------------
int __fastcall sub_38F94(int a1, char **a2)
{
  char **v3; // r5
  int v4; // r4
  char *v5; // r1
  char *v6; // t1
  char v7; // r4
  int v8; // r10
  char *v9; // r8
  FILE *v10; // r5
  int v11; // r7
  const char *v13; // r0
  char *mnt_type; // r4
  struct mntent *v15; // r0
  unsigned int v16; // r0
  struct mntent *v17; // r4
  struct mntent *v18; // r5
  char *i; // r2
  const char *v20; // r1
  const char *v21; // r9
  const char *mnt_fsname; // r11
  const char *mnt_dir; // r11
  int v24; // r5
  int v25; // r11
  int v26; // r0
  const char *v27; // r9
  size_t v28; // r3
  int v29; // r0
  int v30; // r2
  bool v31; // zf
  char *v32; // r0
  char *v33; // r0
  char *v34; // r1
  char *s1; // [sp+Ch] [bp-60h]
  _BYTE *v36; // [sp+10h] [bp-5Ch]
  const char **v37; // [sp+14h] [bp-58h]
  FILE *stream; // [sp+18h] [bp-54h]
  size_t v39; // [sp+1Ch] [bp-50h]
  char *s; // [sp+24h] [bp-48h] BYREF
  char *s2; // [sp+28h] [bp-44h] BYREF
  int v42; // [sp+2Ch] [bp-40h] BYREF
  _DWORD *v43; // [sp+30h] [bp-3Ch] BYREF
  char *file; // [sp+34h] [bp-38h] BYREF
  struct mntent result[2]; // [sp+38h] [bp-34h] BYREF

  v3 = a2;
  v4 = 1;
  s = (char *)sub_174DC(1u);
  s2 = 0;
  v42 = 0;
  v43 = 0;
  file = "/etc/fstab";
  sub_5D500();
  while ( 1 )
  {
    v6 = v3[1];
    ++v3;
    v5 = v6;
    if ( !v6 )
      break;
    if ( *v5 == 45 && v5[1] == 45 )
      sub_388F8((void **)&s, v5 + 2);
    else
      a2[v4++] = v5;
  }
  a2[v4] = 0;
  v7 = sub_593CC(a2, "^o:*t:rwanfvsiO:T:", &v43, &s2, &v42, &file);
  while ( v43 )
  {
    v13 = (const char *)sub_5D2FC(&v43);
    sub_388F8((void **)&s, v13);
  }
  if ( (v7 & 4) != 0 )
    sub_388F8((void **)&s, "ro");
  if ( (v7 & 8) != 0 )
    sub_388F8((void **)&s, "rw");
  v8 = optind;
  v9 = a2[optind];
  v37 = (const char **)&a2[optind];
  if ( v9 )
  {
    if ( a2[optind + 1] )
    {
      result[0].mnt_dir = a2[optind + 1];
      v15 = result;
      result[0].mnt_fsname = v9;
      result[0].mnt_type = s2;
      result[0].mnt_opts = s;
      return sub_38A7C((const char **)&v15->mnt_fsname, 0);
    }
    v9 = sub_60DE0(v9);
  }
  else if ( (v7 & 0x10) == 0 )
  {
    v10 = setmntent("/proc/mounts", "r");
    if ( !v10 )
      sub_16DBC("no %s", "/proc/mounts");
    while ( getmntent_r(v10, result, (char *)&buf.c_oflag, 1020) )
    {
      mnt_type = result[0].mnt_type;
      if ( !s2 || !strcmp(result[0].mnt_type, s2) )
        printf("%s on %s type %s (%s)\n", result[0].mnt_fsname, result[0].mnt_dir, mnt_type, result[0].mnt_opts);
    }
    return 0;
  }
  v16 = sub_387E4(s, 0);
  if ( (v16 & 0x1E0000) != 0 )
  {
    if ( mount("", a2[v8], "", v16, "") )
      sub_16B90(a2[v8]);
    return 0;
  }
  if ( (v16 & 0x20) != 0 )
    file = "/proc/mounts";
  stream = setmntent(file, "r");
  if ( !stream )
    sub_16B40("can't read '%s'", file);
  v17 = result;
  v11 = 0;
  memset(result, 0, sizeof(result));
LABEL_36:
  v18 = &result[1];
  for ( i = (_BYTE *)(&dword_7D990 + 2); getmntent_r(stream, v17, i, 510); i = (char *)&buf.c_oflag )
  {
    v21 = *v37;
    if ( *v37 )
    {
      mnt_fsname = v17->mnt_fsname;
      if ( !strcmp(*v37, v17->mnt_fsname) || !strcmp(v9, mnt_fsname) || (mnt_dir = v17->mnt_dir, !strcmp(v21, mnt_dir)) )
      {
        v17 = v18;
      }
      else if ( !strcmp(v9, mnt_dir) )
      {
        v17 = v18;
      }
    }
    else if ( sub_5D9F8((int)v17->mnt_type, (unsigned __int8 *)s2)
           && (sub_387E4(v17->mnt_opts, 0) & 0x60000000) == 0
           && strcasecmp(v17->mnt_type, "swap") )
    {
      v24 = v42;
      s1 = v17->mnt_opts;
      if ( v42 )
      {
        while ( *(_BYTE *)v24 )
        {
          if ( *(_BYTE *)v24 == 110 && *(_BYTE *)(v24 + 1) == 111 )
          {
            v24 += 2;
            v25 = 1;
            v26 = strchrnul((const char *)v24, 44);
          }
          else
          {
            v25 = 0;
            v26 = strchrnul((const char *)v24, 44);
          }
          v27 = s1;
          v28 = v26 - v24;
          v36 = (_BYTE *)v26;
          while ( 1 )
          {
            v39 = v28;
            v29 = strncmp(v27, (const char *)v24, v28);
            v28 = v39;
            if ( !v29 )
            {
              v30 = (unsigned __int8)v27[v39];
              v31 = v30 == 44;
              if ( v30 != 44 )
                v31 = v30 == 0;
              if ( v31 )
              {
                if ( v25 )
                  goto LABEL_38;
                goto LABEL_71;
              }
            }
            v32 = strchr(v27, 44);
            v28 = v39;
            if ( !v32 )
              break;
            v27 = v32 + 1;
          }
          if ( !v25 )
            goto LABEL_38;
LABEL_71:
          if ( !*v36 )
            break;
          v24 += v28 + 1;
        }
      }
      v17->mnt_opts = sub_174F8(s1);
      if ( !sub_58A20(v17->mnt_dir, 0) && sub_38A7C((const char **)&v17->mnt_fsname, 1) )
        ++v11;
      free(v17->mnt_opts);
    }
LABEL_38:
    v18 = result;
    if ( v17 == result )
      goto LABEL_36;
  }
  v20 = a2[v8];
  if ( v20 )
  {
    if ( !v18->mnt_fsname )
      sub_16DBC("can't find %s in %s", v20, file);
    v33 = sub_174F8(v18->mnt_opts);
    v34 = s;
    v18->mnt_opts = v33;
    sub_388F8((void **)&v18->mnt_opts, v34);
    v15 = v18;
    return sub_38A7C((const char **)&v15->mnt_fsname, 0);
  }
  return v11;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7D604: using guessed type int optind;
// 7D990: using guessed type int dword_7D990;

//----- (0003948C) --------------------------------------------------------
void __fastcall __noreturn sub_3948C(int a1, char **a2)
{
  unsigned int v3; // r4
  const char **v4; // r0

  if ( *(_BYTE *)(dword_7DB90 + 5) == 54 )
    v3 = 0;
  else
    v3 = 8;
  if ( sub_593CC(a2, "+R") )
    v3 |= 0x40000u;
  if ( personality(v3) < 0 )
    sub_16B40("personality(0x%lx)", v3);
  v4 = (const char **)&a2[optind];
  if ( !*v4 )
    *--v4 = "/bin/sh";
  sub_58840(v4);
}
// 7D604: using guessed type int optind;
// 7DB90: using guessed type int dword_7DB90;

//----- (00039514) --------------------------------------------------------
unsigned int __fastcall sub_39514(const char *a1, unsigned int a2)
{
  int v2; // r3

  v2 = *(unsigned __int8 *)a1;
  if ( v2 != 43 && v2 != 45 )
    sub_16DBC("invalid capability '%s'", a1);
  return sub_57BB4(a1 + 1, a2);
}

//----- (00039544) --------------------------------------------------------
void __fastcall __noreturn sub_39544(int a1, char **a2)
{
  char v3; // r5
  int v4; // r6
  const char **v5; // r7
  char *v6; // r8
  unsigned int v7; // r1
  char *i; // r11
  unsigned int v9; // r0
  _BYTE *v10; // r3
  int v11; // r0
  int v12; // r2
  int v13; // r0
  unsigned int v14; // r1
  char *j; // r5
  unsigned int v16; // r2
  char *v17; // [sp+Ch] [bp-30h] BYREF
  char *s; // [sp+10h] [bp-2Ch] BYREF
  int v19[3]; // [sp+14h] [bp-28h] BYREF
  _BYTE v20[28]; // [sp+20h] [bp-1Ch] BYREF

  v3 = sub_593F8(a2, asc_68F41, "nnp", &v17, &s);
  v4 = optind;
  v5 = (const char **)&a2[optind];
  if ( (v3 & 4) != 0 && prctl(38, 1, 0) )
    sub_16B40("prctl: %s", "SET_NO_NEW_PRIVS");
  if ( (v3 & 1) != 0 )
  {
    v6 = v17;
    sub_57C28(v19);
    for ( i = strtok(v6, ","); i; i = strtok(0, ",") )
    {
      v9 = sub_39514(i, v7);
      if ( v9 >> 5 >= v19[2] )
        sub_16DBC("invalid capability '%s'", i);
      v10 = &v20[12 * (v9 >> 5) + 24];
      v11 = 1 << (v9 & 0x1F);
      v12 = *((_DWORD *)v10 - 4);
      if ( *i == 43 )
        v13 = v11 | v12;
      else
        v13 = v12 & ~v11;
      *((_DWORD *)v10 - 4) = v13;
    }
    if ( capset(v19, v20) )
      sub_16B40("capset");
  }
  if ( (v3 & 2) != 0 )
  {
    for ( j = strtok(s, ","); j; j = strtok(0, ",") )
    {
      v16 = sub_39514(j, v14);
      if ( *j == 43 )
      {
        if ( prctl(47, 2, v16) < 0 )
          sub_16AF4("cap_ambient_raise");
      }
      else if ( prctl(47, 3, v16) < 0 )
      {
        sub_16AF4("cap_ambient_lower");
      }
    }
  }
  if ( a2[v4] )
    sub_58840(v5);
  sub_162F0();
}
// 39608: variable 'v7' is possibly undefined
// 396A8: variable 'v14' is possibly undefined
// 14030: using guessed type int __fastcall capset(_DWORD, _DWORD);
// 7D604: using guessed type int optind;

//----- (0003973C) --------------------------------------------------------
int __fastcall sub_3973C(int a1, char **a2)
{
  int v3; // r5
  char v4; // r6
  int v5; // r7
  FILE *v6; // r8
  const char **v7; // r11
  _DWORD *v8; // r10
  int i; // r4
  int v10; // r9
  int v11; // r3
  const char *v12; // r7
  char *v13; // r8
  const char *v14; // r0
  _BOOL4 v15; // r3
  int v16; // r0
  bool v17; // zf
  const char *v18; // r0
  bool j; // zf
  unsigned __int8 *v21; // [sp+14h] [bp-20h] BYREF
  struct mntent result; // [sp+18h] [bp-1Ch] BYREF

  v3 = 0;
  v21 = 0;
  v4 = sub_593CC(a2, "fldnrat:cvi", &v21);
  v5 = optind;
  v6 = setmntent("/proc/mounts", "r");
  v7 = (const char **)&a2[v5];
  if ( v6 )
  {
    while ( getmntent_r(v6, &result, (char *)&buf, 1024) )
    {
      if ( sub_5D9F8((int)result.mnt_type, v21) )
      {
        v8 = sub_174DC(0xCu);
        v8[2] = v3;
        v3 = (int)v8;
        v8[1] = sub_174F8(result.mnt_fsname);
        *v8 = sub_174F8(result.mnt_dir);
      }
    }
    endmntent(v6);
  }
  else
  {
    v3 = v4 & 0x20;
    if ( (v4 & 0x20) != 0 )
      sub_16DBC("can't open '%s'", "/proc/mounts");
  }
  if ( (v4 & 0x20) != 0 )
  {
    i = v3;
  }
  else
  {
    if ( !a2[v5] )
      sub_162F0();
    i = v4 & 0x20;
  }
  v10 = 0;
  while ( 1 )
  {
    v11 = v4 & 0x20;
    v12 = *v7;
    if ( (v4 & 0x20) != 0 )
      v11 = 1;
    if ( i )
    {
      v13 = sub_174F8(*(const char **)i);
LABEL_19:
      v12 = *(const char **)i;
      goto LABEL_24;
    }
    if ( !v12 )
      v11 = 1;
    if ( v11 )
      return v10;
    v14 = *v7++;
    v13 = sub_17CF0(v14);
    if ( v13 )
    {
      for ( i = v3; i; i = *(_DWORD *)(i + 8) )
      {
        if ( !strcmp(v13, *(const char **)i) || !strcmp(v13, *(const char **)(i + 4)) )
          goto LABEL_19;
      }
    }
LABEL_24:
    if ( umount2(v12, v4 & 3) )
    {
      if ( (v4 & 0x10) != 0 )
      {
        v15 = *(_DWORD *)dword_7DB94 == 16;
        if ( !i )
          v15 = 0;
        if ( v15 )
        {
          v16 = mount(*(const char **)(i + 4), v12, 0, 0x21u, 0);
          v17 = v16 == 0;
          if ( v16 )
            v10 = 1;
          v18 = "%s busy - remounted read-only";
          if ( !v17 )
            v18 = "can't remount %s read-only";
          sub_16DDC(v18, *(_DWORD *)(i + 4));
          goto LABEL_34;
        }
      }
      v10 = 1;
      sub_16AF4("can't unmount %s", v12);
    }
    else if ( (v4 & 4) != 0 )
    {
      if ( i )
      {
        sub_5D55C(*(_DWORD *)(i + 4));
        goto LABEL_34;
      }
      goto LABEL_47;
    }
    for ( j = i == 0; !j; j = strcmp(v13, *(const char **)(i + 4)) == 0 )
    {
LABEL_34:
      i = *(_DWORD *)(i + 8);
      if ( !i || (v4 & 0x20) != 0 )
        break;
    }
LABEL_47:
    free(v13);
  }
}
// 7D604: using guessed type int optind;
// 7DB94: using guessed type int dword_7DB94;

//----- (000399D0) --------------------------------------------------------
int __fastcall sub_399D0(int result, int a2, int a3, int a4)
{
  int *v4; // r1
  int *v5; // r2

  v4 = (int *)(result + 4 * a2);
  v5 = (int *)(result + 4 * a3);
  while ( a4 > 0 )
  {
    result = *v4;
    --a4;
    *v4++ = *v5;
    *v5++ = result;
  }
  return result;
}

//----- (000399F8) --------------------------------------------------------
int __fastcall sub_399F8(_DWORD *a1)
{
  int v1; // r5
  int v2; // r3
  unsigned __int8 *v3; // r8
  int v4; // r6
  unsigned __int8 *i; // r1
  int j; // r3
  int v7; // r1
  int k; // r3
  int m; // r3
  int v10; // r3
  int v11; // r1
  int n; // r1
  int v13; // r0
  int result; // r0
  char v15; // r2
  int v16; // lr
  int v17; // r1
  int v18; // r3
  int ii; // r4
  int jj; // r3
  int *v21; // r3
  int v22; // r9
  int v23; // r10
  _DWORD *v24; // r1
  int kk; // r3
  int v26; // r3
  int v27; // r1
  int v28; // t1
  int *v29; // r0
  int v30; // r1
  int v31; // r2
  int v32; // r2
  int v33; // r3
  _DWORD *v34; // r2
  int v35; // r12
  _DWORD *v36; // r1
  unsigned int v37; // r11
  int v38; // lr
  int v39; // t1
  int v40; // r12
  int v41; // t1
  unsigned int v42; // r7
  _DWORD *mm; // r2
  int v44; // lr
  int v45; // r1
  int v46; // r3
  int v47; // r2
  int *v48; // r3
  int v49; // lr
  int v50; // r11
  int v51; // r7
  int *v52; // r1
  int v53; // r0
  int v54; // t1
  bool v55; // cc
  int v56; // r3
  int v57; // r7
  int v58; // r3
  int v59; // r7
  int v60; // r11
  int v61; // r3
  int *v62; // r2
  int v63; // r3
  int v64; // r1
  _BOOL4 v65; // r3
  int v66; // r3
  int nn; // r2
  int v68; // r1
  int v69; // r1
  int v70; // [sp+4h] [bp-B58h]
  int v71; // [sp+8h] [bp-B54h]
  _DWORD *v72; // [sp+Ch] [bp-B50h]
  int v73; // [sp+Ch] [bp-B50h]
  int v74; // [sp+10h] [bp-B4Ch]
  int v75; // [sp+14h] [bp-B48h]
  int v76; // [sp+18h] [bp-B44h]
  int v77; // [sp+1Ch] [bp-B40h]
  int v78; // [sp+20h] [bp-B3Ch]
  int v79; // [sp+24h] [bp-B38h]
  unsigned __int16 v80; // [sp+28h] [bp-B34h]
  int *v81; // [sp+2Ch] [bp-B30h]
  int v82; // [sp+34h] [bp-B28h]
  int v83; // [sp+1C4h] [bp-998h]
  _DWORD v84[255]; // [sp+354h] [bp-808h]
  _DWORD v85[255]; // [sp+754h] [bp-408h]
  int v86; // [sp+B58h] [bp-4h] BYREF

  v1 = a1[2];
  v70 = a1[13];
  v2 = 0;
  v3 = (unsigned __int8 *)a1[3];
  v4 = a1[4];
  do
    v85[v2++] = 0;
  while ( v2 != 257 );
  for ( i = v3; v70 > i - v3; ++i )
  {
    v28 = *i;
    ++v85[v28];
  }
  for ( j = 0; j != 256; ++j )
    v84[j] = v85[j];
  v7 = v85[0];
  for ( k = 1; k != 257; ++k )
  {
    v7 += v85[k];
    v85[k] = v7;
  }
  for ( m = 0; m < v70; ++m )
  {
    v29 = &v86 + v3[m];
    v30 = *(v29 - 257) - 1;
    *(_DWORD *)(v1 + 4 * v30) = m;
    *(v29 - 257) = v30;
  }
  v10 = v70;
  v11 = 0;
  do
    *(_DWORD *)(v4 + 4 * v11++) = 0;
  while ( (int)(((unsigned int)v70 >> 5) + 2) > v11 );
  for ( n = 0; n != 256; ++n )
  {
    v13 = v85[n];
    *(_DWORD *)(v4 + 4 * (v13 >> 5)) |= 1 << (v13 & 0x1F);
  }
  result = 1;
  do
  {
    *(_DWORD *)(v4 + 4 * (v10 >> 5)) |= 1 << (v10 & 0x1F);
    v15 = v10 + 1;
    v16 = (v10 + 1) >> 5;
    v10 += 2;
    *(_DWORD *)(v4 + 4 * v16) &= ~(1 << (v15 & 0x1F));
  }
  while ( v70 + 64 != v10 );
  v77 = 1;
  do
  {
    v17 = 0;
    v18 = 0;
    while ( v18 < v70 )
    {
      v31 = *(_DWORD *)(v1 + 4 * v18);
      result = v77;
      if ( (*(_DWORD *)(v4 + 4 * (v18 >> 5)) & (1 << (v18 & 0x1F))) != 0 )
        v17 = v18;
      ++v18;
      v32 = v31 - v77;
      if ( v32 < 0 )
      {
        result = v70;
        v32 += v70;
      }
      *(_DWORD *)&v3[4 * v32] = v17;
    }
    v79 = 0;
    v74 = -1;
LABEL_21:
    while ( 2 )
    {
      for ( ii = v74 + 1; (*(_DWORD *)(v4 + 4 * (ii >> 5)) & (1 << (ii & 0x1F))) != 0; ++ii )
      {
        if ( (ii & 0x1F) == 0 )
        {
          while ( *(_DWORD *)(v4 + 4 * (ii >> 5)) == -1 )
            ii += 32;
          while ( (*(_DWORD *)(v4 + 4 * (ii >> 5)) & (1 << (ii & 0x1F))) != 0 )
            ++ii;
          break;
        }
      }
      v71 = ii - 1;
      if ( v70 > ii - 1 )
      {
        while ( (*(_DWORD *)(v4 + 4 * (ii >> 5)) & (1 << (ii & 0x1F))) == 0 )
        {
          if ( (ii & 0x1F) == 0 )
          {
            while ( !*(_DWORD *)(v4 + 4 * (ii >> 5)) )
              ii += 32;
            while ( (*(_DWORD *)(v4 + 4 * (ii >> 5)) & (1 << (ii & 0x1F))) == 0 )
              ++ii;
            break;
          }
          ++ii;
        }
        v74 = ii - 1;
        if ( v70 > ii - 1 )
        {
          if ( v71 >= ii - 1 )
            continue;
          v79 += ii - v71;
          v82 = v71;
          v83 = ii - 1;
          v80 = 0;
          for ( jj = 1; ; jj = v75 )
          {
            v78 = jj;
            v75 = jj - 1;
            v21 = &v86 + jj - 1;
            v22 = *(v21 - 713);
            v23 = *(v21 - 613);
            if ( v23 - v22 > 9 )
            {
              v80 = (7621 * v80 + 1) & 0x7FFF;
              result = sub_15EFC(v80, 3u);
              if ( v45 )
              {
                if ( v45 == 1 )
                  v46 = v22 + v23;
                else
                  v46 = *(_DWORD *)(v1 + 4 * v23);
                if ( v45 == 1 )
                  v46 = *(_DWORD *)(v1 + 4 * (v46 >> 1));
              }
              else
              {
                v46 = *(_DWORD *)(v1 + 4 * v22);
              }
              v47 = *(_DWORD *)&v3[4 * v46];
              v48 = (int *)(v1 + 4 * v22);
              v49 = v22 + 1;
              v73 = v23;
              v50 = v22;
              v51 = v23;
              while ( 1 )
              {
                v76 = v49 - 1;
                if ( v51 < v49 - 1 )
                  break;
                result = *v48;
                if ( *(_DWORD *)&v3[4 * *v48] == v47 )
                {
                  *v48 = *(_DWORD *)(v1 + 4 * v50);
                  *(_DWORD *)(v1 + 4 * v50++) = result;
                  goto LABEL_81;
                }
                if ( *(_DWORD *)&v3[4 * *v48] - v47 > 0 )
                {
                  v52 = (int *)(v1 + 4 * v51);
                  while ( 1 )
                  {
                    v81 = v52;
                    --v51;
                    v54 = *v52--;
                    v53 = v54;
                    v55 = *(_DWORD *)&v3[4 * v54] - v47 < 0;
                    if ( *(_DWORD *)&v3[4 * v54] == v47 )
                    {
                      v52[1] = *(_DWORD *)(v1 + 4 * v73);
                      *(_DWORD *)(v1 + 4 * v73--) = v53;
                    }
                    else if ( v55 )
                    {
                      v64 = *v48;
                      *v48 = v53;
                      result = (int)v81;
                      *v81 = v64;
                      break;
                    }
                    result = v49 - 1;
                    if ( v76 > v51 )
                      goto LABEL_88;
                  }
                }
LABEL_81:
                ++v49;
                ++v48;
              }
LABEL_88:
              if ( v50 <= v73 )
              {
                v56 = v50 - v22;
                if ( v50 - v22 >= v76 - v50 )
                  v56 = v76 - v50;
                sub_399D0(v1, v22, v76 - v56, v56);
                v57 = v73 - v51;
                v58 = v23 - v73;
                if ( v23 - v73 >= v57 )
                  v58 = v57;
                v59 = v23 - v57 + 1;
                sub_399D0(v1, v76, v23 - v58 + 1, v58);
                result = (int)&v86;
                v60 = v22 + v76 - v50 - 1;
                v61 = v75;
                v75 = v78 + 1;
                v62 = &v86 + v61;
                if ( v60 - v22 > v23 - v59 )
                {
                  *(v62 - 613) = v60;
                  v62 = &v86;
                }
                v63 = 4 * v78;
                if ( v60 - v22 > v23 - v59 )
                {
                  v63 += (int)v62;
                }
                else
                {
                  *(v62 - 713) = v59;
                  v62 = &v86;
                }
                if ( v60 - v22 > v23 - v59 )
                {
                  *(_DWORD *)(v63 - 2852) = v59;
                  *(_DWORD *)(v63 - 2452) = v23;
                }
                else
                {
                  v63 += (int)v62;
                }
                if ( v60 - v22 <= v23 - v59 )
                {
                  *(_DWORD *)(v63 - 2852) = v22;
                  *(_DWORD *)(v63 - 2452) = v60;
                }
                continue;
              }
            }
            else if ( v22 != v23 )
            {
              if ( v23 - v22 > 3 )
              {
                v33 = v23 - 4;
                v34 = (_DWORD *)(v1 + 4 * (v23 - 4));
                while ( v22 <= v33 )
                {
                  v35 = *v34;
                  result = v33 + 4;
                  v36 = v34;
                  v37 = *(_DWORD *)&v3[4 * *v34];
                  while ( 1 )
                  {
                    v72 = v36;
                    if ( v23 < result )
                      break;
                    v39 = v36[4];
                    v36 += 4;
                    v38 = v39;
                    if ( v37 <= *(_DWORD *)&v3[4 * v39] )
                      break;
                    *(v36 - 4) = v38;
                    result += 4;
                  }
                  --v33;
                  --v34;
                  *v72 = v35;
                }
              }
              v24 = (_DWORD *)(v1 + 4 * v23);
              for ( kk = v23 - 1; v22 <= kk; --kk )
              {
                v41 = *--v24;
                v40 = v41;
                result = kk + 1;
                v42 = *(_DWORD *)&v3[4 * v41];
                for ( mm = v24; v23 >= result; ++mm )
                {
                  v44 = mm[1];
                  if ( v42 <= *(_DWORD *)&v3[4 * v44] )
                    break;
                  *mm = v44;
                  ++result;
                }
                *mm = v40;
              }
            }
            if ( !v75 )
            {
              v26 = -1;
              do
              {
                v27 = *(_DWORD *)&v3[4 * *(_DWORD *)(v1 + 4 * v71)];
                if ( v26 != v27 )
                {
                  result = v71 >> 5;
                  *(_DWORD *)(v4 + 4 * (v71 >> 5)) |= 1 << (v71 & 0x1F);
                }
                ++v71;
                v26 = v27;
              }
              while ( ii != v71 );
              goto LABEL_21;
            }
          }
        }
      }
      break;
    }
    v77 *= 2;
    v65 = v79 == 0;
    if ( v70 < v77 )
      v65 = 1;
  }
  while ( !v65 );
  v66 = 0;
  for ( nn = 0; nn < v70; ++nn )
  {
    while ( 1 )
    {
      v68 = v84[v66];
      if ( v68 )
        break;
      ++v66;
    }
    result = (int)(&v86 + v66);
    *(_DWORD *)(result - 2052) = v68 - 1;
    v69 = *(_DWORD *)(v1 + 4 * nn);
    v3[v69] = v66;
  }
  return result;
}
// 39E94: variable 'v45' is possibly undefined

//----- (0003A0CC) --------------------------------------------------------
bool __fastcall sub_3A0CC(_DWORD *a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r6
  unsigned int v5; // r12
  unsigned int v6; // r3
  unsigned int v7; // r5
  bool v8; // cc
  unsigned __int8 *v10; // lr
  unsigned __int8 *v11; // r12
  unsigned int v12; // r7
  unsigned int v13; // r3
  unsigned int v14; // r7
  unsigned int v15; // r3
  unsigned int v16; // r7
  unsigned int v17; // r3
  unsigned int v18; // r7
  unsigned int v19; // r3
  unsigned int v20; // r7
  unsigned int v21; // r3
  unsigned int v22; // r7
  unsigned int v23; // r3
  unsigned int v24; // r7
  unsigned int v25; // r3
  unsigned int v26; // r7
  unsigned int v27; // r3
  unsigned int v28; // r3
  unsigned int v29; // r7
  unsigned int v30; // r7
  unsigned int v31; // r3
  unsigned int v32; // lr
  unsigned int v33; // r3
  unsigned int v34; // r1
  unsigned int v35; // r2
  int v36; // r8
  unsigned int v37; // r12
  unsigned int v38; // r3
  unsigned int v39; // r7
  unsigned int v40; // r3
  unsigned __int8 *v41; // r7
  unsigned __int8 *v42; // r3
  unsigned int v43; // r10
  unsigned int v44; // r9
  unsigned __int16 *v45; // lr
  unsigned __int16 *v46; // r12
  unsigned int v47; // r10
  unsigned int v48; // r9
  unsigned int v49; // r10
  unsigned int v50; // r9
  unsigned int v51; // r10
  unsigned int v52; // r9
  unsigned int v53; // r10
  unsigned int v54; // r9
  unsigned int v55; // r10
  unsigned int v56; // r9
  unsigned int v57; // r7
  unsigned int v58; // r3
  int v59; // r7
  int v60; // r3
  unsigned int v61; // r10
  unsigned int v62; // r9
  unsigned int v63; // r10
  unsigned int v64; // r9
  unsigned int v65; // r10
  unsigned int v66; // r9
  unsigned int v67; // r10
  unsigned int v68; // r9
  unsigned int v69; // r7
  unsigned int v70; // r3
  unsigned int v71; // lr
  unsigned int v72; // r3

  v3 = a1[8];
  v4 = a1[5];
  v5 = *(unsigned __int8 *)(v3 + a2);
  v6 = *(unsigned __int8 *)(v3 + a3);
  v7 = a1[13];
  v8 = v5 > v6;
  if ( v5 == v6 )
  {
    v10 = (unsigned __int8 *)(v3 + a2);
    v11 = (unsigned __int8 *)(v3 + a3);
    v12 = *(unsigned __int8 *)(v3 + a2 + 1);
    v13 = *(unsigned __int8 *)(v3 + a3 + 1);
    v8 = v12 > v13;
    if ( v12 == v13 )
    {
      v14 = v10[2];
      v15 = v11[2];
      v8 = v14 > v15;
      if ( v14 == v15 )
      {
        v16 = v10[3];
        v17 = v11[3];
        v8 = v16 > v17;
        if ( v16 == v17 )
        {
          v18 = v10[4];
          v19 = v11[4];
          v8 = v18 > v19;
          if ( v18 == v19 )
          {
            v20 = v10[5];
            v21 = v11[5];
            v8 = v20 > v21;
            if ( v20 == v21 )
            {
              v22 = v10[6];
              v23 = v11[6];
              v8 = v22 > v23;
              if ( v22 == v23 )
              {
                v24 = v10[7];
                v25 = v11[7];
                v8 = v24 > v25;
                if ( v24 == v25 )
                {
                  v26 = v10[8];
                  v27 = v11[8];
                  v8 = v26 > v27;
                  if ( v26 == v27 )
                  {
                    v28 = v10[9];
                    v29 = v11[9];
                    if ( v28 != v29 )
                      return v28 > v29;
                    v30 = v10[10];
                    v31 = v11[10];
                    v8 = v30 > v31;
                    if ( v30 == v31 )
                    {
                      v32 = v10[11];
                      v33 = v11[11];
                      v8 = v32 > v33;
                      if ( v32 == v33 )
                      {
                        v34 = a2 + 12;
                        v35 = a3 + 12;
                        v36 = v7 + 8;
                        while ( 1 )
                        {
                          v37 = *(unsigned __int8 *)(v3 + v34);
                          v38 = *(unsigned __int8 *)(v3 + v35);
                          v8 = v37 > v38;
                          if ( v37 != v38 )
                            break;
                          v39 = *(unsigned __int16 *)(v4 + 2 * v34);
                          v40 = *(unsigned __int16 *)(v4 + 2 * v35);
                          v8 = v39 > v40;
                          if ( v39 != v40 )
                            break;
                          v41 = (unsigned __int8 *)(v3 + v34);
                          v42 = (unsigned __int8 *)(v3 + v35);
                          v43 = *(unsigned __int8 *)(v3 + v34 + 1);
                          v44 = *(unsigned __int8 *)(v3 + v35 + 1);
                          v8 = v43 > v44;
                          if ( v43 != v44 )
                            break;
                          v45 = (unsigned __int16 *)(v4 + 2 * v34);
                          v46 = (unsigned __int16 *)(v4 + 2 * v35);
                          v47 = v45[1];
                          v48 = v46[1];
                          v8 = v47 > v48;
                          if ( v47 != v48 )
                            break;
                          v49 = v41[2];
                          v50 = v42[2];
                          v8 = v49 > v50;
                          if ( v49 != v50 )
                            break;
                          v51 = v45[2];
                          v52 = v46[2];
                          v8 = v51 > v52;
                          if ( v51 != v52 )
                            break;
                          v53 = v41[3];
                          v54 = v42[3];
                          v8 = v53 > v54;
                          if ( v53 != v54 )
                            break;
                          v55 = v45[3];
                          v56 = v46[3];
                          v8 = v55 > v56;
                          if ( v55 != v56 )
                            break;
                          v57 = v41[4];
                          v58 = v42[4];
                          v8 = v57 > v58;
                          if ( v57 != v58 )
                            break;
                          v28 = v45[4];
                          v29 = v46[4];
                          if ( v28 != v29 )
                            return v28 > v29;
                          v59 = v3 + v34;
                          v60 = v3 + v35;
                          v61 = *(unsigned __int8 *)(v3 + v34 + 5);
                          v62 = *(unsigned __int8 *)(v3 + v35 + 5);
                          v8 = v61 > v62;
                          if ( v61 != v62 )
                            break;
                          v63 = v45[5];
                          v64 = v46[5];
                          v8 = v63 > v64;
                          if ( v63 != v64 )
                            break;
                          v65 = *(unsigned __int8 *)(v59 + 6);
                          v66 = *(unsigned __int8 *)(v60 + 6);
                          v8 = v65 > v66;
                          if ( v65 != v66 )
                            break;
                          v67 = v45[6];
                          v68 = v46[6];
                          v8 = v67 > v68;
                          if ( v67 != v68 )
                            break;
                          v69 = *(unsigned __int8 *)(v59 + 7);
                          v70 = *(unsigned __int8 *)(v60 + 7);
                          v8 = v69 > v70;
                          if ( v69 != v70 )
                            break;
                          v71 = v45[7];
                          v72 = v46[7];
                          v8 = v71 > v72;
                          if ( v71 != v72 )
                            break;
                          v34 += 8;
                          v35 += 8;
                          if ( v7 <= v34 )
                            v34 -= v7;
                          if ( v7 <= v35 )
                            v35 -= v7;
                          v36 -= 8;
                          --a1[6];
                          if ( v36 < 0 )
                            return 0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v8;
}

//----- (0003A320) --------------------------------------------------------
_DWORD *__fastcall sub_3A320(_DWORD *result, int a2, int a3)
{
  int v3; // r11
  int v4; // r3
  _DWORD *v5; // r3
  int v6; // r4
  int v7; // r10
  int v8; // r3
  _BOOL4 v9; // r2
  int i; // r5
  int v12; // r6
  _DWORD *v13; // r7
  int v14; // r3
  int v15; // r8
  _DWORD *v16; // r9
  _BOOL4 v17; // r0
  _DWORD *v18; // r3
  unsigned int v19; // r2
  unsigned int v20; // r1
  unsigned int v21; // r0
  int v22; // r12
  int v23; // r7
  int v24; // r8
  int v25; // r5
  int v26; // r9
  int v27; // r6
  _DWORD *v28; // r1
  _DWORD *v29; // t1
  bool v30; // cc
  int v31; // r9
  int v32; // r3
  int v33; // r5
  int v34; // r3
  int v35; // r1
  int v36; // r6
  int v37; // r8
  int v38; // r5
  int v39; // r3
  int v40; // r2
  int v41; // r0
  int v42; // r1
  bool v43; // cc
  int v44; // r1
  int v45; // r1
  int v46; // r1
  int v47; // r1
  int v48; // r1
  _DWORD *v49; // r1
  _DWORD *v50; // r1
  _DWORD *v51; // r2
  _DWORD *v52; // r1
  int v53; // [sp+4h] [bp-4E0h]
  int v54; // [sp+8h] [bp-4DCh]
  int v55; // [sp+8h] [bp-4DCh]
  int v56; // [sp+Ch] [bp-4D8h]
  _DWORD *v57; // [sp+10h] [bp-4D4h]
  unsigned int v58; // [sp+14h] [bp-4D0h]
  _DWORD *v59; // [sp+14h] [bp-4D0h]
  int v60; // [sp+18h] [bp-4CCh]
  int v61; // [sp+1Ch] [bp-4C8h]
  _DWORD *v62; // [sp+20h] [bp-4C4h]
  int v63; // [sp+24h] [bp-4C0h]
  unsigned int v64; // [sp+28h] [bp-4BCh]
  int v65; // [sp+2Ch] [bp-4B8h]
  int v66; // [sp+30h] [bp-4B4h]
  int v67; // [sp+1C0h] [bp-324h]
  _DWORD v68[101]; // [sp+350h] [bp-194h] BYREF

  v3 = result[7];
  v60 = result[8];
  v68[0] = 2;
  v4 = 1;
  v57 = result;
  v66 = a2;
  v67 = a3;
  while ( 1 )
  {
    v54 = v4;
    v56 = v4 - 1;
    v5 = &v68[v4 + 99];
    v6 = *(v5 - 300);
    v7 = *(v5 - 200);
    v53 = *(v5 - 100);
    v8 = v7 - v6;
    v9 = v7 - v6 <= 19;
    if ( v53 > 14 )
      v9 = 1;
    if ( v9 )
      break;
    v18 = (_DWORD *)(v3 + 4 * v6);
    v19 = *(unsigned __int8 *)(v60 + v53 + *v18);
    v20 = *(unsigned __int8 *)(v60 + v53 + *(_DWORD *)(v3 + 4 * v7));
    v21 = *(unsigned __int8 *)(v60 + v53 + *(_DWORD *)(v3 + 4 * ((v6 + v7) >> 1)));
    if ( v19 <= v20 )
    {
      v20 = *(unsigned __int8 *)(v60 + v53 + *(_DWORD *)(v3 + 4 * v6));
      v19 = *(unsigned __int8 *)(v60 + v53 + *(_DWORD *)(v3 + 4 * v7));
    }
    if ( v21 < v19 )
    {
      if ( v21 < v20 )
        v19 = v20;
      else
        v19 = *(unsigned __int8 *)(v60 + v53 + *(_DWORD *)(v3 + 4 * ((v6 + v7) >> 1)));
    }
    v22 = v6 + 1;
    result = (_DWORD *)v53;
    v23 = v7;
    v24 = v6;
    v25 = v7;
    v26 = v60 + v53;
    while ( 1 )
    {
      v27 = v22 - 1;
      if ( v22 - 1 > v25 )
        break;
      result = (_DWORD *)*v18;
      if ( *(unsigned __int8 *)(v26 + *v18) == v19 )
      {
        *v18 = *(_DWORD *)(v3 + 4 * v24);
        *(_DWORD *)(v3 + 4 * v24++) = result;
        goto LABEL_32;
      }
      if ( (int)(*(unsigned __int8 *)(v26 + *v18) - v19) > 0 )
      {
        v28 = (_DWORD *)(v3 + 4 * v25);
        while ( 1 )
        {
          v59 = v28;
          --v25;
          v29 = (_DWORD *)*v28--;
          result = v29;
          v30 = (int)(*((unsigned __int8 *)v29 + v26) - v19) < 0;
          if ( *((unsigned __int8 *)v29 + v26) == v19 )
          {
            v28[1] = *(_DWORD *)(v3 + 4 * v23);
            *(_DWORD *)(v3 + 4 * v23--) = result;
          }
          else if ( v30 )
          {
            v52 = (_DWORD *)*v18;
            *v18 = result;
            result = v59;
            *v59 = v52;
            break;
          }
          if ( v27 > v25 )
            goto LABEL_39;
        }
      }
LABEL_32:
      ++v22;
      ++v18;
    }
LABEL_39:
    v31 = v53 + 1;
    if ( v24 > v23 )
    {
      v68[v56] = v31;
    }
    else
    {
      v32 = v24 - v6;
      if ( v24 - v6 >= v27 - v24 )
        v32 = v27 - v24;
      v33 = v23 - v25;
      sub_399D0(v3, v6, v27 - v32, v32);
      v34 = v7 - v23;
      v35 = v27;
      v36 = v27 + v6;
      if ( v7 - v23 >= v33 )
        v34 = v33;
      v37 = v36 - v24;
      v38 = v7 - v33;
      sub_399D0(v3, v35, v7 - v34 + 1, v34);
      v39 = v37 - 1;
      v40 = v38 + 1;
      v41 = v38 - v37;
      if ( v37 - 1 - v6 >= v7 - (v38 + 1) )
      {
        v42 = v7;
        v7 = v37 - 1;
        v39 = v42;
        v40 = v6;
        v6 = v38 + 1;
      }
      v43 = v39 - v6 < v41;
      if ( v39 - v6 < v41 )
      {
        result = (_DWORD *)v53;
      }
      else
      {
        v44 = v38;
        v38 = v39;
        v39 = v44;
        v45 = v37;
        v37 = v6;
        v6 = v45;
        result = (_DWORD *)(v53 + 1);
      }
      if ( !v43 )
        v31 = v53;
      if ( v7 - v40 >= v38 - v37 )
      {
        v46 = v31;
        v31 = v53;
        v53 = v46;
        v47 = v38;
        v38 = v7;
        v7 = v47;
        v48 = v37;
        v37 = v40;
        v40 = v48;
      }
      v49 = &v68[v56 + 100];
      *(v49 - 300) = v37;
      *(v49 - 200) = v38;
      *(v49 - 100) = v31;
      v50 = &v68[v54 + 100];
      *(v50 - 300) = v40;
      *(v50 - 200) = v7;
      *(v50 - 100) = v53;
      v51 = &v68[v54 + 101];
      *(v51 - 200) = v39;
      *(v51 - 300) = v6;
      *(v51 - 100) = result;
      v54 += 2;
    }
    v56 = v54;
LABEL_59:
    v4 = v56;
  }
  v61 = v57[7];
  if ( v8 > 0 )
  {
    for ( i = 0; dword_63990[i] <= (unsigned int)v8; ++i )
      ;
    while ( i-- != 0 )
    {
      v12 = v6 + dword_63990[i];
      v55 = dword_63990[i];
      v13 = (_DWORD *)(v61 + 4 * v12);
      v14 = -4 * v55;
      v64 = v12 - 1;
      while ( v7 >= v12 )
      {
        v15 = v12;
        v16 = v13;
        v62 = (_DWORD *)*v13;
        v63 = *v13 + v53;
        while ( 1 )
        {
          v65 = v14;
          v58 = v15 - v55;
          v17 = sub_3A0CC(v57, v53 + *(_DWORD *)((char *)v16 + v14), v63);
          v14 = v65;
          if ( !v17 )
            break;
          v15 -= v55;
          *v16 = *(_DWORD *)((char *)v16 + v65);
          v16 = (_DWORD *)((char *)v16 + v65);
          if ( v64 >= v58 )
            goto LABEL_20;
        }
        v58 = v15;
LABEL_20:
        ++v12;
        ++v13;
        result = v62;
        *(_DWORD *)(v61 + 4 * v58) = v62;
        if ( (int)v57[6] < 0 )
          goto LABEL_6;
      }
    }
  }
LABEL_6:
  if ( (int)v57[6] >= 0 && v56 )
    goto LABEL_59;
  return result;
}
// 63990: using guessed type _DWORD dword_63990[14];

//----- (0003A73C) --------------------------------------------------------
_DWORD *__fastcall sub_3A73C(_DWORD *result)
{
  int v1; // r1
  int v2; // r12
  int v3; // r2
  char v4; // r3
  int v5; // r12
  int v6; // r1
  int v7; // r1
  int v8; // r2
  int v9; // r1
  int v10; // r2
  int v11; // r1
  int v12; // r2
  int v13; // r1
  int v14; // r3
  int v15; // r2

  v1 = result[11];
  v2 = 0;
  v3 = result[12];
  v4 = v1;
  while ( v3 > v2 )
  {
    ++v2;
    result[20] = *(_DWORD *)(result[19] + 4 * ((unsigned __int8)v1 ^ HIBYTE(result[20]))) ^ (result[20] << 8);
  }
  *((_BYTE *)result + v1 + 100) = 1;
  v5 = result[8];
  v6 = result[13];
  switch ( v3 )
  {
    case 2:
      goto LABEL_9;
    case 3:
      *(_BYTE *)(v5 + v6) = v4;
      ++result[13];
LABEL_9:
      *(_BYTE *)(result[8] + result[13]++) = v4;
      goto LABEL_10;
    case 1:
LABEL_10:
      *(_BYTE *)(result[8] + result[13]) = v4;
      goto LABEL_11;
  }
  *((_BYTE *)result + v3 + 96) = 1;
  *(_BYTE *)(v5 + v6) = v4;
  v7 = result[8];
  v8 = result[13] + 1;
  result[13] = v8;
  *(_BYTE *)(v7 + v8) = v4;
  v9 = result[8];
  v10 = result[13] + 1;
  result[13] = v10;
  *(_BYTE *)(v9 + v10) = v4;
  v11 = result[8];
  v12 = result[13] + 1;
  result[13] = v12;
  *(_BYTE *)(v11 + v12) = v4;
  v13 = result[8];
  v14 = result[13] + 1;
  v15 = result[12] - 4;
  result[13] = v14;
  *(_BYTE *)(v13 + v14) = v15;
LABEL_11:
  ++result[13];
  return result;
}

//----- (0003A850) --------------------------------------------------------
int __fastcall sub_3A850(int result)
{
  _BYTE *v1; // r3
  char v2; // r2

  while ( *(int *)(result + 72) > 0 )
  {
    v1 = *(_BYTE **)(result + 60);
    v2 = *(_BYTE *)(result + 71);
    *(_DWORD *)(result + 60) = v1 + 1;
    *v1 = v2;
    *(_DWORD *)(result + 68) <<= 8;
    *(_DWORD *)(result + 72) -= 8;
  }
  return result;
}

//----- (0003A88C) --------------------------------------------------------
_DWORD *__fastcall sub_3A88C(_DWORD *result, int a2, int a3)
{
  int v3; // r12
  int v4; // r3
  _BYTE *v5; // r12

  while ( 1 )
  {
    v3 = result[18];
    v4 = result[17];
    if ( v3 <= 7 )
      break;
    v5 = (_BYTE *)result[15];
    result[15] = v5 + 1;
    *v5 = HIBYTE(v4);
    result[17] <<= 8;
    result[18] -= 8;
  }
  result[18] = v3 + a2;
  result[17] = v4 | (a3 << (32 - v3 - a2));
  return result;
}

//----- (0003A8EC) --------------------------------------------------------
_DWORD *__fastcall sub_3A8EC(_DWORD *result, int a2)
{
  int v2; // r2
  int v3; // r3
  _BYTE *v4; // r2

  while ( 1 )
  {
    v2 = result[18];
    v3 = result[17];
    if ( v2 <= 7 )
      break;
    v4 = (_BYTE *)result[15];
    result[15] = v4 + 1;
    *v4 = HIBYTE(v3);
    result[17] <<= 8;
    result[18] -= 8;
  }
  result[18] = v2 + 16;
  result[17] = v3 | (a2 << (16 - v2));
  return result;
}

//----- (0003A944) --------------------------------------------------------
int __fastcall sub_3A944(int result)
{
  _BYTE *v1; // r3
  char v2; // r2

  if ( *(int *)(result + 72) > 7 )
  {
    v1 = *(_BYTE **)(result + 60);
    v2 = *(_BYTE *)(result + 71);
    *(_DWORD *)(result + 60) = v1 + 1;
    *v1 = v2;
    *(_DWORD *)(result + 68) <<= 8;
    *(_DWORD *)(result + 72) -= 8;
  }
  ++*(_DWORD *)(result + 72);
  return result;
}

//----- (0003A98C) --------------------------------------------------------
_DWORD *__fastcall sub_3A98C(_DWORD *a1, unsigned int a2)
{
  unsigned __int16 v2; // r4
  _DWORD *v3; // r0

  v2 = a2;
  v3 = sub_3A8EC(a1, HIWORD(a2));
  return sub_3A8EC(v3, v2);
}

//----- (0003A9A8) --------------------------------------------------------
_DWORD *__fastcall sub_3A9A8(_DWORD *result)
{
  int v1; // r4
  unsigned __int8 *v2; // r3
  int v3; // r7
  int v4; // r12
  int v6; // r3
  _DWORD *v7; // r2
  int v8; // r5
  int i; // r3
  int v10; // r6
  int v11; // r3
  int v12; // r1
  int j; // lr
  int v14; // r2
  unsigned int v15; // r1
  _WORD *v16; // r9
  int v17; // r2
  int v18; // r1
  int v19; // r1
  unsigned __int8 *v20; // r2
  int v21; // r2
  int v22; // r9
  int v23; // t1
  unsigned __int8 v24; // [sp+0h] [bp-100h] BYREF
  unsigned __int8 v25; // [sp+1h] [bp-FFh] BYREF

  v2 = (unsigned __int8 *)(result + 25);
  v3 = result[7];
  v4 = 0;
  do
  {
    if ( *v2++ )
      v2[255] = v4++;
  }
  while ( result + 89 != (_DWORD *)v2 );
  v6 = 0;
  v7 = result + 153;
  v8 = v4 + 1;
  result[24] = v4;
  while ( v8 >= v6 )
  {
    *v7++ = 0;
    ++v6;
  }
  for ( i = 0; i < v4; ++i )
    *(&v24 + i) = i;
  v10 = result[13];
  v11 = 0;
  v12 = 0;
  for ( j = 0; v10 > j; ++j )
  {
    v14 = *(_DWORD *)(v3 + 4 * j) - 1;
    if ( v14 < 0 )
      v14 += v10;
    v1 = *((unsigned __int8 *)result + *(unsigned __int8 *)(result[8] + v14) + 356);
    if ( v24 == v1 )
    {
      ++v12;
      continue;
    }
    if ( v12 )
      goto LABEL_20;
LABEL_25:
    v19 = v25;
    v25 = v24;
    v20 = &v25;
    while ( v1 != v19 )
    {
      v23 = *++v20;
      *v20 = v19;
      v19 = v23;
    }
    v21 = v20 - &v24;
    v22 = result[9];
    v24 = v1;
    *(_WORD *)(v22 + 2 * v11++) = v21 + 1;
    ++result[v21 + 154];
    v12 = 0;
  }
  if ( !v12 )
    goto LABEL_12;
  j = -1;
LABEL_20:
  v15 = v12 - 1;
  v16 = (_WORD *)(result[9] + 2 * v11);
  while ( 1 )
  {
    v17 = v15 & 1;
    v18 = v15 - 2;
    *v16++ = v17;
    ++v11;
    ++result[v17 + 153];
    if ( v18 < 0 )
      break;
    v15 = (unsigned int)v18 >> 1;
  }
  if ( j != -1 )
    goto LABEL_25;
LABEL_12:
  *(_WORD *)(result[9] + 2 * v11) = v8;
  ++result[v4 + 154];
  result[23] = v11 + 1;
  return result;
}
// 3AAF8: variable 'v1' is possibly undefined

//----- (0003AB44) --------------------------------------------------------
int __fastcall sub_3AB44(_DWORD *a1)
{
  int *v1; // r4
  unsigned __int8 *v3; // r10
  int v4; // r11
  _WORD *v5; // r0
  int v6; // r2
  int v7; // r3
  _WORD *v8; // lr
  int i; // r1
  unsigned __int8 *v10; // r3
  unsigned __int8 v11; // t1
  int v12; // r1
  int *v13; // r3
  int v14; // t1
  unsigned int v15; // r3
  int j; // r3
  int v17; // r0
  unsigned int v18; // r3
  unsigned int v19; // r1
  int v20; // r8
  unsigned int v21; // lr
  unsigned int v22; // r2
  int v23; // r7
  int k; // r9
  int v25; // r8
  int v26; // r6
  int *v27; // r7
  int v28; // r1
  unsigned int *v29; // r1
  int *v30; // r12
  int m; // r3
  int *v32; // r0
  int v33; // lr
  _DWORD *v34; // r2
  int result; // r0
  _DWORD *v36; // r2
  _BYTE *v37; // lr
  signed int v38; // r3
  int n; // r3
  int v40; // r1
  char v41; // r0
  unsigned int v42; // r1
  unsigned int v43; // r3
  int v44; // r1
  int ii; // r3
  int v46; // r12
  int v47; // r1
  int v48; // r2
  int v49; // r3
  int v50; // r3
  int v51; // r1
  int v52; // r1
  int v53; // lr
  int v54; // r1
  int v55; // r1
  int v56; // r7
  unsigned int v57; // r2
  int v58; // r12
  int v59; // r6
  int v60; // [sp+4h] [bp-210h]
  int v61; // [sp+8h] [bp-20Ch]
  _BYTE *v62; // [sp+Ch] [bp-208h]
  _BYTE v63[256]; // [sp+10h] [bp-204h]
  _BYTE v64[260]; // [sp+110h] [bp-104h] BYREF

  v1 = (int *)a1[4];
  v60 = a1[13];
  v3 = (unsigned __int8 *)a1[8];
  v4 = a1[7];
  v61 = a1[5];
  memset(v1, 0, 0x40004u);
  v5 = (_WORD *)(v61 + 2 * v60);
  v6 = v60 - 1;
  v7 = *v3 << 8;
  v8 = v5;
  for ( i = v60 - 1; i >= 0; --i )
  {
    *--v8 = 0;
    v46 = v3[i];
    v7 = (v7 >> 8) | (v46 << 8);
    ++v1[v7];
  }
  v10 = v3 - 1;
  do
  {
    v11 = *++v10;
    v10[v60] = v11;
    *v5++ = 0;
  }
  while ( v3 + 33 != v10 );
  v12 = *v1;
  v13 = v1;
  do
  {
    v14 = v13[1];
    ++v13;
    v12 += v14;
    *v13 = v12;
  }
  while ( v1 + 0x10000 != v13 );
  v15 = *v3 << 8;
  while ( v6 >= 0 )
  {
    v15 = (v3[v6] << 8) | (v15 >> 8);
    v47 = v1[v15] - 1;
    v1[v15] = v47;
    *(_DWORD *)(v4 + 4 * v47) = v6--;
  }
  for ( j = 0; j != 256; ++j )
  {
    v64[j] = j;
    v63[j] = 0;
  }
  v17 = 5;
  v18 = 364;
  do
  {
    v18 = (171 * v18) >> 9;
    v19 = v18;
    v62 = &v64[-v18];
    do
    {
      v20 = (unsigned __int8)v64[v19];
      v21 = v1[256 * v20 + 256] - v1[256 * v20];
      v22 = v19;
      do
      {
        v23 = (unsigned __int8)v62[v22];
        if ( v1[256 * v23 + 256] - v1[256 * v23] <= v21 )
          break;
        v64[v22] = v23;
        v22 -= v18;
      }
      while ( v18 <= v22 );
      ++v19;
      v64[v22] = v20;
    }
    while ( v19 != 256 );
    --v17;
  }
  while ( v17 );
  for ( k = 0; ; ++k )
  {
    v25 = 0;
    v26 = (unsigned __int8)v64[k];
    v27 = &v1[256 * v26];
    v62 = (_BYTE *)(v26 << 10);
    do
    {
      if ( v26 != v25 )
      {
        v28 = *v27;
        if ( (*v27 & 0x200000) == 0 )
        {
          v48 = (v27[1] & 0xFFDFFFFF) - 1;
          if ( v28 < v48 )
          {
            result = (int)sub_3A320(a1, v28, v48);
            if ( (int)a1[6] < 0 )
              return result;
          }
        }
        *v27 |= 0x200000u;
      }
      ++v25;
      ++v27;
    }
    while ( v25 != 256 );
    v29 = a1 + 14187;
    v30 = &v1[v26];
    for ( m = 0; m != 0x10000; m += 256 )
    {
      v32 = &v30[m];
      v33 = v30[m];
      *v29++ = v33 & 0xFFDFFFFF;
      v29[255] = (v32[1] & 0xFFDFFFFF) - 1;
    }
    v34 = &a1[v26];
    result = v1[256 * v26] & 0xFFDFFFFF;
    while ( v34[14187] > result )
    {
      v49 = *(_DWORD *)(v4 + 4 * result++);
      v50 = v49 - 1;
      if ( v50 < 0 )
        v50 += v60;
      v51 = v3[v50];
      if ( !v63[v51] )
      {
        v52 = (int)&a1[v51 + 13312];
        v53 = *(_DWORD *)(v52 + 3500);
        *(_DWORD *)(v52 + 3500) = v53 + 1;
        *(_DWORD *)(v4 + 4 * v53) = v50;
      }
    }
    v36 = v34 + 14336;
    v37 = v62 + 1024;
    v38 = (*(_DWORD *)&v62[(_DWORD)v1 + 1024] & 0xFFDFFFFF) - 1;
    while ( v36[107] < v38 )
    {
      v54 = *(_DWORD *)(v4 + 4 * v38--);
      v55 = v54 - 1;
      if ( v55 < 0 )
        v55 += v60;
      result = v3[v55];
      if ( !v63[result] )
      {
        result = (int)&a1[result + 14336];
        v56 = *(_DWORD *)(result + 428);
        *(_DWORD *)(result + 428) = v56 - 1;
        *(_DWORD *)(v4 + 4 * v56) = v55;
      }
    }
    for ( n = 0; n != 256; ++n )
      v30[256 * n] |= 0x200000u;
    if ( k == 255 )
      break;
    v40 = v1[256 * v26];
    v63[v26] = 1;
    v41 = 0;
    v42 = v40 & 0xFFDFFFFF;
    v43 = (*(_DWORD *)&v37[(_DWORD)v1] & 0xFFDFFFFF) - v42;
    while ( v43 >> v41 > 0xFFFE )
      ++v41;
    v44 = v4 + 4 * v42;
    for ( ii = v43 - 1; ii >= 0; --ii )
    {
      v57 = *(_DWORD *)(v44 + 4 * ii);
      v58 = ii >> v41;
      v59 = v61;
      *(_WORD *)(v61 + 2 * v57) = v58;
      if ( v57 <= 0x21 )
        *(_WORD *)(v59 + 2 * (v57 + v60)) = v58;
    }
  }
  return result;
}

//----- (0003AF30) --------------------------------------------------------
int __fastcall sub_3AF30(_DWORD *a1)
{
  int v1; // r5
  int v2; // r3
  int i; // r3
  int v6; // r1
  int v7; // r2

  v2 = a1[13];
  if ( v2 <= 9999 )
    goto LABEL_2;
  v6 = v2 + 34;
  if ( ((v2 + 34) & 1) != 0 )
    v6 = v2 + 35;
  v7 = a1[8] + v6;
  a1[6] = 9 * v2;
  a1[5] = v7;
  sub_3AB44(a1);
  if ( (int)a1[6] < 0 )
LABEL_2:
    sub_399F8(a1);
  for ( i = 0; a1[13] != i; ++i )
  {
    if ( !*(_DWORD *)(a1[7] + 4 * i) )
      return i;
  }
  return v1;
}
// 3AF74: variable 'v1' is possibly undefined

//----- (0003AFB8) --------------------------------------------------------
_DWORD *__fastcall sub_3AFB8(_DWORD *a1)
{
  int v1; // r10
  _DWORD *v3; // r2
  int v4; // r11
  unsigned int i; // r3
  unsigned int v6; // lr
  signed int v7; // r6
  unsigned int v8; // r8
  int v9; // r2
  int v10; // r9
  unsigned int v11; // r7
  char *v12; // r5
  unsigned int v13; // r0
  unsigned int v14; // r3
  unsigned int v15; // r1
  int j; // r12
  _BOOL4 v17; // lr
  unsigned int v18; // r0
  bool v19; // cc
  char v20; // r12
  int v21; // r12
  char *v22; // r12
  unsigned int v23; // r1
  int v24; // r8
  int v25; // t1
  int v26; // lr
  bool v27; // zf
  int v28; // lr
  unsigned int k; // r3
  unsigned int v30; // r12
  _BYTE *v31; // lr
  unsigned int v32; // r3
  unsigned int v33; // r1
  int v34; // r2
  unsigned int v35; // r6
  unsigned __int16 *v36; // r5
  unsigned int v37; // r7
  int v38; // r2
  int v39; // r6
  unsigned int v40; // r9
  int v41; // r2
  int v42; // t1
  int v43; // r2
  int *v44; // r1
  int v45; // r2
  int *v46; // r0
  int m; // r3
  int v48; // r1
  int *v49; // r3
  int v50; // r0
  char *v51; // r12
  int v52; // r0
  int jj; // r2
  int *v54; // r1
  int mm; // r2
  int v56; // r3
  int v57; // r3
  int v58; // r2
  int v59; // r6
  int v60; // lr
  _DWORD *v61; // r2
  int v62; // r12
  int v63; // r5
  int v64; // t1
  _DWORD *v65; // r6
  int n; // r2
  int v67; // r12
  int v68; // r7
  int v69; // r6
  _DWORD *v70; // r7
  int ii; // r2
  int v72; // lr
  int v73; // r9
  _DWORD *v74; // r12
  _DWORD *v75; // r2
  int v76; // r5
  int v77; // r2
  int v78; // r12
  unsigned int v79; // r2
  int v80; // r12
  int v81; // r2
  int v82; // r6
  _DWORD *v83; // r2
  int v84; // r5
  int kk; // r1
  int v86; // r3
  int v87; // r3
  unsigned __int8 *v88; // r0
  _BYTE *nn; // r3
  unsigned __int8 *v90; // r5
  int v91; // r8
  _DWORD *v92; // r1
  unsigned __int8 *v93; // r6
  int v94; // r2
  int v95; // r3
  int v96; // r0
  int v97; // r6
  int v98; // t1
  _BYTE *v99; // r1
  int i1; // r2
  int v101; // t1
  int v102; // r12
  unsigned int v103; // r12
  int v104; // r0
  _DWORD *v105; // r7
  int v106; // r8
  int v107; // r1
  int v108; // r1
  int v109; // r8
  int v110; // r3
  int v111; // r1
  char *v112; // r2
  int v113; // r7
  _DWORD *v114; // r0
  unsigned int v115; // r9
  unsigned __int8 *v116; // r7
  int v117; // r8
  _DWORD *result; // r0
  unsigned int v119; // r3
  unsigned int v120; // r7
  int v121; // r6
  int v122; // r11
  int v123; // r6
  unsigned __int16 *v124; // r8
  int v125; // t1
  int i2; // r12
  int v127; // r3
  _BYTE *v128; // r0
  int v129; // r3
  unsigned int v130; // r2
  int v131; // r0
  unsigned int v132; // [sp+4h] [bp-68h]
  unsigned int v133; // [sp+8h] [bp-64h]
  unsigned __int16 *v134; // [sp+Ch] [bp-60h]
  char *v135; // [sp+Ch] [bp-60h]
  int v136; // [sp+10h] [bp-5Ch]
  _DWORD *v137; // [sp+14h] [bp-58h]
  _DWORD *v138; // [sp+18h] [bp-54h]
  unsigned __int8 *v139; // [sp+1Ch] [bp-50h]
  int v140; // [sp+24h] [bp-48h]
  int v141; // [sp+28h] [bp-44h]
  int v142; // [sp+2Ch] [bp-40h]
  int v143; // [sp+38h] [bp-34h]
  int v144; // [sp+3Ch] [bp-30h]
  int v145; // [sp+40h] [bp-2Ch]
  char *v146; // [sp+44h] [bp-28h]
  _BYTE v147[8]; // [sp+48h] [bp-24h] BYREF
  _DWORD v148[7]; // [sp+50h] [bp-1Ch]

  v1 = a1[24];
  v3 = a1;
  v138 = a1;
  v4 = v1 + 2;
  v142 = a1[9];
  do
  {
    for ( i = 0; v4 > i; ++i )
    {
      v6 = i + 37648;
      *((_BYTE *)v3 + v6) = 15;
    }
    v3 = (_DWORD *)((char *)v3 + 258);
  }
  while ( v3 != a1 + 387 );
  v7 = a1[23];
  v8 = 0;
  v9 = (v7 > 199) + 2;
  if ( v7 >= 600 )
    v9 = (v7 > 199) + 3;
  if ( v7 >= 1200 )
    ++v9;
  if ( v7 >= 2400 )
    ++v9;
  v10 = 258 * v9;
  v11 = v9;
  v133 = v9;
  v12 = (char *)a1 + 258 * v9 + 37390;
  do
  {
    v13 = sub_15CA0(v7, v11);
    v14 = 0;
    v15 = v8;
    for ( j = (int)&a1[v8 + 152]; ; j += 4 )
    {
      v17 = v14 < v13;
      if ( v4 <= v15 )
        v17 = 0;
      if ( !v17 )
        break;
      v25 = *(_DWORD *)(j + 4);
      ++v15;
      v14 += v25;
    }
    v18 = v15 - 1;
    v19 = v133 > v11;
    if ( v133 != v11 )
      v19 = v18 > v8;
    v20 = v19;
    if ( v11 == 1 )
      v21 = 0;
    else
      v21 = v20 & 1;
    if ( v21 && ((v133 - v11) & 1) != 0 )
    {
      v14 -= a1[v15 + 152];
      v18 = v15 - 2;
    }
    v22 = v12;
    v23 = 0;
    while ( v4 > v23 )
    {
      ++v22;
      v26 = v23 >= v8;
      v19 = v23++ > v18;
      if ( v19 )
        v26 = 0;
      v27 = v26 == 0;
      if ( v26 )
        *(v22 - 1) = 0;
      else
        LOBYTE(v26) = 15;
      if ( v27 )
        *(v22 - 1) = v26;
    }
    --v11;
    v8 = v18 + 1;
    v7 -= v14;
    v12 -= 258;
  }
  while ( v11 );
  v146 = (char *)a1 + v10 + 37647;
  v132 = 4;
  do
  {
    v24 = 0;
    do
    {
      for ( k = 0; v4 > k; ++k )
      {
        v28 = 4 * k + 45388;
        *(_DWORD *)((char *)&a1[258 * v24] + v28) = 0;
      }
      ++v24;
    }
    while ( v133 != v24 );
    v30 = a1[23];
    v139 = (unsigned __int8 *)(a1 + 411);
    v31 = a1 + 411;
    v32 = 0;
    while ( 1 )
    {
      v141 = (int)&v31[-1644 - (_DWORD)a1];
      if ( v30 <= v32 )
        break;
      v33 = v32 + 49;
      if ( v30 <= v32 + 49 )
        v33 = v30 - 1;
      v34 = 0;
      do
        v148[v34++] = 0;
      while ( v34 != v24 );
      v35 = v32;
      v36 = (unsigned __int16 *)(v142 + 2 * v32);
      v134 = v36;
      while ( v33 >= v35 )
      {
        v136 = *v134;
        v43 = 0;
        ++v134;
        do
        {
          v148[v43] += *((unsigned __int8 *)a1 + 258 * v43 + v136 + 37648);
          ++v43;
        }
        while ( v43 != v24 );
        ++v35;
      }
      v37 = v148[0];
      v38 = 0;
      v39 = 1;
      do
      {
        v40 = v148[v39];
        if ( v40 < v37 )
          v38 = v39;
        ++v39;
        if ( v40 < v37 )
          v37 = v40;
      }
      while ( v39 != v24 );
      *v31++ = v38;
      v41 = 258 * v38;
      while ( v32 <= v33 )
      {
        v42 = *v36++;
        ++v32;
        ++a1[v41 + 11347 + v42];
      }
    }
    v135 = (char *)a1 + 37647;
    v137 = a1 + 11347;
    do
    {
      v44 = a1 + 13156;
      v45 = 0;
      while ( v4 > v45 )
      {
        v56 = v137[v45++];
        if ( v56 )
          v57 = v56 << 8;
        else
          v57 = 256;
        *v44++ = v57;
      }
      while ( 1 )
      {
        v46 = a1 + 12896;
        a1[12895] = 0;
        a1[13155] = 0;
        a1[13671] = -2;
        for ( m = 1; ; ++m )
        {
          v48 = m - 1;
          if ( v4 < m )
            break;
          v46[776] = -1;
          v58 = m;
          *v46++ = m;
          v59 = v46[259];
          while ( 1 )
          {
            v60 = v58 >> 1;
            v61 = &a1[v58 + 12894];
            v62 = a1[v60 + 12895];
            if ( v59 >= a1[v62 + 13155] )
              break;
            v61[1] = v62;
            v58 = v60;
          }
          v61[1] = m;
        }
        v49 = &a1[m + 12894];
        v50 = v1 + 2;
        v140 = (int)&a1[v1 + 13157];
        while ( v48 > 1 )
        {
          --v48;
          v64 = *v49--;
          v63 = v64;
          v144 = a1[12896];
          v65 = &a1[v64 + 13154];
          a1[12896] = v64;
          for ( n = 1; ; n = v67 )
          {
            v67 = 2 * n;
            if ( v48 < 2 * n )
              break;
            if ( v48 > 2 * n && a1[a1[2 * n + 12896] + 13155] < a1[a1[2 * n + 12895] + 13155] )
              ++v67;
            v68 = a1[v67 + 12895];
            if ( v65[1] < a1[v68 + 13155] )
              break;
            a1[n + 12895] = v68;
          }
          a1[n + 12895] = v63;
          v69 = *v49;
          v145 = a1[12896];
          v70 = &a1[*v49 + 13154];
          a1[12896] = *v49;
          v143 = v48 - 1;
          for ( ii = 1; ; ii = v72 )
          {
            v72 = 2 * ii;
            if ( v143 < 2 * ii )
              break;
            if ( v143 > 2 * ii && a1[a1[2 * ii + 12896] + 13155] < a1[a1[2 * ii + 12895] + 13155] )
              ++v72;
            v73 = a1[v72 + 12895];
            if ( v70[1] < a1[v73 + 13155] )
              break;
            a1[ii + 12895] = v73;
          }
          ++v50;
          a1[ii + 12895] = v69;
          v74 = &a1[v145];
          v74[13671] = v50;
          v75 = &a1[v144];
          v75[13671] = v50;
          v76 = v74[13155];
          v77 = v75[13155];
          v78 = (unsigned __int8)v77;
          v79 = (v77 & 0xFFFFFF00) + (v76 & 0xFFFFFF00);
          if ( (unsigned __int8)v76 >= v78 )
            v78 = (unsigned __int8)v76;
          v80 = (v78 + 1) | v79;
          *(_DWORD *)(v140 + 4) = v80;
          *(_DWORD *)(v140 + 2068) = -1;
          v140 += 4;
          v81 = v48;
          *v49 = v50;
          while ( 1 )
          {
            v82 = v81 >> 1;
            v83 = &a1[v81 + 12894];
            v84 = a1[v82 + 12895];
            if ( v80 >= a1[v84 + 13155] )
              break;
            v83[1] = v84;
            v81 = v82;
          }
          v83[1] = v50;
        }
        v51 = v135;
        v52 = 0;
        for ( jj = 1; v4 >= jj; ++jj )
        {
          v86 = jj;
          for ( kk = 0; ; ++kk )
          {
            v86 = a1[v86 + 13671];
            if ( v86 < 0 )
              break;
          }
          *++v51 = kk;
          if ( kk >= 18 )
            v52 = 1;
        }
        if ( !v52 )
          break;
        v54 = a1 + 13156;
        for ( mm = 1; v4 >= mm; ++mm )
        {
          *v54 = (((int)((*v54 >> 8) + ((unsigned int)*v54 >> 31)) >> 1) + 1) << 8;
          ++v54;
        }
      }
      v135 += 258;
      v137 += 258;
    }
    while ( v135 != v146 );
    --v132;
  }
  while ( v132 );
  v87 = 0;
  do
  {
    v147[v87] = v87;
    ++v87;
  }
  while ( v87 != v24 );
  v88 = (unsigned __int8 *)(a1 + 411);
  for ( nn = (char *)a1 + 19646; (char *)a1 + v141 + 19646 != nn; ++nn )
  {
    v98 = *v88++;
    v97 = v98;
    v99 = v147;
    for ( i1 = v147[0]; i1 != v97; i1 = v101 )
    {
      v101 = (unsigned __int8)*++v99;
      *v99 = i1;
    }
    v147[0] = i1;
    *nn = v99 - v147;
  }
  v90 = (unsigned __int8 *)(a1 + 9412);
  v91 = (int)a1 + 258 * v24 + 37648;
  v92 = a1 + 9799;
  v93 = (unsigned __int8 *)(a1 + 9412);
  do
  {
    v94 = 0;
    v95 = 32;
    v96 = 0;
    while ( v96 < v4 )
    {
      v102 = v96 + 37648;
      ++v96;
      v103 = v93[v102 - 37648];
      if ( v94 < v103 )
        v94 = v103;
      if ( v95 >= v103 )
        v95 = v103;
    }
    v104 = 0;
    while ( v94 >= v95 )
    {
      for ( i2 = 0; v4 > i2; ++i2 )
      {
        if ( v93[i2] == v95 )
          v92[i2] = v104++;
      }
      v104 *= 2;
      ++v95;
    }
    v93 += 258;
    v92 += 258;
  }
  while ( (unsigned __int8 *)v91 != v93 );
  v105 = a1;
  v106 = 0;
  do
  {
    v107 = v105[26];
    v105 += 4;
    v106 = ((v105[21] | v107 | v105[23] | v105[24]) != 0) + 2 * v106;
  }
  while ( a1 + 64 != v105 );
  v108 = v106;
  v109 = v106 << 16;
  sub_3A8EC(a1, v108);
  do
  {
    if ( v109 < 0 )
    {
      v110 = 0;
      v111 = 0;
      do
      {
        v112 = (char *)v138 + v110++;
        v111 = (unsigned __int8)v112[100] + 2 * v111;
      }
      while ( v110 != 16 );
      sub_3A8EC(a1, v111);
    }
    v109 *= 2;
    v27 = v105 == v138 + 4;
    v138 += 4;
  }
  while ( !v27 );
  v113 = 0;
  v114 = sub_3A88C(a1, 3, v133);
  sub_3A88C(v114, 15, v141);
  while ( v113 != v141 )
  {
    v130 = 0;
    while ( *((unsigned __int8 *)a1 + v113 + 19646) > v130 )
    {
      v127 = a1[17];
      if ( (int)a1[18] > 7 )
      {
        v128 = (_BYTE *)a1[15];
        a1[15] = v128 + 1;
        *v128 = HIBYTE(v127);
        a1[17] <<= 8;
        a1[18] -= 8;
      }
      v129 = a1[18];
      ++v130;
      v131 = a1[17];
      a1[18] = v129 + 1;
      a1[17] = v131 | (1 << (31 - v129));
    }
    ++v113;
    sub_3A944((int)a1);
  }
  do
  {
    v115 = *v90;
    v116 = v90;
    v117 = 0;
    result = sub_3A88C(a1, 5, v115);
    while ( v117 < v4 )
    {
      while ( *v116 > v115 )
      {
        ++v115;
        sub_3A88C(a1, 2, 2);
      }
      while ( *v116 < v115 )
      {
        --v115;
        sub_3A88C(a1, 2, 3);
      }
      ++v117;
      result = (_DWORD *)sub_3A944((int)a1);
      ++v116;
    }
    v90 += 258;
  }
  while ( v93 != v90 );
  while ( 1 )
  {
    v119 = a1[23];
    if ( v119 <= v132 )
      break;
    v120 = v132 + 49;
    if ( v119 <= v132 + 49 )
      v120 = v119 - 1;
    v121 = *v139++;
    v122 = 258 * v121 + 37648;
    v123 = 1032 * v121 + 39196;
    v124 = (unsigned __int16 *)(v142 + 2 * v132);
    while ( v132 <= v120 )
    {
      v125 = *v124++;
      result = sub_3A88C(a1, *((unsigned __int8 *)a1 + v125 + v122), *(_DWORD *)((char *)&a1[v125] + v123));
      ++v132;
    }
  }
  return result;
}

//----- (0003BA6C) --------------------------------------------------------
_DWORD *__fastcall sub_3BA6C(_DWORD *result, int a2)
{
  int v2; // r6
  _DWORD *v3; // r4
  int v5; // r2
  int v6; // r1
  int v7; // r3
  int v8; // r3
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0

  v3 = result;
  v5 = result[22];
  if ( (int)result[13] > 0 )
  {
    v6 = result[21];
    v7 = ~result[20];
    result[20] = v7;
    result[21] = v7 ^ __ROR4__(v6, 31);
    if ( v5 > 1 )
      result[15] = result[10];
    result = (_DWORD *)sub_3AF30(result);
    v2 = (int)result;
  }
  v8 = v3[3] + v3[13];
  v3[10] = v8;
  v3[15] = v8;
  v3[16] = v8;
  if ( v3[22] == 1 )
  {
    v3[18] = 0;
    v3[17] = 0;
    result = sub_3A98C(v3, *((unsigned __int8 *)v3 + 6) + 1113221168);
  }
  if ( (int)v3[13] > 0 )
  {
    v9 = sub_3A98C(v3, 0x31415926u);
    v10 = sub_3A8EC(v9, 21337);
    v11 = sub_3A98C(v10, v3[20]);
    v12 = (_DWORD *)sub_3A944((int)v11);
    v13 = sub_3A88C(v12, 24, v2);
    v14 = sub_3A9A8(v13);
    result = sub_3AFB8(v14);
  }
  if ( a2 )
  {
    v15 = sub_3A98C(v3, 0x17724538u);
    v16 = sub_3A8EC(v15, 20624);
    v17 = sub_3A98C(v16, v3[21]);
    return (_DWORD *)sub_3A850((int)v17);
  }
  return result;
}
// 3BB2C: variable 'v2' is possibly undefined

//----- (0003BB70) --------------------------------------------------------
_BYTE *__fastcall sub_3BB70(_DWORD *a1)
{
  _BYTE *result; // r0
  int v3; // r2
  _BYTE *v4; // r3
  unsigned int v5; // r1
  _BYTE *v6; // r2
  int v7; // r3
  unsigned int v8; // r1
  _BYTE *v9; // r3
  int v10; // r3
  int v11; // r3
  int v12; // r12
  int v13; // r8
  __int64 v14; // r2
  int v15; // r3
  int v16; // r3
  _BOOL4 v17; // r12
  int v18; // r1
  _BOOL4 v19; // r1

  do
  {
    while ( 2 )
    {
      result = a1 + 89;
      do
      {
        if ( *((_BYTE *)a1 + 5) == 1 )
        {
          while ( 1 )
          {
            v3 = *a1;
            v4 = (_BYTE *)a1[16];
            v5 = a1[15];
            if ( !*(_DWORD *)(*a1 + 16) )
              break;
            if ( v5 <= (unsigned int)v4 )
              goto LABEL_8;
            v6 = *(_BYTE **)(v3 + 8);
            a1[16] = v4 + 1;
            *v6 = *v4;
            v7 = *a1;
            v8 = *(_DWORD *)(*a1 + 28);
            *(_DWORD *)(v7 + 16) = *(_DWORD *)(*a1 + 16) - 1;
            ++*(_DWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 24) = __PAIR64__(v8, *(_DWORD *)(v7 + 24)) + 1;
          }
          if ( v5 > (unsigned int)v4 )
            return result;
LABEL_8:
          if ( *((_BYTE *)a1 + 4) == 4 && !*(_DWORD *)(v3 + 12) && (a1[11] > 0xFFu || (int)a1[12] <= 0) )
            return result;
          v9 = a1 + 25;
          a1[13] = 0;
          a1[20] = -1;
          do
            *v9++ = 0;
          while ( result != v9 );
          v10 = a1[22];
          *((_BYTE *)a1 + 5) = 2;
          a1[22] = v10 + 1;
        }
      }
      while ( *((_BYTE *)a1 + 5) != 2 );
      while ( 1 )
      {
        v11 = *(_DWORD *)(*a1 + 12);
        if ( !v11 )
          break;
        v12 = a1[13];
        if ( v12 >= a1[14] )
          break;
        v13 = **(unsigned __int8 **)(*a1 + 4);
        v14 = *(_QWORD *)(a1 + 11);
        if ( v13 == (_DWORD)v14 )
        {
          if ( HIDWORD(v14) != 255 )
          {
            a1[12] = HIDWORD(v14) + 1;
            goto LABEL_21;
          }
        }
        else
        {
          if ( HIDWORD(v14) == 1 )
          {
            a1[20] = *(_DWORD *)(a1[19] + 4 * ((unsigned __int8)v14 ^ HIBYTE(a1[20]))) ^ (a1[20] << 8);
            *((_BYTE *)a1 + v14 + 100) = 1;
            *(_BYTE *)(a1[8] + v12) = v14;
            v15 = a1[13];
            a1[11] = v13;
            a1[13] = v15 + 1;
            goto LABEL_21;
          }
          if ( (unsigned int)v14 > 0xFF )
            goto LABEL_26;
        }
        sub_3A73C(a1);
LABEL_26:
        a1[11] = v13;
        a1[12] = 1;
LABEL_21:
        v16 = *a1;
        *(_DWORD *)(v16 + 4) = *(_DWORD *)(*a1 + 4) + 1;
        --*(_DWORD *)(v16 + 12);
      }
      v17 = *((unsigned __int8 *)a1 + 4) != 2;
      if ( v11 )
        v17 = 0;
      if ( v17 )
      {
        if ( a1[11] <= 0xFFu )
          sub_3A73C(a1);
        v18 = *((unsigned __int8 *)a1 + 4);
        a1[11] = 256;
        a1[12] = 0;
        v19 = v18 == 4;
LABEL_33:
        sub_3BA6C(a1, v19);
        *((_BYTE *)a1 + 5) = 1;
        continue;
      }
      break;
    }
    result = (_BYTE *)a1[13];
    if ( (int)result >= a1[14] )
    {
      v19 = 0;
      goto LABEL_33;
    }
  }
  while ( v11 );
  return result;
}

//----- (0003BDB8) --------------------------------------------------------
unsigned int sub_3BDB8()
{
  int v0; // r7
  char *v1; // r6
  unsigned int i; // r3
  char *v3; // r4
  void *v4; // r0
  void *v5; // r0
  _DWORD *v6; // r0
  char *v7; // r2
  ssize_t v8; // r0
  ssize_t v9; // r5
  unsigned int v10; // r4
  void **v11; // r5
  _DWORD *v13; // r4
  int v14; // r4
  int v15; // r11
  ssize_t v16; // r0
  int v17; // r1
  int v18; // r2
  int *v19; // r3
  bool v20; // cc
  const char *v21; // r0
  int v22; // r5
  _DWORD *v23; // [sp+0h] [bp-24h] BYREF
  char *v24; // [sp+4h] [bp-20h]
  char *v25; // [sp+8h] [bp-1Ch]
  ssize_t v26; // [sp+Ch] [bp-18h]
  int v27; // [sp+10h] [bp-14h]
  int v28; // [sp+18h] [bp-Ch]
  int v29; // [sp+1Ch] [bp-8h]

  v0 = 0;
  v1 = (char *)sub_1748C(0x4000u);
  for ( i = ((unsigned int)dword_7DBC0 >> 9) | 0x100; ; i >>= 1 )
  {
    ++v0;
    if ( (i & 1) != 0 )
      break;
  }
  v3 = (char *)sub_174DC(0xE5ACu);
  *(_DWORD *)v3 = &v23;
  v4 = sub_1748C(400000 * v0);
  *((_DWORD *)v3 + 2) = v4;
  *((_DWORD *)v3 + 9) = v4;
  *((_DWORD *)v3 + 7) = v4;
  v5 = sub_1748C(4 * (100000 * v0 + 34));
  *((_DWORD *)v3 + 3) = v5;
  *((_DWORD *)v3 + 8) = v5;
  *((_DWORD *)v3 + 4) = sub_1748C(0x40004u);
  v6 = sub_585EC(0, 1);
  *((_WORD *)v3 + 2) = 514;
  v28 = 0;
  v29 = 0;
  *(_QWORD *)(v3 + 44) = 256;
  *((_DWORD *)v3 + 20) = -1;
  v7 = v3 + 100;
  *((_DWORD *)v3 + 19) = v6;
  v3[6] = v0;
  *((_DWORD *)v3 + 14) = 100000 * v0 - 19;
  v23 = v3;
  *((_DWORD *)v3 + 13) = 0;
  do
    *v7++ = 0;
  while ( v7 != v3 + 356 );
  ++*((_DWORD *)v3 + 22);
  do
  {
    v8 = sub_18050(0, v1, 0x2000u);
    v9 = v8;
    if ( v8 < 0 )
    {
      v10 = -1;
      sub_16AF4("read error");
      break;
    }
    v26 = v8;
    v24 = v1;
    while ( 1 )
    {
      v13 = v23;
      v27 = 0x2000;
      v25 = v1 + 0x2000;
      if ( *((_BYTE *)v23 + 4) == 2 )
      {
        if ( v9 )
        {
          v14 = 1;
          sub_3BB70(v23);
          goto LABEL_14;
        }
        *((_BYTE *)v23 + 4) = 4;
      }
      sub_3BB70(v13);
      if ( *(_DWORD *)(*v13 + 12) || v13[11] <= 0xFFu && (int)v13[12] > 0 )
        v14 = 3;
      else
        v14 = v13[16] >= v13[15] ? 4 : 3;
LABEL_14:
      v15 = 0x2000 - v27;
      if ( v27 != 0x2000 )
      {
        v16 = sub_17FB8(1, v1 + 0x2000, 0x2000 - v27);
        if ( v15 != v16 )
          break;
      }
      if ( v14 == 4 )
      {
        v10 = 0;
        goto LABEL_22;
      }
      if ( v9 )
      {
        v10 = v26;
        if ( !v26 )
          goto LABEL_22;
      }
    }
    v20 = v16 < 0;
    v10 = -1;
    if ( v16 < 0 )
    {
      v21 = "write error";
    }
    else
    {
      v19 = &dword_7DB94;
      v18 = 0;
      v21 = "short write";
    }
    if ( !v20 )
    {
      v19 = (int *)*v19;
      *v19 = v18;
    }
    sub_16AF4(v21, v17, v18, v19, v23, v24, v25);
LABEL_22:
    if ( v9 )
      v22 = v10 >> 31;
    else
      v22 = 1;
  }
  while ( !v22 );
  v11 = (void **)v23;
  free((void *)v23[2]);
  free(v11[3]);
  free(v11[4]);
  free(v11[19]);
  free(v11);
  free(v1);
  return v10;
}
// 3BF8C: variable 'v19' is possibly undefined
// 3BF90: variable 'v18' is possibly undefined
// 3BF94: variable 'v17' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0003C048) --------------------------------------------------------
int __fastcall sub_3C048(int a1, char **a2)
{
  if ( (sub_593CC(a2, "^cfkvqdtzs123456789") & 0x60) != 0 )
    return sub_3D008(a1, a2);
  else
    return sub_3CD8C(
             (int *)&a2[optind],
             (int (__fastcall *)(_BYTE *))sub_3BDB8,
             (int (__fastcall *)(int, int))sub_3CD78,
             (int)"bz2");
}
// 7D604: using guessed type int optind;

//----- (0003C0AC) --------------------------------------------------------
int __fastcall sub_3C0AC(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // r0
  int v5; // r1
  int v6; // r2
  FILE *v7; // r4
  const char *v8; // r0
  unsigned int v9; // r5
  const char *v10; // r0
  _DWORD *v11[2]; // [sp+4h] [bp-Ch] BYREF
  int v12; // [sp+Ch] [bp-4h] BYREF

  v11[1] = a3;
  v11[0] = a1;
  v12 = 0;
  while ( v11[0] )
  {
    v4 = sub_5D2FC(v11);
    v7 = (FILE *)sub_61D20(v4);
    while ( 1 )
    {
      v8 = sub_58D24(v7, v5, v6);
      v9 = (unsigned int)v8;
      if ( !v8 )
        break;
      v10 = sub_16AA8(v8, 47);
      if ( v9 < (unsigned int)v10 )
        *v10 = 0;
      sub_5D2C8(&v12, v9);
    }
    fclose(v7);
  }
  return v12;
}
// 3C0EC: variable 'v5' is possibly undefined
// 3C0EC: variable 'v6' is possibly undefined

//----- (0003C124) --------------------------------------------------------
void *__fastcall sub_3C124(void *a1, size_t a2, __int64 a3)
{
  char *v5; // r1
  char s[28]; // [sp+Ch] [bp-1Ch] BYREF

  v5 = &s[sprintf(s, "%0*llo", a2, a3) - a2];
  if ( *v5 == 48 )
    ++v5;
  return memcpy(a1, v5, a2);
}

//----- (0003C178) --------------------------------------------------------
int __fastcall sub_3C178(ssize_t *a1, const char *a2, const char *a3, int a4)
{
  const char *v8; // r0
  const char *v9; // r0
  ssize_t v10; // r6
  ssize_t v11; // r6
  int v12; // r5
  int v13; // r2
  int v14; // r3
  FILE *v15; // r0
  const char *v16; // r3
  int v18; // r3
  const char *v19; // r0
  char *v20; // r5
  char v21; // r3
  unsigned __int64 v22; // r0
  unsigned int v23; // r0
  unsigned int v24; // r0
  char v25; // r3
  __int64 v26; // r2
  bool v27; // cc
  _DWORD _0[134]; // [sp+0h] [bp-200h] BYREF

  memset(_0, 0, 0x200u);
  strncpy((char *)_0, a2, 0x64u);
  sub_3C124(&_0[25], 8u, *(_DWORD *)(a4 + 16) & 0xFFFLL);
  sub_3C124(&_0[27], 8u, *(unsigned int *)(a4 + 24));
  sub_3C124(&_0[29], 8u, *(unsigned int *)(a4 + 28));
  memset(&_0[31], 48, 0xBu);
  sub_3C124(&_0[34], 0xCu, *(_DWORD *)(a4 + 80) & ~(*(int *)(a4 + 80) >> 31));
  v8 = (const char *)sub_5E890(*(_DWORD *)(a4 + 24));
  sub_60B34((char *)&_0[66] + 1, v8, 32);
  v9 = (const char *)sub_5E8A8(*(_DWORD *)(a4 + 28));
  sub_60B34((char *)&_0[74] + 1, v9, 32);
  v10 = a1[4];
  if ( v10 )
  {
    LOBYTE(_0[39]) = 49;
    strncpy((char *)&_0[39] + 1, (const char *)(v10 + 24), 0x64u);
    goto LABEL_3;
  }
  v18 = *(_DWORD *)(a4 + 16) & 0xF000;
  switch ( v18 )
  {
    case 40960:
      v19 = (const char *)sub_17C9C(a3);
      v20 = (char *)v19;
      if ( !v19 )
        return 0;
      LOBYTE(_0[39]) = 50;
      strncpy((char *)&_0[39] + 1, v19, 0x64u);
      if ( LOBYTE(_0[64]) )
      {
        free(v20);
        sub_16DDC("names longer than 100 chars not supported");
        return 0;
      }
      free(v20);
      goto LABEL_3;
    case 16384:
      LOBYTE(_0[39]) = 53;
      if ( !HIBYTE(_0[24]) )
        *((_BYTE *)_0 + strlen((const char *)_0)) = 47;
      goto LABEL_3;
    case 8192:
      v21 = 51;
LABEL_27:
      v22 = *(_QWORD *)(a4 + 32);
      LOBYTE(_0[39]) = v21;
      v23 = gnu_dev_major(v22);
      sub_3C124((char *)&_0[82] + 1, 8u, v23);
      v24 = gnu_dev_minor(*(_QWORD *)(a4 + 32));
      sub_3C124((char *)&_0[84] + 1, 8u, v24);
      goto LABEL_3;
    case 24576:
      v21 = 52;
      goto LABEL_27;
    case 4096:
      v25 = 54;
      break;
    case 32768:
      v26 = *(_QWORD *)(a4 + 48);
      v27 = HIDWORD(v26) > 0xF;
      if ( HIDWORD(v26) == 15 )
        v27 = 0;
      if ( v27 )
        sub_16DBC("can't store file '%s' of size %llu, aborting", a3, v26);
      sub_3C124(&_0[31], 0xCu, v26);
      v25 = 48;
      break;
    default:
      sub_16DDC("%s: unknown file type", a3);
      return 0;
  }
  LOBYTE(_0[39]) = v25;
LABEL_3:
  v11 = *a1;
  v12 = 0;
  strcpy((char *)&_0[64] + 1, "ustar  ");
  v13 = 0;
  memset(&_0[37], 32, 8);
  do
  {
    v14 = *((unsigned __int8 *)_0 + v12++);
    v13 += v14;
  }
  while ( v12 != 512 );
  sub_3C124(&_0[37], 7u, v13);
  sub_176C8(v11, (char *)_0, 0x200u);
  if ( a1[1] )
  {
    v15 = (FILE *)stdout;
    if ( *a1 == 1 )
      v15 = (FILE *)stderr;
    v16 = "";
    if ( (*(_DWORD *)(a4 + 16) & 0xF000) == 0x4000 )
      v16 = "/";
    fprintf(v15, "%s%s\n", a2, v16);
  }
  return 1;
}
// 7D608: using guessed type int stderr;
// 7D614: using guessed type int stdout;

//----- (0003C4AC) --------------------------------------------------------
int __fastcall sub_3C4AC(const char *a1, int a2, int a3)
{
  const char *v6; // r0
  int v8; // r3
  const char *v9; // r6
  int *i; // r12
  size_t v11; // r0
  char *v12; // r0
  int v13; // r3
  int **j; // r8
  int v15; // r8
  const char *v16; // r0
  const char *v17; // r9
  int v18; // r3
  int v19; // t1
  size_t v20; // r4

  v6 = (const char *)sub_40108(a1);
  if ( !*v6 )
    return 1;
  v8 = *(_DWORD *)(a2 + 16) & 0xF000;
  if ( v8 == 49152 )
  {
    sub_16DDC("%s: socket ignored", a1);
    return 1;
  }
  v9 = v6;
  *(_DWORD *)(a3 + 16) = 0;
  if ( v8 != 0x4000 && *(_DWORD *)(a2 + 20) > 1u )
  {
    for ( i = *(int **)(a3 + 12);
          i && (*(_QWORD *)(a2 + 96) != *((_QWORD *)i + 2) || *(_QWORD *)a2 != *((_QWORD *)i + 1));
          i = (int *)*i )
    {
      ;
    }
    *(_DWORD *)(a3 + 16) = i;
    if ( !i )
    {
      v11 = strlen(v6);
      v12 = (char *)sub_1748C(v11 + 32);
      v13 = *(_DWORD *)(a3 + 12);
      *(_DWORD *)(a3 + 12) = v12;
      v12 += 24;
      *((_DWORD *)v12 - 6) = v13;
      *((_QWORD *)v12 - 2) = *(_QWORD *)a2;
      *((_QWORD *)v12 - 1) = *(_QWORD *)(a2 + 96);
      strcpy(v12, v9);
    }
  }
  if ( *(_QWORD *)(a3 + 24) == *(_QWORD *)a2 && *(_QWORD *)(a3 + 120) == *(_QWORD *)(a2 + 96) )
  {
    sub_16DDC("%s: file is the archive; skipping", a1);
    return 1;
  }
  for ( j = *(int ***)(a3 + 8); ; j = (int **)*j )
  {
    if ( !j )
    {
      if ( strlen(v9) > 0x63 )
      {
        sub_16DDC("names longer than 100 chars not supported");
        return 1;
      }
      if ( *(_DWORD *)(a3 + 16) || (*(_DWORD *)(a2 + 16) & 0xF000) != 0x8000 )
      {
        v15 = -1;
      }
      else
      {
        v15 = sub_1760C(a1, 0);
        if ( v15 < 0 )
          return 0;
      }
      if ( sub_3C178((ssize_t *)a3, v9, a1, a2) )
      {
        if ( v15 != -1 )
        {
          sub_17F58(v15, *(_DWORD *)a3, *(_QWORD *)(a2 + 48));
          close(v15);
          v20 = -*(_DWORD *)(a2 + 48) & 0x1FF;
          memset(&buf, 0, v20);
          sub_176C8(*(_DWORD *)a3, (char *)&buf, v20);
        }
        return 1;
      }
      return 0;
    }
    v16 = (const char *)j[1];
    if ( *v16 == 47 )
      break;
    v17 = v9 - 1;
    while ( 1 )
    {
      v19 = *(unsigned __int8 *)++v17;
      v18 = v19;
      if ( !v19 )
        break;
      if ( (v9 == v17 || *(v17 - 1) == 47) && v18 != 47 && !fnmatch((const char *)j[1], v17, 9) )
        return 2;
    }
LABEL_27:
    ;
  }
  if ( fnmatch(v16, v9, 9) )
    goto LABEL_27;
  return 2;
}

//----- (0003C720) --------------------------------------------------------
int __fastcall sub_3C720(int a1, const char *a2)
{
  __pid_t v2; // r4
  int v6; // [sp+10h] [bp-8h] BYREF
  int fd; // [sp+14h] [bp-4h]

  sub_1766C(&v6);
  signal(13, (__sighandler_t)1);
  v2 = vfork();
  if ( v2 < 0 )
    sub_16B40("vfork");
  if ( !v2 )
  {
    close(fd);
    sub_176A8(v6, 0);
    sub_176A8(a1, 1);
    execlp(a2, a2, "-f", 0);
    exit(1);
  }
  sub_176A8(fd, a1);
  return close(v6);
}
// 3C7C4: conditional instruction was optimized away because %var_C.4==0
// 7DB94: using guessed type int dword_7DB94;

//----- (0003C7FC) --------------------------------------------------------
int __fastcall sub_3C7FC(int *a1, int a2, int **a3, const char *a4)
{
  int v8; // r4
  int v10; // r0
  int stat_loc; // [sp+Ch] [bp-4h] BYREF

  stat_loc = (int)a4;
  sub_17A30(*a1, (int)(a1 + 6), "can't stat tar file");
  if ( a4 )
    sub_3C720(*a1, a4);
  v8 = 0;
  while ( a3 )
  {
    v10 = sub_60474((const char *)a3[1], a2, (int (*)())sub_3C4AC, (int (*)())sub_3C4AC, (int)a1, 0);
    a3 = (int **)*a3;
    if ( !v10 )
      v8 = 1;
  }
  memset(&buf, 0, 0x400u);
  sub_176C8(*a1, (char *)&buf, 0x400u);
  close(*a1);
  if ( v8 )
    sub_16DDC("error exit delayed from previous errors");
  if ( a4 )
  {
    if ( sub_17398(-1, &stat_loc, 0) == -1 )
    {
      sub_16AF4("waitpid");
    }
    else if ( (stat_loc & 0x7F) != 0 )
    {
      return 1;
    }
    else if ( (stat_loc & 0xFF00) != 0 )
    {
      return 1;
    }
  }
  return v8;
}

//----- (0003C90C) --------------------------------------------------------
int __fastcall sub_3C90C(int a1, int a2)
{
  _DWORD *v3; // r4
  const char *v4; // r0
  int v5; // r3
  bool v6; // zf
  char *v7; // r0
  int v8; // r1
  int (__fastcall *v9)(int); // r2
  unsigned int v10; // r5
  int (__fastcall *v11)(const char **); // r3
  int v12; // r7
  bool v13; // zf
  _DWORD *v14; // r0
  int v15; // r0
  int v16; // r1
  int *v17; // r3
  int v18; // r2
  int *v19; // r6
  _DWORD *v20; // r0
  const char *v21; // r0
  const char *v22; // t1
  int v23; // r3
  const char *v24; // r0
  int v25; // r1
  int v26; // r3
  const char *v27; // r6
  int *v28; // r0
  int v30; // r0
  int v31; // r1
  int v32; // r2
  int v33; // r0
  const char *v34; // [sp+20h] [bp-10h] BYREF
  const char *v35; // [sp+24h] [bp-Ch] BYREF
  int (__fastcall *v36)(const char **); // [sp+28h] [bp-8h] BYREF
  int *v37; // [sp+2Ch] [bp-4h] BYREF

  v34 = 0;
  v35 = "-";
  v36 = 0;
  v37 = 0;
  v3 = sub_3FD30();
  *v3 = 7;
  v6 = getuid() == 0;
  v4 = *(const char **)(a2 + 4);
  if ( !v6 )
    *v3 |= 0x20u;
  if ( v4 )
  {
    v5 = *(unsigned __int8 *)v4;
    v6 = v5 == 0;
    if ( *v4 )
      v6 = v5 == 45;
    if ( !v6 )
    {
      v7 = strchr(v4, 102);
      if ( v7 )
      {
        while ( v7[1] )
        {
          *v7 = v7[1];
          ++v7;
        }
        *v7 = 102;
      }
      *(_DWORD *)(a2 + 4) = sub_177E4("-%s", *(const char **)(a2 + 4));
    }
  }
  v10 = sub_593F8((char **)a2, aTxcFOopvkchtXZ, "list", &v34, &v35, v3 + 3, v3 + 4, v3 + 14, &v37, &v36, &v36);
  v11 = v36;
  v12 = 4 * optind;
  if ( v36 )
  {
    v13 = v36 == (int (__fastcall *)(const char **))1;
    v9 = sub_3FC48;
    if ( v36 == (int (__fastcall *)(const char **))1 )
      v11 = sub_3FC40;
    v3[8] = sub_3FC48;
    if ( v13 )
      v3[8] = v11;
  }
  v14 = (_DWORD *)v3[4];
  if ( (v10 & 2) != 0 )
    v3[9] = sub_3D050;
  if ( (v10 & 0x10) != 0 )
    v3[9] = sub_3D420;
  if ( (v10 & 0x100) != 0 )
    *v3 &= ~4u;
  if ( (v10 & 0x20000) != 0 )
    *v3 |= 0x40u;
  if ( (v10 & 0x20) != 0 )
    *v3 |= 0x10u;
  if ( (v10 & 0x40000) != 0 )
    *v3 |= 0x20u;
  if ( (v10 & 0x80000) != 0 )
    *v3 = *v3 & 0xFFFFFF7B | 0x80;
  if ( (v10 & 0x4000) != 0 )
    *v3 &= ~1u;
  v15 = sub_3C0AC(v14, v8, v9);
  v17 = v37;
  v18 = 0;
  v3[4] = v15;
  while ( v17 )
  {
    v16 = *v17;
    *v17 = v3[4];
    v18 = 1;
    v3[4] = v17;
    v17 = (int *)v16;
  }
  v19 = (int *)(a2 + v12 - 4);
  v20 = (_DWORD *)v3[3];
  if ( v18 )
    v37 = 0;
  v3[3] = sub_3C0AC(v20, v16, (_DWORD *)v18);
  while ( 1 )
  {
    v22 = (const char *)v19[1];
    ++v19;
    v21 = v22;
    if ( !v22 )
      break;
    v24 = sub_16AA8(v21, 47);
    if ( *v19 < (unsigned int)v24 )
      *v24 = 0;
    sub_5D2C8(v3 + 3, *v19);
  }
  v23 = v3[3];
  if ( v23 || v3[4] )
    v3[2] = sub_3F500;
  if ( (v10 & 0x200) != 0 )
  {
    if ( !v23 )
      sub_16DBC("empty archive");
    v25 = 577;
    v26 = 1;
  }
  else
  {
    v25 = 0;
    v26 = 0;
  }
  if ( *v35 != 45 || v35[1] )
  {
    if ( v25 || (v10 & 0x2000) != 0 )
    {
      v3[1] = sub_175D8(v35, v25);
    }
    else
    {
      v30 = sub_40000((int)v35, 0);
      v3[1] = v30;
      if ( v30 < 0 )
        sub_16B40("can't open '%s'", v35);
    }
  }
  else
  {
    v3[1] = v26;
    v3[10] = sub_400F8;
  }
  if ( v34 )
    sub_178FC(v34);
  if ( (v10 & 0x200) != 0 )
  {
    v27 = "gzip";
    if ( (v10 & 0x2000) == 0 )
      v27 = 0;
    v28 = (int *)sub_174DC(0x80u);
    *v28 = v3[1];
    v28[1] = (int)v36;
    v28[2] = v3[4];
    return sub_3C7FC(v28, (v10 >> 9) & 2 | ((v10 ^ 0x10000) >> 16) & 1, (int **)v3[3], v27);
  }
  else
  {
    if ( (v10 & 0x2000) != 0 )
    {
      sub_3FF4C(v3[1], v10 & 0x200, sub_3F2A0);
      v3[10] = sub_400F8;
    }
    dword_7DBA0 = 1;
    while ( !sub_3F6D0((int)v3) )
      dword_7DBA0 = 0;
    sub_40244(v3[7]);
    while ( 1 )
    {
      v33 = v3[3];
      if ( !v33 )
        break;
      if ( !sub_3F54C(v3[4], *(char **)(v33 + 4)) && !sub_3F54C(v3[5], *(char **)(v3[3] + 4)) )
        sub_16DBC("%s: not found in archive", *(const char **)(v3[3] + 4));
      v3[3] = *(_DWORD *)v3[3];
    }
    sub_3FF04(0, v31, v32);
    return dword_7DBA0;
  }
}
// 3CA84: variable 'v8' is possibly undefined
// 3CA84: variable 'v9' is possibly undefined
// 3CAB4: variable 'v16' is possibly undefined
// 3CC94: variable 'v31' is possibly undefined
// 3CC94: variable 'v32' is possibly undefined
// 7D604: using guessed type int optind;
// 7DBA0: using guessed type int dword_7DBA0;

//----- (0003CD38) --------------------------------------------------------
const char *__fastcall sub_3CD38(const char *a1, const char *a2)
{
  char *v4; // r0
  char *v5; // r4
  int v6; // r0

  v4 = strrchr(a1, 46);
  v5 = v4;
  if ( v4 )
  {
    v6 = strcmp(v4 + 1, a2);
    if ( v6 )
      v5 = 0;
    else
      *v5 = 0;
    if ( !v6 )
      return a1;
  }
  return v5;
}

//----- (0003CD78) --------------------------------------------------------
char *__fastcall sub_3CD78(const char *a1, const char *a2)
{
  return sub_177E4("%s.%s", a1, a2);
}

//----- (0003CD8C) --------------------------------------------------------
int __fastcall sub_3CD8C(int *a1, int (__fastcall *a2)(_BYTE *), int (__fastcall *a3)(int, int), int a4)
{
  int v7; // r6
  int v8; // r5
  char *v9; // r4
  int v10; // r0
  int v11; // r0
  const char *v12; // r0
  int v13; // r0
  int v14; // r0
  int v15; // r3
  const char *v16; // r0
  int v17; // t1
  int v20; // [sp+4h] [bp-B8h]
  struct timeval tvp; // [sp+8h] [bp-B4h] BYREF
  __time_t v22; // [sp+10h] [bp-ACh]
  int v23; // [sp+14h] [bp-A8h]
  _BYTE v24[12]; // [sp+18h] [bp-A4h] BYREF
  int v25; // [sp+24h] [bp-98h]
  __time_t v26; // [sp+4Ch] [bp-70h]

  v7 = 0;
  do
  {
    v8 = *a1;
    if ( *a1 )
    {
      if ( *(_BYTE *)v8 == 45 && !*(_BYTE *)(v8 + 1) )
      {
        v8 = *(unsigned __int8 *)(v8 + 1);
      }
      else
      {
        v9 = (char *)sub_62DFC();
        if ( v9 )
        {
          v7 = 1;
          v9 = 0;
          sub_16B80((const char *)v8);
          goto LABEL_7;
        }
        v10 = sub_175E0((const char *)v8, 0);
        if ( v10 < 0 )
          goto LABEL_20;
        sub_176A8(v10, 0);
      }
    }
    if ( (dword_7DBC0 & 0x41) != 0 )
    {
      v8 = dword_7DBC0 & 0x40;
      if ( (dword_7DBC0 & 0x40) != 0 )
      {
        v11 = sub_175E0("/dev/null", 1);
        if ( v11 < 0 )
          sub_16E08();
        v8 = 0;
        sub_176A8(v11, 1);
      }
LABEL_14:
      v9 = (char *)v8;
      goto LABEL_25;
    }
    if ( !v8 )
      goto LABEL_14;
    v12 = (const char *)a3(v8, a4);
    v9 = (char *)v12;
    if ( !v12 )
    {
      sub_16DDC("%s: unknown suffix - ignored", (const char *)v8);
LABEL_20:
      v7 = 1;
      goto LABEL_7;
    }
    if ( (dword_7DBC0 & 2) != 0 )
      unlink(v12);
    v13 = sub_175E0(v9, 193);
    if ( v13 < 0 )
    {
      v7 = 1;
      goto LABEL_40;
    }
    sub_176A8(v13, 1);
LABEL_25:
    if ( (dword_7DBC0 & 2) == 0 && isatty(0) )
      sub_16DBC("compressed data not read from terminal, use -f to force it");
    sub_3FDF0(v24);
    v25 = 1;
    v14 = a2(v24);
    if ( v14 < 0 )
      v7 = 1;
    v15 = v14;
    if ( (dword_7DBC0 & 1) == 0 )
    {
      v20 = v14;
      sub_17700(1);
      v15 = v20;
    }
    if ( v8 )
    {
      if ( v15 >= 0 )
      {
        if ( v26 )
        {
          tvp.tv_sec = v26;
          v22 = v26;
          tvp.tv_usec = 0;
          v23 = 0;
          utimes(v9, &tvp);
        }
        if ( v9 == (char *)v8 )
          v9[strlen(v9)] = 46;
        if ( (dword_7DBC0 & 4) != 0 )
          goto LABEL_40;
        v16 = (const char *)v8;
        goto LABEL_48;
      }
      if ( v9 )
      {
        v16 = v9;
LABEL_48:
        sub_1761C(v16);
LABEL_40:
        if ( v9 == (char *)v8 )
          goto LABEL_41;
      }
LABEL_7:
      free(v9);
    }
LABEL_41:
    if ( !*a1 )
      break;
    v17 = a1[1];
    ++a1;
  }
  while ( v17 );
  if ( (dword_7DBC0 & 1) != 0 )
    sub_17700(1);
  return v7;
}
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0003D008) --------------------------------------------------------
int __fastcall sub_3D008(int a1, char **a2)
{
  sub_593CC(a2, "cfkvqdt");
  return sub_3CD8C(
           (int *)&a2[optind],
           (int (__fastcall *)(_BYTE *))sub_3DE30,
           (int (__fastcall *)(int, int))sub_3CD38,
           (int)"bz2");
}
// 7D604: using guessed type int optind;

//----- (0003D050) --------------------------------------------------------
void __fastcall sub_3D050(_DWORD *a1)
{
  int v2; // r5
  char *v3; // r6
  int v4; // r8
  char *v5; // r4
  char *v6; // r0
  char *v7; // r0
  char *v8; // r0
  char *v9; // r8
  __mode_t v10; // r1
  bool v11; // zf
  int v12; // r3
  int v13; // r1
  int v14; // r6
  __uid_t pw_uid; // r6
  __gid_t gr_gid; // r8
  const char *v17; // r0
  struct passwd *v18; // r0
  const char *v19; // r0
  struct group *v20; // r0
  struct timeval v21; // [sp+0h] [bp-68h] BYREF
  __time_t tv_sec; // [sp+8h] [bp-60h]
  int v23; // [sp+Ch] [bp-5Ch]
  int v24; // [sp+50h] [bp-18h]

  v2 = a1[6];
  if ( (*(_DWORD *)(v2 + 32) & 0xF000) != 0x8000 || *(_QWORD *)(v2 + 16) )
    v3 = 0;
  else
    v3 = *(char **)(v2 + 4);
  v4 = a1[14];
  v5 = *(char **)v2;
  if ( v4 )
  {
    do
    {
      v6 = strchr(v5, 47);
      if ( !v6 || !v6[1] )
        goto LABEL_8;
      v5 = v6 + 1;
      if ( v3 )
      {
        v7 = strchr(v3, 47);
        if ( !v7 || !v7[1] )
          goto LABEL_8;
        v3 = v7 + 1;
      }
    }
    while ( --v4 );
  }
  if ( (*a1 & 2) != 0 )
  {
    v8 = strrchr(v5, 47);
    v9 = v8;
    if ( v8 )
    {
      *v8 = 0;
      sub_5D824(v5, 0xFFFFFFFF, 4);
      *v9 = 47;
    }
  }
  if ( (*a1 & 4) != 0 )
  {
    v10 = *(_DWORD *)(v2 + 32);
    if ( (v10 & 0xF000) == 0x4000 )
    {
      if ( v3 )
        goto LABEL_36;
      goto LABEL_67;
    }
    if ( v3 && !strcmp(v3, v5) )
      return;
    if ( unlink(v5) == -1 )
    {
      v11 = *(_DWORD *)dword_7DB94 == 2;
      goto LABEL_24;
    }
  }
  else
  {
    if ( (*a1 & 8) == 0 )
      goto LABEL_35;
    if ( sub_62E14() == -1 )
    {
      if ( *(_DWORD *)dword_7DB94 != 2 )
        sub_16B40("can't stat old file");
    }
    else
    {
      if ( v24 >= *(_DWORD *)(v2 + 36) )
      {
        if ( (*(_DWORD *)(v2 + 32) & 0xF000) != 0x4000 )
          sub_16DDC("%s not created: newer or same age file exists", v5);
LABEL_8:
        sub_3D434((int)a1);
        return;
      }
      if ( unlink(v5) == -1 )
      {
        v11 = *(_DWORD *)dword_7DB94 == 21;
LABEL_24:
        if ( !v11 )
          sub_16B40("can't remove old file %s", v5);
      }
    }
  }
LABEL_35:
  if ( v3 )
  {
LABEL_36:
    sub_401A0(a1 + 7, v3, v5, 1);
    return;
  }
  v10 = *(_DWORD *)(v2 + 32);
  v12 = v10 & 0xF000;
  if ( v12 == 24576 )
    goto LABEL_64;
  if ( (v10 & 0xF000) <= 0x6000 )
  {
    if ( v12 != 0x2000 )
    {
      if ( v12 != 0x4000 )
      {
        if ( v12 != 4096 )
          goto LABEL_42;
        goto LABEL_64;
      }
LABEL_67:
      if ( mkdir(v5, v10) && (*(_DWORD *)dword_7DB94 & 0xFFFFFFFB) != 0x11 )
        sub_16AF4("can't make dir %s", v5);
      goto LABEL_49;
    }
LABEL_64:
    if ( sub_62E20(v5, v10, *(_QWORD *)(v2 + 40)) )
      sub_16AF4("can't create node %s", v5);
    goto LABEL_49;
  }
  if ( v12 != 40960 )
  {
    if ( v12 != 49152 )
    {
      if ( v12 != 0x8000 )
LABEL_42:
        sub_16DBC("unrecognized file type");
      v13 = 577;
      if ( (*a1 & 0x80) == 0 )
        v13 = 193;
      v14 = sub_175B4(v5, v13);
      sub_17F58(a1[1], v14, *(_QWORD *)(v2 + 16));
      close(v14);
      goto LABEL_49;
    }
    goto LABEL_64;
  }
  sub_401A0(a1 + 7, *(char **)(v2 + 4), v5, 0);
LABEL_49:
  if ( (*(_DWORD *)(v2 + 32) & 0xF000) != 0xA000 )
  {
    if ( (*a1 & 0x10) == 0 )
    {
      pw_uid = *(_DWORD *)(v2 + 24);
      gr_gid = *(_DWORD *)(v2 + 28);
      if ( (*a1 & 0x40) == 0 )
      {
        v17 = *(const char **)(v2 + 8);
        if ( v17 )
        {
          v18 = getpwnam(v17);
          if ( v18 )
            pw_uid = v18->pw_uid;
        }
        v19 = *(const char **)(v2 + 12);
        if ( v19 )
        {
          v20 = getgrnam(v19);
          if ( v20 )
            gr_gid = v20->gr_gid;
        }
      }
      chown(v5, pw_uid, gr_gid);
    }
    if ( (*a1 & 0x20) == 0 )
      chmod(v5, *(_DWORD *)(v2 + 32));
    if ( (*a1 & 1) != 0 )
    {
      v21.tv_sec = *(_DWORD *)(v2 + 36);
      tv_sec = v21.tv_sec;
      v21.tv_usec = 0;
      v23 = 0;
      utimes(v5, &v21);
    }
  }
}
// 7DB94: using guessed type int dword_7DB94;

//----- (0003D420) --------------------------------------------------------
__int64 __fastcall sub_3D420(int a1)
{
  return sub_17F58(*(_DWORD *)(a1 + 4), 1, *(_QWORD *)(*(_DWORD *)(a1 + 24) + 16));
}

//----- (0003D434) --------------------------------------------------------
int __fastcall sub_3D434(int a1)
{
  return (*(int (__fastcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(a1 + 40))(
           *(_DWORD *)(a1 + 4),
           *(_DWORD *)(a1 + 40),
           *(_DWORD *)(*(_DWORD *)(a1 + 24) + 16),
           *(_DWORD *)(*(_DWORD *)(a1 + 24) + 20));
}

//----- (0003D448) --------------------------------------------------------
int __fastcall sub_3D448(int a1, int a2)
{
  int v2; // r7
  int i; // r5
  unsigned int v6; // r3
  int v7; // r5
  ssize_t v9; // r0
  int v10; // r3
  bool v11; // cc
  int v12; // r1
  int v13; // r2
  int v14; // r3

  v2 = 0;
  for ( i = *(_DWORD *)a1; a2 > i; i += 8 )
  {
    if ( *(_DWORD *)(a1 + 20) == *(_DWORD *)(a1 + 16) )
    {
      v9 = read(*(_DWORD *)(a1 + 8), *(void **)(a1 + 24), 0x1000u);
      *(_DWORD *)(a1 + 16) = v9;
      if ( v9 <= 0 )
        longjmp(*(struct __jmp_buf_tag **)(a1 + 68), -3);
      *(_DWORD *)(a1 + 20) = 0;
    }
    v10 = *(_DWORD *)(a1 + 20);
    v11 = i <= 23;
    v12 = *(_DWORD *)(a1 + 24);
    if ( i > 23 )
      a2 -= i;
    v13 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 20) = v10 + 1;
    v14 = *(unsigned __int8 *)(v12 + v10);
    if ( i > 23 )
    {
      v2 = v13 & ~(-1 << i);
      i = 0;
    }
    if ( !v11 )
      v2 <<= a2;
    *(_DWORD *)(a1 + 4) = v14 | (v13 << 8);
  }
  v6 = *(_DWORD *)(a1 + 4);
  v7 = i - a2;
  *(_DWORD *)a1 = v7;
  return ~(-1 << a2) & (v6 >> v7) | v2;
}

//----- (0003D504) --------------------------------------------------------
int __fastcall sub_3D504(_DWORD *a1)
{
  int v2; // r11
  int v3; // r6
  int v4; // r5
  bool v5; // zf
  bool v7; // zf
  int v8; // r5
  __int16 v9; // r6
  __int16 v10; // r0
  int v11; // r0
  int v12; // r6
  int i; // r3
  _BYTE *v14; // r7
  _DWORD *v15; // r5
  int v16; // r7
  int m; // r3
  unsigned __int8 *v18; // r8
  unsigned int v19; // r5
  unsigned int v20; // r6
  int v21; // r7
  int v22; // t1
  unsigned int v23; // r10
  int v24; // r7
  int v25; // r3
  int v26; // r1
  int v27; // r2
  unsigned int v28; // r3
  int v29; // r0
  int v30; // r5
  char v31; // r3
  char *j; // r5
  char v33; // t1
  int v34; // r9
  unsigned int v35; // r8
  int v36; // r0
  int v37; // r1
  int v38; // r3
  int v39; // r2
  int v40; // r0
  _DWORD *v41; // lr
  int v42; // r1
  int v43; // r12
  int v44; // r1
  int v45; // r0
  int v46; // r8
  int v47; // r0
  int v48; // r1
  int v49; // r0
  int v50; // r8
  int v51; // r9
  int v52; // r1
  int v53; // r12
  int v54; // r2
  int v55; // r3
  int *v56; // r2
  char *v57; // r1
  int v58; // t1
  int v59; // r2
  unsigned int v60; // r0
  unsigned int v61; // r3
  int v62; // r1
  int v63; // r12
  int v64; // r2
  int v65; // r1
  int v66; // r2
  _BYTE *v67; // r3
  char v68; // t1
  int v69; // r2
  int v70; // r2
  int n; // r3
  int v72; // r0
  unsigned int ii; // r3
  unsigned int v74; // r2
  _BYTE *v75; // r1
  int v76; // r2
  int v77; // r0
  signed int v78; // [sp+4h] [bp-680h]
  unsigned int v79; // [sp+8h] [bp-67Ch]
  int k; // [sp+Ch] [bp-678h]
  _BYTE *v81; // [sp+10h] [bp-674h]
  unsigned int v82; // [sp+14h] [bp-670h]
  int v83; // [sp+18h] [bp-66Ch]
  int v84; // [sp+1Ch] [bp-668h]
  int v85; // [sp+20h] [bp-664h]
  _DWORD v86[85]; // [sp+2Ch] [bp-658h]
  _BYTE v87[256]; // [sp+180h] [bp-504h] BYREF
  _BYTE v88[1028]; // [sp+280h] [bp-404h] BYREF

  v81 = a1 + 274;
  v2 = a1[15];
  v3 = sub_3D448((int)a1, 24);
  v4 = sub_3D448((int)a1, 24);
  a1[12] = sub_3D448((int)a1, 32);
  v5 = v3 == 1536581;
  if ( v3 == 1536581 )
    v5 = v4 == 3690640;
  if ( v5 )
    return -1;
  v7 = v4 == 2511705;
  if ( v4 == 2511705 )
    v7 = v3 == 3227993;
  if ( !v7 )
    return -2;
  v8 = sub_3D448((int)a1, 1);
  if ( v8 )
    return -7;
  v82 = sub_3D448((int)a1, 24);
  if ( a1[16] < v82 )
    return -5;
  v9 = sub_3D448((int)a1, 16);
  v78 = 0;
  do
  {
    if ( v9 < 0 )
    {
      v10 = sub_3D448((int)a1, 16);
      while ( 1 )
      {
        if ( v10 < 0 )
          *((_BYTE *)&v86[21] + v78++) = v8;
        v10 *= 2;
        if ( ((v8 + 1) & 0xF) == 0 )
          break;
        ++v8;
      }
      v8 -= 15;
    }
    v8 += 16;
    v9 *= 2;
  }
  while ( v8 <= 255 );
  v11 = sub_3D448((int)a1, 3);
  v12 = v11;
  if ( (unsigned int)(v11 - 2) > 4 )
    return -5;
  for ( i = 0; i != v11; ++i )
    v87[i] = i;
  v84 = sub_3D448((int)a1, 15);
  if ( !v84 )
    return -5;
  v14 = v81;
  while ( v84 > v14 - v81 )
  {
    v30 = 0;
    while ( sub_3D448((int)a1, 1) )
    {
      if ( v30 == v12 )
        return -5;
      ++v30;
    }
    v31 = v87[v30];
    for ( j = &v87[v30 - 1]; j - v87 != -1; j[2] = v33 )
      v33 = *j--;
    *v14++ = v31;
    v87[0] = v31;
  }
  v15 = a1 + 8465;
  v16 = v78 + 2;
  for ( k = 0; k != v12; ++k )
  {
    v34 = 0;
    v35 = sub_3D448((int)a1, 5) - 1;
    do
    {
      while ( 1 )
      {
        if ( v35 > 0x13 )
          return -5;
        v36 = sub_3D448((int)a1, 2);
        if ( v36 <= 1 )
          break;
        v35 += (((_BYTE)v36 + 1) & 2) - 1;
      }
      ++*a1;
      v88[v34++] = v35 + 1;
    }
    while ( v16 > v34 );
    v37 = 1;
    v38 = v88[0];
    v39 = v88[0];
    do
    {
      v40 = (unsigned __int8)v88[v37];
      if ( v40 <= v39 )
      {
        if ( v38 >= v40 )
          v38 = (unsigned __int8)v88[v37];
      }
      else
      {
        v39 = (unsigned __int8)v88[v37];
      }
      ++v37;
    }
    while ( v16 > v37 );
    v41 = v15 + 21;
    v42 = v38;
    v43 = 0;
    v15[300] = v38;
    v15[301] = v39;
    while ( v42 <= v39 )
    {
      v86[v42] = 0;
      v49 = 0;
      v15[v42] = 0;
      do
      {
        if ( (unsigned __int8)v88[v49] == v42 )
        {
          v50 = (int)&v15[++v43];
          *(_DWORD *)(v50 + 164) = v49;
        }
        ++v49;
      }
      while ( v16 > v49 );
      ++v42;
    }
    v44 = 0;
    do
    {
      v45 = (unsigned __int8)v88[v44++];
      ++v86[v45];
    }
    while ( v16 > v44 );
    v46 = 0;
    v47 = v38;
    v48 = 0;
    while ( v47 < v39 )
    {
      v51 = v86[v47];
      v52 = v51 + v48;
      v46 += v51;
      v53 = v52 << (v39 - v47);
      v48 = 2 * v52;
      v15[v47++] = v53 - 1;
      v41[v47] = v48 - v46;
    }
    v15[v39] = v86[v39] - 1 + v48;
    v15[v39 + 1] = 0x7FFFFFFF;
    v41[v38] = 0;
    v15 += 301;
  }
  for ( m = 0; m != 256; ++m )
  {
    *(_DWORD *)&v88[4 * m] = 0;
    v87[m] = m;
  }
  v18 = v81;
  v19 = 0;
  v20 = 0;
LABEL_34:
  if ( v84 <= v18 - v81 )
    return -5;
  v22 = *v18++;
  v21 = v22;
  if ( v22 >= k )
    return -5;
  v23 = v19;
  v24 = (int)&a1[301 * v21 + 8466];
  v85 = v24 - 4;
  v83 = 49;
  while ( 1 )
  {
    v25 = *a1;
    v26 = *(_DWORD *)(v24 + 1200);
    v27 = *a1 - v26;
    if ( v27 < 0 )
    {
      v54 = a1[5];
      if ( v54 != a1[4] )
      {
        v62 = a1[6];
        v63 = a1[1];
        a1[5] = v54 + 1;
        v64 = *(unsigned __int8 *)(v62 + v54);
        *a1 = v25 + 8;
        a1[1] = v64 | (v63 << 8);
        goto LABEL_88;
      }
      v29 = sub_3D448((int)a1, v26);
    }
    else
    {
      v28 = a1[1];
      *a1 = v27;
      v29 = ((1 << v26) - 1) & (v28 >> v27);
    }
    v55 = *(_DWORD *)(v24 + 1196);
    v56 = (int *)(v85 + 4 * v55);
    while ( 1 )
    {
      v57 = (char *)v56 - v85;
      v58 = *v56++;
      if ( v58 >= v29 )
        break;
      ++v55;
    }
    v59 = *(_DWORD *)(v24 + 1200) - v55;
    if ( v59 < 0 )
      return -5;
    *a1 += v59;
    v60 = (v29 >> v59) - *(_DWORD *)&v57[v24 + 80];
    if ( v60 > 0x101 )
      return -5;
    v61 = *(_DWORD *)(v24 + 4 * v60 + 164);
    if ( v61 > 1 )
      break;
    if ( v19 )
      v23 = v79;
    else
      v19 = 1;
    v79 = v23 + (v19 << v61);
    if ( a1[16] > v19 )
      v19 *= 2;
LABEL_85:
    if ( --v83 < 0 )
      goto LABEL_34;
LABEL_88:
    v23 = v19;
  }
  if ( v19 )
  {
    if ( v20 + v79 > a1[16] )
      return -5;
    v65 = *((unsigned __int8 *)&v86[21] + v87[0]);
    *(_DWORD *)&v88[4 * v65] += v79;
    while ( (--v79 & 0x80000000) == 0 )
      *(_DWORD *)(v2 + 4 * v20++) = v65;
  }
  if ( v78 >= (int)v61 )
  {
    if ( a1[16] <= v20 )
      return -5;
    v66 = *((unsigned __int8 *)&v86[84] + v61 + 3);
    v67 = &v87[v61 - 1];
    do
    {
      v68 = *--v67;
      v67[1] = v68;
    }
    while ( v87 != v67 );
    v87[0] = v66;
    v19 = 0;
    v69 = *((unsigned __int8 *)&v86[21] + v66);
    *(_DWORD *)(v2 + 4 * v20++) = v69;
    ++*(_DWORD *)&v88[4 * v69];
    goto LABEL_85;
  }
  v70 = 0;
  for ( n = 0; n != 256; ++n )
  {
    v72 = *(_DWORD *)&v88[4 * n];
    *(_DWORD *)&v88[4 * n] = v70;
    v70 += v72;
  }
  for ( ii = 0; ii != v20; ++ii )
  {
    v75 = &v88[4 * *(unsigned __int8 *)(v2 + 4 * ii) + 1024];
    v76 = *((_DWORD *)v75 - 256);
    v77 = *(_DWORD *)(v2 + 4 * v76) | (ii << 8);
    *(_DWORD *)(v2 + 4 * v76) = v77;
    *((_DWORD *)v75 - 256) = v76 + 1;
  }
  if ( ii )
  {
    if ( ii > v82 )
    {
      v74 = *(_DWORD *)(v2 + 4 * v82);
      a1[8] = v74 >> 8;
      a1[11] = (unsigned __int8)v74;
      a1[9] = 5;
      goto LABEL_107;
    }
    return -5;
  }
LABEL_107:
  a1[10] = ii;
  return 0;
}
// 3DA08: variable 'v79' is possibly undefined

//----- (0003DBE8) --------------------------------------------------------
int __fastcall sub_3DBE8(_DWORD *a1, _BYTE *a2, int a3)
{
  int result; // r0
  int v7; // r7
  int v8; // r1
  int v9; // r12
  unsigned int v10; // r3
  int v11; // r2
  int v12; // r1
  bool v13; // zf
  int v14; // r0
  int v15; // r2
  int v16; // r3
  int v17; // r2
  int v18; // r3

  result = a1[10];
  if ( result >= 0 )
  {
    v7 = a1[15];
    v8 = a1[8];
    v9 = a1[11];
    v10 = a1[14];
    if ( !a1[7] )
      goto LABEL_15;
    do
    {
      --a1[7];
LABEL_4:
      if ( --a3 < 0 )
      {
        a1[14] = v10;
        v18 = a1[7];
        a1[8] = v8;
        a1[11] = v9;
        a1[7] = v18 + 1;
        return 0;
      }
      *a2++ = v9;
      v10 = a1[(v9 ^ HIBYTE(v10)) + 18] ^ (v10 << 8);
    }
    while ( a1[7] );
    while ( 1 )
    {
      while ( 1 )
      {
        v11 = a1[10] - 1;
        a1[10] = v11;
        if ( v11 < 0 )
          break;
        v12 = *(_DWORD *)(v7 + 4 * v8);
        v13 = a1[9]-- == 1;
        v14 = (unsigned __int8)v12;
        v8 = v12 >> 8;
        if ( !v13 )
        {
          if ( v14 != v9 )
          {
            v9 = v14;
            a1[9] = 4;
          }
          goto LABEL_4;
        }
        a1[7] = v14;
        a1[9] = 5;
        if ( v14 )
        {
          a1[7] = v14 - 1;
          goto LABEL_4;
        }
      }
      v15 = a1[13];
      v16 = ~v10;
      a1[14] = v16;
      a1[13] = v16 ^ __ROR4__(v15, 31);
      v17 = a1[12];
      if ( v17 != v16 )
      {
        a1[13] = v17 + 1;
        return -1;
      }
LABEL_15:
      result = sub_3D504(a1);
      if ( result )
        break;
      v8 = a1[8];
      v10 = -1;
      v9 = a1[11];
    }
    a1[10] = result;
    if ( result == -1 )
      return a3;
  }
  return result;
}

//----- (0003DD44) --------------------------------------------------------
int __fastcall sub_3DD44(int a1, _DWORD *a2, int a3, const void *a4, size_t a5)
{
  size_t v7; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r4
  void *v12; // r0
  int v13; // r0
  int v14; // r0
  void *v15; // r0

  v7 = 45184;
  if ( a3 == -1 )
    v7 = 41088;
  v10 = sub_174DC(v7);
  v11 = v10;
  *a2 = v10;
  v10[17] = a1;
  v10[2] = a3;
  if ( a3 == -1 )
  {
    v10[6] = a4;
  }
  else
  {
    v12 = v10 + 10272;
    v11[6] = v12;
    memcpy(v12, a4, a5);
  }
  v11[4] = a5;
  sub_585EC(v11 + 18, 1);
  v13 = sub_3D448((int)v11, 16);
  if ( (unsigned int)(v13 - 26673) > 8 )
    return -2;
  v14 = 100000 * v13 + 1627767296;
  v11[16] = v14;
  v15 = sub_17450(4 * v14);
  v11[15] = v15;
  if ( !v15 )
  {
    free(v11);
    sub_16E08();
  }
  return 0;
}

//----- (0003DE14) --------------------------------------------------------
void __fastcall sub_3DE14(void **a1)
{
  free(a1[15]);
  free(a1);
}

//----- (0003DE30) --------------------------------------------------------
int __fastcall sub_3DE30(int *a1)
{
  size_t v1; // r4
  int v2; // r0
  _BYTE *v4; // r1
  size_t i; // [sp+8h] [bp-1A4h]
  size_t v6; // [sp+8h] [bp-1A4h]
  _BYTE *ptr; // [sp+Ch] [bp-1A0h]
  void **v9; // [sp+1Ch] [bp-190h] BYREF
  jmp_buf env; // [sp+20h] [bp-18Ch] BYREF

  if ( sub_3FDFC(a1, 23106) )
    return -1;
  ptr = sub_1748C(0x1000u);
  for ( i = 0; ; i = v6 - 2 )
  {
    v1 = setjmp(env);
    if ( !v1 )
    {
      v1 = sub_3DD44((int)env, &v9, a1[2], ptr + 2, i);
      if ( !v1 )
      {
        while ( 1 )
        {
          v2 = sub_3DBE8(v9, ptr, 4096);
          v1 = v2;
          if ( v2 < 0 )
            break;
          v1 = 4096 - v2;
          if ( 4096 == v2 )
            goto LABEL_20;
          if ( v1 != sub_3FE5C(a1, ptr, v1) )
          {
            v1 = -4;
            goto LABEL_10;
          }
        }
      }
    }
    if ( v1 != -1 )
    {
      sub_16DDC("bunzip error %d", v1);
      goto LABEL_10;
    }
LABEL_20:
    if ( v9[12] != v9[13] )
      break;
    v4 = v9[5];
    v6 = (_BYTE *)v9[4] - v4;
    memcpy(ptr, &v4[(_DWORD)v9[6]], v6);
    if ( v6 <= 1 )
    {
      if ( 2 - v6 != sub_1800C(a1[2], &ptr[v6], 2 - v6) )
        goto LABEL_18;
      v6 = 2;
    }
    if ( *(_WORD *)ptr != 23106 )
    {
LABEL_18:
      v1 = 0;
      goto LABEL_10;
    }
    sub_3DE14(v9);
  }
  sub_16DDC("CRC error");
LABEL_10:
  sub_3DE14(v9);
  free(ptr);
  return v1;
}

//----- (0003DFC8) --------------------------------------------------------
void __fastcall sub_3DFC8(int a1)
{
  void *v2; // r0

  while ( a1 )
  {
    v2 = (void *)(a1 - 8);
    a1 = *(_DWORD *)(a1 - 4);
    free(v2);
  }
}

//----- (0003DFE8) --------------------------------------------------------
int __fastcall sub_3DFE8(int *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7)
{
  int v8; // r3
  unsigned int v10; // r4
  _DWORD *v11; // r0
  _DWORD *v12; // r3
  int *v13; // r0
  int v14; // t1
  _WORD *v15; // r0
  int result; // r0
  unsigned int i; // r2
  signed int v18; // r7
  unsigned int j; // r5
  int v20; // r0
  unsigned int v21; // r3
  int v22; // r3
  char *v23; // r1
  int v24; // r3
  int v25; // r2
  int v26; // r3
  int v27; // r2
  _BYTE *v28; // r2
  int v29; // r1
  int v30; // r2
  char *v31; // r12
  int v32; // r3
  int v33; // r3
  unsigned int k; // r10
  unsigned int v35; // r6
  unsigned int v36; // r2
  unsigned int v37; // r0
  unsigned int v38; // r0
  _DWORD *v39; // r1
  _BOOL4 v40; // r2
  char *v41; // r0
  int v42; // r2
  _DWORD *v43; // r3
  int v44; // r9
  unsigned int v45; // r8
  unsigned int v46; // r1
  char v47; // r6
  unsigned int v48; // lr
  unsigned int m; // r1
  int v50; // r0
  unsigned int v51; // r3
  unsigned int v52; // r0
  char *v53; // r11
  char *v54; // r1
  unsigned int v55; // [sp+4h] [bp-5C8h]
  unsigned int v56; // [sp+8h] [bp-5C4h]
  unsigned int *v57; // [sp+Ch] [bp-5C0h]
  int v59; // [sp+18h] [bp-5B4h]
  int v61; // [sp+30h] [bp-59Ch]
  char *v62; // [sp+34h] [bp-598h]
  _DWORD v63[16]; // [sp+38h] [bp-594h] BYREF
  _DWORD s[17]; // [sp+78h] [bp-554h] BYREF
  _DWORD v65[17]; // [sp+BCh] [bp-510h] BYREF
  _DWORD v66[2]; // [sp+100h] [bp-4CCh]
  char v67; // [sp+108h] [bp-4C4h] BYREF
  _BYTE v68[1160]; // [sp+144h] [bp-488h] BYREF

  if ( a2 > 0x100 )
    v8 = a1[256];
  else
    v8 = 16;
  v10 = a2;
  v56 = v8;
  *a6 = 0;
  v11 = memset(s, 0, sizeof(s));
  v12 = v11;
  v13 = a1;
  do
  {
    v14 = *v13++;
    --v10;
    ++s[v14];
  }
  while ( v10 );
  if ( s[0] == a2 )
  {
    v15 = (char *)sub_174DC(0x18u) + 8;
    *v15 = 355;
    v15[4] = 355;
    *a6 = v15;
    *a7 = 1;
    return 0;
  }
  else
  {
    for ( i = 1; i != 17; ++i )
    {
      if ( v12[i] )
        break;
    }
    v18 = i;
    for ( j = 16; ; --j )
    {
      v20 = v12[j];
      if ( v20 )
        break;
      if ( !j )
      {
        v20 = 0;
        break;
      }
    }
    v21 = *a7;
    if ( *a7 >= i )
    {
      if ( v21 >= j )
        v21 = j;
    }
    else
    {
      v21 = i;
    }
    *a7 = v21;
    v22 = 1 << i;
    while ( j > i )
    {
      v33 = v22 - s[i];
      if ( v33 < 0 )
        return 2;
      ++i;
      v22 = 2 * v33;
    }
    v59 = v22 - v20;
    if ( v22 - v20 < 0 )
      return 2;
    v23 = &v67;
    s[j] = v22;
    v24 = 0;
    v25 = 0;
    v66[1] = 0;
    while ( j != ++v25 )
    {
      v24 += s[v25];
      *(_DWORD *)v23 = v24;
      v23 += 4;
    }
    memset(v68, 255, 0x484u);
    v26 = 0;
    do
    {
      v27 = a1[v26];
      if ( v27 )
      {
        v28 = &v68[4 * v27 + 1156];
        v29 = *((_DWORD *)v28 - 306);
        *((_DWORD *)v28 - 306) = v29 + 1;
        *(_DWORD *)&v68[4 * v29] = v26;
      }
      ++v26;
    }
    while ( a2 != v26 );
    v66[0] = 0;
    LOBYTE(v30) = 0;
    v65[0] = 0;
    v31 = 0;
    v63[0] = 0;
    v55 = 0;
    v57 = (unsigned int *)v68;
    v32 = -1;
    while ( v18 <= (int)j )
    {
      for ( k = s[v18]; k; --k )
      {
        while ( 1 )
        {
          v44 = v32 + 1;
          v45 = v65[v32 + 1];
          if ( (int)v45 >= v18 )
            break;
          v35 = v18 - v45;
          v36 = j - v45;
          v37 = 1 << (v18 - v45);
          if ( j - v45 >= *a7 )
            v36 = *a7;
          if ( k < v37 )
          {
            v38 = v37 - k;
            v39 = &s[v18 - v35];
            while ( v36 > ++v35 )
            {
              v51 = v39[v35];
              v52 = 2 * v38;
              if ( v51 >= v52 )
                break;
              v38 = v52 - v51;
            }
          }
          v40 = v45 + v35 > v56;
          if ( v45 >= v56 )
            v40 = 0;
          if ( v40 )
            v35 = v56 - v45;
          v55 = 1 << v35;
          v65[v44 + 1] = v45 + v35;
          v41 = (char *)sub_174DC(8 * ((1 << v35) + 1));
          v31 = v41 + 8;
          *a6 = v41 + 8;
          a6 = v41 + 4;
          v63[v44] = v41 + 8;
          if ( v44 )
          {
            v42 = v65[v44 - 1];
            v66[v44] = v10;
            v62 = v41 + 8;
            LOBYTE(v61) = v35 + 16;
            BYTE1(v61) = v45 - v42;
            v43 = (_DWORD *)(v63[v44 - 1] + 8 * ((((1 << v45) - 1) & v10) >> v42));
            *v43 = v61;
            v43[1] = v41 + 8;
          }
          LOBYTE(v30) = v45;
          v32 = v44;
        }
        v46 = *v57;
        if ( *v57 == -1 )
        {
          v47 = 99;
        }
        else
        {
          ++v57;
          if ( v46 >= a3 )
          {
            v46 -= a3;
            v47 = *(_BYTE *)(a5 + v46);
            LOWORD(v46) = *(_WORD *)(a4 + 2 * v46);
          }
          else if ( v46 == 256 )
          {
            v47 = 15;
          }
          else
          {
            v47 = 16;
          }
          LOWORD(v62) = v46;
        }
        v48 = v10 >> v30;
        while ( v48 < v55 )
        {
          LOBYTE(v61) = v47;
          v53 = &v31[8 * v48];
          BYTE1(v61) = v18 - v30;
          v48 += 1 << (v18 - v30);
          v54 = v62;
          *(_DWORD *)v53 = v61;
          *((_DWORD *)v53 + 1) = v54;
        }
        for ( m = 1 << (v18 - 1); ; m >>= 1 )
        {
          v50 = v10 & m;
          v10 ^= m;
          if ( !v50 )
            break;
        }
        while ( (((1 << v30) - 1) & v10) != v66[v32] )
          v30 = v65[--v32];
      }
      ++v18;
    }
    result = j != 1;
    *a7 = v65[1];
    if ( !v59 )
      return 0;
  }
  return result;
}
// 3E378: variable 'v61' is possibly undefined

//----- (0003E4B0) --------------------------------------------------------
void __fastcall __noreturn sub_3E4B0(int a1)
{
  sub_3DFC8(*(_DWORD *)(a1 + 76));
  sub_3DFC8(*(_DWORD *)(a1 + 80));
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  longjmp((struct __jmp_buf_tag *)(a1 + 136), 1);
}

//----- (0003E4E0) --------------------------------------------------------
int __fastcall sub_3E4E0(int a1, int a2, unsigned int *a3, unsigned int a4)
{
  unsigned __int64 v9; // r2
  ssize_t v10; // r0
  int v11; // r3
  int v12; // r1
  unsigned int v13; // r2
  __int64 v14; // [sp+0h] [bp-8h]

  while ( *a3 < a4 )
  {
    if ( *(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 52) )
    {
      v9 = *(_QWORD *)(a1 + 40);
      if ( v9 > 0x3FFB )
        LODWORD(v9) = 16380;
      v10 = sub_1800C(*(_DWORD *)(a1 + 12), (void *)(*(_DWORD *)(a1 + 36) + 4), v9);
      *(_DWORD *)(a1 + 52) = v10;
      if ( v10 <= 0 )
      {
        *(_DWORD *)(a1 + 132) = "unexpected end of file";
        sub_3E4B0(a1);
      }
      v14 = *(_QWORD *)(a1 + 40);
      if ( v14 >= 0 )
        *(_QWORD *)(a1 + 40) = v14 - (unsigned int)v10;
      *(_DWORD *)(a1 + 48) = 4;
      *(_DWORD *)(a1 + 52) = v10 + 4;
    }
    v11 = *(_DWORD *)(a1 + 48);
    v12 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 36) + v11);
    v13 = *a3;
    *(_DWORD *)(a1 + 48) = v11 + 1;
    a2 |= v12 << v13;
    *a3 += 8;
  }
  return a2;
}

//----- (0003E5C0) --------------------------------------------------------
bool __fastcall sub_3E5C0(int a1, signed int a2)
{
  int v2; // r3
  signed int v3; // r4
  int v6; // r1
  ssize_t v7; // r0
  unsigned int v9; // r4

  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 52) - v2;
  if ( a2 <= v3 )
    return 1;
  memmove(*(void **)(a1 + 36), (const void *)(*(_DWORD *)(a1 + 36) + v2), v3);
  v6 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 48) = 0;
  v7 = sub_18050(*(_DWORD *)(a1 + 12), (char *)(v6 + v3), 0x4000 - v3);
  *(_DWORD *)(a1 + 52) = v7;
  if ( v7 >= 0 )
  {
    v9 = v3 + v7;
    *(_DWORD *)(a1 + 52) = v9;
    return v9 >= a2;
  }
  else
  {
    sub_16DDC("read error");
    return 0;
  }
}

//----- (0003E64C) --------------------------------------------------------
int __fastcall sub_3E64C(int a1, unsigned int *a2)
{
  int v3; // r1
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r3
  unsigned int v8; // r1
  int v9; // r0
  unsigned int v10; // r3
  unsigned int v11; // r0
  int v12; // r5
  unsigned int v13; // r0
  int v14; // r3
  unsigned int v15; // r2
  int v16; // r3
  int i; // r3
  int j; // r1
  __int64 v20; // r2
  int v21; // r1
  unsigned int v22; // r0
  unsigned int v23; // r9
  unsigned int v24; // r0
  unsigned int v25; // r0
  unsigned int v26; // r7
  int v27; // r5
  bool v28; // cc
  unsigned int v29; // r6
  unsigned int v30; // r0
  int v31; // r3
  int v32; // r10
  unsigned int v33; // r7
  unsigned int v34; // r11
  unsigned int v35; // r0
  unsigned int v36; // r6
  int v37; // r3
  int v38; // r1
  unsigned int v39; // r3
  char v40; // r3
  int v41; // r3
  unsigned int v42; // r0
  int v43; // r3
  int *k; // r6
  bool v45; // cf
  unsigned int v46; // r0
  int v47; // r1
  int v48; // r3
  int *m; // r6
  unsigned int v50; // r7
  unsigned int v51; // r0
  int v52; // r3
  int *n; // r6
  unsigned int v54; // [sp+14h] [bp-518h]
  int v55; // [sp+1Ch] [bp-510h]
  unsigned int v56; // [sp+24h] [bp-508h] BYREF
  int v57; // [sp+28h] [bp-504h] BYREF
  _BYTE v58[12]; // [sp+2Ch] [bp-500h] BYREF
  int v59[317]; // [sp+38h] [bp-4F4h] BYREF

  v3 = *(_DWORD *)(a1 + 28);
  v56 = *(unsigned __int8 *)(a1 + 32);
  v5 = sub_3E4E0(a1, v3, &v56, 1u);
  *a2 = v5 & 1;
  --v56;
  v6 = sub_3E4E0(a1, v5 >> 1, &v56, 2u);
  v7 = v56;
  v8 = v6 >> 2;
  v9 = v6 & 3;
  *(_DWORD *)(a1 + 28) = v8;
  v10 = v7 - 2;
  v56 = v10;
  *(_BYTE *)(a1 + 32) = v10;
  switch ( v9 )
  {
    case 1:
      for ( i = 0; i != 144; ++i )
        v59[i] = 8;
      do
        v59[i++] = 9;
      while ( i != 256 );
      do
        v59[i++] = 7;
      while ( i != 280 );
      *(_DWORD *)&v58[4] = 7;
      v59[280] = 8;
      v59[281] = 8;
      v59[282] = 8;
      v59[283] = 8;
      v59[284] = 8;
      v59[285] = 8;
      v59[286] = 8;
      v59[287] = 8;
      sub_3DFE8(v59, 0x120u, 0x101u, (int)&unk_64362, (int)&unk_693B0, (_DWORD *)(a1 + 76), (unsigned int *)&v58[4]);
      for ( j = 0; j != 30; ++j )
        v59[j] = 5;
      *(_DWORD *)&v58[8] = 5;
      sub_3DFE8(v59, 0x1Eu, 0, (int)&unk_64326, (int)&unk_69392, (_DWORD *)(a1 + 80), (unsigned int *)&v58[8]);
      v20 = *(_QWORD *)&v58[4];
      break;
    case 0:
      v57 = (unsigned __int8)v10 - (v10 & 7);
      v11 = sub_3E4E0(a1, v8 >> (v10 & 7), (unsigned int *)&v57, 0x10u);
      v12 = (unsigned __int16)v11;
      v57 -= 16;
      v13 = sub_3E4E0(a1, HIWORD(v11), (unsigned int *)&v57, 0x10u);
      v14 = (unsigned __int16)~(_WORD)v13;
      if ( v14 == v12 )
      {
        v15 = v57;
        *(_DWORD *)(a1 + 116) = v14;
        v16 = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 120) = HIWORD(v13);
        *(_DWORD *)(a1 + 124) = v15 - 16;
        *(_DWORD *)(a1 + 128) = v16;
        return -1;
      }
LABEL_5:
      sub_3E4B0(a1);
    case 2:
      *(_DWORD *)&v58[8] = (unsigned __int8)v10;
      v22 = sub_3E4E0(a1, v8, (unsigned int *)&v58[8], 5u);
      v23 = (v22 & 0x1F) + 257;
      *(_DWORD *)&v58[8] -= 5;
      v24 = sub_3E4E0(a1, v22 >> 5, (unsigned int *)&v58[8], 5u);
      v54 = (v24 & 0x1F) + 1;
      *(_DWORD *)&v58[8] -= 5;
      v25 = sub_3E4E0(a1, v24 >> 5, (unsigned int *)&v58[8], 4u);
      v26 = (v25 & 0xF) + 4;
      v27 = v25 >> 4;
      *(_DWORD *)&v58[8] -= 4;
      v28 = v54 > 0x1E;
      if ( v54 <= 0x1E )
        v28 = v23 > 0x11E;
      v29 = v28;
      if ( v28 )
        goto LABEL_5;
      do
      {
        v30 = sub_3E4E0(a1, v27, (unsigned int *)&v58[8], 3u);
        v31 = byte_6937F[v29++];
        v27 = v30 >> 3;
        v59[v31] = v30 & 7;
        *(_DWORD *)&v58[8] -= 3;
      }
      while ( v26 > v29 );
      while ( v26 != 19 )
      {
        v41 = byte_6937F[v26++];
        v59[v41] = 0;
      }
      *(_DWORD *)v58 = 7;
      v32 = sub_3DFE8(v59, 0x13u, 0x13u, 0, 0, (_DWORD *)(a1 + 76), (unsigned int *)v58);
      if ( v32 )
        goto LABEL_5;
      v33 = 0;
      v34 = v23 + v54;
      v55 = word_643A0[*(_DWORD *)v58];
      do
      {
        v35 = sub_3E4E0(a1, v27, (unsigned int *)&v58[8], *(unsigned int *)v58);
        v36 = v33;
        v37 = *(_DWORD *)(a1 + 76) + 8 * (v55 & v35);
        v38 = *(unsigned __int8 *)(v37 + 1);
        v39 = *(unsigned __int16 *)(v37 + 4);
        v27 = v35 >> v38;
        *(_DWORD *)&v58[8] -= v38;
        if ( v39 > 0xF )
        {
          if ( v39 == 16 )
          {
            v42 = sub_3E4E0(a1, v35 >> v38, (unsigned int *)&v58[8], 2u);
            v43 = (v42 & 3) + 3;
            v27 = v42 >> 2;
            *(_DWORD *)&v58[8] -= 2;
            if ( v43 + v33 > v34 )
              goto LABEL_5;
            for ( k = &v59[v36 - 1]; ; ++k )
            {
              v45 = v43-- != 0;
              if ( !v45 )
                break;
              k[1] = v32;
            }
            v33 += (v42 & 3) + 3;
          }
          else
          {
            if ( v39 == 17 )
            {
              v46 = sub_3E4E0(a1, v35 >> v38, (unsigned int *)&v58[8], 3u);
              v47 = v46 & 7;
              v48 = v47 + 3;
              v27 = v46 >> 3;
              *(_DWORD *)&v58[8] -= 3;
              if ( v47 + 3 + v33 > v34 )
                goto LABEL_5;
              for ( m = &v59[v36 - 1]; ; ++m )
              {
                v45 = v48-- != 0;
                if ( !v45 )
                  break;
                m[1] = 0;
              }
              v50 = v33 + 3;
            }
            else
            {
              v51 = sub_3E4E0(a1, v35 >> v38, (unsigned int *)&v58[8], 7u);
              v47 = v51 & 0x7F;
              v52 = v47 + 11;
              v27 = v51 >> 7;
              *(_DWORD *)&v58[8] -= 7;
              if ( v47 + 11 + v33 > v34 )
                goto LABEL_5;
              for ( n = &v59[v36 - 1]; ; ++n )
              {
                v45 = v52-- != 0;
                if ( !v45 )
                  break;
                n[1] = 0;
              }
              v50 = v33 + 11;
            }
            v33 = v47 + v50;
            v32 = 0;
          }
        }
        else
        {
          v32 = v39;
          ++v33;
          v59[v36] = v39;
        }
      }
      while ( v33 < v34 );
      sub_3DFC8(*(_DWORD *)(a1 + 76));
      v40 = v58[8];
      *(_DWORD *)(a1 + 28) = v27;
      *(_BYTE *)(a1 + 32) = v40;
      *(_DWORD *)v58 = 9;
      if ( sub_3DFE8(v59, v23, 0x101u, (int)&unk_64362, (int)&unk_693B0, (_DWORD *)(a1 + 76), (unsigned int *)v58) )
        goto LABEL_5;
      *(_DWORD *)&v58[4] = 6;
      if ( sub_3DFE8(&v59[v23], v54, 0, (int)&unk_64326, (int)&unk_69392, (_DWORD *)(a1 + 80), (unsigned int *)&v58[4]) )
        goto LABEL_5;
      v20 = *(_QWORD *)v58;
      break;
    default:
      goto LABEL_5;
  }
  v21 = *(_DWORD *)(a1 + 28);
  *(_QWORD *)(a1 + 84) = v20;
  *(_DWORD *)(a1 + 64) = v21;
  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a1 + 32);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a1 + 16);
  HIDWORD(v20) = word_643A0[HIDWORD(v20)];
  *(_DWORD *)(a1 + 56) = word_643A0[(_DWORD)v20];
  *(_DWORD *)(a1 + 60) = HIDWORD(v20);
  return -2;
}
// 643A0: using guessed type unsigned __int16 word_643A0[17];
// 6937F: using guessed type unsigned __int8 byte_6937F[19];

//----- (0003EC34) --------------------------------------------------------
int __fastcall sub_3EC34(int a1)
{
  int v2; // r0
  int v3; // r3
  int v4; // r0
  int v5; // r3
  unsigned int v6; // r5
  unsigned __int8 *v7; // r7
  int v8; // r2
  int v9; // r1
  int v10; // r0
  int v11; // r2
  int v12; // r3
  int v13; // r2
  int v14; // r1
  int v15; // r3
  int v16; // r3
  __int16 v17; // r1
  int v18; // r2
  unsigned int v20; // r0
  int v21; // r2
  int v22; // r3
  unsigned int v23; // r3
  int v24; // r0
  int v25; // r3
  int v26; // r0
  int v27; // r3
  unsigned int v28; // r5
  unsigned __int8 *v29; // r7
  int v30; // r2
  int v31; // r1
  int v32; // r0
  int v33; // r2
  int v34; // r3
  int v35; // r2
  int v36; // r1
  unsigned int v37; // r0
  int v38; // r3
  unsigned int v39; // r0
  size_t v40; // r3
  unsigned int v41; // r1
  unsigned int v42; // r5
  size_t v43; // r5
  size_t v44; // r2
  int v45; // r3
  void *v46; // r0
  const void *v47; // r1
  int v48; // r3
  int v49; // r1
  int v50; // r2
  int v51; // r3
  int v52; // r2

  if ( *(_DWORD *)(a1 + 100) )
    goto LABEL_17;
LABEL_2:
  while ( 2 )
  {
    v2 = sub_3E4E0(a1, *(_DWORD *)(a1 + 64), (unsigned int *)(a1 + 68), *(_DWORD *)(a1 + 84));
    v3 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 64) = v2;
    v4 = v2 & v3;
    v5 = *(_DWORD *)(a1 + 76);
    v6 = *(unsigned __int8 *)(v5 + 8 * v4);
    v7 = (unsigned __int8 *)(v5 + 8 * v4);
    while ( v6 > 0x10 )
    {
      if ( v6 == 99 )
LABEL_5:
        sub_3E4B0(a1);
      v8 = v7[1];
      v9 = *(_DWORD *)(a1 + 64) >> v8;
      *(_DWORD *)(a1 + 68) -= v8;
      *(_DWORD *)(a1 + 64) = v9;
      v10 = sub_3E4E0(a1, v9, (unsigned int *)(a1 + 68), v6 - 16);
      v11 = *((_DWORD *)v7 + 1);
      v12 = word_643A0[v6 - 16];
      *(_DWORD *)(a1 + 64) = v10;
      v7 = (unsigned __int8 *)(v11 + 8 * (v10 & v12));
      v6 = *v7;
    }
    v13 = v7[1];
    v14 = *(_DWORD *)(a1 + 64) >> v13;
    v15 = *(_DWORD *)(a1 + 68) - v13;
    *(_DWORD *)(a1 + 68) = v15;
    *(_DWORD *)(a1 + 64) = v14;
    if ( v6 == 16 )
    {
      v16 = *(_DWORD *)(a1 + 72);
      v17 = *((_WORD *)v7 + 2);
      v18 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 72) = v16 + 1;
      *(_BYTE *)(v18 + v16) = v17;
      if ( *(_DWORD *)(a1 + 72) != 0x8000 )
        continue;
      *(_DWORD *)(a1 + 16) = 0x8000;
LABEL_10:
      *(_DWORD *)(a1 + 72) = 0;
      return 1;
    }
    break;
  }
  if ( v6 != 15 )
  {
    v20 = sub_3E4E0(a1, v14, (unsigned int *)(a1 + 68), v6);
    v21 = *((unsigned __int16 *)v7 + 2);
    v22 = word_643A0[v6];
    *(_DWORD *)(a1 + 64) = v20 >> v6;
    *(_DWORD *)(a1 + 92) = (v22 & v20) + v21;
    v23 = *(_DWORD *)(a1 + 88);
    *(_DWORD *)(a1 + 68) -= v6;
    v24 = sub_3E4E0(a1, v20 >> v6, (unsigned int *)(a1 + 68), v23);
    v25 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a1 + 64) = v24;
    v26 = v24 & v25;
    v27 = *(_DWORD *)(a1 + 80);
    v28 = *(unsigned __int8 *)(v27 + 8 * v26);
    v29 = (unsigned __int8 *)(v27 + 8 * v26);
    while ( v28 > 0x10 )
    {
      if ( v28 == 99 )
        goto LABEL_5;
      v30 = v29[1];
      v31 = *(_DWORD *)(a1 + 64) >> v30;
      *(_DWORD *)(a1 + 68) -= v30;
      *(_DWORD *)(a1 + 64) = v31;
      v32 = sub_3E4E0(a1, v31, (unsigned int *)(a1 + 68), v28 - 16);
      v33 = *((_DWORD *)v29 + 1);
      v34 = word_643A0[v28 - 16];
      *(_DWORD *)(a1 + 64) = v32;
      v29 = (unsigned __int8 *)(v33 + 8 * (v32 & v34));
      v28 = *v29;
    }
    v35 = v29[1];
    v36 = *(_DWORD *)(a1 + 64) >> v35;
    *(_DWORD *)(a1 + 68) -= v35;
    *(_DWORD *)(a1 + 64) = v36;
    v37 = sub_3E4E0(a1, v36, (unsigned int *)(a1 + 68), v28);
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 72) - *((unsigned __int16 *)v29 + 2) - (word_643A0[v28] & v37);
    v38 = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(a1 + 64) = v37 >> v28;
    *(_DWORD *)(a1 + 68) = v38 - v28;
    while ( 1 )
    {
LABEL_17:
      v39 = *(_DWORD *)(a1 + 72);
      v40 = *(_DWORD *)(a1 + 92);
      v41 = *(_DWORD *)(a1 + 96) & 0x7FFF;
      *(_DWORD *)(a1 + 96) = v41;
      if ( v41 < v39 )
        v42 = v39;
      else
        v42 = v41;
      v43 = 0x8000 - v42;
      if ( v41 >= v39 )
        v44 = v41 - v39;
      else
        v44 = v39 - v41;
      if ( v40 < v43 )
        v43 = v40;
      *(_DWORD *)(a1 + 92) = v40 - v43;
      v45 = *(_DWORD *)(a1 + 20);
      v46 = (void *)(v45 + v39);
      v47 = (const void *)(v45 + v41);
      if ( v44 < v43 )
      {
        do
        {
          v49 = *(_DWORD *)(a1 + 96);
          --v43;
          v50 = *(_DWORD *)(a1 + 20);
          *(_DWORD *)(a1 + 96) = v49 + 1;
          v51 = *(_DWORD *)(a1 + 72);
          *(_DWORD *)(a1 + 72) = v51 + 1;
          *(_BYTE *)(v50 + v51) = *(_BYTE *)(v50 + v49);
        }
        while ( v43 );
      }
      else
      {
        memcpy(v46, v47, v43);
        *(_DWORD *)(a1 + 72) += v43;
        *(_DWORD *)(a1 + 96) += v43;
      }
      v48 = *(_DWORD *)(a1 + 92);
      if ( *(_DWORD *)(a1 + 72) == 0x8000 )
        break;
      if ( !v48 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        goto LABEL_2;
      }
    }
    *(_DWORD *)(a1 + 16) = 0x8000;
    *(_DWORD *)(a1 + 100) = v48 != 0;
    goto LABEL_10;
  }
  v52 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 28) = v14;
  *(_BYTE *)(a1 + 32) = v15;
  *(_DWORD *)(a1 + 16) = v52;
  sub_3DFC8(*(_DWORD *)(a1 + 76));
  sub_3DFC8(*(_DWORD *)(a1 + 80));
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  return 0;
}
// 643A0: using guessed type unsigned __int16 word_643A0[17];

//----- (0003EF78) --------------------------------------------------------
int __fastcall sub_3EF78(int a1, int *a2)
{
  int v2; // r2
  int v3; // r4
  unsigned int v5; // r0
  unsigned int v6; // r1
  int v7; // r1
  int v8; // r3
  int v9; // r3
  int v10; // r3
  int v11; // r1
  int v12; // r3
  int v13; // r0
  int v14; // r2
  int v15; // r3
  unsigned int v16; // r0
  unsigned int v17; // r1

  *(_DWORD *)(a1 + 20) = sub_1748C(0x8000u);
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  v2 = a2[2];
  *(_DWORD *)(a1 + 100) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 12) = v2;
  *(_DWORD *)(a1 + 108) = 1;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 104) = -1;
  *(_DWORD *)(a1 + 24) = sub_58678();
  *(_DWORD *)(a1 + 8) = -1;
  *(_DWORD *)(a1 + 132) = "corrupted data";
  if ( setjmp((struct __jmp_buf_tag *)(a1 + 136)) )
  {
    sub_16DDC(*(const char **)(a1 + 132));
  }
  else
  {
    while ( 1 )
    {
      *(_DWORD *)(a1 + 16) = 0;
      while ( 1 )
      {
        if ( *(_DWORD *)(a1 + 108) )
        {
          if ( *(_DWORD *)(a1 + 112) )
          {
            v3 = 0;
            v5 = sub_586A4(*(_DWORD *)(a1 + 8), *(char **)(a1 + 20), *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 24));
            v6 = *(_DWORD *)(a1 + 16);
            *(_DWORD *)(a1 + 8) = v5;
            *(_QWORD *)a1 += v6;
            *(_DWORD *)(a1 + 112) = 0;
            goto LABEL_9;
          }
          *(_DWORD *)(a1 + 104) = sub_3E64C(a1, (unsigned int *)(a1 + 112));
          *(_DWORD *)(a1 + 108) = 0;
        }
        v9 = *(_DWORD *)(a1 + 104);
        if ( v9 != -2 )
          break;
        if ( sub_3EC34(a1) == 1 )
          goto LABEL_21;
LABEL_18:
        *(_DWORD *)(a1 + 108) = 1;
      }
      if ( v9 != -1 )
        sub_3E4B0(a1);
      while ( 1 )
      {
        v10 = *(_DWORD *)(a1 + 116);
        *(_DWORD *)(a1 + 116) = v10 - 1;
        v11 = *(_DWORD *)(a1 + 120);
        if ( !v10 )
        {
          v12 = *(_DWORD *)(a1 + 128);
          *(_DWORD *)(a1 + 28) = v11;
          *(_DWORD *)(a1 + 16) = v12;
          *(_BYTE *)(a1 + 32) = *(_DWORD *)(a1 + 124);
          goto LABEL_18;
        }
        v13 = sub_3E4E0(a1, v11, (unsigned int *)(a1 + 124), 8u);
        *(_DWORD *)(a1 + 120) = v13;
        v14 = *(_DWORD *)(a1 + 20);
        v15 = *(_DWORD *)(a1 + 128);
        *(_DWORD *)(a1 + 128) = v15 + 1;
        *(_BYTE *)(v14 + v15) = v13;
        if ( *(_DWORD *)(a1 + 128) == 0x8000 )
          break;
        *(_DWORD *)(a1 + 120) >>= 8;
        *(_DWORD *)(a1 + 124) -= 8;
      }
      *(_DWORD *)(a1 + 16) = 0x8000;
      *(_DWORD *)(a1 + 128) = 0;
      *(_DWORD *)(a1 + 120) >>= 8;
      *(_DWORD *)(a1 + 124) -= 8;
LABEL_21:
      v3 = 1;
      v16 = sub_586A4(*(_DWORD *)(a1 + 8), *(char **)(a1 + 20), *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 24));
      v17 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 8) = v16;
      *(_QWORD *)a1 += v17;
LABEL_9:
      if ( sub_3FE5C(a2, *(void **)(a1 + 20), *(_DWORD *)(a1 + 16)) == -1 )
        break;
      if ( !v3 )
      {
        if ( *(unsigned __int8 *)(a1 + 32) > 7u )
        {
          v7 = *(_DWORD *)(a1 + 28);
          v8 = *(_DWORD *)(a1 + 48) - 1;
          *(_DWORD *)(a1 + 48) = v8;
          *(_BYTE *)(*(_DWORD *)(a1 + 36) + v8) = v7;
          *(_DWORD *)(a1 + 28) >>= 8;
          *(_BYTE *)(a1 + 32) -= 8;
        }
        goto LABEL_4;
      }
    }
  }
  v3 = -1;
LABEL_4:
  free(*(void **)(a1 + 20));
  free(*(void **)(a1 + 24));
  return v3;
}

//----- (0003F2A0) --------------------------------------------------------
int __fastcall sub_3F2A0(int *a1)
{
  int v2; // r5
  void *v3; // r4
  void *v4; // r0
  int v5; // r3
  int v6; // r1
  char *v7; // r0
  size_t v8; // r2
  int v9; // r3
  unsigned __int8 *v10; // r2
  int v11; // r1
  unsigned __int8 v12; // r6
  int v13; // r10
  int v14; // r3
  signed int v15; // r11
  int v16; // r3
  int v17; // r2
  int v18; // r0
  int v19; // r3
  int v20; // r0
  int v21; // r12
  int v22; // r2
  int v24; // r2
  int v25; // r2
  int v26; // r3

  v2 = sub_3FDFC(a1, 35615);
  if ( v2 )
    return -1;
  v3 = sub_174DC(0x210u);
  *((_QWORD *)v3 + 5) = -1;
  v4 = sub_1748C(0x4000u);
  v5 = a1[2];
  *((_DWORD *)v3 + 9) = v4;
  *((_DWORD *)v3 + 3) = v5;
  while ( 1 )
  {
    v6 = *((_DWORD *)v3 + 12);
    v7 = (char *)*((_DWORD *)v3 + 9);
    v8 = *((_DWORD *)v3 + 13) - v6;
    *((_DWORD *)v3 + 13) = v8;
    memmove(v7, &v7[v6], v8);
    *((_DWORD *)v3 + 12) = 0;
    if ( !sub_3E5C0((int)v3, 8) )
      break;
    v9 = *((_DWORD *)v3 + 12);
    v10 = (unsigned __int8 *)(*((_DWORD *)v3 + 9) + v9);
    v11 = *v10;
    v12 = v10[1];
    v13 = *(_DWORD *)(v10 + 2);
    *((_DWORD *)v3 + 12) = v9 + 8;
    if ( v11 != 8 )
      break;
    if ( (v12 & 4) != 0 )
    {
      if ( !sub_3E5C0((int)v3, 2) )
        break;
      v14 = *((_DWORD *)v3 + 12);
      v15 = *(unsigned __int16 *)(*((_DWORD *)v3 + 9) + v14);
      *((_DWORD *)v3 + 12) = v14 + 2;
      if ( !sub_3E5C0((int)v3, v15) )
        break;
      *((_DWORD *)v3 + 12) += v15;
    }
    if ( (v12 & 0x18) != 0 )
    {
      while ( sub_3E5C0((int)v3, 1) )
      {
        v16 = *((_DWORD *)v3 + 12);
        v17 = *((_DWORD *)v3 + 9);
        *((_DWORD *)v3 + 12) = v16 + 1;
        if ( !*(_BYTE *)(v17 + v16) )
        {
          if ( (v12 & 0x18) != 0x18 )
            goto LABEL_15;
          v12 &= 0xE7u;
        }
      }
      break;
    }
LABEL_15:
    a1[13] = v13;
    if ( (v12 & 2) != 0 )
    {
      if ( !sub_3E5C0((int)v3, 2) )
        break;
      *((_DWORD *)v3 + 12) += 2;
    }
    v18 = sub_3EF78((int)v3, a1);
    if ( v18 < 0 )
      goto LABEL_23;
    v2 += v18;
    if ( !sub_3E5C0((int)v3, 8) )
      break;
    v19 = *((_DWORD *)v3 + 12);
    v20 = *((_DWORD *)v3 + 9);
    v21 = *(_DWORD *)(v20 + v19);
    v22 = ~*((_DWORD *)v3 + 2);
    *((_DWORD *)v3 + 12) = v19 + 4;
    if ( v22 != v21 )
    {
      sub_16DDC("crc error");
      goto LABEL_23;
    }
    v24 = *(_DWORD *)(v20 + v19 + 4);
    *((_DWORD *)v3 + 12) = v19 + 8;
    if ( *(_DWORD *)v3 != v24 )
    {
      v2 = -1;
      sub_16DDC("incorrect length");
    }
    if ( !sub_3E5C0((int)v3, 2) )
      goto LABEL_24;
    v25 = *((_DWORD *)v3 + 9);
    v26 = *((_DWORD *)v3 + 12);
    if ( *(_BYTE *)(v25 + v26) != 31 || *(unsigned __int8 *)(v25 + v26 + 1) != 139 )
      goto LABEL_24;
    *((_DWORD *)v3 + 12) = v26 + 2;
  }
  sub_16DDC("corrupted data");
LABEL_23:
  v2 = -1;
LABEL_24:
  free(*((void **)v3 + 9));
  free(v3);
  return v2;
}

//----- (0003F500) --------------------------------------------------------
int **__fastcall sub_3F500(int a1)
{
  int *v1; // r3
  int v3; // r5
  int **result; // r0

  v1 = *(int **)(a1 + 24);
  v3 = *v1;
  if ( sub_3F588(*(int ***)(a1 + 16), *v1) )
    return (int **)1;
  result = *(int ***)(a1 + 12);
  if ( result )
    return (int **)(sub_3F588(result, v3) == 0);
  return result;
}

//----- (0003F54C) --------------------------------------------------------
int __fastcall sub_3F54C(int a1, char *name)
{
  while ( a1 && fnmatch(*(const char **)(a1 + 4), name, 0) )
    a1 = *(_DWORD *)a1;
  return a1;
}

//----- (0003F588) --------------------------------------------------------
int **__fastcall sub_3F588(int **a1, int a2)
{
  int v4; // r5
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // t1
  char *v10; // r3
  int v11; // r0
  int v12; // r12
  int v13; // t1
  char v15[4080]; // [sp+0h] [bp-1004h] BYREF
  char v16; // [sp+FFFh] [bp-5h] BYREF

  v4 = a2 + 4095;
  while ( a1 )
  {
    v6 = 0;
    v7 = (int)a1[1] - 1;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)++v7;
      v8 = v9;
      if ( !v9 )
        break;
      if ( v8 == 47 )
        ++v6;
    }
    v10 = v15;
    v11 = a2 - 1;
    while ( 1 )
    {
      v13 = *(unsigned __int8 *)++v11;
      v12 = v13;
      if ( !v13 )
        break;
      if ( v11 == v4 )
      {
        v10 = &v16;
        break;
      }
      if ( v12 == 47 && v6-- == 0 )
        break;
      *v10++ = v12;
    }
    *v10 = 0;
    if ( !fnmatch((const char *)a1[1], v15, 0) )
      break;
    a1 = (int **)*a1;
  }
  return a1;
}

//----- (0003F644) --------------------------------------------------------
unsigned __int64 __fastcall sub_3F644(const char *a1, char *a2, char *a3)
{
  unsigned __int64 result; // r0
  int v6; // r0
  unsigned __int8 *v7; // r2
  unsigned __int8 *v8; // r4
  unsigned int v9; // t1
  char *endptr[2]; // [sp+4h] [bp-8h] BYREF

  endptr[0] = a2;
  endptr[1] = a3;
  a2[(_DWORD)a1] = 0;
  result = strtoull(a1, endptr, 8);
  if ( (*endptr[0] & 0xDF) != 0 )
  {
    v6 = *a1;
    if ( v6 >= 0 )
      sub_16DBC("corrupted octal value in tar header", HIDWORD(result));
    v7 = (unsigned __int8 *)(a1 + 1);
    v8 = (unsigned __int8 *)&a2[(_DWORD)a1];
    result = v6 << 25 >> 25;
    while ( v7 != v8 )
    {
      v9 = *v7++;
      result = v9 + (result << 8);
    }
  }
  return result;
}

//----- (0003F6D0) --------------------------------------------------------
int __fastcall sub_3F6D0(int a1)
{
  int v2; // r4
  ssize_t v3; // r0
  int v4; // r1
  int result; // r0
  __int64 v6; // r0
  unsigned int v7; // r2
  unsigned int v8; // kr00_4
  int v9; // r3
  int v10; // r6
  int v11; // r3
  int v12; // r8
  int v13; // r2
  int i; // r3
  char *v15; // r2
  int v16; // r7
  unsigned __int64 v17; // r0
  char *v18; // r2
  bool v19; // zf
  char v20; // r6
  unsigned int v21; // r8
  char *v22; // r2
  unsigned int v23; // r0
  void *v24; // r0
  void *v25; // r0
  char *v26; // r2
  char *v27; // r2
  char *v28; // r2
  char *v29; // r2
  char *v30; // r0
  int v31; // r3
  unsigned __int64 v32; // r2
  int v33; // r6
  unsigned __int8 *v34; // r0
  const char *v35; // r6
  char *v36; // r0
  unsigned int v37; // r1
  unsigned int v38; // r0
  unsigned int v39; // r2
  unsigned int v40; // kr04_4
  unsigned __int64 v41; // kr20_8
  void *v42; // r0
  unsigned int v43; // r3
  int v44; // r2
  __int64 v45; // r8
  char v46[100]; // [sp+8h] [bp-204h] BYREF
  char v47[8]; // [sp+6Ch] [bp-1A0h] BYREF
  char v48[8]; // [sp+74h] [bp-198h] BYREF
  char v49[8]; // [sp+7Ch] [bp-190h] BYREF
  char v50[12]; // [sp+84h] [bp-188h] BYREF
  char v51[12]; // [sp+90h] [bp-17Ch] BYREF
  char v52[9]; // [sp+9Ch] [bp-170h] BYREF
  char v53[99]; // [sp+A5h] [bp-167h] BYREF
  unsigned __int8 v54[7]; // [sp+109h] [bp-103h] BYREF
  char v55[31]; // [sp+111h] [bp-FBh] BYREF
  char v56[31]; // [sp+131h] [bp-DBh] BYREF
  char v57[7]; // [sp+151h] [bp-BBh] BYREF
  char v58[7]; // [sp+159h] [bp-B3h] BYREF
  char v59[167]; // [sp+161h] [bp-ABh] BYREF

  v2 = *(_DWORD *)(a1 + 24);
  sub_402D8(a1, 0x200u);
  while ( 1 )
  {
    while ( 1 )
    {
      *(_DWORD *)v46 = 0;
      v3 = sub_18050(*(_DWORD *)(a1 + 4), v46, 0x200u);
      if ( !v3 )
      {
        if ( !*(_QWORD *)(a1 + 48) )
          sub_16DDC("short read");
        return 1;
      }
      if ( v3 == 512 )
      {
        v7 = *(_DWORD *)(a1 + 52);
        v8 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)(a1 + 48) = v8 + 512;
        v9 = (unsigned __int8)v46[0];
        *(_DWORD *)(a1 + 52) = (__PAIR64__(v7, v8) + 512) >> 32;
        if ( !v9 )
        {
          result = (unsigned __int8)v59[0];
          if ( !v59[0] )
          {
            if ( !*(_DWORD *)(a1 + 60) )
            {
              *(_DWORD *)(a1 + 60) = 1;
              return result;
            }
            while ( sub_18050(*(_DWORD *)(a1 + 4), v46, 0x200u) == 512 )
              ;
            return 1;
          }
        }
        *(_DWORD *)(a1 + 60) = 0;
        if ( sub_1684C(v54, (int)"ustar") )
          break;
      }
      v6 = lseek64(*(_DWORD *)(a1 + 4), v4);
      if ( v6 || sub_3FFC0(*(_DWORD *)(a1 + 4), 0) )
        sub_16DBC("invalid tar magic", HIDWORD(v6));
      *(_QWORD *)(a1 + 48) = 0;
    }
    v10 = 256;
    v11 = 0;
    v12 = 256;
    do
    {
      v13 = (unsigned __int8)v46[v11++];
      v12 += v13;
      v10 += (char)v13;
    }
    while ( v11 != 148 );
    for ( i = 156; i != 512; ++i )
    {
      v15 = (char *)(unsigned __int8)v46[i];
      v12 += (int)v15;
      v10 += (char)v15;
    }
    v16 = (unsigned __int8)v52[8];
    v17 = sub_3F644(v52, (char *)8, v15);
    v19 = (_DWORD)v17 == v12;
    if ( (_DWORD)v17 != v12 )
      v19 = (_DWORD)v17 == v10;
    if ( !v19 )
      sub_16DBC("invalid tar header checksum", HIDWORD(v17));
    if ( v57[0] )
    {
      v20 = v59[0];
      v21 = sub_3F644(v58, (char *)8, v18);
      v23 = sub_3F644(v57, (char *)8, v22);
      *(_QWORD *)(v2 + 40) = j_gnu_dev_makedev(v23, v21);
      v59[0] = v20;
    }
    if ( !v16 )
      v16 = 48;
    *(_DWORD *)(v2 + 4) = 0;
    if ( (unsigned int)(v16 - 48) <= 7 && v53[0] )
      *(_DWORD *)(v2 + 4) = sub_1751C(v53, 100);
    v24 = (void *)(unsigned __int8)v55[0];
    if ( v55[0] )
      v24 = sub_1751C(v55, 32);
    *(_DWORD *)(v2 + 8) = v24;
    v25 = (void *)(unsigned __int8)v56[0];
    if ( v56[0] )
      v25 = sub_1751C(v56, 32);
    *(_DWORD *)(v2 + 12) = v25;
    *(_DWORD *)(v2 + 36) = sub_3F644(v51, (char *)0xC, v18);
    *(_QWORD *)(v2 + 16) = sub_3F644(v50, (char *)0xC, v26);
    *(_DWORD *)(v2 + 28) = sub_3F644(v49, (char *)8, v27);
    *(_DWORD *)(v2 + 24) = sub_3F644(v48, (char *)8, v28);
    *(_DWORD *)(v2 + 32) = sub_3F644(v47, (char *)8, v29) & 0xFFF;
    *(_DWORD *)v2 = 0;
    if ( (unsigned int)(v16 - 48) <= 7 )
    {
      v47[0] = 0;
      if ( v59[0] )
      {
        v59[155] = 0;
        v30 = sub_16998(v59, v46);
      }
      else
      {
        v30 = sub_174F8(v46);
      }
      *(_DWORD *)v2 = v30;
    }
    if ( v16 == 52 )
    {
      v31 = *(_DWORD *)(v2 + 32) | 0x6000;
      goto LABEL_60;
    }
    if ( v16 <= 52 )
      break;
    if ( v16 == 55 )
      goto LABEL_61;
    if ( v16 <= 55 )
    {
      if ( v16 == 53 )
        v31 = *(_DWORD *)(v2 + 32) | 0x4000;
      else
        v31 = *(_DWORD *)(v2 + 32) | 0x1000;
      goto LABEL_60;
    }
    if ( v16 != 103 && v16 != 120 )
      goto LABEL_47;
    v32 = *(_QWORD *)(v2 + 16);
    if ( v32 > 0xFFFFF )
    {
      sub_16DDC("warning: skipping header '%c'", v16);
      v43 = (*(_DWORD *)(v2 + 16) + 511) & 0xFFFFFE00;
      v44 = (unsigned __int64)(*(_QWORD *)(v2 + 16) + 511LL) >> 32;
      HIDWORD(v45) = v44 >> 9;
      LODWORD(v45) = (v43 >> 9) | (v44 << 23);
      *(_QWORD *)(a1 + 48) += __PAIR64__(v44, v43);
      while ( --v45 != -1 )
        sub_60448(*(_DWORD *)(a1 + 4), v46, 0x200u);
    }
    else
    {
      sub_400F8(*(_DWORD *)(a1 + 4), ((_DWORD)v32 + 511) & 0xFFFFFE00);
    }
  }
  if ( v16 == 49 )
  {
    v31 = *(_DWORD *)(v2 + 32) | 0x8000;
    goto LABEL_60;
  }
  if ( v16 > 49 )
  {
    if ( v16 == 50 )
      v31 = *(_DWORD *)(v2 + 32) | 0xA000;
    else
      v31 = *(_DWORD *)(v2 + 32) | 0x2000;
LABEL_60:
    *(_DWORD *)(v2 + 32) = v31;
    *(_QWORD *)(v2 + 16) = 0;
    goto LABEL_62;
  }
  if ( v16 != 48 )
LABEL_47:
    sub_16DBC("unknown typeflag: 0x%x", v16);
LABEL_61:
  *(_DWORD *)(v2 + 32) |= 0x8000u;
LABEL_62:
  v33 = *(_DWORD *)v2;
  v34 = sub_40108(*(const char **)v2);
  sub_60B4C(v33, (int)v34);
  v35 = sub_16AA8(*(const char **)v2, 47);
  if ( (*(int (__fastcall **)(int))(a1 + 8))(a1) )
  {
    sub_3D434(a1);
    v36 = *(char **)v2;
  }
  else
  {
    (*(void (__fastcall **)(int))(a1 + 32))(v2);
    if ( v35 )
      *v35 = 0;
    (*(void (__fastcall **)(int))(a1 + 36))(a1);
    if ( *(_DWORD *)(a1 + 12) || (v36 = *(char **)v2, *(_DWORD *)(a1 + 16)) || (*(_DWORD *)a1 & 0x100) != 0 )
    {
      sub_5D2A0((int *)(a1 + 20), *(_DWORD *)v2);
      goto LABEL_69;
    }
  }
  free(v36);
LABEL_69:
  v37 = *(_DWORD *)(v2 + 16);
  v38 = *(_DWORD *)(v2 + 20);
  v39 = *(_DWORD *)(a1 + 52);
  v40 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = v40 + v37;
  v41 = __PAIR64__(v39, v40) + __PAIR64__(v38, v37);
  v42 = *(void **)(v2 + 4);
  *(_DWORD *)(a1 + 52) = HIDWORD(v41);
  free(v42);
  free(*(void **)(v2 + 8));
  free(*(void **)(v2 + 12));
  return 0;
}
// 3F9F8: conditional instruction was optimized away because r7.4==33
// 3FA20: conditional instruction was optimized away because r7.4==36
// 3F750: variable 'v4' is possibly undefined
// 3F868: variable 'v6' is possibly undefined
// 3F888: variable 'v18' is possibly undefined
// 3F89C: variable 'v22' is possibly undefined
// 3F940: variable 'v26' is possibly undefined
// 3F950: variable 'v27' is possibly undefined
// 3F960: variable 'v28' is possibly undefined
// 3F970: variable 'v29' is possibly undefined
// 13928: using guessed type __int64 __fastcall lseek64(_DWORD, _DWORD);

//----- (0003FC40) --------------------------------------------------------
int __fastcall sub_3FC40(const char **a1)
{
  return puts(*a1);
}

//----- (0003FC48) --------------------------------------------------------
int __fastcall sub_3FC48(int a1)
{
  char *v2; // r5
  const char *v3; // r6
  char *v4; // r0
  const char *v5; // r1
  char s[16]; // [sp+2Ch] [bp-3Ch] BYREF
  struct tm tp; // [sp+3Ch] [bp-2Ch] BYREF

  localtime_r((const time_t *)(a1 + 36), &tp);
  v2 = *(char **)(a1 + 8);
  if ( !v2 )
  {
    v2 = s;
    sprintf(s, "%u", *(_DWORD *)(a1 + 24));
  }
  v3 = *(const char **)(a1 + 12);
  if ( !v3 )
    v3 = sub_16F64(*(_DWORD *)(a1 + 28));
  v4 = sub_5DA78(*(_DWORD *)(a1 + 32));
  printf(
    "%s %s/%s %9llu %4u-%02u-%02u %02u:%02u:%02u %s",
    v4,
    v2,
    v3,
    *(_QWORD *)(a1 + 16),
    tp.tm_year + 1900,
    tp.tm_mon + 1,
    tp.tm_mday,
    tp.tm_hour,
    tp.tm_min,
    tp.tm_sec,
    *(const char **)a1);
  v5 = *(const char **)(a1 + 4);
  if ( v5 )
    printf(" -> %s", v5);
  return j_putchar_unlocked(10);
}

//----- (0003FD30) --------------------------------------------------------
_DWORD *sub_3FD30()
{
  _DWORD *v0; // r4

  v0 = sub_174DC(0x40u);
  v0[6] = sub_174DC(0x30u);
  v0[8] = nullsub_2;
  v0[9] = sub_3D434;
  v0[2] = sub_4033C;
  v0[10] = sub_4007C;
  return v0;
}
// 40350: using guessed type int nullsub_2();

//----- (0003FD84) --------------------------------------------------------
_DWORD *__fastcall sub_3FD84(ssize_t a1, int a2)
{
  _DWORD *v4; // r4
  int v6; // [sp+4h] [bp-4h] BYREF

  v6 = a2;
  v4 = sub_174DC(0x38u);
  *v4 = 2;
  v4[2] = a1;
  sub_60448(a1, (char *)&v6, 2u);
  if ( (unsigned __int16)v6 == 35615 )
  {
    v4[1] = sub_3F2A0;
  }
  else if ( a2 )
  {
    sub_16DBC("no gzip magic");
  }
  return v4;
}

//----- (0003FDF0) --------------------------------------------------------
void *__fastcall sub_3FDF0(void *a1)
{
  return memset(a1, 0, 0x38u);
}

//----- (0003FDFC) --------------------------------------------------------
int __fastcall sub_3FDFC(_DWORD *a1, int a2)
{
  unsigned __int16 buf; // [sp+6h] [bp-2h] BYREF

  buf = HIWORD(a2);
  if ( *a1 )
    return 0;
  if ( sub_18050(a1[2], (char *)&buf, 2u) == 2 && buf == a2 )
  {
    *a1 = 2;
    return 0;
  }
  sub_16DDC("invalid magic");
  return -1;
}

//----- (0003FE5C) --------------------------------------------------------
ssize_t __fastcall sub_3FE5C(int *a1, void *a2, size_t a3)
{
  unsigned int v3; // r3
  int v6; // r7
  size_t v7; // r6
  void *v8; // r0
  int v9; // r1
  ssize_t result; // r0
  char *v12; // r0

  v3 = a1[4];
  if ( v3 )
  {
    v6 = a1[5];
    v7 = a3 + v6;
    a1[5] = a3 + v6;
    v8 = (void *)a1[6];
    if ( v3 < a3 + v6 )
    {
      free(v8);
      v9 = a1[4];
      a1[6] = 0;
      sub_16AF4("buffer %u too small", v9);
      return -1;
    }
    v12 = (char *)sub_174B4(v8, v7 + 1);
    a1[6] = (int)v12;
    memcpy(&v12[v6], a2, a3);
    *(_BYTE *)(a1[6] + v7) = 0;
    return a3;
  }
  else
  {
    result = sub_17FB8(a1[3], (char *)a2, a3);
    if ( a3 != result )
    {
      sub_16AF4("write");
      return -1;
    }
  }
  return result;
}

//----- (0003FF04) --------------------------------------------------------
__pid_t __fastcall sub_3FF04(int a1, int a2, int a3)
{
  __pid_t result; // r0
  int stat_loc[2]; // [sp+4h] [bp-8h] BYREF

  stat_loc[0] = a2;
  stat_loc[1] = a3;
  if ( a1 )
    goto LABEL_6;
  for ( result = wait(stat_loc); result >= 0; result = sub_173DC(stat_loc) )
  {
    if ( stat_loc[0] )
      dword_7DBA0 = 1;
LABEL_6:
    ;
  }
  return result;
}
// 7DBA0: using guessed type int dword_7DBA0;

//----- (0003FF4C) --------------------------------------------------------
int __fastcall sub_3FF4C(int a1, int a2, int (__fastcall *a3)(_DWORD *))
{
  unsigned int v6; // r0
  int fd; // [sp+0h] [bp-40h] BYREF
  int v9; // [sp+4h] [bp-3Ch]
  _DWORD v10[14]; // [sp+8h] [bp-38h] BYREF

  sub_1766C(&fd);
  if ( !sub_17B64() )
  {
    close(fd);
    sub_3FDF0(v10);
    v10[0] = a2;
    v10[2] = a1;
    v10[3] = v9;
    v6 = a3(v10);
    exit(v6 >> 31);
  }
  close(v9);
  return sub_176A8(fd, a1);
}

//----- (0003FFC0) --------------------------------------------------------
int __fastcall sub_3FFC0(ssize_t a1, int a2)
{
  _DWORD *v2; // r0
  int (__fastcall *v3)(_DWORD *); // r2
  void *v5; // r4

  v2 = sub_3FD84(a1, a2);
  v3 = (int (__fastcall *)(_DWORD *))v2[1];
  if ( v3 )
  {
    v5 = v2;
    sub_3FF4C(v2[2], 1, v3);
    free(v5);
    return 0;
  }
  else
  {
    free(v2);
    return 1;
  }
}

//----- (00040000) --------------------------------------------------------
int __fastcall sub_40000(int a1, int a2)
{
  ssize_t v3; // r0
  int v4; // r4
  _DWORD *v6; // r0
  int v7; // r1
  void *v8; // r5
  int (__fastcall *v9)(_DWORD *); // r2

  v3 = open64(a1, 0);
  if ( v3 < 0 )
    return -1;
  v6 = sub_3FD84(v3, a2);
  v8 = v6;
  if ( !v6 )
    return -1;
  v9 = (int (__fastcall *)(_DWORD *))v6[1];
  v4 = v6[2];
  if ( v9 )
    sub_3FF4C(v6[2], 1, v9);
  else
    sub_1771C(v4, v7, -*v6, 1);
  free(v8);
  return v4;
}
// 40074: variable 'v7' is possibly undefined
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (0004007C) --------------------------------------------------------
int __fastcall sub_4007C(__int64 a1, __int64 a2)
{
  int v3; // r4

  if ( a2 )
  {
    v3 = a1;
    a1 = lseek64(a1, 1);
    if ( a1 == -1 )
    {
      if ( *(_DWORD *)dword_7DB94 != 29 )
        sub_16B40("seek failure");
      LODWORD(a1) = sub_400F8(v3, a2);
    }
  }
  return a1;
}
// 13928: using guessed type __int64 __fastcall lseek64(_DWORD, _DWORD);
// 7DB94: using guessed type int dword_7DB94;

//----- (000400F8) --------------------------------------------------------
int __fastcall sub_400F8(int result, __int64 a2)
{
  if ( a2 )
    return sub_17F58(result, -1, a2);
  return result;
}

//----- (00040108) --------------------------------------------------------
unsigned __int8 *__fastcall sub_40108(const char *a1)
{
  unsigned __int8 *i; // r4
  char *v3; // r0

  for ( i = (unsigned __int8 *)a1; ; i = (unsigned __int8 *)(v3 + 4) )
  {
    while ( 1 )
    {
      while ( *i == 47 )
        ++i;
      if ( !sub_1684C(i, (int)"../") )
        break;
      i += 3;
    }
    v3 = strstr((const char *)i, "/../");
    if ( !v3 )
      break;
  }
  if ( i != (unsigned __int8 *)a1 && !dword_7D73C )
  {
    dword_7D73C = 1;
    sub_16DDC("removing leading '%.*s' from member names", i - (unsigned __int8 *)a1, a1);
  }
  return i;
}
// 7D73C: using guessed type int dword_7D73C;

//----- (000401A0) --------------------------------------------------------
_DWORD *__fastcall sub_401A0(_DWORD *a1, char *haystack, const char *a3, int a4)
{
  char *v8; // r1
  _DWORD *result; // r0

  if ( a4 || *haystack == 47 || strstr(haystack, "..") )
  {
    v8 = sub_177E4("%c%s%c%s", a4, a3, 0, haystack);
    return sub_5D2C8(a1, (int)v8);
  }
  else
  {
    result = (_DWORD *)symlink(haystack, a3);
    if ( result )
      sub_16B40("can't create %slink '%s' to '%s'", "sym", a3, haystack);
  }
  return result;
}

//----- (00040244) --------------------------------------------------------
int __fastcall sub_40244(int result)
{
  _DWORD *i; // r4
  int v2; // r6
  const char *v3; // r5
  const char *v4; // r1
  unsigned __int8 *v5; // r2
  const char *v6; // r1
  const char *v7; // r2
  int v8; // t1

  for ( i = (_DWORD *)result; i; i = (_DWORD *)*i )
  {
    v2 = i[1];
    v3 = (const char *)(v2 + strlen((const char *)(v2 + 1)) + 2);
    v4 = (const char *)(v2 + 1);
    if ( *(_BYTE *)v2 )
      result = link(v3, v4);
    else
      result = symlink(v3, v4);
    if ( result )
    {
      v5 = (unsigned __int8 *)i[1];
      v6 = "hard";
      v8 = *v5;
      v7 = (const char *)(v5 + 1);
      if ( !v8 )
        v6 = "sym";
      sub_16DBC("can't create %slink '%s' to '%s'", v6, v7, v3);
    }
  }
  return result;
}

//----- (000402D8) --------------------------------------------------------
int __fastcall sub_402D8(int a1, unsigned int a2)
{
  __int64 v4; // r2
  unsigned int v5; // r2
  unsigned int v6; // r5
  int result; // r0

  sub_62BA4(*(_QWORD *)(a1 + 48), a2);
  sub_62BA4(a2 - v4, a2);
  v6 = v5;
  result = (*(int (__fastcall **)(_DWORD, _DWORD, unsigned int, _DWORD))(a1 + 40))(
             *(_DWORD *)(a1 + 4),
             *(_DWORD *)(a1 + 40),
             v5,
             0);
  *(_QWORD *)(a1 + 48) += v6;
  return result;
}
// 402F8: variable 'v4' is possibly undefined
// 40310: variable 'v5' is possibly undefined

//----- (0004033C) --------------------------------------------------------
bool __fastcall sub_4033C(int a1)
{
  return **(_DWORD **)(a1 + 24) == 0;
}

//----- (00040354) --------------------------------------------------------
bool __fastcall sub_40354(int a1, int a2)
{
  const char *v2; // r0
  int v3; // r5
  const char *v4; // r0
  char *v5; // r6
  const char *v6; // r7
  size_t v7; // r4
  size_t v8; // r0
  size_t v9; // r5

  v2 = *(const char **)(a2 + 4);
  v3 = a2;
  if ( v2 && !strcmp(v2, "--") )
    v3 += 4;
  v4 = *(const char **)(v3 + 4);
  if ( !v4 )
LABEL_5:
    sub_162F0();
  v5 = sub_16A54(v4);
  v6 = *(const char **)(v3 + 8);
  v7 = strlen(v5);
  if ( v6 )
  {
    if ( *(_DWORD *)(v3 + 12) )
      goto LABEL_5;
    v8 = strlen(*(const char **)(v3 + 8));
    if ( v7 > v8 )
    {
      v9 = v7 - v8;
      if ( !strcmp(&v5[v7 - v8], v6) )
        v7 = v9;
    }
  }
  v5[v7] = 10;
  return v7 + 1 != sub_17FB8(1, v5, v7 + 1);
}

//----- (00040404) --------------------------------------------------------
int __fastcall sub_40404(int a1, char **a2)
{
  _BOOL4 v2; // r9
  unsigned int v4; // r0
  char v5; // r5
  int *v6; // r4
  int v7; // r6
  int v8; // r3
  char v9; // r8
  int v10; // r3
  int v11; // r11
  ssize_t v12; // r0
  int v13; // r7
  unsigned int v14; // r3
  unsigned int v15; // r9
  int v16; // t1
  char v17; // r0
  int v18; // t1
  ssize_t v20; // [sp+0h] [bp-34h]
  int v21; // [sp+4h] [bp-30h]
  int v22; // [sp+8h] [bp-2Ch]
  unsigned int v23; // [sp+Ch] [bp-28h]
  _DWORD v24[8]; // [sp+14h] [bp-20h] BYREF

  v4 = sub_593CC(a2, "^etvAnbu");
  v5 = v4;
  v6 = (int *)&a2[optind];
  if ( !*v6 )
    *--v6 = (int)"-";
  if ( (v4 & 7) != 0 )
  {
    v7 = 0;
    if ( (v4 & 0x30) != 0 )
    {
      v8 = 10;
      v2 = 1;
    }
    else
    {
      v8 = 256;
    }
    if ( (v4 & 0x30) == 0 )
      v2 = 0;
    v9 = 0;
    v22 = v8;
    if ( (v4 & 0x20) != 0 )
      v10 = 10;
    else
      v10 = 256;
    v21 = v10;
    do
    {
      v11 = sub_61D34(*v6);
      if ( v11 >= 0 )
      {
        while ( 1 )
        {
          v12 = read(v11, &buf, 0x400u);
          v20 = v12;
          if ( v12 < 0 )
            break;
          if ( !v12 )
            goto LABEL_23;
          v13 = 0;
          do
          {
            v14 = *((unsigned __int8 *)&buf.c_iflag + v13);
            if ( v2 && v21 != v14 )
            {
              ++v7;
              v23 = *((unsigned __int8 *)&buf.c_iflag + v13);
              printf("%6u  ", v7);
              v14 = v23;
            }
            ++v13;
            v15 = v22 - v14;
            sub_5E550(v14, v24, v5);
            v2 = v15 == 0;
            fputs_unlocked(v24, stdout);
          }
          while ( v20 != v13 );
        }
      }
      v9 = 1;
LABEL_23:
      v16 = v6[1];
      ++v6;
    }
    while ( v16 );
    v17 = v9;
LABEL_25:
    sub_588D8(v17);
  }
  if ( ((v4 >> 4) & 3) != 0 )
  {
    v24[0] = 6;
    v24[1] = 1;
    v24[2] = 1;
    v24[5] = ((v4 ^ 0x20) >> 5) & 1;
    v24[6] = (v4 >> 4) & 2;
    v24[3] = "\t";
    v24[4] = "\n";
    do
    {
      sub_5E42C((int)v24, *v6);
      v18 = v6[1];
      ++v6;
      v17 = v18;
    }
    while ( v18 );
    goto LABEL_25;
  }
  return sub_57910(v6);
}
// 404BC: variable 'v2' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7D614: using guessed type int stdout;

//----- (000405D0) --------------------------------------------------------
int __fastcall sub_405D0(const char *a1, int a2, const char *a3, int a4)
{
  __mode_t v7; // r1

  if ( a4 )
  {
    if ( (*(_DWORD *)(a2 + 16) & 0xF000) == 0xA000 )
      return 1;
  }
  else if ( sub_62DFC() )
  {
LABEL_5:
    sub_16B80(a1);
    return 0;
  }
  v7 = sub_5E0F4(a3, *(_DWORD *)(a2 + 16));
  if ( v7 == -1 )
    sub_16DBC("invalid mode '%s'", a3);
  if ( chmod(a1, v7) )
    goto LABEL_5;
  return 1;
}

//----- (00040654) --------------------------------------------------------
int __fastcall sub_40654(int a1, char **a2)
{
  char **v3; // r6
  char *v4; // r4
  char *v5; // t1
  char v6; // r1
  int v7; // r3
  int v8; // r7
  char **v9; // r2
  int v10; // r5
  char **v11; // r4
  int v12; // r0
  char *v13; // r3
  char *v14; // t1

  v3 = a2;
  while ( 1 )
  {
    v5 = v3[1];
    ++v3;
    v4 = v5;
    if ( !v5 )
      break;
    if ( *v4 != 45 )
    {
      v4 = 0;
      break;
    }
    if ( v4[1] && !strchr("-R", (unsigned __int8)v4[1]) )
    {
      *v4 = 97;
      break;
    }
  }
  sub_593CC(a2, "^R");
  if ( v4 )
    v6 = 45;
  v7 = optind;
  if ( v4 )
    *v4 = v6;
  v8 = (int)a2[v7];
  v9 = &a2[v7];
  v10 = 0;
  v11 = v9 + 1;
  do
  {
    v12 = sub_60474(*v11, dword_7DBC0 & 1, (int (*)())sub_405D0, (int (*)())sub_405D0, v8, 0);
    v14 = v11[1];
    ++v11;
    v13 = v14;
    if ( !v12 )
      v10 = 1;
  }
  while ( v13 );
  return v10;
}
// 406C4: variable 'v6' is possibly undefined
// 7D604: using guessed type int optind;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00040734) --------------------------------------------------------
int __fastcall sub_40734(const char *a1, int a2, int *a3)
{
  int v3; // r3
  int v6; // r2

  v3 = *a3;
  v6 = a3[1];
  if ( v3 == -1 )
    v3 = *(_DWORD *)(a2 + 24);
  if ( v6 == -1 )
    v6 = *(_DWORD *)(a2 + 28);
  if ( !((int (__fastcall *)(const char *, int, int))a3[2])(a1, v3, v6) )
    return 1;
  sub_16B80(a1);
  return 0;
}

//----- (00040788) --------------------------------------------------------
int __fastcall sub_40788(int a1, char **a2)
{
  char v3; // r0
  int (*v4)(const char *, __uid_t, __gid_t); // r2
  char *v5; // r1
  char **v6; // r5
  int v7; // r4
  int v8; // r7
  const char *v9; // r0
  const char *v10; // t1
  __uid_t v12[2]; // [sp+Ch] [bp-10h] BYREF
  int (*v13)(const char *, __uid_t, __gid_t); // [sp+14h] [bp-8h]

  v3 = sub_593CC(a2, "^Rh");
  v4 = chown;
  v13 = chown;
  if ( (v3 & 2) != 0 )
    v4 = lchown;
  v5 = a2[optind];
  v6 = &a2[optind];
  v7 = 0;
  if ( (v3 & 2) != 0 )
    v13 = v4;
  if ( (v3 & 1) != 0 )
    v8 = 9;
  else
    v8 = 8;
  sub_6278C(v12, v5);
  while ( 1 )
  {
    v10 = v6[1];
    ++v6;
    v9 = v10;
    if ( !v10 )
      break;
    if ( !sub_60474(v9, v8, (int (*)())sub_40734, (int (*)())sub_40734, (int)v12, 0) )
      v7 = 1;
  }
  return v7;
}
// 7D604: using guessed type int optind;

//----- (00040834) --------------------------------------------------------
void __fastcall __noreturn sub_40834(int a1, const char **a2)
{
  const char *v2; // r0
  const char **v4; // r0

  v2 = a2[1];
  if ( !v2 )
    sub_162F0();
  sub_17920(v2);
  v4 = a2 + 2;
  if ( !a2[2] )
  {
    *a2 = sub_58D5C();
    v4 = a2;
    a2[1] = "-i";
  }
  sub_58840(v4);
}

//----- (0004087C) --------------------------------------------------------
void __fastcall __noreturn sub_4087C(int a1, int a2, int a3)
{
  const char **v3; // r4
  char v4; // r9
  _DWORD *v5; // r10
  const char *v6; // r0
  int v7; // r11
  __int64 v8; // r6
  unsigned int v9; // r8
  ssize_t v10; // r0
  int v11; // r2
  unsigned int v12; // r0
  int v13; // r1
  const char *v14; // r0
  const char *v15; // t1
  __int64 v16; // r0
  int i; // r3
  int v18; // r2
  int v19; // [sp+4h] [bp-8h]
  int v20; // [sp+8h] [bp-4h]

  v19 = a2;
  v20 = a3;
  v3 = (const char **)(a2 + 4);
  v4 = 0;
  v5 = sub_585EC(0, 1);
  while ( 1 )
  {
    v6 = *v3;
    if ( !*v3 )
      v6 = "standard input";
    v7 = sub_61D34((int)v6);
    if ( v7 >= 0 )
    {
      v8 = 0;
      v9 = 0;
      do
      {
        v10 = sub_1800C(v7, &buf, 0x400u);
        v11 = v10;
        if ( v10 <= 0 )
        {
          close(v7);
          v16 = v8;
          for ( i = 0; ; ++i )
          {
            v11 = i;
            if ( !v16 )
              break;
            *((_BYTE *)&buf.c_iflag + i) = v16;
            v18 = v16 >> 8;
            HIDWORD(v16) >>= 8;
            LODWORD(v16) = v18;
          }
          v7 = -1;
        }
        else
        {
          v8 += v10;
        }
        v12 = sub_58684(v9, (unsigned __int8 *)&buf, v11, (int)v5);
        v9 = v12;
      }
      while ( v7 != -1 );
      v13 = ~v12;
      v14 = "%u %llu\n";
      if ( *v3 )
        v14 = "%u %llu %s\n";
      printf(v14, v13, v8, *v3, v19, v20);
    }
    else
    {
      v4 = 1;
    }
    if ( *v3 )
    {
      v15 = v3[1];
      ++v3;
      if ( v15 )
        continue;
    }
    sub_588D8(v4);
  }
}
// 4092C: variable 'v19' is possibly undefined
// 4092C: variable 'v20' is possibly undefined

//----- (000409A4) --------------------------------------------------------
int __fastcall sub_409A4(int a1, char **a2)
{
  int v4; // r0
  int v5; // r5
  const char **v6; // r7
  const char *v7; // r6
  int (*v8)(); // r2
  int v9; // r8
  int v10; // r0
  int v11; // r9
  int v12; // r4
  char *v13; // r8
  char *v14; // r0
  int v16; // [sp+0h] [bp-D0h] BYREF
  _BYTE v17[104]; // [sp+68h] [bp-68h] BYREF

  v4 = sub_593CC(a2, "^pdRfilsLHarPvuT");
  v5 = v4 ^ 2;
  if ( ((v4 ^ 2) & 0x80) != 0 )
    v5 = v4 | 2;
  v6 = (const char **)&a2[optind];
  v7 = (&v6[a1 - optind])[-1];
  if ( a1 - optind != 2 )
  {
    v11 = v5 & 0x4000;
    if ( (v5 & 0x4000) != 0 )
      sub_16DBC("too many arguments");
    goto LABEL_17;
  }
  v8 = sub_62DFC;
  if ( (v5 & 2) == 0 )
    v8 = sub_62E14;
  v9 = sub_49B28(a2[optind], (int)&v16, v8);
  if ( v9 < 0 )
    return 1;
  v10 = sub_49B90(v7, (int)v17);
  if ( v10 < 0 )
    return 1;
  v11 = v5 & 0x4000;
  if ( (v5 & 0x4000) != 0 && (v9 & 2) == 0 && (v10 & 2) != 0 )
    sub_16DBC("'%s' is a directory", v7);
  v12 = ((unsigned __int8)v9 | (unsigned __int8)v10) & 2;
  if ( (((unsigned __int8)v9 | (unsigned __int8)v10) & 2) != 0 )
  {
    if ( ((v5 & 4) == 0 || ((v10 == 0) & ((unsigned int)v9 >> 1)) == 0) && (v5 & 0x4000) == 0 )
      goto LABEL_17;
    v13 = (char *)v7;
    v12 = 0;
  }
  else
  {
    v13 = (char *)v7;
  }
  while ( 1 )
  {
    if ( sub_57E30(*v6, v13, v5) < 0 )
      v12 = 1;
    if ( v6[1] == v7 )
      break;
    v11 = v12;
    free(v13);
    ++v6;
LABEL_17:
    v12 = v11;
    v14 = sub_16A54(*v6);
    v13 = sub_16998(v7, v14);
  }
  return v12;
}
// 7D604: using guessed type int optind;

//----- (00040B14) --------------------------------------------------------
int __fastcall sub_40B14(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00040B24) --------------------------------------------------------
void __fastcall __noreturn sub_40B24(int a1, char **a2)
{
  const char *v3; // r0
  bool v4; // zf
  int v5; // r10
  unsigned int v6; // r8
  char *v7; // r0
  unsigned int v8; // r11
  int v9; // r5
  char *v10; // r0
  char *v11; // r2
  char *v12; // r4
  char *v13; // r0
  int v14; // r1
  int v15; // r2
  int i; // r7
  unsigned int v17; // r0
  unsigned int v18; // r0
  signed int v19; // r10
  char v20; // r6
  char *v21; // r5
  int j; // r6
  signed int v23; // r5
  unsigned __int8 *v24; // r9
  char *v26; // r3
  int v27; // r3
  char *v28; // r2
  char *v29; // r0
  int v30; // r3
  int v31; // r0
  _BOOL4 v32; // r1
  int v33; // t1
  bool v34; // cc
  _BOOL4 v35; // r3
  int v36; // r11
  int v37; // r10
  char v38; // r2
  int v39; // r3
  unsigned int k; // r9
  bool v41; // cf
  int v42; // r6
  int c; // [sp+8h] [bp-34h]
  int *v44; // [sp+Ch] [bp-30h]
  _BYTE *ptr; // [sp+10h] [bp-2Ch]
  char *s; // [sp+14h] [bp-28h]
  char v47; // [sp+18h] [bp-24h]
  FILE *v48; // [sp+1Ch] [bp-20h]
  char delim[4]; // [sp+28h] [bp-14h] BYREF
  char *v50; // [sp+2Ch] [bp-10h] BYREF
  char *v51; // [sp+30h] [bp-Ch] BYREF
  char *stringp; // [sp+34h] [bp-8h] BYREF

  v3 = (const char *)sub_593CC(a2, "^b:c:f:d:sn", &v50, &v50, &v50, &v51);
  v4 = ((unsigned __int8)v3 & 7) == 0;
  if ( ((unsigned __int8)v3 & 7) == 0 )
    v3 = "expected a list of bytes, characters, or fields";
  v5 = optind;
  v44 = (int *)&a2[optind];
  if ( v4 )
LABEL_8:
    sub_16DBC(v3);
  if ( ((unsigned __int8)v3 & 8) != 0 )
  {
    c = (unsigned __int8)*v51;
    if ( *v51 && v51[1] )
    {
      v3 = "the delimiter must be a single character";
      goto LABEL_8;
    }
  }
  else
  {
    c = 9;
  }
  if ( ((unsigned __int8)v3 & 4) != 0 )
  {
    v6 = 0;
  }
  else
  {
    v6 = (unsigned __int8)v3 & 0x10;
    if ( ((unsigned __int8)v3 & 0x10) != 0 )
      sub_16DBC("suppressing non-delimited lines makes sense%s", " only when operating on fields");
    if ( c != 9 )
      sub_16DBC("a delimiter may be specified%s", " only when operating on fields");
  }
  v12 = 0;
  while ( 1 )
  {
    do
    {
      v13 = strsep(&v50, ",");
      v51 = v13;
      if ( !v13 )
      {
        if ( !v6 )
          sub_16DBC("missing list of positions");
        qsort(v12, v6, 8u, (__compar_fn_t)sub_40B14);
        if ( !a2[v5] )
          *--v44 = (int)"-";
        v47 = 0;
        while ( 1 )
        {
          v48 = (FILE *)sub_61CD8(*v44);
          if ( v48 )
            break;
          v47 = 1;
LABEL_55:
          v30 = v44[1];
          ++v44;
          if ( !v30 )
            sub_588D8(v47);
        }
        for ( i = 0; ; ++i )
        {
          v29 = sub_58D24(v48, v14, v15);
          stringp = v29;
          if ( !v29 )
          {
            sub_5888C(v48);
            goto LABEL_55;
          }
          v19 = strlen(v29);
          ptr = sub_174DC(v19 + 1);
          s = stringp;
          v20 = dword_7DBC0;
          v21 = (char *)(dword_7DBC0 & 3);
          if ( (dword_7DBC0 & 3) != 0 )
          {
            for ( j = 0; j != v6; ++j )
            {
              v23 = *(_DWORD *)&v12[8 * j];
              v24 = &ptr[v23];
              do
              {
                if ( v19 <= v23 )
                  break;
                if ( !*v24++ )
                {
                  v26 = stringp;
                  *(v24 - 1) = 88;
                  putchar_unlocked((unsigned __int8)v26[v23]);
                }
                ++v23;
              }
              while ( v23 <= *(_DWORD *)&v12[8 * j + 4] );
            }
LABEL_48:
            putchar_unlocked(10);
            goto LABEL_52;
          }
          if ( c == 10 )
            break;
          delim[0] = c;
          delim[1] = 0;
          if ( strchr(stringp, c) )
          {
            v36 = 0;
            v42 = -1;
            for ( k = 0; ; ++k )
            {
              v41 = 1;
              if ( stringp )
                v41 = k >= v6;
              if ( v41 )
                break;
              v37 = *(_DWORD *)&v12[8 * k];
              do
              {
                while ( 1 )
                {
                  v34 = (int)stringp < 0;
                  if ( stringp )
                    v34 = v42 < v37;
                  if ( !v34 )
                    break;
                  ++v42;
                  v21 = strsep(&stringp, delim);
                }
                v35 = v42 == v37;
                if ( !v21 )
                  v35 = 0;
                if ( v35 && !ptr[v42] )
                {
                  if ( v36 )
                    putchar_unlocked(c);
                  ++v36;
                  fputs_unlocked(v21, stdout);
                  ptr[v42] = 88;
                }
                ++v37;
                v38 = (char)stringp;
                v39 = *(_DWORD *)&v12[8 * k + 4];
                if ( stringp )
                  v38 = 1;
              }
              while ( v37 <= v39 && ((unsigned __int8)v38 & (v39 != -1)) != 0 );
            }
            goto LABEL_48;
          }
          if ( (v20 & 0x10) == 0 )
            goto LABEL_63;
LABEL_52:
          free(ptr);
          free(s);
        }
        v27 = *(_DWORD *)v12;
        if ( *(_DWORD *)v12 > i )
          goto LABEL_52;
        v28 = v12;
        while ( i > v27 )
        {
          v31 = *((_DWORD *)v28 + 1);
          ++v27;
          v32 = v31 == -1;
          if ( v27 > v31 )
            v32 = 1;
          if ( v32 )
          {
            if ( ++v21 == (char *)v6 )
              goto LABEL_52;
            v33 = *((_DWORD *)v28 + 2);
            v28 += 8;
            v27 = v33;
            if ( i < v33 )
              goto LABEL_52;
          }
        }
LABEL_63:
        puts(s);
        goto LABEL_52;
      }
    }
    while ( !*v13 );
    v7 = strsep(&v51, "-");
    if ( *v7 && (v17 = sub_6219C(v7)) != 0 )
      v8 = v17 - 1;
    else
      v8 = 0;
    if ( !v51 )
      break;
    if ( *v51 )
    {
      v18 = sub_6219C(v51);
      if ( !v18 )
        v18 = 0x7FFFFFFF;
      v9 = v18 - 1;
      if ( v8 == v18 - 1 )
        break;
    }
    else
    {
      v9 = 0x7FFFFFFF;
    }
LABEL_20:
    v10 = sub_62544(v12, 0x804u, v6);
    v11 = &v10[8 * v6];
    *(_DWORD *)v11 = v8;
    v12 = v10;
    ++v6;
    *((_DWORD *)v11 + 1) = v9;
  }
  v9 = -1;
  goto LABEL_20;
}
// 40DD0: variable 'v14' is possibly undefined
// 40DD0: variable 'v15' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7D614: using guessed type int stdout;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00040FA8) --------------------------------------------------------
int __fastcall sub_40FA8(int a1, char **a2)
{
  char v3; // r5
  int v4; // r7
  void **v5; // r9
  int v6; // r6
  char *v7; // r4
  const char *v8; // r8
  size_t v9; // r0
  const char *v10; // r3
  size_t v11; // r7
  const char *v12; // r1
  int v13; // r3
  int v14; // r2
  char v15; // r1
  unsigned __int8 *v16; // r0
  const char *v17; // r2
  void *v19; // [sp+14h] [bp-B0h] BYREF
  int v20; // [sp+18h] [bp-ACh] BYREF
  const char *v21; // [sp+1Ch] [bp-A8h] BYREF
  char *s; // [sp+20h] [bp-A4h] BYREF
  time_t timer[2]; // [sp+24h] [bp-A0h] BYREF
  struct tm tp; // [sp+2Ch] [bp-98h] BYREF
  char dest[80]; // [sp+58h] [bp-6Ch] BYREF
  time_t v26; // [sp+A8h] [bp-1Ch]

  s = 0;
  v3 = sub_593F8(a2, "^Rs:ud:r:I::D:", "rfc-822", &v19, &v19, &v21, &s, &v20);
  v4 = optind;
  v5 = (void **)&a2[optind];
  if ( (v3 & 4) != 0 )
    putenv("TZ=UTC0");
  if ( (v3 & 0x20) != 0 )
  {
    if ( s )
    {
      v6 = sub_168D4("date", s);
      if ( v6 < 0 )
        goto LABEL_6;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = -1;
  }
  v7 = a2[v4];
  if ( v7 )
  {
    if ( *v7 == 43 )
    {
      ++v7;
      ++v5;
    }
    else
    {
      v7 = 0;
    }
  }
  v8 = (const char *)*v5;
  if ( (v3 & 0xA) == 0 )
  {
    v3 |= 2u;
    v19 = *v5;
    if ( v8 )
    {
      v9 = strspn(v8, "0123456789");
      if ( !v8[v9]
        || v8[v9] == 46
        && (v10 = &v8[v9], (unsigned int)(unsigned __int8)v8[v9 + 1] - 48 <= 9)
        && (unsigned int)*((unsigned __int8 *)v10 + 2) - 48 <= 9
        && !v10[3] )
      {
        v11 = v9 - 8;
        if ( v9 - 8 > 4 || (v11 & 1) != 0 )
        {
          v12 = v8;
          goto LABEL_22;
        }
        if ( v9 != 8 )
        {
          memcpy(dest, v8 + 8, v9 - 8);
          memmove((void *)&v8[v11], v8, 8u);
          memcpy(v19, dest, v11);
        }
      }
      ++v5;
    }
  }
  if ( *v5 )
LABEL_6:
    sub_162F0();
  if ( (v3 & 0x10) != 0 )
  {
    sub_17A0C(v21);
    timer[0] = v26;
  }
  else
  {
    time(timer);
  }
  localtime_r(timer, &tp);
  if ( v19 )
  {
    memset(&tp, 0, 12);
    if ( (v3 & 0x40) != 0 )
    {
      if ( !strptime() )
      {
        v12 = (const char *)v19;
LABEL_22:
        sub_16DBC("invalid date '%s'", v12);
      }
    }
    else
    {
      sub_182E8((int)v19, &tp.tm_sec);
    }
    if ( *(_BYTE *)v19 != 64 )
      tp.tm_isdst = -1;
    timer[0] = sub_18740((const char *)v19, &tp);
    if ( (v3 & 2) != 0 && stime(timer) < 0 )
      sub_16AF4("can't set date");
  }
  if ( !v7 )
  {
    if ( v6 != -1 )
    {
      strcpy(dest, "%Y-%m-%dT%H:%M:%S");
      v13 = 3 * v6 + 8;
      if ( !v6 )
      {
LABEL_48:
        v7 = dest;
        dest[v13] = 0;
        goto LABEL_49;
      }
LABEL_44:
      v14 = v13 + 1;
      dest[v13] = 37;
      v13 += 2;
      if ( (v3 & 4) != 0 )
        v15 = 90;
      else
        v15 = 122;
      dest[v14] = v15;
      goto LABEL_48;
    }
    if ( (v3 & 1) != 0 )
    {
      strcpy(dest, "%a, %d %b %Y %H:%M:%S ");
      v13 = 22;
      goto LABEL_44;
    }
    v7 = "%a %b %e %H:%M:%S %Z %Y";
  }
LABEL_49:
  if ( *v7 )
  {
    v16 = sub_1684C((unsigned __int8 *)v7, (int)"%f");
    v17 = "%Y.%m.%d-%H:%M:%S";
    if ( !v16 )
      v17 = v7;
    strftime((char *)&buf, 0x400u, v17, &tp);
  }
  else
  {
    LOBYTE(buf.c_iflag) = 0;
  }
  puts((const char *)&buf);
  return 0;
}
// 137F8: using guessed type int strptime(void);
// 7D604: using guessed type int optind;

//----- (00041308) --------------------------------------------------------
int __fastcall sub_41308(int a1, int a2)
{
  char *v2; // r0
  char *v3; // r0

  v2 = (char *)sub_60E30(a2);
  v3 = dirname(v2);
  puts(v3);
  return sub_177D8();
}

//----- (00041324) --------------------------------------------------------
unsigned __int64 __fastcall sub_41324(const char *a1)
{
  unsigned __int64 v2; // r4
  DIR *v4; // r8
  char *v5; // r9
  int v6; // r0
  char *v7; // r0
  _QWORD v8[2]; // [sp+0h] [bp-6Ch] BYREF
  int v9; // [sp+10h] [bp-5Ch]
  unsigned int v10; // [sp+14h] [bp-58h]
  unsigned __int64 v11; // [sp+40h] [bp-2Ch]

  if ( sub_62E14() )
    goto LABEL_2;
  if ( (dword_7DBC0 & 0x20) != 0 )
  {
    if ( *(_DWORD *)&buf.c_line )
    {
      if ( *(_QWORD *)&buf.c_cc[7] != v8[0] )
        return 0;
    }
    else
    {
      *(_QWORD *)&buf.c_cc[7] = v8[0];
    }
  }
  v2 = v11;
  if ( (v9 & 0xF000) == 0xA000 && (int)buf.c_lflag > *(int *)&buf.c_line )
  {
    if ( sub_62DFC() )
    {
LABEL_2:
      sub_16B80(a1);
      LOBYTE(buf.c_cflag) = 1;
      return 0;
    }
    v2 = v11;
    if ( buf.c_lflag == 1 )
      buf.c_lflag = 0x7FFFFFFF;
  }
  if ( (dword_7DBC0 & 0x80) == 0 && v10 > 1 )
  {
    if ( sub_5A6C0((int)v8) )
      return 0;
    sub_5A754((int)v8, 0);
  }
  if ( (v9 & 0xF000) == 0x4000 )
  {
    v4 = sub_17954(a1);
    if ( !v4 )
    {
      LOBYTE(buf.c_cflag) = 1;
      return v2;
    }
    while ( 1 )
    {
      v6 = readdir64(v4);
      if ( !v6 )
        break;
      v5 = sub_57D64(a1, (_BYTE *)(v6 + 19));
      if ( v5 )
      {
        ++*(_DWORD *)&buf.c_line;
        v2 += sub_41324();
        --*(_DWORD *)&buf.c_line;
        free(v5);
      }
    }
    closedir(v4);
  }
  else if ( (dword_7DBC0 & 1) == 0 && *(_DWORD *)&buf.c_line )
  {
    return v2;
  }
  if ( *(int *)&buf.c_line <= (int)buf.c_oflag )
  {
    v7 = sub_5A318(v2, 0x200u, buf.c_iflag);
    printf("%s\t%s\n", v7, a1);
  }
  return v2;
}
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00041530) --------------------------------------------------------
void __fastcall __noreturn sub_41530(int a1, char **a2)
{
  char *v3; // r0
  __int16 v4; // r0
  int *v5; // r3
  __int16 v6; // r5
  bool v7; // zf
  char **v8; // r2
  char **v9; // r7
  tcflag_t c_lflag; // r9
  unsigned __int64 v11; // kr00_8
  char *v12; // t1
  char *v13; // r0

  buf.c_iflag = 1024;
  v3 = getenv("POSIXLY_CORRECT");
  if ( v3 )
    BYTE1(buf.c_iflag) = 2;
  LOWORD(buf.c_oflag) = -1;
  BYTE2(buf.c_oflag) = -1;
  if ( v3 )
  {
    LOBYTE(buf.c_iflag) = 0;
    HIWORD(buf.c_iflag) = 0;
  }
  HIBYTE(buf.c_oflag) = 127;
  v4 = sub_593CC(a2, "^aHkLsxd:+lchm", &buf.c_oflag);
  v5 = &optind;
  v6 = v4;
  if ( (v4 & 0x200) != 0 )
    buf.c_iflag = 0;
  v7 = (v4 & 0x400) == 0;
  if ( (v4 & 0x400) != 0 )
  {
    LOBYTE(v5) = 0;
    LOBYTE(v4) = 16;
    LOBYTE(buf.c_iflag) = 0;
  }
  v8 = &a2[optind];
  if ( !v7 )
  {
    BYTE1(buf.c_iflag) = (_BYTE)v5;
    HIBYTE(buf.c_iflag) = (_BYTE)v5;
    BYTE2(buf.c_iflag) = v4;
  }
  if ( (v6 & 4) != 0 )
    buf.c_iflag = 1024;
  if ( (v6 & 2) != 0 )
    buf.c_lflag = 1;
  if ( (v6 & 8) != 0 )
    buf.c_lflag = 0x7FFFFFFF;
  if ( (v6 & 0x10) != 0 )
    buf.c_oflag = 0;
  if ( a2[optind] )
  {
    v9 = &a2[optind];
  }
  else
  {
    v9 = v8 - 1;
    *(v8 - 1) = ".";
    if ( buf.c_lflag == 1 )
      buf.c_lflag = 0;
  }
  c_lflag = buf.c_lflag;
  v11 = 0;
  do
  {
    v11 += sub_41324(*v9);
    sub_5A7F4();
    buf.c_lflag = c_lflag;
    v12 = v9[1];
    ++v9;
  }
  while ( v12 );
  if ( (v6 & 0x100) != 0 )
  {
    v13 = sub_5A318(v11, 0x200u, buf.c_iflag);
    printf("%s\t%s\n", v13, "total");
  }
  sub_588D8(buf.c_cflag);
}
// 7D604: using guessed type int optind;

//----- (00041704) --------------------------------------------------------
int __fastcall sub_41704(int a1, int a2, unsigned __int8 *a3)
{
  int v3; // r6
  int v4; // r7
  unsigned __int8 **v5; // r5
  _BYTE *v6; // r3
  unsigned __int8 *v7; // r3
  int v8; // r12
  int v9; // r0
  int v10; // r2
  int v11; // r4
  int i; // r8
  const char *v13; // r0
  const char *v14; // t1
  char *v15; // r8
  char *j; // r4
  unsigned __int8 *v17; // r1
  int *v18; // r5
  int result; // r0
  unsigned __int8 *v21; // t1
  int v22; // r2
  unsigned __int8 *v23; // r3
  char v24; // r0
  unsigned __int8 *v25[2]; // [sp+4h] [bp-8h] BYREF

  v25[0] = (unsigned __int8 *)a2;
  v25[1] = a3;
  v3 = 0;
  v4 = 1;
  while ( 1 )
  {
    v5 = (unsigned __int8 **)(a2 + 4);
    v6 = *(_BYTE **)(a2 + 4);
    if ( !v6 || *v6 != 45 )
      break;
    v7 = v6 + 1;
    v8 = v3;
    v9 = v4;
    do
    {
      v10 = *v7;
      switch ( v10 )
      {
        case 'n':
          v9 = 0;
          break;
        case 'e':
          v8 = 92;
          break;
        case 'E':
          break;
        default:
          goto LABEL_8;
      }
    }
    while ( *++v7 );
    v3 = v8;
    v4 = v9;
    a2 += 4;
  }
LABEL_8:
  v11 = a2;
  for ( i = 0; ; i += strlen(v13) + 1 )
  {
    v14 = *(const char **)(v11 + 4);
    v11 += 4;
    v13 = v14;
    if ( !v14 )
      break;
  }
  v15 = (char *)sub_1748C(i + 1);
  for ( j = v15; ; ++j )
  {
    v17 = *v5;
    if ( !*v5 )
      break;
    if ( v3 )
    {
      while ( 1 )
      {
        v23 = v17 + 1;
        v24 = *v17;
        if ( !*v17 )
          break;
        if ( *v17 == v3 )
        {
          v22 = v17[1];
          if ( v22 == 99 )
            goto LABEL_14;
          if ( v22 == 48 && (unsigned int)v17[2] - 48 <= 7 )
            v23 = v17 + 2;
          v25[0] = v23;
          v24 = sub_5E668(v25);
          v23 = v25[0];
        }
        v17 = v23;
        *j++ = v24;
      }
    }
    else
    {
      j = (char *)stpcpy(j, v17);
    }
    v21 = v5[1];
    ++v5;
    if ( !v21 )
      break;
    *j = 32;
  }
  if ( v4 )
    *j++ = 10;
LABEL_14:
  v18 = (int *)dword_7DB94;
  *(_DWORD *)dword_7DB94 = 0;
  sub_17FB8(1, v15, j - v15);
  free(v15);
  result = *v18;
  if ( *v18 )
  {
    sub_16AF4("write error");
    return 1;
  }
  return result;
}
// 1372C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 7DB94: using guessed type int dword_7DB94;

//----- (000418A4) --------------------------------------------------------
void __fastcall __noreturn sub_418A4(int a1, char **a2)
{
  char v3; // r0
  const char **v4; // r4
  const char *v5; // r3
  const char **v6; // r6
  char *v7; // r5
  char *v8; // t1
  char *v9; // r0
  const char *v10; // r0
  int v11; // r4
  const char *v12; // t1
  _DWORD *v13; // [sp+4h] [bp-4h] BYREF

  v13 = 0;
  v3 = sub_593F8(a2, "+iu:*", "ignore-environment", &v13, a1);
  v4 = (const char **)&a2[optind];
  v5 = *v4;
  if ( *v4 && *v5 == 45 && !v5[1] )
  {
    v3 |= 1u;
    ++v4;
  }
  if ( (v3 & 1) != 0 )
    clearenv();
  while ( v13 )
  {
    v9 = (char *)sub_5D2FC(&v13);
    putenv(v9);
  }
  while ( 1 )
  {
    v6 = v4;
    v8 = (char *)*v4++;
    v7 = v8;
    if ( !v8 )
      break;
    if ( !strchr(v7, 61) )
      sub_58840(v6);
    if ( putenv(v7) < 0 )
      sub_16B40("putenv");
  }
  if ( _environ )
  {
    v11 = _environ - 4;
    while ( 1 )
    {
      v12 = *(const char **)(v11 + 4);
      v11 += 4;
      v10 = v12;
      if ( !v12 )
        break;
      puts(v10);
    }
  }
  sub_588D8(0);
}
// 7D600: using guessed type int _environ;
// 7D604: using guessed type int optind;

//----- (000419B0) --------------------------------------------------------
int __fastcall sub_419B0(int a1)
{
  _BYTE *v2; // r3

  if ( !*(_DWORD *)a1 )
    return *(_QWORD *)(a1 + 8) == 0;
  v2 = *(_BYTE **)(a1 + 8);
  if ( !*v2 )
    return 1;
  if ( *v2 == 48 )
    return v2[1] == 0;
  return 0;
}

//----- (00041A08) --------------------------------------------------------
char *__fastcall sub_41A08(char *result)
{
  char *v1; // r4

  if ( !*(_DWORD *)result )
  {
    v1 = result;
    result = sub_177E4("%lld", *((_QWORD *)result + 1));
    *((_DWORD *)v1 + 2) = result;
    *(_DWORD *)v1 = 1;
  }
  return result;
}

//----- (00041A3C) --------------------------------------------------------
_DWORD *__fastcall sub_41A3C(const char *a1)
{
  _DWORD *v2; // r4

  v2 = sub_174DC(0x10u);
  *v2 = 1;
  v2[2] = sub_174F8(a1);
  return v2;
}

//----- (00041A6C) --------------------------------------------------------
int __fastcall sub_41A6C(_DWORD *a1, char *a2)
{
  __int64 v3; // r8
  char *v4; // r0
  int v5; // r6
  char *endptr; // [sp+4h] [bp-4h] BYREF

  endptr = a2;
  if ( *a1 != 1 )
    return 1;
  v3 = strtoll((const char *)a1[2], &endptr, 10);
  v4 = (char *)a1[2];
  if ( v4 != endptr )
  {
    v5 = (unsigned __int8)*endptr;
    if ( !*endptr )
    {
      free(v4);
      *((_QWORD *)a1 + 1) = v3;
      *a1 = v5;
      return 1;
    }
  }
  return 0;
}

//----- (00041AD4) --------------------------------------------------------
signed __int64 __fastcall sub_41AD4(int a1, int a2, int a3)
{
  char *v6; // r1
  signed __int64 v7; // r0
  signed __int64 v8; // r8
  __int64 v9; // r4
  int v11; // r1
  __int64 v12; // r2

  if ( !sub_41A6C((_DWORD *)a1, (char *)a2) || !sub_41A6C((_DWORD *)a2, v6) )
    sub_16DBC("non-numeric argument");
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(_QWORD *)(a2 + 8);
  switch ( a3 )
  {
    case '+':
      return v7 + v8;
    case '-':
      return v7 - v8;
    case '*':
      return v7 * v8;
  }
  if ( !v8 )
    sub_16DBC("division by zero");
  if ( a3 == 47 )
  {
    LODWORD(v9) = sub_62BA4(v7, v8);
    HIDWORD(v9) = v11;
  }
  else
  {
    sub_62BA4(v7, v8);
    return v12;
  }
  return v9;
}
// 41AFC: variable 'v6' is possibly undefined
// 41B7C: variable 'v11' is possibly undefined
// 41B88: variable 'v12' is possibly undefined

//----- (00041B9C) --------------------------------------------------------
void __fastcall sub_41B9C(void **a1)
{
  if ( *a1 == (void *)1 )
    free(a1[2]);
  free(a1);
}

//----- (00041BC4) --------------------------------------------------------
const char *__fastcall sub_41BC4(const char *a1)
{
  const char *result; // r0

  result = *(const char **)buf.c_iflag;
  if ( *(_DWORD *)buf.c_iflag )
  {
    if ( !strcmp(result, a1) )
      return (const char *)(*(unsigned __int8 *)a1 + *((unsigned __int8 *)a1 + 1));
    else
      return 0;
  }
  return result;
}

//----- (00041C04) --------------------------------------------------------
_QWORD *__fastcall sub_41C04(int a1, int a2)
{
  const char *v4; // r1
  const char *v5; // r0
  _QWORD *v6; // r4
  regoff_t rm_eo; // r6
  regmatch_t pmatch[2]; // [sp+8h] [bp-34h] BYREF
  regex_t s; // [sp+18h] [bp-24h] BYREF

  sub_41A08((char *)a1);
  sub_41A08((char *)a2);
  v4 = *(const char **)(a2 + 8);
  if ( *v4 == 94 )
    sub_16DDC(
      "warning: '%s': using '^' as the first character\nof a basic regular expression is not portable; it is ignored",
      v4);
  memset(&s, 0, sizeof(s));
  memset(pmatch, 0, sizeof(pmatch));
  sub_625E4(&s, *(const char **)(a2 + 8), 0);
  if ( regexec(&s, *(const char **)(a1 + 8), 2u, pmatch, 0) == 1 || pmatch[0].rm_so )
  {
    if ( !s.re_nsub )
    {
      v6 = sub_174DC(0x10u);
      v6[1] = 0;
      goto LABEL_10;
    }
    v5 = "";
  }
  else
  {
    if ( !s.re_nsub || pmatch[1].rm_so < 0 )
    {
      rm_eo = pmatch[0].rm_eo;
      v6 = sub_174DC(0x10u);
      v6[1] = rm_eo;
      goto LABEL_10;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + pmatch[1].rm_eo) = pmatch[0].rm_so;
    v5 = (const char *)(*(_DWORD *)(a1 + 8) + pmatch[1].rm_so);
  }
  v6 = sub_41A3C(v5);
LABEL_10:
  regfree(&s);
  return v6;
}

//----- (00041D30) --------------------------------------------------------
void **sub_41D30()
{
  void **v0; // r4
  void **v2; // r6
  void **v3; // r8

  v0 = (void **)sub_421E4();
  while ( sub_41BC4(":") )
  {
    buf.c_iflag += 4;
    v2 = (void **)sub_421E4();
    v3 = (void **)sub_41C04((int)v0, (int)v2);
    sub_41B9C(v0);
    v0 = v3;
    sub_41B9C(v2);
  }
  return v0;
}

//----- (00041DA0) --------------------------------------------------------
void **sub_41DA0()
{
  void **i; // r4
  const char *v1; // r5
  void **v2; // r11
  signed __int64 v3; // r6

  for ( i = sub_41D30(); ; *((_QWORD *)i + 1) = v3 )
  {
    v1 = sub_41BC4("*");
    if ( !v1 )
    {
      v1 = sub_41BC4("/");
      if ( !v1 )
      {
        v1 = sub_41BC4("%");
        if ( !v1 )
          break;
      }
    }
    buf.c_iflag += 4;
    v2 = sub_41D30();
    v3 = sub_41AD4((int)i, (int)v2, (int)v1);
    sub_41B9C(i);
    sub_41B9C(v2);
    i = (void **)sub_174DC(0x10u);
  }
  return i;
}

//----- (00041E54) --------------------------------------------------------
void **sub_41E54()
{
  void **i; // r4
  const char *v1; // r6
  void **v2; // r10
  signed __int64 v3; // r6

  for ( i = sub_41DA0(); ; *((_QWORD *)i + 1) = v3 )
  {
    v1 = sub_41BC4("+");
    if ( !v1 )
    {
      v1 = sub_41BC4("-");
      if ( !v1 )
        break;
    }
    buf.c_iflag += 4;
    v2 = sub_41DA0();
    v3 = sub_41AD4((int)i, (int)v2, (int)v1);
    sub_41B9C(i);
    sub_41B9C(v2);
    i = (void **)sub_174DC(0x10u);
  }
  return i;
}

//----- (00041EF0) --------------------------------------------------------
_DWORD *sub_41EF0()
{
  _DWORD *i; // r4
  const char *v1; // r9
  void **v2; // r5
  char *v3; // r1
  char *v4; // r1
  __int64 v5; // r0
  __int64 v6; // r2
  bool v7; // cc
  _BOOL4 v8; // r9
  bool v9; // cc
  bool v10; // zf

  for ( i = sub_41E54(); ; *((_QWORD *)i + 1) = v8 )
  {
    v1 = sub_41BC4("<");
    if ( !v1 )
    {
      v1 = sub_41BC4("<=");
      if ( !v1 )
      {
        v1 = sub_41BC4("=");
        if ( !v1 )
        {
          v1 = sub_41BC4("==");
          if ( !v1 )
          {
            v1 = sub_41BC4("!=");
            if ( !v1 )
            {
              v1 = sub_41BC4(">=");
              if ( !v1 )
              {
                v1 = sub_41BC4(">");
                if ( !v1 )
                  break;
              }
            }
          }
        }
      }
    }
    buf.c_iflag += 4;
    v2 = sub_41E54();
    sub_41A6C(i, v3);
    sub_41A6C(v2, v4);
    v5 = *((_QWORD *)i + 1);
    v6 = *((_QWORD *)v2 + 1);
    if ( *i == 1 || *v2 == (void *)1 )
    {
      sub_41A08((char *)i);
      sub_41A08((char *)v2);
      v5 = strcmp((const char *)i[2], (const char *)v2[2]);
      v6 = 0;
    }
    if ( v1 == (const char *)60 )
    {
      v7 = v5 < v6;
      goto LABEL_14;
    }
    if ( v1 == (const char *)121 )
    {
      v9 = v6 < v5;
    }
    else
    {
      v10 = v1 == (const char *)122;
      if ( v1 != (const char *)122 )
        v10 = v1 == (const char *)61;
      if ( v10 )
      {
        v8 = v5 == v6;
        goto LABEL_27;
      }
      if ( v1 == (const char *)94 )
      {
        v8 = v5 != v6;
        goto LABEL_27;
      }
      if ( v1 == (const char *)62 )
      {
        v7 = v6 < v5;
LABEL_14:
        v8 = v7;
        goto LABEL_27;
      }
      v9 = v5 < v6;
    }
    v8 = !v9;
LABEL_27:
    sub_41B9C((void **)i);
    sub_41B9C(v2);
    i = sub_174DC(0x10u);
  }
  return i;
}
// 41F94: variable 'v3' is possibly undefined
// 41F9C: variable 'v4' is possibly undefined

//----- (000420CC) --------------------------------------------------------
void **sub_420CC()
{
  void **v0; // r4
  void **v2; // r5

  v0 = (void **)sub_41EF0();
  while ( sub_41BC4("&") )
  {
    buf.c_iflag += 4;
    v2 = (void **)sub_41EF0();
    if ( sub_419B0((int)v0) || sub_419B0((int)v2) )
    {
      sub_41B9C(v0);
      sub_41B9C(v2);
      v0 = (void **)sub_174DC(0x10u);
      *((_QWORD *)v0 + 1) = 0;
    }
    else
    {
      sub_41B9C(v2);
    }
  }
  return v0;
}

//----- (0004216C) --------------------------------------------------------
void **sub_4216C()
{
  void **v0; // r4
  void **v2; // r5
  void **v3; // r0

  v0 = sub_420CC();
  while ( sub_41BC4("|") )
  {
    buf.c_iflag += 4;
    v2 = sub_420CC();
    if ( sub_419B0((int)v0) )
    {
      sub_41B9C(v0);
    }
    else
    {
      v3 = v2;
      v2 = v0;
      sub_41B9C(v3);
    }
    v0 = v2;
  }
  return v0;
}

//----- (000421E4) --------------------------------------------------------
_DWORD *sub_421E4()
{
  _DWORD *v0; // r4
  const char **v1; // r4
  tcflag_t v2; // r5
  int v3; // r0
  int v4; // r6
  tcflag_t c_iflag; // r3
  const char *v6; // r0
  int v8; // r5
  size_t v9; // r6
  void **v10; // r0
  int v11; // r5
  __int64 *v12; // r6
  void **v13; // r0
  int v14; // r10
  size_t v15; // r6
  _QWORD *v16; // r0
  int v17; // r7
  char *v18; // r1
  char *v19; // r1
  __int64 v20; // r8
  _BOOL4 v21; // r3

  if ( *(_DWORD *)buf.c_iflag )
  {
    v3 = sub_16880("quote", *(char **)buf.c_iflag);
    v4 = v3 + 1;
    if ( v3 != -1 )
    {
      c_iflag = buf.c_iflag;
      buf.c_iflag += 4;
      if ( !v3 )
      {
        v6 = *(const char **)(c_iflag + 4);
        if ( v6 )
        {
          buf.c_iflag = c_iflag + 8;
          return sub_41A3C(v6);
        }
        goto LABEL_6;
      }
      if ( v3 == 1 )
      {
        v8 = sub_421E4();
        sub_41A08((char *)v8);
        v9 = strlen(*(const char **)(v8 + 8));
        v0 = sub_174DC(0x10u);
        v0[2] = v9;
        v0[3] = 0;
        v10 = (void **)v8;
      }
      else
      {
        v11 = sub_421E4();
        switch ( v4 )
        {
          case 3:
            v12 = (__int64 *)sub_421E4();
            v0 = sub_41C04(v11, (int)v12);
            v13 = (void **)v11;
            break;
          case 4:
            v14 = sub_421E4();
            sub_41A08((char *)v11);
            sub_41A08((char *)v14);
            v15 = strcspn(*(const char **)(v11 + 8), *(const char **)(v14 + 8)) + 1;
            v16 = sub_174DC(0x10u);
            v16[1] = v15;
            v0 = v16;
            if ( v15 == strlen(*(const char **)(v11 + 8)) + 1LL )
              *((_QWORD *)v0 + 1) = 0;
            sub_41B9C((void **)v11);
            v10 = (void **)v14;
            goto LABEL_17;
          case 5:
            v17 = sub_421E4();
            v12 = (__int64 *)sub_421E4();
            sub_41A08((char *)v11);
            if ( !sub_41A6C((_DWORD *)v17, v18) || !sub_41A6C(v12, v19) )
              goto LABEL_28;
            v20 = *(_QWORD *)(v17 + 8);
            v21 = strlen(*(const char **)(v11 + 8)) < v20;
            if ( v20 < 1 )
              v21 = 1;
            if ( !v21 && v12[1] >= 1 )
            {
              v0 = sub_1748C(0x10u);
              *v0 = 1;
              v0[2] = sub_1751C((char *)(*(_DWORD *)(v11 + 8) + *(_DWORD *)(v17 + 8) - 1), *((_DWORD *)v12 + 2));
            }
            else
            {
LABEL_28:
              v0 = sub_41A3C("");
            }
            sub_41B9C((void **)v11);
            v13 = (void **)v17;
            break;
          default:
            return v0;
        }
        sub_41B9C(v13);
        v10 = (void **)v12;
      }
LABEL_17:
      sub_41B9C(v10);
      return v0;
    }
  }
  v1 = (const char **)buf.c_iflag;
  if ( !*(_DWORD *)buf.c_iflag )
    goto LABEL_6;
  v2 = buf.c_iflag + 4;
  if ( !sub_41BC4("(") )
  {
    if ( !sub_41BC4(")") )
    {
      buf.c_iflag = v2;
      v6 = *v1;
      return sub_41A3C(v6);
    }
LABEL_6:
    sub_16DBC("syntax error");
  }
  buf.c_iflag = v2;
  v0 = (_DWORD *)sub_4216C();
  if ( !sub_41BC4(")") )
    goto LABEL_6;
  buf.c_iflag += 4;
  return v0;
}
// 422F0: variable 'v0' is possibly undefined
// 423D4: variable 'v18' is possibly undefined
// 42400: variable 'v19' is possibly undefined
// 4216C: using guessed type int sub_4216C(void);

//----- (0004249C) --------------------------------------------------------
void __fastcall __noreturn sub_4249C(int a1, int a2)
{
  void **v2; // r0
  int v3; // r4
  char v4; // r0

  byte_7D5F8 = 2;
  buf.c_iflag = a2 + 4;
  if ( !*(_DWORD *)(a2 + 4) )
    sub_16DBC("too few arguments");
  v2 = sub_4216C();
  v3 = (int)v2;
  if ( *(_DWORD *)buf.c_iflag )
    sub_16DBC("syntax error");
  if ( *v2 )
    puts((const char *)v2[2]);
  else
    printf("%lld\n", *((_QWORD *)v2 + 1));
  v4 = sub_419B0(v3);
  sub_588D8(v4);
}
// 7D5F8: using guessed type char byte_7D5F8;

//----- (0004252C) --------------------------------------------------------
int __fastcall sub_4252C(unsigned __int64 a1)
{
  unsigned __int64 v1; // r4
  int v3; // r8
  unsigned int v4; // r7
  unsigned int v5; // r6
  unsigned __int64 v6; // r0
  __int64 v7; // r2
  int v8; // r3
  int v9; // r0

  v1 = a1;
  if ( a1 > 3 )
  {
    while ( (v1 & 1) == 0 )
    {
      v1 >>= 1;
      printf(" 2");
    }
    v3 = 913;
    v4 = 3;
    v5 = (sub_5A898(v1, HIDWORD(v1)) - 1) | 1;
    while ( 1 )
    {
      LODWORD(v6) = sub_62C44(v1, v4);
      if ( v7 )
        break;
      v1 = v6;
      printf(" %u", v4);
      v9 = sub_5A898(v1, HIDWORD(v1));
      v8 = v3;
      v5 = (v9 - 1) | 1;
LABEL_19:
      v3 = v8;
    }
    while ( v4 < v5 )
    {
      v8 = v3 + 137;
      v4 += 2;
      if ( ((v3 + 137) & 0x844) == 0 )
        goto LABEL_19;
      if ( (((_BYTE)v3 - 119) & 4) != 0 )
        v8 = v3 + 134;
      if ( (v8 & 0x40) != 0 )
        v8 -= 40;
      if ( (v8 & 0x800) != 0 )
        v8 -= 896;
      v3 = v8;
    }
  }
  if ( v1 > 1 )
    printf(" %llu", v1);
  return j_putchar_unlocked(10);
}
// 425CC: variable 'v7' is possibly undefined
// 42608: variable 'v6' is possibly undefined

//----- (00042648) --------------------------------------------------------
int __fastcall sub_42648(const char *a1)
{
  __int64 v1; // r0
  unsigned __int64 v2; // r4

  if ( *a1 == 43 )
    ++a1;
  v1 = sub_188A4(a1, 0, 10);
  v2 = v1;
  if ( *(_DWORD *)dword_7DB94 )
    sub_162F0();
  printf("%llu:", v1);
  return sub_4252C(v2);
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000426AC) --------------------------------------------------------
int __fastcall sub_426AC(int a1, int a2, int a3)
{
  _BYTE *v3; // r0
  void *v4; // r6
  unsigned __int8 *v5; // r4
  unsigned __int8 *v6; // r0
  const char *v7; // r7
  unsigned __int8 *v8; // r0
  int v9; // r4
  unsigned __int8 *v10; // r0
  int v11; // t1

  if ( *(_DWORD *)(a2 + 4) )
  {
    v9 = a2 + 4;
    do
    {
      v10 = sub_60E74(*(unsigned __int8 **)v9);
      sub_42648((const char *)v10);
      v11 = *(_DWORD *)(v9 + 4);
      v9 += 4;
    }
    while ( v11 );
  }
  else
  {
    while ( 1 )
    {
      v3 = sub_58D24((FILE *)stdin, a2, a3);
      v4 = v3;
      if ( !v3 )
        break;
      v5 = v3;
      while ( 1 )
      {
        v6 = sub_60E74(v5);
        v7 = (const char *)v6;
        if ( !*v6 )
          break;
        v8 = sub_60E94(v6);
        v5 = v8;
        if ( *v8 )
        {
          *v8 = 0;
          v5 = v8 + 1;
        }
        sub_42648(v7);
      }
      free(v4);
    }
  }
  return 0;
}
// 426C8: variable 'a2' is possibly undefined
// 426C8: variable 'a3' is possibly undefined
// 7D610: using guessed type int stdin;

//----- (00042748) --------------------------------------------------------
int sub_42748()
{
  return 1;
}

//----- (00042750) --------------------------------------------------------
unsigned int __fastcall sub_42750(int a1, int a2)
{
  int v2; // r3
  int v4; // r0

  v2 = dword_7DBC0 & 1;
  if ( (dword_7DBC0 & 1) != 0 )
    return a1 + 1;
  switch ( a2 )
  {
    case 9:
      return (a1 & 0xFFFFFFF8) + 8;
    case 8:
      v4 = a1 - 1;
      if ( v4 >= 0 )
        return v4;
      break;
    case 13:
      break;
    default:
      return a1 + 1;
  }
  return v2;
}
// 7DBC0: using guessed type int dword_7DBC0;

//----- (000427A4) --------------------------------------------------------
size_t __fastcall sub_427A4(const void *a1, size_t a2)
{
  return fwrite(a1, 1u, a2, (FILE *)stdout);
}
// 7D614: using guessed type int stdout;

//----- (000427BC) --------------------------------------------------------
void __fastcall __noreturn sub_427BC(int a1, char **a2)
{
  char **v3; // r5
  char *v4; // r3
  char *v5; // t1
  char v6; // r8
  unsigned __int8 *v7; // r5
  int *v8; // r7
  FILE *v9; // r10
  size_t v10; // r4
  int v11; // r6
  int v12; // r9
  int v13; // t1
  int v14; // r2
  unsigned int v15; // r0
  _BYTE *v16; // r2
  bool v17; // cc
  int i; // r6
  size_t v19; // r1
  int v20; // r3
  bool v21; // zf
  size_t v22; // r6
  unsigned __int8 *v23; // r1
  unsigned __int8 *v24; // r2
  unsigned __int8 *v25; // r3
  unsigned int v26; // r0
  unsigned int v27; // [sp+0h] [bp-14h]
  unsigned __int8 *v28; // [sp+4h] [bp-10h]
  int v29; // [sp+Ch] [bp-8h] BYREF

  v3 = a2;
  v29 = (int)"80";
  while ( 1 )
  {
    v5 = v3[1];
    ++v3;
    v4 = v5;
    if ( !v5 )
      break;
    if ( *v4 == 45 )
    {
      v14 = (unsigned __int8)v4[1];
      if ( v14 == 45 && !v4[2] )
        break;
      if ( (unsigned int)(v14 - 48) <= 9 )
        *v3 = sub_177E4("-w%s", v4 + 1);
    }
  }
  v6 = 0;
  sub_593CC(a2, "bsw:", &v29);
  v7 = 0;
  v27 = sub_6206C((const char *)v29, 1u, 0x2710u);
  v8 = (int *)&a2[optind];
  if ( !*v8 )
    *--v8 = (int)"-";
  while ( 1 )
  {
    v9 = (FILE *)sub_61CD8(*v8);
    if ( !v9 )
      goto LABEL_12;
LABEL_6:
    v10 = 0;
    v11 = 0;
    while ( 1 )
    {
      v12 = getc_unlocked(v9);
      if ( v12 == -1 )
        break;
      if ( (v10 & 0xFFF) == 0 )
        v7 = (unsigned __int8 *)sub_174B4(v7, v10 + 4096);
      while ( 1 )
      {
        v7[v10] = v12;
        if ( v12 == 10 )
        {
          sub_427A4(v7, v10 + 1);
          goto LABEL_6;
        }
        v15 = sub_42750(v11, (unsigned __int8)v12);
        v11 = v15;
        v17 = v10 != 0;
        if ( v10 )
          v17 = v15 > v27;
        if ( !v17 )
          break;
        if ( (dword_7DBC0 & 2) != 0 )
        {
          for ( i = v10 - 1; ; --i )
          {
            if ( i < 0 )
              goto LABEL_30;
            v20 = v7[i];
            v21 = v20 == 9;
            if ( v20 != 9 )
              v21 = v20 == 32;
            if ( v21 )
              break;
          }
          v22 = i + 1;
          v10 -= v22;
          sub_427A4(v7, v22);
          putchar_unlocked(10);
          v23 = &v7[v22];
          v11 = 0;
          memmove(v7, v23, v10);
          v24 = v7;
          v25 = &v7[v10];
          while ( v24 != v25 )
          {
            v28 = v25;
            v26 = sub_42750(v11, *v24);
            v25 = v28;
            v11 = v26;
          }
        }
        else
        {
LABEL_30:
          v19 = v10 + 1;
          *v16 = 10;
          v10 = 0;
          sub_427A4(v7, v19);
          v11 = 0;
        }
      }
      ++v10;
    }
    if ( v10 )
      sub_427A4(v7, v10);
    if ( sub_5888C(v9) )
    {
      sub_16B80((const char *)*v8);
LABEL_12:
      v6 = 1;
    }
    v13 = v8[1];
    ++v8;
    if ( !v13 )
      sub_588D8(v6);
  }
}
// 42964: variable 'v16' is possibly undefined
// 429D8: variable 'v24' is possibly undefined
// 7D604: using guessed type int optind;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00042A10) --------------------------------------------------------
void __fastcall __noreturn sub_42A10(int a1, int a2)
{
  int v2; // r5
  int v3; // r4
  char *const *v4; // r8
  int v5; // r6
  const char *v6; // r0
  unsigned int v7; // r7
  int v8; // r0
  int v9; // r3
  int *v10; // r5
  const char *v11; // r9
  int v12; // r0
  FILE *v13; // r8
  int v14; // r11
  _BYTE *v15; // r10
  char *v16; // r9
  int v17; // r0
  int v18; // r9
  int v19; // r0
  void *v20; // r0
  int v21; // t1
  char *v22; // r0
  int v23; // r1
  int v24; // r2
  int v25; // r11
  char *v26; // r10
  _DWORD *v27; // r9
  char *v28; // r3
  void *v29; // r0
  int v30; // r11
  int v31; // r1
  int v32; // r2
  void *v33; // r1
  void *v34; // r0
  void *v35; // t1
  int v36; // r0
  int v37; // r3
  unsigned int v38; // r9
  int v39; // [sp+4h] [bp-20h]
  size_t v40; // [sp+8h] [bp-1Ch]
  char v41; // [sp+Ch] [bp-18h]
  size_t v42; // [sp+10h] [bp-14h]
  char *v43; // [sp+18h] [bp-Ch]
  int v44; // [sp+18h] [bp-Ch]
  void *ptr; // [sp+1Ch] [bp-8h]
  void *ptra; // [sp+1Ch] [bp-8h]

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = (char *const *)a2;
  if ( v3 )
  {
    if ( *(_BYTE *)v3 == 45 && (unsigned int)*(unsigned __int8 *)(v3 + 1) - 48 <= 9 )
    {
      v4 = (char *const *)(a2 + 4);
      v5 = 1;
      v2 = a1 - 1;
      v6 = (const char *)(v3 + 1);
      v3 = 0;
      v39 = 0;
      while ( 1 )
      {
        if ( *v6 == 45 )
        {
          ++v6;
          v3 = 1;
        }
        v7 = sub_62090(v6, (int)&unk_64174);
        while ( 1 )
        {
LABEL_8:
          v8 = getopt(v2, v4, "n:c:qv");
          if ( v8 <= 0 )
          {
            v9 = v2 - optind;
            v10 = (int *)&v4[optind];
            if ( !*v10 )
              *--v10 = (int)"-";
            if ( v5 >= v9 )
              v5 = 0;
            if ( ((unsigned __int8)v3 & (v7 > 0x1FFFFFFE)) != 0 )
              sub_16DDC("count is too big: %lu", v7);
            v11 = "==> %s <==\n";
            v40 = v7 + 1;
            v42 = v7 + 1;
            v41 = 0;
            while ( 2 )
            {
              v12 = sub_61CD8(*v10);
              v13 = (FILE *)v12;
              if ( v12 )
              {
                if ( stdin == v12 )
                  *v10 = (int)"standard input";
                if ( v5 )
                  printf(v11, *v10);
                if ( v3 )
                {
                  if ( v39 )
                  {
                    v14 = 0;
                    v15 = sub_1748C(v40);
                    v16 = v15 - 1;
                    do
                    {
                      v17 = getc_unlocked(v13);
                      if ( v17 == -1 )
                        goto LABEL_43;
                      ++v14;
                      *++v16 = v17;
                    }
                    while ( v14 != v40 );
                    v18 = 0;
                    while ( 1 )
                    {
                      putchar_unlocked((unsigned __int8)v15[v18]);
                      v19 = getc_unlocked(v13);
                      if ( v19 == -1 )
                        break;
                      v15[v18++] = v19;
                      if ( v14 == v18 )
                        v18 = 0;
                    }
LABEL_43:
                    v20 = v15;
                  }
                  else
                  {
                    v22 = (char *)sub_174DC(v42 * 4);
                    v25 = 0;
                    v26 = v22 - 4;
                    v27 = v22;
                    v28 = v22 - 4;
                    do
                    {
                      v43 = v28;
                      v29 = sub_58D10(v13, v23, v24);
                      if ( !v29 )
                        goto LABEL_58;
                      v24 = v7 + 1;
                      ++v25;
                      *((_DWORD *)v43 + 1) = v29;
                      v28 = v43 + 4;
                    }
                    while ( v40 != v25 );
                    v30 = 0;
                    while ( 1 )
                    {
                      v44 = v30;
                      ptr = (void *)v27[v30];
                      fputs_unlocked(ptr, stdout);
                      v33 = sub_58D10(v13, v31, v32);
                      if ( !v33 )
                        break;
                      v34 = ptr;
                      ptra = v33;
                      free(v34);
                      ++v30;
                      v27[v44] = ptra;
                      if ( v40 == v30 )
                        v30 = 0;
                    }
                    do
                    {
LABEL_58:
                      v35 = (void *)*((_DWORD *)v26 + 1);
                      v26 += 4;
                      free(v35);
                    }
                    while ( v26 != (char *)&v27[v42 - 1] );
                    v20 = v27;
                  }
                  free(v20);
                }
                else
                {
                  v38 = v7;
                  while ( v38 )
                  {
                    v36 = getc_unlocked(v13);
                    if ( v36 == -1 )
                      break;
                    v37 = v39;
                    if ( v36 == 10 )
                      v37 = v39 | 1;
                    if ( v37 )
                      --v38;
                    putchar_unlocked(v36);
                  }
                }
                sub_177C0();
                if ( sub_5888C(v13) )
                {
                  sub_16B80((const char *)*v10);
                  goto LABEL_47;
                }
              }
              else
              {
LABEL_47:
                v41 = 1;
              }
              v21 = v10[1];
              ++v10;
              v11 = "\n==> %s <==\n";
              if ( !v21 )
                sub_588D8(v41);
              continue;
            }
          }
          if ( v8 == 110 )
            goto LABEL_39;
          if ( v8 <= 110 )
            break;
          if ( v8 == 113 )
          {
            v5 = 0x7FFFFFFF;
          }
          else
          {
            if ( v8 != 118 )
              goto LABEL_34;
            v5 = -1;
          }
        }
        if ( v8 != 99 )
LABEL_34:
          sub_162F0();
        v39 = 1;
LABEL_39:
        v6 = (const char *)optarg;
      }
    }
    v3 = 0;
  }
  v39 = v3;
  v5 = 1;
  v7 = 10;
  goto LABEL_8;
}
// 42C80: variable 'v23' is possibly undefined
// 42C80: variable 'v24' is possibly undefined
// 42CCC: variable 'v31' is possibly undefined
// 42CCC: variable 'v32' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7D610: using guessed type int stdin;
// 7D614: using guessed type int stdout;
// 7D618: using guessed type int optarg;

//----- (00042D90) --------------------------------------------------------
int __fastcall sub_42D90(int a1, int a2)
{
  int v2; // r0

  if ( *(_DWORD *)(a2 + 4) )
    sub_162F0();
  v2 = gethostid();
  printf("%08x\n", v2);
  return sub_177D8();
}

//----- (00042DC0) --------------------------------------------------------
int __fastcall sub_42DC0(const char *a1, __gid_t a2, __gid_t list[], int *a4)
{
  int result; // r0

  if ( a1 )
  {
    result = getgrouplist(a1, a2, list, a4);
    if ( *a4 < 0 )
      return 0;
  }
  else
  {
    result = getgroups(*a4, list);
    *a4 = result;
    if ( result < 0 )
    {
      if ( *(_DWORD *)dword_7DB94 == 22 )
        *a4 = getgroups(0, list);
      return -(*a4 >= 0);
    }
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00042E3C) --------------------------------------------------------
int __fastcall sub_42E3C(int a1, int a2, const char *a3)
{
  unsigned int v5; // r3
  int result; // r0

  if ( a3 )
    printf("%s", a3);
  v5 = ((dword_7DBC0 ^ 2u) >> 1) & 1;
  if ( !a2 )
    v5 = 1;
  if ( v5 )
    printf("%u", a1);
  if ( dword_7DBC0 )
  {
    result = dword_7DBC0 & 2;
    if ( (dword_7DBC0 & 2) == 0 )
      return result;
    if ( !a2 )
      return 1;
    printf("%s", a2);
  }
  else if ( a2 )
  {
    printf("(%s)", a2);
  }
  return 0;
}
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00042EE0) --------------------------------------------------------
int __fastcall sub_42EE0(__uid_t a1, const char *a2)
{
  struct passwd *v4; // r0

  v4 = sub_57AEC(a1);
  return sub_42E3C(a1, (int)v4, a2);
}

//----- (00042F04) --------------------------------------------------------
int __fastcall sub_42F04(__gid_t a1, const char *a2)
{
  struct group *v4; // r0

  v4 = sub_57B00(a1);
  return sub_42E3C(a1, (int)v4, a2);
}

//----- (00042F28) --------------------------------------------------------
int __fastcall sub_42F28(int a1, char **a2, int a3)
{
  int v4; // r8
  const char *v5; // r10
  struct passwd *v6; // r0
  __uid_t pw_uid; // r6
  __gid_t pw_gid; // r5
  __uid_t v9; // r9
  __gid_t v10; // r7
  int v11; // r4
  int v12; // r4
  __uid_t v13; // r0
  int v14; // r4
  const char *v15; // r1
  void *v16; // r6
  __gid_t v18; // r0
  bool v19; // zf
  const char *v20; // r1
  int i; // r10
  char v22; // r0
  int v23[2]; // [sp+4h] [bp-8h] BYREF

  v23[0] = (int)a2;
  v23[1] = a3;
  v4 = sub_593CC(a2, "^rnugG");
  v5 = a2[optind];
  if ( v5 )
  {
    v6 = sub_57A70(a2[optind]);
    pw_uid = v6->pw_uid;
    pw_gid = v6->pw_gid;
    if ( !v4 )
    {
      v11 = sub_42EE0(v6->pw_uid, "uid=");
      v10 = pw_gid;
      v9 = pw_uid;
      v12 = v11 | sub_42F04(pw_gid, " gid=");
      goto LABEL_14;
    }
    v9 = v6->pw_uid;
    v10 = v6->pw_gid;
LABEL_6:
    LOBYTE(v12) = v4 & 0x10;
    if ( (v4 & 0x10) == 0 )
    {
      if ( (v4 & 1) == 0 )
      {
        pw_gid = v10;
        pw_uid = v9;
      }
LABEL_31:
      if ( (v4 & 4) != 0 )
      {
        v22 = sub_42EE0(pw_uid, 0);
      }
      else
      {
        if ( (v4 & 8) == 0 )
        {
LABEL_34:
          j_putchar_unlocked(10);
          sub_588D8(v12);
        }
        v22 = sub_42F04(pw_gid, 0);
      }
      LOBYTE(v12) = v12 | v22;
      goto LABEL_34;
    }
    v12 = sub_42F04(pw_gid, 0);
    if ( v10 != pw_gid )
    {
      v15 = " ";
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  v10 = getegid();
  pw_gid = getgid();
  v9 = geteuid();
  v13 = getuid();
  pw_uid = v13;
  if ( v4 )
    goto LABEL_6;
  v14 = sub_42EE0(v13, "uid=");
  v12 = v14 | sub_42F04(pw_gid, " gid=");
  if ( v9 != pw_uid )
    v12 |= sub_42EE0(v9, " euid=");
  if ( v10 != pw_gid )
  {
    v15 = " egid=";
LABEL_21:
    v12 |= sub_42F04(v10, v15);
  }
LABEL_14:
  v23[0] = 64;
  v16 = sub_1748C(0x100u);
  if ( sub_42DC0(v5, pw_gid, (__gid_t *)v16, v23) < 0 )
  {
    v16 = sub_174B4(v16, 4 * v23[0]);
    sub_42DC0(v5, pw_gid, (__gid_t *)v16, v23);
  }
  if ( v23[0] > 0 )
  {
    v20 = " groups=";
    for ( i = 0; ; ++i )
    {
      if ( v23[0] <= i )
        goto LABEL_30;
      v18 = *((_DWORD *)v16 + i);
      if ( !v4 )
        goto LABEL_27;
      v19 = v18 == v10;
      if ( v18 != v10 )
        v19 = v18 == pw_gid;
      if ( !v19 )
        break;
LABEL_28:
      ;
    }
    v20 = " ";
LABEL_27:
    v12 |= sub_42F04(v18, v20);
    v20 = ",";
    goto LABEL_28;
  }
  if ( !v23[0] )
  {
LABEL_30:
    pw_gid = v10;
    pw_uid = v9;
    goto LABEL_31;
  }
  return 1;
}
// 7D604: using guessed type int optind;

//----- (00043180) --------------------------------------------------------
int __fastcall sub_43180(int a1, char **a2)
{
  int v3; // r5
  const char **v4; // r6
  int result; // r0

  sub_593CC(a2, "^");
  v3 = optind;
  v4 = (const char **)&a2[optind];
  result = link(*v4, v4[1]);
  if ( result )
    sub_16B40("can't create %slink '%s' to '%s'", "hard", v4[1], a2[v3]);
  return result;
}
// 7D604: using guessed type int optind;

//----- (000431D8) --------------------------------------------------------
int __fastcall sub_431D8(int a1, char **a2)
{
  unsigned int v4; // r0
  char *v5; // r7
  const char **v6; // r4
  int v7; // r5
  char v8; // r6
  char *v9; // r0
  int v10; // r9
  int (*v11)(const char *, const char *); // r3
  char *v12; // r8
  char *v13; // r5
  char *v14; // r0
  char *v15; // r0
  const char *v16; // r5
  char *v17; // r0
  char *v19; // r10
  int v20; // [sp+0h] [bp-84h]
  int (__fastcall *v21)(const char *, const char *); // [sp+8h] [bp-7Ch]
  char *v22; // [sp+14h] [bp-70h] BYREF
  int v23; // [sp+28h] [bp-5Ch]

  v22 = "~";
  v4 = sub_593CC(a2, "^sfnbS:vT", &v22);
  v5 = (&a2[a1])[-1];
  v6 = (const char **)&a2[optind];
  v20 = v4 & 0x40;
  if ( a1 - optind > 2 )
    v7 = (v4 >> 6) & 1;
  else
    v7 = 0;
  if ( v7 )
    sub_16DBC("-T accepts 2 args max");
  v8 = v4;
  if ( !v6[1] )
  {
    *(v6 - 1) = v5;
    v9 = sub_174F8(v5);
    --v6;
    v5 = sub_16A54(v9);
  }
  v10 = 0;
  v11 = link;
  if ( (v8 & 1) != 0 )
    v11 = symlink;
  v21 = v11;
  do
  {
    v12 = (char *)sub_5A854((int)v5, ~v8 & 4);
    if ( v12 )
    {
      if ( v20 )
        sub_16DBC("'%s' is a directory", v5);
      v13 = sub_174F8(*v6);
      v14 = sub_16A54(v13);
      v12 = sub_16998(v5, v14);
      v15 = v13;
      v16 = v12;
      free(v15);
    }
    else
    {
      v16 = v5;
    }
    if ( (v8 & 1) == 0 && sub_62DFC() && (sub_62E14() || (v23 & 0xF000) != 0xA000) )
    {
      sub_16B80(*v6);
      v17 = v12;
LABEL_20:
      v10 = 1;
      free(v17);
      goto LABEL_21;
    }
    if ( (v8 & 8) != 0 )
    {
      v19 = sub_177E4("%s%s", v16, v22);
      if ( rename(v16, v19) < 0 && *(_DWORD *)dword_7DB94 != 2 )
      {
        sub_16B80(v16);
        v17 = v19;
        goto LABEL_20;
      }
      free(v19);
    }
    else if ( (v8 & 2) == 0 )
    {
      goto LABEL_31;
    }
    unlink(v16);
LABEL_31:
    if ( (v8 & 0x20) != 0 )
      printf("'%s' -> '%s'\n", v16, *v6);
    if ( v21(*v6, v16) )
    {
      v10 = 1;
      sub_16B80(v16);
    }
    free(v12);
LABEL_21:
    ++v6;
  }
  while ( v6[1] );
  return v10;
}
// 4322C: masking with 0x1 was optimized away because r3.4 <= 0x1
// 7D604: using guessed type int optind;
// 7DB94: using guessed type int dword_7DB94;

//----- (0004344C) --------------------------------------------------------
int __fastcall sub_4344C(int a1, int a2)
{
  char v3[68]; // [sp+0h] [bp-44h] BYREF

  if ( *(_DWORD *)(a2 + 4) )
    sub_162F0();
  if ( getlogin_r(v3, 0x40u) )
    sub_16B40("getlogin");
  puts(v3);
  return sub_177D8();
}

//----- (00043498) --------------------------------------------------------
int __fastcall sub_43498(unsigned __int16 a1)
{
  if ( (dword_7DBC0 & 0x3000) == 0 )
    return 0;
  if ( (a1 & 0xF000) == 0x4000 )
    return 47;
  if ( (dword_7DBC0 & 0x1000) == 0 )
    return 0;
  if ( (a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0 )
    return 42;
  return byte_69AE3[a1 >> 12];
}
// 69AE3: using guessed type unsigned __int8 byte_69AE3[51];
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00043504) --------------------------------------------------------
int __fastcall sub_43504(int a1, int a2)
{
  int v3; // r3
  int result; // r0
  _BYTE *v5; // r2
  int v6; // r2

  if ( !a1 )
    return 0;
  v3 = 0;
  result = 0;
  while ( 1 )
  {
    v6 = *(_DWORD *)(a1 + 4 * v3);
    if ( !v6 )
      break;
    ++v3;
    if ( (*(_DWORD *)(v6 + 24) & 0xF000) == 0x4000 )
    {
      v5 = *(_BYTE **)v6;
      if ( a2 != 2 || *v5 != 46 || v5[1] && (v5[1] != 46 || v5[2]) )
        ++result;
    }
  }
  if ( !a2 )
    return v3 - result;
  return result;
}

//----- (00043588) --------------------------------------------------------
void *__fastcall sub_43588(void *result)
{
  if ( result )
    return sub_174DC(4 * ((_DWORD)result + 1));
  return result;
}

//----- (0004359C) --------------------------------------------------------
_DWORD *__fastcall sub_4359C(int a1, int a2)
{
  void *v4; // r0
  _DWORD *result; // r0
  int v6; // r3
  int v7; // r2
  int v8; // r12
  int v9; // t1
  _BYTE *v10; // r1

  if ( a1 )
  {
    v4 = (void *)sub_43504(a1, a2);
    result = sub_43588(v4);
    v6 = a1 - 4;
    v7 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = *(_DWORD *)(v6 + 4);
        v6 += 4;
        v8 = v9;
        if ( !v9 )
          return result;
        if ( (*(_DWORD *)(v8 + 24) & 0xF000) == 0x4000 )
          break;
        if ( !a2 )
          goto LABEL_11;
      }
      if ( a2 )
      {
        v10 = *(_BYTE **)v8;
        if ( a2 == 1 || *v10 != 46 || v10[1] && (v10[1] != 46 || v10[2]) )
LABEL_11:
          result[v7++] = v8;
      }
    }
  }
  return 0;
}

//----- (0004363C) --------------------------------------------------------
_DWORD *__fastcall sub_4363C(const char *a1, int a2, int a3)
{
  _DWORD *v6; // r4
  void *v7; // r0
  int v9; // r3
  int v10; // [sp+10h] [bp-5Ch]
  int v11; // [sp+14h] [bp-58h]
  int v12; // [sp+18h] [bp-54h]
  int v13; // [sp+1Ch] [bp-50h]
  unsigned __int64 v14; // [sp+20h] [bp-4Ch]
  __int64 v15; // [sp+30h] [bp-3Ch]
  __int64 v16; // [sp+40h] [bp-2Ch]
  int v17; // [sp+48h] [bp-24h]
  int v18; // [sp+50h] [bp-1Ch]
  int v19; // [sp+58h] [bp-14h]
  __int64 v20; // [sp+60h] [bp-Ch]

  v6 = sub_174DC(0x58u);
  *v6 = a2;
  v6[1] = a1;
  if ( dword_7DBC0 & 0x800000 | a3 )
  {
    if ( sub_62DFC() )
    {
LABEL_3:
      sub_16B80(a1);
      v7 = v6;
      v6 = 0;
      buf.c_oflag = 1;
      free(v7);
      return v6;
    }
    v6[5] = v10;
  }
  else
  {
    if ( sub_62E14() )
      goto LABEL_3;
    v6[4] = v10;
  }
  v6[6] = v10;
  *((_QWORD *)v6 + 4) = v15;
  v6[10] = v18;
  v9 = dword_7DBC0;
  if ( (dword_7DBC0 & 0x40000) != 0 )
    v6[10] = v17;
  if ( (v9 & 0x10000) != 0 )
    v6[10] = v19;
  *((_QWORD *)v6 + 6) = v20;
  *((_QWORD *)v6 + 7) = v16;
  v6[16] = v11;
  v6[17] = v12;
  v6[18] = v13;
  v6[19] = gnu_dev_major(v14);
  v6[20] = gnu_dev_minor(v14);
  return v6;
}
// 436CC: variable 'v10' is possibly undefined
// 436DC: variable 'v15' is possibly undefined
// 436E4: variable 'v18' is possibly undefined
// 43700: variable 'v17' is possibly undefined
// 4370C: variable 'v19' is possibly undefined
// 43714: variable 'v20' is possibly undefined
// 4371C: variable 'v16' is possibly undefined
// 43724: variable 'v11' is possibly undefined
// 4372C: variable 'v12' is possibly undefined
// 43734: variable 'v13' is possibly undefined
// 43738: variable 'v14' is possibly undefined
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00043784) --------------------------------------------------------
int __fastcall sub_43784(_BYTE *a1)
{
  const char *v1; // r0
  int v2; // r4
  int v4; // r4
  const char *v5; // r5
  int v6; // r3
  int v7; // t1
  bool v8; // zf
  int v9; // [sp+4h] [bp-10h] BYREF
  int v10; // [sp+Ch] [bp-8h]

  v1 = sub_5E5D0(&v9, a1);
  if ( (dword_7DBC0 & 0x8000) != 0 )
  {
    v4 = v10;
    v5 = v1 - 1;
    putchar_unlocked(34);
    v2 = v4 + 2;
    while ( 1 )
    {
      v7 = *(unsigned __int8 *)++v5;
      v6 = v7;
      if ( !v7 )
        break;
      v8 = v6 == 92;
      if ( v6 != 92 )
        v8 = v6 == 34;
      if ( v8 )
      {
        ++v2;
        putchar_unlocked(92);
      }
      putchar_unlocked(*(unsigned __int8 *)v5);
    }
    putchar_unlocked(34);
  }
  else
  {
    fputs_unlocked(v1, stdout);
    return v10;
  }
  return v2;
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00043820) --------------------------------------------------------
void __fastcall sub_43820(void *a1, size_t a2)
{
  qsort(a1, a2, 4u, (__compar_fn_t)sub_43830);
}

//----- (00043830) --------------------------------------------------------
int __fastcall sub_43830(int *a1, int **a2)
{
  int *v2; // r6
  int v3; // r5
  int v4; // r4
  int v5; // r1
  int v6; // r8
  __int64 v7; // r2
  int result; // r0
  const char *v9; // r0
  int v10; // r7
  int v11; // r0
  const char *v12; // r8
  const char *v13; // r0

  v2 = *a2;
  v3 = *a1;
  v4 = dword_7DBC0;
  if ( (dword_7DBC0 & 0x8000000) == 0
    || ((v2[6] & 0xF000) == 0x4000
      ? (v5 = (*(_DWORD *)(v3 + 24) & 0xF000) != 0x4000)
      : (v5 = -((*(_DWORD *)(v3 + 24) & 0xF000) == 0x4000)),
        (v6 = v5) == 0) )
  {
    if ( (dword_7DBC0 & 0x80000) != 0 )
    {
      v7 = *((_QWORD *)v2 + 4) - *(_QWORD *)(v3 + 32);
    }
    else
    {
      if ( (dword_7DBC0 & 0x20000) != 0 )
      {
        LODWORD(v7) = v2[10] - *(_DWORD *)(v3 + 40);
      }
      else
      {
        v9 = *(const char **)v3;
        v10 = *v2;
        if ( (dword_7DBC0 & 0x400000) != 0 )
        {
          v11 = strverscmp(v9, *v2);
        }
        else
        {
          if ( (dword_7DBC0 & 0x100000) == 0 )
          {
LABEL_10:
            v6 = strcmp(*(const char **)v3, (const char *)*v2);
            goto LABEL_11;
          }
          v12 = (const char *)strchrnul(v9, 46);
          v13 = (const char *)strchrnul(v10, 46);
          v11 = strcmp(v12, v13);
        }
        LODWORD(v7) = v11;
      }
      v7 = (int)v7;
    }
    if ( v7 )
    {
      v6 = HIDWORD(v7) | 1;
      goto LABEL_11;
    }
    goto LABEL_10;
  }
LABEL_11:
  result = v6;
  if ( (v4 & 0x200000) != 0 )
    return -v6;
  return result;
}
// 134BC: using guessed type int __fastcall strverscmp(_DWORD, _DWORD);
// 13624: using guessed type int __fastcall strchrnul(_DWORD, _DWORD);
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00043940) --------------------------------------------------------
int __fastcall sub_43940(int a1)
{
  __int16 v2; // r1
  int v3; // r9
  int v4; // r6
  int v5; // r7
  _BYTE *v6; // r8
  int v7; // r5
  char *v8; // r0
  int v9; // r10
  const char *v10; // r0
  int v11; // r1
  const char *v12; // r5
  int v13; // r2
  int v14; // r0
  const char *v15; // r5
  int v16; // r0
  const char *v17; // r5
  const time_t *v18; // r0
  struct tm *v19; // r0
  int v20; // r10
  int v21; // r1
  int v22; // r2
  int v23; // r5
  int v24; // r6
  int v25; // r10
  int v26; // r1
  int v27; // r2
  bool v28; // zf
  int v30; // r1
  int v31; // r10
  int v32; // r2
  unsigned __int64 v33; // r0
  char *v34; // r0
  char *v35; // r0
  const char *v36; // r11
  const char *v37; // r10
  char v38[16]; // [sp+0h] [bp-6Ch] BYREF
  int v39; // [sp+10h] [bp-5Ch]

  v3 = sub_43498(*(_DWORD *)(a1 + 24));
  v4 = dword_7DBC0;
  v5 = dword_7DBC0 & 0x20;
  if ( (dword_7DBC0 & 0x20) != 0 && (v2 & 0xF000) == 0xA000 )
    v6 = sub_17C9C(*(const char **)(a1 + 4));
  else
    v6 = 0;
  v7 = v4 & 8;
  if ( (v4 & 8) != 0 )
    v7 = printf("%7llu ", *(_QWORD *)(a1 + 48));
  if ( (v4 & 0x100) != 0 )
    v7 += printf("%6llu ", *(__int64 *)(a1 + 56) >> 1);
  if ( v5 )
  {
    v8 = sub_5DA78(*(_DWORD *)(a1 + 24));
    v9 = printf("%-10s ", v8);
    v10 = (const char *)(v9 + printf("%4lu ", *(_DWORD *)(a1 + 64)));
    v12 = &v10[v7];
    if ( (v4 & 0x80) != 0 )
    {
      v13 = *(_DWORD *)(a1 + 72);
      if ( (v4 & 0x40) != 0 )
        v10 = "%-8u ";
      else
        v11 = *(_DWORD *)(a1 + 68);
      if ( (v4 & 0x40) != 0 )
        v14 = printf(v10, *(_DWORD *)(a1 + 72), v13);
      else
        v14 = printf("%-8u %-8u ", v11, v13);
    }
    else if ( (v4 & 0x40) != 0 )
    {
      v30 = sub_5E8A8(*(_DWORD *)(a1 + 72));
      v14 = printf("%-8.8s ", v30);
    }
    else
    {
      v31 = sub_5E890(*(_DWORD *)(a1 + 68));
      v32 = sub_5E8A8(*(_DWORD *)(a1 + 72));
      v14 = printf("%-8.8s %-8.8s ", v31, v32);
    }
    v15 = &v12[v14];
    if ( (*(_DWORD *)(a1 + 24) & 0xB000) == 0x2000 )
    {
      v16 = printf("%4u, %3u ", *(_DWORD *)(a1 + 76), *(_DWORD *)(a1 + 80));
    }
    else
    {
      v33 = *(_QWORD *)(a1 + 32);
      if ( (v4 & 0x2000000) != 0 )
      {
        v34 = sub_5A318(v33, 1u, 0);
        v16 = printf("%7s ", v34);
      }
      else
      {
        v16 = printf("%9llu ", v33);
      }
    }
    v17 = &v15[v16];
    v18 = (const time_t *)(a1 + 40);
    if ( (v4 & 0x4000000) != 0 )
    {
      v19 = localtime(v18);
      strftime(v38, 0x1Du, "%Y-%m-%d %H:%M:%S %z", v19);
      v7 = (int)&v17[printf("%s ", v38)];
    }
    else
    {
      v35 = ctime(v18);
      v36 = v35 + 4;
      if ( buf.c_lflag - *(_DWORD *)(a1 + 40) + 899 > 0xF09D42 )
      {
        v37 = v35 + 20;
        *strchr(v35 + 20, 10) = 32;
        printf("%.7s%6s", v36, v37);
      }
      else
      {
        printf("%.12s ", v35 + 4);
      }
      v7 = (int)(v17 + 13);
    }
  }
  if ( buf.c_iflag )
  {
    v20 = *(_DWORD *)(a1 + 16);
    if ( !v20 && !sub_62E14() )
      LOWORD(v20) = v39;
    if ( (v20 & 0xF000) == 0x8000 && (v20 & 0x49) != 0 )
    {
      v21 = 1;
    }
    else
    {
      v21 = byte_69AE3[((unsigned __int16)v20 >> 12) + 17];
      if ( (v20 & 0xF000) != 0x8000 )
        goto LABEL_29;
    }
    if ( (v20 & 0x49) != 0 )
    {
      v22 = 32;
LABEL_30:
      printf("\x1B[%u;%um", v21, v22);
      goto LABEL_31;
    }
LABEL_29:
    v22 = byte_69AE3[((unsigned __int16)v20 >> 12) + 34];
    goto LABEL_30;
  }
LABEL_31:
  v23 = v7 + sub_43784(*(_BYTE **)a1);
  if ( buf.c_iflag )
    printf("\x1B[m");
  v24 = v4 & 0x3000;
  if ( v6 )
  {
    printf(" -> ");
    if ( !v24 && !buf.c_iflag )
      goto LABEL_47;
    v25 = *(_DWORD *)(a1 + 20);
    if ( !v25 && !sub_62DFC() )
      LOWORD(v25) = v39;
    v3 = sub_43498(v25);
    if ( !buf.c_iflag )
      goto LABEL_47;
    if ( (v25 & 0xF000) == 0x8000 && (v25 & 0x49) != 0 )
    {
      v26 = 1;
    }
    else
    {
      v26 = byte_69AE3[((unsigned __int16)v25 >> 12) + 17];
      if ( (v25 & 0xF000) != 0x8000 )
        goto LABEL_45;
    }
    if ( (v25 & 0x49) != 0 )
    {
      v27 = 32;
LABEL_46:
      printf("\x1B[%u;%um", v26, v27);
LABEL_47:
      v23 += sub_43784(v6) + 4;
      free(v6);
      if ( buf.c_iflag )
        printf("\x1B[m");
      goto LABEL_49;
    }
LABEL_45:
    v27 = byte_69AE3[((unsigned __int16)v25 >> 12) + 34];
    goto LABEL_46;
  }
LABEL_49:
  v28 = v3 == 0;
  if ( v3 )
    v28 = v24 == 0;
  if ( !v28 )
  {
    ++v23;
    putchar_unlocked(v3);
  }
  return v23;
}
// 4396C: variable 'v2' is possibly undefined
// 43A18: variable 'v11' is possibly undefined
// 69AE3: using guessed type unsigned __int8 byte_69AE3[51];
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00043D70) --------------------------------------------------------
unsigned int __fastcall sub_43D70(unsigned int result, unsigned int a2)
{
  unsigned int v3; // r4
  unsigned int v4; // r5
  unsigned int v5; // r5
  int v6; // r4
  const char *v7; // r0
  unsigned int v8; // r3
  const char *v9; // r0
  _BYTE **v10; // r3
  _BYTE **v11; // t1
  int v12; // r2
  int v13; // r9
  int v14; // r10
  unsigned int i; // r8
  bool v16; // zf
  int v17; // r2
  int v18; // t1
  unsigned int v19; // r11
  int v20; // r1
  unsigned int v21; // r3
  unsigned int v22; // [sp+0h] [bp-24h]
  unsigned int v23; // [sp+4h] [bp-20h]
  unsigned int v24; // [sp+8h] [bp-1Ch]
  unsigned int v25; // [sp+Ch] [bp-18h]
  int v26; // [sp+14h] [bp-10h] BYREF
  unsigned int v27; // [sp+1Ch] [bp-8h]

  v24 = result;
  v3 = dword_7DBC0 & 0x30;
  if ( (dword_7DBC0 & 0x30) != 0 )
  {
    v5 = a2;
    v22 = 0;
LABEL_4:
    v6 = 1;
    goto LABEL_16;
  }
  v4 = result - 4;
  while ( 1 )
  {
    v11 = *(_BYTE ***)(v4 + 4);
    v4 += 4;
    v10 = v11;
    if ( !v11 )
      break;
    v7 = sub_5E5D0(&v26, *v10);
    v8 = v27;
    if ( (dword_7DBC0 & 0x8000) != 0 )
    {
      v9 = v7 - 1;
      v8 = v27 + 2;
      while ( 1 )
      {
        v18 = *(unsigned __int8 *)++v9;
        v17 = v18;
        if ( !v18 )
          break;
        v16 = v17 == 92;
        if ( v17 != 92 )
          v16 = v17 == 34;
        if ( v16 )
          ++v8;
      }
    }
    if ( v3 < v8 )
      v3 = v8;
  }
  if ( (dword_7DBC0 & 0x100) != 0 )
    v12 = 5;
  else
    v12 = 0;
  v22 = (dword_7DBC0 & 8) + 2 + v12 + v3;
  result = sub_15CA0(0x50u, v22);
  v6 = result;
  if ( result <= 1 )
  {
    v5 = a2;
    goto LABEL_4;
  }
  result = sub_15CA0(a2, result);
  v5 = result;
  if ( result * v6 < a2 )
    v5 = result + 1;
LABEL_16:
  v13 = 0;
  v14 = v6;
  for ( i = 0; v5 != i; ++i )
  {
    v19 = v14 - v6;
    v20 = 0;
    v23 = i;
    do
    {
      v21 = v23;
      if ( (dword_7DBC0 & 0x200) != 0 )
        v21 = v19;
      if ( v21 < a2 )
      {
        if ( v20 )
        {
          v25 = v21;
          printf("%*s", v13 - v20, "");
          v21 = v25;
          v20 = v13;
        }
        v13 = v20 + v22;
        v20 += sub_43940(*(_DWORD *)(v24 + 4 * v21));
      }
      ++v19;
      v23 += v5;
    }
    while ( v14 != v19 );
    result = putchar_unlocked(10);
    v14 += v6;
  }
  return result;
}
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00043F1C) --------------------------------------------------------
void __fastcall sub_43F1C(int a1, int a2)
{
  _DWORD *v3; // r7
  int v4; // t1
  const char *v5; // r9
  DIR *v6; // r11
  char *v7; // r10
  char *v8; // r0
  _DWORD *v9; // r0
  int v10; // r0
  char *v11; // r0
  char *v12; // r10
  void *v13; // r9
  char *v14; // r3
  _DWORD *v15; // r4
  _DWORD *v16; // r5
  size_t v17; // r1
  int v18; // r4
  int v19; // t1
  char *v20; // r5

  v3 = (_DWORD *)(a1 - 4);
  while ( 1 )
  {
    v4 = v3[1];
    ++v3;
    if ( !v4 )
      break;
    if ( buf.c_cflag || (dword_7DBC0 & 0x4000) != 0 )
    {
      if ( !a2 )
        j_putchar_unlocked(10);
      a2 = 0;
      printf("%s:\n", *(const char **)(*v3 + 4));
    }
    v5 = *(const char **)(*v3 + 4);
    v6 = sub_17954(v5);
    if ( v6 )
    {
      v20 = 0;
      v15 = 0;
      while ( 1 )
      {
        v10 = readdir64(v6);
        if ( !v10 )
          break;
        if ( *(_BYTE *)(v10 + 19) != 46
          || (dword_7DBC0 & 0x402) != 0
          && ((dword_7DBC0 & 2) != 0 || *(_BYTE *)(v10 + 20) && *(_WORD *)(v10 + 20) != 46) )
        {
          v7 = sub_16998(v5, (_BYTE *)(v10 + 19));
          v8 = sub_169FC(v7);
          v9 = sub_4363C(v7, (int)v8, 0);
          if ( v9 )
          {
            v9[2] = v15;
            v9[3] = 1;
            ++v20;
            v15 = v9;
          }
          else
          {
            free(v7);
          }
        }
      }
      closedir(v6);
      if ( v15 )
      {
        v11 = (char *)sub_43588(v20);
        v12 = v11 - 4;
        v13 = v11;
        v14 = v11 - 4;
        do
        {
          *((_DWORD *)v14 + 1) = v15;
          v14 += 4;
          v15 = (_DWORD *)v15[2];
        }
        while ( v15 );
        if ( v20 )
        {
          sub_43820(v11, (size_t)v20);
          sub_43D70((unsigned int)v13, (unsigned int)v20);
          if ( (dword_7DBC0 & 0x4000) != 0 )
          {
            v16 = sub_4359C((int)v13, 2);
            v17 = sub_43504((int)v13, 2);
            if ( v17 )
            {
              sub_43820(v16, v17);
              sub_43F1C(v16, 0);
              free(v16);
            }
          }
          if ( v13 )
          {
            while ( 1 )
            {
              v19 = *((_DWORD *)v12 + 1);
              v12 += 4;
              v18 = v19;
              if ( !v19 )
                break;
              if ( *(_DWORD *)(v18 + 12) )
                free(*(void **)(v18 + 4));
              free((void *)v18);
            }
            free(v13);
          }
        }
      }
    }
    else
    {
      buf.c_oflag = 1;
    }
  }
}
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00044140) --------------------------------------------------------
tcflag_t __fastcall sub_44140(int a1, char **a2)
{
  int v3; // r4
  char *v4; // r0
  int v5; // r2
  char **v6; // r3
  char *v7; // r4
  const char **v8; // r6
  _DWORD *v9; // r7
  const char *v10; // r1
  const char *v11; // t1
  unsigned int v12; // r2
  _DWORD *v13; // r0
  const char *v14; // r3
  char *v16; // r0
  unsigned int v17; // r6
  char *v18; // r3
  _DWORD *v19; // r8
  _DWORD *v20; // r7
  int v21; // r0
  size_t v22; // r4
  size_t v23; // r5
  char *s; // [sp+4h] [bp-4h] BYREF

  s = "always";
  memset(&buf, 0, 0x10u);
  time((time_t *)&buf.c_lflag);
  v3 = sub_593F8(a2, "^Cadi1lgnsxAkFpRQctuSXrvLHh", "full-time", &s, a1);
  if ( isatty(1) )
  {
    v4 = getenv("LS_COLORS");
    if ( !v4 || *v4 && strcmp(v4, "none") )
      buf.c_iflag = 1;
  }
  if ( (v3 & 0x10000000) != 0 )
  {
    if ( *s == 110 )
    {
      LOBYTE(buf.c_iflag) = 0;
    }
    else
    {
      switch ( sub_168D4("always", s) )
      {
        case 0:
        case 1:
        case 2:
          goto LABEL_35;
        case 3:
        case 4:
        case 5:
          if ( !isatty(1) )
            goto LABEL_10;
LABEL_35:
          LOBYTE(buf.c_iflag) = 1;
          break;
        default:
          goto LABEL_10;
      }
    }
    *(_WORD *)((char *)&buf.c_iflag + 1) = 0;
    HIBYTE(buf.c_iflag) = 0;
  }
LABEL_10:
  if ( (v3 & 4) != 0 )
    dword_7DBC0 &= ~0x4000u;
  if ( (v3 & 0x20) == 0 && (v3 & 0x50000) != 0 )
    dword_7DBC0 |= 0x20000u;
  if ( (dword_7DBC0 & 0x231) == 0 )
  {
    if ( isatty(1) )
      v5 = 1;
    else
      v5 = 16;
    dword_7DBC0 |= v5;
  }
  v6 = &a2[optind];
  if ( !*v6 )
    *--v6 = ".";
  if ( v6[1] )
    buf.c_cflag = 1;
  v7 = 0;
  v8 = (const char **)v6;
  v9 = 0;
  do
  {
    v11 = *v8++;
    v10 = v11;
    if ( (dword_7DBC0 & 0x1120) != 0 )
      v12 = HIBYTE(dword_7DBC0) & 1;
    else
      v12 = 1;
    v13 = sub_4363C(v10, (int)v10, v12);
    v14 = *v8;
    if ( v13 )
    {
      v13[2] = v9;
      ++v7;
      v9 = v13;
    }
  }
  while ( v14 );
  if ( v7 )
  {
    v16 = (char *)sub_43588(v7);
    v17 = (unsigned int)v16;
    v18 = v16 - 4;
    do
    {
      *((_DWORD *)v18 + 1) = v9;
      v18 += 4;
      v9 = (_DWORD *)v9[2];
    }
    while ( v9 );
    if ( (dword_7DBC0 & 4) != 0 )
    {
      sub_43820(v16, (size_t)v7);
      sub_43D70(v17, (unsigned int)v7);
    }
    else
    {
      v19 = sub_4359C((int)v16, 1);
      v20 = sub_4359C(v17, 0);
      v21 = sub_43504(v17, 1);
      v22 = (size_t)&v7[-v21];
      v23 = v21;
      if ( v22 )
      {
        sub_43820(v20, v22);
        sub_43D70((unsigned int)v20, v22);
      }
      if ( v23 )
      {
        sub_43820(v19, v23);
        sub_43F1C((int)v19, v22 == 0);
      }
    }
  }
  return buf.c_oflag;
}
// 44320: control flows out of bounds to 44324
// 7D604: using guessed type int optind;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00044448) --------------------------------------------------------
void *__fastcall sub_44448(const char *a1)
{
  int v2; // r6
  int v3; // r3
  void (__fastcall *v4)(int, _DWORD *); // r5
  int v5; // r7
  char *i; // r4
  ssize_t v7; // r0
  void *v8; // r5
  _BYTE v10[208]; // [sp+0h] [bp-D0h] BYREF

  v2 = sub_61D34((int)a1);
  if ( v2 < 0 )
    return 0;
  v3 = *(unsigned __int8 *)(dword_7DB90 + 3);
  if ( v3 == 115 )
  {
    v4 = (void (__fastcall *)(int, _DWORD *))sub_5A08C;
    v5 = 16;
    sub_59FE0((int)v10);
  }
  else
  {
    if ( v3 != 50 )
      sub_16E08();
    v4 = (void (__fastcall *)(int, _DWORD *))sub_5A1E8;
    sub_5A0C4((int)v10);
    v5 = 32;
  }
  for ( i = (char *)sub_1748C(0x1000u); ; sub_5A024((int)v10, i, v7) )
  {
    v7 = sub_1800C(v2, i, 0x1000u);
    if ( v7 <= 0 )
      break;
  }
  if ( v7 )
  {
    v8 = 0;
    sub_16AF4("can't read '%s'", a1);
  }
  else
  {
    v4((int)v10, i);
    v8 = sub_174DC(2 * v5 + 1);
    sub_16FB4((int)v8, (unsigned __int8 *)i, v5);
  }
  free(i);
  if ( v2 )
    close(v2);
  return v8;
}
// 7DB90: using guessed type int dword_7DB90;

//----- (00044554) --------------------------------------------------------
int __fastcall sub_44554(int a1, char **a2)
{
  int v3; // r6
  char v4; // r7
  const char **v5; // r4
  const char *v6; // r0
  int v7; // r5
  int v8; // r8
  int v9; // r1
  int v10; // r2
  FILE *v11; // r10
  const char *v12; // r0
  char *v13; // r9
  const char *v14; // t1
  char *v16; // r11
  const char *v17; // r11
  const char *v18; // r0
  int v19; // r2
  int v20; // r0
  const char *v21; // r0
  char *v22; // r5
  char *ptr; // [sp+0h] [bp-Ch]

  v3 = 0;
  v4 = sub_593CC(a2, "^scwbt");
  v5 = (const char **)&a2[optind];
  if ( !*v5 )
    *--v5 = "-";
  do
  {
    v6 = *v5;
    if ( (v4 & 2) != 0 )
    {
      v7 = 0;
      v8 = 0;
      v11 = (FILE *)sub_61D20((int)v6);
      while ( 1 )
      {
        v12 = sub_58D24(v11, v9, v10);
        v13 = (char *)v12;
        if ( !v12 )
          break;
        ++v8;
        v16 = strstr(v12, "  ");
        if ( v16 || (v16 = strstr(v13, " *")) != 0 )
        {
          *v16 = 0;
          v17 = v16 + 2;
          v18 = (const char *)sub_44448(v17);
          v19 = v4 & 1;
          ptr = (char *)v18;
          if ( !v18 || (v20 = strcmp(v18, v13), v19 = v4 & 1, v20) )
          {
            if ( !v19 )
              printf("%s: FAILED\n", v17);
            ++v7;
            v3 = 1;
          }
          else if ( (v4 & 1) == 0 )
          {
            printf("%s: OK\n", v17);
          }
          free(ptr);
          free(v13);
        }
        else
        {
          if ( (v4 & 4) != 0 )
            sub_16DDC("invalid format");
          ++v7;
          free(v13);
          v3 = 1;
        }
      }
      if ( v7 && (v4 & 1) == 0 )
        sub_16DDC("WARNING: %d of %d computed checksums did NOT match", v7, v8);
      if ( !v8 )
      {
        v3 = 1;
        sub_16DDC("%s: no checksum lines found", *v5);
      }
      sub_5888C(v11);
    }
    else
    {
      v21 = (const char *)sub_44448(v6);
      v22 = (char *)v21;
      if ( v21 )
      {
        printf("%s  %s\n", v21, *v5);
        free(v22);
      }
      else
      {
        v3 = 1;
      }
    }
    v14 = v5[1];
    ++v5;
  }
  while ( v14 );
  return v3;
}
// 445B0: variable 'v9' is possibly undefined
// 445B0: variable 'v10' is possibly undefined
// 7D604: using guessed type int optind;

//----- (00044738) --------------------------------------------------------
int __fastcall sub_44738(int a1, char **a2, int a3)
{
  char v4; // r5
  __mode_t v5; // r6
  int v6; // r7
  char **v7; // r5
  int v8; // r4
  int v9; // r0
  char *v10; // r3
  char *v11; // t1
  int v13[2]; // [sp+4h] [bp-8h] BYREF

  v13[0] = (int)a2;
  v13[1] = a3;
  v4 = sub_593F8(a2, "m:pv", "mode", v13, a1);
  if ( (v4 & 1) != 0 )
  {
    v5 = sub_5E0F4((const char *)v13[0], 0x1FFu);
    if ( v5 == -1 )
      sub_16DBC("invalid mode '%s'", (const char *)v13[0]);
  }
  else
  {
    v5 = -1;
  }
  if ( (v4 & 2) != 0 )
    v6 = 4;
  else
    v6 = 0;
  if ( (v4 & 4) != 0 )
    v6 |= 0x1000u;
  v7 = &a2[optind];
  if ( !*v7 )
    sub_162F0();
  v8 = 0;
  do
  {
    v9 = sub_5D824(*v7, v5, v6);
    v11 = v7[1];
    ++v7;
    v10 = v11;
    if ( v9 )
      v8 = 1;
  }
  while ( v10 );
  return v8;
}
// 7D604: using guessed type int optind;

//----- (000447FC) --------------------------------------------------------
int __fastcall sub_447FC(int a1, char **a2, int a3)
{
  int v4; // r0
  char **v5; // r4
  __mode_t v6; // r6
  int v7; // r5
  char *v8; // t1

  v4 = sub_49B9C(a2, (int)a2, a3);
  v5 = &a2[optind];
  if ( !*v5 )
    sub_162F0();
  v6 = v4;
  v7 = 0;
  do
  {
    if ( mkfifo(*v5, v6) < 0 )
    {
      v7 = 1;
      sub_16B80(*v5);
    }
    v8 = v5[1];
    ++v5;
  }
  while ( v8 );
  return v7;
}
// 7D604: using guessed type int optind;

//----- (00044868) --------------------------------------------------------
int __fastcall sub_44868(int a1, char **a2, int a3)
{
  int v4; // r0
  int v5; // r6
  char **v6; // r5
  char *v7; // r3
  int v8; // r8
  char *v9; // r0
  const char *v10; // r7
  __mode_t v11; // r8
  unsigned int v12; // r0
  unsigned int v13; // r7
  unsigned int v14; // r0
  unsigned int v15; // r0
  unsigned __int64 v16; // r0
  __dev_t v17; // r2
  int result; // r0

  v4 = sub_49B9C(a2, (int)a2, a3);
  v5 = optind;
  v6 = &a2[optind];
  if ( !*v6 )
    goto LABEL_3;
  v7 = v6[1];
  if ( !v7 )
    goto LABEL_3;
  v8 = v4;
  v9 = strchr("pcub", (unsigned __int8)*v7);
  if ( !v9 )
    goto LABEL_3;
  v10 = v6[2];
  v11 = v8 | dword_639C8[(unsigned __int8)v9[4]];
  if ( *v9 != 112 )
  {
    if ( v10 && v6[3] )
    {
      v12 = gnu_dev_major(0xFFFFFFFF);
      v13 = sub_6206C(v10, 0, v12);
      v14 = gnu_dev_minor(0xFFFFFFFF);
      v15 = sub_6206C(v6[3], 0, v14);
      v16 = j_gnu_dev_makedev(v13, v15);
      v10 = v6[4];
      v17 = v16;
      goto LABEL_9;
    }
LABEL_3:
    sub_162F0();
  }
  v17 = 0;
LABEL_9:
  if ( v10 )
    goto LABEL_3;
  result = sub_62E20(a2[v5], v11, v17);
  if ( result )
    sub_16B90(a2[v5]);
  return result;
}
// 639C8: using guessed type _DWORD dword_639C8[3];
// 7D604: using guessed type int optind;

//----- (0004497C) --------------------------------------------------------
int __fastcall sub_4497C(int a1, char **a2, const char *a3)
{
  char *v4; // r0
  char v5; // r5
  char *v6; // r4
  bool v7; // zf
  const char *v9[2]; // [sp+4h] [bp-8h] BYREF

  v9[1] = a3;
  v4 = getenv("TMPDIR");
  v9[0] = v4;
  if ( !v4 || !*v4 )
    v9[0] = "/tmp";
  v5 = sub_593CC(a2, "^dqtp:u", v9);
  v6 = a2[optind];
  if ( !v6 )
  {
    v5 |= 4u;
    v6 = sub_174F8("tmp.XXXXXX");
  }
  if ( (v5 & 0xC) != 0 )
    v6 = sub_16998(v9[0], v6);
  if ( (v5 & 0x10) != 0 )
  {
    v6 = mktemp(v6);
    v7 = *v6 == 0;
  }
  else
  {
    if ( (v5 & 1) == 0 )
    {
      if ( mkstemp64(v6) >= 0 )
        goto LABEL_11;
      goto LABEL_16;
    }
    v7 = mkdtemp(v6) == 0;
  }
  if ( !v7 )
  {
LABEL_11:
    puts(v6);
    return 0;
  }
LABEL_16:
  if ( (v5 & 2) == 0 )
    sub_5E304();
  return 1;
}
// 13A24: using guessed type int __fastcall mkstemp64(_DWORD);
// 7D604: using guessed type int optind;

//----- (00044A78) --------------------------------------------------------
int __fastcall sub_44A78(int a1, char **a2)
{
  char v4; // r8
  const char **v5; // r4
  int v6; // r3
  const char *v7; // r9
  int v8; // r0
  int v9; // r6
  int v10; // r7
  char *v11; // r0
  char *v12; // r5
  int v14; // r0
  const char *v15; // r2
  const char *v16; // r1
  _BYTE v17[104]; // [sp+0h] [bp-D0h] BYREF
  _BYTE v18[104]; // [sp+68h] [bp-68h] BYREF

  v4 = sub_593F8(a2, "^finv", "interactive");
  v5 = (const char **)&a2[optind];
  v6 = a1 - optind + 0x3FFFFFFF;
  v7 = v5[v6];
  if ( a1 - optind != 2 )
  {
LABEL_5:
    v10 = 0;
    while ( 1 )
    {
      v11 = sub_16A54(*v5);
      v12 = sub_16998(v7, v11);
      v9 = sub_49B90(v12, (int)v17);
      if ( v9 < 0 )
        goto LABEL_34;
LABEL_7:
      if ( v9 )
      {
        if ( (v4 & 4) != 0 )
          goto LABEL_9;
        if ( (v4 & 1) == 0 && (access(v12, 2) < 0 && isatty(v4 & 1) || (v4 & 2) != 0) )
        {
          if ( fprintf((FILE *)stderr, "mv: overwrite '%s'? ", v12) < 0 )
            goto LABEL_34;
          if ( !sub_57700() )
            goto LABEL_9;
        }
      }
      if ( rename(*v5, v12) >= 0 )
        goto LABEL_9;
      if ( *(_DWORD *)dword_7DB94 != 18 )
        break;
      v14 = sub_49B28(*v5, (int)v18, sub_62E14);
      if ( v14 <= 0 )
        break;
      if ( v9 )
      {
        if ( v9 == 3 )
        {
          if ( v14 != 3 )
          {
            v15 = "non-";
            v16 = "";
            goto LABEL_33;
          }
        }
        else if ( v14 == 3 )
        {
          v15 = "";
          v16 = "non-";
LABEL_33:
          sub_16DDC("can't overwrite %sdirectory with %sdirectory", v16, v15);
LABEL_34:
          v10 = 1;
          goto LABEL_9;
        }
        if ( unlink(v12) < 0 )
        {
          sub_16AF4("can't remove '%s'", v12);
          goto LABEL_34;
        }
      }
      if ( sub_57E30(*v5, v12, 5) < 0 || sub_6065C(*v5, 12) < 0 )
        goto LABEL_34;
LABEL_9:
      if ( (v4 & 8) != 0 )
        printf("'%s' -> '%s'\n", *v5, v12);
      if ( v12 != v7 )
        free(v12);
      if ( v5[1] == v7 )
        return v10;
      ++v5;
    }
    sub_16AF4("can't rename '%s'", *v5);
    goto LABEL_34;
  }
  v8 = sub_49B90(v5[v6], (int)v17);
  v9 = v8;
  if ( v8 >= 0 )
  {
    v10 = v8 & 2;
    if ( (v8 & 2) == 0 )
    {
      v12 = (char *)v7;
      goto LABEL_7;
    }
    goto LABEL_5;
  }
  return 1;
}
// 7D604: using guessed type int optind;
// 7D608: using guessed type int stderr;
// 7DB94: using guessed type int dword_7DB94;

//----- (00044CD8) --------------------------------------------------------
void __fastcall __noreturn sub_44CD8(int a1, int a2)
{
  int v3; // r0
  _BYTE *v4; // r4
  int v5; // r7
  int v6; // r5
  const char *v7; // r0
  signed int v8; // r0
  int v9; // r7

  v3 = getpriority(0, 0);
  v4 = *(_BYTE **)(a2 + 4);
  v5 = v3;
  if ( !v4 )
  {
    printf("%d\n", v3);
    sub_588D8(0);
  }
  v6 = a2 + 4;
  if ( *v4 != 45 )
  {
    v8 = 10;
    goto LABEL_11;
  }
  v7 = v4 + 1;
  if ( v4[1] == 110 )
  {
    v7 = v4 + 2;
    if ( v4[2] )
    {
LABEL_8:
      if ( !*(_DWORD *)(v6 + 4) )
LABEL_9:
        sub_162F0();
      v6 += 4;
      v8 = sub_62154(v7, -1073741824, 0x3FFFFFFF);
LABEL_11:
      v9 = v8 + v5;
      if ( setpriority(0, 0, v9) < 0 )
        sub_16B40("setpriority(%d)", v9);
      sub_58840((const char **)v6);
    }
    v7 = *(const char **)(a2 + 8);
    v6 = a2 + 8;
  }
  if ( !v7 )
    goto LABEL_9;
  goto LABEL_8;
}

//----- (00044DB0) --------------------------------------------------------
void __fastcall __noreturn sub_44DB0(int a1, int a2)
{
  char *v3; // r0
  char *v4; // r4

  byte_7D5F8 = 127;
  if ( !*(_DWORD *)(a2 + 4) )
    sub_162F0();
  if ( isatty(0) )
  {
    close(0);
    sub_175D8("/dev/null", 0);
  }
  if ( !isatty(1) )
  {
LABEL_10:
    if ( isatty(2) )
      dup2(1, 2);
    signal(1, (__sighandler_t)1);
    sub_58840((const char **)(a2 + 4));
  }
  close(1);
  if ( open64("nohup.out", 1089) < 0 )
  {
    v3 = getenv("HOME");
    if ( v3 )
    {
      v4 = sub_16998(v3, "nohup.out");
      sub_175B4(v4, 1089);
LABEL_9:
      sub_16DDC("appending output to %s", v4);
      goto LABEL_10;
    }
    sub_175D8("/dev/null", 0);
  }
  v4 = "nohup.out";
  goto LABEL_9;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D5F8: using guessed type char byte_7D5F8;

//----- (00044EB0) --------------------------------------------------------
int sub_44EB0()
{
  int v0; // r1
  int i; // r3
  unsigned int j; // r2
  _DWORD v5[1025]; // [sp+0h] [bp-1004h] BYREF

  v0 = sched_getaffinity(0, 4096, v5);
  if ( v0 )
  {
    v0 = 1;
  }
  else
  {
    for ( i = 0; i != 1024; ++i )
    {
      for ( j = v5[i]; j; j >>= 1 )
      {
        if ( (j & 1) != 0 )
          ++v0;
      }
    }
    if ( !v0 )
      v0 = 1;
  }
  printf("%u\n", v0);
  return 0;
}
// 14060: using guessed type int __fastcall sched_getaffinity(_DWORD, _DWORD, _DWORD);

//----- (00044F28) --------------------------------------------------------
void __fastcall __noreturn sub_44F28(int a1, char **a2)
{
  int v2; // r10
  int v4; // r1
  unsigned __int8 *v5; // r2
  int v6; // r8
  int v7; // r7
  char **v8; // r4
  _BYTE *v9; // r0
  int v10; // r5
  char *v11; // r3
  int v12; // r6
  int *v13; // r4
  int *v14; // r7
  int v15; // r0
  int v16; // t1
  bool v17; // zf
  int v18; // t1
  int v19; // r0
  int v20; // r0
  int v21; // r7
  void *v22; // r6
  _BYTE *v23; // r9
  FILE *v24; // r0
  FILE **v25; // r9
  FILE *v26; // t1
  _BYTE *v27; // r0
  void *v28; // r11
  int i; // r7
  int v30; // r8
  int v31; // r0
  unsigned __int8 *v32; // [sp+0h] [bp-14h]
  unsigned __int8 *v33; // [sp+Ch] [bp-8h] BYREF

  v33 = "\t";
  v6 = sub_593CC(a2, "d:s", &v33);
  v7 = optind;
  v8 = &a2[optind];
  if ( (v6 & 1) != 0 )
  {
    if ( !*v33 )
      sub_16DBC("-d '' is not supported");
    v9 = sub_5E730(v33, v33, v5);
    v10 = v9 - v33;
  }
  else
  {
    v10 = 1;
  }
  v11 = a2[v7];
  v12 = 0;
  if ( !v11 )
    *--v8 = "-";
  v13 = (int *)(v8 - 1);
  v14 = v13;
  while ( 1 )
  {
    v16 = v14[1];
    ++v14;
    v15 = v16;
    if ( !v16 )
      break;
    v19 = sub_61CD8(v15);
    *v14 = v19;
    if ( !v19 )
      sub_16E08();
    ++v12;
  }
  v17 = (v6 & 2) == 0;
  if ( (v6 & 2) != 0 )
    v6 = (int)&stdout;
  else
    v2 = v12;
  v32 = v33;
  if ( !v17 )
  {
    while ( 1 )
    {
      v18 = v13[1];
      ++v13;
      if ( !v18 )
        break;
      v22 = 0;
      v21 = 0;
      while ( 1 )
      {
        v23 = sub_58D24((FILE *)*v13, v4, (int)v5);
        if ( !v23 )
          break;
        if ( v22 )
        {
          fputs_unlocked(v22, *(_DWORD *)v6);
          free(v22);
          v5 = v32;
          v20 = v32[v21];
          if ( v10 == v21 + 1 )
            v21 = 0;
          else
            ++v21;
          if ( v20 )
            putc_unlocked(v20, *(FILE **)v6);
        }
        v22 = v23;
      }
      if ( v22 )
      {
        printf("%s\n", (const char *)v22);
        free(v22);
      }
      sub_5888C((FILE *)*v13);
    }
LABEL_14:
    sub_588D8(0);
  }
LABEL_36:
  if ( v2 <= 0 )
    goto LABEL_14;
  v30 = 0;
  v25 = (FILE **)v13;
  for ( i = 0; ; ++i )
  {
    if ( v12 == i )
      goto LABEL_36;
    v26 = v25[1];
    ++v25;
    v24 = v26;
    if ( v26 )
    {
      v27 = sub_58D24(v24, v4, (int)v5);
      v28 = v27;
      if ( !v27 )
      {
        --v2;
        sub_5888C(*v25);
        *v25 = 0;
        continue;
      }
      fputs_unlocked(v27, stdout);
      free(v28);
      if ( i == v12 - 1 )
      {
        v31 = 10;
LABEL_43:
        putc_unlocked(v31, (FILE *)stdout);
        continue;
      }
      v5 = v32;
      v31 = v32[v30];
      if ( v10 == v30 + 1 )
        v30 = 0;
      else
        ++v30;
      if ( v31 )
        goto LABEL_43;
    }
  }
}
// 44F80: variable 'v5' is possibly undefined
// 45054: variable 'v4' is possibly undefined
// 450AC: variable 'v2' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7D614: using guessed type int stdout;

//----- (0004515C) --------------------------------------------------------
void __fastcall __noreturn sub_4515C(int a1, int a2)
{
  char v2; // r4
  int v3; // r4
  const char *v4; // r0
  const char *v5; // t1
  char *v6; // r0
  const char *v7; // r0
  int v8; // r5
  const char *v9; // t1

  if ( *(_DWORD *)(a2 + 4) )
  {
    v8 = a2;
    v2 = 0;
    while ( 1 )
    {
      v9 = *(const char **)(v8 + 4);
      v8 += 4;
      v7 = v9;
      if ( !v9 )
        break;
      v6 = getenv(v7);
      if ( v6 )
        puts(v6);
      else
        v2 = 1;
    }
  }
  else
  {
    if ( _environ )
    {
      v3 = _environ - 4;
      while ( 1 )
      {
        v5 = *(const char **)(v3 + 4);
        v3 += 4;
        v4 = v5;
        if ( !v5 )
          break;
        puts(v4);
      }
    }
    v2 = 0;
  }
  sub_588D8(v2);
}
// 7D600: using guessed type int _environ;

//----- (000451D4) --------------------------------------------------------
int __fastcall sub_451D4(char *a1)
{
  int result; // r0

  result = sub_189FC(a1, 0, 10);
  if ( *(_DWORD *)dword_7DB94 )
  {
    sub_16DDC("invalid number '%s'", a1);
    return 0;
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00045218) --------------------------------------------------------
__int64 __fastcall sub_45218(char *a1, __int64 *a2)
{
  __int64 result; // r0

  result = sub_18914(a1, 0, 0);
  *a2 = result;
  return result;
}

//----- (00045234) --------------------------------------------------------
int __fastcall sub_45234(const char *a1, int a2, void (__fastcall *a3)(const char *, int))
{
  const char *v3; // r4
  int v4; // r3
  bool v7; // zf
  int *v8; // r5
  int result; // r0

  v3 = a1;
  v4 = *(unsigned __int8 *)a1;
  v7 = v4 == 39;
  if ( v4 != 39 )
    v7 = v4 == 34;
  if ( v7 )
    v3 = sub_16F64(*((unsigned __int8 *)a1 + 1));
  v8 = (int *)dword_7DB94;
  *(_DWORD *)dword_7DB94 = 0;
  a3(v3, a2);
  result = *v8;
  if ( *v8 )
  {
    sub_16DDC("invalid number '%s'", v3);
    return 1;
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000452A4) --------------------------------------------------------
char *__fastcall sub_452A4(const char *a1, int a2, const char *a3, const char *a4, const char *a5)
{
  char v6; // r10
  char *v10; // r11
  char *result; // r0
  char *v12; // r8
  unsigned int v13; // r2
  void (__fastcall *v14)(const char *, int); // r2
  const char *v15; // r1
  int v16; // r2
  int v17; // r3
  bool v18; // zf
  const char *v19; // r2
  const char *v20; // r1
  int v21; // [sp+8h] [bp-Ch] BYREF
  int v22; // [sp+Ch] [bp-8h]

  v6 = a1[a2];
  a1[a2] = 0;
  v10 = strstr(a1, ".*");
  result = strchr(a1, 42);
  if ( result - 1 == v10 )
    v12 = 0;
  else
    v12 = result;
  *(_DWORD *)dword_7DB94 = 0;
  v13 = (unsigned __int8)a1[a2 - 1];
  if ( v13 > 0x67 )
  {
    if ( v13 == 115 )
    {
      if ( v12 )
      {
        v20 = a3;
        if ( v10 )
          v19 = a4;
        else
          v19 = a5;
      }
      else
      {
        v19 = a5;
        if ( v10 )
          v20 = a4;
        else
          v20 = a5;
      }
      result = (char *)printf(a1, v20, v19, a5);
      goto LABEL_10;
    }
    if ( v13 > 0x73 )
    {
      if ( v13 == 117 )
      {
LABEL_25:
        v14 = (void (__fastcall *)(const char *, int))sub_454C0;
LABEL_14:
        if ( sub_45234(a5, (int)&v21, v14) )
        {
          v21 = 0;
          v22 = 0;
        }
        v16 = v21;
        v17 = v22;
        if ( !v12 )
        {
          if ( v10 )
            v15 = a4;
          goto LABEL_44;
        }
        if ( !v10 )
        {
          v15 = a3;
LABEL_44:
          result = (char *)printf(a1, v15, v16, v17);
          goto LABEL_10;
        }
LABEL_32:
        result = (char *)printf(a1, a3, a4, v17, v21, v22);
        goto LABEL_10;
      }
      v18 = v13 == 120;
    }
    else
    {
      if ( v13 == 105 )
      {
LABEL_13:
        v14 = (void (__fastcall *)(const char *, int))sub_45218;
        goto LABEL_14;
      }
      v18 = v13 == 111;
    }
    if ( !v18 )
      goto LABEL_10;
    goto LABEL_25;
  }
  if ( v13 >= 0x65 )
    goto LABEL_41;
  if ( v13 == 88 )
    goto LABEL_25;
  if ( v13 <= 0x58 )
  {
    if ( v13 != 69 && v13 != 71 )
      goto LABEL_10;
LABEL_41:
    sub_45234(a5, (int)&v21, (void (__fastcall *)(const char *, int))sub_4550C);
    v16 = v21;
    v17 = v22;
    if ( !v12 )
    {
      if ( v10 )
        v15 = a4;
      goto LABEL_44;
    }
    if ( !v10 )
    {
      v15 = a3;
      goto LABEL_44;
    }
    goto LABEL_32;
  }
  if ( v13 == 99 )
  {
    result = (char *)printf(a1, *(unsigned __int8 *)a5);
    goto LABEL_10;
  }
  if ( v13 == 100 )
    goto LABEL_13;
LABEL_10:
  a1[a2] = v6;
  return result;
}
// 45470: variable 'v15' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;

//----- (000454C0) --------------------------------------------------------
__int64 __fastcall sub_454C0(char *a1, __int64 *a2)
{
  __int64 result; // r0

  result = sub_188A4(a1, 0, 0);
  *a2 = result;
  if ( *(_DWORD *)dword_7DB94 )
  {
    result = sub_18914(a1, 0, 0);
    *a2 = result;
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (0004550C) --------------------------------------------------------
double __fastcall sub_4550C(const char *a1, char *a2)
{
  __int64 v2; // d0
  double result; // r0
  char *v5; // r3
  char *endptr; // [sp+4h] [bp-4h] BYREF

  endptr = a2;
  result = strtod(a1, &endptr);
  v5 = endptr;
  *(_QWORD *)a2 = v2;
  if ( *v5 )
  {
    *(_DWORD *)dword_7DB94 = 34;
    *(_QWORD *)a2 = 0;
  }
  return result;
}
// 45520: variable 'v2' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;

//----- (00045558) --------------------------------------------------------
int __fastcall sub_45558(int a1, int a2)
{
  _BYTE *v3; // r3
  char **v5; // r6
  char **v6; // r5
  unsigned __int8 *v7; // r7
  int v8; // r0
  int v9; // r1
  unsigned __int8 *v10; // r3
  int v11; // r0
  unsigned __int8 *v12; // r4
  int v13; // r2
  int v14; // r4
  char *v15; // r0
  const char *v16; // r9
  unsigned __int8 *v17; // r3
  int v18; // r8
  char *v19; // r0
  const char *v20; // r11
  int v21; // r4
  bool v22; // zf
  int v23; // r2
  int v24; // r4
  char *v25; // r0
  bool v26; // zf
  char *v27; // r3
  int v28; // r10
  unsigned __int8 *v29; // r1
  const char *v30; // r2
  bool v31; // zf
  int v32; // r0
  const char *v33; // [sp+0h] [bp-1Ch]
  int v34; // [sp+8h] [bp-14h]
  unsigned __int8 *v35; // [sp+Ch] [bp-10h]
  unsigned __int8 *i; // [sp+10h] [bp-Ch] BYREF
  unsigned __int8 *v37; // [sp+14h] [bp-8h] BYREF

  if ( fcntl(1, 3) == -1 )
    return 1;
  v3 = *(_BYTE **)(a2 + 4);
  if ( v3 && *v3 == 45 && v3[1] == 45 && !v3[2] )
    a2 += 4;
  v35 = *(unsigned __int8 **)(a2 + 4);
  if ( !v35 )
  {
    if ( *(_BYTE *)dword_7DB90 == 112 )
      sub_162F0();
    sub_16DDC("usage: printf FORMAT [ARGUMENT...]");
    return 2;
  }
  v5 = (char **)(a2 + 8);
  v34 = 0;
  while ( 2 )
  {
    v6 = v5;
    for ( i = v35; ; ++i )
    {
      v7 = i;
      v8 = *i;
      if ( !*i )
        break;
      if ( v8 != 37 )
      {
        if ( v8 == 92 )
        {
          ++i;
          if ( v7[1] == 99 )
          {
LABEL_32:
            v6 = v5;
            goto LABEL_67;
          }
          v32 = sub_5E668(&i);
          j_putchar_unlocked(v32);
          --i;
        }
        else
        {
          putchar_unlocked(v8);
        }
        continue;
      }
      ++i;
      v9 = v7[1];
      if ( v9 == 37 )
      {
        j_putchar_unlocked(37);
        continue;
      }
      if ( v9 == 98 )
      {
        v10 = (unsigned __int8 *)*v6;
        if ( *v6 )
        {
          while ( 1 )
          {
            v11 = *v10;
            if ( !*v10 )
              break;
            v12 = v10 + 1;
            if ( v11 == 92 )
            {
              v13 = v10[1];
              if ( v13 == 48 )
              {
                if ( (unsigned int)v10[2] - 48 <= 7 )
                  v12 = v10 + 2;
              }
              else if ( v13 == 99 )
              {
                goto LABEL_32;
              }
              v37 = v12;
              v11 = sub_5E668(&v37);
              v12 = v37;
            }
            putchar_unlocked(v11);
            v10 = v12;
          }
          ++v6;
        }
        continue;
      }
      if ( v7[1] && strchr("-+ #", v9) )
      {
        v14 = 2;
        i = v7 + 2;
      }
      else
      {
        v14 = 1;
      }
      if ( *i == 42 )
      {
        v15 = *v6;
        ++i;
        ++v14;
        if ( v15 )
        {
          ++v6;
          v15 = (char *)sub_451D4(v15);
        }
        v16 = v15;
      }
      else
      {
        while ( (unsigned int)*i - 48 <= 9 )
        {
          ++v14;
          ++i;
        }
        v16 = 0;
      }
      v17 = i;
      if ( *i == 46 )
      {
        v18 = v14 + 1;
        ++i;
        if ( v17[1] == 42 )
        {
          v19 = *v6;
          i = v17 + 2;
          v18 = v14 + 2;
          if ( v19 )
          {
            ++v6;
            v19 = (char *)sub_451D4(v19);
          }
          v20 = v19;
          goto LABEL_53;
        }
        while ( (unsigned int)*i - 48 <= 9 )
        {
          ++v18;
          ++i;
        }
      }
      else
      {
        v18 = v14;
      }
      v20 = 0;
      while ( 1 )
      {
LABEL_53:
        v21 = *i;
        v22 = v21 == 104;
        if ( v21 != 104 )
          v22 = v21 == 122;
        v23 = v22;
        if ( (v21 | 0x20) == 0x6C )
          v23 |= 1u;
        if ( !v23 )
          break;
        sub_60B4C((int)i, (int)(i + 1));
      }
      v24 = v21 == 0;
      v25 = strchr("diouxXfeEgGcs", *i);
      if ( !v25 )
        v24 = 1;
      if ( v24 )
      {
        v6 = v5 - 1;
        sub_16DDC("%s: invalid format", (const char *)v7);
        break;
      }
      v27 = "diouxXfeEgGcs";
      v28 = v18 + 1;
      if ( v25 - "diouxXfeEgGcs" <= 5 )
      {
        v24 = (int)sub_1748C(v18 + 4);
        v29 = v7;
        v7 = (unsigned __int8 *)v24;
        memcpy((void *)v24, v29, v18 + 1);
        *(_BYTE *)(v24 + v18 + 2) = *(_BYTE *)(v24 + v18);
        *(_BYTE *)(v24 + v18) = 108;
        *(_BYTE *)(v24 + v28) = 108;
        v28 = v18 + 3;
      }
      v30 = *v6;
      v31 = *v6 == 0;
      if ( *v6 )
      {
        ++v6;
        v33 = v30;
      }
      else
      {
        v27 = "";
      }
      if ( v31 )
        v33 = v27;
      sub_452A4((const char *)v7, v28, v16, v20, v33);
      v34 |= *(_DWORD *)dword_7DB94;
      free((void *)v24);
    }
    if ( v5 < v6 && *v6 )
    {
      v5 = v6;
      continue;
    }
    break;
  }
LABEL_67:
  v26 = v5 == v6;
  if ( v5 <= v6 )
    v26 = v34 == 0;
  return !v26;
}
// 458D4: variable 'v27' is possibly undefined
// 458DC: variable 'v33' is possibly undefined
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;

//----- (00045958) --------------------------------------------------------
int sub_45958()
{
  const char *v0; // r0
  char *v1; // r4

  v0 = (const char *)sub_624A4(0);
  v1 = (char *)v0;
  if ( !v0 )
    return 1;
  puts(v0);
  free(v1);
  return sub_177D8();
}

//----- (00045988) --------------------------------------------------------
int __fastcall sub_45988(int a1, char **a2)
{
  char v3; // r5
  const char *v4; // r0
  void *v5; // r0
  void *v6; // r4
  void *v7; // r1
  const char *v8; // r0

  v3 = sub_593CC(a2, "^fnvsq");
  v4 = a2[optind];
  if ( (v3 & 4) == 0 )
    dword_7D4BC = v3 & 4;
  if ( (v3 & 1) != 0 )
    v5 = sub_17CF8(v4);
  else
    v5 = sub_17C9C(v4);
  v6 = v5;
  if ( v5 )
  {
    v7 = v5;
    v8 = "%s";
    if ( (v3 & 2) == 0 )
      v8 = "%s\n";
    printf(v8, v7);
    free(v6);
    sub_588D8(0);
  }
  return 1;
}
// 7D4BC: using guessed type int dword_7D4BC;
// 7D604: using guessed type int optind;

//----- (00045A1C) --------------------------------------------------------
void __fastcall __noreturn sub_45A1C(int a1, int a2)
{
  int v2; // r4
  char v3; // r5
  const char *v4; // r0
  char *v5; // r6
  int v6; // t1

  if ( !*(_DWORD *)(a2 + 4) )
    sub_162F0();
  v2 = a2 + 4;
  v3 = 0;
  while ( 1 )
  {
    v4 = sub_17CF8(*(const char **)v2);
    v5 = (char *)v4;
    if ( v4 )
    {
      puts(v4);
      free(v5);
    }
    else
    {
      v3 = 1;
      sub_16B80(*(const char **)v2);
    }
    v6 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    if ( !v6 )
      sub_588D8(v3);
  }
}

//----- (00045A78) --------------------------------------------------------
int __fastcall sub_45A78(int a1, char **a2)
{
  char v3; // r0
  int v4; // r5
  int *v5; // r6
  int v6; // r4
  char *v7; // r0
  int v8; // t1

  v3 = sub_593CC(a2, "^fiRrv");
  if ( (v3 & 1) != 0 )
    v4 = 8;
  else
    v4 = 0;
  if ( (v3 & 2) != 0 )
    v4 |= 0x10u;
  if ( (v3 & 0xC) != 0 )
    v4 |= 4u;
  if ( (v3 & 0x10) != 0 )
    v4 |= 0x1000u;
  v5 = (int *)&a2[optind];
  v6 = *v5;
  if ( *v5 )
  {
    v6 = 0;
    do
    {
      v7 = sub_16A54((const char *)*v5);
      if ( *v7 != 46 || v7[1] && (v7[1] != 46 || v7[2]) )
      {
        if ( sub_6065C((const char *)*v5, v4) < 0 )
          v6 = 1;
      }
      else
      {
        v6 = 1;
        sub_16DDC("can't remove '.' or '..'");
      }
      v8 = v5[1];
      ++v5;
    }
    while ( v8 );
  }
  else if ( (v4 & 8) == 0 )
  {
    sub_162F0();
  }
  return v6;
}
// 7D604: using guessed type int optind;

//----- (00045B54) --------------------------------------------------------
int __fastcall sub_45B54(int a1, char **a2)
{
  char v3; // r0
  char **v4; // r5
  char v5; // r6
  int v6; // r7
  int v7; // r9
  char *v8; // r4
  char *v9; // t1
  char *v11; // r0

  v3 = sub_593F8(a2, "pv", "parents");
  v4 = &a2[optind];
  if ( !*v4 )
    sub_162F0();
  v5 = v3;
  v6 = 0;
  v7 = v3 & 1;
  do
  {
    v8 = *v4;
    while ( 1 )
    {
      if ( (v5 & 2) != 0 )
        printf("rmdir: removing directory, '%s'\n", v8);
      if ( rmdir(v8) < 0 )
        break;
      if ( v7 )
      {
        v11 = dirname(v8);
        v8 = v11;
        if ( *v11 != 46 || v11[1] )
          continue;
      }
      goto LABEL_11;
    }
    if ( (v5 & 4) == 0 || *(_DWORD *)dword_7DB94 != 39 )
    {
      v6 = 1;
      sub_16AF4("'%s'", v8);
    }
LABEL_11:
    v9 = v4[1];
    ++v4;
  }
  while ( v9 );
  return v6;
}
// 7D604: using guessed type int optind;
// 7DB94: using guessed type int dword_7DB94;

//----- (00045C4C) --------------------------------------------------------
int __fastcall sub_45C4C(int a1, char **a2)
{
  double v2; // d0
  char v5; // r7
  int v6; // r9
  int v7; // r4
  _DWORD *v8; // r5
  const char **v9; // r6
  double v10; // d8
  double v11; // d9
  size_t v12; // r4
  unsigned int v13; // r5
  const char *v14; // r8
  const char *v15; // r0
  unsigned int v16; // r8
  size_t v17; // r0
  const char *v18; // r3
  const char *v19; // t1
  size_t v20; // r6
  const char *v21; // r1
  double v22; // d7
  unsigned int i; // r4
  _BOOL4 v24; // r3
  const char *v26; // [sp+8h] [bp-Ch] BYREF
  char *endptr; // [sp+Ch] [bp-8h] BYREF

  v26 = "\n";
  v5 = sub_593CC(a2, "+ws:", &v26);
  v6 = optind;
  v7 = a1 - optind;
  v8 = (_DWORD *)dword_7DB94;
  v9 = (const char **)&a2[optind];
  *(_DWORD *)dword_7DB94 = 0;
  if ( v7 == 2 )
  {
    v10 = 1.0;
    goto LABEL_6;
  }
  if ( v7 == 3 )
  {
    strtod(v9[1], &endptr);
    v10 = v2;
    *v8 |= (unsigned __int8)*endptr;
LABEL_6:
    strtod(a2[v6], &endptr);
    v11 = v2;
    *v8 |= (unsigned __int8)*endptr;
    goto LABEL_7;
  }
  if ( v7 != 1 )
    goto LABEL_4;
  v10 = 1.0;
  v11 = 1.0;
LABEL_7:
  strtod((&v9[v7])[-1], &endptr);
  if ( *v8 || (v12 = (unsigned __int8)*endptr, *endptr) )
LABEL_4:
    sub_162F0();
  v13 = (unsigned __int8)*endptr;
  while ( 1 )
  {
    v14 = *v9;
    v15 = (const char *)strchrnul(*v9, 46);
    v16 = v15 - v14;
    v17 = strlen(v15);
    v19 = v9[1];
    ++v9;
    v18 = v19;
    if ( v13 < v16 )
      v13 = v16;
    if ( !v18 )
      break;
    if ( v12 < v17 )
      v12 = v17;
  }
  if ( v12 )
  {
    v20 = v12 - 1;
    if ( v12 != 1 )
      v13 += v12;
  }
  else
  {
    v20 = 0;
  }
  v21 = "";
  if ( (v5 & 1) == 0 )
    v13 = 0;
  v22 = v11;
  for ( i = 0; ; v22 = v11 + (double)i * v10 )
  {
    v24 = v10 < 0.0 ? v22 >= v2 : v22 <= v2;
    if ( !v24 || printf("%s%0*.*f", v21, v13, v20, v22) < 0 )
      break;
    ++i;
    v21 = v26;
  }
  if ( i )
    j_putchar_unlocked(10);
  return sub_177D8();
}
// 45CC8: variable 'v2' is possibly undefined
// 13624: using guessed type int strchrnul(const char *, ...);
// 7D604: using guessed type int optind;
// 7DB94: using guessed type int dword_7DB94;

//----- (00045E58) --------------------------------------------------------
unsigned int __fastcall sub_45E58(const char **endptr)
{
  const char *v2; // r0
  unsigned int result; // r0

  v2 = *endptr;
  if ( (unsigned int)*(unsigned __int8 *)v2 - 48 > 9 || (result = strtoul(v2, (char **)endptr, 10)) == 0 )
    sub_16DBC("bad field specification");
  return result;
}

//----- (00045E94) --------------------------------------------------------
char *__fastcall sub_45E94(char *s, _DWORD *a2, int a3)
{
  signed int v3; // r5
  char *v4; // r4
  int v7; // r11
  signed int v8; // r8
  signed int v9; // r0
  int v10; // lr
  int i; // r2
  int v12; // r1
  signed int v13; // r3
  int v14; // r12
  unsigned int v15; // r9
  int v16; // r12
  char *v17; // r2
  unsigned int v18; // t1
  unsigned int v19; // r12
  bool v20; // cc
  char *v21; // r1
  int v22; // r1
  char *v23; // r0
  int v24; // r2
  char *v25; // r0
  char *v26; // r0
  int v27; // r2
  char *j; // r2
  char *v30; // r3
  int v31; // r1
  unsigned int v32; // t1
  unsigned int v33; // r1
  bool v34; // cc
  char *v35; // r1
  int v36; // r10
  int v37; // t1
  unsigned int v38; // t1
  unsigned int v39; // r12
  bool v40; // cc
  bool v41; // cc
  unsigned int v42; // r3
  unsigned int v43; // t1
  int v44; // r3
  int v45; // t1
  char *v46; // r1
  int v47; // r3
  int v48; // t1
  int v49; // [sp+8h] [bp-Ch]
  unsigned int v50; // [sp+Ch] [bp-8h]

  v4 = s;
  v7 = a2[2];
  v8 = a2[4];
  if ( a2[1] != 1 || v7 || a2[3] || v8 || (a3 & 0x80000E80) != 0 )
  {
    v9 = strlen(s);
    v10 = 0;
    for ( i = 0; ; i = 1 )
    {
      v12 = a2[2 * i + 1];
      if ( v12 )
      {
        v14 = 0;
        v15 = 1;
        v13 = 0;
        v50 = v12 + i;
        while ( v50 > v15 )
        {
          if ( byte_7D782 )
          {
            do
            {
              v14 = (unsigned __int8)v4[v13];
              if ( !v4[v13] )
                break;
              ++v13;
            }
            while ( (unsigned __int8)byte_7D782 != v14 );
          }
          else
          {
            v30 = &v4[v13];
            do
            {
              v31 = v30 - v4;
              v32 = (unsigned __int8)*v30++;
              v49 = v31;
              v33 = v32 - 9;
              v34 = v32 > 0x20;
              if ( v32 != 32 )
                v34 = v33 > 4;
            }
            while ( !v34 );
            v35 = &v4[v49];
            do
            {
              v13 = v35 - v4;
              v37 = (unsigned __int8)*v35++;
              v36 = v37;
            }
            while ( (v37 & 0xDF) != 0 && (unsigned int)(v36 - 9) > 4 );
          }
          ++v15;
        }
        if ( v14 )
          v16 = v10;
        else
          v16 = 0;
        if ( v16 )
          --v13;
      }
      else
      {
        v13 = v9;
      }
      v10 ^= 1u;
      if ( !i )
        v3 = v13;
      if ( i == 1 )
        break;
    }
    if ( (a3 & 0x80) != 0 )
    {
      v17 = &v4[v3];
      do
      {
        v3 = v17 - v4;
        v18 = (unsigned __int8)*v17++;
        v19 = v18 - 9;
        v20 = v18 > 0x20;
        if ( v18 != 32 )
          v20 = v19 > 4;
      }
      while ( !v20 );
    }
    if ( a3 < 0 )
    {
      v21 = &v4[v13];
      while ( v3 < v13 )
      {
        v38 = (unsigned __int8)*--v21;
        v39 = v38 - 9;
        v40 = v38 > 0x20;
        if ( v38 != 32 )
          v40 = v39 > 4;
        if ( v40 )
          break;
        --v13;
      }
    }
    if ( v8 )
    {
      if ( v8 >= v9 )
        v13 = v9;
      else
        v13 = v8;
    }
    if ( v7 )
    {
      v3 += v7 - 1;
      if ( v3 >= v9 )
        v3 = v9;
    }
    if ( v3 < v13 )
      v22 = v13 - v3;
    else
      v22 = 0;
    v23 = (char *)sub_1751C(&v4[v3], v22);
    v4 = v23;
    if ( (a3 & 0x200) != 0 )
    {
      v24 = 0;
      v25 = v23 - 1;
      while ( 1 )
      {
        v43 = (unsigned __int8)*++v25;
        v42 = v43;
        if ( !v43 )
          break;
        v41 = v42 > 0x20;
        if ( v42 != 32 )
          v41 = v42 - 9 > 4;
        if ( !v41 || v42 - 48 <= 9 || (v42 | 0x20) - 97 <= 0x19 )
          v4[v24++] = v42;
      }
      v4[v24] = 0;
    }
    if ( (a3 & 0x800) != 0 )
    {
      v26 = v4 - 1;
      v27 = 0;
      while ( 1 )
      {
        v45 = (unsigned __int8)*++v26;
        v44 = v45;
        v46 = &v4[v27];
        if ( !v45 )
          break;
        if ( (unsigned int)(v44 - 32) <= 0x5E )
        {
          ++v27;
          *v46 = v44;
        }
      }
      *v46 = 0;
    }
    if ( (a3 & 0x400) != 0 )
    {
      for ( j = v4 - 1; ; *j = v47 )
      {
        v48 = (unsigned __int8)*++j;
        v47 = v48;
        if ( !v48 )
          break;
        if ( (unsigned int)(v47 - 97) <= 0x19 )
          LOBYTE(v47) = v47 - 32;
      }
    }
  }
  return v4;
}
// 45F64: variable 'v3' is possibly undefined
// 7D782: using guessed type char byte_7D782;

//----- (00046148) --------------------------------------------------------
int __fastcall sub_46148(char **a1, char **a2)
{
  double v2; // d0
  int v4; // r4
  int v6; // r11
  _DWORD *i; // r7
  int v8; // r3
  size_t v9; // r5
  char *v11; // r6
  char *v12; // r0
  char *v13; // r5
  double v14; // d7
  int v15; // r11
  int v16; // r0
  int v17; // r11
  int v18; // [sp+4h] [bp-38h]
  char *endptr; // [sp+8h] [bp-34h] BYREF
  char *v20[4]; // [sp+Ch] [bp-30h] BYREF
  int v21; // [sp+1Ch] [bp-20h]

  LOWORD(v4) = dword_7DBC0;
  v6 = 0;
  for ( i = (_DWORD *)dword_7D740; ; i = (_DWORD *)*i )
  {
    v8 = (int)i;
    if ( i )
      v8 = 1;
    if ( v6 )
      v8 = 0;
    if ( !v8 )
      break;
    v4 = i[5];
    if ( !v4 )
      v4 = dword_7DBC0;
    v11 = sub_45E94(*a1, i, v4);
    v12 = sub_45E94(*a2, i, v4);
    v13 = v12;
    switch ( v4 & 7 )
    {
      case 0:
        v6 = strcmp(v11, v12);
        break;
      case 1:
        atof(v11);
        atof(v13);
        goto LABEL_39;
      case 2:
        strtod(v11, &endptr);
        strtod(v13, v20);
        if ( endptr == v11 )
        {
          v6 = v20[0] - v13;
          if ( v20[0] != v13 )
            v6 = -1;
        }
        else
        {
          if ( v20[0] == v13 )
            goto LABEL_46;
          v14 = 1.0 / v2;
          if ( 1.0 / v2 == 0.0 )
          {
            if ( v2 >= 0.0 )
            {
              if ( v14 != 0.0 )
                goto LABEL_46;
              v6 = v2 <= 0.0;
            }
            else if ( v14 == 0.0 )
            {
              if ( v2 < 0.0 )
                v6 = 0;
              else
                v6 = -1;
            }
            else
            {
              v6 = -1;
            }
          }
          else
          {
LABEL_39:
            v6 = 0;
          }
        }
        break;
      case 4:
        v18 = strptime(v11, "%b", v20);
        v15 = v21;
        v16 = strptime(v13, "%b", v20);
        if ( v18 )
        {
          if ( v16 )
            v6 = v15 - v21;
          else
LABEL_46:
            v6 = 1;
        }
        else
        {
          v17 = v16;
          if ( v16 )
            v17 = 1;
          v6 = -v17;
        }
        break;
      default:
        sub_16DBC("unknown sort type");
    }
    if ( *a1 != v11 )
      free(v11);
    if ( *a2 != v13 )
      free(v13);
  }
  if ( !v6 )
  {
    if ( (dword_7DBC0 & 0x20) != 0 )
    {
      v9 = (strlen(*a1) + 4) & 0xFFFFFFFC;
      if ( *(_DWORD *)&(*a1)[v9] > *(_DWORD *)&(*a2)[(strlen(*a2) + 4) & 0xFFFFFFFC] )
        v6 = 1;
      else
        v6 = -1;
    }
    else if ( (dword_7DBC0 & 0x40000000) == 0 )
    {
      LOWORD(v4) = dword_7DBC0;
      v6 = strcmp(*a1, *a2);
    }
  }
  if ( (v4 & 0x100) != 0 )
    return -v6;
  return v6;
}
// 46244: control flows out of bounds to 46248
// 46314: variable 'v2' is possibly undefined
// 137F8: using guessed type int strptime(_DWORD, const char *, ...);
// 7D740: using guessed type int dword_7D740;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00046458) --------------------------------------------------------
int __fastcall sub_46458(int a1, char **a2)
{
  int v3; // r0
  int *v4; // r9
  int i; // r4
  _DWORD *v6; // r0
  _DWORD *v7; // r5
  char *v8; // r10
  unsigned int v9; // r0
  char *v10; // r3
  char *v11; // r10
  char *v12; // r0
  int v13; // r0
  int v14; // r3
  int v15; // r2
  _BOOL4 v16; // r0
  int v17; // r1
  signed int v18; // r5
  char **v19; // r4
  int *v20; // r7
  int v21; // r9
  int v22; // r1
  int v23; // r2
  FILE *v24; // r6
  void *v25; // r0
  void *v26; // r10
  int v27; // r2
  char *v28; // r0
  int v29; // t1
  int v30; // r6
  int v31; // r6
  int j; // r7
  char **v33; // r9
  int v34; // r0
  char **v35; // r5
  int v36; // r6
  char **v37; // r0
  char *v39; // t1
  size_t v40; // r7
  char *v41; // r0
  void **v42; // r6
  int v43; // r7
  int v44; // r9
  char **v45; // r10
  const char *v46; // t1
  char v47[4]; // [sp+14h] [bp-Ch] BYREF
  const char *v48; // [sp+18h] [bp-8h] BYREF
  char *v49; // [sp+1Ch] [bp-4h] BYREF
  _DWORD *v50; // [sp+20h] [bp+0h] BYREF
  char *endptr[2]; // [sp+24h] [bp+4h] BYREF

  v50 = 0;
  byte_7D5F8 = 2;
  v3 = sub_593CC(a2, "^ngMucszbrdfimS:T:o:k:*t:", v47, v47, &v48, &v50, &v49);
  if ( (v3 & 0x80) != 0 )
    dword_7DBC0 |= 0x80000000;
  if ( (v3 & 0x20000) != 0 )
  {
    if ( !*v49 || v49[1] )
      sub_16DBC("bad -t parameter");
    byte_7D782 = *v49;
  }
  while ( v50 )
  {
    v4 = &dword_7D740;
    for ( i = dword_7D740; i; i = *(_DWORD *)i )
      v4 = (int *)i;
    v6 = sub_174DC(0x18u);
    *v4 = (int)v6;
    v7 = v6;
    endptr[0] = (char *)sub_5D2FC(&v50);
LABEL_30:
    while ( *endptr[0] )
    {
      v8 = (char *)&v7[2 * i];
      v9 = sub_45E58((const char **)endptr);
      v10 = endptr[0];
      *((_DWORD *)v8 + 1) = v9;
      if ( *v10 == 46 )
      {
        endptr[0] = v10 + 1;
        *((_DWORD *)v8 + 2) = sub_45E58((const char **)endptr);
      }
      while ( 1 )
      {
        v17 = (unsigned __int8)*endptr[0];
        if ( !*endptr[0] )
          break;
        v11 = endptr[0] + 1;
        if ( v17 == 44 )
        {
          if ( !i )
          {
            ++endptr[0];
            i = 1;
            goto LABEL_30;
          }
          ++i;
        }
        v12 = strchr("ngMucszbrdfimS:T:o:k:*t:", v17);
        if ( !v12 )
          sub_16DBC("unknown key option");
        v13 = v12 - "ngMucszbrdfimS:T:o:k:*t:";
        v14 = 1 << v13;
        if ( ((1 << v13) & 0xFFFFF078) != 0 )
          sub_16DBC("unknown sort type");
        v15 = v7[5];
        v16 = v13 == 7;
        if ( !i )
          v16 = 0;
        endptr[0] = v11;
        if ( v16 )
          v14 = 0x80000000;
        v7[5] = v15 | v14;
      }
    }
  }
  v18 = 0;
  v19 = 0;
  v20 = (int *)&a2[optind];
  if ( !*v20 )
    *--v20 = (int)"-";
  do
  {
    v21 = 4 * v18;
    v24 = (FILE *)sub_61D20(*v20);
    while ( 1 )
    {
      v25 = (dword_7DBC0 & 0x40) != 0 ? sub_58C58(v24, 0) : sub_58D24(v24, v22, v23);
      v26 = v25;
      if ( !v25 )
        break;
      v27 = v18++;
      v28 = sub_62544(v19, 0x406u, v27);
      *(_DWORD *)&v28[v21] = v26;
      v19 = (char **)v28;
      v21 += 4;
    }
    sub_5888C(v24);
    v29 = v20[1];
    ++v20;
  }
  while ( v29 );
  if ( !dword_7D740 )
  {
    dword_7D740 = (int)sub_174DC(0x18u);
    *(_DWORD *)(dword_7D740 + 4) = 1;
  }
  v30 = dword_7DBC0 & 0x10;
  if ( (dword_7DBC0 & 0x10) == 0 )
  {
    if ( (dword_7DBC0 & 0x20) != 0 )
    {
      v33 = v19 - 1;
      while ( v30 != v18 )
      {
        v39 = v33[1];
        ++v33;
        v40 = (strlen(v39) + 4) & 0xFFFFFFFC;
        v41 = (char *)sub_174B4(v39, v40 + 4);
        *v33 = v41;
        *(_DWORD *)&v41[v40] = v30++;
      }
    }
    qsort(v19, v18, 4u, (__compar_fn_t)sub_46148);
    if ( (dword_7DBC0 & 8) != 0 )
    {
      v42 = (void **)(v19 + 1);
      v43 = 0;
      v44 = 1;
      dword_7DBC0 |= 0x40000000u;
      while ( v44 < v18 )
      {
        v45 = &v19[v43];
        if ( sub_46148(v45, (char **)v42) )
        {
          ++v43;
          v45[1] = (char *)*v42;
        }
        else
        {
          free(*v42);
        }
        ++v44;
        ++v42;
      }
      if ( v18 )
        v18 = v43 + 1;
    }
    if ( (dword_7DBC0 & 0x8000) != 0 )
    {
      v34 = sub_175D8(v48, 577);
      sub_176A8(v34, 1);
    }
    v35 = &v19[v18];
    if ( (dword_7DBC0 & 0x40) != 0 )
      v36 = 0;
    else
      v36 = 10;
    while ( v35 != v19 )
    {
      v46 = *v19++;
      printf("%s%c", v46, v36);
    }
    sub_588D8(0);
  }
  v31 = dword_7DBC0 << 28 >> 31;
  for ( j = 1; j < v18; ++j )
  {
    v37 = v19++;
    if ( sub_46148(v37, v19) > v31 )
    {
      fprintf((FILE *)stderr, "Check line %u\n", j);
      return 1;
    }
  }
  return 0;
}
// 4669C: variable 'v22' is possibly undefined
// 4669C: variable 'v23' is possibly undefined
// 7D5F8: using guessed type char byte_7D5F8;
// 7D604: using guessed type int optind;
// 7D608: using guessed type int stderr;
// 7D740: using guessed type int dword_7D740;
// 7D782: using guessed type char byte_7D782;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0004689C) --------------------------------------------------------
unsigned int __fastcall sub_4689C(unsigned int result, int a2, unsigned int *a3)
{
  unsigned int v3; // r3
  int v4; // r12
  int v5; // lr
  int v6; // r3
  int v7; // r3
  bool v8; // zf
  unsigned int v9; // r3
  unsigned int v10; // r3
  unsigned int v11; // r0
  unsigned int v12; // r3
  unsigned int v13; // r3
  int i; // r3
  unsigned __int8 v15; // r12
  int v16; // r1
  unsigned __int8 *v17; // r3
  unsigned int v18; // r1
  int v19; // r1
  int v20; // r1
  unsigned int v21; // r3
  unsigned int v22; // r3
  unsigned int v23; // r0
  unsigned int v24; // r3
  int v25; // r3
  unsigned int v26; // r12
  unsigned int v27; // r0
  unsigned int v28; // r3
  int v29; // r3
  unsigned int v30; // r12
  unsigned int v31; // r3
  unsigned int v32; // r3
  unsigned int v33; // r3
  bool v34; // zf
  unsigned int v35; // r12
  unsigned int v36; // r0
  unsigned int v37; // r3
  unsigned int v38; // r12

  v3 = *(unsigned __int8 *)result;
  if ( v3 <= 3 )
  {
    v4 = (unsigned __int8)asc_6A3C6[v3];
    if ( (unsigned int *)((char *)a3 + v4) )
    {
      v5 = *(unsigned __int16 *)(result + 2);
      result = *(_DWORD *)(result + 4);
      v6 = *(unsigned int *)((char *)a3 + v4) & ~v5;
      if ( a2 )
        v7 = v6 & ~result;
      else
        v7 = v6 | result;
      *(unsigned int *)((char *)a3 + v4) = v7;
      return result;
    }
  }
  v8 = result == (_DWORD)&unk_63A04;
  if ( (_UNKNOWN *)result != &unk_63A04 )
    v8 = result == (_DWORD)&unk_639FC;
  if ( v8 )
  {
    v9 = a3[2];
    if ( !a2 )
    {
      v10 = v9 & 0xFFFFFCCF | 0x120;
LABEL_18:
      a3[2] = v10;
      return result;
    }
LABEL_13:
    v10 = v9 & 0xFFFFFECF | 0x30;
    goto LABEL_18;
  }
  if ( (_UNKNOWN *)result == &unk_63A0C )
  {
    v9 = a3[2];
    if ( !a2 )
    {
      v10 = v9 & 0xFFFFFCCF | 0x320;
      goto LABEL_18;
    }
    goto LABEL_13;
  }
  if ( (_UNKNOWN *)result == &unk_63A14 )
  {
    v11 = *a3;
    v12 = a3[1];
    if ( a2 )
    {
      v11 &= 0xFFFFFE3F;
      v13 = v12 & 0xFFFFFFD3 | 4;
    }
    else
    {
      v13 = v12 & 0xFFFFFFFB;
    }
    if ( a2 )
      result = v11 | 0x100;
    else
      result = v11 & 0xFFFFFEFF;
    *a3 = result;
    goto LABEL_27;
  }
  if ( (_UNKNOWN *)result == &unk_63A1C )
  {
    *((_BYTE *)a3 + 19) = 127;
    *((_BYTE *)a3 + 20) = 21;
    return result;
  }
  if ( (_UNKNOWN *)result == &unk_63A24 )
  {
    result = (unsigned int)byte_643C2;
    for ( i = 0; i != 34; i += 2 )
    {
      v15 = byte_643C2[i];
      v16 = byte_643C2[i + 1];
      *((_BYTE *)a3 + v16 + 17) = v15;
    }
    v17 = (unsigned __int8 *)&unk_639FC;
    while ( 1 )
    {
      v18 = *v17;
      if ( v18 > 3 )
        goto LABEL_41;
      result = (unsigned __int8)asc_6A3C6[v18];
      if ( !(unsigned int *)((char *)a3 + result) )
        goto LABEL_41;
      v19 = *(unsigned int *)((char *)a3 + result) & ~*((unsigned __int16 *)v17 + 1);
      if ( (v17[1] & 1) != 0 )
        break;
      if ( (v17[1] & 2) != 0 )
      {
        v20 = v19 & ~*((_DWORD *)v17 + 1);
        goto LABEL_40;
      }
LABEL_41:
      v17 += 8;
      if ( &unk_63CC4 == (_UNKNOWN *)v17 )
        return result;
    }
    v20 = *((_DWORD *)v17 + 1) | v19;
LABEL_40:
    *(unsigned int *)((char *)a3 + result) = v20;
    goto LABEL_41;
  }
  if ( (_UNKNOWN *)result == &unk_63A4C )
  {
    v21 = a3[3];
    if ( a2 )
      v22 = v21 | 2;
    else
      v22 = v21 & 0xFFFFFFFD;
    goto LABEL_47;
  }
  if ( (_UNKNOWN *)result == &unk_63A3C )
  {
    v23 = *a3;
    v24 = a3[2] & 0xFFFFFECF;
    if ( a2 )
    {
      v25 = v24 | 0x120;
      result = v23 | 0x20;
    }
    else
    {
      v25 = v24 | 0x30;
      result = v23 & 0xFFFFFFDF;
    }
    a3[2] = v25;
    *a3 = result;
    return result;
  }
  if ( (_UNKNOWN *)result != &unk_63A44 )
  {
    if ( (_UNKNOWN *)result == &unk_63A34 )
    {
      if ( a2 )
        goto LABEL_68;
    }
    else
    {
      if ( (_UNKNOWN *)result != &unk_63A2C )
      {
        if ( (_UNKNOWN *)result == &unk_63A64 )
        {
          v31 = *a3;
          if ( a2 )
          {
            v32 = v31 | 0x800;
LABEL_64:
            *a3 = v32;
            return result;
          }
LABEL_63:
          v32 = v31 & 0xFFFFF7FF;
          goto LABEL_64;
        }
        if ( (_UNKNOWN *)result == &unk_63A6C )
        {
          v33 = a3[1];
          if ( a2 )
            v13 = v33 | 0x1800;
          else
            v13 = v33 & 0xFFFFE7FF;
LABEL_27:
          a3[1] = v13;
          return result;
        }
        v34 = result == (_DWORD)&unk_63A7C;
        if ( (_UNKNOWN *)result != &unk_63A7C )
          v34 = result == (_DWORD)&unk_63A74;
        if ( v34 )
        {
          v35 = a3[3];
          v36 = *a3;
          v37 = a3[1];
          if ( a2 )
            v38 = v35 & 0xFFFFFFFB;
          else
            v38 = v35 | 4;
          if ( a2 )
            result = v36 & 0xFFFFFDFF;
          else
            result = v36 | 0x200;
          if ( a2 )
          {
            a3[3] = v38;
            v13 = v37 & 0xFFFFFFFD;
          }
          else
          {
            v13 = v37 | 2;
            a3[3] = v38;
          }
          *a3 = result;
          goto LABEL_27;
        }
        if ( (_UNKNOWN *)result != &unk_63A54 )
        {
          if ( (_UNKNOWN *)result != &unk_63A5C )
            return result;
          *((_BYTE *)a3 + 17) = 3;
          *((_BYTE *)a3 + 19) = 127;
          *((_BYTE *)a3 + 20) = 21;
          a3[3] |= 0xA10u;
          v31 = *a3;
          goto LABEL_63;
        }
        v22 = a3[3] | 0xA10;
LABEL_47:
        a3[3] = v22;
        return result;
      }
      if ( !a2 )
      {
LABEL_68:
        *a3 |= 0x526u;
        a3[1] |= 1u;
        v22 = a3[3] | 3;
        goto LABEL_47;
      }
    }
    *a3 = 0;
    a3[1] &= ~1u;
    a3[3] &= 0xFFFFFFF8;
    *((_WORD *)a3 + 11) = 256;
    return result;
  }
  v26 = *a3;
  v27 = a3[1];
  v28 = a3[2] & 0xFFFFFECF;
  if ( a2 )
  {
    v29 = v28 | 0x120;
    v30 = v26 | 0x20;
    result = v27 | 1;
  }
  else
  {
    v29 = v28 | 0x30;
    v30 = v26 & 0xFFFFFFDF;
    result = v27 & 0xFFFFFFFE;
  }
  a3[2] = v29;
  *a3 = v30;
  a3[1] = result;
  return result;
}
// 643C2: using guessed type unsigned __int8 byte_643C2[30];

//----- (00046C5C) --------------------------------------------------------
int __fastcall sub_46C5C(_DWORD *a1)
{
  unsigned __int8 *v1; // r4
  unsigned __int8 *v2; // r5
  int v3; // t1

  v1 = (unsigned __int8 *)a1 + 49;
  v2 = (unsigned __int8 *)a1 + 17;
  printf("%lx:%lx:%lx:%lx", *a1, a1[1], a1[2], a1[3]);
  do
  {
    v3 = *v2++;
    printf(":%x", v3);
  }
  while ( v2 != v1 );
  return j_putchar_unlocked(10);
}

//----- (00046CB4) --------------------------------------------------------
int sub_46CB4(const char *a1, ...)
{
  int result; // r0
  int v2; // r5
  int v3; // r6
  tcflag_t v4; // r3
  tcflag_t v5; // r3
  bool v6; // cf
  int v7; // r0
  va_list v8; // [sp+4h] [bp-84h]
  char s[144]; // [sp+8h] [bp-80h] BYREF
  va_list varg_r1; // [sp+9Ch] [bp+14h] BYREF

  va_start(varg_r1, a1);
  va_copy(v8, varg_r1);
  result = vsnprintf(s, 0x80u, a1, varg_r1);
  v2 = result - 1;
  if ( (unsigned int)(result - 1) <= 0x7E )
  {
    v3 = result;
    if ( buf.c_cflag )
    {
      v4 = ++buf.c_cflag;
      if ( s[0] != 10 )
      {
        v5 = v4 + result;
        v6 = v5 >= buf.c_oflag;
        if ( v5 < buf.c_oflag )
        {
          v7 = 32;
        }
        else
        {
          LOBYTE(v5) = 0;
          v7 = 10;
        }
        if ( v6 )
        {
          LOBYTE(buf.c_cflag) = v5;
          BYTE1(buf.c_cflag) = v5;
          BYTE2(buf.c_cflag) = v5;
          HIBYTE(buf.c_cflag) = v5;
        }
        j_putchar_unlocked(v7);
      }
    }
    fputs_unlocked(s, stdout);
    result = buf.c_cflag + v3;
    buf.c_cflag += v3;
    if ( s[v2] == 10 )
      buf.c_cflag = 0;
  }
  return result;
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;

//----- (00046D90) --------------------------------------------------------
int sub_46D90()
{
  int result; // r0

  if ( buf.c_cflag )
    return sub_46CB4("\n");
  return result;
}

//----- (00046DB0) --------------------------------------------------------
int __fastcall sub_46DB0(char *s2)
{
  int v1; // r0

  v1 = sub_16880("evenp", s2);
  if ( v1 < 0 )
    return 0;
  else
    return (int)&unk_639FC + 8 * v1;
}

//----- (00046DDC) --------------------------------------------------------
int __fastcall sub_46DDC(char *s2)
{
  int v1; // r3
  int result; // r0

  v1 = sub_16880("line", s2);
  result = v1 + 1;
  if ( v1 != -1 && (unsigned int)(v1 - 4) > 1 )
    return result | 0x80;
  return result;
}

//----- (00046E0C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_46E0C(unsigned __int8 *result, const char *a2, int a3)
{
  unsigned __int8 *v4; // r7
  bool v6; // zf
  int v7; // r4
  int v8; // r8

  v4 = result;
  v6 = result == (unsigned __int8 *)&unk_643E2;
  if ( result != (unsigned __int8 *)&unk_643E2 )
    v6 = result == (unsigned __int8 *)&unk_643E0;
  if ( v6 )
    goto LABEL_5;
  v7 = *(unsigned __int8 *)a2;
  if ( *a2 )
  {
    v8 = *((unsigned __int8 *)a2 + 1);
    if ( a2[1] )
    {
      result = (unsigned __int8 *)strcmp(a2, "^-");
      if ( !result || (result = (unsigned __int8 *)strcmp(a2, "undef")) == 0 )
      {
        LOBYTE(v7) = (_BYTE)result;
        goto LABEL_6;
      }
      if ( v7 == 94 )
      {
        if ( v8 == 63 )
          LOBYTE(v7) = 127;
        else
          LOBYTE(v7) = v8 & 0x1F;
        goto LABEL_6;
      }
LABEL_5:
      result = (unsigned __int8 *)sub_6204C(a2, 0, 0xFFu, (int)&unk_63CC4);
      LOBYTE(v7) = (_BYTE)result;
    }
  }
LABEL_6:
  *(_BYTE *)(a3 + v4[1] + 17) = v7;
  return result;
}

//----- (00046EC8) --------------------------------------------------------
void __fastcall sub_46EC8(int a1, int a2)
{
  const char *v3; // r0
  int v4; // [sp+0h] [bp-8h] BYREF
  int v5; // [sp+4h] [bp-4h] BYREF

  v4 = a1;
  v5 = a2;
  if ( sub_1714C(0, &v4, &v5) )
  {
    if ( *(_DWORD *)dword_7DB94 == 22 )
    {
      if ( !a1 )
        sub_16AF4("");
    }
    else
    {
      sub_16AF4("%s", buf.c_iflag);
    }
  }
  else
  {
    v3 = "rows %u; columns %u;";
    if ( !a1 )
      v3 = "%u %u\n";
    sub_46CB4(v3, v5, v4);
  }
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00046F5C) --------------------------------------------------------
int __fastcall sub_46F5C(const struct termios *a1, int a2)
{
  speed_t v4; // r5
  speed_t v5; // r0
  const char *v6; // r4
  _BOOL4 v7; // r3
  int v8; // r6
  int v9; // r5
  int v10; // r0

  v4 = cfgetispeed(a1);
  v5 = cfgetospeed(a1);
  v6 = "%lu %lu\n";
  v7 = v4 == v5;
  if ( !v4 )
    v7 = 1;
  v8 = v5;
  if ( v7 )
  {
    v4 = v5;
    v6 = "%lu\n";
  }
  if ( a2 )
    v6 += 9;
  v9 = sub_60ED8(v4);
  v10 = sub_60ED8(v8);
  return sub_46CB4(v6, v9, v10);
}

//----- (00046FD8) --------------------------------------------------------
int __fastcall sub_46FD8(const struct termios *a1, int a2)
{
  int v4; // r1
  int v5; // r4
  char *v6; // r3
  char *v7; // r0
  unsigned __int8 *v8; // r4
  const char *v9; // r2
  int v10; // r11
  unsigned __int8 v11; // r5
  const char *v12; // r8
  unsigned int v13; // r1
  bool v14; // cc
  int v15; // r2
  int v16; // r1
  char *v17; // r1
  char *v19; // r1
  unsigned int v20; // [sp+4h] [bp-18h]
  char dest[16]; // [sp+Ch] [bp-10h] BYREF

  sub_46F5C(a1, 1);
  if ( a2 )
    sub_46EC8(1, v4);
  v5 = 0;
  sub_46CB4("line = %u;\n", a1->c_line);
  do
  {
    v6 = (char *)a1 + byte_643C2[2 * v5 + 1];
    if ( v6[17] )
      sub_5E550((unsigned __int8)v6[17], dest, 0);
    else
      strcpy(dest, "<undef>");
    v7 = sub_16964("intr", v5++);
    sub_46CB4("%s = %s;", v7, dest);
  }
  while ( v5 != 15 );
  v8 = (unsigned __int8 *)&unk_639FC;
  sub_46CB4("min = %u; time = %u;", a1->c_cc[6], a1->c_cc[5]);
  sub_46D90();
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    v11 = v8[1];
    if ( (v11 & 8) != 0 )
    {
      v12 = v9;
      goto LABEL_30;
    }
    v13 = *v8;
    v12 = (const char *)v13;
    if ( (const char *)v13 != v9 )
    {
      v20 = *v8;
      sub_46D90();
      v13 = v20;
    }
    v14 = v13 > 3;
    if ( v13 > 3 )
      v13 = 0;
    else
      v9 = "\b";
    if ( !v14 )
      v13 = (unsigned __int8)v9[v13];
    v15 = *((unsigned __int16 *)v8 + 1);
    if ( !v14 )
      v13 += (unsigned int)a1;
    v16 = *(_DWORD *)v13;
    if ( !*((_WORD *)v8 + 1) )
      v15 = *((_DWORD *)v8 + 1);
    if ( (v15 & v16) == *((_DWORD *)v8 + 1) )
    {
      if ( a2 || (v11 & 2) != 0 )
      {
        v17 = sub_16964("evenp", v10);
        sub_46CB4("%s", v17);
      }
    }
    else
    {
      if ( a2 )
      {
        if ( (v11 & 4) == 0 )
          goto LABEL_30;
      }
      else if ( (v11 & 5) != 5 )
      {
        goto LABEL_30;
      }
      v19 = sub_16964("evenp", v10);
      sub_46CB4("-%s", v19);
    }
LABEL_30:
    ++v10;
    v8 += 8;
    if ( v10 == 89 )
      return sub_46D90();
    v9 = v12;
  }
}
// 46FFC: variable 'v4' is possibly undefined
// 470CC: variable 'v9' is possibly undefined
// 643C2: using guessed type unsigned __int8 byte_643C2[30];

//----- (000471B0) --------------------------------------------------------
bool __fastcall sub_471B0(const char *a1, int a2)
{
  _BYTE *v5; // r6
  _BYTE *v6; // r4
  const char *v7; // r5
  int v8; // [sp+10h] [bp+0h] BYREF
  int v9; // [sp+14h] [bp+4h] BYREF
  int v10; // [sp+18h] [bp+8h] BYREF
  int v11; // [sp+1Ch] [bp+Ch] BYREF
  int v12; // [sp+20h] [bp+10h] BYREF
  int v13; // [sp+24h] [bp+14h] BYREF

  if ( sscanf(a1, "%lx:%lx:%lx:%lx%n", &v10, &v11, &v12, &v13, &v8) == 4 )
  {
    v5 = (_BYTE *)(a2 + 17);
    v6 = (_BYTE *)(a2 + 49);
    *(_DWORD *)(v6 - 49) = v10;
    *(_DWORD *)(v6 - 45) = v11;
    *(_DWORD *)(v6 - 41) = v12;
    *(_DWORD *)(v6 - 37) = v13;
    v7 = &a1[v8];
    while ( sscanf(v7, ":%x%n", &v9, &v8) == 1 )
    {
      *v5++ = v9;
      v7 += v8;
      if ( v5 == v6 )
        return *v7 == 0;
    }
  }
  return 0;
}

//----- (0004727C) --------------------------------------------------------
int __fastcall sub_4727C(int a1, const char *a2, struct termios *a3)
{
  unsigned int v5; // r0
  speed_t v6; // r0
  speed_t v7; // r6
  int result; // r0

  v5 = sub_620B0(a2);
  v6 = sub_60F24(v5);
  v7 = v6;
  if ( a1 == 1 )
    return cfsetospeed(a3, v7);
  result = cfsetispeed(a3, v6);
  if ( a1 )
    return cfsetospeed(a3, v7);
  return result;
}

//----- (000472C8) --------------------------------------------------------
void __fastcall __noreturn sub_472C8(const char *a1)
{
  sub_16B40(a1, buf.c_iflag);
}

//----- (000472DC) --------------------------------------------------------
void __fastcall sub_472DC(int a1, int a2, int a3, int a4)
{
  int v6; // r3
  int v7; // [sp+0h] [bp-8h] BYREF
  int v8; // [sp+4h] [bp-4h]

  v7 = 0;
  v8 = 0;
  if ( ioctl(0, 0x5413u, &v7, a4) )
  {
    v6 = *(_DWORD *)dword_7DB94;
    if ( *(_DWORD *)dword_7DB94 != 22 )
    {
LABEL_3:
      sub_16AF4("%s", (const char *)buf.c_iflag);
      return;
    }
    v7 = 0;
    v8 = 0;
  }
  if ( a1 >= 0 )
    LOWORD(v7) = a1;
  if ( a2 >= 0 )
    HIWORD(v7) = a2;
  if ( ioctl(0, 0x5414u, &v7, v6, v7, v8) )
    goto LABEL_3;
}
// 4735C: variable 'v6' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;

//----- (00047378) --------------------------------------------------------
int __fastcall sub_47378(int a1, int a2)
{
  int v2; // r5
  int v4; // r4
  const char *v5; // r7
  void (__fastcall *v6)(_DWORD *); // r10
  int v7; // r9
  char *v8; // r11
  int v9; // r1
  const char *v10; // r6
  int v11; // r0
  _DWORD *v12; // r2
  unsigned __int8 *v13; // r0
  int v14; // r12
  int v15; // r1
  int v16; // t1
  const char *v17; // r1
  int v19; // r0
  unsigned __int8 *v20; // r0
  int v21; // r0
  unsigned int v22; // r0
  const char *v23; // r1
  int v24; // r0
  int v25; // r0
  int v26; // r1
  int v27; // r2
  const char *v28; // r0
  const char *v30; // r10
  unsigned int v31; // r0
  int v32; // r1
  int v33; // r7
  char *v34; // r6
  char v35; // r5
  int v36; // r0
  int v37; // r0
  int v38; // r1
  const char *v39; // r1
  int v40; // r0
  unsigned int v41; // r1
  int v42; // r2
  int v43; // r3
  unsigned int v44; // r0
  _DWORD *v45; // [sp+Ch] [bp-80h]
  struct termios s; // [sp+10h] [bp-7Ch] BYREF
  struct termios termios_p; // [sp+4Ch] [bp-40h] BYREF

  v2 = 0;
  v4 = 16;
  v5 = 0;
  v6 = (void (__fastcall *)(_DWORD *))sub_46FD8;
  buf.c_iflag = (tcflag_t)"standard input";
  buf.c_oflag = 80;
  buf.c_cflag = 0;
  while ( 1 )
  {
    v7 = v2 + 1;
    v8 = *(char **)(a2 + 4 * (v2 + 1));
    v9 = 4 * (v2 + 1);
    if ( !v8 )
      break;
    v10 = *(const char **)(a2 + v9 + 4);
    if ( *v8 == 45 )
    {
      v45 = (_DWORD *)(a2 + v9 + 4);
      v11 = sub_46DB0(v8 + 1);
      v12 = v45;
      if ( v11 )
      {
        if ( (*(_BYTE *)(v11 + 1) & 4) == 0 )
          goto LABEL_16;
        v4 &= ~0x10u;
      }
      else
      {
        v13 = (unsigned __int8 *)(v8 + 1);
        while ( 1 )
        {
          while ( 1 )
          {
            v14 = v13 - (unsigned __int8 *)v8;
            v16 = *v13++;
            v15 = v16;
            if ( !v16 )
              goto LABEL_10;
            if ( v15 != 97 )
              break;
            v6 = (void (__fastcall *)(_DWORD *))sub_46FD8;
            v4 |= 4u;
          }
          if ( v15 != 103 )
            break;
          v4 |= 8u;
          v6 = (void (__fastcall *)(_DWORD *))sub_46C5C;
        }
        if ( v15 != 70 )
LABEL_16:
          sub_16DBC("invalid argument '%s'", v8);
        if ( v5 )
          sub_16DBC("only one device may be specified", 70);
        v5 = &v8[v14 + 1];
        if ( !*v5 )
        {
          if ( !v10 )
          {
            v17 = "-F";
            goto LABEL_23;
          }
          while ( *v12++ )
            *(v12 - 1) = *v12;
          v5 = v10;
        }
      }
    }
    else
    {
      v4 &= ~0x10u;
      if ( sub_46DB0(*(char **)(a2 + 4 * (v2 + 1))) )
        goto LABEL_10;
      v19 = sub_16880("intr", v8);
      if ( v19 < 0 )
      {
        v21 = sub_46DDC(v8);
        if ( (v21 & 0x80) != 0 )
        {
          if ( !v10 )
          {
LABEL_30:
            v17 = v8;
LABEL_23:
            sub_16DBC("%s requires an argument", v17);
          }
          v7 = v2 + 2;
        }
        if ( v21 > 132 )
        {
          if ( v21 == 135 )
          {
            v23 = v10;
            v24 = 0;
            goto LABEL_46;
          }
          if ( v21 == 136 )
          {
            v23 = v10;
            v24 = 1;
LABEL_46:
            sub_4727C(v24, v23, &s);
            goto LABEL_10;
          }
        }
        else
        {
          if ( v21 >= 129 )
          {
            sub_6204C(v10, 1u, 0x7FFFFFFFu, (int)&unk_63CC4);
            goto LABEL_10;
          }
          if ( (unsigned int)(v21 - 5) <= 1 )
            goto LABEL_10;
        }
        if ( !sub_471B0(v8, (int)&s) )
        {
          v22 = sub_620B0(v8);
          if ( sub_60F24(v22) == -1 )
            goto LABEL_16;
        }
      }
      else
      {
        v20 = &byte_643C2[2 * v19];
        if ( !v10 )
          goto LABEL_30;
        sub_46E0C(v20, v10, (int)&s);
        v7 = v2 + 2;
      }
    }
LABEL_10:
    v2 = v7;
  }
  if ( (v4 & 0xC) == 0xC )
    sub_16DBC("-a and -g are mutually exclusive", v9);
  if ( (v4 & 0xC) != 0 && (v4 & 0x10) == 0 )
    sub_16DBC("modes may not be set when -a or -g is used", v9);
  if ( v5 )
  {
    buf.c_iflag = (tcflag_t)v5;
    v25 = sub_17614(v5);
    sub_176A8(v25, 0);
    sub_16E68(0);
  }
  memset(&s, 0, sizeof(s));
  if ( tcgetattr(0, &s) )
    goto LABEL_53;
  if ( v4 )
  {
    buf.c_oflag = sub_17280(1, v26, v27);
    v6(&s);
    return 0;
  }
  v35 = 0;
  while ( 2 )
  {
    v33 = v4 + 1;
    v34 = *(char **)(a2 + 4 * (v4 + 1));
    if ( v34 )
    {
      v30 = *(const char **)(a2 + 4 * (v4 + 1) + 4);
      if ( *v34 == 45 )
      {
        v31 = sub_46DB0(v34 + 1);
        if ( !v31 )
        {
LABEL_61:
          v4 = v33;
          continue;
        }
        v32 = 1;
        goto LABEL_70;
      }
      v31 = sub_46DB0(*(char **)(a2 + 4 * (v4 + 1)));
      if ( v31 )
      {
        v32 = 0;
LABEL_70:
        sub_4689C(v31, v32, &s.c_iflag);
LABEL_71:
        v35 |= 1u;
        goto LABEL_61;
      }
      v36 = sub_16880("intr", v34);
      if ( v36 >= 0 )
      {
        v33 = v4 + 2;
        sub_46E0C(&byte_643C2[2 * v36], v30, (int)&s);
        goto LABEL_71;
      }
      v37 = sub_46DDC(v34);
      if ( (v37 & 0x80) != 0 )
        v33 = v4 + 2;
      if ( v37 != 130 )
      {
        if ( v37 <= 130 )
        {
          switch ( v37 )
          {
            case 6:
              sub_46F5C(&s, 0);
              goto LABEL_61;
            case 129:
              s.c_line = sub_62090(v30, (int)&unk_63CC4);
              goto LABEL_71;
            case 5:
              sub_46EC8(0, v38);
              goto LABEL_61;
          }
          goto LABEL_81;
        }
        if ( v37 == 135 )
        {
          v39 = v30;
          v40 = 0;
          goto LABEL_95;
        }
        if ( v37 > 135 )
        {
          if ( v37 == 136 )
          {
            v39 = v30;
            v40 = 1;
            goto LABEL_95;
          }
        }
        else if ( v37 <= 132 )
        {
          v41 = sub_62090(v30, (int)&unk_63CC4);
          v44 = -1;
LABEL_87:
          sub_472DC(v44, v41, v42, v43);
          goto LABEL_61;
        }
LABEL_81:
        if ( sub_471B0(v34, (int)&s) )
          goto LABEL_71;
        v39 = v34;
        v40 = 2;
LABEL_95:
        sub_4727C(v40, v39, &s);
        v35 = 3;
        goto LABEL_61;
      }
      v44 = sub_62090(v30, (int)&unk_63CC4);
      v41 = -1;
      goto LABEL_87;
    }
    break;
  }
  if ( (v35 & 1) == 0 )
    return 0;
  if ( tcsetattr(*(_DWORD *)(a2 + 4 * (v4 + 1)), 1, &s)
    || (memset(&termios_p, 0, sizeof(termios_p)), tcgetattr(0, &termios_p)) )
  {
LABEL_53:
    v28 = "%s";
    goto LABEL_54;
  }
  if ( memcmp(&s, &termios_p, 0x3Cu) )
  {
    v28 = "%s: cannot perform all requested operations";
LABEL_54:
    sub_472C8(v28);
  }
  return 0;
}
// 47664: variable 'v26' is possibly undefined
// 47664: variable 'v27' is possibly undefined
// 47800: variable 'v42' is possibly undefined
// 47800: variable 'v43' is possibly undefined
// 47838: variable 'v38' is possibly undefined
// 643C2: using guessed type unsigned __int8 byte_643C2[30];

//----- (000478C8) --------------------------------------------------------
int sub_478C8()
{
  sync();
  return 0;
}

//----- (000478D8) --------------------------------------------------------
unsigned int __fastcall sub_478D8(const char *a1)
{
  int v1; // r3

  v1 = *(unsigned __int8 *)a1;
  if ( v1 == 45 )
  {
    ++a1;
  }
  else if ( v1 == 43 )
  {
    ++a1;
    LOBYTE(buf.c_iflag) = 1;
  }
  return sub_62090(a1, (int)&unk_64174);
}

//----- (0004790C) --------------------------------------------------------
int __fastcall sub_4790C(int a1, char **a2)
{
  char *v3; // r0
  char **v4; // r5
  size_t v5; // r4
  char v6; // r8
  int v7; // r3
  int v8; // r7
  int v9; // r6
  int v10; // r5
  __int64 v11; // r0
  size_t v12; // r9
  int v13; // r3
  char *v14; // r6
  int v15; // r11
  int v16; // r3
  const char *v17; // r5
  int v18; // r7
  int *v19; // r9
  int v20; // r4
  int v21; // t1
  const char *v22; // r6
  int v23; // r1
  __int64 v24; // r0
  ssize_t v25; // r0
  size_t v26; // r11
  signed int v27; // r7
  char *v28; // r3
  unsigned int v29; // r10
  signed int v30; // r5
  signed int v31; // r2
  int v32; // r1
  size_t v33; // r1
  char *v34; // r2
  int v35; // t1
  size_t v36; // r7
  int v37; // r2
  unsigned int v38; // r2
  char *v39; // r1
  int v40; // t1
  bool v41; // zf
  int v42; // r10
  const char *v43; // r2
  unsigned int v45; // [sp+Ch] [bp-118h]
  int v46; // [sp+10h] [bp-114h]
  char **v47; // [sp+14h] [bp-110h]
  unsigned int v48; // [sp+18h] [bp-10Ch]
  _DWORD *v49; // [sp+1Ch] [bp-108h]
  __int64 v50; // [sp+20h] [bp-104h]
  int v51; // [sp+20h] [bp-104h]
  char *buf; // [sp+28h] [bp-FCh]
  __int64 bufa; // [sp+28h] [bp-FCh]
  const char *v54; // [sp+30h] [bp-F4h]
  int v55; // [sp+38h] [bp-ECh]
  char *v56; // [sp+3Ch] [bp-E8h]
  _BOOL4 v57; // [sp+3Ch] [bp-E8h]
  unsigned int seconds; // [sp+44h] [bp-E0h] BYREF
  const char *v59; // [sp+48h] [bp-DCh] BYREF
  const char *v60; // [sp+4Ch] [bp-D8h] BYREF
  __int64 v61; // [sp+50h] [bp-D4h]
  __int64 v62; // [sp+B0h] [bp-74h]
  __int64 v63; // [sp+B8h] [bp-6Ch]
  int v64; // [sp+C8h] [bp-5Ch]
  __int64 v65; // [sp+E8h] [bp-3Ch]
  __int64 v66; // [sp+118h] [bp-Ch]

  v3 = a2[1];
  v4 = a2;
  seconds = 1;
  if ( !v3 || ((*v3 - 43) & 0xFD) != 0 || (unsigned int)(unsigned __int8)v3[1] - 48 > 9 )
  {
    v5 = 10;
  }
  else
  {
    v4 = a2 + 1;
    v5 = sub_478D8(v3);
    --a1;
  }
  v6 = sub_593CC(v4, "^fc:n:qs:+vF", &v59, &v60, &seconds);
  if ( (v6 & 2) != 0 )
    v5 = sub_478D8(v59);
  if ( (v6 & 4) != 0 )
    v5 = sub_478D8(v60);
  if ( (v6 & 8) != 0 )
    v7 = -1;
  else
    v7 = 1;
  if ( (v6 & 0x20) != 0 )
    v7 = 0;
  v48 = v7;
  v8 = optind;
  v9 = a1 - optind;
  v47 = &v4[optind];
  v49 = sub_1748C(4 * (v9 + 1));
  if ( !v4[v8] )
  {
    if ( !sub_62E08() && (v64 & 0xF000) == 0x1000 )
      v6 &= ~1u;
    *v47 = "standard input";
  }
  v10 = 0;
  v45 = 0;
  do
  {
    LODWORD(v11) = sub_61D34((int)v47[v10]);
    if ( (int)v11 >= 0 || (v6 & 0x40) != 0 )
    {
      v49[v45] = v11;
      HIDWORD(v11) = v47;
      v47[v45++] = v47[v10];
    }
    else
    {
      BYTE1(::buf.c_iflag) = 1;
    }
    ++v10;
  }
  while ( v9 > v10 );
  if ( !v45 )
    sub_16DBC("no files");
  if ( LOBYTE(::buf.c_iflag) || (v6 & 2) == 0 )
  {
    v12 = 0x2000;
  }
  else
  {
    v12 = v5 + 0x2000;
    if ( v5 >= 0xFFFFE000 )
      v12 = 0x2000;
  }
  v13 = v5 | 0xF;
  if ( (v5 | 0xF) >= 0x7FFF )
    v13 = 0x7FFF;
  v55 = v13 << 16;
  v54 = "==> %s <==\n";
  v46 = 0;
  v14 = 0;
  do
  {
    v15 = v49[v46];
    if ( v15 < 0 )
      goto LABEL_48;
    if ( v48 < v45 )
    {
      if ( dprintf(1, v54, v47[v46]) < 0 )
LABEL_38:
        sub_5E304();
      v54 = "\n==> %s <==\n";
    }
    if ( !LOBYTE(::buf.c_iflag) )
    {
      v11 = lseek64(v15, HIDWORD(v11));
      if ( v11 >= 1 )
      {
        if ( (v6 & 2) != 0 )
        {
          if ( v5 )
          {
            LODWORD(v50) = v11 - v5;
            HIDWORD(v50) = v11 - v5;
            if ( (int)(v11 - v5) < 0 )
              v50 = 0;
            sub_1771C(v15, SHIDWORD(v11), v50, 0);
            v11 = sub_17F2C(v15, 1, v5);
          }
          goto LABEL_48;
        }
        bufa = v11 - (unsigned int)v55;
        if ( bufa < 0 )
          bufa = 0;
        sub_1771C(v15, SHIDWORD(v11), bufa, 0);
      }
    }
    if ( !v14 )
      v14 = (char *)sub_1748C(v12);
    v27 = 0;
    v28 = v14;
    v29 = 1;
    v30 = 0;
LABEL_75:
    while ( 1 )
    {
      v56 = v28;
      LODWORD(v11) = sub_18050(v15, v28, v12 - v30);
      v28 = v56;
      if ( (int)v11 < 0 )
        break;
      if ( !(_DWORD)v11 )
        goto LABEL_77;
      if ( LOBYTE(::buf.c_iflag) )
      {
        if ( v5 <= v29 )
        {
          v31 = v11;
          goto LABEL_80;
        }
        if ( (v6 & 2) != 0 )
        {
          v38 = v29 - v5;
          v29 += v11;
          v31 = v38 + v11;
        }
        else
        {
          v39 = v56;
          v31 = v11;
          while ( 1 )
          {
            v40 = (unsigned __int8)*v39++;
            --v31;
            if ( v40 == 10 && v5 == ++v29 )
              break;
            if ( !v31 )
              goto LABEL_75;
          }
        }
        if ( v31 > 0 )
        {
LABEL_80:
          sub_176C8(1, &v56[v11 - v31], v31);
          v28 = v56;
        }
      }
      else if ( v5 )
      {
        v32 = v6 & 2;
        if ( (v6 & 2) != 0 )
        {
          v30 += v11;
          if ( v30 > (int)v5 )
          {
            v33 = v30 - v5;
            v30 = v5;
            memmove(v14, &v14[v33], v5);
          }
        }
        else
        {
          v34 = &v56[v11];
          do
          {
            v35 = (unsigned __int8)*--v34;
            if ( v35 == 10 )
              ++v32;
          }
          while ( v56 != v34 );
          v27 += v32;
          if ( v27 >= (int)v5 )
          {
            HIDWORD(v11) = v14;
            v36 = (v56[(_DWORD)v11 - 1] != 10) + v27 - v5;
            while ( v36 )
            {
              v37 = (unsigned __int8)*(_BYTE *)HIDWORD(v11);
              ++HIDWORD(v11);
              if ( v37 == 10 )
                --v36;
            }
            v57 = v56[(_DWORD)v11 - 1] != 10;
            v30 += v11 - (HIDWORD(v11) - (_DWORD)v14);
            memmove(v14, (const void *)HIDWORD(v11), v30);
            v27 = v5 - v57;
          }
          else
          {
            v30 += v11;
          }
          if ( v30 + 0x2000 > v12 )
          {
            v12 = v30 + 0x2000;
            v14 = (char *)sub_174B4(v14, v30 + 0x2000);
          }
        }
        v28 = &v14[v30];
      }
    }
    sub_16AF4("read error");
    BYTE1(::buf.c_iflag) = 1;
LABEL_77:
    if ( !LOBYTE(::buf.c_iflag) )
      sub_176C8(1, v14, v30);
LABEL_48:
    v16 = ++v46;
  }
  while ( v46 != v45 );
  v51 = v49[v16 - 1];
  buf = (char *)sub_174B4(v14, 0x2000u);
  if ( (v6 & 1) != 0 )
  {
    v17 = 0;
    while ( 2 )
    {
      v18 = 0;
      sleep(seconds);
      v19 = v49 - 1;
LABEL_52:
      v21 = v19[1];
      ++v19;
      v20 = v21;
      v22 = v47[v18];
      if ( (v6 & 0x40) != 0 )
      {
        if ( v20 >= 0 )
        {
          if ( sub_62E08() >= 0 && sub_62DFC() >= 0 && v63 == v61 && v66 == v62 )
            goto LABEL_58;
          close(v20);
        }
        v42 = open64(v22, 0);
        if ( v42 < 0 )
        {
          if ( v20 >= 0 )
            sub_16AF4("%s has become inaccessible", v22);
        }
        else
        {
          v43 = "been replaced";
          if ( v20 < 0 )
            v43 = "appeared";
          sub_16DDC("%s has %s; following end of new file", v22, v43);
        }
        *v19 = v42;
        v20 = v42;
      }
LABEL_58:
      if ( v20 >= 0 )
      {
        if ( v48 < v45 )
          v17 = "\n==> %s <==\n";
        while ( 1 )
        {
          if ( !sub_62E08() && v65 >= 1 )
          {
            v24 = lseek64(v20, v23);
            if ( v65 < v24 )
              sub_1771C(v20, SHIDWORD(v24), 0, 0);
          }
          v25 = sub_18050(v20, buf, 0x2000u);
          v26 = v25;
          if ( v25 < 0 )
            break;
          if ( !v25 )
            goto LABEL_67;
          v41 = v17 == 0;
          if ( v17 )
            v41 = v51 == v20;
          if ( !v41 )
          {
            if ( dprintf(1, v17, v22) < 0 )
              goto LABEL_38;
            v17 = 0;
            v51 = v20;
          }
          sub_176C8(1, buf, v26);
        }
        sub_16AF4("read error");
        BYTE1(::buf.c_iflag) = 1;
      }
LABEL_67:
      if ( v46 == ++v18 )
        continue;
      goto LABEL_52;
    }
  }
  return BYTE1(::buf.c_iflag);
}
// 47B78: variable 'v11' is possibly undefined
// 47D10: variable 'v23' is possibly undefined
// 13558: using guessed type int dprintf(_DWORD, const char *, ...);
// 13928: using guessed type __int64 __fastcall lseek64(_DWORD, _DWORD);
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D604: using guessed type int optind;

//----- (00048094) --------------------------------------------------------
void __fastcall __noreturn sub_48094(int a1, char **a2)
{
  char v4; // r0
  int v5; // r4
  char **v6; // r5
  const char **v7; // r10
  char **v8; // r11
  char **v9; // r6
  char v10; // r8
  FILE **v11; // r4
  FILE **v12; // r9
  FILE *v13; // t1
  char **v14; // r2
  int v15; // r0
  int v16; // t1
  ssize_t v17; // r0
  size_t v18; // r9
  FILE *v19; // r0
  FILE *v20; // t1
  const char *v21; // t1
  int v22; // r0
  FILE **v23; // r6
  FILE *v24; // t1
  char *v25; // [sp+0h] [bp-Ch]
  char **v26; // [sp+4h] [bp-8h]

  v4 = sub_593CC(a2, "ia");
  v5 = a1 - optind;
  v6 = &a2[optind];
  v25 = &aW_1[v4 & 2];
  if ( (v4 & 1) != 0 )
    signal(2, (__sighandler_t)1);
  v7 = (const char **)(v6 - 1);
  signal(13, (__sighandler_t)1);
  v8 = v6 - 1;
  v9 = v6;
  v10 = 0;
  v11 = (FILE **)sub_174DC(4 * (v5 + 2));
  v12 = v11;
  *v11 = (FILE *)stdout;
  while ( 1 )
  {
    v13 = *v12++;
    setbuf(v13, 0);
    while ( 1 )
    {
      v14 = v9;
      v16 = (int)*v9++;
      v15 = v16;
      if ( !v16 )
      {
        while ( 1 )
        {
          v17 = sub_1800C(0, &buf, 0x400u);
          v18 = v17;
          if ( v17 <= 0 )
            break;
          v23 = v11;
          do
          {
            fwrite(&buf, 1u, v18, *v23);
            v24 = v23[1];
            ++v23;
          }
          while ( v24 );
        }
        if ( v17 )
          v10 = 1;
        *(v6 - 1) = "standard input";
        *v11 = (FILE *)stdin;
        do
        {
          v20 = *v11++;
          v19 = v20;
          v21 = *v7++;
          sub_1779C(v19, v21);
        }
        while ( *v11 );
        sub_588D8(v10);
      }
      *v12 = (FILE *)stdout;
      if ( *(_BYTE *)v15 == 45 && !*(_BYTE *)(v15 + 1) )
        break;
      v26 = v14;
      v22 = sub_61C78((const char *)v15, (int)v25);
      *v12 = (FILE *)v22;
      v14 = v26;
      if ( v22 )
        break;
      v10 = 1;
    }
    v9 = v14 + 1;
    v8[1] = *v14;
    ++v8;
  }
}
// 7D604: using guessed type int optind;
// 7D610: using guessed type int stdin;
// 7D614: using guessed type int stdout;

//----- (00048224) --------------------------------------------------------
void __fastcall __noreturn sub_48224(const char *a1, const char *a2)
{
  if ( a1 && *a1 )
    sub_16DDC("%s: %s", a1, a2);
  else
    sub_16DDC("%s", a2);
  longjmp((struct __jmp_buf_tag *)(dword_7DBBC + 16), 2);
}
// 7DBBC: using guessed type int dword_7DBBC;

//----- (00048278) --------------------------------------------------------
__int64 __fastcall sub_48278(const char *a1, char *a2, char *a3)
{
  _DWORD *v4; // r5
  __int64 v5; // r0
  const char *v6; // r1
  __int64 v7; // r6
  char *endptr[2]; // [sp+4h] [bp-8h] BYREF

  endptr[0] = a2;
  endptr[1] = a3;
  v4 = (_DWORD *)dword_7DB94;
  *(_DWORD *)dword_7DB94 = 0;
  v5 = strtoll(a1, endptr, 10);
  if ( *v4 )
  {
    v6 = "out of range";
    goto LABEL_5;
  }
  LODWORD(v7) = v5;
  if ( endptr[0] == a1 || (HIDWORD(v7) = HIDWORD(v5), *sub_60E74((unsigned __int8 *)endptr[0])) )
  {
    v6 = "bad number";
LABEL_5:
    sub_48224(a1, v6);
  }
  return v7;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000482F8) --------------------------------------------------------
int __fastcall sub_482F8(int s2)
{
  int v1; // r4
  int v2; // r0
  unsigned __int8 *v3; // r2
  bool v4; // nf

  v1 = dword_7DBBC;
  *(_DWORD *)(dword_7DBBC + 4) = &unk_6A482;
  if ( s2 )
  {
    v2 = sub_16880("-r", (char *)s2);
    v4 = v2 < 0;
    if ( v2 < 0 )
    {
      s2 = 39;
    }
    else
    {
      v3 = (unsigned __int8 *)&unk_6A484 + 2 * v2;
      s2 = *v3;
    }
    if ( !v4 )
      *(_DWORD *)(v1 + 4) = v3;
  }
  return s2;
}
// 48334: variable 'v3' is possibly undefined
// 7DBBC: using guessed type int dword_7DBBC;

//----- (0004834C) --------------------------------------------------------
bool sub_4834C()
{
  char **v0; // r4
  int v1; // r0
  const char *v2; // r5
  char *v3; // r1
  const char **v4; // r3
  char *v5; // r7
  const char *v6; // r6
  char *v7; // r2
  int v8; // r4
  __int64 v9; // r4
  char *v10; // r2
  __int64 v11; // r0
  int v12; // r3
  bool v14; // cc
  bool v15; // cc
  int v16; // r0
  int v17; // r3
  __int64 v18; // [sp+0h] [bp-D4h]
  int v19; // [sp+50h] [bp-84h]
  __int64 v20; // [sp+60h] [bp-74h]
  __int64 v21; // [sp+68h] [bp-6Ch]
  int v22; // [sp+B8h] [bp-1Ch]
  __int64 v23; // [sp+C8h] [bp-Ch]

  v0 = (char **)dword_7DBBC;
  v1 = *(_DWORD *)(*(_DWORD *)dword_7DBBC + 4);
  v2 = **(const char ***)dword_7DBBC;
  *(_DWORD *)dword_7DBBC += 4;
  sub_482F8(v1);
  v4 = (const char **)*v0;
  v5 = v0[1];
  v6 = (const char *)*((_DWORD *)*v0 + 1);
  v7 = *v0 + 4;
  *v0 = v7;
  if ( !v6 )
    sub_48224(*v4, "argument expected");
  v8 = (unsigned __int8)*v5;
  if ( (unsigned int)(v8 - 28) > 5 )
  {
    if ( (unsigned int)(v8 - 22) <= 5 )
    {
      v16 = strcmp(v2, v6);
      switch ( v8 )
      {
        case 24:
          return v16 == 0;
        case 25:
          return v16 != 0;
        case 26:
          return (unsigned int)v16 >> 31;
      }
      v14 = v16 < 1LL;
      return !v14;
    }
    if ( sub_62DFC() || sub_62DFC() )
      return 0;
    v17 = (unsigned __int8)*v5;
    if ( v17 == 17 )
      return v19 > v22;
    if ( v17 == 18 )
      return v19 < v22;
    return v18 == v21 && v20 == v23;
  }
  else
  {
    v9 = sub_48278(v2, v3, v7);
    v11 = sub_48278(v6, (char *)HIDWORD(v9), v10);
    v12 = (unsigned __int8)*v5;
    switch ( v12 )
    {
      case 28:
        return v9 == v11;
      case 29:
        return v9 != v11;
      case 30:
        v14 = v9 < v11;
        return !v14;
      case 31:
        v15 = v11 < v9;
        break;
      case 32:
        v14 = v11 < v9;
        return !v14;
      default:
        v15 = v9 < v11;
        break;
    }
    return v15;
  }
}
// 483AC: variable 'v3' is possibly undefined
// 483BC: variable 'v10' is possibly undefined
// 48500: variable 'v19' is possibly undefined
// 48500: variable 'v22' is possibly undefined
// 4853C: variable 'v18' is possibly undefined
// 4853C: variable 'v21' is possibly undefined
// 48550: variable 'v20' is possibly undefined
// 48550: variable 'v23' is possibly undefined
// 7DBBC: using guessed type int dword_7DBBC;

//----- (00048568) --------------------------------------------------------
__int64 __fastcall sub_48568(int a1)
{
  _DWORD *v1; // r4
  int v2; // r0
  __int64 v3; // r4
  const char *v5; // r1
  int *v6; // r6
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r4
  char *v11; // r1
  int v12; // r0
  char *v13; // r2
  const char *v14; // r0
  int v16; // r0
  int v17; // r4
  int v18; // r5
  __uid_t v19; // r0
  int v20; // r7
  int v21; // r4
  bool v22; // zf
  int v23; // r3
  unsigned __int8 *v24; // r4
  __uid_t v25; // r0
  int v26; // [sp+10h] [bp-58h]
  unsigned __int8 *v27; // [sp+18h] [bp-50h]
  unsigned __int8 *v28; // [sp+1Ch] [bp-4Ch]
  __int64 v29; // [sp+30h] [bp-38h]

  if ( a1 != 34 )
  {
    if ( !a1 )
    {
      v5 = "argument expected";
      goto LABEL_11;
    }
    v6 = (int *)dword_7DBBC;
    v7 = *(_DWORD *)(*(_DWORD *)dword_7DBBC + 4);
    if ( a1 == 37 )
    {
      *(_DWORD *)dword_7DBBC += 4;
      v8 = sub_482F8(v7);
      v3 = sub_48994(v8);
      v9 = *(_DWORD *)(*v6 + 4);
      *v6 += 4;
      if ( sub_482F8(v9) == 38 )
        return v3;
      v5 = "closing paren expected";
LABEL_11:
      sub_48224(0, v5);
    }
    v10 = *(_DWORD *)(dword_7DBBC + 4);
    if ( sub_482F8(v7) && *(_DWORD *)(*v6 + 8) && *(_BYTE *)(v6[1] + 1) == 1 )
      goto LABEL_15;
    v13 = (char *)*(unsigned __int8 *)(v10 + 1);
    if ( *(_BYTE *)(v10 + 1) )
    {
      if ( *(_BYTE *)(v6[1] + 1) == 1 )
      {
LABEL_15:
        v12 = sub_4834C();
LABEL_16:
        LODWORD(v3) = v12;
        return (int)v3;
      }
    }
    else
    {
      v14 = *(const char **)(*v6 + 4);
      if ( v14 )
      {
        *v6 += 4;
        switch ( a1 )
        {
          case 22:
            LODWORD(v3) = *(unsigned __int8 *)v14 == 0;
LABEL_25:
            HIDWORD(v3) = v13;
            return v3;
          case 23:
            LODWORD(v3) = *(unsigned __int8 *)v14;
            if ( *v14 )
              LODWORD(v3) = 1;
            goto LABEL_25;
          case 13:
            v16 = sub_48278(v14, v11, v13);
            v12 = isatty(v16);
            goto LABEL_16;
          case 11:
            if ( sub_62E14() )
            {
LABEL_31:
              LODWORD(v3) = 0;
              return (int)v3;
            }
            v21 = 40960;
            goto LABEL_70;
        }
        v17 = sub_62DFC();
        if ( v17 )
          goto LABEL_31;
        if ( a1 != 4 )
        {
          if ( (unsigned int)(unsigned __int8)a1 - 1 <= 2 )
          {
            if ( a1 == 2 )
            {
              v18 = 2;
            }
            else if ( a1 == 3 )
            {
              v18 = 1;
            }
            else
            {
              v18 = 4;
            }
            v19 = geteuid();
            v20 = v18;
            if ( v19 || v18 == 1 && (v26 & 0x49) == 0 )
            {
              if ( (unsigned __int8 *)v19 == v27 )
              {
                v20 = v18 << 6;
              }
              else if ( v28 == (unsigned __int8 *)getgid() || v28 == (unsigned __int8 *)getegid() )
              {
LABEL_57:
                v20 = 8 * v18;
              }
              else
              {
                if ( !v6[3] )
                  v6[2] = (int)sub_579BC(v6 + 3, 0);
                while ( v17 < v6[3] )
                {
                  if ( v28 == *(unsigned __int8 **)(v6[2] + 4 * v17) )
                    goto LABEL_57;
                  ++v17;
                }
              }
              if ( (v20 & v26) != 0 )
                v17 = 0;
              else
                v17 = -1;
            }
            LODWORD(v3) = v17 == 0;
            return (int)v3;
          }
          if ( (unsigned int)(unsigned __int8)a1 - 5 <= 5 )
          {
            switch ( a1 )
            {
              case 6:
                v21 = 0x4000;
                break;
              case 7:
                v21 = 0x2000;
                break;
              case 8:
                v21 = 24576;
                break;
              case 9:
                v21 = 4096;
                break;
              case 10:
                v21 = 49152;
                break;
              default:
                v21 = 0x8000;
                break;
            }
LABEL_70:
            v22 = (v26 & 0xF000) == v21;
            goto LABEL_71;
          }
          if ( (unsigned int)(unsigned __int8)a1 - 14 <= 2 )
          {
            if ( a1 == 15 )
            {
              v23 = 1024;
            }
            else if ( a1 == 16 )
            {
              v23 = 512;
            }
            else
            {
              v23 = 2048;
            }
            LODWORD(v3) = (v23 & v26) != 0;
            return (int)v3;
          }
          switch ( a1 )
          {
            case 12:
              LODWORD(v3) = v29 >= 1;
              return (int)v3;
            case 20:
              v24 = v27;
              v25 = geteuid();
LABEL_86:
              v22 = v24 == (unsigned __int8 *)v25;
LABEL_71:
              LODWORD(v3) = v22;
              return (int)v3;
            case 21:
              v24 = v28;
              v25 = getegid();
              goto LABEL_86;
          }
        }
        LODWORD(v3) = 1;
        return (int)v3;
      }
    }
    LODWORD(v3) = **(unsigned __int8 **)*v6;
    if ( **(_BYTE **)*v6 )
      LODWORD(v3) = 1;
    goto LABEL_4;
  }
  v1 = (_DWORD *)dword_7DBBC;
  v2 = *(_DWORD *)(*(_DWORD *)dword_7DBBC + 4);
  *(_DWORD *)dword_7DBBC += 4;
  if ( sub_482F8(v2) )
  {
    LODWORD(v3) = sub_48568() == 0;
  }
  else
  {
    *v1 -= 4;
    LODWORD(v3) = 1;
  }
LABEL_4:
  HIDWORD(v3) = 0;
  return v3;
}
// 486D4: variable 'v11' is possibly undefined
// 48758: variable 'v26' is possibly undefined
// 48768: variable 'v27' is possibly undefined
// 4877C: variable 'v28' is possibly undefined
// 488A0: variable 'v29' is possibly undefined
// 48994: using guessed type __int64 __fastcall sub_48994(_DWORD);
// 7DBBC: using guessed type int dword_7DBBC;

//----- (00048914) --------------------------------------------------------
__int64 __fastcall sub_48914(int a1)
{
  __int64 v1; // r4
  int *v2; // r6
  int v3; // r0
  int v4; // r0
  int v5; // r3
  int v6; // r0
  int v7; // r0
  __int64 v8; // r0
  bool v9; // zf

  v1 = sub_48568(a1);
  v2 = (int *)dword_7DBBC;
  v3 = *(_DWORD *)(*(_DWORD *)dword_7DBBC + 4);
  *(_DWORD *)dword_7DBBC += 4;
  v4 = sub_482F8(v3);
  v5 = *v2;
  if ( v4 == 35 )
  {
    v6 = *(_DWORD *)(v5 + 4);
    *v2 = v5 + 4;
    v7 = sub_482F8(v6);
    LODWORD(v8) = sub_48914(v7);
    v9 = v1 == 0;
    HIDWORD(v1) = 0;
    LOBYTE(v1) = !v9;
    if ( !v8 )
      LOBYTE(v1) = 0;
    LODWORD(v1) = (unsigned __int8)v1;
  }
  else
  {
    *v2 = v5 - 4;
  }
  return v1;
}
// 4897C: variable 'v8' is possibly undefined
// 7DBBC: using guessed type int dword_7DBBC;

//----- (00048994) --------------------------------------------------------
__int64 __fastcall sub_48994(int a1)
{
  __int64 v1; // r4
  int *v2; // r6
  int v3; // r0
  int v4; // r0
  int v5; // r3
  int v6; // r0
  int v7; // r0

  v1 = sub_48914(a1);
  v2 = (int *)dword_7DBBC;
  v3 = *(_DWORD *)(*(_DWORD *)dword_7DBBC + 4);
  *(_DWORD *)dword_7DBBC += 4;
  v4 = sub_482F8(v3);
  v5 = *v2;
  if ( v4 == 36 )
  {
    v6 = *(_DWORD *)(v5 + 4);
    *v2 = v5 + 4;
    v7 = sub_482F8(v6);
    return (sub_48994(v7) | v1) != 0;
  }
  else
  {
    *v2 = v5 - 4;
  }
  return v1;
}
// 7DBBC: using guessed type int dword_7DBBC;

//----- (00048A14) --------------------------------------------------------
int __fastcall sub_48A14(int a1, const char **a2)
{
  char *v3; // r0
  int v4; // r3
  const char **v5; // r4
  const char *v6; // r3
  const char *v7; // r0
  int v8; // r4
  int v10; // r5
  unsigned __int8 *v11; // r3
  int v12; // r0
  int v13; // r0
  _BOOL4 v14; // r0
  _BYTE *v15; // r2
  int v16; // r0
  __int64 v17; // r0
  int *v18; // r3
  const char *v19; // r1
  _DWORD *v21; // [sp+4h] [bp-8h]

  v3 = sub_169FC(*a2);
  if ( *v3 == 91 )
  {
    v4 = a1 - 1;
    v5 = &a2[a1 - 1];
    v6 = a2[v4];
    if ( v3[1] )
    {
      if ( strcmp(v6, "]]") )
      {
        v7 = "missing ]]";
        goto LABEL_6;
      }
    }
    else if ( *v6 != 93 || v6[1] )
    {
      v7 = "missing ]";
LABEL_6:
      v8 = 2;
      sub_16DDC(v7);
      return v8;
    }
    *v5 = 0;
  }
  dword_7DBBC = (int)sub_174DC(0x198u);
  v8 = setjmp((struct __jmp_buf_tag *)(dword_7DBBC + 16));
  v10 = dword_7DBBC;
  if ( v8 )
    goto LABEL_18;
  v21 = a2 + 1;
  *(_DWORD *)dword_7DBBC = v21;
  while ( 1 )
  {
    v11 = (unsigned __int8 *)*v21;
    if ( !*v21 )
    {
      v14 = 1;
      goto LABEL_17;
    }
    v12 = v21[1];
    if ( !v12 )
    {
      v13 = *v11;
LABEL_16:
      v14 = v13 == 0;
LABEL_17:
      v8 ^= v14;
      goto LABEL_18;
    }
    if ( v21[2] )
    {
      v15 = (_BYTE *)v21[3];
      if ( v15 )
      {
        if ( !v21[4] && *v11 == 40 && !v11[1] && *v15 == 41 && !v15[1] )
        {
          v21[3] = (unsigned __int8)v15[1];
          ++v21;
        }
      }
      else
      {
        sub_482F8(v12);
        if ( *(_BYTE *)(*(_DWORD *)(v10 + 4) + 1) == 1 )
        {
          *(_DWORD *)v10 = v21;
          v13 = sub_4834C();
          goto LABEL_16;
        }
      }
    }
    if ( *(_BYTE *)*v21 != 33 || *(_BYTE *)(*v21 + 1) )
      break;
    v8 ^= 1u;
    ++v21;
  }
  v16 = sub_482F8(**(_DWORD **)v10);
  v17 = sub_48994(v16);
  v18 = *(int **)v10;
  v8 = v17 == 0;
  if ( **(_DWORD **)v10 )
  {
    v19 = (const char *)v18[1];
    *(_DWORD *)v10 = v18 + 1;
    if ( v19 )
    {
      v8 = 2;
      sub_16DDC("%s: unknown operand", v19);
    }
  }
LABEL_18:
  free(*(void **)(v10 + 8));
  free((void *)v10);
  return v8;
}
// 7DBBC: using guessed type int dword_7DBBC;

//----- (00048C48) --------------------------------------------------------
int __fastcall sub_48C48(int a1, char **a2)
{
  char v3; // r0
  char **v4; // r4
  char v5; // r6
  int v6; // r5
  int v7; // r0
  char *v8; // t1

  v3 = sub_593CC(a2, "cfma");
  v4 = &a2[optind];
  if ( !*v4 )
    sub_162F0();
  v5 = v3;
  v6 = 0;
  do
  {
    if ( !utimes(*v4, 0) )
      goto LABEL_9;
    if ( *(_DWORD *)dword_7DB94 != 2 )
      goto LABEL_11;
    if ( (v5 & 1) != 0 )
      goto LABEL_9;
    v7 = open64(*v4, 66);
    if ( v7 >= 0 )
    {
      sub_17700(v7);
    }
    else
    {
LABEL_11:
      v6 = 1;
      sub_16B80(*v4);
    }
LABEL_9:
    v8 = v4[1];
    ++v4;
  }
  while ( v8 );
  return v6;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7DB94: using guessed type int dword_7DB94;

//----- (00048CFC) --------------------------------------------------------
size_t __fastcall sub_48CFC(void *s, size_t n)
{
  int v2; // r4
  size_t v5; // r5
  int v6; // r1
  char v7; // r8
  _BYTE *v8; // r3
  _BYTE _0[280]; // [sp+0h] [bp-100h] BYREF

  v2 = 0;
  v5 = 0;
  do
  {
    v6 = v2;
    v7 = v2++;
    if ( !memchr(s, v6, n) )
    {
      v8 = &_0[v5++ + 256];
      *(v8 - 256) = v7;
    }
  }
  while ( v2 != 256 );
  memcpy(s, _0, v5);
  return v5;
}

//----- (00048D64) --------------------------------------------------------
int __fastcall sub_48D64(unsigned __int8 *a1, void **a2)
{
  char *v3; // r6
  size_t v5; // r8
  int v6; // r5
  unsigned __int8 v8; // r0
  int v9; // r2
  unsigned int v10; // r7
  unsigned int v11; // r0
  int v12; // r3
  int v13; // r5
  unsigned int i; // r2
  int v15; // r10
  int v16; // r0
  unsigned int v17; // r7
  bool v18; // cc
  char *v19; // r2
  int j; // r3
  bool v21; // cc
  char *v22; // r0
  int k; // r2
  char *v25; // r1
  int m; // r2
  int v27; // r2
  char *v28; // r1
  int v29; // r2
  bool v30; // cc
  char *v31; // r1
  int v32; // r2
  char v33; // r0
  unsigned __int8 v34; // r2
  int v35; // [sp+4h] [bp-18h]
  char *ptr; // [sp+8h] [bp-14h]
  unsigned __int8 *v37[2]; // [sp+14h] [bp-8h] BYREF

  v3 = (char *)*a2;
  v5 = 0x2000;
  v6 = 0;
  while ( *a1 )
  {
    if ( v6 + 256 > v5 )
    {
      v5 += 256;
      v3 = (char *)sub_174B4(v3, v5);
      *a2 = v3;
    }
    if ( *a1 == 92 )
    {
      v37[0] = a1 + 1;
      v8 = sub_5E668(v37);
      a1 = v37[0] - 1;
      *(v37[0] - 1) = v8;
    }
    v9 = a1[1];
    v10 = *a1;
    if ( v9 == 45 )
    {
      v11 = a1[2];
      if ( a1[2] )
      {
        a1 += 3;
        if ( v11 == 92 )
        {
          v37[0] = a1;
          v11 = sub_5E668(v37);
          a1 = v37[0];
        }
        v13 = v6 - v10;
        for ( i = v10; ; ++i )
        {
          v12 = i + v13;
          if ( v11 < i )
            break;
          v3[v13 + i] = i;
        }
      }
      else
      {
        ++a1;
        v12 = v6 + 1;
        v3[v6] = v10;
      }
      goto LABEL_16;
    }
    if ( v10 != 91 )
      goto LABEL_71;
    if ( v9 == 58 )
    {
      if ( a1[2] == 120 )
        v15 = 8;
      else
        v15 = 7;
      ptr = (char *)sub_1751C((char *)a1 + 2, v15);
      v16 = sub_16880("alpha:]", ptr);
      v17 = v16 + 1;
      v35 = v16;
      free(ptr);
      if ( !v17 )
      {
LABEL_71:
        v34 = *a1;
        v12 = v6 + 1;
        ++a1;
        v3[v6] = v34;
        goto LABEL_16;
      }
      a1 += v15 + 2;
      v18 = v17 > 0xA;
      if ( v17 != 10 )
        v18 = (unsigned int)(v35 - 1) > 1;
      if ( v18 )
      {
        v12 = v6;
      }
      else
      {
        v19 = &v3[v6];
        for ( j = 48; j != 58; ++j )
          *v19++ = j;
        v12 = v6 + 10;
      }
      v21 = v17 > 5;
      if ( v17 != 5 )
        v21 = v17 - 1 > 1;
      if ( !v21 )
      {
        v22 = &v3[v12];
        for ( k = 65; k != 91; ++k )
          *v22++ = k;
        v12 += 26;
      }
      if ( v17 == 4 || v17 - 1 <= 1 )
      {
        v25 = &v3[v12];
        for ( m = 97; m != 123; ++m )
          *v25++ = m;
        v12 += 26;
      }
      if ( v17 - 6 <= 1 )
      {
        v27 = v12 + 1;
        v3[v12] = 9;
        if ( v17 == 6 )
        {
          v3[v27] = 10;
          v28 = &v3[v12];
          v28[2] = 11;
          v28[3] = 12;
          v27 = v12 + 5;
          v28[4] = 13;
        }
        v12 = v27 + 1;
        v3[v27] = 32;
      }
      if ( v17 - 8 <= 1 )
      {
        v29 = 0;
        while ( 1 )
        {
          if ( v17 == 8 )
          {
            if ( (unsigned int)(v29 - 32) > 0x5E
              || (unsigned int)(unsigned __int8)v29 - 48 <= 9
              || ((unsigned __int8)v29 | 0x20u) - 97 <= 0x19
              || (unsigned __int8)v29 == 32 )
            {
              goto LABEL_59;
            }
          }
          else
          {
            v30 = (unsigned __int8)v29 > 0x7Fu;
            if ( (unsigned __int8)v29 != 127 )
              v30 = (unsigned __int8)v29 > 0x1Fu;
            if ( v30 )
              goto LABEL_59;
          }
          v3[v12++] = v29;
LABEL_59:
          if ( ++v29 == 256 )
            goto LABEL_16;
        }
      }
      if ( v17 == 10 )
      {
        v31 = &v3[v12];
        v32 = 65;
        do
        {
          v33 = v32++;
          v31[6] = v33 | 0x20;
          *v31++ = v33;
        }
        while ( v32 != 71 );
        v12 += 12;
      }
    }
    else
    {
      v12 = v6 + 1;
      if ( v9 != 61 )
        goto LABEL_71;
      v3[v6] = a1[2];
      if ( !a1[2] || a1[3] != 61 || a1[4] != 93 )
        sub_162F0();
      a1 += 5;
    }
LABEL_16:
    v6 = v12;
  }
  return v6;
}

//----- (000490B4) --------------------------------------------------------
ssize_t __fastcall sub_490B4(int a1, char **a2)
{
  _BYTE *v3; // r0
  int v4; // r3
  _BYTE *v5; // r4
  char *v6; // r5
  char *v7; // r6
  char v8; // r7
  unsigned __int8 **v9; // r9
  size_t v10; // r0
  signed int v11; // r8
  unsigned __int8 *v12; // r0
  unsigned int v13; // r0
  char *v14; // r2
  _BYTE *v15; // r10
  signed int v16; // r3
  unsigned int v17; // r1
  char v18; // r12
  char *v19; // r9
  _BYTE *v20; // r1
  unsigned __int8 *i; // r2
  _BYTE *v22; // r1
  unsigned __int8 *j; // r2
  int v24; // r8
  ssize_t result; // r0
  ssize_t v26; // r12
  bool v27; // cc
  int v28; // lr
  int v29; // t1
  int v30; // t1
  int v31; // t1
  size_t v32; // r2
  int v33; // r3
  int v34; // r0
  int v35; // r1
  int v36; // r3
  void *buf; // [sp+0h] [bp-8h] BYREF
  _BYTE *v38; // [sp+4h] [bp-4h] BYREF

  buf = sub_1748C(0x2000u);
  v38 = sub_1748C(0x2000u);
  v3 = sub_174DC(0x300u);
  v4 = 0;
  v5 = v3;
  v6 = v3 + 256;
  v7 = v3 + 512;
  do
  {
    v3[v4] = v4;
    ++v4;
  }
  while ( v4 != 256 );
  v8 = sub_593CC(a2, "^+Ccds");
  v9 = (unsigned __int8 **)&a2[optind];
  v10 = sub_48D64(*v9, &buf);
  v11 = v10;
  if ( (v8 & 3) != 0 )
    v11 = sub_48CFC(buf, v10);
  v12 = v9[1];
  if ( v12 )
  {
    if ( !*v12 )
      sub_16DBC("STRING2 cannot be empty");
    v13 = sub_48D64(v12, (void **)&v38);
    v14 = (char *)buf;
    v15 = v38;
    v16 = v13;
    v17 = 0;
    v18 = 48;
    v19 = (char *)buf + v11;
    while ( v14 != v19 )
    {
      v27 = v13 > v17;
      v29 = (unsigned __int8)*v14++;
      v28 = v29;
      if ( v13 <= v17 )
        v5[v28] = v18;
      else
        v18 = v15[v17++];
      if ( v27 )
        v5[v28] = v18;
    }
  }
  else
  {
    v16 = 0;
  }
  v20 = buf;
  for ( i = (unsigned __int8 *)buf; i - v20 < v11; ++i )
  {
    v30 = *i;
    v6[v30] = 1;
  }
  v22 = v38;
  for ( j = v38; v16 > j - v22; ++j )
  {
    v31 = *j;
    v7[v31] = 1;
  }
  v24 = 256;
  while ( 1 )
  {
    result = sub_1800C(0, buf, 0x2000u);
    v26 = result;
    if ( result <= 0 )
      break;
    v32 = 0;
    v33 = 0;
    do
    {
      v34 = v33 + 1;
      v35 = *((unsigned __int8 *)buf + v33);
      if ( (v8 & 4) == 0 || !v6[v35] )
      {
        v36 = (unsigned __int8)v5[v35];
        if ( (v8 & 8) == 0 || v24 != v36 || !v6[v35] && !v7[v24] )
        {
          v24 = (unsigned __int8)v5[v35];
          v38[v32++] = v36;
        }
      }
      v33 = v34;
    }
    while ( v26 != v34 );
    if ( v32 )
      sub_176C8(1, v38, v32);
  }
  if ( result )
    sub_16B40("read error");
  return result;
}
// 7D604: using guessed type int optind;

//----- (000492C0) --------------------------------------------------------
int sub_492C0()
{
  return 0;
}

//----- (000492C8) --------------------------------------------------------
int __fastcall sub_492C8(int a1, char **a2)
{
  char v3; // r7
  int v4; // r6
  int v5; // r5
  const char **v6; // r4
  const char *v7; // r0
  const char *v8; // t1
  int v10; // r11
  char v11; // r3
  int v12; // [sp+Ch] [bp-8h] BYREF

  v3 = sub_593CC(a2, "^cs:", &v12);
  v4 = 2049;
  if ( (v3 & 1) == 0 )
    v4 = 2113;
  v5 = 0;
  sub_61EE8((const char *)v12, (int)&unk_641AC);
  v6 = (const char **)&a2[optind - 1];
  while ( 1 )
  {
    v8 = v6[1];
    ++v6;
    v7 = v8;
    if ( !v8 )
      break;
    v10 = open64(v7, v4);
    if ( v10 >= 0 )
    {
      if ( ftruncate64() == -1 )
      {
        v5 = 1;
        sub_16AF4("%s: truncate", *v6);
      }
      sub_17700(v10);
    }
    else
    {
      v11 = ~v3;
      if ( *(_DWORD *)dword_7DB94 != 2 )
        v11 |= 1u;
      if ( (v11 & 1) != 0 )
      {
        sub_16AF4("%s: open", *v6);
        v5 = 1;
      }
    }
  }
  return v5;
}
// 136FC: using guessed type int ftruncate64(void);
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D604: using guessed type int optind;
// 7DB94: using guessed type int dword_7DB94;

//----- (000493C8) --------------------------------------------------------
void __fastcall __noreturn sub_493C8(int a1, char **a2)
{
  int v2; // r5
  char *v3; // r3
  char v4; // r4

  byte_7D5F8 = 2;
  v2 = sub_593CC(a2, "s");
  v3 = sub_17B34(0);
  if ( v3 )
  {
    v4 = 0;
  }
  else
  {
    v4 = 1;
    v3 = "not a tty";
  }
  if ( !v2 )
    puts(v3);
  sub_588D8(v4);
}
// 7D5F8: using guessed type char byte_7D5F8;

//----- (00049428) --------------------------------------------------------
void __fastcall __noreturn sub_49428(int a1, char **a2)
{
  int v3; // r0
  unsigned int v4; // r4
  const char *v5; // r5
  const char *v6; // r1
  unsigned __int16 *v7; // r5
  const char *v8; // r0
  struct utsname name; // [sp+4h] [bp-218h] BYREF
  char v10[62]; // [sp+18Ah] [bp-92h] BYREF
  char v11[65]; // [sp+1CBh] [bp-51h] BYREF
  char dest[10]; // [sp+20Ch] [bp-10h] BYREF

  if ( *(_BYTE *)dword_7DB90 == 117 )
  {
    v3 = sub_593F8(a2, "snrvmpioa", "all");
    v4 = v3;
    if ( a2[optind] )
      sub_162F0();
    if ( (v3 & 0x100) != 0 )
    {
      v4 = 255;
      v5 = "";
      goto LABEL_9;
    }
    if ( !v3 )
      v4 = 1;
  }
  else
  {
    v4 = 16;
  }
  v5 = "unknown";
LABEL_9:
  uname(&name);
  if ( *(_BYTE *)dword_7DB90 == 97 )
  {
    puts(name.machine);
  }
  else
  {
    strcpy(v10, v5);
    v6 = v5;
    v7 = (unsigned __int16 *)&unk_643E4;
    strcpy(v11, v6);
    strcpy(dest, "GNU/Linux");
    v8 = "%s";
    do
    {
      if ( (v4 & 1) != 0 )
      {
        if ( name.sysname[*v7] )
        {
          printf(v8);
          v8 = " %s";
        }
      }
      v4 >>= 1;
      ++v7;
    }
    while ( v4 );
    j_putchar_unlocked(10);
  }
  sub_588D8(0);
}
// 7D604: using guessed type int optind;
// 7DB90: using guessed type int dword_7DB90;

//----- (00049560) --------------------------------------------------------
int __fastcall sub_49560(int a1, char **a2)
{
  sub_593CC(a2, "^");
  sub_1761C(a2[optind]);
  return 0;
}
// 7D604: using guessed type int optind;

//----- (00049594) --------------------------------------------------------
int __fastcall sub_49594(int a1, int a2)
{
  const char *v2; // r0
  __useconds_t v3; // r0

  v2 = *(const char **)(a2 + 4);
  if ( !v2 )
    sub_162F0();
  v3 = sub_620B0(v2);
  usleep(v3);
  return 0;
}

//----- (000495B8) --------------------------------------------------------
void __fastcall __noreturn sub_495B8(int a1, char **a2)
{
  int v3; // r5
  int *v4; // r3
  FILE *v5; // r0
  int v6; // r8
  ssize_t v7; // r0
  ssize_t v8; // r4
  char buf[60]; // [sp+4h] [bp-8Ch] BYREF
  char v10[80]; // [sp+40h] [bp-50h] BYREF

  v3 = sub_593CC(a2, "^d");
  v4 = (int *)&a2[optind];
  if ( !*v4 )
    *--v4 = (int)"-";
  v5 = (FILE *)sub_61D20(*v4);
  if ( v3 )
  {
    sub_61998(v5, (FILE *)stdout, 255);
  }
  else
  {
    v6 = fileno_unlocked(v5);
    while ( 1 )
    {
      v7 = sub_18050(v6, buf, 0x39u);
      v8 = v7;
      if ( !v7 )
        break;
      if ( v7 < 0 )
        sub_16B40("read error");
      sub_617E8(v10, (int)buf, v7, (int)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=");
      sub_176C8(1, v10, 4 * ((v8 + 2) / 3u));
      j_putchar_unlocked(10);
      fflush((FILE *)stdout);
    }
  }
  sub_588D8(0);
}
// 7D604: using guessed type int optind;
// 7D614: using guessed type int stdout;

//----- (000496B4) --------------------------------------------------------
void __fastcall __noreturn sub_496B4(int a1, char **a2)
{
  int v3; // r3
  int *v4; // r8
  const char *v5; // r3
  char *v6; // r3
  char v7; // r5
  int v8; // r6
  const char *v9; // r4
  int *v10; // r10
  FILE *v11; // r11
  int v12; // r8
  unsigned int v13; // r9
  int v14; // r0
  int v15; // r2
  int v16; // r0
  const char *v17; // r0
  int i; // r10
  int v19; // r11
  int v20; // [sp+4h] [bp-40h]
  char *format; // [sp+8h] [bp-3Ch]
  char *v22; // [sp+Ch] [bp-38h]
  _DWORD *v23; // [sp+10h] [bp-34h]
  _DWORD v24[5]; // [sp+18h] [bp-2Ch] BYREF
  _DWORD s[6]; // [sp+2Ch] [bp-18h] BYREF

  v3 = sub_593CC(a2, "lwmcL");
  if ( !v3 )
    v3 = 11;
  v20 = v3;
  v4 = (int *)&a2[optind];
  if ( *v4 )
    v5 = " %s\n";
  else
    v5 = "standard input";
  if ( !*v4 )
  {
    *--v4 = (int)v5;
    v5 = "\n";
  }
  v22 = (char *)v5;
  if ( v4[1] )
  {
    v6 = "%9u";
  }
  else
  {
    v6 = "%u";
    if ( ((v20 - 1) & v20) != 0 )
      v6 = "%9u";
  }
  v7 = 0;
  v8 = 0;
  format = v6;
  memset(s, 0, 0x14u);
  v23 = v24;
  while ( 1 )
  {
    v9 = (const char *)*v4;
    v10 = v4 + 1;
    if ( !*v4 )
    {
      if ( v8 <= 1 )
        sub_588D8(v7);
      v8 = *v4;
      v23 = s;
      v9 = "total";
      goto LABEL_34;
    }
    ++v8;
    v11 = (FILE *)sub_61CD8(*v4);
    if ( !v11 )
    {
      v7 = 1;
      goto LABEL_39;
    }
    v12 = 0;
    v13 = 0;
    memset(v24, 0, sizeof(v24));
    while ( 1 )
    {
      do
      {
        while ( 1 )
        {
          v14 = getc_unlocked(v11);
          v15 = v14;
          if ( v14 == -1 )
          {
            v16 = ferror_unlocked(v11);
            v15 = -1;
            if ( v16 )
            {
              v7 = 1;
              sub_16B80(v9);
              v15 = -1;
            }
            goto LABEL_22;
          }
          ++v24[3];
          ++v24[2];
          if ( (unsigned int)(v14 - 32) > 0x5E )
            break;
          ++v13;
          if ( v14 == 32 )
            goto LABEL_30;
          v12 = 1;
        }
      }
      while ( (unsigned int)(v14 - 9) > 4 );
      if ( v14 == 9 )
      {
        v13 = (v13 | 7) + 1;
        goto LABEL_30;
      }
LABEL_22:
      if ( v24[4] < v13 )
        v24[4] = v13;
      if ( v15 == 10 )
      {
        v13 = 0;
        ++v24[0];
      }
      else if ( v15 != 11 )
      {
        v13 = 0;
      }
LABEL_30:
      v24[1] += v12;
      if ( v15 == -1 )
        break;
      v12 = 0;
    }
    v4 = v10;
    sub_5888C(v11);
    if ( s[4] < v24[4] )
      s[4] = v24[4];
    s[4] -= v24[4];
LABEL_34:
    v17 = format;
    for ( i = 0; i != 5; ++i )
    {
      v19 = v23[i];
      if ( (v20 & (1 << i)) != 0 )
      {
        printf(v17, v23[i], v20 & (1 << i), 1);
        v17 = " %9u";
      }
      s[i] += v19;
    }
    v10 = v4;
    printf(v22, v9);
LABEL_39:
    v4 = v10;
  }
}
// 7D604: using guessed type int optind;

//----- (00049948) --------------------------------------------------------
struct utmpx *__fastcall sub_49948(int a1, char **a2)
{
  char v2; // r7
  struct utmpx *result; // r0
  struct utmpx *v4; // r4
  char *v5; // r0
  int v6; // r5
  unsigned int v7; // r5
  int v8; // r1
  int v9; // r0
  char *v10; // r0
  int v11; // [sp+1Ch] [bp-A8h]
  time_t tv_sec; // [sp+24h] [bp-A0h] BYREF
  char v13[8]; // [sp+28h] [bp-9Ch] BYREF
  char dest[40]; // [sp+30h] [bp-94h] BYREF
  int v15; // [sp+A0h] [bp-24h]

  v2 = sub_593CC(a2, "^aH");
  if ( (v2 & 2) != 0 )
    puts("USER\t\tTTY\t\tIDLE\tTIME\t\t HOST");
  setutxent();
  while ( 1 )
  {
    result = getutxent();
    v4 = result;
    if ( !result )
      break;
    if ( result->ut_user[0] && ((v2 & 1) != 0 || result->ut_type == 7) )
    {
      *(_WORD *)v13 = 63;
      strcpy(dest, "/dev/");
      if ( v4->ut_line[0] == 47 )
        v5 = dest;
      else
        v5 = &dest[5];
      sub_60B34(v5, v4->ut_line, 33);
      if ( !sub_62DFC() )
      {
        v6 = v15;
        v7 = time(0) - v6;
        if ( v7 > 0x1517F )
        {
          strcpy(v13, "old");
        }
        else
        {
          sub_161AC(v7, 0xE10u);
          v11 = sub_15F18(v8, 60);
          v9 = sub_15F18(v7, 3600);
          sprintf(v13, "%02d:%02d", v9, v11);
        }
      }
      tv_sec = v4->ut_tv.tv_sec;
      v10 = ctime(&tv_sec);
      printf("%-15.*s %-15.*s %-7s %-16.16s %.*s\n", 32, v4->ut_user, 32, v4->ut_line, v13, v10 + 4, 256, v4->ut_host);
    }
  }
  return result;
}
// 49A28: variable 'v8' is possibly undefined

//----- (00049AC4) --------------------------------------------------------
void __fastcall __noreturn sub_49AC4(int a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r5
  int v4; // t1

  *a2 = "y";
  v2 = a2 + 1;
  if ( !a2[1] )
    v2 = a2;
  while ( 1 )
  {
    v3 = v2;
    while ( 1 )
    {
      fputs_unlocked(*v3, stdout);
      v4 = v3[1];
      ++v3;
      if ( !v4 )
        break;
      putchar_unlocked(32);
    }
    if ( putchar_unlocked(10) == -1 )
      sub_5E304();
  }
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;

//----- (00049B28) --------------------------------------------------------
int __fastcall sub_49B28(const char *a1, int a2, int (*a3)(void))
{
  if ( a3() >= 0 )
  {
    if ( (*(_DWORD *)(a2 + 16) & 0xF000) == 0x4000 )
      return 3;
    else
      return 1;
  }
  else if ( *(_DWORD *)dword_7DB94 == 2 )
  {
    return 0;
  }
  else
  {
    sub_16AF4("can't stat '%s'", a1);
    return -1;
  }
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00049B90) --------------------------------------------------------
int __fastcall sub_49B90(const char *a1, int a2)
{
  return sub_49B28(a1, a2, sub_62DFC);
}

//----- (00049B9C) --------------------------------------------------------
int __fastcall sub_49B9C(char **a1, int a2, int a3)
{
  unsigned int v3; // r4
  int v5[2]; // [sp+4h] [bp-8h] BYREF

  v5[1] = a3;
  v5[0] = 0;
  if ( (sub_593CC(a1, "m:", v5) & 1) == 0 )
    return 438;
  v3 = sub_5E0F4((const char *)v5[0], 0x1B6u);
  if ( v3 != -1 )
    umask(0);
  return v3;
}

//----- (00049BF0) --------------------------------------------------------
char *__fastcall sub_49BF0(int a1)
{
  char *v2; // r7
  const char *v3; // r0
  char *v4; // r8
  _BOOL4 v5; // r5
  char *result; // r0
  const char *v7; // r5
  char v8[20]; // [sp+4h] [bp-7Ch] BYREF
  char s[24]; // [sp+18h] [bp-68h] BYREF
  int v10; // [sp+30h] [bp-50h]
  char v11; // [sp+37h] [bp-49h]

  if ( !buf.c_lflag )
    goto LABEL_21;
  v2 = &s[sprintf(s, "/proc/%u/exe", a1) - 3];
  v3 = (const char *)sub_17B80(s);
  v4 = (char *)v3;
  v5 = v3 && strcmp((const char *)buf.c_lflag, v3) == 0;
  free(v4);
  if ( v5
    || (strcpy(v2, "cmdline"),
        result = (char *)sub_180C8((int)s, *(char **)&buf.c_cc[3], *(size_t *)&buf.c_cc[7]),
        (int)result > 0)
    && (result[*(_DWORD *)&buf.c_cc[3]] = 0,
        (result = (char *)strcmp((const char *)buf.c_lflag, *(const char **)&buf.c_cc[3])) == 0) )
  {
LABEL_21:
    if ( !buf.c_cflag )
      goto LABEL_18;
    sprintf(s, "/proc/%u/stat", a1);
    result = (char *)sub_180C8((int)s, s, 0x1Fu);
    if ( (int)result >= 0 )
    {
      v11 = 0;
      result = strchr(s, 40);
      if ( result )
      {
        v7 = result + 1;
        result = strrchr(result + 1, 41);
        if ( result )
        {
          *result = 0;
          result = (char *)strlen(v7);
          if ( (unsigned int)result <= 0xE )
          {
            result = (char *)strcmp(v7, (const char *)buf.c_cflag);
            if ( !result )
            {
LABEL_18:
              if ( !buf.c_oflag
                || (sprintf(v8, "/proc/%u", a1), (result = (char *)sub_62DFC()) == 0) && v10 == *(_DWORD *)&buf.c_cc[11] )
              {
                result = (char *)sub_1748C(8u);
                *(_DWORD *)result = buf.c_iflag;
                *((_DWORD *)result + 1) = a1;
                buf.c_iflag = (tcflag_t)result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (00049DA8) --------------------------------------------------------
unsigned int __fastcall sub_49DA8(int a1, char **a2)
{
  int v3; // r7
  size_t v4; // r0
  char **v5; // r8
  int v6; // r5
  FILE *v7; // r0
  FILE *v8; // r5
  const char *c_cflag; // r6
  char *v10; // r0
  _DWORD *c_iflag; // r8
  int v12; // r5
  DIR *v14; // r9
  _DWORD *v15; // r6
  int v16; // r0
  int v17; // r0
  int v18; // r1
  char v19; // r3
  _DWORD *i; // r4
  int v21; // r1
  struct passwd *v22; // r0
  int v23; // r4
  int v24; // r4
  const char *v25; // [sp+20h] [bp-1Ch] BYREF
  char *file; // [sp+24h] [bp-18h] BYREF
  char *s; // [sp+28h] [bp-14h] BYREF
  const char *v28; // [sp+2Ch] [bp-10h] BYREF
  __uid_t v29; // [sp+30h] [bp-Ch] BYREF
  __gid_t groups[2]; // [sp+34h] [bp-8h] BYREF

  buf.c_cc[11] = -1;
  buf.c_cc[12] = -1;
  buf.c_cc[13] = -1;
  buf.c_cc[14] = -1;
  buf.c_cc[15] = 15;
  buf.c_cc[16] = 0;
  buf.c_cc[17] = 0;
  buf.c_cc[18] = 0;
  v3 = sub_593F8(
         a2,
         "^KSbqtma:n:s:u:c:x:p:ovN:R:",
         "stop",
         &file,
         &buf.c_cflag,
         &v25,
         &buf.c_oflag,
         &s,
         &buf.c_lflag,
         &buf.c_line,
         &v28,
         0);
  if ( (v3 & 0x100) != 0 )
  {
    *(_DWORD *)&buf.c_cc[15] = sub_61000(v25);
    if ( *(int *)&buf.c_cc[15] < 0 )
      sub_162F0();
  }
  if ( (v3 & 0x40) == 0 )
    file = (char *)buf.c_lflag;
  if ( !buf.c_lflag )
    buf.c_lflag = (tcflag_t)file;
  if ( buf.c_lflag )
  {
    v4 = strlen((const char *)buf.c_lflag);
    *(_DWORD *)&buf.c_cc[7] = v4 + 1;
    *(_DWORD *)&buf.c_cc[3] = sub_1748C(v4 + 2);
  }
  v5 = &a2[optind];
  if ( buf.c_oflag )
  {
    *(_DWORD *)&buf.c_cc[11] = sub_18990((const char *)buf.c_oflag, 0, (char *)0xA);
    if ( *(_DWORD *)dword_7DB94 )
      *(_DWORD *)&buf.c_cc[11] = sub_57B54((const char *)buf.c_oflag);
  }
  v6 = *(_DWORD *)&buf.c_line;
  if ( *(_DWORD *)&buf.c_line )
  {
    v7 = (FILE *)sub_61C9C(*(int *)&buf.c_line);
    v8 = v7;
    if ( v7 )
    {
      if ( fscanf(v7, "%u", &v29) == 1 )
        sub_49BF0(v29);
      fclose(v8);
    }
    else if ( *(_DWORD *)dword_7DB94 != 2 )
    {
      sub_16B40("open pidfile %s", *(_DWORD *)&buf.c_line);
    }
  }
  else
  {
    v14 = sub_17980("/proc");
    v15 = (_DWORD *)dword_7DB94;
    while ( 1 )
    {
      do
      {
        *v15 = 0;
        v16 = readdir64(v14);
      }
      while ( *v15 );
      if ( !v16 )
        break;
      v17 = sub_18990((const char *)(v16 + 19), 0, (char *)0xA);
      v6 = v17;
      if ( !*v15 )
        sub_49BF0(v17);
    }
    closedir(v14);
    if ( !v6 )
      sub_16DBC("nothing in /proc - not mounted?");
  }
  if ( (v3 & 1) != 0 )
  {
    c_cflag = (const char *)buf.c_cflag;
    if ( !buf.c_cflag )
    {
      c_cflag = (const char *)buf.c_lflag;
      if ( !buf.c_lflag )
      {
        if ( *(_DWORD *)&buf.c_line )
        {
          v10 = sub_177E4("process in pidfile '%s'");
        }
        else
        {
          if ( !buf.c_oflag )
            sub_16DBC("internal error, please report");
          v10 = sub_177E4("process(es) owned by '%s'");
        }
        c_cflag = v10;
      }
    }
    c_iflag = (_DWORD *)buf.c_iflag;
    if ( buf.c_iflag )
    {
      v12 = 0;
      do
      {
        if ( (dword_7DBC0 & 0x10) != 0 )
          v18 = 0;
        else
          v18 = *(_DWORD *)&buf.c_cc[15];
        if ( kill(c_iflag[1], v18) )
        {
          sub_16AF4("warning: killing process %u", c_iflag[1]);
          v19 = dword_7DBC0;
          c_iflag[1] = 0;
          if ( (v19 & 0x10) != 0 )
            goto LABEL_29;
        }
        else
        {
          ++v12;
        }
        c_iflag = (_DWORD *)*c_iflag;
      }
      while ( c_iflag );
      if ( (dword_7DBC0 & 8) == 0 && v12 )
      {
        printf("stopped %s (pid", c_cflag);
        for ( i = (_DWORD *)buf.c_iflag; i; i = (_DWORD *)*i )
        {
          v21 = i[1];
          if ( v21 )
            printf(" %u", v21);
        }
        puts(")");
      }
    }
    else
    {
      if ( (dword_7DBC0 & 8) == 0 )
        printf("no %s found; none killed\n", c_cflag);
LABEL_29:
      v12 = -1;
    }
    return (v12 <= 0) & ((v3 ^ 0x2000u) >> 13);
  }
  else
  {
    if ( !buf.c_iflag )
    {
      *(v5 - 1) = file;
      if ( (v3 & 4) != 0 )
        sub_61B48(22);
      if ( (v3 & 0x20) != 0 )
        sub_5E30C(*(int *)&buf.c_line);
      if ( (v3 & 0x400) != 0 )
      {
        sub_6278C(&v29, s);
        if ( v29 == -1 )
        {
          if ( groups[0] != -1 )
          {
            sub_178C4(groups[0]);
            setgroups(1u, groups);
          }
        }
        else
        {
          v22 = sub_57AB8(v29);
          if ( groups[0] != -1 )
            v22->pw_gid = groups[0];
          sub_57CD8((int)v22);
        }
      }
      if ( (v3 & 0x8000) != 0 )
      {
        v23 = getpriority(0, 0);
        v24 = v23 + sub_62154(v28, -1073741824, 0x3FFFFFFF);
        if ( setpriority(0, 0, v24) < 0 )
          sub_16B40("setpriority(%d)", v24);
      }
      execvp(file, v5 - 1);
      sub_16B40("can't execute '%s'", file);
    }
    if ( (dword_7DBC0 & 8) == 0 )
      printf("%s is already running\n%u\n", (const char *)buf.c_lflag, *(_DWORD *)(buf.c_iflag + 4));
    return ((v3 ^ 0x2000u) >> 13) & 1;
  }
}
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7D604: using guessed type int optind;
// 7DB94: using guessed type int dword_7DB94;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0004A270) --------------------------------------------------------
int __fastcall sub_4A270(int a1, char **a2)
{
  char *v3; // r8
  char *v4; // r0
  int v5; // r6
  const char **v6; // r4
  const char *v7; // r5
  int v8; // r5
  const char *v9; // t1
  char *v11; // r0
  char *v12; // r10
  char *v13; // [sp+0h] [bp-28h] BYREF
  char dest[30]; // [sp+4h] [bp-24h] BYREF

  v3 = getenv("PATH");
  if ( !v3 )
  {
    v4 = strcpy(dest, "/sbin:/usr/sbin:/bin:/usr/bin");
    v3 = v4;
  }
  sub_593CC(a2, "^a");
  v5 = 0;
  v6 = (const char **)&a2[optind];
  do
  {
    v7 = *v6;
    if ( strchr(*v6, 47) )
    {
      if ( sub_58760(v7) )
      {
        v8 = 0;
        puts(*v6);
      }
      else
      {
        v8 = 1;
      }
    }
    else
    {
      v8 = 1;
      v13 = v3;
      do
      {
        v11 = sub_587B4(*v6, &v13);
        v12 = v11;
        if ( !v11 )
          break;
        puts(v11);
        v8 = 0;
        free(v12);
      }
      while ( dword_7DBC0 );
    }
    v9 = v6[1];
    ++v6;
    v5 |= v8;
  }
  while ( v9 );
  return v5;
}
// 7D604: using guessed type int optind;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0004A364) --------------------------------------------------------
int __fastcall sub_4A364(int a1)
{
  int v1; // r2
  int result; // r0
  int v3; // r3
  int v4; // t1

  v1 = a1 - 1;
  for ( result = 0; ; result = v3 + 63 * result )
  {
    v4 = *(unsigned __int8 *)++v1;
    v3 = v4;
    if ( !v4 )
      break;
  }
  return result;
}

//----- (0004A384) --------------------------------------------------------
unsigned __int8 *__fastcall sub_4A384(unsigned __int8 *result)
{
  int v1; // r2
  int v2; // r3
  bool v3; // zf

  v1 = dword_7DB98;
  while ( 1 )
  {
    v2 = *result;
    if ( v2 == 92 && result[1] == 10 )
    {
      ++result;
      ++*(_DWORD *)(v1 + 12);
      goto LABEL_5;
    }
    v3 = v2 == 32;
    if ( v2 != 32 )
      v3 = v2 == 9;
    if ( !v3 )
      return result;
LABEL_5:
    ++result;
  }
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004A3D0) --------------------------------------------------------
int __fastcall sub_4A3D0(int *a1)
{
  int result; // r0
  _BYTE *v3; // r2

  result = *a1;
  do
    v3 = (_BYTE *)(*a1)++;
  while ( *v3 );
  return result;
}

//----- (0004A3F4) --------------------------------------------------------
void sub_4A3F4()
{
  *(_DWORD *)(dword_7DB98 - 8) = 1;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004A40C) --------------------------------------------------------
_DWORD *__fastcall sub_4A40C(_DWORD **a1)
{
  _DWORD *v1; // r3

  v1 = *a1;
  if ( *a1 && (*v1 & 0xFF00) == 0x1300 )
  {
    *a1 = (_DWORD *)v1[3];
    return (_DWORD *)v1[2];
  }
  else
  {
    *a1 = 0;
  }
  return v1;
}

//----- (0004A444) --------------------------------------------------------
_DWORD *sub_4A444()
{
  _DWORD *v0; // r4

  v0 = sub_174DC(0x14u);
  v0[1] = 61;
  v0[4] = sub_174DC(0xF4u);
  return v0;
}

//----- (0004A470) --------------------------------------------------------
int __fastcall sub_4A470(int *a1)
{
  int v2; // r3

  while ( 1 )
  {
    v2 = *a1;
    if ( (*a1 & 0x2000) == 0 )
      break;
    a1 = (int *)a1[5];
  }
  if ( (v2 & 2) == 0 )
  {
    *a1 = v2 | 2;
    a1[5] = (int)sub_4A444();
  }
  return a1[5];
}

//----- (0004A4AC) --------------------------------------------------------
_DWORD *__fastcall sub_4A4AC(int a1)
{
  _DWORD *result; // r0

  result = sub_174DC(0x14u);
  *result = a1;
  result[1] = *(_DWORD *)(dword_7DB98 - 56);
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004A4D8) --------------------------------------------------------
_DWORD *__fastcall sub_4A4D8(int a1)
{
  int v2; // r6
  int i; // r4
  _DWORD *v4; // r1
  int v5; // r7
  _DWORD *v6; // r0
  int v7; // r2
  _DWORD *result; // r0
  unsigned int v9; // r5
  _DWORD *v10; // r3

  v2 = 0;
  for ( i = dword_7DB98; ; *(_DWORD *)(i - 40) = v4[3] )
  {
    v4 = *(_DWORD **)(i - 40);
    if ( !v4 )
      break;
    if ( a1 - 1431655765 * ((v4[1] - (int)(v4 + 4)) >> 3) <= *v4 )
      goto LABEL_8;
    v2 = *(_DWORD *)(i - 40);
  }
  if ( a1 < 64 )
    v5 = 64;
  else
    v5 = a1;
  v6 = sub_174DC(24 * v5 + 16);
  *(_DWORD *)(i - 40) = v6;
  *v6 = v5;
  v6[1] = v6 + 4;
  v6[2] = v2;
  if ( v2 )
    *(_DWORD *)(v2 + 12) = v6;
LABEL_8:
  v7 = *(_DWORD *)(i - 40);
  result = *(_DWORD **)(v7 + 4);
  v9 = (unsigned int)&result[6 * a1];
  v10 = result;
  *(_DWORD *)(v7 + 4) = v9;
  while ( v9 > (unsigned int)v10 )
  {
    *v10 = 0;
    v10 += 6;
    *(v10 - 2) = 0;
  }
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004A59C) --------------------------------------------------------
void *__fastcall sub_4A59C(void *result, int a2, int *a3)
{
  size_t v3; // r1

  if ( !result || *a3 <= a2 )
  {
    v3 = a2 + (a2 >> 1) + 80;
    *a3 = v3;
    return sub_174B4(result, v3);
  }
  return result;
}

//----- (0004A5C4) --------------------------------------------------------
int __fastcall sub_4A5C4(int a1)
{
  if ( (*(_DWORD *)a1 & 0x1000) == 0 )
    free(*(void **)(a1 + 16));
  *(_DWORD *)a1 = *(_DWORD *)a1 & 0x2C02 | 0x4000;
  *(_DWORD *)(a1 + 16) = 0;
  return a1;
}

//----- (0004A60C) --------------------------------------------------------
int __fastcall sub_4A60C(int result)
{
  int v1; // r6
  int v2; // r4
  int v3; // r7
  int v4; // r7
  int v5; // r5
  void *v6; // r0
  int v7; // r3
  int v8; // r0

  v1 = result;
  v2 = dword_7DB98;
  v3 = *(_DWORD *)(dword_7DB98 - 48);
  if ( v3 <= result )
  {
    *(_DWORD *)(dword_7DB98 - 48) = result + 16;
    v6 = sub_174B4(*(void **)(v2 - 44), 24 * (result + 16));
    v7 = *(_DWORD *)(v2 - 48);
    *(_DWORD *)(v2 - 44) = v6;
    for ( result = (int)v6 + 24 * v3; ; *(_DWORD *)(result - 8) = 0 )
    {
      result += 24;
      if ( v7 <= v3 )
        break;
      *(_DWORD *)(result - 24) = 1024;
      ++v3;
    }
  }
  v4 = v1;
  v5 = 24 * v1;
  while ( *(_DWORD *)(v2 - 52) > v4 )
  {
    ++v4;
    v8 = *(_DWORD *)(v2 - 44) + v5;
    v5 += 24;
    result = sub_4A5C4(v8);
  }
  *(_DWORD *)(v2 - 52) = v1;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004A6AC) --------------------------------------------------------
void __fastcall sub_4A6AC(_DWORD *a1)
{
  unsigned int i; // r6
  int v3; // r7
  int v4; // r4
  int v5; // r8
  void *v6; // r0

  for ( i = 0; a1[1] > i; ++i )
  {
    v3 = 4 * i;
    v4 = *(_DWORD *)(a1[4] + 4 * i);
    while ( v4 )
    {
      v5 = *(_DWORD *)(v4 + 24);
      free(*(void **)(v4 + 16));
      v6 = (void *)v4;
      v4 = v5;
      free(v6);
    }
    *(_DWORD *)(a1[4] + v3) = 0;
  }
  *a1 = 0;
  a1[3] = 0;
}

//----- (0004A710) --------------------------------------------------------
_DWORD *__fastcall sub_4A710(int a1)
{
  int v2; // r4
  _DWORD *v3; // r5
  _DWORD *v4; // r0
  _DWORD *v5; // r3
  int v6; // r3
  int v7; // r2
  int v8; // r5
  _DWORD *v9; // r5
  _DWORD *v10; // r0
  int v11; // r3

  v2 = dword_7DB98;
  v3 = *(_DWORD **)(dword_7DB98 - 92);
  if ( !*v3 )
  {
    v4 = sub_4A4AC(0);
    v5 = *(_DWORD **)(v2 - 92);
    v3[1] = v4;
    *v5 = v4;
  }
  v6 = *(_DWORD *)(v2 - 92);
  v7 = *(_DWORD *)(v2 - 60);
  if ( *(_DWORD *)(v6 + 8) != v7 )
  {
    *(_DWORD *)(v6 + 8) = v7;
    v8 = sub_4A710(768);
    *(_DWORD *)(v8 + 8) = sub_174F8(*(const char **)(v2 - 60));
  }
  v9 = *(_DWORD **)(*(_DWORD *)(v2 - 92) + 4);
  *v9 = a1;
  v10 = sub_4A4AC(10240);
  v11 = *(_DWORD *)(v2 - 92);
  v9[4] = v10;
  *(_DWORD *)(v11 + 4) = v10;
  return v9;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004A79C) --------------------------------------------------------
int __fastcall sub_4A79C(const char *a1, int a2)
{
  regex_t *v4; // r7
  regex_t *v5; // r6

  v4 = (regex_t *)(a2 + 20);
  v5 = (regex_t *)(a2 + 52);
  if ( (*(_DWORD *)a2 & 0xFF00) == 0x2100 )
  {
    regfree((regex_t *)(a2 + 20));
    regfree(v5);
  }
  if ( *a1 && a1[1] )
  {
    *(_DWORD *)a2 = 8448;
    *(_DWORD *)(a2 + 8) = v4;
    *(_DWORD *)(a2 + 12) = v5;
    sub_625E4(v4, a1, 1);
    sub_625E4(v5, a1, 3);
  }
  else
  {
    *(_DWORD *)a2 = *(unsigned __int8 *)a1;
  }
  return a2;
}

//----- (0004A828) --------------------------------------------------------
int __fastcall sub_4A828(double a1)
{
  __int64 v1; // d0
  unsigned int v2; // r3
  unsigned int *v3; // r4
  unsigned int v4; // r3
  char *endptr; // [sp+4h] [bp-4h] BYREF

  v2 = *(_DWORD *)LODWORD(a1);
  endptr = (char *)HIDWORD(a1);
  v3 = (unsigned int *)LODWORD(a1);
  if ( (v2 & 0x101) == 0 )
  {
    *(_QWORD *)(LODWORD(a1) + 8) = 0;
    LODWORD(a1) = *(_DWORD *)(LODWORD(a1) + 16);
    endptr = (char *)v3[4];
    if ( LODWORD(a1) && *(_BYTE *)LODWORD(a1) )
    {
      a1 = strtod((const char *)LODWORD(a1), &endptr);
      v4 = *v3;
      *((_QWORD *)v3 + 1) = v1;
      if ( (v4 & 0x200) == 0 )
        goto LABEL_8;
      LODWORD(a1) = sub_4A384((unsigned __int8 *)endptr);
      endptr = (char *)LODWORD(a1);
      if ( !*(_BYTE *)LODWORD(a1) )
        goto LABEL_8;
      v2 = *v3;
    }
    *v3 = v2 & 0xFFFFFDFF;
LABEL_8:
    *v3 |= 0x100u;
  }
  return LODWORD(a1);
}
// 4A874: variable 'v1' is possibly undefined

//----- (0004A8BC) --------------------------------------------------------
int __fastcall sub_4A8BC(double a1)
{
  int v1; // r4
  int result; // r0
  _BYTE *v3; // r3

  v1 = LODWORD(a1);
  sub_4A828(a1);
  result = (*(_DWORD *)v1 ^ 0x4000) & 0x4201;
  if ( result )
    return *(double *)(v1 + 8) != 0.0;
  v3 = *(_BYTE **)(v1 + 16);
  if ( v3 )
  {
    result = (unsigned __int8)*v3;
    if ( *v3 )
      return 1;
  }
  return result;
}

//----- (0004A910) --------------------------------------------------------
int __fastcall sub_4A910(double a1)
{
  double v1; // d0
  unsigned int v2; // s15
  int result; // r0
  int v4; // r3
  bool v5; // nf

  result = sub_4A828(a1);
  v5 = v1 < 0.0;
  if ( v1 >= 0.0 )
    v2 = (unsigned int)v1;
  else
    LODWORD(v1) = (unsigned int)-v1;
  if ( v5 )
    v4 = LODWORD(v1);
  else
    result = v2;
  if ( v5 )
    return -v4;
  return result;
}
// 4A91C: variable 'v1' is possibly undefined
// 4A930: variable 'v2' is possibly undefined
// 4A934: variable 'v4' is possibly undefined

//----- (0004A93C) --------------------------------------------------------
int __fastcall sub_4A93C(int a1, const char *a2)
{
  unsigned int v4; // r0
  int v5; // r1
  int i; // r4

  v4 = sub_4A364((int)a2);
  sub_15EFC(v4, *(_DWORD *)(a1 + 4));
  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * v5); i && strcmp((const char *)(i + 28), a2); i = *(_DWORD *)(i + 24) )
    ;
  return i;
}
// 4A95C: variable 'v5' is possibly undefined

//----- (0004A98C) --------------------------------------------------------
char *__fastcall sub_4A98C(unsigned int *a1, const char *a2)
{
  char *v4; // r5
  unsigned int v5; // r1
  unsigned int v6; // r0
  unsigned int v7; // r3
  unsigned int v8; // r9
  _DWORD *v9; // r0
  char *v10; // r11
  _DWORD *v11; // r8
  _DWORD *v12; // r10
  size_t v13; // r6
  unsigned int v14; // r0
  unsigned int v15; // r3
  int v16; // r1
  size_t v17; // r0
  int i; // r6
  unsigned int v20; // r0
  int v21; // r1
  int v22; // [sp+4h] [bp-8h]

  v4 = (char *)sub_4A93C((int)a1, a2);
  if ( !v4 )
  {
    v5 = a1[1];
    v6 = *a1 + 1;
    *a1 = v6;
    if ( sub_15CA0(v6, v5) > 0xA )
    {
      v7 = a1[2];
      if ( v7 != 5 )
      {
        a1[2] = v7 + 1;
        v8 = word_643F4[v7];
        v9 = sub_174DC(4 * v8);
        v10 = (char *)a1[1];
        v11 = v9;
        v12 = (_DWORD *)a1[4];
        while ( v4 != v10 )
        {
          for ( i = v12[(_DWORD)v4]; i; i = v22 )
          {
            v22 = *(_DWORD *)(i + 24);
            v20 = sub_4A364(i + 28);
            sub_15EFC(v20, v8);
            *(_DWORD *)(i + 24) = v11[v21];
            v11[v21] = i;
          }
          ++v4;
        }
        free(v12);
        a1[1] = v8;
        a1[4] = (unsigned int)v11;
      }
    }
    v13 = strlen(a2);
    v4 = (char *)sub_174DC(v13 + 33);
    strcpy(v4 + 28, a2);
    v14 = sub_4A364((int)a2);
    sub_15EFC(v14, a1[1]);
    v15 = a1[4];
    v17 = a1[3] + 1 + v13;
    *((_DWORD *)v4 + 6) = *(_DWORD *)(v15 + 4 * v16);
    *(_DWORD *)(v15 + 4 * v16) = v4;
    a1[3] = v17;
  }
  return v4;
}
// 4AA48: variable 'v16' is possibly undefined
// 4AA98: variable 'v21' is possibly undefined
// 643F4: using guessed type unsigned __int16 word_643F4[5];

//----- (0004AAB0) --------------------------------------------------------
void __fastcall sub_4AAB0(int *a1, const char *a2)
{
  unsigned int v4; // r0
  int v5; // r1
  int *i; // r6
  int v7; // r5
  size_t v8; // r0
  int v9; // r3

  v4 = sub_4A364((int)a2);
  sub_15EFC(v4, a1[1]);
  for ( i = (int *)(a1[4] + 4 * v5); ; i = (int *)(v7 + 24) )
  {
    v7 = *i;
    if ( !*i )
      break;
    if ( !strcmp((const char *)(v7 + 28), a2) )
    {
      v8 = strlen(a2);
      v9 = *a1;
      a1[3] = a1[3] - 1 - v8;
      *a1 = v9 - 1;
      *i = *(_DWORD *)(v7 + 24);
      free((void *)v7);
      return;
    }
  }
}
// 4AAD0: variable 'v5' is possibly undefined

//----- (0004AB34) --------------------------------------------------------
int __fastcall sub_4AB34(unsigned __int8 **a1)
{
  unsigned __int8 *v1; // r5
  int v2; // r6
  int v3; // r3

  v1 = *a1;
  v2 = (int)(*a1 + 1);
  *a1 = (unsigned __int8 *)v2;
  v3 = *v1;
  if ( v3 == 92 )
  {
    v3 = sub_5E668(a1);
    if ( v3 == 92 && (unsigned __int8 *)v2 == *a1 )
    {
      v3 = v1[1];
      if ( v1[1] )
        *a1 = v1 + 2;
    }
  }
  return v3;
}

//----- (0004AB88) --------------------------------------------------------
int __fastcall sub_4AB88(unsigned __int8 *a1, int a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3; // r4
  int result; // r0
  unsigned __int8 *v5[2]; // [sp+4h] [bp-8h] BYREF

  v5[1] = a3;
  v3 = a1 - 1;
  v5[0] = a1;
  do
  {
    result = sub_4AB34(v5);
    *++v3 = result;
  }
  while ( result );
  return result;
}

//----- (0004ABB4) --------------------------------------------------------
time_t __fastcall sub_4ABB4(const char *a1)
{
  struct tm v2; // [sp+1Ch] [bp-30h] BYREF

  v2.tm_isdst = -1;
  if ( sscanf(
         a1,
         "%u %u %u %u %u %u %d",
         &v2.tm_year,
         &v2.tm_mon,
         &v2.tm_mday,
         &v2.tm_hour,
         &v2.tm_min,
         &v2,
         &v2.tm_isdst) <= 5
    || !v2.tm_mon
    || v2.tm_year <= 0x76Bu )
  {
    return -1;
  }
  --v2.tm_mon;
  v2.tm_year -= 1900;
  return mktime(&v2);
}

//----- (0004AC50) --------------------------------------------------------
void __fastcall __noreturn sub_4AC50(const char *a1)
{
  sub_16DBC("%s:%i: %s", *(const char **)(dword_7DB98 - 60), *(_DWORD *)(dword_7DB98 - 56), a1);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004AC78) --------------------------------------------------------
int __fastcall sub_4AC78(char *a1, size_t a2, const char *a3, int a4)
{
  double v4; // d0
  __int64 v8; // r0
  __int64 v9; // r8
  double v10; // r0
  const char *v12; // r3
  int v13; // r7
  int v15; // r3

  if ( a4 )
  {
    LODWORD(v8) = sub_62C80(v4);
    v9 = v8;
    LODWORD(v10) = sub_62B48(v8);
    if ( v10 == v4 )
      return snprintf(a1, a2, "%lld", v9);
  }
  v12 = a3;
  do
  {
    v13 = *(unsigned __int8 *)v12;
    if ( !*v12 )
      break;
  }
  while ( *(unsigned __int8 *)++v12 );
  if ( strchr("diouxX", v13) )
    return snprintf(a1, a2, a3, (int)v4);
  if ( !strchr("eEfgG", v13) )
    sub_4AC50("Invalid format specifier");
  return snprintf(a1, a2, a3, v15, v4);
}
// 4ACA0: variable 'v4' is possibly undefined
// 4ACA4: variable 'v8' is possibly undefined
// 4ACBC: variable 'v10' is possibly undefined
// 4AD58: variable 'v15' is possibly undefined

//----- (0004AD78) --------------------------------------------------------
char *__fastcall sub_4AD78(int *a1)
{
  int v2; // r6
  char *v3; // r7
  const char *v4; // r0
  char *v5; // r0
  int v6; // r3
  char *result; // r0

  if ( (*a1 & 0x101) == 1 )
  {
    v2 = dword_7DB98;
    v3 = *(char **)(dword_7DB98 - 32);
    v4 = (const char *)sub_4AD78(*(_DWORD *)(dword_7DB98 + 16));
    sub_4AC78(v3, 0xF0u, v4, 1);
    v5 = sub_174F8(*(const char **)(v2 - 32));
    v6 = *a1;
    a1[4] = (int)v5;
    *a1 = v6 | 0x100;
  }
  result = (char *)a1[4];
  if ( !result )
    return "";
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004ADF8) --------------------------------------------------------
int __fastcall sub_4ADF8(const char *a1, int a2, _DWORD *a3)
{
  char *v5; // r5
  size_t v6; // r0
  void *v7; // r0
  int v8; // r6
  int *v9; // r0
  int i; // r4
  int v11; // r10
  signed int v12; // r7
  signed int v13; // r6
  const regex_t *v14; // r0
  regoff_t rm_so; // r3
  int v16; // t1
  int v18; // r2
  char v19; // r3
  char *v20; // r2
  unsigned __int8 v21; // r3
  char *v22; // r0
  _BYTE *v23; // r0
  _BYTE *v24; // r1
  char v25; // r1
  int v26; // t1
  unsigned __int8 *v27; // r0
  int v28; // r3
  int v29; // t1
  _BYTE *v30; // r2
  char accept; // [sp+8h] [bp-18h] BYREF
  unsigned __int8 v32; // [sp+9h] [bp-17h]
  char reject[2]; // [sp+Ah] [bp-16h] BYREF
  void *dest; // [sp+Ch] [bp-14h] BYREF
  regmatch_t pmatch; // [sp+10h] [bp-10h] BYREF

  v5 = (char *)a1;
  v6 = strlen(a1);
  v7 = sub_174DC(2 * v6 + 3);
  *a3 = v7;
  dest = v7;
  strcpy((char *)v7, v5);
  v8 = dword_7DB98;
  v32 = *(_BYTE *)a2;
  accept = v32;
  v9 = *(int **)(dword_7DB98 + 36);
  *(_WORD *)reject = 0;
  if ( !*sub_4AD78(v9) )
    reject[0] = 10;
  if ( (*(_DWORD *)a2 & 0xFF00) == 0x2100 )
  {
    i = (unsigned __int8)*v5;
    if ( *v5 )
    {
      v11 = dword_7DB98;
      i = 1;
      do
      {
        v12 = strcspn(v5, reject);
        v13 = v12;
        if ( *(_DWORD *)(v11 - 28) )
          v14 = *(const regex_t **)(a2 + 12);
        else
          v14 = *(const regex_t **)(a2 + 8);
        if ( regexec(v14, v5, 1u, &pmatch, 0) || (rm_so = pmatch.rm_so, pmatch.rm_so > v12) )
        {
          v18 = (unsigned __int8)v5[v12];
          pmatch.rm_eo = v12;
          if ( v18 )
            pmatch.rm_eo = v12 + 1;
        }
        else
        {
          ++i;
          if ( !pmatch.rm_eo )
          {
            pmatch.rm_eo = 1;
            rm_so = pmatch.rm_so + 1;
          }
          v13 = rm_so;
        }
        memcpy(dest, v5, v13);
        do
          *((_BYTE *)dest + v13++) = 0;
        while ( pmatch.rm_eo > v13 );
        sub_4A3D0((int *)&dest);
        v16 = (unsigned __int8)v5[pmatch.rm_eo];
        v5 += pmatch.rm_eo;
      }
      while ( v16 );
    }
  }
  else
  {
    v19 = accept;
    if ( accept )
    {
      if ( accept == 32 )
      {
        for ( i = 0; *v5; ++i )
        {
          v27 = sub_60E74((unsigned __int8 *)v5);
          if ( !*v27 )
            break;
          while ( 1 )
          {
            v5 = (char *)v27;
            v29 = *v27++;
            v28 = v29;
            v30 = dest;
            dest = (char *)dest + 1;
            if ( (v29 & 0xDF) == 0 || (unsigned int)(v28 - 9) <= 4 )
              break;
            *v30 = *(v27 - 1);
          }
          *v30 = 0;
        }
      }
      else
      {
        if ( *(_DWORD *)(v8 - 28) )
        {
          if ( (unsigned int)(unsigned __int8)accept - 97 <= 0x19 )
            v19 = accept - 32;
          accept = v19;
          v21 = v32;
          if ( (unsigned int)v32 - 65 <= 0x19 )
            v21 = v32 + 32;
          v32 = v21;
        }
        i = *(unsigned __int8 *)dest;
        if ( *(_BYTE *)dest )
          i = 1;
        while ( 1 )
        {
          v22 = strpbrk((const char *)dest, &accept);
          if ( !v22 )
            break;
          ++i;
          dest = v22 + 1;
          *v22 = 0;
        }
      }
    }
    else
    {
      v20 = v5;
      while ( 1 )
      {
        i = v20 - v5;
        v26 = (unsigned __int8)*v20++;
        v25 = v26;
        if ( !v26 )
          break;
        v23 = dest;
        dest = (char *)dest + 1;
        *v23 = v25;
        v24 = dest;
        dest = (char *)dest + 1;
        *v24 = 0;
      }
    }
  }
  return i;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004B08C) --------------------------------------------------------
int __fastcall sub_4B08C(int a1, int a2)
{
  int v2; // r4
  int v3; // r5
  void *v4; // r0
  char *v5; // r0
  int v6; // r8
  int result; // r0
  int v8; // r3
  double v9; // d7
  int v10; // r7
  int v11; // r9
  int v12; // r0
  int v13; // r2
  int v14; // [sp+4h] [bp-4h] BYREF

  v14 = a2;
  v2 = dword_7DB98;
  v3 = *(_DWORD *)(dword_7DB98 - 12);
  if ( !v3 )
  {
    v4 = *(void **)(dword_7DB98 + 92);
    *(_DWORD *)(dword_7DB98 - 12) = 1;
    free(v4);
    sub_4A60C(0);
    v5 = sub_4AD78(*(int **)(v2 + 52));
    v6 = sub_4ADF8(v5, v2 + 292, (_DWORD *)(v2 + 92));
    sub_4A60C(v6);
    v14 = *(_DWORD *)(v2 + 92);
    while ( v3 < v6 )
    {
      v10 = 24 * v3;
      v11 = *(_DWORD *)(v2 - 44);
      ++v3;
      v12 = sub_4A3D0(&v14);
      v13 = *(_DWORD *)(v2 - 44);
      *(_DWORD *)(v11 + v10 + 16) = v12;
      *(_DWORD *)(v13 + v10) |= 0x5200u;
    }
    result = sub_4A5C4(*(_DWORD *)(v2 + 80));
    v8 = *(_DWORD *)(v2 + 80);
    v9 = (double)*(int *)(v2 - 52);
    *(_DWORD *)v8 = 1025;
    *(double *)(v8 + 8) = v9;
  }
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004B14C) --------------------------------------------------------
int __fastcall sub_4B14C(double a1)
{
  double v1; // d0
  __int64 v2; // d8
  int v3; // r4
  int v4; // r7
  int v5; // r6
  char *v6; // r5
  size_t v7; // r8
  int v8; // r3
  char *v9; // r11
  size_t v10; // r9
  char *v11; // r0
  int *v12; // r6
  char *v13; // r0
  int v14; // r1
  char *src; // [sp+0h] [bp-40h]
  int v17; // [sp+Ch] [bp-34h] BYREF
  __int64 v18; // [sp+14h] [bp-2Ch]

  if ( (*(_DWORD *)LODWORD(a1) & 0x400) != 0 )
  {
    v18 = v2;
    v3 = dword_7DB98;
    if ( *(_DWORD *)(dword_7DB98 + 80) == LODWORD(a1) )
    {
      sub_4A828(a1);
      v4 = 0;
      v5 = 0;
      v6 = 0;
      sub_4A60C((int)v1);
      src = sub_4AD78(*(int **)(v3 + 28));
      v7 = strlen(src);
      while ( v4 < (int)v1 )
      {
        v9 = sub_4AD78((int *)(*(_DWORD *)(v3 - 44) + 24 * v4));
        v10 = strlen(v9);
        if ( v6 )
        {
          v11 = &v6[v5];
          v5 += v7;
          memcpy(v11, src, v7);
        }
        ++v4;
        v6 = (char *)sub_4A59C(v6, v5 + v10 + v7, &v17);
        memcpy(&v6[v5], v9, v10);
        v5 += v10;
      }
      if ( v6 )
        v6[v5] = 0;
      LODWORD(a1) = sub_4B308(*(_DWORD *)(v3 + 52), v6);
      v8 = 1;
      goto LABEL_8;
    }
    if ( *(_DWORD *)(dword_7DB98 + 52) == LODWORD(a1) )
    {
      v8 = 0;
LABEL_8:
      *(_DWORD *)(v3 - 12) = v8;
      return LODWORD(a1);
    }
    v12 = *(int **)(dword_7DB98 + 24);
    if ( v12 == (int *)LODWORD(a1) )
    {
      sub_4B08C(SLODWORD(a1), SHIDWORD(a1));
      v13 = sub_4AD78(v12);
      v14 = v3 + 292;
LABEL_16:
      LODWORD(a1) = sub_4A79C(v13, v14);
      return LODWORD(a1);
    }
    if ( *(_DWORD *)(dword_7DB98 + 36) == LODWORD(a1) )
    {
      v13 = sub_4AD78((int *)LODWORD(a1));
      v14 = v3 + 376;
      goto LABEL_16;
    }
    if ( *(_DWORD *)(dword_7DB98 + 84) == LODWORD(a1) )
    {
      LODWORD(a1) = sub_4A8BC(a1);
      *(_DWORD *)(v3 - 28) = LODWORD(a1);
    }
    else
    {
      LODWORD(a1) = *(_DWORD *)(dword_7DB98 + 80);
      sub_4A828(a1);
      LODWORD(a1) = sub_4B458(*(_DWORD *)(v3 + 80));
    }
  }
  return LODWORD(a1);
}
// 4B164: variable 'v2' is possibly undefined
// 4B194: variable 'v1' is possibly undefined
// 4B308: using guessed type int __fastcall sub_4B308(_DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (0004B308) --------------------------------------------------------
int __fastcall sub_4B308(int a1, int a2)
{
  double v4; // r0

  sub_4A5C4(a1);
  LODWORD(v4) = a1;
  *(_DWORD *)(a1 + 16) = a2;
  sub_4B14C(v4);
  return a1;
}
// 4B320: variable 'v4' is possibly undefined

//----- (0004B32C) --------------------------------------------------------
int __fastcall sub_4B32C(int a1, const char *a2)
{
  int v3; // r0

  v3 = (int)a2;
  if ( a2 )
  {
    if ( *a2 )
      v3 = (int)sub_174F8(a2);
    else
      v3 = *(unsigned __int8 *)a2;
  }
  return sub_4B308(a1, v3);
}

//----- (0004B360) --------------------------------------------------------
_DWORD *__fastcall sub_4B360(int a1, const char *a2)
{
  _DWORD *result; // r0

  result = (_DWORD *)sub_4B32C(a1, a2);
  *result |= 0x200u;
  return result;
}

//----- (0004B378) --------------------------------------------------------
int __fastcall sub_4B378(const char *a1)
{
  unsigned int v1; // r2
  bool v2; // cc
  char *v4; // r4
  char *v5; // r6
  int v6; // r0
  unsigned __int8 *v7; // r4
  int v8; // r1
  unsigned __int8 *v9; // r2
  char *v10; // r0

  v1 = *(unsigned __int8 *)a1;
  if ( v1 - 48 > 9 )
  {
    v2 = v1 > 0x5F;
    if ( v1 != 95 )
      v2 = (v1 | 0x20) - 97 > 0x19;
    if ( v2 )
      return 0;
  }
  v4 = strchr(a1, 61);
  if ( !v4 )
    return 0;
  v5 = sub_174F8(a1);
  v6 = v4 - a1;
  v7 = (unsigned __int8 *)&v5[v4 - a1 + 1];
  v5[v6] = 0;
  sub_4AB88(v7, v8, v9);
  v10 = sub_4A98C(*(unsigned int **)(dword_7DB98 - 76), v5);
  sub_4B360((int)v10, (const char *)v7);
  free(v5);
  return 1;
}
// 4B3E0: variable 'v8' is possibly undefined
// 4B3E0: variable 'v9' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (0004B424) --------------------------------------------------------
_DWORD *__fastcall sub_4B424(int *a1, signed int a2, const char *a3)
{
  unsigned int *v5; // r5
  const char *v6; // r0
  char *v7; // r0

  v5 = (unsigned int *)sub_4A470(a1);
  v6 = sub_16F8C(a2);
  v7 = sub_4A98C(v5, v6);
  return sub_4B360((int)v7, a3);
}

//----- (0004B458) --------------------------------------------------------
int __fastcall sub_4B458(int a1)
{
  __int64 v1; // d0
  int v3; // r3

  sub_4A5C4(a1);
  v3 = *(_DWORD *)a1;
  *(_QWORD *)(a1 + 8) = v1;
  *(_DWORD *)a1 = v3 | 1;
  sub_4B14C(a1);
  return a1;
}
// 4B474: variable 'v1' is possibly undefined
// 4B14C: using guessed type int __fastcall sub_4B14C(_DWORD);

//----- (0004B490) --------------------------------------------------------
int __fastcall sub_4B490(double a1)
{
  int v1; // r4

  v1 = LODWORD(a1);
  sub_4A828(a1);
  return sub_4B458(v1);
}

//----- (0004B4B0) --------------------------------------------------------
int __fastcall sub_4B4B0(double a1)
{
  int v1; // r4
  int v2; // r5

  v1 = LODWORD(a1);
  if ( LODWORD(a1) != HIDWORD(a1) )
  {
    v2 = HIDWORD(a1);
    sub_4A5C4(SLODWORD(a1));
    LODWORD(a1) = *(_DWORD *)(v2 + 16);
    *(_DWORD *)v1 |= *(_DWORD *)v2 & 0xFFFF83FD;
    *(_QWORD *)(v1 + 8) = *(_QWORD *)(v2 + 8);
    if ( LODWORD(a1) )
      *(_DWORD *)(v1 + 16) = sub_174F8((const char *)LODWORD(a1));
  }
  LODWORD(a1) = v1;
  sub_4B14C(a1);
  return v1;
}
// 4B500: variable 'a1' is possibly undefined

//----- (0004B50C) --------------------------------------------------------
int __fastcall sub_4B50C(double a1)
{
  double v1; // d0
  int v2; // r4
  FILE *v3; // r0
  double v4; // r0
  double v5; // r0
  const char *v7; // r5
  int v8; // r6
  int *v9; // r0
  char *v10; // r5
  unsigned int *v11; // r0
  int *v12; // r0

  v2 = dword_7DB98;
  v3 = *(FILE **)(dword_7DB98 + 116);
  if ( v3 )
    fclose(v3);
  *(_DWORD *)(v2 + 116) = 0;
  *(_DWORD *)(v2 + 124) = 0;
  *(_DWORD *)(v2 + 132) = 0;
  while ( 1 )
  {
    LODWORD(a1) = *(_DWORD *)(v2 + 56);
    sub_4A828(a1);
    LODWORD(v4) = *(_DWORD *)(v2 + 60);
    sub_4A828(v4);
    if ( v1 + 1.0 >= v1 )
      break;
    LODWORD(v5) = *(_DWORD *)(v2 + 56);
    v9 = (int *)sub_4B490(v5);
    v10 = sub_4AD78(v9);
    v11 = (unsigned int *)sub_4A470(*(int **)(v2 + 64));
    v12 = (int *)sub_4A98C(v11, v10);
    LODWORD(a1) = sub_4AD78(v12);
    v7 = (const char *)LODWORD(a1);
    if ( LODWORD(a1) && *(_BYTE *)LODWORD(a1) && !sub_4B378((const char *)LODWORD(a1)) )
    {
      v8 = sub_61D20((int)v7);
      goto LABEL_8;
    }
  }
  if ( *(_DWORD *)(v2 + 112) )
    return 0;
  v7 = "-";
  v8 = stdin;
LABEL_8:
  *(_DWORD *)(v2 + 112) = 1;
  sub_4B32C(*(_DWORD *)(v2 + 44), v7);
  *(_DWORD *)(v2 + 116) = v8;
  return v2 + 116;
}
// 4B544: variable 'a1' is possibly undefined
// 4B550: variable 'v4' is possibly undefined
// 4B554: variable 'v1' is possibly undefined
// 4B5A8: variable 'v5' is possibly undefined
// 7D610: using guessed type int stdin;
// 7DB98: using guessed type int dword_7DB98;

//----- (0004B604) --------------------------------------------------------
unsigned int __fastcall sub_4B604(unsigned int result)
{
  int v1; // r5
  int v2; // r3
  unsigned int v3; // r6
  unsigned int i; // r4
  _DWORD *v5; // r0
  int v6; // r3
  int v7; // r7
  int v8; // r3
  int v9; // r2
  _DWORD *v10; // r0
  _DWORD *v11; // r10

  v1 = dword_7DB98;
  v2 = *(_DWORD *)(dword_7DB98 - 40);
  if ( result < v2 + 16 || (v3 = result, *(_DWORD *)(v2 + 4) <= result) )
    sub_4AC50("Internal error");
  for ( i = result + 24; ; i += 24 )
  {
    v6 = *(_DWORD *)(v1 - 40);
    v7 = i - 24;
    if ( *(_DWORD *)(v6 + 4) <= i - 24 )
      break;
    if ( (*(_DWORD *)(i - 24) & 0x2002) == 2 )
    {
      v5 = (_DWORD *)sub_4A470((int *)(i - 24));
      sub_4A6AC(v5);
      free(*(void **)(*(_DWORD *)(i - 4) + 16));
      free(*(void **)(i - 4));
    }
    if ( (*(_DWORD *)(i - 24) & 0x800) != 0 )
    {
      v10 = *(_DWORD **)(i - 4);
      *(_DWORD *)(i - 4) = 0;
      while ( v10 )
      {
        v11 = (_DWORD *)v10[2];
        free(v10);
        v10 = v11;
      }
    }
    result = sub_4A5C4(v7);
  }
  *(_DWORD *)(v6 + 4) = v3;
  while ( 1 )
  {
    v8 = *(_DWORD *)(v1 - 40);
    v9 = *(_DWORD *)(v8 + 8);
    if ( !v9 || *(_DWORD *)(v8 + 4) != v8 + 16 )
      break;
    *(_DWORD *)(v1 - 40) = v9;
  }
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004B6F4) --------------------------------------------------------
int __fastcall sub_4B6F4(int a1, _DWORD *a2)
{
  int v3; // r0
  char *v4; // r9
  int v5; // r5
  int v6; // r4
  int v7; // r11
  char *v8; // r4
  const regex_t *v9; // r0
  regoff_t rm_so; // r6
  regoff_t rm_eo; // r7
  bool v12; // zf
  int v13; // r0
  int v14; // r10
  const char *v15; // r3
  _BYTE *v16; // r1
  char v17; // r2
  char v18; // r6
  const char *v20; // r0
  char *v21; // r0
  char *v22; // r3
  int v23; // r2
  int v24; // t1
  int *v25; // [sp+Ch] [bp-38h]
  int v26; // [sp+10h] [bp-34h]
  int v27; // [sp+14h] [bp-30h]
  int fd; // [sp+1Ch] [bp-28h]
  char fda; // [sp+1Ch] [bp-28h]
  int v31; // [sp+20h] [bp-24h]
  const char *v32; // [sp+20h] [bp-24h]
  int c; // [sp+24h] [bp-20h]
  int v34; // [sp+2Ch] [bp-18h] BYREF
  regmatch_t pmatch; // [sp+30h] [bp-14h] BYREF

  v3 = fileno_unlocked(*(FILE **)a1);
  v4 = *(char **)(a1 + 4);
  fd = v3;
  v26 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 16);
  v34 = *(_DWORD *)(a1 + 12);
  v6 = *(_DWORD *)(dword_7DB98 + 376);
  v25 = (int *)dword_7DB98;
  v31 = (unsigned __int8)v6;
  if ( !v4 )
  {
    v34 = 464;
    v4 = (char *)sub_174B4(0, 0x1D0u);
  }
  v27 = 0;
  v7 = 0;
  c = (unsigned __int8)v6;
  while ( 1 )
  {
    v8 = &v4[v26];
    if ( v5 <= 0 )
      goto LABEL_36;
    if ( (v25[94] & 0xFF00) == 0x2100 )
    {
      if ( *(v25 - 7) )
        v9 = (const regex_t *)v25[97];
      else
        v9 = (const regex_t *)v25[96];
      if ( regexec(v9, &v4[v26], 1u, &pmatch, 0) )
        goto LABEL_36;
      rm_so = pmatch.rm_so;
      rm_eo = pmatch.rm_eo;
      v12 = v8[pmatch.rm_eo] == 0;
    }
    else
    {
      if ( v31 )
      {
        v16 = strchr(&v8[v7], c);
        if ( v16 || (v16 = memchr(&v8[v7], 0, v5 - v7)) != 0 )
        {
          rm_so = v16 - v8;
          rm_eo = v16 - v8 + 1;
LABEL_28:
          v14 = 1;
          goto LABEL_29;
        }
LABEL_36:
        rm_eo = v5;
        rm_so = v5;
        goto LABEL_13;
      }
      v15 = &v8[v27];
      do
      {
        v20 = v15;
        v27 = v15 - v8;
        ++v15;
      }
      while ( *v20 == 10 );
      v21 = strstr(v20, "\n\n");
      if ( !v21 )
        goto LABEL_36;
      rm_so = v21 - v8;
      v22 = v21;
      do
      {
        rm_eo = v22 - v8;
        v24 = (unsigned __int8)*v22++;
        v23 = v24;
      }
      while ( v24 == 10 );
      v12 = v23 == 0;
    }
    if ( !v12 )
      goto LABEL_28;
LABEL_13:
    if ( v26 > 0 )
    {
      memmove(v4, v8, v5 + 1);
      v26 = 0;
    }
    v4 = (char *)sub_4A59C(v4, v26 + v5 + 128, &v34);
    v8 = &v4[v26];
    v13 = v5 + sub_1800C(fd, &v4[v26 + v5], v34 - v5 - 1);
    if ( v5 > v13 )
    {
      v14 = 0;
      sub_4B458(v25[17]);
      v13 = 0;
    }
    else
    {
      v14 = 1;
    }
    v8[v13] = 0;
    v7 = v5;
    if ( v5 >= v13 )
      break;
    v5 = v13;
  }
  if ( !v13 )
  {
    --v14;
    goto LABEL_30;
  }
  v5 = v13;
LABEL_29:
  v17 = v8[rm_so];
  v32 = &v8[rm_so];
  v8[rm_so] = 0;
  fda = v17;
  sub_4B32C((int)a2, &v8[v27]);
  *a2 |= 0x200u;
  v8[rm_so] = fda;
  v18 = v8[rm_eo];
  v8[rm_eo] = 0;
  sub_4B32C(v25[10], v32);
  v13 = v5;
  v8[rm_eo] = v18;
LABEL_30:
  *(_DWORD *)(a1 + 16) = v13 - rm_eo;
  *(_DWORD *)(a1 + 4) = v4;
  *(_DWORD *)(a1 + 8) = v26 + rm_eo;
  *(_DWORD *)(a1 + 12) = v34;
  return v14;
}
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;

//----- (0004B9E0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall __noreturn sub_4B9E0(int a1)
{
  int v2; // r4
  unsigned int i; // r6
  int v4; // r3
  int j; // r5
  _BYTE _0[24]; // [sp+0h] [bp-10h] OVERLAPPED BYREF

  memset(_0, 0, sizeof(_0));
  v2 = dword_7DB98;
  if ( !*(_DWORD *)(dword_7DB98 - 24) )
  {
    *(_QWORD *)(dword_7DB98 - 24) = 1;
    sub_14790(*(_DWORD *)(v2 - 104), _0);
  }
  for ( i = 0; ; ++i )
  {
    v4 = *(_DWORD *)(v2 - 68);
    if ( *(_DWORD *)(v4 + 4) <= i )
      break;
    for ( j = *(_DWORD *)(*(_DWORD *)(v4 + 16) + 4 * i); j; j = *(_DWORD *)(j + 24) )
    {
      if ( *(_DWORD *)j )
      {
        if ( *(_DWORD *)(j + 20) )
          pclose(*(FILE **)j);
      }
    }
  }
  exit(a1);
}
// 4B9E0: variables would overlap: ^0.24 and stkvar "__saved_registers" ^10.16(special frame member)
// 14790: using guessed type int __fastcall sub_14790(_DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (0004BA78) --------------------------------------------------------
regex_t *__fastcall sub_4BA78(_DWORD *a1, regex_t *a2)
{
  int v3; // r7
  regex_t *v4; // r4
  _DWORD *v6; // r6
  int *v7; // r0
  char *v8; // r1
  const char *v9; // r5
  int v10; // r7

  v3 = dword_7DB98;
  if ( (*a1 & 0xFF00) == 0x2100 )
  {
    if ( *(_DWORD *)(dword_7DB98 - 28) )
      return (regex_t *)a1[3];
    else
      return (regex_t *)a1[2];
  }
  else
  {
    v4 = a2;
    v6 = sub_4A4D8(1);
    v7 = (int *)sub_14790(a1, v6);
    v8 = sub_4AD78(v7);
    v9 = v8;
    if ( *(_DWORD *)(v3 - 28) )
      v10 = 3;
    else
      v10 = 1;
    if ( regcomp(v4, v8, v10) )
      sub_625E4(v4, v9, v10 & 2);
    sub_4B604((unsigned int)v6);
  }
  return v4;
}
// 14790: using guessed type int __fastcall sub_14790(_DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (0004BB1C) --------------------------------------------------------
int __fastcall sub_4BB1C(_DWORD *a1, const char *a2, int a3, int *a4, int a5, char a6)
{
  regex_t *v7; // r10
  char *v8; // r7
  size_t v9; // r0
  int eflags; // r3
  int v11; // r4
  int v12; // r9
  char *v13; // r6
  int v14; // r5
  size_t v15; // r0
  size_t rm_eo; // r11
  int v18; // r3
  int v19; // r2
  int v20; // r1
  int v21; // r8
  int v22; // r8
  int v23; // r4
  _BYTE *v24; // r4
  size_t v25; // r5
  char *v26; // r0
  int v27; // r1
  int v28; // [sp+8h] [bp-9Ch]
  const char *v29; // [sp+8h] [bp-9Ch]
  size_t v30; // [sp+Ch] [bp-98h]
  regoff_t rm_so; // [sp+10h] [bp-94h]
  int v34; // [sp+2Ch] [bp-78h] BYREF
  regex_t v35; // [sp+30h] [bp-74h] BYREF
  regmatch_t pmatch; // [sp+50h] [bp-54h] BYREF
  _BYTE v37[4]; // [sp+A0h] [bp-4h] BYREF

  v7 = sub_4BA78(a1, &v35);
  if ( !a4 )
    a4 = *(int **)(dword_7DB98 + 52);
  v8 = sub_4AD78(a4);
  v9 = strlen(a2);
  eflags = 0;
  v30 = v9;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  while ( 1 )
  {
    v14 = regexec(v7, v8, 0xAu, &pmatch, eflags);
    if ( v14 )
      break;
    v28 = v11;
    rm_eo = pmatch.rm_eo;
    ++v12;
    rm_so = pmatch.rm_so;
    v11 += pmatch.rm_eo;
    v13 = (char *)sub_4A59C(v13, v11 + v30, &v34);
    memcpy(&v13[v28], v8, rm_eo);
    if ( v12 >= a3 )
    {
      v11 -= rm_eo - rm_so;
      v29 = a2 - 1;
      while ( 1 )
      {
        v18 = *(unsigned __int8 *)++v29;
        v19 = v11;
        if ( !v18 )
          break;
        ++v11;
        v13[v19] = v18;
        if ( v18 == 92 )
        {
          ++v14;
        }
        else if ( v18 == 38 || ((unsigned int)(v18 - 48) <= 9 ? (v20 = a6 & 1) : (v20 = 0), v20) )
        {
          v21 = v14 + 3;
          if ( v18 != 38 )
            LOBYTE(v14) = v14 + 1;
          v22 = v11 - (v21 >> 1);
          if ( v18 == 38 )
            v23 = 0;
          else
            v23 = v18 - 48;
          if ( (v14 & 1) != 0 )
          {
            v11 = v22 + 1;
            v13[v22] = v18;
          }
          else
          {
            v24 = &v37[8 * v23];
            v25 = *((_DWORD *)v24 - 19) - *((_DWORD *)v24 - 20);
            v26 = (char *)sub_4A59C(v13, v30 + v22 + v25, &v34);
            v27 = *((_DWORD *)v24 - 20);
            v13 = v26;
            v11 = v22 + v25;
            memcpy(&v26[v22], &v8[v27], v25);
          }
          v14 = 0;
        }
        else
        {
          v14 = 0;
        }
      }
    }
    v8 += rm_eo;
    if ( v12 == a3 )
      break;
    if ( rm_so == rm_eo )
    {
      v13[v11] = *v8;
      if ( !*v8 )
        goto LABEL_6;
      ++v8;
      ++v11;
    }
    eflags = 1;
  }
  v15 = strlen(v8);
  v13 = (char *)sub_4A59C(v13, v15 + v11, &v34);
  strcpy(&v13[v11], v8);
LABEL_6:
  if ( !a5 )
    a5 = *(_DWORD *)(dword_7DB98 + 52);
  sub_4B308(a5, (int)v13);
  if ( v7 == &v35 )
    regfree(v7);
  return v12;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004BD98) --------------------------------------------------------
int __fastcall sub_4BD98(unsigned int *a1, int a2)
{
  double v2; // d0
  double v4; // r0
  _DWORD *v5; // r7
  int v6; // r5
  unsigned int v7; // r6
  unsigned int *v8; // r3
  unsigned int v9; // r8
  _BOOL4 v10; // r3
  int v11; // r6
  double v12; // r0
  double v13; // r0
  double v14; // r2
  int v15; // r0
  int *v16; // r0
  char *v17; // r0
  int v18; // r5
  int v19; // r0
  int *v20; // r8
  int v21; // r6
  unsigned __int8 *buffer; // r9
  _DWORD *v23; // r0
  const char *v24; // r0
  signed int v25; // r1
  char *v26; // r9
  signed int v27; // r8
  double v28; // r0
  double v29; // r0
  double v30; // d0
  int v31; // r6
  int v32; // r6
  int v33; // r1
  char *v34; // r1
  double v36; // r0
  char *v37; // r2
  int v38; // r3
  int v39; // t1
  char v40; // r12
  char *v41; // r10
  char *v42; // r8
  signed int v43; // r6
  int v44; // r9
  bool v45; // cc
  int v46; // r5
  const char *v47; // r0
  char *v48; // r5
  int v49; // r6
  char *v50; // r8
  struct tm *v51; // r0
  regex_t *v52; // r5
  int v53; // r0
  int rm_so; // r3
  int v55; // r8
  char *v56; // r0
  char *v57; // r0
  _DWORD *v58; // r5
  char *v59; // r6
  unsigned int *v60; // [sp+Ch] [bp-6Ch] BYREF
  time_t timer; // [sp+14h] [bp-64h] BYREF
  _DWORD *v62[2]; // [sp+18h] [bp-60h]
  _DWORD *v63; // [sp+20h] [bp-58h]
  int v64; // [sp+28h] [bp-50h]
  int *v65; // [sp+2Ch] [bp-4Ch]
  int *v66; // [sp+30h] [bp-48h]
  int *v67; // [sp+34h] [bp-44h]
  char *s; // [sp+38h] [bp-40h]
  char *v69; // [sp+3Ch] [bp-3Ch]
  regmatch_t pmatch; // [sp+48h] [bp-30h] BYREF
  regex_t v71; // [sp+58h] [bp-20h] BYREF

  v60 = a1;
  v5 = sub_4A4D8(4);
  v6 = 0;
  v67 = 0;
  v7 = *v60;
  v8 = (unsigned int *)v60[2];
  v66 = 0;
  v9 = v7;
  v60 = v8;
  while ( 1 )
  {
    v10 = v6 <= 3;
    if ( !v60 )
      v10 = 0;
    if ( !v10 )
      break;
    LODWORD(v4) = sub_4A40C(&v60);
    v62[v6] = (_DWORD *)LODWORD(v4);
    if ( (v9 & 0x9000000) != 0 )
      *(&v64 + v6) = sub_14790(LODWORD(v4), &v5[6 * v6]);
    if ( (v9 & 0x8000000) != 0 )
      (&s)[v6] = sub_4AD78((int *)*(&v64 + v6));
    v9 >>= 1;
    ++v6;
  }
  if ( v6 < v7 >> 30 )
    sub_4AC50("Too few arguments for builtin");
  v11 = v7 & 0x7F;
  switch ( v11 )
  {
    case 0:
      LODWORD(v4) = v64;
      sub_4A828(v4);
      LODWORD(v12) = v65;
      LODWORD(v13) = sub_4A828(v12);
      atan2(v13, v14);
      goto LABEL_14;
    case 1:
      v41 = v69;
      v42 = s;
      v43 = strlen(v69);
      v44 = strlen(s) - v43;
      v45 = v44 <= 0;
      if ( v44 >= 0 )
        v45 = v43 <= 0;
      if ( !v45 )
      {
        if ( *(_DWORD *)(dword_7DB98 - 28) )
        {
          v46 = 0;
          do
            v47 = &v42[v46++];
          while ( strncasecmp(v47, v41, v43) && v44 >= v46 );
        }
        else
        {
          strstr(s, v69);
        }
      }
      goto LABEL_14;
    case 2:
      v52 = sub_4BA78(v62[1], &v71);
      v53 = regexec(v52, s, 1u, &pmatch, 0);
      if ( v53 )
      {
        rm_so = -1;
        pmatch.rm_so = 0;
      }
      else
      {
        rm_so = pmatch.rm_so;
      }
      if ( !v53 )
      {
        pmatch.rm_so = rm_so + 1;
        rm_so = pmatch.rm_eo + 1;
      }
      pmatch.rm_eo = rm_so;
      v55 = dword_7DB98;
      v56 = sub_4A98C(*(unsigned int **)(dword_7DB98 - 76), "RSTART");
      sub_4B458((int)v56);
      v57 = sub_4A98C(*(unsigned int **)(v55 - 76), "RLENGTH");
      sub_4B458((int)v57);
      sub_4B458(a2);
      if ( v52 == &v71 )
        regfree(v52);
      break;
    case 3:
      if ( v6 <= 2 )
      {
        v15 = dword_7DB98 + 292;
      }
      else
      {
        v15 = (int)v63;
        if ( (*v63 & 0xFF00) != 0x2100 )
        {
          v16 = (int *)sub_14790(v63, v5 + 12);
          v17 = sub_4AD78(v16);
          v15 = sub_4A79C(v17, dword_7DB98 + 208);
        }
      }
      v18 = 1;
      v19 = sub_4ADF8(s, v15, &v71);
      v20 = v65;
      v21 = v19;
      buffer = v71.buffer;
      v23 = (_DWORD *)sub_4A470(v65);
      sub_4A6AC(v23);
      while ( v18 <= v21 )
      {
        v24 = (const char *)sub_4A3D0((int *)&v71);
        v25 = v18++;
        sub_4B424(v20, v25, v24);
      }
      free(buffer);
      goto LABEL_14;
    case 4:
      v26 = s;
      v27 = strlen(s);
      LODWORD(v28) = v65;
      sub_4A828(v28);
      v30 = v2 - 1.0;
      v31 = (int)v30;
      if ( v27 < (int)v30 )
        v31 = v27;
      v32 = v31 & ~(v31 >> 31);
      if ( v6 > 2 )
      {
        LODWORD(v29) = v66;
        sub_4A828(v29);
        v33 = (int)v30;
      }
      else
      {
        v33 = v27 - v32;
      }
      v34 = (char *)sub_1751C(&v26[v32], v33 & ~(v33 >> 31));
      goto LABEL_29;
    case 5:
      if ( v6 <= 1 )
      {
        time(&timer);
      }
      else
      {
        LODWORD(v4) = v65;
        sub_4A828(v4);
        timer = (int)v2;
      }
      if ( v6 )
        v48 = s;
      else
        v48 = "%a %b %d %H:%M:%S %Z %Y";
      v49 = dword_7DB98;
      v50 = *(char **)(dword_7DB98 - 32);
      v51 = localtime(&timer);
      *(_BYTE *)(*(_DWORD *)(v49 - 32) + strftime(v50, 0xF0u, v48, v51)) = 0;
      sub_4B32C(a2, *(const char **)(v49 - 32));
      break;
    case 6:
      sub_4ABB4(s);
      goto LABEL_14;
    case 7:
    case 8:
      v34 = sub_174F8(s);
      v37 = v34 - 1;
      while ( 1 )
      {
        v39 = (unsigned __int8)*++v37;
        v38 = v39;
        if ( !v39 )
          break;
        v40 = v38 | 0x20;
        if ( (v38 | 0x20u) - 97 <= 0x19 )
        {
          if ( v11 == 8 )
            v40 = v38 & 0xDF;
          *v37 = v40;
        }
      }
LABEL_29:
      sub_4B308(a2, (int)v34);
      break;
    case 9:
      LODWORD(v4) = v66;
      v58 = v62[0];
      v59 = v69;
      sub_4A828(v4);
      sub_4BB1C(v58, v59, (int)v2, v67, a2, 1);
      break;
    case 10:
      sub_4BB1C(v62[0], v69, 0, v66, (int)v66, 0);
      goto LABEL_14;
    case 11:
      sub_4BB1C(v62[0], v69, 1, v66, (int)v66, 0);
      goto LABEL_14;
    case 12:
    case 14:
    case 15:
    case 16:
    case 17:
      LODWORD(v4) = v64;
      sub_4A910(v4);
      LODWORD(v36) = v65;
      sub_4A910(v36);
      goto LABEL_14;
    case 13:
      LODWORD(v4) = v64;
      sub_4A910(v4);
LABEL_14:
      sub_4B458(a2);
      break;
    default:
      break;
  }
  sub_4B604((unsigned int)v5);
  return a2;
}
// 4BE68: control flows out of bounds to 4BE6C
// 4BEB8: variable 'v4' is possibly undefined
// 4BEC4: variable 'v12' is possibly undefined
// 4BED0: variable 'v13' is possibly undefined
// 4BED0: variable 'v14' is possibly undefined
// 4BFA4: variable 'v28' is possibly undefined
// 4BFAC: variable 'v2' is possibly undefined
// 4BFD4: variable 'v29' is possibly undefined
// 4C020: variable 'v36' is possibly undefined
// 14790: using guessed type int __fastcall sub_14790(_DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (0004C344) --------------------------------------------------------
_BYTE *__fastcall sub_4C344(_DWORD *a1)
{
  double v1; // d0
  int v2; // r4
  void *v3; // r6
  _DWORD *v4; // r9
  _DWORD *v5; // r0
  int *v6; // r0
  char *v7; // r0
  char *v8; // r11
  const char *v9; // r7
  _BYTE *result; // r0
  char *i; // r5
  char *v12; // r3
  int v13; // r1
  int v14; // t1
  size_t v15; // r8
  size_t v16; // r10
  _DWORD *v17; // r0
  double v18; // r0
  bool v19; // zf
  double v20; // r0
  int v21; // r3
  int v22; // r2
  int v23; // r0
  int v24; // r0
  char *v25; // r8
  size_t v26; // r0
  int v27; // r3
  int v28; // [sp+0h] [bp-1Ch]
  int v29; // [sp+4h] [bp-18h]
  int *v30; // [sp+4h] [bp-18h]
  _DWORD *v31[2]; // [sp+Ch] [bp-10h] BYREF
  int v32; // [sp+14h] [bp-8h] BYREF

  v2 = 0;
  v3 = 0;
  v31[0] = a1;
  v4 = sub_4A4D8(1);
  v5 = sub_4A40C(v31);
  v6 = (int *)sub_14790(v5, v4);
  v7 = sub_4AD78(v6);
  v8 = sub_174F8(v7);
  v9 = v8;
  while ( *v9 )
  {
    for ( i = (char *)v9; *i; ++i )
    {
      v12 = i + 1;
      if ( *i == 37 )
      {
        if ( i[1] != 37 )
        {
          while ( 1 )
          {
            i = v12;
            v14 = (unsigned __int8)*v12++;
            v13 = v14;
            if ( !v14 || (v13 | 0x20u) - 97 <= 0x19 )
              break;
            if ( v13 == 42 )
              sub_4AC50("%*x formats are not supported");
          }
          break;
        }
        ++i;
      }
    }
    v15 = i - v9 + 240;
    v16 = v2 + v15;
    v3 = sub_4A59C(v3, v2 + v15, &v32);
    v29 = (unsigned __int8)*i;
    if ( *i )
      ++i;
    v28 = (unsigned __int8)*i;
    *i = 0;
    v17 = sub_4A40C(v31);
    LODWORD(v18) = sub_14790(v17, v4);
    v19 = v29 == 0;
    if ( v29 )
      v19 = v29 == 99;
    if ( v19 )
    {
      v30 = (int *)LODWORD(v18);
      sub_4A828(v18);
      HIDWORD(v20) = v30;
      LODWORD(v20) = v30;
      if ( (*v30 & 0x4201) == 0x4000 )
      {
        v22 = (unsigned __int8)*sub_4AD78(v30);
      }
      else
      {
        sub_4A828(v20);
        v30 = (int *)v1;
        v22 = (unsigned __int8)(unsigned int)v1;
      }
      v23 = sprintf((char *)v3 + v2, v9, v22, v21, v28, v30);
    }
    else if ( v29 == 115 )
    {
      v25 = sub_4AD78((int *)LODWORD(v18));
      v26 = strlen(v25);
      v3 = sub_4A59C(v3, v16 + v26, &v32);
      v23 = sprintf((char *)v3 + v2, v9, v25, v27, v28, 115);
    }
    else
    {
      sub_4A828(v18);
      v23 = sub_4AC78((char *)v3 + v2, v15, v9, 0);
    }
    v24 = v2 + v23;
    v9 = i;
    if ( v2 < v24 )
      v2 = v24;
    *i = v28;
  }
  free(v8);
  sub_4B604((unsigned int)v4);
  result = sub_174B4(v3, v2 + 1);
  result[v2] = 0;
  return result;
}
// 4C47C: variable 'v18' is possibly undefined
// 4C4A4: variable 'v1' is possibly undefined
// 4C4B4: variable 'v21' is possibly undefined
// 4C4CC: variable 'v28' is possibly undefined
// 4C52C: variable 'v27' is possibly undefined
// 14790: using guessed type int __fastcall sub_14790(_DWORD, _DWORD);

//----- (0004C558) --------------------------------------------------------
int __fastcall sub_4C558(int a1)
{
  double v1; // r0

  LODWORD(v1) = sub_14790(a1, dword_7DB98 + 184);
  return sub_4A8BC(v1);
}
// 4C570: variable 'v1' is possibly undefined
// 14790: using guessed type int __fastcall sub_14790(_DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (0004C578) --------------------------------------------------------
int __fastcall sub_4C578(unsigned int a1)
{
  __int64 v1; // d0
  _DWORD *v3; // r5
  int result; // r0
  const char *v5; // r0
  unsigned __int8 *v6; // r4
  int v7; // r11
  unsigned __int8 *v8; // r0
  int v9; // r3
  unsigned __int8 *v10; // r2
  int v11; // r1
  int v12; // t1
  bool v13; // zf
  unsigned int v14; // r7
  unsigned __int8 *v15; // r4
  unsigned __int8 *i; // r6
  unsigned __int8 *v17; // r3
  _BYTE *v18; // r7
  bool v19; // cc
  bool v20; // zf
  int v21; // r3
  int v22; // r6
  int v23; // r3
  bool v24; // zf
  _BYTE *v25; // r6
  unsigned __int8 *v26; // r8
  unsigned __int8 *v27; // r4
  int v28; // r3
  int v29; // t1
  const char *v30; // r9
  int v31; // r0
  _DWORD *v32; // r3
  unsigned int v33; // r2
  bool v34; // cc
  size_t v35; // r8
  bool v36; // cc
  unsigned int v37; // r2
  unsigned int v38; // t1
  bool v39; // cc
  bool v40; // r3
  int v41; // r3
  _DWORD *v42; // [sp+4h] [bp-10h]
  unsigned __int8 *v43; // [sp+Ch] [bp-8h] BYREF

  v3 = (_DWORD *)dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 - 8) )
  {
    *(_DWORD *)(dword_7DB98 - 8) = 0;
  }
  else if ( *(_DWORD *)(dword_7DB98 + 108) )
  {
    *(_DWORD *)(dword_7DB98 + 108) = 0;
    v3[1] = v3[24];
    *v3 = v3[25];
  }
  else
  {
    v6 = *(unsigned __int8 **)(dword_7DB98 - 36);
    v7 = a1 | 0x1FF8080;
    do
    {
      v8 = sub_4A384(v6);
      v9 = v3[3];
      v6 = v8;
      *(v3 - 14) = v9;
      if ( *v8 == 35 )
      {
        v10 = v8;
        do
        {
          v6 = v10;
          v12 = *v10++;
          v11 = v12;
          v13 = v12 == 10;
          if ( v12 != 10 )
            v13 = v11 == 0;
        }
        while ( !v13 );
      }
      if ( *v6 == 10 )
        v3[3] = v9 + 1;
      v14 = *v6;
      if ( !*v6 )
      {
        v22 = 0x2000000;
        goto LABEL_36;
      }
      if ( v14 == 34 )
      {
        v15 = v6 + 1;
        v3[2] = v15;
        for ( i = v15; ; ++i )
        {
          v21 = *v15;
          if ( v21 == 34 )
            break;
          v20 = v21 == 10;
          if ( v21 != 10 )
            v20 = v21 == 0;
          if ( v20 )
            goto LABEL_32;
          v43 = v15;
          *i = sub_4AB34(&v43);
          v15 = v43;
        }
        v6 = v15 + 1;
        *i = 0;
        v22 = 0x20000000;
      }
      else if ( ((v14 == 47) & (a1 >> 2)) != 0 )
      {
        v17 = v6 + 1;
        v3[2] = v6 + 1;
        v18 = v6 + 1;
LABEL_52:
        v26 = v17;
        while ( 1 )
        {
          v27 = v26;
          v29 = *v26++;
          v28 = v29;
          if ( v29 == 47 )
            break;
          v24 = v28 == 10;
          if ( v28 != 10 )
            v24 = v28 == 0;
          if ( v24 )
          {
LABEL_32:
            v5 = "Unexpected end of string";
            goto LABEL_33;
          }
          *v18 = v28;
          v25 = v18 + 1;
          if ( v28 == 92 )
          {
            v43 = v26;
            *v18 = sub_5E668(&v43);
            if ( v27[1] == 92 )
            {
              v18[1] = 92;
              v25 = v18 + 2;
            }
            v17 = v43;
            if ( v43 == v26 )
            {
              v17 = v27 + 2;
              *v25++ = v27[1];
            }
            v18 = v25;
            goto LABEL_52;
          }
          ++v18;
        }
        v6 = v26;
        *v18 = 0;
        v22 = 4;
      }
      else
      {
        v19 = v14 > 0x2E;
        if ( v14 != 46 )
          v19 = v14 - 48 > 9;
        if ( v19 )
        {
          v32 = &unk_63CE4;
          v22 = 1;
          v30 = (const char *)&unk_6AAC2;
          while ( 1 )
          {
            v35 = *(unsigned __int8 *)v30;
            if ( !*v30 )
              break;
            ++v30;
            if ( v35 == 255 )
            {
              v22 *= 2;
            }
            else
            {
              if ( (v7 & v22) != 0 )
              {
                v42 = v32;
                v31 = strncmp((const char *)v6, v30, v35);
                v32 = v42;
                if ( !v31 )
                {
                  if ( (v22 & 0x1FF0080) == 0 )
                    goto LABEL_67;
                  v33 = v6[v35];
                  if ( v33 - 48 > 9 )
                  {
                    v34 = v33 > 0x5F;
                    if ( v33 != 95 )
                      v34 = (v33 | 0x20) - 97 > 0x19;
                    if ( v34 )
                    {
LABEL_67:
                      v6 += v35;
                      *v3 = *v42;
                      goto LABEL_36;
                    }
                  }
                }
              }
              ++v32;
              v30 += v35;
            }
          }
          v36 = v14 > 0x5F;
          if ( v14 != 95 )
            v36 = (v14 | 0x20) - 97 > 0x19;
          if ( v36 )
          {
LABEL_27:
            v5 = "Unexpected token";
            goto LABEL_33;
          }
          v3[2] = --v6;
          while ( 1 )
          {
            v38 = *++v6;
            v37 = v38;
            if ( v38 - 48 > 9 )
            {
              v39 = v37 > 0x5F;
              if ( v37 != 95 )
                v39 = (v37 | 0x20) - 97 > 0x19;
              v40 = !v39;
              if ( v39 )
                break;
            }
            *(v6 - 1) = v37;
          }
          *(v6 - 1) = v40;
          if ( (a1 & 0xC000000) != 0x4000000 )
            v6 = sub_4A384(v6);
          v41 = *v6;
          if ( v41 == 40 )
          {
            v22 = 0x10000000;
          }
          else if ( v41 == 91 )
          {
            ++v6;
            v22 = 0x8000000;
          }
          else
          {
            v22 = 0x4000000;
          }
        }
        else
        {
          v43 = v6;
          strtod((const char *)v6, (char **)&v43);
          v6 = v43;
          *((_QWORD *)v3 - 17) = v1;
          if ( *v6 == 46 )
            goto LABEL_27;
          v22 = 0x40000000;
        }
      }
LABEL_36:
      v23 = v3[26];
      *(v3 - 9) = v6;
    }
    while ( (v23 & 0xF3C0) != 0 && (v22 & 0x8000) != 0 );
    if ( (v23 & 0x64000812) != 0 && (v22 & 0x7C380421) != 0 && (a1 & 0x3C0) != 0 )
    {
      v3[24] = v22;
      v3[27] = 1;
      v22 = 960;
      v3[25] = *v3;
      *v3 = 588190976;
    }
    v3[1] = v22;
  }
  result = v3[1];
  v3[26] = result;
  if ( (result & a1) == 0 )
  {
    v13 = (result & 0x2008000) == 0;
    v5 = "Unexpected token";
    if ( !v13 )
      v5 = "Unexpected end of string";
LABEL_33:
    sub_4AC50(v5);
  }
  return result;
}
// 4C6A0: variable 'v1' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (0004C960) --------------------------------------------------------
int sub_4C960()
{
  sub_4C578(1u);
  return sub_4C978(2);
}
// 4C978: using guessed type int __fastcall sub_4C978(_DWORD);

//----- (0004C978) --------------------------------------------------------
int __fastcall sub_4C978(int a1)
{
  int *v2; // r11
  int *v3; // r8
  unsigned int v4; // r6
  int v5; // r10
  unsigned int v6; // r5
  int v8; // r7
  int v9; // r0
  int *v10; // r4
  int v11; // r1
  int *v12; // r0
  int v13; // r0
  _DWORD *v14; // r6
  int *v15; // r0
  int v16; // r2
  int v17; // r2
  const char *v18; // r11
  int v19; // r0
  void *v20; // r0
  const char *v21; // r7
  regex_t *v22; // r0
  regex_t *v23; // r5
  const char *v24; // r1
  int v25; // [sp+Ch] [bp+0h] BYREF
  int v26; // [sp+18h] [bp+Ch]

  v2 = &v25;
  v3 = 0;
  v25 = 2130706432;
  v4 = a1 | 0x7C380425;
  v26 = 0;
  v5 = a1 | 0x7C3807F1;
  while ( 1 )
  {
    v6 = sub_4C578(v4);
    if ( (a1 & v6) != 0 )
      return v26;
    v8 = dword_7DB98;
    v9 = *(_DWORD *)dword_7DB98;
    if ( v3 && v9 == 654513154 )
    {
      v10 = sub_4A4AC(621745408);
      v4 = 2084045857;
      v3[2] = (int)v10;
      v10[4] = (int)v3;
      v3 = 0;
      goto LABEL_7;
    }
    if ( (v6 & 0x3D0) != 0 )
    {
      v11 = *(_DWORD *)dword_7DB98 & 0xFF00;
      while ( 1 )
      {
        v14 = (_DWORD *)v2[4];
        if ( (v9 & 0x7F000000u) <= (*v14 & 0x7E000000u) && (*v2 != v9 || v11 != 4608) )
          break;
        v2 = (int *)v2[4];
      }
      if ( v11 == 9472 )
        *(_DWORD *)dword_7DB98 = v9 + 100663296;
      v15 = sub_4A4AC(*(_DWORD *)v8);
      v16 = v2[4];
      v14[3] = v15;
      v10 = v15;
      v15[4] = v16;
      if ( (v6 & 0x3C0) != 0 )
      {
        v17 = *(_DWORD *)v8;
        v15[2] = (int)v2;
        if ( (v17 & 0xFF00) != 0x2000 )
        {
          v4 = 2084045861;
LABEL_29:
          v2[4] = (int)v10;
          goto LABEL_7;
        }
        sub_4C578(0x200000u);
        *v10 &= 0x80FFFFFF;
      }
      else
      {
        v15[3] = (int)v2;
      }
      v4 = a1 | 0x7C3807E1;
      goto LABEL_29;
    }
    v12 = sub_4A4AC(v9);
    v10 = v12;
    v2[3] = (int)v12;
    v12[4] = (int)v2;
    if ( (v6 & 0x7C380005) != 0 )
    {
      v4 = v5;
      if ( v6 == 0x200000 )
      {
        v3 = v12;
        v4 = a1 | 0x7C3807E1;
      }
      else if ( v6 > 0x200000 )
      {
        if ( v6 == 0x10000000 )
        {
          v24 = *(const char **)(v8 + 8);
          *v12 = 6400;
          v12[3] = (int)sub_4A98C(*(unsigned int **)(v8 - 64), v24);
LABEL_51:
          v10[2] = sub_4C960();
          goto LABEL_7;
        }
        if ( v6 > 0x10000000 )
        {
          if ( v6 == 0x20000000 || v6 == 0x40000000 )
          {
            *v12 = 9984;
            v20 = sub_174DC(0x18u);
            v10[2] = (int)v20;
            if ( (v6 & 0x40000000) != 0 )
              sub_4B458((int)v20);
            else
              sub_4B32C((int)v20, *(const char **)(v8 + 8));
          }
        }
        else if ( v6 == 0x4000000 || v6 == 0x8000000 )
        {
          v18 = *(const char **)(v8 + 8);
          *v12 = 9984;
          v19 = sub_4A93C(*(_DWORD *)(v8 - 72), v18);
          if ( v19 )
          {
            *v10 = 6144;
            v10[2] = *(_DWORD *)(v19 + 20);
          }
          else
          {
            v10[2] = (int)sub_4A98C(*(unsigned int **)(v8 - 76), v18);
          }
          if ( (v6 & 0x8000000) != 0 )
          {
            *v10 |= 0xA0000u;
            v10[3] = sub_4C978(2048);
          }
        }
      }
      else
      {
        if ( v6 == 4 )
        {
          v21 = *(const char **)(v8 + 8);
          v22 = (regex_t *)sub_174DC(0x40u);
          v23 = v22 + 1;
          v10[2] = (int)v22;
          *v10 = 8448;
          v10[3] = (int)&v22[1];
          sub_625E4(v22, v21, 1);
          sub_625E4(v23, v21, 3);
          goto LABEL_7;
        }
        if ( v6 > 4 )
        {
          if ( v6 == 0x80000 )
            goto LABEL_51;
          if ( v6 == 0x100000 )
          {
            sub_4C578(0xE001u);
            sub_4A3F4();
            if ( (*(_DWORD *)(v8 + 4) & 1) != 0 )
              goto LABEL_51;
          }
        }
        else if ( v6 == 1 )
        {
          v13 = sub_4C978(2);
          v10 = (int *)v13;
          v2[3] = v13;
          if ( !v13 )
            sub_4AC50("Empty sequence");
          *(_DWORD *)(v13 + 16) = v2;
        }
      }
    }
    else
    {
      v4 = 2084045861;
    }
LABEL_7:
    v2 = v10;
  }
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004CCC0) --------------------------------------------------------
void __fastcall sub_4CCC0(int a1)
{
  _DWORD *v1; // r4

  v1 = sub_4A710(a1);
  v1[2] = sub_4C978(57344);
  if ( (*(_DWORD *)(dword_7DB98 + 4) & 0x2000) != 0 )
    sub_4A3F4();
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004CCF8) --------------------------------------------------------
void sub_4CCF8()
{
  int v0; // r0
  int *v1; // r0
  _DWORD *v2; // r4
  unsigned int v3; // r3
  _DWORD *v4; // r5
  int v5; // r0
  int v6; // r3
  _DWORD *v7; // r5
  _DWORD *v8; // r6
  int v9; // r4
  _DWORD *v10; // r6
  _DWORD *v11; // r4
  _DWORD *v12; // r0
  _DWORD *v13; // r5
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  int v16; // r4
  int v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  int v20; // r3

  do
    v0 = sub_4C578(0x7C3BD425u);
  while ( (v0 & 0x8000) != 0 );
  if ( (v0 & 0x1000) != 0 )
  {
    while ( sub_4C578(0x7C3BF425u) != 0x2000 )
    {
      if ( (*(_DWORD *)(dword_7DB98 + 4) & 0x8000) == 0 )
      {
        sub_4A3F4();
        sub_4CCF8();
      }
    }
    return;
  }
  if ( (v0 & 0x7C38C425) != 0 )
  {
    sub_4A3F4();
    v1 = &elf_hash_bucket[17];
    goto LABEL_8;
  }
  v2 = (_DWORD *)dword_7DB98;
  v1 = *(int **)dword_7DB98;
  v3 = *(_DWORD *)dword_7DB98 & 0xFF00;
  if ( v3 == 2304 )
  {
    v19 = sub_4A710(512);
    v20 = *(v2 - 21);
    goto LABEL_36;
  }
  if ( v3 <= 0x900 )
  {
    if ( v3 == 1280 )
      goto LABEL_14;
    if ( v3 != 2048 )
    {
      if ( v3 != 1024 )
        goto LABEL_8;
LABEL_14:
      v4 = sub_4A710((int)v1);
      v5 = sub_4C978(57352);
      v6 = v2[1];
      v4[2] = v5;
      if ( (v6 & 8) != 0 )
      {
        *v4 |= *v2;
        v4[3] = sub_4C978(57344);
      }
      if ( (v2[1] & 0x2000) != 0 )
        goto LABEL_17;
      return;
    }
    v19 = sub_4A710(512);
    v20 = *(v2 - 22);
LABEL_36:
    v19[4] = v20;
    v1 = (int *)*v2;
    goto LABEL_8;
  }
  if ( v3 == 12544 )
  {
    v10 = sub_4A710(512);
    v11 = sub_4CFB0(0);
    v10[4] = v11[4];
    sub_4C578(0x20000u);
    v11[2] = sub_4C960();
    return;
  }
  if ( v3 <= 0x3100 )
  {
    if ( v3 != 12288 )
      goto LABEL_8;
    v7 = sub_4A710((int)&elf_hash_chain[74]);
    v7[2] = sub_4C960();
    sub_4CCF8();
    v8 = sub_4A710(512);
    v7[3] = *(_DWORD *)(*(v2 - 23) + 4);
    if ( sub_4C578(0x7C3FF425u) == 0x40000 )
    {
      sub_4CCF8();
      v8[4] = *(_DWORD *)(*(v2 - 23) + 4);
      return;
    }
LABEL_17:
    sub_4A3F4();
    return;
  }
  if ( v3 != 12800 )
  {
    if ( v3 == 13056 )
    {
      v9 = sub_4C960();
      sub_4CFB0(0)[2] = v9;
      return;
    }
LABEL_8:
    sub_4CCC0((int)v1);
    return;
  }
  sub_4C578(1u);
  v12 = (_DWORD *)sub_4C978(16386);
  v13 = v12;
  if ( (v2[1] & 2) != 0 )
  {
    if ( !v12 || (*v12 & 0xFF00) != 0x1B00 )
      sub_4AC50("Unexpected token");
    v14 = sub_4A710(198144);
    v14[2] = v13[2];
    v14[3] = v13[3];
    v15 = sub_4CFB0(0);
    *v15 = &stru_10DFC.st_value;
    v15[2] = v13[2];
  }
  else
  {
    sub_4A710((int)&elf_hash_bucket[17])[2] = v12;
    v16 = sub_4C978(0x4000);
    v17 = sub_4C978(2);
    v18 = sub_4CFB0(v17);
    v18[2] = v16;
    if ( !v16 )
      *v18 = 512;
  }
}
// 101BC: using guessed type int elf_hash_bucket[263];
// 105D8: using guessed type int elf_hash_chain[309];
// 10DFC: using guessed type Elf32_Sym stru_10DFC;
// 7DB98: using guessed type int dword_7DB98;

//----- (0004CFB0) --------------------------------------------------------
_DWORD *__fastcall sub_4CFB0(int a1)
{
  int v2; // r4
  __int64 v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r0
  int v6; // r3
  int v8; // r2
  int v9; // r3

  v2 = dword_7DB98;
  v3 = *(_QWORD *)(dword_7DB98 - 88);
  v4 = sub_4A710((int)&elf_hash_chain[74]);
  *(_DWORD *)(v2 - 84) = sub_4A4AC(512);
  *(_DWORD *)(v2 - 88) = sub_4A4AC(512);
  sub_4CCF8();
  v5 = sub_4A710((int)&elf_hash_bucket[17]);
  v6 = *(_DWORD *)(v2 - 84);
  v5[2] = a1;
  v5[4] = v4;
  *(_DWORD *)(v6 + 16) = v5;
  v8 = *(_DWORD *)(v2 - 88);
  v9 = *(_DWORD *)(*(_DWORD *)(v2 - 92) + 4);
  v4[3] = v9;
  *(_DWORD *)(v8 + 16) = v9;
  *(_QWORD *)(v2 - 88) = v3;
  return v4;
}
// 101BC: using guessed type int elf_hash_bucket[263];
// 105D8: using guessed type int elf_hash_chain[309];
// 4CCF8: using guessed type int sub_4CCF8(void);
// 7DB98: using guessed type int dword_7DB98;

//----- (0004D030) --------------------------------------------------------
int __fastcall sub_4D030(int a1)
{
  int v1; // r3
  int result; // r0
  int v3; // r4
  int v4; // r3
  const char *v5; // r1
  unsigned int *v6; // r0
  char *v7; // r5
  char *v8; // r0
  int v9; // r3
  _DWORD *v10; // r5
  int v11; // r0
  int v12; // r3

  v1 = dword_7DB98;
  *(_DWORD *)(dword_7DB98 - 36) = a1;
  *(_DWORD *)(v1 + 12) = 1;
  while ( 1 )
  {
    result = sub_4C578(0x7FF8D425u);
    if ( result == 0x2000000 )
      return result;
    if ( (result & 0xC000) == 0 )
    {
      v3 = dword_7DB98;
      *(_DWORD *)(dword_7DB98 - 92) = dword_7DB98 - 116;
      if ( (result & 0x800000) != 0 )
      {
        v4 = v3 - 128;
LABEL_8:
        *(_DWORD *)(v3 - 92) = v4;
        goto LABEL_9;
      }
      if ( (result & 0x1000000) != 0 )
      {
        v4 = v3 - 104;
        goto LABEL_8;
      }
      if ( (result & 0x400000) != 0 )
      {
        sub_4C578(0x10000000u);
        v5 = *(const char **)(v3 + 8);
        v6 = *(unsigned int **)(v3 - 64);
        ++*(_DWORD *)(v3 - 36);
        v7 = sub_4A98C(v6, v5);
        *((_DWORD *)v7 + 1) = 0;
        *(_DWORD *)v7 = 0;
        do
        {
          if ( (sub_4C578(0x4000002u) & 0x4000000) == 0 )
            break;
          v8 = sub_4A98C(*(unsigned int **)(v3 - 72), *(const char **)(v3 + 8));
          v9 = (*(_DWORD *)v7)++;
          *((_DWORD *)v8 + 5) = v9;
        }
        while ( (sub_4C578(0x102u) & 2) == 0 );
        *(_DWORD *)(v3 - 92) = v7 + 4;
        sub_4CCF8();
        sub_4A6AC(*(_DWORD **)(v3 - 72));
      }
      else if ( (result & 0x7C380425) != 0 )
      {
        sub_4A3F4();
        v10 = sub_4A710(3328);
        v11 = sub_4C978(33607680);
        v12 = *(_DWORD *)(v3 + 4);
        v10[2] = v11;
        if ( (v12 & 0x1000) != 0 )
        {
          sub_4A3F4();
          sub_4CCF8();
        }
        else
        {
          sub_4A710(1024);
        }
        v10[3] = *(_DWORD *)(v3 - 112);
      }
      else
      {
        sub_4A3F4();
LABEL_9:
        sub_4CCF8();
      }
    }
  }
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004D18C) --------------------------------------------------------
int __fastcall sub_4D18C(_DWORD *a1, _DWORD *a2)
{
  int v2; // r3

  v2 = a1[2] - a2[2];
  if ( !v2 )
    return *a1 - *a2;
  return v2;
}

//----- (0004D1AC) --------------------------------------------------------
int __fastcall sub_4D1AC(int result, __int64 a2)
{
  if ( *(_QWORD *)(result + 8) != a2 )
  {
    *(_QWORD *)(result + 8) = a2;
    return fseeko64(*(_DWORD *)result);
  }
  return result;
}
// 13E44: using guessed type int __fastcall fseeko64(_DWORD);

//----- (0004D1E4) --------------------------------------------------------
unsigned int __fastcall sub_4D1E4(int a1, int a2)
{
  int v3; // r4
  int v4; // r0
  int v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // kr04_4
  unsigned int v8; // r3
  bool v9; // cc
  int v10; // r0

  v3 = a2 | 0x200;
  while ( (v3 & 0x800) == 0 )
  {
    v4 = getc_unlocked(*(FILE **)a1);
    if ( v4 == -1 )
    {
      v5 = 1;
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 12);
      v7 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v7 + 1;
      v8 = (unsigned __int8)(v4 - 9);
      *(_DWORD *)(a1 + 12) = (__PAIR64__(v6, v7) + 1) >> 32;
      v9 = v8 > 0x17;
      if ( v8 != 23 )
        v9 = v8 > 4;
      v5 = !v9;
    }
    v3 |= v4 & 0xC00;
    if ( v4 == 10 )
      v3 |= 0x800u;
    if ( (dword_7DBC0 & 8) != 0 && (unsigned int)(v4 - 65) <= 0x19 )
      LOWORD(v4) = v4 + 32;
    if ( (v5 & ((unsigned int)dword_7DBC0 >> 13)) == 0 )
    {
      v10 = v4 & 0x1FF;
      if ( (dword_7DBC0 & 2) == 0 )
        return v10 | v3 & 0xFFFFFC00;
      if ( (v3 & 0x1000) == 0 )
      {
        if ( v5 )
          v10 = 4128;
        return v10 | v3 & 0xFFFFFC00;
      }
      if ( !v5 )
      {
        v3 &= ~0x1000u;
        return v10 | v3 & 0xFFFFFC00;
      }
    }
  }
  return v3;
}
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0004D2B8) --------------------------------------------------------
_DWORD *__fastcall sub_4D2B8(int a1, int *a2, _DWORD *a3)
{
  void **v4; // r7
  int v5; // r5
  int *v6; // r4
  _QWORD *v7; // r0
  _QWORD *v8; // r6
  unsigned int v9; // r6
  int v10; // r8
  int i; // r10
  unsigned int v12; // r0
  void *v13; // r0
  _QWORD *v15; // r3
  __int64 v16; // r0
  char *v17; // r0
  int v18; // r2
  int v19; // r1
  char *v20; // r0
  int v21; // r2
  int v22; // r3
  _DWORD *v23; // r7
  int v24; // r1
  _DWORD *v25; // r6
  int v26; // r0
  int v27; // r5
  int v28; // r2
  int v29; // r3
  int v30; // r4
  int v31; // r9
  int v32; // r1
  int v33; // r0
  signed int v34; // r1
  signed int j; // r3
  int v36; // r2
  int v37; // r8
  int v38; // r0
  int v39; // r1
  int v40; // r3
  bool v41; // cc
  _BOOL4 v42; // r12
  int v43; // r3
  int v44; // r8
  size_t v45; // r6
  _DWORD *v46; // r0
  int m; // r3
  int n; // r3
  size_t v49; // r8
  _DWORD *v50; // r0
  int v51; // r2
  _DWORD *v52; // r7
  int v53; // r3
  int v54; // r5
  int v55; // r1
  unsigned int v56; // r0
  int v57; // r3
  _DWORD *v58; // r6
  int *v59; // r10
  int v60; // r9
  int ii; // r3
  _DWORD *v62; // r3
  int v63; // r5
  int v65; // r12
  int v66; // r0
  int v67; // r12
  unsigned int v68; // r10
  unsigned int v69; // r9
  _DWORD *k; // r2
  int v71; // r9
  int v72; // r12
  int v73; // r0
  int v74; // r3
  int v75; // r8
  int v76; // r0
  int v77; // r12
  int v78; // r3
  int v79; // r5
  int v80; // r1
  int v81; // r3
  _DWORD *v82; // r0
  int *v83; // r1
  _BOOL4 v84; // r3
  int v85; // r10
  int v86; // r6
  unsigned int v87; // r9
  unsigned int v88; // r0
  _DWORD *v89; // [sp+Ch] [bp-48h]
  int v90; // [sp+Ch] [bp-48h]
  signed int v91; // [sp+10h] [bp-44h]
  int v92; // [sp+18h] [bp-3Ch]
  int v93; // [sp+18h] [bp-3Ch]
  _QWORD *v94; // [sp+1Ch] [bp-38h]
  int v95; // [sp+1Ch] [bp-38h]
  int v97; // [sp+24h] [bp-30h]
  _DWORD *v98; // [sp+28h] [bp-2Ch]
  int v99; // [sp+2Ch] [bp-28h]
  unsigned int v100; // [sp+30h] [bp-24h]
  _DWORD *ptr; // [sp+3Ch] [bp-18h]
  unsigned int v103; // [sp+40h] [bp-14h]
  char *v104; // [sp+44h] [bp-10h]
  int *v105; // [sp+48h] [bp-Ch]
  int v106; // [sp+4Ch] [bp-8h]
  signed int v107; // [sp+50h] [bp-4h]
  int v108; // [sp+54h] [bp+0h] BYREF
  _DWORD *v109; // [sp+58h] [bp+4h]
  _DWORD *v110; // [sp+5Ch] [bp+8h]
  _DWORD v111[3]; // [sp+60h] [bp+Ch]

  v4 = (void **)&v108;
  v5 = a1;
  v6 = a2 - 1;
  v89 = a3 - 1;
  v92 = a1 + 32;
  do
  {
    v7 = sub_1748C(0x670u);
    *(_QWORD *)(v5 + 8) = 0;
    v8 = v7;
    v4[1] = v7;
    ++v4;
    fseeko64(*(_DWORD *)v5);
    *v8 = 0;
    v9 = 100;
    v6[1] = 0;
    ++v6;
    do
    {
      v10 = 0;
      for ( i = 0; ; i = (i << 7) - (i - (v12 & 0x1FF)) )
      {
        v12 = sub_4D1E4(v5, v10);
        v10 = v12;
        if ( (v12 & 0x200) != 0 )
          break;
      }
      v13 = *v4;
      if ( (*v6)++ == v9 )
      {
        v9 = (3 * v9) >> 1;
        *v4 = sub_174B4(v13, 16 * (v9 + 3));
      }
      v15 = *v4;
      v16 = *(_QWORD *)(v5 + 8);
      *((_DWORD *)*v4 + 4 * *v6 + 2) = i & 0x7FFFFFFF;
      v15[2 * *v6] = v16;
    }
    while ( (v10 & 0x400) == 0 );
    v94 = v15;
    if ( ++v15[2 * *v6] - v15[2 * *v6 - 2] == 1 )
      --*v6;
    v17 = (char *)sub_1748C(8 * (*v6 + 2));
    v18 = 0;
    v19 = *v6;
    v89[1] = v17;
    v20 = v17 - 8;
    ++v89;
    while ( v19 >= v18 )
    {
      v65 = 2 * v18++;
      *((_QWORD *)v20 + 1) = v94[v65];
      v20 += 8;
    }
    v5 += 16;
  }
  while ( v5 != v92 );
  v21 = *a2;
  v22 = 6;
  v23 = v109;
  v24 = 0;
  v25 = v110;
  while ( 1 )
  {
    v90 = v24;
    if ( v21 <= v24 )
      break;
    if ( a2[1] <= v24 )
      break;
    v66 = v109[v22];
    v22 += 4;
    if ( v66 != v110[v22 - 4] )
      break;
    ++v24;
  }
  v26 = 16 * v21;
  v27 = 0;
  v28 = v21 - v24;
  while ( v28 > v27 )
  {
    v29 = a2[1];
    if ( v29 - v24 <= v27 || *(_DWORD *)((char *)v109 + v26 - 16 * v27 + 8) != v110[4 * (v29 - v27) + 2] )
      break;
    ++v27;
  }
  v30 = 0;
  v31 = 4 * v24;
  while ( 1 )
  {
    v32 = a2[v30];
    v33 = (int)&(&v109)[v30][v31];
    v111[v30] = v33;
    v34 = v32 - v90 - v27;
    *(&v107 + v30) = v34;
    for ( j = 0; v34 >= j; ++j )
      *(_DWORD *)(v33 + 16 * j) = j;
    qsort((void *)(v33 + 16), v34, 0x10u, (__compar_fn_t)sub_4D18C);
    if ( v30 == 1 )
      break;
    v30 = 1;
  }
  v36 = 1;
  v37 = v111[0];
  v38 = v111[1];
  v39 = v108;
  v91 = v107;
  v40 = 1;
  while ( 1 )
  {
    v41 = v91 < v40;
    if ( v91 >= v40 )
      v41 = v39 < v36;
    v42 = !v41;
    if ( v41 )
      break;
    v67 = v37 + 16 * v40;
    v68 = *(_DWORD *)(v67 + 8);
    v69 = *(_DWORD *)(v38 + 16 * v36 + 8);
    if ( v68 >= v69 )
    {
      if ( v68 == v69 )
      {
        ++v40;
        *(_DWORD *)(v67 + 8) = v36;
      }
      else
      {
        ++v36;
      }
    }
    else
    {
      ++v40;
      *(_DWORD *)(v67 + 8) = 0;
    }
  }
  while ( v91 >= v40 )
  {
    ++v40;
    *(_DWORD *)(v37 + 16 * v40 - 8) = v42;
  }
  *(_DWORD *)(v38 + 16 * v39 + 24) = v42;
  v43 = 0;
  while ( v39 >= ++v43 )
  {
    v25[v43] = -*(_DWORD *)(v38 + 16 * v43);
    for ( k = (_DWORD *)(v38 + 16 * v43 - 16); ; v25[++v43] = k[4] )
    {
      v71 = k[10];
      v72 = k[6];
      k += 4;
      if ( v71 != v72 )
        break;
    }
  }
  v25[v43] = -1;
  v44 = v37 + 16;
  v98 = sub_174B4(v25, 4 * (v39 + 2));
  v45 = 4 * (v91 + 1);
  v46 = sub_1748C(v45);
  for ( m = 1; ; ++m )
  {
    v44 += 16;
    if ( v91 < m )
      break;
    v46[*(_DWORD *)(v44 - 16)] = *(_DWORD *)(v44 - 8);
  }
  for ( n = 1; v91 >= n; ++n )
    v23[n] = v46[n];
  v49 = v45 + 4;
  free(v46);
  ptr = sub_174B4(v23, v45 + 4);
  v50 = sub_1748C(4 * (*a2 + 2));
  v51 = *a2;
  v52 = v50;
  v53 = 0;
  v54 = *a2 - v27;
  v55 = a2[1] - *a2;
  while ( v51 >= v53 )
  {
    if ( v90 < v53 )
    {
      if ( v54 >= v53 )
        v73 = 0;
      else
        v73 = v55 + v53;
    }
    else
    {
      v73 = v53;
    }
    v52[v53++] = v73;
  }
  v56 = sub_5A898(v91, v91 >> 31);
  if ( (dword_7DBC0 & 4) != 0 )
  {
    v57 = -1;
  }
  else if ( v56 < 0x100 )
  {
    v57 = 256;
  }
  else
  {
    v57 = v56;
  }
  v103 = v57;
  v58 = sub_174DC(0x4B0u);
  v59 = (int *)sub_174DC(v49);
  v60 = 1;
  v93 = 0;
  v95 = 1;
  v99 = 100;
  while ( 1 )
  {
    v105 = &v59[v93];
    if ( v91 < v95 )
      break;
    v74 = ptr[v95];
    if ( !v74 )
      goto LABEL_99;
    v75 = -v98[v74];
    v97 = *v59;
    v104 = (char *)&v98[v74];
    v100 = 0;
    v76 = 0;
    while ( 1 )
    {
      if ( v58[3 * v97 + 1] >= v75 )
        goto LABEL_96;
      if ( v75 > v58[3 * *v105 + 1] )
      {
        v79 = v93 + 1;
      }
      else
      {
        v77 = v93 + 1;
        v78 = 0;
        while ( 1 )
        {
          v79 = (v77 + v78) >> 1;
          if ( v79 <= v78 )
            break;
          v80 = v58[3 * v59[v79] + 1];
          if ( v75 < v80 )
          {
            v77 = (v77 + v78) >> 1;
          }
          else
          {
            v78 = (v77 + v78) >> 1;
            if ( v75 <= v80 )
              goto LABEL_88;
          }
        }
        ++v79;
      }
LABEL_88:
      if ( v76 + 1 != v79 )
        v97 = v59[v79 - 1];
      v81 = v59[v79];
      if ( v93 >= v79 && v75 >= v58[3 * v81 + 1] )
        goto LABEL_96;
      if ( v60 == v99 )
      {
        v106 = v59[v79];
        v99 = 11 * v60 / 10;
        v82 = sub_174B4(v58, 12 * v99);
        v81 = v106;
        v58 = v82;
      }
      v83 = &v58[3 * v60];
      *v83 = v95;
      v83[1] = v75;
      v83[2] = v97;
      v59[v79] = v60;
      if ( v93 < v79 )
        break;
      ++v60;
      v97 = v81;
      ++v100;
      v76 = v79;
LABEL_96:
      v75 = *((_DWORD *)v104 + 1);
      v104 += 4;
      v84 = v100 < v103;
      if ( v75 <= 0 )
        v84 = 0;
      if ( !v84 )
        goto LABEL_99;
    }
    ++v60;
    ++v93;
LABEL_99:
    ++v95;
  }
  for ( ii = *v105; ; ii = v62[2] )
  {
    v62 = &v58[3 * ii];
    v63 = v62[1];
    if ( !v63 )
      break;
    v52[v90 + *v62] = v90 + v63;
  }
  free(v59);
  free(v58);
  v52[*a2 + 1] = a2[1] + 1;
  free(ptr);
  free(v98);
  while ( *a2 >= v30 )
  {
    if ( v52[v30] )
    {
      sub_4D1AC(a1, *(_QWORD *)(*a3 + 8 * v30 - 8));
      sub_4D1AC(a1 + 16, *(_QWORD *)(a3[1] + 8 * v52[v30] - 8));
      v85 = v52[v30] - v30;
      while ( *a2 >= v30 && v52[v30] == v85 + v30 )
      {
        v86 = 0;
        v87 = 0;
        do
        {
          v87 = sub_4D1E4(a1, v87);
          v88 = sub_4D1E4(a1 + 16, v86);
          v86 = v88;
          if ( ((v87 ^ v88) & 0x200) != 0
            || (v87 & 0x200) == 0 && (((unsigned __int16)v87 ^ (unsigned __int16)v88) & 0x1FF) != 0 )
          {
            v52[v30] = 0;
          }
        }
        while ( (v87 & v88 & 0x200) == 0 );
        ++v30;
      }
    }
    ++v30;
  }
  return v52;
}
// 13E44: using guessed type int __fastcall fseeko64(_DWORD);
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0004DB30) --------------------------------------------------------
int __fastcall sub_4DB30(int result, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  int v6; // r5
  int v7; // r8
  __int64 v8; // r6
  int v9; // r10
  int v10; // r0
  __int64 v11; // [sp+0h] [bp-14h]

  v5 = a2 + 8 * (a3 + 0x1FFFFFFF);
  v6 = result;
  v7 = a3;
LABEL_2:
  if ( v7 <= a4 )
  {
    sub_4D1AC(v6, *(_QWORD *)v5);
    putchar_unlocked(a5);
    if ( (dword_7DBC0 & 0x800) != 0 )
      putchar_unlocked(9);
    v8 = 0;
    v9 = 0;
    while ( 1 )
    {
      result = *(_DWORD *)(v5 + 4);
      LODWORD(v11) = *(_DWORD *)(v5 + 8) - *(_DWORD *)v5;
      HIDWORD(v11) = v11;
      if ( v8 >= v11 )
      {
        ++v7;
        v5 += 8;
        goto LABEL_2;
      }
      v10 = getc_unlocked(*(FILE **)v6);
      if ( v10 == -1 )
        return puts("\n\\ No newline at end of file");
      ++*(_QWORD *)(v6 + 8);
      if ( v10 == 9 && (dword_7DBC0 & 0x400) != 0 )
      {
        do
        {
          ++v9;
          putchar_unlocked(32);
        }
        while ( (v9 & 7) != 0 );
      }
      else
      {
        putchar_unlocked(v10);
        ++v9;
      }
      ++v8;
    }
  }
  return result;
}
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0004DC54) --------------------------------------------------------
int __fastcall sub_4DC54(int a1, char **a2)
{
  _DWORD *v3; // r6
  int v4; // r9
  int v5; // r4
  _DWORD *v6; // r5
  char **v7; // r7
  _DWORD **v8; // r6
  int v9; // r9
  const char *v10; // r0
  const char *v11; // t1
  int v12; // r2
  int v13; // r1
  int v14; // r2
  int v15; // r2
  int v16; // r4
  int v17; // r3
  int v18; // r3
  char *v19; // r7
  char *v20; // r0
  char *v21; // r0
  int v22; // r11
  int v23; // r0
  int v24; // r4
  unsigned int v25; // r3
  const char *v27; // r3
  char *v28; // r2
  int v29; // r0
  int v30; // r1
  _DWORD *v31; // r12
  __int16 v32; // r1
  int v33; // r0
  char v34; // r3
  int v35; // r10
  __int64 v36; // r0
  int v37; // r4
  FILE *v38; // r8
  size_t v39; // r0
  FILE *v40; // r7
  signed int v41; // r6
  signed int v42; // r0
  struct termios *v43; // r3
  int v44; // r12
  int c_iflag_low; // t1
  int v46; // lr
  unsigned int v47; // r10
  char *v48; // r8
  int v49; // r9
  int v50; // r6
  int v51; // r3
  int v52; // r12
  int *v53; // r1
  int v54; // r2
  int v55; // r4
  int *v56; // r12
  int i; // r1
  int v58; // r7
  int v59; // t1
  int v60; // r7
  bool v61; // cc
  int v62; // r1
  char *v63; // r12
  int j; // r3
  int v65; // r2
  char *v66; // r0
  char *v67; // r2
  int *v68; // r12
  int v69; // r1
  bool v70; // zf
  int v71; // lr
  int v72; // r0
  int v73; // r1
  int v74; // lr
  int v75; // r1
  int v76; // r1
  char *v77; // r6
  int v78; // r9
  int v79; // r10
  int v80; // r4
  int v81; // r7
  int v82; // r4
  int v83; // r1
  int v84; // r1
  int v85; // r2
  int v86; // r1
  bool v87; // cc
  int *v88; // r4
  int k; // r2
  int v90; // r3
  __int64 v91; // r2
  int v92; // [sp+0h] [bp-8Ch]
  int v93; // [sp+8h] [bp-84h]
  int v94; // [sp+Ch] [bp-80h]
  int v95; // [sp+Ch] [bp-80h]
  _BOOL4 v96; // [sp+10h] [bp-7Ch]
  _DWORD *v97; // [sp+14h] [bp-78h]
  unsigned int v98; // [sp+18h] [bp-74h]
  int v99; // [sp+1Ch] [bp-70h]
  __int64 v100; // [sp+28h] [bp-64h]
  int v101; // [sp+30h] [bp-5Ch] BYREF
  _DWORD *v102; // [sp+34h] [bp-58h] BYREF
  int v103; // [sp+38h] [bp-54h]
  int v104; // [sp+3Ch] [bp-50h]
  FILE *stream; // [sp+40h] [bp-4Ch]
  FILE *v106; // [sp+44h] [bp-48h]
  int v107[2]; // [sp+48h] [bp-44h] BYREF
  void *ptr; // [sp+50h] [bp-3Ch] BYREF
  void *v109; // [sp+54h] [bp-38h]
  int v110; // [sp+58h] [bp-34h] BYREF
  int v111; // [sp+5Ch] [bp-30h]
  int v112; // [sp+60h] [bp-2Ch]
  int v113; // [sp+64h] [bp-28h]
  char v114[16]; // [sp+68h] [bp-24h] BYREF
  FILE *v115; // [sp+78h] [bp-14h] BYREF

  v101 = 0;
  v102 = 0;
  v3 = sub_174DC(0xE8u);
  dword_7DB98 = (int)v3;
  v3[1] = 3;
  sub_593CC(a2, "^abdiL:*NqrsS:tTU:+wupBE", &v102, &v101, v3 + 1);
  v4 = optind;
  while ( 1 )
  {
    v5 = (int)v102;
    if ( !v102 )
      break;
    v16 = v3[3];
    v3[(v16 != 0) + 3] = sub_5D2FC(&v102);
  }
  v6 = (_DWORD *)dword_7DB98;
  v7 = &a2[v4];
  v8 = &v102;
  v9 = 24;
  byte_7D5F8 = 2;
  do
  {
    v11 = *v7++;
    v10 = v11;
    v12 = *(unsigned __int8 *)v11;
    v8[1] = v11;
    ++v8;
    if ( v12 == 45 && !v10[1] )
    {
      ++v5;
      sub_62E08();
      goto LABEL_7;
    }
    if ( (dword_7DBC0 & 0x20) != 0 )
    {
      if ( !sub_62DFC() )
        goto LABEL_7;
      v10 = "/dev/null";
    }
    sub_17A0C(v10);
LABEL_7:
    v9 += 104;
  }
  while ( v9 != 232 );
  v14 = v6[10];
  byte_7D5F8 = 1;
  v15 = v14 & 0xF000;
  if ( v5 && (v15 == 0x4000 || (v6[36] & 0xF000) == 0x4000) )
    sub_16DBC("can't compare stdin to a directory");
  v17 = v6[36] & 0xF000;
  if ( v15 == 0x4000 )
  {
    if ( v17 == 0x4000 )
      sub_16DBC("no support for directory comparison");
    v96 = 0;
LABEL_22:
    v19 = (char *)*(&v103 + (v17 != 0x4000));
    v20 = strrchr(v19, 47);
    if ( v20 )
      v19 = v20 + 1;
    v21 = sub_16998((const char *)*(&v103 + v96), v19);
    *(&v103 + v96) = (int)v21;
    sub_17A0C(v21);
    v18 = 1;
  }
  else
  {
    v96 = v17 == 0x4000;
    if ( v17 == 0x4000 )
      goto LABEL_22;
    v18 = 0;
  }
  v99 = v18;
  if ( v5 > 1 )
    goto LABEL_147;
  v22 = 0;
  stream = (FILE *)stdin;
  v106 = (FILE *)stdin;
  while ( 1 )
  {
    v23 = *(&v103 + v22);
    if ( *(_BYTE *)v23 != 45 || (v24 = *(unsigned __int8 *)(v23 + 1), *(_BYTE *)(v23 + 1)) )
    {
      if ( (dword_7DBC0 & 0x20) != 0 )
      {
        v24 = open64(v23, 0);
        if ( v24 == -1 )
          v24 = sub_175D8("/dev/null", 0);
      }
      else
      {
        v24 = sub_1760C((const char *)v23, 0);
        if ( v24 == -1 )
          goto LABEL_31;
      }
    }
    v92 = 0;
    if ( lseek64(v24, v13) == -1 && *(_DWORD *)dword_7DB94 == 29 )
    {
      v27 = "/tmp/difXXXXXX";
      v28 = v114;
      do
      {
        v29 = *(_DWORD *)v27;
        v27 += 8;
        v30 = *((_DWORD *)v27 - 1);
        *(_DWORD *)v28 = v29;
        *((_DWORD *)v28 + 1) = v30;
        v31 = v28 + 8;
        v28 += 8;
      }
      while ( v27 != "XXXXXX" );
      v32 = *((_WORD *)v27 + 2);
      v33 = *(_DWORD *)v27;
      v34 = v27[6];
      *((_WORD *)v31 + 2) = v32;
      *v31 = v33;
      *((_BYTE *)v31 + 6) = v34;
      v35 = sub_17778(v114);
      unlink(v114);
      v36 = sub_17FAC(v24, v35);
      if ( v36 < 0 )
        sub_16E08();
      if ( v24 )
        close(v24);
      v24 = v35;
      sub_1771C(v35, SHIDWORD(v36), 0, 0);
    }
    *(&stream + v22) = fdopen(v24, "r");
    if ( v22 == 1 )
      break;
    v22 = 1;
  }
  v37 = 0;
  v93 = 0;
LABEL_55:
  v38 = stream;
  v39 = fread(&buf, 1u, 0x200u, stream);
  v40 = v106;
  v41 = v39;
  v42 = fread(&dword_7D990, 1u, 0x200u, v106);
  if ( v41 != v42 )
  {
    if ( v42 >= v41 )
      v42 = v41;
    v93 = 1;
  }
  if ( v42 )
  {
    v43 = &buf;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v42 <= (char *)v43 - (char *)&buf )
          goto LABEL_55;
        c_iflag_low = LOBYTE(v43->c_iflag);
        v43 = (struct termios *)((char *)v43 + 1);
        v44 = c_iflag_low;
        if ( c_iflag_low )
          break;
        v37 = 1;
LABEL_65:
        v46 = v93;
        if ( v44 != v43[8].c_cc[14] )
          v46 = 1;
        v93 = v46;
      }
      if ( v43[8].c_cc[14] )
        goto LABEL_65;
      v37 = 1;
      v93 = 1;
    }
  }
  if ( !v93 )
    goto LABEL_31;
  if ( v37 && (dword_7DBC0 & 1) == 0 )
  {
    v22 = 2;
    goto LABEL_145;
  }
  v47 = 0;
  *(_DWORD *)v114 = v38;
  v48 = 0;
  v115 = v40;
  v97 = sub_4D2B8((int)v114, v107, &ptr);
  v94 = 1;
  do
  {
    v49 = 0;
    v50 = -1;
    while ( 1 )
    {
      v51 = v94;
      v52 = 0;
      v110 = v94;
      v53 = &v97[v94];
      while ( 1 )
      {
        v54 = *(v53 - 1) + 1;
        if ( v107[0] < v51 )
          break;
        v71 = *v53++;
        if ( v71 != v54 )
          break;
        ++v51;
        v52 = v93;
      }
      v55 = v51 - 1;
      if ( v52 )
        v110 = v51;
      v112 = v54;
      v111 = v51 - 1;
      v56 = &v97[v51];
      for ( i = 0; ; i = v93 )
      {
        v59 = *v56++;
        v58 = v59;
        if ( v107[0] <= v55 || v58 )
          break;
        ++v55;
      }
      v60 = v58 - 1;
      if ( i )
        v111 = v55;
      v61 = v60 < v54;
      if ( v60 < v54 )
        v61 = v55 < v51;
      v113 = v60;
      if ( !v61 )
      {
        v62 = 2 * v6[1] + 1;
        if ( v50 != -1 )
        {
          v63 = &v48[16 * v50];
          if ( v62 + *((_DWORD *)v63 + 1) < v51 && v62 + *((_DWORD *)v63 + 3) < v54 )
            goto LABEL_106;
        }
        for ( j = 0; ; j = 1 )
        {
          v95 = *(&v110 + 2 * j);
          v65 = 8 * v95;
          while ( v95 <= *(&v110 + 2 * j + 1) )
          {
            v72 = (int)*(&ptr + j);
            v73 = *(_DWORD *)(v72 + v65);
            v74 = v72 + v65;
            v65 += 8;
            LODWORD(v100) = v73;
            HIDWORD(v100) = *(_DWORD *)(v74 + 4);
            if ( v100 - *(_QWORD *)(v74 - 8) != 1 )
              v49 |= 1u;
            ++v95;
          }
          if ( j == 1 )
            break;
        }
        v66 = sub_62544(v48, 0x1006u, ++v50);
        v67 = &v66[16 * v50];
        v48 = v66;
        v68 = &v110;
        do
        {
          v67 += 8;
          v69 = v68[1];
          v70 = v68 + 2 == (int *)v114;
          *((_DWORD *)v67 - 2) = *v68;
          *((_DWORD *)v67 - 1) = v69;
          v68 += 2;
        }
        while ( !v70 );
      }
      v94 = v55 + 1;
      if ( v55 + 1 > v107[0] )
        break;
      v97[v55] = v60;
    }
    if ( v50 == -1 )
      continue;
LABEL_106:
    v98 = v49 | ((dword_7DBC0 ^ 0x10000u) >> 16) & 1;
    if ( v98 )
    {
      if ( (dword_7DBC0 & 0x40) == 0 )
      {
        if ( !v47 )
        {
          v75 = v6[3];
          if ( !v75 )
            v75 = v103;
          printf("--- %s\n", v75);
          v76 = v6[4];
          if ( !v76 )
            v76 = v104;
          printf("+++ %s\n", v76);
        }
        v77 = &v48[16 * v50];
        v78 = 0;
        v79 = 4;
        printf("@@");
        while ( 1 )
        {
          v80 = v6[1];
          v81 = *(_DWORD *)&v48[8 * v78] - v80;
          v82 = v80 + *(_DWORD *)&v77[v79];
          v83 = v107[v78];
          if ( v81 < 1 )
            v81 = 1;
          *(&v110 + 2 * v78) = v81;
          if ( v82 >= v83 )
            v82 = v83;
          if ( v78 )
            v84 = 43;
          else
            v84 = 45;
          *(int *)((char *)&v110 + v79) = v82;
          if ( v81 >= v82 )
            v85 = v82;
          else
            v85 = v81;
          printf(" %c%d", v84, v85, &v110, v92);
          v87 = v81 < v82;
          if ( v81 != v82 )
          {
            if ( v81 >= v82 )
              v86 = 0;
            else
              v82 -= v81;
            if ( v87 )
              v86 = v82 + 1;
            printf(",%d", v86);
          }
          v79 += 8;
          if ( v78 == 1 )
            break;
          v78 = 1;
        }
        v88 = (int *)v48;
        puts(" @@");
        for ( k = v110; ; k = *(v88 - 3) + 1 )
        {
          if ( v77 < (char *)v88 )
            v90 = v111;
          else
            v90 = *v88;
          if ( v77 >= (char *)v88 )
            --v90;
          sub_4DB30((int)v114, (int)ptr, k, v90, 32);
          if ( v77 < (char *)v88 )
            break;
          v91 = *(_QWORD *)v88;
          v88 += 4;
          sub_4DB30((int)v114, (int)ptr, v91, SHIDWORD(v91), 45);
          sub_4DB30((int)&v115, (int)v109, *(v88 - 2), *(v88 - 1), 43);
        }
      }
      v47 = v98;
    }
  }
  while ( v107[0] >= v94 );
  free(v48);
  free(ptr);
  free(v109);
  free(v97);
  if ( v47 )
LABEL_145:
    *v6 |= 1u;
  else
LABEL_31:
    v22 = 0;
  sub_5888C(stream);
  sub_5888C(v106);
  if ( (unsigned int)(v22 - 1) > 1 )
  {
LABEL_147:
    if ( (dword_7DBC0 & 0x100) != 0 )
      printf("Files %s and %s are identical\n", v103, v104);
  }
  else
  {
    v25 = ((unsigned int)dword_7DBC0 >> 6) & 1;
    if ( v22 == 2 )
      v25 = 1;
    if ( v25 )
      printf("Files %s and %s differ\n", v103, v104);
  }
  if ( v99 )
    free((void *)*(&v103 + v96));
  return *v6;
}
// 4DF7C: variable 'v13' is possibly undefined
// 4E048: variable 'v36' is possibly undefined
// 4E424: variable 'v92' is possibly undefined
// 4E440: variable 'v86' is possibly undefined
// 13928: using guessed type __int64 __fastcall lseek64(_DWORD, _DWORD);
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7D5F8: using guessed type char byte_7D5F8;
// 7D604: using guessed type int optind;
// 7D610: using guessed type int stdin;
// 7D990: using guessed type int dword_7D990;
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0004E5A0) --------------------------------------------------------
_DWORD *__fastcall sub_4E5A0(int *a1, int a2)
{
  _DWORD *result; // r0
  _DWORD *v5; // r2
  int v6; // r3

  result = sub_1748C(0xCu);
  v6 = *a1;
  result[2] = a2;
  if ( v6 )
  {
    v5 = *(_DWORD **)(v6 + 4);
    *result = v6;
  }
  else
  {
    result[1] = result;
  }
  if ( v6 )
    result[1] = v5;
  else
    *result = result;
  if ( v6 )
    *v5 = result;
  else
    *a1 = (int)result;
  if ( v6 )
    *(_DWORD *)(v6 + 4) = result;
  return result;
}
// 4E5CC: variable 'v5' is possibly undefined

//----- (0004E5E4) --------------------------------------------------------
void __fastcall sub_4E5E4(void **a1)
{
  unsigned __int8 *v2; // r2
  int v3; // r3
  int v4; // r0

  v2 = (unsigned __int8 *)a1[2];
  v3 = *(_DWORD *)(dword_7DB98 + 36);
  if ( v3 > 1 && v3 != *v2 )
  {
    if ( v3 == 2 )
      v4 = 2;
    else
      v4 = *(_DWORD *)(dword_7DB98 + 48);
    if ( v3 > 3 )
      ++v2;
    dprintf(v4, "%s\n", v2);
  }
  free(a1[2]);
  free(a1);
}
// 13558: using guessed type int __fastcall dprintf(_DWORD, _DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (0004E648) --------------------------------------------------------
void sub_4E648()
{
  int v0; // r4
  __int64 v1; // r0
  const char *v2; // r0
  char *v3; // r5

  v0 = dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 + 52) )
  {
    v1 = *(_QWORD *)(dword_7DB98 + 44);
    if ( (_DWORD)v1 != -1 )
    {
      sub_17FAC(v1, SHIDWORD(v1));
      sub_17700(*(_DWORD *)(v0 + 44));
    }
    sub_17700(*(_DWORD *)(v0 + 48));
    v2 = *(const char **)(v0 + 52);
    if ( *v2 )
    {
      v3 = sub_174F8(v2);
      v3[strlen(v3) - 6] = 0;
      rename(*(const char **)(v0 + 52), v3);
      free(v3);
      free(*(void **)(v0 + 52));
    }
    *(_DWORD *)(v0 + 52) = 0;
  }
  *(_DWORD *)(v0 + 44) = -1;
  *(_DWORD *)(v0 + 48) = -1;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0004E6E0) --------------------------------------------------------
void __fastcall sub_4E6E0(void **a1)
{
  void **v2; // r5

  while ( a1 )
  {
    v2 = (void **)*a1;
    sub_4E5E4(a1);
    if ( a1 == v2 )
      break;
    a1 = v2;
  }
}

//----- (0004E70C) --------------------------------------------------------
void sub_4E70C()
{
  int v0; // r4
  int v1; // r0
  const char *v2; // r0

  v0 = dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 + 8) )
  {
    dprintf(
      2,
      "Hunk %d FAILED %ld/%ld.\n",
      *(_DWORD *)(dword_7DB98 + 40),
      *(_DWORD *)(dword_7DB98 + 12),
      *(_DWORD *)(dword_7DB98 + 20));
    v1 = *(_DWORD *)(v0 + 8);
    *(_DWORD *)(v0 + 56) = 1;
    *(_DWORD *)(v0 + 36) = 2;
    **(_DWORD **)(v1 + 4) = 0;
    sub_4E6E0((void **)v1);
    *(_DWORD *)(v0 + 8) = 0;
    close(*(_DWORD *)(v0 + 44));
    close(*(_DWORD *)(v0 + 48));
    v2 = *(const char **)(v0 + 52);
    if ( *v2 )
    {
      unlink(v2);
      free(*(void **)(v0 + 52));
    }
    *(_DWORD *)(v0 + 52) = 0;
    *(_DWORD *)(v0 + 36) = 0;
  }
}
// 13558: using guessed type int dprintf(_DWORD, const char *, ...);
// 7DB98: using guessed type int dword_7DB98;

//----- (0004E7B0) --------------------------------------------------------
int __fastcall sub_4E7B0(int a1, char **a2)
{
  int v2; // r7
  int v3; // r9
  __int16 v5; // r0
  int v6; // r1
  int v7; // r8
  int v8; // r0
  int v9; // r6
  int v10; // r3
  int v11; // r0
  char **p_s1; // r3
  char *v13; // r2
  int v14; // r6
  char *v15; // r0
  char *v16; // r5
  _DWORD *v17; // r4
  int v18; // r3
  bool v19; // zf
  int v20; // r3
  bool v21; // zf
  int v22; // r3
  int *v23; // r5
  int v24; // r7
  _DWORD *v25; // r2
  _BYTE *v26; // r1
  _BOOL4 v27; // r3
  int v28; // r6
  _BOOL4 v29; // r6
  int v30; // r9
  const char *v31; // r2
  int v32; // r3
  int v33; // r11
  const char *v34; // r1
  _BOOL4 v35; // r3
  void **v36; // r0
  int v37; // r0
  int v38; // r0
  _DWORD *v39; // r3
  int v40; // r0
  int v41; // r2
  _DWORD *v42; // r3
  _DWORD *v43; // r1
  int v44; // r2
  void **v45; // r0
  void **v46; // r4
  const char *i; // r10
  int v48; // r2
  _BOOL4 v49; // r11
  const char *v50; // r0
  bool v51; // cc
  char *v52; // r11
  int v53; // r10
  int v54; // r5
  int v55; // r3
  char *v56; // r2
  char *v57; // r5
  int v58; // r0
  _BOOL4 v59; // r0
  int v60; // r10
  char *v61; // r0
  char *v62; // r0
  __int16 v64; // [sp+8h] [bp-9Ch]
  char **v65; // [sp+Ch] [bp-98h]
  _BOOL4 v66; // [sp+10h] [bp-94h]
  void **v67; // [sp+14h] [bp-90h]
  const char *v68; // [sp+18h] [bp-8Ch]
  _DWORD *v69; // [sp+18h] [bp-8Ch]
  int v70; // [sp+18h] [bp-8Ch]
  int v71; // [sp+1Ch] [bp-88h]
  const char *v72; // [sp+1Ch] [bp-88h]
  char *v73; // [sp+24h] [bp-80h] BYREF
  char *s1; // [sp+28h] [bp-7Ch] BYREF
  const char *v75; // [sp+2Ch] [bp-78h] BYREF
  int v76; // [sp+30h] [bp-74h] BYREF
  char *v77; // [sp+34h] [bp-70h] BYREF
  int v78[26]; // [sp+38h] [bp-6Ch] BYREF
  char v79; // [sp+A0h] [bp-4h] BYREF

  v73 = 0;
  s1 = 0;
  dword_7DB98 = (int)sub_174DC(0x3Cu);
  v5 = sub_593F8(a2, "Rup:i:NEfg", "reverse", &v75, &v76);
  v7 = v5 & 1;
  v64 = v5;
  v8 = v5 & 4;
  v9 = optind;
  v65 = &a2[optind];
  if ( v8 )
    v8 = sub_62178(v75);
  v10 = dword_7DB98;
  *(_DWORD *)(dword_7DB98 + 4) = v8;
  *(_DWORD *)(v10 + 48) = -1;
  *(_DWORD *)(v10 + 44) = -1;
  if ( (v64 & 8) != 0 )
  {
    v11 = sub_61D6C(v76);
LABEL_5:
    sub_176A8(v11, 0);
    goto LABEL_6;
  }
  if ( a2[v9] )
  {
    v37 = (int)v65[1];
    if ( v37 )
    {
      v11 = sub_61D6C(v37);
      goto LABEL_5;
    }
  }
LABEL_6:
  p_s1 = &v73;
  v13 = &v79;
  if ( v7 )
    p_s1 = &s1;
  v67 = (void **)p_s1;
LABEL_9:
  v14 = 0;
LABEL_10:
  while ( 1 )
  {
    v15 = sub_58D24((FILE *)stdin, v6, (int)v13);
    v16 = v15;
    if ( !v15 )
      break;
    if ( !*v15 )
    {
      free(v15);
      v16 = sub_174F8(" ");
    }
    v17 = (_DWORD *)dword_7DB98;
    if ( v14 <= 1 )
    {
      if ( sub_1684C((unsigned __int8 *)v16, (int)"--- ") || sub_1684C((unsigned __int8 *)v16, (int)"+++ ") )
      {
        if ( *v16 == 43 )
        {
          if ( v7 )
          {
            v14 = v7;
            v46 = (void **)&v73;
          }
          else
          {
            v46 = (void **)&s1;
            v14 = 1;
          }
        }
        else
        {
          v46 = v67;
        }
        sub_4E648();
        if ( !*v65 )
        {
          free(*v46);
          for ( i = v16 + 4; ; ++i )
          {
            v48 = *(unsigned __int8 *)i;
            v49 = v48 != 9;
            if ( !*i )
              v49 = 0;
            if ( !v49 )
              break;
            if ( v48 == 92 && i[1] )
              ++i;
          }
          if ( (unsigned int)(atoi(i) - 1901) > 0x45 )
          {
            v50 = v16 + 4;
            *i = 0;
          }
          else
          {
            v50 = "/dev/null";
          }
          *v46 = sub_174F8(v50);
        }
      }
      else if ( v14 == 1 && sub_1684C((unsigned __int8 *)v16, (int)"@@ -") )
      {
        v77 = v16 + 4;
        v17[6] = 1;
        v17[4] = 1;
        v17[3] = strtol(v16 + 4, &v77, 10);
        if ( *v77 == 44 )
        {
          v3 = strtol(v77 + 1, &v77, 10);
          v17[4] = v3;
        }
        else
        {
          v3 = 1;
        }
        v17[5] = strtol(v77 + 2, &v77, 10);
        if ( *v77 == 44 )
        {
          v2 = strtol(v77 + 1, &v77, 10);
          v17[6] = v2;
        }
        else
        {
          v2 = 1;
        }
        v51 = v3 <= 0;
        if ( v3 <= 0 )
          v51 = v2 <= 0;
        if ( v51 )
          sub_16DBC("Really? %s", v16);
        v17[8] = 0;
        if ( !v73 )
          v73 = sub_174F8("MISSING_FILENAME");
        if ( !s1 )
          s1 = sub_174F8("MISSING_FILENAME");
        if ( v17[11] != -1 )
        {
LABEL_118:
          v14 = 2;
          goto LABEL_134;
        }
        if ( v7 )
          v52 = v73;
        else
          v52 = s1;
        v53 = v3 + v17[3];
        v54 = v2 + v17[5];
        if ( !strcmp(v52, "/dev/null") )
        {
          if ( v7 )
            goto LABEL_138;
        }
        else
        {
          if ( v7 )
          {
            if ( v53 )
              goto LABEL_125;
LABEL_138:
            v52 = s1;
LABEL_126:
            v77 = v52;
            v55 = 0;
            v6 = dword_7DBC0 & 4;
            while ( 1 )
            {
              v56 = v77;
              if ( !*v77 || (dword_7DBC0 & 4) != 0 && v17[1] == v55 )
                break;
              ++v77;
              if ( *v56 == 47 )
              {
                while ( 1 )
                {
                  v52 = v77;
                  if ( *v77 != 47 )
                    break;
                  ++v77;
                }
                ++v55;
              }
            }
            v57 = *v65;
            if ( !*v65 )
              v57 = v52;
            if ( v14 )
            {
              v14 = v64 & 0x100;
              if ( (dword_7DBC0 & 0x20) != 0 )
              {
                printf("removing %s\n", v57);
                if ( (v64 & 0x100) == 0 )
                {
                  sub_1761C(v57);
                  goto LABEL_134;
                }
              }
              else
              {
                printf("patching file %s\n", v57);
                if ( (v64 & 0x100) == 0 )
                {
                  v58 = sub_175D8(v57, 513);
                  sub_17700(v58);
                  goto LABEL_134;
                }
              }
              v14 = 0;
LABEL_134:
              v13 = (char *)dword_7DB98;
              ++*(_DWORD *)(dword_7DB98 + 40);
              continue;
            }
            if ( (dword_7DBC0 & 4) != 0 && v17[1] < v55 )
              goto LABEL_118;
            v59 = strcmp(v73, "/dev/null") == 0;
            if ( v53 )
              v60 = v59;
            else
              v60 = 1;
            if ( v60 )
            {
              printf("creating %s\n", v57);
              if ( (v64 & 0x100) == 0 )
              {
                v61 = strrchr(v57, 47);
                v77 = v61;
                if ( v61 )
                {
                  *v61 = 0;
                  sub_5D824(v57, 0xFFFFFFFF, 4);
                  *v77 = 47;
                }
                v17[11] = sub_175D8(v57, 194);
LABEL_158:
                v62 = sub_177E4("%sXXXXXX", v57);
                v17[13] = v62;
                v17[12] = sub_17778(v62);
                sub_62E08();
                fchmod(v17[12], v78[4]);
LABEL_159:
                v17[7] = 0;
                v17[10] = 0;
                goto LABEL_118;
              }
              v17[11] = sub_175D8("/dev/null", 0);
            }
            else
            {
              printf("patching file %s\n", v57);
              v17[11] = sub_175D8(v57, 0);
              if ( (v64 & 0x100) == 0 )
                goto LABEL_158;
            }
            v17[13] = "";
            v17[12] = sub_175D8("/dev/null", 1);
            goto LABEL_159;
          }
          if ( v54 )
          {
LABEL_125:
            v14 = 0;
            goto LABEL_126;
          }
        }
        v52 = v73;
        goto LABEL_126;
      }
      free(v16);
      continue;
    }
    v18 = (unsigned __int8)*v16;
    v19 = (((_BYTE)v18 - 43) & 0xFD) == 0;
    if ( (((_BYTE)v18 - 43) & 0xFD) != 0 )
      v19 = v18 == 32;
    if ( !v19 )
    {
      sub_4E70C();
      goto LABEL_9;
    }
    sub_4E5A0((int *)(dword_7DB98 + 8), (int)v16);
    v20 = (unsigned __int8)*v16;
    if ( v20 != 43 )
    {
      --v3;
      if ( v20 == 45 )
        goto LABEL_55;
    }
    v21 = v20 == 32;
    if ( v20 == 32 )
      v21 = v14 == 2;
    --v2;
    if ( v21 )
    {
      v14 = 2;
      ++v17[8];
    }
    else
    {
LABEL_55:
      v14 = 3;
    }
    v22 = v3 | v2;
    if ( !(v3 | v2) )
    {
      v78[0] = 0;
      v23 = (int *)v17[2];
      v24 = dword_7DBC0 & 1;
      *(_DWORD *)v23[1] = 0;
      v25 = v23;
      do
      {
        v26 = (_BYTE *)v25[2];
        v25 = (_DWORD *)*v25;
        if ( *v26 == 32 )
          ++v22;
        else
          v22 = 0;
      }
      while ( v25 );
      if ( v22 )
        v27 = v17[8] > v22;
      else
        v27 = 1;
      v66 = v27;
      if ( v24 )
        v28 = v17[4];
      else
        v28 = v17[6];
      v29 = v28 != 0;
      if ( !v29 )
        goto LABEL_78;
      v29 = 0;
      v30 = 0;
LABEL_39:
      v31 = (const char *)sub_60388(v17[11], 0);
      v32 = dword_7DBC0 & 0x10;
      v33 = v17[7] + 1;
      v17[7] = v33;
      while ( 1 )
      {
LABEL_40:
        if ( !v23 || (v34 = (const char *)v23[2], *(unsigned __int8 *)v34 != (unsigned __int8)asc_6AED1[v24]) )
        {
          if ( !v31 )
          {
            v35 = v66;
            if ( v23 )
              v35 = 0;
            if ( v35 )
            {
LABEL_78:
              v45 = (void **)v17[2];
              v17[9] = (unsigned __int8)asc_6AED4[v29 ^ v24];
              sub_4E6E0(v45);
              v17[2] = 0;
              v17[9] = 1;
              goto LABEL_49;
            }
            if ( v30 )
              dprintf(2, "Possibly reversed hunk %d at %ld\n", v17[10], v33);
            sub_4E70C();
LABEL_49:
            v36 = (void **)v78[0];
            if ( v78[0] )
            {
              **(_DWORD **)(v78[0] + 4) = 0;
              sub_4E6E0(v36);
            }
            v2 = 0;
            v14 = v17[9];
            v3 = 0;
            goto LABEL_10;
          }
          v39 = sub_4E5A0(v78, (int)v31);
          while ( 1 )
          {
            if ( !v23 )
              goto LABEL_66;
            v69 = v39;
            v72 = (const char *)v23[2];
            v40 = strcmp((const char *)v39[2], v72 + 1);
            v39 = v69;
            if ( *(unsigned __int8 *)v72 == (unsigned __int8)asc_6AED1[v24] )
            {
              if ( !(v30 | v40) )
              {
                v30 = v17[7];
                if ( (dword_7DBC0 & 0x10) != 0 )
                {
                  v24 ^= 1u;
                  v29 = 1;
                }
              }
              v23 = (int *)*v23;
              continue;
            }
            if ( !v40 )
            {
              v23 = (int *)*v23;
              if ( v23 )
                v44 = 0;
              else
                v44 = !v66;
              if ( v44 )
                goto LABEL_78;
              v39 = (_DWORD *)*v69;
              if ( *v69 == v78[0] )
                goto LABEL_39;
            }
            else
            {
LABEL_66:
              v41 = v78[0];
              v17[9] = 3;
              v42 = *(_DWORD **)v41;
              v70 = v41;
              v78[0] = (int)v42;
              v43 = *(_DWORD **)(v41 + 4);
              *v43 = v42;
              v42[1] = v43;
              sub_4E5E4((void **)v41);
              v39 = (_DWORD *)v78[0];
              v23 = (int *)v17[2];
              if ( v70 == v78[0] )
              {
                v78[0] = 0;
                goto LABEL_39;
              }
            }
          }
        }
        if ( !v31 )
          goto LABEL_61;
        v71 = v32;
        v68 = v31;
        v38 = strcmp(v31, v34 + 1);
        v31 = v68;
        v32 = v71;
        if ( v38 | v30 )
          goto LABEL_61;
        if ( !v71 )
          break;
        v24 ^= 1u;
        v30 = v33;
        v29 = 1;
      }
      v30 = v33;
LABEL_61:
      v23 = (int *)*v23;
      goto LABEL_40;
    }
  }
  sub_4E648();
  return *(_DWORD *)(dword_7DB98 + 56);
}
// 4E870: variable 'v6' is possibly undefined
// 4E870: variable 'v13' is possibly undefined
// 4E8D8: variable 'v3' is possibly undefined
// 4E8E8: variable 'v2' is possibly undefined
// 13558: using guessed type int dprintf(_DWORD, const char *, ...);
// 7D604: using guessed type int optind;
// 7D610: using guessed type int stdin;
// 7DB98: using guessed type int dword_7DB98;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (0004F0D0) --------------------------------------------------------
int __fastcall sub_4F0D0(int a1, int a2)
{
  int v3; // r1
  int v4; // r3
  int result; // r0
  int v6; // r12
  int v7; // lr
  int v8; // r2
  int v9; // t1
  bool v10; // zf

  v3 = a1;
  if ( a1 >= 0 )
  {
    v4 = -1;
  }
  else
  {
    v3 = -a1;
    v4 = -2;
  }
  result = 0;
  v6 = a2 - 1;
  v7 = 0;
  while ( 1 )
  {
    v9 = *(unsigned __int8 *)++v6;
    v8 = v9;
    if ( !v9 )
      sub_16DBC("unmatched '%c'", v3);
    if ( v4 >= 0 )
    {
      if ( v8 == 93 && v4 != result - 1 )
      {
        if ( v4 == result - 2 )
        {
          if ( *(_BYTE *)(v6 - 1) != 94 )
            v4 = -1;
        }
        else
        {
          v4 = -1;
        }
      }
      goto LABEL_12;
    }
    if ( v7 )
    {
      v7 = 0;
      goto LABEL_12;
    }
    if ( v8 == 92 )
    {
      v7 = 1;
      goto LABEL_12;
    }
    v10 = v8 == 91;
    if ( v8 == 91 )
      v10 = v4 == -1;
    if ( v10 )
    {
      v4 = result;
      goto LABEL_12;
    }
    if ( v8 == v3 )
      return result;
LABEL_12:
    ++result;
  }
}

//----- (0004F18C) --------------------------------------------------------
tcflag_t sub_4F18C()
{
  tcflag_t result; // r0

  result = buf.c_lflag;
  if ( buf.c_lflag )
    return unlink((const char *)buf.c_lflag);
  return result;
}

//----- (0004F1A4) --------------------------------------------------------
_BYTE *__fastcall sub_4F1A4(int a1, char *s, int a3, int a4, unsigned __int8 a5)
{
  _BYTE *v8; // r12
  int v9; // lr
  int v10; // r1
  int v12; // r1

  if ( a3 == -1 )
    a3 = strlen(s);
  v8 = (_BYTE *)a1;
  v9 = 0;
  while ( v9 < a3 )
  {
    if ( s[v9] != 92 )
      goto LABEL_14;
    v10 = (unsigned __int8)s[v9 + 1];
    if ( !a5 )
      goto LABEL_8;
    if ( a4 == v10 )
    {
      v10 = a5;
LABEL_8:
      *v8 = v10;
      if ( !v10 )
        return &v8[-a1];
      v9 += 2;
      ++v8;
    }
    else
    {
      *v8 = 92;
      ++v9;
      ++v8;
LABEL_14:
      v12 = (unsigned __int8)s[v9];
      *v8 = v12;
      if ( !v12 )
        return &v8[-a1];
      ++v8;
      ++v9;
    }
  }
  *v8 = 0;
  return &v8[-a1];
}

//----- (0004F25C) --------------------------------------------------------
char *__fastcall sub_4F25C(char *a1, _BYTE *a2)
{
  char *v3; // r4
  _BYTE *v4; // r6
  char *i; // r5
  char *v7; // r1

  v3 = "\tt\rr";
  v4 = a2;
  for ( i = (char *)sub_1748C((size_t)(a2 + 1));
        ;
        v4 = sub_4F1A4((int)i, v7, (int)v4, (unsigned __int8)*(v3 - 3), *(v3 - 4)) )
  {
    v3 += 2;
    if ( !*(v3 - 4) )
      break;
    v7 = a1;
    a1 = i;
  }
  return i;
}

//----- (0004F2BC) --------------------------------------------------------
char *__fastcall sub_4F2BC(int a1, char *a2, regex_t **a3)
{
  int v4; // r3
  int v5; // r4
  bool v7; // zf
  _BYTE *v8; // r0
  _BYTE *v9; // r6
  char *v10; // r5
  regex_t *v11; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  endptr = a2;
  v4 = *(unsigned __int8 *)a1;
  v5 = a1;
  endptr = (char *)a1;
  if ( (unsigned int)(v4 - 48) > 9 )
  {
    if ( v4 == 36 )
    {
      *(_DWORD *)a2 = -1;
      endptr = (char *)(a1 + 1);
    }
    else
    {
      v7 = v4 == 92;
      if ( v4 != 92 )
        v7 = v4 == 47;
      if ( v7 )
      {
        if ( v4 == 92 )
          endptr = (char *)(a1 + 1);
        else
          a1 = 47;
        if ( v4 == 92 )
          a1 = *(unsigned __int8 *)(a1 + 1);
        v8 = (_BYTE *)sub_4F0D0(a1, (int)++endptr);
        v9 = v8;
        if ( v8 )
        {
          v10 = sub_4F25C(endptr, v8);
          v11 = (regex_t *)sub_174DC(0x20u);
          *a3 = v11;
          dword_7D808 = (int)v11;
          sub_625E4(*a3, v10, buf.c_oflag);
          free(v10);
        }
        else
        {
          *a3 = (regex_t *)dword_7D808;
          if ( !dword_7D808 )
            sub_16DBC("no previous regexp");
        }
        endptr = &v9[(_DWORD)endptr + 1];
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = strtol((const char *)a1, &endptr, 10);
  }
  return &endptr[-v5];
}
// 7D808: using guessed type int dword_7D808;

//----- (0004F3C8) --------------------------------------------------------
_BYTE *__fastcall sub_4F3C8(_BYTE *a1, char **a2, char **a3)
{
  int v3; // r7
  char *v4; // r4
  _BYTE *v8; // r1
  char *v9; // r0
  char *v10; // r4
  _BYTE *v11; // r5

  v3 = (unsigned __int8)*a1;
  if ( !*a1 )
    sub_16DBC("bad format in substitution expression");
  v4 = a1 + 1;
  v8 = (_BYTE *)sub_4F0D0((unsigned __int8)*a1, (int)(a1 + 1));
  v9 = v4;
  v10 = &v8[(_DWORD)v4 + 1];
  *a2 = sub_4F25C(v9, v8);
  v11 = (_BYTE *)sub_4F0D0(-v3, (int)v10);
  *a3 = sub_4F25C(v10, v11);
  return &v11[v10 - a1];
}

//----- (0004F448) --------------------------------------------------------
unsigned __int8 *__fastcall sub_4F448(char *a1, void **a2)
{
  char *v4; // r2
  char *v5; // r0
  unsigned __int8 *v6; // r3
  unsigned int v7; // r1
  bool v8; // cc
  unsigned __int8 *i; // r4
  int v10; // r2
  bool v11; // zf
  int v12; // r1
  void *v13; // r0

  v4 = a1;
  do
  {
    v5 = v4;
    v6 = (unsigned __int8 *)(v4 - a1);
    v7 = (unsigned __int8)*v4++;
    v8 = v7 > 0x20;
    if ( v7 != 32 )
      v8 = v7 - 9 > 4;
  }
  while ( !v8 );
  for ( i = v6; ; ++i )
  {
    v10 = i[(_DWORD)a1];
    v11 = v10 == 0;
    if ( i[(_DWORD)a1] )
      v11 = v10 == 10;
    if ( v11 )
      break;
  }
  v12 = i - v6;
  if ( v10 == 10 )
  {
    if ( i != v6 )
    {
      v13 = sub_1751C(v5, v12 + 2);
      *a2 = v13;
      i[(_DWORD)v13] = 92;
      return i;
    }
LABEL_14:
    sub_16DBC("empty filename", v12);
  }
  if ( i == v6 )
    goto LABEL_14;
  *a2 = sub_1751C(v5, v12 + 1);
  return i;
}

//----- (0004F4E8) --------------------------------------------------------
void __fastcall sub_4F4E8(char *s)
{
  char *v1; // r4
  size_t v2; // r0
  size_t v3; // r5
  char *v4; // r2
  char v5; // r3
  int v6; // t1
  size_t v7; // r0
  int v8; // r7
  const char *v9; // r0
  void *v10; // r5
  char *v11; // r3
  char *v12; // r4
  int v13; // r0
  char *v14; // r0
  unsigned __int8 *v15; // r0
  unsigned __int8 *v16; // r11
  int v17; // r7
  unsigned int v18; // r0
  tcflag_t c_oflag; // r7
  int v20; // r9
  unsigned int v21; // r2
  const char *v22; // r0
  int v23; // r0
  char *v24; // r3
  bool v25; // cc
  int v26; // r1
  regex_t *v27; // r0
  int v28; // r0
  bool v29; // cc
  unsigned int v30; // r3
  char *v31; // r7
  bool v32; // zf
  _BYTE *v33; // r0
  char *v34; // r0
  size_t v35; // r7
  void *v36; // r0
  int v37; // r7
  size_t v38; // r0
  void *v39; // r0
  int v40; // r3
  char v41; // r1
  int v42; // r2
  void *ptr; // [sp+8h] [bp-Ch] BYREF
  char *endptr[2]; // [sp+Ch] [bp-8h] BYREF

  v1 = s;
  if ( dword_7D818 )
  {
    v1 = sub_177E4("%s\n%s", (const char *)dword_7D818, s);
    free((void *)dword_7D818);
    dword_7D818 = (int)v1;
  }
  v2 = strlen(v1);
  v3 = v2;
  v4 = &v1[v2];
  while ( 1 )
  {
    v5 = (_BYTE)v4 - (_BYTE)v1;
    if ( v1 == v4 )
      break;
    v6 = (unsigned __int8)*--v4;
    if ( v6 != 92 )
      goto LABEL_6;
  }
  v5 = 0;
LABEL_6:
  if ( (((_BYTE)v2 - v5) & 1) == 0 )
  {
    while ( 1 )
    {
LABEL_7:
      if ( !*v1 || (v7 = strspn(v1, "; \n\r\t\v"), v8 = (int)&v1[v7], !v1[v7]) )
      {
LABEL_9:
        free((void *)dword_7D818);
        dword_7D818 = 0;
        return;
      }
      if ( v1[v7] != 35 )
        break;
      v9 = &v1[v7];
      if ( *(_BYTE *)(v8 + 1) == 110 )
        ++buf.c_iflag;
      v1 = strpbrk(v9, "\n\r");
      if ( !v1 )
        goto LABEL_9;
    }
    v10 = sub_174DC(0x30u);
    v11 = &sub_4F2BC(v8, (char *)v10 + 16, (regex_t **)v10 + 1)[v8];
    *((_DWORD *)v10 + 5) = *((_DWORD *)v10 + 4);
    if ( *v11 == 44 )
    {
      v12 = v11 + 1;
      if ( v11[1] == 43 && (unsigned int)(unsigned __int8)v11[2] - 48 <= 9 )
      {
        v13 = strtol(v11 + 2, endptr, 10);
        *((_DWORD *)v10 + 6) = -2 - v13;
        v11 = endptr[0];
      }
      else
      {
        v14 = sub_4F2BC((int)(v11 + 1), (char *)v10 + 24, (regex_t **)v10 + 2);
        v11 = &v14[(_DWORD)v12];
        v13 = (int)(v14 - 1);
      }
      if ( v13 < 0 )
        sub_16DBC("no address after comma");
      *((_DWORD *)v10 + 7) = *((_DWORD *)v10 + 6);
    }
    v15 = sub_60E74((unsigned __int8 *)v11);
    v16 = v15;
    if ( *v15 == 33 )
    {
      *((_BYTE *)v10 + 44) |= 1u;
      v16 = sub_60E74(v15 + 1);
    }
    v17 = *v16;
    if ( !*v16 )
      sub_16DBC("missing command");
    *((_BYTE *)v10 + 46) = v17;
    v1 = (char *)(v16 + 1);
    v18 = strchrnul("saicrw:btTydDgGhHlnNpPqx={}", v17) - (_DWORD)"saicrw:btTydDgGhHlnNpPqx={}";
    if ( v18 )
    {
      if ( v18 > 3 )
      {
        if ( v18 > 5 )
        {
          if ( v18 > 9 )
          {
            if ( v18 == 10 )
            {
              v37 = v16[1];
              v1 = &sub_4F3C8(v16 + 1, (char **)&ptr, endptr)[(_DWORD)v1 + 1];
              sub_4F1A4((int)ptr, (char *)ptr, -1, v37, v37);
              sub_4F1A4((int)endptr[0], endptr[0], -1, v37, v37);
              v38 = strlen((const char *)ptr);
              v39 = sub_174DC(2 * (v38 + 1));
              v40 = 0;
              *((_DWORD *)v10 + 9) = v39;
              while ( *((_BYTE *)ptr + v40) && endptr[0][v40] )
              {
                *(_BYTE *)(*((_DWORD *)v10 + 9) + 2 * v40) = *((_BYTE *)ptr + v40);
                v41 = endptr[0][v40];
                v42 = *((_DWORD *)v10 + 9) + 2 * v40++;
                *(_BYTE *)(v42 + 1) = v41;
              }
              free(ptr);
              free(endptr[0]);
            }
            else if ( v18 > 0x1A )
            {
              sub_16DBC("unsupported command %c", v17);
            }
          }
          else
          {
            v1 = (char *)sub_60E74(v16 + 1);
            v35 = strcspn(v1, "; \n\r\t\v");
            if ( v35 )
            {
              v36 = sub_1751C(v1, v35);
              v1 += v35;
              *((_DWORD *)v10 + 9) = v36;
            }
          }
          goto LABEL_59;
        }
        if ( v18 != 4 || !*((_DWORD *)v10 + 6) && !*((_DWORD *)v10 + 2) )
        {
          v1 = (char *)&sub_4F448((char *)v16 + 1, (void **)v10 + 9)[(_DWORD)v1];
          if ( *((_BYTE *)v10 + 46) == 119 )
          {
            *((_DWORD *)v10 + 8) = sub_61CC0(*((const char **)v10 + 9));
            *((_BYTE *)v10 + 45) = 10;
          }
          goto LABEL_59;
        }
      }
      else if ( v18 == 3 || !*((_DWORD *)v10 + 6) && !*((_DWORD *)v10 + 2) )
      {
        while ( 1 )
        {
          v30 = (unsigned __int8)*v1;
          v31 = v1++;
          v32 = v30 == 92;
          if ( v30 != 92 )
            v32 = v30 == 10;
          if ( v32 )
            break;
          v29 = v30 > 0x20;
          if ( v30 != 32 )
            v29 = v30 - 9 > 4;
          if ( v29 )
            goto LABEL_79;
        }
        v31 = v1;
LABEL_79:
        v33 = (_BYTE *)strlen(v31);
        v1 = &v33[(_DWORD)v31];
        v34 = sub_4F25C(v31, v33);
        *((_DWORD *)v10 + 9) = v34;
        sub_4F1A4((int)v34, v34, -1, 0, 0);
        goto LABEL_59;
      }
      sub_16DBC("command '%c' uses only one address", v17);
    }
    c_oflag = buf.c_oflag;
    v20 = (int)sub_4F3C8(v16 + 1, (char **)&ptr, (char **)v10 + 9);
    *((_DWORD *)v10 + 10) = 1;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          do
          {
            while ( 1 )
            {
              v21 = (unsigned __int8)v1[++v20];
              v22 = &v1[v20];
              if ( !v1[v20] )
                goto LABEL_56;
              if ( v21 - 48 > 9 )
                break;
              if ( *(_BYTE *)ptr != 94 )
              {
                endptr[0] = &v1[v20];
                v23 = strtol(v22, endptr, 10);
                v24 = endptr[0];
                *((_DWORD *)v10 + 10) = v23;
                v20 = v24 - v1 - 1;
              }
            }
            v25 = v21 > 0x20;
            if ( v21 != 32 )
              v25 = v21 - 9 > 4;
            v26 = !v25;
          }
          while ( !v25 );
          if ( v21 != 103 )
            break;
          if ( *(_BYTE *)ptr != 94 )
            *((_DWORD *)v10 + 10) = v26;
        }
        if ( v21 > 0x67 )
          break;
        if ( v21 == 59 )
          goto LABEL_56;
        if ( v21 != 73 )
        {
          if ( v21 != 35 )
            goto LABEL_49;
          v20 += strlen(v22);
          goto LABEL_56;
        }
LABEL_53:
        c_oflag |= 2u;
      }
      if ( v21 == 112 )
      {
        *((_BYTE *)v10 + 44) |= 4u;
      }
      else
      {
        if ( v21 <= 0x70 )
        {
          if ( v21 != 105 )
            goto LABEL_49;
          goto LABEL_53;
        }
        if ( v21 != 119 )
        {
          if ( v21 != 125 )
LABEL_49:
            sub_16DBC("bad option in substitution expression");
LABEL_56:
          if ( *(_BYTE *)ptr )
          {
            v27 = (regex_t *)sub_174DC(0x20u);
            *((_DWORD *)v10 + 3) = v27;
            sub_625E4(v27, (const char *)ptr, c_oflag);
          }
          v1 += v20;
          free(ptr);
LABEL_59:
          *(_DWORD *)dword_7D810 = v10;
          dword_7D810 = (int)v10;
          goto LABEL_7;
        }
        v20 += (int)sub_4F448(&v1[v20 + 1], (void **)endptr);
        v28 = sub_61CC0(endptr[0]);
        *((_BYTE *)v10 + 45) = 10;
        *((_DWORD *)v10 + 8) = v28;
        free(endptr[0]);
      }
    }
  }
  if ( !dword_7D818 )
    dword_7D818 = (int)sub_174F8(v1);
  *(_BYTE *)(v3 + dword_7D818 - 1) = 0;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7D810: using guessed type int dword_7D810;
// 7D818: using guessed type int dword_7D818;

//----- (0004FAD0) --------------------------------------------------------
void __fastcall sub_4FAD0(const char *a1)
{
  char *v1; // r6
  const char *v2; // r5
  char *v3; // r4
  char *v4; // r0

  v1 = sub_174F8(a1);
  v2 = v1;
  do
  {
    v3 = strchr(v2, 10);
    v4 = (char *)v2;
    if ( v3 )
      *v3 = 0;
    v2 = v3 + 1;
    sub_4F4E8(v4);
  }
  while ( v3 );
  free(v1);
}

//----- (0004FB18) --------------------------------------------------------
void *__fastcall sub_4FB18(char a1)
{
  void *result; // r0
  int v3; // r3

  result = (void *)dword_7D81C;
  if ( dword_7D820 == dword_7D824 )
  {
    result = sub_174B4((void *)dword_7D81C, dword_7D820 + 64);
    dword_7D81C = (int)result;
    dword_7D824 += 64;
  }
  v3 = dword_7D820++;
  *(_BYTE *)(dword_7D81C + v3) = a1;
  return result;
}
// 7D81C: using guessed type int dword_7D81C;
// 7D820: using guessed type int dword_7D820;
// 7D824: using guessed type int dword_7D824;

//----- (0004FB6C) --------------------------------------------------------
int __fastcall sub_4FB6C(_BYTE *a1, FILE *a2, _BYTE *a3, int a4)
{
  int v5; // r4
  bool v9; // zf
  int result; // r0

  v5 = (unsigned __int8)*a3;
  v9 = v5 == 10;
  if ( v5 != 10 )
    v9 = v5 == 0;
  if ( !v9 )
  {
    LOBYTE(v5) = 10;
    putc_unlocked(10, a2);
  }
  fputs_unlocked(a1, a2);
  if ( *a1 )
    LOBYTE(v5) = 120;
  if ( a4 == 2 )
  {
    LOBYTE(v5) = 120;
    putc_unlocked(0, a2);
  }
  else if ( a4 != 1 )
  {
    putc_unlocked(a4, a2);
    LOBYTE(v5) = a4;
  }
  result = ferror_unlocked(a2);
  if ( result )
  {
    byte_7D5F8 = 4;
    sub_16DBC("write error");
  }
  *a3 = v5;
  return result;
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D5F8: using guessed type char byte_7D5F8;

//----- (0004FC1C) --------------------------------------------------------
_BYTE *__fastcall sub_4FC1C(_BYTE *a1)
{
  _BYTE *result; // r0
  void *v3; // r4

  while ( 1 )
  {
    result = (_BYTE *)sub_5D2FC(&dword_7D814);
    v3 = result;
    if ( !result )
      break;
    sub_4FB6C(result, (FILE *)buf.c_cflag, a1, 10);
    free(v3);
  }
  return result;
}
// 7D814: using guessed type _DWORD *dword_7D814;

//----- (0004FC5C) --------------------------------------------------------
_BYTE *__fastcall sub_4FC5C(_BYTE *a1, _BYTE *a2, int a3)
{
  int v4; // r5
  _BYTE *v5; // r6
  FILE *v6; // r4
  const char *v7; // r0
  _BYTE *v8; // r0
  bool v9; // zf
  int v10; // r0
  _DWORD v12[2]; // [sp+4h] [bp-8h] BYREF

  v12[0] = a2;
  v12[1] = a3;
  sub_4FC1C(a2);
  while ( 1 )
  {
    if ( *(int *)&buf.c_cc[7] > *(int *)&buf.c_cc[11] )
    {
      LOBYTE(v4) = 1;
      v5 = 0;
      goto LABEL_19;
    }
    v6 = *(FILE **)&buf.c_cc[19];
    if ( !*(_DWORD *)&buf.c_cc[19] )
    {
      v6 = (FILE *)stdin;
      v7 = *(const char **)(*(_DWORD *)&buf.c_cc[15] + 4 * *(_DWORD *)&buf.c_cc[7]);
      if ( v7 != "standard input" )
      {
        v6 = (FILE *)sub_61C78(v7, (int)"r");
        if ( !v6 )
        {
          buf.c_cc[4] = 0;
          buf.c_cc[3] = 1;
          buf.c_cc[5] = 0;
          buf.c_cc[6] = 0;
          goto LABEL_8;
        }
      }
      *(_DWORD *)&buf.c_cc[19] = v6;
    }
    v8 = sub_58C58(v6, v12);
    v5 = v8;
    if ( v8 )
      break;
    sub_5888C(v6);
    buf.c_cc[19] = 0;
    buf.c_cc[20] = 0;
    buf.c_cc[21] = 0;
    buf.c_cc[22] = 0;
LABEL_8:
    ++*(_DWORD *)&buf.c_cc[7];
  }
  v4 = (unsigned __int8)v8[v12[0] - 1];
  v9 = v4 == 0;
  if ( v8[v12[0] - 1] )
    v9 = v4 == 10;
  if ( v9 )
  {
    v8[v12[0] - 1] = 0;
    if ( !v4 )
    {
      v10 = getc_unlocked(v6);
      if ( v10 == -1 )
        LOBYTE(v4) = 2;
      else
        ungetc(v10, v6);
    }
  }
  else
  {
    LOBYTE(v4) = 1;
  }
LABEL_19:
  *a1 = v4;
  return v5;
}
// 7D610: using guessed type int stdin;

//----- (0004FD84) --------------------------------------------------------
void __fastcall sub_4FD84(int a1, int a2, int a3)
{
  int v3; // r9
  int v4; // r2
  char *v5; // r5
  int v6; // r10
  const char *v7; // r8
  int i; // r4
  unsigned int v9; // r3
  int v10; // r2
  int v11; // r7
  bool v12; // zf
  int v13; // r3
  int v14; // r0
  int v15; // r3
  const regex_t *v16; // r0
  int v17; // r3
  int v18; // r2
  const regex_t *v19; // r0
  char *v20; // r1
  int v21; // r0
  int v22; // t1
  int v23; // r2
  int j; // r3
  char *v25; // r0
  char *v26; // r7
  FILE *v27; // r1
  int v28; // r3
  char *v29; // r2
  char *v30; // r0
  char *v31; // r0
  void *v32; // r0
  const char *v33; // r7
  int v34; // r11
  int v35; // r3
  bool v36; // zf
  char *k; // r3
  const char *n; // r3
  int v39; // r3
  int v40; // r2
  char v41; // r0
  int v42; // t1
  FILE *v43; // r1
  int v44; // r3
  int v45; // r0
  const char *v46; // r3
  int v47; // t1
  int v48; // r3
  int v49; // r0
  int v50; // r0
  int v51; // r2
  char *v52; // r2
  char *v53; // r1
  int v54; // r0
  char *m; // r3
  char *v56; // r0
  FILE *c_cflag; // r1
  int v58; // r3
  char *v59; // r0
  char *v60; // r0
  int v61; // r1
  int v62; // r2
  FILE *v63; // r7
  _BYTE *v64; // r1
  int v65; // r2
  const char *v66; // r0
  char *v67; // r0
  size_t v68; // r7
  size_t v69; // r0
  int v70; // r2
  const char *v71; // r7
  const char *v72; // r0
  const char *v73; // r0
  size_t v74; // r7
  size_t v75; // r0
  char *v76; // r0
  char v77; // r3
  size_t v78; // r7
  size_t v79; // r0
  _BYTE *v80; // r0
  char *v81; // r0
  int v82; // [sp+8h] [bp-34h]
  regex_t *preg; // [sp+Ch] [bp-30h]
  int v84; // [sp+10h] [bp-2Ch]
  int v85; // [sp+10h] [bp-2Ch]
  int v86; // [sp+14h] [bp-28h]
  int v87; // [sp+18h] [bp-24h]
  int v88; // [sp+1Ch] [bp-20h]
  _BOOL4 v89; // [sp+20h] [bp-1Ch]
  int v90; // [sp+20h] [bp-1Ch]
  const char *v91; // [sp+24h] [bp-18h]
  char *v92; // [sp+24h] [bp-18h]
  char *v93; // [sp+24h] [bp-18h]
  int v94; // [sp+24h] [bp-18h]
  int v95; // [sp+24h] [bp-18h]
  char *v96; // [sp+24h] [bp-18h]
  int v97; // [sp+28h] [bp-14h]
  int v98; // [sp+28h] [bp-14h]
  char *v99; // [sp+2Ch] [bp-10h]
  char v100; // [sp+36h] [bp-6h] BYREF
  unsigned __int8 v101; // [sp+37h] [bp-5h] BYREF

  v3 = 0;
  v100 = 10;
  v5 = sub_4FC5C(&v101, &v100, a3);
  while ( v5 )
  {
    v6 = v101;
    ++v3;
    v7 = sub_4FC5C(&v101, &v100, v4);
    v82 = 0;
LABEL_4:
    for ( i = dword_7D80C; i; i = *(_DWORD *)i )
    {
      v9 = *(unsigned __int8 *)(i + 44);
      v10 = *(_DWORD *)(i + 16);
      v11 = (v9 >> 1) & 1;
      if ( (v9 & 2) != 0 )
        goto LABEL_13;
      if ( !v10 )
      {
        if ( *(_DWORD *)(i + 24) || *(_DWORD *)(i + 4) )
          goto LABEL_28;
        v12 = *(_DWORD *)(i + 8) == 0;
        goto LABEL_11;
      }
      if ( v10 <= 0 )
        goto LABEL_28;
      if ( !*(_DWORD *)(i + 24) && !*(_DWORD *)(i + 8) )
      {
        v12 = v3 == v10;
LABEL_11:
        if ( v12 )
          goto LABEL_13;
        goto LABEL_28;
      }
      if ( v3 >= v10 )
        goto LABEL_26;
LABEL_28:
      v16 = *(const regex_t **)(i + 4);
      if ( v16 && !regexec(v16, v5, 0, 0, 0) )
      {
        dword_7D808 = *(_DWORD *)(i + 4);
LABEL_26:
        LOBYTE(v9) = *(_BYTE *)(i + 44);
LABEL_13:
        *(_BYTE *)(i + 44) = v9 | 2;
        v13 = *(_DWORD *)(i + 24);
        if ( v13 < -1 )
          *(_DWORD *)(i + 24) = v3 - v13 - 2;
        v14 = *(_DWORD *)(i + 24);
        if ( *(int *)(i + 16) > 0 )
          *(_DWORD *)(i + 16) = -2;
        if ( v14 )
        {
          if ( v14 == -1 )
          {
            if ( !v7 )
              goto LABEL_20;
LABEL_46:
            v19 = *(const regex_t **)(i + 8);
            if ( !v19 )
              v11 = 0;
            if ( v11 )
              LOBYTE(v14) = regexec(v19, v5, 0, 0, 0) != 0;
            else
              LOBYTE(v14) = 1;
          }
          else
          {
            if ( v14 > v3 )
              goto LABEL_46;
LABEL_20:
            LOBYTE(v14) = 0;
          }
        }
        else if ( *(_DWORD *)(i + 8) )
        {
          goto LABEL_46;
        }
        *(_BYTE *)(i + 44) = *(_BYTE *)(i + 44) & 0xFD | (2 * (v14 & 1));
        v15 = 1;
        goto LABEL_34;
      }
      LOBYTE(v9) = *(_BYTE *)(i + 44);
      if ( *(_DWORD *)(i + 16) == -1 && !v7 )
        goto LABEL_13;
      *(_BYTE *)(i + 44) = v9 & 0xFD;
      v15 = 0;
LABEL_34:
      if ( *(_BYTE *)(i + 46) == 123 )
      {
        if ( (*(_BYTE *)(i + 44) & 1) == 0 )
          v15 ^= 1u;
        if ( v15 )
        {
          v17 = 0;
          while ( 1 )
          {
            v18 = *(unsigned __int8 *)(i + 46);
            if ( v18 == 123 )
            {
              ++v17;
            }
            else if ( v18 == 125 && !--v17 )
            {
              break;
            }
            i = *(_DWORD *)i;
            if ( !i )
              sub_16DBC("unterminated {");
          }
        }
      }
      else
      {
        if ( (*(_BYTE *)(i + 44) & 1) == 0 )
          v15 ^= 1u;
        v84 = v15;
        if ( !v15 )
        {
          if ( *(_DWORD *)(i + 4) )
            dword_7D808 = *(_DWORD *)(i + 4);
          switch ( *(_BYTE *)(i + 46) )
          {
            case '=':
              fprintf((FILE *)buf.c_cflag, "%d\n", v3);
              continue;
            case 'D':
              v31 = strchr(v5, 10);
              if ( !v31 )
                goto LABEL_133;
              sub_60B4C((int)v5, (int)(v31 + 1));
              goto LABEL_4;
            case 'G':
              if ( v5 )
                v74 = strlen(v5) + 2;
              else
                v74 = 2;
              v75 = *(_DWORD *)&buf.c_line;
              if ( *(_DWORD *)&buf.c_line )
                v75 = strlen(*(const char **)&buf.c_line);
              v76 = (char *)sub_174B4(v5, v74 + v75);
              if ( v74 == 2 )
                v77 = 0;
              v5 = v76;
              if ( v74 == 2 )
                *v76 = v77;
              strcat(v76, "\n");
              if ( *(_DWORD *)&buf.c_line )
                strcat(v5, *(const char **)&buf.c_line);
              goto LABEL_180;
            case 'H':
              if ( *(_DWORD *)&buf.c_line )
                v78 = strlen(*(const char **)&buf.c_line) + 2;
              else
                v78 = 2;
              v79 = (size_t)v5;
              if ( v5 )
                v79 = strlen(v5);
              v80 = sub_174B4(*(void **)&buf.c_line, v78 + v79);
              *(_DWORD *)&buf.c_line = v80;
              if ( v78 == 2 )
                *v80 = 0;
              strcat(*(char **)&buf.c_line, "\n");
              if ( v5 )
                strcat(*(char **)&buf.c_line, v5);
              continue;
            case 'N':
              if ( !v7 )
                goto LABEL_145;
              ++v3;
              v68 = strlen(v5);
              v69 = strlen(v7);
              v5 = (char *)sub_174B4(v5, v68 + v69 + 2);
              v5[v68] = 10;
              strcpy(&v5[v68 + 1], v7);
              v6 = v101;
              v7 = sub_4FC5C(&v101, &v100, v70);
              continue;
            case 'P':
              v25 = strchr(v5, 10);
              v26 = v25;
              if ( !v25 )
                goto LABEL_66;
              *v25 = 0;
              sub_4FB6C(v5, (FILE *)buf.c_cflag, &v100, 10);
              *v26 = 10;
              continue;
            case 'T':
              if ( v82 )
                continue;
              goto LABEL_152;
            case 'a':
              v56 = sub_174F8(*(const char **)(i + 36));
              sub_5D2C8(&dword_7D814, (int)v56);
              continue;
            case 'b':
              goto LABEL_152;
            case 'c':
              if ( (*(_BYTE *)(i + 44) & 2) != 0 )
                goto LABEL_133;
              c_cflag = (FILE *)buf.c_cflag;
              v58 = 10;
              v59 = *(char **)(i + 36);
              goto LABEL_132;
            case 'd':
              goto LABEL_133;
            case 'g':
              free(v5);
              v73 = *(const char **)&buf.c_line;
              if ( !*(_DWORD *)&buf.c_line )
                v73 = "";
              v5 = sub_174F8(v73);
              continue;
            case 'h':
              free(*(void **)&buf.c_line);
              *(_DWORD *)&buf.c_line = sub_174F8(v5);
              continue;
            case 'i':
              v27 = (FILE *)buf.c_cflag;
              v28 = 10;
              v30 = *(char **)(i + 36);
              v29 = &v100;
              goto LABEL_129;
            case 'n':
              if ( !buf.c_iflag )
                sub_4FB6C(v5, (FILE *)buf.c_cflag, &v100, v6);
              if ( !v7 )
                goto LABEL_133;
              ++v3;
              free(v5);
              v6 = v101;
              v5 = (char *)v7;
              v66 = sub_4FC5C(&v101, &v100, v65);
              v44 = 0;
              v7 = v66;
              goto LABEL_143;
            case 'p':
LABEL_66:
              v27 = (FILE *)buf.c_cflag;
              v28 = 10;
              v29 = &v100;
              goto LABEL_67;
            case 'q':
              v67 = (char *)v7;
              v7 = 0;
              free(v67);
              goto LABEL_145;
            case 'r':
              v63 = (FILE *)sub_61C9C(*(_DWORD *)(i + 36));
              if ( v63 )
              {
                while ( 1 )
                {
                  v64 = sub_58D24(v63, v61, v62);
                  if ( !v64 )
                    break;
                  sub_5D2C8(&dword_7D814, (int)v64);
                }
                fclose(v63);
              }
              continue;
            case 's':
              preg = *(regex_t **)(i + 12);
              if ( !preg )
              {
                preg = (regex_t *)dword_7D808;
                if ( !dword_7D808 )
                  sub_16DBC("no previous regexp");
              }
              dword_7D808 = (int)preg;
              if ( regexec(preg, v5, 0xAu, (regmatch_t *)&buf.c_cc[23], 0) == 1 )
                continue;
              v32 = sub_1748C(0x40u);
              dword_7D820 = 0;
              v87 = 0;
              v33 = v5;
              dword_7D81C = (int)v32;
              dword_7D824 = 64;
              v88 = 0;
              v89 = 1;
              break;
            case 't':
              if ( !v82 )
                continue;
              v82 = 0;
LABEL_152:
              v71 = *(const char **)(i + 36);
              if ( !v71 )
                goto LABEL_145;
              for ( i = dword_7D80C; ; i = *(_DWORD *)i )
              {
                if ( !i )
                  sub_16DBC("can't find label for jump to '%s'", v71);
                if ( *(_BYTE *)(i + 46) == 58 )
                {
                  v72 = *(const char **)(i + 36);
                  if ( v72 )
                  {
                    if ( !strcmp(v72, v71) )
                      break;
                  }
                }
              }
              continue;
            case 'w':
              v28 = v6;
              v29 = (char *)(i + 45);
              v27 = *(FILE **)(i + 32);
LABEL_67:
              v30 = v5;
LABEL_129:
              sub_4FB6C(v30, v27, v29, v28);
              continue;
            case 'x':
              v81 = *(char **)&buf.c_line;
              if ( !*(_DWORD *)&buf.c_line )
                v81 = (char *)sub_174DC(1u);
              *(_DWORD *)&buf.c_line = v5;
              v5 = v81;
LABEL_180:
              v6 = 10;
              continue;
            case 'y':
              v20 = v5 - 1;
LABEL_60:
              while ( 1 )
              {
                v22 = (unsigned __int8)*++v20;
                v21 = v22;
                if ( !v22 )
                  break;
                v23 = *(_DWORD *)(i + 36);
                for ( j = 0; ; j += 2 )
                {
                  if ( !*(_BYTE *)(v23 + j) )
                    goto LABEL_60;
                  if ( *(unsigned __int8 *)(v23 + j) == v21 )
                    break;
                }
                *v20 = *(_BYTE *)(v23 + j + 1);
              }
              continue;
            default:
              continue;
          }
          do
          {
            v34 = *(_DWORD *)&buf.c_cc[27];
            v86 = *(_DWORD *)&buf.c_cc[23];
            ++v88;
            v35 = *(_DWORD *)(i + 40);
            v36 = v35 == 0;
            if ( v35 )
              v36 = v88 == v35;
            if ( v36 )
            {
              for ( k = (char *)v33; v86 > k - v33; k = v92 )
              {
                v92 = k + 1;
                sub_4FB18(*k);
              }
              v39 = v89;
              if ( v86 | v34 )
                v39 = 1;
              v90 = v39;
              if ( v39 )
              {
                v40 = 0;
                v85 = *(_DWORD *)(i + 36);
                while ( 1 )
                {
                  v54 = *(unsigned __int8 *)(v85 + v40);
                  if ( !*(_BYTE *)(v85 + v40) )
                    break;
                  v48 = v40 + 1;
                  if ( v54 == 92 )
                  {
                    v49 = *(unsigned __int8 *)(v85 + v48);
                    if ( (unsigned int)(v49 - 48) > 9 )
                    {
                      v94 = v40 + 1;
                      sub_4FB18(v49);
                      v48 = v94;
                    }
                    else
                    {
                      v50 = v49 - 43;
                      v51 = *(&buf.c_iflag + 2 * v50);
                      if ( v51 != -1 )
                      {
                        v52 = (char *)&v33[v51];
                        v53 = (char *)&buf + 8 * v50;
                        while ( v52 - v33 < *((_DWORD *)v53 + 1) )
                        {
                          v99 = v53;
                          v97 = v48;
                          v93 = v52 + 1;
                          sub_4FB18(*v52);
                          v53 = v99;
                          v52 = v93;
                          v48 = v97;
                        }
                      }
                    }
                  }
                  else
                  {
                    if ( v54 == 38 )
                    {
                      for ( m = (char *)&v33[*(_DWORD *)&buf.c_cc[23]]; m - v33 < *(int *)&buf.c_cc[27]; m = v96 )
                      {
                        v98 = v40;
                        v96 = m + 1;
                        sub_4FB18(*m);
                        v40 = v98;
                      }
                    }
                    else
                    {
                      v95 = v40;
                      sub_4FB18(v54);
                      v40 = v95;
                    }
                    v48 = v40;
                  }
                  v40 = v48 + 1;
                }
                v84 = v90;
              }
              v41 = v33[v34];
              v89 = v86 == v34;
              if ( v86 == v34 )
              {
                if ( v33[v34] )
                {
                  ++v34;
                  sub_4FB18(v41);
                }
                else
                {
                  v87 = 1;
                }
              }
              v33 += v34;
              if ( *(_DWORD *)(i + 40) )
                goto LABEL_90;
            }
            else
            {
              for ( n = v33 - 1; ; n = v91 )
              {
                v47 = *((unsigned __int8 *)n + 1);
                v46 = n + 1;
                v45 = v47;
                if ( v46 - v33 >= v34 )
                  break;
                v91 = v46;
                sub_4FB18(v45);
              }
              if ( v34 >= 0 )
                v33 += v34;
              if ( v86 == v34 && v45 )
              {
                ++v33;
                sub_4FB18(v45);
              }
            }
            if ( !*v33 )
            {
              if ( v87 )
              {
                sub_4FB18(0);
                goto LABEL_91;
              }
              v87 = 1;
            }
          }
          while ( regexec(preg, v33, 0xAu, (regmatch_t *)&buf.c_cc[23], 1) != 1 );
          do
          {
LABEL_90:
            v42 = *(unsigned __int8 *)v33++;
            sub_4FB18(v42);
          }
          while ( v42 );
LABEL_91:
          free(v5);
          v5 = (char *)dword_7D81C;
          if ( v84 )
          {
            if ( (*(_BYTE *)(i + 44) & 4) != 0 )
              sub_4FB6C((_BYTE *)dword_7D81C, (FILE *)buf.c_cflag, &v100, v6);
            v43 = *(FILE **)(i + 32);
            if ( v43 )
              sub_4FB6C(v5, v43, (_BYTE *)(i + 45), v6);
            v44 = 1;
LABEL_143:
            v82 = v44;
          }
        }
      }
    }
LABEL_145:
    if ( !buf.c_iflag )
    {
      v58 = v6;
      c_cflag = (FILE *)buf.c_cflag;
      v59 = v5;
LABEL_132:
      sub_4FB6C(v59, c_cflag, &v100, v58);
    }
LABEL_133:
    sub_4FC1C(&v100);
    v60 = v5;
    v5 = (char *)v7;
    free(v60);
  }
}
// 4FFE8: control flows out of bounds to 4FFEC
// 4FDC4: variable 'v4' is possibly undefined
// 50540: variable 'v61' is possibly undefined
// 50540: variable 'v62' is possibly undefined
// 505B8: variable 'v65' is possibly undefined
// 50650: variable 'v70' is possibly undefined
// 50764: variable 'v77' is possibly undefined
// 7D808: using guessed type int dword_7D808;
// 7D80C: using guessed type int dword_7D80C;
// 7D814: using guessed type _DWORD *dword_7D814;
// 7D81C: using guessed type int dword_7D81C;
// 7D820: using guessed type int dword_7D820;
// 7D824: using guessed type int dword_7D824;

//----- (0005085C) --------------------------------------------------------
int __fastcall sub_5085C(int a1, int a2)
{
  const char *v3; // r0
  int v4; // r5
  char v6; // r0
  tcflag_t (*v7)(); // r2
  tcflag_t c_oflag; // r3
  int v9; // r7
  char v10; // r8
  int v11; // r9
  const char **v12; // r5
  const char *v13; // r0
  const char *v14; // r0
  int v15; // r0
  int v16; // r1
  int v17; // r2
  FILE *v18; // r11
  char *v19; // r0
  const char *v20; // r0
  int v21; // r1
  int v22; // r2
  const char *v23; // t1
  int v24; // r11
  int v25; // r0
  int v26; // r1
  int v27; // r2
  char *v28; // r11
  _DWORD *i; // r3
  char *ptr; // [sp+14h] [bp-80h]
  _DWORD *v31; // [sp+1Ch] [bp-78h] BYREF
  _DWORD *v32; // [sp+20h] [bp-74h] BYREF
  const char *v33[27]; // [sp+24h] [bp-70h] BYREF

  dword_7D810 = (int)&dword_7D80C;
  v3 = *(const char **)(a2 + 4);
  if ( !v3 || (v4 = strcmp(v3, "--version")) != 0 )
  {
    v33[0] = 0;
    v32 = 0;
    v31 = 0;
    v6 = sub_593F8((char **)a2, "^i::rEne:*f:*", "in-place", v33, &v31, &v32, &buf);
    c_oflag = (tcflag_t)&optind;
    v9 = v6 & 1;
    if ( (v6 & 1) != 0 )
      v7 = sub_4F18C;
    v10 = v6;
    v11 = optind;
    if ( (v6 & 1) != 0 )
    {
      c_oflag = (tcflag_t)&off_7DB9C;
      off_7DB9C = (int (*)(void))v7;
    }
    if ( (v6 & 6) != 0 )
      c_oflag = buf.c_oflag;
    v12 = (const char **)(a2 + 4 * optind);
    if ( (v6 & 6) != 0 )
      buf.c_oflag = c_oflag | 1;
    while ( v31 )
    {
      v14 = (const char *)sub_5D2FC(&v31);
      sub_4FAD0(v14);
    }
    while ( v32 )
    {
      v15 = sub_5D2FC(&v32);
      v18 = (FILE *)sub_61D20(v15);
      while ( 1 )
      {
        v19 = sub_58D24(v18, v16, v17);
        if ( !v19 )
          break;
        ptr = v19;
        sub_4F4E8(v19);
        free(ptr);
      }
      sub_5888C(v18);
    }
    if ( (v10 & 0x30) == 0 )
    {
      v13 = *(const char **)(a2 + 4 * v11);
      if ( !v13 )
        sub_162F0();
      ++v12;
      sub_4FAD0(v13);
    }
    sub_4F4E8("");
    *(_DWORD *)&buf.c_cc[15] = v12;
    buf.c_cflag = stdout;
    if ( *v12 )
    {
      while ( 1 )
      {
        v20 = *v12;
        if ( v9 )
        {
          if ( sub_62DFC() )
          {
            sub_16B80(*v12);
            v22 = 1;
            buf.c_cc[4] = 0;
            buf.c_cc[5] = 0;
            buf.c_cc[6] = 0;
            buf.c_cc[3] = 1;
            ++*(_DWORD *)&buf.c_cc[7];
          }
          else
          {
            buf.c_lflag = (tcflag_t)sub_177E4("%sXXXXXX", *v12);
            v24 = sub_17778((const char *)buf.c_lflag);
            buf.c_cflag = (tcflag_t)sub_61CCC(v24);
            fchmod(v24, (__mode_t)v33[5]);
            v25 = fchown(v24, (__uid_t)v33[7], (__gid_t)v33[8]);
            sub_4FD84(v25, v26, v27);
            fclose((FILE *)buf.c_cflag);
            buf.c_cflag = stdout;
            if ( v33[0] )
            {
              v28 = sub_177E4("%s%s", *v12, v33[0]);
              sub_17640(*v12, v28);
              free(v28);
            }
            sub_17640((const char *)buf.c_lflag, *v12);
            free((void *)buf.c_lflag);
            buf.c_lflag = 0;
            for ( i = (_DWORD *)dword_7D80C; i; i = (_DWORD *)*i )
            {
              i[4] = i[5];
              v22 = i[7];
              i[6] = v22;
            }
          }
        }
        else if ( *v20 == 45 && !v20[1] )
        {
          *v12 = "standard input";
          sub_4FD84((int)v20, v21, v22);
        }
        v23 = v12[1];
        ++v12;
        if ( !v23 )
          break;
        ++*(_DWORD *)&buf.c_cc[11];
      }
    }
    else
    {
      if ( v9 )
        sub_16DBC("%s requires an argument", "-i");
      *v12 = "standard input";
    }
    sub_4FD84((int)v20, v21, v22);
    return *(_DWORD *)&buf.c_cc[3];
  }
  else
  {
    puts("This is not GNU sed version 4.0");
  }
  return v4;
}
// 508F4: variable 'v7' is possibly undefined
// 50960: variable 'v16' is possibly undefined
// 50960: variable 'v17' is possibly undefined
// 509F0: variable 'v21' is possibly undefined
// 509F0: variable 'v22' is possibly undefined
// 50A2C: variable 'v20' is possibly undefined
// 50AB4: variable 'v26' is possibly undefined
// 50AB4: variable 'v27' is possibly undefined
// 7D604: using guessed type int optind;
// 7D614: using guessed type int stdout;
// 7D80C: using guessed type int dword_7D80C;
// 7D810: using guessed type int dword_7D810;
// 7DB9C: using guessed type int (*off_7DB9C)(void);

//----- (00050B80) --------------------------------------------------------
unsigned int sub_50B80()
{
  int i; // r1
  unsigned __int8 *v1; // r3
  unsigned int result; // r0
  bool v3; // cc
  bool v4; // r2
  _BOOL4 v5; // r2

  for ( i = dword_7DB98; ; *(_DWORD *)(i + 8) = v1 + 1 )
  {
    v1 = *(unsigned __int8 **)(i + 8);
    result = *v1;
    v3 = result > 0x20;
    if ( result != 32 )
      v3 = result - 9 > 4;
    v4 = !v3;
    v5 = result != 10 && v4;
    if ( !v5 || (unsigned int)v1 >= *(_DWORD *)(i + 4) - 1 )
      break;
  }
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00050BD8) --------------------------------------------------------
int sub_50BD8()
{
  int v0; // r4
  int result; // r0

  v0 = dword_7DB98;
  result = sub_17364(0, (struct termios *)(dword_7DB98 + 116), 6);
  *(_BYTE *)(v0 + 100) = *(_BYTE *)(v0 + 135);
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00050C04) --------------------------------------------------------
void *sub_50C04()
{
  return memset(*(void **)(dword_7DB98 + 84), 32, *(_DWORD *)(dword_7DB98 + 88));
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00050C20) --------------------------------------------------------
char *__fastcall sub_50C20(char *src, signed int a2)
{
  char *v3; // r5
  int *v5; // r4
  void *v6; // r0
  int v7; // r2
  unsigned int v8; // r3
  size_t v9; // r1
  char *v10; // r0
  int v11; // r5
  int v12; // r3

  if ( a2 <= 0 )
    return 0;
  v5 = (int *)dword_7DB98;
  v6 = *(void **)dword_7DB98;
  v7 = *(_DWORD *)(dword_7DB98 + 12);
  v8 = *(_DWORD *)(dword_7DB98 + 4) + a2;
  *(_DWORD *)(dword_7DB98 + 4) = v8;
  if ( v8 >= (unsigned int)v6 + v7 )
  {
    v9 = v8 - (_DWORD)v6 + 10240;
    v5[3] = v9;
    v10 = (char *)sub_174B4(v6, v9);
    v11 = *v5;
    v12 = v5[20];
    *v5 = (int)v10;
    v3 = &v10[-v11];
    src = &v3[(_DWORD)src];
    v5[20] = (int)&v3[v12];
    v5[2] += (int)v3;
    v5[1] += (int)v3;
  }
  else
  {
    v3 = 0;
  }
  memmove(&src[a2], src, v5[1] - a2 - (_DWORD)src);
  memset(src, 32, a2);
  return v3;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00050CDC) --------------------------------------------------------
int __fastcall sub_50CDC(int result, size_t a2, int a3)
{
  unsigned __int8 *v3; // r6
  size_t v4; // r7
  char v5; // r5
  int *v6; // r8
  char *v7; // r4
  bool v8; // zf
  int v9; // r2
  char v10; // r5
  unsigned __int8 *v11; // r6
  int v12; // r2
  int v13; // r8
  int v14; // r4
  int v15; // r3
  int v16; // r3
  int v17; // r3
  int v18; // r4
  int v19; // r3

  v3 = (unsigned __int8 *)result;
  v4 = a2;
  v5 = a3;
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        return result;
      v13 = dword_7DB98;
      v14 = dword_7DB98 + 4096;
      while ( 1 )
      {
        v15 = *(unsigned __int8 *)(v14 + 596);
        if ( v15 == 1 )
          break;
        if ( *(_BYTE *)(v14 + 596) )
        {
          if ( v15 != 64 )
            goto LABEL_5;
          *(_BYTE *)(v14 + 596) = 1;
          break;
        }
        sub_50F44();
      }
      v16 = *(_DWORD *)(v14 + 600);
      *(_DWORD *)(v14 + 604) = v3;
      v17 = v16 + 1;
      *(_DWORD *)(v14 + 600) = v17;
      result = *v3;
      *(_BYTE *)(v13 + 256 - v17 + 4704) = result;
      break;
    case 64:
      return result;
    case 4:
      if ( a2 != 1 )
        return result;
      v18 = dword_7DB98 + 4096;
      while ( 1 )
      {
        v19 = *(unsigned __int8 *)(v18 + 596);
        if ( v19 != 1 )
          break;
        result = sub_50F44();
      }
      if ( *(_BYTE *)(v18 + 596) )
      {
        if ( v19 != 64 )
        {
LABEL_5:
          v6 = (int *)dword_7DB98;
          if ( (v5 & 0xFD) == 1 )
          {
            if ( *(unsigned __int8 **)(dword_7DB98 + 4) == &v3[v4] )
              --v4;
            v7 = (char *)sub_174DC(v4 + 13);
            result = (int)memcpy(v7 + 13, v3, v4);
          }
          else
          {
            result = (int)sub_174DC(0x10u);
            v7 = (char *)result;
          }
          v8 = (v5 & 0x20) == 0;
          v9 = *v6;
          v10 = v5 & 0xDF;
          if ( !v8 )
            v3 = (unsigned __int8 *)v6[1175];
          v7[12] = v10;
          *((_DWORD *)v7 + 2) = v4;
          v11 = &v3[-v9];
          v12 = v6[1240];
          *((_DWORD *)v7 + 1) = v11;
          *(_DWORD *)v7 = v12;
          v6[1240] = (int)v7;
          ++v6[7];
          return result;
        }
        *(_DWORD *)(v18 + 604) = v3;
        *(_BYTE *)(v18 + 596) = 0;
      }
      v17 = *(_DWORD *)(v18 + 600) + 1;
      *(_DWORD *)(v18 + 600) = v17;
      break;
    default:
      goto LABEL_5;
  }
  if ( v17 == 256 )
    return sub_50F44();
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00050E58) --------------------------------------------------------
void *__fastcall sub_50E58(char *dest, unsigned int a2, int a3)
{
  void *v3; // r6
  char *v4; // r7
  unsigned int *v5; // r5
  int v6; // r4
  size_t v7; // r8
  unsigned int v8; // r0
  unsigned int v9; // r1
  bool v10; // cc
  unsigned int v11; // r2
  int v12; // r3
  void *v13; // r3
  unsigned int v14; // r4

  if ( a2 < (unsigned int)dest )
  {
    v4 = dest + 1;
    v3 = (void *)a2;
  }
  else
  {
    v4 = (char *)(a2 + 1);
  }
  if ( a2 >= (unsigned int)dest )
    v3 = dest;
  v5 = (unsigned int *)dword_7DB98;
  v6 = a2 - (_DWORD)dest + 1;
  v7 = *(_DWORD *)(dword_7DB98 + 4) - (_DWORD)v4;
  switch ( a3 )
  {
    case 2:
      a3 = 3;
      break;
    case 3:
      a3 = 5;
      break;
    case 1:
      break;
    default:
      goto LABEL_10;
  }
  sub_50CDC((int)dest, a2 - (_DWORD)dest + 1, a3);
LABEL_10:
  v8 = *v5;
  v9 = v5[7];
  v10 = *v5 > (unsigned int)v4;
  v5[7] = v9 - 1;
  if ( !v10 )
  {
    v11 = v5[1];
    v12 = v11 < (unsigned int)v4;
    if ( v8 > (unsigned int)v3 )
      v12 = 1;
    if ( v11 <= (unsigned int)v3 )
      v12 |= 1u;
    if ( !v12 )
    {
      v5[7] = v9;
      if ( v11 > (unsigned int)v4 )
        memmove(v3, v4, v7);
      v13 = (void *)*v5;
      v14 = v5[1] - v6;
      v5[1] = v14;
      if ( v14 <= (unsigned int)v3 )
        v3 = (void *)(v14 - 1);
      if ( v14 <= (unsigned int)v13 )
      {
        v3 = v13;
        v5[1] = (unsigned int)v13;
      }
    }
  }
  return v3;
}
// 50ED4: variable 'v3' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (00050F44) --------------------------------------------------------
int sub_50F44()
{
  int result; // r0
  int v1; // r4
  int v2; // r1

  result = dword_7DB98;
  v1 = dword_7DB98 + 4096;
  v2 = *(_DWORD *)(dword_7DB98 + 4696);
  if ( v2 > 0 )
  {
    result = sub_50CDC(dword_7DB98 - v2 + 4960, v2, *(unsigned __int8 *)(dword_7DB98 + 4692) | 0x20);
    *(_BYTE *)(v1 + 596) = 64;
    *(_DWORD *)(v1 + 600) = 0;
  }
  return result;
}
// 50CDC: using guessed type int __fastcall sub_50CDC(_DWORD, _DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (00050F90) --------------------------------------------------------
int sub_50F90()
{
  int result; // r0
  unsigned int v1; // r3

  result = sub_50F44();
  v1 = *(_DWORD *)(dword_7DB98 + 8);
  if ( v1 > *(_DWORD *)dword_7DB98 && *(_BYTE *)(v1 - 1) != 10 )
    *(_DWORD *)(dword_7DB98 + 8) = v1 - 1;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00050FC8) --------------------------------------------------------
int sub_50FC8()
{
  int result; // r0
  _BYTE *v1; // r3

  result = sub_50F44();
  v1 = *(_BYTE **)(dword_7DB98 + 8);
  if ( (unsigned int)v1 < *(_DWORD *)(dword_7DB98 + 4) - 1 && *v1 != 10 )
    *(_DWORD *)(dword_7DB98 + 8) = v1 + 1;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051000) --------------------------------------------------------
char *sub_51000(const char *a1, ...)
{
  int v1; // r4
  char *v2; // r5
  char *result; // r0
  va_list varg_r1; // [sp+1Ch] [bp+10h] BYREF

  va_start(varg_r1, a1);
  v1 = dword_7DB98;
  v2 = (char *)(dword_7DB98 + 204);
  strcpy((char *)(dword_7DB98 + 204), "\x1B[7m");
  vsprintf((char *)(v1 + 208), a1, varg_r1);
  result = strcat(v2, "\x1B[m");
  *(_DWORD *)(v1 + 68) = 8;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051068) --------------------------------------------------------
char *__fastcall sub_51068(const char *a1)
{
  char *v1; // r3
  const char *v2; // r5
  const char *v3; // r5
  unsigned int v4; // r10
  unsigned int v5; // t1
  unsigned int v6; // r2
  char *v7; // r0
  bool v8; // cc
  char *v9; // r4
  char v11[128]; // [sp+0h] [bp-84h] BYREF

  v11[0] = 0;
  v1 = v11;
  v2 = "(NULL)";
  if ( *a1 )
    v2 = a1;
  v3 = v2 - 1;
  do
  {
    v5 = *(unsigned __int8 *)++v3;
    v4 = v5;
    if ( !v5 )
      break;
    if ( (v4 & 0x80u) != 0 )
    {
      v7 = strcpy(v1, "\x1B[m");
      v6 = 46;
      v1 = v7 + 3;
    }
    else
    {
      v6 = v4;
    }
    v8 = v6 > 0x7F;
    if ( v6 != 127 )
      v8 = v6 > 0x1F;
    v9 = v1 + 1;
    if ( v8 )
    {
      v9 = v1;
    }
    else
    {
      *v1 = 94;
      v6 = (unsigned __int8)v6 | 0x40;
      if ( v6 == 127 )
        LOBYTE(v6) = 63;
    }
    *v9 = v6;
    v1 = v9 + 1;
    v9[1] = 0;
    if ( (v4 & 0x80u) == 0 )
    {
      if ( v4 == 10 )
      {
        v1 = v9 + 2;
        v9[1] = 36;
        v9[2] = 0;
      }
    }
    else
    {
      strcpy(v9 + 1, "\x1B[7m");
      v1 = v9 + 5;
    }
  }
  while ( v1 - v11 <= 118 );
  return sub_51000("'%s' is not implemented", v11);
}

//----- (00051168) --------------------------------------------------------
int sub_51168(const char *a1, ...)
{
  int v1; // r4
  int result; // r0
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  v1 = dword_7DB98;
  result = vsprintf((char *)(dword_7DB98 + 204), a1, varg_r1);
  *(_DWORD *)(v1 + 68) = 1;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000511A8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_511A8(unsigned __int8 *a1, int a2, int a3, int a4)
{
  _DWORD *v8; // r8
  unsigned int v9; // r1
  unsigned int v10; // r4
  bool v11; // cc
  int v12; // r0
  bool v14; // cc
  bool v15; // cc

  v8 = (_DWORD *)dword_7DB98;
  while ( 1 )
  {
    v9 = *a1;
    v10 = a1[a3];
    switch ( a4 )
    {
      case 1:
        v11 = v10 > 0x20;
        if ( v10 != 32 )
          v11 = v10 - 9 > 4;
        if ( v11 )
          goto LABEL_8;
        v12 = v10 == 10;
LABEL_7:
        if ( !v12 )
          return a1;
LABEL_8:
        if ( v10 == 10 )
        {
          if ( a2 == 1 )
            return a1;
          a2 = 1;
        }
        goto LABEL_11;
      case 2:
        v14 = v9 > 0x20;
        if ( v9 != 32 )
          v14 = v9 - 9 > 4;
        if ( v14 )
          goto LABEL_11;
        v12 = v9 == 10;
        goto LABEL_21;
      case 3:
        v15 = v9 > 0x20;
        if ( v9 != 32 )
          v15 = v9 - 9 > 4;
        v12 = !v15;
LABEL_21:
        v10 = *a1;
        goto LABEL_7;
      case 4:
        v12 = *(unsigned __int8 *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", a1[a3]);
        goto LABEL_7;
    }
    if ( a4 != 5 )
      return a1;
    if ( v10 - 48 > 9 )
    {
      if ( (v10 | 0x20) - 97 <= 0x19 )
        goto LABEL_8;
      if ( v10 != 95 )
        return a1;
    }
LABEL_11:
    if ( a3 == -1 ? *v8 >= (unsigned int)a1 : (unsigned int)a1 >= v8[1] - 1 )
      return a1;
    a1 += a3;
  }
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DB98: using guessed type int dword_7DB98;

//----- (000512E4) --------------------------------------------------------
int __fastcall sub_512E4(unsigned int a1)
{
  int v1; // r4
  int v2; // r0

  v1 = *(_DWORD *)dword_7DB98;
  if ( *(_DWORD *)dword_7DB98 >= a1 )
    return a1;
  v2 = memrchr(*(_DWORD *)dword_7DB98, 10, a1 - v1);
  if ( v2 )
    return v2 + 1;
  return v1;
}
// 13BE0: using guessed type int __fastcall memrchr(_DWORD, _DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (00051324) --------------------------------------------------------
int __fastcall sub_51324(unsigned int a1)
{
  unsigned int v1; // r0

  v1 = sub_512E4(a1);
  if ( *(_DWORD *)dword_7DB98 < v1 && *(_BYTE *)(v1 - 1) == 10 )
    --v1;
  return sub_512E4(v1);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051358) --------------------------------------------------------
int sub_51358()
{
  int v0; // r4
  int result; // r0

  sub_50F44();
  v0 = dword_7DB98;
  result = sub_51324(*(_DWORD *)(dword_7DB98 + 8));
  *(_DWORD *)(v0 + 8) = result;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0005137C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5137C(unsigned int a1, int a2)
{
  int v3; // r5
  unsigned __int8 *v4; // r6
  int v5; // r7
  unsigned __int8 *result; // r0
  unsigned int v7; // r3
  unsigned int v8; // t1
  unsigned int v9; // r1
  unsigned int v10; // r4
  int v11; // r1
  int v12; // r1
  bool v13; // cc

  v3 = 0;
  v4 = (unsigned __int8 *)sub_512E4(a1);
  v5 = dword_7DB98;
  while ( 1 )
  {
    result = v4;
    if ( v3 >= a2 )
      break;
    if ( *(_DWORD *)(v5 + 4) <= (unsigned int)v4 )
      break;
    v8 = *v4++;
    v7 = v8;
    if ( v8 == 10 )
      break;
    if ( v7 == 9 )
    {
      v9 = *(_DWORD *)(v5 + 92);
      v10 = v9 - 1;
      sub_161AC(v3, v9);
      v12 = v10 - v11 + v3;
    }
    else
    {
      v13 = v7 > 0x7F;
      if ( v7 != 127 )
        v13 = v7 > 0x1F;
      v12 = v3 + 1;
      if ( v13 )
        v12 = v3;
    }
    v3 = v12 + 1;
  }
  return result;
}
// 513D4: variable 'v11' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (000513FC) --------------------------------------------------------
int sub_513FC()
{
  int v0; // r4
  int result; // r0

  sub_50F44();
  v0 = dword_7DB98;
  result = sub_512E4(*(_DWORD *)(dword_7DB98 + 8));
  *(_DWORD *)(v0 + 8) = result;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051420) --------------------------------------------------------
void *__fastcall sub_51420(const void *a1)
{
  int v1; // r3
  int v2; // r4
  void *v3; // r0

  v1 = *(_DWORD *)(dword_7DB98 + 4);
  v2 = v1 - 1;
  if ( v1 - 1 <= (unsigned int)a1 )
    return (void *)a1;
  v3 = memchr(a1, 10, v1 - (_DWORD)a1 - 1);
  if ( v3 )
    return v3;
  return (void *)v2;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051464) --------------------------------------------------------
_BYTE *__fastcall sub_51464(const void *a1)
{
  _BYTE *result; // r0

  result = sub_51420(a1);
  if ( (unsigned int)result < *(_DWORD *)(dword_7DB98 + 4) - 1 && *result == 10 )
    ++result;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051498) --------------------------------------------------------
_BYTE *__fastcall sub_51498(int a1)
{
  _BYTE *result; // r0

  result = *(_BYTE **)dword_7DB98;
  while ( a1 > 1 )
  {
    result = sub_51464(result);
    --a1;
  }
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000514C4) --------------------------------------------------------
char *__fastcall sub_514C4(char *a1, char *s, int a3, int a4)
{
  size_t v8; // r6
  char *v9; // r5
  unsigned int v11; // r5

  v8 = strlen(s);
  if ( a3 == 1 )
  {
    v9 = (char *)(*(_DWORD *)(dword_7DB98 + 4) - 1);
    if ( !a4 )
      v9 = sub_51464(a1);
    while ( a1 < v9 )
    {
      if ( !strncmp(a1, s, v8) )
        return a1;
      ++a1;
    }
  }
  else if ( a3 == -1 )
  {
    v11 = *(_DWORD *)dword_7DB98;
    if ( !a4 )
      v11 = sub_51324((unsigned int)a1);
    for ( a1 -= v8; (unsigned int)a1 >= v11; --a1 )
    {
      if ( !strncmp(a1, s, v8) )
        return a1;
    }
  }
  return 0;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0005159C) --------------------------------------------------------
_BYTE *sub_5159C()
{
  int v0; // r4
  _BYTE *result; // r0

  sub_50F44();
  v0 = dword_7DB98;
  result = sub_51464(*(const void **)(dword_7DB98 + 8));
  *(_DWORD *)(v0 + 8) = result;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000515C0) --------------------------------------------------------
int __fastcall sub_515C0(const void *a1, const void *a2, int a3, const void *a4)
{
  const void *v4; // r4
  int v5; // r5
  void *v6; // r7
  int v7; // r6
  _BYTE *v9; // r0

  if ( a2 < a1 )
    a4 = a1;
  v4 = a1;
  if ( a2 < a1 )
  {
    v4 = a2;
    a2 = a4;
  }
  v5 = 0;
  v6 = sub_51420(a2);
  v7 = dword_7DB98;
  while ( v4 <= v6 && (unsigned int)v4 <= *(_DWORD *)(v7 + 4) - 1 )
  {
    v9 = sub_51420(v4);
    v4 = v9 + 1;
    if ( *v9 == 10 )
      ++v5;
  }
  return v5;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051630) --------------------------------------------------------
const char *__fastcall sub_51630(const char *a1, int *a2, int a3)
{
  const char *v4; // r4
  int v5; // r1
  const void **v6; // r6
  unsigned int v7; // r0
  const void *v8; // r0
  int v9; // r2
  const void *v10; // r3
  char *v11; // r6
  char *v12; // r1
  char *v13; // r6
  const void **v14; // r7
  char *v15; // r1
  int v16; // r2
  const void *v17; // r3
  int *v19; // [sp+4h] [bp-8h] BYREF
  int v20; // [sp+8h] [bp-4h]

  v19 = a2;
  v20 = a3;
  *a2 = -1;
  v4 = a1;
  v5 = *(unsigned __int8 *)a1;
  switch ( v5 )
  {
    case '.':
      v4 = a1 + 1;
      v6 = (const void **)dword_7DB98;
      v7 = *(_DWORD *)(dword_7DB98 + 8);
LABEL_3:
      v8 = (const void *)sub_512E4(v7);
      *a2 = sub_515C0(*v6, v8, v9, v10);
      return v4;
    case '/':
      v11 = (char *)(a1 + 1);
      v4 = (const char *)strchrnul(a1 + 1);
      v12 = (char *)sub_1751C(v11, v4 - v11);
      v13 = v12;
      if ( *v4 == 47 )
        ++v4;
      v14 = (const void **)dword_7DB98;
      v15 = sub_514C4(*(char **)(dword_7DB98 + 8), v12, 1, 1);
      if ( v15 )
        *a2 = sub_515C0(*v14, v15, v16, v17);
      free(v13);
      break;
    case '$':
      v4 = a1 + 1;
      v6 = (const void **)dword_7DB98;
      v7 = *(_DWORD *)(dword_7DB98 + 4) - 1;
      goto LABEL_3;
    default:
      if ( (unsigned int)(v5 - 48) <= 9 )
      {
        sscanf(a1, "%d%n", a2, &v19);
        return (char *)v19 + (_DWORD)v4;
      }
      break;
  }
  return v4;
}
// 5166C: variable 'v9' is possibly undefined
// 5166C: variable 'v10' is possibly undefined
// 516D4: variable 'v16' is possibly undefined
// 516D4: variable 'v17' is possibly undefined
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DB98: using guessed type int dword_7DB98;

//----- (00051740) --------------------------------------------------------
void *sub_51740()
{
  unsigned int v0; // r5
  _BYTE *v1; // r0
  unsigned int v2; // r4

  v0 = 0;
  v1 = *(_BYTE **)(dword_7DB98 + 80);
  v2 = *(_DWORD *)(dword_7DB98 + 44) - 2;
  while ( v0 < v2 )
  {
    v1 = sub_51464(v1);
    ++v0;
  }
  return sub_51420(v1);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (0005177C) --------------------------------------------------------
unsigned int __fastcall sub_5177C(int a1, int a2)
{
  int v4; // r4
  const void *v5; // r0
  void *v6; // r0
  _BYTE *v8; // r0

  sub_50F44();
  v4 = dword_7DB98;
  while ( 1 )
  {
    v5 = *(const void **)(v4 + 80);
    if ( a1 <= 0 )
      break;
    if ( a2 == -1 )
      v8 = (_BYTE *)sub_51324((unsigned int)v5);
    else
      v8 = sub_51464(v5);
    *(_DWORD *)(v4 + 80) = v8;
    --a1;
  }
  if ( *(_DWORD *)(v4 + 8) < (unsigned int)v5 )
    *(_DWORD *)(v4 + 8) = v5;
  v6 = sub_51740();
  if ( *(_DWORD *)(v4 + 8) > (unsigned int)v6 )
    *(_DWORD *)(v4 + 8) = sub_512E4((unsigned int)v6);
  return sub_50B80();
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000517F0) --------------------------------------------------------
void *sub_517F0()
{
  int v0; // r4
  void *result; // r0

  sub_50F44();
  v0 = dword_7DB98;
  result = sub_51420(*(const void **)(dword_7DB98 + 8));
  *(_DWORD *)(v0 + 8) = result;
  return result;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051814) --------------------------------------------------------
int __fastcall sub_51814(int a1, char *a2, int a3)
{
  ssize_t v3; // r4
  int v7; // r0
  int v8; // r6
  size_t v9; // r5
  int v10; // r1

  if ( a1 )
  {
    v7 = open64(a1, 65);
    v8 = v7;
    if ( v7 >= 0 )
    {
      v9 = a3 - (_DWORD)a2 + 1;
      v3 = sub_17FB8(v7, a2, v9);
      ftruncate64(v8, v10, v3, v3 >> 31);
      if ( v9 != v3 )
        v3 = 0;
      close(v8);
    }
    else
    {
      return -1;
    }
  }
  else
  {
    v3 = -2;
    sub_51000("No current filename");
  }
  return v3;
}
// 51878: variable 'v10' is possibly undefined
// 136FC: using guessed type int __fastcall ftruncate64(_DWORD, _DWORD, _DWORD, _DWORD);
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00051894) --------------------------------------------------------
int sub_51894()
{
  sub_177D8();
  return sub_1729C((struct termios *)(dword_7DB98 + 116));
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000518B4) --------------------------------------------------------
int __fastcall sub_518B4(int a1)
{
  return fputs_unlocked(a1, stdout);
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;

//----- (000518C4) --------------------------------------------------------
int __fastcall sub_518C4(int a1, int a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r3
  unsigned int v4; // r3
  unsigned int v5; // r1
  unsigned int v6; // r2
  char s[40]; // [sp+4h] [bp-28h] BYREF

  v2 = a1 & ~(a1 >> 31);
  v3 = *(_DWORD *)(dword_7DB98 + 44);
  if ( v3 <= v2 )
    v2 = v3 - 1;
  v4 = a2 & ~(a2 >> 31);
  v5 = *(_DWORD *)(dword_7DB98 + 48);
  v6 = v2 + 1;
  if ( v5 <= v4 )
    v4 = v5 - 1;
  sprintf(s, "\x1B[%u;%uH", v6, v4 + 1);
  return sub_518B4((int)s);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051920) --------------------------------------------------------
int sub_51920()
{
  sub_518C4(*(_DWORD *)(dword_7DB98 + 44) - 1, 0);
  return sub_518B4((int)"\x1B[K");
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00051950) --------------------------------------------------------
int sub_51950()
{
  char *v0; // r4
  int result; // r0

  sub_177D8();
  v0 = (char *)(dword_7DB98 + 188);
  while ( 1 )
  {
    result = sub_60068(0, v0, -1);
    if ( result != -1 )
      break;
    if ( *(_DWORD *)dword_7DB94 != 11 )
    {
      sub_51920();
      sub_51894();
      sub_16DBC("can't read user input");
    }
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;
// 7DB98: using guessed type int dword_7DB98;

//----- (000519AC) --------------------------------------------------------
char *__fastcall sub_519AC(char *result, char *dest, int a3)
{
  char *v3; // r3
  char *i; // r3

  if ( result > dest )
  {
    v3 = result;
    result = dest;
    dest = v3;
  }
  if ( a3 > 0 )
    return (char *)sub_50E58(result, (unsigned int)dest, 1);
  if ( *result != 10 )
  {
    for ( i = result; i + 1 <= dest; ++i )
    {
      if ( i[1] == 10 )
      {
        dest = i;
        return (char *)sub_50E58(result, (unsigned int)dest, 1);
      }
    }
    return (char *)sub_50E58(result, (unsigned int)dest, 1);
  }
  return result;
}

//----- (00051A00) --------------------------------------------------------
int __fastcall sub_51A00(const char *a1, char *a2, int a3)
{
  char *v5; // r4
  int v6; // r10
  int v7; // r5
  const char *v8; // r1
  const char *v9; // r0
  signed int v11; // r6
  char *v12; // r4
  ssize_t v13; // r0
  __int16 v14; // [sp+10h] [bp-58h]
  __int64 v15; // [sp+30h] [bp-38h]

  v5 = *(char **)dword_7DB98;
  if ( *(_DWORD *)dword_7DB98 < (unsigned int)a2 )
    v5 = a2;
  if ( (unsigned int)v5 >= *(_DWORD *)(dword_7DB98 + 4) )
    v5 = *(char **)(dword_7DB98 + 4);
  v6 = open64(a1, 0);
  if ( v6 >= 0 )
  {
    if ( sub_62E08() >= 0 )
    {
      if ( (v14 & 0xF000) == 0x8000 )
      {
        v11 = v15;
        if ( v15 > 2147483646 )
          v11 = 0x7FFFFFFF;
        v12 = &sub_50C20(v5, v11)[(_DWORD)v5];
        v13 = sub_18050(v6, v12, v11);
        v7 = v13;
        if ( v13 >= 0 )
        {
          if ( v11 > v13 )
          {
            sub_50E58(&v12[v13], (unsigned int)&v12[v11 - 1], 0);
            sub_51000("can't read '%s'", a1);
          }
        }
        else
        {
          sub_51000("'%s' %m", a1);
          sub_50E58(v12, (unsigned int)&v12[v11 - 1], 0);
        }
        goto LABEL_14;
      }
      v9 = "'%s' is not a regular file";
      v8 = a1;
    }
    else
    {
      v8 = a1;
      v9 = "'%s' %m";
    }
    v7 = -1;
    sub_51000(v9, v8);
LABEL_14:
    close(v6);
    return v7;
  }
  if ( !a3 )
    sub_51000("'%s' %m", a1);
  return -1;
}
// 51A78: variable 'v14' is possibly undefined
// 51AA8: variable 'v15' is possibly undefined
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (00051B48) --------------------------------------------------------
unsigned __int8 *__fastcall sub_51B48(unsigned __int8 *a1, unsigned int *a2, _DWORD *a3)
{
  unsigned __int8 *v6; // r0
  int v7; // r2
  unsigned __int8 *v8; // r7
  int v9; // r4
  unsigned __int8 *v10; // r1
  unsigned int v11; // r5
  unsigned int v12; // r0
  int i; // r6
  unsigned __int8 *result; // r0
  unsigned int j; // r11
  bool v16; // cc
  unsigned __int8 *v17; // r6
  int k; // r5
  int v19; // r3
  int v20; // r3
  unsigned __int8 *v21; // r0
  int v22; // r2
  const void *v23; // r3
  signed int v24; // r11
  signed int v25; // r6
  unsigned int v26; // r3
  unsigned int v27; // t1
  unsigned int v28; // r1
  int v29; // r1
  int v30; // r1
  bool v31; // cc
  unsigned int v32; // [sp+4h] [bp-8h]

  v6 = (unsigned __int8 *)sub_512E4((unsigned int)a1);
  v8 = v6;
  v9 = dword_7DB98;
  v10 = *(unsigned __int8 **)(dword_7DB98 + 80);
  v11 = *(_DWORD *)(dword_7DB98 + 44) - 1;
  if ( v10 <= v6 )
  {
    v21 = (unsigned __int8 *)sub_51740();
    if ( v8 <= v21 )
      goto LABEL_5;
    v12 = sub_515C0(v21, v8, v22, v23);
    if ( v12 <= v11 >> 1 )
    {
      v24 = 0;
      v25 = v12 - 1;
      while ( v25 > v24 )
      {
        ++v24;
        *(_DWORD *)(v9 + 80) = sub_51464(*(const void **)(v9 + 80));
      }
      goto LABEL_5;
    }
  }
  else
  {
    v12 = sub_515C0(v6, v10, v7, &dword_7DB98);
  }
  *(_DWORD *)(v9 + 80) = v8;
  if ( v11 >> 1 < v12 )
  {
    for ( i = 0; i != v11 >> 1; ++i )
      *(_DWORD *)(v9 + 80) = sub_51324(*(_DWORD *)(v9 + 80));
  }
LABEL_5:
  result = *(unsigned __int8 **)(v9 + 80);
  for ( j = 0; ; ++j )
  {
    v16 = result > v8;
    if ( result != v8 )
      v16 = v11 > j;
    if ( !v16 )
      break;
    result = sub_51464(result);
  }
  v17 = result;
  for ( k = 0; a1 > v17; k = v30 + 1 )
  {
    v27 = *v17++;
    v26 = v27;
    if ( v27 == 10 )
      break;
    if ( v26 == 9 )
    {
      v28 = *(_DWORD *)(v9 + 92);
      v32 = v28 - 1;
      result = (unsigned __int8 *)sub_161AC(k, v28);
      v30 = v32 - v29 + k;
    }
    else
    {
      v31 = v26 > 0x7F;
      if ( v26 != 127 )
        v31 = v26 > 0x1F;
      v30 = k + 1;
      if ( v31 )
        v30 = k;
    }
  }
  v19 = *(_DWORD *)(v9 + 48);
  if ( *(_DWORD *)(v9 + 64) > k )
    *(_DWORD *)(v9 + 64) = k;
  if ( v19 + *(_DWORD *)(v9 + 64) <= (unsigned int)k )
    *(_DWORD *)(v9 + 64) = 1 - v19 + k;
  if ( a1 == v8 && *a1 == 9 )
    *(_DWORD *)(v9 + 64) = 0;
  v20 = *(_DWORD *)(v9 + 64);
  *a2 = j;
  *a3 = k - v20;
  return result;
}
// 51B7C: variable 'v7' is possibly undefined
// 51C3C: variable 'v22' is possibly undefined
// 51C3C: variable 'v23' is possibly undefined
// 51CA4: variable 'v29' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (00051CCC) --------------------------------------------------------
int __fastcall sub_51CCC(int a1)
{
  unsigned int v1; // r9
  _DWORD *v2; // r4
  unsigned __int8 *v3; // r8
  int result; // r0
  signed int v5; // r7
  _DWORD *v6; // r6
  unsigned __int8 *v7; // r1
  unsigned int v8; // r2
  unsigned int v9; // r5
  unsigned int v10; // r3
  unsigned int v11; // r0
  char *v12; // r6
  unsigned int v13; // r0
  unsigned int v14; // r5
  char *v15; // r0
  int v16; // r5
  int v17; // r2
  int v18; // r7
  int v19; // r5
  int j; // r10
  int v21; // r3
  int v22; // r1
  unsigned __int8 *v23; // r3
  bool v24; // cc
  _BYTE *i; // r5
  bool v26; // zf
  unsigned int v27; // r1
  unsigned int v28; // r10
  int v29; // r1
  size_t v30; // r10
  signed int v31; // r11
  signed int v32; // r2
  void *v33; // r5
  size_t v34; // r7
  unsigned __int8 *v36; // [sp+8h] [bp-Ch]
  unsigned __int8 *v37; // [sp+Ch] [bp-8h]

  v1 = 0;
  v2 = (_DWORD *)dword_7DB98;
  sub_51B48(*(unsigned __int8 **)(dword_7DB98 + 8), (unsigned int *)(dword_7DB98 + 56), (_DWORD *)(dword_7DB98 + 60));
  v3 = (unsigned __int8 *)v2[20];
  while ( v2[11] - 1 > v1 )
  {
    v5 = v2[16];
    v6 = v2 + 133;
    v7 = v3;
    v8 = 0;
    LOBYTE(v9) = 126;
    while ( v8 < v2[12] + v2[23] )
    {
      if ( v2[1] <= (unsigned int)v7 )
      {
        v23 = v7;
      }
      else
      {
        v9 = *v7;
        v23 = v7 + 1;
        if ( v9 == 10 )
          break;
        if ( (v9 & 0x80) != 0 )
          v9 = 46;
        v24 = v9 > 0x7F;
        if ( v9 != 127 )
          v24 = v9 > 0x1F;
        if ( !v24 )
        {
          if ( v9 == 9 )
          {
            for ( i = (char *)v6 + v8; ; ++i )
            {
              v37 = v23;
              v27 = v2[23];
              v28 = v27 - 1;
              sub_161AC(i - (_BYTE *)v6, v27);
              v8 = i - (_BYTE *)v6;
              v23 = v37;
              if ( v29 == v28 )
                break;
              *i = 32;
            }
            LOBYTE(v9) = 32;
          }
          else
          {
            v26 = v9 == 127;
            if ( v9 != 127 )
              LOBYTE(v9) = v9 + 64;
            *((_BYTE *)v6 + v8++) = 94;
            if ( v26 )
              LOBYTE(v9) = 63;
          }
        }
      }
      v30 = v8 + 1;
      *((_BYTE *)v6 + v8) = v9;
      v31 = v2[23];
      v32 = (int)(v8 + 1) >= v5 ? v5 : v8 + 1;
      if ( v31 <= v32 )
      {
        v36 = v23;
        memmove(v2 + 133, (char *)v6 + v31, v30);
        v23 = v36;
        v8 = v30 - v31;
        v5 -= v31;
      }
      else
      {
        v8 = v30;
      }
      if ( v2[1] <= (unsigned int)v23 )
        break;
      v7 = v23;
    }
    v10 = v2[12];
    if ( (int)v8 >= v5 )
      v11 = v5;
    else
      v11 = v8;
    v12 = (char *)v6 + v11;
    v13 = v8 - v11;
    if ( v10 > v13 )
      memset(&v12[v13], 32, v10 - v13);
    v14 = v2[1];
    if ( (unsigned int)v3 < v14 )
    {
      v15 = (char *)memchr(v3, 10, v14 - (_DWORD)v3);
      if ( !v15 )
        v15 = (char *)(v14 - 1);
      v3 = (unsigned __int8 *)(v15 + 1);
    }
    v16 = v2[12];
    v17 = v16 - 1;
    v18 = v16 - 1;
    v19 = v2[21] + v1 * v16;
    if ( a1 )
    {
      v21 = v17;
      v22 = a1;
      j = 0;
    }
    else
    {
      for ( j = 0; ; ++j )
      {
        if ( j > v17 )
        {
          v21 = v17;
          v22 = 0;
          goto LABEL_48;
        }
        if ( v12[j] != *(_BYTE *)(v19 + j) )
          break;
      }
      v21 = v17;
      do
      {
        if ( v12[v21] != *(_BYTE *)(v19 + v21) )
          break;
        --v21;
      }
      while ( j <= v21 );
      v22 = 1;
LABEL_48:
      if ( v2[16] != v2[27] )
        v22 = 1;
    }
    if ( v21 >= (unsigned int)v17 )
      v21 = v17;
    if ( j > v21 )
      j = 0;
    else
      v18 = v21;
    if ( v22 )
    {
      v33 = (void *)(v19 + j);
      v34 = v18 - j + 1;
      memcpy(v33, &v12[j], v34);
      sub_518C4(v1, j);
      fwrite(v33, v34, 1u, (FILE *)stdout);
    }
    ++v1;
  }
  result = sub_518C4(v2[14], v2[15]);
  v2[27] = v2[16];
  return result;
}
// 51E6C: variable 'v29' is possibly undefined
// 7D614: using guessed type int stdout;
// 7DB98: using guessed type int dword_7DB98;

//----- (00051F9C) --------------------------------------------------------
char *__fastcall sub_51F9C(char *src, int a2, int a3)
{
  char *v3; // r4
  char *v5; // r7
  int v6; // r6
  int v7; // r2
  char v9; // r6
  _DWORD *v10; // r7
  bool v11; // zf
  bool v12; // zf
  int v13; // r2
  char *v14; // r0

  v3 = src;
  if ( a2 == 22 )
  {
    v5 = sub_50C20(src, 1);
    v5[(_DWORD)v3] = 94;
    v6 = (int)&v5[(_DWORD)v3];
    sub_51CCC(0);
    v5[(_DWORD)v3] = sub_51950();
    switch ( a3 )
    {
      case 2:
        v7 = 2;
        break;
      case 3:
        v7 = 4;
        break;
      case 1:
        v7 = 0;
        break;
      default:
        return (char *)(v6 + 1);
    }
    sub_50CDC(v6, 1u, v7);
    return (char *)(v6 + 1);
  }
  v9 = a2;
  v10 = (_DWORD *)dword_7DB98;
  if ( a2 == 27 )
  {
    *(_DWORD *)(dword_7DB98 + 24) = 0;
    sub_50F44();
    v10[10] = 0;
    v10[18] = 0;
    if ( *(v3 - 1) != 10 && v10[2] > *v10 )
      --v3;
    return v3;
  }
  if ( *(unsigned __int8 *)(dword_7DB98 + 100) != a2 )
  {
    v11 = a2 == 127;
    if ( a2 != 127 )
      v11 = a2 == 8;
    if ( !v11 )
    {
      v12 = a2 == 13;
      if ( a2 != 13 )
        v12 = a2 == 10;
      if ( v12 )
      {
        v9 = 10;
        sub_50F44();
      }
      switch ( a3 )
      {
        case 2:
          v13 = 2;
          break;
        case 3:
          v13 = 4;
          break;
        case 1:
          v13 = 0;
          break;
        default:
LABEL_32:
          v14 = sub_50C20(v3, 1);
          v14[(_DWORD)v3] = v9;
          return &v14[(_DWORD)v3 + 1];
      }
      sub_50CDC((int)v3, 1u, v13);
      goto LABEL_32;
    }
  }
  if ( *(_DWORD *)dword_7DB98 >= (unsigned int)src )
    return v3;
  return (char *)sub_50E58(src - 1, (unsigned int)(src - 1), 3);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00052108) --------------------------------------------------------
int __fastcall sub_52108(const char *a1)
{
  int v2; // r4
  void *v3; // r0
  char *v4; // r0
  int v5; // r6
  _DWORD *v6; // r0

  v2 = dword_7DB98;
  free(*(void **)dword_7DB98);
  *(_DWORD *)(v2 + 12) = 10240;
  v3 = sub_174DC(0x2800u);
  *(_DWORD *)v2 = v3;
  *(_DWORD *)(v2 + 4) = v3;
  *(_DWORD *)(v2 + 8) = v3;
  *(_DWORD *)(v2 + 80) = v3;
  v4 = *(char **)(v2 + 76);
  if ( v4 != a1 )
  {
    free(v4);
    *(_DWORD *)(v2 + 76) = sub_174F8(a1);
  }
  v5 = sub_51A00(a1, *(char **)v2, 1);
  if ( v5 < 0 )
    sub_51F9C(*(char **)v2, 10, 0);
  while ( 1 )
  {
    v6 = *(_DWORD **)(v2 + 4960);
    if ( !v6 )
      break;
    *(_DWORD *)(v2 + 4960) = *v6;
    free(v6);
  }
  *(_DWORD *)(v2 + 28) = 0;
  *(_DWORD *)(v2 + 32) = -1;
  return v5;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000521B8) --------------------------------------------------------
const char *__fastcall sub_521B8(char *src)
{
  int v2; // r5
  const char *v3; // r7
  signed int v4; // r4
  unsigned int v5; // r0
  bool v6; // zf
  int v8; // r3

  v2 = dword_7DB98;
  v3 = (const char *)(dword_7DB98 + 404);
  strcpy((char *)(dword_7DB98 + 404), src);
  *(_DWORD *)(v2 + 72) = 0;
  sub_51920();
  sub_518B4((int)src);
  v4 = strlen(v3);
  while ( v4 <= 127 )
  {
    v5 = sub_51950();
    if ( v5 <= 0x1B && ((0x8002400u >> v5) & 1) != 0 )
      break;
    if ( *(unsigned __int8 *)(v2 + 100) == v5 )
      goto LABEL_10;
    v6 = v5 == 127;
    if ( v5 != 127 )
      v6 = v5 == 8;
    if ( v6 )
    {
LABEL_10:
      --v4;
      *(_BYTE *)(v2 + v4 + 404) = 0;
      sub_518B4((int)"\b \b");
      if ( v4 <= 0 )
        break;
    }
    else if ( v5 - 1 <= 0xFE )
    {
      v8 = v2 + v4++;
      *(_BYTE *)(v8 + 404) = v5;
      *(_BYTE *)(v2 + v4 + 404) = 0;
      j_putchar_unlocked(v5);
    }
  }
  sub_51CCC(0);
  return v3;
}
// 7DB98: using guessed type int dword_7DB98;

//----- (000522A0) --------------------------------------------------------
int __fastcall sub_522A0(int a1)
{
  int v2; // r0
  int v3; // r1
  int v4; // r2

  sub_518C4(0, 0);
  sub_518B4((int)"\x1B[J");
  sub_50C04();
  *(_DWORD *)(dword_7DB98 + 72) = 0;
  v2 = sub_51CCC(a1);
  return sub_5232C(v2, v3, v4);
}
// 522DC: variable 'v3' is possibly undefined
// 522DC: variable 'v4' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (000522E8) --------------------------------------------------------
int sub_522E8()
{
  int v0; // r0
  bool v1; // zf

  sub_518B4((int)"\x1B[7m");
  sub_518B4((int)"[Hit return to continue]");
  sub_518B4((int)"\x1B[m");
  do
  {
    v0 = sub_51950();
    v1 = v0 == 13;
    if ( v0 != 13 )
      v1 = v0 == 10;
  }
  while ( !v1 );
  return sub_522A0(1);
}
// 522A0: using guessed type int __fastcall sub_522A0(_DWORD);

//----- (0005232C) --------------------------------------------------------
int __fastcall sub_5232C(int a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r6
  unsigned int v5; // r0
  const void *v6; // r5
  int v7; // r0
  int v8; // r2
  const void *v9; // r9
  int v10; // r7
  const void *v11; // r3
  int v12; // r0
  int v13; // r1
  int v14; // r0
  unsigned __int8 *v15; // r8
  unsigned int v16; // r5
  const char *v17; // r2
  const char *v18; // r1
  unsigned __int8 *v19; // r3
  int v20; // r5
  int v22; // t1

  v3 = dword_7DB98;
  v4 = *(_DWORD *)(dword_7DB98 + 68);
  if ( v4 )
  {
    v4 = 0;
    v5 = 0;
  }
  else
  {
    v6 = *(const void **)(dword_7DB98 + 8);
    v7 = sub_515C0(*(const void **)dword_7DB98, v6, a3, &dword_7DB98);
    v9 = *(const void **)(v3 + 28);
    v10 = v7;
    v11 = *(const void **)(v3 + 32);
    if ( v9 != v11 )
    {
      v12 = sub_515C0(v6, (const void *)(*(_DWORD *)(v3 + 4) - 1), v8, v11);
      *(_DWORD *)(v3 + 32) = v9;
      *(_DWORD *)(v3 + 112) = v10 + v12 - 1;
    }
    v13 = *(_DWORD *)(v3 + 112);
    v14 = 100;
    if ( v13 > 0 )
    {
      v14 = sub_15F18(100 * v10, v13);
    }
    else
    {
      v10 = 0;
      *(_DWORD *)(v3 + 112) = 0;
    }
    v15 = (unsigned __int8 *)(v3 + 204);
    v16 = *(_DWORD *)(v3 + 48);
    v17 = *(const char **)(v3 + 76);
    if ( v16 >= 0xC7 )
      v16 = 199;
    if ( !v17 )
      v17 = "No file";
    v18 = "";
    if ( v9 )
      v18 = " [Modified]";
    v5 = snprintf(
           (char *)(v3 + 204),
           v16 + 1,
           "%c %s%s %d/%d %d%%",
           (unsigned __int8)aIr[*(_DWORD *)(v3 + 24) & 3],
           v17,
           v18,
           v10,
           *(_DWORD *)(v3 + 112),
           v14);
    if ( v5 >= v16 )
      v5 = v16;
    v19 = &v15[v5];
    while ( v19 > v15 )
    {
      v22 = *v15++;
      v4 += v22;
    }
  }
  if ( *(_DWORD *)(v3 + 68) || v5 && *(_DWORD *)(v3 + 72) != v4 )
  {
    *(_DWORD *)(v3 + 72) = v4;
    sub_51920();
    sub_518B4(v3 + 204);
    v20 = *(_DWORD *)(v3 + 68);
    if ( v20 )
    {
      if ( 1 - v20 + strlen((const char *)(v3 + 204)) > *(_DWORD *)(v3 + 48) - 1 )
      {
        *(_DWORD *)(v3 + 68) = 0;
        sub_522E8();
      }
      *(_DWORD *)(v3 + 68) = 0;
    }
    sub_518C4(*(_DWORD *)(v3 + 56), *(_DWORD *)(v3 + 60));
  }
  return sub_177D8();
}
// 52380: variable 'v8' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (000524D4) --------------------------------------------------------
int __fastcall sub_524D4(int a1, int a2)
{
  struct pollfd v3; // [sp+0h] [bp-8h] BYREF

  v3.fd = a1;
  *(_DWORD *)&v3.events = a2;
  if ( (*(_DWORD *)(dword_7DB98 + 16) & 8) == 0 )
    return sub_518B4((int)"\a");
  sub_518B4((int)"\x1B[7m");
  sub_522A0(1);
  sub_177D8();
  v3.fd = 0;
  v3.events = 1;
  sub_60AD4(&v3, 1u, 100);
  sub_518B4((int)"\x1B[m");
  return sub_522A0(1);
}
// 7DB98: using guessed type int dword_7DB98;

//----- (00052554) --------------------------------------------------------
unsigned int __fastcall sub_52554(unsigned int a1, int a2)
{
  unsigned int v2; // r4
  unsigned int *v3; // r5
  __int64 v4; // r2
  unsigned int v5; // r5

  v2 = a1;
  v3 = (unsigned int *)dword_7DB98;
  v4 = *(_QWORD *)dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 + 4) <= a1 && HIDWORD(v4) > (unsigned int)v4 )
  {
    v2 = HIDWORD(v4) - 1;
    a1 = sub_524D4(a1, a2);
  }
  v5 = *v3;
  if ( v5 > v2 )
  {
    v2 = v5;
    sub_524D4(a1, a2);
  }
  return v2;
}
// 52590: variable 'a2' is possibly undefined
// 7DB98: using guessed type int dword_7DB98;

//----- (000525A0) --------------------------------------------------------
unsigned int __fastcall sub_525A0(const char *a1, int a2, int a3)
{
  int v3; // r3
  const char *v4; // r6
  int v5; // r5
  unsigned __int8 *v6; // r4
  unsigned __int8 *v7; // r7
  int v8; // r2
  char *v9; // r11
  const char *v10; // r0
  int v11; // r3
  int v12; // t1
  bool v13; // zf
  char *v14; // r0
  int v15; // r3
  int v16; // t1
  bool v17; // zf
  char *p_s1; // r2
  char *i; // r3
  const char *v20; // r0
  int v21; // r3
  int v22; // t1
  bool v23; // zf
  const char *v24; // r3
  const char *v25; // r0
  int v26; // r2
  int v27; // t1
  bool v28; // zf
  int v29; // r1
  const char *v30; // r1
  int v31; // r2
  int v32; // t1
  bool v33; // zf
  char v34; // r6
  char *v35; // r0
  int v36; // r3
  int v37; // r10
  _BYTE *v38; // r0
  size_t v39; // r0
  int v40; // r2
  size_t v41; // r8
  void *v42; // r0
  int v43; // r6
  int v44; // r1
  int v45; // r4
  unsigned int result; // r0
  const void *v47; // r6
  unsigned __int8 *v48; // r3
  int v49; // r0
  _BYTE *v50; // r3
  int v51; // r7
  int v52; // r4
  const void *v53; // r1
  int v54; // r4
  int v55; // r2
  const void *v56; // r3
  int v57; // r3
  const char *v58; // r2
  bool v59; // zf
  const void *v60; // r5
  unsigned int v61; // r5
  unsigned int v62; // t1
  int v63; // r6
  bool v64; // cc
  bool v65; // zf
  unsigned __int8 *v66; // r0
  _BYTE *v67; // r6
  int v68; // r0
  int v69; // r2
  const void *v70; // r3
  char *v71; // r4
  int v72; // r6
  int v73; // r0
  unsigned int v74; // r3
  int v75; // r0
  int v76; // r8
  char *v77; // r9
  char *v78; // r0
  const char *v79; // r6
  int v80; // r10
  char *v81; // r0
  char *v82; // r4
  int v83; // r2
  const void *v84; // r3
  int v85; // r8
  int v86; // r5
  int v87; // r10
  char *v88; // r7
  char *v89; // r0
  char *v90; // r4
  size_t v91; // r11
  char *v92; // r8
  int v93; // r2
  const void *v94; // r3
  int v95; // r6
  int v96; // r5
  int v97; // r0
  int v98; // r0
  int v99; // r3
  int v100; // r2
  bool v101; // zf
  char *src; // [sp+Ch] [bp-118h]
  char *srca; // [sp+Ch] [bp-118h]
  int v104; // [sp+10h] [bp-114h]
  int v105; // [sp+10h] [bp-114h]
  int v106; // [sp+14h] [bp-110h]
  int v107; // [sp+18h] [bp-10Ch] BYREF
  int v108; // [sp+1Ch] [bp-108h] BYREF
  char s1; // [sp+20h] [bp-104h] BYREF
  unsigned __int8 v110; // [sp+21h] [bp-103h]
  char dest[132]; // [sp+A0h] [bp-84h] BYREF

  v3 = *(unsigned __int8 *)a1;
  if ( !*a1 )
    goto LABEL_58;
  v108 = -1;
  v4 = a1;
  v107 = -1;
  if ( v3 == 58 )
    v4 = a1 + 1;
  v5 = dword_7DB98;
  v6 = *(unsigned __int8 **)dword_7DB98;
  v7 = (unsigned __int8 *)(*(_DWORD *)(dword_7DB98 + 4) - 1);
  sub_515C0(*(const void **)dword_7DB98, v7, a3, &dword_7DB98);
  v9 = *(char **)(v5 + 76);
  do
  {
    v10 = v4;
    v12 = *(unsigned __int8 *)v4++;
    v11 = v12;
    v13 = v12 == 9;
    if ( v12 != 9 )
      v13 = v11 == 32;
  }
  while ( v13 );
  if ( v11 == 37 )
  {
    v107 = 1;
    v108 = sub_515C0(v6, v7, v8, (const void *)1);
LABEL_10:
    v14 = (char *)v4;
    do
    {
      src = v14;
      v16 = (unsigned __int8)*v14++;
      v15 = v16;
      v17 = v16 == 9;
      if ( v16 != 9 )
        v17 = v15 == 32;
    }
    while ( v17 );
    goto LABEL_14;
  }
  v20 = sub_51630(v10, &v107, v8);
  do
  {
    src = (char *)v20;
    v22 = *(unsigned __int8 *)v20++;
    v21 = v22;
    v23 = v22 == 9;
    if ( v22 != 9 )
      v23 = v21 == 32;
  }
  while ( v23 );
  if ( v21 == 44 )
  {
    v24 = v20;
    do
    {
      v25 = v24;
      v27 = *(unsigned __int8 *)v24++;
      v26 = v27;
      v28 = v27 == 9;
      if ( v27 != 9 )
        v28 = v26 == 32;
    }
    while ( v28 );
    v4 = sub_51630(v25, &v108, v26);
    goto LABEL_10;
  }
LABEL_14:
  p_s1 = &s1;
  for ( i = src; ; ++i )
  {
    v29 = (unsigned __int8)*i;
    if ( (v29 & 0xDF) == 0 || (unsigned int)(v29 - 9) <= 4 )
      break;
    *p_s1++ = v29;
  }
  *p_s1 = 0;
  do
  {
    v30 = i;
    v32 = (unsigned __int8)*i++;
    v31 = v32;
    v33 = v32 == 9;
    if ( v32 != 9 )
      v33 = v31 == 32;
    v34 = v33;
  }
  while ( v33 );
  strcpy(dest, v30);
  v35 = (char *)sub_16AA8(&s1, 33);
  if ( v35 )
  {
    *v35 = v34;
    v36 = 1;
  }
  v37 = v107;
  if ( v35 )
    v104 = v36;
  else
    v104 = 0;
  if ( v107 >= 0 )
  {
    v6 = sub_51498(v107);
    v7 = (unsigned __int8 *)sub_51420(v6);
  }
  v106 = v108;
  if ( v108 >= 0 )
  {
    v38 = sub_51498(v108);
    v7 = (unsigned __int8 *)sub_51420(v38);
  }
  v39 = strlen(&s1);
  v41 = v39;
  if ( !v39 )
  {
    if ( v37 >= 0 )
    {
      v42 = sub_51498(v37);
LABEL_47:
      *(_DWORD *)(v5 + 8) = v42;
      sub_50B80();
    }
LABEL_58:
    v45 = dword_7DB98;
    result = sub_52554(*(_DWORD *)(dword_7DB98 + 8), a2);
    *(_DWORD *)(v45 + 8) = result;
    return result;
  }
  v43 = (unsigned __int8)s1;
  if ( s1 == 33 )
  {
    sub_51920();
    sub_51894();
    v44 = system(src + 1);
    if ( v44 )
      printf("\nshell returned %i\n\n", v44);
LABEL_51:
    sub_50BD8();
LABEL_52:
    sub_522E8();
    goto LABEL_58;
  }
  if ( s1 == 61 && !v110 )
  {
    if ( v37 < 0 )
    {
      v108 = sub_515C0(*(const void **)v5, *(const void **)(v5 + 8), v40, (const void *)v110);
      v107 = v108;
    }
    sub_51168("%d", v107);
    goto LABEL_58;
  }
  if ( !strncmp(&s1, "delete", v39) )
  {
    if ( v37 < 0 )
    {
      v47 = *(const void **)(v5 + 8);
      v6 = (unsigned __int8 *)sub_512E4((unsigned int)v47);
      v7 = (unsigned __int8 *)sub_51420(v47);
    }
    if ( v6 <= v7 )
    {
      v48 = v7;
      v7 = v6;
      v6 = v48;
    }
    v42 = sub_50E58((char *)v7, (unsigned int)v6, 1);
    goto LABEL_47;
  }
  if ( !strncmp(&s1, "edit", v41) )
  {
    if ( *(_DWORD *)(v5 + 28) )
      v49 = v104 ^ 1;
    else
      v49 = 0;
    if ( !v49 )
    {
      if ( dest[0] )
      {
        v9 = dest;
      }
      else
      {
        v50 = *(_BYTE **)(v5 + 76);
        if ( !v50 || !*v50 )
        {
          sub_51000("No current filename");
          goto LABEL_58;
        }
      }
      v51 = sub_52108(v9);
      v52 = *(_DWORD *)(v5 + 4);
      v53 = (const void *)(v52 - 1);
      v54 = v52 - *(_DWORD *)v5;
      v57 = sub_515C0(*(const void **)v5, v53, v55, v56);
      v58 = "";
      if ( v51 < 0 )
        v58 = " [New file]";
      sub_51168("'%s'%s %dL, %dC", *(const char **)(v5 + 76), v58, v57, v54);
      goto LABEL_58;
    }
    goto LABEL_70;
  }
  if ( !strncmp(&s1, "file", v41) )
  {
    v59 = v106 == -1;
    if ( v106 == -1 )
      v59 = v37 == -1;
    if ( v59 )
    {
      if ( dest[0] )
      {
        free(*(void **)(v5 + 76));
        *(_DWORD *)(v5 + 76) = sub_174F8(dest);
      }
      else
      {
        *(_DWORD *)(v5 + 72) = 0;
      }
    }
    else
    {
      sub_51000("No address allowed on this command");
    }
    goto LABEL_58;
  }
  if ( !strncmp(&s1, "features", v41) )
  {
    sub_51920();
    sub_51894();
    puts("These features are available:\n\tPattern searches with / and ?\n\tSome colon mode commands with :");
    goto LABEL_51;
  }
  if ( !strncmp(&s1, "list", v41) )
  {
    if ( v37 < 0 )
    {
      v60 = *(const void **)(v5 + 8);
      v6 = (unsigned __int8 *)sub_512E4((unsigned int)v60);
      v7 = (unsigned __int8 *)sub_51420(v60);
    }
    sub_51920();
    puts("\r");
    while ( 1 )
    {
      if ( v7 < v6 )
        goto LABEL_52;
      v62 = *v6++;
      v61 = v62;
      v63 = (char)v62;
      if ( (v62 & 0x80u) == 0 )
      {
        if ( v61 == 10 )
        {
          sub_518B4((int)"$\r");
          goto LABEL_107;
        }
      }
      else
      {
        v61 = 46;
        sub_518B4((int)"\x1B[7m");
      }
      v64 = v61 > 0x7F;
      if ( v61 != 127 )
        v64 = v61 > 0x1F;
      if ( !v64 )
      {
        j_putchar_unlocked(94);
        v65 = v61 == 127;
        if ( v61 == 127 )
          v61 = 63;
        else
          v61 += 64;
        if ( !v65 )
          v61 = (unsigned __int8)v61;
      }
LABEL_107:
      j_putchar_unlocked(v61);
      if ( v63 < 0 )
        sub_518B4((int)"\x1B[m");
    }
  }
  if ( !strncmp(&s1, "quit", v41) || !strncmp(&s1, "next", v41) || !strncmp(&s1, "prev", v41) )
  {
    if ( v104 )
    {
      if ( v43 == 113 )
        optind = *(_DWORD *)(v5 + 36);
LABEL_115:
      *(_DWORD *)(v5 + 20) = 0;
      goto LABEL_58;
    }
    if ( !*(_DWORD *)(v5 + 28) )
    {
      a2 = *(_DWORD *)(v5 + 36) - optind - 1;
      switch ( v43 )
      {
        case 'q':
          if ( a2 > 0 )
          {
            sub_51000("%d more file(s) to edit", a2);
            goto LABEL_58;
          }
          break;
        case 'n':
          if ( a2 <= 0 )
          {
            sub_51000("No more files to edit");
            goto LABEL_58;
          }
          break;
        case 'p':
          if ( optind <= 0 )
          {
            sub_51000("No previous files to edit");
            goto LABEL_58;
          }
          optind -= 2;
          break;
      }
      goto LABEL_115;
    }
LABEL_70:
    sub_51000("No write since last change (:%s! overrides)", &s1);
    goto LABEL_58;
  }
  if ( !strncmp(&s1, "read", v41) )
  {
    if ( !dest[0] )
    {
      sub_51000("No filename given");
      goto LABEL_58;
    }
    if ( v37 >= 0 )
    {
      if ( !v37 )
      {
LABEL_137:
        v67 = *(_BYTE **)v5;
        v68 = sub_51A00(dest, (char *)v6, 0);
        v71 = (char *)(*(_DWORD *)v5 + v6 - v67);
        v72 = v68;
        if ( v68 >= 0 )
        {
          v73 = sub_515C0(v71, &v71[v68 - 1], v69, v70);
          sub_51168("'%s' %dL, %dC", dest, v73, v72);
          if ( v72 )
          {
            v74 = *(_DWORD *)(v5 + 8);
            if ( v74 >= (unsigned int)v71 )
              *(_DWORD *)(v5 + 8) = v74 + v72;
          }
        }
        goto LABEL_58;
      }
    }
    else
    {
      v6 = (unsigned __int8 *)sub_512E4(*(_DWORD *)(v5 + 8));
    }
    v66 = sub_51464(v6);
    v6 = *(unsigned __int8 **)(v5 + 4);
    if ( v6 - 1 != v66 )
      v6 = v66;
    goto LABEL_137;
  }
  if ( !strncmp(&s1, "rewind", v41) )
  {
    if ( *(_DWORD *)(v5 + 28) )
      v75 = v104 ^ 1;
    else
      v75 = 0;
    if ( !v75 )
    {
      *(_DWORD *)(v5 + 20) = 0;
      optind = -1;
      goto LABEL_58;
    }
    goto LABEL_70;
  }
  if ( !strncmp(&s1, "set", v41) )
    goto LABEL_58;
  if ( v43 != 115 )
  {
    if ( !strncmp(&s1, "version", v41) )
    {
      sub_51168("1.29.3");
    }
    else if ( !strncmp(&s1, "write", v41) || !strncmp(&s1, "wq", v41) || !strncmp(&s1, "wn", v41) || v43 == 120 && !v110 )
    {
      v94 = *(const void **)(v5 + 28);
      if ( dest[0] )
        v9 = dest;
      v95 = v43 != 120;
      if ( v94 )
        v95 = 1;
      if ( v95 )
      {
        v97 = sub_51814((int)v9, (char *)v6, (int)v7);
        v96 = v97;
        v95 = v7 - v6 + 1;
        if ( v97 < 0 )
        {
          if ( v97 == -1 )
            sub_51000("'%s' %m", v9);
          goto LABEL_58;
        }
      }
      else
      {
        v96 = 0;
      }
      v98 = sub_515C0(v6, &v6[v96 - 1], v93, v94);
      sub_51168("'%s' %dL, %dC", v9, v98, v96);
      v99 = dword_7DB98;
      if ( v96 == v95 )
      {
        if ( *(unsigned __int8 **)dword_7DB98 == v6 && *(unsigned __int8 **)(dword_7DB98 + 4) == &v6[v96] )
        {
          a2 = -1;
          *(_QWORD *)(dword_7DB98 + 28) = 0xFFFFFFFF00000000LL;
        }
        if ( s1 == 120 )
          goto LABEL_188;
        v100 = v110 & 0xDF;
        v101 = v100 == 78;
        if ( v100 != 78 )
          v101 = v100 == 81;
        if ( v101 )
LABEL_188:
          *(_DWORD *)(v99 + 20) = 0;
      }
    }
    else
    {
      sub_51068(&s1);
    }
    goto LABEL_58;
  }
  v76 = (unsigned __int8)src[1];
  v77 = src + 2;
  v78 = strchr(src + 2, v76);
  if ( v78 )
  {
    v79 = v78 + 1;
    *v78 = 0;
    v80 = v78 - v77;
    v81 = strchr(v78 + 1, v76);
    if ( v81 )
    {
      *v81 = 0;
      v105 = v81 - v79;
      srca = (char *)(unsigned __int8)v81[1];
      v82 = (char *)sub_512E4((unsigned int)v6);
      if ( v107 < 0 )
      {
        v82 = (char *)sub_512E4(*(_DWORD *)(v5 + 8));
        v107 = sub_515C0(*(const void **)v5, v82, v83, v84);
      }
      v85 = 1;
      v86 = v107;
      v87 = v80 - 1;
      if ( v108 < 0 )
        v108 = v107;
      while ( v108 >= v86 )
      {
        v88 = v82;
        do
        {
          v89 = sub_514C4(v82, v77, 1, 0);
          v90 = v89;
          if ( !v89 )
            break;
          sub_50E58(v89, (unsigned int)&v89[v87], v85);
          v91 = strlen(v79);
          sub_50CDC((int)v90, v91, 2);
          v92 = sub_50C20(v90, v91);
          memcpy(&v92[(_DWORD)v90], v79, v91);
          v88 = &v92[(_DWORD)v88];
          if ( srca != (char *)103 )
          {
            v85 = 2;
            break;
          }
          v82 = &v92[v105 + (_DWORD)v90];
          v85 = 2;
        }
        while ( v82 < sub_51420(v88) );
        ++v86;
        v82 = sub_51464(v88);
      }
      goto LABEL_58;
    }
  }
  return sub_51168(":s expression missing delimiters");
}
// 52618: variable 'v8' is possibly undefined
// 52700: variable 'v36' is possibly undefined
// 527D0: variable 'v40' is possibly undefined
// 527F4: variable 'a2' is possibly undefined
// 528FC: variable 'v55' is possibly undefined
// 528FC: variable 'v56' is possibly undefined
// 52BE4: variable 'v69' is possibly undefined
// 52BE4: variable 'v70' is possibly undefined
// 52D04: variable 'v83' is possibly undefined
// 52D04: variable 'v84' is possibly undefined
// 52ED0: variable 'v93' is possibly undefined
// 52ED0: variable 'v94' is possibly undefined
// 7D604: using guessed type int optind;
// 7DB98: using guessed type int dword_7DB98;

//----- (00052FF8) --------------------------------------------------------
int __fastcall sub_52FF8(int a1, int a2, int a3)
{
  int v3; // r5
  unsigned int v4; // r7
  __int64 v5; // r0
  int v6; // r2
  const void *v7; // r3
  int v8; // r4
  int v9; // r2
  _DWORD *v10; // r4
  char *v11; // r0
  unsigned __int8 *v12; // r5
  int result; // r0
  _BOOL4 v14; // r3
  unsigned __int8 *v15; // r8
  unsigned int v16; // r1
  bool v17; // cc
  int v18; // r3
  __int64 v19; // r2
  unsigned __int8 *v20; // r0
  unsigned int v21; // r3
  bool v22; // cc
  int v23; // r3
  _DWORD *v24; // r7
  int v25; // r3
  int v26; // r0
  int v27; // r1
  unsigned int v28; // r0
  int v29; // r3
  int v30; // r3
  int v31; // r3
  int v32; // r3
  char *v33; // r10
  int v34; // r10
  int v35; // r3
  unsigned int v36; // r9
  char *v37; // r7
  int v38; // r8
  char *v39; // r12
  int v40; // r0
  int v41; // r3
  bool v42; // cc
  int v43; // r2
  int v44; // r2
  unsigned int v45; // r3
  int v46; // r3
  int v47; // r2
  unsigned int v48; // r0
  unsigned __int8 *v49; // r3
  int v50; // r3
  int v51; // r3
  _BYTE *v52; // r3
  int v53; // r3
  _BYTE *v54; // r2
  int v55; // r3
  int v56; // r7
  int v57; // r4
  char *v58; // r8
  char *v59; // r0
  const char *v60; // r1
  int v61; // r3
  int v62; // r2
  int v63; // r3
  int v64; // r1
  int v65; // r2
  int v66; // r9
  unsigned __int8 v67; // r0
  void *v68; // r7
  int v69; // r2
  const void *v70; // r3
  int i; // r7
  int v72; // r0
  int v73; // r3
  int j; // r8
  _BYTE *v75; // r3
  int v76; // r3
  int v77; // r2
  int v78; // r7
  unsigned __int8 *v79; // r0
  unsigned int v80; // r3
  bool v81; // cc
  int v82; // r3
  unsigned __int8 *v83; // r0
  void *v84; // r8
  char *v85; // r0
  char *v86; // r7
  int v87; // r0
  unsigned int v88; // r2
  unsigned int v89; // r3
  int v90; // r3
  _BYTE *v91; // r3
  int v92; // r3
  bool v93; // zf
  void *v94; // r0
  int v95; // r3
  unsigned int v96; // r2
  unsigned int v97; // r3
  int v98; // r3
  int v99; // r8
  unsigned int v100; // r7
  int v101; // r7
  int v102; // r3
  int v103; // r3
  int v104; // r3
  int v105; // r7
  unsigned int v106; // r8
  int v107; // r10
  int v108; // r3
  unsigned __int8 *v109; // r0
  unsigned int v110; // r3
  bool v111; // cc
  unsigned __int8 *v112; // r9
  unsigned int v113; // r1
  bool v114; // cc
  int v115; // r3
  int v116; // r3
  int v117; // r8
  int v118; // r9
  int v119; // r2
  bool v120; // zf
  int v121; // r1
  int v122; // r3
  int v123; // r3
  char v124; // r7
  int v125; // r0
  unsigned int v126; // r7
  int v127; // r0
  unsigned __int8 *v128; // r0
  int v129; // r3
  _BYTE *v130; // r2
  int v131; // r3
  int v132; // r3
  unsigned int v133; // [sp+Ch] [bp-20h]
  void *src; // [sp+14h] [bp-18h] BYREF
  char *v135; // [sp+18h] [bp-14h] BYREF
  __int64 dest; // [sp+1Ch] [bp-10h] BYREF
  int v137; // [sp+24h] [bp-8h]

  v3 = a1;
  v4 = a1 + 11;
  dest = 0;
  v137 = 0;
  LODWORD(v5) = sub_5232C(a1, a2, a3);
  if ( v4 <= 9 )
  {
    v6 = 1;
    v7 = (const void *)((1 << v4) & 0x3F7);
    if ( v7 )
      goto LABEL_349;
  }
  v8 = dword_7DB98;
  if ( *(_DWORD *)(dword_7DB98 + 24) == 2 )
  {
    if ( v3 == -8 )
    {
LABEL_187:
      v76 = dword_7DB98;
      v77 = 1;
LABEL_188:
      *(_DWORD *)(v76 + 24) = v77;
      sub_50F44();
      goto LABEL_19;
    }
    HIDWORD(v5) = *(_DWORD *)(dword_7DB98 + 8);
    if ( *(_BYTE *)HIDWORD(v5) != 10 )
    {
      if ( v3 <= 0 && (unsigned int)(unsigned __int8)v3 - 32 > 0x5E )
        goto LABEL_19;
      if ( v3 != 27 )
        *(_DWORD *)(v8 + 8) = sub_519AC(*(char **)(dword_7DB98 + 8), (char *)HIDWORD(v5), 0);
      v9 = 2;
      HIDWORD(v5) = (unsigned __int8)v3;
      goto LABEL_17;
    }
    *(_DWORD *)(dword_7DB98 + 24) = 1;
    LODWORD(v5) = sub_50F44();
  }
  v7 = *(const void **)(v8 + 24);
  if ( v7 != (const void *)1 )
  {
LABEL_349:
    v8 = dword_7DB98;
    switch ( v4 )
    {
      case 0u:
      case 0x11u:
        v26 = *(_DWORD *)(dword_7DB98 + 44);
        v27 = 1;
        goto LABEL_56;
      case 1u:
      case 0xDu:
        v26 = *(_DWORD *)(dword_7DB98 + 44);
        v27 = -1;
LABEL_56:
        v28 = v26 - 2;
        goto LABEL_58;
      case 2u:
        HIDWORD(v5) = *(_DWORD *)(dword_7DB98 + 8);
        if ( HIDWORD(v5) >= *(_DWORD *)(dword_7DB98 + 4) - 1 )
          goto LABEL_19;
        LODWORD(v5) = sub_50E58(*(char **)(dword_7DB98 + 8), HIDWORD(v5), 1);
        goto LABEL_18;
      case 3u:
      case 0x74u:
        goto LABEL_187;
      case 4u:
      case 0x2Fu:
        while ( 1 )
        {
          LODWORD(v5) = sub_51420(*(const void **)(v8 + 8));
          v35 = *(_DWORD *)(v8 + 40);
          *(_DWORD *)(v8 + 8) = v5;
          *(_DWORD *)(v8 + 40) = --v35;
          if ( v35 <= 0 )
            break;
          sub_5159C();
        }
        goto LABEL_19;
      case 5u:
        goto LABEL_165;
      case 6u:
      case 0x13u:
      case 0x73u:
      case 0x8Au:
        do
        {
          sub_50F90();
          v29 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v29;
        }
        while ( v29 >= 0 && !v93 );
        goto LABEL_19;
      case 7u:
      case 0x2Bu:
      case 0x77u:
        do
        {
          sub_50FC8();
          v32 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v32;
        }
        while ( v32 >= 0 && !v93 );
        goto LABEL_19;
      case 8u:
      case 0x15u:
      case 0x75u:
        do
        {
          sub_5159C();
          LODWORD(v5) = sub_5137C(*(_DWORD *)(v8 + 8), *(_DWORD *)(v8 + 60) + *(_DWORD *)(v8 + 64));
          v30 = *(_DWORD *)(v8 + 40);
          *(_DWORD *)(v8 + 8) = v5;
          *(_DWORD *)(v8 + 40) = --v30;
        }
        while ( v30 > 0 );
        goto LABEL_19;
      case 9u:
      case 0x76u:
        do
        {
          sub_51358();
          LODWORD(v5) = sub_5137C(*(_DWORD *)(v8 + 8), *(_DWORD *)(v8 + 60) + *(_DWORD *)(v8 + 64));
          v123 = *(_DWORD *)(v8 + 40);
          *(_DWORD *)(v8 + 8) = v5;
          *(_DWORD *)(v8 + 40) = --v123;
        }
        while ( v123 > 0 );
        goto LABEL_19;
      case 0xBu:
        goto LABEL_19;
      case 0xFu:
        v27 = 1;
        v28 = (unsigned int)(*(_DWORD *)(dword_7DB98 + 44) - 2) >> 1;
        goto LABEL_58;
      case 0x10u:
        v27 = 1;
        goto LABEL_60;
      case 0x12u:
        *(_DWORD *)(dword_7DB98 + 72) = 0;
        goto LABEL_19;
      case 0x17u:
      case 0x1Du:
        sub_518C4(0, 0);
        sub_518B4((int)"\x1B[J");
        sub_50C04();
        *(_DWORD *)(v8 + 72) = 0;
        sub_51CCC(1);
        goto LABEL_19;
      case 0x18u:
      case 0x36u:
        do
        {
          sub_5159C();
          sub_50B80();
          v31 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v31;
        }
        while ( v31 >= 0 && !v93 );
        goto LABEL_19;
      case 0x20u:
        v27 = -1;
        v28 = (unsigned int)(*(_DWORD *)(dword_7DB98 + 44) - 2) >> 1;
        goto LABEL_58;
      case 0x24u:
        v27 = -1;
LABEL_60:
        v28 = 1;
        goto LABEL_58;
      case 0x26u:
        if ( !*(_DWORD *)(dword_7DB98 + 24) )
          sub_524D4(v5, SHIDWORD(v5));
        *(_DWORD *)(v8 + 24) = 0;
        sub_50F44();
        *(_DWORD *)(v8 + 72) = 0;
        goto LABEL_19;
      case 0x30u:
        v36 = *(_DWORD *)(dword_7DB98 + 4);
        v135 = *(char **)(dword_7DB98 + 8);
        while ( 2 )
        {
          v37 = v135;
          v38 = (unsigned __int8)*v135;
          if ( v36 <= (unsigned int)v135 || v38 == 10 )
            goto LABEL_107;
          LODWORD(v5) = strchr("()[]{}", (unsigned __int8)*v135);
          if ( !(_DWORD)v5 )
          {
            ++v135;
            continue;
          }
          break;
        }
        v39 = *(char **)v8;
        v40 = (v5 - (_DWORD)"()[]{}") ^ 1;
        v41 = 1;
        HIDWORD(v5) = (unsigned __int8)asc_6B2F3[v40];
        LODWORD(v5) = ((2 * (_BYTE)v40) & 2) - 1;
        while ( 1 )
        {
          v37 += v5;
          v42 = v37 > v39;
          if ( v37 >= v39 )
            v42 = v36 > (unsigned int)v37;
          if ( !v42 )
            break;
          v43 = (unsigned __int8)*v37;
          if ( v43 == v38 )
            ++v41;
          if ( HIDWORD(v5) == v43 && !--v41 )
            goto LABEL_104;
        }
        v37 = 0;
LABEL_104:
        src = v37;
        if ( v37 )
          *(_DWORD *)(v8 + 8) = v37;
        else
          LODWORD(v5) = sub_524D4(v5, SHIDWORD(v5));
LABEL_107:
        if ( *v135 == 10 )
LABEL_108:
          sub_524D4(v5, SHIDWORD(v5));
        goto LABEL_19;
      case 0x37u:
        v47 = *(_DWORD *)(dword_7DB98 + 96);
        if ( !v47 )
          goto LABEL_19;
        v48 = *(_DWORD *)dword_7DB98;
        do
        {
          v49 = *(unsigned __int8 **)(v8 + 8);
          while ( 1 )
          {
            v135 = (char *)--v49;
            if ( v48 > (unsigned int)v49 )
              break;
            HIDWORD(v5) = *v49;
            if ( HIDWORD(v5) == 10 )
            {
              if ( v47 != 10 )
                break;
LABEL_132:
              *(_DWORD *)(v8 + 8) = v49;
              break;
            }
            if ( v47 == HIDWORD(v5) )
              goto LABEL_132;
          }
          v50 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v50;
        }
        while ( v50 >= 0 && !v93 );
        goto LABEL_19;
      case 0x38u:
        do
        {
          sub_51358();
          sub_50B80();
          v51 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v51;
        }
        while ( v51 >= 0 && !v93 );
        goto LABEL_19;
      case 0x3Au:
      case 0x4Au:
        LOWORD(dest) = (unsigned __int8)v3;
        LODWORD(v5) = sub_521B8((char *)&dest);
        v135 = (char *)v5;
        if ( !*(_BYTE *)v5 )
          goto LABEL_19;
        v52 = *(_BYTE **)(v8 + 104);
        if ( *(_BYTE *)(v5 + 1) )
        {
          free(*(void **)(v8 + 104));
          *(_DWORD *)(v8 + 104) = sub_174F8(v135);
        }
        else if ( *v52 )
        {
          *v52 = v3;
        }
        goto LABEL_140;
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
        v63 = *(_DWORD *)(dword_7DB98 + 40);
        if ( v3 == 48 && v63 <= 0 )
        {
LABEL_165:
          sub_513FC();
        }
        else
        {
          HIDWORD(v5) = 10;
          *(_DWORD *)(dword_7DB98 + 40) = v3 - 48 + 10 * v63;
        }
        goto LABEL_19;
      case 0x45u:
        src = (void *)sub_521B8((char *)":");
        sub_525A0((const char *)src, v64, v65);
        goto LABEL_19;
      case 0x46u:
        goto LABEL_111;
      case 0x47u:
      case 0x49u:
        v66 = sub_515C0(*(const void **)dword_7DB98, *(const void **)(dword_7DB98 + 8), v6, v7);
        v67 = sub_51950();
        sub_54414((unsigned int *)&src, &v135, v67);
        v68 = (void *)sub_512E4((unsigned int)src);
        src = v68;
        v135 = (char *)sub_51420(v135);
        for ( i = sub_515C0(v68, v135, v69, v70); i > 0; --i )
        {
          if ( v3 == 60 )
          {
            v73 = *(unsigned __int8 *)src;
            if ( v73 == 9 )
            {
              sub_50E58((char *)src, (unsigned int)src, 0);
            }
            else if ( v73 == 32 )
            {
              for ( j = 0; *(_BYTE *)src == 32 && *(_DWORD *)(v8 + 92) > j; ++j )
                sub_50E58((char *)src, (unsigned int)src, 0);
            }
          }
          else if ( v3 == 62 )
          {
            sub_51F9C((char *)src, 9, 1);
          }
          src = sub_51464(src);
        }
        v72 = v66;
        goto LABEL_171;
      case 0x4Cu:
        sub_517F0();
        goto LABEL_185;
      case 0x4Du:
      case 0x50u:
      case 0x62u:
        if ( v3 == 66 )
          v78 = -1;
        else
          v78 = 1;
        do
        {
          v79 = *(unsigned __int8 **)(v8 + 8);
          if ( v3 != 87 )
          {
            v80 = v79[v78];
            v81 = v80 > 0x20;
            if ( v80 != 32 )
              v81 = v80 - 9 > 4;
            if ( v81 )
              goto LABEL_197;
          }
          v83 = sub_511A8(v79, 1, v78, 2);
          *(_DWORD *)(v8 + 8) = v83;
          *(_DWORD *)(v8 + 8) = sub_511A8(v83, 2, v78, 3);
          if ( v3 != 87 )
LABEL_197:
            *(_DWORD *)(v8 + 8) = sub_511A8(*(unsigned __int8 **)(v8 + 8), 1, v78, 1);
          v82 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v82;
        }
        while ( v82 >= 0 && !v93 );
        goto LABEL_19;
      case 0x4Eu:
      case 0x4Fu:
        v84 = *(void **)(dword_7DB98 + 8);
        v85 = (char *)sub_51420(v84);
        v86 = v85;
        if ( *v85 == 10 && (int)&v85[-sub_512E4((unsigned int)v85)] > 0 )
          --v86;
        *(_DWORD *)(v8 + 8) = v86;
        *(_DWORD *)(v8 + 8) = sub_519AC((char *)v84, v86, 0);
        if ( v3 == 67 )
          goto LABEL_187;
        LOBYTE(v3) = 68;
        goto LABEL_19;
      case 0x52u:
        goto LABEL_215;
      case 0x53u:
        v88 = *(_DWORD *)(dword_7DB98 + 40);
        *(_DWORD *)(dword_7DB98 + 8) = *(_DWORD *)(dword_7DB98 + 80);
        v89 = *(_DWORD *)(v8 + 44) - 1;
        if ( v88 > v89 )
          *(_DWORD *)(v8 + 40) = v89;
        v90 = *(_DWORD *)(v8 + 40) - 1;
        v93 = *(_DWORD *)(v8 + 40) == 1;
        *(_DWORD *)(v8 + 40) = v90;
        if ( v90 >= 0 && !v93 )
          sub_52FF8(43);
        goto LABEL_216;
      case 0x54u:
        sub_513FC();
        sub_50B80();
        goto LABEL_187;
      case 0x55u:
        do
        {
          sub_517F0();
          LODWORD(v5) = *(_DWORD *)(v8 + 8);
          if ( (unsigned int)v5 < *(_DWORD *)(v8 + 4) - 1 )
          {
            sub_50CDC(v5, 1u, 1);
            v91 = *(_BYTE **)(v8 + 8);
            *(_DWORD *)(v8 + 8) = v91 + 1;
            *v91 = 32;
            sub_50CDC(*(_DWORD *)(v8 + 8) - 1, 1u, 2);
            while ( 1 )
            {
              HIDWORD(v5) = *(_DWORD *)(v8 + 8);
              v92 = (unsigned __int8)*(_BYTE *)HIDWORD(v5);
              v93 = v92 == 9;
              if ( v92 != 9 )
                v93 = v92 == 32;
              if ( !v93 )
                break;
              sub_50E58(*(char **)(v8 + 8), HIDWORD(v5), 2);
            }
          }
          v25 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v25;
        }
        while ( v25 >= 0 && !v93 );
        goto LABEL_19;
      case 0x57u:
        v94 = sub_51740();
        v95 = *(_DWORD *)(v8 + 44);
        v96 = *(_DWORD *)(v8 + 40);
        *(_DWORD *)(v8 + 8) = v94;
        v97 = v95 - 1;
        if ( v96 > v97 )
          *(_DWORD *)(v8 + 40) = v97;
        v98 = *(_DWORD *)(v8 + 40) - 1;
        v93 = *(_DWORD *)(v8 + 40) == 1;
        *(_DWORD *)(v8 + 40) = v98;
        if ( v98 >= 0 && !v93 )
          sub_52FF8(45);
        goto LABEL_232;
      case 0x58u:
        v99 = 0;
        v100 = (unsigned int)(*(_DWORD *)(dword_7DB98 + 44) - 1) >> 1;
        *(_DWORD *)(dword_7DB98 + 8) = *(_DWORD *)(dword_7DB98 + 80);
        while ( v99 != v100 )
        {
          ++v99;
          *(_DWORD *)(v8 + 8) = sub_51464(*(const void **)(v8 + 8));
        }
        goto LABEL_19;
      case 0x59u:
        v55 = *(_DWORD *)(dword_7DB98 + 8);
        src = (void *)(v55 - 1);
        if ( **(_BYTE **)(dword_7DB98 + 104) != 63 )
          goto LABEL_145;
        src = (void *)(v55 + 1);
        goto LABEL_158;
      case 0x5Au:
        src = (void *)sub_512E4(*(_DWORD *)(dword_7DB98 + 8));
        if ( *((char *)src - 1) == 10 )
        {
          sub_51358();
LABEL_238:
          sub_517F0();
          *(_DWORD *)(v8 + 8) = sub_51F9C(*(char **)(v8 + 8), 10, 1);
        }
        else
        {
          sub_513FC();
          *(_DWORD *)(v8 + 8) = sub_51F9C(*(char **)(v8 + 8), 10, 1);
          sub_51358();
        }
        goto LABEL_187;
      case 0x5Du:
        goto LABEL_240;
      case 0x63u:
      case 0x7Eu:
      case 0x83u:
        if ( v3 == 88 )
          v101 = -1;
        else
          v101 = 0;
        do
        {
          v102 = *(_DWORD *)(v8 + 8);
          if ( *(_BYTE *)(v102 + v101) != 10 )
          {
            if ( v3 == 88 )
              *(_DWORD *)(v8 + 8) = v102 - 1;
            *(_DWORD *)(v8 + 8) = sub_519AC(*(char **)(v8 + 8), *(char **)(v8 + 8), 0);
          }
          v103 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v103;
        }
        while ( v103 >= 0 && !v93 );
        if ( v3 == 115 )
          goto LABEL_187;
        goto LABEL_19;
      case 0x65u:
        LODWORD(v5) = sub_51950();
        if ( (_DWORD)v5 != 90 )
          goto LABEL_108;
        v104 = *(_DWORD *)(v8 + 28);
        if ( !v104 )
          goto LABEL_262;
        LODWORD(v5) = sub_51814(*(_DWORD *)(v8 + 76), *(char **)v8, *(_DWORD *)(v8 + 4) - 1);
        if ( (int)v5 >= 0 )
        {
          if ( *(_DWORD *)(v8 + 4) - *(_DWORD *)v8 == (_DWORD)v5 )
          {
            v104 = 0;
LABEL_262:
            *(_DWORD *)(v8 + 20) = v104;
          }
        }
        else if ( (_DWORD)v5 == -1 )
        {
          sub_51000("Write error: %m");
        }
        LOBYTE(v3) = 90;
        goto LABEL_19;
      case 0x69u:
LABEL_232:
        sub_513FC();
        goto LABEL_216;
      case 0x6Cu:
LABEL_185:
        v75 = *(_BYTE **)(v8 + 8);
        if ( *v75 != 10 )
          *(_DWORD *)(v8 + 8) = v75 + 1;
        goto LABEL_187;
      case 0x6Du:
      case 0x70u:
        if ( v3 == 98 )
          v105 = -1;
        else
          v105 = 1;
        v106 = *(_DWORD *)(dword_7DB98 + 4) - 1;
        if ( v3 == 101 )
          v107 = 2;
        else
          v107 = 1;
        v133 = *(_DWORD *)dword_7DB98;
        while ( 2 )
        {
          v108 = *(_DWORD *)(v8 + 8);
          v109 = (unsigned __int8 *)(v108 + v105);
          if ( v108 + v105 < v133 || (unsigned int)v109 > v106 )
            goto LABEL_19;
          *(_DWORD *)(v8 + 8) = v109;
          v110 = *(unsigned __int8 *)(v108 + v105);
          v111 = v110 > 0x20;
          if ( v110 != 32 )
            v111 = v110 - 9 > 4;
          if ( !v111 )
            *(_DWORD *)(v8 + 8) = sub_511A8(v109, v107, v105, 3);
          v112 = *(unsigned __int8 **)(v8 + 8);
          v113 = *v112;
          if ( v113 - 48 <= 9 )
            goto LABEL_280;
          v114 = v113 > 0x5F;
          if ( v113 != 95 )
            v114 = (v113 | 0x20) - 97 > 0x19;
          if ( v114 )
          {
            if ( !*(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~") )
            {
LABEL_282:
              v116 = *(_DWORD *)(v8 + 40) - 1;
              v93 = *(_DWORD *)(v8 + 40) == 1;
              *(_DWORD *)(v8 + 40) = v116;
              if ( v116 < 0 || v93 )
                goto LABEL_19;
              continue;
            }
            v115 = 4;
          }
          else
          {
LABEL_280:
            v115 = 5;
          }
          break;
        }
        *(_DWORD *)(v8 + 8) = sub_511A8(v112, 1, v105, v115);
        goto LABEL_282;
      case 0x6Eu:
      case 0x6Fu:
        v117 = sub_51950();
        v118 = sub_54414((unsigned int *)&src, &v135, (unsigned __int8)v117);
        sub_518C4(0, 0);
        if ( v117 == 27 )
        {
          v3 = 27;
          goto LABEL_291;
        }
        if ( strchr("wW", v117) )
        {
          if ( v3 == 99 )
          {
            while ( 1 )
            {
              v119 = (unsigned __int8)*v135;
              v120 = v119 == 9;
              if ( v119 != 9 )
                v120 = v119 == 32;
              if ( !v120 || *(_DWORD *)v8 >= (unsigned int)v135 || *(v135 - 1) == 10 )
                break;
              --v135;
            }
          }
          goto LABEL_290;
        }
        if ( strchr(a0bbeeftLh, v117) )
        {
LABEL_290:
          *(_DWORD *)(v8 + 8) = sub_519AC((char *)src, v135, v118);
LABEL_291:
          LODWORD(v5) = 0;
          goto LABEL_302;
        }
        if ( strchr("cdykjHL+-{}\r\n", v117) )
        {
          *(_DWORD *)(v8 + 8) = sub_519AC((char *)src, v135, v118);
          LODWORD(v5) = 1;
        }
        else
        {
          v3 = 27;
          v118 = 0;
          sub_524D4(0, v121);
          v117 = 27;
          LODWORD(v5) = 0;
        }
LABEL_302:
        if ( !v118 )
          LODWORD(v5) = 0;
        if ( (_DWORD)v5 )
        {
          if ( v3 == 99 )
          {
            LODWORD(v5) = sub_51F9C(*(char **)(v8 + 8), 10, 2);
            v122 = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 8) = v5;
            if ( (_DWORD)v5 != v122 - 1 )
              sub_51358();
            if ( v117 == 27 )
              goto LABEL_19;
            goto LABEL_309;
          }
          if ( v3 != 100 )
            goto LABEL_19;
          sub_513FC();
          sub_50B80();
          if ( v117 == 27 )
            goto LABEL_19;
        }
        else
        {
          if ( v117 == 27 )
            goto LABEL_19;
          if ( v3 == 99 )
          {
LABEL_309:
            strcpy((char *)&dest, "Change");
            LOBYTE(v3) = 99;
            goto LABEL_187;
          }
          if ( v3 != 100 )
            goto LABEL_19;
        }
        strcpy((char *)&dest, "Delete");
        LOBYTE(v3) = 100;
        goto LABEL_19;
      case 0x71u:
        *(_DWORD *)(v8 + 96) = sub_51950();
LABEL_111:
        v44 = *(_DWORD *)(v8 + 96);
        HIDWORD(v5) = *(_DWORD *)(v8 + 4) - 1;
        do
        {
          if ( !v44 )
            break;
          v45 = *(_DWORD *)(v8 + 8);
          while ( 1 )
          {
            v135 = (char *)(v45 + 1);
            LODWORD(v5) = *(unsigned __int8 *)++v45;
            if ( HIDWORD(v5) <= v45 || (_DWORD)v5 == 10 )
              break;
            if ( v44 == (_DWORD)v5 )
              goto LABEL_117;
          }
          if ( v44 == (_DWORD)v5 )
LABEL_117:
            *(_DWORD *)(v8 + 8) = v45;
          v46 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v46;
        }
        while ( v46 >= 0 && !v93 );
        goto LABEL_19;
      case 0x72u:
        v87 = sub_51950();
        if ( v87 == 103 )
        {
          if ( !*(_DWORD *)(v8 + 40) )
            *(_DWORD *)(v8 + 40) = 1;
LABEL_215:
          v72 = *(_DWORD *)(v8 + 40);
          *(_DWORD *)(v8 + 8) = *(_DWORD *)(v8 + 4) - 1;
          if ( v72 > 0 )
LABEL_171:
            *(_DWORD *)(v8 + 8) = sub_51498(v72);
LABEL_216:
          sub_50B80();
        }
        else
        {
          LOBYTE(dest) = 103;
          if ( v87 < 0 )
            LOBYTE(v87) = 42;
          *(_WORD *)((char *)&dest + 1) = (unsigned __int8)v87;
LABEL_54:
          sub_51068((const char *)&dest);
        }
        goto LABEL_19;
      case 0x79u:
        do
        {
LABEL_140:
          v53 = *(_DWORD *)(dword_7DB98 + 8);
          v54 = *(_BYTE **)(dword_7DB98 + 104);
          src = (void *)(v53 + 1);
          if ( *v54 == 63 )
          {
            src = (void *)(v53 - 1);
LABEL_145:
            v56 = -1;
          }
          else
          {
LABEL_158:
            v56 = 1;
          }
          v57 = dword_7DB98;
          v58 = (char *)(*(_DWORD *)(dword_7DB98 + 104) + 1);
          LODWORD(v5) = sub_514C4((char *)src, v58, v56, 1);
          v135 = (char *)v5;
          if ( (_DWORD)v5 )
          {
            *(_DWORD *)(v57 + 8) = v5;
          }
          else
          {
            src = *(void **)v57;
            if ( v56 == -1 )
              src = (void *)(*(_DWORD *)(v57 + 4) - 1);
            v59 = sub_514C4((char *)src, v58, v56, 1);
            v135 = v59;
            if ( v59 )
            {
              v60 = "search hit TOP, continuing at BOTTOM";
              *(_DWORD *)(v57 + 8) = v59;
              if ( v56 != -1 )
                v60 = "search hit BOTTOM, continuing at TOP";
            }
            else
            {
              v60 = "Pattern not found";
            }
            sub_51000("%s", v60);
          }
          v61 = *(_DWORD *)(v57 + 40) - 1;
          v93 = *(_DWORD *)(v57 + 40) == 1;
          *(_DWORD *)(v57 + 40) = v61;
        }
        while ( v61 >= 0 && !v93 );
        goto LABEL_19;
      case 0x7Au:
        goto LABEL_238;
      case 0x7Du:
        v124 = sub_51950();
        LODWORD(v5) = *(_DWORD *)(v8 + 8);
        if ( *(_BYTE *)v5 != 10 )
        {
          sub_50CDC(v5, 1u, 1);
          **(_BYTE **)(v8 + 8) = v124;
          sub_50CDC(*(_DWORD *)(v8 + 8), 1u, 2);
        }
        goto LABEL_19;
      case 0x7Fu:
        *(_DWORD *)(v8 + 96) = sub_51950();
        v5 = sub_52FF8(59);
        if ( **(unsigned __int8 **)(v8 + 8) == *(_DWORD *)(v8 + 96) )
          sub_50F90();
        *(_DWORD *)(v8 + 96) = 0;
        goto LABEL_19;
      case 0x80u:
        while ( 1 )
        {
          sub_50F44();
          v24 = *(_DWORD **)(v8 + 4960);
          if ( !v24 )
            break;
          switch ( *((_BYTE *)v24 + 12) )
          {
            case 0:
            case 2:
              sub_50E58((char *)(*(_DWORD *)v8 + v24[1]), *(_DWORD *)v8 + v24[1] + v24[2] - 1, 0);
              sub_51168("Undo [%d] %s %d chars at position %d", *(_DWORD *)(v8 + 28), "deleted", v24[2], v24[1]);
              break;
            case 1:
            case 3:
              v33 = (char *)(*(_DWORD *)v8 + v24[1]);
              sub_50C20(v33, v24[2]);
              memcpy(v33, (char *)v24 + 13, v24[2]);
              sub_51168("Undo [%d] %s %d chars at position %d", *(_DWORD *)(v8 + 28), "restored", v24[2], v24[1]);
              break;
            default:
              break;
          }
          switch ( *((_BYTE *)v24 + 12) )
          {
            case 0:
            case 1:
              *(_DWORD *)(v8 + 8) = *(_DWORD *)v8 + v24[1];
              sub_51CCC(0);
              goto LABEL_85;
            case 2:
            case 3:
              v34 = 1;
              break;
            default:
LABEL_85:
              v34 = 0;
              break;
          }
          *(_DWORD *)(v8 + 4960) = *v24;
          free(v24);
          --*(_DWORD *)(v8 + 28);
          if ( !v34 )
            goto LABEL_19;
        }
        sub_51168("Already at oldest change");
        goto LABEL_19;
      case 0x82u:
        while ( 1 )
        {
          v15 = *(unsigned __int8 **)(v8 + 8);
          v16 = *v15;
          if ( v16 - 48 <= 9 )
            goto LABEL_36;
          v17 = v16 > 0x5F;
          if ( v16 != 95 )
            v17 = (v16 | 0x20) - 97 > 0x19;
          if ( v17 )
          {
            if ( !*(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~") )
              goto LABEL_38;
            v18 = 4;
          }
          else
          {
LABEL_36:
            v18 = 5;
          }
          *(_DWORD *)(v8 + 8) = sub_511A8(v15, 1, 1, v18);
LABEL_38:
          v19 = *(_QWORD *)(v8 + 4);
          if ( HIDWORD(v19) < (unsigned int)(v19 - 1) )
            *(_DWORD *)(v8 + 8) = HIDWORD(v19) + 1;
          v20 = *(unsigned __int8 **)(v8 + 8);
          v21 = *v20;
          v22 = v21 > 0x20;
          if ( v21 != 32 )
            v22 = v21 - 9 > 4;
          if ( !v22 )
            *(_DWORD *)(v8 + 8) = sub_511A8(v20, 2, 1, 3);
          v23 = *(_DWORD *)(v8 + 40) - 1;
          v93 = *(_DWORD *)(v8 + 40) == 1;
          *(_DWORD *)(v8 + 40) = v23;
          if ( v23 < 0 || v93 )
            goto LABEL_19;
        }
      case 0x85u:
        v125 = sub_51950();
        if ( v125 == 46 )
        {
          v126 = (unsigned int)(*(_DWORD *)(v8 + 44) - 2) >> 1;
        }
        else
        {
          if ( v125 == 45 )
            v126 = *(_DWORD *)(v8 + 44);
          else
            v126 = 0;
          if ( v125 == 45 )
            v126 -= 2;
        }
        v127 = sub_512E4(*(_DWORD *)(v8 + 8));
        v27 = -1;
        *(_DWORD *)(v8 + 80) = v127;
        v28 = v126;
LABEL_58:
        sub_5177C(v28, v27);
        goto LABEL_19;
      case 0x86u:
        v62 = -1;
        goto LABEL_160;
      case 0x87u:
        LODWORD(v5) = sub_5137C(*(_DWORD *)(dword_7DB98 + 8), *(_DWORD *)(dword_7DB98 + 40) - 1);
        goto LABEL_18;
      case 0x88u:
        v62 = 1;
LABEL_160:
        LODWORD(v5) = sub_514C4(*(char **)(dword_7DB98 + 8), (char *)"\n\n", v62, 1);
        v135 = (char *)v5;
        if ( !(_DWORD)v5 )
          goto LABEL_19;
        LODWORD(v5) = sub_51464((const void *)v5);
        goto LABEL_18;
      case 0x89u:
        goto LABEL_337;
      default:
        LOWORD(dest) = (unsigned __int8)v3;
        goto LABEL_54;
    }
    while ( 1 )
    {
LABEL_337:
      v128 = *(unsigned __int8 **)(v8 + 8);
      v129 = *v128;
      if ( (unsigned int)(v129 - 97) > 0x19 )
      {
        if ( (unsigned int)(v129 - 65) > 0x19 )
          goto LABEL_341;
        sub_50CDC((int)v128, 1u, 1);
        v130 = *(_BYTE **)(v8 + 8);
        v131 = (unsigned __int8)*v130;
        if ( (unsigned int)(v131 - 65) <= 0x19 )
          LOBYTE(v131) = v131 + 32;
      }
      else
      {
        sub_50CDC((int)v128, 1u, 1);
        v130 = *(_BYTE **)(v8 + 8);
        v131 = (unsigned __int8)*v130;
        if ( (unsigned int)(v131 - 97) <= 0x19 )
          LOBYTE(v131) = v131 - 32;
      }
      *v130 = v131;
      sub_50CDC(*(_DWORD *)(v8 + 8), 1u, 2);
LABEL_341:
      sub_50FC8();
      v132 = *(_DWORD *)(v8 + 40) - 1;
      v93 = *(_DWORD *)(v8 + 40) == 1;
      *(_DWORD *)(v8 + 40) = v132;
      if ( v132 < 0 || v93 )
        goto LABEL_19;
    }
  }
  HIDWORD(v5) = (unsigned __int8)v3;
  if ( v3 == -8 )
  {
LABEL_240:
    v76 = dword_7DB98;
    v77 = 2;
    goto LABEL_188;
  }
  if ( v3 <= 0 && (unsigned int)(unsigned __int8)v3 - 32 > 0x5E )
    goto LABEL_19;
  v9 = 3;
LABEL_17:
  LODWORD(v5) = sub_51F9C(*(char **)(v8 + 8), SHIDWORD(v5), v9);
LABEL_18:
  *(_DWORD *)(v8 + 8) = v5;
LABEL_19:
  v10 = (_DWORD *)dword_7DB98;
  v11 = *(char **)(dword_7DB98 + 4);
  if ( v11 == *(char **)dword_7DB98 )
  {
    sub_51F9C(v11, 10, 0);
    v10[2] = *v10;
  }
  LODWORD(v5) = v10[2];
  if ( (_DWORD)v5 != v10[1] )
    v10[2] = sub_52554(v5, SHIDWORD(v5));
  v17 = (unsigned __int8)(v3 - 48) > 9u;
  v12 = (unsigned __int8 *)v10[2];
  if ( v17 )
    v10[10] = 0;
  result = (int)&v12[-sub_512E4((unsigned int)v12)];
  v14 = *v12 == 10;
  if ( result <= 0 )
    v14 = 0;
  if ( v14 && !v10[6] )
    v10[2] = v12 - 1;
  return result;
}
// 5318C: control flows out of bounds to 53190
// 53618: control flows out of bounds to 5361C
// 5367C: control flows out of bounds to 53680
// 5311C: variable 'v5' is possibly undefined
// 53ABC: variable 'v64' is possibly undefined
// 53ABC: variable 'v65' is possibly undefined
// 53ACC: variable 'v6' is possibly undefined
// 53B0C: variable 'v69' is possibly undefined
// 53B0C: variable 'v70' is possibly undefined
// 541FC: variable 'v121' is possibly undefined
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DB98: using guessed type int dword_7DB98;

//----- (00054414) --------------------------------------------------------
int __fastcall sub_54414(unsigned int *a1, char **a2, int c)
{
  unsigned int *v6; // r4
  char *v7; // r0
  char *v8; // r8
  int v9; // r5
  _BYTE *v10; // r0
  int v11; // r11
  unsigned int v12; // r6
  char *v13; // r5
  char *v14; // r3
  int result; // r0
  unsigned __int8 *v16; // r11
  unsigned int v17; // r6
  unsigned int v18; // r5
  bool v19; // cc
  unsigned int v20; // r3
  bool v21; // cc
  int v22; // r3
  _BYTE *v23; // r3
  char *v24; // r3
  int v25; // r2

  v6 = (unsigned int *)dword_7DB98;
  v7 = strchr("cdy><", c);
  v8 = (char *)v6[2];
  if ( v7 )
  {
    v9 = 1;
    v10 = (_BYTE *)sub_512E4(v6[2]);
    v11 = v6[10];
    v12 = (unsigned int)v10;
    while ( v11 > v9 )
    {
      v10 = sub_51464(v10);
      ++v9;
    }
    v13 = (char *)sub_51420(v10);
    goto LABEL_5;
  }
  if ( strchr(a0bbeefth, c) )
  {
    sub_52FF8(c);
LABEL_16:
    v13 = (char *)v6[2];
    v12 = (unsigned int)v8;
    goto LABEL_5;
  }
  if ( strchr("wW", c) )
  {
    sub_52FF8(c);
    v16 = (unsigned __int8 *)v6[2];
    v17 = *v6;
    if ( (unsigned int)v16 > *v6 )
    {
      v18 = *(v16 - 1);
      v19 = v18 > 0x20;
      if ( v18 != 32 )
        v19 = v18 - 9 > 4;
      if ( !v19 )
      {
        v20 = *v16;
        v21 = v20 > 0x20;
        if ( v20 != 32 )
          v21 = v20 - 9 > 4;
        if ( v21 )
          goto LABEL_31;
      }
      if ( *(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", *(v16 - 1))
        && !*(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", *v16)
        || (v18 - 48 <= 9 || (v18 | 0x20) - 97 <= 0x19)
        && (v22 = *v16, (unsigned int)(v22 - 48) > 9)
        && (v22 | 0x20u) - 97 > 0x19 )
      {
LABEL_31:
        v6[2] = (unsigned int)(v16 - 1);
      }
    }
    v23 = (_BYTE *)v6[2];
    if ( v17 < (unsigned int)v23 && *v23 == 10 )
      v6[2] = (unsigned int)(v23 - 1);
    goto LABEL_16;
  }
  if ( strchr("H-k{", c) )
  {
    v13 = (char *)sub_51420(v8);
    sub_52FF8(c);
    sub_513FC();
    v12 = v6[2];
  }
  else
  {
    if ( !strchr("L+j}\r\n", c) )
    {
      v12 = (unsigned int)v8;
      v13 = v8;
      goto LABEL_9;
    }
    v12 = sub_512E4((unsigned int)v8);
    sub_52FF8(c);
    sub_517F0();
    v13 = (char *)v6[2];
  }
LABEL_5:
  if ( v12 > (unsigned int)v13 )
  {
    v24 = (char *)v12;
    v12 = (unsigned int)v13;
    v13 = v24;
LABEL_7:
    if ( strchr(a0bbh, c) )
      --v13;
    goto LABEL_9;
  }
  if ( v12 < (unsigned int)v13 )
    goto LABEL_7;
LABEL_9:
  v14 = (char *)v12;
  do
  {
    if ( v13 < v14 )
    {
      result = 0;
      goto LABEL_12;
    }
    v25 = (unsigned __int8)*v14++;
  }
  while ( v25 != 10 );
  result = 1;
LABEL_12:
  *a1 = v12;
  *a2 = v13;
  v6[2] = (unsigned int)v8;
  return result;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 52FF8: using guessed type int __fastcall sub_52FF8(_DWORD);
// 7DB98: using guessed type int dword_7DB98;

//----- (00054680) --------------------------------------------------------
int __fastcall sub_54680(int a1, char *const *a2)
{
  _DWORD *v4; // r4
  char *v5; // r0
  int v6; // r0
  int v7; // r3
  int v8; // r8
  const char *v9; // r11
  void *v10; // r0
  int i; // r3
  const char *v12; // r0
  char *v13; // r11
  const char *v14; // r7
  const char *v15; // t1
  int v17; // r5
  char *v18; // r0
  int v19; // r1
  char *v20; // r10
  char *j; // r2
  int v22; // r0
  int v23; // r1
  int v24; // r2
  int v25; // r7
  int v26; // r2
  int v27; // r0
  int v28; // r1
  int v29; // r2
  int v30; // [sp+4h] [bp-10h]
  struct pollfd fds; // [sp+8h] [bp-Ch] BYREF

  v4 = sub_174DC(0x1364u);
  dword_7DB98 = (int)v4;
  v4[8] = -1;
  v4[26] = sub_174DC(2u);
  *((_BYTE *)v4 + 4692) = 64;
  v4[4] = 6;
  v5 = getenv("EXINIT");
  if ( v5 && *v5 )
    v4[44] = sub_1751C(v5, 128);
  while ( 1 )
  {
    v6 = getopt(a1, a2, "hCRHc:");
    if ( v6 == -1 )
      break;
    if ( v6 == 72 )
    {
      puts("These features are available:\n\tPattern searches with / and ?\n\tSome colon mode commands with :");
LABEL_19:
      sub_162F0();
    }
    if ( v6 != 99 )
      goto LABEL_19;
    if ( *(_BYTE *)optarg )
    {
      v17 = v4[44];
      v4[(v17 != 0) + 44] = sub_1751C((char *)optarg, 128);
    }
  }
  v7 = optind;
  optind = 0;
  v8 = a1 - v7;
  v4[9] = v8;
  v30 = v7;
  sub_518B4((int)"\x1B[?1049h");
  do
  {
    v9 = (&a2[optind])[v30];
    v4[5] = 1;
    sub_50BD8();
    v10 = (void *)v4[21];
    v4[11] = 24;
    v4[12] = 80;
    v4[13] = 0;
    free(v10);
    v4[22] = 1928;
    v4[21] = sub_1748C(0x788u);
    sub_50C04();
    for ( i = 80; i != 1840; i += 80 )
      *(_BYTE *)(v4[21] + i) = 126;
    v12 = v9;
    v13 = (char *)(v4 + 43);
    sub_52108(v12);
    *((_BYTE *)v4 + 101) = 0;
    v4[24] = 0;
    v4[14] = 0;
    v4[15] = 0;
    v4[6] = 0;
    v4[10] = 0;
    v4[23] = 8;
    v4[16] = 0;
    while ( 1 )
    {
      v15 = (const char *)*((_DWORD *)v13 + 1);
      v13 += 4;
      v14 = v15;
      if ( !v15 )
        break;
      while ( 1 )
      {
        v18 = strchr(v14, 10);
        v20 = v18;
        if ( v18 )
        {
          for ( j = v18; ; *(j - 1) = 0 )
          {
            v20 = j++;
            v19 = (unsigned __int8)*v20;
            if ( v19 != 10 )
              break;
          }
        }
        if ( *v14 )
          sub_525A0(v14, v19, *(unsigned __int8 *)v14);
        if ( !v20 )
          break;
        v14 = v20;
      }
      free(*(void **)v13);
      *(_DWORD *)v13 = 0;
    }
    sub_522A0(0);
    while ( (int)v4[5] > 0 )
    {
      v22 = sub_51950();
      *((_BYTE *)v4 + 101) = v22;
      sub_52FF8(v22, v23, v24);
      v25 = *((unsigned __int8 *)v4 + 188);
      if ( !*((_BYTE *)v4 + 188) )
      {
        v26 = *((unsigned __int8 *)v4 + 188);
        fds.fd = v26;
        fds.events = 1;
        if ( sub_60AD4(&fds, 1u, v26) <= 0 )
        {
          v27 = sub_51CCC(v25);
          sub_5232C(v27, v28, v29);
        }
      }
    }
    sub_51920();
    sub_51894();
    ++optind;
  }
  while ( optind < v8 );
  sub_518B4((int)"\x1B[?1049l");
  return 0;
}
// 548A0: variable 'v19' is possibly undefined
// 548E0: variable 'v23' is possibly undefined
// 548E0: variable 'v24' is possibly undefined
// 54918: variable 'v28' is possibly undefined
// 54918: variable 'v29' is possibly undefined
// 7D604: using guessed type int optind;
// 7D618: using guessed type int optarg;
// 7DB98: using guessed type int dword_7DB98;

//----- (00054940) --------------------------------------------------------
bool __fastcall sub_54940(int a1, int a2, int a3)
{
  return (*(_DWORD *)(a2 + 16) & 0xF000) == *(_DWORD *)(a3 + 8);
}

//----- (0005495C) --------------------------------------------------------
bool __fastcall sub_5495C(int a1, int a2, int a3)
{
  return *(_QWORD *)(a2 + 96) == *(_QWORD *)(a3 + 8);
}

//----- (00054978) --------------------------------------------------------
bool __fastcall sub_54978(int a1, int a2, int a3)
{
  int v3; // r12
  __int64 v4; // r0
  __int64 v5; // r2

  v3 = *(unsigned __int8 *)(a3 + 8);
  v4 = *(_QWORD *)(a2 + 48);
  v5 = *(_QWORD *)(a3 + 16);
  if ( v3 == 43 )
  {
    return v5 < v4;
  }
  else
  {
    if ( v3 != 45 )
      return v4 == v5;
    return v4 < v5;
  }
}

//----- (000549C8) --------------------------------------------------------
int __fastcall sub_549C8(char *s, int a2)
{
  int v4; // r4
  tcflag_t v5; // r8
  int v6; // r5
  int v7; // t1
  int v8; // r5
  int v9; // r6
  int v10; // t1
  char v11; // r4

  v4 = 0;
  v5 = buf.c_iflag - 4;
LABEL_2:
  v7 = *(_DWORD *)(v5 + 4);
  v5 += 4;
  v6 = v7;
  if ( v7 )
  {
    v4 &= ~1u;
    v8 = v6 - 4;
    while ( 1 )
    {
      v10 = *(_DWORD *)(v8 + 4);
      v8 += 4;
      v9 = v10;
      if ( !v10 )
        break;
      v4 |= (*(int (__fastcall **)(char *, int, int))v9)(s, a2, v9) ^ 1;
      if ( *(_BYTE *)(v9 + 4) )
        v4 ^= 1u;
      if ( (v4 & 1) != 0 )
        goto LABEL_2;
    }
  }
  v11 = v4 ^ 1;
  if ( (v11 & 1) != 0 && buf.c_oflag )
    puts(s);
  if ( (v11 & 2) != 0 )
    return 2;
  else
    return 1;
}

//----- (00054A70) --------------------------------------------------------
int __fastcall sub_54A70(const char *a1)
{
  puts(a1);
  return 1;
}

//----- (00054A80) --------------------------------------------------------
_BYTE *__fastcall sub_54A80(int *a1, size_t a2, int a3)
{
  _BYTE *v5; // r5
  int v6; // r6
  int v7; // r8
  _DWORD *v8; // r0
  int v9; // r3
  char v10; // r2

  v5 = sub_174DC(a2);
  v6 = *a1;
  v7 = a1[1];
  v8 = sub_174B4(*(void **)(*a1 + 4 * v7), 4 * (a1[2] + 2));
  v9 = a1[2];
  *(_DWORD *)(v6 + 4 * v7) = v8;
  a1[2] = v9 + 1;
  v10 = *((_BYTE *)a1 + 12);
  v8[v9] = v5;
  v8[v9 + 1] = 0;
  *(_DWORD *)v5 = a3;
  v5[4] = v10;
  *((_BYTE *)a1 + 12) = 0;
  return v5;
}

//----- (00054AE8) --------------------------------------------------------
bool __fastcall sub_54AE8(char *name, int a2, int a3)
{
  const char *v4; // r0
  int v5; // r2

  v4 = *(const char **)(a3 + 8);
  if ( *(_BYTE *)(a3 + 12) )
    v5 = 16;
  else
    v5 = 0;
  return fnmatch(v4, name, v5) == 0;
}

//----- (00054B18) --------------------------------------------------------
unsigned int __fastcall sub_54B18(const char *a1, int a2, int a3)
{
  char *v3; // r5
  char *v5; // r0
  char *v6; // r4
  char *v7; // r3
  int v8; // t1
  int v9; // r2
  unsigned int v10; // r0
  char v11; // r3
  unsigned int result; // r0

  v3 = (char *)a1;
  v5 = sub_169FC(a1);
  if ( *v5 )
  {
    v3 = v5;
    v6 = 0;
  }
  else
  {
    while ( 1 )
    {
      v6 = v5;
      if ( v3 == v5 )
        break;
      if ( *(v5 - 1) != 47 )
      {
        while ( 1 )
        {
          v7 = v5;
          v8 = (unsigned __int8)*--v5;
          if ( v8 == 47 )
            break;
          if ( v3 == v5 )
            goto LABEL_12;
        }
        v3 = v7;
        goto LABEL_12;
      }
      --v5;
    }
    v6 = (char *)(unsigned __int8)v3[1];
    if ( !v3[1] )
      goto LABEL_14;
    v6 = v3 + 1;
LABEL_12:
    if ( v6 )
      *v6 = 0;
  }
LABEL_14:
  if ( *(_BYTE *)(a3 + 12) )
    v9 = 16;
  else
    v9 = 0;
  v10 = __clz(fnmatch(*(const char **)(a3 + 8), v3, v9));
  if ( v6 )
    v11 = 47;
  result = v10 >> 5;
  if ( v6 )
    *v6 = v11;
  return result;
}
// 54BCC: variable 'v11' is possibly undefined

//----- (00054BD4) --------------------------------------------------------
bool __fastcall sub_54BD4(_DWORD *a1, const char *a2)
{
  int v3; // r8
  const char **i; // r5
  _DWORD *v5; // r2
  int v6; // r4
  const char **v7; // r6
  char *v8; // r0
  const char *v9; // t1
  const char *v11; // r9
  int v12; // r1
  const char **j; // r7
  char *v14; // r0
  char *v15; // r0
  int v16; // r3
  int v17; // r10
  const char *v18; // r3
  const char *v19; // [sp+0h] [bp-2Ch] BYREF
  const char *v20; // [sp+4h] [bp-28h]

  v3 = 0;
  v20 = a2;
  for ( i = &v19; ; i = j )
  {
    v5 = (_DWORD *)a1[5];
    if ( v3 >= a1[4] )
      break;
    v11 = *(const char **)(a1[2] + 4 * v3);
    v12 = *(_DWORD *)(a1[3] + 4 * v3);
    if ( !v5 )
    {
      j = i + 1;
      v14 = sub_60924(*(const char **)(a1[2] + 4 * v3), v12, (char *)"{}", v20);
      goto LABEL_13;
    }
    if ( !v12 )
    {
      j = i + 1;
      v14 = sub_174F8(*(const char **)(a1[2] + 4 * v3));
LABEL_13:
      *i = v14;
      goto LABEL_16;
    }
    for ( j = i; ; ++j )
    {
      v17 = (char *)j - (char *)i;
      v18 = *(const char **)(a1[5] + (char *)j - (char *)i);
      if ( !v18 )
        break;
      v15 = sub_60924(v11, 1, (char *)"{}", v18);
      v16 = a1[5];
      *j = v15;
      free(*(void **)(v16 + v17));
    }
LABEL_16:
    ++v3;
  }
  *i = 0;
  if ( v5 )
  {
    *v5 = 0;
    a1[6] = 0;
    a1[7] = 0;
  }
  v6 = sub_61B38(&v19);
  if ( v6 < 0 )
    sub_16B80(v19);
  v7 = &v19 - 1;
  while ( 1 )
  {
    v9 = v7[1];
    ++v7;
    v8 = (char *)v9;
    if ( !v9 )
      break;
    free(v8);
  }
  return v6 == 0;
}

//----- (00054D10) --------------------------------------------------------
int __fastcall sub_54D10(const char *a1, int a2, _DWORD *a3)
{
  void *v4; // r0
  const char *v6; // r5
  char *v7; // r0
  int v8; // r7
  size_t v9; // r0
  _DWORD *v10; // r0

  v4 = (void *)a3[5];
  if ( !v4 )
  {
    v10 = a3;
    return sub_54BD4(v10, a1);
  }
  v6 = a1;
  v7 = sub_62544(v4, 0x408u, a3[6]);
  v8 = a3[6];
  a3[5] = v7;
  a3[6] = v8 + 1;
  *(_DWORD *)&v7[4 * v8] = sub_174F8(v6);
  v9 = a3[7] + 5 + strlen(v6);
  a3[7] = v9;
  if ( v9 >= *(_DWORD *)&buf.c_line )
  {
    v10 = a3;
    a1 = 0;
    return sub_54BD4(v10, a1);
  }
  return 1;
}

//----- (00054DA4) --------------------------------------------------------
int __fastcall sub_54DA4(int a1, _DWORD *a2)
{
  _DWORD *v3; // r8
  unsigned int v4; // r0
  int v5; // r5
  _DWORD *v6; // r6
  char **v7; // r0
  int v8; // r7
  char v9; // r0
  char *v10; // r3
  bool v11; // zf
  unsigned __int8 **v12; // r7
  unsigned __int8 **v13; // r8
  unsigned int v14; // r9
  _DWORD *v15; // r6
  const char *v16; // r0
  const char *v17; // t1
  int *c_iflag; // r6
  int v19; // r4
  int v20; // t1
  int v22; // r2
  int v23; // r0
  int v24; // r5
  const char *v25; // r10
  const char *v26; // r1
  size_t v27; // r1
  char v28; // r3
  _DWORD *v29; // r5
  unsigned __int8 **v30; // r3
  unsigned __int8 *v31; // r2
  unsigned __int8 *v32; // t1
  int v33; // r1
  int v34; // r0
  int v35; // r11
  void *v36; // r0
  int v37; // r10
  int i; // r9
  _BYTE *v39; // r0
  bool v40; // zf
  char v41; // r5
  _BYTE *v42; // r0
  int v43; // r3
  int v44; // r3
  _BYTE *v45; // r5
  _BYTE *v46; // r5
  _BOOL4 v47; // r0
  int v48; // r5
  int v49; // t1
  int v50; // [sp+Ch] [bp-18h]
  void *v51; // [sp+10h] [bp-14h] BYREF
  int v52; // [sp+14h] [bp-10h]
  int v53; // [sp+18h] [bp-Ch]
  char v54; // [sp+1Ch] [bp-8h]

  v3 = a2;
  memset(&buf, 0, 0x14u);
  v4 = sub_60F68();
  buf.c_oflag = 1;
  *(_DWORD *)&buf.c_line = v4 - 2048;
  LOBYTE(buf.c_lflag) = 1;
  while ( 1 )
  {
    v5 = v3[1];
    v6 = v3 + 1;
    if ( !v5 || *(_BYTE *)v5 != 45 || !*(_BYTE *)(v5 + 1) || *(_BYTE *)(v5 + strspn((const char *)(v5 + 1), "HLP") + 1) )
      break;
    ++v3;
  }
  v7 = (char **)a2;
  *v6 = 0;
  v8 = 0;
  v9 = sub_593CC(v7, "+HLP");
  if ( (v9 & 1) != 0 )
    LOBYTE(buf.c_lflag) |= 0x44u;
  if ( (v9 & 2) != 0 )
    LOBYTE(buf.c_lflag) |= 0x42u;
  *v6 = v5;
  while ( 1 )
  {
    v10 = (char *)v6[v8];
    if ( !v10 )
      break;
    v22 = (unsigned __int8)*v10;
    if ( v22 == 45 )
      break;
    if ( v22 == 33 )
    {
      v10 = (char *)(unsigned __int8)v10[1];
      if ( !v10 )
        break;
    }
    ++v8;
  }
  v11 = v8 == 0;
  if ( !v8 )
  {
    v10 = ".";
    v6 = v3;
    v8 = 1;
  }
  v12 = (unsigned __int8 **)&v6[v8];
  if ( v11 )
    *v3 = v10;
  v13 = v12;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v51 = sub_174DC(8u);
  while ( 1 )
  {
    v14 = (unsigned int)*v13;
    if ( !*v13 )
      break;
    v23 = sub_16880("-follow", (char *)*v13);
    v24 = v23;
    v25 = (const char *)v13[1];
    if ( v23 <= 6 )
    {
      if ( !v23 )
      {
        v28 = LOBYTE(buf.c_lflag) | 0x42;
LABEL_39:
        LOBYTE(buf.c_lflag) = v28;
        goto LABEL_40;
      }
      if ( v23 == 1 )
      {
        v28 = LOBYTE(buf.c_lflag) | 8;
        goto LABEL_39;
      }
    }
    else
    {
      if ( !v25 )
        goto LABEL_30;
      ++v13;
    }
    switch ( v23 )
    {
      case 2:
        goto LABEL_40;
      case 3:
        v27 = 4 * (v52 + 3);
        ++v52;
        v51 = sub_174B4(v51, v27);
        *((_DWORD *)v51 + v52 + 1) = 0;
        v53 = 0;
        goto LABEL_40;
      case 4:
        v54 ^= 1u;
        goto LABEL_40;
      case 5:
        buf.c_oflag = 0;
        sub_54A80((int *)&v51, 8u, (int)sub_54A70);
        goto LABEL_40;
      case 6:
        buf.c_oflag = 0;
        v29 = sub_54A80((int *)&v51, 0x20u, (int)sub_54D10);
        v30 = v13 + 1;
        v29[2] = v13 + 1;
        while ( 1 )
        {
          v13 = v30;
          v32 = *v30++;
          v31 = v32;
          if ( !v32 )
            break;
          v33 = *v31;
          if ( (v33 & 0xEF) == 0x2B && !v31[1] )
          {
            if ( v33 == 43 )
              v29[5] = sub_174DC(4u);
            v34 = v29[4];
            if ( v34 )
            {
              v35 = 0;
              v36 = sub_1748C(4 * v34);
              v37 = v29[4];
              v29[3] = v36;
              for ( i = 4 * v37; ; v35 += *(_DWORD *)(v29[3] + i) )
              {
                --v37;
                i -= 4;
                if ( v37 == -1 )
                  break;
                v50 = v29[3];
                *(_DWORD *)(v50 + i) = sub_608E0(*(const char **)(v29[2] + i), (char *)"{}");
              }
              if ( v35 != 1 && v29[5] )
                sub_16DBC("only one '{}' allowed for -exec +");
              goto LABEL_40;
            }
LABEL_30:
            v26 = (const char *)v14;
LABEL_49:
            sub_16DBC("%s requires an argument", v26);
          }
          ++v29[4];
        }
        v26 = "-exec";
        goto LABEL_49;
    }
    if ( (unsigned int)(v23 - 7) <= 1 )
    {
      v39 = sub_54A80((int *)&v51, 0x10u, (int)sub_54B18);
      v40 = v24 == 8;
      *((_DWORD *)v39 + 2) = v25;
LABEL_64:
      v41 = v40;
      v39[12] = v41;
      goto LABEL_40;
    }
    if ( (unsigned int)(v23 - 9) <= 1 )
    {
      v39 = sub_54A80((int *)&v51, 0x10u, (int)sub_54AE8);
      v40 = v24 == 10;
      *((_DWORD *)v39 + 2) = v25;
      goto LABEL_64;
    }
    switch ( v23 )
    {
      case 11:
        v42 = sub_54A80((int *)&v51, 0xCu, (int)sub_54940);
        v43 = *(unsigned __int8 *)v25;
        if ( v43 != 98 )
        {
          switch ( v43 )
          {
            case 'c':
              v44 = 0x2000;
              goto LABEL_79;
            case 'd':
              v44 = 0x4000;
              goto LABEL_79;
            case 'p':
              v44 = 4096;
              goto LABEL_79;
            case 'f':
              v44 = 0x8000;
              goto LABEL_79;
            case 'l':
              v44 = 40960;
              goto LABEL_79;
            case 's':
              v44 = 49152;
LABEL_79:
              if ( !v25[1] )
              {
                *((_DWORD *)v42 + 2) = v44;
                goto LABEL_40;
              }
              break;
          }
          sub_16DBC("invalid argument '%s' to '%s'", v25, "-type");
        }
        v44 = 24576;
        goto LABEL_79;
      case 12:
        v45 = sub_54A80((int *)&v51, 0x10u, (int)sub_5495C);
        *((_DWORD *)v45 + 2) = sub_620B0(v25);
        *((_DWORD *)v45 + 3) = 0;
        break;
      case 13:
        v46 = sub_54A80((int *)&v51, 0x18u, (int)sub_54978);
        v46[8] = *v25;
        if ( ((*v25 - 43) & 0xFD) == 0 )
          ++v25;
        *((_QWORD *)v46 + 2) = sub_61EE8(v25, (int)&unk_63E74);
        break;
      default:
        sub_16DDC("unrecognized: %s", (const char *)v14);
        sub_162F0();
    }
LABEL_40:
    ++v13;
  }
  v15 = v6 - 1;
  buf.c_iflag = (tcflag_t)v51;
  *v12 = 0;
  while ( 1 )
  {
    v17 = (const char *)v15[1];
    ++v15;
    v16 = v17;
    if ( !v17 )
      break;
    if ( !sub_60474(v16, LOBYTE(buf.c_lflag), (int (*)())sub_549C8, (int (*)())sub_549C8, 0, 0) )
      v14 = 1;
  }
  c_iflag = (int *)buf.c_iflag;
  while ( 1 )
  {
    v20 = *c_iflag++;
    v19 = v20;
    if ( !v20 )
      break;
    while ( 1 )
    {
      v49 = *(_DWORD *)v19;
      v19 += 4;
      v48 = v49;
      if ( !v49 )
        break;
      if ( *(int (__fastcall **)(const char *, int, _DWORD *))v48 == sub_54D10 && *(_DWORD *)(v48 + 24) )
      {
        v47 = sub_54BD4((_DWORD *)v48, 0);
        if ( *(_BYTE *)(v48 + 4) )
          v47 = !v47;
        if ( !v47 )
        {
          v19 = 1;
          return v14 | v19;
        }
      }
    }
  }
  return v14 | v19;
}

//----- (00055398) --------------------------------------------------------
int __fastcall sub_55398(int result, int a2, int a3)
{
  const char *v5; // r7

  if ( a2 > 0 )
  {
    v5 = (const char *)result;
    if ( (*(_DWORD *)&buf.c_cc[7] || *(_DWORD *)&buf.c_cc[11])
      && *(_DWORD *)&buf.c_cc[3]
      && *(_DWORD *)&buf.c_cc[19] != a2 - 1 )
    {
      result = puts("--");
    }
    buf.c_cc[4] = 0;
    buf.c_cc[5] = 0;
    buf.c_cc[6] = 0;
    buf.c_cc[3] = 1;
    *(_DWORD *)&buf.c_cc[19] = a2;
    if ( buf.c_lflag )
      result = printf("%s%c", *(const char **)&buf.c_cc[27], a3);
    if ( (dword_7DBC0 & 2) != 0 )
      result = printf("%i%c", a2, a3);
    if ( (~dword_7DBC0 & 0x2008) != 0 )
      return puts(v5);
  }
  return result;
}
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00055478) --------------------------------------------------------
int __fastcall sub_55478(FILE *a1, int a2, int a3)
{
  int v3; // r4
  int v4; // r6
  int v5; // r11
  int v6; // r8
  char *v7; // r5
  _DWORD *v9; // r10
  unsigned int v10; // r2
  char v11; // r7
  const char *v12; // r7
  int v13; // r9
  char *v14; // r0
  char *v15; // r3
  unsigned int v16; // r2
  bool v17; // cc
  size_t v18; // r0
  bool v19; // cc
  int v20; // r3
  const char *v21; // r1
  const char *v22; // r7
  int eflags; // r3
  int v24; // r0
  int v25; // r3
  unsigned int v26; // r3
  bool v27; // cc
  int v28; // r3
  unsigned int v29; // r9
  int v30; // r1
  int v31; // r0
  int v32; // r10
  int v33; // r7
  int v34; // r11
  int v35; // r0
  int v36; // r1
  int v37; // r1
  int v38; // r1
  int v39; // r7
  int v40; // r0
  int v41; // r10
  char *v42; // r3
  int v43; // [sp+8h] [bp-24h]
  int pmatch; // [sp+Ch] [bp-20h]
  char *s; // [sp+10h] [bp-1Ch]
  int v47; // [sp+1Ch] [bp-10h]
  int v48; // [sp+20h] [bp-Ch]
  char *v49; // [sp+24h] [bp-8h]

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v43 = 0;
  while ( 2 )
  {
    while ( 2 )
    {
      v7 = sub_58D24(a1, a2, a3);
      if ( !v7 )
        goto LABEL_3;
      v9 = *(_DWORD **)&buf.c_cc[23];
      ++v43;
      pmatch = 0;
      while ( v9 )
      {
        v3 = v9[1];
        if ( (dword_7DBC0 & 0x40) != 0 )
        {
          v12 = v7;
          s = *(char **)v3;
          v47 = dword_7DBC0 & 0x80;
          v13 = dword_7DBC0 & 0x10000;
          v48 = dword_7DBC0 & 0x20000;
          while ( 1 )
          {
            v14 = v47 ? (char *)strcasestr(v12, s) : strstr(v12, s);
            v15 = v14;
            if ( !v14 )
              break;
            v10 = v48;
            if ( v48 )
            {
              if ( v12 != v14 || v12[strlen(s)] )
                break;
              goto LABEL_24;
            }
            if ( !v13 )
              goto LABEL_24;
            v16 = v14 == v7 ? 32 : (unsigned __int8)*(v14 - 1);
            if ( v16 - 48 > 9 )
            {
              v17 = v16 > 0x5F;
              if ( v16 != 95 )
                v17 = (v16 | 0x20) - 97 > 0x19;
              if ( v17 )
              {
                v49 = v14;
                v18 = strlen(s);
                v15 = v49;
                v10 = (unsigned __int8)v49[v18];
                if ( !v49[v18] )
                  goto LABEL_24;
                if ( v10 - 48 > 9 )
                {
                  v19 = v10 > 0x5F;
                  if ( v10 != 95 )
                    v19 = (v10 | 0x20) - 97 > 0x19;
                  if ( v19 )
                    goto LABEL_24;
                }
              }
            }
            v12 = v15 + 1;
          }
        }
        else
        {
          v20 = *(_DWORD *)(v3 + 44);
          if ( (v20 & 2) == 0 )
          {
            v21 = *(const char **)v3;
            *(_DWORD *)(v3 + 44) = v20 | 2;
            sub_625E4((regex_t *)(v3 + 4), v21, buf.c_oflag);
          }
          v22 = v7;
          eflags = 0;
          *(_DWORD *)(v3 + 36) = 0;
          *(_DWORD *)(v3 + 40) = 0;
          while ( 1 )
          {
            v24 = regexec((const regex_t *)(v3 + 4), v22, 1u, (regmatch_t *)(v3 + 36), eflags);
            if ( v24 )
              break;
            if ( (dword_7DBC0 & 0x20000) != 0 )
            {
              if ( !*(_DWORD *)(v3 + 36) )
                v24 = v22[*(_DWORD *)(v3 + 40)] == 0;
              pmatch = v24;
              break;
            }
            if ( (dword_7DBC0 & 0x10000) == 0 )
              goto LABEL_24;
            v25 = *(_DWORD *)(v3 + 36);
            if ( v22 > v7 || v25 )
              v26 = (unsigned __int8)v22[v25 - 1];
            else
              v26 = 32;
            if ( v26 - 48 > 9 && (v26 | 0x20) - 97 > 0x19 && v26 != 95 )
              v26 = (unsigned __int8)v22[*(_DWORD *)(v3 + 40)];
            v10 = v26 - 48;
            if ( v26 - 48 > 9 )
            {
              v10 = (unsigned __int8)((v26 | 0x20) - 97);
              v27 = v26 > 0x5F;
              if ( v26 != 95 )
                v27 = v10 > 0x19;
              if ( v27 )
                goto LABEL_24;
            }
            v28 = *(_DWORD *)(v3 + 40);
            if ( !v28 )
              break;
            v22 += v28;
            eflags = 1;
          }
        }
        if ( pmatch )
        {
LABEL_24:
          pmatch = 1;
          if ( !buf.c_cflag )
            goto LABEL_13;
        }
        v9 = (_DWORD *)*v9;
      }
      v10 = pmatch;
      if ( buf.c_cflag == pmatch )
      {
        if ( v5 )
        {
          --v5;
          sub_55398((int)v7, v43, 45);
        }
        else if ( *(_DWORD *)&buf.c_cc[7] )
        {
          free(*(void **)(*(_DWORD *)&buf.c_cc[15] + 4 * v4));
          *(_DWORD *)(*(_DWORD *)&buf.c_cc[15] + 4 * v4) = v7;
          v7 = 0;
          sub_161AC(v4 + 1, *(unsigned int *)&buf.c_cc[7]);
          v4 = v38;
        }
      }
      else
      {
LABEL_13:
        ++v6;
        v11 = dword_7DBC0;
        if ( (dword_7DBC0 & 0x1005) != 0 )
        {
          free(v7);
          if ( (v11 & 4) != 0 )
            exit(0);
          if ( (v11 & 1) != 0 )
            puts(*(const char **)&buf.c_cc[27]);
          return 1;
        }
        if ( (dword_7DBC0 & 0x8000) != 0 && (int)buf.c_iflag < v6 )
          goto LABEL_3;
        if ( (dword_7DBC0 & 0x20) == 0 )
        {
          if ( v4 )
            v10 = v4 - 1;
          v29 = *(_DWORD *)&buf.c_cc[7];
          if ( !v4 )
            v10 = *(_DWORD *)&buf.c_cc[7] - 1;
          if ( *(_DWORD *)&buf.c_cc[7] )
          {
            v32 = *(_DWORD *)&buf.c_cc[15];
            if ( *(_DWORD *)(*(_DWORD *)&buf.c_cc[15] + 4 * v10) )
            {
              v33 = v4;
              v34 = v43 - *(_DWORD *)&buf.c_cc[7];
              while ( !*(_DWORD *)(v32 + 4 * v33) )
              {
                sub_161AC(v33 + 1, v29);
                ++v34;
                v33 = v37;
              }
              while ( 1 )
              {
                v35 = *(_DWORD *)(*(_DWORD *)&buf.c_cc[15] + 4 * v33);
                if ( !v35 )
                  break;
                sub_55398(v35, v34++, 45);
                free(*(void **)(*(_DWORD *)&buf.c_cc[15] + 4 * v33));
                *(_DWORD *)(*(_DWORD *)&buf.c_cc[15] + 4 * v33) = 0;
                sub_161AC(v33 + 1, *(unsigned int *)&buf.c_cc[7]);
                v33 = v36;
              }
            }
          }
          v5 = *(_DWORD *)&buf.c_cc[11];
          if ( (dword_7DBC0 & 0x2000) == 0 )
          {
            v30 = v43;
            v31 = (int)v7;
LABEL_80:
            sub_55398(v31, v30, 58);
            goto LABEL_91;
          }
          if ( (dword_7DBC0 & 0x40) == 0 )
          {
            while ( 1 )
            {
              v39 = *(_DWORD *)(v3 + 40);
              v40 = *(_DWORD *)(v3 + 36);
              v41 = (unsigned __int8)v7[v39];
              v42 = &v7[v39];
              v7[v39] = 0;
              if ( v40 == v39 )
              {
                if ( !v41 )
                  goto LABEL_91;
                ++v39;
                *v42 = v41;
              }
              else
              {
                sub_55398((int)&v7[v40], v43, 58);
                if ( !v41 )
                  goto LABEL_91;
                v7[v39] = v41;
              }
              if ( regexec((const regex_t *)(v3 + 4), &v7[v39], 1u, (regmatch_t *)(v3 + 36), 1) )
                goto LABEL_91;
              *(_DWORD *)(v3 + 36) += v39;
              *(_DWORD *)(v3 + 40) += v39;
            }
          }
          if ( pmatch )
          {
            v30 = v43;
            v31 = *(_DWORD *)v3;
            goto LABEL_80;
          }
        }
      }
LABEL_91:
      free(v7);
      a3 = dword_7DBC0;
      if ( ((v5 == 0) & ((unsigned int)dword_7DBC0 >> 15)) == 0 )
        continue;
      break;
    }
    if ( buf.c_iflag != v6 )
    {
      v5 = 0;
      continue;
    }
    break;
  }
LABEL_3:
  if ( (dword_7DBC0 & 0x20) != 0 )
  {
    if ( buf.c_lflag )
      printf("%s:", *(const char **)&buf.c_cc[27]);
    printf("%d\n", v6);
  }
  if ( (dword_7DBC0 & 0x1000) != 0 )
    puts(*(const char **)&buf.c_cc[27]);
  return v6;
}
// 55498: variable 'a2' is possibly undefined
// 55844: variable 'v10' is possibly undefined
// 558B0: variable 'v36' is possibly undefined
// 558C8: variable 'v37' is possibly undefined
// 558F0: variable 'v3' is possibly undefined
// 55980: variable 'v38' is possibly undefined
// 134F8: using guessed type int __fastcall strcasestr(_DWORD, _DWORD);
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00055A24) --------------------------------------------------------
int __fastcall sub_55A24(const char *a1, int a2, _DWORD *a3)
{
  FILE *v6; // r0
  int v7; // r1
  int v8; // r2
  FILE *v9; // r7
  __int16 v10; // [sp+10h] [bp-5Ch]

  if ( (*(_DWORD *)(a2 + 16) & 0xF000) == 0xA000 )
  {
    if ( sub_62DFC() )
    {
      if ( (dword_7DBC0 & 0x10) == 0 )
        sub_16B80(a1);
      return 0;
    }
    if ( (v10 & 0xF000) == 0x4000 )
      return 1;
  }
  v6 = (FILE *)sub_61C9C((int)a1);
  v9 = v6;
  if ( v6 )
  {
    *(_DWORD *)&buf.c_cc[27] = a1;
    *a3 += sub_55478(v6, v7, v8);
    fclose(v9);
    return 1;
  }
  if ( (dword_7DBC0 & 0x10) == 0 )
    sub_16B80(a1);
  buf.c_line = 1;
  buf.c_cc[0] = 0;
  buf.c_cc[1] = 0;
  buf.c_cc[2] = 0;
  return 0;
}
// 55A7C: variable 'v10' is possibly undefined
// 55AD4: variable 'v7' is possibly undefined
// 55AD4: variable 'v8' is possibly undefined
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00055AFC) --------------------------------------------------------
unsigned int __fastcall sub_55AFC(int a1, char **a2)
{
  int v3; // r0
  _DWORD *v4; // r7
  _DWORD *i; // r0
  int v6; // r1
  char **v7; // r7
  char *v8; // r6
  int v9; // r8
  _DWORD *v10; // r0
  int v11; // r7
  _DWORD *v12; // r9
  int v13; // r1
  int v14; // r2
  FILE *v15; // r7
  _BYTE *v16; // r10
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  int v20; // r2
  unsigned int v21; // r6
  char *v22; // r0
  bool v23; // zf
  FILE *v24; // r11
  char *v25; // t1
  unsigned int result; // r0
  _DWORD *v27; // [sp+14h] [bp-78h] BYREF
  int v28; // [sp+18h] [bp-74h] BYREF
  int v29; // [sp+1Ch] [bp-70h] BYREF
  int v30; // [sp+30h] [bp-5Ch]

  v27 = 0;
  byte_7D5F8 = 2;
  v3 = sub_593CC(
         a2,
         "^lnqvscFiHhe:*f:*Lorm:+wxA:+B:+C:+EaI",
         &buf.c_cc[23],
         &v27,
         &buf,
         &buf.c_cc[11],
         &buf.c_cc[7],
         &v28);
  if ( (v3 & 0x100000) != 0 )
  {
    if ( (v3 & 0x40000) == 0 )
      *(_DWORD *)&buf.c_cc[11] = v28;
    if ( (v3 & 0x80000) == 0 )
      *(_DWORD *)&buf.c_cc[7] = v28;
  }
  if ( (v3 & 0x1025) != 0 )
  {
    dword_7DBC0 &= ~2u;
    buf.c_cc[7] = 0;
    buf.c_cc[8] = 0;
    buf.c_cc[9] = 0;
    buf.c_cc[10] = 0;
    buf.c_cc[11] = 0;
    buf.c_cc[12] = 0;
    buf.c_cc[13] = 0;
    buf.c_cc[14] = 0;
  }
  else if ( *(int *)&buf.c_cc[7] > 0 )
  {
    if ( *(int *)&buf.c_cc[7] > 0xFFFFFFF )
    {
      buf.c_cc[7] = -1;
      buf.c_cc[8] = -1;
      buf.c_cc[9] = -1;
      buf.c_cc[10] = 15;
    }
    *(_DWORD *)&buf.c_cc[15] = sub_174DC(4 * *(_DWORD *)&buf.c_cc[7]);
  }
  v4 = *(_DWORD **)&buf.c_cc[23];
  buf.c_cflag = ((unsigned int)dword_7DBC0 >> 3) & 1;
  while ( v4 )
  {
    v9 = v4[1];
    v10 = sub_174DC(0x30u);
    *v10 = v9;
    v4[1] = v10;
    v4 = (_DWORD *)*v4;
  }
  if ( (dword_7DBC0 & 0x800) != 0 )
  {
    for ( i = v27; i; i = v12 )
    {
      v11 = i[1];
      v12 = (_DWORD *)*i;
      free(i);
      v15 = (FILE *)sub_61D20(v11);
      while ( 1 )
      {
        v16 = sub_58D24(v15, v13, v14);
        if ( !v16 )
          break;
        v18 = sub_174DC(0x30u);
        *v18 = v16;
        sub_5D2A0((int *)&buf.c_cc[23], (int)v18);
      }
      sub_5888C(v15);
    }
    if ( !*(_DWORD *)&buf.c_cc[23] )
    {
      v17 = sub_174DC(0x30u);
      *v17 = "";
      sub_5D2A0((int *)&buf.c_cc[23], (int)v17);
      buf.c_cflag ^= 1u;
    }
  }
  v6 = dword_7DB90;
  if ( *(_BYTE *)dword_7DB90 == 102 )
    dword_7DBC0 |= 0x40u;
  if ( (dword_7DBC0 & 0x32000) == 0 )
    buf.c_oflag = 8;
  if ( *(_BYTE *)dword_7DB90 == 101 || (dword_7DBC0 & 0x200000) != 0 )
    buf.c_oflag |= 1u;
  if ( (dword_7DBC0 & 0x80) != 0 )
    buf.c_oflag |= 2u;
  v7 = &a2[optind];
  v8 = *v7;
  if ( !*(_DWORD *)&buf.c_cc[23] )
  {
    if ( !v8 )
      sub_162F0();
    ++v7;
    v19 = sub_174DC(0x30u);
    *v19 = v8;
    sub_5D2A0((int *)&buf.c_cc[23], (int)v19);
  }
  if ( *v7 && v7[1] )
    buf.c_lflag = 1;
  v20 = dword_7DBC0;
  v21 = 0;
  if ( (dword_7DBC0 & 0x100) != 0 )
  {
    v6 = 1;
    buf.c_lflag = 1;
  }
  if ( (dword_7DBC0 & 0x200) != 0 )
    buf.c_lflag = 0;
  do
  {
    v22 = *v7;
    v23 = *v7 == 0;
    *(_DWORD *)&buf.c_cc[27] = *v7;
    v24 = (FILE *)stdin;
    if ( v23 || *v22 == 45 && !v22[1] )
    {
      *(_DWORD *)&buf.c_cc[27] = "(standard input)";
LABEL_48:
      v21 += sub_55478(v24, v6, v20);
      sub_5888C(v24);
      goto LABEL_55;
    }
    if ( (dword_7DBC0 & 0x4000) != 0 && !sub_62DFC() && (v30 & 0xF000) == 0x4000 )
    {
      if ( (dword_7DBC0 & 0x200) == 0 )
        buf.c_lflag = 1;
      v29 = 0;
      sub_60474(*(const char **)&buf.c_cc[27], 13, (int (*)())sub_55A24, 0, (int)&v29, 0);
      v21 += v29;
    }
    else
    {
      v24 = (FILE *)sub_61C9C(*(int *)&buf.c_cc[27]);
      if ( v24 )
        goto LABEL_48;
      if ( (dword_7DBC0 & 0x10) == 0 )
        sub_16B80(*(const char **)&buf.c_cc[27]);
      v20 = 1;
      buf.c_line = 1;
      buf.c_cc[0] = 0;
      buf.c_cc[1] = 0;
      buf.c_cc[2] = 0;
    }
LABEL_55:
    if ( !*v7 )
      break;
    v25 = v7[1];
    ++v7;
  }
  while ( v25 );
  if ( *(_DWORD *)&buf.c_line )
    result = 2;
  else
    result = __clz(v21);
  if ( !*(_DWORD *)&buf.c_line )
    result >>= 5;
  return result;
}
// 55CE0: variable 'v13' is possibly undefined
// 55CE0: variable 'v14' is possibly undefined
// 55E18: variable 'v6' is possibly undefined
// 55E18: variable 'v20' is possibly undefined
// 7D5F8: using guessed type char byte_7D5F8;
// 7D604: using guessed type int optind;
// 7D610: using guessed type int stdin;
// 7DB90: using guessed type int dword_7DB90;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (00055F3C) --------------------------------------------------------
tcflag_t __fastcall sub_55F3C(int a1)
{
  tcflag_t result; // r0
  int v3; // r3

  result = buf.c_iflag;
  if ( !buf.c_cc[3] )
  {
    result = (tcflag_t)sub_174B4((void *)buf.c_iflag, 4 * (*(_DWORD *)&buf.c_cc[3] + 256));
    buf.c_iflag = result;
  }
  v3 = (*(_DWORD *)&buf.c_cc[3])++;
  *(_DWORD *)(buf.c_iflag + 4 * v3) = a1;
  return result;
}

//----- (00055F84) --------------------------------------------------------
const char *__fastcall sub_55F84(int a1, int a2, const char *a3)
{
  int i; // r6
  void *v6; // r0
  const char *v7; // r4
  char *v8; // r6
  int v9; // r0
  int v11; // r1
  char *v12; // r6
  int j; // r4

  for ( i = 0; buf.c_iflag; i += 4 )
  {
    v6 = *(void **)(buf.c_iflag + i);
    if ( !v6 )
      break;
    if ( *(void **)(buf.c_oflag + i) != v6 )
      free(v6);
  }
  v7 = &a3[a1];
  v8 = (char *)a3;
  while ( 1 )
  {
    v9 = getchar_unlocked();
    if ( v9 == -1 || LOBYTE(buf.c_lflag) == v9 )
    {
      if ( v8 == a3 )
        goto LABEL_19;
      v9 = 0;
    }
    *v8++ = v9;
    if ( !v9 )
      break;
    if ( v7 == v8 )
      goto LABEL_11;
  }
  for ( j = 0; ; j += 4 )
  {
    v12 = *(char **)(buf.c_oflag + j);
    if ( !v12 )
      break;
    v11 = sub_608E0(*(const char **)(buf.c_oflag + j), (char *)buf.c_cflag);
    if ( v11 )
      v12 = sub_60924(v12, v11, (char *)buf.c_cflag, a3);
    sub_55F3C((int)v12);
  }
LABEL_19:
  v7 = a3;
LABEL_11:
  *v7 = 0;
  return a3;
}

//----- (00056078) --------------------------------------------------------
char *__fastcall sub_56078(int a1, int a2, char *s)
{
  char *v3; // r4
  char *v5; // r6
  char *v6; // r5
  int v7; // r0
  int v8; // r0

  v3 = s;
  v5 = &s[a1];
  v6 = &s[strlen(s)];
  while ( 1 )
  {
    v7 = getchar_unlocked();
    if ( v7 == -1 )
      break;
LABEL_5:
    *v6++ = v7;
    if ( !v7 )
    {
      v8 = (int)v3;
      v3 = v6;
      sub_55F3C(v8);
      if ( !--a2 )
        goto LABEL_8;
    }
    if ( v5 == v6 )
      goto LABEL_8;
  }
  if ( v3 != v6 )
  {
    v7 = 0;
    goto LABEL_5;
  }
  v6 = v3;
LABEL_8:
  *v6 = 0;
  return v3;
}

//----- (000560F0) --------------------------------------------------------
const char *__fastcall sub_560F0(int a1, int a2, char *s)
{
  const char *v3; // r4
  int v4; // r6
  char *v6; // r8
  int v7; // r7
  char *v8; // r5
  int v9; // r0
  const char *v11; // r11
  const char *v12; // r1
  bool v13; // cc
  bool v14; // zf

  v3 = s;
  v4 = 0;
  v6 = &s[a1];
  v7 = 0;
  v8 = &s[strlen(s)];
  while ( 1 )
  {
    v9 = getchar_unlocked();
    if ( v9 == -1 )
    {
      if ( v3 == v8 )
        goto LABEL_4;
LABEL_28:
      LOBYTE(v9) = 0;
      v4 = 4;
      goto LABEL_10;
    }
    if ( v4 == 2 )
    {
      v4 = 0;
      goto LABEL_10;
    }
    if ( v4 == 1 )
      break;
    v13 = (unsigned __int8)v9 > 0x20u;
    if ( (unsigned __int8)v9 != 32 )
      v13 = (unsigned int)(unsigned __int8)v9 - 9 > 4;
    if ( v13 )
    {
      if ( v9 == 92 )
      {
        v4 = 2;
        goto LABEL_19;
      }
      v14 = v9 == 34;
      if ( v9 != 34 )
        v14 = v9 == 39;
      if ( !v14 )
        goto LABEL_10;
      v7 = (unsigned __int8)v9;
      v4 = 1;
    }
    else if ( v3 != v8 )
    {
      goto LABEL_28;
    }
LABEL_19:
    if ( v6 == v8 )
      goto LABEL_5;
  }
  if ( v7 == v9 )
  {
    v7 = 0;
LABEL_34:
    v4 = 0;
    goto LABEL_19;
  }
LABEL_10:
  v11 = v8 + 1;
  *v8 = v9;
  if ( v4 != 4 )
  {
    ++v8;
    goto LABEL_19;
  }
  if ( v7 )
  {
    v12 = "single";
    if ( v7 != 39 )
      v12 = "double";
    sub_16DBC("unmatched %s quote", v12);
  }
  if ( !*(_DWORD *)&buf.c_line || strcmp(v3, *(const char **)&buf.c_line) )
  {
    ++v8;
    sub_55F3C((int)v3);
    --a2;
    v3 = v11;
    if ( !a2 )
      goto LABEL_5;
    goto LABEL_34;
  }
  while ( getchar_unlocked() != -1 )
    ;
LABEL_4:
  v8 = (char *)v3;
LABEL_5:
  *v8 = 0;
  return v3;
}

//----- (00056258) --------------------------------------------------------
int __fastcall sub_56258(int a1, int a2, int a3)
{
  int result; // r0
  __pid_t v4; // r0
  int v5; // r3
  int v6; // r2
  int stat_loc[2]; // [sp+4h] [bp-8h] BYREF

  stat_loc[0] = a2;
  stat_loc[1] = a3;
  if ( *(_DWORD *)&buf.c_cc[11] == 1 )
  {
    result = sub_61B38((const char **)buf.c_iflag);
  }
  else
  {
    while ( 1 )
    {
      v4 = *(int *)&buf.c_cc[7] < *(int *)&buf.c_cc[11] ? sub_173DC(stat_loc) : sub_17398(-1, stat_loc, 0);
      if ( v4 <= 0 )
        break;
      v5 = *(_DWORD *)&buf.c_cc[7];
      if ( *(_DWORD *)&buf.c_cc[7] )
        v5 = *(_DWORD *)&buf.c_cc[7] - 1;
      v6 = stat_loc[0] & 0x7F;
      if ( *(_DWORD *)&buf.c_cc[7] )
        *(_DWORD *)&buf.c_cc[7] = v5;
      if ( (v6 + 1) << 24 >> 25 <= 0 )
        result = BYTE1(stat_loc[0]);
      else
        result = v6 + 384;
      if ( (unsigned int)(result - 1) > 0xFD )
      {
        if ( result )
          goto LABEL_3;
      }
      else
      {
        buf.c_cc[16] = 0;
        buf.c_cc[15] = 123;
        buf.c_cc[17] = 0;
        buf.c_cc[18] = 0;
      }
    }
    result = *(_DWORD *)&buf.c_cc[11];
    if ( !*(_DWORD *)&buf.c_cc[11] )
      return result;
    result = sub_61AB4((const char **)buf.c_iflag);
    if ( result > 0 )
    {
      result = 0;
      ++*(_DWORD *)&buf.c_cc[7];
      return result;
    }
  }
LABEL_3:
  if ( result < 0 )
  {
    sub_16B80(*(const char **)buf.c_iflag);
    if ( *(_DWORD *)dword_7DB94 == 2 )
      result = 127;
    else
      result = 126;
    goto LABEL_7;
  }
  if ( result >= 384 )
  {
    sub_16DDC("'%s' terminated by signal %d", *(const char **)buf.c_iflag, result - 384);
    result = 125;
LABEL_7:
    *(_DWORD *)&buf.c_cc[15] = result;
    return result;
  }
  if ( result )
  {
    if ( result == 255 )
    {
      sub_16DDC("%s: exited with status 255; aborting", *(const char **)buf.c_iflag);
      return 124;
    }
    else
    {
      buf.c_cc[15] = 123;
      buf.c_cc[16] = 0;
      buf.c_cc[17] = 0;
      buf.c_cc[18] = 0;
      return 0;
    }
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (000563E4) --------------------------------------------------------
int __fastcall sub_563E4(int a1, char **a2)
{
  int v3; // r5
  int v4; // r0
  int (__fastcall *v5)(int, unsigned int, void *); // r7
  char **v6; // r9
  signed int v7; // r0
  int v8; // r6
  unsigned int v9; // r6
  char **v10; // r11
  int v11; // r8
  char **v12; // r10
  const char *v13; // r0
  const char *v14; // t1
  int v15; // r6
  void *v16; // r8
  unsigned int v17; // r10
  int v18; // r11
  _BYTE *v19; // r9
  int v20; // r0
  int v21; // r1
  int v22; // r2
  int v23; // r0
  int v24; // t1
  int v25; // r2
  tcflag_t v26; // r5
  const char *i; // r1
  int v28; // t1
  int v30; // [sp+20h] [bp-1Ch]
  int v31; // [sp+24h] [bp-18h]
  int v32; // [sp+2Ch] [bp-10h] BYREF
  int v33; // [sp+30h] [bp-Ch] BYREF
  const char *v34; // [sp+34h] [bp-8h] BYREF

  buf.c_cc[11] = 1;
  v34 = 0;
  buf.c_cflag = (tcflag_t)"{}";
  LOBYTE(buf.c_lflag) = 10;
  buf.c_line = 0;
  buf.c_cc[0] = 0;
  buf.c_cc[1] = 0;
  buf.c_cc[2] = 0;
  buf.c_cc[3] = 0;
  buf.c_cc[4] = 0;
  buf.c_cc[5] = 0;
  buf.c_cc[6] = 0;
  buf.c_cc[7] = 0;
  buf.c_cc[8] = 0;
  buf.c_cc[9] = 0;
  buf.c_cc[10] = 0;
  buf.c_cc[12] = 0;
  buf.c_cc[13] = 0;
  buf.c_cc[14] = 0;
  buf.c_cc[15] = 0;
  buf.c_cc[16] = 0;
  buf.c_cc[17] = 0;
  buf.c_cc[18] = 0;
  v3 = sub_593F8(
         a2,
         "+trn:s:e::E:x0I:i::P:+a:",
         "no-run-if-empty",
         &v32,
         &v33,
         &buf.c_line,
         &buf.c_line,
         &buf.c_cflag,
         &buf.c_cflag,
         &buf.c_cc[11],
         &v34);
  if ( *(int *)&buf.c_cc[11] <= 0 )
  {
    buf.c_cc[12] = 0;
    buf.c_cc[11] = 100;
    buf.c_cc[13] = 0;
    buf.c_cc[14] = 0;
  }
  if ( v34 )
  {
    v4 = sub_175D8(v34, 0);
    sub_176A8(v4, 0);
  }
  if ( (v3 & 0x20) != 0 && !**(_BYTE **)&buf.c_line )
  {
    buf.c_line = 0;
    buf.c_cc[0] = 0;
    buf.c_cc[1] = 0;
    buf.c_cc[2] = 0;
  }
  if ( (v3 & 0x80) != 0 )
  {
    v5 = (int (__fastcall *)(int, unsigned int, void *))sub_56078;
    LOBYTE(buf.c_lflag) = 0;
  }
  else
  {
    v5 = (int (__fastcall *)(int, unsigned int, void *))sub_560F0;
  }
  v6 = &a2[optind];
  if ( !*v6 )
    *--v6 = "echo";
  v7 = sub_60F68();
  if ( v7 >= 0x8000 )
    v8 = 0x8000;
  else
    v8 = v7;
  v9 = v8 - 2048;
  if ( (v3 & 8) != 0 )
    v9 = sub_6206C((const char *)v33, 1u, 0x7FFFFFFFu);
  v10 = v6 - 1;
  v11 = 0;
  v12 = v6 - 1;
  while ( 1 )
  {
    v14 = v12[1];
    ++v12;
    v13 = v14;
    if ( !v14 )
      break;
    v11 += strlen(v13) + 1;
  }
  v15 = v9 - v11;
  if ( v15 <= 0 )
    sub_16DBC("can't fit single argument within argument list size limit");
  v16 = sub_174DC(v15 + 1);
  if ( (v3 & 4) != 0 )
    v17 = sub_6206C((const char *)v32, 1u, 0x7FFFFFFFu);
  else
    v17 = v15;
  if ( (v3 & 0x300) != 0 )
  {
    v5 = (int (__fastcall *)(int, unsigned int, void *))sub_55F84;
    v3 |= 2u;
    buf.c_oflag = (tcflag_t)v6;
    buf.c_iflag = 0;
  }
  else
  {
    while ( 1 )
    {
      v24 = (int)v10[1];
      ++v10;
      v23 = v24;
      if ( !v24 )
        break;
      sub_55F3C(v23);
    }
  }
  v18 = *(_DWORD *)&buf.c_cc[3];
  v30 = 4 * *(_DWORD *)&buf.c_cc[3];
  while ( 1 )
  {
    *(_DWORD *)&buf.c_cc[3] = v18;
    v19 = (_BYTE *)v5(v15, v17, v16);
    v20 = sub_55F3C(0);
    if ( !*(_DWORD *)(buf.c_iflag + v30) )
    {
      v22 = (unsigned __int8)*v19;
      if ( *v19 )
        sub_16DBC("argument line too long");
      if ( (v3 & 2) != 0 )
        break;
    }
    v25 = v3 | 2;
    v31 = v3 | 2;
    if ( (v3 & 1) != 0 )
    {
      v26 = buf.c_iflag - 4;
      for ( i = "%s"; ; i = " %s" )
      {
        v28 = *(_DWORD *)(v26 + 4);
        v26 += 4;
        if ( !v28 )
          break;
        fprintf((FILE *)stderr, i);
      }
      v20 = sub_170EC(10, (int)i, 0);
    }
    v20 = sub_56258(v20, v21, v25);
    if ( v20 )
      break;
    sub_60B4C((int)v16, (int)v19);
    v3 = v31;
  }
  buf.c_cc[11] = 0;
  buf.c_cc[12] = 0;
  buf.c_cc[13] = 0;
  buf.c_cc[14] = 0;
  sub_56258(v20, v21, v22);
  return *(_DWORD *)&buf.c_cc[15];
}
// 5667C: variable 'v21' is possibly undefined
// 5667C: variable 'v25' is possibly undefined
// 566DC: variable 'v22' is possibly undefined
// 7D604: using guessed type int optind;
// 7D608: using guessed type int stderr;

//----- (00056724) --------------------------------------------------------
int sub_56724()
{
  _DWORD v1[96]; // [sp+0h] [bp-30Ch] BYREF
  struct utsname name; // [sp+180h] [bp-18Ch] BYREF

  memset(v1, 0, sizeof(v1));
  v1[85] = time(0);
  strcpy((char *)&v1[11], "shutdown");
  LOWORD(v1[0]) = 1;
  LOWORD(v1[10]) = 32382;
  LOWORD(v1[2]) = 32382;
  uname(&name);
  sub_60B34((char *)&v1[19], name.release, 256);
  return updwtmpx("/var/log/wtmp", v1);
}
// 13F1C: using guessed type int __fastcall updwtmpx(_DWORD, _DWORD);

//----- (000567A0) --------------------------------------------------------
int __fastcall sub_567A0(int a1, char **a2, unsigned int a3)
{
  int v3; // r4
  char v4; // r5
  __pid_t v5; // r0
  int v6; // r6
  int v7; // r4
  int v8; // r5
  int v10; // r0
  unsigned int seconds[2]; // [sp+4h] [bp-8h] BYREF

  seconds[1] = a3;
  v3 = 0;
  seconds[0] = 0;
  while ( aHpr[v3] != *(_BYTE *)dword_7DB90 )
    ++v3;
  v4 = sub_593CC(a2, "d:+nfwi", seconds);
  sleep(seconds[0]);
  sub_56724();
  if ( (v4 & 8) == 0 )
  {
    if ( (v4 & 2) == 0 )
      sync();
    if ( (v4 & 4) != 0 )
    {
      v10 = reboot(dword_63EA4[v3]);
LABEL_12:
      v8 = v10;
    }
    else
    {
      v5 = *(_DWORD *)sub_58B44("linuxrc");
      v6 = dword_63EB0[v3];
      if ( v5 > 0 && !kill(v5, dword_63EB0[v3]) )
        return 0;
      v7 = 4;
      v8 = kill(1, v6);
      while ( access("/proc/meminfo", 0) )
      {
        if ( v7-- == 0 )
          goto LABEL_11;
        sleep(1u);
      }
      if ( v7 != 4 )
      {
LABEL_11:
        v10 = kill(1, v6);
        goto LABEL_12;
      }
    }
    if ( v8 )
      sub_5E304();
  }
  return 0;
}
// 63EA4: using guessed type _DWORD dword_63EA4[3];
// 63EB0: using guessed type _DWORD dword_63EB0[3];
// 7DB90: using guessed type int dword_7DB90;

//----- (000568D8) --------------------------------------------------------
unsigned int sub_568D8()
{
  return sleep(0x278D00u);
}

//----- (000568E4) --------------------------------------------------------
int sub_568E4()
{
  struct termios termios_p; // [sp+4h] [bp-40h] BYREF

  tcgetattr(0, &termios_p);
  termios_p.c_cc[8] = 17;
  termios_p.c_cc[9] = 19;
  termios_p.c_cc[10] = 26;
  termios_p.c_iflag = 5376;
  termios_p.c_oflag = 5;
  *(_DWORD *)&termios_p.c_line = 2132542208;
  *(_WORD *)&termios_p.c_cc[3] = 1045;
  termios_p.c_cflag = termios_p.c_cflag & 0x8000137F | 0xC80;
  termios_p.c_lflag = 35387;
  return sub_1729C(&termios_p);
}

//----- (00056964) --------------------------------------------------------
char *__fastcall sub_56964(char a1, char *s2, const char *a3)
{
  struct termios *v4; // r5
  tcflag_t i; // r4
  size_t v8; // r0

  v4 = &buf;
  for ( i = buf.c_iflag; ; i = *(_DWORD *)i )
  {
    if ( !i )
    {
      v8 = strlen(s2);
      i = (tcflag_t)sub_174DC(v8 + 44);
      goto LABEL_9;
    }
    if ( !strcmp((const char *)(i + 41), s2) && !strcmp((const char *)(i + 9), a3) )
      break;
    v4 = (struct termios *)i;
  }
  for ( v4->c_iflag = *(_DWORD *)i; v4->c_iflag; v4 = (struct termios *)v4->c_iflag )
    ;
  *(_DWORD *)i = 0;
LABEL_9:
  v4->c_iflag = i;
  *(_BYTE *)(i + 8) = a1;
  strcpy((char *)(i + 41), s2);
  return sub_60B34((char *)(i + 9), a3, 32);
}

//----- (00056A1C) --------------------------------------------------------
void __fastcall __noreturn sub_56A1C(int a1)
{
  sleep(1u);
  if ( !vfork() )
  {
    reboot(a1);
    exit(0);
  }
  while ( 1 )
    sleep(1u);
}

//----- (00056A58) --------------------------------------------------------
int sub_56A58()
{
  sub_18184((__sighandler_t)0x18940E, 0);
  return sub_18158(1);
}

//----- (00056A78) --------------------------------------------------------
_DWORD *__fastcall sub_56A78(__pid_t a1)
{
  _DWORD *result; // r0

  if ( a1 > 0 )
  {
    sub_617C8(a1);
    for ( result = (_DWORD *)buf.c_iflag; result; result = (_DWORD *)*result )
    {
      if ( result[1] == a1 )
      {
        result[1] = 0;
        return result;
      }
    }
  }
  return 0;
}

//----- (00056AC4) --------------------------------------------------------
__sighandler_t sub_56AC4()
{
  _DWORD *v0; // r5
  int v1; // r6
  int v2; // r7
  __pid_t v3; // r0
  __sighandler_t result; // r0

  v0 = (_DWORD *)dword_7DB94;
  v1 = dword_7DBA0;
  v2 = *(_DWORD *)dword_7DB94;
  signal(18, sub_18140);
  while ( dword_7DBA0 != 18 )
  {
    v3 = sub_173DC(0);
    sub_56A78(v3);
    sleep(1u);
  }
  result = signal(18, 0);
  *v0 = v2;
  dword_7DBA0 = v1;
  return result;
}
// 7DB94: using guessed type int dword_7DB94;
// 7DBA0: using guessed type int dword_7DBA0;

//----- (00056B2C) --------------------------------------------------------
void sub_56B2C(char a1, const char *a2, ...)
{
  unsigned int v3; // r0
  int v4; // r4
  char buf; // [sp+8h] [bp-84h] BYREF
  char s[147]; // [sp+9h] [bp-83h] BYREF
  va_list varg_r2; // [sp+A0h] [bp+14h] BYREF

  va_start(varg_r2, a2);
  buf = 13;
  v3 = vsnprintf(s, 0x7Eu, a2, varg_r2) + 1;
  if ( v3 >= 0x7E )
    v4 = 126;
  else
    v4 = v3;
  s[v4 - 1] = 0;
  if ( (a1 & 1) != 0 )
  {
    openlog((const char *)dword_7DB90, 0, 24);
    syslog(6, "%s", s);
    closelog();
  }
  s[v4 - 1] = 10;
  s[v4] = 0;
  if ( (a1 & 2) != 0 )
    sub_17FB8(2, &buf, v4 + 1);
}
// 7DB90: using guessed type int dword_7DB90;

//----- (00056BF0) --------------------------------------------------------
void sub_56BF0()
{
  _DWORD *v0; // r5
  unsigned __int8 *v1; // r4
  int v2; // r0
  char v3; // r9
  unsigned __int8 *v4; // r0
  _DWORD v5[3]; // [sp+0h] [bp-14h] BYREF
  char *v6; // [sp+Ch] [bp-8h]

  v0 = sub_5DDC4((int)"/etc/inittab", (int (*)(void))sub_61C9C);
  if ( v0 )
  {
    while ( sub_5DE1C(v0, v5, 4456452, "#:") )
    {
      v1 = (unsigned __int8 *)v5[0];
      if ( v6 && (v2 = sub_16880("sysinit", (char *)v5[2]), v3 = v2, v2 >= 0) && *v6 )
      {
        if ( *v1 )
        {
          v4 = sub_60EB8(v1);
          v1 = (unsigned __int8 *)sub_16998("/dev/", v4);
        }
        sub_56964(1 << v3, v6, (const char *)v1);
        if ( *v1 )
          free(v1);
      }
      else
      {
        sub_56B2C(3, "Bad inittab entry at line %d", v0[6]);
      }
    }
    sub_5DDEC((int)v0);
  }
  else
  {
    sub_56964(1, "/etc/init.d/rcS", "");
    sub_56964(16, "-/bin/sh", "");
    sub_56964(16, "-/bin/sh", "/dev/tty2");
    sub_56964(16, "-/bin/sh", "/dev/tty3");
    sub_56964(16, "-/bin/sh", "/dev/tty4");
    sub_56964(32, "reboot", "");
    sub_56964(64, "umount -a -r", "");
    sub_56964(64, "swapoff -a", "");
    sub_56964(128, "init", "");
  }
}

//----- (00056DB8) --------------------------------------------------------
int __fastcall sub_56DB8(const char *a1)
{
  if ( *a1 )
  {
    close(0);
    if ( sub_586C8((int)a1, 2) )
    {
      sub_56B2C(3, "can't open %s: %m", a1);
      return 0;
    }
    dup2(0, 1);
    dup2(0, 2);
  }
  sub_568E4();
  return 1;
}

//----- (00056E24) --------------------------------------------------------
void __fastcall sub_56E24(const char *a1)
{
  int v2; // r9
  _BOOL4 v3; // r4
  char *v4; // r6
  char *v5; // r3
  const char *v6; // r4
  char *v7; // r0
  char *v8; // r0
  char *v9; // [sp+0h] [bp-2Ch] BYREF
  char *_4[11]; // [sp+4h] [bp-28h] BYREF

  strlen(a1);
  v2 = *(unsigned __int8 *)a1;
  v3 = v2 == 45;
  v4 = strpbrk(&a1[v3], "~`!$^&*()=|\\{}[];\"'<>?");
  if ( v4 )
  {
    sprintf((char *)&v9, "exec %s", &a1[v3]);
    v5 = "-/bin/sh";
    v6 = "/bin/sh";
    if ( v2 != 45 )
      v5 = "/bin/sh";
    v9 = v5;
    _4[0] = "-c";
    _4[1] = (char *)&v9;
    _4[2] = 0;
  }
  else
  {
    v7 = strcpy((char *)&v9, a1);
    v6 = &v7[v3];
    _4[0] = v7;
    while ( 1 )
    {
      v8 = strsep(_4, " \t");
      if ( !v8 )
        break;
      if ( *v8 )
        _4[(_DWORD)v4++ - 1] = v8;
    }
    _4[(_DWORD)v4 - 1] = 0;
  }
  if ( v2 == 45 )
    ioctl(0, 0x540Eu);
  execvp(v6, &v9);
  sub_56B2C(3, "can't run '%s': %m", v6);
}

//----- (00056F5C) --------------------------------------------------------
__pid_t __fastcall sub_56F5C(int a1)
{
  __pid_t v1; // r0
  __pid_t v2; // r4
  int v3; // r0
  __pid_t v4; // r0
  char buf; // [sp+17h] [bp-1h] BYREF

  sub_18158(0);
  if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0 )
    v1 = fork();
  else
    v1 = vfork();
  v2 = v1;
  if ( v1 < 0 )
    sub_56B2C(3, "can't fork");
  if ( !v2 )
  {
    sub_56A58();
    setsid();
    if ( sub_56DB8((const char *)(a1 + 9)) )
    {
      if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0 )
      {
        sub_17FB8(1, "\nPlease press Enter to activate this console. ", 0x2Eu);
        while ( sub_1800C(0, &buf, 1u) == 1 && buf != 10 )
          ;
      }
      v4 = getpid();
      sub_56B2C(1, "starting pid %u, tty '%s': '%s'", v4, (const char *)(a1 + 9), (const char *)(a1 + 41));
      sub_56E24((const char *)(a1 + 41));
      v3 = -1;
    }
    else
    {
      v3 = 1;
    }
    exit(v3);
  }
  sub_18158(1);
  return v2;
}

//----- (00057070) --------------------------------------------------------
__pid_t __fastcall sub_57070(__pid_t result)
{
  __pid_t v1; // r6
  tcflag_t i; // r4
  int v3; // r3
  __pid_t v4; // r5
  _BOOL4 v5; // r3
  bool j; // zf
  __pid_t v7; // r0

  v1 = result;
  for ( i = buf.c_iflag; i; i = *(_DWORD *)i )
  {
    v3 = *(unsigned __int8 *)(i + 8);
    if ( (v3 & v1) != 0 )
    {
      if ( (v3 & 0x67) != 0 )
      {
        result = sub_56F5C(i);
        v4 = result;
        v5 = (*(_BYTE *)(i + 8) & 0x63) == 0;
        if ( result <= 0 )
          v5 = 1;
        for ( j = !v5; j; j = result == 0 )
        {
          v7 = wait(0);
          sub_56A78(v7);
          result = kill(v4, 0);
        }
      }
      if ( (*(_BYTE *)(i + 8) & 0x18) != 0 && !*(_DWORD *)(i + 4) )
      {
        result = sub_56F5C(i);
        *(_DWORD *)(i + 4) = result;
      }
    }
  }
  return result;
}

//----- (00057118) --------------------------------------------------------
void sub_57118()
{
  sub_57070(64);
  sub_56B2C(3, "The system is going down NOW!");
  kill(-1, 15);
  sub_56B2C(2, "Sent SIG%s to all processes", "TERM");
  sync();
  sleep(1u);
  kill(-1, 9);
  sub_56B2C(2, "Sent SIG%s to all processes", "KILL");
  sync();
}

//----- (00057190) --------------------------------------------------------
int sub_57190()
{
  int result; // r0
  int v1; // r4
  tcflag_t i; // r3
  tcflag_t j; // r4
  struct termios *v4; // r4
  tcflag_t *c_iflag; // r0
  __pid_t v6; // r0
  bool v7; // zf
  int v8; // r4
  const char *v9; // r2
  int v10; // r0
  tcflag_t k; // r4

  for ( result = 0; ; result = 1 )
  {
    v1 = dword_7DBA0;
    if ( !dword_7DBA0 )
      break;
    dword_7DBA0 = 0;
    switch ( v1 )
    {
      case 1:
        sub_56B2C(1, "reloading /etc/inittab");
        for ( i = buf.c_iflag; i; i = *(_DWORD *)i )
          *(_BYTE *)(i + 8) = 0;
        sub_56BF0();
        for ( j = buf.c_iflag; j; j = *(_DWORD *)j )
        {
          if ( !*(_BYTE *)(j + 8) )
          {
            v6 = *(_DWORD *)(j + 4);
            if ( v6 )
              kill(v6, 15);
          }
        }
        v4 = &buf;
        while ( 1 )
        {
          c_iflag = (tcflag_t *)v4->c_iflag;
          if ( !v4->c_iflag )
            break;
          if ( (c_iflag[2] & 0xFE) != 0 || c_iflag[1] )
          {
            v4 = (struct termios *)v4->c_iflag;
          }
          else
          {
            v4->c_iflag = *c_iflag;
            free(c_iflag);
          }
        }
        break;
      case 2:
        sub_57070(32);
        break;
      case 3:
        for ( k = buf.c_iflag; ; k = *(_DWORD *)k )
        {
          if ( !k )
            goto LABEL_10;
          if ( *(char *)(k + 8) < 0 )
            break;
        }
        sub_56A58();
        sub_57118();
        reboot(-1985229329);
        if ( sub_56DB8((const char *)(k + 9)) )
          sub_56E24((const char *)(k + 41));
        v10 = -839974621;
LABEL_36:
        sub_56A1C(v10);
      default:
        if ( ((1073779712 >> v1) & 1) != 0 )
        {
          sub_56A58();
          sub_57118();
          if ( v1 == 15 )
          {
            v8 = 19088743;
            v9 = "reboot";
          }
          else
          {
            v7 = v1 == 12;
            v8 = 1126301404;
            v9 = "poweroff";
            if ( !v7 )
            {
              v8 = -839974621;
              v9 = "halt";
            }
          }
          sub_56B2C(2, "Requesting system %s", v9);
          v10 = v8;
          goto LABEL_36;
        }
        break;
    }
LABEL_10:
    ;
  }
  return result;
}
// 7DBA0: using guessed type int dword_7DBA0;

//----- (00057350) --------------------------------------------------------
int __fastcall sub_57350(int a1, const char **a2)
{
  const char *v2; // r0
  const char **v3; // r4
  char *v5; // r0
  int v6; // r0
  int v7; // r5
  char *v8; // r5
  char *v9; // r0
  const char *v10; // r1
  const char *v11; // r5
  size_t v12; // r0
  char *v13; // r1
  const char *v14; // t1
  int v15; // r4
  int v16; // r4
  _BOOL4 i; // r4
  int v18; // r0
  int v19; // r6
  const char *v20; // r0
  struct sigaction s; // [sp+4h] [bp-8Ch] BYREF

  v2 = a2[1];
  v3 = a2;
  if ( !v2 || strcmp(v2, "-q") )
  {
    sub_18158(0);
    if ( getpid() != 1 && *(_BYTE *)dword_7DB90 != 108 )
      sub_16DBC("must be run as PID 1");
    reboot(0);
    off_7DB9C = (int (*)(void))sub_568D8;
    v5 = getenv("CONSOLE");
    if ( v5 || (v5 = getenv("console")) != 0 )
    {
      v6 = open64(v5, 2306);
      v7 = v6;
      if ( v6 >= 0 )
      {
        dup2(v6, 0);
        dup2(v7, 1);
        sub_176A8(v7, 2);
      }
    }
    else
    {
      sub_61C40();
    }
    v8 = getenv("TERM");
    if ( ioctl(0, 0x5600u, &s) )
    {
      if ( !v8 || !strcmp(v8, "linux") )
      {
        v9 = "TERM=vt102";
LABEL_15:
        putenv(v9);
      }
    }
    else if ( !v8 )
    {
      v9 = "TERM=linux";
      goto LABEL_15;
    }
    sub_568E4();
    sub_178FC("/");
    setsid();
    putenv("HOME=/");
    putenv("PATH=/sbin:/usr/sbin:/bin:/usr/bin");
    putenv("SHELL=/bin/sh");
    putenv("USER=root");
    v10 = v3[1];
    if ( v10 )
      sub_17820("RUNLEVEL", v10);
    v11 = v3[1];
    if ( v11 && (!strcmp(v3[1], "single") || !strcmp(v11, "-s") || *v11 == 49 && !v11[1]) )
      sub_56964(8, "-/bin/sh", "");
    else
      sub_56BF0();
    v12 = strlen(*v3);
    strncpy((char *)*v3, "init", v12);
    while ( 1 )
    {
      v14 = v3[1];
      ++v3;
      v13 = (char *)v14;
      if ( !v14 )
        break;
      sub_5DB1C(v13);
    }
    memset(&s, 0, sizeof(s));
    sigfillset(&s.sa_mask);
    sigdelset(&s.sa_mask, 18);
    s.sa_handler = (__sighandler_t)sub_56AC4;
    sub_18150(20, &s);
    sub_18150(19, &s);
    sub_181C4(1073779726, sub_18140);
    sub_18158(1);
    sub_57070(1);
    sub_57190();
    sub_57070(2);
    sub_57190();
    sub_57070(4);
    while ( 1 )
    {
      v15 = sub_57190();
      sub_57070(24);
      v16 = v15 | sub_57190();
      sleep(1u);
      for ( i = (v16 | sub_57190()) != 0; ; i = 1 )
      {
        v18 = waitpid(-1, 0, i);
        v19 = v18;
        if ( v18 <= 0 )
          break;
        v20 = (const char *)sub_56A78(v18);
        if ( v20 )
          sub_56B2C(1, "process '%s' (pid %d) exited. Scheduling for restart.", v20 + 41, v19);
      }
    }
  }
  return kill(1, 1);
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7DB90: using guessed type int dword_7DB90;
// 7DB9C: using guessed type int (*off_7DB9C)(void);

//----- (000576AC) --------------------------------------------------------
bool __fastcall sub_576AC(FILE *a1)
{
  int v1; // r4
  int v3; // r0
  bool v4; // zf
  bool v6; // zf

  v1 = 0;
  sub_177D8();
  while ( 1 )
  {
    v3 = getc_unlocked(a1);
    v4 = v3 == 10;
    if ( v3 != 10 )
      v4 = v3 == -1;
    if ( v4 )
      break;
    if ( !v1 )
    {
      v6 = (unsigned __int8)v3 == 9;
      if ( (unsigned __int8)v3 != 9 )
        v6 = (unsigned __int8)v3 == 32;
      if ( !v6 )
        v1 = (unsigned __int8)v3 | 0x20;
    }
  }
  return v1 == 121;
}

//----- (00057700) --------------------------------------------------------
bool sub_57700()
{
  return sub_576AC((FILE *)stdin);
}
// 7D610: using guessed type int stdin;

//----- (00057710) --------------------------------------------------------
int __fastcall sub_57710(int a1)
{
  int v2; // r4

  v2 = (unsigned __int8)byte_7D783;
  free(*((void **)&unk_7D744 + (unsigned __int8)byte_7D783));
  *((_DWORD *)&unk_7D744 + v2) = a1;
  byte_7D783 = (v2 + 1) & 3;
  return a1;
}
// 7D783: using guessed type char byte_7D783;

//----- (00057750) --------------------------------------------------------
_BYTE *__fastcall sub_57750(int a1, unsigned int a2, int a3)
{
  int v6; // r5
  _BYTE *v7; // r4
  char *v8; // r0
  char *v9; // r8
  unsigned int v10; // r0
  int v11; // r3
  void *v12; // r0
  int v14; // r3
  bool v15; // zf
  struct termios v16; // [sp+0h] [bp-194h] BYREF
  struct termios termios_p; // [sp+3Ch] [bp-158h] BYREF
  struct sigaction act; // [sp+78h] [bp-11Ch] BYREF
  struct sigaction oact; // [sp+104h] [bp-90h] BYREF

  tcflush(a1, 0);
  fputs_unlocked(a3, stdout);
  sub_177D8();
  tcgetattr(a1, &termios_p);
  v16.c_iflag = termios_p.c_iflag;
  v16.c_oflag = termios_p.c_oflag;
  v16.c_cflag = termios_p.c_cflag;
  *(_DWORD *)&v16.c_line = *(_DWORD *)&termios_p.c_line;
  *(_DWORD *)&v16.c_cc[3] = *(_DWORD *)&termios_p.c_cc[3];
  *(_DWORD *)&v16.c_cc[7] = *(_DWORD *)&termios_p.c_cc[7];
  *(_DWORD *)&v16.c_cc[11] = *(_DWORD *)&termios_p.c_cc[11];
  *(_DWORD *)&v16.c_cc[15] = *(_DWORD *)&termios_p.c_cc[15];
  *(_DWORD *)&v16.c_cc[19] = *(_DWORD *)&termios_p.c_cc[19];
  *(_DWORD *)&v16.c_cc[23] = *(_DWORD *)&termios_p.c_cc[23];
  *(_DWORD *)&v16.c_cc[27] = *(_DWORD *)&termios_p.c_cc[27];
  v16.c_lflag = termios_p.c_lflag & 0xFFFFFF87;
  *(_DWORD *)&v16.c_cc[31] = *(_DWORD *)&termios_p.c_cc[31];
  v16.c_ispeed = termios_p.c_ispeed;
  v16.c_ospeed = termios_p.c_ospeed;
  tcsetattr(a1, 0, &v16);
  memset(&act.sa_mask, 0, 0x88u);
  act.sa_handler = (__sighandler_t)nullsub_1;
  sigaction(2, &act, &oact);
  if ( a2 )
  {
    sub_18150(14, &act);
    alarm(a2);
  }
  v6 = 0;
  v7 = 0;
  do
  {
    v8 = (char *)sub_174B4(v7, v6 + 2);
    v9 = &v8[v6];
    v7 = v8;
    v10 = read(a1, &v8[v6], 1u);
    if ( v6 | v10 )
      v11 = v10 >> 31;
    else
      v11 = 1;
    if ( v11 )
    {
      *v9 = 0;
      sub_5DB1C(v7);
      v12 = v7;
      v7 = 0;
      free(v12);
      goto LABEL_9;
    }
    if ( !v10 )
      break;
    v14 = (unsigned __int8)*v9;
    v15 = v14 == 10;
    if ( v14 != 10 )
      v15 = v14 == 13;
    if ( v15 )
      break;
    ++v6;
  }
  while ( v6 != 4095 );
  v7[v6] = 0;
LABEL_9:
  if ( a2 )
    alarm(0);
  sub_18150(2, &oact);
  tcsetattr(a1, 0, &termios_p);
  j_putchar_unlocked(10);
  sub_177D8();
  return v7;
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 5774C: using guessed type int nullsub_1();
// 7D614: using guessed type int stdout;

//----- (000578F0) --------------------------------------------------------
_BYTE *__fastcall sub_578F0(int a1)
{
  return sub_57750(0, 0, a1);
}

//----- (00057900) --------------------------------------------------------
unsigned int __fastcall sub_57900(int a1, unsigned int a2)
{
  return bswap32(a2);
}

//----- (00057910) --------------------------------------------------------
int __fastcall sub_57910(int *a1)
{
  int *v1; // r4
  int v2; // r5
  int v3; // r0
  int v4; // r6
  int v5; // t1
  int v7; // r9

  v1 = a1;
  v2 = 0;
  if ( !*a1 )
    v1 = (int *)&off_63F54;
  do
  {
    v3 = sub_61D34(*v1);
    v4 = v3;
    if ( v3 < 0 )
      goto LABEL_4;
    v7 = (unsigned __int64)sub_17FAC(v3, 1) >> 32;
    if ( v4 )
      close(v4);
    if ( v7 < 0 )
LABEL_4:
      v2 = 1;
    v5 = v1[1];
    ++v1;
  }
  while ( v5 );
  return v2;
}
// 63F54: using guessed type _UNKNOWN *off_63F54;

//----- (00057988) --------------------------------------------------------
signed int __fastcall sub_57988(signed int a1)
{
  time_t v2; // r5
  signed int result; // r0

  v2 = time(0);
  do
  {
    sleep(a1);
    result = time(0) - v2;
  }
  while ( result < a1 );
  return result;
}

//----- (000579BC) --------------------------------------------------------
void *__fastcall sub_579BC(int *a1, void *a2)
{
  int v3; // r5
  int v5; // r0

  if ( a1 )
  {
    v3 = *a1;
    if ( *a1 < 32 )
      v3 = 32;
  }
  else
  {
    v3 = 32;
  }
  while ( 1 )
  {
    a2 = sub_174B4(a2, 4 * (v3 + 1));
    v5 = getgroups(v3, (__gid_t *)a2);
    if ( v5 >= 0 )
      break;
    if ( *(_DWORD *)dword_7DB94 != 22 )
      sub_16B40("getgroups");
    v3 = getgroups(0, (__gid_t *)a2);
  }
  *((_DWORD *)a2 + v5) = -1;
  if ( a1 )
    *a1 = v5;
  return a2;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00057A54) --------------------------------------------------------
int __fastcall sub_57A54(int a1, struct sockaddr *a2, socklen_t a3)
{
  socklen_t v4[2]; // [sp+4h] [bp-8h] BYREF

  v4[1] = a3;
  v4[0] = a3;
  return getsockname(a1, a2, v4);
}

//----- (00057A70) --------------------------------------------------------
struct passwd *__fastcall sub_57A70(const char *a1)
{
  struct passwd *result; // r0

  result = getpwnam(a1);
  if ( !result )
    sub_16DBC("unknown user %s", a1);
  return result;
}

//----- (00057A94) --------------------------------------------------------
struct group *__fastcall sub_57A94(const char *a1)
{
  struct group *result; // r0

  result = getgrnam(a1);
  if ( !result )
    sub_16DBC("unknown group %s", a1);
  return result;
}

//----- (00057AB8) --------------------------------------------------------
struct passwd *__fastcall sub_57AB8(__uid_t a1)
{
  struct passwd *result; // r0

  result = getpwuid(a1);
  if ( !result )
    sub_16DBC("unknown uid %u", a1);
  return result;
}

//----- (00057ADC) --------------------------------------------------------
char *__fastcall sub_57ADC(__uid_t a1)
{
  return sub_57AB8(a1)->pw_name;
}

//----- (00057AEC) --------------------------------------------------------
struct passwd *__fastcall sub_57AEC(__uid_t a1)
{
  struct passwd *result; // r0

  result = getpwuid(a1);
  if ( result )
    return (struct passwd *)result->pw_name;
  return result;
}

//----- (00057B00) --------------------------------------------------------
struct group *__fastcall sub_57B00(__gid_t a1)
{
  struct group *result; // r0

  result = getgrgid(a1);
  if ( result )
    return (struct group *)result->gr_name;
  return result;
}

//----- (00057B14) --------------------------------------------------------
struct passwd *__fastcall sub_57B14(__uid_t a1)
{
  struct passwd *result; // r0

  result = sub_57AEC(a1);
  if ( !result )
    return (struct passwd *)sub_16F64(a1);
  return result;
}

//----- (00057B34) --------------------------------------------------------
struct group *__fastcall sub_57B34(__gid_t a1)
{
  struct group *result; // r0

  result = sub_57B00(a1);
  if ( !result )
    return (struct group *)sub_16F64(a1);
  return result;
}

//----- (00057B54) --------------------------------------------------------
__uid_t __fastcall sub_57B54(const char *a1)
{
  return sub_57A70(a1)->pw_uid;
}

//----- (00057B64) --------------------------------------------------------
__gid_t __fastcall sub_57B64(const char *a1)
{
  return sub_57A94(a1)->gr_gid;
}

//----- (00057B74) --------------------------------------------------------
int __fastcall sub_57B74(const char *a1, int (__fastcall *a2)(const char *))
{
  int result; // r0

  result = sub_18990(a1, 0, (char *)0xA);
  if ( *(_DWORD *)dword_7DB94 )
    return a2(a1);
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00057BB4) --------------------------------------------------------
unsigned int __fastcall sub_57BB4(const char *a1, unsigned int a2)
{
  unsigned int v3; // r4
  unsigned int v5; // [sp+4h] [bp-4h] BYREF

  v5 = a2;
  if ( sscanf(a1, "cap_%u", &v5) == 1 )
  {
    v3 = v5;
    if ( v5 > 0x25 )
LABEL_7:
      sub_16DBC("unknown capability '%s'", a1);
  }
  else
  {
    v3 = 0;
    while ( !strcasecmp(off_63EBC[v3], a1) )
    {
      if ( ++v3 == 38 )
        goto LABEL_7;
    }
  }
  return v3;
}
// 63EBC: using guessed type char *off_63EBC[5];

//----- (00057C28) --------------------------------------------------------
int __fastcall sub_57C28(int *a1)
{
  int v2; // r5
  int v3; // r3
  int v4; // r3
  int result; // r0

  v2 = 0;
  a1[1] = 0;
  while ( 1 )
  {
    *a1 = byte_6BA6C[v2];
    if ( !capget(a1, 0) )
      break;
    if ( ++v2 == 3 )
      goto LABEL_4;
  }
  v3 = *a1;
  if ( *a1 == 537333798 || v3 == 537396514 )
  {
    v4 = 2;
  }
  else
  {
    if ( v3 != 429392688 )
      sub_16DBC("unsupported capability version");
    v4 = 1;
  }
  a1[2] = v4;
  result = capget(a1, a1 + 3);
  if ( result )
LABEL_4:
    sub_16B90("capget");
  return result;
}
// 1394C: using guessed type int __fastcall capget(_DWORD, _DWORD);
// 6BA6C: using guessed type unsigned __int8 byte_6BA6C[3];

//----- (00057CD8) --------------------------------------------------------
__uid_t __fastcall sub_57CD8(int a1)
{
  int v2; // r5
  int v3; // r4
  __uid_t result; // r0

  v2 = initgroups(*(const char **)a1, *(_DWORD *)(a1 + 12));
  endgrent();
  if ( v2 )
  {
    if ( *(_DWORD *)dword_7DB94 != 38 || (v3 = *(_DWORD *)(a1 + 8), result = getuid(), v3 != result) )
      sub_16B40("can't set groups");
  }
  else
  {
    sub_178C4(*(_DWORD *)(a1 + 12));
    return sub_178E0(*(_DWORD *)(a1 + 8));
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00057D48) --------------------------------------------------------
const char *__fastcall sub_57D48(const char *a1)
{
  const char *result; // r0

  result = sub_16AA8(a1, 10);
  if ( result )
    *result = 0;
  return result;
}

//----- (00057D64) --------------------------------------------------------
char *__fastcall sub_57D64(const char *a1, _BYTE *a2)
{
  if ( a2 && *a2 == 46 && (!a2[1] || a2[1] == 46 && !a2[2]) )
    return 0;
  else
    return sub_16998(a1, a2);
}

//----- (00057DA4) --------------------------------------------------------
int __fastcall sub_57DA4(char *name, char a2)
{
  _DWORD *v3; // r5
  int v4; // r6
  int result; // r0

  v3 = (_DWORD *)dword_7DB94;
  v4 = *(_DWORD *)dword_7DB94;
  if ( (a2 & 0x10) == 0
    || (fprintf((FILE *)stderr, "%s: overwrite '%s'? ", (const char *)dword_7DB90, name), (result = sub_57700()) != 0) )
  {
    if ( unlink(name) < 0 )
    {
      *v3 = v4;
      sub_16AF4("can't create '%s'", name);
      return -1;
    }
    else
    {
      return 1;
    }
  }
  return result;
}
// 7D608: using guessed type int stderr;
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;

//----- (00057E30) --------------------------------------------------------
int __fastcall sub_57E30(const char *a1, char *a2, int a3)
{
  int v3; // r7
  int (*v6)(); // r3
  int (*v8)(const char *, const char *); // r7
  int v9; // r8
  int v10; // r0
  void *v11; // r1
  int v12; // r9
  __mode_t v13; // r3
  __mode_t v14; // r7
  __mode_t v15; // r0
  __mode_t v16; // r1
  DIR *v17; // r10
  char *v18; // r11
  int v19; // r0
  const char *v20; // r1
  const char *v21; // r2
  unsigned int v23; // r2
  const char *v24; // r0
  const char *v25; // r7
  int v26; // r9
  int v27; // r0
  int v28; // r7
  __int64 v29; // r0
  __mode_t v30; // r2
  bool v31; // zf
  int v32; // r3
  int v33; // r0
  const char *v34; // r0
  char *v35; // r7
  int v36; // r9
  _BYTE *ptr; // [sp+4h] [bp-E8h]
  char *ptra; // [sp+4h] [bp-E8h]
  struct timeval tvp; // [sp+8h] [bp-E4h] BYREF
  __time_t v40; // [sp+10h] [bp-DCh]
  int v41; // [sp+14h] [bp-D8h]
  _QWORD v42[2]; // [sp+18h] [bp-D4h] BYREF
  __mode_t mode; // [sp+28h] [bp-C4h]
  __uid_t owner; // [sp+30h] [bp-BCh]
  __gid_t group; // [sp+34h] [bp-B8h]
  __dev_t v46; // [sp+38h] [bp-B4h]
  __time_t v47; // [sp+68h] [bp-84h]
  __int64 v48; // [sp+78h] [bp-74h]
  __int64 v49; // [sp+80h] [bp-6Ch] BYREF
  int v50; // [sp+90h] [bp-5Ch]
  __time_t v51; // [sp+D0h] [bp-1Ch]
  __int64 v52; // [sp+E0h] [bp-Ch]

  v3 = a3 & 0x102;
  v6 = sub_62DFC;
  if ( (a3 & 0x102) == 0 )
    v6 = sub_62E14;
  if ( v6() < 0 )
  {
    if ( (a3 & 0x60) != 0 )
      goto LABEL_5;
    v11 = (void *)a1;
LABEL_14:
    sub_16AF4("can't stat '%s'", v11);
    return -1;
  }
  if ( sub_62E14() >= 0 )
  {
    if ( v42[0] == v49 && v48 == v52 )
    {
      sub_16DDC("'%s' and '%s' are the same file", a1, a2);
      return -1;
    }
    v12 = 1;
  }
  else
  {
    if ( *(_DWORD *)dword_7DB94 != 2 )
    {
LABEL_18:
      v11 = a2;
      goto LABEL_14;
    }
    v12 = 0;
  }
  v13 = mode & 0xF000;
  if ( v13 == 0x4000 )
  {
    if ( (a3 & 4) == 0 )
    {
      sub_16DDC("omitting directory '%s'", a1);
      return -1;
    }
    v14 = sub_5A6C0((int)v42);
    if ( v14 )
    {
      sub_16DDC("recursion detected, omitting directory '%s'", a1);
      return -1;
    }
    if ( v12 )
    {
      if ( (v50 & 0xF000) != 0x4000 )
      {
        sub_16DDC("target '%s' is not a directory", a2);
        return -1;
      }
    }
    else
    {
      v15 = umask(0);
      v16 = mode;
      v14 = v15;
      if ( (a3 & 1) == 0 )
        v16 = mode & ~v15;
      if ( mkdir(a2, v16 | 0x1C0) < 0 )
      {
        umask(v14);
        sub_16AF4("can't create directory '%s'", a2);
        return -1;
      }
      umask(v14);
      if ( sub_62E14() < 0 )
        goto LABEL_18;
    }
    sub_5A754((int)&v49, 0);
    v17 = opendir(a1);
    if ( v17 )
    {
      v9 = 0;
      while ( 1 )
      {
        v19 = readdir64(v17);
        if ( !v19 )
          break;
        ptr = (_BYTE *)(v19 + 19);
        v18 = sub_57D64(a1, (_BYTE *)(v19 + 19));
        if ( v18 )
        {
          ptra = sub_16998(a2, ptr);
          if ( sub_57E30(v18, ptra, a3 & 0xFFFFFEFF) < 0 )
            v9 = -1;
          free(v18);
          free(ptra);
        }
      }
      closedir(v17);
      if ( !v12 && chmod(a2, mode & ~v14) < 0 )
        sub_16AF4("can't preserve %s of '%s'", "permissions", a2);
    }
    else
    {
      v9 = -1;
    }
    goto LABEL_49;
  }
  if ( v12 && (a3 & 0x2000) != 0 && v47 <= v51 )
    return 0;
  v9 = a3 & 0x60;
  if ( (a3 & 0x60) == 0 )
  {
    v23 = ((a3 ^ 4u) >> 2) & 1;
    if ( v13 == 0x8000 )
      v23 = 1;
    if ( v23 )
    {
      if ( v3 )
        goto LABEL_73;
      if ( v13 != 40960 )
      {
        v24 = (const char *)sub_5A6C0((int)v42);
        v25 = v24;
        if ( v24 )
        {
          if ( link(v24, a2) >= 0 )
            return 0;
          v9 = sub_57DA4(a2, a3);
          if ( v9 <= 0 )
            return v9;
          v10 = link(v25, a2);
LABEL_10:
          if ( v10 < 0 )
          {
            sub_16AF4("can't create link '%s'", a2);
            return -1;
          }
          return 0;
        }
        sub_5A754((int)v42, a2);
LABEL_73:
        v26 = sub_1760C(a1, 0);
        if ( v26 < 0 )
          return -1;
        v27 = open64(a2, 193);
        if ( v27 == -1 )
        {
          v9 = sub_57DA4(a2, a3);
          if ( v9 <= 0 )
          {
            close(v26);
            return v9;
          }
          v28 = sub_175E0(a2, 193);
          if ( v28 < 0 )
          {
            close(v26);
            return -1;
          }
        }
        else
        {
          v28 = v27;
        }
        v29 = sub_17FAC(v26, v28);
        v9 = -(((unsigned int)v29 & HIDWORD(v29)) == -1);
        if ( close(v28) < 0 )
        {
          v9 = -1;
          sub_16AF4("error writing to '%s'", a2);
        }
        close(v26);
        if ( (mode & 0xF000) != 0x8000 )
          return v9;
        goto LABEL_49;
      }
      if ( !v12 )
      {
LABEL_107:
        v34 = (const char *)sub_17C9C(a1);
        v35 = (char *)v34;
        if ( !v34 )
          goto LABEL_103;
        v36 = symlink(v34, a2);
        free(v35);
        if ( v36 < 0 )
        {
          sub_16AF4("can't create %slink '%s' to '%s'", "sym", a2, v35);
          return -1;
        }
        if ( (a3 & 1) == 0 || lchown(a2, owner, group) >= 0 )
          goto LABEL_103;
        v21 = a2;
        v20 = "ownership";
        goto LABEL_56;
      }
    }
    else if ( !v12 )
    {
      goto LABEL_85;
    }
    *(_DWORD *)dword_7DB94 = 17;
    v33 = sub_57DA4(a2, a3);
    if ( v33 <= 0 )
      return v33;
LABEL_85:
    v30 = mode & 0xF000;
    if ( v30 != 40960 )
    {
      v31 = v30 == 49152;
      if ( v30 != 49152 )
        v31 = (mode & 0xB000) == 0x2000;
      v32 = v31;
      if ( v30 == 4096 )
        v32 |= 1u;
      if ( !v32 )
      {
        sub_16DDC("unrecognized file '%s' with mode %x", a1, mode);
        return -1;
      }
      if ( sub_62E20(a2, mode, v46) < 0 )
      {
        sub_16AF4("can't create '%s'", a2);
        return -1;
      }
LABEL_49:
      if ( (a3 & 1) == 0 )
        goto LABEL_103;
      tvp.tv_sec = v47;
      v40 = v47;
      tvp.tv_usec = 0;
      v41 = 0;
      if ( utimes(a2, &tvp) < 0 )
        sub_16AF4("can't preserve %s of '%s'", "times", a2);
      if ( chown(a2, owner, group) < 0 )
      {
        mode &= 0xFFFFF3FF;
        sub_16AF4("can't preserve %s of '%s'", "ownership", a2);
      }
      if ( chmod(a2, mode) >= 0 )
        goto LABEL_103;
      v20 = "permissions";
      v21 = a2;
LABEL_56:
      sub_16AF4("can't preserve %s of '%s'", v20, v21);
LABEL_103:
      if ( (a3 & 0x1000) != 0 )
        printf("'%s' -> '%s'\n", a1, a2);
      return v9;
    }
    goto LABEL_107;
  }
LABEL_5:
  v8 = symlink;
  if ( (a3 & 0x40) == 0 )
    v8 = link;
  if ( v8(a1, a2) >= 0 )
    return 0;
  v9 = sub_57DA4(a2, a3);
  if ( v9 > 0 )
  {
    v10 = v8(a1, a2);
    goto LABEL_10;
  }
  return v9;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7DB94: using guessed type int dword_7DB94;

//----- (0005848C) --------------------------------------------------------
char *__fastcall sub_5848C(int a1, char *buffer)
{
  char *result; // r0
  int v4; // r2
  bool v5; // zf
  struct spwd *v6; // r12
  const char *v7; // r0
  struct spwd *v8; // [sp+8h] [bp-30h] BYREF
  struct spwd result_buf; // [sp+Ch] [bp-2Ch] BYREF

  if ( !a1 )
    return "aa";
  result = *(char **)(a1 + 4);
  v4 = (unsigned __int8)*result;
  v5 = v4 == 42;
  if ( v4 != 42 )
    v5 = v4 == 120;
  if ( v5 )
  {
    v6 = (struct spwd *)(unsigned __int8)result[1];
    if ( !result[1] )
    {
      v7 = *(const char **)a1;
      v8 = v6;
      if ( getspnam_r(v7, &result_buf, buffer, 0x100u, &v8) || !v8 )
        return "aa";
      else
        return v8->sp_pwdp;
    }
  }
  return result;
}

//----- (00058510) --------------------------------------------------------
int __fastcall sub_58510(int a1, char *a2)
{
  char *v3; // r0
  _BOOL4 v4; // r4
  const char *v5; // r4
  char *v6; // r5
  char v8[260]; // [sp+0h] [bp-104h] BYREF

  v3 = sub_5848C(a1, v8);
  if ( !*v3 )
    return 2;
  v5 = v3;
  v6 = (char *)sub_5FBFC(a2, v3, 1);
  v4 = strcmp(v6, v5) == 0;
  free(v6);
  return v4;
}

//----- (00058570) --------------------------------------------------------
int __fastcall sub_58570(int a1, unsigned int a2, int a3)
{
  int v6; // r4
  char *v7; // r5
  char v9[256]; // [sp+0h] [bp-100h] BYREF

  if ( !*sub_5848C(a1, v9) )
    return 2;
  v7 = sub_57750(0, a2, a3);
  if ( !v7 )
    return -1;
  v6 = sub_58510(a1, v7);
  sub_5DB1C(v7);
  return v6;
}

//----- (000585DC) --------------------------------------------------------
int __fastcall sub_585DC(int a1)
{
  return sub_58570(a1, 0, (int)"Password: ");
}

//----- (000585EC) --------------------------------------------------------
_DWORD *__fastcall sub_585EC(_DWORD *result, int a2)
{
  int v3; // r4
  int i; // r2
  int v5; // r1
  int v6; // r3
  bool v7; // nf
  int v8; // r12

  v3 = -306674912;
  if ( a2 )
    v3 = 79764919;
  if ( !result )
    result = sub_1748C(0x400u);
  for ( i = 0; i != 256; ++i )
  {
    v5 = 8;
    if ( a2 )
      v6 = i << 24;
    else
      v6 = i;
    do
    {
      if ( a2 )
      {
        v7 = v6 < 0;
        v6 *= 2;
        if ( v7 )
          goto LABEL_12;
      }
      else
      {
        v8 = v6 & 1;
        v6 = (unsigned int)v6 >> 1;
        if ( v8 )
LABEL_12:
          v6 ^= v3;
      }
      --v5;
    }
    while ( v5 );
    result[i] = v6;
  }
  return result;
}

//----- (00058678) --------------------------------------------------------
_DWORD *sub_58678()
{
  return sub_585EC(0, 0);
}

//----- (00058684) --------------------------------------------------------
unsigned int __fastcall sub_58684(unsigned int result, unsigned __int8 *a2, int a3, int a4)
{
  unsigned __int8 *v4; // r2
  int v5; // t1

  v4 = &a2[a3];
  while ( a2 != v4 )
  {
    v5 = *a2++;
    result = *(_DWORD *)(a4 + 4 * (v5 ^ HIBYTE(result))) ^ (result << 8);
  }
  return result;
}

//----- (000586A4) --------------------------------------------------------
unsigned int __fastcall sub_586A4(unsigned int result, char *a2, int a3, int a4)
{
  char *v4; // r2
  char v5; // t1

  v4 = &a2[a3];
  while ( a2 != v4 )
  {
    v5 = *a2++;
    result = *(_DWORD *)(a4 + 4 * (unsigned __int8)(v5 ^ result)) ^ (result >> 8);
  }
  return result;
}

//----- (000586C8) --------------------------------------------------------
int __fastcall sub_586C8(int a1, int a2)
{
  int v4; // r6
  int v5; // r5
  int v6; // r0
  int v7; // r7

  v4 = a2 | 0x800;
  v5 = 5;
  while ( 1 )
  {
    v6 = open64(a1, v4);
    v7 = v6;
    if ( v6 >= 0 )
      break;
    if ( !--v5 )
      return v7;
  }
  if ( a2 != v4 )
    fcntl(v6, 4, a2);
  return v7;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (0005871C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5871C(unsigned __int8 *result)
{
  int v1; // r3
  int v2; // t1

  v1 = *result;
  if ( v1 == 95 )
  {
LABEL_6:
    while ( 1 )
    {
      v2 = *++result;
      v1 = v2;
      if ( !v2 )
        break;
      if ( v1 != 95 && (unsigned int)(v1 - 48) > 9 )
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    if ( (v1 | 0x20u) - 97 <= 0x19 )
      goto LABEL_6;
  }
  return result;
}

//----- (00058760) --------------------------------------------------------
bool __fastcall sub_58760(const char *a1)
{
  __int16 v2; // [sp+10h] [bp-58h]

  return !access(a1, 1) && !sub_62DFC() && (v2 & 0xF000) == 0x8000;
}
// 587A0: variable 'v2' is possibly undefined

//----- (000587B4) --------------------------------------------------------
char *__fastcall sub_587B4(_BYTE *a1, char **a2)
{
  char *v3; // r4
  char *v5; // r0
  char *v6; // r5
  const char *v7; // r0
  _BOOL4 v8; // r0
  char *v10; // r0

  v3 = *a2;
  while ( v3 )
  {
    v5 = strchr(v3, 58);
    v6 = v5;
    if ( v5 )
      *v5 = 0;
    if ( *v3 )
      v7 = v3;
    else
      v7 = ".";
    v3 = sub_16998(v7, a1);
    v8 = sub_58760(v3);
    if ( v6 )
      *v6++ = 58;
    if ( v8 )
    {
      *a2 = v6;
      return v3;
    }
    v10 = v3;
    v3 = v6;
    free(v10);
  }
  return v3;
}

//----- (00058840) --------------------------------------------------------
void __fastcall __noreturn sub_58840(const char **argv)
{
  char v2; // r2

  execvp(*argv, (char *const *)argv);
  if ( *(_DWORD *)dword_7DB94 == 2 )
    v2 = 127;
  else
    v2 = 126;
  byte_7D5F8 = v2;
  sub_16B40("can't execute '%s'", *argv);
}
// 7D5F8: using guessed type char byte_7D5F8;
// 7DB94: using guessed type int dword_7DB94;

//----- (0005888C) --------------------------------------------------------
int __fastcall sub_5888C(FILE *a1)
{
  int v2; // r4

  v2 = ferror_unlocked(a1);
  if ( v2 )
    *(_DWORD *)dword_7DB94 = 5;
  if ( (FILE *)stdin != a1 )
    return v2 | fclose(a1);
  return v2;
}
// 7D610: using guessed type int stdin;
// 7DB94: using guessed type int dword_7DB94;

//----- (000588D8) --------------------------------------------------------
void __fastcall __noreturn sub_588D8(char a1)
{
  byte_7D5F8 = a1;
  if ( fflush((FILE *)stdout) )
    sub_16B40("standard output");
  sub_16E08();
}
// 7D5F8: using guessed type char byte_7D5F8;
// 7D614: using guessed type int stdout;

//----- (00058910) --------------------------------------------------------
char *__fastcall sub_58910(FILE *a1, char *s, int a3, signed int *a4)
{
  signed int v6; // r4
  unsigned int v7; // r11
  size_t v8; // r7
  signed int v9; // r6
  char *v10; // r5
  int v11; // r0
  char v12; // r2
  signed int v14; // r10
  char *v15; // r0
  char v18; // [sp+Ch] [bp-8h]

  v6 = 0;
  v7 = *a4;
  v8 = strlen(s);
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    v11 = getc_unlocked(a1);
    v12 = v11;
    if ( v11 == -1 )
      break;
    v14 = v6 + 1;
    if ( v9 <= v6 )
    {
      v9 += 200;
      v18 = v11;
      v15 = (char *)sub_174B4(v10, v9);
      v10 = v15;
      v12 = v18;
      if ( v7 <= v6 )
      {
        v15[v6++] = v18;
        goto LABEL_4;
      }
    }
    v10[v6] = v12;
    v6 = v14 - v8;
    if ( (int)(v14 - v8) >= 0 && !memcmp(&v10[v6], s, v8) )
    {
      if ( !a3 )
        v6 = v14;
      goto LABEL_4;
    }
    v6 = v14;
  }
  if ( !v6 )
    return v10;
LABEL_4:
  v10 = (char *)sub_174B4(v10, v6 + 1);
  v10[v6] = 0;
  *a4 = v6;
  return v10;
}

//----- (000589FC) --------------------------------------------------------
char *__fastcall sub_589FC(FILE *a1, char *a2, signed int a3)
{
  signed int v4[2]; // [sp+4h] [bp-8h] BYREF

  v4[1] = a3;
  v4[0] = 2147479552;
  return sub_58910(a1, a2, 0, v4);
}

//----- (00058A20) --------------------------------------------------------
struct mntent *__fastcall sub_58A20(const char *a1, int a2)
{
  int v4; // r4
  struct mntent *v5; // r5
  __int64 v7; // r6
  FILE *v8; // r9
  int v9; // r4
  struct mntent *v10; // r0
  const char *mnt_fsname; // r8
  int v12; // r3
  __int64 v13; // [sp+0h] [bp-6Ch]
  __int16 v14; // [sp+10h] [bp-5Ch]
  __int64 v15; // [sp+20h] [bp-4Ch]

  v4 = sub_62DFC();
  if ( v4 )
    return 0;
  v7 = v13;
  if ( (v14 & 0xB000) == 0x2000 )
  {
    v7 = v15;
    v4 = 1;
  }
  v8 = setmntent("/proc/mounts", "r");
  if ( !v8 )
    return 0;
  v9 = v4 ^ 1;
  while ( 1 )
  {
    v10 = getmntent(v8);
    v5 = v10;
    if ( !v10 )
      break;
    mnt_fsname = v10->mnt_fsname;
    if ( strcmp(v10->mnt_fsname, "rootfs") )
    {
      if ( !strcmp(a1, v5->mnt_dir) || !strcmp(a1, mnt_fsname) )
        break;
      v12 = a2 ? 0 : v9;
      if ( !v12 && (!sub_62DFC() && v15 == v7 || !sub_62DFC() && v13 == v7) )
        break;
    }
  }
  endmntent(v8);
  return v5;
}
// 58A54: variable 'v13' is possibly undefined
// 58A58: variable 'v14' is possibly undefined
// 58A60: variable 'v15' is possibly undefined

//----- (00058B44) --------------------------------------------------------
void *__fastcall sub_58B44(const char *a1)
{
  char *v2; // r4
  int v3; // r6
  void *v4; // r5
  char *v5; // r0
  const char *v7; // r0
  const char *v8; // r0
  char *v9; // r0
  int v10; // r8
  signed int v11; // r0
  char *v12; // r0
  char *v13; // r0

  v2 = 0;
  v3 = 0;
  v4 = sub_174DC(4u);
  while ( 1 )
  {
    v5 = sub_5E8EC(v2, (int)&dword_10120 + 1);
    v2 = v5;
    if ( !v5 )
      break;
    if ( strncmp(v5 + 72, a1, 0xFu)
      || v2[86]
      && ((v10 = *((_DWORD *)v2 + 2)) == 0
       || (v11 = strlen(*((const char **)v2 + 2)) + 1, v11 >= *((unsigned __int16 *)v2 + 3))
       || (v12 = sub_169FC((const char *)(v10 + v11)), strcmp(v12, a1))) )
    {
      v7 = (const char *)*((_DWORD *)v2 + 2);
      if ( !v7 || (v13 = sub_169FC(v7), strcmp(v13, a1)) )
      {
        v8 = (const char *)*((_DWORD *)v2 + 3);
        if ( !v8 )
          continue;
        v9 = sub_169FC(v8);
        if ( strcmp(v9, a1) )
          continue;
      }
    }
    v4 = sub_62544(v4, 0x402u, v3);
    *((_DWORD *)v4 + v3++) = *((_DWORD *)v2 + 9);
  }
  *((_DWORD *)v4 + v3) = 0;
  return v4;
}
// 10120: using guessed type int dword_10120;

//----- (00058C58) --------------------------------------------------------
void *__fastcall sub_58C58(FILE *stream, _DWORD *a2)
{
  void *v2; // r4
  int i; // r6
  int v6; // r5
  int v7; // r7
  _BOOL4 v9; // r5

  v2 = 0;
  for ( i = 0; ; ++i )
  {
    v6 = getc_unlocked(stream);
    if ( v6 == -1 )
      break;
    if ( !(_BYTE)i )
    {
      if ( i == -256 )
        sub_17440();
      v2 = sub_174B4(v2, i + 256);
    }
    v7 = i + 1;
    *((_BYTE *)v2 + i) = v6;
    if ( !v6 )
      goto LABEL_4;
    v9 = v6 == 10;
    if ( !a2 )
      v9 = 0;
    if ( v9 )
      goto LABEL_5;
  }
  v7 = i;
LABEL_4:
  if ( !a2 )
    goto LABEL_6;
LABEL_5:
  *a2 = v7;
LABEL_6:
  if ( v2 )
  {
    v2 = sub_174B4(v2, v7 + 1);
    *((_BYTE *)v2 + v7) = 0;
  }
  return v2;
}

//----- (00058D10) --------------------------------------------------------
void *__fastcall sub_58D10(FILE *a1, int a2, int a3)
{
  _DWORD v4[2]; // [sp+4h] [bp-8h] BYREF

  v4[0] = a2;
  v4[1] = a3;
  return sub_58C58(a1, v4);
}

//----- (00058D24) --------------------------------------------------------
_BYTE *__fastcall sub_58D24(FILE *a1, int a2, int a3)
{
  _BYTE *result; // r0
  int v4; // r3
  _DWORD v5[2]; // [sp+4h] [bp-8h] BYREF

  v5[0] = a2;
  v5[1] = a3;
  result = sub_58C58(a1, v5);
  if ( v5[0] )
  {
    v4 = v5[0] - 1;
    v5[0] = v4;
    if ( result[v4] == 10 )
      result[v4] = 0;
  }
  return result;
}

//----- (00058D5C) --------------------------------------------------------
char *sub_58D5C()
{
  char *result; // r0
  __uid_t v1; // r0
  struct passwd *v2; // r0

  result = getenv("SHELL");
  if ( !result || !*result )
  {
    v1 = getuid();
    v2 = getpwuid(v1);
    if ( v2 && (result = v2->pw_shell) != 0 )
    {
      if ( !*result )
        return (char *)"/bin/sh";
    }
    else
    {
      return (char *)"/bin/sh";
    }
  }
  return result;
}

//----- (00058DBC) --------------------------------------------------------
int __fastcall sub_58DBC(char **a1, const char *a2, const char *a3, int *a4)
{
  const char *v4; // r4
  size_t v8; // r0
  int v9; // r3
  bool v10; // zf
  int v11; // r3
  char *v12; // r0
  int v13; // r3
  int v14; // r6
  char *v15; // r3
  bool v16; // zf
  _BYTE *v17; // r8
  const char *v18; // r10
  int i; // r8
  char *v20; // r10
  int *v21; // r2
  int v22; // r1
  int v23; // r1
  int v24; // t1
  int v25; // r1
  struct option *j; // r10
  struct option *k; // r3
  int v28; // r8
  signed int v29; // r7
  int v30; // r6
  const char *v31; // r3
  int v32; // r2
  int v33; // r3
  int *flag; // r2
  int v35; // r1
  _BYTE *v36; // r12
  int v37; // r2
  int v38; // r2
  int v39; // r2
  unsigned int v40; // r2
  unsigned __int8 *v41; // r3
  bool v42; // cc
  int v43; // r1
  int v44; // r4
  int v45; // r0
  int v46; // r4
  _BOOL4 v47; // r3
  unsigned int v49; // r2
  int v50; // r0
  int v51; // r12
  _DWORD *v52; // r3
  bool v53; // zf
  int v54; // r0
  bool v55; // zf
  int v56; // r2
  bool v57; // zf
  int v58; // r0
  int v59; // r2
  _DWORD *v60; // r1
  _DWORD *v61; // r2
  _DWORD *v62; // lr
  unsigned __int8 *v63; // r12
  _DWORD *v64; // r3
  unsigned __int8 *v65; // r4
  int v66; // r1
  int v67; // t1
  bool v68; // zf
  int v69; // r0
  int v70; // r4
  _BYTE *v71; // r9
  int v72; // r2
  int v73; // r1
  _DWORD *v74; // r3
  _DWORD *v75; // r2
  int v76; // r2
  unsigned int *v77; // r10
  int v78; // r3
  char dest[4]; // [sp+8h] [bp-464h] BYREF
  _DWORD *v80; // [sp+Ch] [bp-460h]
  char **argv; // [sp+10h] [bp-45Ch]
  int v82; // [sp+14h] [bp-458h]
  char *shortopts; // [sp+18h] [bp-454h]
  struct option *longopts; // [sp+1Ch] [bp-450h]
  unsigned int v85; // [sp+20h] [bp-44Ch]
  _BYTE *v86; // [sp+24h] [bp-448h]
  _BYTE v87[1060]; // [sp+28h] [bp-444h] BYREF

  argv = a1;
  memset(v87, 0, 0x420u);
  v8 = strlen(a2);
  v9 = *(unsigned __int8 *)a2;
  v10 = v9 == 94;
  if ( v9 == 94 )
    ++a2;
  else
    v4 = 0;
  v11 = *(unsigned __int8 *)a2;
  if ( v10 )
    v4 = &a2[v8];
  if ( v11 == 33 )
    ++a2;
  v82 = v11;
  v12 = strcpy(dest, a2);
  v13 = (unsigned __int8)*v12;
  v14 = 0;
  shortopts = v12;
  v15 = (char *)(v13 - 43);
  v16 = ((unsigned __int8)v15 & 0xFD) == 0;
  if ( ((unsigned __int8)v15 & 0xFD) != 0 )
    v12 = shortopts;
  else
    v15 = v12;
  if ( v16 )
    v12 = v15 + 1;
  v86 = &v87[32];
  v17 = &v87[32];
  while ( *v12 && v14 != 32 )
  {
    *(v17 - 32) = *v12;
    v20 = v12 + 1;
    *((_DWORD *)v17 - 6) = 1 << v14;
    if ( v12[1] == 58 )
    {
      v21 = a4 + 1;
      *((_DWORD *)v17 - 2) = *a4;
      v22 = (unsigned __int8)v12[2];
      if ( (unsigned int)(v22 - 42) <= 1 )
      {
        v85 = (unsigned int)(a4 + 1);
        if ( v22 == 43 )
          v23 = 2;
        else
          v23 = 1;
        *((_DWORD *)v17 - 7) = v23;
        sub_60B4C((int)(v12 + 2), (int)(v12 + 3));
        v21 = (int *)v85;
      }
      do
        v24 = (unsigned __int8)*++v20;
      while ( v24 == 58 );
      a4 = v21;
    }
    ++v14;
    v17 += 32;
    v12 = v20;
  }
  if ( a3 )
  {
    v18 = a3;
    for ( i = 1; ; ++i )
    {
      v25 = *(unsigned __int8 *)v18;
      if ( !*v18 )
        break;
      v18 += strlen(v18) + 3;
    }
    longopts = (struct option *)dest;
    memset(dest, v25, 16 * i);
    for ( j = longopts; ; j[-1].val = v33 )
    {
      --i;
      ++j;
      if ( !i )
        break;
      j[-1].name = a3;
      v31 = &a3[strlen(a3) + 1];
      v32 = *(unsigned __int8 *)v31;
      a3 = v31 + 2;
      v33 = *((unsigned __int8 *)v31 + 1);
      j[-1].has_arg = v32;
    }
    for ( k = longopts + 1; k[-1].name; ++k )
    {
      flag = k[-1].flag;
      if ( !flag )
      {
        while ( 1 )
        {
          v35 = (unsigned __int8)v87[(_DWORD)flag];
          v36 = &v87[(_DWORD)flag];
          if ( !v87[(_DWORD)flag] )
            break;
          flag += 8;
          if ( v35 == k[-1].val )
            goto LABEL_45;
        }
        if ( v14 > 31 )
          break;
        *v36 = k[-1].val;
        v37 = 1 << v14++;
        *((_DWORD *)v36 + 2) = v37;
        if ( k[-1].has_arg )
        {
          v38 = *a4++;
          *((_DWORD *)v36 + 6) = v38;
        }
      }
LABEL_45:
      ;
    }
  }
  else
  {
    longopts = (struct option *)&unk_63F5C;
  }
  v28 = -1;
  if ( v4 )
  {
    v29 = 0;
    v85 = 0;
    v30 = 0;
    while ( 1 )
    {
      v43 = *(unsigned __int8 *)v4;
      if ( !*v4 )
        goto LABEL_54;
      v39 = *((unsigned __int8 *)v4 + 1);
      if ( v43 != 58 )
      {
        switch ( v43 )
        {
          case '?':
            v40 = v39 - 48;
            v41 = (unsigned __int8 *)(v4 + 1);
            v42 = v40 > 9;
            if ( v40 <= 9 )
              v28 = v40;
LABEL_50:
            if ( !v42 )
              v4 = (const char *)v41;
            goto LABEL_52;
          case '-':
            v49 = v39 - 48;
            v41 = (unsigned __int8 *)(v4 + 1);
            v42 = v49 > 9;
            if ( v49 <= 9 )
              v29 = v49;
            goto LABEL_50;
          case '=':
            v29 = v39 - 48;
            ++v4;
            v28 = v39 - 48;
            goto LABEL_52;
        }
        v50 = 0;
        do
        {
          v51 = (unsigned __int8)v87[v50];
          v52 = &v87[v50];
          if ( !v87[v50] )
            sub_16DBC("NO OPT %c!", v43);
          v50 += 32;
        }
        while ( v51 != v43 );
        if ( v39 == 58 )
        {
          if ( v4[2] == 58 )
          {
            v52[1] = 1;
            goto LABEL_52;
          }
        }
        else if ( v39 == 43 )
        {
          v54 = *((unsigned __int8 *)v4 + 2);
          v55 = v54 == 0;
          if ( v4[2] )
            v55 = v54 == 58;
          if ( v55 )
          {
            v52[1] = 2;
LABEL_90:
            ++v4;
            goto LABEL_52;
          }
        }
        v53 = v39 == 0;
        if ( v4[1] )
          v53 = v39 == 58;
        if ( v53 )
        {
          v85 |= v52[2];
          goto LABEL_52;
        }
        if ( v39 == 45 )
        {
          v56 = *((unsigned __int8 *)v4 + 2);
          v57 = v56 == 0;
          if ( v4[2] )
            v57 = v56 == 58;
          if ( v57 )
          {
            v58 = v52[2];
            v30 |= v58;
            v52[4] |= v58;
            goto LABEL_90;
          }
        }
        else if ( v51 == v39 )
        {
          v59 = *a4;
          ++v4;
          ++a4;
          v52[7] = v59;
        }
        v60 = v52 + 4;
        v61 = v52 + 2;
        v62 = v52 + 3;
        v63 = (unsigned __int8 *)(v4 + 1);
        v64 = v52 + 5;
        v80 = v60;
        while ( 1 )
        {
LABEL_100:
          v65 = v63;
          v67 = *v63++;
          v66 = v67;
          v68 = v67 == 0;
          if ( v67 )
            v68 = v66 == 58;
          if ( v68 )
            break;
          if ( v66 == 63 )
          {
            v61 = v64;
          }
          else if ( v66 == 45 )
          {
            v10 = v62 == v61;
            v61 = v80;
            if ( !v10 )
              v61 = v62;
          }
          else
          {
            v69 = 0;
            while ( 1 )
            {
              v70 = (unsigned __int8)v87[v69];
              v71 = &v87[v69];
              if ( !v87[v69] )
                break;
              v69 += 32;
              if ( v70 == v66 )
              {
                *v61 |= *((_DWORD *)v71 + 2);
                goto LABEL_100;
              }
            }
          }
        }
        v4 = (const char *)(v65 - 1);
      }
LABEL_52:
      ++v4;
    }
  }
  v29 = 0;
  v85 = 0;
  v30 = 0;
LABEL_54:
  optind = 0;
  v44 = sub_162C8(argv + 1) + 1;
  while ( 1 )
  {
    v45 = getopt_long(v44, argv, shortopts, longopts, 0);
    if ( v45 == -1 )
      break;
    v72 = 0;
    while ( 1 )
    {
      v73 = (unsigned __int8)v87[v72];
      v74 = &v87[v72];
      if ( v73 == (unsigned __int8)v45 )
        break;
      v72 += 32;
      if ( !v73 )
        goto LABEL_123;
    }
    if ( (v30 & v74[4]) != 0 )
      goto LABEL_123;
    v30 = (v74[2] & ~v74[3] | v30 & ~(v74[3] & ~v74[2])) ^ v74[2] & v74[3];
    v75 = (_DWORD *)v74[7];
    if ( v75 )
      ++*v75;
    if ( optarg )
    {
      v76 = v74[1];
      v77 = (unsigned int *)v74[6];
      if ( v76 == 1 )
      {
        sub_5D2C8((_DWORD *)v74[6], optarg);
      }
      else if ( v76 == 2 )
      {
        *v77 = sub_6219C((const char *)optarg);
      }
      else if ( v77 )
      {
        *v77 = optarg;
      }
    }
  }
  while ( *(v86 - 32) )
  {
    v78 = *((_DWORD *)v86 - 3);
    if ( v78 && (v30 & *((_DWORD *)v86 - 6)) != 0 && (v78 & v30) == 0 )
      goto LABEL_123;
    v86 += 32;
  }
  if ( !v85 || (v30 & v85) != 0 )
  {
    v46 = v44 - optind;
    if ( v29 <= v46 )
    {
      v47 = v28 >= 0;
      if ( v28 >= v46 )
        v47 = 0;
      if ( !v47 )
      {
        dword_7DBC0 = v30;
        return v30;
      }
    }
  }
LABEL_123:
  if ( v82 != 33 )
    sub_162F0();
  return -1;
}
// 58F88: variable 'v4' is possibly undefined
// 7D604: using guessed type int optind;
// 7D618: using guessed type int optarg;
// 7DBC0: using guessed type int dword_7DBC0;

//----- (000593CC) --------------------------------------------------------
int sub_593CC(char **a1, const char *a2, ...)
{
  va_list varg_r2; // [sp+10h] [bp+8h] BYREF

  va_start(varg_r2, a2);
  return sub_58DBC(a1, a2, 0, (int *)varg_r2);
}

//----- (000593F8) --------------------------------------------------------
int sub_593F8(char **a1, const char *a2, const char *a3, ...)
{
  va_list varg_r3; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r3, a3);
  return sub_58DBC(a1, a2, a3, (int *)varg_r3);
}

//----- (00059420) --------------------------------------------------------
const char *__fastcall sub_59420(const char **a1)
{
  const char *result; // r0
  const char *v3; // t1
  size_t v4; // r0
  _BYTE *v5; // r0
  const char *v6; // r1
  const char *v7; // r5

  while ( 1 )
  {
    v3 = a1[1];
    ++a1;
    result = v3;
    if ( !v3 )
      break;
    if ( *result != 45 )
    {
      v4 = strlen(result);
      v5 = sub_1748C(v4 + 2);
      v6 = *a1;
      v7 = v5;
      *v5 = 45;
      strcpy(v5 + 1, v6);
      *a1 = v7;
    }
  }
  return result;
}

//----- (00059468) --------------------------------------------------------
_DWORD *__fastcall sub_59468(_DWORD *result)
{
  _DWORD *v1; // r4
  int v2; // r9
  int v3; // r8
  int v4; // r1
  _DWORD *v5; // r5
  int v6; // r12
  int v7; // r2
  int v8; // r3
  int v9; // r6
  int v10; // r11
  int v11; // t2
  int v12; // t2
  int v13; // t2
  char *v14; // lr
  _DWORD *v15; // r4
  int v16; // r10
  int v17; // t2
  int v18; // t2
  int v19; // t2
  char *v20; // lr
  _DWORD *v21; // r5
  int v22; // r10
  int v23; // r4
  int v24; // t2
  int v25; // t2
  int v26; // t2
  char *v27; // lr
  _DWORD *v28; // r4
  int v29; // r10
  int v30; // t2
  int v31; // t2
  int v32; // t2
  int v33; // [sp+4h] [bp-8h]

  v1 = result + 4;
  v2 = result[20];
  v3 = result[21];
  v4 = result[23];
  v5 = &unk_63F7C;
  v6 = v2;
  v33 = v4;
  v7 = v3;
  v8 = result[22];
  do
  {
    v9 = *(v1 - 4);
    v10 = *(v5 - 4);
    v1 += 4;
    v5 += 4;
    v11 = __ROR4__(((v8 ^ v4) & v7 ^ v4) + v9 + v10 + v6, 25);
    v6 = v7 + v11;
    v12 = __ROR4__(((v7 ^ v8) & (v7 + v11) ^ v8) + *(v1 - 7) + *(v5 - 7) + v4, 20);
    v4 = v6 + v12;
    v13 = __ROR4__(((v6 ^ v7) & (v6 + v12) ^ v7) + *(v1 - 6) + *(v5 - 6) + v8, 15);
    v8 = v4 + v13;
    v7 = v4 + v13 + __ROR4__(((v6 ^ v4) & (v4 + v13) ^ v6) + *(v1 - 5) + *(v5 - 5) + v7, 10);
  }
  while ( result + 20 != v1 );
  v14 = (char *)&unk_6BBD2;
  v15 = &unk_63FBC;
  do
  {
    v16 = *(v15 - 4);
    v14 += 4;
    v15 += 4;
    v17 = __ROR4__(((v7 ^ v8) & v4 ^ v8) + v16 + result[(unsigned __int8)*(v14 - 8)] + v6, 27);
    v6 = v7 + v17;
    v18 = __ROR4__((((v7 + v17) ^ v7) & v8 ^ v7) + v4 + *(v15 - 7) + result[(unsigned __int8)*(v14 - 7)], 23);
    v4 = v6 + v18;
    v19 = __ROR4__(((v6 ^ (v6 + v18)) & v7 ^ v6) + v8 + *(v15 - 6) + result[(unsigned __int8)*(v14 - 6)], 18);
    v8 = v4 + v19;
    v7 = v4 + v19 + __ROR4__(((v4 ^ (v4 + v19)) & v6 ^ v4) + v7 + *(v15 - 5) + result[(unsigned __int8)*(v14 - 5)], 12);
  }
  while ( &unk_6BBE2 != (_UNKNOWN *)v14 );
  v20 = (char *)&unk_6BBE2;
  v21 = &unk_63FFC;
  do
  {
    v22 = (unsigned __int8)*(v20 - 4);
    v23 = *(v21 - 4);
    v20 += 4;
    v21 += 4;
    v24 = __ROR4__((v7 ^ v8 ^ v4) + v23 + result[v22] + v6, 28);
    v6 = v7 + v24;
    v25 = __ROR4__((v7 ^ v8 ^ (v7 + v24)) + v4 + *(v21 - 7) + result[(unsigned __int8)*(v20 - 7)], 21);
    v4 = v6 + v25;
    v26 = __ROR4__((v6 ^ v7 ^ (v6 + v25)) + v8 + *(v21 - 6) + result[(unsigned __int8)*(v20 - 6)], 16);
    v8 = v4 + v26;
    v7 = v4 + v26 + __ROR4__((v6 ^ v4 ^ (v4 + v26)) + v7 + *(v21 - 5) + result[(unsigned __int8)*(v20 - 5)], 9);
  }
  while ( &unk_6BBF2 != (_UNKNOWN *)v20 );
  v27 = (char *)&unk_6BBF2;
  v28 = &unk_6403C;
  do
  {
    v29 = *(v28 - 4);
    v27 += 4;
    v28 += 4;
    v30 = __ROR4__(((~v4 | v7) ^ v8) + v29 + result[(unsigned __int8)*(v27 - 8)] + v6, 26);
    v6 = v7 + v30;
    v31 = __ROR4__(((~v8 | (v7 + v30)) ^ v7) + v4 + *(v28 - 7) + result[(unsigned __int8)*(v27 - 7)], 22);
    v4 = v6 + v31;
    v32 = __ROR4__(((~v7 | (v6 + v31)) ^ v6) + v8 + *(v28 - 6) + result[(unsigned __int8)*(v27 - 6)], 17);
    v8 = v4 + v32;
    v7 = v4 + v32 + __ROR4__(((~v6 | (v4 + v32)) ^ v4) + v7 + *(v28 - 5) + result[(unsigned __int8)*(v27 - 5)], 11);
  }
  while ( "%*c" != v27 );
  result[22] += v8;
  result[20] = v2 + v6;
  result[21] = v3 + v7;
  result[23] = v33 + v4;
  return result;
}

//----- (000597A4) --------------------------------------------------------
int __fastcall sub_597A4(int a1, int a2)
{
  int v4; // r3
  int result; // r0
  unsigned int v6; // r6
  __int64 v7; // r0

  v4 = *(_DWORD *)(a1 + 72) & 0x3F;
  result = v4 + 1;
  *(_BYTE *)(a1 + v4) = 0x80;
  do
  {
    v6 = 64 - result;
    memset((void *)(a1 + result), 0, 64 - result);
    if ( v6 > 7 )
    {
      v7 = 8LL * *(_QWORD *)(a1 + 72);
      if ( a2 )
        LODWORD(v7) = sub_57900(v7, HIDWORD(v7));
      *(_QWORD *)(a1 + 56) = v7;
    }
    (*(void (__fastcall **)(int))(a1 + 64))(a1);
    result = 0;
  }
  while ( v6 <= 7 );
  return result;
}
// 597FC: variable 'v7' is possibly undefined

//----- (0005981C) --------------------------------------------------------
unsigned int __fastcall sub_5981C(int a1)
{
  unsigned int v1; // r7
  int v3; // r9
  int v4; // r8
  unsigned int v5; // r5
  unsigned int v6; // r6
  __int64 v7; // r0
  char *v8; // r2
  unsigned int v9; // lr
  char *v10; // r9
  unsigned int v11; // r3
  unsigned __int64 v12; // kr10_8
  int v13; // r1
  int v14; // r3
  int v15; // lr
  int v16; // r9
  int v17; // r12
  int v18; // r8
  _BYTE *v19; // r3
  unsigned __int64 v20; // kr20_8
  int v21; // r12
  unsigned __int64 v22; // kr38_8
  unsigned int v23; // r0
  unsigned int v24; // r8
  unsigned __int64 v25; // kr30_8
  unsigned int result; // r0
  unsigned __int64 v27; // kr40_8
  __int64 v28; // r2
  __int64 v29; // kr48_8
  unsigned int v30; // kr1C_4
  unsigned int v31; // kr28_4
  bool v32; // cf
  int v33; // r9
  __int64 v34; // r2
  int v35; // r10
  unsigned int v36; // r5
  __int64 v37; // r2
  unsigned int v38; // r6
  __int64 v39; // kr50_8
  int v40; // r3
  int v41; // r3
  unsigned int v42; // r3
  unsigned int v43; // r3
  unsigned int v44; // [sp+4h] [bp-2B8h]
  __int64 v45; // [sp+8h] [bp-2B4h]
  unsigned __int64 v46; // [sp+10h] [bp-2ACh]
  __int64 v47; // [sp+18h] [bp-2A4h]
  __int64 v48; // [sp+20h] [bp-29Ch]
  unsigned __int64 v49; // [sp+28h] [bp-294h]
  __int64 v50; // [sp+30h] [bp-28Ch]
  _BYTE v51[512]; // [sp+38h] [bp-284h] BYREF
  char v52; // [sp+238h] [bp-84h] BYREF

  v1 = *(_DWORD *)(a1 + 16);
  v3 = a1 + 80;
  v4 = 0;
  v44 = *(_DWORD *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 48);
  v6 = *(_DWORD *)(a1 + 52);
  v45 = *(_QWORD *)(a1 + 24);
  v46 = *(_QWORD *)(a1 + 32);
  v49 = *(_QWORD *)(a1 + 40);
  v47 = *(_QWORD *)(a1 + 56);
  v48 = *(_QWORD *)(a1 + 64);
  v50 = *(_QWORD *)(a1 + 72);
  do
  {
    LODWORD(v7) = sub_57900(*(_DWORD *)(v3 + v4), *(_DWORD *)(v3 + v4 + 4));
    *(_QWORD *)&v51[v4] = v7;
    v4 += 8;
  }
  while ( v4 != 128 );
  v8 = v51;
  do
  {
    v9 = *((_DWORD *)v8 + 29);
    v10 = v8;
    v11 = *((_DWORD *)v8 + 28);
    v8 += 8;
    v12 = __PAIR64__(
            ((v9 >> 19) | (v11 << 13)) ^ ((8 * v9) | (v11 >> 29)) ^ (v9 >> 6),
            ((8 * v11) | (v9 >> 29)) ^ ((v11 >> 19) | (v9 << 13)) ^ ((v11 >> 6) | (v9 << 26)))
        + *((_QWORD *)v10 + 9)
        + *(_QWORD *)v10;
    v13 = ((*((_DWORD *)v8 + 1) >> 8) | (*(_DWORD *)v8 << 24))
        ^ ((*((_DWORD *)v8 + 1) >> 1) | (*(_DWORD *)v8 << 31))
        ^ (*((_DWORD *)v8 + 1) >> 7);
    v14 = (*(__int64 *)v8 >> 1) ^ (*(__int64 *)v8 >> 8) ^ (*(__int64 *)v8 >> 7);
    *((_DWORD *)v8 + 30) = v12 + v14;
    *((_DWORD *)v8 + 31) = v13 + __CFADD__((_DWORD)v12, v14) + HIDWORD(v12);
  }
  while ( &v52 != v8 );
  v15 = 0;
  while ( 1 )
  {
    v16 = *(_DWORD *)((char *)&unk_62E48 + v15);
    v17 = *(_DWORD *)((char *)&unk_62E48 + v15 + 4);
    v18 = *(_DWORD *)&v51[v15];
    v19 = &v51[v15];
    v15 += 8;
    v20 = __PAIR64__(
            ((v6 >> 14) | (v5 << 18)) ^ ((v6 >> 18) | (v5 << 14)) ^ ((v6 << 23) | (v5 >> 9)),
            ((v5 >> 14) | (v6 << 18)) ^ ((v5 >> 18) | (v6 << 14)) ^ ((v5 << 23) | (v6 >> 9)))
        + __PAIR64__(*((_DWORD *)v19 + 1) + (unsigned int)__CFADD__(v16, v18) + v17, v16 + v18);
    v21 = ((v1 << 30) | (v44 >> 2)) ^ ((v1 >> 28) | (16 * v44)) ^ ((v1 << 25) | (v44 >> 7));
    v22 = __PAIR64__(
            (HIDWORD(v48) & ~v6 ^ v6 & HIDWORD(v47)) + __CFADD__((_DWORD)v20, v5 & v47 ^ v48 & ~v5) + HIDWORD(v20),
            v20 + (v5 & v47 ^ v48 & ~v5))
        + v50
        + v49;
    v25 = __PAIR64__(
            (HIDWORD(v48) & ~v6 ^ v6 & HIDWORD(v47)) + __CFADD__((_DWORD)v20, v5 & v47 ^ v48 & ~v5) + HIDWORD(v20),
            v20 + (v5 & v47 ^ v48 & ~v5))
        + v50
        + __PAIR64__(
            (HIDWORD(v45) & HIDWORD(v46) ^ (HIDWORD(v45) ^ HIDWORD(v46)) & v44)
          + __CFADD__(v21, v45 & v46 ^ (v45 ^ v46) & v1)
          + (((v44 >> 28) | (16 * v1)) ^ ((v44 << 30) | (v1 >> 2)) ^ ((v44 << 25) | (v1 >> 7))),
            v21 + (v45 & v46 ^ (v45 ^ v46) & v1));
    v24 = HIDWORD(v25);
    v23 = v25;
    v49 = v46;
    v50 = v48;
    if ( v15 == 640 )
      break;
    v40 = v47;
    LODWORD(v47) = v5;
    v5 = v22;
    LODWORD(v48) = v40;
    v41 = HIDWORD(v47);
    HIDWORD(v47) = v6;
    v6 = HIDWORD(v22);
    HIDWORD(v48) = v41;
    v42 = v45;
    LODWORD(v45) = v1;
    v1 = v23;
    v46 = __PAIR64__(HIDWORD(v45), v42);
    v43 = v44;
    v44 = v24;
    HIDWORD(v45) = v43;
  }
  v27 = *(_QWORD *)(a1 + 16) + __PAIR64__(v24, v23);
  result = *(_DWORD *)(a1 + 16) + v23;
  v28 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v27;
  *(_DWORD *)(a1 + 24) = v28 + v1;
  v29 = v28 + __PAIR64__(v44, v1);
  LODWORD(v28) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 28) = HIDWORD(v29);
  v30 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = v30 + v45;
  HIDWORD(v28) = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 36) = (__PAIR64__(v28, v30) + v45) >> 32;
  LODWORD(v28) = *(_DWORD *)(a1 + 44);
  v31 = HIDWORD(v28);
  *(_DWORD *)(a1 + 40) = HIDWORD(v28) + v46;
  HIDWORD(v28) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 44) = (__PAIR64__(v28, v31) + v46) >> 32;
  v32 = __CFADD__(HIDWORD(v28), (_DWORD)v22);
  v33 = HIDWORD(v28) + v22;
  v34 = *(_QWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 48) = v33;
  v35 = HIDWORD(v22) + v32 + (_DWORD)v34;
  v32 = __CFADD__(HIDWORD(v34), v5);
  v36 = HIDWORD(v34) + v5;
  v37 = *(_QWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 52) = v35;
  v38 = v6 + v32 + (_DWORD)v37;
  LODWORD(v37) = *(_DWORD *)(a1 + 68);
  *(_DWORD *)(a1 + 56) = v36;
  *(_DWORD *)(a1 + 60) = v38;
  v39 = __PAIR64__(v37, HIDWORD(v37)) + v47;
  *(_DWORD *)(a1 + 64) = HIDWORD(v37) + v47;
  HIDWORD(v37) = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 68) = HIDWORD(v39);
  *(_QWORD *)(a1 + 72) = __PAIR64__(*(_DWORD *)(a1 + 76), HIDWORD(v37)) + v48;
  return result;
}
// 598B0: variable 'v7' is possibly undefined

//----- (00059C58) --------------------------------------------------------
_DWORD *__fastcall sub_59C58(_DWORD *result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r1
  unsigned int v3; // t1
  unsigned int v4; // r3
  int v5; // r1
  int v6; // r6
  int v7; // lr
  int v8; // r5
  int v9; // r4
  int v10; // r12
  int v11; // r3
  int v12; // r10
  int v13; // r7
  int v14; // r8
  int v15; // r2
  int v16; // r11
  int v17; // r2
  int v18; // r2
  int v19; // [sp+0h] [bp-9Ch]
  int v20; // [sp+4h] [bp-98h]
  int v21; // [sp+8h] [bp-94h]
  int v22; // [sp+Ch] [bp-90h]
  int v23; // [sp+10h] [bp-8Ch]
  _DWORD v24[34]; // [sp+14h] [bp-88h] BYREF

  v1 = result - 1;
  v2 = v24;
  do
  {
    v3 = v1[1];
    ++v1;
    v4 = bswap32(v3);
    v2[17] = v4;
    v2[1] = v4;
    ++v2;
  }
  while ( v1 != result + 15 );
  v5 = 0;
  v6 = 0;
  v19 = result[20];
  v7 = v19;
  v20 = result[21];
  v8 = v20;
  v21 = result[22];
  v22 = result[23];
  v9 = v22;
  v23 = result[24];
  v10 = v23;
  v11 = v21;
  do
  {
    v12 = v10;
    v13 = v8;
    v10 = v9;
    v8 = v7;
    v9 = v11;
    v14 = 19;
    v24[0] = dword_640BC[v6];
    while ( 1 )
    {
      v15 = v11 ^ v10;
      v16 = v24[v5 + 1];
      if ( v6 )
      {
        if ( v6 == 2 )
        {
          v18 = v13 | v11;
          v11 &= v13;
          v17 = v18 & v10;
        }
        else
        {
          v17 = v15 ^ v13;
        }
        if ( v6 == 2 )
          v17 |= v11;
      }
      else
      {
        v17 = v15 & v13 ^ v10;
        if ( v14 > 3 )
          goto LABEL_7;
      }
      v16 = __ROR4__(v16 ^ v24[v5 + 14] ^ v24[v5 + 9] ^ v24[v5 + 3], 31);
      v24[v5 + 17] = v16;
      v24[v5 + 1] = v16;
LABEL_7:
      --v14;
      v5 = ((_BYTE)v5 + 1) & 0xF;
      v11 = __ROR4__(v13, 2);
      v13 = v8;
      v7 = v24[0] + __ROR4__(v7, 27) + v17 + v16 + v12;
      v12 = v10;
      if ( v14 == -1 )
        break;
      v10 = v9;
      v8 = v7;
      v9 = v11;
    }
    ++v6;
  }
  while ( v6 != 4 );
  result[20] = v19 + v7;
  result[21] = v8 + v20;
  result[22] = v21 + v11;
  result[23] = v9 + v22;
  result[24] = v10 + v23;
  return result;
}
// 640BC: using guessed type _DWORD dword_640BC[4];

//----- (00059E14) --------------------------------------------------------
_DWORD *__fastcall sub_59E14(_DWORD *result)
{
  int i; // r3
  char *v2; // r3
  unsigned int v3; // r1
  char *v4; // r4
  unsigned int v5; // t1
  int v6; // r5
  int v7; // r12
  int v8; // r4
  int v9; // lr
  int v10; // r11
  int v11; // r1
  int v12; // r8
  int v13; // r7
  int v14; // r10
  int v15; // r3
  char *v16; // r2
  int v17; // r3
  int v18; // r2
  int v19; // r3
  int v20; // [sp+4h] [bp-120h]
  int v21; // [sp+8h] [bp-11Ch]
  int v22; // [sp+Ch] [bp-118h]
  int v23; // [sp+10h] [bp-114h]
  int v24; // [sp+14h] [bp-110h]
  int v25; // [sp+18h] [bp-10Ch]
  int v26; // [sp+1Ch] [bp-108h]
  _DWORD v27[48]; // [sp+20h] [bp-104h] BYREF
  char v28; // [sp+E0h] [bp-44h] BYREF

  for ( i = 0; i != 16; ++i )
    v27[i] = bswap32(result[i]);
  v2 = (char *)v27;
  do
  {
    v3 = *((_DWORD *)v2 + 14);
    v4 = v2;
    v5 = *((_DWORD *)v2 + 1);
    v2 += 4;
    *((_DWORD *)v2 + 15) = (__ROR4__(v3, 19) ^ __ROR4__(v3, 17) ^ (v3 >> 10))
                         + *((_DWORD *)v4 + 9)
                         + *(_DWORD *)v4
                         + (__ROR4__(v5, 18) ^ __ROR4__(v5, 7) ^ (v5 >> 3));
  }
  while ( &v28 != v2 );
  v6 = 0;
  v20 = result[21];
  v7 = result[20];
  v21 = result[22];
  v8 = v20;
  v9 = v21;
  v22 = result[23];
  v10 = v22;
  v23 = result[24];
  v11 = v23;
  v24 = result[25];
  v12 = v24;
  v25 = result[26];
  v13 = v25;
  v14 = result[27];
  v26 = v14;
  while ( 1 )
  {
    v15 = (__ROR4__(v11, 11) ^ __ROR4__(v11, 6) ^ __ROR4__(v11, 25)) + (v11 & v12 ^ v13 & ~v11) + v27[v6];
    v16 = (char *)&unk_62E48 + 8 * v6++;
    v17 = v15 + *((_DWORD *)v16 + 1) + v14;
    v14 = v13;
    v18 = v17 + v10;
    v19 = v17 + (__ROR4__(v7, 2) ^ __ROR4__(v7, 13) ^ __ROR4__(v7, 22)) + ((v8 ^ v9) & v7 ^ v8 & v9);
    v10 = v9;
    if ( v6 == 64 )
      break;
    v13 = v12;
    v9 = v8;
    v12 = v11;
    v8 = v7;
    v11 = v18;
    v7 = v19;
  }
  result[20] += v19;
  result[21] = v20 + v7;
  result[22] = v21 + v8;
  result[23] = v22 + v9;
  result[24] = v23 + v18;
  result[25] = v24 + v11;
  result[26] = v25 + v12;
  result[27] = v26 + v13;
  return result;
}

//----- (00059FE0) --------------------------------------------------------
int __fastcall sub_59FE0(int result)
{
  *(_QWORD *)(result + 80) = 0xEFCDAB8967452301LL;
  *(_QWORD *)(result + 88) = 0x1032547698BADCFELL;
  *(_QWORD *)(result + 72) = 0;
  *(_DWORD *)(result + 64) = sub_59468;
  return result;
}

//----- (0005A024) --------------------------------------------------------
void *__fastcall sub_5A024(int a1, char *src, size_t n)
{
  __int64 v5; // r0
  unsigned int v6; // r6
  int v7; // r7
  size_t v8; // r4
  char *v9; // r1
  void *result; // r0

  v5 = *(_QWORD *)(a1 + 72);
  v6 = n;
  v7 = v5 & 0x3F;
  *(_QWORD *)(a1 + 72) = v5 + n;
  while ( 1 )
  {
    v8 = 64 - v7;
    v9 = src;
    if ( 64 - v7 >= v6 )
      v8 = v6;
    v6 -= v8;
    src += v8;
    result = memcpy((void *)(a1 + v7), v9, v8);
    if ( v7 + v8 != 64 )
      break;
    (*(void (__fastcall **)(int))(a1 + 64))(a1);
    v7 = 0;
  }
  return result;
}

//----- (0005A08C) --------------------------------------------------------
int __fastcall sub_5A08C(int a1, _DWORD *a2)
{
  int *v4; // r3
  _DWORD *v5; // r1
  int *v6; // r4
  int v7; // t1

  sub_597A4(a1, 0);
  v4 = (int *)(a1 + 80);
  v5 = a2;
  v6 = (int *)(a1 + 96);
  do
  {
    v7 = *v4++;
    *v5++ = v7;
  }
  while ( v4 != v6 );
  return 16;
}

//----- (0005A0C4) --------------------------------------------------------
int __fastcall sub_5A0C4(int a1)
{
  int *v1; // r12
  int v2; // r2
  int result; // r0
  int v5; // r1
  bool v6; // zf

  v1 = dword_6406C;
  v2 = a1 + 72;
  do
  {
    v2 += 8;
    result = *v1;
    v5 = v1[1];
    v6 = v1 + 2 == dword_64094;
    *(_DWORD *)(v2 - 8) = *v1;
    *(_DWORD *)(v2 - 4) = v5;
    v1 += 2;
  }
  while ( !v6 );
  *(_DWORD *)(a1 + 64) = sub_59E14;
  return result;
}
// 6406C: using guessed type _DWORD dword_6406C[10];
// 64094: using guessed type _DWORD dword_64094[10];

//----- (0005A10C) --------------------------------------------------------
int __fastcall sub_5A10C(int a1)
{
  int result; // r0
  int i; // r3
  unsigned int v3; // r2
  __int64 v4; // r6

  result = a1 - 8;
  for ( i = 0; i != 10; ++i )
  {
    v3 = dword_64094[i];
    LODWORD(v4) = 0;
    HIDWORD(v4) = dword_6406C[i];
    *(_QWORD *)(result + 8) = v4 + v3;
    result += 8;
  }
  return result;
}
// 6406C: using guessed type _DWORD dword_6406C[10];
// 64094: using guessed type _DWORD dword_64094[10];

//----- (0005A150) --------------------------------------------------------
void *__fastcall sub_5A150(__int64 *a1, char *src, size_t n)
{
  __int64 v5; // r0
  unsigned int v6; // r5
  __int64 v7; // r8
  int v8; // r10
  _BOOL4 v9; // r2
  size_t v10; // r6
  void *result; // r0

  v5 = *a1;
  v6 = n;
  v8 = v5 & 0x7F;
  v7 = v5 + n;
  v9 = __CFADD__(__CFADD__((_DWORD)v5, n), HIDWORD(v5));
  *a1 = v7;
  if ( v9 )
    ++a1[1];
  while ( 1 )
  {
    v10 = 128 - v8;
    if ( v6 < 128 - v8 )
      v10 = v6;
    result = memcpy((char *)a1 + v8 + 80, src, v10);
    v6 -= v10;
    src += v10;
    if ( v10 + v8 != 128 )
      break;
    v8 = 0;
    sub_5981C((int)a1);
  }
  return result;
}

//----- (0005A1E8) --------------------------------------------------------
size_t __fastcall sub_5A1E8(int a1, void *a2)
{
  unsigned int *v4; // r3
  const void *v5; // r1
  size_t v6; // r4
  unsigned int *v7; // r0

  sub_597A4(a1, 1);
  v4 = (unsigned int *)(a1 + 80);
  v5 = (const void *)(a1 + 80);
  if ( *(_DWORD *(__fastcall **)(_DWORD *))(a1 + 64) == sub_59C58 )
    v6 = 5;
  else
    v6 = 8;
  v7 = &v4[v6];
  do
  {
    *v4 = bswap32(*v4);
    ++v4;
  }
  while ( v4 != v7 );
  memcpy(a2, v5, v6 * 4);
  return v6 * 4;
}

//----- (0005A248) --------------------------------------------------------
int __fastcall sub_5A248(int a1, _DWORD *a2)
{
  int *v4; // r7
  int v5; // r3
  int v6; // r0
  unsigned int v7; // r5
  __int64 v8; // r0
  int v9; // r3
  __int64 v10; // r0
  int v11; // r4
  int *v12; // r5
  __int64 v13; // r0
  int *v14; // r3
  _DWORD *v15; // r1
  int v16; // t1

  v4 = (int *)(a1 + 80);
  v5 = *(_DWORD *)a1 & 0x7F;
  v6 = v5 + 1;
  *(_BYTE *)(a1 + v5 + 80) = 0x80;
  do
  {
    v7 = 128 - v6;
    memset((char *)v4 + v6, 0, 128 - v6);
    if ( v7 > 0xF )
    {
      LODWORD(v8) = sub_57900(8 * *(_DWORD *)a1, *(_QWORD *)a1 >> 29);
      v9 = *(_DWORD *)(a1 + 12);
      *(_QWORD *)(a1 + 200) = v8;
      LODWORD(v10) = sub_57900(*(__int64 *)(a1 + 4) >> 29, (8 * v9) | (*(_DWORD *)(a1 + 8) >> 29));
      *(_QWORD *)(a1 + 192) = v10;
    }
    sub_5981C(a1);
    v6 = 0;
  }
  while ( v7 <= 0xF );
  v11 = a1 + 16;
  v12 = (int *)v11;
  do
  {
    LODWORD(v13) = sub_57900(*(_DWORD *)v11, *(_DWORD *)(v11 + 4));
    *(_QWORD *)v11 = v13;
    v11 += 8;
  }
  while ( (int *)v11 != v4 );
  v14 = v12;
  v15 = a2;
  do
  {
    v16 = *v14++;
    *v15++ = v16;
  }
  while ( v14 != v4 );
  return 64;
}
// 5A2A4: variable 'v8' is possibly undefined
// 5A2C4: variable 'v10' is possibly undefined
// 5A2EC: variable 'v13' is possibly undefined

//----- (0005A318) --------------------------------------------------------
char *__fastcall sub_5A318(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned __int64 v3; // r8
  int v4; // r12
  const char *v5; // r12
  unsigned __int8 *v6; // lr
  char *v7; // r0
  int v9; // r3

  v3 = a1;
  HIDWORD(a1) |= a1;
  if ( HIDWORD(a1) )
  {
    if ( a2 > 1 )
    {
      v4 = a2 * HIDWORD(v3);
      v3 = (unsigned int)a1 * (unsigned __int64)a2;
      HIDWORD(v3) += v4;
    }
    if ( a3 )
    {
      LODWORD(a1) = sub_62C44(v3 + (a3 >> 1), a3);
      v5 = "%llu";
      v3 = a1;
      v6 = (unsigned __int8 *)&unk_6BC1B;
      a3 = 0;
    }
    else
    {
      v5 = "%llu";
      v6 = (unsigned __int8 *)&unk_6BC1B;
      while ( v3 > 0x3FF )
      {
        v9 = 10 * (v3 & 0x3FF);
        ++v6;
        v5 = "%llu.%u%c";
        v3 >>= 10;
        a3 = (unsigned int)(v9 + 512) >> 10;
      }
      if ( a3 == 10 )
      {
        ++v3;
        if ( !a2 )
        {
          v7 = sub_177E4("%llu%*c", HIDWORD(a1), v3, 1, *v6);
          return (char *)sub_57710((int)v7);
        }
        a3 = 0;
      }
      else if ( !a2 )
      {
        if ( a3 > 4 )
          ++v3;
        v7 = sub_177E4("%llu%*c", HIDWORD(a1), v3, 1, *v6, a2);
        return (char *)sub_57710((int)v7);
      }
    }
    v7 = sub_177E4(v5, HIDWORD(a1), v3, a3, *v6, a2);
    return (char *)sub_57710((int)v7);
  }
  return "0";
}
// 5A360: variable 'a1' is possibly undefined

//----- (0005A454) --------------------------------------------------------
int __fastcall sub_5A454(unsigned __int8 *a1, _WORD *a2)
{
  _BYTE *v3; // r1
  _BYTE *v4; // r4
  char v5; // r12
  unsigned __int8 *v6; // lr
  unsigned __int8 *v7; // r7
  int v8; // r6
  int v9; // r5
  int v10; // t1
  unsigned int v11; // r3
  bool v13; // zf

  v3 = a2 + 4;
  *a2 = 1;
  v4 = a2 + 1;
LABEL_2:
  v5 = 0;
  v6 = a1;
  v7 = a1 + 2;
  v8 = 0;
  while ( 1 )
  {
    a1 = v6;
    v10 = *v6++;
    v9 = v10;
    v11 = (unsigned __int8)(v10 - 48);
    if ( v11 > 9 )
      break;
LABEL_6:
    a1 = v6;
    v5 = v11 + 16 * v5;
    v8 = 1;
    if ( v6 == v7 )
    {
LABEL_7:
      *v4++ = v5;
      if ( v4 == v3 )
        return *a1;
      if ( *a1 == 58 )
        ++a1;
      goto LABEL_2;
    }
  }
  if ( (v9 | 0x20u) - 97 <= 5 )
  {
    LOBYTE(v11) = (v9 | 0x20) - 87;
    goto LABEL_6;
  }
  if ( v8 )
  {
    v13 = v9 == 0;
    if ( v9 )
      v13 = v9 == 58;
    if ( v13 )
      goto LABEL_7;
  }
  return -1;
}

//----- (0005A500) --------------------------------------------------------
int __fastcall sub_5A500(unsigned __int16 *a1, int a2)
{
  unsigned int v2; // r3
  int v4; // t1

  v2 = 0;
  while ( a2 > 1 )
  {
    v4 = *a1++;
    a2 -= 2;
    v2 += v4;
  }
  if ( a2 == 1 )
    v2 += *(unsigned __int8 *)a1;
  return (unsigned __int16)~(v2 + HIWORD(v2) + ((unsigned int)((unsigned __int16)v2 + HIWORD(v2)) >> 16));
}

//----- (0005A53C) --------------------------------------------------------
int __fastcall sub_5A53C(const char *a1, struct in_addr *a2)
{
  int v4; // r5
  struct hostent *v5; // r0
  char **h_addr_list; // r3

  a2->s_addr = 2;
  if ( !strcmp(a1, "default") )
  {
    a2[1].s_addr = 0;
    return 1;
  }
  else
  {
    v4 = inet_aton(a1, a2 + 1);
    if ( v4 )
    {
      return 0;
    }
    else
    {
      v5 = gethostbyname(a1);
      if ( v5 )
        h_addr_list = v5->h_addr_list;
      else
        v4 = -1;
      if ( v5 )
        a2[1].s_addr = *(in_addr_t *)*h_addr_list;
    }
  }
  return v4;
}
// 5A598: variable 'h_addr_list' is possibly undefined

//----- (0005A5B0) --------------------------------------------------------
char *__fastcall sub_5A5B0(int a1, unsigned int a2, int a3)
{
  char *v3; // r6
  int v6; // r8
  const char *v7; // r0
  int v8; // r4
  _DWORD *i; // r0
  size_t v10; // r0
  void *v11; // r0
  int v12; // r3
  int v13; // r5

  if ( *(_WORD *)a1 != 2 )
  {
    v3 = 0;
    *(_DWORD *)dword_7DB94 = 97;
    return v3;
  }
  v6 = *(_DWORD *)(a1 + 4);
  if ( (a2 & 0xFFF) != 0 )
    return sub_6249C((const struct sockaddr *)a1);
  if ( v6 )
  {
    if ( (v6 & ~a3) != 0 )
      v8 = 1;
    else
      v8 = (a2 >> 14) & 1;
    for ( i = (_DWORD *)dword_7D754; i; i = (_DWORD *)*i )
    {
      if ( i[1] == v6 && i[2] == v8 )
      {
        v7 = (const char *)(i + 3);
        return sub_174F8(v7);
      }
    }
    if ( !v8 || (v3 = sub_62494((const struct sockaddr *)a1)) == 0 )
      v3 = sub_6249C((const struct sockaddr *)a1);
    v10 = strlen(v3);
    v11 = sub_1748C(v10 + 16);
    v12 = dword_7D754;
    v13 = (int)v11;
    *((_DWORD *)v11 + 2) = v8;
    *(_DWORD *)v11 = v12;
    *((_DWORD *)v11 + 1) = v6;
    strcpy((char *)v11 + 12, v3);
    dword_7D754 = v13;
    return v3;
  }
  if ( (a2 & 0x8000) != 0 )
    v7 = "default";
  else
    v7 = "*";
  return sub_174F8(v7);
}
// 7D754: using guessed type int dword_7D754;
// 7DB94: using guessed type int dword_7DB94;

//----- (0005A6C0) --------------------------------------------------------
int __fastcall sub_5A6C0(int a1)
{
  int v1; // r4
  __int64 v2; // r6
  int v4; // r1
  int result; // r0

  v1 = dword_7D758;
  if ( !dword_7D758 )
    return 0;
  v2 = *(_QWORD *)(a1 + 96);
  sub_15EFC(*(_DWORD *)(a1 + 96), 0x137u);
  for ( result = *(_DWORD *)(v1 + 4 * v4); result; result = *(_DWORD *)(result + 16) )
  {
    if ( v2 == *(_QWORD *)result
      && *(_QWORD *)(result + 8) == *(_QWORD *)a1
      && *(_BYTE *)(result + 20) == ((*(_DWORD *)(a1 + 16) & 0xF000) == 0x4000) )
    {
      result += 21;
      return result;
    }
  }
  return result;
}
// 5A6E8: variable 'v4' is possibly undefined
// 7D758: using guessed type int dword_7D758;

//----- (0005A754) --------------------------------------------------------
unsigned int __fastcall sub_5A754(int a1, char *s)
{
  const char *v2; // r5
  size_t v4; // r0
  void *v5; // r4
  unsigned int result; // r0
  int v7; // r3
  int v8; // r1

  v2 = "";
  if ( s )
    v2 = s;
  v4 = strlen(v2);
  v5 = sub_1748C(v4 + 24);
  *(_QWORD *)v5 = *(_QWORD *)(a1 + 96);
  *((_QWORD *)v5 + 1) = *(_QWORD *)a1;
  *((_BYTE *)v5 + 20) = (*(_DWORD *)(a1 + 16) & 0xF000) == 0x4000;
  strcpy((char *)v5 + 21, v2);
  if ( !dword_7D758 )
    dword_7D758 = (int)sub_174DC(0x4DCu);
  result = sub_15EFC(*(_DWORD *)(a1 + 96), 0x137u);
  v7 = dword_7D758;
  *((_DWORD *)v5 + 4) = *(_DWORD *)(dword_7D758 + 4 * v8);
  *(_DWORD *)(v7 + 4 * v8) = v5;
  return result;
}
// 5A7DC: variable 'v8' is possibly undefined
// 7D758: using guessed type int dword_7D758;

//----- (0005A7F4) --------------------------------------------------------
void sub_5A7F4()
{
  void *v0; // r5
  int v1; // r7
  int v2; // r6
  _DWORD *i; // r0
  _DWORD *v4; // t1
  _DWORD *v5; // r8

  v0 = (void *)dword_7D758;
  if ( dword_7D758 )
  {
    v1 = dword_7D758 - 4;
    v2 = dword_7D758 + 1240;
    while ( v1 != v2 )
    {
      v4 = *(_DWORD **)(v1 + 4);
      v1 += 4;
      for ( i = v4; i; i = v5 )
      {
        v5 = (_DWORD *)i[4];
        free(i);
      }
    }
    free(v0);
    dword_7D758 = 0;
  }
}
// 7D758: using guessed type int dword_7D758;

//----- (0005A854) --------------------------------------------------------
bool __fastcall sub_5A854(int a1, int a2)
{
  int v2; // r0
  bool v3; // zf
  _BOOL4 result; // r0
  _BOOL4 v5; // [sp+10h] [bp-5Ch]

  if ( a2 )
    v2 = sub_62DFC();
  else
    v2 = sub_62E14();
  v3 = v2 == 0;
  if ( v2 )
    result = 0;
  else
    result = v5;
  if ( v3 )
    return (result & 0xF000) == 0x4000;
  return result;
}
// 5A870: variable 'v5' is possibly undefined

//----- (0005A898) --------------------------------------------------------
int __fastcall sub_5A898(unsigned int a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r3
  int v4; // r12
  unsigned __int64 v5; // r4
  int v6; // r4
  char v7; // lr

  v2 = 62;
  v3 = 0;
  do
  {
    v4 = 2 * v3;
    HIDWORD(v5) = a2 >> v2;
    v3 = 2 * v3 + 1;
    v6 = (a1 >> v2) | (a2 << (32 - v2));
    v7 = v2 - 32;
    v2 -= 2;
    LODWORD(v5) = v6 | (a2 >> v7);
    if ( (unsigned int)v3 * (unsigned __int64)(unsigned int)v3 > v5 )
      v3 = v4;
  }
  while ( v2 != -2 );
  return v3;
}

//----- (0005A8E8) --------------------------------------------------------
int sub_5A8E8()
{
  int v0; // r6
  int v1; // r5
  char *release; // r0
  int v3; // r5
  char *v4; // r0
  int v5; // r0
  struct utsname v7; // [sp+0h] [bp-18Ch] BYREF

  v0 = 3;
  v1 = 0;
  uname(&v7);
  release = v7.release;
  do
  {
    v3 = v1 << 8;
    v4 = strtok(release, ".");
    if ( v4 )
      v5 = atoi(v4);
    else
      v5 = 0;
    --v0;
    v1 = v3 + v5;
    release = 0;
  }
  while ( v0 );
  return v1;
}

//----- (0005A944) --------------------------------------------------------
bool __fastcall sub_5A944(unsigned int a1)
{
  unsigned int v1; // r3
  bool v2; // cf
  bool v3; // zf

  if ( a1 - 48 <= 9 )
    return 1;
  v1 = (a1 | 0x20) - 97;
  v2 = a1 >= 0x5F;
  v3 = a1 == 95;
  if ( a1 != 95 )
  {
    v2 = v1 >= 0x19;
    v3 = v1 == 25;
  }
  return v3 || !v2;
}

//----- (0005A974) --------------------------------------------------------
_WORD *__fastcall sub_5A974(_WORD *result, int a2, int a3)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3

  if ( a2 != a3 )
  {
    result += a2;
    v3 = -1 * a2;
    v4 = a3;
    do
    {
      v5 = (__int16)result[v3 + v4];
      *result++ = v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (0005A9A4) --------------------------------------------------------
int __fastcall sub_5A9A4(int a1)
{
  size_t v2; // r0
  unsigned __int8 *v3; // r3
  _WORD *v4; // r0
  __int16 v5; // t1
  unsigned int v6; // r2
  int v7; // r5
  int v8; // r1
  _WORD *v9; // r7
  int v10; // r6
  int v11; // t1
  int v12; // r7
  int v13; // r3
  int v14; // r12
  int v15; // r0
  int v16; // r6
  int v17; // r3
  int v18; // t1
  int v19; // r7
  int v20; // r8
  bool v21; // zf
  bool v22; // zf
  bool v23; // zf
  unsigned int v24; // r1
  unsigned int v25; // r1
  int v26; // lr
  int v27; // r1
  int i; // r2
  int v29; // r1
  int v30; // r3
  int v31; // t1
  int j; // r1
  int v33; // r3
  int v34; // r1
  int k; // r2
  int v36; // t1
  int v37; // r6
  int v38; // r0
  __int64 v39; // r2
  int v40; // r3
  int v41; // t1
  int v42; // r2
  int m; // r3
  int v44; // t1
  int v45; // r2
  int v46; // r3
  int v47; // r0
  int v48; // t1
  unsigned int v49; // r1
  int v50; // r4
  __int16 v51; // t1
  bool v53; // zf
  bool v54; // zf
  _BOOL4 v55; // r6

  v2 = strlen((const char *)a1);
  v3 = (unsigned __int8 *)(a1 + v2);
  v4 = (_WORD *)(a1 + 2 * v2);
  do
  {
    v5 = *v3--;
    *v4-- = v5;
    v6 = (unsigned int)&v3[-a1];
  }
  while ( (int)&v3[-a1] >= 0 );
  v7 = a1 - 2;
  v8 = 0;
  v9 = (_WORD *)(a1 - 2);
  while ( 1 )
  {
    v11 = (__int16)v9[1];
    ++v9;
    v10 = v11;
    if ( !v11 )
      break;
    v20 = v8 + 1;
    if ( v10 == 92 )
    {
      sub_5A974((_WORD *)a1, v8, v8 + 1);
      *v9 |= 0x100u;
    }
    v8 = v20;
  }
  v12 = 0;
  while ( 1 )
  {
    v13 = *(__int16 *)(a1 + 2 * v12);
    if ( !*(_WORD *)(a1 + 2 * v12) )
      break;
    v21 = v13 == 34;
    if ( v13 != 34 )
      v21 = v13 == 39;
    v6 = v12 + 1;
    if ( !v21 )
    {
      if ( !v10 )
        goto LABEL_26;
      goto LABEL_25;
    }
    v22 = v10 == v13;
    if ( v10 != v13 )
      v22 = v10 == 0;
    if ( v22 )
    {
      v10 ^= v13;
      sub_5A974((_WORD *)a1, v12, v6);
    }
    else
    {
LABEL_25:
      *(_WORD *)(a1 + 2 * v12) = v13 | 0x100;
LABEL_26:
      ++v12;
    }
  }
  while ( 2 )
  {
    v14 = 2 * v13;
    v15 = *(__int16 *)(a1 + 2 * v13);
    if ( *(_WORD *)(a1 + 2 * v13) )
    {
      v23 = v15 == 38;
      if ( v15 != 38 )
        v23 = v15 == 59;
      v24 = __clz(v15 - 124);
      if ( v23 )
        v6 = 1;
      v25 = v24 >> 5;
      if ( !v23 )
        v6 = 0;
      v6 |= v25;
      if ( !v6 )
        goto LABEL_44;
      if ( v13 )
      {
        v26 = *(__int16 *)(a1 + v14 - 2);
        if ( v15 == 38 )
        {
          v6 = v26 & 0xFFFFFFFD;
          if ( (v26 & 0xFFFFFFFD) == 0x3C )
          {
LABEL_44:
            ++v13;
            continue;
          }
        }
      }
      else
      {
        v26 = 0;
      }
      if ( v26 == 62 )
        v27 = v25 & 1;
      else
        v27 = 0;
      v6 = v13 + 1;
      if ( !v27 )
      {
        if ( *(__int16 *)(a1 + v14 + 2) == v15 )
          v6 = v13 + 2;
        sub_5A974((_WORD *)a1, 0, v6);
        v13 = -1;
      }
      goto LABEL_44;
    }
    break;
  }
  v16 = a1 - 2;
  while ( 1 )
  {
    v18 = *(__int16 *)(v16 + 2);
    v16 += 2;
    v17 = v18;
    if ( !v18 )
      break;
    v19 = v15 + 1;
    if ( v17 == 96 )
    {
      v30 = v16;
      for ( i = v15 + 1; ; ++i )
      {
        v31 = *(__int16 *)(v30 + 2);
        v30 += 2;
        v29 = v31;
        if ( !v31 )
          break;
        if ( v29 == 96 )
        {
          sub_5A974((_WORD *)a1, v15, i);
          goto LABEL_11;
        }
      }
      sub_5A974((_WORD *)a1, 0, v15 + 1);
      break;
    }
LABEL_11:
    v15 = v19;
  }
  for ( j = 0; ; ++j )
  {
    v33 = *(__int16 *)(a1 + 2 * j);
    if ( !*(_WORD *)(a1 + 2 * j) )
      break;
    v53 = v33 == 123;
    if ( v33 != 123 )
      v53 = v33 == 40;
    if ( v53 )
    {
      sub_5A974((_WORD *)a1, 0, j + 1);
      j = -1;
    }
  }
  v34 = a1 - 2;
  for ( k = v33; ; ++k )
  {
    v36 = *(__int16 *)(v34 + 2);
    v34 += 2;
    if ( v36 != 32 )
      break;
  }
  sub_5A974((_WORD *)a1, 0, k);
  v37 = 0;
  v38 = a1 - 2;
  for ( LODWORD(v39) = 0; ; LODWORD(v39) = v39 + 1 )
  {
    v41 = *(__int16 *)(v38 + 2);
    v38 += 2;
    v40 = v41;
    if ( !v41 )
      break;
    v54 = v40 == 32;
    if ( v40 != 32 )
      v54 = (v40 & 0xFFFFFFFD) == 60;
    if ( v54 )
    {
      if ( v37 )
        v55 = 0;
      else
        v55 = v40 == 32;
      if ( !v55 || *(_BYTE *)a1 != 99 || (HIDWORD(v39) = *(unsigned __int8 *)(a1 + 2), v39 != 0x6400000002LL) )
      {
        v37 = 2;
        break;
      }
      v37 = 1;
    }
  }
  v42 = a1 - 2;
  for ( m = 0; ; ++m )
  {
    v44 = *(__int16 *)(v42 + 2);
    v42 += 2;
    if ( !v44 )
      break;
  }
  v45 = m - 1;
  v46 = a1 + 2 * m;
  while ( v45 != -1 )
  {
    v48 = *(__int16 *)(v46 - 2);
    v46 -= 2;
    v47 = v48;
    v49 = (unsigned __int16)(v48 - 32);
    if ( v49 > 0x1E )
    {
      if ( v47 == 124 )
      {
LABEL_63:
        sub_5A974((_WORD *)a1, 0, v45 + 1);
        break;
      }
    }
    else if ( ((0x50000041u >> v49) & 1) != 0 )
    {
      goto LABEL_63;
    }
    --v45;
  }
  v50 = a1 - 1;
  do
  {
    v51 = *(_WORD *)(v7 + 2);
    v7 += 2;
    *(_BYTE *)++v50 = v51;
  }
  while ( (_BYTE)v51 );
  return v37;
}
// 5AABC: variable 'v6' is possibly undefined

//----- (0005ACDC) --------------------------------------------------------
int sub_5ACDC()
{
  return j_putchar_unlocked(7);
}

//----- (0005ACE4) --------------------------------------------------------
unsigned int __fastcall sub_5ACE4(unsigned int result)
{
  _DWORD *v1; // r5
  unsigned int v2; // r3
  unsigned int v3; // r4
  unsigned int v4; // r1
  const char *v5; // r0
  unsigned int v6; // r1
  unsigned int v7; // r7
  int v8; // r4
  unsigned int v9; // r0
  int v10; // r6
  unsigned int v11; // r8
  int v12; // r1

  v1 = (_DWORD *)dword_7DBC4;
  v2 = *(_DWORD *)(dword_7DBC4 + 20);
  if ( v2 >= result )
    v3 = result;
  else
    v3 = *(_DWORD *)(dword_7DBC4 + 20);
  if ( v3 )
  {
    v4 = *(_DWORD *)(dword_7DBC4 + 8);
    *(_DWORD *)(dword_7DBC4 + 20) = v2 - v3;
    if ( v4 < v3 )
    {
      v7 = v1[1];
      v8 = v3 - v4;
      v9 = sub_15CA0(v8 - 1, v7);
      v10 = v1[3];
      v11 = v9 + 1;
      sub_15EFC(v10 * v7 - v8, v7);
      v1[3] = v10 - v11;
      v1[2] = v12;
      result = printf("\r\x1B[%uA", v11);
      v6 = v1[2];
      if ( !v6 )
        return result;
      v5 = "\x1B[%uC";
    }
    else
    {
      v1[2] = v4 - v3;
      if ( v3 <= 4 )
      {
        do
        {
          result = j_putchar_unlocked(8);
          --v3;
        }
        while ( v3 );
        return result;
      }
      v5 = "\x1B[%uD";
      v6 = v3;
    }
    return printf(v5, v6);
  }
  return result;
}
// 5AD84: variable 'v12' is possibly undefined
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005ADB8) --------------------------------------------------------
unsigned int sub_5ADB8()
{
  int v0; // r4
  int v1; // r5
  int v2; // r3
  unsigned int v3; // r3
  bool v4; // cc
  int v5; // r3
  unsigned int v6; // r3
  bool v7; // cc
  unsigned int result; // r0

  v0 = dword_7DBC4;
  v1 = *(_DWORD *)(dword_7DBC4 + 32);
  while ( 1 )
  {
    v2 = *(_DWORD *)(v0 + 20);
    if ( !v2 )
      break;
    v3 = *(unsigned __int8 *)(v1 + v2 - 1);
    v4 = v3 > 0x20;
    if ( v3 != 32 )
      v4 = v3 - 9 > 4;
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(v0 + 20);
        if ( !v5 )
          break;
        v6 = *(unsigned __int8 *)(v1 + v5 - 1);
        v7 = v6 > 0x20;
        if ( v6 != 32 )
          v7 = v6 - 9 > 4;
        if ( !v7 )
          break;
        result = sub_5ACE4(1u);
      }
      return result;
    }
    result = sub_5ACE4(1u);
  }
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005AE2C) --------------------------------------------------------
void sub_5AE2C()
{
  int v0; // r5
  int v1; // r4
  int v2; // r6

  v0 = dword_7DBC4;
  if ( **(_BYTE **)(dword_7DBC4 + 32) )
  {
    v1 = *(_DWORD *)(*(_DWORD *)dword_7DBC4 + 16) + 8;
    free(*(void **)(*(_DWORD *)dword_7DBC4 + 4 * v1));
    v2 = *(_DWORD *)v0;
    *(_DWORD *)(v2 + 4 * v1) = sub_174F8(*(const char **)(v0 + 32));
  }
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005AE74) --------------------------------------------------------
int sub_5AE74()
{
  int v0; // r5
  int v1; // r4

  v0 = dword_7DBC4;
  v1 = **(_DWORD **)dword_7DBC4 & 1;
  if ( v1 && *(_DWORD *)(*(_DWORD *)dword_7DBC4 + 16) )
  {
    sub_5AE2C();
    --*(_DWORD *)(*(_DWORD *)v0 + 16);
  }
  else
  {
    sub_5ACDC();
    return 0;
  }
  return v1;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005AEC8) --------------------------------------------------------
int sub_5AEC8()
{
  int v0; // r4
  int result; // r0

  v0 = dword_7DBC4;
  if ( (**(_DWORD **)dword_7DBC4 & 1) != 0
    && *(_DWORD *)(*(_DWORD *)dword_7DBC4 + 16) < *(_DWORD *)(*(_DWORD *)dword_7DBC4 + 12) )
  {
    sub_5AE2C();
    result = *(_DWORD *)(*(_DWORD *)v0 + 16) + 1;
    *(_DWORD *)(*(_DWORD *)v0 + 16) = result;
  }
  else
  {
    sub_5ACDC();
    return 0;
  }
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005AF1C) --------------------------------------------------------
void sub_5AF1C()
{
  int v0; // r5
  int v1; // r4
  void **v2; // r0
  int v3; // r4

  v0 = dword_7DBC4;
  if ( *(_DWORD *)(dword_7DBC4 + 52) )
  {
    while ( 1 )
    {
      v1 = *(_DWORD *)(v0 + 56);
      v2 = *(void ***)(v0 + 52);
      if ( !v1 )
        break;
      v3 = v1 - 1;
      *(_DWORD *)(v0 + 56) = v3;
      free(v2[v3]);
    }
    free(v2);
    *(_DWORD *)(v0 + 52) = 0;
  }
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005AF68) --------------------------------------------------------
void sub_5AF68()
{
  int v0; // r4
  void *v1; // r0

  v0 = dword_7DBC4;
  free(*(void **)(dword_7DBC4 + 36));
  free(*(void **)(v0 + 44));
  v1 = *(void **)(v0 + 48);
  if ( v1 != &unk_6BC3E )
    free(v1);
  free((void *)v0);
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005AFAC) --------------------------------------------------------
size_t __fastcall sub_5AFAC(_DWORD *a1)
{
  size_t result; // r0
  FILE *v3; // r7
  int v4; // r4
  _DWORD *v5; // r6
  int v6; // r1
  int v7; // r2
  _BYTE *v8; // r0
  _BYTE *v9; // r8
  int v10; // r7
  int v11; // r6
  _DWORD *i; // r9
  void *v13; // t1
  _DWORD *v14; // r9
  int v15; // r3
  _DWORD *v16; // r3
  int v17; // r8
  _DWORD s[1007]; // [sp+4h] [bp-F9Ch] BYREF

  result = sub_61C9C(a1[7]);
  v3 = (FILE *)result;
  if ( result )
  {
    v4 = a1[3];
    v5 = &a1[v4 + 8];
    while ( v4 )
    {
      v13 = (void *)*--v5;
      --v4;
      free(v13);
      *v5 = 0;
    }
    memset(s, 0, 0xF9Cu);
    a1[6] = 0;
    while ( 1 )
    {
      v8 = sub_58D24(v3, v6, v7);
      v9 = v8;
      if ( !v8 )
        break;
      if ( *v8 )
      {
        v14 = &s[v4++ + 999];
        free((void *)*(v14 - 999));
        v15 = a1[6];
        *(v14 - 999) = v9;
        a1[6] = v15 + 1;
        if ( a1[5] == v4 )
          v4 = 0;
      }
      else
      {
        free(v8);
      }
    }
    result = fclose(v3);
    v10 = a1[5];
    if ( a1[6] )
    {
      while ( !s[v4] )
      {
        if ( ++v4 == v10 )
          v4 = 0;
      }
    }
    v11 = 0;
    for ( i = a1 + 8; v10 != v11; ++i )
    {
      v16 = &s[v4 + 999];
      v17 = *(v16 - 999);
      if ( !v17 )
        break;
      ++v4;
      ++v11;
      if ( v10 == v4 )
        v4 = 0;
      result = strlen((const char *)*(v16 - 999));
      *i = v17;
      if ( result >= 0x400 )
        *(_BYTE *)(v17 + 1023) = 0;
    }
    a1[3] = v11;
  }
  return result;
}
// 5AFFC: variable 'v6' is possibly undefined
// 5AFFC: variable 'v7' is possibly undefined

//----- (0005B0F4) --------------------------------------------------------
void sub_5B0F4()
{
  int v0; // r4
  int v1; // r5
  int v2; // r3
  unsigned int v3; // r1
  bool v4; // cc
  int v5; // r3
  int v6; // r3

  v0 = dword_7DBC4;
  v1 = *(_DWORD *)(dword_7DBC4 + 32);
  if ( *(_DWORD *)(dword_7DBC4 + 20) )
  {
    while ( 1 )
    {
      sub_5ACE4(1u);
      v2 = *(_DWORD *)(v0 + 20);
      if ( !v2 )
        break;
      v3 = *(unsigned __int8 *)(v1 + v2);
      v4 = v3 > 0x20;
      if ( v3 != 32 )
        v4 = v3 - 9 > 4;
      if ( v4 )
      {
        if ( sub_5A944(v3) )
        {
          while ( 1 )
          {
            v6 = *(_DWORD *)(v0 + 20);
            if ( !v6 || !sub_5A944(*(unsigned __int8 *)(v1 + v6 - 1)) )
              break;
            sub_5ACE4(1u);
          }
        }
        else if ( *(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~") )
        {
          while ( 1 )
          {
            v5 = *(_DWORD *)(v0 + 20);
            if ( !v5 || !*(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", *(unsigned __int8 *)(v1 + v5 - 1)) )
              break;
            sub_5ACE4(1u);
          }
        }
        return;
      }
    }
  }
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B1C8) --------------------------------------------------------
_BYTE *sub_5B1C8()
{
  int v0; // r4
  int v1; // r5
  _BYTE *result; // r0
  int v3; // r3

  v0 = dword_7DBC4;
  v1 = *(_DWORD *)(dword_7DBC4 + 32);
  while ( 1 )
  {
    result = (_BYTE *)sub_5ACE4(1u);
    v3 = *(_DWORD *)(v0 + 20);
    if ( !v3 )
      break;
    if ( *(_BYTE *)(v1 + v3) != 32 )
    {
      result = (_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
      if ( !*result )
      {
        do
        {
          if ( *(_BYTE *)(v1 + *(_DWORD *)(v0 + 20) - 1) == 32 )
            break;
          result = (_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
          if ( *result )
            break;
          result = (_BYTE *)sub_5ACE4(1u);
        }
        while ( *(_DWORD *)(v0 + 20) );
        return result;
      }
    }
  }
  return result;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B25C) --------------------------------------------------------
unsigned int __fastcall sub_5B25C(int a1)
{
  _DWORD *v1; // r4
  int v2; // r0
  unsigned int v3; // r1
  unsigned int result; // r0
  int v5; // r1

  v1 = (_DWORD *)dword_7DBC4;
  if ( a1 )
    v2 = *(_DWORD *)(dword_7DBC4 + 36);
  else
    v2 = *(_DWORD *)(dword_7DBC4 + 40);
  fputs_unlocked(v2, stdout);
  v3 = v1[1];
  v1[5] = 0;
  result = sub_15EFC(v1[4], v3);
  v1[3] = result;
  v1[2] = v5;
  return result;
}
// 5B29C: variable 'v5' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B2AC) --------------------------------------------------------
unsigned int __fastcall sub_5B2AC(unsigned __int8 *a1)
{
  char *v1; // r4
  int v2; // r7
  int v3; // r10
  void *v4; // r6
  unsigned __int8 *v5; // r11
  int v6; // r4
  unsigned __int8 *v7; // r0
  unsigned __int8 *v9; // r5
  unsigned int v10; // r8
  char *v11; // r5
  char *v12; // r0
  size_t v13; // r0
  int v14; // r2
  char *v15; // r0
  char *v16; // r3
  unsigned __int8 *v17; // r0
  _BYTE *v18; // r1
  unsigned __int8 *v19; // r0
  int v20; // r3
  bool v21; // zf
  char *v22; // r0
  char *v23; // r8
  int v24; // r5
  unsigned __int8 v25; // r0
  int v26; // [sp+0h] [bp-24h]
  int v27; // [sp+0h] [bp-24h]
  unsigned __int8 *v28; // [sp+4h] [bp-20h] BYREF
  _BYTE v29[4]; // [sp+Ch] [bp-18h] BYREF
  char *s; // [sp+10h] [bp-14h] BYREF
  char nptr[16]; // [sp+14h] [bp-10h] BYREF

  v1 = 0;
  v2 = 91;
  v3 = 0;
  v28 = a1;
  v4 = sub_174DC(1u);
  v29[1] = 0;
  while ( 1 )
  {
    v5 = v28;
    if ( !*v28 )
      break;
    v9 = v28 + 1;
    s = v29;
    ++v28;
    v10 = *v5;
    if ( v10 != 92 )
      goto LABEL_18;
    v10 = v5[1];
    if ( v10 != 116 )
      v10 = sub_5E668(&v28);
    v26 = dword_7DBC4;
    if ( v9 != v28 )
      goto LABEL_18;
    if ( !v5[1] )
      break;
    v28 = v5 + 2;
    v10 = v5[1];
    if ( v10 == 88 )
      goto LABEL_63;
    if ( v10 > 0x58 )
    {
      if ( v10 == 116 )
        goto LABEL_48;
      if ( v10 > 0x74 )
      {
        if ( v10 != 119 )
        {
          if ( v10 == 120 )
          {
LABEL_63:
            v23 = nptr;
            v24 = 0;
            while ( 1 )
            {
              v27 = v24 + 1;
              *v23 = *v28;
              *++v23 = 0;
              if ( strtoul(nptr, &s, 16) > 0xFF || s - nptr < v27 )
                break;
              ++v24;
              ++v28;
              if ( v27 == 3 )
                goto LABEL_67;
            }
            nptr[v24] = 0;
LABEL_67:
            v25 = strtoul(nptr, 0, 16);
            v10 = v25;
            v16 = v29;
            if ( !v25 )
              v10 = 63;
LABEL_44:
            s = v16;
          }
          else if ( v10 == 117 )
          {
            v16 = *(char **)(dword_7DBC4 + 44);
            if ( !v16 )
              v16 = "";
            goto LABEL_44;
          }
LABEL_18:
          v11 = 0;
          goto LABEL_24;
        }
        goto LABEL_49;
      }
      if ( v10 != 93 )
      {
        if ( v10 == 104 )
          goto LABEL_22;
        if ( v10 != 91 )
          goto LABEL_18;
      }
      if ( v2 != v10 )
        goto LABEL_18;
      v2 ^= 6u;
    }
    else
    {
      if ( v10 <= 0x41 )
      {
        if ( v10 < 0x40 )
        {
          if ( v10 == 36 && !geteuid() )
            v10 = 35;
          goto LABEL_18;
        }
LABEL_48:
        v11 = 0;
        *(sub_18768(nptr, 9u, 0) - 3) = 0;
        s = nptr;
        goto LABEL_24;
      }
      if ( v10 == 84 )
        goto LABEL_48;
      if ( v10 != 87 )
      {
        if ( v10 != 72 )
          goto LABEL_18;
LABEL_22:
        v12 = (char *)sub_60AA0();
        v11 = v12;
        s = v12;
        if ( v10 == 104 )
          *(_BYTE *)strchrnul(v12, 46) = 0;
        goto LABEL_24;
      }
LABEL_49:
      if ( !v1 )
      {
        v17 = (unsigned __int8 *)sub_624A4(0);
        v1 = (char *)v17;
        if ( v17 )
        {
          v18 = *(_BYTE **)(v26 + 48);
          if ( *v18 )
          {
            v19 = sub_1684C(v17, (int)v18);
            if ( v19 )
            {
              v20 = *v19;
              v21 = v20 == 0;
              if ( *v19 )
                v21 = v20 == 47;
              if ( v21 )
              {
                *v1 = 126;
                sub_60B4C((int)(v1 + 1), (int)v19);
              }
            }
          }
        }
        else
        {
          v1 = "(unknown)";
        }
      }
      s = v1;
      if ( v10 == 119 )
        goto LABEL_18;
      v22 = strrchr(v1, 47);
      v11 = v22;
      if ( v22 )
      {
        s = v22 + 1;
        goto LABEL_18;
      }
LABEL_24:
      v29[0] = v10;
      v13 = strlen(s);
      if ( v10 == 10 )
        v14 = 0;
      v3 += v13;
      if ( v10 == 10 )
      {
        *(_DWORD *)(dword_7DBC4 + 16) = v14;
      }
      else if ( v2 != 93 )
      {
        *(_DWORD *)(dword_7DBC4 + 16) += v13;
      }
      v15 = (char *)sub_174B4(v4, v3 + 1);
      v4 = strcat(v15, s);
      free(v11);
    }
  }
  if ( v1 != "(unknown)" )
    free(v1);
  v6 = dword_7DBC4;
  *(_DWORD *)(dword_7DBC4 + 40) = v4;
  *(_DWORD *)(v6 + 36) = v4;
  v7 = (unsigned __int8 *)strrchr((const char *)v4, 10);
  v28 = v7;
  if ( v7 )
    *(_DWORD *)(v6 + 40) = v7 + 1;
  return sub_5B25C(1);
}
// 5B418: variable 'v14' is possibly undefined
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B628) --------------------------------------------------------
int sub_5B628()
{
  _DWORD *v0; // r4
  int v1; // r3
  int v2; // r0
  int v3; // r2
  bool v4; // zf
  int v5; // r5
  int result; // r0

  v0 = (_DWORD *)dword_7DBC4;
  v1 = *(_DWORD *)(dword_7DBC4 + 20);
  v2 = *(unsigned __int8 *)(*(_DWORD *)(dword_7DBC4 + 32) + v1);
  v3 = *(_DWORD *)(dword_7DBC4 + 8);
  v4 = v2 == 0;
  if ( *(_BYTE *)(*(_DWORD *)(dword_7DBC4 + 32) + v1) )
    ++v1;
  else
    v2 = 32;
  if ( !v4 )
  {
    *(_DWORD *)(dword_7DBC4 + 20) = v1;
    v0[2] = v3 + 1;
  }
  v5 = v0[2] - v0[1];
  result = j_putchar_unlocked(v2);
  if ( v5 >= 0 )
  {
    result = puts("\r");
    ++v0[3];
    v0[2] = 0;
  }
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B698) --------------------------------------------------------
int sub_5B698()
{
  int result; // r0

  if ( *(_DWORD *)(dword_7DBC4 + 20) < *(_DWORD *)(dword_7DBC4 + 24) )
    return sub_5B628();
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B6B4) --------------------------------------------------------
int __fastcall sub_5B6B4(int a1)
{
  int v2; // r4
  int v3; // r5
  int result; // r0
  unsigned int v5; // r3
  unsigned int v6; // r3
  unsigned int v7; // r3
  unsigned int v8; // r3
  bool v9; // cc

  v2 = dword_7DBC4;
  v3 = *(_DWORD *)(dword_7DBC4 + 32);
  result = sub_5A944(*(unsigned __int8 *)(v3 + *(_DWORD *)(dword_7DBC4 + 20)));
  if ( result )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v2 + 20);
      if ( v6 >= *(_DWORD *)(v2 + 24) )
        break;
      result = sub_5A944(*(unsigned __int8 *)(v3 + v6 + 1));
      if ( !result )
        break;
      result = sub_5B698();
    }
  }
  else
  {
    result = strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
    if ( *(_BYTE *)result )
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(v2 + 20);
        if ( v5 >= *(_DWORD *)(v2 + 24) )
          break;
        result = strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", *(unsigned __int8 *)(v3 + v5 + 1));
        if ( !*(_BYTE *)result )
          break;
        result = sub_5B698();
      }
    }
  }
  if ( *(_DWORD *)(v2 + 20) < *(_DWORD *)(v2 + 24) )
    result = sub_5B698();
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(v2 + 20);
      if ( v7 >= *(_DWORD *)(v2 + 24) )
        break;
      v8 = *(unsigned __int8 *)(v3 + v7);
      v9 = v8 > 0x20;
      if ( v8 != 32 )
        v9 = v8 - 9 > 4;
      if ( v9 )
        break;
      result = sub_5B698();
    }
  }
  return result;
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B7A4) --------------------------------------------------------
int __fastcall sub_5B7A4(int result)
{
  int v1; // r6
  int v2; // r4
  int v3; // r5
  unsigned int v4; // r3
  unsigned int v5; // r3
  bool v6; // cc
  unsigned int v7; // r3
  unsigned int v8; // r3
  bool v9; // cc

  v1 = result;
  v2 = dword_7DBC4;
  v3 = *(_DWORD *)(dword_7DBC4 + 32);
  while ( 1 )
  {
    v4 = *(_DWORD *)(v2 + 20);
    if ( v4 >= *(_DWORD *)(v2 + 24) )
      break;
    v5 = *(unsigned __int8 *)(v3 + v4);
    v6 = v5 > 0x20;
    if ( v5 != 32 )
      v6 = v5 - 9 > 4;
    if ( !v6 )
      break;
    result = sub_5B698();
  }
  if ( v1 )
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(v2 + 20);
      if ( v7 >= *(_DWORD *)(v2 + 24) )
        break;
      v8 = *(unsigned __int8 *)(v3 + v7);
      v9 = v8 > 0x20;
      if ( v8 != 32 )
        v9 = v8 - 9 > 4;
      if ( v9 )
        break;
      result = sub_5B698();
    }
  }
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B81C) --------------------------------------------------------
void sub_5B81C()
{
  int v0; // r4
  int v1; // r5
  __int64 v2; // r2
  unsigned int v3; // r1
  bool v4; // cc
  unsigned int v5; // r3
  unsigned int v6; // r3

  v0 = dword_7DBC4;
  v1 = *(_DWORD *)(dword_7DBC4 + 32);
  if ( *(_DWORD *)(dword_7DBC4 + 20) < (unsigned int)(*(_DWORD *)(dword_7DBC4 + 24) - 1) )
  {
    while ( 1 )
    {
      sub_5B698();
      v2 = *(_QWORD *)(v0 + 20);
      if ( (unsigned int)v2 >= HIDWORD(v2) - 1 )
        break;
      v3 = *(unsigned __int8 *)(v1 + v2);
      v4 = v3 > 0x20;
      if ( v3 != 32 )
        v4 = v3 - 9 > 4;
      if ( v4 )
      {
        if ( sub_5A944(*(unsigned __int8 *)(v1 + v2)) )
        {
          while ( 1 )
          {
            v6 = *(_DWORD *)(v0 + 20);
            if ( v6 >= *(_DWORD *)(v0 + 24) - 1 || !sub_5A944(*(unsigned __int8 *)(v1 + v6 + 1)) )
              break;
            sub_5B698();
          }
        }
        else if ( *(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~") )
        {
          while ( 1 )
          {
            v5 = *(_DWORD *)(v0 + 20);
            if ( v5 >= *(_DWORD *)(v0 + 24) - 1
              || !*(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", *(unsigned __int8 *)(v1 + v5 + 1)) )
            {
              break;
            }
            sub_5B698();
          }
        }
        return;
      }
    }
  }
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B900) --------------------------------------------------------
int sub_5B900()
{
  int v0; // r4
  int v1; // r5
  int result; // r0
  unsigned int v3; // r3
  unsigned int v4; // r3
  bool v5; // cc
  unsigned int v6; // r3
  unsigned int v7; // r3
  bool v8; // cc

  v0 = dword_7DBC4;
  v1 = *(_DWORD *)(dword_7DBC4 + 32);
  do
  {
    result = sub_5B698();
    v3 = *(_DWORD *)(v0 + 20);
    if ( v3 >= *(_DWORD *)(v0 + 24) )
      break;
    v4 = *(unsigned __int8 *)(v1 + v3);
    v5 = v4 > 0x20;
    if ( v4 != 32 )
      v5 = v4 - 9 > 4;
  }
  while ( !v5 );
  while ( 1 )
  {
    v6 = *(_DWORD *)(v0 + 20);
    if ( v6 >= *(_DWORD *)(v0 + 24) - 1 )
      break;
    v7 = *(unsigned __int8 *)(v1 + v6 + 1);
    v8 = v7 > 0x20;
    if ( v7 != 32 )
      v8 = v7 - 9 > 4;
    if ( !v8 )
      break;
    result = sub_5B698();
  }
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B970) --------------------------------------------------------
void sub_5B970()
{
  int v0; // r4
  int v1; // r5
  int v2; // r3

  v0 = dword_7DBC4;
  v1 = *(_DWORD *)(dword_7DBC4 + 32);
  while ( 1 )
  {
    v2 = *(_DWORD *)(v0 + 20);
    if ( !*(_BYTE *)(v1 + v2) )
      break;
    if ( *(_BYTE *)(v1 + v2) != 32 && !*(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~") )
    {
      do
        sub_5B698();
      while ( (*(_BYTE *)(v1 + *(_DWORD *)(v0 + 20)) & 0xDF) != 0
           && !*(_BYTE *)strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~") );
      return;
    }
    sub_5B698();
  }
}
// 13624: using guessed type int strchrnul(const char *, ...);
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005B9F0) --------------------------------------------------------
int sub_5B9F0()
{
  int v0; // r4
  int result; // r0

  v0 = dword_7DBC4;
  while ( *(_DWORD *)(v0 + 20) < *(_DWORD *)(v0 + 24) )
    result = sub_5B628();
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BA14) --------------------------------------------------------
int sub_5BA14()
{
  int result; // r0

  result = sub_5B9F0();
  if ( !*(_DWORD *)(dword_7DBC4 + 20) || *(_DWORD *)(dword_7DBC4 + 8) )
    return j_putchar_unlocked(10);
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BA4C) --------------------------------------------------------
unsigned int __fastcall sub_5BA4C(int a1, unsigned int a2, int a3)
{
  if ( a1 > 0 )
    printf("\x1B[%uA", a1);
  j_putchar_unlocked(13);
  sub_5B25C(a3);
  sub_5B9F0();
  printf("\x1B[J");
  return sub_5ACE4(a2);
}

//----- (0005BA98) --------------------------------------------------------
unsigned int __fastcall sub_5BA98(int a1, int a2, int a3)
{
  unsigned int v3; // r0
  _DWORD *v4; // r4
  int v5; // r3
  unsigned int v6; // r5
  unsigned int v7; // r0

  v3 = sub_17280(0, a2, a3);
  v4 = (_DWORD *)dword_7DBC4;
  v5 = *(_DWORD *)(dword_7DBC4 + 20);
  *(_DWORD *)(dword_7DBC4 + 4) = v3;
  v6 = v4[6] - v5;
  v7 = sub_15CA0(v5 + v4[4], v3);
  if ( v7 < v4[3] )
    v7 = v4[3];
  return sub_5BA4C(v7, v6, 0);
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BAEC) --------------------------------------------------------
int __fastcall sub_5BAEC(int result, int a2)
{
  int v2; // r2
  _DWORD *v3; // r4
  int v4; // r5

  v2 = *(_DWORD *)(dword_7DBC4 + 68);
  if ( v2 )
  {
    v3 = (_DWORD *)dword_7DB94;
    v4 = *(_DWORD *)dword_7DB94;
    sub_5BA98(result, a2, v2);
    result = sub_177D8();
    *v3 = v4;
  }
  else
  {
    ++*(_DWORD *)(dword_7DBC4 + 64);
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BB38) --------------------------------------------------------
unsigned int __fastcall sub_5BB38(unsigned int result)
{
  _DWORD *v1; // r4
  int v2; // r5
  int v3; // r3
  int v4; // r1
  _BYTE *v5; // r2

  v1 = (_DWORD *)dword_7DBC4;
  v2 = *(_DWORD *)(dword_7DBC4 + 20);
  if ( *(_DWORD *)(dword_7DBC4 + 24) != v2 )
  {
    if ( result )
    {
      v3 = dword_7DBC4 + 80;
      v4 = *(_DWORD *)(dword_7DBC4 + 32);
      if ( *(_DWORD *)(dword_7DBC4 + 72) )
      {
        *(_DWORD *)(dword_7DBC4 + 76) = v3;
        v1[18] = 0;
      }
      v5 = (_BYTE *)v1[19];
      if ( (int)&v5[-v3] <= 127 )
      {
        v1[19] = v5 + 1;
        *v5 = *(_BYTE *)(v4 + v2);
      }
    }
    memmove((void *)(v1[8] + v2), (const void *)(v1[8] + v2 + 1), v1[6] - v2);
    --v1[6];
    sub_5B9F0();
    printf("\x1B[J");
    return sub_5ACE4(v1[5] - v2);
  }
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BBE0) --------------------------------------------------------
unsigned int sub_5BBE0()
{
  unsigned int result; // r0

  if ( *(_DWORD *)(dword_7DBC4 + 20) )
  {
    sub_5ACE4(1u);
    return sub_5BB38(0);
  }
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BC10) --------------------------------------------------------
size_t __fastcall sub_5BC10(const char *a1)
{
  int v1; // r4

  v1 = dword_7DBC4;
  sub_60B34(*(char **)(dword_7DBC4 + 32), a1, *(_DWORD *)(dword_7DBC4 + 28));
  return strlen(*(const char **)(v1 + 32));
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BC3C) --------------------------------------------------------
_BYTE *__fastcall sub_5BC3C(const char *a1)
{
  const char *v1; // r5
  int v2; // r4
  size_t v3; // r0
  _BYTE *i; // r6
  int v5; // r7
  int v6; // t1

  v1 = a1 - 1;
  v2 = 0;
  v3 = strlen(a1);
  for ( i = sub_174DC(2 * (v3 + 1)); ; i[v2++] = v5 )
  {
    v6 = *(unsigned __int8 *)++v1;
    v5 = v6;
    if ( !v6 )
      break;
    if ( strchr(" `\"#$%^&*()=+{}[]:;'|\\<>", v5) )
      i[v2++] = 92;
  }
  return i;
}

//----- (0005BCA8) --------------------------------------------------------
size_t __fastcall sub_5BCA8(const char *a1, int a2)
{
  char *v3; // r7
  char *v4; // r0
  void **v5; // r5
  char *v6; // r4
  int v7; // r9
  const char **v8; // r8
  const char *v9; // t1
  DIR *v10; // r11
  char *v12; // r4
  const char *v13; // r0
  int i; // r5
  char *v15; // r0
  char *v16; // r3
  int v17; // r6
  char *v18; // r0
  char *v19; // r0
  char *v20; // r6
  char *v21; // r0
  char *v22; // r9
  char *v23; // r6
  char *v24; // r2
  int v25; // r3
  int v26; // t1
  int v27; // r9
  char *v28; // r0
  int v29; // r3
  unsigned __int8 *v30; // r0
  const char **v31; // [sp+4h] [bp-80h]
  size_t v32; // [sp+8h] [bp-7Ch]
  size_t v33; // [sp+Ch] [bp-78h]
  char *v34; // [sp+14h] [bp-70h] BYREF
  int v35; // [sp+28h] [bp-5Ch]

  v3 = (char *)a1;
  v34 = ".";
  v4 = strrchr(a1, 47);
  if ( v4 )
  {
    v20 = v4 + 1;
    v21 = (char *)sub_1751C(v3, v4 + 1 - v3);
    v3 = v20;
    v6 = v21;
    v34 = v21;
    v5 = (void **)&v34;
  }
  else
  {
    if ( !a2 )
    {
      v12 = (**(_DWORD **)dword_7DBC4 & 0x10) != 0 ? *(char **)(*(_DWORD *)dword_7DBC4 + 8) : getenv("PATH");
      if ( v12 && *v12 && (*v12 != 58 || v12[1]) )
      {
        v13 = v12;
        for ( i = 1; ; ++i )
        {
          v15 = strchr(v13, 58);
          v16 = v15;
          if ( !v15 )
            break;
          v13 = v15 + 1;
          if ( !v16[1] )
            break;
        }
        v17 = 1;
        v5 = (void **)sub_1748C(4 * i);
        v18 = sub_174F8(v12);
        *v5 = v18;
        while ( 1 )
        {
          v7 = v17;
          v19 = strchr(v18, 58);
          v6 = v19;
          if ( !v19 )
            break;
          v18 = v19 + 1;
          *v6 = 0;
          v6 = (char *)(unsigned __int8)v6[1];
          if ( !v6 )
            break;
          v5[v17++] = v18;
        }
        goto LABEL_5;
      }
    }
    v5 = (void **)&v34;
    v6 = 0;
  }
  v7 = 1;
LABEL_5:
  v8 = (const char **)v5;
  v32 = strlen(v3);
  v31 = (const char **)&v5[v7];
  do
  {
    v9 = *v8++;
    v10 = opendir(v9);
    if ( !v10 )
      continue;
    while ( 1 )
    {
      v30 = (unsigned __int8 *)readdir64(v10);
      if ( !v30 )
        break;
      v22 = (char *)(v30 + 19);
      if ( (*v3 || v30[19] != 46 || v30[20] && (v30[20] != 46 || v30[21])) && sub_1684C(v30 + 19, (int)v3) )
      {
        v23 = sub_16998(*(v8 - 1), v22);
        if ( sub_62DFC() && sub_62E14() )
        {
LABEL_38:
          free(v23);
        }
        else
        {
          v33 = strlen(v22);
          v23 = (char *)sub_174B4(v23, v33 + 2);
          strcpy(v23, v22);
          if ( (v35 & 0xF000) == 0x4000 )
          {
            v23[v33] = 47;
            v23[v33 + 1] = 0;
          }
          else if ( a2 == 1 )
          {
            goto LABEL_38;
          }
          v24 = v23 - 1;
          while ( 1 )
          {
            v26 = (unsigned __int8)*++v24;
            v25 = v26;
            if ( !v26 )
              break;
            if ( (unsigned int)(v25 - 32) > 0x5E )
              goto LABEL_38;
          }
          v27 = dword_7DBC4;
          v28 = sub_62544(*(void **)(dword_7DBC4 + 52), 0x404u, *(_DWORD *)(dword_7DBC4 + 56));
          v29 = *(_DWORD *)(v27 + 56);
          *(_DWORD *)(v27 + 52) = v28;
          *(_DWORD *)&v28[4 * v29] = v23;
          *(_DWORD *)(v27 + 56) = v29 + 1;
        }
      }
    }
    closedir(v10);
  }
  while ( v8 != v31 );
  if ( v5 != (void **)&v34 )
  {
    free(*v5);
    free(v5);
  }
  free(v6);
  return v32;
}
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BF98) --------------------------------------------------------
int __fastcall sub_5BF98(char *a1, int a2)
{
  int v4; // r4
  int result; // r0

  sub_177D8();
  v4 = dword_7DBC4;
  *(_DWORD *)(dword_7DBC4 + 68) = 1;
  result = sub_60068(0, a1, a2);
  *(_DWORD *)(v4 + 68) = 0;
  return result;
}
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005BFD8) --------------------------------------------------------
void __fastcall sub_5BFD8(_DWORD *a1)
{
  size_t v1; // r8
  int v2; // r4
  signed int v4; // r5
  int v5; // r6
  int v6; // r7
  int v7; // r0
  int v8; // r8
  int v9; // r5
  int v10; // r0
  int v11; // r1
  int m; // r6
  int v13; // r11
  int v14; // r10
  int n; // r9
  const char *v16; // r0
  signed int v17; // r0
  size_t v18; // r0
  const char *v19; // r1
  char *v20; // r7
  int v21; // r6
  char *v22; // r9
  unsigned __int8 *i; // r6
  __int64 v24; // r0
  int v25; // r11
  unsigned int v26; // r6
  int v27; // r9
  void *v28; // r10
  char *v29; // r5
  char *v30; // r0
  char *j; // r3
  unsigned int k; // r2
  int v33; // t1
  const char *v35; // r9
  size_t v36; // r6
  size_t v37; // r0
  int v38; // r3
  const char **v39; // r3
  size_t v40; // r0
  int v41; // [sp+0h] [bp-14h]
  int v42; // [sp+4h] [bp-10h]
  const char *v43; // [sp+Ch] [bp-8h]

  v2 = dword_7DBC4;
  if ( (**(_DWORD **)dword_7DBC4 & 2) == 0 )
    return;
  if ( !*a1 )
  {
    *a1 = 1;
    v20 = (char *)sub_1748C(0x800u);
    sub_60B34(v20, *(const char **)(v2 + 32), *(_DWORD *)(v2 + 20) + 1);
    v21 = sub_5A9A4((int)v20);
    sub_5AF1C();
    if ( !*(_DWORD *)(v2 + 52) )
      v1 = sub_5BCA8(v20, v21);
    v22 = &v20[strlen(v20)];
    for ( i = (unsigned __int8 *)&v22[-v1]; i < (unsigned __int8 *)v22; ++i )
    {
      v33 = *i;
      if ( strchr(" `\"#$%^&*()=+{}[]:;'|\\<>", v33) )
        ++v1;
    }
    v24 = *(_QWORD *)(v2 + 52);
    if ( (_DWORD)v24 )
    {
      v25 = 0;
      v26 = 0;
      sub_62614((void *)v24, HIDWORD(v24));
      while ( 1 )
      {
        v27 = *(_DWORD *)(v2 + 52);
        v28 = *(void **)(v27 + 4 * v26);
        if ( *(_DWORD *)(v2 + 56) - 1 <= v26 )
          break;
        if ( strcmp((const char *)v28, *(const char **)(v27 + 4 * v26++ + 4)) )
          *(_DWORD *)(v27 + 4 * v25++) = v28;
        else
          free(v28);
      }
      *(_DWORD *)(v27 + 4 * v25) = v28;
      *(_DWORD *)(v2 + 56) = v25 + 1;
    }
    if ( *(_DWORD *)(v2 + 56) == 1 )
    {
      v39 = *(const char ***)(v2 + 52);
      *a1 = 0;
      v29 = sub_5BC3C(*v39);
      v40 = strlen(v29);
      v36 = v40;
      if ( v29[v40 - 1] != 47 )
      {
        v36 = v40 + 1;
        v29[v40] = 32;
        v29[v40 + 1] = 0;
      }
    }
    else
    {
      sub_5ACDC();
      v29 = *(char **)(v2 + 52);
      if ( !v29 )
        goto LABEL_48;
      v30 = sub_174F8(*(const char **)v29);
      v29 = v30;
      for ( j = v30; *j; ++j )
      {
        for ( k = 1; *(_DWORD *)(v2 + 56) > k; ++k )
        {
          if ( *(unsigned __int8 *)(*(_DWORD *)(*(_DWORD *)(v2 + 52) + 4 * k) + j - v30) != (unsigned __int8)*j )
            goto LABEL_44;
        }
      }
LABEL_44:
      if ( j == v30 )
        goto LABEL_48;
      *j = 0;
      v35 = sub_5BC3C(v30);
      free(v29);
      v29 = (char *)v35;
      v36 = strlen(v35);
    }
    if ( (signed int)(*(_DWORD *)(v2 + 24) - v1 + v36) < *(_DWORD *)(v2 + 28) )
    {
      strcpy(v20, (const char *)(*(_DWORD *)(v2 + 32) + *(_DWORD *)(v2 + 20)));
      sprintf((char *)(*(_DWORD *)(v2 + 32) + *(_DWORD *)(v2 + 20)), "%s%s", &v29[v1], v20);
      v37 = strlen(*(const char **)(v2 + 32));
      v38 = *(_DWORD *)(v2 + 20);
      *(_DWORD *)(v2 + 24) = v37;
      sub_5BA4C(*(_DWORD *)(v2 + 12), v37 - (v38 - v1 + v36), 0);
    }
LABEL_48:
    free(v29);
    free(v20);
    return;
  }
  if ( *(_DWORD *)(dword_7DBC4 + 56) )
  {
    v4 = 0;
    v5 = 0;
    v42 = *(_DWORD *)(dword_7DBC4 + 20);
    sub_5BA14();
    v6 = *(_DWORD *)(v2 + 56);
    while ( v6 > v5 )
    {
      v16 = *(const char **)(*(_DWORD *)(v2 + 52) + 4 * v5++);
      v17 = strlen(v16);
      if ( v4 < v17 )
        v4 = v17;
    }
    v41 = v4 + 2;
    v7 = sub_15CA0(*(_DWORD *)(v2 + 4), v4 + 2);
    v8 = v7;
    if ( v7 > 1 )
    {
      v10 = sub_161AC(v6, v7);
      v9 = v10;
      if ( v11 )
        v9 = v10 + 1;
    }
    else
    {
      v9 = v6;
      v8 = 1;
    }
    for ( m = 0; v9 > m; ++m )
    {
      v13 = 4 * m;
      v14 = m;
      for ( n = 1; ; ++n )
      {
        v19 = *(const char **)(*(_DWORD *)(v2 + 52) + v13);
        if ( n == v8 )
          break;
        v14 += v9;
        v13 += 4 * v9;
        if ( v6 <= v14 )
          break;
        v43 = v19;
        v18 = strlen(v19);
        printf("%s%-*s", v43, v41 - v18, "");
      }
      puts(v19);
    }
    sub_5BA4C(0, *(_DWORD *)(v2 + 24) - v42, 1);
  }
}
// 5C070: variable 'v11' is possibly undefined
// 5C18C: variable 'v1' is possibly undefined
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005C3B4) --------------------------------------------------------
_DWORD *__fastcall sub_5C3B4(int a1)
{
  _DWORD *result; // r0

  result = sub_174DC(0xFC0u);
  *result = a1;
  result[1] = -1;
  result[5] = 999;
  return result;
}

//----- (0005C3DC) --------------------------------------------------------
int __fastcall sub_5C3DC(int result)
{
  int v1; // r5
  const char **v2; // r6
  int i; // r4
  int v4; // r1
  const char *v5; // t1

  v1 = result;
  if ( result )
  {
    v2 = (const char **)(result + 32);
    for ( i = 0; *(_DWORD *)(v1 + 12) > i; ++i )
    {
      v4 = i;
      v5 = *v2++;
      result = printf("%4d %s\n", v4, v5);
    }
  }
  return result;
}

//----- (0005C41C) --------------------------------------------------------
size_t __fastcall sub_5C41C(int a1, unsigned __int8 *a2, char *a3, int a4)
{
  _DWORD *v8; // r4
  size_t v9; // r4
  int v11; // r3
  int v12; // r3
  _DWORD *v13; // r0
  __uid_t v14; // r0
  struct passwd *v15; // r0
  int v16; // r1
  int v17; // r2
  struct passwd *v18; // r7
  int v19; // r5
  int i; // r0
  int v21; // r1
  int v22; // r3
  int v23; // r2
  int v24; // r7
  int v25; // r8
  bool v26; // zf
  int v27; // r7
  unsigned int v28; // r0
  bool v29; // zf
  int v30; // r8
  int v31; // r5
  int v32; // r3
  int v33; // r2
  int v34; // r3
  int v35; // r5
  _DWORD *v36; // r2
  int v37; // r9
  char *v38; // r0
  _DWORD *v39; // r3
  int v40; // r0
  int v41; // r0
  int v42; // r1
  int v43; // r9
  size_t v44; // r0
  size_t v45; // r8
  size_t v46; // r5
  ssize_t v47; // r10
  int *v48; // r3
  int v49; // r1
  unsigned int v50; // r2
  const char **v51; // r5
  const char *v52; // r3
  const char *v53; // r8
  __pid_t v54; // r0
  char *v55; // r8
  int v56; // r0
  const char **v57; // r10
  FILE *v58; // r9
  int v59; // r8
  int v60; // r9
  int v61; // r2
  const char *v62; // r0
  size_t v63; // r0
  _DWORD *v64; // r3
  int v65; // r2
  unsigned int v66; // r1
  int v67; // r0
  int v68; // r2
  unsigned int v69; // r3
  bool v70; // cc
  int v71; // r2
  unsigned int v72; // r3
  bool v73; // cc
  bool v74; // zf
  char *v75; // r0
  int v76; // r2
  size_t v77; // r8
  int v78; // r10
  int v79; // r3
  int v80; // r0
  unsigned int v81; // r0
  int v82; // r10
  unsigned int v83; // r8
  unsigned int v84; // r8
  char *v85; // r0
  size_t v86; // r0
  int v87; // r1
  int v88; // r3
  size_t v89; // r8
  int v90; // r0
  int v91; // r3
  int v92; // r10
  int v93; // r2
  char *v94; // r3
  const char *v95; // r7
  const char *v96; // t1
  char *v97; // r1
  void *v98; // r0
  int v99; // r1
  int v100; // r0
  unsigned int v101; // r8
  unsigned int v102; // r10
  int v103; // r3
  int v104; // r10
  int v105; // r0
  const char *v106; // t1
  void *v107; // t1
  int v108; // [sp+8h] [bp-14Ch]
  int v109; // [sp+Ch] [bp-148h]
  const char *j; // [sp+10h] [bp-144h]
  char *v111; // [sp+10h] [bp-144h]
  void *src; // [sp+14h] [bp-140h]
  int v113; // [sp+18h] [bp-13Ch]
  int v114; // [sp+20h] [bp-134h]
  int v115; // [sp+24h] [bp-130h]
  int v116; // [sp+28h] [bp-12Ch]
  int v117; // [sp+2Ch] [bp-128h]
  int v118; // [sp+34h] [bp-120h] BYREF
  char v119[16]; // [sp+38h] [bp-11Ch] BYREF
  char v120[16]; // [sp+48h] [bp-10Ch] BYREF
  struct termios s; // [sp+58h] [bp-FCh] BYREF
  struct termios termios_p; // [sp+94h] [bp-C0h] BYREF
  char v123[132]; // [sp+D0h] [bp-84h] BYREF

  v118 = 0;
  v8 = sub_174DC(0x15Cu);
  dword_7DBC4 = (int)v8;
  v8[1] = 80;
  v8[12] = &unk_6BC3E;
  v8[19] = v8 + 20;
  src = v8 + 20;
  v109 = sub_172AC(0, (int)&termios_p, &s, 1);
  if ( v109 || (s.c_lflag & 0xA) == 2 )
  {
    sub_5B2AC(a2);
    sub_177D8();
    if ( fgets_unlocked(a3, a4, stdin) )
      v9 = strlen(a3);
    else
      v9 = -1;
    goto LABEL_6;
  }
  if ( a4 >= 1024 )
    v11 = 1024;
  else
    v11 = a4;
  v113 = v11;
  v8[7] = v11;
  *v8 = &unk_632C8;
  if ( a1 )
  {
    v12 = *(_DWORD *)(a1 + 4);
    *v8 = a1;
  }
  else
  {
    v12 = -1;
  }
  v13 = (_DWORD *)*v8;
  v108 = v12;
  if ( *(_DWORD *)(*v8 + 28) && !v13[3] )
    sub_5AFAC(v13);
  if ( (*(_DWORD *)*v8 & 1) != 0 )
    *(_DWORD *)(*v8 + 16) = *(_DWORD *)(*v8 + 12);
  v8[3] = 0;
  v8[6] = 0;
  v8[8] = a3;
  *a3 = 0;
  sub_1729C(&termios_p);
  v14 = geteuid();
  v15 = getpwuid(v14);
  v18 = v15;
  if ( v15 )
  {
    v8[11] = sub_174F8(v15->pw_name);
    v8[12] = sub_174F8(v18->pw_dir);
  }
  v8[1] = sub_17280(0, v16, v17);
  sub_5B2AC(a2);
  v19 = 0;
  v8[52] = sub_5BAEC;
  v8[85] = 0x10000000;
  i = sigaction(28, (const struct sigaction *)(v8 + 52), (struct sigaction *)(v8 + 52));
  v119[0] = 0;
  while ( 1 )
  {
    v22 = v8[16];
    v23 = v8[15];
    if ( v23 != v22 )
    {
      v8[15] = v22;
      sub_5BA98(i, v21, v23);
    }
    i = sub_5BF98(v119, v108);
    v24 = i;
LABEL_24:
    if ( v19 )
      v25 = v24 | 0x40000000;
    else
      v25 = v24;
    v8[18] = 1;
    if ( v25 == 1073741834 )
    {
LABEL_65:
      v27 = 1;
      sub_5BA14();
      goto LABEL_66;
    }
    if ( v25 <= 1073741834 )
    {
      if ( v25 == 2 )
        goto LABEL_122;
      if ( v25 <= 2 )
      {
        if ( v25 == -7 )
          goto LABEL_62;
        if ( v25 <= -7 )
        {
          if ( v25 == -44 )
          {
            v84 = v8[5];
            i = (int)sub_5B1C8();
            while ( v84 > v8[5] )
            {
              --v84;
              i = sub_5BB38(1u);
            }
            goto LABEL_186;
          }
          if ( v25 > -44 )
          {
            if ( v25 == -36 )
            {
LABEL_267:
              sub_5B970();
              goto LABEL_186;
            }
            if ( v25 == -9 )
              goto LABEL_273;
            v26 = v25 == -37;
          }
          else
          {
            if ( v25 == -68 )
              goto LABEL_267;
            if ( v25 == -45 )
            {
              v82 = v8[5];
              sub_5B970();
              v83 = v8[5] - v82;
              for ( i = sub_5ACE4(v83); (--v83 & 0x80000000) == 0; i = sub_5BB38(1u) )
                ;
              goto LABEL_186;
            }
            v26 = v25 == -69;
          }
          if ( v26 )
          {
            i = (int)sub_5B1C8();
            goto LABEL_186;
          }
          goto LABEL_39;
        }
        if ( v25 != -3 )
        {
          if ( v25 <= -3 )
          {
            if ( v25 != -5 )
            {
              if ( v25 > -5 )
                goto LABEL_171;
LABEL_49:
              v28 = v8[5];
LABEL_151:
              i = sub_5ACE4(v28);
              goto LABEL_186;
            }
LABEL_122:
            v28 = 1;
            goto LABEL_151;
          }
          if ( v25 == -1 )
            goto LABEL_272;
          if ( v25 >= -1 )
          {
            v29 = v25 == 1;
            goto LABEL_53;
          }
          if ( !sub_5AE74() )
            goto LABEL_177;
LABEL_99:
          v62 = *(const char **)(*v8 + 4 * (*(_DWORD *)(*v8 + 16) + 8));
          if ( !v62 )
            v62 = "";
          v63 = sub_5BC10(v62);
          v64 = (_DWORD *)*v8;
          v65 = 0;
          v8[6] = v63;
          v66 = *v64 & 8;
          if ( v66 )
            v66 = 9999;
LABEL_103:
          v67 = v8[3];
LABEL_133:
          i = sub_5BA4C(v67, v66, v65);
          goto LABEL_186;
        }
LABEL_97:
        i = sub_5AEC8();
LABEL_98:
        if ( i )
          goto LABEL_99;
        goto LABEL_186;
      }
      if ( v25 == 13 )
        goto LABEL_65;
      if ( v25 <= 13 )
      {
        if ( v25 == 9 )
        {
          sub_5BFD8(&v118);
          goto LABEL_186;
        }
        if ( v25 > 9 )
        {
          if ( v25 == 11 )
          {
            *(_BYTE *)(v8[8] + v8[5]) = 0;
            v8[6] = v8[5];
            i = printf("\x1B[J");
            goto LABEL_186;
          }
          if ( v25 <= 11 )
            goto LABEL_65;
LABEL_132:
          printf("\x1B[H\x1B[J");
          v65 = 1;
          v67 = 0;
          v66 = v8[6] - v8[5];
          goto LABEL_133;
        }
        if ( v25 == 6 )
          goto LABEL_171;
        if ( v25 == 8 )
          goto LABEL_185;
        if ( v25 != 5 )
          goto LABEL_39;
LABEL_62:
        i = sub_5B9F0();
        goto LABEL_186;
      }
      if ( v25 == 21 )
        goto LABEL_137;
      if ( v25 > 21 )
      {
        if ( v25 == 27 )
        {
          if ( (*(_DWORD *)*v8 & 8) != 0 )
          {
            v19 = 1;
            i = sub_5ACE4(1u);
          }
          goto LABEL_186;
        }
        if ( v25 <= 27 )
        {
          if ( v25 == 23 )
            goto LABEL_107;
          goto LABEL_39;
        }
        if ( v25 == 127 )
        {
LABEL_185:
          i = sub_5BBE0();
          goto LABEL_186;
        }
        v74 = v25 == 1073741832;
LABEL_120:
        if ( !v74 )
          goto LABEL_39;
        goto LABEL_122;
      }
      if ( v25 != 16 )
      {
        if ( v25 == 18 )
        {
          v120[0] = 0;
          v123[0] = 0;
          v114 = v8[10];
          v115 = v8[4];
          for ( j = 0; ; j = v95 )
          {
            v85 = sub_177E4("(reverse-i-search)'%s': ", v123);
            v8[10] = v85;
            v86 = strlen(v85);
            v87 = v8[6];
            v88 = v8[5];
            v8[4] = v86;
            sub_5BA4C(v8[3], v87 - v88, 0);
LABEL_200:
            v89 = strlen(v123);
            v90 = sub_5BF98(v120, v108);
            v24 = v90;
            if ( v90 != 18 )
            {
              if ( v90 == 127 || v90 == 8 )
              {
                if ( v89 )
                  --v89;
                v123[v89] = 0;
              }
              else
              {
                if ( (unsigned int)(v90 - 32) > 0xDF )
                {
                  if ( j )
                    v8[6] = sub_5BC10(j);
                  free((void *)v8[10]);
                  v99 = v8[6];
                  v100 = v8[3];
                  v8[10] = v114;
                  v8[4] = v115;
                  i = sub_5BA4C(v100, v99 - v8[5], 0);
                  goto LABEL_24;
                }
                if ( v89 <= 0x7E )
                {
                  v94 = &v123[v89 + 128];
                  *(v94 - 128) = v90;
                  *(v94 - 127) = 0;
                }
              }
            }
            v91 = *v8;
            v92 = *(_DWORD *)(*v8 + 16);
            if ( v90 == 18 )
              --v92;
            v93 = v91 + 4 * v92 + 36;
            while ( 1 )
            {
              if ( v92 < 0 )
              {
                v123[v89] = 0;
                sub_5ACDC();
                goto LABEL_200;
              }
              v96 = *(const char **)(v93 - 4);
              v93 -= 4;
              v95 = v96;
              if ( v96 )
              {
                v116 = v93;
                v117 = v91;
                v97 = strstr(v95, v123);
                v93 = v116;
                v91 = v117;
                if ( v97 )
                  break;
              }
              --v92;
            }
            *(_DWORD *)(v117 + 16) = v92;
            v111 = v97;
            v8[6] = sub_5BC10(v95);
            v98 = (void *)v8[10];
            v8[5] = v111 - v95;
            free(v98);
          }
        }
        if ( v25 != 14 )
          goto LABEL_39;
        goto LABEL_97;
      }
LABEL_191:
      i = sub_5AE74();
      goto LABEL_98;
    }
    if ( v25 == 1073741911 )
    {
      i = sub_5B7A4(1);
      goto LABEL_186;
    }
    if ( v25 > 1073741911 )
    {
      if ( v25 == 1073741929 )
        goto LABEL_223;
      if ( v25 <= 1073741929 )
      {
        if ( v25 == 1073741923 )
        {
          v19 = 0;
        }
        else
        {
          if ( v25 <= 1073741923 )
          {
            if ( v25 == 1073741921 )
            {
              i = sub_5B698();
              goto LABEL_223;
            }
            if ( v25 > 1073741921 )
            {
              sub_5B0F4();
              goto LABEL_186;
            }
            if ( v25 != 1073741912 )
              goto LABEL_39;
            if ( v8[5] )
            {
              sub_5ACE4(1u);
LABEL_180:
              v81 = 1;
LABEL_181:
              i = sub_5BB38(v81);
              goto LABEL_186;
            }
            goto LABEL_186;
          }
          if ( v25 == 1073741925 )
          {
            sub_5B81C();
            goto LABEL_186;
          }
          if ( v25 >= 1073741925 )
          {
            v79 = 1073741928;
            goto LABEL_165;
          }
        }
        i = sub_5BF98(v119, v108);
        if ( *(_DWORD *)dword_7DB94 )
          goto LABEL_272;
        if ( v24 == i )
        {
          i = sub_5ACE4(v8[5]);
LABEL_183:
          while ( v8[5] < v8[6] )
            i = sub_5BB38(1u);
          goto LABEL_186;
        }
        v101 = v8[5];
        if ( i == 69 )
          goto LABEL_235;
        if ( i > 69 )
        {
          if ( i == 98 )
          {
            sub_5B0F4();
LABEL_257:
            while ( v8[5] < v101 )
            {
              --v101;
              i = sub_5BB38(1u);
            }
            goto LABEL_186;
          }
          if ( i > 98 )
          {
            if ( i != 101 && i != 119 )
              goto LABEL_186;
LABEL_235:
            if ( i <= 87 )
            {
              sub_5B900();
              goto LABEL_255;
            }
            if ( i == 101 )
            {
              sub_5B81C();
LABEL_255:
              sub_5B698();
            }
            else
            {
              sub_5B6B4(v19);
            }
LABEL_237:
            v102 = v8[5];
            i = sub_5ACE4(v102 - v101);
            while ( v102 > v8[5] )
            {
              --v102;
              i = sub_5BB38(1u);
            }
            goto LABEL_186;
          }
          if ( i == 87 )
          {
            sub_5B7A4(v19);
            goto LABEL_237;
          }
        }
        else
        {
          switch ( i )
          {
            case '$':
              goto LABEL_183;
            case 'B':
              i = sub_5ADB8();
              goto LABEL_257;
            case ' ':
              goto LABEL_180;
          }
        }
        goto LABEL_186;
      }
      if ( v25 == 1073741936 )
      {
        i = sub_5B698();
        goto LABEL_149;
      }
      if ( v25 > 1073741936 )
      {
        if ( v25 == 1073741943 )
        {
          i = sub_5B6B4(1);
          goto LABEL_186;
        }
        if ( v25 <= 1073741943 )
        {
          if ( v25 == 1073741938 )
          {
            v80 = sub_5BF98(v119, v108);
            if ( *(_DWORD *)dword_7DB94 )
              goto LABEL_272;
            if ( (unsigned int)(v80 - 32) <= 0xDF )
            {
              *(_BYTE *)(v8[8] + v8[5]) = v80;
              j_putchar_unlocked(v80);
              i = j_putchar_unlocked(8);
              goto LABEL_186;
            }
LABEL_177:
            i = sub_5ACDC();
            goto LABEL_186;
          }
          goto LABEL_39;
        }
        if ( v25 == 1073741944 )
          goto LABEL_180;
        v79 = 1073741951;
LABEL_165:
        v74 = v25 == v79;
        goto LABEL_120;
      }
      if ( v25 != 1073741931 )
      {
        if ( v25 >= 1073741931 )
        {
          if ( v25 == 1073741932 )
          {
LABEL_171:
            i = sub_5B698();
            goto LABEL_186;
          }
          goto LABEL_39;
        }
        goto LABEL_97;
      }
      goto LABEL_191;
    }
    if ( v25 == 1073741860 )
      goto LABEL_62;
    if ( v25 > 1073741860 )
      break;
    if ( v25 == 1073741840 )
      goto LABEL_191;
    if ( v25 <= 1073741840 )
    {
      if ( v25 == 1073741837 )
        goto LABEL_65;
      if ( v25 != 1073741838 )
      {
        if ( v25 != 1073741836 )
          goto LABEL_39;
        goto LABEL_132;
      }
      goto LABEL_97;
    }
    if ( v25 != 1073741847 )
    {
      if ( v25 == 1073741856 )
        goto LABEL_171;
      if ( v25 != 1073741845 )
        goto LABEL_39;
LABEL_137:
      v21 = v8[5];
      if ( !v21 )
        goto LABEL_186;
      v75 = (char *)v8[8];
      v76 = v8[6] - v21;
      v8[6] = v76;
      memmove(v75, &v75[v21], v76 + 1);
      v65 = 0;
      v66 = v8[6];
      goto LABEL_103;
    }
LABEL_107:
    while ( 1 )
    {
      v68 = v8[5];
      if ( !v68 )
        break;
      v69 = *(unsigned __int8 *)(v8[8] + v68 - 1);
      v70 = v69 > 0x20;
      if ( v69 != 32 )
        v70 = v69 - 9 > 4;
      if ( v70 )
      {
        while ( 1 )
        {
          v71 = v8[5];
          if ( !v71 )
            break;
          v72 = *(unsigned __int8 *)(v8[8] + v71 - 1);
          v73 = v72 > 0x20;
          if ( v72 != 32 )
            v73 = v72 - 9 > 4;
          if ( !v73 )
            break;
          i = sub_5BBE0();
        }
        break;
      }
      i = sub_5BBE0();
    }
LABEL_186:
    if ( v24 != 9 )
      v118 = 0;
  }
  if ( v25 == 1073741891 )
  {
    v19 = 0;
    goto LABEL_183;
  }
  if ( v25 > 1073741891 )
  {
    if ( v25 == 1073741893 )
    {
      i = sub_5B900();
      goto LABEL_186;
    }
    if ( v25 < 1073741893 )
      goto LABEL_183;
    if ( v25 == 1073741897 )
    {
      i = sub_5ACE4(v8[5]);
LABEL_223:
      v19 = 0;
      goto LABEL_186;
    }
    if ( v25 != 1073741904 )
      goto LABEL_39;
LABEL_149:
    v77 = v8[19] - (_DWORD)src;
    if ( v77 )
    {
      v78 = v8[5];
      memmove((void *)(v8[8] + v78 + v77), (const void *)(v8[8] + v78), v8[6] - v78 + 1);
      memcpy((void *)(v8[8] + v8[5]), src, v77);
      v8[6] += v77;
      sub_5B9F0();
      v28 = v8[5] + 1 - v78 - v77;
      goto LABEL_151;
    }
    goto LABEL_186;
  }
  if ( v25 == 1073741889 )
  {
    i = sub_5B9F0();
    goto LABEL_223;
  }
  if ( v25 > 1073741889 )
  {
    i = sub_5ADB8();
    goto LABEL_186;
  }
  v29 = v25 == 1073741872;
LABEL_53:
  if ( v29 )
    goto LABEL_49;
LABEL_39:
  if ( s.c_cc[0] && s.c_cc[0] == v24 )
  {
    v27 = -1;
    v8[6] = 0;
    goto LABEL_66;
  }
  if ( !s.c_cc[4] || s.c_cc[4] != v24 )
  {
    if ( (unsigned int)(v25 - 32) > 0xDF )
      goto LABEL_186;
    v103 = v8[6];
    if ( v103 >= v113 - 2 )
      goto LABEL_186;
    v104 = v8[5];
    v105 = v8[8];
    v8[6] = v103 + 1;
    if ( v104 == v103 )
    {
      *(_BYTE *)(v105 + v104) = v25;
      *(_BYTE *)(v8[8] + v8[5] + 1) = 0;
      i = sub_5B628();
      goto LABEL_186;
    }
    memmove((void *)(v105 + v104 + 1), (const void *)(v105 + v104), v103 + 1 - v104);
    *(_BYTE *)(v8[8] + v104) = v25;
    sub_5B9F0();
    v28 = v8[5] - (v104 + 1);
    goto LABEL_151;
  }
  if ( v8[6] )
  {
LABEL_273:
    v81 = 0;
    goto LABEL_181;
  }
  *(_DWORD *)dword_7DB94 = 0;
LABEL_272:
  v27 = -1;
  v8[6] = -1;
LABEL_66:
  if ( (int)v8[6] > 0 )
  {
    v30 = *v8;
    if ( (*(_DWORD *)*v8 & 1) != 0 )
    {
      if ( *a3 )
      {
        v31 = *(_DWORD *)(v30 + 12);
        if ( !v31 || strcmp(*(const char **)(v30 + 4 * (v31 + 7)), a3) )
        {
          free(*(void **)(v30 + 4 * (*(_DWORD *)(v30 + 20) + 8)));
          v32 = *v8;
          v33 = *(_DWORD *)(*v8 + 20);
          *(_DWORD *)(*v8 + 4 * (v33 + 8)) = 0;
          if ( v31 >= v33 )
          {
            free(*(void **)(v32 + 32));
            v34 = 0;
            v35 = *(_DWORD *)(*v8 + 20);
            v36 = (_DWORD *)(*v8 + 32);
            while ( v35 - 1 > v34 )
            {
              ++v34;
              *v36 = v36[1];
              ++v36;
            }
            if ( v35 < 1 )
              v35 = 1;
            v31 = v35 - 1;
          }
          v37 = *v8;
          v38 = sub_174F8(a3);
          v39 = (_DWORD *)*v8;
          *(_DWORD *)(v37 + 4 * (v31 + 8)) = v38;
          v40 = v39[7];
          v39[4] = v31 + 1;
          v39[3] = v31 + 1;
          if ( v40 )
          {
            v41 = open64(v40, 1089);
            v43 = v41;
            if ( v41 >= 0 )
            {
              sub_1771C(v41, v42, 0, 2);
              v44 = strlen(a3);
              v45 = v44 + 1;
              a3[v44] = 10;
              v46 = v44;
              v47 = sub_17FB8(v43, a3, v44 + 1);
              a3[v46] = 0;
              close(v43);
              if ( v45 == v47 )
              {
                v48 = (int *)*v8;
                v49 = *(_DWORD *)(*v8 + 20);
                v50 = *(_DWORD *)(*v8 + 24) + 1;
                *(_DWORD *)(*v8 + 24) = v50;
                if ( v50 > 4 * v49 )
                {
                  v51 = (const char **)sub_5C3B4(*v48);
                  v52 = *(const char **)(*v8 + 20);
                  v51[7] = *(const char **)(*v8 + 28);
                  v51[5] = v52;
                  sub_5AFAC(v51);
                  v53 = *(const char **)(*v8 + 28);
                  v54 = getpid();
                  v55 = sub_177E4("%s.%u.new", v53, v54);
                  v56 = open64(v55, 577);
                  if ( v56 >= 0 )
                  {
                    v57 = v51 + 8;
                    v58 = sub_61CCC(v56);
                    while ( v109 < (int)v51[3] )
                    {
                      v106 = *v57++;
                      fprintf(v58, "%s\n", v106);
                      ++v109;
                    }
                    fclose(v58);
                    if ( !rename(v55, *(const char **)(*v8 + 28)) )
                      *(_DWORD *)(*v8 + 24) = v51[3];
                  }
                  free(v55);
                  v59 = (int)v51[3];
                  v60 = (int)&v51[v59 + 8];
                  while ( v59 > 0 )
                  {
                    v107 = *(void **)(v60 - 4);
                    v60 -= 4;
                    --v59;
                    free(v107);
                  }
                  free(v51);
                }
              }
            }
          }
        }
      }
    }
  }
  if ( v27 == 1 )
  {
    v61 = v8[6];
    v8[6] = v61 + 1;
    a3[v61] = 10;
    a3[v61 + 1] = 0;
  }
  sub_5AF1C();
  sub_1729C(&s);
  sub_18150(28, (const struct sigaction *)(v8 + 52));
  sub_177D8();
  v9 = v8[6];
LABEL_6:
  sub_5AF68();
  return v9;
}
// 5D008: conditional instruction was optimized away because r0.4==45
// 5D098: conditional instruction was optimized away because r0.4==77
// 5C590: variable 'v16' is possibly undefined
// 5C590: variable 'v17' is possibly undefined
// 5C5E8: variable 'i' is possibly undefined
// 5C5E8: variable 'v21' is possibly undefined
// 5C814: variable 'v42' is possibly undefined
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 14048: using guessed type int __fastcall fgets_unlocked(_DWORD, _DWORD, _DWORD);
// 7D610: using guessed type int stdin;
// 7DB94: using guessed type int dword_7DB94;
// 7DBC4: using guessed type int dword_7DBC4;

//----- (0005D2A0) --------------------------------------------------------
_DWORD *__fastcall sub_5D2A0(int *a1, int a2)
{
  _DWORD *result; // r0
  int v5; // r3

  result = sub_1748C(8u);
  v5 = *a1;
  result[1] = a2;
  *a1 = (int)result;
  *result = v5;
  return result;
}

//----- (0005D2C8) --------------------------------------------------------
_DWORD *__fastcall sub_5D2C8(_DWORD *a1, int a2)
{
  _DWORD *result; // r0

  while ( *a1 )
    a1 = (_DWORD *)*a1;
  result = sub_174DC(8u);
  *a1 = result;
  result[1] = a2;
  return result;
}

//----- (0005D2FC) --------------------------------------------------------
int __fastcall sub_5D2FC(_DWORD **a1)
{
  _DWORD *v1; // r3
  int v2; // r4

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v2 = v1[1];
  *a1 = (_DWORD *)*v1;
  free(v1);
  return v2;
}

//----- (0005D328) --------------------------------------------------------
int __fastcall sub_5D328(int a1, struct utsname *a2)
{
  int result; // r0
  FILE *v5; // r4
  int v6; // r0
  bool v7; // zf
  int v8; // r0
  struct utsname *machine; // r3
  bool v10; // zf
  struct tm *v11; // r0
  time_t v12; // [sp+0h] [bp-290h] BYREF
  char s; // [sp+4h] [bp-28Ch] BYREF
  char v14; // [sp+5h] [bp-28Bh]
  char v15; // [sp+6h] [bp-28Ah]
  struct utsname name; // [sp+108h] [bp-188h] BYREF

  time(&v12);
  uname(&name);
  puts("\r");
  result = sub_61C9C(a1);
  v5 = (FILE *)result;
  if ( result )
  {
    while ( 1 )
    {
      v6 = getc_unlocked(v5);
      if ( v6 == -1 )
      {
        fclose(v5);
        return sub_177D8();
      }
      v14 = 0;
      if ( v6 == 10 )
      {
        v15 = 0;
        v14 = 13;
      }
      v7 = v6 == 37;
      if ( v6 != 37 )
        v7 = v6 == 92;
      s = v6;
      if ( !v7 )
        goto LABEL_39;
      v8 = getc_unlocked(v5);
      if ( v8 == 109 )
      {
        machine = (struct utsname *)name.machine;
        goto LABEL_36;
      }
      if ( v8 <= 109 )
        break;
      if ( v8 == 114 )
      {
        machine = (struct utsname *)name.release;
        goto LABEL_36;
      }
      if ( v8 <= 114 )
      {
        if ( v8 != 110 )
        {
          v10 = v8 == 111;
LABEL_18:
          if ( v10 )
          {
LABEL_20:
            machine = (struct utsname *)name.__domainname;
            goto LABEL_36;
          }
LABEL_25:
          s = v8;
          machine = (struct utsname *)&s;
          goto LABEL_36;
        }
LABEL_37:
        machine = (struct utsname *)name.nodename;
        goto LABEL_36;
      }
      if ( v8 == 116 )
      {
        sub_18768(&s, 0x101u, (time_t)&v12);
LABEL_39:
        machine = (struct utsname *)&s;
        goto LABEL_36;
      }
      if ( v8 < 116 )
        goto LABEL_41;
      if ( v8 != 118 )
        goto LABEL_25;
      machine = (struct utsname *)name.version;
LABEL_36:
      fputs_unlocked(machine, stdout);
    }
    if ( v8 != 83 )
    {
      if ( v8 <= 83 )
      {
        if ( v8 == 68 )
          goto LABEL_20;
        v10 = v8 == 79;
        goto LABEL_18;
      }
      if ( v8 == 104 )
        goto LABEL_37;
      if ( v8 == 108 )
      {
        machine = a2;
        goto LABEL_36;
      }
      if ( v8 != 100 )
        goto LABEL_25;
      v11 = localtime(&v12);
      strftime(&s, 0x101u, "%A, %d %B %Y", v11);
      goto LABEL_39;
    }
LABEL_41:
    machine = &name;
    goto LABEL_36;
  }
  return result;
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;

//----- (0005D4C4) --------------------------------------------------------
void sub_5D4C4()
{
  void *v0; // r5

  v0 = sub_60AA0();
  fputs_unlocked(v0, stdout);
  fputs_unlocked(" login: ", stdout);
  sub_177D8();
  free(v0);
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;

//----- (0005D500) --------------------------------------------------------
int sub_5D500()
{
  __uid_t v0; // r4
  const char *v1; // r4
  size_t v2; // r0
  int v3; // t1

  v0 = getuid();
  if ( v0 == geteuid() )
    return 0;
  v1 = "ENV";
  do
  {
    unsetenv(v1);
    v2 = strlen(v1) + 1;
    v3 = (unsigned __int8)v1[v2];
    v1 += v2;
  }
  while ( v3 );
  putenv("PATH=/sbin:/usr/sbin:/bin:/usr/bin");
  return 1;
}

//----- (0005D55C) --------------------------------------------------------
int __fastcall sub_5D55C(int a1)
{
  int v1; // r0
  int v2; // r5
  int v3; // r4

  v1 = open64(a1, 0);
  v2 = v1;
  if ( v1 < 0 )
    return 1;
  v3 = ioctl(v1, 0x4C01u, 0);
  close(v2);
  return v3;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (0005D594) --------------------------------------------------------
int __fastcall sub_5D594(char **a1, const char *a2, int a3, int a4, int a5)
{
  int v6; // r7
  int v7; // r4
  char *v9; // r6
  int v10; // r5
  signed int v11; // r8
  _BOOL4 v12; // r3
  _DWORD *v13; // r9
  bool v14; // zf
  __dev_t v15; // r0
  int fd; // [sp+0h] [bp-17Ch]
  char s[24]; // [sp+10h] [bp-16Ch] BYREF
  int v21; // [sp+38h] [bp-144h]
  _DWORD v22[59]; // [sp+90h] [bp-ECh] BYREF

  if ( (a5 & 1) != 0 )
    v6 = 0;
  else
    v6 = 2;
  while ( 1 )
  {
    fd = open64(a2, v6);
    if ( fd >= 0 )
      break;
    if ( !v6 )
      return -*(_DWORD *)dword_7DB94;
    v6 = 0;
  }
  v9 = *a1;
  v10 = -1;
  v7 = -1;
  v11 = 0;
  if ( !*a1 )
    v9 = s;
  while ( 1 )
  {
    v12 = v11 <= 0xFFFFF;
    if ( !v10 )
      v12 = 0;
    if ( !v12 )
      break;
    sprintf(s, "/dev/loop%u", v11);
    v13 = (_DWORD *)dword_7DB94;
    *(_DWORD *)dword_7DB94 = 0;
    if ( sub_62DFC() || (v21 & 0xF000) != 0x6000 )
    {
      v14 = *v13 == 2;
      if ( *v13 == 2 )
        v14 = v9 == s;
      if ( !v14 || (v15 = j_gnu_dev_makedev(7u, v11), sub_62E20(s, 0x61A4u, v15)) )
      {
LABEL_34:
        v10 = -1;
        break;
      }
    }
    v7 = open64(v9, v6);
    if ( v7 >= 0 || *v13 == 30 && (v7 = open64(v9, 0), v6 = 0, v7 >= 0) )
    {
      v10 = ioctl(v7, 0x4C05u, v22);
      if ( !v10 || *v13 != 6 )
      {
        v10 = -1;
        goto LABEL_28;
      }
      if ( ioctl(v7, 0x4C00u, fd) )
        goto LABEL_28;
      memset(v22, 0, 0xE8u);
      sub_60B34((char *)&v22[14], a2, 64);
      v22[6] = a3;
      v22[7] = a4;
      v22[13] = a5 & 0xFFFFFFFE;
      v10 = ioctl(v7, 0x4C04u, v22);
      if ( v10 )
      {
        if ( (v22[13] & 4) == 0 || (v22[13] -= 4, (v10 = ioctl(v7, 0x4C04u, v22)) != 0) )
        {
          ioctl(v7, 0x4C01u, 0);
LABEL_28:
          close(v7);
        }
      }
    }
    else if ( *v13 == 6 )
    {
      goto LABEL_34;
    }
    if ( *a1 )
      break;
    ++v11;
  }
  close(fd);
  if ( v10 )
    return v10;
  if ( !*a1 )
    *a1 = sub_174F8(s);
  return v7;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7DB94: using guessed type int dword_7DB94;

//----- (0005D824) --------------------------------------------------------
int __fastcall sub_5D824(char *path, __mode_t a2, int a3)
{
  int v3; // r9
  __mode_t v4; // r4
  char *v5; // r7
  unsigned int v6; // r6
  int v10; // r8
  char *v11; // r3
  int v12; // r2
  int v13; // t1
  int v14; // t1
  __mode_t v15; // r0
  _BOOL4 v16; // r3
  const char *v18; // r1
  int v19; // [sp+4h] [bp-70h]
  __int16 v20; // [sp+18h] [bp-5Ch]

  if ( (unsigned int)(unsigned __int8)*path - 46 <= 1 )
  {
    v3 = (unsigned __int8)path[1];
    if ( !path[1] )
      return v3;
  }
  v4 = -1;
  v5 = path;
  v6 = -1;
  v19 = a3 & 4;
  while ( 1 )
  {
    if ( v19 )
    {
      v11 = v5;
      while ( 1 )
      {
        v5 = v11;
        v13 = (unsigned __int8)*v11++;
        v12 = v13;
        if ( !v13 )
          break;
        if ( v12 == 47 )
        {
          do
          {
            v14 = (unsigned __int8)*++v5;
            v10 = v14;
          }
          while ( v14 == 47 );
          *v5 = 0;
          if ( !v10 )
            break;
          if ( v6 == -1 )
          {
            v15 = umask(0);
            v6 = v15 & 0xFFFFFF3F;
            v4 = v15;
            if ( (v15 & 0xFFFFFF3F) != 0 )
              umask(v15 & 0xFFFFFF3F);
          }
          goto LABEL_16;
        }
      }
    }
    if ( v6 != v4 )
    {
      v6 = v4;
      umask(v4);
    }
    v10 = 0;
LABEL_16:
    if ( mkdir(path, 0x1FFu) >= 0 )
      break;
    v16 = v19 == 0;
    if ( (*(_DWORD *)dword_7DB94 & 0xFFFFFFFB) != 0x11 )
      v16 = 1;
    if ( v16 || sub_62DFC() < 0 || (v20 & 0xF000) != 0x4000 )
    {
      v18 = "create";
      v3 = -1;
      goto LABEL_33;
    }
    if ( !v10 )
      goto LABEL_23;
LABEL_34:
    *v5 = v10;
  }
  if ( (a3 & 0x1000) != 0 )
    printf("created directory: '%s'\n", path);
  if ( v10 )
    goto LABEL_34;
  if ( a2 == -1 || chmod(path, a2) >= 0 )
  {
LABEL_23:
    v3 = 0;
    goto LABEL_24;
  }
  v18 = "set permissions of";
  v3 = -(a3 >= 0);
LABEL_33:
  sub_16AF4("can't %s directory '%s'", v18, path);
LABEL_24:
  if ( v6 != v4 )
    umask(v4);
  return v3;
}
// 5D940: variable 'v20' is possibly undefined
// 7DB94: using guessed type int dword_7DB94;

//----- (0005D9F8) --------------------------------------------------------
int __fastcall sub_5D9F8(int a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // r4
  int v3; // r5
  unsigned __int8 *v5; // r0
  int v6; // r3
  bool v7; // zf
  char *v8; // r0

  v2 = a2;
  if ( !a2 )
    return 1;
  if ( *a2 == 110 && a2[1] == 111 )
  {
    v2 = a2 + 2;
    v3 = 0;
  }
  else
  {
    v3 = 1;
  }
  while ( 1 )
  {
    v5 = sub_1684C(v2, a1);
    if ( v5 )
    {
      v6 = *v5;
      v7 = v6 == 44;
      if ( v6 != 44 )
        v7 = v6 == 0;
      if ( v7 )
        break;
    }
    v8 = strchr((const char *)v2, 44);
    if ( !v8 )
      return v3 ^ 1;
    v2 = (unsigned __int8 *)(v8 + 1);
  }
  return v3;
}

//----- (0005DA78) --------------------------------------------------------
char *__fastcall sub_5DA78(int a1)
{
  int v1; // r4
  int v2; // r2
  int v3; // lr
  char v4; // r3
  int v5; // r12
  char *v6; // r8
  bool v7; // zf
  int v8; // lr
  char *v9; // r3

  v1 = 256;
  v2 = 0;
  byte_7D784[0] = aRwxststPcDBLSS[((unsigned __int16)a1 >> 12) + 7];
  do
  {
    v3 = 3 * v2;
    v4 = 0;
    v5 = 0;
    v6 = &byte_7D784[3 * v2];
    do
    {
      v7 = (v1 & a1) == 0;
      *++v6 = 45;
      if ( (v1 & a1) != 0 )
        v4 = aRwxststPcDBLSS[v5];
      v1 >>= 1;
      if ( !v7 )
      {
        *v6 = v4;
        v4 = v5;
      }
      ++v5;
    }
    while ( v5 != 3 );
    if ( (a1 & (4096 >> ++v2)) != 0 )
    {
      v8 = v3 + 3;
      v9 = &aRwxststPcDBLSS[v4 & 2];
      if ( v2 == 3 )
        ++v9;
      byte_7D784[v8] = v9[3];
    }
  }
  while ( v2 != 3 );
  return byte_7D784;
}

//----- (0005DB1C) --------------------------------------------------------
_BYTE *__fastcall sub_5DB1C(_BYTE *result)
{
  if ( result )
  {
    --result;
    while ( *++result )
      *result = 0;
  }
  return result;
}

//----- (0005DB40) --------------------------------------------------------
bool __fastcall sub_5DB40(int a1, int a2)
{
  return strcasestr(a2, a1) || strcasestr(a1, a2) != 0;
}
// 134F8: using guessed type int __fastcall strcasestr(_DWORD, _DWORD);

//----- (0005DB80) --------------------------------------------------------
int __fastcall sub_5DB80(const char *a1, int a2)
{
  _BOOL4 v4; // r5
  char *v5; // r4
  signed int v6; // r0
  char *v7; // r2
  signed int i; // r3
  int v9; // r0
  char *v10; // r4
  int v11; // r5

  v4 = sub_5DB40((int)a1, a2);
  v5 = sub_174F8(a1);
  v6 = strlen(a1);
  v7 = v5 - 1;
  for ( i = v6; --i >= 0; *++v7 = a1[i] )
    ;
  if ( v6 < 0 )
    v9 = -v6;
  else
    v9 = 0;
  v10 = &v5[v9];
  v11 = sub_5DB40((int)v10, a2) || v4;
  sub_5DB1C(v10);
  free(v10);
  return v11;
}

//----- (0005DBFC) --------------------------------------------------------
int __fastcall sub_5DBFC(_BYTE *a1, const char *a2, int *a3)
{
  size_t v6; // r7
  _BYTE *v7; // r1
  void *v8; // r4
  int v9; // r6
  const char *v10; // r10
  const char *v11; // r2
  int v12; // r4
  int v13; // r8
  int v14; // t1
  const char *v15; // r0
  int v16; // r11
  char *v17; // r0
  char *v18; // r3
  int v19; // r2
  unsigned int v20; // r3
  int v21; // r1
  bool v22; // zf
  const char *v24; // r1
  unsigned __int8 *v25; // [sp+4h] [bp-8h]

  if ( !a2 || (v6 = strlen(a2), v6 <= 5) )
  {
    v24 = "too short";
    goto LABEL_31;
  }
  if ( sub_5DB80(a2, *a3) )
  {
    v24 = "similar to username";
    goto LABEL_31;
  }
  v7 = (_BYTE *)a3[4];
  if ( *v7 && sub_5DB80(a2, (int)v7) )
  {
    v24 = "similar to gecos";
LABEL_31:
    v9 = 1;
    printf("Bad password: %s\n", v24);
    return v9;
  }
  v8 = sub_60AA0();
  v9 = sub_5DB80(a2, (int)v8);
  free(v8);
  if ( v9 )
  {
    v24 = "similar to hostname";
    goto LABEL_31;
  }
  v10 = a2;
  v11 = &a2[v6];
  v12 = 0;
  do
  {
    v14 = *(unsigned __int8 *)v10++;
    v13 = v14;
    if ( (unsigned int)(v14 - 97) > 0x19 )
    {
      if ( (unsigned int)(v13 - 65) > 0x19 )
      {
        if ( (unsigned int)(v13 - 48) > 9 )
          v12 |= 8u;
        else
          v12 |= 4u;
      }
      else
      {
        v12 |= 2u;
      }
    }
    else
    {
      v12 |= 1u;
    }
    v15 = a2;
    v16 = 0;
    do
    {
      v25 = (unsigned __int8 *)v11;
      v17 = strchr(v15, v13);
      v18 = v17;
      v11 = (const char *)v25;
      if ( !v17 )
        break;
      v15 = v17 + 1;
      ++v16;
    }
    while ( v18[1] );
    if ( v6 <= 2 * v16 )
    {
      v24 = "too many similar characters";
      goto LABEL_31;
    }
  }
  while ( v10 != (const char *)v25 );
  v19 = 4;
  v20 = 14;
  v21 = 1;
  do
  {
    v22 = (v12 & v21) == 0;
    v21 *= 2;
    if ( !v22 )
      v20 -= 2;
    --v19;
  }
  while ( v19 );
  if ( v6 < v20 )
  {
    v24 = "too weak";
    goto LABEL_31;
  }
  if ( a1 && *a1 && sub_5DB80(a2, (int)a1) )
  {
    v24 = "similar to old password";
    goto LABEL_31;
  }
  return v9;
}

//----- (0005DDC4) --------------------------------------------------------
_DWORD *__fastcall sub_5DDC4(int a1, int (*a2)(void))
{
  int v2; // r4
  _DWORD *result; // r0

  v2 = a2();
  if ( !v2 )
    return 0;
  result = sub_174DC(0x1Cu);
  *result = v2;
  return result;
}

//----- (0005DDEC) --------------------------------------------------------
void __fastcall sub_5DDEC(int a1)
{
  if ( a1 )
  {
    fclose(*(FILE **)a1);
    free(*(void **)(a1 + 8));
    free(*(void **)(a1 + 12));
    free((void *)a1);
  }
}

//----- (0005DE1C) --------------------------------------------------------
int __fastcall sub_5DE1C(_DWORD *a1, void *a2, int a3, const char *a4)
{
  int v6; // r3
  int v7; // r9
  int v9; // r0
  int v10; // r4
  char *v11; // r11
  int v12; // r0
  size_t v13; // r2
  int v14; // r8
  size_t v15; // r1
  char *v16; // r0
  char *v17; // r4
  unsigned __int8 *v18; // r0
  int v19; // r2
  bool v20; // zf
  _BOOL4 v21; // r2
  int v22; // r11
  int v23; // r8
  const char *v24; // r1
  int v25; // r3
  int v26; // r1
  bool v27; // cc
  int v29; // r1
  int v30; // r0
  char *v31; // r3
  char *v32; // r0
  int v33; // [sp+4h] [bp-30h]
  int v34; // [sp+8h] [bp-2Ch]
  int n; // [sp+10h] [bp-24h]
  size_t v37; // [sp+14h] [bp-20h]
  _DWORD *v38; // [sp+24h] [bp-10h]
  char *v39; // [sp+28h] [bp-Ch]

  if ( !a1 )
    return 0;
  v6 = a3 & 0x800000;
  if ( (a3 & 0x800000) != 0 )
    v6 = *(unsigned __int8 *)a4;
  v7 = (unsigned __int8)a3;
  if ( (a3 & 0x800000) == 0 )
    v33 = v6;
  if ( (a3 & 0x800000) != 0 )
  {
    ++a4;
    v33 = v6;
  }
  v34 = BYTE1(a3);
  n = 4 * (unsigned __int8)a3;
  v38 = a1 + 5;
  while ( 1 )
  {
    while ( 1 )
    {
      memset(a2, 0, n);
      v9 = getline(a1 + 2, a1 + 4, *a1);
      v10 = v9;
      if ( v9 <= 0 )
      {
        if ( v9 )
          return 0;
      }
      else
      {
        v11 = (char *)a1[2];
        while ( 1 )
        {
          ++a1[6];
          if ( v11[v10 - 1] == 10 && !--v10 )
            break;
          if ( v11[v10 - 1] != 92 )
            break;
          --v10;
          v12 = getline(a1 + 3, v38, *a1);
          v13 = v12;
          if ( v12 <= 0 )
            break;
          v14 = v10 + v12;
          v15 = v10 + v12 + 1;
          if ( a1[4] < v15 )
          {
            a1[4] = v15;
            v37 = v12;
            v16 = (char *)sub_174B4(v11, v15);
            v13 = v37;
            v11 = v16;
            a1[2] = v16;
          }
          memcpy(&v11[v10], (const void *)a1[3], v13);
          v10 = v14;
        }
        v11[v10] = 0;
      }
      v17 = (char *)a1[2];
      if ( (a3 & 0x20000) != 0 )
        v17 += strspn(v17, a4 + 1);
      v18 = (unsigned __int8 *)v17;
      if ( (a3 & 0x1000000) != 0 )
        v18 = sub_60E74((unsigned __int8 *)v17);
      v19 = *v18;
      if ( *v18 )
      {
        v20 = v19 == v33;
        if ( v19 != v33 )
          v20 = *(unsigned __int8 *)a4 == v19;
        v21 = v20;
        if ( !v20 )
          break;
      }
    }
    v22 = v21;
    v23 = a3 & 0x400000;
    do
    {
      *((_DWORD *)a2 + v22) = v17;
      if ( v7 - 1 == v22 && (a3 & 0x40000) != 0 )
      {
        if ( v23 )
          v29 = *(unsigned __int8 *)a4;
        else
          v29 = 0;
        v30 = strchrnul(v17, v29);
        v17 = (char *)v30;
        if ( (a3 & 0x20000) != 0 )
        {
          v31 = (char *)v30;
          do
          {
            v17 = v31;
            v39 = v31 - 1;
            v32 = strchr(a4 + 1, (unsigned __int8)*(v31 - 1));
            v31 = v39;
          }
          while ( v32 );
        }
      }
      else
      {
        if ( *a4 && v23 )
          v24 = a4;
        else
          v24 = a4 + 1;
        v17 += strcspn(v17, v24);
      }
      if ( v23 && *(unsigned __int8 *)a4 == (unsigned __int8)*v17 )
      {
        *v17 = 0;
      }
      else if ( *v17 )
      {
        *v17++ = 0;
      }
      if ( (a3 & 0x10000) != 0 )
        v17 += strspn(v17, a4 + 1);
      v25 = (unsigned __int8)*v17;
      ++v22;
      if ( !*v17 )
        break;
      v26 = *(unsigned __int8 *)a4;
      v27 = v26 <= v25;
      if ( v26 != v25 )
        v27 = v7 <= v22;
    }
    while ( !v27 );
    if ( v34 <= v22 )
      break;
    sub_16DDC("bad line %u: %d tokens found, %d needed", a1[6], v22, v34);
    if ( (a3 & 0x100000) != 0 )
      sub_16E08();
  }
  return v22;
}
// 5DF78: variable 'v33' is possibly undefined
// 13624: using guessed type int strchrnul(const char *, ...);
// 140B4: using guessed type int __fastcall getline(_DWORD, _DWORD, _DWORD);

//----- (0005E0F4) --------------------------------------------------------
unsigned int __fastcall sub_5E0F4(const char *a1, unsigned int nptr)
{
  const char *i; // r4
  unsigned int result; // r0
  _BOOL4 v5; // r3
  int v6; // r7
  const char *v7; // r3
  int v10; // r9
  int v11; // r8
  char *v12; // r2
  unsigned int v13; // r2
  int v14; // r5
  int v15; // r0
  int v16; // r5
  int v17; // r2
  bool v18; // zf
  int v19; // t1
  const char *v20; // r2
  int v21; // r12
  __mode_t v24; // [sp+4h] [bp-10h]
  char *endptr; // [sp+Ch] [bp-8h] BYREF

  if ( (unsigned int)*(unsigned __int8 *)a1 - 48 <= 7 )
  {
    result = strtoul(a1, &endptr, 8);
    v5 = result >= 0x1000;
    if ( *endptr )
      v5 = 1;
    if ( v5 )
      return -1;
  }
  else
  {
    for ( i = a1; ; ++i )
    {
LABEL_3:
      if ( !*i )
        return nptr;
      if ( *i != 44 )
        break;
    }
    v6 = 0;
    do
    {
      v7 = "augo";
      while ( *(unsigned __int8 *)v7 != *(unsigned __int8 *)i )
      {
        if ( !*(unsigned __int8 *)++v7 )
        {
          v10 = -4096;
          if ( v6 )
            v10 = ~v6;
          while ( 1 )
          {
            v11 = *(unsigned __int8 *)i;
            if ( ((v11 - 43) & 0xFD) != 0 )
            {
              if ( v11 != 61 )
                return -1;
              nptr &= v10;
            }
            v12 = "ugo";
            while ( *v12 != i[1] )
            {
              v19 = (unsigned __int8)*++v12;
              v14 = v19;
              if ( !v19 )
              {
                ++i;
                do
                {
                  v20 = "rwxXst";
                  v21 = *(unsigned __int8 *)i;
                  while ( *(unsigned __int8 *)v20 != v21 )
                  {
                    if ( !*(unsigned __int8 *)++v20 )
                      goto LABEL_31;
                  }
                  if ( v21 != 88 || (nptr & 0x4049) != 0 )
                    v14 |= dword_640CC[v20 - "rwxXst"];
                }
                while ( *(unsigned __int8 *)++i );
                if ( !v14 )
                  goto LABEL_3;
                goto LABEL_32;
              }
            }
            i += 2;
            v13 = dword_640E4[v12 - "augo"] & nptr;
            v14 = v13 & 0x1FF;
            if ( (v13 & 0x124) != 0 )
              v14 = v13 & 0xDB | 0x124;
            if ( (v14 & 0x92) != 0 )
              v14 |= 0x92u;
            if ( (v14 & 0x49) != 0 )
              v14 |= 0x49u;
LABEL_31:
            if ( v14 )
            {
LABEL_32:
              v15 = v6;
              if ( !v6 )
              {
                v24 = umask(0);
                umask(v24);
                v15 = ~v24;
              }
              v16 = v14 & v15;
              if ( v11 == 45 )
                nptr &= ~v16;
              else
                nptr |= v16;
            }
            v17 = *(unsigned __int8 *)i;
            v18 = v17 == 0;
            if ( *i )
              v18 = v17 == 44;
            if ( v18 )
              goto LABEL_3;
          }
        }
      }
      v6 |= dword_640E4[v7 - "augo"];
    }
    while ( *(unsigned __int8 *)++i );
    return -1;
  }
  return result;
}
// 640CC: using guessed type _DWORD dword_640CC[6];
// 640E4: using guessed type _DWORD dword_640E4[4];

//----- (0005E304) --------------------------------------------------------
void __noreturn sub_5E304()
{
  sub_16B40(0);
}

//----- (0005E30C) --------------------------------------------------------
int __fastcall sub_5E30C(int result)
{
  int v1; // r5
  __pid_t v2; // r0
  _BYTE *v3; // r0
  char v4[16]; // [sp+0h] [bp-88h] BYREF
  int v5; // [sp+20h] [bp-68h]

  if ( result )
  {
    result = open64(result, 577);
    v1 = result;
    if ( result >= 0 )
    {
      if ( sub_62E08() || (v5 & 0xF000) != 0x8000 )
      {
        dword_7DBC8 = 0;
      }
      else
      {
        dword_7DBC8 = 1;
        v2 = getpid();
        v3 = sub_16EB0(v2, v4, 14);
        *v3 = 10;
        sub_17FB8(v1, v4, v3 - v4 + 1);
      }
      return close(v1);
    }
  }
  return result;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 7DBC8: using guessed type int dword_7DBC8;

//----- (0005E3AC) --------------------------------------------------------
int __fastcall sub_5E3AC(int a1, char *s, int a3, const char *a4)
{
  _DWORD *v6; // r7
  const char *v8; // r6
  int v10; // t1
  const char *v11; // r1

  v6 = (_DWORD *)(a1 - 4);
  v8 = 0;
  while ( *s )
  {
    v10 = v6[1];
    ++v6;
    if ( (a3 & v10) != 0 )
    {
      if ( v8 )
        v11 = v8;
      else
        v11 = "";
      v8 = a4;
      printf("%s%s", v11, s);
      a3 &= ~*v6;
    }
    s += strlen(s) + 1;
  }
  return a3;
}

//----- (0005E42C) --------------------------------------------------------
int __fastcall sub_5E42C(int a1, int a2)
{
  int v3; // r1
  int v4; // r2
  FILE *v5; // r7
  int v6; // r5
  const char *v7; // r0
  char *v8; // r6
  int v10; // r0

  v5 = (FILE *)sub_61CD8(a2);
  v6 = *(_DWORD *)(a1 + 4);
  while ( 1 )
  {
    v7 = sub_58D24(v5, v3, v4);
    v8 = (char *)v7;
    if ( !v7 )
      break;
    if ( *(_DWORD *)(a1 + 20) || *(_DWORD *)(a1 + 24) && *v7 )
    {
      printf("%*u%s%s\n", *(_DWORD *)a1, v6, *(const char **)(a1 + 12), v7);
      v6 += *(_DWORD *)(a1 + 8);
    }
    else
    {
      v10 = *(_DWORD *)(a1 + 16);
      if ( v10 )
        fputs_unlocked(v10, stdout);
    }
    free(v8);
  }
  *(_DWORD *)(a1 + 4) = v6;
  return fclose(v5);
}
// 5E450: variable 'v3' is possibly undefined
// 5E450: variable 'v4' is possibly undefined
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);
// 7D614: using guessed type int stdout;

//----- (0005E4E0) --------------------------------------------------------
int __fastcall sub_5E4E0(__int16 a1, FILE *stream)
{
  int v2; // r4

  LOBYTE(v2) = a1;
  if ( (a1 & 0x180) == 0x180 )
  {
    LOBYTE(v2) = a1 & 0x7F;
    fputs_unlocked("M-", stream);
  }
  v2 = (unsigned __int8)v2;
  if ( (unsigned __int8)v2 == 155 )
  {
    v2 = 123;
    goto LABEL_10;
  }
  if ( (unsigned __int8)v2 <= 0x1Fu )
  {
    v2 = (unsigned __int8)v2 + 64;
LABEL_10:
    putc_unlocked(94, stream);
    return putc_unlocked(v2, stream);
  }
  if ( (unsigned __int8)v2 == 127 )
  {
    v2 = 63;
    goto LABEL_10;
  }
  return putc_unlocked(v2, stream);
}
// 1345C: using guessed type int __fastcall fputs_unlocked(_DWORD, _DWORD);

//----- (0005E550) --------------------------------------------------------
unsigned int __fastcall sub_5E550(unsigned int result, _BYTE *a2, char a3)
{
  bool v3; // cc

  if ( result == 9 )
  {
    if ( (a3 & 2) == 0 )
      goto LABEL_11;
  }
  else
  {
    if ( result == 10 )
    {
      if ( (a3 & 1) == 0 )
        goto LABEL_11;
      *a2 = 36;
      goto LABEL_7;
    }
    if ( result > 0x7F )
    {
      *a2 = 77;
      a2[1] = 45;
      result -= 128;
      a2 += 2;
    }
  }
  v3 = result > 0x7F;
  if ( result != 127 )
    v3 = result > 0x1F;
  if ( !v3 )
  {
    result ^= 0x40u;
    *a2 = 94;
LABEL_7:
    ++a2;
  }
LABEL_11:
  *a2 = result;
  a2[1] = 0;
  return result;
}

//----- (0005E5D0) --------------------------------------------------------
const char *__fastcall sub_5E5D0(int *a1, _BYTE *a2)
{
  _BYTE *v2; // r2
  const char *result; // r0
  int v5; // r1
  int v6; // r2
  char *v7; // r0
  char *i; // r3
  int v9; // r1
  _BYTE *v10; // r2
  int v11; // r3

  v2 = a2;
  result = a2;
  do
  {
    v5 = (unsigned __int8)*v2;
    if ( !*v2 )
    {
      if ( a1 )
      {
        v6 = v2 - result;
        *a1 = v6;
        a1[1] = v6;
        a1[2] = v6;
      }
      return result;
    }
    ++v2;
  }
  while ( (unsigned int)(v5 - 32) <= 0x5E );
  v7 = sub_174F8(result);
  for ( i = v7; ; ++i )
  {
    v10 = i + 1;
    v9 = (unsigned __int8)*i;
    if ( !*i )
      break;
    if ( (unsigned int)(v9 - 32) > 0x5E )
      *(v10 - 1) = 63;
  }
  if ( a1 )
  {
    v11 = i - v7;
    *a1 = v11;
    a1[1] = v11;
    a1[2] = v11;
  }
  return (const char *)sub_57710((int)v7);
}

//----- (0005E668) --------------------------------------------------------
int __fastcall sub_5E668(unsigned __int8 **a1)
{
  unsigned __int8 *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r4
  int v4; // r12
  unsigned __int8 *v5; // lr
  int v6; // r5
  int v7; // t1
  int v8; // r6
  unsigned int v9; // r1
  unsigned int v11; // r1
  const char *v12; // r3

  v1 = *a1;
  v2 = 0;
  if ( **a1 == 120 )
  {
    ++v1;
    v3 = 16;
    v4 = 1;
  }
  else
  {
    v3 = 8;
    v4 = 0;
  }
  while ( 1 )
  {
    v5 = v1;
    v7 = *v1++;
    v6 = v7;
    v8 = v7 | 0x20;
    v9 = (v7 | 0x20) - 48;
    if ( v9 > 9 )
      v9 = v8 - 87;
    if ( v9 >= v3 )
      break;
    v11 = v9 + v3 * v2;
    if ( v11 > 0xFF )
      goto LABEL_13;
    ++v4;
    v5 = v1;
    v2 = v11;
    if ( v4 == 3 )
      goto LABEL_9;
  }
  if ( v3 != 16 )
  {
LABEL_13:
    if ( !v4 )
    {
      v12 = "abefnrtv\\";
      while ( *(unsigned __int8 *)v12 != v6 )
      {
        if ( !*(unsigned __int8 *)++v12 )
          goto LABEL_17;
      }
      ++v5;
LABEL_17:
      LOBYTE(v2) = v12[10];
    }
    goto LABEL_9;
  }
  if ( v4 != 1 )
  {
LABEL_9:
    *a1 = v5;
    return (unsigned __int8)v2;
  }
  return 92;
}

//----- (0005E730) --------------------------------------------------------
_BYTE *__fastcall sub_5E730(_BYTE *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v4; // r3
  _BYTE *v5; // r7
  int v6; // r4
  char v7; // r0
  unsigned __int8 *v9[2]; // [sp+4h] [bp-8h] BYREF

  v9[1] = a3;
  v9[0] = a2;
  do
  {
    v4 = v9[0];
    v5 = a1;
    ++v9[0];
    v6 = *v4;
    if ( v6 == 92 )
      v7 = sub_5E668(v9);
    else
      v7 = *v4;
    *a1++ = v7;
  }
  while ( v6 );
  return v5;
}

//----- (0005E780) --------------------------------------------------------
int __fastcall sub_5E780(int a1, int a2, int (__fastcall *a3)(int))
{
  void *v4; // r0
  int v5; // r6
  int i; // r12
  char *v10; // r0
  char *v11; // r9
  const char *v12; // r0

  v4 = *(void **)a1;
  v5 = *(_DWORD *)(a1 + 4);
  for ( i = 0; ; ++i )
  {
    if ( v5 <= i )
    {
      *(_DWORD *)(a1 + 4) = v5 + 1;
      v10 = sub_62544(v4, 0x2002u, v5);
      *(_DWORD *)a1 = v10;
      v11 = &v10[32 * v5];
      *(_DWORD *)v11 = a2;
      v12 = (const char *)a3(a2);
      sub_60B34(v11 + 4, v12, 28);
      return *(_DWORD *)a1 + 32 * v5 + 4;
    }
    if ( *((_DWORD *)v4 + 8 * i) == a2 )
      break;
  }
  return (int)v4 + 32 * i + 4;
}

//----- (0005E80C) --------------------------------------------------------
ssize_t __fastcall sub_5E80C(int a1, void *a2)
{
  int v3; // r0
  int v4; // r6
  ssize_t v5; // r4

  v3 = open64(a1, 0);
  v4 = v3;
  if ( v3 >= 0 )
  {
    v5 = read(v3, a2, 0x3FFu);
    close(v4);
  }
  else
  {
    v5 = -1;
  }
  *((_BYTE *)a2 + (v5 & ~(v5 >> 31))) = 0;
  return v5;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (0005E854) --------------------------------------------------------
void sub_5E854()
{
  free((void *)dword_7D764);
  dword_7D764 = 0;
  dword_7D768 = 0;
  free((void *)dword_7D75C);
  dword_7D75C = 0;
  dword_7D760 = 0;
}
// 7D75C: using guessed type int dword_7D75C;
// 7D760: using guessed type int dword_7D760;
// 7D764: using guessed type int dword_7D764;
// 7D768: using guessed type int dword_7D768;

//----- (0005E890) --------------------------------------------------------
int __fastcall sub_5E890(int a1)
{
  return sub_5E780((int)&dword_7D764, a1, (int (__fastcall *)(int))sub_57B14);
}
// 7D764: using guessed type int dword_7D764;

//----- (0005E8A8) --------------------------------------------------------
int __fastcall sub_5E8A8(int a1)
{
  return sub_5E780((int)&dword_7D75C, a1, (int (__fastcall *)(int))sub_57B34);
}
// 7D75C: using guessed type int dword_7D75C;

//----- (0005E8C0) --------------------------------------------------------
void __fastcall sub_5E8C0(int a1)
{
  closedir(*(DIR **)a1);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 12));
  free((void *)a1);
}

//----- (0005E8EC) --------------------------------------------------------
char *__fastcall sub_5E8EC(char *a1, int a2)
{
  char *v2; // r4
  unsigned int v4; // r6
  char v5; // r3
  int v6; // r0
  int v7; // r0
  int v9; // r6
  char *v10; // r6
  char *v11; // r0
  const char *v12; // r7
  char *v13; // r0
  int v14; // r2
  unsigned int v15; // r1
  int v16; // r3
  char *v17; // r3
  char v18; // r2
  ssize_t v19; // r0
  void *v20; // r0
  int v21; // [sp+2Ch] [bp-448h] BYREF
  int v22; // [sp+30h] [bp-444h] BYREF
  unsigned int v23; // [sp+34h] [bp-440h] BYREF
  int v24; // [sp+38h] [bp-43Ch] BYREF
  char s[52]; // [sp+3Ch] [bp-438h] BYREF
  char v26[24]; // [sp+70h] [bp-404h] BYREF
  int v27; // [sp+88h] [bp-3ECh]
  int v28; // [sp+8Ch] [bp-3E8h]

  v2 = a1;
  if ( !a1 )
  {
    v4 = getpagesize();
    v2 = (char *)sub_174DC(0x58u);
    *(_DWORD *)v2 = sub_17980("/proc");
    while ( 1 )
    {
      v4 >>= 1;
      v5 = v2[4];
      if ( !v4 )
        break;
      v2[4] = v5 + 1;
    }
    v2[5] = v5 - 10;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        v6 = readdir64(*(_DWORD *)v2);
        if ( !v6 )
        {
          v7 = (int)v2;
          v2 = 0;
          sub_5E8C0(v7);
          return v2;
        }
        v9 = sub_18990((const char *)(v6 + 19), 0, (char *)0xA);
      }
      while ( *(_DWORD *)dword_7DB94 );
      memset(v2 + 16, 0, 0x48u);
      *((_DWORD *)v2 + 9) = v9;
      if ( (a2 & 0xFFFFFFFE) == 0 )
        return v2;
      v10 = &s[sprintf(s, "/proc/%u/", v9)];
      if ( (a2 & 0x10) == 0 )
        break;
      if ( !sub_62DFC() )
      {
        *((_DWORD *)v2 + 13) = v27;
        *((_DWORD *)v2 + 14) = v28;
        break;
      }
    }
    if ( (a2 & 0x47E2E) == 0 )
      goto LABEL_26;
    strcpy(v10, "stat");
    if ( sub_5E80C((int)s, v26) >= 0 )
    {
      v11 = strrchr(v26, 41);
      *v11 = 0;
      v12 = v11 + 2;
      v13 = strchr(v26, 40);
      sub_60B34(v2 + 72, v13 + 1, 16);
      if ( sscanf(
             v12,
             "%c %u %u %u %d %*s %*s %*s %*s %*s %*s %lu %lu %*s %*s %*s %ld %*s %*s %lu %lu %lu ",
             v2 + 68,
             v2 + 40,
             v2 + 44,
             v2 + 48,
             &v22,
             v2 + 28,
             v2 + 24,
             &v21,
             v2 + 32,
             &v23,
             &v24) > 10 )
        break;
    }
  }
  v14 = v22;
  v15 = v23 >> 10;
  *((_DWORD *)v2 + 5) = v24 << v2[5];
  *((_DWORD *)v2 + 15) = ((unsigned int)v14 >> 8) & 0xFFF;
  *((_DWORD *)v2 + 4) = v15;
  *((_DWORD *)v2 + 16) = (v14 >> 12) & 0xFFF00 | (unsigned __int8)v14;
  v2[69] = 32;
  v2[70] = 32;
  if ( v15 || v2[68] == 90 )
  {
    v16 = 1;
  }
  else
  {
    v2[69] = 87;
    v16 = 2;
  }
  if ( v21 )
  {
    v17 = &v2[v16];
    if ( v21 >= 0 )
      v18 = 78;
    else
      v18 = 60;
    v17[68] = v18;
  }
LABEL_26:
  if ( (a2 & 0x100) != 0 )
  {
    strcpy(v10, "exe");
    free(*((void **)v2 + 3));
    *((_DWORD *)v2 + 3) = sub_17B80(s);
  }
  if ( (a2 & (unsigned int)&dword_10080) != 0 )
  {
    free(*((void **)v2 + 2));
    *((_DWORD *)v2 + 2) = 0;
    strcpy(v10, "cmdline");
    v19 = sub_5E80C((int)s, v26);
    if ( v19 > 0 )
    {
      if ( (a2 & 0x10000) != 0 )
      {
        *((_WORD *)v2 + 3) = v19;
        v20 = sub_1756C(v26, v19 + 1);
      }
      else
      {
        *((_WORD *)v2 + 3) = 0;
        v20 = sub_174F8(v26);
      }
      *((_DWORD *)v2 + 2) = v20;
    }
  }
  return v2;
}
// 10080: using guessed type int dword_10080;
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7DB94: using guessed type int dword_7DB94;

//----- (0005EBFC) --------------------------------------------------------
char *__fastcall sub_5EBFC(char *a1, signed int a2, int a3, const char *a4)
{
  ssize_t v7; // r0
  ssize_t v8; // r5
  bool v9; // cf
  char *result; // r0
  char *v11; // r5
  const char *v12; // r8
  size_t v13; // r5
  signed int v14; // r5
  unsigned int v15; // t1
  const char *v16; // r3
  char v17[32]; // [sp+0h] [bp-20h] BYREF

  sprintf(v17, "/proc/%u/cmdline", a3);
  v7 = sub_180C8((int)v17, a1, a2 - 1);
  v8 = v7;
  if ( v7 <= 0 )
  {
    v16 = "?";
    if ( a4 )
      v16 = a4;
    return (char *)snprintf(a1, a2, "[%s]", v16);
  }
  else
  {
    a1[v7] = 0;
    do
      v9 = v8-- != 0;
    while ( v9 && !a1[v8] );
    *(_BYTE *)strchrnul(a1, 32) = 0;
    result = sub_169FC(a1);
    v11 = &a1[v8 + 1];
    v12 = result;
    while ( v11 != a1 )
    {
      v15 = (unsigned __int8)*--v11;
      if ( v15 <= 0x1F )
        *v11 = 32;
    }
    if ( *result == 45 )
      v12 = result + 1;
    if ( a4 )
    {
      v13 = strlen(a4);
      result = (char *)strncmp(v12, a4, v13);
      if ( result )
      {
        v14 = v13 + 3;
        if ( a2 > v14 )
          memmove(&a1[v14], a1, a2 - v14);
        result = (char *)snprintf(a1, a2, "{%s}", a4);
        if ( a2 > v14 )
        {
          a1[v14 - 1] = 32;
          a1[a2 - 1] = 0;
        }
      }
    }
  }
  return result;
}
// 13624: using guessed type int strchrnul(const char *, ...);

//----- (0005ED54) --------------------------------------------------------
int __fastcall sub_5ED54(char a1)
{
  int v1; // r0

  v1 = a1 & 0x3F;
  if ( !v1 )
    return 46;
  if ( v1 == 1 )
    return 47;
  if ( v1 <= 11 )
    return v1 + 46;
  if ( v1 > 37 )
    return v1 + 59;
  return v1 + 53;
}

//----- (0005ED94) --------------------------------------------------------
_BYTE *__fastcall sub_5ED94(_BYTE *result, unsigned int a2, int a3)
{
  char v3; // r0
  _BYTE *v4; // r3
  _BYTE *v5; // r3
  unsigned int v6; // r1
  _BYTE *v7; // r2

  if ( result != &result[a3] )
  {
    do
    {
      v3 = sub_5ED54(a2);
      *v4 = v3;
      v5 = v4 + 1;
      a2 = v6 >> 6;
    }
    while ( v5 != v7 );
    return v5;
  }
  return result;
}
// 5EDB0: variable 'v4' is possibly undefined
// 5EDB8: variable 'v6' is possibly undefined
// 5EDBC: variable 'v7' is possibly undefined

//----- (0005EDC8) --------------------------------------------------------
unsigned int __fastcall sub_5EDC8(unsigned int a1)
{
  unsigned int result; // r0

  if ( a1 > 0x7A )
    return 0;
  if ( a1 > 0x60 )
    return a1 - 59;
  if ( a1 > 0x5A )
    return 0;
  if ( a1 > 0x40 )
    return a1 - 53;
  result = a1 - 46;
  if ( (unsigned __int8)result > 0xBu )
    return 0;
  return result;
}

//----- (0005EE14) --------------------------------------------------------
int __fastcall sub_5EE14(int a1, unsigned int a2)
{
  char v2; // r0
  _BYTE *v3; // r3
  unsigned int v4; // r1
  char v5; // r0
  int v6; // r3
  unsigned int v7; // r1
  char v8; // r0
  int v9; // r3
  char v10; // r1
  int result; // r0
  int v12; // r3

  v2 = sub_5ED54(a2 >> 18);
  *v3 = v2;
  v5 = sub_5ED54(v4 >> 12);
  *(_BYTE *)(v6 + 1) = v5;
  v8 = sub_5ED54(v7 >> 6);
  *(_BYTE *)(v9 + 2) = v8;
  result = sub_5ED54(v10);
  *(_BYTE *)(v12 + 3) = result;
  return result;
}
// 5EE24: variable 'v3' is possibly undefined
// 5EE28: variable 'v4' is possibly undefined
// 5EE30: variable 'v6' is possibly undefined
// 5EE34: variable 'v7' is possibly undefined
// 5EE3C: variable 'v9' is possibly undefined
// 5EE44: variable 'v10' is possibly undefined
// 5EE48: variable 'v12' is possibly undefined

//----- (0005EE50) --------------------------------------------------------
char *__fastcall sub_5EE50(char *a1, char *a2, char *a3)
{
  size_t i; // r4
  int v7; // r3
  bool v8; // zf
  size_t v9; // r7
  int v10; // r5
  int v11; // r11
  char *v12; // r1
  char *v13; // r10
  size_t v14; // r4
  char *v15; // r1
  size_t v16; // r2
  int v17; // r1
  int v18; // r1
  char *v19; // r1
  size_t v20; // r2
  char *v21; // r3
  char *v22; // r4
  int v23; // t1
  char *v24; // r0
  size_t v26; // r2
  char *v27; // r1
  char v28; // [sp+3h] [bp-F9h] BYREF
  _DWORD v29[5]; // [sp+4h] [bp-F8h] BYREF
  _BYTE v30[112]; // [sp+18h] [bp-E4h] BYREF
  _BYTE v31[116]; // [sp+88h] [bp-74h] BYREF

  for ( i = 3; i != 11; ++i )
  {
    v7 = (unsigned __int8)a3[i];
    v8 = v7 == 36;
    if ( v7 != 36 )
      v8 = v7 == 0;
    if ( v8 )
      break;
  }
  sub_59FE0((int)v30);
  v9 = strlen(a2);
  v10 = v9;
  v11 = v9;
  sub_5A024((int)v30, a2, v9);
  sub_5A024((int)v30, a3, i);
  v12 = a3;
  v13 = a3 + 3;
  memcpy(a1, v12, i);
  a1[i] = 36;
  v14 = i - 3;
  sub_59FE0((int)v31);
  sub_5A024((int)v31, a2, v9);
  sub_5A024((int)v31, v13, v14);
  sub_5A024((int)v31, a2, v9);
  sub_5A08C((int)v31, v29);
  while ( v11 > 0 )
  {
    if ( v11 >= 16 )
      v26 = 16;
    else
      v26 = v11;
    v11 -= 16;
    sub_5A024((int)v30, (char *)v29, v26);
  }
  memset(v29, 0, 0x11u);
  while ( v10 )
  {
    if ( (v10 & 1) != 0 )
      v27 = (char *)v29;
    else
      v27 = a2;
    v10 >>= 1;
    sub_5A024((int)v30, v27, 1u);
  }
  sub_5A08C((int)v30, v29);
  do
  {
    sub_59FE0((int)v31);
    if ( (v10 & 1) != 0 )
      v15 = a2;
    else
      v15 = (char *)v29;
    if ( (v10 & 1) != 0 )
      v16 = v9;
    else
      v16 = 16;
    sub_5A024((int)v31, v15, v16);
    sub_161AC(v10, 3u);
    if ( v17 )
      sub_5A024((int)v31, v13, v14);
    sub_161AC(v10, 7u);
    if ( v18 )
      sub_5A024((int)v31, a2, v9);
    if ( (v10 & 1) != 0 )
      v19 = (char *)v29;
    else
      v19 = a2;
    if ( (v10 & 1) != 0 )
      v20 = 16;
    else
      v20 = v9;
    sub_5A024((int)v31, v19, v20);
    ++v10;
    sub_5A08C((int)v31, v29);
  }
  while ( v10 != 1000 );
  v21 = &a1[v14 + 4];
  v22 = &v28;
  LOBYTE(v29[4]) = BYTE1(v29[1]);
  do
  {
    v23 = (unsigned __int8)*++v22;
    v24 = sub_5ED94(v21, ((unsigned __int8)v22[6] << 8) | (v23 << 16) | (unsigned __int8)v22[12], 4);
    v21 = v24;
  }
  while ( &v29[1] != (_DWORD *)v22 );
  *sub_5ED94(v24, HIBYTE(v29[2]), 2) = 0;
  return a1;
}
// 5EF88: variable 'v17' is possibly undefined
// 5EFAC: variable 'v18' is possibly undefined

//----- (0005F09C) --------------------------------------------------------
_BYTE *__fastcall sub_5F09C(const char *a1, char *s)
{
  char *v4; // r7
  size_t v5; // r0
  int v6; // r2
  size_t v7; // r3
  size_t v8; // r6
  _BYTE *v9; // r0
  char v10; // r2
  char *v11; // r5
  unsigned int v12; // r0
  unsigned int v13; // r3
  unsigned int v14; // r0
  size_t v15; // r8
  size_t v16; // r10
  char *v17; // r0
  void (__fastcall *v18)(int, void *); // r3
  char *v19; // r9
  void (__fastcall *v20)(int, char *, size_t); // r5
  void (__fastcall *v21)(int); // r3
  size_t i; // r3
  size_t v23; // r4
  size_t v24; // r11
  char *v25; // r0
  size_t v26; // r10
  size_t v27; // r2
  unsigned int v28; // r10
  unsigned int v29; // r7
  char *v30; // r1
  size_t v31; // r2
  int v32; // r1
  int v33; // r1
  char *v34; // r1
  size_t v35; // r2
  size_t v36; // r2
  unsigned int v37; // r5
  _BYTE *v38; // r2
  char *v39; // r0
  size_t v40; // r2
  char *v41; // r1
  unsigned int v42; // r1
  int v43; // r2
  size_t v45; // r5
  unsigned int v46; // r2
  unsigned int v47; // [sp+4h] [bp-240h]
  void *dest; // [sp+8h] [bp-23Ch]
  void (__fastcall *v49)(int); // [sp+Ch] [bp-238h]
  void (__fastcall *v50)(int, void *); // [sp+10h] [bp-234h]
  _BYTE *v51; // [sp+14h] [bp-230h]
  char *v52; // [sp+18h] [bp-22Ch]
  int v53; // [sp+1Ch] [bp-228h]
  char v54[30]; // [sp+20h] [bp-224h] BYREF
  unsigned __int16 v55; // [sp+3Eh] [bp-206h]
  unsigned __int8 v56; // [sp+5Fh] [bp-1E5h]
  _BYTE src[64]; // [sp+60h] [bp-1E4h] BYREF
  _BYTE v58[208]; // [sp+A0h] [bp-1A4h] BYREF
  _BYTE v59[212]; // [sp+170h] [bp-D4h] BYREF

  v4 = s + 3;
  v5 = strlen(s);
  v6 = (unsigned __int8)s[1];
  if ( v6 == 54 )
    v7 = v5 + 88;
  else
    v7 = v5 + 45;
  if ( v6 == 54 )
    v8 = 64;
  else
    v8 = 32;
  v9 = sub_174DC(v7);
  v10 = s[1];
  v51 = v9;
  v11 = v9 + 3;
  *v9 = 36;
  v9[1] = v10;
  v9[2] = 36;
  if ( !strncmp(v4, "rounds=%u$", 7u) && (v12 = sub_18990(s + 10, v54, (char *)0xA), **(_BYTE **)v54 == 36) )
  {
    v4 = (char *)(*(_DWORD *)v54 + 1);
    v13 = 999999999;
    if ( v12 < 0x3B9AC9FF )
      v13 = v12;
    if ( v13 < 0x3E8 )
      v13 = 1000;
    v47 = v13;
    v11 += sprintf(v11, "rounds=%u$", v13);
  }
  else
  {
    v47 = 5000;
  }
  v14 = strchrnul(v4, 36) - (_DWORD)v4;
  if ( v14 >= 0x10 )
    v15 = 16;
  else
    v15 = v14;
  dest = sub_1751C(v4, v15);
  strcpy(v11, (const char *)dest);
  v52 = &v11[v15 + 1];
  v11[v15] = 36;
  v16 = strlen(a1);
  v17 = sub_174F8(a1);
  v18 = (void (__fastcall *)(int, void *))sub_5A1E8;
  v19 = v17;
  v20 = (void (__fastcall *)(int, char *, size_t))sub_5A150;
  if ( v8 != 32 )
    v18 = (void (__fastcall *)(int, void *))sub_5A248;
  v50 = v18;
  if ( v8 == 32 )
    v20 = (void (__fastcall *)(int, char *, size_t))sub_5A024;
  v21 = (void (__fastcall *)(int))sub_5A0C4;
  if ( v8 != 32 )
    v21 = (void (__fastcall *)(int))sub_5A10C;
  v49 = v21;
  v21((int)v58);
  v20((int)v58, v19, v16);
  v20((int)v58, (char *)dest, v15);
  v49((int)v59);
  v20((int)v59, v19, v16);
  v20((int)v59, (char *)dest, v15);
  v20((int)v59, v19, v16);
  v50((int)v59, v54);
  for ( i = v16; v8 < i; i = v53 - v8 )
  {
    v53 = i;
    v20((int)v58, v54, v8);
  }
  v23 = v16;
  v20((int)v58, v54, i);
  while ( v23 )
  {
    if ( (v23 & 1) != 0 )
    {
      v40 = v8;
      v41 = v54;
    }
    else
    {
      v40 = v16;
      v41 = v19;
    }
    v20((int)v58, v41, v40);
    v23 >>= 1;
  }
  v24 = 0;
  v50((int)v58, v54);
  v49((int)v59);
  while ( v24 != v16 )
  {
    ++v24;
    v20((int)v59, v19, v16);
  }
  v50((int)v59, src);
  v25 = v19;
  v26 = v24;
  while ( v8 <= v26 )
  {
    v26 -= v8;
    v25 = (char *)memcpy(v25, src, v8) + v8;
  }
  v27 = v26;
  v28 = 0;
  memcpy(v25, src, v27);
  v49((int)v59);
  while ( (unsigned int)(unsigned __int8)v54[0] + 16 > v28 )
  {
    ++v28;
    v20((int)v59, (char *)dest, v15);
  }
  v29 = 0;
  v50((int)v59, src);
  memcpy(dest, src, v15);
  do
  {
    v49((int)v58);
    if ( (v29 & 1) != 0 )
      v30 = v19;
    else
      v30 = v54;
    if ( (v29 & 1) != 0 )
      v31 = v24;
    else
      v31 = v8;
    v20((int)v58, v30, v31);
    sub_15EFC(v29, 3u);
    if ( v32 )
      v20((int)v58, (char *)dest, v15);
    sub_15EFC(v29, 7u);
    if ( v33 )
      v20((int)v58, v19, v24);
    if ( (v29 & 1) != 0 )
      v34 = v54;
    else
      v34 = v19;
    if ( (v29 & 1) != 0 )
      v35 = v8;
    else
      v35 = v24;
    v20((int)v58, v34, v35);
    ++v29;
    v50((int)v58, v54);
  }
  while ( v47 > v29 );
  if ( v8 == 32 )
  {
    while ( 1 )
    {
      v36 = v23 + 10;
      v37 = v23 + 20;
      if ( v23 + 10 > 0x1D )
        v36 = v23 - 20;
      v38 = &v59[v36 + 208];
      if ( v37 > 0x1D )
        v37 = v23 - 10;
      v39 = sub_5ED94(
              v52,
              ((unsigned __int8)*(v38 - 544) << 8) | ((unsigned __int8)v54[v23] << 16) | (unsigned __int8)v54[v37],
              4);
      v52 = v39;
      if ( v37 == 29 )
        break;
      v23 = v37 + 1;
    }
    v42 = v55;
    v43 = 3;
  }
  else
  {
    while ( 1 )
    {
      v45 = v23 + 21;
      v46 = v23 + 42;
      if ( v23 + 21 > 0x3E )
        v45 = v23 - 42;
      if ( v46 > 0x3E )
        v46 = v23 - 21;
      v39 = sub_5ED94(
              v52,
              ((unsigned __int8)v54[v45] << 8) | ((unsigned __int8)v54[v23] << 16) | (unsigned __int8)v54[v46],
              4);
      v52 = v39;
      if ( v45 == 20 )
        break;
      v23 = v45 + 1;
    }
    v43 = 2;
    v42 = v56;
  }
  sub_5ED94(v39, v42, v43);
  free(v19);
  free(dest);
  return v51;
}
// 5F378: variable 'v32' is possibly undefined
// 5F39C: variable 'v33' is possibly undefined
// 13624: using guessed type int strchrnul(const char *, ...);

//----- (0005F5A4) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5F5A4(int *a1, unsigned __int8 *a2, _BYTE *a3, unsigned __int8 *a4)
{
  unsigned int *i; // r1
  unsigned int v8; // r1
  unsigned int v9; // r2
  int *v10; // r9
  int *v11; // r6
  int *v12; // r7
  int *v13; // lr
  int *v14; // r1
  int *v15; // r12
  int *v16; // r0
  int *v17; // r2
  int *v18; // r10
  int v19; // r3
  int v20; // r9
  unsigned int v21; // r0
  int *v22; // r7
  unsigned int v23; // r2
  int *v24; // r3
  int *v25; // r0
  int *v26; // r6
  int *v27; // lr
  int *v28; // r12
  int *v29; // r2
  unsigned int v30; // r0
  unsigned __int8 v31; // r2
  int v32; // r1
  int v33; // r0
  int v34; // r1
  unsigned int v35; // r2
  unsigned int v36; // r3
  int v37; // r12
  bool v38; // zf
  int v39; // r0
  int v40; // r6
  unsigned int v41; // r2
  unsigned int *v42; // r7
  int *v43; // lr
  unsigned int v44; // r8
  int v45; // r1
  int v46; // r2
  int v47; // r12
  int v48; // t1
  int v49; // r1
  unsigned int v50; // t1
  unsigned int v51; // r7
  unsigned int v52; // r2
  int v53; // r2
  int v55; // r3
  unsigned int v56; // [sp+4h] [bp-20h]
  unsigned int v57; // [sp+8h] [bp-1Ch]
  int *v58; // [sp+Ch] [bp-18h]
  unsigned __int8 *v59; // [sp+10h] [bp-14h]
  unsigned int v60[3]; // [sp+18h] [bp-Ch] BYREF

  for ( i = v60; (char *)i - (char *)v60 != 8; i = (unsigned int *)((char *)i + 1) )
  {
    v55 = (unsigned __int8)(2 * *a3);
    *(_BYTE *)i = v55;
    if ( v55 )
      ++a3;
  }
  v8 = bswap32(v60[0]);
  v9 = bswap32(v60[1]);
  v10 = &a1[v8 >> 25];
  v11 = &a1[(v8 >> 17) & 0x7F];
  v12 = &a1[v9 >> 25];
  v13 = &a1[(unsigned __int16)v8 >> 9];
  v14 = &a1[(unsigned __int8)v8 >> 1];
  v15 = &a1[(v9 >> 17) & 0x7F];
  v16 = &a1[(unsigned __int16)v9 >> 9];
  v17 = &a1[(unsigned __int8)v9 >> 1];
  v18 = a1 + 40;
  v56 = v10[4168] | v12[4680] | v11[4296] | v13[4424] | v14[4552] | v15[4808] | v16[4936] | v17[5064];
  v19 = v10[5192];
  v20 = 0;
  v57 = v19 | v12[5704] | v11[5320] | v13[5448] | v14[5576] | v15[5832] | v16[5960] | v17[6088];
  v59 = (unsigned __int8 *)&unk_6BFB2;
  do
  {
    v20 += *++v59;
    v21 = (v56 >> (28 - v20)) | (v56 << v20);
    v22 = &a1[(v21 >> 14) & 0x7F];
    v58 = &a1[(v21 >> 7) & 0x7F];
    v23 = (v57 >> (28 - v20)) | (v57 << v20);
    v24 = &a1[(v21 >> 21) & 0x7F];
    v25 = &a1[v21 & 0x7F];
    v26 = &a1[(v23 >> 21) & 0x7F];
    v27 = &a1[(v23 >> 14) & 0x7F];
    v28 = &a1[(v23 >> 7) & 0x7F];
    v29 = &a1[v23 & 0x7F];
    *v18++ = v25[6600] | v29[7112] | v24[6216] | v22[6344] | v58[6472] | v26[6728] | v27[6856] | v28[6984];
    v18[15] = v25[7624] | v29[8136] | v24[7240] | v22[7368] | v58[7496] | v26[7752] | v27[7880] | v28[8008];
  }
  while ( a1 + 56 != v18 );
  sub_5EDC8(a4[1]);
  v30 = sub_5EDC8(*a4);
  *a2 = v31;
  v33 = v30 | (v32 << 6);
  v34 = 1;
  if ( a4[1] )
    v31 = a4[1];
  a2[1] = v31;
  v35 = 0x800000;
  a1[1] = 0;
  v36 = 24;
  do
  {
    v37 = a1[1];
    v38 = (v33 & v34) == 0;
    v34 *= 2;
    if ( !v38 )
      v37 |= v35;
    v35 >>= 1;
    if ( !v38 )
      a1[1] = v37;
    --v36;
  }
  while ( v36 );
  v40 = 25;
  v41 = 0;
  do
  {
    v42 = (unsigned int *)(a1 + 56);
    v43 = a1 + 40;
    v44 = v41;
    while ( 1 )
    {
      v45 = (v36 << 23) & 0x800000
          | (v36 >> 9) & 0x7C0000
          | (v36 >> 11) & 0x3F000
          | (v36 >> 13) & 0xFC0
          | (v36 >> 15) & 0x3F;
      v46 = (v36 << 7) & 0xFC0000
          | (32 * v36) & 0x3F000
          | (v36 >> 31)
          | (8 * (_WORD)v36) & 0xFC0
          | (2 * (_BYTE)v36) & 0x3E;
      v47 = (v45 ^ v46) & a1[1];
      v48 = *v43++;
      v49 = v45 ^ v48;
      v50 = *v42++;
      v39 = *a1;
      v41 = (a1[*(unsigned __int8 *)(v39 + ((v49 ^ (unsigned int)v47) >> 12) + 64) + 8264]
           | a1[*(unsigned __int8 *)(v39 + ((v49 ^ v47) & 0xFFF) + 4160) + 8520]
           | a1[*(unsigned __int8 *)(v39 + ((v47 ^ v46 ^ v50) >> 12) + 8256) + 8776]
           | a1[*(unsigned __int8 *)(v39 + ((v47 ^ v46 ^ v50) & 0xFFF) + 12352) + 9032])
          ^ v44;
      v44 = v36;
      if ( v43 == a1 + 56 )
        break;
      v36 = v41;
    }
    --v40;
  }
  while ( v40 );
  v51 = a1[HIBYTE(v41) + 72]
      | a1[(unsigned __int8)v41 + 840]
      | a1[HIBYTE(v36) + 1096]
      | a1[(unsigned __int8)v36 + 1864]
      | a1[BYTE2(v41) + 328]
      | a1[BYTE1(v41) + 584]
      | a1[BYTE2(v36) + 1352]
      | a1[BYTE1(v36) + 1608];
  sub_5EE14((int)(a2 + 2), v51 >> 8);
  sub_5EE14((int)(a2 + 6), HIWORD(v52) | (v51 << 16));
  sub_5EE14((int)(a2 + 10), v53 << 8);
  a2[13] = 0;
  return a2;
}
// 5F850: variable 'v31' is possibly undefined
// 5F854: variable 'v32' is possibly undefined
// 5FAC0: variable 'v52' is possibly undefined
// 5FAD4: variable 'v53' is possibly undefined

//----- (0005FB14) --------------------------------------------------------
int __fastcall sub_5FB14(int a1, int a2)
{
  __pid_t v4; // r4
  int v5; // r1
  int v6; // r2
  int v7; // r3
  char v8; // r0
  _BYTE *v9; // r2
  unsigned int v10; // r3
  char v11; // r0
  int v12; // r2
  int v13; // r1

  v4 = getpid();
  v7 = v4 + sub_187B0(v4, v5, v6);
  do
  {
    v8 = sub_5ED54((unsigned int)(1664525 * v7 + 1013904223) >> 16);
    *v9 = v8;
    v11 = sub_5ED54(v10 >> 22);
    *(_BYTE *)(v12 - 1) = v11;
  }
  while ( v12 != v13 );
  *(_BYTE *)(a1 + 2 * a2) = 0;
  return v7;
}
// 5FB2C: variable 'v5' is possibly undefined
// 5FB2C: variable 'v6' is possibly undefined
// 5FB40: variable 'v7' is possibly undefined
// 5FB4C: variable 'v9' is possibly undefined
// 5FB50: variable 'v10' is possibly undefined
// 5FB5C: variable 'v12' is possibly undefined
// 5FB60: variable 'v13' is possibly undefined

//----- (0005FB7C) --------------------------------------------------------
int __fastcall sub_5FB7C(_BYTE *a1, const char *a2)
{
  int v3; // r5
  int v4; // r1
  int v5; // r0
  char v6; // r3

  if ( (*(unsigned __int8 *)a2 | 0x20) == 0x64 )
  {
    v3 = (int)a1;
    v4 = 1;
  }
  else
  {
    *a1 = 36;
    a1[1] = 49;
    v3 = (int)(a1 + 3);
    a1[2] = 36;
    if ( (*(unsigned __int8 *)a2 | 0x20) == 0x73 )
    {
      v5 = strcasecmp(a2, "sha512");
      v4 = 8;
      if ( v5 )
        v6 = 53;
      else
        v6 = 54;
      a1[1] = v6;
    }
    else
    {
      v4 = 4;
    }
  }
  sub_5FB14(v3, v4);
  return v3;
}

//----- (0005FBFC) --------------------------------------------------------
void *__fastcall sub_5FBFC(char *a1, char *a2, int a3)
{
  int v4; // r3
  char *v5; // r0
  void *v6; // r0
  void *v7; // r4
  _BYTE *v9; // r0
  int i; // r3
  char *v11; // r9
  unsigned int j; // r12
  unsigned int v13; // r1
  int v14; // r6
  unsigned int v15; // lr
  char *v16; // r6
  char v17; // r2
  char v18; // r2
  int k; // r3
  int *v20; // r4
  int *v21; // r3
  _BYTE *v22; // r1
  int m; // r3
  int n; // r3
  int *v25; // r2
  int *v26; // r7
  int ii; // r3
  int *v28; // r10
  int v29; // r11
  int jj; // r0
  int v31; // lr
  int v32; // r8
  int kk; // r12
  unsigned int v34; // r6
  int v35; // r6
  int v36; // r12
  _DWORD *v37; // r8
  int *v38; // r9
  int mm; // r12
  int v40; // r6
  int v41; // r10
  int v42; // lr
  int v43; // r0
  char *v44; // r0
  int v45; // r0
  int v46; // lr
  int v47; // r10
  int v48; // r6
  int v49; // r0
  char *v50; // r0
  int v51; // r0
  int nn; // r3
  int *v53; // r0
  int i1; // r3
  unsigned int v55; // r8
  bool v56; // zf
  int i2; // r2
  int v58; // r1
  int v59; // r2
  unsigned __int8 *v60; // r0
  int *v61; // [sp+4h] [bp-18h]
  int v62; // [sp+8h] [bp-14h]

  if ( *a2 != 36 )
    goto LABEL_11;
  v4 = (unsigned __int8)a2[1];
  if ( !a2[1] || a2[2] != 36 )
    goto LABEL_11;
  if ( v4 == 49 )
  {
    v5 = (char *)sub_174DC((unsigned __int8)a2[2]);
    v6 = sub_5EE50(v5, a1, a2);
    goto LABEL_6;
  }
  if ( (unsigned int)(v4 - 53) <= 1 )
  {
    v6 = sub_5F09C(a1, a2);
  }
  else
  {
LABEL_11:
    if ( !dword_7D76C )
    {
      v9 = sub_1748C(0x4040u);
      for ( i = 0; i != 4; ++i )
      {
        v11 = (char *)&unk_6BFEE + 64 * i;
        for ( j = 0; j != 64; ++j )
        {
          v17 = v11[j >> 1];
          v15 = 0;
          if ( (j & 1) == 0 )
            v17 *= 16;
          v18 = v17 & 0xF0;
          do
          {
            v13 = (unsigned __int8)v11[(v15 >> 1) + 32];
            v56 = (v15 & 1) == 0;
            v14 = (j << 6) | v15++;
            v16 = &v9[4096 * i + v14];
            if ( !v56 )
              v13 >>= 4;
            v16[64] = v18 | v13 & 0xF;
          }
          while ( v15 != 64 );
        }
      }
      for ( k = 0; k != 64; ++k )
        v9[k] = byte_6BF03[k] - 1;
      dword_7D76C = (int)v9;
    }
    v20 = (int *)dword_7D770;
    v62 = dword_7D76C;
    if ( !dword_7D770 )
      v20 = (int *)sub_1748C(0x9120u);
    v61 = v20;
    *v20 = v62;
    v20[1] = 0;
    v21 = v20 + 24;
    do
    {
      *(_BYTE *)v21 = -1;
      v21 = (int *)((char *)v21 + 1);
    }
    while ( v21 != v20 + 40 );
    v22 = v20 + 10;
    for ( m = 0; m != 56; ++m )
    {
      *((_BYTE *)v20 + byte_6BF7B[m] + 95) = m;
      *v22++ = -1;
    }
    for ( n = 0; n != 48; ++n )
      *((_BYTE *)v20 + byte_6BF4B[n] + 39) = n;
    v25 = v20 + 4168;
    v26 = v20;
    for ( ii = 0; ii != 8; ++ii )
    {
      v28 = v26 + 71;
      v29 = v62 + 8 * ii;
      for ( jj = 0; jj != 256; ++jj )
      {
        v31 = 0;
        v32 = 0;
        for ( kk = 0; kk != 8; ++kk )
        {
          if ( (byte_6BF43[kk] & (unsigned __int8)jj) != 0 )
          {
            v34 = *(unsigned __int8 *)(v29 + kk);
            v35 = v34 <= 0x1F ? dword_640F4[v34] : v34 - 32;
            if ( *(unsigned __int8 *)(v29 + kk) <= 0x1Fu )
              v32 |= v35;
            else
              v35 = dword_640F4[v35];
            if ( *(unsigned __int8 *)(v29 + kk) > 0x1Fu )
              v31 |= v35;
          }
        }
        v28[1] = v32;
        ++v28;
        v36 = 4 * jj + 8480;
        *(int *)((char *)v26 + v36) = v31;
      }
      v37 = v25 + 2048;
      v38 = v25;
      for ( mm = 0; mm != 128; ++mm )
      {
        v40 = 0;
        v41 = 0;
        v42 = 0;
        do
        {
          if ( (byte_6BF43[++v42] & (unsigned __int8)mm) != 0 )
          {
            v43 = *((unsigned __int8 *)&v20[2 * ii + 23] + v42 + 3);
            if ( v43 != 255 )
            {
              v44 = (char *)&dword_640F4[v43];
              if ( *((unsigned __int8 *)&v20[2 * ii + 23] + v42 + 3) > 0x1Bu )
                v45 = *((_DWORD *)v44 - 24);
              else
                v45 = *((_DWORD *)v44 + 4);
              if ( *((unsigned __int8 *)&v20[2 * ii + 23] + v42 + 3) > 0x1Bu )
                v40 |= v45;
              else
                v41 |= v45;
            }
          }
        }
        while ( v42 != 7 );
        v46 = 0;
        *v38++ = v41;
        v47 = 0;
        v38[1023] = v40;
        v48 = 0;
        do
        {
          if ( (byte_6BF43[++v48] & (unsigned __int8)mm) != 0 )
          {
            v49 = *((unsigned __int8 *)v20 + 7 * ii + v48 + 39);
            if ( v49 != 255 )
            {
              v50 = (char *)&dword_640F4[v49];
              if ( *((unsigned __int8 *)v20 + 7 * ii + v48 + 39) > 0x17u )
                v51 = *((_DWORD *)v50 - 16);
              else
                v51 = *((_DWORD *)v50 + 8);
              if ( *((unsigned __int8 *)v20 + 7 * ii + v48 + 39) > 0x17u )
                v46 |= v51;
              else
                v47 |= v51;
            }
          }
        }
        while ( v48 != 7 );
        *v37++ = v47;
        v37[1023] = v46;
      }
      v25 += 128;
      v26 += 256;
    }
    for ( nn = 0; nn != 32; ++nn )
      *((_BYTE *)v20 + byte_6BFC3[nn] + 7) = nn;
    v53 = v20;
    do
    {
      for ( i1 = 0; i1 != 256; ++i1 )
      {
        v58 = 0;
        for ( i2 = 0; i2 != 8; ++i2 )
        {
          v55 = byte_6BF43[i2];
          v56 = (v55 & i1) == 0;
          if ( (v55 & i1) != 0 )
            v55 = (unsigned int)v53 + i2;
          if ( !v56 )
            v58 |= dword_640F4[*(unsigned __int8 *)(v55 + 8)];
        }
        v59 = 4 * i1 + 33056;
        *(int *)((char *)v61 + v59) = v58;
      }
      v53 += 2;
      v61 += 256;
    }
    while ( v61 != v20 + 1024 );
    dword_7D770 = (int)v20;
    v60 = (unsigned __int8 *)sub_174DC(0x15u);
    v6 = sub_5F5A4(v20, v60, a1, (unsigned __int8 *)a2);
  }
LABEL_6:
  v7 = v6;
  if ( a3 )
  {
    free((void *)dword_7D76C);
    free((void *)dword_7D770);
    dword_7D76C = 0;
    dword_7D770 = 0;
  }
  return v7;
}
// 640F4: using guessed type _DWORD dword_640F4[32];
// 6BF03: using guessed type _BYTE byte_6BF03[64];
// 6BF43: using guessed type unsigned __int8 byte_6BF43[8];
// 6BF4B: using guessed type unsigned __int8 byte_6BF4B[48];
// 6BF7B: using guessed type unsigned __int8 byte_6BF7B[55];
// 6BFC3: using guessed type unsigned __int8 byte_6BFC3[32];
// 7D76C: using guessed type int dword_7D76C;
// 7D770: using guessed type int dword_7D770;

//----- (00060068) --------------------------------------------------------
int __fastcall sub_60068(int fd, char *a2, int a3)
{
  char *v3; // r9
  _DWORD *v6; // r7
  ssize_t v7; // r0
  int v9; // r4
  int v10; // r6
  int i; // r11
  char v12; // r1
  char *v13; // r2
  char *v14; // r6
  _BYTE *v15; // r6
  unsigned int v16; // r6
  unsigned int v17; // r0
  _BOOL4 v18; // r3
  char *endptr; // [sp+Ch] [bp-10h] BYREF
  struct pollfd fds; // [sp+10h] [bp-Ch] BYREF

  v3 = a2 + 1;
  fds.events = 1;
  fds.fd = fd;
  v6 = (_DWORD *)dword_7DB94;
  while ( 1 )
  {
    *v6 = 0;
    v7 = (unsigned __int8)*a2;
    if ( !*a2 )
    {
      if ( a3 >= -1 && !sub_60AD4(&fds, 1u, a3) )
      {
        *v6 = 11;
        return -1;
      }
      v7 = sub_1800C(fd, v3, 1u);
      if ( v7 <= 0 )
        return -1;
    }
    v9 = v7 - 1;
    v10 = (unsigned __int8)a2[1];
    if ( v7 != 1 )
      memmove(v3, a2 + 2, v7 - 1);
    if ( v10 != 27 )
    {
      *a2 = v9;
      return (unsigned __int8)v10;
    }
    v15 = &unk_6C0EE;
LABEL_22:
    if ( *v15 )
      break;
    while ( v9 <= 14 )
    {
      if ( !sub_60AD4(&fds, 1u, 50) )
        goto LABEL_43;
      *v6 = 0;
      if ( sub_1800C(fd, &v3[v9], 1u) <= 0 )
        goto LABEL_16;
      if ( ++v9 > 4 && a2[1] == 91 && a2[v9] == 82 && (unsigned int)(unsigned __int8)a2[2] - 48 <= 9 )
      {
        v16 = strtoul(a2 + 2, &endptr, 10);
        if ( *endptr == 59 && (unsigned int)(unsigned __int8)endptr[1] - 48 <= 9 )
        {
          v17 = strtoul(endptr + 1, &endptr, 10);
          if ( *endptr == 82 )
          {
            v18 = v17 == 0;
            if ( !v16 )
              v18 = 1;
            if ( !v18 && (v16 | v17) < 0x8000 )
            {
              *a2 = 0;
              return -256;
            }
          }
        }
      }
    }
LABEL_24:
    *a2 = 0;
  }
  for ( i = 0; ; ++i )
  {
    if ( v9 > i )
      goto LABEL_19;
    if ( !sub_60AD4(&fds, 1u, 50) )
      goto LABEL_43;
    *v6 = 0;
    if ( sub_1800C(fd, &v3[v9], 1u) <= 0 )
      break;
    ++v9;
LABEL_19:
    v12 = v15[i];
    v13 = &v15[i];
    if ( a2[i + 1] != (v12 & 0x7F) )
    {
      do
        v14 = v13++;
      while ( *v14 >= 0 );
      v15 = v14 + 2;
      goto LABEL_22;
    }
    if ( v12 < 0 )
    {
      *a2 = 0;
      return v13[1];
    }
  }
LABEL_16:
  if ( *v6 != 11 )
  {
    *a2 = 0;
    return -1;
  }
LABEL_43:
  if ( v9 > 1 )
    goto LABEL_24;
  *a2 = v9;
  return 27;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00060320) --------------------------------------------------------
ssize_t __fastcall sub_60320(int fd, void *buf, size_t nbytes)
{
  ssize_t result; // r0
  struct pollfd v7; // [sp+0h] [bp-8h] BYREF

  v7.fd = fd;
  *(_DWORD *)&v7.events = buf;
  while ( 1 )
  {
    result = sub_1800C(fd, buf, nbytes);
    if ( result >= 0 || *(_DWORD *)dword_7DB94 != 11 )
      break;
    v7.fd = fd;
    v7.events = 1;
    sub_60AD4(&v7, 1u, -1);
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00060388) --------------------------------------------------------
void *__fastcall sub_60388(int a1, unsigned int *a2)
{
  unsigned int v2; // r9
  int v4; // r6
  char *v6; // r5
  unsigned int v7; // r8
  char *v8; // r4
  _BYTE *v10; // r3

  if ( a2 )
    v2 = *a2;
  v4 = 0;
  v6 = 0;
  if ( !a2 )
    v2 = 2147479552;
LABEL_5:
  v7 = v4 + 128;
  v6 = (char *)sub_174B4(v6, v4 + 128);
  v8 = &v6[v4];
  while ( sub_60320(a1, v8, 1u) == 1 )
  {
    v10 = v8 + 1;
    if ( *v8 == 10 )
      goto LABEL_13;
    if ( v7 >= v2 )
    {
      ++v8;
      goto LABEL_13;
    }
    v4 = v10 - v6;
    ++v8;
    if ( v10 - v6 == v7 )
      goto LABEL_5;
  }
  if ( v8 == v6 )
  {
    free(v8);
    return 0;
  }
LABEL_13:
  *v8 = 0;
  if ( a2 )
    *a2 = v8 - v6;
  return sub_174B4(v6, v8 + 1 - v6);
}
// 60414: variable 'v2' is possibly undefined

//----- (00060448) --------------------------------------------------------
ssize_t __fastcall sub_60448(ssize_t result, char *a2, size_t a3)
{
  if ( a3 )
  {
    result = sub_18050(result, a2, a3);
    if ( result != a3 )
      sub_16DBC("short read");
  }
  return result;
}

//----- (0006046C) --------------------------------------------------------
int sub_6046C()
{
  return 1;
}

//----- (00060474) --------------------------------------------------------
int __fastcall sub_60474(const char *a1, int a2, int (*a3)(), int (*a4)(), int a5, int a6)
{
  int (*v6)(); // r10
  int (*v7)(); // r7
  int v10; // r3
  bool v11; // zf
  int (*v12)(); // r3
  int v13; // r5
  DIR *v16; // r11
  int v17; // r0
  int v18; // r0
  char *v19; // r0
  char *ptr; // [sp+10h] [bp-74h]
  _BYTE v21[16]; // [sp+18h] [bp-6Ch] BYREF
  int v22; // [sp+28h] [bp-5Ch]

  v7 = sub_6046C;
  if ( a3 )
    v6 = a3;
  if ( !a3 )
    v6 = sub_6046C;
  if ( a4 )
    v7 = a4;
  if ( a6 )
    v10 = 2;
  else
    v10 = 6;
  v11 = (v10 & a2) == 0;
  v12 = sub_62DFC;
  if ( v11 )
    v12 = sub_62E14;
  if ( v12() < 0 )
  {
    if ( (a2 & 0x40) != 0 && *(_DWORD *)dword_7DB94 == 2 && !sub_62E14() )
      return ((int (__fastcall *)(const char *, _BYTE *, int, int))v6)(a1, v21, a5, a6);
    goto LABEL_14;
  }
  if ( (v22 & 0xF000) != 0x4000 )
    return ((int (__fastcall *)(const char *, _BYTE *, int, int))v6)(a1, v21, a5, a6);
  if ( (a2 & 1) == 0 )
    return ((int (__fastcall *)(const char *, _BYTE *, int, int))v7)(a1, v21, a5, a6);
  if ( (a2 & 8) == 0 )
  {
    v18 = ((int (__fastcall *)(const char *, _BYTE *, int, int))v7)(a1, v21, a5, a6);
    if ( !v18 )
    {
LABEL_14:
      v13 = a2 & 0x20;
      if ( (a2 & 0x20) != 0 )
        return 0;
      sub_16B80(a1);
      return v13;
    }
    if ( v18 == 2 )
      return 1;
  }
  v16 = opendir(a1);
  if ( !v16 )
    goto LABEL_14;
  v13 = 1;
  while ( 1 )
  {
    v17 = readdir64(v16);
    if ( !v17 )
      break;
    v19 = sub_57D64(a1, (_BYTE *)(v17 + 19));
    ptr = v19;
    if ( v19 )
    {
      if ( !sub_60474(v19, a2, v6, v7, a5, a6 + 1) )
        v13 = 0;
      free(ptr);
    }
  }
  closedir(v16);
  if ( (a2 & 8) != 0 && !((int (__fastcall *)(const char *, _BYTE *, int, int))v7)(a1, v21, a5, a6) )
    goto LABEL_14;
  return v13;
}
// 60528: variable 'v6' is possibly undefined
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7DB94: using guessed type int dword_7DB94;

//----- (0006065C) --------------------------------------------------------
int __fastcall sub_6065C(const char *a1, int a2)
{
  int v4; // r6
  DIR *v5; // r7
  int v6; // r0
  char *v7; // r0
  char *v8; // r8
  __int16 v10; // [sp+10h] [bp-58h]

  if ( sub_62E14() < 0 )
  {
    if ( *(_DWORD *)dword_7DB94 != 2 )
    {
      sub_16AF4("can't stat '%s'", a1);
      return -1;
    }
    if ( (a2 & 8) != 0 )
      return 0;
LABEL_6:
    sub_16AF4("can't remove '%s'", a1);
    return -1;
  }
  if ( (v10 & 0xF000) != 0x4000 )
  {
    if ( ((a2 & 8) != 0 || access(a1, 2) >= 0 || (v10 & 0xF000) == 0xA000 || !isatty(a2 & 8)) && (a2 & 0x10) == 0
      || (fprintf((FILE *)stderr, "%s: remove '%s'? ", (const char *)dword_7DB90, a1), sub_57700()) )
    {
      if ( unlink(a1) < 0 )
        goto LABEL_6;
      if ( (a2 & 0x1000) != 0 )
        printf("removed '%s'\n", a1);
    }
    return 0;
  }
  if ( (a2 & 4) == 0 )
  {
    sub_16DDC("'%s' is a directory", a1);
    return -1;
  }
  if ( (a2 & 8) == 0 && access(a1, 2) < 0 && isatty(a2 & 8) || (a2 & 0x10) != 0 )
  {
    fprintf((FILE *)stderr, "%s: descend into directory '%s'? ", (const char *)dword_7DB90, a1);
    if ( !sub_57700() )
      return 0;
  }
  v5 = opendir(a1);
  if ( !v5 )
    return -1;
  v4 = 0;
  while ( 1 )
  {
    v6 = readdir64(v5);
    if ( !v6 )
      break;
    v7 = sub_57D64(a1, (_BYTE *)(v6 + 19));
    v8 = v7;
    if ( v7 )
    {
      if ( sub_6065C(v7, a2) < 0 )
        v4 = -1;
      free(v8);
    }
  }
  if ( closedir(v5) < 0 )
  {
    sub_16AF4("can't close '%s'", a1);
    return -1;
  }
  if ( (a2 & 0x10) == 0
    || (fprintf((FILE *)stderr, "%s: remove directory '%s'? ", (const char *)dword_7DB90, a1), sub_57700()) )
  {
    if ( rmdir(a1) < 0 )
      goto LABEL_6;
    if ( (a2 & 0x1000) != 0 )
      printf("removed directory: '%s'\n", a1);
  }
  return v4;
}
// 606BC: variable 'v10' is possibly undefined
// 13F64: using guessed type int __fastcall readdir64(_DWORD);
// 7D608: using guessed type int stderr;
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;

//----- (000608E0) --------------------------------------------------------
int __fastcall sub_608E0(const char *a1, char *s)
{
  int v4; // r5
  size_t i; // r7
  char *v6; // r0

  v4 = 0;
  for ( i = strlen(s); ; a1 = &v6[i] )
  {
    v6 = strstr(a1, s);
    if ( !v6 )
      break;
    ++v4;
  }
  return v4;
}

//----- (00060924) --------------------------------------------------------
char *__fastcall sub_60924(const char *a1, int a2, char *s, const char *a4)
{
  size_t v8; // r9
  size_t v9; // r6
  size_t v10; // r0
  char *v11; // r7
  char *i; // r3
  char *v13; // r0
  char *v14; // r11
  int v16; // r5
  char *v17; // r0
  char *dest; // [sp+4h] [bp-8h]

  v8 = strlen(s);
  v9 = strlen(a4);
  v10 = strlen(a1);
  v11 = (char *)sub_1748C(v10 + 1 + a2 * (v9 - v8));
  for ( i = v11; ; i = (char *)memcpy(&v17[v16], a4, v9) + v9 )
  {
    dest = i;
    v13 = strstr(a1, s);
    v14 = v13;
    if ( !v13 )
      break;
    v16 = v13 - a1;
    v17 = (char *)memcpy(dest, a1, v13 - a1);
    a1 = &v14[v8];
  }
  strcpy(dest, a1);
  return v11;
}

//----- (000609D8) --------------------------------------------------------
void __fastcall __noreturn sub_609D8(const char *a1, int a2, int *a3)
{
  int *v5; // r6
  char *v6; // r3
  char *v7; // r0
  _DWORD *v8; // r5
  char *v9; // r1
  _DWORD *v10; // r2
  int v11; // t1

  v5 = a3;
  v6 = (char *)a3;
  do
  {
    v7 = v6;
    if ( !v6 )
      break;
    v6 += 4;
  }
  while ( *(_DWORD *)v7 );
  v8 = sub_1748C(((v7 - (char *)a3) & 0xFFFFFFFC) + 8);
  if ( a1 )
  {
    if ( !*a1 )
      a1 = "/bin/sh";
  }
  else
  {
    a1 = "/bin/sh";
  }
  v9 = sub_16A1C(a1);
  *v8 = v9;
  if ( a2 )
    *v8 = sub_177E4("-%s", v9);
  v8[1] = 0;
  if ( v5 )
  {
    v10 = v8;
    do
    {
      v11 = *v5++;
      v10[1] = v11;
      ++v10;
    }
    while ( v11 );
  }
  execv(a1, (char *const *)v8);
  sub_16B40("can't execute '%s'", a1);
}

//----- (00060AA0) --------------------------------------------------------
void *sub_60AA0()
{
  char *nodename; // r0
  struct utsname v2; // [sp+0h] [bp-18Ch] BYREF

  uname(&v2);
  if ( v2.nodename[0] )
    nodename = v2.nodename;
  else
    nodename = (char *)"?";
  return sub_1751C(nodename, 65);
}

//----- (00060AD4) --------------------------------------------------------
int __fastcall sub_60AD4(struct pollfd *fds, nfds_t nfds, int timeout)
{
  int v6; // r5

  while ( 1 )
  {
    v6 = poll(fds, nfds, timeout);
    if ( v6 >= 0 )
      break;
    if ( timeout > 0 )
      --timeout;
    if ( (*(_DWORD *)dword_7DB94 & 0xFFFFFFF7) != 4 )
    {
      sub_16AF4("poll");
      return v6;
    }
  }
  return v6;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00060B34) --------------------------------------------------------
char *__fastcall sub_60B34(char *result, const char *a2, int a3)
{
  size_t v3; // r2

  if ( a3 )
  {
    v3 = a3 - 1;
    result[v3] = 0;
    return strncpy(result, a2, v3);
  }
  return result;
}

//----- (00060B4C) --------------------------------------------------------
int __fastcall sub_60B4C(int result, int a2)
{
  int v2; // r1
  int v3; // t1

  if ( result != a2 )
  {
    v2 = a2 - 1;
    --result;
    do
    {
      v3 = *(unsigned __int8 *)++v2;
      *(_BYTE *)++result = v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00060B70) --------------------------------------------------------
char *__fastcall sub_60B70(const char *a1)
{
  _DWORD *v2; // r5
  char *result; // r0
  char *s1; // [sp+4h] [bp-4h] BYREF

  s1 = "/etc/securetty";
  v2 = sub_5DDC4((int)"/etc/securetty", (int (*)(void))sub_61C9C);
  while ( sub_5DE1C(v2, &s1, 4653313, "# \t") && strcmp(s1, a1) )
    s1 = 0;
  sub_5DDEC((int)v2);
  result = s1;
  if ( s1 )
    return (char *)1;
  return result;
}

//----- (00060C00) --------------------------------------------------------
const char *__fastcall sub_60C00(const char *result, char a2, int a3)
{
  const char *v3; // r5
  const char *v6; // r0
  char *v7; // r6
  const char *v8; // r1

  v3 = result;
  if ( result )
  {
    if ( !*result )
      v3 = "/bin/sh";
  }
  else
  {
    v3 = "/bin/sh";
  }
  if ( (a2 & 0x10) == 0 )
  {
    result = (const char *)chdir(*(const char **)(a3 + 20));
    if ( result )
    {
      sub_16DDC("can't change directory to '%s'", *(const char **)(a3 + 20));
      v6 = "/tmp";
      if ( (a2 & 4) == 0 )
        v6 = "/";
      result = (const char *)sub_178FC(v6);
    }
  }
  if ( (a2 & 2) != 0 )
  {
    v7 = getenv("TERM");
    clearenv();
    if ( v7 )
      sub_17820("TERM", v7);
    if ( *(_DWORD *)(a3 + 8) )
      v8 = "/bin:/usr/bin";
    else
      v8 = "/sbin:/usr/sbin:/bin:/usr/bin";
    sub_17820("PATH", v8);
LABEL_17:
    sub_17820("USER", *(const char **)a3);
    sub_17820("LOGNAME", *(const char **)a3);
    goto LABEL_20;
  }
  if ( (a2 & 1) == 0 )
    return result;
  if ( *(_DWORD *)(a3 + 8) )
    goto LABEL_17;
LABEL_20:
  sub_17820("HOME", *(const char **)(a3 + 20));
  return (const char *)sub_17820("SHELL", v3);
}

//----- (00060D24) --------------------------------------------------------
_BYTE *__fastcall sub_60D24(_BYTE *a1)
{
  _BYTE *v1; // r3
  unsigned __int8 *i; // r2
  int v3; // r12
  int v4; // lr
  bool v5; // zf
  int v6; // lr
  bool v7; // zf
  int v8; // t1

  v1 = a1;
  for ( i = a1; ; ++i )
  {
    v3 = *i;
    if ( *v1 != 47 )
      goto LABEL_17;
    if ( v3 == 47 )
      goto LABEL_18;
    if ( v3 != 46 )
    {
LABEL_17:
      *++v1 = v3;
      goto LABEL_18;
    }
    v4 = i[1];
    v5 = v4 == 0;
    if ( i[1] )
      v5 = v4 == 47;
    if ( !v5 )
    {
      if ( v4 != 46 )
        goto LABEL_17;
      v6 = i[2];
      v7 = v6 == 0;
      if ( i[2] )
        v7 = v6 == 47;
      if ( !v7 )
        goto LABEL_17;
      if ( v1 > a1 )
      {
        do
          v8 = (unsigned __int8)*--v1;
        while ( v8 != 47 );
      }
      ++i;
    }
LABEL_18:
    if ( !i[1] )
      break;
  }
  if ( v1 == a1 || *v1 != 47 )
    ++v1;
  *v1 = 0;
  return v1;
}

//----- (00060DE0) --------------------------------------------------------
char *__fastcall sub_60DE0(char *a1)
{
  char *v1; // r4
  char *v4; // r5

  if ( *a1 == 47 )
  {
    v1 = sub_174F8(a1);
  }
  else
  {
    v4 = (char *)sub_624A4(0);
    v1 = sub_16998(v4, a1);
    free(v4);
  }
  sub_60D24(v1);
  return v1;
}

//----- (00060E30) --------------------------------------------------------
int __fastcall sub_60E30(int a1)
{
  int v1; // r4
  const char *v2; // r0
  int result; // r0

  v1 = a1;
  v2 = *(const char **)(a1 + 4);
  if ( v2 && !strcmp(v2, "--") )
    v1 += 4;
  result = *(_DWORD *)(v1 + 4);
  if ( !result || *(_DWORD *)(v1 + 8) )
    sub_162F0();
  return result;
}

//----- (00060E74) --------------------------------------------------------
unsigned __int8 *__fastcall sub_60E74(unsigned __int8 *a1)
{
  unsigned __int8 *result; // r0
  unsigned int v3; // t1
  unsigned int v4; // r1
  bool v5; // cc

  do
  {
    result = a1;
    v3 = *a1++;
    v4 = v3 - 9;
    v5 = v3 > 0x20;
    if ( v3 != 32 )
      v5 = v4 > 4;
  }
  while ( !v5 );
  return result;
}

//----- (00060E94) --------------------------------------------------------
unsigned __int8 *__fastcall sub_60E94(unsigned __int8 *a1)
{
  unsigned __int8 *result; // r0
  int v3; // r3
  int v4; // t1

  do
  {
    result = a1;
    v4 = *a1++;
    v3 = v4;
  }
  while ( (v4 & 0xDF) != 0 && (unsigned int)(v3 - 9) > 4 );
  return result;
}

//----- (00060EB8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_60EB8(unsigned __int8 *a1)
{
  unsigned __int8 *result; // r0

  result = sub_1684C(a1, (int)"/dev/");
  if ( !result )
    return a1;
  return result;
}

//----- (00060ED8) --------------------------------------------------------
int __fastcall sub_60ED8(int a1)
{
  int v1; // r3
  int result; // r0

  v1 = 0;
  while ( word_643FE[2 * v1] != a1 )
  {
    if ( ++v1 == 31 )
      return 0;
  }
  result = word_643FE[2 * v1 + 1];
  if ( (result & 0x8000) != 0 )
    return 200 * (result & 0x7FFF);
  return result;
}
// 643FE: using guessed type unsigned __int16 word_643FE[62];

//----- (00060F24) --------------------------------------------------------
int __fastcall sub_60F24(int a1)
{
  int v2; // r4
  int v3; // r5

  v2 = 0;
  while ( 1 )
  {
    v3 = word_643FE[2 * v2];
    if ( sub_60ED8(v3) == a1 )
      break;
    if ( ++v2 == 31 )
      return -1;
  }
  return v3;
}
// 643FE: using guessed type unsigned __int16 word_643FE[62];

//----- (00060F68) --------------------------------------------------------
unsigned int sub_60F68()
{
  unsigned int result; // r0

  result = sysconf(0);
  if ( result >= 0x4000000 )
    return 0x4000000;
  return result;
}

//----- (00060F80) --------------------------------------------------------
int sub_60F80()
{
  return sysconf(2);
}

//----- (00060F88) --------------------------------------------------------
char *__fastcall sub_60F88(char *a1)
{
  size_t v2; // r6
  char *v3; // r3
  size_t v4; // r5
  unsigned int v5; // t1
  unsigned int v6; // r1
  bool v7; // cc
  unsigned __int8 *v8; // r1
  char *result; // r0

  v2 = strlen(a1);
  v3 = &a1[v2];
  do
  {
    v4 = v3 - a1;
    if ( a1 == v3 )
    {
      v4 = 0;
      goto LABEL_9;
    }
    v5 = (unsigned __int8)*--v3;
    v6 = v5 - 9;
    v7 = v5 > 0x20;
    if ( v5 != 32 )
      v7 = v6 > 4;
  }
  while ( !v7 );
  v8 = sub_60E74((unsigned __int8 *)a1);
  if ( v8 != (unsigned __int8 *)a1 )
  {
    v4 -= v8 - (unsigned __int8 *)a1;
    memmove(a1, v8, v4);
  }
LABEL_9:
  result = &a1[v4];
  if ( v4 != v2 )
    a1[v4] = 0;
  return result;
}

//----- (00061000) --------------------------------------------------------
unsigned int __fastcall sub_61000(const char *a1)
{
  const char *v1; // r5
  unsigned int result; // r0
  _DWORD *v3; // r6
  bool v4; // zf
  int v5; // r4
  unsigned int v6; // r0
  bool v7; // zf
  unsigned int v8; // r0
  bool v9; // zf

  v1 = a1;
  result = sub_18990(a1, 0, (char *)0xA);
  v3 = (_DWORD *)dword_7DB94;
  v4 = result == 64;
  if ( result <= 0x40 )
    v4 = *(_DWORD *)dword_7DB94 == 0;
  if ( !v4 )
  {
    v5 = 0;
    if ( !strncasecmp(v1, "SIG", 3u) )
      v1 += 3;
    do
    {
      if ( !strcasecmp(v1, &aExit_0[7 * v5]) )
        return v5;
      ++v5;
    }
    while ( v5 != 33 );
    if ( !strncasecmp(v1, "RTMIN", 5u) )
    {
      if ( v1[5] )
      {
        if ( v1[5] != 43 )
          return -1;
        v6 = sub_18990(v1 + 6, 0, (char *)0xA);
        v7 = v6 == 32;
        if ( v6 <= 0x20 )
          v7 = *v3 == 0;
        if ( !v7 )
          return -1;
        return v6 + 32;
      }
      else
      {
        return 32;
      }
    }
    else
    {
      if ( strncasecmp(v1, "RTMAX", 5u) )
        return -1;
      if ( v1[5] )
      {
        if ( v1[5] != 45 )
          return -1;
        v8 = sub_18990(v1 + 6, 0, (char *)0xA);
        v9 = v8 == 32;
        if ( v8 <= 0x20 )
          v9 = *v3 == 0;
        if ( !v9 )
          return -1;
        return 64 - v8;
      }
      else
      {
        return 64;
      }
    }
  }
  return result;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00061144) --------------------------------------------------------
char *__fastcall sub_61144(unsigned int a1)
{
  if ( a1 <= 0x20 && aExit_0[7 * a1] )
    return &aExit_0[7 * a1];
  else
    return sub_16F8C(a1);
}

//----- (00061174) --------------------------------------------------------
int sub_61174()
{
  int i; // r4
  const char *v1; // r2

  for ( i = 1; i != 33; ++i )
  {
    v1 = &aExit_0[7 * i];
    if ( *v1 )
      printf("%2u) %s\n", i, v1);
  }
  return printf("%2u) %s\n", 64, "RTMAX");
}

//----- (000611D0) --------------------------------------------------------
int __fastcall sub_611D0(const char *a1, const char *a2, const char *a3)
{
  char *v5; // r0
  char *v6; // r5
  int v7; // r8
  char *v8; // r4
  size_t v9; // r0
  const char *v10; // r1
  size_t v11; // r10
  FILE *v12; // r6
  int v13; // r9
  int v14; // r7
  FILE *v16; // r9
  int v17; // r1
  int v18; // r2
  unsigned __int8 *v19; // r0
  char *v20; // r10
  unsigned __int8 *v21; // r0
  const char *v22; // r0
  unsigned int v23; // r0
  int v24; // r10
  int v25; // r10
  int v26; // r10
  char *ptr; // [sp+Ch] [bp-A0h]
  _DWORD *v28; // [sp+10h] [bp-9Ch]
  const char *v29; // [sp+10h] [bp-9Ch]
  int fd; // [sp+14h] [bp-98h]
  char *v31; // [sp+18h] [bp-94h]
  _DWORD v33[8]; // [sp+20h] [bp-8Ch] BYREF
  int v34; // [sp+50h] [bp-5Ch]
  __uid_t owner; // [sp+58h] [bp-54h]
  __gid_t group; // [sp+5Ch] [bp-50h]

  v31 = strstr(a1, "shadow");
  v5 = sub_17BE4(a1);
  v6 = v5;
  if ( v5 )
  {
    v8 = sub_177E4("%s+", v5);
    v9 = strlen(v8);
    v10 = "";
    v11 = v9 - 1;
    if ( a2 )
      v10 = a2;
    ptr = sub_177E4("%s:", v10);
    if ( v31 )
    {
      v12 = (FILE *)fopen64(v6, &unk_6C2FD);
      if ( !v12 )
      {
        v7 = 0;
LABEL_18:
        free(v8);
        free(v6);
        free(ptr);
        return v7;
      }
    }
    else
    {
      v12 = (FILE *)sub_61C78(v6, (int)&unk_6C2FD);
      if ( !v12 )
      {
        v7 = -1;
        goto LABEL_18;
      }
    }
    v13 = 30;
    fd = fileno_unlocked(v12);
    while ( 1 )
    {
      v14 = open64(v8, 193);
      v28 = (_DWORD *)dword_7DB94;
      if ( v14 >= 0 )
        break;
      if ( *(_DWORD *)dword_7DB94 == 17 )
      {
        usleep(0x186A0u);
        if ( --v13 )
          continue;
      }
      sub_16AF4("can't create '%s'", v8);
LABEL_13:
      v7 = -1;
      goto LABEL_14;
    }
    if ( !sub_62E08() )
    {
      fchmod(v14, v34 & 0x1FF);
      fchown(v14, owner, group);
    }
    *v28 = 0;
    v16 = sub_61CCC(v14);
    v8[v11] = 45;
    if ( unlink(v8) && *v28 != 2 || link(v6, v8) )
      sub_16AF4("warning: can't create backup copy '%s'", v8);
    v8[v11] = 43;
    v33[0] = 1;
    memset(&v33[2], 0, 16);
    if ( fcntl(fd, 13, v33) < 0 )
      sub_16AF4("warning: can't lock '%s'", v6);
    v7 = 0;
    LOWORD(v33[0]) = 2;
    while ( 1 )
    {
      v19 = sub_58D24(v12, v17, v18);
      v20 = (char *)v19;
      if ( !v19 )
        break;
      v21 = sub_1684C(v19, (int)ptr);
      if ( v21 )
      {
        if ( *(_BYTE *)dword_7DB90 == 112 )
        {
          v22 = (const char *)strchrnul((const char *)v21, 58);
          if ( v31 && *v22 == 58 )
          {
            v29 = (const char *)strchrnul(v22 + 1);
            v23 = time(0);
            fprintf(v16, "%s%s:%u%s\n", ptr, a3, v23 / 0x15180, v29);
          }
          else
          {
            fprintf(v16, "%s%s%s\n", ptr, a3, v22);
          }
          ++v7;
        }
      }
      else
      {
        fprintf(v16, "%s\n", v20);
      }
      free(v20);
    }
    fcntl(fd, 13, v33);
    *(_DWORD *)dword_7DB94 = 0;
    v24 = ferror_unlocked(v12);
    v25 = v24 | fflush(v16);
    v26 = v25 | fsync(v14);
    if ( v26 | fclose(v16) || rename(v8, v6) )
    {
      sub_62654();
      unlink(v8);
      goto LABEL_13;
    }
LABEL_14:
    fclose(v12);
    goto LABEL_18;
  }
  return -1;
}
// 613D4: variable 'v17' is possibly undefined
// 613D4: variable 'v18' is possibly undefined
// 13624: using guessed type int strchrnul(const char *, ...);
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 13FF4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 7DB90: using guessed type int dword_7DB90;
// 7DB94: using guessed type int dword_7DB94;

//----- (0006156C) --------------------------------------------------------
int sub_6156C()
{
  int result; // r0
  int v1; // r0

  result = access("/var/run/utmp", 6);
  if ( result == -1 )
  {
    v1 = open64("/var/run/utmp", 65);
    return close(v1);
  }
  return result;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (000615A0) --------------------------------------------------------
int __fastcall sub_615A0(__pid_t a1, __int16 a2, unsigned __int8 *a3, const char *a4, const char *a5)
{
  unsigned __int8 *v9; // r4
  size_t v10; // r6
  char *ut_id; // r5
  struct utmpx v13; // [sp+0h] [bp-180h] BYREF

  memset(&v13, 0, sizeof(v13));
  v13.ut_pid = a1;
  v13.ut_type = a2;
  v9 = sub_60EB8(a3);
  sub_60B34(v13.ut_line, (const char *)v9, 32);
  if ( a4 )
    sub_60B34(v13.ut_user, a4, 32);
  if ( a5 )
    sub_60B34(v13.ut_host, a5, 256);
  v13.ut_tv.tv_sec = time(0);
  if ( *v9 == 112 )
  {
    v13.ut_id[0] = 112;
    v10 = 3;
    ut_id = &v13.ut_id[1];
  }
  else
  {
    v10 = 4;
    ut_id = v13.ut_id;
  }
  if ( strlen((const char *)v9) > 3 )
    v9 += 3;
  strncpy(ut_id, (const char *)v9, v10);
  sub_6156C();
  setutxent();
  pututxline(&v13);
  endutxent();
  return updwtmpx("/var/log/wtmp", &v13);
}
// 13F1C: using guessed type int __fastcall updwtmpx(_DWORD, _DWORD);

//----- (00061694) --------------------------------------------------------
void __fastcall sub_61694(__pid_t a1, int a2, unsigned __int8 *a3, const char *a4, const char *a5)
{
  struct utmpx *v9; // r0
  struct utmpx *v10; // r4
  int ut_type; // r2
  unsigned __int8 *v12; // r0
  struct utmpx dest; // [sp+8h] [bp-184h] BYREF

  sub_6156C();
  setutxent();
  while ( 1 )
  {
    v9 = getutxent();
    v10 = v9;
    if ( !v9 )
    {
      if ( a2 == 8 )
        endutxent();
      else
        sub_615A0(a1, a2, a3, a4, a5);
      return;
    }
    if ( v9->ut_pid == a1 )
    {
      if ( v9->ut_id[0] )
      {
        ut_type = v9->ut_type;
        if ( (unsigned __int16)(ut_type - 5) <= 3u )
          break;
      }
    }
  }
  if ( ut_type >= a2 )
    memset(v9->ut_host, 0, sizeof(v9->ut_host));
  memcpy(&dest, v10, sizeof(dest));
  dest.ut_type = a2;
  if ( a3 )
  {
    v12 = sub_60EB8(a3);
    sub_60B34(dest.ut_line, (const char *)v12, 32);
  }
  if ( a4 )
    sub_60B34(dest.ut_user, a4, 32);
  if ( a5 )
    sub_60B34(dest.ut_host, a5, 256);
  dest.ut_tv.tv_sec = time(0);
  pututxline(&dest);
  endutxent();
  updwtmpx("/var/log/wtmp", &dest);
}
// 13F1C: using guessed type int __fastcall updwtmpx(_DWORD, _DWORD);

//----- (000617C8) --------------------------------------------------------
void __fastcall sub_617C8(__pid_t a1)
{
  sub_61694(a1, 8, 0, 0, 0);
}

//----- (000617E8) --------------------------------------------------------
_BYTE *__fastcall sub_617E8(_BYTE *result, int a2, int a3, int a4)
{
  int v4; // r1
  _BYTE *v5; // r1
  unsigned int v6; // lr
  unsigned int v7; // r12
  unsigned int v8; // r4
  _BYTE *v9; // r1

  v4 = a2 + 3;
  if ( a3 > 0 )
  {
    do
    {
      a3 -= 3;
      if ( a3 == -2 )
      {
        v6 = 0;
        v7 = 0;
      }
      else
      {
        v7 = *(unsigned __int8 *)(v4 - 2);
        if ( a3 == -1 )
          v6 = 0;
        else
          v6 = *(unsigned __int8 *)(v4 - 1);
      }
      v8 = *(unsigned __int8 *)(v4 - 3);
      result += 4;
      v4 += 3;
      *(result - 4) = *(_BYTE *)(a4 + (v8 >> 2));
      *(result - 3) = *(_BYTE *)(a4 + ((16 * *(_BYTE *)(v4 - 6)) & 0x30) + (v7 >> 4));
      *(result - 2) = *(_BYTE *)(a4 + ((4 * (_BYTE)v7) & 0x3C) + (v6 >> 6));
      *(result - 1) = *(_BYTE *)(a4 + (v6 & 0x3F));
    }
    while ( a3 > 0 );
    *result = 0;
    v9 = &result[a3];
    while ( result != v9 )
      *--result = *(_BYTE *)(a4 + 64);
  }
  else
  {
    *result = 0;
    v5 = &result[a3];
    while ( result != v5 )
      *--result = *(_BYTE *)(a4 + 64);
  }
  return result;
}

//----- (000618B0) --------------------------------------------------------
_BYTE *__fastcall sub_618B0(_BYTE **a1, _BYTE *a2, int a3)
{
  _BYTE *v4; // r4
  _BYTE *v5; // r6
  _BYTE *v6; // r11
  int v7; // r5
  _BYTE *v8; // r7
  _BYTE *v9; // r3
  char *v10; // r0
  int v11; // r0
  int v12; // r12
  _BYTE *v13; // r3
  int v14; // r2
  int v15; // r1
  _DWORD v17[2]; // [sp+4h] [bp-8h] BYREF

  v17[0] = a2;
  v17[1] = a3;
  v4 = *a1;
  v5 = a2;
LABEL_2:
  v6 = v5;
  v7 = 0;
LABEL_3:
  v8 = v6;
  while ( 1 )
  {
    v9 = v8++;
    if ( !*v9 )
      break;
    v6 = v8;
    v10 = strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", (unsigned __int8)*v9);
    if ( v10 )
    {
      v11 = v10 - "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      if ( v11 == 64 )
      {
        if ( v7 > 1 )
          goto LABEL_8;
        v13 = v4;
      }
      else
      {
        *((_BYTE *)v17 + v7) = v11;
        if ( ++v7 != 4 )
          goto LABEL_3;
LABEL_8:
        v12 = BYTE1(v17[0]);
        v13 = v4 + 1;
        v14 = (BYTE1(v17[0]) >> 4) | (4 * LOBYTE(v17[0]));
        *v4 = v14;
        if ( v7 != 2 )
        {
          if ( v7 == 4 )
            LOBYTE(v14) = HIBYTE(v17[0]);
          v13 = v4 + 2;
          if ( v7 == 4 )
          {
            v13 = v4 + 3;
            LOBYTE(v14) = v14 | (BYTE2(v17[0]) << 6);
          }
          v15 = (BYTE2(v17[0]) >> 2) | (16 * v12);
          if ( v7 == 4 )
            v4[2] = v14;
          v4[1] = v15;
        }
      }
      v4 = v13;
      v5 = v8;
      goto LABEL_2;
    }
  }
  *a1 = v4;
  if ( !v7 )
    return v9;
  return v5;
}

//----- (00061998) --------------------------------------------------------
int __fastcall sub_61998(FILE *stream, FILE *a2, __int16 a3)
{
  char v5; // r7
  int v6; // r6
  int v7; // r10
  int result; // r0
  int v9; // r5
  const char *v10; // r4
  char *v11; // r3
  char *v12; // [sp+4h] [bp-80h] BYREF
  char v13[52]; // [sp+8h] [bp-7Ch] BYREF
  char s1[72]; // [sp+3Ch] [bp-48h] BYREF

  v5 = a3;
  v6 = 0;
  v7 = a3 & 0x100;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v6 > 63 )
      {
LABEL_8:
        v9 = 0;
        goto LABEL_9;
      }
      result = getc_unlocked(stream);
      if ( v5 == result )
      {
        if ( !v6 )
          return result;
        break;
      }
      if ( result == -1 )
        break;
      if ( result <= 32 )
        goto LABEL_8;
      v11 = &s1[v6++ + 68];
      *(v11 - 68) = result;
    }
    v9 = 1;
LABEL_9:
    s1[v6] = 0;
    if ( v7 )
    {
      result = strcmp(s1, "====");
      if ( !result )
        return result;
    }
    v12 = v13;
    v10 = sub_618B0(&v12, s1, a3);
    result = fwrite(v13, v12 - v13, 1u, a2);
    if ( v9 )
      break;
    v6 = strlen(v10);
    memmove(s1, v10, v6);
  }
  if ( *v10 )
    sub_16DBC("truncated base64 input");
  return result;
}
// 61A34: variable 'a3' is possibly undefined

//----- (00061AB4) --------------------------------------------------------
__pid_t __fastcall sub_61AB4(const char **a1)
{
  __pid_t v1; // r3

  sub_177D8();
  v1 = vfork();
  if ( !v1 )
  {
    execvp(*a1, (char *const *)a1);
    exit(111);
  }
  return v1;
}
// 61B04: conditional instruction was optimized away because %var_4.4==0
// 7DB94: using guessed type int dword_7DB94;

//----- (00061B38) --------------------------------------------------------
int __fastcall sub_61B38(const char **a1)
{
  __pid_t v1; // r0
  int v2; // r1
  int v3; // r2

  v1 = sub_61AB4(a1);
  return sub_173EC(v1, v2, v3);
}
// 61B44: variable 'v2' is possibly undefined
// 61B44: variable 'v3' is possibly undefined

//----- (00061B48) --------------------------------------------------------
int __fastcall sub_61B48(char a1)
{
  int result; // r0
  int v3; // r4
  int v4; // r5

  if ( (a1 & 1) != 0 )
    sub_178FC("/");
  if ( (a1 & 2) != 0 )
  {
    close(0);
    close(1);
    close(2);
  }
  result = open64("/dev/null", 2);
  v3 = result;
  if ( result >= 0 )
    goto LABEL_8;
  for ( result = sub_175D8("/", 0); ; result = dup(v3) )
  {
    v3 = result;
LABEL_8:
    if ( (unsigned int)v3 > 1 )
      break;
  }
  if ( (a1 & 8) == 0 )
  {
    if ( sub_17B64()
      || (setsid(), dup2(v3, 0), dup2(v3, 1), result = dup2(v3, 2), (a1 & 0x10) != 0) && (result = sub_17B64()) != 0 )
    {
      exit(0);
    }
  }
  v4 = a1 & 4;
  while ( v3 > 2 )
  {
    result = close(v3);
    if ( !v4 )
      break;
    --v3;
  }
  return result;
}
// 13A00: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00061C40) --------------------------------------------------------
int sub_61C40()
{
  return sub_61B48(8);
}

//----- (00061C48) --------------------------------------------------------
FILE *__fastcall sub_61C48(unsigned int a1)
{
  bool v1; // zf
  int v2; // r0
  const char *v3; // r1
  FILE *result; // r0

  v1 = (a1 & 1) == 0;
  v2 = a1 >> 1;
  v3 = "w";
  if ( v1 )
    v3 = "r";
  result = fdopen(v2, v3);
  if ( !result )
    sub_17440();
  return result;
}

//----- (00061C78) --------------------------------------------------------
int __fastcall sub_61C78(const char *a1, int a2)
{
  int v3; // r4

  v3 = fopen64(a1, a2);
  if ( !v3 )
    sub_16B80(a1);
  return v3;
}
// 13FF4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00061C9C) --------------------------------------------------------
int __fastcall sub_61C9C(int a1)
{
  return fopen64(a1, "r");
}
// 13FF4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00061CA8) --------------------------------------------------------
int __fastcall sub_61CA8(const char *a1)
{
  return sub_17590(a1, (int)"r");
}

//----- (00061CB4) --------------------------------------------------------
int __fastcall sub_61CB4(int a1)
{
  return fopen64(a1, "w");
}
// 13FF4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00061CC0) --------------------------------------------------------
int __fastcall sub_61CC0(const char *a1)
{
  return sub_17590(a1, (int)"w");
}

//----- (00061CCC) --------------------------------------------------------
FILE *__fastcall sub_61CCC(int a1)
{
  return sub_61C48(2 * a1 + 1);
}

//----- (00061CD8) --------------------------------------------------------
int __fastcall sub_61CD8(int a1)
{
  if ( (char *)a1 == "standard input" || *(_BYTE *)a1 == 45 && !*(_BYTE *)(a1 + 1) )
    return stdin;
  else
    return sub_61C78((const char *)a1, (int)"r");
}
// 7D610: using guessed type int stdin;

//----- (00061D20) --------------------------------------------------------
int __fastcall sub_61D20(int a1)
{
  int result; // r0

  result = sub_61CD8(a1);
  if ( !result )
    sub_16E08();
  return result;
}

//----- (00061D34) --------------------------------------------------------
int __fastcall sub_61D34(int a1)
{
  if ( (char *)a1 == "standard input" || *(_BYTE *)a1 == 45 && !*(_BYTE *)(a1 + 1) )
    return 0;
  else
    return sub_1760C((const char *)a1, 0);
}

//----- (00061D6C) --------------------------------------------------------
int __fastcall sub_61D6C(int a1)
{
  int result; // r0

  result = sub_61D34(a1);
  if ( result < 0 )
    sub_16E08();
  return result;
}

//----- (00061D80) --------------------------------------------------------
unsigned __int64 __fastcall sub_61D80(const char *a1, int base, unsigned __int64 a3, unsigned __int64 a4, int a5)
{
  unsigned int v6; // r3
  int v7; // r8
  bool v8; // cc
  _BOOL4 v9; // r3
  _DWORD *v10; // r6
  int v11; // r10
  unsigned __int64 v12; // r4
  char *v13; // r9
  unsigned int v14; // r6
  __int64 v15; // r10
  __int64 v16; // r2
  int v17; // r0
  char *endptr; // [sp+14h] [bp-8h] BYREF

  v6 = *(unsigned __int8 *)a1;
  v7 = a5;
  if ( ((v6 - 43) & 0xFD) == 0 )
    goto LABEL_13;
  v8 = v6 > 0x20;
  if ( v6 != 32 )
    v8 = v6 - 9 > 4;
  v9 = !v8;
  if ( !v8
    || (v10 = (_DWORD *)dword_7DB94,
        v11 = *(_DWORD *)dword_7DB94,
        *(_DWORD *)dword_7DB94 = v9,
        v12 = strtoull(a1, &endptr, base),
        *v10)
    || (v13 = endptr, endptr == a1) )
  {
LABEL_13:
    sub_16DBC("invalid number '%s'", a1);
  }
  *v10 = v11;
  if ( a5 )
  {
    while ( 1 )
    {
      v14 = *(_DWORD *)(v7 + 4);
      if ( !v14 )
        goto LABEL_12;
      if ( !strcmp((const char *)v7, v13) )
        break;
      v7 += 8;
    }
    v15 = 0;
    if ( HIDWORD(v12) )
    {
      HIDWORD(v16) = 0;
      LODWORD(v16) = ((unsigned int)v12 * (unsigned __int64)v14) >> 32;
      v15 = (HIDWORD(v12) * (unsigned __int64)v14 + v16) >> 32 != 0;
    }
    if ( v15 )
LABEL_25:
      sub_16DBC("number %s is not in %llu..%llu range", a1, a3, a4);
    v17 = v14 * HIDWORD(v12);
    v12 = (unsigned int)v12 * (unsigned __int64)v14;
    HIDWORD(v12) += v17;
  }
  else
  {
LABEL_12:
    if ( *v13 )
      goto LABEL_13;
  }
  if ( v12 > a4 || v12 < a3 )
    goto LABEL_25;
  return v12;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00061EE8) --------------------------------------------------------
unsigned __int64 __fastcall sub_61EE8(const char *a1, int a2)
{
  return sub_61D80(a1, 10, 0, 0xFFFFFFFFFFFFFFFFLL, a2);
}

//----- (00061F14) --------------------------------------------------------
unsigned int __fastcall sub_61F14(const char *a1, int base, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v6; // r3
  int v9; // r5
  bool v10; // cc
  _BOOL4 v11; // r3
  _DWORD *v12; // r7
  int v13; // r11
  unsigned int v14; // r4
  char *v15; // r10
  _BOOL4 v16; // r3
  unsigned int v18; // r7
  char *endptr; // [sp+Ch] [bp-8h] BYREF

  v6 = *(unsigned __int8 *)a1;
  v9 = a5;
  if ( ((v6 - 43) & 0xFD) == 0 )
    goto LABEL_23;
  v10 = v6 > 0x20;
  if ( v6 != 32 )
    v10 = v6 - 9 > 4;
  v11 = !v10;
  if ( !v10 )
    goto LABEL_23;
  v12 = (_DWORD *)dword_7DB94;
  v13 = *(_DWORD *)dword_7DB94;
  *(_DWORD *)dword_7DB94 = v11;
  v14 = strtoul(a1, &endptr, base);
  if ( *v12 )
    goto LABEL_23;
  v15 = endptr;
  if ( endptr == a1 )
    goto LABEL_23;
  *v12 = v13;
  if ( !a5 )
  {
LABEL_12:
    if ( !*v15 )
      goto LABEL_13;
LABEL_23:
    sub_16DBC("invalid number '%s'", a1);
  }
  while ( 1 )
  {
    v18 = *(_DWORD *)(v9 + 4);
    if ( !v18 )
      goto LABEL_12;
    if ( !strcmp((const char *)v9, v15) )
      break;
    v9 += 8;
  }
  if ( !is_mul_ok(v14, v18) )
LABEL_22:
    sub_16DBC("number %s is not in %llu..%llu range", a1, (unsigned __int64)a3, (unsigned __int64)a4);
  v14 *= v18;
LABEL_13:
  v16 = v14 >= a3;
  if ( v14 > a4 )
    v16 = 0;
  if ( !v16 )
    goto LABEL_22;
  return v14;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00062034) --------------------------------------------------------
unsigned int __fastcall sub_62034(const char *a1, int a2, unsigned int a3, unsigned int a4)
{
  return sub_61F14(a1, a2, a3, a4, 0);
}

//----- (0006204C) --------------------------------------------------------
unsigned int __fastcall sub_6204C(const char *a1, unsigned int a2, unsigned int a3, int a4)
{
  return sub_61F14(a1, 10, a2, a3, a4);
}

//----- (0006206C) --------------------------------------------------------
unsigned int __fastcall sub_6206C(const char *a1, unsigned int a2, unsigned int a3)
{
  return sub_61F14(a1, 10, a2, a3, 0);
}

//----- (00062090) --------------------------------------------------------
unsigned int __fastcall sub_62090(const char *a1, int a2)
{
  return sub_61F14(a1, 10, 0, 0xFFFFFFFF, a2);
}

//----- (000620B0) --------------------------------------------------------
unsigned int __fastcall sub_620B0(const char *a1)
{
  return sub_62090(a1, 0);
}

//----- (000620B8) --------------------------------------------------------
signed int __fastcall sub_620B8(const char *a1, int a2, signed int a3, signed int a4, int a5)
{
  const char *v6; // r4
  unsigned int v8; // r3
  int v9; // r3
  signed int result; // r0
  _BOOL4 v11; // r3

  v6 = a1;
  if ( ((*a1 - 43) & 0xFD) != 0 )
  {
    v8 = 0x7FFFFFFF;
  }
  else
  {
    v9 = *(unsigned __int8 *)++a1;
    if ( v9 == 45 )
      v8 = 0x80000000;
    else
      v8 = 0x7FFFFFFF;
  }
  result = sub_61F14(a1, a2, 0, v8, a5);
  if ( *v6 == 45 )
    result = -result;
  v11 = result > a4;
  if ( result < a3 )
    v11 = 1;
  if ( v11 )
    sub_16DBC("number %s is not in %lld..%lld range", v6, (__int64)a3, (__int64)a4);
  return result;
}

//----- (00062154) --------------------------------------------------------
signed int __fastcall sub_62154(const char *a1, signed int a2, signed int a3)
{
  return sub_620B8(a1, 10, a2, a3, 0);
}

//----- (00062178) --------------------------------------------------------
signed int __fastcall sub_62178(const char *a1)
{
  return sub_620B8(a1, 10, 0x80000000, 0x7FFFFFFF, 0);
}

//----- (0006219C) --------------------------------------------------------
unsigned int __fastcall sub_6219C(const char *a1)
{
  return sub_6206C(a1, 0, 0x7FFFFFFFu);
}

//----- (000621A8) --------------------------------------------------------
int __fastcall sub_621A8(const char *a1)
{
  return (unsigned __int16)sub_6206C(a1, 0, 0xFFFFu);
}

//----- (000621C0) --------------------------------------------------------
_WORD *__fastcall sub_621C0(const char *a1, unsigned int a2, int a3)
{
  char *v6; // r0
  char *v7; // r9
  char *v8; // r7
  _BOOL4 v9; // r3
  _WORD *v10; // r4
  __int16 v11; // r5
  struct addrinfo *v12; // r7
  _DWORD *v14; // r0
  size_t ai_addrlen; // r2
  struct sockaddr *ai_addr; // r1
  char v17[4]; // [sp+0h] [bp-44h] BYREF
  struct addrinfo *pai; // [sp+4h] [bp-40h] BYREF
  struct addrinfo inp; // [sp+8h] [bp-3Ch] BYREF

  pai = 0;
  v6 = strrchr(a1, 58);
  v7 = v6;
  if ( !v6 )
  {
    v8 = (char *)a1;
    goto LABEL_8;
  }
  v8 = sub_60B34(v17, a1, v6 - a1 + 1);
  a2 = sub_18990(v7 + 1, 0, (char *)0xA);
  v9 = a2 >= 0x10000;
  if ( *(_DWORD *)dword_7DB94 )
    v9 = 1;
  if ( !v9 )
  {
LABEL_8:
    if ( inet_aton(v8, (struct in_addr *)&inp) )
    {
      v10 = sub_174DC(0x14u);
      *(_DWORD *)v10 = 16;
      v10[2] = 2;
      *((_DWORD *)v10 + 2) = inp.ai_flags;
    }
    else
    {
      memset(&inp.ai_protocol, 0, 0x14u);
      *(_QWORD *)&inp.ai_family = 0x100000002LL;
      inp.ai_flags = a3 & 0xFFFFFFFD;
      if ( getaddrinfo(v8, 0, &inp, &pai) || (v12 = pai) == 0 )
      {
        sub_16DDC("bad address '%s'", a1);
        v10 = (_WORD *)(a3 & 2);
        if ( v10 )
LABEL_6:
          sub_16E08();
        goto LABEL_16;
      }
      v14 = sub_1748C(pai->ai_addrlen + 4);
      ai_addrlen = v12->ai_addrlen;
      v10 = v14;
      ai_addr = v12->ai_addr;
      *v14 = ai_addrlen;
      memcpy(v14 + 1, ai_addr, ai_addrlen);
    }
    v11 = __rev16(a2);
    if ( v10[2] == 2 )
      v10[3] = v11;
LABEL_16:
    if ( pai )
      freeaddrinfo(pai);
    return v10;
  }
  sub_16DDC("bad port spec '%s'", a1);
  v10 = (_WORD *)(a3 & 2);
  if ( v10 )
    goto LABEL_6;
  return v10;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00062364) --------------------------------------------------------
char *__fastcall sub_62364(const struct sockaddr *a1, int a2)
{
  char v2; // r5
  char serv[16]; // [sp+10h] [bp-94h] BYREF
  char host[132]; // [sp+20h] [bp-84h] BYREF

  v2 = a2;
  if ( getnameinfo(a1, 0x10u, host, 0x80u, serv, 0x10u, a2 | 2) )
    return 0;
  if ( (v2 & 2) != 0 )
    return sub_174F8(host);
  return sub_177E4("%s:%s", host, serv);
}

//----- (000623D0) --------------------------------------------------------
int __fastcall sub_623D0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+Ch] [bp-4h] BYREF

  v5 = a4;
  return setsockopt(a1, a2, a3, &v5, 4u);
}

//----- (000623F4) --------------------------------------------------------
int __fastcall sub_623F4(int a1, int a2, int a3)
{
  return sub_623D0(a1, a2, a3, 1);
}

//----- (000623FC) --------------------------------------------------------
int __fastcall sub_623FC(int a1, int a2, int a3)
{
  return sub_623D0(a1, 1, a2, a3);
}

//----- (00062414) --------------------------------------------------------
int __fastcall sub_62414(int a1)
{
  return sub_623FC(a1, 2, 1);
}

//----- (0006241C) --------------------------------------------------------
void sub_6241C()
{
  JUMPOUT(0x6240C);
}
// 62420: control flows out of bounds to 6240C

//----- (00062424) --------------------------------------------------------
int __fastcall sub_62424(int a1, const char *a2)
{
  int v4; // r4
  char optval[36]; // [sp+8h] [bp-24h] BYREF

  sub_16EA8(optval, a2);
  v4 = setsockopt(a1, 1, 25, optval, 0x20u);
  if ( v4 )
    sub_16AF4("can't bind to interface %s", a2);
  return v4;
}

//----- (0006247C) --------------------------------------------------------
_WORD *__fastcall sub_6247C(const char *a1, unsigned int a2)
{
  return sub_621C0(a1, a2, 0);
}

//----- (00062484) --------------------------------------------------------
_WORD *__fastcall sub_62484(const char *a1, unsigned int a2)
{
  return sub_621C0(a1, a2, 2);
}

//----- (0006248C) --------------------------------------------------------
_WORD *__fastcall sub_6248C(const char *a1, unsigned int a2)
{
  return sub_621C0(a1, a2, 6);
}

//----- (00062494) --------------------------------------------------------
char *__fastcall sub_62494(const struct sockaddr *a1)
{
  return sub_62364(a1, 2);
}

//----- (0006249C) --------------------------------------------------------
char *__fastcall sub_6249C(const struct sockaddr *a1)
{
  return sub_62364(a1, 3);
}

//----- (000624A4) --------------------------------------------------------
void *__fastcall sub_624A4(void *a1)
{
  size_t v2; // r5
  size_t v4; // r1

  v2 = 128;
  while ( 1 )
  {
    v2 += 64;
    a1 = sub_174B4(a1, v2);
    if ( getcwd((char *)a1, v2) )
      break;
    if ( *(_DWORD *)dword_7DB94 != 34 )
    {
      free(a1);
      sub_16AF4("getcwd");
      return 0;
    }
  }
  v4 = strlen((const char *)a1) + 1;
  return sub_174B4(a1, v4);
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00062520) --------------------------------------------------------
struct hostent *__fastcall sub_62520(const char *a1)
{
  struct hostent *result; // r0

  result = gethostbyname(a1);
  if ( !result )
    sub_62624("%s", a1);
  return result;
}

//----- (00062544) --------------------------------------------------------
char *__fastcall sub_62544(void *a1, unsigned int a2, int a3)
{
  int v4; // r5
  char *v5; // r8
  unsigned int v6; // r4

  v4 = 1 << a2;
  if ( (((1 << a2) - 1) & a3) != 0 )
    return (char *)a1;
  v6 = a2 >> 8;
  v5 = (char *)sub_174B4(a1, v6 + (v4 + a3) * v6);
  memset(&v5[v6 * a3], 0, v6 + v4 * v6);
  return v5;
}

//----- (00062594) --------------------------------------------------------
char *__fastcall sub_62594(regex_t *a1, const char *a2, int a3)
{
  int v4; // r0
  int v5; // r5
  char *v6; // r4
  size_t v7; // r7

  v4 = regcomp(a1, a2, a3);
  v5 = v4;
  if ( !v4 )
    return 0;
  v7 = regerror(v4, a1, 0, 0);
  v6 = (char *)sub_1748C(v7);
  regerror(v5, a1, v6, v7);
  return v6;
}

//----- (000625E4) --------------------------------------------------------
char *__fastcall sub_625E4(regex_t *a1, const char *a2, int a3)
{
  char *result; // r0

  result = sub_62594(a1, a2, a3);
  if ( result )
    sub_16DBC("bad regex '%s': %s", a2, result);
  return result;
}

//----- (00062608) --------------------------------------------------------
int __fastcall sub_62608(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (00062614) --------------------------------------------------------
void __fastcall sub_62614(void *a1, size_t a2)
{
  qsort(a1, a2, 4u, (__compar_fn_t)sub_62608);
}

//----- (00062624) --------------------------------------------------------
void __noreturn sub_62624(const char *a1, ...)
{
  int *v1; // r0
  const char *v2; // r0
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  v1 = _h_errno_location();
  v2 = hstrerror(*v1);
  sub_16BA4(a1, (char *)varg_r1, v2);
  sub_16E08();
}

//----- (00062654) --------------------------------------------------------
void sub_62654()
{
  sub_16AF4(0);
}

//----- (0006265C) --------------------------------------------------------
int __fastcall sub_6265C(__uid_t *a1, char *s)
{
  const char *v2; // r6
  char *v4; // r0
  const char *v5; // r5
  const char *v6; // r1
  int v7; // r2
  __uid_t v8; // r0
  __uid_t pw_gid; // r7
  struct passwd *v10; // r0
  int v11; // r0
  struct group *v12; // r0
  struct passwd *v14; // r0
  _DWORD savedregs[8]; // [sp+0h] [bp-1Ch] BYREF

  v2 = s;
  v4 = strchr(s, 58);
  v5 = v4;
  if ( v4 )
  {
    v5 = v4 + 1;
    v6 = v2;
    v7 = v4 + 1 - v2;
    v2 = (const char *)savedregs;
    sub_60B34((char *)savedregs, v6, v7);
  }
  v8 = sub_18990(v2, 0, (char *)0xA);
  pw_gid = v8;
  if ( *(_DWORD *)dword_7DB94 )
  {
    v14 = getpwnam(v2);
    if ( !v14 )
      return 0;
    *a1 = v14->pw_uid;
    a1[1] = v14->pw_gid;
  }
  else
  {
    *a1 = v8;
    v10 = getpwuid(v8);
    if ( v10 )
      pw_gid = v10->pw_gid;
    a1[1] = pw_gid;
  }
  if ( !v5 )
    return 1;
  v11 = sub_18990(v5, 0, (char *)0xA);
  if ( !*(_DWORD *)dword_7DB94 )
  {
    a1[1] = v11;
    return 1;
  }
  v12 = getgrnam(v5);
  if ( v12 )
  {
    a1[1] = v12->gr_gid;
    return 1;
  }
  return 0;
}
// 7DB94: using guessed type int dword_7DB94;

//----- (00062768) --------------------------------------------------------
int __fastcall sub_62768(__uid_t *a1, char *a2)
{
  int result; // r0

  result = sub_6265C(a1, a2);
  if ( !result )
    sub_16DBC("unknown user/group %s", a2);
  return result;
}

//----- (0006278C) --------------------------------------------------------
__uid_t __fastcall sub_6278C(__uid_t *a1, char *s)
{
  char *v4; // r0
  __uid_t result; // r0

  a1[1] = -1;
  *a1 = -1;
  v4 = strchr(s, 46);
  if ( v4 )
  {
    *v4 = 58;
  }
  else
  {
    v4 = strchr(s, 58);
    if ( !v4 )
    {
      result = sub_57B74(s, (int (__fastcall *)(const char *))sub_57B54);
      *a1 = result;
      return result;
    }
  }
  if ( s == v4 )
  {
    result = sub_57B74(s + 1, (int (__fastcall *)(const char *))sub_57B64);
    a1[1] = result;
  }
  else
  {
    if ( !v4[1] )
      *v4 = 0;
    return sub_62768(a1, s);
  }
  return result;
}

//----- (00062B38) --------------------------------------------------------
int __fastcall sub_62B38(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x62B5E);
  return a1;
}
// 62B46: control flows out of bounds to 62B5E

//----- (00062B48) --------------------------------------------------------
int __fastcall sub_62B48(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (00062BA4) --------------------------------------------------------
int __fastcall sub_62BA4(signed __int64 a1, signed __int64 a2)
{
  bool v3; // cf
  unsigned __int64 v5; // [sp+8h] [bp-8h] BYREF

  if ( !a2 )
    JUMPOUT(0x62C74);
  if ( a1 < 0 )
  {
    v3 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v3;
    if ( a2 < 0 )
    {
      v3 = (_DWORD)a2 == 0;
      LODWORD(a2) = -(int)a2;
      HIDWORD(a2) -= 2 * HIDWORD(a2) + !v3;
      return sub_62CA4(a1, a2, &v5);
    }
    else
    {
      return -sub_62CA4(a1, a2, &v5);
    }
  }
  else if ( a2 < 0 )
  {
    v3 = (_DWORD)a2 == 0;
    LODWORD(a2) = -(int)a2;
    HIDWORD(a2) -= 2 * HIDWORD(a2) + !v3;
    return -sub_62CA4(a1, a2, &v5);
  }
  else
  {
    return sub_62CA4(a1, a2, &v5);
  }
}
// 62BC2: control flows out of bounds to 62C74

//----- (00062C44) --------------------------------------------------------
int __fastcall sub_62C44(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return sub_62CA4(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (00062C80) --------------------------------------------------------
unsigned int __fastcall sub_62C80(double a1)
{
  if ( a1 >= 0.0 )
    return sub_161C8(a1);
  HIDWORD(a1) ^= 0x80000000;
  return -sub_161C8(a1);
}

//----- (00062CA4) --------------------------------------------------------
int __fastcall sub_62CA4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}

//----- (00062DBC) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_7CF08;
  v8 = &off_7CF0C - &off_7CF08;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 7CF08: using guessed type _UNKNOWN *off_7CF08;
// 7CF0C: using guessed type _UNKNOWN *off_7CF0C;

//----- (00062DFC) --------------------------------------------------------
int sub_62DFC()
{
  return sub_140FC();
}

//----- (00062E08) --------------------------------------------------------
int sub_62E08()
{
  return j___fxstat64();
}

//----- (00062E14) --------------------------------------------------------
int sub_62E14()
{
  return sub_14178();
}

//----- (00062E20) --------------------------------------------------------
int __fastcall sub_62E20(char *path, __mode_t mode, __dev_t a3)
{
  __dev_t v4; // [sp+0h] [bp-8h] BYREF

  v4 = a3;
  return _xmknod(1, path, mode, &v4);
}

//----- (00062E3C) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1835 queued=1227 decompiled=1227 lumina nreq=0 worse=0 better=0
// ALL OK, 1227 function(s) have been successfully decompiled
