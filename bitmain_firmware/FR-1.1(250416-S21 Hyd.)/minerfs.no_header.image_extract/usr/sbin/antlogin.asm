;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2025 Hex-Rays, <support@hex-rays.com>           |
; |                      License info: 48-2137-ACAB-99                      |
; |                              elf <elv@ven>                              |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : 5FB202884793EA96CC9B4A3216F7EA921D78C776DFD10BD040A08FCEDE271F2B
; Input MD5    : A4B4A6437EC0036929B2C87D40539264
; Input CRC32  : AC994B33
; Compiler     : GNU C++

; File Name   : /home/danielsokil/Lab/HashSource/hashsource_antminer_S21x/bitmain_firmware/FR-1.1(250416-S21 Hyd.)/minerfs.no_header.image_extract/usr/sbin/antlogin
; Format      : ELF for ARM (Executable)
; Imagebase   : 10000
; Interpreter '/lib/ld-linux-armhf.so.3'
; Needed Library 'libc.so.6'
;
; Options     : EF_ARM_VFP_FLOAT
; EABI version: 5
;

; Processor       : ARM
; ARM architecture: ARMv7-A
; Target assembler: Generic assembler for ARM
; Byte sex        : Little endian


; Segment type: Pure code
AREA LOAD, CODE, ALIGN=0
; ORG 0x10000
CODE32
dword_10000 DCD 0x464C457F ; File format: \x7FELF
DCB 1                   ; File class: 32-bit
DCB 1                   ; Data encoding: little-endian
DCB 1                   ; File version
DCB 0                   ; OS/ABI: UNIX System V ABI
DCB 0                   ; ABI Version
DCB 0, 0, 0, 0, 0, 0, 0 ; Padding
DCW 2                   ; File type: Executable
DCW 0x28                ; Machine: ARM
DCD 1                   ; File version
DCD start+1             ; Entry point
DCD 0x34                ; PHT file offset
DCD 0x1148              ; SHT file offset
DCD 0x5000400           ; Processor-specific flags
DCW 0x34                ; ELF header size
DCW 0x20                ; PHT entry size
DCW 9                   ; Number of entries in PHT
DCW 0x28                ; SHT entry size
DCW 0x1A                ; Number of entries in SHT
DCW 0x19                ; SHT entry index for string table
; LOAD ends

; ELF32 Program Header
; PHT Entry 0

; Segment type: Pure code
AREA PHDR, CODE
; ORG 0x10034
CODE32
dword_10034 DCD 0x70000001 ; Type: EXIDX
DCD 0x470               ; File offset
DCD unk_10470           ; Virtual address
DCD 0x10470             ; Physical address
DCD 8                   ; Size in file image
DCD 8                   ; Size in memory image
DCD 4                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 1
DCD 6                   ; Type: PHDR
DCD 0x34                ; File offset
DCD dword_10034         ; Virtual address
DCD 0x10034             ; Physical address
DCD 0x120               ; Size in file image
DCD 0x120               ; Size in memory image
DCD 5                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 2
DCD 3                   ; Type: INTERP
DCD 0x154               ; File offset
DCD aLibLdLinuxArmh     ; Virtual address
DCD 0x10154             ; Physical address
DCD 0x19                ; Size in file image
DCD 0x19                ; Size in memory image
DCD 4                   ; Flags
DCD 1                   ; Alignment
; PHT Entry 3
DCD 1                   ; Type: LOAD
DCD 0                   ; File offset
DCD dword_10000         ; Virtual address
DCD 0x10000             ; Physical address
DCD 0x47C               ; Size in file image
DCD 0x47C               ; Size in memory image
DCD 5                   ; Flags
DCD 0x10000             ; Alignment
; PHT Entry 4
DCD 1                   ; Type: LOAD
DCD 0xF10               ; File offset
DCD off_20F10           ; Virtual address
DCD 0x20F10             ; Physical address
DCD 0x118               ; Size in file image
DCD 0x11C               ; Size in memory image
DCD 6                   ; Flags
DCD 0x10000             ; Alignment
; PHT Entry 5
DCD 2                   ; Type: DYNAMIC
DCD 0xF18               ; File offset
DCD stru_20F18          ; Virtual address
DCD 0x20F18             ; Physical address
DCD 0xE8                ; Size in file image
DCD 0xE8                ; Size in memory image
DCD 6                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 6
DCD 4                   ; Type: NOTE
DCD 0x170               ; File offset
DCD dword_10170         ; Virtual address
DCD 0x10170             ; Physical address
DCD 0x44                ; Size in file image
DCD 0x44                ; Size in memory image
DCD 4                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 7
DCD 0x6474E551          ; Type: STACK
DCD 0                   ; File offset
DCD 0                   ; Virtual address
DCD 0                   ; Physical address
DCD 0                   ; Size in file image
DCD 0                   ; Size in memory image
DCD 6                   ; Flags
DCD 0x10                ; Alignment
; PHT Entry 8
DCD 0x6474E552          ; Type: RO-AFTER
DCD 0xF10               ; File offset
DCD off_20F10           ; Virtual address
DCD 0x20F10             ; Physical address
DCD 0xF0                ; Size in file image
DCD 0xF0                ; Size in memory image
DCD 4                   ; Flags
DCD 1                   ; Alignment
; PHDR ends


; Segment type: Pure code
AREA LOAD, CODE, ALIGN=0
; ORG 0x10154
CODE32
aLibLdLinuxArmh DCB "/lib/ld-linux-armhf.so.3",0
DCB 0, 0, 0
; ELF Note Entry
dword_10170 DCD 4       ; Name Size
DCD 0x10                ; Desc Size
DCD 1                   ; Type: NT_GNU_ABI_TAG
aGnu DCB "GNU",0        ; Name
DCD 0, 3, 2, 0          ; ABI: Linux 3.2.0
; ELF Note Entry
DCD 4                   ; Name Size
DCD 0x14                ; Desc Size
DCD 3                   ; Type: NT_GNU_BUILD_ID
aGnu_0 DCB "GNU",0      ; Name
DCB 0x6F, 8, 0xD, 0x78, 0x4A, 0x61, 0x28 ; Desc
DCB 0x45, 0xF9, 0xF, 0x8F, 0xF3, 0xB0, 0x56
DCB 0x15, 0x2B, 0x83, 0xE4, 0xE0, 0x57
; ELF Hash Table
elf_hash_nbucket DCD 3
elf_hash_nchain DCD 5
elf_hash_bucket DCD 3, 2, 4
elf_hash_chain DCD 0, 0, 0, 0, 1
; ELF Symbol Table
Elf32_Sym <0>
Elf32_Sym <aExeclp - byte_1022C, 0, 0, \ ; "execlp"
           0x12, 0, 0>
Elf32_Sym <aLibcStartMain - byte_1022C, \ ; "__libc_start_main"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aGmonStart - byte_1022C, 0, \ ; "__gmon_start__"
           0, 0x20, 0, 0>
Elf32_Sym <aAbort - byte_1022C, 0, 0, \ ; "abort"
           0x12, 0, 0>
; ELF String Table
byte_1022C DCB 0
aLibcSo6 DCB "libc.so.6",0
aAbort DCB "abort",0
aExeclp DCB "execlp",0
aLibcStartMain DCB "__libc_start_main",0
aGmonStart DCB "__gmon_start__",0
aGlibc24 DCB "GLIBC_2.4",0
DCB 0
; ELF GNU Symbol Version Table
DCW 0
DCW 2                   ; execlp@@GLIBC_2.4
DCW 2                   ; __libc_start_main@@GLIBC_2.4
DCW 0                   ; local  symbol: __gmon_start__
DCW 2                   ; abort@@GLIBC_2.4
DCW 0
; ELF GNU Symbol Version Requirements
Elf32_Verneed <1, 1, \  ; "libc.so.6"
               aLibcSo6 - byte_1022C, \
               0x10, 0>
Elf32_Vernaux <0xD696914, 0, 2, \ ; "GLIBC_2.4"
               aGlibc24 - byte_1022C, 0>
; ELF REL Relocation Table
Elf32_Rel <0x2101C, 0x315> ; R_ARM_GLOB_DAT __gmon_start__
; ELF JMPREL Relocation Table
Elf32_Rel <0x2100C, 0x116> ; R_ARM_JUMP_SLOT execlp
Elf32_Rel <0x21010, 0x216> ; R_ARM_JUMP_SLOT __libc_start_main
Elf32_Rel <0x21014, 0x316> ; R_ARM_JUMP_SLOT __gmon_start__
Elf32_Rel <0x21018, 0x416> ; R_ARM_JUMP_SLOT abort
; LOAD ends


; Segment type: Pure code
AREA .init, CODE
; ORG 0x102C4
CODE32



; int init_proc()
EXPORT .init_proc
.init_proc
PUSH            {R3,LR}
BL              sub_10380
POP             {R3,PC}
; End of function .init_proc

; .init ends


; Segment type: Pure code
AREA .plt, CODE
; ORG 0x102D0
CODE32



; void sub_102D0()
sub_102D0
PUSH            {LR}
LDR             LR, =(_GLOBAL_OFFSET_TABLE_ - 0x102E0)
ADD             LR, PC, LR ; _GLOBAL_OFFSET_TABLE_
LDR             PC, [LR,#(off_21008 - 0x21000)]!
; End of function sub_102D0

off_102E0 DCD _GLOBAL_OFFSET_TABLE_ - 0x102E0
; [0000000C BYTES: COLLAPSED FUNCTION execlp]
; [0000000C BYTES: COLLAPSED FUNCTION __libc_start_main]
; [0000000C BYTES: COLLAPSED FUNCTION __gmon_start__]
; [0000000C BYTES: COLLAPSED FUNCTION abort]

; Segment type: Pure code
AREA .text, CODE
; ORG 0x10314
CODE32



; int main(int, char **, char **)
main

var_8= -8

MOVW            R1, #:lower16:aLogin ; "login"
PUSH            {R4,LR}
MOVT            R1, #:upper16:aLogin ; "login"
SUB             SP, SP, #8
MOV             R4, #0
MOVW            R3, #:lower16:aRoot ; "root"
MOVW            R2, #:lower16:aF ; "-f"
MOV             R0, R1  ; file
STR             R4, [SP,#8+var_8]
MOVT            R3, #:upper16:aRoot ; "root"
MOVT            R2, #:upper16:aF ; "-f"
BL              execlp
MOV             R0, R4
ADD             SP, SP, #8
POP             {R4,PC}
; End of function main

CODE16


; Attributes: noreturn

; void __noreturn start(void (*)(), int, int, int, ...)
EXPORT start
start

arg_0=  0

MOV.W           R11, #0
MOV.W           LR, #0
POP             {R1}    ; argc
MOV             R2, SP  ; ubp_av
PUSH            {R2}    ; stack_end
PUSH            {R0}    ; rtld_fini
LDR.W           R12, =(nullsub_1+1)
PUSH.W          {R12}   ; fini
LDR             R0, =main ; main
LDR             R3, =(init+1) ; init
BLX             __libc_start_main
BLX             abort
; End of function start

off_10374 DCD nullsub_1+1
off_10378 DCD main
off_1037C DCD init+1
CODE32



; int sub_10380()
sub_10380
LDR             R3, =(_GLOBAL_OFFSET_TABLE_ - 0x10390)
LDR             R2, =(__gmon_start___ptr_0 - 0x21000)
ADD             R3, PC, R3 ; _GLOBAL_OFFSET_TABLE_
LDR             R2, [R3,R2] ; __imp___gmon_start__
CMP             R2, #0
BXEQ            LR
B               __gmon_start__
; End of function sub_10380

off_1039C DCD _GLOBAL_OFFSET_TABLE_ - 0x10390
off_103A0 DCD __gmon_start___ptr_0 - 0x21000
CODE16



; char *sub_103A4()
sub_103A4
MOVW            R0, #:lower16:byte_21028
MOVW            R3, #:lower16:byte_21028
MOVT            R0, #:upper16:byte_21028
MOVT            R3, #:upper16:byte_21028
CMP             R3, R0
BEQ             locret_103C4
MOV             R3, #0
CBZ             R3, locret_103C4
BX              R3

locret_103C4
BX              LR
; End of function sub_103A4

ALIGN 4



; __int64 sub_103C8()
sub_103C8
MOVW            R0, #:lower16:byte_21028
MOVW            R1, #:lower16:byte_21028
MOVT            R0, #:upper16:byte_21028
MOVT            R1, #:upper16:byte_21028
SUBS            R1, R1, R0
ASRS            R1, R1, #2
ADD.W           R1, R1, R1,LSR#31
ASRS            R1, R1, #1
BEQ             locret_103F0
MOV             R3, #0
CBZ             R3, locret_103F0
BX              R3

locret_103F0
BX              LR
; End of function sub_103C8

ALIGN 4



; char *sub_103F4()
sub_103F4
PUSH            {R4,LR}
MOV             R4, #byte_21028
LDRB            R3, [R4]
CBNZ            R3, locret_1040A
BL              sub_103A4
MOVS            R3, #1
STRB            R3, [R4]

locret_1040A
POP             {R4,PC}
; End of function sub_103F4



; Attributes: thunk

sub_1040C
B               sub_103C8
; End of function sub_1040C

ALIGN 0x10



; int __fastcall init(int, int, int)
init
PUSH.W          {R3-R9,LR}
MOV             R7, R0
LDR             R6, =(off_20F14 - 0x10422)
MOV             R8, R1
MOV             R9, R2
LDR             R5, =(off_20F10 - 0x10428)
ADD             R6, PC  ; off_20F14
BLX             .init_proc
ADD             R5, PC  ; off_20F10
SUBS            R6, R6, R5
ASRS            R6, R6, #2
BEQ             locret_10440
MOVS            R4, #0

loc_1042E
ADDS            R4, #1
LDR.W           R3, [R5],#4
MOV             R2, R9
MOV             R1, R8
MOV             R0, R7
BLX             R3
CMP             R6, R4
BNE             loc_1042E

locret_10440
POP.W           {R3-R9,PC}
; End of function init

off_10444 DCD off_20F14 - 0x10422
off_10448 DCD off_20F10 - 0x10428
; [00000002 BYTES: COLLAPSED FUNCTION nullsub_1]
ALIGN 0x10
; .text ends


; Segment type: Pure code
AREA .fini, CODE
; ORG 0x10450
CODE32



; void term_proc()
EXPORT .term_proc
.term_proc
PUSH            {R3,LR}
POP             {R3,PC}
; End of function .term_proc

; .fini ends


; Segment type: Pure data
AREA .rodata, DATA, READONLY
; ORG 0x10458
DCB    1
DCB    0
DCB    2
DCB    0
aRoot DCB "root",0
ALIGN 4
aF DCB "-f",0
ALIGN 4
aLogin DCB "login",0
ALIGN 0x10
; .rodata ends


; Segment type: Pure data
AREA .ARM.exidx, DATA, READONLY
; ORG 0x10470
unk_10470 DCB 0xE0
DCB 0xFE
DCB 0xFF
DCB 0x7F ; 
DCB    1
DCB    0
DCB    0
DCB    0
; .ARM.exidx ends


; Segment type: Pure data
AREA .eh_frame, DATA, READONLY
; ORG 0x10478
DCB    0
DCB    0
DCB    0
DCB    0
; .eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
AREA .init_array, DATA
; ORG 0x20F10
off_20F10 DCD sub_1040C+1
; .init_array ends

; ELF Termination Function Table

; Segment type: Pure data
AREA .fini_array, DATA
; ORG 0x20F14
off_20F14 DCD sub_103F4+1
; .fini_array ends

; ELF Dynamic Information

; Segment type: Pure data
AREA LOAD, DATA, ALIGN=0
; ORG 0x20F18
stru_20F18 Elf32_Dyn <1, <1>> ; DT_NEEDED libc.so.6
Elf32_Dyn <0xC, <0x102C4>> ; DT_INIT
Elf32_Dyn <0xD, <0x10450>> ; DT_FINI
Elf32_Dyn <0x19, <0x20F10>> ; DT_INIT_ARRAY
Elf32_Dyn <0x1B, <4>>   ; DT_INIT_ARRAYSZ
Elf32_Dyn <0x1A, <0x20F14>> ; DT_FINI_ARRAY
Elf32_Dyn <0x1C, <4>>   ; DT_FINI_ARRAYSZ
Elf32_Dyn <4, <0x101B4>> ; DT_HASH
Elf32_Dyn <5, <0x1022C>> ; DT_STRTAB
Elf32_Dyn <6, <0x101DC>> ; DT_SYMTAB
Elf32_Dyn <0xA, <0x43>> ; DT_STRSZ
Elf32_Dyn <0xB, <0x10>> ; DT_SYMENT
Elf32_Dyn <0x15, <0>>   ; DT_DEBUG
Elf32_Dyn <3, <0x21000>> ; DT_PLTGOT
Elf32_Dyn <2, <0x20>>   ; DT_PLTRELSZ
Elf32_Dyn <0x14, <0x11>> ; DT_PLTREL
Elf32_Dyn <0x17, <0x102A4>> ; DT_JMPREL
Elf32_Dyn <0x11, <0x1029C>> ; DT_REL
Elf32_Dyn <0x12, <8>>   ; DT_RELSZ
Elf32_Dyn <0x13, <8>>   ; DT_RELENT
Elf32_Dyn <0x6FFFFFFE, <0x1027C>> ; DT_VERNEED
Elf32_Dyn <0x6FFFFFFF, <1>> ; DT_VERNEEDNUM
Elf32_Dyn <0x6FFFFFF0, <0x10270>> ; DT_VERSYM
Elf32_Dyn <0>           ; DT_NULL
ALIGN 0x40
; LOAD ends


; Segment type: Pure data
AREA .got, DATA
; ORG 0x21000
_GLOBAL_OFFSET_TABLE_ DCD stru_20F18
DCD 0
off_21008 DCD 0
execlp_ptr DCD __imp_execlp
__libc_start_main_ptr DCD __imp___libc_start_main
__gmon_start___ptr DCD __imp___gmon_start__
abort_ptr DCD __imp_abort
__gmon_start___ptr_0 DCD __imp___gmon_start__
; .got ends


; Segment type: Pure data
AREA .data, DATA
; ORG 0x21020
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
; .data ends


; Segment type: Uninitialized
AREA .bss, DATA, ALIGN=0
; ORG 0x21028
byte_21028 % 1
ALIGN 4
; .bss ends


; Segment type: Externs
; int execlp(const char *file, const char *arg, ...)
IMPORT __imp_execlp
; int __libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end)
IMPORT __imp___libc_start_main
; void abort(void)
IMPORT __imp_abort
IMPORT __imp___gmon_start__, WEAK

END start
