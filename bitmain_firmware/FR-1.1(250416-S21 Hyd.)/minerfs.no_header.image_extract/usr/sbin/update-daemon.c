/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_107A8();
// char *strstr(const char *haystack, const char *needle);
// int printf(const char *format, ...);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcpy(char *dest, const char *src);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int puts(const char *s);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int system(const char *command);
// int _gmon_start__(void); weak
// const unsigned __int16 **_ctype_b_loc(void);
// void exit(int status);
// size_t strlen(const char *s);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// void *memset(void *s, int c, size_t n);
// ssize_t write(int fd, const void *buf, size_t n);
// int access(const char *name, int type);
// void pthread_exit(void *retval);
// int shutdown(int fd, int how);
// int listen(int fd, int n);
// int sprintf(char *s, const char *format, ...);
// int socket(int domain, int type, int protocol);
// in_addr_t inet_addr(const char *cp);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
int __fastcall main(int a1, const char **a2, char **a3);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...); // idb
int sub_10BB0();
int deregister_tm_clones(); // idb
int register_tm_clones(); // idb
int sub_10C24();
int __fastcall sub_10C40(const char *a1);
void __fastcall __noreturn sub_10C8C(int *a1);
int __fastcall sub_10EB8(const char *a1);
int __fastcall init(int a1, int a2, int a3);
int nullsub_1(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN *off_21F08 = (_UNKNOWN *)0x10C3D; // weak
_UNKNOWN *off_21F0C = (_UNKNOWN *)0x10C25; // weak
int stderr; // weak
char byte_2209C; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0001079C) --------------------------------------------------------
int init_proc()
{
  return sub_10BB0();
}

//----- (000107A8) --------------------------------------------------------
void sub_107A8()
{
  JUMPOUT(0);
}
// 107B4: control flows out of bounds to 0

//----- (00010930) --------------------------------------------------------
int __fastcall main(int a1, const char **a2, char **a3)
{
  const char *v4; // r4
  int v5; // r4
  int v6; // r0
  __int16 v7; // r5
  int arg; // [sp+4h] [bp-2Ch] BYREF
  socklen_t addr_len; // [sp+8h] [bp-28h] BYREF
  pthread_t newthread; // [sp+Ch] [bp-24h] BYREF
  struct sockaddr addr; // [sp+10h] [bp-20h] BYREF
  struct sockaddr v13; // [sp+20h] [bp-10h] BYREF

  v4 = *a2;
  if ( strstr(*a2, "daemonc") )
    return sub_10EB8(a2[1]);
  if ( strstr(v4, "daemons") )
  {
    v5 = socket(2, 1, 0);
    if ( v5 == -1 )
      _assert_fail("sockfd_server != -1", "update-daemon.c", 0xA4u, "ProcessServer");
    addr.sa_family = 2;
    *(_WORD *)&addr.sa_data[6] = 0;
    *(_DWORD *)&addr.sa_data[8] = 0;
    *(_WORD *)&addr.sa_data[12] = 0;
    *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
    v6 = sub_10C40("22322");
    v7 = v6;
    printf("Will Listening To Port[%d]\r\n", v6);
    *(_WORD *)addr.sa_data = v7;
    if ( bind(v5, &addr, 0x10u) == -1 )
    {
      fwrite("bind error!\n", 1u, 0xCu, (FILE *)stderr);
      exit(1);
    }
    if ( listen(v5, 512) == -1 )
    {
      fwrite("listen error!\n", 1u, 0xEu, (FILE *)stderr);
      exit(1);
    }
    do
    {
      while ( 1 )
      {
        puts("waiting for new connection...");
        addr_len = 16;
        arg = accept(v5, &v13, &addr_len);
        if ( arg != -1 )
          break;
        fwrite("Accept error!\n", 1u, 0xEu, (FILE *)stderr);
      }
      puts("A new connection occurs!");
    }
    while ( pthread_create(&newthread, 0, (void *(*)(void *))sub_10C8C, &arg) != -1 );
    fwrite("pthread_create error!\n", 1u, 0x16u, (FILE *)stderr);
    if ( shutdown(v5, 1) == -1 )
      _assert_fail("ret != -1", "update-daemon.c", 0xCEu, "ProcessServer");
    puts("Server shuts down");
    return 0;
  }
  else
  {
    puts("Cannot Find Command!\r");
    return -1;
  }
}
// 22098: using guessed type int stderr;

//----- (00010B80) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_1,
    a1,
    va);
  abort();
}
// 10B8A: positive sp value 4 has been found
// 10B9C: variable 'v4' is possibly undefined
// 10FD0: using guessed type int init();
// 1100C: using guessed type int nullsub_1();

//----- (00010BB0) --------------------------------------------------------
int sub_10BB0()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 10840: using guessed type int _gmon_start__(void);

//----- (00010BD4) --------------------------------------------------------
int deregister_tm_clones()
{
  return 139412;
}

//----- (00010BF8) --------------------------------------------------------
int register_tm_clones()
{
  return 139412;
}

//----- (00010C24) --------------------------------------------------------
int sub_10C24()
{
  int result; // r0

  if ( !byte_2209C )
  {
    result = deregister_tm_clones();
    byte_2209C = 1;
  }
  return result;
}
// 2209C: using guessed type char byte_2209C;

//----- (00010C40) --------------------------------------------------------
int __fastcall sub_10C40(const char *a1)
{
  size_t v2; // r0
  size_t v3; // r12
  const char *v4; // r1
  const char *v5; // r2
  int i; // r0
  int v7; // t1
  int v8; // r3

  v2 = strlen(a1);
  v3 = v2 - 1;
  v4 = &a1[v2 - 2];
  v5 = a1 - 1;
  for ( i = 0; ; i = 10 * (v7 + v8) )
  {
    v8 = i - 48;
    if ( v5 == v4 )
      break;
    v7 = *(unsigned __int8 *)++v5;
  }
  return (unsigned __int8)a1[v3] + v8;
}

//----- (00010C8C) --------------------------------------------------------
void __fastcall __noreturn sub_10C8C(int *a1)
{
  int v2; // r6
  int v3; // r4
  const unsigned __int16 *v4; // r1
  _DWORD *v5; // r2
  int v6; // t1
  int v7; // r4
  size_t v8; // r0
  char v9[16]; // [sp+0h] [bp-810h] BYREF
  _DWORD buf[256]; // [sp+10h] [bp-800h] BYREF
  char command[1024]; // [sp+410h] [bp-400h] BYREF

  puts("New Thread!\r");
  memset(buf, 0, sizeof(buf));
  v2 = *a1;
  read(*a1, buf, 0x400u);
  printf("Recv:'%s'\r\n", (const char *)buf);
  if ( !access((const char *)buf, 0) )
  {
    v3 = LOBYTE(buf[0]);
    if ( LOBYTE(buf[0]) )
    {
      v4 = *_ctype_b_loc();
      v5 = buf;
      do
      {
        if ( (v4[v3] & 8) == 0 && v3 != 95 && (unsigned int)(v3 - 45) > 2 )
        {
          puts("Invalid client content.");
          close(v2);
          pthread_exit(0);
        }
        v6 = *((unsigned __int8 *)v5 + 1);
        v5 = (_DWORD *)((char *)v5 + 1);
        v3 = v6;
      }
      while ( v6 );
    }
    strcpy(command, "/usr/sbin/updateporc.sh ");
    memset(&command[25], 0, 0x3E7u);
    strcpy(&command[24], (const char *)buf);
    strcpy(v9, "Come On WUHAN");
    v7 = system(command);
    if ( v7 == -1 )
    {
      puts("system err!\r");
      strcpy(v9, "500");
    }
    else
    {
      printf("system status:[%d]\r\n", v7);
      if ( (v7 & 0x7F) != 0 )
      {
        printf("Other Exit Ret[%d]\r\n", BYTE1(v7));
        sprintf(v9, "6%d", BYTE1(v7));
      }
      else if ( BYTE1(v7) )
      {
        printf("Shell Execute Failed, Ret[%d]\r\n", BYTE1(v7));
        sprintf(v9, "%d", BYTE1(v7));
      }
      else
      {
        puts("Shell Exec Successfully!\r");
        strcpy(v9, "200");
      }
    }
    v8 = strlen(v9);
    write(v2, v9, v8 + 1);
    close(v2);
    pthread_exit(0);
  }
  printf("File does not exist: %s\n", (const char *)buf);
  close(v2);
  pthread_exit(0);
}

//----- (00010EB8) --------------------------------------------------------
int __fastcall sub_10EB8(const char *a1)
{
  int v2; // r0
  int v3; // r6
  size_t v4; // r0
  ssize_t v5; // r0
  int result; // r0
  struct sockaddr v7; // [sp+0h] [bp-410h] BYREF
  _DWORD buf[260]; // [sp+10h] [bp-400h] BYREF

  if ( !a1 )
    return -3;
  v7.sa_family = 2;
  *(_WORD *)&v7.sa_data[6] = 0;
  *(_DWORD *)&v7.sa_data[8] = 0;
  *(_WORD *)&v7.sa_data[12] = 0;
  *(_DWORD *)&v7.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)v7.sa_data = sub_10C40("22322");
  v2 = socket(2, 1, 0);
  v3 = v2;
  if ( v2 < 0 )
  {
    perror("socket err:");
    return -1;
  }
  if ( connect(v2, &v7, 0x10u) < 0 )
  {
    perror("connect err:");
    return -2;
  }
  v4 = strlen(a1);
  send(v3, a1, v4 + 1, 0);
  memset(buf, 0, 1024);
  v5 = recv(v3, buf, 0x400u, 0);
  if ( v5 <= 0 )
    return -3;
  *((_BYTE *)buf + v5) = 0;
  result = sub_10C40((const char *)buf);
  if ( result == 200 )
    return 0;
  return result;
}

//----- (00010FD0) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_21F08;
  v8 = &off_21F0C - &off_21F08;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 21F08: using guessed type _UNKNOWN *off_21F08;
// 21F0C: using guessed type _UNKNOWN *off_21F0C;

//----- (00011010) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=77 queued=13 decompiled=13 lumina nreq=0 worse=0 better=0
// ALL OK, 13 function(s) have been successfully decompiled
