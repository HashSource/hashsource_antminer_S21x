/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_B20C();
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int __fastcall BN_div(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void freeifaddrs(struct ifaddrs *ifa);
// int __fastcall if_nametoindex(_DWORD); weak
// int __fastcall EVP_DigestInit_ex(_DWORD, _DWORD, _DWORD); weak
// int __fastcall CMAC_Init(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigemptyset(sigset_t *set);
// char *strerror(int errnum);
// int __fastcall X509_add_ext(_DWORD, _DWORD, _DWORD); weak
// const __int32_t **_ctype_toupper_loc(void);
// int fileno(FILE *stream);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int munlockall(void);
// int mkdir(const char *path, __mode_t mode);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __fastcall CMAC_CTX_new(_DWORD); weak
// int __fastcall X509_sign(_DWORD, _DWORD, _DWORD); weak
// void abort(void);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int DSA_SIG_new(void); weak
// int __fastcall EVP_PKEY_get0_RSA(_DWORD); weak
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// void srand(unsigned int seed);
// int __fastcall ERR_get_error(_DWORD); weak
// struct tm *localtime(const time_t *timer);
// int __fastcall RAND_load_file(_DWORD, _DWORD); weak
// DIR *opendir(const char *name);
// int __fastcall BN_mod_mul(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
// int sysconf(int name);
// void pthread_exit(void *retval);
// void __fastcall __noreturn _longjmp_chk(_DWORD, _DWORD); weak
// int __fastcall EVP_MD_CTX_md(_DWORD); weak
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int __fastcall BN_CTX_free(_DWORD); weak
// int __fastcall X509_get_issuer_name(_DWORD); weak
// int __fastcall mkstemp64(_DWORD); weak
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int __fastcall X509_get_signature_nid(_DWORD); weak
// int __fastcall X509_EXTENSION_get_data(_DWORD); weak
// int _gmon_start__(void); weak
// void rewind(FILE *stream);
// int __fastcall DSA_SIG_set0(_DWORD, _DWORD, _DWORD); weak
// int __fastcall OBJ_nid2ln(_DWORD); weak
// int __fastcall RAND_seed(_DWORD, _DWORD); weak
// int __fastcall OBJ_obj2nid(_DWORD); weak
// int __fastcall strptime(_DWORD, _DWORD, _DWORD); weak
// int socketpair(int domain, int type, int protocol, int fds[2]);
// int rename(const char *old, const char *new);
// char *strncpy(char *dest, const char *src, size_t n);
// int fclose(FILE *stream);
// char *getpass(const char *prompt);
// char *fgets(char *s, int n, FILE *stream);
// char *getenv(const char *name);
// int _printf_chk(_DWORD, const char *, ...); weak
// double strtod(const char *nptr, char **endptr);
// int __fastcall X509_get_pubkey(_DWORD); weak
// int system(const char *command);
// char *strchr(const char *s, int c);
// int strcasecmp(const char *s1, const char *s2);
int __fastcall sub_B508(void (*lpfunc)(void *), void *obj, void *lpdso_handle); // idb
// int _cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
// int setlogmask(int mask);
// void *calloc(size_t nmemb, size_t size);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int __fastcall stpcpy(_DWORD); weak
// int __fastcall BN_bin2bn(_DWORD, _DWORD, _DWORD); weak
// int sched_get_priority_max(int algorithm);
// time_t mktime(struct tm *tp);
// int sched_setscheduler(__pid_t pid, int policy, const struct sched_param *param);
// int X509_EXTENSION_get_object(void); weak
// void *memset(void *s, int c, size_t n);
// const char *gai_strerror(int ecode);
// int __fastcall EVP_get_digestbyname(_DWORD); weak
// int uname(struct utsname *name);
// int sem_destroy(sem_t *sem);
// int __fastcall X509V3_EXT_print(_DWORD, _DWORD, _DWORD); weak
// int __fastcall BN_gcd(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall EVP_PKEY_base_id(_DWORD); weak
// void freeaddrinfo(struct addrinfo *ai);
// char *strrchr(const char *s, int c);
// int __fastcall d2i_PublicKey(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int setitimer(__itimer_which_t which, const struct itimerval *new, struct itimerval *old);
// int fsync(int fd);
// __pid_t setsid(void);
// int strerror_r(void); weak
// int __fastcall EVP_md5(_DWORD); weak
// int __fastcall CMAC_Update(_DWORD, _DWORD, _DWORD); weak
// void perror(const char *s);
// int __fastcall BN_num_bits(_DWORD); weak
// int __fastcall _strncpy_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall EVP_MD_size(_DWORD); weak
// int __fastcall EVP_MD_CTX_set_flags(_DWORD, _DWORD); weak
// __pid_t wait(void *stat_loc);
// int __fastcall CMAC_Final(_DWORD, _DWORD, _DWORD); weak
// double floor(double x);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int __fastcall _fxstat64(_DWORD, _DWORD, _DWORD); weak
// int __fastcall X509_getm_notAfter(_DWORD); weak
// int __fastcall canonicalize_file_name(_DWORD); weak
// int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD); weak
// int __fastcall d2i_DSA_SIG(_DWORD, _DWORD, _DWORD); weak
// int __fastcall i2d_DSAparams(_DWORD, _DWORD); weak
// double sqrt(double x);
// int OpenSSL_version_num(void); weak
// void exit(int status);
// int __fastcall BIO_gets(_DWORD, _DWORD, _DWORD); weak
// int __fastcall DSA_get0_key(_DWORD, _DWORD, _DWORD); weak
// __uid_t getuid(void);
// int __fastcall BN_cmp(_DWORD, _DWORD); weak
// int __fastcall DSA_set0_key(_DWORD, _DWORD, _DWORD); weak
// int __fastcall X509_get_version(_DWORD); weak
// int __fastcall EVP_VerifyFinal(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int adjtime(const struct timeval *delta, struct timeval *olddelta);
// void free(void *ptr);
// ssize_t read(int fd, void *buf, size_t nbytes);
// ssize_t write(int fd, const void *buf, size_t n);
// int RSA_size(void); weak
// int access(const char *name, int type);
// void openlog(const char *ident, int option, int facility);
// int inet_pton(int af, const char *cp, void *buf);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int fseek(FILE *stream, int off, int whence);
// int setpriority(__priority_which_t which, id_t who, int prio);
// int __fastcall BN_dup(_DWORD); weak
// int __fastcall getrlimit64(_DWORD, _DWORD); weak
// int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int _res_init(void);
// int tcgetattr(int fd, struct termios *termios_p);
// int __fastcall EVP_DigestFinal(_DWORD, _DWORD, _DWORD); weak
// int EVP_CIPHER_CTX_block_size(void); weak
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int tcflush(int fd, int queue_selector);
// int __fastcall PEM_read(_DWORD, _DWORD, _DWORD); weak
// int __fastcall BIO_new(_DWORD); weak
// int socket(int domain, int type, int protocol);
// __mode_t umask(__mode_t mask);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int fflush(FILE *stream);
// int __fastcall X509_gmtime_adj(_DWORD); weak
// int ioctl(int fd, unsigned int request, ...);
// int __fastcall DSA_set0_pqg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall strsignal(_DWORD); weak
// int __fastcall ASN1_INTEGER_new(_DWORD); weak
// int __fastcall RSA_private_decrypt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall EVP_PKEY_get0_DSA(_DWORD); weak
// int __fastcall BN_add(_DWORD, _DWORD, _DWORD); weak
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// size_t strlen(const char *s);
// int sscanf(const char *s, const char *format, ...);
// int adjtimex(struct timex *ntx);
// int __fastcall RAND_write_file(_DWORD); weak
// int unlink(const char *name);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// int __fastcall ASN1_INTEGER_get(_DWORD); weak
// void clearerr(FILE *stream);
// int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
// const __int32_t **_ctype_tolower_loc(void);
// int __fastcall EVP_MD_CTX_new(_DWORD); weak
// int BIO_s_mem(void); weak
// int stime(const time_t *when);
// int __fastcall X509_NAME_oneline(_DWORD, _DWORD, _DWORD); weak
// int feof(FILE *stream);
// int fgetc(FILE *stream);
// int strtol(const char *nptr, char **endptr, int base);
// int sigaddset(sigset_t *set, int signo);
// char *strcpy(char *dest, const char *src);
// int sem_post(sem_t *sem);
// int X509_new(void); weak
// int __fastcall X509_set_pubkey(_DWORD, _DWORD); weak
// int pthread_sigmask(int how, const __sigset_t *newmask, __sigset_t *oldmask);
// int settimeofday(const struct timeval *tv, const struct timezone *tz);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int __fastcall BN_new(_DWORD); weak
// int printf(const char *format, ...);
// char *ctime(const time_t *timer);
// int __fastcall open64(_DWORD, _DWORD, _DWORD); weak
// int __fastcall _vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int raise(int sig);
// int mlockall(int flags);
// int __fastcall BN_is_one(_DWORD); weak
// int __fastcall X509_getm_notBefore(_DWORD); weak
// int __fastcall EVP_PKEY_size(_DWORD); weak
// int __fastcall ERR_error_string(_DWORD, _DWORD); weak
// int __fastcall EVP_MD_pkey_type(_DWORD); weak
// int __fastcall X509_get_serialNumber(_DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// FILE *fdopen(int fd, const char *modes);
// int __fastcall BN_CTX_new(_DWORD); weak
// int _syslog_chk(_DWORD, _DWORD, const char *, ...); weak
// char *strstr(const char *haystack, const char *needle);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int close(int fd);
// double frexp(double x, int *exponent);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __fastcall X509_verify(_DWORD, _DWORD); weak
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int __fastcall X509_get0_notBefore(_DWORD); weak
// int closedir(DIR *dirp);
// int remove(const char *filename);
// time_t time(time_t *timer);
// double log10(double x);
// int __fastcall i2d_X509(_DWORD, _DWORD); weak
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// const unsigned __int16 **_ctype_b_loc(void);
// int __fastcall _xstat64(_DWORD, _DWORD, _DWORD); weak
// int __fastcall X509_set_version(_DWORD, _DWORD); weak
// int fprintf(FILE *stream, const char *format, ...);
// int __fastcall X509_NAME_add_entry_by_txt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void *malloc(size_t size);
// int __fastcall mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int EVP_aes_128_cbc(void); weak
// int gethostname(char *name, size_t len);
// int cfsetospeed(struct termios *termios_p, speed_t speed);
// int sched_get_priority_min(int algorithm);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// struct tm *gmtime_r(const time_t *timer, struct tm *tp);
// int chdir(const char *path);
// int __fastcall OBJ_sn2nid(_DWORD); weak
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// int __fastcall DSA_free(_DWORD); weak
// int _fprintf_chk(_DWORD, _DWORD, const char *, ...); weak
// int pthread_attr_init(pthread_attr_t *attr);
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// int __fastcall CMAC_CTX_cleanup(_DWORD); weak
// char *getcwd(char *buf, size_t size);
// int __fastcall BN_rand(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall X509_get_ext(_DWORD, _DWORD); weak
// void rewinddir(DIR *dirp);
// int __fastcall DSA_SIG_get0(_DWORD, _DWORD, _DWORD); weak
// unsigned int sleep(unsigned int seconds);
// void *memmove(void *dest, const void *src, size_t n);
// int fnmatch(const char *pattern, const char *name, int flags);
// int RAND_file_name(void); weak
// int getifaddrs(struct ifaddrs **ifap);
// int clock_settime(clockid_t clock_id, const struct timespec *tp);
// int __fastcall X509_get0_notAfter(_DWORD); weak
// int __fastcall DSA_get0_pqg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int dup2(int fd, int fd2);
// int __fastcall X509_get_subject_name(_DWORD); weak
// int puts(const char *s);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int __fastcall EVP_MD_CTX_free(_DWORD); weak
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// int __fastcall i2d_PublicKey(_DWORD, _DWORD); weak
// __pid_t getpid(void);
// int __fastcall RAND_bytes(_DWORD, _DWORD, _DWORD); weak
// int __fastcall RSA_public_encrypt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void closelog(void);
// int __fastcall EVP_PKEY_free(_DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int dup(int fd);
// ssize_t readlink(const char *path, char *buf, size_t len);
// __pid_t fork(void);
// int __fastcall X509_set_serialNumber(_DWORD, _DWORD); weak
// int pthread_attr_destroy(pthread_attr_t *attr);
// ssize_t recvmsg(int fd, struct msghdr *message, int flags);
// int rand(void);
// int munmap(void *addr, size_t len);
// int __fastcall i2d_DSA_SIG(_DWORD, _DWORD); weak
// int __fastcall BN_bn2bin(_DWORD, _DWORD); weak
// int __fastcall BN_mod_exp(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall CMAC_CTX_get0_cipher_ctx(_DWORD); weak
// int __fastcall ASN1_INTEGER_set(_DWORD, _DWORD); weak
// int __fastcall readdir64(_DWORD); weak
// int __fastcall OBJ_nid2sn(_DWORD); weak
// int __fastcall EVP_SignFinal(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall BIO_free(_DWORD); weak
// int __fastcall RAND_status(_DWORD); weak
// int __fastcall EVP_DigestInit(_DWORD, _DWORD); weak
// size_t strcspn(const char *s, const char *reject);
// int _sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...); weak
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int __fastcall X509_set_subject_name(_DWORD, _DWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// struct tm *gmtime(const time_t *timer);
// int link(const char *from, const char *to);
// int ferror(FILE *stream);
// int utimes(const char *file, const struct timeval tvp[2]);
// void *realloc(void *ptr, size_t size);
// int __fastcall d2i_X509(_DWORD, _DWORD, _DWORD); weak
// int IO_putc(int c, _IO_FILE *fp);
// int __fastcall setrlimit64(_DWORD, _DWORD); weak
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int __fastcall X509_free(_DWORD); weak
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int pipe(int pipedes[2]);
// char *_strdup(const char *s);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// char *strpbrk(const char *s, const char *accept);
// int getitimer(__itimer_which_t which, struct itimerval *value);
// int __fastcall DSA_SIG_free(_DWORD); weak
// int sem_wait(sem_t *sem);
// void *memchr(const void *s, int c, size_t n);
// int strcmp(const char *s1, const char *s2);
// int __fastcall X509_get_ext_count(_DWORD); weak
// void exit(int status);
// int cfsetispeed(struct termios *termios_p, speed_t speed);
// int *_errno_location(void);
// int pthread_cancel(pthread_t th);
// int DSA_new(void); weak
// int __fastcall RSA_get0_key(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall PEM_read_PrivateKey(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int _cxa_finalize(void *);
// int __fastcall _fdelt_chk(_DWORD, _DWORD, _DWORD); weak
// double ceil(double x);
// int sprintf(char *s, const char *format, ...);
// int pthread_join(pthread_t th, void **thread_return);
// int __fastcall d2i_DSAparams(_DWORD, _DWORD, _DWORD); weak
// int fscanf(FILE *stream, const char *format, ...);
// int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
// int __fastcall BN_free(_DWORD); weak
// int truncate64(void); weak
// int fputs(const char *s, FILE *stream);
// double ldexp(double x, int exponent);
int __fastcall sub_C170(int a1, char a2, unsigned int a3, __int16 a4);
int __fastcall sub_C534(const char *a1, const char *a2);
void __noreturn sub_C5C4();
void __fastcall __noreturn sub_C610(int a1);
int __fastcall main(int argc, const char **argv, const char **envp);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_C6F8();
char *sub_C71C();
__int64 sub_C748();
char *sub_C77C();
_BYTE *sub_C7C0();
int __fastcall sub_C8E0(int result);
void __noreturn sub_C954(unsigned __int8 *a1, ...);
void __fastcall sub_C9A0(_DWORD *a1, __int16 *a2);
unsigned int *__fastcall sub_CBFC(const char *a1);
bool __fastcall sub_CC78(unsigned __int16 *a1, int a2);
int __fastcall sub_CE10(int a1, unsigned __int16 *a2);
unsigned int __fastcall sub_CEE8(unsigned int result);
void __fastcall sub_D014(int a1, int a2, int a3, const char *a4, int a5, int a6, int a7);
void __fastcall sub_D1A8(int a1, int a2, unsigned __int16 *ptr, const char *a4, int a5, int a6, _DWORD *a7);
char *__fastcall sub_D368(char *result, int a2, int a3, const char *a4, int a5, int a6, _DWORD *a7);
int __fastcall sub_D504(unsigned __int8 *a1, char *s);
char *__fastcall sub_D580(char *s1);
int __fastcall sub_D6D4(int a1, FILE *s, int a3);
int __fastcall sub_ED20(FILE *s, int a2);
_DWORD *__fastcall sub_EDB0(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_EE48(_DWORD *result, _DWORD *ptr);
int __fastcall sub_EEF0(int *a1, void (**a2)(void *ptr));
void __fastcall destroy_attr_val(int a1);
_DWORD *__fastcall sub_F020(int a1);
_DWORD *__fastcall sub_F098(int a1, int a2);
_DWORD *__fastcall sub_F108(int a1, int a2);
_DWORD *__fastcall sub_F178(int a1, int a2, int a3);
_DWORD *__fastcall sub_F1F0(int a1, void *a2);
_DWORD *__fastcall sub_F288(int a1);
_DWORD *__fastcall sub_F2E8(int a1);
_DWORD *__fastcall sub_F348(int a1, int a2);
void __fastcall sub_F410(_DWORD *a1);
_DWORD *__fastcall sub_F4B0(int a1, int a2, int **a3);
_WORD *__fastcall sub_F7BC(_DWORD *a1);
_DWORD *__fastcall sub_F898(int a1, int a2);
_DWORD *__fastcall sub_F900(int a1, int a2, __int16 a3, int a4, int a5);
_DWORD *__fastcall sub_F980(const char *a1, int a2, int a3);
_DWORD *__fastcall sub_FA04(int a1, int a2, int a3);
_DWORD *__fastcall sub_FAAC(int a1, int a2);
_DWORD *__fastcall sub_FB14(int a1, int a2);
char *__fastcall sub_FB7C(char *result, unsigned __int64 a2);
void __fastcall sub_FD04(int a1);
void __fastcall sub_132B0(unsigned __int16 *a1);
void __fastcall sub_13380(int a1, int a2);
char *__fastcall sub_134EC(unsigned int a1);
char *__fastcall sub_1379C(int a1);
char *__fastcall sub_138BC(int a1);
bool __fastcall sub_13D38(unsigned __int16 *a1);
int __fastcall sub_13DC8(_DWORD *s2);
int __fastcall sub_13EA4(_DWORD *a1, int a2);
_DWORD *__fastcall sub_13F3C(const void *a1);
int __fastcall sub_1400C(int a1, int fd, unsigned __int16 *a3);
char *__fastcall sub_140C0(char *result, int a2);
char *__fastcall sub_141A4(char *result);
char *__fastcall sub_14298(int a1);
char *__fastcall sub_1482C(int a1);
int __fastcall sub_148D0(_DWORD *a1, unsigned __int16 *a2);
int __fastcall sub_149CC(const char *a1, unsigned __int16 *a2, unsigned int a3);
ssize_t __fastcall sub_14C78(int a1, int a2, int a3, int a4);
int __fastcall sub_15184(_DWORD *s2);
__int16 *__fastcall sub_15274(unsigned int a1, int a2);
__int16 *__fastcall sub_153D4(unsigned int a1, int a2, int a3);
__int16 *__fastcall sub_15420(unsigned int a1, int a2);
int __fastcall sub_154A8(struct sockaddr *a1, int a2, int a3, int a4);
__int16 *__fastcall sub_15954(__int16 *result);
__int16 *__fastcall sub_15A58(int a1);
void __fastcall sub_15B14(int a1);
int sub_15CF0();
int __fastcall sub_15D6C(int (__fastcall *a1)(int, _DWORD **), int a2);
_DWORD *__fastcall sub_15E04(int a1, const char *a2, int a3, int a4);
_DWORD *__fastcall sub_15F74(_DWORD *result, int *a2);
int __fastcall sub_16020(int a1, unsigned __int16 *a2);
int sub_16070();
char *__fastcall sub_160C4(int a1, unsigned __int16 *a2);
char *sub_1621C();
int sub_1640C();
char *__fastcall sub_164F4(char *result);
void __fastcall sub_167AC(unsigned __int16 *s2);
int __fastcall sub_16A68(struct sockaddr *addr, int a2, int a3, unsigned int *buf, size_t n);
char *sub_16D04();
int __fastcall sub_1753C(_DWORD *a1, int a2);
char *__fastcall sub_1759C(const struct sockaddr *a1, int a2, int a3);
char *__fastcall sub_178F8(const struct sockaddr *a1);
int __fastcall sub_17984(void (__fastcall *a1)(int, _DWORD **), int a2);
char *sub_18484();
void __fastcall sub_18908(void (__fastcall *a1)(int, _DWORD **), int a2);
int __fastcall sub_1898C(struct sockaddr *a1);
char *__fastcall sub_18C28(int a1, int a2, char *a3);
int sub_18D18();
int __fastcall sub_18DF0(int *a1);
char *__fastcall sub_18E64(int a1);
__int16 *sub_18F30();
const char *__fastcall sub_18FB4(int a1);
int __fastcall sub_19024(__int16 *a1, unsigned int a2);
int __fastcall sub_190F4(FILE *a1, int a2);
const char *__fastcall sub_1919C(const char *result, int a2);
size_t __fastcall sub_19254(int a1, char *s);
int __fastcall sub_19348(int *a1, _BYTE **a2, __int16 *a3, int a4);
int __fastcall sub_19664(const char *a1);
int sub_1973C();
const char *__fastcall sub_1BBB4(unsigned int a1);
int __fastcall sub_1BC38(int a1, _DWORD *a2);
_DWORD *__fastcall sub_1BD14(const char *a1, int a2);
void __fastcall sub_1BDD8(_DWORD *a1);
int __fastcall sub_1BE54(_DWORD *a1);
int sub_1BFFC();
char *__fastcall sub_1C0BC(int a1);
bool __fastcall sub_1C148(const char *a1, int a2);
int sub_1C1CC();
bool sub_1C24C();
int __fastcall sub_1C2E8(const char *a1, int a2);
_DWORD *sub_1C364();
int sub_1C3DC();
int sub_1C450();
int sub_1C4B8();
_BYTE *__fastcall sub_1C50C(char *a1);
int sub_1C5E8();
int __fastcall sub_1CF78(int result);
char *__fastcall sub_1CFD4(int a1);
const char *__fastcall sub_1D044(const char *result, int a2, unsigned __int8 *a3, int *a4);
void __fastcall __noreturn sub_1D124(const char *a1, int a2, unsigned __int8 *a3, int *a4);
void __fastcall __noreturn sub_1D1CC(const char *a1, int a2, int a3, const char *a4);
void __noreturn sub_1D250();
int __fastcall sub_1D284(int *a1, char ***a2);
void __fastcall __noreturn sub_1D338(int a1, char **a2);
int sub_1DF60();
void __noreturn sub_1DFC0();
void __fastcall sub_1E008(int a1, int a2);
int __fastcall sub_1E508(unsigned __int16 *a1, int a2, int a3);
unsigned int __fastcall sub_1E688(int a1, int a2, unsigned int a3);
char *__fastcall sub_1E710(unsigned __int16 *a1, int a2);
_DWORD *__fastcall sub_1E820(int a1, _DWORD *a2);
__int16 *__fastcall sub_1EBA4(int a1);
char *__fastcall sub_1EEC8(char *result, int a2, int a3);
char *__fastcall sub_1F0E4(const char *a1, int a2, int a3);
char *__fastcall sub_1F188(const char *a1, unsigned int a2, unsigned __int16 *a3);
char *__fastcall sub_1F20C(const char *a1, int a2);
char *__fastcall sub_1F2C0(const char *a1, int a2, int a3);
char *sub_1F3A0(unsigned __int8 *a1, ...);
__int16 *__fastcall sub_1F454(int a1);
int __fastcall sub_1F4D0(int a1);
int sub_1F5E0();
char *__fastcall sub_1F62C(int a1, __int16 a2);
unsigned int __fastcall sub_1F95C(unsigned int result);
char *__fastcall sub_1FA04(const char *a1, int a2);
char *__fastcall sub_1FAA8(const char *a1, int a2);
char *__fastcall sub_1FB4C(const char *a1, int a2);
char *__fastcall sub_1FBF0(int a1);
char *__fastcall sub_1FCCC(const char *a1, _DWORD *a2);
char *__fastcall sub_1FD78(int a1, int a2, int a3);
char *__fastcall sub_200E4(const char *a1, int a2, int a3);
signed int __fastcall sub_201A8(int a1, unsigned __int8 *a2, int a3);
char *__fastcall sub_20608(const char *a1, int a2, int a3);
char *__fastcall sub_2071C(const char *a1, int a2);
size_t __fastcall sub_20810(int a1, int a2);
__int16 *__fastcall sub_211F8(int a1);
signed int __fastcall sub_21888(signed int result);
_BYTE *__fastcall sub_2305C(_BYTE *result);
unsigned __int16 *__fastcall sub_23110(int a1, int a2);
int __fastcall sub_23504(int a1);
int sub_235A8();
void sub_23684();
__int16 *sub_23AC0();
__int16 *sub_23BF8();
__int16 *sub_23CE8();
int __fastcall sub_23D98(unsigned __int16 *a1, int a2, int a3, char a4);
__int16 *__fastcall sub_24010(int a1, __int16 a2);
int __fastcall sub_240C0(unsigned __int16 *a1, int a2, int a3);
__int16 *__fastcall sub_24150(int a1, __int16 a2);
int sub_241C4();
int sub_2430C();
void *__fastcall sub_243AC(unsigned int *a1, size_t a2, __int16 a3);
unsigned int *__fastcall sub_2446C(unsigned int *result, unsigned __int8 *a2, size_t a3, __int16 a4);
unsigned int *__fastcall sub_245C4(unsigned __int8 *a1, size_t a2, __int16 a3);
char *__fastcall sub_2462C(char *result, __int16 a2);
__int16 *sub_24B08();
void *__fastcall sub_24D10(const char *a1);
void __fastcall sub_24DE4(_WORD *a1);
void __fastcall sub_24E78(int a1, __int16 a2);
void sub_25BB4();
__int16 *__fastcall sub_25EE0(__int16 *result, int a2, const char *a3);
unsigned int sub_262E8(__int16 *a1, int a2, unsigned __int8 *a3, ...);
unsigned int __fastcall sub_2637C(_DWORD *a1, int *a2, int a3);
void __fastcall sub_26540(int a1, int a2);
int __fastcall sub_26630(unsigned int *a1, unsigned int *a2, int a3);
int __fastcall sub_268A4(unsigned __int8 *a1, unsigned __int8 *a2);
unsigned int __fastcall sub_2698C(unsigned int a1, _DWORD *a2, int a3);
_DWORD *__fastcall sub_26B40(unsigned __int8 *a1, int a2, unsigned __int16 *a3);
_DWORD *__fastcall sub_26D98(char *s1, int a2, unsigned __int16 *a3);
int __fastcall sub_26E50(int a1);
unsigned int __fastcall sub_272C8(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5);
int __fastcall sub_27454(int a1, int a2);
int __fastcall sub_27774(int a1);
_DWORD *__fastcall sub_2787C(int a1, int a2, unsigned int a3, char *s);
void sub_279FC();
void sub_27AA0();
void *__fastcall sub_27B48(_DWORD *a1);
void __fastcall sub_27BCC(_DWORD *a1);
char *__fastcall sub_27C64(const void *a1, unsigned int a2, unsigned int a3);
int __fastcall sub_2816C(unsigned int *a1);
int __fastcall sub_2828C(int a1, int a2);
unsigned int __fastcall sub_29774(int a1, int a2, int a3, int a4, unsigned int *a5, unsigned int a6);
char *sub_2B408();
void *__fastcall sub_2BCA8(int a1, const char *a2);
void __fastcall sub_2BE54(int a1, unsigned int a2);
void __fastcall sub_2C570(int a1, char *s1, const char *a3, int a4, int a5);
int __fastcall sub_2C718(char *s1); // idb
const char *__fastcall sub_2C7BC(const char *a1, const char *a2, int a3);
void sub_2C8D8();
int __fastcall sub_2C96C(int result);
unsigned __int8 *__fastcall sub_2C9CC(unsigned __int8 *a1);
unsigned int __fastcall sub_2CA3C(_BYTE *a1, _BYTE *a2);
int __fastcall sub_2CAC4(int a1, int a2);
_QWORD *__fastcall sub_2CB8C(int a1, unsigned __int64 *a2);
_BYTE *__fastcall sub_2CD30(int *a1);
int *__fastcall sub_2CE3C(int *result, unsigned __int8 *a2);
int __fastcall sub_2CF08(int a1, int a2, unsigned __int64 *a3);
_BYTE *__fastcall sub_2D014(int (__fastcall *a1)(int), int a2, _BYTE *a3);
const void *__fastcall sub_2D0F4(int a1);
int __fastcall sub_2D1A4(void *a1);
int __fastcall sub_2D220(int a1);
int __fastcall sub_2D2B0(_DWORD *a1);
int __fastcall sub_2D320(int a1, int (__fastcall *a2)(int), int a3, int a4);
int __fastcall sub_2D664(int a1, int (*a2)(int, const char *, ...), int a3);
int __fastcall sub_2D7D0(unsigned __int64 *a1, int a2, time_t *a3);
int __fastcall sub_2D9F0(int a1, int a2, time_t *a3);
bool __fastcall sub_2DA78(_QWORD *a1);
int sub_2DB18();
_DWORD *__fastcall sub_2DB68(_DWORD *a1);
bool __fastcall sub_2DBD0(int a1, time_t *a2);
int __fastcall sub_2DC54(int a1, time_t *a2);
bool __fastcall sub_2DCF4(int a1, int a2, time_t *a3);
int __fastcall sub_2DE9C(int a1, int a2, time_t *a3);
int __fastcall sub_2E04C(int (__fastcall *a1)(int), int a2);
int __fastcall sub_2E298(FILE *a1, const char *a2, int a3);
int __fastcall sub_2E578(const char *a1, _DWORD *a2, int a3, int a4);
void *sub_2E6E0();
int __fastcall sub_2E750(__int16 *a1);
__int16 *__fastcall sub_2E800(const char *a1, int a2, int a3);
void __noreturn sub_2E8C0();
char *sub_2E914();
void *__fastcall sub_2EA24(const char *a1, int a2, int a3, int a4, int a5, int a6);
__int16 *sub_2EF84();
unsigned int sub_2F1EC();
__int16 *sub_2F368();
int sub_2F40C();
int __fastcall sub_2F4BC(int a1);
int sub_301E4();
__int16 *__fastcall sub_303FC(__int16 *result);
int sub_30520();
void *__fastcall sub_305F8(void *result);
void sub_30A38();
_DWORD *__fastcall sub_30B44(int a1);
void *sub_30C68();
int __fastcall sub_30CD4(int result);
unsigned int __fastcall sub_30DFC(unsigned int result);
void *__fastcall sub_30F28(void *result);
int __fastcall sub_30FF4(int a1, int a2);
int __fastcall sub_31634(unsigned __int16 *s, int a2);
int __fastcall sub_318D8(unsigned int a1, __int16 a2);
int sub_31958();
int __fastcall sub_31A44(unsigned __int16 *a1, const char *a2, int *a3, int a4, char a5, _DWORD *a6);
int __fastcall sub_31C78(int a1);
int sub_31D10();
int __fastcall sub_31DAC(int a1);
char *__fastcall sub_31E54(char *result, int a2);
int __fastcall sub_31FC4(int a1);
void sub_320B4();
char *__fastcall sub_321D4(int a1, const char *a2, char *a3, int a4, unsigned __int8 a5, char a6, unsigned __int8 a7, unsigned __int8 a8, int a9, unsigned __int8 a10, int a11, unsigned int a12, const char *a13);
char *__fastcall sub_32898(_DWORD *a1, const char *a2, char *a3, int a4, unsigned __int8 a5, char a6, unsigned __int8 a7, unsigned __int8 a8, int a9, int a10, unsigned int a11, const char *a12);
int *sub_32A70();
_DWORD *__fastcall sub_32B18(_DWORD *result);
_DWORD *sub_32B9C();
int *__fastcall sub_32C0C(int a1);
int __fastcall sub_32CA0(int a1, int a2, int *a3);
int sub_32E6C();
int sub_32F28();
int __fastcall sub_32FE4(int a1);
char *__fastcall sub_33174(int a1);
char *__fastcall pool_name_resolved(int a1, int a2, unsigned __int16 a3, int a4, int a5, int a6, int a7);
int __fastcall sub_335A4(int result);
int __fastcall sub_3362C(int a1, int a2, int a3, int a4);
int __fastcall sub_336EC(int *a1, _DWORD *a2, unsigned int a3);
char *__fastcall sub_337E4(int a1);
int __fastcall sub_3394C(_DWORD *a1);
int __fastcall sub_339F8(double a1);
int __fastcall sub_34264(int a1, unsigned int a2);
int sub_343FC();
int __fastcall sub_35528(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, char a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, double a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, double a54);
int __fastcall sub_359B0(int a1, unsigned __int8 *a2, int a3);
int __fastcall sub_36214(int a1, int *a2);
int __fastcall sub_36448(int); // idb
int __fastcall receive(__int64 a1);
char *sub_386B0();
void __fastcall sub_38810(int a1, __int16 *a2, char *s2);
int sub_38C70();
int *sub_38D98();
int __fastcall sub_391E0(double *a1, double *a2);
size_t __fastcall sub_39248(int a1);
__int16 *__fastcall sub_394A0(__int16 *result, int a2);
int sub_395B0();
void __fastcall sub_39640(int a1);
int __fastcall sub_396D4(int a1);
int __fastcall sub_3987C(int a1);
int sub_3992C(void); // weak
int __fastcall sub_39A70(_DWORD *a1, int a2, unsigned int a3);
int __fastcall sub_39BC8(_DWORD *a1);
int __fastcall sub_39CF8(_DWORD *a1);
int __fastcall sub_39D44(_DWORD); // weak
_BYTE *__fastcall sub_39EE4(int a1, bool *a2, int a3, _DWORD *a4);
size_t __fastcall sub_39F94(_DWORD *a1, void *dest, int a3, _DWORD *a4);
int __fastcall sub_3A02C(int a1, char *a2);
int __fastcall sub_3A0AC(int a1, speed_t a2, __int16 a3);
int __fastcall sub_3A298(const char *a1, speed_t a2, __int16 a3);
int __fastcall sub_3A3B4(__int64 a1, int a2);
int __fastcall sub_3A698(double a1);
int *sub_3A860();
void *sub_3A918();
int __fastcall sub_3AA70(_DWORD *a1, int a2);
_DWORD *__fastcall sub_3AB18(_DWORD **a1, _DWORD *a2);
void **__fastcall sub_3ABB0(void **result, int *a2);
int __fastcall sub_3AD58(struct sockaddr *a1, int a2, char a3, char a4, int a5);
int __fastcall sub_3AE24(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3AE7C(struct sockaddr *a1, int a2, int a3, unsigned int a4);
int __fastcall sub_3AF24(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3AF70(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3AFBC(struct sockaddr *a1, int a2, int a3);
int sub_3B02C();
int __fastcall sub_3B12C(int a1, int a2, int a3);
int __fastcall sub_3B1F0(int a1, int a2, int a3);
int __fastcall sub_3B390(int a1, int a2, int a3);
int __fastcall sub_3B454(int a1, int a2, int a3);
int __fastcall sub_3B668(int a1, int a2, int a3);
int __fastcall sub_3B7EC(int a1, int a2, int a3);
int __fastcall sub_3B8E4(int a1, int a2, int a3);
int __fastcall sub_3BAA8(int a1, int a2, int a3);
int __fastcall sub_3BC14(int a1, int a2, int a3);
int __fastcall sub_3BDB0(int a1, int a2, int a3);
int __fastcall sub_3BF84(int a1, int a2, int a3);
int __fastcall sub_3C3CC(int a1, int a2, int a3);
int __fastcall sub_3C6E8(struct sockaddr *a1, int a2, int a3, int a4);
int __fastcall sub_3C894(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3C8E0(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3C92C(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3CC18(struct sockaddr *a1, int a2, int a3, int a4);
int __fastcall sub_3CF70(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3CFBC(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3D008(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3D054(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3D294(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3D524(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3D800(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3DAD4(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3DD2C(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3E104(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3E2D0(int *a1, const char *a2, struct sockaddr *a3, int a4, int a5);
int __fastcall sub_3E3F0(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3E460(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3E4D0(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3E6FC(int a1, int a2, int a3);
int __fastcall sub_3E800(struct sockaddr *a1, int a2, int a3, __int16 *a4);
int __fastcall sub_3E9E0(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3EA2C(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3EA78(struct sockaddr *a1, int a2, int a3);
int __fastcall sub_3F100(int a1, int a2, int a3);
int *sub_3F3E4();
int __fastcall sub_3F498(int a1);
int __fastcall sub_3F4E4(int result, int a2);
int __fastcall sub_3F994(int a1, int a2);
int __fastcall sub_3FAA4(int *s, int a2);
int __fastcall sub_3FC3C(int a1, int a2);
int __fastcall sub_3FD1C(int a1, int a2);
int sub_3FFBC();
unsigned int __fastcall sub_40054(unsigned int result, _WORD *a2);
int __fastcall sub_40238(int result, unsigned __int16 *a2, _DWORD *a3, __int16 a4, unsigned __int16 a5, __int16 a6, int a7);
unsigned int __fastcall sub_40824(unsigned __int16 *a1, int a2, int a3);
int sub_40AEC();
int sub_40B88();
int sub_40C14();
int sub_40CF0();
int __fastcall sub_40DFC(int result);
int __fastcall sub_40E80(int result);
void sub_40ED4();
int sub_41648();
int ntpd_time_stepped();
int __fastcall sub_41754(int a1, int a2, time_t *a3);
int sub_418A8();
void sub_419E0();
unsigned int __fastcall sub_41CDC(unsigned int result, int a2);
unsigned int __fastcall sub_41E10(unsigned int result);
unsigned int __fastcall sub_41F44(unsigned __int16 *a1, const char *a2);
unsigned int sub_42050(unsigned __int16 *a1, unsigned __int8 *a2, ...);
unsigned int __fastcall sub_420F0(unsigned __int16 *a1, unsigned __int16 *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, unsigned int a7, int a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, int a15);
unsigned int __fastcall sub_4241C(unsigned int result);
unsigned int __fastcall sub_42514(unsigned __int16 *a1, const char *a2);
int __fastcall sub_42670(int a1, int a2, time_t *a3);
size_t __fastcall sub_42744(const char *a1);
int sub_427E8();
_BYTE *__fastcall sub_42858(int a1);
void __fastcall sub_4294C(int a1, char *s);
int __fastcall sub_42D0C(unsigned __int8 *a1, unsigned __int8 *a2);
void sub_42DE0();
int sub_42E24();
void sub_42E94();
ssize_t __fastcall sub_42ED8(int a1, int a2);
void __fastcall sub_42F5C(int a1, int a2);
char *__fastcall sub_42FF0(char *result);
int __fastcall sub_432DC(int a1, int a2, int a3);
void __fastcall sub_434DC(int a1, int a2);
int __fastcall sub_4355C(int a1, int a2);
__int16 *__fastcall sub_436C0(int a1);
unsigned int __fastcall sub_43928(int a1, int a2);
void __fastcall sub_439BC(int a1, int a2);
__int16 *__fastcall sub_43A3C(__int16 *result);
int __fastcall sub_43D9C(int a1, int a2);
unsigned __int64 __fastcall sub_43F08(unsigned __int8 *a1, unsigned __int8 **a2);
int __fastcall sub_440B0(double a1, int a2, _DWORD *a3);
void __fastcall sub_4426C(int a1, int a2);
int __fastcall sub_443C4(__int16 *a1, _DWORD *a2, int a3, unsigned int a4);
int __fastcall sub_44468(int a1, const char *a2);
int __fastcall sub_444F8(int a1, int a2);
int *__fastcall sub_445B0(int *result, const char *a2, unsigned __int8 *a3, int a4);
int __fastcall sub_4475C(int a1);
void __fastcall sub_44920(int a1, int a2);
const char *sub_44D5C();
__int16 *__fastcall sub_44E70(int a1, int a2);
unsigned int sub_45034(void **a1, int a2, ...);
bool __fastcall sub_450E4(int a1, int a2);
int __fastcall sub_45590(_DWORD *a1, char *s1, int a3);
unsigned __int64 __fastcall sub_456C0(_DWORD *a1, char *a2);
int __fastcall sub_45784(_DWORD *a1, _DWORD *a2, char *a3, char *a4, int a5);
int __fastcall sub_458B8(_DWORD *a1, char *a2);
int __fastcall sub_4594C(_DWORD *a1, char *a2, int a3);
int __fastcall sub_459F4(int *a1, int a2, unsigned int a3, int a4, unsigned int a5);
_DWORD *__fastcall sub_46070(_DWORD *result);
int __fastcall sub_460C4(int a1);
__int16 *__fastcall sub_470B4(int a1, int a2);
char *__fastcall sub_471C4(int a1, int a2);
__int16 *__fastcall sub_47230(int a1);
int __fastcall sub_47414(int a1, int a2);
int __fastcall sub_47520(int a1, int a2);
void __fastcall sub_47580(int a1, int a2);
unsigned int __fastcall sub_47600(unsigned int result);
int __fastcall sub_477E8(int a1, int a2);
__int16 *__fastcall sub_4793C(int a1, int a2);
void __fastcall sub_47B18(int a1, int a2);
int __fastcall sub_47B98(__int16 a1, int a2);
__int16 *__fastcall sub_47C84(int a1, int a2);
void __fastcall sub_47D48(int a1, int a2);
int __fastcall sub_47DC8(int a1, int a2);
__int16 *__fastcall sub_47F48(int a1);
__int16 *__fastcall sub_48568(int a1, int a2);
void __fastcall sub_48618(int a1, int a2);
int __fastcall sub_48698(int a1, int a2);
int __fastcall sub_48ABC(int a1, int a2);
int __fastcall sub_48CB8(int a1);
int __fastcall sub_492D0(int a1);
int __fastcall sub_49588(double a1, int a2);
int __fastcall sub_498E8(int a1, int a2, int a3);
int sub_49A14();
int sub_49A5C();
int __fastcall sub_49AA4(int a1, int a2, int a3);
int __fastcall sub_49B10(int a1, int a2, _WORD *a3);
int __fastcall sub_49C20(int a1);
int __fastcall sub_49C80(int a1);
int __fastcall sub_49CE0(int a1, int a2, int a3);
unsigned int __fastcall sub_49D34(int a1, int a2);
void __fastcall sub_49DE0(int a1, int a2);
unsigned int __fastcall sub_4A084(int a1, int a2, char *s);
int __fastcall sub_4A2E0(__int16 *a1, int a2);
int __fastcall sub_4A370(__int16 *a1, int a2);
int __fastcall sub_4A3BC(__int16 *a1, int a2);
int __fastcall sub_4A44C(__int16 *a1, int a2, _WORD *a3);
int __fastcall sub_4A52C(__int16 *a1, int a2, int a3);
int __fastcall sub_4A5CC(__int16 *a1, int a2);
int __fastcall sub_4A65C(__int16 *a1, int a2, int a3);
int __fastcall sub_4A838(__int16 *a1, int a2, int a3);
int __fastcall sub_4A880(__int16 *a1, int a2, int a3);
int __fastcall sub_4A8D4(__int16 *a1, int a2);
unsigned int __fastcall sub_4A9A4(int a1, int a2);
__int16 *__fastcall sub_4AAB4(int a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_4AD94(int a1, _DWORD *a2, int a3);
bool __fastcall sub_4B4B4(int a1, int a2, int a3);
int __fastcall sub_4B744(int a1, int a2); // idb
bool __fastcall sub_4BB10(__int16 *a1, int a2, __int16 *a3);
int __fastcall sub_4BC28(unsigned __int8 *a1, int a2);
int __fastcall sub_4C038(int a1, int a2);
char *__fastcall sub_4C478(_DWORD *a1);
int sub_4E12C();
int sub_4E174();
int sub_4E1BC();
int sub_4E204();
int sub_4E24C();
int sub_4E294();
int sub_4E2DC();
int sub_4E324();
int sub_4E36C();
int sub_4E3B4();
int sub_4E3FC();
int sub_4E444();
int sub_4E48C();
int sub_4E4D4();
int sub_4E51C();
int sub_4E564();
int sub_4E5AC();
int sub_4E5F4();
int sub_4E63C();
int sub_4E684();
int sub_4E6CC();
int __fastcall sub_4E744(unsigned __int8 *a1, _WORD *a2);
int __fastcall sub_4E854(int result);
int __fastcall sub_4EC80(int a1, int a2, _BYTE *s);
char *__fastcall sub_4EDF4(char *result);
char *__fastcall sub_4EEC4(char *result);
int __fastcall sub_4EF58(int a1, int a2);
int __fastcall sub_4F1C8(int a1, int a2);
int __fastcall sub_4F260(int a1, int a2);
int __fastcall sub_4F360(int a1, int a2);
int __fastcall sub_4F3C0(double a1, int a2, int a3);
char *__fastcall sub_4F7E8(int a1, int a2);
int __fastcall sub_4F944(int a1, int *a2);
int __fastcall sub_4F9D8(int a1, int *a2);
__int16 *__fastcall sub_4FA84(__int16 *result);
int __fastcall sub_50150(int a1, int a2);
void sub_50980();
int __fastcall sub_509C4(unsigned __int8 **a1, int a2, int a3, unsigned __int8 a4);
int sub_50A98();
int __fastcall sub_50B6C(int a1, int a2);
char *__fastcall sub_50C90(int a1, int a2);
bool __fastcall sub_50D0C(unsigned __int8 *a1, int a2);
int __fastcall sub_50DCC(int a1, int a2, int a3, int a4);
int __fastcall sub_50F28(_BYTE *a1, unsigned int *a2, int a3, int a4);
bool sub_510A0(unsigned __int8 **a1, ...);
bool __fastcall sub_511FC(int a1, int a2);
int __fastcall sub_51584(int a1);
ssize_t __fastcall sub_523A0(__int16 *a1, int fd);
void __fastcall sub_52428(int a1, int a2);
int __fastcall sub_524A8(_DWORD *a1, _DWORD *a2, unsigned __int8 *a3);
int __fastcall sub_52610(int a1, int a2);
unsigned int __fastcall sub_52A04(int a1);
int __fastcall sub_52E7C(int a1);
__int16 *__fastcall sub_52FC4(__int16 *result, int a2);
__int16 *__fastcall sub_530E4(int a1);
int __fastcall sub_53428(int a1, int a2);
int __fastcall sub_53490(int a1, int a2);
__int16 *__fastcall sub_535B4(int a1, int a2);
__int16 *__fastcall sub_53808(int a1, int a2);
void __fastcall sub_538E0(int a1, int a2);
int __fastcall sub_53960(int a1, int a2);
__int16 *__fastcall sub_53A84(int a1);
FILE *sub_53CC4(int a1, int a2, ...);
__int16 *__fastcall sub_53E04(__int16 *result, char *s);
__int16 *__fastcall sub_53ECC(int a1, unsigned int a2);
int __fastcall sub_5465C(int a1, int a2);
void __fastcall sub_546EC(int a1, int a2);
char *__fastcall sub_5476C(int a1);
int __fastcall sub_54C54(int a1, int a2);
__int16 *__fastcall sub_54DA8(int a1, int a2);
void __fastcall sub_54E84(int a1, int a2);
__int16 *__fastcall sub_54F04(int a1);
int __fastcall sub_5534C(int a1, int a2);
int __fastcall sub_55480(int a1, int a2);
void __fastcall sub_554F4(int a1, int a2);
int __fastcall sub_55584(int **a1);
int __fastcall sub_55620(char a1, int *a2, int a3);
int __fastcall sub_556C0(int a1);
int __fastcall sub_55870(int a1);
int __fastcall sub_559D4(int a1, int a2);
int __fastcall sub_55C88(double a1, double *a2);
int __fastcall sub_55F80(double a1, int a2);
int __fastcall sub_56264(double a1);
int __fastcall sub_57878(int a1);
_BYTE *__fastcall sub_58E24(double a1, int a2);
__int16 *__fastcall sub_5906C(int a1, int a2);
__int16 *__fastcall sub_590F4(int a1, int a2);
void __fastcall sub_591B8(int a1, int a2);
__int16 *__fastcall sub_59238(int a1);
int __fastcall sub_59630(int a1, int a2);
int __fastcall sub_59754(int a1, int a2);
void __fastcall sub_597D8(int a1, int a2);
int __fastcall sub_59858(int a1, int a2);
__int16 *__fastcall sub_599B8(_DWORD *a1);
void sub_59B70();
int __fastcall sub_59BB4(int a1, int a2);
__int16 *__fastcall sub_59C80(int a1, int a2);
char *__fastcall sub_5A694(char *result);
char *__fastcall sub_5A7D8(char *result, int a2);
char *__fastcall sub_5AB2C(int a1, int a2);
char *__fastcall sub_5ABDC(int a1, int a2);
void __fastcall sub_5AC94(int a1, int a2);
__int16 *__fastcall sub_5ACF0(_DWORD *a1);
int __fastcall sub_5B4C0(int a1, int a2);
__int16 *__fastcall sub_5B5DC(int a1, int a2);
void __fastcall sub_5B6B0(int a1, int a2);
_BYTE *__fastcall sub_5B730(int a1);
int __fastcall sub_5BD80(int a1, int a2);
void sub_5BEF8();
void __fastcall sub_5BF3C(int a1, int a2);
char *__fastcall sub_5BFCC(int a1);
int __fastcall sub_5C09C(unsigned __int8 *a1, _DWORD *a2);
int __fastcall sub_5C130(int a1, int a2);
int __fastcall sub_5C498(_BYTE *a1, char *s);
__int16 *__fastcall sub_5C588(int a1, int a2);
__int16 *__fastcall sub_5C6DC(__int16 *result);
__int16 *__fastcall sub_5CF78(int a1, int a2);
void __fastcall sub_5D048(int a1, int a2);
int __fastcall sub_5D0C8(int a1, int a2);
__int16 *__fastcall sub_5D1F8(int a1);
void sub_5D4C8();
void __fastcall sub_5D50C(int a1, int a2);
int __fastcall sub_5D58C(int a1, int a2);
__int16 *__fastcall sub_5D6B4(int a1);
int __fastcall sub_5D8D0(int a1, int a2);
Elf32_Dyn **__fastcall sub_5D924(Elf32_Dyn **result);
int __fastcall sub_5DFB4(int a1);
void __fastcall sub_5E260(int a1, int a2);
int __fastcall sub_5E2F0(int a1, int a2, int a3, int a4);
int __fastcall sub_5E478(int a1, int a2);
__int16 *__fastcall sub_5E78C(int a1, int a2);
int __fastcall sub_5EC18(double a1);
int __fastcall sub_5F600(double a1);
void sub_5F6E0();
int __fastcall sub_5F724(int *a1);
int sub_5FCA8();
int sub_5FF34();
int sub_602C8();
int __fastcall sub_60310(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4);
size_t __fastcall sub_606CC(int a1, int a2, int a3, int a4, int a5);
bool __fastcall sub_60770(int a1, int a2, int a3, int a4, int a5, int a6);
int __fastcall sub_6083C(int a1);
int __fastcall sub_60930(unsigned __int8 *a1, int *a2);
int __fastcall sub_60A30(char *s2, int a2);
int __fastcall sub_60AC0(const char *a1, int a2, int a3);
int __fastcall sub_612E0(int a1, int a2, int a3);
int sub_61520();
int *sub_615D8();
_DWORD *__fastcall sub_61680(int a1, _DWORD *a2, int a3);
_DWORD *__fastcall sub_61724(_DWORD *a1);
int __fastcall sub_6177C(_DWORD *a1);
int __fastcall sub_617D8(int result);
unsigned __int16 *__fastcall sub_61968(unsigned __int16 *result, unsigned __int16 *a2, unsigned int a3);
unsigned __int16 *__fastcall sub_61A8C(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3);
void *sub_61B14();
_DWORD *__fastcall sub_61BB0(int a1);
int __fastcall sub_61C70(int a1, __int16 a2, __int16 a3, int a4, int a5, int a6, int a7);
_DWORD *__fastcall sub_61DBC(int a1);
_DWORD *__fastcall sub_61F34(int a1);
bool __fastcall sub_61FD4(int a1);
int __fastcall sub_6204C(int a1);
_DWORD *__fastcall sub_621BC(int a1, unsigned int a2);
int __fastcall sub_622E0(int a1);
_DWORD *__fastcall sub_623A4(int a1, unsigned __int16 *a2);
int *__fastcall sub_624AC(int a1, __int16 a2, const void *a3, size_t a4, int a5);
void sub_625F8();
int sub_626D0();
size_t __fastcall sub_6278C(size_t result, int a2, int a3);
bool __fastcall sub_62854(int a1, int a2, int a3, unsigned int a4);
unsigned __int8 *__fastcall sub_6291C(unsigned __int8 **a1);
char *sub_62A30(char *result, unsigned __int8 *a2, ...);
void __fastcall sub_62AB4(_DWORD *ptr);
int __fastcall sub_62B28(const char *a1);
int __fastcall sub_63138(int a1, _BYTE *a2);
int __fastcall sub_631F0(unsigned __int16 *a1);
bool __fastcall sub_633D8(int a1, int a2, int a3, int a4, int a5, int a6, int *a7, _DWORD *a8);
int __fastcall sub_635A0(const char *a1, _DWORD *a2);
char *__fastcall sub_63804(unsigned int a1, unsigned int a2, int a3, int a4, int a5);
char *__fastcall sub_63AC4(signed int a1, unsigned int a2, int a3);
char *__fastcall sub_63B34(signed int a1, unsigned int a2, int a3);
void *__fastcall sub_63BA4(void *a1, size_t a2, size_t a3, int a4);
void *__fastcall sub_63C68(void *a1, unsigned int a2, unsigned int a3, int a4);
void *__fastcall sub_63D08(const char *a1);
void sub_63D78();
int __fastcall sub_63DC0(int a1, int a2);
int __fastcall sub_63F68(int a1, speed_t a2);
int __fastcall sub_64054(int a1, int a2, _DWORD *a3);
void sub_64244();
int __fastcall sub_642E4(const struct timeval *a1, const struct timezone *a2);
_BYTE *__fastcall sub_64648(unsigned int a1);
unsigned __int8 *__fastcall sub_64708(int a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall sub_647E0(_BYTE *a1, int a2, unsigned __int8 *a3, int a4);
char *__fastcall sub_648EC(int a1, char *s);
unsigned int __fastcall sub_64BBC(int a1, unsigned int a2, unsigned __int8 *a3, int *a4);
int __fastcall sub_64C44(int a1, unsigned __int8 *a2, int a3);
int sub_64CC4(int a1, unsigned __int8 *a2, ...);
int sub_64D28(unsigned __int8 *a1, ...);
unsigned int sub_64D9C(int a1, unsigned int a2, unsigned __int8 *a3, ...);
char *sub_64E00(int a1, unsigned __int8 *a2, ...);
char *__fastcall sub_64E88(int a1, unsigned __int8 *a2, int *a3);
int __fastcall sub_64EFC(char *s, int a2, int a3);
int __fastcall sub_64FEC(const char *a1, int a2);
const char *__fastcall sub_65384(const char *result);
_DWORD *__fastcall sub_65468(int *a1);
void *__fastcall sub_65578(time_t (**a1)(time_t *timer));
_QWORD *__fastcall sub_655EC(_QWORD *result);
int __fastcall sub_65644(int a1);
char *__fastcall sub_6568C(int a1);
int __fastcall sub_657A8(int a1, int a2, int a3);
_QWORD *__fastcall sub_65844(_QWORD *a1, int a2, time_t *timer);
_QWORD *__fastcall sub_658E8(_QWORD *a1, int a2, time_t *timer);
int *__fastcall sub_6598C(int *a1, int *a2);
unsigned int *__fastcall sub_65A30(unsigned int *a1, int a2, _BOOL4 *a3);
int *__fastcall sub_65B3C(int *a1, int a2, int a3);
int __fastcall sub_65BF4(int a1, int a2);
bool __fastcall sub_65CD8(_DWORD *a1, int a2);
unsigned int __fastcall sub_65D94(_BYTE *a1, int a2);
unsigned int __fastcall sub_65E40(_DWORD *a1, int a2);
int __fastcall sub_65EE8(_BYTE *a1, _DWORD *a2, int a3);
bool __fastcall sub_65F54(_DWORD *a1, _DWORD *a2, int a3);
int __fastcall sub_65FC0(_BYTE *a1, int *a2);
_QWORD *__fastcall sub_66038(_QWORD *result, int a2, int a3);
unsigned int __fastcall sub_66090(int a1);
unsigned int __fastcall sub_660F4(int a1);
_DWORD *__fastcall sub_66148(_DWORD *result, int a2);
int __fastcall sub_661F8(int a1, int a2, int a3);
int __fastcall sub_66274(int a1, unsigned int a2, int a3);
int __fastcall sub_6636C(int a1, int a2, int a3);
int __fastcall sub_663C0(_DWORD *a1);
int __fastcall sub_66428(unsigned __int16 *a1);
unsigned int __fastcall sub_6648C(int a1);
int __fastcall sub_664DC(int a1);
int __fastcall sub_6653C(int a1);
int __fastcall sub_665B0(unsigned __int8 *a1);
int __fastcall sub_66604(int *a1);
int __fastcall sub_66658(unsigned __int16 *a1);
int __fastcall sub_666D8(_BYTE *a1, int *a2);
int __fastcall sub_66750(_BYTE *a1, int a2, time_t *a3);
_QWORD *__fastcall sub_667B4(_QWORD *a1, unsigned __int16 *a2);
int __fastcall sub_66830(unsigned __int16 *a1);
int __fastcall sub_66884(int a1, int a2);
int __fastcall sub_668D4(int a1, int a2);
int __fastcall sub_66920(int a1, int a2);
int __fastcall sub_66970(int a1, int a2);
int __fastcall sub_669BC(int a1, int a2);
unsigned int __fastcall sub_66A0C(int a1);
_DWORD *__fastcall sub_66AAC(_DWORD *a1, int a2);
bool __fastcall sub_66B90(int a1, int *a2);
bool __fastcall sub_66CC4(int a1, int a2, time_t *a3);
_QWORD *__fastcall sub_66D28(_QWORD *a1, unsigned __int8 *a2);
int __fastcall sub_66DC4(unsigned __int8 *a1);
int sub_66E18();
int __fastcall sub_66EA4(const char *a1);
int sub_66FD8();
int __fastcall sub_6702C(int a1);
unsigned int sub_67190();
int sub_671FC();
int sub_67264();
int __fastcall sub_672B8(__int16 a1);
unsigned int sub_67318();
unsigned int sub_673DC();
_DWORD *__fastcall sub_67478(int a1, unsigned int a2);
bool __fastcall sub_67590(int ecode);
void __fastcall sub_6774C(int a1, char *a2, int a3, _DWORD *a4);
time_t __fastcall sub_67B04(time_t result, time_t a2, int *a3);
time_t __fastcall sub_67CA8(int *a1);
void __fastcall sub_67D40(int a1, unsigned __int16 *a2, int a3, _DWORD *a4);
int __fastcall sub_67F40(const char *a1, const char *a2, int *a3, int a4, int a5, int a6, int a7);
int __fastcall sub_681E0(int a1, int a2);
int __fastcall sub_68520(const char *a1, const char *a2, int *a3, int a4, int a5, int a6);
int __fastcall sub_68738(int a1, int a2);
unsigned int __fastcall sub_68A44(unsigned int a1, int a2, char **a3);
void __noreturn sub_68A8C();
unsigned int sub_68AE4();
void __fastcall sub_68B80(int a1);
char *__fastcall sub_68C64(int a1, int a2);
char *__fastcall sub_68E70(int a1);
char *__fastcall sub_68EBC(int a1);
int __fastcall sub_68F08(_QWORD *a1, int *a2);
int __fastcall sub_68FAC(int a1);
int __fastcall sub_69020(int a1);
int sub_6908C();
int __fastcall sub_69188(size_t a1, const void *a2, int a3, size_t a4, size_t a5);
int __fastcall sub_69350(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_693BC(int a1);
int sub_694B8();
int __fastcall sub_69588(int a1);
int sub_69654();
_BYTE *__fastcall sub_696EC(unsigned int a1);
_BYTE *__fastcall sub_697A8(unsigned int a1, int a2);
struct tm *__fastcall sub_6987C(__int64 *a1, int a2);
_BYTE *__fastcall sub_69A20(int *a1, int a2);
_BYTE *__fastcall sub_69C54(int *a1);
_BYTE *__fastcall sub_69CA0(int *a1);
struct tm *__fastcall sub_69CEC(int a1, int a2);
int sub_69D58();
int sub_69DAC();
int sub_69E00();
int sub_69E54();
int *__fastcall sub_69EA8(int a1);
char *__fastcall sub_69FA8(char *result);
char *__fastcall sub_6A044(char *result);
int sub_6A108();
int sub_6A1A4();
char *__fastcall sub_6A240(char *result);
int sub_6A3A0();
_BYTE *__fastcall sub_6A3FC(unsigned __int16 *a1);
int __fastcall sub_6A520(int result, int *a2, unsigned int a3, const char *a4, int a5, int a6, char a7);
int __fastcall sub_6A6BC(int a1, unsigned int *a2, unsigned int a3, int a4, __int64 a5, int a6, int a7, int a8, unsigned int a9);
int __fastcall sub_6AB20(double a1, unsigned int a2, int a3, int a4, unsigned int a5, _DWORD *a6);
unsigned int __fastcall sub_6B6F8(int a1, unsigned int a2, unsigned __int8 *a3, int *a4);
unsigned int sub_6C054(int a1, unsigned int a2, unsigned __int8 *a3, ...);
int __fastcall sub_6C0B8(int a1);
int __fastcall sub_6C26C(int a1);
_BYTE *__fastcall sub_6C2E8(unsigned __int16 *a1);
_BYTE *__fastcall sub_6C47C(unsigned __int16 *a1);
int __fastcall sub_6C568(unsigned __int16 *a1);
int __fastcall sub_6C60C(int *a1);
int sub_6C6B8();
int sub_6C714();
const char *__fastcall sub_6C7EC(int a1);
int __fastcall sub_6C910(unsigned __int8 *a1, int *a2);
char *__fastcall sub_6CC40(int a1);
_BYTE *__fastcall sub_6CCB0(int a1, const char *a2, int *a3, int a4);
_BYTE *__fastcall sub_6CE6C(int a1, _DWORD *a2);
_BYTE *__fastcall sub_6CF4C(int a1);
_BYTE *__fastcall sub_6D01C(int a1);
_BYTE *__fastcall sub_6D084(int a1);
_BYTE *__fastcall sub_6D0EC(int a1);
_BYTE *__fastcall sub_6D154(int a1, int a2);
_BYTE *__fastcall sub_6D3C4(int a1);
_BYTE *__fastcall sub_6D480(int a1);
int __fastcall sub_6D4DC(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_6D58C(unsigned __int8 *a1, char *s, int a3);
int __fastcall sigint_handler(int result);
int __fastcall sub_6D6F0(int a1, void (*a2)(int));
int __fastcall sub_6D7B0(int (__fastcall *a1)(_DWORD, _DWORD));
__int64 *__fastcall sub_6D854(__int64 *a1, unsigned __int8 *a2, unsigned __int8 **a3, int a4);
int __fastcall sub_6DA84(_QWORD *a1, _QWORD *a2);
int __fastcall sub_6DAF4(unsigned __int64 *a1, unsigned __int64 *a2);
int *__fastcall sub_6DBC0(int *result, _DWORD *a2, _DWORD *a3);
_QWORD *__fastcall sub_6DC24(_QWORD *result, _QWORD *a2, int a3);
_QWORD *__fastcall sub_6DCDC(_QWORD *result, _QWORD *a2, unsigned int a3);
_QWORD *__fastcall sub_6DD38(_QWORD *result, _QWORD *a2, unsigned int a3);
int __fastcall sub_6DD94(pthread_t *a1);
int __fastcall sub_6E078(sem_t *a1, struct timespec *abstime);
int __fastcall sub_6E128(int a1, int a2);
sem_t *__fastcall sub_6E26C(sem_t *a1, unsigned int value);
int __fastcall sub_6E2CC(int result);
void __fastcall __noreturn sub_6E36C(void *a1);
void __fastcall __noreturn blocking_thread(int a1);
int __fastcall sub_6E3C8(int a1, int a2);
void sub_6E4A8();
int __fastcall sub_6E544(int a1, size_t *a2, const void *a3);
int __fastcall sub_6E6E8(int a1, int a2);
int __fastcall sub_6E870(int a1);
int __fastcall sub_6E948(int a1);
int __fastcall sub_6EAE8(int a1);
int __fastcall sub_6EB58(int *a1, int a2, unsigned __int8 *a3, int *a4);
int sub_6EC04(int *a1, int a2, unsigned __int8 *a3, ...);
int __fastcall sub_6EC68(int a1, int a2, int a3);
void __fastcall __noreturn sub_6ECC0(const char *a1, int a2, int a3, const char *a4);
int (__fastcall *__fastcall sub_6ED00(int (__fastcall *result)(const char *a1, int a2, int a3, const char *a4)))(const char *a1, int a2, int a3, const char *a4);
const char *__fastcall sub_6ED7C(int a1);
int __fastcall sub_6EE20(const char *a1, int a2, int a3, const char *a4);
int __fastcall sub_6F058(int a1, int a2, int a3);
int __fastcall sub_6F0AC(int a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_6F1AC(int a1, _DWORD *a2, int a3);
int __fastcall sub_6F2DC(const char *a1, int a2, int a3, int a4);
int __fastcall sub_6F380(const char *a1, int a2, int a3, int a4);
int (__fastcall *__fastcall sub_6F45C(int (__fastcall *result)(const char *a1, int a2, int a3, int a4)))(const char *a1, int a2, int a3, int a4);
int (__fastcall *__fastcall sub_6F4D8(int (__fastcall *result)(const char *a1, int a2, int a3, int a4)))(const char *a1, int a2, int a3, int a4);
int sub_6F554(const char *a1, int a2, int a3, ...);
void __noreturn sub_6F5C8(const char *a1, int a2, int a3, ...);
void __fastcall __noreturn sub_6F61C(const char *a1, int a2, const char *a3);
int __fastcall sub_6F69C(int a1);
char *__fastcall sub_6F718(char *result, int a2, int a3, int a4);
int __fastcall sub_6F874(int a1);
int __fastcall sub_6FD38(int a1, _DWORD *a2);
int __fastcall sub_6FFC4(int a1, void *dest); // idb
int __fastcall sub_70050(_DWORD *a1);
int __fastcall sub_70164(_DWORD *a1);
void __fastcall sub_70284(_DWORD **a1);
_DWORD *sub_70388();
int sub_703E8();
char *__fastcall sub_704E0(int a1);
int __fastcall sub_70610(_DWORD *a1, unsigned int a2, int a3, int a4);
int __fastcall sub_707C8(int a1);
int __fastcall sub_70C0C(_DWORD *a1);
void __fastcall sub_70CC0(_DWORD **a1);
char *__fastcall sub_70F38(int a1, _DWORD *a2);
void __fastcall sub_710C8(void **a1);
_DWORD *__fastcall sub_71240(_DWORD *result, int *a2);
const char *__fastcall sub_71360(_DWORD *a1, char *s2);
_DWORD *__fastcall sub_71458(_DWORD *result, int *a2);
const char *__fastcall sub_71578(_DWORD *a1, char *s2);
int __fastcall sub_71670(_DWORD *a1, const char *a2, int a3, int a4, int *a5, int a6);
int __fastcall sub_71914(_DWORD *a1, void **a2);
int __fastcall sub_71B68(int a1, _DWORD *a2, int *a3);
int __fastcall sub_71D84(_DWORD *a1, char *s1, unsigned int a3, int a4);
int __fastcall sub_71F68(int result);
int __fastcall sub_71FBC(int a1, int a2);
int __fastcall sub_72120(_DWORD *a1);
_DWORD *__fastcall sub_721A8(_DWORD *result, int a2);
int __fastcall sub_72230(_DWORD *a1);
bool __fastcall sub_722B8(_DWORD *a1, const char *a2);
int __fastcall sub_7239C(_DWORD *a1);
void __fastcall sub_72424(const char *ident, int option, int facility);
int __fastcall sub_7246C(int a1);
int __fastcall sub_725B8(int a1, int a2);
int __fastcall sub_72648(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7, int a8, int a9, int *a10);
int sub_73300(int a1, int a2, int a3, int a4, int a5, ...);
int __fastcall sub_7344C(int a1, int a2, int a3, int a4, int a5, int *a6);
int sub_734BC(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, int a8, ...);
int sub_735B0(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, int a8, ...);
_DWORD *__fastcall sub_736A4(int a1, _DWORD *a2);
void __fastcall sub_73770(_DWORD **a1);
int __fastcall sub_73830(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_7393C(int a1);
int sub_73B50();
int sub_73BB8();
int sub_73C50();
int sub_73CA8();
int sub_73D00();
int sub_73F34();
int sub_7408C();
int sub_740D8();
int sub_74174();
int __fastcall sub_74210(int a1, _WORD *a2, _WORD *a3);
int sub_742A4();
int sub_74308();
int sub_7436C();
int sub_743D0();
bool __fastcall sub_74434(int *a1, _DWORD *a2);
bool __fastcall sub_74518(_DWORD *a1, _DWORD *a2, unsigned int a3);
int __fastcall sub_74680(int *a1, _DWORD *a2);
int __fastcall sub_74908(_DWORD *a1, unsigned int a2);
int __fastcall sub_749DC(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_74B04(_DWORD *result, int *a2);
int __fastcall sub_74B70(_DWORD *a1, int *a2);
int sub_74BE0();
_DWORD *__fastcall sub_74C28(_DWORD *result, int a2);
int __fastcall sub_74CA0(int a1);
_DWORD *__fastcall sub_74CE8(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_74DA8(_DWORD *result);
uint32_t __fastcall sub_74E0C(_DWORD *a1);
bool __fastcall sub_74E78(_DWORD *a1);
int __fastcall sub_74F00(_DWORD *a1);
int __fastcall sub_74F64(_DWORD *a1);
int __fastcall sub_74FD0(_DWORD *a1);
_DWORD *__fastcall sub_7503C(_DWORD *result, _DWORD *a2);
int __fastcall sub_7511C(int a1, unsigned int a2, int a3, int a4, int a5);
int sub_752E0();
int sub_75400();
int __fastcall sub_754A0(unsigned int a1);
int __fastcall sub_755E0(int a1, unsigned int a2, int a3, int a4, int a5);
int __fastcall sub_75654(int a1, int a2, int *a3);
int __fastcall sub_756E4(FILE *a1);
int __fastcall sub_75768(FILE *a1, int a2, int a3);
int __fastcall sub_757EC(void *a1, size_t a2, size_t a3, FILE *stream, size_t *a5);
int __fastcall sub_758B0(const void *a1, size_t a2, size_t a3, FILE *stream, size_t *a5);
int __fastcall sub_7595C(FILE *a1);
int __fastcall sub_759E0(FILE *a1);
int sub_75A78();
int __fastcall sub_75B10(int a1, int a2, unsigned int a3);
_DWORD *__fastcall sub_75CAC(_DWORD *result, int a2, unsigned int a3);
bool __fastcall sub_75D54(int a1);
_DWORD *__fastcall sub_75E0C(_DWORD *result, int a2, unsigned int a3);
_DWORD *__fastcall sub_75EB4(_DWORD *result);
bool __fastcall sub_75F30(int a1);
int __fastcall sub_75FE8(__time_t *a1);
int __fastcall sub_7614C(int *a1, int *a2);
int __fastcall sub_76378(unsigned int *a1, unsigned int *a2);
int __fastcall sub_76468(int *a1, int *a2, int *a3);
int __fastcall sub_765A8(unsigned int *a1, unsigned int *a2, unsigned int *a3);
int __fastcall sub_766E0(unsigned int *a1, unsigned int *a2);
int __fastcall sub_767E8(_DWORD *a1);
int *__fastcall sub_76894(int *result, int *a2);
unsigned int __fastcall sub_76950(int a1);
unsigned int __fastcall sub_769F8(time_t *a1, char *a2, size_t a3);
size_t __fastcall sub_76B14(time_t *a1, char *a2, size_t a3);
size_t __fastcall sub_76BDC(time_t *a1, char *a2, size_t a3);
unsigned int __fastcall sub_76CA4(int *a1, unsigned int *a2);
int __fastcall sub_7819C(int result);
void *__fastcall sub_78250(void *a1);
void *__fastcall sub_782A0(int *a1, char *src, size_t n);
void *__fastcall sub_783E8(int *a1, int a2);
int __fastcall sub_78564(int result, unsigned __int8 *a2, int a3);
int __fastcall sub_78614(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall sub_786B8(int a1);
const char *sub_78740();
const char *__fastcall sub_78840(time_t a1);
_DWORD *__fastcall sub_78914(_DWORD *result, int a2, int a3);
_DWORD *__fastcall sub_789B8(_DWORD *result);
void *__fastcall sub_78A30(int a1, void *dest, size_t a3);
_DWORD *__fastcall sub_78AEC(_DWORD *result);
int __fastcall sub_78BE8(int result, _QWORD *a2);
_DWORD *__fastcall sub_78CA0(_DWORD *result, _QWORD *a2);
_DWORD *__fastcall sub_78D5C(_DWORD *result, _QWORD *a2);
_DWORD *__fastcall sub_78E1C(_DWORD *result, int a2);
_DWORD *__fastcall sub_78EDC(_DWORD *result, unsigned int a2);
_DWORD *__fastcall sub_78FB0(_DWORD *result);
_DWORD *__fastcall sub_79044(_DWORD *result, _QWORD *a2);
_DWORD *__fastcall sub_79100(_DWORD *result, _QWORD *a2);
_DWORD *__fastcall sub_791C8(_DWORD *result, unsigned int *a2);
_DWORD *__fastcall sub_792A4(_DWORD *result, int a2);
_DWORD *__fastcall sub_79364(_DWORD *result);
_DWORD *__fastcall sub_793F0(_DWORD *result, int a2);
_DWORD *__fastcall sub_794B0(_DWORD *result, unsigned int a2);
void *__fastcall sub_7956C(int a1);
int __fastcall sub_7962C(_DWORD *a1);
int __fastcall sub_796F4(_DWORD *a1, char a2);
int __fastcall sub_797BC(_DWORD *a1);
int __fastcall sub_79890(_DWORD *a1, __int16 a2);
unsigned int __fastcall sub_79964(_DWORD *a1, unsigned int a2);
unsigned int __fastcall sub_79A40(_DWORD *a1);
unsigned int __fastcall sub_79B10(_DWORD *a1, unsigned int a2);
unsigned int __fastcall sub_79BF4(_DWORD *a1);
_DWORD *__fastcall sub_79CE8(_DWORD *result, int a2, int a3, __int16 a4);
void *__fastcall sub_79DF0(_DWORD *a1, const void *a2, size_t a3);
unsigned int __fastcall sub_79EC8(_DWORD *a1, char *s);
int __fastcall sub_79FE0(_DWORD *a1, int a2);
int __fastcall sub_7A0D4(int a1, _DWORD *a2, int a3);
void __fastcall sub_7A1B4(_DWORD **a1);
int __fastcall sub_7A2B0(int result);
int __fastcall sub_7A33C(int a1, char *s); // idb
int __fastcall sub_7A4A4(int a1);
int __fastcall sub_7A584(_DWORD *a1);
int __fastcall sub_7A620(_DWORD *a1);
int __fastcall sub_7A6B8(const char *a1);
int __fastcall sub_7A768(int a1);
int __fastcall sub_7A7DC(const char *a1);
int __fastcall sub_7A990(int a1, const char *a2, int a3);
int __fastcall sub_7AC88(int a1, int a2);
int __fastcall sub_7AD44(int a1, _DWORD *a2);
int __fastcall sub_7AE04(const char *a1, _DWORD *a2);
int __fastcall sub_7AEFC(char *a1, char *s, unsigned __int8 *a3, unsigned int a4);
int __fastcall sub_7B074(char *a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall sub_7B0D0(const char *a1, char *to);
int __fastcall sub_7B2F0(const char *a1, int a2, FILE **a3);
int __fastcall sub_7B5A8(const char *a1, FILE **a2);
int __fastcall sub_7B5F8(const char *a1, FILE **a2);
int __fastcall sub_7B648(const char *a1);
int __fastcall sub_7B6F4(const char *a1, const char *a2);
bool __fastcall sub_7B7D0(int a1);
int __fastcall sub_7B84C(int a1);
bool __fastcall sub_7B8F4(unsigned __int8 *a1);
int __fastcall sub_7B974(_BYTE *a1);
bool __fastcall sub_7B9FC(unsigned __int8 *a1);
const char *__fastcall sub_7BA8C(const char *a1);
int __fastcall sub_7BB10(const char *a1, void *a2, size_t a3);
int __fastcall sub_7BBDC(char *a1, int a2, size_t size);
int sub_7BD40();
int __fastcall sub_7BDC8(int a1, FILE **a2);
int __fastcall sub_7BF38(int a1, char *a2, _DWORD *a3, char **a4);
void sub_7C06C();
int sub_7C0C8();
void __fastcall sub_7C160(unsigned int a1);
unsigned int __fastcall sub_7C1B4(unsigned int *a1);
unsigned int __fastcall sub_7C24C(unsigned int result, unsigned int a2);
int __fastcall sub_7C2F0(int a1, _DWORD *a2);
void __fastcall sub_7C38C(_DWORD *a1);
const char *__fastcall sub_7C420(const char *a1);
void __fastcall optionNumericVal(unsigned int a1, int a2);
int __fastcall sub_7C6DC(int result, const char *a2, const char *a3, const char *a4);
int __fastcall sub_7C7A4(FILE *a1, int a2, const char *a3);
int __fastcall sub_7C924(unsigned int a1, _DWORD *a2, const char **a3, int a4);
unsigned int __fastcall sub_7CC34(const char *a1, unsigned int a2, _DWORD *a3, const char **a4, unsigned int a5);
void __fastcall __noreturn sub_7CE5C(int status); // idb
void __fastcall __noreturn sub_7CEC0(int a1);
void __fastcall __noreturn sub_7CF18(int a1, int a2, int a3);
int __fastcall sub_7CFA4(int result, int a2, int a3, _DWORD *a4);
int __fastcall sub_7D420(char a1, char **a2);
int __fastcall sub_7D588(char a1, char **a2);
int __fastcall sub_7D768(int a1, int a2, int a3);
int __fastcall sub_7D81C(int a1, const char **a2, const char *a3, int a4);
int __fastcall sub_7D90C(const char *a1);
int __fastcall sub_7DB8C(int a1, int a2);
int __fastcall sub_7DC70(int a1, void ***a2);
int __fastcall sub_7DE38(const char *a1);
int __fastcall sub_7DFF0(int a1, unsigned int a2, _DWORD *a3, _DWORD *a4);
size_t __fastcall sub_7E1AC(int *a1, unsigned __int16 *a2, const char **a3, const char **a4);
char *__fastcall sub_7E2F8(int a1);
int __fastcall sub_7E3DC(_DWORD *a1, _DWORD *a2);
void __fastcall __noreturn sub_7E624(const char *a1);
char *__fastcall sub_7E680(char *result);
int __fastcall sub_7E784(int **a1, int a2);
int __fastcall sub_7E89C(int **a1, const void *a2, size_t a3, const char *a4, int a5);
size_t __fastcall sub_7EAC8(const char **a1, int a2);
int __fastcall sub_7ED38(int a1);
int __fastcall sub_7EE38(const char *a1, _DWORD *a2, _DWORD *a3, int *a4);
int __fastcall sub_7F000(int a1);
int __fastcall sub_7F19C(_DWORD *a1, _DWORD *a2);
void __fastcall optionPagedUsage(int a1, int a2);
char *__fastcall sub_7F530(int a1, const char **a2);
char *__fastcall sub_7F9CC(const char *a1, const char *a2);
_DWORD *__fastcall sub_7FDCC(_DWORD *result, unsigned __int16 *a2, int a3);
int __fastcall sub_806BC(_DWORD *a1, int a2, int a3);
int __fastcall sub_80B6C(const char *a1);
int __fastcall sub_8121C(const char *a1, int a2);
int __fastcall sub_812E0(const char *a1, int a2);
const char *__fastcall sub_813A4(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_817F8(_DWORD *a1, int a2, unsigned int a3);
void __fastcall sub_81938(unsigned int a1, int a2);
int __fastcall sub_81A54(int a1, int a2);
int __fastcall sub_81B34(_DWORD *a1, char *s2);
_DWORD *__fastcall sub_81C08(int a1, char *s2, int a3);
int __fastcall sub_81D14(_DWORD *a1, int a2);
int __fastcall sub_81DDC(char *a1, _BYTE *a2, char a3);
char *__fastcall sub_821C8(unsigned __int8 *a1, int *a2);
int **__fastcall sub_82410(char *a1, const void *a2, size_t a3);
int __fastcall sub_83400(int a1, int a2);
const char *__fastcall sub_83478(unsigned int a1, _DWORD *a2, const char **a3, unsigned int a4);
int __fastcall sub_835B8(int a1);
void __fastcall sub_83C64(unsigned int a1, _DWORD *a2, char a3, int a4);
int __fastcall sub_83F7C(_BYTE *a1, unsigned int a2, char *s, const char *a4);
int __fastcall sub_84264(_DWORD *a1, const char *a2, const char *a3);
void __fastcall sub_843E0(_DWORD *a1);
void __fastcall sub_8446C(unsigned int a1, int a2);
int __fastcall sub_8455C(unsigned int a1, _DWORD *a2, int a3, int a4);
_BYTE *__fastcall sub_84784(_BYTE *a1, char *s);
void __fastcall sub_84A50(_BYTE *a1, FILE *a2);
char *__fastcall sub_85098(void *src);
void __fastcall sub_85140(void *dest);
char *__fastcall sub_85234(int a1);
void __fastcall sub_85318(int *a1);
void __fastcall sub_857E4(unsigned int a1, int a2);
unsigned int __fastcall sub_85948(unsigned int result, int a2);
int __fastcall sub_859EC(unsigned __int8 *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_85A98(int a1, char *src, int *a3);
char *__fastcall sub_85F40(int a1, int *a2, char *s, int a4, int a5);
void __fastcall sub_862F0(int a1, char *s);
int __fastcall sub_8639C(unsigned int a1, int a2);
int *__fastcall sub_86524(int *result, int a2);
int __fastcall sub_867CC(_DWORD *a1, int *a2);
int __fastcall sub_869AC(int a1); // idb
int __fastcall sub_86AD8(int a1); // idb
unsigned __int8 *__fastcall sub_86C00(int a1, char *a2);
char *__fastcall sub_86D90(int *a1, unsigned __int8 *a2);
char *__fastcall sub_87004(int a1, int a2);
int __fastcall sub_87100(unsigned __int8 *a1, unsigned __int8 *a2);
char *__fastcall sub_87194(void ***a1, char *name, int a3, int a4);
unsigned int __fastcall sub_87354(unsigned int result, unsigned int a2, int a3);
char *__fastcall sub_87404(char *result);
int __fastcall sub_87480(int *a1, char *s);
_BYTE *__fastcall sub_87650(_BYTE *result, int a2);
int __fastcall sub_876C0(int a1, int a2, int a3, int *a4);
int __fastcall sub_8791C(int a1);
int __fastcall sub_879A8(int a1, int a2, int a3);
int __fastcall sub_884D4(int result);
int __fastcall sub_88688(int *a1, char *a2);
unsigned int __fastcall optionLoadOpt(unsigned int result, int a2);
int **__fastcall sub_887E4(const char *a1);
void __fastcall sub_888C4(unsigned int a1, int a2);
void __fastcall sub_889B4(unsigned int a1, int a2);
int *__fastcall sub_88A20(char *a1);
unsigned int __fastcall sub_88E84(unsigned int result, int a2);
unsigned int __fastcall sub_8909C(unsigned int a1, int a2, char **a3);
int __fastcall sub_89944(_DWORD *a1, int a2);
void __fastcall sub_89A3C(char *a1, int a2, FILE *a3);
void __fastcall __noreturn sub_89BE8(int a1, int a2);
void __fastcall __noreturn sub_8A30C(int a1, int a2);
void __noreturn sub_8A4F0();
const char *sub_8A534();
int __fastcall sub_8A588(int a1, _DWORD *a2, _BYTE **a3, FILE *stream, char a5);
unsigned int __fastcall optionPrintVersion(unsigned int result, int a2);
size_t __fastcall sub_8A95C(unsigned int a1, int a2, int a3);
unsigned int __fastcall sub_8B580(unsigned int result, int a2);
unsigned int __fastcall sub_8B61C(unsigned int result, int a2);
unsigned int __fastcall sub_8B690(unsigned int result, unsigned int a2);
unsigned int __fastcall sub_8B8EC(unsigned int a1, unsigned int a2);
int __fastcall sub_8B908(int a1, int a2);
int __fastcall sub_8B90E(int result, unsigned int a2);
int __fastcall sub_8BB9C(int a1, unsigned int a2);
int __fastcall sub_8BEC4(__int64 a1);
int __fastcall sub_8BF30(signed __int64 a1, signed __int64 a2);
int __fastcall sub_8BFD0(unsigned __int64 a1, unsigned __int64 a2);
unsigned int __fastcall sub_8C010(double a1);
int __fastcall sub_8C050(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall _libc_csu_init(int a1, int a2, int a3);
int __fastcall sub_8C1A8(void (*a1)(void *));
void term_proc();
// struct tm *localtime(const time_t *timer);
// void free(void *ptr);
// time_t time(time_t *timer);
// int getc(FILE *stream);
// struct tm *gmtime(const time_t *timer);
// int __cxa_finalize(void *);
// int ITM_deregisterTMCloneTable(void); weak
// int ITM_registerTMCloneTable(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_4 = '\x01'; // weak
char byte_5 = '\x01'; // weak
char byte_6 = '\x01'; // weak
char byte_7 = '\0'; // weak
char byte_8[] = { '\0' }; // weak
char byte_9[7] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
__int16 word_10 = 3; // weak
int dword_14 = 1; // weak
_UNKNOWN *off_18 = (_UNKNOWN *)0xC6B1; // weak
int dword_1C = 52; // weak
int dword_20 = 689972; // weak
int dword_24 = 83887104; // weak
__int16 word_28 = 52; // weak
__int16 word_2C = 9; // weak
__int16 word_32 = 26; // weak
int dword_4C = 4; // weak
int dword_50 = 4; // weak
int dword_60 = 52; // weak
int dword_64 = 288; // weak
int dword_80 = 340; // weak
int dword_84 = 25; // weak
int dword_88 = 25; // weak
int dword_8C = 4; // weak
int dword_90 = 1; // weak
int dword_D0 = 65536; // weak
int dword_110 = 4; // weak
int dword_140 = 734936; // weak
int dword_150 = 1; // weak
char aLibLdLinuxArmh[25] = "/lib/ld-linux-armhf.so.3"; // weak
int dword_180[4] = { 0, 3, 2, 0 }; // weak
int elf_hash_bucket[521] =
{
  0,
  512,
  0,
  469,
  521,
  618,
  0,
  482,
  564,
  548,
  0,
  508,
  562,
  341,
  178,
  0,
  536,
  537,
  651,
  569,
  0,
  340,
  147,
  245,
  586,
  556,
  0,
  166,
  527,
  0,
  0,
  402,
  0,
  0,
  428,
  580,
  0,
  277,
  506,
  0,
  610,
  65,
  56,
  0,
  466,
  254,
  0,
  502,
  0,
  222,
  0,
  0,
  640,
  450,
  492,
  590,
  316,
  0,
  498,
  337,
  431,
  419,
  458,
  257,
  484,
  420,
  0,
  0,
  260,
  535,
  275,
  632,
  0,
  0,
  583,
  637,
  511,
  530,
  7,
  550,
  412,
  617,
  444,
  0,
  95,
  199,
  465,
  306,
  91,
  8,
  584,
  77,
  0,
  174,
  568,
  596,
  413,
  268,
  228,
  479,
  282,
  0,
  0,
  263,
  0,
  372,
  20,
  514,
  574,
  459,
  497,
  563,
  242,
  5,
  176,
  307,
  280,
  140,
  646,
  468,
  286,
  374,
  633,
  25,
  411,
  0,
  587,
  534,
  385,
  367,
  146,
  595,
  212,
  604,
  0,
  659,
  322,
  0,
  433,
  546,
  495,
  150,
  233,
  131,
  650,
  408,
  272,
  467,
  59,
  204,
  206,
  171,
  0,
  0,
  0,
  566,
  276,
  161,
  134,
  472,
  177,
  141,
  380,
  0,
  462,
  626,
  283,
  0,
  369,
  398,
  539,
  129,
  0,
  0,
  0,
  0,
  526,
  0,
  0,
  0,
  409,
  0,
  384,
  0,
  0,
  524,
  528,
  455,
  591,
  0,
  0,
  647,
  532,
  10,
  605,
  0,
  627,
  648,
  0,
  0,
  0,
  663,
  0,
  0,
  261,
  613,
  229,
  655,
  588,
  571,
  86,
  33,
  393,
  491,
  27,
  338,
  426,
  0,
  0,
  606,
  152,
  0,
  486,
  404,
  0,
  0,
  423,
  165,
  547,
  407,
  376,
  0,
  208,
  321,
  58,
  343,
  631,
  625,
  346,
  0,
  153,
  0,
  167,
  221,
  645,
  295,
  0,
  237,
  76,
  629,
  0,
  13,
  582,
  0,
  552,
  652,
  487,
  394,
  608,
  553,
  579,
  630,
  449,
  400,
  488,
  589,
  0,
  0,
  15,
  642,
  612,
  63,
  68,
  36,
  494,
  549,
  0,
  67,
  80,
  656,
  499,
  0,
  0,
  24,
  203,
  0,
  616,
  559,
  558,
  0,
  82,
  403,
  635,
  525,
  71,
  437,
  662,
  452,
  266,
  0,
  0,
  594,
  0,
  0,
  601,
  0,
  555,
  390,
  0,
  611,
  183,
  643,
  661,
  540,
  543,
  531,
  0,
  638,
  353,
  0,
  0,
  483,
  0,
  396,
  0,
  358,
  607,
  0,
  0,
  365,
  561,
  0,
  227,
  598,
  609,
  464,
  424,
  639,
  0,
  309,
  314,
  236,
  78,
  0,
  523,
  100,
  198,
  0,
  0,
  85,
  18,
  336,
  575,
  636,
  410,
  60,
  628,
  360,
  657,
  634,
  0,
  180,
  507,
  264,
  0,
  0,
  299,
  481,
  654,
  201,
  0,
  42,
  330,
  505,
  0,
  0,
  302,
  243,
  614,
  0,
  0,
  445,
  315,
  0,
  0,
  493,
  143,
  0,
  658,
  274,
  621,
  581,
  623,
  0,
  252,
  0,
  542,
  158,
  0,
  0,
  0,
  496,
  572,
  517,
  504,
  0,
  26,
  269,
  186,
  0,
  319,
  308,
  460,
  265,
  519,
  294,
  0,
  253,
  0,
  644,
  0,
  457,
  545,
  430,
  0,
  255,
  326,
  117,
  649,
  348,
  653,
  370,
  391,
  159,
  0,
  432,
  474,
  513,
  622,
  570,
  377,
  235,
  108,
  397,
  567,
  38,
  518,
  0,
  421,
  0,
  577,
  442,
  456,
  238,
  118,
  318,
  434,
  0,
  599,
  267,
  477,
  565,
  0,
  0,
  0,
  538,
  592,
  112,
  0,
  215,
  416,
  0,
  660,
  0,
  0,
  19,
  0,
  50,
  111,
  516,
  470,
  241,
  480,
  0,
  0,
  122,
  0,
  0,
  154,
  0,
  347,
  557,
  544,
  88,
  503,
  90,
  0,
  541,
  335,
  522,
  440,
  473,
  246,
  0,
  378,
  368,
  0,
  284,
  578,
  0,
  624,
  194,
  476,
  435,
  0,
  226,
  256,
  0,
  438,
  597,
  489
}; // weak
Elf32_Rel stru_80F8 = { 740280u, 23u }; // weak
Elf32_Dyn **off_C6E8 = (Elf32_Dyn **)0xA8E9C; // weak
char *off_1517C = &loc_78644; // weak
char *off_15180 = &off_78550; // weak
_UNKNOWN loc_1F31C; // weak
_UNKNOWN loc_20020; // weak
char *off_23AB0 = &loc_70C28; // weak
_UNKNOWN loc_30008; // weak
_UNKNOWN loc_40020; // weak
_UNKNOWN loc_75300; // weak
_UNKNOWN loc_7A120; // weak
_UNKNOWN loc_80100; // weak
_UNKNOWN loc_83124; // weak
_UNKNOWN loc_8B6C8; // weak
_UNKNOWN loc_8B950; // weak
unsigned __int8 byte_8C1D4[4] = { 37u, 103u, 0u, 0u }; // weak
__int16 asc_8E108[436] =
{
  11,
  -175,
  2,
  -215,
  -215,
  -215,
  3,
  -215,
  93,
  9,
  -138,
  -215,
  93,
  -215,
  66,
  -40,
  -215,
  -93,
  -215,
  -87,
  -82,
  -215,
  -215,
  -81,
  -215,
  -215,
  -40,
  20,
  210,
  -40,
  -215,
  -215,
  -70,
  -215,
  -67,
  -215,
  -215,
  34,
  6,
  -13,
  47,
  -6,
  -215,
  -215,
  -48,
  66,
  -45,
  -215,
  412,
  483,
  -39,
  -60,
  62,
  -215,
  -215,
  -215,
  127,
  203,
  -63,
  -215,
  -40,
  -215,
  -40,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -11,
  75,
  -24,
  -22,
  -215,
  -18,
  -215,
  -215,
  -53,
  -215,
  -215,
  -215,
  48,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  93,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  9,
  -215,
  82,
  120,
  -215,
  93,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  86,
  -215,
  4,
  373,
  -215,
  -215,
  -215,
  -81,
  -215,
  -215,
  -40,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  210,
  -215,
  106,
  -40,
  -215,
  -215,
  15,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  6,
  -215,
  105,
  146,
  151,
  105,
  -30,
  -215,
  -215,
  -215,
  -215,
  -6,
  -215,
  117,
  -21,
  -215,
  66,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  412,
  -215,
  -11,
  22,
  -215,
  -215,
  -215,
  -20,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  483,
  -215,
  128,
  -11,
  -215,
  -215,
  -215,
  129,
  -60,
  -215,
  -215,
  -215,
  132,
  -215,
  10,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  1,
  -133,
  -215,
  -215,
  -215,
  -215,
  -215,
  134,
  -215,
  41,
  -215,
  -215,
  -215,
  -215,
  -28,
  42,
  -215,
  -215,
  -215,
  -215,
  45,
  148,
  -215,
  -215,
  86,
  -215,
  -11,
  -20,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  150,
  -215,
  105,
  105,
  -215,
  -39,
  -215,
  -215,
  -215,
  51,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -57,
  178,
  -215,
  -215,
  -215,
  288,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -115,
  25,
  23,
  -215,
  -215,
  -215,
  -215,
  61,
  -215,
  -215,
  21,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  477,
  -215,
  -215,
  477,
  105,
  477,
  201,
  -39,
  169,
  -215,
  172,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -59,
  -215,
  77,
  36,
  52,
  -100,
  -215,
  39,
  -215,
  -11,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  -215,
  477,
  477,
  -215,
  -215,
  -215,
  -215,
  -215,
  43,
  -215,
  -215,
  -215,
  -40,
  -215,
  -215,
  -215,
  55,
  -215,
  477,
  -215,
  -215,
  49,
  56,
  -11,
  54,
  -166,
  -215,
  67,
  -11,
  -215,
  -215,
  -215,
  70,
  63,
  -215,
  -215,
  -215,
  -215,
  -215,
  124,
  85,
  64,
  -215,
  89,
  -215,
  -11,
  -215,
  -215
}; // weak
_UNKNOWN unk_8E470; // weak
_UNKNOWN unk_8EB6C; // weak
_UNKNOWN unk_8F09C; // weak
unsigned __int16 word_8F54C[1304] =
{
  0u,
  378u,
  378u,
  382u,
  383u,
  384u,
  399u,
  400u,
  401u,
  402u,
  403u,
  404u,
  405u,
  406u,
  407u,
  408u,
  409u,
  410u,
  411u,
  412u,
  420u,
  430u,
  431u,
  432u,
  433u,
  434u,
  438u,
  439u,
  444u,
  449u,
  451u,
  457u,
  458u,
  466u,
  467u,
  468u,
  472u,
  477u,
  478u,
  479u,
  480u,
  481u,
  482u,
  483u,
  484u,
  488u,
  490u,
  495u,
  496u,
  497u,
  498u,
  499u,
  500u,
  504u,
  509u,
  518u,
  528u,
  529u,
  539u,
  541u,
  543u,
  545u,
  556u,
  563u,
  565u,
  570u,
  572u,
  574u,
  576u,
  578u,
  588u,
  594u,
  595u,
  603u,
  605u,
  617u,
  618u,
  619u,
  620u,
  621u,
  630u,
  635u,
  640u,
  648u,
  650u,
  652u,
  654u,
  659u,
  660u,
  661u,
  662u,
  663u,
  664u,
  665u,
  666u,
  667u,
  671u,
  672u,
  681u,
  683u,
  692u,
  702u,
  707u,
  715u,
  716u,
  717u,
  718u,
  719u,
  720u,
  721u,
  722u,
  727u,
  728u,
  736u,
  746u,
  755u,
  770u,
  775u,
  776u,
  780u,
  781u,
  785u,
  786u,
  787u,
  788u,
  789u,
  790u,
  791u,
  800u,
  804u,
  808u,
  816u,
  824u,
  832u,
  847u,
  862u,
  875u,
  876u,
  896u,
  897u,
  905u,
  906u,
  907u,
  908u,
  909u,
  910u,
  911u,
  912u,
  913u,
  914u,
  915u,
  916u,
  917u,
  918u,
  919u,
  920u,
  921u,
  925u,
  930u,
  938u,
  943u,
  944u,
  945u,
  949u,
  954u,
  962u,
  967u,
  968u,
  969u,
  970u,
  971u,
  972u,
  973u,
  974u,
  982u,
  992u,
  997u,
  1005u,
  1007u,
  1009u,
  1018u,
  1020u,
  1025u,
  1026u,
  1030u,
  1031u,
  1032u,
  1033u,
  1041u,
  1046u,
  1051u,
  1059u,
  1064u,
  1065u,
  1066u,
  1075u,
  1077u,
  1082u,
  1087u,
  1095u,
  1097u,
  1114u,
  1115u,
  1116u,
  1117u,
  1118u,
  1119u,
  1123u,
  1124u,
  1125u,
  1126u,
  1127u,
  1128u,
  1136u,
  1141u,
  1146u,
  1154u,
  1159u,
  1160u,
  1161u,
  1162u,
  1163u,
  1164u,
  1165u,
  1166u,
  1167u,
  1168u,
  1177u,
  1178u,
  1179u,
  1186u,
  1193u,
  1200u,
  1216u,
  1235u,
  1237u,
  1239u,
  1241u,
  1243u,
  1245u,
  1252u,
  1257u,
  1258u,
  1259u,
  1263u,
  1267u,
  1276u,
  1277u,
  1281u,
  1282u,
  1283u,
  1287u,
  1298u,
  1316u,
  1328u,
  1333u,
  1335u,
  1340u,
  1341u,
  1349u,
  1351u,
  1359u,
  1364u,
  1372u,
  1397u,
  1404u,
  1414u,
  1415u,
  1419u,
  1420u,
  1421u,
  1422u,
  1426u,
  1427u,
  1428u,
  1432u,
  1437u,
  1442u,
  1450u,
  1451u,
  1452u,
  1453u,
  1454u,
  1455u,
  1456u,
  1466u,
  1471u,
  1479u,
  1484u,
  1492u,
  1494u,
  1498u,
  1503u,
  1508u,
  1516u,
  1521u,
  1529u,
  1538u,
  1539u,
  1543u,
  1544u,
  1548u,
  1556u,
  1574u,
  1578u,
  1583u,
  1591u,
  1596u,
  1597u,
  1601u,
  1606u,
  1614u,
  1619u,
  1624u,
  1629u,
  1634u,
  1642u,
  1647u,
  1652u,
  1660u,
  1665u,
  1666u,
  1667u,
  1668u,
  1669u,
  0u,
  0u,
  1u,
  10u,
  16u,
  17u,
  18u,
  24u,
  25u,
  31u,
  32u,
  35u,
  37u,
  39u,
  40u,
  44u,
  53u,
  57u,
  63u,
  65u,
  75u,
  76u,
  79u,
  80u,
  84u,
  85u,
  88u,
  89u,
  97u,
  110u,
  111u,
  112u,
  117u,
  127u,
  132u,
  134u,
  136u,
  137u,
  146u,
  147u,
  148u,
  149u,
  150u,
  151u,
  152u,
  153u,
  156u,
  158u,
  167u,
  172u,
  173u,
  174u,
  176u,
  177u,
  183u,
  184u,
  193u,
  209u,
  210u,
  211u,
  212u,
  213u,
  225u,
  226u,
  227u,
  228u,
  232u,
  237u,
  245u,
  255u,
  260u,
  264u,
  269u,
  273u,
  274u,
  275u,
  276u,
  277u,
  285u,
  286u,
  289u,
  301u,
  302u,
  192u,
  64u,
  64u,
  229u,
  8u,
  13u,
  20u,
  73u,
  107u,
  108u,
  125u,
  130u,
  157u,
  180u,
  181u,
  182u,
  265u,
  266u,
  267u,
  268u,
  11u,
  103u,
  108u,
  249u,
  250u,
  251u,
  164u,
  278u,
  265u,
  22u,
  26u,
  86u,
  133u,
  141u,
  144u,
  166u,
  171u,
  239u,
  70u,
  72u,
  164u,
  214u,
  215u,
  216u,
  164u,
  164u,
  164u,
  164u,
  283u,
  284u,
  214u,
  297u,
  64u,
  59u,
  60u,
  61u,
  62u,
  91u,
  93u,
  95u,
  101u,
  252u,
  253u,
  254u,
  297u,
  164u,
  164u,
  296u,
  64u,
  7u,
  8u,
  27u,
  67u,
  98u,
  165u,
  170u,
  290u,
  291u,
  29u,
  70u,
  72u,
  154u,
  214u,
  64u,
  45u,
  99u,
  155u,
  261u,
  262u,
  263u,
  164u,
  279u,
  238u,
  239u,
  164u,
  6u,
  33u,
  52u,
  55u,
  131u,
  159u,
  160u,
  161u,
  162u,
  167u,
  270u,
  271u,
  272u,
  12u,
  14u,
  15u,
  21u,
  23u,
  51u,
  92u,
  94u,
  100u,
  102u,
  105u,
  128u,
  129u,
  233u,
  234u,
  235u,
  236u,
  300u,
  215u,
  64u,
  204u,
  293u,
  294u,
  295u,
  64u,
  292u,
  0u,
  211u,
  192u,
  214u,
  214u,
  34u,
  64u,
  299u,
  64u,
  164u,
  164u,
  36u,
  58u,
  83u,
  288u,
  206u,
  30u,
  54u,
  57u,
  142u,
  143u,
  149u,
  230u,
  231u,
  266u,
  250u,
  64u,
  34u,
  240u,
  3u,
  46u,
  47u,
  48u,
  49u,
  145u,
  163u,
  168u,
  169u,
  256u,
  257u,
  258u,
  259u,
  164u,
  211u,
  284u,
  214u,
  253u,
  64u,
  164u,
  291u,
  68u,
  246u,
  29u,
  29u,
  246u,
  90u,
  246u,
  262u,
  64u,
  203u,
  239u,
  271u,
  299u,
  164u,
  42u,
  64u,
  175u,
  298u,
  234u,
  64u,
  299u,
  281u,
  64u,
  294u,
  64u,
  192u,
  217u,
  5u,
  69u,
  71u,
  164u,
  188u,
  287u,
  194u,
  195u,
  303u,
  304u,
  305u,
  64u,
  164u,
  31u,
  39u,
  43u,
  82u,
  113u,
  178u,
  241u,
  242u,
  243u,
  164u,
  164u,
  64u,
  257u,
  299u,
  298u,
  64u,
  247u,
  246u,
  246u,
  247u,
  215u,
  247u,
  164u,
  65u,
  138u,
  282u,
  38u,
  9u,
  19u,
  56u,
  57u,
  74u,
  96u,
  104u,
  106u,
  121u,
  139u,
  140u,
  175u,
  177u,
  185u,
  189u,
  218u,
  219u,
  220u,
  221u,
  222u,
  223u,
  224u,
  152u,
  304u,
  306u,
  307u,
  309u,
  192u,
  203u,
  164u,
  4u,
  28u,
  109u,
  116u,
  135u,
  187u,
  190u,
  244u,
  41u,
  50u,
  58u,
  77u,
  78u,
  81u,
  87u,
  114u,
  115u,
  118u,
  119u,
  120u,
  122u,
  123u,
  124u,
  126u,
  185u,
  248u,
  247u,
  247u,
  246u,
  29u,
  280u,
  215u,
  64u,
  64u,
  64u,
  179u,
  164u,
  203u,
  192u,
  207u,
  307u,
  206u,
  299u,
  247u,
  205u,
  214u,
  196u,
  308u,
  203u,
  197u,
  310u,
  311u,
  299u,
  203u,
  207u,
  311u,
  192u,
  299u,
  206u,
  198u,
  199u,
  200u,
  201u,
  202u,
  312u,
  313u,
  314u,
  207u,
  313u,
  192u,
  203u,
  192u,
  299u,
  0u,
  208u,
  209u,
  210u,
  210u,
  210u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  211u,
  212u,
  213u,
  213u,
  213u,
  213u,
  213u,
  214u,
  214u,
  215u,
  216u,
  216u,
  217u,
  217u,
  218u,
  218u,
  218u,
  219u,
  220u,
  220u,
  220u,
  220u,
  220u,
  220u,
  220u,
  220u,
  221u,
  221u,
  222u,
  222u,
  222u,
  222u,
  222u,
  222u,
  223u,
  224u,
  225u,
  226u,
  226u,
  227u,
  227u,
  227u,
  227u,
  228u,
  228u,
  228u,
  228u,
  228u,
  228u,
  228u,
  228u,
  228u,
  229u,
  229u,
  230u,
  230u,
  231u,
  231u,
  231u,
  231u,
  231u,
  232u,
  233u,
  233u,
  234u,
  234u,
  234u,
  234u,
  235u,
  235u,
  235u,
  235u,
  235u,
  235u,
  235u,
  235u,
  235u,
  236u,
  236u,
  237u,
  237u,
  237u,
  238u,
  238u,
  239u,
  239u,
  239u,
  239u,
  239u,
  239u,
  239u,
  239u,
  240u,
  240u,
  241u,
  241u,
  241u,
  241u,
  242u,
  242u,
  243u,
  243u,
  244u,
  244u,
  244u,
  244u,
  244u,
  244u,
  244u,
  245u,
  245u,
  245u,
  245u,
  245u,
  245u,
  245u,
  245u,
  246u,
  246u,
  247u,
  247u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  248u,
  249u,
  249u,
  250u,
  251u,
  251u,
  251u,
  252u,
  252u,
  253u,
  254u,
  254u,
  254u,
  254u,
  254u,
  254u,
  254u,
  254u,
  255u,
  256u,
  256u,
  257u,
  257u,
  257u,
  257u,
  257u,
  258u,
  258u,
  259u,
  259u,
  259u,
  259u,
  260u,
  261u,
  261u,
  262u,
  263u,
  263u,
  263u,
  264u,
  264u,
  265u,
  265u,
  266u,
  266u,
  267u,
  267u,
  267u,
  267u,
  267u,
  267u,
  268u,
  268u,
  268u,
  268u,
  268u,
  268u,
  269u,
  270u,
  270u,
  271u,
  272u,
  272u,
  272u,
  272u,
  272u,
  272u,
  272u,
  272u,
  272u,
  272u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  273u,
  274u,
  274u,
  274u,
  275u,
  275u,
  276u,
  276u,
  277u,
  277u,
  277u,
  278u,
  278u,
  278u,
  279u,
  280u,
  280u,
  281u,
  281u,
  282u,
  282u,
  283u,
  283u,
  284u,
  285u,
  285u,
  286u,
  286u,
  287u,
  287u,
  287u,
  287u,
  288u,
  288u,
  288u,
  289u,
  290u,
  290u,
  291u,
  291u,
  291u,
  291u,
  291u,
  291u,
  291u,
  292u,
  292u,
  293u,
  293u,
  294u,
  294u,
  295u,
  296u,
  296u,
  297u,
  297u,
  298u,
  298u,
  298u,
  299u,
  299u,
  300u,
  301u,
  302u,
  303u,
  303u,
  304u,
  305u,
  305u,
  306u,
  306u,
  307u,
  308u,
  309u,
  310u,
  310u,
  311u,
  312u,
  312u,
  313u,
  314u,
  314u,
  314u,
  314u,
  314u,
  0u,
  65321u,
  65321u,
  65321u,
  65513u,
  65321u,
  65321u,
  65521u,
  65487u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  81u,
  65321u,
  65321u,
  65321u,
  65321u,
  65498u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65382u,
  65322u,
  65321u,
  65321u,
  153u,
  65321u,
  65321u,
  142u,
  65321u,
  65321u,
  65321u,
  32u,
  65321u,
  65321u,
  65321u,
  65321u,
  121u,
  65321u,
  65321u,
  277u,
  65501u,
  65321u,
  65321u,
  65321u,
  65321u,
  107u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  163u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  65321u,
  137u,
  65321u,
  65321u,
  87u,
  65321u,
  65321u,
  267u,
  53u,
  65349u,
  65321u,
  65321u,
  65321u,
  65321u,
  65534u,
  65321u,
  65321u,
  65481u,
  65321u,
  65321u,
  65321u,
  65427u,
  65321u,
  65415u,
  65321u,
  0u,
  65535u,
  56u,
  57u,
  58u,
  59u,
  60u,
  132u,
  124u,
  125u,
  292u,
  348u,
  349u,
  350u,
  351u,
  352u,
  353u,
  354u,
  61u,
  62u,
  63u,
  64u,
  85u,
  238u,
  239u,
  65u,
  203u,
  204u,
  205u,
  206u,
  66u,
  174u,
  119u,
  244u,
  312u,
  313u,
  314u,
  370u,
  67u,
  267u,
  322u,
  388u,
  105u,
  106u,
  107u,
  143u,
  144u,
  145u,
  68u,
  254u,
  255u,
  256u,
  257u,
  69u,
  169u,
  170u,
  171u,
  70u,
  98u,
  99u,
  100u,
  101u,
  71u,
  187u,
  188u,
  189u,
  72u,
  73u,
  74u,
  75u,
  76u,
  109u,
  173u,
  393u,
  287u,
  331u,
  130u,
  131u,
  77u,
  78u,
  298u,
  230u,
  79u,
  158u,
  159u,
  215u,
  211u,
  212u,
  213u,
  149u,
  133u,
  283u,
  223u,
  207u,
  80u,
  81u,
  301u,
  302u,
  303u,
  357u,
  358u,
  410u,
  359u,
  413u,
  414u,
  427u,
  428u,
  429u,
  0u
}; // weak
char aFilegenNolinkR[37] = "filegen nolink remote config ignored"; // weak
_DWORD dword_93B9C[22] =
{
  8388608,
  0,
  0,
  0,
  679477248,
  1048575,
  -4,
  -1069547521,
  -4,
  4194303,
  50595078,
  50594818,
  67371522,
  100794628,
  50922500,
  100729860,
  33818118,
  67372036,
  33686018,
  67371523,
  67372034,
  263172
}; // weak
_UNKNOWN unk_93BF4; // weak
_UNKNOWN unk_93C20; // weak
_UNKNOWN unk_93CA8; // weak
_UNKNOWN unk_93CB4; // weak
char asc_95648[3] = "-*"; // weak
char a127001[10] = "127.0.0.1"; // weak
_UNKNOWN unk_975BC; // weak
_UNKNOWN unk_975E4; // weak
_UNKNOWN unk_975EC; // weak
char aGps_2[4] = "GPS"; // weak
_UNKNOWN unk_97798; // weak
_UNKNOWN unk_9779C; // weak
_UNKNOWN unk_977C8; // weak
_UNKNOWN unk_977CC; // weak
char a0123456789abcd_4[17] = "0123456789abcdef"; // weak
_UNKNOWN unk_9795C; // weak
_UNKNOWN unk_97ADC; // weak
_UNKNOWN unk_97B7C; // weak
_UNKNOWN unk_97B88; // weak
_WORD word_97B94[6] = { 0, 0, 0, 0, 5, 0 }; // weak
_WORD word_97BA0[6] = { 0, 20, 90, 0, 20, 0 }; // weak
char byte_97F78[4] = { '\x05', '1', 'J', '\x03' }; // weak
char byte_97F7C[4] = { '\0', '\0', '\0', '\0' }; // weak
unsigned __int8 byte_987A8[12] = { 31u, 29u, 31u, 30u, 31u, 30u, 31u, 31u, 30u, 31u, 30u, 31u }; // weak
_UNKNOWN *off_987B4 = (_UNKNOWN *)0xD54; // weak
_DWORD dword_99210[4] = { 0, 100000000, 10000000, 1000000 }; // weak
char byte_996E0[4] = { '\x03', '\r', '\0', '\0' }; // weak
_UNKNOWN *off_99960 = (_UNKNOWN *)0x61; // weak
_UNKNOWN unk_99AA8; // weak
int dword_99EB8 = 4346960; // weak
_UNKNOWN *off_9A190 = (_UNKNOWN *)0x414C; // weak
_UNKNOWN *off_9A194 = (_UNKNOWN *)0x4F4C; // weak
_UNKNOWN *off_9A198 = (_UNKNOWN *)0x484C; // weak
char *off_9A19C = "EVP_PKEY_get0_DSA"; // weak
char aV1320030221[16] = "V1.3 2003/02/21"; // weak
char a0123456789abcd[20] = "0123456789abcdef_*="; // weak
char a101531Apr16202[21] = "10:15:31/Apr 16 2025"; // weak
_UNKNOWN unk_9B2D4; // weak
char a0123456789abcd_2[17] = "0123456789abcdef"; // weak
char asc_9CA04[2] = "\a"; // weak
_UNKNOWN unk_9D770; // weak
_UNKNOWN unk_9E23F; // weak
char byte_9E240[4] = { '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_9F184[1] = { 2 }; // weak
_UNKNOWN unk_9F188; // weak
_UNKNOWN unk_9F380; // weak
_UNKNOWN unk_9F384; // weak
_UNKNOWN **off_9F394 = &off_3C; // weak
_UNKNOWN unk_9F3A4; // weak
_UNKNOWN unk_9F3B4; // weak
_UNKNOWN unk_9F3C4; // weak
_UNKNOWN unk_9F3D4; // weak
_UNKNOWN unk_9F3D8; // weak
char ao_strs_strtable[4] = "-_^"; // weak
_UNKNOWN *off_9FDED = (_UNKNOWN *)0x676F7270; // weak
_UNKNOWN *off_B36D8 = (_UNKNOWN *)0xC7BD; // weak
_UNKNOWN *off_B36DC = (_UNKNOWN *)0xC77D; // weak
char *off_B36E0 = "$end"; // weak
char *keyword_text = "abbrev"; // weak
_UNKNOWN unk_B3EF0; // weak
_UNKNOWN unk_B3F68; // weak
_UNKNOWN unk_B4148; // weak
_UNKNOWN unk_B4480; // weak
_UNKNOWN unk_B44F0; // weak
char *off_B46C4[6] = { "localhost", "gpsd", "localhost", "2947", "127.0.0.1", "2947" }; // weak
int (*off_B46E4[135])() =
{
  &sub_49A14,
  &sub_4E204,
  &sub_4E294,
  &sub_4E36C,
  &sub_4E444,
  &sub_49C80,
  &sub_4E204,
  &sub_4E294,
  &sub_4E36C,
  &sub_4E444,
  &sub_49A14,
  &sub_49A5C,
  &sub_4E294,
  &sub_4E36C,
  &sub_4E444,
  &sub_49A14,
  &sub_4E24C,
  &sub_4E2DC,
  &sub_4E3B4,
  &sub_4E48C,
  &sub_49A14,
  &sub_4E204,
  &sub_4E294,
  &sub_4E36C,
  &sub_49C20,
  &sub_49A14,
  &sub_4E204,
  &sub_4A5CC,
  &sub_4E3FC,
  &sub_4E444,
  &sub_49A14,
  &sub_4E204,
  &sub_49AA4,
  &sub_4B4B4,
  &sub_4E444,
  &sub_49A14,
  &sub_4E204,
  &sub_4E294,
  &sub_4AD94,
  &sub_4E444,
  &sub_49A14,
  &sub_4E204,
  &sub_4E324,
  &sub_4E3FC,
  &sub_4E444,
  &sub_49A14,
  &sub_4E204,
  &sub_4A52C,
  &sub_4BB10,
  &sub_4E444,
  &sub_49A14,
  &sub_4E24C,
  &sub_4E324,
  &sub_4E3FC,
  &sub_49C20,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4E5F4,
  &sub_4E174,
  &sub_4E1BC,
  &sub_4E51C,
  &sub_4A880,
  &sub_4E5F4,
  &sub_4E174,
  &sub_4E1BC,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4A8D4,
  &sub_4E174,
  &sub_4E1BC,
  &sub_4E4D4,
  &sub_4E5AC,
  &sub_4E63C,
  &sub_4E12C,
  &sub_4A3BC,
  &sub_4E4D4,
  &sub_4A65C,
  &sub_4E5F4,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4E684,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4E5F4,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4A370,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4A838,
  &sub_4A370,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4E684,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4A370,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4A370,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4A370,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4E5F4,
  &sub_4E174,
  &sub_49CE0,
  &sub_4E4D4,
  &sub_4E564,
  &sub_4E5F4,
  &sub_4E174,
  &sub_4A44C,
  &sub_4E4D4,
  &sub_4E5AC,
  &sub_4E63C,
  &sub_4E12C,
  &sub_4A2E0
}; // weak
char *off_B4B04 = "gps"; // weak
char *off_B4B64[11] =
{
  "vol",
  "bass",
  "treble",
  "synth",
  "pcm",
  "speaker",
  "line",
  "mic",
  "cd",
  "mix",
  "pcm2"
}; // weak
char *set_tod_used[4] = { "undetermined", "clock_settime", "settimeofday", "stime" }; // weak
_UNKNOWN *off_B4BD8 = (_UNKNOWN *)0x9C20C; // weak
char *daynames[19] =
{
  "Sun",
  "Mon",
  "Tue",
  "Wed",
  "Thu",
  "Fri",
  "Sat",
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
}; // weak
char *months[12] =
{
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
}; // weak
int off_B4C48 = 128; // weak
int dword_B4C84 = 1; // weak
_UNKNOWN off_B4D44; // weak
int dword_B4D68 = 1; // weak
_DWORD dword_B4E04 = 0; // weak
_DWORD dword_B4E40 = 0; // weak
_DWORD dword_B4EC4 = 0; // weak
_DWORD dword_B4F90 = 0; // weak
_DWORD dword_B4FFC = 1; // weak
_DWORD dword_B50BC = 0; // weak
_DWORD dword_B511C = 0; // weak
_UNKNOWN *off_B51E8 = (_UNKNOWN *)0x996C0; // weak
_UNKNOWN *off_B5208 = &byte_97F7C; // weak
_UNKNOWN unk_B52E8; // weak
char *off_B5324 = "amp;"; // weak
_UNKNOWN *refclock_conf = &unk_BCD34; // weak
Elf32_Dyn *GLOBAL_OFFSET_TABLE_ = &stru_B5454; // weak
int **mru_initalloc_ptr = &mru_initalloc; // weak
_UNKNOWN *bcd3_ptr = &bcd3; // weak
int *mru_maxdepth_ptr = &mru_maxdepth; // weak
_UNKNOWN *bcd6_ptr = &bcd6; // weak
_UNKNOWN *bcd2_ptr = &bcd2; // weak
int *pubkey_ptr = &pubkey; // weak
_UNKNOWN *bcd9_ptr = &bcd9; // weak
int **mru_incalloc_ptr = &mru_incalloc; // weak
_UNKNOWN *stdout_ptr = &stdout; // weak
_UNKNOWN *stderr_ptr = &stderr; // weak
int *tai_leap_ptr = &tai_leap; // weak
_UNKNOWN *off_B6004 = &off_B6004; // weak
int old_config_style = 1; // weak
char default_keysdir[5] = "/etc"; // weak
int cur_memlock = -1; // weak
char *keysdir[2] = { "/etc", "allall" }; // weak
char *off_B601C = "allall"; // weak
_UNKNOWN *off_B606C = (_UNKNOWN *)0x9893C; // weak
char *off_B6094 = "all"; // weak
_UNKNOWN *ntp_signd_socket = &unk_B860C; // weak
int *qos = &dword_B8; // weak
int waitsync_fd_to_close = -1; // weak
int listen_to_virtual_ips = 1; // weak
int priority_done = 2; // weak
_UNKNOWN ntpdOptions; // weak
_UNKNOWN *off_B611C = &unk_B615C; // weak
char *Version = "ntpd 4.2.8p13@1.3847-o Wed Apr 16 02:15:41 UTC 2025 (1)"; // weak
int crypto_nid = 4; // weak
int kern_enable = 1; // weak
int ntp_enable = 1; // weak
char allan_xpt = '\v'; // weak
double clock_phi = 0.000015; // weak
double clock_panic = 1000.0; // weak
double clock_minstep = 300.0; // weak
double clock_max_fwd = 0.128; // weak
double clock_max_back = 0.128; // weak
_UNKNOWN *mon_age = (_UNKNOWN *)0xBB8; // weak
int mru_maxdepth = 14563; // weak
int *mru_maxage = &dword_40; // weak
_UNKNOWN *mru_mindepth = (_UNKNOWN *)0x258; // weak
char ntp_minpoll = '\x03'; // weak
int ntp_minpkt = 2; // weak
int *mru_incalloc[2] = { &dword_38, &dword_38 }; // weak
int *mru_initalloc = &dword_38; // weak
_DWORD AM[50] =
{
  -1,
  5,
  0,
  3,
  4,
  6,
  0,
  -1,
  1,
  1,
  0,
  0,
  0,
  0,
  -1,
  1,
  -1,
  0,
  0,
  0,
  0,
  -1,
  0,
  0,
  0,
  1,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  1,
  0,
  0
}; // weak
int unpeer_digest_early = 1; // weak
int unpeer_crypto_nak_early = 1; // weak
int unpeer_crypto_early = 1; // weak
int peer_clear_digest_early = 1; // weak
Elf32_Sym *sys_beacon = &stru_1C20; // weak
int *sys_orphwait = &dword_12C; // weak
int sys_orphan = 17; // weak
int sys_maxclock = 10; // weak
int sys_minclock = 3; // weak
int sys_minsane = 1; // weak
int sys_ceiling = 15; // weak
double sys_maxdist = 1.5; // weak
double sys_mindisp = 0.001; // weak
int reset_entries = 1; // weak
char sys_automax = '\f'; // weak
char sys_revoke = '\x11'; // weak
char statsdir[10] = "/var/NTP/"; // weak
double wander_threshold = 1.0e-7; // weak
char num_refclock_conf = '/'; // weak
_UNKNOWN unk_B6DD4; // weak
_UNKNOWN unk_B6DF0; // weak
char *off_B6ED0[32] =
{
  "<NUL>",
  "<SOH>",
  "<STX>",
  "<ETX>",
  "<EOT>",
  "<ENQ>",
  "<ACK>",
  "<BEL>",
  "<BS>",
  "<HT>",
  "<LF>",
  "<VT>",
  "<FF>",
  "<CR>",
  "<SO>",
  "<SI>",
  "<DLE>",
  "<DC1>",
  "<DC2>",
  "<DC3>",
  "<DC4>",
  "<NAK>",
  "<SYN>",
  "<ETB>",
  "<CAN>",
  "<EM>",
  "<SUB>",
  "<ESC>",
  "<FS>",
  "<GS>",
  "<RS>",
  "<US>"
}; // weak
_UNKNOWN *off_B6F54 = (_UNKNOWN *)0x97C18; // weak
_UNKNOWN *off_B6F8C = &unk_98784; // weak
_UNKNOWN *off_B6F9C = &unk_98784; // weak
char *types[2] = { "unknown", "goes" }; // weak
char *states[21] =
{
  "Base",
  "InqTM",
  "InqTCU",
  "InqOmega",
  "InqGOES",
  "InqTL3",
  "Init",
  "F18",
  "F50",
  "Start",
  "Auto",
  "Init",
  "Huh",
  "F18",
  "F50",
  "F51",
  "Satellite",
  "TL3",
  "Poll",
  "Location",
  "TS"
}; // weak
char *events[10] =
{
  "Init",
  "Huh",
  "F18",
  "F50",
  "F51",
  "Satellite",
  "TL3",
  "Poll",
  "Location",
  "TS"
}; // weak
char dstcod[5] = "SIOD"; // weak
double bcd9[44] =
{
  -0.25,
  -0.25,
  -0.25,
  -0.25,
  0.25,
  -0.25,
  -0.25,
  -0.25,
  -0.25,
  0.25,
  -0.25,
  -0.25,
  0.25,
  0.25,
  -0.25,
  -0.25,
  -0.25,
  -0.25,
  0.25,
  -0.25,
  0.25,
  -0.25,
  0.25,
  -0.25,
  -0.25,
  0.25,
  0.25,
  -0.25,
  0.25,
  0.25,
  0.25,
  -0.25,
  -0.25,
  -0.25,
  -0.25,
  0.25,
  0.25,
  -0.25,
  -0.25,
  0.25,
  0.0,
  0.0,
  0.0,
  0.0
}; // weak
_UNKNOWN progx; // weak
double sintab[81] =
{
  0.0,
  0.0784591,
  0.1564345,
  0.2334454,
  0.309017,
  0.3826834,
  0.4539905,
  0.5224986,
  0.5877853,
  0.649448,
  0.7071068,
  0.760406,
  0.809017,
  0.8526402,
  0.8910065,
  0.9238795,
  0.9510565,
  0.9723699,
  0.9876883,
  0.9969173,
  1.0,
  0.9969173,
  0.9876883,
  0.9723699,
  0.9510565,
  0.9238795,
  0.8910065,
  0.8526402,
  0.809017,
  0.760406,
  0.7071068,
  0.649448,
  0.5877853,
  0.5224986,
  0.4539905,
  0.3826834,
  0.309017,
  0.2334454,
  0.1564345,
  0.0784591,
  -0.0,
  -0.0784591,
  -0.1564345,
  -0.2334454,
  -0.309017,
  -0.3826834,
  -0.4539905,
  -0.5224986,
  -0.5877853,
  -0.649448,
  -0.7071068,
  -0.760406,
  -0.809017,
  -0.8526402,
  -0.8910065,
  -0.9238795,
  -0.9510565,
  -0.9723699,
  -0.9876883,
  -0.9969173,
  -1.0,
  -0.9969173,
  -0.9876883,
  -0.9723699,
  -0.9510565,
  -0.9238795,
  -0.8910065,
  -0.8526402,
  -0.809017,
  -0.760406,
  -0.7071068,
  -0.649448,
  -0.5877853,
  -0.5224986,
  -0.4539905,
  -0.3826834,
  -0.309017,
  -0.2334454,
  -0.1564345,
  -0.0784591,
  0.0
}; // weak
char *modem_setup = "ATB1&C0&D2E0L1M1Q0V1Y1"; // weak
char aItf[632] =
{
  'I',
  'T',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'E',
  'T',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'L',
  'O',
  'R',
  'A',
  'N',
  ' ',
  'E',
  'N',
  'S',
  'E',
  'M',
  'B',
  'L',
  'E',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'L',
  'O',
  'R',
  'A',
  'N',
  ' ',
  'T',
  'D',
  'A',
  'T',
  'A',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'I',
  'D',
  ';',
  'O',
  'P',
  'T',
  ';',
  'V',
  'E',
  'R',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'I',
  'T',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'E',
  'T',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'L',
  'O',
  'R',
  'A',
  'N',
  ' ',
  'E',
  'N',
  'S',
  'E',
  'M',
  'B',
  'L',
  'E',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'T',
  'R',
  'S',
  'T',
  'A',
  'T',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'P',
  'O',
  'S',
  ';',
  'P',
  'P',
  'S',
  ';',
  'P',
  'P',
  'S',
  'O',
  'F',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'I',
  'T',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'E',
  'T',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'L',
  'O',
  'R',
  'A',
  'N',
  ' ',
  'E',
  'N',
  'S',
  'E',
  'M',
  'B',
  'L',
  'E',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'L',
  'O',
  'R',
  'A',
  'N',
  ' ',
  'T',
  'D',
  'A',
  'T',
  'A',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'U',
  'T',
  'C',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'I',
  'T',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'E',
  'T',
  'F',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'L',
  'O',
  'R',
  'A',
  'N',
  ' ',
  'E',
  'N',
  'S',
  'E',
  'M',
  'B',
  'L',
  'E',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'T',
  'R',
  'S',
  'T',
  'A',
  'T',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'O',
  'S',
  'C',
  ';',
  'E',
  'T',
  ';',
  'T',
  'E',
  'M',
  'P',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int enable_panic_check = 1; // weak
int dword_B7CC0 = -1073459957; // weak
int dword_B7CC4 = -1073459968; // weak
int dword_B7CC8 = -1; // weak
int dword_B7CCC = -1; // weak
__int16 authhashmask = 63; // weak
__int16 authhashbuckets = 64; // weak
int ntp_syslogmask = -1; // weak
int msyslog_include_timestamp = 1; // weak
int msyslog_term_pid = 1; // weak
int syslogit = 1; // weak
int dword_B7CE4 = 25567; // weak
time_t (*off_B7CE8)(time_t *timer) = &time; // weak
int dword_B7CEC = -1; // weak
int dword_B7CF4 = -1726662223; // weak
_UNKNOWN unk_B7CF8; // weak
_UNKNOWN unk_B7D00; // weak
_UNKNOWN unk_B7D6C; // weak
_UNKNOWN *off_B7D70 = &unk_B7D00; // weak
int *off_B7D74 = &dword_B7CF4; // weak
int dword_B7D78 = -1; // weak
int dword_B7D7C = -1; // weak
int (__fastcall *off_B7D80)(const char *a1, int a2, int a3, const char *a4) = &sub_6EE20; // weak
int (__fastcall *off_B7D84)(const char *a1, int a2, int a3, int a4) = &sub_6F2DC; // weak
int (__fastcall *off_B7D88)(const char *a1, int a2, int a3, int a4) = &sub_6F380; // weak
_UNKNOWN *isc_modules = (_UNKNOWN *)0x92834; // weak
char *off_B7D9C = "interface"; // weak
_UNKNOWN *off_B7DAC = (_UNKNOWN *)0x9DC80; // weak
char *isc_categories = "default"; // weak
char *off_B7DC4 = "general"; // weak
int dword_B7DD4 = 23; // weak
int dword_B7DD8 = 23; // weak
int dword_B7DDC = 23; // weak
int dword_B7DE0 = 23; // weak
char *off_B7DE4[23] =
{
  "success",
  "out of memory",
  "timed out",
  "no available threads",
  "address not available",
  "address in use",
  "permission denied",
  "no pending connections",
  "network unreachable",
  "host unreachable",
  "network down",
  "host down",
  "connection refused",
  "not enough free resources",
  "end of file",
  "socket already bound",
  "reload",
  "lock busy",
  "already exists",
  "ran out of space",
  "operation canceled",
  "socket is not bound",
  "shutting down"
}; // weak
int clktypes = 0; // weak
char aAbcdefghijklmn[63] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; // weak
int dword_B8164 = 1; // weak
int dword_B8168[65] =
{
  1,
  50462976,
  117835012,
  185207048,
  252579084,
  319951120,
  387323156,
  454695192,
  522067228,
  589439264,
  656811300,
  724183336,
  791555372,
  858927408,
  926299444,
  993671480,
  1061043516,
  1667391808,
  1734763876,
  1802135912,
  1869507948,
  1936879984,
  2004252020,
  1534753144,
  1600019804,
  1667391840,
  1734763876,
  1802135912,
  1869507948,
  1936879984,
  2004252020,
  2071624056,
  2138996092,
  -2088599168,
  -2021227132,
  -1953855096,
  -1886483060,
  -1819111024,
  -1751738988,
  -1684366952,
  -1616994916,
  -1549622880,
  -1482250844,
  -1414878808,
  -1347506772,
  -1280134736,
  -1212762700,
  -1145390664,
  -1078018628,
  -1010646592,
  -943274556,
  -875902520,
  -808530484,
  -741158448,
  -673786412,
  -606414376,
  -539042340,
  -471670304,
  -404298268,
  -336926232,
  -269554196,
  -202182160,
  -134810124,
  -67438088,
  -66052
}; // weak
char aStr[5] = "=str"; // weak
_UNKNOWN genshelloptOptions; // weak
int option_xlateable_txt = 108; // weak
char *off_B8454[108] =
{
  "=T/F",
  "=KWd",
  "=num",
  "=str",
  "allocation of %d bytes failed\n",
  "AutoOpts function called without option descriptor\n",
  "\tThis exceeds the compiled library version:  ",
  "Automated Options Processing Error!\n\t%s called AutoOpts function with structure version %d:%d:%d.\n",
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8458[107] =
{
  "=KWd",
  "=num",
  "=str",
  "allocation of %d bytes failed\n",
  "AutoOpts function called without option descriptor\n",
  "\tThis exceeds the compiled library version:  ",
  "Automated Options Processing Error!\n\t%s called AutoOpts function with structure version %d:%d:%d.\n",
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B845C[106] =
{
  "=num",
  "=str",
  "allocation of %d bytes failed\n",
  "AutoOpts function called without option descriptor\n",
  "\tThis exceeds the compiled library version:  ",
  "Automated Options Processing Error!\n\t%s called AutoOpts function with structure version %d:%d:%d.\n",
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8460[105] =
{
  "=str",
  "allocation of %d bytes failed\n",
  "AutoOpts function called without option descriptor\n",
  "\tThis exceeds the compiled library version:  ",
  "Automated Options Processing Error!\n\t%s called AutoOpts function with structure version %d:%d:%d.\n",
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8464[104] =
{
  "allocation of %d bytes failed\n",
  "AutoOpts function called without option descriptor\n",
  "\tThis exceeds the compiled library version:  ",
  "Automated Options Processing Error!\n\t%s called AutoOpts function with structure version %d:%d:%d.\n",
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8468[103] =
{
  "AutoOpts function called without option descriptor\n",
  "\tThis exceeds the compiled library version:  ",
  "Automated Options Processing Error!\n\t%s called AutoOpts function with structure version %d:%d:%d.\n",
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B846C[102] =
{
  "\tThis exceeds the compiled library version:  ",
  "Automated Options Processing Error!\n\t%s called AutoOpts function with structure version %d:%d:%d.\n",
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8470[101] =
{
  "Automated Options Processing Error!\n\t%s called AutoOpts function with structure version %d:%d:%d.\n",
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8474[100] =
{
  "realloc of %d bytes at 0x%p failed\n",
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8478[99] =
{
  "\tThis is less than the minimum library version:  ",
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B847C[98] =
{
  "Automated Options version %s\n\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n",
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8480[97] =
{
  "(AutoOpts bug):  %s.\n",
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8484[96] =
{
  "optionResetOpt() called, but reset-option not configured",
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8488[95] =
{
  "could not locate the 'help' option",
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B848C[94] =
{
  "optionProcess() was called with invalid data",
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8490[93] =
{
  "invalid argument type specified",
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8494[92] =
{
  "defaulted to option with optional arg",
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8498[91] =
{
  "aliasing option is out of range.",
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B849C[90] =
{
  "%s error:  the keyword '%s' is ambiguous for %s\n",
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84A0[89] =
{
  "  The following options match:\n",
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84A4[88] =
{
  "%s: ambiguous option name: %s (matches %d options)\n",
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84A8[87] =
{
  "%s: Command line arguments required\n",
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84AC[86] =
{
  "%d %s%s options allowed\n",
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84B0[85] =
{
  "%s error %d (%s) calling %s for '%s'\n",
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84B4[84] =
{
  "interprocess pipe",
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84B8[83] =
{
  "error: version option argument '%c' invalid.  Use:\n\t'v' - version only\n\t'c' - version and copyright\n\t'n' - version and full copyright notice\n",
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84BC[82] =
{
  "%s error:  the '%s' and '%s' options conflict\n",
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84C0[81] =
{
  "%s: The '%s' option has been disabled.",
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84C4[80] =
{
  "-equivalence",
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84C8[79] =
{
  "%s: illegal option -- %c\n",
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84CC[78] =
{
  "%s: illegal option -- %s\n",
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84D0[77] =
{
  "%s: unknown vendor extension option -- %s\n",
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84D4[76] =
{
  "  or an integer from %d through %d\n",
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84D8[75] =
{
  "%s error:  invalid option descriptor for %s\n",
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84DC[74] =
{
  "%s: invalid option name: %s\n",
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84E0[73] =
{
  "%s: The '%s' option requires an argument.\n",
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84E4[72] =
{
  "(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\n\t'%s' and '%s'.",
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84E8[71] =
{
  "%s error:  The %s option is required\n",
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84EC[70] =
{
  "%s: The '%s' option cannot have an argument.\n",
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84F0[69] =
{
  "%s: Command line arguments are not allowed.\n",
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84F4[68] =
{
  "error %d (%s) creating %s\n",
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84F8[67] =
{
  "%s error:  '%s' does not match any %s keywords.\n",
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B84FC[66] =
{
  "%s error: The '%s' option requires an argument.\n",
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8500[65] =
{
  "error %d (%s) stat-ing %s\n",
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8504[64] =
{
  "%s error: no saved option state\n",
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8508[63] =
{
  "'%s' is not a command line option.\n",
  "%s error:  '%s' is not a recognizable date/time.\n",
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8510[61] =
{
  "'%s' not defined\n",
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8514[60] =
{
  "%s error:  '%s' is not a recognizable time duration.\n",
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8518[59] =
{
  "%s error:  The %s option must appear %d times.\n",
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B851C[58] =
{
  "%s error:  '%s' is not a recognizable number.\n",
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8520[57] =
{
  "%s error:  %s exceeds %s keyword count\n",
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8524[56] =
{
  "Try '%s %s' for more information.\n",
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8528[55] =
{
  "one %s%s option allowed\n",
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B852C[54] =
{
  "standard output",
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8530[53] =
{
  "standard error",
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8534[52] =
{
  "write",
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8538[51] =
{
  "%s error:  %s option value %ld is out of range.\n",
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B853C[50] =
{
  "%s error:  %s option requires the %s option\n",
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8540[49] =
{
  "%s warning:  cannot save options - %s not regular file\n",
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8544[48] =
{
  "\t\t\t\t- an alternate for '%s'\n",
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8548[47] =
{
  "Version, usage and configuration options:",
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B854C[46] =
{
  "\t\t\t\t- default option for unnamed options\n",
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8550[45] =
{
  "\t\t\t\t- disabled as '--%s'\n",
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8554[44] =
{
  " --- %-14s %s\n",
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8558[43] =
{
  "This option has been disabled",
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B855C[42] =
{
  "\t\t\t\t- enabled by default\n",
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8560[41] =
{
  "%s error:  only ",
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8564[40] =
{
  " - examining environment variables named %s_*\n",
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8568[39] =
{
  "\t\t\t\t- file must not pre-exist\n",
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B856C[38] =
{
  "\t\t\t\t- file must pre-exist\n",
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8570[37] =
{
  "Options are specified by doubled hyphens and their name or by a single\nhyphen and the flag character.\n",
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8574[36] =
{
  "\n= = = = = = = =\n\nThis incarnation of genshell will produce\na shell script to parse the options for %s:\n\n",
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8578[35] =
{
  "  or an integer mask with any of the lower %d bits set\n",
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B857C[34] =
{
  "\t\t\t\t- is a set membership option\n",
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8580[33] =
{
  "\t\t\t\t- must appear between %d and %d times\n",
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8584[32] =
{
  "Options are specified by single or double hyphens and their name.\n",
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8588[31] =
{
  "\t\t\t\t- may appear multiple times\n",
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B858C[30] =
{
  "\t\t\t\t- may not be preset\n",
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8590[29] =
{
  "   Arg Option-Name    Description\n",
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8594[28] =
{
  "  Flg Arg Option-Name    Description\n",
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8598[27] =
{
  " %3s %s",
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B859C[26] =
{
  "The '-#<number>' option may omit the hash char\n",
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85A0[25] =
{
  "All arguments are named options.\n",
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85A4[24] =
{
  " - reading file %s",
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85A8[23] =
{
  "\nPlease send bug reports to:  <%s>\n",
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85AC[22] =
{
  "\t\t\t\t- may NOT appear - preset only\n",
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85B0[21] =
{
  "\nThe following option preset mechanisms are supported:\n",
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85B4[20] =
{
  "prohibits these options:\n",
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85B8[19] =
{
  "prohibits the option '%s'\n",
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85BC[18] =
{
  "%s%ld to %ld",
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85C0[17] =
{
  "%sgreater than or equal to %ld",
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85C4[16] =
{
  "%s%ld exactly",
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85C8[15] =
{
  "%sit must lie in one of the ranges:\n",
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85CC[14] =
{
  "%sit must be in the range:\n",
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85D0[13] =
{
  ", or\n",
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85D4[12] =
{
  "%sis scalable with a suffix: k/K/m/M/g/G/t/T\n",
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85D8[11] =
{
  "%sless than or equal to %ld",
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85DC[10] =
{
  "Operands and options may be intermixed.  They will be reordered.\n",
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85E0[9] =
{
  "requires the option '%s'\n",
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85E4[8] =
{
  "requires these options:\n",
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85E8[7] =
{
  "   Arg Option-Name   Req?  Description\n",
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85EC[6] =
{
  "  Flg Arg Option-Name   Req?  Description\n",
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85F0[5] =
{
  "or you may use a numeric representation.  Preceding these with a '!'\nwill clear the bits, specifying 'none' will clear all bits, and 'all'\nwill set them all.  Multiple entries may be passed as an option\nargument list.\n",
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85F4[4] =
{
  "\t\t\t\t- may appear up to %d times\n",
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85F8[3] =
{
  "The valid \"%s\" option keywords are:\n",
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B85FC[2] =
{
  "The next option supports vendor supported extra options:",
  "These additional options are:"
}; // weak
char *off_B8600 = "These additional options are:"; // weak
char *off_B8604 = &byte_A17C0; // weak
char byte_B8608; // weak
_UNKNOWN unk_B860C; // weak
int dword_B8610; // weak
char byte_B8614[1016]; // weak
char byte_B8A14[1016]; // weak
char byte_B8E14[1024]; // weak
int config_priority_override; // weak
int sys_phone[]; // weak
int dword_B921C; // weak
__int16 word_B9240[]; // weak
_UNKNOWN unk_B9244; // weak
_UNKNOWN unk_B92C0; // weak
int dword_B92C4; // weak
int dword_B92C8; // weak
int dword_B92CC; // weak
char byte_B92D0[256]; // weak
int dword_B93D0; // weak
int dword_B93D4; // weak
int dword_B93D8; // weak
int dword_B93DC; // weak
int dword_B93E0; // weak
int dword_B93E4; // weak
int dword_B93E8; // weak
int dword_B93EC; // weak
int unexpected_error_cnt; // weak
int dword_B93F4; // weak
int dword_B93F8; // weak
int dword_B93FC; // weak
int dword_B9400; // weak
int dword_B9404; // weak
int dword_B9408; // weak
int dword_B940C; // weak
_UNKNOWN unk_B9410; // weak
int dword_B9490; // weak
int dword_B9494; // weak
int dword_B9498; // weak
char byte_B949C; // weak
char byte_B949D; // weak
__int16 word_B949E; // weak
__int16 word_B94A0; // weak
__int16 word_B94A2; // weak
__int16 word_B94A4; // weak
__int16 word_B94A6; // weak
_UNKNOWN unk_B94A8; // weak
_UNKNOWN unk_B967C; // weak
int dword_B96A0; // weak
char byte_B96A4; // weak
int dword_B96A8; // weak
char byte_B96AC; // weak
char byte_B96AD; // weak
int dword_B96B0; // weak
int dword_B96B4; // weak
__int16 word_B96B8; // weak
int dword_B96BC; // weak
int dword_B96C0; // weak
int dword_B96C4; // weak
__int16 word_B96C8; // weak
int dword_B96CC; // weak
_UNKNOWN unk_B96D0; // weak
int dword_B96E4; // weak
int dword_B96E8; // weak
int dword_B9708; // weak
int dword_B9710; // weak
int dword_B9714; // weak
int dword_B9718; // weak
int dword_B971C; // weak
char byte_B9750[260]; // weak
char byte_B9854[128]; // weak
int dword_B98D8; // weak
char byte_B98DC; // weak
char byte_B98DD; // weak
char byte_B98DE; // weak
char byte_B98DF; // weak
int dword_B98E0; // weak
int dword_B98E4; // weak
int dword_B98E8; // weak
int dword_B98EC; // weak
int dword_B98F0; // weak
int dword_B98F4; // weak
int dword_B98F8; // weak
int dword_B98FC; // weak
int mvkey_info; // weak
int gqkey_info; // weak
int iffkey_info; // weak
int pkinfo; // weak
int cert_host; // weak
int cinfo; // weak
int sys_groupname; // weak
int sys_hostname; // weak
int crypto_flags; // weak
int dword_B9924; // weak
int dword_B9928; // weak
int dword_B9930; // weak
_UNKNOWN unk_B9938; // weak
_UNKNOWN unk_B9A28; // weak
int dword_B9B18; // weak
double dbl_B9B20; // weak
int dword_B9B28; // weak
_UNKNOWN unk_B9B30; // weak
int dword_B9CB8; // weak
int dword_B9CBC; // weak
float flt_B9CC0; // weak
float flt_B9CC4; // weak
int dword_B9CC8; // weak
int dword_B9CCC; // weak
int dword_B9CD0; // weak
int dword_B9CD4; // weak
float flt_B9CF0; // weak
int dword_B9D3C; // weak
int dword_B9DC0; // weak
struct sigaction stru_B9DC8; // weak
int dword_B9E54; // weak
int dword_B9E58; // weak
int dword_B9E5C; // weak
double dbl_B9E60; // weak
int dword_B9E68; // weak
int dword_B9E6C; // weak
int dword_B9E70; // weak
double dbl_B9E78; // weak
int state; // weak
int mode_ntpdate; // weak
int force_step_once; // weak
char byte_B9E8C; // weak
int dword_BAE90; // weak
int dword_BAE94; // weak
int dword_BAE98; // weak
__int16 word_BAE9C; // weak
__int16 word_BAE9E; // weak
int dword_BAEA0; // weak
int dword_BB1A8; // weak
int dword_BB4B0; // weak
int dword_BB7B8; // weak
int dword_BBAC0; // weak
int dword_BBDC8; // weak
int dword_BC0D0; // weak
int dword_BC3D8; // weak
int dword_BC6E0; // weak
int dword_BC6E4; // weak
int dword_BC6E8; // weak
int dword_BC6EC; // weak
int dword_BC6F0; // weak
int dword_BC6F4; // weak
int dword_BC6F8; // weak
double dbl_BC700; // weak
int dynamic_interleave; // weak
int sys_cohort; // weak
char sys_bcpollbstep; // weak
int sys_floor; // weak
int sys_ident; // weak
_UNKNOWN unk_BC71C; // weak
int dword_BC910; // weak
int dword_BC914; // weak
int dword_BC918; // weak
int dword_BC91C; // weak
int dword_BC920; // weak
char byte_BC924; // weak
char byte_BC925; // weak
char byte_BC926; // weak
char byte_BC927; // weak
__int16 word_BC928; // weak
__int16 word_BC92A; // weak
int dword_BC92C; // weak
int dword_BC930; // weak
int dword_BC934; // weak
int dword_BC938; // weak
int dword_BC93C; // weak
int dword_BC940; // weak
int dword_BC944; // weak
int dword_BC948; // weak
int dword_BC94C; // weak
int dword_BC950; // weak
int dword_BC954; // weak
int dword_BC958; // weak
int dword_BC95C; // weak
int dword_BC960; // weak
int dword_BC964; // weak
_UNKNOWN unk_BC96C; // weak
_UNKNOWN unk_BC970; // weak
_UNKNOWN unk_BC974; // weak
_UNKNOWN unk_BC978; // weak
int dword_BCB20; // weak
int dword_BCB24; // weak
int dword_BCB28; // weak
int dword_BCB2C; // weak
int dword_BCB30; // weak
int dword_BCB34; // weak
int dword_BCB38; // weak
int dword_BCB3C; // weak
int dword_BCB40; // weak
int dword_BCB44; // weak
__int16 word_BCB50; // weak
int dword_BCB78; // weak
__int16 word_BCB84; // weak
int dword_BCBAC; // weak
int dword_BCBB0; // weak
int dword_BCBB4; // weak
__int16 word_BCBB8; // weak
__int16 word_BCBBA; // weak
__int16 word_BCBBC; // weak
int dword_BCBC0; // weak
int dword_BCBC4; // weak
int dword_BCBC8; // weak
int dword_BCBCC; // weak
int dword_BCBD0; // weak
int dword_BCBD4; // weak
int dword_BCBD8; // weak
int dword_BCBDC; // weak
int dword_BCBE0; // weak
int dword_BCBE8; // weak
int dword_BCBEC; // weak
int dword_BCC04; // weak
int dword_BCC1C; // weak
int dword_BCC34; // weak
int dword_BCC4C; // weak
int dword_BCC64; // weak
int dword_BCC7C; // weak
_UNKNOWN unk_BCC94; // weak
double dbl_BCCB0; // weak
double dbl_BCCB8; // weak
int dword_BCCC0; // weak
int dword_BCCC4; // weak
_DWORD dword_BCCC8[26]; // weak
int dword_BCD30; // weak
int dword_BCD50; // weak
int dword_BCD58; // weak
int dword_BCD5C; // weak
char byte_BCD60[2044]; // weak
_UNKNOWN unk_BD55F; // weak
int dword_BD560; // weak
int dword_BD564[]; // weak
int dword_BD568; // weak
int dword_BD56C; // weak
int dword_BD570; // weak
int dword_BD574; // weak
_WORD word_BD578[60]; // weak
int dword_BD5F0; // weak
int dword_BD5F4; // weak
int dword_BD5F8; // weak
int dword_BD5FC; // weak
char byte_BD600[100]; // weak
char byte_BD664[8196]; // weak
_UNKNOWN unk_BF668; // weak
_UNKNOWN unk_BF670; // weak
int dword_BF688; // weak
_UNKNOWN unk_BF690; // weak
int dword_BF878; // weak
double dbl_BF880; // weak
double dbl_BF888; // weak
double dbl_BF890; // weak
double dbl_BF898; // weak
double dbl_BF8A0; // weak
double dbl_BF8A8; // weak
double dbl_BF8B0; // weak
double dbl_BF8B8; // weak
double dbl_BF8C0; // weak
double dbl_BF8C8; // weak
double dbl_BF8D0; // weak
double dbl_BF8D8; // weak
double dbl_BF8E0; // weak
double dbl_BF8E8; // weak
_UNKNOWN unk_BF8F0; // weak
_UNKNOWN unk_BFA38; // weak
_UNKNOWN unk_BFB78; // weak
_UNKNOWN unk_BFCB8; // weak
_UNKNOWN unk_BFDF8; // weak
int dword_BFF38; // weak
int dword_BFF3C; // weak
int dword_BFF40; // weak
double dbl_BFF48; // weak
int dword_BFF50; // weak
double dbl_BFF58; // weak
double dbl_BFF60; // weak
double dbl_BFF68; // weak
int dword_BFF70; // weak
double dbl_BFF78; // weak
double dbl_BFF80; // weak
double dbl_BFF88; // weak
double dbl_BFF90; // weak
double dbl_BFF98; // weak
double dbl_BFFA0; // weak
double dbl_BFFA8; // weak
double dbl_BFFB0; // weak
double dbl_BFFB8; // weak
int dword_BFFC0; // weak
double dbl_BFFC8; // weak
int dword_BFFD0; // weak
int dword_BFFD4; // weak
int dword_BFFD8; // weak
int dword_BFFDC; // weak
int dword_BFFE0; // weak
int dword_BFFE4; // weak
int dword_BFFE8; // weak
int dword_BFFEC; // weak
int dword_BFFF0; // weak
int dword_BFFF4; // weak
int dword_BFFF8; // weak
int dword_BFFFC; // weak
int dword_C0000; // weak
int dword_C0004; // weak
int dword_C0008; // weak
double dbl_C0010[8000]; // weak
_UNKNOWN unk_CFA10; // weak
_UNKNOWN unk_DC210; // weak
_UNKNOWN unk_E8A10; // weak
_UNKNOWN unk_F423F; // weak
_UNKNOWN unk_F4240; // weak
double dbl_F5210[5566]; // weak
_UNKNOWN unk_100006; // weak
_UNKNOWN unk_101A10; // weak
_UNKNOWN unk_104490; // weak
int dword_106F10; // weak
int dword_106F14; // weak
int dword_106F18; // weak
__int64 qword_106F20; // weak
int dword_106F28; // weak
__int64 qword_106F2C; // weak
__int64 qword_106F34; // weak
double sys_residual; // weak
float sys_fuzz_nsec; // weak
double sys_fuzz; // weak
double sys_tick; // weak
int allow_panic; // weak
char byte_106F64[100]; // weak
char byte_106FC8[100]; // weak
char byte_10702C[100]; // weak
char byte_107090[100]; // weak
int dword_1070F4; // weak
int dword_1070F8; // weak
int dword_1070FC; // weak
int dword_107100; // weak
int (__fastcall *set_tod_using)(_DWORD); // weak
int dword_107108; // weak
int dword_10710C; // weak
int dword_107110; // weak
int msyslog_term; // weak
int dword_107118[57]; // weak
_UNKNOWN unk_10711C; // weak
int dword_1071FC; // weak
int dword_107200; // weak
int dword_107204; // weak
int dword_107208; // weak
int dword_10720C; // weak
int dword_107210; // weak
int dword_107214; // weak
int dword_107218; // weak
int dword_10721C; // weak
int dword_107220; // weak
int dword_107224; // weak
int (__fastcall *off_107228)(_DWORD, _DWORD); // weak
int dword_10722C; // weak
sem_t stru_107230; // weak
int dword_107240; // weak
pthread_once_t dword_107244; // weak
int isc_msgcat; // weak
_UNKNOWN unk_10724C; // weak
int dword_107250; // weak
int isc_lctx; // weak
pthread_once_t dword_107260; // weak
pthread_once_t dword_107264; // weak
pthread_once_t dword_107268; // weak
pthread_mutex_t stru_10726C; // weak
int dword_107284; // weak
int dword_107288; // weak
pthread_once_t dword_10728C; // weak
pthread_mutex_t stru_107290; // weak
pthread_once_t dword_1072A8; // weak
pthread_once_t dword_1072BC; // weak
int dword_1072C0[]; // weak
char byte_1072C4; // weak
int dword_1072C8; // weak
int dword_1072CC; // weak
int dword_1072D0; // weak
int dword_1072D4; // weak
int dword_1072D8; // weak
int dword_1072DC; // weak
int dword_1072E0; // weak
int dword_1072E4; // weak
int dword_1072E8; // weak
int dword_1072EC; // weak
int dword_1072F0; // weak
int dword_1072F4; // weak
int dword_1072F8; // weak
int dword_1072FC; // weak
int dword_107300; // weak
int dword_10732C; // weak
int dword_107334; // weak
int dword_107358; // weak
int dword_107370; // weak
int dword_107374; // weak
int dword_107388; // weak
int dword_1073B8; // weak
int dword_1073BC; // weak
int dword_1073C0; // weak
char byte_1073C4; // weak
int dword_1073C8; // weak
char byte_1073CC; // weak
char byte_1073D0[32]; // weak
char byte_1073F0; // weak
int dword_1073F4; // weak
int dword_1073F8; // weak
int optionParseShellOptions; // weak
int option_usage_fp; // weak
int cmdline_server_count; // weak
int config_priority; // weak
int config_file; // weak
_UNKNOWN cfgt; // weak
int dword_107434; // weak
int dword_107440; // weak
int dword_107448; // weak
_UNKNOWN unk_10744C; // weak
_UNKNOWN unk_107450; // weak
_UNKNOWN unk_107454; // weak
_UNKNOWN unk_107458; // weak
_UNKNOWN unk_10745C; // weak
_UNKNOWN unk_107460; // weak
_UNKNOWN unk_107464; // weak
_UNKNOWN unk_107468; // weak
_UNKNOWN unk_10746C; // weak
_UNKNOWN unk_107470; // weak
_UNKNOWN unk_107474; // weak
_UNKNOWN unk_107478; // weak
_UNKNOWN unk_10747C; // weak
_UNKNOWN unk_107480; // weak
_UNKNOWN unk_107484; // weak
_UNKNOWN unk_107488; // weak
_UNKNOWN unk_10748C; // weak
_UNKNOWN unk_107490; // weak
_UNKNOWN unk_107494; // weak
_UNKNOWN unk_107498; // weak
_UNKNOWN unk_10749C; // weak
_UNKNOWN unk_1074A0; // weak
_UNKNOWN unk_1074A4; // weak
_UNKNOWN unk_1074A8; // weak
_UNKNOWN unk_1074AC; // weak
_UNKNOWN unk_1074B0; // weak
_UNKNOWN unk_1074B4; // weak
_UNKNOWN unk_1074B8; // weak
_UNKNOWN unk_1074BC; // weak
_DWORD *dword_1074C0; // weak
_DWORD *dword_1074C4; // weak
_DWORD *dword_1074C8; // weak
_DWORD *dword_1074CC; // weak
_DWORD *dword_1074D0; // weak
_DWORD *dword_1074D4; // weak
int dword_1074D8; // weak
int cmdline_servers; // weak
int saveconfigdir; // weak
int cfg_tree_history; // weak
int cryptosw; // weak
unsigned __int8 remote_config[1024]; // weak
char byte_1078F0[1024]; // weak
int dword_107CF0; // weak
int dword_107CF4; // weak
int dword_107CF8; // weak
int packets_received; // weak
int packets_ignored; // weak
int mc4_list; // weak
int packets_sent; // weak
int asyncio_reader_list; // weak
int nic_rule_list; // weak
int loopback_interface; // weak
int handler_calls; // weak
int mc6_list; // weak
int remoteaddr_list; // weak
int disable_dynamic_updates; // weak
int ep_list; // weak
int broadcast_client_enabled; // weak
int fd_list; // weak
int packets_notsent; // weak
int ninterfaces; // weak
int handler_pkts; // weak
int packets_dropped; // weak
int io_timereset; // weak
int sys_ifnum; // weak
int any_interface; // weak
int any6_interface; // weak
int yydebug; // weak
int yychar; // weak
double yylval; // weak
int yynerrs; // weak
char yytext; // weak
int conf_file_sum; // weak
int saved_argc; // weak
int saved_argv; // weak
int nofork; // weak
int was_alarmed; // weak
int progname; // weak
int numctlbadpkts; // weak
int numctldatatooshort; // weak
int numctlresponses; // weak
_UNKNOWN ctl_traps; // weak
_UNKNOWN unk_10819C; // weak
char byte_1081C6; // weak
char byte_1081FA; // weak
char byte_10822E; // weak
int numctlinputresp; // weak
int ctltimereset; // weak
int numasyncmsgs; // weak
int numctlinputerr; // weak
int numctlreq; // weak
int numctlfrags; // weak
int numctltooshort; // weak
int numctlbadversion; // weak
int ctl_auth_keyid; // weak
int numctlbadoffset; // weak
int numctlinputfrag; // weak
int numctlbadop; // weak
int num_ctl_traps; // weak
int numctlerrors; // weak
int hostval; // weak
int dword_10826C; // weak
int dword_108270; // weak
int dword_108274; // weak
int dword_108278; // weak
int dword_10827C; // weak
int pubkey; // weak
int dword_108284; // weak
int dword_108288; // weak
int dword_10828C; // weak
int dword_108290; // weak
int dword_108294; // weak
int tai_leap; // weak
int dword_10829C; // weak
int dword_1082A0; // weak
int dword_1082A4; // weak
int dword_1082A8; // weak
int dword_1082AC; // weak
char sys_poll; // weak
int hardpps_enable; // weak
double clock_jitter; // weak
int ext_enable; // weak
int tc_counter; // weak
double last_offset; // weak
int sys_tai; // weak
double drift_comp; // weak
double clock_stability; // weak
int freq_set; // weak
int pll_control; // weak
int kernel_status; // weak
int pll_status; // weak
double clock_codec; // weak
float freq_cnt; // weak
_UNKNOWN mon_mru_list; // weak
int dword_108310; // weak
int dword_108314; // weak
float mru_entries; // weak
int mon_enabled; // weak
int mru_peakentries; // weak
int mon_hash; // weak
char mon_hash_bits; // weak
int mru_alloc; // weak
_DWORD assoc_hash[128]; // weak
int peer_free_count; // weak
int assocpeer_calls; // weak
int peer_timereset; // weak
int peer_associations; // weak
int findpeer_calls; // weak
_DWORD peer_hash[128]; // weak
_DWORD assoc_hash_count[128]; // weak
int total_peer_structs; // weak
int peer_allocations; // weak
int peer_demobilizations; // weak
_DWORD peer_hash_count[128]; // weak
int peer_list; // weak
int peer_preempt; // weak
int sys_badauth; // weak
double sys_jitter; // weak
char sys_precision; // weak
int sys_authenticate; // weak
int sys_newversion; // weak
double sys_rootdisp; // weak
char sys_leap; // weak
double sys_rootdelay; // weak
int sys_refid; // weak
int sys_kodsent; // weak
char sys_ttl[]; // weak
char byte_108BD9; // weak
char byte_108BDA; // weak
char byte_108BDB; // weak
char byte_108BDC; // weak
char byte_108BDD; // weak
char byte_108BDE; // weak
char byte_108BDF; // weak
int ntp_mode7; // weak
double sys_bdelay; // weak
unsigned int sys_authdelay; // weak
int dword_108BF4; // weak
int sys_ttlmax; // weak
int sys_received; // weak
int sys_restricted; // weak
int peer_ntpdate; // weak
int sys_reftime; // weak
int dword_108C0C; // weak
int sys_limitrejected; // weak
char sys_stratum; // weak
int sys_processed; // weak
int sys_declined; // weak
int sys_stattime; // weak
int sys_manycastserver; // weak
int sys_badlength; // weak
int sys_peer; // weak
int sys_epoch; // weak
char xmt_leap; // weak
int sys_oldversion; // weak
int sys_private; // weak
double sys_offset; // weak
int sys_bclient; // weak
int sys_survivors; // weak
int leap_sec_in_progress; // weak
int cal_enable; // weak
int errorcounter[]; // weak
int dword_108C5C; // weak
int dword_108C60; // weak
int dword_108C64; // weak
int dword_108C68; // weak
int dword_108C6C; // weak
int dword_108C70; // weak
int dword_108C74; // weak
int numresppkts; // weak
int auth_timereset; // weak
int numrequests; // weak
int info_auth_keyid; // weak
int restrictlist4; // weak
int restrictlist6; // weak
int alarm_overflow; // weak
int itimer; // weak
int dword_108C98; // weak
int dword_108C9C; // weak
int dword_108CA0; // weak
int current_time; // weak
int initializing; // weak
int leapsec; // weak
int orphwait; // weak
int alarm_flag; // weak
int interface_interval; // weak
int timer_timereset; // weak
int leapdif; // weak
int timer_overflows; // weak
int timer_xmtcalls; // weak
int stats_drift_file; // weak
int stats_control; // weak
int fd; // weak
int praecis_msg; // weak
double measured_tick; // weak
int sys_lamport; // weak
int sys_tsrounding; // weak
int trunc_os_clock; // weak
int (__fastcall *step_callback)(_DWORD, _DWORD, _DWORD); // weak
int key_hash; // weak
int authfreekeys; // weak
int authdecryptions; // weak
int cache_keyacclist; // weak
int cache_secretsize; // weak
__int16 cache_flags; // weak
int cache_secret; // weak
int authkeyexpired; // weak
int authkeyuncached; // weak
int cache_type; // weak
int authnumkeys; // weak
int authnumfreekeys; // weak
int authencryptions; // weak
int authkeynotfound; // weak
int cache_keyid; // weak
int authnokey; // weak
_UNKNOWN key_listhead; // weak
int dword_108D40; // weak
int dword_108D44; // weak
int authkeylookups; // weak
int ipv6_works; // weak
int ipv4_works; // weak
int lib_nextbuf; // weak
int debug; // weak
_BYTE lib_stringbuf[2048]; // weak
int lib_inited; // weak
int syslog_fname; // weak
int syslog_abs_fname; // weak
int syslog_file; // weak
int dnsworker_contexts_alloc; // weak
int dnschild_contexts; // weak
int dnsworker_contexts; // weak
int dnschild_contexts_alloc; // weak
int blocking_children_alloc; // weak
int worker_per_query; // weak
int intres_req_pending; // weak
int blocking_child_ready_seen; // weak
int blocking_children; // weak
int blocking_child_ready_done; // weak
int ssl_init_done; // weak
int (__fastcall *addremove_io_fd)(_DWORD, _DWORD, _DWORD); // weak
// extern const struct in6_addr in6addr_any;
// extern _UNKNOWN _stack_chk_guard; weak
// extern struct _IO_FILE *stdout;
// extern struct _IO_FILE *stderr;
// extern _UNKNOWN __gmon_start__; weak


//----- (0000B200) --------------------------------------------------------
int init_proc()
{
  return sub_C6F8();
}

//----- (0000B20C) --------------------------------------------------------
void sub_B20C()
{
  JUMPOUT(0);
}
// B218: control flows out of bounds to 0

//----- (0000B508) --------------------------------------------------------
// attributes: thunk
int __fastcall sub_B508(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return _cxa_atexit(lpfunc, obj, lpdso_handle);
}

//----- (0000C170) --------------------------------------------------------
int __fastcall sub_C170(int a1, char a2, unsigned int a3, __int16 a4)
{
  int v8; // r2
  unsigned int v9; // r9
  unsigned int *v10; // r10
  unsigned __int8 v11; // r11
  unsigned int v12; // r1
  unsigned int v13; // r0
  unsigned int v14; // r1
  unsigned int v15; // r10
  char v16; // r11
  unsigned int v17; // r3
  char v18; // r1
  unsigned int v19; // r0
  unsigned int v20; // r1
  unsigned int v21; // lr
  unsigned int v22; // r2
  int v24; // r10
  unsigned int v25; // r10
  int v26; // r0
  unsigned int v27; // r3
  size_t n; // r10
  unsigned int v29; // r3
  unsigned int v30; // [sp+14h] [bp-860h] BYREF
  unsigned int v31; // [sp+18h] [bp-85Ch]
  int v32; // [sp+1Ch] [bp-858h] BYREF
  unsigned int v33; // [sp+20h] [bp-854h]
  unsigned int buf; // [sp+24h] [bp-850h] BYREF
  unsigned int v35; // [sp+28h] [bp-84Ch]
  unsigned int v36; // [sp+2Ch] [bp-848h]
  int v37; // [sp+30h] [bp-844h]
  unsigned int v38; // [sp+34h] [bp-840h]
  unsigned int v39; // [sp+38h] [bp-83Ch]
  unsigned int v40; // [sp+3Ch] [bp-838h]
  unsigned int v41; // [sp+40h] [bp-834h]
  unsigned int v42; // [sp+44h] [bp-830h]
  unsigned int v43; // [sp+48h] [bp-82Ch]
  unsigned int v44; // [sp+4Ch] [bp-828h]
  unsigned int v45; // [sp+50h] [bp-824h]

  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 144) & 0x40) != 0 )
    *(_DWORD *)(a1 + 60) = sub_178F8((const struct sockaddr *)(a1 + 4));
  v8 = a2;
  v9 = *(unsigned __int8 *)(a1 + 90);
  v10 = (unsigned int *)(a1 + 128);
  v11 = *(_BYTE *)(a1 + 88) & 0x38;
  if ( v9 < (unsigned __int8)ntp_minpoll )
    LOBYTE(v9) = ntp_minpoll;
  if ( (a4 & 0x800) != 0 )
  {
    v12 = *(_DWORD *)(a1 + 108);
    v38 = *(_DWORD *)(a1 + 104);
    v39 = v12;
    v13 = *v10;
    v14 = *(_DWORD *)(a1 + 132);
    LOWORD(buf) = v11 | (unsigned __int8)~((unsigned int)~(v8 << 26) >> 26);
    v15 = *(_DWORD *)(a1 + 92);
    v16 = *(_BYTE *)(a1 + 91);
    v44 = v13;
    v45 = v14;
    v17 = *(_DWORD *)(a1 + 96);
    BYTE2(buf) = v9;
    v40 = v13;
    v41 = v14;
    v42 = v13;
    v43 = v14;
    ++sys_kodsent;
    v37 = 1163149650;
    HIBYTE(buf) = v16;
    v35 = v15;
    v36 = v17;
  }
  else
  {
    LOBYTE(buf) = v11 | v8 | (xmt_leap << 6);
    BYTE2(buf) = v9;
    v18 = sys_stratum;
    if ( sys_stratum == 16 )
      v18 = 0;
    BYTE1(buf) = v18;
    v19 = *v10;
    v20 = *(_DWORD *)(a1 + 132);
    HIBYTE(buf) = sys_precision;
    v21 = bswap32(*(_DWORD *)(a1 + 72));
    v37 = sys_refid;
    v22 = bswap32(*(_DWORD *)(a1 + 76));
    v35 = bswap32((int)(sys_rootdelay * 65536.0));
    v36 = bswap32((unsigned int)(sys_rootdisp * 65536.0));
    v40 = v19;
    v41 = v20;
    v43 = v22;
    v42 = v21;
    v38 = bswap32(sys_reftime);
    v39 = bswap32(dword_108C0C);
    sub_5F724((int *)&v30);
    v44 = bswap32(v30);
    v45 = bswap32(v31);
  }
  if ( *(_DWORD *)(a1 + 84) == 48 )
    return sub_16A68((struct sockaddr *)(a1 + 4), *(_DWORD *)(a1 + 60), 0, &buf, 0x30u);
  if ( a3 >= 0x10000 )
  {
    v25 = sub_272C8((_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 60) + 24, 0, sys_private, 0);
    v26 = *(_DWORD *)(a1 + 60);
    if ( *(_DWORD *)(a1 + 84) <= 0x48u )
    {
      v27 = v25;
      v24 = 48;
      sub_272C8((_DWORD *)(v26 + 24), a1 + 4, a3, v27, 2u);
    }
    else
    {
      sub_272C8((_DWORD *)(v26 + 24), a1 + 4, a3, 0, 2u);
      *(_DWORD *)(a1 + 136) |= 0x80u;
      v24 = sub_29774(0, (int)&buf, a1, 48, (unsigned int *)(a1 + 136), v25) + 48;
    }
  }
  else
  {
    v24 = 48;
  }
  sub_5F724((int *)&v30);
  n = v24 + sub_6278C(a3, (int)&buf, v24);
  if ( a3 >= 0x10000 )
    sub_621BC(a3, 0);
  sub_16A68((struct sockaddr *)(a1 + 4), *(_DWORD *)(a1 + 60), 0, &buf, n);
  sub_5F724(&v32);
  v29 = v32 - v30;
  if ( v33 < v31 )
    --v29;
  sys_authdelay = v29;
  dword_108BF4 = v33 - v31;
  return v29;
}
// B6B30: using guessed type char ntp_minpoll;
// 108BA8: using guessed type char sys_precision;
// 108BB8: using guessed type double sys_rootdisp;
// 108BC8: using guessed type double sys_rootdelay;
// 108BD0: using guessed type int sys_refid;
// 108BD4: using guessed type int sys_kodsent;
// 108BF0: using guessed type unsigned int sys_authdelay;
// 108BF4: using guessed type int dword_108BF4;
// 108C08: using guessed type int sys_reftime;
// 108C0C: using guessed type int dword_108C0C;
// 108C14: using guessed type char sys_stratum;
// 108C34: using guessed type char xmt_leap;
// 108C3C: using guessed type int sys_private;

//----- (0000C534) --------------------------------------------------------
int __fastcall sub_C534(const char *a1, const char *a2)
{
  int result; // r0

  if ( !a1 )
    return 0;
  result = strcmp(a1, (const char *)sys_groupname);
  if ( result )
    return !a2 || strcmp(a1, a2) != 0;
  return result;
}
// B9918: using guessed type int sys_groupname;

//----- (0000C5C4) --------------------------------------------------------
void __noreturn sub_C5C4()
{
  int *v0; // r0

  v0 = _errno_location();
  sub_64E00(3, "read system clock failed: %m (%d)", *v0);
  exit(1);
}

//----- (0000C610) --------------------------------------------------------
void __fastcall __noreturn sub_C610(int a1)
{
  fprintf(stderr, off_B8464[0], a1);
  sub_7CE5C(1);
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8464: using guessed type char *off_B8464[104];

//----- (0000C668) --------------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  sub_1D338(argc, (char **)argv);
}

//----- (0000C6B0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))*(&off_C6E8 + 173632),
    v4,
    (char **)va,
    (void (*)())*(&off_C6E8 + 173484),
    (void (*)())*(&off_C6E8 + 173309),
    a1,
    va);
  abort();
}
// C6BA: positive sp value 4 has been found
// C6E0: variable 'v4' is possibly undefined
// C6E8: using guessed type Elf32_Dyn **off_C6E8;

//----- (0000C6F8) --------------------------------------------------------
int sub_C6F8()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// B418: using guessed type int _gmon_start__(void);

//----- (0000C71C) --------------------------------------------------------
char *sub_C71C()
{
  return &byte_B8608;
}
// B8608: using guessed type char byte_B8608;
// 109AE4: using guessed type int ITM_deregisterTMCloneTable(void);

//----- (0000C748) --------------------------------------------------------
__int64 sub_C748()
{
  __int64 result; // r0

  LODWORD(result) = &byte_B8608;
  HIDWORD(result) = 0;
  return result;
}
// B8608: using guessed type char byte_B8608;
// 109AE8: using guessed type int ITM_registerTMCloneTable(void);

//----- (0000C77C) --------------------------------------------------------
char *sub_C77C()
{
  char *result; // r0

  if ( !byte_B8608 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_B6004);
    result = sub_C71C();
    byte_B8608 = 1;
  }
  return result;
}
// B6004: using guessed type _UNKNOWN *off_B6004;
// B8608: using guessed type char byte_B8608;

//----- (0000C7C0) --------------------------------------------------------
_BYTE *sub_C7C0()
{
  int v0; // s0
  int v1; // s1
  _BYTE *v2; // r4
  int v3; // r5
  int v4; // r3
  char *v5; // r0
  int v6; // r3
  bool v7; // zf
  unsigned __int8 *v8; // r1
  int v9; // t1

  v2 = &lib_stringbuf[128 * lib_nextbuf];
  v3 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v2, 0, 0x80u);
  lib_nextbuf = v3;
  sub_6C054((int)v2, 0x80u, byte_8C1D4, v4, v0, v1);
  v5 = strchr(v2, 101);
  if ( !v5 )
  {
    v5 = strchr(v2, 69);
    if ( !v5 )
      return v2;
    *v5 = 101;
  }
  v6 = (unsigned __int8)v5[1];
  v7 = v6 == 45;
  if ( v6 == 45 )
    v6 = (unsigned __int8)v5[2];
  else
    ++v5;
  if ( v7 )
    v5 += 2;
  if ( v6 == 48 )
  {
    v8 = (unsigned __int8 *)v5;
    do
      v9 = *++v8;
    while ( v9 == 48 );
    if ( v5 != (char *)v8 )
      sub_6D4DC(v5, v8, 128 - (v5 - v2));
  }
  return v2;
}
// C830: variable 'v4' is possibly undefined
// C830: variable 'v0' is possibly undefined
// C830: variable 'v1' is possibly undefined
// 8C1D4: using guessed type unsigned __int8 byte_8C1D4[4];
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0000C8E0) --------------------------------------------------------
int __fastcall sub_C8E0(int result)
{
  if ( result )
  {
    result = *(_DWORD *)(result + 4);
    if ( result )
      return strncmp((const char *)result, "127.127.", 8u) == 0;
  }
  return result;
}

//----- (0000C954) --------------------------------------------------------
void __noreturn sub_C954(unsigned __int8 *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  sub_64E88(0, a1, (int *)varg_r1);
  exit(1);
}

//----- (0000C9A0) --------------------------------------------------------
void __fastcall sub_C9A0(_DWORD *a1, __int16 *a2)
{
  _DWORD *v2; // r4
  int v4; // r2

  if ( a1 )
  {
    v2 = (_DWORD *)*a1;
    if ( *a1 )
    {
      while ( 1 )
      {
        v4 = v2[4];
        if ( v4 == 363 )
          break;
LABEL_4:
        if ( v4 < 364 )
        {
          if ( v4 == 275 )
          {
            sub_38810(13, a2, 0);
            goto LABEL_20;
          }
          if ( v4 >= 276 )
          {
            if ( v4 == 328 )
            {
              sub_38810(9, a2, 0);
              goto LABEL_20;
            }
            if ( v4 == 362 )
            {
              sub_38810(28, a2, 0);
              goto LABEL_20;
            }
          }
          else
          {
            if ( v4 == 263 )
            {
              sub_38810(3, a2, 0);
              goto LABEL_20;
            }
            if ( v4 == 268 )
            {
              sub_38810(1, a2, 0);
              goto LABEL_20;
            }
          }
        }
        else
        {
          if ( v4 == 412 )
          {
            sub_38810(11, a2, 0);
            goto LABEL_20;
          }
          if ( v4 <= 412 )
          {
            if ( v4 == 380 )
            {
              sub_38810(8, a2, 0);
              goto LABEL_20;
            }
            if ( v4 == 385 )
            {
              sub_38810(32, a2, 0);
              goto LABEL_20;
            }
          }
          else
          {
            switch ( v4 )
            {
              case 436:
                sub_38810(30, a2, 0);
                goto LABEL_20;
              case 437:
                sub_38810(31, a2, 0);
                goto LABEL_20;
              case 435:
                sub_38810(29, a2, 0);
                goto LABEL_20;
            }
          }
        }
        sub_64E00(3, "can not apply enable/disable token %d, unknown", v4);
        v2 = (_DWORD *)*v2;
        if ( !v2 )
          return;
      }
      while ( 1 )
      {
        sub_38810(10, a2, 0);
LABEL_20:
        v2 = (_DWORD *)*v2;
        if ( !v2 )
          break;
        v4 = v2[4];
        if ( v4 != 363 )
          goto LABEL_4;
      }
    }
  }
}

//----- (0000CBFC) --------------------------------------------------------
unsigned int *__fastcall sub_CBFC(const char *a1)
{
  size_t v1; // r0
  unsigned __int8 v3[128]; // [sp+4h] [bp-88h] BYREF

  sub_6C054((int)v3, 0x80u, "settimeofday=\"%s\"", a1);
  v1 = strlen((const char *)v3);
  return sub_245C4(v3, v1 + 1, 1);
}

//----- (0000CC78) --------------------------------------------------------
bool __fastcall sub_CC78(unsigned __int16 *a1, int a2)
{
  int v2; // r12
  bool v3; // zf
  _BOOL4 v4; // r3
  const char *v6; // r0
  unsigned int v7; // r6
  unsigned int v8; // r3
  _BOOL4 v9; // lr
  bool v10; // zf

  v2 = *a1;
  if ( v2 == 2 )
  {
    v7 = *((_DWORD *)a1 + 1);
    v8 = bswap32(v7);
    if ( HIWORD(v8) << 16 != 2139029504 )
    {
      v9 = (v8 & 0xFF000000) == 2130706432;
      if ( v8 == 2130706433 )
        v9 = 0;
      if ( v9 )
        goto LABEL_14;
    }
    v10 = a2 == 387;
    if ( a2 != 387 )
      v10 = a2 == 407;
    if ( !v10 && a2 != 392 )
    {
      if ( a2 != 343 )
        return 1;
      goto LABEL_24;
    }
    v4 = (v8 & 0xF0000000) == -536870912;
  }
  else
  {
    v3 = a2 == 387;
    if ( a2 != 387 )
      v3 = a2 == 407;
    if ( !v3 && a2 != 392 )
    {
      if ( a2 != 343 )
        goto LABEL_9;
      goto LABEL_13;
    }
    v4 = *((unsigned __int8 *)a1 + 8) == 255;
  }
  if ( v4 )
  {
LABEL_14:
    v6 = sub_6C2E8(a1);
    sub_64E00(3, "attempt to configure invalid address %s", v6);
    return 0;
  }
  if ( a2 == 343 )
  {
    if ( v2 != 2 )
    {
LABEL_13:
      if ( *((unsigned __int8 *)a1 + 8) != 255 )
        goto LABEL_14;
      goto LABEL_9;
    }
    v7 = *((_DWORD *)a1 + 1);
LABEL_24:
    if ( (v7 & 0xF0) != 0xE0 )
      goto LABEL_14;
    return 1;
  }
LABEL_9:
  if ( v2 != 10 )
    return 1;
  return ipv6_works != 0;
}
// 108D68: using guessed type int ipv6_works;

//----- (0000CE10) --------------------------------------------------------
int __fastcall sub_CE10(int a1, unsigned __int16 *a2)
{
  int v3; // r1
  _BOOL4 v4; // r2
  int result; // r0

  v3 = *a2;
  v4 = v3 == 10;
  if ( (v3 & 0xFFFD) == 0 )
    v4 = 1;
  if ( !v4 )
    sub_6ECC0(
      "ntp_config.c",
      5181,
      0,
      "0 == ((addr)->sa.sa_family) || 2 == ((addr)->sa.sa_family) || 10 == ((addr)->sa.sa_family)");
  result = sub_64054(a1, v3, a2);
  if ( result )
  {
    if ( *a2 != 10 || ipv6_works )
    {
      result = 1;
      a2[1] = 31488;
    }
    else
    {
      return -1;
    }
  }
  return result;
}
// 108D68: using guessed type int ipv6_works;

//----- (0000CEE8) --------------------------------------------------------
unsigned int __fastcall sub_CEE8(unsigned int result)
{
  _DWORD *v1; // r3
  int v2; // r1

  if ( result )
  {
    v1 = *(_DWORD **)result;
    if ( *(_DWORD *)result )
    {
      result = 0;
      while ( 1 )
      {
        v2 = v1[4];
        if ( v2 == 376 )
          break;
        if ( v2 > 376 )
        {
          if ( v2 == 395 )
          {
            result |= 0x20u;
            goto LABEL_9;
          }
          if ( v2 >= 396 )
          {
            if ( v2 == 430 )
            {
              result |= 0x400u;
            }
            else
            {
              if ( v2 != 444 )
                goto LABEL_15;
              result |= 0x1000u;
            }
            goto LABEL_9;
          }
          if ( v2 != 394 )
LABEL_15:
            sub_C954("peerflag_bits: option-token=%d", v2);
          v1 = (_DWORD *)*v1;
          result |= 2u;
          if ( !v1 )
            return result;
        }
        else
        {
          switch ( v2 )
          {
            case 274:
              result |= 0x40u;
              break;
            case 311:
              result |= 0x100u;
              break;
            case 264:
              result |= 0x800u;
              break;
            default:
              goto LABEL_15;
          }
LABEL_9:
          v1 = (_DWORD *)*v1;
          if ( !v1 )
            return result;
        }
      }
      result |= 0x200u;
      goto LABEL_9;
    }
    return 0;
  }
  return result;
}

//----- (0000D014) --------------------------------------------------------
void __fastcall sub_D014(int a1, int a2, int a3, const char *a4, int a5, int a6, int a7)
{
  unsigned int v10; // r2
  char *v11; // r5
  const char *v12; // r0
  const char *v13; // r5
  const char *v14; // r0
  unsigned __int16 v15[14]; // [sp+8h] [bp-20h] BYREF

  if ( a1 )
  {
    v12 = gai_strerror(a1);
    sub_64E00(3, "giving up resolving trap host %s: %s (%d)", a4, v12, a1);
  }
  else
  {
    v10 = *(_DWORD *)(a7 + 16);
    if ( v10 > 0x1C )
      sub_6ECC0("ntp_config.c", 3582, 2, "sizeof(peeraddr) >= res->ai_addrlen");
    memset(v15, 0, sizeof(v15));
    _memcpy_chk(v15, *(_DWORD *)(a7 + 20), v10, 28);
    if ( !*(_DWORD *)(a3 + 28) || (v11 = sub_178F8((const struct sockaddr *)a3)) == 0 )
    {
      if ( v15[0] == 2 )
        v11 = (char *)any_interface;
      else
        v11 = (char *)any6_interface;
    }
    if ( !sub_23D98(v15, (int)v11, 0, 4) )
    {
      v13 = sub_18FB4((int)v11);
      v14 = sub_6C2E8(v15);
      sub_64E00(3, "set trap %s -> %s failed.", v13, v14);
    }
  }
  free((void *)a3);
}
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;

//----- (0000D1A8) --------------------------------------------------------
void __fastcall sub_D1A8(int a1, int a2, unsigned __int16 *ptr, const char *a4, int a5, int a6, _DWORD *a7)
{
  _DWORD *v10; // r4
  int v11; // r3
  const char *v12; // r4
  const char *v13; // r0
  const char *v14; // r0
  unsigned __int16 v15[14]; // [sp+20h] [bp-24h] BYREF

  v10 = a7;
  if ( a1 )
  {
    free(ptr);
    v14 = gai_strerror(a1);
    sub_64E00(3, "giving up resolving host %s: %s (%d)", a4, v14, a1);
  }
  else
  {
    if ( a7 )
    {
      while ( 1 )
      {
        _memcpy_chk(v15, v10[5], v10[4], 28);
        if ( sub_CC78(v15, *((_DWORD *)ptr + 1)) )
          break;
        v10 = (_DWORD *)v10[7];
        if ( !v10 )
          goto LABEL_12;
      }
      if ( (ntp_syslogmask & 1) != 0 )
      {
        v11 = ptr[4];
        if ( v11 == 10 )
        {
          v12 = "(AAAA) ";
        }
        else if ( v11 == 2 )
        {
          v12 = "(A) ";
        }
        else
        {
          v12 = byte_97F7C;
        }
        v13 = sub_6C2E8(v15);
        sub_64E00(6, "DNS %s %s-> %s", a4, v12, v13);
      }
      sub_32898(
        v15,
        0,
        0,
        -1,
        *((_BYTE *)ptr + 16),
        *((_BYTE *)ptr + 17),
        *((_BYTE *)ptr + 18),
        *((_BYTE *)ptr + 19),
        *(_DWORD *)ptr,
        *((_DWORD *)ptr + 5),
        *((_DWORD *)ptr + 3),
        *((const char **)ptr + 6));
    }
LABEL_12:
    free(ptr);
  }
}
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// B7CD4: using guessed type int ntp_syslogmask;

//----- (0000D368) --------------------------------------------------------
char *__fastcall sub_D368(char *result, int a2, int a3, const char *a4, int a5, int a6, _DWORD *a7)
{
  char *v8; // r5
  _DWORD *v9; // r4
  unsigned int v10; // r2
  const char *v11; // r9
  const char *v12; // r0
  int v13; // r11
  const char *v14; // r0
  unsigned __int16 v15[14]; // [sp+10h] [bp-24h] BYREF

  v8 = result;
  v9 = a7;
  if ( result )
  {
    v14 = gai_strerror((int)result);
    return sub_64E00(3, "giving up resolving unpeer %s: %s (%d)", a4, v14, v8);
  }
  else if ( a7 )
  {
    v10 = a7[4];
    if ( v10 > 0x1C )
LABEL_16:
      sub_6ECC0("ntp_config.c", 4345, 2, "res->ai_addrlen <= sizeof(peeraddr)");
    while ( 1 )
    {
      _memcpy_chk(v15, v9[5], v10, 28);
      result = (char *)sub_31A44(v15, 0, 0, -1, 0, 0);
      v13 = (int)result;
      if ( result )
      {
        if ( v15[0] == 10 )
        {
          v11 = "(AAAA) ";
        }
        else if ( v15[0] == 2 )
        {
          v11 = "(A) ";
        }
        else
        {
          v11 = byte_97F7C;
        }
        v12 = sub_6C2E8(v15);
        sub_64E00(5, "unpeered %s %s-> %s", a4, v11, v12);
        sub_36214(v13, (int *)"GONE");
        result = (char *)sub_31FC4(v13);
      }
      v9 = (_DWORD *)v9[7];
      if ( !v9 )
        break;
      v10 = v9[4];
      if ( v10 > 0x1C )
        goto LABEL_16;
    }
  }
  return result;
}
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000D504) --------------------------------------------------------
int __fastcall sub_D504(unsigned __int8 *a1, char *s)
{
  if ( *a1 )
    sub_6D58C(a1, ",", 1024);
  return sub_6D58C(a1, s, 1024);
}

//----- (0000D580) --------------------------------------------------------
char *__fastcall sub_D580(char *s1)
{
  char **v2; // r4
  const char *v3; // r1
  const char *v4; // t1
  char *result; // r0
  const char *v6; // r4
  _UNKNOWN **v7; // r8
  const char *v8; // r6
  const char *v9; // r1
  char **v10; // r8
  const char *v11; // t1
  char *v12; // r0
  const char *v13; // t1
  size_t v14; // r6

  v2 = &off_B601C;
  v3 = off_B601C;
  if ( !off_B601C )
    goto LABEL_6;
  while ( strcmp(s1, v3) )
  {
    v4 = v2[2];
    v2 += 2;
    v3 = v4;
    if ( !v4 )
      goto LABEL_6;
  }
  result = v2[1];
  if ( !result )
  {
LABEL_6:
    v6 = (const char *)off_B606C;
    if ( off_B606C )
    {
      v7 = &off_B606C;
      while ( 1 )
      {
        v14 = strlen(v6);
        if ( !strncmp(s1, v6, v14) )
          break;
        v13 = (const char *)v7[2];
        v7 += 2;
        v6 = v13;
        if ( !v13 )
          goto LABEL_8;
      }
      v8 = &s1[v14];
      v6 = (const char *)v7[1];
    }
    else
    {
LABEL_8:
      v8 = s1;
    }
    v9 = off_B6094;
    if ( !off_B6094 )
      goto LABEL_15;
    v10 = &off_B6094;
    while ( strcmp(v8, v9) )
    {
      v11 = v10[2];
      v10 += 2;
      v9 = v11;
      if ( !v11 )
        goto LABEL_15;
    }
    v12 = v10[1];
    if ( v12 )
    {
      return (char *)((_DWORD)v12 << (char)v6);
    }
    else
    {
LABEL_15:
      sub_64E00(3, "logconfig: '%s' not recognized - ignored", s1);
      return 0;
    }
  }
  return result;
}
// B601C: using guessed type char *off_B601C;
// B606C: using guessed type _UNKNOWN *off_B606C;
// B6094: using guessed type char *off_B6094;

//----- (0000D6D4) --------------------------------------------------------
int __fastcall sub_D6D4(int a1, FILE *s, int a3)
{
  int v3; // r11
  int **v5; // r3
  int *i; // r4
  char *v7; // r9
  const char *v8; // r0
  int v9; // r3
  char *v10; // r0
  int ***v11; // r3
  int **v12; // r4
  const char *v13; // r3
  _DWORD *v14; // r3
  _DWORD *v15; // r4
  char *v16; // r0
  _DWORD *v17; // r3
  _DWORD *v18; // r6
  _DWORD *v19; // r3
  _DWORD *v20; // r4
  char *v21; // r0
  int v22; // r3
  char *v23; // r0
  int ***v24; // r3
  int **v25; // r4
  char *v26; // r0
  int v27; // r3
  const char *v28; // r3
  const char *v29; // r3
  _DWORD *v30; // r3
  _DWORD *v31; // r4
  int v32; // r3
  int v33; // r3
  int v34; // r3
  _DWORD *v35; // r3
  int v36; // r7
  const char *v37; // r0
  _DWORD *v38; // r4
  char *v39; // r0
  int v40; // r3
  _DWORD *v41; // r3
  char *v42; // r0
  char *v43; // r0
  _DWORD *v44; // r3
  _DWORD *v45; // r4
  int v46; // r0
  char *v47; // r0
  int v48; // r3
  char *v49; // r9
  const char *v50; // r0
  _DWORD *v51; // r3
  _DWORD *v52; // r4
  char *v53; // r0
  _DWORD *v54; // r3
  _DWORD *v55; // r4
  char *v56; // r6
  const char *v57; // r0
  int **v58; // r3
  int *v59; // r7
  int v60; // r4
  char *v61; // r0
  int v62; // r3
  int v63; // r6
  const char *v64; // r4
  int v65; // r3
  int v66; // r3
  const char *v67; // r3
  _DWORD *v68; // r3
  _DWORD *v69; // r4
  char *v70; // r0
  _DWORD *v71; // r3
  _DWORD *v72; // r6
  const char *v73; // r4
  _DWORD *v74; // r3
  _DWORD *v75; // r4
  char *v76; // r11
  const char *v77; // r0
  int v78; // r3
  char *v79; // r0
  int ***v80; // r3
  int **v81; // r4
  int ***v82; // r3
  int **v83; // r4
  _DWORD *v84; // r3
  _DWORD *v85; // r4
  _DWORD *v86; // r3
  _DWORD *v87; // r4
  char *v88; // r0
  _DWORD *v89; // r3
  _DWORD *v90; // r4
  char *v91; // r0
  int ***v92; // r3
  int **v93; // r6
  int *v94; // r2
  int *v95; // r4
  const char *v96; // r7
  int v97; // r10
  int *v98; // r3
  int *v99; // r3
  _DWORD *v100; // r4
  int v101; // r0
  char *v102; // r0
  _DWORD *v103; // r3
  _DWORD *v104; // r4
  char *v105; // r6
  int v106; // r0
  char *v107; // r0
  char *v108; // r0
  int v109; // r0
  const char *v110; // r3
  int ***v111; // r3
  int **v112; // r4
  int ***v113; // r3
  int **j; // r4
  char *v115; // r7
  char *v116; // r6
  _DWORD *v117; // r3
  _DWORD *v118; // r4
  _DWORD *v119; // r3
  _DWORD *v120; // r6
  int ***v121; // r3
  int **k; // r4
  int *v123; // r3
  _DWORD *v124; // r3
  _DWORD *v125; // r4
  char *v126; // r0
  int *v128; // r3
  _DWORD *v129; // r3
  struct tm *v130; // r0
  size_t v131; // r0
  int v132; // r3
  const char *v133; // r2
  char *v134; // r0
  const char *v135; // r0
  int v136; // [sp+18h] [bp-6Ch]
  unsigned __int16 v137; // [sp+20h] [bp-64h] BYREF
  unsigned __int8 v138; // [sp+24h] [bp-60h]
  unsigned __int8 v139; // [sp+25h] [bp-5Fh]
  char v140[80]; // [sp+2Ch] [bp-58h] BYREF

  v3 = a1;
  if ( a3 )
  {
    v130 = localtime((const time_t *)(a1 + 32));
    v131 = strftime(v140, 0x50u, "%Y-%m-%d %H:%M:%S", v130);
    v132 = *(_DWORD *)(v3 + 12);
    if ( !v131 )
      v140[0] = 0;
    if ( v132 == 1 )
      v133 = "ntpq remote config from";
    else
      v133 = "startup configuration file";
    _fprintf_chk(s, 1, "# %s %s %s\n", v140, v133, *(const char **)(v3 + 24));
  }
  v5 = *(int ***)(v3 + 160);
  if ( v5 )
  {
    for ( i = *v5; i; i = (int *)*i )
    {
      while ( 1 )
      {
        v9 = i[2];
        if ( v9 != 319 )
          break;
        v10 = sub_1C0BC(i[1]);
        _fprintf_chk(s, 1, "%s %d\n", v10, i[4]);
        i = (int *)*i;
        if ( !i )
          goto LABEL_12;
      }
      if ( v9 == 419 )
      {
        v42 = sub_1C0BC(i[1]);
        _fprintf_chk(s, 1, "%s \"%s\"", v42, (const char *)i[4]);
        if ( i[1] == 290 && *i && *(_DWORD *)(*i + 4) == 441 )
        {
          i = (int *)*i;
          v135 = sub_C7C0();
          _fprintf_chk(s, 1, " %s\n", v135);
        }
        else
        {
          fputc(10, s);
        }
      }
      else if ( v9 == 289 )
      {
        v7 = sub_1C0BC(i[1]);
        v8 = sub_C7C0();
        _fprintf_chk(s, 1, "%s %s\n", v7, v8);
      }
    }
  }
LABEL_12:
  v11 = *(int ****)(v3 + 140);
  if ( v11 )
  {
    v12 = *v11;
    if ( *v11 )
    {
      fwrite("logconfig", 1u, 9u, s);
      do
      {
        _fprintf_chk(s, 1, " %c%s", v12[1], (const char *)v12[4]);
        v12 = (int **)*v12;
      }
      while ( v12 );
      fputc(10, s);
    }
  }
  v13 = *(const char **)(v3 + 64);
  if ( v13 )
    _fprintf_chk(s, 1, "statsdir \"%s\"\n", v13);
  v14 = *(_DWORD **)(v3 + 60);
  if ( v14 )
  {
    v15 = (_DWORD *)*v14;
    if ( *v14 )
    {
      fwrite("statistics", 1u, 0xAu, s);
      do
      {
        v16 = sub_1C0BC(v15[1]);
        _fprintf_chk(s, 1, " %s", v16);
        v15 = (_DWORD *)*v15;
      }
      while ( v15 );
      fputc(10, s);
    }
  }
  v17 = *(_DWORD **)(v3 + 68);
  if ( v17 )
  {
    v18 = (_DWORD *)*v17;
    if ( *v17 )
    {
      do
      {
        while ( 1 )
        {
          v19 = (_DWORD *)v18[2];
          if ( v19 )
          {
            v20 = (_DWORD *)*v19;
            if ( *v19 )
              break;
          }
          v18 = (_DWORD *)*v18;
          if ( !v18 )
            goto LABEL_38;
        }
        v21 = sub_1C0BC(v18[1]);
        _fprintf_chk(s, 1, "filegen %s", v21);
        do
        {
          while ( 1 )
          {
            v22 = v20[1];
            if ( v22 != 433 )
              break;
            v23 = sub_1C0BC(v20[4]);
            _fprintf_chk(s, 1, " type %s", v23);
            v20 = (_DWORD *)*v20;
            if ( !v20 )
              goto LABEL_37;
          }
          if ( v22 == 446 )
          {
            v43 = sub_1C0BC(v20[4]);
            _fprintf_chk(s, 1, " %s", v43);
          }
          else if ( v22 == 298 )
          {
            _fprintf_chk(s, 1, " file %s", (const char *)v20[4]);
          }
          v20 = (_DWORD *)*v20;
        }
        while ( v20 );
LABEL_37:
        fputc(10, s);
        v18 = (_DWORD *)*v18;
      }
      while ( v18 );
    }
  }
LABEL_38:
  v24 = *(int ****)(v3 + 112);
  if ( v24 )
  {
    v25 = *v24;
    if ( *v24 )
    {
      fwrite("crypto", 1u, 6u, s);
      do
      {
        v26 = sub_1C0BC((int)v25[1]);
        _fprintf_chk(s, 1, " %s %s", v26, (const char *)v25[4]);
        v25 = (int **)*v25;
      }
      while ( v25 );
      fputc(10, s);
    }
  }
  v27 = *(_DWORD *)(v3 + 128);
  if ( v27 )
    _fprintf_chk(s, 1, "revoke %d\n", v27);
  v28 = *(const char **)(v3 + 120);
  if ( v28 )
    _fprintf_chk(s, 1, "keysdir \"%s\"\n", v28);
  v29 = *(const char **)(v3 + 116);
  if ( v29 )
    _fprintf_chk(s, 1, "keys \"%s\"\n", v29);
  v30 = *(_DWORD **)(v3 + 132);
  if ( v30 )
  {
    v31 = (_DWORD *)*v30;
    if ( *v30 )
    {
      fwrite("trustedkey", 1u, 0xAu, s);
      do
      {
        while ( 1 )
        {
          v32 = v31[2];
          if ( v32 != 319 )
            break;
          _fprintf_chk(s, 1, " %d", v31[4]);
          v31 = (_DWORD *)*v31;
          if ( !v31 )
            goto LABEL_57;
        }
        if ( v32 == 321 )
          _fprintf_chk(s, 1, " (%d ... %d)", v31[4], v31[5]);
        v31 = (_DWORD *)*v31;
      }
      while ( v31 );
LABEL_57:
      fputc(10, s);
    }
  }
  v33 = *(_DWORD *)(v3 + 104);
  if ( v33 )
    _fprintf_chk(s, 1, "controlkey %d\n", v33);
  v34 = *(_DWORD *)(v3 + 124);
  if ( v34 )
    _fprintf_chk(s, 1, "requestkey %d\n", v34);
  v35 = *(_DWORD **)(v3 + 96);
  v36 = 1;
  v37 = "enable";
  if ( !v35 )
    goto LABEL_67;
  v38 = (_DWORD *)*v35;
  if ( !*v35 )
    goto LABEL_67;
  while ( 1 )
  {
    fputs(v37, s);
    do
    {
      v39 = sub_1C0BC(v38[4]);
      _fprintf_chk(s, 1, " %s", v39);
      v38 = (_DWORD *)*v38;
    }
    while ( v38 );
    fputc(10, s);
LABEL_67:
    v40 = v36 - 1;
    v36 = 0;
    if ( v40 == -1 )
      break;
    v41 = *(_DWORD **)(v3 + 100);
    if ( !v41 )
      break;
    v38 = (_DWORD *)*v41;
    if ( !*v41 )
      break;
    v37 = "disable";
  }
  v44 = *(_DWORD **)(v3 + 56);
  if ( v44 )
  {
    v45 = (_DWORD *)*v44;
    if ( *v44 )
    {
      fwrite("tos", 1u, 3u, s);
      do
      {
        while ( 1 )
        {
          v48 = v45[2];
          if ( v48 != 289 )
            break;
          v49 = sub_1C0BC(v45[1]);
          v50 = sub_C7C0();
          _fprintf_chk(s, 1, " %s %s", v49, v50);
          v45 = (_DWORD *)*v45;
          if ( !v45 )
            goto LABEL_85;
        }
        if ( v48 == 319 )
        {
          v46 = v45[1];
          if ( v46 == 267 )
          {
            sub_65BF4((int)&v137, v45[4] + 693596);
            v134 = sub_1C0BC(v45[1]);
            _fprintf_chk(s, 1, " %s \"%04hu-%02hu-%02hu\"", v134, v137, v138, v139);
          }
          else
          {
            v47 = sub_1C0BC(v46);
            _fprintf_chk(s, 1, " %s %d", v47, v45[4]);
          }
        }
        v45 = (_DWORD *)*v45;
      }
      while ( v45 );
LABEL_85:
      fputc(10, s);
    }
  }
  v51 = *(_DWORD **)(v3 + 88);
  if ( v51 )
  {
    v52 = (_DWORD *)*v51;
    if ( *v51 )
    {
      fwrite("rlimit", 1u, 6u, s);
      do
      {
        if ( v52[2] != 319 )
          sub_6ECC0("ntp_config.c", 760, 2, "319 == atrv->type");
        v53 = sub_1C0BC(v52[1]);
        _fprintf_chk(s, 1, " %s %d", v53, v52[4]);
        v52 = (_DWORD *)*v52;
      }
      while ( v52 );
      fputc(10, s);
    }
  }
  v54 = *(_DWORD **)(v3 + 92);
  if ( v54 )
  {
    v55 = (_DWORD *)*v54;
    if ( *v54 )
    {
      fwrite("tinker", 1u, 6u, s);
      do
      {
        if ( v55[2] != 289 )
          sub_6ECC0("ntp_config.c", 771, 2, "289 == atrv->type");
        v56 = sub_1C0BC(v55[1]);
        v57 = sub_C7C0();
        _fprintf_chk(s, 1, " %s %s", v56, v57);
        v55 = (_DWORD *)*v55;
      }
      while ( v55 );
      fputc(10, s);
    }
  }
  if ( *(_DWORD *)(v3 + 44) )
    fwrite("broadcastclient\n", 1u, 0x10u, s);
  v58 = *(int ***)(v3 + 36);
  if ( v58 )
  {
    v59 = *v58;
    if ( *v58 )
    {
      v136 = v3;
      do
      {
        v60 = v59[2];
        v61 = sub_1C0BC(v59[1]);
        fputs(v61, s);
        v62 = *(unsigned __int16 *)(v60 + 8);
        if ( v62 == 2 )
        {
          fwrite(" -4", 1u, 3u, s);
        }
        else if ( v62 == 10 )
        {
          fwrite(" -6", 1u, 3u, s);
        }
        _fprintf_chk(s, 1, " %s", *(const char **)(v60 + 4));
        if ( *((_BYTE *)v59 + 16) )
          _fprintf_chk(s, 1, " minpoll %u", *((unsigned __int8 *)v59 + 16));
        if ( *((_BYTE *)v59 + 17) )
          _fprintf_chk(s, 1, " maxpoll %u", *((unsigned __int8 *)v59 + 17));
        v63 = v59[5];
        if ( v63 )
        {
          v64 = *(const char **)(v60 + 4);
          if ( strlen(v64) > 8 && !memcmp(v64, "127.127.", 8u) )
            _fprintf_chk(s, 1, " mode %u", v63);
          else
            _fprintf_chk(s, 1, " ttl %u", v63);
        }
        v65 = *((unsigned __int8 *)v59 + 24);
        if ( v65 != 4 )
          _fprintf_chk(s, 1, " version %u", v65);
        v66 = v59[7];
        if ( v66 )
          _fprintf_chk(s, 1, " key %u", v66);
        v67 = (const char *)v59[8];
        if ( v67 )
          _fprintf_chk(s, 1, " ident \"%s\"", v67);
        v68 = (_DWORD *)v59[3];
        if ( v68 )
        {
          v69 = (_DWORD *)*v68;
          if ( *v68 )
          {
            if ( v69[1] != 446 )
LABEL_252:
              sub_6ECC0("ntp_config.c", 832, 2, "446 == atrv->attr");
            if ( v69[2] != 319 )
LABEL_253:
              sub_6ECC0("ntp_config.c", 833, 2, "319 == atrv->type");
            while ( 1 )
            {
              v70 = sub_1C0BC(v69[4]);
              _fprintf_chk(s, 1, " %s", v70);
              v69 = (_DWORD *)*v69;
              if ( !v69 )
                break;
              if ( v69[1] != 446 )
                goto LABEL_252;
              if ( v69[2] != 319 )
                goto LABEL_253;
            }
          }
        }
        fputc(10, s);
        v71 = *(_DWORD **)(v136 + 84);
        if ( v71 )
        {
          v72 = (_DWORD *)*v71;
          if ( *v71 )
          {
            do
            {
              while ( 1 )
              {
                v73 = *(const char **)(v59[2] + 4);
                if ( !strcmp(v73, *(const char **)(v72[1] + 4)) )
                  break;
                v72 = (_DWORD *)*v72;
                if ( !v72 )
                  goto LABEL_143;
              }
              _fprintf_chk(s, 1, "fudge %s", v73);
              v74 = (_DWORD *)v72[2];
              if ( v74 )
              {
                v75 = (_DWORD *)*v74;
                if ( *v74 )
                {
                  do
                  {
                    while ( 1 )
                    {
                      v78 = v75[2];
                      if ( v78 != 319 )
                        break;
                      v79 = sub_1C0BC(v75[1]);
                      _fprintf_chk(s, 1, " %s %d", v79, v75[4]);
                      v75 = (_DWORD *)*v75;
                      if ( !v75 )
                        goto LABEL_142;
                    }
                    if ( v78 == 419 )
                    {
                      v108 = sub_1C0BC(v75[1]);
                      _fprintf_chk(s, 1, " %s %s", v108, (const char *)v75[4]);
                    }
                    else if ( v78 == 289 )
                    {
                      v76 = sub_1C0BC(v75[1]);
                      v77 = sub_C7C0();
                      _fprintf_chk(s, 1, " %s %s", v76, v77);
                    }
                    v75 = (_DWORD *)*v75;
                  }
                  while ( v75 );
                }
              }
LABEL_142:
              fputc(10, s);
              v72 = (_DWORD *)*v72;
            }
            while ( v72 );
          }
        }
LABEL_143:
        v59 = (int *)*v59;
      }
      while ( v59 );
      v3 = v136;
    }
  }
  v80 = *(int ****)(v3 + 48);
  if ( v80 )
  {
    v81 = *v80;
    if ( *v80 )
    {
      fwrite("manycastserver", 1u, 0xEu, s);
      do
      {
        _fprintf_chk(s, 1, " %s", (const char *)v81[1]);
        v81 = (int **)*v81;
      }
      while ( v81 );
      fputc(10, s);
    }
  }
  v82 = *(int ****)(v3 + 52);
  if ( v82 )
  {
    v83 = *v82;
    if ( *v82 )
    {
      fwrite("multicastclient", 1u, 0xFu, s);
      do
      {
        _fprintf_chk(s, 1, " %s", (const char *)v83[1]);
        v83 = (int **)*v83;
      }
      while ( v83 );
      fputc(10, s);
    }
  }
  v84 = *(_DWORD **)(v3 + 40);
  if ( v84 )
  {
    v85 = (_DWORD *)*v84;
    if ( *v84 )
    {
      do
      {
        _fprintf_chk(s, 1, "unpeer %s\n", *(const char **)(v85[2] + 4));
        v85 = (_DWORD *)*v85;
      }
      while ( v85 );
    }
  }
  v86 = *(_DWORD **)(v3 + 76);
  if ( v86 )
  {
    v87 = (_DWORD *)*v86;
    if ( *v86 )
    {
      fwrite("mru", 1u, 3u, s);
      do
      {
        v88 = sub_1C0BC(v87[1]);
        _fprintf_chk(s, 1, " %s %d", v88, v87[4]);
        v87 = (_DWORD *)*v87;
      }
      while ( v87 );
      fputc(10, s);
    }
  }
  v89 = *(_DWORD **)(v3 + 72);
  if ( v89 )
  {
    v90 = (_DWORD *)*v89;
    if ( *v89 )
    {
      fwrite("discard", 1u, 7u, s);
      do
      {
        v91 = sub_1C0BC(v90[1]);
        _fprintf_chk(s, 1, " %s %d", v91, v90[4]);
        v90 = (_DWORD *)*v90;
      }
      while ( v90 );
      fputc(10, s);
    }
  }
  v92 = *(int ****)(v3 + 80);
  if ( v92 )
  {
    v93 = *v92;
    if ( *v92 )
    {
      while ( 1 )
      {
        v94 = v93[1];
        if ( !v94 )
          break;
        v95 = v93[2];
        v96 = (const char *)v94[1];
        if ( !v95 )
          goto LABEL_174;
        v97 = v95[1];
        if ( *((_WORD *)v94 + 4) != 2
          || strcmp((const char *)v94[1], "0.0.0.0")
          || (v109 = strcmp((const char *)v97, "0.0.0.0"), v110 = "-4 default", v109) )
        {
          if ( *((_WORD *)v95 + 4) != 10 )
            goto LABEL_174;
          if ( *v96 != 58 || v96[1] != 58 )
            goto LABEL_196;
          if ( v96[2] )
            goto LABEL_174;
          if ( *(_BYTE *)v97 != 58 || *(_BYTE *)(v97 + 1) != 58 )
          {
LABEL_196:
            _fprintf_chk(s, 1, "restrict %s", v96);
            v98 = v93[2];
            if ( !v98 )
              goto LABEL_175;
            goto LABEL_197;
          }
          if ( *(_BYTE *)(v97 + 2) )
            goto LABEL_174;
          v110 = "-6 default";
        }
        _fprintf_chk(s, 1, "restrict %s", v110);
LABEL_175:
        _fprintf_chk(s, 1, " ippeerlimit %d", *((__int16 *)v93 + 10));
        v99 = v93[3];
        if ( v99 )
        {
          v100 = (_DWORD *)*v99;
          if ( *v99 )
          {
            do
            {
              v101 = v100[1];
              if ( v101 != 409 )
              {
                v102 = sub_1C0BC(v101);
                _fprintf_chk(s, 1, " %s", v102);
              }
              v100 = (_DWORD *)*v100;
            }
            while ( v100 );
          }
        }
        fputc(10, s);
        v93 = (int **)*v93;
        if ( !v93 )
          goto LABEL_181;
      }
      v128 = v93[3];
      if ( v128 )
      {
        v129 = (_DWORD *)*v128;
        if ( v129 )
        {
          if ( v129[1] == 409 )
          {
            v96 = "source";
          }
          else
          {
            do
            {
              v129 = (_DWORD *)*v129;
              if ( !v129 )
              {
                v96 = "default";
                goto LABEL_174;
              }
            }
            while ( v129[1] != 409 );
            v96 = "source";
          }
        }
        else
        {
          v96 = "default";
        }
      }
      else
      {
        v96 = "default";
      }
LABEL_174:
      _fprintf_chk(s, 1, "restrict %s", v96);
      v98 = v93[2];
      if ( !v98 )
        goto LABEL_175;
LABEL_197:
      _fprintf_chk(s, 1, " mask %s", (const char *)v98[1]);
      goto LABEL_175;
    }
  }
LABEL_181:
  v103 = *(_DWORD **)(v3 + 164);
  if ( v103 )
  {
    v104 = (_DWORD *)*v103;
    if ( *v103 )
    {
      do
      {
        v105 = sub_1C0BC(v104[3]);
        v106 = v104[1];
        if ( v106 )
          v107 = sub_1C0BC(v106);
        else
          v107 = (char *)v104[2];
        _fprintf_chk(s, 1, "interface %s %s\n", v105, v107);
        v104 = (_DWORD *)*v104;
      }
      while ( v104 );
    }
  }
  v111 = *(int ****)(v3 + 144);
  if ( v111 )
  {
    v112 = *v111;
    if ( *v111 )
    {
      fwrite("phone", 1u, 5u, s);
      do
      {
        _fprintf_chk(s, 1, " \"%s\"", (const char *)v112[1]);
        v112 = (int **)*v112;
      }
      while ( v112 );
      fputc(10, s);
    }
  }
  v113 = *(int ****)(v3 + 148);
  if ( v113 )
  {
    for ( j = *v113; j; j = (int **)*j )
    {
      v115 = sub_1C50C((char *)j[1]);
      v116 = sub_1C50C((char *)j[2]);
      _fprintf_chk(s, 1, "setvar %s = %s", v115, v116);
      free(v115);
      free(v116);
      if ( j[3] )
        fwrite(" default", 1u, 8u, s);
      fputc(10, s);
    }
  }
  v117 = *(_DWORD **)(v3 + 152);
  if ( v117 )
  {
    v118 = (_DWORD *)*v117;
    if ( *v117 )
    {
      fwrite("ttl", 1u, 3u, s);
      do
      {
        _fprintf_chk(s, 1, " %d", v118[1]);
        v118 = (_DWORD *)*v118;
      }
      while ( v118 );
      fputc(10, s);
    }
  }
  v119 = *(_DWORD **)(v3 + 156);
  if ( v119 )
  {
    v120 = (_DWORD *)*v119;
    if ( *v119 )
    {
      do
      {
        _fprintf_chk(s, 1, "trap %s", *(const char **)(v120[1] + 4));
        v121 = (int ***)v120[2];
        if ( v121 )
        {
          for ( k = *v121; k; k = (int **)*k )
          {
            while ( 1 )
            {
              v123 = k[1];
              if ( v123 != &dword_140 )
                break;
              _fprintf_chk(s, 1, " interface %s", (const char *)k[4]);
              k = (int **)*k;
              if ( !k )
                goto LABEL_227;
            }
            if ( v123 == (int *)((char *)&dword_180[2] + 1) )
              _fprintf_chk(s, 1, " port %d", k[4]);
          }
        }
LABEL_227:
        fputc(10, s);
        v120 = (_DWORD *)*v120;
      }
      while ( v120 );
    }
  }
  v124 = *(_DWORD **)(v3 + 168);
  if ( v124 )
  {
    v125 = (_DWORD *)*v124;
    if ( *v124 )
    {
      fwrite("reset", 1u, 5u, s);
      do
      {
        v126 = sub_1C0BC(v125[1]);
        _fprintf_chk(s, 1, " %s", v126);
        v125 = (_DWORD *)*v125;
      }
      while ( v125 );
      fputc(10, s);
    }
  }
  return 0;
}
// 140: using guessed type int;
// 180: using guessed type int[4];
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0000ED20) --------------------------------------------------------
int __fastcall sub_ED20(FILE *s, int a2)
{
  _DWORD *v4; // r4
  int v5; // r5
  int v6; // r0

  v4 = (_DWORD *)cfg_tree_history;
  if ( !cfg_tree_history )
    return 0;
  v5 = 0;
  do
  {
    v6 = sub_D6D4((int)v4, s, a2);
    v4 = (_DWORD *)*v4;
    v5 |= v6;
  }
  while ( v4 );
  return v5;
}
// 1074E8: using guessed type int cfg_tree_history;

//----- (0000EDB0) --------------------------------------------------------
_DWORD *__fastcall sub_EDB0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r2
  _DWORD **v4; // r3
  _DWORD *v5; // r1

  v2 = a1;
  if ( !a1 )
    v2 = sub_63BA4(0, 8u, 0, 1);
  if ( a2 )
  {
    v4 = (_DWORD **)v2[1];
    v5 = 0;
    *a2 = 0;
    if ( v4 )
    {
      v5 = *v4;
    }
    else
    {
      *v2 = a2;
      v2[1] = v2;
    }
    if ( v4 )
    {
      *v5 = a2;
      v2[1] = *v4;
    }
  }
  return v2;
}

//----- (0000EE48) --------------------------------------------------------
_DWORD *__fastcall sub_EE48(_DWORD *result, _DWORD *ptr)
{
  _DWORD *v3; // r4
  _DWORD *v4; // r3
  _DWORD **v5; // r2
  int v6; // r0
  int v7; // r1

  v3 = result;
  if ( !result )
    return ptr;
  if ( ptr )
  {
    v4 = (_DWORD *)ptr[1];
    if ( v4 )
    {
      v5 = (_DWORD **)result[1];
      if ( v5 )
      {
        **v5 = *ptr;
        if ( v4 == ptr )
          v4 = *v5;
        result[1] = v4;
      }
      else
      {
        v6 = *ptr;
        v7 = ptr[1];
        *v3 = v6;
        v3[1] = v7;
      }
    }
    free(ptr);
    return v3;
  }
  return result;
}

//----- (0000EEF0) --------------------------------------------------------
int __fastcall sub_EEF0(int *a1, void (**a2)(void *ptr))
{
  void (**v3)(void *); // r5
  int v4; // r3
  bool v5; // zf
  int *v6; // r0

  if ( a1 )
  {
    v3 = a2;
    if ( !a2 )
      v3 = &free;
    while ( 1 )
    {
      v6 = (int *)*a1;
      if ( !*a1 )
        break;
      v4 = *v6;
      v5 = *v6 == 0;
      *a1 = *v6;
      if ( v5 )
      {
        a1[1] = v4;
      }
      else if ( (int *)a1[1] == v6 )
      {
        a1[1] = (int)a1;
      }
      ((void (*)(void))v3)();
    }
    free(a1);
  }
  return 0;
}

//----- (0000EF98) --------------------------------------------------------
void __fastcall destroy_attr_val(int a1)
{
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 8) == 419 )
      free(*(void **)(a1 + 16));
    free((void *)a1);
  }
}

//----- (0000F020) --------------------------------------------------------
_DWORD *__fastcall sub_F020(int a1)
{
  __int64 v1; // d0
  _DWORD *result; // r0

  result = sub_63BA4(0, 0x18u, 0, 1);
  result[1] = a1;
  *((_QWORD *)result + 2) = v1;
  result[2] = 289;
  return result;
}
// F070: variable 'v1' is possibly undefined

//----- (0000F098) --------------------------------------------------------
_DWORD *__fastcall sub_F098(int a1, int a2)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 0x18u, 0, 1);
  result[1] = a1;
  result[4] = a2;
  result[2] = 319;
  return result;
}

//----- (0000F108) --------------------------------------------------------
_DWORD *__fastcall sub_F108(int a1, int a2)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 0x18u, 0, 1);
  result[1] = a1;
  result[4] = a2;
  result[2] = 434;
  return result;
}

//----- (0000F178) --------------------------------------------------------
_DWORD *__fastcall sub_F178(int a1, int a2, int a3)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 0x18u, 0, 1);
  result[1] = a1;
  result[4] = a2;
  result[5] = a3;
  result[2] = 321;
  return result;
}

//----- (0000F1F0) --------------------------------------------------------
_DWORD *__fastcall sub_F1F0(int a1, void *a2)
{
  _DWORD *v4; // r4

  v4 = sub_63BA4(0, 0x18u, 0, 1);
  v4[1] = a1;
  if ( !a2 )
    a2 = sub_63D08(byte_97F7C);
  v4[4] = a2;
  v4[2] = 419;
  return v4;
}

//----- (0000F288) --------------------------------------------------------
_DWORD *__fastcall sub_F288(int a1)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 8u, 0, 1);
  result[1] = a1;
  return result;
}

//----- (0000F2E8) --------------------------------------------------------
_DWORD *__fastcall sub_F2E8(int a1)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 8u, 0, 1);
  result[1] = a1;
  return result;
}

//----- (0000F348) --------------------------------------------------------
_DWORD *__fastcall sub_F348(int a1, int a2)
{
  __int16 v3; // r4
  bool v4; // zf
  _DWORD *result; // r0

  if ( !a1 )
    sub_6ECC0("ntp_config.c", 1267, 0, "((void *)0) != addr");
  v3 = a2;
  v4 = (a2 & 0xFFFFFFFD) == 0;
  if ( (a2 & 0xFFFFFFFD) != 0 )
    v4 = a2 == 10;
  if ( !v4 )
    sub_6ECC0("ntp_config.c", 1268, 0, "2 == type || 10 == type || 0 == type");
  result = sub_63BA4(0, 0xCu, 0, 1);
  result[1] = a1;
  *((_WORD *)result + 4) = v3;
  return result;
}

//----- (0000F410) --------------------------------------------------------
void __fastcall sub_F410(_DWORD *a1)
{
  void *v2; // r0

  if ( a1 )
  {
    v2 = (void *)a1[1];
    if ( !v2 )
      sub_6ECC0("ntp_config.c", 1284, 0, "((void *)0) != my_node->address");
    free(v2);
    free(a1);
  }
}

//----- (0000F4B0) --------------------------------------------------------
_DWORD *__fastcall sub_F4B0(int a1, int a2, int **a3)
{
  _DWORD *v6; // r6
  int *v7; // r4
  int v8; // r7
  _DWORD *v9; // r0
  int *v10; // r3
  bool v11; // zf
  signed int v12; // r0
  const char *v13; // r0
  unsigned int v15; // r3
  int v16; // r2
  unsigned int v17; // r3
  unsigned int v18; // r2
  int v19; // r3
  void *v20; // r0

  v6 = sub_63BA4(0, 0x24u, 0, 1);
  v6[1] = a1;
  v6[2] = a2;
  *((_BYTE *)v6 + 24) = 4;
  if ( !a3 )
    return v6;
  v7 = *a3;
  if ( !*a3 )
  {
    free(a3);
    return v6;
  }
  v8 = 0;
  do
  {
    while ( 1 )
    {
      v10 = (int *)*v7;
      v11 = *v7 == 0;
      *a3 = (int *)*v7;
      if ( v11 )
      {
        a3[1] = v10;
      }
      else if ( a3[1] == v7 )
      {
        a3[1] = (int *)a3;
      }
      v12 = v7[1];
      if ( v12 == 359 )
      {
        v16 = v7[4];
        if ( (unsigned int)(v16 - 3) > 0xFC )
        {
          sub_64E00(6, "minpoll: provided value (%d) is out of range [%d-%d])", v16, 3, 255);
          *((_BYTE *)v6 + 16) = 3;
        }
        else
        {
          *((_BYTE *)v6 + 16) = v16;
        }
        goto LABEL_19;
      }
      if ( v12 < 360 )
      {
        switch ( v12 )
        {
          case 329:
            v19 = v7[4];
            if ( v19 == -1 )
            {
              v8 = 1;
              sub_64E00(3, "key: invalid argument");
            }
            else
            {
              v6[7] = v19;
            }
            break;
          case 351:
            v18 = v7[4];
            if ( v18 > 0x11 )
            {
              sub_64E00(6, "maxpoll: provided value (%d) is out of range [0-%d])", v18, 17);
              *((_BYTE *)v6 + 17) = 17;
            }
            else
            {
              *((_BYTE *)v6 + 17) = v18;
            }
            break;
          case 312:
            v6[8] = v7[4];
            break;
          default:
            goto LABEL_18;
        }
        goto LABEL_19;
      }
      if ( v12 == 432 )
      {
        if ( sub_C8E0(a2) )
        {
          v8 = 1;
          sub_64E00(3, "'ttl' does not apply for refclocks");
        }
        else
        {
          v15 = v7[4];
          if ( v15 <= 7 )
            goto LABEL_35;
          sub_64E00(3, "ttl: invalid argument");
          v8 = 1;
        }
        goto LABEL_19;
      }
      if ( v12 <= 432 )
        break;
      if ( v12 == 440 )
      {
        v17 = v7[4];
        if ( v17 > 0xFE )
        {
          sub_64E00(3, "version: invalid argument");
          v8 = 1;
        }
        else
        {
          *((_BYTE *)v6 + 24) = v17;
        }
        goto LABEL_19;
      }
      if ( v12 != 446 )
        goto LABEL_18;
      v9 = sub_EDB0((_DWORD *)v6[3], v7);
      v7 = *a3;
      v6[3] = v9;
      if ( !v7 )
        goto LABEL_20;
    }
    if ( v12 != 361 )
    {
LABEL_18:
      v13 = sub_1BBB4(v12);
      v8 = 1;
      sub_64E00(3, "Unknown peer/server option token %s", v13);
      goto LABEL_19;
    }
    if ( sub_C8E0(a2) )
    {
      v15 = v7[4];
LABEL_35:
      v6[5] = v15;
      goto LABEL_19;
    }
    sub_64E00(3, "'mode' does not apply for network peers");
    v8 = 1;
LABEL_19:
    free(v7);
    v7 = *a3;
  }
  while ( *a3 );
LABEL_20:
  free(a3);
  if ( v8 )
  {
    v20 = v6;
    v6 = v7;
    free(v20);
  }
  return v6;
}

//----- (0000F7BC) --------------------------------------------------------
_WORD *__fastcall sub_F7BC(_DWORD *a1)
{
  _WORD *v2; // r6
  const unsigned __int16 **v3; // r0
  unsigned int v4; // r2
  const unsigned __int16 *v5; // r12
  int v6; // r0
  int v7; // r3
  int v8; // t1
  int v9; // r1
  _BOOL4 v10; // r0

  v2 = sub_63BA4(0, 0xCu, 0, 1);
  v3 = _ctype_b_loc();
  v4 = 0;
  v5 = *v3;
  v6 = a1[1] - 1;
  while ( 1 )
  {
    v8 = *(unsigned __int8 *)++v6;
    v7 = v8;
    v9 = v5[v8] & 0x800;
    if ( (v5[v8] & 0x800) == 0 )
      break;
    v4 = (v7 - 48 + 10 * v4) | v4 & 0xFF000000;
  }
  v10 = v4 < 0x10000;
  if ( v7 )
    v10 = 0;
  if ( v10 )
  {
    v2[2] = v4;
    *((_DWORD *)v2 + 2) = v9;
    sub_F410(a1);
  }
  else
  {
    v2[2] = 0;
    *((_DWORD *)v2 + 2) = a1;
  }
  return v2;
}

//----- (0000F898) --------------------------------------------------------
_DWORD *__fastcall sub_F898(int a1, int a2)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 0xCu, 0, 1);
  result[1] = a1;
  result[2] = a2;
  return result;
}

//----- (0000F900) --------------------------------------------------------
_DWORD *__fastcall sub_F900(int a1, int a2, __int16 a3, int a4, int a5)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 0x18u, 0, 1);
  result[1] = a1;
  result[2] = a2;
  *((_WORD *)result + 10) = a3;
  result[3] = a4;
  result[4] = a5;
  return result;
}

//----- (0000F980) --------------------------------------------------------
_DWORD *__fastcall sub_F980(const char *a1, int a2, int a3)
{
  char *v6; // r0
  _DWORD *result; // r0

  v6 = strchr(a1, 61);
  if ( v6 )
    *v6 = 0;
  result = sub_63BA4(0, 0x10u, 0, 1);
  result[1] = a1;
  result[2] = a2;
  result[3] = a3;
  return result;
}

//----- (0000FA04) --------------------------------------------------------
_DWORD *__fastcall sub_FA04(int a1, int a2, int a3)
{
  int v4; // r2
  _DWORD *result; // r0

  v4 = a2;
  if ( a2 )
    v4 = 1;
  if ( a1 )
    v4 = 1;
  if ( !v4 )
    sub_6ECC0("ntp_config.c", 1688, 0, "match_class != 0 || if_name != ((void *)0)");
  result = sub_63BA4(0, 0x10u, 0, 1);
  result[1] = a1;
  result[2] = a2;
  result[3] = a3;
  return result;
}

//----- (0000FAAC) --------------------------------------------------------
_DWORD *__fastcall sub_FAAC(int a1, int a2)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 0xCu, 0, 1);
  result[1] = a1;
  result[2] = a2;
  return result;
}

//----- (0000FB14) --------------------------------------------------------
_DWORD *__fastcall sub_FB14(int a1, int a2)
{
  _DWORD *result; // r0

  result = sub_63BA4(0, 0xCu, 0, 0);
  result[1] = a1;
  result[2] = a2;
  return result;
}

//----- (0000FB7C) --------------------------------------------------------
char *__fastcall sub_FB7C(char *result, unsigned __int64 a2)
{
  unsigned __int64 v3; // r6
  int v4; // r4
  unsigned __int64 v5; // [sp+0h] [bp-18h] BYREF
  unsigned __int64 v6; // [sp+8h] [bp-10h]

  v3 = a2;
  if ( result == &byte_7 )
  {
    v6 = a2;
    v5 = a2;
    result = (char *)setrlimit64(7, &v5);
    if ( result == (char *)-1 )
      return sub_64E00(3, "Cannot set RLIMIT_NOFILE: %m");
  }
  else
  {
    v4 = (int)result;
    if ( result == &byte_8 )
    {
      if ( (*(int *)((_BYTE *)&elf_hash_bucket[261] + (_DWORD)off_B611C) & 0xF) == 0 )
      {
        v6 = a2;
        v5 = a2;
        result = (char *)setrlimit64(8, &v5);
        if ( result == (char *)-1 )
          return sub_64E00(3, "Cannot set RLIMIT_MEMLOCK: %m");
      }
    }
    else
    {
      if ( result != (_BYTE *)&dword_0 + 3 )
        sub_C954("ntp_rlimit: unexpected RLIMIT case: %d", result);
      if ( getrlimit64(3, &v5) == -1 )
      {
        return sub_64E00(v4, "getrlimit(RLIMIT_STACK) failed: %m");
      }
      else
      {
        if ( v6 < v3 )
        {
          sub_64E00(4, "ntp_rlimit: using maximum allowed stack limit %lu instead of %lu.", (_DWORD)v6, (_DWORD)v3);
          v3 = v6;
        }
        v5 = v3;
        result = (char *)setrlimit64(3, &v5);
        if ( result == (char *)-1 )
          return sub_64E00(3, "ntp_rlimit: Cannot set RLIMIT_STACK: %m");
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 7: using guessed type char;
// 8: using guessed type char;
// 1BC: using guessed type int elf_hash_bucket[521];
// B818: using guessed type int __fastcall getrlimit64(_DWORD, _DWORD);
// BFD4: using guessed type int __fastcall setrlimit64(_DWORD, _DWORD);
// B611C: using guessed type _UNKNOWN *off_B611C;

//----- (0000FD04) --------------------------------------------------------
void __fastcall sub_FD04(int a1)
{
  int *v2; // r2
  FILE *v3; // r0
  int v4; // r0
  int v5; // r4
  _DWORD *v6; // r3
  _DWORD *v7; // r4
  const char *v8; // r0
  int v9; // r10
  char *v10; // r5
  char *v11; // r0
  char *v12; // r11
  int v13; // r0
  int v14; // r1
  char *v15; // r1
  _DWORD *v16; // r3
  _DWORD *v17; // r4
  char *v18; // r7
  int v19; // r0
  _DWORD *v20; // r3
  _DWORD *v21; // r7
  char *v22; // r9
  int v23; // r0
  _DWORD *v24; // r2
  int v25; // r3
  int v26; // r5
  _DWORD *v27; // r12
  int v28; // r1
  int v29; // r1
  int ***v30; // r3
  int **i; // r4
  int v32; // r0
  int v33; // r1
  int v34; // r1
  const char *v35; // r3
  const char *v36; // r3
  _DWORD *v37; // r0
  _DWORD *v38; // r3
  int v39; // r2
  int v40; // r6
  bool v41; // r1
  int v43; // r2
  int v44; // r2
  const char *v45; // r0
  _DWORD *v46; // r3
  _DWORD *v47; // r4
  int v48; // r9
  bool v49; // cc
  int v50; // r3
  int v51; // r8
  int v52; // r2
  double **v53; // r0
  int v54; // r6
  int v55; // r5
  int v56; // r7
  double *v57; // r4
  double v58; // d7
  int v59; // r3
  bool v60; // cc
  _DWORD *v61; // r3
  _DWORD *v62; // r4
  int v63; // r1
  int v64; // r0
  double v65; // d7
  int v66; // r0
  int **v67; // r3
  int *v68; // r4
  int v69; // r0
  _DWORD *v70; // r3
  _DWORD *v71; // r4
  int v72; // r0
  char *v73; // r0
  int v74; // r3
  int ***v75; // r1
  unsigned int v76; // r3
  int v77; // r3
  int v78; // r3
  void **v79; // r3
  _DWORD *v80; // r3
  __int16 v81; // r10
  _DWORD *v82; // r2
  int v83; // r8
  int v84; // r9
  int v85; // r1
  int v86; // r3
  const char *v87; // r5
  int v88; // r2
  int v89; // r0
  const struct addrinfo *v90; // r0
  const struct addrinfo *v91; // r3
  int v92; // r0
  int v93; // r12
  const char *v94; // r0
  struct addrinfo *v95; // r6
  struct sockaddr *ai_addr; // r1
  socklen_t ai_addrlen; // r2
  int sa_family; // r2
  bool v99; // zf
  int v100; // r3
  int v101; // r0
  _DWORD *v102; // r3
  _DWORD *v103; // r4
  void *v104; // r0
  int v105; // r1
  int v106; // r3
  int v107; // r2
  unsigned int v108; // r2
  char *v109; // r0
  _DWORD *v110; // r3
  _DWORD *v111; // r4
  int v112; // r1
  int v113; // r2
  int ***v114; // r3
  int **k; // r4
  int v116; // r1
  int ***v117; // r3
  int **v118; // r4
  unsigned int v119; // r5
  void *v120; // r0
  int ***v121; // r3
  int **v122; // r4
  void *v123; // r6
  size_t v124; // r5
  size_t v125; // r5
  __int16 v126; // r2
  _DWORD *v127; // r3
  _DWORD *v128; // r4
  unsigned int v129; // r5
  int v130; // r3
  double **v131; // r3
  double *m; // r4
  int v133; // r2
  const char *v134; // r6
  int v135; // r0
  unsigned int v136; // r6
  void *v137; // r0
  const char *v138; // r3
  _DWORD *v139; // r3
  _DWORD *v140; // r5
  _DWORD *v141; // r3
  _DWORD *v142; // r4
  unsigned int v143; // r11
  char *v144; // r7
  int v145; // r6
  int v146; // r3
  int v147; // r2
  sa_family_t v148; // r3
  _DWORD *v149; // r0
  _DWORD *v150; // r7
  int v151; // t1
  int v152; // r2
  int v153; // r3
  int v154; // r12
  int v155; // r2
  int v156; // r3
  __int16 *v157; // r1
  int **v158; // r3
  int *n; // r6
  int v160; // r0
  int **v161; // r3
  int *v162; // r6
  int v163; // r0
  int *v164; // r3
  _WORD *v165; // r7
  int v166; // r12
  const char *v167; // r0
  int **v168; // r3
  int *v169; // r4
  int v170; // r0
  unsigned __int8 v171; // r9
  int v172; // r1
  unsigned int v173; // r0
  int v174; // r3
  _DWORD *v175; // r0
  __int64 v176; // r2
  int v177; // r7
  unsigned int v178; // r0
  int v179; // r12
  int v180; // r1
  int v181; // r3
  int v182; // r1
  int v183; // r12
  const char *v184; // r0
  int ***v185; // r3
  int **ii; // r5
  int *v187; // r3
  const char *v188; // r6
  _DWORD *v189; // r4
  const char *v190; // r0
  _DWORD *v191; // r3
  _DWORD *v192; // r9
  int v193; // r11
  int **v194; // r3
  int *v195; // r4
  signed int v196; // r0
  char v197; // r2
  __int64 v198; // r0
  _DWORD *v199; // r3
  _DWORD *v200; // r4
  int v201; // r3
  const char *v202; // r7
  __int16 v203; // r3
  unsigned int v204; // r0
  unsigned int v205; // r0
  char v206; // r2
  char v207; // r2
  char v208; // r2
  size_t v209; // r0
  int v210; // r2
  _BYTE *v211; // r0
  int **v212; // r3
  int *v213; // r0
  int v214; // r4
  _BYTE *v215; // r0
  int v216; // r2
  int v217; // r3
  int v218; // r4
  const char *v219; // r0
  const char *v220; // r6
  _BYTE *v221; // r0
  int v222; // r3
  int v223; // r2
  int v224; // r0
  int v225; // r4
  const char *v226; // r0
  _DWORD *v227; // r2
  _DWORD *v228; // r4
  int v229; // r6
  int v230; // r0
  bool v231; // cc
  char *v232; // r1
  int v233; // r2
  __int16 v234; // r2
  int v235; // r0
  const char *v236; // r0
  int v237; // r0
  char *v238; // r0
  void *j; // [sp+20h] [bp-BCh]
  int v240; // [sp+24h] [bp-B8h]
  _DWORD *v241; // [sp+28h] [bp-B4h]
  struct addrinfo *pai; // [sp+44h] [bp-98h] BYREF
  _QWORD s[9]; // [sp+48h] [bp-94h] BYREF
  struct sockaddr v244; // [sp+94h] [bp-48h] BYREF
  int v245; // [sp+A4h] [bp-38h]
  int v246; // [sp+A8h] [bp-34h]
  int v247; // [sp+ACh] [bp-30h]
  _DWORD v248[7]; // [sp+B0h] [bp-2Ch] BYREF
  char v249[8]; // [sp+CCh] [bp-10h] BYREF

  v241 = sub_63BA4(0, 0xB8u, 0, 0);
  memcpy(v241, &cfgt, 0xB8u);
  memset(&cfgt, 0, 0xB8u);
  v2 = (int *)cfg_tree_history;
  if ( cfg_tree_history )
  {
    while ( *v2 )
      v2 = (int *)*v2;
  }
  else
  {
    v2 = &cfg_tree_history;
  }
  *v241 = 0;
  *v2 = (int)v241;
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[261] + (_DWORD)off_B611C) & 0xF) != 0 )
  {
    v3 = (FILE *)fopen64(*(int *)((char *)&elf_hash_bucket[263] + (_DWORD)off_B611C), "w");
    if ( v3 )
    {
      v4 = sub_ED20(v3, 0);
      v5 = v4;
      if ( v4 )
        _fprintf_chk(
          stderr,
          1,
          "--saveconfigquit %s error %d\n",
          *(const char **)((char *)&elf_hash_bucket[263] + (_DWORD)off_B611C),
          v4);
      else
        _fprintf_chk(
          stderr,
          1,
          "configuration saved to %s\n",
          *(const char **)((char *)&elf_hash_bucket[263] + (_DWORD)off_B611C));
      exit(v5);
    }
    v213 = _errno_location();
    v214 = *v213;
    sub_64CC4(
      (int)stderr,
      "can not create save file %s, error %d %m\n",
      *(const char **)((char *)&elf_hash_bucket[263] + (_DWORD)off_B611C),
      *v213);
    exit(v214);
  }
  if ( a1 )
  {
    v227 = (_DWORD *)v241[14];
    if ( v227 && (v228 = (_DWORD *)*v227) != 0 )
    {
      v229 = 0;
      do
      {
        while ( v228[1] != 267 )
        {
          v228 = (_DWORD *)*v228;
          if ( !v228 )
            goto LABEL_622;
        }
        v229 = a1;
        sub_6702C(v228[4]);
        v228 = (_DWORD *)*v228;
      }
      while ( v228 );
LABEL_622:
      if ( (unsigned int)sub_66FD8() <= 0x63DF )
      {
        v230 = sub_66E18();
        sub_6702C(v230 - 11);
      }
      if ( v229 )
        sub_602C8();
    }
    else if ( (unsigned int)sub_66FD8() <= 0x63DF )
    {
      v235 = sub_66E18();
      sub_6702C(v235 - 11);
    }
  }
  v6 = (_DWORD *)v241[41];
  if ( v6 )
  {
    v7 = (_DWORD *)*v6;
    if ( *v6 )
    {
      if ( (*(int *)((_BYTE *)&elf_hash_bucket[133] + (_DWORD)off_B611C) & 0xF) == 0
        && (*(int *)((_BYTE *)&elf_hash_bucket[85] + (_DWORD)off_B611C) & 0xF) == 0 )
      {
        while ( 1 )
        {
          v10 = (char *)v7[2];
          LODWORD(s[0]) = -1;
          if ( !v10 )
          {
            v9 = v7[1];
            if ( v9 == 324 )
            {
              v13 = 1;
              goto LABEL_34;
            }
            if ( v9 <= 324 )
            {
              if ( !v9 )
LABEL_666:
                sub_6ECC0("ntp_config.c", 3051, 2, "if_name != ((void *)0)");
              if ( v9 != 260 )
LABEL_676:
                sub_C954("config_nic_rules: match-class-token=%d", v9);
              v13 = 0;
LABEL_566:
              v14 = v7[3];
              if ( v14 != 313 )
              {
                if ( v14 != 338 )
                {
LABEL_556:
                  if ( v14 != 291 )
LABEL_37:
                    sub_C954("config_nic_rules: action-token=%d", v14);
                  v216 = s[0];
                  goto LABEL_558;
                }
                v216 = s[0];
                v217 = 0;
LABEL_559:
                sub_15E04(v13, v10, v216, v217);
                sub_40E80(current_time + 2);
                if ( !v10 )
                  goto LABEL_27;
                goto LABEL_26;
              }
LABEL_561:
              v216 = s[0];
            }
            else
            {
              if ( v9 == 326 )
              {
                v13 = 2;
              }
              else
              {
                if ( v9 != 443 )
                  goto LABEL_676;
                v13 = 3;
              }
LABEL_34:
              v14 = v7[3];
              if ( v14 != 313 )
              {
                if ( v14 == 338 )
                {
                  sub_15E04(v13, 0, -1, 0);
                  sub_40E80(current_time + 2);
                  goto LABEL_27;
                }
                if ( v14 != 291 )
                  goto LABEL_37;
                v216 = -1;
LABEL_558:
                v217 = 2;
                goto LABEL_559;
              }
              v216 = -1;
            }
            v217 = 1;
            goto LABEL_559;
          }
          v8 = (const char *)sub_63D08(v10);
          v9 = v7[1];
          v10 = (char *)v8;
          if ( v9 == 324 )
          {
            v13 = 1;
            goto LABEL_566;
          }
          if ( v9 > 324 )
          {
            if ( v9 == 326 )
            {
              v13 = 2;
            }
            else
            {
              if ( v9 != 443 )
                goto LABEL_676;
              v13 = 3;
            }
            goto LABEL_566;
          }
          if ( v9 )
          {
            if ( v9 != 260 )
              goto LABEL_676;
            v13 = 0;
            goto LABEL_566;
          }
          if ( !v8 )
            goto LABEL_666;
          v11 = strchr(v8, 47);
          v12 = v11;
          if ( !v11 )
            break;
          *v11 = 0;
          if ( !sub_64054((int)v10, 0, v248) )
          {
            v13 = 4;
            *v12 = 47;
            goto LABEL_23;
          }
          if ( sscanf(v12 + 1, "%d", s) != 1 )
            goto LABEL_592;
          v13 = 5;
          v222 = s[0];
          if ( LOWORD(v248[0]) == 2 )
            v223 = 32;
          else
            v223 = 128;
          if ( SLODWORD(s[0]) < -1 )
            v222 = -1;
          if ( v222 >= v223 )
            v222 = v223;
          LODWORD(s[0]) = v222;
LABEL_23:
          v14 = v7[3];
          if ( v14 == 313 )
            goto LABEL_561;
          if ( v14 != 338 )
            goto LABEL_556;
          sub_15E04(v13, v10, s[0], 0);
          sub_40E80(current_time + 2);
LABEL_26:
          free(v10);
LABEL_27:
          v7 = (_DWORD *)*v7;
          if ( !v7 )
            goto LABEL_39;
        }
        if ( !sub_64054((int)v10, 0, v248) )
        {
          v13 = 4;
          goto LABEL_566;
        }
LABEL_592:
        v13 = 5;
        goto LABEL_23;
      }
      if ( a1 )
      {
        sub_64E00(3, "interface/nic rules are not allowed with --interface (-I) or --novirtualips (-L)%s", ", exiting");
        exit(1);
      }
      sub_64E00(3, "interface/nic rules are not allowed with --interface (-I) or --novirtualips (-L)%s", byte_97F7C);
    }
  }
LABEL_39:
  v15 = (char *)v241[16];
  if ( v15 )
    sub_4294C(2, v15);
  v16 = (_DWORD *)v241[15];
  if ( v16 )
  {
    v17 = (_DWORD *)*v16;
    if ( *v16 )
    {
      do
      {
        while ( 1 )
        {
          v18 = sub_1C0BC(v17[1]);
          v19 = sub_2C718(v18);
          if ( !v19 )
            break;
          sub_2C570(v19, statsdir, v18, *(unsigned __int8 *)(v19 + 20), *(unsigned __int8 *)(v19 + 21) | 0x80);
          v17 = (_DWORD *)*v17;
          if ( !v17 )
            goto LABEL_47;
        }
        sub_64E00(3, "stats %s unrecognized", v18);
        v17 = (_DWORD *)*v17;
      }
      while ( v17 );
    }
  }
LABEL_47:
  v20 = (_DWORD *)v241[17];
  if ( v20 )
  {
    v21 = (_DWORD *)*v20;
    if ( *v20 )
    {
      do
      {
        v22 = sub_1C0BC(v21[1]);
        v23 = sub_2C718(v22);
        if ( v23 )
        {
          v24 = (_DWORD *)v21[2];
          v25 = *(unsigned __int8 *)(v23 + 20);
          v26 = *(unsigned __int8 *)(v23 + 21) | 0x80;
          if ( v24 )
          {
            v27 = (_DWORD *)*v24;
            if ( *v24 )
            {
              do
              {
                v28 = v27[1];
                if ( v28 == 433 )
                {
                  v29 = v27[4];
                  if ( v29 == 371 )
                  {
                    v25 = 255;
                  }
                  else if ( v29 >= 372 )
                  {
                    switch ( v29 )
                    {
                      case 442:
                        v25 = 3;
                        break;
                      case 445:
                        v25 = 5;
                        break;
                      case 390:
                        v25 = 1;
                        break;
                      default:
LABEL_61:
                        sub_C954("config-monitor: type-token=%d", v29);
                    }
                  }
                  else
                  {
                    switch ( v29 )
                    {
                      case 283:
                        v25 = 2;
                        break;
                      case 364:
                        v25 = 4;
                        break;
                      case 259:
                        v25 = 6;
                        break;
                      default:
                        goto LABEL_61;
                    }
                  }
                }
                else if ( v28 == 446 )
                {
                  v34 = v27[4];
                  if ( v34 == 294 )
                  {
                    v26 |= 0x80u;
                  }
                  else if ( v34 <= 294 )
                  {
                    if ( v34 != 286 )
                    {
LABEL_658:
                      sub_64E00(3, "Unknown filegen flag token %d", v27[4]);
                      exit(1);
                    }
                    v26 &= ~0x80u;
                  }
                  else if ( v34 == 337 )
                  {
                    v26 |= 1u;
                  }
                  else
                  {
                    if ( v34 != 368 )
                      goto LABEL_658;
                    v26 &= ~1u;
                  }
                }
                else
                {
                  if ( v28 != 298 )
                  {
                    sub_64E00(3, "Unknown filegen option token %d", v27[1]);
                    exit(1);
                  }
                  v22 = (char *)v27[4];
                }
                v27 = (_DWORD *)*v27;
              }
              while ( v27 );
            }
          }
          sub_2C570(v23, statsdir, v22, v25, v26);
        }
        else
        {
          sub_64E00(3, "filegen category '%s' unrecognized", v22);
        }
        v21 = (_DWORD *)*v21;
      }
      while ( v21 );
    }
  }
  v30 = (int ***)v241[28];
  if ( v30 )
  {
    for ( i = *v30; i; i = (int **)*i )
    {
      v33 = (int)i[1];
      if ( v33 == 312 )
      {
        v32 = 2;
      }
      else if ( v33 <= 312 )
      {
        if ( v33 == 285 )
        {
          v32 = 9;
        }
        else
        {
          if ( v33 != 309 )
            goto LABEL_672;
          v32 = 1;
        }
      }
      else if ( v33 == 397 )
      {
        v32 = 8;
      }
      else
      {
        if ( v33 != 398 )
LABEL_672:
          sub_C954("config_auth: attr-token=%d", v33);
        v32 = 4;
      }
      sub_2BCA8(v32, (const char *)i[4]);
    }
  }
  v35 = (const char *)v241[30];
  if ( v35 )
  {
    if ( keysdir[0] != default_keysdir )
    {
      free(keysdir[0]);
      v35 = (const char *)v241[30];
    }
    keysdir[0] = (char *)sub_63D08(v35);
  }
  v36 = (const char *)v241[34];
  if ( v36 )
  {
    if ( ntp_signd_socket != &unk_B860C )
    {
      free(ntp_signd_socket);
      v36 = (const char *)v241[34];
    }
    ntp_signd_socket = sub_63D08(v36);
  }
  if ( v241[27] && !cryptosw )
  {
    sub_2B408();
    cryptosw = 1;
  }
  v37 = (_DWORD *)v241[33];
  if ( v37 )
  {
    v38 = (_DWORD *)*v37;
    if ( *v37 )
    {
      v37 = 0;
      do
      {
        while ( 1 )
        {
          v43 = v38[2];
          if ( v43 != 319 )
            break;
          v44 = v38[4];
          v38 = (_DWORD *)*v38;
          if ( (unsigned int)(v44 - 2) <= 0xFFFD )
            v37 = (_DWORD *)((char *)v37 + 1);
          if ( !v38 )
            goto LABEL_128;
        }
        if ( v43 != 321 )
          sub_6ECC0("ntp_config.c", 2012, 0, "321 == my_val->type");
        v39 = v38[5];
        v40 = v38[4];
        v38 = (_DWORD *)*v38;
        v41 = v40 <= v39;
        if ( v40 <= 0 )
          v41 = 0;
        if ( v39 <= 0xFFFF && v41 )
          v37 = (_DWORD *)((char *)v37 + v39 + 1 - v40);
      }
      while ( v38 );
    }
    else
    {
      v37 = 0;
    }
  }
LABEL_128:
  sub_61DBC((int)v37);
  v45 = (const char *)v241[29];
  if ( v45 )
    sub_42744(v45);
  if ( v241[26] )
    ctl_auth_keyid = v241[26];
  if ( v241[31] )
    info_auth_keyid = v241[31];
  v46 = (_DWORD *)v241[33];
  if ( v46 )
  {
    v47 = (_DWORD *)*v46;
    if ( *v46 )
    {
      while ( 1 )
      {
        v51 = v47[4];
        if ( v47[2] != 319 )
          break;
        if ( (unsigned int)(v51 - 1) > 0xFFFE )
        {
          sub_64E00(5, "Ignoring invalid trustedkey %d, min 1 max %d.", v47[4], 0xFFFF);
LABEL_146:
          v47 = (_DWORD *)*v47;
          if ( !v47 )
            goto LABEL_150;
        }
        else
        {
          sub_621BC(v47[4], 1u);
          v47 = (_DWORD *)*v47;
          if ( !v47 )
            goto LABEL_150;
        }
      }
      v48 = v47[5];
      v49 = v48 <= v51;
      if ( v48 >= v51 )
        v49 = v51 <= 0;
      v50 = v49;
      if ( v48 > 0xFFFF )
        v50 |= 1u;
      if ( v50 )
      {
        sub_64E00(5, "Ignoring invalid trustedkey range %d ... %d, min 1 max %d.", v51, v48, 0xFFFF);
      }
      else
      {
        do
        {
          v64 = v51++;
          sub_621BC(v64, 1u);
        }
        while ( v48 >= v51 );
      }
      goto LABEL_146;
    }
  }
LABEL_150:
  v52 = v241[32];
  if ( (unsigned int)(v52 - 3) <= 0x1C )
  {
    sys_revoke = v241[32];
  }
  else if ( v52 )
  {
    sub_64E00(3, "'revoke' value %d ignored", v52);
  }
  v53 = (double **)v241[14];
  v54 = sys_maxclock;
  v55 = sys_minclock;
  v56 = sys_minsane;
  if ( v53 )
  {
    v57 = *v53;
    if ( *v53 )
    {
      while ( 1 )
      {
        v59 = *((_DWORD *)v57 + 1);
        if ( v59 == 347 )
        {
          v54 = (int)v57[2];
          if ( v54 <= 0 )
          {
            v57[2] = 1.0;
            v54 = 1;
          }
          goto LABEL_161;
        }
        if ( v59 < 348 )
        {
          if ( v59 == 269 )
          {
            v65 = v57[2];
            if ( v65 > 4.0 )
            {
              sub_64E00(4, "Using maximum bcpollbstep ceiling %d, %d requested", 4, (int)v65);
              v57[2] = 4.0;
            }
            else if ( v65 < 0.0 )
            {
              sub_64E00(4, "Using minimum bcpollbstep floor %d, %d requested", 0, (int)v65);
              v57[2] = 0.0;
            }
          }
          else if ( v59 == 276 )
          {
            v58 = v57[2];
            if ( v58 > 15.0 )
            {
              sub_64E00(4, "Using maximum tos ceiling %d, %d requested", 15, (int)v58);
              v57[2] = 15.0;
            }
            else if ( v58 < 1.0 )
            {
              sub_64E00(4, "Using minimum tos floor %d, %d requested", 1, (int)v58);
              v57[2] = 1.0;
            }
          }
          goto LABEL_161;
        }
        if ( v59 == 355 )
          break;
        if ( v59 == 360 )
        {
          v56 = (int)v57[2];
          if ( v56 < 0 )
          {
            v57[2] = 0.0;
            v56 = 0;
          }
          v57 = *(double **)v57;
          if ( !v57 )
          {
LABEL_169:
            v60 = v54 <= v55;
            if ( v54 >= v55 )
              v60 = v55 <= v56;
            if ( !v60 )
            {
LABEL_172:
              v61 = (_DWORD *)v241[14];
              if ( v61 )
              {
                v62 = (_DWORD *)*v61;
                if ( *v61 )
                {
                  while ( 2 )
                  {
                    v63 = v62[1];
                    switch ( v63 )
                    {
                      case 267:
                        goto LABEL_189;
                      case 269:
                        v66 = 33;
                        goto LABEL_188;
                      case 270:
                        v66 = 25;
                        goto LABEL_188;
                      case 276:
                        v66 = 18;
                        goto LABEL_188;
                      case 278:
                        v66 = 19;
                        goto LABEL_188;
                      case 306:
                        v66 = 17;
                        goto LABEL_188;
                      case 347:
                        v66 = 15;
                        goto LABEL_188;
                      case 349:
                        v66 = 22;
                        goto LABEL_188;
                      case 355:
                        v66 = 14;
                        goto LABEL_188;
                      case 357:
                        v66 = 21;
                        goto LABEL_188;
                      case 360:
                        v66 = 16;
                        goto LABEL_188;
                      case 383:
                        v66 = 26;
                        goto LABEL_188;
                      case 384:
                        v66 = 27;
LABEL_188:
                        sub_38810(v66, 0, 0);
LABEL_189:
                        v62 = (_DWORD *)*v62;
                        if ( !v62 )
                          goto LABEL_190;
                        continue;
                      default:
                        sub_C954("config-tos: attr-token=%d", v63);
                    }
                  }
                }
              }
              goto LABEL_190;
            }
LABEL_630:
            sub_64E00(
              3,
              "tos error: must have minsane (%d) < minclock (%d) <= maxclock (%d) - daemon will not operate properly!",
              v56,
              v55,
              v54);
            goto LABEL_172;
          }
        }
        else
        {
LABEL_161:
          v57 = *(double **)v57;
          if ( !v57 )
            goto LABEL_169;
        }
      }
      v55 = (int)v57[2];
      if ( v55 <= 0 )
      {
        v57[2] = 1.0;
        v55 = 1;
      }
      goto LABEL_161;
    }
  }
  v231 = sys_maxclock <= sys_minclock;
  if ( sys_maxclock >= sys_minclock )
    v231 = sys_minclock <= sys_minsane;
  if ( v231 )
    goto LABEL_630;
LABEL_190:
  v67 = (int **)v241[19];
  if ( v67 )
  {
    v68 = *v67;
    if ( *v67 )
    {
      while ( 2 )
      {
        v69 = v68[1];
        switch ( v69 )
        {
          case 314:
            if ( v68[4] < 0 )
              goto LABEL_319;
            mru_incalloc[0] = (int *)v68[4];
            goto LABEL_206;
          case 315:
            v78 = v68[4];
            if ( v78 < 0 )
              goto LABEL_319;
            v76 = v78 << 10;
            v75 = &mru_incalloc_ptr;
            goto LABEL_215;
          case 316:
            if ( v68[4] < 0 )
              goto LABEL_319;
            mru_initalloc = (int *)v68[4];
            goto LABEL_206;
          case 317:
            v77 = v68[4];
            if ( v77 < 0 )
              goto LABEL_319;
            v76 = v77 << 10;
            v75 = &mru_initalloc_ptr;
            goto LABEL_215;
          case 346:
            mru_maxage = (int *)v68[4];
            goto LABEL_206;
          case 348:
            if ( v68[4] < 0 )
              goto LABEL_326;
            mru_maxdepth = v68[4];
            goto LABEL_206;
          case 350:
            v74 = v68[4];
            if ( v74 < 0 )
            {
LABEL_326:
              mru_maxdepth = -1;
            }
            else
            {
              v75 = (int ***)&mru_maxdepth_ptr;
              v76 = v74 << 10;
LABEL_215:
              **v75 = (int *)(v76 / 0x48);
            }
LABEL_206:
            v68 = (int *)*v68;
            if ( !v68 )
              break;
            continue;
          case 356:
            if ( v68[4] < 0 )
            {
LABEL_319:
              v109 = sub_1C0BC(v69);
              sub_64E00(3, "mru %s %d out of range, ignored.", v109, v68[4]);
            }
            else
            {
              mru_mindepth = (_UNKNOWN *)v68[4];
            }
            goto LABEL_206;
          default:
            v238 = sub_1C0BC(v69);
            sub_64E00(3, "Unknown mru option %s (%d)", v238, v68[1]);
            exit(1);
            return;
        }
        break;
      }
    }
  }
  v70 = (_DWORD *)v241[18];
  if ( v70 )
  {
    v71 = (_DWORD *)*v70;
    if ( *v70 )
    {
      do
      {
        v72 = v71[1];
        if ( v72 == 358 )
        {
          ntp_minpkt = v71[4];
        }
        else if ( v72 == 363 )
        {
          mon_age = (_UNKNOWN *)v71[4];
        }
        else
        {
          if ( v72 != 266 )
          {
            v73 = sub_1C0BC(v72);
            sub_64E00(3, "Unknown discard option %s (%d)", v73, v71[1]);
            exit(1);
          }
          v108 = v71[4];
          if ( v108 > 0xFF )
            sub_64E00(3, "discard average %d out of range, ignored.", v108);
          else
            ntp_minpoll = v71[4];
        }
        v71 = (_DWORD *)*v71;
      }
      while ( v71 );
    }
  }
  v79 = (void **)v241[20];
  if ( v79 )
  {
    for ( j = *v79; j; j = *(void **)j )
    {
      v80 = (_DWORD *)*((_DWORD *)j + 3);
      v81 = *((_WORD *)j + 10);
      if ( v80 && (v82 = (_DWORD *)*v80) != 0 )
      {
        v83 = 0;
        v84 = 0;
        do
        {
          v85 = v82[1];
          switch ( v85 )
          {
            case 305:
              v83 |= 0x2000u;
              break;
            case 313:
              v83 |= 1u;
              break;
            case 332:
              v83 |= 0x800u;
              break;
            case 333:
              v83 |= 0x1000u;
              break;
            case 336:
              v83 |= 0x40u;
              break;
            case 342:
              v83 |= 0x400u;
              break;
            case 369:
              v83 |= 0x100u;
              break;
            case 370:
              v83 |= 0x4000u;
              break;
            case 373:
              v83 |= 0x20u;
              break;
            case 374:
              v83 |= 0x10u;
              break;
            case 375:
              v83 |= 0x80u;
              break;
            case 377:
              v83 |= 2u;
              break;
            case 378:
              v83 |= 0x200u;
              break;
            case 379:
              v83 |= 4u;
              break;
            case 381:
              v84 |= 0x2000u;
              break;
            case 409:
              v84 |= 0x4000u;
              break;
            case 440:
              v83 |= 8u;
              break;
            default:
              sub_C954("config_access: flag-type-token=%d", v85);
          }
          v82 = (_DWORD *)*v82;
        }
        while ( v82 );
        if ( (v83 & 0x1000) != 0 && !dword_B8610 )
        {
          dword_B8610 = 1;
          _fprintf_chk(
            stderr,
            1,
            "%s\n",
            "mssntp restrict bit ignored, this ntpd was configured without --enable-ntp-signd.");
          sub_64E00(
            4,
            (unsigned __int8 *)"%s",
            "mssntp restrict bit ignored, this ntpd was configured without --enable-ntp-signd.");
        }
        if ( (v83 & 0x840) == 0x800 )
        {
          v86 = *((_DWORD *)j + 1);
          if ( v86 )
          {
            v87 = *(const char **)(v86 + 4);
          }
          else if ( (v84 & 0x4000) != 0 )
          {
            v87 = "source";
          }
          else
          {
            v87 = "default";
          }
          _fprintf_chk(stderr, 1, "restrict %s: %s\n", v87, "KOD does nothing without LIMITED.");
          sub_64E00(4, "restrict %s: %s", v87, "KOD does nothing without LIMITED.");
        }
        memset(&v244, 0, sizeof(v244));
        v245 = 0;
        v246 = 0;
        v247 = 0;
        v88 = *((_DWORD *)j + 1);
        pai = 0;
        if ( !v88 )
        {
          memset(v248, 0, sizeof(v248));
          if ( (v84 & 0x4000) == 0 )
            goto LABEL_308;
          sub_40238(1, 0, 0, v81, v84, v83, 0);
          continue;
        }
      }
      else
      {
        LOWORD(v84) = 0;
        memset(&v244, 0, sizeof(v244));
        v245 = 0;
        v246 = 0;
        v247 = 0;
        v88 = *((_DWORD *)j + 1);
        pai = 0;
        if ( !v88 )
        {
          LOWORD(v84) = 0;
          LOWORD(v83) = 0;
          memset((char *)v248 + 2, 0, 26);
LABEL_308:
          v244.sa_family = 2;
          LOWORD(v248[0]) = 2;
          sub_40238(1, &v244.sa_family, v248, v81, v84, v83, 0);
          v244.sa_family = 10;
          strcpy((char *)v248, "\n");
          sub_40238(1, &v244.sa_family, v248, v81, v84, v83, 0);
LABEL_309:
          if ( pai )
            freeaddrinfo(pai);
          continue;
        }
        LOWORD(v83) = 0;
      }
      v89 = *(_DWORD *)(v88 + 4);
      v244.sa_family = *(_WORD *)(v88 + 8);
      if ( sub_CE10(v89, &v244.sa_family) == 1 )
      {
        sa_family = v244.sa_family;
        v95 = 0;
      }
      else
      {
        pai = 0;
        v90 = (const struct addrinfo *)memset(s, 0, 0x20u);
        v91 = v90;
        v92 = *((_DWORD *)j + 1);
        v93 = *(unsigned __int16 *)(v92 + 8);
        v94 = *(const char **)(v92 + 4);
        s[1] = 0x1100000002LL;
        HIDWORD(s[0]) = v93;
        if ( getaddrinfo(v94, "ntp", v91, &pai) )
        {
          sub_64E00(
            3,
            "restrict: ignoring line %d, address/host '%s' unusable.",
            *((_DWORD *)j + 4),
            *(_DWORD *)(*((_DWORD *)j + 1) + 4));
          continue;
        }
        v95 = pai;
        if ( !pai )
          sub_6ECC0("ntp_config.c", 2767, 2, "ai_list != ((void *)0)");
        ai_addr = pai->ai_addr;
        if ( !ai_addr )
          sub_6ECC0("ntp_config.c", 2769, 2, "pai->ai_addr != ((void *)0)");
        ai_addrlen = pai->ai_addrlen;
        if ( ai_addrlen > 0x1C )
          sub_6ECC0("ntp_config.c", 2771, 2, "sizeof(addr) >= pai->ai_addrlen");
        _memcpy_chk(&v244, ai_addr, ai_addrlen, 28);
        sa_family = v244.sa_family;
        if ( (v244.sa_family & 0xFFF7) != 2 )
          sub_6ECC0("ntp_config.c", 2775, 2, "2 == ((&addr)->sa.sa_family) || 10 == ((&addr)->sa.sa_family)");
      }
      v99 = sa_family == 10;
      LOWORD(v248[0]) = sa_family;
      *(_DWORD *)((char *)&v248[1] + 2) = 0;
      if ( sa_family == 10 )
        sa_family = -1;
      *(_DWORD *)((char *)v248 + 2) = 0;
      memset((char *)&v248[2] + 2, 0, 18);
      if ( v99 )
      {
        v248[3] = sa_family;
        v248[2] = sa_family;
        v248[4] = sa_family;
        v248[5] = sa_family;
      }
      else
      {
        v248[1] = -1;
      }
      if ( !*((_DWORD *)j + 2)
        || (memset(v248, 0, sizeof(v248)),
            v100 = *((_DWORD *)j + 2),
            v101 = *(_DWORD *)(v100 + 4),
            LOWORD(v248[0]) = *(_WORD *)(v100 + 8),
            sub_CE10(v101, (unsigned __int16 *)v248) == 1) )
      {
        while ( 1 )
        {
          sub_40238(1, &v244.sa_family, v248, v81, v84, v83, 0);
          if ( !v95 )
            break;
          v95 = v95->ai_next;
          if ( !v95 )
            break;
          if ( !v95->ai_addr )
            sub_6ECC0("ntp_config.c", 2810, 2, "pai->ai_addr != ((void *)0)");
          if ( v95->ai_addrlen > 0x1C )
            sub_6ECC0("ntp_config.c", 2812, 2, "sizeof(addr) >= pai->ai_addrlen");
          memset(&v244, 0, sizeof(v244));
          v245 = 0;
          v246 = 0;
          v247 = 0;
          _memcpy_chk(&v244, v95->ai_addr, v95->ai_addrlen, 28);
          v106 = v244.sa_family;
          v107 = v244.sa_family & 0xFFF7;
          if ( v107 != 2 )
            sub_6ECC0("ntp_config.c", 2817, 2, "2 == ((&addr)->sa.sa_family) || 10 == ((&addr)->sa.sa_family)");
          *(_DWORD *)((char *)v248 + 2) = 0;
          *(_DWORD *)((char *)&v248[1] + 2) = 0;
          if ( v244.sa_family == 10 )
            v107 = -1;
          memset((char *)&v248[2] + 2, 0, 18);
          LOWORD(v248[0]) = v244.sa_family;
          if ( v244.sa_family == 10 )
          {
            v248[3] = v107;
            v248[2] = v107;
            v248[4] = v107;
            v248[5] = v107;
          }
          else
          {
            v106 = -1;
          }
          if ( v244.sa_family != 10 )
            v248[1] = v106;
        }
        goto LABEL_309;
      }
      sub_64E00(
        3,
        "restrict: ignoring line %d, mask '%s' unusable.",
        *((_DWORD *)j + 4),
        *(_DWORD *)(*((_DWORD *)j + 2) + 4));
    }
  }
  v102 = (_DWORD *)v241[23];
  if ( v102 )
  {
    v103 = (_DWORD *)*v102;
    if ( *v102 )
    {
      do
      {
        v105 = v103[1];
        if ( v105 == 386 )
        {
          v104 = &byte_6;
        }
        else if ( v105 > 386 )
        {
          if ( v105 == 416 )
          {
            v104 = &byte_5;
          }
          else if ( v105 > 416 )
          {
            if ( v105 == 417 )
            {
              v104 = &byte_8;
            }
            else
            {
              if ( v105 != 422 )
                goto LABEL_671;
              v104 = byte_9 + 6;
            }
          }
          else if ( v105 == 414 )
          {
            v104 = &dword_0 + 3;
          }
          else
          {
            if ( v105 != 415 )
              goto LABEL_671;
            v104 = &byte_4;
          }
        }
        else if ( v105 == 288 )
        {
          v104 = &byte_7;
        }
        else if ( v105 <= 288 )
        {
          if ( v105 != 261 )
LABEL_671:
            sub_C954("config_tinker: attr-token=%d", v105);
          v104 = byte_9 + 1;
        }
        else if ( v105 == 307 )
        {
          v104 = byte_9 + 3;
        }
        else
        {
          if ( v105 != 310 )
            goto LABEL_671;
          v104 = byte_9 + 2;
        }
        sub_305F8(v104);
        v103 = (_DWORD *)*v103;
      }
      while ( v103 );
    }
  }
  v110 = (_DWORD *)v241[22];
  if ( v110 )
  {
    v111 = (_DWORD *)*v110;
    if ( *v110 )
    {
      do
      {
        v112 = v111[1];
        switch ( v112 )
        {
          case 354:
            if ( (*(int *)((_BYTE *)&elf_hash_bucket[261] + (_DWORD)off_B611C) & 0xF) == 0 )
            {
              v113 = v111[4];
              if ( v113 == -1 )
              {
                if ( cur_memlock && munlockall() == -1 )
                  sub_64E00(3, "munlockall() failed: %m");
                cur_memlock = 0;
              }
              else if ( v113 < 0 )
              {
                sub_64E00(4, "'rlimit memlock' value of %d is unexpected!", v113);
              }
              else
              {
                if ( cur_memlock != 1 )
                {
                  if ( mlockall(3) == -1 )
                    sub_64E00(3, "mlockall() failed: %m");
                  v113 = v111[4];
                }
                sub_FB7C(&byte_8, v113 << 20);
                cur_memlock = 1;
              }
            }
            break;
          case 410:
            sub_FB7C((_BYTE *)&dword_0 + 3, (int)(v111[4] << 12));
            break;
          case 300:
            sub_FB7C(&byte_7, (int)v111[4]);
            break;
          default:
            sub_C954("config-rlimit: value-token=%d", v112);
        }
        v111 = (_DWORD *)*v111;
      }
      while ( v111 );
    }
  }
  sub_C9A0((_DWORD *)v241[24], (__int16 *)((char *)&dword_0 + 1));
  sub_C9A0((_DWORD *)v241[25], 0);
  v114 = (int ***)v241[35];
  if ( v114 )
  {
    for ( k = *v114; k; k = (int **)*k )
    {
      v116 = (int)k[1];
      switch ( v116 )
      {
        case '-':
          ntp_syslogmask &= ~(unsigned int)sub_D580((char *)k[4]);
          break;
        case '=':
          ntp_syslogmask = (int)sub_D580((char *)k[4]);
          break;
        case '+':
          ntp_syslogmask |= (unsigned int)sub_D580((char *)k[4]);
          break;
        default:
          sub_C954("config-logconfig: modifier='%c'", v116);
      }
    }
  }
  v117 = (int ***)v241[36];
  if ( v117 )
  {
    v118 = *v117;
    if ( *v117 )
    {
      v119 = 0;
      do
      {
        while ( v119 <= 8 )
        {
          v120 = sub_63D08((const char *)v118[1]);
          v118 = (int **)*v118;
          sys_phone[v119++] = (int)v120;
          sys_phone[v119] = 0;
          if ( !v118 )
            goto LABEL_363;
        }
        sub_64E00(6, "phone: Number of phone entries exceeds %zu. Ignoring phone %s...", 9u, (const char *)v118[1]);
        v118 = (int **)*v118;
      }
      while ( v118 );
    }
  }
LABEL_363:
  v121 = (int ***)v241[37];
  if ( v121 )
  {
    v122 = *v121;
    if ( *v121 )
    {
      v123 = 0;
      do
      {
        v124 = strlen((const char *)v122[1]);
        v125 = v124 + strlen((const char *)v122[2]) + 2;
        v123 = sub_63BA4(v123, v125, 0, 0);
        sub_6C054((int)v123, v125, "%s=%s", (const char *)v122[1], (const char *)v122[2]);
        if ( v122[3] )
          v126 = 32;
        else
          v126 = 0;
        sub_245C4((unsigned __int8 *)v123, v125, v126);
        v122 = (int **)*v122;
      }
      while ( v122 );
      if ( v123 )
        free(v123);
    }
  }
  v127 = (_DWORD *)v241[38];
  if ( v127 )
  {
    v128 = (_DWORD *)*v127;
    if ( *v127 )
    {
      v129 = 0;
      do
      {
        while ( 1 )
        {
          v130 = v128[1];
          if ( v129 > 7 )
            break;
          sys_ttl[v129++] = v130;
          v128 = (_DWORD *)*v128;
          if ( !v128 )
            goto LABEL_378;
        }
        sub_64E00(6, "ttl: Number of TTL entries exceeds %zu. Ignoring TTL %d...", 8u, v130);
        v128 = (_DWORD *)*v128;
      }
      while ( v128 );
LABEL_378:
      sys_ttlmax = v129 - 1;
    }
  }
  v131 = (double **)v241[40];
  if ( v131 )
  {
    for ( m = *v131; m; m = *(double **)m )
    {
      v133 = *((_DWORD *)m + 1);
      if ( v133 == 334 )
      {
        sub_4294C(4, *((char **)m + 4));
        continue;
      }
      if ( v133 <= 334 )
      {
        if ( v133 == 290 )
        {
          v232 = (char *)*((_DWORD *)m + 4);
          if ( *v232 )
          {
            sub_4294C(1, v232);
          }
          else
          {
            stats_drift_file = (unsigned __int8)*v232;
            sub_64E00(6, "config: driftfile disabled");
          }
          continue;
        }
        if ( v133 > 290 )
        {
          if ( v133 == 292 )
          {
            qos = (int *)(4 * *((_DWORD *)m + 4));
            continue;
          }
          if ( v133 != 312 )
            goto LABEL_634;
          sys_ident = *((_DWORD *)m + 4);
        }
        else
        {
          if ( v133 == 265 )
          {
            v233 = *((_DWORD *)m + 4);
            if ( (unsigned int)(v233 - 3) > 0x1C )
              sub_64E00(3, "'automax' value %d ignored", v233);
            else
              sys_automax = *((_DWORD *)m + 4);
            continue;
          }
          if ( v133 != 273 )
            goto LABEL_634;
          sub_38810(4, 0, 0);
        }
      }
      else
      {
        if ( v133 == 391 )
        {
          sub_4294C(3, *((char **)m + 4));
          continue;
        }
        if ( v133 < 392 )
        {
          if ( v133 == 340 )
          {
            if ( sub_64FEC(*((const char **)m + 4), 1) == -1 )
              sub_64E00(3, "Cannot open logfile %s: %m", *((const char **)m + 4));
            continue;
          }
          if ( v133 == 372 )
            goto LABEL_642;
LABEL_634:
          sub_64E00(3, "config_vars(): unexpected token %d", v133);
          continue;
        }
        if ( v133 == 422 )
        {
          sub_305F8(&byte_9[6]);
          continue;
        }
        if ( v133 == 441 )
        {
LABEL_642:
          wander_threshold = m[2];
          continue;
        }
        if ( v133 != 406 )
          goto LABEL_634;
        if ( saveconfigdir )
          free((void *)saveconfigdir);
        v134 = (const char *)*((_DWORD *)m + 4);
        v135 = strlen(v134);
        if ( !v135 )
          goto LABEL_651;
        if ( v134[v135 - 1] == 47 )
        {
          v135 = (int)sub_63D08(v134);
LABEL_651:
          saveconfigdir = v135;
          continue;
        }
        v136 = v135 + 2;
        v137 = sub_63BA4(0, v135 + 2, 0, 0);
        v138 = (const char *)*((_DWORD *)m + 4);
        saveconfigdir = (int)v137;
        sub_6C054((int)v137, v136, "%s%c", v138, 47);
      }
    }
  }
  sub_18484();
  v139 = (_DWORD *)v241[39];
  v244.sa_family = 0;
  if ( v139 )
  {
    v140 = (_DWORD *)*v139;
    if ( *v139 )
    {
      while ( 1 )
      {
        v141 = (_DWORD *)v140[2];
        if ( !v141 )
          break;
        v142 = (_DWORD *)*v141;
        if ( !*v141 )
          break;
        v143 = 0;
        v144 = 0;
        v145 = 0;
        do
        {
          while ( 1 )
          {
            v146 = v142[1];
            if ( v146 != 393 )
              break;
            v147 = v142[4];
            if ( (unsigned int)(v147 - 1) > 0xFFFE )
            {
              sub_64E00(3, "invalid port number %d, trap ignored");
              v145 = 1;
              v147 = v142[4];
            }
            v142 = (_DWORD *)*v142;
            v143 = (unsigned __int16)v147;
            if ( !v142 )
              goto LABEL_413;
          }
          if ( v146 == 320 )
          {
            memset(&v244, 0, sizeof(v244));
            v245 = 0;
            v246 = 0;
            v247 = 0;
            if ( sub_CE10(v142[4], &v244.sa_family) != 1 )
              goto LABEL_421;
            v144 = sub_178F8(&v244);
            if ( !v144 )
            {
              v145 = 1;
              v215 = sub_6C2E8(&v244.sa_family);
              sub_64E00(3, "can't find interface with address %s", v215);
            }
          }
          v142 = (_DWORD *)*v142;
        }
        while ( v142 );
LABEL_413:
        if ( v145 )
          goto LABEL_421;
        v248[0] = 0;
        if ( !v143 )
          v143 = 18447;
        memset(&v248[1], 0, 24);
        if ( sub_CE10(*(_DWORD *)(v140[1] + 4), (unsigned __int16 *)v248) != 1 )
        {
          memset(s, 0, 0x20u);
          s[1] = 0x1100000002LL;
          sub_6C054((int)v249, 8u, (unsigned __int8 *)"%u", v143);
          LODWORD(s[0]) = 1024;
          v149 = sub_63BA4(0, 0x20u, 0, 1);
          if ( v144 )
          {
            HIDWORD(s[0]) = *((unsigned __int16 *)v144 + 70);
            v149[7] = 1;
            v151 = *((_DWORD *)v144 + 6);
            v150 = v144 + 24;
            v152 = v150[1];
            v153 = v150[2];
            v154 = v150[3];
            *v149 = v151;
            v149[1] = v152;
            v149[2] = v153;
            v149[3] = v154;
            v155 = v150[5];
            v156 = v150[6];
            v149[4] = v150[4];
            v149[5] = v155;
            v149[6] = v156;
          }
          goto LABEL_419;
        }
        v234 = __rev16(v143);
        if ( v144 )
          v148 = v244.sa_family;
        HIWORD(v248[0]) = v234;
        if ( !v144 )
          goto LABEL_585;
        LOWORD(v248[0]) = v148;
LABEL_587:
        if ( sub_23D98((unsigned __int16 *)v248, (int)v144, 0, 4) )
        {
LABEL_421:
          v140 = (_DWORD *)*v140;
          if ( !v140 )
            goto LABEL_422;
        }
        else
        {
          v220 = sub_18FB4((int)v144);
          v221 = sub_6C2E8((unsigned __int16 *)v248);
          sub_64E00(3, "set trap %s -> %s failed.", v220, v221);
          v140 = (_DWORD *)*v140;
          if ( !v140 )
            goto LABEL_422;
        }
      }
      memset(v248, 0, sizeof(v248));
      if ( sub_CE10(*(_DWORD *)(v140[1] + 4), (unsigned __int16 *)v248) != 1 )
      {
        memset(s, 0, 0x20u);
        s[1] = 0x1100000002LL;
        sub_6C054((int)v249, 8u, (unsigned __int8 *)"%u", 18447);
        LODWORD(s[0]) = 1024;
        v149 = sub_63BA4(0, 0x20u, 0, 1);
LABEL_419:
        if ( !sub_68520(*(const char **)(v140[1] + 4), v249, (int *)s, 2, (int)sub_D014, (int)v149) )
          sub_64E00(3, "config_trap: getaddrinfo_sometime(%s,%s): %m", *(const char **)(v140[1] + 4), v249);
        goto LABEL_421;
      }
      HIWORD(v248[0]) = 3912;
LABEL_585:
      if ( LOWORD(v248[0]) == 2 )
        v144 = (char *)any_interface;
      else
        v144 = (char *)any6_interface;
      goto LABEL_587;
    }
  }
LABEL_422:
  v157 = (__int16 *)v241[11];
  if ( v157 )
    sub_38810(1, v157, 0);
  v158 = (int **)v241[12];
  if ( v158 )
  {
    for ( n = *v158; n; sys_manycastserver = 1 )
    {
      while ( 1 )
      {
        memset(v248, 0, sizeof(v248));
        v160 = n[1];
        LOWORD(v248[0]) = *((_WORD *)n + 4);
        if ( sub_CE10(v160, (unsigned __int16 *)v248) == 1 )
          break;
        n = (int *)*n;
        if ( !n )
          goto LABEL_430;
      }
      sub_38810(6, 0, (char *)v248);
      n = (int *)*n;
    }
  }
LABEL_430:
  v161 = (int **)v241[13];
  if ( v161 )
  {
    v162 = *v161;
    if ( *v161 )
    {
      do
      {
        while ( 1 )
        {
          memset(v248, 0, sizeof(v248));
          v163 = v162[1];
          LOWORD(v248[0]) = *((_WORD *)v162 + 4);
          if ( sub_CE10(v163, (unsigned __int16 *)v248) == 1 )
            break;
          v162 = (int *)*v162;
          if ( !v162 )
            goto LABEL_436;
        }
        sub_38810(6, 0, (char *)v248);
        v162 = (int *)*v162;
      }
      while ( v162 );
LABEL_436:
      sub_38810(6, (__int16 *)((char *)&dword_0 + 1), (char *)v162);
    }
  }
  if ( cmdline_server_count > 0 )
  {
    v164 = (int *)cmdline_servers;
    do
    {
      memset(v248, 0, sizeof(v248));
      if ( sub_64054(*v164, 0, v248) )
      {
        HIWORD(v248[0]) = 31488;
        if ( sub_CC78((unsigned __int16 *)v248, 407) )
          sub_32898(v248, 0, 0, -1, 3u, 4, 0, 0, 256, 0, 0, 0);
      }
      else
      {
        v165 = sub_63BA4(0, 0x1Cu, 0, 1);
        v165[4] = 0;
        *((_DWORD *)v165 + 1) = 407;
        v165[8] = 1027;
        *(_DWORD *)v165 = 256;
        memset(s, 0, 0x20u);
        v166 = (unsigned __int16)v165[4];
        s[1] = 0x1100000002LL;
        v167 = *(const char **)cmdline_servers;
        HIDWORD(s[0]) = v166;
        sub_67F40(v167, "ntp", (int *)s, 2, (int)sub_D1A8, (int)v165, 0);
      }
      v99 = cmdline_server_count == 1;
      v164 = (int *)(cmdline_servers + 4);
      --cmdline_server_count;
      cmdline_servers += 4;
    }
    while ( cmdline_server_count >= 0 && !v99 );
  }
  v168 = (int **)v241[9];
  if ( v168 )
  {
    v169 = *v168;
    if ( *v168 )
    {
      while ( 1 )
      {
        memset(v248, 0, sizeof(v248));
        v174 = v169[1];
        if ( v174 == 387 )
          break;
        if ( v174 >= 388 )
        {
          if ( v174 != 392 && v174 != 407 )
LABEL_513:
            sub_6ECC0("ntp_config.c", 4057, 2, "hmode != 0");
        }
        else
        {
          if ( v174 == 271 )
          {
            v170 = v169[2];
            v171 = 5;
            goto LABEL_450;
          }
          if ( v174 != 343 )
            goto LABEL_513;
        }
        v170 = v169[2];
        v99 = v174 == 392;
        v202 = *(const char **)(v170 + 4);
        v203 = *(_WORD *)(v170 + 8);
        if ( v99 )
        {
          v204 = v169[3];
          LOWORD(v248[0]) = v203;
          v205 = sub_CEE8(v204);
          sub_32898(
            v248,
            v202,
            0,
            -1,
            3u,
            *((_BYTE *)v169 + 24),
            *((_BYTE *)v169 + 16),
            *((_BYTE *)v169 + 17),
            v205,
            v169[5],
            v169[7],
            (const char *)v169[8]);
LABEL_453:
          v169 = (int *)*v169;
          if ( !v169 )
            goto LABEL_457;
        }
        else
        {
          v171 = 3;
LABEL_450:
          if ( sub_64054(*(_DWORD *)(v170 + 4), *(unsigned __int16 *)(v170 + 8), v248) )
          {
            v172 = v169[1];
            HIWORD(v248[0]) = 31488;
            if ( sub_CC78((unsigned __int16 *)v248, v172) )
            {
              v173 = sub_CEE8(v169[3]);
              sub_32898(
                v248,
                0,
                0,
                -1,
                v171,
                *((_BYTE *)v169 + 24),
                *((_BYTE *)v169 + 16),
                *((_BYTE *)v169 + 17),
                v173,
                v169[5],
                v169[7],
                (const char *)v169[8]);
            }
            goto LABEL_453;
          }
          v175 = sub_63BA4(0, 0x1Cu, 0, 1);
          v176 = *(_QWORD *)(v169 + 1);
          v177 = (int)v175;
          WORD2(v176) = *(_WORD *)(HIDWORD(v176) + 8);
          v175[1] = v176;
          *((_BYTE *)v175 + 16) = v171;
          *((_WORD *)v175 + 4) = WORD2(v176);
          *((_BYTE *)v175 + 17) = *((_BYTE *)v169 + 24);
          *((_BYTE *)v175 + 18) = *((_BYTE *)v169 + 16);
          *((_BYTE *)v175 + 19) = *((_BYTE *)v169 + 17);
          v178 = sub_CEE8(v169[3]);
          v179 = v169[5];
          v180 = v169[7];
          v181 = v169[8];
          *(_DWORD *)v177 = v178;
          *(_DWORD *)(v177 + 20) = v179;
          *(_DWORD *)(v177 + 12) = v180;
          *(_DWORD *)(v177 + 24) = v181;
          memset(s, 0, 0x20u);
          v182 = v169[2];
          v183 = *(unsigned __int16 *)(v177 + 8);
          s[1] = 0x1100000002LL;
          v184 = *(const char **)(v182 + 4);
          HIDWORD(s[0]) = v183;
          sub_67F40(v184, "ntp", (int *)s, 2, (int)sub_D1A8, v177, 0);
          v169 = (int *)*v169;
          if ( !v169 )
            goto LABEL_457;
        }
      }
      v171 = 1;
      v170 = v169[2];
      goto LABEL_450;
    }
  }
LABEL_457:
  v185 = (int ***)v241[10];
  if ( v185 )
  {
    for ( ii = *v185; ii; ii = (int **)*ii )
    {
      if ( ii[2] )
      {
        memset(v248, 0, sizeof(v248));
        v187 = ii[2];
        v188 = (const char *)v187[1];
        LOWORD(v248[0]) = *((_WORD *)v187 + 4);
        if ( sub_CE10((int)v188, (unsigned __int16 *)v248) > 0 )
        {
          v218 = sub_31A44((unsigned __int16 *)v248, 0, 0, -1, 0, 0);
          if ( v218 )
          {
            v219 = sub_6C2E8((unsigned __int16 *)v248);
            sub_64E00(5, "unpeered %s", v219);
            sub_36214(v218, (int *)"GONE");
            sub_31FC4(v218);
          }
        }
        else
        {
          v189 = (_DWORD *)peer_list;
          if ( peer_list )
          {
            while ( 1 )
            {
              v190 = (const char *)v189[11];
              if ( v190 )
              {
                if ( !strcasecmp(v190, v188) )
                  break;
              }
              v189 = (_DWORD *)*v189;
              if ( !v189 )
                goto LABEL_465;
            }
            sub_64E00(5, "unpeered %s", v188);
            sub_36214((int)v189, (int *)"GONE");
            sub_31FC4((int)v189);
          }
LABEL_465:
          memset(s, 0, 0x20u);
          HIDWORD(s[0]) = *((unsigned __int16 *)ii[2] + 4);
          s[1] = 0x1100000002LL;
          sub_68520(v188, "ntp", (int *)s, 2, (int)sub_D368, 0);
        }
      }
      else
      {
        v224 = sub_31C78(*((unsigned __int16 *)ii + 2));
        v225 = v224;
        if ( v224 )
        {
          v226 = sub_6C2E8((unsigned __int16 *)(v224 + 16));
          sub_64E00(5, "unpeered %s", v226);
          sub_36214(v225, (int *)"GONE");
          sub_31FC4(v225);
        }
      }
    }
  }
  v191 = (_DWORD *)v241[21];
  if ( !v191 )
    goto LABEL_492;
  v192 = (_DWORD *)*v191;
  if ( !*v191 )
    goto LABEL_492;
  do
  {
    v193 = v192[1];
    memset(v248, 0, sizeof(v248));
    if ( sub_CE10(*(_DWORD *)(v193 + 4), (unsigned __int16 *)v248) != 1 )
    {
      sub_64E00(3, "unrecognized fudge reference clock address %s, line ignored", *(const char **)(v193 + 4));
LABEL_471:
      memset(s, 0, sizeof(s));
      v194 = (int **)v192[2];
      if ( v194 )
      {
        v195 = *v194;
        if ( *v194 )
        {
          v240 = 1;
          goto LABEL_480;
        }
      }
      goto LABEL_491;
    }
    if ( LOWORD(v248[0]) != 2 || LOWORD(v248[1]) != 32639 )
    {
      v211 = sub_6C2E8((unsigned __int16 *)v248);
      sub_64E00(3, "inappropriate address %s for the fudge command, line ignored", v211);
      goto LABEL_471;
    }
    memset(s, 0, sizeof(s));
    v212 = (int **)v192[2];
    if ( !v212 || (v195 = *v212) == 0 )
    {
LABEL_490:
      HIDWORD(v198) = s;
      LODWORD(v198) = v248;
      sub_3A3B4(v198, 0);
      goto LABEL_491;
    }
    v240 = 0;
    do
    {
      while ( 1 )
      {
LABEL_480:
        v196 = v195[1];
        if ( v196 == 304 )
        {
          BYTE2(s[0]) = ~((unsigned int)~(BYTE2(s[0]) << 25) >> 25);
          if ( v195[4] )
            v206 = BYTE1(s[0]) | 8;
          else
            v206 = BYTE1(s[0]) & 0xF7;
          BYTE1(s[0]) = v206;
          goto LABEL_479;
        }
        if ( v196 <= 304 )
          break;
        if ( v196 == 418 )
        {
          BYTE2(s[0]) |= 4u;
          LODWORD(s[7]) = v195[4];
        }
        else if ( v196 <= 418 )
        {
          if ( v196 != 400 )
          {
LABEL_660:
            v236 = sub_1BBB4(v196);
            sub_64E00(3, "Unexpected fudge flag %s (%d) for %s", v236, v195[1], *(const char **)(v193 + 4));
            v237 = v195[1];
            if ( !v237 )
              v237 = 1;
            exit(v237);
          }
          HIDWORD(s[7]) = 0;
          BYTE2(s[0]) |= 8u;
          v209 = strlen((const char *)v195[4]);
          if ( v209 >= 4 )
            v210 = 4;
          else
            v210 = v209;
          _memcpy_chk((char *)&s[7] + 4, v195[4], v210, 12);
        }
        else if ( v196 == 423 )
        {
          BYTE2(s[0]) |= 1u;
          s[5] = *((_QWORD *)v195 + 2);
        }
        else
        {
          if ( v196 != 424 )
            goto LABEL_660;
          BYTE2(s[0]) |= 2u;
          s[6] = *((_QWORD *)v195 + 2);
        }
LABEL_479:
        v195 = (int *)*v195;
        if ( !v195 )
          goto LABEL_489;
      }
      if ( v196 == 302 )
      {
        BYTE2(s[0]) |= 0x20u;
        if ( v195[4] )
          v208 = BYTE1(s[0]) | 2;
        else
          v208 = BYTE1(s[0]) & 0xFD;
        BYTE1(s[0]) = v208;
        goto LABEL_479;
      }
      if ( v196 > 302 )
      {
        BYTE2(s[0]) |= 0x40u;
        if ( v195[4] )
          v207 = BYTE1(s[0]) | 4;
        else
          v207 = BYTE1(s[0]) & 0xFB;
        BYTE1(s[0]) = v207;
        goto LABEL_479;
      }
      if ( v196 != 301 )
        goto LABEL_660;
      BYTE2(s[0]) |= 0x10u;
      if ( v195[4] )
        v197 = BYTE1(s[0]) | 1;
      else
        v197 = BYTE1(s[0]) & 0xFE;
      BYTE1(s[0]) = v197;
      v195 = (int *)*v195;
    }
    while ( v195 );
LABEL_489:
    if ( !v240 )
      goto LABEL_490;
LABEL_491:
    v192 = (_DWORD *)*v192;
  }
  while ( v192 );
LABEL_492:
  v199 = (_DWORD *)v241[42];
  if ( v199 )
  {
    v200 = (_DWORD *)*v199;
    if ( *v199 )
    {
      while ( 1 )
      {
        v201 = v200[1];
        if ( v201 == 322 )
          break;
        if ( v201 <= 322 )
        {
          switch ( v201 )
          {
            case 263:
              sub_3A860();
              break;
            case 282:
              sub_241C4();
              break;
            case 262:
              sub_32B9C();
              break;
          }
          goto LABEL_499;
        }
        switch ( v201 )
        {
          case 420:
            sub_38C70();
            goto LABEL_499;
          case 425:
            sub_41648();
            goto LABEL_499;
          case 353:
            sub_32A70();
            v200 = (_DWORD *)*v200;
            if ( !v200 )
              return;
            break;
          default:
LABEL_499:
            v200 = (_DWORD *)*v200;
            if ( !v200 )
              return;
            break;
        }
      }
      sub_18D18();
      goto LABEL_499;
    }
  }
}
// 12F5C: variable 'v148' is possibly undefined
// 0: using guessed type int dword_0;
// 4: using guessed type char;
// 5: using guessed type char;
// 6: using guessed type char;
// 7: using guessed type char byte_7;
// 8: using guessed type char byte_8;
// 1BC: using guessed type int elf_hash_bucket[521];
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// B5BDC: using guessed type int **mru_initalloc_ptr;
// B5D2C: using guessed type int *mru_maxdepth_ptr;
// B5ED4: using guessed type int **mru_incalloc_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B6014: using guessed type int cur_memlock;
// B6018: using guessed type char *keysdir[2];
// B60C4: using guessed type _UNKNOWN *ntp_signd_socket;
// B60C8: using guessed type int *qos;
// B611C: using guessed type _UNKNOWN *off_B611C;
// B6B20: using guessed type _UNKNOWN *mon_age;
// B6B24: using guessed type int mru_maxdepth;
// B6B28: using guessed type int *mru_maxage;
// B6B2C: using guessed type _UNKNOWN *mru_mindepth;
// B6B30: using guessed type char ntp_minpoll;
// B6B34: using guessed type int ntp_minpkt;
// B6B38: using guessed type int *mru_incalloc[2];
// B6B3C: using guessed type int *mru_initalloc;
// B6C24: using guessed type int sys_maxclock;
// B6C28: using guessed type int sys_minclock;
// B6C2C: using guessed type int sys_minsane;
// B6C88: using guessed type char sys_automax;
// B6C89: using guessed type char sys_revoke;
// B6D90: using guessed type double wander_threshold;
// B7CD4: using guessed type int ntp_syslogmask;
// B8610: using guessed type int dword_B8610;
// B9218: using guessed type int sys_phone[];
// BC718: using guessed type int sys_ident;
// 107418: using guessed type int cmdline_server_count;
// 1074E0: using guessed type int cmdline_servers;
// 1074E4: using guessed type int saveconfigdir;
// 1074E8: using guessed type int cfg_tree_history;
// 1074EC: using guessed type int cryptosw;
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;
// 108250: using guessed type int ctl_auth_keyid;
// 108B8C: using guessed type int peer_list;
// 108BF8: using guessed type int sys_ttlmax;
// 108C24: using guessed type int sys_manycastserver;
// 108C84: using guessed type int info_auth_keyid;
// 108CA4: using guessed type int current_time;
// 108CCC: using guessed type int stats_drift_file;

//----- (000132B0) --------------------------------------------------------
void __fastcall sub_132B0(unsigned __int16 *a1)
{
  const char *v2; // r0
  const char *v3; // r0
  char v4[128]; // [sp+4h] [bp-88h] BYREF

  v2 = sub_6C2E8(a1);
  sub_6C054((int)v4, 0x80u, "remote config from %s", v2);
  sub_1C148(v4, 0);
  memset(&cfgt, 0, 0xB8u);
  dword_1074D8 = 5;
  sub_1973C();
  sub_1C1CC();
  dword_107434 = 1;
  dword_107448 = time(0);
  v3 = sub_6C2E8(a1);
  dword_107440 = (int)sub_63D08(v3);
  sub_FD04(0);
}
// 107434: using guessed type int dword_107434;
// 107440: using guessed type int dword_107440;
// 107448: using guessed type int dword_107448;
// 1074D8: using guessed type int dword_1074D8;

//----- (00013380) --------------------------------------------------------
void __fastcall sub_13380(int a1, int a2)
{
  size_t v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  unsigned __int8 v7[256]; // [sp+4h] [bp-108h] BYREF

  config_file = (int)"/etc/ntp.conf";
  sub_6C054((int)v7, 0x100u, "daemon_version=\"%s\"", Version);
  v4 = strlen((const char *)v7);
  sub_245C4(v7, v4 + 1, 1);
  set_tod_using = sub_CBFC;
  sub_1E008(a1, a2);
  memset(&cfgt, 0, 0xB8u);
  dword_1074D8 = 5;
  sub_63D78();
  if ( sub_1C148(v5, (int)"r") )
  {
    dword_107440 = (int)sub_63D08((const char *)config_file);
    sub_1973C();
    sub_1C1CC();
    dword_107434 = 0;
    dword_107448 = time(0);
    sub_FD04(1);
  }
  else
  {
    sub_63D78();
    sub_64E00(6, "getconfig: Couldn't open <%s>: %m", v6);
    sub_18484();
  }
}
// 13448: variable 'v5' is possibly undefined
// 134B0: variable 'v6' is possibly undefined
// B6ADC: using guessed type char *Version;
// 107104: using guessed type _UNKNOWN *set_tod_using;
// 107420: using guessed type int config_file;
// 107434: using guessed type int dword_107434;
// 107440: using guessed type int dword_107440;
// 107448: using guessed type int dword_107448;
// 1074D8: using guessed type int dword_1074D8;

//----- (000134EC) --------------------------------------------------------
char *__fastcall sub_134EC(unsigned int a1)
{
  unsigned int v1; // r4
  char v3[12]; // [sp+0h] [bp-14h] BYREF

  v1 = a1;
  byte_B8614[0] = 0;
  if ( (a1 & 1) != 0 )
  {
    v1 = a1 & 0xFFFFFFFE;
    sub_D504((unsigned __int8 *)byte_B8614, "up");
  }
  if ( (v1 & 2) != 0 )
  {
    v1 &= ~2u;
    sub_D504((unsigned __int8 *)byte_B8614, "ppp");
  }
  if ( (v1 & 4) != 0 )
  {
    v1 &= ~4u;
    sub_D504((unsigned __int8 *)byte_B8614, "loopback");
  }
  if ( (v1 & 8) != 0 )
  {
    v1 &= ~8u;
    sub_D504((unsigned __int8 *)byte_B8614, "broadcast");
  }
  if ( (v1 & 0x10) != 0 )
  {
    v1 &= ~0x10u;
    sub_D504((unsigned __int8 *)byte_B8614, "multicast");
  }
  if ( (v1 & 0x20) != 0 )
  {
    v1 &= ~0x20u;
    sub_D504((unsigned __int8 *)byte_B8614, "bcastopen");
  }
  if ( (v1 & 0x40) != 0 )
  {
    v1 &= ~0x40u;
    sub_D504((unsigned __int8 *)byte_B8614, "mcastopen");
  }
  if ( (v1 & 0x80) != 0 )
  {
    v1 &= ~0x80u;
    sub_D504((unsigned __int8 *)byte_B8614, "wildcard");
  }
  if ( (v1 & 0x100) != 0 )
  {
    v1 &= ~0x100u;
    sub_D504((unsigned __int8 *)byte_B8614, "MCASTif");
  }
  if ( (v1 & 0x200) != 0 )
  {
    v1 &= ~0x200u;
    sub_D504((unsigned __int8 *)byte_B8614, "IPv6privacy");
  }
  if ( (v1 & 0x400) != 0 )
  {
    v1 &= ~0x400u;
    sub_D504((unsigned __int8 *)byte_B8614, "bcastxmit");
  }
  if ( v1 )
  {
    sub_6C054((int)v3, 0xAu, (unsigned __int8 *)"%0x", v1);
    sub_D504((unsigned __int8 *)byte_B8614, v3);
  }
  return byte_B8614;
}

//----- (0001379C) --------------------------------------------------------
char *__fastcall sub_1379C(int a1)
{
  int v1; // r4
  char v3[12]; // [sp+0h] [bp-14h] BYREF

  v1 = a1;
  byte_B8A14[0] = 0;
  if ( (a1 & 0x2000) != 0 )
  {
    v1 = a1 & 0xDFFF;
    sub_D504((unsigned __int8 *)byte_B8A14, "ntponly");
  }
  if ( (v1 & 0x4000) != 0 )
  {
    v1 &= 0xBFFFu;
    sub_D504((unsigned __int8 *)byte_B8A14, "source");
  }
  if ( v1 )
  {
    sub_6C054((int)v3, 0xAu, (unsigned __int8 *)"%0x", v1);
    sub_D504((unsigned __int8 *)byte_B8A14, v3);
  }
  return byte_B8A14;
}
// 1BC: using guessed type int elf_hash_bucket[521];

//----- (000138BC) --------------------------------------------------------
char *__fastcall sub_138BC(int a1)
{
  int v1; // r4
  char v3[12]; // [sp+0h] [bp-14h] BYREF

  v1 = a1;
  byte_B8E14[0] = 0;
  if ( (a1 & 0x2000) != 0 )
  {
    v1 = a1 & 0xDFFF;
    sub_D504((unsigned __int8 *)byte_B8E14, "flake");
  }
  if ( (v1 & 1) != 0 )
  {
    v1 &= 0xFFFEu;
    sub_D504((unsigned __int8 *)byte_B8E14, "ignore");
  }
  if ( (v1 & 0x800) != 0 )
  {
    v1 &= 0xF7FFu;
    sub_D504((unsigned __int8 *)byte_B8E14, "kod");
  }
  if ( (v1 & 0x1000) != 0 )
  {
    v1 &= 0xEFFFu;
    sub_D504((unsigned __int8 *)byte_B8E14, "mssntp");
  }
  if ( (v1 & 0x40) != 0 )
  {
    v1 &= 0xFFBFu;
    sub_D504((unsigned __int8 *)byte_B8E14, "limited");
  }
  if ( (v1 & 0x400) != 0 )
  {
    v1 &= 0xFBFFu;
    sub_D504((unsigned __int8 *)byte_B8E14, "lptrap");
  }
  if ( (v1 & 0x100) != 0 )
  {
    v1 &= 0xFEFFu;
    sub_D504((unsigned __int8 *)byte_B8E14, "nomodify");
  }
  if ( (v1 & 0x4000) != 0 )
  {
    v1 &= 0xBFFFu;
    sub_D504((unsigned __int8 *)byte_B8E14, "nomrulist");
    if ( (v1 & 0x20) == 0 )
    {
LABEL_17:
      if ( (v1 & 0x10) == 0 )
        goto LABEL_18;
      goto LABEL_30;
    }
  }
  else if ( (v1 & 0x20) == 0 )
  {
    goto LABEL_17;
  }
  v1 &= 0xFFDFu;
  sub_D504((unsigned __int8 *)byte_B8E14, "noepeer");
  if ( (v1 & 0x10) == 0 )
  {
LABEL_18:
    if ( (v1 & 0x80) == 0 )
      goto LABEL_19;
    goto LABEL_31;
  }
LABEL_30:
  v1 &= 0xFFEFu;
  sub_D504((unsigned __int8 *)byte_B8E14, "nopeer");
  if ( (v1 & 0x80) == 0 )
  {
LABEL_19:
    if ( (v1 & 2) == 0 )
      goto LABEL_20;
    goto LABEL_32;
  }
LABEL_31:
  v1 &= 0xFF7Fu;
  sub_D504((unsigned __int8 *)byte_B8E14, "noquery");
  if ( (v1 & 2) == 0 )
  {
LABEL_20:
    if ( (v1 & 0x200) == 0 )
      goto LABEL_21;
    goto LABEL_33;
  }
LABEL_32:
  v1 &= 0xFFFDu;
  sub_D504((unsigned __int8 *)byte_B8E14, "dontserve");
  if ( (v1 & 0x200) == 0 )
  {
LABEL_21:
    if ( (v1 & 4) == 0 )
      goto LABEL_22;
LABEL_34:
    v1 &= 0xFFFBu;
    sub_D504((unsigned __int8 *)byte_B8E14, "notrust");
    if ( (v1 & 8) == 0 )
      goto LABEL_23;
    goto LABEL_35;
  }
LABEL_33:
  v1 &= 0xFDFFu;
  sub_D504((unsigned __int8 *)byte_B8E14, "notrap");
  if ( (v1 & 4) != 0 )
    goto LABEL_34;
LABEL_22:
  if ( (v1 & 8) == 0 )
    goto LABEL_23;
LABEL_35:
  v1 &= 0xFFF7u;
  sub_D504((unsigned __int8 *)byte_B8E14, "version");
LABEL_23:
  if ( v1 )
  {
    sub_6C054((int)v3, 0xAu, (unsigned __int8 *)"%0x", v1);
    sub_D504((unsigned __int8 *)byte_B8E14, v3);
  }
  if ( !byte_B8E14[0] )
    sub_D504((unsigned __int8 *)byte_B8E14, "(none)");
  return byte_B8E14;
}
// 1BC: using guessed type int elf_hash_bucket[521];

//----- (00013D38) --------------------------------------------------------
bool __fastcall sub_13D38(unsigned __int16 *a1)
{
  int v1; // r2

  v1 = *a1;
  if ( v1 == 2 )
    return *((_DWORD *)a1 + 1) == 0;
  if ( v1 == 10 )
    return memcmp(a1 + 4, &in6addr_any, 0x10u) == 0;
  return 0;
}

//----- (00013DC8) --------------------------------------------------------
int __fastcall sub_13DC8(_DWORD *s2)
{
  int v1; // r4
  int v3; // r5
  char *v4; // r6

  v1 = remoteaddr_list;
  if ( remoteaddr_list )
  {
    v4 = (char *)(s2 + 2);
    v3 = *(unsigned __int16 *)s2;
    while ( 1 )
    {
      if ( *(unsigned __int16 *)(v1 + 4) != v3 )
        goto LABEL_3;
      if ( v3 == 2 )
      {
        if ( *(_DWORD *)(v1 + 8) == s2[1] )
          return *(_DWORD *)(v1 + 32);
        v1 = *(_DWORD *)v1;
        if ( !v1 )
          return v1;
      }
      else
      {
        if ( !memcmp((const void *)(v1 + 12), v4, 0x10u) && *(_DWORD *)(v1 + 28) == s2[6] )
          return *(_DWORD *)(v1 + 32);
LABEL_3:
        v1 = *(_DWORD *)v1;
        if ( !v1 )
          return v1;
      }
    }
  }
  return v1;
}
// 107D20: using guessed type int remoteaddr_list;

//----- (00013EA4) --------------------------------------------------------
int __fastcall sub_13EA4(_DWORD *a1, int a2)
{
  _DWORD *v4; // r6
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int result; // r0
  int v9; // r1
  int v10; // r2

  v4 = sub_63BA4(0, 0x24u, 0, 0);
  v5 = a1[1];
  v6 = a1[2];
  v7 = a1[3];
  v4[1] = *a1;
  v4[2] = v5;
  v4[3] = v6;
  v4[4] = v7;
  result = a1[4];
  v9 = a1[5];
  v10 = a1[6];
  v4[5] = result;
  v4[6] = v9;
  v4[7] = v10;
  v4[8] = a2;
  *v4 = remoteaddr_list;
  remoteaddr_list = (int)v4;
  return result;
}
// 107D20: using guessed type int remoteaddr_list;

//----- (00013F3C) --------------------------------------------------------
_DWORD *__fastcall sub_13F3C(const void *a1)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r5
  int v5; // r3

  v2 = sub_63BA4(0, 0xC0u, 0, 0);
  v3 = v2;
  if ( a1 )
  {
    memcpy(v2, a1, 0xC0u);
  }
  else
  {
    memset(v2, 0, 0xC0u);
    v3[3] = -1;
    v3[4] = -1;
    *((_WORD *)v3 + 71) = word_B9240[0];
  }
  v5 = sys_ifnum;
  v3[5] = sys_ifnum;
  sys_ifnum = v5 + 1;
  v3[40] = current_time;
  return v3;
}
// B9240: using guessed type __int16 word_B9240[];
// 107D48: using guessed type int sys_ifnum;
// 108CA4: using guessed type int current_time;

//----- (0001400C) --------------------------------------------------------
int __fastcall sub_1400C(int a1, int fd, unsigned __int16 *a3)
{
  int v5; // r12
  const char *v7; // r0
  int optval; // [sp+8h] [bp-8h] BYREF

  v5 = *a3;
  optval = 1;
  if ( v5 == 2 && setsockopt(fd, 1, 6, &optval, 4u) )
  {
    v7 = sub_6C2E8(a3);
    sub_64E00(3, "setsockopt(SO_BROADCAST) enable failure on address %s: %m", v7);
  }
  *(_DWORD *)(a1 + 144) |= 0x400u;
  return 1;
}

//----- (000140C0) --------------------------------------------------------
char *__fastcall sub_140C0(char *result, int a2)
{
  int v2; // r3
  const char *v3; // r2
  int optval; // [sp+Ch] [bp-Ch] BYREF

  optval = a2;
  if ( result == (_BYTE *)&dword_0 + 2 )
    v2 = any_interface;
  else
    v2 = any6_interface;
  if ( v2 )
  {
    result = *(char **)(v2 + 12);
    if ( result != (char *)-1 )
    {
      result = (char *)setsockopt((int)result, 1, 2, &optval, 4u);
      if ( result )
      {
        if ( optval )
          v3 = "on";
        else
          v3 = "off";
        return sub_64E00(3, "set_wildcard_reuse: setsockopt(SO_REUSEADDR, %s) failed: %m", v3);
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;

//----- (000141A4) --------------------------------------------------------
char *__fastcall sub_141A4(char *result)
{
  int i; // r4
  _BYTE *v2; // r2
  char *v3; // r3
  char *optval; // [sp+Ch] [bp-Ch] BYREF

  optval = result;
  for ( i = ep_list; i; i = *(_DWORD *)i )
  {
    if ( (*(_DWORD *)(i + 144) & 0x80) == 0 )
    {
      result = *(char **)(i + 12);
      if ( result != (char *)-1 )
      {
        result = (char *)setsockopt((int)result, 1, 2, &optval, 4u);
        if ( result )
        {
          v2 = sub_6C2E8((unsigned __int16 *)(i + 24));
          if ( optval )
            v3 = "on";
          else
            v3 = "off";
          result = sub_64E00(3, "set_reuseaddr: setsockopt(%s, SO_REUSEADDR, %s) failed: %m", v2, v3);
        }
      }
    }
  }
  return result;
}
// 107D28: using guessed type int ep_list;

//----- (00014298) --------------------------------------------------------
char *__fastcall sub_14298(int a1)
{
  unsigned __int16 *v1; // r8
  char *result; // r0
  int *v4; // r2
  int v5; // r1
  int v6; // r7
  int v7; // r4
  int v8; // r8
  int v9; // r5
  int v10; // r10
  int v11; // r3
  int v12; // r2
  _BOOL4 v13; // r1
  int v14; // r3
  int v15; // r2
  int v16; // r1
  int v17; // r3
  int *v18; // r1
  int v19; // r3
  int v20; // r4
  int v21; // r3
  _BYTE *v22; // r3
  _DWORD *v23; // r11
  unsigned int v24; // r0
  _DWORD *v25; // r1
  int v26; // r3
  unsigned int v27; // r3
  _DWORD *v28; // r12
  int v29; // r3
  int v30; // t1
  int v31; // lr
  int v32; // t1
  int v33; // t1
  int v34; // r3
  _BYTE *v35; // r2
  _BOOL4 v36; // [sp+10h] [bp-2Ch]
  int *v37; // [sp+14h] [bp-28h]
  int v38; // [sp+18h] [bp-24h]
  int v39; // [sp+20h] [bp-1Ch]
  int v40; // [sp+28h] [bp-14h]
  unsigned __int16 *v41; // [sp+2Ch] [bp-10h]

  v1 = (unsigned __int16 *)(a1 + 24);
  result = (char *)sub_6083C(a1 + 24);
  *(_DWORD *)(a1 + 152) = result;
  v4 = (int *)ep_list;
  if ( ep_list )
  {
    while ( *v4 )
      v4 = (int *)*v4;
  }
  else
  {
    v4 = &ep_list;
  }
  *(_DWORD *)a1 = 0;
  *v4 = a1;
  v5 = *(_DWORD *)(a1 + 180);
  ++ninterfaces;
  if ( v5 || (*(_DWORD *)(a1 + 144) & 0x14) != 0x10 )
    return result;
  v6 = *(unsigned __int16 *)(a1 + 140);
  if ( v6 == 2 )
  {
    v7 = mc4_list;
    if ( !mc4_list )
    {
      v37 = &mc4_list;
      goto LABEL_79;
    }
    v38 = 0;
    v37 = &mc4_list;
    v39 = 0;
    v36 = 0;
    goto LABEL_12;
  }
  v7 = mc6_list;
  if ( v6 == 10 )
  {
    v38 = (*(_DWORD *)(a1 + 144) >> 9) & 1;
    v34 = *(_DWORD *)(a1 + 32) & 0x80FF;
    v36 = v34 == 33022;
    v39 = (*(unsigned __int8 *)(a1 + 40) >> 1) & 1;
    if ( mc6_list )
    {
      v37 = &mc6_list;
      goto LABEL_12;
    }
    if ( v34 == 33022 )
    {
      v37 = &mc6_list;
      goto LABEL_45;
    }
LABEL_78:
    v37 = &mc6_list;
    goto LABEL_79;
  }
  if ( !mc6_list )
    goto LABEL_78;
  v39 = 0;
  v37 = &mc6_list;
  v38 = 0;
  v36 = 0;
LABEL_12:
  v41 = v1;
  v8 = !v36;
  do
  {
    while ( 1 )
    {
      v9 = *(_DWORD *)(v7 + 4);
      if ( *(unsigned __int16 *)(v7 + 140) != v6 )
        goto LABEL_18;
      v10 = strcmp((const char *)(a1 + 108), (const char *)(v7 + 108));
      if ( v10 )
        goto LABEL_18;
      v11 = *(unsigned __int16 *)(a1 + 52);
      if ( v11 != *(unsigned __int16 *)(a1 + 24) )
        sub_6ECC0("ntp_io.c", 699, 0, "((a)->sa.sa_family) == ((a_mask)->sa.sa_family)");
      v12 = *(unsigned __int16 *)(v7 + 52);
      if ( v12 != *(unsigned __int16 *)(v7 + 24) )
        sub_6ECC0("ntp_io.c", 700, 0, "((b)->sa.sa_family) == ((b_mask)->sa.sa_family)");
      if ( v11 != v12 )
      {
LABEL_24:
        result = 0;
        goto LABEL_25;
      }
      if ( v11 == 2 )
      {
        if ( *(_DWORD *)(a1 + 56) != *(_DWORD *)(v7 + 56) )
          goto LABEL_24;
LABEL_73:
        v24 = a1 + 28;
        v25 = (_DWORD *)(v7 + 28);
        v23 = (_DWORD *)(a1 + 56);
        v26 = 4;
        goto LABEL_63;
      }
      v23 = (_DWORD *)(a1 + 60);
      v40 = *(unsigned __int16 *)(a1 + 52);
      result = (char *)memcmp((const void *)(a1 + 60), (const void *)(v7 + 60), 0x10u);
      if ( result )
        goto LABEL_24;
      if ( *(_DWORD *)(a1 + 76) != *(_DWORD *)(v7 + 76) )
        goto LABEL_25;
      if ( v40 != 10 )
        goto LABEL_73;
      v24 = a1 + 32;
      v25 = (_DWORD *)(v7 + 32);
      v26 = 16;
LABEL_63:
      v27 = v24 + v26;
      if ( v24 < v27 )
      {
        if ( ((*v25 ^ *(_DWORD *)v24) & *v23) != 0 )
          goto LABEL_24;
        v28 = (_DWORD *)((char *)v25 + ((~v24 + v27) & 0xFFFFFFFC));
        while ( v28 != v25 )
        {
          v30 = *(_DWORD *)(v24 + 4);
          v24 += 4;
          v29 = v30;
          v32 = v25[1];
          ++v25;
          v31 = v32;
          v33 = v23[1];
          ++v23;
          if ( ((v29 ^ v31) & v33) != 0 )
            goto LABEL_24;
        }
      }
      result = (_BYTE *)(&dword_0 + 1);
LABEL_25:
      if ( v6 == 10 )
      {
        v15 = (*(unsigned __int8 *)(v7 + 40) >> 1) & 1;
        v14 = (*(_DWORD *)(v7 + 144) >> 9) & 1;
        v13 = v36;
        v10 = (*(_WORD *)(v7 + 32) & 0x80FF) == 33022;
        if ( (*(_WORD *)(v7 + 32) & 0x80FF) == 0x80FE )
          v13 = 0;
      }
      else
      {
        v13 = v36;
        v14 = 0;
        v15 = 0;
      }
      if ( v13 )
        return result;
      if ( result )
        break;
      if ( (v8 & v10) != 0 )
        goto LABEL_30;
LABEL_18:
      v7 = v9;
      if ( !v9 )
        goto LABEL_39;
    }
    result = (char *)v38;
    if ( ((v14 ^ 1) & v38) != 0 || ((v39 ^ 1) & v15) != 0 )
      return result;
    if ( (v8 & v10) == 0 && ((v38 ^ 1) & v14) == 0 && ((v15 ^ 1) & v39) == 0 )
      goto LABEL_18;
LABEL_30:
    v16 = *v37;
    if ( *v37 == v7 )
    {
      v17 = v7;
      v18 = v37;
    }
    else
    {
      if ( !v16 )
        goto LABEL_18;
      v17 = *(_DWORD *)(v16 + 4);
      if ( !v17 )
        goto LABEL_18;
      while ( v17 != v7 )
      {
        v16 = v17;
        if ( !*(_DWORD *)(v17 + 4) )
          goto LABEL_18;
        v17 = *(_DWORD *)(v17 + 4);
      }
      v18 = (int *)(v16 + 4);
    }
    v7 = v9;
    *v18 = *(_DWORD *)(v17 + 4);
  }
  while ( v9 );
LABEL_39:
  v1 = v41;
  v7 = *v37;
  if ( !v36 )
  {
LABEL_79:
    *(_DWORD *)(a1 + 4) = v7;
    *v37 = a1;
    goto LABEL_46;
  }
  if ( v7 )
  {
    while ( *(_DWORD *)(v7 + 4) )
      v7 = *(_DWORD *)(v7 + 4);
    v37 = (int *)(v7 + 4);
  }
LABEL_45:
  *(_DWORD *)(a1 + 4) = 0;
  *v37 = a1;
LABEL_46:
  result = *(char **)(a1 + 12);
  if ( result != (char *)-1 )
  {
    v19 = *(unsigned __int16 *)(a1 + 24);
    if ( v19 == 2 )
    {
      result = (char *)setsockopt((int)result, 0, 32, (const void *)(a1 + 28), 4u);
      if ( result )
      {
        v35 = sub_6C2E8(v1);
        return sub_64E00(3, "setsockopt IP_MULTICAST_IF %s fails: %m", v35);
      }
    }
    else if ( v19 == 10 )
    {
      result = (char *)setsockopt((int)result, 41, 17, (const void *)(a1 + 176), 4u);
      if ( result )
      {
        v20 = *(_DWORD *)(a1 + 176);
        if ( *(_WORD *)(a1 + 24) == 2 )
          v21 = 0;
        else
          v21 = *(_DWORD *)(a1 + 48);
        if ( v20 != v21 )
        {
          v22 = sub_6C2E8(v1);
          return sub_64E00(3, "setsockopt IPV6_MULTICAST_IF %u for %s fails: %m", v20, v22);
        }
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 107D04: using guessed type int mc4_list;
// 107D1C: using guessed type int mc6_list;
// 107D28: using guessed type int ep_list;
// 107D38: using guessed type int ninterfaces;

//----- (0001482C) --------------------------------------------------------
char *__fastcall sub_1482C(int a1)
{
  const char *v2; // r6
  int v3; // r7
  const char *v4; // r0

  if ( *(_DWORD *)(a1 + 180) )
    v2 = "Listen and drop";
  else
    v2 = "Listen normally";
  v3 = *(_DWORD *)(a1 + 20);
  v4 = sub_6C47C((unsigned __int16 *)(a1 + 24));
  return sub_64E00(6, "%s on %d %s %s", v2, v3, (const char *)(a1 + 108), v4);
}

//----- (000148D0) --------------------------------------------------------
int __fastcall sub_148D0(_DWORD *a1, unsigned __int16 *a2)
{
  int v3; // r0
  int result; // r0
  int v5; // r3
  int *v6; // r1
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  _DWORD *v11; // t0
  int v12; // r6
  int v13; // r0
  _DWORD v14[2]; // [sp+8h] [bp-20h] BYREF
  _DWORD optval[5]; // [sp+10h] [bp-18h] BYREF

  v3 = *a2;
  if ( v3 == 2 )
  {
    v13 = a1[3];
    v14[0] = *((_DWORD *)a2 + 1);
    v14[1] = 0;
    if ( setsockopt(v13, 0, 35, v14, 8u) )
      return 0;
  }
  else if ( v3 == 10 )
  {
    v6 = (int *)(a2 + 4);
    v7 = *v6;
    v11 = v6 + 1;
    v8 = v6[1];
    v9 = *++v11;
    v10 = v11[1];
    v12 = a1[3];
    optval[0] = v7;
    optval[1] = v8;
    optval[2] = v9;
    optval[3] = v10;
    optval[4] = a1[44];
    if ( setsockopt(v12, 41, 20, optval, 0x14u) )
      return 0;
  }
  result = 1;
  v5 = a1[39] + 1;
  a1[36] |= 0x40u;
  a1[39] = v5;
  return result;
}

//----- (000149CC) --------------------------------------------------------
int __fastcall sub_149CC(const char *a1, unsigned __int16 *a2, unsigned int a3)
{
  _BOOL4 v5; // r10
  int v6; // r4
  unsigned int v7; // r8
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r1
  int v13; // r2
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r2
  int v18; // r1
  int result; // r0
  int v20; // r3
  int v21; // r3
  int v22; // [sp+4h] [bp-80h]
  int v23; // [sp+10h] [bp-74h]
  _DWORD v24[6]; // [sp+24h] [bp-60h] BYREF
  _DWORD v25[6]; // [sp+3Ch] [bp-48h] BYREF
  int v26; // [sp+54h] [bp-30h] BYREF
  int v27; // [sp+58h] [bp-2Ch]
  int v28; // [sp+5Ch] [bp-28h]
  int v29; // [sp+60h] [bp-24h]
  int v30; // [sp+64h] [bp-20h]
  int v31; // [sp+68h] [bp-1Ch]
  int v32; // [sp+6Ch] [bp-18h]
  int v33; // [sp+70h] [bp-14h]
  int v34; // [sp+74h] [bp-10h]
  int v35; // [sp+78h] [bp-Ch]

  v23 = a3 & 4;
  v22 = (a3 >> 2) & 1;
  v5 = sub_13D38(a2);
  v6 = nic_rule_list;
  if ( nic_rule_list )
  {
    while ( 1 )
    {
      switch ( *(_DWORD *)(v6 + 8) )
      {
        case 0:
          if ( v5 | v22 )
            goto LABEL_5;
          return *(_DWORD *)(v6 + 4);
        case 1:
          if ( *a2 == 2 )
            return *(_DWORD *)(v6 + 4);
          goto LABEL_5;
        case 2:
          if ( *a2 == 10 )
            return *(_DWORD *)(v6 + 4);
          goto LABEL_5;
        case 3:
          if ( v5 )
            return *(_DWORD *)(v6 + 4);
          goto LABEL_5;
        case 4:
          if ( a1 && !fnmatch(*(const char **)(v6 + 12), a1, 16) )
            return *(_DWORD *)(v6 + 4);
          goto LABEL_5;
        case 5:
          v7 = *(_DWORD *)(v6 + 44);
          if ( v7 == -1 )
          {
            v21 = *(unsigned __int16 *)(v6 + 16);
            if ( v21 == *a2 )
            {
              if ( v21 == 2 )
              {
                if ( *((_DWORD *)a2 + 1) == *(_DWORD *)(v6 + 20) )
                  return *(_DWORD *)(v6 + 4);
              }
              else if ( !memcmp(a2 + 4, (const void *)(v6 + 24), 0x10u) && *((_DWORD *)a2 + 6) == *(_DWORD *)(v6 + 40) )
              {
                return *(_DWORD *)(v6 + 4);
              }
            }
          }
          else
          {
            v8 = *(_DWORD *)a2;
            v9 = *((_DWORD *)a2 + 1);
            v10 = *((_DWORD *)a2 + 2);
            v11 = *((_DWORD *)a2 + 3);
            v34 = 0;
            v33 = 0;
            v35 = 0;
            v26 = v8;
            v27 = v9;
            v28 = v10;
            v29 = v11;
            v12 = *((_DWORD *)a2 + 5);
            v13 = *((_DWORD *)a2 + 6);
            v30 = *((_DWORD *)a2 + 4);
            v31 = v12;
            v32 = v13;
            sub_74CE8(v24, &v26);
            v33 = 0;
            v34 = 0;
            v35 = 0;
            v14 = *(_DWORD *)(v6 + 20);
            v15 = *(_DWORD *)(v6 + 24);
            v16 = *(_DWORD *)(v6 + 28);
            v26 = *(_DWORD *)(v6 + 16);
            v27 = v14;
            v28 = v15;
            v29 = v16;
            v17 = *(_DWORD *)(v6 + 40);
            v18 = *(_DWORD *)(v6 + 36);
            v30 = *(_DWORD *)(v6 + 32);
            v31 = v18;
            v32 = v17;
            sub_74CE8(v25, &v26);
            if ( sub_74518(v24, v25, v7) )
              return *(_DWORD *)(v6 + 4);
          }
LABEL_5:
          v6 = *(_DWORD *)v6;
          if ( !v6 )
            goto LABEL_6;
          break;
        default:
          goto LABEL_5;
      }
    }
  }
LABEL_6:
  if ( v23 )
    return 0;
  if ( v5 )
    return 2;
  v20 = (int)a1;
  if ( a1 )
    v20 = 1;
  if ( listen_to_virtual_ips )
    v20 = 0;
  if ( v20 && strchr(a1, 58) )
    return 1;
  result = nic_rule_list;
  if ( nic_rule_list )
    return 1;
  return result;
}
// B60D0: using guessed type int listen_to_virtual_ips;
// 107D10: using guessed type int nic_rule_list;

//----- (00014C78) --------------------------------------------------------
ssize_t __fastcall sub_14C78(int a1, int a2, int a3, int a4)
{
  char *v8; // r0
  char *v9; // r9
  ssize_t v10; // r8
  ssize_t v12; // r0
  size_t msg_controllen; // r3
  _DWORD *msg_control; // r10
  int v15; // r1
  int v16; // r1
  int v17; // r5
  int v18; // r2
  bool v19; // cc
  int v20; // r5
  int v21; // r6
  signed int v22; // r0
  double v23; // d0
  double v24; // r0
  int v25; // r2
  __int64 v26; // r0
  bool v27; // cf
  int v28; // r5
  int v29; // r3
  const char *v30; // r0
  __int64 v31; // r0
  const char *v32; // r0
  socklen_t addr_len; // [sp+20h] [bp-654h] BYREF
  _DWORD v34[2]; // [sp+24h] [bp-650h] BYREF
  int v35; // [sp+2Ch] [bp-648h]
  int v36; // [sp+30h] [bp-644h]
  struct msghdr message; // [sp+34h] [bp-640h] BYREF
  struct sockaddr addr; // [sp+50h] [bp-624h] BYREF
  _BYTE buf[1536]; // [sp+6Ch] [bp-608h] BYREF

  v8 = (char *)sub_6A108();
  v9 = v8;
  if ( !v8 )
    goto LABEL_4;
  if ( *(_DWORD *)(a2 + 180) )
  {
    sub_69FA8(v8);
LABEL_4:
    addr_len = 28;
    v10 = recvfrom(a1, buf, 0x4B0u, 0, &addr, &addr_len);
    if ( *(_DWORD *)(a2 + 180) )
      ++packets_ignored;
    else
      ++packets_dropped;
    return v10;
  }
  message.msg_flags = 0;
  addr_len = 28;
  message.msg_namelen = 28;
  v34[0] = v8 + 88;
  v34[1] = 2120;
  message.msg_iovlen = 1;
  message.msg_iov = (struct iovec *)v34;
  message.msg_name = v8 + 4;
  message.msg_control = buf;
  message.msg_controllen = 1536;
  v12 = recvmsg(a1, &message, 0);
  v10 = v12;
  *((_DWORD *)v9 + 21) = v12;
  if ( !v12 )
    goto LABEL_41;
  if ( v12 == -1 )
  {
    if ( *_errno_location() != 11 )
      goto LABEL_40;
LABEL_41:
    sub_69FA8(v9);
    return v10;
  }
  if ( v12 < 0 )
  {
LABEL_40:
    v30 = sub_6C2E8((unsigned __int16 *)v9 + 2);
    sub_64E00(3, "recvfrom(%s) fd=%d: %m", v30, a1);
    goto LABEL_41;
  }
  if ( *((_WORD *)v9 + 2) == 2 && *((_WORD *)v9 + 4) == 32639 )
  {
    v32 = sub_6C2E8((unsigned __int16 *)v9 + 2);
    sub_64E00(3, "recvfrom(%s) fd=%d: refclock srcadr on a network interface!", v32, a1);
LABEL_52:
    ++packets_dropped;
    sub_69FA8(v9);
    return v10;
  }
  if ( *(_WORD *)(a2 + 140) == 10
    && !*((_DWORD *)v9 + 3)
    && !*((_DWORD *)v9 + 4)
    && !*((_DWORD *)v9 + 5)
    && *((_DWORD *)v9 + 6) == 0x1000000
    && (*(_DWORD *)(a2 + 32) || *(_DWORD *)(a2 + 36) || *(_DWORD *)(a2 + 40) || *(_DWORD *)(a2 + 44) != 0x1000000) )
  {
    goto LABEL_52;
  }
  msg_controllen = message.msg_controllen;
  *((_DWORD *)v9 + 15) = a2;
  *((_DWORD *)v9 + 16) = a1;
  if ( msg_controllen > 0xB )
  {
    msg_control = message.msg_control;
    if ( message.msg_control )
    {
      do
      {
        if ( msg_control[2] == 35 )
        {
          v15 = msg_control[4];
          v35 = msg_control[3];
          v36 = v15;
          if ( sys_tick > measured_tick )
          {
            v16 = v36;
            if ( sys_tick > 0.000000001 )
              v16 = (int)((double)(unsigned int)((double)v36 * 0.000000001 / sys_tick) * 1000000000.0 * sys_tick);
          }
          else
          {
            v16 = v36;
          }
          v17 = v35;
          if ( v16 < 0 )
          {
            do
            {
              v16 += 1000000000;
              --v17;
            }
            while ( v16 < 0 );
          }
          else if ( v16 > 999999999 )
          {
            v18 = v16 - 1000000000;
            v19 = v16 - 1000000000 <= 999999999;
            if ( v16 - 1000000000 <= 999999999 )
              v17 = v35 + 1;
            else
              v16 -= 2013265920;
            if ( v19 )
              v16 = v18;
            else
              v16 += 13238272;
            if ( !v19 )
            {
              v17 += 2;
              v16 += 27648;
            }
          }
          v20 = v17 - 2085978496;
          v21 = sub_8BFD0(__PAIR64__(v16, 0) + 500000000, 0x3B9ACA00u);
          v22 = sub_68AE4();
          v23 = ((double)v22 + (double)v22) * 2.32830644e-10 * sys_fuzz;
          LODWORD(v24) = 32;
          ldexp(v24, v25);
          if ( v23 < 0.0 )
          {
            LODWORD(v31) = sub_8C010(-v23);
            v26 = -v31;
          }
          else
          {
            LODWORD(v26) = sub_8C010(v23);
          }
          v27 = __CFADD__(v21, (_DWORD)v26);
          a4 = v21 + v26;
          v28 = v20 + HIDWORD(v26);
          v29 = v27;
          a3 = v28 + v29;
        }
        if ( *msg_control <= 0xBu )
          break;
        msg_control = (_DWORD *)((char *)msg_control + ((*msg_control + 3) & 0xFFFFFFFC));
        if ( (char *)message.msg_control + message.msg_controllen < (char *)(msg_control + 3) )
          break;
      }
      while ( (char *)message.msg_control + message.msg_controllen >= (char *)msg_control
                                                                    + ((*msg_control + 3) & 0xFFFFFFFC) );
    }
  }
  *((_DWORD *)v9 + 18) = a3;
  *((_DWORD *)v9 + 19) = a4;
  *((_DWORD *)v9 + 20) = receive;
  sub_6A044(v9);
  ++*(_DWORD *)(a2 + 164);
  ++packets_received;
  return v10;
}
// 14F38: variable 'v24' is possibly undefined
// 14F38: variable 'v25' is possibly undefined
// 14F48: variable 'v26' is possibly undefined
// 15034: variable 'v31' is possibly undefined
// 15180: using guessed type char *off_15180;
// 106F50: using guessed type double sys_fuzz;
// 106F58: using guessed type double sys_tick;
// 107CFC: using guessed type int packets_received;
// 107D00: using guessed type int packets_ignored;
// 107D40: using guessed type int packets_dropped;
// 108CE0: using guessed type double measured_tick;

//----- (00015184) --------------------------------------------------------
int __fastcall sub_15184(_DWORD *s2)
{
  int v1; // r4
  int v3; // r5
  char *v4; // r6
  int result; // r0

  v1 = remoteaddr_list;
  if ( remoteaddr_list )
  {
    v4 = (char *)(s2 + 2);
    v3 = *(unsigned __int16 *)s2;
    do
    {
      if ( *(unsigned __int16 *)(v1 + 4) == v3 )
      {
        if ( v3 == 2 )
        {
          if ( *(_DWORD *)(v1 + 8) == s2[1] )
          {
            result = *(_DWORD *)(v1 + 32);
            if ( (*(_DWORD *)(result + 144) & 0x40) != 0 )
              return result;
          }
        }
        else if ( !memcmp((const void *)(v1 + 12), v4, 0x10u) && *(_DWORD *)(v1 + 28) == s2[6] )
        {
          result = *(_DWORD *)(v1 + 32);
          if ( (*(_DWORD *)(result + 144) & 0x40) != 0 )
            return result;
        }
      }
      v1 = *(_DWORD *)v1;
    }
    while ( v1 );
  }
  return v1;
}
// 107D20: using guessed type int remoteaddr_list;

//----- (00015274) --------------------------------------------------------
__int16 *__fastcall sub_15274(unsigned int a1, int a2)
{
  int v3; // r8
  int v4; // r0
  __int16 *v5; // r1
  int v6; // r4
  __int16 *result; // r0
  int v8; // r2
  int v9; // r0
  int v10; // r3
  int v11; // r2
  int v12; // r4

  if ( a1 >= 0x400 )
  {
    sub_64E00(3, "Too many sockets in use, FD_SETSIZE %d exceeded by fd %d", 1024, a1);
    exit(1);
  }
  v3 = 1 << (a1 & 0x1F);
  if ( a2 )
  {
    v4 = ((int (*)(void))_fdelt_chk)();
    v5 = word_B9240;
    v6 = dword_B92C4;
    result = &word_B9240[2 * v4];
    v8 = a1 == dword_B92C4;
    if ( !dword_B92C4 )
      v8 = 0;
    *((_DWORD *)result + 1) &= ~v3;
    if ( v8 )
    {
      v12 = v6 - 1;
      while ( 1 )
      {
        result = &word_B9240[2 * _fdelt_chk(v12, v5, v8)];
        v8 = *((_DWORD *)result + 1);
        if ( (v8 & (1 << (v12 & 0x1F))) != 0 )
          break;
        if ( v12-- == 0 )
        {
          v12 = dword_B92C4;
          goto LABEL_14;
        }
      }
      dword_B92C4 = v12;
LABEL_14:
      if ( v12 == a1 )
        sub_6ECC0("ntp_io.c", 380, 2, "fd != maxactivefd");
    }
  }
  else
  {
    v9 = ((int (*)(void))_fdelt_chk)();
    v10 = dword_B92C4;
    result = &word_B9240[2 * v9];
    v11 = *((_DWORD *)result + 1);
    if ( dword_B92C4 < (int)a1 )
      v10 = a1;
    dword_B92C4 = v10;
    *((_DWORD *)result + 1) = v11 | v3;
  }
  return result;
}
// 15344: variable 'v5' is possibly undefined
// C0E8: using guessed type int __fastcall _fdelt_chk(_DWORD, _DWORD, _DWORD);
// B9240: using guessed type __int16 word_B9240[];
// B92C4: using guessed type int dword_B92C4;

//----- (000153D4) --------------------------------------------------------
__int16 *__fastcall sub_153D4(unsigned int a1, int a2, int a3)
{
  return sub_15274(a1, a3);
}

//----- (00015420) --------------------------------------------------------
__int16 *__fastcall sub_15420(unsigned int a1, int a2)
{
  _DWORD *v4; // r0

  v4 = sub_63BA4(0, 0xCu, 0, 0);
  v4[1] = a1;
  v4[2] = a2;
  *v4 = fd_list;
  fd_list = (int)v4;
  return sub_15274(a1, 0);
}
// 107D30: using guessed type int fd_list;

//----- (000154A8) --------------------------------------------------------
int __fastcall sub_154A8(struct sockaddr *a1, int a2, int a3, int a4)
{
  int sa_family; // r0
  int v9; // r0
  int *v10; // r6
  unsigned int v11; // r5
  const char *v12; // r7
  const char *v13; // r0
  bool v14; // cc
  unsigned int v15; // r5
  int v17; // r0
  char *v18; // r11
  socklen_t v19; // r2
  int v20; // r6
  const char *v21; // r6
  const char *v22; // r0
  int v23; // r0
  const char *v24; // r0
  int *v25; // r6
  const char *v26; // r0
  int *v27; // r11
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r6
  const char *v31; // r0
  int v32; // r2
  int v33; // r3
  unsigned __int16 v34; // r1
  int v35; // r2
  const char *v36; // r2
  int v37; // r0
  int v38; // [sp+14h] [bp-10h] BYREF
  int optval; // [sp+18h] [bp-Ch] BYREF

  sa_family = a1->sa_family;
  v38 = 1;
  optval = 0;
  if ( sa_family == 10 && !ipv6_works )
    return -1;
  v9 = socket(sa_family, 2, 0);
  if ( v9 == -1 )
  {
    v10 = _errno_location();
    v11 = *v10;
    if ( a1->sa_family == 10 )
      v12 = "6";
    else
      v12 = (const char *)&unk_97F7C;
    v13 = sub_6C2E8(&a1->sa_family);
    sub_64E00(3, "socket(AF_INET%s, SOCK_DGRAM, 0) failed on address %s: %m", v12, v13);
    v14 = v11 > 0x5D;
    if ( v11 != 93 )
      v14 = v11 - 96 > 1;
    if ( v14 )
    {
      *v10 = v11;
      sub_64E00(
        3,
        "unexpected socket() error %m code %d (not EPROTONOSUPPORT nor EAFNOSUPPORT nor EPFNOSUPPORT) - exiting",
        v11);
      exit(1);
    }
    return -1;
  }
  v17 = sub_6C0B8(v9);
  v15 = v17;
  if ( !a3 )
  {
    if ( !setsockopt(v17, 1, 2, &v38, 4u) )
      goto LABEL_13;
    v21 = "on";
LABEL_28:
    v22 = sub_6C2E8(&a1->sa_family);
    sub_64E00(3, "setsockopt SO_REUSEADDR %s fails for address %s: %m", v21, v22);
    v23 = v15;
    v15 = -1;
    close(v23);
    return v15;
  }
  if ( setsockopt(v17, 1, 2, &optval, 4u) )
  {
    v21 = "off";
    goto LABEL_28;
  }
LABEL_13:
  v18 = (char *)a1->sa_family;
  if ( v18 == (_BYTE *)&dword_0 + 2 )
  {
    if ( setsockopt(v15, 0, 1, &qos, 4u) )
    {
      v27 = qos;
      v28 = sub_6C2E8(&a1->sa_family);
      sub_64E00(3, "setsockopt IP_TOS (%02x) fails on address %s: %m", v27, v28);
    }
    if ( a2 )
      sub_1400C(a4, v15, &a1->sa_family);
    v18 = (char *)a1->sa_family;
  }
  if ( v18 == &byte_9[1] )
  {
    if ( setsockopt(v15, 41, 67, &qos, 4u) )
    {
      v25 = qos;
      v26 = sub_6C2E8(&a1->sa_family);
      sub_64E00(3, "setsockopt IPV6_TCLASS (%02x) fails on address %s: %m", v25, v26);
    }
    if ( !sub_740D8() && setsockopt(v15, 41, 26, &v38, 4u) )
    {
      v29 = sub_6C2E8(&a1->sa_family);
      sub_64E00(3, "setsockopt IPV6_V6ONLY on fails on address %s: %m", v29);
    }
    v18 = (char *)a1->sa_family;
  }
  if ( !sub_13D38(&a1->sa_family) )
  {
    sub_140C0(v18, 1);
    v18 = (char *)a1->sa_family;
  }
  if ( v18 == (_BYTE *)&dword_0 + 2 )
    v19 = 16;
  else
    v19 = 28;
  v20 = bind(v15, a1, v19);
  if ( !sub_13D38(&a1->sa_family) )
    sub_140C0((char *)a1->sa_family, 0);
  if ( v20 < 0 )
  {
    if ( !a3 )
    {
      if ( a1->sa_family == 10 )
        v30 = "6";
      else
        v30 = (const char *)&unk_97F7C;
      v31 = sub_6C2E8(&a1->sa_family);
      v33 = a1->sa_family;
      if ( v33 == 2 )
        v32 = *(_DWORD *)&a1->sa_data[2];
      v34 = __rev16(*(unsigned __int16 *)a1->sa_data);
      if ( v33 == 2 )
        v35 = (v32 & 0xF0) - 224;
      else
        v35 = (unsigned __int8)a1->sa_data[6] - 255;
      if ( v35 )
        v36 = (const char *)&unk_97F7C;
      else
        v36 = " (multicast)";
      sub_64E00(3, "bind(%d) AF_INET%s %s#%d%s flags 0x%x failed: %m", v15, v30, v31, v34, v36, *(_DWORD *)(a4 + 144));
    }
    v37 = v15;
    v15 = -1;
    close(v37);
  }
  else
  {
    if ( setsockopt(v15, 1, 35, &v38, 4u) )
    {
      v24 = sub_6C2E8(&a1->sa_family);
      sub_64E00(7, "setsockopt SO_TIMESTAMPNS on fails on address %s: %m", v24);
    }
    sub_6C26C(v15);
    sub_15420(v15, 0);
  }
  return v15;
}
// 1587C: variable 'v32' is possibly undefined
// 0: using guessed type int dword_0;
// B60C8: using guessed type int *qos;
// 108D68: using guessed type int ipv6_works;

//----- (00015954) --------------------------------------------------------
__int16 *__fastcall sub_15954(__int16 *result)
{
  unsigned int v1; // r5
  int *v2; // r2
  int *v3; // r4
  int *v4; // r3
  unsigned int v5; // r1

  v1 = (unsigned int)result;
  v2 = &fd_list;
  v3 = (int *)fd_list;
  v4 = *(int **)fd_list;
  if ( *(__int16 **)(fd_list + 4) != result )
  {
    if ( !v4 )
      return result;
    while ( (__int16 *)v4[1] != result )
    {
      v3 = v4;
      if ( !*v4 )
        return result;
      v4 = (int *)*v4;
    }
    v2 = v3;
    v3 = (int *)*v3;
    v4 = (int *)*v3;
  }
  v5 = v3[2];
  *v2 = (int)v4;
  if ( v5 > 1 )
  {
    sub_64E00(3, "internal error - illegal descriptor type %d - EXITING", v5);
    exit(1);
  }
  close(v3[1]);
  free(v3);
  return sub_15274(v1, 1);
}
// 107D30: using guessed type int fd_list;

//----- (00015A58) --------------------------------------------------------
__int16 *__fastcall sub_15A58(int a1)
{
  int *v2; // r3
  int *v3; // r1
  int *v4; // r3
  __int16 *result; // r0

  v2 = &asyncio_reader_list;
  v3 = (int *)asyncio_reader_list;
  if ( a1 == asyncio_reader_list )
  {
LABEL_9:
    *v2 = *v3;
    goto LABEL_10;
  }
  if ( asyncio_reader_list )
  {
    v4 = *(int **)asyncio_reader_list;
    if ( *(_DWORD *)asyncio_reader_list )
    {
      while ( (int *)a1 != v4 )
      {
        v3 = v4;
        if ( !*v4 )
          goto LABEL_10;
        v4 = (int *)*v4;
      }
      v2 = v3;
      v3 = (int *)*v3;
      goto LABEL_9;
    }
  }
LABEL_10:
  result = *(__int16 **)(a1 + 4);
  if ( result != (__int16 *)-1 )
    result = sub_15954(result);
  *(_DWORD *)(a1 + 4) = -1;
  return result;
}
// 107D0C: using guessed type int asyncio_reader_list;

//----- (00015B14) --------------------------------------------------------
void __fastcall sub_15B14(int a1)
{
  void *v1; // r7
  _DWORD *v2; // r5
  ssize_t v3; // r0
  int v4; // r7
  unsigned int v5; // r3
  _DWORD buf[1279]; // [sp+4h] [bp-1408h] BYREF

  v1 = (void *)a1;
  if ( disable_dynamic_updates )
    goto LABEL_9;
  v2 = buf;
  v3 = read(*(_DWORD *)(a1 + 4), buf, 0x1400u);
  if ( v3 < 0 )
  {
    if ( *_errno_location() == 105 )
    {
      sub_64E00(3, "routing socket reports: %m");
      return;
    }
    sub_64E00(3, "routing socket reports: %m - disabling");
    a1 = (int)v1;
LABEL_9:
    sub_15A58(a1);
    free(v1);
    return;
  }
  if ( v3 > 15 && buf[0] > 0xFu )
  {
    v4 = v3;
    if ( buf[0] <= (unsigned int)v3 )
    {
      while ( 2 )
      {
        switch ( *((_WORD *)v2 + 2) )
        {
          case 3:
            return;
          case 0x10:
          case 0x11:
          case 0x14:
          case 0x15:
          case 0x18:
          case 0x19:
            sub_40E80(current_time + 2);
            goto LABEL_13;
          default:
LABEL_13:
            v5 = (*v2 + 3) & 0xFFFFFFFC;
            v4 -= v5;
            v2 = (_DWORD *)((char *)v2 + v5);
            if ( v4 <= 15 || *v2 <= 0xFu || (unsigned int)v4 < *v2 )
              return;
            continue;
        }
      }
    }
  }
}
// 107D24: using guessed type int disable_dynamic_updates;
// 108CA4: using guessed type int current_time;

//----- (00015CF0) --------------------------------------------------------
int sub_15CF0()
{
  int v1; // [sp+4h] [bp-8h]

  sub_69EA8(10);
  interface_interval = 300;
  addremove_io_fd = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))sub_153D4;
  return v1;
}
// 15D34: variable 'v1' is possibly undefined
// 108CB8: using guessed type int interface_interval;
// 1095B4: using guessed type int (__fastcall *addremove_io_fd)(_DWORD, _DWORD, _DWORD);

//----- (00015D6C) --------------------------------------------------------
int __fastcall sub_15D6C(int (__fastcall *a1)(int, _DWORD **), int a2)
{
  int result; // r0
  _DWORD *v5; // [sp+Ch] [bp-Ch] BYREF
  char v6; // [sp+10h] [bp-8h]

  result = 2092;
  v6 = 1;
  v5 = (_DWORD *)ep_list;
  if ( ep_list )
  {
    do
    {
      result = a1(a2, &v5);
      v5 = (_DWORD *)*v5;
    }
    while ( v5 );
  }
  return result;
}
// 107D28: using guessed type int ep_list;

//----- (00015E04) --------------------------------------------------------
_DWORD *__fastcall sub_15E04(int a1, const char *a2, int a3, int a4)
{
  _DWORD *result; // r0
  _DWORD *v9; // r4

  result = sub_63BA4(0, 0x30u, 0, 1);
  v9 = result;
  result[11] = a3;
  result[2] = a1;
  result[1] = a4;
  if ( a1 == 4 )
  {
    if ( !a2 )
      sub_6ECC0("ntp_io.c", 1207, 0, "((void *)0) != if_name");
    result = sub_63D08(a2);
    v9[3] = result;
  }
  else if ( a1 == 5 )
  {
    if ( !a2 )
      sub_6ECC0("ntp_io.c", 1210, 0, "((void *)0) != if_name");
    result = (_DWORD *)sub_64054((int)a2, 0, result + 4);
    if ( !result )
      sub_6ECC0("ntp_io.c", 1213, 0, "is_ip");
  }
  else if ( a2 )
  {
    sub_6ECC0("ntp_io.c", 1215, 0, "((void *)0) == if_name");
  }
  *v9 = nic_rule_list;
  nic_rule_list = (int)v9;
  return result;
}
// 107D10: using guessed type int nic_rule_list;

//----- (00015F74) --------------------------------------------------------
_DWORD *__fastcall sub_15F74(_DWORD *result, int *a2)
{
  int v2; // r3
  _DWORD *v3; // r1
  int v4; // t1
  int v5; // lr
  int v6; // r12
  int v7; // r1

  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  *result = 0;
  result[4] = 0;
  result[5] = 0;
  result[6] = 0;
  v2 = *a2;
  *(_WORD *)result = *a2;
  if ( v2 == 2 )
  {
    result[1] = a2[1];
  }
  else if ( v2 == 10 )
  {
    v4 = a2[1];
    v3 = a2 + 1;
    v5 = v3[1];
    v6 = v3[2];
    v7 = v3[3];
    result[2] = v4;
    result[3] = v5;
    result[4] = v6;
    result[5] = v7;
  }
  return result;
}

//----- (00016020) --------------------------------------------------------
int __fastcall sub_16020(int a1, unsigned __int16 *a2)
{
  return sub_1400C(a1, *(_DWORD *)(a1 + 12), a2);
}

//----- (00016070) --------------------------------------------------------
int sub_16070()
{
  return broadcast_client_enabled;
}
// 107D2C: using guessed type int broadcast_client_enabled;

//----- (000160C4) --------------------------------------------------------
char *__fastcall sub_160C4(int a1, unsigned __int16 *a2)
{
  char *result; // r0
  int v5; // r12
  int v6; // r3
  int v7; // r7
  const char *v8; // r4
  const char *v9; // r0
  int v10; // r7
  const char *v11; // r4
  const char *v12; // r0
  int v13; // [sp+Ch] [bp-10h] BYREF
  int optval; // [sp+10h] [bp-Ch] BYREF

  result = (_BYTE *)(elf_hash_bucket + 1648);
  v5 = *a2;
  v6 = *(unsigned __int16 *)(a1 + 24);
  v13 = 0;
  optval = 0;
  if ( v6 != v5 )
    sub_6ECC0("ntp_io.c", 2398, 0, "((maddr)->sa.sa_family) == ((&iface->sin)->sa.sa_family)");
  if ( v6 == 2 )
  {
    result = (char *)setsockopt(*(_DWORD *)(a1 + 12), 0, 34, &v13, 4u);
    if ( result )
    {
      v10 = *(_DWORD *)(a1 + 12);
      v11 = sub_6C2E8((unsigned __int16 *)(a1 + 24));
      v12 = sub_6C2E8(a2);
      return sub_64E00(
               3,
               "setsockopt IP_MULTICAST_LOOP failed: %m on socket %d, addr %s for multicast address %s",
               v10,
               v11,
               v12);
    }
  }
  else if ( v6 == 10 )
  {
    result = (char *)setsockopt(*(_DWORD *)(a1 + 12), 41, 19, &optval, 4u);
    if ( result )
    {
      v7 = *(_DWORD *)(a1 + 12);
      v8 = sub_6C2E8((unsigned __int16 *)(a1 + 24));
      v9 = sub_6C2E8(a2);
      return sub_64E00(
               3,
               "setsockopt IPV6_MULTICAST_LOOP failed: %m on socket %d, addr %s for multicast address %s",
               v7,
               v8,
               v9);
    }
  }
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];

//----- (0001621C) --------------------------------------------------------
char *sub_1621C()
{
  int v0; // r4
  int v1; // r5
  const char *v2; // r0
  int v3; // r2
  int v4; // r0
  const char *v5; // r0
  int v7; // [sp+Ch] [bp-4h]

  sub_141A4((_BYTE *)&dword_0 + 1);
  v0 = ep_list;
  if ( !ep_list )
  {
    sub_141A4(0);
    goto LABEL_17;
  }
  v1 = 0;
  do
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)(v0 + 144);
      if ( (v3 & 0x84) != 0 || *(_DWORD *)(v0 + 180) || (v3 & 8) == 0 )
        goto LABEL_4;
      if ( *(_WORD *)(v0 + 80) != 2 )
        sub_6ECC0("ntp_io.c", 2630, *(_DWORD *)(v0 + 180), "(2 == ((&interf->bcast)->sa.sa_family))");
      if ( (v3 & 0x20) != 0 )
      {
        ++v1;
        goto LABEL_4;
      }
      *(_WORD *)(v0 + 140) = 2;
      v4 = sub_154A8((struct sockaddr *)(v0 + 80), 1, 0, v0);
      *(_DWORD *)(v0 + 16) = v4;
      if ( v4 == -1 )
        break;
      ++v1;
      *(_DWORD *)(v0 + 144) |= 0x20u;
      v2 = sub_6C2E8((unsigned __int16 *)(v0 + 80));
      sub_64E00(
        6,
        "Listen for broadcasts to %s on interface #%d %s",
        v2,
        *(_DWORD *)(v0 + 20),
        (const char *)(v0 + 108));
LABEL_4:
      v0 = *(_DWORD *)v0;
      if ( !v0 )
        goto LABEL_14;
    }
    if ( (unsigned int)(*_errno_location() - 98) <= 1 )
      goto LABEL_4;
    v5 = sub_6C2E8((unsigned __int16 *)(v0 + 80));
    sub_64E00(
      6,
      "failed to listen for broadcasts to %s on interface #%d %s",
      v5,
      *(_DWORD *)(v0 + 20),
      (const char *)(v0 + 108));
    v0 = *(_DWORD *)v0;
  }
  while ( v0 );
LABEL_14:
  sub_141A4((char *)v0);
  if ( v1 )
  {
    broadcast_client_enabled = 1;
    return (char *)v7;
  }
LABEL_17:
  broadcast_client_enabled = 0;
  return sub_64E00(3, "Unable to listen for broadcasts, no broadcast interfaces available");
}
// 16368: variable 'v7' is possibly undefined
// 0: using guessed type int dword_0;
// 107D28: using guessed type int ep_list;
// 107D2C: using guessed type int broadcast_client_enabled;

//----- (0001640C) --------------------------------------------------------
int sub_1640C()
{
  int i; // r4
  int v1; // r3
  const char *v2; // r0
  int v4; // [sp+Ch] [bp-4h]

  for ( i = ep_list; i; i = *(_DWORD *)i )
  {
    v1 = *(_DWORD *)(i + 144);
    if ( (v1 & 0x80) == 0 && (v1 & 0x20) != 0 )
    {
      if ( *(_DWORD *)(i + 16) != -1 )
      {
        v2 = sub_6C2E8((unsigned __int16 *)(i + 80));
        sub_64E00(
          6,
          "stop listening for broadcasts to %s on interface #%d %s",
          v2,
          *(_DWORD *)(i + 20),
          (const char *)(i + 108));
        sub_15954(*(__int16 **)(i + 16));
        v1 = *(_DWORD *)(i + 144);
        *(_DWORD *)(i + 16) = -1;
      }
      *(_DWORD *)(i + 144) = v1 & 0xFFFFFFDF;
    }
  }
  broadcast_client_enabled = 0;
  return v4;
}
// 164BC: variable 'v4' is possibly undefined
// 107D28: using guessed type int ep_list;
// 107D2C: using guessed type int broadcast_client_enabled;

//----- (000164F4) --------------------------------------------------------
char *__fastcall sub_164F4(char *result)
{
  int v1; // r1
  char *v2; // r4
  int v3; // r3
  int v4; // r3
  _BYTE *v5; // r2
  int v6; // r0
  char *v7; // r1
  _DWORD *v8; // r6
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r3
  int v13; // r1
  int v14; // r2
  bool v15; // zf
  int v16; // r0
  int v17; // r2
  int v18; // r3
  const char *v19; // r7
  const char *v20; // r0
  int v21; // r3
  int v22; // r1
  int v23; // r2
  int v24; // r3
  int v25; // r1
  int v26; // r2
  const char *v27; // r0

  v1 = *(unsigned __int16 *)result;
  v2 = result;
  if ( v1 == 2 )
    v3 = *((_DWORD *)result + 1);
  else
    v3 = (unsigned __int8)result[8];
  if ( v1 == 2 )
    v4 = (v3 & 0xF0) - 224;
  else
    v4 = v3 - 255;
  if ( v4 )
    return result;
  if ( sub_15184(result) )
  {
    v5 = sub_6C2E8((unsigned __int16 *)v2);
    v6 = 6;
    v7 = "Duplicate request found for multicast address %s";
    return sub_64E00(v6, (unsigned __int8 *)v7, v5);
  }
  v8 = sub_13F3C(0);
  v9 = *((_DWORD *)v2 + 1);
  v10 = *((_DWORD *)v2 + 2);
  v11 = *((_DWORD *)v2 + 3);
  v8[6] = *(_DWORD *)v2;
  v8[7] = v9;
  v8[8] = v10;
  v8[9] = v11;
  v12 = *((unsigned __int16 *)v8 + 12);
  v13 = *((_DWORD *)v2 + 5);
  v14 = *((_DWORD *)v2 + 6);
  v15 = v12 == 10;
  v8[10] = *((_DWORD *)v2 + 4);
  v8[11] = v13;
  v8[12] = v14;
  if ( v12 == 10 )
    v14 = -1;
  *((_WORD *)v8 + 70) = v12;
  *((_WORD *)v8 + 26) = v12;
  if ( v12 == 10 )
  {
    v8[15] = v14;
    v8[16] = v14;
    v8[17] = v14;
    v8[18] = v14;
  }
  else
  {
    v12 = -1;
  }
  if ( !v15 )
    v8[14] = v12;
  *((_WORD *)v8 + 13) = 31488;
  sub_141A4((_BYTE *)&dword_0 + 1);
  v8[4] = -1;
  v16 = sub_154A8((struct sockaddr *)(v8 + 6), 0, 0, (int)v8);
  v8[3] = v16;
  if ( v16 != -1 )
  {
    v17 = v8[36];
    v18 = 0;
    v8[45] = 0;
    v8[36] = v17 | 0x100;
    if ( *(_WORD *)v2 != 2 )
      v18 = *((_DWORD *)v2 + 6);
    v8[44] = v18;
    sub_6D4DC((_BYTE *)v8 + 108, "multicast", 32);
    sub_14298((int)v8);
    sub_1482C((int)v8);
    goto LABEL_22;
  }
  free(v8);
  v21 = *(unsigned __int16 *)v2;
  if ( v21 == 2 )
  {
    v8 = (_DWORD *)dword_B92C8;
  }
  else
  {
    if ( v21 != 10 )
    {
LABEL_27:
      v5 = sub_6C2E8((unsigned __int16 *)v2);
      v6 = 3;
      v7 = "No multicast socket available to use for address %s";
      return sub_64E00(v6, (unsigned __int8 *)v7, v5);
    }
    v8 = (_DWORD *)dword_B92CC;
  }
  if ( !v8 )
    goto LABEL_27;
  v22 = *((_DWORD *)v2 + 1);
  v23 = *((_DWORD *)v2 + 2);
  v24 = *((_DWORD *)v2 + 3);
  v8[20] = *(_DWORD *)v2;
  v8[21] = v22;
  v8[22] = v23;
  v8[23] = v24;
  v25 = *((_DWORD *)v2 + 5);
  v26 = *((_DWORD *)v2 + 6);
  v8[24] = *((_DWORD *)v2 + 4);
  v8[25] = v25;
  v8[26] = v26;
  v27 = sub_6C2E8((unsigned __int16 *)v2);
  sub_64E00(3, "multicast address %s using wildcard interface #%d %s", v27, v8[5], (const char *)v8 + 108);
LABEL_22:
  if ( sub_148D0(v8, (unsigned __int16 *)v2) )
  {
    v19 = sub_6C2E8((unsigned __int16 *)v8 + 12);
    v20 = sub_6C2E8((unsigned __int16 *)v2);
    sub_64E00(6, "Joined %s socket to multicast group %s", v19, v20);
  }
  return (char *)sub_13EA4(v2, (int)v8);
}
// 0: using guessed type int dword_0;
// B92C8: using guessed type int dword_B92C8;
// B92CC: using guessed type int dword_B92CC;

//----- (000167AC) --------------------------------------------------------
void __fastcall sub_167AC(unsigned __int16 *s2)
{
  int v2; // r6
  int v3; // r3
  int v4; // r3
  int v5; // r4
  int v6; // r6
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int *v11; // r9
  int i; // r4
  _BOOL4 v13; // r3
  _DWORD *v14; // r0
  int v15; // r12
  int v16; // r0
  unsigned int v17; // r6
  unsigned int v18; // r4
  const char *v19; // r0
  const char *v20; // r0
  int v21; // r6
  _BYTE *v22; // r0
  int v23; // r4
  _BYTE *v24; // r0
  const char *v25; // [sp+18h] [bp-2Ch]
  _BYTE *v26; // [sp+18h] [bp-2Ch]
  int v27; // [sp+1Ch] [bp-28h]
  int v28; // [sp+20h] [bp-24h] BYREF
  int v29; // [sp+24h] [bp-20h]
  _DWORD optval[5]; // [sp+28h] [bp-1Ch] BYREF

  v2 = *s2;
  if ( v2 == 2 )
    v3 = *((_DWORD *)s2 + 1);
  else
    v3 = *((unsigned __int8 *)s2 + 8);
  if ( v2 == 2 )
    v4 = (v3 & 0xF0) - 224;
  else
    v4 = v3 - 255;
  if ( v4 )
  {
    v20 = sub_6C2E8(s2);
    sub_64E00(3, "invalid multicast address %s", v20);
    return;
  }
LABEL_8:
  while ( 1 )
  {
    v5 = sub_15184(s2);
    if ( !v5 )
      break;
    while ( 1 )
    {
      v28 = 0;
      v29 = 0;
      if ( !sub_13DC8(s2) )
        break;
      if ( v2 == 2 )
      {
        v15 = *(_DWORD *)(v5 + 28);
        v16 = *(_DWORD *)(v5 + 12);
        v28 = *((_DWORD *)s2 + 1);
        v29 = v15;
        if ( setsockopt(v16, 0, 36, &v28, 8u) )
        {
          v27 = *(_DWORD *)(v5 + 12);
          v25 = sub_6C2E8((unsigned __int16 *)(v5 + 24));
          v17 = bswap32(*(_DWORD *)(v5 + 28));
          v18 = bswap32(*((_DWORD *)s2 + 1));
          v19 = sub_6C2E8(s2);
          sub_64E00(
            3,
            "setsockopt IP_DROP_MEMBERSHIP failed: %m on socket %d, addr %s for %x / %x (%s)",
            v27,
            v25,
            v18,
            v17,
            v19);
          v2 = *s2;
          goto LABEL_8;
        }
      }
      else if ( v2 == 10 )
      {
        v6 = *(_DWORD *)(v5 + 12);
        v7 = *((_DWORD *)s2 + 3);
        v8 = *((_DWORD *)s2 + 4);
        v9 = *((_DWORD *)s2 + 5);
        optval[0] = *((_DWORD *)s2 + 2);
        optval[1] = v7;
        optval[2] = v8;
        optval[3] = v9;
        optval[4] = *(_DWORD *)(v5 + 176);
        if ( setsockopt(v6, 41, 21, optval, 0x14u) )
        {
          v21 = *(_DWORD *)(v5 + 12);
          v22 = sub_6C2E8((unsigned __int16 *)(v5 + 24));
          v23 = *(_DWORD *)(v5 + 176);
          v26 = v22;
          v24 = sub_6C2E8(s2);
          sub_64E00(3, "setsockopt IPV6_LEAVE_GROUP failure: %m on socket %d, addr %s for %d (%s)", v21, v26, v23, v24);
          v2 = *s2;
          goto LABEL_8;
        }
      }
      if ( (*(_DWORD *)(v5 + 156))-- == 1 )
        *(_DWORD *)(v5 + 144) &= ~0x40u;
      v5 = sub_15184(s2);
      v2 = *s2;
      if ( !v5 )
        goto LABEL_16;
    }
  }
LABEL_16:
  v11 = &remoteaddr_list;
  for ( i = remoteaddr_list; ; i = *(_DWORD *)i )
  {
    if ( *(unsigned __int16 *)(i + 4) != v2 )
      goto LABEL_17;
    if ( v2 == 2 )
    {
      v13 = *((_DWORD *)s2 + 1) != *(_DWORD *)(i + 8);
    }
    else
    {
      if ( memcmp(s2 + 4, (const void *)(i + 12), 0x10u) )
        goto LABEL_17;
      v13 = *((_DWORD *)s2 + 6) != *(_DWORD *)(i + 28);
    }
    if ( !v13 )
      break;
LABEL_17:
    if ( !*(_DWORD *)i )
      return;
    v11 = (int *)i;
  }
  v14 = (_DWORD *)*v11;
  *v11 = *(_DWORD *)*v11;
  free(v14);
}
// 107D20: using guessed type int remoteaddr_list;

//----- (00016A68) --------------------------------------------------------
int __fastcall sub_16A68(struct sockaddr *addr, int a2, int a3, unsigned int *buf, size_t n)
{
  int v7; // r7
  int result; // r0
  int sa_family; // r3
  int v11; // r2
  int v12; // r0
  int v13; // r3
  int v14; // r3
  socklen_t addr_len; // r12
  unsigned __int16 *v16; // r0
  const char *v17; // r0
  int optval; // [sp+34h] [bp-18h] BYREF
  char v19; // [sp+3Bh] [bp-11h] BYREF
  unsigned int v20[2]; // [sp+3Ch] [bp-10h] BYREF

  v7 = 0;
  result = 2092;
  sa_family = addr->sa_family;
  optval = a3;
  v20[0] = 0;
  v20[1] = 0;
  if ( sa_family == 2 )
  {
    if ( (*(_DWORD *)&addr->sa_data[2] & 0xF0) == 0xE0 )
    {
      v7 = 1;
      a2 = mc4_list;
    }
  }
  else if ( (unsigned __int8)addr->sa_data[6] == 255 )
  {
    v7 = 1;
    a2 = mc6_list;
  }
  if ( !a2 )
    return result;
  do
  {
    v11 = optval;
    v12 = *(_DWORD *)(a2 + 12);
    if ( optval > 0 )
      v13 = v7;
    else
      v13 = 0;
    if ( v13 && optval != *(_DWORD *)(a2 + 148) )
    {
      v14 = *(unsigned __int16 *)(a2 + 24);
      if ( v14 == 2 )
      {
        v19 = optval;
        if ( !setsockopt(v12, 0, 33, &v19, 1u) )
          goto LABEL_13;
      }
      else
      {
        if ( v14 != 10 )
          goto LABEL_14;
        if ( !setsockopt(v12, 41, 18, &optval, 4u) )
        {
LABEL_13:
          v11 = optval;
          v12 = *(_DWORD *)(a2 + 12);
LABEL_14:
          *(_DWORD *)(a2 + 148) = v11;
          goto LABEL_15;
        }
      }
      v17 = sub_6C2E8((unsigned __int16 *)(a2 + 24));
      sub_64E00(3, "setsockopt IP_MULTICAST_TTL/IPV6_MULTICAST_HOPS fails on address %s: %m", v17);
      v12 = *(_DWORD *)(a2 + 12);
    }
LABEL_15:
    if ( addr->sa_family == 2 )
      addr_len = 16;
    else
      addr_len = 28;
    if ( sendto(v12, buf, n, 0, addr, addr_len) == -1 )
    {
      ++*(_DWORD *)(a2 + 172);
      ++packets_notsent;
    }
    else
    {
      ++*(_DWORD *)(a2 + 168);
      ++packets_sent;
    }
    if ( !v7 )
    {
      v16 = (unsigned __int16 *)(a2 + 24);
      return sub_420F0(
               v16,
               &addr->sa_family,
               buf + 6,
               buf + 8,
               buf + 10,
               v20,
               *(_BYTE *)buf & 7,
               (*(unsigned __int8 *)buf >> 3) & 7,
               *(unsigned __int8 *)buf >> 6,
               *((unsigned __int8 *)buf + 1),
               *((unsigned __int8 *)buf + 2),
               *((char *)buf + 3),
               buf[3],
               n - 48,
               (int)(buf + 12));
    }
    a2 = *(_DWORD *)(a2 + 4);
  }
  while ( a2 );
  v16 = 0;
  return sub_420F0(
           v16,
           &addr->sa_family,
           buf + 6,
           buf + 8,
           buf + 10,
           v20,
           *(_BYTE *)buf & 7,
           (*(unsigned __int8 *)buf >> 3) & 7,
           *(unsigned __int8 *)buf >> 6,
           *((unsigned __int8 *)buf + 1),
           *((unsigned __int8 *)buf + 2),
           *((char *)buf + 3),
           buf[3],
           n - 48,
           (int)(buf + 12));
}
// 16AE8: masking with 0x1 was optimized away because r7.4 <= 0x1
// 107D04: using guessed type int mc4_list;
// 107D08: using guessed type int packets_sent;
// 107D1C: using guessed type int mc6_list;
// 107D34: using guessed type int packets_notsent;

//----- (00016D04) --------------------------------------------------------
char *sub_16D04()
{
  char *result; // r0
  int v1; // r6
  __suseconds_t tv_usec; // r1
  int v3; // r2
  _DWORD *v4; // r6
  int v5; // r4
  int v6; // r3
  int v7; // r9
  size_t v8; // r5
  int *v9; // r0
  int v10; // r2
  ssize_t v11; // r0
  ssize_t v12; // r7
  int v13; // r2
  __time_t tv_sec; // r0
  __suseconds_t v15; // r1
  int v16; // r2
  int v17; // r8
  size_t v18; // r5
  int *v19; // r0
  int v20; // r2
  ssize_t v21; // r0
  ssize_t v22; // r3
  int v23; // r2
  __time_t v24; // r0
  __suseconds_t v25; // r1
  int v26; // r2
  int *v27; // r3
  int *v28; // r0
  int v29; // r7
  int *v30; // r5
  const char *v31; // r0
  _DWORD *v32; // r4
  int v33; // r6
  int v34; // r5
  int v35; // r7
  int *v36; // r3
  int v37; // r4
  int v38; // r5
  int v39; // r0
  bool v40; // nf
  int v41; // r3
  unsigned int v42; // r4
  int v43; // r5
  int v44; // r0
  int v45; // r3
  int v46; // r1
  int v47; // r8
  int v48; // r2
  int v49; // r9
  char *v50; // r3
  char *v51; // r11
  int v52; // r0
  char v53; // r3
  __int16 *v54; // r3
  int v55; // r7
  int v56; // r1
  int v57; // r2
  int v58; // r6
  int v59; // r11
  int v60; // r0
  int v61; // r4
  int v62; // r1
  int v63; // r2
  int v64; // r0
  const char *v65; // r0
  int v66; // [sp+8h] [bp-574h]
  int v67; // [sp+10h] [bp-56Ch]
  int *v68; // [sp+10h] [bp-56Ch]
  int v69; // [sp+10h] [bp-56Ch]
  int *v70; // [sp+14h] [bp-568h]
  int *v71; // [sp+14h] [bp-568h]
  struct timeval v72; // [sp+24h] [bp-558h] BYREF
  struct timeval v73; // [sp+2Ch] [bp-550h]
  struct timeval v74; // [sp+34h] [bp-548h]
  struct timeval timeout; // [sp+3Ch] [bp-540h] BYREF
  fd_set dest; // [sp+44h] [bp-538h] BYREF
  _BYTE v77[1208]; // [sp+C4h] [bp-4B8h] BYREF

  ++handler_calls;
  memcpy(&dest, &unk_B9244, sizeof(dest));
  result = (char *)select(dword_B92C4 + 1, &dest, 0, 0, 0);
  v1 = (int)result;
  if ( (int)result >= 0 )
    goto LABEL_2;
  result = (char *)_errno_location();
  v47 = *(_DWORD *)result;
  if ( *(_DWORD *)result == 4 )
    goto LABEL_3;
  v48 = dword_B92C4 + 1;
  v49 = dword_B92C4 >= 255 ? 255 : dword_B92C4;
  v66 = dword_B92C4 + 1;
  v69 = v49;
  if ( dword_B92C4 >= 0 )
  {
    v51 = byte_B92D0;
    do
    {
      v52 = _fdelt_chk(v49, v46, v48);
      v48 = v49-- & 0x1F;
      if ( (*(_DWORD *)&word_B9240[2 * v52 + 2] & (1 << v48)) != 0 )
        v53 = 35;
      else
        v53 = 45;
      *v51++ = v53;
    }
    while ( v49 != -1 );
    v54 = word_B9240;
    if ( v69 >= 0 )
      v54 = (__int16 *)((char *)word_B9240 + v69);
    v50 = (char *)v54 + 145;
  }
  else
  {
    v50 = byte_B92D0;
  }
  v55 = 0;
  *v50 = 0;
  result = sub_64E00(3, "select(%d, %s, 0L, 0L, &0.0) error: %m", v66, byte_B92D0);
  if ( v47 != 9 )
    goto LABEL_3;
  if ( dword_B92C4 >= 0 )
  {
    v59 = 0;
    do
    {
      v60 = _fdelt_chk(v59, v56, v57);
      v57 = v59 & 0x1F;
      v61 = 1 << (v59 & 0x1F);
      if ( (v61 & *(_DWORD *)&word_B9240[2 * v60 + 2]) != 0 )
      {
        if ( read(v59, &timeout, 0) == -1 )
        {
          sub_64E00(3, "Removing bad file descriptor %d from select set", v59);
          v64 = _fdelt_chk(v59, v62, v63);
          *(_DWORD *)&word_B9240[2 * v64 + 2] &= ~v61;
        }
        else
        {
          v55 = v59;
        }
      }
      ++v59;
    }
    while ( v59 <= dword_B92C4 );
    v58 = v55 + 1;
    if ( dword_B92C4 == v55 )
      goto LABEL_99;
  }
  else
  {
    v58 = 1;
  }
  dword_B92C4 = v55;
LABEL_99:
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  memcpy(&dest, &unk_B9244, sizeof(dest));
  result = (char *)select(v58, &dest, 0, 0, &timeout);
  v1 = (int)result;
LABEL_2:
  if ( v1 <= 0 )
  {
LABEL_3:
    if ( v1 == -1 )
    {
      result = (char *)_errno_location();
      if ( *(_DWORD *)result != 4 )
        return sub_64E00(3, "select() error: %m");
    }
    return result;
  }
  sub_5F724(&v72.tv_sec);
  result = (char *)v72.tv_sec;
  tv_usec = v72.tv_usec;
  v3 = (int)&handler_pkts;
  v4 = (_DWORD *)dword_B93D0;
  v73 = v72;
  ++handler_pkts;
  if ( !dword_B93D0 )
    goto LABEL_35;
  while ( 1 )
  {
    while ( 1 )
    {
LABEL_6:
      v5 = v4[5];
      result = &v77[4 * _fdelt_chk(v5, tv_usec, v3) + 1204];
      LOBYTE(v6) = v5 & 0x1F;
      if ( v5 <= 0 )
        v6 = -(-v5 & 0x1F);
      tv_usec = *((_DWORD *)result - 333);
      v3 = 1;
      if ( (tv_usec & (1 << v6)) != 0 )
        break;
LABEL_34:
      v4 = (_DWORD *)*v4;
      if ( !v4 )
        goto LABEL_35;
    }
    v74 = v73;
    v7 = sub_6A108();
    if ( v7 )
      break;
    v12 = read(v5, v77, 0x4B0u);
    ++packets_dropped;
LABEL_31:
    if ( v12 < 0 )
    {
      v28 = _errno_location();
      v29 = *v28;
      v30 = v28;
      if ( *v28 == 11 )
        goto LABEL_18;
      v31 = sub_6A3FC((unsigned __int16 *)(v4[3] + 16));
      *v30 = v29;
      sub_64E00(3, "%s read: %m", v31);
      result = (char *)sub_15274(v5, 1);
      goto LABEL_34;
    }
    if ( v12 )
      goto LABEL_18;
    v65 = sub_6A3FC((unsigned __int16 *)(v4[3] + 16));
    sub_64E00(3, "%s read EOF", v65);
    result = (char *)sub_15274(v5, 1);
    v4 = (_DWORD *)*v4;
    if ( !v4 )
      goto LABEL_35;
  }
  v8 = v4[4];
  if ( v8 - 1 > 0x847 )
    v8 = 2120;
  while ( 1 )
  {
    v11 = read(v5, (void *)(v7 + 88), v8);
    v12 = v11;
    if ( v11 >= 0 )
      break;
    v9 = _errno_location();
    v10 = *v9;
    if ( *v9 != 4 )
    {
      v27 = v9;
LABEL_30:
      v67 = v10;
      v70 = v27;
      sub_69FA8((char *)v7);
      *v70 = v67;
      goto LABEL_31;
    }
  }
  if ( !v11 )
  {
    v27 = _errno_location();
    v10 = *v27;
    goto LABEL_30;
  }
  v13 = v4[3];
  tv_sec = v74.tv_sec;
  v15 = v74.tv_usec;
  *(_DWORD *)(v7 + 84) = v12;
  *(_DWORD *)(v7 + 4) = v13;
  v16 = v4[1];
  *(_DWORD *)(v7 + 64) = v5;
  *(_DWORD *)(v7 + 60) = 0;
  *(_DWORD *)(v7 + 72) = tv_sec;
  *(_DWORD *)(v7 + 76) = v15;
  *(_DWORD *)(v7 + 80) = v16;
  if ( !sub_3A02C((int)v4, (char *)v7) )
  {
    ++v4[6];
    ++packets_received;
  }
LABEL_18:
  while ( 2 )
  {
    while ( 1 )
    {
      timeout = v73;
      v17 = sub_6A108();
      if ( v17 )
        break;
      result = (char *)read(v5, v77, 0x4B0u);
      v3 = (int)&packets_dropped;
      ++packets_dropped;
      if ( (int)result <= 0 )
        goto LABEL_34;
    }
    v18 = v4[4];
    if ( v18 - 1 > 0x847 )
      v18 = 2120;
    while ( 1 )
    {
      v21 = read(v5, (void *)(v17 + 88), v18);
      if ( v21 >= 0 )
        break;
      v19 = _errno_location();
      v20 = *v19;
      if ( *v19 != 4 )
      {
        v36 = v19;
        goto LABEL_48;
      }
    }
    v22 = v21;
    if ( v21 )
    {
      v23 = v4[3];
      v24 = timeout.tv_sec;
      v25 = timeout.tv_usec;
      *(_DWORD *)(v17 + 84) = v22;
      *(_DWORD *)(v17 + 4) = v23;
      v26 = v4[1];
      *(_DWORD *)(v17 + 64) = v5;
      *(_DWORD *)(v17 + 60) = 0;
      *(_DWORD *)(v17 + 72) = v24;
      *(_DWORD *)(v17 + 76) = v25;
      *(_DWORD *)(v17 + 80) = v26;
      if ( !sub_3A02C((int)v4, (char *)v17) )
      {
        ++v4[6];
        ++packets_received;
      }
      continue;
    }
    break;
  }
  v36 = _errno_location();
  v20 = *v36;
LABEL_48:
  v68 = (int *)v20;
  v71 = v36;
  result = sub_69FA8((char *)v17);
  v4 = (_DWORD *)*v4;
  v3 = (int)v68;
  *v71 = (int)v68;
  if ( v4 )
    goto LABEL_6;
LABEL_35:
  v32 = (_DWORD *)ep_list;
  if ( !ep_list )
    goto LABEL_52;
  while ( 2 )
  {
    v33 = 0;
    while ( 2 )
    {
      if ( !v33 )
      {
        v34 = v32[3];
        v35 = 1;
        if ( v34 >= 0 )
          goto LABEL_42;
        goto LABEL_44;
      }
      if ( (v32[36] & 0x20) == 0 )
        break;
      v34 = v32[4];
      v35 = v33 + 1;
      if ( v34 >= 0 )
      {
LABEL_42:
        result = &v77[4 * _fdelt_chk(v34, tv_usec, v3) + 1204];
        v3 = *((_DWORD *)result - 333);
        if ( (v3 & (1 << (v34 & 0x1F))) != 0 )
        {
          do
            result = (char *)sub_14C78(v34, (int)v32, v73.tv_sec, v73.tv_usec);
          while ( (int)result > 0 );
        }
      }
      if ( v35 != 2 )
      {
LABEL_44:
        ++v33;
        continue;
      }
      break;
    }
    v32 = (_DWORD *)*v32;
    if ( v32 )
      continue;
    break;
  }
LABEL_52:
  v37 = asyncio_reader_list;
  if ( asyncio_reader_list )
  {
    do
    {
      v38 = *(_DWORD *)v37;
      v39 = _fdelt_chk(*(_DWORD *)(v37 + 4), tv_usec, v3);
      v41 = *(_DWORD *)(v37 + 4);
      result = &v77[4 * v39 + 1204];
      v40 = -v41 < 0;
      tv_usec = *((_DWORD *)result - 333);
      v3 = -v41 & 0x1F;
      LOBYTE(v41) = v41 & 0x1F;
      if ( !v40 )
        v41 = -v3;
      if ( (tv_usec & (1 << v41)) != 0 )
        result = (char *)(*(int (__fastcall **)(int))(v37 + 12))(v37);
      v37 = v38;
    }
    while ( v38 );
  }
  if ( blocking_children_alloc )
  {
    v42 = 0;
    do
    {
      v43 = *(_DWORD *)(blocking_children + 4 * v42);
      if ( v43 )
      {
        result = *(char **)(v43 + 52);
        if ( result != (char *)-1 )
        {
          v44 = _fdelt_chk(result, tv_usec, v3);
          v45 = *(_DWORD *)(v43 + 52);
          result = &v77[4 * v44 + 1204];
          v40 = -v45 < 0;
          tv_usec = *((_DWORD *)result - 333);
          v3 = -v45 & 0x1F;
          LOBYTE(v45) = v45 & 0x1F;
          if ( !v40 )
            v45 = -v3;
          if ( (tv_usec & (1 << v45)) != 0 )
          {
            ++*(_DWORD *)(v43 + 68);
            v3 = (int)&blocking_child_ready_seen;
            ++blocking_child_ready_seen;
          }
        }
      }
      ++v42;
    }
    while ( v42 < blocking_children_alloc );
  }
  return result;
}
// 16E10: variable 'tv_usec' is possibly undefined
// 16E10: variable 'v3' is possibly undefined
// 172BC: variable 'v46' is possibly undefined
// 1737C: variable 'v56' is possibly undefined
// 1737C: variable 'v57' is possibly undefined
// 173C8: variable 'v62' is possibly undefined
// 173C8: variable 'v63' is possibly undefined
// C0E8: using guessed type int __fastcall _fdelt_chk(_DWORD, _DWORD, _DWORD);
// B9240: using guessed type __int16 word_B9240[];
// B92C4: using guessed type int dword_B92C4;
// B93D0: using guessed type int dword_B93D0;
// 107CFC: using guessed type int packets_received;
// 107D0C: using guessed type int asyncio_reader_list;
// 107D18: using guessed type int handler_calls;
// 107D28: using guessed type int ep_list;
// 107D3C: using guessed type int handler_pkts;
// 107D40: using guessed type int packets_dropped;
// 109598: using guessed type int blocking_children_alloc;
// 1095A4: using guessed type int blocking_child_ready_seen;
// 1095A8: using guessed type int blocking_children;

//----- (0001753C) --------------------------------------------------------
int __fastcall sub_1753C(_DWORD *a1, int a2)
{
  int result; // r0

  result = sub_13DC8(a1);
  if ( result )
  {
    if ( (a2 & *(_DWORD *)(result + 144)) != 0 )
      return 0;
  }
  return result;
}

//----- (0001759C) --------------------------------------------------------
char *__fastcall sub_1759C(const struct sockaddr *a1, int a2, int a3)
{
  _BYTE *v3; // r11
  int sa_family; // r0
  int v8; // r0
  int v9; // r5
  socklen_t v10; // r2
  int v11; // r9
  char *v12; // r0
  char *v13; // lr
  int v14; // r12
  int v15; // r3
  int v16; // r2
  int v17; // r1
  bool v18; // zf
  unsigned int v19; // r10
  unsigned int v20; // t1
  char v21; // r3
  unsigned int v22; // t1
  bool v23; // cc
  char *v24; // r1
  char v25; // t1
  char v26; // t1
  char v27; // r3
  _BYTE *v28; // r10
  _BYTE *v29; // r3
  char *v30; // r2
  char *v31; // t1
  unsigned int v32; // t1
  bool v33; // cc
  unsigned int v35; // r2
  unsigned int v36; // r3
  unsigned int v37; // r3
  socklen_t len; // [sp+8h] [bp-64h] BYREF
  int v39; // [sp+Ch] [bp-60h] BYREF
  struct sockaddr addr; // [sp+10h] [bp-5Ch] BYREF
  _BYTE v41[28]; // [sp+2Ch] [bp-40h] BYREF
  __int64 v42; // [sp+48h] [bp-24h] BYREF
  __int64 v43; // [sp+50h] [bp-1Ch]
  int v44; // [sp+58h] [bp-14h]
  int v45; // [sp+5Ch] [bp-10h]
  int v46; // [sp+60h] [bp-Ch]

  sa_family = a1->sa_family;
  if ( !sa_family )
    return 0;
  v8 = socket(sa_family, 2, 0);
  v9 = v8;
  if ( v8 == -1 )
    return 0;
  if ( a3 && (v39 = 1, setsockopt(v8, 1, 6, &v39, 4u) == -1)
    || (a1->sa_family == 2 ? (v10 = 16) : (v10 = 28), connect(v9, a1, v10) == -1) )
  {
    close(v9);
    return 0;
  }
  len = 28;
  v11 = getsockname(v9, &addr, &len);
  close(v9);
  if ( v11 == -1 )
    return 0;
  v12 = (char *)sub_1753C(&addr, a2);
  v13 = v12;
  if ( !v12 || *((_DWORD *)v12 + 45) )
  {
    v13 = 0;
    v42 = 0;
    v43 = 0;
    v44 = 0;
    v45 = 0;
    v46 = 0;
    v14 = ep_list;
    if ( !ep_list )
      return 0;
    while ( 1 )
    {
      if ( *(_DWORD *)(v14 + 180) )
        goto LABEL_40;
      v15 = *(unsigned __int16 *)(v14 + 140);
      if ( v15 != addr.sa_family )
        goto LABEL_40;
      v16 = *(_DWORD *)(v14 + 144) & 0x84;
      if ( v16 )
        goto LABEL_40;
      v17 = *(unsigned __int16 *)(v14 + 24);
      if ( v17 != v15 )
        sub_6ECC0("ntp_io.c", 4158, 0, "((a1)->sa.sa_family) == ((a2)->sa.sa_family)");
      v18 = v17 == 2;
      *(_WORD *)v41 = *(_WORD *)(v14 + 24);
      *(_DWORD *)&v41[2] = 0;
      if ( v17 != 2 )
        v12 = &addr.sa_data[5];
      *(_DWORD *)&v41[6] = 0;
      if ( v17 != 2 )
        v17 = v14 + 31;
      *(_DWORD *)&v41[10] = 0;
      if ( !v18 )
        v3 = &v41[7];
      memset(&v41[14], 0, 14);
      if ( v18 )
      {
        v35 = bswap32(*(unsigned int *)&addr.sa_data[2]);
        v36 = bswap32(*(_DWORD *)(v14 + 28));
        if ( v35 <= v36 )
          v37 = v36 - v35;
        else
          v37 = v35 - v36;
        *(_DWORD *)&v41[4] = bswap32(v37);
      }
      else
      {
        while ( 1 )
        {
          v20 = (unsigned __int8)*++v12;
          v19 = v20;
          v22 = *(unsigned __int8 *)++v17;
          v21 = v22;
          v23 = v19 > v22;
          if ( v19 != v22 )
            break;
          ++v16;
          *++v3 = 0;
          if ( v16 == 16 )
            goto LABEL_32;
        }
        v12 = (char *)(v14 + v16 + 33);
        v24 = &addr.sa_data[v16 + 6];
        v3 = (_BYTE *)v23;
        while ( 1 )
        {
          v27 = v3 ? v19 - v21 : v21 - v19;
          v28 = &v41[v16++];
          v28[8] = v27;
          if ( v16 > 15 )
            break;
          v25 = *v12++;
          v21 = v25;
          v26 = *++v24;
          LOBYTE(v19) = v26;
        }
      }
LABEL_32:
      if ( !v13 )
        goto LABEL_50;
      if ( (unsigned __int16)v42 != *(unsigned __int16 *)v41 )
        sub_6ECC0("ntp_io.c", 4209, 0, "((d1)->sa.sa_family) == ((d2)->sa.sa_family)");
      if ( (unsigned __int16)v42 != 2 )
      {
        v29 = &v41[7];
        v30 = (char *)&v42 + 7;
        while ( 1 )
        {
          v31 = (char *)(unsigned __int8)*++v29;
          v12 = v31;
          v32 = (unsigned __int8)*++v30;
          v33 = (unsigned int)v12 > v32;
          if ( (unsigned int)v12 < v32 )
            goto LABEL_50;
          if ( v33 || v29 == &v41[23] )
            goto LABEL_40;
        }
      }
      if ( bswap32(*(unsigned int *)&v41[4]) >= bswap32(HIDWORD(v42)) )
      {
LABEL_40:
        v14 = *(_DWORD *)v14;
        if ( !v14 )
          goto LABEL_41;
      }
      else
      {
LABEL_50:
        v3 = &v41[16];
        v13 = (char *)v14;
        v14 = *(_DWORD *)v14;
        v42 = *(_QWORD *)v41;
        v43 = *(_QWORD *)&v41[8];
        v12 = *(char **)&v41[16];
        v44 = *(_DWORD *)&v41[16];
        v45 = *(_DWORD *)&v41[20];
        v46 = *(_DWORD *)&v41[24];
        if ( !v14 )
        {
LABEL_41:
          if ( v13 && !*((_DWORD *)v13 + 45) )
            return v13;
          return 0;
        }
      }
    }
  }
  return v13;
}
// 177F4: variable 'v3' is possibly undefined
// 107D28: using guessed type int ep_list;

//----- (000178F8) --------------------------------------------------------
char *__fastcall sub_178F8(const struct sockaddr *a1)
{
  char *result; // r0
  int *v3; // r3

  result = sub_1759C(a1, 128, 0);
  if ( !result )
  {
    if ( a1->sa_family == 2 )
      v3 = &any_interface;
    else
      v3 = &any6_interface;
    return (char *)*v3;
  }
  return result;
}
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;

//----- (00017984) --------------------------------------------------------
int __fastcall sub_17984(void (__fastcall *a1)(int, _DWORD **), int a2)
{
  unsigned int v4; // r12
  int v5; // r11
  int v6; // r0
  int v7; // r5
  int v8; // r0
  int v9; // r6
  int *v10; // r1
  int *v11; // r3
  int *v12; // r3
  int *v13; // r3
  int v14; // r1
  int v15; // r3
  int *v16; // r0
  int *v17; // r3
  int *v18; // r2
  _BYTE *v19; // r0
  const char *v20; // r0
  int v21; // r1
  int v22; // r3
  bool v23; // zf
  char *v24; // r0
  int i; // r6
  int v26; // r3
  unsigned __int16 *v27; // r5
  const char *v28; // r8
  const char *v29; // r0
  int v30; // r3
  int v31; // r0
  int v32; // r11
  int v33; // r3
  const char *v34; // r0
  _DWORD *v35; // r8
  unsigned __int16 *v36; // r10
  int v37; // r0
  int v38; // r1
  const char *v39; // r0
  int v40; // r3
  bool v41; // zf
  int v42; // r11
  _BYTE *v43; // r0
  _BYTE *v44; // r0
  int v45; // [sp+18h] [bp-1A4h]
  int v47; // [sp+24h] [bp-198h]
  int v48; // [sp+30h] [bp-18Ch] BYREF
  _DWORD *v49; // [sp+34h] [bp-188h] BYREF
  char v50; // [sp+38h] [bp-184h]
  __int16 v51; // [sp+3Ch] [bp-180h] BYREF
  _QWORD v52[3]; // [sp+3Eh] [bp-17Eh] BYREF
  __int16 v53; // [sp+56h] [bp-166h]
  unsigned __int8 dest[32]; // [sp+58h] [bp-164h] BYREF
  int v55; // [sp+78h] [bp-144h]
  int v56; // [sp+7Ch] [bp-140h]
  unsigned int v57; // [sp+80h] [bp-13Ch]
  int v58; // [sp+84h] [bp-138h]
  int v59; // [sp+88h] [bp-134h]
  int v60; // [sp+8Ch] [bp-130h]
  int v61; // [sp+90h] [bp-12Ch]
  int v62; // [sp+98h] [bp-124h]
  int v63; // [sp+9Ch] [bp-120h]
  int v64; // [sp+A0h] [bp-11Ch]
  int v65; // [sp+A4h] [bp-118h]
  int v66; // [sp+B0h] [bp-10Ch]
  int v67; // [sp+DCh] [bp-E0h]
  int v68; // [sp+E0h] [bp-DCh]
  _DWORD s[48]; // [sp+E4h] [bp-D8h] BYREF
  int v70; // [sp+1A4h] [bp-18h]
  int v71; // [sp+1A8h] [bp-14h]
  int v72; // [sp+1ACh] [bp-10h]
  int v73; // [sp+1B0h] [bp-Ch]

  v48 = 0;
  if ( sub_6FD38(-1, &v48) )
    return 0;
  word_B9240[0] ^= 1u;
  if ( !sub_70050((_DWORD *)v48) )
  {
    v45 = 0;
    while ( 1 )
    {
      if ( sub_6FFC4(v48, dest) )
        goto LABEL_27;
      if ( (v56 & 0xFFFFFFF7) == 2 )
        break;
LABEL_26:
      if ( sub_70164((_DWORD *)v48) )
        goto LABEL_27;
    }
    if ( v56 == 2 )
    {
      if ( !ipv4_works )
        goto LABEL_26;
    }
    else if ( v56 == 10 && !ipv6_works )
    {
      goto LABEL_26;
    }
    memset(s, 0, sizeof(s));
    v73 = 0x1000000;
    v70 = 0;
    v71 = 0;
    v72 = 0;
    HIWORD(s[35]) = word_B9240[0];
    s[3] = -1;
    s[4] = -1;
    sub_6D4DC(&s[27], dest, 32);
    HIWORD(s[6]) = 31488;
    s[44] = v68;
    HIWORD(s[13]) = 31488;
    HIWORD(s[20]) = 31488;
    LOWORD(s[35]) = v55;
    LOWORD(s[6]) = v55;
    LOWORD(s[13]) = v55;
    LOWORD(s[20]) = v55;
    if ( (unsigned __int16)v55 == 2 )
    {
      s[7] = v57;
      s[14] = v62;
      v30 = (16 * (_WORD)v67) & 0x200 | v67 & 0x17;
      if ( (v67 & 8) != 0 )
      {
        v4 = s[36] | 8 | v30;
        s[36] = v4;
        s[21] = v66;
        if ( (v4 & 4) == 0 )
          goto LABEL_17;
      }
      else
      {
        v4 = s[36] | v30;
        s[36] = v4;
        if ( (v4 & 4) == 0 )
          goto LABEL_17;
      }
      if ( bswap32(v57) >> 24 != 127 )
        goto LABEL_16;
    }
    else
    {
      v4 = (16 * (_WORD)v67) & 0x200 | v67 & 0x17 | s[36];
      v5 = v67 & 4 | s[36] & 4;
      if ( (unsigned __int16)v55 == 10 )
      {
        s[36] |= (16 * (_WORD)v67) & 0x200 | v67 & 0x17;
        s[8] = v57;
        s[9] = v58;
        s[10] = v59;
        s[11] = v60;
        s[12] = v61;
        s[15] = v62;
        s[16] = v63;
        s[17] = v64;
        s[18] = v65;
        if ( !v5 )
          goto LABEL_17;
        if ( v70 != s[8] )
          goto LABEL_16;
      }
      else
      {
        s[36] |= (16 * (_WORD)v67) & 0x200 | v67 & 0x17;
        if ( !v5 )
        {
LABEL_17:
          v6 = sub_149CC((const char *)&s[27], (unsigned __int16 *)&s[6], v4);
          if ( v6 == 1 )
            goto LABEL_26;
          if ( v6 )
          {
            if ( v6 == 2 )
              s[45] = 1;
          }
          else
          {
            s[45] = 0;
          }
          if ( (s[36] & 1) == 0 || sub_13D38((unsigned __int16 *)&s[6]) || LOWORD(s[6]) != 2 && LOWORD(s[6]) != 10 )
            goto LABEL_26;
          v31 = sub_1753C(&s[6], 128);
          v32 = v31;
          if ( v31 && *(_DWORD *)(v31 + 12) != -1 )
          {
            if ( *(unsigned __int16 *)(v31 + 142) == (unsigned __int16)word_B9240[0] )
            {
              sub_6D4DC((_BYTE *)(v31 + 108), "*multiple*", 32);
              v33 = *(_DWORD *)(v32 + 180);
            }
            else
            {
              sub_6D4DC((_BYTE *)(v31 + 108), (unsigned __int8 *)&s[27], 32);
              v33 = s[45];
              *(_DWORD *)(v32 + 180) = s[45];
            }
            if ( s[45] != v33 )
            {
              v34 = sub_6C2E8((unsigned __int16 *)&s[6]);
              sub_64E00(
                3,
                "WARNING: conflicting enable configuration for interfaces %s and %s for address %s - unsupported configur"
                "ation - address DISABLED",
                (const char *)&s[27],
                (const char *)(v32 + 108),
                v34);
              *(_DWORD *)(v32 + 180) = 1;
            }
            v49 = (_DWORD *)v32;
            v50 = 1;
            *(_WORD *)(v32 + 142) = word_B9240[0];
            if ( a1 )
              a1(a2, &v49);
            goto LABEL_26;
          }
          v35 = sub_13F3C(s);
          v36 = (unsigned __int16 *)(v35 + 6);
          v37 = sub_154A8((struct sockaddr *)(v35 + 6), 0, 0, (int)v35);
          v35[3] = v37;
          if ( v37 == -1 )
          {
            if ( (v35[36] & 8) == 0 )
              goto LABEL_120;
            if ( v35[4] == -1 )
            {
LABEL_135:
              v42 = v35[5];
              v43 = sub_6C2E8(v36);
              sub_64E00(3, "unable to create socket on %s (%d) for %s#%d", v35 + 27, v42, v43, 123);
              free(v35);
              v44 = sub_6C2E8((unsigned __int16 *)&s[6]);
              sub_64E00(6, "failed to init interface for address %s", v44);
              goto LABEL_26;
            }
          }
          else
          {
            sub_1482C((int)v35);
            if ( (v35[36] & 8) == 0 )
            {
LABEL_119:
              if ( v35[3] != -1 )
                goto LABEL_121;
LABEL_120:
              if ( v35[4] != -1 )
                goto LABEL_121;
              goto LABEL_135;
            }
            if ( v35[4] == -1 )
            {
              if ( v35[3] != -1 )
              {
LABEL_121:
                memset(v52, 0, sizeof(v52));
                v53 = 0;
                v40 = *((unsigned __int16 *)v35 + 12);
                v41 = v40 == 10;
                v51 = *((_WORD *)v35 + 12);
                if ( v40 == 10 )
                  v38 = -1;
                else
                  v40 = -1;
                if ( v41 )
                {
                  *(_DWORD *)((char *)&v52[1] + 2) = v38;
                  *(_DWORD *)((char *)v52 + 6) = v38;
                  *(_DWORD *)((char *)&v52[1] + 6) = v38;
                  *(_DWORD *)((char *)&v52[2] + 2) = v38;
                }
                else
                {
                  *(_DWORD *)((char *)v52 + 2) = v40;
                }
                sub_40238(1, v36, &v51, -4, 0x3000u, 1, 0);
                if ( !loopback_interface && *((_WORD *)v35 + 70) == 2 && (v35[36] & 4) != 0 )
                  loopback_interface = (int)v35;
                sub_13EA4(v36, (int)v35);
                sub_14298((int)v35);
                v49 = v35;
                v50 = 2;
                if ( a1 )
                  a1(a2, &v49);
                v45 = 1;
                goto LABEL_26;
              }
              goto LABEL_135;
            }
          }
          v39 = sub_6C2E8((unsigned __int16 *)v35 + 40);
          sub_64E00(6, "Listening on broadcast address %s#%d", v39, 123);
          goto LABEL_119;
        }
        if ( v70 != s[8] )
        {
LABEL_16:
          v4 &= ~4u;
          s[36] = v4;
          goto LABEL_17;
        }
      }
      if ( v71 != s[9] || v72 != s[10] || v73 != s[11] )
        goto LABEL_16;
    }
    v4 = s[36];
    goto LABEL_17;
  }
  v45 = 0;
LABEL_27:
  sub_70284((_DWORD **)&v48);
  v7 = ep_list;
  if ( !ep_list )
    goto LABEL_78;
  do
  {
    v8 = *(_DWORD *)(v7 + 144);
    v9 = *(_DWORD *)v7;
    if ( (v8 & 0x180) != 0 || *(unsigned __int16 *)(v7 + 142) == (unsigned __int16)word_B9240[0] )
      goto LABEL_77;
    v10 = (int *)ep_list;
    if ( ep_list == v7 )
    {
      v12 = (int *)v7;
      v10 = &ep_list;
LABEL_38:
      *v10 = *v12;
      goto LABEL_39;
    }
    if ( ep_list )
    {
      v11 = *(int **)ep_list;
      if ( *(_DWORD *)ep_list )
      {
        while ( (int *)v7 != v11 )
        {
          v10 = v11;
          if ( !*v11 )
            goto LABEL_39;
          v11 = (int *)*v11;
        }
        v12 = (int *)*v10;
        goto LABEL_38;
      }
    }
LABEL_39:
    if ( !*(_DWORD *)(v7 + 180) && (v8 & 0x10) != 0 )
    {
      if ( *(_WORD *)(v7 + 140) == 2 )
        v13 = &mc4_list;
      else
        v13 = &mc6_list;
      v14 = *v13;
      if ( *v13 != v7 )
      {
        if ( !v14 )
          goto LABEL_52;
        v15 = *(_DWORD *)(v14 + 4);
        if ( !v15 )
          goto LABEL_52;
        while ( v7 != v15 )
        {
          v14 = v15;
          if ( !*(_DWORD *)(v15 + 4) )
            goto LABEL_52;
          v15 = *(_DWORD *)(v15 + 4);
        }
        v13 = (int *)(v14 + 4);
      }
      *v13 = *(_DWORD *)(v7 + 4);
      goto LABEL_52;
    }
    while ( 1 )
    {
LABEL_52:
      v16 = (int *)remoteaddr_list;
      v17 = *(int **)remoteaddr_list;
      if ( *(_DWORD *)(remoteaddr_list + 32) == v7 )
      {
        v18 = &remoteaddr_list;
        goto LABEL_59;
      }
      if ( !v17 )
        break;
      while ( v17[8] != v7 )
      {
        v16 = v17;
        if ( !*v17 )
          goto LABEL_60;
        v17 = (int *)*v17;
      }
      v18 = v16;
      v16 = (int *)*v16;
      v17 = (int *)*v16;
LABEL_59:
      *v18 = (int)v17;
      free(v16);
    }
LABEL_60:
    if ( *(_DWORD *)(v7 + 12) != -1 )
    {
      v47 = *(_DWORD *)(v7 + 20);
      v19 = sub_6C2E8((unsigned __int16 *)(v7 + 24));
      sub_64E00(
        6,
        "Deleting interface #%d %s, %s#%d, interface stats: received=%ld, sent=%ld, dropped=%ld, active_time=%ld secs",
        v47,
        v7 + 108,
        v19,
        (unsigned __int16)__rev16(*(unsigned __int16 *)(v7 + 26)),
        *(_DWORD *)(v7 + 164),
        *(_DWORD *)(v7 + 168),
        *(_DWORD *)(v7 + 172),
        current_time - *(_DWORD *)(v7 + 160));
      sub_15954(*(__int16 **)(v7 + 12));
      *(_DWORD *)(v7 + 12) = -1;
    }
    if ( *(_DWORD *)(v7 + 16) != -1 )
    {
      v20 = sub_6C2E8((unsigned __int16 *)(v7 + 80));
      sub_64E00(
        6,
        "stop listening for broadcasts to %s on interface #%d %s",
        v20,
        *(_DWORD *)(v7 + 20),
        (const char *)(v7 + 108));
      sub_15954(*(__int16 **)(v7 + 16));
      *(_DWORD *)(v7 + 16) = -1;
    }
    --ninterfaces;
    sub_30F28((void *)v7);
    memset(v52, 0, sizeof(v52));
    v53 = 0;
    v22 = *(unsigned __int16 *)(v7 + 24);
    v23 = v22 == 10;
    v51 = *(_WORD *)(v7 + 24);
    if ( v22 == 10 )
      v21 = -1;
    else
      v22 = -1;
    if ( v23 )
    {
      *(_DWORD *)((char *)&v52[1] + 2) = v21;
      *(_DWORD *)((char *)v52 + 6) = v21;
      *(_DWORD *)((char *)&v52[1] + 6) = v21;
      *(_DWORD *)((char *)&v52[2] + 2) = v21;
    }
    else
    {
      *(_DWORD *)((char *)v52 + 2) = v22;
    }
    sub_40238(4, (unsigned __int16 *)(v7 + 24), &v51, -3, 0x3000u, 1, 0);
    v49 = (_DWORD *)v7;
    v50 = 3;
    if ( a1 )
      a1(a2, &v49);
    while ( 1 )
    {
      v24 = *(char **)(v7 + 184);
      if ( !v24 )
        break;
      sub_31E54(v24, 0);
    }
    if ( loopback_interface == v7 )
      loopback_interface = 0;
    free((void *)v7);
LABEL_77:
    v7 = v9;
  }
  while ( v9 );
LABEL_78:
  sub_320B4();
  if ( broadcast_client_enabled )
    sub_1621C();
  if ( sys_bclient )
    sub_1621C();
  for ( i = ep_list; i; i = *(_DWORD *)i )
  {
    if ( (*(_DWORD *)(i + 144) & 0x140) == 0x100 )
    {
      v26 = remoteaddr_list;
      if ( remoteaddr_list )
      {
        if ( i == *(_DWORD *)(remoteaddr_list + 32) )
        {
LABEL_90:
          v27 = (unsigned __int16 *)(v26 + 4);
          if ( sub_148D0((_DWORD *)i, (unsigned __int16 *)(v26 + 4)) )
          {
            v28 = sub_6C2E8((unsigned __int16 *)(i + 24));
            v29 = sub_6C2E8(v27);
            sub_64E00(6, "Joined %s socket to multicast group %s", v28, v29);
          }
        }
        else
        {
          while ( 1 )
          {
            v26 = *(_DWORD *)v26;
            if ( !v26 )
              break;
            if ( *(_DWORD *)(v26 + 32) == i )
              goto LABEL_90;
          }
        }
      }
    }
  }
  return v45;
}
// 17EAC: variable 'v21' is possibly undefined
// 182B0: variable 'v38' is possibly undefined
// B9240: using guessed type __int16 word_B9240[];
// 107D04: using guessed type int mc4_list;
// 107D14: using guessed type int loopback_interface;
// 107D1C: using guessed type int mc6_list;
// 107D20: using guessed type int remoteaddr_list;
// 107D28: using guessed type int ep_list;
// 107D2C: using guessed type int broadcast_client_enabled;
// 107D38: using guessed type int ninterfaces;
// 108C48: using guessed type int sys_bclient;
// 108CA4: using guessed type int current_time;
// 108D68: using guessed type int ipv6_works;
// 108D6C: using guessed type int ipv4_works;

//----- (00018484) --------------------------------------------------------
char *sub_18484()
{
  char *result; // r0
  __int16 *v1; // r3
  int v2; // r0
  int v3; // r7
  _DWORD *v4; // r0
  int v5; // r11
  _DWORD *v6; // r7
  int v7; // r1
  uint32_t v8; // r2
  uint32_t v9; // r3
  uint32_t v10; // r1
  int v11; // r2
  int v12; // r0
  uint32_t v13; // r1
  uint32_t v14; // r2
  uint32_t v15; // r3
  int v16; // r9
  _DWORD *v17; // r7
  int v18; // r1
  uint32_t v19; // r2
  uint32_t v20; // r3
  uint32_t v21; // r1
  int v22; // r2
  int v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  struct sockaddr addr; // [sp+4h] [bp-30h] BYREF
  int v27; // [sp+14h] [bp-20h]
  uint32_t v28; // [sp+18h] [bp-1Ch]
  uint32_t v29; // [sp+1Ch] [bp-18h]
  uint32_t v30; // [sp+20h] [bp-14h]
  uint32_t v31; // [sp+24h] [bp-10h]
  int v32; // [sp+28h] [bp-Ch]

  result = (char *)word_B9240;
  if ( !dword_B93D4 && (*(int *)((_BYTE *)&elf_hash_bucket[261] + (_DWORD)off_B611C) & 0xF) == 0 )
  {
    v1 = word_B9240;
    dword_B92C4 = 0;
    dword_B93D4 = 1;
    do
    {
      *((_DWORD *)v1 + 1) = 0;
      v1 += 2;
    }
    while ( v1 != (__int16 *)&unk_B92C0 );
    *(_DWORD *)&addr.sa_data[10] = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    if ( ipv6_works )
    {
      v27 = 0;
      v32 = 0;
      *(_DWORD *)&addr.sa_data[10] = 2063597578;
      v13 = in6addr_any.in6_u.u6_addr32[1];
      v14 = in6addr_any.in6_u.u6_addr32[2];
      v15 = in6addr_any.in6_u.u6_addr32[3];
      v28 = in6addr_any.in6_u.u6_addr32[0];
      v29 = v13;
      v30 = v14;
      v31 = v15;
      v16 = sub_149CC(0, (unsigned __int16 *)&addr.sa_data[10], 0);
      if ( v16 != 1 )
      {
        v17 = sub_13F3C(0);
        sub_6D4DC((_BYTE *)v17 + 108, "v6wildcard", 32);
        v18 = v27;
        v19 = v28;
        v20 = v29;
        v17[6] = *(_DWORD *)&addr.sa_data[10];
        v17[9] = v20;
        v17[7] = v18;
        v17[8] = v19;
        v21 = v31;
        v22 = v32;
        v17[10] = v30;
        v17[11] = v21;
        v17[12] = v22;
        *((_WORD *)v17 + 70) = 10;
        *((_WORD *)v17 + 26) = 10;
        v17[15] = -1;
        v17[16] = -1;
        v17[17] = -1;
        v17[18] = -1;
        v17[45] = v16 == 2;
        v17[36] = 129;
        v23 = sub_154A8((struct sockaddr *)(v17 + 6), 0, 1, (int)v17);
        v17[3] = v23;
        if ( v23 == -1 )
        {
          v24 = sub_6C2E8((unsigned __int16 *)v17 + 12);
          sub_64E00(3, "unable to bind to wildcard address %s - another process may be running - EXITING", v24);
          exit(1);
        }
        dword_B92CC = (int)v17;
        any6_interface = (int)v17;
        sub_13EA4(v17 + 6, (int)v17);
        sub_14298((int)v17);
        sub_1482C((int)v17);
      }
    }
    if ( ipv4_works )
    {
      *(_DWORD *)&addr.sa_data[10] = 2063597570;
      v27 = 0;
      v5 = sub_149CC(0, (unsigned __int16 *)&addr.sa_data[10], 0);
      if ( v5 != 1 )
      {
        v6 = sub_13F3C(0);
        sub_6D4DC((_BYTE *)v6 + 108, "v4wildcard", 32);
        v7 = v27;
        v8 = v28;
        v9 = v29;
        v6[6] = *(_DWORD *)&addr.sa_data[10];
        v6[9] = v9;
        v6[7] = v7;
        v6[8] = v8;
        v10 = v31;
        v11 = v32;
        v6[10] = v30;
        v6[11] = v10;
        v6[12] = v11;
        v6[45] = v5 == 2;
        v6[20] = 2063597570;
        v6[21] = 0;
        v6[14] = -1;
        v6[36] = 137;
        *((_WORD *)v6 + 70) = 2;
        *((_WORD *)v6 + 26) = 2;
        v12 = sub_154A8((struct sockaddr *)(v6 + 6), 0, 1, (int)v6);
        v6[3] = v12;
        if ( v12 == -1 )
        {
          v25 = sub_6C2E8((unsigned __int16 *)v6 + 12);
          sub_64E00(3, "unable to bind to wildcard address %s - another process may be running - EXITING", v25);
          exit(1);
        }
        dword_B92C8 = (int)v6;
        any_interface = (int)v6;
        sub_13EA4(v6 + 6, (int)v6);
        sub_14298((int)v6);
        sub_1482C((int)v6);
      }
    }
    sub_17984(0, 0);
    sub_141A4(0);
    v2 = socket(16, 3, 0);
    if ( v2 < 0 )
    {
      return sub_64E00(3, "unable to open routing socket (%m) - using polled interface update");
    }
    else
    {
      v3 = sub_6C0B8(v2);
      *(_WORD *)&addr.sa_data[4] = 0;
      *(_DWORD *)addr.sa_data = 0;
      addr.sa_family = 16;
      *(_DWORD *)&addr.sa_data[6] = 1905;
      if ( bind(v3, &addr, 0xCu) < 0 )
      {
        return sub_64E00(3, "bind failed on routing socket (%m) - using polled interface update");
      }
      else
      {
        sub_6C26C(v3);
        v4 = sub_63BA4(0, 0x10u, 0, 1);
        v4[1] = v3;
        v4[3] = sub_15B14;
        *v4 = asyncio_reader_list;
        asyncio_reader_list = (int)v4;
        sub_15420(v3, 0);
        return sub_64E00(6, "Listening on routing socket on fd #%d for interface updates", v3);
      }
    }
  }
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B611C: using guessed type _UNKNOWN *off_B611C;
// B9240: using guessed type __int16 word_B9240[];
// B92C4: using guessed type int dword_B92C4;
// B92C8: using guessed type int dword_B92C8;
// B92CC: using guessed type int dword_B92CC;
// B93D4: using guessed type int dword_B93D4;
// 107D0C: using guessed type int asyncio_reader_list;
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;
// 108D68: using guessed type int ipv6_works;
// 108D6C: using guessed type int ipv4_works;

//----- (00018908) --------------------------------------------------------
void __fastcall sub_18908(void (__fastcall *a1)(int, _DWORD **), int a2)
{
  if ( !disable_dynamic_updates )
  {
    if ( sub_17984(a1, a2) )
      sub_6E4A8();
  }
}
// 107D24: using guessed type int disable_dynamic_updates;

//----- (0001898C) --------------------------------------------------------
int __fastcall sub_1898C(struct sockaddr *a1)
{
  char *v2; // r4
  int sa_family; // r1
  int v5; // r3
  int v6; // r2
  int v7; // r1
  int v8; // r11
  int v9; // r3
  int *v10; // r0
  _DWORD *v11; // r11
  _DWORD *v12; // r0
  int v13; // r10
  _BOOL4 v14; // r3
  int v15; // r10

  v2 = sub_1759C(a1, 132, 1);
  if ( !v2 )
  {
    sa_family = a1->sa_family;
    v2 = (char *)ep_list;
    if ( !ep_list )
    {
LABEL_15:
      if ( sa_family == 2 )
        return any_interface;
      else
        return any6_interface;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v5 = *((_DWORD *)v2 + 36);
          if ( (v5 & 0x80) != 0 )
            goto LABEL_14;
          if ( *((_DWORD *)v2 + 45) )
            goto LABEL_14;
          v6 = *((unsigned __int16 *)v2 + 12);
          if ( v6 != sa_family || (v5 & 4) != 0 )
            goto LABEL_14;
          if ( sa_family != 2 )
            break;
          v7 = *(_DWORD *)&a1->sa_data[2];
          if ( (v7 & 0xF0) == 0xE0 && (v5 & 0x10) != 0
            || *((_WORD *)v2 + 40) == 2 && *((_DWORD *)v2 + 21) == v7
            || ((v7 ^ *((_DWORD *)v2 + 7)) & *((_DWORD *)v2 + 14)) == 0 )
          {
            return (int)v2;
          }
LABEL_18:
          v2 = *(char **)v2;
          sa_family = v6;
          if ( !v2 )
            goto LABEL_15;
        }
        if ( (unsigned __int8)a1->sa_data[6] != 255 || (v5 & 0x10) == 0 )
          break;
        if ( sa_family != 10 || (a1->sa_data[7] & 0xF) != 2 || (*((_DWORD *)v2 + 8) & 0xC0FF) == 0x80FE )
          return (int)v2;
LABEL_14:
        v2 = *(char **)v2;
        if ( !v2 )
          goto LABEL_15;
      }
      if ( sa_family != 10 )
        goto LABEL_18;
      if ( *((_WORD *)v2 + 40) == 10
        && !memcmp(v2 + 88, &a1->sa_data[6], 0x10u)
        && *((_DWORD *)v2 + 26) == *(_DWORD *)&a1[1].sa_data[6] )
      {
        return (int)v2;
      }
      v8 = *(unsigned __int16 *)sub_65468((int *)v2 + 6);
      if ( *(unsigned __int16 *)sub_65468((int *)a1) == v8 )
      {
        v9 = *(unsigned __int16 *)sub_65468((int *)v2 + 6);
        v10 = (int *)(v2 + 24);
        if ( v9 == 2 )
        {
          v15 = sub_65468(v10)[1];
          v14 = sub_65468((int *)a1)[1] == v15;
        }
        else
        {
          v11 = sub_65468(v10);
          v12 = sub_65468((int *)a1);
          if ( memcmp(v11 + 2, v12 + 2, 0x10u) )
            goto LABEL_29;
          v13 = sub_65468((int *)v2 + 6)[6];
          v14 = sub_65468((int *)a1)[6] == v13;
        }
        if ( v14 )
          return (int)v2;
      }
LABEL_29:
      v2 = *(char **)v2;
      sa_family = a1->sa_family;
      if ( !v2 )
        goto LABEL_15;
    }
  }
  return (int)v2;
}
// 107D28: using guessed type int ep_list;
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;

//----- (00018C28) --------------------------------------------------------
char *__fastcall sub_18C28(int a1, int a2, char *a3)
{
  int v4; // r6
  char *result; // r0

  if ( *(_WORD *)a2 == 2 )
  {
    v4 = any_interface;
    if ( *(_WORD *)(a2 + 4) == 32639 )
    {
      result = (char *)loopback_interface;
      goto LABEL_12;
    }
  }
  else
  {
    v4 = any6_interface;
  }
  if ( (*(_BYTE *)(a1 + 72) & 0x36) != 0 )
  {
    result = (char *)sub_1898C((struct sockaddr *)a2);
LABEL_12:
    if ( result != (char *)v4 )
      goto LABEL_13;
    goto LABEL_15;
  }
  if ( a3 && a3 != (char *)v4 )
  {
    result = a3;
    goto LABEL_7;
  }
LABEL_15:
  result = sub_178F8((const struct sockaddr *)a2);
LABEL_13:
  if ( !result )
    return 0;
LABEL_7:
  if ( (*((_DWORD *)result + 36) & 0x80) != 0 )
    return 0;
  return result;
}
// 107D14: using guessed type int loopback_interface;
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;

//----- (00018D18) --------------------------------------------------------
int sub_18D18()
{
  packets_dropped = 0;
  packets_ignored = 0;
  packets_received = 0;
  packets_sent = 0;
  packets_notsent = 0;
  handler_calls = 0;
  handler_pkts = 0;
  io_timereset = current_time;
  return current_time;
}
// 107CFC: using guessed type int packets_received;
// 107D00: using guessed type int packets_ignored;
// 107D08: using guessed type int packets_sent;
// 107D18: using guessed type int handler_calls;
// 107D34: using guessed type int packets_notsent;
// 107D3C: using guessed type int handler_pkts;
// 107D40: using guessed type int packets_dropped;
// 107D44: using guessed type int io_timereset;
// 108CA4: using guessed type int current_time;

//----- (00018DF0) --------------------------------------------------------
int __fastcall sub_18DF0(int *a1)
{
  int v1; // r2

  v1 = dword_B93D0;
  a1[7] = 1;
  *a1 = v1;
  dword_B93D0 = (int)a1;
  sub_15420(a1[5], 1);
  return 1;
}
// B93D0: using guessed type int dword_B93D0;

//----- (00018E64) --------------------------------------------------------
char *__fastcall sub_18E64(int a1)
{
  char *result; // r0
  int *v3; // r1
  int *v4; // r3
  int *v5; // r3
  __int16 *v6; // r0

  *(_DWORD *)(a1 + 28) = 0;
  result = (char *)word_B9240;
  v3 = (int *)dword_B93D0;
  if ( a1 == dword_B93D0 )
  {
    v5 = &dword_B93D0;
LABEL_9:
    v6 = *(__int16 **)(a1 + 20);
    *v5 = *v3;
    sub_15954(v6);
    result = sub_6A240(*(char **)(a1 + 20));
    *(_DWORD *)(a1 + 20) = -1;
    return result;
  }
  if ( dword_B93D0 )
  {
    v4 = *(int **)dword_B93D0;
    if ( *(_DWORD *)dword_B93D0 )
    {
      while ( (int *)a1 != v4 )
      {
        v3 = v4;
        if ( !*v4 )
          return result;
        v4 = (int *)*v4;
      }
      v5 = v3;
      v3 = (int *)*v3;
      goto LABEL_9;
    }
  }
  return result;
}
// B9240: using guessed type __int16 word_B9240[];
// B93D0: using guessed type int dword_B93D0;

//----- (00018F30) --------------------------------------------------------
__int16 *sub_18F30()
{
  __int16 *result; // r0
  int i; // r3

  result = (_WORD *)(elf_hash_bucket + 1648);
  dword_B92C4 = 0;
  for ( i = fd_list; fd_list; i = fd_list )
    result = sub_15954(*(__int16 **)(i + 4));
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B92C4: using guessed type int dword_B92C4;
// 107D30: using guessed type int fd_list;

//----- (00018FB4) --------------------------------------------------------
const char *__fastcall sub_18FB4(int a1)
{
  if ( a1 )
    return sub_6C2E8((unsigned __int16 *)(a1 + 24));
  else
    return "<null>";
}

//----- (00019024) --------------------------------------------------------
int __fastcall sub_19024(__int16 *a1, unsigned int a2)
{
  __int16 *v4; // r4
  __int16 *v5; // r6

  fwrite("Stack now", 1u, 9u, stderr);
  if ( (unsigned int)a1 <= a2 )
  {
    v4 = a1 + 1;
    v5 = (__int16 *)((char *)a1 + ((a2 - (_DWORD)a1) & 0xFFFFFFFE) + 2);
    while ( 1 )
    {
      _fprintf_chk(stderr, 1, " %d", *a1);
      a1 = v4;
      if ( v4 == v5 )
        break;
      ++v4;
    }
  }
  return fputc(10, stderr);
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (000190F4) --------------------------------------------------------
int __fastcall sub_190F4(FILE *a1, int a2)
{
  const char *v3; // r3

  if ( a2 <= 207 )
    v3 = "token";
  else
    v3 = "nterm";
  _fprintf_chk(a1, 1, "%s %s (", v3, (&off_B36E0)[a2]);
  return fputc(41, a1);
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// B36E0: using guessed type char *off_B36E0;

//----- (0001919C) --------------------------------------------------------
const char *__fastcall sub_1919C(const char *result, int a2)
{
  if ( yydebug )
  {
    _fprintf_chk(stderr, 1, "%s ", result);
    sub_190F4(stderr, a2);
    return (const char *)fputc(10, stderr);
  }
  return result;
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// 107D58: using guessed type int yydebug;

//----- (00019254) --------------------------------------------------------
size_t __fastcall sub_19254(int a1, char *s)
{
  size_t result; // r0
  char *v4; // r3
  unsigned int v5; // r2
  int v6; // r2

  if ( *s == 34 )
  {
    v4 = s;
    for ( result = 0; ; ++result )
    {
      v5 = (unsigned __int8)v4[1];
      if ( v5 == 39 )
        goto LABEL_2;
      if ( v5 <= 0x27 )
        break;
      if ( v5 == 44 )
        goto LABEL_2;
      if ( v5 != 92 )
        goto LABEL_18;
      v6 = (unsigned __int8)v4[2];
      v4 += 2;
      if ( v6 != 92 )
        goto LABEL_2;
LABEL_11:
      if ( a1 )
        *(_BYTE *)(a1 + result) = *v4;
    }
    if ( v5 == 34 )
    {
      if ( a1 )
        *(_BYTE *)(a1 + result) = 0;
      return result;
    }
LABEL_18:
    ++v4;
    goto LABEL_11;
  }
LABEL_2:
  if ( a1 )
    return stpcpy(a1) - a1;
  else
    return strlen(s);
}
// B548: using guessed type int __fastcall stpcpy(_DWORD);

//----- (00019348) --------------------------------------------------------
int __fastcall sub_19348(int *a1, _BYTE **a2, __int16 *a3, int a4)
{
  char *v7; // r6
  size_t v8; // r0
  size_t v9; // r8
  int v10; // r3
  int v11; // r2
  int v12; // r11
  int v13; // r4
  int v14; // r6
  size_t v15; // r7
  char *v16; // r5
  int v17; // t1
  _BOOL4 v18; // r1
  char *v19; // r1
  _DWORD *v20; // r12
  size_t v21; // r0
  bool v22; // cf
  int result; // r0
  size_t v24; // r0
  const char *v25; // r4
  unsigned int v26; // r8
  int v27; // r3
  _BYTE *v28; // r5
  int v29; // r3
  bool v30; // zf
  _BOOL4 v31; // r2
  int v32; // r7
  size_t v33; // r0
  _DWORD v35[7]; // [sp+8h] [bp-1Ch] BYREF

  v7 = (&off_B36E0)[a4];
  v8 = sub_19254(0, v7);
  v9 = v8;
  if ( a4 == -2 )
  {
    v24 = 12;
    v14 = 0;
    v25 = "syntax error";
  }
  else
  {
    v10 = *a3;
    v35[0] = v7;
    v11 = asc_8E108[v10];
    if ( v11 == -215 )
    {
      v24 = 27;
      v14 = 1;
      v25 = "syntax error, unexpected %s";
    }
    else
    {
      v12 = 663 - v11;
      if ( v11 >= 0 )
        v13 = 0;
      else
        v13 = -v11;
      if ( v12 >= 208 )
        v12 = 208;
      if ( v13 >= v12 )
      {
        v24 = 27;
        v14 = 1;
        v25 = "syntax error, unexpected %s";
      }
      else
      {
        v14 = 1;
        v15 = v8;
        v16 = (char *)&asc_8E108[v13 + 435 + v11];
        do
        {
          v17 = *((__int16 *)v16 + 1);
          v16 += 2;
          v18 = v17 == v13;
          if ( v13 == 1 )
            v18 = 0;
          if ( v18 )
          {
            if ( v14 == 5 )
            {
              v24 = 27;
              v14 = 1;
              v25 = "syntax error, unexpected %s";
              goto LABEL_19;
            }
            v19 = (&off_B36E0)[v13];
            v20 = &v35[v14++ + 6];
            *(v20 - 6) = v19;
            v21 = sub_19254(0, v19);
            v22 = __CFADD__(v21, v15);
            v15 += v21;
            if ( v22 )
              return 2;
          }
          ++v13;
        }
        while ( v12 != v13 );
        switch ( v14 )
        {
          case 1:
            v9 = v15;
            v24 = 27;
            v25 = "syntax error, unexpected %s";
            break;
          case 2:
            v9 = v15;
            v24 = 41;
            v25 = "syntax error, unexpected %s, expecting %s";
            break;
          case 3:
            v9 = v15;
            v24 = 47;
            v25 = "syntax error, unexpected %s, expecting %s or %s";
            break;
          case 4:
            v9 = v15;
            v24 = 53;
            v25 = "syntax error, unexpected %s, expecting %s or %s or %s";
            break;
          case 5:
            v9 = v15;
            v24 = 59;
            v25 = "syntax error, unexpected %s, expecting %s or %s or %s or %s";
            break;
          default:
            v9 = v15;
            v24 = strlen(0);
            v25 = 0;
            break;
        }
      }
    }
  }
LABEL_19:
  v22 = __CFADD__(v9, v24);
  v26 = v9 + v24;
  if ( v22 )
    return 2;
  if ( *a1 >= v26 )
  {
    result = *(unsigned __int8 *)v25;
    v28 = *a2;
    v29 = 0;
    while ( 1 )
    {
      *v28 = result;
      if ( !result )
        break;
      v30 = result == 37;
      result = *((unsigned __int8 *)v25 + 1);
      if ( !v30 )
        goto LABEL_27;
      v31 = result == 115;
      if ( v29 >= v14 )
        v31 = 0;
      if ( v31 )
      {
        v32 = v29 + 1;
        v25 += 2;
        v33 = sub_19254((int)v28, (char *)v35[v29]);
        v29 = v32;
        v28 += v33;
        result = *(unsigned __int8 *)v25;
      }
      else
      {
LABEL_27:
        ++v28;
        ++v25;
      }
    }
  }
  else
  {
    v27 = 2 * v26;
    result = 1;
    if ( 2 * v26 < v26 )
      v27 = -1;
    *a1 = v27;
  }
  return result;
}
// 8E108: using guessed type __int16 asc_8E108[436];
// B36E0: using guessed type char *off_B36E0;

//----- (00019664) --------------------------------------------------------
int __fastcall sub_19664(const char *a1)
{
  _DWORD *v2; // r4
  int v3; // r1
  int result; // r0

  v2 = (_DWORD *)sub_1C4B8();
  v3 = v2[9];
  v2[10] = v2[8];
  v2[11] = v3;
  sub_64E00(3, "line %d column %d %s", v2[10], v2[11], a1);
  result = sub_1C450();
  if ( !result )
  {
    result = sub_6C054(
               (int)&unk_1078F0 + dword_107CF4,
               1024 - dword_107CF4,
               (unsigned __int8 *)"column %d %s",
               v2[11],
               a1);
    if ( result > 0 )
    {
      result += dword_107CF4;
      dword_107CF4 = result;
    }
    ++dword_107CF8;
  }
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// 107CF4: using guessed type int dword_107CF4;
// 107CF8: using guessed type int dword_107CF8;

//----- (0001973C) --------------------------------------------------------
int sub_1973C()
{
  int v0; // r3
  int v1; // r6
  __int16 *v2; // r11
  int *v3; // r9
  __int16 *v4; // r10
  unsigned int v5; // r6
  unsigned int v6; // r5
  unsigned int v7; // r4
  int v8; // r0
  int v9; // r3
  int v10; // r7
  int v11; // r4
  const __int16 *v12; // r2
  int v13; // r4
  int v14; // r7
  const char *v15; // r0
  __int16 *v16; // r5
  int *v17; // r9
  int v18; // r6
  int v19; // r6
  int v20; // r2
  int v21; // r3
  unsigned int v22; // r3
  int v23; // r3
  int v24; // r3
  int v25; // r9
  int v26; // r4
  __int16 *v27; // r0
  __int16 *v28; // r7
  int v29; // r5
  size_t v30; // r10
  size_t v31; // r9
  char *v32; // r4
  int v33; // r3
  int v34; // r3
  unsigned int v35; // r5
  int v36; // r5
  int v37; // r5
  int v38; // t1
  int v39; // r4
  bool v40; // zf
  int v41; // r4
  __int16 *v42; // r8
  int v43; // r1
  int v44; // t1
  int v46; // r3
  int v47; // r5
  __int16 *v48; // r4
  int v49; // r0
  int v50; // r3
  const char *v51; // r0
  __int16 *v52; // r9
  __int16 *v53; // r11
  int v54; // r0
  _DWORD *v55; // r0
  int **v56; // r3
  int v57; // r0
  int **v58; // r4
  _DWORD *v59; // r0
  _DWORD *v60; // r0
  int v61; // r5
  int v62; // r0
  _DWORD *v63; // r0
  void *v64; // r0
  _DWORD *v65; // r4
  void *v66; // r0
  _DWORD *v67; // r5
  int **v68; // r6
  int v69; // r0
  _DWORD *v70; // r0
  void *v71; // r0
  _DWORD *v72; // r4
  void *v73; // r0
  _DWORD *v74; // r5
  int **v75; // r6
  int v76; // r0
  _DWORD *v77; // r0
  __int16 v78; // r4
  int **v79; // r5
  int v80; // r0
  _DWORD *v81; // r0
  int v82; // r4
  int v83; // r5
  int **v84; // r6
  int v85; // r0
  _DWORD *v86; // r0
  _DWORD *v87; // r0
  unsigned __int64 v88; // kr00_8
  _DWORD *v89; // r0
  _DWORD *v90; // r4
  _DWORD *v91; // r0
  int v92; // r4
  __int16 v93; // r6
  int **v94; // r5
  int v95; // r0
  _DWORD *v96; // r0
  _DWORD *v97; // r0
  _DWORD *v98; // r4
  _DWORD *v99; // r0
  _DWORD *v100; // r0
  int **v101; // r0
  int v102; // r3
  int v103; // r4
  void *v104; // r0
  int v105; // r4
  void *v106; // r0
  _DWORD *v107; // r0
  _DWORD *v108; // r0
  _DWORD *v109; // r0
  _DWORD *v110; // r0
  _WORD *v111; // r1
  void *v112; // r0
  _DWORD *v113; // r0
  _DWORD *v114; // r0
  _DWORD *v115; // r0
  _DWORD *v116; // r0
  _DWORD *v117; // r0
  _DWORD *v118; // r0
  int **v119; // r1
  _DWORD *v120; // r0
  int **v121; // r1
  _DWORD *v122; // r0
  char *v123; // r0
  char *v124; // r0
  const char *v125; // r0
  const char *v126; // r4
  unsigned int v127; // [sp+14h] [bp-938h]
  char *src; // [sp+18h] [bp-934h]
  int v129; // [sp+1Ch] [bp-930h]
  int v130; // [sp+1Ch] [bp-930h]
  __int16 *v131; // [sp+1Ch] [bp-930h]
  int v132; // [sp+1Ch] [bp-930h]
  int v133; // [sp+24h] [bp-928h]
  int v134; // [sp+28h] [bp-924h]
  int v135; // [sp+30h] [bp-91Ch]
  __int16 v136; // [sp+58h] [bp-8F4h]
  __int16 v137; // [sp+58h] [bp-8F4h]
  __int16 v138; // [sp+58h] [bp-8F4h]
  int v139; // [sp+5Ch] [bp-8F0h]
  void *ptr; // [sp+68h] [bp-8E4h] BYREF
  size_t v141; // [sp+6Ch] [bp-8E0h] BYREF
  _WORD v142[4]; // [sp+70h] [bp-8DCh] BYREF
  _BYTE v143[1600]; // [sp+200h] [bp-74Ch] BYREF
  _BYTE v144[124]; // [sp+844h] [bp-108h] BYREF
  char v145[128]; // [sp+8C4h] [bp-88h] BYREF

  ptr = v144;
  v141 = 128;
  v0 = yydebug;
  if ( yydebug )
  {
    fwrite("Starting parse\n", 1u, 0xFu, stderr);
    v0 = yydebug;
  }
  v1 = 0;
  v133 = 0;
  yynerrs = 0;
  v2 = v142;
  v142[0] = 0;
  v127 = 200;
  v3 = (int *)v143;
  src = v143;
  yychar = -2;
  v4 = v142;
  if ( v0 )
    goto LABEL_39;
  while ( 1 )
  {
    if ( v1 == 216 )
    {
      v41 = 0;
      v42 = v4;
      goto LABEL_64;
    }
    v5 = 2 * v1;
    v6 = asc_8E108[v5 / 2];
    v7 = v6;
    if ( v6 == -215 )
    {
LABEL_14:
      v12 = "\v";
      v13 = *(unsigned __int16 *)((char *)&unk_8F09C + v5);
      if ( *(_WORD *)((char *)&unk_8F09C + v5) )
        goto LABEL_15;
      v33 = yychar;
      if ( yychar == -2 )
      {
        v13 = -2;
      }
      else
      {
        if ( (unsigned int)yychar > 0x1C9 )
          v13 = 2;
        else
          v12 = (__int16 *)("\v" + yychar);
        if ( (unsigned int)yychar <= 0x1C9 )
          v13 = *((unsigned __int8 *)v12 + 2200);
      }
      if ( v133 )
      {
        if ( v133 == 3 )
        {
          if ( yychar > 0 )
          {
            sub_1919C("Error: discarding", v13);
            yychar = -2;
          }
          else if ( !yychar )
          {
            v41 = 1;
            v42 = v4;
            goto LABEL_84;
          }
        }
      }
      else
      {
        ++yynerrs;
        v49 = sub_19348((int *)&v141, (_BYTE **)&ptr, v4, v13);
        v50 = v49;
        if ( v49 )
        {
          if ( v49 == 1 )
          {
            if ( ptr != v144 )
              free(ptr);
            ptr = sub_63BA4(0, v141, 0, 0);
            if ( !ptr )
            {
              v52 = v2;
              v53 = v4;
              ptr = v144;
              v141 = 128;
              sub_19664("syntax error");
              goto LABEL_106;
            }
            v50 = sub_19348((int *)&v141, (_BYTE **)&ptr, v4, v13);
            v51 = (const char *)ptr;
          }
          else
          {
            v51 = "syntax error";
          }
          v132 = v50;
          sub_19664(v51);
          if ( v132 == 2 )
            goto LABEL_105;
        }
        else
        {
          sub_19664((const char *)ptr);
        }
      }
      v34 = v5;
      while ( 1 )
      {
        if ( v6 != -215 )
        {
          v35 = v6 + 1;
          if ( v35 <= 0x296 )
          {
            v36 = 2 * v35;
            if ( *(_WORD *)((char *)&unk_8E470 + v36) == 1 && *(__int16 *)((char *)&unk_8EB6C + v36) > 0 )
              break;
          }
        }
        if ( v2 == v4 )
        {
          v2 = v4;
          v41 = 1;
          v42 = v4;
          goto LABEL_64;
        }
        v3 -= 2;
        sub_1919C("Error: popping", *(unsigned __int16 *)((char *)&word_8F54C[326] + v34));
        v38 = *--v4;
        v37 = v38;
        if ( yydebug )
          sub_19024(v2, (unsigned int)v4);
        v34 = 2 * v37;
        v6 = asc_8E108[v37];
      }
      v39 = *(__int16 *)((char *)&unk_8EB6C + v36);
      v40 = yydebug == 0;
      *((double *)v3 + 1) = yylval;
      v3 += 2;
      if ( v40 )
      {
        v16 = v4;
        v1 = v39;
        v133 = 3;
      }
      else
      {
        v1 = v39;
        v16 = v4;
        v133 = 3;
        _fprintf_chk(stderr, 1, "%s ", "Shifting");
        sub_190F4(stderr, word_8F54C[v39 + 326]);
        fputc(10, stderr);
      }
      goto LABEL_27;
    }
    v8 = yychar;
    v9 = yydebug;
    if ( yychar == -2 )
    {
      if ( yydebug )
        fwrite("Reading a token: ", 1u, 0x11u, stderr);
      v8 = sub_1C5E8();
      v9 = yydebug;
      yychar = v8;
    }
    if ( v8 <= 0 )
    {
      v10 = 0;
      yychar = 0;
      if ( v9 )
        fwrite("Now at end of input.\n", 1u, 0x15u, stderr);
      else
        v10 = 0;
    }
    else if ( v8 <= 457 )
    {
      v10 = *((unsigned __int8 *)&asc_8E108[1100] + v8);
      v7 = v6 + v10;
      if ( v9 )
        goto LABEL_82;
    }
    else
    {
      v10 = 2;
      v7 = v6 + 2;
      if ( v9 )
      {
LABEL_82:
        _fprintf_chk(stderr, 1, "%s ", "Next token is");
        sub_190F4(stderr, v10);
        fputc(10, stderr);
      }
    }
    if ( v7 > 0x296 )
      goto LABEL_14;
    v11 = 2 * v7;
    v129 = *(__int16 *)((char *)&unk_8E470 + v11);
    if ( v129 != v10 )
      goto LABEL_14;
    v46 = *(__int16 *)((char *)&unk_8EB6C + v11);
    v1 = v46;
    if ( v46 <= 0 )
    {
      v13 = -v46;
LABEL_15:
      v14 = (unsigned __int8)aFilegenNolinkR[v13 - 3288];
      v130 = v3[2 * (1 - v14)];
      v134 = v3[2 * (1 - v14) + 1];
      if ( yydebug )
      {
        v135 = v13;
        _fprintf_chk(stderr, 1, "Reducing stack by rule %d (line %lu):\n", v13 - 1, word_8F54C[v13]);
        if ( v14 )
        {
          v139 = v13;
          v47 = 0;
          v48 = &v4[-v14];
          do
          {
            ++v47;
            ++v48;
            _fprintf_chk(stderr, 1, "   $%d = ", v47);
            sub_190F4(stderr, word_8F54C[v48[(__int16)v14 - v14] + 326]);
            fputc(10, stderr);
          }
          while ( v14 != v47 );
          v13 = v139;
        }
      }
      else
      {
        v135 = v13;
      }
      switch ( v13 )
      {
        case 5:
          v54 = sub_1C4B8();
          sub_64E00(
            3,
            "syntax error in %s line %d, column %d",
            (const char *)(v54 + 48),
            *(_DWORD *)(v54 + 40),
            *(_DWORD *)(v54 + 44));
          break;
        case 20:
          v122 = sub_F4B0(*(v3 - 4), *(v3 - 2), (int **)*v3);
          unk_10744C = sub_EDB0(unk_10744C, v122);
          break;
        case 27:
          v130 = (int)sub_F348(*v3, *(v3 - 2));
          break;
        case 28:
          v130 = (int)sub_F348(*v3, 0);
          break;
        case 29:
          v130 = 2;
          break;
        case 30:
          v130 = 10;
          break;
        case 31:
        case 71:
        case 111:
        case 257:
          v130 = 0;
          break;
        case 32:
        case 72:
        case 81:
        case 112:
        case 157:
        case 163:
        case 175:
        case 189:
        case 197:
        case 214:
        case 258:
        case 261:
        case 287:
        case 294:
        case 309:
        case 314:
          v130 = (int)sub_EDB0((_DWORD *)*(v3 - 2), (_DWORD *)*v3);
          break;
        case 36:
        case 116:
        case 199:
          goto LABEL_186;
        case 45:
        case 159:
        case 165:
        case 178:
        case 191:
        case 259:
          goto LABEL_130;
        case 46:
          v130 = (int)sub_F108(*(v3 - 2), *v3);
          break;
        case 53:
        case 73:
        case 180:
        case 181:
          goto LABEL_157;
        case 55:
          v111 = sub_F7BC((_DWORD *)*v3);
          if ( v111 )
            unk_107450 = sub_EDB0(unk_107450, v111);
          break;
        case 58:
          unk_107454 = 1;
          break;
        case 59:
          unk_107458 = sub_EE48(unk_107458, (_DWORD *)*v3);
          break;
        case 60:
          unk_10745C = sub_EE48(unk_10745C, (_DWORD *)*v3);
          break;
        case 61:
          dword_1074D8 = *v3;
          break;
        case 62:
        case 230:
          v110 = sub_F098(*(v3 - 2), *v3);
          dword_1074C8 = sub_EDB0(dword_1074C8, v110);
          break;
        case 63:
          unk_107490 = *v3;
          break;
        case 64:
          v119 = (int **)*v3;
          ++unk_107494;
          unk_107498 = sub_EE48(unk_107498, v119);
          break;
        case 65:
          unk_10749C = *v3;
          break;
        case 66:
          unk_1074A0 = *v3;
          break;
        case 67:
          unk_1074A4 = *v3;
          break;
        case 68:
          unk_1074A8 = *v3;
          break;
        case 69:
          v120 = (_DWORD *)sub_EEF0(unk_1074AC, (void (**)(void *))destroy_attr_val);
          v121 = (int **)*v3;
          unk_1074AC = v120;
          unk_1074AC = sub_EE48(v120, v121);
          break;
        case 70:
          unk_1074B0 = *v3;
          break;
        case 74:
          v130 = 0;
          unk_1074A8 = *v3;
          sub_64E00(4, "'crypto revoke %d' is deprecated, please use 'revoke %d' instead.", unk_1074A8, unk_1074A8);
          break;
        case 80:
          unk_107460 = sub_EE48(unk_107460, (_DWORD *)*v3);
          break;
        case 82:
        case 158:
        case 164:
        case 176:
        case 190:
        case 198:
        case 215:
        case 262:
        case 288:
        case 295:
        case 310:
        case 315:
          v130 = (int)sub_EDB0(0, (_DWORD *)*v3);
          break;
        case 83:
        case 84:
        case 85:
        case 177:
        case 216:
          v130 = (int)sub_F020(*(v3 - 2));
          break;
        case 86:
          v130 = (int)sub_F098(267, *v3);
          break;
        case 98:
          unk_107464 = sub_EE48(unk_107464, (_DWORD *)*v3);
          break;
        case 99:
          if ( sub_1C450() )
          {
            unk_107468 = *v3;
          }
          else
          {
            free((void *)*v3);
            sub_19664("statsdir remote configuration ignored");
          }
          break;
        case 100:
          v100 = sub_F898(*(v3 - 2), *v3);
          unk_10746C = sub_EDB0(unk_10746C, v100);
          break;
        case 101:
        case 139:
        case 276:
        case 285:
          v98 = (_DWORD *)*(v3 - 2);
          v99 = sub_F288(*v3);
          v130 = (int)sub_EDB0(v98, v99);
          break;
        case 102:
        case 277:
        case 286:
          v97 = sub_F288(*v3);
          v130 = (int)sub_EDB0(0, v97);
          break;
        case 113:
          if ( sub_1C450() )
          {
LABEL_157:
            v130 = (int)sub_F1F0(*(v3 - 2), (void *)*v3);
          }
          else
          {
            v130 = 0;
            free((void *)*v3);
            sub_19664("filegen file remote config ignored");
          }
          break;
        case 114:
          if ( sub_1C450() )
            goto LABEL_130;
          v130 = 0;
          sub_19664("filegen type remote config ignored");
          break;
        case 115:
          if ( sub_1C450() )
            goto LABEL_186;
          v130 = 0;
          if ( *v3 == 337 )
            v15 = "filegen link remote config ignored";
          else
            v15 = "filegen nolink remote config ignored";
          sub_19664(v15);
          break;
        case 128:
          unk_107470 = sub_EE48(unk_107470, (_DWORD *)*v3);
          break;
        case 129:
          unk_107474 = sub_EE48(unk_107474, (_DWORD *)*v3);
          break;
        case 130:
          v92 = *(v3 - 4);
          v93 = *((_WORD *)v3 - 4);
          v94 = (int **)*v3;
          v95 = sub_1C4B8();
          v96 = sub_F900(v92, 0, v93, (int)v94, *(_DWORD *)(v95 + 16));
          unk_107478 = sub_EDB0(unk_107478, v96);
          break;
        case 131:
          v82 = *(v3 - 8);
          v83 = *(v3 - 4);
          v138 = *((_WORD *)v3 - 4);
          v84 = (int **)*v3;
          v85 = sub_1C4B8();
          v86 = sub_F900(v82, v83, v138, (int)v84, *(_DWORD *)(v85 + 16));
          unk_107478 = sub_EDB0(unk_107478, v86);
          break;
        case 132:
          v78 = *((_WORD *)v3 - 4);
          v79 = (int **)*v3;
          v80 = sub_1C4B8();
          v81 = sub_F900(0, 0, v78, (int)v79, *(_DWORD *)(v80 + 16));
          unk_107478 = sub_EDB0(unk_107478, v81);
          break;
        case 133:
          v71 = sub_63D08("0.0.0.0");
          v72 = sub_F348((int)v71, 2);
          v73 = sub_63D08("0.0.0.0");
          v74 = sub_F348((int)v73, 2);
          v75 = (int **)*v3;
          v137 = *((_WORD *)v3 - 4);
          v76 = sub_1C4B8();
          v77 = sub_F900((int)v72, (int)v74, v137, (int)v75, *(_DWORD *)(v76 + 16));
          unk_107478 = sub_EDB0(unk_107478, v77);
          break;
        case 134:
          v64 = sub_63D08("::");
          v65 = sub_F348((int)v64, 10);
          v66 = sub_63D08("::");
          v67 = sub_F348((int)v66, 10);
          v68 = (int **)*v3;
          v136 = *((_WORD *)v3 - 4);
          v69 = sub_1C4B8();
          v70 = sub_F900((int)v65, (int)v67, v136, (int)v68, *(_DWORD *)(v69 + 16));
          unk_107478 = sub_EDB0(unk_107478, v70);
          break;
        case 135:
          v58 = (int **)*v3;
          v59 = sub_F288(*(v3 - 4));
          v60 = sub_EDB0(v58, v59);
          *v3 = (int)v60;
          v61 = (int)v60;
          LOWORD(v58) = *((_WORD *)v3 - 4);
          v62 = sub_1C4B8();
          v63 = sub_F900(0, 0, (__int16)v58, v61, *(_DWORD *)(v62 + 16));
          unk_107478 = sub_EDB0(unk_107478, v63);
          break;
        case 136:
          v130 = -1;
          break;
        case 137:
          v56 = (int **)*v3;
          if ( (unsigned int)(*v3 + 1) > 0x65 )
          {
            v57 = sub_1C4B8();
            sub_64E00(
              3,
              "Unreasonable ippeerlimit value (%d) in %s line %d, column %d.  Using 0.",
              *v3,
              (const char *)(v57 + 48),
              *(_DWORD *)(v57 + 40),
              *(_DWORD *)(v57 + 44));
            v56 = 0;
            *v3 = 0;
          }
          v130 = (int)v56;
          break;
        case 138:
          v130 = 0;
          break;
        case 174:
          v55 = sub_FAAC(*(v3 - 2), *v3);
          unk_10747C = sub_EDB0(unk_10747C, v55);
          break;
        case 179:
          if ( (unsigned int)*v3 > 0x10 )
          {
            v130 = 0;
            sub_19664("fudge factor: stratum value not in [0..16], ignored");
          }
          else
          {
LABEL_130:
            v130 = (int)sub_F098(*(v3 - 2), *v3);
          }
          break;
        case 188:
          unk_107480 = sub_EE48(unk_107480, (_DWORD *)*v3);
          break;
        case 195:
          unk_107488 = sub_EE48(unk_107488, (_DWORD *)*v3);
          break;
        case 196:
          unk_10748C = sub_EE48(unk_10748C, (_DWORD *)*v3);
          break;
        case 200:
          if ( sub_1C450() )
          {
LABEL_186:
            v130 = (int)sub_F098(446, *v3);
          }
          else
          {
            v130 = 0;
            v123 = sub_1C0BC(*v3);
            sub_6C054((int)v145, 0x80u, "enable/disable %s remote configuration ignored", v123);
            sub_19664(v145);
          }
          break;
        case 213:
          unk_107484 = sub_EE48(unk_107484, (_DWORD *)*v3);
          break;
        case 229:
          v109 = sub_F020(*(v3 - 2));
          dword_1074C8 = sub_EDB0(dword_1074C8, v109);
          break;
        case 231:
          goto LABEL_181;
        case 232:
          if ( sub_1C450() )
          {
LABEL_181:
            v108 = sub_F1F0(*(v3 - 2), (void *)*v3);
            dword_1074C8 = sub_EDB0(dword_1074C8, v108);
          }
          else
          {
            free((void *)*v3);
            v124 = sub_1C0BC(*(v3 - 2));
            sub_6C054((int)v145, 0x40u, "%s remote config ignored", v124);
            sub_19664(v145);
          }
          break;
        case 233:
          if ( sub_1C450() )
          {
            if ( (unsigned int)sub_1C3DC() <= 5 )
            {
              sub_63D78();
              v126 = v125;
              if ( !sub_1C2E8(v125, (int)"r") )
              {
                _fprintf_chk(stderr, 1, "getconfig: Couldn't open <%s>\n", v126);
                sub_64E00(3, "getconfig: Couldn't open <%s>", v126);
              }
            }
            else
            {
              fwrite("getconfig: Maximum include file level exceeded.\n", 1u, 0x30u, stderr);
              sub_64E00(3, "getconfig: Maximum include file level exceeded.");
            }
            free((void *)*(v3 - 2));
          }
          else
          {
            free((void *)*(v3 - 2));
            sub_19664("remote includefile ignored");
          }
          break;
        case 234:
          sub_1C24C();
          break;
        case 236:
          unk_1074B4 = sub_EE48(unk_1074B4, (_DWORD *)*v3);
          break;
        case 237:
          unk_1074B8 = sub_EE48(unk_1074B8, (_DWORD *)*v3);
          break;
        case 238:
          unk_1074BC = sub_EDB0(unk_1074BC, (_DWORD *)*v3);
          break;
        case 239:
          v107 = sub_FAAC(*(v3 - 2), *v3);
          dword_1074C4 = sub_EDB0(dword_1074C4, v107);
          break;
        case 240:
          dword_1074C0 = sub_EE48(dword_1074C0, (_DWORD *)*v3);
          break;
        case 245:
          sub_19664("Built without LEAP_SMEAR support.");
          break;
        case 251:
          if ( sub_1C450() )
          {
            v116 = sub_F1F0(290, (void *)*v3);
            dword_1074C8 = sub_EDB0(dword_1074C8, v116);
          }
          else
          {
            free((void *)*v3);
            sub_19664("driftfile remote configuration ignored");
          }
          break;
        case 252:
          if ( sub_1C450() )
          {
            v114 = sub_F1F0(290, (void *)*(v3 - 2));
            dword_1074C8 = sub_EDB0(dword_1074C8, v114);
            v115 = sub_F020(441);
            dword_1074C8 = sub_EDB0(dword_1074C8, v115);
            sub_64E00(
              4,
              "'driftfile FILENAME WanderValue' is deprecated, please use separate 'driftfile FILENAME' and 'nonvolatile "
              "WanderValue' lines instead.");
          }
          else
          {
            free((void *)*(v3 - 2));
            sub_19664("driftfile remote configuration ignored");
          }
          break;
        case 253:
          if ( sub_1C450() )
          {
            v112 = sub_63D08(byte_97F7C);
            v113 = sub_F1F0(290, v112);
            dword_1074C8 = sub_EDB0(dword_1074C8, v113);
          }
          else
          {
            sub_19664("driftfile remote configuration ignored");
          }
          break;
        case 254:
          v130 = (int)sub_F980((const char *)*(v3 - 6), *(v3 - 2), *v3);
          break;
        case 256:
        case 298:
          v130 = 0;
          break;
        case 260:
          v105 = *(v3 - 2);
          v106 = sub_63D08(*(const char **)(*v3 + 4));
          v130 = (int)sub_F1F0(v105, v106);
          sub_F410((_DWORD *)*v3);
          break;
        case 263:
          v101 = (int **)*v3;
          v102 = *(unsigned __int8 *)*v3;
          if ( v102 == 45 || v102 == 61 || v102 == 43 )
          {
            v101 = (int **)((char *)v101 + 1);
            v103 = *(unsigned __int8 *)*v3;
          }
          else
          {
            v103 = 61;
          }
          v104 = sub_63D08((const char *)v101);
          v130 = (int)sub_F1F0(v103, v104);
          free((void *)*v3);
          break;
        case 264:
          v117 = sub_FA04(*v3, 0, *(v3 - 2));
          dword_1074CC = sub_EDB0(dword_1074CC, v117);
          break;
        case 265:
          v118 = sub_FA04(0, *v3, *(v3 - 2));
          dword_1074CC = sub_EDB0(dword_1074CC, v118);
          break;
        case 275:
          dword_1074D0 = sub_EE48(dword_1074D0, (_DWORD *)*v3);
          break;
        case 289:
          v130 = (int)sub_F098(105, *v3);
          break;
        case 291:
          v130 = (int)sub_F178(45, *(v3 - 6), *(v3 - 2));
          break;
        case 292:
          v90 = (_DWORD *)*(v3 - 2);
          v91 = sub_F2E8(*v3);
          v130 = (int)sub_EDB0(v90, v91);
          break;
        case 293:
          v89 = sub_F2E8(*v3);
          v130 = (int)sub_EDB0(0, v89);
          break;
        case 296:
          if ( (unsigned int)*v3 > 1 )
          {
            v130 = 1;
            sub_19664("Integer value is not boolean (0 or 1). Assuming 1");
          }
          else
          {
            v130 = *v3;
          }
          break;
        case 297:
          v130 = 1;
          break;
        case 299:
          *(double *)&v88 = (double)*v3;
          v134 = HIDWORD(v88);
          v130 = v88;
          break;
        case 301:
          v130 = sub_66EA4((const char *)*v3);
          free((void *)*v3);
          break;
        case 302:
          v87 = sub_FB14(*(v3 - 4), *(v3 - 2));
          dword_1074D4 = sub_EDB0(dword_1074D4, v87);
          old_config_style = 1;
          break;
        case 303:
          old_config_style = 0;
          break;
        case 304:
        case 317:
          v130 = (int)sub_EDB0((_DWORD *)*(v3 - 4), (_DWORD *)*(v3 - 2));
          break;
        case 305:
        case 318:
          v130 = (int)sub_EDB0(0, (_DWORD *)*(v3 - 2));
          break;
        case 306:
        case 319:
          v130 = (int)sub_F020(*(v3 - 4));
          break;
        case 311:
          v130 = 0;
          break;
        case 312:
          v130 = *(v3 - 2);
          v134 = *(v3 - 1);
          break;
        case 313:
          v130 = *v3;
          break;
        case 316:
          v130 = 0;
          break;
        default:
          break;
      }
      v16 = &v4[-(__int16)v14];
      v17 = &v3[-2 * (__int16)v14];
      v18 = word_8F54C[v135 + 762];
      if ( yydebug )
      {
        _fprintf_chk(stderr, 1, "%s ", "-> $$ =");
        sub_190F4(stderr, v18);
        fputc(10, stderr);
        if ( yydebug )
          sub_19024(v2, (unsigned int)v16);
      }
      v19 = v18 - 208;
      v20 = *v16;
      v3 = v17 + 2;
      v21 = (__int16)word_8F54C[v19 + 1088];
      *v3 = v130;
      v3[1] = v134;
      v22 = v21 + v20;
      if ( v22 <= 0x296 && (v23 = 2 * v22, *(__int16 *)((char *)&unk_8E470 + v23) == v20) )
        v1 = *(__int16 *)((char *)&unk_8EB6C + v23);
      else
        v1 = (__int16)word_8F54C[v19 + 1196];
      goto LABEL_27;
    }
    if ( v133 )
      --v133;
    if ( yydebug )
    {
      _fprintf_chk(stderr, 1, "%s ", "Shifting");
      sub_190F4(stderr, v129);
      fputc(10, stderr);
    }
    v16 = v4;
    v3 += 2;
    yychar = -2;
    *(double *)v3 = yylval;
LABEL_27:
    v4 = v16 + 1;
    v16[1] = v1;
    v24 = 2 * (v127 + 0x7FFFFFFF);
    if ( v16 + 1 < &v2[v24 / 2u] )
    {
      v32 = src;
      v131 = v2;
      goto LABEL_38;
    }
    v25 = v4 - v2 + 1;
    if ( v127 >= 0x3E8
      || ((unsigned int)(v24 + 2) >= 0x3E8 ? (v26 = 1000) : (v26 = v24 + 2),
          v127 = v26,
          v27 = (__int16 *)sub_63BA4(0, 10 * v26 + 7, 0, 0),
          (v28 = v27) == 0) )
    {
LABEL_105:
      v52 = v2;
      v53 = v4;
LABEL_106:
      v42 = v53;
      v41 = 2;
      v2 = v52;
      sub_19664("memory exhausted");
      goto LABEL_64;
    }
    v29 = v26;
    v30 = v25;
    v31 = 8 * v25;
    v131 = v27;
    v32 = (char *)v27 + ((2 * v26 + 7) & 0xFFFFFFF8);
    memcpy(v27, v2, v30 * 2);
    memcpy(v32, src, v31);
    if ( v2 != v142 )
      free(v2);
    v4 = &v28[v30 - 1];
    v3 = (int *)&v32[v31 - 8];
    if ( yydebug )
      _fprintf_chk(stderr, 1, "Stack size increased to %lu\n", v127);
    if ( v4 >= &v28[v29 - 1] )
      break;
LABEL_38:
    src = v32;
    v2 = v131;
    if ( yydebug )
LABEL_39:
      _fprintf_chk(stderr, 1, "Entering state %d\n", v1);
  }
  v41 = 1;
  v42 = v4;
  v2 = v28;
LABEL_64:
  v33 = yychar;
  if ( yychar == -2 )
    goto LABEL_69;
  if ( (unsigned int)yychar > 0x1C9 )
  {
    v43 = 2;
    goto LABEL_68;
  }
LABEL_84:
  v43 = *((unsigned __int8 *)&asc_8E108[1100] + v33);
LABEL_68:
  sub_1919C("Cleanup: discarding lookahead", v43);
LABEL_69:
  if ( yydebug )
    sub_19024(v2, (unsigned int)v42);
  while ( v42 != v2 )
  {
    v44 = *v42--;
    sub_1919C("Cleanup: popping", word_8F54C[v44 + 326]);
  }
  if ( v2 != v142 )
    free(v2);
  if ( ptr != v144 )
    free(ptr);
  return v41;
}
// 1973C: too many cbuild loops
// 1BB04: variable 'v125' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// 9E0: using guessed type int elf_hash_chain[664];
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8E108: using guessed type __int16 asc_8E108[436];
// 8F54C: using guessed type unsigned __int16[1304];
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B6008: using guessed type int old_config_style;
// 1074C0: using guessed type _DWORD *;
// 1074C4: using guessed type _DWORD *;
// 1074C8: using guessed type _DWORD *;
// 1074CC: using guessed type _DWORD *;
// 1074D0: using guessed type _DWORD *;
// 1074D4: using guessed type _DWORD *;
// 1074D8: using guessed type int dword_1074D8;
// 107D58: using guessed type int yydebug;
// 107D5C: using guessed type int yychar;
// 107D60: using guessed type double yylval;
// 107D68: using guessed type int yynerrs;

//----- (0001BBB4) --------------------------------------------------------
const char *__fastcall sub_1BBB4(unsigned int a1)
{
  if ( a1 > 0x1C9 )
    return "$undefined";
  else
    return (&off_B36E0)[(unsigned __int8)asc_8E108[a1 + 2200]];
}
// B36E0: using guessed type char *off_B36E0;

//----- (0001BC38) --------------------------------------------------------
int __fastcall sub_1BC38(int a1, _DWORD *a2)
{
  int v3; // r1
  int v4; // r2
  int v5; // r1

  if ( !a2 || a2[2] || a2[3] != -1 || a1 == -1 )
    return -1;
  v3 = a2[1];
  v4 = (unsigned __int8)a1;
  a2[3] = (unsigned __int8)a1;
  if ( v3 )
    conf_file_sum -= (unsigned __int8)a1;
  if ( (unsigned __int8)a1 == 10 )
  {
    v5 = a2[7];
    a2[4] = a2[6];
    a2[5] = v5;
    a2[7] = -1;
  }
  --a2[5];
  return v4;
}
// 108170: using guessed type int conf_file_sum;

//----- (0001BD14) --------------------------------------------------------
_DWORD *__fastcall sub_1BD14(const char *a1, int a2)
{
  size_t v4; // r6
  _DWORD *v5; // r0
  _DWORD *v6; // r4
  int v7; // r0
  void *v9; // r0

  v4 = strlen(a1);
  v5 = sub_63BA4(0, v4 + 52, 0, 1);
  v5[4] = 1;
  v6 = v5;
  v5[3] = -1;
  memcpy(v5 + 12, a1, v4);
  if ( a2 )
  {
    v7 = fopen64(a1, a2);
    v6[1] = v7;
    if ( !v7 )
    {
      v9 = v6;
      v6 = 0;
      free(v9);
    }
  }
  return v6;
}
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (0001BDD8) --------------------------------------------------------
void __fastcall sub_1BDD8(_DWORD *a1)
{
  FILE *v2; // r0

  if ( a1 )
  {
    v2 = (FILE *)a1[1];
    if ( v2 )
      fclose(v2);
    free(a1);
  }
}

//----- (0001BE54) --------------------------------------------------------
int __fastcall sub_1BE54(_DWORD *a1)
{
  int result; // r0
  FILE *v3; // r2
  int v4; // r1
  int v5; // r3
  int v6; // r3
  char *v7; // r1
  char *v8; // r3
  char *v9; // r2
  int v10; // lr
  char *v11; // r3

  if ( a1 && !a1[2] )
  {
    result = a1[3];
    v3 = (FILE *)a1[1];
    if ( result != -1 )
    {
      a1[3] = -1;
      if ( v3 )
        conf_file_sum += result;
      ++a1[5];
      goto LABEL_7;
    }
    if ( v3 )
    {
      while ( 1 )
      {
        result = fgetc(v3);
        if ( result == -1 )
        {
          v7 = (char *)a1[5];
          goto LABEL_15;
        }
        v6 = a1[5] + 1;
        if ( result <= 127 )
          break;
        v3 = (FILE *)a1[1];
        a1[5] = v6;
      }
      a1[5] = v6;
      conf_file_sum += result;
LABEL_7:
      if ( result != 10 )
        return result;
      goto LABEL_8;
    }
    v7 = (char *)a1[5];
    result = remote_config[dword_107CF0];
    v8 = (char *)&remote_config[dword_107CF0];
    if ( (unsigned int)result > 0x7F )
    {
      v10 = v7 - v8;
      v11 = v8 + 1;
      do
      {
        v7 = &v11[v10];
        v9 = v11;
        a1[5] = &(v11++)[v10];
        result = (unsigned __int8)*v9;
      }
      while ( (unsigned int)result > 0x7F );
    }
    else
    {
      v9 = (char *)&remote_config[dword_107CF0];
    }
    if ( result )
    {
      a1[5] = v7 + 1;
      dword_107CF0 = v9 + 1 - (char *)remote_config;
      goto LABEL_7;
    }
    dword_107CF0 = v9 - (char *)remote_config;
LABEL_15:
    if ( v7 )
    {
LABEL_8:
      v4 = a1[5];
      v5 = a1[4] + 1;
      a1[6] = a1[4];
      a1[7] = v4;
      a1[4] = v5;
      a1[5] = 0;
      return 10;
    }
  }
  return -1;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// 1074F0: using guessed type unsigned __int8 remote_config[1024];
// 107CF0: using guessed type int dword_107CF0;
// 108170: using guessed type int conf_file_sum;

//----- (0001BFFC) --------------------------------------------------------
int sub_1BFFC()
{
  int v0; // r4
  const unsigned __int16 **v1; // r0
  char *v2; // r2
  int v3; // t1
  void *v4; // r0
  int v5; // r2

  v0 = (unsigned __int8)yytext;
  if ( yytext )
  {
    v1 = _ctype_b_loc();
    v2 = &yytext;
    while ( ((*v1)[v0] & 0x2000) != 0 )
    {
      v3 = (unsigned __int8)*++v2;
      v0 = v3;
      if ( !v3 )
        goto LABEL_6;
    }
    v4 = sub_63D08(&yytext);
    v5 = 419;
    LODWORD(yylval) = v4;
  }
  else
  {
LABEL_6:
    v5 = 447;
    LODWORD(yylval) = 447;
  }
  return v5;
}
// 107D60: using guessed type double yylval;
// 107D6C: using guessed type char yytext;

//----- (0001C0BC) --------------------------------------------------------
char *__fastcall sub_1C0BC(int a1)
{
  unsigned int v1; // r0
  char *result; // r0

  v1 = a1 - 258;
  if ( v1 > 0xC7 )
    return "(keyword not found)";
  result = (&keyword_text)[v1];
  if ( !result )
    return "(keyword not found)";
  return result;
}
// B3BD0: using guessed type char *keyword_text;

//----- (0001C148) --------------------------------------------------------
bool __fastcall sub_1C148(const char *a1, int a2)
{
  _BOOL4 v2; // r3

  v2 = a1 == 0;
  if ( dword_B93D8 )
    v2 = 1;
  if ( v2 )
    return 0;
  dword_B93D8 = (int)sub_1BD14(a1, a2);
  return dword_B93D8 != 0;
}
// B93D8: using guessed type int dword_B93D8;

//----- (0001C1CC) --------------------------------------------------------
int sub_1C1CC()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  int v3; // [sp+4h] [bp-8h]

  v0 = (_DWORD *)dword_B93D8;
  if ( dword_B93D8 )
  {
    do
    {
      v1 = (_DWORD *)*v0;
      sub_1BDD8(v0);
      v0 = v1;
    }
    while ( v1 );
  }
  dword_B93D8 = 0;
  return v3;
}
// 1C210: variable 'v3' is possibly undefined
// B93D8: using guessed type int dword_B93D8;

//----- (0001C24C) --------------------------------------------------------
bool sub_1C24C()
{
  _DWORD *v0; // r5
  _BOOL4 v1; // r6
  _DWORD *v2; // r0
  int v3; // r6
  _DWORD *v4; // r4

  v0 = (_DWORD *)dword_B93D8;
  if ( !dword_B93D8 )
    return 0;
  v2 = *(_DWORD **)dword_B93D8;
  v3 = *(_DWORD *)(dword_B93D8 + 8);
  *(_DWORD *)(dword_B93D8 + 8) = 1;
  v1 = v3 == 0;
  if ( v2 )
  {
    do
    {
      v4 = (_DWORD *)*v2;
      sub_1BDD8(v2);
      v2 = v4;
    }
    while ( v4 );
  }
  *v0 = 0;
  return v1;
}
// B93D8: using guessed type int dword_B93D8;

//----- (0001C2E8) --------------------------------------------------------
int __fastcall sub_1C2E8(const char *a1, int a2)
{
  _DWORD *v3; // r2
  int v4; // r1

  if ( !a1 )
    return 0;
  v3 = sub_1BD14(a1, a2);
  if ( !v3 )
    return 0;
  v4 = dword_B93D8;
  dword_B93D8 = (int)v3;
  *v3 = v4;
  return 1;
}
// B93D8: using guessed type int dword_B93D8;

//----- (0001C364) --------------------------------------------------------
_DWORD *sub_1C364()
{
  _DWORD *result; // r0

  result = (_DWORD *)dword_B93D8;
  if ( dword_B93D8 )
  {
    if ( *(_DWORD *)dword_B93D8 )
    {
      dword_B93D8 = *(_DWORD *)dword_B93D8;
      sub_1BDD8(result);
      return &dword_0 + 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// B93D8: using guessed type int dword_B93D8;

//----- (0001C3DC) --------------------------------------------------------
int sub_1C3DC()
{
  _DWORD *v0; // r3
  int result; // r0

  v0 = (_DWORD *)dword_B93D8;
  if ( !dword_B93D8 )
    return 0;
  result = 0;
  do
  {
    v0 = (_DWORD *)*v0;
    ++result;
  }
  while ( v0 );
  return result;
}
// B93D8: using guessed type int dword_B93D8;

//----- (0001C450) --------------------------------------------------------
int sub_1C450()
{
  int result; // r0

  result = dword_B93D8;
  if ( dword_B93D8 )
    return *(_DWORD *)(dword_B93D8 + 4) != 0;
  return result;
}
// B93D8: using guessed type int dword_B93D8;

//----- (0001C4B8) --------------------------------------------------------
int sub_1C4B8()
{
  return dword_B93D8;
}
// B93D8: using guessed type int dword_B93D8;

//----- (0001C50C) --------------------------------------------------------
_BYTE *__fastcall sub_1C50C(char *a1)
{
  size_t v2; // r0
  unsigned int v3; // r8
  size_t v4; // r9
  _BYTE *v5; // r7

  v2 = strlen(a1);
  v3 = v2 + 3;
  v4 = v2;
  v5 = sub_63BA4(0, v2 + 3, 0, 0);
  if ( *a1 == 34 || strcspn(a1, "{}(),;|=") >= v4 && !strchr(a1, 32) )
    sub_6D4DC(v5, (unsigned __int8 *)a1, v3);
  else
    sub_6C054((int)v5, v3, (unsigned __int8 *)"\"%s\"", a1);
  return v5;
}

//----- (0001C5E8) --------------------------------------------------------
int sub_1C5E8()
{
  double v0; // d0
  Elf32_Dyn **v1; // r11
  char *v2; // r2
  int v3; // r4
  const unsigned __int16 **v4; // r6
  Elf32_Dyn *v5; // r7
  __int32 d_tag; // r5
  int v7; // r0
  int v8; // r4
  int v9; // r1
  char *v10; // r0
  char *v11; // r5
  int v12; // r0
  int v13; // r11
  int v14; // r3
  _DWORD *v15; // r2
  int v16; // r8
  int v17; // r5
  int v18; // r6
  _DWORD *v19; // r0
  char *v20; // r5
  bool v21; // zf
  int v22; // r0
  int v23; // r1
  int v24; // r0
  int v25; // r2
  Elf32_Dyn *v26; // r5
  int v28; // r2
  unsigned int v29; // r3
  int v30; // r1
  _BYTE *v31; // r0
  int v32; // r2
  char *v33; // r3
  __int16 v34; // r3
  int v35; // r2
  const unsigned __int16 *v36; // r6
  char *v37; // r2
  int v38; // t1
  unsigned __int16 v39; // r3
  _BOOL4 v40; // r0
  int v41; // r2
  char *v42; // r1
  int v43; // r3
  int v44; // t1
  int v45; // r4
  int v46; // r5
  int v47; // r3
  char *v48; // r3
  int v49; // r2
  int v50; // t1
  int v51; // r3
  int *v52; // r4
  int v53; // r0
  bool v54; // zf
  int v55; // r0
  int v56; // r2
  char *v57; // r1
  int v58; // t1
  int *v59; // r4
  char *s; // [sp+Ch] [bp-28h]
  char *sb; // [sp+Ch] [bp-28h]
  char *sa; // [sp+Ch] [bp-28h]
  char *nptra; // [sp+10h] [bp-24h]
  char *nptr; // [sp+10h] [bp-24h]
  Elf32_Dyn **v65; // [sp+14h] [bp-20h]
  int v66; // [sp+24h] [bp-10h]
  int v67; // [sp+28h] [bp-Ch] BYREF

  v1 = &GLOBAL_OFFSET_TABLE_;
  v66 = 0;
  v2 = (char *)dword_B93D8;
  do
  {
    while ( 1 )
    {
      v3 = sub_1BE54(v2);
      if ( v3 == -1 )
      {
        v3 = (int)sub_1C364();
        if ( !v3 )
          return v3;
        v3 = 447;
        goto LABEL_26;
      }
      v4 = _ctype_b_loc();
      v5 = v1[424];
      d_tag = v5->d_tag;
      if ( ((*v4)[v3] & 0x2000) == 0 )
        break;
      if ( d_tag )
      {
        if ( v3 == 10 )
        {
LABEL_25:
          v3 = 447;
          dword_B93DC = 0;
          goto LABEL_26;
        }
        v2 = (char *)dword_B93D8;
      }
      else
      {
        if ( v3 == 59 )
          goto LABEL_25;
        v2 = (char *)dword_B93D8;
      }
    }
    if ( d_tag )
    {
      if ( v3 == 10 )
        goto LABEL_25;
    }
    else if ( v3 == 59 )
    {
      goto LABEL_25;
    }
    s = (char *)v1[669];
    if ( strchr(s, v3) && !dword_B93DC )
    {
      if ( v3 == 61 )
        dword_B93DC = d_tag != 0;
      LOWORD(v1[458]->d_tag) = (unsigned __int8)v3;
      goto LABEL_26;
    }
    v7 = v3;
    v8 = 0;
    nptra = (char *)dword_B93D8;
    sub_1BC38(v7, (_DWORD *)dword_B93D8);
    v9 = *((_DWORD *)nptra + 5);
    *((_DWORD *)nptra + 8) = *((_DWORD *)nptra + 4);
    *((_DWORD *)nptra + 9) = v9;
    v10 = nptra;
    v65 = v1;
    nptr = (char *)v1[458];
    v11 = nptr;
    while ( 1 )
    {
      v12 = sub_1BE54(v10);
      v13 = v12;
      if ( v12 == -1 )
      {
        v14 = -1;
        v1 = v65;
        v15 = (_DWORD *)dword_B93D8;
        goto LABEL_30;
      }
      *v11++ = v12;
      if ( ((*v4)[v12] & 0x2000) != 0 )
      {
        v14 = v12;
        v1 = v65;
        v15 = (_DWORD *)dword_B93D8;
        if ( v12 != 34 )
          goto LABEL_30;
        goto LABEL_37;
      }
      if ( v5->d_tag )
      {
        if ( v12 == 10 )
        {
          v14 = 10;
          v1 = v65;
          v15 = (_DWORD *)dword_B93D8;
          goto LABEL_30;
        }
      }
      else if ( v12 == 59 )
      {
        v14 = 59;
        v1 = v65;
        v15 = (_DWORD *)dword_B93D8;
        goto LABEL_30;
      }
      if ( v12 == 34 )
        break;
      if ( !dword_B93DC && strchr(s, v12) )
      {
        v14 = v13;
        v15 = (_DWORD *)dword_B93D8;
        v1 = v65;
        goto LABEL_30;
      }
      v10 = (char *)dword_B93D8;
      if ( v13 == 35 )
      {
        v1 = v65;
        do
        {
          v24 = sub_1BE54(v10);
          v14 = v24;
          if ( v24 == -1 )
          {
            v15 = (_DWORD *)dword_B93D8;
            goto LABEL_30;
          }
          v21 = v24 == 10;
          v10 = (char *)dword_B93D8;
        }
        while ( !v21 );
        v15 = (_DWORD *)dword_B93D8;
        goto LABEL_30;
      }
      if ( ++v8 == 1025 )
      {
        v25 = dword_B93D8;
        v1 = v65;
LABEL_55:
        *((_BYTE *)&word_32 + (_DWORD)nptr) = 0;
        sub_64E00(
          3,
          "configuration item on line %d longer than limit of %lu, began with '%s'",
          *(_DWORD *)(v25 + 16),
          50,
          nptr);
        if ( sub_1C450() )
          exit(1024);
        v26 = v1[620];
LABEL_57:
        v3 = 0;
        v26->d_tag = 0;
        return v3;
      }
    }
    v1 = v65;
    v15 = (_DWORD *)dword_B93D8;
LABEL_37:
    sa = (char *)v4;
    v18 = v8;
    v19 = v15;
    v20 = &nptr[v8 - 1];
    while ( 1 )
    {
      v22 = sub_1BE54(v19);
      v14 = v22;
      if ( v22 == -1 )
      {
        v8 = v18;
        v66 = 1;
        v4 = (const unsigned __int16 **)sa;
        v15 = (_DWORD *)dword_B93D8;
        goto LABEL_30;
      }
      v21 = v22 == 34;
      if ( v22 != 34 )
        v21 = v22 == 10;
      v19 = (_DWORD *)dword_B93D8;
      if ( v21 )
        break;
      ++v18;
      *++v20 = v14;
      if ( v18 == 1025 )
      {
        v25 = (int)v19;
        goto LABEL_55;
      }
    }
    v8 = v18;
    if ( v14 != 34 )
      v23 = 1;
    v4 = (const unsigned __int16 **)sa;
    v15 = (_DWORD *)dword_B93D8;
    if ( v14 == 34 )
    {
      v66 = 1;
      v14 = sub_1BE54((_DWORD *)dword_B93D8);
      v15 = (_DWORD *)dword_B93D8;
    }
    else
    {
      v66 = v23;
    }
LABEL_30:
    sb = (char *)v15;
    sub_1BC38(v14, v15);
    nptr[v8] = 0;
    v2 = sb;
  }
  while ( !v8 );
  v16 = (unsigned __int8)*nptr;
  v17 = dword_B93DC | v66;
  if ( dword_B93DC | v66 )
  {
    if ( v16 != 45 )
      goto LABEL_33;
    v28 = *((unsigned __int8 *)&dword_0 + (_DWORD)nptr + 1);
    if ( v28 == 52 )
    {
      v3 = 325;
    }
    else
    {
      if ( v28 != 54 )
      {
LABEL_33:
        if ( dword_B93DC == 1 )
          dword_B93DC = 0;
        return sub_1BFFC();
      }
      v3 = 327;
    }
LABEL_26:
    v1[620]->d_tag = v3;
    return v3;
  }
  if ( !*nptr )
  {
LABEL_131:
    if ( sscanf(nptr, "%u", &v67) != 1 )
    {
      v16 = (unsigned __int8)*nptr;
      goto LABEL_81;
    }
    if ( v67 < 0 )
    {
      v16 = (unsigned __int8)*nptr;
      goto LABEL_81;
    }
LABEL_113:
    v52 = _errno_location();
    *v52 = 0;
    v53 = strtol(nptr, 0, 10);
    v26 = v1[620];
    v26->d_tag = v53;
    if ( v53 )
      return 319;
    v54 = *v52 == 34;
    if ( *v52 != 34 )
      v54 = *v52 == 22;
    if ( !v54 )
      return 319;
    sub_64E00(3, "Integer cannot be represented: %s", nptr);
    goto LABEL_119;
  }
  v29 = 1961801593;
  v30 = (unsigned __int8)*nptr;
  v3 = 940;
  v31 = nptr + 1;
  while ( 1 )
  {
    for ( ; (unsigned __int8)v29 != v30; v29 = *(&v1[400]->d_tag + v3) )
    {
      v3 = v29 >> 21;
      if ( !(v29 >> 21) )
        goto LABEL_77;
    }
    v30 = (unsigned __int8)*v31;
    if ( !*v31 )
      break;
    v3 = (v29 >> 10) & 0x7FF;
    ++v31;
    if ( !v3 )
      goto LABEL_77;
    v29 = *(&v1[400]->d_tag + v3);
  }
  v51 = (v29 >> 8) & 3;
  if ( v51 != 3 )
  {
    dword_B93DC = v51;
    if ( v3 == 407 && !v5->d_tag )
      dword_B93DC = 0;
    goto LABEL_26;
  }
LABEL_77:
  v32 = (unsigned __int8)nptr[v16 == 45];
  v33 = &nptr[v16 == 45];
  if ( !*v33 )
  {
LABEL_112:
    if ( v16 == 45 )
      goto LABEL_113;
    goto LABEL_131;
  }
  while ( ((*v4)[v32] & 0x800) != 0 )
  {
    v32 = (unsigned __int8)*++v33;
    if ( !*v33 )
      goto LABEL_112;
  }
LABEL_81:
  if ( v16 == 48 )
  {
    if ( (*_ctype_tolower_loc())[*((unsigned __int8 *)&dword_0 + (_DWORD)nptr + 1)] == 120 )
    {
      v34 = *((unsigned __int8 *)&dword_0 + (_DWORD)nptr + 2);
      if ( !*((_BYTE *)&dword_0 + (_DWORD)nptr + 2) )
      {
LABEL_128:
        if ( (*_ctype_tolower_loc())[*((unsigned __int8 *)&dword_0 + (_DWORD)nptr + 1)] == 120 )
        {
          v26 = v1[620];
          v55 = sscanf(nptr + 2, "%x", v26);
          goto LABEL_123;
        }
LABEL_122:
        v26 = v1[620];
        v55 = sscanf(nptr, "%u", v26);
LABEL_123:
        if ( v55 == 1 )
          return 434;
        sub_64E00(3, "U_int cannot be represented: %s", nptr);
LABEL_119:
        if ( !sub_1C450() )
          goto LABEL_57;
LABEL_120:
        exit(1);
      }
      v35 = 2;
      v17 = 1;
      goto LABEL_84;
    }
  }
  else if ( !v16 )
  {
    goto LABEL_122;
  }
  v34 = v16;
  v35 = 0;
LABEL_84:
  v36 = *v4;
  v37 = &nptr[v35];
  while ( 1 )
  {
    v39 = v36[v34];
    if ( v17 )
    {
      if ( (v39 & 0x1000) == 0 )
        break;
      goto LABEL_86;
    }
    if ( (v39 & 0x800) == 0 )
      break;
LABEL_86:
    v38 = (unsigned __int8)*++v37;
    v34 = v38;
    if ( !v38 )
    {
      if ( v16 != 48 )
        goto LABEL_122;
      goto LABEL_128;
    }
  }
  v40 = ((v16 - 43) & 0xFD) == 0;
  v41 = (unsigned __int8)nptr[v40];
  v42 = &nptr[v40];
  if ( !nptr[v40] )
    return sub_1BFFC();
  v43 = 0;
  while ( 1 )
  {
    v45 = v40 + v43;
    if ( (v36[v41] & 0x800) == 0 )
      break;
    v44 = (unsigned __int8)*++v42;
    v41 = v44;
    ++v43;
    if ( !v44 )
      goto LABEL_141;
  }
  if ( v41 == 46 )
  {
    v56 = (unsigned __int8)nptr[++v45];
    v57 = &nptr[v45];
    if ( nptr[v45] )
    {
      while ( (v36[v56] & 0x800) != 0 )
      {
        v58 = (unsigned __int8)*++v57;
        v56 = v58;
        ++v43;
        ++v45;
        if ( !v58 )
          goto LABEL_140;
      }
      goto LABEL_94;
    }
LABEL_140:
    if ( !v43 )
      return sub_1BFFC();
LABEL_141:
    v59 = _errno_location();
    *v59 = 0;
    strtod(nptr, 0);
    *(double *)v1[620] = v0;
    if ( v0 != 0.0 || *v59 != 34 )
      return 289;
    sub_64E00(3, "Double too large to represent: %s", nptr);
    goto LABEL_120;
  }
LABEL_94:
  if ( v43 )
  {
    if ( !nptr[v45] )
      goto LABEL_141;
    v46 = (unsigned __int8)nptr[v45];
    if ( (*_ctype_tolower_loc())[v46] == 101 )
    {
      v47 = v45 + 1;
      if ( ((nptr[v45 + 1] - 43) & 0xFD) == 0 )
        v47 = v45 + 2;
      v48 = &nptr[v47 - 1];
      while ( 1 )
      {
        v50 = (unsigned __int8)*++v48;
        v49 = v50;
        if ( !v50 )
          break;
        if ( (v36[v49] & 0x800) == 0 )
          return sub_1BFFC();
      }
      goto LABEL_141;
    }
  }
  return sub_1BFFC();
}
// 1C994: variable 'v23' is possibly undefined
// 1CEB4: variable 'v0' is possibly undefined
// 0: using guessed type int dword_0;
// 32: using guessed type __int16;
// B5584: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;
// B93D8: using guessed type int dword_B93D8;
// B93DC: using guessed type int dword_B93DC;

//----- (0001CF78) --------------------------------------------------------
int __fastcall sub_1CF78(int result)
{
  dword_B93E0 = 1;
  dword_B93E4 = result;
  return result;
}
// B93E0: using guessed type int dword_B93E0;
// B93E4: using guessed type int dword_B93E4;

//----- (0001CFD4) --------------------------------------------------------
char *__fastcall sub_1CFD4(int a1)
{
  int *v2; // r4
  int v3; // r2
  int v4; // r6
  char *result; // r0

  v2 = _errno_location();
  v3 = a1;
  v4 = *v2;
  result = sub_64E00(7, "ntpd not compiled for debugging (signal %d)", v3);
  *v2 = v4;
  return result;
}

//----- (0001D044) --------------------------------------------------------
const char *__fastcall sub_1D044(const char *result, int a2, unsigned __int8 *a3, int *a4)
{
  char v6[256]; // [sp+4h] [bp-108h] BYREF

  if ( unexpected_error_cnt <= 99 )
  {
    sub_64E00(3, "%s:%d: unexpected error:", result, a2);
    sub_6B6F8((int)v6, 0x100u, a3, a4);
    result = sub_64E00(3, (unsigned __int8 *)"%s", v6);
    if ( ++unexpected_error_cnt == 100 )
      return sub_64E00(3, "Too many errors.  Shutting up.");
  }
  return result;
}
// B93F0: using guessed type int unexpected_error_cnt;

//----- (0001D124) --------------------------------------------------------
void __fastcall __noreturn sub_1D124(const char *a1, int a2, unsigned __int8 *a3, int *a4)
{
  char v8[256]; // [sp+4h] [bp-104h] BYREF

  sub_6F4D8(0);
  sub_64E00(3, "%s:%d: fatal error:", a1, a2);
  sub_6B6F8((int)v8, 0x100u, a3, a4);
  sub_64E00(3, (unsigned __int8 *)"%s", v8);
  sub_64E00(3, "exiting (due to fatal error in library)");
  abort();
}

//----- (0001D1CC) --------------------------------------------------------
void __fastcall __noreturn sub_1D1CC(const char *a1, int a2, int a3, const char *a4)
{
  const char *v8; // r0

  sub_6ED00(0);
  v8 = sub_6ED7C(a3);
  sub_64E00(3, "%s:%d: %s(%s) failed", a1, a2, v8, a4);
  sub_64E00(3, "exiting (due to assertion failure)");
  abort();
}

//----- (0001D250) --------------------------------------------------------
void __noreturn sub_1D250()
{
  while ( 1 )
    sleep(0xAu);
}

//----- (0001D284) --------------------------------------------------------
int __fastcall sub_1D284(int *a1, char ***a2)
{
  int v4; // r1
  char **v5; // r2
  unsigned int v6; // r0
  int v8; // [sp+4h] [bp-8h]

  v4 = *a1;
  v5 = *a2;
  if ( dword_B93E8 )
  {
    v6 = dword_B93EC;
  }
  else
  {
    v6 = sub_68A44((unsigned int)&ntpdOptions, v4, v5);
    v4 = *a1;
    v5 = *a2;
    dword_B93EC = v6;
  }
  *a1 = v4 - v6;
  *a2 = &v5[v6];
  dword_B93E8 = 1;
  return v8;
}
// 1D2DC: variable 'v8' is possibly undefined
// B93E8: using guessed type int dword_B93E8;
// B93EC: using guessed type int dword_B93EC;

//----- (0001D338) --------------------------------------------------------
void __fastcall __noreturn sub_1D338(int a1, char **a2)
{
  int v2; // r0
  int v3; // r4
  __mode_t v4; // r0
  int *v5; // r8
  int v6; // r12
  const char *v7; // r4
  int v8; // r5
  const char *v9; // r3
  __uid_t v10; // r2
  void *v11; // r3
  int *v12; // r5
  int v13; // r4
  const char **v14; // r5
  int v15; // t1
  int v16; // r0
  int v17; // r4
  int v18; // r4
  int v19; // r5
  int v20; // r4
  void (__fastcall *v21)(int); // r3
  int v22; // r4
  char *v23; // r1
  char *v24; // r0
  char *v25; // r0
  const char *v26; // r0
  __time_t priority_max; // r5
  int v28; // r1
  int v29; // r3
  __pid_t v30; // r0
  int v31; // r2
  __time_t priority_min; // r0
  int v33; // r4
  const char *v34; // r0
  int v35; // r7
  time_t v36; // r0
  int v37; // r3
  int v38; // r11
  time_t v39; // r0
  int v40; // r1
  fd_set *v41; // r3
  int v42; // r0
  int v43; // r0
  int v44; // r1
  int v45; // r2
  int v46; // r3
  int i; // r3
  char *v48; // lr
  int v49; // r12
  int v50; // [sp+Ch] [bp-4C8h]
  const char *v51; // [sp+24h] [bp-4B0h]
  char **v52; // [sp+28h] [bp-4ACh] BYREF
  int v53; // [sp+2Ch] [bp-4A8h] BYREF
  int v54[2]; // [sp+34h] [bp-4A0h] BYREF
  struct timeval th; // [sp+3Ch] [bp-498h] BYREF
  int v56; // [sp+44h] [bp-490h] BYREF
  int v57; // [sp+48h] [bp-48Ch] BYREF
  fd_set v58; // [sp+4Ch] [bp-488h] BYREF
  char v59[1032]; // [sp+CCh] [bp-408h] BYREF

  v53 = a1;
  v52 = a2;
  pthread_attr_init((pthread_attr_t *)&v58);
  v2 = pthread_attr_setstacksize((pthread_attr_t *)&v58, 0x8000u);
  if ( v2 )
  {
    v25 = strerror(v2);
    sub_64E00(3, "my_pthread_warmup: pthread_attr_setstacksize() -> %s", v25);
  }
  v3 = pthread_create((pthread_t *)&th, (const pthread_attr_t *)&v58, (void *(*)(void *))sub_1D250, 0);
  pthread_attr_destroy((pthread_attr_t *)&v58);
  if ( v3 )
  {
    v24 = strerror(v3);
    sub_64E00(3, "my_pthread_warmup: pthread_create() -> %s", v24);
  }
  else
  {
    pthread_cancel(th.tv_sec);
    pthread_join(th.tv_sec, 0);
  }
  v4 = umask(0);
  if ( !v4 )
    v4 = 18;
  umask(v4);
  v5 = &saved_argc;
  saved_argc = v53;
  v6 = (int)*v52;
  saved_argv = (int)v52;
  progname = v6;
  initializing = 1;
  sub_1D284(&v53, &v52);
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[165] + (_DWORD)off_B611C) & 0xF) != 0
    || (*(int *)((_BYTE *)&elf_hash_bucket[229] + (_DWORD)off_B611C) & 0xF) != 0
    || (*(int *)((_BYTE *)&elf_hash_bucket[261] + (_DWORD)off_B611C) & 0xF) != 0 )
  {
    nofork = 1;
  }
  sub_64EFC((char *)progname, 61440, 1);
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[117] + (_DWORD)off_B611C) & 0xF) != 0 )
  {
    v26 = *(const char **)((char *)&elf_hash_bucket[119] + (_DWORD)off_B611C);
    v51 = v26;
    syslogit = 0;
    sub_64FEC(v26, 0);
  }
  else
  {
    if ( nofork )
      msyslog_term = 1;
    v51 = 0;
    if ( (*(int *)((_BYTE *)&elf_hash_bucket[261] + (_DWORD)off_B611C) & 0xF) != 0 )
      syslogit = 0;
  }
  sub_64E00(5, "%s: Starting", Version);
  sub_6C054((int)v59, 0x400u, "Command line:");
  v7 = &v59[strlen(v59)];
  if ( saved_argc > 0 )
  {
    v8 = 0;
    do
    {
      v9 = *(const char **)(saved_argv + 4 * v8++);
      sub_6C054((int)v7, 1024 - (v7 - v59), (unsigned __int8 *)" %s", v9);
      v7 += strlen(v7);
    }
    while ( saved_argc > v8 );
  }
  sub_64E00(6, (unsigned __int8 *)"%s", v59);
  sub_6ED00((int (__fastcall *)(const char *, int, int, const char *))sub_1D1CC);
  sub_6F4D8((int (__fastcall *)(const char *, int, int, int))sub_1D124);
  sub_6F45C((int (__fastcall *)(const char *, int, int, int))sub_1D044);
  v10 = getuid();
  v11 = off_B611C;
  if ( v10 && (*(int *)((_BYTE *)&elf_hash_bucket[261] + (_DWORD)off_B611C) & 0xF) == 0 )
  {
    msyslog_term = 1;
    sub_64E00(3, "must be run as root, not uid %ld", v10);
    exit(1);
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[133] + (_DWORD)off_B611C) & 0xF) != 0 )
    listen_to_virtual_ips = 0;
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[85] + (_DWORD)off_B611C) & 0xF) != 0 )
  {
    v12 = *(int **)((char *)&elf_hash_bucket[88] + (_DWORD)off_B611C);
    v13 = *v12 - 1;
    if ( *v12 > 0 )
    {
      v14 = (const char **)(v12 + 1);
      do
      {
        v15 = (int)v14[1];
        ++v14;
        --v13;
        if ( sub_64054(v15, 0, &v58) )
          v16 = 5;
        else
          v16 = 4;
        sub_15E04(v16, *v14, -1, 0);
      }
      while ( v13 != -1 );
      v11 = off_B611C;
    }
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[181] + (_DWORD)v11) & 0xF) != 0 )
    priority_done = 0;
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[213] + (_DWORD)v11) & 0xF) != 0 )
  {
    config_priority = *(int *)((char *)&elf_hash_bucket[215] + (_DWORD)v11);
    config_priority_override = 1;
    priority_done = 0;
  }
  v17 = *(int *)((char *)&elf_hash_bucket[373] + (_DWORD)v11);
  v56 = -1;
  v57 = -1;
  v18 = v17 & 0xF;
  if ( v18 )
  {
    v18 = *(int *)((char *)&elf_hash_bucket[375] + (_DWORD)v11);
    if ( v18 > 0 )
    {
      nofork = 0;
      if ( pipe(&v56) )
      {
        v22 = *_errno_location();
        v23 = "Pipe creation failed for --wait-sync: %m";
        goto LABEL_58;
      }
      waitsync_fd_to_close = v57;
    }
    else
    {
      v18 = 0;
    }
  }
  sub_64244();
  sub_5F724(v54);
  sub_68B80(v54[1] * v54[0]);
  v19 = nofork;
  if ( nofork )
  {
LABEL_38:
    sub_FB7C((_BYTE *)&dword_0 + 3, 0x32000u);
    sub_FB7C(byte_8, 0xFFFFFFFFFFF00000LL);
    sub_6D6F0(1, (void (*)(int))sub_1CF78);
    sub_6D6F0(2, (void (*)(int))sub_1CF78);
    sub_6D6F0(3, (void (*)(int))sub_1CF78);
    sub_6D6F0(15, (void (*)(int))sub_1CF78);
    sub_6D6F0(7, (void (*)(int))sub_1CF78);
    sub_6D6F0(10, (void (*)(int))sub_1CFD4);
    sub_6D6F0(12, (void (*)(int))sub_1CFD4);
    sub_6D6F0(13, (void (*)(int))((char *)&dword_0 + 1));
    if ( !ssl_init_done )
      sub_6C6B8();
    sub_61B14();
    sub_418A8();
    sub_3FFBC();
    sub_30C68();
    sub_40CF0();
    sub_3F3E4();
    sub_2430C();
    sub_31958();
    sub_395B0();
    if ( !priority_done )
    {
      priority_max = sched_get_priority_max(1);
      th.tv_sec = priority_max;
      if ( config_priority_override )
      {
        priority_min = sched_get_priority_min(1);
        if ( priority_max >= config_priority )
        {
          if ( priority_min < config_priority )
            priority_min = config_priority;
          th.tv_sec = priority_min;
        }
        else
        {
          th.tv_sec = priority_max;
        }
      }
      if ( sched_setscheduler(0, 1, (const struct sched_param *)&th) == -1 )
      {
        sub_64E00(3, "sched_setscheduler(): %m");
        v28 = priority_done;
      }
      else
      {
        v28 = ++priority_done;
      }
      if ( !v28 )
      {
        if ( setpriority(0, 0, -12) == -1 )
        {
          sub_64E00(3, "setpriority() error: %m");
          v29 = priority_done;
        }
        else
        {
          v29 = ++priority_done;
        }
        if ( !v29 )
          sub_64E00(3, "set_process_priority: No way found to improve our priority");
      }
    }
    sub_38D98();
    sub_15CF0();
    sub_2F40C();
    sub_30CD4(1);
    sub_13380(v53, (int)v52);
    sub_305F8((char *)&dword_0 + 1);
    sub_25EE0((__int16 *)&byte_6, 0, 0);
    initializing = 0;
    was_alarmed = 0;
    while ( 1 )
    {
LABEL_42:
      if ( dword_B93E0 )
      {
        v33 = dword_B93E4;
        v34 = (const char *)strsignal(dword_B93E4);
        if ( !v34 )
          v34 = byte_97F7C;
        sub_64E00(5, "%s exiting on signal %d (%s)", (const char *)progname, v33, v34);
        sub_32E6C();
        exit(0);
      }
      if ( alarm_flag )
      {
        alarm_flag = 0;
        was_alarmed = 1;
      }
      else
      {
        if ( was_alarmed )
          goto LABEL_67;
        sub_694B8();
        if ( !was_alarmed )
        {
          if ( !sub_6A3A0() )
            sub_16D04();
LABEL_67:
          if ( !alarm_flag )
          {
            if ( !was_alarmed )
              goto LABEL_47;
            goto LABEL_46;
          }
LABEL_70:
          alarm_flag = 0;
          was_alarmed = 1;
          goto LABEL_46;
        }
      }
      if ( alarm_flag )
        goto LABEL_70;
LABEL_46:
      sub_40ED4();
      was_alarmed = 0;
LABEL_47:
      v20 = sub_6A1A4();
      if ( v20 )
      {
        while ( 1 )
        {
          if ( alarm_flag )
          {
            was_alarmed = 1;
            alarm_flag = 0;
          }
          else if ( !was_alarmed )
          {
            v21 = *(void (__fastcall **)(int))(v20 + 80);
            if ( !v21 )
            {
LABEL_55:
              sub_64E00(3, "fatal: receive buffer callback NULL");
              abort();
            }
            goto LABEL_50;
          }
          sub_40ED4();
          v21 = *(void (__fastcall **)(int))(v20 + 80);
          was_alarmed = 0;
          if ( !v21 )
            goto LABEL_55;
LABEL_50:
          v21(v20);
          sub_69FA8((char *)v20);
          v20 = sub_6A1A4();
          if ( !v20 )
            goto LABEL_42;
        }
      }
    }
  }
  v30 = fork();
  if ( v30 != -1 )
  {
    if ( v30 > 0 )
    {
      v35 = v56;
      if ( !v18 )
        goto LABEL_106;
      close(waitsync_fd_to_close);
      v36 = time(0);
      LOBYTE(v37) = v35 & 0x1F;
      if ( v35 <= 0 )
        v37 = -(-v35 & 0x1F);
      v50 = v18 + v36;
      v38 = 1 << v37;
      while ( 1 )
      {
        v39 = time(0);
        th.tv_usec = 0;
        if ( v50 > v39 )
          v5 = (int *)(v50 - v39);
        v41 = (fd_set *)&v57;
        if ( v50 <= v39 )
          v5 = 0;
        th.tv_sec = (__time_t)v5;
        do
        {
          v41->__fds_bits[1] = 0;
          v41 = (fd_set *)((char *)v41 + 4);
        }
        while ( &v58.__fds_bits[31] != (__fd_mask *)v41 );
        v42 = _fdelt_chk(v35, v40, &v58.__fds_bits[31]);
        v58.__fds_bits[v42] |= v38;
        v43 = select(v35 + 1, &v58, 0, 0, &th);
        if ( v43 != -1 )
          break;
        v46 = *_errno_location();
        if ( v46 != 4 )
        {
          if ( !v46 )
            v46 = -1;
          v19 = v46;
          sub_64E00(3, "--wait-sync select failed: %m");
          goto LABEL_106;
        }
        if ( !v5 )
          goto LABEL_127;
      }
      if ( !v43 )
      {
        for ( i = 0; i != 32; ++i )
          v58.__fds_bits[i] = 0;
        v48 = &v59[4 * _fdelt_chk(v35, v44, v45) + 1028];
        th.tv_sec = 0;
        v49 = *((_DWORD *)v48 - 289);
        th.tv_usec = 0;
        *((_DWORD *)v48 - 289) = v49 | v38;
        if ( !select(v35 + 1, &v58, 0, 0, &th) )
        {
LABEL_127:
          v19 = 110;
          _fprintf_chk(stderr, 1, "%s: -w/--wait-sync %ld timed out.\n", (const char *)progname, v18);
        }
      }
LABEL_106:
      exit(v19);
    }
    closelog();
    if ( syslog_file )
    {
      fclose((FILE *)syslog_file);
      syslog_file = 0;
      syslogit = 1;
    }
    sub_69020(waitsync_fd_to_close);
    if ( open64("/dev/null", 0, v31) || dup2(0, 1) != 1 || dup2(0, 2) != 2 )
      sub_6ECC0("ntpd.c", 580, 2, "0 == open(\"/dev/null\", 0) && 1 == dup2(0, 1) && 2 == dup2(0, 2)");
    sub_64EFC((char *)progname, 0, 1);
    sub_65384(v51);
    if ( setsid() == -1 )
      sub_64E00(3, "setsid(): %m");
    goto LABEL_38;
  }
  v22 = *_errno_location();
  v23 = "fork: %m";
LABEL_58:
  if ( !v22 )
    v22 = -1;
  sub_64E00(3, (unsigned __int8 *)v23);
  exit(v22);
}
// 1DB48: variable 'v31' is possibly undefined
// 1DE50: variable 'v40' is possibly undefined
// 1DEE0: variable 'v44' is possibly undefined
// 1DEE0: variable 'v45' is possibly undefined
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;
// 1BC: using guessed type int elf_hash_bucket[521];
// B8E4: using guessed type int __fastcall strsignal(_DWORD);
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// C0E8: using guessed type int __fastcall _fdelt_chk(_DWORD, _DWORD, _DWORD);
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B60CC: using guessed type int waitsync_fd_to_close;
// B60D0: using guessed type int listen_to_virtual_ips;
// B60D4: using guessed type int priority_done;
// B611C: using guessed type _UNKNOWN *off_B611C;
// B6ADC: using guessed type char *Version;
// B7CE0: using guessed type int syslogit;
// B9214: using guessed type int config_priority_override;
// B93E0: using guessed type int dword_B93E0;
// B93E4: using guessed type int dword_B93E4;
// 107114: using guessed type int msyslog_term;
// 10741C: using guessed type int config_priority;
// 108174: using guessed type int saved_argc;
// 108178: using guessed type int saved_argv;
// 10817C: using guessed type int nofork;
// 108180: using guessed type int was_alarmed;
// 108184: using guessed type int progname;
// 108CA8: using guessed type int initializing;
// 108CB4: using guessed type int alarm_flag;
// 109584: using guessed type int syslog_file;
// 1095B0: using guessed type int ssl_init_done;

//----- (0001DF60) --------------------------------------------------------
int sub_1DF60()
{
  int v1; // [sp+4h] [bp-8h]

  ++*(int *)((char *)&elf_hash_bucket[7] + (_DWORD)off_B611C);
  return v1;
}
// 1DF88: variable 'v1' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// B611C: using guessed type _UNKNOWN *off_B611C;

//----- (0001DFC0) --------------------------------------------------------
void __noreturn sub_1DFC0()
{
  sub_89BE8((int)&ntpdOptions, 0);
}

//----- (0001E008) --------------------------------------------------------
void __fastcall sub_1E008(int a1, int a2)
{
  void *v4; // r3
  __int16 *v5; // r2
  int *v6; // r10
  int v7; // r4
  const char **v8; // r10
  int v9; // t1
  const char *v10; // r7
  const char *v11; // t1
  int v12; // r0
  int *v13; // r11
  int v14; // r4
  char **v15; // r11
  int v16; // t1
  char *v17; // t1
  size_t v18; // r0
  int *v19; // r11
  int v20; // r4
  char **v21; // r11
  int v22; // t1
  char *v23; // t1
  size_t v24; // r0
  int v25; // r4
  const char *v26; // r4
  double v27; // [sp+8h] [bp-14h] BYREF

  if ( !ipv4_works )
  {
    if ( !ipv6_works )
    {
      sub_64E00(3, "Neither IPv4 nor IPv6 networking detected, fatal.");
      exit(1);
    }
    v4 = off_B611C;
    if ( (*(_DWORD *)((_BYTE *)&word_10 + (_DWORD)off_B611C) & 0xF) != 0 )
    {
      sub_64E00(4, "-4/--ipv4 ignored, IPv4 networking not found.");
      v4 = off_B611C;
    }
    goto LABEL_5;
  }
  v4 = off_B611C;
  if ( ipv6_works )
  {
    if ( (*(_DWORD *)((_BYTE *)&word_10 + (_DWORD)off_B611C) & 0xF) != 0 )
    {
      ipv6_works = 0;
    }
    else if ( (*(int *)((_BYTE *)&dword_50 + (_DWORD)off_B611C) & 0xF) != 0 )
    {
      ipv4_works = 0;
    }
LABEL_5:
    v5 = (__int16 *)(*(int *)((_BYTE *)&dword_90 + (_DWORD)v4) & 0xF);
    if ( !v5 )
      goto LABEL_6;
LABEL_51:
    sub_38810(3, (__int16 *)((char *)&dword_0 + 1), 0);
    v4 = off_B611C;
    if ( (*(int *)((_BYTE *)&dword_110 + (_DWORD)off_B611C) & 0xF) == 0 )
      goto LABEL_9;
    goto LABEL_52;
  }
  if ( (*(int *)((_BYTE *)&dword_50 + (_DWORD)off_B611C) & 0xF) == 0 )
    goto LABEL_5;
  sub_64E00(4, "-6/--ipv6 ignored, IPv6 networking not found.");
  v4 = off_B611C;
  v5 = (__int16 *)(*(int *)((_BYTE *)&dword_90 + (_DWORD)off_B611C) & 0xF);
  if ( v5 )
    goto LABEL_51;
LABEL_6:
  if ( (*(int *)((_BYTE *)&dword_D0 + (_DWORD)v4) & 0xF) != 0 )
  {
    sub_38810(3, v5, (char *)v5);
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&dword_110 + (_DWORD)v4) & 0xF) != 0 )
  {
LABEL_52:
    sub_38810(1, (__int16 *)((char *)&dword_0 + 1), 0);
    v4 = off_B611C;
  }
LABEL_9:
  if ( (*(int *)((_BYTE *)&dword_150 + (_DWORD)v4) & 0xF) != 0 )
    config_file = *(_DWORD *)&aLibLdLinuxArmh[(_DWORD)v4 + 4];
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[21] + (_DWORD)v4) & 0xF) != 0 )
  {
    sub_4294C(1, *(char **)((char *)&elf_hash_bucket[23] + (_DWORD)v4));
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[37] + (_DWORD)v4) & 0xF) != 0 )
    allow_panic = 1;
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[53] + (_DWORD)v4) & 0xF) != 0 )
    force_step_once = 1;
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[101] + (_DWORD)v4) & 0xF) != 0 )
  {
    sub_42744(*(const char **)((char *)&elf_hash_bucket[103] + (_DWORD)v4));
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[197] + (_DWORD)v4) & 0xF) != 0 )
  {
    sub_4294C(3, *(char **)((char *)&elf_hash_bucket[199] + (_DWORD)v4));
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[229] + (_DWORD)v4) & 0xF) != 0 )
    mode_ntpdate = 1;
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[245] + (_DWORD)v4) & 0xF) != 0 )
  {
    v26 = *(const char **)((char *)&elf_hash_bucket[247] + (_DWORD)v4);
    if ( sscanf(v26, "%lf", &v27) == 1 )
      sub_38810(4, 0, 0);
    else
      sub_64E00(3, "command line broadcast delay value %s undecodable", v26);
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[277] + (_DWORD)v4) & 0xF) != 0 )
  {
    sub_4294C(2, *(char **)((char *)&elf_hash_bucket[279] + (_DWORD)v4));
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[293] + (_DWORD)v4) & 0xF) != 0 )
  {
    v6 = *(int **)((char *)&elf_hash_bucket[296] + (_DWORD)v4);
    v9 = *v6;
    v8 = (const char **)&byte_8[(_DWORD)v6];
    v7 = v9;
    do
    {
      while ( 1 )
      {
        v11 = *v8++;
        v10 = v11;
        v12 = strtol(v11, 0, 10);
        if ( (unsigned int)(v12 - 1) <= 0xFFFE )
          break;
        --v7;
        sub_64E00(3, "command line trusted key %s is invalid", v10);
        if ( v7 <= 0 )
          goto LABEL_31;
      }
      --v7;
      sub_621BC(v12, 1u);
    }
    while ( v7 > 0 );
LABEL_31:
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[341] + (_DWORD)v4) & 0xF) != 0 )
  {
    v13 = *(int **)((char *)&elf_hash_bucket[344] + (_DWORD)v4);
    v16 = *v13;
    v15 = (char **)&byte_8[(_DWORD)v13];
    v14 = v16;
    do
    {
      v17 = *v15++;
      --v14;
      v18 = strlen(v17);
      sub_245C4((unsigned __int8 *)v17, v18 + 1, 3);
    }
    while ( v14 > 0 );
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[357] + (_DWORD)v4) & 0xF) != 0 )
  {
    v19 = *(int **)((char *)&elf_hash_bucket[360] + (_DWORD)v4);
    v22 = *v19;
    v21 = (char **)&byte_8[(_DWORD)v19];
    v20 = v22;
    do
    {
      v23 = *v21++;
      --v20;
      v24 = strlen(v23);
      sub_245C4((unsigned __int8 *)v23, v24 + 1, 35);
    }
    while ( v20 > 0 );
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[389] + (_DWORD)v4) & 0xF) != 0 )
  {
    sub_305F8((char *)&dword_0 + 3);
    v4 = off_B611C;
  }
  if ( (*(int *)((_BYTE *)&elf_hash_bucket[325] + (_DWORD)v4) & 0xF) != 0 )
  {
    v25 = *(int *)((char *)&elf_hash_bucket[327] + (_DWORD)v4);
    if ( v25 < 0 )
    {
      _fprintf_chk(
        stderr,
        1,
        "command line interface update interval %ld must not be negative\n",
        *(int *)((char *)&elf_hash_bucket[327] + (_DWORD)v4));
      sub_64E00(3, "command line interface update interval %ld must not be negative", v25);
      if ( a1 > 0 )
      {
        cmdline_server_count = a1;
        cmdline_servers = a2;
      }
      sub_89BE8((int)&ntpdOptions, 2);
    }
    interface_interval = *(int *)((char *)&elf_hash_bucket[327] + (_DWORD)v4);
  }
  if ( a1 > 0 )
  {
    cmdline_server_count = a1;
    cmdline_servers = a2;
  }
}
// 0: using guessed type int dword_0;
// 10: using guessed type __int16;
// 50: using guessed type int;
// 90: using guessed type int;
// D0: using guessed type int;
// 110: using guessed type int;
// 150: using guessed type int;
// 1BC: using guessed type int elf_hash_bucket[521];
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B611C: using guessed type _UNKNOWN *off_B611C;
// B9E84: using guessed type int mode_ntpdate;
// B9E88: using guessed type int force_step_once;
// 106F60: using guessed type int allow_panic;
// 107418: using guessed type int cmdline_server_count;
// 107420: using guessed type int config_file;
// 1074E0: using guessed type int cmdline_servers;
// 108CB8: using guessed type int interface_interval;
// 108D68: using guessed type int ipv6_works;
// 108D6C: using guessed type int ipv4_works;

//----- (0001E508) --------------------------------------------------------
int __fastcall sub_1E508(unsigned __int16 *a1, int a2, int a3)
{
  unsigned int v4; // r0
  int v5; // r4
  int v6; // r0
  int digestbyname; // r0
  int v8; // r3
  int v9; // r2
  unsigned __int16 *v10; // r1
  int v12; // [sp+0h] [bp-50h] BYREF
  int v13; // [sp+4h] [bp-4Ch] BYREF
  _BYTE v14[4]; // [sp+8h] [bp-48h] BYREF
  _DWORD v15[16]; // [sp+Ch] [bp-44h] BYREF

  v4 = 2092;
  v13 = a2;
  v12 = a3;
  while ( !dword_B93F4 || (unsigned int)(current_time - dword_B9404) >= 0xE10 )
  {
    dword_B93F4 = sub_68AE4();
    dword_B93F8 = sub_68AE4();
    dword_B93FC = sub_68AE4();
    v4 = sub_68AE4();
    dword_B9400 = v4;
    dword_B9404 = current_time;
  }
  v5 = EVP_MD_CTX_new(v4);
  EVP_MD_CTX_set_flags(v5, 8);
  v6 = OBJ_nid2sn(4);
  digestbyname = EVP_get_digestbyname(v6);
  EVP_DigestInit_ex(v5, digestbyname, 0);
  EVP_DigestUpdate(v5, &dword_B93F4, 16);
  EVP_DigestUpdate(v5, &v13, 4);
  EVP_DigestUpdate(v5, &v12, 4);
  v8 = *a1;
  if ( v8 == 2 )
    v9 = 2;
  else
    v9 = 8;
  if ( v8 == 2 )
    v10 = &a1[v9];
  else
    v10 = a1 + 4;
  EVP_DigestUpdate(v5, v10, v9 * 2);
  EVP_DigestUpdate(v5, a1 + 1, 2);
  EVP_DigestUpdate(v5, &dword_B93F4, 16);
  EVP_DigestFinal(v5, v15, v14);
  EVP_MD_CTX_free(v5);
  return v15[0];
}
// B250: using guessed type int __fastcall EVP_DigestInit_ex(_DWORD, _DWORD, _DWORD);
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// B68C: using guessed type int __fastcall EVP_MD_CTX_set_flags(_DWORD, _DWORD);
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B848: using guessed type int __fastcall EVP_DigestFinal(_DWORD, _DWORD, _DWORD);
// B9C8: using guessed type int __fastcall EVP_MD_CTX_new(_DWORD);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// B93F4: using guessed type int dword_B93F4;
// B93F8: using guessed type int dword_B93F8;
// B93FC: using guessed type int dword_B93FC;
// B9400: using guessed type int dword_B9400;
// B9404: using guessed type int dword_B9404;
// 108CA4: using guessed type int current_time;

//----- (0001E688) --------------------------------------------------------
unsigned int __fastcall sub_1E688(int a1, int a2, unsigned int a3)
{
  int v6; // r0

  v6 = sub_1E508((unsigned __int16 *)(a1 + 4), *(_DWORD *)(a1 + 72), *(_DWORD *)(a1 + 76));
  return sub_6C054(a2, a3, "%08x%08x%08x", *(_DWORD *)(a1 + 72), *(_DWORD *)(a1 + 76), v6);
}

//----- (0001E710) --------------------------------------------------------
char *__fastcall sub_1E710(unsigned __int16 *a1, int a2)
{
  int v4; // r5
  unsigned __int16 *v5; // r4
  char *v6; // r3
  int v8; // r2
  int v9; // r0
  char *v10; // [sp+4h] [bp-10h]

  v4 = 0;
  v5 = (unsigned __int16 *)&ctl_traps;
  v6 = (char *)&unk_10819C;
  while ( 1 )
  {
    if ( (v5[25] & 1) == 0 )
      goto LABEL_4;
    if ( a1[1] != v5[1] )
      goto LABEL_4;
    v8 = *v5;
    if ( v8 != *a1 )
      goto LABEL_4;
    if ( v8 == 2 )
    {
      if ( *((_DWORD *)a1 + 1) != *((_DWORD *)v5 + 1) )
        goto LABEL_4;
    }
    else
    {
      v10 = v6;
      v9 = memcmp(a1 + 4, &v6[52 * v4], 0x10u);
      v6 = v10;
      if ( v9 || *((_DWORD *)a1 + 6) != *((_DWORD *)v5 + 6) )
        goto LABEL_4;
    }
    if ( *((_DWORD *)v5 + 7) == a2 )
      return (char *)&ctl_traps + 52 * v4;
LABEL_4:
    ++v4;
    v5 += 26;
    if ( v4 == 3 )
      return 0;
  }
}

//----- (0001E820) --------------------------------------------------------
_DWORD *__fastcall sub_1E820(int a1, _DWORD *a2)
{
  unsigned __int8 *v2; // r6
  unsigned int v3; // r8
  int i; // r7
  unsigned __int8 *v6; // r4
  int v7; // r11
  const unsigned __int16 *v8; // r0
  unsigned int v10; // r1
  unsigned __int8 *v11; // r2
  unsigned __int8 *v12; // r9
  int v13; // t1
  int v14; // r7
  unsigned int v15; // r4
  unsigned __int8 *v16; // r1
  unsigned __int8 *v17; // r3
  unsigned __int8 *v18; // r12
  int v19; // r2
  int v20; // r4
  unsigned __int8 *v21; // r12
  __int16 v22; // r3
  _BYTE *v23; // r1
  int v24; // r3
  unsigned __int8 *v25; // r2
  int v26; // t1
  int v27; // t1
  bool v28; // zf
  const char *v29; // r0

  v2 = (unsigned __int8 *)dword_B9408;
  v3 = dword_B940C;
  if ( dword_B940C <= (unsigned int)dword_B9408 )
    return 0;
  for ( i = 0; ; i = 1 )
  {
    v6 = v2 + 1;
    v7 = *v2;
    if ( v7 != 44 )
    {
      v8 = *_ctype_b_loc();
      if ( (v8[v7] & 0x2000) == 0 )
        break;
    }
    ++v2;
    if ( (unsigned __int8 *)v3 == v6 )
    {
      dword_B9408 = v3;
      return 0;
    }
  }
  if ( i )
    dword_B9408 = (int)v2;
  if ( v3 <= (unsigned int)v2 )
    return 0;
  v10 = v3 - 1;
  v11 = v2;
  v12 = 0;
  while ( 1 )
  {
    v14 = (int)v11;
    if ( v7 != 61 )
      break;
    if ( !v12 )
      v12 = v11;
    if ( (unsigned __int8 *)v10 == v11 )
      goto LABEL_20;
LABEL_15:
    v13 = *++v11;
    v7 = v13;
  }
  if ( v7 == 44 )
    goto LABEL_21;
  if ( (unsigned __int8 *)v10 != v11 )
    goto LABEL_15;
LABEL_20:
  v14 = v3;
LABEL_21:
  v15 = 0;
  *a2 = 0;
  if ( !v12 )
  {
    v12 = (unsigned __int8 *)v14;
    if ( a1 )
      goto LABEL_32;
    return dword_93B9C;
  }
  v16 = v12 + 1;
  if ( v12 + 1 == (unsigned __int8 *)v14 )
    goto LABEL_31;
  v17 = v12 + 1;
  while ( 1 )
  {
    v16 = v17;
    v18 = v17 + 1;
    v19 = *v17;
    v15 = v8[v19] & 0x2000;
    if ( (v8[v19] & 0x2000) == 0 )
      break;
    ++v17;
    if ( (unsigned __int8 *)v14 == v18 )
    {
      v16 = (unsigned __int8 *)v14;
LABEL_52:
      v15 = 0;
LABEL_31:
      _memcpy_chk(&unk_B9410, v16, v15, 128);
      *((_BYTE *)&dword_B93F4 + v15 + 28) = 0;
      *a2 = &unk_B9410;
      if ( a1 )
      {
LABEL_32:
        v22 = *(_WORD *)(a1 + 2);
        if ( (v22 & 0x80) != 0 )
        {
LABEL_50:
          *a2 = 0;
          return (_DWORD *)a1;
        }
        while ( 2 )
        {
          if ( (v22 & 0x40) == 0 )
          {
            v23 = *(_BYTE **)(a1 + 4);
            v24 = (unsigned __int8)*v23;
            if ( v2 == v12 )
            {
LABEL_43:
              v28 = v24 == 61;
              if ( v24 != 61 )
                v28 = v24 == 0;
              if ( v28 )
              {
                if ( v3 != v14 )
                  ++v14;
                dword_B9408 = v14;
                return (_DWORD *)a1;
              }
            }
            else if ( *v23 && *v2 == v24 )
            {
              v25 = v2;
              while ( 1 )
              {
                v27 = (unsigned __int8)*++v23;
                v24 = v27;
                if ( v12 - 1 == v25 )
                  goto LABEL_43;
                if ( v24 )
                {
                  v26 = *++v25;
                  if ( v26 == v24 )
                    continue;
                }
                break;
              }
            }
          }
          a1 += 8;
          v22 = *(_WORD *)(a1 + 2);
          if ( (v22 & 0x80) != 0 )
            goto LABEL_50;
          continue;
        }
      }
      return dword_93B9C;
    }
  }
  if ( v17 == (unsigned __int8 *)v14 )
    goto LABEL_31;
  v20 = v14;
  while ( 1 )
  {
    v21 = (unsigned __int8 *)(v20 - 1);
    if ( (v8[*(unsigned __int8 *)(v20 - 1)] & 0x2000) == 0 )
      break;
    --v20;
    if ( v21 == v17 )
      goto LABEL_52;
  }
  v15 = v20 - (_DWORD)v17;
  if ( v15 <= 0x7F )
    goto LABEL_31;
  ++numctlbadpkts;
  if ( (ntp_syslogmask & 2) != 0 && dword_B9490 <= (unsigned int)current_time )
  {
    dword_B9490 = current_time + 300;
    v29 = sub_6C2E8((unsigned __int16 *)dword_B9494);
    sub_64E00(
      4,
      "Possible 'ntpdx' exploit from %s#%u (possibly spoofed)",
      v29,
      (unsigned __int16)__rev16(*(unsigned __int16 *)(dword_B9494 + 2)));
    v3 = dword_B940C;
  }
  dword_B9408 = v3;
  return 0;
}
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 93B9C: using guessed type _DWORD dword_93B9C[22];
// B7CD4: using guessed type int ntp_syslogmask;
// B93F4: using guessed type int dword_B93F4;
// B9408: using guessed type int dword_B9408;
// B940C: using guessed type int dword_B940C;
// B9490: using guessed type int dword_B9490;
// B9494: using guessed type int dword_B9494;
// 108188: using guessed type int numctlbadpkts;
// 108CA4: using guessed type int current_time;

//----- (0001EBA4) --------------------------------------------------------
__int16 *__fastcall sub_1EBA4(int a1)
{
  int v2; // r3
  unsigned int v3; // r6
  size_t n; // r4
  _BYTE *v5; // r3
  int v6; // r8
  unsigned __int16 *v7; // r5
  int v9; // r2
  _DWORD *v10; // r12
  int v11; // r5
  size_t v12; // r0
  size_t v13; // r0
  char v14; // lr
  int v15; // r1

  v2 = dword_B9498;
  v3 = dword_B9498 - (_DWORD)&unk_B94A8;
  if ( !a1 && dword_B96A0 && v3 + 2 < 0x1D4 )
  {
    v3 += 2;
    *(_BYTE *)dword_B9498 = 13;
    *(_BYTE *)(v2 + 1) = 10;
    dword_B9498 = v2 + 2;
  }
  n = v3 + 12;
  if ( ((v3 + 12) & 3) != 0 )
  {
    v5 = (_BYTE *)dword_B9498;
    do
    {
      ++n;
      *v5++ = 0;
    }
    while ( (n & 3) != 0 );
    dword_B9498 = (int)v5;
  }
  word_B94A6 = __rev16(v3);
  word_B94A4 = __rev16(dword_B96A8);
  byte_B949D = a1 | ~(~((byte_B96A4 & 0x1Fu) << 25) >> 25);
  if ( !byte_B96AC )
  {
    if ( byte_B96AD && sys_authenticate )
    {
      v9 = dword_B9498;
      if ( (n & 7) != 0 )
      {
        v10 = (_DWORD *)dword_B9498;
        do
        {
          *(_BYTE *)v10 = 0;
          v10 = (_DWORD *)((char *)v10 + 1);
          v11 = (int)v10 + n - v9;
        }
        while ( (v11 & 7) != 0 );
        dword_B9498 = (int)v10;
      }
      else
      {
        v10 = (_DWORD *)dword_B9498;
        v11 = n;
      }
      v12 = dword_B96B0;
      *v10 = bswap32(dword_B96B0);
      v13 = sub_6278C(v12, (int)&byte_B949C, v11);
      sub_16A68((struct sockaddr *)dword_B9494, dword_B96B4, -5, (unsigned int *)&byte_B949C, v13 + v11);
      if ( a1 )
        goto LABEL_19;
    }
    else
    {
      sub_16A68((struct sockaddr *)dword_B9494, dword_B96B4, -6, (unsigned int *)&byte_B949C, n);
      if ( a1 )
      {
LABEL_19:
        ++numctlfrags;
        goto LABEL_11;
      }
    }
    ++numctlresponses;
    goto LABEL_11;
  }
  v6 = 0;
  v7 = (unsigned __int16 *)&ctl_traps;
  do
  {
    if ( (v7[25] & 1) != 0 )
    {
      v14 = (8 * *((_BYTE *)v7 + 51)) & 0x38;
      word_B949E = __rev16(v7[24]);
      v15 = *((_DWORD *)v7 + 7);
      byte_B949C = (sys_leap << 6) | 6 | v14;
      sub_16A68((struct sockaddr *)v7, v15, -4, (unsigned int *)&byte_B949C, n);
      if ( !a1 )
        ++v7[24];
      ++numasyncmsgs;
    }
    ++v6;
    v7 += 26;
  }
  while ( v6 != 3 );
LABEL_11:
  dword_B9498 = (int)&unk_B94A8;
  dword_B96A8 += v3;
  ++word_B96B8;
  return &word_B96B8;
}
// A8: using guessed type int;
// 1BC: using guessed type int elf_hash_bucket[521];
// B9494: using guessed type int dword_B9494;
// B9498: using guessed type int dword_B9498;
// B949C: using guessed type char byte_B949C;
// B949D: using guessed type char byte_B949D;
// B949E: using guessed type __int16 word_B949E;
// B94A4: using guessed type __int16 word_B94A4;
// B94A6: using guessed type __int16 word_B94A6;
// B96A0: using guessed type int dword_B96A0;
// B96A4: using guessed type char byte_B96A4;
// B96A8: using guessed type int dword_B96A8;
// B96AC: using guessed type char byte_B96AC;
// B96AD: using guessed type char byte_B96AD;
// B96B0: using guessed type int dword_B96B0;
// B96B4: using guessed type int dword_B96B4;
// B96B8: using guessed type __int16 word_B96B8;
// 108190: using guessed type int numctlresponses;
// 108238: using guessed type int numasyncmsgs;
// 108244: using guessed type int numctlfrags;
// 108BAC: using guessed type int sys_authenticate;
// 108BC0: using guessed type char sys_leap;

//----- (0001EEC8) --------------------------------------------------------
char *__fastcall sub_1EEC8(char *result, int a2, int a3)
{
  int v3; // r1
  int v4; // r8
  char *v5; // r7
  char *v6; // r6
  size_t v7; // r5
  bool v8; // zf
  void *v9; // r3
  size_t i; // r4
  const void *v11; // r1
  int v12; // r5
  int v13; // r6
  char *v14; // r3
  int v15; // r12
  char *v16; // [sp+0h] [bp-14h]

  if ( a3 )
  {
    v3 = 8 * a2;
    v4 = 0;
  }
  else
  {
    v3 = 8 * a2;
    dword_B96A0 = 1;
    if ( dword_B96BC )
    {
      v12 = dword_B9498;
      v13 = dword_B96C0;
      v14 = result;
      *(_BYTE *)dword_B9498 = 44;
      dword_B9498 = v12 + 1;
      dword_B96C0 = v13 + 1;
      do
      {
        v15 = *((_DWORD *)v14 + 1);
        v14 += 8;
        a3 += v15;
      }
      while ( &result[v3] != v14 );
      if ( (unsigned int)(v13 + 2 + a3) <= 0x47 )
      {
        *(_BYTE *)(v12 + 1) = 32;
        v4 = 3;
        dword_B96C0 = v13 + 2;
        dword_B9498 = v12 + 2;
      }
      else
      {
        *(_BYTE *)(v12 + 1) = 13;
        v4 = 3;
        dword_B9498 = v12 + 3;
        dword_B96C0 = 0;
        *(_BYTE *)(v12 + 2) = 10;
      }
    }
    else
    {
      v4 = 3;
    }
  }
  v5 = result;
  v16 = &result[v3];
  do
  {
    v6 = *(char **)v5;
    v7 = *((_DWORD *)v5 + 1);
    v8 = v7 == 0;
    if ( v7 )
      v8 = v6 == 0;
    if ( !v8 )
    {
      v9 = (void *)dword_B9498;
      for ( i = dword_B96C4 - dword_B9498; v4 + v7 > dword_B96C4 - dword_B9498; i = dword_B96C4 - dword_B9498 )
      {
        v11 = v6;
        if ( i >= v7 )
          i = v7;
        v7 -= i;
        v6 += i;
        dword_B9498 = (int)memcpy(v9, v11, i) + i;
        dword_B96C0 += i;
        sub_1EBA4(32);
        v9 = (void *)dword_B9498;
      }
      result = (char *)memcpy(v9, v6, v7);
      dword_B9498 = (int)&result[v7];
      dword_B96BC = 1;
      dword_B96C0 += v7;
    }
    v5 += 8;
  }
  while ( v16 != v5 );
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B9498: using guessed type int dword_B9498;
// B96A0: using guessed type int dword_B96A0;
// B96BC: using guessed type int dword_B96BC;
// B96C0: using guessed type int dword_B96C0;
// B96C4: using guessed type int dword_B96C4;

//----- (0001F0E4) --------------------------------------------------------
char *__fastcall sub_1F0E4(const char *a1, int a2, int a3)
{
  size_t v5; // r0
  int v6; // r2
  bool v7; // zf
  int v8; // r1
  _DWORD v10[6]; // [sp+4h] [bp-1Ch] BYREF

  v10[0] = a1;
  v5 = strlen(a1);
  v6 = a3;
  if ( a3 )
    v6 = 1;
  if ( !a2 )
    v6 = 0;
  v7 = v6 == 0;
  v10[1] = v5;
  if ( v6 )
    v6 = 0;
  v10[3] = 1;
  if ( v7 )
    v8 = 2;
  else
    v8 = 3;
  v10[2] = "=";
  if ( !v7 )
  {
    v10[4] = a2;
    v10[5] = a3;
  }
  return sub_1EEC8((char *)v10, v8, v6);
}

//----- (0001F188) --------------------------------------------------------
char *__fastcall sub_1F188(const char *a1, unsigned int a2, unsigned __int16 *a3)
{
  const char *v4; // r5
  size_t v5; // r2

  if ( a3 )
    v4 = sub_6C2E8(a3);
  else
    v4 = sub_696EC(a2);
  v5 = strlen(v4);
  return sub_1F0E4(a1, (int)v4, v5);
}

//----- (0001F20C) --------------------------------------------------------
char *__fastcall sub_1F20C(const char *a1, int a2)
{
  int v3; // r9
  unsigned __int8 *v4; // r10
  int v5; // r4
  int v6; // t1
  const unsigned __int16 **v7; // r0
  int v8; // r3
  int v9; // r4
  int v11; // [sp+0h] [bp-8h] BYREF

  v3 = 0;
  v11 = a2;
  v4 = (unsigned __int8 *)&v11;
  do
  {
    v6 = *v4++;
    v5 = v6;
    if ( !v6 )
      break;
    v7 = _ctype_b_loc();
    v8 = v5;
    ++v3;
    v9 = v5 == 44;
    if ( ((*v7)[v8] & 0x6000) != 0x4000 )
      v9 |= 1u;
    if ( v9 )
      *(v4 - 1) = 46;
  }
  while ( v3 != 4 );
  return sub_1F0E4(a1, (int)&v11, v3);
}

//----- (0001F2C0) --------------------------------------------------------
char *__fastcall sub_1F2C0(const char *a1, int a2, int a3)
{
  size_t v5; // r0
  int v6; // r2
  _DWORD v8[2]; // [sp+4h] [bp-24h] BYREF
  const char *v9; // [sp+Ch] [bp-1Ch]
  int v10; // [sp+10h] [bp-18h]
  int v11; // [sp+14h] [bp-14h]
  int v12; // [sp+18h] [bp-10h]
  char *v13; // [sp+1Ch] [bp-Ch]
  int v14; // [sp+20h] [bp-8h]

  v8[0] = a1;
  v5 = strlen(a1);
  v6 = a3;
  v8[1] = v5;
  if ( a3 )
    v6 = 1;
  if ( !a2 )
    v6 = 0;
  if ( v6 )
  {
    v11 = a2;
    v9 = "=\"";
    v12 = a3;
    v13 = "\"";
    v10 = 2;
    v14 = 1;
    return sub_1EEC8((char *)v8, 4, 0);
  }
  else
  {
    v10 = 3;
    v9 = "=\"\"";
    return sub_1EEC8((char *)v8, 2, 0);
  }
}

//----- (0001F3A0) --------------------------------------------------------
char *sub_1F3A0(unsigned __int8 *a1, ...)
{
  _DWORD v2[2]; // [sp+4h] [bp-90h] BYREF
  char v3[122]; // [sp+Ch] [bp-88h] BYREF
  char v4[6]; // [sp+86h] [bp-Eh] BYREF
  va_list varg_r1; // [sp+A4h] [bp+10h] BYREF

  va_start(varg_r1, a1);
  if ( sub_6B6F8((int)v3, 0x80u, a1, (int *)varg_r1) > 0x7F )
    strcpy(v4, "[...]");
  v2[1] = strlen(v3);
  v2[0] = v3;
  return sub_1EEC8((char *)v2, 1, 0);
}

//----- (0001F454) --------------------------------------------------------
__int16 *__fastcall sub_1F454(int a1)
{
  size_t v1; // r0
  char v3[64]; // [sp+4h] [bp-48h] BYREF

  sub_1E688(a1, (int)v3, 0x40u);
  v1 = strlen(v3);
  sub_1F0E4("nonce", (int)v3, v1);
  return sub_1EBA4(0);
}

//----- (0001F4D0) --------------------------------------------------------
int __fastcall sub_1F4D0(int a1)
{
  size_t v2; // r0

  word_B94A0 = __rev16(a1 << 8);
  word_B94A6 = 0;
  byte_B949D = ~(~((byte_B96A4 & 0x1Fu) << 26) >> 26);
  ++numctlerrors;
  if ( !byte_B96AD || !sys_authenticate )
    return sub_16A68((struct sockaddr *)dword_B9494, dword_B96B4, -3, (unsigned int *)&byte_B949C, 0xCu);
  v2 = sub_6278C(dword_B96B0, (int)&byte_B949C, 12);
  return sub_16A68((struct sockaddr *)dword_B9494, dword_B96B4, -2, (unsigned int *)&byte_B949C, v2 + 12);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B9494: using guessed type int dword_B9494;
// B949C: using guessed type char byte_B949C;
// B949D: using guessed type char byte_B949D;
// B94A0: using guessed type __int16 word_B94A0;
// B94A6: using guessed type __int16 word_B94A6;
// B96A4: using guessed type char byte_B96A4;
// B96AD: using guessed type char byte_B96AD;
// B96B0: using guessed type int dword_B96B0;
// B96B4: using guessed type int dword_B96B4;
// 108264: using guessed type int numctlerrors;
// 108BAC: using guessed type int sys_authenticate;

//----- (0001F5E0) --------------------------------------------------------
int sub_1F5E0()
{
  return sub_1F4D0(1);
}

//----- (0001F62C) --------------------------------------------------------
char *__fastcall sub_1F62C(int a1, __int16 a2)
{
  int v2; // r8
  char *result; // r0
  const char *v5; // r0
  unsigned __int16 *v6; // r9
  unsigned int v7; // r0
  unsigned int v8; // r10
  int v9; // r8
  const char *v10; // r0
  const char *v11; // r0
  int v12; // r0
  int v13; // r4
  const char *v14; // r0
  const char *v15; // r0
  signed int v16; // r0
  char *v17; // [sp+4h] [bp-Ch] BYREF
  size_t v18; // [sp+8h] [bp-8h]

  v2 = (unsigned __int16)word_B96C8;
  if ( word_B96C8 )
    return (char *)sub_1F4D0(6);
  if ( (a2 & 0x100) != 0 )
  {
    sub_6C054(
      (int)byte_1078F0,
      (unsigned int)&elf_hash_bucket[145],
      "runtime configuration prohibited by restrict ... nomodify");
    v18 = strlen(byte_1078F0);
    v17 = byte_1078F0;
    sub_1EEC8((char *)&v17, 1, v2);
    result = (char *)sub_1EBA4(v2);
    if ( (ntp_syslogmask & 1) != 0 )
    {
      v5 = sub_6C2E8((unsigned __int16 *)(a1 + 4));
      result = sub_64E00(5, "runtime config from %s rejected due to nomodify restriction", v5);
    }
    ++sys_restricted;
  }
  else
  {
    v6 = (unsigned __int16 *)(a1 + 4);
    v7 = sub_42D0C((unsigned __int8 *)dword_B9408, (unsigned __int8 *)dword_B940C);
    v8 = v7;
    if ( v7 > 0x3FE )
    {
      sub_6C054((int)byte_1078F0, (unsigned int)&elf_hash_bucket[145], "runtime configuration failed: request too long");
      v18 = strlen(byte_1078F0);
      v17 = byte_1078F0;
      sub_1EEC8((char *)&v17, 1, 0);
      sub_1EBA4(0);
      v15 = sub_6C2E8(v6);
      return sub_64E00(5, "runtime config from %s rejected: request too long", v15);
    }
    else
    {
      v9 = dword_B940C - dword_B9408;
      if ( dword_B940C - dword_B9408 == v7 )
      {
        _memcpy_chk(remote_config, dword_B9408, dword_B940C - dword_B9408, 2060);
        remote_config[v9] = 0;
        v11 = sub_6C2E8(v6);
        sub_64E00(5, "%s config: %s", v11, (const char *)remote_config);
        remote_config[v9] = 10;
        dword_107CF0 = 0;
        remote_config[v9 + 1] = 0;
        dword_107CF4 = 0;
        dword_107CF8 = 0;
        sub_132B0(v6);
        if ( dword_107CF8
          || (v16 = sub_6C054((int)byte_1078F0, (unsigned int)&elf_hash_bucket[145], "Config Succeeded"), v16 <= 0) )
        {
          v12 = dword_107CF4;
        }
        else
        {
          v12 = v16 + dword_107CF4;
          dword_107CF4 = v12;
        }
        v18 = v12;
        v17 = byte_1078F0;
        sub_1EEC8((char *)&v17, 1, 0);
        result = (char *)sub_1EBA4(0);
        v13 = dword_107CF8;
        if ( dword_107CF8 > 0 )
        {
          v14 = sub_6C2E8(v6);
          return sub_64E00(5, "%d error in %s config", v13, v14);
        }
      }
      else
      {
        sub_6C054(
          (int)byte_1078F0,
          (unsigned int)&elf_hash_bucket[145],
          "runtime configuration failed: request contains an unprintable character");
        v18 = strlen(byte_1078F0);
        v17 = byte_1078F0;
        sub_1EEC8((char *)&v17, 1, 0);
        sub_1EBA4(0);
        v10 = sub_6C2E8(v6);
        return sub_64E00(
                 5,
                 "runtime config from %s rejected: request contains an unprintable character: %0x",
                 v10,
                 *(unsigned __int8 *)(dword_B9408 + v8));
      }
    }
  }
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// B7CD4: using guessed type int ntp_syslogmask;
// B9408: using guessed type int dword_B9408;
// B940C: using guessed type int dword_B940C;
// B96C8: using guessed type __int16 word_B96C8;
// 1074F0: using guessed type unsigned __int8 remote_config[1024];
// 107CF0: using guessed type int dword_107CF0;
// 107CF4: using guessed type int dword_107CF4;
// 107CF8: using guessed type int dword_107CF8;
// 108C00: using guessed type int sys_restricted;

//----- (0001F95C) --------------------------------------------------------
unsigned int __fastcall sub_1F95C(unsigned int result)
{
  unsigned int v1; // r3

  if ( result )
  {
    v1 = result + 8;
    result = *(_WORD *)(result + 2) & 0x80;
    if ( result )
    {
      return 0;
    }
    else
    {
      do
      {
        v1 += 8;
        ++result;
      }
      while ( (*(_WORD *)(v1 - 6) & 0x80) == 0 );
      if ( result >= 0x10000 )
        sub_6ECC0("ntp_control.c", 5165, 1, "c <= (0x7fff * 2 + 1)");
      return (unsigned __int16)result;
    }
  }
  return result;
}

//----- (0001FA04) --------------------------------------------------------
char *__fastcall sub_1FA04(const char *a1, int a2)
{
  unsigned int v3; // r0
  _BYTE v5[24]; // [sp+4h] [bp-1Ch] BYREF

  v3 = sub_6C054((int)v5, 0x18u, "0x%lx", a2);
  if ( v3 > 0x17 )
    sub_6ECC0("ntp_control.c", 1751, 2, "rc >= 0 && (size_t)rc < sizeof(buffer)");
  return sub_1F0E4(a1, (int)v5, v3);
}

//----- (0001FAA8) --------------------------------------------------------
char *__fastcall sub_1FAA8(const char *a1, int a2)
{
  unsigned int v3; // r0
  _BYTE v5[24]; // [sp+4h] [bp-1Ch] BYREF

  v3 = sub_6C054((int)v5, 0x18u, "%ld", a2);
  if ( v3 > 0x17 )
    sub_6ECC0("ntp_control.c", 1769, 2, "rc >= 0 && (size_t)rc < sizeof(buffer)");
  return sub_1F0E4(a1, (int)v5, v3);
}

//----- (0001FB4C) --------------------------------------------------------
char *__fastcall sub_1FB4C(const char *a1, int a2)
{
  unsigned int v3; // r0
  _BYTE v5[24]; // [sp+4h] [bp-1Ch] BYREF

  v3 = sub_6C054((int)v5, 0x18u, (unsigned __int8 *)"%lu", a2);
  if ( v3 > 0x17 )
    sub_6ECC0("ntp_control.c", 1682, 2, "rc >= 0 && (size_t)rc < sizeof(buffer)");
  return sub_1F0E4(a1, (int)v5, v3);
}

//----- (0001FBF0) --------------------------------------------------------
char *__fastcall sub_1FBF0(int a1)
{
  int v2; // r4
  int v3; // r4
  char v5[4]; // [sp+4h] [bp-28h] BYREF
  _BYTE v6[28]; // [sp+8h] [bp-24h] BYREF

  v2 = rand();
  v3 = v2 ^ (rand() << 16);
  v5[1] = (v3 >> 5) % 26 + 97;
  v5[0] = v3 % 26 + 97;
  v5[2] = (v3 >> 10) % 26 + 97;
  v5[3] = 46;
  sub_6C054((int)v6, 0x1Cu, (unsigned __int8 *)"%d", a1);
  return sub_1FB4C(v5, v3 >> 15);
}

//----- (0001FCCC) --------------------------------------------------------
char *__fastcall sub_1FCCC(const char *a1, _DWORD *a2)
{
  unsigned int v3; // r0
  _BYTE v5[24]; // [sp+Ch] [bp-1Ch] BYREF

  v3 = sub_6C054((int)v5, 0x18u, "0x%08lx.%08lx", *a2, a2[1]);
  if ( v3 > 0x17 )
    sub_6ECC0("ntp_control.c", 1789, 2, "rc >= 0 && (size_t)rc < sizeof(buffer)");
  return sub_1F0E4(a1, (int)v5, v3);
}

//----- (0001FD78) --------------------------------------------------------
char *__fastcall sub_1FD78(int a1, int a2, int a3)
{
  unsigned int v3; // r2
  unsigned int v4; // r3
  unsigned int v5; // r5
  int v6; // r6
  int v7; // r7
  int v8; // r3
  char *v9; // r4
  const char *v10; // r0
  const char *v11; // r8
  size_t v12; // r0
  int v14; // r5
  _BYTE *v15; // r9
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r2
  int v21; // r3
  const char *v22; // [sp+0h] [bp-88h]
  _BYTE *v25; // [sp+34h] [bp-54h]
  char v26; // [sp+3Ch] [bp-4Ch]
  int v27; // [sp+44h] [bp-44h] BYREF
  unsigned int v28; // [sp+48h] [bp-40h]
  int v29; // [sp+4Ch] [bp-3Ch]
  int v30; // [sp+50h] [bp-38h]
  int v31; // [sp+54h] [bp-34h]
  int v32; // [sp+58h] [bp-30h]
  int v33; // [sp+5Ch] [bp-2Ch]
  int v34; // [sp+60h] [bp-28h] BYREF
  unsigned int v35; // [sp+64h] [bp-24h]
  int v36; // [sp+68h] [bp-20h]
  int v37; // [sp+6Ch] [bp-1Ch]
  int v38; // [sp+70h] [bp-18h]
  int v39; // [sp+74h] [bp-14h]
  int v40; // [sp+78h] [bp-10h]
  int v41; // [sp+7Ch] [bp-Ch]
  char v42[8]; // [sp+80h] [bp-8h] BYREF
  char v43[8]; // [sp+88h] [bp+0h] BYREF
  char v44[8]; // [sp+90h] [bp+8h] BYREF
  char v45[12]; // [sp+98h] [bp+10h] BYREF
  char v46[40]; // [sp+A4h] [bp+1Ch] BYREF

  strcpy(v42, "addr.%u");
  strcpy(v43, "mask.%u");
  strcpy(v44, "hits.%u");
  v28 = 0;
  v27 = 0;
  strcpy(v45, "flags.%u");
  v29 = 0;
  v34 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  if ( a2 )
  {
    LOWORD(v27) = 10;
    LOWORD(v34) = 10;
    v16 = *(_DWORD *)(a1 + 24);
    v17 = *(_DWORD *)(a1 + 28);
    v18 = *(_DWORD *)(a1 + 32);
    v29 = *(_DWORD *)(a1 + 20);
    v30 = v16;
    v31 = v17;
    v32 = v18;
    v19 = *(_DWORD *)(a1 + 40);
    v20 = *(_DWORD *)(a1 + 44);
    v21 = *(_DWORD *)(a1 + 48);
    v36 = *(_DWORD *)(a1 + 36);
    v37 = v19;
    v38 = v20;
    v39 = v21;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 20);
    v4 = *(_DWORD *)(a1 + 24);
    LOWORD(v27) = 2;
    LOWORD(v34) = 2;
    v28 = bswap32(v3);
    v35 = bswap32(v4);
  }
  v5 = 0;
  v6 = 4;
  v7 = 0;
  v41 = 0;
  do
  {
    if ( v7 <= 1 )
    {
      v14 = rand();
      v7 = 29;
      v5 = v14 ^ (rand() << 16);
    }
    else
    {
      v7 -= 2;
    }
    v8 = v5 & 3;
    v5 >>= 2;
    while ( 1 )
    {
      v9 = &v46[v8 + 36];
      if ( !v42[v8 - 4] )
        break;
      v8 = ((_BYTE)v8 + 1) & 3;
    }
    if ( v8 == 2 )
    {
      sub_6C054((int)v46, 0x20u, (unsigned __int8 *)v44, a3);
      sub_1FB4C(v46, *(_DWORD *)(a1 + 4));
    }
    else
    {
      if ( v8 == 3 )
      {
        sub_6C054((int)v46, 0x20u, (unsigned __int8 *)v45, a3);
        v15 = sub_6D01C(*(unsigned __int16 *)(a1 + 10));
        v11 = sub_6D084(*(unsigned __int16 *)(a1 + 8));
        if ( *v15 )
        {
          v26 = lib_nextbuf;
          v25 = &lib_stringbuf[128 * lib_nextbuf];
          memset(v25, 0, 0x80u);
          v22 = v11;
          lib_nextbuf = (v26 + 1) & 0xF;
          v11 = v25;
          sub_6C054((int)v25, 0x80u, (unsigned __int8 *)"%s %s", v15, v22);
        }
        v10 = v11;
      }
      else
      {
        if ( v8 == 1 )
        {
          sub_6C054((int)v46, 0x20u, (unsigned __int8 *)v43, a3);
          v10 = sub_6C2E8((unsigned __int16 *)&v34);
        }
        else
        {
          sub_6C054((int)v46, 0x20u, (unsigned __int8 *)v42, a3);
          v10 = sub_6C2E8((unsigned __int16 *)&v27);
        }
        v11 = v10;
      }
      v12 = strlen(v10);
      sub_1F0E4(v46, (int)v11, v12);
    }
    --v6;
    *(v9 - 76) = 1;
  }
  while ( v6 );
  return sub_1FBF0(a3);
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (000200E4) --------------------------------------------------------
char *__fastcall sub_200E4(const char *a1, int a2, int a3)
{
  double v3; // d0
  unsigned int v6; // r0
  _BYTE v7[40]; // [sp+Ch] [bp-2Ch] BYREF

  if ( a2 )
    v6 = sub_6C054((int)v7, 0x28u, "%.*f", a3, v3);
  else
    v6 = sub_6C054((int)v7, 0x28u, "%.*g", a3, v3);
  if ( v6 > 0x27 )
    sub_6ECC0("ntp_control.c", 1665, 2, "rc >= 0 && (size_t)rc < sizeof(buffer)");
  return sub_1F0E4(a1, (int)v7, v6);
}
// 2016C: variable 'v3' is possibly undefined

//----- (000201A8) --------------------------------------------------------
signed int __fastcall sub_201A8(int a1, unsigned __int8 *a2, int a3)
{
  signed int result; // r0
  char *v5; // r6
  char *v6; // r8
  __int16 v7; // r3
  char *v8; // r7
  const char *v9; // r10
  size_t v10; // r2
  char *v11; // r0
  int v12; // r6
  __int16 v13; // r3
  unsigned __int8 *v14; // r1
  int v15; // r2
  bool v16; // zf
  int v17; // r2
  int v18; // r3
  int v19; // t1
  bool v20; // zf
  char *v21; // r3
  _BYTE *v22; // r3
  int v23; // r3
  unsigned int v24; // r1
  _BYTE *v25; // r4
  size_t v26; // r0
  size_t v27; // r4
  int v28; // r3
  _DWORD v29[2]; // [sp+0h] [bp-1E4h] BYREF
  char v30[468]; // [sp+8h] [bp-1DCh] BYREF
  _DWORD v31[2]; // [sp+1DCh] [bp-8h] BYREF

  result = a1 - 1;
  switch ( result )
  {
    case 0:
      if ( a3 || (v22 = (_BYTE *)*((_DWORD *)a2 + 8)) == 0 || !*v22 )
        result = (signed int)sub_1FB4C("type", *a2);
      break;
    case 1:
      result = (signed int)sub_1F2C0("timecode", *((_DWORD *)a2 + 2), *((unsigned __int16 *)a2 + 2));
      break;
    case 2:
      result = (signed int)sub_1FB4C("poll", *((_DWORD *)a2 + 3));
      break;
    case 3:
      result = (signed int)sub_1FB4C("noreply", *((_DWORD *)a2 + 4));
      break;
    case 4:
      result = (signed int)sub_1FB4C("badformat", *((_DWORD *)a2 + 5));
      break;
    case 5:
      result = (signed int)sub_1FB4C("baddata", *((_DWORD *)a2 + 6));
      break;
    case 6:
      if ( a3 || (a2[2] & 1) != 0 )
        result = (signed int)sub_200E4("fudgetime1", 1, 3);
      break;
    case 7:
      if ( a3 || (a2[2] & 2) != 0 )
        result = (signed int)sub_200E4("fudgetime2", 1, 3);
      break;
    case 8:
      if ( a3 || (a2[2] & 4) != 0 )
        result = (signed int)sub_1FAA8("stratum", *((_DWORD *)a2 + 14));
      break;
    case 9:
      if ( a3 || (a2[2] & 8) != 0 )
      {
        v23 = *((_DWORD *)a2 + 14);
        v24 = *((_DWORD *)a2 + 15);
        if ( v23 <= 1 )
          result = (signed int)sub_1F20C("refid", v24);
        else
          result = (signed int)sub_1F188("refid", v24, 0);
      }
      break;
    case 10:
      result = (signed int)sub_1FB4C("flags", a2[1]);
      break;
    case 11:
      v25 = (_BYTE *)*((_DWORD *)a2 + 8);
      if ( v25 && *v25 )
      {
        v26 = strlen(*((const char **)a2 + 8));
        result = (signed int)sub_1F2C0("device", (int)v25, v26);
      }
      else if ( a3 )
      {
        result = (signed int)sub_1F2C0("device", (int)&unk_97F7C, 0);
      }
      break;
    case 12:
      sub_6C054((int)v30, 0x1D4u, "%s=\"", "clock_var_list");
      v5 = (char *)&unk_B3EF0;
      result = strlen(v30);
      v6 = &v30[result];
      LOBYTE(v7) = 1;
      v8 = &v30[result];
      while ( 1 )
      {
        v5 += 8;
        if ( (v7 & 0x80) != 0 )
          break;
        if ( (v7 & 0x40) == 0 )
        {
          v9 = (const char *)*((_DWORD *)v5 + 1);
          result = strlen(v9);
          v10 = result;
          if ( v31 <= (_DWORD *)&v8[result + 1] )
            break;
          if ( v8 == v6 )
          {
            v11 = v6;
          }
          else
          {
            v11 = v8 + 1;
            *v8 = 44;
          }
          v8 = &v11[v10];
          result = (signed int)memcpy(v11, v9, v10);
        }
        v7 = *((_WORD *)v5 + 5);
      }
      v12 = *((_DWORD *)a2 + 17);
      if ( v12 )
      {
        v13 = *(_WORD *)(v12 + 2);
        if ( (v13 & 0x80) == 0 )
        {
          while ( 1 )
          {
            if ( (v13 & 0x40) == 0 )
            {
              v14 = *(unsigned __int8 **)(v12 + 4);
              if ( v14 )
              {
                v15 = *v14;
                v16 = v15 == 61;
                if ( v15 != 61 )
                  v16 = v15 == 0;
                if ( v16 )
                {
                  v27 = 0;
                  v28 = 1;
                }
                else
                {
                  v17 = *(_DWORD *)(v12 + 4);
                  do
                  {
                    v19 = *(unsigned __int8 *)++v17;
                    v18 = v19;
                    v20 = v19 == 0;
                    if ( v19 )
                      v20 = v18 == 61;
                  }
                  while ( !v20 );
                  v27 = v17 - (_DWORD)v14;
                  v28 = v17 - (_DWORD)v14 + 1;
                }
                if ( v31 <= (_DWORD *)&v8[v28] )
                  break;
                if ( v6 == v8 )
                  v21 = v6;
                else
                  v21 = (char *)&word_2C;
                if ( v6 != v8 )
                {
                  *v8 = (char)v21;
                  v21 = v8 + 1;
                  v14 = *(unsigned __int8 **)(v12 + 4);
                }
                v8 = &v21[v27];
                result = (signed int)memcpy(v21, v14, v27);
                *(_BYTE *)(result + v27) = 0;
              }
            }
            v12 += 8;
            if ( v12 )
            {
              v13 = *(_WORD *)(v12 + 2);
              if ( (v13 & 0x80) == 0 )
                continue;
            }
            break;
          }
        }
      }
      if ( v31 > (_DWORD *)(v8 + 2) )
      {
        *v8 = 34;
        v8[1] = 0;
        v29[0] = v30;
        v29[1] = v8 + 1 - v30;
        result = (signed int)sub_1EEC8((char *)v29, 1, 0);
      }
      break;
    default:
      return result;
  }
  return result;
}
// 2C: using guessed type __int16;

//----- (00020608) --------------------------------------------------------
char *__fastcall sub_20608(const char *a1, int a2, int a3)
{
  int v5; // r5
  _BYTE *v6; // r4
  int v7; // r3
  bool v8; // zf
  double *v9; // r3
  signed int v10; // r0
  _BYTE v13[200]; // [sp+14h] [bp-C8h] BYREF
  _DWORD v14[2]; // [sp+DCh] [bp+0h] BYREF

  v5 = a3;
  v6 = v13;
  v7 = _stack_chk_guard;
  do
  {
    v8 = v5 == 0;
    if ( v5 )
      --v5;
    else
      v7 = 56;
    if ( !v8 )
      v7 = 8 * v5;
    v9 = (double *)(a2 + v7);
    if ( v8 )
      v5 = 7;
    v10 = sub_6C054((int)v6, (char *)v14 - v6, " %.2f", v9, *v9 * 1000.0);
    if ( v10 < 0 || (char *)v14 - v6 <= (unsigned int)v10 )
      sub_6ECC0("ntp_control.c", 1862, 2, "rc >= 0 && (size_t)rc < (size_t)(ep - cp)");
    v6 += v10;
  }
  while ( a3 != v5 );
  return sub_1F0E4(a1, (int)v13, v6 - v13);
}
// 20674: variable 'v7' is possibly undefined

//----- (0002071C) --------------------------------------------------------
char *__fastcall sub_2071C(const char *a1, int a2)
{
  char *result; // r0
  unsigned int v4; // r2
  time_t v5; // [sp+10h] [bp-18h] BYREF
  _BYTE v6[16]; // [sp+14h] [bp-14h] BYREF

  v5 = a2 + 2085978496;
  result = (char *)gmtime(&v5);
  if ( result )
  {
    v4 = sub_6C054(
           (int)v6,
           0x10u,
           "%04d%02d%02d%02d%02d",
           *((_DWORD *)result + 5) + 1900,
           *((_DWORD *)result + 4) + 1,
           *((_DWORD *)result + 3),
           *((_DWORD *)result + 2),
           *((_DWORD *)result + 1));
    if ( v4 > 0xF )
      sub_6ECC0("ntp_control.c", 1732, 2, "rc >= 0 && (size_t)rc < sizeof(buffer)");
    return sub_1F0E4(a1, (int)v6, v4);
  }
  return result;
}

//----- (00020810) --------------------------------------------------------
size_t __fastcall sub_20810(int a1, int a2)
{
  size_t result; // r0
  int v4; // r1
  int v5; // r0
  int digestbyname; // r0
  int v7; // r0
  const char *v8; // r5
  size_t v9; // r0
  int *v10; // r6
  int v11; // r5
  size_t v12; // r0
  int v13; // r5
  size_t v14; // r0
  int v15; // r1
  int v16; // r5
  size_t v17; // r0
  char *v18; // r7
  __int16 v19; // r3
  char *v20; // r6
  char *i; // r5
  const char *v22; // r11
  size_t v23; // r2
  char *v24; // r0
  int v25; // r3
  int v26; // r1
  unsigned int v27; // r1
  int v28; // r2
  unsigned int v29; // r1
  unsigned __int16 *v30; // r2
  _DWORD v31[2]; // [sp+0h] [bp-1E4h] BYREF
  char v32[468]; // [sp+8h] [bp-1DCh] BYREF
  _DWORD v33[2]; // [sp+1DCh] [bp-8h] BYREF

  result = a1 - 1;
  switch ( result )
  {
    case 0u:
      result = (size_t)sub_1FB4C("config", ((*(_DWORD *)(a2 + 68) ^ 2u) >> 1) & 1);
      break;
    case 1u:
      result = (size_t)sub_1FB4C("authenable", *(_DWORD *)(a2 + 124) == 0);
      break;
    case 2u:
      result = (size_t)sub_1FB4C("authentic", (*(_DWORD *)(a2 + 68) >> 2) & 1);
      break;
    case 3u:
      result = (size_t)sub_1F188("srcadr", 0, (unsigned __int16 *)(a2 + 16));
      break;
    case 4u:
      result = (size_t)sub_1FB4C("srcport", (unsigned __int16)__rev16(*(unsigned __int16 *)(a2 + 18)));
      break;
    case 5u:
      v30 = *(unsigned __int16 **)(a2 + 56);
      if ( v30 )
        v30 += 12;
      result = (size_t)sub_1F188("dstadr", 0, v30);
      break;
    case 6u:
      v4 = *(_DWORD *)(a2 + 56);
      if ( v4 )
        v4 = (unsigned __int16)__rev16(*(unsigned __int16 *)(v4 + 26));
      result = (size_t)sub_1FB4C("dstport", v4);
      break;
    case 7u:
      result = (size_t)sub_1FB4C("leap", *(unsigned __int8 *)(a2 + 91));
      break;
    case 8u:
      result = (size_t)sub_1FB4C("hmode", *(unsigned __int8 *)(a2 + 63));
      break;
    case 9u:
      result = (size_t)sub_1FB4C("stratum", *(unsigned __int8 *)(a2 + 93));
      break;
    case 0xAu:
      result = (size_t)sub_1FB4C("ppoll", *(unsigned __int8 *)(a2 + 94));
      break;
    case 0xBu:
      result = (size_t)sub_1FB4C("hpoll", *(unsigned __int8 *)(a2 + 64));
      break;
    case 0xCu:
      result = (size_t)sub_1FAA8("precision", *(char *)(a2 + 95));
      break;
    case 0xDu:
      result = (size_t)sub_200E4("rootdelay", 1, 3);
      break;
    case 0xEu:
      result = (size_t)sub_200E4("rootdisp", 1, 3);
      break;
    case 0xFu:
      v28 = *(_DWORD *)(a2 + 68);
      v29 = *(_DWORD *)(a2 + 112);
      if ( (v28 & 8) != 0 || (unsigned int)*(unsigned __int8 *)(a2 + 93) - 2 > 0xD )
        result = (size_t)sub_1F20C("refid", v29);
      else
        result = (size_t)sub_1F188("refid", v29, 0);
      break;
    case 0x10u:
      result = (size_t)sub_1FCCC("reftime", (_DWORD *)(a2 + 116));
      break;
    case 0x11u:
      result = (size_t)sub_1FCCC("org", (_DWORD *)(a2 + 584));
      break;
    case 0x12u:
      result = (size_t)sub_1FCCC("rec", (_DWORD *)(a2 + 576));
      break;
    case 0x13u:
      if ( *(double *)(a2 + 640) != 0.0 )
        result = (size_t)sub_200E4("xleave", 1, 3);
      break;
    case 0x14u:
      result = (size_t)sub_1FA04("reach", *(unsigned __int8 *)(a2 + 298));
      break;
    case 0x15u:
      result = (size_t)sub_1FB4C("unreach", *(_DWORD *)(a2 + 708));
      break;
    case 0x16u:
      result = (size_t)sub_1FB4C("timer", *(_DWORD *)(a2 + 720) - current_time);
      break;
    case 0x17u:
      result = (size_t)sub_200E4("delay", 1, 3);
      break;
    case 0x18u:
      result = (size_t)sub_200E4("offset", 1, 3);
      break;
    case 0x19u:
      result = (size_t)sub_200E4("jitter", 1, 3);
      break;
    case 0x1Au:
      result = (size_t)sub_200E4("dispersion", 1, 3);
      break;
    case 0x1Bu:
      v27 = *(_DWORD *)(a2 + 124);
      if ( v27 < 0x10000 )
        result = (size_t)sub_1FB4C("keyid", v27);
      else
        result = (size_t)sub_1FA04("keyid", v27);
      break;
    case 0x1Cu:
      result = (size_t)sub_20608("filtdelay", a2 + 328, *(_DWORD *)(a2 + 320));
      break;
    case 0x1Du:
      result = (size_t)sub_20608("filtoffset", a2 + 392, *(_DWORD *)(a2 + 320));
      break;
    case 0x1Eu:
      result = (size_t)sub_1FB4C("pmode", *(unsigned __int8 *)(a2 + 92));
      break;
    case 0x1Fu:
      result = (size_t)sub_1FB4C("received", *(_DWORD *)(a2 + 744));
      break;
    case 0x20u:
      result = (size_t)sub_1FB4C("sent", *(_DWORD *)(a2 + 740));
      break;
    case 0x21u:
      result = (size_t)sub_20608("filtdisp", a2 + 456, *(_DWORD *)(a2 + 320));
      break;
    case 0x22u:
      result = (size_t)sub_1FA04("flash", *(_DWORD *)(a2 + 300));
      break;
    case 0x23u:
      v25 = *(_DWORD *)(a2 + 68);
      v26 = *(_DWORD *)(a2 + 76);
      if ( (v25 & 8) != 0 )
      {
        result = (size_t)sub_1FB4C("ttl", v26);
      }
      else if ( (unsigned int)(v26 - 1) <= 6 )
      {
        result = (size_t)sub_1FAA8("ttl", (unsigned __int8)sys_ttl[v26]);
      }
      break;
    case 0x24u:
      sub_6C054((int)v32, 0x1D4u, "%s=\"", "peer_var_list");
      result = strlen(v32);
      v18 = &v32[result];
      LOBYTE(v19) = 1;
      v20 = &v32[result];
      for ( i = (char *)&unk_B3F68; ; v19 = *((_WORD *)i + 5) )
      {
        i += 8;
        if ( (v19 & 0x80) != 0 )
          break;
        if ( (v19 & 0x40) == 0 )
        {
          v22 = (const char *)*((_DWORD *)i + 1);
          result = strlen(v22);
          v23 = result;
          if ( v33 <= (_DWORD *)&v20[result + 1] )
            break;
          if ( v20 == v18 )
          {
            v24 = v18;
          }
          else
          {
            *v20 = 44;
            v24 = v20 + 1;
          }
          v20 = &v24[v23];
          result = (size_t)memcpy(v24, v22, v23);
        }
      }
      if ( v33 > (_DWORD *)(v20 + 2) )
      {
        *v20 = 34;
        v20[1] = 0;
        v31[0] = v32;
        v31[1] = v20 + 1 - v32;
        result = (size_t)sub_1EEC8((char *)v31, 1, 0);
      }
      break;
    case 0x25u:
      if ( *(double *)(a2 + 672) > 0.0 )
        result = (size_t)sub_200E4("in", 1, 3);
      break;
    case 0x26u:
      if ( *(double *)(a2 + 696) > 0.0 )
        result = (size_t)sub_200E4("out", 1, 3);
      break;
    case 0x27u:
      result = (size_t)sub_1FB4C("headway", *(_DWORD *)(a2 + 712));
      break;
    case 0x28u:
      if ( *(double *)(a2 + 648) != 0.0 )
        result = (size_t)sub_200E4("bias", 1, 3);
      break;
    case 0x29u:
      v16 = *(_DWORD *)(a2 + 44);
      if ( v16 )
      {
        v17 = strlen(*(const char **)(a2 + 44));
        result = (size_t)sub_1F2C0("srchost", v16, v17);
      }
      break;
    case 0x2Au:
      result = (size_t)sub_1FB4C("timerec", current_time - *(_DWORD *)(a2 + 732));
      break;
    case 0x2Bu:
      result = (size_t)sub_1FB4C("timereach", current_time - *(_DWORD *)(a2 + 736));
      break;
    case 0x2Cu:
      result = (size_t)sub_1FB4C("badauth", *(_DWORD *)(a2 + 752));
      break;
    case 0x2Du:
      result = (size_t)sub_1FB4C("bogusorg", *(_DWORD *)(a2 + 760));
      break;
    case 0x2Eu:
      result = (size_t)sub_1FB4C("oldpkt", *(_DWORD *)(a2 + 764));
      break;
    case 0x2Fu:
      result = (size_t)sub_1FB4C("seldisp", *(_DWORD *)(a2 + 768));
      break;
    case 0x30u:
      result = (size_t)sub_1FB4C("selbroken", *(_DWORD *)(a2 + 772));
      break;
    case 0x31u:
      result = (size_t)sub_1FB4C("candidate", *(unsigned __int8 *)(a2 + 296));
      break;
    case 0x32u:
      v15 = *(_DWORD *)(a2 + 136);
      if ( v15 )
        result = (size_t)sub_1FA04("flags", v15);
      break;
    case 0x33u:
      v13 = *(_DWORD *)(a2 + 148);
      if ( v13 )
      {
        v14 = strlen(*(const char **)(a2 + 148));
        result = (size_t)sub_1F2C0("host", v13, v14);
      }
      break;
    case 0x35u:
      v10 = *(int **)(a2 + 220);
      if ( v10 )
      {
        sub_1FAA8("initsequence", v10[1]);
        sub_1FA04("initkey", *v10);
        result = (size_t)sub_2071C("timestamp", bswap32(*(_DWORD *)(a2 + 208)));
      }
      break;
    case 0x38u:
      result = *(_DWORD *)(a2 + 136);
      if ( result )
      {
        v5 = OBJ_nid2sn(HIWORD(result));
        digestbyname = EVP_get_digestbyname(v5);
        v7 = EVP_MD_pkey_type(digestbyname);
        v8 = (const char *)OBJ_nid2ln(v7);
        v9 = strlen(v8);
        result = (size_t)sub_1F2C0("signature", (int)v8, v9);
      }
      break;
    case 0x39u:
      v11 = *(_DWORD *)(a2 + 80);
      if ( v11 )
      {
        v12 = strlen(*(const char **)(a2 + 80));
        result = (size_t)sub_1F2C0("ident", v11, v12);
      }
      break;
    default:
      return result;
  }
  return result;
}
// B43C: using guessed type int __fastcall OBJ_nid2ln(_DWORD);
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// BB00: using guessed type int __fastcall EVP_MD_pkey_type(_DWORD);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// 108CA4: using guessed type int current_time;

//----- (000211F8) --------------------------------------------------------
__int16 *__fastcall sub_211F8(int a1)
{
  unsigned int v1; // r4
  __int16 v2; // r4
  unsigned int v4; // r11
  int v5; // r6
  unsigned int v6; // r5
  int v7; // r8
  int v8; // r7
  unsigned int v9; // r2
  unsigned int v10; // r3
  char *v11; // r4
  size_t v12; // r0
  int v13; // r2
  char *v14; // r1
  size_t v15; // r0
  int v16; // r5
  size_t v17; // r0
  _DWORD *v18; // r5
  int v19; // r4
  int v20; // r2
  _DWORD *v21; // r5
  int v22; // r2
  unsigned __int8 *v23; // [sp+0h] [bp-D0h]
  const char *v24; // [sp+34h] [bp-9Ch]
  const char *v25; // [sp+34h] [bp-9Ch]
  char v26[8]; // [sp+50h] [bp-80h] BYREF
  char v27[8]; // [sp+58h] [bp-78h] BYREF
  char v28[8]; // [sp+60h] [bp-70h] BYREF
  char v29[8]; // [sp+68h] [bp-68h] BYREF
  char v30[8]; // [sp+70h] [bp-60h] BYREF
  char v31[8]; // [sp+78h] [bp-58h] BYREF
  char v32[8]; // [sp+80h] [bp-50h] BYREF
  char s1[8]; // [sp+88h] [bp-48h] BYREF
  char v34[8]; // [sp+90h] [bp-40h] BYREF
  char v35[8]; // [sp+98h] [bp-38h] BYREF
  char v36[12]; // [sp+A0h] [bp-30h] BYREF
  char v37[12]; // [sp+ACh] [bp-24h] BYREF
  char v38[12]; // [sp+B8h] [bp-18h] BYREF
  _DWORD v39[3]; // [sp+C4h] [bp-Ch] BYREF
  char v40[20]; // [sp+D0h] [bp+0h] BYREF
  char v41[40]; // [sp+E4h] [bp+14h] BYREF

  v1 = *(unsigned __int16 *)(a1 + 98);
  strcpy(s1, "ifstats");
  v2 = __rev16(v1);
  strcpy(v40, "addr_restrictions");
  if ( !v2 )
  {
LABEL_7:
    if ( sys_ifnum )
    {
      v4 = 0;
      do
      {
        v5 = ep_list;
        if ( ep_list )
        {
          while ( *(_DWORD *)(v5 + 20) != v4 )
          {
            v5 = *(_DWORD *)v5;
            if ( !v5 )
              goto LABEL_24;
          }
          strcpy(v34, "addr.%u");
          v23 = (unsigned __int8 *)v35;
          v6 = 0;
          strcpy(v36, "bcast.%u");
          v7 = 0;
          strcpy(v26, "en.%u");
          strcpy(v35, "name.%u");
          strcpy(v37, "flags.%u");
          strcpy(v27, "tl.%u");
          memset(v39, 0, sizeof(v39));
          strcpy(v28, "mc.%u");
          strcpy(v29, "rx.%u");
          v8 = 12;
          strcpy(v30, "tx.%u");
          strcpy(v38, "txerr.%u");
          strcpy(v31, "pc.%u");
          strcpy(v32, "up.%u");
          do
          {
            if ( v7 <= 3 )
            {
              v16 = rand();
              v7 = 27;
              v6 = v16 ^ (rand() << 16);
            }
            else
            {
              v7 -= 4;
            }
            v9 = v6 & 0xF;
            v6 >>= 4;
            while ( 1 )
            {
              v10 = v9 % 0xC;
              v11 = &v41[v9 % 0xC + 36];
              if ( !*((_BYTE *)v39 + v9 % 0xC) )
                break;
              v9 = v10 + 1;
            }
            switch ( v10 )
            {
              case 1u:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v36, v4, v23);
                v13 = *(_DWORD *)(v5 + 144) & 0x20;
                if ( v13 )
                {
                  v25 = sub_6C47C((unsigned __int16 *)(v5 + 80));
                  v17 = strlen(v25);
                  v14 = (char *)v25;
                  v13 = v17;
                }
                else
                {
                  v14 = byte_97F7C;
                }
                sub_1F0E4(v41, (int)v14, v13);
                break;
              case 2u:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v26, v4, v23);
                sub_1FAA8(v41, *(_DWORD *)(v5 + 180) == 0);
                break;
              case 3u:
                sub_6C054((int)v41, 0x20u, v23, v4, v23);
                v12 = strlen((const char *)(v5 + 108));
                sub_1F2C0(v41, v5 + 108, v12);
                break;
              case 4u:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v37, v4, v23);
                sub_1FA04(v41, *(_DWORD *)(v5 + 144));
                break;
              case 5u:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v27, v4, v23);
                sub_1FAA8(v41, *(_DWORD *)(v5 + 148));
                break;
              case 6u:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v28, v4, v23);
                sub_1FAA8(v41, *(_DWORD *)(v5 + 156));
                break;
              case 7u:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v29, v4, v23);
                sub_1FAA8(v41, *(_DWORD *)(v5 + 164));
                break;
              case 8u:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v30, v4, v23);
                sub_1FAA8(v41, *(_DWORD *)(v5 + 168));
                break;
              case 9u:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v38, v4, v23);
                sub_1FAA8(v41, *(_DWORD *)(v5 + 172));
                break;
              case 0xAu:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v31, v4, v23);
                sub_1FB4C(v41, *(_DWORD *)(v5 + 188));
                break;
              case 0xBu:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v32, v4, v23);
                sub_1FB4C(v41, current_time - *(_DWORD *)(v5 + 160));
                break;
              default:
                sub_6C054((int)v41, 0x20u, (unsigned __int8 *)v34, v4, v23);
                v24 = sub_6C47C((unsigned __int16 *)(v5 + 24));
                v15 = strlen(v24);
                sub_1F0E4(v41, (int)v24, v15);
                break;
            }
            --v8;
            *(v11 - 68) = 1;
          }
          while ( v8 );
          sub_1FBF0(v4);
        }
LABEL_24:
        ++v4;
      }
      while ( v4 < sys_ifnum );
    }
    return sub_1EBA4(0);
  }
  if ( v2 == 7 )
  {
    if ( memcmp(s1, (const void *)(a1 + 100), 7u) )
      return (__int16 *)sub_1F4D0(5);
    goto LABEL_7;
  }
  if ( v2 != 17 || memcmp(v40, (const void *)(a1 + 100), 0x11u) )
    return (__int16 *)sub_1F4D0(5);
  v18 = (_DWORD *)restrictlist4;
  if ( restrictlist4 )
  {
    v19 = 0;
    do
    {
      v20 = v19++;
      sub_1FD78((int)v18, 0, v20);
      v18 = (_DWORD *)*v18;
    }
    while ( v18 );
  }
  else
  {
    v19 = 0;
  }
  v21 = (_DWORD *)restrictlist6;
  if ( !restrictlist6 )
    return sub_1EBA4(0);
  do
  {
    v22 = v19++;
    sub_1FD78((int)v21, 1, v22);
    v21 = (_DWORD *)*v21;
  }
  while ( v21 );
  return sub_1EBA4(0);
}
// 21550: variable 'v23' is possibly undefined
// 107D28: using guessed type int ep_list;
// 107D48: using guessed type int sys_ifnum;
// 108C88: using guessed type int restrictlist4;
// 108C8C: using guessed type int restrictlist6;
// 108CA4: using guessed type int current_time;

//----- (00021888) --------------------------------------------------------
signed int __fastcall sub_21888(signed int result)
{
  char *v1; // r4
  const char *v2; // r4
  size_t v3; // r2
  struct timex *v4; // r0
  unsigned __int8 *v5; // r0
  size_t v6; // r0
  size_t v7; // r0
  int v8; // r0
  int digestbyname; // r0
  int v10; // r0
  unsigned __int8 *v11; // r0
  size_t v12; // r0
  int i; // r4
  size_t v14; // r0
  unsigned int v15; // r2
  size_t v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r0
  const char *v21; // r4
  size_t v22; // r0
  __int64 v23; // r0
  double v24; // r0
  int v25; // r2
  int v26; // r1
  const char *v27; // r0
  double v28; // d7
  int v29; // s13
  double v30; // d7
  int v31; // r9
  char *v32; // r4
  __int16 v33; // r3
  char *v34; // r8
  char *v35; // r5
  const char *v36; // r11
  char v37; // r3
  size_t v38; // r2
  bool v39; // zf
  char *v40; // r0
  int j; // r5
  const char *v42; // r11
  char *v43; // r0
  __int16 v44; // r3
  size_t v45; // r2
  size_t v46; // r0
  size_t v47; // r0
  size_t v48; // r0
  int v49; // [sp+14h] [bp-200h] BYREF
  int v50; // [sp+18h] [bp-1FCh]
  _DWORD v51[2]; // [sp+20h] [bp-1F4h] BYREF
  _BYTE v52[16]; // [sp+28h] [bp-1ECh] BYREF
  char v53[468]; // [sp+38h] [bp-1DCh] BYREF
  _DWORD v54[2]; // [sp+20Ch] [bp-8h] BYREF

  v1 = (char *)result;
  if ( (unsigned int)(result - 59) <= 0xF && current_time != dword_B96CC )
  {
    v4 = (struct timex *)memset(&unk_B96D0, 0, 0x80u);
    result = adjtimex(v4);
    if ( result < 0 )
      result = (signed int)sub_64E00(3, "ntp_adjtime() for mode 6 query failed: %m");
    else
      dword_B96CC = current_time;
  }
  switch ( (unsigned int)v1 )
  {
    case 1u:
      return (signed int)sub_1FB4C("leap", (unsigned __int8)sys_leap);
    case 2u:
      return (signed int)sub_1FB4C("stratum", (unsigned __int8)sys_stratum);
    case 3u:
      return (signed int)sub_1FAA8("precision", sys_precision);
    case 4u:
      return (signed int)sub_200E4("rootdelay", 1, 3);
    case 5u:
      return (signed int)sub_200E4("rootdisp", 1, 3);
    case 6u:
      if ( (unsigned int)(unsigned __int8)sys_stratum - 2 <= 0xD )
        return (signed int)sub_1F188("refid", sys_refid, 0);
      else
        return (signed int)sub_1F20C("refid", sys_refid);
    case 7u:
      return (signed int)sub_1FCCC("reftime", &sys_reftime);
    case 8u:
      return (signed int)sub_1FB4C("tc", (unsigned __int8)sys_poll);
    case 9u:
      if ( sys_peer )
        return (signed int)sub_1FB4C("peer", *(unsigned __int16 *)(sys_peer + 60));
      else
        return (signed int)sub_1FB4C("peer", 0);
    case 0xAu:
      return (signed int)sub_200E4("offset", 1, 6);
    case 0xBu:
      return (signed int)sub_200E4("frequency", 1, 3);
    case 0xCu:
      return (signed int)sub_200E4("sys_jitter", 1, 6);
    case 0xDu:
      return (signed int)sub_200E4("clk_jitter", 1, 3);
    case 0xEu:
      sub_5F724(&v49);
      return (signed int)sub_1FCCC("clock", &v49);
    case 0xFu:
      v48 = strlen(byte_B9854);
      return (signed int)sub_1F2C0("processor", (int)byte_B9854, v48);
    case 0x10u:
      sub_6C054((int)v53, 0x100u, "%s/%s", byte_B9750, &byte_B9750[130]);
      v47 = strlen(v53);
      return (signed int)sub_1F2C0("system", (int)v53, v47);
    case 0x11u:
      v46 = strlen(Version);
      return (signed int)sub_1F2C0("version", (int)Version, v46);
    case 0x12u:
      return (signed int)sub_200E4("clk_wander", 1, 3);
    case 0x13u:
      v31 = 1;
      sub_6C054((int)v53, 0x1D4u, "%s=\"", "sys_var_list");
      result = strlen(v53);
      v32 = &v53[result];
      LOBYTE(v33) = 3;
      v34 = (char *)((char *)v54 - &v53[result]);
      v35 = (char *)&unk_B4148;
      break;
    case 0x14u:
      if ( sys_tai )
        return (signed int)sub_1FB4C("tai", sys_tai);
      return result;
    case 0x15u:
      result = (signed int)sub_2DB68(&v49);
      if ( v50 )
        return (signed int)sub_2071C("leapsec", v50);
      return result;
    case 0x16u:
      result = (signed int)sub_2DB68(&v49);
      if ( v49 )
        return (signed int)sub_2071C("expire", v49);
      return result;
    case 0x17u:
      return (signed int)sub_1FB4C("mintc", (unsigned __int8)ntp_minpoll);
    case 0x18u:
      return (signed int)sub_1FA04("mru_enabled", mon_enabled);
    case 0x19u:
      return (signed int)sub_1FB4C("mru_depth", SLODWORD(mru_entries));
    case 0x1Au:
      return (signed int)sub_1FB4C("mru_deepest", mru_peakentries);
    case 0x1Bu:
      return (signed int)sub_1FB4C("mru_mindepth", (int)mru_mindepth);
    case 0x1Cu:
      return (signed int)sub_1FAA8("mru_maxage", (int)mru_maxage);
    case 0x1Du:
      return (signed int)sub_1FB4C("mru_maxdepth", mru_maxdepth);
    case 0x1Eu:
      v27 = "mru_mem";
      v30 = (double)LODWORD(mru_entries) * 0.0703125;
      v29 = (unsigned int)v30;
      if ( v30 - (double)(unsigned int)v30 >= 0.5 )
        ++v29;
      return (signed int)sub_1FB4C(v27, v29);
    case 0x1Fu:
      v27 = "mru_maxmem";
      v28 = (double)(unsigned int)mru_maxdepth * 0.0703125;
      v29 = (unsigned int)v28;
      if ( v28 - (double)(unsigned int)v28 >= 0.5 )
        ++v29;
      return (signed int)sub_1FB4C(v27, v29);
    case 0x20u:
      return (signed int)sub_1FB4C("ss_uptime", current_time);
    case 0x21u:
      return (signed int)sub_1FB4C("ss_reset", current_time - sys_stattime);
    case 0x22u:
      return (signed int)sub_1FB4C("ss_received", sys_received);
    case 0x23u:
      return (signed int)sub_1FB4C("ss_thisver", sys_newversion);
    case 0x24u:
      return (signed int)sub_1FB4C("ss_oldver", sys_oldversion);
    case 0x25u:
      return (signed int)sub_1FB4C("ss_badformat", sys_badlength);
    case 0x26u:
      return (signed int)sub_1FB4C("ss_badauth", sys_badauth);
    case 0x27u:
      return (signed int)sub_1FB4C("ss_declined", sys_declined);
    case 0x28u:
      return (signed int)sub_1FB4C("ss_restricted", sys_restricted);
    case 0x29u:
      return (signed int)sub_1FB4C("ss_limited", sys_limitrejected);
    case 0x2Au:
      return (signed int)sub_1FB4C("ss_kodsent", sys_kodsent);
    case 0x2Bu:
      return (signed int)sub_1FB4C("ss_processed", sys_processed);
    case 0x2Cu:
      return (signed int)sub_1FB4C("ss_lamport", sys_lamport);
    case 0x2Du:
      return (signed int)sub_1FB4C("ss_tsrounding", sys_tsrounding);
    case 0x2Eu:
      if ( sys_peer )
      {
        if ( *(_DWORD *)(sys_peer + 56) )
        {
          v2 = sub_6C47C((unsigned __int16 *)(sys_peer + 16));
          v3 = strlen(v2);
        }
        else
        {
          v3 = 9;
          v2 = "0.0.0.0:0";
        }
      }
      else
      {
        v3 = 9;
        v2 = "0.0.0.0:0";
      }
      return (signed int)sub_1F0E4("peeradr", (int)v2, v3);
    case 0x2Fu:
      v26 = sys_peer;
      if ( sys_peer )
        v26 = *(unsigned __int8 *)(sys_peer + 63);
      return (signed int)sub_1FB4C("peermode", v26);
    case 0x30u:
      return (signed int)sub_200E4("bcastdelay", 1, 3);
    case 0x31u:
      v23 = __PAIR64__(sys_authdelay, 0) + (unsigned int)dword_108BF4;
      if ( (sys_authdelay & 0x80000000) != 0 )
        sub_8BEC4(-v23);
      else
        sub_8BEC4(v23);
      LODWORD(v24) = -32;
      ldexp(v24, v25);
      return (signed int)sub_200E4("authdelay", 1, 3);
    case 0x32u:
      return (signed int)sub_1FB4C("authkeys", authnumkeys);
    case 0x33u:
      return (signed int)sub_1FB4C("authfreek", authnumfreekeys);
    case 0x34u:
      return (signed int)sub_1FB4C("authklookups", authkeylookups);
    case 0x35u:
      return (signed int)sub_1FB4C("authknotfound", authkeynotfound);
    case 0x36u:
      return (signed int)sub_1FB4C("authkuncached", authkeyuncached);
    case 0x37u:
      return (signed int)sub_1FB4C("authkexpired", authkeyexpired);
    case 0x38u:
      return (signed int)sub_1FB4C("authencrypts", authencryptions);
    case 0x39u:
      return (signed int)sub_1FB4C("authdecrypts", authdecryptions);
    case 0x3Au:
      return (signed int)sub_1FB4C("authreset", current_time - auth_timereset);
    case 0x3Bu:
      return (signed int)sub_200E4("koffset", 0, -1);
    case 0x3Cu:
      return (signed int)sub_200E4("kfreq", 0, -1);
    case 0x3Du:
      return (signed int)sub_200E4("kmaxerr", 0, 6);
    case 0x3Eu:
      return (signed int)sub_200E4("kesterr", 0, 6);
    case 0x3Fu:
      v21 = sub_6D0EC(dword_B96E4);
      v22 = strlen(v21);
      return (signed int)sub_1F2C0("kstflags", (int)v21, v22);
    case 0x40u:
      return (signed int)sub_1FAA8("ktimeconst", dword_B96E8);
    case 0x41u:
      return (signed int)sub_200E4("kprecis", 0, 6);
    case 0x42u:
      return (signed int)sub_200E4("kfreqtol", 0, -1);
    case 0x43u:
      if ( dword_B9708 )
        return (signed int)sub_200E4("kppsfreq", 0, -1);
      else
        return (signed int)sub_1FAA8("kppsfreq", 0);
    case 0x44u:
      if ( dword_B9708 )
        return (signed int)sub_200E4("kppsstab", 0, -1);
      else
        return (signed int)sub_1FAA8("kppsstab", 0);
    case 0x45u:
      if ( dword_B9708 )
        return (signed int)sub_200E4("kppsjitter", 1, 3);
      else
        return (signed int)sub_1FAA8("kppsjitter", 0);
    case 0x46u:
      if ( dword_B9708 )
        return (signed int)sub_1FAA8("kppscalibdur", 1 << dword_B9708);
      else
        return (signed int)sub_1FAA8("kppscalibdur", 0);
    case 0x47u:
      if ( dword_B9708 )
        return (signed int)sub_1FAA8("kppscalibs", dword_B9714);
      else
        return (signed int)sub_1FAA8("kppscalibs", 0);
    case 0x48u:
      if ( dword_B9708 )
        return (signed int)sub_1FAA8("kppscaliberrs", dword_B9718);
      else
        return (signed int)sub_1FAA8("kppscaliberrs", 0);
    case 0x49u:
      if ( dword_B9708 )
        return (signed int)sub_1FAA8("kppsjitexc", dword_B9710);
      else
        return (signed int)sub_1FAA8("kppsjitexc", 0);
    case 0x4Au:
      if ( dword_B9708 )
        return (signed int)sub_1FAA8("kppsstbexc", dword_B971C);
      else
        return (signed int)sub_1FAA8("kppsstbexc", 0);
    case 0x4Bu:
      return (signed int)sub_1FB4C("iostats_reset", current_time - io_timereset);
    case 0x4Cu:
      v20 = sub_69E00();
      return (signed int)sub_1FB4C("total_rbuf", v20);
    case 0x4Du:
      v19 = sub_69D58();
      return (signed int)sub_1FB4C("free_rbuf", v19);
    case 0x4Eu:
      v18 = sub_69DAC();
      return (signed int)sub_1FB4C("used_rbuf", v18);
    case 0x4Fu:
      v17 = sub_69E54();
      return (signed int)sub_1FB4C("rbuf_lowater", v17);
    case 0x50u:
      return (signed int)sub_1FB4C("io_dropped", packets_dropped);
    case 0x51u:
      return (signed int)sub_1FB4C("io_ignored", packets_ignored);
    case 0x52u:
      return (signed int)sub_1FB4C("io_received", packets_received);
    case 0x53u:
      return (signed int)sub_1FB4C("io_sent", packets_sent);
    case 0x54u:
      return (signed int)sub_1FB4C("io_sendfailed", packets_notsent);
    case 0x55u:
      return (signed int)sub_1FB4C("io_wakeups", handler_calls);
    case 0x56u:
      return (signed int)sub_1FB4C("io_goodwakeups", handler_pkts);
    case 0x57u:
      return (signed int)sub_1FB4C("timerstats_reset", current_time - timer_timereset);
    case 0x58u:
      return (signed int)sub_1FB4C("timer_overruns", alarm_overflow);
    case 0x59u:
      return (signed int)sub_1FB4C("timer_xmts", timer_xmtcalls);
    case 0x5Au:
      return (signed int)sub_200E4("fuzz", 1, 3);
    case 0x5Bu:
      return (signed int)sub_200E4("clk_wander_threshold", 1, 3);
    case 0x5Eu:
      if ( crypto_flags )
        return (signed int)sub_1FA04("flags", crypto_flags);
      return result;
    case 0x5Fu:
      if ( dword_108274 )
      {
        v16 = strlen((const char *)dword_108274);
        return (signed int)sub_1F2C0("host", dword_108274, v16);
      }
      return result;
    case 0x60u:
      if ( hostval )
        return (signed int)sub_2071C("update", bswap32(hostval));
      return result;
    case 0x61u:
      for ( i = cinfo; i; i = *(_DWORD *)i )
      {
        sub_6C054(
          (int)v53,
          0x100u,
          "%s %s 0x%x",
          *(const char **)(i + 48),
          *(const char **)(i + 52),
          *(_DWORD *)(i + 4));
        v14 = strlen(v53);
        sub_1F2C0("cert", (int)v53, v14);
        v15 = sub_6C054(
                (int)v52,
                0x10u,
                "%04d%02d%02d%02d%02d",
                *(unsigned __int16 *)(i + 38),
                *(unsigned __int8 *)(i + 42),
                *(unsigned __int8 *)(i + 43),
                *(unsigned __int8 *)(i + 44),
                *(unsigned __int8 *)(i + 45));
        if ( v15 > 0xF )
          sub_6ECC0("ntp_control.c", 1705, 2, "rc >= 0 && (size_t)rc < sizeof(buffer)");
        result = (signed int)sub_1F0E4("until", (int)v52, v15);
      }
      return result;
    case 0x62u:
      result = crypto_flags;
      if ( crypto_flags )
      {
        v8 = OBJ_nid2sn(HIWORD(crypto_flags));
        digestbyname = EVP_get_digestbyname(v8);
        v10 = EVP_MD_pkey_type(digestbyname);
        v11 = (unsigned __int8 *)OBJ_nid2ln(v10);
        sub_6D4DC(v53, v11, 256);
        v12 = strlen(v53);
        return (signed int)sub_1F2C0("signature", (int)v53, v12);
      }
      return result;
    case 0x64u:
      if ( sys_ident )
      {
        v7 = strlen((const char *)sys_ident);
        return (signed int)sub_1F2C0("ident", sys_ident, v7);
      }
      return result;
    case 0x65u:
      if ( crypto_flags )
      {
        v5 = (unsigned __int8 *)OBJ_nid2ln(crypto_nid);
        sub_6D4DC(v53, v5, 256);
        v6 = strlen(v53);
        return (signed int)sub_1F2C0("digest", (int)v53, v6);
      }
      return result;
    default:
      return result;
  }
  while ( 1 )
  {
    v35 += 8;
    if ( (v33 & 0x80) != 0 )
      break;
    if ( (v33 & 0x40) == 0 )
    {
      v36 = (const char *)*((_DWORD *)v35 + 1);
      result = strlen(v36);
      v37 = result + 1;
      v38 = result;
      if ( result + 1 >= (int)v34 )
        break;
      v39 = v31 == 0;
      if ( !v31 )
        v37 = 44;
      v31 = 0;
      if ( v39 )
        *v32++ = v37;
      v40 = v32;
      v32 += v38;
      v34 = (char *)((char *)v54 - v32);
      result = (signed int)memcpy(v40, v36, v38);
    }
    v33 = *((_WORD *)v35 + 5);
  }
  for ( j = dword_B98D8; j; j += 8 )
  {
    v44 = *(_WORD *)(j + 2);
    if ( (v44 & 0x80) != 0 )
      break;
    if ( (v44 & 0x40) == 0 )
    {
      v42 = *(const char **)(j + 4);
      if ( v42 )
      {
        result = (signed int)strchr(*(const char **)(j + 4), 61);
        if ( result )
        {
          v45 = result - (_DWORD)v42;
        }
        else
        {
          result = strlen(v42);
          v45 = result;
        }
        if ( (int)(v45 + 1) >= (int)v34 )
          break;
        v39 = v31 == 0;
        v31 = 0;
        if ( !v39 )
        {
          *v32++ = 44;
          v42 = *(const char **)(j + 4);
        }
        v43 = v32;
        v32 += v45;
        v34 = (char *)((char *)v54 - v32);
        result = (signed int)memcpy(v43, v42, v45);
      }
    }
  }
  if ( (int)v34 > 2 )
  {
    *v32 = 34;
    v32[1] = 0;
    v51[0] = v53;
    v51[1] = v32 + 1 - v53;
    return (signed int)sub_1EEC8((char *)v51, 1, 0);
  }
  return result;
}
// 22488: variable 'v24' is possibly undefined
// 22488: variable 'v25' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// B43C: using guessed type int __fastcall OBJ_nid2ln(_DWORD);
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// BB00: using guessed type int __fastcall EVP_MD_pkey_type(_DWORD);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// B6ADC: using guessed type char *Version;
// B6AE0: using guessed type int crypto_nid;
// B6B24: using guessed type int mru_maxdepth;
// B6B28: using guessed type int *mru_maxage;
// B6B2C: using guessed type _UNKNOWN *mru_mindepth;
// B6B30: using guessed type char ntp_minpoll;
// B96CC: using guessed type int dword_B96CC;
// B96E4: using guessed type int dword_B96E4;
// B96E8: using guessed type int dword_B96E8;
// B9708: using guessed type int dword_B9708;
// B9710: using guessed type int dword_B9710;
// B9714: using guessed type int dword_B9714;
// B9718: using guessed type int dword_B9718;
// B971C: using guessed type int dword_B971C;
// B98D8: using guessed type int dword_B98D8;
// B9914: using guessed type int cinfo;
// B9920: using guessed type int crypto_flags;
// BC718: using guessed type int sys_ident;
// 106F50: using guessed type double sys_fuzz;
// 107CFC: using guessed type int packets_received;
// 107D00: using guessed type int packets_ignored;
// 107D08: using guessed type int packets_sent;
// 107D18: using guessed type int handler_calls;
// 107D34: using guessed type int packets_notsent;
// 107D3C: using guessed type int handler_pkts;
// 107D40: using guessed type int packets_dropped;
// 107D44: using guessed type int io_timereset;
// 108268: using guessed type int hostval;
// 108274: using guessed type int dword_108274;
// 1082B0: using guessed type char sys_poll;
// 1082B8: using guessed type double clock_jitter;
// 1082D0: using guessed type int sys_tai;
// 108354: using guessed type float mru_entries;
// 108358: using guessed type int mon_enabled;
// 10835C: using guessed type int mru_peakentries;
// 108B98: using guessed type int sys_badauth;
// 108BA8: using guessed type char sys_precision;
// 108BB0: using guessed type int sys_newversion;
// 108BC0: using guessed type char sys_leap;
// 108BD0: using guessed type int sys_refid;
// 108BD4: using guessed type int sys_kodsent;
// 108BF0: using guessed type unsigned int sys_authdelay;
// 108BF4: using guessed type int dword_108BF4;
// 108BFC: using guessed type int sys_received;
// 108C00: using guessed type int sys_restricted;
// 108C08: using guessed type int sys_reftime;
// 108C10: using guessed type int sys_limitrejected;
// 108C14: using guessed type char sys_stratum;
// 108C18: using guessed type int sys_processed;
// 108C1C: using guessed type int sys_declined;
// 108C20: using guessed type int sys_stattime;
// 108C28: using guessed type int sys_badlength;
// 108C2C: using guessed type int sys_peer;
// 108C38: using guessed type int sys_oldversion;
// 108C7C: using guessed type int auth_timereset;
// 108C90: using guessed type int alarm_overflow;
// 108CA4: using guessed type int current_time;
// 108CBC: using guessed type int timer_timereset;
// 108CC8: using guessed type int timer_xmtcalls;
// 108CE8: using guessed type int sys_lamport;
// 108CEC: using guessed type int sys_tsrounding;
// 108D00: using guessed type int authdecryptions;
// 108D14: using guessed type int authkeyexpired;
// 108D18: using guessed type int authkeyuncached;
// 108D24: using guessed type int authnumkeys;
// 108D28: using guessed type int authnumfreekeys;
// 108D2C: using guessed type int authencryptions;
// 108D30: using guessed type int authkeynotfound;
// 108D64: using guessed type int authkeylookups;

//----- (0002305C) --------------------------------------------------------
_BYTE *__fastcall sub_2305C(_BYTE *result)
{
  unsigned int v1; // r3
  int i; // r1
  unsigned int v3; // r2
  char v4; // r3
  unsigned int v5; // t1

  if ( result )
  {
    v1 = (unsigned __int8)*result;
    if ( *result )
    {
      for ( i = 1; ; i = 2 )
      {
        if ( !v1 )
          return (_BYTE *)(&dword_0 + 1);
        v3 = v1 >> 4;
        v4 = (2 * v1) & 0x1E;
        if ( v3 > 7 )
          break;
        v1 = i & (dword_93B9C[v3 + 2] >> v4);
        if ( !v1 )
          return (_BYTE *)v1;
        v5 = (unsigned __int8)*++result;
        v1 = v5;
      }
      return 0;
    }
    else
    {
      return (_BYTE *)v1;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 93B9C: using guessed type _DWORD dword_93B9C[22];

//----- (00023110) --------------------------------------------------------
unsigned __int16 *__fastcall sub_23110(int a1, int a2)
{
  unsigned __int16 *result; // r0
  int v5; // r1
  int v6; // r2
  int v7; // lr
  int v8; // r3
  int v9; // r10
  unsigned __int16 v10; // r9
  bool v11; // zf
  unsigned int v12; // r10
  __int16 v13; // r12
  unsigned int v14; // r12
  unsigned int v15; // r11
  int v16; // r3
  char *i; // r0
  int v18; // r0
  __int16 *(*v19)(); // r3
  unsigned int v20; // r2

  result = (unsigned __int16 *)(a1 + 4);
  v5 = *(_DWORD *)(a1 + 84);
  v6 = *(unsigned __int8 *)(a1 + 89);
  dword_B96B4 = *(_DWORD *)(a1 + 60);
  dword_B9494 = (int)result;
  v7 = *(unsigned __int16 *)(a1 + 96);
  ++numctlreq;
  if ( v5 <= 11 )
  {
    ++numctltooshort;
LABEL_3:
    if ( (v6 & 0x80) != 0 )
      ++numctlinputresp;
    if ( (v6 & 0x20) != 0 )
      ++numctlinputfrag;
    if ( (v6 & 0x40) != 0 )
      ++numctlinputerr;
    if ( v7 )
      ++numctlbadoffset;
    return result;
  }
  if ( (v6 & 0xE0) != 0 || v7 )
    goto LABEL_3;
  v8 = (*(unsigned __int8 *)(a1 + 88) >> 3) & 7;
  byte_B98DC = (*(_BYTE *)(a1 + 88) >> 3) & 7;
  if ( (unsigned int)(v8 - 1) > 3 )
  {
    ++numctlbadversion;
    return result;
  }
  v9 = v5 & 3;
  if ( (v5 & 3) != 0 )
    v9 = 1;
  v10 = __rev16(*(unsigned __int16 *)(a1 + 98));
  word_B94A0 = 0;
  dword_B96A8 = 0;
  if ( v10 > v5 - 12 )
    v9 |= 1u;
  byte_B96AC = 0;
  v11 = v9 == 0;
  v12 = *(unsigned __int16 *)(a1 + 94);
  byte_B96AD = 0;
  dword_B96B0 = 0;
  word_B94A2 = v12;
  v13 = *(_WORD *)(a1 + 90);
  byte_B98DD = 0;
  byte_B949C = (sys_leap << 6) | 6 | (8 * v8);
  dword_B96A0 = 0;
  dword_B96C0 = 0;
  dword_B96BC = 0;
  word_B949E = v13;
  word_B96B8 = 1;
  byte_B96A4 = v6;
  word_B96C8 = __rev16(v12);
  dword_B9498 = (int)&unk_B94A8;
  dword_B96C4 = (int)&unk_B967C;
  if ( !v11 )
  {
    result = (unsigned __int16 *)sub_1F4D0(2);
    ++numctldatatooshort;
    return result;
  }
  v14 = (v10 + 19) & 0xFFFFFFF8;
  v15 = v5 - v14;
  if ( v5 - v14 - 4 <= 0x14 && sys_authenticate )
  {
    v20 = *(_DWORD *)(a1 + 88 + v14);
    byte_B96AD = 1;
    dword_B96B0 = bswap32(v20);
    if ( sub_623A4(dword_B96B0, result) )
    {
      if ( !sub_62854(dword_B96B0, a1 + 88, *(_DWORD *)(a1 + 84) - v15, v15) )
      {
        v6 = (unsigned __int8)byte_B96A4;
        dword_B96B0 = 0;
        goto LABEL_24;
      }
      byte_B98DD = 1;
    }
    v6 = (unsigned __int8)byte_B96A4;
  }
LABEL_24:
  dword_B940C = a1 + 100 + v10;
  dword_B9408 = a1 + 100;
  if ( v6 )
  {
    v16 = 1;
    for ( i = (char *)&unk_B4480; ; i += 8 )
    {
      if ( v16 == -1 )
      {
        v18 = 3;
        ++numctlbadop;
        return (unsigned __int16 *)sub_1F4D0(v18);
      }
      if ( v16 == v6 )
        break;
      v16 = *((__int16 *)i + 8);
    }
    if ( *((_WORD *)i + 5) == 1 && (!byte_B98DD || dword_B96B0 != ctl_auth_keyid) )
    {
      v18 = 1;
      return (unsigned __int16 *)sub_1F4D0(v18);
    }
    v19 = (__int16 *(*)())*((_DWORD *)i + 3);
  }
  else
  {
    v19 = sub_23CE8;
  }
  return (unsigned __int16 *)((int (__fastcall *)(int, int))v19)(a1, a2);
}
// A8: using guessed type int;
// AC: using guessed type int;
// 1BC: using guessed type int elf_hash_bucket[521];
// B9408: using guessed type int dword_B9408;
// B940C: using guessed type int dword_B940C;
// B9494: using guessed type int dword_B9494;
// B9498: using guessed type int dword_B9498;
// B949C: using guessed type char byte_B949C;
// B949E: using guessed type __int16 word_B949E;
// B94A0: using guessed type __int16 word_B94A0;
// B94A2: using guessed type __int16 word_B94A2;
// B96A0: using guessed type int dword_B96A0;
// B96A4: using guessed type char byte_B96A4;
// B96A8: using guessed type int dword_B96A8;
// B96AC: using guessed type char byte_B96AC;
// B96AD: using guessed type char byte_B96AD;
// B96B0: using guessed type int dword_B96B0;
// B96B4: using guessed type int dword_B96B4;
// B96B8: using guessed type __int16 word_B96B8;
// B96BC: using guessed type int dword_B96BC;
// B96C0: using guessed type int dword_B96C0;
// B96C4: using guessed type int dword_B96C4;
// B96C8: using guessed type __int16 word_B96C8;
// B98DC: using guessed type char byte_B98DC;
// B98DD: using guessed type char byte_B98DD;
// 10818C: using guessed type int numctldatatooshort;
// 108230: using guessed type int numctlinputresp;
// 10823C: using guessed type int numctlinputerr;
// 108240: using guessed type int numctlreq;
// 108248: using guessed type int numctltooshort;
// 10824C: using guessed type int numctlbadversion;
// 108250: using guessed type int ctl_auth_keyid;
// 108254: using guessed type int numctlbadoffset;
// 108258: using guessed type int numctlinputfrag;
// 10825C: using guessed type int numctlbadop;
// 108BAC: using guessed type int sys_authenticate;
// 108BC0: using guessed type char sys_leap;

//----- (00023504) --------------------------------------------------------
int __fastcall sub_23504(int a1)
{
  int v1; // r12
  __int16 v2; // r3

  v1 = *(_DWORD *)(a1 + 68);
  v2 = *(unsigned __int8 *)(a1 + 296);
  if ( (v1 & 1) != 0 )
    v2 |= 0x80u;
  if ( *(_DWORD *)(a1 + 124) )
    v2 |= 0x40u;
  if ( (v1 & 4) != 0 )
    v2 |= 0x20u;
  if ( *(_BYTE *)(a1 + 298) )
    v2 |= 0x10u;
  if ( (*(_BYTE *)(a1 + 72) & 0x1E) != 0 )
    v2 |= 8u;
  return *(_BYTE *)(a1 + 73) & 0xF | (unsigned __int8)(16 * *(_BYTE *)(a1 + 74)) | (unsigned __int16)(v2 << 8);
}

//----- (000235A8) --------------------------------------------------------
int sub_235A8()
{
  unsigned __int16 v0; // r12
  unsigned int v1; // r2

  if ( sys_peer )
  {
    v0 = *(unsigned __int8 *)(sys_peer + 90);
    if ( *(_BYTE *)(sys_peer + 90) )
    {
      v0 = (v0 << 8) & 0x3F00;
    }
    else
    {
      v1 = *(unsigned __int8 *)(sys_peer + 88);
      if ( v1 <= 0x2E )
        v0 = (*((unsigned __int8 *)&dword_93B9C[10] + v1) << 8) & 0x3F00;
    }
  }
  else
  {
    v0 = 0;
  }
  return v0
       | byte_B98DE & 0xF
       | (unsigned __int16)((unsigned __int8)sys_leap << 14)
       | (unsigned __int8)(16 * byte_B98DF);
}
// 93B9C: using guessed type _DWORD dword_93B9C[22];
// B98DE: using guessed type char byte_B98DE;
// B98DF: using guessed type char byte_B98DF;
// 108BC0: using guessed type char sys_leap;
// 108C2C: using guessed type int sys_peer;

//----- (00023684) --------------------------------------------------------
void sub_23684()
{
  char v0; // r5
  int v1; // r8
  unsigned int v2; // r0
  unsigned int v3; // r7
  unsigned int v4; // r11
  char *i; // r5
  unsigned int v6; // r3
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  int v9; // r0
  int v10; // r7
  int k; // r6
  unsigned int v12; // r3
  _DWORD *v13; // r0
  _BYTE *v14; // r4
  char *v16; // r6
  char *v17; // r4
  int v19; // r6
  int v21; // r3
  const char *v22; // r9
  signed int v23; // r0
  unsigned __int8 *v24; // r4
  signed int v25; // t1
  int v26; // r4
  __int16 j; // r3
  const char *v28; // r6
  int v29; // r0
  unsigned __int8 *v30; // r4
  int v31; // t1
  int v32; // [sp+Ch] [bp-50h] BYREF
  const char *v33; // [sp+10h] [bp-4Ch] BYREF
  size_t v34; // [sp+14h] [bp-48h]
  _BYTE s[68]; // [sp+18h] [bp-44h] BYREF

  v0 = word_B96C8;
  if ( !word_B96C8 )
  {
    v1 = 0;
    word_B94A0 = __rev16(sub_235A8());
    if ( byte_B98DD )
      byte_B98DF = v0;
    v2 = sub_1F95C(dword_B98D8);
    v3 = v2 + 102;
    v4 = v2;
    for ( i = (char *)sub_63BA4(0, v2 + 102, 0, 1); ; i[v6] = 1 )
    {
      v7 = sub_1E820((int)&unk_B4148, &v32);
      if ( !v7 )
        break;
      if ( (*((_WORD *)v7 + 1) & 0x80) != 0 )
      {
        v8 = sub_1E820(dword_B98D8, &v32);
        if ( !v8 )
        {
          sub_1F4D0(6);
          free(i);
          return;
        }
        if ( (*((_WORD *)v8 + 1) & 0x80) != 0 )
        {
          sub_1F4D0(5);
          free(i);
          return;
        }
        v6 = *(unsigned __int16 *)v8 + 102;
        if ( v3 <= v6 )
          sub_6ECC0("ntp_control.c", 3369, 2, "n < wants_count");
      }
      else
      {
        v6 = *(unsigned __int16 *)v7;
        if ( v3 <= v6 )
          sub_6ECC0("ntp_control.c", 3353, 2, "v->code < wants_count");
      }
      v1 = 1;
    }
    if ( v1 )
    {
      v16 = i + 101;
      v17 = i;
      do
      {
        while ( !*++v17 )
        {
          if ( v17 == v16 )
            goto LABEL_31;
        }
        sub_21888(v17 - i);
      }
      while ( v17 != v16 );
LABEL_31:
      if ( v3 != 102 )
      {
        v19 = 0;
        do
        {
          while ( !*++v17 )
          {
            if ( ++v19 == v4 )
              goto LABEL_36;
          }
          v21 = dword_B98D8 + 8 * v19++;
          v22 = *(const char **)(v21 + 4);
          v34 = strlen(v22);
          v33 = v22;
          sub_1EEC8((char *)&v33, 1, 0);
        }
        while ( v19 != v4 );
      }
    }
    else
    {
      v23 = 17;
      v24 = (unsigned __int8 *)&unk_93C20;
      do
      {
        sub_21888(v23);
        v25 = *++v24;
        v23 = v25;
      }
      while ( v25 );
      v26 = dword_B98D8;
      if ( dword_B98D8 )
      {
        for ( j = *(_WORD *)(dword_B98D8 + 2); (j & 0x80) == 0; j = *(_WORD *)(v26 + 2) )
        {
          if ( (j & 0x20) != 0 )
          {
            v28 = *(const char **)(v26 + 4);
            v34 = strlen(v28);
            v33 = v28;
            sub_1EEC8((char *)&v33, 1, 0);
          }
          v26 += 8;
          if ( !v26 )
            break;
        }
      }
    }
LABEL_36:
    free(i);
LABEL_37:
    sub_1EBA4(0);
    return;
  }
  v9 = sub_31C78((unsigned __int16)word_B96C8);
  v10 = v9;
  if ( v9 )
  {
    word_B94A0 = __rev16(sub_23504(v9));
    if ( byte_B98DD )
      *(_BYTE *)(v10 + 74) = 0;
    memset(s, 0, 0x3Bu);
    for ( k = 0; ; k = 1 )
    {
      v13 = sub_1E820((int)&unk_B3F68, &v32);
      if ( !v13 )
        break;
      if ( (*((_WORD *)v13 + 1) & 0x80) != 0 )
      {
        sub_1F4D0(5);
        return;
      }
      v12 = *(unsigned __int16 *)v13;
      if ( v12 > 0x3A )
        sub_6ECC0("ntp_control.c", 3310, 2, "v->code < (sizeof(wants) / sizeof((wants)[0]))");
      s[v12] = 1;
    }
    if ( k )
    {
      v14 = s;
      do
      {
        if ( *++v14 )
          sub_20810(v14 - s, v10);
      }
      while ( &s[58] != v14 );
    }
    else
    {
      v29 = 4;
      v30 = (unsigned __int8 *)&unk_93BF4;
      do
      {
        sub_20810(v29, v10);
        v31 = *++v30;
        v29 = v31;
      }
      while ( v31 );
    }
    goto LABEL_37;
  }
  sub_1F4D0(4);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// 23AB0: using guessed type char *off_23AB0;
// B94A0: using guessed type __int16 word_B94A0;
// B96C8: using guessed type __int16 word_B96C8;
// B98D8: using guessed type int dword_B98D8;
// B98DD: using guessed type char byte_B98DD;
// B98DF: using guessed type char byte_B98DF;

//----- (00023AC0) --------------------------------------------------------
__int16 *sub_23AC0()
{
  int v0; // r8
  int v1; // r4
  unsigned int v2; // r0
  _WORD *v3; // r3
  bool v4; // cc
  _WORD *v6; // [sp+0h] [bp-1E0h] BYREF
  int v7; // [sp+4h] [bp-1DCh]
  _WORD v8[234]; // [sp+8h] [bp-1D8h] BYREF

  word_B94A0 = __rev16(sub_235A8());
  v0 = peer_list;
  if ( peer_list )
  {
    v1 = 2;
    v8[0] = __rev16(*(unsigned __int16 *)(peer_list + 60));
    v8[1] = __rev16(sub_23504(peer_list));
    while ( 1 )
    {
      v0 = *(_DWORD *)v0;
      if ( !v0 )
        break;
      while ( 1 )
      {
        v8[v1] = __rev16(*(unsigned __int16 *)(v0 + 60));
        v2 = sub_23504(v0);
        v3 = &v8[v1];
        v4 = (unsigned int)(v1 + 3) > 0xE9;
        v1 += 2;
        v3[1] = __rev16(v2);
        if ( !v4 )
          break;
        v6 = v8;
        v7 = 2 * v1;
        sub_1EEC8((char *)&v6, 1, 1);
        v0 = *(_DWORD *)v0;
        v1 = 0;
        if ( !v0 )
          goto LABEL_7;
      }
    }
LABEL_7:
    if ( v1 )
    {
      v6 = v8;
      v7 = 2 * v1;
      sub_1EEC8((char *)&v6, 1, 1);
    }
  }
  return sub_1EBA4(0);
}
// B94A0: using guessed type __int16 word_B94A0;
// 108B8C: using guessed type int peer_list;

//----- (00023BF8) --------------------------------------------------------
__int16 *sub_23BF8()
{
  int v0; // r0
  int v1; // r6
  int v2; // r0
  unsigned __int8 *v3; // r4
  int v4; // t1

  if ( !word_B96C8 )
    return sub_23AC0();
  v0 = sub_31C78((unsigned __int16)word_B96C8);
  v1 = v0;
  if ( !v0 )
    return (__int16 *)sub_1F4D0(4);
  word_B94A0 = __rev16(sub_23504(v0));
  v2 = 4;
  if ( byte_B98DD )
    *(_BYTE *)(v1 + 74) = 0;
  v3 = (unsigned __int8 *)&unk_93BF4;
  do
  {
    sub_20810(v2, v1);
    v4 = *++v3;
    v2 = v4;
  }
  while ( v4 );
  return sub_1EBA4(0);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B94A0: using guessed type __int16 word_B94A0;
// B96C8: using guessed type __int16 word_B96C8;
// B98DD: using guessed type char byte_B98DD;

//----- (00023CE8) --------------------------------------------------------
__int16 *sub_23CE8()
{
  int v0; // r0

  if ( !word_B96C8 )
  {
    word_B94A0 = __rev16(sub_235A8());
    return sub_1EBA4(0);
  }
  v0 = sub_31C78((unsigned __int16)word_B96C8);
  if ( v0 )
  {
    word_B94A0 = __rev16(sub_23504(v0));
    return sub_1EBA4(0);
  }
  return (__int16 *)sub_1F4D0(4);
}
// B94A0: using guessed type __int16 word_B94A0;
// B96C8: using guessed type __int16 word_B96C8;

//----- (00023D98) --------------------------------------------------------
int __fastcall sub_23D98(unsigned __int16 *a1, int a2, int a3, char a4)
{
  char *v8; // r0
  char *v9; // r12
  int v11; // r11
  int v12; // r3
  unsigned int v13; // lr
  char *v14; // r1
  char v15; // r2
  int v16; // r0
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r2
  int v23; // [sp+4h] [bp-18h]

  v8 = sub_1E710(a1, a2);
  v9 = v8;
  if ( v8 )
  {
    if ( a3 == 1 )
    {
      if ( (v8[50] & 4) == 0 )
      {
        v8[50] = 1;
        goto LABEL_6;
      }
    }
    else
    {
      if ( a3 != 2 )
      {
        if ( !a3 )
          v8[50] = 5;
        goto LABEL_6;
      }
      if ( (v8[50] & 4) == 0 )
      {
        v8[50] = 3;
LABEL_6:
        ++*((_DWORD *)v8 + 11);
        *((_DWORD *)v8 + 8) = current_time;
        return 1;
      }
    }
    return 1;
  }
  v11 = 0;
  v12 = 0;
  v13 = current_time;
  v14 = (char *)&ctl_traps;
  v23 = num_ctl_traps;
  do
  {
    v15 = *((_BYTE *)&ctl_traps + 52 * v12 + 50);
    if ( (v15 & 5) == 1 && *((_DWORD *)v14 + 8) + 3600 > v13 )
    {
      v11 = v15 & 5;
      v14[50] = 0;
      v9 = v14;
      --v23;
      goto LABEL_18;
    }
    if ( (*((_BYTE *)&ctl_traps + 52 * v12 + 50) & 1) == 0 )
      goto LABEL_36;
    if ( (*((_BYTE *)&ctl_traps + 52 * v12 + 50) & 4) != 0 )
      goto LABEL_18;
    if ( a3 )
    {
      if ( a3 != 1 || (*((_BYTE *)&ctl_traps + 52 * v12 + 50) & 2) == 0 )
        goto LABEL_18;
      if ( !v9 )
        goto LABEL_36;
      if ( (v9[50] & 1) == 0 )
        goto LABEL_18;
    }
    else
    {
      if ( !v9 )
        goto LABEL_36;
      v22 = v15 & 2;
      if ( (v9[50] & 2) != 0 )
      {
        if ( !v22 )
          goto LABEL_18;
      }
      else if ( v22 )
      {
LABEL_36:
        v9 = v14;
        goto LABEL_18;
      }
    }
    if ( *((_DWORD *)v9 + 10) < *((_DWORD *)v14 + 10) )
      v9 = v14;
LABEL_18:
    ++v12;
    v14 += 52;
  }
  while ( v12 != 3 );
  if ( v11 )
    num_ctl_traps = v23;
  if ( !v9 )
    return 0;
  *((_WORD *)v9 + 24) = 1;
  v16 = *(_DWORD *)a1;
  v17 = *((_DWORD *)a1 + 1);
  v18 = *((_DWORD *)a1 + 2);
  v19 = *((_DWORD *)a1 + 3);
  *((_DWORD *)v9 + 10) = v13;
  *((_DWORD *)v9 + 8) = v13;
  *((_DWORD *)v9 + 11) = 0;
  *((_DWORD *)v9 + 9) = 0;
  *(_DWORD *)v9 = v16;
  *((_DWORD *)v9 + 1) = v17;
  *((_DWORD *)v9 + 2) = v18;
  *((_DWORD *)v9 + 3) = v19;
  if ( !a3 )
    LOBYTE(v19) = 5;
  v20 = *((_DWORD *)a1 + 5);
  v21 = *((_DWORD *)a1 + 6);
  *((_DWORD *)v9 + 4) = *((_DWORD *)a1 + 4);
  *((_DWORD *)v9 + 5) = v20;
  *((_DWORD *)v9 + 6) = v21;
  *((_DWORD *)v9 + 7) = a2;
  v9[51] = a4;
  if ( a3 )
  {
    if ( a3 == 2 )
      LOBYTE(v19) = 3;
    else
      v9[50] = 1;
    if ( a3 == 2 )
      v9[50] = v19;
  }
  else
  {
    v9[50] = v19;
  }
  ++num_ctl_traps;
  return 1;
}
// 108260: using guessed type int num_ctl_traps;
// 108CA4: using guessed type int current_time;

//----- (00024010) --------------------------------------------------------
__int16 *__fastcall sub_24010(int a1, __int16 a2)
{
  int v2; // r2

  if ( (a2 & 0x200) != 0 )
    return (__int16 *)sub_1F4D0(1);
  if ( (a2 & 0x400) != 0 )
    v2 = 2;
  else
    v2 = 1;
  if ( !sub_23D98((unsigned __int16 *)(a1 + 4), *(_DWORD *)(a1 + 60), v2, byte_B98DC) )
    sub_1F4D0(1);
  return sub_1EBA4(0);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B98DC: using guessed type char byte_B98DC;

//----- (000240C0) --------------------------------------------------------
int __fastcall sub_240C0(unsigned __int16 *a1, int a2, int a3)
{
  char *v4; // r0
  char *v5; // r3
  char v6; // r2

  v4 = sub_1E710(a1, a2);
  v5 = v4;
  if ( !v4 )
    return 0;
  v6 = a3;
  if ( a3 )
    v6 = 1;
  if ( (*(_DWORD *)&v6 & ((unsigned __int8)v4[50] >> 2)) != 0 )
    return 0;
  v5[50] = 0;
  --num_ctl_traps;
  return 1;
}
// 108260: using guessed type int num_ctl_traps;

//----- (00024150) --------------------------------------------------------
__int16 *__fastcall sub_24150(int a1, __int16 a2)
{
  int v2; // r2

  if ( (a2 & 0x400) != 0 )
    v2 = 2;
  else
    v2 = 1;
  if ( !sub_240C0((unsigned __int16 *)(a1 + 4), *(_DWORD *)(a1 + 60), v2) )
    sub_1F4D0(4);
  return sub_1EBA4(0);
}

//----- (000241C4) --------------------------------------------------------
int sub_241C4()
{
  ctltimereset = current_time;
  numctlreq = 0;
  numctlbadpkts = 0;
  numctlresponses = 0;
  numctlfrags = 0;
  numctlerrors = 0;
  numctltooshort = 0;
  numctlinputresp = 0;
  numctlinputfrag = 0;
  numctlinputerr = 0;
  numctlbadoffset = 0;
  numctlbadversion = 0;
  numctldatatooshort = 0;
  numctlbadop = 0;
  numasyncmsgs = 0;
  return _stack_chk_guard;
}
// 108188: using guessed type int numctlbadpkts;
// 10818C: using guessed type int numctldatatooshort;
// 108190: using guessed type int numctlresponses;
// 108230: using guessed type int numctlinputresp;
// 108234: using guessed type int ctltimereset;
// 108238: using guessed type int numasyncmsgs;
// 10823C: using guessed type int numctlinputerr;
// 108240: using guessed type int numctlreq;
// 108244: using guessed type int numctlfrags;
// 108248: using guessed type int numctltooshort;
// 10824C: using guessed type int numctlbadversion;
// 108254: using guessed type int numctlbadoffset;
// 108258: using guessed type int numctlinputfrag;
// 10825C: using guessed type int numctlbadop;
// 108264: using guessed type int numctlerrors;
// 108CA4: using guessed type int current_time;

//----- (0002430C) --------------------------------------------------------
int sub_2430C()
{
  int v1; // [sp+4h] [bp-4h]

  uname((struct utsname *)byte_B9750);
  sub_241C4();
  byte_B98DE = 0;
  byte_B98DF = 0;
  ctl_auth_keyid = 0;
  num_ctl_traps = 0;
  byte_1081C6 = 0;
  byte_1081FA = 0;
  byte_10822E = 0;
  return v1;
}
// 2434C: variable 'v1' is possibly undefined
// 64: using guessed type int;
// 98: using guessed type int;
// 1BC: using guessed type int elf_hash_bucket[521];
// B98DE: using guessed type char byte_B98DE;
// B98DF: using guessed type char byte_B98DF;
// 1081C6: using guessed type char byte_1081C6;
// 1081FA: using guessed type char byte_1081FA;
// 10822E: using guessed type char byte_10822E;
// 108250: using guessed type int ctl_auth_keyid;
// 108260: using guessed type int num_ctl_traps;

//----- (000243AC) --------------------------------------------------------
void *__fastcall sub_243AC(unsigned int *a1, size_t a2, __int16 a3)
{
  void *v5; // r4
  unsigned int v7; // r5
  _WORD *v8; // r4
  void *result; // r0
  char *v10; // r2
  _DWORD *v11; // r2

  v5 = (void *)*a1;
  v7 = sub_1F95C(*a1);
  v8 = sub_63BA4(v5, 8 * (v7 + 2), 0, 0);
  *a1 = (unsigned int)v8;
  result = sub_63BA4(0, a2, 0, 0);
  v8[4 * v7] = v7;
  v10 = (char *)&v8[4 * v7];
  *((_DWORD *)v10 + 1) = result;
  *((_WORD *)v10 + 1) = a3;
  v11 = &v8[4 * v7 + 4];
  *v11 = 0x800000;
  v11[1] = 0;
  return result;
}

//----- (0002446C) --------------------------------------------------------
unsigned int *__fastcall sub_2446C(unsigned int *result, unsigned __int8 *a2, size_t a3, __int16 a4)
{
  bool v4; // zf
  unsigned int v6; // r4
  unsigned __int8 *v9; // lr
  int v10; // r9
  int v11; // r3
  unsigned __int8 *v12; // r1
  unsigned __int8 *v13; // r2
  int v14; // r3
  int v15; // t1
  int v16; // r12
  int v17; // t1
  size_t v18; // r1
  void *v19; // r0
  void *v20; // r0
  void *v21; // r0

  v4 = a3 == 0;
  if ( a3 )
    v4 = a2 == 0;
  if ( v4 )
    return result;
  v6 = *result;
  if ( !*result || (*(_WORD *)(v6 + 2) & 0x80) != 0 )
  {
LABEL_20:
    v21 = sub_243AC(result, a3, a4);
    return (unsigned int *)memcpy(v21, a2, a3);
  }
  v9 = *(unsigned __int8 **)(v6 + 4);
  if ( !v9 )
  {
LABEL_17:
    v18 = a3;
    v19 = 0;
    goto LABEL_18;
  }
  v10 = *a2;
  while ( 1 )
  {
    v11 = *v9;
    if ( v11 == 61 )
    {
      v16 = v10;
    }
    else
    {
      if ( v11 != v10 )
        goto LABEL_15;
      v12 = a2;
      v13 = v9;
      while ( 1 )
      {
        v15 = *++v13;
        v14 = v15;
        v17 = *++v12;
        v16 = v17;
        if ( v14 == 61 )
          break;
        if ( v14 != v16 )
          goto LABEL_15;
      }
    }
    if ( v16 == 61 )
      break;
LABEL_15:
    v6 += 8;
    if ( (*(_WORD *)(v6 + 2) & 0x80) != 0 )
      goto LABEL_20;
    v9 = *(unsigned __int8 **)(v6 + 4);
    if ( !v9 )
      goto LABEL_17;
  }
  v19 = v9;
  v18 = a3;
LABEL_18:
  v20 = sub_63BA4(v19, v18, 0, 0);
  result = (unsigned int *)memcpy(v20, a2, a3);
  *(_WORD *)(v6 + 2) = a4;
  *(_DWORD *)(v6 + 4) = result;
  return result;
}

//----- (000245C4) --------------------------------------------------------
unsigned int *__fastcall sub_245C4(unsigned __int8 *a1, size_t a2, __int16 a3)
{
  return sub_2446C((unsigned int *)&dword_B98D8, a1, a2, a3);
}
// B98D8: using guessed type int dword_B98D8;

//----- (0002462C) --------------------------------------------------------
char *__fastcall sub_2462C(char *result, __int16 a2)
{
  char *v2; // r6
  int v3; // r7
  unsigned int v4; // r4
  unsigned __int16 *v5; // r6
  struct tm *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  FILE *v14; // r0
  FILE *v15; // r4
  const char *v16; // r0
  size_t v17; // r0
  int *v18; // r0
  char *v19; // r0
  const char *v20; // r0
  int *v21; // r0
  char *v22; // r0
  const char *v23; // r0
  time_t timer; // [sp+8h] [bp-3A4h] BYREF
  _DWORD v25[2]; // [sp+Ch] [bp-3A0h] BYREF
  char v26[128]; // [sp+14h] [bp-398h] BYREF
  char v27[128]; // [sp+94h] [bp-318h] BYREF
  unsigned __int8 v28[144]; // [sp+114h] [bp-298h] BYREF
  char v29[512]; // [sp+1A4h] [bp-208h] BYREF

  v2 = result;
  if ( (a2 & 0x100) != 0 )
  {
    sub_1F3A0((unsigned __int8 *)"%s", "saveconfig prohibited by restrict ... nomodify");
    result = (char *)sub_1EBA4(0);
    if ( (ntp_syslogmask & 1) != 0 )
    {
      v10 = sub_6C2E8((unsigned __int16 *)v2 + 2);
      result = sub_64E00(5, "saveconfig from %s rejected due to nomodify restriction", v10);
    }
    ++sys_restricted;
  }
  else if ( saveconfigdir )
  {
    v3 = dword_B9408;
    v4 = dword_B940C - dword_B9408;
    if ( dword_B940C != dword_B9408 )
    {
      result = (char *)memchr((const void *)dword_B9408, 0, dword_B940C - dword_B9408);
      if ( !result || (v4 = (unsigned int)&result[-v3], result != (char *)v3) )
      {
        v5 = (unsigned __int16 *)(v2 + 4);
        if ( v4 > 0x7F )
        {
          sub_1F3A0("saveconfig exceeded maximum raw name length (%u)", 128);
          sub_1EBA4(0);
          v8 = sub_6C2E8(v5);
          return sub_64E00(5, "saveconfig exceeded maximum raw name length from %s", v8);
        }
        else
        {
          _memcpy_chk(v26, v3, v4, 128);
          v26[v4] = 0;
          time(&timer);
          v6 = localtime(&timer);
          if ( !strftime(v27, 0x80u, v26, v6) )
            sub_6D4DC(v27, (unsigned __int8 *)v26, 128);
          if ( sub_2305C(v27) )
          {
            if ( strpbrk(v27, "\\/") )
            {
              sub_6C054((int)v29, 0x80u, "saveconfig does not allow directory in filename");
              v25[1] = strlen(v29);
              v25[0] = v29;
              sub_1EEC8((char *)v25, 1, 0);
              sub_1EBA4(0);
              v7 = sub_6C2E8(v5);
              return sub_64E00(5, "saveconfig rejects unsafe file name from %s", v7);
            }
            else if ( sub_6C054((int)v29, 0x200u, (unsigned __int8 *)"%s%s", (const char *)saveconfigdir, v27) < 0x200 )
            {
              v13 = open64(v29, 705, 384);
              if ( v13 == -1 || (v14 = fdopen(v13, "w"), (v15 = v14) == 0) )
              {
                v18 = _errno_location();
                v19 = strerror(*v18);
                sub_1F3A0("Unable to save configuration to file '%s': %s", v27, v19);
                v20 = sub_6C2E8(v5);
                sub_64E00(3, "saveconfig %s from %s failed", v27, v20);
              }
              else
              {
                if ( sub_ED20(v14, 1) == -1 )
                {
                  v21 = _errno_location();
                  v22 = strerror(*v21);
                  sub_1F3A0("Unable to save configuration to file '%s': %s", v27, v22);
                  v23 = sub_6C2E8(v5);
                  sub_64E00(3, "saveconfig %s from %s failed", v27, v23);
                }
                else
                {
                  sub_1F3A0("Configuration saved to '%s'", v27);
                  v16 = sub_6C2E8(v5);
                  sub_64E00(5, "Configuration saved to '%s' (requested by %s)", v29, v16);
                  sub_6C054((int)v28, 0x8Du, (unsigned __int8 *)"%s%s", "savedconfig=", v27);
                  v17 = strlen((const char *)v28);
                  sub_245C4(v28, v17 + 1, 1);
                }
                fclose(v15);
              }
              return (char *)sub_1EBA4(0);
            }
            else
            {
              sub_1F3A0("saveconfig exceeded maximum path length (%u)", 512);
              sub_1EBA4(0);
              v12 = sub_6C2E8(v5);
              return sub_64E00(5, "saveconfig exceeded maximum path length from %s", v12);
            }
          }
          else
          {
            sub_1F3A0("saveconfig rejects unsafe file name '%s'", v27);
            sub_1EBA4(0);
            v11 = sub_6C2E8(v5);
            return sub_64E00(5, "saveconfig rejects unsafe file name from %s", v11);
          }
        }
      }
    }
  }
  else
  {
    sub_1F3A0((unsigned __int8 *)"%s", "saveconfig prohibited, no saveconfigdir configured");
    result = (char *)sub_1EBA4(0);
    if ( (ntp_syslogmask & 1) != 0 )
    {
      v9 = sub_6C2E8((unsigned __int16 *)v2 + 2);
      return sub_64E00(5, "saveconfig from %s rejected, no saveconfigdir", v9);
    }
  }
  return result;
}
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// B7CD4: using guessed type int ntp_syslogmask;
// B9408: using guessed type int dword_B9408;
// B940C: using guessed type int dword_B940C;
// 1074E4: using guessed type int saveconfigdir;
// 108C00: using guessed type int sys_restricted;

//----- (00024B08) --------------------------------------------------------
__int16 *sub_24B08()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  __int16 v2; // r3
  int v3; // r10
  _DWORD *v4; // r0
  size_t v6; // r10
  size_t v7; // r0
  char *v8; // r0
  _BYTE *v9; // r2
  char *v10; // r5
  int v11; // r3
  bool v12; // zf
  int v13; // t1
  bool v14; // zf
  void *v15; // r10
  size_t v16; // r0
  size_t v17; // r0
  char *s; // [sp+4h] [bp-10h] BYREF
  int v19; // [sp+8h] [bp-Ch] BYREF

  v19 = 0;
  if ( word_B96C8 )
    return (__int16 *)sub_1F4D0(1);
  word_B94A0 = __rev16(sub_235A8());
  while ( 1 )
  {
    v0 = sub_1E820((int)&unk_B4148, &s);
    v1 = v0;
    if ( !v0 )
      return sub_1EBA4(0);
    v2 = *((_WORD *)v0 + 1);
    v3 = v2 & 0x80;
    if ( (v2 & 0x80) != 0 )
    {
      v4 = sub_1E820(dword_B98D8, &s);
      v1 = v4;
      if ( !v4 )
        return sub_1EBA4(0);
      v2 = *((_WORD *)v4 + 1);
      if ( (v2 & 0x80) != 0 )
        return (__int16 *)sub_1F4D0(5);
      v3 = 1;
    }
    if ( (v2 & 2) == 0 )
      return (__int16 *)sub_1F4D0(1);
    if ( !s )
      return (__int16 *)sub_1F4D0(2);
    if ( !v3 )
      break;
    v6 = strlen((const char *)v1[1]);
    v7 = strlen(s);
    v8 = (char *)sub_63BA4(0, v6 + v7 + 2, 0, 0);
    v9 = (_BYTE *)v1[1];
    v10 = v8;
    v11 = (unsigned __int8)*v9;
    v12 = v11 == 0;
    if ( *v9 )
      v12 = v11 == 61;
    if ( !v12 )
    {
      do
      {
        *v8++ = v11;
        v13 = (unsigned __int8)*++v9;
        v11 = v13;
        v14 = v13 == 0;
        if ( v13 )
          v14 = v11 == 61;
      }
      while ( !v14 );
    }
    *v8 = 61;
    v15 = v8 + 1;
    v16 = strlen(s);
    memcpy(v15, s, v16 + 1);
    v17 = strlen(v10);
    sub_245C4((unsigned __int8 *)v10, v17 + 1, *((_WORD *)v1 + 1));
    free(v10);
  }
  if ( !*s || !sub_60930((unsigned __int8 *)s, &v19) )
    return (__int16 *)sub_1F4D0(2);
  if ( (v19 & 0xFFFFFFFC) != 0 )
    return (__int16 *)sub_1F4D0(6);
  else
    return (__int16 *)sub_1F4D0(0);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B94A0: using guessed type __int16 word_B94A0;
// B96C8: using guessed type __int16 word_B96C8;
// B98D8: using guessed type int dword_B98D8;

//----- (00024D10) --------------------------------------------------------
void *__fastcall sub_24D10(const char *a1)
{
  size_t v2; // r0
  int v3; // r4
  size_t v4; // r6
  int v5; // r5

  v2 = strlen(a1);
  v3 = dword_B98D8;
  if ( (*(_WORD *)(dword_B98D8 + 2) & 0x80) != 0 )
    return 0;
  v4 = v2;
  while ( 1 )
  {
    v5 = *(_DWORD *)(v3 + 4);
    if ( v5 && !memcmp(a1, *(const void **)(v3 + 4), v4) )
    {
      if ( *(_BYTE *)(v5 + v4) == 61 )
        return (void *)(v5 + v4 + 1);
      if ( !*(_BYTE *)(v5 + v4) )
        break;
    }
    v3 += 8;
    if ( (*(_WORD *)(v3 + 2) & 0x80) != 0 )
      return 0;
  }
  return &unk_97F7C;
}
// B98D8: using guessed type int dword_B98D8;

//----- (00024DE4) --------------------------------------------------------
void __fastcall sub_24DE4(_WORD *a1)
{
  _WORD *v2; // r4
  void *v3; // r0

  if ( a1 )
  {
    if ( (a1[1] & 0x80) == 0 )
    {
      v2 = a1;
      do
      {
        v3 = (void *)*((_DWORD *)v2 + 1);
        v2 += 4;
        free(v3);
      }
      while ( (v2[1] & 0x80) == 0 );
    }
    free(a1);
  }
}

//----- (00024E78) --------------------------------------------------------
void __fastcall sub_24E78(int a1, __int16 a2)
{
  int v2; // r10
  int v3; // r5
  size_t v4; // r0
  size_t v5; // r0
  void *v6; // r8
  _DWORD *v7; // r0
  _DWORD *v8; // r7
  char *v9; // r3
  const char *v10; // r5
  const char *v11; // r1
  unsigned __int16 *v12; // r2
  unsigned __int8 *v13; // r2
  _BOOL4 v14; // r3
  void *v15; // r0
  const char *v16; // r0
  int v17; // r6
  unsigned int v18; // r5
  int v19; // r7
  unsigned int v20; // r6
  unsigned int v21; // r5
  bool v22; // zf
  unsigned __int16 *v23; // r6
  int v24; // r4
  int v25; // r11
  int v26; // r5
  int v27; // r3
  size_t v28; // r0
  int v29; // r4
  unsigned int v30; // r9
  int v31; // r0
  _BOOL4 v32; // r1
  unsigned __int8 *v33; // r2
  int v34; // r3
  unsigned __int8 *v35; // r3
  const char *v36; // r5
  size_t v37; // r0
  size_t v38; // r0
  int v39; // r6
  int v40; // r5
  unsigned int v41; // r5
  unsigned int v42; // r2
  unsigned int v43; // r3
  unsigned __int8 *v44; // r4
  size_t v45; // r0
  size_t v46; // r0
  int v48; // [sp+24h] [bp-388h]
  const char *v49; // [sp+3Ch] [bp-370h]
  unsigned __int16 v50; // [sp+46h] [bp-366h] BYREF
  unsigned __int16 v51; // [sp+48h] [bp-364h] BYREF
  unsigned __int16 v52; // [sp+4Ah] [bp-362h] BYREF
  unsigned int v53; // [sp+4Ch] [bp-360h] BYREF
  int v54; // [sp+50h] [bp-35Ch] BYREF
  unsigned int v55; // [sp+54h] [bp-358h] BYREF
  int v56; // [sp+58h] [bp-354h] BYREF
  int v57; // [sp+5Ch] [bp-350h] BYREF
  _WORD *v58; // [sp+60h] [bp-34Ch] BYREF
  char *v59; // [sp+64h] [bp-348h] BYREF
  int v60; // [sp+68h] [bp-344h] BYREF
  unsigned int v61; // [sp+6Ch] [bp-340h] BYREF
  int v62; // [sp+70h] [bp-33Ch] BYREF
  int v63[2]; // [sp+74h] [bp-338h] BYREF
  _DWORD v64[7]; // [sp+7Ch] [bp-330h] BYREF
  _DWORD s[32]; // [sp+98h] [bp-314h] BYREF
  _BYTE v66[448]; // [sp+118h] [bp-294h] BYREF
  char v67[8]; // [sp+2D8h] [bp-D4h] BYREF
  char v68[8]; // [sp+2E0h] [bp-CCh] BYREF
  char v69[8]; // [sp+2E8h] [bp-C4h] BYREF
  int v70; // [sp+2F0h] [bp-BCh]
  __int16 v71; // [sp+2F4h] [bp-B8h]
  char v72[12]; // [sp+2F8h] [bp-B4h] BYREF
  char v73[32]; // [sp+304h] [bp-A8h] BYREF
  unsigned __int8 v74[136]; // [sp+324h] [bp-88h] BYREF

  v2 = a2 & 0x4000;
  if ( (a2 & 0x4000) != 0 )
  {
    sub_1F4D0(1);
    if ( (ntp_syslogmask & 1) != 0 )
    {
      v16 = sub_6C2E8((unsigned __int16 *)(a1 + 4));
      sub_64E00(5, "mrulist from %s rejected due to nomrulist restriction", v16);
    }
    ++sys_restricted;
    return;
  }
  v58 = 0;
  v3 = 0;
  sub_2446C((unsigned int *)&v58, "nonce", 6u, 0);
  sub_2446C((unsigned int *)&v58, "frags", 6u, 0);
  sub_2446C((unsigned int *)&v58, "limit", 6u, 0);
  sub_2446C((unsigned int *)&v58, "mincount", 9u, 0);
  sub_2446C((unsigned int *)&v58, "resall", 7u, 0);
  sub_2446C((unsigned int *)&v58, "resany", 7u, 0);
  sub_2446C((unsigned int *)&v58, "maxlstint", 0xAu, 0);
  sub_2446C((unsigned int *)&v58, "laddr", 6u, 0);
  do
  {
    sub_6C054((int)v74, 0x80u, "last.%d", v3);
    v4 = strlen((const char *)v74);
    sub_2446C((unsigned int *)&v58, v74, v4 + 1, 0);
    sub_6C054((int)v74, 0x80u, "addr.%d", v3++);
    v5 = strlen((const char *)v74);
    sub_2446C((unsigned int *)&v58, v74, v5 + 1, 0);
  }
  while ( v3 != 16 );
  v6 = 0;
  v53 = 0;
  v54 = 0;
  v48 = 0;
  v55 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  memset(s, 0, sizeof(s));
  memset(v66, 0, sizeof(v66));
  while ( 1 )
  {
    v7 = sub_1E820((int)v58, &v59);
    v8 = v7;
    if ( !v7 || (*((_WORD *)v7 + 1) & 0x80) != 0 )
      break;
    v9 = v59;
    v10 = (const char *)v7[1];
    if ( !v59 )
      v9 = (char *)&unk_93CA8;
    v11 = (const char *)v7[1];
    if ( !v59 )
      v59 = v9;
    if ( !strcmp("nonce", v11) )
    {
      free(v6);
      v6 = (void *)(unsigned __int8)*v59;
      if ( *v59 )
        v6 = sub_63D08(v59);
    }
    else if ( !strcmp("frags", v10) )
    {
      if ( sscanf(v59, "%hu", &v50) != 1 )
        goto LABEL_29;
    }
    else if ( !strcmp("limit", v10) )
    {
      if ( sscanf(v59, "%u", &v53) != 1 )
        goto LABEL_29;
    }
    else if ( !strcmp("mincount", v10) )
    {
      if ( sscanf(v59, "%d", &v54) != 1 )
        goto LABEL_29;
      if ( v54 < 0 )
        v54 = 0;
    }
    else if ( !strcmp("resall", v10) )
    {
      v12 = &v51;
LABEL_33:
      if ( sscanf(v59, "0x%hx", v12) != 1 )
        goto LABEL_29;
    }
    else
    {
      if ( !strcmp("resany", v10) )
      {
        v12 = &v52;
        goto LABEL_33;
      }
      if ( !strcmp("maxlstint", v10) )
      {
        if ( sscanf(v59, "%u", &v55) != 1 )
          goto LABEL_29;
      }
      else if ( !strcmp("laddr", v10) )
      {
        if ( !sub_635A0(v59, v64) )
          goto LABEL_29;
        v48 = sub_1753C(v64, 0);
      }
      else if ( sscanf(v10, "last.%d", v63) == 1 && v63[0] <= 0xFu )
      {
        if ( sscanf(v59, "0x%08x.%08x", &v56, &v57) != 2 )
        {
LABEL_29:
          free(v6);
          sub_24DE4(v58);
          return;
        }
        v31 = v57;
        v32 = v63[0] == v2;
        v33 = &v74[8 * v63[0] + 132];
        v34 = 28 * v63[0];
        *((_DWORD *)v33 - 196) = v56;
        *((_DWORD *)v33 - 195) = v31;
        if ( *(_WORD *)&v66[v34] == 2 )
        {
          if ( !*(_DWORD *)&v66[v34 + 4] )
            v32 = 0;
          goto LABEL_111;
        }
        v35 = &v74[v34 + 132];
        if ( *((_DWORD *)v35 - 162) || *((_DWORD *)v35 - 161) || *((_DWORD *)v35 - 160) || *((_DWORD *)v35 - 159) )
        {
LABEL_111:
          if ( v32 )
            goto LABEL_112;
        }
      }
      else if ( sscanf((const char *)v8[1], "addr.%d", v63) == 1 && v63[0] <= 0xFu )
      {
        if ( !sub_635A0(v59, &v66[28 * v63[0]]) )
          goto LABEL_29;
        v13 = &v74[8 * v63[0] + 132];
        if ( *((_DWORD *)v13 - 196) )
        {
          v14 = v63[0] == v2;
          if ( !*((_DWORD *)v13 - 195) )
            v14 = 0;
          if ( v14 )
LABEL_112:
            ++v2;
        }
      }
    }
  }
  sub_24DE4(v58);
  v58 = 0;
  if ( !v6 )
    return;
  if ( sscanf((const char *)v6, "%08x%08x%08x", &v60, &v61, &v62) != 3 )
  {
    v15 = v6;
LABEL_53:
    free(v15);
    return;
  }
  v17 = v60;
  v18 = v61;
  v19 = sub_1E508((unsigned __int16 *)(a1 + 4), v60, v61);
  sub_5F724(v63);
  v15 = v6;
  v20 = v63[0] - v17;
  if ( v18 > v63[1] )
    v21 = v20 - 1;
  else
    v21 = v20;
  v22 = v21 == 15;
  if ( v21 <= 0xF )
    v22 = v62 == v19;
  if ( !v22 )
    goto LABEL_53;
  free(v6);
  if ( !v50 )
  {
    if ( v53 - 1 <= 0xFF )
    {
      v50 = 128;
      goto LABEL_66;
    }
LABEL_104:
    sub_1F4D0(6);
    return;
  }
  if ( v50 > 0x80u )
    goto LABEL_104;
  if ( !v53 )
    v53 = -1;
LABEL_66:
  if ( !v2 )
    goto LABEL_80;
  v23 = (unsigned __int16 *)&v66[8];
  v24 = 0;
  while ( 1 )
  {
    v25 = *(_DWORD *)(mon_hash + 4 * (unsigned __int16)(sub_6C568(v23 - 4) & ~(-1 << mon_hash_bits)));
    if ( v25 )
      break;
LABEL_77:
    ++v24;
    v23 += 14;
    if ( v24 == v2 )
    {
      if ( v24 )
      {
        sub_1F4D0(5);
        return;
      }
LABEL_80:
      v25 = dword_108310;
      if ( (_UNKNOWN *)dword_108310 == &mon_mru_list )
        goto LABEL_121;
      goto LABEL_81;
    }
  }
  v26 = *(v23 - 3);
  while ( 1 )
  {
    if ( *(unsigned __int16 *)(v25 + 46) != v26 )
      goto LABEL_70;
    v27 = *(v23 - 4);
    if ( v27 != *(unsigned __int16 *)(v25 + 44) )
      goto LABEL_70;
    if ( v27 != 2 )
      break;
    if ( *(_DWORD *)(v25 + 48) == *((_DWORD *)v23 - 1) )
      goto LABEL_76;
LABEL_70:
    v25 = *(_DWORD *)v25;
    if ( !v25 )
      goto LABEL_77;
  }
  if ( memcmp((const void *)(v25 + 52), v23, 0x10u) || *(_DWORD *)(v25 + 68) != *((_DWORD *)v23 + 4) )
    goto LABEL_70;
LABEL_76:
  if ( *(_DWORD *)(v25 + 24) != s[2 * v24] || *(_DWORD *)(v25 + 28) != s[2 * v24 + 1] )
    goto LABEL_77;
  sub_1FCCC("last.older", (_DWORD *)(v25 + 24));
  v36 = sub_6C47C((unsigned __int16 *)(v25 + 44));
  v37 = strlen(v36);
  sub_1F0E4("addr.older", (int)v36, v37);
  if ( v53 <= 1 )
  {
    sub_5F724(v63);
    sub_1E688(a1, (int)v74, 0x80u);
    v46 = strlen((const char *)v74);
    sub_1F0E4("nonce", (int)v74, v46);
LABEL_82:
    if ( (unsigned __int16)word_B96B8 < (unsigned int)v50 && v53 )
    {
      v29 = 0;
      v30 = 0;
      while ( 1 )
      {
        if ( *(_DWORD *)(v25 + 36) >= v54
          && (!v51 || (v51 & ~*(unsigned __int16 *)(v25 + 40)) == 0)
          && (!v52 || (v52 & *(_WORD *)(v25 + 40)) != 0)
          && (!v55 || v55 >= v63[0] - *(_DWORD *)(v25 + 24))
          && (!v48 || *(_DWORD *)(v25 + 12) == v48) )
        {
          v39 = 6;
          strcpy(v72, "first.%d");
          strcpy(v67, "ct.%d");
          v71 = 0;
          v70 = 0;
          strcpy(v68, "mv.%d");
          strcpy(v69, "rs.%d");
          v40 = rand();
          v41 = v40 ^ (rand() << 16);
          do
          {
            v42 = v41 & 7;
            v41 >>= 3;
            while ( 1 )
            {
              v43 = v42 % 6;
              v44 = &v74[v42 % 6 + 132];
              if ( !*((_BYTE *)&v70 + v42 % 6) )
                break;
              v42 = v43 + 1;
            }
            switch ( v43 )
            {
              case 1u:
                sub_6C054((int)v73, 0x20u, "last.%d", v30);
                sub_1FCCC(v73, (_DWORD *)(v25 + 24));
                break;
              case 2u:
                sub_6C054((int)v73, 0x20u, (unsigned __int8 *)v72, v30);
                sub_1FCCC(v73, (_DWORD *)(v25 + 16));
                break;
              case 3u:
                sub_6C054((int)v73, 0x20u, (unsigned __int8 *)v67, v30);
                sub_1FAA8(v73, *(_DWORD *)(v25 + 36));
                break;
              case 4u:
                sub_6C054((int)v73, 0x20u, (unsigned __int8 *)v68, v30);
                sub_1FB4C(v73, *(unsigned __int8 *)(v25 + 42));
                break;
              case 5u:
                sub_6C054((int)v73, 0x20u, (unsigned __int8 *)v69, v30);
                sub_1FA04(v73, *(unsigned __int16 *)(v25 + 40));
                break;
              default:
                sub_6C054((int)v73, 0x20u, "addr.%d", v30);
                v49 = sub_6C47C((unsigned __int16 *)(v25 + 44));
                v45 = strlen(v49);
                sub_1F0E4(v73, (int)v49, v45);
                break;
            }
            --v39;
            *(v44 - 184) = 1;
          }
          while ( v39 );
          if ( !v30 )
            sub_1FBF0(0);
          ++v30;
          v29 = v25;
        }
        v25 = *(_DWORD *)(v25 + 4);
        if ( (_UNKNOWN *)v25 == &mon_mru_list || !v25 )
          break;
        if ( (unsigned __int16)word_B96B8 >= (unsigned int)v50 || v53 <= v30 )
          goto LABEL_102;
      }
      if ( v30 > 1 )
        sub_1FBF0(v30 - 1);
      sub_1FCCC("now", v63);
      if ( v29 )
        sub_1FCCC("last.newest", (_DWORD *)(v29 + 24));
    }
    goto LABEL_102;
  }
  v25 = *(_DWORD *)(v25 + 4);
  if ( (_UNKNOWN *)v25 != &mon_mru_list )
  {
LABEL_81:
    sub_5F724(v63);
    sub_1E688(a1, (int)v74, 0x80u);
    v28 = strlen((const char *)v74);
    sub_1F0E4("nonce", (int)v74, v28);
    if ( !v25 )
      goto LABEL_122;
    goto LABEL_82;
  }
LABEL_121:
  sub_5F724(v63);
  sub_1E688(a1, (int)v74, 0x80u);
  v38 = strlen((const char *)v74);
  sub_1F0E4("nonce", (int)v74, v38);
LABEL_122:
  sub_1FCCC("now", v63);
LABEL_102:
  sub_1EBA4(0);
}
// 25804: conditional instruction was optimized away because r10.4!=0
// B7CD4: using guessed type int ntp_syslogmask;
// B96B8: using guessed type __int16 word_B96B8;
// 108310: using guessed type int dword_108310;
// 108360: using guessed type int mon_hash;
// 108364: using guessed type char mon_hash_bits;
// 108C00: using guessed type int sys_restricted;

//----- (00025BB4) --------------------------------------------------------
void sub_25BB4()
{
  _DWORD *v0; // r0
  int v1; // r4
  _WORD *v2; // r5
  unsigned int v3; // r0
  char *v4; // r7
  _DWORD *v5; // r0
  _DWORD *v6; // r0
  char *v7; // r6
  int v9; // r0
  unsigned __int8 *v10; // r4
  int v11; // t1
  __int16 i; // r3
  const char *v13; // r4
  _WORD *v14; // r5
  char *v15; // r4
  __int16 v16; // r3
  const char *v18; // r6
  int v19; // r0
  int v20; // [sp+4h] [bp-60h] BYREF
  unsigned __int8 v21[68]; // [sp+8h] [bp-5Ch] BYREF
  _WORD *v22; // [sp+4Ch] [bp-18h]
  const char *v23; // [sp+54h] [bp-10h] BYREF
  size_t v24; // [sp+58h] [bp-Ch]

  if ( !word_B96C8 )
  {
    v0 = (_DWORD *)sys_peer;
    if ( sys_peer && (*(_DWORD *)(sys_peer + 68) & 8) != 0 )
      goto LABEL_4;
    v0 = (_DWORD *)peer_list;
    if ( peer_list )
    {
      while ( (v0[17] & 8) == 0 )
      {
        v0 = (_DWORD *)*v0;
        if ( !v0 )
          goto LABEL_15;
      }
      goto LABEL_4;
    }
LABEL_15:
    sub_1F4D0(4);
    return;
  }
  v0 = (_DWORD *)sub_31C78((unsigned __int16)word_B96C8);
  if ( !v0 || (v0[17] & 8) == 0 )
    goto LABEL_15;
LABEL_4:
  v22 = 0;
  sub_3A3B4((unsigned int)(v0 + 4), (int)v21);
  v1 = 0;
  v2 = v22;
  word_B94A0 = __rev16(v21[64] & 0xF | (unsigned __int8)(16 * v21[65]));
  v3 = sub_1F95C((unsigned int)v22);
  v4 = (char *)sub_63BA4(0, v3 + 14, 0, 1);
  while ( 1 )
  {
    v5 = sub_1E820((int)&unk_B3EF0, &v20);
    if ( !v5 )
      break;
    if ( (*((_WORD *)v5 + 1) & 0x80) != 0 )
    {
      v6 = sub_1E820((int)v2, &v20);
      if ( !v6 )
      {
        v19 = 6;
LABEL_41:
        sub_1F4D0(v19);
        free(v4);
        sub_24DE4(v22);
        return;
      }
      if ( (*((_WORD *)v6 + 1) & 0x80) != 0 )
      {
        v19 = 5;
        goto LABEL_41;
      }
      v4[*(unsigned __int16 *)v6 + 14] = 1;
    }
    else
    {
      v4[*(unsigned __int16 *)v5] = 1;
    }
    v1 = 1;
  }
  if ( v1 )
  {
    v7 = v4;
    do
    {
      if ( *++v7 )
        sub_201A8(v1, v21, 1);
      ++v1;
    }
    while ( v1 != 14 );
    if ( v2 && (*(_WORD *)((_BYTE *)&dword_0 + (_DWORD)v2 + 2) & 0x80) == 0 )
    {
      v14 = v2 + 4;
      v15 = v4 + 13;
      do
      {
        if ( *++v15 )
        {
          v18 = (const char *)*((_DWORD *)v14 - 1);
          v24 = strlen(v18);
          v23 = v18;
          sub_1EEC8((char *)&v23, 1, 0);
        }
        v16 = v14[1];
        v14 += 4;
      }
      while ( (v16 & 0x80) == 0 );
    }
  }
  else
  {
    v9 = 12;
    v10 = (unsigned __int8 *)&unk_93CB4;
    do
    {
      sub_201A8(v9, v21, 0);
      v11 = *++v10;
      v9 = v11;
    }
    while ( v11 );
    if ( v2 )
    {
      for ( i = *(_WORD *)((char *)&dword_0 + (_DWORD)v2 + 2); (i & 0x80) == 0; i = v2[1] )
      {
        if ( (i & 0x20) != 0 )
        {
          v13 = (const char *)*((_DWORD *)v2 + 1);
          v24 = strlen(v13);
          v23 = v13;
          sub_1EEC8((char *)&v23, 1, 0);
        }
        v2 += 4;
        if ( !v2 )
          break;
      }
    }
  }
  free(v4);
  sub_24DE4(v22);
  sub_1EBA4(0);
}
// 0: using guessed type int dword_0;
// B94A0: using guessed type __int16 word_B94A0;
// B96C8: using guessed type __int16 word_B96C8;
// 108B8C: using guessed type int peer_list;
// 108C2C: using guessed type int sys_peer;

//----- (00025EE0) --------------------------------------------------------
__int16 *__fastcall sub_25EE0(__int16 *result, int a2, const char *a3)
{
  int v5; // r6
  int v6; // r2
  char v7; // r3
  int v8; // r1
  unsigned __int16 *v9; // r0
  const char *v10; // r11
  int v11; // r10
  const char *v12; // r0
  size_t v13; // r0
  unsigned int v14; // r3
  int v15; // r4
  int v16; // r0
  unsigned int v17; // r3
  char v18; // r3
  int v19; // r10
  const char *v20; // r0
  size_t v21; // r0
  int v22; // r4
  signed int v23; // r0
  int v24; // r4
  int v25; // r0
  int v26; // r4
  __int16 v27; // r3
  const char *v28; // r5
  unsigned __int8 v29[68]; // [sp+10h] [bp-15Ch] BYREF
  int v30; // [sp+54h] [bp-118h]
  _DWORD v31[2]; // [sp+5Ch] [bp-110h] BYREF
  char v32[256]; // [sp+64h] [bp-108h] BYREF

  v5 = (int)result;
  if ( a2 )
  {
    v6 = (unsigned __int8)result & 0x7F;
    if ( *(unsigned __int8 *)(a2 + 73) == v6 )
    {
      v17 = *(unsigned __int8 *)(a2 + 74);
      if ( v17 > 0xE )
        return result;
      v7 = v17 + 1;
    }
    else
    {
      v7 = 1;
    }
    v8 = *(unsigned __int16 *)(a2 + 16);
    v9 = (unsigned __int16 *)(a2 + 16);
    *(_BYTE *)(a2 + 73) = v6;
    *(_BYTE *)(a2 + 74) = v7;
    if ( v8 == 2 && *(_WORD *)(a2 + 20) == 32639 )
      v10 = sub_6A3FC(v9);
    else
      v10 = sub_6C2E8(v9);
    v11 = sub_23504(a2);
    v12 = sub_6D3C4(v5);
    sub_6C054((int)v32, 0x100u, "%s %04x %02x %s", v10, v11, v5, v12);
    if ( a3 )
    {
      v13 = strlen(v32);
      sub_6C054((int)&v32[v13], 256 - v13, (unsigned __int8 *)" %s", a3);
    }
    if ( (ntp_syslogmask & 0x20) == 0 )
      goto LABEL_11;
    goto LABEL_27;
  }
  if ( (unsigned __int8)byte_B98DE == (unsigned __int8)result )
  {
    if ( (unsigned __int8)byte_B98DF > 0xEu )
      return result;
    v18 = byte_B98DF + 1;
  }
  else
  {
    v18 = 1;
  }
  byte_B98DE = (char)result;
  byte_B98DF = v18;
  v19 = sub_235A8();
  v20 = sub_6D3C4(v5);
  sub_6C054((int)v32, 0x100u, "0.0.0.0 %04x %02x %s", v19, v5, v20);
  if ( a3 )
  {
    v21 = strlen(v32);
    sub_6C054((int)&v32[v21], 256 - v21, (unsigned __int8 *)" %s", a3);
  }
  if ( (ntp_syslogmask & 2) != 0 )
LABEL_27:
    sub_64E00(6, (unsigned __int8 *)"%s", v32);
LABEL_11:
  result = (__int16 *)sub_4241C((unsigned int)v32);
  if ( num_ctl_traps > 0 )
  {
    if ( (v5 & 0x80) == 0 )
    {
      v22 = 1;
      dword_B96A8 = 0;
      byte_B96AD = 0;
      word_B94A2 = 0;
      byte_B96A4 = 7;
      dword_B9498 = (int)&unk_B94A8;
      dword_B96C4 = (int)&unk_B967C;
      byte_B96AC = 1;
      word_B94A0 = __rev16(sub_235A8());
      do
      {
        v23 = v22++;
        sub_21888(v23);
      }
      while ( v22 != 20 );
      return sub_1EBA4(0);
    }
    if ( a2 )
    {
      v14 = *(unsigned __int16 *)(a2 + 60);
      v15 = 1;
      byte_B96A4 = 7;
      dword_B9498 = (int)&unk_B94A8;
      dword_B96C4 = (int)&unk_B967C;
      word_B94A2 = __rev16(v14);
      dword_B96A8 = 0;
      byte_B96AD = 0;
      byte_B96AC = 1;
      word_B94A0 = __rev16(sub_23504(a2));
      do
      {
        v16 = v15++;
        sub_20810(v16, a2);
      }
      while ( v15 != 51 );
      if ( v5 == 139 )
      {
        v30 = 0;
        sub_3A3B4((unsigned int)(a2 + 16), (int)v29);
        v24 = 1;
        sub_1FA04("refclockstatus", v29[64] & 0xF | (unsigned __int8)(16 * v29[65]));
        do
        {
          v25 = v24++;
          sub_201A8(v25, v29, 0);
        }
        while ( v24 != 14 );
        v26 = v30;
        if ( v30 )
        {
          v27 = *(_WORD *)((char *)&dword_0 + v30 + 2);
          if ( (v27 & 0x80) == 0 )
          {
            do
            {
              if ( (v27 & 0x20) != 0 )
              {
                v28 = *(const char **)(v26 + 4);
                v31[1] = strlen(v28);
                v31[0] = v28;
                sub_1EEC8((char *)v31, 1, 0);
              }
              v26 += 8;
              if ( !v26 )
                break;
              v27 = *(_WORD *)(v26 + 2);
            }
            while ( (v27 & 0x80) == 0 );
            v26 = v30;
          }
        }
        sub_24DE4((_WORD *)v26);
      }
      return sub_1EBA4(0);
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// B7CD4: using guessed type int ntp_syslogmask;
// B9498: using guessed type int dword_B9498;
// B94A0: using guessed type __int16 word_B94A0;
// B94A2: using guessed type __int16 word_B94A2;
// B96A4: using guessed type char byte_B96A4;
// B96A8: using guessed type int dword_B96A8;
// B96AC: using guessed type char byte_B96AC;
// B96AD: using guessed type char byte_B96AD;
// B96C4: using guessed type int dword_B96C4;
// B98DE: using guessed type char byte_B98DE;
// B98DF: using guessed type char byte_B98DF;
// 108260: using guessed type int num_ctl_traps;

//----- (000262E8) --------------------------------------------------------
unsigned int sub_262E8(__int16 *a1, int a2, unsigned __int8 *a3, ...)
{
  unsigned int v5; // r8
  char v7[512]; // [sp+4h] [bp-204h] BYREF
  va_list varg_r3; // [sp+224h] [bp+1Ch] BYREF

  va_start(varg_r3, a3);
  v5 = sub_64BBC((int)v7, 0x200u, a3, (int *)varg_r3);
  sub_25EE0(a1, a2, v7);
  return v5;
}

//----- (0002637C) --------------------------------------------------------
unsigned int __fastcall sub_2637C(_DWORD *a1, int *a2, int a3)
{
  unsigned int v4; // r12
  size_t v5; // r3
  unsigned int v6; // lr
  size_t v8; // r8
  unsigned int result; // r0
  unsigned int v10; // r4
  int v11; // r1
  int v12; // r2
  int v13; // r9
  const void *v14; // r1
  const void *v15; // r1
  int v16; // r10
  int v17; // r0
  _DWORD *v18; // r2

  v4 = a2[2];
  v5 = bswap32(v4);
  if ( v5 > 0xFFE7 )
    sub_6ECC0("ntp_crypto.c", 1774, 2, "vallen <= (65535 - (6 * 4))");
  v6 = a2[4];
  v8 = bswap32(v6);
  result = (v8 + 3) & 0xFFFFFFFC;
  v10 = ((v5 + 3) & 0xFFFFFFFC) + 24 + result;
  if ( a3 + v10 > 0x830 )
    return 0;
  v11 = *a2;
  v12 = a2[1];
  a1[4] = v4;
  a1[2] = v11;
  a1[3] = v12;
  if ( v5 )
  {
    v15 = (const void *)a2[3];
    if ( v15 )
    {
      v16 = v5 >> 2;
      v13 = (v5 >> 2) + 1;
      if ( (v5 & 0xFFFFFFFC) < v5 )
      {
        v17 = v16 + 2;
        v18 = &a1[v16 + 4];
        v16 = (v5 >> 2) + 1;
        v13 = v17;
        v18[1] = 0;
      }
      result = (unsigned int)memcpy(a1 + 5, v15, v5);
      v5 = v16;
      v6 = a2[4];
      goto LABEL_5;
    }
    v5 = 0;
  }
  v13 = 1;
LABEL_5:
  a1[v5 + 5] = v6;
  if ( v8 )
  {
    v14 = (const void *)a2[5];
    if ( v14 )
    {
      if ( (v8 & 0xFFFFFFFC) < v8 )
        a1[v13 + 5 + (v8 >> 2)] = 0;
      result = (unsigned int)memcpy(&a1[v13 + 5], v14, v8);
    }
  }
  if ( v10 <= 0xFFE7 )
    result = v10;
  *a1 = bswap32(bswap32(*(unsigned __int16 *)a1) | v10);
  if ( v10 > 0xFFE7 )
    sub_6ECC0("ntp_crypto.c", 1815, 1, "len <= (65535 - (6 * 4))");
  return result;
}

//----- (00026540) --------------------------------------------------------
void __fastcall sub_26540(int a1, int a2)
{
  int v4; // r0
  int v5; // r12
  void *v6; // r7
  int v7; // r0
  int v8; // r5
  int v9; // r0
  int v10; // r0
  int v11; // [sp+0h] [bp-48h] BYREF
  _BYTE v12[64]; // [sp+4h] [bp-44h] BYREF

  v4 = BN_num_bits();
  v5 = v4 + 7;
  if ( v4 + 7 < 0 )
    v5 = v4 + 14;
  v11 = v5 >> 3;
  v6 = sub_63BA4(0, v5 >> 3, 0, 0);
  v7 = BN_bn2bin(a1, v6);
  v8 = EVP_MD_CTX_new(v7);
  v9 = EVP_MD_CTX_set_flags(v8, 8);
  v10 = EVP_md5(v9);
  EVP_DigestInit_ex(v8, v10, 0);
  EVP_DigestUpdate(v8, v6, v11);
  EVP_DigestFinal(v8, v12, &v11);
  EVP_MD_CTX_free(v8);
  BN_bin2bn(v12, v11, a2);
  free(v6);
}
// B250: using guessed type int __fastcall EVP_DigestInit_ex(_DWORD, _DWORD, _DWORD);
// B554: using guessed type int __fastcall BN_bin2bn(_DWORD, _DWORD, _DWORD);
// B644: using guessed type int __fastcall EVP_md5(_DWORD);
// B668: using guessed type int BN_num_bits(void);
// B68C: using guessed type int __fastcall EVP_MD_CTX_set_flags(_DWORD, _DWORD);
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B848: using guessed type int __fastcall EVP_DigestFinal(_DWORD, _DWORD, _DWORD);
// B9C8: using guessed type int __fastcall EVP_MD_CTX_new(_DWORD);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// BECC: using guessed type int __fastcall BN_bn2bin(_DWORD, _DWORD);

//----- (00026630) --------------------------------------------------------
int __fastcall sub_26630(unsigned int *a1, unsigned int *a2, int a3)
{
  unsigned int v5; // r3
  int v6; // r0
  unsigned int v7; // r3
  unsigned int v9; // r9
  unsigned int v10; // r8
  unsigned int v11; // r7
  unsigned int v12; // r0
  unsigned int v13; // r2
  unsigned int v14; // r2
  unsigned int v15; // r0
  _BOOL4 v16; // lr
  unsigned int v17; // lr
  unsigned int v18; // r1
  bool v19; // zf
  bool v20; // cc
  int v21; // r11
  bool v22; // zf
  int v23; // r10
  int v24; // r3

  v5 = bswap32(*a1);
  if ( (v5 & 0x40000000) != 0 )
    return 271;
  v6 = (unsigned __int16)v5;
  if ( (unsigned __int16)v5 <= 0x17u )
    return 257;
  v7 = HIWORD(v5) << 16;
  if ( v7 == -2113667072 && (*(_BYTE *)(a3 + 92) == 5 || (*(_BYTE *)(a3 + 72) & 0x20) != 0) )
  {
    if ( *(unsigned __int16 *)(a3 + 132) != bswap32(a1[1]) )
      return 271;
  }
  else if ( *(unsigned __int16 *)(a3 + 60) != bswap32(a1[1]) )
  {
    return 271;
  }
  v9 = bswap32(a1[4]);
  if ( v9 - 1 > 0xFFE6 )
    return 257;
  v10 = (v9 + 3) >> 2;
  v11 = bswap32(a1[v10 + 5]);
  if ( v11 > 0xFFE7 )
    return 257;
  v12 = v6 - 24;
  v13 = (v9 + 3) & 0xFFFFFFFC;
  if ( v12 < v13 || v12 - v13 < ((v11 + 3) & 0xFFFFFFFC) )
    return 257;
  v14 = bswap32(a1[2]);
  v15 = bswap32(a1[3]);
  v16 = v14 < v15;
  if ( !v14 )
    v16 = 1;
  if ( v16 )
    return 258;
  if ( a2 )
  {
    v17 = bswap32(*a2);
    v18 = bswap32(a2[1]);
    v19 = v17 == 0;
    if ( v17 )
      v19 = v18 == 0;
    if ( !v19 )
    {
      if ( v17 > v14 )
        return 258;
      v20 = v18 > v15;
      if ( v18 <= v15 )
        v20 = v18 > v14;
      if ( v20 )
        return 259;
    }
  }
  if ( v7 == -2113798144 )
    return 256;
  if ( (crypto_flags & 0x10 & *(_DWORD *)(a3 + 136)) != 0 )
    v21 = dword_B98E0;
  else
    v21 = *(_DWORD *)(a3 + 140);
  v22 = v21 == 0;
  if ( v21 )
    v22 = v11 == 0;
  if ( v22 || !*(_DWORD *)(a3 + 144) )
    return 271;
  if ( EVP_PKEY_size(v21) != v11 )
    return 263;
  v23 = EVP_MD_CTX_new();
  EVP_DigestInit(v23, *(_DWORD *)(a3 + 144));
  EVP_DigestUpdate(v23, a1 + 2, v9 + 12);
  if ( EVP_VerifyFinal(v23, &a1[v10 + 6], v11, v21) > 0 )
  {
    EVP_MD_CTX_free(v23);
    v24 = *(_DWORD *)(a3 + 136);
    if ( (v24 & 0x200) != 0 )
    {
      *(_DWORD *)(a3 + 136) = v24 | 0x400;
      return 256;
    }
    return 256;
  }
  EVP_MD_CTX_free(v23);
  return 264;
}
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B77C: using guessed type int __fastcall EVP_VerifyFinal(_DWORD, _DWORD, _DWORD, _DWORD);
// B9C8: using guessed type int EVP_MD_CTX_new(void);
// BAE8: using guessed type int __fastcall EVP_PKEY_size(_DWORD);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// BF38: using guessed type int __fastcall EVP_DigestInit(_DWORD, _DWORD);
// B98E0: using guessed type int dword_B98E0;
// B9920: using guessed type int crypto_flags;

//----- (000268A4) --------------------------------------------------------
int __fastcall sub_268A4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // lr
  int v4; // r2
  int v5; // r2
  int v6; // r2
  int v7; // r2
  int v8; // r2

  v2 = *(unsigned __int16 *)a2;
  if ( *(unsigned __int16 *)a1 - v2 < 0 )
    return -1;
  if ( *(unsigned __int16 *)a1 != v2 )
    return 1;
  v4 = a2[4];
  if ( a1[4] - v4 < 0 )
    return -1;
  if ( a1[4] != v4 )
    return 1;
  v5 = a2[5];
  if ( a1[5] - v5 < 0 )
    return -1;
  if ( a1[5] != v5 )
    return 1;
  v6 = a2[6];
  if ( a1[6] - v6 < 0 )
    return -1;
  if ( a1[6] != v6 )
    return 1;
  v7 = a2[7];
  if ( a1[7] - v7 < 0 )
    return -1;
  if ( a1[7] != v7 )
    return 1;
  v8 = a2[8];
  if ( a1[8] - v8 < 0 )
    return -1;
  else
    return a1[8] != v8;
}

//----- (0002698C) --------------------------------------------------------
unsigned int __fastcall sub_2698C(unsigned int a1, _DWORD *a2, int a3)
{
  unsigned int v5; // r10
  unsigned int v6; // r9
  unsigned int v7; // r4
  unsigned int result; // r0
  char var1C[60]; // [sp+4h] [bp-1Ch] BYREF

  if ( a1 > 0x17 )
    sub_6ECC0("ntp_crypto.c", 2041, 0, "len < sizeof(v)");
  _strncpy_chk(var1C, *a2, a1, 24);
  if ( a1 <= 0xC )
    sub_6ECC0("ntp_crypto.c", 2043, 0, "len >= 13");
  *(_BYTE *)(a3 + 8) = strtoul(&var1C[a1 - 3], 0, 10);
  var1C[a1 - 3] = 0;
  v5 = a1 - 7;
  *(_BYTE *)(a3 + 7) = strtoul(&var1C[a1 - 5], 0, 10);
  var1C[a1 - 5] = 0;
  v6 = a1 - 9;
  *(_BYTE *)(a3 + 6) = strtoul(&var1C[a1 - 7], 0, 10);
  v7 = a1 - 11;
  var1C[v5] = 0;
  *(_BYTE *)(a3 + 5) = strtoul(&var1C[v6], 0, 10);
  var1C[v6] = 0;
  *(_BYTE *)(a3 + 4) = strtoul(&var1C[v7], 0, 10);
  var1C[v7] = 0;
  result = strtoul(var1C, 0, 10);
  if ( result > 0x31 )
  {
    if ( result > 0x95 )
      goto LABEL_7;
  }
  else
  {
    result += 100;
  }
  result += 1900;
LABEL_7:
  *(_BYTE *)(a3 + 9) = 0;
  *(_WORD *)a3 = result;
  *(_WORD *)(a3 + 2) = 0;
  return result;
}
// B674: using guessed type int __fastcall _strncpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00026B40) --------------------------------------------------------
_DWORD *__fastcall sub_26B40(unsigned __int8 *a1, int a2, unsigned __int16 *a3)
{
  FILE *v6; // r0
  FILE *v7; // r7
  char *v8; // r0
  char *v9; // r0
  int PrivateKey; // r10
  int v11; // r0
  _DWORD *v12; // r4
  void *v13; // r0
  int v14; // r3
  char *v15; // r0
  int v16; // r0
  char *v18; // r1
  int error; // r0
  const char *v20; // r0
  int v21; // [sp+8h] [bp-30Ch] BYREF
  char v22[256]; // [sp+Ch] [bp-308h] BYREF
  char s[2]; // [sp+10Ch] [bp-208h] BYREF
  char v24[254]; // [sp+10Eh] [bp-206h] BYREF
  char v25[256]; // [sp+20Ch] [bp-108h] BYREF

  if ( *a1 == 47 )
    sub_6D4DC(v22, a1, 256);
  else
    sub_6C054((int)v22, 0x100u, "%s/%s", keysdir[0], (const char *)a1);
  v6 = (FILE *)fopen64(v22, "r");
  v7 = v6;
  if ( !v6 )
    return 0;
  v8 = fgets(s, 256, v6);
  if ( !v8 )
  {
    v18 = "crypto_key: empty file %s";
    goto LABEL_14;
  }
  v9 = strrchr(v8, 46);
  if ( !v9 )
  {
    v18 = "crypto_key: no filestamp %s";
    goto LABEL_14;
  }
  if ( sscanf(v9 + 1, "%u", &v21) != 1 )
  {
    v18 = "crypto_key: invalid filestamp %s";
LABEL_14:
    v12 = 0;
    sub_64E00(3, (unsigned __int8 *)v18, v22);
    fclose(v7);
    return v12;
  }
  PrivateKey = PEM_read_PrivateKey(v7, 0, 0, a2);
  v11 = fclose(v7);
  if ( !PrivateKey )
  {
    error = ERR_get_error(v11);
    v20 = (const char *)ERR_error_string(error, 0);
    sub_64E00(3, "crypto_key: %s", v20);
    exit(-1);
  }
  v12 = sub_63BA4(0, 0x10u, 0, 0);
  v12[1] = PrivateKey;
  *v12 = pkinfo;
  pkinfo = (int)v12;
  v13 = sub_63D08((const char *)a1);
  v14 = v21;
  v12[2] = v13;
  v12[3] = v14;
  v15 = strrchr(s, 10);
  if ( v15 )
    *v15 = 0;
  v16 = EVP_PKEY_size(PrivateKey);
  sub_6C054((int)v25, 0x100u, "%s mod %d", v24, 8 * v16);
  sub_42514(a3, v25);
  return v12;
}
// B340: using guessed type int __fastcall ERR_get_error(_DWORD);
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BAE8: using guessed type int __fastcall EVP_PKEY_size(_DWORD);
// BAF4: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// C0D0: using guessed type int __fastcall PEM_read_PrivateKey(_DWORD, _DWORD, _DWORD, _DWORD);
// B6018: using guessed type char *keysdir[2];
// B990C: using guessed type int pkinfo;

//----- (00026D98) --------------------------------------------------------
_DWORD *__fastcall sub_26D98(char *s1, int a2, unsigned __int16 *a3)
{
  int v6; // r4

  v6 = pkinfo;
  if ( !pkinfo )
    return sub_26B40((unsigned __int8 *)s1, a2, a3);
  while ( strcmp(s1, *(const char **)(v6 + 8)) )
  {
    v6 = *(_DWORD *)v6;
    if ( !v6 )
      return sub_26B40((unsigned __int8 *)s1, a2, a3);
  }
  return (_DWORD *)v6;
}
// B990C: using guessed type int pkinfo;

//----- (00026E50) --------------------------------------------------------
int __fastcall sub_26E50(int a1)
{
  int v1; // r5
  _DWORD *v2; // r4
  int v3; // r3
  int v4; // r2
  _DWORD *v5; // r0
  int v6; // r3
  unsigned int v7; // r3
  void *v8; // r3
  size_t n; // [sp+8h] [bp-134h] BYREF
  time_t v11; // [sp+Ch] [bp-130h] BYREF
  unsigned __int64 v12; // [sp+10h] [bp-12Ch] BYREF
  unsigned int v13; // [sp+18h] [bp-124h]
  int v14; // [sp+1Ch] [bp-120h]
  __int16 v15; // [sp+24h] [bp-118h]
  char v16[256]; // [sp+34h] [bp-108h] BYREF

  v1 = EVP_MD_CTX_new(a1);
  if ( dword_108288 )
  {
    dword_108290 = 0;
    pubkey = hostval;
    if ( !dword_108294 )
      dword_108294 = (int)sub_63BA4(0, dword_B98E4, 0, 0);
    EVP_DigestInit(v1, dword_B98E8);
    EVP_DigestUpdate(v1, &pubkey, 12);
    EVP_DigestUpdate(v1, dword_10828C, bswap32(dword_108288));
    if ( EVP_SignFinal(v1, dword_108294, &n, dword_B98E0) )
    {
      if ( n > dword_B98E4 )
        sub_6ECC0("ntp_crypto.c", 1868, 2, "len <= sign_siglen");
      dword_108290 = bswap32(n);
    }
  }
  v2 = (_DWORD *)cinfo;
  if ( cinfo )
  {
    do
    {
      v3 = v2[20];
      v4 = hostval;
      v2[19] = 0;
      v2[15] = v4;
      if ( !v3 )
        v2[20] = sub_63BA4(0, dword_B98E4, 0, 0);
      EVP_DigestInit(v1, dword_B98E8);
      EVP_DigestUpdate(v1, v2 + 15, 12);
      EVP_DigestUpdate(v1, v2[18], bswap32(v2[17]));
      if ( EVP_SignFinal(v1, v2[20], &n, dword_B98E0) )
      {
        if ( n > dword_B98E4 )
          sub_6ECC0("ntp_crypto.c", 1889, 2, "len <= sign_siglen");
        v2[19] = bswap32(n);
      }
      v2 = (_DWORD *)*v2;
    }
    while ( v2 );
  }
  tai_leap = hostval;
  dword_10829C = dword_10826C;
  sub_2DA78(&v12);
  if ( (_DWORD)v12 == v13 && HIDWORD(v12) == v14 )
  {
    v11 = time(0);
    sub_2D7D0(&v12, v11 - 2085978496, &v11);
  }
  v5 = (_DWORD *)dword_1082A4;
  n = 12;
  if ( !dword_1082A4 || dword_1082A0 != 201326592 )
  {
    free((void *)dword_1082A4);
    v5 = sub_63BA4(0, n, 0, 0);
    dword_1082A4 = (int)v5;
    dword_1082A0 = bswap32(n);
  }
  if ( v15 <= 10 )
  {
    memset(v5, 0, n);
    v8 = (void *)dword_1082AC;
    if ( dword_1082AC )
      goto LABEL_21;
    goto LABEL_35;
  }
  *v5 = bswap32(v15);
  v6 = v12;
  v5[1] = bswap32(v12);
  if ( v14 < 0 )
    v7 = v6 + 2160000;
  else
    v7 = v13;
  if ( v14 >= 0 )
    v7 += 604800;
  v5[2] = bswap32(v7);
  v8 = (void *)dword_1082AC;
  if ( !dword_1082AC )
LABEL_35:
    dword_1082AC = (int)sub_63BA4(v8, dword_B98E4, (size_t)v8, (int)v8);
LABEL_21:
  EVP_DigestInit(v1, dword_B98E8);
  EVP_DigestUpdate(v1, &tai_leap, 12);
  EVP_DigestUpdate(v1, dword_1082A4, n);
  if ( EVP_SignFinal(v1, dword_1082AC, &n, dword_B98E0) )
  {
    if ( n > dword_B98E4 )
      sub_6ECC0("ntp_crypto.c", 1939, 2, "len <= sign_siglen");
    dword_1082A8 = bswap32(n);
  }
  crypto_flags |= 2u;
  sub_6C054((int)v16, 0x100u, "signature update ts %u", bswap32(hostval));
  sub_42514(0, v16);
  return EVP_MD_CTX_free(v1);
}
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B9C8: using guessed type int __fastcall EVP_MD_CTX_new(_DWORD);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// BF14: using guessed type int __fastcall EVP_SignFinal(_DWORD, _DWORD, _DWORD, _DWORD);
// BF38: using guessed type int __fastcall EVP_DigestInit(_DWORD, _DWORD);
// B5E48: using guessed type int *pubkey_ptr;
// B5F8C: using guessed type int *tai_leap_ptr;
// B98E0: using guessed type int dword_B98E0;
// B98E4: using guessed type int dword_B98E4;
// B98E8: using guessed type int dword_B98E8;
// B9914: using guessed type int cinfo;
// B9920: using guessed type int crypto_flags;
// 108268: using guessed type int hostval;
// 10826C: using guessed type int dword_10826C;
// 108280: using guessed type int pubkey;
// 108288: using guessed type int dword_108288;
// 10828C: using guessed type int dword_10828C;
// 108290: using guessed type int dword_108290;
// 108294: using guessed type int dword_108294;
// 108298: using guessed type int tai_leap;
// 10829C: using guessed type int dword_10829C;
// 1082A0: using guessed type int dword_1082A0;
// 1082A4: using guessed type int dword_1082A4;
// 1082A8: using guessed type int dword_1082A8;
// 1082AC: using guessed type int dword_1082AC;

//----- (000272C8) --------------------------------------------------------
unsigned int __fastcall sub_272C8(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v6; // r5
  int v7; // r2
  unsigned int v8; // r12
  int v9; // r1
  unsigned int v10; // r2
  unsigned int v11; // r3
  int v12; // r11
  _DWORD *v13; // r5
  int v14; // t1
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r5
  int v19; // r0
  int digestbyname; // r0
  int v22; // r0
  int v23; // r1
  size_t v24; // [sp+8h] [bp-74h] BYREF
  int v25; // [sp+Ch] [bp-70h] BYREF
  int v26; // [sp+10h] [bp-6Ch]
  unsigned int v27; // [sp+14h] [bp-68h]
  unsigned int v28; // [sp+18h] [bp-64h]
  int v29; // [sp+1Ch] [bp-60h]
  int v30; // [sp+20h] [bp-5Ch]
  int v31; // [sp+24h] [bp-58h]
  int v32; // [sp+28h] [bp-54h]
  unsigned int v33; // [sp+2Ch] [bp-50h]
  unsigned int v34; // [sp+30h] [bp-4Ch]
  unsigned int v35[16]; // [sp+34h] [bp-48h] BYREF

  v6 = a2;
  if ( a2 )
  {
    v7 = *(unsigned __int16 *)a1;
    if ( v7 == 2 )
    {
      v22 = a1[1];
      v23 = *(_DWORD *)(a2 + 4);
      v28 = bswap32(a4);
      v12 = 16;
      v25 = v22;
      v26 = v23;
      v27 = bswap32(a3);
    }
    else if ( v7 == 10 )
    {
      v8 = bswap32(a4);
      v9 = a1[3];
      v10 = a1[4];
      v11 = a1[5];
      v25 = a1[2];
      v26 = v9;
      v27 = v10;
      v28 = v11;
      v12 = 40;
      v14 = *(_DWORD *)(v6 + 8);
      v13 = (_DWORD *)(v6 + 8);
      v15 = v13[1];
      v16 = v13[2];
      v17 = v13[3];
      v29 = v14;
      v30 = v15;
      v31 = v16;
      v32 = v17;
      v34 = v8;
      v33 = bswap32(a3);
    }
    else
    {
      v12 = 0;
    }
    v18 = EVP_MD_CTX_new();
    EVP_MD_CTX_set_flags(v18, 8);
    v19 = OBJ_nid2sn(crypto_nid);
    digestbyname = EVP_get_digestbyname(v19);
    EVP_DigestInit_ex(v18, digestbyname, 0);
    EVP_DigestUpdate(v18, &v25, v12);
    EVP_DigestFinal(v18, v35, &v24);
    EVP_MD_CTX_free(v18);
    v6 = bswap32(v35[0]);
    if ( a5 )
    {
      sub_624AC(a3, crypto_nid, v35, v24, 0);
      sub_621BC(a3, a5);
    }
  }
  return v6;
}
// B250: using guessed type int __fastcall EVP_DigestInit_ex(_DWORD, _DWORD, _DWORD);
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// B68C: using guessed type int __fastcall EVP_MD_CTX_set_flags(_DWORD, _DWORD);
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B848: using guessed type int __fastcall EVP_DigestFinal(_DWORD, _DWORD, _DWORD);
// B9C8: using guessed type int EVP_MD_CTX_new(void);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// B6AE0: using guessed type int crypto_nid;

//----- (00027454) --------------------------------------------------------
int __fastcall sub_27454(int a1, int a2)
{
  int v4; // r9
  void *v5; // r3
  unsigned int v6; // r0
  unsigned int v7; // r6
  unsigned int v8; // r2
  unsigned int v9; // r3
  int v10; // r5
  _DWORD *v11; // r11
  int v12; // r8
  unsigned int v13; // r4
  unsigned int v14; // r3
  _BOOL4 v15; // r3
  _DWORD *v16; // r3
  unsigned int v17; // r1
  int v18; // r0
  int v19; // r4
  int v20; // r2
  unsigned int v22; // [sp+0h] [bp-34h]
  unsigned int v23; // [sp+10h] [bp-24h]
  unsigned int v24; // [sp+18h] [bp-1Ch]
  int v25[2]; // [sp+24h] [bp-10h] BYREF

  if ( !a2 )
    return 271;
  v25[1] = 0;
  v25[0] = 0;
  if ( sys_leap == 3 )
  {
    v24 = 0;
    v4 = 0;
    v5 = *(void **)(a1 + 240);
    if ( v5 )
      goto LABEL_6;
LABEL_32:
    *(_DWORD *)(a1 + 240) = sub_63C68(v5, 0x64u, 4u, (int)v5);
    goto LABEL_6;
  }
  sub_5F724(v25);
  v4 = v25[0];
  v24 = bswap32(v25[0]);
  v5 = *(void **)(a1 + 240);
  if ( !v5 )
    goto LABEL_32;
  do
  {
    do
    {
LABEL_6:
      v6 = sub_68AE4();
      v7 = v6;
    }
    while ( v6 < 0x10000 );
  }
  while ( sub_6204C(v6) );
  v8 = *(unsigned __int8 *)(a1 + 94);
  v9 = *(unsigned __int8 *)(a1 + 64);
  v10 = 0;
  v11 = (_DWORD *)(a2 + 24);
  if ( v8 >= v9 )
    v12 = 1 << v9;
  else
    v12 = 1 << v8;
  v13 = 1 << sys_automax;
  if ( 1 << sys_automax >= (unsigned int)(100 * v12) )
    v13 = 100 * v12;
  if ( *(_BYTE *)(a1 + 63) == 5 )
    v14 = 0;
  else
    v14 = *(_DWORD *)(a1 + 168);
  v23 = v14;
  do
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 240) + 4 * v10) = v7;
    v22 = v13 + v12;
    v13 = v13 + v12 - 2 * v12;
    *(_DWORD *)(a1 + 244) = v10;
    v7 = sub_272C8(v11, a1 + 16, v7, v23, v22);
    if ( sub_61FD4(v7) )
      break;
    v15 = v7 <= 0xFFFF;
    if ( !v4 )
      v15 = 1;
    if ( v15 | (v13 >> 31) )
      break;
    ++v10;
  }
  while ( v10 != 100 );
  v16 = *(_DWORD **)(a1 + 284);
  if ( !v16 )
  {
    v16 = sub_63BA4(0, 8u, 0, 0);
    *(_DWORD *)(a1 + 284) = v16;
  }
  v17 = *(_DWORD *)(a1 + 244);
  *v16 = bswap32(v7);
  v18 = 0x8000000;
  v16[1] = bswap32(v17);
  *(_DWORD *)(a1 + 272) = v24;
  *(_DWORD *)(a1 + 280) = 0x8000000;
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 276) = hostval;
  if ( !v4 )
    return 256;
  if ( !*(_DWORD *)(a1 + 292) )
  {
    v18 = (int)sub_63BA4(*(void **)(a1 + 292), dword_B98E4, *(_DWORD *)(a1 + 292), 0);
    *(_DWORD *)(a1 + 292) = v18;
  }
  v19 = EVP_MD_CTX_new(v18);
  EVP_DigestInit(v19, dword_B98E8);
  EVP_DigestUpdate(v19, a1 + 272, 12);
  EVP_DigestUpdate(v19, *(_DWORD *)(a1 + 284), 8);
  if ( EVP_SignFinal(v19, *(_DWORD *)(a1 + 292), v25, dword_B98E0) )
  {
    if ( v25[0] > (unsigned int)dword_B98E4 )
      sub_6ECC0("ntp_crypto.c", 397, 2, "len <= sign_siglen");
    v20 = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(a1 + 288) = bswap32(v25[0]);
    *(_DWORD *)(a1 + 68) = v20 | 0x8000;
  }
  EVP_MD_CTX_free(v19);
  return 256;
}
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B9C8: using guessed type int __fastcall EVP_MD_CTX_new(_DWORD);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// BF14: using guessed type int __fastcall EVP_SignFinal(_DWORD, _DWORD, _DWORD, _DWORD);
// BF38: using guessed type int __fastcall EVP_DigestInit(_DWORD, _DWORD);
// B6C88: using guessed type char sys_automax;
// B98E0: using guessed type int dword_B98E0;
// B98E4: using guessed type int dword_B98E4;
// B98E8: using guessed type int dword_B98E8;
// 108268: using guessed type int hostval;
// 108BC0: using guessed type char sys_leap;

//----- (00027774) --------------------------------------------------------
int __fastcall sub_27774(int a1)
{
  int v1; // r1
  int v3; // r7
  const char *v4; // r3
  _DWORD *v5; // r0
  char v7[256]; // [sp+Ch] [bp-108h] BYREF

  v1 = *(_DWORD *)(a1 + 136);
  if ( (v1 & 0x20) != 0 )
  {
    v3 = 34013184;
    v4 = "iff";
  }
  else if ( (v1 & 0x40) != 0 )
  {
    v3 = 34078720;
    v4 = "gq";
  }
  else
  {
    if ( (v1 & 0x80) == 0 )
    {
LABEL_9:
      v3 = 0x2000000;
      sub_64E00(5, "crypto_ident: no identity parameters found for group %s", *(const char **)(a1 + 80));
      return v3;
    }
    v3 = 34144256;
    v4 = "mv";
  }
  sub_6C054((int)v7, 0x100u, "ntpkey_%spar_%s", v4, *(const char **)(a1 + 80));
  v5 = sub_26D98(v7, 0, (unsigned __int16 *)(a1 + 16));
  *(_DWORD *)(a1 + 172) = v5;
  if ( !v5 )
    goto LABEL_9;
  return v3;
}

//----- (0002787C) --------------------------------------------------------
_DWORD *__fastcall sub_2787C(int a1, int a2, unsigned int a3, char *s)
{
  unsigned int v6; // r4
  size_t v8; // r0
  unsigned int v9; // r8
  size_t v10; // r5
  _DWORD *v11; // r0
  _DWORD *v12; // r3
  _DWORD *v14; // [sp+4h] [bp-18h]
  int v15[2]; // [sp+Ch] [bp-10h] BYREF

  v6 = 0;
  v15[1] = 0;
  v15[0] = 0;
  if ( sys_leap != 3 )
  {
    sub_5F724(v15);
    v6 = v15[0];
  }
  if ( s )
  {
    v8 = strlen(s);
    v9 = v8;
    if ( v8 > 0xFFE6 )
      sub_6ECC0("ntp_crypto.c", 1725, 2, "slen < (65535 - (6 * 4))");
    v10 = v8 + 24;
  }
  else
  {
    v9 = 0;
    v10 = 24;
  }
  v11 = sub_63BA4(0, v10, 0, 1);
  v12 = v11;
  if ( a2 )
  {
    if ( (_WORD)a2 )
      sub_6ECC0("ntp_crypto.c", 1733, 0, "0 == (opcode & ~0xffff0000)");
    *v11 = bswap32(v10 + a2);
    v11[1] = bswap32(a3);
    v11[2] = bswap32(v6);
    if ( !s )
      v11[4] = 0;
    v11[3] = hostval;
    if ( s )
    {
      v11[4] = bswap32(v9);
      v14 = v11;
      memcpy(v11 + 5, s, v9);
      return v14;
    }
  }
  return v12;
}
// 108268: using guessed type int hostval;
// 108BC0: using guessed type char sys_leap;

//----- (000279FC) --------------------------------------------------------
void sub_279FC()
{
  int v0; // r0
  int v1[2]; // [sp+4h] [bp-10h] BYREF

  v1[1] = 0;
  v1[0] = 0;
  if ( sys_leap == 3 )
  {
    hostval = 0;
  }
  else
  {
    v0 = sub_5F724(v1);
    hostval = bswap32(v1[0]);
    if ( hostval )
      sub_26E50(v0);
  }
}
// 108268: using guessed type int hostval;
// 108BC0: using guessed type char sys_leap;

//----- (00027AA0) --------------------------------------------------------
void sub_27AA0()
{
  if ( dword_B98E8 && dword_B98E0 && dword_1082A4 && dword_1082A0 == 201326592 )
    sub_279FC();
}
// B5F8C: using guessed type int *tai_leap_ptr;
// B98E0: using guessed type int dword_B98E0;
// B98E8: using guessed type int dword_B98E8;
// 1082A0: using guessed type int dword_1082A0;
// 1082A4: using guessed type int dword_1082A4;

//----- (00027B48) --------------------------------------------------------
void *__fastcall sub_27B48(_DWORD *a1)
{
  void *v2; // r0
  void *result; // r0

  v2 = (void *)a1[3];
  if ( v2 )
    free(v2);
  result = (void *)a1[5];
  if ( result )
    free(result);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return result;
}

//----- (00027BCC) --------------------------------------------------------
void __fastcall sub_27BCC(_DWORD *a1)
{
  void *v2; // r0
  void *v3; // r0

  if ( a1[2] )
    EVP_PKEY_free();
  v2 = (void *)a1[12];
  if ( v2 )
    free(v2);
  v3 = (void *)a1[13];
  if ( v3 )
    free(v3);
  if ( a1[14] )
    BN_free();
  sub_27B48(a1 + 15);
  free(a1);
}
// BE48: using guessed type int EVP_PKEY_free(void);
// C13C: using guessed type int BN_free(void);

//----- (00027C64) --------------------------------------------------------
char *__fastcall sub_27C64(const void *a1, unsigned int a2, unsigned int a3)
{
  int v3; // r6
  char *v4; // r4
  int pubkey; // r5
  int subject_name; // r0
  char *v7; // r0
  int signature_nid; // r0
  int v9; // r0
  int serialNumber; // r0
  int issuer_name; // r0
  char *v12; // r0
  unsigned int *v13; // r0
  unsigned int *v14; // r0
  int ext_count; // r9
  int i; // r5
  int v17; // r0
  int v18; // r10
  int ext; // r8
  int object; // r0
  int v21; // r0
  _DWORD *data; // r0
  const char *v23; // r5
  const char *v24; // r8
  void *v25; // r0
  _DWORD *v27; // r0
  int error; // r0
  const char *v29; // r0
  int v30; // r0
  const char *v31; // r0
  unsigned __int8 *v35; // [sp+5Ch] [bp-128h]
  const void *v36; // [sp+6Ch] [bp-118h] BYREF
  unsigned __int8 v37[4]; // [sp+70h] [bp-114h] BYREF
  unsigned __int8 v38; // [sp+74h] [bp-110h]
  unsigned __int8 v39; // [sp+75h] [bp-10Fh]
  unsigned __int8 v40; // [sp+76h] [bp-10Eh]
  unsigned __int8 v41; // [sp+77h] [bp-10Dh]
  unsigned __int8 v42; // [sp+78h] [bp-10Ch]
  char v43[256]; // [sp+7Ch] [bp-108h] BYREF

  v36 = a1;
  v3 = d2i_X509(0, &v36, a2);
  if ( !v3 )
  {
    error = ERR_get_error(0);
    v4 = 0;
    v29 = (const char *)ERR_error_string(error, 0);
    sub_64E00(3, "cert_parse: %s", v29);
    return v4;
  }
  v4 = (char *)sub_63BA4(0, 0x54u, 0, 1);
  pubkey = X509_get_pubkey(v3);
  *((_DWORD *)v4 + 2) = pubkey;
  if ( !pubkey )
  {
    v30 = ERR_get_error(0);
    v31 = (const char *)ERR_error_string(v30, 0);
    sub_64E00(3, "cert_parse: %s", v31);
    goto LABEL_25;
  }
  *((_DWORD *)v4 + 3) = X509_get_version(v3);
  subject_name = X509_get_subject_name(v3);
  X509_NAME_oneline(subject_name, v43, 256);
  v7 = strstr(v43, "CN=");
  if ( !v7 )
  {
    sub_64E00(5, "cert_parse: invalid subject %s", v43);
    goto LABEL_25;
  }
  *((_DWORD *)v4 + 12) = sub_63D08(v7 + 3);
  signature_nid = X509_get_signature_nid(v3);
  *((_DWORD *)v4 + 4) = signature_nid;
  v9 = OBJ_nid2sn(signature_nid);
  *((_DWORD *)v4 + 5) = EVP_get_digestbyname(v9);
  serialNumber = X509_get_serialNumber(v3);
  *((_DWORD *)v4 + 6) = ASN1_INTEGER_get(serialNumber);
  issuer_name = X509_get_issuer_name(v3);
  X509_NAME_oneline(issuer_name, v43, 256);
  v12 = strstr(v43, "CN=");
  if ( !v12 )
  {
    sub_64E00(5, "cert_parse: invalid issuer %s", v43);
    goto LABEL_25;
  }
  v35 = (unsigned __int8 *)(v4 + 28);
  *((_DWORD *)v4 + 13) = sub_63D08(v12 + 3);
  v13 = (unsigned int *)X509_get0_notBefore(v3);
  sub_2698C(*v13, v13 + 2, (int)(v4 + 28));
  v14 = (unsigned int *)X509_get0_notAfter(v3);
  sub_2698C(*v14, v14 + 2, (int)(v4 + 38));
  ext_count = X509_get_ext_count(v3);
  if ( ext_count > 0 )
  {
    for ( i = 0; i != ext_count; ++i )
    {
      while ( 1 )
      {
        ext = X509_get_ext(v3, i);
        object = X509_EXTENSION_get_object();
        v21 = OBJ_obj2nid(object);
        if ( v21 != 82 )
          break;
        ++i;
        data = (_DWORD *)X509_EXTENSION_get_data(ext);
        *((_DWORD *)v4 + 14) = BN_bin2bn(data[2] + 2, *data - 2, 0);
        if ( ext_count == i )
          goto LABEL_13;
      }
      if ( v21 == 126 )
      {
        v17 = BIO_s_mem();
        v18 = BIO_new(v17);
        X509V3_EXT_print(v18, ext, 0);
        BIO_gets(v18, v43, 256);
        BIO_free(v18);
        if ( !strcmp(v43, "Trust Root") )
        {
          *((_DWORD *)v4 + 1) |= 1u;
        }
        else if ( !strcmp(v43, "Private") )
        {
          *((_DWORD *)v4 + 1) |= 8u;
        }
      }
    }
  }
LABEL_13:
  v23 = (const char *)*((_DWORD *)v4 + 12);
  v24 = (const char *)*((_DWORD *)v4 + 13);
  if ( !strcmp(v23, v24) )
  {
    if ( X509_verify(v3, *((_DWORD *)v4 + 2)) <= 0 )
    {
      sub_64E00(5, "cert_parse: signature not verified %s", *((const char **)v4 + 12));
LABEL_25:
      v27 = v4;
      v4 = 0;
      sub_27BCC(v27);
      X509_free(v3);
      return v4;
    }
  }
  else if ( !strcmp((const char *)dword_108274, v24) )
  {
    sub_64E00(5, "cert_parse: certificate trail loop %s", v23);
    goto LABEL_25;
  }
  sub_66750(v37, a3, 0);
  if ( sub_268A4(v35, (unsigned __int8 *)v4 + 38) > 0 || sub_268A4(v35, v37) < 0 )
  {
    sub_64E00(
      5,
      "cert_parse: invalid times %s first %u-%02u-%02uT%02u:%02u:%02u last %u-%02u-%02uT%02u:%02u:%02u fstamp %u-%02u-%02"
      "uT%02u:%02u:%02u",
      *((const char **)v4 + 12),
      *((unsigned __int16 *)v4 + 14),
      (unsigned __int8)v4[32],
      (unsigned __int8)v4[33],
      (unsigned __int8)v4[34],
      (unsigned __int8)v4[35],
      (unsigned __int8)v4[36],
      *((unsigned __int16 *)v4 + 19),
      (unsigned __int8)v4[42],
      (unsigned __int8)v4[43],
      (unsigned __int8)v4[44],
      (unsigned __int8)v4[45],
      (unsigned __int8)v4[46],
      *(unsigned __int16 *)v37,
      v38,
      v39,
      v40,
      v41,
      v42);
    goto LABEL_25;
  }
  *((_DWORD *)v4 + 16) = bswap32(a3);
  *((_DWORD *)v4 + 17) = bswap32(a2);
  v25 = sub_63BA4(0, a2, 0, 0);
  *((_DWORD *)v4 + 18) = v25;
  memcpy(v25, a1, a2);
  X509_free(v3);
  return v4;
}
// B340: using guessed type int __fastcall ERR_get_error(_DWORD);
// B3DC: using guessed type int __fastcall X509_get_issuer_name(_DWORD);
// B400: using guessed type int __fastcall X509_get_signature_nid(_DWORD);
// B40C: using guessed type int __fastcall X509_EXTENSION_get_data(_DWORD);
// B454: using guessed type int __fastcall OBJ_obj2nid(_DWORD);
// B4D8: using guessed type int __fastcall X509_get_pubkey(_DWORD);
// B554: using guessed type int __fastcall BN_bin2bn(_DWORD, _DWORD, _DWORD);
// B584: using guessed type int X509_EXTENSION_get_object(void);
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// B5CC: using guessed type int __fastcall X509V3_EXT_print(_DWORD, _DWORD, _DWORD);
// B734: using guessed type int __fastcall BIO_gets(_DWORD, _DWORD, _DWORD);
// B770: using guessed type int __fastcall X509_get_version(_DWORD);
// B884: using guessed type int __fastcall BIO_new(_DWORD);
// B998: using guessed type int __fastcall ASN1_INTEGER_get(_DWORD);
// B9D4: using guessed type int BIO_s_mem(void);
// B9EC: using guessed type int __fastcall X509_NAME_oneline(_DWORD, _DWORD, _DWORD);
// BAF4: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// BB0C: using guessed type int __fastcall X509_get_serialNumber(_DWORD);
// BB90: using guessed type int __fastcall X509_verify(_DWORD, _DWORD);
// BBA8: using guessed type int __fastcall X509_get0_notBefore(_DWORD);
// BD40: using guessed type int __fastcall X509_get_ext(_DWORD, _DWORD);
// BDAC: using guessed type int __fastcall X509_get0_notAfter(_DWORD);
// BDD0: using guessed type int __fastcall X509_get_subject_name(_DWORD);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// BF20: using guessed type int __fastcall BIO_free(_DWORD);
// BFBC: using guessed type int __fastcall d2i_X509(_DWORD, _DWORD, _DWORD);
// BFEC: using guessed type int __fastcall X509_free(_DWORD);
// C07C: using guessed type int __fastcall X509_get_ext_count(_DWORD);
// 108274: using guessed type int dword_108274;

//----- (0002816C) --------------------------------------------------------
int __fastcall sub_2816C(unsigned int *a1)
{
  char *v1; // r0
  int v2; // r5
  int v3; // r10
  const char *v4; // r6
  int v5; // r4
  int *v6; // r7
  _DWORD *v8; // r0

  v1 = sub_27C64(a1 + 5, bswap32(a1[4]), bswap32(a1[3]));
  v2 = (int)v1;
  if ( v1 )
  {
    v3 = cinfo;
    if ( cinfo )
    {
      v4 = (const char *)*((_DWORD *)v1 + 12);
      v5 = cinfo;
      v6 = &cinfo;
      while ( strcmp(v4, *(const char **)(v5 + 48)) || strcmp(*(const char **)(v2 + 52), *(const char **)(v5 + 52)) )
      {
        v6 = (int *)v5;
        v5 = *(_DWORD *)v5;
        if ( !v5 )
          goto LABEL_7;
      }
      if ( bswap32(*(_DWORD *)(v2 + 64)) <= bswap32(*(_DWORD *)(v5 + 64)) )
      {
        v8 = (_DWORD *)v2;
        v2 = v5;
        sub_27BCC(v8);
        goto LABEL_8;
      }
      *v6 = *(_DWORD *)v5;
      sub_27BCC((_DWORD *)v5);
      v3 = cinfo;
    }
LABEL_7:
    *(_DWORD *)v2 = v3;
    cinfo = v2;
LABEL_8:
    *(_DWORD *)(v2 + 4) |= 4u;
    sub_279FC();
  }
  return v2;
}
// B9914: using guessed type int cinfo;

//----- (0002828C) --------------------------------------------------------
int __fastcall sub_2828C(int a1, int a2)
{
  int v3; // r12
  unsigned int v4; // r0
  size_t v5; // r7
  int v6; // r8
  int v7; // r6
  unsigned int *v8; // r4
  unsigned int v9; // r10
  int v10; // r5
  unsigned int v11; // r3
  unsigned __int16 v12; // lr
  _BOOL4 v13; // r2
  int v14; // r10
  int v15; // r5
  const char *v16; // r0
  unsigned int v18; // r2
  int v19; // r3
  char *v20; // r1
  int v21; // r10
  void *v22; // r0
  void *v23; // r0
  _DWORD *v24; // r0
  int v25; // r3
  int v26; // r0
  bool v27; // zf
  time_t *v28; // r2
  int v29; // r2
  int v30; // r3
  unsigned int v31; // r2
  unsigned int v32; // r12
  _QWORD *v33; // r0
  __int64 v34; // r2
  unsigned int v35; // r1
  int v36; // lr
  int v37; // r4
  unsigned __int64 v38; // r2
  int v39; // r3
  int v40; // r0
  int v41; // r0
  int v42; // r0
  unsigned int v43; // r2
  int v44; // r0
  int v45; // r1
  int v46; // r12
  const char *v47; // r3
  unsigned int v48; // r10
  int v49; // r0
  int digestbyname; // r3
  __int16 v51; // r2
  int v52; // r2
  void *v53; // r0
  void *v54; // r0
  void *v55; // r0
  void *v56; // r0
  int v57; // r3
  int v58; // r2
  int v59; // r4
  int v60; // r0
  void *v61; // r0
  int v62; // r10
  void *v63; // r0
  void *v64; // r0
  int v65; // r3
  unsigned int v66; // r2
  int v67; // r0
  bool v68; // cc
  int v69; // r0
  int v70; // r3
  unsigned int v71; // r10
  _DWORD *v72; // r1
  int v73; // r0
  int v74; // r2
  const char *v75; // r3
  int v76; // r1
  const char *v77; // r0
  size_t v78; // r0
  unsigned int *v79; // r10
  unsigned int v80; // r7
  unsigned int v81; // r7
  int v82; // r3
  unsigned int v83; // r1
  unsigned int v84; // r2
  unsigned int v85; // r0
  unsigned int v86; // r3
  int v87; // r0
  int v88; // r0
  unsigned int v89; // r2
  int v90; // r12
  const char *v91; // r3
  int v92; // r0
  int v93; // r0
  int v94; // r0
  unsigned int v95; // r2
  int v96; // r0
  int v97; // r12
  const char *v98; // r3
  int v99; // r2
  int v100; // r1
  int v101; // r2
  const char *v102; // r3
  int v103; // r10
  const char *v104; // r0
  int v105; // r0
  int v106; // r0
  const char *v107; // r0
  int v108; // r0
  int error; // r0
  const char *v110; // r0
  int v111; // r0
  const char *v112; // r0
  unsigned int v113; // r2
  unsigned int v114; // [sp+0h] [bp-184h]
  unsigned int v115; // [sp+0h] [bp-184h]
  unsigned int v116; // [sp+0h] [bp-184h]
  int v117; // [sp+1Ch] [bp-168h]
  unsigned __int16 *v118; // [sp+1Ch] [bp-168h]
  int v119; // [sp+1Ch] [bp-168h]
  int v120; // [sp+1Ch] [bp-168h]
  int v121; // [sp+1Ch] [bp-168h]
  int v122; // [sp+1Ch] [bp-168h]
  const char *v123; // [sp+1Ch] [bp-168h]
  int v124; // [sp+1Ch] [bp-168h]
  unsigned __int16 v125; // [sp+24h] [bp-160h]
  int v126; // [sp+24h] [bp-160h]
  const char *v127; // [sp+24h] [bp-160h]
  int v128; // [sp+24h] [bp-160h]
  unsigned int v129; // [sp+28h] [bp-15Ch]
  int v131; // [sp+38h] [bp-14Ch]
  int v132; // [sp+40h] [bp-144h]
  int v133; // [sp+40h] [bp-144h]
  int v134; // [sp+40h] [bp-144h]
  int v135; // [sp+40h] [bp-144h]
  int v136; // [sp+40h] [bp-144h]
  int v137; // [sp+40h] [bp-144h]
  int v138; // [sp+40h] [bp-144h]
  const char *v139; // [sp+40h] [bp-144h]
  int v140; // [sp+44h] [bp-140h]
  int v141; // [sp+44h] [bp-140h]
  int v142; // [sp+44h] [bp-140h]
  int v143; // [sp+44h] [bp-140h]
  int v144; // [sp+48h] [bp-13Ch]
  const char *v145; // [sp+48h] [bp-13Ch]
  int v146; // [sp+48h] [bp-13Ch]
  int v147; // [sp+48h] [bp-13Ch]
  int v148; // [sp+4Ch] [bp-138h]
  int v149; // [sp+4Ch] [bp-138h]
  int v150; // [sp+4Ch] [bp-138h]
  int v151; // [sp+4Ch] [bp-138h]
  int v152; // [sp+50h] [bp-134h]
  int v153; // [sp+50h] [bp-134h]
  int v154; // [sp+50h] [bp-134h]
  int v155; // [sp+54h] [bp-130h]
  int v156; // [sp+5Ch] [bp-128h] BYREF
  unsigned int *v157; // [sp+60h] [bp-124h] BYREF
  unsigned int *v158; // [sp+64h] [bp-120h] BYREF
  unsigned int *v159; // [sp+68h] [bp-11Ch] BYREF
  int v160; // [sp+6Ch] [bp-118h] BYREF
  int v161; // [sp+70h] [bp-114h] BYREF
  int v162; // [sp+74h] [bp-110h] BYREF
  int v163; // [sp+78h] [bp-10Ch] BYREF
  char v164[256]; // [sp+7Ch] [bp-108h] BYREF

  v3 = *(_DWORD *)(a2 + 84);
  v4 = v3 - 48;
  v131 = *(_BYTE *)(a2 + 88) & 7;
  if ( v3 - 48 > 24 )
  {
    v5 = 0;
    v6 = a2 + 88;
    v7 = 48;
    v129 = 0;
    do
    {
      v8 = (unsigned int *)(v6 + 4 * (v7 / 4));
      v9 = bswap32(*v8);
      v10 = (unsigned __int16)v9;
      v11 = v9 & 0xFFFF0000;
      v12 = bswap32(v8[1]);
      v13 = (unsigned __int16)v9 <= 7u;
      if ( (((v9 & 0xFFFF0000) >> 24) & 0x3F) != 2 )
        v13 = 1;
      v125 = v12;
      v117 = v12;
      if ( v13 )
      {
        v11 = v9 & 0xBFFF0000 | 0x40000000;
        ++sys_badlength;
      }
      if ( v4 < (unsigned __int16)v9 )
        return 257;
      if ( (unsigned __int16)v9 <= 0x17u )
      {
        if ( v11 == -2113863680 )
          goto LABEL_58;
        if ( v11 <= 0x82010000 )
        {
          if ( v11 == 33947648 )
            goto LABEL_165;
          if ( v11 > 0x2060000 )
          {
            if ( v11 == 34078720 || v11 == 34144256 || v11 == 34013184 )
            {
LABEL_165:
              v118 = (unsigned __int16 *)(a1 + 16);
              v15 = 257;
              goto LABEL_19;
            }
            goto LABEL_43;
          }
          if ( v11 == 33685504 || v11 == 33751040 )
            goto LABEL_165;
          goto LABEL_52;
        }
        if ( v11 == -2113601536 )
        {
LABEL_69:
          v26 = sub_26630((unsigned int *)(v6 + 4 * (v7 / 4)), 0, a1);
          v27 = v5 == 12;
          if ( v5 == 12 )
            v27 = v26 == 256;
          v21 = v26;
          v28 = (time_t *)!v27;
          if ( v27 )
          {
            if ( sys_leap != 3 )
              sub_2DE9C(bswap32(v8[5]), *(_DWORD *)(a2 + 72), v28);
            v5 = 12;
            v29 = v8[3];
            tai_leap = v8[2];
            dword_10829C = v29;
            sub_279FC();
            sub_262E8((__int16 *)&byte_9[5], a1, "%d seconds", bswap32(v8[5]));
            v30 = *(_DWORD *)(a1 + 300);
            *(_DWORD *)(a1 + 136) |= 0x4000u;
            v31 = v8[3];
            *(_DWORD *)(a1 + 300) = v30 & 0xFFFFFF7F;
            sub_6C054(
              (int)v164,
              0x100u,
              "leap TAI offset %d at %u expire %u fs %u",
              bswap32(v8[5]),
              bswap32(v8[6]),
              bswap32(v8[7]),
              bswap32(v31));
            sub_42514((unsigned __int16 *)(a1 + 16), v164);
            v3 = *(_DWORD *)(a2 + 84);
            goto LABEL_46;
          }
          if ( v26 != 256 )
            goto LABEL_39;
          goto LABEL_60;
        }
        LOWORD(v18) = 0;
        if ( v11 <= 0x82050000 )
        {
          HIWORD(v18) = -32253;
          if ( v11 == v18 )
          {
LABEL_38:
            v21 = sub_26630((unsigned int *)(v6 + 4 * (v7 / 4)), (unsigned int *)(a1 + 184), a1);
            if ( v21 != 256 )
              goto LABEL_39;
            v135 = EVP_PKEY_size(dword_B98EC);
            if ( v135 != v5
              || (v122 = EVP_PKEY_get0_RSA(dword_B98EC), v78 = RSA_size(), (v79 = (unsigned int *)malloc(v78)) == 0) )
            {
              v118 = (unsigned __int16 *)(a1 + 16);
              v15 = 267;
              v9 = bswap32(*v8);
              goto LABEL_19;
            }
            if ( RSA_private_decrypt(v5, v8 + 5, v79, v122, 4) != 4 )
            {
              v118 = (unsigned __int16 *)(a1 + 16);
              free(v79);
              v15 = 267;
              v9 = bswap32(*v8);
              goto LABEL_19;
            }
            v80 = *v79;
            free(v79);
            sub_3394C((_DWORD *)a1);
            v81 = bswap32(v80);
            v82 = v131 - 1;
            if ( (unsigned int)(v131 - 1) <= 1 )
              v82 = *(_DWORD *)(a1 + 164);
            v83 = bswap32(v8[2]);
            v84 = bswap32(v8[3]);
            v85 = *(_DWORD *)(a1 + 300) & 0xFFFFFF7F;
            *(_DWORD *)(a1 + 136) |= 0x800u;
            if ( (unsigned int)(v131 - 1) <= 1 )
              v81 ^= v82;
            *(_DWORD *)(a1 + 300) = v85;
            *(_DWORD *)(a1 + 168) = v81;
            v86 = v81;
            v5 = v135;
            sub_6C054((int)v164, 0x100u, "cook %x ts %u fs %u", v86, v83, v84);
            goto LABEL_110;
          }
          if ( v11 == -2113667072 )
          {
LABEL_79:
            v21 = sub_26630((unsigned int *)(v6 + 4 * (v7 / 4)), (unsigned int *)(a1 + 208), a1);
            if ( v21 != 256 )
              goto LABEL_39;
            if ( (*(_BYTE *)(a1 + 72) & 0x20) == 0 || *(unsigned __int16 *)(a1 + 132) == v117 )
            {
              v32 = v8[2];
              if ( v32 )
              {
                v33 = *(_QWORD **)(a1 + 220);
                if ( !v33 )
                {
                  v33 = sub_63BA4(0, 8u, 0, 0);
                  v32 = v8[2];
                  *(_DWORD *)(a1 + 220) = v33;
                }
                v34 = *(_QWORD *)(v8 + 5);
                v35 = v8[3];
                v36 = *(_DWORD *)(a1 + 300);
                v37 = *(_DWORD *)(a1 + 136);
                v38 = _byteswap_uint64(__PAIR64__(v34, HIDWORD(v34)));
                *(_DWORD *)(a1 + 208) = v32;
                *(_DWORD *)(a1 + 212) = v35;
                *v33 = v38;
                *(_DWORD *)(a1 + 160) = v38;
                *(_DWORD *)(a1 + 136) = v37 | 0x1000;
                *(_DWORD *)(a1 + 300) = v36 & 0xFFFFFF7F;
                sub_6C054(
                  (int)v164,
                  0x100u,
                  "auto seq %d key %x ts %u fs %u",
                  HIDWORD(v38),
                  (_DWORD)v38,
                  bswap32(v32),
                  bswap32(v35));
                goto LABEL_110;
              }
            }
            goto LABEL_60;
          }
          if ( v11 == -2113798144 )
            goto LABEL_46;
          goto LABEL_43;
        }
        HIWORD(v18) = -32249;
        if ( v11 == v18 )
        {
LABEL_65:
          v118 = (unsigned __int16 *)(a1 + 16);
          v14 = sub_26630((unsigned int *)(v6 + 4 * (v7 / 4)), 0, a1);
          if ( v14 != 256 )
            goto LABEL_18;
          v25 = *(_DWORD *)(a1 + 172);
          if ( !v25 )
          {
            sub_64E00(5, "crypto_iff: scheme unavailable");
            goto LABEL_163;
          }
          if ( bswap32(v8[3]) != *(_DWORD *)(v25 + 12) )
          {
            v20 = "crypto_iff: invalid filestamp %u";
            goto LABEL_33;
          }
          v87 = EVP_PKEY_get0_DSA(*(_DWORD *)(v25 + 4));
          v149 = v87;
          if ( !v87 )
          {
            sub_64E00(5, "crypto_iff: defective key");
LABEL_161:
            v15 = 260;
            v9 = bswap32(*v8);
            goto LABEL_19;
          }
          if ( !*(_DWORD *)(a1 + 176) )
          {
            sub_64E00(5, "crypto_iff: missing challenge");
            goto LABEL_163;
          }
          v142 = BN_CTX_new(v87);
          v146 = BN_new(v142);
          v88 = BN_new(v146);
          v89 = v8[4];
          v136 = v88;
          v158 = v8 + 5;
          v153 = d2i_DSA_SIG(0, &v158, bswap32(v89));
          if ( !v153 )
          {
            v15 = 271;
            BN_free(v136);
            BN_free(v146);
            v108 = BN_CTX_free(v142);
            error = ERR_get_error(v108);
            v110 = (const char *)ERR_error_string(error, 0);
            sub_64E00(3, "crypto_iff: %s", v110);
            v9 = bswap32(*v8);
            goto LABEL_19;
          }
          DSA_get0_key(v149, &v163, 0);
          DSA_get0_pqg(v149, &v159, 0, &v160);
          DSA_SIG_get0(v153, &v161, &v162);
          BN_mod_exp(v136, v163, *(_DWORD *)(a1 + 176), v159, v142);
          BN_mod_exp(v146, v160, v161, v159, v142);
          BN_mod_mul(v136, v136, v146, v159, v142);
          sub_26540(v136, v136);
          v150 = BN_cmp(v136, v162);
          BN_free(v136);
          BN_free(v146);
          BN_CTX_free(v142);
          BN_free(*(_DWORD *)(a1 + 176));
          *(_DWORD *)(a1 + 176) = 0;
          DSA_SIG_free(v153);
          if ( v150 )
          {
            sub_64E00(5, "crypto_iff: identity not verified");
            goto LABEL_163;
          }
          v90 = *(_DWORD *)(a1 + 136);
          v91 = *(const char **)(a1 + 152);
          v115 = bswap32(v8[3]);
          *(_DWORD *)(a1 + 300) &= ~0x80u;
          *(_DWORD *)(a1 + 136) = v90 | 0x200;
          sub_6C054((int)v164, 0x100u, "iff %s fs %u", v91, v115);
          goto LABEL_110;
        }
        if ( v11 <= v18 )
          goto LABEL_16;
      }
      else
      {
        v5 = bswap32(v8[4]);
        v129 = bswap32(v8[3]);
        if ( !v5 || (unsigned int)(unsigned __int16)v9 - 24 < v5 )
          return 257;
        if ( v11 == -2113667072 )
          goto LABEL_79;
        if ( v11 <= 0x82040000 )
        {
          if ( v11 == -2113863680 )
            goto LABEL_58;
          if ( v11 > 0x82010000 )
          {
            if ( v11 == -2113798144 )
            {
              v21 = sub_26630((unsigned int *)(v6 + 4 * (v7 / 4)), 0, a1);
              if ( v21 != 256 )
              {
LABEL_39:
                v15 = v21;
                v118 = (unsigned __int16 *)(a1 + 16);
                v9 = bswap32(*v8);
                goto LABEL_19;
              }
              v62 = sub_2816C((unsigned int *)(v6 + 4 * (v7 / 4)));
              if ( !v62 )
              {
                v118 = (unsigned __int16 *)(a1 + 16);
                v15 = 269;
                v9 = bswap32(*v8);
                goto LABEL_19;
              }
              v63 = *(void **)(a1 + 152);
              if ( v63 )
                free(v63);
              v64 = sub_63D08(*(const char **)(v62 + 52));
              v65 = *(_DWORD *)(a1 + 156);
              *(_DWORD *)(a1 + 152) = v64;
              *(_DWORD *)(a1 + 156) = v62;
              v133 = v65;
              if ( strcmp(*(const char **)(v62 + 48), *(const char **)(v62 + 52)) )
                goto LABEL_121;
              if ( (*(_DWORD *)(v62 + 4) & 1) != 0 )
              {
                v99 = *(_DWORD *)(a1 + 136);
                v100 = *(_DWORD *)(v62 + 56);
                v27 = *(_DWORD *)(a1 + 80) == 0;
                *(_DWORD *)(a1 + 136) = v99 | 0x100;
                *(_DWORD *)(a1 + 180) = v100;
                if ( v27 || (v99 & 0xF0) == 0 )
                  *(_DWORD *)(a1 + 136) = v99 | 0x300;
LABEL_121:
                if ( v133 )
                {
                  v66 = *(_DWORD *)(v133 + 68);
                  v163 = *(_DWORD *)(v133 + 72);
                  v67 = d2i_X509(0, &v163, bswap32(v66));
                  if ( !v67 )
                  {
                    v118 = (unsigned __int16 *)(a1 + 16);
                    v15 = 269;
                    v9 = bswap32(*v8);
                    *(_DWORD *)(v133 + 4) |= 0x80u;
                    goto LABEL_19;
                  }
                  v121 = v67;
                  v68 = X509_verify(v67, *(_DWORD *)(v62 + 8)) <= 0;
                  v69 = v121;
                  if ( v68 )
                  {
                    v118 = (unsigned __int16 *)(a1 + 16);
                    X509_free(v69);
                    v15 = 265;
                    v9 = bswap32(*v8);
                    *(_DWORD *)(v133 + 4) |= 0x80u;
                    goto LABEL_19;
                  }
                  X509_free(v121);
                  if ( sub_268A4((unsigned __int8 *)(v133 + 28), (unsigned __int8 *)(v62 + 28)) < 0 )
                  {
                    v70 = *(_DWORD *)(v133 + 4);
LABEL_127:
                    v71 = *v8;
                    *(_DWORD *)(v133 + 4) = v70 | 0x80;
                    v118 = (unsigned __int16 *)(a1 + 16);
                    v15 = 266;
                    v9 = bswap32(v71);
                    goto LABEL_19;
                  }
                  if ( sub_268A4((unsigned __int8 *)(v133 + 28), (unsigned __int8 *)(v62 + 38)) > 0 )
                  {
                    v70 = *(_DWORD *)(v133 + 4);
                    goto LABEL_127;
                  }
                  *(_DWORD *)(v133 + 4) |= 2u;
                }
              }
              if ( !*(_DWORD *)(a1 + 140) )
              {
                v113 = *(_DWORD *)(v62 + 68);
                v156 = *(_DWORD *)(v62 + 72);
                v124 = d2i_X509(0, &v156, bswap32(v113));
                *(_DWORD *)(a1 + 140) = X509_get_pubkey(v124);
                X509_free(v124);
              }
              v101 = *(_DWORD *)(v62 + 16);
              v139 = *(const char **)(v62 + 48);
              v102 = *(const char **)(v62 + 52);
              *(_DWORD *)(a1 + 300) &= ~0x80u;
              v128 = v101;
              v123 = v102;
              v103 = *(_DWORD *)(v62 + 4);
              v104 = (const char *)OBJ_nid2ln(v101);
              sub_6C054(
                (int)v164,
                0x100u,
                "cert %s %s 0x%x %s (%u) fs %u",
                v139,
                v123,
                v103,
                v104,
                v128,
                bswap32(v8[3]));
LABEL_110:
              sub_42514((unsigned __int16 *)(a1 + 16), v164);
              v3 = *(_DWORD *)(a2 + 84);
              goto LABEL_46;
            }
            if ( v11 == -2113732608 )
              goto LABEL_38;
            goto LABEL_43;
          }
LABEL_52:
          if ( v11 == 33619968 )
          {
            if ( (*(_DWORD *)(a1 + 136) & 0x100) != 0 )
              goto LABEL_145;
            v22 = *(void **)(a1 + 232);
            if ( v22 )
            {
              if ( *(unsigned __int16 *)(a1 + 132) != v12 )
              {
LABEL_145:
                v118 = (unsigned __int16 *)(a1 + 16);
                v15 = 271;
                goto LABEL_19;
              }
              free(v22);
            }
            v23 = sub_63BA4(0, (unsigned __int16)v9, 0, 0);
            v24 = memcpy(v23, (const void *)(v6 + 4 * (v7 / 4)), (unsigned __int16)v9);
            v24[1] = bswap32(*(unsigned __int16 *)(a1 + 60));
            *(_DWORD *)(a1 + 232) = v24;
LABEL_58:
            if ( !*(_DWORD *)(a1 + 136) )
            {
              if ( (unsigned __int16)v9 <= 0x17u )
                sub_6ECC0("ntp_crypto.c", 561, 2, "len >= (6 * 4)");
              if ( v5 - 1 >= 0x200 || (unsigned int)(unsigned __int16)v9 - 24 < v5 )
              {
                v118 = (unsigned __int16 *)(a1 + 16);
                v15 = 257;
                v9 = bswap32(*v8);
                goto LABEL_19;
              }
              if ( (crypto_flags & 0x10) != 0 )
              {
                if ( (v129 & 0x10) == 0 )
                  goto LABEL_141;
                v129 |= 0x2300u;
              }
              else if ( (unsigned int)(v131 - 1) <= 1 )
              {
                if ( (crypto_flags & 0xF0) != 0 )
                {
                  if ( (v129 & 0xF0) == 0 )
                    goto LABEL_141;
                }
                else if ( (v129 & 0xF0) != 0 )
                {
LABEL_141:
                  v118 = (unsigned __int16 *)(a1 + 16);
                  v15 = 262;
                  v9 = bswap32(*v8);
                  goto LABEL_19;
                }
              }
              v48 = HIWORD(v129);
              v49 = OBJ_nid2sn(HIWORD(v129));
              digestbyname = EVP_get_digestbyname(v49);
              if ( !digestbyname )
              {
                v118 = (unsigned __int16 *)(a1 + 16);
                v15 = 261;
                v9 = bswap32(*v8);
                goto LABEL_19;
              }
              v51 = v117;
              v119 = digestbyname;
              *(_WORD *)(a1 + 132) = v51;
              if ( v131 == 4 )
                v129 |= 0x1000u;
              v52 = v129;
              if ( (v129 & 2) == 0 )
              {
                v52 = v129 | 0x4000;
                v129 |= 0x4000u;
              }
              RAND_bytes(a1 + 164, 4, v52);
              v53 = *(void **)(a1 + 148);
              *(_DWORD *)(a1 + 136) = v129;
              *(_DWORD *)(a1 + 144) = v119;
              if ( v53 )
                free(v53);
              v54 = sub_63BA4(0, v5 + 1, 0, 0);
              *(_DWORD *)(a1 + 148) = v54;
              memcpy(v54, v8 + 5, v5);
              *(_BYTE *)(*(_DWORD *)(a1 + 148) + v5) = 0;
              v55 = *(void **)(a1 + 152);
              if ( v55 )
                free(v55);
              v56 = sub_63D08(*(const char **)(a1 + 148));
              v57 = *(unsigned __int16 *)(a1 + 60);
              v58 = *(_DWORD *)(a1 + 148);
              *(_DWORD *)(a1 + 152) = v56;
              v59 = *(unsigned __int16 *)(a1 + 132);
              v126 = v57;
              v120 = v58;
              v60 = OBJ_nid2ln(v48);
              sub_6C054((int)v164, 0x100u, "assoc %d %d host %s %s", v126, v59, v120, v60);
              goto LABEL_110;
            }
            if ( *(unsigned __int16 *)(a1 + 132) != v117 )
            {
              v118 = (unsigned __int16 *)(a1 + 16);
              v15 = 271;
              v9 = bswap32(*v8);
              goto LABEL_19;
            }
LABEL_60:
            v3 = *(_DWORD *)(a2 + 84);
            goto LABEL_46;
          }
          goto LABEL_43;
        }
        if ( v11 == -2113470464 )
          goto LABEL_65;
        if ( v11 <= 0x82070000 )
        {
          if ( v11 == -2113601536 )
            goto LABEL_69;
LABEL_16:
          if ( v11 == -2113536000 )
          {
            v118 = (unsigned __int16 *)(a1 + 16);
            v14 = sub_26630((unsigned int *)(v6 + 4 * (v7 / 4)), 0, a1);
            if ( v14 != 256 )
              goto LABEL_18;
            v72 = (_DWORD *)sub_2816C((unsigned int *)(v6 + 4 * (v7 / 4)));
            if ( !v72 )
            {
              v15 = 269;
              v9 = bswap32(*v8);
              goto LABEL_19;
            }
            v73 = *(_DWORD *)(a1 + 300);
            v74 = v72[4];
            v145 = (const char *)v72[12];
            v75 = (const char *)v72[13];
            v76 = v72[1];
            *(_DWORD *)(a1 + 136) |= 0x2000u;
            *(_DWORD *)(a1 + 300) = v73 & 0xFFFFFF7F;
            v141 = v74;
            v127 = v75;
            v134 = v76;
            v77 = (const char *)OBJ_nid2ln(v74);
            sub_6C054((int)v164, 0x100u, "sign %s %s 0x%x %s (%u) fs %u", v145, v127, v134, v77, v141, bswap32(v8[3]));
LABEL_130:
            sub_42514(v118, v164);
            goto LABEL_60;
          }
          goto LABEL_43;
        }
      }
      if ( v11 == -2113404928 )
      {
        v118 = (unsigned __int16 *)(a1 + 16);
        v14 = sub_26630((unsigned int *)(v6 + 4 * (v7 / 4)), 0, a1);
        if ( v14 != 256 )
        {
LABEL_18:
          v15 = v14;
          v9 = bswap32(*v8);
          goto LABEL_19;
        }
        v39 = *(_DWORD *)(a1 + 172);
        if ( !v39 )
        {
          sub_64E00(5, "crypto_gq: scheme unavailable");
          goto LABEL_163;
        }
        if ( bswap32(v8[3]) < *(_DWORD *)(v39 + 12) )
        {
          v20 = "crypto_gq: invalid filestamp %u";
LABEL_33:
          v15 = 259;
          sub_64E00(5, (unsigned __int8 *)v20);
          v9 = bswap32(*v8);
          goto LABEL_19;
        }
        v40 = EVP_PKEY_get0_RSA(*(_DWORD *)(v39 + 4));
        if ( !v40 )
        {
          sub_64E00(5, "crypto_gq: defective key");
          goto LABEL_161;
        }
        v41 = RSA_get0_key(v40, &v160, 0, &v161);
        if ( !*(_DWORD *)(a1 + 176) )
        {
          sub_64E00(5, "crypto_gq: missing challenge");
          goto LABEL_163;
        }
        v140 = BN_CTX_new(v41);
        v132 = BN_new(v140);
        v42 = BN_new(v132);
        v43 = v8[4];
        v144 = v42;
        v159 = v8 + 5;
        v44 = d2i_DSA_SIG(0, &v159, bswap32(v43));
        v148 = v44;
        if ( !v44 )
        {
          v15 = 271;
          BN_CTX_free(v140);
          BN_free(v132);
          v105 = BN_free(v144);
          v106 = ERR_get_error(v105);
          v107 = (const char *)ERR_error_string(v106, 0);
          sub_64E00(3, "crypto_gq: %s", v107);
          v9 = bswap32(*v8);
          goto LABEL_19;
        }
        DSA_SIG_get0(v44, &v162, &v163);
        v45 = *(_DWORD *)(a1 + 180);
        if ( !v45 )
        {
          sub_64E00(5, "crypto_gq: missing group key");
          goto LABEL_163;
        }
        BN_mod_exp(v144, v45, *(_DWORD *)(a1 + 176), v160, v140);
        BN_mod_exp(v132, v162, v161, v160, v140);
        BN_mod_mul(v132, v144, v132, v160, v140);
        sub_26540(v132, v132);
        v152 = BN_cmp(v132, v163);
        BN_CTX_free(v140);
        BN_free(v132);
        BN_free(v144);
        BN_free(*(_DWORD *)(a1 + 176));
        *(_DWORD *)(a1 + 176) = 0;
        DSA_SIG_free(v148);
        if ( v152 )
        {
          sub_64E00(5, "crypto_gq: identity not verified");
          goto LABEL_163;
        }
        v46 = *(_DWORD *)(a1 + 136);
        v47 = *(const char **)(a1 + 152);
        v114 = bswap32(v8[3]);
        *(_DWORD *)(a1 + 300) &= ~0x80u;
        *(_DWORD *)(a1 + 136) = v46 | 0x200;
        sub_6C054((int)v164, 0x100u, "gq %s fs %u", v47, v114);
        goto LABEL_130;
      }
      if ( v11 == -2113339392 )
      {
        v118 = (unsigned __int16 *)(a1 + 16);
        v14 = sub_26630((unsigned int *)(v6 + 4 * (v7 / 4)), 0, a1);
        if ( v14 != 256 )
          goto LABEL_18;
        v19 = *(_DWORD *)(a1 + 172);
        if ( !v19 )
        {
          sub_64E00(5, "crypto_mv: scheme unavailable");
          goto LABEL_163;
        }
        if ( bswap32(v8[3]) != *(_DWORD *)(v19 + 12) )
        {
          v20 = "crypto_mv: invalid filestamp %u";
          goto LABEL_33;
        }
        v92 = EVP_PKEY_get0_DSA(*(_DWORD *)(v19 + 4));
        v137 = v92;
        if ( !v92 )
        {
          sub_64E00(5, "crypto_mv: defective key");
          goto LABEL_161;
        }
        DSA_get0_pqg(v92, &v158, 0, 0);
        v93 = DSA_get0_key(v137, &v159, &v160);
        if ( !*(_DWORD *)(a1 + 176) )
        {
          sub_64E00(5, "crypto_mv: missing challenge");
          goto LABEL_163;
        }
        v143 = BN_CTX_new(v93);
        v154 = BN_new(v143);
        v138 = BN_new(v154);
        v94 = BN_new(v138);
        v95 = v8[4];
        v147 = v94;
        v157 = v8 + 5;
        v96 = d2i_DSAparams(0, &v157, bswap32(v95));
        v151 = v96;
        if ( !v96 )
        {
          v111 = ERR_get_error(0);
          v112 = (const char *)ERR_error_string(v111, 0);
          v15 = 271;
          sub_64E00(3, "crypto_mv: %s", v112);
          v9 = bswap32(*v8);
          goto LABEL_19;
        }
        DSA_get0_pqg(v96, &v161, &v162, &v163);
        BN_mod_exp(v138, v162, v159, v158, v143);
        BN_mod_exp(v147, v163, v160, v158, v143);
        BN_mod_mul(v138, v138, v147, v158, v143);
        BN_mod_mul(v138, v138, v161, v158, v143);
        v155 = BN_cmp(v138, *(_DWORD *)(a1 + 176));
        BN_CTX_free(v143);
        BN_free(v154);
        BN_free(v138);
        BN_free(v147);
        BN_free(*(_DWORD *)(a1 + 176));
        *(_DWORD *)(a1 + 176) = 0;
        DSA_free(v151);
        if ( v155 )
        {
          sub_64E00(5, "crypto_mv: identity not verified");
LABEL_163:
          v15 = 270;
          v9 = bswap32(*v8);
LABEL_19:
          v16 = sub_6D3C4(v15);
          sub_6C054((int)v164, 0x100u, "%04x %d %02x %s", v9, v125, v15, v16);
          sub_42514(v118, v164);
          return v15;
        }
        v97 = *(_DWORD *)(a1 + 136);
        v98 = *(const char **)(a1 + 152);
        v116 = bswap32(v8[3]);
        *(_DWORD *)(a1 + 300) &= ~0x80u;
        *(_DWORD *)(a1 + 136) = v97 | 0x200;
        sub_6C054((int)v164, 0x100u, "mv %s fs %u", v98, v116);
        goto LABEL_130;
      }
LABEL_43:
      if ( (v11 & 0xC0000000) != 0 )
        goto LABEL_145;
      if ( !*(_DWORD *)(a1 + 232) )
      {
        v61 = sub_63BA4(0, (unsigned __int16)v9, 0, 0);
        *(_DWORD *)(a1 + 232) = memcpy(v61, (const void *)(v6 + 4 * (v7 / 4)), (unsigned __int16)v9);
        v3 = *(_DWORD *)(a2 + 84);
      }
LABEL_46:
      v7 += (v10 + 3) & 0xFFFFFFFC;
      v4 = v3 - v7;
    }
    while ( v3 - v7 > 24 );
  }
  return 256;
}
// B31C: using guessed type int __fastcall EVP_PKEY_get0_RSA(_DWORD);
// B340: using guessed type int __fastcall ERR_get_error(_DWORD);
// B370: using guessed type int __fastcall BN_mod_mul(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// B3D0: using guessed type int __fastcall BN_CTX_free(_DWORD);
// B43C: using guessed type int __fastcall OBJ_nid2ln(_DWORD);
// B4D8: using guessed type int __fastcall X509_get_pubkey(_DWORD);
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// B6F8: using guessed type int __fastcall d2i_DSA_SIG(_DWORD, _DWORD, _DWORD);
// B740: using guessed type int __fastcall DSA_get0_key(_DWORD, _DWORD, _DWORD);
// B758: using guessed type int __fastcall BN_cmp(_DWORD, _DWORD);
// B7B8: using guessed type int RSA_size(void);
// B8FC: using guessed type int __fastcall RSA_private_decrypt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// B908: using guessed type int __fastcall EVP_PKEY_get0_DSA(_DWORD);
// BA7C: using guessed type int __fastcall BN_new(_DWORD);
// BAE8: using guessed type int __fastcall EVP_PKEY_size(_DWORD);
// BAF4: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// BB3C: using guessed type int __fastcall BN_CTX_new(_DWORD);
// BB90: using guessed type int __fastcall X509_verify(_DWORD, _DWORD);
// BCD4: using guessed type int __fastcall DSA_free(_DWORD);
// BD58: using guessed type int __fastcall DSA_SIG_get0(_DWORD, _DWORD, _DWORD);
// BDB8: using guessed type int __fastcall DSA_get0_pqg(_DWORD, _DWORD, _DWORD, _DWORD);
// BE24: using guessed type int __fastcall RAND_bytes(_DWORD, _DWORD, _DWORD);
// BED8: using guessed type int __fastcall BN_mod_exp(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// BFBC: using guessed type int __fastcall d2i_X509(_DWORD, _DWORD, _DWORD);
// BFEC: using guessed type int __fastcall X509_free(_DWORD);
// C040: using guessed type int __fastcall DSA_SIG_free(_DWORD);
// C0C4: using guessed type int __fastcall RSA_get0_key(_DWORD, _DWORD, _DWORD, _DWORD);
// C118: using guessed type int __fastcall d2i_DSAparams(_DWORD, _DWORD, _DWORD);
// C13C: using guessed type int __fastcall BN_free(_DWORD);
// B5F8C: using guessed type int *tai_leap_ptr;
// B98EC: using guessed type int dword_B98EC;
// B9920: using guessed type int crypto_flags;
// 108298: using guessed type int tai_leap;
// 10829C: using guessed type int dword_10829C;
// 108BC0: using guessed type char sys_leap;
// 108C28: using guessed type int sys_badlength;

//----- (00029774) --------------------------------------------------------
unsigned int __fastcall sub_29774(int a1, int a2, int a3, int a4, unsigned int *a5, unsigned int a6)
{
  int v8; // r4
  _DWORD *v9; // r10
  int v10; // r11
  unsigned int v11; // r0
  int v12; // r5
  unsigned int v13; // r3
  unsigned int v14; // r2
  bool v15; // cc
  unsigned int v16; // r2
  bool v17; // cc
  int v18; // r2
  int v19; // r5
  unsigned __int16 v20; // r3
  unsigned int v21; // r1
  int v22; // r8
  int v23; // r10
  int v24; // r6
  int v25; // r0
  int v26; // r0
  unsigned int v27; // r3
  unsigned int v28; // r0
  int v29; // r4
  unsigned int v30; // r3
  int v31; // r5
  unsigned __int16 v32; // r3
  unsigned int v33; // r8
  int v34; // r4
  int v35; // r6
  int v36; // r8
  int v37; // r10
  unsigned int v38; // r4
  char *v39; // r12
  unsigned int v40; // r3
  unsigned int v41; // r3
  void *v42; // r6
  int v43; // r0
  int v44; // r0
  int v45; // r3
  int v46; // r5
  int v47; // r0
  int v48; // r2
  int v49; // r12
  int v50; // r0
  int v51; // r0
  int v52; // r4
  int v53; // r0
  int v54; // r12
  unsigned int v55; // r12
  void *v56; // r3
  int v57; // r0
  int **v58; // r3
  int v60; // r3
  int v61; // r5
  int v62; // r0
  int v63; // r2
  int v64; // r12
  int v65; // r0
  int v66; // r0
  int v67; // r4
  int v68; // r0
  int v69; // r12
  unsigned int v70; // r12
  void *v71; // r3
  int v72; // r0
  int v73; // r11
  const char *v74; // r0
  int v75; // r5
  int v76; // r3
  int v77; // r0
  int v78; // r0
  int v79; // r2
  int v80; // r12
  int v81; // r0
  int v82; // r0
  int v83; // r4
  int v84; // r0
  int v85; // r12
  unsigned int v86; // r12
  void *v87; // r3
  int v88; // r0
  unsigned int v89; // r1
  unsigned int v90; // r3
  int v91; // r0
  unsigned __int16 v92; // r3
  unsigned int v93; // r1
  int v94; // r6
  int v95; // r5
  int v96; // r10
  int v97; // r8
  int v98; // r0
  unsigned int v99; // r1
  void *v100; // r4
  unsigned int v101; // r0
  unsigned int v102; // r12
  int v103; // r5
  unsigned __int16 v104; // r3
  unsigned int v105; // r1
  int v106; // r8
  int v107; // r5
  int v108; // r6
  int v109; // r10
  unsigned int v110; // r0
  unsigned int v111; // r6
  void *v112; // r4
  unsigned int v113; // r1
  unsigned int v114; // r12
  unsigned __int16 v115; // r3
  unsigned int v116; // r2
  int v117; // r0
  int v118; // r10
  int version; // r0
  int v120; // r0
  int v121; // r10
  int v122; // r0
  int v123; // r0
  size_t v124; // r0
  int subject_name; // r0
  int ext_count; // r0
  int v127; // r4
  int v128; // r10
  int ext; // r0
  int v130; // r6
  int v131; // r0
  const char *v132; // r0
  int v133; // r0
  const char *v134; // r0
  int v135; // r0
  const char *v136; // r0
  int v137; // r0
  const char *v138; // r0
  int v139; // r0
  const char *v140; // r0
  int v141; // r0
  const char *v142; // r0
  int error; // r0
  const char *v144; // r0
  int v145; // r0
  const char *v146; // r0
  int v147; // r0
  const char *v148; // r0
  int v149; // r0
  const char *v150; // r0
  int v151; // r0
  unsigned int v152; // r0
  unsigned int v153; // r8
  int v154; // r4
  int v155; // r0
  const char *v156; // r0
  unsigned __int16 v157; // [sp+18h] [bp-274h]
  unsigned __int16 *v158; // [sp+1Ch] [bp-270h]
  _DWORD *v159; // [sp+20h] [bp-26Ch]
  int v160; // [sp+24h] [bp-268h]
  int v162; // [sp+28h] [bp-264h]
  int v163; // [sp+2Ch] [bp-260h]
  int v164; // [sp+2Ch] [bp-260h]
  int v165; // [sp+2Ch] [bp-260h]
  int v166; // [sp+2Ch] [bp-260h]
  int v167; // [sp+2Ch] [bp-260h]
  int v168; // [sp+30h] [bp-25Ch]
  int v169; // [sp+30h] [bp-25Ch]
  int pubkey; // [sp+30h] [bp-25Ch]
  int v171; // [sp+34h] [bp-258h]
  int v172; // [sp+38h] [bp-254h]
  int issuer_name; // [sp+38h] [bp-254h]
  int v174; // [sp+38h] [bp-254h]
  int v175; // [sp+3Ch] [bp-250h]
  unsigned int v176; // [sp+44h] [bp-248h] BYREF
  unsigned int v177; // [sp+48h] [bp-244h] BYREF
  unsigned int v178; // [sp+4Ch] [bp-240h] BYREF
  unsigned int v179; // [sp+50h] [bp-23Ch] BYREF
  unsigned int v180; // [sp+54h] [bp-238h] BYREF
  void *v181; // [sp+58h] [bp-234h] BYREF
  _DWORD *v182; // [sp+5Ch] [bp-230h] BYREF
  int v183; // [sp+60h] [bp-22Ch]
  unsigned int v184; // [sp+68h] [bp-224h] BYREF
  unsigned int v185; // [sp+6Ch] [bp-220h]
  unsigned int v186; // [sp+70h] [bp-21Ch]
  void *ptr; // [sp+74h] [bp-218h]
  unsigned int v188; // [sp+78h] [bp-214h]
  void *v189; // [sp+7Ch] [bp-210h]
  char v190[524]; // [sp+80h] [bp-20Ch] BYREF

  v8 = a4 / 4;
  v9 = (_DWORD *)a1;
  v159 = (_DWORD *)(a2 + 4 * (a4 / 4));
  v10 = bswap32(*a5);
  if ( a1 )
  {
    v158 = (unsigned __int16 *)(a1 + 16);
    if ( v10 >= 0 )
      *(_DWORD *)(a1 + 128) = *a5;
  }
  else
  {
    v158 = (unsigned __int16 *)(a3 + 4);
  }
  v11 = a5[1];
  v12 = 0;
  v13 = HIWORD(v10) << 16;
  v185 = 0;
  v184 = 0;
  v157 = bswap32(v11);
  *(_DWORD *)(a2 + 4 * v8) = bswap32(v13 | 8);
  *(_DWORD *)(a2 + 4 * v8 + 4) = v11;
  if ( sys_leap != 3 )
  {
    sub_5F724((int *)&v184);
    v12 = v184;
    v13 = HIWORD(v10) << 16;
  }
  if ( v13 == -2113863680 )
    goto LABEL_170;
  LOWORD(v14) = 0;
  if ( v13 <= 0x82010000 )
  {
    HIWORD(v14) = 518;
    if ( v13 == v14 )
    {
      sub_66750(&v182, v12, 0);
      v75 = cert_host;
      if ( sub_268A4((unsigned __int8 *)&v182, (unsigned __int8 *)(cert_host + 28)) >= 0
        && sub_268A4((unsigned __int8 *)&v182, (unsigned __int8 *)(v75 + 38)) <= 0 )
      {
        return sub_2637C(v159, (int *)(v75 + 60), a4);
      }
      v31 = 266;
      goto LABEL_115;
    }
    if ( v13 > v14 )
    {
      switch ( v13 )
      {
        case 0x2080000u:
          if ( !v9 )
            return 8;
          v45 = v9[43];
          if ( v45 )
          {
            v46 = EVP_PKEY_get0_RSA(*(_DWORD *)(v45 + 4));
            if ( v46 )
            {
              v47 = v9[44];
              if ( v47 )
                v47 = BN_free(v47);
              v9[44] = BN_new(v47);
              RSA_get0_key(v46, &v181, 0, 0);
              v48 = BN_num_bits(v181);
              v49 = v48 + 7;
              v50 = v9[44];
              if ( v48 + 7 < 0 )
                v49 = v48 + 14;
              v180 = v49 >> 3;
              v51 = BN_rand(v50, 8 * (v49 >> 3), -1, 1);
              v52 = BN_CTX_new(v51);
              BN_div(0, v9[44], v9[44], v181, v52);
              v53 = BN_CTX_free(v52);
              v184 = 0;
              v183 = 0;
              v182 = 0;
              if ( sys_leap == 3 )
                v53 = 0;
              v185 = 0;
              v186 = 0;
              if ( sys_leap == 3 )
                v52 = v53;
              ptr = 0;
              v188 = 0;
              v189 = 0;
              if ( sys_leap != 3 )
              {
                sub_5F724((int *)&v182);
                v52 = (int)v182;
                v53 = bswap32((unsigned int)v182);
              }
              v54 = v9[43];
              v184 = v53;
              v55 = *(_DWORD *)(v54 + 12);
              v186 = bswap32(v180);
              v185 = bswap32(v55);
              v56 = sub_63BA4(0, v180, 0, 0);
              v57 = v9[44];
              ptr = v56;
              BN_bn2bin(v57, v56);
              if ( !v52 )
                goto LABEL_168;
              v189 = sub_63BA4(0, dword_B98E4, 0, 0);
              v29 = EVP_MD_CTX_new(v189);
              EVP_DigestInit(v29, dword_B98E8);
              EVP_DigestUpdate(v29, &v184, 12);
              EVP_DigestUpdate(v29, ptr, v180);
              if ( !EVP_SignFinal(v29, v189, &v180, dword_B98E0) )
                goto LABEL_155;
              v30 = v180;
              if ( v180 > dword_B98E4 )
                sub_6ECC0("ntp_crypto.c", 2554, 2, "len <= sign_siglen");
              goto LABEL_154;
            }
            v31 = 260;
            sub_64E00(5, "crypto_alice2: defective key");
            goto LABEL_115;
          }
          break;
        case 0x2090000u:
          if ( !v9 )
            return 8;
          v76 = v9[43];
          if ( v76 )
          {
            v77 = EVP_PKEY_get0_DSA(*(_DWORD *)(v76 + 4));
            if ( v77 )
            {
              DSA_get0_pqg(v77, &v181, 0, 0);
              v78 = v9[44];
              if ( v78 )
                v78 = BN_free(v78);
              v9[44] = BN_new(v78);
              v79 = BN_num_bits(v181);
              v80 = v79 + 7;
              v81 = v9[44];
              if ( v79 + 7 < 0 )
                v80 = v79 + 14;
              v180 = v80 >> 3;
              v82 = BN_rand(v81, 8 * (v80 >> 3), -1, 1);
              v83 = BN_CTX_new(v82);
              BN_div(0, v9[44], v9[44], v181, v83);
              v84 = BN_CTX_free(v83);
              v184 = 0;
              v183 = 0;
              v182 = 0;
              if ( sys_leap == 3 )
                v84 = 0;
              v185 = 0;
              v186 = 0;
              if ( sys_leap == 3 )
                v83 = v84;
              ptr = 0;
              v188 = 0;
              v189 = 0;
              if ( sys_leap != 3 )
              {
                sub_5F724((int *)&v182);
                v83 = (int)v182;
                v84 = bswap32((unsigned int)v182);
              }
              v85 = v9[43];
              v184 = v84;
              v86 = *(_DWORD *)(v85 + 12);
              v186 = bswap32(v180);
              v185 = bswap32(v86);
              v87 = sub_63BA4(0, v180, 0, 0);
              v88 = v9[44];
              ptr = v87;
              BN_bn2bin(v88, v87);
              if ( !v83 )
                goto LABEL_168;
              v189 = sub_63BA4(0, dword_B98E4, 0, 0);
              v29 = EVP_MD_CTX_new(v189);
              EVP_DigestInit(v29, dword_B98E8);
              EVP_DigestUpdate(v29, &v184, 12);
              EVP_DigestUpdate(v29, ptr, v180);
              if ( !EVP_SignFinal(v29, v189, &v180, dword_B98E0) )
                goto LABEL_155;
              v30 = v180;
              if ( v180 > dword_B98E4 )
                sub_6ECC0("ntp_crypto.c", 2898, 2, "len <= sign_siglen");
              goto LABEL_154;
            }
            v31 = 260;
            sub_64E00(5, "crypto_alice3: defective key");
            goto LABEL_115;
          }
          break;
        case 0x2070000u:
          if ( !v9 )
            return 8;
          v60 = v9[43];
          if ( v60 )
          {
            v61 = EVP_PKEY_get0_DSA(*(_DWORD *)(v60 + 4));
            if ( v61 )
            {
              v62 = v9[44];
              if ( v62 )
                v62 = BN_free(v62);
              v9[44] = BN_new(v62);
              DSA_get0_pqg(v61, 0, &v181, 0);
              v63 = BN_num_bits(v181);
              v64 = v63 + 7;
              v65 = v9[44];
              if ( v63 + 7 < 0 )
                v64 = v63 + 14;
              v180 = v64 >> 3;
              v66 = BN_rand(v65, 8 * (v64 >> 3), -1, 1);
              v67 = BN_CTX_new(v66);
              BN_div(0, v9[44], v9[44], v181, v67);
              v68 = BN_CTX_free(v67);
              v184 = 0;
              v183 = 0;
              v182 = 0;
              if ( sys_leap == 3 )
                v68 = 0;
              v185 = 0;
              v186 = 0;
              if ( sys_leap == 3 )
                v67 = v68;
              ptr = 0;
              v188 = 0;
              v189 = 0;
              if ( sys_leap != 3 )
              {
                sub_5F724((int *)&v182);
                v67 = (int)v182;
                v68 = bswap32((unsigned int)v182);
              }
              v69 = v9[43];
              v184 = v68;
              v70 = *(_DWORD *)(v69 + 12);
              v186 = bswap32(v180);
              v185 = bswap32(v70);
              v71 = sub_63BA4(0, v180, 0, 0);
              v72 = v9[44];
              ptr = v71;
              BN_bn2bin(v72, v71);
              if ( !v67 )
                goto LABEL_168;
              v189 = sub_63BA4(0, dword_B98E4, 0, 0);
              v29 = EVP_MD_CTX_new(v189);
              EVP_DigestInit(v29, dword_B98E8);
              EVP_DigestUpdate(v29, &v184, 12);
              EVP_DigestUpdate(v29, ptr, v180);
              if ( !EVP_SignFinal(v29, v189, &v180, dword_B98E0) )
                goto LABEL_155;
              v30 = v180;
              if ( v180 > dword_B98E4 )
                sub_6ECC0("ntp_crypto.c", 2224, 2, "len <= sign_siglen");
              goto LABEL_154;
            }
            v31 = 260;
            sub_64E00(5, "crypto_alice: defective key");
          }
          else
          {
            v31 = 270;
            sub_64E00(5, "crypto_alice: scheme unavailable");
          }
          goto LABEL_115;
        default:
          goto LABEL_37;
      }
      goto LABEL_190;
    }
    if ( v13 == 33685504 )
    {
      v89 = a5[3];
      v90 = a5[4];
      v184 = a5[2];
      v185 = v89;
      v186 = v90;
      ptr = a5 + 5;
      v189 = 0;
      v188 = 0;
      return sub_2637C(v159, (int *)&v184, a4);
    }
    if ( v13 == 33751040 )
    {
      v58 = &pubkey_ptr;
      return sub_2637C(v159, *v58, a4);
    }
    if ( v13 != 33619968 )
      goto LABEL_37;
LABEL_170:
    v38 = sub_2637C(v159, &hostval, a4);
    v159[3] = bswap32(crypto_flags);
    return v38;
  }
  HIWORD(v14) = -32251;
  v15 = v13 > v14;
  if ( v13 == v14 )
  {
    v58 = &tai_leap_ptr;
    return sub_2637C(v159, *v58, a4);
  }
  LOWORD(v16) = 0;
  if ( !v15 )
  {
    HIWORD(v16) = -32253;
    if ( v13 != v16 )
    {
      if ( v13 == -2113667072 )
      {
        if ( v9 || (v9 = (_DWORD *)sub_31C78(v157)) != 0 )
        {
          v9[17] &= ~0x8000u;
          return sub_2637C(v159, v9 + 68, a4);
        }
LABEL_38:
        v31 = 271;
        goto LABEL_115;
      }
      if ( v13 == -2113798144 )
      {
        v32 = bswap32(*a5);
        if ( v32 > 0x13u )
        {
          v33 = bswap32(a5[4]);
          if ( v33 <= (unsigned int)v32 - 20 && v33 - 1 < 0x200 )
          {
            _memcpy_chk(v190, a5 + 5, v33, 513);
            v190[v33] = 0;
            v34 = cinfo;
            if ( cinfo )
            {
              v35 = 0;
              v36 = 0;
              do
              {
                v37 = *(_DWORD *)(v34 + 4);
                if ( (v37 & 0x88) == 0 && !strcmp(v190, *(const char **)(v34 + 48)) )
                {
                  if ( !strcmp(v190, *(const char **)(v34 + 52)) )
                  {
                    if ( (v37 & 1) != 0 )
                      v36 = v34;
                  }
                  else
                  {
                    v35 = v34;
                  }
                }
                v34 = *(_DWORD *)v34;
              }
              while ( v34 );
              if ( !v36 )
              {
                if ( !v35 )
                  return 8;
                v36 = v35;
              }
              if ( v12 )
                return sub_2637C(v159, (int *)(v36 + 60), a4);
            }
            return 8;
          }
        }
        goto LABEL_114;
      }
LABEL_37:
      if ( v10 >= 0 )
        return 8;
      goto LABEL_38;
    }
    v39 = (char *)bswap32(a5[4]);
    if ( (unsigned int)(v39 - 1) <= 0xFFE5 )
    {
      v40 = (unsigned __int16)v10;
      if ( (unsigned __int16)v10 >= (unsigned int)(v39 + 24) )
      {
        if ( v9 )
          v40 = v9[41];
        v180 = (unsigned int)(a5 + 5);
        if ( v9 )
          a6 = v40;
        v181 = v39;
        v164 = d2i_PublicKey(6, 0, &v180, v39);
        if ( v164 )
        {
          v41 = 0;
          v184 = 0;
          v183 = 0;
          v182 = 0;
          v185 = 0;
          if ( sys_leap == 3 )
            v9 = 0;
          v186 = 0;
          ptr = 0;
          v188 = 0;
          v189 = 0;
          if ( sys_leap != 3 )
          {
            sub_5F724((int *)&v182);
            v9 = v182;
            v41 = bswap32((unsigned int)v182);
          }
          v184 = v41;
          v185 = hostval;
          v181 = (void *)EVP_PKEY_size(v164);
          v186 = bswap32((unsigned int)v181);
          v42 = sub_63BA4(0, (size_t)v181, 0, 0);
          ptr = v42;
          v182 = (_DWORD *)bswap32(a6);
          v43 = EVP_PKEY_get0_RSA(v164);
          v44 = RSA_public_encrypt(4, &v182, v42, v43, 4);
          if ( v44 > 0 )
          {
            EVP_PKEY_free(v164);
            if ( v9 )
            {
              v189 = sub_63BA4(0, dword_B98E4, 0, 0);
              v29 = EVP_MD_CTX_new(v189);
              EVP_DigestInit(v29, dword_B98E8);
              EVP_DigestUpdate(v29, &v184, 12);
              EVP_DigestUpdate(v29, ptr, v181);
              if ( EVP_SignFinal(v29, v189, &v181, dword_B98E0) )
              {
                v30 = (unsigned int)v181;
                if ( (unsigned int)v181 > dword_B98E4 )
                  sub_6ECC0("ntp_crypto.c", 1631, 2, "vallen <= sign_siglen");
LABEL_154:
                v188 = bswap32(v30);
                goto LABEL_155;
              }
              goto LABEL_155;
            }
            goto LABEL_168;
          }
          error = ERR_get_error(v44);
          v31 = 267;
          v144 = (const char *)ERR_error_string(error, 0);
          sub_64E00(3, "crypto_encrypt: %s", v144);
          free(ptr);
          EVP_PKEY_free(v164);
        }
        else
        {
          v139 = ERR_get_error(0);
          v31 = 260;
          v140 = (const char *)ERR_error_string(v139, 0);
          sub_64E00(3, "crypto_encrypt: %s", v140);
        }
        goto LABEL_115;
      }
    }
    goto LABEL_114;
  }
  HIWORD(v16) = -32249;
  v17 = v13 > v16;
  if ( v13 == v16 )
  {
    if ( !iffkey_info )
    {
      v31 = 270;
      sub_64E00(5, "crypto_bob: scheme unavailable");
      goto LABEL_115;
    }
    v103 = EVP_PKEY_get0_DSA(*(_DWORD *)(iffkey_info + 4));
    DSA_get0_pqg(v103, &v178, &v179, &v180);
    DSA_get0_key(v103, 0, &v181);
    v104 = bswap32(*a5);
    if ( v104 > 0x13u )
    {
      v105 = bswap32(a5[4]);
      if ( v105 <= (unsigned int)v104 - 20 )
      {
        v177 = v105;
        if ( v105 - 1 <= 0xFFE6 )
        {
          v166 = BN_bin2bn(a5 + 5, v105, 0);
          if ( v166 )
          {
            v106 = ((int (*)(void))BN_CTX_new)();
            v107 = ((int (*)(void))BN_new)();
            v108 = ((int (*)(void))BN_new)();
            v109 = DSA_SIG_new();
            BN_rand(v107, 8 * v177, -1, 1);
            BN_mod_mul(v108, v181, v166, v179, v106);
            BN_add(v108, v108, v107);
            BN_div(0, v108, v108, v179, v106);
            BN_mod_exp(v107, v180, v107, v178, v106);
            sub_26540(v107, v107);
            DSA_SIG_set0(v109, v108, v107);
            BN_CTX_free(v106);
            BN_free(v166);
            v110 = i2d_DSA_SIG(v109, 0);
            v111 = v110;
            v177 = v110;
            if ( v110 )
            {
              if ( v110 <= 0xFFE7 )
              {
                v184 = 0;
                v183 = 0;
                v182 = 0;
                v185 = 0;
                v186 = 0;
                ptr = 0;
                v188 = 0;
                v189 = 0;
                if ( sys_leap == 3 )
                {
                  v113 = 0;
                  v112 = 0;
                }
                else
                {
                  sub_5F724((int *)&v182);
                  v112 = v182;
                  v111 = v177;
                  v113 = bswap32((unsigned int)v182);
                }
                v184 = v113;
                v114 = *(_DWORD *)(iffkey_info + 12);
                v186 = bswap32(v111);
                v185 = bswap32(v114);
                v182 = sub_63BA4(0, v111, 0, 0);
                ptr = v182;
                i2d_DSA_SIG(v109, &v182);
                DSA_SIG_free(v109);
                if ( !v112 )
                  goto LABEL_168;
                v189 = sub_63BA4(0, dword_B98E4, 0, 0);
                v29 = EVP_MD_CTX_new(v189);
                EVP_DigestInit(v29, dword_B98E8);
                EVP_DigestUpdate(v29, &v184, 12);
                EVP_DigestUpdate(v29, ptr, v177);
                if ( !EVP_SignFinal(v29, v189, &v177, dword_B98E0) )
                  goto LABEL_155;
                v30 = v177;
                if ( v177 > dword_B98E4 )
                  sub_6ECC0("ntp_crypto.c", 2337, 2, "len <= sign_siglen");
                goto LABEL_154;
              }
              v31 = 257;
              sub_64E00(3, "crypto_bob: signature is too big: %u", v110);
              DSA_SIG_free(v109);
            }
            else
            {
              v145 = ERR_get_error(0);
              v31 = 271;
              v146 = (const char *)ERR_error_string(v145, 0);
              sub_64E00(3, "crypto_bob: %s", v146);
              DSA_SIG_free(v109);
            }
          }
          else
          {
            v135 = ERR_get_error(0);
            v31 = 271;
            v136 = (const char *)ERR_error_string(v135, 0);
            sub_64E00(3, "crypto_bob: %s", v136);
          }
          goto LABEL_115;
        }
      }
    }
    goto LABEL_114;
  }
  LOWORD(v18) = 0;
  if ( v17 )
  {
    HIWORD(v18) = -32248;
    if ( v13 == v18 )
    {
      if ( !gqkey_info )
      {
        v31 = 270;
        sub_64E00(5, "crypto_bob2: scheme unavailable");
        goto LABEL_115;
      }
      v91 = EVP_PKEY_get0_RSA(*(_DWORD *)(gqkey_info + 4));
      RSA_get0_key(v91, &v179, &v180, &v181);
      v92 = bswap32(*a5);
      if ( v92 > 0x13u )
      {
        v93 = bswap32(a5[4]);
        if ( v93 <= (unsigned int)v92 - 20 )
        {
          v178 = v93;
          if ( v93 - 1 <= 0xFFE6 )
          {
            v165 = BN_bin2bn(a5 + 5, v93, 0);
            if ( v165 )
            {
              v94 = ((int (*)(void))BN_CTX_new)();
              v95 = ((int (*)(void))BN_new)();
              v96 = ((int (*)(void))BN_new)();
              v97 = ((int (*)(void))BN_new)();
              v169 = DSA_SIG_new();
              BN_rand(v95, 8 * v178, -1, 1);
              BN_div(0, v95, v95, v179, v94);
              BN_mod_exp(v97, v180, v165, v179, v94);
              BN_mod_mul(v97, v95, v97, v179, v94);
              BN_mod_exp(v96, v95, v181, v179, v94);
              sub_26540(v96, v96);
              DSA_SIG_set0(v169, v97, v96);
              BN_CTX_free(v94);
              BN_free(v165);
              BN_free(v95);
              v98 = i2d_DSA_SIG(v169, 0);
              v99 = v98;
              v178 = v98;
              if ( v98 > 0 )
              {
                v184 = 0;
                v183 = 0;
                v182 = 0;
                v185 = 0;
                v186 = 0;
                ptr = 0;
                v188 = 0;
                v189 = 0;
                if ( sys_leap == 3 )
                {
                  v101 = 0;
                  v100 = 0;
                }
                else
                {
                  sub_5F724((int *)&v182);
                  v100 = v182;
                  v99 = v178;
                  v101 = bswap32((unsigned int)v182);
                }
                v184 = v101;
                v102 = *(_DWORD *)(gqkey_info + 12);
                v186 = bswap32(v99);
                v185 = bswap32(v102);
                v182 = sub_63BA4(0, v99, 0, 0);
                ptr = v182;
                i2d_DSA_SIG(v169, &v182);
                DSA_SIG_free(v169);
                if ( !v100 )
                  goto LABEL_168;
                v189 = sub_63BA4(0, dword_B98E4, 0, 0);
                v29 = EVP_MD_CTX_new(v189);
                EVP_DigestInit(v29, dword_B98E8);
                EVP_DigestUpdate(v29, &v184, 12);
                EVP_DigestUpdate(v29, ptr, v178);
                if ( !EVP_SignFinal(v29, v189, &v178, dword_B98E0) )
                  goto LABEL_155;
                v30 = v178;
                if ( v178 > dword_B98E4 )
                  sub_6ECC0("ntp_crypto.c", 2659, 2, "len <= sign_siglen");
                goto LABEL_154;
              }
              v141 = ERR_get_error(v98);
              v31 = 271;
              v142 = (const char *)ERR_error_string(v141, 0);
              sub_64E00(3, "crypto_bob2: %s", v142);
              DSA_SIG_free(v169);
            }
            else
            {
              v137 = ERR_get_error(0);
              v31 = 271;
              v138 = (const char *)ERR_error_string(v137, 0);
              sub_64E00(3, "crypto_bob2: %s", v138);
            }
            goto LABEL_115;
          }
        }
      }
      goto LABEL_114;
    }
    if ( v13 != -2113339392 )
      goto LABEL_37;
    if ( mvkey_info )
    {
      v19 = EVP_PKEY_get0_DSA(*(_DWORD *)(mvkey_info + 4));
      DSA_get0_pqg(v19, &v177, &v178, &v179);
      DSA_get0_key(v19, &v180, &v181);
      v20 = bswap32(*a5);
      if ( v20 > 0x13u )
      {
        v21 = bswap32(a5[4]);
        if ( v21 <= (unsigned int)v20 - 20 )
        {
          v176 = v21;
          if ( v21 - 1 <= 0xFFE6 )
          {
            v168 = BN_bin2bn(a5 + 5, v21, 0);
            if ( v168 )
            {
              v22 = ((int (*)(void))BN_CTX_new)();
              v23 = ((int (*)(void))BN_new)();
              v24 = ((int (*)(void))BN_new)();
              v163 = DSA_new();
              v171 = ((int (*)(void))BN_new)();
              v172 = ((int (*)(void))BN_new)();
              v175 = ((int (*)(void))BN_new)();
              do
              {
                v25 = BN_num_bits(v178);
                BN_rand(v23, v25, 0, 0);
                BN_div(0, v23, v23, v178, v22);
                BN_gcd(v24, v23, v178, v22);
              }
              while ( !BN_is_one(v24) );
              BN_mod_exp(v24, v179, v23, v177, v22);
              BN_mod_mul(v171, v24, v168, v177, v22);
              BN_mod_exp(v172, v181, v23, v177, v22);
              BN_mod_exp(v175, v180, v23, v177, v22);
              v26 = BN_dup(v180);
              DSA_set0_key(v163, v26, 0);
              DSA_set0_pqg(v163, v171, v172, v175);
              BN_CTX_free(v22);
              BN_free(v23);
              BN_free(v168);
              BN_free(v24);
              v27 = 0;
              v184 = 0;
              v183 = 0;
              v182 = 0;
              v185 = 0;
              if ( sys_leap == 3 )
                v22 = 0;
              v186 = 0;
              ptr = 0;
              v188 = 0;
              v189 = 0;
              if ( sys_leap != 3 )
              {
                sub_5F724((int *)&v182);
                v22 = (int)v182;
                v27 = bswap32((unsigned int)v182);
              }
              v184 = v27;
              v185 = bswap32(*(_DWORD *)(mvkey_info + 12));
              v28 = i2d_DSAparams(v163, 0);
              v176 = v28;
              if ( v28 )
              {
                v186 = bswap32(v28);
                v182 = sub_63BA4(0, v28, 0, 0);
                ptr = v182;
                i2d_DSAparams(v163, &v182);
                DSA_free(v163);
                if ( v22 )
                {
                  v189 = sub_63BA4(0, dword_B98E4, 0, 0);
                  v29 = EVP_MD_CTX_new(v189);
                  EVP_DigestInit(v29, dword_B98E8);
                  EVP_DigestUpdate(v29, &v184, 12);
                  EVP_DigestUpdate(v29, ptr, v176);
                  if ( EVP_SignFinal(v29, v189, &v176, dword_B98E0) )
                  {
                    v30 = v176;
                    if ( v176 > dword_B98E4 )
                      sub_6ECC0("ntp_crypto.c", 3011, 2, "len <= sign_siglen");
                    goto LABEL_154;
                  }
LABEL_155:
                  EVP_MD_CTX_free(v29);
                }
LABEL_168:
                v38 = sub_2637C(v159, (int *)&v184, a4);
                sub_27B48(&v184);
                return v38;
              }
              v131 = ERR_get_error(0);
              v31 = 271;
              v132 = (const char *)ERR_error_string(v131, 0);
              sub_64E00(3, "crypto_bob3: %s", v132);
              DSA_free(v163);
            }
            else
            {
              v133 = ERR_get_error(0);
              v31 = 271;
              v134 = (const char *)ERR_error_string(v133, 0);
              sub_64E00(3, "crypto_bob3: %s", v134);
            }
LABEL_115:
            v73 = v10 | 0x40000000;
            *(_DWORD *)(a2 + 4 * v8) |= 0x40u;
            v74 = sub_6D3C4(v31);
            sub_6C054((int)v190, 0x100u, "%04x %d %02x %s", v73, v157, v31, v74);
            sub_42514(v158, v190);
            if ( v73 >= 0 )
              return 0;
            return 8;
          }
        }
      }
LABEL_114:
      v31 = 257;
      goto LABEL_115;
    }
    sub_64E00(5, "crypto_bob3: scheme unavailable");
LABEL_190:
    v31 = 270;
    goto LABEL_115;
  }
  HIWORD(v18) = -32250;
  if ( v13 != v18 )
    goto LABEL_37;
  v185 = 0;
  v184 = 0;
  if ( sys_leap == 3 || (sub_5F724((int *)&v184), (v167 = v184) == 0) )
  {
    v31 = 258;
    goto LABEL_115;
  }
  v115 = bswap32(*a5);
  if ( v115 <= 0x13u )
    goto LABEL_114;
  v116 = bswap32(a5[4]);
  if ( v116 > (unsigned int)v115 - 20 )
    goto LABEL_114;
  v179 = v116;
  if ( v116 - 1 > 0xFFE6 )
    goto LABEL_114;
  v180 = (unsigned int)(a5 + 5);
  v117 = d2i_X509(0, &v180, v116);
  v162 = v117;
  if ( !v117 )
  {
    v147 = ERR_get_error(0);
    v31 = 269;
    v148 = (const char *)ERR_error_string(v147, 0);
    sub_64E00(3, "cert_sign: %s", v148);
    goto LABEL_115;
  }
  pubkey = X509_get_pubkey(v117);
  if ( !pubkey )
  {
    v149 = ERR_get_error(0);
    v31 = 260;
    v150 = (const char *)ERR_error_string(v149, 0);
    sub_64E00(3, "cert_sign: %s", v150);
    X509_free(v162);
    goto LABEL_115;
  }
  v118 = X509_new();
  version = X509_get_version(v162);
  v160 = v118;
  v120 = X509_set_version(v118, version);
  v121 = ASN1_INTEGER_new(v120);
  ASN1_INTEGER_set(v121, v167);
  X509_set_serialNumber(v160, v121);
  v122 = X509_getm_notBefore(v160);
  X509_gmtime_adj(v122);
  v123 = X509_getm_notAfter(v160);
  X509_gmtime_adj(v123);
  issuer_name = X509_get_issuer_name(v160);
  v124 = strlen((const char *)dword_108274);
  X509_NAME_add_entry_by_txt(issuer_name, "commonName", 4097, dword_108274, v124, -1, 0);
  subject_name = X509_get_subject_name(v162);
  X509_set_subject_name(v160, subject_name);
  X509_set_pubkey(v160, pubkey);
  ext_count = X509_get_ext_count(v162);
  if ( ext_count > 0 )
  {
    v174 = v8;
    v127 = 0;
    v128 = ext_count;
    do
    {
      ext = X509_get_ext(v162, v127);
      if ( !X509_add_ext(v160, ext, -1) )
        sub_6ECC0("ntp_crypto.c", 3218, 2, "X509_add_ext(cert, ext, -1)");
      ++v127;
    }
    while ( v128 != v127 );
    v8 = v174;
  }
  X509_free(v162);
  sub_66750(&v182, v167, 0);
  v130 = cert_host;
  if ( sub_268A4((unsigned __int8 *)&v182, (unsigned __int8 *)(cert_host + 28)) < 0
    || sub_268A4((unsigned __int8 *)&v182, (unsigned __int8 *)(v130 + 38)) > 0 )
  {
    v31 = 266;
    X509_free(v160);
    goto LABEL_115;
  }
  X509_sign(v160, dword_B98E0, dword_B98E8);
  v151 = X509_verify(v160, dword_B98E0);
  if ( v151 <= 0 )
  {
    v155 = ERR_get_error(v151);
    v31 = 265;
    v156 = (const char *)ERR_error_string(v155, 0);
    sub_64E00(3, "cert_sign: %s", v156);
    X509_free(v160);
    goto LABEL_115;
  }
  v152 = i2d_X509(v160, 0);
  v153 = a5[3];
  v179 = v152;
  v184 = bswap32(v167);
  v186 = bswap32(v152);
  ptr = 0;
  v188 = 0;
  v189 = 0;
  v185 = v153;
  v181 = sub_63BA4(0, v152, 0, 0);
  ptr = v181;
  i2d_X509(v160, &v181);
  v188 = 0;
  v189 = sub_63BA4(0, dword_B98E4, 0, 0);
  v154 = EVP_MD_CTX_new(v189);
  EVP_DigestInit(v154, dword_B98E8);
  EVP_DigestUpdate(v154, &v184, 12);
  EVP_DigestUpdate(v154, ptr, v179);
  if ( EVP_SignFinal(v154, v189, &v179, dword_B98E0) )
  {
    if ( v179 > dword_B98E4 )
      sub_6ECC0("ntp_crypto.c", 3261, 2, "len <= sign_siglen");
    v188 = bswap32(v179);
  }
  EVP_MD_CTX_free(v154);
  X509_free(v160);
  v38 = sub_2637C(v159, (int *)&v184, a4);
  sub_27B48(&v184);
  return v38;
}
// B22C: using guessed type int __fastcall BN_div(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// B28C: using guessed type int __fastcall X509_add_ext(_DWORD, _DWORD, _DWORD);
// B2EC: using guessed type int __fastcall X509_sign(_DWORD, _DWORD, _DWORD);
// B310: using guessed type int DSA_SIG_new(void);
// B31C: using guessed type int __fastcall EVP_PKEY_get0_RSA(_DWORD);
// B340: using guessed type int __fastcall ERR_get_error(_DWORD);
// B370: using guessed type int __fastcall BN_mod_mul(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// B3D0: using guessed type int __fastcall BN_CTX_free(_DWORD);
// B3DC: using guessed type int __fastcall X509_get_issuer_name(_DWORD);
// B430: using guessed type int __fastcall DSA_SIG_set0(_DWORD, _DWORD, _DWORD);
// B4D8: using guessed type int __fastcall X509_get_pubkey(_DWORD);
// B554: using guessed type int __fastcall BN_bin2bn(_DWORD, _DWORD, _DWORD);
// B5D8: using guessed type int __fastcall BN_gcd(_DWORD, _DWORD, _DWORD, _DWORD);
// B608: using guessed type int __fastcall d2i_PublicKey(_DWORD, _DWORD, _DWORD, _DWORD);
// B668: using guessed type int __fastcall BN_num_bits(_DWORD);
// B6D4: using guessed type int __fastcall X509_getm_notAfter(_DWORD);
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B704: using guessed type int __fastcall i2d_DSAparams(_DWORD, _DWORD);
// B740: using guessed type int __fastcall DSA_get0_key(_DWORD, _DWORD, _DWORD);
// B764: using guessed type int __fastcall DSA_set0_key(_DWORD, _DWORD, _DWORD);
// B770: using guessed type int __fastcall X509_get_version(_DWORD);
// B80C: using guessed type int __fastcall BN_dup(_DWORD);
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// B8C0: using guessed type int __fastcall X509_gmtime_adj(_DWORD);
// B8D8: using guessed type int __fastcall DSA_set0_pqg(_DWORD, _DWORD, _DWORD, _DWORD);
// B8F0: using guessed type int __fastcall ASN1_INTEGER_new(_DWORD);
// B908: using guessed type int __fastcall EVP_PKEY_get0_DSA(_DWORD);
// B914: using guessed type int __fastcall BN_add(_DWORD, _DWORD, _DWORD);
// B9C8: using guessed type int __fastcall EVP_MD_CTX_new(_DWORD);
// BA40: using guessed type int X509_new(void);
// BA4C: using guessed type int __fastcall X509_set_pubkey(_DWORD, _DWORD);
// BA7C: using guessed type int __fastcall BN_new(_DWORD);
// BAD0: using guessed type int __fastcall BN_is_one(_DWORD);
// BADC: using guessed type int __fastcall X509_getm_notBefore(_DWORD);
// BAE8: using guessed type int __fastcall EVP_PKEY_size(_DWORD);
// BAF4: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// BB3C: using guessed type int __fastcall BN_CTX_new(_DWORD);
// BB90: using guessed type int __fastcall X509_verify(_DWORD, _DWORD);
// BBE4: using guessed type int __fastcall i2d_X509(_DWORD, _DWORD);
// BC14: using guessed type int __fastcall X509_set_version(_DWORD, _DWORD);
// BC2C: using guessed type int __fastcall X509_NAME_add_entry_by_txt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// BCD4: using guessed type int __fastcall DSA_free(_DWORD);
// BD34: using guessed type int __fastcall BN_rand(_DWORD, _DWORD, _DWORD, _DWORD);
// BD40: using guessed type int __fastcall X509_get_ext(_DWORD, _DWORD);
// BDB8: using guessed type int __fastcall DSA_get0_pqg(_DWORD, _DWORD, _DWORD, _DWORD);
// BDD0: using guessed type int __fastcall X509_get_subject_name(_DWORD);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// BE30: using guessed type int __fastcall RSA_public_encrypt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// BE48: using guessed type int __fastcall EVP_PKEY_free(_DWORD);
// BE84: using guessed type int __fastcall X509_set_serialNumber(_DWORD, _DWORD);
// BEC0: using guessed type int __fastcall i2d_DSA_SIG(_DWORD, _DWORD);
// BECC: using guessed type int __fastcall BN_bn2bin(_DWORD, _DWORD);
// BED8: using guessed type int __fastcall BN_mod_exp(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// BEF0: using guessed type int __fastcall ASN1_INTEGER_set(_DWORD, _DWORD);
// BF14: using guessed type int __fastcall EVP_SignFinal(_DWORD, _DWORD, _DWORD, _DWORD);
// BF38: using guessed type int __fastcall EVP_DigestInit(_DWORD, _DWORD);
// BF68: using guessed type int __fastcall X509_set_subject_name(_DWORD, _DWORD);
// BFBC: using guessed type int __fastcall d2i_X509(_DWORD, _DWORD, _DWORD);
// BFEC: using guessed type int __fastcall X509_free(_DWORD);
// C040: using guessed type int __fastcall DSA_SIG_free(_DWORD);
// C07C: using guessed type int __fastcall X509_get_ext_count(_DWORD);
// C0B8: using guessed type int DSA_new(void);
// C0C4: using guessed type int __fastcall RSA_get0_key(_DWORD, _DWORD, _DWORD, _DWORD);
// C13C: using guessed type int __fastcall BN_free(_DWORD);
// B5E48: using guessed type int *pubkey_ptr;
// B5F8C: using guessed type int *tai_leap_ptr;
// B98E0: using guessed type int dword_B98E0;
// B98E4: using guessed type int dword_B98E4;
// B98E8: using guessed type int dword_B98E8;
// B9900: using guessed type int mvkey_info;
// B9904: using guessed type int gqkey_info;
// B9908: using guessed type int iffkey_info;
// B9910: using guessed type int cert_host;
// B9914: using guessed type int cinfo;
// B9920: using guessed type int crypto_flags;
// 108268: using guessed type int hostval;
// 108274: using guessed type int dword_108274;
// 108BC0: using guessed type char sys_leap;

//----- (0002B408) --------------------------------------------------------
char *sub_2B408()
{
  int v0; // r0
  const char *v1; // r6
  _DWORD *v2; // r0
  _DWORD *v3; // r10
  unsigned int v4; // r2
  unsigned int v5; // r0
  unsigned int v6; // r10
  _DWORD *v7; // r0
  FILE *v8; // r0
  FILE *v9; // r9
  char *v10; // r0
  char *v11; // r0
  char *v12; // r9
  char *v13; // r9
  char *v14; // r0
  unsigned int v15; // r12
  int v16; // r1
  const char *v17; // r8
  char *v18; // r0
  _DWORD *v19; // r0
  int v20; // r4
  int v21; // r0
  int v22; // r4
  const char *v23; // r0
  int error; // r0
  const char *v26; // r0
  void *v27; // [sp+1Ch] [bp-528h] BYREF
  unsigned int v28; // [sp+20h] [bp-524h] BYREF
  unsigned int v29; // [sp+24h] [bp-520h]
  char *s1; // [sp+28h] [bp-51Ch] BYREF
  void *ptr; // [sp+2Ch] [bp-518h] BYREF
  void *v32; // [sp+30h] [bp-514h]
  int v33[2]; // [sp+34h] [bp-510h] BYREF
  char v34[4]; // [sp+3Ch] [bp-508h] BYREF
  char name[256]; // [sp+13Ch] [bp-408h] BYREF
  char v36[256]; // [sp+23Ch] [bp-308h] BYREF
  char s[2]; // [sp+33Ch] [bp-208h] BYREF
  char v38[242]; // [sp+33Eh] [bp-206h] BYREF
  char v39[256]; // [sp+43Ch] [bp-108h] BYREF

  if ( (crypto_flags & 1) != 0 )
    return sub_64E00(5, "crypto_setup: spurious crypto command");
  v0 = sub_6C714();
  if ( !RAND_status(v0) )
  {
    v1 = (const char *)dword_B98F0;
    if ( dword_B98F0 )
    {
      if ( *(_BYTE *)dword_B98F0 != 47 )
      {
        v1 = v34;
        sub_6C054((int)v34, 0x100u, "%s/%s", keysdir[0], (const char *)dword_B98F0);
      }
    }
    else
    {
      v1 = v34;
      RAND_file_name();
    }
    if ( !RAND_load_file(v1, -1) )
    {
      sub_64E00(3, "crypto_setup: random seed file %s missing", v1);
      exit(-1);
    }
    sub_5F724(v33);
    RAND_seed(v33, 8);
    RAND_write_file(v1);
  }
  gethostname(name, 0x100u);
  if ( dword_B98F4 )
    sub_6D4DC(name, (unsigned __int8 *)dword_B98F4, 256);
  if ( !dword_B98F8 )
    dword_B98F8 = (int)sub_63D08(name);
  hostval = 0;
  dword_10826C = 0;
  dword_108270 = 0;
  dword_108274 = 0;
  dword_108278 = 0;
  dword_10827C = 0;
  pubkey = 0;
  dword_108284 = 0;
  dword_108288 = 0;
  dword_10828C = 0;
  dword_108290 = 0;
  dword_108294 = 0;
  tai_leap = 0;
  dword_10829C = 0;
  dword_1082A0 = 0;
  dword_1082A4 = 0;
  dword_1082A8 = 0;
  dword_1082AC = 0;
  sub_6C054((int)v34, 0x100u, "ntpkey_host_%s", name);
  v2 = sub_26D98(v34, dword_B98F8, 0);
  v3 = v2;
  if ( !v2 )
  {
    sub_64E00(3, "crypto_setup: host key file %s not found or corrupt", v34);
    exit(-1);
  }
  if ( EVP_PKEY_base_id(v2[1]) != 6 )
  {
    sub_64E00(3, "crypto_setup: host key is not RSA key type");
    exit(-1);
  }
  v4 = bswap32(v3[3]);
  dword_B98EC = v3[1];
  dword_10826C = v4;
  dword_B98E0 = dword_B98EC;
  v5 = i2d_PublicKey(dword_B98EC, 0);
  v6 = bswap32(v5);
  v27 = sub_63BA4(0, v5, 0, 0);
  dword_10828C = (int)v27;
  i2d_PublicKey(dword_B98EC, &v27);
  dword_108288 = v6;
  dword_108284 = dword_10826C;
  sub_6C054((int)v34, 0x100u, "ntpkey_sign_%s", name);
  v7 = sub_26D98(v34, dword_B98F8, 0);
  if ( v7 )
    dword_B98E0 = v7[1];
  sub_6C054((int)v34, 0x100u, "ntpkey_cert_%s", name);
  if ( v34[0] == 47 )
    sub_6D4DC(v36, (unsigned __int8 *)v34, 256);
  else
    sub_6C054((int)v36, 0x100u, "%s/%s", keysdir[0], v34);
  v8 = (FILE *)fopen64(v36, "r");
  v9 = v8;
  if ( !v8 )
    goto LABEL_45;
  v10 = fgets(s, 256, v8);
  if ( !v10 )
  {
    sub_64E00(3, "crypto_cert: empty file %s", v36);
    goto LABEL_51;
  }
  v11 = strrchr(v10, 46);
  if ( !v11 )
  {
    sub_64E00(3, "crypto_cert: no filestamp %s", v36);
LABEL_51:
    fclose(v9);
    cinfo = 0;
LABEL_46:
    sub_64E00(3, "crypto_setup: certificate file %s not found or corrupt", v34);
    exit(-1);
  }
  if ( sscanf(v11 + 1, "%u", &v28) != 1 )
  {
    sub_64E00(3, "crypto_cert: invalid filestamp %s", v36);
    fclose(v9);
    goto LABEL_45;
  }
  if ( !PEM_read(v9, &s1, &ptr) )
  {
    error = ERR_get_error(0);
    v26 = (const char *)ERR_error_string(error, 0);
    sub_64E00(3, "crypto_cert: %s", v26);
    fclose(v9);
    cinfo = 0;
    goto LABEL_46;
  }
  fclose(v9);
  free(ptr);
  v12 = s1;
  if ( strcmp(s1, "CERTIFICATE") )
  {
    sub_64E00(5, "crypto_cert: wrong PEM type %s", v12);
    free(s1);
    free(v32);
    cinfo = 0;
    goto LABEL_46;
  }
  free(v12);
  v13 = sub_27C64(v32, v29, v28);
  free(v32);
  if ( !v13 )
  {
LABEL_45:
    cinfo = 0;
    goto LABEL_46;
  }
  v14 = strrchr(s, 10);
  v15 = v29;
  if ( v14 )
    *v14 = 0;
  sub_6C054((int)v39, 0x100u, "%s 0x%x len %lu", v38, *((_DWORD *)v13 + 1), v15);
  sub_42514(0, v39);
  v16 = *((_DWORD *)v13 + 5);
  cinfo = (int)v13;
  dword_B98E8 = v16;
  cert_host = (int)v13;
  dword_B98E4 = EVP_PKEY_size(dword_B98E0);
  if ( (*(_DWORD *)(cinfo + 4) & 8) != 0 )
    crypto_flags |= 0x10u;
  v17 = *(const char **)(cinfo + 48);
  if ( strcmp(v17, *(const char **)(cinfo + 52)) )
  {
    sub_64E00(3, "crypto_setup: certificate %s is not self-signed", v34);
    exit(-1);
  }
  dword_108274 = (int)sub_63D08(v17);
  dword_108270 = bswap32(strlen(*(const char **)(cinfo + 48)));
  sys_hostname = dword_108274;
  v18 = strchr((const char *)dword_108274, 64);
  if ( v18 )
  {
    v27 = v18 + 1;
    sys_groupname = (int)sub_63D08(v18 + 1);
  }
  else
  {
    v27 = 0;
  }
  if ( dword_B98FC )
    sub_6D4DC(name, (unsigned __int8 *)dword_B98FC, 256);
  sub_6C054((int)v34, 0x100u, "ntpkey_iffkey_%s", name);
  iffkey_info = (int)sub_26D98(v34, dword_B98F8, 0);
  if ( iffkey_info )
    crypto_flags |= 0x20u;
  sub_6C054((int)v34, 0x100u, "ntpkey_gqkey_%s", name);
  gqkey_info = (int)sub_26D98(v34, dword_B98F8, 0);
  if ( gqkey_info )
    crypto_flags |= 0x40u;
  sub_6C054((int)v34, 0x100u, "ntpkey_mvkey_%s", name);
  v19 = sub_26D98(v34, dword_B98F8, 0);
  v20 = crypto_flags;
  mvkey_info = (int)v19;
  if ( v19 )
    v20 = crypto_flags | 0x80;
  v21 = *(_DWORD *)(cinfo + 16);
  v22 = v20 | (v21 << 16) | 1;
  crypto_flags = v22;
  v23 = (const char *)OBJ_nid2ln(v21);
  sub_6C054((int)v39, 0x100u, "setup 0x%x host %s %s", v22, name, v23);
  return (char *)sub_42514(0, v39);
}
// B340: using guessed type int __fastcall ERR_get_error(_DWORD);
// B358: using guessed type int __fastcall RAND_load_file(_DWORD, _DWORD);
// B43C: using guessed type int __fastcall OBJ_nid2ln(_DWORD);
// B448: using guessed type int __fastcall RAND_seed(_DWORD, _DWORD);
// B5E4: using guessed type int __fastcall EVP_PKEY_base_id(_DWORD);
// B878: using guessed type int __fastcall PEM_read(_DWORD, _DWORD, _DWORD);
// B950: using guessed type int __fastcall RAND_write_file(_DWORD);
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BAE8: using guessed type int __fastcall EVP_PKEY_size(_DWORD);
// BAF4: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// BD88: using guessed type int RAND_file_name(void);
// BE0C: using guessed type int __fastcall i2d_PublicKey(_DWORD, _DWORD);
// BF2C: using guessed type int __fastcall RAND_status(_DWORD);
// B6018: using guessed type char *keysdir[2];
// B98E0: using guessed type int dword_B98E0;
// B98E4: using guessed type int dword_B98E4;
// B98E8: using guessed type int dword_B98E8;
// B98EC: using guessed type int dword_B98EC;
// B98F0: using guessed type int dword_B98F0;
// B98F4: using guessed type int dword_B98F4;
// B98F8: using guessed type int dword_B98F8;
// B98FC: using guessed type int dword_B98FC;
// B9900: using guessed type int mvkey_info;
// B9904: using guessed type int gqkey_info;
// B9908: using guessed type int iffkey_info;
// B9910: using guessed type int cert_host;
// B9914: using guessed type int cinfo;
// B9918: using guessed type int sys_groupname;
// B991C: using guessed type int sys_hostname;
// B9920: using guessed type int crypto_flags;
// 108268: using guessed type int hostval;
// 10826C: using guessed type int dword_10826C;
// 108270: using guessed type int dword_108270;
// 108274: using guessed type int dword_108274;
// 108278: using guessed type int dword_108278;
// 10827C: using guessed type int dword_10827C;
// 108280: using guessed type int pubkey;
// 108284: using guessed type int dword_108284;
// 108288: using guessed type int dword_108288;
// 10828C: using guessed type int dword_10828C;
// 108290: using guessed type int dword_108290;
// 108294: using guessed type int dword_108294;
// 108298: using guessed type int tai_leap;
// 10829C: using guessed type int dword_10829C;
// 1082A0: using guessed type int dword_1082A0;
// 1082A4: using guessed type int dword_1082A4;
// 1082A8: using guessed type int dword_1082A8;
// 1082AC: using guessed type int dword_1082AC;

//----- (0002BCA8) --------------------------------------------------------
void *__fastcall sub_2BCA8(int a1, const char *a2)
{
  void *result; // r0

  result = (void *)(a1 - 1);
  switch ( (unsigned int)result )
  {
    case 0u:
      if ( dword_B98F4 )
        free((void *)dword_B98F4);
      result = sub_63D08(a2);
      dword_B98F4 = (int)result;
      break;
    case 1u:
      if ( dword_B98FC )
        free((void *)dword_B98FC);
      result = sub_63D08(a2);
      dword_B98FC = (int)result;
      break;
    case 3u:
      if ( dword_B98F0 )
        free((void *)dword_B98F0);
      result = sub_63D08(a2);
      dword_B98F0 = (int)result;
      break;
    case 7u:
      if ( dword_B98F8 )
        free((void *)dword_B98F8);
      result = sub_63D08(a2);
      dword_B98F8 = (int)result;
      break;
    case 8u:
      result = (void *)OBJ_sn2nid(a2);
      if ( result )
        crypto_nid = (int)result;
      else
        result = sub_64E00(3, "crypto_config: invalid digest name %s", a2);
      break;
    default:
      return result;
  }
  return result;
}
// BCBC: using guessed type int __fastcall OBJ_sn2nid(_DWORD);
// B6AE0: using guessed type int crypto_nid;
// B98F0: using guessed type int dword_B98F0;
// B98F4: using guessed type int dword_B98F4;
// B98F8: using guessed type int dword_B98F8;
// B98FC: using guessed type int dword_B98FC;

//----- (0002BE54) --------------------------------------------------------
void __fastcall sub_2BE54(int a1, unsigned int a2)
{
  FILE *v3; // r0
  int v5; // r7
  _BOOL4 v6; // r0
  size_t v7; // r9
  size_t v8; // r9
  size_t v9; // r10
  unsigned __int8 *v10; // r11
  char *v11; // r7
  int v12; // r0
  unsigned int v13; // r2
  unsigned int v14; // r9
  __pid_t v15; // r0
  int v16; // r3
  int v17; // r5
  char v18; // r3
  int v19; // r0
  unsigned __int16 v20; // r3
  int v21; // r0
  unsigned int v22; // lr
  int v23; // r0
  int v24; // r0
  char v25; // r3
  char *v26; // r5
  __pid_t v27; // r0
  int v28; // [sp+8h] [bp-9Ch]
  size_t v29; // [sp+10h] [bp-94h]
  int v30; // [sp+14h] [bp-90h]
  int v31; // [sp+14h] [bp-90h]
  int v32; // [sp+14h] [bp-90h]
  int v33; // [sp+14h] [bp-90h]
  int v34; // [sp+14h] [bp-90h]
  time_t v35; // [sp+18h] [bp-8Ch] BYREF
  unsigned __int16 v36; // [sp+1Ch] [bp-88h] BYREF
  unsigned __int8 v37; // [sp+1Eh] [bp-86h]
  char v38; // [sp+1Fh] [bp-85h]
  char v39; // [sp+20h] [bp-84h]
  char v40; // [sp+21h] [bp-83h]
  char v41; // [sp+22h] [bp-82h]
  unsigned __int16 v42; // [sp+24h] [bp-80h] BYREF
  int v43; // [sp+28h] [bp-7Ch]
  char v44; // [sp+2Ch] [bp-78h]
  char v45[16]; // [sp+30h] [bp-74h] BYREF
  int v46; // [sp+40h] [bp-64h]
  unsigned int v47; // [sp+44h] [bp-60h]

  if ( *(char *)(a1 + 21) >= 0 )
  {
    v3 = *(FILE **)a1;
    if ( v3 )
    {
      fclose(v3);
      *(_DWORD *)a1 = 0;
    }
    return;
  }
  switch ( *(_BYTE *)(a1 + 20) )
  {
    case 1:
      v5 = *(_DWORD *)(a1 + 12);
      v6 = v5 != getpid();
      if ( !*(_DWORD *)a1 )
        v6 = 1;
      if ( v6 )
        goto LABEL_16;
      return;
    case 2:
    case 3:
    case 4:
    case 5:
      if ( a2 < *(_DWORD *)(a1 + 12) || a2 >= *(_DWORD *)(a1 + 16) )
        goto LABEL_16;
      goto LABEL_11;
    case 6:
      if ( *(_DWORD *)(a1 + 12) > (unsigned int)current_time || (unsigned int)current_time >= *(_DWORD *)(a1 + 16) )
        goto LABEL_16;
LABEL_11:
      if ( *(_DWORD *)a1 )
        return;
LABEL_16:
      v35 = time(0);
      v7 = strlen(*(const char **)(a1 + 4));
      v8 = v7 + strlen(*(const char **)(a1 + 8));
      v9 = v8 + 65;
      v10 = (unsigned __int8 *)sub_63BA4(0, v8 + 65, 0, 0);
      v11 = (char *)sub_63BA4(0, v8 + 65, 0, 0);
      v29 = v8 + 64;
      sub_6C054((int)v10, v8 + 65, (unsigned __int8 *)"%s%s", *(const char **)(a1 + 4), *(const char **)(a1 + 8));
      v12 = sub_6D4DC(v11, v10, v8 + 65);
      v11[v8 + 64] = 0;
      v13 = *(unsigned __int8 *)(a1 + 20);
      v14 = v8 + 65 - v12;
      if ( v13 == 4 )
      {
        v34 = (int)&v11[v12];
        sub_66750(&v42, a2, &v35);
        sub_6C054(v34, v14, "%c%04d%02d", 46, v42, (unsigned __int8)v43);
        v44 = 0;
        HIWORD(v43) = 0;
        BYTE1(v43) = 1;
        v24 = sub_66830(&v42);
        v25 = v43;
        *(_DWORD *)(a1 + 12) = v24;
        LOBYTE(v43) = v25 + 1;
        *(_DWORD *)(a1 + 16) = sub_66830(&v42);
        v16 = (unsigned __int8)v11[v29];
        goto LABEL_22;
      }
      if ( v13 > 4 )
      {
        if ( v13 == 6 )
        {
          v22 = (_DWORD)&off_15180 * (current_time / 0x15180u);
          *(_DWORD *)(a1 + 12) = v22;
          *(_DWORD *)(a1 + 16) = v22 + 86400;
          sub_6C054((int)&v11[v12], v9 - v12, "%ca%08ld", 46, v22);
          v16 = (unsigned __int8)v11[v29];
          goto LABEL_22;
        }
        if ( v13 < 6 )
        {
          v31 = (int)&v11[v12];
          sub_66750(&v42, a2, &v35);
          sub_6C054(v31, v14, "%c%04d", 46, v42);
          v44 = 0;
          v43 = 257;
          v19 = sub_66830(&v42);
          v20 = v42;
          *(_DWORD *)(a1 + 12) = v19;
          v42 = v20 + 1;
          *(_DWORD *)(a1 + 16) = sub_66830(&v42);
          v16 = (unsigned __int8)v11[v29];
          goto LABEL_22;
        }
        if ( v13 == 255 )
          goto LABEL_33;
LABEL_41:
        sub_64E00(
          3,
          "unsupported file generations type %d for \"%s\" - reverting to FILEGEN_NONE",
          v13,
          (const char *)v10);
        *(_BYTE *)(a1 + 20) = -1;
        if ( !v11[v29] )
          goto LABEL_33;
        goto LABEL_42;
      }
      if ( v13 == 2 )
      {
        v33 = (int)&v11[v12];
        sub_66750(&v42, a2, &v35);
        sub_6C054(v33, v14, "%c%04d%02d%02d", 46, v42, (unsigned __int8)v43, BYTE1(v43));
        HIWORD(v43) = 0;
        v44 = 0;
        v23 = sub_66830(&v42);
        *(_DWORD *)(a1 + 12) = v23;
        *(_DWORD *)(a1 + 16) = v23 + 86400;
        v16 = (unsigned __int8)v11[v29];
        goto LABEL_22;
      }
      if ( v13 > 2 )
      {
        v32 = (int)&v11[v12];
        sub_66CC4((int)&v36, a2, &v35);
        sub_6C054(v32, v14, "%c%04dw%02d", 46, v36, v37);
        v38 = 1;
        v41 = 0;
        v40 = 0;
        v39 = 0;
        v21 = sub_66DC4((unsigned __int8 *)&v36);
        *(_DWORD *)(a1 + 12) = v21;
        *(_DWORD *)(a1 + 16) = v21 + 604800;
        v16 = (unsigned __int8)v11[v29];
        goto LABEL_22;
      }
      if ( v13 != 1 )
        goto LABEL_41;
      v30 = (int)&v11[v12];
      v15 = getpid();
      *(_DWORD *)(a1 + 12) = v15;
      *(_DWORD *)(a1 + 16) = 0;
      sub_6C054(v30, v14, "%c#%ld", 46, v15);
      v16 = (unsigned __int8)v11[v29];
LABEL_22:
      if ( !v16 )
        goto LABEL_23;
LABEL_42:
      v11[v29] = 0;
      sub_64E00(3, "logfile name truncated: \"%s\"", v11);
LABEL_23:
      if ( *(unsigned __int8 *)(a1 + 20) != 255 )
      {
        if ( _xstat64(3, v10, v45) )
        {
          if ( *_errno_location() != 2 )
            sub_64E00(3, "stat(%s) failed: %m", (const char *)v10);
        }
        else if ( (v46 & 0xF000) == 0x8000 )
        {
          if ( v47 <= 1 )
          {
            v26 = (char *)sub_63BA4(0, v9, 0, 0);
            v27 = getpid();
            v28 = dword_B9924++;
            sub_6C054((int)v26, v9, "%s%c%dC%lu", (const char *)v10, 46, v27, v28);
            if ( rename((const char *)v10, v26) )
              sub_64E00(3, "couldn't save %s: %m", (const char *)v10);
            free(v26);
          }
          else if ( unlink((const char *)v10) )
          {
            sub_64E00(3, "couldn't unlink %s: %m", (const char *)v10);
          }
        }
        else
        {
          sub_64E00(3, "expected regular file for %s (found mode 0%lo)", (const char *)v10, v46);
        }
      }
LABEL_33:
      v17 = fopen64(v11, &off_99960);
      if ( v17 )
      {
        if ( *(_DWORD *)a1 )
          fclose(*(FILE **)a1);
        v18 = *(_BYTE *)(a1 + 21);
        *(_DWORD *)a1 = v17;
        if ( (v18 & 1) != 0 && link(v11, (const char *)v10) && *_errno_location() != 17 )
          sub_64E00(3, "can't link(%s, %s): %m", v11, (const char *)v10);
      }
      else if ( *_errno_location() != 2 )
      {
        sub_64E00(3, "can't open %s: %m", v11);
      }
      free(v10);
      free(v11);
      return;
    default:
      if ( !*(_DWORD *)a1 )
        goto LABEL_16;
      return;
  }
}
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type char *off_15180;
// 99960: using guessed type _UNKNOWN *off_99960;
// B9924: using guessed type int dword_B9924;
// 108CA4: using guessed type int current_time;

//----- (0002C570) --------------------------------------------------------
void __fastcall sub_2C570(int a1, char *s1, const char *a3, int a4, int a5)
{
  void *v7; // r8
  bool v10; // zf
  char *v11; // r3
  int v12; // r2
  bool v13; // zf
  int v14; // r11
  void *v15; // r5
  unsigned int v16; // [sp+Ch] [bp-10h] BYREF

  v7 = *(void **)(a1 + 4);
  if ( strcmp(s1, (const char *)v7)
    || strcmp(a3, *(const char **)(a1 + 8))
    || *(unsigned __int8 *)(a1 + 20) != a4
    || *(unsigned __int8 *)(a1 + 21) != a5 )
  {
    v10 = a3 == 0;
    if ( a3 )
      v10 = *s1 == 0;
    if ( !v10 )
    {
      v11 = (char *)a3;
      while ( 1 )
      {
        if ( *v11 == 46 && v11[1] == 46 )
        {
          v12 = (unsigned __int8)v11[2];
          v13 = v12 == 47;
          if ( v12 != 47 )
            v13 = v12 == 0;
          if ( v13 )
            break;
        }
        v11 = strchr(v11, 47);
        if ( !v11 )
        {
          if ( *(_DWORD *)a1 )
          {
            v14 = 1;
            fclose(*(FILE **)a1);
            v7 = *(void **)(a1 + 4);
            *(_DWORD *)a1 = 0;
          }
          else
          {
            v14 = 0;
          }
          if ( strcmp((const char *)v7, s1) )
          {
            free(v7);
            *(_DWORD *)(a1 + 4) = sub_63D08(s1);
          }
          v15 = *(void **)(a1 + 8);
          if ( strcmp((const char *)v15, a3) )
          {
            free(v15);
            *(_DWORD *)(a1 + 8) = sub_63D08(a3);
          }
          *(_BYTE *)(a1 + 20) = a4;
          *(_BYTE *)(a1 + 21) = a5;
          if ( v14 )
          {
            sub_5F724((int *)&v16);
            sub_2BE54(a1, v16);
          }
          return;
        }
      }
    }
  }
}

//----- (0002C718) --------------------------------------------------------
int __fastcall sub_2C718(char *s1)
{
  int v1; // r4
  const char *v2; // r1

  v1 = dword_B9928;
  if ( !dword_B9928 )
    return v1;
  v2 = *(const char **)dword_B9928;
  if ( s1 != *(char **)dword_B9928 )
  {
    do
    {
      if ( !strcmp(s1, v2) )
        break;
      v1 = *(_DWORD *)(v1 + 8);
      if ( !v1 )
        return v1;
      v2 = *(const char **)v1;
    }
    while ( *(char **)v1 != s1 );
  }
  return *(_DWORD *)(v1 + 4);
}
// B9928: using guessed type int dword_B9928;

//----- (0002C7BC) --------------------------------------------------------
const char *__fastcall sub_2C7BC(const char *a1, const char *a2, int a3)
{
  int v5; // r4
  const char *result; // r0
  const char **v7; // r3
  int *v8; // r4
  _DWORD *v9; // r3
  const char *v10; // r0
  const char **v11; // r5
  int v12; // r3

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = sub_63D08(a1);
  *(_DWORD *)(a3 + 8) = sub_63D08(a2);
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  v5 = dword_B9928;
  *(_WORD *)(a3 + 20) = 258;
  if ( v5 )
  {
    result = *(const char **)v5;
    if ( a2 != *(const char **)v5 )
    {
      do
      {
        result = (const char *)strcmp(result, a2);
        if ( !result )
          break;
        v7 = *(const char ***)(v5 + 8);
        if ( !v7 )
        {
          v8 = (int *)(v5 + 8);
          goto LABEL_9;
        }
        result = *v7;
        v5 = *(_DWORD *)(v5 + 8);
      }
      while ( *v7 != a2 );
    }
    *(_DWORD *)(v5 + 4) = a3;
  }
  else
  {
    v8 = &dword_B9928;
LABEL_9:
    v9 = sub_63BA4(0, 0xCu, 0, 0);
    *v8 = (int)v9;
    v10 = a2;
    v9[2] = 0;
    v11 = (const char **)*v8;
    result = (const char *)sub_63D08(v10);
    v12 = *v8;
    *v11 = result;
    *(_DWORD *)(v12 + 4) = a3;
  }
  return result;
}
// B9928: using guessed type int dword_B9928;

//----- (0002C8D8) --------------------------------------------------------
void sub_2C8D8()
{
  int i; // r4

  for ( i = dword_B9928; i; i = *(_DWORD *)(i + 8) )
    sub_2C570(
      *(_DWORD *)(i + 4),
      statsdir,
      *(const char **)(*(_DWORD *)(i + 4) + 8),
      *(unsigned __int8 *)(*(_DWORD *)(i + 4) + 20),
      *(unsigned __int8 *)(*(_DWORD *)(i + 4) + 21));
}
// B9928: using guessed type int dword_B9928;

//----- (0002C96C) --------------------------------------------------------
int __fastcall sub_2C96C(int result)
{
  __int64 v1; // r2

  *(_DWORD *)(result + 64) = -1;
  *(_DWORD *)(result + 68) = -1;
  v1 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 56) = v1;
  *(_QWORD *)(result + 48) = v1;
  *(_QWORD *)(result + 40) = v1;
  return result;
}

//----- (0002C9CC) --------------------------------------------------------
unsigned __int8 *__fastcall sub_2C9CC(unsigned __int8 *a1)
{
  const unsigned __int16 *v2; // r1
  unsigned __int8 *v3; // r2
  unsigned __int8 *result; // r0

  v2 = *_ctype_b_loc();
  v3 = a1;
  do
    result = v3++;
  while ( (v2[*result] & 0x2000) != 0 );
  return result;
}

//----- (0002CA3C) --------------------------------------------------------
unsigned int __fastcall sub_2CA3C(_BYTE *a1, _BYTE *a2)
{
  unsigned int result; // r0
  int v3; // r4

  if ( a2 == a1 )
    return 1;
  v3 = (unsigned __int8)*a2;
  result = v3 != 35;
  if ( !*a2 )
    result = 0;
  if ( result )
    return (((*_ctype_b_loc())[v3] ^ 0x2000u) >> 13) & 1;
  return result;
}

//----- (0002CAC4) --------------------------------------------------------
int __fastcall sub_2CAC4(int a1, int a2)
{
  __int16 v2; // r8
  _DWORD *v4; // r6
  size_t v5; // r2
  __int16 v6; // r3
  int v7; // r3
  __int16 v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  bool v13; // cc

  v4 = (_DWORD *)a2;
  v5 = *(unsigned __int16 *)(a1 + 32);
  v6 = _stack_chk_guard;
  if ( *(_WORD *)(a1 + 32) )
  {
    v13 = v5 > 9;
    if ( v5 <= 9 )
      v2 = v5 + 1;
    else
      v6 = *(_WORD *)(a1 + 236);
    if ( v5 <= 9 )
      v5 *= 16;
    else
      LOWORD(a2) = 9;
    if ( v13 )
    {
      v2 = 10;
      v5 = 144;
      *(_WORD *)(a1 + 32) = a2;
      *(_WORD *)(a1 + 34) = v6;
    }
  }
  else
  {
    v7 = *(__int16 *)(a2 + 12);
    v2 = 1;
    if ( v7 < 0 )
      v8 = v7 + 1;
    else
      v8 = v7 - 1;
    *(_WORD *)(a1 + 34) = v8;
  }
  memmove((void *)(a1 + 96), (const void *)(a1 + 80), v5);
  v9 = v4[1];
  v10 = v4[2];
  v11 = v4[3];
  *(_DWORD *)(a1 + 80) = *v4;
  *(_DWORD *)(a1 + 84) = v9;
  *(_DWORD *)(a1 + 88) = v10;
  *(_DWORD *)(a1 + 92) = v11;
  *(_WORD *)(a1 + 32) = v2;
  sub_2C96C(a1);
  return 1;
}
// 2CB30: variable 'v2' is possibly undefined

//----- (0002CB8C) --------------------------------------------------------
_QWORD *__fastcall sub_2CB8C(int a1, unsigned __int64 *a2)
{
  int v3; // r1
  unsigned __int64 *v5; // r6
  int v6; // r4
  int v7; // r0
  int v8; // r3
  int v9; // r1
  int v10; // r6
  int v11; // r4
  __int16 v12; // r0
  int v13; // r4
  int v14; // r1
  int v15; // r2
  int v16; // r12
  __int64 v17; // r0
  _QWORD *result; // r0
  __int16 v19; // r2
  __int64 v20; // r2
  __int16 v21; // r1
  __int16 v22; // r3
  __int64 v23; // [sp+0h] [bp-10h] BYREF

  v3 = *(unsigned __int16 *)(a1 + 32);
  if ( *(_WORD *)(a1 + 32) )
  {
    v5 = (unsigned __int64 *)(a1 + 80);
    v6 = 0;
    while ( 1 )
    {
      v7 = sub_6DAF4(a2, v5);
      v8 = *(unsigned __int16 *)(a1 + 32);
      if ( v7 >= 0 )
        break;
      ++v6;
      v5 += 2;
      if ( v8 == v6 )
      {
        v9 = v6 - 1;
        goto LABEL_11;
      }
    }
    v9 = v6 - 1;
    if ( v8 > v6 )
    {
      v10 = a1 + 48;
      v11 = a1 + 16 * v6;
      v12 = *(_WORD *)(v11 + 92);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(v11 + 80);
      *(_WORD *)(a1 + 36) = v12;
      if ( v9 == -1 )
        goto LABEL_12;
      goto LABEL_7;
    }
LABEL_11:
    v19 = *(_WORD *)(a1 + 34);
    v10 = a1 + 48;
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 0;
    *(_WORD *)(a1 + 36) = v19;
    if ( v9 == -1 )
      goto LABEL_12;
LABEL_7:
    v13 = 16 * v9;
    v14 = a1 + 16 * v9;
    v15 = *(__int16 *)(v14 + 92);
    v16 = dword_B9930;
    *(_WORD *)(a1 + 38) = v15;
    *(_BYTE *)(a1 + 72) = *(_BYTE *)(v14 + 94);
    v17 = *(_QWORD *)(v14 + 80);
    *(_QWORD *)(a1 + 48) = v17;
    if ( v16 )
    {
      *(_QWORD *)(a1 + 40) = v17;
    }
    else
    {
      sub_6DC24(&v23, (_QWORD *)v10, v15 - *(__int16 *)(a1 + 36));
      *(_QWORD *)(a1 + 40) = v23;
    }
    result = sub_6DD38(&v23, (_QWORD *)v10, *(_DWORD *)(a1 + v13 + 88));
    *(_QWORD *)(a1 + 56) = v23;
  }
  else
  {
    v22 = *(_WORD *)(a1 + 34);
    v10 = a1 + 48;
    *(_DWORD *)(a1 + 64) = v3;
    *(_DWORD *)(a1 + 68) = v3;
    *(_WORD *)(a1 + 36) = v22;
LABEL_12:
    *(_DWORD *)v10 = -1;
    *(_DWORD *)(v10 + 4) = -1;
    v20 = *(_QWORD *)(a1 + 48);
    v21 = *(_WORD *)(a1 + 36);
    *(_BYTE *)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 56) = v20;
    *(_QWORD *)(a1 + 40) = v20;
    *(_WORD *)(a1 + 38) = v21;
    return 0;
  }
  return result;
}
// B9930: using guessed type int dword_B9930;

//----- (0002CD30) --------------------------------------------------------
_BYTE *__fastcall sub_2CD30(int *a1)
{
  _BYTE *v2; // r5
  int v3; // r4
  int v4; // r3
  unsigned __int16 v6; // [sp+18h] [bp-10h] BYREF
  unsigned __int8 v7; // [sp+1Ch] [bp-Ch]
  unsigned __int8 v8; // [sp+1Dh] [bp-Bh]
  unsigned __int8 v9; // [sp+1Eh] [bp-Ah]
  unsigned __int8 v10; // [sp+1Fh] [bp-9h]
  unsigned __int8 v11; // [sp+20h] [bp-8h]

  v2 = &lib_stringbuf[128 * lib_nextbuf];
  v3 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v2, 0, 0x80u);
  v4 = a1[1];
  lib_nextbuf = v3;
  if ( v4 < 0 || sub_666D8(&v6, a1) < 0 )
    sub_6C054((int)v2, 0x80u, (unsigned __int8 *)"%s", "9999-12-31T23:59:59Z");
  else
    sub_6C054((int)v2, 0x80u, "%04d-%02d-%02dT%02d:%02d:%02dZ", v6, v7, v8, v9, v10, v11);
  return v2;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0002CE3C) --------------------------------------------------------
int *__fastcall sub_2CE3C(int *result, unsigned __int8 *a2)
{
  int *v2; // r8
  size_t v4; // r6
  int v5; // r4
  int v6; // t1
  bool v7; // zf
  char *v8; // r2
  int v9; // t1
  bool v10; // zf
  char src[40]; // [sp+4h] [bp-28h] BYREF

  v2 = result;
  v4 = 0;
  while ( 1 )
  {
    v6 = *a2++;
    v5 = v6;
    v7 = v6 == 35;
    if ( v6 != 35 )
      v7 = v5 == 0;
    if ( v7 )
      break;
    while ( 1 )
    {
      result = (int *)_ctype_b_loc();
      if ( (*(_WORD *)(*result + 2 * v5) & 0x800) == 0 )
        break;
      v8 = &src[v4 + 36];
      v4 = (v4 + 1) & 0x1F;
      *(v8 - 36) = v5;
      if ( v4 )
        break;
      result = (int *)sub_782A0(v2, src, 0x20u);
      v9 = *a2++;
      v5 = v9;
      v10 = v9 == 35;
      if ( v9 != 35 )
        v10 = v5 == 0;
      if ( v10 )
        goto LABEL_11;
    }
  }
LABEL_11:
  if ( v4 )
    return (int *)sub_782A0(v2, src, v4);
  return result;
}

//----- (0002CF08) --------------------------------------------------------
int __fastcall sub_2CF08(int a1, int a2, unsigned __int64 *a3)
{
  int result; // r0
  unsigned __int64 *v7; // r5
  int v8; // r4
  int v9; // r3
  int v10; // r1
  int v11; // r4

  result = *(unsigned __int16 *)(a2 + 32);
  if ( !*(_WORD *)(a2 + 32) )
  {
    *(_DWORD *)a1 = result;
    *(_DWORD *)(a1 + 4) = result;
    *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 34);
    goto LABEL_10;
  }
  v7 = (unsigned __int64 *)(a2 + 80);
  v8 = 0;
  do
  {
    result = sub_6DAF4(a3, v7);
    v9 = *(unsigned __int16 *)(a2 + 32);
    if ( result >= 0 )
    {
      v10 = v8 - 1;
      if ( v9 <= v8 )
        goto LABEL_9;
      v11 = a2 + 16 * v8;
      result = *(unsigned __int16 *)(v11 + 92);
      *(_QWORD *)a1 = *(_QWORD *)(v11 + 80);
      *(_WORD *)(a1 + 16) = result;
      if ( v10 == -1 )
        goto LABEL_10;
      goto LABEL_7;
    }
    ++v8;
    v7 += 2;
  }
  while ( v9 != v8 );
  v10 = v8 - 1;
LABEL_9:
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 34);
  if ( v10 != -1 )
  {
LABEL_7:
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 16 * v10 + 80);
    return result;
  }
LABEL_10:
  *(_DWORD *)(a1 + 8) = -1;
  *(_DWORD *)(a1 + 12) = -1;
  return result;
}

//----- (0002D014) --------------------------------------------------------
_BYTE *__fastcall sub_2D014(int (__fastcall *a1)(int), int a2, _BYTE *a3)
{
  _BYTE *v6; // r4
  int v7; // r9
  int i; // r0
  int v9; // r5
  const unsigned __int16 *v10; // r1
  _BYTE *v11; // r2
  int v12; // t1

  v6 = a3;
  v7 = 50;
  for ( i = a1(a2); ; i = a1(a2) )
  {
    if ( i == -1 )
    {
      v9 = 0;
      goto LABEL_8;
    }
    if ( i == 10 )
      break;
    if ( v7 != 1 )
    {
      --v7;
      *v6++ = i;
    }
  }
  v9 = 1;
LABEL_8:
  if ( a3 != v6 )
  {
    v10 = *_ctype_b_loc();
    while ( 1 )
    {
      v11 = v6;
      v12 = (unsigned __int8)*--v6;
      if ( (v10[v12] & 0x2000) == 0 )
        break;
      if ( a3 == v6 )
        goto LABEL_15;
    }
    if ( v11 != a3 )
      v9 |= 1u;
    v6 = v11;
  }
LABEL_15:
  *v6 = 0;
  if ( v9 )
    return a3;
  else
    return 0;
}

//----- (0002D0F4) --------------------------------------------------------
const void *__fastcall sub_2D0F4(int a1)
{
  const void *result; // r0
  void *v3; // r9

  result = (const void *)dword_B9B18;
  if ( (_UNKNOWN *)dword_B9B18 == &unk_B9938 )
  {
    v3 = &unk_B9A28;
  }
  else if ( (_UNKNOWN *)dword_B9B18 == &unk_B9A28 )
  {
    v3 = &unk_B9938;
  }
  else
  {
    v3 = &unk_B9A28;
    sub_2C96C((int)&unk_B9938);
    sub_2C96C((int)&unk_B9A28);
    result = &unk_B9938;
    dword_B9B18 = (int)&unk_B9938;
  }
  if ( a1 )
  {
    memcpy(v3, result, 0xF0u);
    return v3;
  }
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B9B18: using guessed type int dword_B9B18;

//----- (0002D1A4) --------------------------------------------------------
int __fastcall sub_2D1A4(void *a1)
{
  bool v2; // zf
  int result; // r0

  v2 = a1 == &unk_B9938;
  if ( a1 != &unk_B9938 )
    v2 = a1 == &unk_B9A28;
  if ( v2 )
  {
    result = 1;
    dword_B9B18 = (int)a1;
  }
  else
  {
    result = dword_B9B18;
  }
  if ( !v2 )
    return result == (_DWORD)a1;
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B9B18: using guessed type int dword_B9B18;

//----- (0002D220) --------------------------------------------------------
int __fastcall sub_2D220(int a1)
{
  int v1; // r5
  bool v2; // zf

  v1 = dword_B9930;
  if ( a1 >= 0 )
  {
    dword_B9930 = a1 != 0;
    if ( (a1 != 0) != v1 )
    {
      v2 = dword_B9B18 == (_DWORD)&unk_B9A28;
      if ( (_UNKNOWN *)dword_B9B18 != &unk_B9A28 )
        v2 = dword_B9B18 == (_DWORD)&unk_B9938;
      if ( v2 )
        sub_2C96C(dword_B9B18);
    }
  }
  return v1;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B9930: using guessed type int dword_B9930;
// B9B18: using guessed type int dword_B9B18;

//----- (0002D2B0) --------------------------------------------------------
int __fastcall sub_2D2B0(_DWORD *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  memset(a1 + 4, 0, 0x40u);
  return sub_2C96C((int)a1);
}

//----- (0002D320) --------------------------------------------------------
int __fastcall sub_2D320(int a1, int (__fastcall *a2)(int), int a3, int a4)
{
  int v8; // r4
  unsigned __int8 *v9; // r4
  unsigned __int8 *v10; // r11
  int v11; // r4
  int v12; // r3
  unsigned __int8 *v13; // r4
  unsigned __int8 *v14; // r1
  int v16; // r0
  unsigned __int8 *v17; // r4
  unsigned __int8 *v18; // r1
  unsigned __int64 v19; // [sp+8h] [bp-84h] BYREF
  unsigned __int8 *v20; // [sp+14h] [bp-78h] BYREF
  unsigned __int64 v21; // [sp+18h] [bp-74h] BYREF
  unsigned __int64 v22; // [sp+20h] [bp-6Ch] BYREF
  unsigned __int16 v23[6]; // [sp+28h] [bp-64h] BYREF
  unsigned __int16 v24; // [sp+34h] [bp-58h] BYREF
  char v25; // [sp+38h] [bp-54h]
  char v26; // [sp+39h] [bp-53h]
  __int16 v27; // [sp+3Ah] [bp-52h]
  char v28; // [sp+3Ch] [bp-50h]
  unsigned __int64 v29; // [sp+40h] [bp-4Ch] BYREF
  int v30; // [sp+48h] [bp-44h]
  __int16 v31; // [sp+4Ch] [bp-40h]
  char v32; // [sp+4Eh] [bp-3Eh]
  unsigned __int8 v33; // [sp+50h] [bp-3Ch] BYREF
  char v34; // [sp+51h] [bp-3Bh]
  unsigned __int8 v35[50]; // [sp+52h] [bp-3Ah] BYREF

  sub_2D2B0((_DWORD *)a1);
  if ( a4 && sub_6568C((int)v23) )
  {
    v23[0] -= 10;
    sub_667B4(&v19, v23);
    v22 = v19;
  }
  else
  {
    v22 = 0;
  }
  while ( sub_2D014(a2, a3, &v33) )
  {
    v8 = v33;
    if ( v33 == 35 )
    {
      if ( v34 == 64 )
      {
        v17 = sub_2C9CC(v35);
        sub_6D854((__int64 *)&v19, v17, &v20, 10);
        v18 = v20;
        *(_QWORD *)(a1 + 24) = v19;
        if ( sub_2CA3C(v17, v18) )
          goto LABEL_16;
        *(_DWORD *)a1 = *(_DWORD *)(a1 + 24);
      }
      else if ( v34 == 36 )
      {
        v13 = sub_2C9CC(v35);
        sub_6D854((__int64 *)&v19, v13, &v20, 10);
        v14 = v20;
        *(_QWORD *)(a1 + 16) = v19;
        if ( sub_2CA3C(v13, v14) )
        {
LABEL_16:
          *_errno_location() = 84;
          sub_2D2B0((_DWORD *)a1);
          return 0;
        }
      }
    }
    else if ( ((*_ctype_b_loc())[v8] & 0x800) != 0 )
    {
      sub_6D854((__int64 *)&v19, &v33, &v20, 10);
      v9 = v20;
      v21 = v19;
      if ( sub_2CA3C(&v33, v20) )
        goto LABEL_16;
      v10 = sub_2C9CC(v9);
      v11 = strtol((const char *)v10, (char **)&v20, 10);
      if ( sub_2CA3C(v10, v20) || (unsigned int)(v11 + 0x8000) >= 0x10000 )
        goto LABEL_16;
      if ( sub_6DAF4(&v21, &v22) < 0 )
      {
        *(_WORD *)(a1 + 34) = v11;
        goto LABEL_12;
      }
      if ( *(_WORD *)(a1 + 32) )
      {
        v16 = sub_6DAF4(&v21, (unsigned __int64 *)(a1 + 80));
        if ( !v16 )
        {
          if ( v11 != *(__int16 *)(a1 + 92) )
            goto LABEL_32;
          goto LABEL_12;
        }
        if ( v16 < 0 )
        {
LABEL_32:
          *_errno_location() = 34;
          goto LABEL_26;
        }
      }
      sub_666D8(&v24, (int *)&v21);
      if ( v26 != 1 || v27 || v28 )
      {
        *_errno_location() = 22;
LABEL_26:
        sub_2D2B0((_DWORD *)a1);
        return 0;
      }
      --v25;
      sub_667B4(&v19, &v24);
      v31 = v11;
      v32 = 0;
      v30 = v21 - v19;
      v29 = v21;
      if ( !sub_2CAC4(a1, (int)&v29) )
        goto LABEL_26;
LABEL_12:
      v12 = v21;
      *(_WORD *)(a1 + 8) = v11;
      *(_DWORD *)(a1 + 4) = v12;
    }
  }
  return 1;
}

//----- (0002D664) --------------------------------------------------------
int __fastcall sub_2D664(int a1, int (*a2)(int, const char *, ...), int a3)
{
  int result; // r0
  int v7; // r3
  int v8; // r5
  int v9; // r4
  __int64 v10; // r2
  __int64 v11; // [sp+28h] [bp-34h] BYREF
  int v12[3]; // [sp+30h] [bp-2Ch] BYREF
  unsigned __int16 v13; // [sp+3Ch] [bp-20h] BYREF
  unsigned __int8 v14; // [sp+40h] [bp-1Ch]
  unsigned __int8 v15; // [sp+41h] [bp-1Bh]
  unsigned __int16 v16; // [sp+48h] [bp-14h] BYREF
  unsigned __int8 v17; // [sp+4Ch] [bp-10h]
  unsigned __int8 v18; // [sp+4Dh] [bp-Fh]

  sub_666D8(&v16, (int *)(a1 + 24));
  result = a2(a3, "leap table (%u entries) expires at %04u-%02u-%02u:\n", *(unsigned __int16 *)(a1 + 32), v16, v17, v18);
  v7 = *(unsigned __int16 *)(a1 + 32);
  if ( *(_WORD *)(a1 + 32) )
  {
    v8 = v7 - 1;
    v9 = a1 + 16 * v7;
    do
    {
      v10 = *(_QWORD *)(v9 + 64);
      --v8;
      v9 -= 16;
      *(_QWORD *)v12 = v10;
      sub_666D8(&v16, v12);
      sub_6DD38(&v11, v12, *(_DWORD *)(v9 + 88));
      *(_QWORD *)v12 = v11;
      sub_666D8(&v13, v12);
      result = a2(
                 a3,
                 "%04u-%02u-%02u [%c] (%04u-%02u-%02u) - %d\n",
                 v16,
                 v17,
                 v18,
                 (unsigned __int8)asc_95648[*(_BYTE *)(v9 + 94) != 0],
                 v13,
                 v14,
                 v15,
                 *(__int16 *)(v9 + 92));
    }
    while ( v8 != -1 );
  }
  return result;
}

//----- (0002D7D0) --------------------------------------------------------
int __fastcall sub_2D7D0(unsigned __int64 *a1, int a2, time_t *a3)
{
  unsigned int v4; // r7
  unsigned __int64 *v5; // r10
  int v6; // r9
  unsigned __int64 v7; // r2
  unsigned __int64 v8; // r4
  unsigned int v9; // r3
  __int16 v10; // r1
  __int16 v11; // r0
  __int16 v12; // r0
  _BOOL4 v13; // r1
  _BOOL4 v14; // r0
  int v15; // r2
  _BOOL4 v16; // r7
  int v17; // r7
  char v18; // r3
  int v20; // r12
  int v21; // r3
  int v22; // r2
  unsigned __int64 v23; // [sp+0h] [bp-2Ch] BYREF
  unsigned __int64 v24; // [sp+8h] [bp-24h] BYREF
  unsigned __int64 v25; // [sp+10h] [bp-1Ch] BYREF
  unsigned __int64 v26; // [sp+18h] [bp-14h] BYREF

  v4 = a2;
  sub_658E8(&v23, a2, a3);
  v24 = v23;
  v5 = (unsigned __int64 *)sub_2D0F4(0);
  memset(a1, 0, 0x20u);
  if ( sub_6DAF4(&v24, v5 + 8) < 0 )
    goto LABEL_22;
  if ( sub_6DAF4(&v24, v5 + 5) < 0 )
  {
    v6 = 0;
    goto LABEL_5;
  }
  sub_6DC24(&v23, v5 + 5, 3);
  v25 = v23;
  if ( sub_6DAF4(&v24, &v25) < 0 )
  {
    v20 = *((_DWORD *)v5 + 10);
    v21 = *((_DWORD *)v5 + 13);
    LODWORD(v25) = *((_DWORD *)v5 + 12);
    v22 = (__int16)(v25 - v20);
    HIDWORD(v25) = v21;
    *((_WORD *)a1 + 12) = v22;
    sub_6DC24(&v23, &v24, v22);
    v26 = v23;
    sub_2CB8C((int)v5, &v26);
    if ( sub_6DAF4(v5 + 8, &v25) )
    {
      v6 = 0;
      *((_WORD *)a1 + 12) = 0;
    }
    else
    {
      v6 = 1;
      v4 = v26;
      v24 = v26;
    }
  }
  else
  {
LABEL_22:
    sub_2CB8C((int)v5, &v24);
    v6 = 0;
  }
LABEL_5:
  v7 = v5[6];
  v8 = v5[8];
  *((_WORD *)a1 + 10) = *((_WORD *)v5 + 18);
  a1[1] = v7;
  *a1 = v8;
  if ( sub_6DAF4(&v24, v5 + 7) >= 0 )
  {
    v9 = *((_DWORD *)v5 + 10);
    v10 = *((_WORD *)v5 + 18);
    v11 = *((_WORD *)v5 + 19);
    *((_DWORD *)a1 + 4) = v9 - v4;
    v12 = v11 - v10;
    v13 = v9 - 86400 <= v4;
    *((_WORD *)a1 + 11) = v12;
    v14 = v4 < v9;
    if ( v9 - 86400 > v9 )
      v15 = v13 || v14;
    else
      v15 = v13 && v14;
    if ( !v15 )
      v9 = 1;
    *((_BYTE *)a1 + 27) = *((_BYTE *)v5 + 72);
    if ( v15 )
    {
      v16 = v9 - 10 <= v4;
      if ( v9 - 10 > v9 )
        v17 = v14 || v16;
      else
        v17 = v16 && v14;
      if ( v17 )
        v18 = 3;
      else
        v18 = 2;
      *((_BYTE *)a1 + 26) = v18;
    }
    else
    {
      *((_BYTE *)a1 + 26) = v9;
    }
  }
  return v6;
}

//----- (0002D9F0) --------------------------------------------------------
int __fastcall sub_2D9F0(int a1, int a2, time_t *a3)
{
  const void *v6; // r8
  unsigned __int64 v8; // [sp+0h] [bp-18h] BYREF
  unsigned __int64 v9; // [sp+8h] [bp-10h] BYREF

  v6 = sub_2D0F4(0);
  sub_658E8(&v8, a2, a3);
  v9 = v8;
  sub_2CF08(a1, (int)v6, &v9);
  return 1;
}

//----- (0002DA78) --------------------------------------------------------
bool __fastcall sub_2DA78(_QWORD *a1)
{
  const void *v2; // r3
  __int16 v3; // r0
  __int64 v4; // r6
  __int16 v5; // r2
  __int64 v6; // r6

  memset(a1, 0, 0x20u);
  v2 = sub_2D0F4(0);
  v3 = *((_WORD *)v2 + 18);
  v4 = *((_QWORD *)v2 + 8);
  v5 = *((_WORD *)v2 + 19);
  *((_WORD *)a1 + 10) = v3;
  *a1 = v4;
  v6 = *((_QWORD *)v2 + 6);
  *((_WORD *)a1 + 11) = v5 - v3;
  a1[1] = v6;
  *((_BYTE *)a1 + 27) = *((_BYTE *)v2 + 72);
  return sub_6DAF4((unsigned __int64 *)v2 + 6, (unsigned __int64 *)v2 + 7) >= 0;
}

//----- (0002DB18) --------------------------------------------------------
int sub_2DB18()
{
  const void *v0; // r0

  v0 = sub_2D0F4(0);
  return sub_2C96C((int)v0);
}

//----- (0002DB68) --------------------------------------------------------
_DWORD *__fastcall sub_2DB68(_DWORD *a1)
{
  _DWORD *result; // r0
  int v3; // r12
  int v4; // r1

  result = sub_2D0F4(0);
  v3 = result[1];
  v4 = result[2];
  *a1 = *result;
  a1[1] = v3;
  a1[2] = v4;
  return result;
}

//----- (0002DBD0) --------------------------------------------------------
bool __fastcall sub_2DBD0(int a1, time_t *a2)
{
  unsigned __int64 *v4; // r5
  unsigned __int64 v6; // [sp+0h] [bp-1Ch] BYREF
  unsigned __int64 v7; // [sp+8h] [bp-14h] BYREF

  v4 = (unsigned __int64 *)sub_2D0F4(0);
  sub_658E8(&v6, a1, a2);
  v7 = v6;
  return sub_6DAF4(&v7, v4 + 3) >= 0;
}

//----- (0002DC54) --------------------------------------------------------
int __fastcall sub_2DC54(int a1, time_t *a2)
{
  _DWORD *v4; // r7
  __int64 v6; // [sp+0h] [bp-24h] BYREF
  int v7[3]; // [sp+8h] [bp-1Ch] BYREF
  int v8; // [sp+14h] [bp-10h] BYREF

  v4 = sub_2D0F4(0);
  sub_658E8(&v6, a1, a2);
  *(_QWORD *)v7 = v6;
  sub_6DBC0((int *)&v6, v4 + 6, v7);
  *(_QWORD *)v7 = v6;
  sub_6598C(&v8, v7);
  return v8;
}

//----- (0002DCF4) --------------------------------------------------------
bool __fastcall sub_2DCF4(int a1, int a2, time_t *a3)
{
  unsigned __int64 *v6; // r5
  int v7; // r4
  int v8; // r4
  unsigned __int16 v9; // r2
  bool v10; // zf
  int v11; // r4
  __int16 v12; // r3
  unsigned __int64 v14; // [sp+0h] [bp-38h] BYREF
  unsigned __int64 v15; // [sp+8h] [bp-30h] BYREF
  unsigned __int16 v16; // [sp+14h] [bp-24h] BYREF
  char v17; // [sp+18h] [bp-20h]
  char v18; // [sp+19h] [bp-1Fh]
  unsigned __int8 v19; // [sp+1Ah] [bp-1Eh]
  char v20; // [sp+1Bh] [bp-1Dh]
  char v21; // [sp+1Ch] [bp-1Ch]
  _DWORD v22[3]; // [sp+20h] [bp-18h] BYREF
  __int16 v23; // [sp+2Ch] [bp-Ch]
  char v24; // [sp+2Eh] [bp-Ah]

  v6 = (unsigned __int64 *)sub_2D0F4(1);
  sub_658E8(&v14, a2, a3);
  v15 = v14;
  if ( sub_6DAF4(&v15, v6 + 3) < 0 || *((_WORD *)v6 + 16) && sub_6DAF4(&v15, v6 + 10) <= 0 )
  {
    v7 = 0;
    *_errno_location() = 34;
  }
  else
  {
    sub_666D8(&v16, (int *)&v15);
    if ( v18 == 1 && (v7 = v19) == 0 )
    {
      *_errno_location() = 22;
    }
    else
    {
      v18 = 1;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      sub_667B4(&v14, &v16);
      v8 = v14;
      ++v17;
      sub_667B4(&v14, &v16);
      v9 = WORD2(v14);
      v10 = *((unsigned __int16 *)v6 + 16) == 0;
      v22[1] = HIDWORD(v14);
      if ( !v10 )
        v9 = *((_WORD *)v6 + 46);
      v11 = v14 - v8;
      if ( v10 )
        v9 = *((_WORD *)v6 + 17);
      v22[0] = v14;
      v12 = -1;
      if ( a1 )
        v12 = 1;
      v22[2] = v11;
      v24 = 1;
      v23 = v9 + v12;
      v7 = sub_2CAC4((int)v6, (int)v22);
      if ( v7 )
        return sub_2D1A4(v6) != 0;
    }
  }
  return v7;
}

//----- (0002DE9C) --------------------------------------------------------
int __fastcall sub_2DE9C(int a1, int a2, time_t *a3)
{
  _WORD *v6; // r0
  int v7; // r3
  int v9; // r8
  int v10; // r0
  int v11; // r2
  int v12; // r0
  int v13; // r3
  int v14; // r1
  __int16 v15; // r12
  __int16 v16; // r2
  __int16 v17; // r2
  unsigned __int64 v18; // [sp+0h] [bp-34h] BYREF
  unsigned __int64 v19; // [sp+8h] [bp-2Ch] BYREF
  unsigned __int64 v20; // [sp+10h] [bp-24h] BYREF
  unsigned __int64 v21; // [sp+18h] [bp-1Ch] BYREF
  __int16 v22; // [sp+20h] [bp-14h]

  v6 = sub_2D0F4(0);
  v7 = a1 <= 9;
  if ( v6[17] )
    v7 = 1;
  if ( v7 )
    return 0;
  v9 = (int)v6;
  v10 = (unsigned __int16)v6[16];
  if ( v10 )
  {
    if ( !*(_BYTE *)(v9 + 94) )
      return 0;
    v11 = v9;
    while ( ++v7 != v10 )
    {
      v11 += 16;
      if ( !*(_BYTE *)(v11 + 94) )
        return 0;
    }
  }
  sub_658E8(&v18, a2, a3);
  v19 = v18;
  sub_2CF08((int)&v20, v9, &v19);
  sub_6DC24(&v18, &v20, 20);
  v20 = v18;
  if ( sub_6DAF4(&v19, &v20) < 0 )
    return 0;
  sub_6DC24(&v18, &v21, -20);
  v21 = v18;
  if ( sub_6DAF4(&v19, &v21) > 0 )
    return 0;
  v12 = *(unsigned __int16 *)(v9 + 32);
  v13 = (unsigned __int16)(a1 - v22);
  v14 = v13 + *(unsigned __int16 *)(v9 + 36);
  v15 = v13 + *(_WORD *)(v9 + 34);
  v16 = v13 + *(_WORD *)(v9 + 38);
  *(_WORD *)(v9 + 36) = v14;
  *(_WORD *)(v9 + 34) = v15;
  if ( v12 )
    v14 = 0;
  *(_WORD *)(v9 + 38) = v16;
  if ( v12 )
  {
    do
    {
      v17 = *(_WORD *)(v9 + 92);
      ++v14;
      v9 += 16;
      *(_WORD *)(v9 + 76) = v13 + v17;
    }
    while ( v14 != v12 );
  }
  return 1;
}

//----- (0002E04C) --------------------------------------------------------
int __fastcall sub_2E04C(int (__fastcall *a1)(int), int a2)
{
  int v4; // r6
  int v5; // r4
  int v6; // r7
  unsigned int *v8; // r0
  unsigned int v9; // r3
  unsigned int v10; // t1
  _DWORD *v11; // r2
  int v12; // [sp+20h] [bp-2Ch] BYREF
  int s1; // [sp+24h] [bp-28h] BYREF
  _BYTE v14[16]; // [sp+28h] [bp-24h] BYREF
  _BYTE v15[20]; // [sp+38h] [bp-14h] BYREF
  int v16[23]; // [sp+4Ch] [bp+0h] BYREF
  unsigned __int8 v17[2]; // [sp+A8h] [bp+5Ch] BYREF
  char s[58]; // [sp+AAh] [bp+5Eh] BYREF

  v4 = -1;
  sub_7819C((int)v16);
  while ( sub_2D014(a1, a2, v17) )
  {
    v5 = strncmp((const char *)v17, "#h", 2u);
    v6 = v5;
    if ( v5 )
    {
      if ( !strncmp((const char *)v17, "#@", 2u) || !strncmp((const char *)v17, "#$", 2u) )
      {
        sub_2CE3C(v16, (unsigned __int8 *)s);
      }
      else if ( ((*_ctype_b_loc())[v17[0]] & 0x800) != 0 )
      {
        sub_2CE3C(v16, v17);
      }
    }
    else
    {
      s1 = 0;
      memset(v14, 0, sizeof(v14));
      if ( sscanf(s, " %lx %lx %lx %lx %lx%n", v15, &v15[4], &v15[8], &v15[12], &v15[16], &v12) == 5
        && (unsigned __int8)s[v12] <= 0x20u )
      {
        v8 = (unsigned int *)v15;
        do
        {
          v10 = *v8++;
          v9 = v10;
          v11 = &v14[v5];
          do
          {
            *((_BYTE *)v11 - 1) = v9;
            v11 = (_DWORD *)((char *)v11 - 1);
            v9 >>= 8;
          }
          while ( v11 != (_DWORD *)&v14[v5 - 4] );
          v5 += 4;
          *(v8 - 1) = v9;
        }
        while ( v5 != 20 );
        v6 = 1;
      }
      v4 = v6;
    }
  }
  sub_783E8(v16, (int)v15);
  sub_78250(v16);
  if ( v4 == -1 )
    return 0;
  if ( !v4 )
    return -2;
  if ( !memcmp(&s1, v15, 0x14u) )
    return 1;
  return -1;
}

//----- (0002E298) --------------------------------------------------------
int __fastcall sub_2E298(FILE *a1, const char *a2, int a3)
{
  const char *v3; // r6
  int v6; // r0
  int v7; // r9
  int *v8; // r8
  int v9; // r3
  int *v11; // r0
  const char *v12; // r0
  const char *v13; // r4
  const char *v14; // r0

  v3 = a2;
  if ( !a2 )
    v3 = "<unknown>";
  v6 = sub_2E04C((int (__fastcall *)(int))&getc, (int)a1);
  v7 = v6;
  if ( a3 )
  {
    switch ( v6 )
    {
      case -2:
        sub_64E00(3, "%s ('%s'): malformed hash signature", "leapsecond file", v3);
        return 0;
      case -1:
        sub_64E00(3, "%s ('%s'): signature mismatch", "leapsecond file", v3);
        return 0;
      case 0:
        sub_64E00(3, "%s ('%s'): no hash signature", "leapsecond file", v3);
        goto LABEL_7;
      case 1:
        sub_64E00(5, "%s ('%s'): good hash signature", "leapsecond file", v3);
        goto LABEL_7;
      default:
        sub_64E00(3, "%s ('%s'): unknown error code %d", "leapsecond file", v3, v6);
        break;
    }
  }
  if ( v7 < 0 )
    return 0;
LABEL_7:
  rewind(a1);
  v8 = (int *)sub_2D0F4(1);
  if ( !sub_2D320((int)v8, (int (__fastcall *)(int))&getc, (int)a1, 1) )
  {
    v9 = *_errno_location();
    if ( v9 == 22 )
    {
      sub_64E00(3, "%s ('%s'): bad transition time", "leapsecond file", v3);
    }
    else if ( v9 == 34 )
    {
      sub_64E00(3, "%s ('%s'): times not ascending", "leapsecond file", v3);
    }
    else
    {
      sub_64E00(3, "%s ('%s'): parsing error", "leapsecond file", v3);
    }
    return 0;
  }
  v11 = v8 + 6;
  if ( *((_WORD *)v8 + 16) )
  {
    v13 = sub_2CD30(v11);
    v14 = sub_2CD30(v8 + 20);
    sub_64E00(5, "%s ('%s'): loaded, expire=%s last=%s ofs=%d", "leapsecond file", v3, v13, v14, *((__int16 *)v8 + 46));
  }
  else
  {
    v12 = sub_2CD30(v11);
    sub_64E00(
      5,
      "%s ('%s'): loaded, expire=%s ofs=%d (no entries after build date)",
      "leapsecond file",
      v3,
      v12,
      *((__int16 *)v8 + 17));
  }
  return sub_2D1A4(v8);
}

//----- (0002E578) --------------------------------------------------------
int __fastcall sub_2E578(const char *a1, _DWORD *a2, int a3, int a4)
{
  int v7; // r9
  FILE *v10; // r0
  FILE *v11; // r6
  _DWORD v12[27]; // [sp+0h] [bp-70h] BYREF

  if ( !a1 || !*a1 )
    return 0;
  v7 = _xstat64(3, a1, v12);
  if ( v7 )
  {
    if ( a4 )
      sub_64E00(3, "%s ('%s'): stat failed: %m", "leapsecond file", a1);
    return 0;
  }
  if ( a2 )
  {
    if ( !a3 && a2[20] == v12[20] && a2[22] == v12[22] )
      return 0;
    memcpy(a2, v12, 0x68u);
  }
  v10 = (FILE *)fopen64(a1, "r");
  v11 = v10;
  if ( v10 )
  {
    v7 = sub_2E298(v10, a1, a4);
    fclose(v11);
    return v7;
  }
  if ( a4 )
  {
    sub_64E00(3, "%s ('%s'): open failed: %m", "leapsecond file", a1);
    return v7;
  }
  return 0;
}
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);

//----- (0002E6E0) --------------------------------------------------------
void *sub_2E6E0()
{
  void *result; // r0

  result = memset(&unk_B9938, 0, 0x1E0u);
  dword_B9B18 = 0;
  dword_B9930 = 0;
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B9930: using guessed type int dword_B9930;
// B9B18: using guessed type int dword_B9B18;

//----- (0002E750) --------------------------------------------------------
int __fastcall sub_2E750(__int16 *a1)
{
  double v1; // d0
  int v4; // [sp+4h] [bp-8h]

  if ( (__int16 *)state != a1 )
    sub_25EE0(a1, 0, 0);
  state = (int)a1;
  dbl_B9B20 = v1;
  last_offset = v1;
  dword_B9B28 = current_time;
  return v4;
}
// 2E7B0: variable 'v1' is possibly undefined
// 2E7B8: variable 'v4' is possibly undefined
// B9B20: using guessed type double dbl_B9B20;
// B9B28: using guessed type int dword_B9B28;
// B9E80: using guessed type int state;
// 1082C8: using guessed type double last_offset;
// 108CA4: using guessed type int current_time;

//----- (0002E800) --------------------------------------------------------
__int16 *__fastcall sub_2E800(const char *a1, int a2, int a3)
{
  char v6[256]; // [sp+Ch] [bp-604h] BYREF
  char v7[256]; // [sp+10Ch] [bp-504h] BYREF
  char v8[1024]; // [sp+20Ch] [bp-404h] BYREF

  sub_6C054((int)v6, 0x100u, "%04x", a2);
  sub_6C054((int)v7, 0x100u, "%04x", a3);
  sub_6C054((int)v8, 0x400u, "%s status: %s -> %s", a1, v6, v7);
  return sub_25EE0((__int16 *)&byte_9[4], 0, v8);
}

//----- (0002E8C0) --------------------------------------------------------
void __noreturn sub_2E8C0()
{
  pll_control = 0;
  _longjmp_chk(&unk_B9B30, 1);
}
// B3AC: using guessed type void __fastcall __noreturn _longjmp_chk(_DWORD, _DWORD);
// 1082F4: using guessed type int pll_control;

//----- (0002E914) --------------------------------------------------------
char *sub_2E914()
{
  char *v0; // r5
  int v2; // r4
  const unsigned __int16 **v3; // r0
  int v4; // r2
  int v5; // t1

  v0 = (char *)dword_B9CB8;
  if ( !dword_B9CB8 )
  {
    strncpy(&byte_B9E8C, "ntp_loopfilter.c", 0x1000u);
    v2 = (unsigned __int8)byte_B9E8C;
    dword_B9CB8 = (int)&byte_B9E8C;
    if ( byte_B9E8C )
    {
      v3 = _ctype_b_loc();
      v4 = 0;
      v0 = &byte_B9E8C;
      while ( ((*v3)[v2] & 8) == 0 )
      {
        v5 = (unsigned __int8)*++v0;
        v2 = v5;
        v4 = 1;
        if ( !v5 )
        {
          dword_B9CB8 = (int)v0;
          return v0;
        }
      }
      if ( v4 )
        dword_B9CB8 = (int)v0;
      else
        return &byte_B9E8C;
    }
    else
    {
      return &byte_B9E8C;
    }
  }
  return v0;
}
// B9CB8: using guessed type int dword_B9CB8;
// B9E8C: using guessed type char byte_B9E8C;

//----- (0002EA24) --------------------------------------------------------
void *__fastcall sub_2EA24(const char *a1, int a2, int a3, int a4, int a5, int a6)
{
  void *result; // r0
  int *v11; // r0
  int *v12; // r4
  char *v13; // r0
  __int16 v14; // r3
  const char *v15; // r3
  int v16; // r3
  int v17; // r2
  char *v18; // r0
  char *v19; // r0
  const char *v20; // r3
  const char *v21; // r3
  const char *v22; // r3
  const char *v23; // r3
  const char *v24; // r3
  char *v25; // r0
  char *v26; // r0
  _DWORD *v27; // [sp+18h] [bp-40Ch] BYREF
  _DWORD v28[256]; // [sp+1Ch] [bp-408h] BYREF
  _DWORD v29[2]; // [sp+41Ch] [bp-8h] BYREF

  v28[0] = 0;
  result = memset(&v28[1], 0, 0x3FCu);
  v27 = v28;
  switch ( a2 )
  {
    case -1:
      switch ( a3 )
      {
        case 14:
          v26 = sub_2E914();
          result = sub_64E00(3, "%s: %s line %d: invalid struct timex pointer: 0x%lx", a1, v26, a6, &dword_B9CBC);
          break;
        case 22:
          v25 = sub_2E914();
          result = sub_64E00(
                     3,
                     "%s: %s line %d: invalid struct timex \"constant\" element value: %ld",
                     a1,
                     v25,
                     a6,
                     dword_B9CD4);
          break;
        case 1:
          v11 = _errno_location();
          v12 = v11;
          if ( a5 )
          {
            *v11 = 1;
            sub_64E00(3, "%s: ntp_adjtime(TAI) failed: %m", a1);
          }
          *v12 = 1;
          v13 = sub_2E914();
          result = sub_64E00(3, "%s: %s line %d: ntp_adjtime: %m", a1, v13, a6);
          break;
        default:
          v19 = sub_2E914();
          result = sub_64E00(
                     5,
                     "%s: %s line %d: unhandled errno value %d after failed ntp_adjtime call",
                     a1,
                     v19,
                     a6,
                     a3);
          break;
      }
      break;
    case 0:
      return result;
    case 1:
      result = sub_64E00(6, "kernel reports leap second insertion scheduled");
      break;
    case 2:
      result = sub_64E00(6, "kernel reports leap second deletion scheduled");
      break;
    case 3:
      result = sub_64E00(6, "kernel reports leap second in progress");
      break;
    case 4:
      result = sub_64E00(6, "kernel reports leap second has occurred");
      break;
    case 5:
      v14 = dword_B9CD0;
      if ( (dword_B9CD0 & 0x40) != 0 )
      {
        sub_6EC04((int *)&v27, (int)v29, "%sClock Unsynchronized", byte_97F7C);
        v14 = dword_B9CD0;
      }
      if ( (v14 & 0x1000) != 0 )
      {
        if ( LOBYTE(v28[0]) )
          v15 = "; ";
        else
          v15 = byte_97F7C;
        sub_6EC04((int *)&v27, (int)v29, "%sClock Error", v15);
      }
      v16 = dword_B9CD0;
      if ( (dword_B9CD0 & 0x102) == 2 )
      {
        if ( LOBYTE(v28[0]) )
          v23 = "; ";
        else
          v23 = byte_97F7C;
        sub_6EC04((int *)&v27, (int)v29, "%sPPS Frequency Sync wanted but no PPS", v23);
        v16 = dword_B9CD0;
      }
      if ( (v16 & 0x104) == 4 )
      {
        if ( LOBYTE(v28[0]) )
          v21 = "; ";
        else
          v21 = byte_97F7C;
        sub_6EC04((int *)&v27, (int)v29, "%sPPS Time Sync wanted but no PPS signal", v21);
        v16 = dword_B9CD0;
      }
      if ( (v16 & 0x204) == 0x204 )
      {
        if ( LOBYTE(v28[0]) )
          v24 = "; ";
        else
          v24 = byte_97F7C;
        sub_6EC04((int *)&v27, (int)v29, "%sPPS Time Sync wanted but PPS Jitter exceeded", v24);
        v16 = dword_B9CD0;
      }
      if ( (~v16 & 0x402) == 0 )
      {
        if ( LOBYTE(v28[0]) )
          v22 = "; ";
        else
          v22 = byte_97F7C;
        sub_6EC04((int *)&v27, (int)v29, "%sPPS Frequency Sync wanted but PPS Wander exceeded", v22);
        v16 = dword_B9CD0;
      }
      if ( (~v16 & 0x802) == 0 )
      {
        if ( LOBYTE(v28[0]) )
          v20 = "; ";
        else
          v20 = byte_97F7C;
        sub_6EC04((int *)&v27, (int)v29, "%sPPS Frequency Sync wanted but Calibration error detected", v20);
      }
      v17 = dword_B9CD0;
      if ( a4 && (dword_B9CD0 & 0x100) == 0 )
      {
        sub_25EE0((__int16 *)&byte_9[4], 0, "no PPS signal");
        v17 = dword_B9CD0;
      }
      result = sub_64E00(6, "kernel reports TIME_ERROR: %#x: %s", v17, (const char *)v28);
      break;
    default:
      v18 = sub_2E914();
      result = sub_64E00(
                 5,
                 "%s: %s line %d: unhandled return value %d from ntp_adjtime() in %s at line %d",
                 a1,
                 v18,
                 a6,
                 a2,
                 "ntp_adjtime_error_handler",
                 431);
      break;
  }
  return result;
}
// 2EB58: conditional instruction was optimized away because %var_408.1==0
// B9CBC: using guessed type int dword_B9CBC;
// B9CD0: using guessed type int dword_B9CD0;
// B9CD4: using guessed type int dword_B9CD4;

//----- (0002EF84) --------------------------------------------------------
__int16 *sub_2EF84()
{
  __int16 *result; // r0
  __int16 v1; // r1
  int v2; // r5
  int *v3; // r0

  pll_control = 1;
  memset(&flt_B9CC0, 0, 0x7Cu);
  dword_B9CBC = 61;
  dword_B9CD0 = 65;
  dword_B9CC8 = 16000000;
  dword_B9CCC = 16000000;
  dword_B9DC0 = 0;
  dword_B9D3C = (int)sub_2E8C0;
  dword_B9CD4 = (unsigned __int8)sys_poll;
  if ( sigaction(31, (const struct sigaction *)&dword_B9D3C, &stru_B9DC8) )
  {
    result = (__int16 *)sub_64E00(3, "sigaction() trap SIGSYS: %m");
    pll_control = 0;
    pll_status = dword_B9CD0;
  }
  else
  {
    if ( !_sigsetjmp((struct __jmp_buf_tag *)&unk_B9B30, 1) )
    {
      v2 = adjtimex((struct timex *)&dword_B9CBC);
      if ( v2 )
      {
        v3 = _errno_location();
        sub_2EA24("start_kern_loop", v2, *v3, 0, 0, 1127);
      }
    }
    if ( sigaction(31, &stru_B9DC8, 0) )
    {
      sub_64E00(3, "sigaction() restore SIGSYS: %m");
      pll_control = 0;
      pll_status = dword_B9CD0;
      return 0;
    }
    else
    {
      result = (__int16 *)&GLOBAL_OFFSET_TABLE_;
      v1 = dword_B9CD0;
      pll_status = dword_B9CD0;
      if ( pll_control )
      {
        if ( !dword_B9E54 )
        {
          dword_B9E54 = 1;
          sub_8C1A8((void (*)(void *))sub_2F368);
          v1 = pll_status;
        }
        if ( v1 < 0 )
          ext_enable = 1;
        return sub_25EE0((__int16 *)&byte_9[4], 0, "kernel time sync enabled");
      }
    }
  }
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B5584: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;
// B9CBC: using guessed type int dword_B9CBC;
// B9CC0: using guessed type float flt_B9CC0;
// B9CC8: using guessed type int dword_B9CC8;
// B9CCC: using guessed type int dword_B9CCC;
// B9CD0: using guessed type int dword_B9CD0;
// B9CD4: using guessed type int dword_B9CD4;
// B9D3C: using guessed type int dword_B9D3C;
// B9DC0: using guessed type int dword_B9DC0;
// B9DC8: using guessed type struct sigaction stru_B9DC8;
// B9E54: using guessed type int dword_B9E54;
// 1082B0: using guessed type char sys_poll;
// 1082C0: using guessed type int ext_enable;
// 1082F4: using guessed type int pll_control;
// 1082FC: using guessed type int pll_status;

//----- (0002F1EC) --------------------------------------------------------
unsigned int sub_2F1EC()
{
  double v0; // d0
  double v1; // d8
  const char *v2; // r4
  int v4; // r7
  int *v5; // r0

  v1 = v0;
  drift_comp = v0;
  if ( pll_control )
  {
    memset(&flt_B9CC0, 0, 0x7Cu);
    dword_B9CBC = 2;
    if ( kern_enable )
    {
      v2 = "kernel";
      LODWORD(flt_B9CC4) = (int)(v0 * 6.5536e10);
    }
    else
    {
      v2 = "ntpd";
    }
    v4 = adjtimex((struct timex *)&dword_B9CBC);
    if ( v4 )
    {
      v5 = _errno_location();
      sub_2EA24("set_freq", v4, *v5, 0, 0, 1086);
    }
    v1 = drift_comp;
  }
  else
  {
    v2 = "ntpd";
  }
  return sub_262E8((_WORD *)&dword_0 + 1, 0, "%s %.3f PPM", v2, v1 * 1000000.0);
}
// 2F210: variable 'v0' is possibly undefined
// 0: using guessed type int dword_0;
// B6AE8: using guessed type int kern_enable;
// B9CBC: using guessed type int dword_B9CBC;
// B9CC0: using guessed type float flt_B9CC0;
// B9CC4: using guessed type float flt_B9CC4;
// 1082D8: using guessed type double drift_comp;
// 1082F4: using guessed type int pll_control;

//----- (0002F368) --------------------------------------------------------
__int16 *sub_2F368()
{
  __int16 *result; // r0

  result = (__int16 *)_stack_chk_guard;
  if ( pll_control )
  {
    if ( kern_enable )
      return sub_25EE0((__int16 *)&byte_9[4], 0, "kernel time sync disabled");
  }
  return result;
}
// B6AE8: using guessed type int kern_enable;
// 1082F4: using guessed type int pll_control;

//----- (0002F40C) --------------------------------------------------------
int sub_2F40C()
{
  double v0; // r0
  int v2; // [sp+4h] [bp-8h]

  HIDWORD(v0) = (unsigned __int8)ntp_minpoll;
  sys_poll = ntp_minpoll;
  LODWORD(v0) = sys_precision;
  ldexp(v0, (int)&sys_poll);
  clock_jitter = 1.0;
  LODWORD(freq_cnt) = (int)clock_minstep;
  return v2;
}
// 2F468: variable 'v2' is possibly undefined
// B6B08: using guessed type double clock_minstep;
// B6B30: using guessed type char ntp_minpoll;
// 1082B0: using guessed type char sys_poll;
// 1082B8: using guessed type double clock_jitter;
// 108308: using guessed type float freq_cnt;
// 108BA8: using guessed type char sys_precision;

//----- (0002F4BC) --------------------------------------------------------
int __fastcall sub_2F4BC(int a1)
{
  double v1; // d0
  int v2; // r5
  double v4; // d8
  double v5; // d7
  double *v6; // r3
  double v7; // d6
  double v8; // d7
  double v9; // d7
  unsigned int v10; // r2
  int v11; // r7
  double v12; // d9
  double v13; // d10
  double v14; // r0
  int *v15; // r0
  double v16; // d6
  int *v17; // r0
  double v18; // d7
  double v19; // d7
  double v20; // d0
  double v21; // d8
  unsigned int v22; // r0
  double v24; // r0
  double v25; // d11
  double v26; // d12
  double v27; // r0
  int v28; // r2
  double *v29; // r2
  double v30; // d13
  double v31; // d12
  double v32; // r0
  int v33; // r2
  double v34; // d0
  double v35; // d0
  double v36; // d11
  int v37; // r2
  double v38; // r0
  int v39; // r2
  int v40; // r3
  unsigned int v41; // r3
  unsigned int v42; // r3
  double v43; // d7
  double v44; // d11
  double v45; // d11
  double v46; // d0
  int v47; // [sp+18h] [bp-64h]
  int v48; // [sp+1Ch] [bp-60h]
  char v49[80]; // [sp+24h] [bp-58h] BYREF

  v2 = ntp_enable;
  if ( !ntp_enable )
  {
    sub_41E10((unsigned __int8)sys_poll);
    return v2;
  }
  v4 = v1;
  if ( fabs(v1) > clock_panic && clock_panic > 0.0 && !allow_panic )
  {
    sub_6C054((int)v49, 0x50u, "%+.0f s; set clock manually within %.0f s.", v1, clock_panic);
    v2 = -1;
    sub_25EE0((__int16 *)&byte_7, 0, v49);
    return v2;
  }
  allow_panic = 0;
  v2 = mode_ntpdate;
  if ( mode_ntpdate )
  {
    if ( clock_max_fwd < v1 && clock_max_fwd > 0.0 || -v1 > clock_max_back && clock_max_back > 0.0 )
    {
      sub_5FF34();
      sub_64E00(5, "ntpd: time set %+.6f s", v1);
      _printf_chk(1, "ntpd: time set %+.6fs\n", v1);
    }
    else
    {
      sub_5FCA8();
      sub_64E00(5, "ntpd: time slew %+.6f s", v1);
      _printf_chk(1, "ntpd: time slew %+.6fs\n", v1);
    }
    sub_41E10((unsigned __int8)sys_poll);
    exit(0);
  }
  if ( dword_B9E58 )
  {
    v5 = *(double *)(a1 + 616);
    v6 = (double *)(dword_B9E58 + 8 * dword_B9E5C);
    if ( v5 < *v6 )
    {
      *v6 = v5;
      v5 = *(double *)(a1 + 616);
    }
    v7 = dbl_B9E60;
    if ( dbl_B9E60 > v5 )
    {
      v7 = v5;
      dbl_B9E60 = v5;
    }
    v8 = v5 - v7;
    if ( v1 <= 0.0 )
      v9 = v8 * 0.5;
    else
      v9 = -(v8 * 0.5);
    v4 = v1 + v9;
  }
  v10 = *(unsigned __int8 *)(a1 + 65);
  v11 = (unsigned __int8)sys_poll;
  if ( (unsigned __int8)sys_poll >= v10 )
    v10 = (unsigned __int8)sys_poll;
  else
    sys_poll = *(_BYTE *)(a1 + 65);
  if ( *(unsigned __int8 *)(a1 + 66) < v10 )
    sys_poll = *(_BYTE *)(a1 + 66);
  v12 = (double)(unsigned int)(current_time - dword_B9B28);
  v13 = drift_comp;
  if ( clock_max_fwd < v4 && clock_max_fwd > 0.0 || -v4 > clock_max_back && clock_max_back > 0.0 )
  {
    if ( !force_step_once )
      goto LABEL_31;
    goto LABEL_68;
  }
  if ( force_step_once )
  {
LABEL_68:
    force_step_once = 0;
    sub_64E00(5, "Doing intital time step");
LABEL_31:
    switch ( state )
    {
      case 4:
        if ( clock_minstep > v12 )
          return v2;
        sub_2F1EC();
        v13 = drift_comp;
        break;
      case 5:
        sub_6C054((int)v49, 0x50u, (unsigned __int8 *)"%+.6f s", v4);
        sub_25EE0((__int16 *)((char *)&dword_0 + 3), 0, v49);
        state = 3;
        return v2;
      case 3:
        break;
      default:
        goto LABEL_34;
    }
    if ( clock_minstep > v12 )
      return v2;
LABEL_34:
    sub_6C054((int)v49, 0x50u, (unsigned __int8 *)"%+.6f s", v4);
    sub_25EE0((__int16 *)&byte_9[3], 0, v49);
    sub_5FF34();
    sub_40C14();
    tc_counter = 0;
    ldexp(COERCE_DOUBLE((unsigned __int64)sys_precision), 1508);
    clock_jitter = 1.0;
    if ( state == 1 )
    {
      v2 = 2;
      sub_2E750((__int16 *)&byte_4);
      return v2;
    }
    v2 = 2;
    LODWORD(v14) = sub_2E750((__int16 *)&byte_5);
    goto LABEL_36;
  }
  HIDWORD(v24) = 1460;
  LODWORD(v24) = sys_precision;
  v25 = clock_jitter * clock_jitter;
  v26 = fabs(v4 - last_offset);
  v27 = ldexp(v24, (int)&last_offset);
  if ( v26 <= 1.0 )
  {
    LODWORD(v27) = sys_precision;
    v27 = ldexp(v27, v28);
    v30 = 1.0;
    v31 = fabs(v4 - last_offset);
  }
  else
  {
    v29 = &last_offset;
    v30 = fabs(v4 - last_offset);
    v31 = v30;
  }
  LODWORD(v27) = sys_precision;
  v32 = ldexp(v27, (int)v29);
  if ( v31 <= 1.0 )
  {
    v34 = 1.0;
    LODWORD(v32) = sys_precision;
    v32 = ldexp(v32, v33);
  }
  else
  {
    v34 = fabs(v4 - last_offset);
  }
  v35 = v25 + (v30 * v34 - v25) * 0.125;
  v36 = sqrt(v35);
  if ( v35 < 0.0 )
    v32 = sqrt(v32);
  clock_jitter = v36;
  if ( state == 1 )
  {
    v2 = 1;
    sub_5FCA8();
    LODWORD(v14) = sub_2E750((__int16 *)&byte_4);
  }
  else
  {
    if ( state == 4 )
    {
      if ( clock_minstep > v12 )
        return v2;
      sub_2F1EC();
      v13 = drift_comp;
    }
    if ( !LODWORD(freq_cnt) )
    {
      v37 = (unsigned __int8)sys_poll;
      LODWORD(v32) = (unsigned __int8)allan_xpt;
      if ( (unsigned __int8)sys_poll >= (unsigned int)(unsigned __int8)allan_xpt )
      {
        LODWORD(v32) = (unsigned __int8)sys_poll;
        v44 = dbl_B9B20;
        v32 = ldexp(v32, (unsigned __int8)sys_poll);
        v45 = v4 - v44;
        if ( v12 < 1.0 )
        {
          LODWORD(v32) = (unsigned __int8)sys_poll;
          v32 = ldexp(v32, v37);
          v46 = 1.0 * 0.25;
        }
        else
        {
          v46 = v12 * 0.25;
        }
        LODWORD(v32) = (unsigned __int8)allan_xpt;
        v13 = v13 + v45 / v46;
      }
      v38 = ldexp(v32, v37);
      if ( v12 > 1.0 )
      {
        LODWORD(v38) = (unsigned __int8)allan_xpt;
        v38 = ldexp(v38, v39);
        v12 = 1.0;
      }
      LODWORD(v38) = (unsigned __int8)sys_poll;
      ldexp(v38, v39);
      v13 = v13 + v4 * v12 / (1.0 * 64.0 * (1.0 * 64.0));
    }
    LODWORD(v14) = sub_2E750((__int16 *)&byte_5);
    v2 = 1;
    if ( fabs(v4) < 0.0005 )
      freq_cnt = 0.0;
  }
LABEL_36:
  if ( pll_control )
  {
    if ( kern_enable )
    {
      *((float *)&v14 + 1) = freq_cnt;
      if ( !LODWORD(freq_cnt) )
      {
        memset(&dword_B9CBC, 0, 0x80u);
        if ( ext_enable )
        {
          dword_B9CBC = 16;
        }
        else
        {
          v43 = -0.5;
          if ( dbl_B9B20 >= 0.0 )
            v43 = 0.5;
          dword_B9CBC = 8253;
          dword_B9CD4 = (unsigned __int8)sys_poll;
          LODWORD(flt_B9CC0) = (int)(v43 + dbl_B9B20 * 1000000000.0);
          dword_B9CCC = (unsigned int)(clock_jitter * 1000000.0);
          dword_B9CD0 = 1;
          dword_B9CC8 = (unsigned int)((sys_rootdisp + sys_rootdelay * 0.5) * 1000000.0);
          if ( hardpps_enable )
          {
            dword_B9CD0 = 7;
            if ( (pll_status & 4) == 0 )
              sub_2E800("PPS enabled", pll_status, 7);
          }
          else if ( (pll_status & 4) != 0 )
          {
            sub_2E800("PPS disabled", pll_status, 1);
          }
          if ( sys_leap == 1 )
          {
            dword_B9CD0 |= 0x10u;
          }
          else if ( sys_leap == 2 )
          {
            dword_B9CD0 |= 0x20u;
          }
        }
        LODWORD(v14) = adjtimex((struct timex *)&dword_B9CBC);
        if ( SLODWORD(v14) < 0 || kernel_status != LODWORD(v14) )
        {
          kernel_status = LODWORD(v14);
          v48 = LODWORD(v14);
          v15 = _errno_location();
          LODWORD(v14) = sub_2EA24("local_clock", v48, *v15, hardpps_enable, 0, 822);
        }
        v16 = (double)SLODWORD(flt_B9CC0);
        pll_status = dword_B9CD0;
        HIDWORD(v14) = dword_B9E68;
        v13 = (double)SLODWORD(flt_B9CC4) / 6.5536e10;
        if ( (dword_B9CD0 & 4) != 0 )
          v16 = (double)SLODWORD(flt_B9CF0) / 1000000000.0;
        dbl_B9B20 = (double)SLODWORD(flt_B9CC0) / 1000000000.0;
        if ( (dword_B9CD0 & 4) != 0 )
          clock_jitter = v16;
        if ( dword_B9E68 != sys_tai )
        {
          dword_B9CBC = 128;
          dword_B9E68 = sys_tai;
          dword_B9CD4 = sys_tai;
          LODWORD(v14) = adjtimex((struct timex *)&dword_B9CBC);
          HIDWORD(v14) = LODWORD(v14);
          if ( LODWORD(v14) )
          {
            v47 = LODWORD(v14);
            v17 = _errno_location();
            LODWORD(v14) = sub_2EA24("local_clock", v47, *v17, 0, 1, 852);
          }
        }
      }
    }
  }
  if ( fabs(v13) > 0.0005 )
    LODWORD(v14) = sub_64E00(5, "frequency error %.0f PPM exceeds tolerance %.0f PPM", v13 * 1000000.0, 500.0);
  v18 = v13 - drift_comp;
  if ( v13 > 0.0005 )
    drift_comp = 0.0005;
  v19 = v18 * v18;
  if ( v13 <= 0.0005 )
  {
    if ( v13 < -0.0005 )
      v13 = -0.0005;
    drift_comp = v13;
  }
  v20 = clock_stability * clock_stability + (v19 - clock_stability * clock_stability) * 0.125;
  v21 = sqrt(v20);
  if ( v20 < 0.0 )
    sqrt(v14);
  clock_stability = v21;
  v22 = (unsigned __int8)sys_poll;
  if ( SLODWORD(freq_cnt) <= 0 )
  {
    if ( fabs(dbl_B9B20) < clock_jitter * 4.0 )
    {
      v40 = tc_counter + (unsigned __int8)sys_poll;
      if ( v40 > 30 )
      {
        v42 = *(unsigned __int8 *)(a1 + 66);
        tc_counter = 30;
        if ( v42 <= (unsigned __int8)sys_poll )
          goto LABEL_63;
        LOBYTE(v22) = sys_poll + 1;
        goto LABEL_100;
      }
    }
    else
    {
      v40 = tc_counter - 2 * (unsigned __int8)sys_poll;
      if ( v40 < -30 )
      {
        v41 = *(unsigned __int8 *)(a1 + 65);
        tc_counter = -30;
        if ( v41 >= (unsigned __int8)sys_poll )
          goto LABEL_63;
        LOBYTE(v22) = sys_poll - 1;
LABEL_100:
        v22 = (unsigned __int8)v22;
        tc_counter = 0;
        sys_poll = v22;
        goto LABEL_63;
      }
    }
    tc_counter = v40;
    goto LABEL_63;
  }
  tc_counter = 0;
LABEL_63:
  if ( v11 != v22 )
  {
    sub_34264(a1, v22);
    v22 = (unsigned __int8)sys_poll;
  }
  sub_41E10(v22);
  return v2;
}
// 2F500: variable 'v1' is possibly undefined
// 30150: variable 'v14' is possibly undefined
// 2FD50: variable 'v29' is possibly undefined
// 2FE20: variable 'v32' is possibly undefined
// 2FE20: variable 'v37' is possibly undefined
// 300D4: variable 'v39' is possibly undefined
// 2FF28: variable 'v28' is possibly undefined
// 2FFC8: variable 'v33' is possibly undefined
// 0: using guessed type int dword_0;
// 4: using guessed type char byte_4;
// 5: using guessed type char byte_5;
// 7: using guessed type char byte_7;
// 1BC: using guessed type int elf_hash_bucket[521];
// B4C0: using guessed type int _printf_chk(_DWORD, const char *, ...);
// B6AE8: using guessed type int kern_enable;
// B6AEC: using guessed type int ntp_enable;
// B6AF0: using guessed type char allan_xpt;
// B6B00: using guessed type double clock_panic;
// B6B08: using guessed type double clock_minstep;
// B6B10: using guessed type double clock_max_fwd;
// B6B18: using guessed type double clock_max_back;
// B9B20: using guessed type double dbl_B9B20;
// B9B28: using guessed type int dword_B9B28;
// B9CBC: using guessed type int dword_B9CBC;
// B9CC0: using guessed type float flt_B9CC0;
// B9CC4: using guessed type float flt_B9CC4;
// B9CC8: using guessed type int dword_B9CC8;
// B9CCC: using guessed type int dword_B9CCC;
// B9CD0: using guessed type int dword_B9CD0;
// B9CD4: using guessed type int dword_B9CD4;
// B9CF0: using guessed type float flt_B9CF0;
// B9E58: using guessed type int dword_B9E58;
// B9E5C: using guessed type int dword_B9E5C;
// B9E60: using guessed type double dbl_B9E60;
// B9E68: using guessed type int dword_B9E68;
// B9E80: using guessed type int state;
// B9E84: using guessed type int mode_ntpdate;
// B9E88: using guessed type int force_step_once;
// 106F60: using guessed type int allow_panic;
// 1082B0: using guessed type char sys_poll;
// 1082B4: using guessed type int hardpps_enable;
// 1082B8: using guessed type double clock_jitter;
// 1082C0: using guessed type int ext_enable;
// 1082C4: using guessed type int tc_counter;
// 1082C8: using guessed type double last_offset;
// 1082D0: using guessed type int sys_tai;
// 1082D8: using guessed type double drift_comp;
// 1082E8: using guessed type double clock_stability;
// 1082F4: using guessed type int pll_control;
// 1082F8: using guessed type int kernel_status;
// 1082FC: using guessed type int pll_status;
// 108308: using guessed type float freq_cnt;
// 108BA8: using guessed type char sys_precision;
// 108BB8: using guessed type double sys_rootdisp;
// 108BC0: using guessed type char sys_leap;
// 108BC8: using guessed type double sys_rootdelay;
// 108CA4: using guessed type int current_time;

//----- (000301E4) --------------------------------------------------------
int sub_301E4()
{
  int result; // r0
  double v1; // d8
  int v2; // r3
  double v3; // d7
  double v4; // d6
  double v5; // d5
  double v6; // r0

  result = _stack_chk_guard;
  sys_rootdisp = sys_rootdisp + clock_phi;
  if ( ntp_enable && !mode_ntpdate )
  {
    v1 = dbl_B9B20;
    v2 = pll_control;
    if ( state == 5 )
    {
      HIDWORD(v6) = &freq_cnt;
      if ( SLODWORD(freq_cnt) <= 0 )
      {
        if ( pll_control && kern_enable )
        {
          v3 = 0.0;
LABEL_11:
          dbl_B9B20 = v1 - v3;
          enable_panic_check = 0;
          result = sub_5FCA8();
          enable_panic_check = 1;
          return result;
        }
        LODWORD(v6) = (unsigned __int8)sys_poll;
        ldexp(v6, SLODWORD(freq_cnt));
        v2 = pll_control;
        v3 = v1 / (1.0 * 16.0);
      }
      else
      {
        --LODWORD(freq_cnt);
        v3 = dbl_B9B20 * 0.03125;
      }
    }
    else
    {
      v3 = 0.0;
    }
    if ( v2 && kern_enable )
      v4 = 0.0;
    else
      v4 = drift_comp;
    v5 = 0.0005;
    if ( v3 + v4 > 0.0005 || (v5 = -0.0005, v3 + v4 < -0.0005) )
      v3 = v5 - v4;
    goto LABEL_11;
  }
  return result;
}
// B6AE8: using guessed type int kern_enable;
// B6AEC: using guessed type int ntp_enable;
// B6AF8: using guessed type double clock_phi;
// B7CBC: using guessed type int enable_panic_check;
// B9B20: using guessed type double dbl_B9B20;
// B9E80: using guessed type int state;
// B9E84: using guessed type int mode_ntpdate;
// 1082B0: using guessed type char sys_poll;
// 1082D8: using guessed type double drift_comp;
// 1082F4: using guessed type int pll_control;
// 108308: using guessed type float freq_cnt;
// 108BB8: using guessed type double sys_rootdisp;

//----- (000303FC) --------------------------------------------------------
__int16 *__fastcall sub_303FC(__int16 *result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3

  if ( (__int16 *)kern_enable != result )
  {
    v1 = pll_control;
    v2 = pll_control;
    if ( pll_control )
      v2 = 1;
    if ( kern_enable )
      v3 = v2;
    else
      v3 = 0;
    if ( result )
      v3 = 0;
    if ( v3 )
    {
      result = sub_25EE0((__int16 *)&byte_9[4], 0, "kernel time sync disabled");
      v1 = pll_control;
      kern_enable = 0;
    }
    else
    {
      kern_enable = (int)result;
      if ( !result )
        v2 = 0;
      if ( v2 )
      {
        result = sub_2EF84();
        v1 = pll_control;
      }
    }
    if ( v1 )
    {
      if ( dword_B9E6C )
        return (__int16 *)sub_2F1EC();
    }
  }
  return result;
}
// B6AE8: using guessed type int kern_enable;
// B9E6C: using guessed type int dword_B9E6C;
// 1082D8: using guessed type double drift_comp;
// 1082F4: using guessed type int pll_control;

//----- (00030520) --------------------------------------------------------
int sub_30520()
{
  int v0; // r4
  int v1; // r5
  int result; // r0
  double v3; // d6
  int v4; // r1
  double *v5; // r3
  int v6; // r2
  double v7; // d7

  v0 = dword_B9E58;
  if ( dword_B9E58 )
  {
    v1 = dword_B9E70;
    result = sub_8BB9C(dword_B9E5C + 1, dword_B9E70);
    v3 = 1000000000.0;
    dword_B9E5C = v4;
    *(_QWORD *)(v0 + 8 * v4) = 0x41CDCD6500000000LL;
    dbl_B9E60 = 1000000000.0;
    if ( v1 > 0 )
    {
      v5 = (double *)v0;
      v6 = 0;
      do
      {
        v7 = *v5++;
        if ( v7 < v3 )
        {
          v3 = v7;
          v6 = 1;
        }
      }
      while ( v5 != (double *)(v0 + 8 * v1) );
      if ( v6 )
        dbl_B9E60 = v3;
    }
  }
  return result;
}
// 30574: variable 'v4' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// B9E58: using guessed type int dword_B9E58;
// B9E5C: using guessed type int dword_B9E5C;
// B9E60: using guessed type double dbl_B9E60;
// B9E70: using guessed type int dword_B9E70;

//----- (000305F8) --------------------------------------------------------
void *__fastcall sub_305F8(void *result)
{
  double v1; // d0
  double v2; // d7
  unsigned int v3; // r1
  int v4; // r12
  _QWORD *v5; // r0
  _QWORD *v6; // r3

  v3 = (unsigned int)result - 1;
  switch ( (unsigned int)result )
  {
    case 1u:
      if ( !mode_ntpdate )
      {
        sub_2EF84();
        sub_2F1EC();
        if ( freq_set )
        {
          result = &dword_0 + 2;
          dbl_B9B20 = 0.0;
          state = 2;
          last_offset = 0.0;
          dword_B9B28 = current_time;
        }
        else
        {
          result = (void *)sub_2E750((__int16 *)((char *)&dword_0 + 1));
        }
        dword_B9E6C = 1;
      }
      break;
    case 2u:
      return result;
    case 3u:
      clock_max_back = v1;
      clock_max_fwd = v1;
      if ( v1 == 0.0 || v1 > 0.5 )
        goto LABEL_10;
      break;
    case 4u:
      clock_max_back = v1;
      if ( v1 == 0.0 || v1 > 0.5 || clock_max_fwd == 0.0 || clock_max_fwd > 0.5 )
        goto LABEL_10;
      break;
    case 5u:
      clock_max_fwd = v1;
      if ( clock_max_back == 0.0 || clock_max_back > 0.5 || v1 == 0.0 || v1 > 0.5 )
LABEL_10:
        result = sub_303FC(0);
      break;
    case 6u:
      clock_panic = v1;
      break;
    case 7u:
      clock_phi = v1 / 1000000.0;
      break;
    case 8u:
      if ( v1 >= 300.0 )
        clock_minstep = v1;
      else
        clock_minstep = 300.0;
      break;
    case 0xAu:
      allan_xpt = (unsigned int)v1;
      break;
    case 0xBu:
      if ( v1 >= 900.0 )
        v2 = v1 / 900.0;
      else
        v3 = 1;
      if ( v1 >= 900.0 )
      {
        v4 = (int)v2;
        v3 = (int)v2;
      }
      else
      {
        v4 = v3;
      }
      dword_B9E70 = v4;
      v5 = sub_63C68(0, v3, 8u, 0);
      dword_B9E58 = (int)v5;
      if ( dword_B9E70 > 0 )
      {
        v6 = &v5[dword_B9E70];
        do
          *v5++ = 0x41CDCD6500000000LL;
        while ( v6 != v5 );
      }
      dbl_B9E60 = 1000000000.0;
      result = 0;
      break;
    case 0xCu:
      dbl_B9E78 = v1;
      ++freq_set;
      break;
    case 0xDu:
      clock_codec = v1 / 1000000.0;
      break;
    case 0xFu:
      result = sub_386B0();
      break;
    default:
      result = sub_64E00(5, "loop_config: unsupported option %d", result);
      break;
  }
  return result;
}
// 30764: variable 'v1' is possibly undefined
// 308D4: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;
// 1BC: using guessed type int elf_hash_bucket[521];
// B6AF0: using guessed type char allan_xpt;
// B6AF8: using guessed type double clock_phi;
// B6B00: using guessed type double clock_panic;
// B6B08: using guessed type double clock_minstep;
// B6B10: using guessed type double clock_max_fwd;
// B6B18: using guessed type double clock_max_back;
// B9B20: using guessed type double dbl_B9B20;
// B9B28: using guessed type int dword_B9B28;
// B9E58: using guessed type int dword_B9E58;
// B9E60: using guessed type double dbl_B9E60;
// B9E6C: using guessed type int dword_B9E6C;
// B9E70: using guessed type int dword_B9E70;
// B9E78: using guessed type double dbl_B9E78;
// B9E80: using guessed type int state;
// B9E84: using guessed type int mode_ntpdate;
// 1082C8: using guessed type double last_offset;
// 1082F0: using guessed type int freq_set;
// 108300: using guessed type double clock_codec;
// 108CA4: using guessed type int current_time;

//----- (00030A38) --------------------------------------------------------
void sub_30A38()
{
  int *v0; // r4
  char *v1; // r3
  int v2; // r6
  _DWORD *v3; // r0

  if ( dword_BAE90 )
  {
    v0 = mru_incalloc[0];
    if ( !mru_incalloc[0] )
      return;
  }
  else
  {
    v0 = mru_initalloc;
    if ( !mru_initalloc )
      return;
  }
  v1 = (char *)sub_63C68(0, (unsigned int)v0, 0x48u, 0) + 72 * (_DWORD)v0;
  v2 = dword_BAE94;
  mru_alloc += (int)v0;
  do
  {
    v3 = memset(v1 - 72, 0, 0x48u);
    v0 = (int *)((char *)v0 - 1);
    *v3 = v2;
    v1 = (char *)v3;
    dword_BAE94 = (int)v3;
    v2 = (int)v3;
  }
  while ( v0 );
  ++dword_BAE90;
}
// B6B38: using guessed type int *mru_incalloc[2];
// B6B3C: using guessed type int *mru_initalloc;
// BAE90: using guessed type int dword_BAE90;
// BAE94: using guessed type int dword_BAE94;
// 108368: using guessed type int mru_alloc;

//----- (00030B44) --------------------------------------------------------
_DWORD *__fastcall sub_30B44(int a1)
{
  int v2; // r0
  _DWORD **v3; // r1
  _DWORD *result; // r0
  _DWORD *v5; // r3
  _DWORD *v6; // r2

  --LODWORD(mru_entries);
  v2 = sub_6C568((unsigned __int16 *)(a1 + 44)) & ~(-1 << mon_hash_bits);
  v3 = *(_DWORD ***)(mon_hash + 4 * v2);
  result = (_DWORD *)(mon_hash + 4 * v2);
  if ( (_DWORD **)a1 == v3 )
  {
    v6 = (_DWORD *)a1;
LABEL_10:
    *result = *(_DWORD *)a1;
    goto LABEL_11;
  }
  if ( v3 )
  {
    v5 = *v3;
    if ( !*v3 )
    {
      v6 = 0;
      goto LABEL_11;
    }
    while ( (_DWORD *)a1 != v5 )
    {
      v6 = (_DWORD *)*v5;
      v3 = (_DWORD **)v5;
      if ( !*v5 )
        goto LABEL_11;
      v5 = (_DWORD *)*v5;
    }
    result = v3;
    v6 = (_DWORD *)a1;
    goto LABEL_10;
  }
  v6 = 0;
LABEL_11:
  if ( v6 != (_DWORD *)a1 )
    sub_6ECC0("ntp_monitor.c", 136, 1, "punlinked == mon");
  return result;
}
// 108354: using guessed type float mru_entries;
// 108360: using guessed type int mon_hash;
// 108364: using guessed type char mon_hash_bits;

//----- (00030C68) --------------------------------------------------------
void *sub_30C68()
{
  mon_enabled = 0;
  dword_108314 = (int)&mon_mru_list;
  dword_108310 = (int)&mon_mru_list;
  return &_stack_chk_guard;
}
// 108310: using guessed type int dword_108310;
// 108314: using guessed type int dword_108314;
// 108358: using guessed type int mon_enabled;

//----- (00030CD4) --------------------------------------------------------
int __fastcall sub_30CD4(int result)
{
  int v1; // r7
  unsigned int v2; // r3
  unsigned int i; // r1
  size_t v4; // r1
  unsigned __int8 v5; // r3

  v1 = result;
  if ( result )
  {
    if ( mon_enabled )
    {
      mon_enabled |= result;
    }
    else
    {
      if ( !dword_BAE90 )
        sub_30A38();
      v2 = (((unsigned int)mru_maxdepth >> 3) + 1) >> 1;
      if ( v2 )
      {
        for ( i = 1; ; i = (unsigned __int8)(i + 1) )
        {
          v2 >>= 1;
          if ( !v2 )
            break;
        }
        if ( i < 4 )
          v5 = 4;
        else
          v5 = i;
        if ( v5 >= 0x10u )
          v5 = 16;
        v4 = 4 << v5;
      }
      else
      {
        v4 = 64;
        v5 = 4;
      }
      mon_hash_bits = v5;
      result = (int)sub_63BA4((void *)mon_hash, v4, 0, 1);
      mon_enabled = v1;
      mon_hash = result;
    }
  }
  return result;
}
// B6B24: using guessed type int mru_maxdepth;
// BAE90: using guessed type int dword_BAE90;
// 108358: using guessed type int mon_enabled;
// 108360: using guessed type int mon_hash;
// 108364: using guessed type char mon_hash_bits;

//----- (00030DFC) --------------------------------------------------------
unsigned int __fastcall sub_30DFC(unsigned int result)
{
  int *v1; // r6
  int v2; // r9
  int *v3; // r7

  if ( mon_enabled )
  {
    if ( (result & mon_enabled) != 0 )
    {
      mon_enabled &= ~result;
      if ( !mon_enabled )
      {
        v1 = (int *)dword_108314;
        if ( (_UNKNOWN *)dword_108314 != &mon_mru_list )
        {
          v2 = dword_BAE94;
          while ( 1 )
          {
            v3 = (int *)v1[2];
            memset(v1 + 1, 0, 0x44u);
            *v1 = v2;
            dword_BAE94 = (int)v1;
            v2 = (int)v1;
            if ( v3 == (int *)&mon_mru_list )
              break;
            v1 = v3;
          }
        }
        dword_108314 = (int)&mon_mru_list;
        dword_108310 = (int)&mon_mru_list;
        mru_entries = 0.0;
        return (unsigned int)memset((void *)mon_hash, 0, 4 << mon_hash_bits);
      }
    }
  }
  return result;
}
// BAE94: using guessed type int dword_BAE94;
// 108310: using guessed type int dword_108310;
// 108314: using guessed type int dword_108314;
// 108354: using guessed type float mru_entries;
// 108358: using guessed type int mon_enabled;
// 108360: using guessed type int mon_hash;
// 108364: using guessed type char mon_hash_bits;

//----- (00030F28) --------------------------------------------------------
void *__fastcall sub_30F28(void *result)
{
  int *v1; // r4
  void *v2; // r7
  int *v3; // r5
  int v4; // r3
  int v5; // r3

  v1 = (int *)dword_108314;
  if ( (_UNKNOWN *)dword_108314 != &mon_mru_list )
  {
    v2 = result;
    do
    {
      while ( 1 )
      {
        v3 = (int *)v1[2];
        if ( (void *)v1[3] == v2 )
          break;
        v1 = (int *)v1[2];
        if ( v3 == (int *)&mon_mru_list )
          return result;
      }
      v4 = v1[1];
      *(_DWORD *)(v4 + 8) = v3;
      *(_DWORD *)(v1[2] + 4) = v4;
      sub_30B44((int)v1);
      result = memset(v1 + 1, 0, 0x44u);
      v5 = dword_BAE94;
      dword_BAE94 = (int)v1;
      *v1 = v5;
      v1 = v3;
    }
    while ( v3 != (int *)&mon_mru_list );
  }
  return result;
}
// BAE94: using guessed type int dword_BAE94;
// 108314: using guessed type int dword_108314;

//----- (00030FF4) --------------------------------------------------------
int __fastcall sub_30FF4(int a1, int a2)
{
  int v4; // r7
  int v6; // r0
  unsigned int v7; // r11
  int v8; // r0
  int v9; // r4
  int *v10; // r9
  int v11; // r11
  __int16 v12; // r10
  int v13; // r0
  unsigned int v14; // r1
  int v15; // r7
  int v16; // lr
  int v17; // r3
  unsigned int v18; // r6
  int v19; // r9
  int v20; // r3
  int v21; // r9
  int v22; // lr
  int v23; // r3
  int v24; // r7
  int v25; // r0
  int v26; // r12
  _BOOL4 v27; // r2
  float v28; // r3
  int v29; // r4
  unsigned int v30; // r3
  int v31; // r0
  int v32; // r1
  unsigned int v33; // r2
  int v34; // r1
  int v35; // r2
  int v36; // r12
  int v37; // r0
  int v38; // r1
  _DWORD *v39; // r3
  int v40; // r2
  bool v41; // zf
  int v42; // r2
  char v43; // r3
  int v44; // r3
  _BOOL4 v45; // r2
  int v46; // r7
  int v47; // r0
  int v48; // r3
  void *v49; // r0
  int v50; // r3
  char v51; // [sp+4h] [bp-28h]
  char v52; // [sp+4h] [bp-28h]
  int v53; // [sp+8h] [bp-24h]
  int v54; // [sp+10h] [bp-1Ch]
  int v55; // [sp+18h] [bp-14h]

  if ( !a1 )
    sub_6ECC0("ntp_monitor.c", 328, 0, "rbufp != ((void *)0)");
  if ( !mon_enabled )
    return a2 & 0xF7BF;
  v6 = sub_6C568((unsigned __int16 *)(a1 + 4));
  v7 = *(unsigned __int8 *)(a1 + 88);
  v51 = v7 & 7;
  v53 = (v7 >> 3) & 7;
  v8 = v6 & ~(-1 << mon_hash_bits);
  v9 = *(_DWORD *)(mon_hash + 4 * v8);
  v54 = 4 * v8;
  v10 = (int *)(mon_hash + 4 * v8);
  if ( v9 )
  {
    v11 = *(unsigned __int16 *)(a1 + 4);
    while ( 1 )
    {
      if ( *(unsigned __int16 *)(v9 + 44) != v11 )
        goto LABEL_7;
      if ( v11 == 2 )
      {
        if ( *(_DWORD *)(v9 + 48) == *(_DWORD *)(a1 + 8) )
          goto LABEL_12;
        v9 = *(_DWORD *)v9;
        if ( !v9 )
          break;
      }
      else
      {
        if ( !memcmp((const void *)(v9 + 52), (const void *)(a1 + 12), 0x10u)
          && *(_DWORD *)(v9 + 68) == *(_DWORD *)(a1 + 28) )
        {
LABEL_12:
          v12 = *(_WORD *)(a1 + 6);
          v13 = *(_DWORD *)(a1 + 72);
          v14 = *(_DWORD *)(a1 + 76);
          v15 = *(_DWORD *)(v9 + 4);
          v16 = *(_DWORD *)(v9 + 36) + 1;
          v17 = v13 - *(_DWORD *)(v9 + 24);
          v18 = *(_DWORD *)(v9 + 28);
          v19 = *(_DWORD *)(v9 + 8);
          *(_DWORD *)(v9 + 24) = v13;
          *(_DWORD *)(v9 + 28) = v14;
          *(_DWORD *)(v9 + 36) = v16;
          *(_BYTE *)(v9 + 42) = v51 | (8 * v53);
          *(_WORD *)(v9 + 46) = v12;
          v20 = v17 + ((__PAIR64__((v14 - v18) >> 31, v14) - v18) >> 32);
          *(_DWORD *)(v15 + 8) = v19;
          v21 = v20 + 1;
          v22 = *(_DWORD *)(v9 + 32);
          *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4) = v15;
          v23 = (v22 - v20) & ~((v22 - v20) >> 31);
          v24 = dword_108314;
          *(_DWORD *)(v9 + 4) = &mon_mru_list;
          *(_DWORD *)(v9 + 8) = v24;
          *(_DWORD *)(dword_108314 + 4) = v9;
          dword_108314 = v9;
          *(_DWORD *)(v9 + 32) = v23;
          v25 = 8 << ntp_minpoll;
          v26 = v23 + (1 << ntp_minpoll);
          v27 = v21 >= ntp_minpkt;
          if ( v26 >= 8 << ntp_minpoll )
            v27 = 0;
          if ( v27 )
          {
            *(_DWORD *)(v9 + 32) = v26 - 2;
            v4 = a2 & 0xF7BF;
          }
          else
          {
            if ( v23 < v25 )
              v4 = a2;
            else
              v4 = 63487;
            if ( v23 < v25 )
              *(_DWORD *)(v9 + 32) = (1 << ntp_minpoll) + v25;
            else
              v4 &= a2;
          }
          *(_WORD *)(v9 + 40) = v4;
          return v4;
        }
LABEL_7:
        v9 = *(_DWORD *)v9;
        if ( !v9 )
          break;
      }
    }
  }
  v28 = mru_entries;
  if ( LODWORD(mru_entries) >= (unsigned int)mru_mindepth )
  {
    v29 = dword_108310;
    v55 = dword_108310;
    v45 = dword_108310 != (_DWORD)&mon_mru_list;
    if ( !dword_108310 )
      v45 = 0;
    if ( v45 )
    {
      v46 = *(_DWORD *)(a1 + 72)
          - *(_DWORD *)(dword_108310 + 24)
          + ((__PAIR64__(
                (unsigned int)(*(_DWORD *)(a1 + 76) - *(_DWORD *)(dword_108310 + 28)) >> 31,
                *(_DWORD *)(a1 + 76))
            - *(unsigned int *)(dword_108310 + 28)) >> 32);
      if ( (int)mru_maxage < v46 )
      {
        v47 = dword_108310;
        v48 = *(_DWORD *)(dword_108310 + 4);
        v4 = a2 & 0xF7BF;
        *(_DWORD *)(v48 + 8) = *(_DWORD *)(dword_108310 + 8);
        *(_DWORD *)(*(_DWORD *)(v29 + 8) + 4) = v48;
        sub_30B44(v47);
        v49 = (void *)v29;
        goto LABEL_46;
      }
    }
    else
    {
      v55 = 0;
      v46 = 0;
    }
    v29 = dword_BAE94;
    if ( dword_BAE94 )
    {
LABEL_42:
      v4 = a2 & 0xF7BF;
      dword_BAE94 = *(_DWORD *)v29;
      goto LABEL_27;
    }
    if ( mru_alloc < (unsigned int)mru_maxdepth )
    {
      sub_30A38();
      v29 = dword_BAE94;
      if ( !dword_BAE94 )
        goto LABEL_48;
      v10 = (int *)(mon_hash + v54);
      v28 = mru_entries;
      goto LABEL_42;
    }
    if ( (double)(int)sub_68AE4() * 1.16415322e-10 > (double)v46 / (double)(int)mon_age )
      return a2 & 0xF7BF;
    v4 = a2 & 0xF7BF;
    v50 = *(_DWORD *)(v55 + 4);
    *(_DWORD *)(v50 + 8) = *(_DWORD *)(v55 + 8);
    *(_DWORD *)(*(_DWORD *)(v55 + 8) + 4) = v50;
    sub_30B44(v55);
    v49 = (void *)v55;
    v29 = v55;
LABEL_46:
    memset(v49, 0, 0x48u);
    v10 = (int *)(mon_hash + v54);
    v28 = mru_entries;
    goto LABEL_27;
  }
  v29 = dword_BAE94;
  if ( !dword_BAE94 )
  {
    sub_30A38();
    v29 = dword_BAE94;
    if ( !dword_BAE94 )
LABEL_48:
      sub_6ECC0("ntp_monitor.c", 471, 2, "mon != ((void *)0)");
  }
  v4 = a2 & 0xF7BF;
  dword_BAE94 = *(_DWORD *)v29;
  v10 = (int *)(mon_hash + v54);
  v28 = mru_entries;
LABEL_27:
  v30 = LODWORD(v28) + 1;
  LODWORD(mru_entries) = v30;
  v52 = v51 | (8 * v53);
  v31 = *(_DWORD *)(a1 + 72);
  v32 = *(_DWORD *)(a1 + 76);
  v33 = mru_peakentries;
  *(_DWORD *)(v29 + 24) = v31;
  *(_DWORD *)(v29 + 28) = v32;
  *(_DWORD *)(v29 + 16) = v31;
  *(_DWORD *)(v29 + 20) = v32;
  *(_WORD *)(v29 + 40) = v4;
  if ( v33 >= v30 )
    v30 = v33;
  *(_DWORD *)(v29 + 36) = 1;
  *(_DWORD *)(v29 + 32) = 0;
  mru_peakentries = v30;
  v34 = *(_DWORD *)(a1 + 8);
  v35 = *(_DWORD *)(a1 + 12);
  v36 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(v29 + 44) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(v29 + 48) = v34;
  *(_DWORD *)(v29 + 52) = v35;
  *(_DWORD *)(v29 + 56) = v36;
  v37 = *(_DWORD *)(a1 + 20);
  v38 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(v29 + 68) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(v29 + 60) = v37;
  *(_DWORD *)(v29 + 64) = v38;
  *(_BYTE *)(v29 + 42) = v52;
  v39 = *(_DWORD **)(a1 + 60);
  v40 = v39[36];
  *(_DWORD *)(v29 + 12) = v39;
  v41 = (v40 & 0x40) == 0;
  v42 = *(_DWORD *)(a1 + 64);
  if ( v41 || v42 != v39[3] )
  {
    if ( v39[4] == v42 )
      v43 = 4;
    else
      v43 = 1;
  }
  else
  {
    v43 = 2;
  }
  *(_BYTE *)(v29 + 43) = v43;
  *(_DWORD *)v29 = *v10;
  *v10 = v29;
  v44 = dword_108314;
  *(_DWORD *)(v29 + 4) = &mon_mru_list;
  *(_DWORD *)(v29 + 8) = v44;
  *(_DWORD *)(dword_108314 + 4) = v29;
  dword_108314 = v29;
  return v4;
}
// B5D2C: using guessed type int *mru_maxdepth_ptr;
// B6B20: using guessed type _UNKNOWN *mon_age;
// B6B24: using guessed type int mru_maxdepth;
// B6B28: using guessed type int *mru_maxage;
// B6B2C: using guessed type _UNKNOWN *mru_mindepth;
// B6B30: using guessed type char ntp_minpoll;
// B6B34: using guessed type int ntp_minpkt;
// BAE94: using guessed type int dword_BAE94;
// 108310: using guessed type int dword_108310;
// 108314: using guessed type int dword_108314;
// 108354: using guessed type float mru_entries;
// 108358: using guessed type int mon_enabled;
// 10835C: using guessed type int mru_peakentries;
// 108360: using guessed type int mon_hash;
// 108364: using guessed type char mon_hash_bits;
// 108368: using guessed type int mru_alloc;

//----- (00031634) --------------------------------------------------------
int __fastcall sub_31634(unsigned __int16 *s, int a2)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  int v7; // r12
  unsigned __int16 *v8; // r7
  int v9; // r12
  int v10; // r8
  unsigned __int16 *v11; // r1
  unsigned __int16 *v12; // r3
  _DWORD *v13; // r1
  const char *v14; // r0
  int v15; // r12
  int v16; // r8
  unsigned __int16 *v17; // r1
  unsigned __int16 *v18; // r3
  _DWORD *v19; // r1
  const char *v20; // r0
  int *v21; // r3
  int *v22; // r1
  unsigned __int16 *v23; // r3
  const char *v24; // r0
  int v25; // [sp+4h] [bp-4h]

  if ( a2 )
  {
    v8 = s + 8;
    v9 = sub_6C568(s + 8) & 0x7F;
    v10 = peer_hash_count[v9];
    peer_hash_count[v9] = v10 - 1;
    v11 = (unsigned __int16 *)peer_hash[v9];
    if ( s == v11 )
    {
      v13 = &peer_hash[v9];
    }
    else
    {
      if ( !v11 || (v12 = (unsigned __int16 *)*((_DWORD *)v11 + 1)) == 0 )
      {
LABEL_18:
        peer_hash_count[v9] = v10;
        v14 = sub_6C2E8(v8);
        sub_64E00(3, "peer %s not in address table!", v14);
LABEL_19:
        v15 = s[30] & 0x7F;
        v16 = assoc_hash_count[v15];
        assoc_hash_count[v15] = v16 - 1;
        v17 = (unsigned __int16 *)assoc_hash[v15];
        if ( s == v17 )
        {
          v19 = &assoc_hash[v15];
        }
        else
        {
          if ( !v17 || (v18 = (unsigned __int16 *)*((_DWORD *)v17 + 2)) == 0 )
          {
LABEL_28:
            assoc_hash_count[v15] = v16;
            v20 = sub_6C2E8(v8);
            sub_64E00(3, "peer %s not in association ID table!", v20);
LABEL_29:
            v21 = &peer_list;
            v22 = (int *)peer_list;
            if ( s != (unsigned __int16 *)peer_list )
            {
              if ( !peer_list || (v23 = *(unsigned __int16 **)peer_list) == 0 )
              {
LABEL_38:
                v24 = sub_6C2E8(v8);
                sub_64E00(3, "%s not in peer list!", v24);
                goto LABEL_2;
              }
              while ( s != v23 )
              {
                v22 = (int *)v23;
                if ( !*(_DWORD *)v23 )
                  goto LABEL_38;
                v23 = *(unsigned __int16 **)v23;
              }
              v21 = v22;
              v22 = (int *)*v22;
            }
            *v21 = *v22;
            goto LABEL_2;
          }
          while ( s != v18 )
          {
            v17 = v18;
            if ( !*((_DWORD *)v18 + 2) )
              goto LABEL_28;
            v18 = (unsigned __int16 *)*((_DWORD *)v18 + 2);
          }
          v19 = v17 + 4;
        }
        *v19 = *(_DWORD *)(*v19 + 8);
        goto LABEL_29;
      }
      while ( v12 != s )
      {
        v11 = v12;
        if ( !*((_DWORD *)v12 + 1) )
          goto LABEL_18;
        v12 = (unsigned __int16 *)*((_DWORD *)v12 + 1);
      }
      v13 = v11 + 2;
    }
    *v13 = *(_DWORD *)(*v13 + 4);
    goto LABEL_19;
  }
LABEL_2:
  v3 = (void *)*((_DWORD *)s + 11);
  if ( v3 )
    free(v3);
  v4 = (void *)*((_DWORD *)s + 20);
  if ( v4 )
    free(v4);
  v5 = (void *)*((_DWORD *)s + 12);
  if ( v5 )
    free(v5);
  memset(s, 0, 0x308u);
  v7 = dword_BAE98;
  dword_BAE98 = (int)s;
  *(_DWORD *)s = v7;
  ++peer_free_count;
  return v25;
}
// 316A8: variable 'v25' is possibly undefined
// BAE98: using guessed type int dword_BAE98;
// 10836C: using guessed type _DWORD assoc_hash[128];
// 10856C: using guessed type int peer_free_count;
// 108580: using guessed type _DWORD peer_hash[128];
// 108780: using guessed type _DWORD assoc_hash_count[128];
// 10898C: using guessed type _DWORD peer_hash_count[128];
// 108B8C: using guessed type int peer_list;

//----- (000318D8) --------------------------------------------------------
int __fastcall sub_318D8(unsigned int a1, __int16 a2)
{
  _BOOL4 v2; // lr
  int v3; // r2

  v2 = (a2 & 0x200) == 0;
  if ( (a2 & 0x1000) != 0 )
    v3 = v2 + 1;
  else
    v3 = v2 + 2;
  if ( (a2 & 0x800) == 0 )
    ++v3;
  if ( (a2 & 0x400) == 0 )
    ++v3;
  if ( a1 > 2 && a1 != 5 )
    ++v3;
  return v3;
}

//----- (00031958) --------------------------------------------------------
int sub_31958()
{
  int result; // r0

  dword_BBDC8 = (int)&dword_BC0D0;
  dword_BBAC0 = (int)&dword_BBDC8;
  dword_BB7B8 = (int)&dword_BBAC0;
  dword_BB4B0 = (int)&dword_BB7B8;
  dword_BB1A8 = (int)&dword_BB4B0;
  dword_BAEA0 = (int)&dword_BB1A8;
  dword_BC0D0 = (int)&dword_BC3D8;
  dword_BC3D8 = dword_BAE98;
  dword_BAE98 = (int)&dword_BAEA0;
  total_peer_structs = 8;
  peer_free_count = 8;
  do
  {
    result = (unsigned __int16)sub_68AE4();
    word_BAE9C = result;
  }
  while ( !(_WORD)result );
  word_BAE9E = result;
  return result;
}
// BAE98: using guessed type int dword_BAE98;
// BAE9C: using guessed type __int16 word_BAE9C;
// BAE9E: using guessed type __int16 word_BAE9E;
// BAEA0: using guessed type int dword_BAEA0;
// BB1A8: using guessed type int dword_BB1A8;
// BB4B0: using guessed type int dword_BB4B0;
// BB7B8: using guessed type int dword_BB7B8;
// BBAC0: using guessed type int dword_BBAC0;
// BBDC8: using guessed type int dword_BBDC8;
// BC0D0: using guessed type int dword_BC0D0;
// BC3D8: using guessed type int dword_BC3D8;
// 10856C: using guessed type int peer_free_count;
// 108980: using guessed type int total_peer_structs;

//----- (00031A44) --------------------------------------------------------
int __fastcall sub_31A44(unsigned __int16 *a1, const char *a2, int *a3, int a4, char a5, _DWORD *a6)
{
  int v9; // r6
  int v10; // r4
  const char *v11; // r0
  int v12; // r3
  bool v13; // zf
  int v15; // r3
  int v16; // r3

  if ( !a2 )
  {
    if ( a3 )
      v10 = a3[1];
    else
      v10 = peer_hash[sub_6C568(a1) & 0x7F];
    if ( v10 )
    {
      while ( 1 )
      {
        if ( a6 )
        {
          v15 = *(unsigned __int16 *)(v10 + 16);
          if ( v15 == *a1 )
          {
            if ( v15 == 2 )
            {
              if ( *((_DWORD *)a1 + 1) == *(_DWORD *)(v10 + 20) )
                ++*a6;
            }
            else if ( !memcmp(a1 + 4, (const void *)(v10 + 24), 0x10u) && *((_DWORD *)a1 + 6) == *(_DWORD *)(v10 + 40) )
            {
              ++*a6;
            }
          }
        }
        if ( (a4 == -1 || a4 == *(unsigned __int8 *)(v10 + 63) || (*(_BYTE *)(v10 + 72) & 0x20) != 0 && (a5 & 0x20) != 0)
          && a1[1] == *(unsigned __int16 *)(v10 + 18) )
        {
          v16 = *(unsigned __int16 *)(v10 + 16);
          if ( v16 == *a1 )
          {
            if ( v16 == 2 )
            {
              if ( *((_DWORD *)a1 + 1) == *(_DWORD *)(v10 + 20) )
                return v10;
            }
            else if ( !memcmp(a1 + 4, (const void *)(v10 + 24), 0x10u) && *((_DWORD *)a1 + 6) == *(_DWORD *)(v10 + 40) )
            {
              return v10;
            }
          }
        }
        v10 = *(_DWORD *)(v10 + 4);
        if ( !v10 )
          return 0;
      }
    }
    return 0;
  }
  v9 = *a1;
  if ( a3 )
    v10 = *a3;
  else
    v10 = peer_list;
  if ( !v10 )
    return 0;
  while ( 1 )
  {
    v11 = *(const char **)(v10 + 44);
    if ( v11 && (a4 == -1 || a4 == *(unsigned __int8 *)(v10 + 63)) )
    {
      if ( !v9 )
        goto LABEL_49;
      v12 = *(unsigned __int16 *)(v10 + 16);
      v13 = v12 == 0;
      if ( *(_WORD *)(v10 + 16) )
        v13 = v9 == v12;
      if ( v13 )
      {
LABEL_49:
        if ( !strcasecmp(v11, a2) )
          return v10;
      }
    }
    v10 = *(_DWORD *)v10;
    if ( !v10 )
      return 0;
  }
}
// 1BC: using guessed type int elf_hash_bucket[521];
// 108580: using guessed type _DWORD peer_hash[128];
// 108B8C: using guessed type int peer_list;

//----- (00031C78) --------------------------------------------------------
int __fastcall sub_31C78(int a1)
{
  int i; // r3

  ++assocpeer_calls;
  for ( i = assoc_hash[a1 & 0x7F]; i; i = *(_DWORD *)(i + 8) )
  {
    if ( *(unsigned __int16 *)(i + 60) == a1 )
      break;
  }
  return i;
}
// 10836C: using guessed type _DWORD assoc_hash[128];
// 108570: using guessed type int assocpeer_calls;

//----- (00031D10) --------------------------------------------------------
int sub_31D10()
{
  int i; // r4
  int result; // r0

  for ( i = peer_list; i; i = *(_DWORD *)i )
  {
    while ( (*(_BYTE *)(i + 72) & 0x1E) != 0 )
    {
      i = *(_DWORD *)i;
      if ( !i )
        return result;
    }
    result = sub_36214(i, (int *)"STEP");
  }
  return result;
}
// 108B8C: using guessed type int peer_list;

//----- (00031DAC) --------------------------------------------------------
int __fastcall sub_31DAC(int a1)
{
  int v1; // r5
  int v2; // r7
  int i; // r4
  int v4; // r0

  v1 = 100;
  v2 = sub_318D8(*(unsigned __int8 *)(a1 + 296), *(_DWORD *)(a1 + 300));
  for ( i = peer_list; i; i = *(_DWORD *)i )
  {
    if ( (*(_DWORD *)(i + 68) & 2) != 0 )
    {
      v4 = sub_318D8(*(unsigned __int8 *)(i + 296), *(_DWORD *)(i + 300));
      if ( v1 >= v4 )
        v1 = v4;
    }
  }
  if ( v2 == v1 )
    return v1;
  else
    return 0;
}
// 108B8C: using guessed type int peer_list;

//----- (00031E54) --------------------------------------------------------
char *__fastcall sub_31E54(char *result, int a2)
{
  char *v2; // r4
  int v3; // r3
  int v5; // r1
  int v6; // r3
  char *v7; // r2
  _DWORD *v8; // r3
  const char *v9; // r7
  const char *v10; // r8
  const char *v11; // r0
  __int64 v12; // r2

  v2 = result;
  if ( result )
  {
    v3 = *((_DWORD *)result + 14);
    if ( v3 != a2 )
    {
      if ( a2 )
      {
        if ( (*((_DWORD *)result + 17) & 0x10) != 0 && (*(_DWORD *)(a2 + 144) & 0x100) != 0 && result[63] == 3 )
          return result;
        if ( !v3 )
        {
          *((_DWORD *)result + 14) = a2;
LABEL_16:
          v12 = *(_QWORD *)(a2 + 184);
          *((_DWORD *)v2 + 3) = v12;
          *(_DWORD *)(a2 + 188) = HIDWORD(v12) + 1;
          *(_DWORD *)(a2 + 184) = v2;
          return result;
        }
      }
      else if ( !v3 )
      {
        return result;
      }
      v5 = *(_DWORD *)(v3 + 184);
      --*(_DWORD *)(v3 + 188);
      if ( result == (char *)v5 )
      {
        v8 = (_DWORD *)(v3 + 184);
        v7 = result;
      }
      else
      {
        if ( !v5 || (v6 = *(_DWORD *)(v5 + 12)) == 0 )
        {
LABEL_15:
          v9 = sub_6C2E8((unsigned __int16 *)result + 8);
          v10 = sub_18FB4(*((_DWORD *)v2 + 14));
          v11 = sub_18FB4(a2);
          result = sub_64E00(6, "%s local addr %s -> %s", v9, v10, v11);
          *((_DWORD *)v2 + 14) = a2;
          if ( !a2 )
            return result;
          goto LABEL_16;
        }
        while ( (char *)v6 != result )
        {
          v5 = v6;
          if ( !*(_DWORD *)(v6 + 12) )
            goto LABEL_15;
          v6 = *(_DWORD *)(v6 + 12);
        }
        v7 = *(char **)(v5 + 12);
        v8 = (_DWORD *)(v5 + 12);
      }
      *v8 = *((_DWORD *)v7 + 3);
      goto LABEL_15;
    }
  }
  return result;
}

//----- (00031FC4) --------------------------------------------------------
int __fastcall sub_31FC4(int a1)
{
  int v2; // r1

  sub_262E8((_WORD *)&dword_80 + 1, a1, "assoc %u", *(unsigned __int16 *)(a1 + 60));
  sub_40824((unsigned __int16 *)(a1 + 16), 1, 0);
  sub_31E54((char *)a1, 0);
  v2 = *(_DWORD *)(a1 + 68);
  ++peer_demobilizations;
  --peer_associations;
  if ( (v2 & 2) != 0 )
    --peer_preempt;
  if ( (v2 & 8) != 0 )
    sub_39640(a1);
  return sub_31634((unsigned __int16 *)a1, 1);
}
// 80: using guessed type int dword_80;
// 108578: using guessed type int peer_associations;
// 108988: using guessed type int peer_demobilizations;
// 108B90: using guessed type int peer_preempt;

//----- (000320B4) --------------------------------------------------------
void sub_320B4()
{
  int i; // r4
  char *v1; // r0
  int v2; // r8
  int v3; // r3
  bool v4; // zf
  char v5; // r3

  for ( i = peer_list; i; i = *(_DWORD *)i )
  {
    if ( !*(_DWORD *)(i + 56) || (*(_BYTE *)(i + 298) & 3) == 0 )
    {
      v1 = sub_18C28(i, i + 16, 0);
      v2 = *(_DWORD *)(i + 56);
      sub_31E54((char *)i, (int)v1);
      v3 = *(_DWORD *)(i + 56);
      if ( v3 )
      {
        v4 = v2 == v3;
        v5 = *(_BYTE *)(i + 72);
        if ( !v4 && (*(_BYTE *)(i + 72) & 0x10) == 0 && *(_BYTE *)(i + 92) != 5 )
        {
          sub_36214(i, (int *)"XFAC");
          v5 = *(_BYTE *)(i + 72);
        }
        if ( (v5 & 4) != 0 )
        {
          sub_16020(*(_DWORD *)(i + 56), (unsigned __int16 *)(i + 16));
          v5 = *(_BYTE *)(i + 72);
        }
        if ( (v5 & 2) != 0 )
          sub_160C4(*(_DWORD *)(i + 56), (unsigned __int16 *)(i + 16));
      }
    }
  }
}
// 108B8C: using guessed type int peer_list;

//----- (000321D4) --------------------------------------------------------
char *__fastcall sub_321D4(
        int a1,
        const char *a2,
        char *a3,
        int a4,
        unsigned __int8 a5,
        char a6,
        unsigned __int8 a7,
        unsigned __int8 a8,
        int a9,
        unsigned __int8 a10,
        int a11,
        unsigned int a12,
        const char *a13)
{
  char *v16; // r10
  int v17; // r0
  int v18; // r2
  char *v19; // r3
  int v20; // r0
  char *v21; // r0
  int v23; // r0
  __int16 v24; // r3
  int v25; // r1
  int v26; // r2
  int v27; // r3
  int v28; // r1
  int v29; // r2
  char *v30; // r0
  unsigned int v31; // r3
  unsigned int v32; // r2
  int v33; // r0
  int v34; // r3
  int v35; // r0
  int v36; // r2
  int v37; // r3
  int v38; // r12
  int v39; // r3
  char *v40; // [sp+Ch] [bp-38h]
  int v41; // [sp+10h] [bp-34h]
  int v43; // [sp+38h] [bp-Ch] BYREF

  v43 = 0;
  v16 = (char *)crypto_flags;
  if ( !crypto_flags )
  {
    if ( a12 >= 0x10000 )
      return 0;
    if ( (a9 & 0x800) != 0 )
    {
      sub_64E00(3, "Autokey not configured");
      return v16;
    }
  }
  if ( a2 && (a10 & 8) == 0 )
    sub_6ECC0("ntp_peer.c", 801, 2, "((void *)0) == hostname || (0x08 & cast_flags)");
  if ( !a3 )
  {
    if ( !sub_31A44((unsigned __int16 *)a1, a2, 0, a5, a10, &v43) )
      goto LABEL_21;
    return 0;
  }
  v17 = sub_31A44((unsigned __int16 *)a1, a2, 0, a5, a10, &v43);
  v18 = v17;
  if ( v17 )
  {
    v19 = *(char **)(v17 + 56);
    if ( a3 != v19 )
    {
      while ( 1 )
      {
        if ( (a10 & 0x20) != 0 && (*(_BYTE *)(v18 + 72) & 0x20) != 0 )
          return 0;
        if ( *(_WORD *)a1 == 2 )
        {
          if ( (char *)any_interface == a3 )
          {
LABEL_17:
            v41 = v18;
            v40 = v19;
            v21 = sub_178F8((const struct sockaddr *)a1);
            v18 = v41;
            if ( v40 == v21 )
              return 0;
          }
        }
        else if ( (char *)any6_interface == a3 )
        {
          goto LABEL_17;
        }
        v20 = sub_31A44((unsigned __int16 *)a1, a2, (int *)v18, a5, a10, &v43);
        v18 = v20;
        if ( !v20 )
          goto LABEL_21;
        v19 = *(char **)(v20 + 56);
        if ( v19 == a3 )
          return 0;
      }
    }
    return 0;
  }
LABEL_21:
  if ( a4 >= 0 && v43 >= a4 )
    return 0;
  if ( peer_free_count )
  {
    v16 = (char *)dword_BAE98;
    if ( !dword_BAE98 )
      sub_6ECC0("ntp_peer.c", 878, 2, "peer != ((void *)0)");
  }
  else
  {
    v16 = (char *)sub_63C68(0, 4u, 0x308u, 0);
    *((_DWORD *)v16 + 582) = dword_BAE98;
    *((_DWORD *)v16 + 388) = v16 + 2328;
    *((_DWORD *)v16 + 194) = v16 + 1552;
    *(_DWORD *)v16 = v16 + 776;
    peer_free_count += 4;
    total_peer_structs += 4;
  }
  v23 = *(_DWORD *)v16;
  --peer_free_count;
  dword_BAE98 = v23;
  ++peer_associations;
  if ( (a9 & 2) != 0 )
    ++peer_preempt;
  v24 = word_BAE9C + 1;
  *((_WORD *)v16 + 30) = word_BAE9C;
  if ( !v24 )
    v24 = 1;
  word_BAE9C = v24;
  v25 = *(_DWORD *)(a1 + 4);
  v26 = *(_DWORD *)(a1 + 8);
  v27 = *(_DWORD *)(a1 + 12);
  *((_DWORD *)v16 + 4) = *(_DWORD *)a1;
  *((_DWORD *)v16 + 5) = v25;
  *((_DWORD *)v16 + 6) = v26;
  *((_DWORD *)v16 + 7) = v27;
  v28 = *(_DWORD *)(a1 + 20);
  v29 = *(_DWORD *)(a1 + 24);
  *((_DWORD *)v16 + 8) = *(_DWORD *)(a1 + 16);
  *((_DWORD *)v16 + 9) = v28;
  *((_DWORD *)v16 + 10) = v29;
  if ( a2 )
    *((_DWORD *)v16 + 11) = sub_63D08(a2);
  v16[63] = a5;
  v16[72] = a10;
  v16[62] = a6;
  *((_DWORD *)v16 + 17) = a9;
  v30 = sub_18C28((int)v16, a1, a3);
  sub_31E54(v16, (int)v30);
  if ( a7 )
  {
    v31 = a7;
    if ( a7 >= 0x11u )
      v31 = 17;
    v16[65] = v31;
  }
  else
  {
    v31 = 6;
    v16[65] = 6;
  }
  if ( a8 )
  {
    v32 = a8;
    if ( a8 < 3u )
      v32 = 3;
    v16[66] = v32;
  }
  else
  {
    v32 = 10;
    v16[66] = 10;
  }
  v33 = *((_DWORD *)v16 + 14);
  if ( v31 > v32 )
    v16[65] = v32;
  v34 = (a10 >> 2) & 1;
  if ( !v33 )
    v34 = 0;
  if ( v34 )
    sub_16020(v33, (unsigned __int16 *)a1);
  if ( (a10 & 2) != 0 )
  {
    v35 = *((_DWORD *)v16 + 14);
    if ( v35 )
      sub_160C4(v35, (unsigned __int16 *)a1);
  }
  if ( a12 >= 0x10000 )
    *((_DWORD *)v16 + 17) |= 0x800u;
  *((_DWORD *)v16 + 19) = a11;
  *((_DWORD *)v16 + 31) = a12;
  if ( a13 )
    *((_DWORD *)v16 + 20) = sub_63D08(a13);
  v16[64] = v16[65];
  v16[95] = sys_precision;
  if ( (a10 & 0x10) != 0 )
  {
    sub_36214((int)v16, (int *)"ACST");
  }
  else if ( (a10 & 8) != 0 )
  {
    sub_36214((int)v16, (int *)"POOL");
  }
  else if ( (a10 & 2) != 0 )
  {
    sub_36214((int)v16, (int *)"MCST");
  }
  else if ( (a10 & 4) != 0 )
  {
    sub_36214((int)v16, (int *)"BCST");
  }
  else
  {
    sub_36214((int)v16, (int *)"INIT");
  }
  if ( mode_ntpdate )
    ++peer_ntpdate;
  v36 = *((unsigned __int16 *)v16 + 8);
  v37 = current_time;
  *((_DWORD *)v16 + 181) = current_time;
  *((_DWORD *)v16 + 184) = v37;
  *((_DWORD *)v16 + 183) = v37;
  if ( v36 != 2 || *((_WORD *)v16 + 10) != 32639 )
    goto LABEL_65;
  if ( !a8 )
    v16[66] = v16[65];
  if ( !sub_396D4((int)v16) )
  {
    sub_31E54(v16, 0);
    sub_31634((unsigned __int16 *)v16, 0);
    return 0;
  }
  else
  {
LABEL_65:
    v38 = sub_6C568((unsigned __int16 *)v16 + 8) & 0x7F;
    *((_DWORD *)v16 + 1) = peer_hash[v38];
    peer_hash[v38] = v16;
    v39 = *((_WORD *)v16 + 30) & 0x7F;
    ++peer_hash_count[v38];
    *((_DWORD *)v16 + 2) = assoc_hash[v39];
    assoc_hash[v39] = v16;
    ++assoc_hash_count[v39];
    *(_DWORD *)v16 = peer_list;
    peer_list = (int)v16;
    sub_40824((unsigned __int16 *)v16 + 8, 0, 0);
    sub_262E8((__int16 *)((char *)&dword_80 + 1), (int)v16, "assoc %d", *((unsigned __int16 *)v16 + 30));
  }
  return v16;
}
// 80: using guessed type int dword_80;
// B9920: using guessed type int crypto_flags;
// B9E84: using guessed type int mode_ntpdate;
// BAE98: using guessed type int dword_BAE98;
// BAE9C: using guessed type __int16 word_BAE9C;
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;
// 10836C: using guessed type _DWORD assoc_hash[128];
// 10856C: using guessed type int peer_free_count;
// 108578: using guessed type int peer_associations;
// 108580: using guessed type _DWORD peer_hash[128];
// 108780: using guessed type _DWORD assoc_hash_count[128];
// 108980: using guessed type int total_peer_structs;
// 10898C: using guessed type _DWORD peer_hash_count[128];
// 108B8C: using guessed type int peer_list;
// 108B90: using guessed type int peer_preempt;
// 108BA8: using guessed type char sys_precision;
// 108C04: using guessed type int peer_ntpdate;
// 108CA4: using guessed type int current_time;

//----- (00032898) --------------------------------------------------------
char *__fastcall sub_32898(
        _DWORD *a1,
        const char *a2,
        char *a3,
        int a4,
        unsigned __int8 a5,
        char a6,
        unsigned __int8 a7,
        unsigned __int8 a8,
        int a9,
        int a10,
        unsigned int a11,
        const char *a12)
{
  int v12; // r12
  unsigned __int8 v13; // r5
  int v14; // r12
  int v16; // r5
  bool v17; // zf
  int v18; // r5
  int v19; // r5
  int v20; // r5
  int v21; // r5
  _BOOL4 v22; // r5

  v12 = a9;
  if ( a5 == 3 )
  {
    v20 = *(unsigned __int16 *)a1;
    if ( a2 )
    {
      if ( v20 != 2 )
      {
        if ( !a1[2] && !a1[3] && !a1[4] && !a1[5] )
          goto LABEL_25;
        goto LABEL_34;
      }
      v21 = a1[1];
      if ( !v21 )
      {
LABEL_25:
        v13 = 8;
        goto LABEL_31;
      }
    }
    else
    {
      if ( v20 != 2 )
      {
LABEL_34:
        v22 = *((unsigned __int8 *)a1 + 8) == 255;
        goto LABEL_28;
      }
      v21 = a1[1];
    }
    v22 = (v21 & 0xF0) == 224;
LABEL_28:
    if ( !v22 )
    {
      v13 = 1;
LABEL_16:
      if ( mode_ntpdate )
        v12 = a9 | 0x100;
      goto LABEL_18;
    }
    v13 = 16;
LABEL_31:
    if ( mode_ntpdate )
      v12 = a9 | 0x100;
    v14 = v12 & 0xFFFFFFFC | 1;
    return sub_321D4((int)a1, a2, a3, a4, a5, a6, a7, a8, v14, v13, a10, a11, a12);
  }
  if ( a5 == 5 )
  {
    v16 = *(unsigned __int16 *)a1;
    v17 = v16 == 2;
    if ( v16 == 2 )
      v18 = a1[1];
    else
      v18 = *((unsigned __int8 *)a1 + 8);
    if ( v17 )
      v19 = (v18 & 0xF0) - 224;
    else
      v19 = v18 - 255;
    if ( v19 )
      v13 = 4;
    else
      v13 = 2;
    goto LABEL_16;
  }
  if ( !mode_ntpdate )
  {
    v13 = 1;
LABEL_18:
    v14 = v12 | 1;
    return sub_321D4((int)a1, a2, a3, a4, a5, a6, a7, a8, v14, v13, a10, a11, a12);
  }
  v13 = 1;
  v14 = a9 | 0x101;
  return sub_321D4((int)a1, a2, a3, a4, a5, a6, a7, a8, v14, v13, a10, a11, a12);
}
// B9E84: using guessed type int mode_ntpdate;

//----- (00032A70) --------------------------------------------------------
int *sub_32A70()
{
  findpeer_calls = 0;
  assocpeer_calls = 0;
  peer_allocations = 0;
  peer_demobilizations = 0;
  peer_timereset = current_time;
  return &current_time;
}
// 108570: using guessed type int assocpeer_calls;
// 108574: using guessed type int peer_timereset;
// 10857C: using guessed type int findpeer_calls;
// 108984: using guessed type int peer_allocations;
// 108988: using guessed type int peer_demobilizations;
// 108CA4: using guessed type int current_time;

//----- (00032B18) --------------------------------------------------------
_DWORD *__fastcall sub_32B18(_DWORD *result)
{
  int v1; // r2

  if ( result )
  {
    result[185] = 0;
    result[186] = 0;
    v1 = current_time;
    result[187] = 0;
    result[188] = 0;
    result[181] = v1;
    result[190] = 0;
    result[191] = 0;
    result[192] = 0;
    result[193] = 0;
  }
  return result;
}
// 108CA4: using guessed type int current_time;

//----- (00032B9C) --------------------------------------------------------
_DWORD *sub_32B9C()
{
  _DWORD *v0; // r4
  _DWORD *result; // r0

  v0 = (_DWORD *)peer_list;
  if ( peer_list )
  {
    do
    {
      result = sub_32B18(v0);
      v0 = (_DWORD *)*v0;
    }
    while ( v0 );
  }
  return result;
}
// 108B8C: using guessed type int peer_list;

//----- (00032C0C) --------------------------------------------------------
int *__fastcall sub_32C0C(int a1)
{
  int *v1; // r3
  unsigned int v2; // r1

  v1 = &peer_list;
  while ( 1 )
  {
    v1 = (int *)*v1;
    if ( !v1 )
      break;
    if ( (v1[18] & 0x18) != 0 )
    {
      v2 = bswap32(*(_DWORD *)(a1 + 116));
      if ( v1[146] == bswap32(*(_DWORD *)(a1 + 112)) && v1[147] == v2 )
        break;
    }
  }
  return v1;
}
// 108B8C: using guessed type int peer_list;

//----- (00032CA0) --------------------------------------------------------
int __fastcall sub_32CA0(int a1, int a2, int *a3)
{
  int i; // r4
  int v7; // r5
  int v8; // r3
  _BOOL4 v9; // r3
  int v10; // r3
  bool v11; // zf
  unsigned int v13; // r2

  ++findpeer_calls;
  for ( i = peer_hash[sub_6C568((unsigned __int16 *)(a1 + 4)) & 0x7F]; i; i = *(_DWORD *)(i + 4) )
  {
    v7 = *(unsigned __int8 *)(i + 63);
    if ( v7 != 6 && *(_DWORD *)(i + 56) != *(_DWORD *)(a1 + 60) )
      continue;
    if ( *(unsigned __int16 *)(a1 + 6) != *(unsigned __int16 *)(i + 18) )
      continue;
    v8 = *(unsigned __int16 *)(i + 16);
    if ( v8 != *(unsigned __int16 *)(a1 + 4) )
      continue;
    if ( v8 == 2 )
    {
      v9 = *(_DWORD *)(a1 + 8) != *(_DWORD *)(i + 20);
    }
    else
    {
      if ( memcmp((const void *)(a1 + 12), (const void *)(i + 24), 0x10u) )
        continue;
      v9 = *(_DWORD *)(a1 + 28) != *(_DWORD *)(i + 40);
    }
    if ( !v9 )
    {
      v10 = AM[7 * v7 + a2];
      v11 = v10 == 1;
      if ( v10 == 1 )
        v11 = a2 == 4;
      *a3 = v10;
      if ( v11 )
      {
        v13 = bswap32(*(_DWORD *)(a1 + 116));
        if ( *(_DWORD *)(i + 584) == bswap32(*(_DWORD *)(a1 + 112)) && *(_DWORD *)(i + 588) == v13 )
          return i;
        if ( sub_32C0C(a1) )
        {
          i = 0;
          *a3 = -1;
          return i;
        }
        v10 = *a3;
      }
      if ( v10 == -1 )
        return 0;
      if ( v10 )
        return i;
    }
  }
  i = 0;
  *a3 = AM[a2];
  return i;
}
// B6B40: using guessed type _DWORD AM[50];
// 10857C: using guessed type int findpeer_calls;
// 108580: using guessed type _DWORD peer_hash[128];

//----- (00032E6C) --------------------------------------------------------
int sub_32E6C()
{
  int v0; // r4
  int i; // r0
  int v2; // r0
  int result; // r0

  v0 = (unsigned __int16)word_BAE9E;
  for ( i = (unsigned __int16)word_BAE9C; (unsigned __int16)word_BAE9C != v0; v0 = (unsigned __int16)(v0 + 1) )
  {
    if ( v0 )
    {
      v2 = sub_31C78(v0);
      if ( v2 )
        sub_31FC4(v2);
    }
    i = (unsigned __int16)word_BAE9C;
  }
  result = sub_31C78(i);
  if ( result )
    return sub_31FC4(result);
  return result;
}
// BAE9C: using guessed type __int16 word_BAE9C;
// BAE9E: using guessed type __int16 word_BAE9E;

//----- (00032F28) --------------------------------------------------------
int sub_32F28()
{
  int v1; // [sp+4h] [bp-8h]

  return v1;
}
// 32F98: variable 'v1' is possibly undefined
// 108CA4: using guessed type int current_time;

//----- (00032FE4) --------------------------------------------------------
int __fastcall sub_32FE4(int a1)
{
  double v1; // d0
  int v3; // r5
  int v4; // r5
  double v6; // r0
  int v7; // r2
  int v8; // r0
  char *v9; // r0

  if ( *(_BYTE *)(a1 + 91) == 3 || (v3 = *(unsigned __int8 *)(a1 + 93), v3 < sys_floor) )
  {
    v4 = 512;
    if ( (*(_DWORD *)(a1 + 68) & 8) != 0 )
      goto LABEL_4;
  }
  else
  {
    if ( v3 < sys_ceiling )
      v4 = 0;
    else
      v4 = 512;
    if ( (*(_DWORD *)(a1 + 68) & 8) != 0 )
    {
LABEL_4:
      if ( *(unsigned __int8 *)(a1 + 93) <= 1u )
        goto LABEL_5;
      goto LABEL_16;
    }
  }
  sub_32F28();
  LODWORD(v6) = *(unsigned __int8 *)(a1 + 64);
  ldexp(v6, v7);
  if ( v1 >= sys_maxdist + 1.0 * clock_phi )
    v4 |= 0x400u;
  if ( *(unsigned __int8 *)(a1 + 93) > 1u )
  {
LABEL_16:
    v8 = *(_DWORD *)(a1 + 56);
    if ( !v8 || (*(_DWORD *)(v8 + 144) & 0x100) != 0 )
    {
      v9 = sub_178F8((const struct sockaddr *)(a1 + 16));
      if ( v9 && *(_DWORD *)(a1 + 112) == *((_DWORD *)v9 + 38) )
        v4 |= 0x800u;
    }
    else if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(v8 + 152) )
    {
      v4 |= 0x800u;
    }
  }
LABEL_5:
  if ( !*(_BYTE *)(a1 + 298) || (*(_DWORD *)(a1 + 68) & 0x200) != 0 )
    v4 |= 0x1000u;
  *(_DWORD *)(a1 + 300) = *(_DWORD *)(a1 + 300) & 0xFFFFE1FF | v4;
  return v4;
}
// 330D0: variable 'v6' is possibly undefined
// 330D0: variable 'v7' is possibly undefined
// 330FC: variable 'v1' is possibly undefined
// B6AF8: using guessed type double clock_phi;
// B6C30: using guessed type int sys_ceiling;
// B6C38: using guessed type double sys_maxdist;
// BC714: using guessed type int sys_floor;

//----- (00033174) --------------------------------------------------------
char *__fastcall sub_33174(int a1)
{
  int v2; // r4
  struct sockaddr *v3; // r6
  char *result; // r0
  char *v5; // r4
  char v6; // r1
  char v7; // r3
  int v8; // r1
  unsigned int v9; // r12
  unsigned int v10; // r2
  char v11; // r12
  int v12; // r2
  const char *v13; // r0
  void *v14; // r0
  int *v15; // r0
  int v16; // r4
  int v17; // lr
  __int16 v18; // [sp+8h] [bp-874h] BYREF
  int s[8]; // [sp+Ch] [bp-870h] BYREF
  unsigned int v20[530]; // [sp+2Ch] [bp-850h] BYREF

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 )
  {
    while ( 1 )
    {
      v3 = *(struct sockaddr **)(v2 + 20);
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(v2 + 28);
      result = (char *)sub_31A44(&v3->sa_family, 0, 0, 3, 0, 0);
      if ( !result )
        break;
      v2 = *(_DWORD *)(a1 + 52);
      if ( !v2 )
        return result;
    }
    sub_40054((unsigned int)v3, &v18);
    if ( (v18 & 0x7F) != 0 )
      sub_40824(&v3->sa_family, 0, current_time + 9);
    v5 = sub_178F8(v3);
    memset(v20, 0, sizeof(v20));
    v6 = *(_BYTE *)(a1 + 64);
    LOBYTE(v20[0]) = (8 * *(_BYTE *)(a1 + 62)) & 0x38 | (sys_leap << 6) | 3;
    BYTE2(v20[0]) = v6;
    v7 = sys_stratum;
    if ( sys_stratum == 16 )
      v7 = 0;
    BYTE1(v20[0]) = v7;
    HIBYTE(v20[0]) = sys_precision;
    v20[3] = sys_refid;
    v20[1] = bswap32((int)(sys_rootdelay * 65536.0));
    v20[2] = bswap32((unsigned int)(sys_rootdisp * 65536.0));
    v20[4] = bswap32(sys_reftime);
    v20[5] = bswap32(dword_108C0C);
    sub_5F724(s);
    v8 = s[1];
    v9 = bswap32(s[1]);
    v20[10] = bswap32(s[0]);
    *(_DWORD *)(a1 + 584) = s[0];
    *(_DWORD *)(a1 + 588) = v8;
    v20[11] = v9;
    v10 = *(_DWORD *)(a1 + 76);
    if ( v10 >= sys_ttlmax )
      v10 = sys_ttlmax;
    sub_16A68(v3, (int)v5, (unsigned __int8)sys_ttl[v10], v20, 0x30u);
    v11 = *(_BYTE *)(a1 + 65);
    v12 = *(_DWORD *)(a1 + 712);
    ++*(_DWORD *)(a1 + 740);
    *(_DWORD *)(a1 + 712) = v12 + (1 << v11) - 2;
    v13 = sub_6C2E8(&v3->sa_family);
    return sub_64E00(6, "Soliciting pool server %s", v13);
  }
  else
  {
    v14 = *(void **)(a1 + 48);
    if ( v14 )
    {
      free(v14);
      *(_DWORD *)(a1 + 48) = 0;
    }
    v15 = (int *)memset(s, 0, sizeof(s));
    v16 = *(unsigned __int16 *)(a1 + 16);
    v17 = *(unsigned __int16 *)(a1 + 60);
    s[3] = 17;
    s[1] = v16;
    s[2] = 2;
    result = (char *)sub_68520(*(const char **)(a1 + 44), "ntp", v15, 0, (int)pool_name_resolved, v17);
    if ( result )
      return sub_64E00(3, "unable to start pool DNS %s: %m", *(const char **)(a1 + 44));
  }
  return result;
}
// 108BA8: using guessed type char sys_precision;
// 108BB8: using guessed type double sys_rootdisp;
// 108BC0: using guessed type char sys_leap;
// 108BC8: using guessed type double sys_rootdelay;
// 108BD0: using guessed type int sys_refid;
// 108BF8: using guessed type int sys_ttlmax;
// 108C08: using guessed type int sys_reftime;
// 108C0C: using guessed type int dword_108C0C;
// 108C14: using guessed type char sys_stratum;
// 108CA4: using guessed type int current_time;

//----- (000334B0) --------------------------------------------------------
char *__fastcall pool_name_resolved(int a1, int a2, unsigned __int16 a3, int a4, int a5, int a6, int a7)
{
  int v9; // r5
  char *v10; // r0
  const char *v12; // r3

  if ( a1 )
  {
    v12 = gai_strerror(a1);
    return sub_64E00(3, "error resolving pool %s: %s (%d)", a4, v12);
  }
  else
  {
    v9 = sub_31C78(a3);
    if ( v9 )
    {
      v10 = sub_68EBC(a7);
      *(_DWORD *)(v9 + 48) = v10;
      *(_DWORD *)(v9 + 52) = v10;
      return (char *)sub_33174(v9);
    }
    else
    {
      return sub_64E00(3, "Could not find assoc %u for pool DNS %s", a3, a4);
    }
  }
}
// 33174: using guessed type int __fastcall sub_33174(_DWORD);

//----- (000335A4) --------------------------------------------------------
int __fastcall sub_335A4(int result)
{
  sys_leap = result;
  xmt_leap = result;
  if ( result != 3 )
  {
    if ( leap_sec_in_progress )
      xmt_leap = 3;
  }
  return result;
}
// 108BC0: using guessed type char sys_leap;
// 108C34: using guessed type char xmt_leap;
// 108C50: using guessed type int leap_sec_in_progress;

//----- (0003362C) --------------------------------------------------------
int __fastcall sub_3362C(int a1, int a2, int a3, int a4)
{
  bool v4; // zf
  char v5; // r0
  int result; // r0

  v4 = a1 == 3;
  if ( a1 == 3 )
    v4 = a2 == 16;
  v5 = v4;
  if ( a3 == 4 )
    result = v5 & 1;
  else
    result = 0;
  if ( result )
  {
    switch ( a4 )
    {
      case 1163149650:
        return 1;
      case 1498301764:
        return 2;
      case 1381258066:
        return 3;
      default:
        if ( (unsigned __int8)a4 == 88 )
          return 4;
        else
          return 0;
    }
  }
  return result;
}

//----- (000336EC) --------------------------------------------------------
int __fastcall sub_336EC(int *a1, _DWORD *a2, unsigned int a3)
{
  bool v4; // cc
  _BOOL4 v5; // r2
  int v6; // r12
  unsigned int v7; // r2
  unsigned int v8; // r1
  unsigned int v9; // r2
  unsigned int v10; // r1
  int v11; // r12
  int v12; // r0
  bool v13; // zf
  int v14; // r2

  if ( a2[21] != 52 )
    return 0;
  v4 = a3 > 4;
  if ( a3 != 4 )
    v4 = a3 - 1 > 1;
  if ( v4 )
    return 1;
  v5 = a1 == 0;
  if ( a2[34] )
    v5 = 1;
  if ( v5 || !a1[31] && (a1[17] & 0x800) == 0 )
    return 1;
  v6 = a1[79];
  v7 = a2[28];
  v8 = a2[29];
  v9 = bswap32(v7);
  if ( v6 > 0 )
    a1 += 148;
  v10 = bswap32(v8);
  if ( v6 <= 0 )
    a1 += 146;
  if ( !(v9 | v10) )
    return 1;
  v11 = *a1;
  v12 = a1[1];
  v13 = v10 == v12;
  if ( v10 == v12 )
    v13 = v9 == v11;
  v14 = !v13;
  if ( !(v11 | v12) )
    v14 = 1;
  if ( v14 )
    return 1;
  else
    return 2;
}

//----- (000337E4) --------------------------------------------------------
char *__fastcall sub_337E4(int a1)
{
  char *v1; // r5
  int v4; // r7

  switch ( a1 )
  {
    case -1:
      v1 = "AM_ERR";
      break;
    case 0:
      v1 = "AM_NOMATCH";
      break;
    case 1:
      v1 = "AM_PROCPKT";
      break;
    case 2:
      v1 = "AM_BCST";
      break;
    case 3:
      v1 = "AM_FXMIT";
      break;
    case 4:
      v1 = "AM_MANYCAST";
      break;
    case 5:
      v1 = "AM_NEWPASS";
      break;
    case 6:
      v1 = "AM_NEWBCL";
      break;
    case 7:
      v1 = "AM_POSSBCL";
      break;
    default:
      v1 = &lib_stringbuf[128 * lib_nextbuf];
      v4 = ((_BYTE)lib_nextbuf + 1) & 0xF;
      memset(v1, 0, 0x80u);
      lib_nextbuf = v4;
      sub_6C054((int)v1, 0x80u, "AM_#%d", a1);
      break;
  }
  return v1;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0003394C) --------------------------------------------------------
int __fastcall sub_3394C(_DWORD *a1)
{
  _DWORD *v2; // r0
  int v3; // r4
  int v5; // r3

  v2 = (_DWORD *)a1[60];
  if ( v2 )
  {
    if ( (int)a1[61] >= 0 )
    {
      v3 = 0;
      do
      {
        sub_621BC(v2[v3++], 0);
        v2 = (_DWORD *)a1[60];
      }
      while ( a1[61] >= v3 );
    }
    free(v2);
    a1[60] = 0;
  }
  sub_27B48(a1 + 68);
  v5 = a1[17];
  a1[61] = 0;
  a1[17] = v5 & 0xFFFF7FFF;
  return 0;
}

//----- (000339F8) --------------------------------------------------------
int __fastcall sub_339F8(double a1)
{
  int v1; // r4
  char v2; // r3
  char v3; // r2
  unsigned int v4; // r0
  char v5; // r3
  char v6; // r2
  unsigned int v7; // r0
  char v8; // r3
  unsigned int v9; // r1
  unsigned int v10; // r2
  int v11; // r2
  unsigned int v12; // r7
  int v13; // r3
  unsigned int v14; // r1
  size_t v15; // r10
  size_t v16; // r0
  unsigned int v17; // r7
  struct sockaddr *v18; // r0
  unsigned int v19; // r2
  int v20; // r1
  int v21; // r2
  char v22; // r12
  int v23; // r2
  int v24; // r3
  unsigned int v25; // r1
  _DWORD *v26; // r2
  __int64 v27; // r2
  double v28; // r0
  double v29; // d0
  int v30; // r2
  unsigned int v31; // r8
  int v32; // r3
  int v33; // r3
  unsigned int v34; // r2
  unsigned int v35; // r3
  int v36; // r3
  double v37; // r0
  double v38; // d0
  int v39; // r2
  int v40; // r1
  _DWORD *v41; // r10
  unsigned int *v42; // r12
  int v43; // r3
  int v44; // r2
  int v45; // r1
  unsigned int *v46; // r12
  int v47; // r3
  int v48; // r3
  unsigned int v49; // r1
  unsigned int v50; // r2
  unsigned int v51; // r2
  unsigned int v52; // r3
  unsigned int v53; // r2
  unsigned int v54; // r3
  unsigned int v55; // r2
  unsigned int v56; // r3
  int v57; // r0
  size_t n; // [sp+0h] [bp-86Ch]
  unsigned int v60; // [sp+Ch] [bp-860h] BYREF
  unsigned int v61; // [sp+10h] [bp-85Ch]
  int v62; // [sp+14h] [bp-858h] BYREF
  unsigned int v63; // [sp+18h] [bp-854h]
  unsigned int v64[6]; // [sp+1Ch] [bp-850h] BYREF
  unsigned int v65; // [sp+34h] [bp-838h]
  unsigned int v66; // [sp+38h] [bp-834h]
  unsigned int v67; // [sp+3Ch] [bp-830h]
  unsigned int v68; // [sp+40h] [bp-82Ch]
  unsigned int v69; // [sp+44h] [bp-828h]
  unsigned int v70; // [sp+48h] [bp-824h]

  if ( !*(_DWORD *)(LODWORD(a1) + 56) )
    return LODWORD(a1);
  v1 = LODWORD(a1);
  v2 = *(_BYTE *)(LODWORD(a1) + 63) & 7 | (sys_leap << 6);
  v3 = (8 * *(_BYTE *)(LODWORD(a1) + 62)) & 0x38;
  v4 = *(_DWORD *)(LODWORD(a1) + 560);
  v5 = v2 | v3;
  v6 = *(_BYTE *)(v1 + 64);
  LOBYTE(v64[0]) = v5;
  v7 = bswap32(v4);
  BYTE2(v64[0]) = v6;
  v8 = sys_stratum;
  if ( sys_stratum == 16 )
    v8 = 0;
  BYTE1(v64[0]) = v8;
  HIBYTE(v64[0]) = sys_precision;
  v9 = bswap32(*(_DWORD *)(v1 + 564));
  v64[3] = sys_refid;
  v10 = bswap32(*(_DWORD *)(v1 + 576));
  v64[1] = bswap32((int)(sys_rootdelay * 65536.0));
  v64[2] = bswap32((unsigned int)(sys_rootdisp * 65536.0));
  v65 = v7;
  v66 = v9;
  v67 = v10;
  v64[5] = bswap32(dword_108C0C);
  v64[4] = bswap32(sys_reftime);
  v11 = *(_DWORD *)(v1 + 68);
  v68 = bswap32(*(_DWORD *)(v1 + 580));
  if ( (v11 & 0x800) != 0 )
  {
    while ( 1 )
    {
      v32 = *(_DWORD *)(v1 + 244);
      if ( v32 )
      {
        v33 = v32 - 1;
        *(_DWORD *)(v1 + 244) = v33;
      }
      else
      {
        sub_27454(v1, *(_DWORD *)(v1 + 56));
        v33 = *(_DWORD *)(v1 + 244);
      }
      v31 = *(_DWORD *)(*(_DWORD *)(v1 + 240) + 4 * v33);
      if ( sub_622E0(v31) )
        break;
      sub_3394C((_DWORD *)v1);
    }
    v36 = *(unsigned __int8 *)(v1 + 63);
    *(_DWORD *)(v1 + 124) = v31;
    switch ( v36 )
    {
      case 1:
      case 2:
        v44 = *(_DWORD *)(v1 + 136);
        if ( !v44 )
          goto LABEL_93;
        if ( (v44 & 0x100) == 0 )
          goto LABEL_99;
        if ( (v44 & 0x200) == 0 )
          goto LABEL_100;
        if ( sys_leap != 3 && *(_BYTE *)(v1 + 91) != 3 && (v44 & 0x800) == 0 )
          goto LABEL_101;
        if ( (v44 & 0x1000) == 0 )
        {
          v41 = sub_2787C(v1, 33816576, *(unsigned __int16 *)(v1 + 60), 0);
          goto LABEL_43;
        }
        if ( (*(_DWORD *)(v1 + 68) & 0x8000) == 0 )
        {
          if ( sys_leap != 3 )
            goto LABEL_56;
          goto LABEL_71;
        }
        if ( (v44 & 0x2000) != 0 )
        {
          v41 = sub_2787C(v1, -2113667072, *(unsigned __int16 *)(v1 + 132), 0);
          goto LABEL_43;
        }
        if ( sys_leap == 3 )
          goto LABEL_71;
        goto LABEL_69;
      case 3:
        v44 = *(_DWORD *)(v1 + 136);
        if ( v44 )
        {
          if ( (v44 & 0x100) != 0 )
          {
            if ( (v44 & 0x200) != 0 )
            {
              if ( (v44 & 0x800) != 0 )
              {
                if ( (v44 & 0x1000) != 0 )
                {
                  if ( sys_leap == 3 )
                    goto LABEL_71;
LABEL_56:
                  if ( (v44 & 0x2000) != 0 )
                  {
                    if ( (v44 & 0x4000) == 0 )
                    {
                      v41 = sub_2787C(v1, 33882112, *(unsigned __int16 *)(v1 + 60), 0);
                      goto LABEL_43;
                    }
LABEL_71:
                    v46 = *(unsigned int **)(v1 + 232);
                    if ( !v46 )
                      goto LABEL_6;
                    *v46 |= 0x80u;
                    v12 = sub_29774(v1, (int)v64, 0, 48, v46, 0) + 48;
                    free(*(void **)(v1 + 232));
                    *(_DWORD *)(v1 + 232) = 0;
LABEL_48:
                    if ( v12 > 0x30 )
                      sub_272C8((_DWORD *)(*(_DWORD *)(v1 + 56) + 24), v1 + 16, v31, 0, 2u);
                    goto LABEL_7;
                  }
LABEL_69:
                  v45 = 33947648;
                  goto LABEL_94;
                }
                v41 = sub_2787C(v1, 33816576, *(unsigned __int16 *)(v1 + 132), 0);
              }
              else
              {
LABEL_101:
                v41 = sub_2787C(v1, 33751040, *(unsigned __int16 *)(v1 + 60), 0);
              }
            }
            else
            {
LABEL_100:
              v57 = sub_27774(v1);
              v41 = sub_2787C(v1, v57, *(unsigned __int16 *)(v1 + 60), 0);
            }
          }
          else
          {
LABEL_99:
            v41 = sub_2787C(v1, 33685504, *(unsigned __int16 *)(v1 + 60), *(char **)(v1 + 152));
          }
LABEL_43:
          v42 = *(unsigned int **)(v1 + 232);
          if ( v42 )
          {
            *v42 |= 0x80u;
            v12 = sub_29774(v1, (int)v64, 0, 48, v42, 0) + 48;
            free(*(void **)(v1 + 232));
            *(_DWORD *)(v1 + 232) = 0;
            if ( !v41 )
              goto LABEL_48;
            if ( !*v41 )
              goto LABEL_47;
            v43 = v12;
          }
          else
          {
            if ( !v41 )
              goto LABEL_6;
            if ( !*v41 )
            {
              v12 = 48;
              free(v41);
              goto LABEL_7;
            }
            v43 = 48;
            v12 = 48;
          }
          v12 += sub_29774(v1, (int)v64, 0, v43, v41, 0);
LABEL_47:
          free(v41);
          goto LABEL_48;
        }
LABEL_93:
        v45 = 33619968;
LABEL_94:
        v41 = sub_2787C(v1, v45, *(unsigned __int16 *)(v1 + 60), (char *)dword_108274);
        goto LABEL_43;
      case 5:
        LOWORD(v40) = 0;
        if ( (*(_DWORD *)(v1 + 68) & 0x8000) != 0 )
          HIWORD(v40) = -32252;
        else
          HIWORD(v40) = -32255;
        v41 = sub_2787C(v1, v40, *(unsigned __int16 *)(v1 + 60), 0);
        goto LABEL_43;
      default:
        goto LABEL_71;
    }
  }
  if ( *(_DWORD *)(v1 + 124) )
  {
LABEL_6:
    v12 = 48;
LABEL_7:
    sub_5F724((int *)&v60);
    v13 = *(_DWORD *)(v1 + 316);
    if ( v13 )
    {
      if ( *(_BYTE *)(v1 + 63) == 5 )
      {
        v69 = bswap32(v60);
        v70 = bswap32(v61);
        if ( v13 <= 0 )
        {
          v51 = *(_DWORD *)(v1 + 584);
          v52 = *(_DWORD *)(v1 + 588);
        }
        else
        {
          v51 = *(_DWORD *)(v1 + 592);
          v52 = *(_DWORD *)(v1 + 596);
        }
        v65 = bswap32(v51);
        v66 = bswap32(v52);
      }
      else
      {
        if ( v13 <= 0 )
        {
          v34 = *(_DWORD *)(v1 + 584);
          v35 = *(_DWORD *)(v1 + 588);
        }
        else
        {
          v34 = *(_DWORD *)(v1 + 592);
          v35 = *(_DWORD *)(v1 + 596);
        }
        v69 = bswap32(v34);
        v70 = bswap32(v35);
      }
    }
    else
    {
      v14 = v61;
      v69 = bswap32(v60);
      v70 = bswap32(v61);
      *(_DWORD *)(v1 + 584) = v60;
      *(_DWORD *)(v1 + 588) = v14;
    }
    v15 = *(_DWORD *)(v1 + 124);
    v16 = sub_6278C(v15, (int)v64, v12);
    if ( !v16 )
    {
      LODWORD(a1) = sub_25EE0((__int16 *)&dword_8C, v1, "no key");
      v47 = *(_DWORD *)(v1 + 752) + 1;
      *(_DWORD *)(v1 + 300) |= 0x10u;
      *(_DWORD *)(v1 + 752) = v47;
      return LODWORD(a1);
    }
    v17 = v12 + v16;
    if ( v15 >= 0x10000 )
      sub_621BC(v15, 0);
    if ( v17 > 0x848 )
    {
      sub_64E00(3, "peer_xmit: buffer overflow %zu", v17);
      exit(-1);
    }
    *(_DWORD *)(v1 + 664) = v17;
    v18 = (struct sockaddr *)(v1 + 16);
    v19 = *(_DWORD *)(v1 + 76);
    n = v17;
    v20 = *(_DWORD *)(v1 + 56);
    if ( v19 >= sys_ttlmax )
      v19 = sys_ttlmax;
    v21 = (unsigned __int8)sys_ttl[v19];
    goto LABEL_16;
  }
  sub_5F724((int *)&v60);
  v48 = *(_DWORD *)(v1 + 316);
  if ( v48 )
  {
    if ( *(_BYTE *)(v1 + 63) == 5 )
    {
      v69 = bswap32(v60);
      v70 = bswap32(v61);
      if ( v48 <= 0 )
      {
        v55 = *(_DWORD *)(v1 + 584);
        v56 = *(_DWORD *)(v1 + 588);
      }
      else
      {
        v55 = *(_DWORD *)(v1 + 592);
        v56 = *(_DWORD *)(v1 + 596);
      }
      v65 = bswap32(v55);
      v66 = bswap32(v56);
    }
    else
    {
      if ( v48 <= 0 )
      {
        v53 = *(_DWORD *)(v1 + 584);
        v54 = *(_DWORD *)(v1 + 588);
      }
      else
      {
        v53 = *(_DWORD *)(v1 + 592);
        v54 = *(_DWORD *)(v1 + 596);
      }
      v69 = bswap32(v53);
      v70 = bswap32(v54);
    }
  }
  else
  {
    v49 = v61;
    v69 = bswap32(v60);
    v70 = bswap32(v61);
    *(_DWORD *)(v1 + 584) = v60;
    *(_DWORD *)(v1 + 588) = v49;
  }
  *(_DWORD *)(v1 + 664) = 48;
  v50 = *(_DWORD *)(v1 + 76);
  n = 48;
  v18 = (struct sockaddr *)(v1 + 16);
  if ( v50 >= sys_ttlmax )
    v50 = sys_ttlmax;
  v20 = *(_DWORD *)(v1 + 56);
  v21 = (unsigned __int8)sys_ttl[v50];
LABEL_16:
  sub_16A68(v18, v20, v21, v64, n);
  v22 = *(_BYTE *)(v1 + 65);
  v23 = *(_DWORD *)(v1 + 712);
  ++*(_DWORD *)(v1 + 740);
  *(_DWORD *)(v1 + 712) = v23 + (1 << v22) - 2;
  sub_5F724(&v62);
  v24 = *(_DWORD *)(v1 + 316);
  if ( v24 )
  {
    v25 = v63;
    if ( v24 <= 0 )
      v26 = (_DWORD *)(v1 + 592);
    else
      v26 = (_DWORD *)(v1 + 584);
    *v26 = v62;
    v26[1] = v25;
    *(_DWORD *)(v1 + 316) = -v24;
  }
  HIDWORD(v27) = v62 - v60;
  if ( v63 < v61 )
    --HIDWORD(v27);
  LODWORD(v27) = v63 - v61;
  v62 = HIDWORD(v27);
  v63 -= v61;
  if ( v27 < 0 )
  {
    LODWORD(v38) = sub_8BEC4(-v27);
    HIDWORD(v38) = HIDWORD(v37);
    LODWORD(v37) = -32;
    a1 = ldexp(v37, v39);
    v29 = -v38;
  }
  else
  {
    LODWORD(v29) = sub_8BEC4(v27);
    HIDWORD(v29) = HIDWORD(v28);
    LODWORD(v28) = -32;
    a1 = ldexp(v28, v30);
  }
  *(double *)(v1 + 640) = v29;
  return LODWORD(a1);
}
// 33C8C: variable 'v28' is possibly undefined
// 33C94: variable 'v30' is possibly undefined
// 33D68: variable 'v37' is possibly undefined
// 33D70: variable 'v39' is possibly undefined
// 8C: using guessed type int dword_8C;
// 108274: using guessed type int dword_108274;
// 108BA8: using guessed type char sys_precision;
// 108BB8: using guessed type double sys_rootdisp;
// 108BC0: using guessed type char sys_leap;
// 108BC8: using guessed type double sys_rootdelay;
// 108BD0: using guessed type int sys_refid;
// 108BF8: using guessed type int sys_ttlmax;
// 108C08: using guessed type int sys_reftime;
// 108C0C: using guessed type int dword_108C0C;
// 108C14: using guessed type char sys_stratum;

//----- (00034264) --------------------------------------------------------
int __fastcall sub_34264(int a1, unsigned int a2)
{
  signed int v3; // r2
  unsigned int v4; // r5
  int v5; // r12
  int result; // r0
  int v7; // r3
  unsigned int v8; // r6
  unsigned int v9; // r3
  unsigned int v10; // r3
  unsigned int v11; // r3

  v3 = *(unsigned __int8 *)(a1 + 65);
  if ( *(unsigned __int8 *)(a1 + 66) < a2 )
    a2 = *(unsigned __int8 *)(a1 + 66);
  if ( v3 < (int)a2 )
    v4 = a2;
  else
    v4 = *(unsigned __int8 *)(a1 + 65);
  if ( (*(_DWORD *)(a1 + 68) & 0x800) != 0 && *(unsigned __int8 *)(a1 + 64) != v4 )
  {
    sub_3394C((_DWORD *)a1);
    LOBYTE(v3) = *(_BYTE *)(a1 + 65);
  }
  *(_BYTE *)(a1 + 64) = v4;
  v5 = *(_DWORD *)(a1 + 712);
  result = ntp_minpkt;
  v7 = v5 - (7 << v3);
  if ( v7 < ntp_minpkt )
    v8 = current_time + ntp_minpkt;
  else
    v8 = current_time + v7;
  if ( *(int *)(a1 + 308) <= 0 )
  {
    if ( *(_DWORD *)(a1 + 232) )
    {
      v9 = *(_DWORD *)(a1 + 720);
      if ( current_time >= v9 || (result = ntp_minpkt + v9, ntp_minpkt + v9 != v8) )
LABEL_21:
        *(_DWORD *)(a1 + 720) = v8;
    }
    else
    {
      if ( *(int *)(a1 + 312) <= 0 )
      {
        if ( *(unsigned __int8 *)(a1 + 94) < v4 )
          LOBYTE(v4) = *(_BYTE *)(a1 + 94);
      }
      else
      {
        LOBYTE(v4) = v3;
      }
      if ( (*(_DWORD *)(a1 + 68) & 8) != 0 )
      {
        v10 = 1 << v4;
      }
      else
      {
        result = (unsigned __int8)sub_68AE4();
        v5 = *(_DWORD *)(a1 + 712);
        LOBYTE(v3) = *(_BYTE *)(a1 + 65);
        v10 = ((unsigned __int8)result | 0x1000u) << v4 >> 12;
      }
      v11 = v10 + *(_DWORD *)(a1 + 716);
      if ( v11 < v8 )
        v11 = v8;
      *(_DWORD *)(a1 + 720) = v11;
      if ( v5 > 1 << v3 )
        *(_DWORD *)(a1 + 720) = v11 + ntp_minpkt;
    }
  }
  else if ( (unsigned int)current_time >= *(_DWORD *)(a1 + 720) )
  {
    if ( (*(_DWORD *)(a1 + 68) & 8) != 0 )
    {
      *(_DWORD *)(a1 + 720) = current_time + 1;
      return result;
    }
    goto LABEL_21;
  }
  return result;
}
// B6B34: using guessed type int ntp_minpkt;
// 108CA4: using guessed type int current_time;

//----- (000343FC) --------------------------------------------------------
int sub_343FC()
{
  double v0; // d0
  _DWORD *v1; // r3
  int v2; // r2
  int v3; // r12
  size_t v4; // r1
  char *v5; // r0
  int v6; // r3
  char *v7; // r2
  int v8; // r3
  int v9; // r4
  double v10; // d8
  int v11; // r6
  int v12; // r10
  int v13; // r2
  int v14; // r3
  double v15; // d7
  int v16; // r2
  int v17; // r1
  int v18; // r3
  int v19; // r12
  __int64 v20; // d5
  int v21; // r2
  int v22; // r1
  int v23; // r3
  int v24; // r10
  int v25; // r3
  _DWORD *v26; // r7
  int v27; // r2
  int v28; // r8
  int v29; // r12
  int v30; // r9
  int v31; // t1
  double v32; // d7
  _DWORD *v33; // r0
  int v34; // r1
  int v35; // r3
  int v36; // t1
  double *v37; // r2
  int v38; // r3
  int v39; // r0
  double v40; // d7
  double v41; // d6
  int v42; // r3
  int v43; // r2
  int v44; // r10
  int v45; // r1
  int v46; // t1
  int v47; // r3
  int v48; // r3
  int v49; // r1
  int v50; // r10
  int v51; // r2
  int v52; // t1
  int v53; // r3
  int v55; // r6
  int v56; // r8
  int v57; // r7
  double v58; // d4
  _DWORD *v59; // r12
  int v60; // r1
  int v61; // r2
  int v62; // r3
  int v63; // r1
  int v64; // r2
  int v65; // r3
  int v66; // r2
  int v67; // r3
  double v68; // r2
  int v69; // r2
  double v70; // r0
  int v71; // r8
  int v72; // s22
  int v73; // r4
  double v74; // d9
  int v75; // r11
  double v76; // d13
  double v77; // d12
  int v78; // r10
  double v79; // d7
  double v80; // d14
  int v81; // r3
  double v82; // d6
  double v83; // d0
  double v84; // d7
  double v85; // d7
  double v86; // r0
  int v87; // r2
  int v88; // r3
  int v89; // r11
  int v90; // r3
  int v91; // r10
  int v92; // r11
  int v93; // r12
  int v94; // r2
  int v95; // r3
  _DWORD *v96; // lr
  int v97; // r3
  int v98; // r3
  unsigned int v99; // r11
  unsigned int v100; // r0
  int v101; // r3
  int i; // r3
  int v103; // r2
  int v104; // r1
  _BOOL4 v105; // r3
  int v106; // r4
  int v107; // r9
  int v108; // r7
  int v109; // lr
  int v110; // r8
  double v111; // d6
  double *v112; // r2
  double v113; // d3
  int v114; // r1
  double v115; // d4
  double v116; // d5
  double v117; // d7
  int v118; // r3
  int v119; // r0
  int v120; // r12
  bool v121; // zf
  double v122; // r8
  double v123; // r0
  int j; // r2
  unsigned int v125; // r1
  unsigned int v126; // r1
  char v127; // r2
  double v128; // d5
  int v129; // r0
  int v130; // r1
  int v131; // r3
  int v132; // r1
  _BOOL4 v133; // r3
  int v134; // r3
  bool v135; // zf
  double v136; // d7
  int v137; // r8
  double v138; // d6
  double v139; // d7
  double v140; // r0
  bool v141; // zf
  double v142; // r0
  int v143; // r3
  double v144; // d7
  double v145; // d0
  int v146; // r2
  double v147; // d5
  double v148; // d6
  double v149; // d4
  int v150; // t1
  double v151; // d2
  double v152; // d0
  double v153; // d8
  int v154; // r3
  int v156; // [sp+4h] [bp-40h]
  int v157; // [sp+4h] [bp-40h]
  int v158; // [sp+4h] [bp-40h]
  int v159; // [sp+8h] [bp-3Ch]
  int v160; // [sp+8h] [bp-3Ch]
  int v161; // [sp+8h] [bp-3Ch]
  int v162; // [sp+10h] [bp-34h]
  int v163; // [sp+18h] [bp-2Ch]
  int v164; // [sp+1Ch] [bp-28h]
  int v165; // [sp+1Ch] [bp-28h]
  int v166; // [sp+28h] [bp-1Ch]
  int v167[2]; // [sp+34h] [bp-10h] BYREF

  sys_survivors = 0;
  v1 = (_DWORD *)peer_list;
  v163 = sys_peer;
  if ( peer_list )
  {
    v2 = 1;
    do
    {
      v1 = (_DWORD *)*v1;
      ++v2;
    }
    while ( v1 );
    v3 = 32 * v2;
    v4 = 72 * v2;
  }
  else
  {
    v4 = 72;
    v3 = 32;
  }
  dword_BC6E0 = v3;
  dword_BC6E4 = v3;
  v5 = (char *)sub_63BA4((void *)dword_BC6E8, v4, 0, 0);
  dword_BC6E8 = (int)v5;
  if ( dword_BC6E0 )
    v6 = dword_BC6E0 + 7;
  else
    v6 = 8;
  if ( dword_BC6E0 )
    v6 &= 0xFFFFFFF8;
  v7 = &v5[v6];
  dword_BC6EC = (int)&v5[v6];
  if ( dword_BC6E4 )
    v8 = dword_BC6E4 + 7;
  else
    v8 = 8;
  v9 = peer_list;
  if ( dword_BC6E4 )
    v8 &= 0xFFFFFFF8;
  dword_BC6F0 = (int)&v7[v8];
  if ( !peer_list )
  {
    v55 = 0;
    *((_QWORD *)v7 + 2) = 0;
    *((double *)v7 + 1) = sys_mindisp;
    goto LABEL_72;
  }
  v10 = 8589934590.0;
  v11 = 0;
  v12 = 0;
  v166 = 0;
  v162 = 0;
  v164 = 0;
  do
  {
    *(_BYTE *)(v9 + 297) = 0;
    if ( sub_32FE4(v9) )
      goto LABEL_24;
    v13 = *(unsigned __int8 *)(v9 + 93);
    if ( v13 == sys_orphan )
    {
      v98 = *(_DWORD *)(v9 + 56);
      if ( v98 )
        v99 = *(_DWORD *)(v98 + 152);
      else
        v99 = -1;
      if ( v98 )
        v99 = bswap32(v99);
      v100 = bswap32(sub_6083C(v9 + 16));
      if ( v99 > v100 )
      {
        v101 = v164;
        if ( (double)v100 < v10 )
        {
          v101 = v9;
          v10 = (double)v100;
        }
        v164 = v101;
      }
    }
    else
    {
      if ( v13 > sys_orphan )
        goto LABEL_24;
      if ( (*(_DWORD *)(v9 + 68) & 0x20) != 0 )
      {
LABEL_23:
        *(_BYTE *)(v9 + 297) = 1;
        sub_32F28();
        v15 = *(double *)(v9 + 608);
        v16 = 16 * v11;
        v17 = dword_BC6EC;
        v11 += 2;
        v18 = dword_BC6E8;
        v19 = v16 + 16;
        v20 = *(_QWORD *)(v9 + 624);
        v21 = dword_BC6E8 + v16;
        *(_DWORD *)(dword_BC6EC + 32 * v12) = v9;
        v22 = v17 + 32 * v12++;
        v23 = v18 + v19;
        *(_QWORD *)(v22 + 16) = v20;
        *(double *)(v22 + 8) = v0;
        *(double *)v21 = v15 - v0;
        *(_DWORD *)(v21 + 8) = -1;
        *(double *)v23 = v0 + v15;
        *(_DWORD *)(v23 + 8) = 1;
        goto LABEL_24;
      }
      v14 = *(unsigned __int8 *)(v9 + 88);
      if ( v14 == 1 )
      {
        v132 = v166;
        v133 = current_time > (unsigned int)orphwait;
        if ( v166 )
          v133 = 0;
        if ( v133 )
          v132 = v9;
        v166 = v132;
      }
      else
      {
        if ( v14 != 18 )
          goto LABEL_23;
        v104 = v162;
        v105 = current_time > (unsigned int)orphwait;
        if ( v162 )
          v105 = 0;
        if ( v105 )
          v104 = v9;
        v162 = v104;
      }
    }
LABEL_24:
    v9 = *(_DWORD *)v9;
  }
  while ( v9 );
  v159 = v12;
  v156 = dword_BC6EC;
  if ( v11 )
  {
    v24 = dword_BC6F0;
    v25 = 0;
    v26 = (_DWORD *)(dword_BC6F0 - 4);
    v27 = dword_BC6F0 - 4;
    do
    {
      *(_DWORD *)(v27 + 4) = v25;
      v27 += 4;
      ++v25;
    }
    while ( v11 != v25 );
    v28 = 0;
    v29 = dword_BC6E8;
    while ( 1 )
    {
      v31 = v26[1];
      ++v26;
      v30 = v31;
      v32 = *(double *)(v29 + 16 * v31);
      if ( v11 <= v28 + 1 )
        break;
      v33 = v26;
      v34 = v28;
      v35 = v28 + 1;
      do
      {
        v36 = v33[1];
        ++v33;
        v37 = (double *)(v29 + 16 * v36);
        if ( *v37 < v32 )
          v34 = v35;
        ++v35;
        if ( *v37 < v32 )
          v32 = *v37;
      }
      while ( v11 != v35 );
      if ( v34 != v28 )
      {
        v38 = *(_DWORD *)(v24 + 4 * v34);
        *(_DWORD *)(v24 + 4 * v34) = v30;
        *v26 = v38;
        if ( v11 <= v28 + 1 )
          break;
      }
      ++v28;
    }
  }
  v39 = v159;
  if ( !v159 )
    goto LABEL_68;
  v40 = 1000000000.0;
  v41 = -1000000000.0;
  do
  {
    if ( v11 )
    {
      v42 = dword_BC6E8 + 16 * *(_DWORD *)dword_BC6F0;
      v40 = *(double *)v42;
      v43 = -*(_DWORD *)(v42 + 8);
      if ( v39 > v43 )
      {
        v44 = dword_BC6F0;
        v45 = 0;
        do
        {
          if ( v11 == ++v45 )
            break;
          v46 = *(_DWORD *)(v44 + 4);
          v44 += 4;
          v47 = dword_BC6E8 + 16 * v46;
          v40 = *(double *)v47;
          v43 -= *(_DWORD *)(v47 + 8);
        }
        while ( v43 < v39 );
      }
    }
    if ( v11 )
    {
      v48 = dword_BC6E8 + 16 * *(_DWORD *)(dword_BC6F0 + 4 * (v11 - 1));
      v49 = *(_DWORD *)(v48 + 8);
      v41 = *(double *)v48;
      if ( v39 > v49 )
      {
        v50 = dword_BC6F0 + 4 * (v11 + 0x3FFFFFFF);
        v51 = v11 - 1;
        do
        {
          if ( v51-- == 0 )
            break;
          v52 = *(_DWORD *)(v50 - 4);
          v50 -= 4;
          v53 = dword_BC6E8 + 16 * v52;
          v41 = *(double *)v53;
          v49 += *(_DWORD *)(v53 + 8);
        }
        while ( v49 < v39 );
      }
    }
    if ( v41 > v40 )
      break;
    --v39;
  }
  while ( v159 - 1 - ((unsigned int)(v159 - 1) >> 1) != v39 );
  v55 = 0;
  v56 = 0;
  v57 = v156 + 8;
  do
  {
    while ( 1 )
    {
      v66 = *(_DWORD *)(v57 - 8);
      v67 = *(_DWORD *)(v66 + 68);
      if ( v41 > v40 )
      {
        v58 = *(double *)(v66 + 608);
        if ( v58 + *(double *)v57 >= v40 && v58 - *(double *)v57 <= v41 )
          break;
      }
      if ( (v67 & 0x400) != 0 )
        break;
      ++v56;
      v57 += 32;
      if ( v159 == v56 )
        goto LABEL_67;
    }
    if ( (v67 & 0x80) == 0 )
      goto LABEL_60;
    if ( !v9 )
      v9 = *(_DWORD *)(v57 - 8);
    if ( (v67 & 0x10000) != 0 )
    {
LABEL_60:
      if ( v55 != v56 )
      {
        v59 = (_DWORD *)(v156 + 32 * v55);
        v60 = *(_DWORD *)(v57 - 4);
        v61 = *(_DWORD *)v57;
        v62 = *(_DWORD *)(v57 + 4);
        *v59 = *(_DWORD *)(v57 - 8);
        v59[1] = v60;
        v59[2] = v61;
        v59[3] = v62;
        v59 += 4;
        v63 = *(_DWORD *)(v57 + 12);
        v64 = *(_DWORD *)(v57 + 16);
        v65 = *(_DWORD *)(v57 + 20);
        *v59 = *(_DWORD *)(v57 + 8);
        v59[1] = v63;
        v59[2] = v64;
        v59[3] = v65;
      }
      ++v55;
    }
    ++v56;
    v57 += 32;
  }
  while ( v159 != v56 );
LABEL_67:
  if ( v55 )
  {
    for ( i = 0; i != v55; ++i )
    {
      v103 = *(_DWORD *)(v156 + 32 * i);
      *(_BYTE *)(v103 + 297) = 3;
    }
  }
  else
  {
LABEL_68:
    *(_QWORD *)(v156 + 16) = 0;
    v68 = sys_mindisp;
    if ( v162 )
      *(_DWORD *)v156 = v162;
    *(double *)(v156 + 8) = v68;
    if ( v162 )
    {
LABEL_71:
      v55 = 1;
      *(_BYTE *)(v162 + 297) = 3;
    }
    else
    {
      v154 = v166;
      if ( v166 || (v154 = v164) != 0 )
      {
        v162 = v154;
        *(_DWORD *)v156 = v154;
        goto LABEL_71;
      }
      v55 = 0;
    }
  }
LABEL_72:
  v69 = 1400;
  HIDWORD(v70) = v55 - 1;
  v71 = 32 * v55;
  v72 = v55 - 1;
  v157 = v9;
  if ( v55 )
    goto LABEL_73;
  while ( 2 )
  {
    v74 = 1000000000.0;
    v73 = v55;
    LODWORD(v70) = sys_precision;
    v86 = ldexp(v70, v69);
LABEL_101:
    LODWORD(v86) = sys_precision;
    v86 = ldexp(v86, v87);
    v76 = 1.0;
LABEL_89:
    v88 = sys_minclock;
    if ( sys_minclock < 1 )
      v88 = 1;
    if ( v88 >= v55 )
    {
      v106 = v157;
      dword_BC6F4 = 0;
      dword_BC6F8 = 0;
      if ( v55 )
        goto LABEL_120;
      if ( !v157 )
        goto LABEL_175;
      v109 = 0;
LABEL_146:
      if ( fabs(sys_offset) >= 0.4 )
      {
LABEL_175:
        if ( v163 )
        {
          if ( (int)sys_orphwait > 0 )
            orphwait = (int)sys_orphwait + current_time;
          LODWORD(v86) = sub_25EE0((__int16 *)byte_8, 0, 0);
        }
        v131 = peer_list;
        for ( sys_peer = 0; v131; v131 = *(_DWORD *)v131 )
          *(_BYTE *)(v131 + 296) = *(_BYTE *)(v131 + 297);
        return LODWORD(v86);
      }
      v121 = v109 == 0;
      if ( !v109 )
        v121 = *(_BYTE *)(v106 + 88) == 22;
      if ( !v121 )
        goto LABEL_150;
      goto LABEL_232;
    }
    if ( v76 > v74 )
    {
      v89 = dword_BC6EC;
      v90 = *(_DWORD *)(dword_BC6EC + 32 * v73);
      v91 = dword_BC6EC + 32 * v73;
      if ( (*(_DWORD *)(v90 + 68) & 0x420) == 0 )
      {
        HIDWORD(v70) = v73 + 1;
        v69 = sys_maxclock;
        if ( sys_maxclock < v55 )
        {
          v69 = 5;
          *(_BYTE *)(v90 + 297) = 5;
        }
        if ( v55 > SHIDWORD(v70) )
        {
          v92 = v89 - 32 + v71;
          do
          {
            v93 = v91;
            v70 = *(double *)(v91 + 32);
            v94 = *(_DWORD *)(v91 + 40);
            v95 = *(_DWORD *)(v91 + 44);
            v96 = (_DWORD *)(v91 + 48);
            v91 += 32;
            *(double *)v93 = v70;
            *(_DWORD *)(v93 + 8) = v94;
            *(_DWORD *)(v93 + 12) = v95;
            v93 += 16;
            HIDWORD(v70) = v96[1];
            v69 = v96[2];
            v97 = v96[3];
            *(_DWORD *)v93 = *v96;
            *(_DWORD *)(v93 + 4) = HIDWORD(v70);
            *(_DWORD *)(v93 + 8) = v69;
            *(_DWORD *)(v93 + 12) = v97;
          }
          while ( v92 != v91 );
        }
        --v55;
        v71 -= 32;
        --v72;
        if ( !v55 )
          continue;
LABEL_73:
        v73 = 0;
        v74 = 1000000000.0;
        v75 = 0;
        v76 = 0.0;
        v77 = -1000000000.0;
        LODWORD(v70) = dword_BC6EC;
        v78 = dword_BC6EC;
        do
        {
          v79 = *(double *)(v78 + 16);
          *(_QWORD *)(v78 + 24) = 0;
          if ( v79 < v74 )
            v74 = v79;
          if ( v55 == 1 )
          {
            v80 = 0.0;
          }
          else
          {
            v81 = 0;
            v82 = 0.0;
            do
            {
              v69 = *(_DWORD *)(LODWORD(v70) + 32 * v81++);
              v82 = v82
                  + (*(double *)(v69 + 608) - *(double *)(*(_DWORD *)v78 + 608))
                  * (*(double *)(v69 + 608) - *(double *)(*(_DWORD *)v78 + 608));
            }
            while ( v55 != v81 );
            v83 = v82 / (double)v72;
            v80 = sqrt(v83);
            if ( v83 < 0.0 )
            {
              v161 = LODWORD(v70);
              v70 = sqrt(v70);
              LODWORD(v70) = v161;
            }
            *(double *)(v78 + 24) = v80;
          }
          v84 = *(double *)(v78 + 8);
          v78 += 32;
          v85 = v80 * v84;
          if ( v85 > v77 )
            v73 = v75;
          ++v75;
          if ( v85 > v77 )
          {
            v76 = v80;
            v77 = v85;
          }
        }
        while ( v55 != v75 );
        LODWORD(v70) = sys_precision;
        v86 = ldexp(v70, v69);
        if ( v76 <= 1.0 )
          goto LABEL_101;
        goto LABEL_89;
      }
    }
    break;
  }
  v106 = v157;
  dword_BC6F4 = 0;
  dword_BC6F8 = 0;
LABEL_120:
  v107 = 0;
  v108 = 0;
  v109 = 0;
  v110 = 0;
  v158 = 0;
  v160 = 0;
  v165 = sys_survivors;
  v111 = 1000000000.0;
  v112 = (double *)dword_BC6EC;
  v113 = sys_mindisp;
  v114 = 0;
  do
  {
    v118 = *(_DWORD *)v112;
    v119 = *(unsigned __int8 *)(*(_DWORD *)v112 + 91);
    *(_DWORD *)(v118 + 708) = 0;
    *(_BYTE *)(v118 + 297) = 4;
    v120 = *(_DWORD *)(v118 + 68);
    if ( v119 == 1 )
    {
      if ( (v120 & 8) != 0 )
      {
        v160 = 1;
        v108 = v55;
      }
      else if ( v55 > v108 )
      {
        ++v108;
        v160 = 1;
      }
    }
    else if ( v119 == 2 )
    {
      if ( (v120 & 8) != 0 )
      {
        v158 = v55;
        v107 = 1;
      }
      else if ( v158 < v55 )
      {
        v107 = 1;
        ++v158;
      }
    }
    LODWORD(v86) = *(unsigned __int8 *)(v118 + 93);
    v115 = v112[3];
    if ( (v120 & 0x20) != 0 )
      v109 = v118;
    v116 = v112[1];
    v112 += 4;
    v117 = (double)SLODWORD(v86) * v113 + v115 * v116;
    if ( v117 < v111 )
      v118 = v114;
    ++v114;
    if ( v117 < v111 )
      v111 = (double)SLODWORD(v86) * v113 + v115 * v116;
    else
      v118 = v110;
    v110 = v118;
  }
  while ( v55 != v114 );
  sys_survivors = v55 + v165;
  if ( v160 )
    dword_BC6F4 = v108;
  if ( v107 )
    dword_BC6F8 = v158;
  if ( sys_minsane > v55 )
  {
    if ( v106 )
      goto LABEL_146;
    goto LABEL_175;
  }
  HIDWORD(v86) = dword_BC6EC;
  LODWORD(v86) = *(_DWORD *)(dword_BC6EC + 32 * v118);
  v134 = dword_BC6EC + 32 * v118;
  v135 = v163 == LODWORD(v86);
  if ( v163 != LODWORD(v86) )
    v135 = v163 == 0;
  if ( v135 )
  {
    dbl_BC700 = 0.0;
    if ( LODWORD(v86) )
    {
      v137 = LODWORD(v86);
      goto LABEL_198;
    }
    if ( !v106 || fabs(sys_offset) >= 0.4 )
      goto LABEL_175;
    v141 = v109 == 0;
    if ( !v109 )
      v141 = *(_BYTE *)(v106 + 88) == 22;
    if ( !v141 )
      goto LABEL_150;
LABEL_232:
    if ( sys_minsane )
      goto LABEL_175;
    goto LABEL_150;
  }
  v136 = fabs(*(double *)(LODWORD(v86) + 608) - *(double *)(v163 + 608));
  if ( sys_mindisp <= v136 )
  {
    v137 = LODWORD(v86);
    dbl_BC700 = 0.0;
  }
  else if ( dbl_BC700 == 0.0 )
  {
    v137 = v163;
    dbl_BC700 = sys_mindisp;
  }
  else
  {
    v138 = dbl_BC700 * 0.5;
    if ( dbl_BC700 * 0.5 <= v136 )
    {
      dbl_BC700 = 0.0;
      v137 = LODWORD(v86);
    }
    else
    {
      v137 = v163;
    }
    if ( v138 > v136 )
      dbl_BC700 = v138;
  }
LABEL_198:
  if ( v109 )
  {
    v139 = *(double *)(v109 + 608);
    *(_BYTE *)(v109 + 297) = 6;
    dbl_BC700 = 0.0;
    v140 = *(double *)(v109 + 624);
    sys_offset = v139;
    sys_jitter = v140;
    if ( !v106 || fabs(v139) >= 0.4 )
    {
LABEL_201:
      v106 = v109;
      goto LABEL_151;
    }
LABEL_150:
    v122 = *(double *)(v106 + 608);
    *(_BYTE *)(v106 + 297) = 7;
    dbl_BC700 = 0.0;
    v123 = *(double *)(v106 + 624);
    sys_offset = v122;
    sys_jitter = v123;
    goto LABEL_151;
  }
  *(_BYTE *)(v137 + 297) = 6;
  v144 = 0.0;
  if ( sys_survivors <= 0 )
  {
    v147 = 0.0;
    v148 = 0.0;
  }
  else
  {
    v145 = *(double *)(LODWORD(v86) + 608);
    v146 = HIDWORD(v86) + 32 * sys_survivors;
    v147 = 0.0;
    v148 = 0.0;
    do
    {
      v149 = *(double *)(HIDWORD(v86) + 8);
      v150 = *(_DWORD *)HIDWORD(v86);
      HIDWORD(v86) += 32;
      LODWORD(v86) = v150;
      v151 = *(double *)(v150 + 608);
      v148 = v148 + 1.0 / v149;
      v147 = v147 + 1.0 / v149 * v151;
      v144 = v144 + (v151 - v145) * (v151 - v145) * (1.0 / v149);
    }
    while ( v146 != HIDWORD(v86) );
  }
  v152 = v144 / v148 + *(double *)(v134 + 24) * *(double *)(v134 + 24);
  sys_offset = v147 / v148;
  v153 = sqrt(v152);
  if ( v152 < 0.0 )
    sqrt(v86);
  sys_jitter = v153;
  if ( !v106 || fabs(sys_offset) >= 0.4 )
  {
    v109 = v137;
    goto LABEL_201;
  }
  if ( *(_BYTE *)(v106 + 88) != 22 )
    goto LABEL_150;
  v106 = v137;
LABEL_151:
  LODWORD(v86) = *(_DWORD *)(v106 + 304);
  if ( LODWORD(v86) <= sys_epoch )
    return LODWORD(v86);
  if ( v163 != v106 )
  {
    sub_25EE0((_WORD *)&dword_88 + 1, v106, 0);
    LODWORD(v86) = *(_DWORD *)(v106 + 304);
  }
  for ( j = peer_list; j; j = *(_DWORD *)j )
    *(_BYTE *)(j + 296) = *(_BYTE *)(j + 297);
  sys_epoch = LODWORD(v86);
  sys_peer = v106;
  v125 = (unsigned __int8)sys_poll;
  if ( *(unsigned __int8 *)(v106 + 65) > (unsigned int)(unsigned __int8)sys_poll )
  {
    v125 = *(unsigned __int8 *)(v106 + 65);
    sys_poll = *(_BYTE *)(v106 + 65);
  }
  if ( *(unsigned __int8 *)(v106 + 66) < v125 )
  {
    v125 = *(unsigned __int8 *)(v106 + 66);
    sys_poll = *(_BYTE *)(v106 + 66);
  }
  sub_34264(v106, v125);
  v126 = *(unsigned __int8 *)(v106 + 93);
  if ( v126 >= 0xF )
    v127 = 15;
  else
    v127 = *(_BYTE *)(v106 + 93);
  sys_stratum = v127 + 1;
  if ( (v126 & 0xEF) != 0 )
    sys_refid = sub_6083C(v106 + 16);
  else
    sys_refid = *(_DWORD *)(v106 + 112);
  v128 = fabs(sys_offset);
  v129 = *(_DWORD *)(v106 + 576);
  v130 = *(_DWORD *)(v106 + 580);
  if ( *(double *)(v106 + 104)
     + *(double *)(v106 + 632)
     + sys_jitter
     + (double)(unsigned int)(current_time - *(_DWORD *)(v106 + 704)) * clock_phi
     + v128 <= sys_mindisp )
    sys_rootdisp = sys_mindisp;
  else
    sys_rootdisp = *(double *)(v106 + 104)
                 + *(double *)(v106 + 632)
                 + sys_jitter
                 + (double)(unsigned int)(current_time - *(_DWORD *)(v106 + 704)) * clock_phi
                 + v128;
  sys_rootdelay = *(double *)(v106 + 616) + *(double *)(v106 + 96);
  sys_reftime = v129;
  dword_108C0C = v130;
  LODWORD(v86) = sub_2F4BC(v106);
  switch ( LODWORD(v86) )
  {
    case 1:
      if ( sys_leap == 3 )
      {
        sub_335A4(0);
        if ( crypto_flags )
          sub_279FC();
        LODWORD(v86) = waitsync_fd_to_close;
        if ( waitsync_fd_to_close != -1 )
        {
          LODWORD(v86) = close(waitsync_fd_to_close);
          waitsync_fd_to_close = -1;
        }
      }
      if ( !leapsec )
      {
        HIDWORD(v86) = dword_BC6F4;
        v143 = dword_BC6F8;
        if ( dword_BC6F4 > dword_BC6F8 )
        {
          if ( dword_BC6F4 <= sys_survivors / 2 )
            return LODWORD(v86);
          sub_5F724(v167);
          LODWORD(v86) = sub_2DCF4(1, v167[0], 0);
          v143 = dword_BC6F8;
          HIDWORD(v86) = dword_BC6F4;
        }
        if ( v143 > SHIDWORD(v86) && v143 > sys_survivors / 2 )
        {
          sub_5F724(v167);
          LODWORD(v86) = sub_2DCF4(0, v167[0], 0);
        }
      }
      break;
    case 2:
      sub_31D10();
      sub_335A4(3);
      sys_refid = 1346720851;
      HIDWORD(v142) = 16;
      LODWORD(v142) = sys_precision;
      sys_rootdelay = 0.0;
      sys_rootdisp = 0.0;
      sys_stratum = 16;
      dword_108C0C = 0;
      sys_reftime = 0;
      ldexp(v142, 0);
      sys_jitter = 1.0;
      LODWORD(v86) = sub_2DB18();
      break;
    case 0xFFFFFFFF:
      exit(-1);
      break;
  }
  return LODWORD(v86);
}
// 345C8: variable 'v0' is possibly undefined
// 349FC: variable 'v69' is possibly undefined
// 34AD4: variable 'v87' is possibly undefined
// 88: using guessed type int;
// B60CC: using guessed type int waitsync_fd_to_close;
// B6AF8: using guessed type double clock_phi;
// B6C1C: using guessed type int *sys_orphwait;
// B6C20: using guessed type int sys_orphan;
// B6C24: using guessed type int sys_maxclock;
// B6C28: using guessed type int sys_minclock;
// B6C2C: using guessed type int sys_minsane;
// B6C40: using guessed type double sys_mindisp;
// B9920: using guessed type int crypto_flags;
// BC6E0: using guessed type int dword_BC6E0;
// BC6E4: using guessed type int dword_BC6E4;
// BC6E8: using guessed type int dword_BC6E8;
// BC6EC: using guessed type int dword_BC6EC;
// BC6F0: using guessed type int dword_BC6F0;
// BC6F4: using guessed type int dword_BC6F4;
// BC6F8: using guessed type int dword_BC6F8;
// BC700: using guessed type double dbl_BC700;
// 1082B0: using guessed type char sys_poll;
// 108B8C: using guessed type int peer_list;
// 108BA0: using guessed type double sys_jitter;
// 108BA8: using guessed type char sys_precision;
// 108BB8: using guessed type double sys_rootdisp;
// 108BC0: using guessed type char sys_leap;
// 108BC8: using guessed type double sys_rootdelay;
// 108BD0: using guessed type int sys_refid;
// 108C08: using guessed type int sys_reftime;
// 108C0C: using guessed type int dword_108C0C;
// 108C14: using guessed type char sys_stratum;
// 108C2C: using guessed type int sys_peer;
// 108C30: using guessed type int sys_epoch;
// 108C40: using guessed type double sys_offset;
// 108C4C: using guessed type int sys_survivors;
// 108CA4: using guessed type int current_time;
// 108CAC: using guessed type int leapsec;
// 108CB0: using guessed type int orphwait;

//----- (00035528) --------------------------------------------------------
int __fastcall sub_35528(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        char a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        double a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        double a54)
{
  __int64 v56; // d0
  __int64 v57; // d1
  __int64 v58; // d2
  double v59; // d6
  int v61; // r6
  int v62; // r4
  int v63; // r2
  double *v64; // r10
  int v65; // r12
  _QWORD *v66; // r1
  int v67; // r0
  double *v68; // r8
  bool v69; // nf
  int v70; // r3
  int v71; // r4
  int v72; // r1
  int v73; // r3
  double v74; // d7
  double v75; // d9
  int v76; // r3
  int v77; // r11
  double v78; // d7
  double v79; // r0
  double v80; // r0
  _DWORD *v81; // r12
  double *v82; // r1
  int i; // r0
  double *v84; // r2
  int v85; // r3
  double v86; // d7
  double v87; // d6
  int v88; // lr
  int v89; // r4
  void **v90; // r2
  _BYTE *v91; // r3
  double v92; // r0
  double v93; // d5
  double v94; // d7
  void *v95; // t1
  int v96; // r6
  int v97; // r3
  double v98; // d7
  int v99; // r2
  bool v101; // zf
  double v102; // d0
  int v103; // r7
  double v104; // d9
  double v105; // d10
  __int64 v106; // r2
  double v107; // d8
  double v108; // r0
  int v109; // r2
  double v110; // d8
  double v111; // d7
  int v112; // r6
  double v113; // d6
  unsigned int v114; // r10
  unsigned int v115; // r4
  double v116; // d0
  int v117; // r0
  double v118; // d9
  unsigned int v120; // [sp+8h] [bp-8h]
  void *v121; // [sp+Ch] [bp-4h] BYREF
  _DWORD v122[8]; // [sp+10h] [bp+0h] BYREF
  _BYTE v123[68]; // [sp+30h] [bp+20h] BYREF
  char v124[80]; // [sp+74h] [bp+64h] BYREF
  int v125; // [sp+C4h] [bp+B4h]

  v61 = 7;
  v62 = *(_DWORD *)(a1 + 320);
  v63 = (int)&_stack_chk_guard;
  v64 = (double *)v123;
  v65 = v62 + 130;
  v66 = (_QWORD *)(a1 + 8 * v62++);
  v67 = _stack_chk_guard;
  v68 = (double *)v123;
  v66[49] = v56;
  v66[41] = v57;
  v66[57] = v58;
  v125 = v67;
  v121 = &_stack_chk_guard;
  v69 = -v62 < 0;
  v70 = -v62 & 7;
  v71 = v62 & 7;
  if ( !v69 )
    v71 = -v70;
  v72 = current_time;
  v73 = current_time - *(_DWORD *)(a1 + 704);
  *(_DWORD *)(a1 + 4 * v65) = current_time;
  *(_DWORD *)(a1 + 320) = v71;
  v74 = clock_phi;
  *(_DWORD *)(a1 + 704) = v72;
  v75 = (double)(unsigned int)v73 * v74;
  do
  {
    v77 = a1 + 8 * v71;
    v78 = *(double *)(v77 + 456);
    if ( v61 )
    {
      v78 = v78 + v75;
      *(double *)(v77 + 456) = v78;
    }
    if ( v78 < 16.0 )
    {
      HIDWORD(v79) = &allan_xpt;
      LODWORD(v79) = (unsigned __int8)allan_xpt;
      v120 = *(_DWORD *)(a1 + 704) - *(_DWORD *)(a1 + 4 * (v71 + 130));
      v80 = ldexp(v79, v63);
      v63 = (unsigned int)1.0;
      if ( v120 <= (unsigned int)1.0 )
      {
        v80 = *(double *)(v77 + 328);
      }
      else
      {
        v78 = *(double *)(v77 + 328);
        v59 = *(double *)(v77 + 456);
      }
      if ( v120 <= (unsigned int)1.0 )
        v68[7] = v80;
      else
        v78 = v78 + v59;
      if ( v120 > (unsigned int)1.0 )
        v68[7] = v78;
    }
    else
    {
      *(double *)(v77 + 456) = 16.0;
      v68[7] = 16.0;
    }
    v122[v61] = v71;
    v69 = -(v71 + 1) < 0;
    --v61;
    v76 = -(v71 + 1) & 7;
    v71 = (v71 + 1) & 7;
    if ( !v69 )
      v71 = -v76;
    --v68;
  }
  while ( v61 != -1 );
  if ( !LODWORD(freq_cnt) )
  {
    v81 = v122;
    v82 = (double *)v123;
    for ( i = 1; i != 8; ++i )
    {
      v84 = (double *)v123;
      v85 = 0;
      do
      {
        v86 = *v84++;
        v87 = v82[1];
        if ( v86 > v87 )
        {
          v88 = v122[v85];
          v89 = v81[1];
          *(v84 - 1) = v87;
          v82[1] = v86;
          v122[v85] = v89;
          v81[1] = v88;
        }
        ++v85;
      }
      while ( v85 != i );
      ++v82;
      ++v81;
    }
  }
  v90 = &v121;
  v91 = (_BYTE *)(a1 + 552);
  HIDWORD(v92) = 0;
  v93 = sys_maxdist;
  do
  {
    v94 = *v64++;
    v95 = v90[1];
    ++v90;
    *v91++ = (_BYTE)v95;
    if ( v94 < 16.0 && (SHIDWORD(v92) <= 1 || v94 < v93) )
      ++HIDWORD(v92);
  }
  while ( (_BYTE *)(a1 + 560) != v91 );
  v96 = v122[0];
  v97 = 7;
  LODWORD(v92) = a1 + 8 * (v122[0] + 49);
  *(_QWORD *)(a1 + 624) = 0;
  v98 = 0.0;
  *(_QWORD *)(a1 + 632) = 0;
  do
  {
    v99 = a1 + 8 * v122[v97];
    v98 = (v98 + *(double *)(v99 + 456)) * 0.5;
    if ( SHIDWORD(v92) > v97 )
      *(double *)(a1 + 624) = *(double *)(a1 + 624)
                            + (*(double *)(v99 + 392) - *(double *)LODWORD(v92))
                            * (*(double *)(v99 + 392) - *(double *)LODWORD(v92));
  }
  while ( v97-- != 0 );
  *(double *)(a1 + 632) = v98;
  if ( !HIDWORD(v92) )
    goto LABEL_58;
  v101 = HIDWORD(v92) == 1;
  v102 = *(double *)(a1 + 624);
  if ( HIDWORD(v92) != 1 )
    --HIDWORD(v92);
  v103 = a1 + 8 * v96;
  v104 = *(double *)(a1 + 608);
  if ( !v101 )
    v98 = (double)SHIDWORD(v92);
  v105 = *(double *)(v103 + 392);
  if ( !v101 )
    v102 = v102 / v98;
  *(double *)(a1 + 608) = v105;
  v106 = *(_QWORD *)(v103 + 328);
  *(_QWORD *)(a1 + 616) = v106;
  if ( !v101 )
    *(double *)(a1 + 624) = v102;
  v107 = sqrt(v102);
  if ( v102 < 0.0 )
    v92 = sqrt(v92);
  LODWORD(v92) = sys_precision;
  v108 = ldexp(v92, v106);
  if ( v107 > 1.0 )
  {
    v116 = *(double *)(a1 + 624);
    v110 = sqrt(v116);
    if ( v116 < 0.0 )
      v108 = sqrt(v108);
  }
  else
  {
    LODWORD(v108) = sys_precision;
    v108 = ldexp(v108, v109);
    v110 = 1.0;
  }
  v111 = sys_maxdist;
  v112 = a1 + 4 * v96;
  v113 = *(double *)(a1 + 632);
  *(double *)(a1 + 624) = v110;
  v114 = *(_DWORD *)(a1 + 304);
  v115 = *(_DWORD *)(v112 + 520);
  if ( v113 < v111 && v111 > *(double *)(v103 + 456) )
  {
    v118 = fabs(v104 - v105);
    if ( v110 * 3.0 < v118 )
    {
      LODWORD(v108) = *(unsigned __int8 *)(a1 + 64);
      v108 = ldexp(v108, v109);
      if ( (double)(v115 - v114) < 1.0 + 1.0 )
      {
        sub_6C054((int)v124, 0x50u, "%.6f s", v118);
        LODWORD(v108) = sub_25EE0((__int16 *)((char *)&dword_8C + 1), a1, v124);
        return LODWORD(v108);
      }
      v115 = *(_DWORD *)(v112 + 520);
      v114 = *(_DWORD *)(a1 + 304);
    }
  }
  if ( v115 > v114 )
  {
    *(_DWORD *)(a1 + 304) = v115;
    v117 = sub_23504(a1);
    LODWORD(v108) = sub_41CDC(a1 + 16, v117);
    if ( !*(_DWORD *)(a1 + 308) || sys_leap == 3 )
LABEL_58:
      LODWORD(v108) = sub_343FC();
  }
  return LODWORD(v108);
}
// 3556C: variable 'v56' is possibly undefined
// 35574: variable 'v57' is possibly undefined
// 35578: variable 'v58' is possibly undefined
// 3566C: variable 'v59' is possibly undefined
// 35810: variable 'v106' is possibly undefined
// 35828: variable 'v109' is possibly undefined
// 8C: using guessed type int;
// B6AF0: using guessed type char allan_xpt;
// B6AF8: using guessed type double clock_phi;
// B6C38: using guessed type double sys_maxdist;
// 108308: using guessed type float freq_cnt;
// 108BA8: using guessed type char sys_precision;
// 108BC0: using guessed type char sys_leap;
// 108CA4: using guessed type int current_time;

//----- (000359B0) --------------------------------------------------------
int __fastcall sub_359B0(int a1, unsigned __int8 *a2, int a3)
{
  unsigned int v5; // r12
  int v6; // r9
  int v7; // lr
  int v8; // r10
  int v9; // r6
  unsigned int v10; // r8
  double v11; // d9
  int v12; // r0
  double v13; // d8
  unsigned int v14; // r3
  unsigned int v15; // r1
  unsigned int v16; // r9
  unsigned int v17; // lr
  double v18; // d9
  double v19; // d8
  int v20; // r3
  int v21; // r2
  unsigned __int16 *v22; // r1
  unsigned int v23; // r11
  int v24; // r9
  unsigned int v25; // r1
  unsigned __int8 v26; // r3
  int v27; // r2
  int v28; // r3
  int v29; // r3
  int v30; // r3
  int v31; // r3
  const char *v32; // r2
  int v33; // r12
  unsigned int v34; // r12
  __int64 v35; // r2
  double v36; // r0
  double v37; // d0
  int v38; // r2
  double v39; // d9
  int v40; // r1
  int v41; // r0
  unsigned int v42; // r1
  __int64 v43; // r2
  double v44; // r0
  double v45; // d0
  int v46; // r2
  double v47; // r0
  int v48; // r2
  double v49; // d8
  int result; // r0
  unsigned int v51; // lr
  __int64 v52; // r2
  double v53; // r0
  double v54; // d0
  int v55; // r2
  double v56; // d8
  __int64 v57; // r2
  double v58; // r0
  double v59; // d0
  int v60; // r2
  double v61; // r0
  int v62; // r2
  double v63; // r0
  int v64; // r2
  double v65; // r0
  int v66; // r2
  unsigned int v67; // r1
  double v68; // r0
  double v69; // d0
  int v70; // r2
  double v71; // r0
  double v72; // d0
  int v73; // r2
  double v74; // r0
  double v75; // d0
  int v76; // r2
  __int64 v77; // r2
  unsigned int v78; // lr
  __int64 v79; // r2
  double v80; // r0
  double v81; // d0
  int v82; // r2
  double v83; // d8
  unsigned int v84; // r12
  __int64 v85; // r2
  double v86; // r0
  double v87; // d0
  int v88; // r2
  int v89; // r1
  int v90; // r1
  double v91; // r0
  double v92; // d0
  int v93; // r2
  unsigned int v94; // lr
  int v95; // r5
  __int64 v96; // r0
  double v97; // r0
  int v98; // r2
  int v99; // r3
  double v100; // d8
  double v101; // d8
  double v102; // r0
  double v103; // d0
  int v104; // r2
  double v105; // r0
  double v106; // d0
  int v107; // r2
  double v108; // r0
  double v109; // d0
  int v110; // r2
  int v111; // [sp+0h] [bp-164h]
  int v112; // [sp+4h] [bp-160h]
  int v113; // [sp+8h] [bp-15Ch]
  int v114; // [sp+Ch] [bp-158h]
  int v115; // [sp+10h] [bp-154h]
  int v116; // [sp+14h] [bp-150h]
  int v117; // [sp+18h] [bp-14Ch]
  int v118; // [sp+1Ch] [bp-148h]
  int v119; // [sp+20h] [bp-144h]
  int v120; // [sp+24h] [bp-140h]
  int v121; // [sp+28h] [bp-13Ch]
  int v122; // [sp+2Ch] [bp-138h]
  int v123; // [sp+30h] [bp-134h]
  unsigned int v124; // [sp+38h] [bp-12Ch]
  unsigned int v125; // [sp+3Ch] [bp-128h]
  int v126; // [sp+40h] [bp-124h]
  int v127; // [sp+44h] [bp-120h] BYREF
  int v128; // [sp+48h] [bp-11Ch]
  int v129; // [sp+4Ch] [bp-118h] BYREF
  char v130[4]; // [sp+50h] [bp-114h]
  int v131; // [sp+54h] [bp-110h] BYREF
  int v132; // [sp+58h] [bp-10Ch]
  int v133[13]; // [sp+5Ch] [bp-108h] BYREF
  double v134; // [sp+90h] [bp-D4h]
  int v135; // [sp+98h] [bp-CCh]
  int v136; // [sp+9Ch] [bp-C8h]
  int v137; // [sp+A0h] [bp-C4h]
  int v138; // [sp+A4h] [bp-C0h]
  int v139; // [sp+A8h] [bp-BCh]
  int v140; // [sp+ACh] [bp-B8h]
  int v141; // [sp+B0h] [bp-B4h]
  int v142; // [sp+B4h] [bp-B0h]
  int v143; // [sp+B8h] [bp-ACh]
  int v144; // [sp+BCh] [bp-A8h]
  int v145; // [sp+C0h] [bp-A4h]
  int v146; // [sp+C4h] [bp-A0h]
  int v147; // [sp+C8h] [bp-9Ch]
  double v148; // [sp+D0h] [bp-94h]

  v5 = *a2;
  v6 = bswap32(*((_DWORD *)a2 + 7));
  v7 = bswap32(*((_DWORD *)a2 + 8));
  v8 = bswap32(*((_DWORD *)a2 + 6));
  v9 = a2[1];
  v10 = v5 >> 6;
  v11 = (double)bswap32(*((_DWORD *)a2 + 1));
  v12 = bswap32(*((_DWORD *)a2 + 9));
  v13 = (double)bswap32(*((_DWORD *)a2 + 2));
  v14 = bswap32(*((_DWORD *)a2 + 11));
  v15 = *((_DWORD *)a2 + 10);
  if ( !a2[1] )
    v9 = 16;
  v132 = v6;
  v16 = *((_DWORD *)a2 + 4);
  v127 = v7;
  v17 = *((_DWORD *)a2 + 5);
  v131 = v8;
  v128 = v12;
  *(_DWORD *)v130 = v14;
  v125 = bswap32(v17);
  v18 = v11 * 0.0000152587891;
  v19 = v13 * 0.0000152587891;
  v124 = bswap32(v16);
  v129 = bswap32(v15);
  v20 = *(_DWORD *)(a1 + 300);
  if ( v10 == 3 || v9 < sys_floor || v9 >= sys_ceiling )
  {
    v20 |= 0x20u;
    *(_DWORD *)(a1 + 300) = v20;
  }
  if ( v19 + v18 * 0.5 >= 16.0 )
  {
    v20 |= 0x40u;
    *(_DWORD *)(a1 + 300) = v20;
  }
  if ( (v20 & 0x1FF) != 0 )
  {
    v67 = *(unsigned __int8 *)(a1 + 64);
    ++*(_DWORD *)(a1 + 768);
    return sub_34264(a1, v67);
  }
  v21 = a3 - 48;
  v22 = *(unsigned __int16 **)(a1 + 56);
  v23 = *((_DWORD *)a2 + 3);
  if ( v22 )
    v22 += 12;
  v24 = sys_processed;
  ++*(_DWORD *)(a1 + 748);
  sys_processed = v24 + 1;
  LOBYTE(v24) = v5 & 7;
  sub_420F0(
    (unsigned __int16 *)(a1 + 16),
    v22,
    (unsigned int *)&v131,
    (unsigned int *)&v127,
    (unsigned int *)&v129,
    (unsigned int *)(a1 + 576),
    v5 >> 6,
    (v5 >> 3) & 7,
    v5 & 7,
    v9,
    a2[2],
    (char)a2[3],
    v23,
    v21,
    (int)(a2 + 48));
  *(_BYTE *)(a1 + 92) = v24;
  if ( (unsigned int)v9 >= 0x10 )
    LOBYTE(v9) = 16;
  *(_BYTE *)(a1 + 91) = v10;
  *(_BYTE *)(a1 + 93) = v9;
  v26 = a2[3];
  v27 = *(_DWORD *)(a1 + 312);
  *(double *)(a1 + 96) = v18;
  *(_BYTE *)(a1 + 95) = v26;
  v28 = *((_DWORD *)a2 + 3);
  *(double *)(a1 + 104) = v19;
  *(_DWORD *)(a1 + 112) = v28;
  *(_DWORD *)(a1 + 116) = v124;
  if ( v27 <= 0 )
    v25 = *(unsigned __int8 *)(a1 + 64);
  *(_DWORD *)(a1 + 120) = v125;
  if ( v27 > 0 )
  {
    v29 = *(unsigned __int8 *)(a1 + 298);
    *(_DWORD *)(a1 + 312) = 0;
    v25 = *(unsigned __int8 *)(a1 + 64);
    if ( v29 )
    {
      v30 = 1 << (v25 - *(_BYTE *)(a1 + 65));
      if ( v30 >= 8 )
        v30 = 8;
      v31 = v30 - 1;
      *(_DWORD *)(a1 + 308) = v31;
      if ( v31 <= 0 )
        goto LABEL_20;
    }
    else
    {
      *(_DWORD *)(a1 + 308) = 5;
    }
    *(_DWORD *)(a1 + 720) = current_time;
  }
LABEL_20:
  sub_34264(a1, v25);
  v32 = (const char *)*(unsigned __int8 *)(a1 + 298);
  if ( !*(_BYTE *)(a1 + 298) )
  {
    sub_25EE0((__int16 *)&dword_84, a1, v32);
    LOBYTE(v32) = *(_BYTE *)(a1 + 298);
    *(_DWORD *)(a1 + 736) = current_time;
  }
  v33 = *(_DWORD *)(a1 + 316);
  *(_BYTE *)(a1 + 298) = (unsigned __int8)v32 | 1;
  if ( !v33 )
  {
    if ( *(_BYTE *)(a1 + 92) != 5 )
    {
      v51 = *(_DWORD *)(a1 + 580);
      HIDWORD(v52) = v129 - *(_DWORD *)(a1 + 576);
      if ( *(_DWORD *)v130 < v51 )
        --HIDWORD(v52);
      LODWORD(v52) = *(_DWORD *)v130 - v51;
      if ( v52 < 0 )
      {
        LODWORD(v69) = sub_8BEC4(-v52);
        HIDWORD(v69) = HIDWORD(v68);
        LODWORD(v68) = -32;
        ldexp(v68, v70);
        v56 = -v69;
      }
      else
      {
        LODWORD(v54) = sub_8BEC4(v52);
        HIDWORD(v54) = HIDWORD(v53);
        LODWORD(v53) = -32;
        ldexp(v53, v55);
        v56 = v54;
      }
      HIDWORD(v57) = v127 - v131;
      if ( v128 < (unsigned int)v132 )
        --HIDWORD(v57);
      LODWORD(v57) = v128 - v132;
      if ( v57 < 0 )
      {
        LODWORD(v92) = sub_8BEC4(-v57);
        HIDWORD(v92) = HIDWORD(v91);
        LODWORD(v91) = -32;
        v47 = ldexp(v91, v93);
        v59 = -v92;
      }
      else
      {
        LODWORD(v59) = sub_8BEC4(v57);
        HIDWORD(v59) = HIDWORD(v58);
        LODWORD(v58) = -32;
        v47 = ldexp(v58, v60);
      }
      v49 = fabs(v59 - v56);
      goto LABEL_52;
    }
    LODWORD(v77) = *(_DWORD *)(a1 + 68) & 0x2000;
    if ( (_DWORD)v77 )
    {
      v78 = *(_DWORD *)(a1 + 588);
      HIDWORD(v79) = v131 - *(_DWORD *)(a1 + 584);
      if ( v132 < v78 )
        --HIDWORD(v79);
      LODWORD(v79) = v132 - v78;
      if ( v79 < 0 )
      {
        LODWORD(v103) = sub_8BEC4(-v79);
        HIDWORD(v103) = HIDWORD(v102);
        LODWORD(v102) = -32;
        ldexp(v102, v104);
        v83 = -v103;
      }
      else
      {
        LODWORD(v81) = sub_8BEC4(v79);
        HIDWORD(v81) = HIDWORD(v80);
        LODWORD(v80) = -32;
        ldexp(v80, v82);
        v83 = v81;
      }
      v84 = *(_DWORD *)(a1 + 596);
      HIDWORD(v85) = v131 - *(_DWORD *)(a1 + 592);
      if ( v132 < v84 )
        --HIDWORD(v85);
      LODWORD(v85) = v132 - v84;
      if ( v85 < 0 )
      {
        LODWORD(v109) = sub_8BEC4(-v85);
        HIDWORD(v109) = HIDWORD(v108);
        LODWORD(v108) = -32;
        ldexp(v108, v110);
        v87 = -v109;
      }
      else
      {
        LODWORD(v87) = sub_8BEC4(v85);
        HIDWORD(v87) = HIDWORD(v86);
        LODWORD(v86) = -32;
        ldexp(v86, v88);
      }
      v89 = *(_DWORD *)v130;
      *(_DWORD *)(a1 + 584) = v129;
      *(_DWORD *)(a1 + 588) = v89;
      v90 = *(_DWORD *)(a1 + 580);
      *(_DWORD *)(a1 + 592) = *(_DWORD *)(a1 + 576);
      *(_DWORD *)(a1 + 596) = v90;
      if ( v83 < 0.0 || v83 > 1.0 )
      {
        if ( (*(_DWORD *)(a1 + 68) & 0x10) == 0 )
        {
          sub_6C054((int)v133, 0x100u, "offset %.6f delay %.6f", v87, v83);
          return (int)sub_25EE0((__int16 *)((char *)&dword_8C + 3), a1, (const char *)v133);
        }
        return sub_31FC4(a1);
      }
      *(double *)(a1 + 640) = v83;
    }
    else
    {
      v94 = *(_DWORD *)(a1 + 580);
      if ( *(_DWORD *)v130 < v94 )
        v95 = 1;
      else
        v95 = *(_DWORD *)(a1 + 68) & 0x2000;
      HIDWORD(v77) = v129 - *(_DWORD *)(a1 + 576);
      if ( v95 )
        --HIDWORD(v77);
      v96 = v77 + *(_DWORD *)v130 - v94;
      if ( v77 < 0 )
      {
        LODWORD(v106) = sub_8BEC4(-v96);
        HIDWORD(v106) = HIDWORD(v105);
        LODWORD(v105) = -32;
        ldexp(v105, v107);
        v87 = -v106;
      }
      else
      {
        LODWORD(v87) = sub_8BEC4(v96);
        HIDWORD(v87) = HIDWORD(v97);
        LODWORD(v97) = -32;
        ldexp(v97, v98);
      }
    }
    v99 = *(_DWORD *)(a1 + 68);
    if ( (v99 & 0x10) != 0 )
    {
      v100 = *(double *)(a1 + 608);
      *(_DWORD *)(a1 + 68) = v99 & 0xFFFFFFEF;
      v101 = fabs(v100 - v87);
      v49 = v101 + v101;
      *(double *)(a1 + 616) = v49;
      if ( v49 > fabs(sys_bdelay) )
        return sub_31FC4(a1);
    }
    else
    {
      v49 = *(double *)(a1 + 616);
    }
    v48 = 1484;
    HIDWORD(v47) = *(unsigned __int8 *)(a1 + 94);
    *(_DWORD *)(a1 + 720) = current_time - 2 + (1 << SBYTE4(v47));
    goto LABEL_52;
  }
  v34 = *(_DWORD *)(a1 + 580);
  HIDWORD(v35) = v129 - *(_DWORD *)(a1 + 576);
  if ( *(_DWORD *)v130 < v34 )
    --HIDWORD(v35);
  LODWORD(v35) = *(_DWORD *)v130 - v34;
  if ( v35 < 0 )
  {
    LODWORD(v75) = sub_8BEC4(-v35);
    HIDWORD(v75) = HIDWORD(v74);
    LODWORD(v74) = -32;
    ldexp(v74, v76);
    v39 = -v75;
  }
  else
  {
    LODWORD(v37) = sub_8BEC4(v35);
    HIDWORD(v37) = HIDWORD(v36);
    LODWORD(v36) = -32;
    ldexp(v36, v38);
    v39 = v37;
  }
  v40 = *(_DWORD *)(a1 + 316);
  if ( v40 <= 0 )
    v41 = *(_DWORD *)(a1 + 584);
  else
    v41 = *(_DWORD *)(a1 + 592);
  if ( v40 <= 0 )
    v42 = *(_DWORD *)(a1 + 588);
  else
    v42 = *(_DWORD *)(a1 + 596);
  HIDWORD(v43) = v127 - v41;
  if ( v128 < v42 )
    --HIDWORD(v43);
  LODWORD(v43) = v128 - v42;
  if ( v43 < 0 )
  {
    LODWORD(v72) = sub_8BEC4(-v43);
    HIDWORD(v72) = HIDWORD(v71);
    LODWORD(v71) = -32;
    v47 = ldexp(v71, v73);
    v45 = -v72;
  }
  else
  {
    LODWORD(v45) = sub_8BEC4(v43);
    HIDWORD(v45) = HIDWORD(v44);
    LODWORD(v44) = -32;
    v47 = ldexp(v44, v46);
  }
  v49 = v45 - v39;
  if ( v45 - v39 < 0.0 || v49 > 1.0 )
  {
    sub_6C054((int)v133, 0x100u, "t21 %.6f t34 %.6f", v45, v39);
    return (int)sub_25EE0((__int16 *)((char *)&dword_8C + 3), a1, (const char *)v133);
  }
LABEL_52:
  LODWORD(v47) = sys_precision;
  v61 = ldexp(v47, v48);
  if ( v49 <= 1.0 )
  {
    LODWORD(v61) = sys_precision;
    v61 = ldexp(v61, v62);
  }
  LODWORD(v61) = sys_precision;
  v63 = ldexp(v61, v62);
  LODWORD(v63) = *(char *)(a1 + 95);
  v65 = ldexp(v63, v64);
  result = sub_35528(
             a1,
             SHIDWORD(v65),
             v66,
             (int)&clock_phi,
             v111,
             v112,
             v113,
             v114,
             v115,
             v116,
             v117,
             v118,
             v119,
             v120,
             v121,
             v122,
             v123,
             (int)&_stack_chk_guard,
             v124,
             v125,
             v126,
             v127,
             v128,
             v129,
             v130[0],
             v131,
             v132,
             v133[0],
             v133[1],
             v133[2],
             v133[3],
             v133[4],
             v133[5],
             v133[6],
             v133[7],
             v133[8],
             v133[9],
             v133[10],
             v133[11],
             v134,
             v135,
             v136,
             v137,
             v138,
             v139,
             v140,
             v141,
             v142,
             v143,
             v144,
             v145,
             v146,
             v147,
             v148);
  if ( (*(_DWORD *)(a1 + 68) & 0x10) != 0 && *(_BYTE *)(a1 + 63) == 3 )
  {
    result = sub_32FE4(a1);
    if ( (result & 0x400) == 0 && ((*(_DWORD *)(a1 + 68) & 0x800) == 0 || (~*(_DWORD *)(a1 + 136) & 0x7F00) == 0) )
      *(_BYTE *)(a1 + 63) = 6;
  }
  return result;
}
// 35BF4: variable 'v25' is possibly undefined
// 35C50: variable 'v36' is possibly undefined
// 35C58: variable 'v38' is possibly undefined
// 35CA8: variable 'v44' is possibly undefined
// 35CB0: variable 'v46' is possibly undefined
// 35DA8: variable 'v53' is possibly undefined
// 35DB0: variable 'v55' is possibly undefined
// 35DF0: variable 'v58' is possibly undefined
// 35DF8: variable 'v60' is possibly undefined
// 35E20: variable 'v48' is possibly undefined
// 35F70: variable 'v62' is possibly undefined
// 35E48: variable 'v64' is possibly undefined
// 35E70: variable 'v66' is possibly undefined
// 35E70: variable 'v111' is possibly undefined
// 35E70: variable 'v112' is possibly undefined
// 35E70: variable 'v113' is possibly undefined
// 35E70: variable 'v114' is possibly undefined
// 35E70: variable 'v115' is possibly undefined
// 35E70: variable 'v116' is possibly undefined
// 35E70: variable 'v117' is possibly undefined
// 35E70: variable 'v118' is possibly undefined
// 35E70: variable 'v119' is possibly undefined
// 35E70: variable 'v120' is possibly undefined
// 35E70: variable 'v121' is possibly undefined
// 35E70: variable 'v122' is possibly undefined
// 35E70: variable 'v123' is possibly undefined
// 35E70: variable 'v126' is possibly undefined
// 35F54: variable 'v68' is possibly undefined
// 35F5C: variable 'v70' is possibly undefined
// 35F88: variable 'v71' is possibly undefined
// 35F90: variable 'v73' is possibly undefined
// 35FA8: variable 'v74' is possibly undefined
// 35FB0: variable 'v76' is possibly undefined
// 36008: variable 'v80' is possibly undefined
// 36010: variable 'v82' is possibly undefined
// 36050: variable 'v86' is possibly undefined
// 36058: variable 'v88' is possibly undefined
// 360C4: variable 'v91' is possibly undefined
// 360CC: variable 'v93' is possibly undefined
// 36118: variable 'v97' is possibly undefined
// 36120: variable 'v98' is possibly undefined
// 36180: variable 'v102' is possibly undefined
// 36188: variable 'v104' is possibly undefined
// 361A0: variable 'v105' is possibly undefined
// 361A8: variable 'v107' is possibly undefined
// 361F4: variable 'v108' is possibly undefined
// 361FC: variable 'v110' is possibly undefined
// 84: using guessed type int;
// 8C: using guessed type int dword_8C;
// B6AF8: using guessed type double clock_phi;
// B6C30: using guessed type int sys_ceiling;
// BC714: using guessed type int sys_floor;
// 108BA8: using guessed type char sys_precision;
// 108BE8: using guessed type double sys_bdelay;
// 108C18: using guessed type int sys_processed;
// 108CA4: using guessed type int current_time;

//----- (00036214) --------------------------------------------------------
int __fastcall sub_36214(int a1, int *a2)
{
  double *v2; // r8
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0
  char v8; // r12
  double v9; // r0
  int v10; // r2
  double v11; // r0
  int v12; // r3
  _QWORD *v13; // r2
  __int64 v14; // r8
  _BYTE *v15; // r1
  int result; // r0
  int i; // r3
  int v18; // r2
  int v19; // r3
  unsigned int v20; // r0
  int v21; // r1
  double v22; // [sp+4h] [bp-10h]

  v2 = (double *)(a1 + 600);
  v22 = *(double *)(a1 + 600);
  sub_3394C((_DWORD *)a1);
  if ( *(_DWORD *)(a1 + 176) )
    BN_free();
  sub_27B48((_DWORD *)(a1 + 184));
  sub_27B48((_DWORD *)(a1 + 208));
  sub_27B48((_DWORD *)(a1 + 248));
  sub_27B48((_DWORD *)(a1 + 272));
  v5 = *(void **)(a1 + 232);
  if ( v5 )
    free(v5);
  v6 = *(void **)(a1 + 148);
  if ( v6 )
    free(v6);
  v7 = *(void **)(a1 + 152);
  if ( v7 )
    free(v7);
  memset((void *)(a1 + 128), 0, 0x240u);
  v8 = *(_BYTE *)(a1 + 66);
  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a1 + 65);
  *(_DWORD *)(a1 + 632) = 0;
  *(_DWORD *)(a1 + 636) = 1076887552;
  *(_BYTE *)(a1 + 94) = v8;
  *(_DWORD *)(a1 + 300) = sub_32FE4(a1);
  LODWORD(v9) = sys_precision;
  v11 = ldexp(v9, v10);
  v12 = *(unsigned __int8 *)(a1 + 63);
  v13 = (_QWORD *)(a1 + 456);
  *(double *)(a1 + 624) = 1.0;
  if ( v12 == 6 )
    v11 = v22;
  HIDWORD(v14) = 1076887552;
  if ( v12 == 6 )
    *v2 = v11;
  v15 = (_BYTE *)(a1 + 552);
  result = *(_DWORD *)(a1 + 68);
  LODWORD(v14) = 0;
  if ( (result & 0x1000) != 0 )
    *(_DWORD *)(a1 + 316) = 1;
  for ( i = 0; i != 8; ++i )
  {
    *v15++ = i;
    *v13++ = v14;
  }
  if ( (result & 8) != 0 )
  {
    v18 = 0;
  }
  else
  {
    i = 16;
    v18 = 3;
    *(_BYTE *)(a1 + 91) = 3;
  }
  if ( (result & 8) != 0 )
    i = *(_DWORD *)(a1 + 84);
  else
    *(_BYTE *)(a1 + 93) = i;
  if ( (result & 8) != 0 )
  {
    *(_DWORD *)(i + 220) = v18;
    *(_DWORD *)(i + 216) = v18;
  }
  else
  {
    i = *a2;
  }
  if ( (result & 8) == 0 )
    *(_DWORD *)(a1 + 112) = i;
  v19 = current_time;
  *(_DWORD *)(a1 + 716) = current_time;
  *(_DWORD *)(a1 + 704) = v19;
  *(_DWORD *)(a1 + 720) = v19;
  if ( initializing )
  {
    *(_DWORD *)(a1 + 720) = peer_associations + v19;
  }
  else if ( *(_BYTE *)(a1 + 63) == 2 )
  {
    *(_DWORD *)(a1 + 720) = ntp_minpkt + v19;
  }
  else
  {
    v20 = sub_68AE4();
    result = sub_8BB9C(v20, *(unsigned __int8 *)(a1 + 65));
    v19 = current_time;
    *(_DWORD *)(a1 + 720) += v21;
  }
  *(_DWORD *)(a1 + 236) = v19 + 0x80000;
  return result;
}
// 36304: variable 'v9' is possibly undefined
// 36304: variable 'v10' is possibly undefined
// 363D0: variable 'v21' is possibly undefined
// C13C: using guessed type int BN_free(void);
// B6B34: using guessed type int ntp_minpkt;
// 108578: using guessed type int peer_associations;
// 108BA8: using guessed type char sys_precision;
// 108CA4: using guessed type int current_time;
// 108CA8: using guessed type int initializing;

//----- (00036448) --------------------------------------------------------
#error "36850: call analysis failed (funcsize=279)"

//----- (000368F4) --------------------------------------------------------
int __fastcall receive(__int64 a1)
{
  int v1; // r1
  unsigned __int16 *v2; // r10
  int v3; // r5
  int v4; // r9
  int v5; // r7
  int v6; // r2
  int v7; // r2
  int v8; // r3
  int v9; // r8
  int v10; // r10
  int v11; // r6
  int v12; // r2
  unsigned int *v13; // r1
  unsigned int v14; // r5
  int v15; // r7
  unsigned int v16; // r11
  const char *v17; // r7
  _BOOL4 v18; // r3
  _BOOL4 v19; // r2
  __int16 v20; // r3
  unsigned int v21; // r2
  int v22; // r0
  char v23; // r1
  int v24; // r3
  unsigned int v25; // r3
  int v26; // r7
  unsigned int v27; // r12
  unsigned int v28; // r1
  unsigned int v29; // r2
  unsigned int v30; // r3
  int v31; // r1
  _BOOL4 v32; // r2
  _BOOL4 v33; // r2
  unsigned int v34; // r8
  int v35; // r3
  bool v36; // zf
  int v37; // r1
  int v38; // r5
  const char *v39; // r4
  const char *v40; // r0
  bool v41; // cc
  unsigned int v42; // r2
  int v43; // r2
  int v44; // r3
  int v45; // r3
  int v46; // r3
  int v47; // r7
  int v49; // r2
  int v50; // r3
  int v51; // r1
  unsigned int v52; // r3
  int v53; // r1
  _BOOL4 v54; // r6
  const char *v55; // r0
  int v56; // r3
  int v57; // r1
  unsigned int v58; // r3
  int v59; // r3
  int v60; // r12
  _DWORD *v61; // r5
  const char *v62; // r0
  unsigned __int64 v63; // r0
  const char *v64; // r0
  const char *v65; // r0
  _BOOL4 v66; // r3
  int v67; // r3
  int v68; // r2
  unsigned int v69; // r3
  _DWORD *v70; // r8
  int v71; // r3
  int v72; // r2
  int v73; // r1
  _DWORD *v74; // r5
  int v75; // r12
  int v76; // r1
  int v77; // r2
  unsigned int v78; // r12
  unsigned int v79; // r3
  int v80; // r3
  int v81; // r2
  unsigned int v82; // r1
  unsigned int v83; // r2
  unsigned int v84; // r0
  int i; // r9
  int v86; // r2
  int v87; // r3
  const char *v88; // r0
  int v89; // r6
  const char *v90; // r0
  int v91; // r3
  const char *v92; // r0
  const char *v93; // r0
  int v94; // r3
  bool v95; // zf
  int v96; // r2
  int v97; // r0
  const char *v98; // r0
  int v99; // r9
  unsigned int v100; // r2
  unsigned int v101; // r3
  int v102; // r1
  const char *v103; // r0
  __int64 v104; // r2
  const char *v105; // r0
  int v106; // r2
  int v107; // r2
  const char *v108; // r0
  const char *v109; // r0
  bool v110; // zf
  int v111; // r2
  int v112; // r3
  const char *v113; // r7
  _BOOL4 v115; // r1
  int v116; // r2
  int v117; // r2
  int v118; // r6
  int v119; // r12
  _BOOL4 v120; // r2
  unsigned int v121; // r6
  const char *v122; // r0
  const char *v123; // r0
  unsigned int v124; // r1
  const char *v125; // r0
  unsigned int v126; // r2
  int v127; // r3
  const char *v128; // r0
  unsigned int v129; // r3
  unsigned int v130; // r2
  _BOOL4 v131; // r8
  int v132; // r2
  int v134; // [sp+30h] [bp-16Ch]
  int v135; // [sp+30h] [bp-16Ch]
  int v136; // [sp+30h] [bp-16Ch]
  unsigned int v137; // [sp+34h] [bp-168h]
  __int16 v138; // [sp+34h] [bp-168h]
  int v139; // [sp+38h] [bp-164h]
  unsigned int v140; // [sp+38h] [bp-164h]
  signed int v141; // [sp+3Ch] [bp-160h]
  __int16 v142; // [sp+40h] [bp-15Ch]
  int v143; // [sp+44h] [bp-158h]
  int v144; // [sp+44h] [bp-158h]
  int v145; // [sp+44h] [bp-158h]
  int s; // [sp+48h] [bp-154h]
  unsigned __int16 *v147; // [sp+4Ch] [bp-150h]
  unsigned __int8 *v148; // [sp+50h] [bp-14Ch]
  unsigned __int16 *v149; // [sp+54h] [bp-148h]
  const char *v150; // [sp+54h] [bp-148h]
  int v151; // [sp+54h] [bp-148h]
  unsigned int v152; // [sp+54h] [bp-148h]
  unsigned int v153; // [sp+58h] [bp-144h]
  int v154; // [sp+5Ch] [bp-140h]
  int v155; // [sp+5Ch] [bp-140h]
  unsigned int v156; // [sp+5Ch] [bp-140h]
  int v157; // [sp+60h] [bp-13Ch]
  const char *v158; // [sp+60h] [bp-13Ch]
  int v159; // [sp+64h] [bp-138h]
  unsigned int v160; // [sp+68h] [bp-134h]
  unsigned int v161; // [sp+68h] [bp-134h]
  int v162; // [sp+6Ch] [bp-130h]
  unsigned __int16 v163; // [sp+70h] [bp-12Ch] BYREF
  __int16 v164; // [sp+72h] [bp-12Ah]
  int v165; // [sp+74h] [bp-128h] BYREF
  unsigned __int64 v166; // [sp+78h] [bp-124h] BYREF
  __int64 v167; // [sp+80h] [bp-11Ch] BYREF
  unsigned __int64 v168; // [sp+88h] [bp-114h] BYREF
  char v169[268]; // [sp+90h] [bp-10Ch] BYREF

  v165 = 0;
  v1 = *(unsigned __int16 *)(a1 + 6);
  ++sys_received;
  if ( !v1 )
    goto LABEL_2;
  v2 = (unsigned __int16 *)(a1 + 4);
  v3 = a1;
  LODWORD(a1) = sub_40054(a1 + 4, &v163);
  v4 = *(unsigned __int8 *)(v3 + 89);
  v5 = v163;
  if ( !*(_BYTE *)(v3 + 89) )
    v4 = 16;
  if ( (v163 & 1) != 0 )
    goto LABEL_54;
  v137 = *(unsigned __int8 *)(v3 + 88);
  v134 = v137 & 7;
  if ( v134 == 7 )
  {
    if ( ntp_mode7 && (v163 & 0x80) == 0 )
    {
      LODWORD(a1) = sub_3F4E4(v3, ((v163 ^ 0x100u) >> 8) & 1);
      return a1;
    }
    goto LABEL_54;
  }
  if ( v134 == 6 )
  {
    if ( (v163 & 0x80) == 0 )
    {
      LODWORD(a1) = sub_23110(v3, v163);
      return a1;
    }
    goto LABEL_54;
  }
  if ( (v163 & 2) != 0 || (v163 & 0x2000) != 0 && (LODWORD(a1) = sub_68AE4(), (double)(int)a1 / 2147483650.0 < 0.1) )
  {
LABEL_54:
    ++sys_restricted;
    return a1;
  }
  v143 = (v137 >> 3) & 7;
  if ( v143 == 4 )
  {
    ++sys_newversion;
    if ( (v137 & 7) == 0 )
      goto LABEL_2;
  }
  else
  {
    v6 = (v137 >> 3) & 7;
    if ( v143 )
      v6 = 1;
    if ( (v6 & ((v5 ^ 8u) >> 3)) == 0 )
      goto LABEL_2;
    ++sys_oldversion;
    if ( (v137 & 7) == 0 )
    {
      if ( v143 != 1 )
        goto LABEL_2;
      v134 = 3;
    }
  }
  v148 = (unsigned __int8 *)(v3 + 88);
  v7 = *(_DWORD *)(v3 + 84) - 48;
  v139 = *(_DWORD *)(v3 + 84);
  v141 = v7;
  if ( v7 <= 0 )
  {
    v9 = 48;
    v150 = 0;
    v160 = 0;
LABEL_66:
    if ( !v141 )
    {
      if ( (v5 & 4) == 0 )
      {
        v140 = 0;
        s = 1;
        goto LABEL_69;
      }
      goto LABEL_54;
    }
LABEL_2:
    ++sys_badlength;
    return a1;
  }
  v8 = v7 & 3;
  if ( (v7 & 3) != 0 )
    v8 = 1;
  if ( v7 <= 3 )
    v8 |= 1u;
  if ( v8 )
    goto LABEL_2;
  if ( v7 <= 24 )
  {
    v150 = 0;
    v25 = 48;
    v160 = 0;
    v9 = 48;
    goto LABEL_79;
  }
  a1 = 0x3FFF000002010000LL;
  v149 = v2;
  v9 = 48;
  v10 = v3 + 88;
  v11 = *(_DWORD *)(v3 + 84) - 48;
  v154 = v5;
  v157 = v3;
  do
  {
    v13 = (unsigned int *)(v10 + 4 * (v9 / 4));
    v14 = bswap32(*v13);
    v15 = v14 & 3;
    if ( (v14 & 3) != 0 )
      v15 = 1;
    if ( (unsigned __int16)v14 <= 3u )
      v15 |= 1u;
    if ( v15 )
      goto LABEL_2;
    v9 += (unsigned __int16)v14;
    if ( v139 < v9 )
      goto LABEL_2;
    LODWORD(a1) = 33619968;
    if ( (v14 & 0x3FFF0000) == 0x2010000 && sys_groupname )
    {
      v16 = bswap32(v13[4]);
      if ( v16 > 0x100 || (unsigned int)(unsigned __int16)v14 - 20 < v16 )
        goto LABEL_2;
      _memcpy_chk(v169, v13 + 5, v16, 257);
      v169[v16] = 0;
      LODWORD(a1) = strchr(v169, 64);
      if ( !(_DWORD)a1 )
        goto LABEL_103;
      v8 = a1 + 1;
    }
    v11 -= (unsigned __int16)v14;
    if ( v11 <= 0 )
    {
      v141 = v11;
      v160 = v14;
      v5 = v154;
      v3 = v157;
      v2 = v149;
      v150 = (const char *)v8;
      goto LABEL_66;
    }
    v12 = v11 & 3;
    if ( (v11 & 3) != 0 )
      v12 = 1;
    if ( v11 <= 3 )
      v12 |= 1u;
    if ( v12 )
      goto LABEL_2;
  }
  while ( v11 > 24 );
  v141 = v11;
  v160 = v14;
  v5 = v154;
  v3 = v157;
  v2 = v149;
  v150 = (const char *)v8;
  v24 = v9 + 3;
  if ( v9 >= 0 )
    v24 = v9;
  v25 = v24 & 0xFFFFFFFC;
LABEL_79:
  v140 = bswap32(*(_DWORD *)&v148[v25]);
  s = v141 == 0;
LABEL_69:
  LODWORD(a1) = sub_30FF4(v3, v5);
  v142 = a1;
  v153 = a1 & 0x40;
  if ( (a1 & 0x40) != 0 )
  {
    ++sys_limitrejected;
    if ( (a1 & 0x800) != 0 && (unsigned int)(v134 - 4) > 1 )
    {
      v20 = a1;
      if ( v134 == 3 )
      {
        v21 = v140;
        v22 = v3;
        v23 = 4;
      }
      else
      {
        v22 = v3;
        v21 = v140;
        v23 = 1;
      }
      LODWORD(a1) = sub_C170(v22, v23, v21, v20);
    }
    return a1;
  }
  v26 = sub_32CA0(v3, v134, &v165);
  v27 = *(_DWORD *)(v3 + 120);
  v28 = bswap32(*(_DWORD *)(v3 + 124));
  v29 = *(_DWORD *)(v3 + 128);
  v166 = _byteswap_uint64(__PAIR64__(*(_DWORD *)(v3 + 112), *(_DWORD *)(v3 + 116)));
  v30 = *(_DWORD *)(v3 + 132);
  HIDWORD(v167) = v28;
  v31 = *(_DWORD *)(v3 + 60);
  v168 = _byteswap_uint64(__PAIR64__(v29, v30));
  LODWORD(v167) = bswap32(v27);
  v147 = (unsigned __int16 *)(v31 + 24);
  v158 = sub_64648(v134);
  sub_337E4(v165);
  LODWORD(a1) = sub_336EC((int *)v26, (_DWORD *)v3, v134);
  v159 = a1;
  if ( (_DWORD)a1 == 1 )
  {
    sub_25EE0((__int16 *)&dword_8C, v26, "Invalid_NAK");
    if ( v26 )
      ++*(_DWORD *)(v26 + 756);
    v38 = current_time;
    v39 = sub_6C2E8(v147);
    v40 = sub_6C2E8(v2);
    LODWORD(a1) = sub_64E00(3, "Invalid-NAK error at %ld %s<-%s", v38, v39, v40);
    return a1;
  }
  if ( s )
  {
    v34 = 0;
    s = 0;
    goto LABEL_95;
  }
  if ( (_DWORD)a1 == 2 )
  {
    v34 = 3;
    v153 = 0;
    goto LABEL_95;
  }
  v32 = v140 >= 0x10000;
  if ( !crypto_flags )
    v32 = 0;
  if ( !v32 )
  {
    v153 = 0;
    goto LABEL_88;
  }
  if ( v141 <= 19 )
  {
LABEL_162:
    ++sys_badauth;
    return a1;
  }
  if ( v134 == 5 )
  {
    v43 = *(_DWORD *)(v3 + 60);
    if ( *(_WORD *)(v3 + 4) == 2 )
      v44 = any_interface;
    else
      v44 = any6_interface;
    if ( v43 == v44 )
      goto LABEL_54;
    if ( *(_WORD *)(v43 + 80) == 2 )
    {
      v46 = *(_DWORD *)(v43 + 84) != 0;
    }
    else
    {
      if ( *(_DWORD *)(v43 + 88) )
      {
        v45 = 0;
      }
      else
      {
        v45 = *(_DWORD *)(v43 + 92);
        if ( v45 )
        {
          v45 = *(_DWORD *)(v43 + 88);
        }
        else if ( !*(_DWORD *)(v43 + 96) )
        {
          v45 = *(_DWORD *)(v43 + 100) == 0;
        }
      }
      v46 = v45 ^ 1;
    }
    if ( v46 )
      v147 = (unsigned __int16 *)(v43 + 80);
    s = 0;
LABEL_135:
    v42 = 2;
    goto LABEL_120;
  }
  if ( v26 )
    s = *(_DWORD *)(v26 + 168);
  else
    s = sub_272C8(v2, (unsigned int)v147, 0, sys_private, 0);
  v41 = s <= 0;
  if ( s )
    v41 = v9 <= 48;
  if ( v41 )
    goto LABEL_135;
  sub_272C8(v2, (unsigned int)v147, v140, 0, 2u);
  v42 = 0;
LABEL_120:
  v153 = sub_272C8(v2, (unsigned int)v147, v140, s, v42);
LABEL_88:
  LODWORD(a1) = sub_62854(v140, (int)v148, v9, v141);
  v33 = v140 >= 0x10000;
  if ( (_DWORD)a1 )
    v34 = 1;
  else
    v34 = 2;
  if ( !crypto_flags )
    v33 = 0;
  if ( v33 )
    LODWORD(a1) = sub_621BC(v140, 0);
LABEL_95:
  if ( v26 )
  {
    v35 = *(_DWORD *)(v26 + 124);
    if ( v35 )
    {
      if ( v35 != v140 )
        goto LABEL_54;
      v36 = v34 == 1;
      if ( v34 != 1 )
        v36 = v141 == 0;
      if ( !v36 )
        goto LABEL_54;
    }
  }
  v37 = v137 >> 6;
  v162 = v165;
  v138 = v142 & 0xE7FF;
  v155 = v37;
  switch ( v165 )
  {
    case 1:
      LODWORD(a1) = sub_C534(v150, *(const char **)(v26 + 80));
      v145 = a1;
      if ( (_DWORD)a1 )
        goto LABEL_103;
      if ( v134 != 5 )
        goto LABEL_159;
      v121 = *(unsigned __int8 *)(v3 + 90);
      if ( v121 != *(unsigned __int8 *)(v26 + 94) )
      {
        v122 = sub_6C2E8(v2);
        sub_64E00(
          6,
          "receive: broadcast poll from %s changed from %u to %u",
          v122,
          *(unsigned __int8 *)(v26 + 94),
          *(unsigned __int8 *)(v3 + 90));
        v121 = *(unsigned __int8 *)(v3 + 90);
      }
      if ( *(unsigned __int8 *)(v26 + 65) > v121 || *(unsigned __int8 *)(v26 + 66) < v121 )
      {
        v145 = v162;
        v123 = sub_6C2E8(v2);
        sub_64E00(
          6,
          "receive: broadcast poll of %u from %s is out-of-range (%d to %d)!",
          v121,
          v123,
          *(unsigned __int8 *)(v26 + 65),
          *(unsigned __int8 *)(v26 + 66));
        LOBYTE(v121) = *(_BYTE *)(v3 + 90);
      }
      v124 = 1 << v121;
      if ( (*(_DWORD *)(v26 + 68) & 0x10) != 0 )
        v124 -= 3;
      if ( current_time - *(_DWORD *)(v26 + 732) < v124 )
      {
        v152 = v124;
        ++v145;
        v125 = sub_6C2E8(v2);
        sub_64E00(
          6,
          "receive: broadcast packet from %s arrived after %lu, not %lu seconds!",
          v125,
          current_time - *(_DWORD *)(v26 + 732),
          v152);
      }
      a1 = *(_QWORD *)(v26 + 600);
      if ( sys_bcpollbstep )
        v126 = *(unsigned __int8 *)(v3 + 90);
      else
        v126 = 0;
      if ( sys_bcpollbstep )
        v126 = ((unsigned __int8)sys_bcpollbstep << v126) + 2;
      if ( !a1 )
        goto LABEL_349;
      v127 = v168 - a1;
      if ( HIDWORD(v168) < HIDWORD(a1) )
        --v127;
      if ( v127 < 0 && current_time - *(_DWORD *)(v26 + 732) < v126 )
      {
        v128 = sub_6C2E8(v2);
        LODWORD(a1) = sub_64E00(
                        6,
                        "receive: broadcast packet from %s contains non-monotonic timestamp: %#010x.%08x -> %#010x.%08x",
                        v128,
                        *(_DWORD *)(v26 + 600),
                        *(_DWORD *)(v26 + 604),
                        (_DWORD)v168,
                        HIDWORD(v168));
      }
      else
      {
LABEL_349:
        if ( !v145 )
          goto LABEL_159;
      }
      *(_DWORD *)(v26 + 728) = current_time;
      ++sys_declined;
      return a1;
    case 3:
      v118 = *(_DWORD *)(v3 + 60);
      if ( (*(_DWORD *)(v118 + 144) & 0x40) == 0 )
      {
        v119 = *(unsigned __int8 *)(v3 + 89);
        if ( !*(_BYTE *)(v3 + 89) )
          v119 = 16;
        LODWORD(a1) = sub_420F0(
                        v2,
                        (unsigned __int16 *)(v118 + 24),
                        (unsigned int *)&v166,
                        (unsigned int *)&v167,
                        (unsigned int *)&v168,
                        (unsigned int *)(v3 + 72),
                        *(unsigned __int8 *)(v3 + 88) >> 6,
                        (*(unsigned __int8 *)(v3 + 88) >> 3) & 7,
                        *(_BYTE *)(v3 + 88) & 7,
                        v119,
                        *(unsigned __int8 *)(v3 + 90),
                        *(char *)(v3 + 91),
                        *(_DWORD *)(v3 + 100),
                        *(_DWORD *)(v3 + 84) - 48,
                        v3 + 136);
        if ( (v142 & 4) != 0 )
          v120 = v34 == 1;
        else
          v120 = v34 <= 1;
        if ( !v120 )
        {
          if ( v34 != 2 )
            goto LABEL_54;
          LODWORD(a1) = sub_C170(v3, 4, 0, v138);
          goto LABEL_162;
        }
LABEL_378:
        LODWORD(a1) = sub_C170(v3, 4, v140, v138);
        return a1;
      }
      if ( !sys_manycastserver )
        goto LABEL_54;
      LODWORD(a1) = sub_C534(v150, 0);
      if ( (_DWORD)a1
        || sys_leap == 3
        || (unsigned __int8)sys_stratum >= (unsigned int)v4
        || !sys_cohort && (unsigned __int8)sys_stratum == v4 + 1
        || *(_DWORD *)(v118 + 152) == *(_DWORD *)(v3 + 100) )
      {
LABEL_103:
        ++sys_declined;
        return a1;
      }
      if ( (v142 & 4) != 0 )
        v131 = v34 == 1;
      else
        v131 = v34 <= 1;
      if ( v131 )
      {
        v132 = *(unsigned __int8 *)(v3 + 89);
        if ( !*(_BYTE *)(v3 + 89) )
          v132 = 16;
        sub_420F0(
          v2,
          (unsigned __int16 *)(v118 + 24),
          (unsigned int *)&v166,
          (unsigned int *)&v167,
          (unsigned int *)&v168,
          (unsigned int *)(v3 + 72),
          *(unsigned __int8 *)(v3 + 88) >> 6,
          (*(unsigned __int8 *)(v3 + 88) >> 3) & 7,
          *(_BYTE *)(v3 + 88) & 7,
          v132,
          *(unsigned __int8 *)(v3 + 90),
          *(char *)(v3 + 91),
          *(_DWORD *)(v3 + 100),
          *(_DWORD *)(v3 + 84) - 48,
          v3 + 136);
        goto LABEL_378;
      }
      return a1;
    case 4:
      LODWORD(a1) = sub_C534(v150, 0);
      if ( (_DWORD)a1 )
        goto LABEL_103;
      LODWORD(a1) = sub_32C0C(v3);
      v47 = a1;
      if ( !(_DWORD)a1 )
        goto LABEL_54;
      if ( (*(_BYTE *)(a1 + 72) & 8) == 0 && sys_authenticate || (v142 & 0x14) != 0 ? v34 != 1 : v34 > 1 )
        goto LABEL_54;
      if ( v155 == 3 )
        goto LABEL_103;
      if ( v4 < sys_floor )
        goto LABEL_103;
      if ( v4 >= sys_ceiling )
        goto LABEL_103;
      LODWORD(a1) = sub_321D4(
                      (int)v2,
                      0,
                      *(char **)(v3 + 60),
                      v164,
                      3u,
                      v143,
                      *(_BYTE *)(a1 + 65),
                      *(_BYTE *)(a1 + 66),
                      *(_DWORD *)(a1 + 68) & 0x100 | 2,
                      0x41u,
                      0,
                      v140,
                      (const char *)sys_ident);
      if ( !(_DWORD)a1 )
        goto LABEL_103;
      if ( (*(_BYTE *)(v47 + 72) & 8) != 0 )
        *(_DWORD *)(v47 + 720) = current_time + 1;
      return a1;
    case 5:
      v17 = (const char *)sys_ident;
      LODWORD(a1) = sub_C534(v150, (const char *)sys_ident);
      if ( (_DWORD)a1 )
        goto LABEL_103;
      if ( v142 & 0x14 | sys_authenticate )
        v18 = v34 != 1;
      else
        v18 = v34 > 1;
      if ( v18 )
      {
        if ( (v142 & 4) != 0 )
          v19 = v34 == 1;
        else
          v19 = v34 <= 1;
        if ( v19 )
        {
          LODWORD(a1) = sub_C170(v3, 2, v140, v138);
          return a1;
        }
        if ( v34 != 2 )
          goto LABEL_103;
        LODWORD(a1) = sub_C170(v3, 2, 0, v138);
        goto LABEL_54;
      }
      if ( (v142 & 0x20) != 0 || v155 != 3 && (v4 < sys_floor || v4 >= sys_ceiling) )
        goto LABEL_103;
      LODWORD(a1) = sub_321D4(
                      (int)v2,
                      0,
                      *(char **)(v3 + 60),
                      v164,
                      2u,
                      v143,
                      *(_BYTE *)(v3 + 90),
                      0xAu,
                      0,
                      1u,
                      0,
                      v140,
                      v17);
      v26 = a1;
      if ( !(_DWORD)a1 )
        goto LABEL_103;
      goto LABEL_159;
    case 6:
      v113 = (const char *)sys_ident;
      LODWORD(a1) = sub_C534(v150, (const char *)sys_ident);
      if ( (_DWORD)a1 )
        goto LABEL_103;
      if ( !sys_bclient )
        goto LABEL_54;
      if ( v142 & 0x14 | sys_authenticate ? v34 != 1 : v34 > 1 )
        goto LABEL_54;
      if ( v155 == 3 || v4 < sys_floor || v4 >= sys_ceiling )
        goto LABEL_103;
      v115 = v140 >= 0x10000;
      if ( !crypto_flags )
        v115 = 0;
      if ( v115 && HIWORD(v160) << 16 != -2113863680 )
        goto LABEL_103;
      v116 = *(_DWORD *)(v3 + 60);
      LODWORD(a1) = &sys_bdelay;
      if ( (*(_DWORD *)(v116 + 144) & 0x40) != 0 )
        v116 = 0;
      if ( sys_bdelay <= 0.0 )
      {
        LODWORD(a1) = sub_321D4(
                        (int)v2,
                        0,
                        (char *)v116,
                        v164,
                        3u,
                        v143,
                        *(_BYTE *)(v3 + 90),
                        *(_BYTE *)(v3 + 90),
                        274,
                        0x20u,
                        0,
                        v140,
                        v113);
        v117 = a1;
        if ( !(_DWORD)a1 )
          goto LABEL_54;
        LODWORD(a1) = v168;
        *(_QWORD *)(v117 + 600) = v168;
        if ( v140 >= 0x10000 )
          LODWORD(a1) = sub_2828C(v117, v3);
        return a1;
      }
      if ( v115 )
        goto LABEL_54;
      LODWORD(a1) = sub_321D4(
                      (int)v2,
                      0,
                      (char *)v116,
                      v164,
                      6u,
                      v143,
                      *(_BYTE *)(v3 + 90),
                      *(_BYTE *)(v3 + 90),
                      2,
                      0x20u,
                      0,
                      v140,
                      v113);
      v26 = a1;
      if ( !(_DWORD)a1 )
        goto LABEL_54;
      a1 = v168;
      *(double *)(v26 + 616) = sys_bdelay;
      *(_QWORD *)(v26 + 600) = a1;
LABEL_159:
      v49 = *(_DWORD *)(v26 + 68);
      if ( v34 != 3 )
      {
        if ( (v49 & 0x800) != 0 )
        {
          if ( v140 < 0x10000 )
            goto LABEL_162;
        }
        else if ( v140 >= 0x10000 )
        {
          goto LABEL_162;
        }
      }
      v50 = *(_DWORD *)(v26 + 300);
      v51 = *(_DWORD *)(v26 + 744);
      if ( (v49 & 0x4000) != 0 )
        *(_DWORD *)(v26 + 68) = v49 & 0xFFFFBFFF;
      v52 = v50 & 0xFFFFFE00;
      v53 = v51 + 1;
      *(_DWORD *)(v26 + 300) = v52;
      if ( (v49 & 0x4000) != 0 )
        *(_DWORD *)(v26 + 300) = v52 | 4;
      *(_DWORD *)(v26 + 744) = v53;
      LODWORD(a1) = sub_3362C(v155, v4, v134, *(_DWORD *)(v3 + 100));
      v144 = a1;
      if ( v168 )
      {
        if ( v168 == *(_QWORD *)(v26 + 568) )
        {
          v94 = *(_DWORD *)(v26 + 764) + 1;
          *(_DWORD *)(v26 + 300) |= 1u;
          *(_DWORD *)(v26 + 764) = v94;
          return a1;
        }
        if ( v134 == 5 )
        {
          if ( (unsigned int)v4 > 0xF )
          {
            v93 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
            LODWORD(a1) = sub_64E00(6, "receive: Unexpected stratum (%d) in broadcast from %s", v4, v93);
            return a1;
          }
        }
        else
        {
          v89 = v166;
          if ( (_DWORD)a1 )
          {
            if ( !v166 || !v167 )
            {
              ++*(_DWORD *)(v26 + 760);
              v90 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
              LODWORD(a1) = sub_64E00(6, "receive: KoD packet from %s has a zero org or rec timestamp.  Ignoring.", v90);
              return a1;
            }
            v95 = (_DWORD)v168 == (_DWORD)v166;
            if ( (_DWORD)v168 == (_DWORD)v166 )
              v95 = HIDWORD(v168) == HIDWORD(v166);
            v96 = !v95;
            if ( (_DWORD)v168 != (_DWORD)v167 )
              v96 |= 1u;
            if ( HIDWORD(v168) == HIDWORD(v167) )
              v97 = v96;
            else
              v97 = v96 | 1;
            if ( v97 )
            {
              ++*(_DWORD *)(v26 + 760);
              v98 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
              LODWORD(a1) = sub_64E00(
                              6,
                              "receive: KoD packet from %s has inconsistent xmt/org/rec timestamps.  Ignoring.",
                              v98);
              return a1;
            }
            v107 = *(_DWORD *)(v26 + 316);
            if ( v107 )
            {
              if ( v107 == 1 && *(_QWORD *)(v26 + 592) != v166 )
              {
                v136 = HIDWORD(v166);
                ++*(_DWORD *)(v26 + 760);
                v109 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
                LODWORD(a1) = sub_64E00(
                                6,
                                "receive: flip 1 KoD origin timestamp %#010x.%08x from %s does not match interleave %#010"
                                "x.%08x - ignoring.",
                                v89,
                                v136,
                                v109,
                                *(_DWORD *)(v26 + 592),
                                *(_DWORD *)(v26 + 596));
                return a1;
              }
            }
            else if ( *(_QWORD *)(v26 + 584) != v166 )
            {
              v135 = HIDWORD(v166);
              ++*(_DWORD *)(v26 + 760);
              v108 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
              LODWORD(a1) = sub_64E00(
                              6,
                              "receive: flip 0 KoD origin timestamp %#010x.%08x from %s does not match %#010x.%08x - ignoring.",
                              v89,
                              v135,
                              v108,
                              *(_DWORD *)(v26 + 584),
                              *(_DWORD *)(v26 + 588));
              return a1;
            }
          }
          else if ( *(_DWORD *)(v26 + 316) )
          {
            if ( v166 && v167 && (v106 = *(_DWORD *)(v26 + 576), *(_QWORD *)(v26 + 576)) )
            {
              v110 = v106 == (_DWORD)v166;
              if ( v106 == (_DWORD)v166 )
                v110 = *(_DWORD *)(v26 + 580) == HIDWORD(v166);
              if ( !v110 )
              {
                v111 = *(_DWORD *)(v26 + 300);
                v112 = *(_DWORD *)(v26 + 68) | 0x4000;
                ++*(_DWORD *)(v26 + 760);
                *(_DWORD *)(v26 + 68) = v112;
                *(_DWORD *)(v26 + 300) = v111 | 2;
              }
            }
            else
            {
              *(_DWORD *)(v26 + 300) |= 4u;
            }
          }
          else if ( v166 )
          {
            v99 = *(_DWORD *)(v26 + 584);
            v151 = *(_DWORD *)(v26 + 588);
            if ( *(_QWORD *)(v26 + 584) == v166 )
            {
              *(_DWORD *)(v26 + 588) = 0;
              *(_DWORD *)(v26 + 584) = 0;
            }
            else
            {
              v100 = *(_DWORD *)(v3 + 112);
              v101 = *(_DWORD *)(v3 + 116);
              v102 = *(_DWORD *)(v26 + 300) | 2;
              ++*(_DWORD *)(v26 + 760);
              *(_DWORD *)(v26 + 300) = v102;
              v161 = bswap32(v100);
              v156 = bswap32(v101);
              v103 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
              sub_64E00(
                6,
                "receive: Unexpected origin timestamp %#010x.%08x does not match aorg %#010x.%08x from %s@%s xmt %#010x.%08x",
                v161,
                v156,
                v99,
                v151,
                v158,
                v103,
                bswap32(*(_DWORD *)(v3 + 128)),
                bswap32(*(_DWORD *)(v3 + 132)));
              v104 = *(_QWORD *)(v26 + 576);
              if ( v104 && v104 == v166 )
              {
                if ( dynamic_interleave )
                {
                  *(_DWORD *)(v26 + 316) = 1;
                  sub_25EE0((_WORD *)&dword_8C + 1, v26, 0);
                }
                else
                {
                  v105 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
                  sub_64E00(6, "receive: Dynamic interleave from %s@%s denied", v158, v105);
                }
              }
            }
          }
          else
          {
            v91 = *(_DWORD *)(v26 + 300) | 2;
            ++*(_DWORD *)(v26 + 760);
            *(_DWORD *)(v26 + 300) = v91;
            v92 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
            sub_64E00(
              6,
              "receive: %s 0 origin timestamp from %s@%s xmt %#010x.%08x",
              "Drop",
              v158,
              v92,
              bswap32(*(_DWORD *)(v3 + 128)),
              bswap32(*(_DWORD *)(v3 + 132)));
          }
        }
      }
      else
      {
        *(_DWORD *)(v26 + 300) |= 4u;
        if ( (_DWORD)a1 )
        {
          ++*(_DWORD *)(v26 + 760);
          v88 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
          LODWORD(a1) = sub_64E00(6, "receive: Unexpected zero transmit timestamp in KoD from %s", v88);
          return a1;
        }
      }
      if ( v159 == 2 )
      {
        LODWORD(a1) = sub_25EE0((__int16 *)&dword_8C, v26, "crypto_NAK");
        HIDWORD(a1) = *(_DWORD *)(v26 + 68);
        v87 = *(_DWORD *)(v26 + 752) + 1;
        *(_DWORD *)(v26 + 300) |= 0x10u;
        *(_DWORD *)(v26 + 752) = v87;
        if ( (a1 & 0x200000000LL) == 0 )
        {
          if ( !*(_DWORD *)(v26 + 136) )
            return a1;
          goto LABEL_199;
        }
        if ( !unpeer_crypto_nak_early )
          return a1;
LABEL_182:
        LODWORD(a1) = sub_31FC4(v26);
        return a1;
      }
      if ( v141 | *(_DWORD *)(v26 + 124) || (v142 & 4) != 0 )
        v54 = v34 != 1;
      else
        v54 = v34 > 1;
      if ( v54 )
      {
        if ( (*(_DWORD *)(v26 + 300) & 0x1FF) != 0 )
        {
          v55 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
          LODWORD(a1) = sub_64E00(6, "receive: Bad auth in packet with bad timestamps from %s denied - spoof?", v55);
          return a1;
        }
        LODWORD(a1) = sub_25EE0((__int16 *)&dword_8C, v26, "digest");
        v56 = *(_DWORD *)(v26 + 752);
        *(_DWORD *)(v26 + 300) |= 0x10u;
        *(_DWORD *)(v26 + 752) = v56 + 1;
        if ( v141 && (unsigned int)(v134 - 1) <= 1 )
          LODWORD(a1) = sub_C170(v3, 1, 0, v138);
        if ( (*(_DWORD *)(v26 + 68) & 2) != 0 )
        {
          if ( !unpeer_digest_early )
            return a1;
          goto LABEL_182;
        }
        if ( !peer_clear_digest_early || !*(_DWORD *)(v26 + 136) )
          return a1;
LABEL_199:
        LODWORD(a1) = sub_36214(v26, (int *)"AUTH");
        return a1;
      }
      if ( v134 != 5 )
      {
        if ( *(_DWORD *)(v26 + 316) )
          goto LABEL_187;
        *(_QWORD *)(v26 + 560) = v168;
        goto LABEL_186;
      }
      if ( (int)v34 > 1 )
      {
        v65 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
        sub_64E00(6, "receive: Bad broadcast auth (%d) from %s", v34, v65);
      }
      else
      {
        v59 = *(_DWORD *)(v26 + 68) & 0x2000;
        if ( v166 )
        {
          if ( !v59 )
          {
            v61 = (_DWORD *)(v3 + 72);
            v62 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
            sub_64E00(6, "receive: Broadcast server at %s is in interleave mode", v62);
            v63 = v168;
            *(_DWORD *)(v26 + 68) |= 0x2000u;
            *(_QWORD *)(v26 + 584) = v63;
            HIDWORD(v63) = v61[1];
            *(_DWORD *)(v26 + 592) = *v61;
            *(_DWORD *)(v26 + 596) = HIDWORD(v63);
            LODWORD(a1) = sub_25EE0((_WORD *)&dword_8C + 1, v26, 0);
            return a1;
          }
        }
        else if ( v59 )
        {
          v64 = sub_6C2E8((unsigned __int16 *)(v26 + 16));
          sub_64E00(6, "receive: Broadcast server at %s is no longer in interleave mode", v64);
          *(_DWORD *)(v26 + 68) &= ~0x2000u;
        }
      }
      v60 = *(_DWORD *)(v26 + 316);
      *(_QWORD *)(v26 + 600) = v168;
      if ( !v60 )
      {
LABEL_186:
        v57 = *(_DWORD *)(v3 + 76);
        *(_DWORD *)(v26 + 576) = *(_DWORD *)(v3 + 72);
        *(_DWORD *)(v26 + 580) = v57;
      }
LABEL_187:
      LODWORD(a1) = v168;
      *(_QWORD *)(v26 + 568) = v168;
      v58 = *(unsigned __int8 *)(v3 + 90);
      if ( v58 < *(unsigned __int8 *)(v26 + 65) )
        LOBYTE(v58) = *(_BYTE *)(v26 + 65);
      *(_BYTE *)(v26 + 94) = v58;
      if ( v144 == 1 )
      {
        ++*(_DWORD *)(v26 + 772);
        sub_25EE0((__int16 *)((char *)&dword_84 + 3), v26, 0);
        v82 = *(unsigned __int8 *)(v3 + 90);
        v83 = *(unsigned __int8 *)(v26 + 65);
        if ( v83 < v82 )
        {
          LOBYTE(v83) = *(_BYTE *)(v26 + 94);
          *(_BYTE *)(v26 + 65) = v83;
        }
        *(_DWORD *)(v26 + 312) = 0;
        *(_DWORD *)(v26 + 712) = 9 << v83;
        *(_DWORD *)(v26 + 308) = 0;
        LODWORD(a1) = sub_34264(v26, v82);
        return a1;
      }
      if ( v144 )
      {
        ++*(_DWORD *)(v26 + 772);
        return a1;
      }
      if ( v134 != 3 )
      {
        v66 = v34 == 1;
        if ( !v140 )
          v66 = 0;
        if ( v66 )
        {
          if ( v140 < 0x10000 && !sub_623A4(v140, (unsigned __int16 *)(v26 + 16)) )
          {
            LODWORD(a1) = sub_25EE0((__int16 *)&dword_8C, v26, "authIP");
            ++*(_DWORD *)(v26 + 752);
            return a1;
          }
          v67 = *(_DWORD *)(v26 + 68);
          v68 = current_time;
          *(_DWORD *)(v26 + 732) = current_time;
          *(_DWORD *)(v26 + 728) = v68;
          goto LABEL_210;
        }
      }
      v67 = *(_DWORD *)(v26 + 68);
      v81 = current_time;
      *(_DWORD *)(v26 + 732) = current_time;
      *(_DWORD *)(v26 + 728) = v81;
      if ( v34 == 1 )
      {
LABEL_210:
        v69 = v67 | 4;
        *(_DWORD *)(v26 + 68) = v69;
        goto LABEL_211;
      }
      v69 = v67 & 0xFFFFFFFB;
      *(_DWORD *)(v26 + 68) = v69;
LABEL_211:
      if ( (v69 & 0x800) != 0 )
      {
        v70 = *(_DWORD **)(v26 + 220);
        if ( v70 )
        {
          v71 = v70[1];
          if ( v71 > 0 )
            v70[1] = v71 - 1;
        }
        *(_DWORD *)(v26 + 300) |= 0x80u;
        LODWORD(a1) = sub_2828C(v26, v3);
        if ( (_DWORD)a1 != 256 )
        {
          if ( (_DWORD)a1 != 271 )
            return a1;
          sub_25EE0((__int16 *)((char *)&dword_84 + 1), v26, "crypto error");
          LODWORD(a1) = sub_36214(v26, (int *)"CRYP");
          v72 = *(_DWORD *)(v26 + 68);
          *(_DWORD *)(v26 + 300) |= 0x100u;
          if ( (v72 & 2) == 0 || !unpeer_crypto_early )
            return a1;
          goto LABEL_182;
        }
        *(_DWORD *)(v26 + 708) = 0;
        if ( v134 == 4 )
        {
          if ( *(_DWORD *)(v26 + 124) == v140 )
            *(_DWORD *)(v26 + 300) &= ~0x80u;
        }
        else if ( (*(_DWORD *)(v26 + 300) & 0x80) != 0 )
        {
          if ( v70 )
          {
            v84 = v153;
            for ( i = 0; ; ++i )
            {
              v86 = v70[1];
              if ( *(_DWORD *)(v26 + 160) == v84 || *v70 == v84 )
                break;
              if ( i > v86 )
              {
                v129 = *(_DWORD *)(v26 + 300);
                *(_DWORD *)(v26 + 136) &= ~0x1000u;
                goto LABEL_354;
              }
              v84 = sub_272C8(v2, (unsigned int)v147, v84, s, 0);
            }
            v129 = *(_DWORD *)(v26 + 300) & 0xFFFFFF7F;
            *(_DWORD *)(v26 + 160) = v140;
            *(_DWORD *)(v26 + 300) = v129;
            v70[1] = v86 - i;
LABEL_354:
            if ( (v129 & 0x80) != 0 )
              sub_25EE0((__int16 *)&dword_8C, v26, "keylist");
          }
        }
        else
        {
          *(_DWORD *)(v26 + 160) = v140;
        }
        v130 = *(_DWORD *)(v26 + 236);
        if ( (*(_DWORD *)(v26 + 136) & 0x400) == 0 )
          *(_DWORD *)(v26 + 300) |= 0x80u;
        if ( v130 < current_time )
        {
          sub_25EE0((__int16 *)((char *)&dword_84 + 1), v26, "crypto refresh");
          LODWORD(a1) = sub_36214(v26, (int *)"TIME");
          return a1;
        }
      }
      LODWORD(a1) = sub_359B0(v26, v148, *(_DWORD *)(v3 + 84));
      if ( *(_DWORD *)(v26 + 316) )
      {
        v73 = HIDWORD(v167);
        v74 = (_DWORD *)(v3 + 72);
        v75 = current_time;
        *(_DWORD *)(v26 + 560) = v167;
        *(_DWORD *)(v26 + 564) = v73;
        v76 = v74[1];
        v77 = *(_DWORD *)(v26 + 720);
        *(_DWORD *)(v26 + 576) = *v74;
        *(_DWORD *)(v26 + 580) = v76;
        LODWORD(a1) = *(unsigned __int8 *)(v26 + 94);
        v78 = v77 - v75;
        HIDWORD(a1) = *(unsigned __int8 *)(v26 + 64);
        if ( (unsigned int)a1 >= HIDWORD(a1) )
          v79 = 1 << SBYTE4(a1);
        else
          v79 = 1 << a1;
        if ( v78 >= v79 >> 1 )
          v80 = v77 - 1;
        else
          v80 = v77 + 1;
        *(_DWORD *)(v26 + 720) = v80;
      }
      break;
    default:
      goto LABEL_103;
  }
  return a1;
}
// 84: using guessed type int dword_84;
// 8C: using guessed type int dword_8C;
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// B6C08: using guessed type int unpeer_digest_early;
// B6C0C: using guessed type int unpeer_crypto_nak_early;
// B6C10: using guessed type int unpeer_crypto_early;
// B6C14: using guessed type int peer_clear_digest_early;
// B6C30: using guessed type int sys_ceiling;
// B9918: using guessed type int sys_groupname;
// B9920: using guessed type int crypto_flags;
// BC708: using guessed type int dynamic_interleave;
// BC70C: using guessed type int sys_cohort;
// BC710: using guessed type char sys_bcpollbstep;
// BC714: using guessed type int sys_floor;
// BC718: using guessed type int sys_ident;
// 107D4C: using guessed type int any_interface;
// 107D50: using guessed type int any6_interface;
// 108B98: using guessed type int sys_badauth;
// 108BAC: using guessed type int sys_authenticate;
// 108BB0: using guessed type int sys_newversion;
// 108BC0: using guessed type char sys_leap;
// 108BE0: using guessed type int ntp_mode7;
// 108BE8: using guessed type double sys_bdelay;
// 108BFC: using guessed type int sys_received;
// 108C00: using guessed type int sys_restricted;
// 108C10: using guessed type int sys_limitrejected;
// 108C14: using guessed type char sys_stratum;
// 108C1C: using guessed type int sys_declined;
// 108C24: using guessed type int sys_manycastserver;
// 108C28: using guessed type int sys_badlength;
// 108C38: using guessed type int sys_oldversion;
// 108C3C: using guessed type int sys_private;
// 108C48: using guessed type int sys_bclient;
// 108CA4: using guessed type int current_time;

//----- (000386B0) --------------------------------------------------------
char *sub_386B0()
{
  double v0; // d0
  char i; // r3
  char *result; // r0

  if ( v0 > 1.0 )
    return sub_64E00(3, "unsupported tick %.3f > 1s ignored", v0);
  if ( measured_tick > v0 )
    return sub_64E00(3, "proto: tick %.3f less than measured tick %.3f, ignored", v0, measured_tick);
  if ( measured_tick < v0 )
  {
    trunc_os_clock = 1;
    result = sub_64E00(5, "proto: truncating system clock to multiples of %.9f", v0);
  }
  sys_tick = v0;
  for ( i = 0; v0 <= 1.0; --i )
    v0 = v0 + v0;
  if ( v0 - 1.0 > 1.0 - v0 * 0.5 )
    ++i;
  sys_precision = i;
  return result;
}
// 386DC: variable 'v0' is possibly undefined
// 106F58: using guessed type double sys_tick;
// 108BA8: using guessed type char sys_precision;
// 108CE0: using guessed type double measured_tick;
// 108CF0: using guessed type int trunc_os_clock;

//----- (00038810) --------------------------------------------------------
void __fastcall sub_38810(int a1, __int16 *a2, char *s2)
{
  double v3; // d0
  int *v4; // r12

  switch ( a1 )
  {
    case 1:
      sys_bclient = (int)a2;
      if ( a2 )
        sub_1621C();
      else
        sub_1640C();
      break;
    case 3:
      sys_authenticate = (int)a2;
      break;
    case 4:
      if ( v3 == 0.0 )
        v3 = -0.05;
      sys_bdelay = v3;
      break;
    case 6:
      if ( s2 )
        sub_164F4(s2);
      sys_bclient = 1;
      break;
    case 7:
      if ( s2 )
        sub_167AC((unsigned __int16 *)s2);
      break;
    case 8:
      ntp_enable = (int)a2;
      break;
    case 9:
      sub_303FC(a2);
      break;
    case 10:
      if ( a2 )
      {
        sub_30CD4(1);
      }
      else
      {
        sub_30DFC(1u);
        if ( mon_enabled )
          sub_64E00(4, "restrict: 'monitor' cannot be disabled while 'limited' is enabled");
      }
      break;
    case 11:
      stats_control = (int)a2;
      break;
    case 12:
      hardpps_enable = (int)a2;
      break;
    case 13:
      cal_enable = (int)a2;
      break;
    case 14:
      sys_minclock = (int)v3;
      break;
    case 15:
      sys_maxclock = (int)v3;
      break;
    case 16:
      sys_minsane = (int)v3;
      break;
    case 17:
      sys_floor = (int)v3;
      break;
    case 18:
      sys_ceiling = (int)v3;
      break;
    case 19:
      sys_cohort = (int)v3;
      break;
    case 20:
      return;
    case 21:
      sys_mindisp = v3;
      break;
    case 22:
      sys_maxdist = v3;
      break;
    case 25:
      sys_beacon = (Elf32_Sym *)(int)v3;
      break;
    case 26:
      sys_orphan = (int)v3;
      break;
    case 27:
      v4 = sys_orphwait;
      sys_orphwait = (int *)(int)v3;
      orphwait = (int)v3 + orphwait - (_DWORD)v4;
      break;
    case 28:
      ntp_mode7 = (int)a2;
      break;
    case 29:
      unpeer_crypto_early = (int)a2;
      break;
    case 30:
      unpeer_crypto_nak_early = (int)a2;
      break;
    case 31:
      unpeer_digest_early = (int)a2;
      break;
    case 32:
      peer_clear_digest_early = (int)a2;
      break;
    case 33:
      sys_bcpollbstep = (unsigned int)v3;
      break;
    default:
      sub_64E00(5, "proto: unsupported option %d");
      break;
  }
}
// 38908: variable 'v3' is possibly undefined
// B6AEC: using guessed type int ntp_enable;
// B6C08: using guessed type int unpeer_digest_early;
// B6C0C: using guessed type int unpeer_crypto_nak_early;
// B6C10: using guessed type int unpeer_crypto_early;
// B6C14: using guessed type int peer_clear_digest_early;
// B6C18: using guessed type Elf32_Sym *sys_beacon;
// B6C1C: using guessed type int *sys_orphwait;
// B6C20: using guessed type int sys_orphan;
// B6C24: using guessed type int sys_maxclock;
// B6C28: using guessed type int sys_minclock;
// B6C2C: using guessed type int sys_minsane;
// B6C30: using guessed type int sys_ceiling;
// B6C38: using guessed type double sys_maxdist;
// B6C40: using guessed type double sys_mindisp;
// BC70C: using guessed type int sys_cohort;
// BC710: using guessed type char sys_bcpollbstep;
// BC714: using guessed type int sys_floor;
// 1082B4: using guessed type int hardpps_enable;
// 108358: using guessed type int mon_enabled;
// 108BAC: using guessed type int sys_authenticate;
// 108BE0: using guessed type int ntp_mode7;
// 108BE8: using guessed type double sys_bdelay;
// 108C48: using guessed type int sys_bclient;
// 108C54: using guessed type int cal_enable;
// 108CB0: using guessed type int orphwait;
// 108CD0: using guessed type int stats_control;

//----- (00038C70) --------------------------------------------------------
int sub_38C70()
{
  int v1; // [sp+4h] [bp-4h]

  sys_stattime = current_time;
  sys_received = 0;
  sys_processed = 0;
  sys_newversion = 0;
  sys_oldversion = 0;
  sys_declined = 0;
  sys_restricted = 0;
  sys_badlength = 0;
  sys_badauth = 0;
  sys_limitrejected = 0;
  sys_kodsent = 0;
  sys_lamport = 0;
  sys_tsrounding = 0;
  return v1;
}
// 38D30: variable 'v1' is possibly undefined
// 108B98: using guessed type int sys_badauth;
// 108BB0: using guessed type int sys_newversion;
// 108BD4: using guessed type int sys_kodsent;
// 108BFC: using guessed type int sys_received;
// 108C00: using guessed type int sys_restricted;
// 108C10: using guessed type int sys_limitrejected;
// 108C18: using guessed type int sys_processed;
// 108C1C: using guessed type int sys_declined;
// 108C20: using guessed type int sys_stattime;
// 108C28: using guessed type int sys_badlength;
// 108C38: using guessed type int sys_oldversion;
// 108CA4: using guessed type int current_time;
// 108CE8: using guessed type int sys_lamport;
// 108CEC: using guessed type int sys_tsrounding;

//----- (00038D98) --------------------------------------------------------
int *sub_38D98()
{
  int v0; // r6
  int v1; // r8
  int v2; // r10
  double v3; // d8
  double v4; // r0
  double v5; // r0
  bool v6; // cc
  int v7; // r3
  unsigned int v8; // r12
  __int64 v9; // r0
  double v10; // r0
  double v11; // d0
  int v12; // r2
  double v13; // r0
  double v14; // d0
  int v15; // r2
  int v17; // [sp+8h] [bp-14h]
  int v18; // [sp+14h] [bp-8h] BYREF
  unsigned int v19; // [sp+18h] [bp-4h]
  int v20; // [sp+1Ch] [bp+0h] BYREF
  unsigned int v21; // [sp+20h] [bp+4h]

  v0 = 0;
  v1 = 0;
  v17 = 0;
  v2 = 0;
  v3 = 1.0;
  sub_335A4(3);
  sys_stratum = 16;
  sys_refid = 1414090313;
  sys_peer = 0;
  sys_rootdelay = 0.0;
  sys_rootdisp = 0.0;
  LODWORD(v4) = &sys_reftime;
  dword_108C0C = 0;
  sys_reftime = 0;
  HIDWORD(v4) = &sys_jitter;
  sys_jitter = 0.0;
  sub_5F600(v4);
  trunc_os_clock = 0;
  sub_5F724(&v20);
  do
  {
    sub_5F724(&v18);
    v7 = v18 - v20;
    LODWORD(v5) = v18;
    if ( v19 < v21 )
      --v7;
    v8 = v19 - v21;
    v20 = v18;
    v21 = v19;
    if ( v7 == 0 || (unsigned int)v7 >= 0x80000000 )
    {
      HIDWORD(v5) = v8 > 0x55;
      if ( v7 )
        HIDWORD(v5) = 0;
      if ( !HIDWORD(v5) )
      {
        ++v2;
        goto LABEL_7;
      }
      if ( v1 < v2 )
        v1 = v2;
      ++v0;
      v9 = __PAIR64__(v7, 0) + v8;
LABEL_18:
      LODWORD(v11) = sub_8BEC4(v9);
      HIDWORD(v11) = HIDWORD(v10);
      LODWORD(v10) = -32;
      v5 = ldexp(v10, v12);
      goto LABEL_19;
    }
    if ( v1 < v2 )
      v1 = v2;
    ++v0;
    v9 = __PAIR64__(v7, 0) + v8;
    if ( v7 >= 0 )
      goto LABEL_18;
    LODWORD(v14) = sub_8BEC4(-(__int64)(__PAIR64__(v7, 0) + v8));
    HIDWORD(v14) = HIDWORD(v13);
    LODWORD(v13) = -32;
    v5 = ldexp(v13, v15);
    v11 = -v14;
LABEL_19:
    v2 = 0;
    if ( v11 < v3 )
      v3 = v11;
LABEL_7:
    v6 = v17 + 1 <= 49999999;
    if ( v17 + 1 <= 49999999 )
      v6 = v0 <= 11;
    ++v17;
  }
  while ( v6 );
  if ( v0 <= 11 )
  {
    sub_64E00(3, "Fatal error: precision could not be measured (MINSTEP too large?)");
    exit(1);
  }
  sub_5F600(v5);
  measured_tick = v3;
  sub_386B0();
  sub_64E00(6, "proto: precision = %.3f usec (%d)", sys_tick * 1000000.0, sys_precision);
  if ( sys_fuzz < sys_tick )
    sub_64E00(5, "proto: fuzz beneath %.3f usec", sys_fuzz * 1000000.0);
  sub_5F724(&v20);
  sys_survivors = 0;
  sys_manycastserver = 0;
  sys_bclient = 0;
  sys_bdelay = -0.05;
  sys_authenticate = 1;
  sys_stattime = current_time;
  orphwait = (int)sys_orphwait + current_time;
  sub_38C70();
  byte_108BDB = 96;
  byte_108BDC = 0x80;
  byte_108BDD = -96;
  sys_ttl[0] = 0;
  byte_108BD9 = 32;
  byte_108BDA = 64;
  byte_108BDF = -32;
  byte_108BDE = -64;
  sys_ttlmax = 7;
  hardpps_enable = 0;
  stats_control = 1;
  return &hardpps_enable;
}
// 38F18: variable 'v10' is possibly undefined
// 38F20: variable 'v12' is possibly undefined
// 38F44: variable 'v13' is possibly undefined
// 38F4C: variable 'v15' is possibly undefined
// 0: using guessed type int dword_0;
// B6C1C: using guessed type int *sys_orphwait;
// 106F50: using guessed type double sys_fuzz;
// 106F58: using guessed type double sys_tick;
// 1082B4: using guessed type int hardpps_enable;
// 108BA0: using guessed type double sys_jitter;
// 108BA8: using guessed type char sys_precision;
// 108BAC: using guessed type int sys_authenticate;
// 108BB8: using guessed type double sys_rootdisp;
// 108BC8: using guessed type double sys_rootdelay;
// 108BD0: using guessed type int sys_refid;
// 108BD9: using guessed type char byte_108BD9;
// 108BDA: using guessed type char byte_108BDA;
// 108BDB: using guessed type char byte_108BDB;
// 108BDC: using guessed type char byte_108BDC;
// 108BDD: using guessed type char byte_108BDD;
// 108BDE: using guessed type char byte_108BDE;
// 108BDF: using guessed type char byte_108BDF;
// 108BE8: using guessed type double sys_bdelay;
// 108BF8: using guessed type int sys_ttlmax;
// 108C08: using guessed type int sys_reftime;
// 108C0C: using guessed type int dword_108C0C;
// 108C14: using guessed type char sys_stratum;
// 108C20: using guessed type int sys_stattime;
// 108C24: using guessed type int sys_manycastserver;
// 108C2C: using guessed type int sys_peer;
// 108C48: using guessed type int sys_bclient;
// 108C4C: using guessed type int sys_survivors;
// 108CA4: using guessed type int current_time;
// 108CB0: using guessed type int orphwait;
// 108CD0: using guessed type int stats_control;
// 108CE0: using guessed type double measured_tick;
// 108CF0: using guessed type int trunc_os_clock;

//----- (000391E0) --------------------------------------------------------
int __fastcall sub_391E0(double *a1, double *a2)
{
  if ( *a1 < *a2 )
    return -1;
  else
    return *a1 > *a2;
}

//----- (00039248) --------------------------------------------------------
size_t __fastcall sub_39248(int a1)
{
  double v1; // d4
  int v2; // r3
  int v3; // r12
  double *v6; // r7
  _QWORD *v7; // r2
  size_t v8; // r5
  int v9; // r2
  unsigned int v10; // r11
  double v11; // r0
  unsigned int v12; // r12
  double v13; // d6
  double v14; // d7
  double v15; // d5
  double v16; // d6
  double *v17; // r6
  unsigned int v18; // r3
  double v19; // d7
  double v20; // d8
  double v21; // d0
  double v22; // d9
  double v23; // r0
  int v24; // r2
  double v25; // d8
  double v26; // d0
  _QWORD v27[60]; // [sp+0h] [bp-1ECh] BYREF
  _BYTE v28[4]; // [sp+1E8h] [bp-4h] BYREF

  v2 = *(_DWORD *)(a1 + 220);
  v3 = *(_DWORD *)(a1 + 216);
  if ( v3 == v2 )
    return 0;
  v6 = (double *)v27;
  v7 = v27;
  v8 = 0;
  do
  {
    ++v8;
    v2 = (v2 + 1) % 60;
    *v7++ = *(_QWORD *)(a1 + 8 * v2 + 264);
  }
  while ( v2 != v3 );
  *(_DWORD *)(a1 + 220) = v2;
  if ( v8 != 1 )
    qsort(v27, v8, 8u, (__compar_fn_t)sub_391E0);
  v9 = 858993460 * v8;
  v10 = v8;
  LODWORD(v11) = 0;
  v12 = v8 - 4 * v8 / 0xA;
LABEL_8:
  HIDWORD(v11) = &v27[v10];
  while ( v10 - LODWORD(v11) > v12 )
  {
    v9 = (int)v28;
    v13 = *(double *)(HIDWORD(v11) - 8);
    HIDWORD(v11) -= 8;
    v14 = *(double *)&v27[(2 * LODWORD(v11) + v10 - LODWORD(v11)) >> 1];
    if ( v13 - v14 < v14 - *v6 )
    {
      ++LODWORD(v11);
      ++v6;
      goto LABEL_8;
    }
    --v10;
  }
  *(_QWORD *)(a1 + 240) = 0;
  v15 = 0.0;
  *(_QWORD *)(a1 + 256) = 0;
  if ( v10 > LODWORD(v11) )
  {
    v9 = (int)v28;
    HIDWORD(v11) = &v28[8 * LODWORD(v11)];
    v17 = (double *)&v27[LODWORD(v11) + 1];
    v18 = LODWORD(v11);
    v16 = *(double *)(HIDWORD(v11) - 488) + 0.0;
    *(double *)(a1 + 240) = v16;
    while ( v10 != ++v18 )
    {
      v19 = *v17++;
      if ( LODWORD(v11) < v18 )
        v1 = *(v17 - 2);
      v16 = v16 + v19;
      if ( LODWORD(v11) < v18 )
        v19 = v19 - v1;
      *(double *)(a1 + 240) = v16;
      if ( LODWORD(v11) < v18 )
      {
        v15 = v15 + v19 * v19;
        *(double *)(a1 + 256) = v15;
      }
    }
  }
  else
  {
    v16 = 0.0;
  }
  v20 = (double)v12;
  v21 = v15 / (double)v12;
  *(double *)(a1 + 240) = v16 / (double)v12;
  v22 = sqrt(v21);
  if ( v21 < 0.0 )
    v11 = sqrt(v11);
  LODWORD(v11) = sys_precision;
  v23 = ldexp(v11, v9);
  if ( v22 > 1.0 )
  {
    v26 = *(double *)(a1 + 256) / v20;
    v25 = sqrt(v26);
    if ( v26 < 0.0 )
      sqrt(v23);
  }
  else
  {
    LODWORD(v23) = sys_precision;
    ldexp(v23, v24);
    v25 = 1.0;
  }
  *(double *)(a1 + 256) = v25;
  return v8;
}
// 3939C: variable 'v1' is possibly undefined
// 393EC: variable 'v9' is possibly undefined
// 39404: variable 'v24' is possibly undefined
// 108BA8: using guessed type char sys_precision;

//----- (000394A0) --------------------------------------------------------
__int16 *__fastcall sub_394A0(__int16 *result, int a2)
{
  int v2; // r2
  int v3; // r5
  const char *v4; // r2
  unsigned int v5; // r3
  unsigned int v6; // r3

  v2 = *((_DWORD *)result + 21);
  if ( v2 )
  {
    v3 = (int)result;
    switch ( a2 )
    {
      case 1:
        ++*(_DWORD *)(v2 + 780);
        goto LABEL_9;
      case 2:
        ++*(_DWORD *)(v2 + 784);
        v6 = *(unsigned __int8 *)(v2 + 42);
        if ( v6 <= 0xE )
          *(_BYTE *)(v2 + 42) = v6 + 1;
        goto LABEL_6;
      case 5:
      case 6:
        ++*(_DWORD *)(v2 + 788);
        goto LABEL_5;
      default:
LABEL_5:
        if ( a2 )
        {
LABEL_9:
          v5 = *(unsigned __int8 *)(v2 + 42);
          if ( v5 <= 0xE )
            *(_BYTE *)(v2 + 42) = v5 + 1;
        }
LABEL_6:
        if ( *(unsigned __int8 *)(v2 + 41) != a2 )
        {
          *(_BYTE *)(v2 + 41) = a2;
          v4 = sub_6D480(a2);
          result = sub_25EE0((__int16 *)((char *)&dword_88 + 3), v3, v4);
        }
        break;
    }
  }
  return result;
}
// 88: using guessed type int dword_88;

//----- (000395B0) --------------------------------------------------------
int sub_395B0()
{
  int v0; // r4
  int *v1; // r5
  int v2; // t1
  int (*v3)(void); // r3
  int result; // r0

  if ( num_refclock_conf )
  {
    v0 = 0;
    v1 = (int *)&refclock_conf;
    do
    {
      v2 = *v1++;
      v3 = *(int (**)(void))(v2 + 16);
      if ( v3 )
        result = v3();
      ++v0;
    }
    while ( (unsigned __int8)num_refclock_conf > v0 );
  }
  return result;
}
// B5398: using guessed type _UNKNOWN *refclock_conf;
// B6D98: using guessed type char num_refclock_conf;

//----- (00039640) --------------------------------------------------------
void __fastcall sub_39640(int a1)
{
  void *v2; // r0
  void (__fastcall *v3)(_DWORD, int); // r3

  v2 = *(void **)(a1 + 84);
  if ( v2 )
  {
    v3 = (void (__fastcall *)(_DWORD, int))*((_DWORD *)*(&refclock_conf + *(unsigned __int8 *)(a1 + 88)) + 1);
    if ( v3 )
    {
      v3(*(unsigned __int8 *)(a1 + 89), a1);
      v2 = *(void **)(a1 + 84);
    }
    free(v2);
    *(_DWORD *)(a1 + 84) = 0;
  }
}
// B5398: using guessed type _UNKNOWN *refclock_conf;

//----- (000396D4) --------------------------------------------------------
int __fastcall sub_396D4(int a1)
{
  unsigned int v2; // r7
  int v3; // r5
  const char *v4; // r0
  int (__fastcall **v6)(_DWORD, int); // r11
  _BYTE *v7; // r10
  char v8; // r12
  int v9; // r2
  int v10; // r3
  bool v11; // zf

  if ( *(_WORD *)(a1 + 16) == 2 && (v2 = bswap32(*(_DWORD *)(a1 + 20)), HIWORD(v2) << 16 == 2139029504) )
  {
    if ( (unsigned __int8)num_refclock_conf > (unsigned int)BYTE1(v2)
      && (v6 = (int (__fastcall **)(_DWORD, int))*(&refclock_conf + BYTE1(v2)), *v6) )
    {
      v7 = sub_63BA4(0, 0x318u, 0, 1);
      v8 = *(_BYTE *)(a1 + 66);
      v9 = *(_DWORD *)(a1 + 68) | 8;
      *(_BYTE *)(a1 + 91) = 3;
      *(_BYTE *)(a1 + 93) = 0;
      *(_BYTE *)(a1 + 88) = BYTE1(v2);
      *(_BYTE *)(a1 + 89) = v2;
      *(_DWORD *)(a1 + 68) = v9;
      *(_BYTE *)(a1 + 94) = v8;
      *(_DWORD *)(a1 + 84) = v7;
      v7[43] = BYTE1(v2);
      *((_DWORD *)v7 + 1) = v6;
      *((_DWORD *)v7 + 7) = -1;
      *((_DWORD *)v7 + 193) = current_time;
      v10 = *(unsigned __int8 *)(a1 + 63);
      v11 = v10 == 1;
      if ( v10 == 1 )
        *(_BYTE *)(a1 + 92) = 2;
      else
        LOBYTE(v10) = 4;
      if ( !v11 )
        *(_BYTE *)(a1 + 92) = v10;
      v3 = (*v6)((unsigned __int8)v2, a1);
      if ( v3 )
      {
        v3 = 1;
        *(_DWORD *)(a1 + 112) = *((_DWORD *)v7 + 191);
      }
      else
      {
        sub_39640(a1);
      }
    }
    else
    {
      v3 = 0;
      sub_64E00(3, "refclock_newpeer: clock type %d invalid\n", BYTE1(v2));
    }
  }
  else
  {
    v3 = 0;
    v4 = sub_6C2E8((unsigned __int16 *)(a1 + 16));
    sub_64E00(3, "refclock_newpeer: clock address %s invalid", v4);
  }
  return v3;
}
// B5398: using guessed type _UNKNOWN *refclock_conf;
// B6D98: using guessed type char num_refclock_conf;
// 108CA4: using guessed type int current_time;

//----- (0003987C) --------------------------------------------------------
int __fastcall sub_3987C(int a1)
{
  _DWORD *v1; // r6
  int result; // r0
  int (__fastcall *v4)(int, int); // r3
  int (__fastcall *v5)(int); // r2

  v1 = *(_DWORD **)(a1 + 84);
  result = *(unsigned __int8 *)(a1 + 89);
  v4 = *(int (__fastcall **)(int, int))(v1[1] + 24);
  if ( v4 )
    result = v4(result, a1);
  v5 = (int (__fastcall *)(int))v1[13];
  if ( v5 )
  {
    if ( v1[12] <= (unsigned int)current_time )
      return v5(a1);
  }
  return result;
}
// 108CA4: using guessed type int current_time;

//----- (0003992C) --------------------------------------------------------
#error "39A10: call analysis failed (funcsize=74)"

//----- (00039A70) --------------------------------------------------------
int __fastcall sub_39A70(_DWORD *a1, int a2, unsigned int a3)
{
  double v3; // d0
  int v5; // r3
  __int64 v6; // r6
  double v7; // d8
  double v8; // r0
  double v9; // d0
  int v10; // r2
  int result; // r0
  int v12; // r1
  int v13; // r2
  int v14; // r3
  double v15; // r0
  double v16; // d0
  int v17; // r2
  int vars24; // [sp+3Ch] [bp+24h]
  unsigned int _40; // [sp+40h] [bp+28h]

  v5 = a2 - vars24;
  if ( a3 < _40 )
    --v5;
  v6 = __PAIR64__(v5, 0) + a3 - _40;
  v7 = v3;
  a1[58] = vars24;
  a1[59] = _40;
  if ( v5 < 0 )
  {
    LODWORD(v16) = sub_8BEC4(-v6);
    HIDWORD(v16) = HIDWORD(v15);
    LODWORD(v15) = -32;
    ldexp(v15, v17);
    v9 = -v16;
  }
  else
  {
    LODWORD(v9) = sub_8BEC4(v6);
    HIDWORD(v9) = HIDWORD(v8);
    LODWORD(v8) = -32;
    ldexp(v8, v10);
  }
  result = -2004318071;
  v12 = a1[55];
  v13 = a1[54] + 1;
  a1[54] = v13 % 60;
  *(double *)&a1[2 * (v13 % 60) + 66] = v9 + v7;
  if ( v13 % 60 == v12 )
  {
    v14 = v13 % 60 + 1;
    result = -2004318071 * v14;
    a1[55] = v14 % 60;
  }
  return result;
}
// 39ABC: variable 'vars24' is possibly undefined
// 39AC8: variable '_40' is possibly undefined
// 39AE8: variable 'v3' is possibly undefined
// 39B08: variable 'v8' is possibly undefined
// 39B10: variable 'v10' is possibly undefined
// 39BA8: variable 'v15' is possibly undefined
// 39BB0: variable 'v17' is possibly undefined

//----- (00039BC8) --------------------------------------------------------
int __fastcall sub_39BC8(_DWORD *a1)
{
  double v2; // r0
  int v3; // r2
  int v4; // s15
  double v5; // d0
  int v6; // r1
  __int64 v7; // r8
  __int64 v8; // r0
  unsigned int v10; // [sp+14h] [bp-10h] BYREF
  unsigned int v11; // [sp+18h] [bp-Ch]

  LODWORD(v2) = sub_633D8(a1[48], a1[49], a1[50], a1[51], 0, a1[58], a1 + 53, &v10);
  if ( LODWORD(v2) )
  {
    v4 = a1[52];
    v11 = 0;
    v5 = (double)v4 / 1000000000.0;
    LODWORD(v2) = 32;
    ldexp(v2, v3);
    if ( v5 < 0.0 )
    {
      LODWORD(v8) = sub_8C010(-v5);
      v7 = -v8;
    }
    else
    {
      LODWORD(v7) = sub_8C010(v5);
      HIDWORD(v7) = v6;
    }
    v10 = (v7 + __PAIR64__(v10, v11)) >> 32;
    v11 += v7;
    sub_39A70(a1, v10, v11);
    LODWORD(v2) = 1;
  }
  return LODWORD(v2);
}
// 39C4C: variable 'v2' is possibly undefined
// 39C4C: variable 'v3' is possibly undefined
// 39C5C: variable 'v6' is possibly undefined
// 39CD8: variable 'v8' is possibly undefined

//----- (00039CF8) --------------------------------------------------------
int __fastcall sub_39CF8(_DWORD *a1)
{
  return sub_39BC8(a1);
}

//----- (00039D44) --------------------------------------------------------
#error "39E14: call analysis failed (funcsize=92)"

//----- (00039EE4) --------------------------------------------------------
_BYTE *__fastcall sub_39EE4(int a1, bool *a2, int a3, _DWORD *a4)
{
  _BYTE *v4; // r2
  char *v5; // r12
  bool *v6; // r4
  bool *v7; // lr
  int v8; // r5
  char v9; // t1
  int v10; // r2
  bool v11; // zf
  bool v12; // r7
  _DWORD *v13; // r0
  int v14; // r1

  if ( a3 <= 0 )
    return 0;
  v5 = (char *)(a1 + 88);
  v6 = &a2[a3 - 1];
  v7 = a2;
  v8 = a1 + 88 + *(_DWORD *)(a1 + 84);
  while ( 1 )
  {
    v11 = v5 == (char *)v8;
    if ( v5 != (char *)v8 )
      v11 = v7 == v6;
    v12 = !v11;
    if ( v11 )
      break;
    v9 = *v5++;
    v10 = v9 & 0x7F;
    if ( (unsigned int)(v10 - 32) <= 0x5E )
      *v7++ = v10;
  }
  v4 = (_BYTE *)(v7 - a2);
  v13 = (_DWORD *)(a1 + 72);
  if ( v7 != a2 )
    *v7 = v12;
  v14 = v13[1];
  *a4 = *v13;
  a4[1] = v14;
  return v4;
}

//----- (00039F94) --------------------------------------------------------
size_t __fastcall sub_39F94(_DWORD *a1, void *dest, int a3, _DWORD *a4)
{
  size_t v5; // r4
  _DWORD *v7; // r5
  int v8; // r1

  if ( a3 <= 0 )
    return 0;
  v5 = a3 - 1;
  v7 = a1 + 18;
  if ( a3 - 1 >= a1[21] )
    v5 = a1[21];
  memcpy(dest, a1 + 22, v5);
  *((_BYTE *)dest + v5) = 0;
  v8 = v7[1];
  *a4 = *v7;
  a4[1] = v8;
  return v5;
}

//----- (0003A02C) --------------------------------------------------------
int __fastcall sub_3A02C(int a1, char *a2)
{
  int (__fastcall *v2)(char *); // r5

  v2 = *(int (__fastcall **)(char *))(a1 + 8);
  if ( v2 && !v2(a2) )
  {
    sub_69FA8(a2);
    return 1;
  }
  else
  {
    sub_6A044(a2);
    return 0;
  }
}

//----- (0003A0AC) --------------------------------------------------------
int __fastcall sub_3A0AC(int a1, speed_t a2, __int16 a3)
{
  tcflag_t v6; // r3
  struct termios *p_c_line; // r3
  tcflag_t v8; // r3
  int *v10; // r4
  int v11; // r5
  int *v12; // r4
  int v13; // r5
  int v14; // [sp+4h] [bp-44h] BYREF
  struct termios termios_p; // [sp+8h] [bp-40h] BYREF

  if ( tcgetattr(a1, &termios_p) < 0 )
  {
    v12 = _errno_location();
    v13 = *v12;
    sub_64E00(3, "refclock_setup fd %d tcgetattr: %m", a1);
    *v12 = v13;
    return 0;
  }
  else
  {
    if ( a2 )
    {
      v14 = 0;
      termios_p.c_iflag = 261;
      termios_p.c_oflag = 0;
      if ( (a3 & 0x100) != 0 )
        v6 = 2976;
      else
        v6 = 2224;
      termios_p.c_cflag = v6;
      cfsetispeed(&termios_p, a2);
      cfsetospeed(&termios_p, a2);
      p_c_line = (struct termios *)&termios_p.c_line;
      do
      {
        BYTE1(p_c_line->c_iflag) = 0;
        p_c_line = (struct termios *)((char *)p_c_line + 1);
      }
      while ( p_c_line != (struct termios *)&termios_p.c_cc[31] );
      if ( ioctl(a1, 0x5415u, &v14) < 0 )
        sub_64E00(3, "refclock_setup fd %d TIOCMGET: %m", a1);
      if ( (v14 & 0x100) != 0 && (a3 & 0x80) != 0 )
        termios_p.c_cflag &= ~0x800u;
    }
    if ( (a3 & 0x20) != 0 )
      v8 = 0;
    else
      v8 = 2;
    termios_p.c_lflag = v8;
    if ( (a3 & 0x20) != 0 )
    {
      termios_p.c_iflag = v8;
      termios_p.c_cc[6] = 1;
    }
    if ( (a3 & 0x40) != 0 )
      termios_p.c_lflag |= 8u;
    if ( tcsetattr(a1, 0, &termios_p) < 0 )
    {
      v10 = _errno_location();
      v11 = *v10;
      sub_64E00(3, "refclock_setup fd %d TCSANOW: %m", a1);
      *v10 = v11;
      return 0;
    }
    else
    {
      if ( tcflush(a1, 2) < 0 )
        sub_64E00(3, "refclock_setup fd %d tcflush(): %m", a1);
      return 1;
    }
  }
}

//----- (0003A298) --------------------------------------------------------
int __fastcall sub_3A298(const char *a1, speed_t a2, __int16 a3)
{
  int v6; // r4
  int *v7; // r6
  int *v9; // r9
  int v10; // r10
  int *v11; // r5
  int v12; // r6
  int v13; // r0
  _BYTE buf[128]; // [sp+4h] [bp-84h] BYREF

  v6 = open64(a1, 2306, 511);
  if ( !v6 )
  {
    v6 = dup(0);
    v9 = _errno_location();
    v10 = *v9;
    close(0);
    *v9 = v10;
  }
  if ( v6 < 0 )
  {
    v11 = _errno_location();
    v12 = *v11;
    v6 = -1;
    sub_64E00(3, "refclock_open %s: %m", a1);
    *v11 = v12;
  }
  else if ( sub_3A0AC(v6, a2, a3) )
  {
    v7 = _errno_location();
    do
    {
      while ( read(v6, buf, 0x80u) > 0 )
        ;
    }
    while ( *v7 == 4 );
  }
  else
  {
    v13 = v6;
    v6 = -1;
    close(v13);
  }
  return v6;
}
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);

//----- (0003A3B4) --------------------------------------------------------
int __fastcall sub_3A3B4(__int64 a1, int a2)
{
  unsigned int v3; // r9
  int v4; // r8
  int v5; // r3
  int v6; // r2
  char v7; // r1
  __int64 v8; // r0
  int v9; // r12
  double v10; // d7
  double v11; // d7
  char v12; // r1
  int v13; // r7
  int v14; // r1
  int v15; // lr
  int v16; // r2

  if ( *(_WORD *)a1 == 2 )
  {
    v3 = bswap32(*(_DWORD *)(a1 + 4));
    if ( HIWORD(v3) << 16 == 2139029504 )
    {
      v4 = HIDWORD(a1);
      LODWORD(a1) = sub_31A44((unsigned __int16 *)a1, 0, 0, -1, 0, 0);
      v5 = a1;
      if ( (_DWORD)a1 )
      {
        v6 = *(_DWORD *)(a1 + 84);
        if ( !v6 )
          sub_6ECC0("ntp_refclock.c", 1052, 2, "peer->procptr != ((void *)0)");
        if ( v4 )
        {
          v7 = *(_BYTE *)(v4 + 2);
          if ( (v7 & 1) != 0 )
            *(_QWORD *)(v6 + 744) = *(_QWORD *)(v4 + 40);
          if ( (v7 & 2) != 0 )
            *(_QWORD *)(v6 + 752) = *(_QWORD *)(v4 + 48);
          if ( (v7 & 4) != 0 )
          {
            LODWORD(a1) = *(unsigned __int8 *)(v4 + 56);
            *(_BYTE *)(v6 + 760) = a1;
            *(_BYTE *)(v5 + 93) = a1;
          }
          if ( (v7 & 8) != 0 )
          {
            LODWORD(a1) = *(_DWORD *)(v4 + 60);
            *(_DWORD *)(v6 + 764) = a1;
            *(_DWORD *)(v5 + 112) = a1;
          }
          if ( (v7 & 0x10) != 0 )
          {
            LODWORD(a1) = *(_BYTE *)(v6 + 768) & 0xFE | *(_BYTE *)(v4 + 1) & 1;
            *(_BYTE *)(v6 + 768) = a1;
          }
          if ( (v7 & 0x20) != 0 )
          {
            LODWORD(a1) = *(_BYTE *)(v6 + 768) & 0xFD | *(_BYTE *)(v4 + 1) & 2;
            *(_BYTE *)(v6 + 768) = a1;
          }
          if ( (v7 & 0x40) != 0 )
          {
            LODWORD(a1) = *(_BYTE *)(v6 + 768) & 0xFB | *(_BYTE *)(v4 + 1) & 4;
            *(_BYTE *)(v6 + 768) = a1;
          }
          if ( v7 < 0 )
          {
            LODWORD(a1) = *(_BYTE *)(v4 + 1) & 8;
            *(_BYTE *)(v6 + 768) = *(_BYTE *)(v6 + 768) & 0xF7 | a1;
          }
        }
        if ( a2 )
        {
          LODWORD(v8) = *(unsigned __int8 *)(v6 + 760);
          HIDWORD(v8) = *(_DWORD *)(v6 + 764);
          *(_BYTE *)(a2 + 2) = 12;
          v9 = v6 + 56;
          v10 = *(double *)(v6 + 744);
          *(_QWORD *)(a2 + 56) = v8;
          *(double *)(a2 + 40) = v10;
          if ( v10 != 0.0 )
            *(_BYTE *)(a2 + 2) = 13;
          v11 = *(double *)(v6 + 752);
          *(double *)(a2 + 48) = v11;
          if ( v11 != 0.0 )
            *(_BYTE *)(a2 + 2) |= 2u;
          v12 = *(_BYTE *)(v6 + 768);
          *(_BYTE *)(a2 + 1) = v12;
          if ( (v12 & 1) != 0 )
            *(_BYTE *)(a2 + 2) |= 0x10u;
          if ( (v12 & 2) != 0 )
            *(_BYTE *)(a2 + 2) |= 0x20u;
          if ( (v12 & 4) != 0 )
            *(_BYTE *)(a2 + 2) |= 0x40u;
          if ( (v12 & 8) != 0 )
            *(_BYTE *)(a2 + 2) = ~((unsigned int)~(*(unsigned __int8 *)(a2 + 2) << 25) >> 25);
          v13 = *(_DWORD *)(v6 + 772);
          v14 = current_time;
          v15 = *(_DWORD *)(v6 + 780);
          *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 776);
          LODWORD(a1) = *(_DWORD *)(v6 + 784);
          *(_DWORD *)(a2 + 28) = v14 - v13;
          HIDWORD(a1) = *(_DWORD *)(v6 + 788);
          *(_DWORD *)(a2 + 16) = v15;
          *(_QWORD *)(a2 + 20) = a1;
          *(_BYTE *)(a2 + 65) = *(_BYTE *)(v6 + 42);
          *(_BYTE *)(a2 + 64) = *(_BYTE *)(v6 + 41);
          *(_BYTE *)a2 = *(_BYTE *)(v6 + 43);
          HIDWORD(a1) = *(_DWORD *)(v6 + 44);
          v16 = *(_DWORD *)(v6 + 184);
          *(_DWORD *)(a2 + 8) = v9;
          *(_DWORD *)(a2 + 32) = HIDWORD(a1);
          *(_WORD *)(a2 + 4) = v16;
        }
        if ( *((_DWORD *)*(&refclock_conf + BYTE1(v3)) + 3) )
          LODWORD(a1) = (*((int (__fastcall **)(_DWORD, int, int, int))*(&refclock_conf + BYTE1(v3)) + 3))(
                          (unsigned __int8)v3,
                          v4,
                          a2,
                          v5);
      }
    }
  }
  return a1;
}
// B5398: using guessed type _UNKNOWN *refclock_conf;
// 108CA4: using guessed type int current_time;

//----- (0003A698) --------------------------------------------------------
int __fastcall sub_3A698(double a1)
{
  unsigned int v1; // r6
  unsigned int v2; // r8
  int v3; // r7
  int v4; // r11
  int v5; // r9
  int v6; // r2
  int v7; // r1
  int v8; // r2
  int v9; // r10
  __int64 v10; // r0
  int v11; // r10
  __int64 v12; // r0
  double *v13; // r9
  int v14; // r10
  double v15; // d0
  __int64 v16; // r0
  int (__fastcall *v17)(_DWORD, int, int); // r3

  v1 = (unsigned __int16)*(_WORD *)LODWORD(a1);
  if ( v1 == 2 )
  {
    v2 = bswap32(*(_DWORD *)(LODWORD(a1) + 4));
    if ( HIWORD(v2) << 16 == 2139029504 )
    {
      v3 = HIDWORD(a1);
      LODWORD(a1) = sub_31A44((unsigned __int16 *)LODWORD(a1), 0, 0, -1, 0, 0);
      v4 = LODWORD(a1);
      if ( LODWORD(a1) )
      {
        v5 = *(_DWORD *)(LODWORD(a1) + 84);
        if ( v5 )
        {
          *(_BYTE *)v3 = 8;
          v6 = *(_DWORD *)(v5 + 188);
          v7 = *(_DWORD *)(v5 + 192);
          *(_WORD *)(v3 + 2) = 63;
          *(_DWORD *)(v3 + 8) = v6;
          v8 = v5 + 232;
          *(_DWORD *)(v3 + 12) = v7;
          v9 = *(_DWORD *)(v5 + 196);
          *(_QWORD *)(v3 + 20) = *(_QWORD *)(v5 + 200);
          v10 = *(_QWORD *)(v5 + 212);
          *(_DWORD *)(v3 + 16) = v9;
          v11 = *(_DWORD *)(v5 + 208);
          *(_QWORD *)(v3 + 32) = v10;
          v12 = *(_QWORD *)(v5 + 224);
          *(_DWORD *)(v3 + 28) = v11;
          *(_DWORD *)(v3 + 4) = -4;
          *(_QWORD *)(v3 + 72) = v12;
          a1 = *(double *)(v5 + 232);
          *(double *)(v3 + 80) = a1;
          if ( *(unsigned __int8 *)(v3 + 1) > 2u )
          {
            v13 = (double *)(v5 + 264);
            v14 = v3;
            do
            {
              v15 = *v13++;
              LODWORD(a1) = 32;
              ldexp(a1, v8);
              if ( v15 >= 0.0 )
              {
                LODWORD(a1) = sub_8C010(v15);
              }
              else
              {
                LODWORD(v16) = sub_8C010(-v15);
                *(_QWORD *)&a1 = -v16;
              }
              *(_DWORD *)(v14 + 92) = LODWORD(a1);
              ++v1;
              *(_DWORD *)(v14 + 88) = HIDWORD(a1);
              v14 += 8;
            }
            while ( *(unsigned __int8 *)(v3 + 1) > v1 );
          }
          v17 = (int (__fastcall *)(_DWORD, int, int))*((_DWORD *)*(&refclock_conf + BYTE1(v2)) + 5);
          if ( v17 )
            LODWORD(a1) = v17((unsigned __int8)v2, v3, v4);
        }
      }
    }
  }
  return LODWORD(a1);
}
// 3A7C4: variable 'a1' is possibly undefined
// 3A7F0: variable 'v8' is possibly undefined
// 3A800: variable 'v16' is possibly undefined
// B5398: using guessed type _UNKNOWN *refclock_conf;

//----- (0003A860) --------------------------------------------------------
int *sub_3A860()
{
  authkeylookups = 0;
  authkeynotfound = 0;
  authencryptions = 0;
  authdecryptions = 0;
  authkeyuncached = 0;
  auth_timereset = current_time;
  return &current_time;
}
// 108C7C: using guessed type int auth_timereset;
// 108CA4: using guessed type int current_time;
// 108D00: using guessed type int authdecryptions;
// 108D18: using guessed type int authkeyuncached;
// 108D2C: using guessed type int authencryptions;
// 108D30: using guessed type int authkeynotfound;
// 108D64: using guessed type int authkeylookups;

//----- (0003A918) --------------------------------------------------------
void *sub_3A918()
{
  int v0; // r0
  int v1; // r5
  int v2; // r2
  int v3; // r0
  int v4; // r5
  void *result; // r0
  __int16 v6; // r12
  char v7; // r5

  v0 = dword_BC914;
  if ( dword_BC918 )
  {
    v6 = __rev16(dword_BC910);
    if ( dword_BC920 )
      v7 = (8 * dword_BC920) | 0xC7;
    else
      v7 = -41;
    word_BC928 = v6;
    byte_BC924 = v7;
    byte_BC925 = dword_BCB20 & 0x7F;
    sub_16A68((struct sockaddr *)dword_BCB28, dword_BCB24, -1, (unsigned int *)&byte_BC924, dword_BC914 + 8);
    v1 = dword_BC91C;
    ++numresppkts;
    _memcpy_chk(&dword_BC92C, &unk_BC71C, dword_BC91C, 500);
    v2 = 1;
    v0 = 0;
    dword_BC918 = 0;
    ++dword_BCB20;
  }
  else
  {
    v1 = dword_BC91C;
    v2 = dword_BC910 + 1;
  }
  v3 = v0 + v1;
  v4 = v3 + v1;
  dword_BC914 = v3;
  if ( v4 <= 500 )
    v3 += (int)&unk_BC71C;
  dword_BC910 = v2;
  if ( v4 <= 500 )
    return (void *)(v3 + 528);
  if ( dword_BCB20 == 127 )
    result = 0;
  else
    result = &unk_BC71C;
  if ( dword_BCB20 != 127 )
    dword_BC918 = 1;
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC920: using guessed type int dword_BC920;
// BC924: using guessed type char byte_BC924;
// BC925: using guessed type char byte_BC925;
// BC928: using guessed type __int16 word_BC928;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 108C78: using guessed type int numresppkts;

//----- (0003AA70) --------------------------------------------------------
int __fastcall sub_3AA70(_DWORD *a1, int a2)
{
  _DWORD *v4; // r3
  int v5; // r2
  int v6; // r2
  _DWORD *v7; // r0
  _DWORD *v8; // r1

  v4 = (_DWORD *)*a1;
  if ( *a1 && (v5 = v4[1]) != 0 )
  {
    v6 = v5 - 1;
  }
  else
  {
    v7 = sub_63BA4(0, 0x104u, 0, 0);
    v8 = (_DWORD *)*a1;
    v6 = 62;
    v4 = v7;
    v7[1] = 63;
    *v7 = v8;
    *a1 = v7;
  }
  v4[1] = v6;
  v4[v6 + 2] = a2;
  return 1;
}

//----- (0003AB18) --------------------------------------------------------
_DWORD *__fastcall sub_3AB18(_DWORD **a1, _DWORD *a2)
{
  _DWORD *result; // r0
  unsigned int v4; // r3
  unsigned int v5; // r2
  unsigned int v6; // r3
  int v7; // r2

  result = *a1;
  if ( result )
  {
    v4 = result[1];
    if ( v4 <= 0x3E )
    {
      v5 = v4 + 2;
      v6 = v4 + 1;
      v7 = result[v5];
      result[1] = v6;
      if ( v6 != 63 )
        result = (int *)((char *)&dword_0 + 1);
      *a2 = v7;
      if ( v6 == 63 )
      {
        *a1 = (_DWORD *)*result;
        free(result);
        return &dword_0 + 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0003ABB0) --------------------------------------------------------
void **__fastcall sub_3ABB0(void **result, int *a2)
{
  _DWORD *v2; // r4
  int v3; // r5
  _DWORD *v4; // r8
  int v6; // r12
  int v7; // r2
  int v8; // r3
  unsigned int v9; // r3
  unsigned int v10; // lr
  unsigned int v11; // r1
  unsigned int v12; // r12
  unsigned int v13; // r2
  unsigned int v14; // r0
  unsigned int v15; // r3
  unsigned int v16; // r1
  unsigned int v17; // r3
  int v18; // r1
  int v19; // r3
  unsigned int v20; // r2
  int v21; // r1
  int v22; // r2
  int v23; // r3
  int v24; // r1
  int v25; // r2
  int v26; // r3
  int v27; // r1
  int v28; // r2
  int v29; // r3

  v2 = *result;
  if ( *result )
  {
    v3 = *a2;
    v4 = result;
    result = (void **)memset(*result, 0, 0x88u);
    if ( *(_WORD *)(v3 + 24) != 10 )
    {
      v6 = 0;
      v7 = *(_DWORD *)(v3 + 84);
      v8 = *(_DWORD *)(v3 + 56);
      *v2 = *(_DWORD *)(v3 + 28);
      v2[4] = v7;
      v2[8] = v8;
LABEL_4:
      v2[12] = v6;
      sub_6D4DC((_BYTE *)v2 + 52, (unsigned __int8 *)(v3 + 108), 32);
      v9 = bswap32(*(_DWORD *)(v3 + 144));
      v10 = *(_DWORD *)(v3 + 156);
      v11 = bswap32(*(_DWORD *)(v3 + 148));
      v12 = *(_DWORD *)(v3 + 168);
      v13 = bswap32(*(_DWORD *)(v3 + 164));
      *((_WORD *)v2 + 64) = __rev16(*(unsigned __int16 *)(v3 + 140));
      v14 = *(_DWORD *)(v3 + 172);
      v2[21] = v9;
      v15 = *(_DWORD *)(v3 + 176);
      v2[22] = v11;
      v16 = *(_DWORD *)(v3 + 20);
      v2[24] = v13;
      v17 = bswap32(v15);
      v2[23] = bswap32(v10);
      v2[30] = bswap32(v16);
      v2[25] = bswap32(v12);
      v2[26] = bswap32(v14);
      v2[29] = v17;
      v2[28] = v17;
      v18 = *(_DWORD *)(v3 + 160);
      v19 = current_time;
      *((_BYTE *)v2 + 130) = *(_DWORD *)(v3 + 180);
      v20 = bswap32(*(_DWORD *)(v3 + 188));
      v2[27] = bswap32(v19 - v18);
      v2[31] = v20;
      *((_BYTE *)v2 + 131) = *((_BYTE *)a2 + 4);
      result = (void **)sub_3A918();
      *v4 = result;
      return result;
    }
    if ( dword_BCB2C )
    {
      v21 = *(_DWORD *)(v3 + 36);
      v22 = *(_DWORD *)(v3 + 40);
      v23 = *(_DWORD *)(v3 + 44);
      *v2 = *(_DWORD *)(v3 + 32);
      v2[1] = v21;
      v2[2] = v22;
      v2[3] = v23;
      v24 = *(_DWORD *)(v3 + 92);
      v25 = *(_DWORD *)(v3 + 96);
      v26 = *(_DWORD *)(v3 + 100);
      v6 = 0x1000000;
      v2[4] = *(_DWORD *)(v3 + 88);
      v2[5] = v24;
      v2[6] = v25;
      v2[7] = v26;
      v27 = *(_DWORD *)(v3 + 64);
      v28 = *(_DWORD *)(v3 + 68);
      v29 = *(_DWORD *)(v3 + 72);
      v2[8] = *(_DWORD *)(v3 + 60);
      v2[9] = v27;
      v2[10] = v28;
      v2[11] = v29;
      goto LABEL_4;
    }
  }
  return result;
}
// BCB2C: using guessed type int dword_BCB2C;
// 108CA4: using guessed type int current_time;

//----- (0003AD58) --------------------------------------------------------
int __fastcall sub_3AD58(struct sockaddr *a1, int a2, char a3, char a4, int a5)
{
  __int16 v5; // r7
  char v6; // lr
  int v8; // [sp+Ch] [bp-4h]

  v5 = __rev16(a5 << 12);
  if ( dword_BC920 )
    v6 = (8 * dword_BC920) | 0x87;
  else
    v6 = -105;
  byte_BC924 = v6;
  byte_BC926 = a3;
  byte_BC927 = a4;
  word_BC928 = v5;
  byte_BC925 = 0;
  word_BC92A = 0;
  sub_16A68(a1, a2, -1, (unsigned int *)&byte_BC924, 8u);
  ++errorcounter[a5];
  return v8;
}
// 3ADE4: variable 'v8' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// BC920: using guessed type int dword_BC920;
// BC924: using guessed type char byte_BC924;
// BC925: using guessed type char byte_BC925;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC928: using guessed type __int16 word_BC928;
// BC92A: using guessed type __int16 word_BC92A;
// 108C58: using guessed type int errorcounter[];

//----- (0003AE24) --------------------------------------------------------
int __fastcall sub_3AE24(struct sockaddr *a1, int a2, int a3)
{
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 4);
}

//----- (0003AE7C) --------------------------------------------------------
int __fastcall sub_3AE7C(struct sockaddr *a1, int a2, int a3, unsigned int a4)
{
  unsigned int v8; // r4
  int *v9; // r10
  unsigned int v10; // r4
  int v11; // t1

  v8 = __rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF;
  if ( v8 )
  {
    v9 = (int *)(a3 + 8);
    v10 = v8 - 1;
    do
    {
      --v10;
      v11 = *v9++;
      sub_621BC(v11, a4);
    }
    while ( v10 != -1 );
  }
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 0);
}

//----- (0003AF24) --------------------------------------------------------
int __fastcall sub_3AF24(struct sockaddr *a1, int a2, int a3)
{
  return sub_3AE7C(a1, a2, a3, 0);
}

//----- (0003AF70) --------------------------------------------------------
int __fastcall sub_3AF70(struct sockaddr *a1, int a2, int a3)
{
  return sub_3AE7C(a1, a2, a3, 1u);
}

//----- (0003AFBC) --------------------------------------------------------
int __fastcall sub_3AFBC(struct sockaddr *a1, int a2, int a3)
{
  sub_427E8();
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 0);
}

//----- (0003B02C) --------------------------------------------------------
int sub_3B02C()
{
  __int16 v0; // r7
  char v1; // r8
  int result; // r0

  if ( !dword_BCB20 && !dword_BC910 )
    return sub_3AD58((struct sockaddr *)dword_BCB28, dword_BCB24, byte_BC926, byte_BC927, 4);
  v0 = __rev16(dword_BC910);
  if ( dword_BC920 )
    v1 = -121;
  else
    v1 = -105;
  if ( dword_BC920 )
    v1 |= 8 * (_BYTE)dword_BC920;
  byte_BC925 = dword_BCB20 & 0x7F;
  byte_BC924 = v1;
  word_BC928 = v0;
  result = sub_16A68((struct sockaddr *)dword_BCB28, dword_BCB24, -1, (unsigned int *)&byte_BC924, dword_BC914 + 8);
  ++numresppkts;
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC920: using guessed type int dword_BC920;
// BC924: using guessed type char byte_BC924;
// BC925: using guessed type char byte_BC925;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC928: using guessed type __int16 word_BC928;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 108C78: using guessed type int numresppkts;

//----- (0003B12C) --------------------------------------------------------
int __fastcall sub_3B12C(int a1, int a2, int a3)
{
  char v3; // lr
  char v4; // r0
  __int16 v5; // lr
  int v6; // r4
  int *v8; // [sp+0h] [bp-Ch] BYREF

  v3 = *(_BYTE *)(a3 + 2);
  dword_BCB28 = a1;
  v4 = *(_BYTE *)(a3 + 3);
  byte_BC926 = v3;
  if ( dword_BCB2C )
    v5 = -30720;
  else
    v5 = 12288;
  byte_BC927 = v4;
  word_BC92A = v5;
  v8 = &dword_BC92C;
  dword_BCB24 = a2;
  if ( dword_BCB2C )
    v6 = 136;
  else
    v6 = 48;
  dword_BC91C = v6;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  sub_18908((void (__fastcall *)(int, _DWORD **))sub_3ABB0, (int)&v8);
  return sub_3B02C();
}
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;

//----- (0003B1F0) --------------------------------------------------------
int __fastcall sub_3B1F0(int a1, int a2, int a3)
{
  char v3; // lr
  int v4; // r3
  char v5; // r1
  int v6; // r2
  __int16 v7; // r2
  int v8; // r4
  int *v9; // r12
  int v10; // r2
  char v11; // r3
  unsigned int v12; // r3
  bool v13; // zf
  int v14; // r1
  int v15; // r2
  int v16; // r3

  v3 = *(_BYTE *)(a3 + 2);
  v4 = dword_BCB2C;
  dword_BCB24 = a2;
  v5 = *(_BYTE *)(a3 + 3);
  dword_BCB28 = a1;
  if ( dword_BCB2C )
    v6 = 32;
  else
    v6 = 8;
  dword_BC91C = v6;
  if ( dword_BCB2C )
    v7 = 0x2000;
  else
    v7 = 2048;
  byte_BC927 = v5;
  word_BC92A = v7;
  byte_BC926 = v3;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  v8 = peer_list;
  if ( peer_list )
  {
    v9 = &dword_BC92C;
    while ( 1 )
    {
      if ( *(_WORD *)(v8 + 16) == 10 )
      {
        if ( !v4 )
          goto LABEL_20;
        v14 = *(_DWORD *)(v8 + 28);
        v15 = *(_DWORD *)(v8 + 32);
        v16 = *(_DWORD *)(v8 + 36);
        v9[4] = *(_DWORD *)(v8 + 24);
        v9[5] = v14;
        v9[6] = v15;
        v9[7] = v16;
        v9[2] = 1;
      }
      else
      {
        v10 = *(_DWORD *)(v8 + 20);
        if ( v4 )
          v9[2] = 0;
        *v9 = v10;
      }
      *((_WORD *)v9 + 2) = *(_WORD *)(v8 + 18);
      v11 = *(_BYTE *)(v8 + 63);
      *((_BYTE *)v9 + 7) = 0;
      *((_BYTE *)v9 + 6) = v11;
      if ( (*(_DWORD *)(v8 + 68) & 1) != 0 )
        *((_BYTE *)v9 + 7) = 1;
      if ( sys_peer == v8 )
        *((_BYTE *)v9 + 7) |= 2u;
      v12 = *(unsigned __int8 *)(v8 + 296);
      if ( v12 == 4 )
      {
        *((_BYTE *)v9 + 7) |= 0x40u;
      }
      else if ( v12 > 5 )
      {
        *((_BYTE *)v9 + 7) |= 0x80u;
      }
      v9 = (int *)sub_3A918();
LABEL_20:
      v8 = *(_DWORD *)v8;
      v13 = v8 == 0;
      if ( v8 )
        v13 = v9 == 0;
      if ( v13 )
        return sub_3B02C();
      v4 = dword_BCB2C;
    }
  }
  return sub_3B02C();
}
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;
// 108B8C: using guessed type int peer_list;
// 108C2C: using guessed type int sys_peer;

//----- (0003B390) --------------------------------------------------------
int __fastcall sub_3B390(int a1, int a2, int a3)
{
  char v3; // lr
  char v4; // r0
  __int16 v5; // lr
  int v6; // r4
  int *v8; // [sp+0h] [bp-Ch] BYREF

  v3 = *(_BYTE *)(a3 + 2);
  dword_BCB28 = a1;
  v4 = *(_BYTE *)(a3 + 3);
  byte_BC926 = v3;
  if ( dword_BCB2C )
    v5 = -30720;
  else
    v5 = 12288;
  byte_BC927 = v4;
  word_BC92A = v5;
  v8 = &dword_BC92C;
  dword_BCB24 = a2;
  if ( dword_BCB2C )
    v6 = 136;
  else
    v6 = 48;
  dword_BC91C = v6;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  sub_15D6C((int (__fastcall *)(int, _DWORD **))sub_3ABB0, (int)&v8);
  return sub_3B02C();
}
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;

//----- (0003B454) --------------------------------------------------------
int __fastcall sub_3B454(int a1, int a2, int a3)
{
  char v3; // r7
  char v4; // r6

  v3 = *(_BYTE *)(a3 + 2);
  dword_BCB28 = a1;
  dword_BC91C = 60;
  v4 = *(_BYTE *)(a3 + 3);
  dword_BCB24 = a2;
  byte_BC927 = v4;
  byte_BC926 = v3;
  word_BC92A = 15360;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  dword_BC92C = bswap32(current_time - ctltimereset);
  dword_BC930 = bswap32(numctlreq);
  dword_BC934 = bswap32(numctlbadpkts);
  dword_BC938 = bswap32(numctlresponses);
  dword_BC93C = bswap32(numctlfrags);
  dword_BC940 = bswap32(numctlerrors);
  dword_BC944 = bswap32(numctltooshort);
  dword_BC948 = bswap32(numctlinputresp);
  dword_BC94C = bswap32(numctlinputfrag);
  dword_BC950 = bswap32(numctlinputerr);
  dword_BC954 = bswap32(numctlbadoffset);
  dword_BC958 = bswap32(numctlbadversion);
  dword_BC95C = bswap32(numctldatatooshort);
  dword_BC960 = bswap32(numctlbadop);
  dword_BC964 = bswap32(numasyncmsgs);
  sub_3A918();
  return sub_3B02C();
}
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BC93C: using guessed type int dword_BC93C;
// BC940: using guessed type int dword_BC940;
// BC944: using guessed type int dword_BC944;
// BC948: using guessed type int dword_BC948;
// BC94C: using guessed type int dword_BC94C;
// BC950: using guessed type int dword_BC950;
// BC954: using guessed type int dword_BC954;
// BC958: using guessed type int dword_BC958;
// BC95C: using guessed type int dword_BC95C;
// BC960: using guessed type int dword_BC960;
// BC964: using guessed type int dword_BC964;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 108188: using guessed type int numctlbadpkts;
// 10818C: using guessed type int numctldatatooshort;
// 108190: using guessed type int numctlresponses;
// 108230: using guessed type int numctlinputresp;
// 108234: using guessed type int ctltimereset;
// 108238: using guessed type int numasyncmsgs;
// 10823C: using guessed type int numctlinputerr;
// 108240: using guessed type int numctlreq;
// 108244: using guessed type int numctlfrags;
// 108248: using guessed type int numctltooshort;
// 10824C: using guessed type int numctlbadversion;
// 108254: using guessed type int numctlbadoffset;
// 108258: using guessed type int numctlinputfrag;
// 10825C: using guessed type int numctlbadop;
// 108264: using guessed type int numctlerrors;
// 108CA4: using guessed type int current_time;

//----- (0003B668) --------------------------------------------------------
int __fastcall sub_3B668(int a1, int a2, int a3)
{
  char v3; // lr
  char v4; // r6

  v3 = *(_BYTE *)(a3 + 3);
  dword_BC91C = 36;
  v4 = *(_BYTE *)(a3 + 2);
  dword_BCB28 = a1;
  dword_BCB24 = a2;
  byte_BC926 = v4;
  byte_BC927 = v3;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  word_BC92A = 9216;
  dword_BC930 = bswap32(authnumkeys);
  dword_BC934 = bswap32(authnumfreekeys);
  dword_BC938 = bswap32(authkeylookups);
  dword_BC93C = bswap32(authkeynotfound);
  dword_BC940 = bswap32(authencryptions);
  dword_BC944 = bswap32(authdecryptions);
  dword_BC94C = bswap32(authkeyuncached);
  dword_BC948 = bswap32(authkeyexpired);
  dword_BC92C = bswap32(current_time - auth_timereset);
  sub_3A918();
  return sub_3B02C();
}
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BC93C: using guessed type int dword_BC93C;
// BC940: using guessed type int dword_BC940;
// BC944: using guessed type int dword_BC944;
// BC948: using guessed type int dword_BC948;
// BC94C: using guessed type int dword_BC94C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 108C7C: using guessed type int auth_timereset;
// 108CA4: using guessed type int current_time;
// 108D00: using guessed type int authdecryptions;
// 108D14: using guessed type int authkeyexpired;
// 108D18: using guessed type int authkeyuncached;
// 108D24: using guessed type int authnumkeys;
// 108D28: using guessed type int authnumfreekeys;
// 108D2C: using guessed type int authencryptions;
// 108D30: using guessed type int authkeynotfound;
// 108D64: using guessed type int authkeylookups;

//----- (0003B7EC) --------------------------------------------------------
int __fastcall sub_3B7EC(int a1, int a2, int a3)
{
  char v3; // r7
  char v4; // r6

  v3 = *(_BYTE *)(a3 + 2);
  dword_BCB28 = a1;
  dword_BC91C = 16;
  v4 = *(_BYTE *)(a3 + 3);
  dword_BCB24 = a2;
  byte_BC926 = v3;
  byte_BC927 = v4;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  word_BC92A = 4096;
  dword_BC92C = bswap32(current_time - timer_timereset);
  dword_BC930 = dword_BC92C;
  dword_BC934 = bswap32(alarm_overflow);
  dword_BC938 = bswap32(timer_xmtcalls);
  sub_3A918();
  return sub_3B02C();
}
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 108C90: using guessed type int alarm_overflow;
// 108CA4: using guessed type int current_time;
// 108CBC: using guessed type int timer_timereset;
// 108CC8: using guessed type int timer_xmtcalls;

//----- (0003B8E4) --------------------------------------------------------
int __fastcall sub_3B8E4(int a1, int a2, int a3)
{
  char v3; // r12
  char v4; // r6
  double v5; // d0
  int v6; // r1
  __int64 v7; // r6
  double v8; // d0
  double v9; // r0
  __int64 v10; // r0
  __int64 v12; // r0
  double v13; // d0
  __int64 v14; // r0

  v3 = *(_BYTE *)(a3 + 3);
  dword_BC91C = 24;
  v4 = *(_BYTE *)(a3 + 2);
  dword_BCB28 = a1;
  dword_BCB24 = a2;
  byte_BC926 = v4;
  byte_BC927 = v3;
  word_BC92A = 6144;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  v5 = last_offset;
  if ( last_offset < 0.0 )
  {
    v13 = -last_offset;
    ldexp(COERCE_DOUBLE(32), 1548);
    LODWORD(v14) = sub_8C010(v13);
    v7 = -v14;
  }
  else
  {
    ldexp(COERCE_DOUBLE(32), 1548);
    LODWORD(v7) = sub_8C010(v5);
    HIDWORD(v7) = v6;
  }
  HIDWORD(v9) = bswap32(HIDWORD(v7));
  dword_BC92C = HIDWORD(v9);
  dword_BC930 = bswap32(v7);
  v8 = drift_comp * 1000000.0;
  LODWORD(v9) = 32;
  if ( drift_comp * 1000000.0 < 0.0 )
  {
    ldexp(v9, (int)&unk_BC71C);
    LODWORD(v12) = sub_8C010(-v8);
    v10 = -v12;
  }
  else
  {
    ldexp(v9, (int)&unk_BC71C);
    LODWORD(v10) = sub_8C010(v8);
  }
  dword_BC934 = bswap32(HIDWORD(v10));
  dword_BC938 = bswap32(v10);
  dword_BC93C = bswap32(tc_counter);
  dword_BC940 = bswap32(current_time - sys_epoch);
  sub_3A918();
  return sub_3B02C();
}
// 3B978: variable 'v6' is possibly undefined
// 3B9C8: variable 'v10' is possibly undefined
// 3BA4C: variable 'v12' is possibly undefined
// 3BA6C: variable 'v14' is possibly undefined
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BC93C: using guessed type int dword_BC93C;
// BC940: using guessed type int dword_BC940;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 1082C4: using guessed type int tc_counter;
// 1082C8: using guessed type double last_offset;
// 1082D8: using guessed type double drift_comp;
// 108C30: using guessed type int sys_epoch;
// 108CA4: using guessed type int current_time;

//----- (0003BAA8) --------------------------------------------------------
int __fastcall sub_3BAA8(int a1, int a2, int a3)
{
  char v3; // r1
  char v4; // r7
  char *v5; // r1
  int *v6; // r2
  char v7; // r3
  unsigned int v8; // t1

  dword_BCB24 = a2;
  dword_BC91C = 148;
  v3 = *(_BYTE *)(a3 + 3);
  v4 = *(_BYTE *)(a3 + 2);
  dword_BCB28 = a1;
  byte_BC927 = v3;
  v5 = (char *)&dword_BC93C + 3;
  byte_BC926 = v4;
  word_BC92A = -27648;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  dword_BC92C = bswap32(current_time - peer_timereset);
  LOWORD(dword_BC930) = __rev16(total_peer_structs);
  HIWORD(dword_BC930) = __rev16(peer_free_count);
  dword_BC934 = bswap32(findpeer_calls);
  dword_BC938 = bswap32(peer_allocations);
  dword_BC93C = bswap32(peer_demobilizations);
  v6 = &peer_demobilizations;
  do
  {
    v8 = v6[1];
    ++v6;
    v7 = v8;
    if ( v8 < 0xFF )
      v7 = -1;
    *++v5 = v7;
  }
  while ( v6 != &peer_hash_count[127] );
  sub_3A918();
  return sub_3B02C();
}
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BC93C: using guessed type int dword_BC93C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 10856C: using guessed type int peer_free_count;
// 108574: using guessed type int peer_timereset;
// 10857C: using guessed type int findpeer_calls;
// 108980: using guessed type int total_peer_structs;
// 108984: using guessed type int peer_allocations;
// 108988: using guessed type int peer_demobilizations;
// 10898C: using guessed type _DWORD peer_hash_count[128];
// 108CA4: using guessed type int current_time;

//----- (0003BC14) --------------------------------------------------------
int __fastcall sub_3BC14(int a1, int a2, int a3)
{
  char v3; // r0

  dword_BCB24 = a2;
  dword_BCB28 = a1;
  dword_BC91C = 40;
  v3 = *(_BYTE *)(a3 + 3);
  byte_BC926 = *(_BYTE *)(a3 + 2);
  word_BC92A = 10240;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  byte_BC927 = v3;
  dword_BC92C = bswap32(current_time - io_timereset);
  LOWORD(dword_BC930) = __rev16(sub_69E00());
  HIWORD(dword_BC930) = __rev16(sub_69D58());
  LOWORD(dword_BC934) = __rev16(sub_69DAC());
  HIWORD(dword_BC934) = __rev16(sub_69E54());
  dword_BC938 = bswap32(packets_dropped);
  dword_BC93C = bswap32(packets_ignored);
  dword_BC940 = bswap32(packets_received);
  dword_BC944 = bswap32(packets_sent);
  dword_BC948 = bswap32(packets_notsent);
  dword_BC94C = bswap32(handler_calls);
  dword_BC950 = bswap32(handler_pkts);
  sub_3A918();
  return sub_3B02C();
}
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BC93C: using guessed type int dword_BC93C;
// BC940: using guessed type int dword_BC940;
// BC944: using guessed type int dword_BC944;
// BC948: using guessed type int dword_BC948;
// BC94C: using guessed type int dword_BC94C;
// BC950: using guessed type int dword_BC950;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 107CFC: using guessed type int packets_received;
// 107D00: using guessed type int packets_ignored;
// 107D08: using guessed type int packets_sent;
// 107D18: using guessed type int handler_calls;
// 107D34: using guessed type int packets_notsent;
// 107D3C: using guessed type int handler_pkts;
// 107D40: using guessed type int packets_dropped;
// 107D44: using guessed type int io_timereset;
// 108CA4: using guessed type int current_time;

//----- (0003BDB0) --------------------------------------------------------
int __fastcall sub_3BDB0(int a1, int a2, int a3)
{
  char v3; // lr
  char v4; // r6

  v3 = *(_BYTE *)(a3 + 3);
  dword_BC91C = 52;
  v4 = *(_BYTE *)(a3 + 2);
  dword_BCB28 = a1;
  dword_BCB24 = a2;
  byte_BC926 = v4;
  byte_BC927 = v3;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  word_BC92A = 13312;
  dword_BC92C = bswap32(current_time);
  dword_BC930 = bswap32(current_time - sys_stattime);
  dword_BC934 = bswap32(sys_restricted);
  dword_BC938 = bswap32(sys_oldversion);
  dword_BC93C = bswap32(sys_newversion);
  dword_BC940 = bswap32(sys_declined);
  dword_BC944 = bswap32(sys_badlength);
  dword_BC948 = bswap32(sys_processed);
  dword_BC94C = bswap32(sys_badauth);
  dword_BC954 = bswap32(sys_limitrejected);
  dword_BC950 = bswap32(sys_received);
  dword_BC958 = bswap32(sys_lamport);
  dword_BC95C = bswap32(sys_tsrounding);
  sub_3A918();
  return sub_3B02C();
}
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BC93C: using guessed type int dword_BC93C;
// BC940: using guessed type int dword_BC940;
// BC944: using guessed type int dword_BC944;
// BC948: using guessed type int dword_BC948;
// BC94C: using guessed type int dword_BC94C;
// BC950: using guessed type int dword_BC950;
// BC954: using guessed type int dword_BC954;
// BC958: using guessed type int dword_BC958;
// BC95C: using guessed type int dword_BC95C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 108B98: using guessed type int sys_badauth;
// 108BB0: using guessed type int sys_newversion;
// 108BFC: using guessed type int sys_received;
// 108C00: using guessed type int sys_restricted;
// 108C10: using guessed type int sys_limitrejected;
// 108C18: using guessed type int sys_processed;
// 108C1C: using guessed type int sys_declined;
// 108C20: using guessed type int sys_stattime;
// 108C28: using guessed type int sys_badlength;
// 108C38: using guessed type int sys_oldversion;
// 108CA4: using guessed type int current_time;
// 108CE8: using guessed type int sys_lamport;
// 108CEC: using guessed type int sys_tsrounding;

//----- (0003BF84) --------------------------------------------------------
int __fastcall sub_3BF84(int a1, int a2, int a3)
{
  char v3; // r5
  char v4; // r1
  int v5; // r2
  __int16 v6; // r2
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v12; // r2

  v3 = *(_BYTE *)(a3 + 2);
  dword_BCB24 = a2;
  v4 = *(_BYTE *)(a3 + 3);
  if ( dword_BCB2C )
    v5 = 80;
  else
    v5 = 56;
  dword_BCB28 = a1;
  dword_BC91C = v5;
  if ( dword_BCB2C )
    v6 = 20480;
  else
    v6 = 14336;
  byte_BC927 = v4;
  word_BC92A = v6;
  byte_BC926 = v3;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  if ( sys_peer )
  {
    if ( *(_WORD *)(sys_peer + 16) == 2 )
    {
      v12 = *(_DWORD *)(sys_peer + 20);
      if ( dword_BCB2C )
        dword_BC964 = 0;
      dword_BC92C = v12;
    }
    else if ( dword_BCB2C )
    {
      v7 = *(_DWORD *)(sys_peer + 24);
      v8 = *(_DWORD *)(sys_peer + 28);
      v9 = *(_DWORD *)(sys_peer + 32);
      v10 = *(_DWORD *)(sys_peer + 36);
      dword_BC964 = 1;
      unk_BC96C = v7;
      unk_BC970 = v8;
      unk_BC974 = v9;
      unk_BC978 = v10;
    }
    LOBYTE(dword_BC930) = *(_BYTE *)(sys_peer + 63);
  }
  else
  {
    dword_BC92C = 0;
    if ( dword_BCB2C )
      dword_BC964 = 0;
    LOBYTE(dword_BC930) = 0;
  }
  BYTE1(dword_BC930) = sys_leap;
  BYTE2(dword_BC930) = sys_stratum;
  HIBYTE(dword_BC930) = sys_precision;
  dword_BC934 = bswap32((int)(sys_rootdelay * 65536.0));
  dword_BC938 = bswap32((unsigned int)(sys_rootdisp * 65536.0));
  dword_BC954 = bswap32((int)(sys_jitter * 65536.0));
  dword_BC960 = bswap32((unsigned int)(clock_stability * 1000000.0 * 65536.0));
  dword_BC93C = sys_refid;
  dword_BC940 = bswap32(sys_reftime);
  dword_BC944 = bswap32(dword_108C0C);
  dword_BC948 = (unsigned __int8)sys_poll;
  LOBYTE(dword_BC94C) = 0;
  if ( sys_authenticate )
    LOBYTE(dword_BC94C) = 2;
  if ( sys_bclient )
    LOBYTE(dword_BC94C) = dword_BC94C | 1;
  if ( cal_enable )
    LOBYTE(dword_BC94C) = dword_BC94C | 0x10;
  if ( kern_enable )
    LOBYTE(dword_BC94C) = dword_BC94C | 8;
  if ( mon_enabled )
    LOBYTE(dword_BC94C) = dword_BC94C | 0x40;
  if ( ntp_enable )
    LOBYTE(dword_BC94C) = dword_BC94C | 4;
  if ( hardpps_enable )
    LOBYTE(dword_BC94C) = dword_BC94C | 0x20;
  if ( stats_control )
    LOBYTE(dword_BC94C) = ~((unsigned int)~((unsigned __int8)dword_BC94C << 25) >> 25);
  dword_BC958 = 0;
  dword_BC950 = bswap32((int)(sys_bdelay * 65536.0));
  dword_BC95C = bswap32(dword_108BF4);
  sub_3A918();
  return sub_3B02C();
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B6AE8: using guessed type int kern_enable;
// B6AEC: using guessed type int ntp_enable;
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BC93C: using guessed type int dword_BC93C;
// BC940: using guessed type int dword_BC940;
// BC944: using guessed type int dword_BC944;
// BC948: using guessed type int dword_BC948;
// BC94C: using guessed type int dword_BC94C;
// BC950: using guessed type int dword_BC950;
// BC954: using guessed type int dword_BC954;
// BC958: using guessed type int dword_BC958;
// BC95C: using guessed type int dword_BC95C;
// BC960: using guessed type int dword_BC960;
// BC964: using guessed type int dword_BC964;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;
// 1082B0: using guessed type char sys_poll;
// 1082B4: using guessed type int hardpps_enable;
// 1082E8: using guessed type double clock_stability;
// 108358: using guessed type int mon_enabled;
// 108BA0: using guessed type double sys_jitter;
// 108BA8: using guessed type char sys_precision;
// 108BAC: using guessed type int sys_authenticate;
// 108BB8: using guessed type double sys_rootdisp;
// 108BC0: using guessed type char sys_leap;
// 108BC8: using guessed type double sys_rootdelay;
// 108BD0: using guessed type int sys_refid;
// 108BE8: using guessed type double sys_bdelay;
// 108BF4: using guessed type int dword_108BF4;
// 108C08: using guessed type int sys_reftime;
// 108C0C: using guessed type int dword_108C0C;
// 108C14: using guessed type char sys_stratum;
// 108C2C: using guessed type int sys_peer;
// 108C48: using guessed type int sys_bclient;
// 108C54: using guessed type int cal_enable;
// 108CD0: using guessed type int stats_control;

//----- (0003C3CC) --------------------------------------------------------
int __fastcall sub_3C3CC(int a1, int a2, int a3)
{
  char v3; // r12
  int v4; // r3
  char v5; // r1
  int v6; // r2
  __int16 v7; // r2
  double v8; // r0
  int v9; // r5
  int *v10; // r4
  int v11; // r3
  int v12; // r2
  int v13; // r2
  int v14; // r3
  unsigned int v15; // r3
  double v16; // d0
  double v17; // r0
  double v18; // d0
  double v19; // d8
  bool v20; // zf
  int *v21; // r12
  int v22; // r2
  int v23; // r3
  bool v24; // zf
  __int64 v25; // r0
  int v26; // r2

  v3 = *(_BYTE *)(a3 + 2);
  v4 = dword_BCB2C;
  dword_BCB24 = a2;
  v5 = *(_BYTE *)(a3 + 3);
  dword_BCB28 = a1;
  if ( dword_BCB2C )
    v6 = 72;
  else
    v6 = 32;
  dword_BC91C = v6;
  if ( dword_BCB2C )
    v7 = 18432;
  else
    v7 = 0x2000;
  byte_BC927 = v5;
  word_BC92A = v7;
  HIDWORD(v8) = _stack_chk_guard;
  byte_BC926 = v3;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  v9 = peer_list;
  if ( peer_list )
  {
    v10 = &dword_BC92C;
    while ( 1 )
    {
      if ( *(_WORD *)(v9 + 16) == 10 )
      {
        if ( !v4 )
          goto LABEL_33;
        v21 = *(int **)(v9 + 56);
        v8 = *(double *)(v9 + 24);
        v22 = *(_DWORD *)(v9 + 32);
        v23 = *(_DWORD *)(v9 + 36);
        v24 = v21 == 0;
        *((double *)v10 + 7) = v8;
        v10[16] = v22;
        v10[17] = v23;
        if ( v21 )
        {
          v23 = (int)(v21 + 8);
          v21 = v10 + 10;
        }
        v10[8] = 1;
        if ( v24 )
        {
          v10[10] = (int)v21;
          v10[11] = (int)v21;
        }
        else
        {
          v8 = *(double *)v23;
          v22 = *(_DWORD *)(v23 + 8);
          v23 = *(_DWORD *)(v23 + 12);
        }
        if ( v24 )
        {
          v10[12] = (int)v21;
          v10[13] = (int)v21;
        }
        else
        {
          *(double *)v21 = v8;
          v21[2] = v22;
          v21[3] = v23;
        }
      }
      else
      {
        v20 = v4 == 0;
        v11 = *(_DWORD *)(v9 + 56);
        v12 = *(_DWORD *)(v9 + 20);
        if ( !v20 )
          v10[8] = 0;
        v10[1] = v12;
        if ( v11 )
        {
          if ( *(_DWORD *)(v9 + 748) )
          {
            if ( *(_BYTE *)(v9 + 72) == 4 || *(_BYTE *)(v9 + 72) && (v26 = *(_DWORD *)(v11 + 28), (*v10 = v26) == 0) )
              *v10 = *(_DWORD *)(v11 + 84);
          }
          else
          {
            *v10 = *(_DWORD *)(v11 + 28);
          }
        }
        else
        {
          *v10 = 0;
        }
      }
      *((_WORD *)v10 + 4) = *(_WORD *)(v9 + 18);
      *((_BYTE *)v10 + 10) = *(_BYTE *)(v9 + 93);
      *((_BYTE *)v10 + 11) = *(_BYTE *)(v9 + 64);
      *((_BYTE *)v10 + 12) = *(_BYTE *)(v9 + 94);
      v13 = *(unsigned __int8 *)(v9 + 298);
      *((_BYTE *)v10 + 14) = 0;
      *((_BYTE *)v10 + 13) = v13;
      if ( sys_peer == v9 )
        *((_BYTE *)v10 + 14) = 2;
      v14 = *(_DWORD *)(v9 + 68);
      if ( (v14 & 1) != 0 )
      {
        v13 = *((unsigned __int8 *)v10 + 14) | 1;
        *((_BYTE *)v10 + 14) = v13;
      }
      if ( (v14 & 8) != 0 )
      {
        v13 = *((unsigned __int8 *)v10 + 14) | 8;
        *((_BYTE *)v10 + 14) = v13;
      }
      if ( (v14 & 0x20) != 0 )
      {
        v13 = *((unsigned __int8 *)v10 + 14) | 0x10;
        *((_BYTE *)v10 + 14) = v13;
      }
      if ( (v14 & 0x40) != 0 )
        *((_BYTE *)v10 + 14) |= 4u;
      v15 = *(unsigned __int8 *)(v9 + 296);
      if ( v15 == 4 )
      {
        *((_BYTE *)v10 + 14) |= 0x40u;
      }
      else if ( v15 > 5 )
      {
        *((_BYTE *)v10 + 14) = ~((unsigned int)~(*((unsigned __int8 *)v10 + 14) << 25) >> 25);
      }
      *((_BYTE *)v10 + 15) = *(_BYTE *)(v9 + 63);
      v16 = *(double *)(v9 + 608);
      v10[4] = bswap32((int)(*(double *)(v9 + 616) * 65536.0));
      LODWORD(v8) = 32;
      ldexp(v8, v13);
      if ( v16 < 0.0 )
      {
        LODWORD(v25) = sub_8C010(-v16);
        *(_QWORD *)&v17 = -v25;
      }
      else
      {
        LODWORD(v17) = sub_8C010(v16);
      }
      v18 = *(double *)(v9 + 632);
      LODWORD(v17) = bswap32(LODWORD(v17));
      v10[5] = bswap32(HIDWORD(v17));
      v10[6] = LODWORD(v17);
      v19 = sqrt(v18);
      if ( v18 < 0.0 )
        sqrt(v17);
      v10[7] = bswap32((unsigned int)(v19 * 65536.0));
      v10 = (int *)sub_3A918();
LABEL_33:
      v9 = *(_DWORD *)v9;
      v20 = v9 == 0;
      if ( v9 )
        v20 = v10 == 0;
      if ( v20 )
        return sub_3B02C();
      v4 = dword_BCB2C;
    }
  }
  return sub_3B02C();
}
// 3C580: variable 'v8' is possibly undefined
// 3C590: variable 'v17' is possibly undefined
// 3C650: variable 'v25' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;
// 108B8C: using guessed type int peer_list;
// 108C2C: using guessed type int sys_peer;

//----- (0003C6E8) --------------------------------------------------------
int __fastcall sub_3C6E8(struct sockaddr *a1, int a2, int a3, int a4)
{
  char *v6; // r12
  int sa_family; // r0
  int v10; // r1
  __int16 v11; // r3
  int v12; // r2
  int v13; // r3
  bool v14; // zf
  char *v15; // lr
  bool v16; // zf
  int *v17; // r3
  __int16 v18; // r3
  int v19; // r0
  int v20; // r12
  char v22; // r3
  int v23; // r12
  struct sockaddr v24; // [sp+8h] [bp-24h] BYREF
  int v25; // [sp+18h] [bp-14h]
  int v26; // [sp+1Ch] [bp-10h]
  int v27; // [sp+20h] [bp-Ch]

  v6 = (char *)&GLOBAL_OFFSET_TABLE_;
  sa_family = a1->sa_family;
  v10 = 31488;
  v11 = __rev16(*(unsigned __int16 *)(a3 + 4));
  v12 = 0;
  v24.sa_family = sa_family;
  memset(&v24.sa_data[2], 0, 12);
  v25 = 0;
  v26 = 0;
  v27 = 0;
  *(_WORD *)v24.sa_data = 31488;
  if ( (v11 & 0xFFFu) > 1 )
  {
    sub_64E00(3, "do_setclr_trap: err_nitems > 1");
    v22 = *(_BYTE *)(a3 + 3);
    v23 = 3;
    return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), v22, v23);
  }
  v13 = *(_DWORD *)(a3 + 8);
  if ( !v13 )
  {
    v15 = (char *)any_interface;
    goto LABEL_11;
  }
  v14 = sa_family == 2;
  if ( sa_family == 2 )
  {
    *(_DWORD *)&v24.sa_data[2] = *(_DWORD *)(a3 + 8);
  }
  else
  {
    v6 = &v24.sa_data[6];
    sa_family = *(_DWORD *)(a3 + 24);
    v10 = *(_DWORD *)(a3 + 28);
    v12 = *(_DWORD *)(a3 + 32);
    v13 = *(_DWORD *)(a3 + 36);
  }
  if ( !v14 )
  {
    *(_DWORD *)v6 = sa_family;
    *((_DWORD *)v6 + 1) = v10;
    *((_DWORD *)v6 + 2) = v12;
    *((_DWORD *)v6 + 3) = v13;
  }
  v15 = sub_178F8(&v24);
  if ( !v15 )
  {
    v22 = *(_BYTE *)(a3 + 3);
    v23 = 4;
    return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), v22, v23);
  }
  sa_family = v24.sa_family;
LABEL_11:
  v16 = sa_family == 2;
  if ( sa_family == 2 )
    v17 = *(int **)(a3 + 12);
  else
    v17 = (int *)(a3 + 40);
  if ( sa_family == 2 )
  {
    *(_DWORD *)&v24.sa_data[2] = v17;
  }
  else
  {
    sa_family = *v17;
    v10 = v17[1];
    v12 = v17[2];
    v17 = (int *)v17[3];
    v6 = &v24.sa_data[6];
  }
  if ( !v16 )
  {
    *(_DWORD *)v6 = sa_family;
    *((_DWORD *)v6 + 1) = v10;
    *((_DWORD *)v6 + 2) = v12;
    *((_DWORD *)v6 + 3) = v17;
  }
  v18 = *(_WORD *)(a3 + 16);
  if ( !v18 )
    v18 = 3912;
  *(_WORD *)v24.sa_data = v18;
  if ( a4 )
    v19 = sub_23D98(&v24.sa_family, (int)v15, 0, (*(_BYTE *)a3 >> 3) & 7);
  else
    v19 = sub_240C0(&v24.sa_family, (int)v15, 0);
  if ( v19 )
    v20 = 0;
  else
    v20 = 4;
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), v20);
}
// 3C7AC: variable 'v6' is possibly undefined
// 3C7AC: variable 'v10' is possibly undefined
// 3C7AC: variable 'v12' is possibly undefined
// B5584: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;
// 107D4C: using guessed type int any_interface;

//----- (0003C894) --------------------------------------------------------
int __fastcall sub_3C894(struct sockaddr *a1, int a2, int a3)
{
  return sub_3C6E8(a1, a2, a3, 0);
}

//----- (0003C8E0) --------------------------------------------------------
int __fastcall sub_3C8E0(struct sockaddr *a1, int a2, int a3)
{
  return sub_3C6E8(a1, a2, a3, 1);
}

//----- (0003C92C) --------------------------------------------------------
int __fastcall sub_3C92C(struct sockaddr *a1, int a2, int a3)
{
  unsigned int v3; // r8
  bool v4; // zf
  unsigned int v5; // r7
  int v6; // r10
  int v7; // r9
  unsigned int v8; // r7
  int *i; // r11
  int v10; // r2
  int v11; // r12
  char v12; // r3
  int v17; // [sp+18h] [bp-3Ch] BYREF
  int v18; // [sp+1Ch] [bp-38h]
  int v19; // [sp+20h] [bp-34h]
  int v20; // [sp+24h] [bp-30h]
  int v21; // [sp+28h] [bp-2Ch]
  int v22; // [sp+2Ch] [bp-28h]
  int v23; // [sp+30h] [bp-24h] BYREF
  int v24; // [sp+34h] [bp-20h]
  int v25; // [sp+38h] [bp-1Ch]
  int v26; // [sp+3Ch] [bp-18h]
  int v27; // [sp+40h] [bp-14h]
  int v28; // [sp+44h] [bp-10h]
  int v29; // [sp+48h] [bp-Ch]

  v3 = __rev16(*(unsigned __int16 *)(a3 + 6)) & 0xFFF;
  if ( v3 > 0x18 )
    return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 3);
  v5 = __rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF;
  v4 = v5 == 0;
  LOWORD(v5) = v5 - 1;
  if ( !v4 )
  {
    v6 = a3 + 8;
    v7 = a3 + 8;
    do
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      _memcpy_chk(&v17, v7, v3, 24);
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      if ( dword_BCB2C && v18 )
      {
        LOWORD(v23) = 10;
        v25 = v19;
        v26 = v20;
        v27 = v21;
        v28 = v22;
      }
      else
      {
        LOWORD(v23) = 2;
        v24 = v17;
      }
      if ( !sub_31A44((unsigned __int16 *)&v23, 0, 0, -1, 0, 0) )
      {
        v10 = a3;
        v11 = 4;
        v12 = *(_BYTE *)(a3 + 3);
        return sub_3AD58(a1, a2, *(_BYTE *)(v10 + 2), v12, v11);
      }
      v5 = (unsigned __int16)(v5 - 1);
      v7 += v3;
    }
    while ( v5 != 0xFFFF );
    v8 = __rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF;
    v4 = v8 == 0;
    LOWORD(v8) = v8 - 1;
    if ( !v4 )
    {
      do
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v22 = 0;
        _memcpy_chk(&v17, v6, v3, 24);
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v28 = 0;
        v29 = 0;
        if ( dword_BCB2C && v18 )
        {
          LOWORD(v23) = 10;
          v25 = v19;
          v26 = v20;
          v27 = v21;
          v28 = v22;
        }
        else
        {
          LOWORD(v23) = 2;
          v24 = v17;
        }
        HIWORD(v23) = 31488;
        for ( i = (int *)sub_31A44((unsigned __int16 *)&v23, 0, 0, -1, 0, 0);
              i;
              i = (int *)sub_31A44((unsigned __int16 *)&v23, 0, i, -1, 0, 0) )
        {
          sub_32B18(i);
        }
        v8 = (unsigned __int16)(v8 - 1);
        v6 += v3;
      }
      while ( v8 != 0xFFFF );
    }
  }
  v10 = a3;
  v11 = 0;
  v12 = *(_BYTE *)(a3 + 3);
  return sub_3AD58(a1, a2, *(_BYTE *)(v10 + 2), v12, v11);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BCB2C: using guessed type int dword_BCB2C;

//----- (0003CC18) --------------------------------------------------------
int __fastcall sub_3CC18(struct sockaddr *a1, int a2, int a3, int a4)
{
  unsigned int v4; // r4
  int v5; // r8
  unsigned int v6; // r3
  int v7; // r6
  int v8; // r5
  int v9; // r7
  unsigned __int16 v10; // r1
  unsigned __int16 v11; // r3
  int v12; // r2
  int v13; // r2
  int v14; // r12
  char v15; // r3
  __int16 v17; // lr
  unsigned __int16 v18; // r7
  int v23; // [sp+28h] [bp-74h] BYREF
  int v24; // [sp+2Ch] [bp-70h]
  int v25; // [sp+30h] [bp-6Ch]
  int v26; // [sp+34h] [bp-68h]
  int v27; // [sp+38h] [bp-64h]
  int v28; // [sp+3Ch] [bp-60h]
  int v29; // [sp+40h] [bp-5Ch]
  int v30; // [sp+44h] [bp-58h] BYREF
  int v31; // [sp+48h] [bp-54h]
  int v32; // [sp+4Ch] [bp-50h]
  int v33; // [sp+50h] [bp-4Ch]
  int v34; // [sp+54h] [bp-48h]
  int v35; // [sp+58h] [bp-44h]
  int v36; // [sp+5Ch] [bp-40h]
  int v37; // [sp+60h] [bp-3Ch] BYREF
  int v38; // [sp+64h] [bp-38h]
  unsigned __int16 v39; // [sp+68h] [bp-34h]
  unsigned __int16 v40; // [sp+6Ah] [bp-32h]
  unsigned __int16 v41; // [sp+6Ch] [bp-30h]
  int v42; // [sp+70h] [bp-2Ch]
  int v43; // [sp+74h] [bp-28h]
  int v44; // [sp+78h] [bp-24h]
  int v45; // [sp+7Ch] [bp-20h]
  int v46; // [sp+80h] [bp-1Ch]
  int v47; // [sp+84h] [bp-18h]
  int v48; // [sp+88h] [bp-14h]
  int v49; // [sp+8Ch] [bp-10h]
  int v50; // [sp+90h] [bp-Ch]

  v4 = __rev16(*(unsigned __int16 *)(a3 + 6)) & 0xFFF;
  if ( v4 > 0x34 )
    return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 3);
  v5 = a3 + 8;
  v6 = __rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF;
  LOWORD(v7) = v6 - 1;
  if ( v6 )
  {
    LOWORD(v8) = v6 - 1;
    v9 = a3 + 8;
    while ( 1 )
    {
      _memcpy_chk(&v37, v9, v4, 52);
      v10 = __rev16(v41);
      v11 = __rev16(v40);
      v40 = v11;
      v12 = v10 & 0xDFFF;
      v41 = v10;
      if ( (v10 & 0xDFFF) != 0 )
        v12 = 1;
      if ( (v11 & 0x8000) != 0 )
        v12 |= 2u;
      if ( v38 )
      {
        if ( dword_BCB2C && v42 )
        {
          if ( !v43 && !v44 && !v45 && !v46 )
          {
            v12 |= 4u;
LABEL_18:
            sub_64E00(3, "do_restrict: bad = %#x", v12);
            v13 = a3;
            v14 = 3;
            v15 = *(_BYTE *)(a3 + 3);
            return sub_3AD58(a1, a2, *(_BYTE *)(v13 + 2), v15, v14);
          }
        }
        else if ( !v37 )
        {
          v12 |= 8u;
          goto LABEL_18;
        }
      }
      v8 = (unsigned __int16)(v8 - 1);
      v9 += v4;
      if ( v8 == 0xFFFF )
        break;
      if ( v12 )
        goto LABEL_18;
    }
    if ( v12 )
      goto LABEL_18;
    v23 = 0;
    v30 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    _memcpy_chk(&v37, v5, v4, 52);
    while ( 1 )
    {
      v17 = __rev16(v41);
      v40 = __rev16(v40);
      v41 = v17;
      v18 = __rev16(v39);
      v39 = v18;
      if ( dword_BCB2C && v42 )
      {
        LOWORD(v23) = 10;
        LOWORD(v30) = 10;
        v25 = v43;
        v26 = v44;
        v27 = v45;
        v28 = v46;
        v32 = v47;
        v33 = v48;
        v34 = v49;
        v35 = v50;
      }
      else
      {
        LOWORD(v23) = 2;
        LOWORD(v30) = 2;
        v24 = v37;
        v31 = v38;
      }
      v7 = (unsigned __int16)(v7 - 1);
      v5 += v4;
      sub_40238(a4, (unsigned __int16 *)&v23, &v30, v17, v18, v40, 0);
      if ( v7 == 0xFFFF )
        break;
      _memcpy_chk(&v37, v5, v4, 52);
    }
  }
  else
  {
    v23 = 0;
    v30 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
  }
  v13 = a3;
  v14 = 0;
  v15 = *(_BYTE *)(a3 + 3);
  return sub_3AD58(a1, a2, *(_BYTE *)(v13 + 2), v15, v14);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BCB2C: using guessed type int dword_BCB2C;

//----- (0003CF70) --------------------------------------------------------
int __fastcall sub_3CF70(struct sockaddr *a1, int a2, int a3)
{
  return sub_3CC18(a1, a2, a3, 3);
}

//----- (0003CFBC) --------------------------------------------------------
int __fastcall sub_3CFBC(struct sockaddr *a1, int a2, int a3)
{
  return sub_3CC18(a1, a2, a3, 2);
}

//----- (0003D008) --------------------------------------------------------
int __fastcall sub_3D008(struct sockaddr *a1, int a2, int a3)
{
  return sub_3CC18(a1, a2, a3, 1);
}

//----- (0003D054) --------------------------------------------------------
int __fastcall sub_3D054(struct sockaddr *a1, int a2, int a3)
{
  unsigned int v3; // r8
  int v4; // r10
  bool v5; // zf
  unsigned int v6; // r7
  int v7; // r9
  int *v8; // r2
  int v9; // r0
  int v10; // r10
  int v11; // r12
  char v12; // r3
  int i; // [sp+8h] [bp-5Ch]
  int v15; // [sp+Ch] [bp-58h]
  int v19; // [sp+24h] [bp-40h]
  int v20; // [sp+28h] [bp-3Ch] BYREF
  int v21; // [sp+2Ch] [bp-38h]
  int v22; // [sp+30h] [bp-34h]
  int v23; // [sp+34h] [bp-30h]
  int v24; // [sp+38h] [bp-2Ch]
  int v25; // [sp+3Ch] [bp-28h]
  int v26; // [sp+40h] [bp-24h] BYREF
  int v27; // [sp+44h] [bp-20h]
  int v28; // [sp+48h] [bp-1Ch]
  int v29; // [sp+4Ch] [bp-18h]
  int v30; // [sp+50h] [bp-14h]
  int v31; // [sp+54h] [bp-10h]
  int v32; // [sp+58h] [bp-Ch]

  v3 = __rev16(*(unsigned __int16 *)(a3 + 6)) & 0xFFF;
  if ( v3 > 0x18 )
    return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 3);
  v19 = a3 + 8;
  v4 = 0;
  for ( i = 0; ; i = 1 )
  {
    v6 = __rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF;
    v5 = v6 == 0;
    LOWORD(v6) = v6 - 1;
    if ( !v5 )
    {
      v7 = v19;
      while ( 2 )
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v25 = 0;
        _memcpy_chk(&v20, v7, v3, 24);
        v26 = 0;
        v27 = 0;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v31 = 0;
        v32 = 0;
        if ( dword_BCB2C && v21 )
        {
          LOWORD(v26) = 10;
          v28 = v22;
          v29 = v23;
          v30 = v24;
          v31 = v25;
        }
        else
        {
          LOWORD(v26) = 2;
          v27 = v20;
        }
        v8 = 0;
        HIWORD(v26) = 31488;
        while ( 1 )
        {
          v9 = sub_31A44((unsigned __int16 *)&v26, 0, v8, -1, 0, 0);
          v8 = (int *)v9;
          if ( !v9 )
            break;
          if ( (*(_DWORD *)(v9 + 68) & 1) != 0 )
          {
            if ( v4 )
            {
              v15 = v9;
              sub_36214(v9, (int *)"GONE");
              sub_31FC4(v15);
            }
            goto LABEL_12;
          }
        }
        if ( i != 1 )
        {
          v10 = a3;
          v11 = 4;
          v12 = *(_BYTE *)(a3 + 3);
          return sub_3AD58(a1, a2, *(_BYTE *)(v10 + 2), v12, v11);
        }
LABEL_12:
        v6 = (unsigned __int16)(v6 - 1);
        v7 += v3;
        if ( v6 != 0xFFFF )
          continue;
        break;
      }
    }
    v4 ^= 1u;
    if ( i == 1 )
      break;
  }
  v10 = a3;
  v11 = 0;
  v12 = *(_BYTE *)(a3 + 3);
  return sub_3AD58(a1, a2, *(_BYTE *)(v10 + 2), v12, v11);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BCB2C: using guessed type int dword_BCB2C;

//----- (0003D294) --------------------------------------------------------
int __fastcall sub_3D294(struct sockaddr *a1, int a2, int a3)
{
  unsigned int v4; // r5
  char v5; // r2
  unsigned int v6; // r5
  char v7; // r2
  unsigned int *v8; // r8
  unsigned int v9; // r9
  signed int v10; // r5
  int *v11; // r4
  double v12; // r0
  int v13; // r2
  int v14; // r1
  int v15; // r3
  int v16; // r3
  unsigned int *v17; // r0
  int *v18; // r3
  unsigned int v19; // t1
  int v20; // r2
  int v21; // r3
  int v22; // r3
  unsigned int *v23; // r9
  int *v24; // r3
  unsigned int v25; // r2
  int *v26; // r0
  bool v27; // cc
  unsigned int v28; // r3
  unsigned int v29; // t1
  int v33; // [sp+18h] [bp-16Ch] BYREF
  int v34; // [sp+1Ch] [bp-168h]
  int v35; // [sp+20h] [bp-164h]
  int v36; // [sp+24h] [bp-160h]
  int v37; // [sp+28h] [bp-15Ch]
  int v38; // [sp+2Ch] [bp-158h]
  int v39; // [sp+30h] [bp-154h]
  unsigned int s[82]; // [sp+34h] [bp-150h] BYREF

  v4 = *(unsigned __int16 *)(a3 + 4);
  dword_BCB28 = (int)a1;
  v5 = *(_BYTE *)(a3 + 2);
  v6 = __rev16(v4) & 0xFFF;
  dword_BC91C = 332;
  byte_BC926 = v5;
  v7 = *(_BYTE *)(a3 + 3);
  dword_BCB24 = a2;
  word_BC92A = 19457;
  byte_BC927 = v7;
  v33 = 2063597570;
  dword_BCB20 = 0;
  v34 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  if ( !v6 )
    return sub_3B02C();
  v8 = (unsigned int *)(a3 + 12);
  v9 = bswap32(*(_DWORD *)(a3 + 8));
  v34 = *(_DWORD *)(a3 + 8);
  if ( (v9 & 0xFFFF0000) == 0x7F7F0000 )
  {
    v10 = v6 - 1;
    v11 = &dword_BC92C;
    while ( sub_31A44((unsigned __int16 *)&v33, 0, 0, -1, 0, 0) )
    {
      memset(s, 0, sizeof(s));
      HIDWORD(v12) = s;
      LODWORD(v12) = &v33;
      sub_3A698(v12);
      if ( !LOWORD(s[0]) )
        break;
      v13 = HIWORD(s[0]);
      *v11 = v34;
      v14 = LOBYTE(s[0]);
      if ( LOBYTE(s[0]) >= 0x10u )
        v15 = 16;
      else
        v15 = LOBYTE(s[0]);
      *((_BYTE *)v11 + 4) = v15;
      *((_WORD *)v11 + 3) = __rev16(v13 & ~(-1 << v15));
      if ( v14 )
      {
        v16 = v15 + 1;
        v17 = &s[v16 + 1];
        v18 = &v11[v16 + 2];
        do
        {
          v19 = *--v17;
          *--v18 = bswap32(v19);
        }
        while ( v18 != v11 + 3 );
      }
      v20 = BYTE1(s[0]);
      if ( BYTE1(s[0]) >= 0x20u )
        v21 = 32;
      else
        v21 = BYTE1(s[0]);
      *((_BYTE *)v11 + 5) = v21;
      v11[2] = bswap32(s[1]);
      if ( v20 )
      {
        v22 = 2 * v21;
        v23 = &s[v22];
        v24 = &v11[v22];
        do
        {
          v25 = v23[16];
          v24 -= 2;
          v23 -= 2;
          v24[19] = bswap32(v25);
          v24[20] = bswap32(v23[19]);
        }
        while ( v11 != v24 );
      }
      v26 = (int *)sub_3A918();
      v27 = (int)v26 <= 0;
      if ( v26 )
        v27 = v10 <= 0;
      v11 = v26;
      if ( v27 )
        return sub_3B02C();
      v29 = *v8++;
      v28 = v29;
      v34 = v29;
      if ( (unsigned __int16)v33 == 2 )
      {
        --v10;
        if ( (bswap32(v28) & 0xFFFF0000) == 0x7F7F0000 )
          continue;
      }
      return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 4);
    }
  }
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 4);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;

//----- (0003D524) --------------------------------------------------------
int __fastcall sub_3D524(struct sockaddr *a1, int a2, int a3)
{
  unsigned int v5; // r4
  unsigned int v6; // r7
  unsigned int v7; // r4
  unsigned int v8; // r3
  __int64 v9; // r0
  unsigned int v10; // r2
  char v11; // r3
  int v12; // r12
  unsigned int v13; // r3
  unsigned int v14; // r3
  __int64 v15; // r0
  double v16; // r0
  double v17; // d0
  int v18; // r2
  __int64 v19; // r0
  double v20; // r0
  double v21; // d0
  int v22; // r2
  double v24; // r0
  double v25; // d0
  int v26; // r2
  double v27; // r0
  double v28; // d0
  int v29; // r2
  __int64 v30; // [sp+8h] [bp-7Ch]
  __int64 v31; // [sp+8h] [bp-7Ch]
  double s[9]; // [sp+18h] [bp-6Ch] BYREF
  int v34; // [sp+60h] [bp-24h] BYREF
  unsigned int v35; // [sp+64h] [bp-20h]
  int v36; // [sp+68h] [bp-1Ch]
  int v37; // [sp+6Ch] [bp-18h]
  int v38; // [sp+70h] [bp-14h]
  int v39; // [sp+74h] [bp-10h]
  int v40; // [sp+78h] [bp-Ch]

  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  memset(s, 0, sizeof(s));
  v5 = __rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF;
  if ( v5 )
  {
    v6 = bswap32(*(_DWORD *)(a3 + 8)) & 0xFFFF0000;
    v7 = v5 - 1;
    v35 = *(_DWORD *)(a3 + 8);
    v34 = 2063597570;
    if ( v6 == 2139029504 )
    {
      while ( 2 )
      {
        if ( sub_31A44((unsigned __int16 *)&v34, 0, 0, -1, 0, 0) )
        {
          switch ( bswap32(*(_DWORD *)(a3 + 12)) )
          {
            case 1u:
              LODWORD(v31) = 0;
              HIDWORD(v31) = bswap32(*(_DWORD *)(a3 + 16));
              v19 = v31 + bswap32(*(_DWORD *)(a3 + 20));
              if ( v31 < 0 )
              {
                LODWORD(v25) = sub_8BEC4(-v19);
                HIDWORD(v25) = HIDWORD(v24);
                LODWORD(v24) = -32;
                ldexp(v24, v26);
                v21 = -v25;
              }
              else
              {
                LODWORD(v21) = sub_8BEC4(v19);
                HIDWORD(v21) = HIDWORD(v20);
                LODWORD(v20) = -32;
                ldexp(v20, v22);
              }
              s[5] = v21;
              BYTE2(s[0]) = 1;
              goto LABEL_6;
            case 2u:
              LODWORD(v30) = 0;
              HIDWORD(v30) = bswap32(*(_DWORD *)(a3 + 16));
              v15 = v30 + bswap32(*(_DWORD *)(a3 + 20));
              if ( v30 < 0 )
              {
                LODWORD(v28) = sub_8BEC4(-v15);
                HIDWORD(v28) = HIDWORD(v27);
                LODWORD(v27) = -32;
                ldexp(v27, v29);
                v17 = -v28;
              }
              else
              {
                LODWORD(v17) = sub_8BEC4(v15);
                HIDWORD(v17) = HIDWORD(v16);
                LODWORD(v16) = -32;
                ldexp(v16, v18);
              }
              s[6] = v17;
              BYTE2(s[0]) = 2;
              goto LABEL_6;
            case 3u:
              v14 = *(_DWORD *)(a3 + 24);
              BYTE2(s[0]) = 4;
              LODWORD(s[7]) = bswap32(v14);
              goto LABEL_6;
            case 4u:
              v13 = *(_DWORD *)(a3 + 24);
              BYTE2(s[0]) = 8;
              HIDWORD(s[7]) = bswap32(v13);
              goto LABEL_6;
            case 5u:
              v8 = *(_DWORD *)(a3 + 24);
              BYTE2(s[0]) = -16;
              BYTE1(s[0]) = bswap32(v8) & 0xF;
LABEL_6:
              --v7;
              HIDWORD(v9) = s;
              LODWORD(v9) = &v34;
              sub_3A3B4(v9, 0);
              if ( v7 == -1 )
                goto LABEL_21;
              v10 = *(_DWORD *)(a3 + 8);
              v34 = 2063597570;
              v35 = v10;
              if ( (bswap32(v10) & 0xFFFF0000) != 0x7F7F0000 )
                break;
              continue;
            default:
              sub_64E00(3, "set_clock_fudge: default!");
              v11 = *(_BYTE *)(a3 + 3);
              v12 = 3;
              return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), v11, v12);
          }
        }
        break;
      }
    }
    v11 = *(_BYTE *)(a3 + 3);
    v12 = 4;
  }
  else
  {
LABEL_21:
    v11 = *(_BYTE *)(a3 + 3);
    v12 = 0;
  }
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), v11, v12);
}
// 3D6F0: variable 'v16' is possibly undefined
// 3D6F8: variable 'v18' is possibly undefined
// 3D740: variable 'v20' is possibly undefined
// 3D748: variable 'v22' is possibly undefined
// 3D7B0: variable 'v24' is possibly undefined
// 3D7B8: variable 'v26' is possibly undefined
// 3D7D0: variable 'v27' is possibly undefined
// 3D7D8: variable 'v29' is possibly undefined

//----- (0003D800) --------------------------------------------------------
int __fastcall sub_3D800(struct sockaddr *a1, int a2, int a3)
{
  unsigned int v4; // r6
  char v5; // r2
  unsigned int v6; // r6
  char v7; // r2
  unsigned int *v8; // r8
  unsigned int v9; // r9
  signed int v10; // r6
  int *v11; // r4
  double v12; // r0
  double v13; // r0
  int v14; // r2
  double v15; // d0
  __int64 v16; // r0
  unsigned int v17; // r3
  int v18; // r2
  int *v19; // r0
  bool v20; // cc
  unsigned int v21; // r3
  unsigned int v22; // t1
  char v23; // r3
  double v24; // d0
  bool v25; // nf
  unsigned __int64 v26; // r2
  __int64 v27; // r0
  __int64 v28; // r0
  __int64 v30; // [sp+8h] [bp-84h]
  _BYTE v33[12]; // [sp+20h] [bp-6Ch] BYREF
  unsigned int v34; // [sp+2Ch] [bp-60h]
  unsigned int v35; // [sp+30h] [bp-5Ch]
  unsigned int v36; // [sp+34h] [bp-58h]
  unsigned int v37; // [sp+38h] [bp-54h]
  unsigned int v38; // [sp+3Ch] [bp-50h]
  double v39; // [sp+48h] [bp-44h]
  double v40; // [sp+50h] [bp-3Ch]
  unsigned int v41; // [sp+58h] [bp-34h]
  int v42; // [sp+5Ch] [bp-30h]
  char v43; // [sp+60h] [bp-2Ch]
  char v44; // [sp+61h] [bp-2Bh]
  _WORD *v45; // [sp+64h] [bp-28h]
  int v46; // [sp+68h] [bp-24h] BYREF
  int v47; // [sp+6Ch] [bp-20h]
  int v48; // [sp+70h] [bp-1Ch]
  int v49; // [sp+74h] [bp-18h]
  int v50; // [sp+78h] [bp-14h]
  int v51; // [sp+7Ch] [bp-10h]
  int v52; // [sp+80h] [bp-Ch]

  v4 = *(unsigned __int16 *)(a3 + 4);
  dword_BCB28 = (int)a1;
  v5 = *(_BYTE *)(a3 + 2);
  v6 = __rev16(v4) & 0xFFF;
  dword_BC91C = 52;
  byte_BC926 = v5;
  v7 = *(_BYTE *)(a3 + 3);
  dword_BCB24 = a2;
  word_BC92A = 13312;
  byte_BC927 = v7;
  v46 = 2063597570;
  dword_BCB20 = 0;
  v47 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  if ( !v6 )
    return sub_3B02C();
  v8 = (unsigned int *)(a3 + 12);
  v9 = bswap32(*(_DWORD *)(a3 + 8));
  v47 = *(_DWORD *)(a3 + 8);
  if ( (v9 & 0xFFFF0000) == 0x7F7F0000 )
  {
    v10 = v6 - 1;
    v11 = &dword_BC92C;
    while ( sub_31A44((unsigned __int16 *)&v46, 0, 0, -1, 0, 0) )
    {
      v45 = 0;
      sub_3A3B4((unsigned int)&v46, (int)v33);
      *v11 = v47;
      v23 = v33[1];
      *((_BYTE *)v11 + 4) = v33[0];
      *((_BYTE *)v11 + 5) = v23;
      *((_BYTE *)v11 + 6) = v44;
      *((_BYTE *)v11 + 7) = v43;
      v24 = v39;
      v12 = COERCE_DOUBLE(_byteswap_uint64(__PAIR64__(v35, v36)));
      v25 = v39 < 0.0;
      v26 = _byteswap_uint64(__PAIR64__(v37, v38));
      v11[2] = bswap32(v34);
      *(double *)(v11 + 3) = v12;
      *(_QWORD *)(v11 + 5) = v26;
      LODWORD(v12) = 32;
      if ( v25 )
      {
        ldexp(v12, v26);
        LODWORD(v27) = sub_8C010(-v24);
        *(_QWORD *)&v13 = -v27;
      }
      else
      {
        ldexp(v12, v26);
        LODWORD(v13) = sub_8C010(v24);
      }
      v15 = v40;
      v11[7] = bswap32(HIDWORD(v13));
      v11[8] = bswap32(LODWORD(v13));
      LODWORD(v13) = 32;
      ldexp(v13, v14);
      if ( v15 < 0.0 )
      {
        LODWORD(v28) = sub_8C010(-v15);
        v30 = -v28;
      }
      else
      {
        LODWORD(v16) = sub_8C010(v15);
        v30 = v16;
      }
      v17 = bswap32(v41);
      v18 = v42;
      v11[9] = bswap32(HIDWORD(v30));
      v11[10] = bswap32(v30);
      v11[11] = v17;
      v11[12] = v18;
      sub_24DE4(v45);
      v19 = (int *)sub_3A918();
      v20 = (int)v19 <= 0;
      if ( v19 )
        v20 = v10 <= 0;
      v11 = v19;
      if ( v20 )
        return sub_3B02C();
      v22 = *v8++;
      v21 = v22;
      v47 = v22;
      if ( (unsigned __int16)v46 == 2 )
      {
        --v10;
        if ( (bswap32(v21) & 0xFFFF0000) == 0x7F7F0000 )
          continue;
      }
      return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 4);
    }
  }
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 4);
}
// 3D904: variable 'v13' is possibly undefined
// 3D924: variable 'v14' is possibly undefined
// 3D930: variable 'v16' is possibly undefined
// 3DA5C: variable 'v27' is possibly undefined
// 3DA80: variable 'v28' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;

//----- (0003DAD4) --------------------------------------------------------
int __fastcall sub_3DAD4(struct sockaddr *a1, int a2, int a3)
{
  unsigned int v4; // r7
  bool v5; // zf
  unsigned int v6; // r6
  int v7; // r8
  int v8; // r12
  unsigned int v9; // r2
  _BOOL4 v10; // r3
  char v11; // r3
  int v12; // r12
  int v16; // [sp+30h] [bp-CCh] BYREF
  unsigned int v17; // [sp+34h] [bp-C8h]
  unsigned int v18; // [sp+38h] [bp-C4h]
  unsigned int v19; // [sp+3Ch] [bp-C0h]
  unsigned int v20; // [sp+40h] [bp-BCh]
  unsigned int v21; // [sp+44h] [bp-B8h]
  int v22; // [sp+48h] [bp-B4h]
  unsigned int s[42]; // [sp+4Ch] [bp-B0h] BYREF

  v4 = __rev16(*(unsigned __int16 *)(a3 + 6)) & 0xFFF;
  if ( v4 > 0xA8 )
    return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 3);
  v6 = __rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF;
  v5 = v6 == 0;
  LOWORD(v6) = v6 - 1;
  if ( v5 )
  {
LABEL_26:
    v11 = *(_BYTE *)(a3 + 3);
    v12 = 0;
  }
  else
  {
    v7 = a3 + 8;
    while ( 1 )
    {
      memset(s, 0, sizeof(s));
      _memcpy_chk(s, v7, v4, 168);
      v16 = 0;
      v17 = 0;
      v18 = 0;
      if ( (s[2] & 2) != 0 )
        v8 = 32;
      else
        v8 = 0;
      v19 = 0;
      if ( (s[2] & 4) != 0 )
        v8 |= 0x40u;
      if ( (s[2] & 8) != 0 )
        v8 |= 0x100u;
      if ( (s[2] & 0x20) != 0 )
        v8 |= 0x800u;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      if ( dword_BCB2C && s[36] )
      {
        LOWORD(v16) = 10;
        v18 = s[38];
        v19 = s[39];
        v20 = s[40];
        v21 = s[41];
      }
      else
      {
        LOWORD(v16) = 2;
        v9 = bswap32(s[0]);
        v17 = s[0];
        if ( HIWORD(v9) << 16 != 2139029504 )
        {
          v10 = (v9 & 0xFF000000) == 2130706432;
          if ( v9 == 2130706433 )
            v10 = 0;
          if ( v10 )
          {
LABEL_23:
            v11 = *(_BYTE *)(a3 + 3);
            v12 = 3;
            return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), v11, v12);
          }
        }
      }
      HIWORD(v16) = 31488;
      if ( LOBYTE(s[1]) > 6u )
        goto LABEL_23;
      if ( !sub_32898(&v16, 0, 0, -1, s[1], SBYTE1(s[1]), BYTE2(s[1]), HIBYTE(s[1]), v8, BYTE1(s[2]), s[3], 0) )
        break;
      v6 = (unsigned __int16)(v6 - 1);
      v7 += v4;
      if ( v6 == 0xFFFF )
        goto LABEL_26;
    }
    v11 = *(_BYTE *)(a3 + 3);
    v12 = 4;
  }
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), v11, v12);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BCB2C: using guessed type int dword_BCB2C;

//----- (0003DD2C) --------------------------------------------------------
int __fastcall sub_3DD2C(struct sockaddr *a1, int a2, int a3)
{
  char v3; // r3
  unsigned int v4; // r7
  unsigned int v5; // r5
  int v6; // r6
  unsigned int v7; // r5
  int v8; // r12
  __int16 v9; // r2
  int *v10; // r4
  int v11; // r0
  int v12; // r12
  int *v13; // r3
  int *v14; // r3
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r2
  int v21; // r3
  unsigned int v22; // lr
  unsigned int v23; // r3
  __int16 v24; // r1
  int v25; // r2
  unsigned int v26; // r0
  int v27; // r1
  int v28; // r2
  int v29; // r10
  int v30; // r3
  unsigned int v31; // r11
  unsigned int v32; // r1
  unsigned int v33; // r2
  unsigned int v34; // lr
  unsigned int v35; // r3
  unsigned int v36; // r10
  unsigned int v37; // r1
  unsigned int v38; // r2
  unsigned int v39; // r12
  bool v40; // zf
  void *v41; // r0
  int v42; // r2
  int v43; // r3
  unsigned __int16 v45[2]; // [sp+10h] [bp-44h] BYREF
  int v46; // [sp+14h] [bp-40h]
  int v47; // [sp+18h] [bp-3Ch]
  int v48; // [sp+1Ch] [bp-38h]
  int v49; // [sp+20h] [bp-34h]
  int v50; // [sp+24h] [bp-30h]
  int v51; // [sp+28h] [bp-2Ch]
  _DWORD s[8]; // [sp+2Ch] [bp-28h] BYREF

  v3 = *(_BYTE *)(a3 + 3);
  v4 = __rev16(*(unsigned __int16 *)(a3 + 6)) & 0xFFF;
  if ( v4 > 0x20 )
    return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), v3, 3);
  v5 = *(unsigned __int16 *)(a3 + 4);
  v6 = a3 + 8;
  byte_BC926 = *(_BYTE *)(a3 + 2);
  v7 = __rev16(v5) & 0xFFF;
  byte_BC927 = v3;
  dword_BCB28 = (int)a1;
  if ( dword_BCB2C )
    v8 = 120;
  else
    v8 = 80;
  if ( dword_BCB2C )
    v9 = 30720;
  else
    v9 = 20480;
  dword_BCB24 = a2;
  v10 = &dword_BC92C;
  dword_BC91C = v8;
  word_BC92A = v9;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  while ( 1 )
  {
    v40 = v10 == 0;
    if ( v10 )
      v40 = v7 == 0;
    if ( v40 )
      break;
    v41 = memset(s, 0, sizeof(s));
    _memcpy_chk(v41, v6, v4, 32);
    v45[0] = 0;
    v46 = 0;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v45[1] = s[1];
    if ( dword_BCB2C && s[2] )
    {
      v45[0] = 10;
      v47 = s[4];
      v48 = s[5];
      v49 = s[6];
      v50 = s[7];
    }
    else
    {
      v45[0] = 2;
      v46 = s[0];
    }
    v6 += v4;
    v11 = sub_31A44(v45, 0, 0, -1, 0, 0);
    v12 = v11;
    if ( v11 )
    {
      v13 = *(int **)(v11 + 56);
      if ( *(_WORD *)(v11 + 16) == 2 )
      {
        v22 = *(_DWORD *)(v11 + 748);
        if ( v13 )
        {
          if ( v22 )
          {
            if ( *(_BYTE *)(v11 + 72) == 4 || *(_BYTE *)(v11 + 72) && (v42 = v13[7], (*v10 = v42) == 0) )
              *v10 = v13[21];
          }
          else
          {
            *v10 = v13[7];
          }
        }
        else
        {
          *v10 = 0;
        }
        v43 = dword_BCB2C;
        v10[1] = *(_DWORD *)(v11 + 20);
        if ( v43 )
          v10[20] = 0;
      }
      else
      {
        if ( v13 )
        {
          if ( *(_BYTE *)(v11 + 72) == 4 )
            v14 = v13 + 22;
          else
            v14 = v13 + 8;
          v15 = *v14;
          v16 = v14[1];
          v17 = v14[2];
          v18 = v14[3];
          v10[22] = v15;
          v10[23] = v16;
          v10[24] = v17;
          v10[25] = v18;
        }
        else
        {
          v10[22] = 0;
          v10[23] = 0;
          v10[24] = 0;
          v10[25] = 0;
        }
        v19 = *(_DWORD *)(v12 + 28);
        v20 = *(_DWORD *)(v12 + 32);
        v21 = *(_DWORD *)(v12 + 36);
        v22 = *(_DWORD *)(v12 + 748);
        v10[26] = *(_DWORD *)(v12 + 24);
        v10[27] = v19;
        v10[28] = v20;
        v10[29] = v21;
        v10[20] = 1;
      }
      v23 = 0;
      v24 = *(_WORD *)(v12 + 18);
      *((_WORD *)v10 + 5) = 0;
      *((_WORD *)v10 + 4) = v24;
      v25 = *(_DWORD *)(v12 + 68);
      if ( sys_peer == v12 )
      {
        *((_WORD *)v10 + 5) = 2;
        v23 = 2;
      }
      if ( (v25 & 1) != 0 )
      {
        v23 |= 1u;
        *((_WORD *)v10 + 5) = v23;
      }
      if ( (v25 & 8) != 0 )
      {
        v23 |= 8u;
        *((_WORD *)v10 + 5) = v23;
      }
      if ( (v25 & 0x20) != 0 )
      {
        v23 |= 0x10u;
        *((_WORD *)v10 + 5) = v23;
      }
      if ( (v25 & 0x40) != 0 )
      {
        v23 |= 4u;
        *((_WORD *)v10 + 5) = v23;
      }
      if ( (v25 & 0x100) != 0 )
      {
        v23 |= 0x100u;
        *((_WORD *)v10 + 5) = v23;
      }
      v26 = *(unsigned __int8 *)(v12 + 296);
      if ( v26 == 4 )
      {
        v23 |= 0x40u;
      }
      else if ( v26 > 5 )
      {
        v23 |= 0x80u;
      }
      *((_WORD *)v10 + 5) = __rev16(v23);
      v27 = *(_DWORD *)(v12 + 732);
      v28 = *(_DWORD *)(v12 + 720);
      v29 = *(_DWORD *)(v12 + 736);
      v30 = current_time;
      v31 = *(_DWORD *)(v12 + 740);
      v10[9] = bswap32(v22);
      v32 = bswap32(v30 - v27);
      v33 = bswap32(v28 - v30);
      v34 = *(_DWORD *)(v12 + 760);
      v35 = v30 - v29;
      v36 = *(_DWORD *)(v12 + 752);
      v10[4] = v32;
      v37 = *(_DWORD *)(v12 + 764);
      v10[5] = v33;
      v38 = *(_DWORD *)(v12 + 768);
      v39 = *(_DWORD *)(v12 + 772);
      v10[6] = bswap32(v35);
      v10[7] = bswap32(v31);
      v10[11] = bswap32(v36);
      v10[12] = bswap32(v34);
      v10[13] = bswap32(v37);
      v10[16] = bswap32(v38);
      v10[17] = bswap32(v39);
      *((_BYTE *)v10 + 76) = v26;
      v10 = (int *)sub_3A918();
    }
    v7 = (unsigned __int16)(v7 - 1);
  }
  return sub_3B02C();
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;
// 108C2C: using guessed type int sys_peer;
// 108CA4: using guessed type int current_time;

//----- (0003E104) --------------------------------------------------------
int __fastcall sub_3E104(struct sockaddr *a1, int a2, int a3)
{
  struct timex *v6; // r0
  char v7; // r0
  char v8; // r2
  unsigned int s[32]; // [sp+Ch] [bp-88h] BYREF

  if ( !pll_control )
    return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), *(_BYTE *)(a3 + 3), 4);
  v6 = (struct timex *)memset(s, 0, sizeof(s));
  if ( adjtimex(v6) < 0 )
    sub_64E00(3, "get_kernel_info: ntp_adjtime() failed: %m");
  v7 = *(_BYTE *)(a3 + 3);
  dword_BCB28 = (int)a1;
  v8 = *(_BYTE *)(a3 + 2);
  dword_BC91C = 60;
  byte_BC927 = v7;
  byte_BC926 = v8;
  dword_BC930 = bswap32(s[2]);
  dword_BC938 = bswap32(s[4]);
  dword_BC934 = bswap32(s[3]);
  dword_BC940 = bswap32(s[6]);
  dword_BC948 = bswap32(s[8]);
  dword_BC950 = bswap32(s[13]);
  dword_BC94C = bswap32(s[12]);
  word_BC92A = 15360;
  LOWORD(dword_BC93C) = __rev16(s[5]);
  dword_BCB24 = a2;
  dword_BC92C = bswap32(s[1]);
  dword_BC944 = bswap32(s[7]);
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  HIWORD(dword_BC93C) = __rev16(s[14]);
  dword_BC954 = bswap32(s[15]);
  dword_BC958 = bswap32(s[16]);
  dword_BC95C = bswap32(s[17]);
  dword_BC960 = bswap32(s[18]);
  dword_BC964 = bswap32(s[19]);
  sub_3A918();
  return sub_3B02C();
}
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BC930: using guessed type int dword_BC930;
// BC934: using guessed type int dword_BC934;
// BC938: using guessed type int dword_BC938;
// BC93C: using guessed type int dword_BC93C;
// BC940: using guessed type int dword_BC940;
// BC944: using guessed type int dword_BC944;
// BC948: using guessed type int dword_BC948;
// BC94C: using guessed type int dword_BC94C;
// BC950: using guessed type int dword_BC950;
// BC954: using guessed type int dword_BC954;
// BC958: using guessed type int dword_BC958;
// BC95C: using guessed type int dword_BC95C;
// BC960: using guessed type int dword_BC960;
// BC964: using guessed type int dword_BC964;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// 1082F4: using guessed type int pll_control;

//----- (0003E2D0) --------------------------------------------------------
int __fastcall sub_3E2D0(int *a1, const char *a2, struct sockaddr *a3, int a4, int a5)
{
  int v9; // r10
  char v10; // r3
  int v11; // r12

  if ( (__rev16(*(unsigned __int16 *)(a5 + 4)) & 0xFFF) > 1 )
  {
    sub_64E00(3, "set_keyid_checked[%s]: err_nitems > 1", a2);
    v10 = *(_BYTE *)(a5 + 3);
    v11 = 3;
  }
  else
  {
    v9 = bswap32(*(_DWORD *)(a5 + 8));
    if ( (unsigned int)(v9 - 1) <= 0xFFFE && sub_61FD4(v9) )
    {
      *a1 = v9;
      v10 = *(_BYTE *)(a5 + 3);
      v11 = 0;
    }
    else
    {
      sub_64E00(3, "set_keyid_checked[%s]: invalid key id: %ld", a2, v9);
      v10 = *(_BYTE *)(a5 + 3);
      v11 = 4;
    }
  }
  return sub_3AD58(a3, a4, *(_BYTE *)(a5 + 2), v10, v11);
}

//----- (0003E3F0) --------------------------------------------------------
int __fastcall sub_3E3F0(struct sockaddr *a1, int a2, int a3)
{
  return sub_3E2D0(&ctl_auth_keyid, "control", a1, a2, a3);
}
// 108250: using guessed type int ctl_auth_keyid;

//----- (0003E460) --------------------------------------------------------
int __fastcall sub_3E460(struct sockaddr *a1, int a2, int a3)
{
  return sub_3E2D0(&info_auth_keyid, "request", a1, a2, a3);
}
// 108C84: using guessed type int info_auth_keyid;

//----- (0003E4D0) --------------------------------------------------------
int __fastcall sub_3E4D0(struct sockaddr *a1, int a2, int a3)
{
  char v3; // r7
  char v4; // r2
  unsigned int v5; // r5
  int v6; // r12
  __int16 v7; // lr
  int *v8; // r12
  _DWORD *v9; // r4
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r2
  int v17; // r0
  unsigned int v18; // r1
  int v19; // r3
  _BOOL4 v20; // r3
  unsigned int v21; // lr
  int v22; // r2
  int v23; // r1
  int v24; // r3

  v3 = *(_BYTE *)(a3 + 2);
  v4 = *(_BYTE *)(a3 + 3);
  if ( num_ctl_traps )
  {
    v5 = 0;
    dword_BCB24 = a2;
    byte_BC927 = v4;
    byte_BC926 = v3;
    if ( dword_BCB2C )
      v6 = 64;
    else
      v6 = 28;
    if ( dword_BCB2C )
      v7 = 0x4000;
    else
      v7 = 7168;
    dword_BC91C = v6;
    v8 = &dword_BC92C;
    dword_BCB28 = (int)a1;
    word_BC92A = v7;
    dword_BCB20 = 0;
    dword_BC910 = 0;
    dword_BC914 = 0;
    dword_BC918 = 0;
    v9 = &ctl_traps;
    while ( 1 )
    {
      v21 = *((unsigned __int8 *)v9 + 50);
      if ( (v21 & 1) == 0 )
        goto LABEL_12;
      v22 = dword_BCB2C;
      if ( *(_WORD *)v9 == 2 )
        break;
      if ( dword_BCB2C )
      {
        v10 = *(_DWORD *)(v9[7] + 36);
        v11 = *(_DWORD *)(v9[7] + 40);
        v12 = *(_DWORD *)(v9[7] + 44);
        v8[8] = *(_DWORD *)(v9[7] + 32);
        v8[9] = v10;
        v8[10] = v11;
        v8[11] = v12;
        v13 = v9[3];
        v14 = v9[4];
        v15 = v9[5];
        v8[12] = v9[2];
        v8[13] = v13;
        v8[14] = v14;
        v8[15] = v15;
        v8[7] = 1;
LABEL_11:
        v16 = v9[8];
        *((_WORD *)v8 + 4) = *((_WORD *)v9 + 1);
        v17 = v9[10];
        *((_WORD *)v8 + 5) = __rev16(*((unsigned __int16 *)v9 + 24));
        v18 = v9[11];
        v8[6] = bswap32(v21);
        v19 = current_time;
        v8[5] = bswap32(v18);
        *(_QWORD *)(v8 + 3) = _byteswap_uint64(__PAIR64__(v19 - v16, v19 - v17));
        v8 = (int *)sub_3A918();
      }
LABEL_12:
      ++v5;
      v9 += 13;
      v20 = v5 <= 2;
      if ( !v8 )
        v20 = 0;
      if ( !v20 )
        return sub_3B02C();
    }
    v23 = v9[7];
    if ( v23 == any_interface )
      v24 = 0;
    else
      v24 = *(_DWORD *)(v23 + 28);
    *v8 = v24;
    v8[1] = v9[1];
    if ( v22 )
      v8[7] = 0;
    goto LABEL_11;
  }
  return sub_3AD58(a1, a2, v3, v4, 4);
}
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;
// 107D4C: using guessed type int any_interface;
// 108260: using guessed type int num_ctl_traps;
// 108CA4: using guessed type int current_time;

//----- (0003E6FC) --------------------------------------------------------
int __fastcall sub_3E6FC(int a1, int a2, int a3)
{
  struct sockaddr *v4; // r6
  unsigned int v6; // r9
  unsigned int v7; // r2
  int *v8; // r4
  int v9; // r3
  int v10; // t1
  char v11; // r3
  int v12; // r12

  v4 = (struct sockaddr *)a1;
  if ( (__rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF) > 1 )
  {
    sub_64E00(3, "reset_stats: err_nitems > 1");
    v11 = *(_BYTE *)(a3 + 3);
    v12 = 3;
  }
  else
  {
    v6 = bswap32(*(_DWORD *)(a3 + 8));
    v7 = v6 & 0xFFFFFF80;
    if ( (v6 & 0xFFFFFF80) != 0 )
    {
      sub_64E00(3, "reset_stats: reset leaves %#lx", v7);
      v11 = *(_BYTE *)(a3 + 3);
      v12 = 3;
    }
    else
    {
      v8 = &reset_entries;
      v9 = reset_entries;
      if ( reset_entries )
      {
        do
        {
          if ( (v9 & v6) != 0 )
            a1 = ((int (__fastcall *)(int, int, unsigned int))v8[1])(a1, a2, v7);
          v10 = v8[2];
          v8 += 2;
          v9 = v10;
        }
        while ( v10 );
      }
      v11 = *(_BYTE *)(a3 + 3);
      v12 = 0;
    }
  }
  return sub_3AD58(v4, a2, *(_BYTE *)(a3 + 2), v11, v12);
}
// 3E76C: variable 'a2' is possibly undefined
// 3E76C: variable 'v7' is possibly undefined
// B6C48: using guessed type int reset_entries;

//----- (0003E800) --------------------------------------------------------
int __fastcall sub_3E800(struct sockaddr *a1, int a2, int a3, __int16 *a4)
{
  unsigned int v8; // r4
  char v9; // r3
  int v10; // r12

  if ( (__rev16(*(unsigned __int16 *)(a3 + 4)) & 0xFFF) > 1 )
  {
    sub_64E00(3, "setclr_flags: err_nitems > 1");
    v9 = *(_BYTE *)(a3 + 3);
    v10 = 3;
  }
  else
  {
    v8 = bswap32(*(_DWORD *)(a3 + 8));
    if ( (v8 & 0xFFFFFF00) != 0 )
    {
      sub_64E00(3, "setclr_flags: extra flags: %#x", v8 & 0xFFFFFF00);
      v9 = *(_BYTE *)(a3 + 3);
      v10 = 3;
    }
    else
    {
      if ( (v8 & 1) != 0 )
        sub_38810(1, a4, 0);
      if ( (v8 & 2) != 0 )
        sub_38810(12, a4, 0);
      if ( (v8 & 4) != 0 )
        sub_38810(8, a4, 0);
      if ( (v8 & 8) != 0 )
        sub_38810(9, a4, 0);
      if ( (v8 & 0x10) != 0 )
        sub_38810(10, a4, 0);
      if ( (v8 & 0x20) != 0 )
        sub_38810(11, a4, 0);
      if ( (v8 & 0x40) != 0 )
        sub_38810(3, a4, 0);
      if ( (v8 & 0x80) != 0 )
        sub_38810(13, a4, 0);
      v9 = *(_BYTE *)(a3 + 3);
      v10 = 0;
    }
  }
  return sub_3AD58(a1, a2, *(_BYTE *)(a3 + 2), v9, v10);
}

//----- (0003E9E0) --------------------------------------------------------
int __fastcall sub_3E9E0(struct sockaddr *a1, int a2, int a3)
{
  return sub_3E800(a1, a2, a3, 0);
}

//----- (0003EA2C) --------------------------------------------------------
int __fastcall sub_3EA2C(struct sockaddr *a1, int a2, int a3)
{
  return sub_3E800(a1, a2, a3, (__int16 *)((char *)&dword_0 + 1));
}
// 0: using guessed type int dword_0;

//----- (0003EA78) --------------------------------------------------------
int __fastcall sub_3EA78(struct sockaddr *a1, int a2, int a3)
{
  char v3; // lr
  int *v4; // r11
  __int16 v5; // r0
  int *v6; // r5
  __int16 v7; // r2
  int v8; // r3
  bool v9; // zf
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r0
  int v19; // r4
  int *v20; // r3
  int v21; // r2
  __int16 v22; // r2
  int v23; // r3
  unsigned int v24; // r3
  int *v25; // r9
  int *v26; // r6
  char *v27; // r8
  int v28; // r3
  int v29; // r2
  double v30; // d6
  double v31; // d7
  unsigned int v32; // r3
  double v33; // d7
  unsigned int v34; // lr
  int v35; // r7
  unsigned int v36; // r12
  unsigned int v37; // r0
  unsigned int v38; // r1
  unsigned int v39; // r2
  int v40; // r3
  unsigned int v41; // r0
  unsigned int v42; // r3
  int v43; // r2
  unsigned int v44; // r1
  unsigned int v45; // r3
  _DWORD *v46; // r5
  double v47; // r0
  char v48; // t1
  char v49; // r3
  int v50; // r1
  double v51; // r0
  double v52; // d0
  __int64 v53; // r0
  double v54; // d0
  double v55; // r0
  double v56; // d7
  double v57; // d0
  double v58; // d9
  double v59; // d0
  unsigned int v60; // s15
  double v61; // d9
  bool v62; // zf
  __int64 v63; // r0
  int *v64; // r3
  int v65; // r0
  int v66; // r1
  int v67; // r2
  int v68; // r3
  int v69; // r1
  int v70; // r2
  int v71; // r3
  int v72; // r2
  int v74; // [sp+8h] [bp-64h]
  int *v75; // [sp+10h] [bp-5Ch]
  int v77; // [sp+28h] [bp-44h] BYREF
  int v78; // [sp+2Ch] [bp-40h]
  int v79; // [sp+30h] [bp-3Ch]
  int v80; // [sp+34h] [bp-38h]
  int v81; // [sp+38h] [bp-34h]
  int v82; // [sp+3Ch] [bp-30h]
  int v83; // [sp+40h] [bp-2Ch]
  int v84; // [sp+44h] [bp-28h]
  int v85; // [sp+48h] [bp-24h]
  int v86; // [sp+4Ch] [bp-20h]
  int v87; // [sp+50h] [bp-1Ch]
  int v88; // [sp+54h] [bp-18h]
  int v89; // [sp+58h] [bp-14h]
  int v90; // [sp+5Ch] [bp-10h]
  int v91; // [sp+60h] [bp-Ch]

  v3 = *(_BYTE *)(a3 + 2);
  if ( (__rev16(*(unsigned __int16 *)(a3 + 6)) & 0xFFF) != 0x20 )
    return sub_3AD58(a1, a2, v3, *(_BYTE *)(a3 + 3), 3);
  v4 = (int *)(a3 + 8);
  v5 = __rev16(*(unsigned __int16 *)(a3 + 4));
  v6 = &dword_BC92C;
  byte_BC927 = *(_BYTE *)(a3 + 3);
  v74 = v5 & 0xFFF;
  if ( dword_BCB2C )
    v7 = 6145;
  else
    v7 = -4096;
  byte_BC926 = v3;
  dword_BCB28 = (int)a1;
  if ( dword_BCB2C )
    v8 = 280;
  else
    v8 = 240;
  dword_BCB24 = a2;
  dword_BC91C = v8;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  word_BC92A = v7;
  v9 = &dword_BC92C == 0;
  if ( &dword_BC92C )
    v9 = v74 == 0;
  if ( !v9 )
  {
    do
    {
      v10 = *v4;
      v11 = v4[1];
      v12 = v4[2];
      v13 = v4[3];
      v77 = 0;
      v84 = v10;
      v85 = v11;
      v86 = v12;
      v87 = v13;
      v14 = v4[4];
      v15 = v4[5];
      v16 = v4[6];
      v17 = v4[7];
      v78 = 0;
      v88 = v14;
      v89 = v15;
      v90 = v16;
      v91 = v17;
      HIWORD(v77) = v85;
      v79 = 0;
      v80 = 0;
      v81 = 0;
      v82 = 0;
      v83 = 0;
      if ( dword_BCB2C && v86 )
      {
        LOWORD(v77) = 10;
        v79 = v88;
        v80 = v89;
        v81 = v90;
        v82 = v91;
      }
      else
      {
        LOWORD(v77) = 2;
        v78 = v84;
      }
      v4 += 8;
      v18 = sub_31A44((unsigned __int16 *)&v77, 0, 0, -1, 0, 0);
      v19 = v18;
      if ( v18 )
      {
        v20 = *(int **)(v18 + 56);
        if ( a1->sa_family == 10 )
        {
          if ( v20 )
          {
            if ( *(_BYTE *)(v18 + 72) == 4 )
              v64 = v20 + 22;
            else
              v64 = v20 + 8;
            v65 = *v64;
            v66 = v64[1];
            v67 = v64[2];
            v68 = v64[3];
            v6[62] = v65;
            v6[63] = v66;
            v6[64] = v67;
            v6[65] = v68;
          }
          else
          {
            v6[62] = 0;
            v6[63] = 0;
            v6[64] = 0;
            v6[65] = 0;
          }
          v69 = *(_DWORD *)(v19 + 28);
          v70 = *(_DWORD *)(v19 + 32);
          v71 = *(_DWORD *)(v19 + 36);
          v6[66] = *(_DWORD *)(v19 + 24);
          v6[67] = v69;
          v6[68] = v70;
          v6[69] = v71;
          v6[60] = 1;
        }
        else
        {
          if ( v20 )
          {
            if ( *(_DWORD *)(v18 + 748) )
            {
              if ( *(_BYTE *)(v18 + 72) == 4 || *(_BYTE *)(v18 + 72) && (v72 = v20[7], (*v6 = v72) == 0) )
                *v6 = v20[21];
            }
            else
            {
              *v6 = v20[7];
            }
          }
          else
          {
            *v6 = 0;
          }
          v21 = dword_BCB2C;
          v6[1] = *(_DWORD *)(v18 + 20);
          if ( v21 )
            v6[60] = 0;
        }
        v22 = *(_WORD *)(v19 + 18);
        *((_BYTE *)v6 + 10) = 0;
        *((_WORD *)v6 + 4) = v22;
        if ( sys_peer == v19 )
          *((_BYTE *)v6 + 10) = 2;
        v23 = *(_DWORD *)(v19 + 68);
        if ( (v23 & 1) != 0 )
          *((_BYTE *)v6 + 10) |= 1u;
        if ( (v23 & 8) != 0 )
          *((_BYTE *)v6 + 10) |= 8u;
        if ( (v23 & 0x20) != 0 )
          *((_BYTE *)v6 + 10) |= 0x10u;
        if ( (v23 & 0x40) != 0 )
          *((_BYTE *)v6 + 10) |= 4u;
        v24 = *(unsigned __int8 *)(v19 + 296);
        if ( v24 == 4 )
        {
          *((_BYTE *)v6 + 10) |= 0x40u;
        }
        else if ( v24 > 5 )
        {
          *((_BYTE *)v6 + 10) = ~((unsigned int)~(*((unsigned __int8 *)v6 + 10) << 25) >> 25);
        }
        v25 = v6 + 45;
        v26 = v6;
        *((_BYTE *)v6 + 11) = *(_BYTE *)(v19 + 91);
        v27 = (char *)(v19 + 552);
        *((_BYTE *)v6 + 12) = *(_BYTE *)(v19 + 63);
        *((_BYTE *)v6 + 13) = *(_BYTE *)(v19 + 92);
        v6[7] = *(_DWORD *)(v19 + 124);
        *((_BYTE *)v6 + 14) = *(_BYTE *)(v19 + 93);
        *((_BYTE *)v6 + 15) = *(_BYTE *)(v19 + 94);
        *((_BYTE *)v6 + 16) = *(_BYTE *)(v19 + 64);
        *((_BYTE *)v6 + 17) = *(_BYTE *)(v19 + 95);
        *((_BYTE *)v6 + 18) = *(_BYTE *)(v19 + 62);
        *((_BYTE *)v6 + 20) = *(_BYTE *)(v19 + 298);
        *((_BYTE *)v6 + 21) = *(_DWORD *)(v19 + 708);
        v28 = *(_DWORD *)(v19 + 300);
        *((_BYTE *)v6 + 22) = v28;
        v29 = *(_DWORD *)(v19 + 76);
        v30 = *(double *)(v19 + 616);
        *((_WORD *)v6 + 12) = v28;
        *((_BYTE *)v6 + 23) = v29;
        v31 = *(double *)(v19 + 96) * 65536.0;
        *((_WORD *)v6 + 13) = __rev16(*(unsigned __int16 *)(v19 + 60));
        v6[59] = bswap32((int)(v30 * 65536.0));
        v32 = (unsigned int)v31;
        v33 = *(double *)(v19 + 104);
        v6[11] = bswap32(v32);
        v34 = bswap32(*(_DWORD *)(v19 + 116));
        v35 = *(_DWORD *)(v19 + 320) - 1;
        v36 = bswap32(*(_DWORD *)(v19 + 120));
        v37 = bswap32(*(_DWORD *)(v19 + 584));
        v38 = bswap32(*(_DWORD *)(v19 + 588));
        v75 = v6;
        v39 = bswap32(*(_DWORD *)(v19 + 560));
        v6[12] = bswap32((unsigned int)(v33 * 65536.0));
        v40 = *(_DWORD *)(v19 + 112);
        v6[15] = v37;
        v41 = *(_DWORD *)(v19 + 568);
        v6[9] = v40;
        v42 = *(_DWORD *)(v19 + 564);
        v6[16] = v38;
        v6[17] = v39;
        v43 = bswap32(v41);
        v44 = bswap32(v42);
        v45 = *(_DWORD *)(v19 + 572);
        v6[13] = v34;
        v6[14] = v36;
        v6[18] = v44;
        v6[19] = v43;
        v6[20] = bswap32(v45);
        v46 = v6 + 21;
        do
        {
          if ( v35 < 0 )
            v50 = 7;
          else
            v50 = v35;
          HIDWORD(v51) = v19 + 8 * v50;
          if ( v35 < 0 )
            v35 = 6;
          else
            --v35;
          *v46++ = bswap32((int)(*(double *)(HIDWORD(v51) + 328) * 65536.0));
          v52 = *(double *)(HIDWORD(v51) + 392);
          LODWORD(v51) = 32;
          ldexp(v51, v43);
          if ( v52 >= 0.0 )
          {
            LODWORD(v47) = sub_8C010(v52);
          }
          else
          {
            LODWORD(v53) = sub_8C010(-v52);
            *(_QWORD *)&v47 = -v53;
          }
          v26[29] = bswap32(HIDWORD(v47));
          v25 = (int *)((char *)v25 + 1);
          v26[30] = bswap32(LODWORD(v47));
          v26 += 2;
          v48 = *v27++;
          v49 = *(_DWORD *)(v19 + 320) - v48;
          HIDWORD(v47) = (unsigned __int8)(v49 + 7);
          if ( HIDWORD(v47) <= 7 )
            *((_BYTE *)v25 - 1) = BYTE4(v47);
          else
            --v49;
          if ( HIDWORD(v47) > 7 )
            *((_BYTE *)v25 - 1) = v49;
        }
        while ( (char *)(v19 + 560) != v27 );
        v54 = *(double *)(v19 + 608);
        LODWORD(v47) = 32;
        ldexp(v47, v43);
        if ( v54 < 0.0 )
        {
          LODWORD(v63) = sub_8C010(-v54);
          *(_QWORD *)&v55 = -v63;
        }
        else
        {
          LODWORD(v55) = sub_8C010(v54);
        }
        v56 = *(double *)(v19 + 616);
        v57 = *(double *)(v19 + 632);
        LODWORD(v55) = bswap32(LODWORD(v55));
        v75[49] = bswap32(HIDWORD(v55));
        v75[50] = LODWORD(v55);
        v58 = sqrt(v57);
        v75[47] = bswap32((int)(v56 * 65536.0));
        if ( v57 < 0.0 )
          v55 = sqrt(v55);
        v59 = *(double *)(v19 + 624);
        v60 = (unsigned int)(v58 * 65536.0);
        v61 = sqrt(v59);
        v75[48] = bswap32(v60);
        if ( v59 < 0.0 )
          sqrt(v55);
        v75[51] = bswap32((unsigned int)(v61 * 65536.0));
        v6 = (int *)sub_3A918();
      }
      v74 = (unsigned __int16)(v74 - 1);
      v62 = v6 == 0;
      if ( v6 )
        v62 = v74 == 0;
    }
    while ( !v62 );
  }
  return sub_3B02C();
}
// 3EE80: variable 'v47' is possibly undefined
// 3EF10: variable 'v43' is possibly undefined
// 3EF20: variable 'v53' is possibly undefined
// 3EF50: variable 'v55' is possibly undefined
// 3F03C: variable 'v63' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;
// 108C2C: using guessed type int sys_peer;

//----- (0003F100) --------------------------------------------------------
int __fastcall sub_3F100(int a1, int a2, int a3)
{
  int i; // r6
  char v4; // r1
  char v5; // lr
  int v6; // r2
  __int16 v7; // r2
  int v8; // r1
  int *v9; // r4
  int *v10; // r3
  unsigned int v11; // r0
  unsigned int v12; // r1
  unsigned int v13; // r2
  unsigned int v14; // r2
  unsigned int v15; // r3
  void **v16; // r0
  int v18; // r1
  int *v19; // r12
  int *v20; // r6
  int v21; // r1
  int v22; // r2
  int v23; // r3
  int v24; // r0
  int v25; // r1
  int v26; // r2
  int v27; // r3
  unsigned int v28; // r6
  unsigned int v29; // r9
  unsigned int v30; // r12
  void **j; // r0
  int *v32; // [sp+0h] [bp-14h] BYREF
  int *v33; // [sp+4h] [bp-10h] BYREF
  void *ptr; // [sp+8h] [bp-Ch] BYREF

  i = dword_BCB2C;
  dword_BCB24 = a2;
  v4 = *(_BYTE *)(a3 + 3);
  v5 = *(_BYTE *)(a3 + 2);
  if ( dword_BCB2C )
    v6 = 56;
  else
    v6 = 16;
  dword_BCB28 = a1;
  dword_BC91C = v6;
  if ( dword_BCB2C )
    v7 = 14336;
  else
    v7 = 4096;
  byte_BC927 = v4;
  word_BC92A = v7;
  byte_BC926 = v5;
  dword_BCB20 = 0;
  dword_BC910 = 0;
  dword_BC914 = 0;
  dword_BC918 = 0;
  ptr = 0;
  v8 = restrictlist4;
  v32 = (int *)restrictlist4;
  if ( restrictlist4 )
  {
    do
    {
      if ( !sub_3AA70(&ptr, v8) )
      {
        i = dword_BCB2C;
        goto LABEL_12;
      }
      v8 = *v32;
      v32 = (int *)*v32;
    }
    while ( v32 );
    i = dword_BCB2C;
  }
LABEL_12:
  v9 = &dword_BC92C;
  while ( 1 )
  {
    if ( !sub_3AB18((_DWORD **)&ptr, &v32) )
      goto LABEL_20;
    v10 = v32;
    v11 = v32[6];
    v12 = v32[1];
    v13 = bswap32(v32[5]);
    if ( i )
      v9[4] = 0;
    *v9 = v13;
    v14 = *((unsigned __int16 *)v10 + 4);
    v15 = *((unsigned __int16 *)v10 + 5);
    v9[1] = bswap32(v11);
    v9[2] = bswap32(v12);
    *((_WORD *)v9 + 6) = __rev16(v14);
    *((_WORD *)v9 + 7) = __rev16(v15);
    v9 = (int *)sub_3A918();
    if ( !v9 )
      break;
    i = dword_BCB2C;
  }
  v16 = (void **)ptr;
  for ( i = dword_BCB2C; ptr; v16 = (void **)ptr )
  {
    ptr = *v16;
    free(v16);
LABEL_20:
    ;
  }
  if ( i )
  {
    ptr = 0;
    v18 = restrictlist6;
    v33 = (int *)restrictlist6;
    if ( restrictlist6 )
    {
      do
      {
        if ( !sub_3AA70(&ptr, v18) )
          break;
        v18 = *v33;
        v33 = (int *)*v33;
      }
      while ( v33 );
      if ( !v9 )
        goto LABEL_34;
    }
    else if ( !v9 )
    {
      return sub_3B02C();
    }
    while ( sub_3AB18((_DWORD **)&ptr, &v33) )
    {
      v19 = v33;
      v20 = v33 + 9;
      v21 = v33[6];
      v22 = v33[7];
      v23 = v33[8];
      v9[6] = v33[5];
      v9[7] = v21;
      v9[8] = v22;
      v9[9] = v23;
      v24 = *v20;
      v25 = v20[1];
      v26 = v20[2];
      v27 = v20[3];
      v28 = bswap32(v19[1]);
      v29 = *((unsigned __int16 *)v19 + 4);
      v30 = *((unsigned __int16 *)v19 + 5);
      v9[10] = v24;
      v9[11] = v25;
      v9[12] = v26;
      v9[13] = v27;
      v9[4] = 1;
      v9[2] = v28;
      *((_WORD *)v9 + 6) = __rev16(v29);
      *((_WORD *)v9 + 7) = __rev16(v30);
      v9 = (int *)sub_3A918();
      if ( !v9 )
        goto LABEL_34;
    }
    for ( j = (void **)ptr; ptr; j = (void **)ptr )
    {
      ptr = *j;
      free(j);
LABEL_34:
      ;
    }
  }
  return sub_3B02C();
}
// 1BC: using guessed type int elf_hash_bucket[521];
// BC910: using guessed type int dword_BC910;
// BC914: using guessed type int dword_BC914;
// BC918: using guessed type int dword_BC918;
// BC91C: using guessed type int dword_BC91C;
// BC926: using guessed type char byte_BC926;
// BC927: using guessed type char byte_BC927;
// BC92A: using guessed type __int16 word_BC92A;
// BC92C: using guessed type int dword_BC92C;
// BCB20: using guessed type int dword_BCB20;
// BCB24: using guessed type int dword_BCB24;
// BCB28: using guessed type int dword_BCB28;
// BCB2C: using guessed type int dword_BCB2C;
// 108C88: using guessed type int restrictlist4;
// 108C8C: using guessed type int restrictlist6;

//----- (0003F3E4) --------------------------------------------------------
int *sub_3F3E4()
{
  numrequests = 0;
  numresppkts = 0;
  auth_timereset = 0;
  info_auth_keyid = 0;
  errorcounter = 0;
  dword_108C5C = 0;
  dword_108C60 = 0;
  dword_108C64 = 0;
  dword_108C68 = 0;
  dword_108C6C = 0;
  dword_108C70 = 0;
  dword_108C74 = 0;
  return &info_auth_keyid;
}
// 108C58: using guessed type int errorcounter;
// 108C5C: using guessed type int dword_108C5C;
// 108C60: using guessed type int dword_108C60;
// 108C64: using guessed type int dword_108C64;
// 108C68: using guessed type int dword_108C68;
// 108C6C: using guessed type int dword_108C6C;
// 108C70: using guessed type int dword_108C70;
// 108C74: using guessed type int dword_108C74;
// 108C78: using guessed type int numresppkts;
// 108C7C: using guessed type int auth_timereset;
// 108C80: using guessed type int numrequests;
// 108C84: using guessed type int info_auth_keyid;

//----- (0003F498) --------------------------------------------------------
int __fastcall sub_3F498(int a1)
{
  return *(_BYTE *)(a1 + 88) & 7;
}

//----- (0003F4E4) --------------------------------------------------------
int __fastcall sub_3F4E4(int result, int a2)
{
  unsigned int v2; // r2
  struct sockaddr *v3; // r6
  int v4; // r7
  const char *v5; // r0
  unsigned int v6; // r3
  char v7; // lr
  int v8; // r4
  int v9; // r8
  int v10; // r9
  unsigned int v11; // r2
  int v12; // r11
  int v13; // r10
  int v14; // r3
  int v15; // r12
  int v16; // r10
  __int16 *i; // r7
  bool v18; // zf
  int v19; // r10
  int v20; // r0
  unsigned int v21; // r9
  unsigned int v22; // r9
  int v23; // r7
  int v24; // r8
  char v25; // r3
  int v26; // r12
  unsigned int v27; // r1
  unsigned int v28; // lr
  signed int v29; // r12
  __int64 v30; // r0
  double v31; // r0
  double v32; // d0
  int v33; // r2
  int v34; // [sp+8h] [bp-1Ch]
  __int16 *v35; // [sp+Ch] [bp-18h]
  int v36; // [sp+10h] [bp-14h]
  int v37; // [sp+10h] [bp-14h]

  v2 = *(unsigned __int8 *)(result + 88);
  v3 = (struct sockaddr *)(result + 4);
  if ( v2 >> 7 )
  {
    v4 = 1;
    goto LABEL_5;
  }
  if ( (v2 & 0x40) != 0 )
  {
    v4 = 2;
    goto LABEL_5;
  }
  v6 = (v2 >> 3) & 7;
  if ( v6 > 4 )
  {
    v4 = 3;
  }
  else if ( v6 )
  {
    v7 = *(_BYTE *)(result + 89);
    v8 = result;
    if ( (v7 & 0x7F) != 0 )
    {
      v4 = 5;
    }
    else
    {
      result = (unsigned __int16)__rev16(*(unsigned __int16 *)(result + 92));
      if ( (unsigned __int16)result >> 12 )
      {
        v4 = 6;
      }
      else
      {
        LOWORD(v9) = __rev16(*(unsigned __int16 *)(v8 + 94));
        v10 = (unsigned __int16)v9;
        if ( !((unsigned __int16)v9 >> 12) )
        {
          v11 = *(_DWORD *)(v8 + 84);
          if ( (int)v11 <= 7 )
          {
            v4 = 8;
            goto LABEL_5;
          }
          v12 = *(unsigned __int8 *)(v8 + 90);
          v13 = *(_DWORD *)(v8 + 60);
          dword_BC920 = v6;
          v34 = v13;
          v14 = *(unsigned __int8 *)(v8 + 91);
          if ( !v12 )
            goto LABEL_17;
          if ( (unsigned int)(v12 - 2) > 1 )
          {
            v15 = 1;
            return sub_3AD58(v3, v34, v12, v14, v15);
          }
          if ( *(_BYTE *)(v8 + 91) )
          {
            v16 = 1;
            for ( i = (__int16 *)&unk_B44F0; ; v16 = i[6] )
            {
              i += 6;
              if ( v16 == -1 )
                break;
              if ( v16 == v14 )
              {
                v35 = i;
                v9 = (__int16)v9;
                v36 = i[2];
                if ( (__int16)v9 == v36 || i[3] == (__int16)v9 )
                  goto LABEL_37;
                goto LABEL_32;
              }
            }
LABEL_17:
            v15 = 2;
            return sub_3AD58(v3, v34, v12, v14, v15);
          }
          v9 = (__int16)v9;
          if ( (_WORD)v9 )
          {
            v36 = *(unsigned __int8 *)(v8 + 91);
            v35 = (__int16 *)&unk_B44F0;
LABEL_32:
            v18 = v9 == 16;
            if ( v9 == 16 )
              v18 = *(unsigned __int16 *)(v8 + 90) == 2563;
            if ( !v18 )
              goto LABEL_35;
            v9 = 16;
LABEL_37:
            if ( v36 && (unsigned int)(unsigned __int16)result * v9 > v11 - 8 )
              goto LABEL_35;
          }
          else
          {
            v35 = (__int16 *)&unk_B44F0;
          }
          dword_BCB2C = v12 == 3;
          v19 = v8 + 88;
          if ( !v35[1] || !sys_authenticate )
            return (*((int (__fastcall **)(struct sockaddr *, int, int))v35 + 2))(v3, v34, v8 + 88);
          v20 = (unsigned __int16)result * v10;
          if ( v20 + 36 <= v11 )
          {
            v21 = (v20 + 19) & 0xFFFFFFFC;
            if ( v21 + 24 < v11 )
              v22 = 20;
            else
              v22 = v11 - v21;
            v23 = v11 - v22;
            v37 = v11 - v22 - 8;
            v24 = v19 + v37;
            if ( (v7 & 0x80) == 0 || !info_auth_keyid || info_auth_keyid != bswap32(*(_DWORD *)(v24 + 8)) )
            {
              v15 = 7;
              return sub_3AD58(v3, v34, v12, v14, v15);
            }
            if ( v11 > 0xD8 )
            {
              sub_64E00(3, "process_private: bad pkt length %zu", v11);
              v25 = *(_BYTE *)(v8 + 91);
              v26 = 3;
              return sub_3AD58(v3, v34, *(_BYTE *)(v8 + 90), v25, v26);
            }
            if ( !a2 )
            {
              ++sys_restricted;
              return sub_3AD58(v3, v34, *(_BYTE *)(v8 + 90), v14, 7);
            }
            if ( !sub_6204C(info_auth_keyid) )
            {
              LOBYTE(v14) = *(_BYTE *)(v8 + 91);
              return sub_3AD58(v3, v34, *(_BYTE *)(v8 + 90), v14, 7);
            }
            v27 = *(_DWORD *)(v8 + 76);
            v28 = bswap32(*(_DWORD *)(v24 + 4));
            v29 = bswap32(*(_DWORD *)(v19 + v37)) - *(_DWORD *)(v8 + 72);
            if ( v28 < v27 )
              --v29;
            v30 = __PAIR64__(v29, 0) + v28 - v27;
            if ( v29 < 0 )
              v30 = -v30;
            LODWORD(v32) = sub_8BEC4(v30);
            HIDWORD(v32) = HIDWORD(v31);
            LODWORD(v31) = -32;
            ldexp(v31, v33);
            if ( v32 > 10.0 || !sub_62854(info_auth_keyid, v8 + 88, v23, v22) )
            {
              v25 = *(_BYTE *)(v8 + 91);
              v26 = 7;
              return sub_3AD58(v3, v34, *(_BYTE *)(v8 + 90), v25, v26);
            }
            return (*((int (__fastcall **)(struct sockaddr *, int, int))v35 + 2))(v3, v34, v8 + 88);
          }
LABEL_35:
          v15 = 3;
          return sub_3AD58(v3, v34, v12, v14, v15);
        }
        v4 = 7;
      }
    }
  }
  else
  {
    v4 = 4;
  }
LABEL_5:
  if ( (ntp_syslogmask & 2) != 0 && current_time >= (unsigned int)dword_BCB30 )
  {
    v5 = sub_6C2E8(&v3->sa_family);
    result = (int)sub_64E00(3, "process_private: drop test %d failed, pkt from %s", v4, v5);
    dword_BCB30 = current_time + 60;
  }
  return result;
}
// 3F90C: variable 'v31' is possibly undefined
// 3F914: variable 'v33' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// B7CD4: using guessed type int ntp_syslogmask;
// BC920: using guessed type int dword_BC920;
// BCB2C: using guessed type int dword_BCB2C;
// BCB30: using guessed type int dword_BCB30;
// 108BAC: using guessed type int sys_authenticate;
// 108C00: using guessed type int sys_restricted;
// 108C84: using guessed type int info_auth_keyid;
// 108CA4: using guessed type int current_time;

//----- (0003F994) --------------------------------------------------------
int __fastcall sub_3F994(int a1, int a2)
{
  unsigned int v3; // r12
  unsigned int cp; // [sp+1Ch] [bp-70h] BYREF
  unsigned int v6; // [sp+20h] [bp-6Ch] BYREF
  char buf[48]; // [sp+24h] [bp-68h] BYREF
  char v8[48]; // [sp+54h] [bp-38h] BYREF

  if ( a2 )
  {
    inet_ntop(10, (const void *)(a1 + 20), buf, 0x2Eu);
    inet_ntop(10, (const void *)(a1 + 36), v8, 0x2Eu);
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 24);
    cp = bswap32(*(_DWORD *)(a1 + 20));
    v6 = bswap32(v3);
    inet_ntop(2, &cp, buf, 0x2Eu);
    inet_ntop(2, &v6, v8, 0x2Eu);
  }
  return sub_64D28(
           "restrict node at %p: %s/%s count %d, rflags %05x, mflags %05x, ippeerlimit %d, expire %lu, next %p\n",
           (const void *)a1,
           buf,
           v8,
           *(_DWORD *)(a1 + 4),
           *(unsigned __int16 *)(a1 + 8),
           *(unsigned __int16 *)(a1 + 10),
           *(__int16 *)(a1 + 12),
           *(_DWORD *)(a1 + 16),
           *(const void **)a1);
}

//----- (0003FAA4) --------------------------------------------------------
int __fastcall sub_3FAA4(int *s, int a2)
{
  bool v3; // zf
  int *v4; // r2
  int *v5; // r0
  int *v6; // r3
  int *v7; // r3
  int v9; // [sp+4h] [bp-Ch]
  int v10; // [sp+Ch] [bp-4h]

  v3 = (s[2] & 0x40) == 0;
  --dword_BCB3C;
  if ( !v3 && !--dword_BCB40 )
  {
    v9 = a2;
    sub_30DFC(2u);
    a2 = v9;
  }
  if ( a2 )
    v4 = &restrictlist6;
  else
    v4 = &restrictlist4;
  v5 = (int *)*v4;
  if ( s == (int *)*v4 )
  {
    v6 = s;
  }
  else
  {
    if ( !v5 || (v6 = (int *)*v5) == 0 )
LABEL_21:
      sub_6ECC0("ntp_restrict.c", 306, 2, "unlinked == res");
    while ( v6 != s )
    {
      v5 = v6;
      if ( !*v6 )
        goto LABEL_21;
      v6 = (int *)*v6;
    }
    v4 = v5;
  }
  *v4 = *v6;
  if ( s != v6 )
    goto LABEL_21;
  if ( a2 )
  {
    memset(s, 0, 0x34u);
    v7 = &dword_BCB34;
  }
  else
  {
    *s = 0;
    s[1] = 0;
    s[2] = 0;
    v7 = &dword_BCB38;
    s[3] = 0;
    s[4] = 0;
    s[5] = 0;
    s[6] = 0;
  }
  *s = *v7;
  *v7 = (int)s;
  return v10;
}
// 3FB90: variable 'v10' is possibly undefined
// BCB34: using guessed type int dword_BCB34;
// BCB38: using guessed type int dword_BCB38;
// BCB3C: using guessed type int dword_BCB3C;
// BCB40: using guessed type int dword_BCB40;
// 108C88: using guessed type int restrictlist4;
// 108C8C: using guessed type int restrictlist6;

//----- (0003FC3C) --------------------------------------------------------
int __fastcall sub_3FC3C(int a1, int a2)
{
  int v2; // r4
  unsigned int v5; // r3
  int v6; // r5
  unsigned int v7; // r3

  v2 = restrictlist4;
  if ( !restrictlist4 )
    return 0;
  while ( 1 )
  {
    v5 = *(_DWORD *)(v2 + 16);
    v6 = *(_DWORD *)v2;
    if ( v5 && v5 <= current_time )
      sub_3FAA4((int *)v2, 0);
    if ( *(_DWORD *)(v2 + 20) == (*(_DWORD *)(v2 + 24) & a1) )
    {
      v7 = ((*(unsigned __int16 *)(v2 + 10) ^ 0x2000u) >> 13) & 1;
      if ( a2 == 123 )
        v7 = 1;
      if ( v7 )
        break;
    }
    v2 = v6;
    if ( !v6 )
      return 0;
  }
  return v2;
}
// 108C88: using guessed type int restrictlist4;
// 108CA4: using guessed type int current_time;

//----- (0003FD1C) --------------------------------------------------------
int __fastcall sub_3FD1C(int a1, int a2)
{
  int v2; // r5
  _DWORD *v3; // r11
  int v5; // r8
  int v6; // r4
  unsigned int v7; // r2
  int v8; // r1
  int v9; // r12
  char *v10; // r0
  char v11; // r2
  char v12; // t1
  char v13; // t1
  unsigned int v14; // r2
  char v16; // [sp+Bh] [bp-19h] BYREF
  _BYTE s1[16]; // [sp+Ch] [bp-18h] BYREF

  v2 = restrictlist6;
  if ( !restrictlist6 )
    return 0;
  v3 = *(_DWORD **)restrictlist6;
  if ( restrictlist6 == *(_DWORD *)restrictlist6 )
LABEL_18:
    sub_6ECC0("ntp_restrict.c", 381, 2, "next != res");
  v5 = a1 - 1;
  v6 = a1 + 15;
  while ( 1 )
  {
    v7 = *(_DWORD *)(v2 + 16);
    if ( v7 && v7 <= current_time )
      sub_3FAA4((int *)v2, 1);
    v8 = v5;
    v9 = v2 + 35;
    v10 = &v16;
    do
    {
      v12 = *(_BYTE *)++v8;
      v11 = v12;
      v13 = *(_BYTE *)++v9;
      *++v10 = v11 & v13;
    }
    while ( v8 != v6 );
    if ( !memcmp(s1, (const void *)(v2 + 20), 0x10u) )
    {
      v14 = ((*(unsigned __int16 *)(v2 + 10) ^ 0x2000u) >> 13) & 1;
      if ( a2 == 123 )
        v14 = 1;
      if ( v14 )
        return v2;
    }
    if ( !v3 )
      return 0;
    v2 = (int)v3;
    if ( v3 == (_DWORD *)*v3 )
      goto LABEL_18;
    v3 = (_DWORD *)*v3;
  }
}
// 108C8C: using guessed type int restrictlist6;
// 108CA4: using guessed type int current_time;

//----- (0003FFBC) --------------------------------------------------------
int sub_3FFBC()
{
  word_BCB50 = -1;
  word_BCB84 = -1;
  dword_BCB44 = restrictlist4;
  restrictlist4 = (int)&dword_BCB44;
  dword_BCB3C = 2;
  dword_BCB78 = restrictlist6;
  restrictlist6 = (int)&dword_BCB78;
  return _stack_chk_guard;
}
// BCB3C: using guessed type int dword_BCB3C;
// BCB44: using guessed type int dword_BCB44;
// BCB50: using guessed type __int16 word_BCB50;
// BCB78: using guessed type int dword_BCB78;
// BCB84: using guessed type __int16 word_BCB84;
// 108C88: using guessed type int restrictlist4;
// 108C8C: using guessed type int restrictlist6;

//----- (00040054) --------------------------------------------------------
unsigned int __fastcall sub_40054(unsigned int result, _WORD *a2)
{
  int v3; // r7
  unsigned __int16 *v4; // r6
  int v5; // r7
  __int16 v6; // r2
  int v7; // r3
  int v8; // r3
  __int16 v9; // r3
  int v10; // r2
  int v11; // r2
  __int16 v12; // r3

  if ( !a2 )
    sub_6ECC0("ntp_restrict.c", 511, 0, "((void *)0) != r4a");
  v3 = *(unsigned __int16 *)result;
  *a2 = 1;
  v4 = (unsigned __int16 *)result;
  a2[1] = 0;
  ++dword_BCBAC;
  if ( v3 != 2 )
  {
    if ( v3 != 10 )
      return result;
    goto LABEL_15;
  }
  result = bswap32(*(_DWORD *)(result + 4));
  if ( (result & 0xF0000000) == 0xE0000000 )
  {
    a2[1] = 2;
    return result;
  }
  result = sub_3FC3C(result, (unsigned __int16)__rev16(v4[1]));
  if ( !result )
    sub_6ECC0("ntp_restrict.c", 535, 2, "match != ((void *)0)");
  v5 = *v4;
  v6 = *(_WORD *)(result + 8);
  ++*(_DWORD *)(result + 4);
  if ( (int *)result == &dword_BCB44 )
    v7 = dword_BCBB0;
  else
    v7 = dword_BCBB4;
  v8 = v7 + 1;
  if ( (int *)result == &dword_BCB44 )
    dword_BCBB0 = v8;
  else
    dword_BCBB4 = v8;
  v9 = *(_WORD *)(result + 12);
  *a2 = v6;
  a2[1] = v9;
  if ( v5 == 10 )
  {
LABEL_15:
    if ( *((unsigned __int8 *)v4 + 8) != 255 )
    {
      result = sub_3FD1C((int)(v4 + 4), (unsigned __int16)__rev16(v4[1]));
      if ( !result )
        sub_6ECC0("ntp_restrict.c", 564, 2, "match != ((void *)0)");
      ++*(_DWORD *)(result + 4);
      if ( (int *)result == &dword_BCB78 )
        v10 = dword_BCBB0;
      else
        v10 = dword_BCBB4;
      v11 = v10 + 1;
      if ( (int *)result == &dword_BCB78 )
        dword_BCBB0 = v11;
      else
        dword_BCBB4 = v11;
      v12 = *(_WORD *)(result + 12);
      *a2 = *(_WORD *)(result + 8);
      a2[1] = v12;
    }
  }
  return result;
}
// BCB44: using guessed type int dword_BCB44;
// BCB78: using guessed type int dword_BCB78;
// BCBAC: using guessed type int dword_BCBAC;
// BCBB0: using guessed type int dword_BCBB0;
// BCBB4: using guessed type int dword_BCBB4;

//----- (00040238) --------------------------------------------------------
int __fastcall sub_40238(
        int result,
        unsigned __int16 *a2,
        _DWORD *a3,
        __int16 a4,
        unsigned __int16 a5,
        __int16 a6,
        int a7)
{
  unsigned int v9; // r7
  int v11; // r2
  char *v12; // lr
  int v13; // r1
  int v14; // r2
  int v15; // r3
  char *v16; // r9
  char *v17; // r12
  char v18; // t1
  size_t v19; // r9
  int *v20; // r4
  int v21; // r10
  unsigned int v22; // r2
  unsigned int v23; // r1
  __int16 v24; // r3
  int v25; // r2
  bool v26; // zf
  __int16 v27; // r3
  int v28; // r1
  int v29; // r2
  int v30; // r3
  int v31; // r1
  int v32; // r2
  int *v33; // r6
  int k; // r5
  int v35; // r3
  int *v36; // r5
  int *v37; // lr
  int v38; // r0
  int v39; // r1
  int v40; // r2
  int v41; // r3
  unsigned int v42; // r2
  unsigned int v43; // r3
  unsigned int v44; // r2
  unsigned int v45; // r3
  int *v46; // r0
  int v47; // r1
  int *i; // r2
  int *v49; // r0
  int v50; // r1
  int *j; // r2
  int v52; // [sp+8h] [bp-44h]
  _DWORD s[13]; // [sp+10h] [bp-3Ch] BYREF

  v9 = result;
  if ( !a2 )
  {
    if ( a3 )
      sub_6ECC0("ntp_restrict.c", 619, (int)a2, "((void *)0) == resmask");
    if ( result != 1 )
      sub_6ECC0("ntp_restrict.c", 620, 0, "RESTRICT_FLAGS == op");
    word_BCBB8 = a6;
    word_BCBBA = a5;
    word_BCBBC = a4;
    dword_BCBC0 = 1;
    return result;
  }
  memset(s, 0, sizeof(s));
  v11 = *a2;
  if ( v11 == 2 )
  {
    v22 = *((_DWORD *)a2 + 1);
    v23 = a3[1];
    v19 = 8;
    result = 1420;
    v52 = 0;
    LOWORD(s[3]) = a4;
    LOWORD(s[2]) = a6;
    HIWORD(s[2]) = a5;
    s[6] = bswap32(v23);
    s[5] = bswap32(v22) & s[6];
    s[4] = a7;
    v20 = (int *)restrictlist4;
  }
  else
  {
    if ( v11 != 10 )
      sub_6ECC0("ntp_restrict.c", 658, 0, "0");
    v12 = (char *)a2 + 7;
    result = a3[2];
    v13 = a3[3];
    v14 = a3[4];
    v15 = a3[5];
    v16 = (char *)a2 + 23;
    v17 = (char *)&s[4] + 3;
    s[9] = result;
    s[10] = v13;
    s[11] = v14;
    s[12] = v15;
    do
    {
      v18 = *++v12;
      v17[1] = v18 & v17[17];
      ++v17;
    }
    while ( v12 != v16 );
    LOWORD(s[3]) = a4;
    v19 = 32;
    v52 = 1;
    LOWORD(s[2]) = a6;
    HIWORD(s[2]) = a5;
    s[4] = a7;
    v20 = (int *)restrictlist6;
  }
  for ( ; v20; v20 = (int *)*v20 )
  {
    v21 = *((unsigned __int16 *)v20 + 5);
    if ( a5 == v21 )
    {
      result = memcmp(v20 + 5, &s[5], v19);
      if ( !result )
      {
        switch ( v9 )
        {
          case 1u:
            v24 = *((_WORD *)v20 + 4);
            if ( (a6 & 0x40) != 0 && (v24 & 0x40) == 0 )
            {
              v25 = dword_BCB40;
              if ( !dword_BCB40 )
              {
                result = sub_30CD4(2);
                v25 = dword_BCB40;
                v24 = *((_WORD *)v20 + 4);
              }
              dword_BCB40 = v25 + 1;
            }
            *((_WORD *)v20 + 4) = a6 | v24;
            goto LABEL_28;
          case 2u:
            v27 = *((_WORD *)v20 + 4);
            if ( (v27 & 0x40) != 0 && (a6 & 0x40) != 0 && !--dword_BCB40 )
            {
              result = sub_30DFC(2u);
              v27 = *((_WORD *)v20 + 4);
            }
            *((_WORD *)v20 + 4) = v27 & ~a6;
            return result;
          case 3u:
          case 4u:
            if ( v9 == 4 || (v21 & 0x1000) == 0 )
            {
              v26 = v20 == &dword_BCB44;
              if ( v20 != &dword_BCB44 )
                v26 = v20 == &dword_BCB78;
              if ( !v26 )
                return sub_3FAA4(v20, v52);
            }
            return result;
          default:
            goto LABEL_21;
        }
      }
    }
  }
  if ( v9 != 1 )
  {
    if ( !v9 || v9 > 4 )
LABEL_21:
      sub_6ECC0("ntp_restrict.c", 734, 2, "0");
    return result;
  }
  if ( v52 )
  {
    v20 = (int *)dword_BCB34;
    if ( dword_BCB34 )
    {
      dword_BCB34 = *(_DWORD *)dword_BCB34;
    }
    else
    {
      v46 = (int *)sub_63C68(0, 0x13u, 0x34u, 0);
      v47 = dword_BCB34;
      v20 = v46;
      for ( i = v46 + 234; ; i -= 13 )
      {
        *i = v47;
        v47 = (int)i;
        if ( v46 == i - 13 )
          break;
      }
      dword_BCB34 = (int)i;
    }
    v36 = s;
    v37 = v20;
    do
    {
      v37 += 4;
      v38 = *v36;
      v39 = v36[1];
      v40 = v36[2];
      v41 = v36[3];
      v36 += 4;
      *(v37 - 4) = v38;
      *(v37 - 3) = v39;
      *(v37 - 2) = v40;
      *(v37 - 1) = v41;
    }
    while ( v36 != &s[12] );
    result = *v36;
    *v37 = *v36;
    v33 = &restrictlist6;
  }
  else
  {
    v20 = (int *)dword_BCB38;
    if ( dword_BCB38 )
    {
      dword_BCB38 = *(_DWORD *)dword_BCB38;
    }
    else
    {
      v49 = (int *)sub_63C68(0, 0x24u, 0x1Cu, 0);
      v50 = dword_BCB38;
      v20 = v49;
      for ( j = v49 + 245; ; j -= 7 )
      {
        *j = v50;
        v50 = (int)j;
        if ( v49 == j - 7 )
          break;
      }
      dword_BCB38 = (int)j;
    }
    v28 = s[1];
    v29 = s[2];
    v30 = s[3];
    *v20 = s[0];
    v20[1] = v28;
    v20[2] = v29;
    result = s[4];
    v31 = s[5];
    v32 = s[6];
    v20[3] = v30;
    v20[4] = result;
    v20[5] = v31;
    v20[6] = v32;
    v33 = &restrictlist4;
  }
  for ( k = *v33; ; k = *(_DWORD *)k )
  {
    if ( !k )
    {
LABEL_48:
      *v20 = k;
      *v33 = (int)v20;
      goto LABEL_49;
    }
    if ( !v52 )
    {
      v42 = v20[5];
      v43 = *(_DWORD *)(k + 20);
      if ( v42 > v43 )
        goto LABEL_48;
      if ( v42 < v43 )
        goto LABEL_63;
      v44 = v20[6];
      v45 = *(_DWORD *)(k + 24);
      if ( v44 > v45 )
        goto LABEL_48;
      if ( v44 < v45 )
        goto LABEL_63;
LABEL_62:
      if ( *((unsigned __int16 *)v20 + 5) > (unsigned int)*(unsigned __int16 *)(k + 10) )
        goto LABEL_48;
      goto LABEL_63;
    }
    result = memcmp(v20 + 5, (const void *)(k + 20), 0x10u);
    if ( result > 0 )
      goto LABEL_48;
    if ( !result )
    {
      result = memcmp(v20 + 9, (const void *)(k + 36), 0x10u);
      if ( result > 0 )
        goto LABEL_48;
      if ( !result )
        goto LABEL_62;
    }
LABEL_63:
    v33 = (int *)k;
    if ( !*(_DWORD *)k )
      break;
  }
  *v20 = 0;
  *(_DWORD *)k = v20;
LABEL_49:
  ++dword_BCB3C;
  if ( (a6 & 0x40) != 0 )
  {
    v35 = dword_BCB40;
    if ( !dword_BCB40 )
    {
      result = sub_30CD4(2);
      v35 = dword_BCB40;
    }
    dword_BCB40 = v35 + 1;
  }
LABEL_28:
  *((_WORD *)v20 + 6) = s[3];
  return result;
}
// BCB34: using guessed type int dword_BCB34;
// BCB38: using guessed type int dword_BCB38;
// BCB3C: using guessed type int dword_BCB3C;
// BCB40: using guessed type int dword_BCB40;
// BCB44: using guessed type int dword_BCB44;
// BCB78: using guessed type int dword_BCB78;
// BCBB8: using guessed type __int16 word_BCBB8;
// BCBBA: using guessed type __int16 word_BCBBA;
// BCBBC: using guessed type __int16 word_BCBBC;
// BCBC0: using guessed type int dword_BCBC0;
// 108C88: using guessed type int restrictlist4;
// 108C8C: using guessed type int restrictlist6;

//----- (00040824) --------------------------------------------------------
unsigned int __fastcall sub_40824(unsigned __int16 *a1, int a2, int a3)
{
  unsigned int result; // r0
  int v6; // r7
  int v7; // r0
  int *v8; // r8
  unsigned int v9; // r3
  int v10; // r0
  unsigned __int64 v11; // [sp+10h] [bp-20h] BYREF
  _BYTE v12[18]; // [sp+18h] [bp-18h] BYREF
  __int16 v13; // [sp+2Ah] [bp-6h]

  result = (unsigned int)&dword_BCB34;
  if ( !dword_BCBC0 )
    return result;
  v6 = *a1;
  if ( v6 != 2 )
  {
    if ( !*((_DWORD *)a1 + 2) && !*((_DWORD *)a1 + 3) && !*((_DWORD *)a1 + 4) && !*((_DWORD *)a1 + 5)
      || *((unsigned __int8 *)a1 + 8) == 255 )
    {
      return result;
    }
    if ( v6 != 10 )
      sub_6ECC0("ntp_restrict.c", 760, 0, "2 == ((addr)->sa.sa_family) || 10 == ((addr)->sa.sa_family)");
    LOWORD(v11) = 10;
    *(_WORD *)&v12[16] = 0;
    memset((char *)&v11 + 2, 0, 6);
    v13 = 0;
    memset(v12, 255, 16);
    if ( !a2 )
    {
      v7 = sub_3FD1C((int)(a1 + 4), (unsigned __int16)__rev16(a1[1]));
      v8 = (int *)v7;
      if ( !v7 )
        sub_6ECC0("ntp_restrict.c", 786, 2, "res != ((void *)0)");
      result = memcmp((const void *)(v7 + 36), v12, 0x10u) == 0;
      goto LABEL_13;
    }
    return sub_40238(3, a1, &v11, -2, 0, 0, 0);
  }
  result = *((_DWORD *)a1 + 1);
  if ( !result )
    return result;
  result = bswap32(result);
  if ( (result & 0xF0000000) == 0xE0000000 || HIWORD(result) << 16 == 2139029504 )
    return result;
  memset(v12, 0, sizeof(v12));
  v11 = 0xFFFFFFFF00000002LL;
  v13 = 0;
  if ( a2 )
    return sub_40238(3, a1, &v11, -2, 0, 0, 0);
  v10 = sub_3FC3C(result, (unsigned __int16)__rev16(a1[1]));
  v8 = (int *)v10;
  if ( !v10 )
    sub_6ECC0("ntp_restrict.c", 781, 2, "res != ((void *)0)");
  result = *(_DWORD *)(v10 + 24) == bswap32(HIDWORD(v11));
LABEL_13:
  if ( a3 )
    v9 = 0;
  else
    v9 = result;
  if ( v9 )
  {
    if ( v8[4] )
    {
      sub_3FAA4(v8, *a1 == 10);
      return sub_40238(1, a1, &v11, word_BCBBC, word_BCBBA, word_BCBB8, a3);
    }
  }
  else if ( !result )
  {
    return sub_40238(1, a1, &v11, word_BCBBC, word_BCBBA, word_BCBB8, a3);
  }
  return result;
}
// BCB34: using guessed type int dword_BCB34;
// BCBB8: using guessed type __int16 word_BCBB8;
// BCBBA: using guessed type __int16 word_BCBBA;
// BCBBC: using guessed type __int16 word_BCBBC;
// BCBC0: using guessed type int dword_BCBC0;

//----- (00040AEC) --------------------------------------------------------
int sub_40AEC()
{
  int result; // r0

  result = _stack_chk_guard;
  if ( !initializing )
  {
    result = alarm_flag;
    if ( alarm_flag )
      ++alarm_overflow;
    else
      alarm_flag = 1;
  }
  return result;
}
// 108C90: using guessed type int alarm_overflow;
// 108CA8: using guessed type int initializing;
// 108CB4: using guessed type int alarm_flag;

//----- (00040B88) --------------------------------------------------------
int sub_40B88()
{
  int result; // r0

  result = setitimer(0, (const struct itimerval *)&itimer, 0);
  if ( result == -1 )
  {
    sub_64E00(3, "interval timer %s failed, %m", "setitimer");
    exit(1);
  }
  return result;
}
// 108C94: using guessed type int itimer;

//----- (00040C14) --------------------------------------------------------
int sub_40C14()
{
  itimer = 0;
  dword_108C98 = 0;
  dword_108C9C = 0;
  dword_108CA0 = 0;
  getitimer(0, (struct itimerval *)&itimer);
  if ( (unsigned int)dword_108C9C <= 1 )
  {
    if ( dword_108CA0 < 0 )
    {
      dword_108CA0 = 0;
      if ( !dword_108C9C )
        dword_108C9C = 1;
    }
    else if ( !dword_108C9C )
    {
      dword_108C9C = dword_108CA0 == 0;
    }
  }
  else
  {
    dword_108C9C = 1;
    if ( dword_108CA0 < 0 )
      dword_108CA0 = 0;
  }
  *(_QWORD *)&itimer = 1;
  return sub_40B88();
}
// 108C94: using guessed type int itimer;
// 108C98: using guessed type int dword_108C98;
// 108C9C: using guessed type int dword_108C9C;
// 108CA0: using guessed type int dword_108CA0;

//----- (00040CF0) --------------------------------------------------------
int sub_40CF0()
{
  alarm_flag = 0;
  alarm_overflow = 0;
  dword_BCBC8 = 3600;
  dword_BCBC4 = 1;
  dword_BCBCC = (int)&off_15180;
  dword_BCBD0 = 0;
  dword_BCBD4 = 0;
  current_time = 0;
  timer_overflows = 0;
  timer_xmtcalls = 0;
  timer_timereset = 0;
  sub_6D6F0(14, (void (*)(int))sub_40AEC);
  dword_108C9C = 1;
  itimer = 1;
  dword_108CA0 = 0;
  dword_108C98 = 0;
  return sub_40B88();
}
// 15180: using guessed type char *off_15180;
// BCBC4: using guessed type int dword_BCBC4;
// BCBC8: using guessed type int dword_BCBC8;
// BCBCC: using guessed type int dword_BCBCC;
// BCBD0: using guessed type int dword_BCBD0;
// BCBD4: using guessed type int dword_BCBD4;
// 108C90: using guessed type int alarm_overflow;
// 108C94: using guessed type int itimer;
// 108C98: using guessed type int dword_108C98;
// 108C9C: using guessed type int dword_108C9C;
// 108CA0: using guessed type int dword_108CA0;
// 108CA4: using guessed type int current_time;
// 108CB4: using guessed type int alarm_flag;
// 108CBC: using guessed type int timer_timereset;
// 108CC4: using guessed type int timer_overflows;
// 108CC8: using guessed type int timer_xmtcalls;

//----- (00040DFC) --------------------------------------------------------
int __fastcall sub_40DFC(int result)
{
  if ( result )
  {
    result += current_time;
    dword_BCBD8 = result;
  }
  else
  {
    dword_BCBD8 = 0;
  }
  return result;
}
// BCBD8: using guessed type int dword_BCBD8;
// 108CA4: using guessed type int current_time;

//----- (00040E80) --------------------------------------------------------
int __fastcall sub_40E80(int result)
{
  dword_BCBD4 = result;
  return result;
}
// BCBD4: using guessed type int dword_BCBD4;

//----- (00040ED4) --------------------------------------------------------
void sub_40ED4()
{
  _DWORD *v0; // r0
  int v1; // r3
  unsigned int v2; // r2
  _DWORD *v3; // r4
  unsigned __int8 v4; // r3
  int v5; // r11
  unsigned int v6; // r3
  int v7; // r10
  int v8; // r0
  int v9; // r0
  _BOOL4 v10; // r10
  int v11; // r1
  int v12; // r0
  int v13; // r3
  int v14; // r1
  int v15; // r0
  double v16; // d0
  const char *v17; // r2
  _DWORD *v18; // r0
  _DWORD *v19; // r4
  int v20; // r11
  int v21; // r2
  int v22; // r10
  int v23; // r2
  time_t v24; // [sp+4h] [bp-38h] BYREF
  int v25; // [sp+8h] [bp-34h] BYREF
  unsigned __int64 s[4]; // [sp+10h] [bp-2Ch] BYREF

  if ( ++current_time >= (unsigned int)dword_BCBC4 )
  {
    ++dword_BCBC4;
    sub_301E4();
    v18 = (_DWORD *)peer_list;
    if ( !peer_list )
      goto LABEL_11;
    do
    {
      v19 = (_DWORD *)*v18;
      if ( (v18[17] & 8) != 0 )
        sub_3987C((int)v18);
      v18 = v19;
    }
    while ( v19 );
  }
  v0 = (_DWORD *)peer_list;
  if ( peer_list )
  {
    while ( 1 )
    {
      v1 = v0[178];
      v2 = v0[180];
      v3 = (_DWORD *)*v0;
      if ( v1 > 0 )
        v0[178] = v1 - 1;
      if ( v2 > current_time )
        goto LABEL_5;
      if ( (v0[17] & 8) != 0 )
      {
        sub_3992C();
LABEL_5:
        v0 = v3;
        if ( !v3 )
          break;
      }
      else
      {
        sub_36448((int)v0);
        v0 = v3;
        if ( !v3 )
          break;
      }
    }
  }
LABEL_11:
  v4 = sys_orphan;
  if ( sys_orphan <= 15 && !sys_peer && current_time > (unsigned int)orphwait )
  {
    if ( sys_leap == 3 )
    {
      sub_335A4(0);
      if ( crypto_flags )
        sub_279FC();
      v4 = sys_orphan;
    }
    sys_stratum = v4;
    if ( v4 <= 1u )
      v23 = 20300;
    else
      v23 = 16777343;
    if ( v4 <= 1u )
      HIWORD(v23) = 20559;
    sys_refid = v23;
    sys_offset = 0.0;
    sys_rootdelay = 0.0;
    sys_rootdisp = 0.0;
  }
  sub_5F724(&v25);
  time(&v24);
  if ( leapsec )
  {
    v5 = (unsigned __int8)sys_leap;
  }
  else
  {
    v6 = current_time;
    v5 = (unsigned __int8)sys_leap;
    if ( (current_time & 7) != 0 )
    {
      if ( sys_leap == 3 )
        goto LABEL_35;
      goto LABEL_57;
    }
  }
  v7 = v25;
  v8 = pll_control;
  if ( pll_control )
  {
    v8 = kern_enable;
    if ( kern_enable )
      v8 = 1;
  }
  sub_2D220(v8);
  if ( v5 == 3 )
  {
    sub_2DB18();
    memset(s, 0, sizeof(s));
    if ( !leapsec )
    {
      v9 = 0;
      v10 = 0;
LABEL_23:
      leapdif = 0;
      goto LABEL_24;
    }
    v10 = 0;
LABEL_74:
    v20 = 0;
    sub_25EE0((__int16 *)&byte_9[1], 0, 0);
    goto LABEL_75;
  }
  if ( sub_2D7D0(s, v7, &v24) )
  {
    v16 = (double)SLOWORD(s[3]);
    if ( v16 < 0.0 )
    {
      if ( clock_max_back <= 0.0 )
      {
        v17 = "Positive leap second, no step correction. System clock will be inaccurate for a long time.";
      }
      else if ( clock_max_back < -v16 )
      {
        sub_5FF34();
        v17 = "Positive leap second, stepped backward.";
      }
      else
      {
        v17 = "Positive leap second, no step correction. System clock will be inaccurate for a long time.";
      }
    }
    else
    {
      if ( v16 <= 0.0 )
        goto LABEL_66;
      if ( clock_max_fwd <= 0.0 )
      {
        v17 = "Negative leap second, no step correction. System clock will be inaccurate for a long time.";
      }
      else if ( v16 > clock_max_fwd )
      {
        sub_5FF34();
        v17 = "Negative leap second, stepped forward.";
      }
      else
      {
        v17 = "Negative leap second, no step correction. System clock will be inaccurate for a long time.";
      }
    }
    sub_64E00(5, (unsigned __int8 *)"%s", v17);
LABEL_66:
    v10 = 1;
    sub_25EE0((__int16 *)&byte_9[2], 0, 0);
    leapsec = 0;
    sys_tai = SWORD2(s[2]);
    if ( HIWORD(s[2]) )
      v9 = LODWORD(s[2]) <= 2;
    else
      v9 = 0;
    goto LABEL_23;
  }
  v20 = BYTE2(s[3]);
  v22 = sys_tai;
  sys_tai = SWORD2(s[2]);
  v10 = v22 != SWORD2(s[2]);
  if ( !leapsec )
  {
    if ( (unsigned int)BYTE2(s[3]) - 1 > 1 )
    {
      if ( HIWORD(s[2]) )
        v9 = LODWORD(s[2]) <= 2;
      else
        v9 = 0;
      goto LABEL_23;
    }
    if ( BYTE3(s[3]) )
      sub_25EE0((__int16 *)((char *)&dword_88 + 1), sys_peer, 0);
    else
      sub_25EE0((__int16 *)byte_9, 0, 0);
    goto LABEL_75;
  }
  if ( BYTE2(s[3]) <= (unsigned int)leapsec )
  {
    if ( BYTE2(s[3]) >= (unsigned int)leapsec )
    {
      v21 = SHIWORD(s[2]);
      v9 = LODWORD(s[2]) <= 2;
      if ( !HIWORD(s[2]) )
        v9 = 0;
      goto LABEL_78;
    }
    if ( !BYTE2(s[3]) )
      goto LABEL_74;
  }
LABEL_75:
  v21 = SHIWORD(s[2]);
  leapsec = v20;
  v9 = LODWORD(s[2]) <= 2;
  if ( !HIWORD(s[2]) )
    v9 = 0;
  if ( !v20 )
    goto LABEL_23;
LABEL_78:
  leapdif = v21;
LABEL_24:
  v11 = leap_sec_in_progress;
  leap_sec_in_progress = v9;
  if ( v11 != v9 )
    sub_335A4((unsigned __int8)sys_leap);
  if ( v10 )
    sub_27AA0();
  if ( sys_leap == 3 )
    goto LABEL_58;
  if ( (unsigned int)leapsec <= 1 || !leapdif )
  {
LABEL_57:
    sub_335A4(0);
LABEL_58:
    v6 = current_time;
    goto LABEL_35;
  }
  if ( leapdif <= 0 )
    v12 = 2;
  else
    v12 = 1;
  sub_335A4(v12);
  v6 = current_time;
LABEL_35:
  if ( dword_BCBD0 <= v6 )
  {
    dword_BCBD0 += 900;
    sub_30520();
    v6 = current_time;
  }
  if ( dword_BCBDC <= v6 )
  {
    dword_BCBDC += 1 << sys_automax;
    sub_626D0();
    v6 = current_time;
  }
  if ( dword_BCBE0 && dword_BCBE0 <= v6 )
  {
    dword_BCBE0 += 1 << sys_revoke;
    RAND_bytes(&sys_private, 4, dword_BCBE0);
    v6 = current_time;
  }
  if ( interface_interval && dword_BCBD4 <= v6 )
  {
    sub_40E80(interface_interval + v6);
    sub_18908(0, 0);
    v6 = current_time;
  }
  if ( dword_BCBD8 && dword_BCBD8 <= v6 )
  {
    sub_69654();
    v6 = current_time;
  }
  if ( dword_BCBC8 <= v6 )
  {
    dword_BCBC8 += 3600;
    sub_419E0();
    v13 = dword_BCBCC;
    if ( dword_BCBCC > (unsigned int)current_time )
    {
      v14 = v25;
      v15 = 0;
    }
    else
    {
      v13 = dword_BCBCC + 86400;
      v14 = v25;
      v15 = 1;
    }
    if ( dword_BCBCC <= (unsigned int)current_time )
      dword_BCBCC = v13;
    sub_42670(v15, v14, &v24);
  }
}
// 88: using guessed type int dword_88;
// BE24: using guessed type int __fastcall RAND_bytes(_DWORD, _DWORD, _DWORD);
// 3992C: using guessed type int sub_3992C(void);
// B6AE8: using guessed type int kern_enable;
// B6B10: using guessed type double clock_max_fwd;
// B6B18: using guessed type double clock_max_back;
// B6C20: using guessed type int sys_orphan;
// B6C88: using guessed type char sys_automax;
// B6C89: using guessed type char sys_revoke;
// B9920: using guessed type int crypto_flags;
// BCBC4: using guessed type int dword_BCBC4;
// BCBC8: using guessed type int dword_BCBC8;
// BCBCC: using guessed type int dword_BCBCC;
// BCBD0: using guessed type int dword_BCBD0;
// BCBD4: using guessed type int dword_BCBD4;
// BCBD8: using guessed type int dword_BCBD8;
// BCBDC: using guessed type int dword_BCBDC;
// BCBE0: using guessed type int dword_BCBE0;
// 1082D0: using guessed type int sys_tai;
// 1082F4: using guessed type int pll_control;
// 108B8C: using guessed type int peer_list;
// 108BB8: using guessed type double sys_rootdisp;
// 108BC0: using guessed type char sys_leap;
// 108BC8: using guessed type double sys_rootdelay;
// 108BD0: using guessed type int sys_refid;
// 108C14: using guessed type char sys_stratum;
// 108C2C: using guessed type int sys_peer;
// 108C3C: using guessed type int sys_private;
// 108C40: using guessed type double sys_offset;
// 108C50: using guessed type int leap_sec_in_progress;
// 108CA4: using guessed type int current_time;
// 108CAC: using guessed type int leapsec;
// 108CB0: using guessed type int orphwait;
// 108CB8: using guessed type int interface_interval;
// 108CC0: using guessed type int leapdif;

//----- (00041648) --------------------------------------------------------
int sub_41648()
{
  timer_overflows = 0;
  timer_xmtcalls = 0;
  timer_timereset = current_time;
  return _stack_chk_guard;
}
// 108CA4: using guessed type int current_time;
// 108CBC: using guessed type int timer_timereset;
// 108CC4: using guessed type int timer_overflows;
// 108CC8: using guessed type int timer_xmtcalls;

//----- (000416D0) --------------------------------------------------------
int ntpd_time_stepped()
{
  int v0; // r5
  int result; // r0

  v0 = mon_enabled;
  if ( mon_enabled )
  {
    sub_30DFC(0);
    return sub_30CD4(v0);
  }
  return result;
}
// 108358: using guessed type int mon_enabled;

//----- (00041754) --------------------------------------------------------
int __fastcall sub_41754(int a1, int a2, time_t *a3)
{
  int result; // r0
  _BOOL4 v5; // r3
  bool v6; // zf
  int v7; // r0
  const char *v8; // r2

  result = sub_2DC54(a2, a3);
  if ( !result )
    return (int)sub_64E00(
                  4,
                  "%s ('%s'): will expire in less than one day",
                  "leapsecond file",
                  (const char *)dword_BCBE8);
  v5 = result <= 27;
  if ( !a1 )
    v5 = 0;
  if ( v5 )
  {
    if ( result >= 0 )
    {
      return (int)sub_64E00(
                    4,
                    "%s ('%s'): will expire in less than %d days",
                    "leapsecond file",
                    (const char *)dword_BCBE8,
                    result + 1);
    }
    else
    {
      v6 = result == -1;
      v7 = -result;
      if ( v6 )
        v8 = byte_97F7C;
      else
        v8 = "s";
      return (int)sub_64E00(
                    3,
                    "%s ('%s'): expired less than %d day%s ago",
                    "leapsecond file",
                    (const char *)dword_BCBE8,
                    v7,
                    v8);
    }
  }
  return result;
}
// BCBE8: using guessed type int dword_BCBE8;

//----- (000418A8) --------------------------------------------------------
int sub_418A8()
{
  int v1; // [sp+4h] [bp-8h]

  sub_2C7BC(statsdir, "peerstats", (int)&dword_BCBEC);
  sub_2C7BC(statsdir, "loopstats", (int)&dword_BCC04);
  sub_2C7BC(statsdir, "clockstats", (int)&dword_BCC1C);
  sub_2C7BC(statsdir, "rawstats", (int)&dword_BCC34);
  sub_2C7BC(statsdir, "sysstats", (int)&dword_BCC4C);
  sub_2C7BC(statsdir, "protostats", (int)&dword_BCC64);
  sub_2C7BC(statsdir, "cryptostats", (int)&dword_BCC7C);
  sub_2C7BC(statsdir, "timingstats", (int)&unk_BCC94);
  step_callback = (int (__fastcall *)(_DWORD, _DWORD, _DWORD))ntpd_time_stepped;
  return v1;
}
// 41980: variable 'v1' is possibly undefined
// BCBEC: using guessed type int dword_BCBEC;
// BCC04: using guessed type int dword_BCC04;
// BCC1C: using guessed type int dword_BCC1C;
// BCC34: using guessed type int dword_BCC34;
// BCC4C: using guessed type int dword_BCC4C;
// BCC64: using guessed type int dword_BCC64;
// BCC7C: using guessed type int dword_BCC7C;
// 108CF4: using guessed type int (__fastcall *step_callback)(_DWORD, _DWORD, _DWORD);

//----- (000419E0) --------------------------------------------------------
void sub_419E0()
{
  int v0; // r0
  FILE *v1; // r4
  const char *v2; // r4
  int v3; // r7
  unsigned int v4; // r8
  unsigned int v5; // r0
  char *v6; // r0
  int v7[2]; // [sp+34h] [bp-Ch] BYREF

  if ( stats_control )
  {
    sub_5F724(v7);
    sub_2BE54((int)&dword_BCC4C, v7[0]);
    v3 = dword_BCC4C;
    v4 = v7[0] / 0x15180u;
    v5 = v7[0] - (_DWORD)&off_15180 * (v7[0] / 0x15180u);
    v7[0] = v5;
    if ( dword_BCC4C )
    {
      v6 = sub_63804(v5, v7[1], 0, 3, 0);
      _fprintf_chk(
        v3,
        1,
        "%lu %s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
        v4 + 15020,
        v6,
        current_time - sys_stattime,
        sys_received,
        sys_processed,
        sys_newversion,
        sys_oldversion,
        sys_restricted,
        sys_badlength,
        sys_badauth,
        sys_declined,
        sys_limitrejected,
        sys_kodsent);
      fflush((FILE *)dword_BCC4C);
      sub_38C70();
    }
  }
  if ( stats_drift_file )
  {
    if ( fabs(dbl_BCCB8 - drift_comp) >= dbl_BCCB0 )
    {
      dbl_BCCB8 = drift_comp;
      dbl_BCCB0 = wander_threshold;
      v0 = fopen64(dword_BCCC0, "w");
      v1 = (FILE *)v0;
      if ( v0 )
      {
        _fprintf_chk(v0, 1, "%.3f\n", drift_comp * 1000000.0);
        fclose(v1);
        v2 = (const char *)dword_BCCC0;
        if ( rename((const char *)dword_BCCC0, (const char *)stats_drift_file) )
          sub_64E00(4, "Unable to rename temp drift file %s to %s, %m", v2, (const char *)stats_drift_file);
      }
      else
      {
        sub_64E00(3, "frequency file %s: %m", (const char *)dword_BCCC0);
      }
    }
    else
    {
      dbl_BCCB0 = dbl_BCCB0 * 0.5;
    }
  }
}
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 15180: using guessed type char *off_15180;
// B6D90: using guessed type double wander_threshold;
// BCC4C: using guessed type int dword_BCC4C;
// BCCB0: using guessed type double dbl_BCCB0;
// BCCB8: using guessed type double dbl_BCCB8;
// BCCC0: using guessed type int dword_BCCC0;
// 1082D8: using guessed type double drift_comp;
// 108B98: using guessed type int sys_badauth;
// 108BB0: using guessed type int sys_newversion;
// 108BD4: using guessed type int sys_kodsent;
// 108BFC: using guessed type int sys_received;
// 108C00: using guessed type int sys_restricted;
// 108C10: using guessed type int sys_limitrejected;
// 108C18: using guessed type int sys_processed;
// 108C1C: using guessed type int sys_declined;
// 108C20: using guessed type int sys_stattime;
// 108C28: using guessed type int sys_badlength;
// 108C38: using guessed type int sys_oldversion;
// 108CA4: using guessed type int current_time;
// 108CCC: using guessed type int stats_drift_file;
// 108CD0: using guessed type int stats_control;

//----- (00041CDC) --------------------------------------------------------
unsigned int __fastcall sub_41CDC(unsigned int result, int a2)
{
  double v2; // d0
  double v3; // d1
  double v4; // d2
  double v5; // d3
  unsigned __int16 *v7; // r5
  int v8; // r8
  unsigned int v9; // r9
  char *v10; // r10
  const char *v11; // r0
  int v12[2]; // [sp+34h] [bp-Ch] BYREF

  if ( stats_control )
  {
    v7 = (unsigned __int16 *)result;
    sub_5F724(v12);
    sub_2BE54((int)&dword_BCBEC, v12[0]);
    v8 = dword_BCBEC;
    v9 = v12[0] / 0x15180u;
    result = v12[0] - (_DWORD)&off_15180 * (v12[0] / 0x15180u);
    v12[0] = result;
    if ( dword_BCBEC )
    {
      v10 = sub_63804(result, v12[1], 0, 3, 0);
      v11 = sub_6C2E8(v7);
      _fprintf_chk(v8, 1, "%lu %s %s %x %.9f %.9f %.9f %.9f\n", v9 + 15020, v10, v11, a2, v2, v3, v4, v5);
      return fflush((FILE *)dword_BCBEC);
    }
  }
  return result;
}
// 41DE8: variable 'v2' is possibly undefined
// 41DE8: variable 'v3' is possibly undefined
// 41DE8: variable 'v4' is possibly undefined
// 41DE8: variable 'v5' is possibly undefined
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 15180: using guessed type char *off_15180;
// BCBEC: using guessed type int dword_BCBEC;
// 108CD0: using guessed type int stats_control;

//----- (00041E10) --------------------------------------------------------
unsigned int __fastcall sub_41E10(unsigned int result)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double v4; // d3
  unsigned int v5; // r5
  int v6; // r7
  unsigned int v7; // r8
  char *v8; // r0
  int v9[2]; // [sp+34h] [bp-Ch] BYREF

  if ( stats_control )
  {
    v5 = result;
    sub_5F724(v9);
    sub_2BE54((int)&dword_BCC04, v9[0]);
    v6 = dword_BCC04;
    v7 = v9[0] / 0x15180u;
    result = v9[0] - (_DWORD)&off_15180 * (v9[0] / 0x15180u);
    v9[0] = result;
    if ( dword_BCC04 )
    {
      v8 = sub_63804(result, v9[1], 0, 3, 0);
      _fprintf_chk(v6, 1, "%lu %s %.9f %.3f %.9f %.6f %d\n", v7 + 15020, v8, v1, v2 * 1000000.0, v3, v4 * 1000000.0, v5);
      return fflush((FILE *)dword_BCC04);
    }
  }
  return result;
}
// 41F14: variable 'v1' is possibly undefined
// 41F10: variable 'v2' is possibly undefined
// 41F14: variable 'v3' is possibly undefined
// 41F0C: variable 'v4' is possibly undefined
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 15180: using guessed type char *off_15180;
// BCC04: using guessed type int dword_BCC04;
// 108CD0: using guessed type int stats_control;

//----- (00041F44) --------------------------------------------------------
unsigned int __fastcall sub_41F44(unsigned __int16 *a1, const char *a2)
{
  unsigned int result; // r0
  int v5; // r8
  unsigned int v6; // r9
  char *v7; // r10
  const char *v8; // r0
  int v9[2]; // [sp+14h] [bp-Ch] BYREF

  result = 2092;
  if ( stats_control )
  {
    sub_5F724(v9);
    sub_2BE54((int)&dword_BCC1C, v9[0]);
    v5 = dword_BCC1C;
    v6 = v9[0] / 0x15180u;
    result = v9[0] - (_DWORD)&off_15180 * (v9[0] / 0x15180u);
    v9[0] = result;
    if ( dword_BCC1C )
    {
      v7 = sub_63804(result, v9[1], 0, 3, 0);
      v8 = sub_6C2E8(a1);
      _fprintf_chk(v5, 1, "%lu %s %s %s\n", v6 + 15020, v7, v8, a2);
      return fflush((FILE *)dword_BCC1C);
    }
  }
  return result;
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 15180: using guessed type char *off_15180;
// BCC1C: using guessed type int dword_BCC1C;
// 108CD0: using guessed type int stats_control;

//----- (00042050) --------------------------------------------------------
unsigned int sub_42050(unsigned __int16 *a1, unsigned __int8 *a2, ...)
{
  unsigned int v3; // r7
  char v5[512]; // [sp+4h] [bp-208h] BYREF
  va_list varg_r2; // [sp+228h] [bp+1Ch] BYREF

  va_start(varg_r2, a2);
  v3 = sub_64BBC((int)v5, 0x200u, a2, (int *)varg_r2);
  if ( stats_control )
    sub_41F44(a1, v5);
  return v3;
}
// 108CD0: using guessed type int stats_control;

//----- (000420F0) --------------------------------------------------------
unsigned int __fastcall sub_420F0(
        unsigned __int16 *a1,
        unsigned __int16 *a2,
        unsigned int *a3,
        unsigned int *a4,
        unsigned int *a5,
        unsigned int *a6,
        unsigned int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        int a15)
{
  double v15; // d0
  double v16; // d1
  unsigned int result; // r0
  unsigned int v22; // r11
  const char *v23; // r9
  char *v24; // r7
  char *v25; // r6
  char *v26; // r5
  char *v27; // r4
  const char *v28; // r0
  int v29; // r4
  int v30; // t1
  int v31; // [sp+74h] [bp-20h]
  char *v32; // [sp+78h] [bp-1Ch]
  const char *v33; // [sp+7Ch] [bp-18h]
  int v34[2]; // [sp+84h] [bp-10h] BYREF

  result = a7;
  if ( stats_control )
  {
    sub_5F724(v34);
    sub_2BE54((int)&dword_BCC34, v34[0]);
    v22 = v34[0];
    v31 = dword_BCC34;
    result = v34[0] - (_DWORD)&off_15180 * (v34[0] / 0x15180u);
    v34[0] = result;
    if ( dword_BCC34 )
    {
      v32 = sub_63804(result, v34[1], 0, 3, 0);
      if ( a1 )
        v33 = sub_6C2E8(a1);
      else
        v33 = "-";
      if ( a2 )
        v23 = sub_6C2E8(a2);
      else
        v23 = "-";
      v24 = sub_63804(*a3, a3[1], 0, 9, 0);
      v25 = sub_63804(*a4, a4[1], 0, 9, 0);
      v26 = sub_63804(*a5, a5[1], 0, 9, 0);
      v27 = sub_63804(*a6, a6[1], 0, 9, 0);
      v28 = sub_697A8(a13, a10);
      _fprintf_chk(
        v31,
        1,
        "%lu %s %s %s %s %s %s %s %d %d %d %d %d %d %.6f %.6f %s",
        v22 / 0x15180 + 15020,
        v32,
        v33,
        v23,
        v24,
        v25,
        v26,
        v27,
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        v15,
        v16,
        v28);
      if ( a14 > 0 )
      {
        v29 = a15 - 1;
        _fprintf_chk(dword_BCC34, 1, " %d: ", a14);
        do
        {
          v30 = *(unsigned __int8 *)++v29;
          _fprintf_chk(dword_BCC34, 1, "%02x", v30);
        }
        while ( v29 != a15 - 1 + a14 );
      }
      fputc(10, (FILE *)dword_BCC34);
      return fflush((FILE *)dword_BCC34);
    }
  }
  return result;
}
// 4234C: variable 'v15' is possibly undefined
// 4234C: variable 'v16' is possibly undefined
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 15180: using guessed type char *off_15180;
// BCC34: using guessed type int dword_BCC34;
// 108CD0: using guessed type int stats_control;

//----- (0004241C) --------------------------------------------------------
unsigned int __fastcall sub_4241C(unsigned int result)
{
  const char *v1; // r5
  int v2; // r7
  unsigned int v3; // r8
  char *v4; // r0
  int v5[2]; // [sp+Ch] [bp-Ch] BYREF

  if ( stats_control )
  {
    v1 = (const char *)result;
    sub_5F724(v5);
    sub_2BE54((int)&dword_BCC64, v5[0]);
    v2 = dword_BCC64;
    v3 = v5[0] / 0x15180u;
    result = v5[0] - (_DWORD)&off_15180 * (v5[0] / 0x15180u);
    v5[0] = result;
    if ( dword_BCC64 )
    {
      v4 = sub_63804(result, v5[1], 0, 3, 0);
      _fprintf_chk(v2, 1, "%lu %s %s\n", v3 + 15020, v4, v1);
      return fflush((FILE *)dword_BCC64);
    }
  }
  return result;
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 15180: using guessed type char *off_15180;
// BCC64: using guessed type int dword_BCC64;
// 108CD0: using guessed type int stats_control;

//----- (00042514) --------------------------------------------------------
unsigned int __fastcall sub_42514(unsigned __int16 *a1, const char *a2)
{
  unsigned int result; // r0
  int v5; // r8
  unsigned int v6; // r7
  unsigned int v7; // r7
  char *v8; // r9
  const char *v9; // r0
  char *v10; // r0
  unsigned int v11; // [sp+14h] [bp-10h] BYREF
  unsigned int v12; // [sp+18h] [bp-Ch]

  result = 2092;
  if ( stats_control )
  {
    sub_5F724((int *)&v11);
    sub_2BE54((int)&dword_BCC7C, v11);
    v5 = dword_BCC7C;
    v6 = v11 / 0x15180;
    result = v11 - (_DWORD)&off_15180 * (v11 / 0x15180);
    v11 = result;
    if ( dword_BCC7C )
    {
      v7 = v6 + 15020;
      if ( a1 )
      {
        v8 = sub_63804(result, v12, 0, 3, 0);
        v9 = sub_6C2E8(a1);
        _fprintf_chk(v5, 1, "%lu %s %s %s\n", v7, v8, v9, a2);
      }
      else
      {
        v10 = sub_63804(result, v12, 0, 3, 0);
        _fprintf_chk(v5, 1, "%lu %s 0.0.0.0 %s\n", v7, v10, a2);
      }
      return fflush((FILE *)dword_BCC7C);
    }
  }
  return result;
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 15180: using guessed type char *off_15180;
// BCC7C: using guessed type int dword_BCC7C;
// 108CD0: using guessed type int stats_control;

//----- (00042670) --------------------------------------------------------
int __fastcall sub_42670(int a1, int a2, time_t *a3)
{
  int result; // r0

  result = dword_BCBE8;
  if ( dword_BCBE8 && *(_BYTE *)dword_BCBE8 )
  {
    result = sub_2E578((const char *)dword_BCBE8, dword_BCCC8, dword_BCCC4 == 0, a1);
    if ( result )
    {
      dword_BCCC4 = 1;
    }
    else if ( !dword_BCCC4 )
    {
      return result;
    }
    return sub_41754(a1, a2, a3);
  }
  return result;
}
// BCBE8: using guessed type int dword_BCBE8;
// BCCC4: using guessed type int dword_BCCC4;
// BCCC8: using guessed type _DWORD dword_BCCC8[26];

//----- (00042744) --------------------------------------------------------
size_t __fastcall sub_42744(const char *a1)
{
  size_t result; // r0
  size_t v3; // r5
  const char *v4; // r0

  result = strlen(a1);
  if ( result )
  {
    v3 = result + 1;
    dword_BCD30 = (int)sub_63BA4((void *)dword_BCD30, result + 1, 0, 0);
    v4 = (const char *)memcpy((void *)dword_BCD30, a1, v3);
    return sub_62B28(v4);
  }
  return result;
}
// BCD30: using guessed type int dword_BCD30;

//----- (000427E8) --------------------------------------------------------
int sub_427E8()
{
  int result; // r0

  result = dword_BCD30;
  if ( dword_BCD30 )
    return sub_62B28((const char *)dword_BCD30);
  return result;
}
// BCD30: using guessed type int dword_BCD30;

//----- (00042858) --------------------------------------------------------
_BYTE *__fastcall sub_42858(int a1)
{
  _BYTE *v2; // r5
  int v3; // r4
  unsigned __int16 v5; // [sp+10h] [bp-10h] BYREF
  unsigned __int8 v6; // [sp+14h] [bp-Ch]
  unsigned __int8 v7; // [sp+15h] [bp-Bh]
  unsigned __int8 v8; // [sp+16h] [bp-Ah]
  unsigned __int8 v9; // [sp+17h] [bp-9h]

  v2 = &lib_stringbuf[128 * lib_nextbuf];
  v3 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v2, 0, 0x80u);
  lib_nextbuf = v3;
  if ( sub_66750(&v5, a1, 0) < 0 )
    sub_6C054((int)v2, 0x80u, "ntpcal_ntp_to_date: %ld: range error", a1);
  else
    sub_6C054((int)v2, 0x80u, "%04d%02d%02d%02d%02d", v5, v6, v7, v8, v9);
  return v2;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0004294C) --------------------------------------------------------
void __fastcall sub_4294C(int a1, char *s)
{
  size_t v3; // r0
  size_t v4; // r0
  size_t v5; // r7
  void *v6; // r8
  int v7; // r7
  const char *v8; // r5
  const char *v9; // r8
  const char *v10; // r0
  FILE *v11; // r4
  __pid_t v12; // r0
  size_t v13; // r0
  size_t v14; // r7
  char *v15; // r9
  __int16 v16; // r2
  FILE *v17; // r0
  FILE *v18; // r5
  time_t v19; // [sp+14h] [bp-28h] BYREF
  int v20; // [sp+18h] [bp-24h] BYREF
  int v21[2]; // [sp+20h] [bp-1Ch] BYREF
  __int16 v22; // [sp+28h] [bp-14h]
  _DWORD v23[2]; // [sp+2Ch] [bp-10h] BYREF

  strcpy((char *)v23, ".TEMP");
  switch ( a1 )
  {
    case 1:
      if ( s )
      {
        v13 = strlen(s);
        v14 = v13;
        if ( v13 )
        {
          stats_drift_file = (int)sub_63BA4((void *)stats_drift_file, v13 + 1, 0, 0);
          v15 = (char *)sub_63BA4((void *)dword_BCCC0, v14 + 6, 0, 0);
          dword_BCCC0 = (int)v15;
          memcpy((void *)stats_drift_file, s, v14 + 1);
          memcpy(v15, s, v14);
          v16 = v23[1];
          *(_DWORD *)&v15[v14] = v23[0];
          *(_WORD *)&v15[v14 + 4] = v16;
          v17 = (FILE *)fopen64(stats_drift_file, "r");
          v18 = v17;
          if ( v17 )
          {
            if ( fscanf(v17, "%lf", v21) == 1 )
            {
              fclose(v18);
              sub_305F8(&byte_9[3]);
              dbl_BCCB8 = drift_comp;
            }
            else
            {
              sub_64E00(3, "format error frequency file %s", (const char *)stats_drift_file);
              fclose(v18);
            }
          }
        }
      }
      break;
    case 2:
      v3 = strlen(s);
      if ( v3 > 0xFE )
      {
        sub_64E00(3, "statsdir too long (>%d, sigh)", 254);
      }
      else
      {
        if ( v3 && s[v3 - 1] != 47 )
          sub_6C054((int)statsdir, 0x100u, "%s%c", s, 47);
        else
          sub_6C054((int)statsdir, 0x100u, (unsigned __int8 *)"%s", s);
        sub_2C8D8();
      }
      break;
    case 3:
      v11 = (FILE *)fopen64(s, "w");
      if ( v11 )
      {
        v12 = getpid();
        _fprintf_chk(v11, 1, "%d", v12);
        fclose(v11);
      }
      else
      {
        sub_64E00(3, "pid file %s: %m", s);
      }
      break;
    case 4:
      if ( s )
      {
        v4 = strlen(s);
        if ( v4 )
        {
          v5 = v4 + 1;
          v6 = sub_63BA4((void *)dword_BCBE8, v4 + 1, 0, 0);
          dword_BCBE8 = (int)v6;
          memcpy(v6, s, v5);
          if ( sub_2E578((const char *)v6, dword_BCCC8, 1, 1) )
          {
            sub_5F724(&v20);
            time(&v19);
            sub_2DB68(v21);
            v7 = v22;
            v8 = sub_42858(v21[1]);
            if ( sub_2DBD0(v20, 0) )
              v9 = "expired";
            else
              v9 = "expires";
            v10 = sub_42858(v21[0]);
            sub_262E8((__int16 *)&byte_9[5], 0, "%d leap %s %s %s", v7, v8, v9, v10);
            dword_BCCC4 = 1;
            sub_41754(1, v20, &v19);
          }
        }
      }
      break;
    default:
      return;
  }
}
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// BCBE8: using guessed type int dword_BCBE8;
// BCCB8: using guessed type double dbl_BCCB8;
// BCCC0: using guessed type int dword_BCCC0;
// BCCC4: using guessed type int dword_BCCC4;
// BCCC8: using guessed type _DWORD dword_BCCC8[26];
// 1082D8: using guessed type double drift_comp;
// 108CCC: using guessed type int stats_drift_file;

//----- (00042D0C) --------------------------------------------------------
int __fastcall sub_42D0C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // r3
  int v3; // t1
  unsigned int v5; // r3
  bool v6; // cc
  unsigned __int8 *i; // r2
  unsigned int v8; // r12
  bool v9; // cc

  if ( a2 == a1 )
    return 0;
  if ( (unsigned int)*(a2 - 1) - 33 > 0x5E )
  {
    v2 = a2 - 1;
    do
    {
      a2 = v2;
      if ( a1 == v2 )
        return 0;
      v3 = *--v2;
    }
    while ( (unsigned int)(v3 - 33) > 0x5E );
  }
  v5 = *a1;
  v6 = v5 > 9;
  if ( v5 != 9 )
    v6 = v5 - 32 > 0x5F;
  if ( v6 )
    return 0;
  for ( i = a1 + 1; a2 != i; ++i )
  {
    v8 = *i;
    v9 = v8 > 9;
    if ( v8 != 9 )
      v9 = v8 - 32 > 0x5F;
    if ( v9 )
      return i - a1;
  }
  return a2 - a1;
}

//----- (00042DE0) --------------------------------------------------------
void sub_42DE0()
{
  ;
}

//----- (00042E24) --------------------------------------------------------
int sub_42E24()
{
  dword_BCD58 = 0;
  qmemcpy(&dword_BCD50, "//k/mn", 6);
  return *(_DWORD *)"//k/mn";
}
// BCD50: using guessed type int dword_BCD50;
// BCD58: using guessed type int dword_BCD58;

//----- (00042E94) --------------------------------------------------------
void sub_42E94()
{
  ;
}

//----- (00042ED8) --------------------------------------------------------
ssize_t __fastcall sub_42ED8(int a1, int a2)
{
  int *v2; // r12
  int v3; // r4
  ssize_t result; // r0

  v2 = *(int **)(a2 + 84);
  v3 = *v2;
  result = write(*(_DWORD *)(*v2 + 4), &dword_BCD50, 6u);
  if ( result != 6 )
    perror("TIME_REQUEST");
  *(_BYTE *)(v3 + 73) = 0;
  return result;
}
// BCD50: using guessed type int dword_BCD50;

//----- (00042F5C) --------------------------------------------------------
void __fastcall sub_42F5C(int a1, int a2)
{
  void **v3; // r0
  void *v4; // r5

  sub_64E00(3, "Datum_PTS: Shutdown Datum PTS");
  v3 = *(void ***)(a2 + 84);
  v4 = *v3;
  if ( *v3 )
  {
    sub_18E64((int)(v3 + 2));
    free(v4);
  }
}

//----- (00042FF0) --------------------------------------------------------
char *__fastcall sub_42FF0(char *result)
{
  int32x2_t v1; // d7
  int *v2; // r1
  char *v3; // r6
  int v4; // r4
  int v5; // lr
  unsigned int v6; // r2
  int v7; // r1
  char *v8; // t0
  char *v9; // r1
  char v10; // t1
  _BOOL4 v11; // r3
  _BOOL4 v12; // r3
  unsigned int v13; // r0
  unsigned int v14; // r8
  int v15; // r3
  unsigned int v16; // r7
  __int16 v17; // r1
  int v18; // r12
  unsigned int v19; // r3
  int v20; // lr
  __int64 v21; // r2
  int v22; // r1
  int v23; // r0
  unsigned int v24; // r0
  unsigned int v25; // r1
  int v26; // r8
  unsigned int v27; // r7
  int v28; // r0
  int v29; // r1
  __int64 v30; // r2
  double v31; // d7
  double v32; // d6
  bool v33; // nf
  double v34; // d5
  bool v35; // nf
  double v36; // d6

  v2 = *(int **)(*((_DWORD *)result + 1) + 84);
  v3 = result + 88;
  v4 = *v2;
  v5 = *((_DWORD *)result + 21);
  v6 = *(unsigned __int8 *)(*v2 + 73);
  if ( *(_BYTE *)(*v2 + 73) )
  {
    v12 = v5 > 0;
    if ( v6 > 7 )
      v12 = 0;
    if ( !v12 )
      goto LABEL_7;
  }
  else
  {
    v8 = result + 72;
    result = (char *)*((_DWORD *)result + 18);
    v7 = *((_DWORD *)v8 + 1);
    *(_DWORD *)(v4 + 16) = result;
    *(_DWORD *)(v4 + 20) = v7;
    if ( v5 <= 0 )
    {
      *(_BYTE *)(v4 + 73) = v6;
      return result;
    }
  }
  v9 = v3;
  result = (char *)(v4 + v6 + 65);
  do
  {
    v10 = *v9++;
    ++v6;
    *result++ = v10;
    v11 = v9 - v3 < v5;
    if ( v6 > 7 )
      v11 = 0;
  }
  while ( v11 );
LABEL_7:
  *(_BYTE *)(v4 + 73) = v6;
  if ( v6 > 6 )
  {
    v13 = *(unsigned __int8 *)(v4 + 66);
    v14 = *(unsigned __int8 *)(v4 + 67);
    v15 = 100 * (*(unsigned __int8 *)(v4 + 70) >> 4)
        + 10 * (*(_BYTE *)(v4 + 70) & 0xF)
        + (*(unsigned __int8 *)(v4 + 71) >> 4);
    v16 = *(unsigned __int8 *)(v4 + 68);
    v17 = *(_BYTE *)(v4 + 65) & 0xF;
    v18 = 1000 * v15;
    *(_DWORD *)(v4 + 56) = v15;
    v19 = *(unsigned __int8 *)(v4 + 69);
    v20 = 100 * v17 + 10 * (v13 >> 4);
    *(_DWORD *)(v4 + 60) = v18;
    HIDWORD(v21) = (v19 & 0xF) + 10 * ((v19 >> 4) & 7);
    v22 = (v14 & 0xF) + 10 * ((v14 >> 4) & 3);
    LODWORD(v21) = (v16 & 0xF) + 10 * ((v16 >> 4) & 7);
    v23 = v20 + (v13 & 0xF);
    *(_DWORD *)(v4 + 44) = v22;
    *(_DWORD *)(v4 + 40) = v23;
    *(_QWORD *)(v4 + 48) = v21;
    if ( sub_633D8(v23, v22, v21, SHIDWORD(v21), 0, *(_DWORD *)(v4 + 16), (int *)(v4 + 32), (_DWORD *)(v4 + 24)) )
    {
      v24 = sub_8BFD0((unsigned __int64)&loc_7A120 + __PAIR64__(*(_DWORD *)(v4 + 60), 0), (unsigned int)&unk_F4240);
      v25 = *(_DWORD *)(v4 + 20);
      v26 = *(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 16);
      v27 = v24 - v25;
      if ( v24 < v25 )
        --v26;
      v28 = *(_DWORD *)(v4 + 16);
      v29 = *(_DWORD *)(v4 + 20);
      ++*(_DWORD *)(v4 + 36);
      *(_DWORD *)(v4 + 24) = v28;
      *(_DWORD *)(v4 + 28) = v29;
      result = (char *)sub_39D44(*(_DWORD *)v4);
      v1.n64_u32[0] = (v27 >> 12) | (v26 << 20);
      v31 = vcvt_n_f64_s32(v1, 0x14u);
      v32 = *(double *)(v4 + 80);
      if ( v31 < 0.0 )
        v31 = -v31;
      if ( v32 == 0.0 )
      {
        v33 = v31 < 0.1;
        if ( v31 < 0.1 )
        {
          v31 = v31 * v31;
        }
        else
        {
          LOWORD(v30) = 5244;
          WORD2(v30) = 31457;
        }
        if ( v33 )
        {
          *(double *)(v4 + 80) = v31;
        }
        else
        {
          WORD1(v30) = 18350;
          HIWORD(v30) = 16260;
          *(_QWORD *)(v4 + 80) = v30;
        }
      }
      else
      {
        v34 = 0.95;
        v35 = v31 < 0.1;
        v36 = v32 * 0.95;
        if ( v31 >= 0.1 )
          v31 = 0.0005;
        else
          v34 = 0.05;
        if ( v35 )
          v34 = v31 * v34;
        else
          v36 = v36 + v31;
        if ( v35 )
          v36 = v36 + v34 * v31;
        *(double *)(v4 + 80) = v36;
      }
    }
    else
    {
      return sub_64E00(3, "Datum_PTS: Bad clocktime");
    }
  }
  return result;
}
// 431FC: variable 'v1' is possibly undefined
// 4323C: variable 'v30' is possibly undefined
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (000432DC) --------------------------------------------------------
int __fastcall sub_432DC(int a1, int a2, int a3)
{
  int v5; // r8
  _DWORD *v6; // r4
  int v7; // r0
  int *v8; // r6
  int v9; // r2
  int v10; // r8
  int v11; // r3
  struct termios v13; // [sp+0h] [bp-44h] BYREF

  v5 = open64("/dev/datum", 2, a3);
  if ( v5 < 0 )
  {
    v10 = 0;
    sub_64E00(3, "Datum_PTS: open(\"%s\", O_RDWR) failed: %m", "/dev/datum");
  }
  else
  {
    v6 = sub_63BA4(0, 0x60u, 0, 1);
    v6[2] = a1;
    v6[1] = v5;
    *((_QWORD *)v6 + 10) = 0;
    v6[8] = 0;
    if ( fcntl(v5, 4, 0) == -1 )
      sub_64E00(3, "MSF_ARCRON(%d): fcntl(F_SETFL, 0): %m.", a1);
    memset(&v13.c_oflag, 0, 0x38u);
    v13.c_cc[5] = 30;
    v7 = v6[1];
    v13.c_iflag = 1;
    v13.c_cflag = 2493;
    if ( tcsetattr(v7, 0, &v13) < 0 )
    {
      v10 = 0;
      sub_64E00(3, "Datum_PTS: tcsetattr(\"%s\") failed: %m", "/dev/datum");
      close(v6[1]);
      free(v6);
    }
    else
    {
      v8 = *(int **)(a2 + 84);
      v9 = v6[1];
      *v6 = a2;
      v8[5] = a2;
      v8[3] = (int)sub_42FF0;
      v8[6] = 0;
      v8[7] = v9;
      v10 = sub_18DF0(v8 + 2);
      if ( v10 )
      {
        v10 = 1;
        v11 = dword_BCD58;
        **(_DWORD **)(a2 + 84) = v6;
        dword_BCD58 = v11 + 1;
      }
      else
      {
        v8[7] = -1;
        sub_64E00(3, "Datum_PTS: Problem adding clock");
        close(v6[1]);
        free(v6);
      }
    }
  }
  return v10;
}
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// BCD58: using guessed type int dword_BCD58;

//----- (000434DC) --------------------------------------------------------
void __fastcall sub_434DC(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (0004355C) --------------------------------------------------------
int __fastcall sub_4355C(int a1, int a2)
{
  int v3; // r9
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  _DWORD *v6; // r6
  int v7; // r8
  struct tm *v8; // r0
  int tm_min; // r1
  int tm_hour; // r2
  int tm_mday; // r3
  int tm_year; // r1
  int tm_wday; // r2
  int tm_yday; // r3
  int tm_gmtoff; // r1
  const char *tm_zone; // r2
  time_t timer; // [sp+4h] [bp-20h] BYREF
  char v19[20]; // [sp+8h] [bp-1Ch] BYREF

  sub_6C054((int)v19, 0x14u, "/dev/dumbclock%d", a1);
  v3 = sub_3A298(v19, 0xDu, 0);
  if ( v3 <= 0 )
    return 0;
  v4 = sub_63BA4(0, 0x3Cu, 0, 1);
  v5 = *(_DWORD **)(a2 + 84);
  v6 = v4;
  *v5 = v4;
  v5[5] = a2;
  v5[7] = v3;
  v5[3] = sub_436C0;
  v5[6] = 0;
  v7 = sub_18DF0(v5 + 2);
  if ( !v7 )
  {
    close(v3);
    v5[7] = -1;
    free(v6);
    *v5 = 0;
    return v7;
  }
  time(&timer);
  v8 = localtime(&timer);
  if ( !v8 )
    return 0;
  tm_min = v8->tm_min;
  tm_hour = v8->tm_hour;
  tm_mday = v8->tm_mday;
  v7 = 1;
  v6[4] = v8->tm_sec;
  v6[5] = tm_min;
  v6[6] = tm_hour;
  v6[7] = tm_mday;
  tm_year = v8->tm_year;
  tm_wday = v8->tm_wday;
  tm_yday = v8->tm_yday;
  v6[8] = v8->tm_mon;
  v6[9] = tm_year;
  v6[10] = tm_wday;
  v6[11] = tm_yday;
  tm_gmtoff = v8->tm_gmtoff;
  tm_zone = v8->tm_zone;
  v6[12] = v8->tm_isdst;
  v6[13] = tm_gmtoff;
  v6[14] = tm_zone;
  *(_BYTE *)(a2 + 95) = -13;
  v5[191] = *(_DWORD *)"dumbclock";
  v5[11] = "Dumb clock";
  return v7;
}

//----- (000436C0) --------------------------------------------------------
__int16 *__fastcall sub_436C0(int a1)
{
  int v1; // r7
  unsigned __int8 **v2; // r8
  unsigned __int8 *v3; // r4
  const char *v4; // r5
  __int16 *result; // r0
  int v6; // r3
  bool v7; // zf
  __int16 **v8; // r4
  __int16 *v9; // r1
  unsigned __int8 *v10; // r3
  unsigned __int8 *v11; // r0
  unsigned __int8 *v12; // r1
  __int16 *v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r12
  struct tm *v17; // r0
  int tm_min; // r1
  int tm_hour; // r2
  int tm_mday; // r3
  int tm_year; // r1
  int tm_wday; // r2
  int tm_yday; // r3
  int tm_gmtoff; // r1
  const char *tm_zone; // r2
  struct tm *v26; // r0
  struct tm *v27; // r6
  int v28; // r0
  unsigned __int8 *v29; // r1
  __int64 v30; // r2
  unsigned __int8 *v31; // r1
  int v32; // [sp+Ch] [bp-4Ch] BYREF
  int v33; // [sp+10h] [bp-48h] BYREF
  int v34; // [sp+14h] [bp-44h] BYREF
  time_t v35; // [sp+18h] [bp-40h] BYREF
  time_t timer; // [sp+1Ch] [bp-3Ch] BYREF
  __int16 *v37; // [sp+20h] [bp-38h] BYREF
  __int16 *v38; // [sp+24h] [bp-34h]
  struct tm tp; // [sp+28h] [bp-30h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(unsigned __int8 ***)(v1 + 84);
  v4 = (const char *)(v2 + 14);
  v3 = *v2;
  result = (__int16 *)sub_39EE4(a1, (bool *)v2 + 56, 128, &v37);
  if ( result )
  {
    v10 = (unsigned __int8 *)(unsigned __int16)result;
    v11 = (unsigned __int8 *)*((_DWORD *)v3 + 1);
    v12 = (unsigned __int8 *)*((_DWORD *)v3 + 2);
    v2[46] = v10;
    v2[58] = v11;
    v2[59] = v12;
    v13 = v38;
    *((_DWORD *)v3 + 1) = v37;
    *((_DWORD *)v3 + 2) = v13;
    *v3 = 1;
    result = (__int16 *)sscanf(v4, "%02d:%02d:%02d", &v32, &v33, &v34);
    if ( result == (__int16 *)((char *)&dword_0 + 3) )
    {
      memset(&tp.tm_isdst, 0, 12);
      tp.tm_yday = 0;
      tp.tm_wday = 0;
      v14 = *((_DWORD *)v3 + 7);
      v15 = *((_DWORD *)v3 + 8);
      v16 = *((_DWORD *)v3 + 9);
      tp.tm_isdst = -1;
      tp.tm_mon = v15;
      tp.tm_mday = v14;
      tp.tm_hour = v32;
      tp.tm_min = v33;
      tp.tm_year = v16;
      tp.tm_sec = v34;
      v35 = mktime(&tp);
      time(&timer);
      if ( v35 - timer > 3600 )
      {
        v35 -= 86400;
      }
      else if ( v35 - timer < -3600 )
      {
        v35 += 86400;
      }
      v17 = localtime(&v35);
      if ( !v17 )
        return sub_394A0((__int16 *)v1, 3);
      tm_min = v17->tm_min;
      tm_hour = v17->tm_hour;
      tm_mday = v17->tm_mday;
      *((_DWORD *)v3 + 4) = v17->tm_sec;
      *((_DWORD *)v3 + 5) = tm_min;
      *((_DWORD *)v3 + 6) = tm_hour;
      *((_DWORD *)v3 + 7) = tm_mday;
      tm_year = v17->tm_year;
      tm_wday = v17->tm_wday;
      tm_yday = v17->tm_yday;
      *((_DWORD *)v3 + 8) = v17->tm_mon;
      *((_DWORD *)v3 + 9) = tm_year;
      *((_DWORD *)v3 + 10) = tm_wday;
      *((_DWORD *)v3 + 11) = tm_yday;
      tm_gmtoff = v17->tm_gmtoff;
      tm_zone = v17->tm_zone;
      *((_DWORD *)v3 + 12) = v17->tm_isdst;
      *((_DWORD *)v3 + 13) = tm_gmtoff;
      *((_DWORD *)v3 + 14) = tm_zone;
      v26 = gmtime(&v35);
      v27 = v26;
      if ( v26 )
      {
        v28 = sub_6EC68(v26->tm_year + 1900, v26->tm_mon + 1, v26->tm_mday);
        v29 = (unsigned __int8 *)v27->tm_hour;
        LODWORD(v30) = v27->tm_min;
        HIDWORD(v30) = v27->tm_sec;
        v2[48] = (unsigned __int8 *)v28;
        v2[49] = v29;
        *((_QWORD *)v2 + 25) = v30;
        if ( sub_39CF8(v2) )
        {
          v31 = v2[59];
          v2[56] = v2[58];
          v2[57] = v31;
          sub_39D44(v1);
          result = (__int16 *)sub_41F44((unsigned __int16 *)(v1 + 16), v4);
          v3[12] = (unsigned __int8)v2[49];
        }
        else
        {
          return sub_394A0((__int16 *)v1, 6);
        }
      }
      else
      {
        return sub_394A0((__int16 *)v1, 3);
      }
    }
    else if ( v3[13] )
    {
      --v3[13];
    }
    else
    {
      return sub_394A0((__int16 *)v1, 2);
    }
  }
  else
  {
    v6 = *v3;
    v7 = v6 == 0;
    if ( *v3 )
      *v3 = 0;
    else
      LOBYTE(v6) = 1;
    if ( v7 )
    {
      *v3 = v6;
      v8 = (__int16 **)(v3 + 4);
      result = v37;
      v9 = v38;
      *v8 = v37;
      v8[1] = v9;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00043928) --------------------------------------------------------
unsigned int __fastcall sub_43928(int a1, int a2)
{
  int v3; // r4

  v3 = *(_DWORD *)(a2 + 84);
  if ( write(*(_DWORD *)(v3 + 28), &unk_B6DD4, 0x1Au) == 26 )
    ++*(_DWORD *)(v3 + 776);
  else
    sub_394A0((__int16 *)a2, 3);
  return sub_41F44((unsigned __int16 *)(a2 + 16), (const char *)(v3 + 56));
}

//----- (000439BC) --------------------------------------------------------
void __fastcall sub_439BC(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (00043A3C) --------------------------------------------------------
__int16 *__fastcall sub_43A3C(__int16 *result)
{
  int v1; // r6
  int v2; // r4
  _DWORD *v3; // r1
  __int16 *v4; // r5
  unsigned __int8 *v5; // r2
  int v6; // t1
  int v7; // r3
  int v8; // r0
  int v9; // r3
  int v10; // r7
  char *v11; // lr
  int v12; // r12
  int v13; // r8
  int v14; // r9
  unsigned int v15; // r10
  int *v16; // r5
  _DWORD *v17; // r7
  int v18; // r0
  int v19; // r1
  _DWORD *v20; // r4
  int v21; // r1
  __int16 *v22; // r0
  int v23; // r1
  int v24; // r0
  int v25; // r0
  unsigned __int8 *v26; // [sp+14h] [bp-10h]

  v1 = *((_DWORD *)result + 1);
  v2 = *(_DWORD *)(v1 + 84);
  v3 = *(_DWORD **)v2;
  if ( !**(_DWORD **)v2 )
  {
    *v3 = 1;
    return result;
  }
  v4 = result;
  if ( *((int *)result + 21) <= 23 )
  {
    v22 = (__int16 *)*((_DWORD *)result + 1);
    v23 = 2;
    return sub_394A0(v22, v23);
  }
  v5 = (unsigned __int8 *)(result + 44);
  if ( *((_BYTE *)result + 88) != 16 )
  {
    do
      v6 = *++v5;
    while ( v6 != 16 );
  }
  v7 = 10 * (v5[2] >> 4) + (v5[2] & 0xF);
  *(_DWORD *)(v2 + 188) = v7;
  if ( v7 == 94 )
  {
    sub_394A0((__int16 *)v1, 2);
    result = (__int16 *)write(*(_DWORD *)(v2 + 28), &unk_B6DF0, 0x1Au);
    if ( result == (_WORD *)&off_18 + 1 )
      return result;
    v22 = (__int16 *)v1;
    v23 = 3;
    return sub_394A0(v22, v23);
  }
  v8 = v3[2];
  if ( v7 <= 98 )
    v7 += 100;
  v9 = v7 + 1900;
  v26 = (unsigned __int8 *)v3[2];
  *(_DWORD *)(v2 + 188) = v9;
  v10 = 100 * (v5[3] & 0xF) + 10 * (v5[4] >> 4) + (v5[4] & 0xF);
  *(_DWORD *)(v2 + 192) = v10;
  if ( v8 > 10 )
  {
    v24 = 10 * (v5[6] >> 4) + (v5[6] & 0xF);
    *(_DWORD *)(v2 + 196) = v24;
    if ( v24 == 10 )
    {
      v11 = (char *)&unk_F4240;
      v12 = 10 * (v5[7] >> 4) + (v5[7] & 0xF);
      *(_DWORD *)(v2 + 200) = v12;
      *(_DWORD *)(v2 + 204) = 10 * (v5[8] >> 4) + (v5[8] & 0xF);
      v25 = (_DWORD)&unk_F4240 * (10 * (v5[9] >> 4) + (v5[9] & 0xF));
      *(_DWORD *)(v2 + 208) = v25;
      *(_DWORD *)(v2 + 208) = v25 + 1000 * (v5[10] >> 4);
LABEL_21:
      v9 = *(_DWORD *)(v2 + 188);
      if ( v12 == 10 )
        v5 = v26;
      else
        v11 = byte_9 + 1;
      v10 = *(_DWORD *)(v2 + 192);
      if ( v12 == 10 )
      {
        v11 = byte_9 + 1;
        v13 = *(_DWORD *)(v2 + 204);
        ++v5;
      }
      else
      {
        v13 = *(_DWORD *)(v2 + 204);
      }
      if ( v12 == 10 )
        v3[2] = v5;
      goto LABEL_12;
    }
  }
  else
  {
    *(_DWORD *)(v2 + 196) = 10 * (v5[5] >> 4) + (v5[5] & 0xF);
  }
  v11 = (char *)(10 * (v5[5] >> 4) + (v5[5] & 0xF));
  *(_DWORD *)(v2 + 196) = v11;
  v12 = 10 * (v5[6] >> 4) + (v5[6] & 0xF);
  *(_DWORD *)(v2 + 200) = v12;
  v13 = 10 * (v5[7] >> 4) + (v5[7] & 0xF);
  *(_DWORD *)(v2 + 204) = v13;
  v14 = (_DWORD)&unk_F4240 * (10 * (v5[8] >> 4) + (v5[8] & 0xF));
  *(_DWORD *)(v2 + 208) = v14;
  v15 = v5[9];
  v5 = (_BYTE *)(elf_hash_bucket + 556);
  *(_DWORD *)(v2 + 208) = v14 + 1000 * (v15 >> 4);
  if ( v11 == &byte_9[1] )
    goto LABEL_21;
LABEL_12:
  v16 = (int *)(v4 + 36);
  sub_6C054(v2 + 56, 0x80u, "%d %d %d %d %d", v9, v10, v11, v12, v13);
  v17 = (_DWORD *)(v2 + 232);
  *(_DWORD *)(v2 + 184) = strlen((const char *)(v2 + 56));
  v18 = *v16;
  v19 = v16[1];
  *(_QWORD *)(v2 + 248) = 0x3EE4F8B588E368F1LL;
  *(_DWORD *)(v2 + 232) = v18;
  *(_DWORD *)(v2 + 236) = v19;
  if ( !sub_39CF8((_DWORD *)v2) )
    sub_394A0((__int16 *)v1, 6);
  v20 = (_DWORD *)(v2 + 224);
  v21 = v17[1];
  *v20 = *v17;
  v20[1] = v21;
  return (__int16 *)sub_39D44(v1);
}
// 18: using guessed type _UNKNOWN *;
// 1BC: using guessed type int elf_hash_bucket[521];
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00043D9C) --------------------------------------------------------
int __fastcall sub_43D9C(int a1, int a2)
{
  int v3; // r10
  int v4; // r9
  _DWORD *v5; // r0
  _DWORD *v6; // r7
  int v7; // r4
  int v8; // r0
  char v10[20]; // [sp+0h] [bp-18h] BYREF

  sub_6C054((int)v10, 0x14u, "/dev/fgclock%d", a1);
  v3 = sub_3A298(v10, 0xDu, 1);
  if ( v3 <= 0 )
    return 0;
  v5 = sub_63BA4(0, 0xCu, 0, 0);
  *v5 = 0;
  v6 = v5;
  v5[1] = 0;
  v5[2] = 0;
  v7 = *(_DWORD *)(a2 + 84);
  *(_DWORD *)v7 = v5;
  *(_DWORD *)(v7 + 20) = a2;
  *(_DWORD *)(v7 + 24) = 0;
  *(_DWORD *)(v7 + 28) = v3;
  *(_DWORD *)(v7 + 12) = sub_43A3C;
  v4 = sub_18DF0((int *)(v7 + 8));
  if ( v4 )
  {
    *(_BYTE *)(a2 + 95) = -10;
    *(_DWORD *)(v7 + 44) = "Forum Graphic GPS dating station";
    *(_WORD *)(v7 + 764) = 20551;
    *(_BYTE *)(v7 + 766) = 83;
    v8 = *(_DWORD *)(v7 + 28);
    *v6 = 0;
    v4 = 1;
    if ( write(v8, &unk_B6DF0, 0x1Au) != 26 )
      sub_394A0((__int16 *)a2, 3);
  }
  else
  {
    close(v3);
    *(_DWORD *)(v7 + 28) = -1;
  }
  return v4;
}

//----- (00043F08) --------------------------------------------------------
unsigned __int64 __fastcall sub_43F08(unsigned __int8 *a1, unsigned __int8 **a2)
{
  int v3; // r11
  unsigned __int8 *v4; // r3
  unsigned int v5; // r9
  unsigned __int64 v6; // r10
  unsigned __int64 v7; // r4
  const unsigned __int16 *v8; // r12
  unsigned __int8 *v9; // r0
  _BOOL4 v10; // lr
  int v11; // r3
  int v12; // r1
  unsigned __int8 *v13; // r3
  int *v14; // r0
  int *v16; // r0
  unsigned __int8 *v17; // [sp+0h] [bp-24h]
  unsigned __int8 *v18; // [sp+Ch] [bp-18h]

  v3 = *a1;
  if ( v3 == 45 )
  {
    v5 = 2;
    v18 = a1 + 1;
    v6 = 0x8000000000000000LL;
  }
  else
  {
    if ( v3 == 43 )
      v4 = a1 + 1;
    else
      v4 = a1;
    v5 = 0;
    v6 = 0x7FFFFFFFFFFFFFFFLL;
    v18 = v4;
  }
  v7 = 0;
  v8 = *_ctype_b_loc();
  v9 = v18;
  while ( 1 )
  {
    v12 = *v9;
    v13 = v9++;
    if ( (v8[v12] & 0x800) == 0 )
      break;
    v10 = v7 > 0xCCCCCCCCCCCCCCCLL;
    v7 = 10 * v7 + v12 - 48;
    if ( v6 < v7 )
      v11 = v10 | 1;
    else
      v11 = v10;
    v5 |= v11;
  }
  if ( v18 == v13 )
  {
    v16 = _errno_location();
    v13 = a1;
    *v16 = 22;
  }
  if ( (v5 & 1) != 0 )
  {
    v17 = v13;
    v7 = v6;
    v14 = _errno_location();
    v13 = v17;
    *v14 = 34;
  }
  *a2 = v13;
  if ( ((v7 != 0) & (v5 >> 1)) != 0 )
    return -(__int64)v7;
  else
    return v7;
}

//----- (000440B0) --------------------------------------------------------
int __fastcall sub_440B0(double a1, int a2, _DWORD *a3)
{
  int v4; // r6
  _DWORD *v5; // r4
  double v6; // d0
  int v7; // r2
  double v8; // r0
  int v9; // r2
  double v10; // d0
  __int64 v11; // r0
  int v12; // r3
  int v13; // r2
  int v14; // r2
  bool v15; // zf
  int v16; // r3
  int v17; // r2
  int v18; // r1
  char v19; // r3
  __int64 v20; // r0
  __int64 v21; // r0
  __int64 v22; // r0

  v4 = a3[21];
  v5 = *(_DWORD **)v4;
  v6 = *(double *)(v4 + 744);
  v7 = *(_DWORD *)(*(_DWORD *)v4 + 8);
  if ( (_DWORD *)v7 == a3 )
  {
    LODWORD(a1) = 32;
    ldexp(a1, v7);
    if ( v6 < 0.0 )
    {
      LODWORD(v22) = sub_8C010(-v6);
      v11 = -v22;
    }
    else
    {
      LODWORD(v11) = sub_8C010(v6);
    }
    v5[30] = v11;
    v5[29] = HIDWORD(v11);
    if ( (*(_BYTE *)(v4 + 768) & 1) == 0 )
      a3[17] &= ~0x80u;
  }
  else
  {
    LODWORD(a1) = 32;
    ldexp(a1, v7);
    if ( v6 < 0.0 )
    {
      LODWORD(v20) = sub_8C010(-v6);
      *(_QWORD *)&v8 = -v20;
    }
    else
    {
      LODWORD(v8) = sub_8C010(v6);
    }
    v10 = *(double *)(v4 + 752);
    v5[28] = LODWORD(v8);
    v5[27] = HIDWORD(v8);
    LODWORD(v8) = 32;
    ldexp(v8, v9);
    if ( v10 < 0.0 )
    {
      LODWORD(v21) = sub_8C010(-v10);
      v11 = -v21;
    }
    else
    {
      LODWORD(v11) = sub_8C010(v10);
    }
    v12 = a3[19];
    v13 = v5[4];
    v5[31] = HIDWORD(v11);
    v5[32] = v11;
    if ( ((v13 ^ v12) & 3) != 0 )
    {
      v14 = v13 & 3;
      v15 = v14 == 2;
      v16 = v12 & 3;
      if ( v14 == 2 )
        LODWORD(v11) = 0;
      v17 = *(_DWORD *)a3[21];
      if ( v15 )
      {
        BYTE4(v11) = *(_BYTE *)(v17 + 132);
        *(_DWORD *)(v17 + 72) = v11;
        *(_BYTE *)(v17 + 132) = BYTE4(v11) & 0xEF;
      }
      v18 = *(_BYTE *)(v17 + 132) & 0xF9;
      *(_BYTE *)(v17 + 132) = v18;
      if ( v16 == 2 )
        v18 = 30;
      v5[4] = v16;
      if ( v16 == 2 )
      {
        v19 = *(_BYTE *)(v17 + 132);
        *(_DWORD *)(v17 + 72) = v18;
        *(_BYTE *)(v17 + 132) = v19 & 0xEF;
      }
      *(_BYTE *)(v17 + 132) &= 0xF9u;
    }
  }
  return v11;
}
// 44110: variable 'v8' is possibly undefined
// 44124: variable 'v9' is possibly undefined
// 44138: variable 'v11' is possibly undefined
// 441E0: variable 'v20' is possibly undefined
// 44238: variable 'v21' is possibly undefined
// 44258: variable 'v22' is possibly undefined

//----- (0004426C) --------------------------------------------------------
void __fastcall sub_4426C(int a1, int a2)
{
  int **v2; // r5
  int *v3; // r4
  int v5; // r0
  int *v6; // r1
  int *v7; // r3
  int v8; // r2
  bool v9; // zf
  const char *v10; // r2

  v2 = *(int ***)(a2 + 84);
  v3 = *v2;
  if ( !*v2 )
    return;
  if ( v3[2] != a2 )
  {
    if ( v2[7] == (int *)-1 )
    {
      v5 = v3[34];
      if ( v5 == -1 )
        goto LABEL_5;
    }
    else
    {
      sub_18E64((int)(v2 + 2));
      v5 = v3[34];
      v2[7] = (int *)-1;
      if ( v5 == -1 )
        goto LABEL_5;
    }
    close(v5);
  }
LABEL_5:
  v9 = v3[1]-- == 1;
  if ( v9 )
  {
    v6 = &dword_BCD5C;
    v7 = (int *)dword_BCD5C;
    while ( v7 )
    {
      v8 = *v7;
      v9 = v3 == v7;
      if ( v3 != v7 )
        v6 = v7;
      v7 = (int *)*v7;
      if ( v9 )
        *v6 = v8;
    }
    free((void *)v3[5]);
    free((void *)v3[6]);
    free(v3);
  }
  *v2 = 0;
  if ( (ntp_syslogmask & 0x100) != 0 )
  {
    v10 = sub_6A3FC((unsigned __int16 *)(a2 + 16));
    sub_64E00(5, "%s: shutdown", v10);
  }
}
// B7CD4: using guessed type int ntp_syslogmask;
// BCD5C: using guessed type int dword_BCD5C;

//----- (000443C4) --------------------------------------------------------
int __fastcall sub_443C4(__int16 *a1, _DWORD *a2, int a3, unsigned int a4)
{
  int v5; // lr
  int v6; // r12

  v5 = a2[54];
  v6 = a2[55];
  a2[56] = a3;
  a2[57] = a4;
  if ( v5 == v6 )
    sub_394A0(a1, 0);
  return sub_39A70(a2, a3, a4);
}

//----- (00044468) --------------------------------------------------------
int __fastcall sub_44468(int a1, const char *a2)
{
  size_t v2; // r4
  size_t v4; // r0
  const void *v5; // r1
  size_t v6; // r1

  v2 = (size_t)a2;
  if ( a2 )
  {
    v4 = strlen(a2);
    v5 = (const void *)v2;
    if ( v4 >= 0x7F )
      v2 = 127;
    else
      v2 = v4;
    memcpy((void *)(a1 + 56), v5, v2);
    v6 = v2;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(a1 + 184) = v6;
  *(_BYTE *)(a1 + v2 + 56) = 0;
  return 0;
}

//----- (000444F8) --------------------------------------------------------
int __fastcall sub_444F8(int a1, int a2)
{
  int v2; // r3
  int v3; // r1
  int v4; // r3
  int v5; // r5
  int v7; // r2
  int v8; // r4

  v2 = 5 * a2;
  v3 = a2 + 1;
  v4 = a1 + 4 * v2;
  v5 = *(_DWORD *)(a1 + 4);
  v7 = *(_DWORD *)(v4 + 8);
  v8 = *(_DWORD *)(v4 + 20);
  if ( v7 == 1 )
  {
    v8 *= 2;
  }
  else if ( v7 != 2 )
  {
    goto LABEL_3;
  }
  for ( ; v8; --v8 )
  {
    if ( v3 >= 0 && v5 > v3 )
      v3 = sub_444F8(a1);
  }
LABEL_3:
  if ( v3 >= 0 && v5 >= v3 )
    return v3;
  return v5;
}

//----- (000445B0) --------------------------------------------------------
int *__fastcall sub_445B0(int *result, const char *a2, unsigned __int8 *a3, int a4)
{
  unsigned __int8 *v4; // r5
  unsigned __int8 *v6; // r8
  char *v7; // r4
  bool v8; // zf
  int v9; // r7
  int v10; // t1
  const char *v11; // r2
  const char *v12; // r3
  int v13; // t1
  unsigned __int8 *v14; // r0
  char v15; // r3
  int v16; // t1
  int v17; // [sp+8h] [bp-1Ch]
  _BYTE v18[8]; // [sp+14h] [bp-10h] BYREF

  v4 = a3;
  if ( debug > 1 )
  {
    v6 = &a3[a4];
    v7 = byte_BCD60;
    v17 = *result;
    while ( 1 )
    {
LABEL_3:
      v8 = v6 == v4;
      if ( v6 != v4 )
        v8 = v7 == (char *)&unk_BD55F;
      if ( v8 )
        break;
      v10 = *v4++;
      v9 = v10;
      if ( v10 == 92 )
      {
        v11 = "\\\\";
        v12 = (const char *)(&byte_BCD60[(_DWORD)"\\\\" + 2046] - v7);
        while ( 1 )
        {
          *v7++ = v9;
          if ( v11 == v12 )
            break;
          v13 = *(unsigned __int8 *)++v11;
          LOBYTE(v9) = v13;
          if ( !v13 )
            goto LABEL_3;
        }
        v7 = (char *)&unk_BD55F;
      }
      else if ( ((*_ctype_b_loc())[v9] & 0x4000) != 0 )
      {
        *v7++ = v9;
      }
      else
      {
        sub_6C054((int)v18, 6u, "\\%03o", v9);
        v14 = v18;
        do
        {
          v16 = *v14++;
          v15 = v16;
          if ( !v16 )
            break;
          *v7++ = v15;
        }
        while ( v7 != (char *)&unk_BD55F );
      }
    }
    *v7 = 0;
    return (int *)sub_64D28("%s[%s]: '%s'\n", *(const char **)(v17 + 20), a2, byte_BCD60);
  }
  return result;
}
// 108D74: using guessed type int debug;

//----- (0004475C) --------------------------------------------------------
int __fastcall sub_4475C(int a1)
{
  _DWORD *v2; // r5
  int v3; // r0
  int result; // r0
  int v5; // r0
  int v6; // r0
  char *v7; // r1
  int v8; // r3
  bool v9; // zf
  int v10; // r3
  const char *v11; // r2
  int v12; // r2
  int v13; // r3
  int v14; // r3
  bool v15; // zf
  const char *v16; // r2
  int optval; // [sp+8h] [bp-10h] BYREF
  struct pollfd optlen; // [sp+Ch] [bp-Ch] BYREF

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 136);
  optlen.events = 4;
  optlen.fd = v3;
  result = poll(&optlen, 1u, 0);
  if ( result != 1 || (optlen.revents & 4) == 0 )
    return result;
  v2[36] = 10;
  optlen.fd = 4;
  v5 = v2[34];
  optval = 0;
  v9 = getsockopt(v5, 1, 4, &optval, (socklen_t *)&optlen) == -1;
  v6 = optval;
  if ( v9 )
  {
    if ( !optval )
    {
      v6 = *_errno_location();
      optval = v6;
    }
  }
  else if ( !optval )
  {
    *(_DWORD *)(a1 + 28) = v2[34];
    v2[34] = -1;
    result = sub_18DF0((int *)(a1 + 8));
    if ( result )
      return result;
    if ( (*(_BYTE *)(a1 + 768) & 4) != 0 )
      goto LABEL_23;
    v14 = v2[45];
    v15 = v14 == 3600;
    if ( v14 != 3600 )
      v15 = v14 == 0;
    if ( v15 )
    {
LABEL_23:
      v16 = (const char *)v2[5];
      v2[45] = 3600;
      sub_64E00(3, "%s: failed to register with I/O engine", v16);
    }
    goto LABEL_12;
  }
  v7 = strerror(v6);
  if ( (*(_BYTE *)(a1 + 768) & 4) != 0 )
    goto LABEL_11;
  v8 = v2[45];
  v9 = v8 == 3600;
  if ( v8 != 3600 )
    v9 = v8 == 0;
  if ( v9 )
  {
LABEL_11:
    v10 = v2[34];
    v11 = (const char *)v2[5];
    v2[45] = 3600;
    sub_64E00(3, "%s: async connect to GPSD failed, fd=%d, ec=%d(%s)", v11, v10, optval, v7);
  }
LABEL_12:
  result = v2[34];
  if ( result != -1 )
    result = close(result);
  v12 = v2[37];
  v2[34] = -1;
  v13 = v12 + 5;
  v2[36] = v12;
  if ( (unsigned int)(v12 + 5) >= 0x78 )
    v13 = 120;
  v2[37] = v13;
  return result;
}

//----- (00044920) --------------------------------------------------------
void __fastcall sub_44920(int a1, int a2)
{
  int *v2; // r5
  int v3; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r6
  int v9; // r2
  int v10; // r1
  int v11; // r0
  int v12; // r0
  int v13; // r3
  bool v14; // zf
  const char *v15; // r2
  int v16; // r0
  int v17; // r0
  int v18; // r2
  int v19; // r3
  int v20; // r3
  int v21; // r3
  int v23; // r3
  bool v24; // zf
  int v25; // r1
  char v26; // r3
  int v27; // r2
  char v28; // r3
  int v29; // r3
  bool v30; // zf
  const char *v31; // r2
  int v32; // r0
  int v33; // r3
  bool v34; // zf
  const char *v35; // r2
  int v36; // r3
  bool v37; // zf
  const char *v38; // r2
  int v39; // r3
  bool v40; // zf
  const char *v41; // r2
  int v42; // [sp+8h] [bp-Ch] BYREF

  v2 = *(int **)(a2 + 84);
  v3 = *v2;
  if ( *(_DWORD *)(*v2 + 8) == a2 )
  {
    v20 = *(_DWORD *)(v3 + 76);
    if ( v20 < 1 )
      v20 = 1;
    v21 = v20 - 1;
    *(_DWORD *)(v3 + 76) = v21;
    if ( !v21 )
    {
      if ( v2[54] != v2[55] )
      {
        sub_394A0((__int16 *)a2, 1);
        v2[54] = v2[55];
      }
      *(_DWORD *)(a2 + 68) &= ~0x80u;
    }
    return;
  }
  v4 = *(_DWORD *)(v3 + 180);
  if ( v4 )
    *(_DWORD *)(v3 + 180) = v4 - 1;
  v5 = *(_DWORD *)(v3 + 144);
  if ( v5 )
  {
    v6 = v5 - 1;
    *(_DWORD *)(v3 + 144) = v6;
    if ( v6 )
    {
      v14 = v6 == 4;
      v7 = v2[7];
      if ( v14 )
      {
        if ( v7 != -1 )
        {
          sub_445B0(v2, "send", "?VERSION;\r\n", 11);
          write(v2[7], "?VERSION;\r\n", 0xBu);
          return;
        }
LABEL_9:
        if ( *(_DWORD *)(v3 + 136) == -1 )
          return;
        goto LABEL_10;
      }
      if ( v7 == -1 )
        goto LABEL_9;
      return;
    }
  }
  if ( v2[7] != -1 )
  {
    if ( (v2[192] & 4) != 0 )
      goto LABEL_45;
    v23 = *(_DWORD *)(v3 + 180);
    v24 = v23 == 0;
    if ( v23 )
      v24 = v23 == 3600;
    if ( v24 )
    {
LABEL_45:
      *(_DWORD *)(v3 + 180) = 3600;
      sub_64E00(6, "%s: closing socket to GPSD, fd=%d", *(const char **)(v3 + 20), v2[7]);
    }
    sub_18E64((int)(v2 + 2));
    v25 = *(_DWORD *)(v3 + 148);
    v2[7] = -1;
    v26 = *(_BYTE *)(v3 + 132);
    v27 = v25 + 5;
    *(_DWORD *)(v3 + 144) = v25;
    v28 = v26 & 0xD9;
    if ( (unsigned int)(v25 + 5) >= 0x78 )
      v27 = 120;
    *(_DWORD *)(v3 + 148) = v27;
    *(_BYTE *)(v3 + 132) = v28 & 0xBF;
    return;
  }
  if ( *(_DWORD *)(v3 + 136) != -1 )
  {
LABEL_10:
    sub_4475C((int)v2);
    return;
  }
  if ( dword_BD560 )
  {
    v8 = *(_DWORD *)(v3 + 140);
    if ( !v8 )
      v8 = dword_BD560;
    v9 = *(_DWORD *)(v8 + 12);
    v10 = *(_DWORD *)(v8 + 8);
    v11 = *(_DWORD *)(v8 + 4);
    *(_DWORD *)(v3 + 140) = *(_DWORD *)(v8 + 28);
    v12 = socket(v11, v10, v9);
    *(_DWORD *)(v3 + 136) = v12;
    if ( v12 == -1 )
    {
      if ( (v2[192] & 4) == 0 )
      {
        v13 = *(_DWORD *)(v3 + 180);
        v14 = v13 == 3600;
        if ( v13 != 3600 )
          v14 = v13 == 0;
        if ( !v14 )
        {
          v16 = v2[7];
          if ( v16 == -1 )
          {
LABEL_28:
            v18 = *(_DWORD *)(v3 + 148);
            v2[7] = -1;
            *(_DWORD *)(v3 + 136) = -1;
            v19 = v18 + 5;
            *(_DWORD *)(v3 + 144) = v18;
            if ( (unsigned int)(v18 + 5) >= 0x78 )
              v19 = 120;
            *(_DWORD *)(v3 + 148) = v19;
            return;
          }
LABEL_25:
          close(v16);
LABEL_26:
          v17 = *(_DWORD *)(v3 + 136);
          if ( v17 != -1 )
            close(v17);
          goto LABEL_28;
        }
      }
      v15 = *(const char **)(v3 + 20);
      *(_DWORD *)(v3 + 180) = 3600;
      sub_64E00(3, "%s: cannot create GPSD socket: %m", v15);
    }
    else if ( fcntl(v12, 4, 2048, 1) == -1 )
    {
      if ( (v2[192] & 4) != 0 )
        goto LABEL_55;
      v29 = *(_DWORD *)(v3 + 180);
      v30 = v29 == 3600;
      if ( v29 != 3600 )
        v30 = v29 == 0;
      if ( v30 )
      {
LABEL_55:
        v31 = *(const char **)(v3 + 20);
        *(_DWORD *)(v3 + 180) = 3600;
        sub_64E00(3, "%s: cannot set GPSD socket to non-blocking: %m", v31);
      }
    }
    else
    {
      v32 = *(_DWORD *)(v3 + 136);
      v42 = 1;
      if ( setsockopt(v32, 6, 1, &v42, 4u) == -1 )
      {
        if ( (v2[192] & 4) != 0 )
          goto LABEL_79;
        v39 = *(_DWORD *)(v3 + 180);
        v40 = v39 == 0;
        if ( v39 )
          v40 = v39 == 3600;
        if ( v40 )
        {
LABEL_79:
          v41 = *(const char **)(v3 + 20);
          *(_DWORD *)(v3 + 180) = 3600;
          sub_64E00(6, "%s: cannot disable TCP nagle: %m", v41);
        }
      }
      if ( connect(*(_DWORD *)(v3 + 136), *(const struct sockaddr **)(v8 + 20), *(_DWORD *)(v8 + 16)) == -1 )
      {
        if ( *_errno_location() == 115 )
          return;
        if ( (v2[192] & 4) != 0 )
          goto LABEL_64;
        v33 = *(_DWORD *)(v3 + 180);
        v34 = v33 == 0;
        if ( v33 )
          v34 = v33 == 3600;
        if ( v34 )
        {
LABEL_64:
          v35 = *(const char **)(v3 + 20);
          *(_DWORD *)(v3 + 180) = 3600;
          sub_64E00(3, "%s: cannot connect GPSD socket: %m", v35);
        }
      }
      else
      {
        v2[7] = *(_DWORD *)(v3 + 136);
        *(_DWORD *)(v3 + 136) = -1;
        if ( sub_18DF0(v2 + 2) )
          return;
        if ( (v2[192] & 4) != 0 )
          goto LABEL_71;
        v36 = *(_DWORD *)(v3 + 180);
        v37 = v36 == 3600;
        if ( v36 != 3600 )
          v37 = v36 == 0;
        if ( v37 )
        {
LABEL_71:
          v38 = *(const char **)(v3 + 20);
          *(_DWORD *)(v3 + 180) = 3600;
          sub_64E00(3, "%s: failed to register with I/O engine", v38);
        }
      }
    }
    v16 = v2[7];
    if ( v16 == -1 )
      goto LABEL_26;
    goto LABEL_25;
  }
}
// BD560: using guessed type int dword_BD560;

//----- (00044D5C) --------------------------------------------------------
const char *sub_44D5C()
{
  const char *result; // r0
  int v1; // r4
  char **v2; // r5
  const char *v3; // r1
  const char *v4; // t1
  struct addrinfo s; // [sp+4h] [bp-24h] BYREF

  dword_BD564[0] = 0;
  dword_BD568 = 0;
  dword_BD56C = 0;
  dword_BD570 = 0;
  result = (const char *)memset(&s, 0, sizeof(s));
  v1 = dword_BD560;
  s.ai_socktype = 1;
  s.ai_protocol = 6;
  if ( dword_BD560 )
  {
    v1 = 0;
  }
  else
  {
    v2 = off_B46C4;
    v3 = "gpsd";
    result = "localhost";
    while ( 1 )
    {
      result = (const char *)getaddrinfo(result, v3, &s, (struct addrinfo **)&dword_BD560);
      dword_BD564[v1] = (int)result;
      if ( !result )
        break;
      v4 = v2[2];
      v2 += 2;
      result = v4;
      ++v1;
      dword_BD560 = 0;
      if ( !v4 )
        break;
      v3 = v2[1];
    }
  }
  dword_BD574 = v1;
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B46C4: using guessed type char *off_B46C4[6];
// BD560: using guessed type int dword_BD560;
// BD564: using guessed type int dword_BD564[];
// BD568: using guessed type int dword_BD568;
// BD56C: using guessed type int dword_BD56C;
// BD570: using guessed type int dword_BD570;
// BD574: using guessed type int dword_BD574;

//----- (00044E70) --------------------------------------------------------
__int16 *__fastcall sub_44E70(int a1, int a2)
{
  int v3; // r5
  _DWORD *v4; // r4
  int v5; // r1
  int v6; // r8
  int v7; // r3
  int v8; // r1
  __int16 *result; // r0
  int v10; // r1
  _DWORD *v11; // r3
  _DWORD *v12; // r5
  int v13; // r1
  int v14; // r3

  v3 = *(_DWORD *)(a2 + 84);
  v4 = *(_DWORD **)v3;
  v5 = *(_DWORD *)(v3 + 216);
  v6 = *(_DWORD *)(*(_DWORD *)v3 + 8);
  ++*(_DWORD *)(v3 + 776);
  v7 = *(_DWORD *)(v3 + 220);
  if ( v6 == a2 )
  {
    if ( v7 == v5 )
    {
      v14 = *(_DWORD *)(v6 + 68);
      *(_BYTE *)(v6 + 95) = -20;
      *(_DWORD *)(v6 + 68) = v14 & 0xFFFFFF7F;
      return sub_394A0((__int16 *)v6, 1);
    }
    else
    {
      v11 = (_DWORD *)(v3 + 232);
      v12 = (_DWORD *)(v3 + 224);
      v13 = v11[1];
      *v12 = *v11;
      v12[1] = v13;
      sub_394A0((__int16 *)v6, 0);
      return (__int16 *)sub_39D44(v6);
    }
  }
  else
  {
    if ( v7 == v5 )
    {
      *(_BYTE *)(a2 + 95) = -9;
      if ( *(_DWORD *)(v3 + 28) == -1 )
      {
        result = sub_394A0((__int16 *)a2, 3);
      }
      else
      {
        if ( v4[39] )
          v8 = 2;
        else
          v8 = 1;
        result = sub_394A0((__int16 *)a2, v8);
      }
    }
    else
    {
      v10 = *(_DWORD *)(v3 + 236);
      *(_DWORD *)(v3 + 224) = *(_DWORD *)(v3 + 232);
      *(_DWORD *)(v3 + 228) = v10;
      sub_394A0((__int16 *)a2, 0);
      result = (__int16 *)sub_39D44(a2);
    }
    if ( (*(_BYTE *)(v3 + 768) & 8) != 0 )
      result = (__int16 *)sub_42050(
                            (unsigned __int16 *)(a2 + 16),
                            "%u %u %u %u %u %u %u",
                            v4[38],
                            v4[39],
                            v4[40],
                            v4[41],
                            v4[42],
                            v4[43],
                            v4[44]);
    v4[39] = 0;
    v4[38] = 0;
    v4[40] = 0;
    v4[41] = 0;
    v4[42] = 0;
    v4[43] = 0;
    v4[44] = 0;
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00045034) --------------------------------------------------------
unsigned int sub_45034(void **a1, int a2, ...)
{
  size_t v3; // r4
  void *i; // r0
  unsigned int result; // r0
  void *v6; // r0
  va_list varg_r2; // [sp+28h] [bp+1Ch] BYREF

  va_start(varg_r2, a2);
  v3 = 32;
  for ( i = 0; ; i = *a1 )
  {
    v3 *= 2;
    free(i);
    v6 = malloc(v3);
    *a1 = v6;
    if ( !v6 )
      break;
    result = sub_6B6F8((int)v6, v3, "%s%u", (int *)varg_r2);
    if ( v3 > result )
      return result;
  }
  return -1;
}

//----- (000450E4) --------------------------------------------------------
bool __fastcall sub_450E4(int a1, int a2)
{
  int v2; // r7
  int v3; // r6
  int v4; // r4
  const char *v5; // r6
  const char *v6; // r11
  int v7; // r7
  const char *v8; // r0
  _BOOL4 v9; // r5
  int *v10; // r10
  _DWORD *v11; // r4
  int v12; // r11
  int v13; // r3
  const char *v14; // r0
  void *v15; // r0
  int v16; // r2
  int v17; // r1
  char v18; // r3
  int v19; // r3
  int v20; // r2
  char v21; // r3
  int v23; // r5
  const char *v24; // r0
  void *v26; // r0
  int v28; // [sp+10h] [bp-7Ch]
  _BYTE v30[16]; // [sp+18h] [bp-74h] BYREF
  int v31; // [sp+28h] [bp-64h]

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 84);
  if ( !dword_BD574 )
  {
    v9 = dword_BD560 != 0;
    goto LABEL_7;
  }
  if ( dword_BD574 <= 0 )
  {
    v23 = dword_BD560;
    if ( dword_BD560 )
      goto LABEL_34;
LABEL_38:
    sub_64E00(3, (unsigned __int8 *)"%s", "GPSD_JSON: failed to get socket address, giving up.");
    v23 = dword_BD560;
    goto LABEL_34;
  }
  v4 = 0;
  v28 = *(_DWORD *)(a2 + 84);
  v5 = "gpsd";
  v6 = "localhost";
  while ( 1 )
  {
    v7 = dword_BD564[v4++];
    v8 = gai_strerror(v7);
    sub_64E00(4, "GPSD_JSON: failed to resolve '%s:%s', rc=%d (%s)", v6, v5, v7, v8);
    if ( v4 >= dword_BD574 )
      break;
    v6 = off_B46C4[2 * v4];
    v5 = off_B46C4[2 * v4 + 1];
  }
  v3 = v28;
  v2 = a2;
  if ( !dword_BD560 )
    goto LABEL_38;
  sub_64E00(
    4,
    "GPSD_JSON: using '%s:%s' instead of '%s:%s'",
    off_B46C4[2 * v4],
    off_B46C4[2 * v4 + 1],
    "localhost",
    "gpsd");
  v23 = dword_BD560;
LABEL_34:
  v9 = v23 != 0;
  dword_BD574 = 0;
LABEL_7:
  if ( !v9 )
    return v9;
  v10 = &dword_BCD5C;
  v11 = (_DWORD *)dword_BCD5C;
  v12 = a1 & 0x7F;
  if ( dword_BCD5C )
  {
    if ( v12 == *(_DWORD *)(dword_BCD5C + 12) )
    {
LABEL_17:
      ++v11[1];
      goto LABEL_18;
    }
    while ( 1 )
    {
      v10 = v11;
      v11 = (_DWORD *)*v11;
      if ( !v11 )
        break;
      if ( v11[3] == v12 )
        goto LABEL_17;
    }
  }
  v11 = sub_63BA4(0, 0x225Cu, 0, 1);
  v13 = v11[1];
  *v10 = (int)v11;
  v11[1] = v13 + 1;
  v14 = sub_6A3FC((unsigned __int16 *)(v2 + 16));
  v15 = sub_63D08(v14);
  v11[37] = 10;
  v11[5] = v15;
  v16 = dword_BD560;
  v11[3] = v12;
  v11[34] = -1;
  v11[35] = v16;
  if ( sub_45034((void **)v11 + 6, (int)"%s%u", "/dev/gps", v12) == -1 )
  {
    sub_64E00(3, "%s: clock device name too long", (const char *)v11[5]);
  }
  else
  {
    if ( _xstat64(3, v11[6], v30) != -1 && (v31 & 0xF000) == 0x2000 )
    {
LABEL_18:
      v17 = -1;
      *(_DWORD *)v3 = v11;
      *(_DWORD *)(v3 + 20) = v2;
      *(_DWORD *)(v3 + 12) = sub_460C4;
      *(_DWORD *)(v3 + 24) = 0;
      *(_BYTE *)(v3 + 56) = 0;
      *(_DWORD *)(v3 + 184) = 0;
      if ( a1 <= 127 )
        v18 = -9;
      else
        v18 = -20;
      *(_DWORD *)(v3 + 764) = *(_DWORD *)"GPSD";
      *(_DWORD *)(v3 + 28) = -1;
      *(_DWORD *)(v3 + 44) = "GPSD JSON client clock";
      *(_BYTE *)(v2 + 95) = v18;
      if ( v11[35] )
      {
        if ( (ntp_syslogmask & 0x100) != 0 )
        {
          v24 = sub_6A3FC((unsigned __int16 *)(v2 + 16));
          sub_64E00(5, "%s: startup, device is '%s'", v24, (const char *)v11[6]);
        }
        v19 = *(_DWORD *)(v2 + 76) & 3;
        v11[4] = v19;
        if ( v19 == 3 )
        {
          v11[4] = 0;
          if ( a1 <= 127 )
          {
            v20 = **(_DWORD **)(v2 + 84);
LABEL_30:
            *(_BYTE *)(v20 + 132) &= 0xF9u;
            return v9;
          }
        }
        else if ( a1 <= 127 )
        {
          if ( v19 == 2 )
            v17 = 30;
          v20 = **(_DWORD **)(v2 + 84);
          if ( v19 == 2 )
          {
            v21 = *(_BYTE *)(v20 + 132);
            *(_DWORD *)(v20 + 72) = v17;
            *(_BYTE *)(v20 + 132) = v21 & 0xEF;
          }
          goto LABEL_30;
        }
        v11[2] = v2;
        return v9;
      }
      sub_64E00(3, "%s: no GPSD socket address, giving up", (const char *)v11[5]);
      goto LABEL_41;
    }
    sub_64E00(3, "%s: '%s' is not a character device", (const char *)v11[5], (const char *)v11[6]);
  }
LABEL_41:
  if ( v11[1]-- == 1 )
  {
    v26 = (void *)v11[6];
    *v10 = *v11;
    free(v26);
    free(v11);
  }
  v9 = 0;
  *(_DWORD *)v3 = 0;
  return v9;
}
// 45390: variable 'v17' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// B46C4: using guessed type char *off_B46C4[6];
// B7CD4: using guessed type int ntp_syslogmask;
// BCD5C: using guessed type int dword_BCD5C;
// BD560: using guessed type int dword_BD560;
// BD564: using guessed type int dword_BD564[];
// BD574: using guessed type int dword_BD574;

//----- (00045590) --------------------------------------------------------
int __fastcall sub_45590(_DWORD *a1, char *s1, int a3)
{
  int v4; // r8
  int v5; // r0
  int v6; // r9
  int v9; // r10
  _DWORD *v10; // r3

  v4 = a1[1];
  if ( v4 <= 0 )
    return -1;
  v5 = a1[2];
  if ( v5 != 1 )
    return -1;
  v6 = a1[5];
  if ( !v6 || v4 <= 2 )
    return -1;
  v9 = 2;
  while ( 1 )
  {
    v10 = &a1[5 * v5];
    if ( v10[2] == 3 )
      break;
    if ( v4 <= v5 )
      goto LABEL_7;
    v5 = sub_444F8((int)a1, v5);
    if ( v5 < 0 )
      return -1;
    if ( v4 <= v5 )
      goto LABEL_7;
    v5 = sub_444F8((int)a1, v5);
LABEL_12:
    if ( v5 < 0 )
      return -1;
LABEL_7:
    if ( --v6 )
    {
      v9 = v5 + 1;
      if ( v4 > v5 + 1 )
        continue;
    }
    return -1;
  }
  if ( strcmp(s1, (const char *)(*a1 + v10[3])) )
  {
    v5 = sub_444F8((int)a1, v9);
    goto LABEL_12;
  }
  if ( a1[5 * v9 + 2] != a3 )
    return -1;
  return v9;
}

//----- (000456C0) --------------------------------------------------------
unsigned __int64 __fastcall sub_456C0(_DWORD *a1, char *a2)
{
  int v3; // r0
  unsigned __int8 *v4; // r4
  unsigned __int64 v5; // r2
  int *v6; // r0
  unsigned __int8 *v8; // [sp+0h] [bp-Ch] BYREF

  v3 = sub_45590(a1, a2, 0);
  if ( v3 == -1 || (v4 = (unsigned __int8 *)(*a1 + a1[5 * v3 + 3])) == 0 )
  {
    v6 = _errno_location();
    v5 = 0;
    *v6 = 22;
  }
  else
  {
    v5 = sub_43F08(v4, &v8);
    if ( v4 == v8 || *v8 )
      return 0;
  }
  return v5;
}

//----- (00045784) --------------------------------------------------------
int __fastcall sub_45784(_DWORD *a1, _DWORD *a2, char *a3, char *a4, int a5)
{
  int v9; // r4
  int *v10; // r11
  int v11; // r7
  int v12; // r0
  int v13; // r1
  int v14; // r0
  int v15; // r2
  bool v16; // cc

  v9 = 0;
  v10 = _errno_location();
  *v10 = 0;
  v11 = sub_456C0(a2, a3);
  v12 = sub_456C0(a2, a4);
  if ( !*v10 )
  {
    v13 = v12 * a5;
    v14 = v11;
    if ( v13 < 0 )
    {
      do
      {
        v13 += 1000000000;
        --v14;
      }
      while ( v13 < 0 );
    }
    else if ( v13 > 999999999 )
    {
      v15 = v13 - 1000000000;
      v16 = v13 - 1000000000 <= 999999999;
      if ( v13 - 1000000000 <= 999999999 )
        v14 = v11 + 1;
      else
        v13 -= 2013265920;
      if ( v16 )
        v13 = v15;
      else
        v13 += 13238272;
      if ( !v16 )
      {
        v14 += 2;
        v13 += 27648;
      }
    }
    v9 = 1;
    *a1 = v14 - 2085978496;
    a1[1] = sub_8BFD0(__PAIR64__(v13, 0) + 500000000, 0x3B9ACA00u);
  }
  return v9;
}

//----- (000458B8) --------------------------------------------------------
int __fastcall sub_458B8(_DWORD *a1, char *a2)
{
  int result; // r0
  int v4; // r3
  int v5; // r3

  result = sub_45590(a1, a2, 0);
  if ( result != -1 )
  {
    v4 = a1[5 * result + 3];
    if ( *a1 + v4 )
    {
      v5 = *(unsigned __int8 *)(*a1 + v4);
      if ( v5 == 102 )
      {
        return 0;
      }
      else if ( v5 == 116 )
      {
        return 1;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return -1;
    }
  }
  return result;
}

//----- (0004594C) --------------------------------------------------------
int __fastcall sub_4594C(_DWORD *a1, char *a2, int a3)
{
  int v5; // r0
  unsigned __int8 *v6; // r6
  int result; // r0
  unsigned __int8 *v8; // [sp+0h] [bp-Ch] BYREF

  v5 = sub_45590(a1, a2, 0);
  if ( v5 == -1 )
    return a3;
  v6 = (unsigned __int8 *)(*a1 + a1[5 * v5 + 3]);
  if ( !v6 )
    return a3;
  result = sub_43F08(v6, &v8);
  if ( v6 == v8 || *v8 )
    return a3;
  return result;
}

//----- (000459F4) --------------------------------------------------------
int __fastcall sub_459F4(int *a1, int a2, unsigned int a3, int a4, unsigned int a5)
{
  int v5; // lr
  int v6; // r4
  unsigned int v7; // r12
  int v8; // r10
  int v9; // r12
  int v10; // r6
  int v11; // r12
  int v12; // r4
  int v13; // r4
  int v14; // r7
  unsigned int v15; // r4
  int v16; // r12
  int v17; // r5
  int v18; // t1
  unsigned int v19; // r9
  unsigned int v20; // r5
  bool v21; // cc
  int v23; // r12
  int v24; // r1
  int v25; // r2
  int j; // r3
  int v27; // r4
  int v28; // r5
  _DWORD *i; // r12
  int v30; // r12
  int v31; // r4
  unsigned int v32; // r12
  int v33; // r5
  unsigned int v34; // t1
  unsigned int v35; // r12
  int v36; // r5
  int v37; // r6
  _DWORD *v38; // r7
  unsigned int v39; // r5
  int v40; // r6
  _DWORD *v41; // r4
  bool v42; // zf
  int v43; // r6
  int v44; // r4
  unsigned int v45; // r4
  int v46; // lr
  int v47; // r5
  _DWORD *v48; // r4

  v5 = *a1;
  v6 = 0;
  if ( a3 > *a1 )
  {
    v7 = *(unsigned __int8 *)(a2 + v5);
    if ( *(_BYTE *)(a2 + v5) )
    {
      v8 = 0;
      while ( 1 )
      {
        if ( v7 == 44 )
        {
          v9 = *a1;
          if ( a4 && (unsigned int)(*(_DWORD *)(a4 + 20 * a1[2]) - 1) > 1 )
            a1[2] = *(_DWORD *)(a4 + 20 * a1[2] + 16);
LABEL_8:
          v5 = v9 + 1;
          *a1 = v9 + 1;
          if ( v9 + 1 >= a3 )
            goto LABEL_41;
          goto LABEL_9;
        }
        if ( v7 > 0x2C )
        {
          if ( v7 != 93 )
          {
            if ( v7 <= 0x5D )
            {
              if ( v7 == 58 )
              {
                v9 = *a1;
                a1[2] = a1[1] - 1;
                goto LABEL_8;
              }
              if ( v7 != 91 )
              {
LABEL_63:
                v31 = *a1;
                if ( a3 > *a1 )
                {
                  v32 = *(unsigned __int8 *)(a2 + v31);
                  v33 = a2 + v31;
                  if ( *(_BYTE *)(a2 + v31) )
                  {
                    while ( v32 != 32 )
                    {
                      if ( v32 <= 0x20 )
                      {
                        if ( v32 >= 9 && (v32 <= 0xA || v32 == 13) )
                          break;
                      }
                      else
                      {
                        if ( v32 == 58 )
                          break;
                        if ( v32 > 0x3A )
                        {
                          if ( v32 == 93 || v32 == 125 )
                            break;
                        }
                        else if ( v32 == 44 )
                        {
                          break;
                        }
                      }
                      if ( v32 - 32 > 0x5E )
                      {
LABEL_35:
                        v6 = -2;
                        *a1 = v5;
                        return v6;
                      }
                      *a1 = ++v31;
                      if ( a3 != v31 )
                      {
                        v34 = *(unsigned __int8 *)++v33;
                        v32 = v34;
                        if ( v34 )
                          continue;
                      }
                      break;
                    }
                  }
                }
                if ( a4 )
                {
                  v35 = a1[1];
                  if ( a5 <= v35 )
                    goto LABEL_110;
                  v36 = a1[2];
                  v37 = 5 * v35;
                  v38 = (_DWORD *)(a4 + 20 * v35);
                  a1[1] = v35 + 1;
                  v38[3] = 0;
                  v9 = v31 - 1;
                  *(_DWORD *)(a4 + 4 * v37) = 0;
                  ++v8;
                  v38[1] = v5;
                  if ( v36 != -1 )
                    v5 = 5 * v36;
                  v38[2] = v31;
                  if ( v36 != -1 )
                    v5 = a4 + 4 * v5;
                  v38[4] = v36;
                  *a1 = v9;
                  if ( v36 != -1 )
                    ++*(_DWORD *)(v5 + 12);
                }
                else
                {
                  v9 = v31 - 1;
                  ++v8;
                }
                goto LABEL_8;
              }
LABEL_91:
              ++v8;
              if ( a4 )
              {
                v39 = a1[1];
                if ( a5 <= v39 )
                  return -1;
                v40 = a1[2];
                v41 = (_DWORD *)(a4 + 20 * v39);
                a1[1] = v39 + 1;
                v41[2] = -1;
                v41[1] = -1;
                v41[3] = 0;
                v41[4] = -1;
                if ( v40 != -1 )
                {
                  ++*(_DWORD *)(a4 + 20 * v40 + 12);
                  v41[4] = v40;
                }
                v42 = v7 == 123;
                v9 = *a1;
                if ( v42 )
                  v43 = 1;
                else
                  v43 = 2;
                *(_DWORD *)(a4 + 20 * v39) = v43;
                v41[1] = v5;
                a1[2] = v39;
                goto LABEL_8;
              }
              goto LABEL_39;
            }
            if ( v7 == 123 )
              goto LABEL_91;
            if ( v7 != 125 )
              goto LABEL_63;
          }
          if ( a4 )
          {
            v27 = a1[1];
            if ( v7 == 125 )
              v28 = 1;
            else
              v28 = 2;
            if ( !v27 )
              return -2;
            for ( i = (_DWORD *)(a4 + 20 * v27 - 20); i[1] == -1 || i[2] != -1; i = (_DWORD *)(a4 + 20 * v30) )
            {
              v30 = i[4];
              if ( v30 == -1 )
              {
                v23 = *a1;
                goto LABEL_40;
              }
            }
            if ( *i != v28 )
              return -2;
            v44 = i[4];
            i[2] = v5 + 1;
            v9 = *a1;
            a1[2] = v44;
            goto LABEL_8;
          }
        }
        else if ( v7 != 13 )
        {
          if ( v7 <= 0xD )
          {
            if ( v7 - 9 > 1 )
              goto LABEL_63;
          }
          else if ( v7 != 32 )
          {
            if ( v7 != 34 )
              goto LABEL_63;
            v10 = v5 + 1;
            *a1 = v5 + 1;
            v11 = v5 + 1;
            if ( a3 <= v5 + 1 || (v12 = *(unsigned __int8 *)(a2 + v10), !*(_BYTE *)(a2 + v10)) )
            {
LABEL_34:
              *a1 = v5;
              return -3;
            }
            while ( v12 != 34 )
            {
              if ( v12 == 92 && (v13 = v11 + 1, a3 > v11 + 1) )
              {
                *a1 = v13;
                v14 = a2 + v13;
                switch ( *(_BYTE *)(a2 + v13) )
                {
                  case '"':
                  case '/':
                  case '\\':
                  case 'b':
                  case 'f':
                  case 'n':
                  case 'r':
                  case 't':
                    goto LABEL_20;
                  case 'u':
                    v15 = v11 + 2;
                    v16 = v11 + 6;
                    *a1 = v15;
                    break;
                  default:
                    goto LABEL_35;
                }
                do
                {
                  if ( a3 == v15 )
                    break;
                  v18 = *(unsigned __int8 *)++v14;
                  v17 = v18;
                  if ( !v18 )
                    break;
                  v19 = v17 & 0xFFFFFFDF;
                  v20 = v17 - 48;
                  v19 -= 65;
                  v21 = v19 > 5;
                  if ( v19 > 5 )
                    v21 = v20 > 9;
                  if ( v21 )
                    goto LABEL_35;
                  *a1 = ++v15;
                }
                while ( v15 != v16 );
                v11 = v15;
                *a1 = v15;
                if ( a3 <= v15 )
                  goto LABEL_34;
              }
              else
              {
                v13 = *a1;
LABEL_20:
                v11 = v13 + 1;
                *a1 = v13 + 1;
                if ( a3 <= v13 + 1 )
                  goto LABEL_34;
              }
              v12 = *(unsigned __int8 *)(a2 + v11);
              if ( !*(_BYTE *)(a2 + v11) )
                goto LABEL_34;
            }
            if ( a4 )
            {
              v45 = a1[1];
              if ( a5 <= v45 )
              {
LABEL_110:
                *a1 = v5;
                return -1;
              }
              v46 = a1[2];
              v47 = 5 * v45;
              a1[1] = v45 + 1;
              v48 = (_DWORD *)(a4 + 20 * v45);
              v48[3] = 0;
              ++v8;
              *(_DWORD *)(a4 + 4 * v47) = 3;
              v48[1] = v10;
              v48[2] = v11;
              v48[4] = v46;
              if ( v46 != -1 )
              {
                v9 = *a1;
                ++*(_DWORD *)(a4 + 20 * v46 + 12);
                goto LABEL_8;
              }
            }
            else
            {
              ++v8;
            }
          }
        }
LABEL_39:
        v23 = *a1;
LABEL_40:
        v5 = v23 + 1;
        *a1 = v23 + 1;
        if ( v23 + 1 >= a3 )
        {
LABEL_41:
          v6 = v8;
          break;
        }
LABEL_9:
        v7 = *(unsigned __int8 *)(a2 + v5);
        if ( !*(_BYTE *)(a2 + v5) )
          goto LABEL_41;
      }
    }
  }
  if ( a4 )
  {
    v24 = a1[1];
    v25 = v24 - 1;
    if ( v24 - 1 >= 0 )
    {
      for ( j = a4 + 20 * v24; *(_DWORD *)(j - 16) == -1 || *(_DWORD *)(j - 12) != -1; j -= 20 )
      {
        if ( --v25 == -1 )
          return v6;
      }
      return -3;
    }
  }
  return v6;
}

//----- (00046070) --------------------------------------------------------
_DWORD *__fastcall sub_46070(_DWORD *result)
{
  result[1] = 0;
  result[2] = -1;
  *result = 0;
  return result;
}

//----- (000460C4) --------------------------------------------------------
int __fastcall sub_460C4(int a1)
{
  double v1; // d0
  unsigned __int8 *v3; // r8
  unsigned __int8 *v4; // r2
  int *v5; // r0
  int v6; // r4
  int v7; // r5
  int v8; // r2
  unsigned __int8 *v9; // r11
  _BYTE *v10; // r3
  _BYTE *v11; // r9
  bool v12; // zf
  unsigned int v13; // r2
  unsigned int v14; // t1
  _BYTE *v15; // r2
  unsigned int v16; // t1
  int v17; // r7
  _BYTE *v18; // r2
  _DWORD *v19; // r3
  int v20; // r4
  int v21; // r10
  int v22; // r0
  int v23; // r3
  int v25; // r3
  int v26; // r2
  int v27; // r1
  int v28; // r0
  int v29; // r3
  int v30; // r2
  int v31; // r10
  int v32; // r2
  int v33; // r10
  int v34; // r0
  const char *v35; // r3
  int v36; // r2
  double v38; // r0
  int *v39; // r2
  const char *v40; // r7
  __int16 v41; // r3
  int v42; // r3
  int *v43; // r10
  int v44; // r6
  char v45; // r2
  int v46; // r1
  int v47; // r6
  char v48; // r3
  int v49; // r1
  int v50; // r2
  int v51; // r2
  int v52; // r1
  _DWORD *v53; // r6
  int v54; // r0
  int v55; // r10
  int v56; // r3
  int v57; // r0
  int *v58; // r6
  unsigned __int16 v59; // r0
  int v60; // r6
  unsigned int v61; // r6
  char v62; // r3
  char v63; // r1
  char v64; // r3
  char v65; // r2
  char v66; // r3
  char v67; // r6
  const char *v68; // r2
  size_t v69; // r6
  int v70; // r3
  bool v71; // zf
  const char *v72; // r2
  int v73; // r2
  const char *v74; // r2
  int v75; // r2
  int v76; // r2
  int v77; // r7
  int v78; // r3
  int v79; // r3
  int v80; // r2
  int v81; // r10
  int v82; // r2
  unsigned int v83; // r2
  unsigned int v84; // lr
  int v85; // r12
  int v86; // r3
  int v87; // r0
  int v88; // r1
  const char *v89; // r0
  int v90; // r0
  const char *v91; // r0
  int *v92; // r3
  int v93; // r6
  unsigned __int8 *v94; // r0
  unsigned __int8 *v95; // r2
  int v96; // r0
  int v97; // r1
  char v98; // r2
  int v99; // r3
  bool v100; // zf
  const char *v101; // r2
  int v102; // r0
  int v103; // r2
  int v104; // lr
  int v105; // r0
  int v106; // r1
  unsigned int v107; // r12
  int v108; // r7
  unsigned int v109; // r1
  int v110; // r0
  int v111; // lr
  unsigned int v112; // r1
  int v113; // r7
  int v114; // lr
  unsigned int v115; // r2
  int v116; // r0
  int v117; // r1
  int v118; // r12
  int v119; // r3
  int v120; // r2
  int v121; // lr
  int v122; // r7
  const char *v123; // r0
  const char *v124; // r2
  signed __int64 v125; // r0
  int v126; // r3
  int v127; // r0
  unsigned int v128; // r12
  int v129; // r1
  int v130; // r1
  int v131; // lr
  unsigned int v132; // r0
  bool v133; // cf
  unsigned int v134; // r0
  int v135; // r1
  int v136; // r3
  char v137; // r2
  const unsigned __int16 **v138; // r0
  unsigned int v139; // r12
  const unsigned __int16 *v140; // lr
  int v141; // t1
  int v142; // [sp+10h] [bp-64h]
  int v143; // [sp+14h] [bp-60h]
  unsigned int v144; // [sp+18h] [bp-5Ch]
  int v145; // [sp+18h] [bp-5Ch]
  int v146; // [sp+18h] [bp-5Ch]
  _DWORD *v147; // [sp+18h] [bp-5Ch]
  int v148; // [sp+18h] [bp-5Ch]
  const char *v149; // [sp+18h] [bp-5Ch]
  int *v150; // [sp+18h] [bp-5Ch]
  int v151; // [sp+18h] [bp-5Ch]
  int v152; // [sp+1Ch] [bp-58h]
  _DWORD *v153; // [sp+24h] [bp-50h]
  int v154; // [sp+28h] [bp-4Ch]
  int *v155; // [sp+34h] [bp-40h]
  int v156; // [sp+34h] [bp-40h]
  const char *v157; // [sp+34h] [bp-40h]
  int v158; // [sp+34h] [bp-40h]
  unsigned __int8 *v159; // [sp+34h] [bp-40h]
  int v160; // [sp+38h] [bp-3Ch]
  const char *v161; // [sp+38h] [bp-3Ch]
  unsigned __int16 v162; // [sp+3Ch] [bp-38h]
  char *v163[11]; // [sp+40h] [bp-34h] BYREF

  v3 = (unsigned __int8 *)(a1 + 88);
  v4 = (unsigned __int8 *)(a1 + 88);
  v143 = *(_DWORD *)(a1 + 4);
  v5 = *(int **)(v143 + 84);
  v6 = *v5 + 4096;
  v152 = *v5;
  v142 = v6;
  v7 = *v5 + 7196;
  sub_445B0(v5, "recv", v4, *(_DWORD *)(a1 + 84));
  v8 = *(_DWORD *)(a1 + 84);
  v9 = &v3[v8];
  v10 = (_BYTE *)(v7 + *(_DWORD *)(v6 + 3096));
  if ( v3 != &v3[v8] )
  {
    v11 = v10 + 1599;
    v154 = a1;
    do
    {
      while ( 1 )
      {
        v14 = *v3++;
        v13 = v14;
        if ( v14 != 10 )
        {
          if ( v11 != v10 )
          {
            v12 = v13 == 32;
            if ( v13 <= 0x20 )
              v12 = v7 == (_DWORD)v10;
            if ( !v12 )
              *v10++ = v13;
          }
          goto LABEL_8;
        }
        if ( (_BYTE *)v7 != v10 && (unsigned __int8)*(v10 - 1) <= 0x20u )
        {
          v15 = v10 - 1;
          do
          {
            v10 = v15;
            if ( v15 == (_BYTE *)v7 )
              break;
            v16 = (unsigned __int8)*--v15;
          }
          while ( v16 <= 0x20 );
        }
        v17 = 0;
        v18 = &v10[-v7];
        *v10 = 0;
        v19 = *(_DWORD **)(v143 + 84);
        *(_DWORD *)(v142 + 3096) = v18;
        v20 = *v19;
        v153 = v19;
        v21 = *v19 + 7196;
        v144 = *(_DWORD *)(*v19 + 7192);
        sub_46070(v163);
        v22 = sub_459F4((int *)v163, v20 + 7196, v144, v20 + 192, 0x15Eu);
        if ( v22 > 0 )
        {
          v23 = *(_DWORD *)(v20 + 192);
          *(_DWORD *)(v20 + 184) = v21;
          *(_DWORD *)(v20 + 188) = v22;
          if ( v23 == 1 )
          {
            v25 = v20;
            do
            {
              v26 = *(_DWORD *)(v25 + 200);
              ++v17;
              v27 = *(_DWORD *)(v25 + 196);
              v25 += 20;
              if ( v26 > v27 )
                *(_BYTE *)(*(_DWORD *)(v20 + 184) + v26) = 0;
            }
            while ( v17 < *(_DWORD *)(v20 + 188) );
            v28 = sub_45590((_DWORD *)(v20 + 184), "class", 3);
            if ( v28 != -1 )
            {
              v29 = *(_DWORD *)(v20 + 184);
              v30 = *(_DWORD *)(v20 + 20 * v28 + 196);
              v31 = v29 + v30;
              if ( v29 + v30 )
                break;
            }
          }
        }
        v10 = (_BYTE *)v7;
        ++*(_DWORD *)(v20 + 156);
        if ( v9 == v3 )
          goto LABEL_18;
      }
      v32 = *(unsigned __int8 *)(v29 + v30);
      if ( v32 == 84 )
      {
        if ( *(_BYTE *)(v31 + 1) != 80 || *(_BYTE *)(v31 + 2) != 86 || *(_BYTE *)(v31 + 3) )
          goto LABEL_69;
        v155 = *(int **)(v143 + 84);
        v33 = *v155;
        v145 = sub_4594C((_DWORD *)(v20 + 184), "mode", 0);
        v34 = sub_45590((_DWORD *)(v20 + 184), "time", 3);
        if ( v34 == -1 )
        {
          v36 = *(_BYTE *)(v33 + 133) & 1;
        }
        else
        {
          v36 = *(_BYTE *)(v33 + 133) & 1;
          v35 = (const char *)(*(_DWORD *)(v20 + 184) + *(_DWORD *)(v20 + 20 * v34 + 196));
          if ( v145 > 1 && v35 != 0 )
          {
            *(_BYTE *)(v33 + 132) &= ~1u;
            if ( !v36 )
            {
              v149 = v35;
              ++*(_DWORD *)(v33 + 164);
              sub_44468((int)v155, v35);
              v94 = (unsigned __int8 *)strptime(v149, "%Y-%m-%dT%H:%M:%S", v163);
              v95 = v94;
              if ( !v94 )
                goto LABEL_143;
              v96 = *v94;
              if ( v96 == 46 )
              {
                v159 = v95;
                v138 = _ctype_b_loc();
                v139 = 100000000;
                v140 = *v138;
                v97 = 0;
                v95 = v159;
                while ( 1 )
                {
                  v141 = *++v95;
                  v96 = v141;
                  if ( (v140[v141] & 0x800) == 0 )
                    break;
                  v97 += v139 * (v96 - 48);
                  v139 /= 0xAu;
                }
              }
              else
              {
                v97 = 0;
              }
              if ( v96 == 90 && !v95[1] )
              {
                v158 = v97;
                v151 = sub_663C0(v163);
                v125 = __PAIR64__(v158, sub_66604((int *)v163));
                v126 = v125 + (_DWORD)&off_15180 * (v151 - 693596);
                if ( v158 < 0 )
                {
                  do
                  {
                    HIDWORD(v125) += 1000000000;
                    --v126;
                  }
                  while ( v125 < 0 );
                }
                else if ( v158 > 999999999 )
                {
                  v127 = v126 + 1;
                  if ( v158 - 1000000000 <= 999999999 )
                  {
                    HIDWORD(v125) = v158 - 1000000000;
                  }
                  else
                  {
                    v126 += 2;
                    HIDWORD(v125) = v158 - 2000027648;
                  }
                  if ( v158 - 1000000000 <= 999999999 )
                    v126 = v127;
                  else
                    HIDWORD(v125) += 27648;
                }
                LODWORD(v125) = 500000000;
                *(_DWORD *)(v33 + 88) = v126;
                *(_DWORD *)(v33 + 92) = sub_8BFD0(v125, 0x3B9ACA00u);
                v128 = *(_DWORD *)(v33 + 128);
                v129 = *(_DWORD *)(v154 + 76);
                *(_DWORD *)(v33 + 80) = *(_DWORD *)(v154 + 72);
                *(_DWORD *)(v33 + 84) = v129;
                v130 = *(_DWORD *)(v154 + 76);
                v131 = *(_DWORD *)(v33 + 124);
                *(_DWORD *)(v33 + 96) = *(_DWORD *)(v154 + 72);
                *(_DWORD *)(v33 + 100) = v130;
                v132 = *(_DWORD *)(v33 + 100);
                v133 = v132 >= v128;
                v134 = v132 - v128;
                v135 = !v133;
                v136 = *(_DWORD *)(v33 + 96) - v131;
                v137 = *(_BYTE *)(v33 + 132) | 2;
                if ( v135 )
                  --v136;
                *(_DWORD *)(v33 + 100) = v134;
                *(_DWORD *)(v33 + 96) = v136;
                *(_BYTE *)(v33 + 132) = v137;
              }
              else
              {
LABEL_143:
                v98 = *(_BYTE *)(v33 + 132) & 0xFD;
                ++*(_DWORD *)(v33 + 156);
                *(_BYTE *)(v33 + 132) = v98;
              }
            }
            LODWORD(v38) = sub_45590((_DWORD *)(v20 + 184), "ept", 0);
            if ( LODWORD(v38) == -1
              || (v39 = *(int **)(v20 + 184), (v40 = (char *)v39 + *(_DWORD *)(v20 + 20 * LODWORD(v38) + 196)) == 0)
              || (v38 = strtod(v40, v163), v40 == v163[0])
              || *v163[0] )
            {
              v1 = 0.00141421356;
            }
            else
            {
              v1 = fabs(v1) * 0.70710678;
            }
            LODWORD(v38) = v163;
            frexp(v38, v39);
            if ( v1 < 0.25 )
              v163[0] = (char *)0x80000000;
            if ( v1 <= 2.0 )
            {
              v42 = (int)v163[0];
              if ( (int)v163[0] < -32 )
                v42 = -32;
              v41 = v42 & (v42 >> 31);
            }
            else
            {
              v41 = 0;
            }
            *(_WORD *)(v33 + 104) = v41;
            goto LABEL_56;
          }
        }
        if ( !v36 )
          v35 = (const char *)(*(_DWORD *)(v33 + 164) + 1);
        ++*(_DWORD *)(v33 + 160);
        if ( !v36 )
          *(_DWORD *)(v33 + 164) = v35;
        *(_BYTE *)(v33 + 132) = *(_BYTE *)(v33 + 132) & 0xF8 | 1;
      }
      else
      {
        if ( v32 != 80 || *(_BYTE *)(v31 + 1) != 80 || *(_BYTE *)(v31 + 2) != 83 || *(_BYTE *)(v31 + 3) )
        {
LABEL_69:
          v146 = *(_DWORD *)(v20 + 184);
          if ( !strcmp("TOFF", (const char *)v31) )
          {
            v81 = *(_DWORD *)(v143 + 84);
            v44 = *(_DWORD *)v81;
            v82 = *(_DWORD *)(*(_DWORD *)v81 + 164);
            v12 = (*(_BYTE *)(*(_DWORD *)v81 + 132) & 1) == 0;
            v148 = *(_BYTE *)(*(_DWORD *)v81 + 132) & 1;
            *(_BYTE *)(v44 + 133) = *(_BYTE *)(*(_DWORD *)v81 + 133) | 1;
            *(_DWORD *)(v44 + 164) = v82 + 1;
            if ( !v12 )
              goto LABEL_56;
            if ( !sub_45784((_DWORD *)(v44 + 96), (_DWORD *)(v20 + 184), "clock_sec", "clock_nsec", 1)
              || !sub_45784((_DWORD *)(v44 + 88), (_DWORD *)(v20 + 184), "real_sec", "real_nsec", 1) )
            {
LABEL_55:
              ++*(_DWORD *)(v44 + 156);
              goto LABEL_56;
            }
            v83 = *(_DWORD *)(v44 + 100);
            v84 = *(_DWORD *)(v44 + 128);
            v85 = *(_DWORD *)(v44 + 124);
            v86 = *(_DWORD *)(v44 + 96);
            v87 = v148;
            if ( v83 < v84 )
              v87 = 1;
            *(_DWORD *)(v44 + 100) = v83 - v84;
            *(_DWORD *)(v44 + 96) = v86 - v85 - v87;
            v88 = *(_DWORD *)(v154 + 76);
            *(_DWORD *)(v44 + 80) = *(_DWORD *)(v154 + 72);
            *(_DWORD *)(v44 + 84) = v88;
            *(_BYTE *)(v44 + 132) |= 2u;
            v89 = sub_69CA0((int *)(v44 + 88));
            sub_44468(v81, v89);
          }
          else if ( !strcmp("VERSION", (const char *)v31) )
          {
            v156 = v146;
            v53 = *(_DWORD **)(v143 + 84);
            v147 = v53;
            v54 = sub_45590((_DWORD *)(v20 + 184), "rev", 3);
            v55 = *v53;
            v56 = v156;
            if ( v54 == -1 )
              v157 = "(unknown)";
            else
              v157 = (const char *)(v156 + *(_DWORD *)(v20 + 20 * v54 + 196));
            v160 = v56;
            v57 = sub_45590((_DWORD *)(v20 + 184), "release", 3);
            if ( v57 == -1 )
              v161 = "(unknown)";
            else
              v161 = (const char *)(v160 + *(_DWORD *)(v20 + 20 * v57 + 196));
            v58 = _errno_location();
            *v58 = 0;
            v162 = sub_456C0((_DWORD *)(v20 + 184), "proto_major");
            v59 = sub_456C0((_DWORD *)(v20 + 184), "proto_minor");
            if ( *v58 )
            {
              if ( (v147[192] & 4) != 0 )
                goto LABEL_149;
              v99 = *(_DWORD *)(v55 + 180);
              v100 = v99 == 0;
              if ( v99 )
                v100 = v99 == 3600;
              if ( v100 )
              {
LABEL_149:
                v101 = *(const char **)(v55 + 20);
                *(_DWORD *)(v55 + 180) = 3600;
                sub_64E00(6, "%s: could not evaluate version data", v101);
              }
            }
            else
            {
              v60 = v59;
              if ( (*(_BYTE *)(v55 + 132) & 0x20) == 0 )
                sub_64E00(
                  6,
                  "%s: GPSD revision=%s release=%s protocol=%u.%u",
                  *(const char **)(v55 + 20),
                  v157,
                  v161,
                  v162,
                  v59);
              v61 = v60 | (v162 << 16);
              v62 = *(_BYTE *)(v55 + 132);
              v63 = *(_BYTE *)(v55 + 133);
              *(_DWORD *)(v55 + 28) = v61;
              v64 = v62 | 0x20;
              if ( v61 > (unsigned int)&loc_30008 )
                v65 = -1;
              else
                v65 = 0;
              v66 = v64 & 0x7F | ((v65 & 1) << 7);
              *(_BYTE *)(v55 + 132) = v66;
              if ( v61 > 0x30009 )
                v67 = -1;
              else
                v67 = 0;
              *(_BYTE *)(v55 + 133) = v63 & 0xFE | v67 & 1;
              if ( (v66 & 0x40) == 0 )
              {
                v68 = (*(_BYTE *)(v55 + 133) & 1) != 0 ? ",\"pps\":true" : byte_97F7C;
                sub_6C054(
                  v55 + 7196,
                  0x640u,
                  "?WATCH={\"device\":\"%s\",\"enable\":true,\"json\":true%s};\r\n",
                  *(const char **)(v55 + 24),
                  v68);
                v69 = strlen((const char *)(v55 + 7196));
                sub_445B0(*(int **)(v143 + 84), "send", (unsigned __int8 *)(v55 + 7196), v69);
                if ( v69 != write(v147[7], (const void *)(v55 + 7196), v69) )
                {
                  if ( (v147[192] & 4) != 0 )
                    goto LABEL_95;
                  v70 = *(_DWORD *)(v55 + 180);
                  v71 = v70 == 0;
                  if ( v70 )
                    v71 = v70 == 3600;
                  if ( v71 )
                  {
LABEL_95:
                    v72 = *(const char **)(v55 + 20);
                    *(_DWORD *)(v55 + 180) = 3600;
                    sub_64E00(3, "%s: failed to write watch request (%m)", v72);
                  }
                }
              }
            }
          }
          else
          {
            if ( strcmp("WATCH", (const char *)v31) )
              goto LABEL_72;
            v90 = sub_45590((_DWORD *)(v20 + 184), "device", 3);
            if ( v90 != -1 )
            {
              v91 = (const char *)(v146 + *(_DWORD *)(v20 + 20 * v90 + 196));
              if ( v91 )
              {
                v92 = *(int **)(v143 + 84);
                v93 = *v92;
                if ( !strcmp(v91, *(const char **)(*v92 + 24)) )
                {
                  if ( sub_458B8((_DWORD *)(v20 + 184), "enable") <= 0 || sub_458B8((_DWORD *)(v20 + 184), "json") <= 0 )
                    *(_BYTE *)(v93 + 132) &= ~0x40u;
                  else
                    *(_BYTE *)(v93 + 132) |= 0x40u;
                }
              }
            }
          }
          goto LABEL_56;
        }
        v43 = *(int **)(v143 + 84);
        v44 = *v43;
        v45 = *(_BYTE *)(*v43 + 132);
        ++*(_DWORD *)(*v43 + 172);
        if ( (v45 & 1) == 0 )
        {
          v46 = *(_DWORD *)(v154 + 76);
          *(_DWORD *)(v44 + 32) = *(_DWORD *)(v154 + 72);
          *(_DWORD *)(v44 + 36) = v46;
          if ( v45 < 0 )
          {
            if ( !sub_45784((_DWORD *)(v44 + 64), (_DWORD *)(v20 + 184), "clock_sec", "clock_nsec", 1) )
              goto LABEL_55;
            v150 = (int *)(v44 + 56);
            if ( !sub_45784((_DWORD *)(v44 + 56), (_DWORD *)(v20 + 184), "real_sec", "real_nsec", 1) )
              goto LABEL_55;
          }
          else
          {
            if ( !sub_45784((_DWORD *)(v44 + 64), (_DWORD *)(v20 + 184), "clock_sec", "clock_musec", 1000) )
              goto LABEL_55;
            v150 = (int *)(v44 + 56);
            if ( !sub_45784((_DWORD *)(v44 + 56), (_DWORD *)(v20 + 184), "real_sec", "real_musec", 1000) )
              goto LABEL_55;
          }
          v102 = sub_4594C((_DWORD *)(v20 + 184), "precision", *(__int16 *)(v44 + 104));
          v103 = -32;
          v104 = *(_DWORD *)(v44 + 108);
          if ( v102 >= -32 )
            v103 = v102;
          v105 = *(_DWORD *)(v44 + 64);
          v106 = *(_DWORD *)(v44 + 68);
          v107 = *(_DWORD *)(v44 + 112);
          *(_WORD *)(v44 + 106) = v103 & (v103 >> 31);
          v108 = v105 - v104;
          *(_DWORD *)(v44 + 48) = v105;
          *(_DWORD *)(v44 + 52) = v106;
          v109 = *(_DWORD *)(v44 + 52);
          v110 = *(_DWORD *)(v44 + 64);
          v111 = *(_DWORD *)(v44 + 116);
          if ( v109 < v107 )
            --v108;
          v112 = v109 - v107;
          *(_DWORD *)(v44 + 48) = v108;
          v113 = v108 + (v112 >> 31);
          v114 = v110 - v111;
          v115 = *(_DWORD *)(v44 + 120);
          *(_DWORD *)(v44 + 52) = v112;
          v116 = *(_DWORD *)(v44 + 48);
          v117 = *(_DWORD *)(v44 + 52);
          v118 = *(_DWORD *)(v44 + 8);
          if ( *(_DWORD *)(v44 + 68) < v115 )
            v119 = v114 - 1;
          else
            v119 = v114;
          v120 = *(_DWORD *)(v44 + 68);
          v121 = *(_DWORD *)(v44 + 120);
          *(_DWORD *)(v44 + 64) = v119;
          *(_DWORD *)(v44 + 68) = v120 - v121;
          v43[58] = v116;
          v43[59] = v117;
          *(_DWORD *)(v44 + 40) = v113;
          *(_DWORD *)(v44 + 44) = 0;
          if ( v118 )
          {
            v122 = *(_DWORD *)(v118 + 84);
            v123 = sub_69CA0(v150);
            sub_44468(v122, v123);
          }
          *(_BYTE *)(v44 + 132) = *(_BYTE *)(v44 + 132) & 0xFB
                                | (4 * (((*((unsigned __int8 *)v43 + 768) ^ 2) << 30 >> 31) & 1))
                                | 8;
        }
      }
LABEL_56:
      v47 = *(_DWORD *)(v20 + 8);
      v48 = *(_BYTE *)(v20 + 132);
      ++*(_DWORD *)(v20 + 152);
      if ( v47 && (v48 & 8) != 0 )
      {
        v77 = *(_DWORD *)(v47 + 84);
        sub_443C4((__int16 *)v47, (_DWORD *)v77, *(_DWORD *)(v20 + 56), *(_DWORD *)(v20 + 60));
        *(_BYTE *)(v47 + 95) = *(_WORD *)(v20 + 106);
        v78 = *(_DWORD *)(v20 + 76);
        if ( v78 >= 8 )
          v78 = 8;
        v79 = v78 + 2;
        *(_DWORD *)(v20 + 76) = v79;
        if ( v79 == 10 && (*(_BYTE *)(v77 + 768) & 1) != 0 )
          *(_DWORD *)(v47 + 68) |= 0x80u;
        v80 = *(_DWORD *)(v20 + 176) + 1;
        v48 = *(_BYTE *)(v20 + 132) & 0xF7;
        *(_BYTE *)(v20 + 132) = v48;
        *(_DWORD *)(v20 + 176) = v80;
      }
      v49 = *(_DWORD *)(v20 + 16);
      if ( (v48 & 6) != 6 )
      {
        if ( v49 == 1 )
          goto LABEL_72;
        goto LABEL_60;
      }
      v76 = *(_DWORD *)(v20 + 80) - *(_DWORD *)(v20 + 32);
      if ( *(_DWORD *)(v20 + 84) < *(_DWORD *)(v20 + 36) )
        --v76;
      if ( v76 <= 0 )
      {
        if ( !v76 )
        {
          if ( v49 == 1 )
            goto LABEL_68;
          goto LABEL_60;
        }
        *(_BYTE *)(v20 + 132) &= ~2u;
      }
      else
      {
        *(_BYTE *)(v20 + 132) &= ~4u;
      }
      v48 = *(_BYTE *)(v20 + 132);
      if ( v49 == 1 )
        goto LABEL_67;
LABEL_60:
      if ( v49 != 2 )
        goto LABEL_102;
      if ( (v48 & 2) == 0 )
        goto LABEL_72;
      v50 = *(_DWORD *)(v20 + 72);
      if ( (v48 & 4) == 0 )
      {
        if ( v50 < 1 )
          v50 = 1;
        v73 = v50 - 1;
        *(_DWORD *)(v20 + 72) = v73;
        if ( !v73 )
        {
          if ( (v48 & 0x10) != 0 )
            goto LABEL_103;
          v74 = *(const char **)(v20 + 20);
          *(_BYTE *)(v20 + 132) |= 0x10u;
          sub_64E00(4, "%s: use TPV alone from now", v74);
LABEL_101:
          v48 = *(_BYTE *)(v20 + 132);
          if ( (v48 & 0x10) != 0 )
          {
LABEL_102:
            if ( (v48 & 2) != 0 )
            {
LABEL_103:
              sub_443C4((__int16 *)v143, v153, *(_DWORD *)(v20 + 88), *(_DWORD *)(v20 + 92));
              v10 = (_BYTE *)v7;
              *(_BYTE *)(v143 + 95) = *(_WORD *)(v20 + 104);
              v75 = *(_DWORD *)(v20 + 168) + 1;
              *(_BYTE *)(v20 + 132) &= ~2u;
              *(_DWORD *)(v20 + 168) = v75;
              continue;
            }
LABEL_72:
            v10 = (_BYTE *)v7;
            continue;
          }
          goto LABEL_67;
        }
LABEL_66:
        if ( (v48 & 0x10) != 0 )
          goto LABEL_103;
        goto LABEL_67;
      }
      if ( v50 >= 57 )
        v50 = 57;
      v51 = v50 + 3;
      *(_DWORD *)(v20 + 72) = v51;
      if ( v51 != 60 )
        goto LABEL_66;
      if ( (v48 & 0x10) != 0 )
      {
        v124 = *(const char **)(v20 + 20);
        *(_BYTE *)(v20 + 132) &= ~0x10u;
        sub_64E00(6, "%s: expect valid PPS from now", v124);
        goto LABEL_101;
      }
LABEL_67:
      if ( (v48 & 6) != 6 )
        goto LABEL_72;
LABEL_68:
      sub_443C4((__int16 *)v143, v153, *(_DWORD *)(v20 + 88), *(_DWORD *)(v20 + 92));
      v10 = (_BYTE *)v7;
      *(_BYTE *)(v143 + 95) = *(_WORD *)(v20 + 106);
      v52 = *(_DWORD *)(v20 + 168) + 1;
      *(_BYTE *)(v20 + 132) &= 0xF9u;
      *(_DWORD *)(v20 + 168) = v52;
LABEL_8:
      ;
    }
    while ( v9 != v3 );
  }
LABEL_18:
  *(_DWORD *)(v142 + 3096) = &v10[-v7];
  *(_DWORD *)(v152 + 144) = 10;
  return 10;
}
// 46434: variable 'v38' is possibly undefined
// 46434: variable 'v39' is possibly undefined
// 46A74: variable 'v35' is possibly undefined
// 46EAC: variable 'v1' is possibly undefined
// B460: using guessed type int __fastcall strptime(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type char *off_15180;

//----- (000470B4) --------------------------------------------------------
__int16 *__fastcall sub_470B4(int a1, int a2)
{
  int v2; // r4
  int v4; // r1
  __int16 *result; // r0
  int v6; // [sp+0h] [bp-8h] BYREF

  v2 = *(_DWORD *)(a2 + 84);
  v6 = 4;
  if ( ioctl(*(_DWORD *)(v2 + 28), 0x5417u, &v6) < 0 )
    sub_394A0((__int16 *)a2, 3);
  sub_5F724((int *)(v2 + 232));
  if ( write(*(_DWORD *)(v2 + 28), "T", 1u) != 1 )
    sub_394A0((__int16 *)a2, 3);
  ioctl(*(_DWORD *)(v2 + 28), 0x5416u, &v6);
  if ( *(_DWORD *)(v2 + 216) == *(_DWORD *)(v2 + 220) )
    return sub_394A0((__int16 *)a2, 1);
  v4 = *(_DWORD *)(v2 + 236);
  *(_DWORD *)(v2 + 224) = *(_DWORD *)(v2 + 232);
  *(_DWORD *)(v2 + 228) = v4;
  sub_39D44(a2);
  result = (__int16 *)sub_41F44((unsigned __int16 *)(a2 + 16), (const char *)(v2 + 56));
  ++*(_DWORD *)(v2 + 776);
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (000471C4) --------------------------------------------------------
char *__fastcall sub_471C4(int a1, int a2)
{
  char *result; // r0

  result = *(char **)(a2 + 84);
  if ( *((_DWORD *)result + 7) != -1 )
    return sub_18E64((int)(result + 8));
  return result;
}

//----- (00047230) --------------------------------------------------------
__int16 *__fastcall sub_47230(int a1)
{
  int v1; // r6
  int v2; // r4
  _BYTE *v3; // r0
  int v4; // r1
  int v5; // r3
  char *v6; // r2
  int i; // r1
  int v8; // t1
  const unsigned __int16 *v9; // r1
  int v10; // r2
  bool v11; // zf
  int v12; // r3
  __int16 *result; // r0
  char *v14; // r2
  int j; // r1
  int v16; // t1
  unsigned __int8 v17; // [sp+1Bh] [bp-21h] BYREF
  int v18; // [sp+1Ch] [bp-20h] BYREF
  int v19; // [sp+20h] [bp-1Ch] BYREF
  int v20; // [sp+24h] [bp-18h] BYREF
  char v21; // [sp+2Ch] [bp-10h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 84);
  v3 = sub_39EE4(a1, (bool *)(v2 + 56), 128, &v20);
  *(_DWORD *)(v2 + 184) = v3;
  if ( v3 != (_BYTE *)&dword_14 + 3
    || sscanf(
         (const char *)(v2 + 56),
         "%2d:%2d:%2d.%c%5c%2d/%2d/%2d",
         v2 + 196,
         v2 + 200,
         v2 + 204,
         &v17,
         &v21,
         &v18,
         &v19,
         v2 + 188) != 8 )
  {
    return sub_394A0((__int16 *)v1, 2);
  }
  v4 = v18 - 1;
  if ( (unsigned int)(v18 - 1) > 0xB )
    return sub_394A0((__int16 *)v1, 6);
  v5 = v19;
  if ( v19 <= 0 )
    return sub_394A0((__int16 *)v1, 6);
  if ( (*(_DWORD *)(v2 + 188) & 3) != 0 )
  {
    v6 = (char *)&unk_975BC;
    if ( v19 <= *((_DWORD *)&unk_975BC + v4) )
    {
      if ( v18 == 1 )
        goto LABEL_12;
      for ( i = 31; ; i = v8 )
      {
        v5 += i;
        if ( &a127001[4 * v18 + 4] == v6 )
          break;
        v8 = *((_DWORD *)v6 + 1);
        v6 += 4;
      }
      goto LABEL_11;
    }
    return sub_394A0((__int16 *)v1, 6);
  }
  if ( v19 > *((_DWORD *)&unk_975BC + v4 + 12) )
    return sub_394A0((__int16 *)v1, 6);
  if ( v18 != 1 )
  {
    v14 = (char *)&unk_975EC;
    for ( j = 31; ; j = v16 )
    {
      v5 += j;
      if ( v14 == (char *)&unk_975E4 + 4 * v18 )
        break;
      v16 = *((_DWORD *)v14 + 1);
      v14 += 4;
    }
LABEL_11:
    v19 = v5;
  }
LABEL_12:
  *(_DWORD *)(v2 + 192) = v5;
  v9 = *_ctype_b_loc();
  v10 = v9[v17];
  v11 = (v10 & 0x800) == 0;
  if ( (v10 & 0x800) != 0 )
  {
    v10 = 100000000;
    v12 = v17 - 48;
  }
  else
  {
    v12 = 3;
  }
  if ( v11 )
  {
    *(_BYTE *)(v2 + 40) = v12;
  }
  else
  {
    v12 *= v10;
    LOBYTE(v9) = 0;
  }
  if ( !v11 )
  {
    *(_BYTE *)(v2 + 40) = (_BYTE)v9;
    *(_DWORD *)(v2 + 208) = v12;
  }
  result = (__int16 *)sub_39CF8((_DWORD *)v2);
  if ( !result )
    return sub_394A0((__int16 *)v1, 6);
  return result;
}
// 14: using guessed type int;

//----- (00047414) --------------------------------------------------------
int __fastcall sub_47414(int a1, int a2)
{
  int v3; // r9
  int v4; // r8
  int *v5; // r4
  char v7[20]; // [sp+0h] [bp-1Ch] BYREF

  sub_6C054((int)v7, 0x14u, "/dev/heath%d", a1);
  v3 = sub_3A298(v7, *((_DWORD *)&unk_975BC + (*(_DWORD *)(a2 + 76) & 3) + 24), 128);
  if ( v3 <= 0 )
    return 0;
  v5 = *(int **)(a2 + 84);
  v5[5] = a2;
  v5[7] = v3;
  v5[3] = (int)sub_47230;
  v5[6] = 0;
  v4 = sub_18DF0(v5 + 2);
  if ( v4 )
  {
    v4 = 1;
    *(_BYTE *)(a2 + 95) = -4;
    v5[191] = 5658455;
    v5[11] = (int)"Heath GC-1000 Most Accurate Clock";
  }
  else
  {
    close(v3);
    v5[7] = -1;
  }
  return v4;
}

//----- (00047520) --------------------------------------------------------
int __fastcall sub_47520(int a1, int a2)
{
  int *v2; // r2
  int result; // r0

  v2 = *(int **)(a2 + 84);
  result = *v2;
  ++v2[194];
  *(_DWORD *)(result + 20) = 1;
  return result;
}

//----- (00047580) --------------------------------------------------------
void __fastcall sub_47580(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (00047600) --------------------------------------------------------
unsigned int __fastcall sub_47600(unsigned int result)
{
  int v1; // r6
  int v2; // r4
  const char *v3; // r7
  _DWORD *v4; // r8
  unsigned int v5; // r0
  int v6; // r0
  int v7; // r3
  char v8; // r2
  int v9; // r2
  int v10; // r1
  _DWORD *v11; // r4
  int v12; // [sp+1Ch] [bp-18h] BYREF
  char v13; // [sp+20h] [bp-14h] BYREF
  int v14; // [sp+24h] [bp-10h] BYREF
  int v15; // [sp+28h] [bp-Ch] BYREF

  v1 = *(_DWORD *)(result + 4);
  v2 = *(_DWORD *)(v1 + 84);
  if ( *(_DWORD *)(*(_DWORD *)v2 + 20) )
  {
    v3 = (const char *)(v2 + 56);
    v4 = (_DWORD *)(v2 + 232);
    *(_DWORD *)(*(_DWORD *)v2 + 20) = 0;
    result = (unsigned __int16)sub_39EE4(result, (bool *)(v2 + 56), 128, (_DWORD *)(v2 + 232));
    *(_DWORD *)(v2 + 184) = (unsigned __int16)result;
    if ( (_WORD)result )
    {
      if ( sscanf(
             (const char *)(v2 + 56),
             "%1x%1x%2d%2d%2d%2d%2d%2d",
             &v12,
             &v13,
             v2 + 196,
             v2 + 200,
             v2 + 204,
             &v14,
             &v15,
             v2 + 188) == 8
        && *(_DWORD *)(v2 + 196) <= 0x17u
        && *(_DWORD *)(v2 + 200) <= 0x3Bu
        && *(_DWORD *)(v2 + 204) <= 0x3Cu
        && (unsigned int)(v14 - 1) <= 0x1E
        && (unsigned int)(v15 - 1) <= 0xB
        && (v5 = *(_DWORD *)(v2 + 188), v5 <= 0x63) )
      {
        v6 = sub_6EC68(v5, v15, v14);
        v7 = *(_DWORD *)(v2 + 188);
        *(_DWORD *)(v2 + 192) = v6;
        *(_BYTE *)(v2 + 40) = 0;
        if ( v7 <= 97 )
        {
          v7 += 100;
          *(_DWORD *)(v2 + 188) = v7;
        }
        v8 = v12;
        *(_DWORD *)(v2 + 188) = v7 + 1900;
        v9 = v8 & 0xC;
        if ( v9 && (v9 != 4 || (*(_BYTE *)(v2 + 768) & 1) != 0) )
        {
          if ( sub_39CF8((_DWORD *)v2) )
          {
            v10 = *(_DWORD *)(v2 + 236);
            v11 = (_DWORD *)(v2 + 224);
            *v11 = *v4;
            v11[1] = v10;
            sub_39D44(v1);
            return sub_41F44((unsigned __int16 *)(v1 + 16), v3);
          }
          else
          {
            return (unsigned int)sub_394A0((__int16 *)v1, 6);
          }
        }
        else
        {
          result = (unsigned int)sub_394A0((__int16 *)v1, 6);
          *(_BYTE *)(v2 + 40) = 3;
        }
      }
      else
      {
        return (unsigned int)sub_394A0((__int16 *)v1, 2);
      }
    }
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (000477E8) --------------------------------------------------------
int __fastcall sub_477E8(int a1, int a2)
{
  int v4; // r0
  int v5; // r9
  int v6; // r8
  _BYTE *v7; // r11
  _DWORD *v8; // r4
  char v10[20]; // [sp+8h] [bp-1Ch] BYREF

  sub_6C054((int)v10, 0x14u, "/dev/hopfclock%d", a1);
  v4 = sub_3A298(v10, 0xDu, 1);
  v5 = v4;
  if ( v4 <= 0 )
    return 0;
  sub_64E00(5, "hopfSerialClock(%d) fd: %d dev: %s", a1, v4, v10);
  v7 = sub_63BA4(0, 0x18u, 0, 1);
  v8 = *(_DWORD **)(a2 + 84);
  *v8 = v7;
  v8[5] = a2;
  v8[7] = v5;
  v8[3] = sub_47600;
  v8[6] = 0;
  v6 = sub_18DF0(v8 + 2);
  if ( v6 )
  {
    v6 = 1;
    v8[11] = "hopf Elektronik serial clock";
    *(_BYTE *)(a2 + 95) = -10;
    v8[191] = *(_DWORD *)"hopf";
    v7[16] = 0;
    *((_WORD *)v7 + 4) = a1;
  }
  else
  {
    close(v5);
    v8[7] = -1;
    free(v7);
    *v8 = 0;
  }
  return v6;
}

//----- (0004793C) --------------------------------------------------------
__int16 *__fastcall sub_4793C(int a1, int a2)
{
  int v4; // r4
  int v5; // r2
  int v6; // r1
  int v7; // r0
  int v8; // r0
  int v9; // r1
  int v10; // r3
  int v11; // lr
  int v12; // r2
  int v13; // r7
  int v14; // r1
  const char *v15; // r7
  _DWORD *v16; // r8
  int v17; // r1
  _DWORD *v18; // r4
  __int16 *result; // r0
  int v20; // [sp+4h] [bp-44h]
  int v21; // [sp+20h] [bp-28h] BYREF
  int v22; // [sp+24h] [bp-24h]
  int v23; // [sp+2Ch] [bp-1Ch]
  int v24; // [sp+30h] [bp-18h]
  int v25; // [sp+34h] [bp-14h]
  int v26; // [sp+38h] [bp-10h]
  int v27; // [sp+3Ch] [bp-Ch]
  int v28; // [sp+40h] [bp-8h]

  v4 = *(_DWORD *)(a2 + 84);
  if ( ioctl(fd, 0x20000u, &v21) < 0 )
    sub_64E00(3, "HOPF_P(%d): HOPF_CLOCK_GET_UTC: %m", a1);
  v5 = v23;
  v6 = v22;
  v7 = v21;
  ++*(_DWORD *)(v4 + 776);
  v8 = sub_6EC68(v7, v6, v5);
  v9 = v27;
  v10 = v28;
  *(_DWORD *)(v4 + 192) = v8;
  v11 = v24;
  v12 = (_DWORD)&unk_F4240 * v9;
  if ( (v10 & 0x20) != 0 )
    LOBYTE(v8) = 1;
  v13 = v25;
  v14 = v26;
  if ( (v10 & 0x20) != 0 )
    *(_BYTE *)(v4 + 40) = v8;
  else
    *(_BYTE *)(v4 + 40) = v10 & 0x20;
  *(_DWORD *)(v4 + 196) = v11;
  *(_DWORD *)(v4 + 200) = v13;
  *(_DWORD *)(v4 + 208) = v12;
  *(_DWORD *)(v4 + 204) = v14;
  v20 = v13;
  v15 = (const char *)(v4 + 56);
  v16 = (_DWORD *)(v4 + 232);
  sub_6C054(
    v4 + 56,
    0x80u,
    "ST: %02X T: %02d:%02d:%02d.%03ld D: %02d.%02d.%04d",
    v10,
    v11,
    v20,
    v14,
    v12 / 1000000,
    v23,
    v22,
    v21);
  *(_DWORD *)(v4 + 184) = (unsigned __int16)strlen((const char *)(v4 + 56));
  sub_5F724((int *)(v4 + 232));
  if ( (v28 & 0xC0) != 0 && ((v28 & 0xC0) != 0x40 || (*(_BYTE *)(v4 + 768) & 1) != 0) )
  {
    if ( sub_39CF8((_DWORD *)v4) )
    {
      v17 = *(_DWORD *)(v4 + 236);
      v18 = (_DWORD *)(v4 + 224);
      *v18 = *v16;
      v18[1] = v17;
      sub_39D44(a2);
      return (__int16 *)sub_41F44((unsigned __int16 *)(a2 + 16), v15);
    }
    else
    {
      return sub_394A0((__int16 *)a2, 6);
    }
  }
  else
  {
    result = sub_394A0((__int16 *)a2, 6);
    *(_BYTE *)(v4 + 40) = 3;
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// 108CD4: using guessed type int fd;

//----- (00047B18) --------------------------------------------------------
void __fastcall sub_47B18(int a1, int a2)
{
  void *v3; // r0

  close(fd);
  v3 = **(void ***)(a2 + 84);
  if ( v3 )
    free(v3);
}
// 108CD4: using guessed type int fd;

//----- (00047B98) --------------------------------------------------------
int __fastcall sub_47B98(__int16 a1, int a2)
{
  _BYTE *v4; // r6
  int v5; // r2
  int v6; // r0
  _DWORD *v7; // r4

  v4 = sub_63BA4(0, 4u, 0, 1);
  v6 = open64("/dev/hopf6039", 2, v5);
  v7 = *(_DWORD **)(a2 + 84);
  v7[7] = -1;
  v7[5] = a2;
  fd = v6;
  v7[3] = 0;
  v7[6] = 0;
  *v7 = v4;
  sub_5F724(v7 + 58);
  v7[191] = *(_DWORD *)"hopf";
  *(_BYTE *)(a2 + 95) = -10;
  v7[11] = "hopf Elektronik PCI radio board";
  v4[2] = 0;
  *(_WORD *)v4 = a1;
  return 1;
}
// 47BE8: variable 'v5' is possibly undefined
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// 108CD4: using guessed type int fd;

//----- (00047C84) --------------------------------------------------------
__int16 *__fastcall sub_47C84(int a1, int a2)
{
  int **v3; // r4
  int v4; // r3
  __int16 *result; // r0

  v3 = *(int ***)(a2 + 84);
  v4 = **v3;
  if ( v4 )
    **v3 = v4 - 1;
  else
    sub_394A0((__int16 *)a2, 1);
  result = (__int16 *)write((int)v3[7], ":PTIME:TCODE?\r", 0xEu);
  if ( result != (__int16 *)&byte_9[5] )
    return sub_394A0((__int16 *)a2, 3);
  v3[194] = (int *)((char *)v3[194] + 1);
  return result;
}

//----- (00047D48) --------------------------------------------------------
void __fastcall sub_47D48(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (00047DC8) --------------------------------------------------------
int __fastcall sub_47DC8(int a1, int a2)
{
  speed_t v3; // r1
  int v4; // r3
  __int16 v5; // r2
  int v6; // r9
  int v7; // r6
  _DWORD *v8; // r0
  int v9; // r4
  _DWORD *v10; // r8
  int v11; // r0
  char v13[20]; // [sp+0h] [bp-18h] BYREF

  sub_6C054((int)v13, 0x14u, "/dev/hpgps%d", a1);
  v4 = *(_DWORD *)(a2 + 76);
  v5 = 257;
  if ( v4 == 1 )
    v3 = 14;
  else
    v5 = 1;
  if ( v4 != 1 )
    v3 = 13;
  v6 = sub_3A298(v13, v3, v5);
  if ( v6 <= 0 )
    return 0;
  v8 = sub_63BA4(0, 0x748u, 0, 1);
  v9 = *(_DWORD *)(a2 + 84);
  v10 = v8;
  *(_DWORD *)(v9 + 20) = a2;
  *(_DWORD *)(v9 + 28) = v6;
  *(_DWORD *)(v9 + 12) = sub_47F48;
  *(_DWORD *)(v9 + 24) = 0;
  v7 = sub_18DF0((int *)(v9 + 8));
  if ( v7 )
  {
    v7 = 1;
    *(_DWORD *)v9 = v10;
    *(_BYTE *)(a2 + 95) = -10;
    *(_DWORD *)(v9 + 44) = "HP 58503A GPS Time and Frequency Reference Receiver";
    strcpy((char *)(v9 + 764), "GPS");
    v10[1] = 0;
    v10[2] = 0;
    *((_BYTE *)v10 + 20) = 0;
    *v10 = 2;
    v11 = *(_DWORD *)(v9 + 28);
    v10[4] = v10 + 5;
    v10[3] = 1;
    if ( write(v11, "*IDN?\r:PTIME:TZONE?\r", 0x14u) != 20 )
      sub_394A0((__int16 *)a2, 3);
  }
  else
  {
    close(v6);
    *(_DWORD *)(v9 + 28) = -1;
    free(v10);
  }
  return v7;
}
// 47E24: variable 'v3' is possibly undefined

//----- (00047F48) --------------------------------------------------------
__int16 *__fastcall sub_47F48(int a1)
{
  int v1; // r6
  int v2; // r5
  int v3; // r12
  int v4; // r9
  __int16 *result; // r0
  int v6; // r3
  int v7; // r11
  bool v8; // cc
  int v9; // r3
  _BYTE *v10; // r12
  int v11; // r1
  char *v12; // r0
  const char *v13; // r8
  const char *v14; // r4
  int v15; // r2
  bool v16; // zf
  int v17; // r2
  int v18; // t1
  bool v19; // zf
  char *v20; // r4
  const char *v21; // r1
  unsigned __int8 v22; // r3
  char v23; // t1
  int v24; // r11
  int v25; // r3
  int v26; // r4
  int v27; // r8
  int v28; // r2
  int v29; // r1
  int v30; // r1
  char *v31; // r3
  int v32; // t1
  int v33; // r8
  int v34; // r0
  int v35; // r3
  int v36; // r1
  int v37; // r3
  int v38; // r3
  int v39; // r3
  int v40; // r1
  int v41; // r0
  char *v42; // r3
  int v43; // t1
  int v44; // r4
  int v45; // r1
  int v46; // r1
  int v47; // r3
  bool v48; // zf
  bool v49; // zf
  _DWORD *v50; // [sp+2Ch] [bp-20h]
  int v51; // [sp+30h] [bp-1Ch]
  int v52; // [sp+34h] [bp-18h]
  char v53; // [sp+3Bh] [bp-11h] BYREF
  char v54; // [sp+3Ch] [bp-10h] BYREF
  char v55; // [sp+3Dh] [bp-Fh] BYREF
  char v56; // [sp+3Eh] [bp-Eh] BYREF
  unsigned __int8 v57; // [sp+3Fh] [bp-Dh] BYREF
  char v58; // [sp+40h] [bp-Ch] BYREF
  unsigned __int8 v59; // [sp+41h] [bp-Bh] BYREF
  __int16 v60; // [sp+42h] [bp-Ah] BYREF
  int v61; // [sp+44h] [bp-8h] BYREF
  int v62; // [sp+48h] [bp-4h] BYREF
  _DWORD v63[2]; // [sp+4Ch] [bp+0h] BYREF
  char v64[128]; // [sp+54h] [bp+8h] BYREF
  int v65; // [sp+D4h] [bp+88h]

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 84);
  v3 = _stack_chk_guard;
  v4 = *(_DWORD *)v2;
  *(_BYTE *)(v2 + 56) = 0;
  v65 = v3;
  result = (__int16 *)sub_39EE4(a1, (bool *)(v2 + 56), 128, v63);
  *(_DWORD *)(v2 + 184) = result;
  if ( !result )
    return result;
  v6 = *(_DWORD *)(v4 + 12);
  v7 = v4 + 20;
  v8 = v6 <= 0;
  v9 = v6 - 1;
  *(_DWORD *)(v4 + 12) = v9;
  if ( !v8 )
  {
    v10 = *(_BYTE **)(v4 + 16);
    result = (__int16 *)((char *)result + 1);
    if ( (int)result < 1841 - (int)&v10[-v7] )
    {
      *(_DWORD *)(v4 + 16) = v10 + 1;
      *v10 = 10;
      result = (__int16 *)memcpy(*(void **)(v4 + 16), (const void *)(v2 + 56), *(_DWORD *)(v2 + 184));
      v9 = *(_DWORD *)(v4 + 12);
      *(_DWORD *)(v4 + 16) += *(_DWORD *)(v2 + 184);
    }
    if ( !v9 )
      return (__int16 *)sub_41F44((unsigned __int16 *)(v1 + 16), (const char *)(v4 + 20));
    return result;
  }
  sub_41F44((unsigned __int16 *)(v1 + 16), (const char *)(v2 + 56));
  v11 = v63[1];
  v50 = (_DWORD *)(v2 + 232);
  *(_DWORD *)(v2 + 232) = v63[0];
  *(_DWORD *)(v2 + 236) = v11;
  *(_BYTE *)(v4 + 20) = 0;
  *(_DWORD *)v4 = 2;
  *(_DWORD *)(v4 + 16) = v7;
  sub_6D4DC(v64, (unsigned __int8 *)(v2 + 56), 128);
  v12 = strrchr((const char *)(v2 + 56), 62);
  if ( v12 )
    v13 = v12 + 1;
  else
    v13 = (const char *)(v2 + 56);
  if ( v12 )
    v14 = &v13[-v2 - 56];
  else
    v14 = 0;
  v64[(_DWORD)v14] = 0;
  v15 = *(unsigned __int8 *)v13;
  v16 = v15 == 9;
  if ( v15 != 9 )
    v16 = v15 == 32;
  if ( v16 )
  {
    do
    {
      v18 = *(unsigned __int8 *)++v13;
      v17 = v18;
      v19 = v18 == 9;
      if ( v18 != 9 )
        v19 = v17 == 32;
    }
    while ( v19 );
  }
  v20 = strrchr(v64, 69);
  if ( v20 > strrchr(v64, 115) && write(*(_DWORD *)(v2 + 28), "*CLS\r\r", 6u) != 6 )
    sub_394A0((__int16 *)v1, 3);
  if ( sscanf(v13, "%c%c", &v53, &v54) != 2 )
    return sub_394A0((__int16 *)v1, 2);
  if ( v53 == 45 )
  {
LABEL_27:
    result = (__int16 *)sscanf(v13, "%d,%d", v4 + 4, v4 + 8);
    if ( result == (_WORD *)&dword_0 + 1
      && (unsigned int)(*(_DWORD *)(v4 + 4) + 12) <= 0x19
      && (unsigned int)(*(_DWORD *)(v4 + 8) + 59) <= 0x76 )
    {
      return result;
    }
    return sub_394A0((__int16 *)v1, 2);
  }
  if ( v53 != 84 )
  {
    if ( v53 != 43 )
      return sub_394A0((__int16 *)v1, 2);
    goto LABEL_27;
  }
  if ( v54 != 50 )
    return sub_394A0((__int16 *)v1, 2);
  if ( sscanf(
         v13,
         "%*c%*c%4d%2d%2d%2d%2d%2d%c%c%c%c%c%2hx",
         v2 + 188,
         &v61,
         &v62,
         v2 + 196,
         v2 + 200,
         v2 + 204,
         &v55,
         &v56,
         &v57,
         &v58,
         &v59,
         &v60) != 12 )
    return sub_394A0((__int16 *)v1, 2);
  v21 = v13 + 21;
  v22 = 0;
  do
  {
    v23 = *v13++;
    v22 += v23;
  }
  while ( v13 != v21 );
  if ( v60 != v22 )
    return sub_394A0((__int16 *)v1, 2);
  v24 = v61;
  v25 = v61 - 1;
  if ( (unsigned int)(v61 - 1) > 0xB )
    return sub_394A0((__int16 *)v1, 6);
  v26 = v62;
  v27 = v62;
  if ( v62 <= 0 )
    return sub_394A0((__int16 *)v1, 6);
  v28 = *(_DWORD *)(v2 + 188);
  if ( (v28 & 3) != 0 )
    goto LABEL_94;
  v52 = v61 - 1;
  v51 = v28;
  sub_8BB9C(*(_DWORD *)(v2 + 188), 0x64u);
  v28 = v51;
  v25 = v52;
  if ( v29 )
    goto LABEL_95;
  sub_8BB9C(v51, 0x190u);
  v28 = v51;
  v25 = v52;
  if ( v30 )
  {
LABEL_94:
    if ( v26 > *(_DWORD *)&aGps_2[4 * v25 + 8] )
      return sub_394A0((__int16 *)v1, 6);
    if ( v25 )
    {
      v42 = (char *)&unk_9779C;
      do
      {
        v43 = *(_DWORD *)v42;
        v42 += 4;
        v27 += v43;
      }
      while ( (char *)&unk_97798 + 4 * v24 != v42 );
      v26 = v27;
      v62 = v27;
    }
    v33 = 365;
  }
  else
  {
LABEL_95:
    if ( v26 > *(_DWORD *)&aGps_2[4 * v25 + 56] )
      return sub_394A0((__int16 *)v1, 6);
    if ( v25 )
    {
      v31 = (char *)&unk_977CC;
      do
      {
        v32 = *(_DWORD *)v31;
        v31 += 4;
        v27 += v32;
      }
      while ( (char *)&unk_977C8 + 4 * v24 != v31 );
      v26 = v27;
      v62 = v27;
    }
    v33 = 366;
  }
  v34 = *(_DWORD *)(v4 + 4);
  v35 = *(_DWORD *)(v2 + 196);
  v36 = *(_DWORD *)(v2 + 200) - *(_DWORD *)(v4 + 8);
  *(_DWORD *)(v2 + 200) = v36;
  v37 = v35 - v34;
  *(_DWORD *)(v2 + 196) = v37;
  if ( v36 < 0 )
  {
    v36 += 60;
    --v37;
    *(_DWORD *)(v2 + 200) = v36;
    *(_DWORD *)(v2 + 196) = v37;
  }
  if ( v36 > 59 )
  {
    ++v37;
    *(_DWORD *)(v2 + 200) = v36 - 60;
    *(_DWORD *)(v2 + 196) = v37;
  }
  if ( v37 < 0 )
  {
    --v26;
    v37 += 24;
    v62 = v26;
    *(_DWORD *)(v2 + 196) = v37;
    if ( v26 <= 0 )
    {
      v44 = v28 - 1;
      *(_DWORD *)(v2 + 188) = v28 - 1;
      if ( ((v28 - 1) & 3) != 0 || (sub_8BB9C(v28 - 1, 0x64u), !v45) && (sub_8BB9C(v44, 0x190u), v46) )
      {
        v37 = *(_DWORD *)(v2 + 196);
        v26 = 365;
        v62 = 365;
      }
      else
      {
        v26 = 366;
        v37 = *(_DWORD *)(v2 + 196);
        v62 = 366;
      }
    }
  }
  if ( v37 > 23 )
  {
    v62 = ++v26;
    *(_DWORD *)(v2 + 196) = v37 - 24;
    if ( v26 > v33 )
    {
      v38 = *(_DWORD *)(v2 + 188);
      v26 = 1;
      v62 = 1;
      *(_DWORD *)(v2 + 188) = v38 + 1;
    }
  }
  v39 = v59;
  *(_DWORD *)(v2 + 192) = v26;
  if ( v39 == 48 )
  {
    v47 = v57;
    *(_BYTE *)(v2 + 40) = 0;
    if ( v47 == 45 )
    {
      v49 = v24 == 12;
      if ( v24 != 12 )
        v49 = v24 == 6;
      if ( v49 )
        *(_BYTE *)(v2 + 40) = 2;
    }
    else if ( v47 != 48 )
    {
      if ( v47 != 43 )
        return sub_394A0((__int16 *)v1, 6);
      v48 = v24 == 12;
      if ( v24 != 12 )
        v48 = v24 == 6;
      if ( v48 )
        *(_BYTE *)(v2 + 40) = 1;
    }
  }
  else
  {
    *(_BYTE *)(v2 + 40) = 3;
  }
  if ( !sub_39CF8((_DWORD *)v2) )
    return sub_394A0((__int16 *)v1, 6);
  v40 = v50[1];
  *(_DWORD *)(v2 + 224) = *v50;
  *(_DWORD *)(v2 + 228) = v40;
  result = (__int16 *)sub_39D44(v1);
  if ( (*(_BYTE *)(v2 + 768) & 8) != 0 )
  {
    v41 = *(_DWORD *)(v2 + 28);
    *(_DWORD *)(v4 + 12) = 22;
    result = (__int16 *)write(v41, ":SYSTEM:PRINT?\r", 0xFu);
    if ( result != (__int16 *)&byte_9[6] )
      return sub_394A0((__int16 *)v1, 3);
  }
  return result;
}
// 482AC: variable 'v29' is possibly undefined
// 482C4: variable 'v30' is possibly undefined
// 484BC: variable 'v45' is possibly undefined
// 484D0: variable 'v46' is possibly undefined
// 0: using guessed type int dword_0;
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00048568) --------------------------------------------------------
__int16 *__fastcall sub_48568(int a1, int a2)
{
  int v3; // r4
  __int16 *result; // r0

  v3 = *(_DWORD *)(a2 + 84);
  if ( *(_DWORD *)(v3 + 216) == *(_DWORD *)(v3 + 220) )
    return sub_394A0((__int16 *)a2, 1);
  result = (__int16 *)sub_39D44(a2);
  if ( (*(_BYTE *)(v3 + 768) & 8) == 0 )
    result = (__int16 *)sub_41F44((unsigned __int16 *)(a2 + 16), (const char *)(v3 + 56));
  ++*(_DWORD *)(v3 + 776);
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00048618) --------------------------------------------------------
void __fastcall sub_48618(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (00048698) --------------------------------------------------------
int __fastcall sub_48698(int a1, int a2)
{
  int *v2; // r5
  int v4; // r4
  int v5; // r12
  int v6; // r8
  int v7; // r3
  int v8; // r12
  int v9; // r3
  int v10; // r2
  int v11; // r3
  int v12; // r0
  int v13; // r3
  char v14; // r12
  char v15; // r2
  int result; // r0
  int v17; // r3
  bool v18; // zf
  int v19; // r0
  int v20; // r1
  bool v21; // zf
  char v22; // r3
  int v23; // r0
  int v24; // r12
  int v25; // r8
  int v26; // r2
  int v27; // r3
  int v28; // r2
  int v29; // r9
  int v30; // r3
  double v31; // d11
  double v32; // d6
  double v33; // d7
  double v34; // d10
  char *v35; // r0
  int v36; // r3
  int v37; // r1
  int v38; // r1
  int v39; // r3
  int v40; // [sp+50h] [bp-34h]
  int v41; // [sp+54h] [bp-30h]
  int v42; // [sp+58h] [bp-2Ch]
  int v43; // [sp+5Ch] [bp-28h]
  int v44; // [sp+60h] [bp-24h]
  int v45; // [sp+64h] [bp-20h]
  int v46; // [sp+6Ch] [bp-18h] BYREF
  char v47; // [sp+70h] [bp-14h] BYREF
  char v48; // [sp+74h] [bp-10h] BYREF
  int v49; // [sp+7Ch] [bp-8h]

  v2 = *(int **)(a1 + 84);
  v4 = *v2;
  v5 = *(_DWORD *)(*v2 + 3224);
  v6 = *(_DWORD *)(*v2 + 3216);
  v46 = 0;
  v7 = _stack_chk_guard;
  v8 = v5 >> 1;
  *(_DWORD *)(v4 + 3224) = v8;
  v49 = v7;
  if ( a2 == 1 )
  {
    *(_DWORD *)(v4 + 3224) = v8 | 0x200;
    v9 = v6 % 10;
  }
  else
  {
    if ( a2 == 2 )
    {
      v17 = *(_DWORD *)(v4 + 3204);
      if ( v17 == 2 )
      {
        v18 = v6 == 1;
        if ( v6 != 1 )
          v17 = *(_DWORD *)(v4 + 768);
        v6 = 1;
        v19 = *(_DWORD *)(v4 + 56);
        v20 = *(_DWORD *)(v4 + 60);
        if ( !v18 )
          *(_DWORD *)(v4 + 768) = v17 | 8;
        *(_DWORD *)(v4 + 40) = v19;
        *(_DWORD *)(v4 + 44) = v20;
        *(_DWORD *)(v4 + 3204) = 2;
        goto LABEL_9;
      }
    }
    v9 = v6 % 10;
  }
  *(_DWORD *)(v4 + 3204) = a2;
  if ( v9 )
    goto LABEL_9;
  v10 = *(_DWORD *)(v4 + 3224);
  v11 = *(_DWORD *)(v4 + 3220);
  if ( v6 == 10 )
  {
    if ( v11 <= 1 )
      goto LABEL_9;
    v10 >>= 1;
  }
  else if ( v11 <= 1 )
  {
    goto LABEL_8;
  }
  v12 = v4 + v11;
  v13 = v11 - 2;
  v14 = a0123456789abcd_4[v10 & 0xF];
  v15 = a0123456789abcd_4[((unsigned int)v10 >> 5) & 0xF];
  *(_BYTE *)(v12 - 1) = v14;
  *(_DWORD *)(v4 + 3220) = v13;
  *(_BYTE *)(v4 + v13) = v15;
LABEL_8:
  if ( v6 )
    goto LABEL_9;
  *(_DWORD *)(v4 + 3220) = 20;
  v21 = sscanf(
          (const char *)v4,
          "%6s%2d%1d%2s%3d%2d%2d%2d",
          &v48,
          v2 + 47,
          &v46,
          &v47,
          v2 + 48,
          v2 + 49,
          v2 + 50,
          v2 + 51) == 8;
  LOWORD(v23) = -30583;
  if ( v21 )
    *((_BYTE *)v2 + 40) = 0;
  else
    v22 = 3;
  if ( !v21 )
    *((_BYTE *)v2 + 40) = v22;
  HIWORD(v23) = -30584;
  v24 = v2[48];
  v25 = *(_DWORD *)(v4 + 768);
  v26 = *(_DWORD *)(v4 + 3208) + *(_DWORD *)(v4 + 3160);
  v40 = v24;
  v27 = v26 - 60 * (((int)(v26 + ((unsigned __int64)(v26 * (__int64)v23) >> 32)) >> 5) - (v26 >> 31));
  v28 = v2[47];
  *(_DWORD *)(v4 + 3208) = v27;
  v42 = v28;
  if ( v24 && (!v28 || v46) )
  {
    v29 = v2[51];
    if ( v27 == v29 )
    {
      v36 = *(_DWORD *)(v4 + 3180);
      *(_DWORD *)(v4 + 3208) = v29;
      v41 = v36;
      if ( !v25 && v36 == 10 )
      {
        v37 = v2[59];
        v2[56] = v2[58];
        v2[57] = v37;
        v38 = *(_DWORD *)(v4 + 44);
        v2[58] = *(_DWORD *)(v4 + 40);
        v2[59] = v38;
        if ( !sub_39CF8(v2) )
          sub_394A0((__int16 *)a1, 6);
        v25 = *(_DWORD *)(v4 + 768);
        v29 = v2[51];
        v40 = v2[48];
        v41 = *(_DWORD *)(v4 + 3180);
        v42 = v2[47];
      }
      goto LABEL_27;
    }
  }
  else
  {
    v29 = v2[51];
    v25 |= 0x80u;
    *(_DWORD *)(v4 + 768) = v25;
    if ( v27 == v29 )
    {
      v39 = *(_DWORD *)(v4 + 3180);
      *(_DWORD *)(v4 + 3208) = v29;
      v41 = v39;
      goto LABEL_27;
    }
  }
  v30 = *(_DWORD *)(v4 + 3180);
  v25 |= 0x20u;
  *(_DWORD *)(v4 + 3208) = v29;
  *(_DWORD *)(v4 + 768) = v25;
  v41 = v30;
LABEL_27:
  v31 = *(double *)(v4 + 3000);
  v32 = *(double *)(v4 + 736) * 1000000.0;
  v33 = *(double *)(v4 + 712) * 1000000.0;
  v43 = v2[49];
  v34 = *(double *)(v4 + 744);
  v44 = v2[50];
  v45 = *(_DWORD *)(v4 + 2836);
  v35 = sub_63804(v2[58], v2[59], 0, 6, 0);
  sub_6C054(
    (int)(v2 + 14),
    0x80u,
    "%02x %02d %03d %02d:%02d:%02d %4.0f %3d %6.3f %2d %6.2f %6.1f %s",
    v25,
    v42,
    v40,
    v43,
    v44,
    v29,
    v31,
    v45,
    v34,
    v41,
    v32 / 8000.0,
    v33 / 8000.0,
    v35);
  v2[46] = strlen((const char *)v2 + 56);
  *(_DWORD *)(v4 + 768) = 0;
  if ( (v2[192] & 8) != 0 )
    sub_41F44((unsigned __int16 *)(a1 + 16), (const char *)v2 + 56);
  v6 = *(_DWORD *)(v4 + 3216);
LABEL_9:
  result = _stack_chk_guard;
  *(_DWORD *)(v4 + 3216) = (v6 + 1) % 100;
  return result;
}
// 4886C: variable 'v22' is possibly undefined

//----- (00048ABC) --------------------------------------------------------
int __fastcall sub_48ABC(int a1, int a2)
{
  int v3; // r9
  int v4; // r8
  char *v5; // r0
  _DWORD *v6; // r5
  char *v7; // r4
  double *v8; // r1
  double *v9; // r2
  double v10; // d6
  int v11; // r3
  double v12; // d7
  __int64 v13; // r2

  v3 = sub_60AC0("/dev/audio", 320, a1);
  if ( v3 < 0 )
    return 0;
  v5 = (char *)sub_63BA4(0, 0xCA0u, 0, 1);
  v6 = *(_DWORD **)(a2 + 84);
  v7 = v5;
  v6[5] = a2;
  v6[7] = v3;
  v6[3] = sub_49588;
  v6[6] = 0;
  v4 = sub_18DF0(v6 + 2);
  if ( v4 )
  {
    *v6 = v7;
    *(_BYTE *)(a2 + 95) = -17;
    v6[11] = "Generic IRIG Audio Driver";
    v6[191] = *(_DWORD *)"IRIG";
    *((_DWORD *)v7 + 790) = 1;
    *((_DWORD *)v7 + 709) = 127;
    *((_DWORD *)v7 + 795) = 2;
    v8 = (double *)(v7 + 1832);
    *((_QWORD *)v7 + 225) = 0;
    *((_DWORD *)v7 + 194) = 0;
    *((_DWORD *)v7 + 195) = 0;
    *((_QWORD *)v7 + 98) = 0x3FF0000000000000LL;
    *((_QWORD *)v7 + 226) = 0xBFF0000000000000LL;
    *((_QWORD *)v7 + 99) = 0x4008000000000000LL;
    *((_QWORD *)v7 + 227) = 0xC008000000000000LL;
    *((_DWORD *)v7 + 200) = 0;
    v9 = (double *)(v7 + 800);
    *((_DWORD *)v7 + 201) = 1075052544;
    v10 = 2.0;
    v11 = 3;
    *((_QWORD *)v7 + 228) = 0xC014000000000000LL;
    while ( ++v11 != 128 )
    {
      v12 = *v9 + v10;
      if ( (v11 & 0xF) == 0 )
        v10 = v10 + v10;
      v9[1] = v12;
      ++v9;
      *v8++ = -v12;
    }
    HIDWORD(v13) = (char *)&loc_83124 + 2;
    v4 = 1;
    LODWORD(v13) = 0;
    *((_QWORD *)v7 + 4) = v13;
  }
  else
  {
    close(v3);
    v6[7] = -1;
    free(v7);
  }
  return v4;
}

//----- (00048CB8) --------------------------------------------------------
int __fastcall sub_48CB8(int a1)
{
  double v1; // d0
  int *v3; // r1
  int v4; // r4
  int v5; // r12
  double *v6; // lr
  int v7; // r3
  int result; // r0
  int v9; // r1
  int v10; // r2
  double v11; // d7
  int32x2_t v12; // d6
  double v13; // d7
  double v14; // d6
  int v15; // r3
  double v16; // d5
  double v17; // d3
  double v18; // d1
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  double v23; // d4
  double v24; // d7
  int v25; // r8
  double v26; // d7
  int v27; // r1
  double v28; // d6
  double v29; // d6
  double v30; // d4
  int v31; // r2
  double v32; // d6
  double *v33; // r8
  double v34; // d7
  int v35; // r1
  double v36; // d8
  bool v37; // zf
  double v38; // d8
  double v39; // d7
  double v40; // d5
  int v41; // r1
  int v42; // r2
  double v43; // d7
  int v44; // r1
  int v45; // r12
  int v46; // r2
  double v47; // d0
  double v48; // r0
  double v49; // d0
  int v50; // r1
  __int64 v51; // r10
  int v52; // r12
  int v53; // r1
  unsigned int v54; // r0
  int v55; // r3
  double *v56; // r4
  __int64 v57; // r0

  v3 = *(int **)(a1 + 84);
  v4 = *v3;
  v5 = *(_DWORD *)(*v3 + 3180);
  v6 = (double *)(*v3 + 3152);
  v7 = (*(_DWORD *)(*v3 + 3164) + 1) % 80;
  result = *v3 + 8 * v7;
  *(_DWORD *)(*v3 + 3164) = v7;
  v9 = v7 & 7;
  if ( v7 <= 0 )
    v9 = -(-v7 & 7);
  v10 = v4 + 8 * v9;
  v11 = (v1 - *(double *)(result + 64)) / (double)(5 * v5) + *(double *)(result + 64);
  *(double *)(result + 64) = v11;
  *(double *)(v10 + 3016) = v1;
  *(double *)(v10 + 3080) = v11;
  v12.n64_u64[0] = *(_QWORD *)(v6 - 1);
  if ( v12.n64_f64[0] > 0.0 && v11 <= 0.0 )
  {
    v12.n64_u32[0] = v9 - 4;
    *(double *)(v4 + 720) = *(double *)(v4 + 720) + vcvt_n_f64_s32(v12, 3u);
  }
  *(v6 - 1) = v11;
  if ( !v7 )
  {
    v13 = *(double *)(v4 + 2992);
    v14 = *(double *)(v4 + 2984);
    *(double *)(v4 + 3000) = v13;
    *(double *)(v4 + 3008) = v14;
    v15 = *(_DWORD *)(v4 + 768);
    if ( v13 < 100.0 )
      v15 |= 1u;
    *(_QWORD *)(v4 + 2992) = 0xC12E848000000000LL;
    *(_QWORD *)(v4 + 2984) = 0x412E848000000000LL;
    if ( v13 < 100.0 )
      *(_DWORD *)(v4 + 768) = v15;
    if ( v13 <= 0.0 )
    {
      *(_DWORD *)(v4 + 744) = 0;
      *(_DWORD *)(v4 + 748) = 0;
    }
    else
    {
      v16 = (v13 - v14) / v13;
      *(double *)(v4 + 744) = v16;
      if ( v16 >= 0.5 )
      {
LABEL_13:
        if ( (v15 & 0xF) != 0 )
        {
          v18 = 16.0;
          v17 = 2.0;
          *(_DWORD *)(v4 + 3180) = 2;
          *(_DWORD *)(v4 + 3184) = 0;
        }
        else
        {
          v17 = (double)*(int *)(v4 + 3180);
          v18 = v17 * 4.0 * v17;
        }
        result = 0;
        v19 = *(double *)(v4 + 720);
        v20 = *(double *)(v4 + 712);
        v21 = *(double *)(v4 + 704);
        v22 = (double)*(int *)(v4 + 3160);
        *(_DWORD *)(v4 + 720) = 0;
        *(_DWORD *)(v4 + 724) = 0;
        v23 = v22 * v19 / 80.0;
        *(double *)(v4 + 728) = v23;
        v24 = v23 / v18 + v20;
        *(double *)(v4 + 704) = v21 + v23 / v17;
        if ( v24 <= 2.0 )
        {
          if ( v24 < -2.0 )
          {
            *(double *)(v4 + 712) = -2.0;
            *(_DWORD *)(v4 + 768) = v15 | 2;
          }
          else
          {
            *(double *)(v4 + 712) = v24;
          }
        }
        else
        {
          *(double *)(v4 + 712) = 2.0;
          *(_DWORD *)(v4 + 768) = v15 | 2;
        }
        return result;
      }
    }
    v15 |= 4u;
    *(_DWORD *)(v4 + 768) = v15;
    goto LABEL_13;
  }
  if ( v9 != 7 )
    return result;
  v25 = *(_DWORD *)(v4 + 3192) + 1;
  v26 = (*(double *)(v4 + 3096) - *(double *)(v4 + 3128)) * 0.5;
  v27 = 2 * *(_DWORD *)(v4 + 3196);
  v28 = *(double *)(v4 + 2984);
  if ( *(double *)(v4 + 2992) < v26 )
    *(double *)(v4 + 2992) = v26;
  if ( v28 > v26 )
    *(double *)(v4 + 2984) = v26;
  v29 = *(double *)(v4 + 3000);
  v30 = *(double *)(v4 + 3008);
  *(_DWORD *)(v4 + 3196) = v27;
  v31 = v25 % 10;
  v32 = (v29 + v30) * 0.5;
  *(_DWORD *)(v4 + 3192) = v25 % 10;
  if ( v32 <= v26 )
    v27 |= 1u;
  result = v27 & 0x303C0F03;
  if ( v32 <= v26 )
    *(_DWORD *)(v4 + 3196) = v27;
  if ( result != 806093568 )
  {
    result = v4 + 3040;
    v33 = (double *)(v4 + 2976);
    v34 = *(double *)(v4 + 2976);
    v35 = 2 * *(_DWORD *)(v4 + 3200);
    v36 = (*(double *)(v4 + 3032) - *(double *)(v4 + 3064)) * 0.5;
    *(_DWORD *)(v4 + 3200) = v35;
    if ( v34 > v36 )
      goto LABEL_30;
    goto LABEL_29;
  }
  v37 = v25 == 10 * (v25 / 10);
  if ( v31 )
    v31 = *(_DWORD *)(v4 + 768);
  v33 = (double *)(v4 + 2976);
  v38 = *(double *)(v4 + 3032);
  if ( !v37 )
    v31 |= 8u;
  v39 = *v33;
  if ( !v37 )
    *(_DWORD *)(v4 + 768) = v31;
  v40 = *(double *)(v4 + 3064);
  v31 = 0;
  v41 = *(_DWORD *)(v4 + 3200);
  *(_DWORD *)(v4 + 3192) = 0;
  v35 = 2 * v41;
  *(_DWORD *)(v4 + 3200) = v35;
  v36 = (v38 - v40) * 0.5;
  if ( v39 > v36 )
  {
LABEL_47:
    v42 = *(_DWORD *)(v4 + 3176) - v7;
    v43 = -*(double *)(v4 + 728);
    *(double *)(v4 + 736) = v43;
    if ( (unsigned int)(v42 + 1) <= 2 )
    {
      v44 = *(_DWORD *)(v4 + 3184) + 1;
      *(_DWORD *)(v4 + 3184) = v44;
      if ( v44 <= 20 * v5 )
      {
        v43 = v43 - (double)v42;
        *(double *)(v4 + 736) = v43;
LABEL_55:
        v46 = *(_DWORD *)(v4 + 3160);
        v47 = *v6;
        HIDWORD(v48) = *(_DWORD *)(v4 + 52);
        *(_DWORD *)(v4 + 56) = *(_DWORD *)(v4 + 48);
        *(_DWORD *)(v4 + 60) = HIDWORD(v48);
        v49 = v47 + (double)v46 * (v43 / 8000.0);
        LODWORD(v48) = 32;
        ldexp(v48, v46);
        if ( v49 < 0.0 )
        {
          LODWORD(v57) = sub_8C010(-v49);
          v51 = -v57;
        }
        else
        {
          LODWORD(v51) = sub_8C010(v49);
          HIDWORD(v51) = v50;
        }
        v52 = *(unsigned __int8 *)(v4 + 3200);
        v53 = *(_DWORD *)(v4 + 28);
        *(_DWORD *)(v4 + 48) = *(_DWORD *)(v4 + 24);
        *(_DWORD *)(v4 + 52) = v53;
        v54 = *(_DWORD *)(v4 + 52);
        v55 = *(_DWORD *)(v4 + 48) - HIDWORD(v51);
        if ( v54 < (unsigned int)v51 )
          --v55;
        *(_DWORD *)(v4 + 48) = v55;
        *(_DWORD *)(v4 + 52) = v54 - v51;
        if ( v52 == 224 )
          goto LABEL_76;
        if ( v52 <= 224 )
        {
          if ( v52 == 128 )
            goto LABEL_77;
          if ( v52 != 192 )
          {
            if ( v52 )
            {
LABEL_64:
              sub_48698(a1, 0);
              *(_DWORD *)(v4 + 768) |= 0x10u;
LABEL_65:
              v56 = (double *)(v4 + 2960);
              result = 0;
              if ( *v56 <= v36 )
                v36 = *v56;
              *v33 = (v36 + *(v33 - 1)) * 0.5;
              *v56 = 1000000.0;
              *(v33 - 1) = -1000000.0;
              return result;
            }
LABEL_77:
            sub_48698(a1, 0);
            goto LABEL_65;
          }
LABEL_76:
          sub_48698(a1, 1);
          goto LABEL_65;
        }
        if ( v52 != 248 )
        {
          if ( v52 <= 248 )
          {
            if ( v52 != 240 )
              goto LABEL_64;
            goto LABEL_76;
          }
          if ( v52 != 252 && v52 != 254 )
            goto LABEL_64;
        }
        sub_48698(a1, 2);
        goto LABEL_65;
      }
      v45 = v5 + 1;
      if ( v45 <= 10 )
        *(_DWORD *)(v4 + 3180) = v45;
      else
        v42 = 10;
      if ( v45 > 10 )
        *(_DWORD *)(v4 + 3180) = v42;
    }
    *(_DWORD *)(v4 + 3176) = v7;
    *(_DWORD *)(v4 + 3184) = 0;
    goto LABEL_55;
  }
LABEL_29:
  *(_DWORD *)(v4 + 3200) = v35 | 1;
LABEL_30:
  switch ( v31 )
  {
    case 0:
      goto LABEL_47;
    case 1:
      goto LABEL_38;
    case 2:
      if ( *(v33 - 1) < v36 )
LABEL_38:
        *(v33 - 1) = v36;
      break;
    case 9:
      *(double *)(v4 + 2960) = v36;
      break;
    default:
      return result;
  }
  return result;
}
// 48D44: variable 'v1' is possibly undefined
// 49180: variable 'v50' is possibly undefined
// 49254: variable 'v57' is possibly undefined

//----- (000492D0) --------------------------------------------------------
int __fastcall sub_492D0(int a1)
{
  double v1; // d0
  int v3; // r4
  double v4; // d6
  double v5; // d5
  double v6; // d4
  double v7; // d3
  double v8; // d2
  double v9; // d1
  double v10; // d8
  double v11; // d9
  double v12; // d14
  double v13; // d7
  double v14; // d15
  double v15; // d7
  double v16; // d8
  double v17; // d6
  double v18; // d5
  double v19; // d4
  int v20; // r0
  unsigned int v21; // r7
  double v22; // d1
  double v23; // d15
  double v24; // d4
  double v25; // d0
  double v26; // d9
  int result; // r0
  int v28; // r1

  v3 = **(_DWORD **)(a1 + 84);
  v4 = *(double *)(v3 + 2904);
  *(double *)(v3 + 2912) = v4;
  v5 = *(double *)(v3 + 2896);
  *(double *)(v3 + 2904) = v5;
  v6 = *(double *)(v3 + 2888);
  *(double *)(v3 + 2896) = v6;
  v7 = *(double *)(v3 + 2880);
  *(double *)(v3 + 2888) = v7;
  v8 = *(double *)(v3 + 2872);
  *(double *)(v3 + 2880) = v8;
  v9 = *(double *)(v3 + 2864);
  *(double *)(v3 + 2872) = v9;
  v10 = *(double *)(v3 + 2856);
  *(double *)(v3 + 2864) = v10;
  v11 = *(double *)(v3 + 2848);
  *(double *)(v3 + 2856) = v11;
  v12 = *(double *)(v3 + 752);
  v13 = v1
      - (v5 * -3.87518
       + v4 * 0.6505491
       + v6 * 11.5118
       + v7 * -21.41264
       + v8 * 27.12837
       + v9 * -23.84486
       + v10 * 14.27663
       + v11 * -5.352734);
  v14 = v11 * -0.02055878 + v13 * 0.004952157;
  *(double *)(v3 + 2848) = v13;
  v15 = *(double *)(v3 + 2944);
  v16 = v14
      + v10 * 0.04401413
      + v9 * -0.06558851
      + v8 * 0.07462108
      + v7 * -0.06558851
      + v6 * 0.04401413
      + v5 * -0.02055878
      + v4 * 0.004952157;
  *(double *)(v3 + 752) = v12 + v16 * v16;
  *(double *)(v3 + 2952) = v15;
  v17 = *(double *)(v3 + 2936);
  *(double *)(v3 + 2944) = v17;
  v18 = *(double *)(v3 + 2928);
  *(double *)(v3 + 2936) = v18;
  v19 = *(double *)(v3 + 2920);
  v20 = *(_DWORD *)(v3 + 3188);
  v21 = *(_DWORD *)(v3 + 3160);
  *(double *)(v3 + 2928) = v19;
  v22 = v19 * -0.01174951;
  v23 = v17 * -3.589893 + v15 * 0.8694604 + v18 * 5.570154 + v19 * -3.849667;
  v24 = *(double *)(v3 + 760);
  v25 = v1 - v23;
  *(double *)(v3 + 2920) = v25;
  v26 = v22 + v25 * 0.003215696 + v18 * 0.01712074 + v17 * -0.01174951 + v15 * 0.003215696;
  *(double *)(v3 + 760) = v24 + v26 * v26;
  result = sub_8BB9C(v20 + 1, v21);
  *(_DWORD *)(v3 + 3188) = v28;
  if ( !v28 )
    return sub_48CB8(a1);
  return result;
}
// 493BC: variable 'v1' is possibly undefined
// 49484: variable 'v28' is possibly undefined

//----- (00049588) --------------------------------------------------------
int __fastcall sub_49588(double a1, int a2)
{
  _DWORD *v2; // r6
  int v3; // r8
  double v4; // d0
  double *v5; // r9
  int v6; // r4
  int v7; // r1
  unsigned int v8; // lr
  int v9; // r3
  int v10; // r1
  bool v11; // cc
  __int64 v12; // r0
  char *v13; // r5
  double v14; // d7
  int v15; // r2
  int v16; // r3
  double v17; // d14
  bool v18; // cf
  int v19; // r3
  int v20; // lr
  int v21; // r2
  double v22; // d7
  double v23; // d6
  __int64 v24; // r0
  int v25; // r2
  int *v26; // r3
  int v27; // r3
  int v28; // r0
  double v29; // d7
  char v30; // t1
  double v31; // d14
  double v32; // d4
  int v33; // r2
  int v34; // r3
  __int64 v35; // r0
  __int64 v37; // [sp+0h] [bp-1Ch]

  v2 = (_DWORD *)LODWORD(a1);
  v3 = *(_DWORD *)(LODWORD(a1) + 4);
  v4 = (double)*(int *)(LODWORD(a1) + 84) / 8000.0;
  v5 = *(double **)(v3 + 84);
  v6 = *(_DWORD *)v5;
  LODWORD(a1) = 32;
  ldexp(a1, a2);
  if ( v4 < 0.0 )
  {
    LODWORD(v35) = sub_8C010(-v4);
    v37 = -v35;
  }
  else
  {
    LODWORD(v37) = sub_8C010(v4);
    HIDWORD(v37) = v7;
  }
  v8 = v2[19];
  v9 = v2[18] - HIDWORD(v37);
  v10 = v2[21];
  if ( v8 < (unsigned int)v37 )
    --v9;
  v2[19] = v8 - v37;
  v11 = v10 <= 0;
  v2[18] = v9;
  v12 = *((_QWORD *)v2 + 9);
  *(_QWORD *)(v6 + 24) = v12;
  if ( !v11 )
  {
    v13 = (char *)(v2 + 22);
    do
    {
      v30 = *v13++;
      v31 = *(double *)(v6 + 8 * (unsigned __int8)~v30 + 776);
      v32 = (*(double *)(v6 + 712) + clock_codec) / 8000.0 + *(double *)(v6 + 704) + v5[94] / 1000000.0;
      *(double *)(v6 + 704) = v32;
      if ( v32 >= 0.5 )
      {
        *(double *)(v6 + 704) = v32 - 1.0;
      }
      else
      {
        if ( v32 < -0.5 )
        {
          *(double *)(v6 + 704) = v32 + 1.0;
          sub_492D0(v3);
        }
        sub_492D0(v3);
      }
      v14 = *(double *)(v6 + 2824);
      v15 = *(_DWORD *)(v6 + 28);
      v16 = *(_DWORD *)(v6 + 36);
      v17 = fabs(v31);
      v18 = __CFADD__(v16, v15);
      v19 = v16 + v15;
      v20 = *(_DWORD *)(v6 + 24);
      if ( v14 < v17 )
        v14 = v17;
      v21 = *(_DWORD *)(v6 + 2844);
      *(_DWORD *)(v6 + 28) = v19;
      ++v21;
      LODWORD(v12) = 274877907 * v21;
      *(_DWORD *)(v6 + 24) = v20 + *(_DWORD *)(v6 + 32) + v18;
      *(double *)(v6 + 2824) = (v17 - v14) / 1000.0 + v14;
      *(_DWORD *)(v6 + 2844) = v21 % 8000;
      if ( v21 != 8000 * (v21 / 8000) )
        continue;
      v22 = *(double *)(v6 + 760);
      v23 = *(double *)(v6 + 752);
      if ( v23 <= v22 )
        LOWORD(v24) = 10381;
      else
        LOWORD(v24) = -28396;
      if ( v23 <= v22 )
        WORD2(v24) = 12478;
      else
        WORD2(v24) = 25711;
      if ( v23 <= v22 )
      {
        WORD1(v24) = 3565;
        v25 = 10;
      }
      else
      {
        WORD1(v24) = 5473;
        v25 = 1;
      }
      if ( v23 <= v22 )
        HIWORD(v24) = 16249;
      else
        HIWORD(v24) = 16238;
      *(_DWORD *)(v6 + 3160) = v25;
      *(_QWORD *)(v6 + 3152) = v24;
      v26 = *(int **)(v3 + 84);
      *(_QWORD *)(v6 + 760) = 0;
      *(_QWORD *)(v6 + 752) = 0;
      v27 = *v26;
      v28 = *(_DWORD *)(v27 + 2836);
      v29 = *(double *)(v27 + 3000);
      if ( v29 >= 2000.0 )
      {
        if ( v29 <= 3000.0 )
          goto LABEL_27;
        v28 -= 4;
        if ( v28 < 0 )
        {
          v28 = 0;
          *(_DWORD *)(v27 + 2836) = 0;
          goto LABEL_27;
        }
      }
      else
      {
        v28 += 4;
        if ( v28 > 255 )
          v28 = 255;
      }
      *(_DWORD *)(v27 + 2836) = v28;
LABEL_27:
      LODWORD(v12) = sub_612E0(v28, *(_DWORD *)(v27 + 2840), *(_DWORD *)(v27 + 2832));
    }
    while ( v2[21] > v13 - (char *)(v2 + 22) );
  }
  if ( ((_BYTE)v5[96] & 2) != 0 )
    v33 = 2;
  else
    v33 = 1;
  v34 = (_BYTE)v5[96] & 4;
  *(_DWORD *)(v6 + 2832) = v33;
  if ( v34 )
    v34 = 127;
  *(_DWORD *)(v6 + 2840) = v34;
  return v12;
}
// 495EC: variable 'v7' is possibly undefined
// 4989C: variable 'v35' is possibly undefined
// 108300: using guessed type double clock_codec;

//----- (000498E8) --------------------------------------------------------
int __fastcall sub_498E8(int a1, int a2, int a3)
{
  __int16 *v3; // r6
  int v8; // r3
  int v9; // r12
  __int16 *v10; // r0
  int v11; // lr
  int v12; // r3

  v3 = (__int16 *)(a3 + 500);
  if ( (*(&off_B46E4[5 * *(__int16 *)(a3 + 502)] + *(__int16 *)(a3 + 500)))() == 1 )
  {
    v8 = *(__int16 *)(a3 + 502);
    v9 = *v3;
    *(_WORD *)(a3 + 496) = 0;
    v10 = (__int16 *)((char *)&unk_9795C + 10 * v8 + 2 * v9);
    v11 = *v10;
    v12 = v10[56];
    if ( v9 != v12 )
    {
      *(_BYTE *)(a3 + 15) = 0;
      *(_WORD *)(a3 + 498) = 0;
      *(_WORD *)(a3 + 504) = 0;
      *(_DWORD *)(a3 + 56) = 0;
      *(_DWORD *)(a3 + 488) = 0;
      *(_BYTE *)(a3 + 492) = 0;
      *(_WORD *)(a3 + 406) = 0;
      if ( !v12 )
        *(_WORD *)(a3 + 12) = 3;
    }
    *v3 = v12;
    if ( v11 )
    {
      *(_WORD *)(a3 + 502) = v11;
      sub_498E8(a1, a2, a3);
    }
  }
  *(_WORD *)(a3 + 502) = 0;
  return 0;
}
// B46E4: using guessed type int (*off_B46E4[135])();

//----- (00049A14) --------------------------------------------------------
int sub_49A14()
{
  return 0;
}

//----- (00049A5C) --------------------------------------------------------
int sub_49A5C()
{
  return 1;
}

//----- (00049AA4) --------------------------------------------------------
int __fastcall sub_49AA4(int a1, int a2, int a3)
{
  *(_BYTE *)(a3 + 15) = 0;
  *(_WORD *)(a3 + 504) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(_DWORD *)(a3 + 488) = 0;
  *(_BYTE *)(a3 + 492) = 0;
  *(_WORD *)(a3 + 406) = 0;
  return 1;
}

//----- (00049B10) --------------------------------------------------------
int __fastcall sub_49B10(int a1, int a2, _WORD *a3)
{
  __int16 *v3; // r6
  int v8; // r0
  int v9; // r3
  int v10; // r2
  int v11; // r12

  v3 = a3 + 256;
  if ( (*(&off_B46E4[5 * (__int16)a3[257] + 55] + (__int16)a3[256]))() == 1 )
  {
    v8 = *v3;
    v9 = 2 * (5 * (__int16)a3[257] + v8);
    v10 = *(__int16 *)((char *)&unk_97ADC + v9);
    v11 = *(__int16 *)((char *)&unk_9795C + v9 + 224);
    if ( v8 != v10 )
    {
      a3[253] = 0;
      a3[255] = 0;
      a3[258] = 0;
    }
    *v3 = v10;
    if ( v11 )
    {
      a3[257] = v11;
      sub_49B10(a1, a2, a3);
    }
  }
  a3[257] = 0;
  return 0;
}
// B46E4: using guessed type int (*off_B46E4[135])();

//----- (00049C20) --------------------------------------------------------
int __fastcall sub_49C20(int a1)
{
  _DWORD *v1; // r1
  _WORD *v2; // r2

  v1 = *(_DWORD **)(a1 + 84);
  v2 = (_WORD *)*v1;
  v2[257] = 3;
  sub_49B10(a1, (int)v1, v2);
  return 0;
}

//----- (00049C80) --------------------------------------------------------
int __fastcall sub_49C80(int a1)
{
  _DWORD *v1; // r1
  _WORD *v2; // r2

  v1 = *(_DWORD **)(a1 + 84);
  v2 = (_WORD *)*v1;
  v2[257] = 1;
  sub_49B10(a1, (int)v1, v2);
  return 1;
}

//----- (00049CE0) --------------------------------------------------------
int __fastcall sub_49CE0(int a1, int a2, int a3)
{
  *(_WORD *)(a3 + 508) = 0;
  return 0;
}

//----- (00049D34) --------------------------------------------------------
unsigned int __fastcall sub_49D34(int a1, int a2)
{
  int v4; // r0
  void *v5; // r4
  char v7[60]; // [sp+8h] [bp-44h] BYREF

  v4 = *(_DWORD *)(a2 + 84);
  v5 = *(void **)v4;
  if ( *(_DWORD *)(v4 + 28) != -1 )
    sub_18E64(v4 + 8);
  if ( v5 )
    free(v5);
  sub_6C054((int)v7, 0x3Cu, "JJY stopped. unit=%d mode=%d", a1, *(_DWORD *)(a2 + 76));
  return sub_41F44((unsigned __int16 *)(a2 + 16), v7);
}

//----- (00049DE0) --------------------------------------------------------
void __fastcall sub_49DE0(int a1, int a2)
{
  int v2; // r7
  int v3; // r4
  int v5; // r2
  int v6; // r1
  int v7; // r3
  int v8; // r2
  int v9; // r3
  int v10; // r9
  _DWORD *v11; // r11
  _WORD *v12; // r8
  __int16 *v13; // r3
  int v14; // r1
  int v15; // r0
  int v16; // r2
  int v17; // r2
  int v18; // r3
  int v19; // r3
  __int16 *v20; // [sp+4h] [bp-10h]

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(_DWORD *)v2;
  if ( !*(_BYTE *)(*(_DWORD *)v2 + 14) && *(_BYTE *)v3 == 100 )
  {
    v5 = 2 * *(__int16 *)(v3 + 500);
    v6 = *(__int16 *)((char *)&unk_97B7C + v5);
    if ( *(_WORD *)((char *)&unk_97B7C + v5) )
    {
      v7 = (__int16)(*(_WORD *)(v3 + 496) + 1);
      *(_WORD *)(v3 + 496) = v7;
      if ( v6 <= v7 )
      {
        *(_WORD *)(v3 + 502) = 9;
        sub_498E8(a2, v2, v3);
        v5 = 2 * *(__int16 *)(v3 + 500);
      }
    }
    v8 = *(__int16 *)((char *)&unk_97B88 + v5);
    if ( v8 )
    {
      v9 = (__int16)(*(_WORD *)(v3 + 498) + 1);
      *(_WORD *)(v3 + 498) = v9;
      if ( v8 <= v9 )
      {
        *(_WORD *)(v3 + 502) = 10;
        sub_498E8(a2, v2, v3);
      }
    }
    v10 = *(__int16 *)(v3 + 512);
    if ( word_97B94[v10] || word_97BA0[v10] )
    {
      v11 = *(_DWORD **)(a2 + 84);
      v12 = (_WORD *)*v11;
      v13 = (__int16 *)(*v11 + 512);
      v14 = *v13;
      v15 = (__int16)word_97B94[v14];
      if ( word_97B94[v14] )
      {
        v16 = (__int16)(v12[254] + 1);
        v12[254] = v16;
        if ( v15 <= v16 )
        {
          v12[257] = 14;
          v20 = v13;
          sub_49B10(a2, (int)v11, v12);
          v14 = *v20;
        }
      }
      v17 = (__int16)word_97BA0[v14];
      if ( word_97BA0[v14] )
      {
        v18 = (__int16)(v12[255] + 1);
        v12[255] = v18;
        if ( v17 <= v18 )
        {
          v12[257] = 15;
          sub_49B10(a2, (int)v11, v12);
        }
      }
      v19 = *(__int16 *)(v3 + 512);
      if ( v10 != v19 )
      {
        if ( !*(_WORD *)(v3 + 512) )
        {
          *(_WORD *)(v3 + 502) = 3;
          goto LABEL_22;
        }
        if ( v19 == 3 )
        {
          *(_WORD *)(v3 + 502) = 2;
LABEL_22:
          sub_498E8(a2, v2, v3);
        }
      }
    }
  }
}
// 1BC: using guessed type int elf_hash_bucket[521];
// 97B94: using guessed type _WORD word_97B94[6];
// 97BA0: using guessed type _WORD word_97BA0[6];

//----- (0004A084) --------------------------------------------------------
unsigned int __fastcall sub_4A084(int a1, int a2, char *s)
{
  const char *v4; // r4
  size_t v5; // r7
  int v6; // r0
  char *v7; // r5
  unsigned int v8; // r4
  const unsigned __int16 **v9; // r8
  _BYTE *v10; // r1
  _BOOL4 v11; // r2
  unsigned int v12; // r3
  unsigned int v13; // t1
  char *v14; // r11
  size_t v15; // r12
  int v16; // r2
  _BYTE *v17; // r0
  unsigned int v18; // r1
  _BYTE *v19; // r0
  _BYTE *v20; // r4
  int v22; // [sp+0h] [bp-FCh]
  void *v23; // [sp+4h] [bp-F8h]
  _DWORD dest[33]; // [sp+Ch] [bp-F0h] BYREF
  int v25; // [sp+90h] [bp-6Ch] BYREF
  _BYTE v26[95]; // [sp+94h] [bp-68h] BYREF
  _BYTE v27[9]; // [sp+F3h] [bp-9h] BYREF

  v22 = a1;
  v23 = &_stack_chk_guard;
  switch ( a2 )
  {
    case 2:
      v4 = "--> ";
      break;
    case 3:
      v4 = "<-- ";
      break;
    case 4:
      v4 = "--- ";
      break;
    case 5:
      v4 = "=== ";
      break;
    case 6:
      v4 = "-W- ";
      break;
    case 7:
      v4 = "-X- ";
      break;
    case 8:
      v4 = "!!! ";
      break;
    default:
      v4 = "JJY ";
      break;
  }
  v5 = strlen(s);
  v6 = *(_DWORD *)v4;
  v26[0] = *((_DWORD *)v4 + 1);
  v25 = v6;
  memcpy(dest, off_B6ED0, sizeof(dest));
  if ( v5 )
  {
    v7 = s;
    v8 = 0;
    v9 = _ctype_b_loc();
    do
    {
      v13 = (unsigned __int8)*v7++;
      v12 = v13;
      if ( ((*v9)[v13] & 0x4000) != 0 )
      {
        if ( v8 == 95 )
        {
          v20 = v27;
          goto LABEL_25;
        }
        v10 = &v27[v8++ + 5];
        *(v10 - 100) = v12;
      }
      else if ( v12 > 0x20 )
      {
        if ( v8 + 6 > 0x5F )
        {
LABEL_27:
          v20 = &v26[v8];
          goto LABEL_25;
        }
        v18 = 96 - v8;
        v19 = &v26[v8];
        v8 += 5;
        sub_6C054((int)v19, v18, "<x%X>", v12, v22, v23);
      }
      else
      {
        v14 = (char *)dest[v12];
        v15 = strlen(v14);
        if ( v8 + 1 + v15 > 0x5F )
          goto LABEL_27;
        v16 = 96 - v8;
        v17 = &v26[v8];
        v8 += v15;
        sub_6D4DC(v17, (unsigned __int8 *)v14, v16);
      }
      v11 = v5 > v7 - s;
      if ( v8 > 0x5F )
        v11 = 0;
    }
    while ( v11 );
    if ( v8 > 0x5F )
      v20 = v27;
    else
      v20 = &v26[v8];
  }
  else
  {
    v20 = v26;
  }
LABEL_25:
  *v20 = 0;
  return sub_41F44((unsigned __int16 *)(v22 + 16), (const char *)&v25);
}
// 4A238: variable 'v22' is possibly undefined
// 4A238: variable 'v23' is possibly undefined
// B6ED0: using guessed type char *off_B6ED0[32];

//----- (0004A2E0) --------------------------------------------------------
int __fastcall sub_4A2E0(__int16 *a1, int a2)
{
  if ( write(*(_DWORD *)(a2 + 28), "ATH0\r\n", 6u) != 6 )
    sub_394A0(a1, 3);
  sub_4A084((int)a1, 2, "ATH0\r\n");
  return 1;
}

//----- (0004A370) --------------------------------------------------------
int __fastcall sub_4A370(__int16 *a1, int a2)
{
  sub_4A2E0(a1, a2);
  return 1;
}

//----- (0004A3BC) --------------------------------------------------------
int __fastcall sub_4A3BC(__int16 *a1, int a2)
{
  if ( write(*(_DWORD *)(a2 + 28), "+++", 3u) != 3 )
    sub_394A0(a1, 3);
  sub_4A084((int)a1, 2, "+++");
  return 0;
}

//----- (0004A44C) --------------------------------------------------------
int __fastcall sub_4A44C(__int16 *a1, int a2, _WORD *a3)
{
  int v6; // r4
  int v7; // r2

  v6 = (__int16)(a3[253] + 1);
  v7 = (__int16)a3[256];
  a3[253] = v6;
  if ( v6 >= sub_8B908((__int16)word_97BA0[v7], (__int16)word_97B94[v7]) )
    return sub_4A2E0(a1, a2);
  sub_4A3BC(a1, a2);
  a3[254] = 0;
  return 0;
}
// 97B94: using guessed type _WORD word_97B94[6];
// 97BA0: using guessed type _WORD word_97BA0[6];

//----- (0004A52C) --------------------------------------------------------
int __fastcall sub_4A52C(__int16 *a1, int a2, int a3)
{
  if ( write(*(_DWORD *)(a2 + 28), "\r", 1u) != 1 )
    sub_394A0(a1, 3);
  sub_4A084((int)a1, 2, "\r");
  *(_WORD *)(a3 + 496) = 0;
  return 1;
}

//----- (0004A5CC) --------------------------------------------------------
int __fastcall sub_4A5CC(__int16 *a1, int a2)
{
  if ( write(*(_DWORD *)(a2 + 28), "TJJY\r", 5u) != 5 )
    sub_394A0(a1, 3);
  sub_4A084((int)a1, 2, "TJJY\r");
  return 0;
}

//----- (0004A65C) --------------------------------------------------------
int __fastcall sub_4A65C(__int16 *a1, int a2, int a3)
{
  _WORD *v3; // r2
  int v6; // r3
  int v7; // r0
  int v8; // r8
  size_t v9; // r2
  char *v10; // r7
  int v12; // r3
  int v13; // r12
  int v14; // r3
  char v15[48]; // [sp+Ch] [bp-34h] BYREF
  int v16; // [sp+3Ch] [bp-4h]

  v3 = (_WORD *)(a3 + 516);
  v6 = (unsigned __int16)(*v3 + 1);
  v7 = _stack_chk_guard;
  *v3 = v6;
  v16 = v7;
  switch ( v6 )
  {
    case 1:
      v8 = 10;
      v9 = 10;
      v10 = "ATE0Q0V1\r\n";
      goto LABEL_3;
    case 2:
      v10 = v15;
      if ( (*(_BYTE *)(a2 + 768) & 4) != 0 )
        v12 = 2;
      else
        v12 = 0;
      if ( (*(_BYTE *)(a2 + 768) & 8) != 0 )
        v13 = 2;
      else
        v13 = 1;
      sub_6C054((int)v15, 0x2Eu, "ATM%dL%d\r\n", v12, v13);
      v9 = strlen(v15);
      v8 = v9;
      goto LABEL_3;
    case 3:
      v8 = 7;
      v9 = 7;
      v10 = "AT&K4\r\n";
      goto LABEL_3;
    case 4:
      v8 = 12;
      v9 = 12;
      v10 = "AT+MS=V22B\r\n";
      goto LABEL_3;
    case 5:
      v8 = 7;
      v9 = 7;
      v10 = "AT%C0\r\n";
      goto LABEL_3;
    case 6:
      v10 = v15;
      if ( (*(_BYTE *)(a2 + 768) & 2) != 0 )
        v14 = 3;
      else
        v14 = 0;
      sub_6C054((int)v15, 0x2Eu, "AT\\N%d\r\n", v14);
      v9 = strlen(v15);
      v8 = v9;
      goto LABEL_3;
    case 7:
      v8 = 6;
      v9 = 6;
      v10 = "ATH1\r\n";
LABEL_3:
      if ( write(*(_DWORD *)(a2 + 28), v10, v9) != v8 )
        sub_394A0(a1, 3);
      sub_4A084((int)a1, 2, v10);
      return 0;
    case 8:
      return 1;
    default:
      return 0;
  }
}

//----- (0004A838) --------------------------------------------------------
int __fastcall sub_4A838(__int16 *a1, int a2, int a3)
{
  return sub_4A65C(a1, a2, a3);
}

//----- (0004A880) --------------------------------------------------------
int __fastcall sub_4A880(__int16 *a1, int a2, int a3)
{
  *(_WORD *)(a3 + 516) = 0;
  return sub_4A65C(a1, a2, a3);
}

//----- (0004A8D4) --------------------------------------------------------
int __fastcall sub_4A8D4(__int16 *a1, int a2)
{
  int v3; // r3
  size_t v5; // r8
  char v7[48]; // [sp+Ch] [bp-34h] BYREF

  if ( (*(_BYTE *)(a2 + 768) & 1) != 0 )
    v3 = 80;
  else
    v3 = 84;
  sub_6C054((int)v7, 0x2Eu, "ATDW%c%s\r\n", v3, (const char *)sys_phone[0]);
  v5 = strlen(v7);
  if ( write(*(_DWORD *)(a2 + 28), v7, v5) != v5 )
    sub_394A0(a1, 3);
  sub_4A084((int)a1, 2, v7);
  return 0;
}
// B9218: using guessed type int sys_phone[];

//----- (0004A9A4) --------------------------------------------------------
unsigned int __fastcall sub_4A9A4(int a1, int a2)
{
  _DWORD *v4; // r1
  int v5; // r3
  int v6; // r2
  int v7; // r12
  int v8; // r3
  int v9; // r4
  int v10; // r1
  char v12[60]; // [sp+8h] [bp-40h] BYREF

  gettimeofday((struct timeval *)(a2 + 8 * (*(__int16 *)(a2 + 406) + 56)), 0);
  v4 = (_DWORD *)(a2 + 8 * *(__int16 *)(a2 + 406));
  v5 = v4[112];
  v6 = v4[102];
  v7 = v4[113] - v4[103];
  v4[113] = v7;
  v8 = v5 - v6;
  v4[112] = v8;
  if ( v7 < 0 )
  {
    --v8;
    v7 += 1000000;
    v4[113] = v7;
    v4[112] = v8;
  }
  v9 = v7 / 1000 + 1000 * v8;
  sub_6C054((int)v12, 0x3Cu, "* Loopback delay : %d.%03d mSec.", v9, v7 % 1000);
  if ( v9 <= 700 )
    v10 = 4;
  else
    v10 = 6;
  return sub_4A084(a1, v10, v12);
}

//----- (0004AAB4) --------------------------------------------------------
__int16 *__fastcall sub_4AAB4(int a1, _DWORD *a2, _DWORD *a3)
{
  int v4; // r1
  int v7; // r2
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r12
  int v12; // r3
  int v13; // r1
  int v14; // r1
  int v16; // r0
  int v17; // r0
  int v18; // r2
  const char *v19; // r12
  char v20[80]; // [sp+34h] [bp-54h] BYREF

  v4 = a3[6];
  v7 = a3[8];
  a2[47] = v4;
  v8 = sub_6EC68(v4, a3[7], v7);
  v9 = a3[12];
  v10 = a3[9];
  v11 = a3[10];
  a2[48] = v8;
  v12 = (_DWORD)&unk_F4240 * v9;
  v13 = a3[11];
  a2[50] = v11;
  if ( v10 - 9 >= 0 )
    a2[49] = v10 - 9;
  a2[51] = v13;
  a2[52] = v12;
  if ( v10 - 9 < 0 )
  {
    v16 = v8 - 1;
    a2[48] = v16;
    a2[49] = v10 + 15;
    if ( v16 <= 0 )
    {
      v17 = a2[47] - 1;
      a2[47] = v17;
      a2[48] = sub_6EC68(v17, 12, 31);
    }
  }
  if ( !sub_39CF8(a2) )
    return sub_394A0((__int16 *)a1, 6);
  v14 = a2[59];
  a2[56] = a2[58];
  a2[57] = v14;
  sub_39D44(a1);
  sub_6C054(
    (int)v20,
    0x50u,
    "%04d/%02d/%02d %02d:%02d:%02d.%03d JST   ( %04d/%03d %02d:%02d:%02d.%03d UTC )",
    a3[6],
    a3[7],
    a3[8],
    a3[9],
    a3[10],
    a3[11],
    a3[12],
    a2[47],
    a2[48],
    a2[49],
    a2[50],
    a2[51],
    a2[52] / 1000000);
  sub_4A084(a1, 5, v20);
  switch ( *(_BYTE *)(a1 + 296) )
  {
    case 0:
      v18 = 32;
      v19 = "Reject";
      break;
    case 1:
      v18 = 120;
      v19 = "FalseTick";
      break;
    case 2:
      v18 = 46;
      v19 = "Excess";
      break;
    case 3:
      v18 = 45;
      v19 = "Outlier";
      break;
    case 4:
      v18 = 43;
      v19 = "Candidate";
      break;
    case 5:
      v18 = 35;
      v19 = "Selected";
      break;
    case 6:
      v18 = 42;
      v19 = "Sys.Peer";
      break;
    case 7:
      v18 = 111;
      v19 = "PPS.Peer";
      break;
    default:
      v18 = 32;
      v19 = byte_97F7C;
      break;
  }
  sub_6C054(
    (int)v20,
    0x50u,
    "status %d [%c] %s : offset %3.3f mSec. : jitter %3.3f mSec.",
    *(unsigned __int8 *)(a1 + 296),
    v18,
    v19,
    *(double *)(a1 + 608) * 1000.0,
    *(double *)(a1 + 624) * 1000.0);
  return (__int16 *)sub_4A084(a1, 4, v20);
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (0004AD94) --------------------------------------------------------
int __fastcall sub_4AD94(int a1, _DWORD *a2, int a3)
{
  const char *v6; // r9
  size_t v7; // r6
  int v8; // r5
  int (**v9)(); // r2
  int (*v10)(); // r3
  int (*v11)(); // r7
  const char *v13; // r1
  int v14; // r0
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r12
  int v19; // r3
  int v20; // r5
  unsigned __int8 *v21; // r12
  unsigned __int8 *v22; // r1
  int v23; // lr
  int v24; // r9
  int v25; // r2
  int v26; // r3
  int v28; // r0
  int v29; // r6
  int v30; // r1
  int v31; // r0
  int v32; // r3
  int v33; // r6
  int v35; // r7
  _BOOL4 v36; // r7
  int v37; // r6
  int v38; // r3
  int v39; // r2
  int v40; // r1
  _BOOL4 v41; // r3
  int v42; // r0
  __int64 v43; // r2
  int v44; // r1
  int v45; // r7
  int v46; // r7
  int (*v47)(); // [sp+14h] [bp-78h]
  int v48; // [sp+14h] [bp-78h]
  int v49; // [sp+18h] [bp-74h]
  int v50; // [sp+20h] [bp-6Ch]
  int v51; // [sp+24h] [bp-68h]
  int v52; // [sp+28h] [bp-64h]
  char v53[80]; // [sp+34h] [bp-58h] BYREF

  if ( *(_WORD *)(a3 + 8) == 32 )
  {
    v6 = (const char *)(a3 + 300);
    v7 = *(_DWORD *)(a3 + 400);
  }
  else
  {
    v6 = (const char *)(a2 + 14);
    v7 = a2[46];
  }
  v8 = *(__int16 *)(a3 + 504);
  v9 = &off_B46E4[5 * v8];
  v10 = v9[137];
  v11 = v9[138];
  if ( v10 == (int (*)())v7 )
  {
    v13 = (const char *)v9[135];
    if ( v11 == (int (*)())&byte_6
      && *(unsigned __int8 *)(a3 + 300) == *(unsigned __int8 *)v13
      && *(__int16 *)(a3 + 406) <= 4 )
    {
      sub_4A9A4(a1, a3);
      ++*(_WORD *)(a3 + 406);
      return 0;
    }
    v47 = v9[137];
    v14 = strncmp(v6, v13, v7);
    v10 = v47;
    if ( !v14 )
    {
      sub_4A084(a1, 4, "* Echoback");
      return 0;
    }
    if ( v47 != off_B46E4[5 * v8 + 139] )
      goto LABEL_7;
  }
  else if ( (int (*)())v7 != v9[139] )
  {
    goto LABEL_6;
  }
  if ( v11 == (int (*)())((char *)&dword_0 + 1) )
  {
    v42 = sscanf(v6, "%4d%2d%2d", a3 + 24, a3 + 28, a3 + 32);
    v43 = *(_QWORD *)(a3 + 24);
    v44 = *(_DWORD *)(a3 + 32);
    if ( v42 == 3
      && (unsigned int)(v43 - 2000) <= 0x62
      && (unsigned int)(HIDWORD(v43) - 1) <= 0xB
      && (unsigned int)(v44 - 1) <= 0x1E )
    {
      return 0;
    }
    sub_6C054((int)v53, 0x4Fu, "# Invalid date : rc=%d year=%d month=%d day=%d", v42, (_DWORD)v43, HIDWORD(v43), v44);
    goto LABEL_23;
  }
  if ( v11 == (int (*)())((char *)&dword_0 + 3) )
  {
    if ( strncmp(v6, " 0", 2u) && strncmp(v6, "+1", 2u) && strncmp(v6, "-1", 2u) )
      goto LABEL_7;
    if ( sscanf(v6, "%2d", a3 + 52) == 1 && (unsigned int)(*(_DWORD *)(a3 + 52) + 1) <= 2 )
      return 0;
    sub_6C054((int)v53, 0x4Fu, "# Invalid leap : leapsecond=[%s]", v6);
LABEL_23:
    sub_4A084(a1, 7, v53);
    *(_BYTE *)(a3 + 15) = 1;
    return 0;
  }
  if ( v11 != (int (*)())((char *)&dword_0 + 2) )
  {
    if ( v10 != (int (*)())v7 )
    {
LABEL_6:
      if ( v11 == (int (*)())&byte_6 )
      {
        sub_6C054((int)v53, 0x4Fu, "* Ignore replay : [%s]", v6);
        sub_4A084(a1, 6, v53);
        return 0;
      }
    }
LABEL_7:
    *(_BYTE *)(a3 + 15) = 1;
    sub_6C054((int)v53, 0x4Fu, "# Unexpected reply : [%s]", v6);
    sub_4A084(a1, 7, v53);
    return 0;
  }
  v15 = sscanf(v6, "%2d%2d%2d", a3 + 36, a3 + 40, a3 + 44);
  v16 = *(_DWORD *)(a3 + 36);
  v17 = *(_DWORD *)(a3 + 40);
  v18 = *(_DWORD *)(a3 + 44);
  if ( v15 != 3 || v16 > 23 || v17 > 59 || v18 > 60 )
  {
    sub_6C054(
      (int)v53,
      0x4Fu,
      "# Invalid time : rc=%d hour=%d minute=%d second=%d",
      v15,
      v16,
      *(_DWORD *)(a3 + 40),
      v18);
    sub_4A084(a1, 7, v53);
    v16 = *(_DWORD *)(a3 + 36);
    v17 = *(_DWORD *)(a3 + 40);
    v18 = *(_DWORD *)(a3 + 44);
    *(_BYTE *)(a3 + 15) = 1;
  }
  v19 = *(_DWORD *)(a3 + 56);
  *(_DWORD *)(a3 + 4 * v19 + 60) = v18 + 60 * (v17 + 60 * v16);
  *(_DWORD *)(a3 + 56) = v19 + 1;
  if ( v19 != 5 )
    return 0;
  v20 = *(unsigned __int8 *)(a3 + 15);
  if ( *(_BYTE *)(a3 + 15) )
    return 0;
  if ( *(_DWORD *)(a1 + 76) == 100 )
  {
    *(_DWORD *)(a3 + 48) = v20;
    v20 = 1;
    goto LABEL_60;
  }
  v21 = (unsigned __int8 *)(a3 + 488);
  *(_WORD *)(a3 + 494) = v20;
  v22 = (unsigned __int8 *)(a3 + 488);
  v23 = *(__int16 *)(a3 + 406);
  v24 = v20;
  v25 = v20;
  v26 = v20;
  v49 = v20;
  v48 = v20;
  v51 = v20;
  v50 = v20;
  v52 = v20;
  while ( v23 > v26 )
  {
    if ( *v22++ )
      goto LABEL_42;
    v28 = a3 + 8 * v26;
    v29 = *(_DWORD *)(v28 + 448);
    if ( v29 > 0 || !v29 && *(int *)(v28 + 452) > 700000 )
      goto LABEL_42;
    if ( v25 )
    {
      if ( v29 < v24 )
      {
        v45 = *(_DWORD *)(v28 + 452);
LABEL_81:
        v52 = v45;
        v24 = *(_DWORD *)(v28 + 448);
        v48 = v26;
        goto LABEL_41;
      }
      if ( v29 == v24 )
      {
        v45 = *(_DWORD *)(v28 + 452);
        if ( v45 < v52 )
          goto LABEL_81;
      }
      if ( v29 <= v50 )
      {
        if ( v29 != v50 )
          goto LABEL_41;
        v46 = *(_DWORD *)(v28 + 452);
        if ( v46 <= v51 )
          goto LABEL_41;
      }
      else
      {
        v46 = *(_DWORD *)(v28 + 452);
      }
      v50 = *(_DWORD *)(v28 + 448);
      v51 = v46;
      v49 = v26;
    }
    else
    {
      v24 = *(_DWORD *)(v28 + 448);
      v50 = v24;
      v49 = v26;
      v51 = *(_DWORD *)(v28 + 452);
      v48 = v26;
      v52 = v51;
    }
LABEL_41:
    v25 = (__int16)(v25 + 1);
    *(_WORD *)(a3 + 494) = v25;
LABEL_42:
    if ( ++v26 == 5 )
      break;
  }
  if ( v25 <= 1 )
    goto LABEL_82;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = a3;
  do
  {
    if ( v23 <= v32 )
      break;
    if ( !*v21++ )
    {
      v35 = *(_DWORD *)(v33 + 448);
      if ( v35 <= 0 && (v35 || *(int *)(v33 + 452) <= 700000) )
      {
        if ( v25 == 2 )
          goto LABEL_55;
        if ( v49 != v32 )
        {
          v36 = v25 > 3;
          if ( v48 != v32 )
            v36 = 0;
          if ( !v36 )
          {
LABEL_55:
            ++v30;
            v31 += *(_DWORD *)(v33 + 452);
          }
        }
      }
    }
    ++v32;
    v33 += 8;
  }
  while ( v32 != 5 );
  if ( v30
    && (v37 = *(_DWORD *)(a1 + 76),
        v38 = sub_8B908(v31, v30) * (v37 - 100) / 100000,
        *(_DWORD *)(a3 + 48) = v38,
        v38 >= 0) )
  {
    v20 = 1;
  }
  else
  {
LABEL_82:
    *(_DWORD *)(a3 + 48) = 0;
  }
LABEL_60:
  v39 = *(_DWORD *)(a3 + 72);
  v40 = *(_DWORD *)(a3 + 68);
  v41 = v39 - 15 <= v40;
  if ( v39 < v40 )
    v41 = 0;
  if ( v41 && v39 + 1 == *(_DWORD *)(a3 + 76) && v39 + 2 == *(_DWORD *)(a3 + 80) )
  {
    sub_4AAB4(a1, a2, (_DWORD *)a3);
    if ( *(_DWORD *)(a1 + 76) != 100 )
    {
      if ( v20 )
      {
        sub_6C054(
          (int)v53,
          0x50u,
          "* Delay adjustment : %d mSec. ( valid=%hd/%d )",
          *(_DWORD *)(a3 + 48),
          *(__int16 *)(a3 + 494),
          5);
        sub_4A084(a1, 4, v53);
      }
      else
      {
        sub_6C054((int)v53, 0x50u, "* Delay adjustment : None ( valid=%hd/%d )", *(__int16 *)(a3 + 494), 5);
        sub_4A084(a1, 7, v53);
      }
    }
  }
  return 0;
}
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;
// B46E4: using guessed type int (*off_B46E4[135])();

//----- (0004B4B4) --------------------------------------------------------
bool __fastcall sub_4B4B4(int a1, int a2, int a3)
{
  __int16 *v3; // r5
  int v5; // r3
  int (**v8)(); // r2
  int v9; // r3
  int (**v10)(); // r2
  char *v11; // r9
  size_t v12; // r10
  __int16 v14; // r2
  int v15; // r3
  int v16; // r0
  int (**v17)(); // r2
  int (**v18)(); // r2
  char v19[120]; // [sp+Ch] [bp-7Ch] BYREF

  v3 = (__int16 *)(a3 + 504);
  v5 = *(__int16 *)(a3 + 504);
  if ( v5 <= 0 )
  {
    if ( !*(_WORD *)(a3 + 504) )
    {
      if ( *(_DWORD *)(a1 + 76) == 100 )
      {
        v14 = 8;
        v11 = "TIME\r";
      }
      else
      {
        v14 = 1;
        *(_DWORD *)(a3 + 488) = 0;
        *(_BYTE *)(a3 + 492) = 0;
        v11 = "LOOP\r";
        *(_WORD *)(a3 + 406) = 0;
      }
      v12 = 5;
      *v3 = v14;
      goto LABEL_14;
    }
    v9 = (__int16)(v5 + 1);
    v18 = &off_B46E4[5 * v9];
    v11 = (char *)v18[135];
    v12 = (size_t)v18[136];
  }
  else
  {
    v8 = &off_B46E4[5 * v5];
    if ( !v8[135] )
      return 1;
    if ( *(_DWORD *)(a1 + 76) != 100 && v8[138] == (int (*)())&byte_6 && *(__int16 *)(a3 + 406) <= 4 )
    {
      sub_4A9A4(a1, a3);
      v9 = (__int16)(*v3 + 1);
      ++*(_WORD *)(a3 + 406);
      v17 = &off_B46E4[5 * v9];
      v11 = (char *)v17[135];
      v12 = (size_t)v17[136];
    }
    else
    {
      v9 = (__int16)(v5 + 1);
      v10 = &off_B46E4[5 * v9];
      v11 = (char *)v10[135];
      v12 = (size_t)v10[136];
    }
  }
  *v3 = v9;
  if ( !v11 )
    return 1;
LABEL_14:
  if ( write(*(_DWORD *)(a2 + 28), v11, v12) != v12 )
    sub_394A0((__int16 *)a1, 3);
  v15 = *v3;
  if ( off_B46E4[5 * v15 + 138] == (int (*)())&byte_6 )
  {
    v16 = *(__int16 *)(a3 + 406);
    if ( v16 > 4 )
    {
      sub_6C054(
        (int)v19,
        0x77u,
        "refclock_jjy.c ; teljjy_conn_send ; iClockCommandSeq=%d iLoopbackCount=%d MAX_LOOPBACK=%d",
        v15,
        v16,
        5);
      sub_4A084(a1, 8, v19);
      sub_64E00(3, (unsigned __int8 *)"%s", v19);
      *(_BYTE *)(a3 + 405) = 0;
    }
    else
    {
      gettimeofday((struct timeval *)(a3 + 8 * (v16 + 51)), 0);
      *(_BYTE *)(a3 + 405) = 1;
    }
  }
  else
  {
    *(_BYTE *)(a3 + 405) = 0;
  }
  sub_4A084(a1, 2, v11);
  return off_B46E4[5 * *v3 + 140] == 0;
}
// 6: using guessed type char byte_6;
// B46E4: using guessed type int (*off_B46E4[135])();

//----- (0004B744) --------------------------------------------------------
int __fastcall sub_4B744(int a1, int a2)
{
  _DWORD *v2; // r5
  unsigned __int8 *v4; // r4
  int v5; // r3
  char v6; // r1
  char v7; // lr
  char v8; // r9
  char v9; // r12
  char v10; // lr
  char v11; // r12
  char v12; // r12
  char v13; // r12
  int result; // r0
  unsigned int v15; // r3
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int *v19; // r0
  int v20; // r3
  int v21; // r1
  int (**v22)(); // r2
  int v23; // r5
  char *v24; // r4
  size_t v25; // r2
  int v26; // r12
  int v27; // r3
  int (**v28)(); // r2
  _DWORD *v29; // r3
  int v30; // r1
  int v31; // r0
  _DWORD *v32; // r0
  int v33; // r3
  __int16 v34; // r12
  int v35; // r0
  _BYTE buf[16]; // [sp+Ch] [bp-40h] BYREF
  char v37[40]; // [sp+1Ch] [bp-30h] BYREF

  v2 = *(_DWORD **)(a2 + 84);
  v4 = (unsigned __int8 *)*v2;
  if ( *(_BYTE *)(*v2 + 10) )
    return sub_4A084(a2, 7, "Ignore polling because of error during initializing");
  v5 = v2[194];
  if ( v5 && !*((_DWORD *)v4 + 5) )
  {
    sub_394A0((__int16 *)a2, 1);
    v5 = v2[194];
  }
  v2[194] = v5 + 1;
  v6 = *(_BYTE *)(a2 + 298);
  buf[11] = 0;
  if ( v6 < 0 )
    v7 = 49;
  else
    v7 = 48;
  buf[4] = v7;
  if ( (v6 & 0x40) != 0 )
    v8 = 49;
  else
    v8 = 48;
  if ( (v6 & 0x20) != 0 )
    v9 = 49;
  else
    v9 = 48;
  buf[6] = v9;
  if ( (v6 & 0x10) != 0 )
    v10 = 49;
  else
    v10 = 48;
  buf[7] = v10;
  if ( (v6 & 8) != 0 )
    v11 = 49;
  else
    v11 = 48;
  buf[8] = v11;
  if ( (v6 & 4) != 0 )
    v12 = 49;
  else
    v12 = 48;
  buf[9] = v12;
  if ( (v6 & 2) != 0 )
    v13 = 49;
  else
    v13 = 48;
  buf[5] = v8;
  buf[10] = v13;
  buf[12] = 0;
  sub_6C054((int)v37, 0x28u, "polls=%ld reach=%s");
  result = sub_4A084(a2, 5, v37);
  v15 = *v4;
  *((_WORD *)v4 + 8) = 0;
  *((_WORD *)v4 + 9) = 0;
  *((_DWORD *)v4 + 5) = 0;
  v4[15] = 0;
  *((_DWORD *)v4 + 46) = 0;
  *((_WORD *)v4 + 6) = 1;
  if ( v15 == 4 )
    goto LABEL_54;
  if ( v15 > 4 )
  {
    if ( v15 != 6 )
    {
      if ( v15 >= 6 )
      {
        if ( v15 == 100 )
        {
          v16 = *(_DWORD *)(a2 + 84);
          v17 = *(_DWORD *)v16;
          v18 = *(__int16 *)(*(_DWORD *)v16 + 500);
          if ( !*(_WORD *)(*(_DWORD *)v16 + 500) )
          {
            *(_DWORD *)(v17 + 184) = v18;
            *(_DWORD *)(v17 + 296) = v18;
            *(_DWORD *)(v17 + 400) = v18;
          }
          *(_WORD *)(v17 + 502) = 1;
          return sub_498E8(a2, v16, v17);
        }
        return result;
      }
      v19 = *(int **)(a2 + 84);
      v26 = *v19;
      *(_DWORD *)(*v19 + 56) = 0;
      if ( (v19[192] & 1) != 0 )
      {
        v27 = (__int16)(*(_WORD *)(v26 + 16) + 1);
        v28 = &off_B46E4[4 * v27];
        v23 = (int)v28[242];
        v24 = (char *)v28[241];
        v25 = v23;
      }
      else
      {
        v25 = 6;
        v23 = 6;
        LOWORD(v27) = 2;
        *(_DWORD *)(v26 + 20) = 1;
        v24 = "time\r\n";
      }
      *(_WORD *)(v26 + 16) = v27;
      goto LABEL_45;
    }
LABEL_54:
    *(_BYTE *)(**(_DWORD **)(a2 + 84) + 15) = 0;
    return result;
  }
  if ( v15 != 2 )
  {
    if ( v15 > 2 )
    {
      v29 = *(_DWORD **)(a2 + 84);
      v30 = *(__int16 *)(*v29 + 2);
      *(_BYTE *)(*v29 + 15) = 0;
      if ( v30 == 1 )
      {
        buf[0] = 84;
      }
      else if ( v30 >= 1 && v30 <= 3 )
      {
        buf[0] = 67;
      }
      v24 = buf;
      v31 = v29[7];
      buf[1] = 0;
      if ( write(v31, buf, 1u) == 1 )
        return sub_4A084(a2, 2, v24);
      goto LABEL_46;
    }
    if ( v15 != 1 )
      return result;
    v19 = *(int **)(a2 + 84);
    v20 = *v19;
    *(_BYTE *)(v20 + 15) = 0;
    *(_DWORD *)(v20 + 56) = 0;
    if ( (v19[192] & 1) != 0 )
    {
      v21 = (__int16)(*(_WORD *)(v20 + 16) + 1);
      v22 = &off_B46E4[5 * v21];
      v23 = (int)v22[207];
      v24 = (char *)v22[206];
      v25 = v23;
    }
    else
    {
      v25 = 6;
      v23 = 6;
      LOWORD(v21) = 3;
      *(_DWORD *)(v20 + 20) = 2;
      v24 = "time\r\n";
    }
    *(_WORD *)(v20 + 16) = v21;
LABEL_45:
    if ( write(v19[7], v24, v25) == v23 )
      return sub_4A084(a2, 2, v24);
LABEL_46:
    sub_394A0((__int16 *)a2, 3);
    return sub_4A084(a2, 2, v24);
  }
  v32 = *(_DWORD **)(a2 + 84);
  v33 = *v32;
  v34 = *(_WORD *)(*v32 + 16);
  *(_BYTE *)(v33 + 15) = 0;
  *(_DWORD *)(v33 + 184) = 0;
  v35 = v32[7];
  *(_DWORD *)(v33 + 296) = 0;
  *(_DWORD *)(v33 + 400) = 0;
  *(_WORD *)(v33 + 16) = v34 + 1;
  if ( write(v35, byte_97F78, 4u) != 4 )
    sub_394A0((__int16 *)a2, 3);
  return sub_4A084(a2, 2, byte_97F78);
}
// B46E4: using guessed type int (*off_B46E4[135])();

//----- (0004BB10) --------------------------------------------------------
bool __fastcall sub_4BB10(__int16 *a1, int a2, __int16 *a3)
{
  int v5; // r2

  v5 = a3[252];
  if ( (unsigned __int16)(v5 - 1) > 5u )
  {
    if ( write(*(_DWORD *)(a2 + 28), "\r", 1u) != 1 )
      sub_394A0(a1, 3);
    sub_4A084((int)a1, 2, "\r");
    a3[248] = 0;
    return 0;
  }
  else
  {
    if ( off_B46E4[5 * v5 + 138] == (int (*)())&byte_6 )
      *((_BYTE *)a3 + a3[203] + 488) = 1;
    a3[248] = 0;
    return sub_4B4B4((int)a1, a2, (int)a3);
  }
}
// 6: using guessed type char byte_6;
// B46E4: using guessed type int (*off_B46E4[135])();

//----- (0004BC28) --------------------------------------------------------
int __fastcall sub_4BC28(unsigned __int8 *a1, int a2)
{
  const char *v3; // r10
  unsigned int v4; // r4
  int v5; // r9
  int v6; // r6
  size_t v7; // r8
  int v8; // r11
  int v9; // r7
  const unsigned __int16 **v10; // r0
  int v11; // r1
  int v12; // t1
  const unsigned __int16 *v13; // r0
  int v14; // r3
  char *v15; // r3
  const char *v16; // r11
  unsigned int v17; // r3
  unsigned int v18; // r1
  int v20; // [sp+10h] [bp-64h]
  _BYTE v22[4]; // [sp+18h] [bp-5Ch] BYREF
  char v23[88]; // [sp+1Ch] [bp-58h] BYREF

  sub_4A084((int)a1, 1, "Refclock: Telephone JJY");
  *(_BYTE *)a2 = 100;
  *(_DWORD *)(a2 + 4) = 11;
  *(_BYTE *)(a2 + 192) = 1;
  *(_BYTE *)(a2 + 404) = 1;
  *(_WORD *)(a2 + 8) = 32;
  *(_DWORD *)(a2 + 188) = &off_B6F54;
  *(_DWORD *)(a2 + 500) = 0;
  v3 = (const char *)sys_phone[0];
  if ( sys_phone[0] )
  {
    v4 = dword_B921C;
    if ( dword_B921C )
    {
      v5 = 1;
      sub_64E00(3, "refclock_jjy.c : jjy_start_telephone : phone in the ntpd.conf should be only one.");
      *(_BYTE *)(a2 + 10) = 1;
    }
    else
    {
      v5 = 0;
      v6 = 0;
      v7 = strlen((const char *)sys_phone[0]);
      v8 = sys_phone[0] - 1;
      v9 = 1 - sys_phone[0];
      v20 = 0;
      while ( v9 + v8 < v7 )
      {
        while ( 1 )
        {
          v10 = _ctype_b_loc();
          v12 = *(unsigned __int8 *)++v8;
          v11 = v12;
          v13 = *v10;
          v14 = v13[v12] & 0x800;
          if ( (v13[v12] & 0x800) == 0 )
            break;
          ++v6;
          if ( v4 <= 2 )
          {
            v15 = &v23[v4++ + 84];
            *(v15 - 88) = v11;
          }
          if ( v9 + v8 >= v7 )
            goto LABEL_9;
        }
        if ( v11 == 44 )
        {
          if ( v5 == 1 )
          {
            sub_64E00(3, "refclock_jjy.c : jjy_start_telephone : phone in the ntpd.conf should be zero or one comma.");
            *(_BYTE *)(a2 + 10) = 1;
            return v5;
          }
          v4 = v14;
          v20 = v8 - (_DWORD)v3;
          v5 = 1;
        }
        else if ( v11 != 45 )
        {
          v5 = 1;
          sub_64E00(3, "refclock_jjy.c : jjy_start_telephone : phone in the ntpd.conf should be a number or a hyphen.");
          *(_BYTE *)(a2 + 10) = 1;
          return v5;
        }
      }
LABEL_9:
      v22[v4] = 0;
      if ( v5 != 1 || v20 == 1 && *v3 == 48 )
      {
        if ( (unsigned int)(v6 - v20 - 6) > 4 )
        {
          v5 = 1;
          sub_64E00(3, "refclock_jjy.c : jjy_start_telephone : phone=%s : Number of digits should be 6 to 10.", v3);
          *(_BYTE *)(a2 + 10) = 1;
        }
        else
        {
          v16 = &v22[v20];
          if ( !strncmp(&v22[v20], "00", 2u)
            || !strncmp(v16, "10", 2u)
            || !strncmp(v16, "11", 2u)
            || !strncmp(v16, "12", 2u)
            || !strncmp(v16, "171", 3u)
            || !strncmp(v16, "177", 3u)
            || v22[0] == 48 && v22[2] == 48 )
          {
            v5 = 1;
            sub_64E00(3, "refclock_jjy.c : jjy_start_telephone : phone=%s : First 2 or 3 digits are not allowed.", v3);
            *(_BYTE *)(a2 + 10) = 1;
          }
          else
          {
            sub_6C054((int)v23, 0x50u, "phone=%s", v3);
            sub_4A084((int)a1, 1, v23);
            v17 = a1[65];
            if ( v17 <= 7 )
            {
              v18 = a1[94];
              a1[65] = 8;
              v5 = 0;
              if ( v18 <= 7 )
                a1[94] = 8;
              if ( a1[66] <= 7u )
                a1[66] = 8;
              sub_6C054((int)v23, 0x50u, "minpoll=%d -> %d", v17, 8);
              sub_4A084((int)a1, 1, v23);
            }
            else
            {
              return 0;
            }
          }
        }
      }
      else
      {
        sub_64E00(3, "refclock_jjy.c : jjy_start_telephone : Getting an outside line should be '0,'.");
        *(_BYTE *)(a2 + 10) = 1;
      }
    }
  }
  else
  {
    v5 = 1;
    sub_64E00(3, "refclock_jjy.c : jjy_start_telephone : phone in the ntpd.conf must be specified.");
    *(_BYTE *)(a2 + 10) = 1;
  }
  return v5;
}
// B6F54: using guessed type _UNKNOWN *off_B6F54;
// B9218: using guessed type int sys_phone[];
// B921C: using guessed type int dword_B921C;

//----- (0004C038) --------------------------------------------------------
int __fastcall sub_4C038(int a1, int a2)
{
  void *v4; // r0
  int v5; // r4
  int v6; // r5
  unsigned int v7; // r8
  int v8; // r8
  int *v9; // r7
  int v10; // r12
  const char *v12; // r0
  __int16 v13; // r2
  speed_t v14; // r1
  const char *v15; // r0
  char v16[24]; // [sp+8h] [bp-5Ch] BYREF
  char v17[60]; // [sp+20h] [bp-44h] BYREF

  v4 = sub_63BA4(0, 0x208u, 0, 0);
  v5 = (int)v4;
  if ( v4 )
  {
    v6 = 0;
    memset(v4, 0, 0x208u);
    *(_BYTE *)(v5 + 10) = 0;
    *(_WORD *)(v5 + 12) = 0;
    *(_BYTE *)(v5 + 14) = 0;
    *(_WORD *)(v5 + 16) = 0;
    *(_DWORD *)(v5 + 20) = 0;
    *(_DWORD *)(v5 + 56) = 0;
    *(_BYTE *)(v5 + 192) = 0;
    *(_DWORD *)(v5 + 400) = 0;
    *(_DWORD *)(v5 + 296) = 0;
    *(_DWORD *)(v5 + 184) = 0;
    *(_BYTE *)(v5 + 404) = 1;
    sub_6C054((int)v16, 0x15u, "/dev/jjy%d", a1);
    sub_6C054((int)v17, 0x3Cu, "mode=%d dev=%s", *(_DWORD *)(a2 + 76), v16);
    sub_4A084(a2, 1, v17);
    v7 = *(_DWORD *)(a2 + 76);
    if ( v7 == 3 )
    {
      sub_4A084(a2, 1, "Refclock: Echo Keisokuki Co. Ltd. LT2000");
      *(_BYTE *)v5 = 3;
      *(_WORD *)(v5 + 8) = 1;
      v13 = 1;
      *(_WORD *)(v5 + 2) = 3;
      v14 = 13;
      *(_DWORD *)(v5 + 4) = 13;
    }
    else if ( v7 <= 3 )
    {
      if ( v7 <= 1 )
      {
        sub_4A084(a2, 1, "Refclock: Tristate Ltd. TS-JJY01, TS-JJY02");
        v14 = 13;
        *(_BYTE *)v5 = 1;
        *(_WORD *)(v5 + 8) = 1;
        v13 = 1;
        *(_DWORD *)(v5 + 4) = 13;
      }
      else
      {
        sub_4A084(a2, 1, "Refclock: C-DEX Co. Ltd. JST2000");
        *(_BYTE *)(v5 + 192) = 1;
        v14 = 13;
        *(_BYTE *)(v5 + 404) = 0;
        v13 = 32;
        *(_DWORD *)(v5 + 188) = &off_B6F8C;
        *(_BYTE *)v5 = 2;
        *(_DWORD *)(v5 + 4) = 13;
        *(_WORD *)(v5 + 8) = 32;
      }
    }
    else if ( v7 == 5 )
    {
      sub_4A084(a2, 1, "Refclock: Tristate Ltd. TS-GPS01");
      v14 = 15;
      *(_BYTE *)v5 = 5;
      *(_WORD *)(v5 + 8) = 1;
      v13 = 1;
      *(_DWORD *)(v5 + 4) = 15;
    }
    else if ( v7 >= 5 )
    {
      if ( v7 == 6 )
      {
        sub_4A084(a2, 1, "Refclock: SEIKO TIME SYSTEMS TDC-300");
        *(_BYTE *)v5 = 6;
        *(_BYTE *)(v5 + 192) = 1;
        v14 = 11;
        *(_BYTE *)(v5 + 404) = 0;
        v13 = 32;
        *(_DWORD *)(v5 + 188) = &off_B6F9C;
        *(_DWORD *)(v5 + 4) = 11;
        *(_WORD *)(v5 + 8) = 32;
      }
      else
      {
        if ( v7 != 100 && v7 - 101 > 0x4F )
        {
          v12 = sub_6C2E8((unsigned __int16 *)(a2 + 16));
          sub_64E00(3, "JJY receiver [ %s mode %d ] : Unsupported mode", v12, *(_DWORD *)(a2 + 76));
          free((void *)v5);
          return v6;
        }
        if ( sub_4BC28((unsigned __int8 *)a2, v5) )
        {
          v6 = 0;
          v15 = sub_6C2E8((unsigned __int16 *)(a2 + 16));
          sub_64E00(3, "JJY receiver [ %s mode %d ] : Initialize error", v15, *(_DWORD *)(a2 + 76));
          free((void *)v5);
          return v6;
        }
        v14 = *(_DWORD *)(v5 + 4);
        v13 = *(_WORD *)(v5 + 8);
      }
    }
    else
    {
      sub_4A084(a2, 1, "Refclock: CITIZEN T.I.C CO. LTD. JJY200");
      *(_BYTE *)v5 = 4;
      v13 = 1;
      *(_WORD *)(v5 + 8) = 1;
      v14 = 12;
      *(_DWORD *)(v5 + 4) = 12;
    }
    v8 = sub_3A298(v16, v14, v13);
    if ( v8 <= 0 )
    {
      v6 = 0;
      free((void *)v5);
    }
    else
    {
      v9 = *(int **)(a2 + 84);
      *v9 = v5;
      v9[5] = a2;
      v9[7] = v8;
      v9[11] = (int)"JJY Receiver";
      v9[3] = (int)sub_4C478;
      v9[6] = 0;
      v6 = sub_18DF0(v9 + 2);
      if ( v6 )
      {
        v6 = 1;
        qmemcpy(v9 + 191, "JJY", 3);
        v10 = *(unsigned __int8 *)(a2 + 66);
        *(_BYTE *)(a2 + 95) = -3;
        sub_6C054((int)v17, 0x3Cu, "minpoll=%d maxpoll=%d", *(unsigned __int8 *)(a2 + 65), v10);
        sub_4A084(a2, 1, v17);
      }
      else
      {
        close(v8);
        v9[7] = -1;
        free((void *)v5);
        *v9 = 0;
      }
    }
  }
  else
  {
    v6 = 0;
    sub_64E00(3, "refclock_jjy.c : jjy_start : emalloc");
  }
  return v6;
}
// B6F8C: using guessed type _UNKNOWN *off_B6F8C;
// B6F9C: using guessed type _UNKNOWN *off_B6F9C;

//----- (0004C478) --------------------------------------------------------
char *__fastcall sub_4C478(_DWORD *a1)
{
  char *v1; // r4
  unsigned __int8 *v2; // r9
  void *v3; // r11
  char *result; // r0
  int v5; // r2
  bool v6; // cc
  int v7; // r3
  int v8; // r2
  unsigned __int8 *v9; // lr
  unsigned __int8 *v10; // r1
  char *v11; // r12
  unsigned __int8 v12; // t1
  int v13; // r1
  const char *v14; // r8
  int v15; // r3
  int v16; // r10
  unsigned __int8 *v17; // r11
  int v18; // r1
  unsigned __int8 *v19; // r1
  unsigned int v20; // r3
  int v21; // r7
  int *v22; // r6
  int v23; // r5
  int v24; // r3
  bool v25; // zf
  int (*v26)(); // r3
  int (**v27)(); // r2
  int v28; // r6
  _DWORD *v29; // r5
  int v30; // r2
  unsigned int v31; // r3
  bool v32; // cc
  int v33; // r2
  const char *v34; // r7
  int v35; // r6
  const char *v36; // r7
  int v37; // r10
  const char *v38; // r9
  size_t v39; // r2
  const char *v40; // r5
  int v41; // t1
  const unsigned __int16 *v42; // lr
  unsigned __int8 *v43; // r0
  unsigned __int8 *v44; // r3
  unsigned __int8 v45; // r2
  int v46; // t1
  int v47; // r1
  int v48; // r3
  unsigned __int8 *v49; // r9
  _BOOL4 v50; // r3
  int v51; // r6
  _DWORD *v52; // r5
  int v53; // r3
  int v54; // r8
  _DWORD *v55; // r5
  int v56; // r7
  const char *v57; // r6
  int v58; // r9
  int (**v59)(); // r3
  int v60; // r3
  _DWORD *v61; // r5
  int v62; // r3
  __int16 v63; // r12
  _DWORD *v64; // r5
  const char *v65; // r3
  int v66; // r2
  int v67; // r0
  int v68; // r7
  int v69; // r8
  int v70; // r1
  int v71; // r3
  int v72; // r12
  int v73; // r2
  int v74; // r12
  _DWORD *v75; // r5
  int v76; // r7
  int v77; // r3
  int v78; // r3
  int v79; // r12
  int v80; // lr
  int v81; // r2
  int v82; // r1
  int v83; // r7
  int v84; // r8
  int v85; // r3
  int v86; // r3
  int v87; // r1
  int v88; // r12
  int v89; // r2
  int v90; // r8
  int v91; // r9
  int v92; // r0
  __int16 *v93; // r9
  unsigned int v94; // r7
  const char *v95; // r8
  int v96; // r3
  __int16 v97; // r2
  int v98; // r3
  int v99; // r3
  int v100; // r3
  int v101; // r2
  int (**v102)(); // r3
  size_t v103; // r5
  int v104; // r2
  int v105; // r3
  int v106; // r3
  int v107; // r3
  int v108; // r1
  int v109; // r2
  int v110; // r12
  int v111; // r3
  int v112; // r2
  unsigned __int8 *v113; // r3
  int v114; // r2
  int v115; // t1
  int v116; // r3
  int v117; // r1
  int v118; // r12
  int v119; // r2
  int tm_year; // r2
  unsigned __int8 *v121; // r3
  char v122; // t1
  int v123; // r8
  int v124; // r7
  int v125; // r1
  int v126; // r0
  int v127; // r5
  int v128; // r2
  unsigned __int8 *v129; // r3
  char v130; // t1
  __int64 v131; // r2
  bool v132; // zf
  char v133; // r3
  int v134; // r3
  struct tm *v135; // r0
  int tm_mday; // r1
  int v137; // r3
  int v138; // r3
  int v139; // r1
  int v140; // r2
  int v141; // r12
  int v142; // r3
  int v143; // r2
  int v144; // r3
  char *v145; // r3
  unsigned __int8 *v146; // r2
  unsigned __int8 v147; // t1
  int v148; // r3
  int v149; // r6
  int v150; // r3
  int v151; // r12
  int v152; // r2
  int (**v153)(); // r3
  char *v154; // r6
  int v155; // r2
  int v156; // r3
  int v157; // r3
  int v158; // r12
  int v159; // r3
  int v160; // r12
  int v161; // r7
  int v162; // r1
  int v163; // r2
  int v164; // r3
  char *v165; // [sp+24h] [bp-150h]
  int v166; // [sp+28h] [bp-14Ch]
  int v168; // [sp+30h] [bp-144h]
  char *v169; // [sp+3Ch] [bp-138h]
  int v170; // [sp+3Ch] [bp-138h]
  int v171; // [sp+40h] [bp-134h]
  int v172; // [sp+54h] [bp-120h] BYREF
  time_t timer; // [sp+58h] [bp-11Ch] BYREF
  _DWORD v174[2]; // [sp+5Ch] [bp-118h] BYREF
  char v175; // [sp+64h] [bp-110h] BYREF
  unsigned __int8 v176; // [sp+65h] [bp-10Fh]
  char v177; // [sp+66h] [bp-10Eh]
  char v178[60]; // [sp+68h] [bp-10Ch] BYREF
  char v179[100]; // [sp+A4h] [bp-D0h] BYREF
  char v180[108]; // [sp+108h] [bp-6Ch] BYREF

  v1 = (char *)v174;
  v166 = a1[1];
  v165 = *(char **)(v166 + 84);
  v3 = v165 + 56;
  v2 = *(unsigned __int8 **)v165;
  if ( *(_WORD *)(*(_DWORD *)v165 + 8) == 32 )
  {
    result = (char *)sub_39F94(a1, v3, 127, v174);
    *((_DWORD *)v165 + 46) = result;
    v7 = *((_DWORD *)v2 + 46);
    if ( (int)result > 0 && v7 <= 97 )
    {
      v8 = v7 + 1;
      v9 = (unsigned __int8 *)&result[v7];
      v10 = &v2[v7 + 84];
      v11 = v165 + 55;
      do
      {
        v7 = v8;
        v12 = *++v11;
        *v10++ = v12;
        if ( v9 == (unsigned __int8 *)v8 )
          break;
        ++v8;
      }
      while ( v7 != 98 );
      *((_DWORD *)v2 + 46) = v7;
    }
    v2[v7 + 84] = 0;
  }
  else
  {
    result = sub_39EE4((int)a1, (bool *)v3, 128, v174);
    *((_DWORD *)v165 + 46) = result;
  }
  if ( !result )
    return result;
  v5 = *((__int16 *)v2 + 6);
  v6 = v5 != 0;
  if ( *((_WORD *)v2 + 6) )
    v6 = (unsigned __int16)(v5 - 3) > 1u;
  if ( !v6 )
  {
    *((_DWORD *)v2 + 46) = 0;
    return result;
  }
  v168 = 0;
  result = (char *)v174[0];
  v13 = v174[1];
  v171 = -84 - (_DWORD)v2;
  v14 = (const char *)*((__int16 *)v2 + 4);
  v15 = *((_DWORD *)v2 + 5) + 1;
  v16 = *((_DWORD *)v2 + 46) - 1;
  v17 = v2;
  *((_DWORD *)v165 + 58) = v174[0];
  *((_DWORD *)v165 + 59) = v13;
  *((_DWORD *)v2 + 5) = v15;
  *((_WORD *)v2 + 6) = 2;
  v18 = (int)"# Invalid time : rc=%d year=%d month=%d day=%d hour=%d minute=%d second=%d";
  v2[14] = 1;
  while ( 1 )
  {
    if ( v14 != (const char *)&dword_20 )
    {
      v19 = (unsigned __int8 *)(v165 + 56);
      v1 = (char *)*((_DWORD *)v165 + 46);
      goto LABEL_19;
    }
    v35 = *((_DWORD *)v17 + 46);
    if ( v17[192] )
    {
      if ( v168 >= v35 )
        goto LABEL_62;
      v36 = (const char *)&v17[v168 + 84];
      v37 = **((_DWORD **)v17 + 47);
      v169 = (char *)*((_DWORD *)v17 + 47);
      while ( 1 )
      {
        if ( v37 )
        {
          v1 = v169;
          v18 = v37;
        }
        v38 = &v36[v171];
        if ( v37 )
          break;
LABEL_61:
        if ( ++v36 == (const char *)&v17[v35 + 84] )
          goto LABEL_62;
      }
      while ( 1 )
      {
        v39 = *((_DWORD *)v1 + 1);
        v40 = &v38[v39];
        if ( (int)&v38[v39] <= v35 )
        {
          result = (char *)strncmp(v36, (const char *)v18, v39);
          if ( !result )
            break;
        }
        v41 = *((_DWORD *)v1 + 2);
        v1 += 8;
        v18 = v41;
        if ( !v41 )
          goto LABEL_61;
      }
      v16 = (int)(v40 - 1);
      if ( !v40 )
      {
LABEL_62:
        if ( v35 <= 97 )
          goto LABEL_78;
        if ( v168 > 0 )
        {
          v49 = v17;
          goto LABEL_283;
        }
        v16 = v35 - 1;
        *((_DWORD *)v17 + 100) = 0;
        *((_DWORD *)v17 + 74) = 0;
LABEL_65:
        v42 = *_ctype_b_loc();
        v43 = v17 + 192;
        v44 = &v17[v168 + 84];
        do
        {
          v46 = *v44++;
          v45 = v46;
          *++v43 = v46;
          if ( (v42[v46] & 2) == 0 )
          {
            v47 = *((_DWORD *)v17 + 100);
            v17[v47 + 300] = v45;
            *((_DWORD *)v17 + 100) = v47 + 1;
          }
        }
        while ( &v17[v16 + 85] != v44 );
        v48 = *((_DWORD *)v17 + 100);
        v1 = (char *)(v16 - v168 + 1);
        *((_DWORD *)v17 + 74) = v1;
        v18 = v48 == 0;
        goto LABEL_73;
      }
    }
    else
    {
      v16 = v35 - 1;
    }
    v48 = 0;
    *((_DWORD *)v17 + 100) = 0;
    *((_DWORD *)v17 + 74) = 0;
    if ( v16 >= v168 )
      goto LABEL_65;
    v18 = 1;
    v1 = 0;
LABEL_73:
    result = 0;
    v1[(_DWORD)v17 + 193] = 0;
    v17[v48 + 300] = 0;
    if ( !v17[404] )
      v18 = 0;
    if ( v18 )
    {
      if ( v16 + 1 >= v35 )
        goto LABEL_78;
      v168 = v16 + 1;
      goto LABEL_91;
    }
    v19 = v17 + 193;
LABEL_19:
    if ( (unsigned int)v1 >= 0x63 )
      v1 = (_BYTE *)(&dword_60 + 3);
    _memcpy_chk(v179, v19, v1, 100);
    v1 = &v180[(_DWORD)v1 + 104];
    *(v1 - 204) = 0;
    result = (char *)sub_4A084(v166, 3, v179);
    v20 = *v17;
    if ( v20 == 4 )
    {
      v51 = a1[1];
      v52 = *(_DWORD **)(v51 + 84);
      v1 = (char *)*v52;
      if ( *(_WORD *)(*v52 + 8) == 32 )
      {
        result = v1 + 300;
        v53 = *((_DWORD *)v1 + 100);
      }
      else
      {
        v53 = v52[46];
        result = (char *)(v52 + 14);
      }
      if ( *(_WORD *)(*v52 + 12) != 2 )
        goto LABEL_88;
      if ( v53 == 23 )
      {
        v86 = sscanf(
                result,
                "%c%2s %2d/%2d/%2d %1d %2d:%2d:%2d",
                &v172,
                &v175,
                v1 + 24,
                v1 + 28,
                v1 + 32,
                &timer,
                v1 + 36,
                v1 + 40,
                v1 + 44);
        v177 = 0;
        if ( v86 != 9 )
        {
          v87 = *((_DWORD *)v1 + 7);
          v89 = *((_DWORD *)v1 + 9);
          v90 = *((_DWORD *)v1 + 10);
          v91 = *((_DWORD *)v1 + 11);
          v88 = *((_DWORD *)v1 + 8);
          goto LABEL_295;
        }
        v87 = *((_DWORD *)v1 + 7);
        v88 = *((_DWORD *)v1 + 8);
        v89 = *((_DWORD *)v1 + 9);
        v90 = *((_DWORD *)v1 + 10);
        v91 = *((_DWORD *)v1 + 11);
        if ( (unsigned __int8)v172 != 39 )
          goto LABEL_295;
        if ( v175 == 79 )
        {
          v92 = v176;
          if ( v176 == 75 )
            goto LABEL_163;
LABEL_295:
          sub_6C054(
            (int)v180,
            0x63u,
            "# Invalid time : rc=%d year=%d month=%d day=%d hour=%d minute=%d second=%d",
            v86,
            *((_DWORD *)v1 + 6),
            v87,
            v88,
            v89,
            v90,
            v91);
LABEL_153:
          result = (char *)sub_4A084(v51, 7, v180);
          v1[15] = 1;
          goto LABEL_154;
        }
        if ( v175 == 78 )
        {
          v92 = v176;
          if ( v176 == 71 )
            goto LABEL_163;
          goto LABEL_295;
        }
        if ( v175 != 69 )
          goto LABEL_295;
        v92 = v176;
        if ( v176 != 82 )
          goto LABEL_295;
LABEL_163:
        if ( (unsigned int)(v87 - 1) > 0xB
          || (unsigned int)(v88 - 1) > 0x1E
          || timer > 6
          || v89 > 23
          || v90 > 59
          || v91 > 60 )
        {
          goto LABEL_295;
        }
        if ( v175 == 78 )
        {
          if ( v92 == 71 )
          {
LABEL_171:
            sub_6C054((int)v178, 0xFu, "status=%s", &v175);
            v1 = v180;
            sub_6C054((int)v180, 0x63u, "* Unsure timestamp : %s", v178);
            result = (char *)sub_4A084(v51, 6, v180);
            goto LABEL_88;
          }
        }
        else if ( v175 == 69 && v92 == 82 )
        {
          goto LABEL_171;
        }
        v164 = *((_DWORD *)v1 + 6);
        *((_DWORD *)v1 + 12) = 0;
        *((_DWORD *)v1 + 6) = v164 + 2000;
        result = (char *)sub_4AAB4(v51, v52, v1);
        goto LABEL_88;
      }
LABEL_152:
      sub_6C054((int)v180, 0x63u, "# Invalid length : length=%d");
      goto LABEL_153;
    }
    if ( v20 <= 4 )
      break;
    if ( v20 == 6 )
    {
      v51 = a1[1];
      v61 = *(_DWORD **)(v51 + 84);
      v1 = (char *)*v61;
      if ( *(_WORD *)(*v61 + 8) == 32 )
      {
        result = v1 + 300;
        v62 = *((_DWORD *)v1 + 100);
      }
      else
      {
        v62 = v61[46];
        result = (char *)(v61 + 14);
      }
      if ( *(_WORD *)(*v61 + 12) != 2 )
        goto LABEL_88;
      v63 = *((_WORD *)v1 + 9);
      v18 = (__int16)(v63 + 1);
      *((_WORD *)v1 + 9) = v18;
      switch ( v62 )
      {
        case 1:
          if ( (unsigned __int8)*result != 229 )
          {
            sub_6C054((int)v180, 0x63u, "# Invalid reply : [%s]");
            goto LABEL_153;
          }
          if ( v18 == 1 )
          {
            *((_WORD *)v1 + 9) = v63;
            goto LABEL_89;
          }
          if ( v18 <= 2 )
          {
            tm_year = *((_DWORD *)v1 + 6);
            goto LABEL_235;
          }
          goto LABEL_189;
        case 8:
          v129 = (unsigned __int8 *)(result - 1);
          do
          {
            v130 = *++v129;
            *v129 = v130 & 0x7F;
          }
          while ( result + 7 != (char *)v129 );
          result = (char *)sscanf(result + 1, "%2d:%2d:%2d", v1 + 36, v1 + 40, v1 + 44);
          v131 = *(_QWORD *)(v1 + 36);
          v18 = *((_DWORD *)v1 + 11);
          if ( result != (_BYTE *)&dword_0 + 3 || (int)v131 > 23 || SHIDWORD(v131) > 59 || v18 > 60 )
          {
            sub_6C054(
              (int)v180,
              0x63u,
              "# Invalid time : rc=%d hour=%d minute=%d second=%d",
              result,
              (_DWORD)v131,
              HIDWORD(v131),
              v18);
            goto LABEL_153;
          }
          v132 = (_DWORD)v131 == 23;
          if ( (_DWORD)v131 == 23 )
            v132 = HIDWORD(v131) == 59;
          v133 = v132;
          if ( v18 > 54 )
            v134 = v133 & 1;
          else
            v134 = 0;
          if ( !v134 )
          {
            time(&timer);
            v135 = localtime(&timer);
            tm_mday = v135->tm_mday;
            tm_year = v135->tm_year;
            *((_DWORD *)v1 + 7) = v135->tm_mon + 1;
            *((_DWORD *)v1 + 8) = tm_mday;
            goto LABEL_235;
          }
          goto LABEL_89;
        case 13:
          v127 = sscanf(result, "%2d%2d%2d%1d%2d%2d%2d", v1 + 24, v1 + 28, v1 + 32, &v172, v1 + 36, v1 + 40, v1 + 44);
          v128 = *((_DWORD *)v1 + 7);
          v18 = *((_DWORD *)v1 + 8);
          result = (char *)*((_DWORD *)v1 + 9);
          if ( v127 != 7 )
          {
            v159 = *((_DWORD *)v1 + 10);
            v160 = *((_DWORD *)v1 + 11);
LABEL_255:
            sub_6C054(
              (int)v180,
              0x63u,
              "# Invalid time : rc=%d year=%d month=%d day=%d hour=%d minute=%d second=%d",
              v127,
              *((_DWORD *)v1 + 6),
              v128,
              v18,
              result,
              v159,
              v160);
            goto LABEL_153;
          }
          v159 = *((_DWORD *)v1 + 10);
          v160 = *((_DWORD *)v1 + 11);
          if ( (unsigned int)(v128 - 1) > 0xB
            || (unsigned int)(v18 - 1) > 0x1E
            || v172 > 6
            || (int)result > 23
            || v159 > 59
            || v160 > 60 )
          {
            goto LABEL_255;
          }
          break;
        case 17:
          v121 = (unsigned __int8 *)(result - 1);
          do
          {
            v122 = *++v121;
            *v121 = v122 & 0x7F;
          }
          while ( result + 16 != (char *)v121 );
          v123 = sscanf(
                   result + 1,
                   "%2d%2d%2d%2d%2d%2d%1d",
                   v1 + 24,
                   v1 + 28,
                   v1 + 32,
                   v1 + 36,
                   v1 + 40,
                   v1 + 44,
                   &v172);
          v124 = *((_DWORD *)v1 + 7);
          v125 = *((_DWORD *)v1 + 8);
          v126 = *((_DWORD *)v1 + 9);
          if ( v123 == 7 )
          {
            v157 = *((_DWORD *)v1 + 10);
            v158 = *((_DWORD *)v1 + 11);
            tm_year = *((_DWORD *)v1 + 6);
            if ( (unsigned int)(v124 - 1) <= 0xB
              && (unsigned int)(v125 - 1) <= 0x1E
              && v172 <= 6
              && v126 <= 23
              && v157 <= 59
              && v158 <= 60 )
            {
LABEL_235:
              *((_DWORD *)v1 + 6) = tm_year + 2000;
              *((_DWORD *)v1 + 12) = 0;
              result = (char *)sub_4AAB4(v51, v61, v1);
              goto LABEL_88;
            }
          }
          else
          {
            v157 = *((_DWORD *)v1 + 10);
            v158 = *((_DWORD *)v1 + 11);
            tm_year = *((_DWORD *)v1 + 6);
          }
          sub_6C054(
            (int)v180,
            0x63u,
            "# Invalid time : rc=%d year=%d month=%d day=%d hour=%d minute=%d second=%d",
            v123,
            tm_year,
            v124,
            v125,
            v126,
            v157,
            v158);
          goto LABEL_153;
        default:
          goto LABEL_152;
      }
      goto LABEL_89;
    }
    if ( v20 < 6 )
    {
      v54 = a1[1];
      v55 = *(_DWORD **)(v54 + 84);
      v1 = (char *)*v55;
      if ( *(_WORD *)(*v55 + 8) == 32 )
      {
        v56 = *((_DWORD *)v1 + 100);
        v57 = v1 + 300;
      }
      else
      {
        v56 = v55[46];
        v57 = (const char *)(v55 + 14);
      }
      if ( v56 <= 5 )
      {
        if ( v56 == 5 )
        {
          result = (char *)strncmp(v57, "$Cmd>", 5u);
          if ( !result )
            goto LABEL_89;
        }
      }
      else
      {
        result = (char *)strncmp(v57, "$GP", 3u);
        if ( !result )
          goto LABEL_89;
        result = (char *)strncmp(v57, "$PFEC", 5u);
        if ( !result )
          goto LABEL_89;
        if ( strncmp(v57, "$Cmd>", 5u) )
          goto LABEL_102;
        v56 -= 5;
        v57 += 5;
        if ( v56 > 5 )
        {
          result = (char *)strncmp(v57, "$GP", 3u);
          if ( result )
          {
LABEL_102:
            result = (char *)strncmp(v57, "$PFEC", 5u);
            if ( result )
              goto LABEL_103;
          }
LABEL_89:
          v14 = (const char *)*((__int16 *)v17 + 4);
          if ( v14 != (const char *)&dword_20 )
            goto LABEL_90;
          goto LABEL_50;
        }
      }
LABEL_103:
      v58 = *((__int16 *)v1 + 8);
      v59 = &off_B46E4[4 * v58];
      if ( v59[241] )
      {
        if ( v59[243] == (int (*)())v56 )
        {
          v60 = *((unsigned __int8 *)v59 + 960);
          switch ( v60 )
          {
            case 2:
              v137 = *((_DWORD *)v1 + 14);
              if ( v137 > 1 )
              {
                sub_6C054((int)v180, 0x63u, "# Too many reply : count=%d", v137);
              }
              else
              {
                v138 = sscanf(v57, "%2d:%2d:%2d", v1 + 36, v1 + 40, v1 + 44);
                v139 = *((_DWORD *)v1 + 9);
                v140 = *((_DWORD *)v1 + 10);
                v141 = *((_DWORD *)v1 + 11);
                if ( v138 == 3 && v139 <= 23 && v140 <= 59 && v141 <= 60 )
                {
                  v142 = *((_DWORD *)v1 + 14);
                  v143 = v140 + 60 * v139;
                  v18 = 0;
                  result = &v1[4 * v142];
                  v144 = v142 + 1;
                  *((_DWORD *)result + 15) = v141 + 60 * v143;
                  *((_DWORD *)v1 + 14) = v144;
                  *((_DWORD *)v1 + 12) = 0;
                  goto LABEL_278;
                }
                sub_6C054(
                  (int)v180,
                  0x63u,
                  "# Invalid time : rc=%d hour=%d minute=%d second=%d",
                  v138,
                  *((_DWORD *)v1 + 9),
                  v140,
                  v141);
              }
              break;
            case 4:
              result = (char *)strncmp(v57, "*R", 2u);
              if ( !result
                || (result = (char *)strncmp(v57, "*G", 2u)) == 0
                || (result = (char *)strncmp(v57, "*U", 2u)) == 0
                || (result = (char *)strncmp(v57, "+U", 2u)) == 0 )
              {
                if ( *((_DWORD *)v1 + 14) != 2 )
                  goto LABEL_322;
                goto LABEL_340;
              }
LABEL_108:
              sub_6C054((int)v180, 0x63u, "# Invalid reply : [%s]", v57);
              break;
            case 1:
              v150 = sscanf(v57, "%4d/%2d/%2d", v1 + 24, v1 + 28, v1 + 32);
              v18 = *((_DWORD *)v1 + 7);
              v151 = *((_DWORD *)v1 + 8);
              if ( v150 == 3 && (unsigned int)(*((_DWORD *)v1 + 6) - 2000) <= 0x62 && (unsigned int)(v18 - 1) <= 0xB )
              {
                result = (char *)(v151 - 1);
                if ( (unsigned int)(v151 - 1) <= 0x1E )
                {
                  v144 = *((_DWORD *)v1 + 14);
LABEL_278:
                  if ( v144 != 2 )
                  {
                    v58 = *((__int16 *)v1 + 8);
                    if ( !off_B46E4[4 * v58 + 241] )
                    {
LABEL_280:
                      result = (char *)sub_4AAB4(v54, v55, v1);
                      goto LABEL_88;
                    }
LABEL_322:
                    v152 = (__int16)(v58 + 1);
                    *((_WORD *)v1 + 8) = v152;
                    v153 = &off_B46E4[4 * v152];
                    v154 = (char *)v153[241];
                    if ( !v154 )
                    {
                      *((_WORD *)v1 + 6) = 3;
                      goto LABEL_88;
                    }
                    v1 = (char *)v153[242];
                    if ( v1 != (char *)write(v55[7], v153[241], (size_t)v1) )
                      sub_394A0((__int16 *)v54, 3);
                    result = (char *)sub_4A084(v54, 2, v154);
                    goto LABEL_89;
                  }
LABEL_340:
                  v155 = *((_DWORD *)v1 + 16);
                  v156 = *((_DWORD *)v1 + 15);
                  if ( v155 - 2 <= v156 )
                  {
                    if ( v155 >= v156 )
                      goto LABEL_280;
                  }
                  else if ( v155 >= v156 )
                  {
                    sub_6C054((int)v180, 0x63u, "# Slow reply : timestamp=%d, %d", v156, v155);
                    break;
                  }
                  v1 = v180;
                  sub_6C054((int)v180, 0x63u, "* Over midnight : timestamp=%d, %d", v156, v155);
                  result = (char *)sub_4A084(v54, 4, v180);
                  goto LABEL_88;
                }
              }
              sub_6C054(
                (int)v180,
                0x63u,
                "# Invalid date : rc=%d year=%d month=%d day=%d",
                v150,
                *((_DWORD *)v1 + 6),
                v18,
                v151);
              break;
            default:
              goto LABEL_108;
          }
        }
        else
        {
          sub_6C054((int)v180, 0x63u, "# Invalid length : length=%d", v56);
        }
      }
      else
      {
        sub_6C054((int)v180, 0x63u, "# Unexpected reply : [%s]", v57);
      }
      result = (char *)sub_4A084(v54, 7, v180);
      v1[15] = 1;
      goto LABEL_154;
    }
    if ( v20 != 100 )
      goto LABEL_131;
    v28 = a1[1];
    v29 = *(_DWORD **)(v28 + 84);
    v1 = (char *)*v29;
    v30 = *(__int16 *)(*v29 + 8);
    v31 = *(__int16 *)(*v29 + 500);
    v32 = v31 > 4;
    if ( v31 != 4 )
      v32 = (unsigned __int16)v31 > 1u;
    if ( v32 )
    {
      if ( v30 == 32 )
      {
        v33 = *((_DWORD *)v1 + 100);
        v34 = v1 + 300;
      }
      else
      {
        v33 = v29[46];
        v34 = (const char *)(v29 + 14);
      }
      *((_WORD *)v1 + 248) = 0;
      if ( v33 == 7 )
      {
        if ( strncmp(v34, "Name ? ", 7u) )
          goto LABEL_296;
        *((_WORD *)v1 + 251) = 5;
      }
      else if ( v33 == 1 )
      {
        v98 = *(unsigned __int8 *)v34;
        if ( v98 != 62 )
          goto LABEL_192;
        *((_WORD *)v1 + 251) = 6;
      }
      else
      {
        if ( v33 <= 0 )
          goto LABEL_48;
LABEL_296:
        v98 = *(unsigned __int8 *)v34;
LABEL_192:
        if ( v98 == 63 )
          *((_WORD *)v1 + 251) = 8;
        else
LABEL_48:
          *((_WORD *)v1 + 251) = 7;
      }
      result = (char *)sub_498E8(v28, (int)v29, (int)v1);
      v14 = (const char *)*((__int16 *)v17 + 4);
      if ( v14 != (const char *)&dword_20 )
        goto LABEL_90;
      goto LABEL_50;
    }
    v93 = (__int16 *)(v1 + 512);
    if ( v30 == 32 )
    {
      v94 = *((_DWORD *)v1 + 100);
      v95 = v1 + 300;
    }
    else
    {
      v94 = v29[46];
      v95 = (const char *)(v29 + 14);
    }
    v170 = *v93;
    switch ( v94 )
    {
      case 2u:
        if ( !strncmp(v95, "OK", 2u) )
        {
          *((_WORD *)v1 + 257) = 4;
          goto LABEL_182;
        }
        goto LABEL_229;
      case 7u:
        if ( !strncmp(v95, "CONNECT", 7u) )
        {
          *((_WORD *)v1 + 257) = 5;
          goto LABEL_182;
        }
        goto LABEL_229;
      case 4u:
        if ( !strncmp(v95, "RING", 4u) )
        {
          *((_WORD *)v1 + 257) = 6;
          goto LABEL_182;
        }
        if ( !strncmp(v95, "BUSY", 4u) )
        {
          *((_WORD *)v1 + 257) = 11;
          goto LABEL_182;
        }
        goto LABEL_229;
      case 0xAu:
        if ( !strncmp(v95, "NO CARRIER", 0xAu) )
        {
          *((_WORD *)v1 + 257) = 7;
          goto LABEL_182;
        }
        if ( strncmp(v95, "CONNECT ", 8u) )
          goto LABEL_229;
        break;
      case 5u:
        if ( !strncmp(v95, "ERROR", 5u) )
        {
          *((_WORD *)v1 + 257) = 8;
          goto LABEL_182;
        }
        goto LABEL_229;
      default:
        if ( v94 <= 7 )
          goto LABEL_375;
        if ( strncmp(v95, "CONNECT ", 8u) )
        {
          if ( v94 == 11 )
          {
            if ( !strncmp(v95, "NO DAILTONE", 0xBu) )
            {
              *((_WORD *)v1 + 257) = 10;
              goto LABEL_182;
            }
          }
          else
          {
LABEL_375:
            if ( v94 == 9 && !strncmp(v95, "NO ANSWER", 9u) )
            {
              *((_WORD *)v1 + 257) = 12;
              goto LABEL_182;
            }
          }
LABEL_229:
          *((_WORD *)v1 + 257) = 13;
          goto LABEL_182;
        }
        break;
    }
    *((_WORD *)v1 + 257) = 9;
LABEL_182:
    result = (char *)sub_49B10(v28, (int)v29, v1);
    v96 = *v93;
    if ( v170 == v96 )
      goto LABEL_89;
    if ( *v93 )
    {
      if ( v96 != 3 )
        goto LABEL_89;
      v97 = 2;
    }
    else
    {
      v97 = 3;
    }
    *((_WORD *)v1 + 251) = v97;
    result = (char *)sub_498E8(v28, (int)v29, (int)v1);
    v14 = (const char *)*((__int16 *)v17 + 4);
    if ( v14 != (const char *)&dword_20 )
      goto LABEL_90;
LABEL_50:
    v35 = *((_DWORD *)v17 + 46);
    v168 = v16 + 1;
    if ( v35 <= v16 + 1 )
    {
      v49 = v17;
      if ( v168 <= 0 )
        goto LABEL_82;
      goto LABEL_286;
    }
    v14 = (const char *)&dword_20;
LABEL_91:
    if ( *((_WORD *)v17 + 6) != 2 )
      goto LABEL_78;
  }
  if ( v20 != 2 )
  {
    if ( v20 > 2 )
    {
      v51 = a1[1];
      v75 = *(_DWORD **)(v51 + 84);
      v1 = (char *)*v75;
      v76 = *(__int16 *)(*v75 + 2);
      if ( *(_WORD *)(*v75 + 8) == 32 )
      {
        result = v1 + 300;
        v77 = *((_DWORD *)v1 + 100);
      }
      else
      {
        v77 = v75[46];
        result = (char *)(v75 + 14);
      }
      if ( v76 == 1 )
      {
        if ( v77 != 15 )
          goto LABEL_152;
        v113 = (unsigned __int8 *)(result - 1);
        v114 = 0;
        do
        {
          v115 = *++v113;
          v114 ^= v115;
        }
        while ( result + 12 != (char *)v113 );
        v116 = (unsigned __int8)result[13];
        v117 = (unsigned __int8)result[14];
        v118 = (v114 >> 4) | 0x30;
        v119 = v114 & 0xF | 0x30;
        if ( v118 != v116 || v119 != v117 )
        {
          sub_6C054((int)v178, 0x3Bu, " BCC error : Recv=%02X,%02X / Calc=%02X,%02X ", v116, v117, v118, v119);
          sub_6C054((int)v180, 0x63u, "# Invalid reply : [%s]");
          goto LABEL_153;
        }
      }
      else
      {
        if ( v76 != 2 && v76 != 3 )
          goto LABEL_88;
        if ( v77 != 17 )
          goto LABEL_152;
      }
      v78 = sscanf(result, "%2d%2d%2d%*1d%2d%2d%2d", v1 + 24, v1 + 28, v1 + 32, v1 + 36, v1 + 40, v1 + 44);
      v79 = *((_DWORD *)v1 + 7);
      v80 = *((_DWORD *)v1 + 8);
      v81 = *((_DWORD *)v1 + 9);
      if ( v78 == 6 )
      {
        v82 = *((_DWORD *)v1 + 10);
        v83 = *((_DWORD *)v1 + 11);
        v84 = *((_DWORD *)v1 + 6);
        if ( (unsigned int)(v79 - 1) <= 0xB && (unsigned int)(v80 - 1) <= 0x1E && v81 <= 23 && v82 <= 59 && v83 <= 60 )
        {
          v85 = *((unsigned __int16 *)v1 + 1);
          *((_DWORD *)v1 + 6) = v84 + 2000;
          if ( (unsigned int)(v85 - 2) <= 1 )
          {
            v161 = v83 - 1;
            *((_DWORD *)v1 + 11) = v161;
            *((_DWORD *)v1 + 12) = 500;
            if ( v161 < 0 )
            {
              v162 = v82 - 1;
              *((_DWORD *)v1 + 10) = v162;
              *((_DWORD *)v1 + 11) = 59;
              if ( v162 < 0 )
              {
                v163 = v81 - 1;
                *((_DWORD *)v1 + 10) = 59;
                *((_DWORD *)v1 + 9) = v163;
                if ( v163 < 0 )
                {
                  *((_DWORD *)v1 + 8) = v80 - 1;
                  *((_DWORD *)v1 + 9) = 23;
                  if ( v80 == 1 )
                  {
                    *((_DWORD *)v1 + 7) = v79 - 1;
                    if ( v79 == 1 )
                    {
                      *((_DWORD *)v1 + 7) = 12;
                      *((_DWORD *)v1 + 6) = v84 + 1999;
                    }
                  }
                }
              }
            }
          }
          result = (char *)sub_4AAB4(v51, v75, v1);
          if ( *((_WORD *)v1 + 1) == 3 )
          {
            if ( write(v75[7], "#", 1u) != 1 )
              sub_394A0((__int16 *)v51, 3);
            result = (char *)sub_4A084(v51, 2, "#");
          }
LABEL_88:
          *((_WORD *)v17 + 6) = 3;
          goto LABEL_89;
        }
      }
      else
      {
        v82 = *((_DWORD *)v1 + 10);
        v83 = *((_DWORD *)v1 + 11);
        v84 = *((_DWORD *)v1 + 6);
      }
      sub_6C054(
        (int)v180,
        0x63u,
        "# Invalid time : rc=%d year=%d month=%d day=%d hour=%d minute=%d second=%d",
        v78,
        v84,
        v79,
        v80,
        *((_DWORD *)v1 + 9),
        v82,
        v83);
      goto LABEL_153;
    }
    if ( v20 == 1 )
    {
      v21 = a1[1];
      v22 = *(int **)(v21 + 84);
      v1 = (char *)*v22;
      v23 = *(__int16 *)(*v22 + 16);
      v24 = *(__int16 *)(*v22 + 8);
      v25 = v24 == 32;
      if ( v24 == 32 )
      {
        v14 = v1 + 300;
        v26 = (int (*)())*((_DWORD *)v1 + 100);
      }
      else
      {
        v26 = (int (*)())v22[46];
      }
      v27 = &off_B46E4[5 * v23];
      if ( !v25 )
        v14 = (const char *)(v22 + 14);
      if ( v27[206] )
      {
        if ( v27[208] == v26 || v26 == v27[209] )
        {
          switch ( LOBYTE(off_B46E4[5 * v23 + 205]) )
          {
            case 1:
              v99 = sscanf(v14, "%4d/%2d/%2d", v1 + 24, v1 + 28, v1 + 32);
              v18 = *((_DWORD *)v1 + 7);
              result = (char *)*((_DWORD *)v1 + 8);
              if ( v99 == 3
                && (unsigned int)(*((_DWORD *)v1 + 6) - 2000) <= 0x62
                && (unsigned int)(v18 - 1) <= 0xB
                && (unsigned int)(result - 1) <= 0x1E )
              {
                v100 = *((_DWORD *)v1 + 14);
                goto LABEL_200;
              }
              sub_6C054(
                (int)v180,
                0x63u,
                "# Invalid date : rc=%d year=%d month=%d day=%d",
                v99,
                *((_DWORD *)v1 + 6),
                v18,
                result);
              break;
            case 2:
            case 3:
              v106 = *((_DWORD *)v1 + 14);
              if ( v106 > 1 )
              {
                sub_6C054((int)v180, 0x63u, "# Too many reply : count=%d", v106);
                break;
              }
              v107 = sscanf(v14, "%2d:%2d:%2d", v1 + 36, v1 + 40, v1 + 44);
              v108 = *((_DWORD *)v1 + 9);
              v109 = *((_DWORD *)v1 + 10);
              v110 = *((_DWORD *)v1 + 11);
              if ( v107 != 3 || v108 > 23 || v109 > 59 || v110 > 60 )
              {
                sub_6C054(
                  (int)v180,
                  0x63u,
                  "# Invalid time : rc=%d hour=%d minute=%d second=%d",
                  v107,
                  *((_DWORD *)v1 + 9),
                  v109,
                  v110);
                break;
              }
              v111 = *((_DWORD *)v1 + 14);
              v112 = v109 + 60 * v108;
              v18 = 0;
              result = &v1[4 * v111];
              v100 = v111 + 1;
              *((_DWORD *)result + 15) = v110 + 60 * v112;
              *((_DWORD *)v1 + 14) = v100;
              *((_DWORD *)v1 + 12) = 0;
LABEL_200:
              if ( v100 != 2 )
              {
                v23 = *((__int16 *)v1 + 8);
                if ( !off_B46E4[5 * v23 + 206] )
                  goto LABEL_88;
LABEL_202:
                v101 = (__int16)(v23 + 1);
                v18 = 5 * v101;
                *((_WORD *)v1 + 8) = v101;
                v102 = &off_B46E4[5 * v101];
                v1 = (char *)v102[206];
                if ( v1 )
                {
                  v103 = (size_t)v102[207];
                  if ( v103 != write(v22[7], v102[206], v103) )
                    sub_394A0((__int16 *)v21, 3);
                  result = (char *)sub_4A084(v21, 2, v1);
                  goto LABEL_89;
                }
                goto LABEL_88;
              }
LABEL_209:
              v104 = *((_DWORD *)v1 + 16);
              v105 = *((_DWORD *)v1 + 15);
              if ( v104 - 2 <= v105 )
              {
                if ( v104 < v105 )
                  goto LABEL_211;
                result = (char *)sub_4AAB4(v21, v22, v1);
                goto LABEL_88;
              }
              if ( v104 < v105 )
              {
LABEL_211:
                v1 = v180;
                sub_6C054((int)v180, 0x63u, "* Over midnight : timestamp=%d, %d", v105, v104);
                result = (char *)sub_4A084(v21, 4, v180);
                goto LABEL_88;
              }
              sub_6C054((int)v180, 0x63u, "# Slow reply : timestamp=%d, %d", v105, v104);
              break;
            case 4:
              result = (char *)strncmp(v14, "adjusted", 8u);
              if ( !result )
                goto LABEL_208;
              result = (char *)strncmp(v14, "unadjusted", 0xAu);
              if ( !result )
                goto LABEL_208;
              goto LABEL_220;
            case 5:
              result = (char *)strncmp(v14, "valid", 5u);
              if ( result )
              {
                result = (char *)strncmp(v14, "invalid", 7u);
                if ( result )
                  goto LABEL_220;
              }
LABEL_208:
              if ( *((_DWORD *)v1 + 14) == 2 )
                goto LABEL_209;
              goto LABEL_202;
            default:
LABEL_220:
              sub_6C054((int)v180, 0x63u, "# Invalid reply : [%s]", v14);
              break;
          }
        }
        else
        {
          sub_6C054((int)v180, 0x63u, "# Invalid length : length=%d", v26);
        }
      }
      else
      {
        sub_6C054((int)v180, 0x63u, "# Unexpected reply : [%s]", v14);
      }
      result = (char *)sub_4A084(v21, 7, v180);
      v1[15] = 1;
      goto LABEL_154;
    }
LABEL_131:
    v14 = (const char *)*((__int16 *)v17 + 4);
    *((_WORD *)v17 + 6) = 4;
    if ( v14 != (const char *)&dword_20 )
      goto LABEL_90;
    goto LABEL_50;
  }
  v51 = a1[1];
  v64 = *(_DWORD **)(v51 + 84);
  v1 = (char *)*v64;
  if ( *(_WORD *)(*v64 + 8) == 32 )
  {
    v65 = v1 + 300;
    v18 = *((_DWORD *)v1 + 100);
  }
  else
  {
    v18 = v64[46];
    v65 = (const char *)(v64 + 14);
  }
  if ( *(_WORD *)(*v64 + 16) != 1 )
  {
LABEL_189:
    sub_6C054((int)v180, 0x63u, "# Unexpected reply : [%s]");
    goto LABEL_153;
  }
  v66 = *((_DWORD *)v1 + 74);
  if ( v66 > 16 && v1[v66 + 192] == 3 )
  {
    if ( v18 == 15 )
    {
      v67 = sscanf(v65, "J%2d%2d%2d%*1d%2d%2d%2d%1d", v1 + 24, v1 + 28, v1 + 32, v1 + 36, v1 + 40, v1 + 44, v1 + 48);
      v68 = *((_DWORD *)v1 + 7);
      v69 = *((_DWORD *)v1 + 8);
      v70 = *((_DWORD *)v1 + 9);
      if ( v67 == 7 )
      {
        v71 = *((_DWORD *)v1 + 10);
        v72 = *((_DWORD *)v1 + 11);
        v73 = *((_DWORD *)v1 + 6);
        if ( (unsigned int)(v68 - 1) <= 0xB && (unsigned int)(v69 - 1) <= 0x1E && v70 <= 23 && v71 <= 59 && v72 <= 60 )
        {
          v74 = *((_DWORD *)v1 + 12);
          *((_DWORD *)v1 + 6) = v73 + 2000;
          *((_DWORD *)v1 + 12) = 100 * v74;
          result = (char *)sub_4AAB4(v51, v64, v1);
          goto LABEL_88;
        }
      }
      else
      {
        v71 = *((_DWORD *)v1 + 10);
        v72 = *((_DWORD *)v1 + 11);
        v73 = *((_DWORD *)v1 + 6);
      }
      sub_6C054(
        (int)v180,
        0x63u,
        "# Invalid time : rc=%d year=%d month=%d day=%d hour=%d minute=%d second=%d",
        v67,
        v73,
        v68,
        v69,
        v70,
        v71,
        v72);
      goto LABEL_153;
    }
    sub_6C054((int)v180, 0x63u, "# Invalid length : length=%d", v18);
    result = (char *)sub_4A084(v51, 7, v180);
    v1[15] = 1;
LABEL_154:
    *((_WORD *)v17 + 6) = 4;
    goto LABEL_89;
  }
  v14 = (const char *)*((__int16 *)v17 + 4);
  if ( v14 != (const char *)&dword_20 )
  {
LABEL_90:
    if ( v14 == (_BYTE *)&dword_0 + 1 )
    {
      v49 = v17;
      goto LABEL_82;
    }
    goto LABEL_91;
  }
LABEL_78:
  v49 = v17;
  v50 = v168 > 0;
  if ( v14 != (const char *)&dword_20 )
    v50 = 0;
  if ( v50 )
  {
    v35 = *((_DWORD *)v17 + 46);
LABEL_283:
    if ( v168 < v35 )
    {
      v145 = (char *)&v49[v168 + 84];
      result = (char *)&v49[v35 + 84];
      v146 = v49 + 83;
      do
      {
        v147 = *v145++;
        *++v146 = v147;
      }
      while ( result != v145 );
    }
LABEL_286:
    v148 = v168;
    v149 = v35 - v168;
    if ( v149 >= 0 )
      *((_DWORD *)v49 + 46) = v149;
    else
      v148 = 0;
    if ( v149 < 0 )
      *((_DWORD *)v49 + 46) = v148;
  }
LABEL_82:
  v49[14] = 0;
  return result;
}
// 4C844: variable 'v18' is possibly undefined
// 0: using guessed type int dword_0;
// 20: using guessed type int;
// 60: using guessed type int dword_60;
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// B46E4: using guessed type int (*off_B46E4[135])();

//----- (0004E12C) --------------------------------------------------------
int sub_4E12C()
{
  return 1;
}

//----- (0004E174) --------------------------------------------------------
int sub_4E174()
{
  return 0;
}

//----- (0004E1BC) --------------------------------------------------------
int sub_4E1BC()
{
  return 0;
}

//----- (0004E204) --------------------------------------------------------
int sub_4E204()
{
  return 0;
}

//----- (0004E24C) --------------------------------------------------------
int sub_4E24C()
{
  return 1;
}

//----- (0004E294) --------------------------------------------------------
int sub_4E294()
{
  return 0;
}

//----- (0004E2DC) --------------------------------------------------------
int sub_4E2DC()
{
  return 1;
}

//----- (0004E324) --------------------------------------------------------
int sub_4E324()
{
  return 1;
}

//----- (0004E36C) --------------------------------------------------------
int sub_4E36C()
{
  return 0;
}

//----- (0004E3B4) --------------------------------------------------------
int sub_4E3B4()
{
  return 1;
}

//----- (0004E3FC) --------------------------------------------------------
int sub_4E3FC()
{
  return 1;
}

//----- (0004E444) --------------------------------------------------------
int sub_4E444()
{
  return 0;
}

//----- (0004E48C) --------------------------------------------------------
int sub_4E48C()
{
  return 1;
}

//----- (0004E4D4) --------------------------------------------------------
int sub_4E4D4()
{
  return 0;
}

//----- (0004E51C) --------------------------------------------------------
int sub_4E51C()
{
  return 1;
}

//----- (0004E564) --------------------------------------------------------
int sub_4E564()
{
  return 0;
}

//----- (0004E5AC) --------------------------------------------------------
int sub_4E5AC()
{
  return 1;
}

//----- (0004E5F4) --------------------------------------------------------
int sub_4E5F4()
{
  return 0;
}

//----- (0004E63C) --------------------------------------------------------
int sub_4E63C()
{
  return 1;
}

//----- (0004E684) --------------------------------------------------------
int sub_4E684()
{
  return 1;
}

//----- (0004E6CC) --------------------------------------------------------
int sub_4E6CC()
{
  _BYTE *v0; // r0
  int v2; // [sp+4h] [bp-4h]

  v0 = memset(&unk_BD578, 0, 0x6Cu);
  v0[108] = 0;
  *((_DWORD *)v0 + 28) = 1297044545;
  return v2;
}
// 4E708: variable 'v2' is possibly undefined

//----- (0004E744) --------------------------------------------------------
int __fastcall sub_4E744(unsigned __int8 *a1, _WORD *a2)
{
  __int16 v2; // r3
  __int16 v3; // r2
  __int16 v5; // r12
  __int16 v6; // r4
  __int16 v7; // r5
  __int16 v8; // r0
  unsigned __int16 v9; // r3
  unsigned __int16 v10; // r5
  unsigned int v11; // r2
  bool v12; // cc
  int v13; // r0

  v2 = a1[88] - 48;
  if ( (unsigned __int8)v2 > 9u )
    return 0;
  v3 = a1[89] - 48;
  if ( (unsigned __int8)v3 > 9u )
    return 0;
  v5 = a1[90] - 48;
  if ( (unsigned __int8)v5 > 9u )
    return 0;
  v6 = a1[91] - 48;
  if ( (unsigned __int8)v6 > 9u )
    return 0;
  v7 = a1[92] - 48;
  if ( (unsigned __int8)v7 > 9u )
    return 0;
  v8 = a1[93] - 48;
  if ( (unsigned __int8)v8 > 9u )
    return 0;
  v9 = v3 + 10 * v2;
  v10 = v8 + 10 * v7;
  v11 = (unsigned __int16)(v6 + 10 * v5);
  v12 = v11 > 0x3C;
  if ( v11 <= 0x3C )
    v12 = v9 > 0x17u;
  a2[23] = v9;
  v13 = v12;
  if ( v10 > 0x3Cu )
    v13 |= 1u;
  a2[25] = v11;
  a2[24] = v10;
  return v13 ^ 1;
}

//----- (0004E854) --------------------------------------------------------
int __fastcall sub_4E854(int result)
{
  char *v1; // r4
  _WORD **v2; // r3
  int v3; // r6
  char *v4; // r4
  int v5; // r1
  char *v6; // r4
  int v7; // r1
  __int16 v8; // r3
  __int16 v9; // r2
  _DWORD *v10; // r4
  int v11; // r1
  __int16 v12; // r1
  __int16 v13; // r12
  __int16 v14; // lr
  unsigned __int16 v15; // r12
  unsigned int v16; // r7
  unsigned int v17; // r1
  unsigned int v18; // r3
  int v19; // r12
  int i; // r1
  __int16 v21; // r2
  int v22; // r4
  int v23; // r4
  int v24; // r1
  int v25; // r1

  if ( *(_DWORD *)(result + 84) == 7 )
  {
    v1 = (char *)result;
    v2 = *(_WORD ***)(*(_DWORD *)(result + 4) + 84);
    v3 = (int)*v2;
    switch ( (*v2)[26] )
    {
      case 0:
        return result;
      case 1:
        v8 = *(unsigned __int8 *)(result + 88) - 48;
        if ( (unsigned __int8)v8 > 9u )
          goto LABEL_12;
        v9 = *(unsigned __int8 *)(result + 89) - 48;
        if ( (unsigned __int8)v9 > 9u )
          goto LABEL_12;
        v12 = *(unsigned __int8 *)(result + 90) - 48;
        result = (unsigned __int8)v12;
        if ( (unsigned __int8)v12 > 9u )
          goto LABEL_12;
        v13 = (unsigned __int8)v1[91] - 48;
        result = (unsigned __int8)v13;
        if ( (unsigned __int8)v13 > 9u )
          goto LABEL_12;
        v14 = (unsigned __int8)v1[92] - 48;
        result = (unsigned __int8)v14;
        if ( (unsigned __int8)v14 > 9u )
          goto LABEL_12;
        result = (unsigned __int8)v1[93] - 48;
        if ( (unsigned __int8)result > 9u )
          goto LABEL_12;
        v15 = v13 + 10 * v12;
        v16 = v15;
        v17 = (unsigned __int16)(result + 10 * v14);
        v18 = (unsigned __int16)(v9 + 10 * v8);
        result = (__int16)v17;
        *(_WORD *)(v3 + 42) = v15;
        *(_WORD *)(v3 + 38) = v18;
        *(_WORD *)(v3 + 44) = v17;
        if ( v15 > 0xCu || (v19 = v15 - 1, byte_987A8[v16 - 1] < v17) )
        {
LABEL_12:
          *(_WORD *)(v3 + 52) = 0;
        }
        else
        {
          *(_WORD *)(v3 + 40) = v17;
          for ( i = 0; v19 > i; ++i )
          {
            v21 = byte_987A8[i];
            *(_WORD *)(v3 + 40) += v21;
          }
          v22 = 1900;
          if ( v18 <= 0x5A )
            v22 = 2000;
          v23 = v18 + v22;
          if ( (v23 & 3) != 0 || (sub_8BB9C(v23, 0x64u), !v24) && (sub_8BB9C(v23, 0x190u), v25) )
          {
            if ( v16 > 2 )
              --*(_WORD *)(v3 + 40);
          }
          result = write(*(_DWORD *)(v3 + 24), &off_987B4, 3u);
          if ( result < 0 )
            result = (int)sub_64E00(3, "leitch_send: unit %d send failed %m", *(unsigned __int8 *)(v3 + 36));
          *(_WORD *)(v3 + 52) = 2;
        }
        break;
      case 2:
        sub_4E744((unsigned __int8 *)result, *v2);
        result = sub_633D8(
                   *(__int16 *)(v3 + 40),
                   *(__int16 *)(v3 + 46),
                   *(__int16 *)(v3 + 50),
                   *(__int16 *)(v3 + 48),
                   1,
                   *((_DWORD *)v1 + 18),
                   (int *)(v3 + 104),
                   (_DWORD *)(v3 + 56));
        if ( !result )
          goto LABEL_4;
        v6 = v1 + 72;
        *(_DWORD *)(v3 + 60) = sub_8BFD0(
                                 (unsigned __int64)&loc_7A120
                               + __PAIR64__(1000 * (unsigned int)*(unsigned __int16 *)(v3 + 54), 0),
                                 (unsigned int)&unk_F4240);
        result = *(_DWORD *)v6;
        v7 = *((_DWORD *)v6 + 1);
        *(_DWORD *)(v3 + 80) = *(_DWORD *)v6;
        *(_DWORD *)(v3 + 84) = v7;
        *(_WORD *)(v3 + 52) = 3;
        break;
      case 3:
        sub_4E744((unsigned __int8 *)result, *v2);
        result = sub_633D8(
                   *(__int16 *)(v3 + 40),
                   *(__int16 *)(v3 + 46),
                   *(__int16 *)(v3 + 50),
                   *(__int16 *)(v3 + 48),
                   1,
                   *((_DWORD *)v1 + 18),
                   (int *)(v3 + 104),
                   (_DWORD *)(v3 + 64));
        if ( !result )
          goto LABEL_4;
        v4 = v1 + 72;
        *(_DWORD *)(v3 + 68) = sub_8BFD0(
                                 (unsigned __int64)&loc_7A120
                               + __PAIR64__(1000 * (unsigned int)*(unsigned __int16 *)(v3 + 54), 0),
                                 (unsigned int)&unk_F4240);
        result = *(_DWORD *)v4;
        v5 = *((_DWORD *)v4 + 1);
        *(_DWORD *)(v3 + 88) = *(_DWORD *)v4;
        *(_DWORD *)(v3 + 92) = v5;
        *(_WORD *)(v3 + 52) = 4;
        break;
      case 4:
        sub_4E744((unsigned __int8 *)result, *v2);
        result = sub_633D8(
                   *(__int16 *)(v3 + 40),
                   *(__int16 *)(v3 + 46),
                   *(__int16 *)(v3 + 50),
                   *(__int16 *)(v3 + 48),
                   0,
                   *((_DWORD *)v1 + 18),
                   (int *)(v3 + 104),
                   (_DWORD *)(v3 + 72));
        if ( result )
        {
          v10 = v1 + 72;
          *(_DWORD *)(v3 + 76) = sub_8BFD0(
                                   (unsigned __int64)&loc_7A120
                                 + __PAIR64__(1000 * (unsigned int)*(unsigned __int16 *)(v3 + 54), 0),
                                   (unsigned int)&unk_F4240);
          v11 = v10[1];
          *(_DWORD *)(v3 + 96) = *v10;
          *(_DWORD *)(v3 + 100) = v11;
          result = sub_39D44(*(_DWORD *)v3);
          *(_WORD *)(v3 + 52) = 0;
        }
        else
        {
LABEL_4:
          *(_WORD *)(v3 + 52) = result;
        }
        break;
      default:
        result = (int)sub_64E00(
                        3,
                        "leitech_receive: invalid state %d unit %d",
                        (__int16)(*v2)[26],
                        *(unsigned __int8 *)(v3 + 36));
        break;
    }
  }
  return result;
}
// 4EBF8: variable 'v24' is possibly undefined
// 4EC0C: variable 'v25' is possibly undefined
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// 987A8: using guessed type unsigned __int8 byte_987A8[12];
// 987B4: using guessed type _UNKNOWN *off_987B4;

//----- (0004EC80) --------------------------------------------------------
int __fastcall sub_4EC80(int a1, int a2, _BYTE *s)
{
  bool v3; // cc
  int result; // r0
  char v7; // r3
  int v8; // r1
  int v9; // r3
  int v10; // r1

  v3 = a1 <= 0;
  result = 2092;
  if ( !v3 )
    return (int)sub_64E00(3, "leitch_control: unit %d invalid", a1);
  if ( a2 )
  {
    v7 = *(_BYTE *)(a2 + 2);
    if ( (v7 & 4) != 0 )
    {
      result = *(_DWORD *)(a2 + 56);
      *((_BYTE *)&unk_BD578 + a1 + 116) = result;
    }
    if ( (v7 & 8) != 0 )
      *((_DWORD *)&unk_BD578 + a1 + 28) = *(_DWORD *)(a2 + 60);
    if ( *((_BYTE *)&unk_BD578 + a1 + 108) )
    {
      result = *((unsigned __int8 *)&unk_BD578 + a1 + 116);
      v8 = *((_DWORD *)&unk_BD578 + a1 + 28);
      v9 = *((_DWORD *)&unk_BD578 + 27 * a1);
      *(_BYTE *)(v9 + 93) = result;
      *(_DWORD *)(v9 + 112) = v8;
    }
  }
  if ( s )
  {
    memset(s, 0, 0x48u);
    *s = 13;
    s[2] = 12;
    result = *((unsigned __int8 *)&unk_BD578 + a1 + 116);
    v10 = *((_DWORD *)&unk_BD578 + a1 + 28);
    *((_DWORD *)s + 2) = byte_97F7C;
    *((_DWORD *)s + 14) = result;
    *((_DWORD *)s + 15) = v10;
    *((_DWORD *)s + 8) = "Leitch: CSD 5300 Master Clock System Driver";
  }
  return result;
}

//----- (0004EDF4) --------------------------------------------------------
char *__fastcall sub_4EDF4(char *result)
{
  char *v1; // r6
  char *v2; // r5

  v1 = result;
  if ( (int)result <= 0 )
  {
    v2 = (char *)&word_BD578[54 * (_DWORD)result];
    if ( *((_WORD *)v2 + 26) )
    {
      *((_WORD *)v2 + 26) = 0;
    }
    else
    {
      result = (char *)write(*((_DWORD *)v2 + 6), "D\r", 3u);
      if ( (int)result < 0 )
        result = sub_64E00(3, "leitch_send: unit %d send failed %m", (unsigned __int8)v2[36]);
      word_BD578[54 * (_DWORD)v1 + 26] = 1;
    }
  }
  return result;
}
// BD578: using guessed type _WORD word_BD578[60];

//----- (0004EEC4) --------------------------------------------------------
char *__fastcall sub_4EEC4(char *result)
{
  int v1; // r2

  if ( (int)result <= 0 )
  {
    v1 = 54 * (_DWORD)result;
    result = *(char **)&word_BD578[54 * (_DWORD)result + 12];
    if ( result != (char *)-1 )
      return sub_18E64((int)&word_BD578[v1 + 2]);
  }
  return result;
}
// BD578: using guessed type _WORD word_BD578[60];

//----- (0004EF58) --------------------------------------------------------
int __fastcall sub_4EF58(int a1, int a2)
{
  char *v3; // r8
  tcflag_t v4; // r4
  int v6; // r7
  int v7; // r2
  _WORD *v9; // [sp+Ch] [bp-60h]
  struct termios v10; // [sp+14h] [bp-58h] BYREF
  char v11[20]; // [sp+50h] [bp-1Ch] BYREF

  if ( a1 > 0 )
  {
    sub_64E00(3, "leitch_start: unit %d invalid", a1);
    return 0;
  }
  else
  {
    v3 = (char *)word_BD578 + a1;
    v4 = *((unsigned __int8 *)&word_BD578[54] + a1);
    if ( *((_BYTE *)&word_BD578[54] + a1) )
    {
      sub_64E00(3, "leitch_start: unit %d in use", a1);
      return 0;
    }
    else
    {
      sub_6C054((int)v11, 0x14u, "/dev/leitch%d", a1);
      v6 = open64(v11, 2, 511);
      if ( v6 == -1 )
      {
        sub_64E00(3, "leitch_start: open of %s: %m", v11);
        return v4;
      }
      else
      {
        v9 = &word_BD578[54 * a1];
        memset(v9, v4, 0x6Cu);
        if ( tcgetattr(v6, &v10) < 0 )
        {
          sub_64E00(3, "leitch_start: tcgetattr(%s): %m", v11);
        }
        else
        {
          v10.c_cflag = 2231;
          v10.c_oflag = v4;
          v10.c_cc[3] = v4;
          v10.c_cc[2] = v4;
          v10.c_iflag = 261;
          v10.c_lflag = 2;
          if ( tcsetattr(v6, v4, &v10) < 0 )
          {
            sub_64E00(3, "leitch_start: tcsetattr(%s): %m", v11);
          }
          else if ( tcflush(v6, 2) < 0 )
          {
            sub_64E00(3, "leitch_start: tcflush(%s): %m", v11);
          }
          else
          {
            *(_DWORD *)&word_BD578[54 * a1] = a2;
            *((_DWORD *)v9 + 5) = v4;
            *((_DWORD *)v9 + 2) = sub_4E854;
            *((_BYTE *)v9 + 36) = a1;
            *((_DWORD *)v9 + 4) = a2;
            *((_DWORD *)v9 + 6) = v6;
            *((_DWORD *)v9 + 13) = 983040;
            if ( sub_18DF0((int *)&word_BD578[54 * a1 + 2]) )
            {
              v7 = *(_DWORD *)&word_BD578[2 * a1 + 56];
              *(_BYTE *)(a2 + 93) = v3[116];
              *(_BYTE *)(a2 + 95) = -20;
              *(_DWORD *)(a2 + 112) = v7;
              v3[108] = 1;
              return 1;
            }
            *((_DWORD *)v9 + 6) = -1;
          }
        }
        close(v6);
        return 0;
      }
    }
  }
}
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// BD578: using guessed type _WORD word_BD578[60];

//----- (0004F1C8) --------------------------------------------------------
int __fastcall sub_4F1C8(int a1, int a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a2 + 84);
  *(_BYTE *)(a2 + 95) = sys_precision;
  *(_BYTE *)(v2 + 40) = 3;
  *(_BYTE *)(a2 + 93) = 5;
  *(_BYTE *)(v2 + 760) = 5;
  *(_DWORD *)(v2 + 764) = *(_DWORD *)"LOCL";
  *(_DWORD *)(v2 + 44) = "Undisciplined local clock";
  return 1;
}
// 108BA8: using guessed type char sys_precision;

//----- (0004F260) --------------------------------------------------------
int __fastcall sub_4F260(int a1, int a2)
{
  bool v3; // zf
  int v4; // r5
  int v5; // r0
  int v6; // r1
  int result; // r0

  v3 = sys_peer == a2;
  if ( sys_peer != a2 )
    v3 = sys_peer == 0;
  if ( v3 )
  {
    v4 = *(_DWORD *)(a2 + 84);
    ++*(_DWORD *)(v4 + 776);
    sub_39A70((_DWORD *)v4, *(_DWORD *)(v4 + 232), *(_DWORD *)(v4 + 236));
    *(_BYTE *)(v4 + 40) = 0;
    v5 = *(_DWORD *)(v4 + 232);
    v6 = *(_DWORD *)(v4 + 236);
    *(_QWORD *)(v4 + 256) = 0;
    *(_QWORD *)(v4 + 248) = 0x3F847AE147AE147BLL;
    *(_DWORD *)(v4 + 224) = v5;
    *(_DWORD *)(v4 + 228) = v6;
    return sub_39D44(a2);
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// 108C2C: using guessed type int sys_peer;

//----- (0004F360) --------------------------------------------------------
int __fastcall sub_4F360(int a1, int a2)
{
  int *v2; // r2
  int result; // r0

  v2 = *(int **)(a2 + 84);
  result = *v2;
  ++v2[194];
  *(_DWORD *)(result + 20) = 1;
  return result;
}

//----- (0004F3C0) --------------------------------------------------------
int __fastcall sub_4F3C0(double a1, int a2, int a3)
{
  int v4; // r8
  double *v5; // r5
  int v6; // r4
  int v7; // r3
  unsigned int *v8; // r5
  void *v9; // r0
  void *v10; // r0
  void *v11; // r0
  void *v12; // r0
  void *v13; // r0
  int v14; // r3
  void *v15; // r0
  int v16; // r3
  void *v17; // r0
  int v18; // r3
  void *v19; // r0
  void *v20; // r0
  void *v21; // r0
  void *v22; // r0
  char v24[80]; // [sp+1Ch] [bp-58h] BYREF

  v4 = LODWORD(a1);
  if ( !a3 || (v5 = *(double **)(a3 + 84)) == 0 || (v6 = *(_DWORD *)v5) == 0 )
  {
    LODWORD(a1) = sub_64E00(3, "NeoClock4X(%d): control: unit invalid/inactive", LODWORD(a1));
    return LODWORD(a1);
  }
  if ( HIDWORD(a1) )
  {
    v7 = ntp_syslogmask & 0x100;
    if ( (*(_BYTE *)(HIDWORD(a1) + 2) & 1) != 0 )
    {
      a1 = *(double *)(HIDWORD(a1) + 40);
      v5[93] = a1;
      if ( !v7 )
        goto LABEL_7;
      LODWORD(a1) = sub_64E00(5, "NeoClock4X(%d): using fudgetime1 with %0.5fs from ntp.conf.", v4, a1);
      v7 = ntp_syslogmask & 0x100;
    }
    if ( ((_BYTE)v5[96] & 1) != 0 )
    {
      if ( v7 )
        LODWORD(a1) = sub_64E00(
                        5,
                        "NeoClock4X(%d): quartz clock is used to synchronize time if radio clock has no reception.",
                        v4);
    }
    else if ( v7 )
    {
      LODWORD(a1) = sub_64E00(5, "NeoClock4X(%d): time is only adjusted with radio signal reception.", v4);
    }
  }
LABEL_7:
  if ( a2 )
  {
    *(_DWORD *)(a2 + 68) = 0;
    *(_BYTE *)a2 = 44;
    v8 = (unsigned int *)(a2 + 68);
    sub_6C054(
      (int)v24,
      0x4Fu,
      "%04d-%02d-%02d %02d:%02d:%02d.%03d",
      *(_DWORD *)(v6 + 128),
      *(_DWORD *)(v6 + 132),
      *(_DWORD *)(v6 + 136),
      *(_DWORD *)(v6 + 140),
      *(_DWORD *)(v6 + 144),
      *(_DWORD *)(v6 + 148),
      *(_DWORD *)(v6 + 152));
    v9 = sub_243AC((unsigned int *)(a2 + 68), 0x4Fu, 33);
    sub_6C054((int)v9, 0x4Fu, "calc_utc=\"%s\"", v24);
    v10 = sub_243AC((unsigned int *)(a2 + 68), 0x28u, 33);
    sub_6C054((int)v10, 0x27u, "radiosignal=\"%s\"", (const char *)(v6 + 112));
    v11 = sub_243AC((unsigned int *)(a2 + 68), 0x28u, 33);
    sub_6C054((int)v11, 0x27u, "antenna1=\"%d\"", *(_DWORD *)(v6 + 120));
    v12 = sub_243AC((unsigned int *)(a2 + 68), 0x28u, 33);
    sub_6C054((int)v12, 0x27u, "antenna2=\"%d\"", *(_DWORD *)(v6 + 124));
    v13 = sub_243AC((unsigned int *)(a2 + 68), 0x28u, 33);
    v14 = *(unsigned __int8 *)(v6 + 116);
    if ( v14 == 65 )
    {
      sub_6C054((int)v13, 0x27u, "timesource=\"radio\"");
    }
    else if ( v14 == 67 )
    {
      sub_6C054((int)v13, 0x27u, "timesource=\"quartz\"");
    }
    else
    {
      sub_6C054((int)v13, 0x27u, "timesource=\"unknown\"");
    }
    v15 = sub_243AC(v8, 0x28u, 33);
    v16 = *(unsigned __int8 *)(v6 + 118);
    if ( v16 == 73 )
    {
      sub_6C054((int)v15, 0x27u, "quartzstatus=\"synchronized\"");
    }
    else if ( v16 == 88 )
    {
      sub_6C054((int)v15, 0x27u, "quartzstatus=\"not synchronized\"");
    }
    else
    {
      sub_6C054((int)v15, 0x27u, "quartzstatus=\"unknown\"");
    }
    v17 = sub_243AC(v8, 0x28u, 33);
    v18 = *(unsigned __int8 *)(v6 + 117);
    if ( v18 == 83 )
    {
      sub_6C054((int)v17, 0x27u, "dststatus=\"summer\"");
    }
    else if ( v18 == 87 )
    {
      sub_6C054((int)v17, 0x27u, "dststatus=\"winter\"");
    }
    else
    {
      sub_6C054((int)v17, 0x27u, "dststatus=\"unknown\"");
    }
    v19 = sub_243AC(v8, 0x50u, 33);
    sub_6C054((int)v19, 0x4Fu, "firmware=\"%s\"", (const char *)(v6 + 24));
    v20 = sub_243AC(v8, 0x28u, 33);
    sub_6C054((int)v20, 0x27u, "firmwaretag=\"%c\"", *(unsigned __int8 *)(v6 + 104));
    v21 = sub_243AC(v8, 0x50u, 33);
    sub_6C054((int)v21, 0x4Fu, "driver version=\"%s\"", "1.16 (2009-12-04)");
    v22 = sub_243AC(v8, 0x50u, 33);
    LODWORD(a1) = sub_6C054((int)v22, 0x4Fu, "serialnumber=\"%s\"", (const char *)(v6 + 105));
  }
  return LODWORD(a1);
}
// B7CD4: using guessed type int ntp_syslogmask;

//----- (0004F7E8) --------------------------------------------------------
char *__fastcall sub_4F7E8(int a1, int a2)
{
  int v3; // r6
  void *v4; // r8
  int v5; // r0
  char *result; // r0
  int v7; // r0
  int v8; // [sp+0h] [bp-Ch] BYREF

  if ( a2 )
  {
    v3 = *(_DWORD *)(a2 + 84);
    if ( v3 )
    {
      v4 = *(void **)v3;
      if ( *(_DWORD *)v3 )
      {
        v5 = *(_DWORD *)(v3 + 28);
        if ( v5 == -1 )
        {
          free(*(void **)v3);
          *(_DWORD *)v3 = 0;
        }
        else
        {
          if ( ioctl(v5, 0x5415u, &v8) == -1 )
            sub_64E00(2, "NeoClock4X(%d): can't query RTS/DTR state: %m", a1);
          v7 = *(_DWORD *)(v3 + 28);
          v8 &= 0xFFFFFFF9;
          if ( ioctl(v7, 0x5418u, &v8) == -1 )
            sub_64E00(2, "NeoClock4X(%d): can't set RTS/DTR to power neoclock4x: %m", a1);
          sub_18E64(v3 + 8);
          free(v4);
          *(_DWORD *)v3 = 0;
        }
      }
    }
  }
  result = sub_64E00(3, "NeoClock4X(%d): shutdown", a1);
  if ( (ntp_syslogmask & 0x100) != 0 )
    return sub_64E00(6, "NeoClock4X(%d): receiver shutdown done", a1);
  return result;
}
// B7CD4: using guessed type int ntp_syslogmask;

//----- (0004F944) --------------------------------------------------------
int __fastcall sub_4F944(int a1, int *a2)
{
  const unsigned __int16 **v4; // r0
  int v5; // r12
  int i; // r3
  int v7; // r2
  int v8; // t1

  v4 = _ctype_b_loc();
  v5 = a1 - 1;
  for ( i = 0; ; i = v7 - 48 + 10 * i )
  {
    v8 = *(unsigned __int8 *)++v5;
    v7 = v8;
    if ( ((v5 - a1 != 2) & ((*v4)[v8] >> 11)) == 0 )
      break;
  }
  *a2 = i;
  return i;
}

//----- (0004F9D8) --------------------------------------------------------
int __fastcall sub_4F9D8(int a1, int *a2)
{
  int v4; // r8
  int v5; // r10
  const unsigned __int16 *v6; // r5
  __int32_t v7; // r3
  int v8; // r3
  int v9; // r11
  int v10; // t1
  unsigned int v11; // r9
  int v12; // r3

  v4 = a1 - 1;
  v5 = 0;
  v6 = *_ctype_b_loc();
  while ( 1 )
  {
    v10 = *(unsigned __int8 *)++v4;
    v9 = v10;
    v11 = v6[v10];
    v12 = (v11 >> 12) & 1;
    if ( v4 - a1 == 2 )
      v12 = 0;
    if ( !v12 )
      break;
    v7 = (*_ctype_toupper_loc())[v9];
    if ( (v11 & 0x800) != 0 )
      v8 = v7 - 48;
    else
      v8 = v7 - 55;
    v5 = v8 + 16 * v5;
  }
  *a2 = v5;
  return v5;
}
// 4FA4C: masking with 0x1 was optimized away because r3.4 <= 0x1

//----- (0004FA84) --------------------------------------------------------
__int16 *__fastcall sub_4FA84(__int16 *result)
{
  int v1; // r8
  bool *v2; // r4
  int v3; // r7
  _BYTE *v4; // r0
  int v5; // r3
  bool *v6; // r1
  char v7; // t1
  int v8; // r2
  bool v9; // r3
  int v10; // r1
  __int16 v11; // r10
  bool v12; // r3
  __int16 v13; // r3
  unsigned int v14; // lr
  unsigned int v15; // r10
  int v16; // r0
  _BOOL4 v17; // r1
  unsigned int v18; // r1
  int v19; // r3
  int v20; // r12
  unsigned int v21; // r1
  unsigned int v22; // r2
  unsigned int v23; // r11
  int v24; // r1
  int v25; // r1
  int v26; // r1
  unsigned int v27; // r3
  unsigned int v28; // r10
  unsigned int v29; // r11
  unsigned int v30; // r10
  unsigned int v31; // r0
  int v32; // r12
  int v33; // r0
  int v34; // r0
  bool v35; // r3
  int v36; // r2
  int v37; // lr
  int v38; // kr04_4
  int v39; // r12
  int v40; // r1
  int v41; // r2
  int v42; // [sp+1Ch] [bp-30h]
  unsigned int v43; // [sp+1Ch] [bp-30h]
  unsigned int v44; // [sp+20h] [bp-2Ch]
  int v45; // [sp+34h] [bp-18h] BYREF
  int v46; // [sp+38h] [bp-14h] BYREF
  int v47; // [sp+3Ch] [bp-10h] BYREF
  int v48; // [sp+40h] [bp-Ch] BYREF

  v1 = *((_DWORD *)result + 1);
  v2 = *(bool **)(v1 + 84);
  v3 = *(_DWORD *)v2;
  if ( !*(_DWORD *)(*(_DWORD *)v2 + 20) )
    return result;
  *(_DWORD *)(v3 + 20) = 0;
  v4 = sub_39EE4((int)result, v2 + 56, 128, (_DWORD *)v2 + 58);
  v2[40] = 0;
  *((_DWORD *)v2 + 46) = v4;
  if ( v4 != (_BYTE *)&dword_24 + 1 )
  {
    if ( (ntp_syslogmask & 0x200) != 0 )
      sub_64E00(
        4,
        "NeoClock4X(%d): received data has invalid length, expected %d bytes, received %d bytes: %s",
        *(__int16 *)(v3 + 8),
        37,
        v4,
        (const char *)v2 + 56);
    return sub_394A0((__int16 *)v1, 2);
  }
  sub_4F9D8((int)(v2 + 91), &v48);
  LOBYTE(v5) = 0;
  v6 = v2 + 55;
  do
  {
    v7 = *++v6;
    v5 = (unsigned __int8)(v5 + v7);
  }
  while ( v2 + 90 != v6 );
  if ( v5 != v48 )
  {
    if ( (ntp_syslogmask & 0x200) != 0 )
      sub_64E00(4, "NeoClock4X(%d): received data has invalid chksum: %s", *(__int16 *)(v3 + 8), (const char *)v2 + 56);
    return sub_394A0((__int16 *)v1, 2);
  }
  v8 = v2[86];
  *(_BYTE *)(v3 + 118) = v8;
  v9 = v2[768];
  v10 = v9 & 2;
  if ( (v9 & 2) == 0 )
  {
    if ( v8 != 73 )
    {
      if ( (ntp_syslogmask & 0x200) != 0 )
        sub_64E00(5, "NeoClock4X(%d): quartz clock is not initialized: %s", *(__int16 *)(v3 + 8), (const char *)v2 + 56);
      v2[40] = 3;
      return sub_394A0((__int16 *)v1, 5);
    }
    goto LABEL_27;
  }
  if ( v8 != 73 && (ntp_syslogmask & 0x200) != 0 )
  {
    sub_64E00(
      5,
      "NeoClock4X(%d): using uninitialized quartz clock for time synchronization: %s",
      *(__int16 *)(v3 + 8),
      (const char *)v2 + 56);
    v9 = v2[768];
    v10 = v9 & 2;
LABEL_27:
    v16 = v2[84];
    *(_BYTE *)(v3 + 116) = v16;
    if ( v10 )
      v17 = 0;
    else
      v17 = v16 != 65;
    if ( v17 && !v9 )
    {
      result = sub_394A0((__int16 *)v1, 6);
      v2[40] = 3;
      return result;
    }
    goto LABEL_19;
  }
  *(_BYTE *)(v3 + 116) = v2[84];
LABEL_19:
  if ( (v9 & 8) != 0 )
    sub_64E00(7, "NeoClock4X(%d): received data: %s", *(__int16 *)(v3 + 8), (const char *)v2 + 56);
  sub_4F944((int)(v2 + 72), (int *)v2 + 47);
  sub_4F944((int)(v2 + 70), &v46);
  sub_4F944((int)(v2 + 68), &v45);
  sub_4F944((int)(v2 + 74), (int *)v2 + 49);
  sub_4F944((int)(v2 + 76), (int *)v2 + 50);
  sub_4F944((int)(v2 + 78), (int *)v2 + 51);
  sub_4F944((int)(v2 + 80), &v47);
  *((_DWORD *)v2 + 52) = 10000000 * v47;
  v11 = *(_WORD *)(v2 + 65);
  v12 = v2[67];
  *(_BYTE *)(v3 + 115) = 0;
  *(_WORD *)(v3 + 112) = v11;
  *(_BYTE *)(v3 + 114) = v12;
  *(_DWORD *)(v3 + 105) = *(_DWORD *)(v2 + 59);
  v13 = *(_WORD *)(v2 + 63);
  *(_BYTE *)(v3 + 111) = 0;
  *(_WORD *)(v3 + 109) = v13;
  *(_BYTE *)(v3 + 117) = v2[85];
  sub_4F9D8((int)(v2 + 87), (int *)(v3 + 120));
  sub_4F9D8((int)(v2 + 89), (int *)(v3 + 124));
  v14 = *((_DWORD *)v2 + 49);
  if ( v14 > 0x17
    || (v15 = *((_DWORD *)v2 + 50), v15 > 0x3B)
    || *((_DWORD *)v2 + 51) > 0x3Cu
    || (unsigned int)(v45 - 1) > 0x1E
    || (unsigned int)(v46 - 1) > 0xB
    || (v18 = *((_DWORD *)v2 + 47), v18 > 0x63) )
  {
    if ( (ntp_syslogmask & 0x200) != 0 )
      sub_64E00(4, "NeoClock4X(%d): date/time out of range: %s", *(__int16 *)(v3 + 8), (const char *)v2 + 56);
    return sub_394A0((__int16 *)v1, 5);
  }
  else
  {
    v19 = v46 - 2;
    v20 = v18 + 2000;
    v42 = v46 - 2;
    if ( v46 - 2 <= 0 )
      v20 = v18 + 1984;
    LOWORD(v21) = -31457;
    if ( v46 - 2 <= 0 )
    {
      v20 += 15;
      v19 = v46 + 10;
    }
    HIWORD(v21) = 20971;
    if ( v46 - 2 <= 0 )
      v42 = v19;
    v22 = *((_DWORD *)v2 + 51)
        + 60
        * (v15
         + 60
         * (v14
          + 24
          * ((v20 >> 31)
           - ((int)((unsigned __int64)(v20 * (__int64)(int)v21) >> 32) >> 5)
           + (v20 >> 2)
           + ((unsigned int)(((unsigned int)v20 * (unsigned __int64)v21) >> 32) >> 7)
           + 367 * v42 / 0xCu
           + v45
           + 365 * v20)));
    v23 = v22 - 2035175056;
    if ( *(_BYTE *)(v3 + 117) == 83 )
      v23 = v22 - 2035178656;
    sub_8B8EC(v23, 0x3Cu);
    *((_DWORD *)v2 + 51) = v24;
    sub_8BB9C(v23 / 0x3C, 0x3Cu);
    *((_DWORD *)v2 + 50) = v25;
    sub_8B8EC(v23 / 0xE10, 0x18u);
    *((_DWORD *)v2 + 49) = v26;
    v27 = v23 / 0x15180 + 2509157;
    v43 = 4 * v27 / 0x23AB1;
    v28 = v27 - ((((unsigned int)&off_23AB0 + 1) * v43 + 3) >> 2);
    v29 = (4000 * v28 + 4000) / 0x164B09;
    v30 = v28 + 31 - ((1461 * v29) >> 2);
    v44 = 80 * v30 / 0x98F;
    v31 = sub_8B690(80 * v30, 0x6925u);
    v32 = v44 + 2 - 12 * v31;
    v33 = v31 + v29 + 100 * v43 - 4900;
    *((_DWORD *)v2 + 47) = v33;
    v45 = v30 - 2447 * v44 / 0x50;
    v46 = v32;
    v34 = sub_6EC68(v33, v32, v45);
    v35 = v2[768];
    *((_DWORD *)v2 + 48) = v34;
    v2[40] = 0;
    if ( (v35 & 8) != 0 )
      sub_64E00(
        7,
        "NeoClock4X(%d): calculated UTC date/time: %04d-%02d-%02d %02d:%02d:%02d.%03ld",
        *(__int16 *)(v3 + 8),
        *((_DWORD *)v2 + 47),
        v46,
        v45,
        *((_DWORD *)v2 + 49),
        *((_DWORD *)v2 + 50),
        *((_DWORD *)v2 + 51),
        *((_DWORD *)v2 + 52) / 1000000);
    v36 = *((_DWORD *)v2 + 49);
    v37 = *((_DWORD *)v2 + 50);
    v38 = *((_DWORD *)v2 + 52);
    v39 = *((_DWORD *)v2 + 51);
    *(_DWORD *)(v3 + 128) = *((_DWORD *)v2 + 47);
    *(_DWORD *)(v3 + 140) = v36;
    v40 = v46;
    v41 = v45;
    *(_DWORD *)(v3 + 144) = v37;
    *(_DWORD *)(v3 + 152) = v38 / 1000000;
    *(_DWORD *)(v3 + 148) = v39;
    *(_DWORD *)(v3 + 132) = v40;
    *(_DWORD *)(v3 + 136) = v41;
    if ( sub_39CF8(v2) )
    {
      sub_39D44(v1);
      sub_394A0((__int16 *)v1, 0);
      return (__int16 *)sub_41F44((unsigned __int16 *)(v1 + 16), (const char *)v2 + 56);
    }
    else
    {
      if ( (ntp_syslogmask & 0x200) != 0 )
        sub_64E00(4, "NeoClock4X(%d): refclock_process failed!", *(__int16 *)(v3 + 8));
      return sub_394A0((__int16 *)v1, 3);
    }
  }
}
// 4FED4: variable 'v24' is possibly undefined
// 4FEF0: variable 'v25' is possibly undefined
// 4FF34: variable 'v26' is possibly undefined
// 24: using guessed type int;
// 23AB0: using guessed type char *off_23AB0;
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// B7CD4: using guessed type int ntp_syslogmask;

//----- (00050150) --------------------------------------------------------
int __fastcall sub_50150(int a1, int a2)
{
  int v4; // r0
  int v5; // r10
  int v6; // r4
  char *v7; // r0
  int v8; // r8
  int v9; // r7
  unsigned int v10; // r9
  unsigned int v11; // r5
  int v12; // r10
  int v13; // r4
  int v14; // r6
  int v15; // r11
  bool v16; // zf
  unsigned __int8 *v17; // r1
  unsigned __int8 *v18; // r3
  int v19; // r10
  int v20; // r9
  int v21; // r4
  char *v22; // r5
  int v23; // r6
  size_t v24; // r7
  int v26; // r3
  void *v27; // r0
  unsigned __int8 *v28; // r2
  void *v29; // r0
  unsigned __int8 *v30; // r3
  int v31; // [sp+Ch] [bp-198h]
  char *haystack; // [sp+10h] [bp-194h]
  int v33; // [sp+14h] [bp-190h]
  char *v34; // [sp+18h] [bp-18Ch]
  unsigned int v35; // [sp+1Ch] [bp-188h]
  int v36; // [sp+30h] [bp-174h]
  int v37; // [sp+3Ch] [bp-168h]
  unsigned __int8 buf; // [sp+47h] [bp-15Dh] BYREF
  int v39; // [sp+48h] [bp-15Ch] BYREF
  struct termios termios_p; // [sp+4Ch] [bp-158h] BYREF
  char v41[20]; // [sp+88h] [bp-11Ch] BYREF
  unsigned __int8 v42[264]; // [sp+9Ch] [bp-108h] BYREF

  sub_6C054((int)v41, 0x13u, "/dev/neoclock4x-%d", a1);
  v4 = sub_3A298(v41, 0xBu, 0);
  v5 = v4;
  if ( v4 <= 0 )
    return 0;
  if ( tcgetattr(v4, &termios_p) < 0 )
  {
    v6 = 0;
    sub_64E00(2, "NeoClock4X(%d): (tcgetattr) can't query serial port settings: %m", a1);
    close(v5);
    return v6;
  }
  v6 = 0;
  termios_p.c_iflag = 261;
  termios_p.c_cflag = 2288;
  termios_p.c_oflag = 0;
  cfsetispeed(&termios_p, 0xBu);
  cfsetospeed(&termios_p, 0xBu);
  if ( tcsetattr(v5, 0, &termios_p) < 0 )
  {
    sub_64E00(2, "NeoClock4X(%d): (tcsetattr) can't set serial port 2400 8N2: %m", a1);
    close(v5);
    return v6;
  }
  if ( ioctl(v5, 0x5415u, &v39) == -1 )
  {
    sub_64E00(2, "NeoClock4X(%d): can't query RTS/DTR state: %m", a1);
    close(v5);
    return v6;
  }
  v39 |= 6u;
  if ( ioctl(v5, 0x5418u, &v39) == -1 )
  {
    sub_64E00(2, "NeoClock4X(%d): can't set RTS/DTR to power neoclock4x: %m", a1);
    close(v5);
    return v6;
  }
  v7 = (char *)sub_63BA4(0, 0x9Cu, 0, 0);
  v34 = v7;
  if ( !v7 )
  {
    v6 = 0;
    sub_64E00(3, "NeoClock4X(%d): can't allocate memory for: %m", a1);
    close(v5);
    return v6;
  }
  memset(v7, 0, 0x9Cu);
  v8 = *(_DWORD *)(a2 + 84);
  *(_DWORD *)v8 = v34;
  *(_DWORD *)(v8 + 12) = sub_4FA84;
  *(_QWORD *)(v8 + 744) = 0x3FC5B4E81B4E81B5LL;
  *(_DWORD *)(v8 + 20) = a2;
  *(_DWORD *)(v8 + 44) = "NeoClock4X";
  *(_DWORD *)(v8 + 24) = 0;
  *(_DWORD *)(v8 + 28) = v5;
  *(_BYTE *)(a2 + 95) = -10;
  *(_DWORD *)(v8 + 764) = *(_DWORD *)"neol";
  v34[16] = 0;
  *((_WORD *)v34 + 4) = a1;
  haystack = v34 + 24;
  v33 = 0;
  sub_6D4DC(v34 + 24, "?", 80);
  v34[104] = 63;
  sub_6D4DC(v34 + 105, "?", 7);
  sub_6D4DC(v34 + 112, "?", 4);
  *((_DWORD *)v34 + 30) = -1;
  *((_DWORD *)v34 + 31) = -1;
  v34[118] = 63;
  *((_DWORD *)v34 + 32) = 0;
  *((_DWORD *)v34 + 33) = 0;
  *((_DWORD *)v34 + 34) = 0;
  *((_DWORD *)v34 + 35) = 0;
  *((_DWORD *)v34 + 36) = 0;
  *((_DWORD *)v34 + 37) = 0;
  *((_DWORD *)v34 + 38) = 0;
  *((_WORD *)v34 + 58) = 16191;
  v37 = v5;
  v36 = a1;
  while ( 1 )
  {
    if ( (ntp_syslogmask & 0x100) != 0 )
      sub_64E00(6, "NeoClock4X(%d): checking NeoClock4X firmware version (%d/5)", v36, v33);
    sleep(3u);
    v9 = *(_DWORD *)(v8 + 28);
    v31 = *((__int16 *)v34 + 4);
    sleep(1u);
    if ( write(v9, "V", 1u) != -1 )
      break;
    sub_64E00(3, "NeoClock4X(%d): can't query firmware version", v31);
    sub_6D4DC(v42, "unknown error", 256);
LABEL_27:
    if ( (unsigned int)sub_6D4DC(haystack, v42, 80) > 0x4F )
      sub_6D4DC(haystack, "buffer too small", 80);
    if ( ++v33 == 5 )
    {
      v19 = v37;
      v20 = v36;
      goto LABEL_31;
    }
  }
  v10 = 0;
  sleep(1u);
  v11 = 0;
  memset(v42, 0, 0x100u);
  v12 = 0;
  v35 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 1;
  while ( read(v9, &buf, 1u) == -1 )
  {
    if ( *_errno_location() == 11 )
    {
      sleep(1u);
    }
    else
    {
      ++v14;
      sub_64E00(7, "NeoClock4x(%d): read: %m", v31);
    }
LABEL_15:
    if ( v14 == 6 )
    {
      sub_64E00(3, "NeoClock4X(%d): can't read firmware version (timeout)", v31);
      sub_6D4DC(v42, "unknown due to timeout", 256);
      goto LABEL_27;
    }
    if ( v13 == 501 )
    {
      sub_64E00(3, "NeoClock4X(%d): can't read firmware version (garbage)", v31);
      sub_6D4DC(v42, "unknown due to garbage input", 256);
      goto LABEL_27;
    }
  }
  ++v13;
  if ( v15 )
  {
    if ( buf == 169 )
    {
      v15 = 0;
      sub_6D4DC(v42, "(c)", 256);
      v11 = 3;
    }
    goto LABEL_15;
  }
  v16 = buf == 13;
  if ( buf != 13 )
    v16 = buf == 10;
  if ( !v16 )
  {
    v12 = 0;
    if ( buf )
    {
      v28 = &v42[v11++ + 260];
      *(v28 - 260) = buf;
    }
LABEL_26:
    v42[v11] = 0;
    if ( v11 > 0xFB )
      goto LABEL_27;
    goto LABEL_15;
  }
  if ( !v12 )
  {
    v12 = 1;
    goto LABEL_26;
  }
  if ( !strstr((const char *)&v42[v35], "S/N") )
  {
    v17 = &v42[v11 + 260];
    v18 = &v42[v11 + 262];
    v10 = v11;
    v11 += 3;
    *(v17 - 259) = 47;
    *(v17 - 260) = 32;
    v35 = v11;
    *(v18 - 260) = 32;
    goto LABEL_26;
  }
  v30 = &v42[v10 + 260];
  v19 = v37;
  v20 = v36;
  *(v30 - 260) = 0;
  if ( (unsigned int)sub_6D4DC(haystack, v42, 80) > 0x4F )
    sub_6D4DC(haystack, "buffer too small", 80);
  if ( (ntp_syslogmask & 0x100) != 0 )
    sub_64E00(6, "NeoClock4X(%d): firmware version: %s", v31, haystack);
  if ( strstr(haystack, "/R2") )
    sub_64E00(
      6,
      "NeoClock4X(%d): Your NeoClock4X uses the new R2 firmware release. Please note the changed LED behaviour.",
      v31);
LABEL_31:
  v21 = 63;
  v34[104] = 63;
  v22 = strstr(haystack, "NDF:");
  v23 = *((__int16 *)v34 + 4);
  if ( v22
    && (v24 = strlen(haystack), v24 - strlen(v22) > 6)
    && v22[5] == 58
    && v22[6] == 42
    && (v21 = (unsigned __int8)v22[4], v34[104] = v21, v21 == 65) )
  {
    v6 = sub_18DF0((int *)(v8 + 8));
    if ( v6 )
    {
      v6 = 1;
      if ( (ntp_syslogmask & 0x100) != 0 )
        sub_64E00(6, "NeoClock4X(%d): receiver setup successful done", v20);
    }
    else
    {
      sub_64E00(3, "NeoClock4X(%d): error add peer to ntpd: %m", v20);
      close(v19);
      v29 = *(void **)v8;
      *(_DWORD *)(v8 + 28) = -1;
      free(v29);
      *(_DWORD *)v8 = 0;
    }
  }
  else
  {
    v26 = v21;
    v6 = 0;
    sub_64E00(2, "NeoClock4X(%d): firmware version \"%c\" not supported with this driver version!", v23, v26);
    close(v19);
    v27 = *(void **)v8;
    *(_DWORD *)(v8 + 28) = -1;
    free(v27);
    *(_DWORD *)v8 = 0;
  }
  return v6;
}
// B7CD4: using guessed type int ntp_syslogmask;

//----- (00050980) --------------------------------------------------------
void sub_50980()
{
  ;
}

//----- (000509C4) --------------------------------------------------------
int __fastcall sub_509C4(unsigned __int8 **a1, int a2, int a3, unsigned __int8 a4)
{
  unsigned __int8 *v4; // r12
  unsigned __int8 *v5; // r4
  int v6; // lr

  v4 = a1[3];
  if ( a2 < (int)v4 )
  {
    v5 = *a1;
    v4 = 0;
    a1[3] = 0;
    a1[1] = v5;
    v6 = *v5;
  }
  else
  {
    v5 = a1[1];
    v6 = *v5;
    if ( a2 <= (int)v4 )
      goto LABEL_9;
  }
  if ( !v6 )
    return 3;
  while ( 1 )
  {
    if ( v6 == 44 )
      ++v4;
    a1[3] = v4;
    a1[1] = v5 + 1;
    v6 = v5[1];
    if ( a2 <= (int)v4 )
      break;
    ++v5;
    if ( !v6 )
      return 3;
  }
LABEL_9:
  if ( v6 && (a3 != v6) != ((a4 ^ 1) & 1) )
    return 0;
  return 3;
}

//----- (00050A98) --------------------------------------------------------
int sub_50A98()
{
  int v0; // r1
  int result; // r0
  unsigned __int16 v2[6]; // [sp+0h] [bp-14h] BYREF

  if ( !sub_6568C((int)v2) || (v0 = sub_66428(v2) - 2, dword_BD5F0 = v0, v0 <= 722818) )
  {
    v0 = 722819;
    dword_BD5F0 = 722819;
  }
  sub_65BF4((int)v2, v0);
  result = dword_BD5F0;
  dword_BD5F4 = v2[0];
  dword_BD5F0 -= 693596;
  return result;
}
// BD5F0: using guessed type int dword_BD5F0;
// BD5F4: using guessed type int dword_BD5F4;

//----- (00050B6C) --------------------------------------------------------
int __fastcall sub_50B6C(int a1, int a2)
{
  int v3; // r4
  _DWORD *v4; // r5
  int v5; // r0
  int v6; // r1
  unsigned __int16 *v7; // r0
  const char *v8; // r2
  int v10; // [sp+1Ch] [bp-8h]

  v3 = *(_DWORD *)(a2 + 84);
  v4 = *(_DWORD **)v3;
  if ( *(_DWORD *)(v3 + 216) == *(_DWORD *)(v3 + 220) )
  {
    sub_394A0((__int16 *)a2, 1);
  }
  else
  {
    v5 = *(_DWORD *)(v3 + 232);
    v6 = *(_DWORD *)(v3 + 236);
    ++*(_DWORD *)(v3 + 776);
    *(_DWORD *)(v3 + 224) = v5;
    *(_DWORD *)(v3 + 228) = v6;
    sub_39D44(a2);
  }
  v7 = (unsigned __int16 *)(a2 + 16);
  v8 = (const char *)(v3 + 56);
  if ( (*(_DWORD *)(a2 + 76) & 0x10000) != 0 )
  {
    if ( !*(_BYTE *)(v3 + 56) )
      v8 = "(none)";
    sub_42050(v7, "%s  %u %u %u %u %u %u", v8, v4[4], v4[5], v4[6], v4[7], v4[8], v4[9]);
  }
  else
  {
    sub_41F44(v7, (const char *)(v3 + 56));
  }
  v4[4] = 0;
  v4[5] = 0;
  v4[6] = 0;
  v4[7] = 0;
  v4[8] = 0;
  v4[9] = 0;
  return v10;
}
// 50C28: variable 'v10' is possibly undefined
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00050C90) --------------------------------------------------------
char *__fastcall sub_50C90(int a1, int a2)
{
  int v2; // r4
  char *result; // r0
  int v4; // r3

  v2 = *(_DWORD *)(a2 + 84);
  result = *(char **)v2;
  if ( *(_DWORD *)v2 )
    free(result);
  v4 = *(_DWORD *)(v2 + 28);
  *(_DWORD *)v2 = 0;
  if ( v4 != -1 )
    result = sub_18E64(v2 + 8);
  *(_DWORD *)(v2 + 28) = -1;
  return result;
}

//----- (00050D0C) --------------------------------------------------------
bool __fastcall sub_50D0C(unsigned __int8 *a1, int a2)
{
  int v3; // r7
  int v4; // r4
  int v5; // r0
  int v6; // r0
  unsigned int v7; // r0
  __int64 v9; // [sp+0h] [bp-24h] BYREF
  int v10[3]; // [sp+8h] [bp-1Ch] BYREF
  int v11[2]; // [sp+14h] [bp-10h] BYREF

  sub_658E8(&v9, a2 - 43200, 0);
  *(_QWORD *)v10 = v9;
  sub_6598C(v11, v10);
  v3 = v11[1];
  v4 = v11[0];
  v5 = sub_665B0(a1);
  v6 = sub_657A8(v3, v5, (int)&off_15180);
  v7 = sub_65D94(a1, v6);
  return sub_65BF4((int)a1, v7 + v4 + 693596) >= 0;
}
// 15180: using guessed type char *off_15180;

//----- (00050DCC) --------------------------------------------------------
int __fastcall sub_50DCC(int a1, int a2, int a3, int a4)
{
  int v5; // r12
  const char *v6; // r0
  int v7; // r4
  const char *v8; // lr
  int v9; // t1
  char v11; // r2
  __int16 v12; // r1
  int v13; // [sp+Ch] [bp-14h] BYREF
  int v14; // [sp+10h] [bp-10h] BYREF
  int v15; // [sp+14h] [bp-Ch] BYREF
  int v16; // [sp+18h] [bp-8h] BYREF

  v5 = *(_DWORD *)(a2 + 12);
  if ( a3 < v5 )
  {
    v6 = *(const char **)a2;
    v5 = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 4) = v6;
  }
  else
  {
    v6 = *(const char **)(a2 + 4);
    if ( a3 <= v5 )
      goto LABEL_9;
  }
  v7 = *(unsigned __int8 *)v6;
  if ( *v6 )
  {
    v8 = v6 + 1;
    do
    {
      if ( v7 == 44 )
        ++v5;
      *(_DWORD *)(a2 + 4) = v8;
      *(_DWORD *)(a2 + 12) = v5;
      v6 = v8;
      if ( a3 <= v5 )
        break;
      v9 = *(unsigned __int8 *)v8++;
      v7 = v9;
    }
    while ( v9 );
  }
LABEL_9:
  if ( a4 == 1 )
  {
    if ( sscanf(v6, "%2u,%2u,%4u%n", &v15, &v14, &v13, &v16) != 3 || v16 != 10 )
      return 0;
  }
  else if ( sscanf(v6, "%2u%2u%2u%n", &v15, &v14, &v13, &v16) != 3 || v16 != 6 )
  {
    return 0;
  }
  if ( (unsigned int)(v15 - 1) > 0x1E )
    return 0;
  v11 = v14;
  if ( (unsigned int)(v14 - 1) > 0xB )
    return 0;
  v12 = v13;
  *(_BYTE *)(a1 + 5) = v15;
  *(_BYTE *)(a1 + 4) = v11;
  *(_WORD *)a1 = v12;
  return 1;
}

//----- (00050F28) --------------------------------------------------------
int __fastcall sub_50F28(_BYTE *a1, unsigned int *a2, int a3, int a4)
{
  int v6; // r12
  const char *v7; // r0
  int v8; // lr
  const char *v9; // r1
  int v10; // t1
  int v11; // r0
  unsigned int v13; // r3
  char v14; // r2
  char v15; // r1
  unsigned int v16; // [sp+14h] [bp-1Ch] BYREF
  unsigned int v17; // [sp+18h] [bp-18h] BYREF
  unsigned int v18; // [sp+1Ch] [bp-14h] BYREF
  int v19; // [sp+20h] [bp-10h] BYREF
  int v20; // [sp+24h] [bp-Ch] BYREF
  int v21; // [sp+28h] [bp-8h] BYREF

  v6 = *(_DWORD *)(a3 + 12);
  if ( a4 < v6 )
  {
    v7 = *(const char **)a3;
    v6 = 0;
    *(_DWORD *)(a3 + 12) = 0;
    *(_DWORD *)(a3 + 4) = v7;
  }
  else
  {
    v7 = *(const char **)(a3 + 4);
    if ( a4 <= v6 )
      goto LABEL_9;
  }
  v8 = *(unsigned __int8 *)v7;
  if ( *v7 )
  {
    v9 = v7 + 1;
    do
    {
      if ( v8 == 44 )
        ++v6;
      *(_DWORD *)(a3 + 4) = v9;
      *(_DWORD *)(a3 + 12) = v6;
      v7 = v9;
      if ( a4 <= v6 )
        break;
      v10 = *(unsigned __int8 *)v9++;
      v8 = v10;
    }
    while ( v10 );
  }
LABEL_9:
  v11 = sscanf(v7, "%2u%2u%2u%n.%3lu%n", &v16, &v17, &v18, &v19, &v21, &v20);
  if ( v11 <= 2 )
    return 0;
  if ( v19 != 6 )
    return 0;
  v13 = v16;
  if ( v16 > 0x17 )
    return 0;
  v14 = v17;
  if ( v17 > 0x3B )
    return 0;
  v15 = v18;
  if ( v18 > 0x3C )
    return 0;
  a1[6] = v16;
  if ( v11 != 4 )
    v13 = 0;
  a1[7] = v14;
  a1[8] = v15;
  if ( v11 == 4 )
    *a2 = v21 * dword_99210[v20 - 7];
  else
    *a2 = v13;
  return 1;
}
// 99210: using guessed type _DWORD dword_99210[4];

//----- (000510A0) --------------------------------------------------------
bool sub_510A0(unsigned __int8 **a1, ...)
{
  int v1; // r4
  unsigned int *v2; // r5
  signed int v4; // r0
  unsigned int v5; // t1
  int v6; // r3
  unsigned __int8 *v7; // r1
  int v8; // r3
  int v9; // t1
  _BOOL4 v10; // r2
  _BOOL4 result; // r0
  unsigned __int8 *v12; // r2
  bool v13; // cc
  unsigned __int8 *v14; // r8
  va_list varg_r1; // [sp+24h] [bp+1Ch] BYREF

  va_start(varg_r1, a1);
  v1 = 8;
  va_copy(v2, varg_r1);
  do
  {
    v5 = *v2++;
    v4 = v5;
    if ( v5 <= 0x20 )
    {
      v12 = a1[3];
      v13 = v4 < (int)v12;
      if ( v4 >= (int)v12 )
      {
        v14 = a1[1];
      }
      else
      {
        v14 = *a1;
        v12 = 0;
      }
      if ( v13 )
      {
        a1[3] = 0;
        a1[1] = v14;
      }
      v8 = *v14;
      if ( v4 <= (int)v12 )
      {
        v7 = v14;
      }
      else
      {
        if ( !*v14 )
          goto LABEL_12;
        while ( 1 )
        {
          if ( v8 == 44 )
            ++v12;
          v7 = v14 + 1;
          a1[3] = v12;
          a1[1] = v14 + 1;
          v8 = v14[1];
          if ( v4 <= (int)v12 )
            break;
          ++v14;
          if ( !v8 )
            goto LABEL_12;
        }
      }
    }
    else
    {
      v6 = (int)a1[2];
      v7 = &(*a1)[v6];
      if ( v6 > 2 && *(v7 - 3) == 42 )
      {
        v8 = *(v7 - 2);
        v7 -= 2;
      }
      else
      {
        v8 = (*a1)[v6];
      }
    }
    while ( 1 )
    {
      v10 = ((v8 - 42) & 0xFD) != 0;
      if ( !v8 )
        v10 = 0;
      if ( !v10 )
        break;
      if ( v8 != 46 )
        *v7 = 95;
      v9 = *++v7;
      v8 = v9;
    }
LABEL_12:
    result = v4 >= 0;
    if ( !v1 )
      result = 0;
    --v1;
  }
  while ( result );
  return result;
}

//----- (000511FC) --------------------------------------------------------
bool __fastcall sub_511FC(int a1, int a2)
{
  _DWORD *v4; // r4
  _BYTE *v5; // r0
  speed_t v6; // r10
  int v7; // r0
  int v8; // r10
  const char *v10; // r0
  const char *v11; // r0
  unsigned int v12; // r0
  char *v13; // r0
  const struct addrinfo *v14; // r0
  struct addrinfo *v15; // r5
  int v16; // r0
  int v17; // r7
  const char *v18; // [sp+Ch] [bp-98h]
  struct addrinfo *pai[9]; // [sp+14h] [bp-90h] BYREF
  char v20[20]; // [sp+38h] [bp-6Ch] BYREF
  char buf[88]; // [sp+4Ch] [bp-58h] BYREF

  v4 = *(_DWORD **)(a2 + 84);
  v5 = sub_63BA4(0, 0x30u, 0, 1);
  switch ( (*(_DWORD *)(a2 + 76) >> 4) & 7 )
  {
    case 0:
      v6 = 12;
      v18 = "4800";
      break;
    case 1:
      v6 = 13;
      v18 = "9600";
      break;
    case 2:
      v6 = 14;
      v18 = "19200";
      break;
    case 3:
      v6 = 15;
      v18 = "38400";
      break;
    case 4:
      v6 = 4097;
      v18 = "57600";
      break;
    case 5:
      v6 = 4098;
      v18 = "115200";
      break;
    default:
      v6 = 12;
      v18 = "4800 (fallback)";
      break;
  }
  *v4 = v5;
  v4[3] = sub_51584;
  v4[5] = a2;
  v4[7] = -1;
  v4[6] = 0;
  v5[40] = 2;
  *((_DWORD *)v5 + 1) = -1;
  *((_DWORD *)v5 + 2) = -1;
  *((_DWORD *)v5 + 4) = 0;
  *((_DWORD *)v5 + 5) = 0;
  *((_DWORD *)v5 + 6) = 0;
  *((_DWORD *)v5 + 7) = 0;
  *((_DWORD *)v5 + 8) = 0;
  *((_DWORD *)v5 + 9) = 0;
  *(_BYTE *)(a2 + 95) = -9;
  v4[191] = 5460039;
  v4[11] = "NMEA GPS Clock";
  if ( sub_6C054((int)v20, 0x14u, "/dev/gps%d", a1) > 0x13 )
  {
    v8 = 0;
    v10 = sub_6A3FC((unsigned __int16 *)(a2 + 16));
    sub_64E00(3, "%s clock device name too long", v10);
    return v8;
  }
  v7 = sub_3A298(v20, v6, 1);
  v4[7] = v7;
  if ( v7 > 0 )
  {
LABEL_5:
    if ( (ntp_syslogmask & 0x100) != 0 )
    {
      v11 = sub_6A3FC((unsigned __int16 *)(a2 + 16));
      sub_64E00(5, "%s serial %s open at %s bps", v11, v20, v18);
    }
    return sub_18DF0(v4 + 2) != 0;
  }
  v12 = readlink(v20, buf, 0x50u);
  if ( v12 > 0x4F )
    goto LABEL_28;
  buf[v12] = 0;
  v13 = strchr(buf, 58);
  v8 = (int)v13;
  if ( !v13 )
  {
LABEL_27:
    v4[7] = -1;
    return v8;
  }
  *v13 = 0;
  v14 = (const struct addrinfo *)memset(&pai[1], 0, 0x20u);
  pai[4] = (struct addrinfo *)&byte_6;
  pai[3] = (struct addrinfo *)(&dword_0 + 1);
  v8 = getaddrinfo(buf, (const char *)(v8 + 1), v14, pai);
  if ( v8 )
  {
LABEL_28:
    v4[7] = -1;
    return 0;
  }
  v15 = pai[0];
  if ( !pai[0] )
  {
    freeaddrinfo(0);
    goto LABEL_27;
  }
  do
  {
    v16 = socket(v15->ai_family, v15->ai_socktype, v15->ai_protocol);
    v17 = v16;
    if ( v16 != -1 )
    {
      if ( connect(v16, v15->ai_addr, v15->ai_addrlen) != -1 )
      {
        freeaddrinfo(pai[0]);
        v4[7] = v17;
        goto LABEL_5;
      }
      close(v17);
    }
    v15 = v15->ai_next;
  }
  while ( v15 );
  freeaddrinfo(pai[0]);
  v4[7] = -1;
  return v8;
}
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;
// B7CD4: using guessed type int ntp_syslogmask;

//----- (00051584) --------------------------------------------------------
int __fastcall sub_51584(int a1)
{
  int v1; // r5
  int *v2; // r11
  int v3; // r8
  int v4; // r3
  size_t v5; // r10
  double v6; // r0
  int v7; // r2
  int v8; // r3
  unsigned int v9; // r1
  bool v10; // cc
  unsigned __int8 *v11; // r1
  int v12; // t1
  unsigned int v13; // lr
  bool v14; // cc
  int v15; // r3
  int v16; // r2
  bool v17; // zf
  int v18; // t1
  bool v19; // zf
  int v20; // r3
  int v21; // lr
  int v22; // r12
  int v23; // t1
  unsigned int v24; // r1
  int v25; // r2
  int v26; // r9
  int v27; // r3
  int v28; // r9
  int v29; // r9
  int v30; // r6
  size_t v31; // r4
  double v32; // d0
  char *v33; // r0
  char v34; // r0
  int v35; // r1
  char v36; // r0
  int v37; // r1
  bool v38; // zf
  signed __int64 v39; // r0
  int v40; // r9
  int v41; // r6
  int v42; // r6
  int v43; // r0
  int v44; // r9
  int v45; // r5
  int v46; // r3
  int v47; // r0
  unsigned int v48; // r1
  int v49; // r3
  const char *v50; // r0
  int v51; // r1
  unsigned __int8 *v52; // r2
  int v53; // t1
  int v54; // r0
  int v55; // r3
  int v56; // r9
  const char *v57; // r0
  int v58; // r1
  unsigned __int8 *v59; // r2
  int v60; // t1
  int v61; // r0
  int v62; // r3
  int v63; // r9
  const char *v64; // r0
  int v65; // r1
  unsigned __int8 *v66; // r2
  int v67; // t1
  int v68; // r0
  __int64 v69; // r2
  int v70; // r1
  unsigned int v71; // r0
  int v72; // r0
  int v73; // r7
  int v74; // r4
  __int16 v75; // r8
  bool v76; // cc
  int v77; // r9
  unsigned __int16 v78; // r0
  const char *v79; // r0
  const char *v80; // r0
  bool v81; // zf
  char *v83; // [sp+10h] [bp-10Ch]
  char *v84; // [sp+10h] [bp-10Ch]
  char *v85; // [sp+18h] [bp-104h]
  char *v86; // [sp+18h] [bp-104h]
  char *v87; // [sp+18h] [bp-104h]
  unsigned __int8 v88; // [sp+1Ch] [bp-100h]
  int v89; // [sp+1Ch] [bp-100h]
  __int16 v90; // [sp+3Ch] [bp-E0h]
  __int64 v91; // [sp+40h] [bp-DCh] BYREF
  __int64 v92; // [sp+48h] [bp-D4h] BYREF
  int v93; // [sp+54h] [bp-C8h] BYREF
  unsigned int v94; // [sp+58h] [bp-C4h]
  int v95; // [sp+5Ch] [bp-C0h]
  int v96; // [sp+60h] [bp-BCh] BYREF
  unsigned int v97; // [sp+64h] [bp-B8h]
  int v98; // [sp+68h] [bp-B4h] BYREF
  _DWORD v99[2]; // [sp+6Ch] [bp-B0h] BYREF
  __int16 v100; // [sp+74h] [bp-A8h]
  unsigned int v101; // [sp+78h] [bp-A4h] BYREF
  char *v102; // [sp+7Ch] [bp-A0h]
  bool *v103; // [sp+84h] [bp-98h] BYREF
  unsigned __int8 *v104; // [sp+88h] [bp-94h]
  int v105; // [sp+8Ch] [bp-90h]
  int v106; // [sp+90h] [bp-8Ch]
  bool v107; // [sp+94h] [bp-88h] BYREF
  unsigned __int8 v108; // [sp+95h] [bp-87h] BYREF
  unsigned __int8 v109; // [sp+96h] [bp-86h] BYREF
  char s1[125]; // [sp+97h] [bp-85h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(int **)(v1 + 84);
  v3 = *v2;
  v99[0] = 0;
  v99[1] = 0;
  v100 = 0;
  v96 = 0;
  v95 = 0;
  v97 = 0;
  v98 = 0;
  LODWORD(v6) = sub_39EE4(a1, &v107, 128, &v93);
  v4 = LODWORD(v6) & ~(SLODWORD(v6) >> 31);
  v5 = LODWORD(v6);
  v103 = &v107;
  *(&v107 + v4) = 0;
  LODWORD(v6) = &v107 + v4;
  v104 = (unsigned __int8 *)&v107;
  v106 = 0;
  v105 = v4;
  if ( !v107 )
    return LODWORD(v6);
  if ( v107 != 36 )
    goto LABEL_3;
  v7 = v108;
  v105 = v4 - 1;
  v103 = (bool *)&v108;
  v104 = &v108;
  if ( (unsigned int)v108 - 65 > 0x19 )
    goto LABEL_3;
  v8 = v109;
  v9 = v109 - 48;
  v10 = v9 > 9;
  if ( v9 > 9 )
    v10 = (unsigned int)v109 - 65 > 0x19;
  v11 = &v109;
  if ( !v10 )
  {
    do
    {
      v7 ^= v8;
      v12 = *++v11;
      v8 = v12;
      v13 = v12 - 65;
      v14 = (unsigned int)(v12 - 48) > 9;
      if ( (unsigned int)(v12 - 48) > 9 )
        v14 = v13 > 0x19;
    }
    while ( !v14 );
  }
  if ( v8 != 44 || v11 - &v108 <= 4 )
    goto LABEL_3;
  v15 = v11[1];
  v16 = v7 ^ 0x2C;
  HIDWORD(v6) = v11 + 1;
  v17 = v15 == 42;
  if ( v15 != 42 )
    v17 = v15 == 0;
  if ( !v17 )
  {
    do
    {
      v16 ^= v15;
      v18 = *(unsigned __int8 *)++HIDWORD(v6);
      v15 = v18;
      v19 = v18 == 0;
      if ( v18 )
        v19 = v15 == 42;
    }
    while ( !v19 );
  }
  if ( !v15 )
  {
    v88 = 1;
    goto LABEL_34;
  }
  if ( v15 != 42 || LODWORD(v6) - 3 != HIDWORD(v6) || HIDWORD(v6) - (int)&v108 > 79 )
    goto LABEL_3;
  v20 = *(unsigned __int8 *)(LODWORD(v6) - 2);
  v21 = LODWORD(v6) - 2;
  if ( *(_BYTE *)(LODWORD(v6) - 2) )
  {
    v22 = 0;
    while ( 1 )
    {
      v24 = (unsigned __int8)(v20 - 48);
      if ( v24 <= 9 )
      {
        v22 = (unsigned __int8)(v24 + 16 * v22);
      }
      else
      {
        if ( (unsigned int)(v20 - 65) > 5 )
          goto LABEL_178;
        v22 = (unsigned __int8)(v20 - 55 + 16 * v22);
      }
      v23 = *(unsigned __int8 *)++v21;
      v20 = v23;
      if ( !v23 )
        goto LABEL_178;
    }
  }
  v22 = *(unsigned __int8 *)(LODWORD(v6) - 2);
LABEL_178:
  v81 = v22 == v16;
  if ( v22 == v16 )
    v81 = LODWORD(v6) == v21;
  if ( !v81 )
  {
LABEL_3:
    LODWORD(v6) = sub_394A0((__int16 *)v1, 2);
    return LODWORD(v6);
  }
  v88 = 2;
LABEL_34:
  ++*(_DWORD *)(v3 + 16);
  LODWORD(v6) = strncmp(s1, "RMC,", 4u);
  v26 = LODWORD(v6);
  if ( !LODWORD(v6) )
    goto LABEL_57;
  LODWORD(v6) = strncmp(s1, "GGA,", 4u);
  if ( !LODWORD(v6) )
  {
    v26 = 1;
    v85 = (_BYTE *)(&dword_0 + 1);
    goto LABEL_42;
  }
  LODWORD(v6) = strncmp(s1, "GLL,", 4u);
  if ( !LODWORD(v6) )
  {
    v26 = 2;
    v85 = (_BYTE *)(&dword_0 + 2);
    goto LABEL_42;
  }
  LODWORD(v6) = strncmp(s1, "ZDA,", 4u);
  if ( !LODWORD(v6) )
  {
    v26 = 3;
    v85 = (_BYTE *)(&dword_0 + 3);
    goto LABEL_42;
  }
  LODWORD(v6) = strncmp(s1, "ZDG,", 4u);
  if ( !LODWORD(v6) )
  {
    v26 = 4;
LABEL_57:
    v27 = *(_DWORD *)(v1 + 76);
    v85 = (char *)v26;
    if ( (v27 & 0x80) == 0 )
      goto LABEL_43;
LABEL_58:
    LODWORD(v6) = -32;
    v32 = (double)v94;
    ldexp(v6, v25);
    v33 = strchr((const char *)&v107, 44);
    LODWORD(v6) = sub_42050(
                    (unsigned __int16 *)(v1 + 16),
                    "delay %0.6f %.*s",
                    v32,
                    v33 - (char *)&v107,
                    (const char *)&v107);
    v27 = *(_DWORD *)(v1 + 76);
    goto LABEL_43;
  }
  LODWORD(v6) = strncmp((const char *)&v108, "PGRMF,", 6u);
  if ( LODWORD(v6) )
    return LODWORD(v6);
  v26 = 5;
  v85 = &byte_5;
LABEL_42:
  v27 = *(_DWORD *)(v1 + 76);
  if ( (v27 & 0x80) != 0 )
    goto LABEL_58;
LABEL_43:
  if ( (v27 & 0xFF0F) != 0 && (v27 & dword_99210[v26 + 6]) == 0 )
    goto LABEL_45;
  v28 = v3 + v26;
  if ( *(unsigned __int8 *)(v28 + 40) > (unsigned int)v88 )
  {
    LODWORD(v6) = sub_394A0((__int16 *)v1, 2);
    ++*(_DWORD *)(v3 + 28);
    return LODWORD(v6);
  }
  *(_BYTE *)(v28 + 40) = v88;
  if ( *(_BYTE *)v3 )
  {
    if ( v85 != &byte_4 )
    {
LABEL_45:
      ++*(_DWORD *)(v3 + 32);
      return LODWORD(v6);
    }
LABEL_49:
    v83 = (char *)sub_50F28(v99, (unsigned int *)&v96, (int)&v103, 1);
    v29 = sub_50DCC((int)v99, (int)&v103, 2, 1);
    *((_BYTE *)v2 + 40) = sub_509C4((unsigned __int8 **)&v103, 4, 48, 1u);
    v95 = -1;
  }
  else
  {
    switch ( (unsigned int)v85 )
    {
      case 1u:
        v83 = (char *)sub_50F28(v99, (unsigned int *)&v96, (int)&v103, 1);
        v36 = sub_509C4((unsigned __int8 **)&v103, 6, 48, 1u);
        v37 = v93;
        *((_BYTE *)v2 + 40) = v36;
        v29 = sub_50D0C((unsigned __int8 *)v99, v37);
        if ( (v2[192] & 8) != 0 )
          sub_510A0((unsigned __int8 **)&v103, 2, 4, -1);
        goto LABEL_50;
      case 2u:
        v83 = (char *)sub_50F28(v99, (unsigned int *)&v96, (int)&v103, 5);
        v34 = sub_509C4((unsigned __int8 **)&v103, 6, 65, 0);
        v35 = v93;
        *((_BYTE *)v2 + 40) = v34;
        v29 = sub_50D0C((unsigned __int8 *)v99, v35);
        if ( (v2[192] & 8) != 0 )
          sub_510A0((unsigned __int8 **)&v103, 1, 3, -1);
        goto LABEL_50;
      case 3u:
        *((_BYTE *)v2 + 40) = 0;
        v83 = (char *)sub_50F28(v99, (unsigned int *)&v96, (int)&v103, 1);
        v29 = sub_50DCC((int)v99, (int)&v103, 2, 1);
        goto LABEL_50;
      case 4u:
        goto LABEL_49;
      case 5u:
        v49 = v106;
        if ( v106 <= 1 )
        {
          v50 = (const char *)v104;
          if ( v106 == 1 )
            goto LABEL_116;
        }
        else
        {
          v50 = (const char *)v103;
          v49 = 0;
          v106 = 0;
          v104 = (unsigned __int8 *)v103;
        }
        v51 = *(unsigned __int8 *)v50;
        if ( *v50 )
        {
          v52 = (unsigned __int8 *)(v50 + 1);
          do
          {
            if ( v51 == 44 )
              ++v49;
            v104 = v52;
            v106 = v49;
            v50 = (const char *)v52;
            if ( v49 == 1 )
              break;
            v53 = *v52++;
            v51 = v53;
          }
          while ( v53 );
        }
LABEL_116:
        v54 = sscanf(v50, "%hu", &v98);
        v55 = v106;
        v56 = v54;
        if ( v106 <= 2 )
        {
          v57 = (const char *)v104;
          if ( v106 == 2 )
            goto LABEL_125;
        }
        else
        {
          v57 = (const char *)v103;
          v55 = 0;
          v106 = 0;
          v104 = (unsigned __int8 *)v103;
        }
        v58 = *(unsigned __int8 *)v57;
        if ( *v57 )
        {
          v59 = (unsigned __int8 *)(v57 + 1);
          do
          {
            if ( v58 == 44 )
              ++v55;
            v104 = v59;
            v106 = v55;
            v57 = (const char *)v59;
            if ( v55 == 2 )
              break;
            v60 = *v59++;
            v58 = v60;
          }
          while ( v60 );
        }
LABEL_125:
        v61 = sscanf(v57, "%lu", &v101);
        v62 = v106;
        v63 = v56 + v61;
        if ( v106 <= 5 )
        {
          v64 = (const char *)v104;
          if ( v106 == 5 )
            goto LABEL_134;
        }
        else
        {
          v64 = (const char *)v103;
          v62 = 0;
          v106 = 0;
          v104 = (unsigned __int8 *)v103;
        }
        v65 = *(unsigned __int8 *)v64;
        if ( *v64 )
        {
          v66 = (unsigned __int8 *)(v64 + 1);
          do
          {
            if ( v65 == 44 )
              ++v62;
            v104 = v66;
            v106 = v62;
            v64 = (const char *)v66;
            if ( v62 == 5 )
              break;
            v67 = *v66++;
            v65 = v67;
          }
          while ( v67 );
        }
LABEL_134:
        if ( v63 + sscanf(v64, "%hd", (char *)&v98 + 2) != 3
          || (unsigned __int16)v98 >= 0x400u
          || v101 > (unsigned int)"found."
          || (v97 = v101, !sub_50DCC((int)v99, (int)&v103, 3, 0)) )
        {
          v83 = (char *)sub_50F28(v99, (unsigned int *)&v96, (int)&v103, 4);
          v29 = 0;
          *((_BYTE *)v2 + 40) = sub_509C4((unsigned __int8 **)&v103, 11, 48, 1u);
          goto LABEL_136;
        }
        v83 = (char *)sub_50F28(v99, (unsigned int *)&v96, (int)&v103, 4);
        *((_BYTE *)v2 + 40) = sub_509C4((unsigned __int8 **)&v103, 11, 48, 1u);
        v68 = sub_665B0((unsigned __int8 *)v99);
        v69 = 1374389535LL * LOWORD(v99[0]);
        v70 = SHIWORD(v98) + v68;
        v71 = (unsigned int)v70 >> 31;
        if ( v70 > (int)&off_1517C + 3 )
          v72 = 1 - v71;
        else
          v72 = -v71;
        v29 = 5;
        v73 = v3;
        LODWORD(v69) = *(unsigned __int16 *)(v3 + 2);
        v74 = v72;
        v75 = LOWORD(v99[0]) % 0x64u;
        v90 = v75;
        break;
      default:
        v83 = (char *)sub_50F28(v99, (unsigned int *)&v96, (int)&v103, 1);
        *((_BYTE *)v2 + 40) = sub_509C4((unsigned __int8 **)&v103, 2, 65, 0);
        v29 = sub_50DCC((int)v99, (int)&v103, 9, 0);
        if ( v29 )
        {
          sub_66750(&v101, v93, 0);
          v77 = (unsigned __int16)v101 - 20;
          if ( v77 < dword_BD5F4 )
            v77 = dword_BD5F4;
          v78 = sub_657A8(v77, LOWORD(v99[0]), 100);
          LOWORD(v99[0]) = v78;
          v29 = v77 <= v78 && v77 + 99 >= v78;
        }
        if ( (v2[192] & 8) != 0 )
          sub_510A0((unsigned __int8 **)&v103, 3, 4, 5, 6, -1, &_stack_chk_guard);
        goto LABEL_50;
    }
    while ( 1 )
    {
      v76 = (unsigned int)(v69 - 19) > 4;
      if ( (unsigned int)(v69 - 19) > 4 )
      {
        LOWORD(v69) = 1900;
        WORD2(v69) = 19;
      }
      else
      {
        LOWORD(v69) = 5 * v69;
      }
      if ( v76 )
        *(_WORD *)(v73 + 2) = WORD2(v69);
      else
        LOWORD(v69) = 5 * v69;
      if ( !v76 )
        LOWORD(v69) = 4 * v69;
      LOWORD(v99[0]) = v75 + v69;
      LODWORD(v69) = sub_66428((unsigned __int16 *)v99) - 722819 + v74;
      if ( (int)v69 >= 0 )
      {
        WORD2(v69) = 9363;
        if ( (unsigned __int16)v98 == (((__int16)v69 / 7) & 0x3FF) )
          break;
      }
      --v29;
      LODWORD(v69) = (unsigned __int16)(*(_WORD *)(v73 + 2) + 1);
      *(_WORD *)(v73 + 2) = v69;
      if ( !v29 )
      {
        v3 = v73;
        LOWORD(v99[0]) = v90;
        goto LABEL_136;
      }
    }
    v3 = v73;
    v29 = 1;
LABEL_136:
    if ( (v2[192] & 8) != 0 )
      sub_510A0((unsigned __int8 **)&v103, 6, 8, -1);
  }
LABEL_50:
  if ( !v83 )
  {
    v30 = 6;
    ++*(_DWORD *)(v3 + 28);
LABEL_52:
    if ( v5 >= 0x7F )
      v31 = 127;
    else
      v31 = v5;
    v2[46] = v31;
    memcpy(v2 + 14, &v107, v31);
    *((_BYTE *)v2 + v31 + 56) = 0;
    LODWORD(v6) = sub_394A0((__int16 *)v1, v30);
    return LODWORD(v6);
  }
  if ( !v29 )
  {
    v30 = 5;
    ++*(_DWORD *)(v3 + 28);
    goto LABEL_52;
  }
  if ( *((_BYTE *)v2 + 40) == 3 )
  {
    v30 = 2;
    ++*(_DWORD *)(v3 + 24);
    goto LABEL_52;
  }
  v38 = *(_BYTE *)v3 == 0;
  if ( !*(_BYTE *)v3 )
    v38 = v85 == &byte_4;
  if ( v38 )
  {
    v80 = sub_6A3FC((unsigned __int16 *)(v1 + 16));
    sub_64E00(6, "%s using GPS time as if it were UTC", v80);
    *(_BYTE *)v3 = 1;
  }
  v84 = **(char ***)(v1 + 84);
  v86 = (char *)sub_665B0((unsigned __int8 *)v99);
  LODWORD(v39) = sub_66428((unsigned __int16 *)v99);
  HIDWORD(v39) = v96;
  v40 = v39 - 693596;
  v41 = v95;
  if ( v96 < 0 )
  {
    do
    {
      HIDWORD(v39) += 1000000000;
      --v41;
    }
    while ( v39 < 0 );
  }
  else if ( v96 > 999999999 )
  {
    if ( v96 - 1000000000 <= 999999999 )
      v41 = v95 + 1;
    else
      HIDWORD(v39) = v96 - 2013265920;
    if ( v96 - 1000000000 <= 999999999 )
      HIDWORD(v39) = v96 - 1000000000;
    else
      HIDWORD(v39) += 13238272;
    if ( v96 - 1000000000 > 999999999 )
    {
      v41 += 2;
      HIDWORD(v39) += 27648;
    }
  }
  LODWORD(v39) = 500000000;
  v42 = (int)&v86[v41];
  v87 = (char *)sub_8BFD0(v39, 0x3B9ACA00u);
  if ( (*(_DWORD *)(v1 + 76) & 0x2000000) != 0 )
  {
    LODWORD(v6) = sub_66038(&v91, v40, v42);
    v45 = v91;
  }
  else
  {
    if ( v42 <= 86399 )
    {
      while ( v42 < 0 )
      {
        --v40;
        v42 += 86400;
      }
    }
    else
    {
      do
      {
        ++v40;
        v42 -= 86400;
      }
      while ( v42 > 86399 );
    }
    sub_658E8(&v91, v93, 0);
    v92 = v91;
    sub_6598C((int *)&v101, (int *)&v92);
    v43 = v101 - 3584;
    if ( (int)v102 > v42 || v102 == (char *)v42 && (unsigned int)v87 < v94 )
      v43 = v101 - 3583;
    if ( v43 < dword_BD5F0 )
      v43 = dword_BD5F0;
    v89 = sub_657A8(v43, v40, 7168);
    v44 = (v89 - v40) / 7;
    if ( v44 != *((__int16 *)v84 + 6) )
    {
      *((_WORD *)v84 + 6) = v44;
      if ( (ntp_syslogmask & 0x100) != 0 )
      {
        v79 = sub_6A3FC((unsigned __int16 *)(v1 + 16));
        sub_64E00(6, "%s Changed GPS epoch warp to %d weeks", v79, v44);
      }
    }
    LODWORD(v6) = sub_66038(&v91, v89, v42);
    v45 = v91;
  }
  if ( *(_DWORD *)(v3 + 4) == v45 && *(char **)(v3 + 8) == v87 )
    goto LABEL_45;
  if ( v5 >= 0x7F )
    v5 = 127;
  v46 = *(_DWORD *)(v3 + 20) + 1;
  *(_DWORD *)(v3 + 4) = v45;
  *(_DWORD *)(v3 + 20) = v46;
  *(_DWORD *)(v3 + 8) = v87;
  v2[46] = v5;
  memcpy(v2 + 14, &v107, v5);
  v47 = v93;
  v48 = v94;
  *((_BYTE *)v2 + v5 + 56) = 0;
  v2[58] = v47;
  v2[59] = v48;
  v101 = v45;
  v102 = v87;
  LODWORD(v6) = sub_39A70(v2, v45, (unsigned int)v87);
  return LODWORD(v6);
}
// 5198C: variable 'v6' is possibly undefined
// 5198C: variable 'v25' is possibly undefined
// 521E4: variable 'v69' is possibly undefined
// 0: using guessed type int dword_0;
// 4: using guessed type char byte_4;
// 5: using guessed type char byte_5;
// 1517C: using guessed type char *off_1517C;
// 99210: using guessed type _DWORD dword_99210[4];
// B7CD4: using guessed type int ntp_syslogmask;
// BD5F0: using guessed type int dword_BD5F0;
// BD5F4: using guessed type int dword_BD5F4;

//----- (000523A0) --------------------------------------------------------
ssize_t __fastcall sub_523A0(__int16 *a1, int fd)
{
  int v2; // lr
  int v3; // r4
  int v4; // r12
  int v5; // lr

  v2 = *a1;
  v3 = *((_DWORD *)a1 + 1);
  *a1 = v2 + 1;
  *(_BYTE *)(v3 + v2) = 16;
  v4 = *a1;
  v5 = *((_DWORD *)a1 + 1);
  *a1 = v4 + 1;
  *(_BYTE *)(v5 + v4) = 3;
  return write(fd, *((const void **)a1 + 1), *a1);
}

//----- (00052428) --------------------------------------------------------
void __fastcall sub_52428(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (000524A8) --------------------------------------------------------
int __fastcall sub_524A8(_DWORD *a1, _DWORD *a2, unsigned __int8 *a3)
{
  char v6; // r1
  unsigned __int16 v7; // r3
  int v8; // r4
  int v9; // r3
  int result; // r0
  unsigned __int16 v11[2]; // [sp+0h] [bp-14h] BYREF
  __int16 v12; // [sp+4h] [bp-10h]

  if ( !dword_BD5F8 )
  {
    if ( !sub_6568C((int)v11) )
    {
      v12 = 257;
      v11[0] = 2015;
    }
    dword_BD5F8 = sub_66428(v11);
  }
  v6 = *a3;
  v7 = _byteswap_ushort(*((_WORD *)a3 + 1));
  LOBYTE(v12) = a3[1];
  HIBYTE(v12) = v6;
  v11[0] = v7;
  v8 = sub_66428(v11);
  sub_65BF4((int)v11, v8);
  if ( __PAIR64__((unsigned __int8)v12, HIBYTE(v12)) != __PAIR64__(a3[1], *a3) || v11[0] != (a3[3] | (a3[2] << 8)) )
    return -1;
  for ( ; v8 < dword_BD5F8; v8 += 7168 )
    ;
  sub_65BF4((int)v11, v8);
  v9 = v11[0];
  result = HIBYTE(v12) | (32 * (unsigned __int8)v12);
  *a2 = v11[1];
  *a1 = v9;
  return result;
}
// BD5F8: using guessed type int dword_BD5F8;

//----- (00052610) --------------------------------------------------------
int __fastcall sub_52610(int a1, int a2)
{
  int v4; // r0
  int v5; // r6
  int v6; // r4
  _DWORD *v7; // r9
  int v8; // r3
  int v9; // r11
  int v10; // r3
  int v11; // r3
  __int16 v13; // [sp+Ch] [bp-60h] BYREF
  void *ptr; // [sp+10h] [bp-5Ch]
  struct termios v15; // [sp+14h] [bp-58h] BYREF
  char v16[20]; // [sp+50h] [bp-1Ch] BYREF

  sub_6C054((int)v16, 0x14u, "/dev/palisade%d", a1);
  v4 = sub_3A298(v16, 0xDu, 32);
  v5 = v4;
  if ( v4 <= 0 )
    return 0;
  sub_64E00(5, "Palisade(%d) fd: %d dev: %s", a1, v4, v16);
  if ( tcgetattr(v5, &v15) < 0 )
  {
    v6 = 0;
    sub_64E00(3, "Palisade(%d) tcgetattr(fd, &tio): %m", a1);
    close(v5);
  }
  else
  {
    v15.c_cflag |= 0x300u;
    v15.c_iflag &= ~0x100u;
    v7 = sub_63BA4(0, 0x94u, 0, 1);
    v8 = *(_DWORD *)(a2 + 76) & 0x7F;
    v7[35] = v8;
    switch ( v8 )
    {
      case 0:
        break;
      case 1:
        sub_64E00(5, "Palisade(%d) Praecis mode enabled", a1);
        break;
      case 2:
        sub_64E00(5, "Palisade(%d) Thunderbolt mode enabled", a1);
        v15.c_cflag = 2224;
        break;
      case 3:
        sub_64E00(5, "Palisade(%d) Acutime Gold mode enabled", a1);
        break;
      default:
        sub_64E00(5, "Palisade(%d) mode unknown", a1);
        break;
    }
    if ( tcsetattr(v5, 0, &v15) == -1 )
    {
      v6 = 0;
      sub_64E00(3, "Palisade(%d) tcsetattr(fd, &tio): %m", a1);
      close(v5);
      free(v7);
    }
    else
    {
      v9 = *(_DWORD *)(a2 + 84);
      *(_DWORD *)(v9 + 20) = a2;
      *(_DWORD *)(v9 + 28) = v5;
      *(_DWORD *)(v9 + 12) = sub_530E4;
      *(_DWORD *)(v9 + 24) = 0;
      v6 = sub_18DF0((int *)(v9 + 8));
      if ( v6 )
      {
        *(_DWORD *)v9 = v7;
        *(_DWORD *)(v9 + 44) = "Trimble Palisade GPS";
        *(_BYTE *)(a2 + 95) = -20;
        *(_BYTE *)(a2 + 90) = 4;
        *(_BYTE *)(a2 + 65) = 4;
        *(_BYTE *)(a2 + 66) = 5;
        strcpy((char *)(v9 + 764), "GPS");
        v10 = v7[35];
        *(_WORD *)v7 = a1;
        v7[2] = 0;
        if ( v10 == 2 )
        {
          ptr = sub_63BA4(0, 0x64u, 0, 0);
          *(_BYTE *)ptr = 16;
          *((_BYTE *)ptr + 1) = -114;
          *((_BYTE *)ptr + 2) = -94;
          v13 = 4;
          *((_BYTE *)ptr + 3) = 3;
          sub_523A0(&v13, v5);
          *(_BYTE *)ptr = 16;
          *((_BYTE *)ptr + 1) = -114;
          *((_BYTE *)ptr + 2) = -91;
          *((_BYTE *)ptr + 3) = 0;
          v13 = 5;
          *((_BYTE *)ptr + 4) = 5;
          sub_523A0(&v13, v5);
          free(ptr);
          v10 = v7[35];
        }
        if ( v10 == 3 )
        {
          v13 = 0;
          ptr = sub_63BA4(0, 0x64u, 0, 0);
          *(_BYTE *)ptr = 16;
          v6 = 1;
          *((_BYTE *)ptr + 1) = -114;
          *((_BYTE *)ptr + 2) = -91;
          *((_BYTE *)ptr + 3) = 2;
          *((_BYTE *)ptr + 4) = 0;
          v13 = 6;
          *((_BYTE *)ptr + 5) = 0;
          v11 = v13++;
          *((_BYTE *)ptr + v11) = 0;
          sub_523A0(&v13, v5);
          free(ptr);
        }
        else
        {
          return 1;
        }
      }
      else
      {
        close(v5);
        *(_DWORD *)(v9 + 28) = -1;
        free(v7);
      }
    }
  }
  return v6;
}

//----- (00052A04) --------------------------------------------------------
unsigned int __fastcall sub_52A04(int a1)
{
  int *v2; // r4
  int v3; // r6
  int v4; // r1
  int v5; // r3
  bool v6; // zf
  int v7; // r2
  unsigned int result; // r0
  bool v9; // zf
  bool v10; // r1
  __int16 *v12; // r0
  unsigned int v13; // r3
  int v14; // r2
  unsigned int v15; // r3
  int v16; // r0
  int v17; // r8
  int v18; // r3
  bool v19; // zf
  int v20; // r3
  bool v21; // zf
  double v22; // d7
  int v23; // lr
  unsigned int v24; // r2
  unsigned int v25; // r3
  bool v26; // cc
  bool v27; // zf
  char v28; // r3

  v2 = *(int **)(a1 + 84);
  v3 = *v2;
  v4 = *(_DWORD *)(*v2 + 140);
  v5 = *(unsigned __int8 *)(*v2 + 12);
  if ( (unsigned int)(v4 - 2) > 1 )
  {
    v6 = v5 == 70;
    if ( v5 != 70 )
      v6 = v5 == 65;
    v7 = v6;
    if ( v5 == 84 )
      v7 |= 1u;
    if ( v5 == 75 )
      v7 |= 1u;
    if ( v5 == 109 )
      v7 |= 1u;
    if ( v7 )
      return 0;
  }
  if ( v5 == 143 )
  {
    result = ((*((unsigned __int8 *)v2 + 768) ^ 2u) >> 1) & 1;
    if ( *(_WORD *)(v3 + 14) )
      result = 0;
    if ( result )
      return 0;
    v13 = *(unsigned __int8 *)(v3 + 13);
    if ( v13 == 171 )
    {
      if ( *(_WORD *)(v3 + 10) != 17 )
        goto LABEL_49;
      if ( *(int *)(v3 + 4) <= 0 )
        return 0;
      if ( !*(_WORD *)(v3 + 20) )
        goto LABEL_49;
      if ( (*(_BYTE *)(v3 + 22) & 0x1D) != 0 )
      {
        v2[52] = 0;
        if ( sub_524A8(v2 + 47, v2 + 48, (unsigned __int8 *)(v3 + 26)) < 0 )
          goto LABEL_49;
        v2[49] = *(unsigned __int8 *)(v3 + 25);
        v2[50] = *(unsigned __int8 *)(v3 + 24);
        v2[51] = *(unsigned __int8 *)(v3 + 23);
        return 1;
      }
    }
    else
    {
      if ( v13 <= 0xAB )
      {
        if ( v13 != 11 || *(int *)(v3 + 4) <= 0 )
          return 0;
        if ( *(_WORD *)(v3 + 10) != 74 )
          goto LABEL_49;
        if ( !*(_WORD *)(v3 + 29) )
          goto LABEL_49;
        v22 = COERCE_DOUBLE(_byteswap_uint64(*(_QWORD *)(v3 + 16)));
        v23 = (int)v22 - (_DWORD)&off_15180 * ((int)v22 / 86400);
        v2[52] = (int)((v22 - (double)(int)v22) * 1000000000.0);
        v2[49] = v23 / 3600;
        v2[50] = v23 % 3600 / 60;
        v2[51] = v23 % 3600 % 60;
        if ( sub_524A8(v2 + 47, v2 + 48, (unsigned __int8 *)(v3 + 24)) < 0 )
          goto LABEL_49;
        if ( !*(_BYTE *)(v3 + 8) )
          return 2;
        *(_BYTE *)(v3 + 8) = 0;
        return 0;
      }
      if ( v13 == 172 )
      {
        if ( *(int *)(v3 + 4) <= 0 )
          return 0;
        if ( *(_WORD *)(v3 + 10) != 68 )
          goto LABEL_49;
        if ( (__rev16(*(unsigned __int16 *)(v3 + 23)) & 0x80) == 0 )
          goto LABEL_57;
        v20 = *(_DWORD *)(v3 + 144);
        v21 = v20 == 12;
        if ( v20 != 12 )
          v21 = v20 == 6;
        if ( v21 )
        {
          *((_BYTE *)v2 + 40) = 1;
        }
        else
        {
LABEL_57:
          *((_BYTE *)v2 + 40) = 0;
          return 0;
        }
        return result;
      }
      if ( v13 != 173 )
        return 0;
      if ( *(_WORD *)(v3 + 10) != 22 )
        goto LABEL_49;
      v14 = *(_DWORD *)(v3 + 4);
      *(_BYTE *)(v3 + 8) = *(_BYTE *)(v3 + 32);
      if ( v14 <= 0 )
        return 0;
      v15 = *(unsigned __int8 *)(v3 + 31);
      if ( v15 <= 0xE )
      {
        v24 = v15 - 2;
        v25 = v15 - 11;
        v26 = v25 > 1;
        if ( v25 > 1 )
          v26 = v24 > 5;
        if ( !v26 )
          goto LABEL_27;
      }
      v16 = sub_524A8(v2 + 47, v2 + 48, (unsigned __int8 *)(v3 + 27));
      if ( v16 < 0 )
        goto LABEL_49;
      v17 = *(unsigned __int8 *)(v3 + 8);
      v18 = v16 >> 5;
      *(_DWORD *)(v3 + 144) = v16 >> 5;
      if ( (v17 & 2) != 0 )
      {
        v27 = v18 == 12;
        if ( v18 != 12 )
          v27 = v18 == 6;
        if ( v27 )
        {
          if ( (v17 & 1) != 0 )
            v28 = 1;
          else
            v28 = 2;
          *((_BYTE *)v2 + 40) = v28;
          goto LABEL_44;
        }
LABEL_43:
        *((_BYTE *)v2 + 40) = 0;
LABEL_44:
        v2[52] = (int)(COERCE_DOUBLE(_byteswap_uint64(*(_QWORD *)(v3 + 16))) * 1000000000.0);
        v2[49] = *(unsigned __int8 *)(v3 + 24);
        v2[50] = *(unsigned __int8 *)(v3 + 25);
        v2[51] = *(unsigned __int8 *)(v3 + 26);
        return 1;
      }
      if ( v17 )
        goto LABEL_43;
    }
    v12 = (__int16 *)a1;
    *((_BYTE *)v2 + 40) = 3;
    goto LABEL_28;
  }
  if ( v5 == 66 )
  {
    puts("0x42");
    return 0;
  }
  if ( v5 != 67 )
  {
    v9 = v4 == 2;
    if ( v4 == 2 )
      v9 = v5 == 65;
    if ( v9 )
    {
      puts("Undocumented 0x41 packet on Thunderbolt");
      return 0;
    }
    v10 = v4 == 3;
    if ( v5 != 65 || !v10 )
    {
      if ( v5 == 70 && v10 )
      {
        if ( *(_BYTE *)(v3 + 14) )
        {
LABEL_27:
          v12 = (__int16 *)a1;
LABEL_28:
          sub_394A0(v12, 6);
          *(_DWORD *)(v3 + 4) = -1;
          return 0;
        }
        goto LABEL_49;
      }
      v19 = v5 == 84;
      if ( v5 != 84 )
        v19 = v5 == 109;
      if ( !v19 )
      {
LABEL_49:
        sub_394A0((__int16 *)a1, 2);
        *(_DWORD *)(v3 + 4) = -1;
        return 0;
      }
    }
    return 0;
  }
  puts("0x43");
  return 0;
}
// 15180: using guessed type char *off_15180;

//----- (00052E7C) --------------------------------------------------------
int __fastcall sub_52E7C(int a1)
{
  __int16 *v2; // r6
  int v3; // r2
  int v4; // r0
  int v6; // [sp+0h] [bp-Ch] BYREF

  v2 = *(__int16 **)a1;
  if ( ioctl(*(_DWORD *)(a1 + 28), 0x5415u, &v6) < 0 )
  {
    sub_64E00(3, "Palisade(%d) HW_poll: ioctl(fd,GET): %m", *v2);
    return -1;
  }
  else
  {
    v3 = *((_DWORD *)v2 + 35);
    v4 = *(_DWORD *)(a1 + 28);
    v6 |= 4u;
    if ( v3 == 3 )
    {
      write(v4, byte_97F7C, 1u);
      v4 = *(_DWORD *)(a1 + 28);
    }
    if ( ioctl(v4, 0x5418u, &v6) < 0 )
    {
      sub_64E00(3, "Palisade(%d) HW_poll: ioctl(fd, SET, RTS_on): %m", *v2);
      return -1;
    }
    else
    {
      v6 &= ~4u;
      sub_5F724((int *)(a1 + 232));
      if ( ioctl(*(_DWORD *)(a1 + 28), 0x5418u, &v6) == -1 )
      {
        sub_64E00(3, "Palisade(%d) HW_poll: ioctl(fd, UNSET, RTS_off): %m", *v2);
        return -1;
      }
      else
      {
        return 0;
      }
    }
  }
}

//----- (00052FC4) --------------------------------------------------------
__int16 *__fastcall sub_52FC4(__int16 *result, int a2)
{
  int v3; // r4
  __int16 *v4; // r7
  int v5; // r5
  int v6; // r1

  v3 = *(_DWORD *)(a2 + 84);
  v4 = result;
  v5 = *(_DWORD *)v3;
  v6 = *(_DWORD *)(*(_DWORD *)v3 + 4);
  ++*(_DWORD *)(v3 + 776);
  if ( v6 > 0 )
    result = sub_394A0((__int16 *)a2, 1);
  *(_DWORD *)(v5 + 4) = 2;
  if ( (*(_BYTE *)(v3 + 768) & 2) == 0 )
  {
    if ( *(_DWORD *)(v5 + 140) == 1 )
    {
      result = (__int16 *)write(*(_DWORD *)(*(_DWORD *)(a2 + 84) + 28), "SPSTAT\r\n", 8u);
      if ( (int)result >= 0 )
      {
        praecis_msg = 1;
        return result;
      }
      sub_64E00(3, "Palisade(%d) write: %m:", v4);
    }
    result = (__int16 *)sub_52E7C(v3);
    if ( (int)result < 0 )
      return sub_394A0((__int16 *)a2, 3);
  }
  return result;
}
// 108CD8: using guessed type int praecis_msg;

//----- (000530E4) --------------------------------------------------------
__int16 *__fastcall sub_530E4(int a1)
{
  int v1; // r9
  unsigned __int8 *v3; // r5
  int v4; // r10
  size_t v5; // r2
  int v6; // r4
  __int16 *result; // r0
  unsigned __int8 *v8; // r6
  int v9; // r3
  int v10; // r2
  int v11; // t1
  int v12; // r3
  int v13; // r2
  int *v14; // r8
  int v15; // r11
  int v16; // r12
  _DWORD *v17; // r3
  _DWORD *v18; // r8
  int v19; // r1
  int v20; // r2
  unsigned __int8 *v21; // r1
  int v22; // r5
  int v23; // r3
  char *v24; // r2
  int v25; // r3

  v1 = *(_DWORD *)(a1 + 4);
  v3 = (unsigned __int8 *)(a1 + 88);
  v4 = *(_DWORD *)(v1 + 84);
  v5 = *(_DWORD *)(a1 + 84);
  v6 = *(_DWORD *)v4;
  result = (__int16 *)_stack_chk_guard;
  if ( *(_DWORD *)(*(_DWORD *)v4 + 140) != 1 || !praecis_msg )
  {
    v8 = &v3[v5];
    if ( &v3[v5] == v3 )
      return result;
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = *(unsigned __int8 *)(v6 + 9);
        v11 = *v3++;
        v10 = v11;
        if ( v9 != 3 )
          break;
        v12 = *(__int16 *)(v6 + 10);
        if ( v10 == 16 )
        {
          *(_BYTE *)(v6 + 9) = 4;
        }
        else
        {
          v13 = v6 + v12;
          v12 = (__int16)(v12 + 1);
          *(_WORD *)(v6 + 10) = v12;
          *(_BYTE *)(v13 + 13) = *(v3 - 1);
        }
LABEL_13:
        if ( v12 <= 128 )
          goto LABEL_8;
LABEL_14:
        *(_BYTE *)(v6 + 9) = 0;
        if ( v3 == v8 )
          return result;
      }
      if ( v9 == 4 )
      {
        if ( v10 == 16 )
        {
          v20 = *(__int16 *)(v6 + 10);
          *(_BYTE *)(v6 + 9) = 3;
          v12 = (__int16)(v20 + 1);
          *(_WORD *)(v6 + 10) = v12;
          *(_BYTE *)(v6 + v20 + 13) = *(v3 - 1);
          goto LABEL_13;
        }
        if ( v10 == 3 )
        {
          v25 = *(__int16 *)(v6 + 10);
          *(_BYTE *)(v6 + 9) = 1;
          if ( v25 > 128 )
            goto LABEL_14;
LABEL_25:
          v14 = *(int **)(v1 + 84);
          v15 = *v14;
          result = (__int16 *)sub_52A04(v1);
          if ( result && *(int *)(v15 + 4) > 0 )
          {
            v16 = v14[52];
            *(_DWORD *)(v15 + 4) = 0;
            v14[46] = 0;
            sub_6C054(
              (int)(v14 + 14),
              0x80u,
              "%4d %03d %02d:%02d:%02d.%09ld",
              v14[47],
              v14[48],
              v14[49],
              v14[50],
              v14[51],
              v16);
            v14[46] = 24;
            if ( sub_39CF8(v14) )
            {
              sub_41F44((unsigned __int16 *)(v1 + 16), (const char *)v14 + 56);
              v17 = v14 + 58;
              v18 = v14 + 56;
              v19 = v17[1];
              *v18 = *v17;
              v18[1] = v19;
              result = (__int16 *)sub_39D44(v1);
            }
            else
            {
              result = sub_394A0((__int16 *)v1, 6);
            }
          }
          goto LABEL_8;
        }
        *(_BYTE *)(v6 + 9) = 2;
        *(_BYTE *)(v6 + 12) = *(v3 - 1);
      }
      else
      {
        if ( v9 == 2 )
        {
          if ( v10 != 3 && v10 != 16 && v10 )
          {
            v12 = *(__int16 *)(v6 + 10);
            *(_BYTE *)(v6 + 9) = 3;
            *(_BYTE *)(v6 + 12) = *(v3 - 1);
            goto LABEL_13;
          }
LABEL_7:
          *(_BYTE *)(v6 + 9) = 0;
          *(_WORD *)(v6 + 10) = 0;
          goto LABEL_8;
        }
        if ( v10 != 16 )
          goto LABEL_7;
        *(_BYTE *)(v6 + 9) = 2;
      }
      *(_WORD *)(v6 + 10) = 0;
      if ( (*(_BYTE *)(v4 + 768) & 2) != 0 )
      {
        result = (__int16 *)sub_5F724((int *)(v4 + 232));
        if ( *(_BYTE *)(v6 + 9) == 1 )
          goto LABEL_25;
      }
LABEL_8:
      if ( v3 == v8 )
        return result;
    }
  }
  v21 = v3;
  v22 = dword_BD5FC;
  result = (__int16 *)memcpy(&byte_BD600[dword_BD5FC], v21, v5);
  v23 = v22 + *(_DWORD *)(a1 + 84);
  dword_BD5FC = v23;
  v24 = (char *)&dword_BD5F8 + v23 - 2;
  if ( v24[8] == 13 && *((_BYTE *)&dword_BD5F8 + v23 + 7) == 10 )
  {
    v24[8] = 0;
    sub_41F44((unsigned __int16 *)(v1 + 16), byte_BD600);
    dword_BD5FC = 0;
    praecis_msg = 0;
    result = (__int16 *)sub_52E7C(v4);
    if ( (int)result < 0 )
      return sub_394A0((__int16 *)v1, 3);
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// BD5F8: using guessed type int dword_BD5F8;
// BD5FC: using guessed type int dword_BD5FC;
// 108CD8: using guessed type int praecis_msg;

//----- (00053428) --------------------------------------------------------
int __fastcall sub_53428(int a1, int a2)
{
  int v2; // r1
  int result; // r0

  v2 = *(_DWORD *)(a2 + 84);
  if ( v2 )
    return close(*(_DWORD *)(v2 + 28));
  return result;
}

//----- (00053490) --------------------------------------------------------
int __fastcall sub_53490(int a1, int a2)
{
  int v4; // r2
  int v5; // r0
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v10; // r2
  int v11; // r0
  _BYTE v12[128]; // [sp+4h] [bp-88h] BYREF

  sub_6C054((int)v12, 0x80u, "/dev/pcfclocks/%d", a1);
  v5 = open64(v12, 0, v4);
  if ( v5 == -1 )
  {
    sub_6C054((int)v12, 0x80u, "/dev/pcfclock%d", a1);
    v11 = open64(v12, 0, v10);
    v6 = v11;
    if ( v11 == -1 )
      return 0;
  }
  else
  {
    v6 = v5;
  }
  v7 = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(v7 + 28) = v6;
  v8 = 1;
  *(_DWORD *)(v7 + 20) = a2;
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 24) = 0;
  *(_BYTE *)(a2 + 95) = -1;
  *(_DWORD *)(v7 + 44) = "Conrad parallel port radio clock";
  strcpy((char *)(v7 + 764), "PCF");
  *(_DWORD *)(v7 + 744) = -515396076;
  *(_DWORD *)(v7 + 748) = 1069945978;
  return v8;
}
// 534DC: variable 'v4' is possibly undefined
// 53580: variable 'v10' is possibly undefined
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);

//----- (000535B4) --------------------------------------------------------
__int16 *__fastcall sub_535B4(int a1, int a2)
{
  int v2; // r6
  int v5; // r2
  int v6; // r0
  bool v7; // cc
  struct tm *v8; // r7
  _DWORD *v9; // r9
  int v10; // r0
  int v11; // r2
  int v12; // r1
  bool v13; // zf
  int v14; // r3
  int tm_hour; // r12
  int tm_sec; // r2
  int tm_min; // r1
  int v18; // r1
  _DWORD *v19; // r6
  time_t v20; // [sp+0h] [bp-4Ch] BYREF
  struct tm tp; // [sp+4h] [bp-48h] BYREF
  _BYTE v22[8]; // [sp+30h] [bp-1Ch] BYREF
  unsigned __int8 v23; // [sp+38h] [bp-14h]
  unsigned __int8 v24; // [sp+3Ah] [bp-12h]
  unsigned __int8 v25; // [sp+3Bh] [bp-11h]
  unsigned __int8 v26; // [sp+3Ch] [bp-10h]
  unsigned __int8 v27; // [sp+3Dh] [bp-Fh]
  unsigned __int8 v28; // [sp+3Eh] [bp-Eh]
  unsigned __int8 v29; // [sp+3Fh] [bp-Dh]
  unsigned __int8 v30; // [sp+40h] [bp-Ch]
  char v31; // [sp+41h] [bp-Bh]

  v2 = *(_DWORD *)(a2 + 84);
  v22[0] = 0;
  if ( read(*(_DWORD *)(v2 + 28), v22, 0x12u) <= 17 || v22[0] != 9 )
    return sub_394A0((__int16 *)a2, 3);
  tp.tm_wday = 0;
  v5 = 10 * v29 + v28;
  tp.tm_mon = 10 * v27 + v26 - 1;
  tp.tm_yday = 0;
  tp.tm_gmtoff = 0;
  tp.tm_zone = 0;
  tp.tm_year = v5;
  if ( (v23 & 1) != 0 )
    v6 = 1;
  else
    v6 = v23 ^ 2;
  if ( (v23 & 1) == 0 )
    v6 = v6 << 30 >> 31;
  v7 = v5 <= 98;
  tp.tm_isdst = v6;
  if ( v5 <= 98 )
    v5 += 100;
  tp.tm_mday = 10 * v25 + v24;
  if ( v7 )
    tp.tm_year = v5;
  tp.tm_hour = 10 * v22[7] + v22[6];
  tp.tm_min = 10 * v22[5] + v22[4];
  tp.tm_sec = 10 * v22[3] + v22[2];
  v20 = mktime(&tp);
  if ( v20 == -1 )
    return sub_394A0((__int16 *)a2, 6);
  *(_DWORD *)(v2 + 184) = strftime((char *)(v2 + 56), 0x80u, "%Y %m %d %H %M %S", &tp);
  v8 = gmtime_r(&v20, &tp);
  if ( !v8 )
    return sub_394A0((__int16 *)a2, 3);
  v9 = (_DWORD *)(v2 + 232);
  sub_5F724((int *)(v2 + 232));
  v10 = 31250000 * v30;
  v11 = *(_DWORD *)(v2 + 776);
  v12 = v8->tm_yday + 1;
  v13 = (v31 & 1) == 0;
  *(_DWORD *)(v2 + 188) = v8->tm_year + 1900;
  v14 = v11 + 1;
  tm_hour = v8->tm_hour;
  tm_sec = v8->tm_sec;
  *(_DWORD *)(v2 + 192) = v12;
  tm_min = v8->tm_min;
  *(_DWORD *)(v2 + 776) = v14;
  if ( !v13 )
    v14 = 500000000;
  *(_DWORD *)(v2 + 208) = v10;
  if ( !v13 )
    v14 += v10;
  *(_DWORD *)(v2 + 196) = tm_hour;
  if ( !v13 )
    *(_DWORD *)(v2 + 208) = v14;
  *(_DWORD *)(v2 + 200) = tm_min;
  *(_DWORD *)(v2 + 204) = tm_sec;
  if ( !sub_39CF8((_DWORD *)v2) )
    return sub_394A0((__int16 *)a2, 6);
  sub_41F44((unsigned __int16 *)(a2 + 16), (const char *)(v2 + 56));
  if ( (v22[1] & 1) == 0 || (*(_BYTE *)(v2 + 768) & 2) != 0 )
    *(_BYTE *)(v2 + 40) = 0;
  else
    *(_BYTE *)(v2 + 40) = 3;
  v18 = *(_DWORD *)(v2 + 236);
  v19 = (_DWORD *)(v2 + 224);
  *v19 = *v9;
  v19[1] = v18;
  return (__int16 *)sub_39D44(a2);
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00053808) --------------------------------------------------------
__int16 *__fastcall sub_53808(int a1, int a2)
{
  int v3; // r4
  _DWORD *v4; // t1
  __int16 *result; // r0

  v3 = *(_DWORD *)(a2 + 84);
  v4 = *(_DWORD **)v3;
  *v4 = 0;
  v4[1] = v3 + 56;
  if ( write(*(_DWORD *)(v3 + 28), "QTQDQMT", 6u) != 6 )
    sub_394A0((__int16 *)a2, 3);
  if ( *(_DWORD *)(v3 + 216) == *(_DWORD *)(v3 + 220) )
    return sub_394A0((__int16 *)a2, 1);
  sub_39D44(a2);
  result = (__int16 *)sub_41F44((unsigned __int16 *)(a2 + 16), (const char *)(v3 + 56));
  ++*(_DWORD *)(v3 + 776);
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (000538E0) --------------------------------------------------------
void __fastcall sub_538E0(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (00053960) --------------------------------------------------------
int __fastcall sub_53960(int a1, int a2)
{
  int v3; // r8
  int v4; // r7
  void *v5; // r0
  int v6; // r4
  void *v7; // r9
  char v9[20]; // [sp+0h] [bp-1Ch] BYREF

  sub_6C054((int)v9, 0x14u, "/dev/wwv%d", a1);
  v3 = sub_3A298(v9, 0xDu, 1);
  if ( v3 <= 0 )
    return 0;
  v5 = sub_63BA4(0, 8u, 0, 1);
  v6 = *(_DWORD *)(a2 + 84);
  v7 = v5;
  *(_DWORD *)(v6 + 20) = a2;
  *(_DWORD *)(v6 + 28) = v3;
  *(_DWORD *)(v6 + 12) = sub_53A84;
  *(_DWORD *)(v6 + 24) = 0;
  v4 = sub_18DF0((int *)(v6 + 8));
  if ( v4 )
  {
    v4 = 1;
    *(_DWORD *)v6 = v7;
    *(_BYTE *)(a2 + 95) = -10;
    *(_DWORD *)(v6 + 44) = "PSTI/Traconex WWV/WWVH Receiver";
    strcpy((char *)(v6 + 764), "WWV");
  }
  else
  {
    close(v3);
    *(_DWORD *)(v6 + 28) = -1;
    free(v7);
  }
  return v4;
}

//----- (00053A84) --------------------------------------------------------
__int16 *__fastcall sub_53A84(int a1)
{
  int v1; // r7
  int v2; // r5
  int *v3; // r4
  __int16 *result; // r0
  int v5; // r2
  int v6; // r12
  int v7; // r1
  int v8; // r12
  int v9; // r2
  int v10; // r3
  int v11; // r1
  _DWORD *v12; // r2
  bool v13; // zf
  int v14; // r0
  double v15; // d7
  char v16; // [sp+22h] [bp-2Eh] BYREF
  char v17; // [sp+23h] [bp-2Dh] BYREF
  unsigned int v18; // [sp+24h] [bp-2Ch] BYREF
  _DWORD v19[2]; // [sp+28h] [bp-28h] BYREF
  char v20; // [sp+30h] [bp-20h] BYREF
  char v21; // [sp+3Ch] [bp-14h] BYREF
  unsigned __int8 v22; // [sp+45h] [bp-Bh]
  char v23; // [sp+48h] [bp-8h]

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 84);
  v3 = *(int **)v2;
  result = (__int16 *)sub_39EE4(a1, *(bool **)(*(_DWORD *)v2 + 4), v2 + 182 - *(_DWORD *)(*(_DWORD *)v2 + 4), v19);
  v5 = v3[1];
  v6 = v2 + 56;
  v3[1] = (int)result + v5 + 1;
  *((_BYTE *)result + v5) = 32;
  *(_BYTE *)v3[1] = 0;
  if ( *v3 )
  {
    v9 = v3[1];
    v10 = *v3 + 1;
    *v3 = v10;
    *(_DWORD *)(v2 + 184) = v9 - v6;
    if ( v10 > 2 )
    {
      if ( v9 - v6 > 45
        && sscanf(
             (const char *)(v2 + 56),
             "%c%2d:%2d:%2d.%3ld%c %9s%3d%13s%4ld",
             &v16,
             v2 + 196,
             v2 + 200,
             v2 + 204,
             v2 + 208,
             &v17,
             &v20,
             v2 + 192,
             &v21,
             &v18) == 10 )
      {
        v11 = *(_DWORD *)(v2 + 208);
        v12 = (_DWORD *)v22;
        v13 = v22 == 56;
        *(_DWORD *)(v2 + 208) = (_DWORD)&unk_F4240 * v11;
        if ( !v13 )
          *(_BYTE *)(v2 + 40) = 3;
        if ( v23 == 72 )
        {
          v14 = *(_DWORD *)"WWVH";
          *(_DWORD *)(v2 + 764) = *(_DWORD *)"WWVH";
        }
        else
        {
          v14 = *(_DWORD *)"WWV";
          strcpy((char *)(v2 + 764), "WWV");
        }
        if ( *(unsigned __int8 *)(v1 + 93) <= 1u )
          *(_DWORD *)(v1 + 112) = *(_DWORD *)(v2 + 764);
        if ( !v18 )
        {
          v14 = *(_DWORD *)(v2 + 232);
          v11 = *(_DWORD *)(v2 + 236);
          v12 = (_DWORD *)(v2 + 224);
        }
        v15 = (double)v18;
        if ( !v18 )
        {
          *v12 = v14;
          v12[1] = v11;
        }
        *(double *)(v2 + 248) = v15 * 0.00001 * 60.0;
        result = (__int16 *)sub_39CF8((_DWORD *)v2);
        if ( result )
        {
          if ( *(double *)(v1 + 632) > 1.5 )
            return (__int16 *)sub_39D44(v1);
        }
        else
        {
          return sub_394A0((__int16 *)v1, 6);
        }
      }
      else
      {
        return sub_394A0((__int16 *)v1, 2);
      }
    }
  }
  else
  {
    result = (__int16 *)v19[0];
    v7 = v19[1];
    v8 = v3[1] - v6;
    *(_DWORD *)(v2 + 232) = v19[0];
    *(_DWORD *)(v2 + 236) = v7;
    *v3 = 1;
    *(_DWORD *)(v2 + 184) = v8;
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00053CC4) --------------------------------------------------------
FILE *sub_53CC4(int a1, int a2, ...)
{
  int *v2; // r3
  int v3; // r5
  unsigned int v4; // r3
  FILE *result; // r0
  int v6; // r2
  int v7; // r4
  int v8; // r3
  int v9; // r7
  int v10; // r0
  FILE *v11; // r0
  _BYTE v12[40]; // [sp+4h] [bp-2Ch] BYREF
  int varg_r1; // [sp+44h] [bp+14h]
  va_list varg_r2; // [sp+48h] [bp+18h] BYREF

  va_start(varg_r2, a2);
  varg_r1 = a2;
  v2 = *(int **)(a1 + 84);
  v3 = *v2;
  v4 = *((unsigned __int8 *)v2 + 768);
  result = *(FILE **)(v3 + 24);
  v6 = (v4 >> 1) & 1;
  v7 = v4 & 2;
  v8 = (int)result;
  if ( result )
    v8 = 1;
  v9 = varg_r1;
  if ( v6 != v8 )
  {
    if ( !v7 )
    {
      result = (FILE *)fclose(result);
      *(_DWORD *)(v3 + 24) = 0;
      return result;
    }
    sub_6C054((int)v12, 0x28u, "/tmp/true%d.debug", *(_DWORD *)(v3 + 20));
    v10 = open64(v12, 193, 384);
    if ( v10 >= 0 )
    {
      v11 = fdopen(v10, "w");
      *(_DWORD *)(v3 + 24) = v11;
      if ( v11 )
        setvbuf(v11, byte_BD664, 1, 0x2000u);
    }
    result = *(FILE **)(v3 + 24);
  }
  if ( result )
  {
    _fprintf_chk(result, 1, "true%d: ", *(_DWORD *)(v3 + 20));
    return (FILE *)_vfprintf_chk(*(_DWORD *)(v3 + 24), 1, v9, (char *)varg_r2);
  }
  return result;
}
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// BAAC: using guessed type int __fastcall _vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (00053E04) --------------------------------------------------------
__int16 *__fastcall sub_53E04(__int16 *result, char *s)
{
  int v2; // r5
  __int16 *v3; // r6
  size_t v5; // r8

  v2 = *((_DWORD *)result + 21);
  if ( (*(_BYTE *)(v2 + 768) & 1) == 0 )
  {
    v3 = result;
    v5 = strlen(s);
    sub_53CC4((int)v3, (int)"Send '%s'\n", s);
    result = (__int16 *)write(*(_DWORD *)(v2 + 28), s, v5);
    if ( result == (__int16 *)v5 )
      ++*(_DWORD *)(v2 + 776);
    else
      return sub_394A0(v3, 3);
  }
  return result;
}

//----- (00053ECC) --------------------------------------------------------
__int16 *__fastcall sub_53ECC(int a1, unsigned int a2)
{
  unsigned int v3; // r6
  unsigned int v4; // r10
  const char *v5; // r9
  int v6; // r5
  int v7; // r3
  const char *v8; // r2
  int v9; // r3
  const char *v10; // r3
  __int16 *result; // r0
  int v12; // r3
  const char *v13; // r2
  const char *v14; // r3
  int v15; // r3
  __int16 *v16; // r0
  char *v17; // r1
  const char *v18; // r9
  const char *v19; // r2
  char *v20; // r1
  int v21; // r3
  const char *v22; // [sp+Ch] [bp-8h]

  v3 = a2;
  v4 = a2;
  v5 = *(const char **)(a1 + 84);
  v6 = *(_DWORD *)v5;
  v7 = *(_DWORD *)(*(_DWORD *)v5 + 16);
  if ( a2 == 9 )
    goto LABEL_3;
  while ( 2 )
  {
    if ( (ntp_syslogmask & 0x400) == 0 )
      goto LABEL_3;
    if ( v7 <= 5 )
    {
      v13 = types[v7];
      v12 = *(_DWORD *)(v6 + 12);
      if ( v12 > 10 )
      {
LABEL_32:
        v14 = "?";
        goto LABEL_12;
      }
    }
    else
    {
      v12 = *(_DWORD *)(v6 + 12);
      v13 = "?";
      if ( v12 > 10 )
        goto LABEL_32;
    }
    v14 = states[v12];
LABEL_12:
    sub_64E00(6, "TRUE: clock %s, state %s, event %s", v13, v14, events[v4]);
    v7 = *(_DWORD *)(v6 + 16);
LABEL_3:
    if ( v7 > 5 )
    {
      v9 = *(_DWORD *)(v6 + 12);
      v8 = "?";
      if ( v9 > 10 )
      {
LABEL_8:
        v10 = "?";
        goto LABEL_6;
      }
    }
    else
    {
      v8 = types[v7];
      v9 = *(_DWORD *)(v6 + 12);
      if ( v9 > 10 )
        goto LABEL_8;
    }
    v10 = states[v9];
LABEL_6:
    result = (__int16 *)sub_53CC4(a1, (int)"clock %s, state %s, event %s\n", v8, v10, events[v4]);
    switch ( *(_DWORD *)(v6 + 16) )
    {
      case 0:
        if ( v3 == 7 )
          return result;
        break;
      case 1:
        switch ( v3 )
        {
          case 5u:
            goto LABEL_34;
          case 7u:
            v16 = (__int16 *)a1;
            v17 = "P";
            return sub_53E04(v16, v17);
          case 0u:
LABEL_34:
            result = sub_53E04((__int16 *)a1, "C");
            *(_DWORD *)(v6 + 12) = 9;
            if ( !v3 )
            {
LABEL_30:
              result = sub_53E04((__int16 *)a1, "C");
              *(_DWORD *)(v6 + 12) = 9;
            }
            return result;
        }
LABEL_22:
        if ( v3 != 9 )
          return result;
LABEL_23:
        if ( (unsigned int)(*(_DWORD *)(v6 + 12) - 9) > 1 )
        {
          v16 = (__int16 *)a1;
          v17 = (char *)&unk_996E0;
          return sub_53E04(v16, v17);
        }
        goto LABEL_15;
      case 2:
        switch ( v3 )
        {
          case 0u:
            result = sub_53E04((__int16 *)a1, "F18\r");
            *(_DWORD *)(v6 + 12) = 6;
            return result;
          case 2u:
            v18 = v5 + 56;
            sub_53E04((__int16 *)a1, "F50\r");
            if ( strcmp(v18, " TRUETIME Mk III") )
            {
              result = (__int16 *)strncmp(v18, " TRUETIME XL", 0xCu);
              if ( result )
              {
                *(_DWORD *)(v6 + 12) = 7;
                return result;
              }
            }
            result = (__int16 *)sub_53ECC(a1, 2);
            if ( (ntp_syslogmask & 0x400) == 0 )
              return result;
            v19 = v18;
            v20 = "TM/TMD/XL: %s";
            break;
          case 3u:
            result = sub_53E04((__int16 *)a1, "F51\r");
            *(_DWORD *)(v6 + 12) = 8;
            return result;
          case 4u:
            result = sub_53E04((__int16 *)a1, "F08\r");
            *(_DWORD *)(v6 + 12) = 9;
            return result;
          case 9u:
            goto LABEL_23;
          default:
            return result;
        }
        return (__int16 *)sub_64E00(6, (unsigned __int8 *)v20, v19);
      case 3:
        if ( v3 )
          goto LABEL_22;
        sub_53E04((__int16 *)a1, "MD3\r");
        sub_53E04((__int16 *)a1, "TSU\r");
        result = sub_53E04((__int16 *)a1, "AU\r");
        *(_DWORD *)(v6 + 12) = 9;
        return result;
      case 4:
        if ( !v3 )
          goto LABEL_30;
        goto LABEL_22;
      case 5:
        if ( v3 )
        {
          if ( v3 == 9 )
LABEL_15:
            *(_DWORD *)(v6 + 12) = 10;
        }
        else
        {
          v16 = (__int16 *)a1;
          v17 = "ST1";
          return sub_53E04(v16, v17);
        }
        return result;
      default:
        sub_64E00(6, "TRUE: cannot identify refclock!");
        goto LABEL_76;
    }
    v15 = *(_DWORD *)(v6 + 12);
    switch ( v15 )
    {
      case 0:
        if ( v3 )
          goto LABEL_76;
        result = sub_53E04((__int16 *)a1, "P\r");
        *(_DWORD *)(v6 + 12) = 4;
        return result;
      case 1:
        if ( v3 <= 1 )
        {
          result = sub_53E04((__int16 *)a1, "PO\r");
          *(_DWORD *)(v6 + 12) = 2;
          return result;
        }
        if ( v3 == 2 )
        {
          v5 = *(const char **)(a1 + 84);
          *(_DWORD *)(v6 + 16) = 2;
          v3 = 0;
          v4 = 0;
          v6 = *(_DWORD *)v5;
          v7 = *(_DWORD *)(*(_DWORD *)v5 + 16);
          continue;
        }
        v19 = v22;
        v20 = "TRUE: TM/TMD init fellthrough!";
        return (__int16 *)sub_64E00(6, (unsigned __int8 *)v20, v19);
      case 2:
        if ( v3 <= 1 )
        {
          *(_DWORD *)(v6 + 12) = 0;
          return (__int16 *)sleep(1u);
        }
        if ( v3 != 8 )
        {
          v19 = v22;
          v20 = "TRUE: TCU init fellthrough!";
          return (__int16 *)sub_64E00(6, (unsigned __int8 *)v20, v19);
        }
        v5 = *(const char **)(a1 + 84);
        v21 = 3;
LABEL_62:
        *(_DWORD *)(v6 + 16) = v21;
        v3 = 0;
        v6 = *(_DWORD *)v5;
        v4 = 0;
        v7 = *(_DWORD *)(*(_DWORD *)v5 + 16);
        continue;
      case 3:
        if ( v3 <= 1 )
        {
          *(_DWORD *)(v6 + 12) = 1;
          v16 = (__int16 *)a1;
          v17 = "F18\r";
          return sub_53E04(v16, v17);
        }
        if ( v3 != 9 )
LABEL_76:
          abort();
        *(_QWORD *)(v6 + 12) = 0x40000000ALL;
        return result;
      case 4:
        switch ( v3 )
        {
          case 0u:
          case 1u:
          case 9u:
            sub_53E04((__int16 *)a1, "ST0");
            sleep(1u);
            *(_DWORD *)(v6 + 12) = 5;
            v16 = (__int16 *)a1;
            v17 = "QV";
            return sub_53E04(v16, v17);
          case 5u:
            v5 = *(const char **)(a1 + 84);
            v21 = 1;
            goto LABEL_62;
          default:
            goto LABEL_76;
        }
      case 5:
        switch ( v3 )
        {
          case 0u:
          case 1u:
            *(_DWORD *)(v6 + 12) = 3;
            v16 = (__int16 *)a1;
            v17 = "C\r";
            return sub_53E04(v16, v17);
          case 6u:
            *(_DWORD *)(v6 + 16) = 5;
            *(_DWORD *)(v6 + 12) = 10;
            v16 = (__int16 *)a1;
            v17 = "ST1";
            return sub_53E04(v16, v17);
          case 9u:
            *(_QWORD *)(v6 + 12) = 0x50000000ALL;
            break;
          default:
            v19 = (const char *)v3;
            v20 = "TRUE: TL3 init fellthrough! (%d)";
            return (__int16 *)sub_64E00(6, (unsigned __int8 *)v20, v19);
        }
        return result;
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        if ( v15 == 11 )
          v19 = "?";
        else
          v19 = states[v15];
        v20 = "TRUE: state %s is unexpected!";
        return (__int16 *)sub_64E00(6, (unsigned __int8 *)v20, v19);
      default:
        return result;
    }
  }
}
// 54520: variable 'v22' is possibly undefined
// B70A8: using guessed type char *types[2];
// B70C0: using guessed type char *states[21];
// B70EC: using guessed type char *events[10];
// B7CD4: using guessed type int ntp_syslogmask;

//----- (0005465C) --------------------------------------------------------
int __fastcall sub_5465C(int a1, int a2)
{
  int **v3; // r4
  int *v4; // r5
  int v5; // r1
  int *v7; // r3

  v3 = *(int ***)(a2 + 84);
  v4 = *v3;
  v5 = **v3;
  if ( v5 )
  {
    *v4 = v5 - 1;
  }
  else
  {
    sub_53ECC(a2, 0);
    sub_394A0((__int16 *)a2, 1);
  }
  v7 = v3[194];
  v4[2] = 1;
  v3[194] = (int *)((char *)v7 + 1);
  return 1;
}

//----- (000546EC) --------------------------------------------------------
void __fastcall sub_546EC(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (0005476C) --------------------------------------------------------
char *__fastcall sub_5476C(int a1)
{
  int v1; // r5
  int v2; // r4
  _DWORD *v3; // r10
  char *result; // r0
  _DWORD *v5; // r9
  int v6; // r1
  int v7; // r3
  int v8; // r3
  bool v9; // zf
  int v10; // r3
  bool v11; // zf
  int v12; // r3
  const char *v13; // r2
  __int64 v14; // r0
  bool v15; // zf
  int v16; // r2
  int v17; // r3
  int v18; // r1
  _DWORD *v19; // r4
  unsigned __int8 v20; // [sp+13h] [bp-A1h] BYREF
  int v21; // [sp+14h] [bp-A0h] BYREF
  char v22; // [sp+18h] [bp-9Ch] BYREF
  int v23; // [sp+1Ch] [bp-98h] BYREF
  char v24; // [sp+20h] [bp-94h] BYREF
  _DWORD v25[2]; // [sp+24h] [bp-90h] BYREF
  bool v26[136]; // [sp+2Ch] [bp-88h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 84);
  v3 = *(_DWORD **)v2;
  result = (char *)(unsigned __int16)sub_39EE4(a1, v26, 128, v25);
  v26[(unsigned __int16)result] = 0;
  if ( (_WORD)result )
  {
    *(_DWORD *)(v2 + 184) = (unsigned __int16)result;
    v5 = (_DWORD *)(v2 + 232);
    sub_6D4DC((_BYTE *)(v2 + 56), (unsigned __int8 *)v26, 128);
    v6 = v25[1];
    v7 = *(_DWORD *)(v2 + 184);
    *(_DWORD *)(v2 + 232) = v25[0];
    *(_DWORD *)(v2 + 236) = v6;
    sub_53CC4(v1, (int)"receive(%s) [%d]\n", (const char *)(v2 + 56), v7);
    *v3 = 2;
    sub_41F44((unsigned __int16 *)(v1 + 16), (const char *)(v2 + 56));
    if ( *(_BYTE *)(v2 + 56) == 63 || !strcmp((const char *)(v2 + 56), "ERROR 05 NO SUCH FUNCTION") )
    {
      return (char *)sub_53ECC(v1, 1u);
    }
    else if ( ((*(unsigned __int8 *)(v2 + 61) - 43) & 0xFD) != 0
           || ((*(unsigned __int8 *)(v2 + 65) - 43) & 0xFD) != 0
           || sscanf((const char *)(v2 + 56), "%5d%*c%3d%*c%3d", &v23, &v22, &v24) != 3 )
    {
      if ( sscanf((const char *)(v2 + 56), "F%2d", &v21) == 1 && (unsigned int)(v21 - 1) <= 0x4E )
      {
        if ( v21 == 50 )
        {
          return (char *)sub_53ECC(v1, 3u);
        }
        else if ( v21 == 51 )
        {
          return (char *)sub_53ECC(v1, 4u);
        }
        else
        {
          return (char *)sub_53CC4(v1, (int)"got F%02d - ignoring\n", v21);
        }
      }
      else if ( *(_WORD *)(v2 + 56) == 17750 && *(_BYTE *)(v2 + 58) == 82 && *(_BYTE *)(v2 + 62) == 46 )
      {
        result = (char *)sub_53ECC(v1, 6u);
        if ( (ntp_syslogmask & 0x400) != 0 )
          return sub_64E00(6, "TL3: %s", (const char *)(v2 + 56));
      }
      else if ( !strncmp((const char *)(v2 + 56), " TRUETIME Mk III ", 0x11u)
             || !strncmp((const char *)(v2 + 56), " TRUETIME XL", 0xCu) )
      {
        result = (char *)sub_53ECC(v1, 2u);
        if ( (ntp_syslogmask & 0x400) != 0 )
          return sub_64E00(6, "TM/TMD/XL: %s", (const char *)(v2 + 56));
      }
      else
      {
        v8 = *(unsigned __int8 *)(v2 + 56);
        v9 = v8 == 83;
        if ( v8 != 83 )
          v9 = v8 == 78;
        if ( !v9 )
          goto LABEL_42;
        v10 = *(unsigned __int8 *)(v2 + 65);
        v11 = v10 == 69;
        if ( v10 != 69 )
          v11 = v10 == 87;
        if ( v11 && *(_BYTE *)(v2 + 74) == 43 )
        {
          result = (char *)sub_53ECC(v1, 8u);
          if ( (ntp_syslogmask & 0x400) != 0 )
            return sub_64E00(6, "TCU-800: %s", (const char *)(v2 + 56));
        }
        else
        {
LABEL_42:
          if ( *(_BYTE *)(v2 + 59) == 58
            && *(_BYTE *)(v2 + 62) == 58
            && *(_BYTE *)(v2 + 65) == 58
            && sscanf((const char *)(v2 + 56), "%3d:%2d:%2d:%2d%c", v2 + 192, v2 + 196, v2 + 200, v2 + 204, &v20) == 5 )
          {
            v15 = v20 == 88;
            if ( v20 != 88 )
              v15 = v20 == 35;
            v16 = v15;
            if ( (unsigned int)v20 - 62 <= 1 )
              v17 = v16 | 1;
            else
              v17 = v16;
            if ( v17 )
              LOBYTE(v17) = 3;
            *(_BYTE *)(v2 + 40) = v17;
            result = (char *)sub_53ECC(v1, 9u);
            if ( v3[2] )
            {
              if ( v3[4] <= 1u )
                sub_53ECC(v1, 7u);
              if ( sub_39CF8((_DWORD *)v2) )
              {
                v18 = *(_DWORD *)(v2 + 236);
                v19 = (_DWORD *)(v2 + 224);
                *v19 = *v5;
                v19[1] = v18;
                sub_39D44(v1);
                result = (char *)sub_394A0((__int16 *)v1, 0);
                v3[2] = 0;
              }
              else
              {
                return (char *)sub_394A0((__int16 *)v1, 6);
              }
            }
          }
          else
          {
            return (char *)sub_394A0((__int16 *)v1, 2);
          }
        }
      }
    }
    else
    {
      if ( (unsigned int)(v23 - 7001) > 0x1B56 )
      {
        v13 = "UNKNOWN";
      }
      else
      {
        if ( v23 > 9999 )
        {
          v12 = 0;
          v13 = "WEST";
        }
        else
        {
          v12 = 1;
          v13 = "EAST";
        }
        if ( v12 != v3[1] )
        {
          v14 = *(_QWORD *)(v2 + 752);
          *(_QWORD *)(v2 + 752) = *(_QWORD *)(v2 + 744);
          *(_QWORD *)(v2 + 744) = v14;
          v3[1] = v12;
        }
      }
      sub_53CC4(v1, (int)"GOES: station %s\n", v13);
      return (char *)sub_53ECC(v1, 5u);
    }
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// B7CD4: using guessed type int ntp_syslogmask;

//----- (00054C54) --------------------------------------------------------
int __fastcall sub_54C54(int a1, int a2)
{
  int v3; // r9
  int v4; // r7
  _DWORD *v5; // r0
  _DWORD *v6; // r4
  _DWORD *v7; // r10
  char v9[40]; // [sp+4h] [bp-2Ch] BYREF

  sub_6C054((int)v9, 0x28u, "/dev/true%d", a1);
  v3 = sub_3A298(v9, 0xDu, 1);
  if ( v3 <= 0 )
    return 0;
  v5 = sub_63BA4(0, 0x1Cu, 0, 1);
  v6 = *(_DWORD **)(a2 + 84);
  v7 = v5;
  v6[5] = a2;
  v6[7] = v3;
  v6[3] = sub_5476C;
  v6[6] = 0;
  v4 = sub_18DF0(v6 + 2);
  if ( v4 )
  {
    v4 = 1;
    *v6 = v7;
    *(_BYTE *)(a2 + 95) = -10;
    v6[11] = "Kinemetrics/TrueTime Receiver";
    v6[191] = *(_DWORD *)"TRUE";
    v7[4] = 0;
    v7[3] = 0;
    *v7 = 2;
    sub_53E04((__int16 *)a2, byte_996E0);
    sub_53ECC(a2, 0);
  }
  else
  {
    close(v3);
    v6[7] = -1;
    free(v7);
  }
  return v4;
}

//----- (00054DA8) --------------------------------------------------------
__int16 *__fastcall sub_54DA8(int a1, int a2)
{
  int v3; // r4
  int v4; // r1
  char buf; // [sp+3h] [bp-5h] BYREF

  v3 = *(_DWORD *)(a2 + 84);
  buf = 84;
  if ( (*(_BYTE *)(v3 + 768) & 1) == 0 || write(*(_DWORD *)(v3 + 28), &buf, 1u) == 1 )
  {
    ++*(_DWORD *)(v3 + 776);
    if ( *(_DWORD *)(v3 + 216) == *(_DWORD *)(v3 + 220) )
      return sub_394A0((__int16 *)a2, 1);
  }
  else
  {
    sub_394A0((__int16 *)a2, 3);
    if ( *(_DWORD *)(v3 + 216) == *(_DWORD *)(v3 + 220) )
      return sub_394A0((__int16 *)a2, 1);
  }
  v4 = *(_DWORD *)(v3 + 236);
  *(_DWORD *)(v3 + 224) = *(_DWORD *)(v3 + 232);
  *(_DWORD *)(v3 + 228) = v4;
  sub_39D44(a2);
  return (__int16 *)sub_41F44((unsigned __int16 *)(a2 + 16), (const char *)(v3 + 56));
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00054E84) --------------------------------------------------------
void __fastcall sub_54E84(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (00054F04) --------------------------------------------------------
__int16 *__fastcall sub_54F04(int a1)
{
  int v1; // r8
  unsigned __int8 **v2; // r4
  const char *v3; // r5
  unsigned __int8 *v4; // r6
  __int16 *result; // r0
  __int16 *v6; // r3
  int v7; // r2
  __int16 **v8; // r6
  __int16 *v9; // r1
  unsigned __int8 *v10; // r0
  unsigned __int8 *v11; // r1
  __int16 *v12; // r1
  int v13; // r3
  unsigned __int8 *v14; // r2
  int v15; // r3
  int v16; // r2
  bool v17; // zf
  char v18; // r3
  int v19; // r3
  _BYTE v20[4]; // [sp+20h] [bp-8h] BYREF
  int v21; // [sp+24h] [bp-4h] BYREF
  __int16 *v22; // [sp+28h] [bp+0h] BYREF
  __int16 *v23; // [sp+2Ch] [bp+4h]
  char v24; // [sp+30h] [bp+8h] BYREF
  char v25; // [sp+31h] [bp+9h]

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(unsigned __int8 ***)(v1 + 84);
  v21 = 0x7FFFFFFF;
  v3 = (const char *)(v2 + 14);
  v4 = *v2;
  result = (__int16 *)sub_39EE4(a1, (bool *)v2 + 56, 128, &v22);
  v6 = result;
  if ( !result )
  {
    v7 = *v4;
    if ( *v4 )
      *v4 = 0;
    else
      LOBYTE(v6) = 1;
    if ( !v7 )
    {
      *v4 = (unsigned __int8)v6;
      v8 = (__int16 **)(v4 + 4);
      result = v22;
      v9 = v23;
      *v8 = v22;
      v8[1] = v9;
    }
    return result;
  }
  v10 = (unsigned __int8 *)*((_DWORD *)v4 + 1);
  v11 = (unsigned __int8 *)*((_DWORD *)v4 + 2);
  v2[46] = (unsigned __int8 *)v6;
  v2[58] = v10;
  v2[59] = v11;
  v12 = v23;
  *((_DWORD *)v4 + 1) = v22;
  *((_DWORD *)v4 + 2) = v12;
  *v4 = 1;
  memset(v20, 32, sizeof(v20));
  if ( v6 == (__int16 *)&off_18 )
    goto LABEL_14;
  if ( v6 != (__int16 *)&dword_20 )
    return sub_394A0((__int16 *)v1, 2);
  if ( sscanf(v3, "%c%*31c", &v20[3]) != 1 )
  {
LABEL_14:
    if ( sscanf(
           v3,
           "%c%1d%c%4d%3d%*c%2d:%2d:%2d.%2ld%c",
           v20,
           &v21,
           &v20[2],
           v2 + 47,
           v2 + 48,
           v2 + 49,
           v2 + 50,
           v2 + 51,
           v2 + 52,
           &v20[1]) == 10 )
    {
      v16 = v20[1];
      v17 = v20[1] == 73;
      v2[52] = (unsigned __int8 *)(10000000 * (_DWORD)v2[52]);
      if ( v17 )
      {
        v20[1] = 43;
      }
      else if ( v16 == 68 )
      {
        v20[1] = 45;
      }
      v15 = v20[0];
      if ( v20[0] == 63 )
      {
        v14 = v2[46];
      }
      else
      {
        v15 = 58;
        v14 = v2[46];
        v20[0] = 58;
      }
      goto LABEL_23;
    }
    return sub_394A0((__int16 *)v1, 2);
  }
  v13 = v20[3];
  if ( v20[3] == 82 )
  {
    if ( sscanf(
           v3,
           "%*2c %*2c%2c%*c%4d%*c%3d%*4c %2d%c%2d:%2d%c%*2c",
           &v24,
           v2 + 47,
           v2 + 48,
           v2 + 49,
           v20,
           v2 + 50,
           v2 + 51,
           &v20[1]) == 8 )
    {
      if ( v24 == 48 )
        v19 = 0;
      else
        v19 = 99;
      v21 = v19;
      if ( v20[1] == 73 )
      {
        v13 = v20[3];
        v20[1] = 43;
      }
      else
      {
        v13 = v20[3];
        if ( v20[1] == 68 )
          v20[1] = 45;
      }
    }
    else
    {
      v13 = v20[3];
    }
  }
  if ( v13 != 83
    || sscanf(
         v3,
         "%*4c %2c %4d%*c%3d%*4c %2d%c%2d:%2d%c%*2c",
         &v24,
         v2 + 47,
         v2 + 48,
         v2 + 49,
         v20,
         v2 + 50,
         v2 + 51,
         &v20[1]) != 8 )
  {
    v14 = v2[46];
    v15 = v20[0];
    goto LABEL_23;
  }
  v14 = v2[46];
  if ( v24 != 76 )
  {
    if ( v24 != 48 )
    {
      v21 = 99;
      v15 = v20[0];
      goto LABEL_42;
    }
    v15 = v20[0];
    v21 = v25 & 0xF;
LABEL_23:
    if ( v14 == (unsigned __int8 *)&dword_20 )
    {
      switch ( v21 )
      {
        case 0:
          goto LABEL_27;
        case 1:
LABEL_32:
          *((_QWORD *)v2 + 31) = 0x3F947AE147AE147BLL;
          break;
        case 2:
LABEL_34:
          *((_QWORD *)v2 + 31) = 0x3FA47AE147AE147BLL;
          break;
        case 3:
LABEL_33:
          *((_QWORD *)v2 + 31) = 0x3FB47AE147AE147BLL;
          break;
        default:
          goto LABEL_42;
      }
    }
    else
    {
      switch ( v21 )
      {
        case 1:
          *((_QWORD *)v2 + 31) = 0x3FC47AE147AE147BLL;
          break;
        case 2:
          goto LABEL_33;
        case 3:
          goto LABEL_34;
        case 4:
          goto LABEL_32;
        case 5:
          goto LABEL_27;
        default:
          goto LABEL_42;
      }
    }
    goto LABEL_28;
  }
  v21 = 0;
  v15 = v20[0];
  if ( v14 != (unsigned __int8 *)&dword_20 )
  {
LABEL_42:
    *((_QWORD *)v2 + 31) = 0x4030000000000000LL;
    goto LABEL_28;
  }
LABEL_27:
  *((_QWORD *)v2 + 31) = 0x3F60624DD2F1A9FCLL;
LABEL_28:
  if ( v15 == 58 )
  {
    if ( v20[1] == 43 )
    {
      *((_BYTE *)v2 + 40) = 1;
    }
    else
    {
      if ( v20[1] == 45 )
        v18 = 2;
      else
        v18 = 0;
      *((_BYTE *)v2 + 40) = v18;
    }
  }
  else
  {
    *((_BYTE *)v2 + 40) = 3;
  }
  result = (__int16 *)sub_39CF8(v2);
  if ( !result )
    return sub_394A0((__int16 *)v1, 6);
  return result;
}
// 18: using guessed type _UNKNOWN *off_18;
// 20: using guessed type int dword_20;

//----- (0005534C) --------------------------------------------------------
int __fastcall sub_5534C(int a1, int a2)
{
  int v3; // r9
  int v4; // r8
  _DWORD *v5; // r0
  void *v6; // r7
  _DWORD *v7; // r4
  char v9[20]; // [sp+0h] [bp-1Ch] BYREF

  sub_6C054((int)v9, 0x14u, "/dev/wwvb%d", a1);
  v3 = sub_3A298(v9, 0xDu, 1);
  if ( v3 <= 0 )
    return 0;
  v5 = sub_63BA4(0, 0xCu, 0, 0);
  *v5 = 0;
  v6 = v5;
  v5[1] = 0;
  v5[2] = 0;
  v7 = *(_DWORD **)(a2 + 84);
  v7[6] = 0;
  v7[5] = a2;
  v7[7] = v3;
  v7[3] = sub_54F04;
  v4 = sub_18DF0(v7 + 2);
  if ( v4 )
  {
    v4 = 1;
    *v7 = v6;
    *(_BYTE *)(a2 + 95) = -10;
    v7[11] = "Ultralink WWVB Receiver";
    v7[191] = *(_DWORD *)"WWVB";
  }
  else
  {
    close(v3);
    v7[7] = -1;
    free(v6);
  }
  return v4;
}

//----- (00055480) --------------------------------------------------------
int __fastcall sub_55480(int a1, int a2)
{
  _DWORD *v3; // r4
  int v4; // r5
  int v5; // r1
  int v7; // r3

  v3 = *(_DWORD **)(a2 + 84);
  v4 = *v3;
  v5 = *(_DWORD *)(*v3 + 52);
  if ( v5 )
    sub_394A0((__int16 *)a2, v5);
  v7 = v3[194];
  *(_DWORD *)(v4 + 52) = 0;
  v3[194] = v7 + 1;
  return 0;
}

//----- (000554F4) --------------------------------------------------------
void __fastcall sub_554F4(int a1, int a2)
{
  _DWORD **v2; // r0
  _DWORD *v3; // r4
  int v4; // r0

  v2 = *(_DWORD ***)(a2 + 84);
  v3 = *v2;
  if ( *v2 )
  {
    sub_18E64((int)(v2 + 2));
    v4 = v3[12];
    if ( v4 > 0 )
      close(v4);
    free(v3);
  }
}

//----- (00055584) --------------------------------------------------------
int __fastcall sub_55584(int **a1)
{
  int *v1; // r4
  int v2; // r3
  int v3; // r0
  int result; // r0

  v1 = *a1;
  v2 = (*a1)[531];
  v3 = (*a1)[529];
  if ( v2 )
  {
    if ( v2 <= 100 )
      goto LABEL_5;
    v3 -= 4;
    if ( v3 < 0 )
    {
      v3 = 0;
      v1[529] = 0;
      goto LABEL_5;
    }
  }
  else
  {
    v3 += 4;
    if ( v3 > 255 )
      v3 = 255;
  }
  v1[529] = v3;
LABEL_5:
  result = sub_612E0(v3, v1[530], v1[528]);
  v1[531] = 0;
  return result;
}

//----- (00055620) --------------------------------------------------------
int __fastcall sub_55620(char a1, int *a2, int a3)
{
  int v4; // r4
  int v5; // r2
  int result; // r0
  int v7; // r3

  v4 = *a2;
  v5 = *(_DWORD *)(*a2 + 48);
  if ( v5 <= 0 )
    return 0;
  *(_DWORD *)(v4 + 216 * *(_DWORD *)(v4 + 3292) + 2200) = *(_DWORD *)(v4 + 2116);
  result = sub_63DC0(v5, a1 & 0x7F);
  v7 = *(_DWORD *)(v4 + 216 * a3 + 2200);
  *(_DWORD *)(v4 + 3292) = a3;
  *(_DWORD *)(v4 + 2116) = v7;
  return result;
}

//----- (000556C0) --------------------------------------------------------
int __fastcall sub_556C0(int a1)
{
  int v1; // r2
  int *v3; // r7
  __int64 v4; // r0
  int v5; // r4
  double v6; // d7
  int v7; // r3
  double v8; // d6
  bool v9; // nf
  int v10; // lr
  int v11; // r7
  int v13; // r2
  __int64 v14; // r2
  __int64 v15; // r0
  bool v16; // zf

  v1 = 0;
  v3 = *(int **)(a1 + 84);
  v4 = 0;
  v5 = *v3;
  v6 = 0.0;
  v7 = *v3 + 2208;
  do
  {
    v8 = *(double *)(v7 + 176);
    v9 = v8 < v6;
    if ( v8 >= v6 )
      LODWORD(v4) = v7 + 104;
    else
      v8 = v6;
    v6 = *(double *)(v7 + 72);
    if ( !v9 )
      HIDWORD(v4) = v1;
    if ( v8 <= v6 )
      HIDWORD(v4) = v1;
    ++v1;
    if ( v8 > v6 )
      v6 = v8;
    else
      LODWORD(v4) = v7;
    v7 += 216;
  }
  while ( v1 != 5 );
  v10 = *(_DWORD *)(v5 + 4328);
  *(_DWORD *)(v5 + 4328) = v10 & 0xFFFFFCFF;
  if ( v6 >= 13.0 )
  {
    *(_QWORD *)(v5 + 3280) = v4;
    v13 = *(_DWORD *)(v4 + 92);
    v3[191] = v13;
    HIDWORD(v4) = *(_DWORD *)(v4 + 88);
    HIDWORD(v14) = *(_DWORD *)(v5 + 4328);
    *(_DWORD *)(a1 + 112) = v13;
    LODWORD(v14) = HIDWORD(v14) | 0x80;
    *(_DWORD *)(v5 + 4328) = HIDWORD(v14) | 0x80;
    if ( (v4 & 0x10000000000LL) != 0 )
    {
      v15 = *((_QWORD *)v3 + 93);
      *(_DWORD *)(v5 + 4328) = HIDWORD(v14) | 0x180;
      v11 = 1;
      *(_QWORD *)(v5 + 40) = v15;
    }
    else
    {
      v16 = (v4 & 0x20000000000LL) == 0;
      if ( (v4 & 0x20000000000LL) != 0 )
      {
        v4 = *((_QWORD *)v3 + 94);
        HIDWORD(v14) |= 0x280u;
      }
      else
      {
        v14 = 0;
      }
      if ( v16 )
      {
        v11 = 1;
        *(_QWORD *)(v5 + 40) = v14;
      }
      else
      {
        *(_DWORD *)(v5 + 4328) = HIDWORD(v14);
        v11 = 1;
        *(_QWORD *)(v5 + 40) = v4;
      }
    }
  }
  else
  {
    v11 = v10 & 0x80;
    *(_DWORD *)(v5 + 3284) = (*(_DWORD *)(v5 + 3284) + 1) % 5;
    if ( (v10 & 0x80) != 0 )
    {
      *(_DWORD *)(v5 + 4328) = v10 & 0xFFFFFC7F;
      sub_394A0((__int16 *)a1, 4);
      v11 = 0;
    }
  }
  if ( *(int *)(v5 + 48) > 0 )
    sub_55620(*(_DWORD *)(a1 + 76), *(int **)(a1 + 84), *(_DWORD *)(v5 + 3284));
  return v11;
}

//----- (00055870) --------------------------------------------------------
int __fastcall sub_55870(int a1)
{
  int v1; // r5
  int v3; // r4
  double v4; // d8
  int v5; // r3
  double *v6; // r6
  int v7; // r0
  double v8; // r0
  double v9; // d0
  int result; // r0

  v1 = **(_DWORD **)(a1 + 84);
  v3 = v1 + 2300;
  v4 = 2.0;
  if ( *(_DWORD *)(v1 + 4328) )
    *(_DWORD *)(v1 + 52) = 1;
  *(_BYTE *)(a1 + 91) = 3;
  *(_DWORD *)(v1 + 4332) = 0;
  *(_DWORD *)(v1 + 4328) = 0;
  *(_QWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 2116) = 127;
  *(_DWORD *)(v1 + 56) = 0;
  *(_DWORD *)(v1 + 2128) = 8;
  memset((void *)(v1 + 2200), 0, 0x438u);
  v5 = 127;
  v6 = (double *)&unk_99AA8;
  while ( 1 )
  {
    *(_DWORD *)(v3 - 100) = v5;
    *(_DWORD *)(v3 - 4) = 256;
    sub_6C054(v3, 5u, "WV%.0f", v4);
    v7 = v3 + 104;
    *(_DWORD *)(v3 + 100) = 512;
    v3 += 216;
    LODWORD(v8) = sub_6C054(v7, 5u, "WH%.0f", v4);
    if ( v3 == v1 + 3380 )
      break;
    v9 = *v6++;
    floor(v8);
    v5 = *(_DWORD *)(v1 + 2116);
    v4 = v9;
  }
  *(_DWORD *)(v1 + 3284) = 2;
  result = sub_556C0(a1);
  *(_DWORD *)(v1 + 3288) = *(_DWORD *)(v1 + 3284);
  return result;
}
// 55978: variable 'v8' is possibly undefined

//----- (000559D4) --------------------------------------------------------
int __fastcall sub_559D4(int a1, int a2)
{
  int v3; // r9
  int v4; // r8
  char *v5; // r0
  _DWORD *v6; // r6
  char *v7; // r4
  double *v8; // r1
  double v9; // d6
  double *v10; // r2
  int v11; // r3
  double v12; // d7
  int v13; // r0
  int v14; // r0

  v3 = sub_60AC0("/dev/audio", 320, a1);
  if ( v3 < 0 )
    return 0;
  v5 = (char *)sub_63BA4(0, 0x10F8u, 0, 1);
  v6 = *(_DWORD **)(a2 + 84);
  v7 = v5;
  v6[5] = a2;
  v6[7] = v3;
  v6[3] = sub_58E24;
  v6[6] = 0;
  v4 = sub_18DF0(v6 + 2);
  if ( v4 )
  {
    *v6 = v7;
    *(_BYTE *)(a2 + 95) = -10;
    v6[11] = "WWV/H Audio Demodulator/Decoder";
    *((_QWORD *)v7 + 136) = 0;
    *((_QWORD *)v7 + 9) = 0x3FF0000000000000LL;
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 137) = 0xBFF0000000000000LL;
    *((_QWORD *)v7 + 10) = 0x4008000000000000LL;
    *((_QWORD *)v7 + 138) = 0xC008000000000000LL;
    *((_QWORD *)v7 + 11) = 0x4014000000000000LL;
    v8 = (double *)(v7 + 1120);
    *((_QWORD *)v7 + 139) = 0xC014000000000000LL;
    v9 = 2.0;
    v10 = (double *)(v7 + 88);
    v11 = 3;
    while ( ++v11 != 128 )
    {
      v12 = *v10 + v9;
      if ( (v11 & 0xF) == 0 )
        v9 = v9 + v9;
      v10[1] = v12;
      ++v10;
      *v8++ = -v12;
    }
    v13 = *(_DWORD *)(a2 + 76);
    *((_DWORD *)v7 + 3) = 536870;
    *((_DWORD *)v7 + 852) = 6;
    *((_DWORD *)v7 + 908) = 3;
    *((_DWORD *)v7 + 2) = 0;
    *((_DWORD *)v7 + 824) = 10;
    *((_DWORD *)v7 + 880) = 10;
    *((_DWORD *)v7 + 936) = 10;
    *((_DWORD *)v7 + 964) = 10;
    *((_DWORD *)v7 + 1020) = 10;
    *((_DWORD *)v7 + 992) = 4;
    *((_DWORD *)v7 + 1048) = 10;
    if ( v13 )
    {
      if ( (v13 & 0x80) != 0 )
        v14 = sub_63F68((int)"/dev/icom", 9u);
      else
        v14 = sub_63F68((int)"/dev/icom", 0xDu);
      *((_DWORD *)v7 + 12) = v14;
    }
    else
    {
      v14 = *((_DWORD *)v7 + 12);
    }
    if ( v14 > 0 )
    {
      if ( sub_55620(*(_DWORD *)(a2 + 76), *(int **)(a2 + 84), 3) )
      {
        sub_64E00(5, "icom: radio not found");
        close(*((_DWORD *)v7 + 12));
        *((_DWORD *)v7 + 12) = 0;
      }
      else
      {
        sub_64E00(5, "icom: autotune enabled");
      }
    }
    v4 = 1;
    sub_55870(a2);
  }
  else
  {
    close(v3);
    free(v7);
  }
  return v4;
}

//----- (00055C88) --------------------------------------------------------
int __fastcall sub_55C88(double a1, double *a2)
{
  double v2; // d6
  double v3; // r6
  int *v4; // r9
  int v5; // r4
  double v6; // d0
  int v7; // r8
  double *v8; // r2
  double *v9; // lr
  double v10; // d4
  double *v11; // r3
  double v12; // d7
  double v13; // d6
  double v14; // d5
  double v15; // d6
  int v16; // r12
  double v17; // d0
  double v18; // d6
  int v19; // r3
  bool v20; // cc
  int v21; // r3
  int v22; // r2
  char v24[128]; // [sp+3Ch] [bp-88h] BYREF

  v2 = *a2;
  v3 = a1;
  v4 = *(int **)(LODWORD(a1) + 84);
  v5 = *v4;
  if ( *a2 == 0.0 )
  {
    v7 = 0;
    *(_QWORD *)(HIDWORD(a1) + 16) = 0xC0B7700000000000LL;
LABEL_31:
    *(_QWORD *)(HIDWORD(v3) + 24) = 0;
    goto LABEL_12;
  }
  v6 = -6000.0;
  v7 = 0;
  v8 = a2 + 1;
  HIDWORD(a1) = 0;
  v9 = (double *)(HIDWORD(v3) + 32);
  v10 = -6000.0;
  do
  {
    v11 = v8;
    LODWORD(a1) = &unk_BF670;
    v12 = unk_BF668 * v2 + 0.0;
    do
    {
      v13 = *v11++;
      v14 = *(double *)LODWORD(a1);
      LODWORD(a1) += 8;
      v12 = v12 + v14 * v13;
    }
    while ( v8 + 3 != v11 );
    v15 = *v9 + (v12 - *v9) * 0.0625;
    *v9++ = v15;
    if ( v15 > v10 )
    {
      v6 = v10;
      v7 = HIDWORD(a1);
      v10 = v15;
    }
    else if ( v15 > v6 )
    {
      v6 = v15;
    }
    v8 += 4;
    v2 = *(v8 - 1);
    ++HIDWORD(a1);
  }
  while ( v2 != 0.0 );
  *(double *)(HIDWORD(v3) + 16) = v10;
  if ( v10 <= 0.0 )
    goto LABEL_31;
  if ( v6 > 0.0 )
  {
    a1 = log10(a1);
    v17 = v10 / v6 * 20.0;
    if ( v17 <= 40.0 )
    {
      v18 = *(double *)(HIDWORD(v3) + 16);
      *(double *)(HIDWORD(v3) + 24) = v17;
      if ( v18 < 1000.0 || v17 < 3.0 )
        goto LABEL_12;
      goto LABEL_22;
    }
    v10 = *(double *)(HIDWORD(v3) + 16);
  }
  *(_QWORD *)(HIDWORD(v3) + 24) = 0x4044000000000000LL;
  if ( v10 < 1000.0 )
  {
LABEL_12:
    *(_DWORD *)(v5 + 4328) |= 0x40u;
    goto LABEL_13;
  }
LABEL_22:
  if ( *(_DWORD *)(HIDWORD(v3) + 4) == v7 )
  {
    v21 = *(_DWORD *)(HIDWORD(v3) + 8);
    if ( v21 <= 2 )
      *(_DWORD *)(HIDWORD(v3) + 8) = ++v21;
    if ( v21 == 3 )
    {
      v22 = *(_DWORD *)(v5 + 4308) + 1;
      *(_DWORD *)(v5 + 4328) |= 4u;
      *(_DWORD *)(v5 + 4308) = v22;
    }
  }
  else
  {
    v19 = *(_DWORD *)(HIDWORD(v3) + 8);
    v20 = v19 <= 0;
    if ( v19 > 0 )
      --v19;
    *(_DWORD *)(v5 + 4332) |= 1u;
    if ( !v20 )
      *(_DWORD *)(HIDWORD(v3) + 8) = v19;
    if ( !v19 )
      *(_DWORD *)(HIDWORD(v3) + 4) = v7;
  }
LABEL_13:
  if ( (v4[192] & 8) != 0 )
  {
    v16 = *(_DWORD *)(v5 + 4328);
    if ( (v16 & 8) == 0 )
    {
      sub_6C054(
        (int)v24,
        0x80u,
        "wwv4 %2d %04x %3d %4d %5.0f %2d %d %d %d %5.0f %5.1f",
        *(_DWORD *)(v5 + 4304) - 1,
        v16,
        *(_DWORD *)(v5 + 2116),
        *(_DWORD *)(v5 + 2132),
        *(double *)(v5 + 2144),
        *(_DWORD *)HIDWORD(v3),
        *(_DWORD *)(HIDWORD(v3) + 4),
        v7,
        *(_DWORD *)(HIDWORD(v3) + 8),
        *(double *)(HIDWORD(v3) + 16),
        *(double *)(HIDWORD(v3) + 24));
      LODWORD(a1) = sub_41F44((unsigned __int16 *)(LODWORD(v3) + 16), v24);
    }
  }
  return LODWORD(a1);
}

//----- (00055F80) --------------------------------------------------------
int __fastcall sub_55F80(double a1, int a2)
{
  int v2; // r4
  _BYTE *v3; // r8
  int v4; // r6
  double v5; // d6
  int *v6; // r7
  double v7; // d7
  int v8; // r5
  bool v9; // fzf
  bool v10; // fnf
  int v11; // r2
  double v12; // d6
  int v13; // r3
  double v14; // d7
  double v15; // d6
  double v16; // d0
  double v17; // d0
  int v18; // r3
  int v19; // r2
  double v20; // d5
  double v21; // d7
  char v23[128]; // [sp+34h] [bp-88h] BYREF
  int v24; // [sp+B4h] [bp-8h]

  v2 = HIDWORD(a1);
  v3 = *(_BYTE **)(LODWORD(a1) + 84);
  v4 = LODWORD(a1);
  v5 = *(double *)(HIDWORD(a1) + 8);
  v6 = *(int **)v3;
  v7 = *(double *)(HIDWORD(a1) + 40);
  v8 = *(_DWORD *)(*(_DWORD *)v3 + 2196);
  v9 = v7 == v5;
  v10 = v7 < v5;
  v11 = v8 - a2;
  v12 = *(double *)(HIDWORD(a1) + 16);
  v13 = v11 - 6400;
  if ( v11 - 6400 < 0 )
    v13 = v11 + 473600;
  HIDWORD(a1) = _stack_chk_guard;
  if ( !v10 && !v9 )
    *(double *)(v2 + 8) = v7;
  v14 = v7 + v12;
  if ( !v10 && !v9 )
    *(_DWORD *)(v2 + 24) = v13;
  v24 = HIDWORD(a1);
  *(double *)(v2 + 16) = v14;
  if ( !v8 )
  {
    v15 = *(double *)(v2 + 8);
    *(double *)(v2 + 56) = v15;
    if ( v15 <= 0.0 )
    {
      v17 = 0.0;
    }
    else
    {
      v16 = (v14 - v15) / 480000.0;
      if ( v16 > 0.0 )
      {
        log10(a1);
        v17 = v15 / v16 * 20.0;
        v15 = *(double *)(v2 + 56);
        if ( v17 > 40.0 )
          v17 = 40.0;
      }
      else
      {
        v17 = 40.0;
      }
    }
    LODWORD(a1) = *(_DWORD *)(v2 + 84);
    HIDWORD(a1) = *(_DWORD *)(v2 + 24);
    *(double *)(v2 + 64) = v17;
    if ( LODWORD(a1) )
      v8 = (HIDWORD(a1) - *(_DWORD *)(v2 + 28)) % 480000;
    else
      *(_DWORD *)(v2 + 28) = HIDWORD(a1);
    v18 = 2 * *(_DWORD *)(v2 + 80);
    *(_DWORD *)(v2 + 80) = v18;
    if ( (v18 & 0x40) != 0 )
      *(_DWORD *)(v2 + 84) = --LODWORD(a1);
    if ( v15 > 2500.0 && v17 > 20.0 )
    {
      LODWORD(a1) = v8 + 159;
      v19 = *(_DWORD *)(v2 + 84);
      if ( (unsigned int)(v8 + 159) > 0x13E )
      {
        if ( v19 == 1 )
          *(_DWORD *)(v2 + 28) = HIDWORD(a1);
      }
      else
      {
        *(_DWORD *)(v2 + 80) = v18 | 1;
        *(_DWORD *)(v2 + 84) = v19 + 1;
        *(_DWORD *)(v2 + 28) = HIDWORD(a1);
        *(_DWORD *)(v2 + 32) = HIDWORD(a1);
      }
    }
    if ( v6[14] <= 6 )
    {
      v20 = 6000.0;
      v21 = (double)*(int *)(v2 + 84) * 6000.0;
      if ( v15 < 6000.0 )
        v21 = v21 + v15;
      else
        v20 = 5999.0;
      if ( v15 >= 6000.0 )
        v21 = v21 + v20;
      *(double *)(v2 + 72) = v21 / 42000.0 * 100.0;
      if ( (v3[768] & 8) == 0 )
        goto LABEL_23;
    }
    else
    {
      *(_QWORD *)(v2 + 72) = 0;
      if ( (v3[768] & 8) == 0 )
      {
LABEL_23:
        *(_QWORD *)(v2 + 16) = 0;
        *(_QWORD *)(v2 + 8) = 0;
        return LODWORD(a1);
      }
    }
    sub_6C054(
      (int)v23,
      0x80u,
      "wwv8 %04x %3d %s %04x %.0f %.0f/%.1f %ld %ld",
      v6[1082],
      v6[529],
      (const char *)(v2 + 92),
      *(unsigned __int16 *)(v2 + 80),
      *(double *)(v2 + 72),
      v15,
      v17,
      SHIDWORD(a1) % 8000,
      v8);
    LODWORD(a1) = sub_41F44((unsigned __int16 *)(v4 + 16), v23);
    goto LABEL_23;
  }
  return LODWORD(a1);
}

//----- (00056264) --------------------------------------------------------
int __fastcall sub_56264(double a1)
{
  double v1; // d0
  int *v2; // r4
  double v3; // d8
  int v4; // r6
  int v5; // r11
  double *v6; // r3
  double v7; // d7
  unsigned int v8; // r2
  int v9; // r9
  int v10; // r7
  int v11; // r3
  double v12; // d7
  double v13; // d0
  double v14; // d0
  int v15; // r3
  int v16; // r2
  int v17; // r2
  double v18; // d6
  int v19; // r3
  int v20; // s15
  int v21; // r3
  double v22; // d7
  double *v23; // r3
  double v24; // d0
  int v25; // r3
  int v26; // r1
  double *v27; // r0
  int v28; // r2
  double v29; // d6
  int v30; // r3
  int v31; // r2
  int v32; // r7
  int v33; // r1
  double v34; // d6
  int v35; // r2
  int v36; // r12
  char v37; // r2
  double v38; // r0
  int v39; // r3
  bool v40; // zf
  int v41; // r9
  double **v42; // r3
  double v43; // r0
  int v44; // r3
  int v45; // r2
  bool v46; // zf
  int v47; // r9
  int v48; // r2
  int v49; // r3
  int v50; // r2
  int v51; // r10
  int v52; // r3
  int v53; // r9
  int v54; // r1
  int v55; // s14
  int v56; // r3
  __int64 v57; // d6
  int v58; // lr
  int v59; // r3
  int v60; // r1
  int v61; // r3
  int v62; // lr
  int v63; // r3
  int v64; // r7
  int v65; // r2
  int v66; // r3
  char v67; // r0
  int v68; // r7
  int v69; // r12
  int v70; // r9
  int v71; // r3
  int v72; // r12
  int v73; // r3
  int v74; // r3
  bool v75; // zf
  int v76; // r9
  int v77; // r2
  bool v78; // zf
  int v79; // r9
  int v80; // r2
  int v81; // lr
  int v82; // r3
  int v83; // r1
  int v84; // s13
  int v85; // r3
  __int64 v86; // t1
  int v87; // r2
  int v88; // r12
  int v89; // r3
  int v90; // r0
  int v91; // s13
  int v92; // r3
  __int64 v93; // d7
  int v94; // r3
  int v95; // r2
  double v96; // d7
  int v97; // r2
  int v98; // r3
  __int64 v99; // t1
  int v100; // r3
  int v101; // r1
  int v102; // r3
  int v103; // r3
  int v104; // r12
  int v105; // r0
  int v106; // r7
  int v107; // r3
  int v108; // r2
  unsigned int v109; // r9
  int v110; // r0
  int *v111; // r1
  int v112; // lr
  int v113; // r0
  double v114; // d7
  int v115; // s13
  int v116; // r2
  int v117; // r3
  __int64 v118; // d7
  int v119; // r7
  int v120; // r0
  double v121; // d7
  int v122; // s13
  int v123; // r2
  int v124; // r3
  __int64 v125; // d7
  int v126; // lr
  int v127; // r12
  int v128; // s13
  int v129; // r1
  int v130; // r3
  __int64 v131; // d7
  int v132; // r1
  int v133; // r9
  int v134; // r3
  int v135; // r3
  int v136; // r3
  double v137; // d0
  int v138; // r0
  int v139; // r1
  int v140; // r7
  int v141; // r3
  int v142; // r0
  int v143; // s13
  int v144; // r3
  __int64 v145; // d7
  int v146; // r3
  int v147; // r1
  double v148; // d7
  int v149; // r1
  int v150; // s13
  int v151; // r3
  __int64 v152; // d7
  double v153; // d7
  int v154; // r7
  int v155; // r4
  double v156; // d7
  int v157; // s13
  int v158; // r0
  int v159; // r3
  __int64 v160; // d7
  int v161; // r12
  int v162; // r0
  double v163; // d7
  int v164; // s13
  int v165; // r2
  int v166; // r3
  __int64 v167; // d7
  int v168; // r0
  int v169; // r1
  double v170; // d7
  int v171; // s14
  int v172; // r2
  int v173; // r3
  __int64 v174; // d6
  int v175; // r3
  int v176; // r1
  int v177; // r2
  int v178; // r7
  int v179; // s14
  int v180; // r3
  __int64 v181; // t1
  double v182; // d7
  int v183; // r2
  int v184; // r3
  int v185; // r7
  bool v186; // zf
  int v187; // r2
  int v188; // s14
  int v189; // r3
  __int64 v190; // t1
  double v191; // d7
  int v193; // [sp+70h] [bp-CCh]
  int v194; // [sp+78h] [bp-C4h]
  int v195; // [sp+78h] [bp-C4h]
  int v196; // [sp+7Ch] [bp-C0h]
  int v197; // [sp+80h] [bp-BCh]
  int v198; // [sp+80h] [bp-BCh]
  int v199; // [sp+84h] [bp-B8h]
  int v200; // [sp+88h] [bp-B4h]
  int v201; // [sp+88h] [bp-B4h]
  unsigned int v202; // [sp+8Ch] [bp-B0h]
  int v203; // [sp+8Ch] [bp-B0h]
  int v204; // [sp+90h] [bp-ACh]
  int v205; // [sp+94h] [bp-A8h]
  int v206; // [sp+98h] [bp-A4h]
  int *v207; // [sp+98h] [bp-A4h]
  int v208; // [sp+9Ch] [bp-A0h]
  int v209; // [sp+A4h] [bp-98h]
  int v210; // [sp+ACh] [bp-90h] BYREF
  unsigned int v211; // [sp+B0h] [bp-8Ch]
  char v212[128]; // [sp+B4h] [bp-88h] BYREF

  v193 = LODWORD(a1);
  v2 = *(int **)(LODWORD(a1) + 84);
  v3 = v1;
  v4 = *v2;
  if ( !dword_BF688 )
  {
    dword_BF688 = 1;
    LODWORD(a1) = memset(&unk_BF690, 0, 0x1E8u);
  }
  v5 = *(_DWORD *)(v4 + 4304);
  HIDWORD(a1) = v5 + 1;
  *(_DWORD *)(v4 + 4304) = v5 + 1;
  v6 = (double *)((char *)&unk_BF668 + 8 * v5);
  v7 = v6[5] + (v1 - v6[5]) * 0.0625;
  v6[5] = v7;
  v8 = (unsigned int)&progx + 8 * v5;
  v9 = *(_DWORD *)(v8 + 4);
  switch ( *(_DWORD *)v8 )
  {
    case 1:
      v36 = *(_DWORD *)(v4 + 4328);
      if ( (v36 & 4) != 0 )
      {
        *((double *)&unk_BF668 + v9) = v1;
        goto LABEL_33;
      }
      LODWORD(a1) = 0;
      v37 = *((_BYTE *)v2 + 768);
      *((_QWORD *)&unk_BF668 + v9) = 0;
      if ( (v37 & 8) == 0 )
        goto LABEL_33;
      goto LABEL_36;
    case 2:
      *((double *)&unk_BF668 + v9) = v1;
      goto LABEL_31;
    case 3:
      LODWORD(a1) = 0;
      *((_QWORD *)&unk_BF668 + v9) = 0;
      goto LABEL_31;
    case 4:
      v42 = (double **)&bcd9_ptr;
      goto LABEL_47;
    case 5:
      v42 = (double **)&bcd6_ptr;
      goto LABEL_47;
    case 6:
      v42 = (double **)&bcd3_ptr;
      goto LABEL_47;
    case 7:
      v42 = (double **)&bcd2_ptr;
LABEL_47:
      LODWORD(v43) = v193;
      HIDWORD(v43) = v4 + 112 * v9 + 3296;
      LODWORD(a1) = sub_55C88(v43, *v42);
      if ( (v2[192] & 8) == 0 )
        goto LABEL_33;
      goto LABEL_32;
    case 8:
      goto LABEL_38;
    case 9:
      HIDWORD(v38) = v4 + 4192;
      LODWORD(v38) = v193;
      LODWORD(a1) = sub_55C88(v38, bcd9);
      v7 = *((double *)&unk_BF668 + v5 + 5);
LABEL_38:
      if ( v7 <= 1000.0 )
      {
        if ( v7 >= -1000.0 )
        {
          *(_DWORD *)(v4 + 4328) |= 0x40u;
        }
        else
        {
          v74 = *(_DWORD *)(v4 + 4336);
          v75 = (v74 & v9) == 0;
          v76 = v74 & ~v9;
          if ( !v75 )
            v8 = *(_DWORD *)(v4 + 4332);
          *(_DWORD *)(v4 + 4336) = v76;
          if ( !v75 )
            *(_DWORD *)(v4 + 4332) = v8 | 1;
        }
      }
      else
      {
        v39 = *(_DWORD *)(v4 + 4336);
        v40 = (v39 & v9) == 0;
        v41 = v39 | v9;
        if ( v40 )
          v8 = *(_DWORD *)(v4 + 4332);
        *(_DWORD *)(v4 + 4336) = v41;
        if ( v40 )
          *(_DWORD *)(v4 + 4332) = v8 | 1;
      }
      goto LABEL_31;
    case 0xA:
      v44 = *(_DWORD *)(v4 + 4328);
      if ( v7 > 1000.0 )
      {
        v77 = *(_DWORD *)(v4 + 4336);
        v78 = (v77 & v9) == 0;
        v79 = v77 | v9;
        if ( v78 )
          HIDWORD(a1) = *(_DWORD *)(v4 + 4332);
        *(_DWORD *)(v4 + 4336) = v79;
        if ( v78 )
          *(_DWORD *)(v4 + 4332) = HIDWORD(a1) | 1;
      }
      else if ( v7 < -1000.0 )
      {
        v45 = *(_DWORD *)(v4 + 4336);
        v46 = (v45 & v9) == 0;
        v47 = v45 & ~v9;
        if ( !v46 )
          HIDWORD(a1) = *(_DWORD *)(v4 + 4332);
        *(_DWORD *)(v4 + 4336) = v47;
        if ( !v46 )
          *(_DWORD *)(v4 + 4332) = HIDWORD(a1) | 1;
      }
      else
      {
        v44 |= 0x40u;
      }
      v48 = *(_DWORD *)(v4 + 48);
      *(_DWORD *)(v4 + 4328) = v44 & 0xFFFFFCFF;
      if ( v48 > 0 )
      {
        v110 = *(_DWORD *)(v4 + 3288) + 1;
        v111 = *(int **)(v193 + 84);
        *(_DWORD *)(v4 + 3288) = v110 % 5;
        LODWORD(a1) = sub_55620(*(_DWORD *)(v193 + 76), v111, v110 % 5);
      }
      else
      {
        *(_DWORD *)(v4 + 216 * *(_DWORD *)(v4 + 3292) + 2200) = *(_DWORD *)(v4 + 2116);
      }
      goto LABEL_31;
    case 0xB:
      v49 = *(_DWORD *)(v4 + 4328);
      if ( (v49 & 0x1000) == 0 )
        goto LABEL_64;
      goto LABEL_31;
    case 0xC:
      v49 = *(_DWORD *)(v4 + 4328);
LABEL_64:
      v50 = *(_DWORD *)(v193 + 84);
      *(_DWORD *)(v4 + 4328) = v49 & 0xFFFFEFFF;
      v51 = *(_DWORD *)v50;
      v196 = v50;
      v52 = *(_DWORD *)(*(_DWORD *)v50 + 3296);
      v53 = *(_DWORD *)(*(_DWORD *)v50 + 3300) + 1;
      *(_DWORD *)(*(_DWORD *)v50 + 3300) = v53;
      if ( v53 == v52 )
        v50 = 0;
      v54 = v52 - 1;
      if ( v53 == v52 )
      {
        v53 = v50;
        *(_DWORD *)(v51 + 3300) = v50;
      }
      v55 = (int)*(double *)(v51 + 3296 + 8 * v52 + 24);
      if ( v54 > 0 )
      {
        v56 = v51 + 8 * v52 + 3320;
        do
        {
          v57 = *(_QWORD *)(v56 - 8);
          v56 -= 8;
          --v54;
          *(_QWORD *)(v56 + 8) = v57;
        }
        while ( v54 );
      }
      v206 = *(_DWORD *)(v51 + 3860);
      v40 = (*(_DWORD *)(v51 + 4328) & 4) == 0;
      v200 = *(_DWORD *)(v51 + 4328);
      v58 = *(_DWORD *)(v51 + 4084);
      v205 = *(_DWORD *)(v51 + 3748);
      v208 = *(_DWORD *)(v51 + 3972);
      v194 = v205 + 10 * v206 + 100 * v208;
      v59 = *(_DWORD *)(v51 + 4336) & 0x40;
      v202 = *(_DWORD *)(v51 + 4336);
      v204 = v58;
      *(double *)(v51 + 3328) = (double)v55;
      v197 = v59;
      if ( v40 )
      {
        v60 = *(_DWORD *)(v51 + 3636);
        v100 = v53 + 10 * *(_DWORD *)(v51 + 3412);
        v53 = *(_DWORD *)(v51 + 3524);
        v199 = v100;
        v64 = v58 + 10 * *(_DWORD *)(v51 + 4196);
        goto LABEL_83;
      }
      if ( v53 )
      {
        v60 = *(_DWORD *)(v51 + 3636);
        v61 = v53 + 10 * *(_DWORD *)(v51 + 3412);
        v53 = *(_DWORD *)(v51 + 3524);
        v199 = v61;
        v62 = v61 + 60 * v53 + 600 * v60;
        goto LABEL_74;
      }
      v80 = *(_DWORD *)(v51 + 3412);
      v81 = v51 + 3408;
      v82 = *(_DWORD *)(v51 + 3408);
      v83 = v80 + 1;
      *(_DWORD *)(v51 + 3412) = v80 + 1;
      if ( v80 + 1 == v82 )
      {
        *(_DWORD *)(v51 + 3412) = 0;
        v84 = (int)*(double *)(v81 + 8 * v80 + 32);
        if ( v80 <= 0 )
        {
          v199 = 0;
          *(double *)(v51 + 3440) = (double)v84;
          goto LABEL_116;
        }
        v199 = 0;
        v83 = 0;
      }
      else
      {
        v80 = v82 - 1;
        v199 = 10 * v83;
        v84 = (int)*(double *)(v81 + 8 * v82 + 24);
        if ( v82 - 1 <= 0 )
          goto LABEL_115;
      }
      v85 = v51 + 8 * v82 + 3432;
      do
      {
        v86 = *(_QWORD *)(v85 - 8);
        v85 -= 8;
        --v80;
        *(_QWORD *)(v85 + 8) = v86;
      }
      while ( v80 );
LABEL_115:
      *(double *)(v51 + 3440) = (double)v84;
      if ( v83 )
      {
        v53 = *(_DWORD *)(v51 + 3524);
        v60 = *(_DWORD *)(v51 + 3636);
        v62 = v199 + 60 * v53 + 600 * v60;
        goto LABEL_74;
      }
LABEL_116:
      v87 = *(_DWORD *)(v51 + 3524);
      v88 = v51 + 3520;
      v89 = *(_DWORD *)(v51 + 3520);
      v90 = v87 + 1;
      *(_DWORD *)(v51 + 3524) = v87 + 1;
      if ( v87 + 1 == v89 )
      {
        v90 = 0;
        v153 = *(double *)(v88 + 8 * v87 + 32);
        *(_DWORD *)(v51 + 3524) = 0;
        v91 = (int)v153;
        if ( v87 <= 0 )
        {
          v62 = v199;
          *(double *)(v51 + 3552) = (double)v91;
          goto LABEL_121;
        }
        v62 = v199;
      }
      else
      {
        v87 = v89 - 1;
        v91 = (int)*(double *)(v88 + 8 * v89 + 24);
        v62 = v199 + 60 * v90;
        if ( v89 - 1 <= 0 )
          goto LABEL_120;
      }
      v92 = v51 + 8 * v89 + 3544;
      do
      {
        v93 = *(_QWORD *)(v92 - 8);
        v92 -= 8;
        --v87;
        *(_QWORD *)(v92 + 8) = v93;
      }
      while ( v87 );
LABEL_120:
      *(double *)(v51 + 3552) = (double)v91;
      if ( v90 )
      {
        v60 = *(_DWORD *)(v51 + 3636);
        v53 = v90;
        v62 += 600 * v60;
        goto LABEL_74;
      }
LABEL_121:
      v94 = *(_DWORD *)(v51 + 3632);
      v60 = *(_DWORD *)(v51 + 3636) + 1;
      *(_DWORD *)(v51 + 3636) = v60;
      if ( v60 == v94 )
        v95 = 0;
      else
        v95 = 600;
      v96 = *(double *)(v51 + 3632 + 8 * v94 + 24);
      if ( v60 == v94 )
      {
        *(_DWORD *)(v51 + 3636) = v95;
        v60 = v95;
      }
      else
      {
        v62 += v95 * v60;
      }
      v97 = v94 - 1;
      if ( v94 - 1 > 0 )
      {
        v98 = v51 + 8 * v94 + 3656;
        do
        {
          v99 = *(_QWORD *)(v98 - 8);
          v98 -= 8;
          --v97;
          *(_QWORD *)(v98 + 8) = v99;
        }
        while ( v97 );
      }
      *(double *)(v51 + 3664) = (double)(int)v96;
LABEL_74:
      if ( !v197 || (v200 & 8) == 0 )
        goto LABEL_81;
      if ( (v204 & 3) != 0 )
      {
        if ( v194 == 182 )
          goto LABEL_209;
        v63 = 365;
      }
      else
      {
        if ( v194 == 183 )
          goto LABEL_209;
        v63 = 366;
      }
      if ( v63 != v194 )
        goto LABEL_81;
LABEL_209:
      if ( v62 == 1439 )
      {
        v154 = *(_DWORD *)(v51 + 4196);
        *(_DWORD *)(v51 + 4328) = v200 | 0x1000;
        v200 |= 0x1000u;
        v64 = v204 + 10 * v154;
        goto LABEL_83;
      }
LABEL_81:
      if ( v62 != 1440 )
      {
        v64 = v204 + 10 * *(_DWORD *)(v51 + 4196);
        goto LABEL_83;
      }
      v112 = *(_DWORD *)(v51 + 3520);
      v113 = v112 - 1;
      while ( 2 )
      {
        ++v53;
        v114 = *(double *)(v51 + 3520 + 8 * (v112 + 3));
        if ( v53 != v112 )
        {
          v115 = (int)v114;
          if ( v113 <= 0 )
            goto LABEL_157;
          goto LABEL_155;
        }
        v115 = (int)v114;
        if ( v113 > 0 )
        {
          v53 = 0;
LABEL_155:
          v116 = v51 + 8 * v112 + 3544;
          v117 = v112 - 1;
          do
          {
            v118 = *(_QWORD *)(v116 - 8);
            v116 -= 8;
            --v117;
            *(_QWORD *)(v116 + 8) = v118;
          }
          while ( v117 );
LABEL_157:
          *(double *)(v51 + 3552) = (double)v115;
          if ( !v53 )
            goto LABEL_158;
          continue;
        }
        break;
      }
      *(double *)(v51 + 3552) = (double)v115;
LABEL_158:
      v119 = *(_DWORD *)(v51 + 3632);
      *(_DWORD *)(v51 + 3524) = 0;
      v120 = v119 - 1;
      while ( 2 )
      {
        ++v60;
        v121 = *(double *)(v51 + 3632 + 8 * (v119 + 3));
        if ( v60 != v119 )
        {
          v122 = (int)v121;
          if ( v120 <= 0 )
            goto LABEL_163;
          goto LABEL_161;
        }
        v122 = (int)v121;
        if ( v120 > 0 )
        {
          v60 = 0;
LABEL_161:
          v123 = v51 + 8 * v119 + 3656;
          v124 = v119 - 1;
          do
          {
            v125 = *(_QWORD *)(v123 - 8);
            v123 -= 8;
            --v124;
            *(_QWORD *)(v123 + 8) = v125;
          }
          while ( v124 );
LABEL_163:
          *(double *)(v51 + 3664) = (double)v122;
          if ( !v60 )
            goto LABEL_164;
          continue;
        }
        break;
      }
      *(double *)(v51 + 3664) = (double)v122;
LABEL_164:
      v126 = *(_DWORD *)(v51 + 3744);
      v209 = v194 + 1;
      v127 = v126 - 1;
      v195 = v205 + 1;
      *(_DWORD *)(v51 + 3748) = v205 + 1;
      if ( v205 + 1 == v126 )
        *(_DWORD *)(v51 + 3748) = 0;
      *(_DWORD *)(v51 + 3636) = 0;
      if ( v205 + 1 == v126 )
        v195 = 0;
      v128 = (int)*(double *)(v51 + 8 * v126 + 3768);
      if ( v127 > 0 )
      {
        v129 = v126 - 1;
        v130 = v51 + 8 * v126 + 3768;
        do
        {
          v131 = *(_QWORD *)(v130 - 8);
          v130 -= 8;
          --v129;
          *(_QWORD *)(v130 + 8) = v131;
        }
        while ( v129 );
      }
      *(double *)(v51 + 3776) = (double)v128;
      if ( v195 )
      {
        v132 = *(_DWORD *)(v51 + 3860);
        v133 = *(_DWORD *)(v51 + 3972);
        goto LABEL_173;
      }
      v140 = v51 + 3856;
      v141 = *(_DWORD *)(v51 + 3856);
      v132 = v206 + 1;
      *(_DWORD *)(v51 + 3860) = v206 + 1;
      if ( v206 + 1 == v141 )
      {
        v142 = v206;
        v133 = 0;
        v132 = v140 + 8 * v206;
        *(_DWORD *)(v51 + 3860) = 0;
        v191 = *(double *)(v132 + 32);
        if ( v206 > 0 )
          v132 = 0;
        v143 = (int)v191;
        if ( v206 > 0 )
        {
LABEL_190:
          v144 = v51 + 8 * v141 + 3880;
          do
          {
            v145 = *(_QWORD *)(v144 - 8);
            v144 -= 8;
            --v142;
            *(_QWORD *)(v144 + 8) = v145;
          }
          while ( v142 );
          goto LABEL_192;
        }
        *(double *)(v51 + 3888) = (double)v143;
LABEL_195:
        v146 = *(_DWORD *)(v51 + 3968);
        v147 = v208;
        v133 = v208 + 1;
        *(_DWORD *)(v51 + 3972) = v208 + 1;
        if ( v208 + 1 == v146 )
          v147 = 0;
        v148 = *(double *)(v51 + 3968 + 8 * v146 + 24);
        if ( v208 + 1 == v146 )
        {
          v133 = v147;
          *(_DWORD *)(v51 + 3972) = v147;
        }
        v149 = v146 - 1;
        v150 = (int)v148;
        if ( v146 - 1 > 0 )
        {
          v151 = v51 + 8 * v146 + 3992;
          do
          {
            v152 = *(_QWORD *)(v151 - 8);
            v151 -= 8;
            --v149;
            *(_QWORD *)(v151 + 8) = v152;
          }
          while ( v149 );
        }
        v132 = 0;
        *(double *)(v51 + 4000) = (double)v150;
      }
      else
      {
        v133 = v140 + 8 * v141;
        v142 = v141 - 1;
        v143 = (int)*(double *)(v133 + 24);
        if ( v141 - 1 > 0 )
          goto LABEL_190;
LABEL_192:
        if ( v132 )
          v133 = *(_DWORD *)(v51 + 3972);
        *(double *)(v51 + 3888) = (double)v143;
        if ( !v132 )
          goto LABEL_195;
      }
LABEL_173:
      v134 = 366;
      if ( (v204 & 3) != 0 )
        v134 = 365;
      if ( v209 != v134 )
      {
        v135 = v195 + 10 * v132;
        v60 = 0;
        v136 = v135 + 100 * v133;
        v53 = 0;
        v194 = v136;
        v64 = v204 + 10 * *(_DWORD *)(v51 + 4196);
        goto LABEL_83;
      }
      v207 = v2;
      v155 = v195;
      while ( 2 )
      {
        while ( 1 )
        {
          ++v155;
          v156 = *(double *)(v51 + 8 * v126 + 3768);
          if ( v126 != v155 )
            break;
          v157 = (int)v156;
          if ( v127 > 0 )
          {
            v155 = 0;
            goto LABEL_214;
          }
          v155 = 0;
          *(double *)(v51 + 3776) = (double)v157;
        }
        v157 = (int)v156;
        if ( v127 <= 0 )
          goto LABEL_216;
LABEL_214:
        v158 = v51 + 8 * v126 + 3768;
        v159 = v126 - 1;
        do
        {
          v160 = *(_QWORD *)(v158 - 8);
          v158 -= 8;
          --v159;
          *(_QWORD *)(v158 + 8) = v160;
        }
        while ( v159 );
LABEL_216:
        *(double *)(v51 + 3776) = (double)v157;
        if ( v155 != 1 )
          continue;
        break;
      }
      v161 = *(_DWORD *)(v51 + 3856);
      *(_DWORD *)(v51 + 3748) = 1;
      v194 = 1;
      v162 = v161 - 1;
      while ( 2 )
      {
        ++v132;
        v163 = *(double *)(v51 + 3856 + 8 * (v161 + 3));
        if ( v132 != v161 )
        {
          v164 = (int)v163;
          if ( v162 > 0 )
          {
LABEL_220:
            v165 = v51 + 8 * v161 + 3880;
            v166 = v161 - 1;
            do
            {
              v167 = *(_QWORD *)(v165 - 8);
              v165 -= 8;
              --v166;
              *(_QWORD *)(v165 + 8) = v167;
            }
            while ( v166 );
          }
          *(double *)(v51 + 3888) = (double)v164;
          if ( !v132 )
          {
            v2 = v207;
            goto LABEL_224;
          }
          continue;
        }
        break;
      }
      v164 = (int)v163;
      if ( v162 > 0 )
      {
        v132 = 0;
        goto LABEL_220;
      }
      v2 = v207;
      *(double *)(v51 + 3888) = (double)v164;
LABEL_224:
      v168 = *(_DWORD *)(v51 + 3968);
      *(_DWORD *)(v51 + 3860) = 0;
      v169 = v168 - 1;
      while ( 2 )
      {
        ++v133;
        v170 = *(double *)(v51 + 3968 + 8 * (v168 + 3));
        if ( v133 != v168 )
        {
          v171 = (int)v170;
          if ( v169 > 0 )
          {
LABEL_227:
            v172 = v51 + 8 * v168 + 3992;
            v173 = v168 - 1;
            do
            {
              v174 = *(_QWORD *)(v172 - 8);
              v172 -= 8;
              --v173;
              *(_QWORD *)(v172 + 8) = v174;
            }
            while ( v173 );
          }
          *(double *)(v51 + 4000) = (double)v171;
          if ( !v133 )
            goto LABEL_230;
          continue;
        }
        break;
      }
      v171 = (int)v170;
      if ( v169 > 0 )
      {
        v133 = 0;
        goto LABEL_227;
      }
      *(double *)(v51 + 4000) = (double)v171;
LABEL_230:
      v175 = *(_DWORD *)(v51 + 4080);
      v176 = v51 + 4080;
      *(_DWORD *)(v51 + 3972) = 0;
      v177 = v204 + 1;
      *(_DWORD *)(v51 + 4084) = v204 + 1;
      if ( v204 + 1 == v175 )
      {
        v178 = v204;
        *(_DWORD *)(v51 + 4084) = 0;
        v177 = v176 + 8 * v204;
        v182 = *(double *)(v177 + 32);
        if ( v204 > 0 )
          v177 = 0;
        v179 = (int)v182;
        if ( v204 > 0 )
        {
LABEL_232:
          v180 = v51 + 8 * v175 + 4104;
          do
          {
            v181 = *(_QWORD *)(v180 - 8);
            v180 -= 8;
            --v178;
            *(_QWORD *)(v180 + 8) = v181;
          }
          while ( v178 );
          v176 = v51 + 4080;
          goto LABEL_235;
        }
        *(double *)(v51 + 4112) = (double)v179;
      }
      else
      {
        v178 = v175 - 1;
        v179 = (int)*(double *)(v176 + 8 * v175 + 24);
        if ( v175 - 1 > 0 )
          goto LABEL_232;
LABEL_235:
        *(double *)(v176 + 32) = (double)v179;
        if ( v177 )
        {
          v60 = 0;
          v53 = 0;
          v64 = v177 + 10 * *(_DWORD *)(v51 + 4196);
          goto LABEL_83;
        }
      }
      v183 = v51 + 4096;
      v184 = *(_DWORD *)(v51 + 4192);
      v185 = *(_DWORD *)(v51 + 4196) + 1;
      v186 = v185 == v184;
      *(_DWORD *)(v51 + 4196) = v185;
      if ( v185 == v184 )
      {
        v176 = v51 + 4096;
        v183 = 0;
        v64 = 0;
      }
      else
      {
        v64 = 5 * v185;
      }
      if ( v186 )
        *(_DWORD *)(v176 + 100) = v183;
      else
        v64 *= 2;
      v187 = v184 - 1;
      v188 = (int)*(double *)(v51 + 4096 + 8 * v184 + 120);
      if ( v184 - 1 > 0 )
      {
        v189 = v51 + 8 * v184 + 4216;
        do
        {
          v190 = *(_QWORD *)(v189 - 8);
          v189 -= 8;
          --v187;
          *(_QWORD *)(v189 + 8) = v190;
        }
        while ( v187 );
      }
      v60 = 0;
      v53 = 0;
      *(double *)(v51 + 4224) = (double)v188;
LABEL_83:
      *(_DWORD *)(v4 + 4304) = 0;
      v65 = *(_DWORD *)(v51 + 4308);
      v66 = *(_DWORD *)(v51 + 4332);
      if ( (v200 & 2) != 0 )
      {
        if ( v65 <= 8 )
        {
LABEL_85:
          v65 = v51 + 4096;
          *(_DWORD *)(v51 + 4332) = v66 | 4;
        }
        else if ( !v66 )
        {
          v65 = v51 + 4096;
          *(_DWORD *)(v51 + 4328) = v200 | 8;
        }
      }
      else
      {
        v66 |= 8u;
        *(_DWORD *)(v51 + 4332) = v66;
        if ( v65 <= 8 )
          goto LABEL_85;
      }
      if ( (*(_DWORD *)(v51 + 4328) & 0xA) == 0xA )
      {
        v101 = v53 + 10 * v60;
        if ( v197 )
        {
          v65 = v196;
          v102 = 1;
        }
        else
        {
          v102 = v196;
        }
        if ( v197 )
          *(_BYTE *)(v65 + 40) = v102;
        else
          *(_BYTE *)(v102 + 40) = 0;
        v210 = 0;
        v103 = *(_DWORD *)(v51 + 4304);
        *(_DWORD *)(v196 + 200) = v199;
        *(_DWORD *)(v196 + 188) = v64 + 2000;
        *(_DWORD *)(v196 + 196) = v101;
        *(_DWORD *)(v196 + 204) = v103;
        *(_DWORD *)(v196 + 192) = v194;
        v104 = *(_DWORD *)v51;
        v211 = 0;
        if ( sub_633D8(v194, v101, v199, v103, 0, v104, (int *)(v196 + 212), &v210) )
        {
          v138 = *(_DWORD *)v51;
          v139 = *(_DWORD *)(v51 + 4);
          *(_DWORD *)(v51 + 56) = 0;
          *(_QWORD *)(v196 + 248) = 0;
          *(_DWORD *)(v196 + 224) = v138;
          *(_DWORD *)(v196 + 228) = v139;
          sub_39A70((_DWORD *)v196, v210, v211);
          sub_39D44(v193);
          v199 = *(_DWORD *)(v51 + 3300) + 10 * *(_DWORD *)(v51 + 3412);
          v53 = *(_DWORD *)(v51 + 3524);
          v60 = *(_DWORD *)(v51 + 3636);
          v202 = *(_DWORD *)(v51 + 4336);
          v64 = *(_DWORD *)(v51 + 4084) + 10 * *(_DWORD *)(v51 + 4196);
          v194 = *(_DWORD *)(v51 + 3748) + 10 * *(_DWORD *)(v51 + 3860) + 100 * *(_DWORD *)(v51 + 3972);
          v197 = v202 & 0x40;
        }
        else
        {
          v105 = *(_DWORD *)(v51 + 3412);
          v106 = *(_DWORD *)(v51 + 4196);
          v107 = *(_DWORD *)(v51 + 4084);
          v108 = *(_DWORD *)(v51 + 3748) + 10 * *(_DWORD *)(v51 + 3860) + 100 * *(_DWORD *)(v51 + 3972);
          v109 = *(_DWORD *)(v51 + 4336);
          *(_DWORD *)(v51 + 52) = 6;
          v202 = v109;
          v194 = v108;
          v64 = v107 + 10 * v106;
          LOBYTE(v107) = v109;
          v53 = *(_DWORD *)(v51 + 3524);
          v60 = *(_DWORD *)(v51 + 3636);
          v197 = v107 & 0x40;
          v199 = *(_DWORD *)(v51 + 3300) + 10 * v105;
        }
      }
      v67 = v202;
      v68 = v64 + 2000;
      v69 = v197;
      v201 = v53 + 10 * v60;
      v70 = v202 & 7;
      if ( (*(_DWORD *)(v51 + 4328) & 8) != 0 )
        v71 = 32;
      else
        v71 = 63;
      v198 = (unsigned __int8)dstcod[(v202 >> 4) & 3];
      if ( v69 )
        v72 = 76;
      else
        v72 = 32;
      v203 = v72;
      if ( (v67 & 8) == 0 )
        v70 = -v70;
      sub_6C054(v196 + 56, 0x80u, "%c%1X", v71, *(_DWORD *)(v51 + 4332));
      sub_6C054((int)v212, 0x32u, " %4d %03d %02d:%02d:%02d %c%c %+d", v68, v194, v201, v199, 0, v203, v198, v70);
      sub_6D58C((unsigned __int8 *)(v196 + 56), v212, 128);
      sub_6C054(
        (int)v212,
        0x32u,
        " %d %d %s %.0f %d %.1f %d",
        *(_DWORD *)(v51 + 56),
        *(_DWORD *)(v51 + 216 * *(_DWORD *)(v51 + 3284) + 2200),
        (const char *)(*(_DWORD *)(v51 + 3280) + 92),
        *(double *)(*(_DWORD *)(v51 + 3280) + 72),
        *(_DWORD *)(v51 + 4340),
        *(double *)(v51 + 24) / 8000.0 * 1000000.0,
        *(_DWORD *)(v51 + 2128));
      sub_6D58C((unsigned __int8 *)(v196 + 56), v212, 128);
      *(_DWORD *)(v196 + 184) = strlen((const char *)(v196 + 56));
      LODWORD(a1) = sub_41F44((unsigned __int16 *)(v193 + 16), (const char *)(v196 + 56));
      if ( (v2[192] & 8) != 0 )
        goto LABEL_32;
LABEL_33:
      *((double *)v2 + 31) = *((double *)v2 + 31) + 0.000005;
      return LODWORD(a1);
    case 0xD:
      v73 = v4 + 216 * *(_DWORD *)(v4 + 3292);
      *(_QWORD *)(v73 + 2264) = *(_QWORD *)(v73 + 2256);
      a1 = *(double *)(v73 + 2360);
      *(double *)(v73 + 2368) = a1;
      goto LABEL_31;
    case 0xE:
      v10 = *(_DWORD *)(v4 + 3292);
      v11 = v4 + 216 * v10;
      v12 = *(double *)(v11 + 2264);
      if ( v12 <= 0.0 )
      {
        v14 = 0.0;
      }
      else
      {
        v13 = *(double *)(v11 + 2248);
        if ( v13 <= 0.0 || (a1 = log10(a1), v14 = v12 / v13 * 20.0, v14 > 40.0) )
          v14 = 40.0;
      }
      v15 = v4 + 216 * v10;
      *(double *)(v15 + 2272) = v14;
      v16 = 2 * *(_DWORD *)(v15 + 2288);
      *(_DWORD *)(v15 + 2288) = v16;
      if ( (v16 & 0x40) != 0 )
        --*(_DWORD *)(v15 + 2292);
      v17 = v4 + 216 * v10;
      v18 = *(double *)(v17 + 2264);
      if ( v18 < 2500.0 || *(double *)(v17 + 2272) < 20.0 || (*(_DWORD *)(v4 + 4328) & 0x60) != 0 )
      {
        v19 = *(_DWORD *)(v17 + 2292);
      }
      else
      {
        LODWORD(a1) = *(_DWORD *)(v17 + 2288) | 1;
        v19 = *(_DWORD *)(v17 + 2292) + 1;
        *(_DWORD *)(v17 + 2288) = LODWORD(a1);
        *(_DWORD *)(v17 + 2292) = v19;
        v18 = *(double *)(v17 + 2264);
      }
      v20 = v19;
      v21 = v4 + 216 * v10;
      HIDWORD(a1) = v21 + 2368;
      v22 = (double)v20 * 6000.0;
      if ( v18 >= 6000.0 )
        v18 = 5999.0;
      *(double *)(v21 + 2280) = (v22 + v18) / 42000.0 * 100.0;
      if ( *(double *)HIDWORD(a1) <= 0.0 )
      {
        v24 = 0.0;
      }
      else
      {
        v23 = (double *)(v21 + 2352);
        if ( *v23 <= 0.0 || (v137 = *(double *)HIDWORD(a1) / *v23, log10(a1), v24 = v137 * 20.0, v24 > 40.0) )
          v24 = 40.0;
      }
      v25 = v4 + 216 * v10;
      v26 = v25;
      *(double *)(v25 + 2376) = v24;
      v27 = (double *)(v25 + 2368);
      v28 = 2 * *(_DWORD *)(v25 + 2392);
      *(_DWORD *)(v25 + 2392) = v28;
      if ( (v28 & 0x40) != 0 )
        --*(_DWORD *)(v25 + 2396);
      v29 = *v27;
      v30 = *(_DWORD *)(v4 + 4328);
      if ( *v27 < 2500.0 || *(double *)(v26 + 2376) < 20.0 || (v30 & 0x60) != 0 )
      {
        v31 = *(_DWORD *)(v26 + 2396);
      }
      else
      {
        v31 = *(_DWORD *)(v26 + 2396) + 1;
        *(_DWORD *)(v26 + 2392) |= 1u;
        *(_DWORD *)(v26 + 2396) = v31;
        v29 = *v27;
      }
      v32 = 216 * v10;
      if ( v29 >= 6000.0 )
        v29 = 5999.0;
      v34 = ((double)v31 * 6000.0 + v29) / 42000.0 * 100.0;
      *(double *)(v4 + v32 + 2384) = v34;
      if ( (v2[192] & 8) != 0 )
      {
        v33 = v4 + v32;
        sub_6C054(
          (int)v212,
          0x80u,
          "wwv5 %04x %3d %4d %.0f/%.1f %.0f/%.1f %s %04x %.0f %.0f/%.1f %s %04x %.0f %.0f/%.1f",
          v30,
          *(_DWORD *)(v4 + 2116),
          *(_DWORD *)(v4 + 2132),
          *(double *)(v4 + 2144),
          *(double *)(v4 + 2152),
          *(double *)(v4 + 4312),
          *(double *)(v4 + 4320),
          (const char *)(v4 + v32 + 2300),
          (unsigned __int16)*(_DWORD *)(v33 + 2288),
          *(double *)(v33 + 2280),
          *(double *)(v33 + 2264),
          *(double *)(v33 + 2272),
          (const char *)(v4 + v32 + 2404),
          (unsigned __int16)*(_DWORD *)(v33 + 2392),
          v34,
          *(double *)(v33 + 2368),
          *(double *)(v33 + 2376));
        sub_41F44((unsigned __int16 *)(v193 + 16), v212);
        v30 = *(_DWORD *)(v4 + 4328);
      }
      *(_DWORD *)(v4 + 4332) = 0;
      *(_DWORD *)(v4 + 4308) = 0;
      *(_DWORD *)(v4 + 4340) = 0;
      v35 = *(_DWORD *)(v4 + 56);
      if ( (v30 & 8) != 0 )
      {
        if ( v35 <= 2880 )
        {
LABEL_30:
          LODWORD(a1) = sub_556C0(v193);
LABEL_31:
          if ( (v2[192] & 8) == 0 )
            goto LABEL_33;
LABEL_32:
          v36 = *(_DWORD *)(v4 + 4328);
          if ( (v36 & 4) == 0 )
          {
LABEL_36:
            sub_6C054(
              (int)v212,
              0x80u,
              "wwv3 %2d %04x %3d %4d %5.0f %5.1f %5.0f %5.1f %5.0f",
              v5,
              v36,
              *(_DWORD *)(v4 + 2116),
              *(_DWORD *)(v4 + 2132),
              *(double *)(v4 + 2144),
              *(double *)(v4 + 2152),
              *(double *)(v4 + 4312),
              *(double *)(v4 + 4320),
              v3);
            LODWORD(a1) = sub_41F44((unsigned __int16 *)(v193 + 16), v212);
          }
          goto LABEL_33;
        }
      }
      else if ( (v30 & 4) != 0 )
      {
        if ( v35 <= 40 )
          goto LABEL_30;
      }
      else if ( v35 <= 15 )
      {
        goto LABEL_30;
      }
      LODWORD(a1) = sub_55870(v193);
      return LODWORD(a1);
    default:
      goto LABEL_31;
  }
}
// 562A0: variable 'v1' is possibly undefined
// 56730: variable 'v8' is possibly undefined
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// B5BEC: using guessed type _UNKNOWN *bcd3_ptr;
// B5D44: using guessed type _UNKNOWN *bcd6_ptr;
// B5D94: using guessed type _UNKNOWN *bcd2_ptr;
// B5E5C: using guessed type _UNKNOWN *bcd9_ptr;
// B7358: using guessed type double bcd9[44];
// BF688: using guessed type int dword_BF688;

//----- (00057878) --------------------------------------------------------
int __fastcall sub_57878(int a1)
{
  double v1; // d0
  int v2; // r4
  double v3; // d15
  double v4; // d12
  double v5; // d13
  double v6; // d7
  double v7; // d9
  double v8; // d14
  double v9; // d8
  double v10; // d3
  double v11; // d10
  double v12; // d2
  double v13; // d4
  double v14; // d0
  double v15; // d11
  double v16; // d1
  int v17; // r12
  double v18; // d7
  int v19; // r1
  int v20; // kr00_4
  double v21; // d9
  double v22; // d5
  double v23; // d15
  double v24; // d12
  double *v25; // r6
  double v26; // d5
  double *v27; // r1
  int v28; // r11
  double v29; // d4
  double v30; // d8
  double v31; // d6
  double v32; // d12
  double v33; // d5
  double v34; // d9
  double v35; // d7
  double v36; // d6
  int v37; // r1
  double v38; // d7
  int v39; // kr04_4
  double v40; // d4
  int v41; // kr08_4
  int v42; // r11
  double *v43; // r6
  double v44; // d3
  int v45; // r10
  double v46; // d1
  double v47; // d6
  int v48; // r2
  double v49; // d2
  double v50; // d3
  int v51; // r10
  double v52; // d6
  double v53; // d0
  double v54; // d7
  double v55; // r0
  double v56; // d3
  int v57; // r5
  double v58; // d6
  double v59; // d0
  double v60; // d8
  int v61; // r6
  double v62; // d0
  double *v63; // r11
  int v64; // r3
  double v65; // d3
  double v66; // r0
  double v67; // d2
  double *v68; // lr
  double v69; // d1
  double v70; // d5
  double *v71; // r10
  double v72; // d6
  double v73; // d3
  double v74; // d7
  double v75; // d1
  int v76; // r6
  double v77; // d0
  double v78; // d6
  double v79; // d5
  double v80; // d8
  int v81; // r1
  int v82; // r12
  int v83; // r6
  int v84; // r3
  double v85; // r0
  int v86; // r6
  int v87; // r3
  int v88; // r2
  double *v89; // r2
  double v90; // d7
  int v91; // r3
  double v92; // d7
  int v93; // r3
  double v94; // d5
  double *v95; // r3
  double v96; // r0
  double v97; // d7
  bool v98; // cc
  int v99; // r12
  double v100; // d7
  double v101; // d0
  int v102; // r0
  _BYTE *v103; // r6
  int v104; // r4
  double *v105; // r7
  int v106; // r5
  double v107; // d7
  int v108; // r2
  int v109; // r3
  double v110; // d6
  int v111; // r2
  int v112; // r3
  bool v113; // zf
  int v114; // r3
  double v115; // d0
  double v116; // d7
  double v117; // d0
  double v118; // d8
  double v119; // r0
  double v120; // r0
  double v121; // d0
  int v122; // r10
  int v123; // r12
  __int64 v124; // r8
  int v125; // r0
  int v126; // r1
  int v127; // r1
  int v128; // r2
  int v129; // lr
  int v130; // r12
  _DWORD *v131; // r3
  int v132; // r0
  double v133; // d7
  double v134; // d5
  double v135; // d6
  double v136; // d7
  double v137; // d0
  double v138; // d8
  double v139; // d6
  int v140; // r2
  double v141; // d7
  double v142; // d0
  double v143; // d0
  double v144; // d9
  double *v145; // r8
  double v146; // r0
  double v147; // d8
  int v148; // r3
  int v149; // r3
  double v150; // d0
  double v152; // [sp+30h] [bp-104h]
  int v153; // [sp+30h] [bp-104h]
  double v154; // [sp+38h] [bp-FCh]
  int v155; // [sp+38h] [bp-FCh]
  double v156; // [sp+40h] [bp-F4h]
  double *v157; // [sp+40h] [bp-F4h]
  int v158; // [sp+40h] [bp-F4h]
  double v159; // [sp+48h] [bp-ECh]
  int v160; // [sp+48h] [bp-ECh]
  double v161; // [sp+50h] [bp-E4h]
  double v162; // [sp+58h] [bp-DCh]
  double v163; // [sp+60h] [bp-D4h]
  double v164; // [sp+68h] [bp-CCh]
  double v165; // [sp+70h] [bp-C4h]
  double v166; // [sp+78h] [bp-BCh]
  double v167; // [sp+80h] [bp-B4h]
  double v168; // [sp+88h] [bp-ACh]
  double v169; // [sp+90h] [bp-A4h]
  double *v171; // [sp+A0h] [bp-94h]
  char v172[128]; // [sp+ACh] [bp-88h] BYREF

  v171 = *(double **)(a1 + 84);
  v154 = v1;
  v2 = *(_DWORD *)v171;
  if ( dword_BF878 )
  {
    v3 = dbl_BF890;
    v4 = dbl_BF898;
    v161 = dbl_BF8D8;
    v165 = dbl_BF8B8;
    v152 = dbl_BF8B0;
    v156 = dbl_BF888;
    v163 = dbl_BF8C8;
    v5 = dbl_BF8A8;
    v162 = dbl_BF8D0;
    v6 = dbl_BF890 * -3.48174 + dbl_BF898 * 0.8360961 + dbl_BF888 * 5.452988 + dbl_BF880 * -3.807229;
    v164 = dbl_BF8C0;
    v159 = dbl_BF8E0;
    v7 = dbl_BF888 * 0.01654858;
    v166 = dbl_BF880;
    v8 = dbl_BF898 * 0.003281435;
    v9 = dbl_BF8A8 * -0.02375732;
    v10 = dbl_BF8D8 * -0.02375732;
    v11 = dbl_BF880 * -0.01149947;
    v12 = dbl_BF890 * -0.01149947;
    v167 = dbl_BF8B0 * 0.03353214;
    v169 = dbl_BF8D0 * 0.03353214;
    v13 = dbl_BF8B8 * -0.04080258;
    v168 = dbl_BF8C8 * -0.04080258;
    v14 = dbl_BF8C0 * 0.04605479;
    v15 = v154
        - (dbl_BF8D8 * -2.765914
         + dbl_BF8E0 * 0.4897278
         + dbl_BF8D0 * 8.110921
         + dbl_BF8C8 * -15.17732
         + dbl_BF8C0 * 19.75197
         + dbl_BF8B8 * -18.14365
         + dbl_BF8B0 * 11.59783
         + dbl_BF8A8 * -4.73504);
    v16 = dbl_BF8E0 * 0.008203628;
  }
  else
  {
    dword_BF878 = 1;
    memset(&unk_BF8F0, 0, 0x148u);
    memset(&unk_104490, 0, 0x2A80u);
    memset(&unk_101A10, 0, 0x2A80u);
    memset(dbl_F5210, 0, 0xC800u);
    memset(&unk_E8A10, 0, 0xC800u);
    memset(&unk_BFA38, 0, 0x140u);
    memset(&unk_BFB78, 0, 0x140u);
    memset(&unk_DC210, 0, 0xC800u);
    memset(&unk_CFA10, 0, 0xC800u);
    memset(&unk_BFCB8, 0, 0x140u);
    memset(&unk_BFDF8, 0, 0x140u);
    memset(dbl_C0010, 0, sizeof(dbl_C0010));
    v6 = 0.0;
    v10 = -0.0;
    v15 = v1;
    v169 = 0.0;
    v16 = 0.0;
    v14 = 0.0;
    v167 = 0.0;
    v5 = 0.0;
    v152 = 0.0;
    v165 = 0.0;
    v164 = 0.0;
    v163 = 0.0;
    v162 = 0.0;
    v161 = 0.0;
    v159 = 0.0;
    v8 = 0.0;
    v7 = 0.0;
    v166 = 0.0;
    v156 = 0.0;
    v3 = 0.0;
    v4 = 0.0;
    v168 = -0.0;
    v13 = -0.0;
    v9 = -0.0;
    v12 = -0.0;
    v11 = -0.0;
  }
  v17 = *(_DWORD *)(v2 + 2176);
  v18 = v154 * 5.0 - v6;
  dbl_BF8A0 = v4;
  dbl_BF890 = v156;
  dbl_BF880 = v18;
  dbl_BF898 = v3;
  v19 = dword_BFF38;
  dbl_BF888 = v166;
  *(_DWORD *)(v2 + 2176) = (v17 + 1) % 80;
  v20 = v19 + 1;
  v19 *= 8;
  dbl_BF8E8 = v159;
  dbl_BF8D8 = v162;
  dbl_BF8E0 = v161;
  v21 = v11 + v18 * 0.003281435 + v7 + v12 + v8;
  v22 = sintab[v17];
  dbl_BF8D0 = v163;
  dbl_BF8C8 = v164;
  v23 = *(double *)(v2 + 2160);
  v24 = v21 * v22 / 680.0;
  dbl_BF8C0 = v165;
  v25 = (double *)((char *)&unk_104490 + v19);
  v26 = *(double *)((char *)&unk_104490 + v19);
  v27 = (double *)((char *)&unk_101A10 + v19);
  v28 = dword_BFF3C;
  v29 = v9 + v15 * 0.008203628 + v167 + v13;
  v30 = v21 * sintab[(v17 + 20) % 80] / 680.0;
  dbl_BF8B8 = v152;
  *(double *)(v2 + 2160) = v23 - v26;
  dword_BFF38 = v20 % 1360;
  dbl_BF8B0 = v5;
  *v25 = v24;
  v31 = *(double *)(v2 + 2168);
  v32 = *(double *)(v2 + 2160) + v24;
  dbl_BF8A8 = v15;
  v33 = dbl_BFF68;
  *(double *)(v2 + 2160) = v32;
  v34 = v29 + v14 + v168 + v169 + v10 + v16;
  v35 = v31 - *v27;
  v36 = dbl_BFF60;
  *(double *)(v2 + 2168) = v35;
  *v27 = v30;
  v37 = dword_BFF40;
  v38 = dbl_BFF48;
  v160 = dword_BFF40;
  *(double *)(v2 + 2168) = *(double *)(v2 + 2168) + v30;
  v39 = v28 + 20;
  v157 = &sintab[v28];
  v40 = dbl_BFF58;
  v41 = v28 + 10;
  v42 = 8 * v37;
  v43 = (double *)((char *)&unk_E8A10 + 8 * v37);
  v44 = sintab[v39 % 80];
  v45 = *(_DWORD *)(v2 + 2196) + 1;
  v46 = v34 * *v157 * 0.25;
  v47 = v36 - *v43;
  dword_BFF3C = v41 % 80;
  v48 = v45 - (_DWORD)&loc_75300 * (v45 / 480000);
  v49 = v34 * v44 * 0.25;
  v50 = dbl_F5210[v37];
  v158 = dword_BFF50;
  v51 = 8 * dword_BFF50;
  *(_DWORD *)(v2 + 2196) = v48;
  LODWORD(v55) = 274877907 * v48;
  v52 = v47 + v49;
  *v43 = v49;
  v53 = v52 * v52;
  v54 = v38 - v50 + v46;
  HIDWORD(v55) = 8000;
  v56 = *(double *)((char *)&unk_BFB78 + v51);
  v57 = v48 % 8000;
  dbl_BFF60 = v52;
  v58 = *(double *)((char *)&unk_BF668 + v51 + 976);
  v59 = v53 + v54 * v54;
  *(double *)((char *)&unk_BFB78 + v51) = v49;
  dbl_F5210[v42 / 8u] = v46;
  *(double *)((char *)&unk_BF668 + v51 + 976) = v46;
  dbl_BFF48 = v54;
  dbl_BFF68 = v33 - v56 + v49;
  v60 = sqrt(v59);
  dbl_BFF58 = v40 - v58 + v46;
  v61 = *(_DWORD *)(v2 + 3292);
  if ( v59 < 0.0 )
    sqrt(v55);
  v153 = v2 + 4096;
  *(double *)(v2 + 216 * v61 + 2248) = v60 / 800.0;
  if ( (*(_DWORD *)(v2 + 4328) & 1) == 0 )
  {
    HIDWORD(v120) = v2 + 216 * v61 + 2208;
    LODWORD(v120) = a1;
    sub_55F80(v120, (int)(v171[93] * 8000.0));
    v160 = dword_BFF40;
    v158 = dword_BFF50;
    v42 = 8 * dword_BFF40;
    v51 = 8 * dword_BFF50;
  }
  HIDWORD(v66) = (char *)&unk_CFA10 + v42;
  v62 = dbl_BFF88 - *(double *)((char *)&unk_CFA10 + v42);
  v63 = (double *)((char *)&unk_DC210 + v42);
  v64 = (dword_BFF70 + 20) % 80;
  v65 = *v63;
  LODWORD(v66) = (dword_BFF70 + 12) % 80;
  v67 = v34 * sintab[dword_BFF70] * 0.25;
  dword_BFF70 = LODWORD(v66);
  v68 = (double *)((char *)&unk_BFCB8 + v51);
  v69 = sintab[v64];
  v70 = *(double *)((char *)&unk_BFCB8 + v51);
  v71 = (double *)((char *)&unk_BFDF8 + v51);
  v72 = *v71;
  v73 = dbl_BFF78 - v65 + v67;
  v74 = dbl_BFF80 - v70;
  *v68 = v67;
  dbl_BFF78 = v73;
  *v63 = v67;
  v75 = v34 * v69 * 0.25;
  v76 = *(_DWORD *)(v2 + 3292);
  v77 = v62 + v75;
  v78 = dbl_BFF90 - v72;
  *(double *)HIDWORD(v66) = v75;
  dbl_BFF80 = v74 + v67;
  dbl_BFF88 = v77;
  *v71 = v75;
  v79 = v77 * v77 + v73 * v73;
  dbl_BFF90 = v78 + v75;
  v80 = sqrt(v79);
  if ( v79 < 0.0 )
    sqrt(v66);
  v81 = 216 * v76;
  *(double *)(v2 + 216 * v76 + 2352) = v80 / 800.0;
  v82 = *(_DWORD *)(v2 + 4328);
  v83 = v82 & 1;
  if ( (v82 & 1) == 0 )
  {
    HIDWORD(v119) = v2 + v81 + 2312;
    LODWORD(v119) = a1;
    sub_55F80(v119, (int)(v171[94] * 8000.0));
    v82 = *(_DWORD *)(v2 + 4328);
    v83 = v82 & 1;
    v160 = dword_BFF40;
    v158 = dword_BFF50;
  }
  v84 = *(_DWORD *)(v2 + 2196);
  LODWORD(v85) = (v158 + 1) % 40;
  HIDWORD(v85) = &unk_BF668;
  dword_BFF40 = (v160 + 1) % 6400;
  dword_BFF50 = LODWORD(v85);
  if ( !v84 )
  {
    ++*(_DWORD *)(v2 + 56);
    if ( v83 )
    {
      if ( (v82 & 0x1000) != 0 )
        *(_DWORD *)(v2 + 2196) = 472000;
LABEL_15:
      v86 = **(_DWORD **)(a1 + 84);
      v87 = *(_DWORD *)(v86 + 3292);
      v88 = v86 + 216 * v87;
      HIDWORD(v85) = v88 + 2240;
      v89 = (double *)(v88 + 2256);
      v90 = *(double *)(HIDWORD(v85) + 8);
      if ( v90 > *v89 )
        *v89 = v90;
      v91 = v86 + 216 * v87;
      v92 = *(double *)(v91 + 2352);
      if ( v92 > *(double *)(v91 + 2360) )
        *(double *)(v91 + 2360) = v92;
      v93 = *(_DWORD *)(v86 + 2192);
      switch ( v93 )
      {
        case 6400:
          *(_DWORD *)(v86 + 2136) = *(_DWORD *)(v86 + 2132);
          break;
        case 120:
          dbl_BFF98 = *(double *)(v86 + 2160);
          dbl_BFFA0 = dbl_BFF98;
          dbl_BFFA8 = dbl_BFF98;
          break;
        case 1600:
          v136 = *(double *)(v86 + 2168);
          dbl_BFFA0 = *(double *)(v86 + 2160);
          v137 = v136 * v136 + dbl_BFFA0 * dbl_BFFA0;
          v138 = sqrt(v137);
          if ( v137 < 0.0 )
          {
            sqrt(v85);
            v136 = *(double *)(v86 + 2168);
            v93 = *(_DWORD *)(v86 + 2192);
          }
          v139 = (double)*(int *)(v86 + 2128);
          dbl_BFFB0 = v138;
          v140 = *(_DWORD *)(v86 + 2176);
          *(double *)(v86 + 2184) = v136 / v139;
          if ( v136 / v139 < 0.0 )
          {
            *(_DWORD *)(v86 + 2176) = v140 - 1;
            if ( v140 - 1 < 0 )
              *(_DWORD *)(v86 + 2176) = v140 + 79;
          }
          else
          {
            *(_DWORD *)(v86 + 2176) = v140 + 1;
            if ( v140 + 1 > 79 )
              *(_DWORD *)(v86 + 2176) = v140 - 79;
          }
          break;
        case 4000:
          dbl_BFF98 = *(double *)(v86 + 2160);
          break;
      }
      HIDWORD(v85) = *(_DWORD *)(v86 + 2196);
      *(_DWORD *)(v86 + 2192) = v93 + 1;
      LODWORD(v85) = 8000;
      if ( SHIDWORD(v85) % 8000 != *(_DWORD *)(v86 + 2136) )
        goto LABEL_23;
      v141 = *(double *)(v86 + 2160);
      v142 = *(double *)(v86 + 2168) * *(double *)(v86 + 2168);
      *(_DWORD *)(v86 + 4328) &= 0xFFFFFF9F;
      v143 = v142 + v141 * v141;
      v144 = sqrt(v143);
      if ( v143 < 0.0 )
        sqrt(v85);
      v145 = (double *)(v86 + 4320);
      HIDWORD(v146) = 0;
      v147 = dbl_BFFB0;
      *(double *)(v86 + 4312) = dbl_BFFB0;
      if ( v147 <= 0.0 )
      {
        *v145 = 0.0;
      }
      else if ( v144 <= 0.0 || (v146 = log10(0.0), v150 = v147 / v144 * 20.0, v150 > 40.0) )
      {
        *v145 = 40.0;
        if ( v147 >= 1000.0 )
        {
LABEL_150:
          LODWORD(v146) = a1;
          dbl_BFFA0 = dbl_BFFA0 - dbl_BFF98;
          dbl_BFF98 = dbl_BFF98 - dbl_BFFA8;
          sub_56264(v146);
          goto LABEL_129;
        }
      }
      else
      {
        *v145 = v150;
        if ( v147 >= 1000.0 && v150 >= 10.0 )
          goto LABEL_150;
      }
      LODWORD(v146) = a1;
      *(_DWORD *)(v86 + 4328) |= 0x20u;
      sub_56264(v146);
LABEL_129:
      v148 = *(_DWORD *)(v86 + 4340);
      if ( (*(_DWORD *)(v86 + 4328) & 0x60) != 0 )
        *(_DWORD *)(v86 + 4340) = ++v148;
      if ( v148 > 40 )
        *(_DWORD *)(v86 + 4332) |= 2u;
      sub_55584(*(int ***)(a1 + 84));
      v85 = 0.0;
      v149 = v86 + 216 * *(_DWORD *)(v86 + 3292);
      *(_QWORD *)(v149 + 2256) = 0;
      *(_QWORD *)(v149 + 2360) = 0;
      *(_DWORD *)(v86 + 2192) = 0;
LABEL_23:
      v82 = *(_DWORD *)(v2 + 4328);
      goto LABEL_24;
    }
    LODWORD(v85) = sub_556C0(a1);
    v82 = *(_DWORD *)(v2 + 4328);
    if ( !LODWORD(v85) )
      *(_DWORD *)(v2 + 56) = 0;
    v83 = v82 & 1;
  }
  if ( v83 )
    goto LABEL_15;
  v112 = *(_DWORD *)(v2 + 3280);
  if ( v112 )
  {
    if ( *(double *)(v112 + 72) >= 50.0 )
    {
      LODWORD(v85) = *(_DWORD *)(v112 + 32);
      HIDWORD(v85) = (int)((unsigned __int64)(274877907LL * SLODWORD(v85)) >> 32) >> 9;
      if ( SLODWORD(v85) % 8000 == v57 )
      {
        v113 = (v82 & 2) == 0;
        v82 |= 1u;
        HIDWORD(v85) = (SLODWORD(v85) / -8000 + 60) % 60;
        v114 = v2 + 4096;
        *(_DWORD *)(v2 + 4304) = HIDWORD(v85);
        *(_DWORD *)(v2 + 2192) = 0;
        *(_DWORD *)(v2 + 4328) = v82;
        if ( !v113 )
          v114 = *(_DWORD *)(v2 + 2132);
        *(_DWORD *)(v2 + 56) = 0;
        if ( v113 )
        {
          *(_DWORD *)(v2 + 2132) = v57;
          *(_DWORD *)(v2 + 2136) = v57;
        }
        else
        {
          *(_DWORD *)(v2 + 2136) = v114;
        }
      }
    }
  }
LABEL_24:
  if ( (v82 & 0x100) != 0 )
  {
    v115 = dbl_BFF68;
    v116 = dbl_BFF58;
  }
  else
  {
    if ( (v82 & 0x200) == 0 )
    {
      v94 = 0.0;
      goto LABEL_27;
    }
    v115 = dbl_BFF90;
    v116 = dbl_BFF80;
  }
  v117 = v115 * v115 + v116 * v116;
  v118 = sqrt(v117);
  if ( v117 < 0.0 )
    sqrt(v85);
  v94 = v118 / 5.0;
LABEL_27:
  v95 = &dbl_C0010[v57];
  HIDWORD(v96) = &unk_BF668;
  LODWORD(v96) = &dbl_BFFB8;
  v97 = (v94 - *v95) / (double)*(int *)(v2 + 2128) + *v95;
  v98 = v97 <= dbl_BFFB8;
  *v95 = v97;
  if ( !v98 )
  {
    v99 = v57 - 48;
    if ( v57 - 48 < 0 )
      v99 = v57 + 7936;
    dbl_BFFB8 = v97;
    if ( v57 - 48 < 0 )
      v99 += 16;
    dword_BFFC0 = v57;
    dbl_BFFC8 = fabs(dbl_C0010[v99]);
  }
  if ( !v57 )
  {
    v100 = dbl_BFFB8;
    *(double *)(v2 + 2144) = dbl_BFFB8;
    if ( v100 <= 0.0 )
    {
      v101 = 0.0;
    }
    else if ( dbl_BFFC8 <= 0.0 || (v121 = v100 / dbl_BFFC8, log10(v96), v101 = v121 * 20.0, v101 > 40.0) )
    {
      v101 = 40.0;
    }
    *(double *)(v2 + 2152) = v101;
    v102 = dword_BFFC0 - 40;
    if ( dword_BFFC0 - 40 < 0 )
      v102 = dword_BFFC0 + 7960;
    dword_BFFC0 = v102;
    v103 = *(_BYTE **)(a1 + 84);
    v104 = *(_DWORD *)v103;
    v105 = (double *)(*(_DWORD *)v103 + 2144);
    v106 = *(_DWORD *)v103 + 4096;
    v107 = *v105;
    if ( !dword_BFFD0 )
    {
      dword_BFFD4 = 0;
      dword_BFFD8 = 0;
      dword_BFFDC = 0;
      dword_BFFD0 = 1;
    }
    v108 = dword_BFFE0 + 1;
    v109 = *(_DWORD *)(v106 + 232);
    ++dword_BFFE0;
    if ( v107 < 2500.0 || (v110 = *(double *)(v104 + 2152), v110 < 15.0) )
    {
      *(_DWORD *)(v106 + 232) = v109 & 0xFFFFFFED;
      dword_BFFE4 = 0;
      dword_BFFE8 = 0;
      dword_BFFEC = 0;
LABEL_44:
      LODWORD(v96) = 0;
      v111 = *(_DWORD *)(v153 + 232);
      if ( (v111 & 2) == 0 )
        *(_DWORD *)(v153 + 236) |= 8u;
      dbl_BFFB8 = 0.0;
      if ( (v111 & 1) == 0 )
        LODWORD(v96) = sub_55584(*(int ***)(a1 + 84));
      return LODWORD(v96);
    }
    if ( (v109 & 0x300) == 0 )
      goto LABEL_44;
    v122 = dword_BFFD4;
    v123 = dword_BFFD8;
    dword_BFFD4 = v102;
    dword_BFFD8 = v122;
    dword_BFFDC = v123;
    if ( v122 < v102 )
    {
      if ( v123 >= v122 )
      {
        if ( v123 > v102 )
        {
LABEL_74:
          v122 = v102;
          dword_BFFF0 = v102;
          goto LABEL_75;
        }
        dword_BFFF0 = v123;
        v122 = v123;
LABEL_75:
        v155 = v103[768] & 8;
        v124 = 274877907LL * (v122 - dword_BFFF4);
        v125 = (v122 - dword_BFFF4) % 8000;
        if ( v125 )
        {
          if ( dword_BFFE4 <= dword_BFFE8 )
          {
            dword_BFFFC = v108;
            dword_BFFE4 = dword_BFFE8;
            dword_BFFE8 = 0;
            dword_C0000 = dword_BFFF4;
          }
        }
        else
        {
          v126 = dword_BFFE8 + 1;
          dword_BFFE8 = v126;
          if ( v126 > 10 )
          {
            if ( (v109 & 1) == 0 )
            {
              if ( !v155 )
              {
LABEL_83:
                v127 = *(_DWORD *)(v104 + 2128);
                goto LABEL_84;
              }
LABEL_152:
              HIDWORD(v124) = v172;
              sub_6C054(
                (int)v172,
                0x80u,
                "wwv1 %04x %3d %4d %5.0f %5.1f %5d %4d %4d %4d",
                v109,
                *(_DWORD *)(v104 + 2116),
                v122,
                v107,
                v110,
                v125,
                dword_BFFEC,
                v126,
                dword_BFFE4);
              sub_41F44((unsigned __int16 *)(a1 + 16), v172);
              v122 = dword_BFFF0;
              goto LABEL_83;
            }
            if ( (v109 & 0x10) == 0 )
            {
              v127 = *(_DWORD *)(v104 + 2128);
              if ( v108 - dword_BFFF8 > v127 )
              {
LABEL_84:
                if ( ++dword_BFFEC >= v127 )
                {
                  v128 = dword_BFFE8;
                  v129 = dword_BFFE4;
                  if ( dword_BFFE8 >= dword_BFFE4 )
                  {
                    v129 = dword_BFFE8;
                    dword_BFFE4 = dword_BFFE8;
                    dword_BFFFC = dword_BFFE0;
                    dword_C0000 = dword_BFFF4;
                  }
                  v130 = *(_DWORD *)(v106 + 232);
                  v131 = &unk_BF668;
                  if ( !v129 )
                    v128 = dword_BFFE0;
                  dword_BFFF4 = v122;
                  if ( v129 )
                    v122 = dword_C0000;
                  else
                    HIDWORD(v124) = v128;
                  if ( v129 )
                    v131 = (_DWORD *)dword_BFFFC;
                  else
                    dword_BFFFC = v128;
                  v132 = v122 - dword_C0004;
                  if ( v129 )
                    HIDWORD(v124) = v131;
                  else
                    v131[614] = v122;
                  v133 = (double)(v132 % 8000);
                  if ( (v130 & 0x10) != 0 )
                  {
                    v134 = fabs(v133);
                    if ( v134 >= 12.0 )
                    {
                      if ( dword_C0008 < -2 )
                      {
                        if ( v127 > 8 )
                        {
                          dword_C0008 = 0;
                          *(_DWORD *)(v104 + 2128) = v127 >> 1;
                        }
                      }
                      else
                      {
                        --dword_C0008;
                      }
                    }
                    else
                    {
                      v135 = v133 * 0.5 / (double)(3 * (HIDWORD(v124) - dword_BFFF8)) + *(double *)(v104 + 24);
                      if ( v135 <= 1.5 )
                      {
                        if ( v135 < -1.5 )
                          v135 = -1.5;
                        *(double *)(v104 + 24) = v135;
                      }
                      else
                      {
                        *(double *)(v104 + 24) = 1.5;
                      }
                      if ( v134 < 6.0 )
                      {
                        if ( dword_C0008 > 2 )
                        {
                          if ( v127 < 1024 )
                          {
                            dword_C0008 = 0;
                            *(_DWORD *)(v104 + 2128) = 2 * v127;
                          }
                        }
                        else
                        {
                          ++dword_C0008;
                        }
                      }
                    }
                  }
                  if ( (v103[768] & 8) != 0 )
                  {
                    sub_6C054(
                      (int)v172,
                      0x80u,
                      "wwv2 %04x %5.0f %5.1f %5d %4d %4d %4d %4.0f %7.2f",
                      v130,
                      *v105,
                      *(double *)(v104 + 2152),
                      v122,
                      *(_DWORD *)(v104 + 2128),
                      v129,
                      HIDWORD(v124) - dword_BFFF8,
                      v133,
                      *(double *)(v104 + 24) * 1000000.0 / 8000.0);
                    sub_41F44((unsigned __int16 *)(a1 + 16), v172);
                    v122 = dword_C0000;
                    v130 = *(_DWORD *)(v106 + 232);
                    HIDWORD(v124) = dword_BFFFC;
                  }
                  *(_DWORD *)(v106 + 232) = v130 | 0x10;
                  dword_C0004 = v122;
                  dword_BFFF8 = HIDWORD(v124);
                  dword_BFFE4 = 0;
                  dword_BFFE8 = 0;
                  dword_BFFEC = 0;
                }
                else
                {
                  dword_BFFF4 = v122;
                }
                goto LABEL_44;
              }
            }
            *(_DWORD *)(v106 + 232) = v109 | 2;
            *(_DWORD *)(v104 + 2132) = v122;
          }
        }
        if ( !v155 )
          goto LABEL_83;
        v109 = *(_DWORD *)(v106 + 232);
        if ( (v109 & 1) != 0 )
          goto LABEL_83;
        v126 = dword_BFFE8;
        goto LABEL_152;
      }
    }
    else if ( v123 <= v122 )
    {
      if ( v123 >= v102 )
      {
        v122 = v123;
        dword_BFFF0 = v123;
        goto LABEL_75;
      }
      goto LABEL_74;
    }
    dword_BFFF0 = v122;
    goto LABEL_75;
  }
  return LODWORD(v96);
}
// 578AC: variable 'v1' is possibly undefined
// 58E00: variable 'v85' is possibly undefined
// 1BC: using guessed type int elf_hash_bucket[521];
// B76A0: using guessed type double sintab[81];
// BF878: using guessed type int dword_BF878;
// BF880: using guessed type double dbl_BF880;
// BF888: using guessed type double dbl_BF888;
// BF890: using guessed type double dbl_BF890;
// BF898: using guessed type double dbl_BF898;
// BF8A0: using guessed type double dbl_BF8A0;
// BF8A8: using guessed type double dbl_BF8A8;
// BF8B0: using guessed type double dbl_BF8B0;
// BF8B8: using guessed type double dbl_BF8B8;
// BF8C0: using guessed type double dbl_BF8C0;
// BF8C8: using guessed type double dbl_BF8C8;
// BF8D0: using guessed type double dbl_BF8D0;
// BF8D8: using guessed type double dbl_BF8D8;
// BF8E0: using guessed type double dbl_BF8E0;
// BF8E8: using guessed type double dbl_BF8E8;
// BFF38: using guessed type int dword_BFF38;
// BFF3C: using guessed type int dword_BFF3C;
// BFF40: using guessed type int dword_BFF40;
// BFF48: using guessed type double dbl_BFF48;
// BFF50: using guessed type int dword_BFF50;
// BFF58: using guessed type double dbl_BFF58;
// BFF60: using guessed type double dbl_BFF60;
// BFF68: using guessed type double dbl_BFF68;
// BFF70: using guessed type int dword_BFF70;
// BFF78: using guessed type double dbl_BFF78;
// BFF80: using guessed type double dbl_BFF80;
// BFF88: using guessed type double dbl_BFF88;
// BFF90: using guessed type double dbl_BFF90;
// BFF98: using guessed type double dbl_BFF98;
// BFFA0: using guessed type double dbl_BFFA0;
// BFFA8: using guessed type double dbl_BFFA8;
// BFFB0: using guessed type double dbl_BFFB0;
// BFFB8: using guessed type double dbl_BFFB8;
// BFFC0: using guessed type int dword_BFFC0;
// BFFC8: using guessed type double dbl_BFFC8;
// BFFD0: using guessed type int dword_BFFD0;
// BFFD4: using guessed type int dword_BFFD4;
// BFFD8: using guessed type int dword_BFFD8;
// BFFDC: using guessed type int dword_BFFDC;
// BFFE0: using guessed type int dword_BFFE0;
// BFFE4: using guessed type int dword_BFFE4;
// BFFE8: using guessed type int dword_BFFE8;
// BFFEC: using guessed type int dword_BFFEC;
// BFFF0: using guessed type int dword_BFFF0;
// BFFF4: using guessed type int dword_BFFF4;
// BFFF8: using guessed type int dword_BFFF8;
// BFFFC: using guessed type int dword_BFFFC;
// C0000: using guessed type int dword_C0000;
// C0004: using guessed type int dword_C0004;
// C0008: using guessed type int dword_C0008;
// C0010: using guessed type double dbl_C0010[8000];
// F5210: using guessed type double dbl_F5210[5566];

//----- (00058E24) --------------------------------------------------------
_BYTE *__fastcall sub_58E24(double a1, int a2)
{
  _DWORD *v2; // r9
  int v3; // r6
  double v4; // d0
  double **v5; // r8
  double *v6; // r4
  __int64 v7; // r0
  unsigned int v8; // lr
  char *v9; // r10
  int v10; // r2
  int v11; // r3
  _BYTE *result; // r0
  int v13; // r1
  char *v14; // r5
  double v15; // d7
  int v16; // r3
  int v17; // r1
  int v18; // lr
  bool v19; // cf
  int v20; // r1
  int v21; // r3
  char v22; // t1
  double v23; // d11
  int v24; // r2
  int v25; // r3
  __int64 v26; // r0

  v2 = (_DWORD *)LODWORD(a1);
  v3 = *(_DWORD *)(LODWORD(a1) + 4);
  v4 = (double)*(int *)(LODWORD(a1) + 84) / 8000.0;
  v5 = *(double ***)(v3 + 84);
  v6 = *v5;
  LODWORD(a1) = 32;
  ldexp(a1, a2);
  if ( v4 < 0.0 )
  {
    LODWORD(v26) = sub_8C010(-v4);
    v7 = -v26;
  }
  else
  {
    LODWORD(v7) = sub_8C010(v4);
  }
  v8 = v2[19];
  v9 = (char *)(v2 + 22);
  v10 = v2[21];
  v11 = v2[18] - HIDWORD(v7);
  if ( v8 < (unsigned int)v7 )
    --v11;
  v2[19] = v8 - v7;
  v2[18] = v11;
  result = (_BYTE *)v2[18];
  v13 = v2[19];
  *(_DWORD *)v6 = result;
  *((_DWORD *)v6 + 1) = v13;
  if ( v10 > 0 )
  {
    v14 = (char *)(v2 + 22);
    do
    {
      v22 = *v14++;
      v23 = v6[(unsigned __int8)~v22 + 8];
      if ( v23 > 6000.0 )
      {
        ++*((_DWORD *)v6 + 531);
      }
      else if ( v23 < -6000.0 )
      {
        ++*((_DWORD *)v6 + 531);
      }
      v15 = (v6[3] + clock_codec) / 8000.0 + v6[2];
      v6[2] = v15;
      if ( v15 < 0.5 )
      {
        if ( v15 < -0.5 )
        {
          v6[2] = v15 + 1.0;
          sub_57878(v3);
        }
        sub_57878(v3);
        v10 = v2[21];
      }
      else
      {
        v6[2] = v15 - 1.0;
      }
      v16 = *((_DWORD *)v6 + 1);
      result = (_BYTE *)(v14 - v9);
      v17 = *((_DWORD *)v6 + 3);
      v18 = *((_DWORD *)v6 + 2);
      v19 = __CFADD__(v17, v16);
      v20 = v17 + v16;
      v21 = *(_DWORD *)v6;
      *((_DWORD *)v6 + 1) = v20;
      *(_DWORD *)v6 = v21 + v18 + v19;
    }
    while ( v10 > v14 - v9 );
  }
  if ( ((_BYTE)v5[192] & 2) != 0 )
    v24 = 2;
  else
    v24 = 1;
  v25 = (_BYTE)v5[192] & 4;
  *((_DWORD *)v6 + 528) = v24;
  if ( v25 )
    v25 = 127;
  *((_DWORD *)v6 + 530) = v25;
  return result;
}
// 58E98: variable 'v7' is possibly undefined
// 5903C: variable 'v26' is possibly undefined
// 108300: using guessed type double clock_codec;

//----- (0005906C) --------------------------------------------------------
__int16 *__fastcall sub_5906C(int a1, int a2)
{
  _DWORD *v3; // r1
  int v4; // r0
  char v5; // r3
  __int16 *result; // r0
  char buf; // [sp+3h] [bp-9h] BYREF

  v3 = *(_DWORD **)(a2 + 84);
  v4 = v3[7];
  if ( *(_BYTE *)(*v3 + 13) )
    v5 = 82;
  else
    v5 = 84;
  buf = v5;
  result = (__int16 *)write(v4, &buf, 1u);
  if ( result != (__int16 *)((char *)&dword_0 + 1) )
    return sub_394A0((__int16 *)a2, 3);
  return result;
}
// 0: using guessed type int dword_0;

//----- (000590F4) --------------------------------------------------------
__int16 *__fastcall sub_590F4(int a1, int a2)
{
  const char *v3; // r4
  bool v4; // zf
  int v5; // r2
  int v6; // r3

  v3 = *(const char **)(a2 + 84);
  v4 = (v3[768] & 8) == 0;
  v5 = *(_DWORD *)v3;
  ++*((_DWORD *)v3 + 194);
  v6 = *((_DWORD *)v3 + 49);
  if ( !v4 && *(unsigned __int8 *)(v5 + 12) > v6 )
    *(_BYTE *)(v5 + 13) = 15;
  *(_BYTE *)(v5 + 12) = v6;
  if ( *((_DWORD *)v3 + 54) == *((_DWORD *)v3 + 55) )
    return sub_394A0((__int16 *)a2, 1);
  sub_39D44(a2);
  return (__int16 *)sub_41F44((unsigned __int16 *)(a2 + 16), v3 + 56);
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (000591B8) --------------------------------------------------------
void __fastcall sub_591B8(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (00059238) --------------------------------------------------------
__int16 *__fastcall sub_59238(int a1)
{
  int v1; // r8
  int *v2; // r5
  __int16 **v3; // r4
  const char *v4; // r6
  __int16 *result; // r0
  __int16 *v6; // r1
  __int16 *v7; // r3
  unsigned int v8; // r3
  bool v9; // zf
  unsigned int v10; // r3
  __int16 *v11; // r0
  __int16 *v12; // r1
  __int16 *v13; // r12
  int v14; // r2
  __int16 *v15; // r1
  int v16; // r0
  int v17; // r0
  int v18; // r1
  _BYTE v19[5]; // [sp+23h] [bp-11h] BYREF
  int v20; // [sp+28h] [bp-Ch] BYREF
  int v21; // [sp+2Ch] [bp-8h] BYREF
  int v22; // [sp+30h] [bp-4h] BYREF
  __int16 *v23; // [sp+34h] [bp+0h] BYREF
  __int16 *v24; // [sp+38h] [bp+4h]

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(int **)(v1 + 84);
  v4 = (const char *)(v2 + 14);
  v3 = (__int16 **)*v2;
  result = (__int16 *)sub_39EE4(a1, (bool *)v2 + 56, 128, &v23);
  v7 = result;
  if ( !result )
  {
    v8 = (unsigned int)v3[2];
    v9 = v8 == 0;
    v10 = __clz(v8);
    if ( v9 )
    {
      result = v23;
      v6 = v24;
    }
    v3[2] = (__int16 *)(v10 >> 5);
    if ( v9 )
    {
      *v3 = result;
      v3[1] = v6;
    }
    return result;
  }
  v11 = *v3;
  v12 = v3[1];
  v2[46] = (int)v7;
  v2[58] = (int)v11;
  v2[59] = (int)v12;
  v13 = v11;
  v14 = v2[59];
  result = v23;
  v15 = v24;
  v3[2] = (_WORD *)(&dword_0 + 1);
  *v3 = result;
  v3[1] = v15;
  if ( !((unsigned int)v13 | v14) )
    return result;
  memset(v19, 32, 4);
  v20 = 0;
  if ( v7 != (__int16 *)&off_18 )
  {
    if ( v7 == (__int16 *)((char *)&dword_1C + 1) )
    {
      if ( sscanf(
             v4,
             "0003%c %4d%2d%2d %2d%2d%2d+0000%c%c",
             v19,
             v2 + 47,
             &v22,
             &v21,
             v2 + 49,
             v2 + 50,
             v2 + 51,
             &v19[3],
             &v19[2]) == 8 )
      {
        v16 = sub_6EC68(v2[47], v22, v21);
        v2[52] = 0;
        v2[48] = v16;
        goto LABEL_15;
      }
    }
    else if ( v7 == (_WORD *)&dword_14 + 1
           && sscanf(
                v4,
                "%c %3d %2d:%2d:%2d%c%cTZ=%2d",
                v19,
                v2 + 48,
                v2 + 49,
                v2 + 50,
                v2 + 51,
                &v19[4],
                &v19[3],
                &v20) == 8 )
    {
      v2[52] = 0;
      goto LABEL_15;
    }
LABEL_11:
    if ( !*((_BYTE *)v3 + 13) )
      return sub_394A0((__int16 *)v1, 2);
    --*((_BYTE *)v3 + 13);
    return (__int16 *)sub_41F44((unsigned __int16 *)(v1 + 16), v4);
  }
  if ( sscanf(
         v4,
         "%c%c %2d %3d %2d:%2d:%2d.%3ld %c",
         v19,
         &v19[1],
         v2 + 47,
         v2 + 48,
         v2 + 49,
         v2 + 50,
         v2 + 51,
         v2 + 52,
         &v19[2]) != 9 )
    goto LABEL_11;
  v2[52] *= (_DWORD)&unk_F4240;
LABEL_15:
  switch ( v19[1] )
  {
    case ' ':
      v17 = v2[58];
      v18 = v2[59];
      *((_QWORD *)v2 + 31) = 0x3F50624DD2F1A9FCLL;
      v2[56] = v17;
      v2[57] = v18;
      break;
    case 'A':
      *((_QWORD *)v2 + 31) = 0x3F847AE147AE147BLL;
      break;
    case 'B':
      *((_QWORD *)v2 + 31) = 0x3FB999999999999ALL;
      break;
    case 'C':
      *((_QWORD *)v2 + 31) = 0x3FE0000000000000LL;
      break;
    case 'D':
      *((_QWORD *)v2 + 31) = 0x4030000000000000LL;
      break;
    default:
      *((_QWORD *)v2 + 31) = 0x4030000000000000LL;
      sub_394A0((__int16 *)v1, 2);
      break;
  }
  if ( v19[0] == 32 )
    *((_BYTE *)v2 + 40) = v19[2] == 76;
  else
    *((_BYTE *)v2 + 40) = 3;
  result = (__int16 *)sub_39BC8(v2);
  if ( !result )
    return sub_394A0((__int16 *)v1, 6);
  return result;
}
// 5929C: variable 'v6' is possibly undefined
// 0: using guessed type int dword_0;
// 14: using guessed type int dword_14;
// 18: using guessed type _UNKNOWN *off_18;
// 1C: using guessed type int;

//----- (00059630) --------------------------------------------------------
int __fastcall sub_59630(int a1, int a2)
{
  int v3; // r8
  int v4; // r7
  void *v5; // r0
  _DWORD *v6; // r4
  void *v7; // r9
  char v9[20]; // [sp+0h] [bp-1Ch] BYREF

  sub_6C054((int)v9, 0x14u, "/dev/wwvb%d", a1);
  v3 = sub_3A298(v9, 0xDu, 1);
  if ( v3 <= 0 )
    return 0;
  v5 = sub_63BA4(0, 0x10u, 0, 1);
  v6 = *(_DWORD **)(a2 + 84);
  v7 = v5;
  v6[5] = a2;
  v6[7] = v3;
  v6[3] = sub_59238;
  v6[6] = 0;
  v4 = sub_18DF0(v6 + 2);
  if ( v4 )
  {
    v4 = 1;
    *v6 = v7;
    *(_BYTE *)(a2 + 95) = -13;
    v6[11] = "Spectracom WWVB/GPS Receiver";
    v6[191] = *(_DWORD *)"WWVB";
  }
  else
  {
    close(v3);
    v6[7] = -1;
    free(v7);
  }
  return v4;
}

//----- (00059754) --------------------------------------------------------
int __fastcall sub_59754(int a1, int a2)
{
  _DWORD *v2; // r4
  int v3; // r5
  int v4; // r3
  int v6; // [sp+4h] [bp-4h]

  v2 = *(_DWORD **)(a2 + 84);
  v3 = *v2;
  v4 = *(_DWORD *)(*v2 + 32);
  if ( v4 )
    *(_DWORD *)(v3 + 32) = v4 - 1;
  else
    sub_394A0((__int16 *)a2, 1);
  ++v2[194];
  *(_BYTE *)(v3 + 30) = 1;
  return v6;
}
// 59790: variable 'v6' is possibly undefined

//----- (000597D8) --------------------------------------------------------
void __fastcall sub_597D8(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (00059858) --------------------------------------------------------
int __fastcall sub_59858(int a1, int a2)
{
  int v4; // r0
  int v5; // r8
  int v6; // r7
  void *v7; // r10
  int v8; // r4
  char v10[20]; // [sp+8h] [bp-18h] BYREF

  sub_6C054((int)v10, 0x14u, "/dev/zyfer%d", a1);
  v4 = sub_3A298(v10, 0xDu, 32);
  v5 = v4;
  if ( v4 <= 0 )
    return 0;
  sub_64E00(5, "zyfer(%d) fd: %d dev <%s>", a1, v4, v10);
  v7 = sub_63BA4(0, 0x30u, 0, 0);
  memset(v7, 0, 0x30u);
  v8 = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(v8 + 20) = a2;
  *(_DWORD *)(v8 + 28) = v5;
  *(_DWORD *)(v8 + 12) = sub_599B8;
  *(_DWORD *)(v8 + 24) = 0;
  v6 = sub_18DF0((int *)(v8 + 8));
  if ( v6 )
  {
    v6 = 1;
    *(_DWORD *)v8 = v7;
    *(_BYTE *)(a2 + 95) = -20;
    *(_DWORD *)(v8 + 44) = "Zyfer GPStarplus";
    strcpy((char *)(v8 + 764), "GPS");
    *((_BYTE *)v7 + 30) = 0;
    *((_DWORD *)v7 + 8) = 2;
  }
  else
  {
    close(v5);
    *(_DWORD *)(v8 + 28) = -1;
    free(v7);
  }
  return v6;
}

//----- (000599B8) --------------------------------------------------------
__int16 *__fastcall sub_599B8(_DWORD *a1)
{
  int v2; // r7
  int *v3; // r4
  __int16 *result; // r0
  int v5; // r9
  const char *v6; // r8
  int v7; // r3
  int v8; // [sp+18h] [bp-14h] BYREF
  char v9; // [sp+1Ch] [bp-10h] BYREF
  int v10; // [sp+20h] [bp-Ch] BYREF

  v2 = a1[1];
  v3 = *(int **)(v2 + 84);
  result = (__int16 *)v3[46];
  v5 = *v3;
  if ( (int)result <= 28 )
  {
    if ( result )
    {
      v6 = (const char *)(v3 + 14);
      memcpy((char *)result + (_DWORD)(v3 + 14), a1 + 22, a1[21]);
      result = (__int16 *)(v3[46] + a1[21]);
      v3[46] = (int)result;
      *((_BYTE *)result + (_DWORD)v3 + 56) = 0;
      goto LABEL_5;
    }
  }
  else
  {
    v3[46] = 0;
  }
  if ( *((_BYTE *)a1 + 88) != 33 )
    return result;
  v6 = (const char *)(v3 + 14);
  result = (__int16 *)sub_39EE4((int)a1, (bool *)v3 + 56, 128, v3 + 58);
  v3[46] = (int)result;
LABEL_5:
  if ( (int)result > 28 )
  {
    sub_41F44((unsigned __int16 *)(v2 + 16), v6);
    if ( v3[46] != 29 )
      return sub_394A0((__int16 *)v2, 6);
    result = (__int16 *)sscanf(
                          v6,
                          "!TIME,%4d,%3d,%2d,%2d,%2d,%d,%d,%d",
                          v3 + 47,
                          v3 + 48,
                          v3 + 49,
                          v3 + 50,
                          v3 + 51,
                          &v8,
                          &v9,
                          &v10);
    if ( result != (__int16 *)byte_8 )
      return sub_394A0((__int16 *)v2, 2);
    if ( v8 != 2 )
      return sub_394A0((__int16 *)v2, 6);
    if ( v10 != 1 )
    {
      *((_BYTE *)v3 + 40) = 3;
      return result;
    }
    result = (__int16 *)sub_39CF8(v3);
    if ( !result )
      return sub_394A0((__int16 *)v2, 6);
    v7 = *(unsigned __int8 *)(v5 + 30);
    *(_DWORD *)(v5 + 32) = 2;
    if ( v7 )
    {
      *(_BYTE *)(v5 + 30) = 0;
      return (__int16 *)sub_39D44(v2);
    }
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (00059B70) --------------------------------------------------------
void sub_59B70()
{
  ;
}

//----- (00059BB4) --------------------------------------------------------
int __fastcall sub_59BB4(int a1, int a2)
{
  _DWORD *v3; // r4
  _BYTE *v4; // r0
  int v5; // r12
  int v6; // r2

  v3 = *(_DWORD **)(a2 + 84);
  v3[11] = "Spectracom TSYNC-PCI";
  v3[3] = 0;
  v3[6] = 0;
  v3[5] = a2;
  *(_BYTE *)(a2 + 95) = -20;
  v4 = sub_63BA4(0, 0xCu, 0, 0);
  if ( !v4 )
    return 0;
  v6 = *(_DWORD *)(a2 + 68);
  v5 = 1;
  v4[8] = 16;
  *(_DWORD *)v4 = v6 & 0x20;
  *((_DWORD *)v4 + 1) = *(_DWORD *)"LOCL";
  v3[191] = *(_DWORD *)"LOCL";
  *v3 = v4;
  return v5;
}

//----- (00059C80) --------------------------------------------------------
__int16 *__fastcall sub_59C80(int a1, int a2)
{
  int v3; // r0
  int v4; // r0
  int *v5; // r9
  const char *v6; // r5
  int v7; // r0
  const char *v8; // r4
  const char *v9; // r3
  char *v10; // r2
  char v11; // t1
  const char *v12; // r6
  int v13; // r4
  int v14; // r6
  const char *v15; // r4
  double v16; // r0
  int v17; // r2
  double v18; // d0
  double v19; // d8
  int v20; // r1
  __int64 v21; // r4
  int v22; // r12
  int v23; // r3
  int v24; // r2
  int v25; // r0
  size_t v26; // r0
  int v27; // r12
  int v28; // r1
  int v29; // r2
  unsigned __int16 v30; // r3
  int v31; // r0
  int v32; // r12
  double v33; // r0
  double v34; // d7
  int v35; // r4
  int v36; // r2
  double v37; // d0
  int v38; // r4
  int v39; // r1
  __int64 v40; // r2
  __int16 *result; // r0
  signed __int64 v42; // r0
  unsigned int v43; // r5
  __int64 v44; // r2
  signed __int64 v45; // r4
  signed __int64 v46; // r2
  int v47; // r4
  __int64 v48; // r2
  int v49; // r2
  char v50; // r3
  bool v51; // zf
  int v52; // r0
  int v53; // r5
  const char *v54; // r4
  int v55; // r0
  bool v56; // zf
  int v57; // r0
  int v58; // r2
  char v59; // r3
  __int64 v60; // r0
  __int64 v61; // r0
  int v62; // r5
  int v63; // r12
  char *v64; // r0
  _DWORD v65[5]; // [sp+18h] [bp-1BCh] BYREF
  int v66; // [sp+2Ch] [bp-1A8h]
  int v67; // [sp+30h] [bp-1A4h]
  _BYTE s[44]; // [sp+34h] [bp-1A0h] BYREF
  _DWORD v69[5]; // [sp+60h] [bp-174h] BYREF
  int v70; // [sp+74h] [bp-160h]
  int v71; // [sp+78h] [bp-15Ch]
  unsigned int v72; // [sp+7Ch] [bp-158h]
  int v73; // [sp+80h] [bp-154h]
  int v74; // [sp+84h] [bp-150h]
  _DWORD v75[5]; // [sp+90h] [bp-144h] BYREF
  int v76; // [sp+A4h] [bp-130h]
  int v77; // [sp+A8h] [bp-12Ch]
  int v78; // [sp+ACh] [bp-128h]
  int v79; // [sp+B0h] [bp-124h]
  int v80; // [sp+B4h] [bp-120h]
  int v81; // [sp+B8h] [bp-11Ch]
  unsigned int v82; // [sp+CCh] [bp-108h]
  signed __int64 v83; // [sp+D0h] [bp-104h]
  signed __int64 v84; // [sp+D8h] [bp-FCh]
  int v85; // [sp+E0h] [bp-F4h]
  const char *v86; // [sp+E4h] [bp-F0h]
  int v87; // [sp+E8h] [bp-ECh]
  int v88; // [sp+ECh] [bp-E8h]
  const char *v89; // [sp+F0h] [bp-E4h]
  _DWORD v90[5]; // [sp+F4h] [bp-E0h]
  unsigned __int16 v91[4]; // [sp+108h] [bp-CCh] BYREF
  char v92; // [sp+110h] [bp-C4h]
  int v93; // [sp+114h] [bp-C0h] BYREF
  int v94; // [sp+118h] [bp-BCh]
  int v95; // [sp+11Ch] [bp-B8h]
  int v96; // [sp+120h] [bp-B4h]
  int v97; // [sp+124h] [bp-B0h]
  int v98; // [sp+128h] [bp-ACh]
  char v99[4]; // [sp+130h] [bp-A4h] BYREF
  unsigned int v100; // [sp+134h] [bp-A0h]
  unsigned __int8 v101; // [sp+139h] [bp-9Bh]
  unsigned __int8 v102; // [sp+13Ah] [bp-9Ah]
  unsigned __int16 v103; // [sp+13Ch] [bp-98h]
  unsigned __int16 v104; // [sp+13Eh] [bp-96h]
  unsigned __int16 v105; // [sp+140h] [bp-94h]
  int v106; // [sp+144h] [bp-90h]
  int v107; // [sp+148h] [bp-8Ch]
  int fd[7]; // [sp+150h] [bp-84h] BYREF
  char haystack[4]; // [sp+16Ch] [bp-68h] BYREF
  char v110; // [sp+170h] [bp-64h]
  char v111[4]; // [sp+174h] [bp-60h] BYREF
  char v112; // [sp+178h] [bp-5Ch]
  _BYTE v113[32]; // [sp+17Ch] [bp-58h] BYREF

  _sprintf_chk(v113, 1, 32, "%s%d", "/dev/tsyncpci", *(unsigned __int8 *)(a2 + 89));
  _printf_chk(1, "Polling device number %d...\n", *(unsigned __int8 *)(a2 + 89));
  v3 = open64(v113, 2048, 511);
  fd[0] = v3;
  if ( v3 < 0 )
    return (__int16 *)sub_64E00(3, "Couldn't open device");
  if ( ioctl(v3, 0xC01C7400, fd) < 0 )
  {
    sub_64E00(3, "Couldn't initialize device");
    return (__int16 *)close(fd[0]);
  }
  v75[0] = 620756993;
  v75[4] = 16;
  memset(&v75[1], 0, 12);
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v90[0] = ioctl(fd[0], 0xC020741A, v75);
  memset(&v69[1], 0, 12);
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v69[0] = 587268097;
  v69[4] = 12;
  v73 = 0;
  v74 = 0;
  v90[1] = ioctl(fd[0], 0xC020741A, v69);
  v65[0] = 587661313;
  v65[4] = 36;
  v86 = s;
  memset(&v65[1], 0, 12);
  v66 = 0;
  v67 = 0;
  memset(s, 0, 0x24u);
  v4 = ioctl(fd[0], 0xC020741A, v65);
  v5 = *(int **)(a2 + 84);
  v89 = (const char *)v4;
  v87 = *v5;
  v88 = ioctl(fd[0], 0xC0207419, v99);
  close(fd[0]);
  if ( (v90[0] | v90[1]) < 0
    || (((unsigned int)v89 | v88) & 0x80000000) != 0
    || v77
    || v71
    || v67
    || v76 != 8
    || v70 != 4
    || v66 != 28 )
  {
    return sub_394A0((__int16 *)a2, 3);
  }
  v6 = v86;
  v7 = 0;
  v8 = v86 + 4;
  v82 = bswap32(v72);
  v110 = 0;
  v112 = 0;
  *(_DWORD *)haystack = v78;
  *(_DWORD *)v111 = v79;
  do
  {
    v9 = &v8[v7];
    v10 = (char *)&v93 + v7;
    do
    {
      v11 = *--v9;
      *v10++ = v11;
    }
    while ( &v6[v7] != v9 );
    v7 += 4;
  }
  while ( v7 != 28 );
  v12 = "gps";
  v13 = 0;
  do
  {
    if ( strstr(haystack, v12) )
      break;
    ++v13;
    v12 = (&off_B4B04)[2 * v13];
  }
  while ( v12 );
  v85 = v13;
  v89 = v12;
  v14 = 0;
  v15 = "gps";
  do
  {
    if ( strstr(v111, v15) )
      break;
    ++v14;
    v15 = (&off_B4B04)[2 * v14];
  }
  while ( v15 );
  v88 = (int)v15;
  v90[1] = v105;
  v18 = (double)v107 / 1000000.0;
  v19 = (double)v100 / 1000000.0;
  LODWORD(v16) = 32;
  ldexp(v16, v17);
  if ( v18 < 0.0 )
  {
    LODWORD(v61) = sub_8C010(-v18);
    v21 = -v61;
  }
  else
  {
    LODWORD(v21) = sub_8C010(v18);
    HIDWORD(v21) = v20;
  }
  v22 = v102;
  v23 = v103;
  v24 = v106 - 2085978496 + HIDWORD(v21);
  v25 = v5[194] + 1;
  v5[59] = v21;
  v5[58] = v24;
  v5[194] = v25;
  v86 = (const char *)(v5 + 14);
  _sprintf_chk(v5 + 14, 1, 128, "%03d %02d:%02d:%02.6f", v23, v22, v101, v19);
  v26 = strlen((const char *)v5 + 56);
  v27 = v103;
  v91[1] = 1;
  v91[2] = 257;
  v5[51] = (int)v19;
  v28 = v102;
  v29 = v101;
  v91[3] = 0;
  v92 = 0;
  v30 = v104;
  v5[46] = v26;
  v5[48] = v27;
  v5[49] = v28;
  v5[50] = v29;
  v91[0] = v30;
  v5[52] = (int)((v19 - (double)(int)v19) * 1000000000.0);
  v31 = sub_631F0(v91);
  v32 = v5[49];
  HIDWORD(v33) = v5[50];
  v34 = (double)v5[52];
  v35 = v5[48] - 1;
  v5[53] = v31;
  v36 = v5[51];
  v37 = v34 / 1000000000.0;
  v38 = v36 + 60 * (HIDWORD(v33) + 60 * (v32 + 24 * v35)) + v31;
  LODWORD(v33) = 32;
  ldexp(v33, v36);
  if ( v34 / 1000000000.0 < 0.0 )
  {
    LODWORD(v60) = sub_8C010(-v37);
    v40 = -v60;
  }
  else
  {
    LODWORD(v40) = sub_8C010(v37);
    HIDWORD(v40) = v39;
  }
  v90[3] = v38 + HIDWORD(v40);
  v90[4] = v40;
  sub_39A70(v5, v38 + HIDWORD(v40), v40);
  if ( v90[1] == 4 )
  {
    v42 = (unsigned int)(v98 - 86401 + (_DWORD)&off_15180 * v95);
    LODWORD(v42) = v42
                 + 3600 * v96
                 + 60 * v97
                 + 31622400 * ((unsigned int)(v94 - 1969) >> 2)
                 + 31536000 * (v94 - 1970 - ((unsigned int)(v94 - 1969) >> 2));
    v43 = v42;
    v90[1] = 4 * sub_8BF30(v42, 126230400);
    sub_8BF30(v43, 126230400);
    v45 = v44;
    if ( v44 > 31535999 )
    {
      v84 = v44 - 31536000;
      if ( v44 - 31536000 > 31535999 )
      {
        v83 = v44 - 63072000;
        if ( v44 - 63072000 <= 31622399 )
        {
          v90[1] += 2;
          v45 = v83;
        }
        else
        {
          v45 = v44 - 94694400;
          v90[1] += 3;
        }
      }
      else
      {
        v45 = v84;
        ++v90[1];
      }
    }
    v90[0] = sub_8BF30(v45, (unsigned int)&off_15180) + 1;
    sub_8BF30(v45, (unsigned int)&off_15180);
    v84 = v46;
    v47 = v90[1] + 1970;
    sub_8BF30(v46, 3600);
    *(_QWORD *)&v90[1] = v48;
    v95 = v90[0];
    v94 = v47;
    v96 = sub_8BF30(v84, 3600);
    v97 = sub_8BF30(*(signed __int64 *)&v90[1], 60);
    sub_8BF30(*(signed __int64 *)&v90[1], 60);
    v98 = v49;
    if ( v82 - 1 > 1 && v104 == v47 && v103 == v90[0] )
    {
      v50 = v93;
      if ( v93 == 1 )
        goto LABEL_41;
      if ( v93 == -1 )
      {
        *((_BYTE *)v5 + 40) = 2;
        goto LABEL_42;
      }
    }
    v50 = 0;
LABEL_41:
    *((_BYTE *)v5 + 40) = v50;
LABEL_42:
    *(_BYTE *)(a2 + 91) = *((_BYTE *)v5 + 40);
    sub_394A0((__int16 *)a2, 0);
    v51 = v88 == 0;
    if ( v88 )
      v51 = v89 == 0;
    if ( v51 )
    {
      v57 = v87;
      v58 = *(_DWORD *)(v87 + 4);
      *(_DWORD *)(a2 + 68) |= *(_DWORD *)v87;
      v5[191] = v58;
      *(_DWORD *)(a2 + 112) = v58;
      v59 = *(_BYTE *)(v57 + 8);
      *((_BYTE *)v5 + 760) = v59;
      *(_BYTE *)(a2 + 93) = v59;
    }
    else
    {
      v52 = strcmp((&off_B4B04)[2 * v85 + 1], "LOCL");
      v53 = *(_DWORD *)(a2 + 68);
      v54 = (&off_B4B04)[2 * v14 + 1];
      if ( v52 && strcmp((&off_B4B04)[2 * v14 + 1], "LOCL") )
      {
        v63 = v87;
        v64 = (char *)(v87 + 4);
        *(_DWORD *)(a2 + 68) = *(_DWORD *)v87 | v53;
        *(_BYTE *)(v63 + 8) = 0;
        strncpy(v64, v54, 4u);
        *((_BYTE *)v5 + 760) = 0;
        *(_BYTE *)(a2 + 93) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 68) = v53 & 0xFFFFFFDF;
        *((_BYTE *)v5 + 760) = 16;
        *(_BYTE *)(a2 + 93) = 16;
        v55 = sys_peer;
        v56 = sys_peer == a2;
        if ( sys_peer != a2 )
          v56 = sys_peer == 0;
        if ( !v56 )
        {
          v62 = v87;
          *(_BYTE *)(v87 + 8) = *(_BYTE *)(sys_peer + 93);
          *(_DWORD *)(v62 + 4) = sub_6083C(v55 + 16);
        }
      }
      strncpy((char *)v5 + 764, v54, 4u);
      *(_DWORD *)(a2 + 112) = v5[191];
    }
    goto LABEL_27;
  }
  v5[191] = *(_DWORD *)"LOCL";
  *(_DWORD *)(a2 + 112) = v5[191];
  *((_BYTE *)v5 + 40) = 3;
  *(_BYTE *)(a2 + 91) = 3;
LABEL_27:
  if ( v5[54] == v5[55] )
    return sub_394A0((__int16 *)a2, 1);
  sub_41F44((unsigned __int16 *)(a2 + 16), v86);
  result = (__int16 *)sub_39D44(a2);
  ++v5[194];
  return result;
}
// 5A000: variable 'v16' is possibly undefined
// 5A000: variable 'v17' is possibly undefined
// 5A010: variable 'v20' is possibly undefined
// 5A140: variable 'v39' is possibly undefined
// 5A320: variable 'v44' is possibly undefined
// 5A410: variable 'v46' is possibly undefined
// 5A420: variable 'v48' is possibly undefined
// 5A468: variable 'v49' is possibly undefined
// 5A594: variable 'v60' is possibly undefined
// 5A5B4: variable 'v61' is possibly undefined
// B4C0: using guessed type int _printf_chk(_DWORD, const char *, ...);
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// BF50: using guessed type int _sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);
// 15180: using guessed type char *off_15180;
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// B4B04: using guessed type char *off_B4B04;
// 108C2C: using guessed type int sys_peer;

//----- (0005A694) --------------------------------------------------------
char *__fastcall sub_5A694(char *result)
{
  int v1; // r4
  _DWORD *v2; // r5
  int v3; // r2
  int v4; // [sp+0h] [bp-8Ch] BYREF
  char v5[128]; // [sp+4h] [bp-88h] BYREF

  v1 = *((_DWORD *)result + 21);
  v2 = *(_DWORD **)v1;
  if ( *(_DWORD *)(v1 + 28) == -1 )
  {
    if ( (*(_BYTE *)(v1 + 768) & 2) == 0 )
      goto LABEL_3;
LABEL_11:
    sub_6C054((int)v5, 0x80u, "/var/spool/lock/LCK..cua%d", *v2);
    result = (char *)unlink(v5);
    goto LABEL_3;
  }
  sub_25EE0((__int16 *)((char *)&dword_88 + 3), (int)result, "close");
  v4 = 2;
  if ( ioctl(*(_DWORD *)(v1 + 28), 0x5417u, &v4) < 0 )
    sub_64E00(3, "acts: ioctl(TIOCMBIC) failed: %m");
  result = sub_18E64(v1 + 8);
  *(_DWORD *)(v1 + 28) = -1;
  if ( (*(_BYTE *)(v1 + 768) & 2) != 0 )
    goto LABEL_11;
LABEL_3:
  if ( v2[4] || (v3 = v2[3], v3 <= 0) || !sys_phone[v3] )
  {
    v2[1] = 0;
    v2[2] = 0;
  }
  else
  {
    v2[1] = 0;
    v2[2] = 30;
  }
  return result;
}
// 88: using guessed type int dword_88;
// B9218: using guessed type int sys_phone[];

//----- (0005A7D8) --------------------------------------------------------
char *__fastcall sub_5A7D8(char *result, int a2)
{
  char *v2; // r4
  int **v3; // r7
  int *v4; // r8
  int v5; // r3
  int v6; // r10
  __pid_t v7; // r0
  size_t v8; // r0
  int v9; // r0
  int v10; // r9
  size_t v11; // r0
  int *v12; // r1
  char v13[8]; // [sp+0h] [bp-A0h] BYREF
  char v14[20]; // [sp+8h] [bp-98h] BYREF
  _BYTE v15[128]; // [sp+1Ch] [bp-84h] BYREF

  v2 = result;
  v3 = (int **)*((_DWORD *)result + 21);
  v4 = *v3;
  switch ( a2 )
  {
    case 0:
      if ( v3[7] != (int *)-1 )
        return result;
      v5 = *v4;
      if ( ((_BYTE)v3[192] & 2) == 0 )
        goto LABEL_14;
      sub_6C054((int)v15, 0x80u, "/var/spool/lock/LCK..cua%d", v5);
      v6 = open64(v15, 193, 420);
      if ( v6 < 0 )
        return (char *)sub_25EE0((__int16 *)((char *)&dword_88 + 3), (int)v2, "acts: port busy");
      v7 = getpid();
      sub_6C054((int)v13, 8u, (unsigned __int8 *)"%d\n", v7);
      v8 = strlen(v13);
      if ( write(v6, v13, v8) < 0 )
        sub_64E00(3, "acts: write lock fails %m");
      close(v6);
      v5 = *v4;
LABEL_14:
      sub_6C054((int)v14, 0x14u, "/dev/acts%d", v5);
      v9 = sub_3A298(v14, 0xEu, 164);
      v10 = v9;
      if ( v9 < 0 )
        return sub_64E00(3, "acts: open fails %m");
      v3[7] = (int *)v9;
      if ( sub_18DF0((int *)v3 + 2) )
      {
        v4[4] = 0;
        v4[7] = (int)(v4 + 8);
        if ( sys_phone[v4[3]] )
        {
          sub_262E8((__int16 *)((char *)&dword_88 + 3), (int)v2, "SETUP %s", modem_setup);
          v11 = strlen(modem_setup);
          if ( write((int)v3[7], modem_setup, v11) < 0 )
            sub_64E00(3, "acts: write SETUP fails %m");
          result = (char *)write((int)v3[7], "\r", 1u);
          *(_QWORD *)(v4 + 1) = 0x300000001LL;
        }
        else
        {
          result = (char *)write((int)v3[7], "T", 1u);
          if ( (int)result < 0 )
            result = sub_64E00(3, "acts: write T fails %m");
          *(_QWORD *)(v4 + 1) = 0x3C00000003LL;
        }
      }
      else
      {
        sub_64E00(3, "acts: addclock fails");
        result = (char *)close(v10);
        v3[7] = (int *)-1;
      }
      return result;
    case 1:
      sub_25EE0((__int16 *)((char *)&dword_88 + 3), (int)result, "no modem");
      return sub_5A694(v2);
    case 2:
      sub_25EE0((__int16 *)((char *)&dword_88 + 3), (int)result, "no answer");
      return sub_5A694(v2);
    case 3:
      if ( v4[4] )
      {
        v12 = v3[59];
        v3[56] = v3[58];
        v3[57] = v12;
        sub_41F44((unsigned __int16 *)result + 8, (const char *)v3 + 56);
        sub_39D44(v2);
      }
      else
      {
        sub_25EE0((__int16 *)((char *)&dword_88 + 3), (int)result, "no timecodes");
      }
      return sub_5A694(v2);
    default:
      return sub_5A694(v2);
  }
}
// 88: using guessed type int dword_88;
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// B7998: using guessed type char *modem_setup;
// B9218: using guessed type int sys_phone[];

//----- (0005AB2C) --------------------------------------------------------
char *__fastcall sub_5AB2C(int a1, int a2)
{
  char *result; // r0
  _BYTE *v3; // lr
  int v4; // r12
  int v5; // r1
  int v6; // r1

  result = (char *)a2;
  v3 = *(_BYTE **)(a2 + 84);
  v4 = *(_DWORD *)v3;
  v5 = *(_DWORD *)(*(_DWORD *)v3 + 8);
  if ( !v5 )
  {
    if ( (v3[768] & 1) == 0 )
      return result;
    v3[768] &= ~1u;
    return sub_5A7D8(result, v5);
  }
  v6 = v5 - 1;
  *(_DWORD *)(v4 + 8) = v6;
  if ( !v6 )
  {
    v5 = *(_DWORD *)(v4 + 4);
    return sub_5A7D8(result, v5);
  }
  return result;
}

//----- (0005ABDC) --------------------------------------------------------
char *__fastcall sub_5ABDC(int a1, int a2)
{
  char *result; // r0
  int v3; // r1
  bool v4; // zf
  _DWORD *v5; // r2
  int v6; // lr
  int v7; // r1

  result = (char *)a2;
  v3 = *(_DWORD *)(a2 + 76);
  if ( v3 )
  {
    if ( v3 == 2 )
      return result;
    goto LABEL_8;
  }
  v4 = sys_peer == 0;
  if ( sys_peer )
    v4 = sys_peer == (_DWORD)result;
  if ( v4 )
  {
LABEL_8:
    v5 = (_DWORD *)*((_DWORD *)result + 21);
    v6 = *v5;
    v7 = *(_DWORD *)(*v5 + 4);
    ++v5[194];
    if ( !v7 )
    {
      *(_DWORD *)(v6 + 12) = 0;
      return sub_5A7D8(result, 0);
    }
  }
  return result;
}
// 108C2C: using guessed type int sys_peer;

//----- (0005AC94) --------------------------------------------------------
void __fastcall sub_5AC94(int a1, int a2)
{
  void *v2; // r5

  v2 = **(void ***)(a2 + 84);
  sub_5A694((char *)a2);
  free(v2);
}

//----- (0005ACF0) --------------------------------------------------------
__int16 *__fastcall sub_5ACF0(_DWORD *a1)
{
  int v1; // r8
  _BYTE *v2; // r4
  int v3; // r5
  __int16 **v4; // r7
  unsigned __int8 *v5; // r6
  __int16 *result; // r0
  int v7; // r9
  _BYTE *v8; // r3
  int v9; // r3
  bool v10; // zf
  int v11; // t1
  unsigned __int8 *v12; // r3
  _DWORD *v13; // r11
  _DWORD *v14; // r10
  int v15; // r3
  int v16; // t1
  int v17; // r1
  int v18; // r1
  const char *v19; // r9
  size_t v20; // r0
  int v21; // r3
  int *v22; // r9
  int v23; // r11
  int v24; // r1
  int v25; // r2
  const char *v26; // r3
  int v27; // r3
  int v28; // r11
  int v29; // r1
  int *v30; // r10
  int v31; // r1
  int *v32; // r9
  int v33; // r1
  int v34; // r3
  int *v35; // r11
  int v36; // r0
  int v37; // r1
  int v38; // r0
  int v39; // r3
  _BOOL4 v40; // r2
  bool v41; // nf
  int v42; // r3
  int *v43; // [sp+38h] [bp-15Ch]
  char v44; // [sp+4Ah] [bp-14Ah] BYREF
  unsigned __int8 v45; // [sp+4Bh] [bp-149h] BYREF
  char v46; // [sp+4Ch] [bp-148h] BYREF
  char v47; // [sp+4Dh] [bp-147h] BYREF
  char v48; // [sp+4Eh] [bp-146h] BYREF
  char v49; // [sp+4Fh] [bp-145h] BYREF
  int v50; // [sp+50h] [bp-144h] BYREF
  int v51; // [sp+54h] [bp-140h] BYREF
  int v52; // [sp+58h] [bp-13Ch] BYREF
  char v53; // [sp+5Ch] [bp-138h] BYREF
  char v54; // [sp+60h] [bp-134h] BYREF
  int v55; // [sp+64h] [bp-130h] BYREF
  char v56; // [sp+68h] [bp-12Ch] BYREF
  int v57; // [sp+6Ch] [bp-128h] BYREF
  char v58; // [sp+70h] [bp-124h] BYREF
  char v59; // [sp+78h] [bp-11Ch] BYREF
  char v60; // [sp+80h] [bp-114h] BYREF
  _BYTE dest[128]; // [sp+8Ch] [bp-108h] BYREF
  char v62; // [sp+10Ch] [bp-88h] BYREF
  char v63; // [sp+10Dh] [bp-87h]
  char v64; // [sp+10Eh] [bp-86h]

  v1 = a1[1];
  v2 = dest;
  v43 = *(int **)(v1 + 84);
  v4 = (__int16 **)(v43 + 58);
  v3 = *v43;
  v5 = (unsigned __int8 *)(*v43 + 32);
  result = (__int16 *)sub_39F94(a1, dest, 128 - (*(_DWORD *)(*v43 + 28) - (_DWORD)v5), v43 + 58);
  v7 = dest[0];
  if ( dest[0] )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v7 != 10 )
        {
          result = (__int16 *)_ctype_b_loc();
          if ( (*(_WORD *)(*(_DWORD *)result + 2 * v7) & 2) == 0 )
          {
            v8 = *(_BYTE **)(v3 + 28);
            *(_DWORD *)(v3 + 28) = v8 + 1;
            *v8 = *v2;
            v9 = (unsigned __int8)*v2;
            v10 = v9 == 35;
            if ( v9 != 35 )
              v10 = v9 == 42;
            if ( v10 )
            {
              v17 = v43[59];
              *(_DWORD *)(v3 + 20) = *v4;
              *(_DWORD *)(v3 + 24) = v17;
              result = (__int16 *)write(v43[7], v2, 1u);
              if ( (int)result < 0 )
                result = (__int16 *)sub_64E00(3, "acts: write echo fails %m");
            }
          }
          goto LABEL_7;
        }
        v12 = *(unsigned __int8 **)(v3 + 28);
        if ( v5 == v12 )
        {
          result = *v4;
          v18 = v43[59];
          *(_DWORD *)(v3 + 20) = *v4;
          *(_DWORD *)(v3 + 24) = v18;
          goto LABEL_7;
        }
        *v12 = 0;
        v13 = *(_DWORD **)(v1 + 84);
        *(_DWORD *)(v3 + 28) = v5;
        v14 = (_DWORD *)*v13;
        v50 = 2;
        sub_6D4DC(&v62, v5, 128);
        strtok(&v62, " ");
        v15 = v14[1];
        if ( v15 == 2 )
        {
          if ( strcmp(&v62, "CONNECT") )
            goto LABEL_13;
          result = sub_25EE0((__int16 *)((char *)&dword_88 + 3), v1, (const char *)v5);
          *(_QWORD *)(v14 + 1) = 0x3C00000003LL;
          goto LABEL_7;
        }
        if ( v15 == 3 )
          break;
        if ( v15 == 1 )
        {
          if ( v62 == 79 && v63 == 75 && !v64 )
          {
            sub_262E8((__int16 *)((char *)&dword_88 + 3), v1, "DIAL #%d %s", v14[3], (const char *)sys_phone[v14[3]]);
            if ( ioctl(v13[7], 0x5416u, &v50) < 0 )
              sub_64E00(3, "acts: ioctl(TIOCMBIS) failed: %m");
            v19 = (const char *)sys_phone[v14[3]];
            v20 = strlen(v19);
            if ( write(v13[7], v19, v20) < 0 )
              sub_64E00(3, "acts: write DIAL fails %m");
            result = (__int16 *)write(v13[7], "\r", 1u);
            v21 = v14[3];
            v14[1] = 2;
            v14[2] = 60;
            v14[3] = v21 + 1;
          }
          else
          {
            result = (__int16 *)strcmp(&v62, modem_setup);
            if ( result )
              goto LABEL_13;
          }
          goto LABEL_7;
        }
LABEL_13:
        sub_25EE0((__int16 *)((char *)&dword_88 + 3), v1, (const char *)v5);
        result = (__int16 *)sub_5A694((char *)v1);
        v16 = (unsigned __int8)*++v2;
        v7 = v16;
        if ( !v16 )
          return result;
      }
      if ( v62 == 78 && v63 == 79 && !v64 )
        sub_25EE0((__int16 *)((char *)&dword_88 + 3), v1, (const char *)v5);
      if ( (int)v14[4] > 19 )
      {
        result = (__int16 *)sub_5A7D8((char *)v1, 3);
        goto LABEL_7;
      }
      v22 = *(int **)(v1 + 84);
      v22[52] = 0;
      result = (__int16 *)strlen((const char *)v5);
      v23 = *v22;
      if ( result == (_WORD *)&dword_14 + 1 )
        break;
      if ( (unsigned int)result > 0x16 )
      {
        if ( result == &word_32 )
        {
          if ( sscanf(
                 (const char *)v5,
                 "%5ld %2d-%2d-%2d %2d:%2d:%2d %2d %1d %3lf %5lf %9s %c",
                 &v53,
                 v22 + 47,
                 &v52,
                 &v51,
                 v22 + 49,
                 v22 + 50,
                 v22 + 51,
                 &v54,
                 &v55,
                 &v58,
                 &v59,
                 &v60,
                 &v44) != 13 )
            goto LABEL_52;
          v38 = sub_6EC68(v22[47], v52, v51);
          v39 = v55;
          v22[48] = v38;
          *((_BYTE *)v22 + 40) = 0;
          if ( v39 == 1 || v39 == 2 )
            *((_BYTE *)v22 + 40) = v39;
          result = *(__int16 **)"NIST";
          v40 = v44 != 35;
          v22[191] = *(_DWORD *)"NIST";
          v27 = *(_DWORD *)(v23 + 16) + 1;
          v41 = *(_DWORD *)(v23 + 16) - 8 < 0;
          *(_DWORD *)(v23 + 16) = v27;
          if ( !(v41 ^ __OFSUB__(v27, 9) | (v27 == 9)) )
            v40 = 0;
          if ( v40 )
            goto LABEL_7;
        }
        else
        {
          if ( result == (_WORD *)&dword_4C + 1 )
          {
            if ( sscanf(
                   (const char *)v5,
                   "%*4d-%*2d-%*2d %*2d:%*2d:%2d %*5c%*12c%4d%2d%2d%2d%2d%5ld%2lf%c%2d%3lf%*15c%c",
                   v22 + 51,
                   v22 + 47,
                   &v52,
                   &v51,
                   v22 + 49,
                   v22 + 50,
                   &v53,
                   &v58,
                   &v49,
                   &v57,
                   &v59,
                   &v44) != 12 )
              goto LABEL_52;
            v33 = v52;
            v34 = v57;
            *((_BYTE *)v22 + 40) = 0;
            if ( v34 == v33 )
            {
              if ( v49 == 43 )
              {
                *((_BYTE *)v22 + 40) = 1;
              }
              else if ( v49 == 45 )
              {
                *((_BYTE *)v22 + 40) = 2;
              }
            }
            v22[48] = sub_6EC68(v22[47], v33, v51);
            v26 = (const char *)&dword_99EB8;
          }
          else
          {
            if ( result != (__int16 *)&off_18 )
              goto LABEL_7;
            if ( sscanf(
                   (const char *)v5,
                   "%c%c%2d %3d %2d:%2d:%2d.%3ld%c%c%c",
                   &v45,
                   &v46,
                   v22 + 47,
                   v22 + 48,
                   v22 + 49,
                   v22 + 50,
                   v22 + 51,
                   v22 + 52,
                   &v48,
                   &v47,
                   &v48) != 11 )
              goto LABEL_52;
            v24 = v22[52];
            v25 = v45;
            *((_BYTE *)v22 + 40) = 0;
            v22[52] = (_DWORD)&unk_F4240 * v24;
            if ( v25 == 32 )
            {
              if ( v47 == 76 )
                *((_BYTE *)v22 + 40) = 1;
            }
            else
            {
              *((_BYTE *)v22 + 40) = 3;
            }
            v26 = "WWVB";
          }
LABEL_42:
          v22[191] = *(_DWORD *)v26;
          v27 = *(_DWORD *)(v23 + 16) + 1;
          *(_DWORD *)(v23 + 16) = v27;
        }
        v28 = v23 + 20;
        result = *(__int16 **)v28;
        v29 = *(_DWORD *)(v28 + 4);
        v30 = v22 + 58;
        *(_DWORD *)(v1 + 112) = v22[191];
        v22[58] = (int)result;
        v22[59] = v29;
        if ( v27 )
          goto LABEL_44;
        goto LABEL_7;
      }
      if ( result == (__int16 *)((char *)&dword_0 + 1) )
      {
        if ( *(_BYTE *)(v3 + 32) != 42 || *(int *)(v23 + 16) <= 0 )
          goto LABEL_7;
        v35 = (int *)(v23 + 20);
        v36 = *v35;
        v37 = v35[1];
        v30 = v22 + 58;
        *(_DWORD *)(v1 + 112) = v22[191];
        v22[58] = v36;
        v22[59] = v37;
LABEL_44:
        sub_6D4DC((_BYTE *)v22 + 56, v5, 128);
        v22[46] = strlen((const char *)v22 + 56);
        if ( sub_39CF8(v22) )
        {
          result = (__int16 *)*v30;
          v31 = v30[1];
          v32 = v22 + 56;
          *v32 = *v30;
          v32[1] = v31;
        }
        else
        {
          result = sub_394A0((__int16 *)v1, 6);
        }
        goto LABEL_7;
      }
      if ( result == (__int16 *)&dword_14 )
      {
        if ( sscanf((const char *)v5, "%5ld %3d %2d%2d%2d %3s", &v53, v22 + 48, v22 + 49, v22 + 50, v22 + 51, &v60) != 6 )
          goto LABEL_52;
        *((_BYTE *)v22 + 40) = 0;
        v26 = "USNO";
        goto LABEL_42;
      }
LABEL_7:
      v11 = (unsigned __int8)*++v2;
      v7 = v11;
      if ( !v11 )
        return result;
    }
    if ( sscanf(
           (const char *)v5,
           "%c %3d %2d:%2d:%2d %cTZ=%2d",
           &v45,
           v22 + 48,
           v22 + 49,
           v22 + 50,
           v22 + 51,
           &v48,
           &v56) != 7 )
    {
LABEL_52:
      result = sub_394A0((__int16 *)v1, 2);
      goto LABEL_7;
    }
    v42 = v45;
    *((_BYTE *)v22 + 40) = 0;
    if ( v42 != 32 )
      *((_BYTE *)v22 + 40) = 3;
    v26 = "WWVB";
    goto LABEL_42;
  }
  return result;
}
// 0: using guessed type int dword_0;
// 14: using guessed type int dword_14;
// 18: using guessed type _UNKNOWN *off_18;
// 32: using guessed type __int16 word_32;
// 4C: using guessed type int;
// 88: using guessed type int dword_88;
// 99EB8: using guessed type int dword_99EB8;
// B7998: using guessed type char *modem_setup;
// B9218: using guessed type int sys_phone[];

//----- (0005B4C0) --------------------------------------------------------
int __fastcall sub_5B4C0(int a1, int a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r3
  const char *v7; // r0

  v4 = sub_63BA4(0, 0xA0u, 0, 1);
  v5 = *(_DWORD **)(a2 + 84);
  *v4 = a1;
  v5[7] = -1;
  v5[3] = sub_5ACF0;
  v5[6] = 0;
  *v5 = v4;
  v5[5] = a2;
  *(_BYTE *)(a2 + 95) = -10;
  v5[11] = "Automated Computer Time Service";
  v5[191] = *(_DWORD *)"NONE";
  *(_BYTE *)(a2 + 90) = 9;
  v4[7] = v4 + 8;
  if ( modem_setup == "ATB1&C0&D2E0L1M1Q0V1Y1" )
  {
    v7 = (const char *)sub_24D10("modemsetup");
    if ( v7 )
      modem_setup = (char *)sub_63D08(v7);
  }
  return 1;
}
// B7998: using guessed type char *modem_setup;

//----- (0005B5DC) --------------------------------------------------------
__int16 *__fastcall sub_5B5DC(int a1, int a2)
{
  const char *v3; // r4
  int v4; // r1

  v3 = *(const char **)(a2 + 84);
  v4 = *(_DWORD *)v3;
  ++*((_DWORD *)v3 + 194);
  *(_DWORD *)(v4 + 8) = 0;
  if ( write(*((_DWORD *)v3 + 7), "TQ", 2u) != 2 )
    sub_394A0((__int16 *)a2, 3);
  if ( *((_DWORD *)v3 + 54) == *((_DWORD *)v3 + 55) )
    return sub_394A0((__int16 *)a2, 1);
  sub_39D44(a2);
  return (__int16 *)sub_41F44((unsigned __int16 *)(a2 + 16), v3 + 56);
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (0005B6B0) --------------------------------------------------------
void __fastcall sub_5B6B0(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (0005B730) --------------------------------------------------------
_BYTE *__fastcall sub_5B730(int a1)
{
  int v1; // r7
  int *v2; // r9
  int v3; // r4
  _BYTE *result; // r0
  int v5; // r10
  int v6; // r1
  int v7; // r1
  int v8; // r3
  const char *v9; // r1
  int v10; // r3
  bool v11; // cc
  int v12; // r0
  const char *v13; // r1
  char v14; // r3
  int v15; // r0
  int v16; // r1
  unsigned __int8 *v17; // r4
  unsigned __int8 *v18; // r4
  char v19; // [sp+13h] [bp-91h] BYREF
  _DWORD v20[2]; // [sp+14h] [bp-90h] BYREF
  bool v21[2]; // [sp+1Ch] [bp-88h] BYREF
  char s[126]; // [sp+1Eh] [bp-86h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(int **)(v1 + 84);
  v3 = *v2;
  result = sub_39EE4(a1, v21, 128, v20);
  v5 = (int)result;
  if ( !result )
    return result;
  v6 = *(_DWORD *)(v3 + 4);
  v2[58] = *(_DWORD *)v3;
  v2[59] = v6;
  result = (_BYTE *)v20[0];
  v7 = v20[1];
  *(_DWORD *)v3 = v20[0];
  *(_DWORD *)(v3 + 4) = v7;
  if ( v5 <= 2 )
    return result;
  v8 = *(_DWORD *)(v3 + 8);
  if ( !v8 )
  {
    if ( !strncmp((const char *)v21, "TQ", 2u) )
    {
      *(_BYTE *)(v3 + 12) = s[0];
      return (_BYTE *)write(v2[7], "SR", 2u);
    }
    if ( !strncmp((const char *)v21, "SR", 2u) )
    {
      sub_6D4DC((_BYTE *)(v3 + 13), (unsigned __int8 *)s, 40);
      if ( (v2[192] & 8) != 0 )
        return (_BYTE *)write(v2[7], &off_9A190, 2u);
      v12 = v2[7];
      if ( (*(_DWORD *)(v1 + 76) & 1) != 0 )
        v13 = "O5";
      else
        v13 = "B5";
      return (_BYTE *)write(v12, v13, 2u);
    }
    if ( !strncmp((const char *)v21, (const char *)&off_9A190, 2u) )
    {
      sub_6D4DC((_BYTE *)(v3 + 53), (unsigned __int8 *)s, 80);
      return (_BYTE *)write(v2[7], &off_9A194, 2u);
    }
    if ( !strncmp((const char *)v21, (const char *)&off_9A194, 2u) )
    {
      v17 = (unsigned __int8 *)(v3 + 53);
      sub_6D58C(v17, " ", 80);
      sub_6D58C(v17, s, 80);
      return (_BYTE *)write(v2[7], &off_9A198, 2u);
    }
    if ( !strncmp((const char *)v21, (const char *)&off_9A198, 2u) )
    {
      v18 = (unsigned __int8 *)(v3 + 53);
      sub_6D58C(v18, " ", 80);
      sub_6D58C(v18, s, 80);
      return (_BYTE *)write(v2[7], &off_9A19C, 2u);
    }
    result = (_BYTE *)strncmp((const char *)v21, (const char *)&off_9A19C, 2u);
    if ( result )
    {
      *(_DWORD *)(v3 + 8) = 1;
      return result;
    }
    sub_6D58C((unsigned __int8 *)(v3 + 53), " ", 80);
    sub_6D58C((unsigned __int8 *)(v3 + 53), s, 80);
    sub_41F44((unsigned __int16 *)(v1 + 16), (const char *)(v3 + 53));
    if ( (*(_DWORD *)(v1 + 76) & 1) != 0 )
      v9 = "O5";
    else
      v9 = "B5";
    result = (_BYTE *)write(v2[7], v9, 2u);
    v8 = *(_DWORD *)(v3 + 8);
  }
  v10 = v8 + 1;
  v11 = v5 <= 23;
  if ( v5 > 23 )
    v11 = v10 <= 1;
  *(_DWORD *)(v3 + 8) = v10;
  if ( !v11 )
  {
    sub_6D4DC((_BYTE *)v2 + 56, (unsigned __int8 *)v21, 128);
    *((_BYTE *)v2 + 78) = *(_BYTE *)(v3 + 12);
    sub_6D58C((unsigned __int8 *)v2 + 56, (char *)(v3 + 13), 128);
    v19 = 32;
    v2[46] = strlen((const char *)v2 + 56);
    if ( sscanf((const char *)v2 + 56, "%c%2d %3d %2d:%2d:%2d", &v19, v2 + 47, v2 + 48, v2 + 49, v2 + 50, v2 + 51) == 6 )
    {
      switch ( *(_BYTE *)(v3 + 12) )
      {
        case '0':
          v15 = v2[58];
          v16 = v2[59];
          *((_QWORD *)v2 + 31) = 0x3E7AD7F29ABCAF48LL;
          v2[56] = v15;
          v2[57] = v16;
          goto LABEL_31;
        case '4':
          *((_QWORD *)v2 + 31) = 0x3EB0C6F7A0B5ED8DLL;
          goto LABEL_31;
        case '5':
          *((_QWORD *)v2 + 31) = 0x3EE4F8B588E368F1LL;
          goto LABEL_31;
        case '6':
          *((_QWORD *)v2 + 31) = 0x3F1A36E2EB1C432DLL;
          goto LABEL_31;
        case '7':
          *((_QWORD *)v2 + 31) = 0x3F50624DD2F1A9FCLL;
          goto LABEL_31;
        case '8':
          *((_QWORD *)v2 + 31) = 0x3F847AE147AE147BLL;
          goto LABEL_31;
        case '9':
          *((_QWORD *)v2 + 31) = 0x3FB999999999999ALL;
          goto LABEL_31;
        case 'A':
          *((_QWORD *)v2 + 31) = 0x3FF0000000000000LL;
          goto LABEL_31;
        case 'B':
          *((_QWORD *)v2 + 31) = 0x4024000000000000LL;
LABEL_31:
          if ( v19 == 32 )
            v14 = 0;
          else
            v14 = 3;
          *((_BYTE *)v2 + 40) = v14;
          if ( sub_39CF8(v2) )
          {
            if ( *(double *)(v1 + 632) > 1.5 )
              sub_39D44(v1);
          }
          else
          {
            sub_394A0((__int16 *)v1, 6);
          }
          v12 = v2[7];
          if ( (*(_DWORD *)(v1 + 76) & 1) != 0 )
            v13 = "O0";
          else
            v13 = "B0";
          break;
        case 'F':
          *((_QWORD *)v2 + 31) = 0x4030000000000000LL;
          sub_394A0((__int16 *)v1, 3);
          v12 = v2[7];
          if ( (*(_DWORD *)(v1 + 76) & 1) != 0 )
            v13 = "O0";
          else
            v13 = "B0";
          break;
        default:
          *((_QWORD *)v2 + 31) = 0x4030000000000000LL;
          sub_394A0((__int16 *)v1, 2);
          v12 = v2[7];
          if ( (*(_DWORD *)(v1 + 76) & 1) != 0 )
            v13 = "O0";
          else
            v13 = "B0";
          break;
      }
    }
    else
    {
      sub_394A0((__int16 *)v1, 2);
      v12 = v2[7];
      if ( (*(_DWORD *)(v1 + 76) & 1) != 0 )
        v13 = "O0";
      else
        v13 = "B0";
    }
    return (_BYTE *)write(v12, v13, 2u);
  }
  return result;
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// 9A190: using guessed type _UNKNOWN *off_9A190;
// 9A194: using guessed type _UNKNOWN *off_9A194;
// 9A198: using guessed type _UNKNOWN *off_9A198;
// 9A19C: using guessed type char *off_9A19C;

//----- (0005BD80) --------------------------------------------------------
int __fastcall sub_5BD80(int a1, int a2)
{
  int v3; // r8
  int v4; // r7
  void *v5; // r0
  _DWORD *v6; // r4
  void *v7; // r9
  unsigned int v8; // r2
  const char *v9; // r1
  char v11[20]; // [sp+0h] [bp-18h] BYREF

  sub_6C054((int)v11, 0x14u, "/dev/gps%d", a1);
  v3 = sub_3A298(v11, 0xDu, 1);
  if ( v3 <= 0 )
    return 0;
  v5 = sub_63BA4(0, 0x88u, 0, 1);
  v6 = *(_DWORD **)(a2 + 84);
  v7 = v5;
  v6[5] = a2;
  v6[7] = v3;
  v6[3] = sub_5B730;
  v6[6] = 0;
  v4 = sub_18DF0(v6 + 2);
  if ( !v4 )
  {
LABEL_10:
    close(v3);
    v6[7] = -1;
    free(v7);
    return v4;
  }
  *v6 = v7;
  *(_BYTE *)(a2 + 95) = -20;
  v6[191] = *(_DWORD *)"GPS ";
  v8 = *(_DWORD *)(a2 + 76);
  v6[11] = "Arbiter 1088A/B GPS Receiver";
  if ( v8 > 1 )
  {
    v4 = 0;
    sub_64E00(5, "ARBITER: Invalid mode %d", v8);
    goto LABEL_10;
  }
  if ( v8 )
    v9 = "O0";
  else
    v9 = "B0";
  v4 = 1;
  write(v6[7], v9, 2u);
  return v4;
}

//----- (0005BEF8) --------------------------------------------------------
void sub_5BEF8()
{
  ;
}

//----- (0005BF3C) --------------------------------------------------------
void __fastcall sub_5BF3C(int a1, int a2)
{
  int v2; // r0
  int v3; // r2
  void *v4; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(_DWORD *)(v2 + 28);
  *(_DWORD *)(v2 + 52) = sub_5BEF8;
  v4 = *(void **)v2;
  if ( v3 != -1 )
    sub_18E64(v2 + 8);
  if ( v4 )
    free(v4);
}

//----- (0005BFCC) --------------------------------------------------------
char *__fastcall sub_5BFCC(int a1)
{
  int *v1; // r5
  _BYTE *v3; // r3
  int v4; // r2
  char v5; // r12
  char *result; // r0
  bool v7; // zf
  char v8; // r1
  int v9; // r2
  char buf; // [sp+3h] [bp-9h] BYREF
  int v11; // [sp+4h] [bp-8h]

  v1 = *(int **)(a1 + 84);
  v3 = (_BYTE *)*v1;
  v4 = *(unsigned __int8 *)(*v1 + 28);
  v5 = *(_BYTE *)(*v1 + 30);
  result = (char *)*(unsigned __int8 *)(*v1 + 31);
  v7 = v4 == 0;
  v3[28] = *(_BYTE *)(*v1 + 29);
  buf = v4;
  v8 = v3[32];
  v9 = _stack_chk_guard;
  v3[29] = v5;
  v3[30] = (_BYTE)result;
  v3[31] = v8;
  v11 = v9;
  if ( !v7 )
  {
    result = (char *)write(v1[7], &buf, 1u);
    if ( result != (_BYTE *)&dword_0 + 1 )
      result = sub_64E00(5, "ARCRON: write to fd %d failed", v1[7]);
    v1 = *(int **)(a1 + 84);
  }
  v1[12] = current_time + 2;
  return result;
}
// 0: using guessed type int dword_0;
// 108CA4: using guessed type int current_time;

//----- (0005C09C) --------------------------------------------------------
int __fastcall sub_5C09C(unsigned __int8 *a1, _DWORD *a2)
{
  const unsigned __int16 **v4; // r0
  int v5; // r3
  const unsigned __int16 *v6; // r2
  int result; // r0
  int v8; // r1

  v4 = _ctype_b_loc();
  v5 = *a1;
  v6 = *v4;
  result = (*v4)[v5] & 0x800;
  if ( result )
  {
    v8 = a1[1];
    result = v6[v8] & 0x800;
    if ( (v6[v8] & 0x800) != 0 )
    {
      *a2 = v8 + 10 * (v5 - 48) - 48;
      return 1;
    }
  }
  return result;
}

//----- (0005C130) --------------------------------------------------------
int __fastcall sub_5C130(int a1, int a2)
{
  int v4; // r10
  int v5; // r4
  int v6; // r9
  _DWORD *v7; // r0
  int v8; // r11
  unsigned int v9; // r2
  int v10; // r12
  int v11; // r0
  _DWORD *ptr; // [sp+4h] [bp-60h]
  struct termios termios_p; // [sp+Ch] [bp-58h] BYREF
  char v15[20]; // [sp+48h] [bp-1Ch] BYREF

  sub_64E00(5, "MSF_ARCRON %s: opening unit %d", "V1.3 2003/02/21", a1);
  sub_6C054((int)v15, 0x14u, "/dev/arc%d", a1);
  v4 = sub_3A298(v15, 7u, 1);
  if ( v4 <= 0 )
    return 0;
  v6 = open64(v15, 258, 511);
  if ( v6 < 0 )
  {
    v5 = 0;
    sub_64E00(3, "MSF_ARCRON(%d): failed second open(%s, 0777): %m.", a1, v15);
    close(v4);
  }
  else
  {
    close(v4);
    if ( fcntl(v6, 4, 0) == -1 )
      sub_64E00(3, "MSF_ARCRON(%d): fcntl(F_SETFL, 0): %m.", a1);
    if ( tcgetattr(v6, &termios_p) < 0 )
    {
      v5 = 0;
      sub_64E00(3, "MSF_ARCRON(%d): tcgetattr(%s): %m.", a1, v15);
      close(v6);
    }
    else
    {
      termios_p.c_iflag = 33;
      termios_p.c_oflag = 0;
      termios_p.c_lflag = 0;
      termios_p.c_cflag = 2295;
      *(_WORD *)&termios_p.c_cc[5] = 256;
      if ( tcsetattr(v6, 0, &termios_p) < 0 )
      {
        v5 = 0;
        sub_64E00(3, "MSF_ARCRON(%d): tcsetattr(%s): %m.", a1, v15);
        close(v6);
      }
      else
      {
        v7 = sub_63BA4(0, 0x28u, 0, 1);
        v8 = *(_DWORD *)(a2 + 84);
        ptr = v7;
        *(_DWORD *)(v8 + 20) = a2;
        *(_DWORD *)(v8 + 24) = 0;
        *(_DWORD *)(v8 + 28) = v6;
        *(_DWORD *)(v8 + 12) = sub_5C6DC;
        v5 = sub_18DF0((int *)(v8 + 8));
        if ( v5 )
        {
          v9 = *(_DWORD *)(a2 + 76);
          *(_DWORD *)v8 = ptr;
          *(_BYTE *)(a2 + 95) = -4;
          *(_BYTE *)(a2 + 93) = 2;
          *(_DWORD *)(v8 + 44) = "ARCRON MSF/DCF/WWVB Receiver";
          if ( v9 > 3 )
          {
            v5 = 0;
            sub_64E00(5, "ARCRON: Invalid mode %d", v9);
          }
          else
          {
            switch ( v9 )
            {
              case 2u:
                strcpy((char *)(v8 + 764), "DCF");
                break;
              case 3u:
                *(_DWORD *)(v8 + 764) = *(_DWORD *)"WWVB";
                break;
              case 1u:
                strcpy((char *)(v8 + 764), "MSF");
                break;
              default:
                *(_DWORD *)(v8 + 764) = *(_DWORD *)"MSFa";
                break;
            }
            v10 = *(_DWORD *)(a2 + 84);
            v5 = 1;
            ptr[3] = -1;
            v11 = current_time + 2;
            ptr[5] = 67 * a1 % 1009 + current_time + 500;
            *(_DWORD *)(v10 + 48) = v11;
            *(_DWORD *)(v10 + 52) = sub_5BFCC;
          }
        }
        else
        {
          close(v6);
          *(_DWORD *)(v8 + 28) = -1;
          free(ptr);
        }
      }
    }
  }
  return v5;
}
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// 108CA4: using guessed type int current_time;

//----- (0005C498) --------------------------------------------------------
int __fastcall sub_5C498(_BYTE *a1, char *s)
{
  signed int v4; // r0
  int v5; // r2
  int v7; // lr
  bool v8; // zf
  char *v9; // r1
  _BYTE *v10; // r12
  int v11; // t1
  _BOOL4 v12; // r3

  v4 = strlen(s);
  if ( a1[31] )
  {
    v5 = 0;
  }
  else if ( a1[30] )
  {
    v5 = 1;
  }
  else if ( a1[29] )
  {
    v5 = 2;
  }
  else if ( a1[28] )
  {
    v5 = 3;
  }
  else
  {
    v5 = 4;
  }
  if ( v4 > v5 )
    return 0;
  v7 = (unsigned __int8)*s;
  v8 = v7 == 0;
  if ( *s )
    v8 = v5 == 0;
  if ( !v8 )
  {
    v9 = s;
    v10 = &a1[32 - v5];
    do
    {
      *v10++ = v7;
      --v5;
      v11 = (unsigned __int8)*++v9;
      LOBYTE(v7) = v11;
      v12 = v5 != 0;
      if ( !v11 )
        v12 = 0;
    }
    while ( v12 );
  }
  return 1;
}

//----- (0005C588) --------------------------------------------------------
__int16 *__fastcall sub_5C588(int a1, int a2)
{
  int *v3; // r4
  int v4; // r5
  int v5; // r3
  _BOOL4 v6; // r2
  int v7; // r4
  __int16 *result; // r0

  v3 = *(int **)(a2 + 84);
  v4 = *v3;
  if ( (v3[192] & 2) == 0 && *(_DWORD *)(v4 + 20) <= (unsigned int)current_time )
  {
    *(_DWORD *)(v4 + 12) = -1;
    *(_DWORD *)(v4 + 24) = 1;
    sub_64E00(5, "ARCRON: unit %d: sending resync command", a1);
    sub_5C498((_BYTE *)v4, "h\r");
    *(_DWORD *)(v4 + 20) = current_time + 3420;
  }
  v5 = *(_DWORD *)(v4 + 12);
  v6 = v5 <= 2;
  if ( v5 == -1 )
    v6 = 0;
  if ( v6 )
  {
    v3[46] = 0;
  }
  else
  {
    v7 = *(_DWORD *)(a2 + 84);
    result = (__int16 *)sub_5C498(*(_BYTE **)v7, "o\r");
    if ( result )
    {
      ++*(_DWORD *)(v7 + 776);
      return result;
    }
    *(_DWORD *)(v7 + 184) = 0;
  }
  return sub_394A0((__int16 *)a2, 3);
}
// 108CA4: using guessed type int current_time;

//----- (0005C6DC) --------------------------------------------------------
__int16 *__fastcall sub_5C6DC(__int16 *result)
{
  int v1; // r9
  __int16 *v2; // r6
  _BYTE **v3; // r4
  int v4; // r5
  int v5; // r2
  int v6; // r1
  int v7; // r3
  int v8; // r12
  int v9; // t1
  bool v10; // zf
  char *v11; // r6
  char *v12; // r3
  int v13; // r3
  bool v14; // zf
  unsigned int v15; // r11
  _BYTE *v16; // r12
  unsigned int v17; // lr
  unsigned int v18; // r10
  unsigned int v19; // r0
  char v20; // r3
  unsigned int v21; // r6
  char v22; // r3
  int v23; // r2
  const char *v24; // r3
  int v25; // r1
  int v26; // r3
  char *v27; // r2
  char v28; // r3
  int v29; // r3
  int v30; // r7
  unsigned int v31; // r6
  char v32; // r10
  unsigned int v33; // r7
  bool v34; // cc
  int v35; // r3
  bool v36; // zf
  int v37; // r3
  int v38; // r10
  int v39; // r3
  int v40; // r2
  int v41; // r7
  int v42; // r11
  int v43; // r0
  _BYTE *v44; // r10
  int v45; // r1
  int v46; // r1
  int v47; // r3
  char v48; // r3
  char v49; // r3
  int v50; // r3
  _BYTE *v51; // r0
  _BYTE *v52; // r1
  int v53; // r12
  int v54; // r1
  int v55; // r3
  int v56; // r3
  unsigned int v57; // r6
  struct tm *v58; // r0
  struct tm *v59; // r6
  __int64 v60; // r2
  int v61; // r0
  __int64 v62; // r0
  __int64 v63; // r2
  int v64; // [sp+Ch] [bp-40h] BYREF
  time_t v65[2]; // [sp+10h] [bp-3Ch] BYREF
  struct tm tp; // [sp+18h] [bp-34h] BYREF

  v1 = *((_DWORD *)result + 1);
  v2 = result;
  v3 = *(_BYTE ***)(v1 + 84);
  v4 = (int)*v3;
  if ( *((_DWORD *)*v3 + 6)
    && !*(_BYTE *)(v4 + 31)
    && !*(_BYTE *)(v4 + 30)
    && !*(_BYTE *)(v4 + 29)
    && !*(_BYTE *)(v4 + 28) )
  {
    result = (__int16 *)sub_5C498(*v3, "g\r");
  }
  v5 = (int)v3[46];
  v6 = *((_DWORD *)v2 + 21);
  v7 = *((unsigned __int8 *)v2 + 88);
  if ( *((_BYTE *)v3 + 56) == 111 )
  {
    v14 = v5 == 1;
    if ( v5 == 1 )
      v14 = v7 == 13;
    if ( v14 )
    {
      if ( v6 > 0 )
        goto LABEL_12;
      return result;
    }
    result = (__int16 *)(v5 + v6 - 1);
    if ( (int)result > 0 )
    {
      if ( (int)result > 16 )
        goto LABEL_75;
      v15 = *((_DWORD *)v2 + 19);
      v16 = (_BYTE *)*((_DWORD *)v2 + 18);
      v17 = *(_DWORD *)v4;
      v18 = *(_DWORD *)(v4 + 4);
      v19 = *(_DWORD *)&aV1320030221[4 * (_DWORD)result + 16];
      if ( v15 < v19 )
        --v16;
      result = (__int16 *)(v15 - v19);
      if ( !(v17 | v18) || v17 + 0x80000000 > (unsigned int)&v16[0x80000000] )
        goto LABEL_36;
      v36 = result == (__int16 *)v18;
      if ( (unsigned int)result <= v18 )
        v36 = v16 == (_BYTE *)v17;
      if ( v36 )
      {
LABEL_36:
        *(_DWORD *)(v4 + 4) = result;
        *(_DWORD *)v4 = v16;
      }
    }
  }
  if ( v5 > 15 )
  {
LABEL_9:
    v3[46] = 0;
    return result;
  }
  if ( v6 > 0 )
  {
LABEL_12:
    result = v2 + 44;
    v8 = -87 - (_DWORD)v2;
    while ( 1 )
    {
      v10 = v7 == 13;
      if ( v7 != 13 )
        v10 = v7 == 104;
      if ( v10 )
      {
        v5 = (int)v3[46];
      }
      else
      {
        v11 = (char *)v3 + v5;
        v3[46] = (_BYTE *)++v5;
        v11[56] = v7;
      }
      v10 = v7 == 111;
      v12 = (char *)result + v8;
      if ( v10 && v5 == 1 )
      {
        *(_DWORD *)(v4 + 4) = 0;
        *(_DWORD *)v4 = 0;
        if ( v6 <= (int)v12 )
        {
          v13 = *((unsigned __int8 *)v3 + 56);
          if ( v13 == 103 )
            return result;
LABEL_39:
          if ( v13 != 111 )
            goto LABEL_75;
          if ( v5 <= 15 )
            return result;
          if ( !*(_QWORD *)v4 )
          {
            v3[46] = (_BYTE *)(*(_DWORD *)v4 | *(_DWORD *)(v4 + 4));
            return sub_394A0((__int16 *)v1, 2);
          }
          v26 = *(_DWORD *)(v4 + 12);
          v27 = (char *)v3 + v5;
          v27[57] = 0;
          v28 = v26 == -1 ? 54 : v26 + 48;
          v27[56] = v28;
          v29 = *((unsigned __int8 *)v3 + 56);
          v3[52] = 0;
          if ( v29 != 111 )
            goto LABEL_75;
          if ( !sub_5C09C((unsigned __int8 *)v3 + 57, v3 + 49) )
            goto LABEL_75;
          if ( !sub_5C09C((unsigned __int8 *)v3 + 59, v3 + 50) )
            goto LABEL_75;
          if ( !sub_5C09C((unsigned __int8 *)v3 + 61, v3 + 51) )
            goto LABEL_75;
          v30 = *((unsigned __int8 *)v3 + 63);
          if ( ((*_ctype_b_loc())[v30] & 0x800) == 0 )
            goto LABEL_75;
          if ( !sub_5C09C((unsigned __int8 *)v3 + 64, v3 + 48) )
            goto LABEL_75;
          if ( !sub_5C09C((unsigned __int8 *)v3 + 66, &v64) )
            goto LABEL_75;
          if ( !sub_5C09C((unsigned __int8 *)v3 + 68, v3 + 47) )
            goto LABEL_75;
          v31 = *((unsigned __int8 *)v3 + 70);
          v32 = *((_BYTE *)v3 + 71);
          if ( (unsigned int)v3[49] > 0x17 || (unsigned int)v3[50] > 0x3B )
            goto LABEL_75;
          v33 = v30 - 49;
          v34 = v33 > 6;
          if ( v33 <= 6 )
            v34 = (unsigned int)v3[51] > 0x3C;
          if ( v34
            || (unsigned int)(v3[48] - 1) > 0x1E
            || (unsigned int)(v64 - 1) > 0xB
            || (v35 = (int)v3[47], (unsigned int)v35 > 0x63)
            || !*(_DWORD *)(v1 + 76) && ((v31 >> 1) & 1) != (((v31 ^ 4) >> 2) & 1) )
          {
LABEL_75:
            v3[46] = 0;
            return sub_394A0((__int16 *)v1, 2);
          }
          if ( (*((_BYTE *)v3 + 71) & 8) != 0 )
          {
            sub_64E00(5, "ARCRON: battery low");
            v35 = (int)v3[47];
          }
          if ( v35 <= 97 )
          {
            v35 += 100;
            v3[47] = (_BYTE *)v35;
          }
          v37 = v35 + 1900;
          v3[47] = (_BYTE *)v37;
          if ( v37 >= 2096 )
            sub_64E00(5, "ARCRON: fix me!  EITHER YOUR DATE IS BADLY WRONG or else I will break soon!");
          v38 = v32 & 7;
          *((_BYTE *)v3 + 40) = 0;
          v39 = *(_DWORD *)(v4 + 8);
          if ( v38 == 3 )
          {
            if ( v39 != 3 )
              sub_64E00(5, "ARCRON: signal acquired");
          }
          else if ( v38 != v39 )
          {
            sub_64E00(5, "ARCRON: signal lost");
            *((_BYTE *)v3 + 40) = 3;
            *(_DWORD *)(v4 + 8) = v38;
            v3[46] = 0;
            return sub_394A0((__int16 *)v1, 3);
          }
          v40 = *(_DWORD *)(v1 + 76);
          v41 = (int)v3[47];
          *(_DWORD *)(v4 + 8) = v38;
          v42 = v64;
          v43 = (int)v3[48];
          if ( !v40 )
          {
            v44 = (_BYTE *)(v43 + *(_DWORD *)&aV1320030221[4 * v64 + 80]);
            v3[48] = v44;
            if ( (v41 & 3) == 0 )
            {
              sub_8BB9C(v41, 0x64u);
              if ( v45 || (sub_8BB9C(v41, 0x190u), !v46) )
              {
                if ( v42 > 2 )
                  v3[48] = v44 + 1;
              }
            }
            if ( (v31 & 2) != 0 )
            {
              v47 = (int)(v3[49] - 1);
              v3[49] = (_BYTE *)v47;
              if ( v47 < 0 )
              {
                v56 = (int)v3[48];
                v3[49] = (_BYTE *)(&dword_14 + 3);
                v3[48] = (_BYTE *)--v56;
                if ( v56 < 0 )
                  goto LABEL_118;
              }
            }
            v48 = *((_BYTE *)v3 + 768);
LABEL_109:
            if ( *(_DWORD *)(v4 + 12) == -1 )
            {
              *(_BYTE *)(v1 + 95) = -4;
              goto LABEL_115;
            }
LABEL_111:
            if ( (v48 & 4) != 0 )
              v49 = -5;
            else
              v49 = -4;
            *(_BYTE *)(v1 + 95) = v49;
LABEL_115:
            v50 = *((unsigned __int8 *)v3 + 768);
            v51 = *(_BYTE **)v4;
            v52 = *(_BYTE **)(v4 + 4);
            if ( *(_DWORD *)(v4 + 36) != v50 )
              *(_DWORD *)(v4 + 36) = v50;
            v3[58] = v51;
            v3[59] = v52;
            if ( sub_39CF8(v3) )
            {
              sub_41F44((unsigned __int16 *)(v1 + 16), (const char *)v3 + 56);
              return (__int16 *)sub_39D44(v1);
            }
LABEL_118:
            v3[46] = 0;
            return sub_394A0((__int16 *)v1, 6);
          }
          if ( ((_BYTE)v3[192] & 1) != 0 )
          {
            memset(&tp.tm_wday, 0, 20);
            v53 = (int)v3[49];
            v54 = (int)v3[50];
            v55 = (int)v3[51];
            tp.tm_year = v41 - 1900;
            tp.tm_mon = v64 - 1;
            tp.tm_mday = v43;
            tp.tm_hour = v53;
            tp.tm_min = v54;
            tp.tm_sec = v55;
            switch ( v40 )
            {
              case 2:
                goto LABEL_137;
              case 3:
                v57 = v31 & 3;
                if ( v57 )
                {
                  if ( v57 > 2 )
                    tp.tm_isdst = 1;
                  else
                    tp.tm_isdst = -1;
                }
                break;
              case 1:
LABEL_137:
                tp.tm_isdst = v31 & 2;
                break;
              default:
                return (__int16 *)sub_64E00(5, "ARCRON: Invalid mode %d", v40);
            }
            v65[0] = mktime(&tp);
            v58 = gmtime(v65);
            v59 = v58;
            if ( !v58 )
            {
              v3[46] = 0;
              return sub_394A0((__int16 *)v1, 3);
            }
            v60 = *(_QWORD *)&v58->tm_mday;
            v61 = v58->tm_year + 1900;
            v3[47] = (_BYTE *)v61;
            v64 = HIDWORD(v60) + 1;
            LODWORD(v62) = sub_6EC68(v61, HIDWORD(v60) + 1, v60);
            HIDWORD(v62) = v59->tm_hour;
            LODWORD(v63) = v59->tm_min;
            HIDWORD(v63) = v59->tm_sec;
            *((_QWORD *)v3 + 24) = v62;
            *((_QWORD *)v3 + 25) = v63;
          }
          else
          {
            v3[48] = (_BYTE *)sub_6EC68(v41, v64, (int)v3[48]);
          }
          v48 = *((_BYTE *)v3 + 768);
          if ( !*(_DWORD *)(v1 + 76) || v38 != 3 || ((_BYTE)v3[192] & 2) == 0 )
            goto LABEL_109;
          goto LABEL_111;
        }
      }
      else
      {
        if ( v6 <= (int)v12 )
          break;
        if ( v5 > 15 )
          goto LABEL_38;
      }
      v9 = *((unsigned __int8 *)result + 1);
      result = (__int16 *)((char *)result + 1);
      v7 = v9;
    }
  }
  if ( !v5 )
    return result;
LABEL_38:
  v13 = *((unsigned __int8 *)v3 + 56);
  if ( v13 != 103 )
    goto LABEL_39;
  if ( v5 > 2 )
  {
    v20 = *((_BYTE *)v3 + 58);
    if ( (v20 & 0x70) == 0x30 )
    {
      v21 = v20 & 0xF;
      if ( v21 <= 5 )
      {
        v22 = *((_BYTE *)v3 + 57);
        if ( (v22 & 0x70) == 0x30 )
        {
          if ( (v22 & 0x7F) == 0x33 )
          {
            if ( *(_DWORD *)(v4 + 16) < (unsigned int)current_time )
            {
              sub_5F724(v65);
              sub_63138(v65[0], &tp);
              *(_DWORD *)(v4 + 16) = current_time + 65 - LOBYTE(tp.tm_hour);
              dword_106F10 = 0;
              dword_106F14 = 0;
            }
            dword_106F10 += v21;
            result = (__int16 *)sub_8B908(dword_106F10, ++dword_106F14);
            dword_106F18 = (int)result;
          }
          else if ( *(_DWORD *)(v4 + 24) )
          {
            v23 = dword_106F18;
            v10 = dword_106F18 == -1;
            *(_DWORD *)(v4 + 12) = dword_106F18;
            if ( v10 )
              v24 = "UNKNOWN, will use clock anyway";
            else
              v24 = v23 > 2 ? "OK, will use clock" : "TOO POOR, will not use clock";
            result = (__int16 *)sub_64E00(5, "ARCRON: sync finished, signal quality %d: %s", v23, v24);
            v25 = *(_DWORD *)(v4 + 12);
            *(_DWORD *)(v4 + 24) = 0;
            dword_106F18 = 0;
            dword_106F10 = 0;
            dword_106F14 = 0;
            if ( v25 <= 2 )
              *(_DWORD *)(v4 + 20) = current_time + 1620;
          }
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}
// 5CE70: conditional instruction was optimized away because r6.4==3
// 5CCE0: variable 'v45' is possibly undefined
// 5CCF4: variable 'v46' is possibly undefined
// 14: using guessed type int dword_14;
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// 106F10: using guessed type int dword_106F10;
// 106F14: using guessed type int dword_106F14;
// 106F18: using guessed type int dword_106F18;
// 108CA4: using guessed type int current_time;

//----- (0005CF78) --------------------------------------------------------
__int16 *__fastcall sub_5CF78(int a1, int a2)
{
  int v3; // r4
  char v4; // r2

  v3 = *(_DWORD *)(a2 + 84);
  if ( write(*(_DWORD *)(v3 + 28), "\r*toc\r", 6u) == 6 )
  {
    v4 = *(_BYTE *)(v3 + 768);
    ++*(_DWORD *)(v3 + 776);
    if ( (v4 & 2) == 0 )
      sub_5F724((int *)(v3 + 232));
  }
  else
  {
    sub_394A0((__int16 *)a2, 3);
  }
  if ( *(_DWORD *)(v3 + 216) == *(_DWORD *)(v3 + 220) )
    return sub_394A0((__int16 *)a2, 1);
  else
    return (__int16 *)sub_39D44(a2);
}
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (0005D048) --------------------------------------------------------
void __fastcall sub_5D048(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (0005D0C8) --------------------------------------------------------
int __fastcall sub_5D0C8(int a1, int a2)
{
  int v3; // r9
  int v4; // r7
  _DWORD *v5; // r0
  int v6; // r4
  _DWORD *v7; // r8
  char v9[20]; // [sp+0h] [bp-18h] BYREF

  sub_6C054((int)v9, 0x14u, "/dev/gps%d", a1);
  v3 = sub_3A298(v9, 0xDu, 1);
  if ( v3 <= 0 )
    return 0;
  v5 = sub_63BA4(0, 0xD4u, 0, 1);
  v6 = *(_DWORD *)(a2 + 84);
  v7 = v5;
  *(_DWORD *)(v6 + 20) = a2;
  *(_DWORD *)(v6 + 28) = v3;
  *(_DWORD *)(v6 + 12) = sub_5D1F8;
  *(_DWORD *)(v6 + 24) = 0;
  v4 = sub_18DF0((int *)(v6 + 8));
  if ( v4 )
  {
    v4 = 1;
    *(_DWORD *)v6 = v7;
    *(_BYTE *)(a2 + 95) = -20;
    *(_DWORD *)(v6 + 44) = "Austron 2201A GPS Receiver";
    strcpy((char *)(v6 + 764), "GPS");
    v7[52] = 0;
    *v7 = v7 + 1;
  }
  else
  {
    close(v3);
    *(_DWORD *)(v6 + 28) = -1;
    free(v7);
  }
  return v4;
}

//----- (0005D1F8) --------------------------------------------------------
__int16 *__fastcall sub_5D1F8(int a1)
{
  int v1; // r7
  int *v2; // r4
  const char *v3; // r5
  int v4; // r8
  __int16 *result; // r0
  __int16 *v6; // r3
  int v7; // r1
  int v8; // r1
  int v9; // r6
  int v10; // r3
  int v11; // r2
  int v12; // r3
  size_t v13; // r2
  __int16 *v14; // r11
  int v15; // r5
  int v16; // r2
  char *v17; // r10
  __int16 *v18; // r3
  size_t v19; // r0
  int v20; // r3
  int v21; // [sp+14h] [bp-18h]
  _DWORD v22[2]; // [sp+1Ch] [bp-10h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(int **)(v1 + 84);
  v3 = (const char *)(v2 + 14);
  v4 = *v2;
  result = (__int16 *)sub_39EE4(a1, (bool *)v2 + 56, 128, v22);
  v2[46] = (int)result;
  if ( result )
  {
    v6 = result;
    if ( (v2[192] & 2) != 0 )
    {
      v7 = v22[1];
      v2[58] = v22[0];
      v2[59] = v7;
    }
    v8 = *(_DWORD *)(v4 + 204);
    if ( v8 <= 0 )
    {
      if ( result == (__int16 *)((char *)&dword_0 + 1) )
      {
        result = (__int16 *)strtol(v3, 0, 10);
        *(_DWORD *)(v4 + 204) = result;
      }
      else
      {
        v9 = v4 + 4;
        sub_41F44((unsigned __int16 *)(v1 + 16), (const char *)(v4 + 4));
        *(_BYTE *)(v4 + 4) = 0;
        v10 = v2[46];
        *(_DWORD *)v4 = v4 + 4;
        if ( v10 > 18
          && sscanf(v3, "%2d:%3d:%2d:%2d:%2d.%3ld", v2 + 47, v2 + 48, v2 + 49, v2 + 50, v2 + 51, v2 + 52) == 6 )
        {
          v11 = *((unsigned __int8 *)v2 + 58);
          v12 = (_DWORD)&unk_F4240 * v2[52];
          if ( v11 == 58 )
            *((_BYTE *)v2 + 40) = 0;
          v2[52] = v12;
          if ( v11 != 58 )
            *((_BYTE *)v2 + 40) = 3;
          if ( sub_39CF8(v2) )
          {
            result = *(__int16 **)v4;
            v13 = v2[46];
            if ( (int)(*(_DWORD *)v4 - v9 + v13) <= 198 )
            {
              result = (__int16 *)memcpy(result, v3, v13);
              v14 = *(__int16 **)v4;
              v15 = v2[46];
              v16 = *(_DWORD *)v4 + v15;
              *(_DWORD *)v4 = v16;
              v21 = v16;
              if ( (v2[192] & 8) != 0 )
              {
                result = (__int16 *)strlen(&aItf[30 * *(_DWORD *)(v4 + 208)]);
                if ( (int)result + v21 - v9 + 1 <= 198 )
                {
                  *(_DWORD *)v4 = v21 + 1;
                  *((_BYTE *)v14 + v15) = 32;
                  v17 = (char *)result - 1;
                  memcpy(*(void **)v4, &aItf[30 * *(_DWORD *)(v4 + 208)], (size_t)result);
                  v18 = *(__int16 **)v4;
                  *(_DWORD *)v4 += v17;
                  v17[(_DWORD)v18] = 0;
                  v19 = strlen(&aItf[30 * *(_DWORD *)(v4 + 208)]);
                  result = (__int16 *)write(v2[7], &aItf[30 * *(_DWORD *)(v4 + 208)], v19);
                  v20 = *(_DWORD *)(v4 + 208) + 1;
                  *(_DWORD *)(v4 + 208) = v20;
                  if ( !aItf[30 * v20] )
                    *(_DWORD *)(v4 + 208) = 0;
                }
              }
            }
          }
          else
          {
            return sub_394A0((__int16 *)v1, 6);
          }
        }
        else
        {
          return sub_394A0((__int16 *)v1, 2);
        }
      }
    }
    else
    {
      result = *(__int16 **)v4;
      *(_DWORD *)(v4 + 204) = v8 - 1;
      if ( (int)v6 + (int)result - v4 - 4 <= 198 )
      {
        *(_DWORD *)v4 = (char *)result + 1;
        *(_BYTE *)result = 32;
        result = (__int16 *)memcpy(*(void **)v4, v3, v2[46] + 1);
        *(_DWORD *)v4 += v2[46];
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0005D4C8) --------------------------------------------------------
void sub_5D4C8()
{
  ;
}

//----- (0005D50C) --------------------------------------------------------
void __fastcall sub_5D50C(int a1, int a2)
{
  int v2; // r0
  void *v3; // r5

  v2 = *(_DWORD *)(a2 + 84);
  v3 = *(void **)v2;
  if ( *(_DWORD *)(v2 + 28) != -1 )
    sub_18E64(v2 + 8);
  if ( v3 )
    free(v3);
}

//----- (0005D58C) --------------------------------------------------------
int __fastcall sub_5D58C(int a1, int a2)
{
  int v3; // r8
  int v4; // r7
  void *v5; // r0
  _DWORD *v6; // r4
  void *v7; // r9
  char v9[20]; // [sp+0h] [bp-1Ch] BYREF

  sub_6C054((int)v9, 0x14u, "/dev/chronolog%d", a1);
  v3 = sub_3A298(v9, 0xBu, 0);
  if ( v3 <= 0 )
    return 0;
  v5 = sub_63BA4(0, 0x1Cu, 0, 1);
  v6 = *(_DWORD **)(a2 + 84);
  v7 = v5;
  *v6 = v5;
  v6[5] = a2;
  v6[7] = v3;
  v6[3] = sub_5D6B4;
  v6[6] = 0;
  v4 = sub_18DF0(v6 + 2);
  if ( v4 )
  {
    v4 = 1;
    *(_BYTE *)(a2 + 95) = -13;
    v6[11] = "Chrono-log K";
    v6[191] = *(_DWORD *)"chronolog";
  }
  else
  {
    close(v3);
    v6[7] = -1;
    free(v7);
    *v6 = 0;
  }
  return v4;
}

//----- (0005D6B4) --------------------------------------------------------
__int16 *__fastcall sub_5D6B4(int a1)
{
  int v1; // r7
  unsigned __int8 **v2; // r8
  unsigned __int8 *v3; // r4
  const char *v4; // r5
  __int16 *result; // r0
  __int16 *v6; // r3
  int v7; // r2
  __int16 **v8; // r4
  __int16 *v9; // r1
  unsigned __int8 *v10; // r0
  unsigned __int8 *v11; // r1
  __int16 *v12; // r1
  int v13; // r3
  struct tm *v14; // r0
  int v15; // r6
  int v16; // lr
  struct tm *v17; // r0
  struct tm *v18; // r6
  int v19; // r0
  unsigned __int8 *tm_hour; // r1
  __int64 v21; // r2
  unsigned __int8 *v22; // r1
  int v23; // [sp+8h] [bp-4Ch] BYREF
  int v24; // [sp+Ch] [bp-48h] BYREF
  int v25; // [sp+10h] [bp-44h] BYREF
  time_t v26; // [sp+14h] [bp-40h] BYREF
  __int16 *v27; // [sp+18h] [bp-3Ch] BYREF
  __int16 *v28; // [sp+1Ch] [bp-38h]
  _DWORD s[11]; // [sp+20h] [bp-34h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(unsigned __int8 ***)(v1 + 84);
  v4 = (const char *)(v2 + 14);
  v3 = *v2;
  result = (__int16 *)sub_39EE4(a1, (bool *)v2 + 56, 128, &v27);
  v6 = result;
  if ( result )
  {
    v10 = (unsigned __int8 *)*((_DWORD *)v3 + 1);
    v11 = (unsigned __int8 *)*((_DWORD *)v3 + 2);
    v2[46] = (unsigned __int8 *)v6;
    v2[58] = v10;
    v2[59] = v11;
    v12 = v28;
    *((_DWORD *)v3 + 1) = v27;
    *((_DWORD *)v3 + 2) = v12;
    *v3 = 1;
    result = (__int16 *)sscanf(v4, "Y %d/%d/%d", v3 + 16, v3 + 24, v3 + 20);
    if ( result )
    {
      v13 = *((_DWORD *)v3 + 4);
      if ( v13 <= 68 )
        v13 += 100;
      *((_DWORD *)v3 + 4) = v13;
    }
    else
    {
      result = (__int16 *)sscanf(v4, "Z %02d:%02d:%02d", &v23, &v24, &v25);
      if ( result == (__int16 *)((char *)&dword_0 + 3) )
      {
        v14 = (struct tm *)memset(s, 0, sizeof(s));
        v15 = *((_DWORD *)v3 + 4);
        v16 = *((_DWORD *)v3 + 5);
        s[4] = *((_DWORD *)v3 + 6) - 1;
        s[5] = v15;
        s[3] = v16;
        s[2] = v23;
        s[1] = v24;
        s[0] = v25;
        s[8] = -1;
        v26 = mktime(v14);
        v17 = gmtime(&v26);
        v18 = v17;
        if ( v17 )
        {
          v19 = sub_6EC68(v17->tm_year + 1900, v17->tm_mon + 1, v17->tm_mday);
          tm_hour = (unsigned __int8 *)v18->tm_hour;
          LODWORD(v21) = v18->tm_min;
          HIDWORD(v21) = v18->tm_sec;
          v2[48] = (unsigned __int8 *)v19;
          v2[49] = tm_hour;
          *((_QWORD *)v2 + 25) = v21;
          if ( sub_39CF8(v2) )
          {
            v22 = v2[59];
            v2[56] = v2[58];
            v2[57] = v22;
            sub_39D44(v1);
            result = (__int16 *)sub_41F44((unsigned __int16 *)(v1 + 16), v4);
            v3[12] = (unsigned __int8)v2[49];
          }
          else
          {
            return sub_394A0((__int16 *)v1, 6);
          }
        }
        else
        {
          return sub_394A0((__int16 *)v1, 3);
        }
      }
    }
  }
  else
  {
    v7 = *v3;
    if ( *v3 )
      *v3 = 0;
    else
      LOBYTE(v6) = 1;
    if ( !v7 )
    {
      *v3 = (unsigned __int8)v6;
      v8 = (__int16 **)(v3 + 4);
      result = v27;
      v9 = v28;
      *v8 = v27;
      v8[1] = v9;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);

//----- (0005D8D0) --------------------------------------------------------
int __fastcall sub_5D8D0(int a1, int a2)
{
  int result; // r0

  result = _stack_chk_guard;
  ++*(_DWORD *)(*(_DWORD *)(a2 + 84) + 776);
  return result;
}

//----- (0005D924) --------------------------------------------------------
Elf32_Dyn **__fastcall sub_5D924(Elf32_Dyn **result)
{
  Elf32_Dyn *v1; // r1
  __int32 d_tag; // r5
  int v3; // r9
  int v4; // r3
  int *v5; // r11
  int v6; // r4
  int v7; // lr
  int *v8; // r6
  int v9; // t1
  int v10; // r1
  int v11; // r2
  bool v12; // zf
  int v13; // r2
  int v14; // r8
  _DWORD *v15; // r6
  int v16; // r12
  int v17; // r2
  int v18; // r2
  int v19; // r0
  int v20; // r1
  int v21; // r7
  _BYTE *v22; // r0
  int v23; // r2
  int v24; // r2
  int v25; // r1
  __int32 v26; // r8
  int v27; // r7
  unsigned int v28; // r4
  const char *v29; // r6
  size_t v30; // r0
  int v31; // t1
  __int32 v32; // r2
  int v33; // r12
  __int32 v34; // r10
  const char *v35; // r7
  int v36; // r8
  unsigned int v37; // r6
  size_t v38; // r0
  int v39; // t1
  int v40; // r3
  int v41; // r9
  int v42; // r7
  unsigned int v43; // r3
  __int32 v44; // r10
  int v45; // r12
  int v46; // r0
  int v47; // r1
  int v48; // lr
  __int32 v49; // r2
  int v50; // r1
  unsigned int v51; // r0
  int v52; // r1
  int v53; // r2
  bool v54; // cf
  int v55; // r2
  int v56; // lr
  int v57; // r4
  int v58; // lr
  _BYTE *v59; // r3
  char v60; // t1
  char v61; // r2
  unsigned int v62; // r3
  int v63; // r8
  int v64; // r2
  int i; // r1
  int v66; // t1
  char v67; // r3
  char *v68; // r2
  int v69; // r2
  int v70; // r2
  int v71; // [sp+14h] [bp-98h]
  Elf32_Dyn *v72; // [sp+28h] [bp-84h]
  Elf32_Dyn **v73; // [sp+2Ch] [bp-80h]
  int v74; // [sp+34h] [bp-78h]
  int v75; // [sp+38h] [bp-74h]
  char s[12]; // [sp+48h] [bp-64h] BYREF
  char v77[80]; // [sp+54h] [bp-58h] BYREF

  v1 = result[21];
  d_tag = v1->d_tag;
  v73 = result;
  v72 = v1;
  v3 = *(_DWORD *)(v1->d_tag + 1112);
  v4 = *(_DWORD *)(v1->d_tag + 920);
  if ( v3 <= 8 )
  {
    *(_DWORD *)(d_tag + 920) = v4 | 1;
    return result;
  }
  v5 = (int *)(d_tag + 1064);
  v6 = 0;
  v7 = 0;
  v8 = (int *)(d_tag + 1064);
  *(_DWORD *)(d_tag + 1120) = 0;
  do
  {
    v9 = *v8++;
    v10 = 8;
    result = 0;
    v11 = v9 ^ v8[4];
    do
    {
      v12 = (v11 & 1) == 0;
      v11 >>= 1;
      if ( v12 )
        result = (Elf32_Dyn **)((char *)result + 1);
      else
        result = (Elf32_Dyn **)((char *)result - 1);
      --v10;
    }
    while ( v10 );
    ++v6;
    v7 += (int)result;
    *(_DWORD *)(d_tag + 1120) = v7;
  }
  while ( v6 != 5 && v6 != v3 - 5 );
  if ( v7 > 27 )
  {
    v13 = *(_DWORD *)(d_tag + 1076);
    v14 = 0;
    v15 = (_DWORD *)(d_tag + 1064);
    v16 = -1;
    *(_DWORD *)(d_tag + 1124) = 0;
    v17 = v13 & 0xF;
    v74 = 0;
    while ( 1 )
    {
      v18 = v17 ^ 0x63;
      v19 = 8;
      v20 = 0;
      do
      {
        v12 = (v18 & 1) == 0;
        v18 >>= 1;
        if ( v12 )
          ++v20;
        else
          --v20;
        --v19;
      }
      while ( v19 );
      v21 = 0;
      if ( v3 > v16 + 9 )
        v6 = v15[8];
      v22 = v15;
      v23 = 16 * v15[4];
      if ( v3 > v16 + 9 )
        v6 &= 0xFu;
      v23 = (unsigned __int8)v23;
      if ( v3 > v16 + 9 )
        v23 = (unsigned __int8)v23 | v6;
      v6 = 8;
      v24 = v23 ^ 0x63;
      do
      {
        v12 = (v24 & 1) == 0;
        v24 >>= 1;
        if ( v12 )
          ++v21;
        else
          --v21;
        --v6;
      }
      while ( v6 );
      v25 = v20 + v21;
      if ( v25 > v14 )
        v74 = v16;
      ++v16;
      if ( v25 > v14 )
      {
        v14 = v25;
        *(_DWORD *)(d_tag + 1124) = v25;
      }
      if ( v16 == 2 )
        break;
      ++v15;
      v17 = (unsigned __int8)(16 * *v22) | v15[3] & 0xF;
    }
    v32 = d_tag + 4 * v74;
    v33 = (unsigned __int8)*(_DWORD *)(v32 + 1080) >> 4;
    if ( (unsigned int)(v33 - 2) <= 7 && v3 > v74 + 9 )
    {
      v69 = (unsigned __int8)*(_DWORD *)(v32 + 1100) >> 4;
      if ( v33 != v69 )
        v69 = 0;
      v75 = v69;
    }
    else
    {
      v75 = 0;
    }
    v71 = v14;
    v34 = d_tag + 1060;
    v35 = v77;
    v36 = 0;
    v37 = 80;
    sub_6C054(
      (int)v77,
      0x50u,
      "chuA %04x %4.0f %2d %2d %2d %2d %1d ",
      v4,
      *(double *)(d_tag + 1136),
      v3,
      v7,
      v74,
      v71,
      v75);
    do
    {
      v38 = strlen(v35);
      if ( v38 + 1 > v37 )
      {
        sub_64E00(3, "chu_a() fatal out buffer");
        exit(1);
      }
      v37 -= v38;
      v35 += v38;
      ++v36;
      v39 = *(_DWORD *)(v34 + 4);
      v34 += 4;
      sub_6C054((int)v35, v37, "%02x", v39);
    }
    while ( v3 != v36 );
    if ( (v72[96].d_tag & 8) != 0 )
      sub_41F44((unsigned __int16 *)v73 + 8, v77);
    v40 = *(_DWORD *)(d_tag + 920);
    if ( *(int *)(d_tag + 1124) > 7 )
    {
      if ( v75 )
      {
        *(_DWORD *)(d_tag + 920) = v40 | 0x100;
        v41 = v75 + 30;
        v72[25].d_un.d_val = v75 + 30;
        *(_DWORD *)(d_tag + 912) = v75 + 30;
        if ( v74 == -1 )
        {
          v41 = *(_DWORD *)(d_tag + 904);
          v42 = 0;
          v43 = *(_DWORD *)(d_tag + 908);
        }
        else
        {
          v42 = v74;
          v43 = 0;
          if ( v74 )
            v42 = 1;
        }
        v44 = d_tag + 8 * v42;
        do
        {
          if ( v42 - 9 > v74 )
            break;
          v45 = *(_DWORD *)(d_tag + 1108);
          v46 = *(_DWORD *)(v44 + 320);
          v47 = *(_DWORD *)(v44 + 324);
          v48 = 0;
          ++v42;
          v44 += 8;
          v49 = d_tag + 8 * v45;
          *(_DWORD *)(v49 + 408) = v46;
          *(_DWORD *)(v49 + 412) = v47;
          v50 = v46;
          v51 = *(_DWORD *)(v49 + 412);
          v52 = v50 - v41;
          if ( v51 < v43 )
            --v52;
          *(_DWORD *)(v49 + 412) = v51 - v43;
          *(_DWORD *)(v49 + 408) = v52;
          v53 = *(_DWORD *)(d_tag + 908);
          v54 = __CFADD__(v53, v43);
          v43 += v53;
          v55 = *(_DWORD *)(d_tag + 904);
          if ( v54 )
            v48 = 1;
          if ( v45 <= 58 )
            *(_DWORD *)(d_tag + 1108) = v45 + 1;
          v41 += v48 + v55;
        }
        while ( v36 > v42 );
        v56 = *(_DWORD *)(d_tag + 1116);
        v57 = 0;
        if ( v56 < v75 )
        {
          v58 = v75 - v56;
          do
          {
            v59 = (_BYTE *)(d_tag + 159);
            do
            {
              v60 = *--v59;
              v61 = v59[160];
              v59[1] = v60;
              v59[161] = v61;
            }
            while ( v59 != (_BYTE *)(d_tag + 144) );
            ++v57;
            *(_BYTE *)(d_tag + 304) = 0;
            *(_BYTE *)(d_tag + 144) = 0;
          }
          while ( v58 != v57 );
          *(_DWORD *)(d_tag + 1116) = v75;
        }
      }
      else
      {
        *(_DWORD *)(d_tag + 920) = v40 | 0x20;
      }
      v62 = -2 * v74;
      v63 = -2 * v74 + 2 * v36;
      do
      {
        if ( v62 <= 0x12 )
        {
          v64 = (unsigned __int8)*v5 >> 4;
          ++*(_BYTE *)(d_tag + 16 * v62 + (*v5 & 0xF));
          ++*(_BYTE *)(d_tag + 16 * (v62 + 1) + v64);
        }
        v62 += 2;
        ++v5;
      }
      while ( v62 != v63 );
      ++*(_DWORD *)(d_tag + 1128);
    }
    else
    {
      *(_DWORD *)(d_tag + 920) = v40 | 0x10;
    }
  }
  else
  {
    if ( v7 >= -27 )
    {
      *(_DWORD *)(d_tag + 920) = v4 | 2;
      return result;
    }
    v26 = d_tag + 1060;
    v27 = 0;
    v28 = 80;
    v29 = v77;
    sub_6C054((int)v77, 0x50u, "chuB %04x %4.0f %2d %2d ", v4, *(double *)(d_tag + 1136), v3, -v7);
    do
    {
      v30 = strlen(v29);
      if ( v30 + 1 > v28 )
      {
        sub_64E00(3, "chu_b() fatal out buffer");
        exit(1);
      }
      v28 -= v30;
      v29 += v30;
      ++v27;
      v31 = *(_DWORD *)(v26 + 4);
      v26 += 4;
      sub_6C054((int)v29, v28, "%02x", v31);
    }
    while ( v3 != v27 );
    if ( (v72[96].d_tag & 8) != 0 )
      sub_41F44((unsigned __int16 *)v73 + 8, v77);
    if ( *(int *)(d_tag + 1120) < -39 )
    {
      for ( i = 0; i != 10; i += 2 )
      {
        v66 = *v5++;
        v67 = a0123456789abcd[(unsigned __int8)v66 >> 4];
        s[i] = a0123456789abcd[v66 & 0xF];
        v68 = &s[i];
        v68[1] = v67;
      }
      if ( sscanf(s, "%1x%1d%4d%2d%2x", d_tag + 1148, d_tag + 1152, &v72[23].d_un, d_tag + 1156, d_tag + 1160) == 5 )
      {
        v70 = *(_DWORD *)(d_tag + 1148);
        *(_DWORD *)(d_tag + 920) |= 0x200u;
        if ( (v70 & 8) != 0 )
          *(_DWORD *)(d_tag + 1152) = -*(_DWORD *)(d_tag + 1152);
      }
      else
      {
        *(_DWORD *)(d_tag + 920) |= 8u;
      }
    }
    else
    {
      *(_DWORD *)(d_tag + 920) |= 4u;
    }
  }
  result = &GLOBAL_OFFSET_TABLE_;
  if ( v73[179] != (Elf32_Dyn *)current_time )
    v73[180] = (Elf32_Dyn *)(current_time + 10);
  return result;
}
// B5584: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;
// 108CA4: using guessed type int current_time;

//----- (0005DFB4) --------------------------------------------------------
int __fastcall sub_5DFB4(int a1)
{
  __int64 v1; // d0
  _DWORD *v3; // r7
  _DWORD *v4; // r4
  int v5; // r0
  int v6; // r8
  double v7; // d8
  int v8; // r3
  int v9; // r1
  int v10; // r2
  double *v11; // r12
  double *v12; // lr
  int v13; // lr
  double v14; // d6
  double v15; // d7
  double v16; // d7
  int v17; // r2
  int v18; // r2
  _BOOL4 v19; // r2
  int v20; // r3
  int v21; // r1
  bool v22; // cc
  int v23; // r1
  int v24; // r3

  v3 = *(_DWORD **)(a1 + 84);
  v4 = (_DWORD *)*v3;
  v5 = *(_DWORD *)(*v3 + 932);
  if ( v5 <= 0 )
    return 0;
  v7 = 0.0;
  v8 = *v3;
  v9 = 0;
  v10 = 5 * v4[234];
  v11 = (double *)&v4[10 * v4[234]];
  v12 = (double *)&v4[2 * v10 + 236 + 2 * *((_DWORD *)v11 + 244)];
  v11[121] = v11[121] - *v12;
  *(_QWORD *)v12 = v1;
  v13 = *((_DWORD *)v11 + 244);
  v14 = v11[121];
  v15 = *(double *)&v4[2 * v10 + 236 + 2 * v13];
  *((_DWORD *)v11 + 245) = 0;
  v11[121] = v15 + v14;
  *((_DWORD *)v11 + 244) = (v13 + 1) % 3;
  do
  {
    v16 = *(double *)(v8 + 968);
    v8 += 40;
    v17 = *(_DWORD *)(v8 + 940) + 1;
    *(_DWORD *)(v8 + 940) = v17;
    if ( v16 > v7 )
    {
      v17 = v4[230];
      v4[234] = v9;
    }
    ++v9;
    if ( v16 > v7 )
    {
      v7 = v16;
      v4[230] = v17 | 0x800;
    }
  }
  while ( v9 != 3 );
  v18 = v4[235] + 1;
  v4[235] = v18 % 5;
  if ( v18 % 5 )
    v19 = v7 == 0.0;
  else
    v19 = 1;
  if ( v19 )
  {
    v20 = v4[245];
    v21 = *(_DWORD *)(a1 + 76);
    v22 = v20 <= 0;
    if ( v20 <= 0 )
      v20 = 0;
    else
      v19 = 0;
    if ( !v22 )
      v4[234] = v19;
    v23 = v21 & 0x7F;
    if ( v20 < v4[255] )
    {
      v20 = v4[255];
      v4[234] = 1;
    }
    if ( v4[265] > v20 )
      v4[234] = 2;
    v6 = sub_63DC0(v5, v23);
    sub_6C054((int)(v4 + 231), 5u, "CHU%d", v4[234]);
    v3[191] = v4[231];
    *(_DWORD *)(a1 + 112) = v4[231];
    if ( v7 == 0.0 )
    {
      v24 = v4[230];
      if ( (v24 & 0x800) != 0 )
      {
        v4[230] = v24 & 0xFFFFF7FF;
        sub_394A0((__int16 *)a1, 4);
      }
    }
  }
  else
  {
    v6 = sub_63DC0(v5, *(_DWORD *)(a1 + 76) & 0x7F);
    sub_6C054((int)(v4 + 231), 5u, "CHU%d", v4[234]);
    v3[191] = v4[231];
    *(_DWORD *)(a1 + 112) = v4[231];
  }
  return v6;
}
// 5E038: variable 'v1' is possibly undefined

//----- (0005E260) --------------------------------------------------------
void __fastcall sub_5E260(int a1, int a2)
{
  _DWORD **v2; // r0
  _DWORD *v3; // r4
  int v4; // r0

  v2 = *(_DWORD ***)(a2 + 84);
  v3 = *v2;
  if ( *v2 )
  {
    sub_18E64((int)(v2 + 2));
    v4 = v3[233];
    if ( v4 > 0 )
      close(v4);
    free(v3);
  }
}

//----- (0005E2F0) --------------------------------------------------------
int __fastcall sub_5E2F0(int a1, int a2, int a3, int a4)
{
  int *v4; // r10
  _DWORD *v7; // r8
  unsigned int v8; // r1
  int v9; // r3
  int v10; // r12
  int v11; // r0
  unsigned int v12; // lr
  int *v13; // r9
  int v14; // r12
  unsigned int v15; // lr
  int v16; // r1
  __int64 v17; // r2
  double v18; // r0
  double v19; // d0
  int v20; // r2
  double v21; // r0
  int v22; // r12
  int v23; // r3
  _DWORD *v24; // r2
  double v25; // r0
  double v26; // d0
  int v27; // r2
  __int64 v29; // [sp+0h] [bp-18h]

  v7 = **(_DWORD ***)(a1 + 84);
  v8 = v7[225];
  v9 = v7[224];
  v10 = v7[222];
  v11 = v9 | v8;
  v12 = v7[223];
  if ( *((_QWORD *)v7 + 112) )
  {
    v13 = v7 + 224;
  }
  else
  {
    v4 = v7 + 222;
    v13 = v7 + 224;
    v11 = v7[222];
    v8 = v7[223];
  }
  if ( *((_QWORD *)v7 + 112) )
  {
    v4 = v7 + 222;
  }
  else
  {
    *v13 = v11;
    v13[1] = v8;
    v9 = v11;
    v8 = v7[225];
  }
  v14 = v10 - v9;
  LODWORD(v29) = 0;
  if ( v12 < v8 )
    --v14;
  v15 = v12 - v8;
  HIDWORD(v29) = v14;
  v16 = v4[1];
  v17 = v29 + v15;
  *v13 = *v4;
  v13[1] = v16;
  if ( v14 >= 0 )
  {
    LODWORD(v19) = sub_8BEC4(v17);
    HIDWORD(v19) = HIDWORD(v18);
    LODWORD(v18) = -32;
    v21 = ldexp(v18, v20);
    if ( v19 <= 0.403333333 )
      goto LABEL_11;
LABEL_18:
    sub_5D924((Elf32_Dyn **)a1);
    goto LABEL_12;
  }
  LODWORD(v26) = sub_8BEC4(-v17);
  HIDWORD(v26) = HIDWORD(v25);
  LODWORD(v25) = -32;
  v21 = ldexp(v25, v27);
  v19 = -v26;
  if ( v19 > 0.403333333 )
    goto LABEL_18;
LABEL_11:
  if ( v19 > 0.0916666667 )
  {
LABEL_12:
    v22 = 1;
    v23 = 0;
    goto LABEL_13;
  }
  v23 = v7[278];
  if ( v23 > 10 )
    return LODWORD(v21);
  v22 = v23 + 1;
LABEL_13:
  LODWORD(v21) = a3;
  v24 = &v7[2 * v23 + 80];
  v7[v23 + 266] = a2;
  *v24 = a3;
  v24[1] = a4;
  v7[278] = v22;
  return LODWORD(v21);
}
// 5E380: variable 'v4' is possibly undefined
// 5E3A4: variable 'v18' is possibly undefined
// 5E3AC: variable 'v20' is possibly undefined
// 5E430: variable 'v25' is possibly undefined
// 5E438: variable 'v27' is possibly undefined

//----- (0005E478) --------------------------------------------------------
int __fastcall sub_5E478(int a1, int a2)
{
  int v4; // r0
  int v5; // r9
  int v6; // r10
  char *v7; // r0
  char **v8; // r5
  char *v9; // r4
  int v10; // r8
  double *v11; // r2
  double v12; // d6
  double *v13; // r1
  int v14; // r3
  double v15; // d7
  int v16; // r3
  int v17; // r0
  int v19; // r0
  char v20[20]; // [sp+0h] [bp-1Ch] BYREF

  v4 = sub_60AC0("/dev/audio", 240, a1);
  v5 = v4;
  if ( v4 < 0 )
  {
    sub_6C054((int)v20, 0x14u, "/dev/chu%d", a1);
    v19 = sub_3A298(v20, 7u, 32);
    v6 = v19;
    if ( v19 < 0 )
      return 0;
  }
  else
  {
    v6 = v4;
  }
  v7 = (char *)sub_63BA4(0, 0x1240u, 0, 1);
  v8 = *(char ***)(a2 + 84);
  v9 = v7;
  *v8 = v7;
  v8[5] = (char *)a2;
  v8[7] = (char *)v6;
  v8[3] = (char *)sub_5EC18;
  v8[6] = 0;
  v10 = sub_18DF0((int *)v8 + 2);
  if ( v10 )
  {
    *(_BYTE *)(a2 + 95) = -10;
    v8[11] = "CHU Audio/Modem Receiver";
    sub_6D4DC(v9 + 924, "CHU", 5);
    v8[191] = (char *)*((_DWORD *)v9 + 231);
    *((_DWORD *)v9 + 226) = 0;
    *((_DWORD *)v9 + 291) = v5;
    *((_DWORD *)v9 + 227) = 157482134;
    *((_DWORD *)v9 + 286) = 127;
    *((_QWORD *)v9 + 274) = 0;
    *((_QWORD *)v9 + 146) = 0;
    *((_QWORD *)v9 + 147) = 0x3FF0000000000000LL;
    *((_QWORD *)v9 + 275) = 0xBFF0000000000000LL;
    *((_QWORD *)v9 + 148) = 0x4008000000000000LL;
    *((_QWORD *)v9 + 276) = 0xC008000000000000LL;
    v11 = (double *)(v9 + 1192);
    *((_QWORD *)v9 + 149) = 0x4014000000000000LL;
    v12 = 2.0;
    v13 = (double *)(v9 + 2224);
    v14 = 3;
    *((_QWORD *)v9 + 277) = 0xC014000000000000LL;
    while ( ++v14 != 128 )
    {
      v15 = *v11 + v12;
      if ( (v14 & 0xF) == 0 )
        v12 = v12 + v12;
      v11[1] = v15;
      ++v11;
      *v13++ = -v15;
    }
    v16 = *(_DWORD *)(a2 + 76);
    *((_DWORD *)v9 + 808) = 0;
    *((_DWORD *)v9 + 809) = (char *)&loc_83124 + 2;
    if ( v16 )
    {
      if ( (v16 & 0x80) != 0 )
        v17 = sub_63F68((int)"/dev/icom", 9u);
      else
        v17 = sub_63F68((int)"/dev/icom", 0xDu);
      *((_DWORD *)v9 + 233) = v17;
    }
    else
    {
      v17 = *((_DWORD *)v9 + 233);
    }
    if ( v17 > 0 )
    {
      v10 = 1;
      if ( sub_5DFB4(a2) )
      {
        sub_64E00(5, "icom: radio not found");
        close(*((_DWORD *)v9 + 233));
        *((_DWORD *)v9 + 233) = 0;
      }
      else
      {
        sub_64E00(5, "icom: autotune enabled");
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    close(v6);
    v8[7] = (char *)-1;
    free(v9);
    *v8 = 0;
  }
  return v10;
}

//----- (0005E78C) --------------------------------------------------------
__int16 *__fastcall sub_5E78C(int a1, int a2)
{
  int *v2; // r7
  int v3; // r6
  int v4; // r1
  __int16 *result; // r0
  int v6; // r4
  char *v7; // r9
  int v8; // r5
  int v9; // r8
  int v10; // lr
  int v11; // r7
  int v12; // r10
  int v13; // r0
  unsigned __int8 *v14; // r4
  int v15; // r1
  int v16; // r2
  int v17; // r12
  int v18; // r6
  int v19; // t1
  int v20; // t1
  int v21; // r3
  bool v22; // cc
  int v23; // r4
  int v24; // r0
  int v25; // r2
  int v26; // r3
  double v27; // d8
  int v28; // r3
  int v29; // r12
  int v30; // r3
  size_t v31; // r0
  int v32; // r3
  _DWORD *v33; // r3
  int v34; // r12
  __int16 *v35; // r3
  char *v36; // r2
  int v37; // r1
  int v38; // r3
  int v39; // r1
  bool v40; // zf
  int v41; // r3
  unsigned int v43; // [sp+48h] [bp-34h]
  int *v44; // [sp+4Ch] [bp-30h]
  int *v45; // [sp+54h] [bp-28h]
  int v46; // [sp+58h] [bp-24h]
  int v47; // [sp+5Ch] [bp-20h]
  int v48; // [sp+60h] [bp-1Ch] BYREF
  unsigned int v49; // [sp+64h] [bp-18h]
  char v50[12]; // [sp+68h] [bp-14h] BYREF

  v2 = *(int **)(a2 + 84);
  v3 = *v2;
  v4 = *(_DWORD *)(*v2 + 912) + 1;
  result = (__int16 *)_stack_chk_guard;
  v6 = v4 % 60;
  *(_DWORD *)(*v2 + 912) = v4 % 60;
  if ( v4 != 60 * (v4 / 60) )
    return result;
  v7 = v50;
  v8 = v4 % 60;
  sub_5D924((Elf32_Dyn **)a2);
  v44 = *(int **)(a2 + 84);
  v9 = *v44;
  v45 = v2;
  v10 = *v44 - 1;
  v11 = *(_DWORD *)(*v44 + 1128);
  v12 = *v44 + 143;
  v46 = v3;
  v47 = v6;
  v43 = (current_time + 30 - *(_DWORD *)(a2 + 704)) / 0x3Cu;
  do
  {
    v13 = 0;
    v14 = (unsigned __int8 *)(v10 + 161);
    v15 = 0;
    v16 = 0;
    v17 = v10;
    do
    {
      v19 = *v14++;
      v18 = v19;
      v20 = *(unsigned __int8 *)++v17;
      v21 = v20 + v18;
      v22 = v20 + v18 <= v15;
      if ( v20 + v18 > v15 )
        v18 = v16;
      ++v16;
      if ( v22 )
      {
        v18 = v13;
        v21 = v15;
      }
      v13 = v18;
      v15 = v21;
    }
    while ( v16 != 16 );
    v10 += 16;
    if ( v11 >= v21 )
      v16 = *(_DWORD *)(v9 + 920);
    v8 += v21;
    if ( v11 >= v21 )
      *(_DWORD *)(v9 + 920) = v16 | 0x40;
    *v7++ = a0123456789abcd[v18];
  }
  while ( v10 != v12 );
  v23 = v47;
  v24 = sscanf(v50, "%1x%3d%2d%2d", &v48, v44 + 48, v44 + 49, v44 + 50);
  if ( v24 != 4 )
    v26 = *(_DWORD *)(v9 + 920);
  v27 = (double)v8;
  if ( v24 != 4 )
    *(_DWORD *)(v9 + 920) = v26 | 0x40;
  if ( *(int *)(v9 + 1108) <= 19 )
    *(_DWORD *)(v9 + 920) |= 0x80u;
  v28 = *(_DWORD *)(v46 + 920);
  v29 = (v28 & 0x14) != 0;
  if ( (v28 & 0x28) != 0 )
    v29 |= 2u;
  if ( (v28 & 0x40) != 0 )
    v29 |= 4u;
  if ( (v28 & 0x80) != 0 )
    v29 |= 8u;
  if ( (v28 & 0x200) != 0 && v27 >= 50.0 )
  {
    *(_DWORD *)(v46 + 920) = v28 | 0x400;
    goto LABEL_29;
  }
  if ( (v28 & 0x400) != 0 )
  {
LABEL_29:
    if ( (*(_DWORD *)(v46 + 1148) & 2) != 0 )
    {
      v25 = 76;
      *((_BYTE *)v45 + 40) = 1;
      v30 = 32;
    }
    else
    {
      v41 = *(_DWORD *)(v46 + 1148) & 4;
      v40 = v41 == 0;
      if ( v41 )
        LOBYTE(v41) = 2;
      else
        v25 = 32;
      *((_BYTE *)v45 + 40) = v41;
      if ( v40 )
      {
        v30 = v25;
      }
      else
      {
        v25 = 108;
        v30 = 32;
      }
    }
    goto LABEL_31;
  }
  v25 = 32;
  *((_BYTE *)v45 + 40) = 3;
  v30 = 63;
LABEL_31:
  sub_6C054(
    (int)(v45 + 14),
    0x80u,
    "%c%1X %04d %03d %02d:%02d:%02d %c%x %+d %d %d %s %.0f %d",
    v30,
    v29,
    v45[47],
    v45[48],
    v45[49],
    v45[50],
    v45[51],
    v25,
    *(_DWORD *)(v46 + 1160),
    *(_DWORD *)(v46 + 1152),
    v43,
    *(_DWORD *)(v46 + 1144),
    (const char *)(v46 + 924),
    v27,
    *(_DWORD *)(v46 + 1108));
  v31 = strlen((const char *)v45 + 56);
  v32 = *(_DWORD *)(v46 + 920);
  v45[46] = v31;
  if ( (v32 & 0x4C0) == 0x400 && v27 > 50.0 )
  {
    if ( sub_633D8(v45[48], v45[49], v45[50], 0, 0, *(_DWORD *)(v46 + 408), v45 + 53, &v48) )
    {
      v38 = *(_DWORD *)(v46 + 1108);
      v49 = 0;
      if ( v38 > 0 )
      {
        do
        {
          ++v23;
          sub_39A70(v45, v48, v49);
        }
        while ( *(_DWORD *)(v46 + 1108) > v23 );
      }
      v39 = *(_DWORD *)(v46 + 892);
      v45[56] = *(_DWORD *)(v46 + 888);
      v45[57] = v39;
      sub_39D44(a2);
    }
    else
    {
      *(_DWORD *)(v46 + 916) = 6;
    }
  }
  if ( v27 > 0.0 )
    sub_41F44((unsigned __int16 *)(a2 + 16), (const char *)v45 + 56);
  sub_5DFB4(a2);
  v33 = **(_DWORD ***)(a2 + 84);
  v34 = v33[230];
  v33[279] = 0;
  result = (__int16 *)((char *)v33 + 319);
  v33[278] = 0;
  v35 = (__int16 *)((char *)v33 - 1);
  *(_DWORD *)((char *)v35 + 1109) = 0;
  *(_DWORD *)((char *)v35 + 921) = v34 & 0xC00;
  *(_DWORD *)((char *)v35 + 1129) = 0;
  do
  {
    v36 = (char *)(v35 + 8);
    do
    {
      *((_BYTE *)v35 + 1) = 0;
      v35 = (__int16 *)((char *)v35 + 1);
    }
    while ( v35 != (__int16 *)v36 );
  }
  while ( v35 != result );
  v37 = *(_DWORD *)(v46 + 916);
  if ( v37 )
    result = sub_394A0((__int16 *)a2, v37);
  *(_DWORD *)(v46 + 916) = 0;
  return result;
}
// 5E93C: variable 'v26' is possibly undefined
// 5EA30: variable 'v25' is possibly undefined
// 39D44: using guessed type int __fastcall sub_39D44(_DWORD);
// 108CA4: using guessed type int current_time;

//----- (0005EC18) --------------------------------------------------------
int __fastcall sub_5EC18(double a1)
{
  _DWORD *v1; // r7
  int v2; // r8
  _DWORD *v3; // r5
  double v4; // d0
  int v5; // r1
  __int64 v6; // r10
  unsigned int v7; // lr
  int v8; // r1
  int v9; // r3
  bool v10; // cc
  char *v11; // r10
  int result; // r0
  int v13; // r1
  char *v14; // r6
  double v15; // d0
  double v16; // d7
  int v17; // r3
  int v18; // r2
  int v19; // kr00_4
  double v20; // r0
  double *v21; // r3
  double v22; // d6
  double v23; // d0
  double v24; // d11
  double v25; // d2
  double v26; // d7
  double v27; // d4
  double v28; // d11
  double v29; // d1
  double v30; // d0
  double v31; // d8
  double v32; // d5
  double v33; // d12
  double v34; // d6
  double v35; // d6
  double v36; // d6
  double v37; // d6
  double v38; // d6
  double v39; // d6
  double v40; // d6
  double v41; // d6
  double v42; // d6
  double v43; // d6
  double v44; // d6
  double v45; // d6
  double v46; // d6
  double v47; // d15
  double v48; // d14
  double v49; // d13
  double v50; // d6
  double v51; // d10
  int v52; // r3
  int v53; // r2
  int v54; // r9
  int v55; // r1
  char v56; // t1
  __int64 v57; // d7
  double v58; // d10
  int v59; // r4
  double v60; // d12
  double v61; // d11
  double v62; // d5
  double v63; // d4
  double v64; // d3
  double v65; // d2
  double v66; // d0
  double v67; // d8
  double v68; // d6
  double v69; // d7
  __int64 v70; // r0
  int v71; // r12
  int v72; // r0
  int v73; // r1
  double v74; // d7
  bool v75; // nf
  int v76; // r3
  int v77; // r12
  int v78; // lr
  int v79; // r11
  int v80; // r3
  double v81; // d6
  double v82; // d7
  double v83; // d5
  double v84; // d7
  int v85; // r1
  unsigned int v86; // r2
  double v87; // d4
  double *v88; // r0
  int v89; // r3
  double v90; // d3
  int v91; // r3
  double v92; // d7
  int v93; // r3
  int v94; // r3
  double v95; // d7
  int v96; // r3
  int v97; // r0
  int i; // r1
  int v99; // r3
  unsigned int v100; // r1
  __int64 v101; // d7
  int v102; // r2
  int v103; // r3
  double v104; // d11
  _DWORD *v105; // r4
  int v106; // r2
  int v107; // r0
  int v108; // r2
  int v109; // r2
  int v110; // r3
  double v111; // [sp+0h] [bp-84h]
  double v112; // [sp+8h] [bp-7Ch]
  double v113; // [sp+10h] [bp-74h]
  double v114; // [sp+18h] [bp-6Ch]
  double v115; // [sp+20h] [bp-64h]
  double v116; // [sp+28h] [bp-5Ch]
  double v117; // [sp+30h] [bp-54h]
  double v118; // [sp+38h] [bp-4Ch]
  double v119; // [sp+40h] [bp-44h]
  double v120; // [sp+48h] [bp-3Ch]
  double v121; // [sp+50h] [bp-34h]
  double v122; // [sp+58h] [bp-2Ch]
  double v123; // [sp+60h] [bp-24h]
  double v124; // [sp+68h] [bp-1Ch]
  int v125; // [sp+74h] [bp-10h]

  v1 = (_DWORD *)LODWORD(a1);
  v2 = *(_DWORD *)(LODWORD(a1) + 4);
  HIDWORD(a1) = *(_DWORD *)(v2 + 84);
  v125 = HIDWORD(a1);
  v3 = (_DWORD *)*(_DWORD *)HIDWORD(a1);
  if ( *(int *)(*(_DWORD *)HIDWORD(a1) + 1164) <= 0 )
    return sub_5E2F0(
             v2,
             *(unsigned __int8 *)(LODWORD(a1) + 88),
             *(_DWORD *)(LODWORD(a1) + 72),
             *(_DWORD *)(LODWORD(a1) + 76));
  v4 = (double)*(int *)(LODWORD(a1) + 84) / 8000.0;
  LODWORD(a1) = 32;
  ldexp(a1, _stack_chk_guard);
  if ( v4 < 0.0 )
  {
    LODWORD(v70) = sub_8C010(-v4);
    v6 = -v70;
  }
  else
  {
    LODWORD(v6) = sub_8C010(v4);
    HIDWORD(v6) = v5;
  }
  v7 = v1[19];
  v8 = v1[21];
  v9 = v1[18] - HIDWORD(v6);
  if ( v7 < (unsigned int)v6 )
    --v9;
  v1[19] = v7 - v6;
  v10 = v8 <= 0;
  v1[18] = v9;
  v11 = (char *)(v1 + 22);
  result = v1[18];
  v13 = v1[19];
  v3[222] = result;
  v3[223] = v13;
  if ( v10 )
    goto LABEL_61;
  v14 = (char *)(v1 + 22);
  while ( 2 )
  {
    while ( 2 )
    {
      v56 = *v14++;
      *(double *)&v57 = 6000.0;
      v58 = *(double *)&v3[2 * (unsigned __int8)~v56 + 292];
      if ( v58 > 6000.0 || (*(double *)&v57 = -6000.0, v58 < -6000.0) )
      {
        v58 = *(double *)&v57;
        ++v3[806];
      }
      v59 = **(_DWORD **)(v2 + 84);
      v60 = *(double *)(v59 + 3296);
      *(double *)(v59 + 3304) = v60;
      v61 = *(double *)(v59 + 3288);
      *(double *)(v59 + 3296) = v61;
      v62 = *(double *)(v59 + 3280);
      *(double *)(v59 + 3288) = v62;
      v63 = *(double *)(v59 + 3272);
      *(double *)(v59 + 3280) = v63;
      v64 = *(double *)(v59 + 3264);
      *(double *)(v59 + 3272) = v64;
      v65 = *(double *)(v59 + 3256);
      *(double *)(v59 + 3264) = v65;
      v66 = *(double *)(v59 + 3248);
      *(double *)(v59 + 3256) = v66;
      v67 = *(double *)(v59 + 3240);
      *(double *)(v59 + 3248) = v67;
      v68 = v58
          - (v61 * 0.488486
           + v60 * 0.5844676
           + v62 * 2.704384
           + v63 * 1.645032
           + v64 * 4.644557
           + v65 * 1.879165
           + v66 * 3.522634
           + v67 * 0.7315738);
      *(double *)(v59 + 3240) = v68;
      v69 = v67 * 0.003156599 + v68 * 0.006176213 + v66 * 0.007567487;
      v15 = 1000.0;
      v16 = v69
          + v65 * 0.00434458
          + v64 * 0.01190128
          + v63 * 0.00434458
          + v62 * 0.007567487
          + v61 * 0.003156599
          + v60 * 0.006176213;
      *(double *)(v59 + 3608) = v16 * 0.25;
      if ( v16 <= 1000.0 )
      {
        if ( v16 < -1000.0 )
          v16 = -1000.0;
        else
          v15 = -v16;
      }
      else
      {
        v16 = 1000.0;
        v15 = -1000.0;
      }
      v17 = *(_DWORD *)(v59 + 3616);
      v18 = v17 + 1;
      v19 = v17 + 1;
      *(_QWORD *)&v20 = 1717986919LL * (v17 + 1);
      v21 = (double *)(v59 + 8 * v17 + 3312);
      v22 = *v21;
      *v21 = v16;
      v23 = v15 * v22;
      *(_DWORD *)(v59 + 3616) = v19 % 10;
      if ( v23 < 0.0 )
      {
        v104 = sqrt(-v23);
        if ( v23 > -0.0 )
        {
          LODWORD(v20) = v18 >> 31;
          sqrt(v20);
        }
        v24 = -v104;
      }
      else
      {
        v24 = sqrt(v23);
      }
      v25 = *(double *)(v59 + 3592);
      *(double *)(v59 + 3600) = v25;
      v26 = *(double *)(v59 + 3584);
      *(double *)(v59 + 3592) = v26;
      v27 = *(double *)(v59 + 3576);
      v28 = v24 * 0.02538771;
      *(double *)(v59 + 3584) = v27;
      v29 = *(double *)(v59 + 3568);
      *(double *)(v59 + 3576) = v29;
      v30 = *(double *)(v59 + 3560);
      *(double *)(v59 + 3568) = v30;
      v31 = *(double *)(v59 + 3552);
      *(double *)(v59 + 3560) = v31;
      v32 = *(double *)(v59 + 3544);
      *(double *)(v59 + 3552) = v32;
      v33 = *(double *)(v59 + 3536);
      *(double *)(v59 + 3544) = v33;
      v34 = *(double *)(v59 + 3528);
      *(double *)(v59 + 3536) = v34;
      v111 = v34;
      v35 = *(double *)(v59 + 3520);
      *(double *)(v59 + 3528) = v35;
      v112 = v35;
      v36 = *(double *)(v59 + 3512);
      *(double *)(v59 + 3520) = v36;
      v113 = v36;
      v37 = *(double *)(v59 + 3504);
      *(double *)(v59 + 3512) = v37;
      v114 = v37;
      v38 = *(double *)(v59 + 3496);
      *(double *)(v59 + 3504) = v38;
      v115 = v38;
      v116 = *(double *)(v59 + 3488);
      *(double *)(v59 + 3496) = v116;
      v39 = *(double *)(v59 + 3480);
      *(double *)(v59 + 3488) = v39;
      v117 = v39;
      v40 = *(double *)(v59 + 3472);
      *(double *)(v59 + 3480) = v40;
      v118 = v40;
      v41 = *(double *)(v59 + 3464);
      *(double *)(v59 + 3472) = v41;
      v119 = v41;
      v42 = *(double *)(v59 + 3456);
      *(double *)(v59 + 3464) = v42;
      v120 = v42;
      v43 = *(double *)(v59 + 3448);
      *(double *)(v59 + 3456) = v43;
      v121 = v43;
      v44 = *(double *)(v59 + 3440);
      *(double *)(v59 + 3448) = v44;
      v122 = v44;
      v45 = *(double *)(v59 + 3432);
      *(double *)(v59 + 3440) = v45;
      v123 = v45;
      v46 = *(double *)(v59 + 3424);
      *(double *)(v59 + 3432) = v46;
      v47 = *(double *)(v59 + 3416);
      v124 = v46;
      *(double *)(v59 + 3424) = v47;
      v48 = *(double *)(v59 + 3408);
      *(double *)(v59 + 3416) = v48;
      v49 = *(double *)(v59 + 3400);
      v50 = *(double *)(v59 + 3624) + 0.000125;
      *(double *)(v59 + 3408) = v49;
      v51 = *(double *)(v59 + 3392);
      *(double *)(v59 + 3400) = v51;
      *(double *)(v59 + 3392) = v28;
      if ( v50 <= 0.000416666667 )
      {
        *(double *)(v59 + 3624) = v50;
        goto LABEL_16;
      }
      v71 = *(_DWORD *)(v59 + 4656);
      v72 = *(_DWORD *)(v59 + 888);
      v73 = *(_DWORD *)(v59 + 892);
      *(double *)(v59 + 3624) = v50 - 0.000416666667;
      v74 = v26 * 0.1084671;
      v75 = -++v71 < 0;
      v76 = -v71 & 7;
      v77 = v71 & 7;
      if ( !v75 )
        v77 = -v76;
      v78 = v77 << 7;
      *(_DWORD *)(v59 + 4656) = v77;
      v79 = v59 + (v77 << 7);
      *(_DWORD *)(v79 + 3632) = v72;
      *(_DWORD *)(v79 + 3636) = v73;
      v80 = v59 + (v77 << 7) + 3728;
      v81 = 1000000.0;
      v82 = v74
          + v25 * 0.02538771
          + v27 * 0.2003159
          + v29 * 0.2985303
          + v30 * 0.4003697
          + v31 * 0.5028552
          + v32 * 0.6028795;
      v83 = -1000000.0;
      *(double *)(v79 + 3640) = -((v82
                                 + v33 * 0.6973249
                                 + v111 * 0.7831828
                                 + v112 * 0.8576717
                                 + v113 * 0.9183463
                                 + v114 * 0.9631951
                                 + v115 * 0.9907208
                                 + v116
                                 + v117 * 0.9907208
                                 + v118 * 0.9631951
                                 + v119 * 0.9183463
                                 + v120 * 0.8576717
                                 + v121 * 0.7831828
                                 + v122 * 0.6973249
                                 + v123 * 0.6028795
                                 + v124 * 0.5028552
                                 + v47 * 0.4003697
                                 + v48 * 0.2985303
                                 + v49 * 0.2003159
                                 + v51 * 0.1084671
                                 + v28)
                                * 6.0);
      do
      {
        v84 = *(double *)(v80 - 8);
        v80 -= 8;
        *(double *)(v80 + 8) = v84;
        if ( v84 > v83 )
          v83 = v84;
        if ( v84 < v81 )
          v81 = v84;
      }
      while ( v59 + 3640 + (v77 << 7) != v80 );
      v85 = v59 + v78;
      v86 = 0;
      v87 = 0.0;
      v88 = (double *)(v59 + v78 + 3648);
      v89 = 0;
      v90 = v81 + (v83 - v81) * 0.45;
      *(double *)(v59 + v78 + 3736) = v83 - v81;
      while ( 1 )
      {
        v91 = 2 * v89;
        *(_DWORD *)(v85 + 3752) = v91;
        v92 = *v88++;
        if ( v90 < v92 )
          *(_DWORD *)(v85 + 3752) = v91 | 1;
        if ( v86 <= 1 )
          goto LABEL_40;
        if ( v86 == 10 )
          break;
        if ( v90 >= v92 )
        {
          ++v86;
          v87 = v87 + v83 - v92;
          if ( v86 == 11 )
            goto LABEL_41;
          goto LABEL_34;
        }
LABEL_40:
        ++v86;
        v87 = v87 + v92 - v81;
        if ( v86 == 11 )
          goto LABEL_41;
LABEL_34:
        v89 = *(_DWORD *)(v85 + 3752);
      }
      v87 = v87 + v83 - v92;
LABEL_41:
      *(double *)(v59 + v78 + 3744) = v87 / ((v83 - v81) * 11.0);
      v93 = *(_DWORD *)(v59 + 4664);
      if ( v93 <= 0 )
      {
        if ( v77 == *(_DWORD *)(v59 + 4660) )
          goto LABEL_45;
      }
      else
      {
        v94 = v93 - 1;
        *(_DWORD *)(v59 + 4664) = v94;
        if ( !v94 )
        {
          *(_DWORD *)(v59 + 4660) = v77;
LABEL_45:
          v95 = 0.0;
          v96 = v59 + 3736;
          v97 = -1;
          for ( i = 0; i != 8; ++i )
          {
            if ( (*(_DWORD *)(v96 + 16) & 0x601) == 0x600 && *(double *)v96 >= 800.0 && *(double *)(v96 + 8) > v95 )
            {
              v97 = i;
              v95 = *(double *)(v96 + 8);
            }
            v96 += 128;
          }
          if ( v97 != -1 )
          {
            v99 = v59 + (v97 << 7);
            v100 = *(_DWORD *)(v99 + 3752);
            v101 = *(_QWORD *)(v99 + 3736);
            v99 += 3632;
            v102 = *(_DWORD *)v99;
            v103 = *(_DWORD *)(v99 + 4);
            *(_QWORD *)(v59 + 1136) = v101;
            sub_5E2F0(v2, (unsigned __int8)(v100 >> 1), v102, v103);
            *(_DWORD *)(v59 + 4664) = 88;
          }
        }
      }
LABEL_16:
      v52 = v3[223];
      v53 = v3[809];
      v54 = v3[222];
      v55 = v3[807] + 1;
      v3[223] = v52 + v53;
      result = __CFADD__(v52, v53);
      v3[222] = v54 + v3[808] + result;
      v3[807] = v55 % 8000;
      if ( !(v55 % 8000) )
      {
        v105 = **(_DWORD ***)(v2 + 84);
        v106 = v105[806];
        v107 = v105[286];
        if ( !v106 )
        {
          v107 += 4;
          if ( v107 > 255 )
            v107 = 255;
          goto LABEL_59;
        }
        if ( v106 > 100 )
        {
          v107 -= 4;
          if ( v107 >= 0 )
          {
LABEL_59:
            v105[286] = v107;
            goto LABEL_60;
          }
          v107 = 0;
          v105[286] = 0;
        }
LABEL_60:
        result = sub_612E0(v107, v105[805], v105[804]);
        v108 = v1[21];
        v105[806] = 0;
        if ( v108 > v14 - v11 )
          continue;
        goto LABEL_61;
      }
      break;
    }
    if ( v1[21] > v14 - v11 )
      continue;
    break;
  }
LABEL_61:
  if ( (*(_BYTE *)(v125 + 768) & 2) != 0 )
    v109 = 2;
  else
    v109 = 1;
  v110 = *(_BYTE *)(v125 + 768) & 4;
  v3[804] = v109;
  if ( v110 )
    v110 = 127;
  v3[805] = v110;
  return result;
}
// 5EC90: variable 'v5' is possibly undefined
// 5F0A8: variable 'v70' is possibly undefined

//----- (0005F600) --------------------------------------------------------
int __fastcall sub_5F600(double a1)
{
  double v1; // d0
  double v2; // r0

  sys_fuzz = v1;
  if ( v1 < 0.0 )
    sub_6ECC0("systime.c", 117, 2, "sys_fuzz >= 0");
  if ( v1 > 1.0 )
    sub_6ECC0("systime.c", 118, 2, "sys_fuzz <= 1.0");
  v2 = ceil(a1);
  LODWORD(sys_fuzz_nsec) = (int)(v1 * 1000000000.0);
  return LODWORD(v2);
}
// 5F630: variable 'v1' is possibly undefined
// 106F48: using guessed type float sys_fuzz_nsec;
// 106F50: using guessed type double sys_fuzz;

//----- (0005F6E0) --------------------------------------------------------
void sub_5F6E0()
{
  ;
}

//----- (0005F724) --------------------------------------------------------
int __fastcall sub_5F724(int *a1)
{
  int v2; // r0
  int tv_nsec; // r3
  __time_t tv_sec; // r4
  int v5; // r2
  int v6; // r1
  __time_t v7; // r12
  int v8; // r2
  int v9; // r0
  bool v10; // cc
  int v11; // r1
  int v12; // r1
  bool v13; // cc
  int v14; // r9
  signed int v15; // r0
  double v16; // d0
  double v17; // r0
  int v18; // r2
  int v19; // r1
  __int64 v20; // r10
  bool v21; // cf
  unsigned int v22; // r9
  int v23; // r2
  int v24; // r3
  int v25; // lr
  int v26; // r2
  int result; // r0
  int v28; // r12
  int v29; // r12
  int v30; // r9
  int v31; // r1
  int v32; // r1
  int v33; // lr
  __int64 v34; // r0
  int v35; // r9
  bool v36; // cc
  struct timespec tp; // [sp+4h] [bp-10h] BYREF
  int v38; // [sp+Ch] [bp-8h]

  v2 = clock_gettime(0, &tp);
  if ( v2 < 0 )
    sub_C5C4();
  tv_nsec = tp.tv_nsec;
  if ( trunc_os_clock )
  {
    tv_nsec = (int)((double)(int)((double)tp.tv_nsec * 0.000000001 / sys_tick) * 1000000000.0 * sys_tick);
    tp.tv_nsec = tv_nsec;
  }
  tv_sec = tp.tv_sec;
  v5 = tv_nsec + 50000000;
  if ( tv_nsec + 50000000 < 0 )
  {
    v2 = tp.tv_sec;
    do
    {
      v5 += 1000000000;
      --v2;
    }
    while ( v5 < 0 );
  }
  else if ( v5 > 999999999 )
  {
    v5 = tv_nsec - 950000000;
    if ( tv_nsec - 950000000 <= 999999999 )
      v2 = tp.tv_sec + 1;
    else
      v5 = 23680;
    if ( tv_nsec - 950000000 > 999999999 )
    {
      HIWORD(v5) = -29755;
      v2 = tp.tv_sec + 2;
      v5 += tv_nsec;
    }
  }
  else
  {
    v2 = tp.tv_sec;
  }
  if ( (int)qword_106F20 < v2 )
    v6 = (int)qword_106F20 <= v2;
  else
    v6 = -((int)qword_106F20 > v2);
  if ( !v6 )
  {
    if ( v5 > SHIDWORD(qword_106F20) )
      v6 = v5 >= SHIDWORD(qword_106F20);
    else
      v6 = -(v5 < SHIDWORD(qword_106F20));
  }
  if ( v6 == -1 )
  {
    dword_106F28 = 1;
    ++sys_lamport;
  }
  qword_106F20 = (__int64)tp;
  v7 = qword_106F2C;
  v8 = LODWORD(sys_fuzz_nsec) + HIDWORD(qword_106F2C);
  if ( LODWORD(sys_fuzz_nsec) + HIDWORD(qword_106F2C) < 0 )
  {
    do
    {
      v8 += 1000000000;
      --v7;
    }
    while ( v8 < 0 );
  }
  else if ( v8 > 999999999 )
  {
    v9 = v8 - 1000000000;
    v10 = v8 - 1000000000 <= 999999999;
    if ( v8 - 1000000000 <= 999999999 )
      v7 = qword_106F2C + 1;
    else
      v8 -= 2013265920;
    if ( v10 )
      v8 = v9;
    else
      v8 += 13238272;
    if ( !v10 )
    {
      v7 += 2;
      v8 += 27648;
    }
  }
  if ( v7 < tp.tv_sec )
    v11 = v7 <= tp.tv_sec;
  else
    v11 = -(v7 > tp.tv_sec);
  if ( v11 )
  {
    if ( v11 != -1 )
      goto LABEL_33;
  }
  else
  {
    if ( v8 < tv_nsec )
      v31 = v8 <= tv_nsec;
    else
      v31 = -(v8 > tv_nsec);
    if ( v31 != -1 )
      goto LABEL_33;
  }
  v32 = v8 - tv_nsec;
  v33 = v7 - tp.tv_sec;
  if ( v8 - tv_nsec < 0 )
  {
    do
    {
      v32 += 1000000000;
      --v33;
    }
    while ( v32 < 0 );
  }
  else if ( v32 > 999999999 )
  {
    v35 = v32 - 1000000000;
    v36 = v32 - 1000000000 <= 999999999;
    if ( v32 - 1000000000 <= 999999999 )
      ++v33;
    else
      v32 -= 2013265920;
    if ( v36 )
      v32 = v35;
    else
      v32 += 13238272;
    if ( !v36 )
    {
      v33 += 2;
      v32 += 27648;
    }
  }
  if ( v33 <= 0 )
  {
    if ( !dword_106F28 )
    {
      tp.tv_sec = v7;
      tp.tv_nsec = v8;
      tv_sec = v7;
      LODWORD(qword_106F2C) = v7;
      HIDWORD(qword_106F2C) = v8;
      tv_nsec = v8;
      if ( v8 >= 0 )
        goto LABEL_43;
      do
      {
LABEL_85:
        tv_nsec += 1000000000;
        --tv_sec;
      }
      while ( tv_nsec < 0 );
      goto LABEL_43;
    }
  }
  else if ( !dword_106F28 )
  {
    sub_64E00(3, "get_systime Lamport advance exceeds one second (%.9f)", (double)v33 + (double)v32 * 0.000000001);
    exit(1);
  }
LABEL_33:
  qword_106F2C = (__int64)tp;
  if ( tv_nsec < 0 )
    goto LABEL_85;
  if ( tv_nsec > 999999999 )
  {
    v12 = tv_nsec - 1000000000;
    v13 = tv_nsec - 1000000000 <= 999999999;
    if ( tv_nsec - 1000000000 <= 999999999 )
      tv_sec = tp.tv_sec + 1;
    else
      tv_nsec -= 2013265920;
    if ( v13 )
      tv_nsec = v12;
    else
      tv_nsec += 13238272;
    if ( !v13 )
    {
      tv_sec += 2;
      tv_nsec += 27648;
    }
  }
LABEL_43:
  v14 = sub_8BFD0(__PAIR64__(tv_nsec, 0) + 500000000, 0x3B9ACA00u);
  v15 = sub_68AE4();
  v16 = ((double)v15 + (double)v15) * 2.32830644e-10 * sys_fuzz;
  LODWORD(v17) = 32;
  ldexp(v17, v18);
  if ( v16 < 0.0 )
  {
    LODWORD(v34) = sub_8C010(-v16);
    v20 = -v34;
  }
  else
  {
    LODWORD(v20) = sub_8C010(v16);
    HIDWORD(v20) = v19;
  }
  v21 = __CFADD__((_DWORD)v20, v14);
  v22 = v20 + v14;
  v23 = v21;
  v24 = tv_sec - 2085978496 + HIDWORD(v20) + v23;
  v25 = dword_106F28;
  v26 = v22;
  if ( qword_106F34 )
  {
    if ( dword_106F28 )
    {
      LODWORD(qword_106F34) = v24;
      HIDWORD(qword_106F34) = v22;
      goto LABEL_50;
    }
    if ( sys_fuzz > 0.0 )
    {
      v28 = v22 < HIDWORD(qword_106F34) ? v24 - 1 : v24;
      v29 = v28 - qword_106F34;
      v30 = v22 == HIDWORD(qword_106F34) ? v29 - 1 : v29;
      if ( v30 < 0 )
      {
        v26 = HIDWORD(qword_106F34) + 1;
        if ( HIDWORD(qword_106F34) == -1 )
          v25 = 1;
        v24 = v25 + qword_106F34;
        ++sys_tsrounding;
      }
    }
    LODWORD(qword_106F34) = v24;
    HIDWORD(qword_106F34) = v26;
  }
  else
  {
    LODWORD(qword_106F34) = v24;
    HIDWORD(qword_106F34) = v22;
    if ( dword_106F28 )
LABEL_50:
      dword_106F28 = 0;
  }
  result = v38;
  a1[1] = v26;
  *a1 = v24;
  return result;
}
// 5F9A4: variable 'v17' is possibly undefined
// 5F9A4: variable 'v18' is possibly undefined
// 5F9B4: variable 'v19' is possibly undefined
// 5FC04: variable 'v34' is possibly undefined
// 106F20: using guessed type __int64 qword_106F20;
// 106F28: using guessed type int dword_106F28;
// 106F2C: using guessed type __int64 qword_106F2C;
// 106F34: using guessed type __int64 qword_106F34;
// 106F48: using guessed type float sys_fuzz_nsec;
// 106F50: using guessed type double sys_fuzz;
// 106F58: using guessed type double sys_tick;
// 108CE8: using guessed type int sys_lamport;
// 108CEC: using guessed type int sys_tsrounding;
// 108CF0: using guessed type int trunc_os_clock;

//----- (0005FCA8) --------------------------------------------------------
int sub_5FCA8()
{
  double v0; // d0
  int result; // r0
  double v2; // d0
  int v3; // lr
  double v4; // d5
  __time_t v5; // r2
  double v6; // d0
  __suseconds_t v7; // r3
  double v8; // d0
  struct timeval delta; // [sp+4h] [bp-18h] BYREF
  struct timeval olddelta; // [sp+Ch] [bp-10h] BYREF

  if ( v0 == 0.0 )
  {
    if ( enable_panic_check && allow_panic )
    {
      sub_64E00(3, "adj_systime: allow_panic is TRUE!");
      if ( allow_panic )
        sub_6ECC0("systime.c", 310, 2, "!allow_panic");
    }
    return 1;
  }
  v2 = v0 + sys_residual;
  if ( v2 >= 0.0 )
  {
    v3 = 0;
  }
  else
  {
    v2 = -v2;
    v3 = 1;
  }
  delta.tv_sec = (int)v2;
  v4 = sys_tick;
  v5 = (int)v2;
  v6 = v2 - (double)(int)v2;
  if ( sys_tick <= sys_fuzz )
    v4 = 0.000001;
  v7 = (int)((double)(int)(v6 / v4 + 0.5) * v4 * 1000000.0 + 0.5);
  delta.tv_usec = v7;
  if ( v7 > (int)&unk_F423F )
  {
    v6 = v6 - 1.0;
    v7 -= 1000000;
    delta.tv_sec = ++v5;
    delta.tv_usec = v7;
  }
  v8 = v6 - (double)v7 * 0.000001;
  sys_residual = v8;
  if ( v3 )
  {
    v5 = -v5;
    delta.tv_sec = v5;
    sys_residual = -v8;
    delta.tv_usec = -v7;
  }
  if ( !v5 && !delta.tv_usec || adjtime(&delta, &olddelta) >= 0 )
  {
    if ( enable_panic_check && allow_panic )
      sub_64E00(3, "adj_systime: allow_panic is TRUE!");
    return 1;
  }
  sub_64E00(3, "adj_systime: %m");
  result = enable_panic_check;
  if ( enable_panic_check )
  {
    result = allow_panic;
    if ( allow_panic )
    {
      sub_64E00(3, "adj_systime: allow_panic is TRUE!");
      return 0;
    }
  }
  return result;
}
// 5FCD0: variable 'v0' is possibly undefined
// B7CBC: using guessed type int enable_panic_check;
// 106F40: using guessed type double sys_residual;
// 106F50: using guessed type double sys_fuzz;
// 106F58: using guessed type double sys_tick;
// 106F60: using guessed type int allow_panic;

//----- (0005FF34) --------------------------------------------------------
int sub_5FF34()
{
  double v0; // d0
  double v1; // d8
  double v2; // d0
  double v3; // r0
  int v4; // r2
  double v5; // kr08_8
  int v6; // r1
  __int64 v7; // r2
  int v8; // r4
  _BOOL4 v9; // r8
  int v10; // r7
  signed __int64 v11; // r0
  __time_t tv_sec; // r9
  int v13; // r0
  bool v14; // cf
  unsigned int v15; // r4
  unsigned __int64 v16; // r2
  __time_t v17; // r0
  int result; // r0
  int v19; // r2
  bool v20; // cc
  __int64 v21; // r0
  double v22; // d0
  __int64 v23; // r0
  __int64 v24; // [sp+0h] [bp-24h] BYREF
  time_t timer; // [sp+8h] [bp-1Ch] BYREF
  struct timeval v26; // [sp+Ch] [bp-18h] BYREF
  struct timespec tp; // [sp+14h] [bp-10h] BYREF

  timer = 0x7FFFFFFF;
  v1 = v0;
  v2 = sys_residual;
  if ( sys_residual < 0.0 )
  {
    v22 = -sys_residual;
    ldexp(NAN, _stack_chk_guard);
    LODWORD(v23) = sub_8C010(v22);
    *(_QWORD *)&v3 = -v23;
  }
  else
  {
    ldexp(NAN, _stack_chk_guard);
    LODWORD(v3) = sub_8C010(v2);
  }
  v5 = v3;
  LODWORD(v3) = 32;
  ldexp(v3, v4);
  if ( v1 < 0.0 )
  {
    LODWORD(v21) = sub_8C010(-v1);
    v7 = -v21;
  }
  else
  {
    LODWORD(v7) = sub_8C010(v1);
    HIDWORD(v7) = v6;
  }
  v8 = LODWORD(v5) + v7;
  v9 = __CFADD__(LODWORD(v5), (_DWORD)v7);
  v10 = HIDWORD(v5) - 2085978496 + HIDWORD(v7);
  if ( clock_gettime(0, &tp) < 0 )
    sub_C5C4();
  HIDWORD(v11) = tp.tv_nsec;
  if ( trunc_os_clock )
  {
    HIDWORD(v11) = (int)((double)(int)((double)tp.tv_nsec * 0.000000001 / sys_tick) * 1000000000.0 * sys_tick);
    tp.tv_nsec = HIDWORD(v11);
  }
  tv_sec = tp.tv_sec;
  if ( v11 < 0 )
  {
    do
    {
      HIDWORD(v11) += 1000000000;
      --tv_sec;
    }
    while ( v11 < 0 );
  }
  else if ( SHIDWORD(v11) > 999999999 )
  {
    v19 = HIDWORD(v11) - 1000000000;
    v20 = HIDWORD(v11) - 1000000000 <= 999999999;
    if ( HIDWORD(v11) - 1000000000 <= 999999999 )
      tv_sec = tp.tv_sec + 1;
    else
      HIDWORD(v11) -= 2013265920;
    if ( v20 )
      HIDWORD(v11) = v19;
    else
      HIDWORD(v11) += 13238272;
    if ( !v20 )
    {
      tv_sec += 2;
      HIDWORD(v11) += 27648;
    }
  }
  LODWORD(v11) = 500000000;
  v13 = sub_8BFD0(v11, 0x3B9ACA00u);
  v14 = __CFADD__(v8, v13);
  v15 = v8 + v13;
  sub_65844(&v24, v9 + v10 + tv_sec + v14, &timer);
  v16 = (unsigned int)&unk_F4240 * (unsigned __int64)v15 + 0x80000000;
  v17 = v24;
  if ( (_UNKNOWN *)HIDWORD(v16) == &unk_F4240 )
  {
    v17 = v24 + 1;
    HIDWORD(v16) = 0;
  }
  v26.tv_sec = v17;
  v26.tv_usec = HIDWORD(v16);
  if ( sub_642E4(&v26, 0) )
  {
    sub_64E00(3, "step-systime: %m");
    result = enable_panic_check;
    if ( enable_panic_check )
    {
      result = allow_panic;
      if ( allow_panic )
      {
        sub_64E00(3, "step_systime: allow_panic is TRUE!");
        return 0;
      }
    }
  }
  else
  {
    dword_106F28 = v1 < 0.0;
    sys_residual = 0.0;
    if ( step_callback )
      step_callback(0, 0, &qword_106F20);
    if ( enable_panic_check && allow_panic )
    {
      sub_64E00(3, "step_systime: allow_panic is TRUE!");
      if ( allow_panic )
        sub_6ECC0("systime.c", 589, 2, "!allow_panic");
    }
    return 1;
  }
  return result;
}
// 5FF5C: variable 'v0' is possibly undefined
// 5FF98: variable 'v3' is possibly undefined
// 5FFA8: variable 'v4' is possibly undefined
// 5FFB8: variable 'v6' is possibly undefined
// 601A8: variable 'v21' is possibly undefined
// 601C8: variable 'v23' is possibly undefined
// B7CBC: using guessed type int enable_panic_check;
// 106F20: using guessed type __int64 qword_106F20;
// 106F28: using guessed type int dword_106F28;
// 106F40: using guessed type double sys_residual;
// 106F58: using guessed type double sys_tick;
// 106F60: using guessed type int allow_panic;
// 108CF0: using guessed type int trunc_os_clock;
// 108CF4: using guessed type int (__fastcall *step_callback)(_DWORD, _DWORD, _DWORD);

//----- (000602C8) --------------------------------------------------------
int sub_602C8()
{
  return 0;
}

//----- (00060310) --------------------------------------------------------
int __fastcall sub_60310(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v5; // r0
  unsigned int v9; // r4
  _BYTE *v10; // r5
  int v11; // r4
  int v12; // r0
  int v14; // r0
  int v15; // r9
  int v16; // r0
  int digestbyname; // r0
  int v18; // r0
  const char *v19; // r0
  int v20; // r3
  const char *v21; // r0
  _BYTE *v22; // r1
  void *v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  int v28; // [sp+Ch] [bp-1Ch] BYREF
  int v29; // [sp+10h] [bp-18h] BYREF
  _BYTE v30[16]; // [sp+14h] [bp-14h] BYREF

  v5 = 2092;
  v28 = 0;
  if ( !ssl_init_done )
    v5 = sub_6C6B8();
  if ( a2 == 894 )
  {
    v9 = a3[1];
    v10 = (_BYTE *)*a3;
    if ( v9 <= 0xF )
    {
      v22 = v10;
      v10 = v30;
      _memcpy_chk(v30, v22, v9, 16);
      v23 = memset(&v30[v9], 0, 16 - v9);
      v11 = CMAC_CTX_new(v23);
      if ( v11 )
        goto LABEL_6;
    }
    else
    {
      v11 = CMAC_CTX_new(v5);
      if ( v11 )
      {
LABEL_6:
        v12 = EVP_aes_128_cbc();
        if ( CMAC_Init(v11, v10, 16, v12, 0) )
        {
          if ( CMAC_CTX_get0_cipher_ctx(v11) && a1[1] < (unsigned int)EVP_CIPHER_CTX_block_size() )
          {
            sub_64E00(3, "MAC encrypt: CMAC %s buf too small.", "AES128CMAC");
          }
          else if ( CMAC_Update(v11, *a4, a4[1]) )
          {
            if ( !CMAC_Final(v11, *a1, &v28) )
            {
              sub_64E00(3, "MAC encrypt: CMAC %s Final failed.", "AES128CMAC");
              v28 = 0;
            }
          }
          else
          {
            sub_64E00(3, "MAC encrypt: CMAC %s Update failed.", "AES128CMAC");
          }
        }
        else
        {
          sub_64E00(3, "MAC encrypt: CMAC %s Init failed.", "AES128CMAC");
        }
        CMAC_CTX_cleanup(v11);
        return v28;
      }
    }
    sub_64E00(3, "MAC encrypt: CMAC %s CTX new failed.", "AES128CMAC");
    return v28;
  }
  v14 = EVP_MD_CTX_new();
  v15 = v14;
  v29 = 0;
  if ( v14 )
  {
    EVP_MD_CTX_set_flags(v14, 8);
    v16 = OBJ_nid2sn(a2);
    digestbyname = EVP_get_digestbyname(v16);
    if ( EVP_DigestInit_ex(v15, digestbyname, 0) )
    {
      v18 = EVP_MD_CTX_md(v15);
      if ( (unsigned int)EVP_MD_size(v18) <= a1[1] )
      {
        if ( EVP_DigestUpdate(v15, *a3, a3[1]) )
        {
          if ( EVP_DigestUpdate(v15, *a4, a4[1]) )
          {
            if ( EVP_DigestFinal(v15, *a1, &v29) )
            {
              v20 = v29;
            }
            else
            {
              v27 = (const char *)OBJ_nid2sn(a2);
              sub_64E00(3, "MAC encrypt: MAC %s Digest Final failed.", v27);
              v29 = 0;
              v20 = 0;
            }
          }
          else
          {
            v25 = (const char *)OBJ_nid2sn(a2);
            sub_64E00(3, "MAC encrypt: MAC %s Digest Update data failed.", v25);
            v20 = v29;
          }
        }
        else
        {
          v26 = (const char *)OBJ_nid2sn(a2);
          sub_64E00(3, "MAC encrypt: MAC %s Digest Update key failed.", v26);
          v20 = v29;
        }
      }
      else
      {
        v19 = (const char *)OBJ_nid2sn(a2);
        sub_64E00(3, "MAC encrypt: MAC %s buf too small.", v19);
        v20 = v29;
      }
    }
    else
    {
      v21 = (const char *)OBJ_nid2sn(a2);
      sub_64E00(3, "MAC encrypt: MAC %s Digest Init failed.", v21);
      v20 = v29;
    }
    v28 = v20;
    EVP_MD_CTX_free(v15);
    return v28;
  }
  v24 = (const char *)OBJ_nid2sn(a2);
  sub_64E00(3, "MAC encrypt: MAC %s Digest CTX new failed.", v24);
  return v29;
}
// B250: using guessed type int __fastcall EVP_DigestInit_ex(_DWORD, _DWORD, _DWORD);
// B25C: using guessed type int __fastcall CMAC_Init(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// B2E0: using guessed type int __fastcall CMAC_CTX_new(_DWORD);
// B3B8: using guessed type int __fastcall EVP_MD_CTX_md(_DWORD);
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// B650: using guessed type int __fastcall CMAC_Update(_DWORD, _DWORD, _DWORD);
// B680: using guessed type int __fastcall EVP_MD_size(_DWORD);
// B68C: using guessed type int __fastcall EVP_MD_CTX_set_flags(_DWORD, _DWORD);
// B6A4: using guessed type int __fastcall CMAC_Final(_DWORD, _DWORD, _DWORD);
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B824: using guessed type int __fastcall _memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// B848: using guessed type int __fastcall EVP_DigestFinal(_DWORD, _DWORD, _DWORD);
// B854: using guessed type int EVP_CIPHER_CTX_block_size(void);
// B9C8: using guessed type int EVP_MD_CTX_new(void);
// BC5C: using guessed type int EVP_aes_128_cbc(void);
// BD1C: using guessed type int __fastcall CMAC_CTX_cleanup(_DWORD);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// BEE4: using guessed type int __fastcall CMAC_CTX_get0_cipher_ctx(_DWORD);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// 1095B0: using guessed type int ssl_init_done;

//----- (000606CC) --------------------------------------------------------
size_t __fastcall sub_606CC(int a1, int a2, int a3, int a4, int a5)
{
  unsigned int v6; // r0
  size_t v7; // r8
  _DWORD v9[2]; // [sp+4h] [bp-5Ch] BYREF
  _DWORD v10[2]; // [sp+Ch] [bp-54h] BYREF
  _DWORD v11[2]; // [sp+14h] [bp-4Ch] BYREF
  _BYTE v12[64]; // [sp+1Ch] [bp-44h] BYREF

  v10[0] = a2;
  v10[1] = a3;
  v9[0] = v12;
  v9[1] = 64;
  v11[1] = a5;
  v11[0] = a4;
  v6 = sub_60310(v9, a1, v10, v11);
  if ( v6 >= 0x14 )
    v7 = 20;
  else
    v7 = v6;
  memcpy((void *)(a4 + a5 + 4), v12, v7);
  return v7 + 4;
}

//----- (00060770) --------------------------------------------------------
bool __fastcall sub_60770(int a1, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v7; // r0
  int v8; // r2
  _DWORD v10[2]; // [sp+4h] [bp-5Ch] BYREF
  _DWORD v11[2]; // [sp+Ch] [bp-54h] BYREF
  _DWORD v12[2]; // [sp+14h] [bp-4Ch] BYREF
  _BYTE v13[64]; // [sp+1Ch] [bp-44h] BYREF

  v11[0] = a2;
  v11[1] = a3;
  v10[0] = v13;
  v10[1] = 64;
  v12[0] = a4;
  v12[1] = a5;
  v7 = sub_60310(v10, a1, v11, v12);
  if ( v7 >= 0x14 )
    v8 = 20;
  else
    v8 = v7;
  if ( v8 + 4 == a6 )
    return sub_78564((int)v13, (unsigned __int8 *)(a4 + a5 + 4), v8) == 0;
  sub_64E00(3, "MAC decrypt: MAC length error");
  return 0;
}

//----- (0006083C) --------------------------------------------------------
int __fastcall sub_6083C(int a1)
{
  int v3; // r4
  int v4; // r0
  int v5; // r0
  int v6; // [sp+0h] [bp-48h] BYREF
  _DWORD v7[16]; // [sp+4h] [bp-44h] BYREF

  if ( *(_WORD *)a1 == 2 )
    return *(_DWORD *)(a1 + 4);
  if ( !ssl_init_done )
    sub_6C6B8();
  v3 = EVP_MD_CTX_new();
  v4 = EVP_MD_CTX_set_flags(v3, 8);
  v5 = EVP_md5(v4);
  if ( !EVP_DigestInit_ex(v3, v5, 0) )
  {
    sub_64E00(3, "MD5 init failed");
    EVP_MD_CTX_free(v3);
    exit(1);
  }
  EVP_DigestUpdate(v3, a1 + 8, 16);
  EVP_DigestFinal(v3, v7, &v6);
  EVP_MD_CTX_free(v3);
  return v7[0];
}
// B250: using guessed type int __fastcall EVP_DigestInit_ex(_DWORD, _DWORD, _DWORD);
// B644: using guessed type int __fastcall EVP_md5(_DWORD);
// B68C: using guessed type int __fastcall EVP_MD_CTX_set_flags(_DWORD, _DWORD);
// B6EC: using guessed type int __fastcall EVP_DigestUpdate(_DWORD, _DWORD, _DWORD);
// B848: using guessed type int __fastcall EVP_DigestFinal(_DWORD, _DWORD, _DWORD);
// B9C8: using guessed type int EVP_MD_CTX_new(void);
// BDF4: using guessed type int __fastcall EVP_MD_CTX_free(_DWORD);
// 1095B0: using guessed type int ssl_init_done;

//----- (00060930) --------------------------------------------------------
int __fastcall sub_60930(unsigned __int8 *a1, int *a2)
{
  unsigned __int8 *v2; // r5
  int v3; // r4
  int v5; // r8
  int v6; // r7
  const unsigned __int16 *v7; // r0
  int v8; // r2
  int v9; // r12
  int v10; // t1
  unsigned int v11; // r3

  v2 = a1;
  v3 = *a1;
  if ( v3 == 45 )
  {
    v3 = a1[1];
    v5 = 56;
    v2 = a1 + 1;
    v6 = 1;
  }
  else
  {
    v5 = 55;
    v6 = 0;
  }
  if ( v3 )
  {
    v7 = *_ctype_b_loc();
    v8 = 0;
    while ( 1 )
    {
      v11 = ((v7[v3] ^ 0x800u) >> 11) & 1;
      if ( v8 > 214748364 )
        v11 = 1;
      if ( v11 )
        break;
      if ( v8 == 214748364 && v5 < v3 )
        return 0;
      v9 = v3 - 48;
      v10 = *++v2;
      v3 = v10;
      v8 = v9 + 10 * v8;
      if ( !v10 )
      {
        if ( v6 )
          v8 = -v8;
        else
          *a2 = v8;
        if ( !v6 )
          return 1;
        *a2 = v8;
        return v6;
      }
    }
  }
  return 0;
}

//----- (00060A30) --------------------------------------------------------
int __fastcall sub_60A30(char *s2, int a2)
{
  int v4; // r4

  v4 = 0;
  while ( ((a2 >> v4) & 1) == 0 || strcmp(off_B4B64[v4], s2) )
  {
    if ( ++v4 == 25 )
      return -1;
  }
  return v4;
}
// B4B64: using guessed type char *off_B4B64[11];

//----- (00060AC0) --------------------------------------------------------
int __fastcall sub_60AC0(const char *a1, int a2, int a3)
{
  FILE *v4; // r8
  char *v5; // r0
  size_t v6; // r0
  size_t v7; // r9
  size_t v8; // r6
  int v9; // r4
  const unsigned __int16 **v10; // r0
  char *v11; // r3
  const unsigned __int16 *v12; // r1
  int v13; // t1
  int v14; // r4
  unsigned int v15; // r3
  const unsigned __int16 *v16; // r2
  char *v17; // r10
  char *v18; // r6
  int v19; // t1
  const unsigned __int16 **v20; // r0
  unsigned int v21; // r3
  int v22; // r3
  int v24; // r3
  int v26; // r0
  int v27; // t1
  int v28; // t1
  const char *v29; // r4
  int v30; // r2
  int v31; // r5
  int v32; // r4
  int v33; // r6
  int v34; // r0
  int v35; // r6
  int v36; // r0
  int *v38; // r0
  char *v39; // r0
  int *v40; // r0
  char *v41; // r0
  int *v42; // r0
  char *v43; // r0
  void *v46; // [sp+2Ch] [bp-108h] BYREF
  char v47[20]; // [sp+30h] [bp-104h] BYREF
  _BYTE v48[32]; // [sp+44h] [bp-F0h] BYREF
  char v49[100]; // [sp+64h] [bp-D0h] BYREF
  unsigned __int8 v50[100]; // [sp+C8h] [bp-6Ch] BYREF

  sub_6C054((int)v48, 0x1Eu, "/dev/mixer%d", a3);
  sub_6C054((int)v47, 0x14u, "%s%d", "/etc/ntp.audio", a3);
  v4 = (FILE *)fopen64(v47, "r");
  if ( v4
    || (_printf_chk(1, "audio_config_read: <%s> NO\n", v47),
        sub_6C054((int)v47, 0x14u, "%s.%d", "/etc/ntp.audio", a3),
        (v4 = (FILE *)fopen64(v47, "r")) != 0)
    || (_printf_chk(1, "audio_config_read: <%s> NO\n", v47),
        sub_6C054((int)v47, 0x14u, (unsigned __int8 *)"%s", "/etc/ntp.audio"),
        (v4 = (FILE *)fopen64(v47, "r")) != 0) )
  {
    _printf_chk(1, "audio_config_read: reading <%s>\n", v47);
    while ( 1 )
    {
      do
      {
LABEL_3:
        if ( !fgets(v49, 100, v4) )
        {
          fclose(v4);
          goto LABEL_49;
        }
        v5 = strchr(v49, 35);
        if ( v5 )
          *v5 = 0;
        v6 = strlen(v49);
        v7 = v6;
        if ( v6 )
        {
          v8 = v6 - 1;
          v9 = (unsigned __int8)v49[v6 - 1];
          if ( (v9 & 0x80) == 0 )
          {
            v10 = _ctype_b_loc();
            v11 = &v49[v8];
            v12 = *v10;
            while ( 1 )
            {
              v7 = v8 + 1;
              if ( (v12[v9] & 0x2000) == 0 )
                break;
              *v11 = 0;
              if ( !v8 )
                goto LABEL_46;
              v13 = (unsigned __int8)*--v11;
              v9 = v13;
              if ( (v13 & 0x80) != 0 )
              {
                v7 = v8;
                break;
              }
              --v8;
            }
          }
        }
        else
        {
LABEL_46:
          v7 = 0;
        }
        v14 = (unsigned __int8)v49[0];
      }
      while ( !v49[0] );
      v15 = v49[0] & 0x80;
      if ( v15 )
      {
        v17 = v49;
      }
      else
      {
        v16 = *_ctype_b_loc();
        v17 = v49;
        while ( (v16[v14] & 0x2000) != 0 )
        {
          v27 = (unsigned __int8)*++v17;
          v14 = v27;
          if ( !v27 )
            goto LABEL_3;
          v15 = v14 & 0xFFFFFF80;
          if ( (v14 & 0xFFFFFF80) != 0 )
            goto LABEL_19;
        }
        v14 = (unsigned __int8)*v17;
        if ( !*v17 )
        {
          v18 = v17;
          goto LABEL_35;
        }
        v15 = v14 & 0x80;
      }
LABEL_19:
      v18 = v17;
      while ( 1 )
      {
        if ( !v15 )
        {
          v20 = _ctype_b_loc();
          v21 = (*v20)[(__int16)v14];
          if ( (v21 & 0x200) != 0 )
          {
            *v18 = (*_ctype_toupper_loc())[(__int16)v14];
            goto LABEL_21;
          }
          v22 = (v21 >> 13) & 1;
          if ( v14 == 61 ? v22 | 1 : v22 )
            break;
        }
LABEL_21:
        v19 = (unsigned __int8)*++v18;
        v14 = v19;
        if ( !v19 )
          goto LABEL_35;
        v15 = v14 & 0xFFFFFF80;
      }
      v24 = (unsigned __int8)*v18;
      if ( *v18 )
      {
        do
        {
          if ( (v24 & 0x80) != 0 )
            break;
          if ( v24 != 61 && !(((*v20)[v24] >> 13) & 1) )
            break;
          v28 = (unsigned __int8)*++v18;
          v24 = v28;
        }
        while ( v28 );
      }
LABEL_35:
      if ( !strncmp(v17, "IDEV", 4u) && sscanf(v18, "%99s", v50) == 1 )
      {
        sub_6D4DC(byte_106FC8, v50, (int)&dword_64);
        _printf_chk(1, "idev <%s>\n", (const char *)v50);
      }
      else if ( !strncmp(v17, "CDEV", 4u) && sscanf(v18, "%99s", v50) == 1 )
      {
        sub_6D4DC(byte_106F64, v50, 100);
        _printf_chk(1, "cdev <%s>\n", (const char *)v50);
      }
      else if ( !strncmp(v17, "AGC", 3u) && sscanf(v18, "%99s", v50) == 1 )
      {
        sub_6D4DC(byte_10702C, v50, 100);
        _printf_chk(1, "agc <%s> %d\n", (const char *)v50, v7);
      }
      else if ( !strncmp(v17, "MONITOR", 7u) && sscanf(v18, "%99s", v50) == 1 )
      {
        sub_6D4DC(byte_107090, v50, 100);
        v26 = sub_60A30((char *)v50, -1);
        _printf_chk(1, "monitor <%s> %d\n", (const char *)v50, v26);
      }
    }
  }
  _printf_chk(1, "audio_config_read: <%s> NO\n", v47);
LABEL_49:
  v29 = v48;
  if ( byte_106F64[0] )
    v29 = byte_106F64;
  if ( byte_106FC8[0] )
    a1 = byte_106FC8;
  v31 = open64(a1, 2050, 511);
  if ( v31 < 0 )
  {
    sub_64E00(3, "audio_init: %s %m", a1);
  }
  else
  {
    dword_1070F4 = open64(v29, 2, v30);
    if ( dword_1070F4 < 0 )
    {
      sub_64E00(3, "audio_init: invalid control device <%s>", v29);
      close(v31);
      return dword_1070F4;
    }
    else
    {
      _printf_chk(1, "audio_init: <%s> bufsiz %d\n", a1, a2);
      v46 = &unk_100006;
      if ( ioctl(v31, 0xC004500A, &v46) == -1 )
      {
        v42 = _errno_location();
        v43 = strerror(*v42);
        _printf_chk(1, "audio_init: SNDCTL_DSP_SETFRAGMENT: %s\n", v43);
      }
      v32 = dword_1070F4;
      if ( ioctl(dword_1070F4, 0x80044DFE, &dword_1070F8) == -1 )
      {
        v40 = _errno_location();
        v41 = strerror(*v40);
        _printf_chk(1, "SOUND_MIXER_READ_DEVMASK: %s\n", v41);
        v32 = dword_1070F4;
      }
      if ( ioctl(v32, 0x80044DFD, &dword_1070FC) == -1 )
      {
        v38 = _errno_location();
        v39 = strerror(*v38);
        _printf_chk(1, "SOUND_MIXER_READ_RECMASK: %s\n", v39);
      }
      if ( byte_10702C[0] )
      {
        v33 = dword_1070FC;
        v34 = sub_60A30(byte_10702C, dword_1070FC);
        if ( v34 < 0 )
          _printf_chk(1, "input %s not in recmask %#x\n", byte_10702C, v33);
        else
          dword_B7CC0 = v34 | 0xC0044D00;
      }
      if ( byte_107090[0] )
      {
        v35 = dword_1070F8;
        v36 = sub_60A30(byte_107090, dword_1070F8);
        if ( v36 < 0 )
          _printf_chk(1, "monitor %s not in devmask %#x\n", byte_107090, v35);
        else
          dword_B7CC4 = v36 | 0xC0044D00;
      }
    }
  }
  return v31;
}
// 60C70: mask 0xFFFFFF80 is shortened because r4.4 <= 0xFF
// 60E5C: variable 'v30' is possibly undefined
// 64: using guessed type int;
// B4C0: using guessed type int _printf_chk(_DWORD, const char *, ...);
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// B7CC0: using guessed type int dword_B7CC0;
// B7CC4: using guessed type int dword_B7CC4;
// 1070F4: using guessed type int dword_1070F4;
// 1070F8: using guessed type int dword_1070F8;
// 1070FC: using guessed type int dword_1070FC;

//----- (000612E0) --------------------------------------------------------
int __fastcall sub_612E0(int a1, int a2, int a3)
{
  int v5; // r8
  unsigned int v6; // r1
  int v7; // r7
  int *v8; // r2
  unsigned int v9; // r1
  unsigned int v10; // r1
  int v11; // r3
  int *v13; // r0
  char *v14; // r0
  int *v15; // r0
  char *v16; // r0
  int *v17; // r0
  char *v18; // r0
  int v19; // [sp+0h] [bp-8h] BYREF

  v5 = dword_1070F4;
  v19 = (100 * a1 / 255) | ((100 * a1 / 255) << 8);
  if ( byte_10702C )
  {
    v7 = ioctl(dword_1070F4, dword_B7CC0, &v19);
  }
  else
  {
    v6 = -1073459961;
    if ( a3 == 2 )
      v6 = -1073459962;
    v7 = ioctl(dword_1070F4, v6, &v19);
  }
  if ( v7 == -1 )
  {
    v13 = _errno_location();
    v14 = strerror(*v13);
    _printf_chk(1, "audio_gain: agc write: %s\n", v14);
  }
  else
  {
    v8 = &dword_B7CC0;
    if ( dword_B7CC8 != a2 )
    {
      if ( byte_107090 )
      {
        v9 = dword_B7CC4;
      }
      else
      {
        v9 = 19712;
        v8 = &v19;
      }
      if ( byte_107090 )
        v8 = &v19;
      else
        HIWORD(v9) = -16380;
      v19 = (100 * a2 / 255) | ((100 * a2 / 255) << 8);
      v7 = ioctl(v5, v9, v8);
      if ( v7 == -1 )
      {
        v17 = _errno_location();
        v18 = strerror(*v17);
        _printf_chk(1, "audio_gain: mongain write: %s\n", v18);
        return v7;
      }
      dword_B7CC8 = a2;
    }
    if ( dword_B7CCC != a3 )
    {
      LOWORD(v10) = 19967;
      if ( a3 == 2 )
        v11 = 64;
      else
        v11 = 128;
      HIWORD(v10) = -16380;
      v19 = v11;
      v7 = ioctl(v5, v10, &v19);
      if ( v7 == -1 )
      {
        v15 = _errno_location();
        v16 = strerror(*v15);
        _printf_chk(1, "SOUND_MIXER_WRITE_RECSRC: %s\n", v16);
      }
      else
      {
        dword_B7CCC = a3;
      }
    }
  }
  return v7;
}
// B4C0: using guessed type int _printf_chk(_DWORD, const char *, ...);
// B7CC0: using guessed type int dword_B7CC0;
// B7CC4: using guessed type int dword_B7CC4;
// B7CC8: using guessed type int dword_B7CC8;
// B7CCC: using guessed type int dword_B7CCC;
// 10702C: using guessed type char byte_10702C;
// 107090: using guessed type char byte_107090;
// 1070F4: using guessed type int dword_1070F4;

//----- (00061520) --------------------------------------------------------
int sub_61520()
{
  int result; // r0
  int *v1; // r0
  char *v2; // r0
  int v3; // [sp+0h] [bp-8h] BYREF

  v3 = 0;
  _printf_chk(1, "audio_show: ctl_fd %d\n", dword_1070F4);
  result = ioctl(dword_1070F4, 0x80044DFF, &v3);
  if ( result == -1 )
  {
    v1 = _errno_location();
    v2 = strerror(*v1);
    return _printf_chk(1, "SOUND_MIXER_READ_RECSRC: %s\n", v2);
  }
  return result;
}
// B4C0: using guessed type int _printf_chk(_DWORD, const char *, ...);
// 1070F4: using guessed type int dword_1070F4;

//----- (000615D8) --------------------------------------------------------
int *sub_615D8()
{
  cache_keyid = 0;
  cache_type = 0;
  cache_flags = 0;
  cache_secret = 0;
  cache_secretsize = 0;
  cache_keyacclist = 0;
  return &cache_secretsize;
}
// 108D04: using guessed type int cache_keyacclist;
// 108D08: using guessed type int cache_secretsize;
// 108D0C: using guessed type __int16 cache_flags;
// 108D10: using guessed type int cache_secret;
// 108D1C: using guessed type int cache_type;
// 108D34: using guessed type int cache_keyid;

//----- (00061680) --------------------------------------------------------
_DWORD *__fastcall sub_61680(int a1, _DWORD *a2, int a3)
{
  _DWORD *result; // r0
  int v7; // r12
  int v8; // r1
  int v9; // r9
  int v10; // lr
  int v11; // r1

  result = sub_63BA4(0, 0x24u, 0, 0);
  v7 = a2[1];
  v8 = a2[2];
  v9 = a2[3];
  result[1] = *a2;
  result[2] = v7;
  result[3] = v8;
  result[4] = v9;
  v10 = a2[4];
  v11 = a2[6];
  result[6] = a2[5];
  result[5] = v10;
  result[7] = v11;
  result[8] = a3;
  *result = a1;
  return result;
}

//----- (00061724) --------------------------------------------------------
_DWORD *__fastcall sub_61724(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  if ( a1 )
  {
    v1 = (_DWORD *)*a1;
    free(a1);
  }
  return v1;
}

//----- (0006177C) --------------------------------------------------------
int __fastcall sub_6177C(_DWORD *a1)
{
  for ( ; a1; a1 = sub_61724(a1) )
    ;
  return 0;
}

//----- (000617D8) --------------------------------------------------------
int __fastcall sub_617D8(int result)
{
  int v1; // r4
  void *v2; // r0
  int v3; // r8
  int v4; // r7
  _DWORD *v5; // r9
  _DWORD **v6; // r1
  _DWORD *v7; // r3
  int v8; // r1

  v1 = result;
  if ( result )
  {
    if ( *(_DWORD *)(result + 24) == cache_keyid )
      sub_615D8();
    sub_6177C(*(_DWORD **)(v1 + 16));
    v2 = *(void **)(v1 + 12);
    v3 = key_hash;
    v4 = (unsigned __int16)authhashmask & *(_DWORD *)(v1 + 24);
    v5 = (_DWORD *)(key_hash + 4 * v4);
    if ( v2 )
    {
      memset(v2, 0, *(_DWORD *)(v1 + 32));
      free(*(void **)(v1 + 12));
    }
    v6 = *(_DWORD ***)(v3 + 4 * v4);
    if ( (_DWORD **)v1 != v6 )
    {
      if ( !v6 )
        goto LABEL_15;
      v7 = *v6;
      if ( !*v6 )
        goto LABEL_15;
      while ( (_DWORD *)v1 != v7 )
      {
        v6 = (_DWORD **)v7;
        if ( !*v7 )
          goto LABEL_15;
        v7 = (_DWORD *)*v7;
      }
      v5 = v6;
      v6 = (_DWORD **)v1;
    }
    *v5 = *v6;
LABEL_15:
    result = *(_DWORD *)(v1 + 4);
    *(_DWORD *)(result + 8) = *(_DWORD *)(v1 + 8);
    *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4) = result;
    *(_DWORD *)(v1 + 12) = 0;
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 24) = 0;
    *(_DWORD *)(v1 + 28) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    *(_DWORD *)(v1 + 36) = 0;
    v8 = authfreekeys;
    authfreekeys = v1;
    *(_DWORD *)(v1 + 8) = v8;
    --authnumkeys;
    ++authnumfreekeys;
  }
  return result;
}
// B7CD0: using guessed type __int16 authhashmask;
// 108CF8: using guessed type int key_hash;
// 108CFC: using guessed type int authfreekeys;
// 108D24: using guessed type int authnumkeys;
// 108D28: using guessed type int authnumfreekeys;
// 108D34: using guessed type int cache_keyid;

//----- (00061968) --------------------------------------------------------
unsigned __int16 *__fastcall sub_61968(unsigned __int16 *result, unsigned __int16 *a2, unsigned int a3)
{
  int v3; // r12
  _BOOL4 v4; // r3
  int v5; // r5
  _BOOL4 v6; // lr
  unsigned __int8 *v7; // r7
  unsigned __int8 *v8; // r8
  unsigned int v9; // r5
  int v10; // r6

  if ( result )
  {
    v3 = *result;
    v4 = a2 == 0;
    if ( !*result )
      v4 = 1;
    if ( v4 )
      return 0;
    v5 = *a2;
    v6 = v5 == 0;
    if ( v3 != v5 )
      v6 = 1;
    if ( v6 )
      return 0;
    if ( v3 == 2 )
    {
      v7 = (unsigned __int8 *)(result + 2);
      if ( a3 >= 0x20 )
        a3 = 32;
      v8 = (unsigned __int8 *)(a2 + 2);
    }
    else
    {
      if ( v3 != 10 || *((_DWORD *)result + 6) != *((_DWORD *)a2 + 6) )
        return 0;
      v7 = (unsigned __int8 *)(result + 4);
      if ( a3 >= 0x80 )
        a3 = 128;
      v8 = (unsigned __int8 *)(a2 + 4);
    }
    v9 = a3 >> 3;
    v10 = (unsigned __int8)~(0xFFu >> (a3 & 7));
    if ( !(a3 >> 3) || !memcmp(v7, v8, a3 >> 3) )
      return (unsigned __int16 *)(!v10 || (v10 & (v7[v9] ^ v8[v9])) == 0);
    return 0;
  }
  return result;
}

//----- (00061A8C) --------------------------------------------------------
unsigned __int16 *__fastcall sub_61A8C(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned __int16 *v3; // r4
  unsigned __int16 *result; // r0

  v3 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      result = sub_61968(v3 + 2, a2, *((_DWORD *)v3 + 8));
      if ( result )
        break;
      v3 = *(unsigned __int16 **)v3;
      if ( !v3 )
        return result;
    }
    return (_WORD *)(&dword_0 + 1);
  }
  else
  {
    result = a3;
    if ( a3 )
      return (_WORD *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (00061B14) --------------------------------------------------------
void *sub_61B14()
{
  size_t v0; // r5
  void *result; // r0

  v0 = 4 * (unsigned __int16)authhashbuckets;
  key_hash = (int)sub_63BA4((void *)key_hash, v0, 0, 0);
  result = memset((void *)key_hash, 0, v0);
  dword_108D44 = (int)&key_listhead;
  dword_108D40 = (int)&key_listhead;
  return result;
}
// B7CD2: using guessed type __int16 authhashbuckets;
// 108CF8: using guessed type int key_hash;
// 108D40: using guessed type int dword_108D40;
// 108D44: using guessed type int dword_108D44;

//----- (00061BB0) --------------------------------------------------------
_DWORD *__fastcall sub_61BB0(int a1)
{
  unsigned int v1; // r4
  unsigned int v2; // r1
  _DWORD *result; // r0
  _DWORD *v4; // r3
  unsigned int v5; // r2
  int v6; // r1

  v1 = a1;
  if ( a1 > 0 )
    v2 = a1;
  else
    v2 = 16;
  if ( a1 <= 0 )
    v1 = v2;
  result = sub_63C68(0, v2, 0x28u, 0);
  v4 = result;
  v5 = v1;
  authnumfreekeys += v1;
  v6 = authfreekeys;
  while ( 1 )
  {
    --v5;
    v4[2] = v6;
    v6 = (int)v4;
    if ( !v5 )
      break;
    v4 += 10;
  }
  authfreekeys = (int)&result[10 * v1 - 10];
  return result;
}
// 108CFC: using guessed type int authfreekeys;
// 108D28: using guessed type int authnumfreekeys;

//----- (00061C70) --------------------------------------------------------
int __fastcall sub_61C70(int a1, __int16 a2, __int16 a3, int a4, int a5, int a6, int a7)
{
  int v8; // r3
  int v9; // r12
  int v10; // r7
  int v11; // r5
  int v12; // r12
  int result; // r0
  int v14; // lr
  int v15; // r1
  int v16; // lr
  __int16 v18; // [sp+Ch] [bp-18h]
  __int16 v19; // [sp+10h] [bp-14h]

  v8 = a5;
  v9 = authnumfreekeys;
  v10 = key_hash;
  v11 = (unsigned __int16)(authhashmask & a1);
  if ( authnumfreekeys <= 0 )
  {
    v19 = a3;
    v18 = a2;
    sub_61BB0(-1);
    v9 = authnumfreekeys;
    a3 = v19;
    v8 = a5;
    a2 = v18;
  }
  v12 = v9 - 1;
  result = authfreekeys;
  if ( authfreekeys )
    authfreekeys = *(_DWORD *)(authfreekeys + 8);
  v14 = *(_DWORD *)(v10 + 4 * v11);
  *(_DWORD *)(result + 32) = v8;
  *(_DWORD *)result = v14;
  *(_WORD *)(result + 36) = a2;
  *(_WORD *)(result + 28) = a3;
  *(_DWORD *)(result + 24) = a1;
  *(_DWORD *)(result + 12) = a6;
  *(_DWORD *)(result + 16) = a7;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(v10 + 4 * v11) = result;
  authnumfreekeys = v12;
  v15 = dword_108D40;
  *(_DWORD *)(result + 8) = &key_listhead;
  *(_DWORD *)(result + 4) = v15;
  v16 = dword_108D40;
  dword_108D40 = result;
  *(_DWORD *)(v16 + 8) = result;
  ++authnumkeys;
  return result;
}
// B7CD0: using guessed type __int16 authhashmask;
// 108CF8: using guessed type int key_hash;
// 108CFC: using guessed type int authfreekeys;
// 108D24: using guessed type int authnumkeys;
// 108D28: using guessed type int authnumfreekeys;
// 108D40: using guessed type int dword_108D40;

//----- (00061DBC) --------------------------------------------------------
_DWORD *__fastcall sub_61DBC(int a1)
{
  unsigned int v1; // r1
  int v2; // r0
  unsigned int v3; // r1
  int v4; // r4
  __int16 v5; // r2
  int v6; // r3
  int v7; // r0
  unsigned int v8; // r1
  size_t v9; // r7
  _DWORD *result; // r0
  _DWORD *v11; // r3
  int v12; // r4
  int v13; // r1
  int v14; // r2

  v1 = authnumkeys + authnumfreekeys;
  v2 = a1 - (authnumkeys + authnumfreekeys);
  if ( v2 > 0 )
  {
    sub_61BB0(v2);
    v1 = authnumkeys + authnumfreekeys;
  }
  v3 = v1 >> 2;
  v4 = 5;
  v5 = 0;
  v6 = 16;
  v7 = -1;
  do
  {
    v7 <<= v6;
    if ( (v7 & v3) != 0 )
      v5 += v6;
    else
      v3 <<= v6;
    --v4;
    v6 >>= 1;
  }
  while ( v4 );
  v8 = (unsigned __int16)(v5 + 1);
  if ( v8 < 4 )
    v8 = 4;
  if ( v8 >= 0xF )
    LOBYTE(v8) = 15;
  v9 = 4 << v8;
  authhashbuckets = 1 << v8;
  authhashmask = (1 << v8) - 1;
  key_hash = (int)sub_63BA4((void *)key_hash, 4 << v8, 0, 0);
  result = memset((void *)key_hash, 0, v9);
  v11 = (_DWORD *)dword_108D44;
  if ( (_UNKNOWN *)dword_108D44 != &key_listhead )
  {
    v12 = (unsigned __int16)authhashmask;
    v13 = key_hash;
    do
    {
      result = (_DWORD *)v11[2];
      v14 = v11[6] & v12;
      *v11 = *(_DWORD *)(v13 + 4 * v14);
      *(_DWORD *)(v13 + 4 * v14) = v11;
      v11 = result;
    }
    while ( result != (_DWORD *)&key_listhead );
  }
  return result;
}
// B7CD0: using guessed type __int16 authhashmask;
// B7CD2: using guessed type __int16 authhashbuckets;
// 108CF8: using guessed type int key_hash;
// 108D24: using guessed type int authnumkeys;
// 108D28: using guessed type int authnumfreekeys;
// 108D44: using guessed type int dword_108D44;

//----- (00061F34) --------------------------------------------------------
_DWORD *__fastcall sub_61F34(int a1)
{
  _DWORD *i; // r3

  for ( i = *(_DWORD **)(key_hash + 4 * (unsigned __int16)(authhashmask & a1)); i && i[6] != a1; i = (_DWORD *)*i )
    ;
  return i;
}
// B7CD0: using guessed type __int16 authhashmask;
// 108CF8: using guessed type int key_hash;

//----- (00061FD4) --------------------------------------------------------
bool __fastcall sub_61FD4(int a1)
{
  return !a1 || cache_keyid == a1 || sub_61F34(a1) != 0;
}
// 108D34: using guessed type int cache_keyid;

//----- (0006204C) --------------------------------------------------------
int __fastcall sub_6204C(int a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r3
  int v3; // r2
  __int16 v4; // r1
  int result; // r0
  int v6; // r6
  int v7; // r1
  int v8; // r12

  ++authkeylookups;
  if ( !a1 || cache_keyid == a1 )
    return cache_flags & 1;
  ++authkeyuncached;
  v1 = sub_61F34(a1);
  v2 = v1;
  if ( v1 && (v3 = *((unsigned __int16 *)v1 + 14), *((_WORD *)v1 + 14)) )
  {
    v4 = *((_WORD *)v1 + 18);
    result = v4 & 1;
    if ( (v4 & 1) != 0 )
    {
      cache_keyid = v2[6];
      v6 = v2[3];
      cache_type = v3;
      cache_flags = v4;
      v7 = v2[4];
      v8 = v2[8];
      cache_secret = v6;
      cache_secretsize = v8;
      cache_keyacclist = v7;
      return 1;
    }
    else
    {
      ++authnokey;
    }
  }
  else
  {
    ++authkeynotfound;
    return 0;
  }
  return result;
}
// 108D04: using guessed type int cache_keyacclist;
// 108D08: using guessed type int cache_secretsize;
// 108D0C: using guessed type __int16 cache_flags;
// 108D10: using guessed type int cache_secret;
// 108D18: using guessed type int authkeyuncached;
// 108D1C: using guessed type int cache_type;
// 108D30: using guessed type int authkeynotfound;
// 108D34: using guessed type int cache_keyid;
// 108D38: using guessed type int authnokey;
// 108D64: using guessed type int authkeylookups;

//----- (000621BC) --------------------------------------------------------
_DWORD *__fastcall sub_621BC(int a1, unsigned int a2)
{
  _DWORD *result; // r0
  int v5; // r3
  _DWORD *v6; // [sp+14h] [bp-10h]

  result = sub_61F34(a1);
  if ( __PAIR64__(a2, (unsigned int)result) )
  {
    if ( result )
    {
      if ( a1 == cache_keyid )
      {
        v6 = result;
        sub_615D8();
        result = v6;
      }
      if ( a2 )
      {
        *((_WORD *)result + 18) |= 1u;
        if ( a2 <= 1 )
          result[5] = 0;
        else
          result[5] = current_time + a2;
      }
      else
      {
        return (_DWORD *)sub_617D8((int)result);
      }
    }
    else
    {
      if ( a2 > 1 )
        v5 = a2 + current_time;
      else
        v5 = 0;
      return (_DWORD *)sub_61C70(a1, 1, 0, v5, 0, 0, 0);
    }
  }
  return result;
}
// 108CA4: using guessed type int current_time;
// 108D34: using guessed type int cache_keyid;

//----- (000622E0) --------------------------------------------------------
int __fastcall sub_622E0(int a1)
{
  _DWORD *v1; // r0

  if ( cache_keyid == a1 )
    return cache_flags & 1;
  ++authkeyuncached;
  v1 = sub_61F34(a1);
  if ( v1 && (v1[9] & 1) != 0 )
    return 1;
  ++authkeynotfound;
  return 0;
}
// 108D0C: using guessed type __int16 cache_flags;
// 108D18: using guessed type int authkeyuncached;
// 108D30: using guessed type int authkeynotfound;
// 108D34: using guessed type int cache_keyid;

//----- (000623A4) --------------------------------------------------------
_DWORD *__fastcall sub_623A4(int a1, unsigned __int16 *a2)
{
  _DWORD *result; // r0
  __int16 v4; // r1

  if ( cache_keyid == a1 )
  {
    if ( (cache_flags & 1) == 0 )
      return 0;
    return (_DWORD *)(sub_61A8C((unsigned __int16 *)cache_keyacclist, a2, (unsigned __int16 *)((char *)&dword_0 + 1)) != 0);
  }
  else
  {
    result = sub_61F34(a1);
    if ( result )
    {
      v4 = *((_WORD *)result + 18);
      ++authkeyuncached;
      if ( (v4 & 1) == 0 )
        return 0;
      return (_DWORD *)(sub_61A8C((unsigned __int16 *)result[4], a2, (unsigned __int16 *)((char *)&dword_0 + 1)) != 0);
    }
    else
    {
      ++authkeynotfound;
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 108D04: using guessed type int cache_keyacclist;
// 108D0C: using guessed type __int16 cache_flags;
// 108D18: using guessed type int authkeyuncached;
// 108D30: using guessed type int authkeynotfound;
// 108D34: using guessed type int cache_keyid;

//----- (000624AC) --------------------------------------------------------
int *__fastcall sub_624AC(int a1, __int16 a2, const void *a3, size_t a4, int a5)
{
  _DWORD *v9; // r0
  _DWORD *v10; // r10
  void *v11; // r5
  int *result; // r0
  void *v13; // r0
  void *v14; // r0
  _DWORD *v15; // r3

  v9 = sub_61F34(a1);
  v10 = v9;
  if ( v9 && v9[6] == a1 )
  {
    v13 = (void *)v9[3];
    if ( v13 )
    {
      memset(v13, 0, v10[8]);
      free((void *)v10[3]);
    }
    v14 = sub_63BA4(0, a4 + 1, 0, 0);
    v15 = (_DWORD *)v10[4];
    v10[3] = v14;
    *((_WORD *)v10 + 14) = a2;
    v10[8] = a4;
    if ( v15 != (_DWORD *)a5 )
    {
      sub_6177C(v15);
      v14 = (void *)v10[3];
      v10[4] = a5;
    }
    result = (int *)memcpy(v14, a3, a4);
    if ( a1 == cache_keyid )
      return sub_615D8();
  }
  else
  {
    v11 = sub_63BA4(0, a4 + 1, 0, 0);
    memcpy(v11, a3, a4);
    return (int *)sub_61C70(a1, 0, a2, 0, a4, (int)v11, a5);
  }
  return result;
}
// 108D34: using guessed type int cache_keyid;

//----- (000625F8) --------------------------------------------------------
void sub_625F8()
{
  int v0; // r4
  void *v1; // r0
  int v2; // r0
  void *v3; // r5
  int v4; // r0

  v0 = dword_108D44;
  if ( (_UNKNOWN *)dword_108D44 != &key_listhead )
  {
    do
    {
      while ( 1 )
      {
        v3 = *(void **)(v0 + 8);
        if ( *(_DWORD *)(v0 + 24) < 0x10000u )
          break;
LABEL_6:
        v0 = (int)v3;
        if ( v3 == &key_listhead )
          return;
      }
      if ( (*(_WORD *)(v0 + 36) & 1) != 0 )
      {
        v1 = *(void **)(v0 + 12);
        if ( v1 )
        {
          memset(v1, 0, *(_DWORD *)(v0 + 32));
          free(*(void **)(v0 + 12));
          *(_DWORD *)(v0 + 12) = 0;
        }
        v2 = sub_6177C(*(_DWORD **)(v0 + 16));
        *(_DWORD *)(v0 + 32) = 0;
        *(_DWORD *)(v0 + 16) = v2;
        *(_DWORD *)(v0 + 20) = 0;
        goto LABEL_6;
      }
      v4 = v0;
      v0 = *(_DWORD *)(v0 + 8);
      sub_617D8(v4);
    }
    while ( v3 != &key_listhead );
  }
}
// 108D44: using guessed type int dword_108D44;

//----- (000626D0) --------------------------------------------------------
int sub_626D0()
{
  int result; // r0
  unsigned int v1; // r3
  void *v2; // r4

  result = dword_108D44;
  if ( (_UNKNOWN *)dword_108D44 != &key_listhead )
  {
    do
    {
      while ( 1 )
      {
        v1 = *(_DWORD *)(result + 20);
        v2 = *(void **)(result + 8);
        if ( v1 )
        {
          if ( v1 < current_time )
            break;
        }
        result = *(_DWORD *)(result + 8);
        if ( v2 == &key_listhead )
          return result;
      }
      sub_617D8(result);
      result = (int)v2;
      ++authkeyexpired;
    }
    while ( v2 != &key_listhead );
  }
  return result;
}
// 108CA4: using guessed type int current_time;
// 108D14: using guessed type int authkeyexpired;
// 108D44: using guessed type int dword_108D44;

//----- (0006278C) --------------------------------------------------------
size_t __fastcall sub_6278C(size_t result, int a2, int a3)
{
  bool v4; // zf
  unsigned int v6; // r3

  v4 = result == 0;
  v6 = bswap32(result);
  if ( !result )
    result = 4;
  ++authencryptions;
  *(_DWORD *)(a2 + (a3 & 0xFFFFFFFC)) = v6;
  if ( !v4 )
  {
    result = sub_6204C(result);
    if ( result )
      return sub_606CC(cache_type, cache_secret, cache_secretsize, a2, a3);
  }
  return result;
}
// 108D08: using guessed type int cache_secretsize;
// 108D10: using guessed type int cache_secret;
// 108D1C: using guessed type int cache_type;
// 108D2C: using guessed type int authencryptions;

//----- (00062854) --------------------------------------------------------
bool __fastcall sub_62854(int a1, int a2, int a3, unsigned int a4)
{
  int v8; // r0
  bool v9; // cc

  ++authdecryptions;
  if ( !a1 )
    return 0;
  v8 = sub_6204C(a1);
  v9 = v8 != 0;
  if ( v8 )
    v9 = a4 > 3;
  return v9 && sub_60770(cache_type, cache_secret, cache_secretsize, a2, a3, a4);
}
// 108D00: using guessed type int authdecryptions;
// 108D08: using guessed type int cache_secretsize;
// 108D10: using guessed type int cache_secret;
// 108D1C: using guessed type int cache_type;

//----- (0006291C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_6291C(unsigned __int8 **a1)
{
  unsigned __int8 *result; // r0
  int v3; // r3
  bool v4; // zf
  int v5; // t1
  bool v6; // zf
  unsigned __int8 *v7; // r1
  int v8; // r3
  unsigned __int8 *v9; // r12
  _BOOL4 v10; // r2
  bool v11; // zf
  unsigned __int8 *v12; // r1
  bool v13; // zf

  result = *a1;
  v3 = *result;
  v4 = v3 == 9;
  if ( v3 != 9 )
    v4 = v3 == 32;
  if ( v4 )
  {
    do
    {
      v5 = *++result;
      v3 = v5;
      v6 = v5 == 9;
      if ( v5 != 9 )
        v6 = v3 == 32;
    }
    while ( v6 );
  }
  if ( (v3 & 0xDF) == 0 || (unsigned int)(v3 - 9) <= 1 || v3 == 35 )
    return 0;
  v7 = result;
  while ( 1 )
  {
    v8 = v7[1];
    v9 = v7 + 1;
    v10 = v8 != 10;
    if ( !v7[1] )
      v10 = 0;
    if ( !v10 )
      break;
    v11 = v8 == 32;
    if ( v8 != 32 )
      v11 = v8 == 9;
    if ( v11 )
    {
      if ( v9 == result )
        return 0;
LABEL_21:
      v12 = v7 + 2;
      *v9 = 0;
LABEL_22:
      *a1 = v12;
      return result;
    }
    ++v7;
    if ( v8 == 35 )
    {
      if ( v9 == result )
        return 0;
LABEL_27:
      v12 = v9;
      *v9 = 0;
      goto LABEL_22;
    }
  }
  if ( v9 != result )
  {
    v13 = v8 == 9;
    if ( v8 != 9 )
      v13 = v8 == 32;
    if ( v13 )
      goto LABEL_21;
    goto LABEL_27;
  }
  return 0;
}

//----- (00062A30) --------------------------------------------------------
char *sub_62A30(char *result, unsigned __int8 *a2, ...)
{
  unsigned int v2; // r3
  va_list varg_r2; // [sp+18h] [bp+Ch] BYREF

  va_start(varg_r2, a2);
  if ( !result )
    return sub_64E88(3, a2, (int *)varg_r2);
  v2 = *(_DWORD *)result + 1;
  *(_DWORD *)result = v2;
  if ( v2 <= 5 )
    return sub_64E88(3, a2, (int *)varg_r2);
  return result;
}

//----- (00062AB4) --------------------------------------------------------
void __fastcall sub_62AB4(_DWORD *ptr)
{
  _DWORD *i; // r0

  for ( i = (_DWORD *)ptr[1]; i; i = (_DWORD *)ptr[1] )
  {
    ptr[1] = *i;
    free(i);
  }
  free(ptr);
}

//----- (00062B28) --------------------------------------------------------
int __fastcall sub_62B28(const char *a1)
{
  _DWORD *v1; // r11
  unsigned __int8 *v2; // r0
  const char *v3; // r4
  unsigned int v4; // r0
  unsigned int v5; // r9
  unsigned __int8 *v6; // r0
  int v7; // r0
  int v8; // r0
  unsigned __int8 *v9; // r0
  unsigned __int8 *v10; // r6
  size_t v11; // r0
  size_t v12; // r4
  _DWORD *v13; // r8
  unsigned __int8 *v14; // r7
  char *v15; // r6
  char *v16; // r0
  int v17; // r11
  unsigned int v18; // r4
  char *v19; // r5
  const unsigned __int16 **v20; // r0
  char *v21; // r2
  const unsigned __int16 *v22; // r0
  int v23; // r3
  int v24; // t1
  unsigned int v25; // r3
  _BOOL4 v26; // r2
  unsigned __int8 *v27; // r6
  size_t v28; // r8
  const __int32_t *v29; // r7
  int v30; // t1
  char *v31; // r0
  bool v32; // zf
  size_t v33; // r3
  char v34; // r0
  _BYTE *v35; // r2
  char v36; // r0
  size_t v37; // r4
  const char *v38; // r3
  _DWORD *v39; // r0
  _DWORD *v40; // r4
  _DWORD *v42; // r5
  FILE *stream; // [sp+8h] [bp-274h]
  int v44; // [sp+10h] [bp-26Ch]
  _DWORD *v45; // [sp+20h] [bp-25Ch]
  char *v47; // [sp+30h] [bp-24Ch] BYREF
  unsigned int v48; // [sp+34h] [bp-248h] BYREF
  unsigned __int16 v49[14]; // [sp+38h] [bp-244h] BYREF
  char src[32]; // [sp+54h] [bp-228h] BYREF
  char v51[512]; // [sp+74h] [bp-208h] BYREF
  _BYTE v52[4]; // [sp+278h] [bp-4h] BYREF

  stream = (FILE *)fopen64(a1, "r");
  if ( !stream )
  {
    sub_64E00(3, "authreadkeys: file '%s': %m", a1);
    return 0;
  }
  if ( !ssl_init_done )
    sub_6C6B8();
  v48 = 0;
  v1 = 0;
  while ( 1 )
  {
    v47 = fgets(v51, 512, stream);
    if ( !v47 || v48 > 0xF )
      break;
    v2 = sub_6291C((unsigned __int8 **)&v47);
    v3 = (const char *)v2;
    if ( v2 )
    {
      v4 = strtol((const char *)v2, 0, 10);
      v5 = v4;
      if ( v4 )
      {
        if ( v4 >= 0x10000 )
        {
          sub_62A30((char *)&v48, "authreadkeys: key %s > %d reserved for Autokey", v3, 0xFFFF);
        }
        else
        {
          v6 = sub_6291C((unsigned __int8 **)&v47);
          if ( v6 )
          {
            v7 = sub_6C910(v6, 0);
            v44 = v7;
            if ( v7 )
            {
              if ( v7 != 894 )
              {
                v8 = OBJ_nid2sn(v7);
                if ( !EVP_get_digestbyname(v8) )
                {
                  v44 = 0;
                  sub_62A30(0, "authreadkeys: no algorithm for key %d", v5);
                }
              }
              v9 = sub_6291C((unsigned __int8 **)&v47);
              v10 = v9;
              if ( !v9 )
                goto LABEL_73;
LABEL_16:
              v11 = strlen((const char *)v9);
              v12 = v11;
              if ( v11 <= 0x14 )
              {
                v13 = sub_63BA4(0, v11 + 20, 0, 0);
                v13[2] = v5;
                *((_WORD *)v13 + 7) = v12;
                *((_WORD *)v13 + 6) = v44;
                v13[1] = 0;
                memcpy(v13 + 4, v10, v12);
                goto LABEL_18;
              }
              v27 = v10 - 1;
              if ( v11 >= 0x40 )
                v12 = 64;
              v28 = 0;
              v29 = *_ctype_tolower_loc();
              while ( 1 )
              {
                v30 = *++v27;
                v31 = strchr("0123456789abcdef", v29[v30]);
                if ( !v31 )
                  break;
                v32 = (v28 & 1) == 0;
                v33 = v28 >> 1;
                if ( (v28 & 1) != 0 )
                  v33 += (size_t)v52;
                v34 = (_BYTE)v31 - (unsigned __int8)"0123456789abcdef";
                if ( (v28 & 1) != 0 )
                  v35 = (_BYTE *)*(unsigned __int8 *)(v33 - 548);
                else
                  v35 = v52;
                ++v28;
                if ( v32 )
                  v36 = 16 * v34;
                else
                  v36 = v34 | (unsigned __int8)v35;
                if ( v32 )
                  v33 += (size_t)v35;
                *(_BYTE *)(v33 - 548) = v36;
                if ( v12 == v28 )
                  goto LABEL_62;
              }
              if ( v12 <= v28 )
              {
LABEL_62:
                v37 = v12 >> 1;
                v13 = sub_63BA4(0, v37 + 20, 0, 0);
                v13[2] = v5;
                *((_WORD *)v13 + 7) = v37;
                *((_WORD *)v13 + 6) = v44;
                v13[1] = 0;
                memcpy(v13 + 4, src, v37);
LABEL_18:
                v14 = sub_6291C((unsigned __int8 **)&v47);
                if ( v14 )
                {
                  v45 = v1;
                  while ( 1 )
                  {
                    v15 = strchr((const char *)v14, 44);
                    if ( v15 )
                      *v15 = 0;
                    v16 = strchr((const char *)v14, 47);
                    if ( v16 )
                    {
                      v17 = (unsigned __int8)v16[1];
                      v18 = 0;
                      *v16 = 0;
                      v19 = v16 + 1;
                      if ( v17 )
                      {
                        v20 = _ctype_b_loc();
                        v21 = v19;
                        v22 = *v20;
                        do
                        {
                          v25 = ((v22[v17] ^ 0x800u) >> 11) & 1;
                          if ( v18 > 0x3E8 )
                            v25 = 1;
                          if ( v25 )
                          {
                            sub_62A30(
                              (char *)&v48,
                              "authreadkeys: Invalid character in subnet specification for <%s/%s> in key %d",
                              v21,
                              v19,
                              v5);
                            goto LABEL_30;
                          }
                          v23 = v17 - 48;
                          v24 = (unsigned __int8)*++v21;
                          v17 = v24;
                          v18 = v23 + 10 * v18;
                        }
                        while ( v24 );
                        if ( sub_64054((int)v14, 0, v49) )
                        {
                          if ( v18 != -1 )
                          {
                            if ( v49[0] == 2 )
                            {
                              if ( v18 > 0x20 )
                                goto LABEL_75;
                            }
                            else
                            {
                              v26 = v18 > 0x80;
                              if ( v49[0] != 10 )
                                v26 = 0;
                              if ( !v26 )
                                goto LABEL_42;
LABEL_75:
                              sub_62A30(0, "authreadkeys: excessive subnet mask <%s/%s> for key %d", v14, v19, v5);
                            }
                          }
LABEL_42:
                          v13[1] = sub_61680(v13[1], v49, v18);
                          goto LABEL_30;
                        }
                      }
                      else if ( sub_64054((int)v14, 0, v49) )
                      {
                        v18 = 0;
                        goto LABEL_42;
                      }
                    }
                    else if ( sub_64054((int)v14, 0, v49) )
                    {
                      v18 = -1;
                      goto LABEL_42;
                    }
                    sub_62A30((char *)&v48, "authreadkeys: invalid IP address <%s> for key %d", v14, v5);
LABEL_30:
                    if ( v15 )
                    {
                      v14 = (unsigned __int8 *)(v15 + 1);
                      if ( v15 != (char *)-1 )
                        continue;
                    }
                    v1 = v45;
                    break;
                  }
                }
                if ( v44 )
                {
                  *v13 = v1;
                  v1 = v13;
                }
                else
                {
                  sub_62AB4(v13);
                }
              }
              else
              {
                sub_62A30((char *)&v48, "authreadkeys: invalid hex digit for key %d", v5);
              }
            }
            else
            {
              sub_62A30(0, "authreadkeys: invalid type for key %d", v5);
              v9 = sub_6291C((unsigned __int8 **)&v47);
              v10 = v9;
              if ( v9 )
                goto LABEL_16;
LABEL_73:
              sub_62A30((char *)&v48, "authreadkeys: no key for key %d", v5);
            }
          }
          else
          {
            sub_62A30((char *)&v48, "authreadkeys: no key type for key %d", v5);
          }
        }
      }
      else
      {
        sub_62A30((char *)&v48, "authreadkeys: cannot change key %s", v3);
      }
    }
  }
  fclose(stream);
  if ( v48 )
  {
    if ( v48 > 0xF )
      v38 = " (emergency break)";
    else
      v38 = byte_97F7C;
    sub_64E00(3, "authreadkeys: rejecting file '%s' after %u error(s)%s", a1, v48, v38);
    if ( v1 )
    {
      v39 = v1;
      do
      {
        v40 = (_DWORD *)*v39;
        sub_62AB4(v39);
        v39 = v40;
      }
      while ( v40 );
    }
    return 0;
  }
  else
  {
    sub_625F8();
    if ( v1 )
    {
      do
      {
        v42 = (_DWORD *)*v1;
        sub_624AC(v1[2], *((_WORD *)v1 + 6), v1 + 4, *((unsigned __int16 *)v1 + 7), v1[1]);
        v1[1] = 0;
        sub_62AB4(v1);
        v1 = v42;
      }
      while ( v42 );
    }
    return 1;
  }
}
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// 1095B0: using guessed type int ssl_init_done;

//----- (00063138) --------------------------------------------------------
int __fastcall sub_63138(int a1, _BYTE *a2)
{
  int v4[2]; // [sp+0h] [bp-28h] BYREF
  __int64 v5; // [sp+8h] [bp-20h] BYREF
  int v6[3]; // [sp+10h] [bp-18h] BYREF
  _DWORD v7[2]; // [sp+1Ch] [bp-Ch] BYREF

  if ( !a2 )
    sub_6ECC0("caljulian.c", 31, 2, "((void *)0) != jt");
  sub_658E8(&v5, a1, 0);
  *(_QWORD *)v6 = v5;
  sub_6598C(v4, v6);
  v7[0] = v4[0];
  v7[1] = v4[1];
  return sub_65EE8(a2, v7, 693596);
}

//----- (000631F0) --------------------------------------------------------
int __fastcall sub_631F0(unsigned __int16 *a1)
{
  int v2; // r5
  int v3; // r0
  __int64 v5; // [sp+0h] [bp-10h] BYREF

  if ( !a1 )
    sub_6ECC0("caltontp.c", 43, 0, "jt != ((void *)0)");
  if ( *((unsigned __int8 *)a1 + 4) > 0xDu )
    sub_6ECC0("caltontp.c", 45, 0, "jt->month <= 13");
  if ( *((unsigned __int8 *)a1 + 5) > 0x20u )
    sub_6ECC0("caltontp.c", 46, 0, "jt->monthday <= 32");
  if ( a1[1] > 0x16Eu )
    sub_6ECC0("caltontp.c", 47, 0, "jt->yearday <= 366");
  if ( *((unsigned __int8 *)a1 + 6) > 0x18u )
    sub_6ECC0("caltontp.c", 48, 0, "jt->hour <= 24");
  if ( *((unsigned __int8 *)a1 + 7) > 0x3Cu )
    sub_6ECC0("caltontp.c", 49, 0, "jt->minute <= (60)");
  if ( *((unsigned __int8 *)a1 + 8) > 0x3Cu )
    sub_6ECC0("caltontp.c", 50, 0, "jt->second <= (60)");
  if ( a1[1] )
    v2 = a1[1] + sub_6648C(*a1) - 1;
  else
    v2 = sub_66428(a1);
  v3 = sub_6636C(*((unsigned __int8 *)a1 + 6), *((unsigned __int8 *)a1 + 7), *((unsigned __int8 *)a1 + 8));
  sub_66038(&v5, v2 - 693596, v3);
  return v5;
}

//----- (000633D8) --------------------------------------------------------
bool __fastcall sub_633D8(int a1, int a2, int a3, int a4, int a5, int a6, int *a7, _DWORD *a8)
{
  int v8; // r2
  int v9; // r0
  int v10; // r4
  int v11; // r3
  int v12; // r0
  int v13; // r5
  int v14; // r7
  unsigned int v15; // r0
  int v16; // r1
  unsigned int v17; // r0
  int v18; // r3
  _BYTE *v19; // r3
  _BOOL4 result; // r0
  int v21; // r2
  int v22; // r3
  __int64 v23; // [sp+10h] [bp-44h] BYREF
  __int64 v24; // [sp+18h] [bp-3Ch] BYREF
  int v25[5]; // [sp+20h] [bp-34h] BYREF
  _DWORD v26[3]; // [sp+34h] [bp-20h]
  unsigned int v27; // [sp+40h] [bp-14h]
  unsigned int v28; // [sp+44h] [bp-10h]
  unsigned int v29; // [sp+48h] [bp-Ch]
  _BYTE v30[4]; // [sp+50h] [bp-4h] BYREF

  v8 = a3 + 60 * (a2 + a5 + 24 * (a1 - 1));
  v9 = *a7;
  v10 = a4 + 60 * v8;
  if ( !*a7 )
    goto LABEL_5;
  v11 = v9 + v10;
  v12 = v9 + v10 - a6;
  if ( v12 < 0 )
    v12 = -v12;
  v26[0] = v11;
  v27 = v12;
  if ( (unsigned int)v12 <= 0xEFF0FF )
  {
    *a8 = v11;
    return (unsigned int)v12 < 0x3840;
  }
  else
  {
LABEL_5:
    sub_658E8(&v23, a6 - v10, 0);
    v24 = v23;
    sub_6598C(v25, (int *)&v24);
    v13 = 0;
    sub_65A30((unsigned int *)v25, v25[0] + 693595, 0);
    v14 = v25[0] - 1;
    do
    {
      v15 = (_DWORD)&off_15180 * (sub_660F4(v14 + v13) - 693595);
      v25[v13 + 2] = v15;
      v16 = v10 + v15 - a6;
      v26[v13] = v10 + v15;
      if ( v16 < 0 )
        v16 = a6 - (v10 + v15);
      *(&v27 + v13++) = v16;
    }
    while ( v13 != 3 );
    v17 = v28;
    v18 = v27;
    if ( v27 >= v28 )
      v18 = 1;
    else
      v17 = v27;
    if ( v27 < v28 )
      v18 = 0;
    if ( v29 < v17 )
    {
      v17 = v29;
      v18 = 2;
    }
    v19 = &v30[4 * v18];
    result = v17 < 0x3840;
    v21 = *((_DWORD *)v19 - 7);
    v22 = *((_DWORD *)v19 - 10);
    *a8 = v21;
    *a7 = v22;
  }
  return result;
}
// 15180: using guessed type char *off_15180;

//----- (000635A0) --------------------------------------------------------
int __fastcall sub_635A0(const char *a1, _DWORD *a2)
{
  char *v2; // r5
  const char *v3; // r7
  char *v5; // r0
  struct addrinfo *v6; // r5
  __int16 v7; // r3
  int v9; // r3
  char *v10; // r12
  bool v11; // zf
  char *v12; // r1
  char *v13; // r2
  int v14; // t1
  bool v15; // zf
  unsigned __int8 *v16; // r1
  char *v17; // r0
  unsigned __int16 v18; // [sp+6h] [bp-7Ah] BYREF
  struct addrinfo *pai; // [sp+8h] [bp-78h] BYREF
  addrinfo req; // [sp+Ch] [bp-74h] BYREF
  char v21[80]; // [sp+2Ch] [bp-54h] BYREF

  v2 = (char *)a1;
  v3 = 0;
  pai = 0;
  if ( !a1 )
    sub_6ECC0("decodenetnum.c", 38, 0, "num != ((void *)0)");
  if ( strlen(a1) > 0x4F )
    return 0;
  if ( *v2 == 91 )
  {
    v9 = (unsigned __int8)v2[1];
    v10 = v2 + 1;
    v11 = v9 == 0;
    if ( v2[1] )
      v11 = v9 == 93;
    if ( v11 )
    {
      v12 = v21;
    }
    else
    {
      v13 = v2 + 2;
      v12 = v21;
      do
      {
        *v12++ = v9;
        v10 = v13;
        v14 = (unsigned __int8)*v13++;
        v9 = v14;
        v15 = v14 == 0;
        if ( v14 )
          v15 = v9 == 93;
      }
      while ( !v15 );
    }
    v3 = 0;
    *v12 = 0;
    if ( v9 == 93 && v10[1] == 58 && (v3 = (const char *)(unsigned __int8)v10[2], v10[2]) )
    {
      v3 = v10 + 2;
      v2 = v21;
    }
    else
    {
      v2 = v21;
    }
  }
  else
  {
    v5 = strchr(v2, 58);
    if ( v5 )
    {
      if ( !strchr(v5 + 1, 58) )
      {
        v16 = (unsigned __int8 *)v2;
        v2 = v21;
        sub_6D4DC(v21, v16, 80);
        v17 = strchr(v21, 58);
        *v17 = 0;
        v3 = v17 + 1;
      }
    }
    else
    {
      v3 = 0;
    }
  }
  memset(&req.ai_family, 0, 28);
  req.ai_flags = 4;
  if ( getaddrinfo(v2, "ntp", &req, &pai) )
    return 0;
  v6 = pai;
  if ( pai->ai_addrlen > 0x1C )
    sub_6ECC0("decodenetnum.c", 78, 2, "ai->ai_addrlen <= sizeof(*netnum)");
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  a2[6] = 0;
  memcpy(a2, v6->ai_addr, v6->ai_addrlen);
  freeaddrinfo(v6);
  if ( v3 && sscanf(v3, "%hu", &v18) == 1 )
    v7 = __rev16(v18);
  else
    v7 = 31488;
  *((_WORD *)a2 + 1) = v7;
  return 1;
}

//----- (00063804) --------------------------------------------------------
char *__fastcall sub_63804(unsigned int a1, unsigned int a2, int a3, int a4, int a5)
{
  int v9; // r7
  char *v10; // r6
  char *v11; // r3
  char *v12; // r2
  int v13; // r12
  bool v14; // cc
  char v15; // r1
  int v16; // r10
  char *v17; // r8
  bool v18; // cc
  unsigned int v19; // r12
  unsigned int v20; // r1
  int v21; // r5
  bool v22; // cf
  char v23; // r0
  char v24; // r1
  char v25; // r0
  char v26; // r1
  bool v27; // cc
  char *v28; // r1
  _BYTE *v30; // r0
  _BYTE *v31; // r1
  char v32; // t1
  char *v34; // r0
  char v35; // t1
  int v36; // r1
  _BYTE *v37; // r12
  _DWORD v38[6]; // [sp+Ch] [bp-20h] BYREF

  v9 = lib_nextbuf;
  v10 = &lib_stringbuf[128 * lib_nextbuf];
  memset(v10, 0, 0x80u);
  memset(v38, 0, sizeof(v38));
  v11 = (char *)&v38[2] + 2;
  lib_nextbuf = ((_BYTE)v9 + 1) & 0xF;
  if ( a1 )
  {
    v12 = (char *)&v38[2] + 2;
    v13 = 10;
    do
    {
      --v13;
      v14 = a1 / 0xA == 0;
      if ( a1 / 0xA )
        v14 = v13 <= 0;
      v15 = a1 % 0xA;
      a1 /= 0xAu;
      *--v12 = v15;
    }
    while ( !v14 );
  }
  else
  {
    v12 = (char *)&v38[2] + 2;
  }
  if ( a4 < 0 )
  {
    if ( !a5 )
    {
      v17 = (char *)&v38[2] + 2;
      goto LABEL_48;
    }
    v16 = 3;
    goto LABEL_12;
  }
  if ( a5 )
  {
    v16 = a4 + 3;
    if ( a4 + 3 >= 14 )
      v16 = 14;
LABEL_12:
    v17 = (char *)&v38[3] + 1;
    if ( !a2 )
      goto LABEL_28;
    goto LABEL_20;
  }
  if ( a4 >= 14 )
    v16 = 14;
  else
    v16 = a4;
  v18 = (int)a2 <= 0;
  if ( a2 )
    v18 = a4 <= 0;
  v17 = (char *)&v38[2] + 2;
  if ( !v18 )
  {
    do
    {
LABEL_20:
      v19 = a2 >> 31;
      v20 = (2 * a2) >> 31;
      v21 = (a2 >> 29) & 1;
      v22 = __CFADD__(2 * a2, 8 * a2);
      a2 *= 10;
      v23 = v20 | (2 * v19);
      --v16;
      v24 = v22;
      v25 = v21 | (2 * v23);
      v26 = v24 + v19;
      v27 = (int)a2 <= 0;
      if ( a2 )
        v27 = v16 <= 0;
      *v11++ = v26 + v25;
    }
    while ( !v27 );
  }
  if ( v16 )
  {
LABEL_28:
    v11 += v16;
    goto LABEL_29;
  }
LABEL_48:
  v34 = v11;
  if ( ((v11 - (char *)v38 > 0) & (a2 >> 31)) != 0 )
  {
    while ( 1 )
    {
      v35 = *--v34;
      v36 = (unsigned __int8)(v35 + 1);
      if ( v36 != 10 )
        break;
      *v34 = 0;
      if ( v34 - (char *)v38 <= 0 )
        goto LABEL_51;
    }
    *v34 = v36;
  }
LABEL_51:
  if ( v12 >= v34 )
    v12 = v34;
LABEL_29:
  if ( v12 >= v17 )
  {
LABEL_35:
    v12 = v17 - 1;
    goto LABEL_36;
  }
  if ( !*v12 )
  {
    v28 = v12 + 1;
    do
    {
      v12 = v28;
      if ( v28 == v17 )
        goto LABEL_35;
    }
    while ( !*v28++ );
  }
LABEL_36:
  if ( a3 )
  {
    v30 = v10 + 1;
    lib_stringbuf[128 * v9] = 45;
  }
  else
  {
    v30 = v10;
  }
  if ( v12 < v11 )
  {
    do
    {
      v37 = v30 + 1;
      if ( v12 == v17 )
      {
        v31 = v30++;
        *v31 = 46;
        v37 = v31 + 2;
      }
      v32 = *v12++;
      *v30 = v32 + 48;
      v30 = v37;
    }
    while ( v12 != v11 );
  }
  else
  {
    v37 = v30;
  }
  *v37 = 0;
  return v10;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (00063AC4) --------------------------------------------------------
char *__fastcall sub_63AC4(signed int a1, unsigned int a2, int a3)
{
  int v4; // r2

  v4 = (unsigned int)a1 >> 31;
  if ( a1 < 0 )
  {
    a2 = -a2;
    a1 = ~a1;
    if ( !a2 )
      ++a1;
  }
  return sub_63804(a1, a2, v4, a3, 0);
}

//----- (00063B34) --------------------------------------------------------
char *__fastcall sub_63B34(signed int a1, unsigned int a2, int a3)
{
  int v4; // r2

  v4 = (unsigned int)a1 >> 31;
  if ( a1 < 0 )
  {
    a2 = -a2;
    a1 = ~a1;
    if ( !a2 )
      ++a1;
  }
  return sub_63804(a1, a2, v4, a3, 1);
}

//----- (00063BA4) --------------------------------------------------------
void *__fastcall sub_63BA4(void *a1, size_t a2, size_t a3, int a4)
{
  char *v7; // r0
  void *v8; // r6
  bool v9; // cc

  if ( !a2 )
  {
    v8 = realloc(a1, 1u);
    if ( v8 )
      return v8;
LABEL_10:
    msyslog_term = 1;
    sub_64E00(3, "fatal out of memory (%lu bytes)", a2);
    exit(1);
  }
  v7 = (char *)realloc(a1, a2);
  v8 = v7;
  if ( !v7 )
    goto LABEL_10;
  v9 = a4 != 0;
  if ( a4 )
    v9 = a2 > a3;
  if ( v9 )
    memset(&v7[a3], 0, a2 - a3);
  return v8;
}
// 107114: using guessed type int msyslog_term;

//----- (00063C68) --------------------------------------------------------
void *__fastcall sub_63C68(void *a1, unsigned int a2, unsigned int a3, int a4)
{
  bool v4; // cc
  int v5; // r12

  v4 = a3 > 0xFFFF;
  if ( a3 <= 0xFFFF )
    v4 = a2 > 0xFFFF;
  v5 = v4;
  if ( !a2 )
    v5 = 0;
  if ( v5 && !is_mul_ok(a3, a2) )
  {
    sub_64E00(3, "fatal allocation size overflow");
    exit(1);
  }
  return sub_63BA4(a1, a4 + a3 * a2, 0, 1);
}

//----- (00063D08) --------------------------------------------------------
void *__fastcall sub_63D08(const char *a1)
{
  size_t v2; // r5
  void *v3; // r0

  v2 = strlen(a1) + 1;
  v3 = sub_63BA4(0, v2, 0, 0);
  return memcpy(v3, a1, v2);
}

//----- (00063D78) --------------------------------------------------------
void sub_63D78()
{
  ;
}

//----- (00063DC0) --------------------------------------------------------
int __fastcall sub_63DC0(int a1, int a2)
{
  double v2; // d0
  int v4; // r5
  size_t v5; // r8
  int v6; // r9
  int v7; // r1
  int v8; // r2
  _BYTE *v9; // r0
  char *v10; // lr
  char v11; // r4
  char v12; // r3
  _BYTE *v13; // r3
  _DWORD *v14; // r3
  ssize_t v15; // r0
  int v18; // [sp+10h] [bp-20h] BYREF
  _DWORD v19[2]; // [sp+14h] [bp-1Ch] BYREF
  _BYTE v20[10]; // [sp+1Ch] [bp-14h] BYREF
  char v21; // [sp+26h] [bp-Ah]

  v4 = a2;
  v18 = 16711423;
  v19[0] = 1504;
  v19[1] = -33751040;
  HIBYTE(v18) = a2;
  if ( a2 == 4 )
  {
    v5 = 11;
    v6 = 11;
  }
  else
  {
    v5 = 12;
    v4 = 5;
    v6 = 12;
  }
  sub_6C054((int)v20, 0x10u, " %10.0f", v2 * 1000000.0);
  LOBYTE(v7) = v21;
  if ( v21 == 32 )
  {
    v8 = 0;
  }
  else
  {
    v9 = v20;
    v10 = (char *)v19 + 1;
    v8 = 0;
    do
    {
      v11 = v9[9];
      v9 -= 2;
      v12 = v7 & 0xF;
      ++v8;
      v7 = (unsigned __int8)v9[10];
      *++v10 = v12 | (16 * v11);
    }
    while ( v7 != 32 );
    v13 = (char *)v19 + v8 + 2;
    if ( v4 <= v8 )
      goto LABEL_11;
  }
  v14 = (int *)((char *)&v18 + v8 + 5);
  do
  {
    *((_BYTE *)v14 + 1) = 0;
    v14 = (_DWORD *)((char *)v14 + 1);
  }
  while ( (_DWORD *)((char *)v19 + v4 + 1) != v14 );
  v13 = (char *)v19 + v4 + 2;
LABEL_11:
  *v13 = -3;
  v15 = write(a1, &v18, v5);
  if ( v15 == -1 )
  {
    sub_64E00(3, "icom_freq: write() failed: %m");
    return -1;
  }
  else if ( v15 == v6 )
  {
    return 0;
  }
  else
  {
    sub_64E00(3, "icom_freq: only wrote %d of %d bytes.", v15, v6);
    return 1;
  }
}
// 63E30: variable 'v2' is possibly undefined

//----- (00063F68) --------------------------------------------------------
int __fastcall sub_63F68(int a1, speed_t a2)
{
  int v3; // r0
  int v4; // r6
  int *v6; // r4
  int v7; // r0
  int v8; // r5
  struct termios v9; // [sp+0h] [bp-40h] BYREF

  v3 = open64(a1, 2, 511);
  v4 = v3;
  if ( v3 < 0 )
    return -1;
  if ( tcgetattr(v3, &v9) < 0
    || (v9.c_cflag = 2105,
        *(_WORD *)&v9.c_cc[5] = 5,
        v9.c_iflag = 0,
        v9.c_oflag = 0,
        v9.c_lflag = 0,
        cfsetispeed(&v9, a2),
        cfsetospeed(&v9, a2),
        tcsetattr(v4, 0, &v9) < 0) )
  {
    v6 = _errno_location();
    v7 = v4;
    v8 = *v6;
    v4 = -1;
    close(v7);
    *v6 = v8;
  }
  return v4;
}
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);

//----- (00064054) --------------------------------------------------------
int __fastcall sub_64054(int a1, int a2, _DWORD *a3)
{
  int v6; // r5
  struct addrinfo *v7; // lr
  struct sockaddr *ai_addr; // r2
  char *v9; // r3
  int v10; // r5
  int v11; // r0
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int result; // r0
  int v16; // r3
  char *v17; // r0
  int buf; // [sp+4h] [bp-ACh] BYREF
  struct addrinfo *pai; // [sp+8h] [bp-A8h] BYREF
  struct addrinfo req; // [sp+Ch] [bp-A4h] BYREF
  char v21[128]; // [sp+2Ch] [bp-84h] BYREF

  if ( !a1 )
    sub_6ECC0("is_ip_address.c", 40, 0, "host != ((void *)0)");
  if ( !a3 )
    sub_6ECC0("is_ip_address.c", 41, 0, "addr != ((void *)0)");
  *a3 = 0;
  v6 = a2 == 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  a3[4] = 0;
  a3[5] = 0;
  a3[6] = 0;
  if ( (a2 & 0xFFFD) != 0 || (result = inet_pton(2, (const char *)a1, &buf), result != 1) )
  {
    if ( a2 == 10 )
      v6 |= 1u;
    if ( !v6 || strlen((const char *)a1) > 0x7F )
      return 0;
    if ( *(_BYTE *)a1 == 91 )
    {
      sub_6D4DC(v21, (unsigned __int8 *)(a1 + 1), 128);
      v17 = strchr(v21, 93);
      if ( v17 )
        *v17 = 0;
    }
    else
    {
      sub_6D4DC(v21, (unsigned __int8 *)a1, 128);
    }
    memset(&req.ai_socktype, 0, 24);
    req.ai_family = 10;
    req.ai_flags = 4;
    if ( getaddrinfo(v21, 0, &req, &pai) )
    {
      return 0;
    }
    else
    {
      v7 = pai;
      *(_WORD *)a3 = 10;
      ai_addr = v7->ai_addr;
      v9 = &ai_addr->sa_data[6];
      v10 = *(_DWORD *)&ai_addr[1].sa_data[6];
      v11 = *(_DWORD *)&ai_addr->sa_data[6];
      v12 = *(_DWORD *)&ai_addr->sa_data[10];
      v13 = *(_DWORD *)&ai_addr[1].sa_family;
      v14 = *((_DWORD *)v9 + 3);
      a3[2] = v11;
      a3[3] = v12;
      a3[4] = v13;
      a3[5] = v14;
      a3[6] = v10;
      freeaddrinfo(v7);
      return 1;
    }
  }
  else
  {
    v16 = buf;
    *(_WORD *)a3 = 2;
    a3[1] = v16;
  }
  return result;
}

//----- (00064244) --------------------------------------------------------
void sub_64244()
{
  if ( !lib_inited )
  {
    ipv4_works = sub_73C50() == 0;
    ipv6_works = sub_73CA8() == 0;
    sub_5F6E0();
    lib_inited = 1;
  }
}
// 108D68: using guessed type int ipv6_works;
// 108D6C: using guessed type int ipv4_works;
// 109578: using guessed type int lib_inited;

//----- (000642E4) --------------------------------------------------------
int __fastcall sub_642E4(const struct timeval *a1, const struct timezone *a2)
{
  int *v4; // r6
  int v5; // r8
  int v6; // r3
  int v7; // r4
  bool v8; // zf
  int v10; // r0
  __suseconds_t tv_usec; // r12
  __time_t tv_sec; // r1
  int v13; // r0
  __time_t v14; // r3
  int v15; // r0
  int v16; // [sp+4h] [bp-18h]
  int v17; // [sp+4h] [bp-18h]
  int v18; // [sp+4h] [bp-18h]
  int v19; // [sp+4h] [bp-18h]
  struct timespec tp; // [sp+Ch] [bp-10h] BYREF

  if ( debug > 0 )
    sub_64D28("In ntp_set_tod\n");
  v4 = _errno_location();
  v5 = dword_107100;
  if ( (unsigned int)dword_107100 > 1 )
  {
    v6 = 0;
    v7 = -1;
    goto LABEL_6;
  }
  tv_usec = a1->tv_usec;
  tv_sec = a1->tv_sec;
  *v4 = 0;
  tp.tv_sec = tv_sec;
  tp.tv_nsec = 1000 * tv_usec;
  v13 = clock_settime(0, &tp);
  v7 = v13;
  v6 = *v4;
  if ( debug > 0 )
  {
    v18 = *v4;
    sub_64D28("ntp_set_tod: clock_settime: %d %m\n", v13);
    v5 = dword_107100;
    v6 = v18;
    if ( !(v7 | dword_107100) )
      goto LABEL_20;
  }
  else if ( !(v13 | v5) )
  {
LABEL_20:
    dword_107100 = 1;
    goto LABEL_16;
  }
  if ( !v7 )
  {
LABEL_16:
    *v4 = v6;
    if ( debug > 0 )
      sub_64D28("ntp_set_tod: Final result: %s: %d %m\n", set_tod_used[dword_107100], 0);
    goto LABEL_26;
  }
LABEL_6:
  if ( (v5 & 0xFFFFFFFD) != 0 )
    goto LABEL_7;
  tp.tv_sec = 0;
  tp.tv_nsec = 0;
  adjtime((const struct timeval *)&tp, 0);
  *v4 = v5 & 0xFFFFFFFD;
  v10 = settimeofday(a1, a2);
  v7 = v10;
  v6 = *v4;
  if ( debug <= 0 )
  {
    if ( v10 | v5 )
      goto LABEL_15;
    goto LABEL_28;
  }
  v17 = *v4;
  sub_64D28("ntp_set_tod: settimeofday: %d %m\n", v10);
  v6 = v17;
  v5 = dword_107100;
  if ( !(v7 | dword_107100) )
  {
LABEL_28:
    dword_107100 = 2;
    goto LABEL_16;
  }
LABEL_15:
  if ( !v7 )
    goto LABEL_16;
LABEL_7:
  v8 = v5 == 0;
  if ( v5 )
    v8 = v5 == 3;
  if ( !v8 )
  {
    *v4 = v6;
    if ( debug <= 0 )
    {
LABEL_11:
      *v4 = v6;
      return v7;
    }
LABEL_36:
    v19 = v6;
    sub_64D28("ntp_set_tod: Final result: %s: %d %m\n", set_tod_used[v5], v7);
    v6 = v19;
    goto LABEL_37;
  }
  v14 = a1->tv_sec;
  *v4 = 0;
  tp.tv_sec = v14;
  v15 = stime(&tp.tv_sec);
  v7 = v15;
  v6 = *v4;
  if ( debug > 0 )
  {
    v16 = *v4;
    sub_64D28("ntp_set_tod: stime: %d %m\n", v15);
    v6 = v16;
    v5 = dword_107100;
  }
  *v4 = v6;
  if ( !(v5 | v7) )
  {
    dword_107100 = 3;
    if ( debug > 0 )
      sub_64D28("ntp_set_tod: Final result: %s: %d %m\n", "stime", v5 | v7);
    goto LABEL_26;
  }
  if ( debug > 0 )
    goto LABEL_36;
LABEL_37:
  if ( v7 )
    goto LABEL_11;
LABEL_26:
  v7 = (int)set_tod_using;
  if ( set_tod_using )
  {
    set_tod_using(set_tod_used[dword_107100]);
    v7 = 0;
    set_tod_using = 0;
  }
  return v7;
}
// 107104: invalid function type '?' has been ignored
// B4BC8: using guessed type char *set_tod_used[4];
// 107100: using guessed type int dword_107100;
// 107104: using guessed type int (__fastcall *set_tod_using)(_DWORD);
// 108D74: using guessed type int debug;

//----- (00064648) --------------------------------------------------------
_BYTE *__fastcall sub_64648(unsigned int a1)
{
  _BYTE *v2; // r4
  int v4; // r7

  if ( a1 <= 8 )
    return *(&off_B4BD8 + a1);
  v2 = &lib_stringbuf[128 * lib_nextbuf];
  v4 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v2, 0, 0x80u);
  lib_nextbuf = v4;
  sub_6C054((int)v2, 0x80u, "mode#%zu", a1);
  return v2;
}
// B4BD8: using guessed type _UNKNOWN *off_B4BD8;
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (00064708) --------------------------------------------------------
unsigned __int8 *__fastcall sub_64708(int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *result; // r0
  bool v7; // cc
  int *v8; // r0

  *a2 = 0;
  result = (unsigned __int8 *)strerror_r();
  if ( result )
  {
    v7 = a2 > result;
    if ( a2 != result )
      v7 = (unsigned int)result > a3;
    if ( v7 )
      return (unsigned __int8 *)sub_6D4DC(a2, result, a3);
  }
  else if ( !*a2 )
  {
    v8 = _errno_location();
    return (unsigned __int8 *)sub_6C054((int)a2, a3, "%s(%d): errno %d", "strerror_r", a1, *v8);
  }
  return result;
}
// B638: using guessed type int strerror_r(void);

//----- (000647E0) --------------------------------------------------------
int __fastcall sub_647E0(_BYTE *a1, int a2, unsigned __int8 *a3, int a4)
{
  _BYTE *v4; // r4
  unsigned int v6; // r6
  int result; // r0
  int v8; // r3
  unsigned __int8 *v9; // r5
  size_t v10; // r0
  _BYTE *v11; // r3
  size_t v12; // r2
  void *v13; // r0
  unsigned __int8 v14[256]; // [sp+4h] [bp+0h] BYREF

  v4 = a1;
  v6 = (unsigned int)&a1[a2 - 1];
LABEL_2:
  result = *a3;
  if ( *a3 )
  {
    while ( v6 > (unsigned int)v4 )
    {
      if ( result == 37 )
      {
        v8 = a3[1];
        v9 = a3 + 2;
        if ( v8 == 109 )
        {
          sub_64708(a4, v14, 0x100u);
          v10 = strlen((const char *)v14);
          v11 = &v4[v10];
          if ( (unsigned int)&v4[v10] < v6 )
          {
            v12 = v10;
            v13 = v4;
            v4 = v11;
            memcpy(v13, v14, v12);
          }
          a3 = v9;
        }
        else
        {
          *v4 = 37;
          if ( !v8 )
          {
            ++v4;
            break;
          }
          v4[1] = v8;
          a3 += 2;
          v4 += 2;
        }
        goto LABEL_2;
      }
      ++a3;
      *v4 = result;
      result = *a3;
      ++v4;
      if ( !*a3 )
        break;
    }
  }
  *v4 = 0;
  return result;
}

//----- (000648EC) --------------------------------------------------------
char *__fastcall sub_648EC(int a1, char *s)
{
  int v4; // r5
  char *v5; // r0
  bool v6; // zf
  int v7; // r5
  int v8; // r6
  __pid_t v9; // r10
  char *result; // r0
  const char *v11; // r11
  FILE *v12; // r6
  int v13; // r0
  const char *v14; // [sp+1Ch] [bp-18h]
  char v15; // [sp+24h] [bp-10h] BYREF
  __int16 v16; // [sp+28h] [bp-Ch] BYREF

  v16 = 10;
  v15 = 0;
  v4 = progname;
  if ( progname != dword_107108 )
  {
    dword_107108 = progname;
    v5 = strrchr((const char *)progname, 47);
    v6 = v5 == 0;
    if ( v5 )
      ++v5;
    else
      dword_10710C = v4;
    if ( !v6 )
      dword_10710C = (int)v5;
  }
  v7 = syslogit;
  v8 = msyslog_term;
  if ( syslogit )
  {
    result = (char *)_syslog_chk(a1, 1, "%s", s);
    if ( !v8 )
      return result;
    v7 = 0;
  }
  else if ( syslog_file )
  {
    v7 = 1;
  }
  else
  {
    v8 = 1;
  }
  if ( msyslog_include_timestamp )
    v14 = sub_78740();
  else
    v14 = 0;
  if ( v7 | msyslog_term_pid )
    v9 = getpid();
  else
    v9 = -1;
  result = &s[strlen(s)];
  if ( *(result - 1) == 10 )
    v11 = &v15;
  else
    v11 = (const char *)&v16;
  if ( v8 )
  {
    if ( a1 <= 3 )
      v12 = stderr;
    else
      v12 = stdout;
    if ( msyslog_include_timestamp )
      _fprintf_chk(v12, 1, "%s ", v14);
    if ( msyslog_term_pid )
      _fprintf_chk(v12, 1, "%s[%d]: ", (const char *)dword_10710C, v9);
    _fprintf_chk(v12, 1, "%s%s", s, v11);
    result = (char *)fflush(v12);
  }
  if ( v7 )
  {
    v13 = syslog_file;
    if ( msyslog_include_timestamp )
    {
      _fprintf_chk(syslog_file, 1, "%s ", v14);
      v13 = syslog_file;
    }
    _fprintf_chk(v13, 1, "%s[%d]: %s%s", (const char *)dword_10710C, v9, s, v11);
    return (char *)fflush((FILE *)syslog_file);
  }
  return result;
}
// BB48: using guessed type int _syslog_chk(_DWORD, _DWORD, const char *, ...);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// B7CD8: using guessed type int msyslog_include_timestamp;
// B7CDC: using guessed type int msyslog_term_pid;
// B7CE0: using guessed type int syslogit;
// 107108: using guessed type int dword_107108;
// 10710C: using guessed type int dword_10710C;
// 107114: using guessed type int msyslog_term;
// 108184: using guessed type int progname;
// 109584: using guessed type int syslog_file;

//----- (00064BBC) --------------------------------------------------------
unsigned int __fastcall sub_64BBC(int a1, unsigned int a2, unsigned __int8 *a3, int *a4)
{
  int *v8; // r0
  unsigned __int8 v10[256]; // [sp+4h] [bp-104h] BYREF

  v8 = _errno_location();
  sub_647E0(v10, 256, a3, *v8);
  return sub_6B6F8(a1, a2, v10, a4);
}

//----- (00064C44) --------------------------------------------------------
int __fastcall sub_64C44(int a1, unsigned __int8 *a2, int a3)
{
  int *v6; // r0
  _BYTE v8[256]; // [sp+4h] [bp-108h] BYREF

  v6 = _errno_location();
  sub_647E0(v8, 256, a2, *v6);
  return _vfprintf_chk(a1, 1, v8, a3);
}
// BAAC: using guessed type int __fastcall _vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064CC4) --------------------------------------------------------
int sub_64CC4(int a1, unsigned __int8 *a2, ...)
{
  va_list varg_r2; // [sp+18h] [bp+Ch] BYREF

  va_start(varg_r2, a2);
  return sub_64C44(a1, a2, (int)varg_r2);
}

//----- (00064D28) --------------------------------------------------------
int sub_64D28(unsigned __int8 *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  return sub_64C44((int)stdout, a1, (int)varg_r1);
}

//----- (00064D9C) --------------------------------------------------------
unsigned int sub_64D9C(int a1, unsigned int a2, unsigned __int8 *a3, ...)
{
  va_list varg_r3; // [sp+1Ch] [bp+10h] BYREF

  va_start(varg_r3, a3);
  return sub_64BBC(a1, a2, a3, (int *)varg_r3);
}

//----- (00064E00) --------------------------------------------------------
char *sub_64E00(int a1, unsigned __int8 *a2, ...)
{
  char v4[1024]; // [sp+4h] [bp-408h] BYREF
  va_list varg_r2; // [sp+420h] [bp+14h] BYREF

  va_start(varg_r2, a2);
  sub_64BBC((int)v4, 0x400u, a2, (int *)varg_r2);
  return sub_648EC(a1, v4);
}

//----- (00064E88) --------------------------------------------------------
char *__fastcall sub_64E88(int a1, unsigned __int8 *a2, int *a3)
{
  char v5[1024]; // [sp+4h] [bp-404h] BYREF

  sub_64BBC((int)v5, 0x400u, a2, a3);
  return sub_648EC(a1, v5);
}

//----- (00064EFC) --------------------------------------------------------
int __fastcall sub_64EFC(char *s, int a2, int a3)
{
  const char *v3; // r7
  _BOOL4 v5; // r3
  char *v6; // r0
  const char *v7; // r0
  int v8; // r2

  v3 = s;
  v5 = ntp_syslogmask == -1;
  if ( !a2 )
    v5 = 0;
  if ( v5 )
    ntp_syslogmask = a2;
  v6 = strrchr(s, 47);
  if ( v6 )
    v3 = v6 + 1;
  v7 = (const char *)sub_63D08(v3);
  progname = (int)v7;
  if ( a3 )
  {
    v8 = 24;
    dword_107110 = 1;
  }
  else
  {
    v8 = dword_107110;
    if ( dword_107110 )
      v8 = 24;
  }
  openlog(v7, 9, v8);
  return setlogmask(255);
}
// B7CD4: using guessed type int ntp_syslogmask;
// 107110: using guessed type int dword_107110;
// 108184: using guessed type int progname;

//----- (00064FEC) --------------------------------------------------------
int __fastcall sub_64FEC(const char *a1, int a2)
{
  const char *v2; // r5
  int result; // r0
  int v5; // r0
  FILE ***v6; // r3
  int v7; // r8
  size_t v8; // r0
  size_t v9; // r10
  char *v10; // r8
  FILE *v11; // r11
  void *v12; // r0
  void *v13; // r0
  size_t v14; // [sp+14h] [bp-210h]
  int v15; // [sp+14h] [bp-210h]
  char buf[520]; // [sp+1Ch] [bp-208h] BYREF

  v2 = a1;
  if ( !a1 )
    sub_6ECC0("msyslog.c", 469, 0, "fname != ((void *)0)");
  if ( syslog_file )
  {
    if ( syslog_fname )
    {
      result = strcmp((const char *)syslog_fname, a1);
      if ( !result )
        return result;
    }
  }
  v5 = strcmp(v2, "stderr");
  v6 = (FILE ***)&stderr_ptr;
  if ( v5 )
  {
    if ( strcmp(v2, "stdout") )
    {
      v7 = syslog_abs_fname;
      if ( syslog_fname && !strcmp(v2, (const char *)syslog_fname) )
      {
        v2 = (const char *)v7;
      }
      else if ( v2 != (const char *)v7 && *v2 != 47 && getcwd(buf, 0x200u) )
      {
        v8 = strlen(buf);
        v9 = v8;
        if ( v8 > 1 && buf[v8 - 1] == 47 )
          v9 = v8 - 1;
        v14 = strlen(v2) + v9 + 2;
        v10 = (char *)sub_63BA4(0, v14, 0, 0);
        sub_6C054((int)v10, v14, "%.*s%c%s", v9, buf, 47, v2);
        goto LABEL_18;
      }
      v10 = (char *)sub_63D08(v2);
LABEL_18:
      if ( debug > 0 )
        sub_64D28("attempting to open log %s\n", v10);
      v11 = (FILE *)fopen64(v10, &off_99960);
      goto LABEL_21;
    }
    v6 = (FILE ***)&stdout_ptr;
  }
  v11 = **v6;
  v10 = (char *)sub_63D08(v2);
LABEL_21:
  if ( v11 )
  {
    if ( a2 && (syslogit || (const char *)syslog_abs_fname != v2) )
      sub_64E00(5, "switching logging to file %s", v10);
    if ( syslog_file && (struct _IO_FILE *)syslog_file != stderr && (struct _IO_FILE *)syslog_file != stdout )
    {
      v15 = fileno((FILE *)syslog_file);
      if ( v15 != fileno(v11) )
        fclose((FILE *)syslog_file);
    }
    syslog_file = (int)v11;
    if ( (const char *)syslog_abs_fname == v2 )
    {
      free(v10);
      goto LABEL_34;
    }
    v12 = (void *)syslog_fname;
    if ( syslog_abs_fname )
    {
      if ( syslog_abs_fname == syslog_fname )
        goto LABEL_40;
      free((void *)syslog_abs_fname);
      v12 = (void *)syslog_fname;
    }
    if ( !v12 )
    {
LABEL_33:
      v13 = sub_63D08(v2);
      syslog_abs_fname = (int)v10;
      syslog_fname = (int)v13;
LABEL_34:
      syslogit = 0;
      return 0;
    }
LABEL_40:
    free(v12);
    goto LABEL_33;
  }
  free(v10);
  return -1;
}
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 99960: using guessed type _UNKNOWN *off_99960;
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B7CE0: using guessed type int syslogit;
// 108D74: using guessed type int debug;
// 10957C: using guessed type int syslog_fname;
// 109580: using guessed type int syslog_abs_fname;
// 109584: using guessed type int syslog_file;

//----- (00065384) --------------------------------------------------------
const char *__fastcall sub_65384(const char *result)
{
  const char *v1; // r6
  int v2; // r2
  char *v3; // r1

  if ( syslog_fname )
  {
    result = (const char *)sub_64FEC((const char *)syslog_fname, 0);
    if ( result != (const char *)-1 )
      return result;
    v2 = syslog_fname;
    v3 = "Cannot reopen log file %s, %m";
    return sub_64E00(3, (unsigned __int8 *)v3, v2);
  }
  v1 = result;
  if ( result )
  {
    result = (const char *)sub_64FEC(result, 1);
    if ( result == (const char *)-1 )
    {
      v2 = (int)v1;
      v3 = "Cannot open log file %s, %m";
      return sub_64E00(3, (unsigned __int8 *)v3, v2);
    }
  }
  return result;
}
// 10957C: using guessed type int syslog_fname;

//----- (00065468) --------------------------------------------------------
_DWORD *__fastcall sub_65468(int *a1)
{
  int v2; // r0
  int v3; // r6
  int v4; // r1
  int v5; // r2
  int v6; // r8
  int v7; // r3
  int v8; // r5
  _DWORD *v9; // r10
  int v10; // r1
  int v11; // r2
  int v12; // r3
  _DWORD *v13; // r2
  unsigned int v15; // r3

  v2 = *a1;
  v3 = dword_107118[0];
  v4 = a1[1];
  v5 = a1[2];
  v6 = 8 * dword_107118[0];
  v7 = a1[3];
  v8 = 7 * dword_107118[0];
  v9 = (_DWORD *)((char *)&unk_10711C + 28 * dword_107118[0]);
  dword_107118[0] = (LOBYTE(dword_107118[0]) + 1) & 7;
  *v9 = v2;
  v9[1] = v4;
  v9[2] = v5;
  v9[3] = v7;
  v10 = a1[5];
  v11 = a1[6];
  v9[4] = a1[4];
  v9[5] = v10;
  v9[6] = v11;
  v12 = LOWORD(dword_107118[v8 + 1]);
  if ( v12 == 2 )
  {
    v15 = bswap32(dword_107118[v8 + 2]);
    if ( (v15 & 0xE0000000) == 0xC0000000 )
    {
      v15 &= 0xFFFFFF00;
    }
    else if ( (v15 & 0xC0000000) == 0x80000000 )
    {
      v15 = HIWORD(v15) << 16;
    }
    dword_107118[v6 - v3 + 2] = bswap32(v15);
  }
  else if ( v12 == 10 )
  {
    v13 = (_DWORD *)((char *)&unk_10711C + v8 * 4 + 16);
    *v13 = 0;
    v13[1] = 0;
  }
  return v9;
}
// 107118: using guessed type int dword_107118[57];

//----- (00065578) --------------------------------------------------------
void *__fastcall sub_65578(time_t (**a1)(time_t *timer))
{
  bool v1; // zf
  time_t (**v2)(time_t *); // r12
  void *result; // r0

  v2 = a1;
  v1 = a1 == 0;
  result = off_B7CE8;
  if ( v1 )
    v2 = &time;
  off_B7CE8 = v2;
  return result;
}
// B7CE8: using guessed type _UNKNOWN *off_B7CE8;

//----- (000655EC) --------------------------------------------------------
_QWORD *__fastcall sub_655EC(_QWORD *result)
{
  *result = (int)*_stack_chk_guard;
  return result;
}

//----- (00065644) --------------------------------------------------------
int __fastcall sub_65644(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0006568C) --------------------------------------------------------
char *__fastcall sub_6568C(int a1)
{
  int v2; // lr
  char *result; // r0
  int v4; // r6
  __int16 v5; // r0
  char v6; // r1
  char v7; // r3
  char v8; // r2
  __int16 v9; // [sp+16h] [bp-16h] BYREF
  __int16 v10; // [sp+18h] [bp-14h] BYREF
  __int16 v11; // [sp+1Ah] [bp-12h] BYREF
  __int16 v12; // [sp+1Ch] [bp-10h] BYREF
  __int16 v13; // [sp+1Eh] [bp-Eh] BYREF
  char v14[4]; // [sp+20h] [bp-Ch] BYREF
  int v15; // [sp+24h] [bp-8h]

  *(_DWORD *)(a1 + 6) = 0;
  v2 = _stack_chk_guard;
  *(_DWORD *)(a1 + 2) = 0;
  *(_WORD *)(a1 + 4) = 257;
  *(_WORD *)a1 = 1970;
  v15 = v2;
  if ( sscanf("10:15:31/Apr 16 2025", "%hu:%hu:%hu/%3s %hu %hu", &v9, &v10, &v11, v14, &v12, &v13) != 6 )
    return 0;
  result = strstr("JanFebMarAprMayJunJulAugSepOctNovDec", v14);
  if ( result )
  {
    v4 = result - "JanFebMarAprMayJunJulAugSepOctNovDec";
    v5 = v13;
    v6 = v12;
    v7 = v11;
    *(_BYTE *)(a1 + 6) = v9;
    v8 = v10;
    *(_WORD *)a1 = v5;
    *(_BYTE *)(a1 + 5) = v6;
    *(_BYTE *)(a1 + 7) = v8;
    *(_BYTE *)(a1 + 4) = (char)v4 / 3 + 1;
    *(_BYTE *)(a1 + 8) = v7;
    return (_BYTE *)(&dword_0 + 1);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (000657A8) --------------------------------------------------------
int __fastcall sub_657A8(int a1, int a2, int a3)
{
  signed int v3; // r5
  int v4; // r7
  int v5; // r4
  bool v6; // cc
  unsigned int v7; // r0
  int v8; // r8
  int v9; // r1

  v3 = a3;
  if ( a3 >= 0 )
  {
    v4 = 0;
  }
  else
  {
    v3 = -a3;
    v4 = 1;
  }
  v5 = a1;
  if ( v3 > 1 )
  {
    v6 = a1 <= a2;
    v7 = a1 > a2 ? a1 - a2 : a2 - a1;
    v8 = v6 ? v4 : v4 ^ 1;
    sub_8B8EC(v7, v3);
    if ( v9 )
    {
      if ( v8 )
        v9 = v3 - v9;
      if ( v4 )
        v9 = -v9;
      v5 += v9;
    }
  }
  return v5;
}
// 65804: variable 'v9' is possibly undefined

//----- (00065844) --------------------------------------------------------
_QWORD *__fastcall sub_65844(_QWORD *a1, int a2, time_t *timer)
{
  __int64 v5; // r0
  __int64 v6; // r10

  if ( timer )
    v5 = *timer;
  else
    v5 = off_B7CE8(0);
  LODWORD(v6) = v5 + 0x80000000;
  HIDWORD(v6) = HIDWORD(v5) - !__CFADD__((_DWORD)v5, 0x80000000);
  *a1 = v6 + a2 + 2085978496 - ((unsigned int)v5 + 0x80000000);
  return a1;
}
// B7CE8: invalid function type '?' has been ignored
// B7CE8: using guessed type time_t (*off_B7CE8)(time_t *timer);

//----- (000658E8) --------------------------------------------------------
_QWORD *__fastcall sub_658E8(_QWORD *a1, int a2, time_t *timer)
{
  __int64 v5; // r0

  if ( timer )
    v5 = *timer;
  else
    v5 = off_B7CE8(0);
  *a1 = v5 + 61505152 + (unsigned int)(a2 - (v5 + 61505152));
  return a1;
}
// B7CE8: using guessed type time_t (*off_B7CE8)(time_t *timer);

//----- (0006598C) --------------------------------------------------------
int *__fastcall sub_6598C(int *a1, int *a2)
{
  unsigned __int64 v2; // r6
  unsigned __int64 v5; // r2
  int v6; // r0
  int v7; // r12
  int v8; // r3

  v2 = *(_QWORD *)a2;
  LODWORD(v5) = &off_15180;
  HIDWORD(v5) = 0;
  if ( a2[1] < 0 )
    v6 = ~sub_8BFD0(~v2, v5);
  else
    v6 = sub_8BFD0(v2, v5);
  v7 = *a2;
  *a1 = v6;
  v8 = v7 - (_DWORD)&off_15180 * v6;
  a1[1] = v8;
  return a1;
}
// 15180: using guessed type char *off_15180;

//----- (00065A30) --------------------------------------------------------
unsigned int *__fastcall sub_65A30(unsigned int *a1, int a2, _BOOL4 *a3)
{
  int v3; // r8
  unsigned int v4; // r4
  int v7; // r4
  unsigned int v8; // r8
  unsigned int v9; // r4
  unsigned int v10; // r3
  unsigned int v11; // r2
  unsigned int v12; // r4
  _BOOL4 v13; // r3

  v3 = a2 >> 31;
  v4 = a2;
  if ( (a2 ^ (unsigned int)(a2 >> 31)) > 0x3FFFFFFF )
  {
    v4 = ~(v3 ^ 0xC0000000);
    *_errno_location() = 33;
  }
  v7 = (4 * v4) | 3;
  v8 = v3 ^ ((v7 ^ (unsigned int)v3) / 0x23AB1);
  v9 = (v7 - ((_DWORD)&off_23AB0 + 1) * v8) | 3;
  v10 = v9 / 0x5B5;
  v11 = v9 / 0x5B5 + 100 * v8;
  v12 = (v9 % 0x5B5) >> 2;
  if ( a3 )
  {
    if ( ((v10 + 1) & 3) != 0 )
      v13 = 0;
    else
      v13 = v10 != 99 || ((v8 + 1) & 3) == 0;
    *a3 = v13;
  }
  *a1 = v11;
  a1[1] = v12;
  return a1;
}
// 23AB0: using guessed type char *off_23AB0;

//----- (00065B3C) --------------------------------------------------------
int *__fastcall sub_65B3C(int *a1, int a2, int a3)
{
  int v4; // r0
  char *v5; // r2
  int v6; // r3
  int v7; // r0
  int v8; // r1

  if ( a2 < 0
    || (!a3 ? (v4 = 0) : (v4 = 26),
        v5 = (char *)&unk_9B2D4 + v4,
        *(unsigned __int16 *)((char *)&unk_9B2D4 + v4 + 24) <= a2) )
  {
    v8 = -1;
    v6 = -1;
  }
  else
  {
    v6 = a2 >> 5;
    v7 = 2 * ((a2 >> 5) + 1);
    if ( *(unsigned __int16 *)&v5[v7] <= a2 )
      v6 = (a2 >> 5) + 1;
    else
      v7 -= 2;
    v8 = a2 - *(unsigned __int16 *)&v5[v7];
  }
  *a1 = v6;
  a1[1] = v8;
  return a1;
}

//----- (00065BF4) --------------------------------------------------------
int __fastcall sub_65BF4(int a1, int a2)
{
  unsigned int v3; // r3
  int v4; // r1
  int v5; // r1
  int v6; // r2
  int v7; // r6
  __int16 v8; // r3
  char v9; // r3
  int result; // r0
  int v11; // [sp+0h] [bp-14h] BYREF
  int v12; // [sp+4h] [bp-10h] BYREF
  int v13; // [sp+8h] [bp-Ch]

  v3 = (unsigned __int8)(a2 % 7);
  v4 = a2 - 1;
  if ( v3 > 6 )
    LOBYTE(v3) = v3 + 7;
  *(_BYTE *)(a1 + 9) = v3;
  sub_65A30((unsigned int *)&v12, v4, (_BOOL4 *)&v11);
  v5 = v13;
  v6 = v11;
  if ( (unsigned int)(v12 + 1) >> 16 )
    v7 = 0;
  else
    v7 = -1;
  v8 = (v12 + 1) & v7;
  *(_WORD *)(a1 + 2) = v13 + 1;
  *(_WORD *)a1 = v8;
  sub_65B3C(&v12, v5, v6);
  v9 = v12;
  if ( v7 )
    result = v11;
  else
    result = -1;
  *(_BYTE *)(a1 + 5) = v13 + 1;
  *(_BYTE *)(a1 + 4) = v9 + 1;
  return result;
}

//----- (00065CD8) --------------------------------------------------------
bool __fastcall sub_65CD8(_DWORD *a1, int a2)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  _BOOL4 result; // r0
  int v7; // r3
  int v8; // [sp+0h] [bp-14h] BYREF
  int v9; // [sp+4h] [bp-10h] BYREF
  int v10; // [sp+8h] [bp-Ch]

  a1[6] = a2 % 7 + (a2 % 7 < 0 ? 7 : 0);
  sub_65A30((unsigned int *)&v9, a2 - 1, (_BOOL4 *)&v8);
  v3 = v10;
  v4 = v8;
  v5 = v9 - 1899;
  a1[7] = v10;
  a1[5] = v5;
  sub_65B3C(&v9, v3, v4);
  result = v8;
  v7 = v10 + 1;
  a1[4] = v9;
  a1[3] = v7;
  return result;
}

//----- (00065D94) --------------------------------------------------------
unsigned int __fastcall sub_65D94(_BYTE *a1, int a2)
{
  unsigned int v2; // lr
  unsigned int v3; // r2
  unsigned int v5; // r3

  v2 = (a2 >> 31) ^ a2;
  v3 = (a2 >> 31) ^ (v2 / 0xE10);
  v5 = (a2 >> 31) ^ (v2 / 0x3C);
  a1[6] = v3 - 24 * ((a2 >> 31) ^ ((3257812231u * (unsigned __int64)v2) >> 48));
  a1[7] = v5 - 60 * v3;
  a1[8] = a2 - 60 * v5;
  return (a2 >> 31) ^ (v2 / 0x15180);
}

//----- (00065E40) --------------------------------------------------------
unsigned int __fastcall sub_65E40(_DWORD *a1, int a2)
{
  unsigned int v2; // lr
  unsigned int v4; // r2
  unsigned int result; // r0
  unsigned int v6; // r3

  v2 = (a2 >> 31) ^ a2;
  v4 = (a2 >> 31) ^ (v2 / 0xE10);
  result = (a2 >> 31) ^ (v2 / 0x15180);
  v6 = (a2 >> 31) ^ (v2 / 0x3C);
  a1[2] = v4 - 24 * result;
  *a1 = a2 - 60 * v6;
  a1[1] = v6 - 60 * v4;
  return result;
}

//----- (00065EE8) --------------------------------------------------------
int __fastcall sub_65EE8(_BYTE *a1, _DWORD *a2, int a3)
{
  int v5; // r7

  v5 = sub_65D94(a1, a2[1]) + a3;
  return sub_65BF4((int)a1, v5 + *a2);
}

//----- (00065F54) --------------------------------------------------------
bool __fastcall sub_65F54(_DWORD *a1, _DWORD *a2, int a3)
{
  int v5; // r7

  v5 = sub_65E40(a1, a2[1]) + a3;
  return sub_65CD8(a1, v5 + *a2);
}

//----- (00065FC0) --------------------------------------------------------
int __fastcall sub_65FC0(_BYTE *a1, int *a2)
{
  int v3; // r6
  unsigned int v4; // r0
  int v6[2]; // [sp+4h] [bp-Ch] BYREF

  sub_6598C(v6, a2);
  v3 = v6[0];
  v4 = sub_65D94(a1, v6[1]);
  return sub_65BF4((int)a1, v4 + v3 + 719163);
}

//----- (00066038) --------------------------------------------------------
_QWORD *__fastcall sub_66038(_QWORD *result, int a2, int a3)
{
  *result = (int)&off_15180 * (__int64)a2 + a3;
  return result;
}
// 15180: using guessed type char *off_15180;

//----- (00066090) --------------------------------------------------------
unsigned int __fastcall sub_66090(int a1)
{
  return ((a1 ^ (unsigned int)(a1 >> 31)) / 0x190
        + ((a1 ^ (unsigned int)(a1 >> 31)) >> 2)
        - (a1 ^ (unsigned int)(a1 >> 31)) / 0x64)
       ^ (a1 >> 31);
}

//----- (000660F4) --------------------------------------------------------
unsigned int __fastcall sub_660F4(int a1)
{
  return sub_66090(a1) + 365 * a1;
}

//----- (00066148) --------------------------------------------------------
_DWORD *__fastcall sub_66148(_DWORD *result, int a2)
{
  int v2; // r3
  int v3; // r4
  unsigned int v4; // r2

  v2 = a2 + 10;
  if ( a2 + 10 > 11 )
    v2 = a2 - 2;
  v3 = a2 + 10 > 11;
  if ( (unsigned int)v2 > 0xB )
  {
    v4 = (v2 >> 31) ^ ((v2 ^ (unsigned int)(v2 >> 31)) / 0xC);
    v3 += v4;
    v2 -= 12 * v4;
  }
  *result = v3;
  result[1] = *(unsigned __int16 *)&a101531Apr16202[2 * v2 + 116] - 306;
  return result;
}

//----- (000661F8) --------------------------------------------------------
int __fastcall sub_661F8(int a1, int a2, int a3)
{
  unsigned int v4; // r0
  unsigned int v7; // r0
  _DWORD v8[2]; // [sp+4h] [bp-Ch] BYREF

  if ( a2 )
  {
    sub_66148(v8, a2);
    v7 = sub_660F4(a1 + v8[0]);
    v4 = v7 + v8[1];
  }
  else
  {
    v4 = sub_660F4(a1);
  }
  return v4 + a3;
}

//----- (00066274) --------------------------------------------------------
int __fastcall sub_66274(int a1, unsigned int a2, int a3)
{
  int v5; // r0
  int v7; // r3
  int v9; // r1
  int v10; // r7
  int v11; // r7
  _DWORD v12[2]; // [sp+4h] [bp-10h] BYREF

  if ( a2 > 0xB )
  {
    sub_66148(v12, a2);
    v10 = v12[1];
    v11 = v10 + sub_660F4(a1 + v12[0]);
    return v11 - sub_660F4(a1) + a3;
  }
  else
  {
    v5 = a1 + 1;
    if ( ((a1 + 1) & 3) != 0 )
    {
      v7 = 0;
    }
    else
    {
      v9 = v5 >> 31;
      if ( v5 == 100 * (v5 / 100) )
      {
        v9 = v5 / 400;
        v7 = 400;
      }
      else
      {
        v7 = 1;
      }
      if ( v5 == 100 * (v5 / 100) )
        v7 = v5 == v7 * v9;
    }
    return *(unsigned __int16 *)&a101531Apr16202[26 * v7 + 64 + 2 * a2] + a3;
  }
}

//----- (0006636C) --------------------------------------------------------
int __fastcall sub_6636C(int a1, int a2, int a3)
{
  return a3 + 60 * (a2 + 60 * a1);
}

//----- (000663C0) --------------------------------------------------------
int __fastcall sub_663C0(_DWORD *a1)
{
  return sub_661F8(a1[5] + 1899, a1[4], a1[3] - 1) + 1;
}

//----- (00066428) --------------------------------------------------------
int __fastcall sub_66428(unsigned __int16 *a1)
{
  return sub_661F8(*a1 - 1, *((unsigned __int8 *)a1 + 4) - 1, *((unsigned __int8 *)a1 + 5) - 1) + 1;
}

//----- (0006648C) --------------------------------------------------------
unsigned int __fastcall sub_6648C(int a1)
{
  return sub_660F4(a1 - 1) + 1;
}

//----- (000664DC) --------------------------------------------------------
int __fastcall sub_664DC(int a1)
{
  unsigned int v3[2]; // [sp+4h] [bp-10h] BYREF

  sub_65A30(v3, a1 - 1, 0);
  return a1 - v3[1];
}

//----- (0006653C) --------------------------------------------------------
int __fastcall sub_6653C(int a1)
{
  int v3; // [sp+0h] [bp-10h] BYREF
  int v4; // [sp+4h] [bp-Ch] BYREF
  int v5; // [sp+8h] [bp-8h]

  sub_65A30((unsigned int *)&v4, a1 - 1, (_BOOL4 *)&v3);
  sub_65B3C(&v4, v5, v3);
  return a1 - v5;
}

//----- (000665B0) --------------------------------------------------------
int __fastcall sub_665B0(unsigned __int8 *a1)
{
  return sub_6636C(a1[6], a1[7], a1[8]);
}

//----- (00066604) --------------------------------------------------------
int __fastcall sub_66604(int *a1)
{
  return sub_6636C(a1[2], a1[1], *a1);
}

//----- (00066658) --------------------------------------------------------
int __fastcall sub_66658(unsigned __int16 *a1)
{
  int v2; // r5
  int v3; // r0
  __int64 v5; // [sp+0h] [bp-18h] BYREF
  __int64 v6; // [sp+8h] [bp-10h] BYREF

  v2 = sub_66428(a1);
  v3 = sub_665B0((unsigned __int8 *)a1);
  sub_66038(&v5, v2 - 719163, v3);
  v6 = v5;
  return sub_65644((int)&v6);
}

//----- (000666D8) --------------------------------------------------------
int __fastcall sub_666D8(_BYTE *a1, int *a2)
{
  int v3; // r6
  unsigned int v4; // r0
  int v6[2]; // [sp+4h] [bp-Ch] BYREF

  sub_6598C(v6, a2);
  v3 = v6[0];
  v4 = sub_65D94(a1, v6[1]);
  return sub_65BF4((int)a1, v4 + v3 + 693596);
}

//----- (00066750) --------------------------------------------------------
int __fastcall sub_66750(_BYTE *a1, int a2, time_t *a3)
{
  __int64 v5; // [sp+0h] [bp-1Ch] BYREF
  int v6[3]; // [sp+8h] [bp-14h] BYREF

  sub_658E8(&v5, a2, a3);
  *(_QWORD *)v6 = v5;
  return sub_666D8(a1, v6);
}

//----- (000667B4) --------------------------------------------------------
_QWORD *__fastcall sub_667B4(_QWORD *a1, unsigned __int16 *a2)
{
  int v4; // r7
  int v5; // r0

  v4 = sub_66428(a2);
  v5 = sub_665B0((unsigned __int8 *)a2);
  sub_66038(a1, v4 - 693596, v5);
  return a1;
}

//----- (00066830) --------------------------------------------------------
int __fastcall sub_66830(unsigned __int16 *a1)
{
  __int64 v2; // [sp+0h] [bp-10h] BYREF

  sub_667B4(&v2, a1);
  return v2;
}

//----- (00066884) --------------------------------------------------------
int __fastcall sub_66884(int a1, int a2)
{
  return sub_657A8(a1 + 1, a2, 7);
}

//----- (000668D4) --------------------------------------------------------
int __fastcall sub_668D4(int a1, int a2)
{
  return sub_657A8(a1, a2, 7);
}

//----- (00066920) --------------------------------------------------------
int __fastcall sub_66920(int a1, int a2)
{
  return sub_657A8(a1 - 3, a2, 7);
}

//----- (00066970) --------------------------------------------------------
int __fastcall sub_66970(int a1, int a2)
{
  return sub_657A8(a1, a2, -7);
}

//----- (000669BC) --------------------------------------------------------
int __fastcall sub_669BC(int a1, int a2)
{
  return sub_657A8(a1 - 1, a2, -7);
}

//----- (00066A0C) --------------------------------------------------------
unsigned int __fastcall sub_66A0C(int a1)
{
  unsigned int v1; // r3

  v1 = (a1 >> 31) ^ ((a1 ^ (unsigned int)(a1 >> 31)) / 0x64);
  return ((a1 >> 31) ^ (((3 * v1 + 1) ^ (a1 >> 31)) >> 2))
       + 5217 * v1
       + ((*(unsigned __int16 *)&a101531Apr16202[2 * ((3 * v1 + 1) & 3) + 144] + 53431 * (a1 - 100 * v1)) >> 10);
}

//----- (00066AAC) --------------------------------------------------------
_DWORD *__fastcall sub_66AAC(_DWORD *a1, int a2)
{
  int v2; // r5
  unsigned int v3; // r4
  int v5; // r4
  unsigned int v6; // r5
  unsigned int v7; // r4

  v2 = a2 >> 31;
  v3 = a2;
  if ( (a2 ^ (unsigned int)(a2 >> 31)) > 0x3FFFFFFF )
  {
    v3 = ~(v2 ^ 0xC0000000);
    *_errno_location() = 33;
  }
  v5 = 4 * v3 + 2;
  v6 = v2 ^ ((v5 ^ (unsigned int)v2) / 0x5187);
  v7 = *(unsigned __int16 *)&a101531Apr16202[2 * (v6 & 3) + 152] + 157 * ((v5 - 20871 * v6) >> 2);
  *a1 = (v7 >> 13) + 100 * v6;
  a1[1] = (v7 & 0x1FFF) / 0x9D;
  return a1;
}

//----- (00066B90) --------------------------------------------------------
bool __fastcall sub_66B90(int a1, int *a2)
{
  char v3; // r1
  unsigned int v4; // r8
  unsigned int v5; // lr
  int v6; // r3
  unsigned int v7; // r12
  unsigned int v8; // r2
  unsigned int v9; // r1
  unsigned int v10; // r3
  int v12; // [sp+Ch] [bp+0h] BYREF
  int v13; // [sp+10h] [bp+4h]

  sub_6598C(&v12, a2);
  v3 = v13;
  v4 = (v13 >> 31) ^ v13;
  v5 = (v13 >> 31) ^ (v4 / 0x15180);
  v6 = v5 + v12 + 693595;
  v7 = (v13 >> 31) ^ (v4 / 0xE10);
  v8 = (v13 >> 31) ^ (v4 / 0x3C);
  *(_BYTE *)(a1 + 4) = v7 - 24 * v5;
  *(_BYTE *)(a1 + 5) = v8 - 60 * v7;
  *(_BYTE *)(a1 + 6) = v3 - 60 * v8;
  v9 = (v6 >> 31) ^ ((v6 ^ (unsigned int)(v6 >> 31)) / 7);
  *(_BYTE *)(a1 + 3) = v6 - 7 * v9 + 1;
  sub_66AAC(&v12, v9);
  v10 = v12;
  *(_BYTE *)(a1 + 2) = v13 + 1;
  *(_WORD *)a1 = v10 + 1;
  return v10 <= 0xFFFE;
}

//----- (00066CC4) --------------------------------------------------------
bool __fastcall sub_66CC4(int a1, int a2, time_t *a3)
{
  __int64 v5; // [sp+0h] [bp-1Ch] BYREF
  int v6[3]; // [sp+8h] [bp-14h] BYREF

  sub_658E8(&v5, a2, a3);
  *(_QWORD *)v6 = v5;
  return sub_66B90(a1, v6);
}

//----- (00066D28) --------------------------------------------------------
_QWORD *__fastcall sub_66D28(_QWORD *a1, unsigned __int8 *a2)
{
  unsigned int v4; // r4
  int v5; // r0

  v4 = 7 * (a2[2] + sub_66A0C(*(unsigned __int16 *)a2 - 1) - 1) + a2[3];
  v5 = sub_6636C(a2[4], a2[5], a2[6]);
  sub_66038(a1, v4 - 693596, v5);
  return a1;
}

//----- (00066DC4) --------------------------------------------------------
int __fastcall sub_66DC4(unsigned __int8 *a1)
{
  __int64 v2; // [sp+0h] [bp-10h] BYREF

  sub_66D28(&v2, a1);
  return v2;
}

//----- (00066E18) --------------------------------------------------------
int sub_66E18()
{
  int v0; // r3
  unsigned __int16 v2[2]; // [sp+0h] [bp-14h] BYREF
  char v3; // [sp+5h] [bp-Fh]

  if ( !sub_6568C((int)v2) )
    return 25567;
  --v3;
  v0 = sub_66428(v2) - 693596;
  if ( v0 < 25567 )
    return 25567;
  return v0;
}

//----- (00066EA4) --------------------------------------------------------
int __fastcall sub_66EA4(const char *a1)
{
  size_t v2; // r7
  int v3; // r3
  int v5; // r1
  unsigned __int16 v6; // [sp+Eh] [bp-16h] BYREF
  unsigned __int16 v7; // [sp+10h] [bp-14h] BYREF
  unsigned __int16 v8; // [sp+12h] [bp-12h] BYREF
  int v9; // [sp+14h] [bp-10h] BYREF
  int v10; // [sp+18h] [bp-Ch] BYREF

  v2 = strlen(a1);
  if ( sscanf(a1, "%4hu-%2hu-%2hu%n", &v6, &v7, &v8, &v10) == 3 && v10 == v2 )
  {
    v5 = v7 - 1;
    if ( (unsigned __int16)v5 <= 0xBu && (unsigned int)v8 - 1 <= 0x1E )
      return sub_661F8(v6 - 1, v5, v8) - 693596;
    goto LABEL_4;
  }
  if ( sscanf(a1, "%lu%n", &v9, &v10) != 1 || v10 != v2 || (v3 = v9, v9 < 0) )
  {
LABEL_4:
    sub_64E00(4, "basedate string \"%s\" invalid, build date substituted!", a1);
    return sub_66E18();
  }
  return v3;
}

//----- (00066FD8) --------------------------------------------------------
int sub_66FD8()
{
  return dword_B7CE4;
}
// B7CE4: using guessed type int dword_B7CE4;

//----- (0006702C) --------------------------------------------------------
int __fastcall sub_6702C(int a1)
{
  int v1; // r2
  int v2; // r4
  int v3; // r7
  int v4; // r3
  unsigned __int16 v6; // [sp+8h] [bp-14h] BYREF
  unsigned __int8 v7; // [sp+Ch] [bp-10h]
  unsigned __int8 v8; // [sp+Dh] [bp-Fh]

  v1 = a1;
  if ( a1 <= 25566 )
  {
    v2 = 719163;
    sub_64E00(4, "baseday_set_day: invalid day (%lu), UNIX epoch substituted", a1);
    v1 = 25567;
  }
  else
  {
    v2 = a1 + 693596;
  }
  v3 = dword_B7CE4;
  dword_B7CE4 = v1;
  sub_65BF4((int)&v6, v2);
  sub_64E00(6, "basedate set to %04hu-%02hu-%02hu", v6, v7, v8);
  v4 = sub_668D4(v2, 0) - 693596;
  if ( v4 < 29223 )
    v4 = 29223;
  dword_1071FC = (v4 - 29223) / 7;
  sub_65BF4((int)&v6, v4 + 693596);
  sub_64E00(6, "gps base set to %04hu-%02hu-%02hu (week %d)", v6, v7, v8, dword_1071FC);
  return v3;
}
// B7CE4: using guessed type int dword_B7CE4;
// 1071FC: using guessed type int dword_1071FC;

//----- (00067190) --------------------------------------------------------
unsigned int sub_67190()
{
  return (_DWORD)&off_15180 * (dword_B7CE4 - 25567) + 0x80000000;
}
// 15180: using guessed type char *off_15180;
// B7CE4: using guessed type int dword_B7CE4;

//----- (000671FC) --------------------------------------------------------
int sub_671FC()
{
  return (_DWORD)&off_15180 * (dword_B7CE4 - 25567);
}
// 15180: using guessed type char *off_15180;
// B7CE4: using guessed type int dword_B7CE4;

//----- (00067264) --------------------------------------------------------
int sub_67264()
{
  return dword_1071FC;
}
// 1071FC: using guessed type int dword_1071FC;

//----- (000672B8) --------------------------------------------------------
int __fastcall sub_672B8(__int16 a1)
{
  return ((a1 - (_WORD)dword_1071FC) & 0x3FF) + dword_1071FC;
}
// 1071FC: using guessed type int dword_1071FC;

//----- (00067318) --------------------------------------------------------
unsigned int sub_67318()
{
  unsigned int v0; // r4
  unsigned int v1; // r5
  void *v2; // r0

  v0 = 0;
  v1 = dnschild_contexts_alloc;
  v2 = (void *)dnschild_contexts;
  while ( v0 >= v1 )
  {
LABEL_5:
    v1 += 20;
    v2 = sub_63BA4(v2, 4 * v1, 4 * v1 - 80, 1);
    dnschild_contexts_alloc = v1;
    dnschild_contexts = (int)v2;
  }
  while ( *((_DWORD *)v2 + v0) )
  {
    if ( ++v0 >= v1 )
      goto LABEL_5;
  }
  *((_DWORD *)v2 + v0) = sub_63BA4(0, 8u, 0, 1);
  return v0;
}
// 10958C: using guessed type int dnschild_contexts;
// 109594: using guessed type int dnschild_contexts_alloc;

//----- (000673DC) --------------------------------------------------------
unsigned int sub_673DC()
{
  unsigned int result; // r0

  if ( worker_per_query )
    return sub_67318();
  result = dword_B7CEC;
  if ( dword_B7CEC == -1 )
  {
    result = sub_67318();
    dword_B7CEC = result;
  }
  return result;
}
// B7CEC: using guessed type int dword_B7CEC;
// 10959C: using guessed type int worker_per_query;

//----- (00067478) --------------------------------------------------------
_DWORD *__fastcall sub_67478(int a1, unsigned int a2)
{
  _DWORD *v4; // r4

  sub_6E2CC(1);
  if ( dnsworker_contexts_alloc <= a2 )
  {
    dnsworker_contexts = (int)sub_63BA4(
                                (void *)dnsworker_contexts,
                                4 * ((a2 + 5) & 0xFFFFFFFC),
                                4 * dnsworker_contexts_alloc,
                                1);
    dnsworker_contexts_alloc = (a2 + 5) & 0xFFFFFFFC;
    v4 = sub_63BA4(0, 0xCu, 0, 1);
    *(_DWORD *)(dnsworker_contexts + 4 * a2) = v4;
  }
  else
  {
    v4 = *(_DWORD **)(dnsworker_contexts + 4 * a2);
    if ( !v4 )
    {
      v4 = sub_63BA4(0, 0xCu, 0, 1);
      *(_DWORD *)(dnsworker_contexts + 4 * a2) = v4;
    }
  }
  sub_6E2CC(0);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = a1;
  return v4;
}
// 109588: using guessed type int dnsworker_contexts_alloc;
// 109590: using guessed type int dnsworker_contexts;

//----- (00067590) --------------------------------------------------------
bool __fastcall sub_67590(int ecode)
{
  int v2; // r4
  const char *v3; // r1
  const char *v4; // r3
  int v5; // r4

  switch ( ecode )
  {
    case -11:
      if ( debug <= 1 )
        goto LABEL_17;
      v2 = 1;
      v3 = gai_strerror(-11);
      v4 = byte_97F7C;
      goto LABEL_15;
    case -5:
    case -2:
      v5 = dword_107200;
      if ( debug <= 1 )
        return dword_107200 == 0;
      v3 = gai_strerror(ecode);
      if ( v5 )
      {
        v2 = 0;
        v4 = "not ";
      }
      else
      {
        v2 = 1;
        v4 = byte_97F7C;
      }
      goto LABEL_15;
    case -4:
      if ( debug <= 1 )
        goto LABEL_17;
      v2 = 1;
      v3 = gai_strerror(-4);
      v4 = byte_97F7C;
      goto LABEL_15;
    case -3:
      v2 = 1;
      dword_107200 = 1;
      if ( debug > 1 )
      {
        v3 = gai_strerror(-3);
        v4 = byte_97F7C;
        goto LABEL_15;
      }
LABEL_17:
      v2 = 1;
      break;
    default:
      if ( debug > 1 )
      {
        v2 = 0;
        v3 = gai_strerror(ecode);
        v4 = "not ";
LABEL_15:
        sub_64D28("intres: resolver returned: %s (%d), %sretrying\n", v3, ecode, v4);
      }
      else
      {
        v2 = 0;
      }
      break;
  }
  return v2;
}
// 107200: using guessed type int dword_107200;
// 108D74: using guessed type int debug;

//----- (0006774C) --------------------------------------------------------
void __fastcall sub_6774C(int a1, char *a2, int a3, _DWORD *a4)
{
  const char *v6; // r8
  int v7; // r0
  int v8; // r6
  int v9; // r11
  int v10; // r9
  _DWORD *v11; // r12
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // r1
  _DWORD *v15; // lr
  _DWORD *v16; // r3
  int v17; // r2
  bool v18; // zf
  int v19; // r2
  int v20; // r10
  int v21; // r3
  time_t v22; // r0
  int v23; // r2
  int v24; // r1
  int v25; // r12
  int v26; // r2
  int v27; // r3
  int v28; // r2
  time_t v29; // r0
  int v30; // r9
  const char *v31; // r0
  int v32; // r3
  time_t *v33; // r0
  int v34; // r3
  const char *v35; // r9
  const char *v36; // r0

  v6 = a2 + 72;
  v7 = a4[1];
  v8 = (int)&a2[*((_DWORD *)a2 + 16) + 72];
  v9 = *(_DWORD *)(dnschild_contexts + 4 * *((_DWORD *)a2 + 1));
  if ( !v7 )
  {
    if ( (int)a4[2] > 2 )
    {
      v29 = time(0);
      *(_DWORD *)(v9 + 4) = v29;
      if ( debug > 0 )
      {
        v30 = *((_DWORD *)a2 + 1);
        v31 = sub_78840(v29);
        sub_64D28("DNS success after retry, %u next_dns_timeslot reset (%s)\n", v30, v31);
      }
    }
    goto LABEL_3;
  }
  v20 = *((_DWORD *)a2 + 13) & 1;
  if ( v20 )
  {
    v21 = *((_DWORD *)a2 + 4);
    if ( v21 <= 0 )
    {
LABEL_3:
      v10 = a4[4];
      v11 = a4 + 5;
      if ( v10 - 1 >= 0 )
      {
        v12 = 0;
        v13 = (int)&a4[8 * v10 - 3];
        do
        {
          *(_DWORD *)(v13 + 28) = v12;
          v12 = v13;
          v13 -= 32;
        }
        while ( a4 - 3 != (_DWORD *)v13 );
      }
      v14 = &v11[8 * v10];
      v15 = &v14[7 * v10];
      if ( v10 <= 0 )
      {
        if ( v14 != v15 )
          sub_6ECC0("ntp_intres.c", 589, 1, "(char *)psau == canon_start");
        if ( !v10 )
          v11 = 0;
      }
      else
      {
        v16 = a4;
        do
        {
          v17 = v16[10];
          v16 += 8;
          v18 = v17 == 0;
          v19 = v16[3];
          if ( !v18 )
            v16[2] = v14;
          v14 += 7;
          if ( v19 )
            v16[3] = (char *)v15 + v19;
        }
        while ( &a4[8 * v10] != v16 );
      }
      (*((void (__fastcall **)(_DWORD, _DWORD, _DWORD, const char *, int, char *, _DWORD *))a2 + 14))(
        a4[1],
        a4[3],
        *((_DWORD *)a2 + 15),
        v6,
        v8,
        a2 + 20,
        v11);
      free(a2);
      return;
    }
    if ( v21 == 2 && (ntp_syslogmask & 1) != 0 )
      goto LABEL_36;
    v22 = time(0);
    v23 = *((_DWORD *)a2 + 4);
    v24 = 1024;
  }
  else
  {
    if ( !sub_67590(v7) )
      goto LABEL_3;
    v32 = *((_DWORD *)a2 + 4);
    if ( v32 <= 0 )
      goto LABEL_3;
    if ( v32 == 2 )
    {
      v33 = (time_t *)(ntp_syslogmask & 1);
      if ( (ntp_syslogmask & 1) != 0 )
      {
        v7 = a4[1];
LABEL_36:
        v34 = *((_DWORD *)a2 + 6);
        if ( v34 == 10 )
        {
          v35 = " (AAAA)";
        }
        else if ( v34 == 2 )
        {
          v35 = " (A)";
        }
        else
        {
          v35 = byte_97F7C;
        }
        if ( v7 == -11 )
        {
          *_errno_location() = a4[3];
          sub_64E00(6, "retrying DNS %s%s: EAI_SYSTEM %d: %m", v6, v35, a4[3]);
        }
        else
        {
          v36 = gai_strerror(v7);
          sub_64E00(6, "retrying DNS %s%s: %s (%d)", v6, v35, v36, a4[1]);
        }
        v22 = time(0);
        v23 = *((_DWORD *)a2 + 4);
        v25 = v22 + v23;
        if ( v22 + v23 < *(_DWORD *)(v9 + 4) )
          v25 = *(_DWORD *)(v9 + 4);
        if ( v20 )
          v24 = 1024;
        else
          v24 = 64;
        *(_DWORD *)(v9 + 4) = v25;
        goto LABEL_21;
      }
    }
    else
    {
      v33 = 0;
    }
    v22 = time(v33);
    v23 = *((_DWORD *)a2 + 4);
    v24 = 64;
  }
  v25 = v22 + v23;
  if ( v22 + v23 < *(_DWORD *)(v9 + 4) )
    v25 = *(_DWORD *)(v9 + 4);
  *(_DWORD *)(v9 + 4) = v25;
LABEL_21:
  v26 = 2 * v23;
  *((_DWORD *)a2 + 2) = v22;
  *((_DWORD *)a2 + 3) = v25;
  v27 = (v26 - 1) & v26;
  if ( !v27 )
    v27 = v26 - (v26 >> 2);
  v28 = *(_DWORD *)a2;
  if ( v27 >= v24 )
    v27 = v24;
  *((_DWORD *)a2 + 4) = v27;
  if ( sub_69188(1u, a2, v28, (size_t)sub_6774C, (size_t)a2) )
  {
    sub_64E00(3, "unable to retry hostname %s", v6);
    goto LABEL_3;
  }
}
// B7CD4: using guessed type int ntp_syslogmask;
// 108D74: using guessed type int debug;
// 10958C: using guessed type int dnschild_contexts;

//----- (00067B04) --------------------------------------------------------
time_t __fastcall sub_67B04(time_t result, time_t a2, int *a3)
{
  time_t v4; // r7
  const char *v6; // r4
  const char *v7; // r7
  const char *v8; // r3
  time_t v9; // r9
  const char *v10; // r10
  const char *v11; // r7
  const char *v12; // r0
  time_t v13; // r0
  const char *v14; // r1

  v4 = result;
  if ( a3[1] <= result )
  {
    result = time(0);
    v9 = result;
    if ( a2 > result )
    {
      if ( debug > 0 )
      {
        v10 = sub_78840(a2);
        v11 = sub_78840(v4);
        v12 = sub_78840(a3[1]);
        sub_64D28("sleep until %s scheduled at %s (>= %s)\n", v10, v11, v12);
      }
      result = sub_6E3C8(*a3, a2 - v9);
      if ( result == -1 )
      {
        v13 = time(0);
        a3[1] = v13;
        a3[2] = v13 + 60;
        dword_107204 = v13 + 60;
        result = _res_init();
        if ( debug > 0 )
        {
          v14 = sub_78840(a3[1]);
          return sub_64D28("sleep interrupted by daemon, ignoring sleeps scheduled before now (%s)\n", v14);
        }
      }
    }
  }
  else if ( debug > 0 )
  {
    v6 = sub_78840(a2);
    v7 = sub_78840(v4);
    v8 = sub_78840(a3[1]);
    return sub_64D28("ignoring sleep until %s scheduled at %s (before %s)\n", v6, v7, v8);
  }
  return result;
}
// 107204: using guessed type int dword_107204;
// 108D74: using guessed type int debug;

//----- (00067CA8) --------------------------------------------------------
time_t __fastcall sub_67CA8(int *a1)
{
  time_t result; // r0
  int v3; // r3
  bool v4; // cc
  time_t v5; // r4
  int v6; // r4

  result = time(0);
  v3 = dword_107204;
  v4 = result < dword_107204;
  *a1 = dword_107204;
  if ( !v4 )
  {
    v5 = result;
    if ( v3 )
      result = _res_init();
    v6 = v5 + 60;
    *a1 = v6;
    dword_107204 = v6;
  }
  return result;
}
// 107204: using guessed type int dword_107204;

//----- (00067D40) --------------------------------------------------------
void __fastcall sub_67D40(int a1, unsigned __int16 *a2, int a3, _DWORD *a4)
{
  int v6; // r0
  int v7; // r9
  _DWORD *v8; // r8
  time_t v9; // r0
  int v10; // r6
  time_t v11; // r0
  int v12; // r3
  int v13; // r1
  int v14; // r3
  int v15; // r2
  int v16; // r3
  bool v17; // cc
  int v18; // r6
  const char *v19; // r0
  const char *v20; // r0

  v6 = a4[1];
  v7 = *(_DWORD *)(dnschild_contexts + 4 * *((_DWORD *)a2 + 1));
  if ( !v6 )
  {
    v8 = a2 + 20;
    if ( (int)a4[3] <= 2 )
    {
LABEL_3:
      (*((void (__fastcall **)(int, _DWORD, _DWORD *))a2 + 8))(v6, a4[2], v8);
      free(a2);
      return;
    }
    v9 = time(0);
    *(_DWORD *)(v7 + 4) = v9;
    if ( debug > 0 )
    {
      v18 = *((_DWORD *)a2 + 1);
      v19 = sub_78840(v9);
      sub_64D28("DNS success after retry, %u next_dns_timeslot reset (%s)\n", v18, v19);
      v6 = a4[1];
      goto LABEL_3;
    }
LABEL_5:
    v6 = a4[1];
    goto LABEL_3;
  }
  v10 = sub_67590(v6);
  if ( *((int *)a2 + 4) <= 0 )
    goto LABEL_7;
  v11 = time(0);
  v12 = *((_DWORD *)a2 + 4);
  v13 = v11 + v12;
  v14 = 2 * v12;
  if ( v13 < *(_DWORD *)(v7 + 4) )
    v13 = *(_DWORD *)(v7 + 4);
  *(_DWORD *)(v7 + 4) = v13;
  v15 = (v14 - 1) & v14;
  *((_DWORD *)a2 + 2) = v11;
  if ( !v15 )
    v15 = v14 - (v14 >> 2);
  *((_DWORD *)a2 + 3) = v13;
  v16 = v15 >= 64 ? 64 : v15;
  v17 = v10 <= 0;
  if ( v10 )
    v17 = v15 <= 0;
  *((_DWORD *)a2 + 4) = v16;
  if ( v17 )
  {
LABEL_7:
    v8 = a2 + 20;
    v6 = a4[1];
    goto LABEL_3;
  }
  if ( sub_69188(0, a2, *(_DWORD *)a2, (size_t)sub_67D40, (size_t)a2) )
  {
    v8 = a2 + 20;
    v20 = sub_6C2E8(a2 + 20);
    sub_64E00(3, "unable to retry reverse lookup of %s", v20);
    goto LABEL_5;
  }
}
// 108D74: using guessed type int debug;
// 10958C: using guessed type int dnschild_contexts;

//----- (00067F40) --------------------------------------------------------
int __fastcall sub_67F40(const char *a1, const char *a2, int *a3, int a4, int a5, int a6, int a7)
{
  unsigned int v10; // r11
  size_t v11; // r8
  size_t v12; // r7
  int v13; // r6
  _DWORD *v14; // r4
  time_t v15; // r0
  _DWORD *v16; // r12
  time_t v17; // r3
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  _DWORD *v22; // r5
  _DWORD *v23; // r12
  int v24; // r1
  int v25; // r2
  int v26; // r3
  int v27; // r3
  int *v29; // r0
  size_t v31; // [sp+20h] [bp-14h]
  int v32; // [sp+24h] [bp-10h]

  if ( !a1 )
    sub_6ECC0("ntp_intres.c", 253, 0, "((void *)0) != node");
  if ( a3 )
  {
    if ( a3[4] )
      sub_6ECC0("ntp_intres.c", 255, 0, "0 == hints->ai_addrlen");
    if ( a3[5] )
      sub_6ECC0("ntp_intres.c", 256, 0, "((void *)0) == hints->ai_addr");
    if ( a3[6] )
      sub_6ECC0("ntp_intres.c", 257, a3[5], "((void *)0) == hints->ai_canonname");
    if ( a3[7] )
      sub_6ECC0("ntp_intres.c", 258, 0, "((void *)0) == hints->ai_next");
  }
  v10 = sub_673DC();
  v32 = *(_DWORD *)(dnschild_contexts + 4 * v10);
  v31 = strlen(a1);
  v11 = v31 + 1;
  v12 = strlen(a2) + 1;
  v13 = v31 + 1 + v12 + 72;
  v14 = sub_63BA4(0, v13, 0, 1);
  *v14 = v13;
  v14[1] = v10;
  v15 = time(0);
  v17 = *(_DWORD *)(v32 + 4);
  v14[2] = v15;
  if ( v15 < v17 )
    v15 = v17;
  v14[3] = v15;
  if ( a3 )
    v16 = v14 + 5;
  *(_DWORD *)(v32 + 4) = v15;
  if ( a3 )
  {
    v18 = *a3;
    v19 = a3[1];
    v20 = a3[2];
    v21 = a3[3];
    v22 = a3 + 4;
    *v16 = v18;
    v16[1] = v19;
    v16[2] = v20;
    v16[3] = v21;
    v23 = v16 + 4;
    v24 = v22[1];
    v25 = v22[2];
    v26 = v22[3];
    *v23 = *v22;
    v23[1] = v24;
    v23[2] = v25;
    v23[3] = v26;
  }
  v14[16] = v11;
  v14[4] = a4;
  v14[17] = v12;
  v14[14] = a5;
  v14[15] = a6;
  v14[13] = a7;
  memcpy(v14 + 18, a1, v11);
  memcpy((char *)v14 + v31 + 73, a2, v12);
  v27 = sub_69188(1u, v14, v13, (size_t)sub_6774C, (size_t)v14);
  if ( v27 )
  {
    sub_64E00(3, "unable to queue getaddrinfo request");
    v29 = _errno_location();
    v27 = -1;
    *v29 = 14;
  }
  return v27;
}
// 68058: variable 'v16' is possibly undefined
// 10958C: using guessed type int dnschild_contexts;

//----- (000681E0) --------------------------------------------------------
int __fastcall sub_681E0(int a1, int a2)
{
  const char *v3; // r7
  const char *v5; // r6
  int *v6; // r8
  _DWORD *v7; // r5
  int v8; // r9
  int v9; // r0
  int v10; // r6
  struct addrinfo *v11; // r7
  int v12; // r10
  const char *ai_canonname; // r0
  int v14; // r9
  int v15; // r1
  size_t v16; // r9
  _DWORD *v17; // r0
  int v18; // r8
  int v19; // r7
  struct addrinfo *v20; // r5
  _DWORD *v21; // r6
  int ai_family; // r1
  int ai_socktype; // r2
  int ai_protocol; // r3
  struct addrinfo *ai_next; // r3
  struct sockaddr *ai_addr; // r1
  char *v27; // r2
  size_t ai_addrlen; // r2
  char *v29; // r8
  size_t v30; // r2
  void *v31; // r0
  int result; // r0
  time_t v33; // r0
  const char *v34; // r0
  struct addrinfo *ai; // [sp+10h] [bp-Ch] BYREF

  v3 = (const char *)(a2 + 96);
  v5 = (const char *)(a2 + 96 + *(_DWORD *)(a2 + 88));
  v6 = sub_67478(a1, *(_DWORD *)(a2 + 28));
  sub_67B04(*(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36), v6);
  sub_67CA8(v6 + 2);
  v7 = sub_63BA4(0, 0x4ECu, 0, 1);
  if ( debug > 1 )
    sub_64D28(
      "blocking_getaddrinfo given node %s serv %s fam %d flags %x\n",
      v3,
      v5,
      *(_DWORD *)(a2 + 48),
      *(_DWORD *)(a2 + 44));
  v8 = 0;
  ai = 0;
  v9 = getaddrinfo(v3, v5, (const struct addrinfo *)(a2 + 44), &ai);
  v10 = *(_DWORD *)(a2 + 40);
  v7[7] = v9;
  v7[8] = v10;
  if ( v9 == -11 )
  {
    v7[9] = *_errno_location();
  }
  else if ( !v9 )
  {
    v11 = ai;
    if ( ai )
    {
      v8 = 0;
      v12 = v7[10] + 1;
      do
      {
        ai_canonname = v11->ai_canonname;
        v7[10] = v12;
        if ( ai_canonname )
          v8 += strlen(ai_canonname) + 1;
        v11 = v11->ai_next;
        ++v12;
      }
      while ( v11 );
    }
    else
    {
      v8 = 0;
    }
    if ( v10 > 2 )
    {
      v33 = time(0);
      v6[1] = v33;
      if ( debug > 0 )
      {
        v34 = sub_78840(v33);
        sub_64D28("DNS success after retry, ignoring sleeps scheduled before now (%s)\n", v34);
      }
    }
  }
  v14 = v8 + 60 * v7[10];
  v15 = v14 + 20;
  v16 = v14 + 44;
  v7[6] = v15;
  v17 = sub_63BA4(v7, v16, 0, 0);
  v18 = v17[7];
  v19 = (int)v17;
  if ( !v18 )
  {
    v20 = ai;
    v21 = v17 + 11;
    if ( ai )
    {
      do
      {
        v21 += 8;
        ai_family = v20->ai_family;
        ai_socktype = v20->ai_socktype;
        ai_protocol = v20->ai_protocol;
        *(v21 - 8) = v20->ai_flags;
        *(v21 - 7) = ai_family;
        *(v21 - 6) = ai_socktype;
        *(v21 - 5) = ai_protocol;
        ai_next = v20->ai_next;
        ai_addr = v20->ai_addr;
        v27 = v20->ai_canonname;
        *(v21 - 4) = v20->ai_addrlen;
        *(v21 - 3) = ai_addr;
        *(v21 - 2) = v27;
        *(v21 - 1) = ai_next;
        if ( v20->ai_canonname )
        {
          *(v21 - 2) = v18;
          v18 += strlen(v20->ai_canonname) + 1;
        }
        v20 = v20->ai_next;
      }
      while ( v20 );
      v20 = ai;
      if ( ai )
      {
        do
        {
          ai_addrlen = v20->ai_addrlen;
          if ( ai_addrlen > 0x1C )
            sub_6ECC0("ntp_intres.c", 425, 2, "ai->ai_addrlen <= sizeof(sockaddr_u)");
          memcpy(v21, v20->ai_addr, ai_addrlen);
          v20 = v20->ai_next;
          v21 += 7;
        }
        while ( v20 );
        v20 = ai;
        if ( ai )
        {
          do
          {
            v29 = v20->ai_canonname;
            if ( v29 )
            {
              v30 = strlen(v20->ai_canonname) + 1;
              v31 = v21;
              v21 = (_DWORD *)((char *)v21 + v30);
              memcpy(v31, v29, v30);
            }
            v20 = v20->ai_next;
          }
          while ( v20 );
          v20 = ai;
        }
      }
    }
    freeaddrinfo(v20);
  }
  result = sub_69350(a1, v19, v16, (_DWORD *)a2);
  if ( result )
  {
    sub_64E00(3, "blocking_getaddrinfo can not queue response");
    return -1;
  }
  return result;
}
// 108D74: using guessed type int debug;

//----- (00068520) --------------------------------------------------------
int __fastcall sub_68520(const char *a1, const char *a2, int *a3, int a4, int a5, int a6)
{
  return sub_67F40(a1, a2, a3, a4, a5, a6, 0);
}

//----- (00068738) --------------------------------------------------------
int __fastcall sub_68738(int a1, int a2)
{
  int v2; // r6
  unsigned int v3; // r5
  int *v6; // r9
  char *serv; // r6
  _DWORD *v8; // r5
  const char *v9; // r0
  socklen_t v10; // r1
  int v11; // r0
  int v12; // r3
  time_t *v13; // r10
  size_t v14; // r0
  size_t v15; // r0
  int v16; // r9
  int v17; // r7
  char *v18; // r0
  int v19; // r3
  char *v20; // r5
  char *v21; // r0
  int v22; // r4
  size_t v24; // r2
  char *v25; // r8
  time_t v26; // r0
  int v27; // r3
  const char *v28; // r0
  int v29; // r7
  int v30; // [sp+18h] [bp-414h]
  size_t v31; // [sp+1Ch] [bp-410h]
  char v32[1024]; // [sp+24h] [bp-408h] BYREF

  v2 = *(_DWORD *)(a2 + 44);
  v3 = v2 + *(_DWORD *)(a2 + 48);
  if ( v3 >= 0x400 )
    sub_6ECC0("ntp_intres.c", 720, 0, "octets < sizeof(host)");
  v6 = sub_67478(a1, *(_DWORD *)(a2 + 28));
  serv = &v32[v2];
  sub_67B04(*(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36), v6);
  sub_67CA8(v6 + 2);
  v8 = sub_63BA4(0, v3 + 48, 0, 1);
  if ( debug > 1 )
  {
    v9 = sub_6C2E8((unsigned __int16 *)(a2 + 64));
    sub_64D28(
      "blocking_getnameinfo given addr %s flags 0x%x hostlen %lu servlen %lu\n",
      v9,
      *(_DWORD *)(a2 + 52),
      *(_DWORD *)(a2 + 44),
      *(_DWORD *)(a2 + 48));
  }
  if ( *(_WORD *)(a2 + 64) == 2 )
    v10 = 16;
  else
    v10 = 28;
  v11 = getnameinfo(
          (const struct sockaddr *)(a2 + 64),
          v10,
          v32,
          *(_DWORD *)(a2 + 44),
          serv,
          *(_DWORD *)(a2 + 48),
          *(_DWORD *)(a2 + 52));
  v12 = *(_DWORD *)(a2 + 40);
  v13 = (time_t *)v11;
  v8[7] = v11;
  v8[9] = v12;
  if ( v11 == -11 )
  {
    v8[8] = *_errno_location();
    goto LABEL_17;
  }
  if ( v11 )
  {
LABEL_17:
    v17 = 48;
    v8[10] = 0;
    v16 = 24;
    v8[11] = 0;
    goto LABEL_11;
  }
  v30 = v12;
  v14 = strlen(v32);
  v8[10] = v14 + 1;
  v31 = v14 + 1;
  v15 = strlen(serv) + 1;
  v8[11] = v15;
  if ( v30 > 2 )
  {
    v26 = time(v13);
    v27 = debug;
    v6[1] = v26;
    if ( v27 > 0 )
    {
      v28 = sub_78840(v26);
      sub_64D28("DNS success after retrying, ignoring sleeps scheduled before now (%s)\n", v28);
    }
    v29 = v8[11] + v8[10];
    v16 = v29 + 24;
    v17 = v29 + 48;
  }
  else
  {
    v16 = v31 + v15 + 24;
    v17 = v31 + v15 + 48;
  }
LABEL_11:
  v18 = (char *)sub_63BA4(v8, v17, 0, 0);
  v19 = *((_DWORD *)v18 + 7);
  v20 = v18;
  *((_DWORD *)v18 + 6) = v16;
  v21 = v18 + 48;
  if ( v19 )
  {
    if ( v17 == 48 )
      goto LABEL_13;
LABEL_24:
    sub_6ECC0("ntp_intres.c", 796, 2, "(size_t)(cp - (char *)resp) == resp_octets");
  }
  v24 = *((_DWORD *)v20 + 10);
  v25 = &v21[v24];
  memcpy(v21, v32, v24);
  memcpy(v25, serv, *((_DWORD *)v20 + 11));
  if ( &v25[*((_DWORD *)v20 + 11)] - v20 != v17 )
    goto LABEL_24;
  if ( *((_DWORD *)v20 + 6) != v16 )
    sub_6ECC0("ntp_intres.c", 797, 2, "resp_octets - sizeof(*resp) == gni_resp->octets");
LABEL_13:
  v22 = sub_69350(a1, (int)v20, v17, (_DWORD *)a2);
  if ( v22 )
    sub_64E00(3, "blocking_getnameinfo unable to queue response");
  return v22;
}
// 108D74: using guessed type int debug;

//----- (00068A44) --------------------------------------------------------
unsigned int __fastcall sub_68A44(unsigned int a1, int a2, char **a3)
{
  return sub_8909C(a1, a2, a3);
}

//----- (00068A8C) --------------------------------------------------------
void __noreturn sub_68A8C()
{
  puts(Version);
  fflush(stdout);
  exit(0);
}
// B6ADC: using guessed type char *Version;

//----- (00068AE4) --------------------------------------------------------
unsigned int sub_68AE4()
{
  char *v0; // r3
  int *v1; // r12
  unsigned int v2; // r0
  int *v3; // r3
  unsigned int result; // r0

  v0 = (char *)off_B7D70;
  v1 = off_B7D74 + 1;
  v2 = *(_DWORD *)off_B7D70 + *off_B7D74;
  *(_DWORD *)off_B7D70 = v2;
  v3 = (int *)(v0 + 4);
  result = v2 >> 1;
  if ( v3 < (int *)&off_B7D70 )
  {
    if ( v1 >= (int *)&off_B7D70 )
      v1 = &dword_B7CF4;
  }
  else
  {
    v3 = &dword_B7CF4;
  }
  off_B7D70 = v3;
  off_B7D74 = v1;
  return result;
}
// B7CF4: using guessed type int dword_B7CF4;
// B7D70: using guessed type _UNKNOWN *off_B7D70;
// B7D74: using guessed type int *;

//----- (00068B80) --------------------------------------------------------
void __fastcall sub_68B80(int a1)
{
  int *v1; // r2
  int v2; // r5
  unsigned int v3; // r0

  v1 = (int *)&unk_B7CF8;
  dword_B7CF4 = a1;
  while ( 1 )
  {
    a1 = -2836 * (a1 / 127773) + 16807 * (a1 - (_DWORD)&loc_1F31C * (a1 / 127773));
    if ( a1 <= 0 )
      a1 += 0x7FFFFFFF;
    *v1 = a1;
    if ( &unk_B7D6C == (_UNKNOWN *)v1 )
      break;
    ++v1;
  }
  v2 = 310;
  off_B7D70 = &unk_B7D00;
  off_B7D74 = &dword_B7CF4;
  do
  {
    v3 = sub_68AE4();
    --v2;
  }
  while ( v2 );
  srand(v3);
}
// B7CF4: using guessed type int dword_B7CF4;
// B7D70: using guessed type _UNKNOWN *off_B7D70;
// B7D74: using guessed type int *off_B7D74;

//----- (00068C64) --------------------------------------------------------
char *__fastcall sub_68C64(int a1, int a2)
{
  int v2; // r5
  int v3; // r4
  int v5; // r6
  int v6; // r7
  const char *v7; // r0
  char *v8; // r0
  char *v9; // r6
  char *v10; // r7
  char *v11; // r11
  char *v12; // r4
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r8
  char *v17; // r12
  int v18; // r1
  int v19; // r2
  int v20; // r3
  size_t v21; // r2
  int v22; // r3
  const char *v23; // r5
  size_t v24; // r2
  char *v25; // r0
  char *v26; // r3
  size_t v28; // [sp+4h] [bp-10h]

  v2 = a1;
  if ( !a1 )
    return (char *)sub_63BA4(0, 0, 0, 1);
  v3 = 0;
  v5 = a1;
  v6 = 0;
  while ( 1 )
  {
    ++v6;
    v7 = *(const char **)(v5 + 24);
    if ( a2 )
      break;
    v5 = *(_DWORD *)(v5 + 28);
    if ( v7 )
      v3 += strlen(v7) + 1;
    if ( !v5 )
      goto LABEL_6;
  }
  if ( v7 )
    v3 += 1 + strlen(v7);
LABEL_6:
  v28 = v3 + 60 * v6;
  v8 = (char *)sub_63BA4(0, v28, 0, 1);
  v9 = &v8[32 * v6];
  v10 = &v9[28 * v6];
  v11 = v8;
  v12 = v8 + 32;
  do
  {
    v13 = *(_DWORD *)(v2 + 4);
    v14 = *(_DWORD *)(v2 + 8);
    v15 = *(_DWORD *)(v2 + 12);
    if ( a2 )
      v16 = 0;
    else
      v16 = *(_DWORD *)(v2 + 28);
    *((_DWORD *)v12 - 8) = *(_DWORD *)v2;
    *((_DWORD *)v12 - 7) = v13;
    *((_DWORD *)v12 - 6) = v14;
    *((_DWORD *)v12 - 5) = v15;
    v17 = v12 - 16;
    v18 = *(_DWORD *)(v2 + 20);
    v19 = *(_DWORD *)(v2 + 24);
    v20 = *(_DWORD *)(v2 + 28);
    *(_DWORD *)v17 = *(_DWORD *)(v2 + 16);
    *((_DWORD *)v17 + 1) = v18;
    *((_DWORD *)v17 + 2) = v19;
    *((_DWORD *)v17 + 3) = v20;
    v21 = *(_DWORD *)(v2 + 16);
    if ( v21 > 0x1C )
      sub_6ECC0("ntp_rfc2553.c", 207, 2, "ai_src->ai_addrlen <= sizeof(sockaddr_u)");
    memcpy(v9, *(const void **)(v2 + 20), v21);
    v22 = *(_DWORD *)(v2 + 24);
    *((_DWORD *)v12 - 3) = v9;
    v9 += 28;
    if ( v22 )
    {
      *((_DWORD *)v12 - 2) = v10;
      v23 = *(const char **)(v2 + 24);
      v24 = strlen(v23) + 1;
      v25 = v10;
      v10 += v24;
      memcpy(v25, v23, v24);
    }
    if ( *((_DWORD *)v12 - 1) )
    {
      if ( a2 )
        v26 = 0;
      else
        v26 = v12;
      *((_DWORD *)v12 - 1) = v26;
    }
    v12 += 32;
    v2 = v16;
  }
  while ( v16 );
  if ( v10 != &v11[v28] )
    sub_6ECC0("ntp_rfc2553.c", 225, 1, "pcanon == ((char *)dst + octets)");
  return v11;
}

//----- (00068E70) --------------------------------------------------------
char *__fastcall sub_68E70(int a1)
{
  return sub_68C64(a1, 1);
}

//----- (00068EBC) --------------------------------------------------------
char *__fastcall sub_68EBC(int a1)
{
  return sub_68C64(a1, 0);
}

//----- (00068F08) --------------------------------------------------------
int __fastcall sub_68F08(_QWORD *a1, int *a2)
{
  int v4; // r1
  int result; // r0
  __int64 v6; // [sp+4h] [bp+0h] BYREF

  if ( socketpair(1, 1, 0, (int *)&v6) != -1 )
  {
    v4 = 0;
    goto LABEL_4;
  }
  result = pipe((int *)&v6);
  if ( result != -1 )
  {
    v4 = 1;
LABEL_4:
    result = 0;
    *a1 = v6;
    if ( a2 )
      *a2 = v4;
  }
  return result;
}

//----- (00068FAC) --------------------------------------------------------
int __fastcall sub_68FAC(int a1)
{
  int v1; // r4
  int result; // r0
  int v3; // r5
  int v4; // r0

  v1 = a1 + 1;
  result = sysconf(4);
  if ( result > v1 )
  {
    v3 = result;
    do
    {
      v4 = v1++;
      result = close(v4);
    }
    while ( v3 != v1 );
  }
  return result;
}

//----- (00069020) --------------------------------------------------------
int __fastcall sub_69020(int a1)
{
  int i; // r4
  int v3; // r0

  if ( a1 > 0 )
  {
    for ( i = 0; i != a1; ++i )
    {
      v3 = i;
      close(v3);
    }
  }
  return sub_68FAC(a1);
}

//----- (0006908C) --------------------------------------------------------
int sub_6908C()
{
  size_t v0; // r2
  int *v1; // r3
  int v2; // r1
  int v3; // r12
  int *v4; // t1
  int v5; // r5
  size_t v6; // r1
  void *v7; // r0
  int v9; // r4

  v0 = blocking_children_alloc;
  if ( !blocking_children_alloc )
  {
    v9 = 0;
    v6 = 16;
    v5 = 4;
LABEL_10:
    v7 = sub_63BA4((void *)blocking_children, v6, v0, 1);
    blocking_children_alloc = v5;
    blocking_children = (int)v7;
    return v9;
  }
  v1 = *(int **)blocking_children;
  if ( !*(_DWORD *)blocking_children )
    return 0;
  v2 = *v1;
  if ( !*v1 )
  {
    v3 = blocking_children;
    while ( 1 )
    {
      v9 = v2 + 1;
      if ( blocking_children_alloc == v2 + 1 )
        break;
      v4 = *(int **)(v3 + 4);
      v3 += 4;
      v1 = v4;
      if ( !v4 )
        return v9;
      ++v2;
      if ( *v1 )
        goto LABEL_12;
    }
    v0 = 4 * blocking_children_alloc;
    v5 = v2 + 5;
    v6 = 4 * blocking_children_alloc + 16;
    goto LABEL_10;
  }
  v9 = 0;
LABEL_12:
  *v1 = 0;
  return v9;
}
// 109598: using guessed type int blocking_children_alloc;
// 1095A8: using guessed type int blocking_children;

//----- (00069188) --------------------------------------------------------
int __fastcall sub_69188(size_t a1, const void *a2, int a3, size_t a4, size_t a5)
{
  int v6; // r2
  int v7; // r3
  size_t v8; // r5
  _DWORD *v9; // r0
  int v11; // r0
  int v12; // r2
  size_t v13[6]; // [sp+4h] [bp-1Ch] BYREF

  v13[0] = a3 + 24;
  v13[2] = a1;
  v13[4] = a4;
  v13[1] = 1359773391;
  v13[5] = a5;
  if ( !worker_per_query )
  {
    v6 = dword_B7D78;
    if ( dword_B7D78 != -1 && !**(_DWORD **)(blocking_children + 4 * dword_B7D78) )
    {
      v7 = intres_req_pending;
      goto LABEL_5;
    }
  }
  v11 = sub_6908C();
  v8 = v11;
  if ( !worker_per_query )
  {
    v6 = dword_B7D78;
    v7 = intres_req_pending;
    if ( dword_B7D78 == -1 )
    {
      dword_B7D78 = v11;
      if ( intres_req_pending )
        goto LABEL_17;
      v6 = v11;
      goto LABEL_15;
    }
LABEL_5:
    if ( v7 )
    {
      v8 = v6;
      intres_req_pending = v7 + 1;
      goto LABEL_8;
    }
LABEL_15:
    v8 = v6;
    sub_40DFC(0);
    v7 = intres_req_pending;
    goto LABEL_17;
  }
  v7 = intres_req_pending;
LABEL_17:
  intres_req_pending = v7 + 1;
  if ( v8 == -1 )
    sub_6ECC0("ntp_worker.c", 193, 2, "(0x7fffffff * 2U + 1U) != child_slot");
LABEL_8:
  v9 = *(_DWORD **)(blocking_children + 4 * v8);
  if ( !v9 )
  {
    v9 = sub_63BA4(0, 0x90u, 0, 1);
    v12 = blocking_children;
    v9[13] = -1;
    v9[14] = -1;
    *(_DWORD *)(v12 + 4 * v8) = v9;
  }
  v13[3] = v8;
  return sub_6E544((int)v9, v13, a2);
}
// B7D78: using guessed type int dword_B7D78;
// 10959C: using guessed type int worker_per_query;
// 1095A0: using guessed type int intres_req_pending;
// 1095A8: using guessed type int blocking_children;

//----- (00069350) --------------------------------------------------------
int __fastcall sub_69350(int a1, int a2, int a3, _DWORD *a4)
{
  __int64 v4; // r4
  int v5; // r3

  LODWORD(v4) = 1359773268;
  HIDWORD(v4) = a4[2];
  *(_QWORD *)(a2 + 4) = v4;
  *(_DWORD *)a2 = a3;
  HIDWORD(v4) = a4[5];
  v5 = a4[4];
  *(_DWORD *)(a2 + 20) = HIDWORD(v4);
  *(_DWORD *)(a2 + 16) = v5;
  return sub_6E6E8(a1, a2);
}

//----- (000693BC) --------------------------------------------------------
int __fastcall sub_693BC(int a1)
{
  int v2; // r3
  int v3; // r0
  void (__fastcall *v4)(int, int, int, int); // r5
  int v5; // r2
  int v6; // r1
  int result; // r0
  _DWORD *v8; // r4

  while ( 1 )
  {
    result = sub_6E948(a1);
    v8 = (_DWORD *)result;
    if ( !result )
      break;
    v2 = result + 24;
    v3 = *(_DWORD *)(result + 8);
    v4 = (void (__fastcall *)(int, int, int, int))v8[4];
    v5 = *v8 - 24;
    v6 = v8[5];
    --intres_req_pending;
    v4(v3, v6, v5, v2);
    free(v8);
  }
  if ( worker_per_query )
    return sub_6EAE8(a1);
  if ( !intres_req_pending )
    return sub_40DFC(180);
  return result;
}
// 10959C: using guessed type int worker_per_query;
// 1095A0: using guessed type int intres_req_pending;

//----- (000694B8) --------------------------------------------------------
int sub_694B8()
{
  int result; // r0
  unsigned int v1; // r4
  int v2; // r3

  result = blocking_child_ready_seen;
  if ( blocking_child_ready_seen != blocking_child_ready_done )
  {
    blocking_child_ready_done = blocking_child_ready_seen;
    if ( blocking_children_alloc )
    {
      v1 = 0;
      do
      {
        result = *(_DWORD *)(blocking_children + 4 * v1);
        if ( result )
        {
          v2 = *(_DWORD *)(result + 68);
          if ( v2 != *(_DWORD *)(result + 72) )
          {
            *(_DWORD *)(result + 72) = v2;
            result = sub_693BC(result);
          }
        }
        ++v1;
      }
      while ( blocking_children_alloc > v1 );
    }
  }
  return result;
}
// 109598: using guessed type int blocking_children_alloc;
// 1095A4: using guessed type int blocking_child_ready_seen;
// 1095A8: using guessed type int blocking_children;
// 1095AC: using guessed type int blocking_child_ready_done;

//----- (00069588) --------------------------------------------------------
int __fastcall sub_69588(int a1)
{
  int v2; // r0
  void *v3; // r4
  int v4; // r2

  while ( 1 )
  {
    v2 = sub_6E870(a1);
    v3 = (void *)v2;
    if ( !v2 )
      return 0;
    v4 = *(_DWORD *)(v2 + 8);
    if ( v4 )
    {
      if ( v4 != 1 )
      {
        sub_64E00(3, "unknown req %d to blocking worker", v4);
        free(v3);
        return 0;
      }
      if ( sub_681E0(a1, v2) )
        goto LABEL_5;
    }
    else if ( sub_68738(a1, v2) )
    {
LABEL_5:
      free(v3);
      return 0;
    }
    free(v3);
  }
}

//----- (00069654) --------------------------------------------------------
int sub_69654()
{
  int result; // r0
  unsigned int v1; // r4

  result = sub_40DFC(0);
  if ( blocking_children_alloc )
  {
    v1 = 0;
    do
    {
      result = *(_DWORD *)(blocking_children + 4 * v1);
      if ( result )
        result = sub_6EAE8(result);
      ++v1;
    }
    while ( blocking_children_alloc > v1 );
  }
  return result;
}
// 109598: using guessed type int blocking_children_alloc;
// 1095A8: using guessed type int blocking_children;

//----- (000696EC) --------------------------------------------------------
_BYTE *__fastcall sub_696EC(unsigned int a1)
{
  unsigned int v1; // r5
  _BYTE *v2; // r8
  int v3; // r4

  v1 = bswap32(a1);
  v2 = &lib_stringbuf[128 * lib_nextbuf];
  v3 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v2, 0, 0x80u);
  lib_nextbuf = v3;
  sub_6C054((int)v2, 0x80u, "%lu.%lu.%lu.%lu", HIBYTE(v1), BYTE2(v1), BYTE1(v1), (unsigned __int8)v1);
  return v2;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (000697A8) --------------------------------------------------------
_BYTE *__fastcall sub_697A8(unsigned int a1, int a2)
{
  int v4; // r11
  _BYTE *v5; // r5
  size_t v6; // r0
  _BYTE *v7; // r3

  if ( a2 > 1 )
    return sub_696EC(a1);
  v4 = lib_nextbuf;
  v5 = &lib_stringbuf[128 * lib_nextbuf];
  memset(v5, 0, 0x80u);
  lib_stringbuf[128 * v4] = 46;
  *(_DWORD *)(v5 + 1) = a1;
  v5[5] = 0;
  lib_nextbuf = ((_BYTE)v4 + 1) & 0xF;
  v6 = strlen(v5);
  v5[v6] = 46;
  v7 = &v5[v6];
  v7[1] = 0;
  return v5;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0006987C) --------------------------------------------------------
struct tm *__fastcall sub_6987C(__int64 *a1, int a2)
{
  __int64 v3; // r2
  int v4; // r1
  bool v5; // zf
  int v6; // r4
  int v7; // r1
  bool v8; // zf
  int v9; // r1
  bool v10; // zf
  struct tm *(**v11)(const time_t *); // r5
  struct tm *result; // r0
  int v13; // r4
  time_t v14; // [sp+0h] [bp-Ch] BYREF

  v3 = *a1;
  v4 = *(int *)a1 >> 31;
  v14 = *(_DWORD *)a1;
  v5 = HIDWORD(v3) == v4;
  if ( HIDWORD(v3) == v4 )
    v5 = 1;
  if ( v5 )
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    do
    {
      while ( v3 >= 0 )
      {
        if ( ++v6 > 3 )
          return 0;
        v7 = ((int)v3 - 883612800) >> 31;
        v3 -= 883612800;
        v8 = v7 == HIDWORD(v3);
        if ( v7 == HIDWORD(v3) )
          v8 = 1;
        if ( v8 )
          goto LABEL_15;
      }
      if ( --v6 < -3 )
        return 0;
      v9 = ((int)v3 + 883612800) >> 31;
      v3 += 883612800;
      v10 = v9 == HIDWORD(v3);
      if ( v9 == HIDWORD(v3) )
        v10 = 1;
    }
    while ( !v10 );
LABEL_15:
    v14 = v3;
  }
  v11 = &localtime;
  if ( !a2 )
    v11 = &gmtime;
  while ( 1 )
  {
    result = ((struct tm *(__fastcall *)(const time_t *))v11)(&v14);
    if ( result )
      break;
    while ( v14 >= 0 )
    {
      if ( v14 <= 883612799 )
        return 0;
      if ( ++v6 > 3 )
        return 0;
      v14 -= 883612800;
      result = ((struct tm *(__fastcall *)(const time_t *))v11)(&v14);
      if ( result )
        goto LABEL_23;
    }
    if ( --v6 < -3 )
      return 0;
    v14 += 883612800;
  }
LABEL_23:
  if ( v6 )
  {
    v13 = result->tm_year + 28 * v6;
    result->tm_year = v13;
    if ( (unsigned int)(v13 - 1) > 0xC6 )
      return 0;
  }
  return result;
}

//----- (00069A20) --------------------------------------------------------
_BYTE *__fastcall sub_69A20(int *a1, int a2)
{
  _BYTE *v4; // r6
  int v5; // r4
  int v6; // r1
  unsigned int v7; // r2
  unsigned int v8; // r8
  struct tm *v9; // r3
  __int64 v11; // [sp+28h] [bp-20h] BYREF
  __int64 v12; // [sp+30h] [bp-18h] BYREF
  unsigned __int16 v13; // [sp+38h] [bp-10h] BYREF
  unsigned __int8 v14; // [sp+3Ch] [bp-Ch]
  unsigned __int8 v15; // [sp+3Dh] [bp-Bh]
  unsigned __int8 v16; // [sp+3Eh] [bp-Ah]
  unsigned __int8 v17; // [sp+3Fh] [bp-9h]
  unsigned __int8 v18; // [sp+40h] [bp-8h]
  unsigned __int8 v19; // [sp+41h] [bp-7h]

  v4 = &lib_stringbuf[128 * lib_nextbuf];
  v5 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v4, 0, 0x80u);
  v6 = *a1;
  v7 = a1[1];
  lib_nextbuf = v5;
  if ( v6 || v7 )
  {
    v8 = v7 / 0x418937;
    if ( v7 / 0x418937 == 1000 )
    {
      ++v6;
      v8 = 0;
    }
    sub_65844(&v11, v6, 0);
    v12 = v11;
    v9 = sub_6987C(&v12, a2);
    if ( v9 )
    {
      sub_6C054(
        (int)v4,
        0x80u,
        "%08lx.%08lx  %s, %s %2d %4d %2d:%02d:%02d.%03u",
        *a1,
        a1[1],
        daynames[v9->tm_wday],
        months[v9->tm_mon],
        v9->tm_mday,
        v9->tm_year + 1900,
        v9->tm_hour,
        v9->tm_min,
        v9->tm_sec,
        v8);
    }
    else
    {
      sub_65FC0(&v13, (int *)&v12);
      if ( a2 )
        sub_6C054(
          (int)v4,
          0x80u,
          "%08lx.%08lx [%s, %s %2d %4d %2d:%02d:%02d.%03u UTC]",
          *a1,
          a1[1],
          daynames[v19],
          months[v14 - 1],
          v15,
          v13,
          v16,
          v17,
          v18,
          v8);
      else
        sub_6C054(
          (int)v4,
          0x80u,
          "%08lx.%08lx  %s, %s %2d %4d %2d:%02d:%02d.%03u",
          *a1,
          a1[1],
          daynames[v19],
          months[v14 - 1],
          v15,
          v13,
          v16,
          v17,
          v18,
          v8);
    }
  }
  else
  {
    sub_6D4DC(v4, "(no time)", 128);
  }
  return v4;
}
// B4BFC: using guessed type char *daynames[19];
// B4C18: using guessed type char *months[12];
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (00069C54) --------------------------------------------------------
_BYTE *__fastcall sub_69C54(int *a1)
{
  return sub_69A20(a1, 1);
}

//----- (00069CA0) --------------------------------------------------------
_BYTE *__fastcall sub_69CA0(int *a1)
{
  return sub_69A20(a1, 0);
}

//----- (00069CEC) --------------------------------------------------------
struct tm *__fastcall sub_69CEC(int a1, int a2)
{
  __int64 v4; // [sp+0h] [bp-1Ch] BYREF
  __int64 v5; // [sp+8h] [bp-14h] BYREF

  sub_65844(&v4, a1, 0);
  v5 = v4;
  return sub_6987C(&v5, a2);
}

//----- (00069D58) --------------------------------------------------------
int sub_69D58()
{
  return dword_107208;
}
// 107208: using guessed type int dword_107208;

//----- (00069DAC) --------------------------------------------------------
int sub_69DAC()
{
  return dword_10720C;
}
// 10720C: using guessed type int dword_10720C;

//----- (00069E00) --------------------------------------------------------
int sub_69E00()
{
  return dword_107210;
}
// 107210: using guessed type int dword_107210;

//----- (00069E54) --------------------------------------------------------
int sub_69E54()
{
  return dword_107214;
}
// 107214: using guessed type int dword_107214;

//----- (00069EA8) --------------------------------------------------------
int *__fastcall sub_69EA8(int a1)
{
  int v1; // r6
  signed int v2; // r6
  int *result; // r0
  int v4; // r3
  int v5; // r4
  int *i; // lr
  int v7; // r1

  dword_107210 = 0;
  dword_107208 = 0;
  dword_107214 = 0;
  dword_10720C = 0;
  v1 = dword_107218;
  dword_107218 = 0;
  v2 = a1 + v1;
  result = (int *)sub_63C68(0, v2, 0x8A4u, 0);
  if ( v2 > 0 )
  {
    v4 = 0;
    v5 = dword_10721C;
    for ( i = result; ; i += 553 )
    {
      v7 = dword_107208;
      ++v4;
      *i = v5;
      v5 = (int)i;
      dword_107208 = v7 + 1;
      ++dword_107210;
      if ( v2 == v4 )
        break;
    }
    dword_10721C = (int)&result[553 * v2 - 553];
  }
  ++dword_107214;
  return result;
}
// 107208: using guessed type int dword_107208;
// 10720C: using guessed type int dword_10720C;
// 107210: using guessed type int dword_107210;
// 107214: using guessed type int dword_107214;
// 107218: using guessed type int dword_107218;
// 10721C: using guessed type int dword_10721C;

//----- (00069FA8) --------------------------------------------------------
char *__fastcall sub_69FA8(char *result)
{
  _DWORD *v1; // r4
  int v2; // r2
  bool v3; // zf
  int v4; // r1

  v1 = result;
  if ( result )
  {
    v2 = *((_DWORD *)result + 552) - 1;
    v3 = *((_DWORD *)result + 552) == 1;
    *((_DWORD *)result + 552) = v2;
    if ( !v3 )
      result = sub_64E00(3, "******** freerecvbuff non-zero usage: %d *******", v2);
    v4 = dword_10721C;
    dword_10721C = (int)v1;
    ++dword_107208;
    *v1 = v4;
  }
  return result;
}
// 107208: using guessed type int dword_107208;
// 10721C: using guessed type int dword_10721C;

//----- (0006A044) --------------------------------------------------------
char *__fastcall sub_6A044(char *result)
{
  char **v1; // r12
  int *v2; // r3

  if ( !result )
    return sub_64E00(3, "add_full_recv_buffer received NULL buffer");
  *(_DWORD *)result = 0;
  v2 = (int *)dword_107224;
  if ( dword_107224 )
  {
    v1 = *(char ***)dword_107224;
  }
  else
  {
    dword_107220 = (int)result;
    v2 = &dword_107220;
  }
  if ( dword_107224 )
  {
    *v1 = result;
    v2 = (int *)*v2;
  }
  dword_107224 = (int)v2;
  ++dword_10720C;
  return result;
}
// 6A090: variable 'v1' is possibly undefined
// 10720C: using guessed type int dword_10720C;
// 107220: using guessed type int dword_107220;
// 107224: using guessed type int dword_107224;

//----- (0006A108) --------------------------------------------------------
int sub_6A108()
{
  int v0; // r4
  int v1; // r12
  void *v2; // r0

  v0 = dword_10721C;
  if ( dword_10721C )
  {
    v1 = *(_DWORD *)dword_10721C;
    --dword_107208;
    v2 = (void *)dword_10721C;
    dword_10721C = v1;
    memset(v2, 0, 0x8A4u);
    *(_DWORD *)(v0 + 2208) = 1;
  }
  else
  {
    ++dword_107218;
  }
  return v0;
}
// 107208: using guessed type int dword_107208;
// 107218: using guessed type int dword_107218;
// 10721C: using guessed type int dword_10721C;

//----- (0006A1A4) --------------------------------------------------------
int sub_6A1A4()
{
  int result; // r0
  int *v1; // r1

  result = dword_107220;
  if ( dword_107220 )
  {
    v1 = *(int **)dword_107220;
    dword_107220 = *(_DWORD *)dword_107220;
    if ( dword_107220 )
    {
      if ( dword_107224 != result )
      {
LABEL_4:
        --dword_10720C;
        return result;
      }
      v1 = &dword_107220;
    }
    dword_107224 = (int)v1;
    goto LABEL_4;
  }
  return result;
}
// 10720C: using guessed type int dword_10720C;
// 107220: using guessed type int dword_107220;
// 107224: using guessed type int dword_107224;

//----- (0006A240) --------------------------------------------------------
char *__fastcall sub_6A240(char *result)
{
  char *v1; // r2
  char *v2; // r9
  char *v3; // r4
  int *v4; // r12
  int *v5; // r3
  char *v6; // r0

  v1 = (char *)dword_107220;
  if ( dword_107220 )
  {
    v2 = result;
    do
    {
      while ( 1 )
      {
        v3 = *(char **)v1;
        if ( *((char **)v1 + 16) == v2 )
          break;
        v1 = *(char **)v1;
        if ( !v3 )
          return result;
      }
      v4 = (int *)dword_107220;
      v5 = *(int **)dword_107220;
      if ( (char *)dword_107220 == v1 )
      {
        v6 = v1;
        v4 = &dword_107220;
      }
      else
      {
        if ( !v5 )
          goto LABEL_20;
        while ( v5 != (int *)v1 )
        {
          v4 = v5;
          if ( !*v5 )
            goto LABEL_20;
          v5 = (int *)*v5;
        }
        v6 = (char *)*v4;
        v5 = *(int **)*v4;
      }
      *v4 = (int)v5;
      if ( v5 )
      {
        if ( (char *)dword_107224 == v6 )
          dword_107224 = (int)&dword_107220;
      }
      else
      {
        dword_107224 = 0;
      }
      if ( v6 != v1 )
LABEL_20:
        sub_6ECC0("recvbuff.c", 285, 2, "punlinked == rbufp");
      --dword_10720C;
      result = sub_69FA8(v6);
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}
// 10720C: using guessed type int dword_10720C;
// 107220: using guessed type int dword_107220;
// 107224: using guessed type int dword_107224;

//----- (0006A3A0) --------------------------------------------------------
int sub_6A3A0()
{
  int result; // r0

  result = dword_107220;
  if ( dword_107220 )
    return 1;
  return result;
}
// 107220: using guessed type int dword_107220;

//----- (0006A3FC) --------------------------------------------------------
_BYTE *__fastcall sub_6A3FC(unsigned __int16 *a1)
{
  _BYTE *v3; // r7
  int v4; // r6
  unsigned int v5; // r4
  __int16 v6; // r4
  const char *v7; // r3

  if ( *a1 != 2 || a1[2] != 32639 )
    return sub_6C2E8(a1);
  v3 = &lib_stringbuf[128 * lib_nextbuf];
  v4 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v3, 0, 0x80u);
  v5 = *((_DWORD *)a1 + 1);
  lib_nextbuf = v4;
  v6 = bswap32(v5);
  v7 = (const char *)sub_786B8(HIBYTE(v6));
  if ( v7 )
    sub_6C054((int)v3, 0x80u, "%s(%lu)", v7, (unsigned __int8)v6);
  else
    sub_6C054((int)v3, 0x80u, "REFCLK(%lu,%lu)", HIBYTE(v6), (unsigned __int8)v6);
  return v3;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0006A520) --------------------------------------------------------
int __fastcall sub_6A520(int result, int *a2, unsigned int a3, const char *a4, int a5, int a6, char a7)
{
  int v7; // r7
  int v9; // r4
  int v10; // r12
  int v11; // lr
  bool v12; // cf
  char v13; // r7
  int v14; // lr
  unsigned int v16; // r12
  int v17; // t1
  int v18; // r3
  bool v19; // cf
  const char *v20; // r8
  int v21; // r4
  int v22; // t1

  v7 = a5;
  if ( a4 )
  {
    if ( !*a4 )
      goto LABEL_7;
  }
  else
  {
    a4 = "(null)";
  }
  if ( a6 > 0 || a6 == -1 )
  {
    v20 = a4;
    v21 = 0;
    do
    {
      v22 = *(unsigned __int8 *)++v20;
      ++v21;
      if ( !v22 )
        break;
    }
    while ( a6 > v21 || a6 == -1 );
    v7 = a5 - v21;
  }
LABEL_7:
  v9 = v7 & ~(v7 >> 31);
  if ( (a7 & 1) != 0 )
  {
    v9 = -v9;
  }
  else if ( v7 > 0 )
  {
    v10 = *a2;
    v11 = v7 & ~(v7 >> 31);
    do
    {
      v12 = v10 + 1 >= a3;
      if ( v10 + 1 >= a3 )
        ++v10;
      else
        *(_BYTE *)(result + v10) = 32;
      if ( !v12 )
        v10 = *a2 + 1;
      --v11;
      *a2 = v10;
    }
    while ( v11 );
    if ( v9 < 1 )
      --v9;
    else
      v9 = 0;
  }
  v13 = *a4;
  if ( *a4 )
  {
    v14 = a6;
    do
    {
      if ( a6 != -1 && v14-- <= 0 )
        break;
      v16 = *a2 + 1;
      if ( v16 < a3 )
      {
        *(_BYTE *)(result + *a2) = v13;
        v16 = *a2 + 1;
      }
      *a2 = v16;
      v17 = *(unsigned __int8 *)++a4;
      v13 = v17;
    }
    while ( v17 );
  }
  if ( v9 )
  {
    v18 = *a2;
    do
    {
      v19 = v18 + 1 >= a3;
      if ( v18 + 1 >= a3 )
        ++v18;
      else
        *(_BYTE *)(result + v18) = 32;
      if ( !v19 )
        v18 = *a2 + 1;
      ++v9;
      *a2 = v18;
    }
    while ( v9 );
  }
  return result;
}

//----- (0006A6BC) --------------------------------------------------------
int __fastcall sub_6A6BC(
        int a1,
        unsigned int *a2,
        unsigned int a3,
        int a4,
        __int64 a5,
        int a6,
        int a7,
        int a8,
        unsigned int a9)
{
  const char *v12; // r9
  int v13; // r5
  unsigned __int64 v14; // r0
  char *v15; // r7
  int v16; // r2
  char v17; // r3
  _BOOL4 v18; // r2
  unsigned int v19; // r3
  int v20; // r10
  int v21; // r12
  int v22; // lr
  int v23; // r9
  int v24; // r7
  int v25; // r2
  int v26; // r3
  int v27; // lr
  int v28; // r7
  int v29; // r1
  int v30; // lr
  bool v31; // cf
  bool v32; // cf
  int v33; // r3
  unsigned int v34; // r1
  unsigned int v35; // r2
  int v36; // r3
  bool v37; // cf
  unsigned __int64 v38; // r2
  int v39; // r3
  unsigned int v41; // [sp+0h] [bp-64h]
  int v42; // [sp+0h] [bp-64h]
  int v43; // [sp+8h] [bp-5Ch]
  unsigned int v44; // [sp+Ch] [bp-58h]
  int v45; // [sp+18h] [bp-4Ch]
  int v46; // [sp+1Ch] [bp-48h]
  _BYTE v47[44]; // [sp+30h] [bp-34h] BYREF

  v43 = a7;
  if ( (a9 & 0x80) != 0 )
  {
    v41 = a5;
    v45 = 0;
    v46 = 0;
    v44 = HIDWORD(a5);
  }
  else
  {
    v38 = abs64(a5);
    v44 = HIDWORD(v38);
    v41 = v38;
    if ( a5 < 0 )
    {
      v45 = 1;
      v46 = 45;
    }
    else if ( (a9 & 2) != 0 )
    {
      v45 = 1;
      v46 = 43;
    }
    else
    {
      v39 = a9 & 4;
      v45 = v39;
      if ( (a9 & 4) != 0 )
      {
        v45 = 1;
        v39 = 32;
      }
      v46 = v39;
    }
  }
  if ( (a9 & 0x40) != 0 )
    v12 = "0123456789ABCDEF";
  else
    v12 = "0123456789abcdef";
  v13 = 0;
  v14 = __PAIR64__(v44, v41);
  v15 = v47;
  do
  {
    ++v13;
    LODWORD(v14) = sub_8BFD0(v14, a6);
    v17 = v12[v16];
    v18 = (unsigned int)v13 <= 0x2A;
    if ( !v14 )
      v18 = 0;
    *v15++ = v17;
  }
  while ( v18 );
  v19 = v41;
  v20 = a9 & 0x20;
  v42 = v13;
  v21 = ((v19 | v44) != 0) & (a9 >> 3);
  if ( !v21 )
    goto LABEL_10;
  if ( a6 == 8 )
  {
    v22 = a8;
    v21 = 0;
    if ( a8 > v13 )
      goto LABEL_11;
    v22 = v13 + 1;
    v23 = 1;
  }
  else
  {
    if ( a6 != 16 )
    {
      v21 = 0;
LABEL_10:
      v22 = a8;
LABEL_11:
      v23 = v22 - v13;
      goto LABEL_12;
    }
    v22 = a8;
    v23 = a8 - v13;
    if ( (a9 & 0x40) != 0 )
      v21 = 88;
    else
      v21 = 120;
  }
LABEL_12:
  if ( (a9 & 0x20) != 0 )
  {
    if ( v13 == 3 * (v13 / 3) )
      v24 = v13 - 1;
    else
      v24 = v13;
    LODWORD(v14) = 1431655766 * v24;
    v20 = v24 / 3;
    v23 -= v24 / 3;
    v43 = a7 - v24 / 3;
  }
  v25 = v23 & ~(v23 >> 31);
  if ( v22 < v13 )
    v26 = v43 - v13;
  else
    v26 = v43 - v22;
  v27 = v26 - v45;
  if ( v21 )
    v27 -= 2;
  v28 = a9 & 1;
  v29 = v27 & ~(v27 >> 31);
  if ( (a9 & 1) != 0 )
  {
    v28 = -v29;
  }
  else
  {
    LODWORD(v14) = a8 == -1;
    if ( ((unsigned int)v14 & (a9 >> 4)) != 0 )
    {
      v25 += v29;
    }
    else if ( v27 > 0 )
    {
      LODWORD(v14) = *a2;
      v30 = v27 & ~(v27 >> 31);
      do
      {
        v31 = (int)v14 + 1 >= a3;
        if ( (int)v14 + 1 >= a3 )
          LODWORD(v14) = v14 + 1;
        else
          *(_BYTE *)(a1 + v14) = 32;
        if ( !v31 )
          LODWORD(v14) = *a2 + 1;
        --v30;
        *a2 = v14;
      }
      while ( v30 );
      v42 = v13;
      if ( v29 < 1 )
        v28 = v29 - 1;
      else
        v28 = 0;
    }
    else
    {
      v28 = v27 & ~(v27 >> 31);
    }
  }
  if ( v46 )
  {
    LODWORD(v14) = *a2;
    HIDWORD(v14) = *a2 + 1;
    if ( HIDWORD(v14) < a3 )
    {
      *(_BYTE *)(a1 + v14) = v46;
      HIDWORD(v14) = *a2 + 1;
    }
    *a2 = HIDWORD(v14);
  }
  if ( v21 )
  {
    LODWORD(v14) = *a2;
    HIDWORD(v14) = *a2 + 1;
    if ( HIDWORD(v14) < a3 )
    {
      *(_BYTE *)(a1 + v14) = 48;
      LODWORD(v14) = *a2;
      HIDWORD(v14) = *a2 + 1;
    }
    LODWORD(v14) = v14 + 2;
    *a2 = HIDWORD(v14);
    if ( (unsigned int)v14 < a3 )
    {
      *(_BYTE *)(a1 + HIDWORD(v14)) = v21;
      HIDWORD(v14) = *a2;
    }
    *a2 = HIDWORD(v14) + 1;
  }
  if ( v25 )
  {
    HIDWORD(v14) = *a2;
    do
    {
      LODWORD(v14) = HIDWORD(v14) + 1;
      v32 = HIDWORD(v14) + 1 >= a3;
      if ( HIDWORD(v14) + 1 >= a3 )
        ++HIDWORD(v14);
      else
        *(_BYTE *)(a1 + HIDWORD(v14)) = 48;
      if ( !v32 )
        HIDWORD(v14) = *a2 + 1;
      --v25;
      *a2 = HIDWORD(v14);
    }
    while ( v25 );
  }
  if ( v13 > 0 )
  {
    v33 = v42;
    do
    {
      while ( 1 )
      {
        v34 = *a2;
        --v33;
        v35 = *a2 + 1;
        if ( v35 < a3 )
        {
          *(_BYTE *)(a1 + v34) = v47[v33];
          v34 = *a2;
          v35 = *a2 + 1;
        }
        LODWORD(v14) = v33 > 0 && v20 > 0;
        *a2 = v35;
        if ( !(_DWORD)v14 )
          break;
        if ( v33 == 3 * (v33 / 3u) )
        {
          if ( a3 > v34 + 2 )
          {
            *(_BYTE *)(a1 + v35) = 44;
            v35 = *a2;
          }
          *a2 = v35 + 1;
        }
      }
    }
    while ( v33 );
  }
  if ( v28 )
  {
    v36 = *a2;
    do
    {
      v37 = v36 + 1 >= a3;
      if ( v36 + 1 >= a3 )
        ++v36;
      else
        *(_BYTE *)(a1 + v36) = 32;
      if ( !v37 )
        v36 = *a2 + 1;
      ++v28;
      *a2 = v36;
    }
    while ( v28 );
  }
  return v14;
}
// 6A774: variable 'v14' is possibly undefined
// 6A780: variable 'v16' is possibly undefined

//----- (0006AB20) --------------------------------------------------------
int __fastcall sub_6AB20(double a1, unsigned int a2, int a3, int a4, unsigned int a5, _DWORD *a6)
{
  double v6; // d0
  int *v7; // r8
  int v8; // r10
  double v9; // d9
  double v10; // d7
  unsigned __int64 v11; // r6
  int v12; // r9
  int v13; // r3
  double v14; // d7
  double v15; // d8
  __int64 v16; // r0
  __int64 v17; // r4
  int v18; // r3
  double v19; // d7
  int v20; // r1
  unsigned __int64 v21; // r10
  double v22; // r0
  double v23; // d8
  double v24; // d8
  __int64 v25; // r0
  double v26; // d7
  unsigned __int64 v27; // r2
  _BOOL4 v28; // r1
  int v29; // r3
  const char *v30; // r1
  int v31; // r0
  const char *v32; // r3
  _BYTE *v33; // r2
  int v34; // t1
  bool v35; // zf
  _BOOL4 v36; // r3
  _BYTE *v37; // r6
  int v38; // r11
  int v39; // r2
  __int64 v40; // r0
  int v41; // r3
  int v42; // r4
  int v43; // r2
  int v44; // r1
  int v45; // r10
  int v46; // r6
  int v47; // r12
  int v48; // r1
  int v49; // r12
  bool v50; // cc
  bool v51; // cf
  bool v52; // cf
  bool v53; // r6
  int v54; // r5
  _BOOL4 v55; // r3
  bool v56; // cf
  int v57; // r2
  char v58; // r1
  bool v59; // cf
  int v60; // r3
  char v61; // r2
  bool v62; // cf
  int v63; // r3
  bool v64; // cf
  unsigned __int8 *v65; // r10
  unsigned __int64 v66; // r4
  int v67; // r2
  int v68; // r0
  int v69; // r1
  int v70; // r3
  int v71; // r5
  int v72; // t1
  char v73; // r3
  int v74; // r10
  unsigned int v75; // r11
  int v76; // r2
  __int64 v77; // r0
  _BOOL4 v78; // r3
  char v79; // r3
  int v80; // r3
  int v83; // [sp+1Ch] [bp-98h]
  const char *v84; // [sp+20h] [bp-94h]
  __int64 v85; // [sp+20h] [bp-94h]
  __int64 v86; // [sp+20h] [bp-94h]
  char v87; // [sp+20h] [bp-94h]
  int v89; // [sp+30h] [bp-84h]
  int v90; // [sp+38h] [bp-7Ch]
  int v91; // [sp+3Ch] [bp-78h]
  unsigned __int64 v92; // [sp+40h] [bp-74h]
  int v93; // [sp+4Ch] [bp-68h]
  _BYTE v94[4]; // [sp+50h] [bp-64h] BYREF
  _BYTE v95[44]; // [sp+54h] [bp-60h] BYREF
  _BYTE v96[44]; // [sp+80h] [bp-34h] BYREF

  v7 = (int *)HIDWORD(a1);
  v83 = LODWORD(a1);
  LODWORD(a1) = 2092;
  v8 = a4;
  if ( a4 == -1 )
    v8 = 6;
  if ( v6 < 0.0 )
  {
    v90 = 45;
  }
  else
  {
    if ( (a5 & 2) != 0 )
    {
      v90 = 43;
    }
    else
    {
      v29 = a5 & 4;
      if ( (a5 & 4) != 0 )
        v29 = 32;
      v90 = v29;
    }
    if ( v6 == 0.0 )
      goto LABEL_7;
  }
  if ( v6 + v6 == v6 )
  {
    if ( (a5 & 0x40) != 0 )
      v30 = "INF";
    else
      v30 = "inf";
    v31 = v90;
    v32 = (const char *)*(unsigned __int8 *)v30;
    if ( !v90 )
      goto LABEL_67;
    v35 = v32 == 0;
    if ( !*v30 )
      v32 = v95;
    v31 = 1;
    if ( v35 )
      v84 = v32;
    v95[0] = v90;
    if ( !v35 )
    {
LABEL_67:
      v33 = &v95[v31 - 1];
      v84 = v95;
      do
      {
        *++v33 = (_BYTE)v32;
        ++v31;
        v34 = *(unsigned __int8 *)++v30;
        LOBYTE(v32) = v34;
      }
      while ( v34 );
    }
    LODWORD(a1) = sub_6A520(v83, v7, a2, v84, a3, v31, a5);
    return LODWORD(a1);
  }
LABEL_7:
  v9 = -v6;
  if ( (a5 & 0x300) == 0 )
  {
    if ( v6 >= 0.0 )
      v9 = v6;
    if ( v8 >= 19 )
      v12 = 19;
    else
      v12 = v8;
    HIDWORD(v11) = a5 & 0x200;
    if ( (a5 & 0x200) == 0 )
    {
      v91 = 0;
      LODWORD(v11) = 0;
      v15 = v9;
      goto LABEL_35;
    }
    v91 = a5 & 0x300;
    LODWORD(v11) = v91;
    v14 = 1.0;
    goto LABEL_34;
  }
  v91 = a5 & 0x100;
  if ( (a5 & 0x100) != 0 )
  {
    --v8;
    v91 = (a5 & 8) == 0;
  }
  if ( v6 >= 0.0 )
    v10 = v6;
  else
    v10 = -v6;
  if ( v10 >= 1.0 || v10 <= 0.0 )
  {
    LODWORD(v11) = 0;
  }
  else
  {
    LODWORD(v11) = -1;
    do
    {
      v10 = v10 * 10.0;
      if ( v10 >= 1.0 )
        break;
      if ( v10 <= 0.0 )
        break;
      LODWORD(v11) = v11 - 1;
    }
    while ( (_DWORD)v11 != -99 );
  }
  if ( v10 < 10.0 )
  {
    if ( v6 >= 0.0 )
      v9 = v6;
    if ( v8 >= 19 )
      v12 = 19;
    else
      v12 = v8;
  }
  else
  {
    LODWORD(v11) = v11 + 1;
    do
    {
      v10 = v10 / 10.0;
      if ( v10 < 10.0 )
        break;
      LODWORD(v11) = v11 + 1;
    }
    while ( (int)v11 <= 98 );
    if ( v6 >= 0.0 )
      v9 = v6;
    if ( v8 >= 19 )
      v12 = 19;
    else
      v12 = v8;
    if ( (int)v11 > 0 )
    {
      v13 = v11;
      v14 = 1.0;
      do
      {
        --v13;
        v14 = v14 * 10.0;
      }
      while ( v13 );
      goto LABEL_33;
    }
  }
  if ( !(_DWORD)v11 )
  {
    v11 = 0x100000000LL;
    v14 = 1.0;
    goto LABEL_34;
  }
  v80 = v11;
  v14 = 1.0;
  do
  {
    ++v80;
    v14 = v14 / 10.0;
  }
  while ( v80 );
LABEL_33:
  HIDWORD(v11) = 1;
LABEL_34:
  v15 = v9 / v14;
  while ( 1 )
  {
LABEL_35:
    if ( v15 >= 1.84467441e19 )
      goto LABEL_94;
    LODWORD(v16) = sub_8C010(v15);
    v17 = v16;
    LODWORD(a1) = sub_8BEC4(v16);
    if ( v15 < a1 )
      --v17;
    if ( v17 == -1 )
    {
LABEL_94:
      *a6 = 1;
      return LODWORD(a1);
    }
    v18 = v12;
    v19 = 1.0;
    if ( v8 > 0 )
    {
      do
      {
        --v18;
        v19 = v19 * 10.0;
      }
      while ( v18 );
      if ( v12 < 1 )
        v18 = v12 - 1;
      else
        v18 = 0;
    }
    for ( ; v18; v19 = v19 / 10.0 )
      ++v18;
    LODWORD(v21) = sub_8C010(v19);
    HIDWORD(v21) = v20;
    LODWORD(v22) = sub_8BEC4(v17);
    v23 = v15 - v22;
    LODWORD(a1) = sub_8BEC4(v21);
    v24 = v23 * a1;
    if ( v24 < 1.84467441e19 )
    {
      LODWORD(v25) = sub_8C010(v24);
      v85 = v25;
      LODWORD(a1) = sub_8BEC4(v25);
      v26 = a1;
      v27 = v85;
      if ( v24 < a1 )
      {
        v86 = v85 - 1;
        LODWORD(a1) = sub_8BEC4(v86);
        v27 = v86;
        v26 = a1;
      }
      if ( v24 - v26 >= 0.5 )
        ++v27;
LABEL_51:
      if ( v21 > v27 )
        goto LABEL_52;
      goto LABEL_80;
    }
    if ( v24 - 1.84467441e19 >= 0.5 )
    {
      v27 = 0;
      goto LABEL_51;
    }
LABEL_80:
    v36 = ++v17 == 10;
    if ( !HIDWORD(v11) )
      v36 = 0;
    if ( v36 )
    {
      LODWORD(v11) = v11 + 1;
      v27 = 0;
      v17 = 1;
    }
    else
    {
      v27 = 0;
    }
LABEL_52:
    if ( (a5 & 0x100) == 0 )
      break;
    v28 = (int)v11 <= v12;
    if ( !HIDWORD(v11) )
      v28 = 0;
    if ( !v28 )
      break;
    if ( (int)v11 < -4 )
    {
      v92 = v27;
      goto LABEL_211;
    }
    v8 = v12 - v11;
    v15 = v9;
    HIDWORD(v11) = 0;
    if ( v12 - (int)v11 >= 19 )
      v12 = 19;
    else
      v12 -= v11;
  }
  v92 = v27;
  if ( !HIDWORD(v11) )
    goto LABEL_96;
LABEL_211:
  if ( (v11 & 0x80000000) == 0LL )
    v73 = 43;
  else
    v73 = 45;
  v87 = v73;
  if ( (v11 & 0x80000000) != 0LL )
    LODWORD(v11) = -(int)v11;
  v11 = (int)v11;
  v74 = 0;
  do
  {
    v75 = v74 + 1;
    sub_8BFD0(v11, 0xAu);
    v94[v74] = a0123456789abcd_2[v76];
    v74 = 1;
    LODWORD(v77) = sub_8BFD0(v11, 0xAu);
    v78 = v75 <= 1;
    LODWORD(v11) = v77;
    if ( !v77 )
      v78 = 0;
    HIDWORD(v11) = HIDWORD(v77);
  }
  while ( v78 );
  if ( v75 == 1 )
    v94[1] = 48;
  HIDWORD(v11) = 4;
  v94[2] = v87;
  if ( (a5 & 0x40) != 0 )
    v79 = 69;
  else
    v79 = 101;
  v94[3] = v79;
LABEL_96:
  v37 = v95;
  v38 = 0;
  do
  {
    sub_8BFD0(v17, 0xAu);
    ++v38;
    *v37++ = a0123456789abcd_2[v39];
    LODWORD(v40) = sub_8BFD0(v17, 0xAu);
    v41 = (unsigned int)v38 <= 0x2A;
    LODWORD(v17) = v40;
    if ( !v40 )
      v41 = 0;
    HIDWORD(v17) = HIDWORD(v40);
  }
  while ( v41 );
  v42 = v38;
  if ( v92 )
  {
    v65 = v96;
    v66 = v92;
    LODWORD(v11) = v96;
    v89 = HIDWORD(v11);
    HIDWORD(v11) = 0;
    v93 = v38;
    do
    {
      sub_8BFD0(v66, 0xAu);
      ++HIDWORD(v11);
      *(_BYTE *)v11 = a0123456789abcd_2[v67];
      LODWORD(v11) = v11 + 1;
      v68 = sub_8BFD0(v66, 0xAu);
      v70 = v68 | v69;
      HIDWORD(v66) = v69;
      v44 = HIDWORD(v11) <= 0x2A;
      if ( !v70 )
        v44 = 0;
      LODWORD(v66) = v68;
    }
    while ( v44 );
    v71 = HIDWORD(v11);
    v42 = v93;
    HIDWORD(v11) = v89;
    v41 = v71;
    v43 = v12 - v71;
    if ( v91 )
    {
      if ( v71 <= 0 )
      {
        v43 = 0;
        goto LABEL_104;
      }
      do
      {
        v72 = *v65++;
        if ( v72 != 48 )
        {
          v12 -= v44;
          v91 = v44;
          goto LABEL_197;
        }
        ++v44;
      }
      while ( v44 != v71 );
      v91 = v44;
      v12 -= v44;
      v41 = v44;
    }
LABEL_197:
    if ( v12 <= 0 )
    {
      v44 = v12;
      v12 = v91;
      goto LABEL_104;
    }
    v45 = 1;
  }
  else
  {
    if ( !v91 )
    {
      v41 = 0;
      v43 = v12;
      goto LABEL_197;
    }
    v43 = 0;
    v44 = 0;
LABEL_104:
    v91 = v12;
    v12 = v44;
    v45 = (a5 >> 3) & 1;
  }
  LODWORD(v11) = a5 & 0x20;
  if ( (a5 & 0x20) != 0 )
  {
    if ( v38 == 3 * (v38 / 3) )
      v46 = v38 - 1;
    else
      v46 = v38;
    LODWORD(v11) = v46 / 3;
  }
  v47 = a5 & 1;
  LODWORD(a1) = a3 - v38 - HIDWORD(v11) - v12 - v11 - v45;
  if ( v90 )
    --LODWORD(a1);
  if ( SLODWORD(a1) < 0 )
  {
    v47 = 0;
    goto LABEL_141;
  }
  if ( (a5 & 1) != 0 )
  {
    v47 = -LODWORD(a1);
    goto LABEL_141;
  }
  if ( (a5 & 0x10) != 0 )
  {
    if ( !LODWORD(a1) )
      goto LABEL_141;
    v48 = *v7;
    if ( v90 )
    {
      v49 = v48 + 1;
      v50 = a2 > v48 + 1;
      if ( a2 <= v48 + 1 )
        ++v48;
      else
        v49 = v83;
      if ( v50 )
      {
        *(_BYTE *)(v49 + v48) = v90;
        v48 = *v7 + 1;
      }
      *v7 = v48;
    }
    v47 = LODWORD(a1);
    LODWORD(a1) = a2;
    do
    {
      v51 = v48 + 1 >= a2;
      if ( v48 + 1 >= a2 )
        ++v48;
      else
        *(_BYTE *)(v83 + v48) = 48;
      if ( !v51 )
        v48 = *v7 + 1;
      --v47;
      *v7 = v48;
    }
    while ( v47 );
  }
  else
  {
    if ( LODWORD(a1) )
    {
      v47 = LODWORD(a1);
      HIDWORD(a1) = *v7;
      LODWORD(a1) = a2;
      do
      {
        v52 = HIDWORD(a1) + 1 >= a2;
        if ( HIDWORD(a1) + 1 >= a2 )
          ++HIDWORD(a1);
        else
          *(_BYTE *)(v83 + HIDWORD(a1)) = 32;
        if ( !v52 )
          HIDWORD(a1) = *v7 + 1;
        --v47;
        *v7 = HIDWORD(a1);
      }
      while ( v47 );
    }
LABEL_141:
    if ( v90 )
    {
      LODWORD(a1) = *v7;
      HIDWORD(a1) = *v7 + 1;
      if ( HIDWORD(a1) < a2 )
      {
        *(_BYTE *)(v83 + LODWORD(a1)) = v90;
        HIDWORD(a1) = *v7 + 1;
      }
      *v7 = HIDWORD(a1);
    }
  }
  if ( v38 > 0 )
  {
    v53 = (int)v11 > 0;
    v54 = v41;
    do
    {
      while ( 1 )
      {
        LODWORD(a1) = *v7;
        --v42;
        HIDWORD(a1) = *v7 + 1;
        if ( HIDWORD(a1) < a2 )
        {
          *(_BYTE *)(v83 + LODWORD(a1)) = v95[v42];
          LODWORD(a1) = *v7;
          HIDWORD(a1) = *v7 + 1;
        }
        v55 = v42 > 0 && v53;
        *v7 = HIDWORD(a1);
        if ( !v55 )
          break;
        if ( v42 == 3 * (v42 / 3u) )
        {
          if ( a2 > LODWORD(a1) + 2 )
          {
            *(_BYTE *)(v83 + HIDWORD(a1)) = 44;
            HIDWORD(a1) = *v7;
          }
          *v7 = HIDWORD(a1) + 1;
        }
      }
    }
    while ( v42 );
    v41 = v54;
  }
  if ( v45 )
  {
    LODWORD(a1) = *v7;
    HIDWORD(a1) = *v7 + 1;
    if ( HIDWORD(a1) < a2 )
    {
      *(_BYTE *)(v83 + LODWORD(a1)) = 46;
      HIDWORD(a1) = *v7 + 1;
    }
    *v7 = HIDWORD(a1);
  }
  if ( v43 > 0 )
  {
    HIDWORD(a1) = *v7;
    do
    {
      LODWORD(a1) = HIDWORD(a1) + 1;
      v56 = HIDWORD(a1) + 1 >= a2;
      if ( HIDWORD(a1) + 1 >= a2 )
        ++HIDWORD(a1);
      else
        *(_BYTE *)(v83 + HIDWORD(a1)) = 48;
      if ( !v56 )
        HIDWORD(a1) = *v7 + 1;
      --v43;
      *v7 = HIDWORD(a1);
    }
    while ( v43 );
  }
  if ( v91 < v41 )
  {
    v57 = *v7;
    LODWORD(a1) = v96;
    do
    {
      v58 = v57 + 1;
      --v41;
      v59 = v57 + 1 >= a2;
      if ( v57 + 1 >= a2 )
        ++v57;
      else
        v58 = v96[v41];
      if ( !v59 )
      {
        *(_BYTE *)(v83 + v57) = v58;
        v57 = *v7 + 1;
      }
      *v7 = v57;
    }
    while ( v91 != v41 );
  }
  if ( HIDWORD(v11) )
  {
    v60 = *v7;
    LODWORD(a1) = a2;
    do
    {
      v61 = v60 + 1;
      --HIDWORD(v11);
      v62 = v60 + 1 >= a2;
      if ( v60 + 1 >= a2 )
        ++v60;
      else
        v61 = v94[HIDWORD(v11)];
      if ( !v62 )
      {
        *(_BYTE *)(v83 + v60) = v61;
        v60 = *v7 + 1;
      }
      *v7 = v60;
    }
    while ( HIDWORD(v11) );
  }
  if ( v47 )
  {
    v63 = *v7;
    LODWORD(a1) = a2;
    do
    {
      v64 = v63 + 1 >= a2;
      if ( v63 + 1 >= a2 )
        ++v63;
      else
        *(_BYTE *)(v83 + v63) = 32;
      if ( !v64 )
        v63 = *v7 + 1;
      ++v47;
      *v7 = v63;
    }
    while ( v47 );
  }
  return LODWORD(a1);
}
// 6AB84: variable 'v6' is possibly undefined
// 6ACE8: variable 'v16' is possibly undefined
// 6AD00: variable 'a1' is possibly undefined
// 6AD68: variable 'v20' is possibly undefined
// 6AD80: variable 'v22' is possibly undefined
// 6ADB0: variable 'v25' is possibly undefined
// 6AF08: variable 'v84' is possibly undefined
// 6B0E0: variable 'v39' is possibly undefined
// 6B118: variable 'v40' is possibly undefined
// 6B514: variable 'v67' is possibly undefined
// 6B538: variable 'v69' is possibly undefined
// 6B60C: variable 'v76' is possibly undefined
// 6B644: variable 'v77' is possibly undefined

//----- (0006B6F8) --------------------------------------------------------
unsigned int __fastcall sub_6B6F8(int a1, unsigned int a2, unsigned __int8 *a3, int *a4)
{
  int v4; // lr
  unsigned int v6; // r7
  int v7; // lr
  unsigned int v8; // r6
  int v10; // r12
  int v11; // r3
  int v12; // r8
  unsigned __int8 *v13; // r4
  __int64 v14; // r0
  unsigned int v15; // r9
  int v16; // r3
  unsigned int v17; // r0
  int v18; // r4
  int v19; // r3
  unsigned int v21; // r9
  int v22; // lr
  bool v23; // zf
  bool v24; // zf
  int v25; // r3
  unsigned int v26; // r5
  int v27; // r3
  unsigned int v28; // r2
  int v29; // r0
  __int64 v30; // r8
  __int64 *v31; // r2
  int v32; // r3
  int v33; // r3
  int v34; // t1
  const char *v35; // r3
  int v36; // r2
  unsigned int v37; // r2
  bool v38; // cf
  __int64 v39; // r8
  __int64 *v40; // r3
  int *v41; // r0
  __int64 v42; // [sp+0h] [bp-34h]
  unsigned int v43; // [sp+24h] [bp-10h] BYREF
  int v44; // [sp+28h] [bp-Ch] BYREF

  v4 = a2;
  if ( a2 )
    v4 = 1;
  if ( a1 )
    v4 = 0;
  LOWORD(v6) = -13107;
  v23 = v4 == 0;
  v7 = 0;
  if ( v23 )
    v8 = a2;
  else
    v8 = 0;
  v43 = 0;
  v10 = 0;
  v11 = *a3;
  v44 = 0;
  v12 = 0;
  HIWORD(v6) = -13108;
  v13 = a3 + 1;
  v14 = 0xFFFFFFFFLL;
  while ( v11 )
  {
LABEL_10:
    switch ( v7 )
    {
      case 1:
        switch ( v11 )
        {
          case ' ':
            v11 = *v13;
            HIDWORD(v14) |= 4u;
            ++v13;
            continue;
          case '#':
            v11 = *v13;
            HIDWORD(v14) |= 8u;
            ++v13;
            continue;
          case '\'':
            v11 = *v13;
            HIDWORD(v14) |= 0x20u;
            ++v13;
            continue;
          case '+':
            v11 = *v13;
            HIDWORD(v14) |= 2u;
            ++v13;
            continue;
          case '-':
            HIDWORD(v14) |= 1u;
            goto LABEL_16;
          case '0':
            v11 = *v13;
            HIDWORD(v14) |= 0x10u;
            ++v13;
            continue;
          default:
            v7 = 2;
            continue;
        }
      case 2:
        v21 = (unsigned __int8)(v11 - 48);
        if ( v21 > 9 )
        {
          if ( v11 == 42 )
          {
            v10 = *a4;
            v7 = 3;
            v11 = *v13;
            ++a4;
            ++v13;
            if ( v10 < 0 )
            {
              HIDWORD(v14) |= 1u;
              v10 = -v10;
            }
          }
          else
          {
            v7 = 3;
          }
          continue;
        }
        if ( v10 <= (int)((unsigned int)(((0x7FFFFFFF - v21) * (unsigned __int64)v6) >> 32) >> 3) )
        {
          v11 = *v13++;
          v10 = v21 + 10 * v10;
          continue;
        }
LABEL_114:
        v16 = 1;
        v44 = 1;
        goto LABEL_18;
      case 3:
        if ( v11 != 46 )
          goto LABEL_28;
        v11 = *v13;
        v7 = 4;
        ++v13;
        continue;
      case 4:
        v15 = (unsigned __int8)(v11 - 48);
        if ( (_DWORD)v14 != -1 )
        {
          if ( v15 > 9 )
            goto LABEL_80;
          if ( (int)v14 > (int)((unsigned int)(((0x7FFFFFFF - v15) * (unsigned __int64)v6) >> 32) >> 3) )
            goto LABEL_114;
          LODWORD(v14) = v15 + 10 * v14;
LABEL_16:
          v11 = *v13++;
          if ( !v11 )
            goto LABEL_17;
          goto LABEL_10;
        }
        if ( v15 <= 9 )
        {
          LODWORD(v14) = (unsigned __int8)(v11 - 48);
          goto LABEL_16;
        }
        LODWORD(v14) = 0;
LABEL_80:
        if ( v11 == 42 )
        {
          v29 = *a4;
          v7 = 5;
          v11 = *v13;
          ++a4;
          ++v13;
          LODWORD(v14) = v29 | (v29 >> 31);
        }
        else
        {
LABEL_28:
          v7 = 5;
        }
        break;
      case 5:
        switch ( v11 )
        {
          case 'L':
            v12 = v7;
            v11 = *v13;
            v7 = 6;
            ++v13;
            break;
          case 'h':
            v11 = *v13;
            v24 = v11 == 104;
            if ( v11 == 104 )
            {
              v11 = v13[1];
            }
            else
            {
              ++v13;
              v7 = 6;
              v12 = 2;
            }
            if ( v24 )
            {
              v7 = 6;
              v13 += 2;
              v12 = 1;
            }
            break;
          case 'j':
            v11 = *v13;
            v7 = 6;
            ++v13;
            v12 = 8;
            break;
          case 'l':
            v11 = *v13;
            v23 = v11 == 108;
            if ( v11 == 108 )
            {
              v11 = v13[1];
            }
            else
            {
              ++v13;
              v7 = 6;
              v12 = 3;
            }
            if ( v23 )
            {
              v7 = 6;
              v13 += 2;
              v12 = 4;
            }
            break;
          case 't':
            v11 = *v13;
            v7 = 6;
            ++v13;
            v12 = 7;
            break;
          case 'z':
            v7 = 6;
            v11 = *v13;
            v12 = 6;
            ++v13;
            break;
          default:
            v7 = 6;
            break;
        }
        continue;
      case 6:
        switch ( v11 )
        {
          case '%':
            v36 = v43++;
            if ( v43 < v8 )
              *(_BYTE *)(a1 + v36) = 37;
            break;
          case 'A':
          case 'F':
            HIDWORD(v14) |= 0x40u;
            goto LABEL_74;
          case 'E':
            HIDWORD(v14) |= 0x40u;
            goto LABEL_72;
          case 'G':
            HIDWORD(v14) |= 0x40u;
            goto LABEL_65;
          case 'X':
            HIDWORD(v14) |= 0x40u;
            goto LABEL_62;
          case 'a':
          case 'f':
LABEL_74:
            v27 = v10;
            v26 = ((unsigned int)a4 + 7) & 0xFFFFFFF8;
            v28 = v8;
            v42 = v14;
            HIDWORD(v14) = &v43;
            goto LABEL_68;
          case 'c':
            v37 = v43;
            v38 = ++v43 >= v8;
            if ( v43 < v8 )
              LODWORD(v14) = *a4;
            ++a4;
            if ( !v38 )
              *(_BYTE *)(a1 + v37) = v14;
            break;
          case 'd':
          case 'i':
            switch ( v12 )
            {
              case 1:
                LODWORD(v39) = *(char *)a4++;
                v39 = (int)v39;
                break;
              case 2:
                LODWORD(v39) = *(__int16 *)a4++;
                v39 = (int)v39;
                break;
              case 4:
              case 8:
                v40 = (__int64 *)(((unsigned int)a4 + 7) & 0xFFFFFFF8);
                a4 = (int *)(v40 + 1);
                v39 = *v40;
                break;
              case 6:
                v39 = (unsigned int)*a4++;
                break;
              default:
                LODWORD(v39) = *a4++;
                v39 = (int)v39;
                break;
            }
            sub_6A6BC(a1, &v43, v8, 10, v39, 10, v10, v14, HIDWORD(v14));
            break;
          case 'e':
LABEL_72:
            v26 = ((unsigned int)a4 + 7) & 0xFFFFFFF8;
            sub_6AB20(COERCE_DOUBLE(__PAIR64__(&v43, a1)), v8, v10, v14, HIDWORD(v14) | 0x200, &v44);
            goto LABEL_69;
          case 'g':
LABEL_65:
            v26 = ((unsigned int)a4 + 7) & 0xFFFFFFF8;
            v27 = v10;
            HIDWORD(v42) = HIDWORD(v14) | 0x100;
            v28 = v8;
            HIDWORD(v14) = &v43;
            if ( !(_DWORD)v14 )
              LODWORD(v14) = 1;
            LODWORD(v42) = v14;
LABEL_68:
            LODWORD(v14) = a1;
            sub_6AB20(*(double *)&v14, v28, v27, v42, HIDWORD(v42), &v44);
LABEL_69:
            v16 = v44;
            a4 = (int *)(v26 + 8);
            if ( !v44 )
              break;
            goto LABEL_18;
          case 'n':
            v34 = *a4++;
            v33 = v34;
            switch ( v12 )
            {
              case 1:
                *(_BYTE *)v33 = v43;
                break;
              case 2:
                *(_WORD *)v33 = v43;
                break;
              case 4:
              case 8:
                *(_DWORD *)v33 = v43;
                *(_DWORD *)(v33 + 4) = 0;
                break;
              default:
                *(_DWORD *)v33 = v43;
                break;
            }
            break;
          case 'o':
            v25 = 8;
            goto LABEL_63;
          case 'p':
            v32 = *a4++;
            if ( v32 )
              sub_6A6BC(a1, &v43, v8, v32, (unsigned int)v32, 16, v10, v14, HIDWORD(v14) | 0x88);
            else
              sub_6A520(a1, (int *)&v43, v8, "(nil)", v10, -1, SBYTE4(v14));
            break;
          case 's':
            v35 = (const char *)*a4++;
            sub_6A520(a1, (int *)&v43, v8, v35, v10, v14, SBYTE4(v14));
            break;
          case 'u':
            v25 = 10;
            goto LABEL_63;
          case 'x':
LABEL_62:
            v25 = 16;
LABEL_63:
            HIDWORD(v14) |= 0x80u;
            switch ( v12 )
            {
              case 1:
                v30 = *(unsigned __int8 *)a4++;
                break;
              case 2:
                v30 = *(unsigned __int16 *)a4++;
                break;
              case 4:
              case 8:
                v31 = (__int64 *)(((unsigned int)a4 + 7) & 0xFFFFFFF8);
                a4 = (int *)(v31 + 1);
                v30 = *v31;
                break;
              case 7:
                LODWORD(v30) = *a4++;
                v30 = (int)v30;
                break;
              default:
                v30 = (unsigned int)*a4++;
                break;
            }
            sub_6A6BC(a1, &v43, v8, v25, v30, v25, v10, v14, HIDWORD(v14));
            break;
          default:
            break;
        }
        v7 = 0;
        v11 = *v13;
        v10 = 0;
        v12 = 0;
        ++v13;
        v14 = 0xFFFFFFFFLL;
        continue;
      default:
        if ( v11 == 37 )
        {
          v7 = 1;
        }
        else
        {
          v22 = v43++;
          if ( v43 < v8 )
            *(_BYTE *)(a1 + v22) = v11;
          v7 = 0;
        }
        goto LABEL_16;
    }
  }
LABEL_17:
  v16 = v44;
LABEL_18:
  v17 = v43;
  if ( v43 >= v8 )
  {
    if ( v8 )
      *(_BYTE *)(a1 + v8 - 1) = 0;
  }
  else
  {
    *(_BYTE *)(a1 + v43) = 0;
  }
  if ( v16 )
  {
    v18 = 75;
    goto LABEL_122;
  }
  if ( v17 > 0x7FFFFFFE )
  {
    v18 = 34;
LABEL_122:
    v41 = _errno_location();
    v19 = -1;
    *v41 = v18;
    return v19;
  }
  return v17;
}

//----- (0006C054) --------------------------------------------------------
unsigned int sub_6C054(int a1, unsigned int a2, unsigned __int8 *a3, ...)
{
  va_list varg_r3; // [sp+1Ch] [bp+10h] BYREF

  va_start(varg_r3, a3);
  return sub_6B6F8(a1, a2, a3, (int *)varg_r3);
}

//----- (0006C0B8) --------------------------------------------------------
int __fastcall sub_6C0B8(int a1)
{
  int v2; // r2
  int v3; // r9
  int v4; // r2
  int v6; // r0
  int v7; // [sp+4h] [bp-10h]

  if ( a1 < 0 )
    sub_6ECC0("socket.c", 81, 0, "(int)fd >= 0");
  v2 = dword_B7D7C;
  if ( dword_B7D7C == -1 )
  {
    if ( sysconf(4) > 25 || sysconf(4) > 9 )
      v2 = sysconf(4) <= 25 ? sysconf(4) - 10 : 16;
    else
      v2 = 0;
    dword_B7D7C = v2;
    if ( debug > 0 )
    {
      v7 = v2;
      v6 = sysconf(4);
      sub_64D28("move_fd: estimated max descriptors: %d, initial socket boundary: %d\n", v6, v7);
      v2 = dword_B7D7C;
    }
  }
  while ( 1 )
  {
    if ( a1 >= v2 )
      return a1;
    v3 = fcntl(a1, 0);
    if ( v3 != -1 )
      break;
    v4 = dword_B7D7C;
    if ( dword_B7D7C < 10 )
      v4 = 10;
    v2 = v4 - 10;
    dword_B7D7C = v2;
    if ( debug > 0 )
    {
      sub_64D28("move_fd: selecting new socket boundary: %d\n", v2);
      v2 = dword_B7D7C;
    }
    if ( v2 <= 0 )
      return a1;
  }
  close(a1);
  return v3;
}
// B7D7C: using guessed type int dword_B7D7C;
// 108D74: using guessed type int debug;

//----- (0006C26C) --------------------------------------------------------
int __fastcall sub_6C26C(int a1)
{
  int result; // r0

  result = fcntl(a1, 4, 2048);
  if ( result < 0 )
  {
    sub_64E00(3, "fcntl(O_NONBLOCK) fails on fd #%d: %m", a1);
    exit(1);
  }
  return result;
}

//----- (0006C2E8) --------------------------------------------------------
_BYTE *__fastcall sub_6C2E8(unsigned __int16 *a1)
{
  int *v2; // r6
  int v3; // r8
  _BYTE *v4; // r4
  int v5; // r9
  int v6; // r3
  int v8; // r9
  _BYTE *v9; // r11
  char v10; // [sp+Ch] [bp-10h]

  v2 = _errno_location();
  v3 = *v2;
  v4 = &lib_stringbuf[128 * lib_nextbuf];
  v5 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v4, 0, 0x80u);
  lib_nextbuf = v5;
  if ( !a1 )
  {
    sub_6D4DC(v4, "(null)", 128);
    goto LABEL_6;
  }
  v6 = *a1;
  if ( v6 == 2 )
    goto LABEL_10;
  if ( v6 != 10 )
  {
    if ( *a1 )
    {
      sub_6C054((int)v4, 0x80u, "(socktoa unknown family %d)", v6);
      goto LABEL_6;
    }
LABEL_10:
    inet_ntop(2, a1 + 2, v4, 0x80u);
    goto LABEL_6;
  }
  inet_ntop(10, a1 + 4, v4, 0x80u);
  v8 = *((_DWORD *)a1 + 6);
  if ( v8 && !strchr(v4, 37) )
  {
    v10 = lib_nextbuf;
    v9 = &lib_stringbuf[128 * lib_nextbuf];
    memset(v9, 0, 0x80u);
    lib_nextbuf = (v10 + 1) & 0xF;
    sub_6C054((int)v9, 0x80u, "%s%%%lu", v4, v8);
    v4 = v9;
    v9[127] = 0;
  }
LABEL_6:
  *v2 = v3;
  return v4;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0006C47C) --------------------------------------------------------
_BYTE *__fastcall sub_6C47C(unsigned __int16 *a1)
{
  int *v2; // r7
  int v3; // r10
  _BYTE *v4; // r11
  _BYTE *v5; // r5
  int v6; // r4
  int v7; // r3
  char *v8; // r2

  v2 = _errno_location();
  v3 = *v2;
  v4 = sub_6C2E8(a1);
  v5 = &lib_stringbuf[128 * lib_nextbuf];
  v6 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v5, 0, 0x80u);
  v7 = *a1;
  lib_nextbuf = v6;
  if ( v7 == 10 )
    v8 = "[%s]:%hu";
  else
    v8 = "%s:%hu";
  sub_6C054((int)v5, 0x80u, (unsigned __int8 *)v8, v4, (unsigned __int16)__rev16(a1[1]));
  *v2 = v3;
  return v5;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0006C568) --------------------------------------------------------
int __fastcall sub_6C568(unsigned __int16 *a1)
{
  int v1; // r12
  unsigned __int16 v2; // r3
  unsigned __int16 *v3; // r0
  unsigned int v4; // lr
  char *v5; // r2
  unsigned int i; // r1
  __int16 v7; // t1

  v1 = *a1;
  v2 = 37 * *(unsigned __int8 *)a1 + *((unsigned __int8 *)a1 + 1);
  if ( v1 == 2 )
  {
    v3 = a1 + 2;
    v4 = 4;
  }
  else
  {
    if ( v1 != 10 )
      return v2;
    v3 = a1 + 4;
    v4 = 16;
  }
  v5 = (char *)v3 - 1;
  for ( i = 0; i < v4; ++i )
  {
    v7 = (unsigned __int8)*++v5;
    v2 = v7 + 37 * v2;
  }
  return v2;
}

//----- (0006C60C) --------------------------------------------------------
int __fastcall sub_6C60C(int *a1)
{
  int v2; // r1
  int v3; // r2
  int v4; // r3
  int v5; // r0
  int v6; // r1
  int v7; // r2
  int v9; // [sp+0h] [bp-4Ch] BYREF
  _DWORD v10[6]; // [sp+4h] [bp-48h] BYREF
  _DWORD v11[10]; // [sp+1Ch] [bp-30h] BYREF

  v2 = a1[1];
  v3 = a1[2];
  v4 = a1[3];
  v5 = *a1;
  memset(&v11[7], 0, 12);
  v11[0] = v5;
  v11[1] = v2;
  v11[2] = v3;
  v11[3] = v4;
  v6 = a1[5];
  v7 = a1[6];
  v11[4] = a1[4];
  v11[5] = v6;
  v11[6] = v7;
  sub_74CE8(v10, v11);
  if ( sub_749DC(v10, &v9) )
    return -1;
  else
    return v9;
}

//----- (0006C6B8) --------------------------------------------------------
int sub_6C6B8()
{
  int v1; // [sp+4h] [bp-8h]

  sub_64244();
  ssl_init_done = 1;
  return v1;
}
// 6C6E4: variable 'v1' is possibly undefined
// 1095B0: using guessed type int ssl_init_done;

//----- (0006C714) --------------------------------------------------------
int sub_6C714()
{
  int result; // r0
  int v1; // r7

  result = OpenSSL_version_num();
  if ( ((result ^ 0x1010104F) & 0xFFFFF00F) != 0 )
  {
    v1 = result;
    sub_64E00(4, "OpenSSL version mismatch. Built against %lx, you have %lx", 269488207, result);
    result = _fprintf_chk(stderr, 1, "OpenSSL version mismatch. Built against %lx, you have %lx\n", 269488207, v1);
  }
  if ( !ssl_init_done )
    return sub_6C6B8();
  return result;
}
// B71C: using guessed type int OpenSSL_version_num(void);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 1095B0: using guessed type int ssl_init_done;

//----- (0006C7EC) --------------------------------------------------------
const char *__fastcall sub_6C7EC(int a1)
{
  const char *result; // r0

  if ( !ssl_init_done )
    sub_6C6B8();
  result = (const char *)OBJ_nid2sn(a1);
  if ( a1 == 894 )
  {
    if ( debug )
      _fprintf_chk(stderr, 1, "%s:%d:%s():%s:nid\n", "ssl_init.c", 223, "keytype_name", "AES128CMAC");
    return "AES128CMAC";
  }
  else if ( !result )
  {
    return "(unknown key type)";
  }
  return result;
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// 108D74: using guessed type int debug;
// 1095B0: using guessed type int ssl_init_done;

//----- (0006C910) --------------------------------------------------------
int __fastcall sub_6C910(unsigned __int8 *a1, int *a2)
{
  int v4; // r4
  _BYTE *v5; // r6
  int v6; // r4
  const __int32_t **v7; // r0
  _BYTE *v8; // r3
  int v9; // t1
  int v10; // r4
  int v11; // r0
  int digestbyname; // r0
  unsigned int v13; // r0
  unsigned int v14; // r6
  int v15; // r3
  struct _IO_FILE *v16; // r5
  const char *v17; // r0
  int v18; // r0
  const char *v19; // r0
  struct _IO_FILE *v21; // r8
  const char *v22; // r0
  int v23; // r0
  const char *v24; // r0

  if ( !ssl_init_done )
    sub_6C6B8();
  v4 = lib_nextbuf;
  v5 = &lib_stringbuf[128 * lib_nextbuf];
  memset(v5, 0, 0x80u);
  lib_nextbuf = ((_BYTE)v4 + 1) & 0xF;
  sub_6D4DC(v5, a1, 128);
  v6 = (unsigned __int8)lib_stringbuf[128 * v4];
  if ( v6 )
  {
    v7 = _ctype_toupper_loc();
    v8 = v5;
    do
    {
      *v8 = (*v7)[v6];
      v9 = (unsigned __int8)*++v8;
      v6 = v9;
    }
    while ( v9 );
  }
  v10 = OBJ_sn2nid(v5);
  if ( v10 )
  {
LABEL_10:
    if ( a2 )
      goto LABEL_11;
    return v10;
  }
  if ( !strcmp("AES128CMAC", v5) )
  {
    v10 = 894;
    if ( debug )
      _fprintf_chk(stderr, 1, "%s:%d:%s():%s:key\n", "ssl_init.c", 135, "keytype_from_text", "AES128CMAC");
    goto LABEL_10;
  }
  if ( (*_ctype_tolower_loc())[*a1] == 109 )
  {
    v10 = 4;
    if ( a2 )
    {
LABEL_11:
      v11 = OBJ_nid2sn(v10);
      digestbyname = EVP_get_digestbyname(v11);
      if ( digestbyname && (v13 = EVP_MD_size(digestbyname), v14 = v13, (v15 = v13) != 0) )
      {
        if ( v13 > 0x14 )
        {
          v16 = stderr;
          v17 = sub_6C7EC(v10);
          _fprintf_chk(v16, 1, "key type %s %u octet digests are too big, max %lu\n", v17, v14, 20);
          v18 = v10;
          v10 = 0;
          v19 = sub_6C7EC(v18);
          sub_64E00(3, "key type %s %u octet digests are too big, max %lu", v19, v14, 20);
          return v10;
        }
      }
      else
      {
        if ( v10 != 894 )
        {
          v21 = stderr;
          v22 = sub_6C7EC(v10);
          _fprintf_chk(v21, 1, "key type %s is not supported by OpenSSL\n", v22);
          v23 = v10;
          v10 = 0;
          v24 = sub_6C7EC(v23);
          sub_64E00(3, "key type %s is not supported by OpenSSL\n", v24);
          return v10;
        }
        if ( debug )
          _fprintf_chk(stderr, 1, "%s:%d:%s():%s:len\n", "ssl_init.c", 164, "keytype_from_text", "AES128CMAC");
        v15 = 16;
      }
      *a2 = v15;
    }
  }
  return v10;
}
// B5A8: using guessed type int __fastcall EVP_get_digestbyname(_DWORD);
// B680: using guessed type int __fastcall EVP_MD_size(_DWORD);
// BCBC: using guessed type int __fastcall OBJ_sn2nid(_DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// BF08: using guessed type int __fastcall OBJ_nid2sn(_DWORD);
// 108D70: using guessed type int lib_nextbuf;
// 108D74: using guessed type int debug;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];
// 1095B0: using guessed type int ssl_init_done;

//----- (0006CC40) --------------------------------------------------------
char *__fastcall sub_6CC40(int a1)
{
  const char *v1; // r0
  char v3[76]; // [sp+0h] [bp-54h] BYREF

  v1 = sub_6C7EC(a1);
  sub_6C054((int)v3, 0x4Cu, "%.64s Password: ", v1);
  return getpass(v3);
}

//----- (0006CCB0) --------------------------------------------------------
_BYTE *__fastcall sub_6CCB0(int a1, const char *a2, int *a3, int a4)
{
  int *v5; // r4
  int *v6; // r7
  _BYTE *v7; // r9
  int v8; // r6
  _BYTE *v9; // r10
  int v10; // r6
  const char *v11; // r3
  const char *v12; // r2
  unsigned int v13; // r0
  const char *v15; // r3
  int *v17; // [sp+14h] [bp-18h]
  int v18; // [sp+18h] [bp-14h]

  v5 = a3;
  v6 = &a3[3 * a4];
  v17 = _errno_location();
  v18 = *v17;
  v7 = &lib_stringbuf[128 * lib_nextbuf];
  v8 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  v9 = v7 + 128;
  memset(v7, 0, 0x80u);
  lib_nextbuf = v8;
  v10 = (int)v7;
  v11 = (const char *)&unk_97F7C;
  while ( 1 )
  {
    v12 = (const char *)v5[1];
    if ( (a1 & *v5) == 0 )
      v12 = (const char *)v5[2];
    if ( !v12 )
      goto LABEL_7;
    v13 = sub_6C054(v10, (unsigned int)&v9[-v10], (unsigned __int8 *)"%s%s", v11, v12);
    if ( v13 >= (unsigned int)&v9[-v10] )
      break;
    v10 += v13;
    v11 = a2;
LABEL_7:
    v5 += 3;
    if ( v6 == v5 )
      return v7;
  }
  if ( a3 == &off_B4C48 )
  {
    v15 = "peer_st";
  }
  else if ( a3 == (int *)&unk_B4C84 )
  {
    v15 = "kern_st";
  }
  else
  {
    v15 = (const char *)&unk_97F7C;
  }
  sub_6C054((int)v7, 0x80u, "decode_bitflags(%s) can't decode 0x%x in %d bytes", v15, a1, 128);
  *v17 = v18;
  return v7;
}
// B4C48: using guessed type int off_B4C48;
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0006CE6C) --------------------------------------------------------
_BYTE *__fastcall sub_6CE6C(int a1, _DWORD *a2)
{
  _DWORD *v2; // r4
  int v4; // r3
  int v5; // t1
  _BYTE *v6; // r6
  int v7; // r7
  const char *v8; // r3

  v2 = a2;
  if ( *a2 != -1 )
  {
    if ( *a2 == a1 )
      return (_BYTE *)v2[1];
    while ( 1 )
    {
      v5 = v2[3];
      v2 += 3;
      v4 = v5;
      if ( v5 == -1 )
        break;
      if ( v4 == a1 )
        return (_BYTE *)v2[1];
    }
  }
  v6 = &lib_stringbuf[128 * lib_nextbuf];
  v7 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v6, 0, 0x80u);
  v8 = (const char *)v2[1];
  lib_nextbuf = v7;
  sub_6C054((int)v6, 0x80u, "%s_%d", v8, a1);
  return v6;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0006CF4C) --------------------------------------------------------
_BYTE *__fastcall sub_6CF4C(int a1)
{
  _BYTE *v2; // r5
  int v3; // r4
  const char *v4; // r3

  v2 = &lib_stringbuf[128 * lib_nextbuf];
  v3 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v2, 0, 0x80u);
  lib_nextbuf = v3;
  if ( a1 == 1 )
    v4 = byte_97F7C;
  else
    v4 = "s";
  sub_6C054((int)v2, 0x80u, "%d event%s", a1, v4);
  return v2;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0006D01C) --------------------------------------------------------
_BYTE *__fastcall sub_6D01C(int a1)
{
  return sub_6CCB0(a1, " ", (int *)&off_B4D44, 3);
}

//----- (0006D084) --------------------------------------------------------
_BYTE *__fastcall sub_6D084(int a1)
{
  return sub_6CCB0(a1, " ", &dword_B4D68, 13);
}
// B4D68: using guessed type int dword_B4D68;

//----- (0006D0EC) --------------------------------------------------------
_BYTE *__fastcall sub_6D0EC(int a1)
{
  return sub_6CCB0(a1, " ", &dword_B4C84, 16);
}
// B4C84: using guessed type int dword_B4C84;

//----- (0006D154) --------------------------------------------------------
_BYTE *__fastcall sub_6D154(int a1, int a2)
{
  _BYTE *v4; // r9
  int v5; // r4
  const char *v7; // r6
  const char *v8; // r4
  const char *v9; // r8
  const char *v10; // r0
  const char *v11; // r4
  const char *v12; // r0
  const char *v13; // r8
  const char *v14; // r4
  const char *v15; // r0
  int v16; // r5
  size_t v17; // r4
  const char *v18; // r0

  v4 = &lib_stringbuf[128 * lib_nextbuf];
  v5 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v4, 0, 0x80u);
  lib_nextbuf = v5;
  switch ( a1 )
  {
    case 2:
      v13 = sub_6CCB0(BYTE1(a2), ", ", &off_B4C48, 5);
      v14 = sub_6CE6C((a2 >> 8) & 7, &dword_B4F90);
      if ( (unsigned __int8)a2 >> 4 )
        v15 = sub_6CF4C((unsigned __int8)a2 >> 4);
      else
        v15 = "no events";
      sub_6C054((int)v4, 0x80u, (unsigned __int8 *)"%s, %s, %s", v13, v14, v15);
      v16 = a2 & 0xF;
      if ( v16 )
      {
        v17 = strlen(v4);
        v18 = sub_6CE6C(v16, &dword_B4FFC);
        sub_6C054((int)&v4[v17], 128 - v17, ", %s", v18);
      }
      break;
    case 3:
      if ( (unsigned __int8)a2 >> 4 )
        v11 = sub_6CF4C((unsigned __int8)a2 >> 4);
      else
        v11 = "no events";
      v12 = sub_6CE6C(a2 & 0xF, &dword_B50BC);
      sub_6C054((int)v4, 0x80u, (unsigned __int8 *)"%s, %s", v11, v12);
      break;
    case 1:
      v7 = sub_6CE6C((unsigned __int16)a2 >> 14, &dword_B4E04);
      v8 = sub_6CE6C(((unsigned int)a2 >> 8) & 0x3F, &dword_B4E40);
      if ( (unsigned __int8)a2 >> 4 )
        v9 = sub_6CF4C((unsigned __int8)a2 >> 4);
      else
        v9 = "no events";
      v10 = sub_6CE6C(a2 & 0xF, &dword_B4EC4);
      sub_6C054((int)v4, 0x80u, "%s, %s, %s, %s", v7, v8, v9, v10);
      break;
  }
  return v4;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B4C48: using guessed type int off_B4C48;
// B4E04: using guessed type _DWORD dword_B4E04;
// B4E40: using guessed type _DWORD dword_B4E40;
// B4EC4: using guessed type _DWORD dword_B4EC4;
// B4F90: using guessed type _DWORD dword_B4F90;
// B4FFC: using guessed type _DWORD dword_B4FFC;
// B50BC: using guessed type _DWORD dword_B50BC;
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (0006D3C4) --------------------------------------------------------
_BYTE *__fastcall sub_6D3C4(int a1)
{
  if ( (a1 & 0x80) != 0 )
    return sub_6CE6C(a1 & 0xFFFFFF7F, &dword_B4FFC);
  if ( (a1 & 0x100) != 0 )
    return sub_6CE6C(a1 & 0xFFFFFEFF, &dword_B511C);
  return sub_6CE6C(a1, &dword_B4EC4);
}
// B4EC4: using guessed type _DWORD dword_B4EC4;
// B4FFC: using guessed type _DWORD dword_B4FFC;
// B511C: using guessed type _DWORD;

//----- (0006D480) --------------------------------------------------------
_BYTE *__fastcall sub_6D480(int a1)
{
  return sub_6CE6C(a1, &dword_B50BC);
}
// B50BC: using guessed type _DWORD;

//----- (0006D4DC) --------------------------------------------------------
int __fastcall sub_6D4DC(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r12
  _BYTE *v4; // lr
  int v5; // r2
  unsigned __int8 *v6; // r3

  if ( !a3 )
  {
    v6 = a2;
LABEL_8:
    while ( *v6++ )
      ;
    return v6 - a2 - 1;
  }
  v3 = a2;
  v4 = &a1[a3 - 1];
  while ( 1 )
  {
    v6 = v3 + 1;
    if ( v4 == a1 )
      break;
    v5 = *v3++;
    *a1++ = v5;
    if ( !v5 )
      return v6 - a2 - 1;
  }
  *v4 = 0;
  v6 = v3 + 1;
  if ( *v3 )
    goto LABEL_8;
  return v6 - a2 - 1;
}

//----- (0006D58C) --------------------------------------------------------
int __fastcall sub_6D58C(unsigned __int8 *a1, char *s, int a3)
{
  unsigned __int8 *v3; // r4
  unsigned __int8 *v4; // r3
  unsigned __int8 *v5; // lr
  int v7; // r4
  int v8; // r3
  char *v9; // r12
  bool v10; // zf
  int v11; // t1

  if ( !a3 )
  {
    v7 = 0;
    goto LABEL_17;
  }
  v3 = a1;
  if ( *a1 )
  {
    v4 = a1 + 1;
    v5 = &a1[a3];
    do
    {
      a1 = v4;
      if ( v5 == v4 )
        break;
    }
    while ( *v4++ );
    v7 = a1 - v3;
    a3 -= v7;
    if ( a3 )
      goto LABEL_7;
LABEL_17:
    v7 += strlen(s);
    return v7;
  }
  v7 = *a1;
LABEL_7:
  LOBYTE(v8) = *s;
  v9 = s;
  if ( *s )
  {
    do
    {
      v10 = a3 == 1;
      if ( a3 != 1 )
      {
        *a1 = v8;
        --a3;
      }
      v11 = (unsigned __int8)*++s;
      v8 = v11;
      if ( !v10 )
        ++a1;
    }
    while ( v8 );
    v7 += s - v9;
  }
  *a1 = 0;
  return v7;
}

//----- (0006D67C) --------------------------------------------------------
int __fastcall sigint_handler(int result)
{
  if ( off_107228 )
    return ((int (__fastcall *)(int))off_107228)(result);
  return result;
}
// 107228: using guessed type int (__fastcall *off_107228)(_DWORD, _DWORD);

//----- (0006D6F0) --------------------------------------------------------
int __fastcall sub_6D6F0(int a1, void (*a2)(int))
{
  int result; // r0
  struct sigaction s; // [sp+4h] [bp-120h] BYREF
  struct sigaction oact; // [sp+90h] [bp-94h] BYREF

  memset(&s, 0, sizeof(s));
  sigemptyset(&s.sa_mask);
  s.sa_handler = a2;
  if ( a1 == 29 )
    s.sa_flags = 0x10000000;
  while ( 1 )
  {
    result = sigaction(a1, &s, &oact);
    if ( result != -1 )
      break;
    if ( *_errno_location() != 4 )
    {
      perror("sigaction");
      exit(1);
    }
  }
  return result;
}

//----- (0006D7B0) --------------------------------------------------------
int __fastcall sub_6D7B0(int (__fastcall *a1)(_DWORD, _DWORD))
{
  int result; // r0

  if ( a1 )
  {
    off_107228 = a1;
    return sub_6D6F0(2, (void (*)(int))sigint_handler);
  }
  else
  {
    result = sub_6D6F0(2, 0);
    off_107228 = 0;
  }
  return result;
}
// 107228: using guessed type int (__fastcall *off_107228)(_DWORD, _DWORD);

//----- (0006D854) --------------------------------------------------------
__int64 *__fastcall sub_6D854(__int64 *a1, unsigned __int8 *a2, unsigned __int8 **a3, int a4)
{
  const unsigned __int16 *v8; // r8
  unsigned __int8 *v9; // r1
  int v10; // r3
  unsigned __int8 *v11; // r4
  int v12; // r9
  int v13; // lr
  int v14; // r12
  int v15; // t1
  int v16; // r12
  __int64 v18; // r2
  __int64 v19; // [sp+10h] [bp-14h]

  v8 = *_ctype_b_loc();
  v9 = a2;
  do
  {
    v10 = *v9;
    v11 = v9++;
    v12 = v8[v10] & 0x2000;
  }
  while ( (v8[v10] & 0x2000) != 0 );
  if ( v10 == 45 )
  {
    v11 = v9;
    v12 = 1;
  }
  else if ( v10 == 43 )
  {
    v11 = v9;
  }
  if ( a4 )
  {
    if ( a4 == 16 )
    {
      if ( *v11 == 48 && (*_ctype_toupper_loc())[v11[1]] == 88 )
        v11 += 2;
    }
    else if ( (unsigned int)(a4 - 3) > 0x21 )
    {
      *_errno_location() = 34;
      *a1 = -1;
      return a1;
    }
  }
  else if ( *v11 == 48 )
  {
    if ( (*_ctype_toupper_loc())[v11[1]] == 88 )
    {
      v11 += 2;
      a4 = 16;
    }
    else
    {
      ++v11;
      a4 = 8;
    }
  }
  else
  {
    a4 = 10;
  }
  v13 = 0;
  v19 = 0;
  v14 = *v11;
  if ( !*v11 )
    goto LABEL_22;
  do
  {
    if ( (v8[v14] & 0x800) != 0 )
    {
      v16 = (unsigned __int8)(v14 - 48);
    }
    else if ( (v8[v14] & 0x100) != 0 )
    {
      v16 = (unsigned __int8)(v14 - 55);
    }
    else
    {
      if ( (v8[v14] & 0x200) == 0 )
        break;
      v16 = (unsigned __int8)(v14 - 87);
    }
    if ( a4 <= v16 )
      break;
    v13 = 1;
    v19 = a4 * v19 + (unsigned int)v16;
    v15 = *++v11;
    v14 = v15;
  }
  while ( v15 );
  if ( !v13 )
LABEL_22:
    *_errno_location() = 22;
  if ( a3 )
    *a3 = v11;
  if ( v12 )
  {
    HIDWORD(v18) = ~HIDWORD(v19);
    if ( !(_DWORD)v19 )
      HIDWORD(v18) = -HIDWORD(v19);
    LODWORD(v18) = -(int)v19;
    v19 = v18;
  }
  *a1 = v19;
  return a1;
}

//----- (0006DA84) --------------------------------------------------------
int __fastcall sub_6DA84(_QWORD *a1, _QWORD *a2)
{
  return (*a2 < *a1) - (*a1 < *a2);
}

//----- (0006DAF4) --------------------------------------------------------
int __fastcall sub_6DAF4(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // r4
  unsigned __int64 v3; // r0
  bool v4; // cf
  _BOOL4 v5; // r0
  int v6; // r1

  v2 = *a1;
  v3 = *a2;
  v4 = v2 >= v3;
  v5 = v2 > v3;
  v6 = !v4;
  return v5 - v6;
}

//----- (0006DBC0) --------------------------------------------------------
int *__fastcall sub_6DBC0(int *result, _DWORD *a2, _DWORD *a3)
{
  int v3; // r4
  bool v4; // cf
  int v5; // r3
  int v6; // r1

  v3 = a3[1];
  v4 = *a2 >= *a3;
  v5 = *a2 - *a3;
  v6 = a2[1];
  *result = v5;
  result[1] = v6 - (v3 + !v4);
  return result;
}

//----- (0006DC24) --------------------------------------------------------
_QWORD *__fastcall sub_6DC24(_QWORD *result, _QWORD *a2, int a3)
{
  *result = *a2 + a3;
  return result;
}

//----- (0006DCDC) --------------------------------------------------------
_QWORD *__fastcall sub_6DCDC(_QWORD *result, _QWORD *a2, unsigned int a3)
{
  *result = *a2 + a3;
  return result;
}

//----- (0006DD38) --------------------------------------------------------
_QWORD *__fastcall sub_6DD38(_QWORD *result, _QWORD *a2, unsigned int a3)
{
  *result = *a2 - a3;
  return result;
}

//----- (0006DD94) --------------------------------------------------------
int __fastcall sub_6DD94(pthread_t *a1)
{
  int v2; // r0
  int v3; // r3
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r5
  int result; // r0
  size_t v9; // r5
  int v10; // r0
  size_t v11; // r7
  char *v12; // r0
  char *v13; // r0
  char *v14; // r0
  int v15; // [sp+8h] [bp-138h] BYREF
  size_t stacksize; // [sp+Ch] [bp-134h] BYREF
  __int64 v17; // [sp+10h] [bp-130h] BYREF
  pthread_attr_t v18; // [sp+18h] [bp-128h] BYREF
  sigset_t v19; // [sp+3Ch] [bp-104h] BYREF
  sigset_t v20; // [sp+BCh] [bp-84h] BYREF

  a1[2] = 0;
  if ( sub_68F08(&v17, &v15) )
  {
    sub_64E00(3, "start_blocking_thread: pipe_socketpair() %m");
    exit(1);
  }
  a1[13] = sub_6C0B8(v17);
  v2 = sub_6C0B8(SHIDWORD(v17));
  v3 = v15;
  a1[14] = v2;
  v4 = a1[13];
  a1[15] = v3;
  v5 = fcntl(v4, 3, 0);
  if ( v5 == -1 )
  {
    sub_64E00(3, "start_blocking_thread: fcntl(F_GETFL) %m");
    exit(1);
  }
  if ( fcntl(a1[13], 4, v5 | 0x800) == -1 )
  {
    sub_64E00(3, "start_blocking_thread: fcntl(F_SETFL, O_NONBLOCK) %m");
    exit(1);
  }
  addremove_io_fd(a1[13], a1[15], 0);
  pthread_attr_init(&v18);
  pthread_attr_setdetachstate(&v18, 1);
  v6 = pthread_attr_getstacksize(&v18, &stacksize);
  if ( v6 )
  {
    v13 = strerror(v6);
    sub_64E00(3, "start_blocking_thread: pthread_attr_getstacksize() -> %s", v13);
  }
  else
  {
    if ( stacksize < 0x10000 )
    {
      v9 = 0x10000;
    }
    else
    {
      if ( stacksize <= 0x40000 )
        goto LABEL_7;
      v9 = 0x40000;
    }
    v10 = pthread_attr_setstacksize(&v18, v9);
    if ( v10 )
    {
      v11 = stacksize;
      v12 = strerror(v10);
      sub_64E00(3, "start_blocking_thread: pthread_attr_setstacksize(0x%lx -> 0x%lx) -> %s", v11, v9, v12);
    }
  }
LABEL_7:
  a1[2] = (pthread_t)sub_63BA4(0, 4u, 0, 1);
  sigemptyset(&v20);
  sigaddset(&v20, 14);
  sigaddset(&v20, 10);
  sigaddset(&v20, 12);
  sigaddset(&v20, 1);
  sigaddset(&v20, 2);
  sigaddset(&v20, 3);
  sigaddset(&v20, 15);
  sigaddset(&v20, 7);
  sigemptyset(&v19);
  pthread_sigmask(0, &v20, &v19);
  v7 = pthread_create(a1 + 35, &v18, (void *(*)(void *))blocking_thread, a1);
  pthread_sigmask(2, &v19, 0);
  result = pthread_attr_destroy(&v18);
  if ( v7 )
  {
    v14 = strerror(v7);
    sub_64E00(3, "start_blocking_thread: pthread_create() -> %s", v14);
    exit(1);
  }
  a1[2] = (pthread_t)(a1 + 35);
  return result;
}
// 1095B4: using guessed type int (__fastcall *addremove_io_fd)(_DWORD, _DWORD, _DWORD);

//----- (0006E078) --------------------------------------------------------
int __fastcall sub_6E078(sem_t *a1, struct timespec *abstime)
{
  int v4; // r4

  if ( a1 )
  {
    while ( 1 )
    {
      if ( abstime )
      {
        v4 = sem_timedwait(a1, abstime);
        if ( v4 != -1 )
          return v4;
      }
      else
      {
        v4 = sem_wait(a1);
        if ( v4 != -1 )
          return v4;
      }
      if ( *_errno_location() != 4 )
        return v4;
    }
  }
  v4 = -1;
  *_errno_location() = 22;
  return v4;
}

//----- (0006E128) --------------------------------------------------------
int __fastcall sub_6E128(int a1, int a2)
{
  unsigned int v4; // r5
  int v5; // r8
  int v6; // r1
  int v7; // r9
  sem_t *v8; // r0
  int v9; // r1
  unsigned int v11; // r8
  unsigned int v12; // r3
  int v13; // r2

  sub_6E078(*(sem_t **)(a1 + 4), 0);
  v4 = *(_DWORD *)(a1 + 20);
  if ( v4 - *(_DWORD *)(a1 + 24) >= *(_DWORD *)(a1 + 16) )
  {
    v11 = *(_DWORD *)(a1 + 16) + 16;
    *(_DWORD *)(a1 + 12) = sub_63BA4(*(void **)(a1 + 12), 4 * v11, 0, 0);
    v12 = *(_DWORD *)(a1 + 16);
    if ( v11 > v12 )
    {
      v13 = 4 * v12;
      do
      {
        ++v12;
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + v13) = 0;
        v13 += 4;
      }
      while ( v11 != v12 );
    }
    v4 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v11;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 20) = v4;
  }
  v5 = *(_DWORD *)(a1 + 12);
  sub_8B8EC(v4, *(_DWORD *)(a1 + 16));
  if ( *(_DWORD *)(v5 + 4 * v6) )
    sub_6ECC0("work_thread.c", 219, 2, "((void *)0) == c->workitems[c->head_workitem % c->workitems_alloc]");
  v7 = *(_DWORD *)(a1 + 12);
  sub_8B8EC(v4, *(_DWORD *)(a1 + 16));
  v8 = *(sem_t **)(a1 + 4);
  *(_DWORD *)(v7 + 4 * v9) = a2;
  *(_DWORD *)(a1 + 20) = v4 + 1;
  sem_post(v8);
  sem_post(*(sem_t **)(a1 + 28));
  return 0;
}
// 6E184: variable 'v6' is possibly undefined
// 6E1A8: variable 'v9' is possibly undefined

//----- (0006E26C) --------------------------------------------------------
sem_t *__fastcall sub_6E26C(sem_t *a1, unsigned int value)
{
  if ( sem_init(a1, 0, value) )
    return 0;
  else
    return a1;
}

//----- (0006E2CC) --------------------------------------------------------
int __fastcall sub_6E2CC(int result)
{
  if ( dword_10722C )
  {
    if ( result )
      return sub_6E078((sem_t *)dword_10722C, 0);
    else
      return sem_post((sem_t *)dword_10722C);
  }
  return result;
}
// 10722C: using guessed type int dword_10722C;

//----- (0006E36C) --------------------------------------------------------
void __fastcall __noreturn sub_6E36C(void *a1)
{
  pthread_exit(a1);
}

//----- (0006E398) --------------------------------------------------------
void __fastcall __noreturn blocking_thread(int a1)
{
  void *v1; // r0

  v1 = (void *)sub_69588(a1);
  sub_6E36C(v1);
}

//----- (0006E3C8) --------------------------------------------------------
int __fastcall sub_6E3C8(int a1, int a2)
{
  int v4; // r8
  sem_t *v5; // r0
  int v6; // r0
  struct timespec v8; // [sp+4h] [bp+0h] BYREF

  v4 = clock_gettime(0, &v8);
  if ( v4 )
  {
    v4 = -1;
    sub_64E00(3, "worker_sleep: clock_gettime() failed: %m");
  }
  else
  {
    v5 = *(sem_t **)(a1 + 48);
    v8.tv_sec += a2;
    v6 = sub_6E078(v5, &v8);
    if ( v6 )
    {
      if ( v6 != -1 || *_errno_location() != 110 )
      {
        v4 = -1;
        sub_64E00(3, "worker_sleep: sem_timedwait: %m");
      }
    }
    else
    {
      return -1;
    }
  }
  return v4;
}

//----- (0006E4A8) --------------------------------------------------------
void sub_6E4A8()
{
  unsigned int v0; // r4
  int v1; // r3
  sem_t *v2; // r0

  if ( blocking_children_alloc )
  {
    v0 = 0;
    do
    {
      v1 = *(_DWORD *)(blocking_children + 4 * v0);
      if ( v1 )
      {
        v2 = *(sem_t **)(v1 + 48);
        if ( v2 )
          sem_post(v2);
      }
      ++v0;
    }
    while ( blocking_children_alloc > v0 );
  }
}
// 109598: using guessed type int blocking_children_alloc;
// 1095A8: using guessed type int blocking_children;

//----- (0006E544) --------------------------------------------------------
int __fastcall sub_6E544(int a1, size_t *a2, const void *a3)
{
  size_t v5; // r1
  size_t v7; // r9
  _DWORD *v8; // r0
  const void *v9; // r1
  size_t v10; // r3
  int v11; // r5
  size_t v12; // r7
  size_t v13; // lr
  size_t v14; // r12

  if ( !a2 )
    sub_6ECC0("work_thread.c", 302, 0, "hdr != ((void *)0)");
  if ( !a3 )
    sub_6ECC0("work_thread.c", 303, 0, "data != ((void *)0)");
  v5 = *a2;
  if ( *a2 <= 0x18 )
    return 1;
  v7 = v5 - 24;
  if ( !*(_DWORD *)(a1 + 8) )
  {
    if ( !dword_10722C )
      dword_10722C = (int)sub_6E26C(&stru_107230, 1u);
    *(_DWORD *)(a1 + 4) = sub_6E26C((sem_t *)(a1 + 76), 1u);
    *(_DWORD *)(a1 + 28) = sub_6E26C((sem_t *)(a1 + 92), 0);
    *(_DWORD *)(a1 + 48) = sub_6E26C((sem_t *)(a1 + 108), 0);
    sub_6DD94((pthread_t *)a1);
    v5 = *a2;
  }
  v8 = sub_63BA4(0, v5, 0, 0);
  v9 = a3;
  v10 = a2[1];
  v11 = (int)v8;
  v12 = a2[2];
  v13 = a2[3];
  *v8 = *a2;
  v8[1] = v10;
  v8[2] = v12;
  v8[3] = v13;
  v14 = a2[4];
  v8[5] = a2[5];
  v8[4] = v14;
  memcpy(v8 + 6, v9, v7);
  return sub_6E128(a1, v11);
}
// 10722C: using guessed type int dword_10722C;
// 107230: using guessed type sem_t stru_107230;

//----- (0006E6E8) --------------------------------------------------------
int __fastcall sub_6E6E8(int a1, int a2)
{
  unsigned int v4; // r5
  unsigned int v5; // r6
  int v6; // r9
  int v7; // r1
  int v8; // r9
  sem_t *v9; // r0
  int v10; // r1
  unsigned int v12; // r9
  unsigned int v13; // r3
  int v14; // r2

  sub_6E078(*(sem_t **)(a1 + 4), 0);
  v4 = *(_DWORD *)(a1 + 40);
  v5 = v4 - *(_DWORD *)(a1 + 44);
  if ( v5 >= *(_DWORD *)(a1 + 36) )
  {
    v12 = *(_DWORD *)(a1 + 36) + 4;
    *(_DWORD *)(a1 + 32) = sub_63BA4(*(void **)(a1 + 32), 4 * v12, 0, 0);
    v13 = *(_DWORD *)(a1 + 36);
    if ( v12 > v13 )
    {
      v14 = 4 * v13;
      do
      {
        ++v13;
        *(_DWORD *)(*(_DWORD *)(a1 + 32) + v14) = 0;
        v14 += 4;
      }
      while ( v12 != v13 );
    }
    v4 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = v12;
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 40) = v4;
  }
  v6 = *(_DWORD *)(a1 + 32);
  sub_8B8EC(v4, *(_DWORD *)(a1 + 36));
  if ( *(_DWORD *)(v6 + 4 * v7) )
    sub_6ECC0("work_thread.c", 255, 2, "((void *)0) == c->responses[c->head_response % c->responses_alloc]");
  v8 = *(_DWORD *)(a1 + 32);
  sub_8B8EC(v4, *(_DWORD *)(a1 + 36));
  v9 = *(sem_t **)(a1 + 4);
  *(_DWORD *)(v8 + 4 * v10) = a2;
  *(_DWORD *)(a1 + 40) = v4 + 1;
  sem_post(v9);
  if ( !v5 && write(*(_DWORD *)(a1 + 56), byte_97F7C, 1u) != 1 )
    sub_64E00(4, "async resolver: %s", "failed to notify main thread!");
  return 0;
}
// 6E744: variable 'v7' is possibly undefined
// 6E768: variable 'v10' is possibly undefined

//----- (0006E870) --------------------------------------------------------
int __fastcall sub_6E870(int a1)
{
  int v2; // r7
  unsigned int i; // r0
  unsigned int v4; // r1
  unsigned int v5; // r5
  int v6; // r6
  int v7; // r1
  int v8; // r6

LABEL_1:
  sub_6E078(*(sem_t **)(a1 + 28), 0);
  sub_6E078(*(sem_t **)(a1 + 4), 0);
  v2 = *(_DWORD *)(a1 + 20);
  for ( i = *(_DWORD *)(a1 + 24); ; i = v5 )
  {
    if ( v2 == i )
    {
      sem_post(*(sem_t **)(a1 + 4));
      goto LABEL_1;
    }
    v4 = *(_DWORD *)(a1 + 16);
    v5 = i + 1;
    v6 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 24) = i + 1;
    sub_8B8EC(i, v4);
    v8 = *(_DWORD *)(v6 + 4 * v7);
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v7) = 0;
    if ( v8 )
      break;
  }
  sem_post(*(sem_t **)(a1 + 4));
  if ( v8 == -1 )
  {
    sub_6E6E8(a1, -1);
    return 0;
  }
  return v8;
}
// 6E8D0: variable 'v7' is possibly undefined

//----- (0006E948) --------------------------------------------------------
int __fastcall sub_6E948(int a1)
{
  int v2; // r7
  unsigned int v3; // r5
  unsigned int v4; // r0
  int v5; // r6
  int v6; // r1
  int v7; // r11
  _BOOL4 v8; // r6
  sem_t *v10; // r0
  sem_t *v11; // r0
  sem_t *v12; // r0
  _BYTE buf[32]; // [sp+4h] [bp-28h] BYREF

  while ( read(*(_DWORD *)(a1 + 52), buf, 0x20u) == -1 && *_errno_location() == 4 )
    ;
  sub_6E078(*(sem_t **)(a1 + 4), 0);
  v2 = *(_DWORD *)(a1 + 40);
  v3 = *(_DWORD *)(a1 + 44);
  if ( v2 == v3 )
  {
    v7 = 0;
    sem_post(*(sem_t **)(a1 + 4));
  }
  else
  {
    do
    {
      v4 = v3;
      v5 = *(_DWORD *)(a1 + 32);
      ++v3;
      sub_8B8EC(v4, *(_DWORD *)(a1 + 36));
      v7 = *(_DWORD *)(v5 + 4 * v6);
      v8 = v2 != v3;
      *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4 * v6) = 0;
      if ( v7 )
        v8 = 0;
    }
    while ( v8 );
    *(_DWORD *)(a1 + 44) = v3;
    sem_post(*(sem_t **)(a1 + 4));
    if ( v7 == -1 )
    {
      v10 = *(sem_t **)(a1 + 4);
      *(_DWORD *)(a1 + 8) = 0;
      if ( v10 )
        sem_destroy(v10);
      v11 = *(sem_t **)(a1 + 28);
      *(_DWORD *)(a1 + 4) = 0;
      if ( v11 )
        sem_destroy(v11);
      v12 = *(sem_t **)(a1 + 48);
      *(_DWORD *)(a1 + 28) = 0;
      if ( v12 )
        sem_destroy(v12);
      *(_DWORD *)(a1 + 48) = 0;
      v7 = 0;
      addremove_io_fd(*(_DWORD *)(a1 + 52), *(_DWORD *)(a1 + 60), 1);
      close(*(_DWORD *)(a1 + 56));
      close(*(_DWORD *)(a1 + 52));
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 44) = 0;
      *(_DWORD *)(a1 + 56) = -1;
      *(_DWORD *)(a1 + 52) = -1;
      *(_DWORD *)a1 = 1;
    }
  }
  return v7;
}
// 6E9D4: variable 'v6' is possibly undefined
// 1095B4: using guessed type int (__fastcall *addremove_io_fd)(_DWORD, _DWORD, _DWORD);

//----- (0006EAE8) --------------------------------------------------------
int __fastcall sub_6EAE8(int a1)
{
  if ( *(_DWORD *)(a1 + 4) )
    return sub_6E128(a1, -1);
  else
    return 0;
}

//----- (0006EB58) --------------------------------------------------------
int __fastcall sub_6EB58(int *a1, int a2, unsigned __int8 *a3, int *a4)
{
  _BYTE *v5; // r4
  unsigned int v6; // r5
  signed int v7; // r0
  int v8; // r3
  int *v10; // r0

  if ( a1 && (v5 = (_BYTE *)*a1) != 0 && (v6 = a2 - (_DWORD)v5, a2 - (int)v5 > 0) )
  {
    v7 = sub_6B6F8(*a1, a2 - (_DWORD)v5, a3, a4);
    v8 = v7;
    if ( v7 > 0 )
    {
      if ( v7 >= v6 )
        v8 = 0;
      else
        v5 += v7;
    }
    *v5 = 0;
    *a1 = (int)v5;
  }
  else
  {
    v10 = _errno_location();
    v8 = -1;
    *v10 = 22;
  }
  return v8;
}

//----- (0006EC04) --------------------------------------------------------
int sub_6EC04(int *a1, int a2, unsigned __int8 *a3, ...)
{
  va_list varg_r3; // [sp+1Ch] [bp+10h] BYREF

  va_start(varg_r3, a3);
  return sub_6EB58(a1, a2, a3, (int *)varg_r3);
}

//----- (0006EC68) --------------------------------------------------------
int __fastcall sub_6EC68(int a1, int a2, int a3)
{
  return sub_66274(a1 - 1, a2 - 1, a3 - 1) + 1;
}

//----- (0006ECC0) --------------------------------------------------------
void __fastcall __noreturn sub_6ECC0(const char *a1, int a2, int a3, const char *a4)
{
  off_B7D80(a1, a2, a3, a4);
  abort();
}
// B7D80: using guessed type int (__fastcall *off_B7D80)(const char *a1, int a2, int a3, const char *a4);

//----- (0006ED00) --------------------------------------------------------
int (__fastcall *__fastcall sub_6ED00(
        int (__fastcall *result)(const char *a1, int a2, int a3, const char *a4)))(const char *a1, int a2, int a3, const char *a4)
{
  if ( result )
    off_B7D80 = result;
  else
    off_B7D80 = sub_6EE20;
  return result;
}
// B7D80: using guessed type int (__fastcall *off_B7D80)(const char *a1, int a2, int a3, const char *a4);

//----- (0006ED7C) --------------------------------------------------------
const char *__fastcall sub_6ED7C(int a1)
{
  const char *result; // r0

  switch ( a1 )
  {
    case 0:
      result = "REQUIRE";
      break;
    case 1:
      result = "ENSURE";
      break;
    case 2:
      result = "INSIST";
      break;
    case 3:
      result = "INVARIANT";
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0006EE20) --------------------------------------------------------
int __fastcall sub_6EE20(const char *a1, int a2, int a3, const char *a4)
{
  const char *v8; // r11
  struct _IO_FILE *v9; // r9
  const char *v10; // r10
  const char *v11; // r0
  int v12; // r4
  const void **v13; // r5
  int v14; // t1
  struct _IO_FILE *v15; // r9
  const char *v16; // r10
  const char *v17; // r0
  int v19; // [sp+20h] [bp-214h] BYREF
  const char *v20; // [sp+24h] [bp-210h] BYREF
  int v21; // [sp+28h] [bp-20Ch] BYREF
  _BYTE v22[512]; // [sp+2Ch] [bp-208h] BYREF

  if ( sub_6F058((int)v22, 128, (int)&v19) )
  {
    v15 = stderr;
    v16 = sub_6ED7C(a3);
    v17 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
    _fprintf_chk(v15, 1, "%s:%d: %s(%s) %s%s\n", a1, a2, v16, a4, v17, ".");
  }
  else
  {
    if ( v19 <= 0 )
      v8 = ".";
    else
      v8 = ", back trace";
    v9 = stderr;
    v10 = sub_6ED7C(a3);
    v11 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
    _fprintf_chk(v9, 1, "%s:%d: %s(%s) %s%s\n", a1, a2, v10, a4, v11, v8);
    if ( v19 > 0 )
    {
      v12 = 0;
      v13 = (const void **)&v21;
      do
      {
        v14 = (int)v13[1];
        ++v13;
        v20 = 0;
        if ( sub_6F1AC(v14, &v20, (int)&v21) )
          _fprintf_chk(stderr, 1, "#%d %p in ??\n", v12, *v13);
        else
          _fprintf_chk(stderr, 1, "#%d %p in %s()+0x%lx\n", v12, *v13, v20, v21);
        ++v12;
      }
      while ( v19 > v12 );
    }
  }
  return fflush(stderr);
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 107248: using guessed type int isc_msgcat;

//----- (0006F058) --------------------------------------------------------
int __fastcall sub_6F058(int a1, int a2, int a3)
{
  bool v3; // zf

  v3 = a3 == 0;
  if ( a3 )
    v3 = a1 == 0;
  if ( v3 )
    return 25;
  else
    return 27;
}

//----- (0006F0AC) --------------------------------------------------------
int __fastcall sub_6F0AC(int a1, _DWORD *a2, _DWORD *a3)
{
  if ( !a2 || *a2 )
    sub_6ECC0("./../lib/isc/backtrace.c", 217, 0, "addrp != ((void *)0) && *addrp == ((void *)0)");
  if ( !a3 || *a3 )
    sub_6ECC0("./../lib/isc/backtrace.c", 218, 0, "symbolp != ((void *)0) && *symbolp == ((void *)0)");
  return 41;
}
// 6F10C: conditional instruction was optimized away because r0.4>=0

//----- (0006F1AC) --------------------------------------------------------
int __fastcall sub_6F1AC(int a1, _DWORD *a2, int a3)
{
  _BOOL4 v3; // lr

  if ( !a2 )
    return 25;
  v3 = a3 == 0;
  if ( *a2 )
    v3 = 1;
  if ( !v3 )
    return 23;
  else
    return 25;
}

//----- (0006F2DC) --------------------------------------------------------
int __fastcall sub_6F2DC(const char *a1, int a2, int a3, int a4)
{
  _fprintf_chk(stderr, 1, "%s:%d: ", a1, a2);
  _vfprintf_chk(stderr, 1, a3, a4);
  fputc(10, stderr);
  return fflush(stderr);
}
// BAAC: using guessed type int __fastcall _vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0006F380) --------------------------------------------------------
int __fastcall sub_6F380(const char *a1, int a2, int a3, int a4)
{
  struct _IO_FILE *v8; // r10
  const char *v9; // r0

  v8 = stderr;
  v9 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 110, (int)"fatal error");
  _fprintf_chk(v8, 1, "%s:%d: %s: ", a1, a2, v9);
  _vfprintf_chk(stderr, 1, a3, a4);
  fputc(10, stderr);
  return fflush(stderr);
}
// BAAC: using guessed type int __fastcall _vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 107248: using guessed type int isc_msgcat;

//----- (0006F45C) --------------------------------------------------------
int (__fastcall *__fastcall sub_6F45C(
        int (__fastcall *result)(const char *a1, int a2, int a3, int a4)))(const char *a1, int a2, int a3, int a4)
{
  if ( result )
    off_B7D84 = result;
  else
    off_B7D84 = sub_6F2DC;
  return result;
}
// B7D84: using guessed type int (__fastcall *off_B7D84)(const char *a1, int a2, int a3, int a4);

//----- (0006F4D8) --------------------------------------------------------
int (__fastcall *__fastcall sub_6F4D8(
        int (__fastcall *result)(const char *a1, int a2, int a3, int a4)))(const char *a1, int a2, int a3, int a4)
{
  if ( result )
    off_B7D88 = result;
  else
    off_B7D88 = sub_6F380;
  return result;
}
// B7D88: using guessed type int (__fastcall *off_B7D88)(const char *a1, int a2, int a3, int a4);

//----- (0006F554) --------------------------------------------------------
int sub_6F554(const char *a1, int a2, int a3, ...)
{
  va_list varg_r3; // [sp+1Ch] [bp+10h] BYREF

  va_start(varg_r3, a3);
  return off_B7D84(a1, a2, a3, (int)varg_r3);
}
// B7D84: using guessed type int (__fastcall *off_B7D84)(const char *a1, int a2, int a3, int a4);

//----- (0006F5C8) --------------------------------------------------------
void __noreturn sub_6F5C8(const char *a1, int a2, int a3, ...)
{
  va_list varg_r3; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r3, a3);
  off_B7D88(a1, a2, a3, (int)varg_r3);
  abort();
}
// B7D88: using guessed type int (__fastcall *off_B7D88)(const char *a1, int a2, int a3, int a4);

//----- (0006F61C) --------------------------------------------------------
void __fastcall __noreturn sub_6F61C(const char *a1, int a2, const char *a3)
{
  const char *v6; // r0

  v6 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
  sub_6F5C8(a1, a2, (int)"RUNTIME_CHECK(%s) %s", a3, v6);
}
// 107248: using guessed type int isc_msgcat;

//----- (0006F69C) --------------------------------------------------------
int __fastcall sub_6F69C(int a1)
{
  FILE *v1; // r2

  v1 = *(FILE **)(a1 + 168);
  if ( v1 && fgets((char *)(a1 + 172), 63, v1) )
  {
    *(_DWORD *)(a1 + 236) = 0;
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 236) = 29;
    return 29;
  }
}

//----- (0006F718) --------------------------------------------------------
char *__fastcall sub_6F718(char *result, int a2, int a3, int a4)
{
  _DWORD *v5; // r1
  int v6; // r6
  int v7; // lr
  int v8; // r0
  int v9; // r1
  int v10; // r1

  v5 = (_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 4) = 0;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = 0;
  v5[4] = 0;
  *(_DWORD *)a2 = result;
  if ( result == (_BYTE *)&dword_0 + 2 )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  }
  else
  {
    if ( result != &byte_9[1] )
      sub_6ECC0("./../lib/isc/unix/interfaceiter.c", 143, 2, "0");
    v6 = *(_DWORD *)(a3 + 12);
    v7 = *(_DWORD *)(a3 + 16);
    v8 = *(_DWORD *)(a3 + 20);
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 8);
    v5[1] = v6;
    v5[2] = v7;
    v5[3] = v8;
    if ( *(_DWORD *)(a3 + 24) )
    {
      v10 = *(_DWORD *)(a3 + 24);
      return (char *)sub_74C28((_DWORD *)a2, v10);
    }
    result = (_BYTE *)(&stru_80F8 + 6);
    if ( (*(_DWORD *)(a3 + 8) & 0xC0FF) == 0x80FE )
    {
      v9 = (unsigned __int16)__rev16(*(unsigned __int16 *)(a3 + 10));
      if ( (_WORD)v9 )
      {
        result = (char *)sub_74C28((_DWORD *)a2, v9);
        *(_WORD *)(a2 + 6) = 0;
      }
      else if ( a4 )
      {
        result = (char *)if_nametoindex(a4);
        v10 = (int)result;
        if ( result )
          return (char *)sub_74C28((_DWORD *)a2, v10);
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0;
// 80F8: using guessed type Elf32_Rel;
// B244: using guessed type int __fastcall if_nametoindex(_DWORD);

//----- (0006F874) --------------------------------------------------------
int __fastcall sub_6F874(int a1)
{
  int v2; // r5
  unsigned __int16 *v3; // r3
  char *v4; // r6
  size_t v5; // r9
  size_t v6; // r2
  int v7; // r3
  bool v8; // zf
  int v9; // r2
  int v10; // r2
  int v11; // r2
  int v12; // r3
  int v13; // r5
  int v15; // r0
  char *v16; // r10
  char *v17; // r6
  char *v18; // r0
  int v19; // t1
  int v20; // r2
  char *v21; // r3
  char v22; // r1
  int v23; // [sp+1Ch] [bp-60h] BYREF
  int v24; // [sp+20h] [bp-5Ch] BYREF
  char v25; // [sp+24h] [bp-58h] BYREF
  char v26; // [sp+28h] [bp-54h] BYREF
  char v27; // [sp+2Bh] [bp-51h] BYREF
  int v28[4]; // [sp+2Ch] [bp-50h] BYREF
  char v29[20]; // [sp+3Ch] [bp-40h] BYREF
  char v30; // [sp+50h] [bp-2Ch] BYREF
  char v31; // [sp+51h] [bp-2Bh] BYREF
  char v32; // [sp+71h] [bp-Bh] BYREF

  if ( !a1 || *(_DWORD *)a1 != 1229343047 )
    sub_6ECC0(
      "./../lib/isc/unix/ifiter_getifaddrs.c",
      145,
      0,
      "(((iter) != ((void *)0)) && (((const isc__magic_t *)(iter))->magic == ((('I') << 24 | ('F') << 16 | ('I') << 8 | ('G')))))");
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      sub_6ECC0("./../lib/isc/unix/ifiter_getifaddrs.c", 163, 2, "ifa->ifa_name != ((void *)0)");
    if ( (*(_DWORD *)(v2 + 8) & 0x40) != 0 )
    {
      v3 = *(unsigned __int16 **)(v2 + 12);
      if ( v3 )
      {
        v4 = (char *)*v3;
        if ( ((unsigned __int16)v4 & 0xFFF7) == 2 )
        {
          if ( v4 == &byte_9[1] )
            dword_107240 = 1;
          memset((void *)(a1 + 24), 0, 0x8Cu);
          v5 = strlen(*(const char **)(v2 + 4));
          memset((void *)(a1 + 24), 0, 0x20u);
          if ( v5 >= 0x1F )
            v6 = 31;
          else
            v6 = v5;
          memcpy((void *)(a1 + 24), *(const void **)(v2 + 4), v6);
          v7 = *(_DWORD *)(v2 + 8);
          *(_DWORD *)(a1 + 156) = 0;
          *(_DWORD *)(a1 + 56) = v4;
          if ( (v7 & 1) != 0 )
            *(_DWORD *)(a1 + 156) = 1;
          if ( (v7 & 0x10) != 0 )
            *(_DWORD *)(a1 + 156) |= 2u;
          if ( (v7 & 8) != 0 )
            *(_DWORD *)(a1 + 156) |= 4u;
          if ( (v7 & 2) != 0 )
            *(_DWORD *)(a1 + 156) |= 8u;
          v8 = (v7 & 0x1000) == 0;
          if ( (v7 & 0x1000) != 0 )
            v7 = *(_DWORD *)(a1 + 156);
          v9 = *(_DWORD *)(v2 + 12);
          if ( !v8 )
            *(_DWORD *)(a1 + 156) = v7 | 0x10;
          sub_6F718(v4, a1 + 60, v9, *(_DWORD *)(v2 + 4));
          v10 = *(_DWORD *)(v2 + 16);
          if ( v10 )
            sub_6F718(v4, a1 + 84, v10, *(_DWORD *)(v2 + 4));
          v11 = *(_DWORD *)(v2 + 20);
          if ( !v11 )
            goto LABEL_31;
          v12 = *(_DWORD *)(a1 + 156);
          if ( (v12 & 2) != 0 )
          {
            sub_6F718(v4, a1 + 132, v11, *(_DWORD *)(v2 + 4));
            v11 = *(_DWORD *)(v2 + 20);
            if ( !v11 )
            {
LABEL_31:
              v13 = 0;
              *(_DWORD *)(a1 + 160) = if_nametoindex(a1 + 24);
              return v13;
            }
            v12 = *(_DWORD *)(a1 + 156);
          }
          if ( (v12 & 8) != 0 )
            sub_6F718(v4, a1 + 108, v11, *(_DWORD *)(v2 + 4));
          goto LABEL_31;
        }
      }
    }
    return 36;
  }
  v13 = *(_DWORD *)(a1 + 236);
  if ( v13 )
    return v13;
  if ( !*(_DWORD *)(a1 + 168) )
  {
    v13 = 25;
    sub_73300(isc_lctx, (int)&off_B7DC4, (int)&off_B7D9C, -4, (int)"/proc/net/if_inet6:iter->proc == NULL");
    return v13;
  }
  v15 = sscanf((const char *)(a1 + 172), "%32[a-f0-9] %x %x %x %x %16s\n", &v30, &v23, &v24, &v25, &v26, v29);
  if ( v15 != 6 )
  {
    v13 = 25;
    sub_73300(
      isc_lctx,
      (int)&off_B7DC4,
      (int)&off_B7D9C,
      -4,
      (int)"/proc/net/if_inet6:sscanf() -> %d (expected 6)",
      v15);
    return v13;
  }
  if ( strlen(&v30) != 32 )
  {
    v13 = 25;
    sub_73300(isc_lctx, (int)&off_B7DC4, (int)&off_B7D9C, -4, (int)"/proc/net/if_inet6:strlen(%s) != 32", &v30);
    return v13;
  }
  if ( (v26 & 0x40) != 0 )
    return 36;
  v16 = &v27;
  v17 = &v31;
  do
  {
    v18 = strchr("0123456789abcdef", (unsigned __int8)*(v17 - 1));
    v19 = (unsigned __int8)*v17;
    v17 += 2;
    *++v16 = (strchr("0123456789abcdef", v19) - "0123456789abcdef") | (16 * (v18 - "0123456789abcdef"));
  }
  while ( &v32 != v17 );
  *(_DWORD *)(a1 + 56) = 10;
  *(_DWORD *)(a1 + 156) = 1;
  sub_74B70((_DWORD *)(a1 + 60), v28);
  *(_DWORD *)(a1 + 160) = v23;
  if ( sub_74F64((_DWORD *)(a1 + 60)) )
    sub_74C28((_DWORD *)(a1 + 60), v23);
  v20 = v24;
  v21 = (char *)v28;
  while ( v20 > 8 )
  {
    v20 -= 8;
    *v21++ = -1;
    if ( v29 == v21 )
      goto LABEL_49;
  }
  do
  {
    v22 = 8 - v20;
    v20 = 0;
    *v21++ = 255 << v22;
  }
  while ( v29 != v21 );
LABEL_49:
  v24 = v20;
  sub_74B70((_DWORD *)(a1 + 84), v28);
  strncpy((char *)(a1 + 24), v29, 0x20u);
  return v13;
}
// B244: using guessed type int __fastcall if_nametoindex(_DWORD);
// B7D9C: using guessed type char *;
// B7DC4: using guessed type char *off_B7DC4;
// 107240: using guessed type int dword_107240;
// 10725C: using guessed type int isc_lctx;

//----- (0006FD38) --------------------------------------------------------
int __fastcall sub_6FD38(int a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  void *v5; // r4
  int v7; // r3
  int v8; // r5
  int v9; // r0
  const char *v10; // r0
  FILE *v11; // r0
  struct ifaddrs *v12; // r0
  int v13; // r0
  int *v14; // r0
  char v15[128]; // [sp+Ch] [bp-88h] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/ifiter_getifaddrs.c", 60, 0, "mctx != ((void *)0)");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/unix/ifiter_getifaddrs.c", 61, 0, "iterp != ((void *)0)");
  if ( *a2 )
    sub_6ECC0("./../lib/isc/unix/ifiter_getifaddrs.c", 62, 0, "*iterp == ((void *)0)");
  v4 = sub_63BA4(0, 0xF0u, 0, 0);
  v5 = v4;
  if ( !v4 )
    return 1;
  v4[1] = a1;
  v4[2] = 0;
  v4[3] = 0;
  v7 = dword_107240;
  v4[4] = 0;
  if ( v7 )
  {
    v4[42] = 0;
  }
  else
  {
    v13 = fopen64("/proc/net/if_inet6", "r");
    *((_DWORD *)v5 + 42) = v13;
    if ( !v13 )
    {
      v14 = _errno_location();
      sub_75B10(*v14, (int)v15, 0x80u);
      sub_73300(isc_lctx, (int)&off_B7DC4, (int)&isc_modules, -3, (int)"failed to open /proc/net/if_inet6");
    }
  }
  v8 = 3;
  *((_DWORD *)v5 + 59) = 25;
  do
  {
    if ( getifaddrs((struct ifaddrs **)v5 + 4) >= 0 )
    {
      *((_DWORD *)v5 + 5) = 0;
      *(_DWORD *)v5 = 1229343047;
      *((_DWORD *)v5 + 41) = 25;
      *a2 = v5;
      return 0;
    }
    v9 = *_errno_location();
    if ( v9 != 4 )
      break;
    --v8;
  }
  while ( v8 );
  sub_75B10(v9, (int)v15, 0x80u);
  v10 = (const char *)sub_73830((_DWORD *)isc_msgcat, 21, 1801, (int)"getifaddrs");
  sub_6F554("./../lib/isc/unix/ifiter_getifaddrs.c", 99, (int)"getting interface addresses: %s: %s", v10, v15);
  v11 = (FILE *)*((_DWORD *)v5 + 42);
  if ( v11 )
    fclose(v11);
  v12 = (struct ifaddrs *)*((_DWORD *)v5 + 4);
  if ( v12 )
    freeifaddrs(v12);
  free(v5);
  return 34;
}
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// B7D8C: using guessed type _UNKNOWN *isc_modules;
// B7DC4: using guessed type char *off_B7DC4;
// 107240: using guessed type int dword_107240;
// 107248: using guessed type int isc_msgcat;
// 10725C: using guessed type int isc_lctx;

//----- (0006FFC4) --------------------------------------------------------
int __fastcall sub_6FFC4(int a1, void *dest)
{
  if ( *(_DWORD *)(a1 + 164) )
    sub_6ECC0("./../lib/isc/unix/interfaceiter.c", 269, 0, "iter->result == 0");
  memcpy(dest, (const void *)(a1 + 24), 0x8Cu);
  return 0;
}

//----- (00070050) --------------------------------------------------------
int __fastcall sub_70050(_DWORD *a1)
{
  FILE *v2; // r0
  int v3; // r3
  int *v4; // r3
  int v5; // r3

  if ( !a1 || *a1 != 1229343047 )
    sub_6ECC0(
      "./../lib/isc/unix/interfaceiter.c",
      278,
      0,
      "(((iter) != ((void *)0)) && (((const isc__magic_t *)(iter))->magic == ((('I') << 24 | ('F') << 16 | ('I') << 8 | ('G')))))");
  v2 = (FILE *)a1[42];
  if ( v2 )
  {
    rewind(v2);
    sub_6F69C((int)a1);
  }
  else
  {
    a1[59] = 29;
  }
  a1[5] = a1[4];
  while ( 1 )
  {
    v3 = sub_6F874((int)a1);
    if ( v3 != 36 )
      break;
    v4 = (int *)a1[5];
    if ( v4 )
    {
      v5 = *v4;
      a1[5] = v5;
      if ( v5 )
        continue;
    }
    if ( dword_107240 )
    {
      v3 = 29;
      break;
    }
    v3 = sub_6F69C((int)a1);
    if ( v3 )
      break;
  }
  a1[41] = v3;
  return v3;
}
// 107240: using guessed type int dword_107240;

//----- (00070164) --------------------------------------------------------
int __fastcall sub_70164(_DWORD *a1)
{
  int v2; // r3
  int v3; // r3
  int *v4; // r3

  if ( !a1 || *a1 != 1229343047 )
    sub_6ECC0(
      "./../lib/isc/unix/interfaceiter.c",
      297,
      0,
      "(((iter) != ((void *)0)) && (((const isc__magic_t *)(iter))->magic == ((('I') << 24 | ('F') << 16 | ('I') << 8 | ('G')))))");
  if ( a1[41] )
    sub_6ECC0("./../lib/isc/unix/interfaceiter.c", 298, 0, "iter->result == 0");
  while ( 1 )
  {
    v4 = (int *)a1[5];
    if ( v4 )
    {
      v2 = *v4;
      a1[5] = v2;
      if ( v2 )
        goto LABEL_6;
    }
    if ( dword_107240 )
      break;
    v3 = sub_6F69C((int)a1);
    if ( v3 )
      goto LABEL_10;
LABEL_6:
    v3 = sub_6F874((int)a1);
    if ( v3 != 36 )
      goto LABEL_10;
  }
  v3 = 29;
LABEL_10:
  a1[41] = v3;
  return v3;
}
// 107240: using guessed type int dword_107240;

//----- (00070284) --------------------------------------------------------
void __fastcall sub_70284(_DWORD **a1)
{
  _DWORD *v2; // r4
  FILE *v3; // r0
  struct ifaddrs *v4; // r0
  void *v5; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/interfaceiter.c", 316, 0, "iterp != ((void *)0)");
  v2 = *a1;
  if ( !*a1 || *v2 != 1229343047 )
    sub_6ECC0(
      "./../lib/isc/unix/interfaceiter.c",
      318,
      0,
      "(((iter) != ((void *)0)) && (((const isc__magic_t *)(iter))->magic == ((('I') << 24 | ('F') << 16 | ('I') << 8 | ('G')))))");
  v3 = (FILE *)v2[42];
  if ( v3 )
    fclose(v3);
  v4 = (struct ifaddrs *)v2[4];
  v2[42] = 0;
  if ( v4 )
    freeifaddrs(v4);
  v5 = (void *)v2[2];
  v2[4] = 0;
  if ( v5 )
    free(v5);
  free(v2);
  *a1 = 0;
}

//----- (00070388) --------------------------------------------------------
_DWORD *sub_70388()
{
  return sub_736A4((int)"libisc.cat", &isc_msgcat);
}
// 107248: using guessed type int isc_msgcat;

//----- (000703E8) --------------------------------------------------------
int sub_703E8()
{
  int result; // r0
  struct _IO_FILE *v1; // r5
  const char *v2; // r6
  const char *v3; // r0

  result = pthread_once(&dword_107244, (void (*)(void))sub_70388);
  if ( result )
  {
    v1 = stderr;
    v2 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 110, (int)"fatal error");
    v3 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
    _fprintf_chk(v1, 1, "%s:%d: %s: isc_once_do() %s.\n", "./../lib/isc/lib.c", 77, v2, v3);
    abort();
  }
  return result;
}
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 107244: using guessed type pthread_once_t dword_107244;
// 107248: using guessed type int isc_msgcat;

//----- (000704E0) --------------------------------------------------------
char *__fastcall sub_704E0(int a1)
{
  int v2; // r7
  int v3; // r5
  size_t v5; // r5
  void *v6; // r0
  void *v7; // r8
  int v8; // r2
  int v9; // r3

  if ( !a1 || *(_DWORD *)a1 != 1281582695 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      1112,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(v2 + 12);
  if ( !v3 )
    sub_6ECC0("./../lib/isc/log.c", 1116, 0, "lctx->category_count != 0");
  if ( v3 == *(_DWORD *)(a1 + 20) )
    return 0;
  v5 = 8 * v3;
  v6 = sub_63BA4(0, v5, 0, 0);
  v7 = v6;
  if ( !v6 )
    return (char *)&dword_0 + 1;
  memset(v6, 0, v5);
  v8 = *(_DWORD *)(a1 + 20);
  if ( v8 )
  {
    memcpy(v7, *(const void **)(a1 + 16), 8 * v8);
    free(*(void **)(a1 + 16));
  }
  v9 = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 20) = v9;
  return 0;
}
// 0: using guessed type int dword_0;

//----- (00070610) --------------------------------------------------------
int __fastcall sub_70610(_DWORD *a1, unsigned int a2, int a3, int a4)
{
  int v7; // r3
  char *v9; // r9
  _DWORD *v11; // r0
  int v12; // r3
  int v13; // r2
  int v14; // r1
  int v15; // r3

  if ( !a1 || *a1 != 1281582695 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      1063,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
  v7 = a1[1];
  if ( *(_DWORD *)(v7 + 12) <= a2 )
    sub_6ECC0("./../lib/isc/log.c", 1067, 0, "category_id < lctx->category_count");
  if ( *(_DWORD *)(a3 + 4) >= *(_DWORD *)(v7 + 20) )
    sub_6ECC0("./../lib/isc/log.c", 1068, 0, "module == ((void *)0) || module->id < lctx->module_count");
  if ( !a4 )
    sub_6ECC0("./../lib/isc/log.c", 1069, 0, "channel != ((void *)0)");
  v9 = sub_704E0((int)a1);
  if ( !v9 )
  {
    v11 = sub_63BA4(0, 0x10u, 0, 0);
    if ( v11 )
    {
      v12 = a1[4];
      *v11 = a3;
      v11[1] = a4;
      v13 = *(_DWORD *)(v12 + 8 * a2);
      if ( !v13 )
        *(_DWORD *)(v12 + 8 * a2 + 4) = v11;
      v14 = *(_DWORD *)(a4 + 4);
      if ( v13 )
        *(_DWORD *)(v13 + 8) = v11;
      v11[3] = v13;
      v11[2] = 0;
      *(_DWORD *)(v12 + 8 * a2) = v11;
      if ( v14 != 1 )
      {
        v15 = *(_DWORD *)(a4 + 8);
        if ( a1[7] < v15 )
          a1[7] = v15;
        if ( !v15 )
          a1[9] = 1;
      }
    }
    else
    {
      return 1;
    }
  }
  return (int)v9;
}
// 70670: conditional instruction was optimized away because r2.4==4C636667

//----- (000707C8) --------------------------------------------------------
int __fastcall sub_707C8(int a1)
{
  const char *v2; // r6
  char *v3; // r0
  const char *v4; // r10
  char *v5; // r4
  size_t v6; // r9
  int v7; // r0
  int v8; // r8
  int v9; // r0
  int v10; // r1
  _BOOL4 v11; // r3
  int v12; // r0
  bool v13; // zf
  unsigned int v14; // r3
  int v16; // r4
  int v17; // r3
  _BOOL4 v18; // r2
  unsigned int v19; // r3
  int v20; // r0
  int v21; // r5
  int v22; // r0
  bool v23; // zf
  const char *v24; // r0
  unsigned int v25; // r0
  bool v26; // zf
  const char *v27; // r0
  unsigned int v28; // r3
  const char *v29; // r0
  int v30; // r0
  bool v31; // zf
  int v32; // [sp+8h] [bp-253Ch]
  int v33; // [sp+18h] [bp-252Ch]
  char *v34; // [sp+24h] [bp-2520h] BYREF
  _DWORD v35[6]; // [sp+28h] [bp-251Ch] BYREF
  char v36[256]; // [sp+42Ch] [bp-2118h] BYREF
  size_t v37; // [sp+52Ch] [bp-2018h]
  char v38[12]; // [sp+534h] [bp-2010h] BYREF
  char v39[4040]; // [sp+1538h] [bp-100Ch] BYREF

  if ( *(_DWORD *)(a1 + 24) == -2 )
    return 0;
  v2 = *(const char **)(a1 + 20);
  if ( *(_DWORD *)(a1 + 4) != 3 )
    sub_6ECC0("./../lib/isc/log.c", 1157, 0, "channel->type == 3");
  v3 = strrchr(*(const char **)(a1 + 20), 47);
  if ( v3 )
  {
    v4 = v3 + 1;
    *v3 = 0;
    v5 = *(char **)(a1 + 20);
  }
  else
  {
    v4 = v2;
    v5 = ".";
  }
  v6 = strlen(v4);
  sub_7A2B0((int)v35);
  v7 = sub_7A33C((int)v35, v5);
  v8 = v7;
  if ( v4 != *(const char **)(a1 + 20) )
    *((_BYTE *)v4 - 1) = 47;
  if ( !v7 )
  {
    v33 = -1;
    while ( !sub_7A4A4((int)v35) )
    {
      if ( v6 < v37 && !strncmp(v36, v4, v6) && v36[v6] == 46 )
      {
        v9 = strtol((const char *)&v35[257] + v6 + 1, &v34, 10);
        v10 = v33;
        v11 = v9 > v33;
        if ( *v34 )
          v11 = 0;
        if ( v11 )
          v10 = v9;
        v33 = v10;
      }
    }
    v16 = v33 + 1;
    sub_7A584(v35);
    v17 = *(_DWORD *)(a1 + 24);
    v18 = v17 == -1;
    if ( v17 > v33 + 1 )
      v18 = 1;
    if ( v18 )
    {
LABEL_27:
      if ( v16 <= 0 )
        goto LABEL_39;
      while ( 1 )
      {
        v21 = v16 - 1;
        if ( sub_6C054((int)v38, 0x1001u, "%s.%d", v2, v16 - 1) > 0x1000
          || sub_6C054((int)v39, 0x1001u, "%s.%d", v2, v16) > 0x1000 )
        {
          v19 = 19;
LABEL_30:
          v20 = sub_754A0(v19);
          v32 = v16--;
          _syslog_chk(3, 1, "unable to rename log file '%s.%d' to '%s.%d': %s", v2, v21, v2, v32, v20);
          if ( !v21 )
            goto LABEL_38;
        }
        else
        {
          v22 = sub_7B6F4(v38, v39);
          v23 = v22 == 0;
          if ( v22 )
            v23 = v22 == 38;
          v19 = v22;
          if ( !v23 )
            goto LABEL_30;
          --v16;
          if ( !v21 )
          {
LABEL_38:
            v17 = *(_DWORD *)(a1 + 24);
LABEL_39:
            if ( v17 )
            {
              if ( sub_6C054((int)v39, 0x1001u, "%s.0", v2) > 0x1000 )
              {
                v14 = 19;
                goto LABEL_43;
              }
              v12 = sub_7B6F4(v2, v39);
              v13 = v12 == 0;
              if ( v12 )
                v13 = v12 == 38;
              v14 = v12;
              if ( !v13 )
              {
LABEL_43:
                v24 = (const char *)sub_754A0(v14);
                _syslog_chk(3, 1, "unable to rename log file '%s' to '%s.0': %s", v2, v2, v24);
                return v8;
              }
            }
            else
            {
              v25 = sub_7B648(v2);
              v26 = v25 == 0;
              if ( v25 )
                v26 = v25 == 38;
              if ( !v26 )
              {
                v27 = (const char *)sub_754A0(v25);
                _syslog_chk(3, 1, "unable to remove log file '%s': %s", v2, v27);
                return v8;
              }
            }
            return 0;
          }
        }
      }
    }
    while ( 1 )
    {
      if ( --v16 < v17 )
        goto LABEL_27;
      if ( sub_6C054((int)v38, 0x1001u, "%s.%d", v2, v16) > 0x1000 )
        break;
      v30 = sub_7B648(v38);
      v31 = v30 == 0;
      if ( v30 )
        v31 = v30 == 38;
      v28 = v30;
      if ( v31 )
      {
        v17 = *(_DWORD *)(a1 + 24);
      }
      else
      {
LABEL_52:
        v29 = (const char *)sub_754A0(v28);
        _syslog_chk(3, 1, "unable to remove log file '%s.%d': %s", v2, v16, v29);
        v17 = *(_DWORD *)(a1 + 24);
      }
    }
    v28 = 19;
    goto LABEL_52;
  }
  return v8;
}
// BB48: using guessed type int _syslog_chk(_DWORD, _DWORD, const char *, ...);

//----- (00070C0C) --------------------------------------------------------
int __fastcall sub_70C0C(_DWORD *a1)
{
  int result; // r0

  if ( !a1 || *a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      424,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  result = a1[13];
  if ( !result )
    sub_6ECC0("./../lib/isc/log.c", 426, 1, "lctx->logconfig != ((void *)0)");
  return result;
}

//----- (00070CC0) --------------------------------------------------------
void __fastcall sub_70CC0(_DWORD **a1)
{
  _DWORD *v2; // r4
  int v3; // r3
  int i; // r5
  int v5; // r2
  int v6; // r3
  int v7; // r3
  FILE *v8; // r0
  unsigned int v9; // r2
  _DWORD *v10; // r3
  unsigned int j; // r5
  _DWORD *v12; // r0
  _DWORD *v13; // r1
  int v14; // r2
  int v15; // r3
  void *v16; // r0

  if ( !a1 || (v2 = *a1) == 0 || *v2 != 1281582695 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      511,
      0,
      "lcfgp != ((void *)0) && (((*lcfgp) != ((void *)0)) && (((const isc__magic_t *)(*lcfgp))->magic == ((('L') << 24 | "
      "('c') << 16 | ('f') << 8 | ('g')))))");
  v3 = v2[1];
  if ( !v3 || v2 == *(_DWORD **)(v3 + 52) )
    sub_6ECC0("./../lib/isc/log.c", 519, 0, "lcfg->lctx != ((void *)0) && lcfg->lctx->logconfig != lcfg");
  for ( i = v2[2]; i; i = v2[2] )
  {
    v7 = *(_DWORD *)(i + 52);
    if ( v7 )
    {
      *(_DWORD *)(v7 + 48) = *(_DWORD *)(i + 48);
      v5 = *(_DWORD *)(i + 48);
    }
    else
    {
      if ( v2[3] != i )
        sub_6ECC0("./../lib/isc/log.c", 524, 2, "(lcfg->channels).tail == (channel)");
      v5 = *(_DWORD *)(i + 48);
      v2[3] = v5;
    }
    if ( v5 )
      *(_DWORD *)(v5 + 52) = v7;
    else
      v2[2] = v7;
    v6 = *(_DWORD *)(i + 4);
    *(_DWORD *)(i + 48) = -1;
    *(_DWORD *)(i + 52) = -1;
    if ( v6 == 3 )
    {
      free(*(void **)(i + 20));
      v8 = *(FILE **)(i + 16);
      if ( v8 )
        fclose(v8);
    }
    free(*(void **)i);
    free((void *)i);
  }
  v9 = v2[5];
  if ( v9 )
  {
    v10 = (_DWORD *)v2[4];
    for ( j = 0; j < v9; ++j )
    {
      v12 = (_DWORD *)v10[2 * j];
      v13 = &v10[2 * j];
      if ( v12 )
      {
        do
        {
          v15 = v12[3];
          if ( v15 )
          {
            *(_DWORD *)(v15 + 8) = v12[2];
            v14 = v12[2];
          }
          else
          {
            if ( (_DWORD *)v13[1] != v12 )
              sub_6ECC0("./../lib/isc/log.c", 546, 2, "(lcfg->channellists[i]).tail == (item)");
            v14 = v12[2];
            v13[1] = v14;
          }
          if ( v14 )
            *(_DWORD *)(v14 + 12) = v15;
          else
            *v13 = v15;
          free(v12);
          v10 = (_DWORD *)v2[4];
          v12 = (_DWORD *)v10[2 * j];
          v13 = &v10[2 * j];
        }
        while ( v12 );
        v9 = v2[5];
      }
    }
    if ( v9 )
      free(v10);
  }
  v16 = (void *)v2[8];
  v2[9] = 0;
  if ( v16 )
    free(v16);
  free(v2);
  *a1 = 0;
}

//----- (00070F38) --------------------------------------------------------
char *__fastcall sub_70F38(int a1, _DWORD *a2)
{
  char *v4; // r7
  _DWORD *v6; // r3
  _DWORD *v7; // [sp+0h] [bp-8h] BYREF

  if ( !a1 || *(_DWORD *)a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      436,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  if ( !a2 || *a2 != 1281582695 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      437,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
  if ( a2[1] != a1 )
    sub_6ECC0("./../lib/isc/log.c", 438, 0, "lcfg->lctx == lctx");
  v4 = sub_704E0((int)a2);
  if ( !v4 )
  {
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 28)) )
      sub_6F61C("./../lib/isc/log.c", 449, "((pthread_mutex_lock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
    v6 = *(_DWORD **)(a1 + 52);
    *(_DWORD *)(a1 + 52) = a2;
    v7 = v6;
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 28)) )
      sub_6F61C("./../lib/isc/log.c", 454, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
    sub_70CC0(&v7);
  }
  return v4;
}

//----- (000710C8) --------------------------------------------------------
void __fastcall sub_710C8(void **a1)
{
  char *v2; // r5
  _DWORD *i; // r0
  int v4; // r2
  int v5; // r3
  _DWORD *v6; // [sp+0h] [bp-Ch] BYREF

  if ( !a1 || (v2 = (char *)*a1) == 0 || *(_DWORD *)v2 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      468,
      0,
      "lctxp != ((void *)0) && (((*lctxp) != ((void *)0)) && (((const isc__magic_t *)(*lctxp))->magic == ((('L') << 24 | "
      "('c') << 16 | ('t') << 8 | ('x')))))");
  if ( *((_DWORD *)v2 + 13) )
  {
    v6 = (_DWORD *)*((_DWORD *)v2 + 13);
    *((_DWORD *)v2 + 13) = 0;
    sub_70CC0(&v6);
  }
  if ( pthread_mutex_destroy((pthread_mutex_t *)(v2 + 28)) )
    sub_6F61C("./../lib/isc/log.c", 479, "((pthread_mutex_destroy(((&lctx->lock))) == 0) ? 0 : 34) == 0");
  for ( i = (_DWORD *)*((_DWORD *)v2 + 2062); i; i = (_DWORD *)*((_DWORD *)v2 + 2062) )
  {
    v5 = i[4];
    if ( v5 )
    {
      *(_DWORD *)(v5 + 12) = i[3];
      v4 = i[3];
    }
    else
    {
      if ( *((_DWORD **)v2 + 2063) != i )
        sub_6ECC0("./../lib/isc/log.c", 482, 2, "(lctx->messages).tail == (message)");
      v4 = i[3];
      *((_DWORD *)v2 + 2063) = v4;
    }
    if ( v4 )
      *(_DWORD *)(v4 + 16) = v5;
    else
      *((_DWORD *)v2 + 2062) = v5;
    free(i);
  }
  free(v2);
  *a1 = 0;
}

//----- (00071240) --------------------------------------------------------
_DWORD *__fastcall sub_71240(_DWORD *result, int *a2)
{
  int **v2; // r3
  int v3; // r2
  int v4; // r3
  int v5; // t1

  if ( !result || *result != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      572,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  if ( !a2 || !*a2 )
    sub_6ECC0("./../lib/isc/log.c", 573, 0, "categories != ((void *)0) && categories[0].name != ((void *)0)");
  v2 = (int **)result[2];
  if ( !v2 )
  {
    result[2] = a2;
LABEL_13:
    v4 = result[3];
    do
    {
      a2[1] = v4++;
      v5 = a2[2];
      a2 += 2;
    }
    while ( v5 );
    result[3] = v4;
    return result;
  }
  while ( *v2 )
  {
    if ( v2[1] == (int *)-1 )
      v2 = (int **)*v2;
    else
      v2 += 2;
  }
  *v2 = a2;
  v3 = *a2;
  v2[1] = (int *)-1;
  if ( v3 )
    goto LABEL_13;
  return result;
}

//----- (00071360) --------------------------------------------------------
const char *__fastcall sub_71360(_DWORD *a1, char *s2)
{
  const char *v3; // r4

  if ( !a1 || *a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      616,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  if ( !s2 )
    sub_6ECC0("./../lib/isc/log.c", 617, 0, "name != ((void *)0)");
  v3 = (const char *)a1[2];
  while ( *(_DWORD *)v3 )
  {
    if ( *((_DWORD *)v3 + 1) == -1 )
    {
      v3 = *(const char **)v3;
    }
    else
    {
      if ( !strcmp(*(const char **)v3, s2) )
        return v3;
      v3 += 8;
    }
  }
  return 0;
}

//----- (00071458) --------------------------------------------------------
_DWORD *__fastcall sub_71458(_DWORD *result, int *a2)
{
  int **v2; // r3
  int v3; // r2
  int v4; // r3
  int v5; // t1

  if ( !result || *result != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      639,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  if ( !a2 || !*a2 )
    sub_6ECC0("./../lib/isc/log.c", 640, 0, "modules != ((void *)0) && modules[0].name != ((void *)0)");
  v2 = (int **)result[4];
  if ( !v2 )
  {
    result[4] = a2;
LABEL_13:
    v4 = result[5];
    do
    {
      a2[1] = v4++;
      v5 = a2[2];
      a2 += 2;
    }
    while ( v5 );
    result[5] = v4;
    return result;
  }
  while ( *v2 )
  {
    if ( v2[1] == (int *)-1 )
      v2 = (int **)*v2;
    else
      v2 += 2;
  }
  *v2 = a2;
  v3 = *a2;
  v2[1] = (int *)-1;
  if ( v3 )
    goto LABEL_13;
  return result;
}

//----- (00071578) --------------------------------------------------------
const char *__fastcall sub_71578(_DWORD *a1, char *s2)
{
  const char *v3; // r4

  if ( !a1 || *a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      683,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  if ( !s2 )
    sub_6ECC0("./../lib/isc/log.c", 684, 0, "name != ((void *)0)");
  v3 = (const char *)a1[4];
  while ( *(_DWORD *)v3 )
  {
    if ( *((_DWORD *)v3 + 1) == -1 )
    {
      v3 = *(const char **)v3;
    }
    else
    {
      if ( !strcmp(*(const char **)v3, s2) )
        return v3;
      v3 += 8;
    }
  }
  return 0;
}

//----- (00071670) --------------------------------------------------------
int __fastcall sub_71670(_DWORD *a1, const char *a2, int a3, int a4, int *a5, int a6)
{
  _BOOL4 v10; // r2
  char *v11; // r4
  int result; // r0
  void *v13; // r0
  int v14; // r3
  int v15; // r1
  void *v16; // r0
  int v17; // r12
  __int64 v18; // r2

  if ( !a1 || *a1 != 1281582695 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      711,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/log.c", 712, 0, "name != ((void *)0)");
  if ( (unsigned int)(a3 - 1) > 3 )
    sub_6ECC0("./../lib/isc/log.c", 714, 0, "type == 2 || type == 3 || type == 4 || type == 1");
  v10 = a3 == 1;
  if ( a5 )
    v10 = 1;
  if ( !v10 )
    sub_6ECC0("./../lib/isc/log.c", 715, 0, "destination != ((void *)0) || type == 1");
  if ( a4 < -5 )
    sub_6ECC0("./../lib/isc/log.c", 716, 0, "level >= (-5)");
  if ( (a6 & 0xFFFFEFE0) != 0 )
    sub_6ECC0("./../lib/isc/log.c", 718, 0, "(flags & (unsigned int)~(0x001F | 0x1000)) == 0");
  v11 = (char *)sub_63BA4(0, 0x38u, 0, 0);
  if ( !v11 )
    return 1;
  v13 = sub_63D08(a2);
  *(_DWORD *)v11 = v13;
  if ( v13 )
  {
    *((_DWORD *)v11 + 1) = a3;
    *((_DWORD *)v11 + 2) = a4;
    *((_DWORD *)v11 + 3) = a6;
    *((_DWORD *)v11 + 12) = -1;
    *((_DWORD *)v11 + 13) = -1;
    switch ( a3 )
    {
      case 3:
        v16 = sub_63D08((const char *)a5[1]);
        v17 = a5[2];
        v18 = *((_QWORD *)a5 + 2);
        *((_DWORD *)v11 + 5) = v16;
        *((_DWORD *)v11 + 6) = v17;
        *((_DWORD *)v11 + 4) = 0;
        *((_QWORD *)v11 + 4) = v18;
        *((_DWORD *)v11 + 10) = 0;
        break;
      case 4:
        v15 = *a5;
        *(_QWORD *)(v11 + 20) = 0xFFFFFFFE00000000LL;
        *((_DWORD *)v11 + 4) = v15;
        *((_QWORD *)v11 + 4) = 0;
        break;
      case 2:
        *((_DWORD *)v11 + 4) = *a5;
        break;
    }
    v14 = a1[2];
    if ( v14 )
      *(_DWORD *)(v14 + 48) = v11;
    else
      a1[3] = v11;
    *((_DWORD *)v11 + 13) = v14;
    *((_DWORD *)v11 + 12) = 0;
    a1[2] = v11;
    result = strcmp(a2, "default_stderr");
    if ( result )
      return 0;
    else
      dword_107250 = (int)v11;
  }
  else
  {
    free(v11);
    return 1;
  }
  return result;
}
// 107250: using guessed type int dword_107250;

//----- (00071914) --------------------------------------------------------
int __fastcall sub_71914(_DWORD *a1, void **a2)
{
  _DWORD *v4; // r0
  int v5; // r1
  int v7; // [sp+Ch] [bp-38h]
  _DWORD *v8; // [sp+14h] [bp-30h] BYREF
  struct _IO_FILE *v9; // [sp+18h] [bp-2Ch] BYREF
  int v10; // [sp+1Ch] [bp-28h]
  int v11; // [sp+20h] [bp-24h]
  int v12; // [sp+28h] [bp-1Ch]
  int v13; // [sp+2Ch] [bp-18h]

  if ( !a2 || *a2 )
    sub_6ECC0("./../lib/isc/log.c", 337, 0, "lcfgp != ((void *)0) && *lcfgp == ((void *)0)");
  if ( !a1 || *a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      338,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  v4 = sub_63BA4(*a2, 0x28u, (size_t)*a2, (int)*a2);
  v8 = v4;
  if ( !v4 )
    return 1;
  v4[1] = a1;
  *v4 = 1281582695;
  v4[4] = 0;
  v4[5] = 0;
  v4[6] = 0;
  v4[8] = 0;
  v4[9] = 0;
  v4[2] = 0;
  v4[3] = 0;
  v4[7] = -1;
  v9 = (struct _IO_FILE *)&off_18;
  v5 = sub_71670(v4, "default_syslog", 2, -1, (int *)&v9, 0);
  if ( v5 )
    goto LABEL_13;
  v10 = 0;
  v11 = -2;
  v12 = 0;
  v13 = 0;
  v9 = stderr;
  v5 = sub_71670(v8, "default_stderr", 4, -1, (int *)&v9, 1);
  if ( v5 )
    goto LABEL_13;
  v10 = 0;
  dword_107250 = v8[2];
  v9 = stderr;
  v11 = -2;
  v12 = 0;
  v13 = 0;
  v5 = sub_71670(v8, "default_debug", 4, 0, (int *)&v9, 1);
  if ( v5 || (v5 = sub_71670(v8, "null", 1, 0, 0, 0)) != 0 )
  {
LABEL_13:
    if ( v8 )
    {
      v7 = v5;
      sub_70CC0(&v8);
      return v7;
    }
  }
  else
  {
    *a2 = v8;
  }
  return v5;
}
// 18: using guessed type _UNKNOWN *off_18;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// 107250: using guessed type int dword_107250;

//----- (00071B68) --------------------------------------------------------
int __fastcall sub_71B68(int a1, _DWORD *a2, int *a3)
{
  char *v6; // r0
  char *v7; // r7
  _DWORD *v8; // r0
  void *v10; // r3
  int v11; // r2
  void *ptr; // [sp+4h] [bp-10h] BYREF
  int v13; // [sp+8h] [bp-Ch] BYREF

  v13 = 0;
  if ( !a1 )
    sub_6ECC0("./../lib/isc/log.c", 273, 0, "mctx != ((void *)0)");
  if ( !a2 || *a2 )
    sub_6ECC0("./../lib/isc/log.c", 274, 0, "lctxp != ((void *)0) && *lctxp == ((void *)0)");
  if ( a3 && *a3 )
    sub_6ECC0("./../lib/isc/log.c", 275, 0, "lcfgp == ((void *)0) || *lcfgp == ((void *)0)");
  v6 = (char *)sub_63BA4(0, 0x2040u, 0, 0);
  ptr = v6;
  if ( !v6 )
    return 1;
  *((_DWORD *)v6 + 1) = a1;
  *((_DWORD *)v6 + 2) = 0;
  *((_DWORD *)v6 + 3) = 0;
  *((_DWORD *)v6 + 4) = 0;
  *((_DWORD *)v6 + 5) = 0;
  *((_DWORD *)v6 + 6) = 0;
  *((_DWORD *)v6 + 2062) = 0;
  *((_DWORD *)v6 + 2063) = 0;
  v7 = (char *)sub_78614((pthread_mutex_t *)(v6 + 28), "./../lib/isc/log.c", 288);
  v8 = ptr;
  if ( v7 )
  {
    free(ptr);
  }
  else
  {
    *(_DWORD *)ptr = 1281586296;
    sub_71240(v8, (int *)&isc_categories);
    sub_71458(ptr, (int *)&isc_modules);
    v7 = (char *)sub_71914(ptr, (void **)&v13);
    if ( v7 || (v7 = sub_704E0(v13)) != 0 )
    {
      if ( v13 )
        sub_70CC0((_DWORD **)&v13);
      if ( ptr )
        sub_710C8(&ptr);
    }
    else
    {
      v10 = ptr;
      v11 = v13;
      *((_DWORD *)ptr + 13) = v13;
      *a2 = v10;
      if ( a3 )
        *a3 = v11;
    }
  }
  return (int)v7;
}
// 71CB0: conditional instruction was optimized away because %var_C.4==0
// B7D8C: using guessed type _UNKNOWN *isc_modules;
// B7DBC: using guessed type char *isc_categories;

//----- (00071D84) --------------------------------------------------------
int __fastcall sub_71D84(_DWORD *a1, char *s1, unsigned int a3, int a4)
{
  unsigned int v6; // r5
  int v8; // r9
  int v9; // r4
  int result; // r0

  if ( !a1 || (v6 = a3, *a1 != 1281582695) )
    sub_6ECC0(
      "./../lib/isc/log.c",
      797,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
  if ( !s1 )
    sub_6ECC0("./../lib/isc/log.c", 798, 0, "name != ((void *)0)");
  v8 = a1[1];
  if ( *(_DWORD *)(a3 + 4) >= *(_DWORD *)(v8 + 12) )
    sub_6ECC0("./../lib/isc/log.c", 802, 0, "category == ((void *)0) || category->id < lctx->category_count");
  if ( a4 )
  {
    if ( *(_DWORD *)(a4 + 4) >= *(_DWORD *)(v8 + 20) )
      sub_6ECC0("./../lib/isc/log.c", 803, 0, "module == ((void *)0) || module->id < lctx->module_count");
  }
  v9 = a1[2];
  if ( !v9 )
    return 23;
  while ( strcmp(s1, *(const char **)v9) )
  {
    v9 = *(_DWORD *)(v9 + 52);
    if ( !v9 )
      return 23;
  }
  if ( v6 )
    return sub_70610(a1, *(_DWORD *)(v6 + 4), a4, v9);
  if ( !*(_DWORD *)(v8 + 12) )
    return 0;
  while ( 1 )
  {
    result = sub_70610(a1, v6, a4, v9);
    if ( result )
      break;
    if ( *(_DWORD *)(v8 + 12) <= ++v6 )
      return 0;
  }
  return result;
}
// 71DE0: conditional instruction was optimized away because r2.4==4C636667

//----- (00071F68) --------------------------------------------------------
int __fastcall sub_71F68(int result)
{
  isc_lctx = result;
  return result;
}
// 10725C: using guessed type int isc_lctx;

//----- (00071FBC) --------------------------------------------------------
int __fastcall sub_71FBC(int a1, int a2)
{
  pthread_mutex_t *v3; // r6
  _DWORD *i; // r4
  FILE *v6; // r0
  int result; // r0

  if ( !a1 || *(_DWORD *)a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      957,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  v3 = (pthread_mutex_t *)(a1 + 28);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 28)) )
    sub_6F61C("./../lib/isc/log.c", 959, "((pthread_mutex_lock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
  *(_DWORD *)(a1 + 24) = a2;
  if ( !a2 )
  {
    for ( i = *(_DWORD **)(*(_DWORD *)(a1 + 52) + 8); i; i = (_DWORD *)i[13] )
    {
      while ( 1 )
      {
        if ( i[1] == 3 && (i[3] & 0x1000) != 0 )
        {
          v6 = (FILE *)i[4];
          if ( v6 )
            break;
        }
        i = (_DWORD *)i[13];
        if ( !i )
          goto LABEL_12;
      }
      fclose(v6);
      i[4] = 0;
    }
  }
LABEL_12:
  result = pthread_mutex_unlock(v3);
  if ( result )
    sub_6F61C("./../lib/isc/log.c", 975, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
  return result;
}

//----- (00072120) --------------------------------------------------------
int __fastcall sub_72120(_DWORD *a1)
{
  if ( !a1 || *a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      980,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  return a1[6];
}

//----- (000721A8) --------------------------------------------------------
_DWORD *__fastcall sub_721A8(_DWORD *result, int a2)
{
  if ( !result || *result != 1281582695 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      987,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
  result[6] = a2;
  return result;
}

//----- (00072230) --------------------------------------------------------
int __fastcall sub_72230(_DWORD *a1)
{
  if ( !a1 || *a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      994,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  return a1[6];
}

//----- (000722B8) --------------------------------------------------------
bool __fastcall sub_722B8(_DWORD *a1, const char *a2)
{
  void *v3; // r0
  void *v4; // r0
  const char *v6; // [sp+4h] [bp-10h]

  if ( !a1 || *a1 != 1281582695 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      1001,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
  v3 = (void *)a1[8];
  if ( a2 && *a2 )
  {
    if ( v3 )
    {
      v6 = a2;
      free(v3);
      a2 = v6;
    }
    v4 = sub_63D08(a2);
    a1[8] = v4;
    return v4 == 0;
  }
  else
  {
    if ( v3 )
      free(v3);
    a1[8] = 0;
    return 0;
  }
}

//----- (0007239C) --------------------------------------------------------
int __fastcall sub_7239C(_DWORD *a1)
{
  if ( !a1 || *a1 != 1281582695 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      1021,
      0,
      "(((lcfg) != ((void *)0)) && (((const isc__magic_t *)(lcfg))->magic == ((('L') << 24 | ('c') << 16 | ('f') << 8 | ('g')))))");
  return a1[8];
}

//----- (00072424) --------------------------------------------------------
void __fastcall sub_72424(const char *ident, int option, int facility)
{
  openlog(ident, option, facility);
}

//----- (0007246C) --------------------------------------------------------
int __fastcall sub_7246C(int a1)
{
  pthread_mutex_t *v2; // r6
  _DWORD *i; // r4
  FILE *v4; // r0
  int result; // r0

  if ( !a1 || *(_DWORD *)a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      1036,
      0,
      "(((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c') << 16 | ('t') << 8 | ('x')))))");
  v2 = (pthread_mutex_t *)(a1 + 28);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 28)) )
    sub_6F61C("./../lib/isc/log.c", 1038, "((pthread_mutex_lock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
  for ( i = *(_DWORD **)(*(_DWORD *)(a1 + 52) + 8); i; i = (_DWORD *)i[13] )
  {
    while ( 1 )
    {
      if ( i[1] == 3 )
      {
        v4 = (FILE *)i[4];
        if ( v4 )
          break;
      }
      i = (_DWORD *)i[13];
      if ( !i )
        goto LABEL_10;
    }
    fclose(v4);
    i[4] = 0;
  }
LABEL_10:
  result = pthread_mutex_unlock(v2);
  if ( result )
    sub_6F61C("./../lib/isc/log.c", 1048, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
  return result;
}

//----- (000725B8) --------------------------------------------------------
int __fastcall sub_725B8(int a1, int a2)
{
  int result; // r0
  int v4; // r3

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 52);
  if ( !v4 )
    return 0;
  if ( *(_DWORD *)(v4 + 28) >= a2 )
    return 1;
  result = *(_DWORD *)(v4 + 36);
  if ( result )
    return *(_DWORD *)(a1 + 24) >= a2;
  return result;
}

//----- (00072648) --------------------------------------------------------
int __fastcall sub_72648(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7, int a8, int a9, int *a10)
{
  int result; // r0
  int v12; // r11
  int v13; // r0
  _DWORD *v14; // r3
  _BOOL4 v15; // r2
  unsigned int v16; // r7
  unsigned int v17; // r11
  int v18; // r6
  int v19; // r8
  int v20; // r0
  int v21; // r7
  int v22; // r9
  int v23; // r11
  int v24; // r0
  int v25; // r1
  _DWORD *v26; // r5
  bool v27; // zf
  int v28; // r4
  int v29; // r3
  int v30; // r2
  int v31; // r3
  _BYTE *v32; // lr
  int v33; // r0
  int v34; // lr
  __int64 v35; // r0
  int v36; // r12
  unsigned int v37; // r0
  int v38; // r3
  const char *v39; // r0
  const char *v40; // r0
  const char *v41; // r3
  const char *v42; // r8
  const char *v43; // r2
  const char *v44; // r6
  const char *v45; // r12
  const char *v46; // r1
  const char *v47; // r7
  const char *v48; // r9
  const char *v49; // r11
  int v50; // r0
  int v51; // r9
  size_t v52; // r8
  __time_t *v53; // r0
  __time_t *v54; // r7
  __time_t v55; // r3
  int v56; // r0
  const char *v57; // r3
  const char *v58; // lr
  const char *v59; // r2
  const char *v60; // r4
  const char *v61; // r12
  const char *v62; // r6
  const char *v63; // r1
  const char *v64; // r8
  const char *v65; // r9
  const char *v66; // r0
  int v67; // r3
  int v68; // r2
  void *v69; // r0
  int v70; // r0
  bool v71; // zf
  int v74; // [sp+30h] [bp-16Ch]
  unsigned __int8 *v76; // [sp+3Ch] [bp-160h]
  pthread_mutex_t *mutex; // [sp+54h] [bp-148h]
  int v78; // [sp+58h] [bp-144h]
  unsigned int v79; // [sp+58h] [bp-144h]
  const char *v80; // [sp+5Ch] [bp-140h]
  const char *v81; // [sp+5Ch] [bp-140h]
  __time_t v82[2]; // [sp+60h] [bp-13Ch] BYREF
  _BYTE v83[48]; // [sp+68h] [bp-134h] BYREF
  __int64 v84; // [sp+98h] [bp-104h]
  __time_t v85[4]; // [sp+D0h] [bp-CCh] BYREF
  int v86; // [sp+E0h] [bp-BCh]
  __int64 v87; // [sp+100h] [bp-9Ch]
  _BYTE v88[24]; // [sp+13Ch] [bp-60h] BYREF
  char v89[64]; // [sp+154h] [bp-48h] BYREF

  v27 = a1 == 0;
  result = 2092;
  v76 = (unsigned __int8 *)a9;
  if ( !v27 && *(_DWORD *)a1 != 1281586296 )
    sub_6ECC0(
      "./../lib/isc/log.c",
      1424,
      0,
      "lctx == ((void *)0) || (((lctx) != ((void *)0)) && (((const isc__magic_t *)(lctx))->magic == ((('L') << 24 | ('c')"
      " << 16 | ('t') << 8 | ('x')))))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/log.c", 1425, 0, "category != ((void *)0)");
  if ( !a3 )
    sub_6ECC0("./../lib/isc/log.c", 1426, 0, "module != ((void *)0)");
  if ( !a4 )
    sub_6ECC0("./../lib/isc/log.c", 1427, 0, "level != 0");
  if ( !a9 )
    sub_6ECC0("./../lib/isc/log.c", 1428, 0, "format != ((void *)0)");
  if ( a1 )
  {
    if ( *(_DWORD *)(a2 + 4) >= *(_DWORD *)(a1 + 12) )
      sub_6ECC0("./../lib/isc/log.c", 1438, 0, "category->id < lctx->category_count");
    if ( *(_DWORD *)(a3 + 4) >= *(_DWORD *)(a1 + 20) )
      sub_6ECC0("./../lib/isc/log.c", 1439, 0, "module->id < lctx->module_count");
    result = sub_725B8(a1, a4);
    if ( result )
    {
      if ( a6 )
        v76 = (unsigned __int8 *)sub_73830(a6, a7, a8, a9);
      mutex = (pthread_mutex_t *)(a1 + 28);
      v89[0] = 0;
      v88[0] = 0;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 28)) )
        sub_6F61C("./../lib/isc/log.c", 1452, "((pthread_mutex_lock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
      v12 = *(_DWORD *)(a1 + 52);
      v13 = 0;
      *(_BYTE *)(a1 + 56) = 0;
      v74 = v12;
      v14 = *(_DWORD **)(*(_DWORD *)(v12 + 16) + 8 * *(_DWORD *)(a2 + 4));
      v15 = v14 == 0;
      while ( 1 )
      {
        if ( (v15 & (v13 ^ 1)) != 0 )
        {
          v14 = **(_DWORD ***)(v74 + 16);
          if ( !v14 )
            v14 = &unk_10724C;
        }
        v26 = (_DWORD *)v14[3];
        v27 = *v14 == a3;
        if ( *v14 != a3 )
          v27 = *v14 == 0;
        if ( !v27 )
        {
          v25 = v13;
          goto LABEL_32;
        }
        v28 = v14[1];
        v29 = *(_DWORD *)(v28 + 12);
        if ( (v29 & 0x1000) != 0 && !*(_DWORD *)(a1 + 24) )
          goto LABEL_31;
        v30 = *(_DWORD *)(v28 + 8);
        if ( v30 )
        {
          if ( v30 < a4 )
            goto LABEL_31;
        }
        else if ( *(_DWORD *)(a1 + 24) < a4 )
        {
          goto LABEL_31;
        }
        if ( (v29 & 1) != 0 && !v89[0] )
        {
          if ( sub_75FE8(v85) )
            sub_6F61C("./../lib/isc/log.c", 1515, "isc_time_now((&isctime)) == 0");
          sub_769F8(v85, v89, 0x40u);
          v29 = *(_DWORD *)(v28 + 12);
        }
        if ( (v29 & 2) != 0 && !v88[0] )
        {
          if ( a4 < -5 )
          {
            v66 = (const char *)sub_73830((_DWORD *)isc_msgcat, 10, 802, (int)"level");
            sub_6C054((int)v88, 0x18u, "%s %d: ", v66, a4);
          }
          else if ( a4 <= 0 )
          {
            sub_6C054((int)v88, 0x18u, "%s: ", (const char *)*(&off_B51E8 - a4));
          }
          else
          {
            sub_6C054((int)v88, 0x18u, "%s %d: ", "debug", a4);
          }
        }
        v16 = *(unsigned __int8 *)(a1 + 56);
        if ( !*(_BYTE *)(a1 + 56) )
        {
          sub_6B6F8(a1 + 56, 0x2000u, v76, a10);
          if ( a5 )
          {
            sub_75CAC(v85, *(_DWORD *)(v74 + 24), v16);
            if ( sub_75FE8(v82) )
              sub_6F61C("./../lib/isc/log.c", 1562, "isc_time_now((&oldest)) == 0");
            if ( !sub_765A8((unsigned int *)v82, (unsigned int *)v85, (unsigned int *)v82) )
            {
              v51 = *(_DWORD *)(a1 + 8248);
              while ( v51 )
              {
                while ( sub_76378((unsigned int *)(v51 + 4), (unsigned int *)v82) >= 0 )
                {
                  if ( !strcmp((const char *)(a1 + 56), *(const char **)v51) )
                  {
                    result = pthread_mutex_unlock(mutex);
                    if ( result )
                      sub_6F61C(
                        "./../lib/isc/log.c",
                        1614,
                        "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
                    return result;
                  }
                  v51 = *(_DWORD *)(v51 + 16);
                  if ( !v51 )
                    goto LABEL_86;
                }
                v67 = *(_DWORD *)(v51 + 16);
                if ( v67 )
                {
                  *(_DWORD *)(v67 + 12) = *(_DWORD *)(v51 + 12);
                  v68 = *(_DWORD *)(v51 + 12);
                }
                else
                {
                  if ( *(_DWORD *)(a1 + 8252) != v51 )
                    sub_6ECC0("./../lib/isc/log.c", 1592, 2, "(lctx->messages).tail == (message)");
                  v68 = *(_DWORD *)(v51 + 12);
                  *(_DWORD *)(a1 + 8252) = v68;
                }
                if ( v68 )
                {
                  *(_DWORD *)(v68 + 16) = v67;
                }
                else
                {
                  if ( *(_DWORD *)(a1 + 8248) != v51 )
                    sub_6ECC0("./../lib/isc/log.c", 1592, 2, "(lctx->messages).head == (message)");
                  *(_DWORD *)(a1 + 8248) = v67;
                }
                v69 = (void *)v51;
                v51 = v67;
                free(v69);
              }
            }
LABEL_86:
            v52 = strlen((const char *)(a1 + 56));
            v53 = (__time_t *)sub_63BA4(0, v52 + 21, 0, 0);
            v54 = v53;
            if ( v53 )
            {
              *v53 = (__time_t)(v53 + 5);
              sub_6D4DC((_BYTE *)v53 + 20, (unsigned __int8 *)(a1 + 56), v52 + 1);
              if ( sub_75FE8(v54 + 1) )
                sub_6F61C("./../lib/isc/log.c", 1637, "isc_time_now((&new->time)) == 0");
              v55 = *(_DWORD *)(a1 + 8252);
              if ( v55 )
                *(_DWORD *)(v55 + 16) = v54;
              else
                *(_DWORD *)(a1 + 8248) = v54;
              v54[3] = v55;
              v54[4] = 0;
              *(_DWORD *)(a1 + 8252) = v54;
            }
          }
        }
        v17 = *(_DWORD *)(v28 + 12);
        v18 = v17 & 0x10;
        v19 = v17 & 1;
        if ( (v17 & 0x10) != 0 )
          v18 = *(_DWORD *)(v74 + 32) != 0;
        v20 = *(_DWORD *)(v28 + 4);
        v21 = (v17 >> 2) & 1;
        v22 = (v17 >> 3) & 1;
        v23 = (v17 >> 1) & 1;
        if ( v20 != 3 )
        {
          if ( v20 == 4 )
          {
            v24 = *(_DWORD *)(v28 + 16);
            goto LABEL_64;
          }
          if ( v20 == 2 )
          {
            if ( a4 <= 0 )
            {
              if ( a4 >= -5 )
                v20 = *(_DWORD *)&asc_9CA04[-4 * a4];
            }
            else
            {
              v20 = 7;
            }
            v56 = v20 | *(_DWORD *)(v28 + 16);
            if ( v19 )
            {
              v57 = v89;
              v58 = " ";
            }
            else
            {
              v57 = (const char *)&unk_97F7C;
              v58 = (const char *)&unk_97F7C;
            }
            if ( v18 )
            {
              v59 = *(const char **)(v74 + 32);
              v60 = ": ";
            }
            else
            {
              v59 = (const char *)&unk_97F7C;
              v60 = (const char *)&unk_97F7C;
            }
            if ( v21 )
            {
              v61 = *(const char **)a2;
              v62 = ": ";
            }
            else
            {
              v61 = (const char *)&unk_97F7C;
              v62 = (const char *)&unk_97F7C;
            }
            if ( v22 )
            {
              v63 = *(const char **)a3;
              v64 = ": ";
            }
            else
            {
              v63 = (const char *)&unk_97F7C;
              v64 = (const char *)&unk_97F7C;
            }
            if ( v23 )
              v65 = v88;
            else
              v65 = (const char *)&unk_97F7C;
            _syslog_chk(
              v56,
              1,
              "%s%s%s%s%s%s%s%s%s%s",
              v57,
              v58,
              v59,
              v60,
              v61,
              v62,
              v63,
              v64,
              v65,
              (const char *)(a1 + 56));
            v25 = 1;
            v13 = 1;
            goto LABEL_32;
          }
          goto LABEL_31;
        }
        if ( *(_DWORD *)(v28 + 40) )
        {
          if ( *(_DWORD *)(v28 + 24) == -2
            && (!_xstat64(3, *(_DWORD *)(v28 + 20), v83) || *_errno_location() != 2)
            && v84 >= *(_QWORD *)(v28 + 32) )
          {
            goto LABEL_31;
          }
          fclose(*(FILE **)(v28 + 16));
          v31 = *(_DWORD *)(v28 + 4);
          *(_DWORD *)(v28 + 16) = 0;
          *(_DWORD *)(v28 + 40) = 0;
          if ( v31 != 3 )
            sub_6ECC0("./../lib/isc/log.c", 1326, 0, "channel->type == 3");
        }
        else
        {
          v24 = *(_DWORD *)(v28 + 16);
          if ( v24 )
            goto LABEL_64;
        }
        v32 = *(_BYTE **)(v28 + 20);
        if ( !v32 || !*v32 )
          sub_6ECC0("./../lib/isc/log.c", 1331, 0, "path != ((void *)0) && *path != '\\0'");
        v78 = *(_DWORD *)(v28 + 20);
        v33 = _xstat64(3, v78, v85);
        v34 = v78;
        if ( !v33 )
        {
          v35 = *(_QWORD *)(v28 + 32);
          v36 = v86 & 0xF000;
          if ( v35 )
          {
            if ( v35 < 1 || v87 < v35 || v36 != 0x8000 )
              goto LABEL_144;
            if ( *(_DWORD *)(v28 + 24) == -2 )
              goto LABEL_31;
          }
          else if ( *(_DWORD *)(v28 + 24) == -2 || v36 != 0x8000 )
          {
            goto LABEL_144;
          }
          v37 = sub_707C8(v28);
          v34 = v78;
          v79 = v37;
          if ( v37 )
          {
            v38 = *(_DWORD *)(v28 + 12);
            if ( (v38 & 0x8000) == 0 )
            {
              v80 = *(const char **)(v28 + 20);
              v39 = (const char *)sub_754A0(v37);
              _syslog_chk(3, 1, "isc_log_open: roll_log '%s' failed: %s", v80, v39);
              v38 = *(_DWORD *)(v28 + 12) | 0x8000;
              *(_DWORD *)(v28 + 12) = v38;
            }
            if ( v79 == 58 || (v38 & 0x8000) != 0 )
              goto LABEL_31;
LABEL_61:
            v81 = *(const char **)(v28 + 20);
            v40 = (const char *)sub_754A0(v79);
            _syslog_chk(3, 1, "isc_log_open '%s' failed: %s", v81, v40);
            *(_DWORD *)(v28 + 12) |= 0x8000u;
            goto LABEL_62;
          }
        }
LABEL_144:
        v70 = sub_75654(v34, (int)&off_99960, (int *)(v28 + 16));
        v71 = v70 == 0;
        if ( v70 )
          v71 = v70 == 58;
        v79 = v70;
        if ( !v71 && (*(_DWORD *)(v28 + 12) & 0x8000) == 0 )
          goto LABEL_61;
LABEL_62:
        if ( !v79 )
        {
          v24 = *(_DWORD *)(v28 + 16);
          *(_DWORD *)(v28 + 12) &= ~0x8000u;
LABEL_64:
          if ( v19 )
          {
            v41 = v89;
            v42 = " ";
          }
          else
          {
            v41 = (const char *)&unk_97F7C;
            v42 = (const char *)&unk_97F7C;
          }
          if ( v18 )
          {
            v43 = *(const char **)(v74 + 32);
            v44 = ": ";
            if ( v21 )
              goto LABEL_68;
LABEL_108:
            v45 = (const char *)&unk_97F7C;
            v46 = (const char *)&unk_97F7C;
            if ( !v22 )
              goto LABEL_109;
LABEL_69:
            v47 = *(const char **)a3;
            v48 = ": ";
          }
          else
          {
            v43 = (const char *)&unk_97F7C;
            v44 = (const char *)&unk_97F7C;
            if ( !v21 )
              goto LABEL_108;
LABEL_68:
            v45 = *(const char **)a2;
            v46 = ": ";
            if ( v22 )
              goto LABEL_69;
LABEL_109:
            v48 = (const char *)&unk_97F7C;
            v47 = (const char *)&unk_97F7C;
          }
          if ( v23 )
            v49 = v88;
          else
            v49 = (const char *)&unk_97F7C;
          _fprintf_chk(
            v24,
            1,
            "%s%s%s%s%s%s%s%s%s%s\n",
            v41,
            v42,
            v43,
            v44,
            v45,
            v46,
            v47,
            v48,
            v49,
            (const char *)(a1 + 56));
          fflush(*(FILE **)(v28 + 16));
          if ( *(__int64 *)(v28 + 32) >= 1 )
          {
            if ( *(_DWORD *)(v28 + 4) != 3 )
              sub_6ECC0("./../lib/isc/log.c", 1723, 2, "channel->type == 3");
            v50 = fileno(*(FILE **)(v28 + 16));
            if ( _fxstat64(3, v50, v83) >= 0 && *(_QWORD *)(v28 + 32) < v84 )
            {
              v25 = 1;
              *(_DWORD *)(v28 + 40) = 1;
              v13 = 1;
              goto LABEL_32;
            }
          }
        }
LABEL_31:
        v25 = 1;
        v13 = 1;
LABEL_32:
        v14 = v26;
        v15 = v26 == 0;
        if ( (v15 & v25) != 0 )
        {
          result = pthread_mutex_unlock(mutex);
          if ( result )
            sub_6F61C("./../lib/isc/log.c", 1766, "((pthread_mutex_unlock(((&lctx->lock))) == 0) ? 0 : 34) == 0");
          return result;
        }
      }
    }
  }
  return result;
}
// B6C8: using guessed type int __fastcall _fxstat64(_DWORD, _DWORD, _DWORD);
// BB48: using guessed type int _syslog_chk(_DWORD, _DWORD, const char *, ...);
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// BCE0: using guessed type int _fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 99960: using guessed type _UNKNOWN *off_99960;
// B51E8: using guessed type _UNKNOWN *off_B51E8;
// 107248: using guessed type int isc_msgcat;

//----- (00073300) --------------------------------------------------------
int sub_73300(int a1, int a2, int a3, int a4, int a5, ...)
{
  va_list va; // [sp+34h] [bp+14h] BYREF

  va_start(va, a5);
  return sub_72648(a1, a2, a3, a4, 0, 0, 0, 0, a5, (int *)va);
}

//----- (0007344C) --------------------------------------------------------
int __fastcall sub_7344C(int a1, int a2, int a3, int a4, int a5, int *a6)
{
  return sub_72648(a1, a2, a3, a4, 1, 0, 0, 0, a5, a6);
}

//----- (000734BC) --------------------------------------------------------
int sub_734BC(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, int a8, ...)
{
  va_list va; // [sp+40h] [bp+20h] BYREF

  va_start(va, a8);
  return sub_72648(a1, a2, a3, a4, 0, a5, a6, a7, a8, (int *)va);
}

//----- (000735B0) --------------------------------------------------------
int sub_735B0(int a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, int a8, ...)
{
  va_list va; // [sp+40h] [bp+20h] BYREF

  va_start(va, a8);
  return sub_72648(a1, a2, a3, a4, 1, a5, a6, a7, a8, (int *)va);
}

//----- (000736A4) --------------------------------------------------------
_DWORD *__fastcall sub_736A4(int a1, _DWORD *a2)
{
  _DWORD *result; // r0
  int v4; // r3

  if ( !a1 )
    sub_6ECC0("./../lib/isc/nls/msgcat.c", 64, 0, "name != ((void *)0)");
  if ( !a2 || *a2 )
    sub_6ECC0("./../lib/isc/nls/msgcat.c", 65, 0, "msgcatp != ((void *)0) && *msgcatp == ((void *)0)");
  result = malloc(4u);
  if ( result )
    LOWORD(v4) = 24948;
  else
    *a2 = 0;
  if ( result )
  {
    HIWORD(v4) = 19779;
    *a2 = result;
    *result = v4;
  }
  return result;
}
// 73704: variable 'v4' is possibly undefined

//----- (00073770) --------------------------------------------------------
void __fastcall sub_73770(_DWORD **a1)
{
  _DWORD *v2; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/nls/msgcat.c", 94, 0, "msgcatp != ((void *)0)");
  v2 = *a1;
  if ( *a1 )
  {
    if ( *v2 != 1296261492 )
      sub_6ECC0(
        "./../lib/isc/nls/msgcat.c",
        96,
        0,
        "(((msgcat) != ((void *)0)) && (((const isc__magic_t *)(msgcat))->magic == ((('M') << 24 | ('C') << 16 | ('a') <<"
        " 8 | ('t'))))) || msgcat == ((void *)0)");
    free(v2);
  }
  *a1 = 0;
}

//----- (00073830) --------------------------------------------------------
int __fastcall sub_73830(_DWORD *a1, int a2, int a3, int a4)
{
  if ( a1 && *a1 != 1296261492 )
    sub_6ECC0(
      "./../lib/isc/nls/msgcat.c",
      119,
      0,
      "(((msgcat) != ((void *)0)) && (((const isc__magic_t *)(msgcat))->magic == ((('M') << 24 | ('C') << 16 | ('a') << 8"
      " | ('t'))))) || msgcat == ((void *)0)");
  if ( a2 <= 0 )
    sub_6ECC0("./../lib/isc/nls/msgcat.c", 120, 0, "set > 0");
  if ( a3 <= 0 )
    sub_6ECC0("./../lib/isc/nls/msgcat.c", 121, 0, "message > 0");
  if ( !a4 )
    sub_6ECC0("./../lib/isc/nls/msgcat.c", 122, 0, "default_text != ((void *)0)");
  return a4;
}
// 6ECC0: using guessed type void __fastcall __noreturn sub_6ECC0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007393C) --------------------------------------------------------
int __fastcall sub_7393C(int a1)
{
  int v2; // r0
  int v3; // r6
  int v4; // r4
  int v6; // r0
  const char *v7; // r0
  socklen_t len; // [sp+Ch] [bp-A8h] BYREF
  struct sockaddr addr; // [sp+10h] [bp-A4h] BYREF
  char v10[128]; // [sp+2Ch] [bp-88h] BYREF

  v2 = socket(a1, 1, 0);
  if ( v2 != -1 )
  {
    v3 = v2;
    if ( a1 != 10 )
      goto LABEL_3;
    len = 28;
    if ( getsockname(v2, &addr, &len) < 0 )
    {
      v4 = 23;
      sub_73300(
        isc_lctx,
        (int)&off_B7DC4,
        (int)&isc_modules,
        -4,
        (int)"retrieving the address of an IPv6 socket from the kernel failed.");
      sub_73300(isc_lctx, (int)&off_B7DC4, (int)&isc_modules, -4, (int)"IPv6 is not supported.");
      goto LABEL_4;
    }
    if ( len == 28 )
    {
LABEL_3:
      v4 = 0;
    }
    else
    {
      v4 = 23;
      sub_73300(
        isc_lctx,
        (int)&off_B7DC4,
        (int)&isc_modules,
        -4,
        (int)"IPv6 structures in kernel and user space do not match.");
      sub_73300(isc_lctx, (int)&off_B7DC4, (int)&isc_modules, -4, (int)"IPv6 is not supported.");
    }
LABEL_4:
    close(v3);
    return v4;
  }
  v6 = *_errno_location();
  if ( v6 == 93 || v6 == 97 || v6 == 22 )
    return 23;
  sub_75B10(v6, (int)v10, 0x80u);
  v4 = 34;
  v7 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
  sub_6F554("./../lib/isc/unix/net.c", 144, (int)"socket() %s: %s", v7, v10);
  return v4;
}
// B7D8C: using guessed type _UNKNOWN *isc_modules;
// B7DC4: using guessed type char *;
// 107248: using guessed type int isc_msgcat;
// 10725C: using guessed type int isc_lctx;

//----- (00073B50) --------------------------------------------------------
int sub_73B50()
{
  int result; // r0

  dword_B7DD4 = sub_7393C(2);
  result = sub_7393C(10);
  dword_B7DD8 = result;
  return result;
}
// B7DD4: using guessed type int dword_B7DD4;
// B7DD8: using guessed type int dword_B7DD8;

//----- (00073BB8) --------------------------------------------------------
int sub_73BB8()
{
  int result; // r0

  result = pthread_once(&dword_107260, (void (*)(void))sub_73B50);
  if ( result )
    sub_6F61C("./../lib/isc/unix/net.c", 221, "((pthread_once((&once), (initialize_action)) == 0) ? 0 : 34) == 0");
  return result;
}
// 107260: using guessed type pthread_once_t dword_107260;

//----- (00073C50) --------------------------------------------------------
int sub_73C50()
{
  sub_73BB8();
  return dword_B7DD4;
}
// B7DD4: using guessed type int dword_B7DD4;

//----- (00073CA8) --------------------------------------------------------
int sub_73CA8()
{
  sub_73BB8();
  return dword_B7DD8;
}
// B7DD8: using guessed type int dword_B7DD8;

//----- (00073D00) --------------------------------------------------------
int sub_73D00()
{
  int result; // r0
  int v1; // r0
  int v2; // r7
  int v3; // r0
  int *v4; // r0
  const char *v5; // r0
  int *v6; // r0
  const char *v7; // r0
  int v8; // [sp+8h] [bp-88h] BYREF
  char v9[128]; // [sp+Ch] [bp-84h] BYREF

  result = sub_73CA8();
  if ( !result )
  {
    v1 = socket(10, 1, 0);
    v2 = v1;
    if ( v1 == -1 )
    {
      v4 = _errno_location();
      sub_75B10(*v4, (int)v9, 0x80u);
      v5 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
      result = sub_6F554("./../lib/isc/unix/net.c", 266, (int)"socket() %s: %s", v5, v9);
      dword_B7DDC = 34;
      return result;
    }
    v8 = 1;
    if ( setsockopt(v1, 41, 26, &v8, 4u) >= 0 )
    {
      close(v2);
      v3 = socket(10, 2, 0);
      v2 = v3;
      if ( v3 == -1 )
      {
        v6 = _errno_location();
        sub_75B10(*v6, (int)v9, 0x80u);
        v7 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
        result = sub_6F554("./../lib/isc/unix/net.c", 289, (int)"socket() %s: %s", v7, v9);
        dword_B7DDC = 34;
        return result;
      }
      v8 = 1;
      if ( setsockopt(v3, 41, 26, &v8, 4u) < 0 )
        dword_B7DDC = 23;
      else
        dword_B7DDC = 0;
    }
    else
    {
      dword_B7DDC = 23;
    }
    return close(v2);
  }
  dword_B7DDC = result;
  return result;
}
// B7DDC: using guessed type int dword_B7DDC;
// 107248: using guessed type int isc_msgcat;

//----- (00073F34) --------------------------------------------------------
int sub_73F34()
{
  int result; // r0
  int v1; // r0
  int v2; // r7
  int *v3; // r0
  const char *v4; // r0
  int v5; // [sp+8h] [bp-8Ch] BYREF
  char v6[128]; // [sp+Ch] [bp-88h] BYREF

  result = sub_73CA8();
  if ( result )
  {
    dword_B7DE0 = result;
  }
  else
  {
    v1 = socket(10, 2, 17);
    v2 = v1;
    if ( v1 == -1 )
    {
      v3 = _errno_location();
      sub_75B10(*v3, (int)v6, 0x80u);
      v4 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
      result = sub_6F554("./../lib/isc/unix/net.c", 338, (int)"socket() %s: %s", v4, v6);
      dword_B7DE0 = 34;
    }
    else
    {
      v5 = 1;
      if ( setsockopt(v1, 41, 49, &v5, 4u) < 0 )
        dword_B7DE0 = 23;
      else
        dword_B7DE0 = 0;
      return close(v2);
    }
  }
  return result;
}
// B7DE0: using guessed type int dword_B7DE0;
// 107248: using guessed type int isc_msgcat;

//----- (0007408C) --------------------------------------------------------
int sub_7408C()
{
  sub_73BB8();
  return 23;
}

//----- (000740D8) --------------------------------------------------------
int sub_740D8()
{
  if ( pthread_once(&dword_107264, (void (*)(void))sub_73D00) )
    sub_6F61C("./../lib/isc/unix/net.c", 317, "((pthread_once((&once_ipv6only), (try_ipv6only)) == 0) ? 0 : 34) == 0");
  return dword_B7DDC;
}
// B7DDC: using guessed type int dword_B7DDC;
// 107264: using guessed type pthread_once_t dword_107264;

//----- (00074174) --------------------------------------------------------
int sub_74174()
{
  if ( pthread_once(&dword_107268, (void (*)(void))sub_73F34) )
    sub_6F61C(
      "./../lib/isc/unix/net.c",
      370,
      "((pthread_once((&once_ipv6pktinfo), (try_ipv6pktinfo)) == 0) ? 0 : 34) == 0");
  return dword_B7DE0;
}
// B7DE0: using guessed type int dword_B7DE0;
// 107268: using guessed type pthread_once_t dword_107268;

//----- (00074210) --------------------------------------------------------
int __fastcall sub_74210(int a1, _WORD *a2, _WORD *a3)
{
  int v3; // r0

  v3 = (int)a3;
  if ( a3 )
    v3 = 1;
  if ( !a2 )
    v3 = 0;
  if ( !v3 )
    sub_6ECC0("./../lib/isc/unix/net.c", 481, 0, "low != ((void *)0) && high != ((void *)0)");
  *a2 = 1024;
  *a3 = -1;
  return 0;
}

//----- (000742A4) --------------------------------------------------------
int sub_742A4()
{
  int result; // r0

  result = sub_73BB8();
  if ( !dword_B7DD4 )
    dword_B7DD4 = 57;
  return result;
}
// B7DD4: using guessed type int dword_B7DD4;

//----- (00074308) --------------------------------------------------------
int sub_74308()
{
  int result; // r0

  result = sub_73BB8();
  if ( !dword_B7DD8 )
    dword_B7DD8 = 57;
  return result;
}
// B7DD8: using guessed type int dword_B7DD8;

//----- (0007436C) --------------------------------------------------------
int sub_7436C()
{
  int result; // r0

  result = sub_73BB8();
  if ( dword_B7DD4 == 57 )
    dword_B7DD4 = 0;
  return result;
}
// B7DD4: using guessed type int dword_B7DD4;

//----- (000743D0) --------------------------------------------------------
int sub_743D0()
{
  int result; // r0

  result = sub_73BB8();
  if ( dword_B7DD8 == 57 )
    dword_B7DD8 = 0;
  return result;
}
// B7DD8: using guessed type int dword_B7DD8;

//----- (00074434) --------------------------------------------------------
bool __fastcall sub_74434(int *a1, _DWORD *a2)
{
  int v2; // r2
  int v3; // r3

  v2 = (int)a2;
  if ( a2 )
    v2 = 1;
  if ( !a1 )
    v2 = 0;
  if ( !v2 )
    sub_6ECC0("./../lib/isc/netaddr.c", 38, 0, "a != ((void *)0) && b != ((void *)0)");
  v3 = *a1;
  if ( *a1 != *a2 || a1[5] != a2[5] )
    return 0;
  if ( v3 != 2 )
  {
    if ( v3 == 10 )
      return memcmp(a1 + 1, a2 + 1, 0x10u) == 0;
    return 0;
  }
  return a1[1] == a2[1];
}

//----- (00074518) --------------------------------------------------------
bool __fastcall sub_74518(_DWORD *a1, _DWORD *a2, unsigned int a3)
{
  int v3; // r12
  int v4; // r12
  int v6; // r3
  int v7; // lr
  bool v8; // zf
  unsigned __int8 *v9; // r8
  unsigned __int8 *v10; // r7
  unsigned int v11; // r5
  unsigned int v12; // r10

  v3 = (int)a2;
  if ( a2 )
    v3 = 1;
  if ( !a1 )
    v3 = 0;
  if ( !v3 )
    sub_6ECC0("./../lib/isc/netaddr.c", 78, 0, "a != ((void *)0) && b != ((void *)0)");
  v4 = *a1;
  if ( *a1 != *a2 )
    return 0;
  v6 = a2[5];
  v7 = a1[5];
  v8 = v7 == v6;
  if ( v7 != v6 )
    v8 = v6 == 0;
  if ( !v8 )
    return 0;
  if ( v4 == 2 )
  {
    v9 = (unsigned __int8 *)(a1 + 1);
    v10 = (unsigned __int8 *)(a2 + 1);
    v11 = 32;
    v12 = 4;
  }
  else
  {
    if ( v4 != 10 )
      return 0;
    v9 = (unsigned __int8 *)(a1 + 1);
    v10 = (unsigned __int8 *)(a2 + 1);
    v11 = 128;
    v12 = 16;
  }
  if ( a3 < v11 )
    v11 = a3;
  if ( v11 >> 3 && memcmp(v9, v10, v11 >> 3) )
    return 0;
  if ( (v11 & 7) == 0 )
    return 1;
  if ( v12 <= v11 >> 3 )
    sub_6ECC0("./../lib/isc/netaddr.c", 116, 2, "nbytes < ipabytes");
  return ((v9[v11 >> 3] ^ v10[v11 >> 3]) & (255 << (8 - (v11 & 7)))) == 0;
}

//----- (00074680) --------------------------------------------------------
int __fastcall sub_74680(int *a1, _DWORD *a2)
{
  int v3; // r0
  size_t v5; // r0
  size_t v6; // r8
  unsigned int v7; // r3
  size_t v8; // r4
  signed int v10; // r0
  _BYTE v11[12]; // [sp+0h] [bp-40h] BYREF
  char buf[48]; // [sp+Ch] [bp-34h] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/netaddr.c", 136, 0, "netaddr != ((void *)0)");
  v3 = *a1;
  if ( *a1 != 2 && v3 != 10 || !inet_ntop(v3, a1 + 1, buf, 0x2Eu) )
    return 25;
  v5 = strlen(buf);
  v6 = v5;
  if ( v5 > 0x2D )
    sub_6ECC0("./../lib/isc/netaddr.c", 163, 2, "alen < sizeof(abuf)");
  if ( *a1 != 10 )
  {
    v7 = v5;
    v8 = 0;
    goto LABEL_9;
  }
  v8 = a1[5];
  if ( v8 )
  {
    v10 = sub_6C054((int)v11, 0xCu, "%%%u", v8);
    v8 = v10;
    if ( v10 >= 0 )
    {
      if ( v10 > 11 )
        sub_6ECC0("./../lib/isc/netaddr.c", 170, 2, "(unsigned int)zlen < sizeof(zbuf)");
      v7 = v6 + v10;
      goto LABEL_9;
    }
    return 25;
  }
  v7 = v5;
LABEL_9:
  if ( a2[2] - a2[3] < v7 )
    return 19;
  sub_79DF0(a2, buf, v6);
  sub_79DF0(a2, v11, v8);
  return 0;
}

//----- (00074908) --------------------------------------------------------
int __fastcall sub_74908(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // r3
  int v3; // r12
  unsigned int v4; // r2
  char *v5; // r0

  if ( *a1 == 2 )
  {
    if ( a2 <= 0x20 )
    {
      v2 = a1 + 1;
      v3 = 4;
      goto LABEL_5;
    }
    return 41;
  }
  if ( *a1 != 10 )
    return 27;
  if ( a2 > 0x80 )
    return 41;
  v2 = a1 + 1;
  v3 = 16;
LABEL_5:
  v4 = a2 >> 3;
  v5 = (char *)v2 + (a2 >> 3);
  if ( (a2 & 7) != 0 )
  {
    if ( (*((unsigned __int8 *)v2 + (a2 >> 3)) & (255 >> (a2 & 7))) != 0 )
      return 25;
    ++v4;
    v5 = (char *)v2 + v4;
  }
  if ( !memcmp(v5, &unk_9D770, v3 - v4) )
    return 0;
  else
    return 25;
}

//----- (000749DC) --------------------------------------------------------
int __fastcall sub_749DC(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r0
  unsigned int v3; // lr
  char *v4; // r12
  unsigned int v5; // r2
  char v6; // r3
  int v7; // t1
  int v8; // r5
  unsigned int v10; // r3
  int v11; // r12
  char *v12; // r3
  char *v13; // r0

  if ( *a1 == 2 )
  {
    v2 = a1 + 1;
    v3 = 4;
  }
  else
  {
    if ( *a1 != 10 )
      return 27;
    v2 = a1 + 1;
    v3 = 16;
  }
  v4 = (char *)v2 - 1;
  v5 = 0;
  while ( 1 )
  {
    v7 = (unsigned __int8)*++v4;
    v6 = v7;
    if ( v7 != 255 )
      break;
    if ( v3 == ++v5 )
      goto LABEL_7;
  }
  if ( v3 <= v5 )
  {
    v3 = v5;
LABEL_7:
    v8 = 0;
LABEL_8:
    *a2 = v8 + 8 * v3;
    return 0;
  }
  v8 = 0;
  if ( v6 < 0 )
  {
    do
    {
      v6 *= 2;
      ++v8;
    }
    while ( v6 < 0 && v8 != 8 );
  }
  if ( !v6 )
  {
    v10 = v5 + 1;
    if ( v3 <= v5 + 1 )
    {
LABEL_23:
      v3 = v5;
      goto LABEL_8;
    }
    v11 = *((unsigned __int8 *)v2 + v10);
    v12 = (char *)v2 + v10;
    if ( !v11 )
    {
      v13 = (char *)v2 + v3 - 1;
      while ( v12 != v13 )
      {
        if ( *++v12 )
          return 37;
      }
      goto LABEL_23;
    }
  }
  return 37;
}

//----- (00074B04) --------------------------------------------------------
_DWORD *__fastcall sub_74B04(_DWORD *result, int *a2)
{
  int v2; // r3

  result[2] = 0;
  result[3] = 0;
  result[1] = 0;
  result[4] = 0;
  result[5] = 0;
  v2 = *a2;
  *result = 2;
  result[1] = v2;
  return result;
}

//----- (00074B70) --------------------------------------------------------
int __fastcall sub_74B70(_DWORD *a1, int *a2)
{
  _DWORD *v2; // r12
  int result; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  _DWORD *v7; // t0

  v2 = a1 + 1;
  a1[2] = 0;
  a1[3] = 0;
  a1[1] = 0;
  a1[4] = 0;
  a1[5] = 0;
  *a1 = 10;
  result = *a2;
  v7 = a2 + 1;
  v4 = a2[1];
  v5 = *++v7;
  v6 = v7[1];
  *v2 = result;
  v2[1] = v4;
  v2[2] = v5;
  v2[3] = v6;
  return result;
}

//----- (00074BE0) --------------------------------------------------------
int sub_74BE0()
{
  return 27;
}

//----- (00074C28) --------------------------------------------------------
_DWORD *__fastcall sub_74C28(_DWORD *result, int a2)
{
  if ( *result != 10 )
    sub_6ECC0("./../lib/isc/netaddr.c", 324, 0, "netaddr->family == 10");
  result[5] = a2;
  return result;
}

//----- (00074CA0) --------------------------------------------------------
int __fastcall sub_74CA0(int a1)
{
  return *(_DWORD *)(a1 + 20);
}

//----- (00074CE8) --------------------------------------------------------
_DWORD *__fastcall sub_74CE8(_DWORD *result, _DWORD *a2)
{
  int v2; // r12
  int v3; // r4
  int v4; // lr
  int v5; // r2
  int v6; // r2

  v2 = *(unsigned __int16 *)a2;
  *result = v2;
  if ( v2 == 2 )
  {
    v6 = a2[1];
    result[5] = 0;
    result[1] = v6;
  }
  else
  {
    if ( v2 != 10 )
      sub_6ECC0("./../lib/isc/netaddr.c", 358, 2, "0");
    v3 = a2[3];
    v4 = a2[4];
    v5 = a2[5];
    result[1] = a2[2];
    result[2] = v3;
    result[3] = v4;
    result[4] = v5;
    result[5] = a2[6];
  }
  return result;
}

//----- (00074DA8) --------------------------------------------------------
_DWORD *__fastcall sub_74DA8(_DWORD *result)
{
  result[3] = 0;
  result[4] = 0;
  result[2] = 0;
  result[5] = 0;
  result[1] = 0;
  *result = 2;
  return result;
}

//----- (00074E0C) --------------------------------------------------------
uint32_t __fastcall sub_74E0C(_DWORD *a1)
{
  _DWORD *v1; // r12
  uint32_t v3; // r1
  uint32_t v4; // r2
  uint32_t v5; // r3

  a1[5] = 0;
  *a1 = 10;
  v1 = a1 + 1;
  v3 = in6addr_any.in6_u.u6_addr32[1];
  v4 = in6addr_any.in6_u.u6_addr32[2];
  v5 = in6addr_any.in6_u.u6_addr32[3];
  *v1 = in6addr_any.in6_u.u6_addr32[0];
  v1[1] = v3;
  v1[2] = v4;
  v1[3] = v5;
  return in6addr_any.in6_u.u6_addr32[0];
}

//----- (00074E78) --------------------------------------------------------
bool __fastcall sub_74E78(_DWORD *a1)
{
  if ( *a1 == 2 )
    return (a1[1] & 0xF0) == 224;
  if ( *a1 == 10 )
    return *((unsigned __int8 *)a1 + 4) == 255;
  return 0;
}

//----- (00074F00) --------------------------------------------------------
int __fastcall sub_74F00(_DWORD *a1)
{
  bool v1; // zf
  int result; // r0

  v1 = *a1 == 2;
  if ( *a1 == 2 )
    result = a1[1];
  else
    result = 0;
  if ( v1 )
    return (result & 0xF0) == 240;
  return result;
}

//----- (00074F64) --------------------------------------------------------
int __fastcall sub_74F64(_DWORD *a1)
{
  bool v1; // zf
  int result; // r0

  v1 = *a1 == 10;
  if ( *a1 == 10 )
    result = a1[1] & 0xC0FF;
  else
    result = 0;
  if ( v1 )
    return result == 33022;
  return result;
}

//----- (00074FD0) --------------------------------------------------------
int __fastcall sub_74FD0(_DWORD *a1)
{
  bool v1; // zf
  int result; // r0

  v1 = *a1 == 10;
  if ( *a1 == 10 )
    result = a1[1] & 0xC0FF;
  else
    result = 0;
  if ( v1 )
    return result == 49406;
  return result;
}

//----- (0007503C) --------------------------------------------------------
_DWORD *__fastcall sub_7503C(_DWORD *result, _DWORD *a2)
{
  if ( *a2 != 10 )
    sub_6ECC0("./../lib/isc/netaddr.c", 428, 0, "s->family == 10");
  if ( a2[1] || a2[2] || a2[3] != -65536 )
    sub_6ECC0(
      "./../lib/isc/netaddr.c",
      429,
      0,
      "(__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (&src->type.in6); __a->__in6_u.__u6_addr3"
      "2[0] == 0 && __a->__in6_u.__u6_addr32[1] == 0 && __a->__in6_u.__u6_addr32[2] == __bswap_32 (0xffff); }))");
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  *result = 2;
  result[1] = a2[4];
  return result;
}

//----- (0007511C) --------------------------------------------------------
int __fastcall sub_7511C(int a1, unsigned int a2, int a3, int a4, int a5)
{
  _DWORD *v9; // r0
  int v10; // r4
  int result; // r0
  int v12; // r2

  if ( (_WORD)a1 )
    sub_6ECC0("./../lib/isc/result.c", 121, 0, "base % 65536 == 0");
  if ( a2 > 0x10000 )
    sub_6ECC0("./../lib/isc/result.c", 122, (unsigned __int16)a1, "nresults <= 65536");
  if ( !a3 )
    sub_6ECC0("./../lib/isc/result.c", 123, 0, "txt != ((void *)0)");
  v9 = malloc(0x1Cu);
  v10 = (int)v9;
  if ( !v9 )
    return 1;
  *v9 = a1;
  v9[1] = a2 - 1 + a1;
  v9[2] = a3;
  v9[3] = a4;
  v9[4] = a5;
  v9[5] = -1;
  v9[6] = -1;
  if ( pthread_mutex_lock(&stru_10726C) )
    sub_6F61C("./../lib/isc/result.c", 139, "((pthread_mutex_lock(((&lock))) == 0) ? 0 : 34) == 0");
  v12 = dword_107288;
  if ( dword_107288 )
    *(_DWORD *)(dword_107288 + 24) = v10;
  else
    dword_107284 = v10;
  *(_DWORD *)(v10 + 20) = v12;
  *(_DWORD *)(v10 + 24) = 0;
  dword_107288 = v10;
  result = pthread_mutex_unlock(&stru_10726C);
  if ( result )
    sub_6F61C("./../lib/isc/result.c", 143, "((pthread_mutex_unlock(((&lock))) == 0) ? 0 : 34) == 0");
  return result;
}
// 10726C: using guessed type pthread_mutex_t stru_10726C;
// 107284: using guessed type int dword_107284;
// 107288: using guessed type int dword_107288;

//----- (000752E0) --------------------------------------------------------
int sub_752E0()
{
  int result; // r0
  int v1; // r6
  const char *v2; // r0

  if ( sub_78614(&stru_10726C, "./../lib/isc/result.c", 152) )
    sub_6F61C("./../lib/isc/result.c", 152, "isc__mutex_init((&lock), \"./../lib/isc/result.c\", 152) == 0");
  dword_107284 = 0;
  dword_107288 = 0;
  result = sub_7511C(0, 0x3Eu, (int)off_B7DE4, isc_msgcat, 2);
  v1 = result;
  if ( result )
  {
    v2 = (const char *)sub_73830((_DWORD *)isc_msgcat, 1, 101, (int)"failed");
    return sub_6F554("./../lib/isc/result.c", 158, (int)"register_table() %s: %u", v2, v1);
  }
  return result;
}
// B7DE4: using guessed type char *off_B7DE4[23];
// 107248: using guessed type int isc_msgcat;
// 10726C: using guessed type pthread_mutex_t stru_10726C;
// 107284: using guessed type int dword_107284;
// 107288: using guessed type int dword_107288;

//----- (00075400) --------------------------------------------------------
int sub_75400()
{
  int result; // r0

  sub_703E8();
  result = pthread_once(&dword_10728C, (void (*)(void))sub_752E0);
  if ( result )
    sub_6F61C("./../lib/isc/result.c", 168, "((pthread_once((&once), (initialize_action)) == 0) ? 0 : 34) == 0");
  return result;
}
// 10728C: using guessed type pthread_once_t dword_10728C;

//----- (000754A0) --------------------------------------------------------
int __fastcall sub_754A0(unsigned int a1)
{
  pthread_mutex_t *lock; // r3
  int v3; // r4

  sub_75400();
  if ( pthread_mutex_lock(&stru_10726C) )
    sub_6F61C("./../lib/isc/result.c", 179, "((pthread_mutex_lock(((&lock))) == 0) ? 0 : 34) == 0");
  lock = &stru_10726C;
  while ( 1 )
  {
    lock = (pthread_mutex_t *)lock[1].__lock;
    if ( !lock )
      break;
    if ( lock->__lock <= a1 && lock->__count >= a1 )
    {
      v3 = sub_73830(
             (_DWORD *)lock->__kind,
             lock->__nusers,
             a1 - lock->__lock + 1,
             *(_DWORD *)(lock->__owner + 4 * (a1 - lock->__lock)));
      if ( v3 )
        goto LABEL_8;
      break;
    }
  }
  v3 = sub_73830((_DWORD *)isc_msgcat, 3, 1, (int)"(result code text not available)");
LABEL_8:
  if ( pthread_mutex_unlock(&stru_10726C) )
    sub_6F61C("./../lib/isc/result.c", 202, "((pthread_mutex_unlock(((&lock))) == 0) ? 0 : 34) == 0");
  return v3;
}
// 107248: using guessed type int isc_msgcat;
// 10726C: using guessed type pthread_mutex_t stru_10726C;

//----- (000755E0) --------------------------------------------------------
int __fastcall sub_755E0(int a1, unsigned int a2, int a3, int a4, int a5)
{
  sub_75400();
  return sub_7511C(a1, a2, a3, a4, a5);
}

//----- (00075654) --------------------------------------------------------
int __fastcall sub_75654(int a1, int a2, int *a3)
{
  int v4; // r0
  int *v6; // r0

  v4 = fopen64();
  if ( v4 )
  {
    *a3 = v4;
    return 0;
  }
  else
  {
    v6 = _errno_location();
    return sub_7A990(*v6, "./../lib/isc/unix/stdio.c", 36);
  }
}
// B98C: using guessed type int fopen64(void);

//----- (000756E4) --------------------------------------------------------
int __fastcall sub_756E4(FILE *a1)
{
  int result; // r0
  int *v2; // r0

  result = fclose(a1);
  if ( result )
  {
    v2 = _errno_location();
    return sub_7A990(*v2, "./../lib/isc/unix/stdio.c", 49);
  }
  return result;
}

//----- (00075768) --------------------------------------------------------
int __fastcall sub_75768(FILE *a1, int a2, int a3)
{
  int result; // r0
  int *v4; // r0

  result = fseek(a1, a2, a3);
  if ( result )
  {
    v4 = _errno_location();
    return sub_7A990(*v4, "./../lib/isc/unix/stdio.c", 60);
  }
  return result;
}

//----- (000757EC) --------------------------------------------------------
int __fastcall sub_757EC(void *a1, size_t a2, size_t a3, FILE *stream, size_t *a5)
{
  size_t v9; // r7
  int result; // r0
  int *v11; // r0

  clearerr(stream);
  v9 = fread(a1, a2, a3, stream);
  if ( a3 == v9 )
  {
    result = 0;
  }
  else if ( feof(stream) )
  {
    result = 14;
  }
  else
  {
    v11 = _errno_location();
    result = sub_7A990(*v11, "./../lib/isc/unix/stdio.c", 74);
  }
  if ( a5 )
    *a5 = v9;
  return result;
}

//----- (000758B0) --------------------------------------------------------
int __fastcall sub_758B0(const void *a1, size_t a2, size_t a3, FILE *stream, size_t *a5)
{
  size_t v9; // r5
  int result; // r0
  int *v11; // r0

  clearerr(stream);
  v9 = fwrite(a1, a2, a3, stream);
  if ( a3 == v9 )
  {
    result = 0;
  }
  else
  {
    v11 = _errno_location();
    result = sub_7A990(*v11, "./../lib/isc/unix/stdio.c", 91);
  }
  if ( a5 )
    *a5 = v9;
  return result;
}

//----- (0007595C) --------------------------------------------------------
int __fastcall sub_7595C(FILE *a1)
{
  int result; // r0
  int *v2; // r0

  result = fflush(a1);
  if ( result )
  {
    v2 = _errno_location();
    return sub_7A990(*v2, "./../lib/isc/unix/stdio.c", 105);
  }
  return result;
}

//----- (000759E0) --------------------------------------------------------
int __fastcall sub_759E0(FILE *a1)
{
  int v1; // r0
  int v2; // r0
  bool v3; // zf

  v1 = fileno(a1);
  if ( !fsync(v1) )
    return 0;
  v2 = *_errno_location();
  v3 = v2 == 95;
  if ( v2 != 95 )
    v3 = v2 == 22;
  if ( v3 )
    return 0;
  else
    return sub_7A990(v2, "./../lib/isc/unix/stdio.c", 127);
}

//----- (00075A78) --------------------------------------------------------
int sub_75A78()
{
  int result; // r0

  result = sub_78614(&unk_107290, "./../lib/isc/unix/strerror.c", 41);
  if ( result )
    sub_6F61C(
      "./../lib/isc/unix/strerror.c",
      41,
      "isc__mutex_init((&isc_strerror_lock), \"./../lib/isc/unix/strerror.c\", 41) == 0");
  return result;
}
// 78614: using guessed type int __fastcall sub_78614(_DWORD, _DWORD, _DWORD);

//----- (00075B10) --------------------------------------------------------
int __fastcall sub_75B10(int a1, int a2, unsigned int a3)
{
  char *v6; // r3
  int result; // r0

  if ( !a2 )
    sub_6ECC0("./../lib/isc/unix/strerror.c", 55, 0, "buf != ((void *)0)");
  if ( pthread_once(&dword_1072A8, (void (*)(void))sub_75A78) )
    sub_6F61C("./../lib/isc/unix/strerror.c", 57, "((pthread_once((&once), (init_lock)) == 0) ? 0 : 34) == 0");
  if ( pthread_mutex_lock(&stru_107290) )
    sub_6F61C("./../lib/isc/unix/strerror.c", 59, "((pthread_mutex_lock(((&isc_strerror_lock))) == 0) ? 0 : 34) == 0");
  v6 = strerror(a1);
  if ( v6 )
    sub_6C054(a2, a3, (unsigned __int8 *)"%s", v6);
  else
    sub_6C054(a2, a3, "Unknown error: %u", a1);
  result = pthread_mutex_unlock(&stru_107290);
  if ( result )
    sub_6F61C("./../lib/isc/unix/strerror.c", 65, "((pthread_mutex_unlock(((&isc_strerror_lock))) == 0) ? 0 : 34) == 0");
  return result;
}
// 107290: using guessed type pthread_mutex_t stru_107290;
// 1072A8: using guessed type pthread_once_t dword_1072A8;

//----- (00075CAC) --------------------------------------------------------
_DWORD *__fastcall sub_75CAC(_DWORD *result, int a2, unsigned int a3)
{
  if ( !result )
    sub_6ECC0("./../lib/isc/unix/time.c", 90, 0, "i != ((void *)0)");
  if ( a3 > 0x3B9AC9FF )
    sub_6ECC0("./../lib/isc/unix/time.c", 91, 0, "nanoseconds < 1000000000");
  *result = a2;
  result[1] = a3;
  return result;
}

//----- (00075D54) --------------------------------------------------------
bool __fastcall sub_75D54(int a1)
{
  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/time.c", 99, 0, "i != ((void *)0)");
  if ( *(_DWORD *)(a1 + 4) > 0x3B9AC9FFu )
    sub_6ECC0("./../lib/isc/unix/time.c", 100, 2, "i->nanoseconds < 1000000000");
  return *(_QWORD *)a1 == 0;
}

//----- (00075E0C) --------------------------------------------------------
_DWORD *__fastcall sub_75E0C(_DWORD *result, int a2, unsigned int a3)
{
  if ( !result )
    sub_6ECC0("./../lib/isc/unix/time.c", 118, 0, "t != ((void *)0)");
  if ( a3 > 0x3B9AC9FF )
    sub_6ECC0("./../lib/isc/unix/time.c", 119, 0, "nanoseconds < 1000000000");
  *result = a2;
  result[1] = a3;
  return result;
}

//----- (00075EB4) --------------------------------------------------------
_DWORD *__fastcall sub_75EB4(_DWORD *result)
{
  if ( !result )
    sub_6ECC0("./../lib/isc/unix/time.c", 127, 0, "t != ((void *)0)");
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (00075F30) --------------------------------------------------------
bool __fastcall sub_75F30(int a1)
{
  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/time.c", 135, 0, "t != ((void *)0)");
  if ( *(_DWORD *)(a1 + 4) > 0x3B9AC9FFu )
    sub_6ECC0("./../lib/isc/unix/time.c", 136, 2, "t->nanoseconds < 1000000000");
  return *(_QWORD *)a1 == 0;
}

//----- (00075FE8) --------------------------------------------------------
int __fastcall sub_75FE8(__time_t *a1)
{
  __time_t tv_sec; // r2
  int tv_usec; // r3
  __suseconds_t v4; // r1
  int v5; // r2
  __time_t v6; // r0
  int v7; // r2
  __time_t v8; // r1
  int result; // r0
  int *v10; // r0
  struct timeval tv; // [sp+4h] [bp-90h] BYREF
  char v12[128]; // [sp+Ch] [bp-88h] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/time.c", 150, 0, "t != ((void *)0)");
  if ( gettimeofday(&tv, 0) == -1 )
  {
    v10 = _errno_location();
    sub_75B10(*v10, (int)v12, 0x80u);
    sub_6F554("./../lib/isc/unix/time.c", 154, (int)"%s", v12);
    return 34;
  }
  tv_sec = tv.tv_sec;
  tv_usec = tv.tv_usec;
  if ( tv.tv_usec < 0 )
  {
    v7 = tv.tv_sec - 1;
    do
    {
      v8 = v7;
      tv_usec += 1000000;
      --v7;
    }
    while ( tv_usec < 0 );
    tv.tv_sec = v8;
    tv.tv_usec = tv_usec;
    goto LABEL_11;
  }
  v4 = 999999;
  if ( tv.tv_usec > 999999 )
  {
    v5 = tv.tv_sec + 1;
    do
    {
      v6 = v5;
      tv_usec -= 1000000;
      ++v5;
    }
    while ( tv_usec > 999999 );
    tv.tv_sec = v6;
    tv.tv_usec = tv_usec;
LABEL_11:
    _syslog_chk(3, 1, "gettimeofday returned bad tv_usec: corrected");
    tv_sec = tv.tv_sec;
  }
  if ( tv_sec < 0 )
  {
    result = 34;
  }
  else
  {
    v4 = tv.tv_usec;
    tv_usec = 1000;
    result = 0;
  }
  if ( tv_sec >= 0 )
  {
    *a1 = tv_sec;
    a1[1] = tv_usec * v4;
  }
  return result;
}
// 760B4: variable 'tv_usec' is possibly undefined
// 760B4: variable 'v4' is possibly undefined
// BB48: using guessed type int _syslog_chk(_DWORD, _DWORD, const char *, ...);

//----- (0007614C) --------------------------------------------------------
int __fastcall sub_7614C(int *a1, int *a2)
{
  __time_t tv_sec; // r2
  int tv_usec; // r3
  int v6; // r2
  __time_t v7; // r0
  int v8; // r2
  __time_t v9; // r1
  int result; // r0
  int v11; // r1
  int v12; // r0
  __suseconds_t v13; // r3
  int v14; // r2
  int v15; // r1
  unsigned int v16; // r3
  int *v17; // r0
  struct timeval tv; // [sp+4h] [bp-8Ch] BYREF
  char v19[128]; // [sp+Ch] [bp-84h] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/time.c", 192, 0, "t != ((void *)0)");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/unix/time.c", 193, 0, "i != ((void *)0)");
  if ( (unsigned int)a2[1] > 0x3B9AC9FF )
    sub_6ECC0("./../lib/isc/unix/time.c", 194, 2, "i->nanoseconds < 1000000000");
  if ( gettimeofday(&tv, 0) == -1 )
  {
    v17 = _errno_location();
    sub_75B10(*v17, (int)v19, 0x80u);
    sub_6F554("./../lib/isc/unix/time.c", 198, (int)"%s", v19);
    return 34;
  }
  tv_sec = tv.tv_sec;
  tv_usec = tv.tv_usec;
  if ( tv.tv_usec < 0 )
  {
    v8 = tv.tv_sec - 1;
    do
    {
      v9 = v8;
      tv_usec += 1000000;
      --v8;
    }
    while ( tv_usec < 0 );
    tv.tv_sec = v9;
    tv.tv_usec = tv_usec;
  }
  else
  {
    if ( tv.tv_usec <= 999999 )
      goto LABEL_14;
    v6 = tv.tv_sec + 1;
    do
    {
      v7 = v6;
      tv_usec -= 1000000;
      ++v6;
    }
    while ( tv_usec > 999999 );
    tv.tv_sec = v7;
    tv.tv_usec = tv_usec;
  }
  _syslog_chk(3, 1, "gettimeofday returned bad tv_usec: corrected");
  tv_sec = tv.tv_sec;
LABEL_14:
  if ( tv_sec < 0 )
    return 34;
  v11 = *a2;
  if ( *a2 < 0 && (int)(((unsigned __int64)(unsigned int)v11 + tv_sec) >> 32) >= 1 )
    return 41;
  v12 = a2[1];
  v13 = tv.tv_usec;
  v14 = tv_sec + v11;
  v15 = 999999999;
  *a1 = v14;
  v16 = v12 + 1000 * v13;
  a1[1] = v16;
  if ( v16 > 0x3B9AC9FF )
    v15 = -1000000000;
  result = 0;
  if ( v16 > 0x3B9AC9FF )
  {
    *a1 = v14 + 1;
    a1[1] = v16 + v15;
  }
  return result;
}
// BB48: using guessed type int _syslog_chk(_DWORD, _DWORD, const char *, ...);

//----- (00076378) --------------------------------------------------------
int __fastcall sub_76378(unsigned int *a1, unsigned int *a2)
{
  int v2; // r2
  unsigned int v3; // lr
  unsigned int v4; // r2
  unsigned int v5; // r0

  v2 = (int)a2;
  if ( a2 )
    v2 = 1;
  if ( !a1 )
    v2 = 0;
  if ( !v2 )
    sub_6ECC0("./../lib/isc/unix/time.c", 240, 0, "t1 != ((void *)0) && t2 != ((void *)0)");
  v3 = a1[1];
  if ( v3 > 0x3B9AC9FF || (v4 = a2[1], v4 > 0x3B9AC9FF) )
    sub_6ECC0("./../lib/isc/unix/time.c", 241, 2, "t1->nanoseconds < 1000000000 && t2->nanoseconds < 1000000000");
  v5 = *a1;
  if ( v5 < *a2 )
    return -1;
  if ( v5 > *a2 )
    return 1;
  if ( v3 < v4 )
    return -1;
  else
    return v3 > v4;
}

//----- (00076468) --------------------------------------------------------
int __fastcall sub_76468(int *a1, int *a2, int *a3)
{
  int v3; // r3
  unsigned int v4; // r12
  unsigned int v5; // r6
  int v6; // r0
  int v7; // r3
  unsigned int v8; // r1
  int v9; // r3
  bool v10; // cc
  int result; // r0

  v3 = (int)a3;
  if ( a3 )
    v3 = 1;
  if ( !a2 )
    v3 = 0;
  if ( !a1 )
    v3 = 0;
  if ( !v3 )
    sub_6ECC0("./../lib/isc/unix/time.c", 257, 0, "t != ((void *)0) && i != ((void *)0) && result != ((void *)0)");
  v4 = a1[1];
  if ( v4 > 0x3B9AC9FF || (v5 = a2[1], v5 > 0x3B9AC9FF) )
    sub_6ECC0("./../lib/isc/unix/time.c", 258, 2, "t->nanoseconds < 1000000000 && i->nanoseconds < 1000000000");
  v6 = *a1;
  v7 = *a2;
  if ( (v6 < 0 || v7 < 0) && (int)(((unsigned int)v7 + (unsigned __int64)(unsigned int)v6) >> 32) >= 1 )
    return 41;
  v8 = v4 + v5;
  v9 = v7 + v6;
  v10 = v4 + v5 > 0x3B9AC9FF;
  *a3 = v9;
  if ( v4 + v5 > 0x3B9AC9FF )
    v4 = -1000000000;
  result = 0;
  if ( v10 )
  {
    ++v9;
    v4 += v8;
  }
  a3[1] = v8;
  if ( v10 )
  {
    *a3 = v9;
    a3[1] = v4;
  }
  return result;
}

//----- (000765A8) --------------------------------------------------------
int __fastcall sub_765A8(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  int v3; // r3
  unsigned int v4; // r3
  unsigned int v5; // lr
  unsigned int v6; // r0
  unsigned int v7; // r1
  bool v8; // cf
  unsigned int v9; // r0
  unsigned int v10; // r3

  v3 = (int)a3;
  if ( a3 )
    v3 = 1;
  if ( !a2 )
    v3 = 0;
  if ( !a1 )
    v3 = 0;
  if ( !v3 )
    sub_6ECC0("./../lib/isc/unix/time.c", 284, 0, "t != ((void *)0) && i != ((void *)0) && result != ((void *)0)");
  v4 = a1[1];
  if ( v4 > 0x3B9AC9FF || (v5 = a2[1], v5 > 0x3B9AC9FF) )
    sub_6ECC0("./../lib/isc/unix/time.c", 285, 2, "t->nanoseconds < 1000000000 && i->nanoseconds < 1000000000");
  v6 = *a1;
  v7 = *a2;
  if ( v6 >= v7 )
  {
    if ( v6 != v7 )
    {
      v8 = v4 >= v5;
      v9 = v6 - v7;
      *a3 = v9;
      v10 = v4 - v5;
      if ( !v8 )
      {
        *a3 = v9 - 1;
        a3[1] = v10 + 1000000000;
        return 0;
      }
      goto LABEL_17;
    }
    if ( v4 >= v5 )
    {
      v10 = v4 - v5;
      *a3 = 0;
LABEL_17:
      a3[1] = v10;
      return 0;
    }
  }
  return 41;
}

//----- (000766E0) --------------------------------------------------------
int __fastcall sub_766E0(unsigned int *a1, unsigned int *a2)
{
  int v2; // r2
  unsigned int v3; // r6
  unsigned int v4; // r4
  unsigned __int64 v5; // r6
  unsigned __int64 v6; // r4

  v2 = (int)a2;
  if ( a2 )
    v2 = 1;
  if ( !a1 )
    v2 = 0;
  if ( !v2 )
    sub_6ECC0("./../lib/isc/unix/time.c", 308, 0, "t1 != ((void *)0) && t2 != ((void *)0)");
  v3 = a1[1];
  if ( v3 > 0x3B9AC9FF || (v4 = a2[1], v4 > 0x3B9AC9FF) )
    sub_6ECC0("./../lib/isc/unix/time.c", 309, 2, "t1->nanoseconds < 1000000000 && t2->nanoseconds < 1000000000");
  v5 = 1000000000LL * *a1 + v3;
  v6 = 1000000000LL * *a2 + v4;
  if ( v5 > v6 )
    return sub_8BFD0(v5 - v6, 0x3E8u);
  else
    return 0;
}

//----- (000767E8) --------------------------------------------------------
int __fastcall sub_767E8(_DWORD *a1)
{
  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/time.c", 329, 0, "t != ((void *)0)");
  if ( a1[1] > 0x3B9AC9FFu )
    sub_6ECC0("./../lib/isc/unix/time.c", 330, 2, "t->nanoseconds < 1000000000");
  return *a1;
}

//----- (00076894) --------------------------------------------------------
int *__fastcall sub_76894(int *result, int *a2)
{
  bool v2; // nf

  if ( !result )
    sub_6ECC0("./../lib/isc/unix/time.c", 339, 0, "t != ((void *)0)");
  if ( (unsigned int)result[1] > 0x3B9AC9FF )
    sub_6ECC0("./../lib/isc/unix/time.c", 340, 2, "t->nanoseconds < 1000000000");
  v2 = *result < 0;
  if ( *result >= 0 )
  {
    *a2 = *result;
    result = 0;
  }
  if ( v2 )
    return (_DWORD *)(&word_28 + 1);
  return result;
}
// 28: using guessed type __int16;

//----- (00076950) --------------------------------------------------------
unsigned int __fastcall sub_76950(int a1)
{
  unsigned int result; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/time.c", 374, 0, "t != ((void *)0)");
  result = *(_DWORD *)(a1 + 4);
  if ( result > 0x3B9AC9FF )
    sub_6ECC0("./../lib/isc/unix/time.c", 376, 1, "t->nanoseconds < 1000000000");
  return result;
}

//----- (000769F8) --------------------------------------------------------
unsigned int __fastcall sub_769F8(time_t *a1, char *a2, size_t a3)
{
  struct tm *v6; // r0
  size_t v7; // r0
  time_t v9; // [sp+0h] [bp-Ch] BYREF

  if ( !a3 )
    sub_6ECC0("./../lib/isc/unix/time.c", 386, 0, "len > 0");
  v9 = *a1;
  v6 = localtime(&v9);
  v7 = strftime(a2, a3, "%d-%b-%Y %X", v6);
  if ( a3 <= v7 )
    sub_6ECC0("./../lib/isc/unix/time.c", 390, 2, "flen < len");
  if ( v7 )
    return sub_6C054((int)&a2[v7], a3 - v7, ".%03u", a1[1] / 0xF4240u);
  else
    return sub_6C054((int)a2, a3, "99-Bad-9999 99:99:99.999");
}

//----- (00076B14) --------------------------------------------------------
size_t __fastcall sub_76B14(time_t *a1, char *a2, size_t a3)
{
  struct tm *v5; // r0
  size_t result; // r0
  time_t v7; // [sp+0h] [bp-8h] BYREF

  if ( !a3 )
    sub_6ECC0("./../lib/isc/unix/time.c", 403, 0, "len > 0");
  v7 = *a1;
  v5 = gmtime(&v7);
  result = strftime(a2, a3, "%a, %d %b %Y %H:%M:%S GMT", v5);
  if ( a3 <= result )
    sub_6ECC0("./../lib/isc/unix/time.c", 407, 2, "flen < len");
  return result;
}

//----- (00076BDC) --------------------------------------------------------
size_t __fastcall sub_76BDC(time_t *a1, char *a2, size_t a3)
{
  struct tm *v5; // r0
  size_t result; // r0
  time_t v7; // [sp+0h] [bp-8h] BYREF

  if ( !a3 )
    sub_6ECC0("./../lib/isc/unix/time.c", 415, 0, "len > 0");
  v7 = *a1;
  v5 = gmtime(&v7);
  result = strftime(a2, a3, "%Y-%m-%dT%H:%M:%SZ", v5);
  if ( a3 <= result )
    sub_6ECC0("./../lib/isc/unix/time.c", 419, 2, "flen < len");
  return result;
}

//----- (00076CA4) --------------------------------------------------------
unsigned int __fastcall sub_76CA4(int *a1, unsigned int *a2)
{
  unsigned int *v2; // r12
  unsigned int *v3; // r4
  unsigned int *v4; // r5
  unsigned int v5; // r0
  unsigned int v6; // r1
  unsigned int *v7; // lr
  unsigned int v8; // r2
  unsigned int v9; // r3
  int v10; // r9
  int v11; // r8
  int v12; // r0
  int v13; // r4
  int v14; // r6
  int v15; // r1
  int v16; // lr
  int v17; // r4
  unsigned int v18; // r9
  unsigned int v19; // r11
  unsigned int v20; // r1
  int v21; // r12
  int v22; // r5
  unsigned int v23; // r10
  int v24; // r8
  int v25; // r1
  int v26; // r7
  int v27; // lr
  int v28; // r5
  int v29; // r1
  int v30; // lr
  int v31; // r6
  int v32; // r12
  int v33; // r0
  int v34; // r6
  int v35; // r5
  int v36; // r6
  int v37; // r8
  int v38; // r1
  int v39; // r7
  int v40; // r0
  int v41; // r4
  int v42; // r1
  int v43; // r4
  int v44; // r12
  int v45; // lr
  int v46; // r10
  int v47; // r0
  unsigned int v48; // r4
  int v49; // r5
  int v50; // r8
  unsigned int v51; // lr
  int v52; // r5
  int v53; // r9
  int v54; // r1
  int v55; // r0
  int v56; // r9
  int v57; // r5
  int v58; // r0
  int v59; // r11
  int v60; // r7
  int v61; // r1
  int v62; // r9
  int v63; // r1
  int v64; // r0
  int v65; // r6
  int v66; // r8
  int v67; // r6
  int v68; // r10
  int v69; // r9
  int v70; // r5
  int v71; // r10
  int v72; // r6
  int v73; // r9
  int v74; // r1
  int v75; // r2
  int v76; // r11
  int v77; // r5
  int v78; // r1
  int v79; // r6
  int v80; // r0
  int v81; // r8
  int v82; // r7
  int v83; // r6
  int v84; // r0
  int v85; // r5
  int v86; // r9
  unsigned int v87; // r6
  int v88; // r2
  int v89; // r11
  int v90; // r10
  int v91; // r2
  int v92; // r6
  int v93; // r5
  int v94; // r2
  int v95; // r12
  int v96; // r5
  int v97; // r11
  int v98; // r4
  int v99; // r6
  int v100; // r5
  int v101; // r0
  int v102; // r2
  int v103; // r5
  int v104; // r6
  int v105; // r8
  int v106; // r2
  int v107; // r12
  int v108; // lr
  int v109; // r5
  int v110; // r4
  int v111; // r12
  int v112; // r7
  int v113; // r5
  int v114; // r4
  int v115; // r8
  int v116; // r0
  int v117; // r9
  int v118; // r2
  int v119; // lr
  int v120; // r4
  int v121; // r11
  int v122; // r2
  int v123; // r1
  int v124; // lr
  int v125; // r12
  int v126; // r9
  int v127; // r12
  int v128; // r8
  int v129; // r6
  int v130; // r4
  int v131; // r2
  int v132; // r5
  int v133; // r12
  int v134; // r11
  int v135; // r2
  int v136; // r4
  int v137; // r0
  int v138; // r12
  int v139; // lr
  int v140; // r3
  int v141; // r5
  int v142; // r7
  int v143; // r4
  int v144; // r2
  int v145; // r10
  int v146; // r0
  int v147; // r1
  int v148; // r2
  int v149; // r3
  int v150; // r7
  int v151; // r0
  int v152; // r6
  int v153; // r2
  int v154; // r4
  int v155; // r12
  int v156; // r5
  int v157; // r0
  int v158; // r4
  int v159; // r0
  int v160; // r11
  int v161; // r2
  int v162; // r7
  int v163; // r3
  int v164; // r9
  int v165; // r1
  int v166; // r12
  int v167; // r0
  int v168; // r6
  int v169; // r2
  int v170; // r8
  int v171; // r3
  int v172; // r11
  int v173; // r1
  int v174; // r5
  int v175; // r7
  int v176; // r9
  int v177; // r0
  int v178; // r4
  int v179; // r1
  int v180; // r7
  int v181; // r0
  int v182; // lr
  int v183; // r11
  int v184; // r2
  int v185; // r4
  int v186; // r2
  int v187; // r7
  int v188; // r6
  int v189; // lr
  int v190; // r7
  int v191; // r2
  int v192; // r10
  int v193; // lr
  int v194; // r9
  int v195; // r6
  int v196; // r8
  int v197; // r12
  int v198; // lr
  int v199; // r7
  int v200; // r1
  int v201; // r5
  int v202; // r6
  int v203; // r10
  int v204; // r4
  int v205; // r2
  int v206; // r5
  int v207; // lr
  int v208; // r2
  int v209; // r8
  int v210; // r1
  int v211; // r7
  int v212; // r12
  int v213; // r5
  int v214; // r2
  int v215; // r6
  int v216; // r4
  int v217; // r12
  int v218; // r11
  int v219; // r8
  int v220; // r12
  int v221; // lr
  int v222; // r2
  int v223; // r0
  int v224; // r8
  int v225; // r7
  int v226; // r10
  int v227; // r0
  int v228; // r4
  int v229; // r0
  int v230; // r6
  int v231; // r9
  int v232; // r7
  int v233; // r12
  int v234; // r2
  int v235; // r9
  int v236; // lr
  int v237; // r1
  int v238; // r11
  int v239; // r8
  unsigned int result; // r0
  int v241; // r10
  int v242; // lr
  int v243; // r1
  int v244; // r10
  int v245; // r1
  int v246; // r8
  int v247; // lr
  unsigned int v248; // [sp+4h] [bp-B8h]
  int v249; // [sp+4h] [bp-B8h]
  int v250; // [sp+4h] [bp-B8h]
  int v251; // [sp+4h] [bp-B8h]
  unsigned int v252; // [sp+8h] [bp-B4h]
  int v253; // [sp+8h] [bp-B4h]
  int v254; // [sp+8h] [bp-B4h]
  int v255; // [sp+8h] [bp-B4h]
  int v256; // [sp+8h] [bp-B4h]
  int v257; // [sp+Ch] [bp-B0h]
  int v258; // [sp+Ch] [bp-B0h]
  int v259; // [sp+Ch] [bp-B0h]
  int v260; // [sp+Ch] [bp-B0h]
  int v261; // [sp+Ch] [bp-B0h]
  unsigned int v262; // [sp+10h] [bp-ACh]
  int v263; // [sp+10h] [bp-ACh]
  int v264; // [sp+10h] [bp-ACh]
  int v265; // [sp+10h] [bp-ACh]
  unsigned int v266; // [sp+14h] [bp-A8h]
  int v267; // [sp+14h] [bp-A8h]
  int v268; // [sp+14h] [bp-A8h]
  int v269; // [sp+14h] [bp-A8h]
  unsigned int v270; // [sp+18h] [bp-A4h]
  int v271; // [sp+18h] [bp-A4h]
  int v272; // [sp+18h] [bp-A4h]
  int v273; // [sp+18h] [bp-A4h]
  unsigned int v274; // [sp+1Ch] [bp-A0h]
  int v275; // [sp+1Ch] [bp-A0h]
  int v276; // [sp+1Ch] [bp-A0h]
  int v277; // [sp+1Ch] [bp-A0h]
  int v278; // [sp+1Ch] [bp-A0h]
  unsigned int v279; // [sp+20h] [bp-9Ch]
  int v280; // [sp+20h] [bp-9Ch]
  int v281; // [sp+20h] [bp-9Ch]
  int v282; // [sp+20h] [bp-9Ch]
  unsigned int v284; // [sp+28h] [bp-94h]
  int v285; // [sp+28h] [bp-94h]
  int v286; // [sp+28h] [bp-94h]
  int v287; // [sp+28h] [bp-94h]
  int v288; // [sp+28h] [bp-94h]
  unsigned int v289; // [sp+2Ch] [bp-90h]
  int v290; // [sp+2Ch] [bp-90h]
  int v291; // [sp+2Ch] [bp-90h]
  int v292; // [sp+2Ch] [bp-90h]
  unsigned int v293; // [sp+30h] [bp-8Ch]
  int v294; // [sp+30h] [bp-8Ch]
  int v295; // [sp+30h] [bp-8Ch]
  unsigned int v296; // [sp+34h] [bp-88h]
  int v297; // [sp+34h] [bp-88h]
  int v298; // [sp+34h] [bp-88h]
  int v299; // [sp+34h] [bp-88h]
  unsigned int v300; // [sp+38h] [bp-84h]
  int v301; // [sp+38h] [bp-84h]
  int v302; // [sp+38h] [bp-84h]
  int v303; // [sp+38h] [bp-84h]
  unsigned int v304; // [sp+3Ch] [bp-80h]
  int v305; // [sp+3Ch] [bp-80h]
  int v306; // [sp+3Ch] [bp-80h]
  int v307; // [sp+3Ch] [bp-80h]
  int v308; // [sp+40h] [bp-7Ch]
  int v309; // [sp+40h] [bp-7Ch]
  int v310; // [sp+44h] [bp-78h]
  int v311; // [sp+44h] [bp-78h]
  int v312; // [sp+48h] [bp-74h]
  int v313; // [sp+48h] [bp-74h]
  int v314; // [sp+4Ch] [bp-70h]
  int v315; // [sp+4Ch] [bp-70h]
  int v316; // [sp+50h] [bp-6Ch]
  unsigned int v317[18]; // [sp+74h] [bp-48h] BYREF

  v2 = a2;
  if ( !a2 )
    sub_6ECC0("./../lib/isc/sha1.c", 208, 2, "buffer != ((void *)0)");
  v3 = v317;
  v4 = a2 + 16;
  do
  {
    v5 = *v2;
    v2 += 4;
    v6 = *(v2 - 3);
    v7 = v3;
    v8 = *(v2 - 2);
    v3 += 4;
    v9 = *(v2 - 1);
    *v7 = v5;
    v7[1] = v6;
    v7[2] = v8;
    v7[3] = v9;
  }
  while ( v2 != v4 );
  v10 = a1[1];
  v11 = a1[3];
  v12 = __ROR4__(v10, 2);
  v13 = a1[2];
  v14 = v13 + 1518500249;
  v15 = (v13 ^ v11) & v10;
  v16 = (v13 ^ v12) & *a1 ^ v13;
  v17 = __ROR4__(*a1, 2);
  v18 = bswap32(v317[1]);
  v19 = bswap32(v317[0]);
  v20 = v19 + (v15 ^ v11) + a1[4] + 1518500249 + __ROR4__(*a1, 27);
  v21 = __ROR4__(v20, 2);
  v22 = v16 + v11 + 1518500249 + v18 + __ROR4__(v20, 27);
  v23 = bswap32(v317[2]);
  v252 = v18;
  v24 = __ROR4__(v22, 2);
  v25 = (v20 & (v12 ^ v17) ^ v12) + v14 + v23 + __ROR4__(v22, 27);
  v274 = v23;
  v279 = bswap32(v317[3]);
  v26 = __ROR4__(v25, 2);
  v27 = ((v17 ^ v21) & v22 ^ v17) + v12 + 1518500249 + v279 + __ROR4__(v25, 27);
  v284 = bswap32(v317[4]);
  v28 = ((v21 ^ v24) & v25 ^ v21) + v17 + 1518500249 + v284 + __ROR4__(v27, 27);
  v29 = (v24 ^ v26) & v27;
  v30 = __ROR4__(v27, 2);
  v296 = bswap32(v317[5]);
  v31 = (v29 ^ v24) + v296 + 1518500249 + v21;
  v32 = __ROR4__(v28, 2);
  v33 = v31 + __ROR4__(v28, 27);
  v300 = bswap32(v317[6]);
  v34 = v28 & (v26 ^ v30) ^ v26;
  v35 = __ROR4__(v33, 2);
  v304 = bswap32(v317[7]);
  v36 = v34 + v300 + 1518500249 + v24 + __ROR4__(v33, 27);
  v37 = __ROR4__(v36, 2);
  v38 = ((v30 ^ v32) & v33 ^ v30) + v304 + 1518500249 + v26 + __ROR4__(v36, 27);
  v262 = bswap32(v317[8]);
  v39 = __ROR4__(v38, 2);
  v40 = (v36 & (v32 ^ v35) ^ v32) + v262 + 1518500249 + v30 + __ROR4__(v38, 27);
  v266 = bswap32(v317[9]);
  v41 = v38 & (v35 ^ v37) ^ v35;
  v270 = bswap32(v317[10]);
  v42 = __ROR4__(v40, 2);
  v43 = v41 + v266 + 1518500249 + v32 + __ROR4__(v40, 27);
  v44 = __ROR4__(v43, 2);
  v45 = ((v37 ^ v39) & v40 ^ v37) + v270 + 1518500249 + v35 + __ROR4__(v43, 27);
  v289 = bswap32(v317[11]);
  v46 = __ROR4__(v45, 2);
  v47 = (v43 & (v39 ^ v42) ^ v39) + v289 + 1518500249 + v37 + __ROR4__(v45, 27);
  v293 = bswap32(v317[12]);
  v48 = bswap32(v317[13]);
  v49 = (v45 & (v42 ^ v44) ^ v42) + v293 + 1518500249 + v39;
  v50 = __ROR4__(v47, 2);
  v51 = bswap32(v317[14]);
  v52 = v49 + __ROR4__(v47, 27);
  v53 = ((v44 ^ v46) & v47 ^ v44) + v48 + 1518500249 + v42;
  v54 = v19 ^ v274;
  v55 = ((v46 ^ v50) & v52 ^ v46) + v51 + 1518500249 + v44;
  v248 = bswap32(v317[15]);
  v56 = v53 + __ROR4__(v52, 27);
  v57 = __ROR4__(v52, 2);
  v58 = v55 + __ROR4__(v56, 27);
  v59 = v252 ^ v279;
  v60 = __ROR4__(v56, 2);
  v253 = __ROR4__(v54 ^ v262 ^ v48, 31);
  v61 = ((v50 ^ v57) & v56 ^ v50) + v248 + 1518500249 + v46;
  v62 = (v57 ^ v60) & v58 ^ v57;
  v63 = v61 + __ROR4__(v58, 27);
  v64 = __ROR4__(v58, 2);
  v65 = v253 + 1518500249 + v50;
  v66 = __ROR4__(v63, 2);
  v67 = v62 + v65 + __ROR4__(v63, 27);
  v68 = v274 ^ v284 ^ v270;
  v275 = __ROR4__(v59 ^ v266 ^ v51, 31);
  v69 = v279 ^ v296;
  v280 = __ROR4__(v68 ^ v248, 31);
  v70 = (v63 & (v60 ^ v64) ^ v60) + v275 + 1518500249 + v57 + __ROR4__(v67, 27);
  v71 = __ROR4__(v67, 2);
  v257 = __ROR4__(v69 ^ v289 ^ v253, 31);
  v72 = (v67 & (v64 ^ v66) ^ v64) + v280 + 1518500249 + v60 + __ROR4__(v70, 27);
  v73 = __ROR4__(v70, 2);
  v74 = v296 ^ v304 ^ v48;
  v75 = ((v66 ^ v71) & v70 ^ v66) + v257 + 1518500249 + v64 + __ROR4__(v72, 27);
  v297 = __ROR4__(v284 ^ v300 ^ v293 ^ v275, 31);
  v76 = __ROR4__(v75, 2);
  v77 = __ROR4__(v72, 2);
  v78 = __ROR4__(v74 ^ v280, 31);
  v79 = (v72 ^ v71 ^ v73) + v297 + 1859775393 + v66 + __ROR4__(v75, 27);
  v80 = (v73 ^ v77 ^ v75) + v78 + 1859775393 + v71 + __ROR4__(v79, 27);
  v301 = __ROR4__(v300 ^ v262 ^ v51 ^ v257, 31);
  v285 = __ROR4__(v304 ^ v266 ^ v248 ^ v297, 31);
  v81 = __ROR4__(v79, 2);
  v82 = (v79 ^ v77 ^ v76) + v301 + 1859775393 + v73 + __ROR4__(v80, 27);
  v305 = __ROR4__(v262 ^ v270 ^ v253 ^ v78, 31);
  v83 = v76 ^ v81 ^ v80;
  v84 = __ROR4__(v80, 2);
  v85 = v83 + v285 + 1859775393 + v77 + __ROR4__(v82, 27);
  v86 = __ROR4__(v82, 2);
  v87 = v289;
  v290 = __ROR4__(v266 ^ v289 ^ v275 ^ v301, 31);
  v88 = v305 + 1859775393 + v76;
  v263 = __ROR4__(v270 ^ v293 ^ v280 ^ v285, 31);
  v89 = v87 ^ v48;
  v90 = __ROR4__(v85, 2);
  v91 = (v82 ^ v81 ^ v84) + v88 + __ROR4__(v85, 27);
  v92 = (v84 ^ v86 ^ v85) + v290 + 1859775393 + v81 + __ROR4__(v91, 27);
  v93 = v86 ^ v90 ^ v91;
  v94 = __ROR4__(v91, 2);
  v267 = __ROR4__(v293 ^ v51 ^ v297 ^ v290, 31);
  v95 = __ROR4__(v89 ^ v257 ^ v305, 31);
  v96 = v93 + v263 + 1859775393 + v84 + __ROR4__(v92, 27);
  v97 = __ROR4__(v92, 2);
  v271 = __ROR4__(v48 ^ v248 ^ v78 ^ v263, 31);
  v98 = __ROR4__(v96, 2);
  v99 = (v92 ^ v90 ^ v94) + v95 + 1859775393 + v86 + __ROR4__(v96, 27);
  v308 = v95;
  v100 = (v96 ^ v94 ^ v97) + v267 + 1859775393 + v90;
  v101 = __ROR4__(v51 ^ v253 ^ v301 ^ v95, 31);
  v102 = (v97 ^ v98 ^ v99) + v271 + 1859775393 + v94;
  v249 = __ROR4__(v248 ^ v275 ^ v285 ^ v267, 31);
  v103 = v100 + __ROR4__(v99, 27);
  v104 = __ROR4__(v99, 2);
  v105 = __ROR4__(v103, 2);
  v106 = v102 + __ROR4__(v103, 27);
  v254 = __ROR4__(v253 ^ v280 ^ v305 ^ v271, 31);
  v312 = v101;
  v107 = (v98 ^ v104 ^ v103) + v101 + 1859775393 + v97 + __ROR4__(v106, 27);
  v108 = __ROR4__(v106, 2);
  v109 = v105 ^ v108 ^ v107;
  v110 = (v106 ^ v104 ^ v105) + v249 + 1859775393 + v98 + __ROR4__(v107, 27);
  v111 = __ROR4__(v107, 2);
  v112 = __ROR4__(v110, 2);
  v113 = v109 + v254 + 1859775393 + v104 + __ROR4__(v110, 27);
  v276 = __ROR4__(v275 ^ v257 ^ v290 ^ v101, 31);
  v310 = __ROR4__(v280 ^ v297 ^ v263 ^ v249, 31);
  v114 = (v110 ^ v108 ^ v111) + v276 + 1859775393 + v105 + __ROR4__(v113, 27);
  v115 = v285;
  v116 = __ROR4__(v257 ^ v78 ^ v308 ^ v254, 31);
  v117 = __ROR4__(v113, 2);
  v281 = __ROR4__(v297 ^ v301 ^ v267 ^ v276, 31);
  v118 = (v112 ^ v117 ^ v114) + v116 + 1859775393 + v111;
  v119 = (v113 ^ v111 ^ v112) + v310 + 1859775393 + v108 + __ROR4__(v114, 27);
  v120 = __ROR4__(v114, 2);
  v314 = v116;
  v258 = __ROR4__(v78 ^ v285 ^ v271 ^ v310, 31);
  v121 = __ROR4__(v119, 2);
  v122 = v118 + __ROR4__(v119, 27);
  v286 = __ROR4__(v301 ^ v305 ^ v312 ^ v116, 31);
  v123 = __ROR4__(v122, 2);
  v124 = (v119 ^ v117 ^ v120) + v281 + 1859775393 + v112 + __ROR4__(v122, 27);
  v125 = (v120 ^ v121 ^ v122) + v258 + 1859775393 + v117;
  v126 = __ROR4__(v115 ^ v290 ^ v249 ^ v281, 31);
  v127 = v125 + __ROR4__(v124, 27);
  v128 = __ROR4__(v124, 2);
  v294 = v126;
  v129 = __ROR4__(v127, 2);
  v130 = (v124 ^ v121 ^ v123) + v286 + 1859775393 + v120 + __ROR4__(v127, 27);
  v131 = v290 ^ v308 ^ v276 ^ v286;
  v291 = __ROR4__(v305 ^ v263 ^ v254 ^ v258, 31);
  v132 = __ROR4__(v130, 2);
  v133 = (v127 ^ v123 ^ v128) + v126 + 1859775393 + v121 + __ROR4__(v130, 27);
  v134 = __ROR4__(v131, 31);
  v135 = __ROR4__(v133, 2);
  v136 = ((v130 | v129) & v128 | v130 & v129) + v291 - 1894007588 + v123 + __ROR4__(v133, 27);
  v298 = v134;
  v302 = __ROR4__(v263 ^ v267 ^ v310 ^ v126, 31);
  v137 = __ROR4__(v136, 2);
  v138 = ((v133 | v132) & v129 | v133 & v132) + v134 - 1894007588 + v128 + __ROR4__(v136, 27);
  v264 = __ROR4__(v308 ^ v271 ^ v314 ^ v291, 31);
  v139 = ((v136 | v135) & v132 | v136 & v135) + v302 - 1894007588 + v129 + __ROR4__(v138, 27);
  v140 = __ROR4__(v138, 2);
  v268 = __ROR4__(v267 ^ v312 ^ v281 ^ v134, 31);
  v141 = ((v138 | v137) & v135 | v138 & v137) + v264 - 1894007588 + v132 + __ROR4__(v139, 27);
  v142 = __ROR4__(v139, 2);
  v306 = __ROR4__(v271 ^ v249 ^ v258 ^ v302, 31);
  v143 = __ROR4__(v141, 2);
  v144 = ((v139 | v140) & v137 | v139 & v140) + v268 - 1894007588 + v135 + __ROR4__(v141, 27);
  v272 = __ROR4__(v312 ^ v254 ^ v286 ^ v264, 31);
  v145 = __ROR4__(v144, 2);
  v146 = ((v141 | v142) & v140 | v141 & v142) + v306 - 1894007588 + v137 + __ROR4__(v144, 27);
  v147 = __ROR4__(v146, 2);
  v250 = __ROR4__(v249 ^ v276 ^ v126 ^ v268, 31);
  v148 = ((v144 | v143) & v142 | v144 & v143) + v272 - 1894007588 + v140 + __ROR4__(v146, 27);
  v309 = __ROR4__(v254 ^ v310 ^ v291 ^ v306, 31);
  v149 = __ROR4__(v148, 2);
  v150 = ((v146 | v145) & v143 | v146 & v145) + v250 - 1894007588 + v142 + __ROR4__(v148, 27);
  v151 = (v148 | v147) & v145 | v148 & v147;
  v152 = __ROR4__(v150, 2);
  v153 = v310 ^ v281;
  v311 = __ROR4__(v276 ^ v314 ^ v134 ^ v272, 31);
  v154 = v151 + v309 - 1894007588 + v143 + __ROR4__(v150, 27);
  v313 = __ROR4__(v153 ^ v302 ^ v250, 31);
  v155 = __ROR4__(v154, 2);
  v156 = ((v150 | v149) & v147 | v150 & v149) + v311 - 1894007588 + v145 + __ROR4__(v154, 27);
  v255 = __ROR4__(v314 ^ v258 ^ v264 ^ v309, 31);
  v157 = ((v154 | v152) & v149 | v154 & v152) + v313 - 1894007588 + v147;
  v158 = __ROR4__(v156, 2);
  v159 = v157 + __ROR4__(v156, 27);
  v277 = __ROR4__(v281 ^ v286 ^ v268 ^ v311, 31);
  v160 = __ROR4__(v159, 2);
  v161 = ((v156 | v155) & v152 | v156 & v155) + v255 - 1894007588 + v149 + __ROR4__(v159, 27);
  v162 = __ROR4__(v161, 2);
  v259 = __ROR4__(v258 ^ v126 ^ v306 ^ v313, 31);
  v163 = ((v159 | v158) & v155 | v159 & v158) + v277 - 1894007588 + v152 + __ROR4__(v161, 27);
  v164 = __ROR4__(v163, 2);
  v315 = __ROR4__(v286 ^ v291 ^ v272 ^ v255, 31);
  v165 = ((v161 | v160) & v158 | v161 & v160) + v259 - 1894007588 + v155 + __ROR4__(v163, 27);
  v166 = __ROR4__(v165, 2);
  v316 = __ROR4__(v294 ^ v298 ^ v250 ^ v277, 31);
  v167 = ((v163 | v162) & v160 | v163 & v162) + v315 - 1894007588 + v158 + __ROR4__(v165, 27);
  v287 = __ROR4__(v291 ^ v302 ^ v309 ^ v259, 31);
  v168 = __ROR4__(v167, 2);
  v169 = ((v165 | v164) & v162 | v165 & v164) + v316 - 1894007588 + v160 + __ROR4__(v167, 27);
  v299 = __ROR4__(v298 ^ v264 ^ v311 ^ v315, 31);
  v282 = __ROR4__(v302 ^ v268 ^ v313 ^ v316, 31);
  v170 = __ROR4__(v169, 2);
  v171 = ((v167 | v166) & v164 | v167 & v166) + v287 - 1894007588 + v162 + __ROR4__(v169, 27);
  v172 = __ROR4__(v171, 2);
  v173 = ((v169 | v168) & v166 | v169 & v168) + v299 - 1894007588 + v164 + __ROR4__(v171, 27);
  v174 = __ROR4__(v173, 2);
  v292 = __ROR4__(v264 ^ v306 ^ v255 ^ v287, 31);
  v265 = __ROR4__(v268 ^ v272 ^ v277 ^ v299, 31);
  v175 = ((v171 | v170) & v168 | v171 & v170) + v282 - 1894007588 + v166 + __ROR4__(v173, 27);
  v176 = __ROR4__(v175, 2);
  v177 = ((v173 | v172) & v170 | v173 & v172) + v292 - 1894007588 + v168 + __ROR4__(v175, 27);
  v269 = __ROR4__(v306 ^ v250 ^ v259 ^ v282, 31);
  v178 = (v172 ^ v174 ^ v175) + v265 - 899497514 + v170 + __ROR4__(v177, 27);
  v179 = v250 ^ v311;
  v180 = v174 ^ v176 ^ v177;
  v181 = __ROR4__(v177, 2);
  v251 = __ROR4__(v272 ^ v309 ^ v315 ^ v292, 31);
  v182 = v180 + v269 - 899497514 + v172 + __ROR4__(v178, 27);
  v183 = __ROR4__(v178, 2);
  v273 = __ROR4__(v179 ^ v316 ^ v265, 31);
  v184 = (v176 ^ v181 ^ v178) + v251 - 899497514 + v174;
  v185 = __ROR4__(v182, 2);
  v186 = v184 + __ROR4__(v182, 27);
  v295 = __ROR4__(v309 ^ v313 ^ v287 ^ v269, 31);
  v187 = v181 ^ v183 ^ v182;
  v188 = (v183 ^ v185 ^ v186) + v295 - 899497514 + v181;
  v189 = v255;
  v190 = v187 + v273 - 899497514 + v176 + __ROR4__(v186, 27);
  v191 = __ROR4__(v186, 2);
  v256 = __ROR4__(v311 ^ v255 ^ v299 ^ v251, 31);
  v192 = v189 ^ v259;
  v193 = v188 + __ROR4__(v190, 27);
  v194 = __ROR4__(v190, 2);
  v303 = __ROR4__(v192 ^ v292 ^ v295, 31);
  v195 = (v185 ^ v191 ^ v190) + v256 - 899497514 + v183 + __ROR4__(v193, 27);
  v307 = __ROR4__(v313 ^ v277 ^ v282 ^ v273, 31);
  v196 = __ROR4__(v193, 2);
  v197 = v191 ^ v194 ^ v193;
  v198 = v259;
  v260 = __ROR4__(v277 ^ v315 ^ v265 ^ v256, 31);
  v199 = __ROR4__(v195, 2);
  v200 = v197 + v307 - 899497514 + v185 + __ROR4__(v195, 27);
  v201 = (v194 ^ v196 ^ v195) + v303 - 899497514 + v191 + __ROR4__(v200, 27);
  v202 = __ROR4__(v200, 2);
  v278 = __ROR4__(v198 ^ v316 ^ v269 ^ v307, 31);
  v203 = __ROR4__(v201, 2);
  v204 = (v196 ^ v199 ^ v200) + v260 - 899497514 + v194 + __ROR4__(v201, 27);
  v205 = v199 ^ v202 ^ v201;
  v206 = v287;
  v288 = __ROR4__(v315 ^ v287 ^ v251 ^ v303, 31);
  v207 = v205 + v278 - 899497514 + v196 + __ROR4__(v204, 27);
  v208 = v288 - 899497514 + v199;
  v209 = __ROR4__(v204, 2);
  v210 = __ROR4__(v316 ^ v299 ^ v273 ^ v260, 31);
  v211 = __ROR4__(v207, 2);
  v212 = (v202 ^ v203 ^ v204) + v208 + __ROR4__(v207, 27);
  v213 = __ROR4__(v206 ^ v282 ^ v295 ^ v278, 31);
  v214 = (v203 ^ v209 ^ v207) + v210 - 899497514 + v202 + __ROR4__(v212, 27);
  v215 = __ROR4__(v212, 2);
  v216 = __ROR4__(v299 ^ v292 ^ v256 ^ v288, 31);
  v217 = (v212 ^ v209 ^ v211) + v213 - 899497514 + v203;
  v218 = v216 - 899497514 + v209;
  v219 = v211 ^ v215 ^ v214;
  v220 = v217 + __ROR4__(v214, 27);
  v221 = __ROR4__(v282 ^ v265 ^ v307 ^ v210, 31);
  v222 = __ROR4__(v214, 2);
  v223 = v260 ^ v265 ^ v251;
  v224 = v219 + v218 + __ROR4__(v220, 27);
  v261 = __ROR4__(v220, 2);
  v225 = (v220 ^ v215 ^ v222) + v221 - 899497514 + v211 + __ROR4__(v224, 27);
  v226 = __ROR4__(v292 ^ v269 ^ v303 ^ v213, 31);
  v227 = v223 ^ v216;
  v228 = __ROR4__(v224, 2);
  v229 = __ROR4__(v227, 31);
  v230 = (v224 ^ v222 ^ v261) + v226 - 899497514 + v215 + __ROR4__(v225, 27);
  v231 = v261 ^ v228 ^ v225;
  v232 = __ROR4__(v225, 2);
  v233 = __ROR4__(v230, 2);
  v234 = v231 + v229 - 899497514 + v222 + __ROR4__(v230, 27);
  v235 = __ROR4__(v234, 2);
  v236 = __ROR4__(v221 ^ v269 ^ v273 ^ v278, 31) - 899497514 + v261 + (v230 ^ v228 ^ v232) + __ROR4__(v234, 27);
  v237 = *a1 - 899497514 + __ROR4__(v210 ^ v273 ^ v256 ^ v229, 31);
  v238 = a1[2] + __ROR4__(v236, 2);
  v239 = __ROR4__(v251 ^ v295 ^ v288 ^ v226, 31) - 899497514 + v228 + (v234 ^ v232 ^ v233);
  result = v317[16];
  v241 = v233 ^ v235 ^ v236;
  v242 = v239 + __ROR4__(v236, 27);
  v243 = v237 + v232 + v241;
  v244 = a1[4];
  v245 = v243 + __ROR4__(v242, 27);
  v246 = a1[3];
  v247 = a1[1] + v242;
  a1[2] = v238;
  *a1 = v245;
  a1[1] = v247;
  a1[4] = v244 + v233;
  a1[3] = v246 + v235;
  return result;
}

//----- (0007819C) --------------------------------------------------------
int __fastcall sub_7819C(int result)
{
  if ( !result )
    sub_6ECC0("./../lib/isc/sha1.c", 270, 2, "context != ((void *)0)");
  *(_DWORD *)result = 1732584193;
  *(_DWORD *)(result + 4) = -271733879;
  *(_DWORD *)(result + 8) = -1732584194;
  *(_DWORD *)(result + 12) = 271733878;
  *(_QWORD *)(result + 16) = 3285377520LL;
  *(_DWORD *)(result + 24) = 0;
  return result;
}

//----- (00078250) --------------------------------------------------------
void *__fastcall sub_78250(void *a1)
{
  return memset(a1, 0, 0x5Cu);
}

//----- (000782A0) --------------------------------------------------------
void *__fastcall sub_782A0(int *a1, char *src, size_t n)
{
  char *v4; // r7
  unsigned int v6; // r2
  size_t v7; // r3
  int v8; // r10
  char *v9; // r9
  int v11; // r4
  size_t v12; // r3

  if ( !a1 )
    sub_6ECC0("./../lib/isc/sha1.c", 296, 2, "context != 0");
  v4 = src;
  if ( !src )
    sub_6ECC0("./../lib/isc/sha1.c", 297, 2, "data != 0");
  v6 = a1[5];
  v7 = 8 * n + v6;
  v8 = (v6 >> 3) & 0x3F;
  a1[5] = v7;
  if ( __CFADD__(8 * n, v6) )
  {
    src = (char *)a1[6];
    v7 = (n >> 29) + 1;
  }
  v9 = (char *)a1 + v8 + 28;
  if ( __CFADD__(8 * n, v6) )
    a1[6] = (int)&src[v7];
  if ( n + v8 > 0x3F )
  {
    v11 = 64 - v8;
    v9 = (char *)(a1 + 7);
    memcpy((char *)a1 + v8 + 28, v4, 64 - v8);
    sub_76CA4(a1, (unsigned int *)a1 + 7);
    if ( n > 127 - v8 )
    {
      do
      {
        sub_76CA4(a1, (unsigned int *)&v4[v11]);
        v12 = v11 + 127;
        v11 += 64;
      }
      while ( n > v12 );
    }
    v4 += v11;
    n -= v11;
  }
  return memcpy(v9, v4, n);
}

//----- (000783E8) --------------------------------------------------------
void *__fastcall sub_783E8(int *a1, int a2)
{
  unsigned int v4; // r2
  char *v5; // r0
  char v6; // r3
  int v7; // r1
  int v8; // r0
  unsigned int i; // r2
  unsigned int v10; // r1
  char v11; // r3
  char v13; // [sp+3h] [bp-11h] BYREF
  char src[8]; // [sp+4h] [bp-10h] BYREF

  if ( !a2 )
    sub_6ECC0("./../lib/isc/sha1.c", 329, 2, "digest != 0");
  if ( !a1 )
    sub_6ECC0("./../lib/isc/sha1.c", 330, 2, "context != 0");
  v4 = 0;
  v5 = &v13;
  do
  {
    v6 = ~(_BYTE)v4;
    if ( v4 > 3 )
      v7 = 4;
    else
      v7 = 5;
    ++v4;
    *++v5 = (unsigned int)a1[v7 + 1] >> (8 * (v6 & 3));
  }
  while ( v4 != 8 );
  sub_782A0(a1, (char *)&unk_9E23F, 1u);
  while ( (a1[5] & 0x1F8) != 0x1C0 )
    sub_782A0(a1, byte_9E240, 1u);
  sub_782A0(a1, src, 8u);
  v8 = a2 - 1;
  for ( i = 0; i != 20; ++i )
  {
    v10 = a1[i >> 2];
    v11 = 8 * (~(_BYTE)i & 3);
    *(_BYTE *)++v8 = v10 >> v11;
  }
  return memset(a1, 0, 0x5Cu);
}
// 0: using guessed type int dword_0;

//----- (00078564) --------------------------------------------------------
int __fastcall sub_78564(int result, unsigned __int8 *a2, int a3)
{
  unsigned int v3; // r5
  int v4; // r0
  unsigned __int8 *v5; // r2
  unsigned int v6; // r12
  int v7; // lr
  int v8; // t1
  int v9; // t1
  int v10; // [sp+0h] [bp-8h]

  if ( !a3 )
    result = 0;
  v10 = 256;
  if ( a3 )
  {
    v3 = 0;
    v4 = result - 1;
    v5 = &a2[a3];
    v6 = 0;
    do
    {
      v8 = *(unsigned __int8 *)++v4;
      v7 = v8;
      v9 = *a2++;
      v6 |= (v7 - v9) & v10;
      v3 |= (v9 - v7) & v10;
      v10 &= ~(v6 | v3);
    }
    while ( a2 != v5 );
    return (v3 >> 8) - (v6 >> 8);
  }
  return result;
}

//----- (00078614) --------------------------------------------------------
int __fastcall sub_78614(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char v7[128]; // [sp+4h] [bp-88h] BYREF

  result = pthread_mutex_init(a1, 0);
  if ( result == 12 )
    return 1;
  if ( result )
  {
    v6 = _errno_location();
    sub_75B10(*v6, (int)v7, 0x80u);
    sub_6F554(a2, a3, (int)"isc_mutex_init() failed: %s", v7);
    return 34;
  }
  return result;
}

//----- (000786B8) --------------------------------------------------------
int __fastcall sub_786B8(int a1)
{
  int *v1; // r2
  int v2; // r3
  int v3; // t1

  v1 = &clktypes;
  if ( clktypes == -1 )
    return 0;
  if ( a1 != clktypes )
  {
    while ( 1 )
    {
      v3 = v1[3];
      v1 += 3;
      v2 = v3;
      if ( v3 == -1 )
        break;
      if ( v2 == a1 )
        return v1[2];
    }
    return 0;
  }
  return v1[2];
}
// B7EE4: using guessed type int clktypes;

//----- (00078740) --------------------------------------------------------
const char *sub_78740()
{
  struct tm *v0; // r7
  _BYTE *v1; // r5
  int v2; // r6
  int tm_mday; // r3
  int tm_min; // lr
  int tm_sec; // [sp+Ch] [bp-10h]
  time_t v7; // [sp+10h] [bp-Ch] BYREF

  v7 = time(0);
  v0 = localtime(&v7);
  if ( !v0 )
    return "-- --- --:--:--";
  v1 = &lib_stringbuf[128 * lib_nextbuf];
  v2 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v1, 0, 0x80u);
  tm_mday = v0->tm_mday;
  tm_sec = v0->tm_sec;
  tm_min = v0->tm_min;
  lib_nextbuf = v2;
  sub_6C054((int)v1, 0x80u, "%2d %s %02d:%02d:%02d", tm_mday, months[v0->tm_mon], v0->tm_hour, tm_min, tm_sec);
  return v1;
}
// B4C18: using guessed type char *months[12];
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (00078840) --------------------------------------------------------
const char *__fastcall sub_78840(time_t a1)
{
  struct tm *v1; // r7
  _BYTE *v2; // r4
  int v3; // r5
  int tm_sec; // r2
  int tm_hour; // r3
  time_t timer; // [sp+Ch] [bp-Ch] BYREF

  timer = a1;
  v1 = localtime(&timer);
  if ( !v1 )
    return "--:--:--";
  v2 = &lib_stringbuf[128 * lib_nextbuf];
  v3 = ((_BYTE)lib_nextbuf + 1) & 0xF;
  memset(v2, 0, 0x80u);
  tm_sec = v1->tm_sec;
  tm_hour = v1->tm_hour;
  lib_nextbuf = v3;
  sub_6C054((int)v2, 0x80u, "%02d:%02d:%02d", tm_hour, v1->tm_min, tm_sec);
  return v2;
}
// 108D70: using guessed type int lib_nextbuf;
// 108D78: using guessed type _BYTE lib_stringbuf[2048];

//----- (00078914) --------------------------------------------------------
_DWORD *__fastcall sub_78914(_DWORD *result, int a2, int a3)
{
  if ( !result )
    sub_6ECC0("./../lib/isc/buffer.c", 37, 0, "b != ((void *)0)");
  result[2] = a3;
  result[1] = a2;
  *result = 1114990113;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  result[8] = 0;
  result[6] = -1;
  result[7] = -1;
  return result;
}

//----- (000789B8) --------------------------------------------------------
_DWORD *__fastcall sub_789B8(_DWORD *result)
{
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  *result = 1114990113;
  result[4] = 0;
  result[5] = 0;
  result[8] = 0;
  result[6] = -1;
  result[7] = -1;
  return result;
}

//----- (00078A30) --------------------------------------------------------
void *__fastcall sub_78A30(int a1, void *dest, size_t a3)
{
  size_t v5; // r2
  void *result; // r0

  v5 = *(_DWORD *)(a1 + 8);
  if ( v5 > a3 )
    sub_6ECC0("./../lib/isc/buffer.c", 63, 0, "b->length <= length");
  if ( !dest )
    sub_6ECC0("./../lib/isc/buffer.c", 64, 0, "base != ((void *)0)");
  result = memmove(dest, *(const void **)(a1 + 4), v5);
  *(_DWORD *)(a1 + 4) = dest;
  *(_DWORD *)(a1 + 8) = a3;
  return result;
}

//----- (00078AEC) --------------------------------------------------------
_DWORD *__fastcall sub_78AEC(_DWORD *result)
{
  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      77,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( result[6] != -1 )
    sub_6ECC0("./../lib/isc/buffer.c", 78, 0, "!((void *)((b)->link.prev) != (void *)(-1))");
  if ( result[8] )
    sub_6ECC0("./../lib/isc/buffer.c", 79, 0, "b->mctx == ((void *)0)");
  result[1] = 0;
  *result = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (00078BE8) --------------------------------------------------------
int __fastcall sub_78BE8(int result, _QWORD *a2)
{
  if ( !result || *(_DWORD *)result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      90,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 91, 0, "r != ((void *)0)");
  *a2 = *(_QWORD *)(result + 4);
  return result;
}

//----- (00078CA0) --------------------------------------------------------
_DWORD *__fastcall sub_78CA0(_DWORD *result, _QWORD *a2)
{
  __int64 v2; // r2

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      102,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 103, 0, "r != ((void *)0)");
  LODWORD(v2) = result[1];
  HIDWORD(v2) = result[3];
  *a2 = v2;
  return result;
}

//----- (00078D5C) --------------------------------------------------------
_DWORD *__fastcall sub_78D5C(_DWORD *result, _QWORD *a2)
{
  int v2; // r12
  __int64 v3; // r2

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      114,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 115, 0, "r != ((void *)0)");
  v2 = result[3];
  LODWORD(v3) = result[1] + v2;
  HIDWORD(v3) = result[2] - v2;
  *a2 = v3;
  return result;
}

//----- (00078E1C) --------------------------------------------------------
_DWORD *__fastcall sub_78E1C(_DWORD *result, int a2)
{
  unsigned int v2; // r1

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      126,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = a2 + result[3];
  if ( v2 > result[2] )
    sub_6ECC0("./../lib/isc/buffer.c", 127, 0, "b->used + n <= b->length");
  result[3] = v2;
  return result;
}

//----- (00078EDC) --------------------------------------------------------
_DWORD *__fastcall sub_78EDC(_DWORD *result, unsigned int a2)
{
  unsigned int v2; // r3
  unsigned int v3; // r12
  unsigned int v4; // r1
  unsigned int v5; // r3

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      138,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = result[3];
  if ( v2 < a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 139, 0, "b->used >= n");
  v3 = result[4];
  v4 = v2 - a2;
  v5 = result[5];
  result[3] = v4;
  if ( v4 < v3 )
    result[4] = v4;
  if ( v4 < v5 )
    result[5] = v4;
  return result;
}

//----- (00078FB0) --------------------------------------------------------
_DWORD *__fastcall sub_78FB0(_DWORD *result)
{
  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      150,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (00079044) --------------------------------------------------------
_DWORD *__fastcall sub_79044(_DWORD *result, _QWORD *a2)
{
  __int64 v2; // r2

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      161,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 162, 0, "r != ((void *)0)");
  LODWORD(v2) = result[1];
  HIDWORD(v2) = result[4];
  *a2 = v2;
  return result;
}

//----- (00079100) --------------------------------------------------------
_DWORD *__fastcall sub_79100(_DWORD *result, _QWORD *a2)
{
  int v2; // r12
  __int64 v3; // r2

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      173,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 174, 0, "r != ((void *)0)");
  v2 = result[4];
  LODWORD(v3) = result[1] + v2;
  HIDWORD(v3) = result[3] - v2;
  *a2 = v3;
  return result;
}

//----- (000791C8) --------------------------------------------------------
_DWORD *__fastcall sub_791C8(_DWORD *result, unsigned int *a2)
{
  unsigned int v2; // r3
  unsigned int v3; // r12
  bool v4; // cf
  unsigned int v5; // r3

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      185,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 186, 0, "r != ((void *)0)");
  v2 = result[5];
  v3 = result[4];
  v4 = v3 >= v2;
  if ( v3 >= v2 )
  {
    v5 = 0;
  }
  else
  {
    result = (_DWORD *)result[1];
    v5 = v2 - v3;
  }
  if ( v4 )
    *a2 = v5;
  else
    a2[1] = v5;
  if ( v4 )
    a2[1] = v5;
  else
    v3 += (unsigned int)result;
  if ( !v4 )
    *a2 = v3;
  return result;
}

//----- (000792A4) --------------------------------------------------------
_DWORD *__fastcall sub_792A4(_DWORD *result, int a2)
{
  unsigned int v2; // r1

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      197,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = a2 + result[4];
  if ( v2 > result[3] )
    sub_6ECC0("./../lib/isc/buffer.c", 198, 0, "b->current + n <= b->used");
  result[5] = v2;
  return result;
}

//----- (00079364) --------------------------------------------------------
_DWORD *__fastcall sub_79364(_DWORD *result)
{
  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      209,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  result[4] = 0;
  return result;
}

//----- (000793F0) --------------------------------------------------------
_DWORD *__fastcall sub_793F0(_DWORD *result, int a2)
{
  unsigned int v2; // r1

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      220,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = a2 + result[4];
  if ( v2 > result[3] )
    sub_6ECC0("./../lib/isc/buffer.c", 221, 0, "b->current + n <= b->used");
  result[4] = v2;
  return result;
}

//----- (000794B0) --------------------------------------------------------
_DWORD *__fastcall sub_794B0(_DWORD *result, unsigned int a2)
{
  unsigned int v2; // r3

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      232,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = result[4];
  if ( v2 < a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 233, 0, "n <= b->current");
  result[4] = v2 - a2;
  return result;
}

//----- (0007956C) --------------------------------------------------------
void *__fastcall sub_7956C(int a1)
{
  int v2; // r1
  size_t v3; // r5
  void *result; // r0
  __int64 v5; // r2
  int v6; // r3

  if ( !a1 || *(_DWORD *)a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      249,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 12) - v2;
  result = memmove(*(void **)(a1 + 4), (const void *)(*(_DWORD *)(a1 + 4) + v2), v3);
  v5 = *(_QWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) = v3;
  *(_DWORD *)(a1 + 16) = 0;
  if ( HIDWORD(v5) <= (unsigned int)v5 )
    v6 = 0;
  else
    v6 = HIDWORD(v5) - v5;
  *(_DWORD *)(a1 + 20) = v6;
  return result;
}

//----- (0007962C) --------------------------------------------------------
int __fastcall sub_7962C(_DWORD *a1)
{
  int v1; // r3
  int v2; // r2

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      272,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v1 = a1[4];
  if ( a1[3] == v1 )
    sub_6ECC0("./../lib/isc/buffer.c", 273, 0, "b->used - b->current >= 1");
  v2 = a1[1];
  a1[4] = v1 + 1;
  return *(unsigned __int8 *)(v2 + v1);
}

//----- (000796F4) --------------------------------------------------------
int __fastcall sub_796F4(_DWORD *a1, char a2)
{
  int v2; // r2
  int v3; // lr
  int v5; // [sp+4h] [bp-8h]

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      284,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = a1[3];
  if ( (unsigned int)(v2 + 1) > a1[2] )
    sub_6ECC0("./../lib/isc/buffer.c", 285, 0, "b->used + 1 <= b->length");
  v3 = a1[1];
  a1[3] = v2 + 1;
  *(_BYTE *)(v3 + v2) = a2;
  return v5;
}
// 7974C: variable 'v5' is possibly undefined

//----- (000797BC) --------------------------------------------------------
int __fastcall sub_797BC(_DWORD *a1)
{
  int v1; // r2
  int v2; // lr

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      300,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v1 = a1[4];
  if ( (unsigned int)(a1[3] - v1) <= 1 )
    sub_6ECC0("./../lib/isc/buffer.c", 301, 0, "b->used - b->current >= 2");
  v2 = a1[1];
  a1[4] = v1 + 2;
  return (unsigned __int16)__rev16(*(unsigned __int16 *)(v2 + v1));
}

//----- (00079890) --------------------------------------------------------
int __fastcall sub_79890(_DWORD *a1, __int16 a2)
{
  int v2; // r2
  int v3; // r3
  int v5; // [sp+4h] [bp-4h]

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      313,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = a1[3];
  if ( (unsigned int)(v2 + 2) > a1[2] )
    sub_6ECC0("./../lib/isc/buffer.c", 314, 0, "b->used + 2 <= b->length");
  v3 = a1[1];
  a1[3] = v2 + 2;
  *(_BYTE *)(v3 + v2) = HIBYTE(a2);
  *(_BYTE *)(v3 + v2 + 1) = a2;
  return v5;
}
// 798EC: variable 'v5' is possibly undefined

//----- (00079964) --------------------------------------------------------
unsigned int __fastcall sub_79964(_DWORD *a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r3
  int v5; // r3

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      321,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = a1[3];
  if ( (unsigned int)(v2 + 3) > a1[2] )
    sub_6ECC0("./../lib/isc/buffer.c", 322, 0, "b->used + 3 <= b->length");
  v3 = a1[1];
  a1[3] = v2 + 3;
  *(_BYTE *)(v3 + v2) = BYTE2(a2);
  v5 = v3 + v2;
  *(_BYTE *)(v5 + 2) = a2;
  *(_BYTE *)(v5 + 1) = BYTE1(a2);
  return a2 >> 8;
}

//----- (00079A40) --------------------------------------------------------
unsigned int __fastcall sub_79A40(_DWORD *a1)
{
  int v1; // r2
  int v2; // lr

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      337,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v1 = a1[4];
  if ( (unsigned int)(a1[3] - v1) <= 3 )
    sub_6ECC0("./../lib/isc/buffer.c", 338, 0, "b->used - b->current >= 4");
  v2 = a1[1];
  a1[4] = v1 + 4;
  return bswap32(*(_DWORD *)(v2 + v1));
}

//----- (00079B10) --------------------------------------------------------
unsigned int __fastcall sub_79B10(_DWORD *a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r3
  _BYTE *v5; // r3

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      352,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v2 = a1[3];
  if ( (unsigned int)(v2 + 4) > a1[2] )
    sub_6ECC0("./../lib/isc/buffer.c", 353, 0, "b->used + 4 <= b->length");
  v3 = a1[1];
  a1[3] = v2 + 4;
  *(_BYTE *)(v3 + v2) = HIBYTE(a2);
  v5 = (_BYTE *)(v3 + v2);
  v5[3] = a2;
  v5[1] = BYTE2(a2);
  v5[2] = BYTE1(a2);
  return a2 >> 8;
}

//----- (00079BF4) --------------------------------------------------------
unsigned int __fastcall sub_79BF4(_DWORD *a1)
{
  int v1; // r2
  int v2; // r12

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      368,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v1 = a1[4];
  if ( (unsigned int)(a1[3] - v1) <= 5 )
    sub_6ECC0("./../lib/isc/buffer.c", 369, 0, "b->used - b->current >= 6");
  v2 = a1[1];
  a1[4] = v1 + 6;
  return _byteswap_ulong(*(_DWORD *)(v2 + v1 + 2));
}

//----- (00079CE8) --------------------------------------------------------
_DWORD *__fastcall sub_79CE8(_DWORD *result, int a2, int a3, __int16 a4)
{
  int v4; // r1
  int v5; // r12
  int v6; // r1
  int v7; // r12
  _BYTE *v8; // r3

  if ( !result || *result != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      388,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v4 = result[3];
  if ( (unsigned int)(v4 + 6) > result[2] )
    sub_6ECC0("./../lib/isc/buffer.c", 389, 0, "b->used + 6 <= b->length");
  v5 = result[1];
  result[3] = v4 + 2;
  *(_BYTE *)(v5 + v4) = HIBYTE(a4);
  *(_BYTE *)(v5 + v4 + 1) = a4;
  v6 = result[3];
  v7 = result[1];
  result[3] = v6 + 4;
  v8 = (_BYTE *)(v7 + v6);
  *(_BYTE *)(v7 + v6) = HIBYTE(a3);
  v8[3] = a3;
  v8[1] = BYTE2(a3);
  v8[2] = BYTE1(a3);
  return result;
}

//----- (00079DF0) --------------------------------------------------------
void *__fastcall sub_79DF0(_DWORD *a1, const void *a2, size_t a3)
{
  int v4; // r3
  void *result; // r0

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      401,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  v4 = a1[3];
  if ( v4 + a3 > a1[2] )
    sub_6ECC0("./../lib/isc/buffer.c", 402, 0, "b->used + length <= b->length");
  result = memcpy((void *)(a1[1] + v4), a2, a3);
  a1[3] += a3;
  return result;
}

//----- (00079EC8) --------------------------------------------------------
unsigned int __fastcall sub_79EC8(_DWORD *a1, char *s)
{
  unsigned int v4; // r6
  int v5; // r0
  unsigned int result; // r0

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      412,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( !s )
    sub_6ECC0("./../lib/isc/buffer.c", 413, 0, "source != ((void *)0)");
  v4 = strlen(s);
  v5 = a1[3];
  if ( a1[2] - v5 < v4 )
    sub_6ECC0("./../lib/isc/buffer.c", 420, 0, "l <= ((b)->length - (b)->used)");
  memcpy((void *)(a1[1] + v5), s, v4);
  result = a1[3] + v4;
  a1[3] = result;
  return result;
}

//----- (00079FE0) --------------------------------------------------------
int __fastcall sub_79FE0(_DWORD *a1, int a2)
{
  int v4; // r0
  size_t v5; // r2

  if ( !a1 || *a1 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      432,
      0,
      "(((b) != ((void *)0)) && (((const isc__magic_t *)(b))->magic == (0x42756621U)))");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 433, 0, "r != ((void *)0)");
  v4 = a1[3];
  v5 = *(_DWORD *)(a2 + 4);
  if ( v5 > a1[2] - v4 )
    return 19;
  memcpy((void *)(a1[1] + v4), *(const void **)a2, v5);
  a1[3] += *(_DWORD *)(a2 + 4);
  return 0;
}

//----- (0007A0D4) --------------------------------------------------------
int __fastcall sub_7A0D4(int a1, _DWORD *a2, int a3)
{
  _DWORD *v6; // r0
  _DWORD *v7; // r9

  if ( !a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 454, 0, "dynbuffer != ((void *)0)");
  if ( *a2 )
    sub_6ECC0("./../lib/isc/buffer.c", 455, 0, "*dynbuffer == ((void *)0)");
  v6 = sub_63BA4(0, a3 + 36, 0, 0);
  v7 = v6;
  if ( !v6 )
    return 1;
  sub_78914(v6, (int)(v6 + 9), a3);
  v7[8] = a1;
  *a2 = v7;
  return 0;
}

//----- (0007A1B4) --------------------------------------------------------
void __fastcall sub_7A1B4(_DWORD **a1)
{
  _DWORD *v2; // r4
  _DWORD *v3; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/buffer.c", 476, 0, "dynbuffer != ((void *)0)");
  v2 = *a1;
  if ( !*a1 || *v2 != 1114990113 )
    sub_6ECC0(
      "./../lib/isc/buffer.c",
      477,
      0,
      "(((*dynbuffer) != ((void *)0)) && (((const isc__magic_t *)(*dynbuffer))->magic == (0x42756621U)))");
  if ( !v2[8] )
    sub_6ECC0("./../lib/isc/buffer.c", 478, 0, "(*dynbuffer)->mctx != ((void *)0)");
  v3 = *a1;
  *a1 = 0;
  v2[8] = 0;
  sub_78AEC(v3);
  free(v2);
}

//----- (0007A2B0) --------------------------------------------------------
int __fastcall sub_7A2B0(int result)
{
  if ( !result )
    sub_6ECC0("./../lib/isc/unix/dir.c", 45, 0, "dir != ((void *)0)");
  *(_DWORD *)result = 1145655850;
  *(_BYTE *)(result + 1028) = 0;
  *(_DWORD *)(result + 1284) = 0;
  *(_DWORD *)(result + 1288) = 0;
  return result;
}

//----- (0007A33C) --------------------------------------------------------
int __fastcall sub_7A33C(int a1, char *s)
{
  size_t v4; // r0
  unsigned int v5; // r5
  size_t v6; // r0
  _BYTE *v7; // r3
  DIR *v8; // r0
  int *v10; // r0

  if ( !a1 || *(_DWORD *)a1 != 1145655850 )
    sub_6ECC0(
      "./../lib/isc/unix/dir.c",
      65,
      0,
      "(((dir) != ((void *)0)) && (((const isc__magic_t *)(dir))->magic == ((('D') << 24 | ('I') << 16 | ('R') << 8 | ('*')))))");
  if ( !s )
    sub_6ECC0("./../lib/isc/unix/dir.c", 66, 0, "dirname != ((void *)0)");
  v4 = strlen(s);
  if ( v4 + 3 > 0x400 )
    return 19;
  v5 = a1 + 4;
  sub_6D4DC((_BYTE *)(a1 + 4), (unsigned __int8 *)s, v4 + 1);
  v6 = strlen((const char *)(a1 + 4));
  v7 = (_BYTE *)(a1 + 4 + v6);
  if ( v5 < v5 + v6 && *(v7 - 1) != 47 )
  {
    ++v7;
    *(_BYTE *)(v5 + v6) = 47;
  }
  *v7 = 42;
  v7[1] = 0;
  v8 = opendir(s);
  *(_DWORD *)(a1 + 1288) = v8;
  if ( v8 )
    return 0;
  v10 = _errno_location();
  return sub_7A990(*v10, "./../lib/isc/unix/dir.c", 93);
}

//----- (0007A4A4) --------------------------------------------------------
int __fastcall sub_7A4A4(int a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r3
  unsigned __int8 *v5; // r4
  unsigned int v6; // r2
  size_t v7; // r0

  if ( !a1 || *(_DWORD *)a1 != 1145655850 || (v2 = *(_DWORD *)(a1 + 1288)) == 0 )
    sub_6ECC0(
      "./../lib/isc/unix/dir.c",
      110,
      0,
      "(((dir) != ((void *)0)) && (((const isc__magic_t *)(dir))->magic == ((('D') << 24 | ('I') << 16 | ('R') << 8 | ('*"
      "'))))) && dir->handle != ((void *)0)");
  v3 = readdir64(v2);
  if ( !v3 )
    return 29;
  v5 = (unsigned __int8 *)(v3 + 19);
  v6 = strlen((const char *)(v3 + 19)) + 1;
  if ( v6 > 0x100 )
    return 34;
  sub_6D4DC((_BYTE *)(a1 + 1028), v5, v6);
  v7 = strlen((const char *)v5);
  v4 = 0;
  *(_DWORD *)(a1 + 1284) = v7;
  return v4;
}
// BEFC: using guessed type int __fastcall readdir64(_DWORD);

//----- (0007A584) --------------------------------------------------------
int __fastcall sub_7A584(_DWORD *a1)
{
  DIR *v2; // r0
  int result; // r0

  if ( !a1 || *a1 != 1145655850 || (v2 = (DIR *)a1[322]) == 0 )
    sub_6ECC0(
      "./../lib/isc/unix/dir.c",
      142,
      0,
      "(((dir) != ((void *)0)) && (((const isc__magic_t *)(dir))->magic == ((('D') << 24 | ('I') << 16 | ('R') << 8 | ('*"
      "'))))) && dir->handle != ((void *)0)");
  result = closedir(v2);
  a1[322] = 0;
  return result;
}

//----- (0007A620) --------------------------------------------------------
int __fastcall sub_7A620(_DWORD *a1)
{
  DIR *v1; // r0

  if ( !a1 || *a1 != 1145655850 || (v1 = (DIR *)a1[322]) == 0 )
    sub_6ECC0(
      "./../lib/isc/unix/dir.c",
      153,
      0,
      "(((dir) != ((void *)0)) && (((const isc__magic_t *)(dir))->magic == ((('D') << 24 | ('I') << 16 | ('R') << 8 | ('*"
      "'))))) && dir->handle != ((void *)0)");
  rewinddir(v1);
  return 0;
}

//----- (0007A6B8) --------------------------------------------------------
int __fastcall sub_7A6B8(const char *a1)
{
  int *v2; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/dir.c", 166, 0, "dirname != ((void *)0)");
  if ( chdir(a1) >= 0 )
    return 0;
  v2 = _errno_location();
  return sub_7A990(*v2, "./../lib/isc/unix/dir.c", 169);
}

//----- (0007A768) --------------------------------------------------------
int __fastcall sub_7A768(int a1)
{
  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/dir.c", 177, 0, "dirname != ((void *)0)");
  return 27;
}

//----- (0007A7DC) --------------------------------------------------------
int __fastcall sub_7A7DC(const char *a1)
{
  __pid_t v2; // r4
  size_t v3; // r0
  char *v4; // r5
  bool v5; // r3
  char v7; // r3
  int v8; // r3
  int v9; // t1
  bool v10; // zf
  int v11; // r7
  int *v12; // r11
  int v13; // r4
  const unsigned __int16 **v14; // r0
  _BYTE *v15; // r3
  int v16; // r4

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/dir.c", 197, 0, "templet != ((void *)0)");
  v2 = getpid();
  v3 = strlen(a1) - 1;
  v4 = (char *)&a1[v3];
  v5 = !__CFADD__(a1, v3);
  if ( a1[v3] == 88 && v5 )
  {
    do
    {
      v7 = v2 % 10;
      v2 /= 10;
      *v4 = v7 + 48;
      v9 = (unsigned __int8)*--v4;
      v8 = v9;
      v10 = a1 == v4;
      if ( a1 <= v4 )
        v10 = v8 == 88;
    }
    while ( v10 );
  }
LABEL_12:
  while ( 2 )
  {
    v11 = mkdir(a1, 0x1C0u);
    if ( !v11 )
      return 0;
    v12 = _errno_location();
    if ( *v12 == 17 )
    {
      v13 = (unsigned __int8)v4[1];
      if ( v4[1] )
      {
        v14 = _ctype_b_loc();
        v15 = v4 + 1;
        while ( 1 )
        {
          if ( ((*v14)[v13] & 0x800) != 0 )
          {
            *v15 = 97;
            goto LABEL_12;
          }
          if ( v13 != 122 )
            break;
          *v15++ = 97;
          v13 = (unsigned __int8)*v15;
          if ( !*v15 )
            goto LABEL_19;
        }
        v16 = (unsigned __int8)(v13 + 1);
        *v15 = v16;
        if ( v16 )
          continue;
      }
LABEL_19:
      *v12 = 17;
    }
    break;
  }
  if ( v11 == -1 )
    return sub_7A990(*v12, "./../lib/isc/unix/dir.c", 251);
  else
    return 0;
}

//----- (0007A990) --------------------------------------------------------
int __fastcall sub_7A990(int a1, const char *a2, int a3)
{
  int result; // r0
  char v7[128]; // [sp+Ch] [bp-84h] BYREF

  switch ( a1 )
  {
    case 1:
    case 13:
      result = 6;
      break;
    case 2:
      result = 38;
      break;
    case 5:
      result = 26;
      break;
    case 9:
    case 20:
    case 22:
    case 36:
    case 40:
      result = 30;
      break;
    case 12:
      result = 1;
      break;
    case 17:
      result = 39;
      break;
    case 23:
    case 24:
      result = 50;
      break;
    case 32:
    case 103:
    case 104:
      result = 54;
      break;
    case 97:
      result = 48;
      break;
    case 98:
      result = 5;
      break;
    case 99:
      result = 4;
      break;
    case 100:
      result = 10;
      break;
    case 101:
      result = 8;
      break;
    case 105:
      result = 13;
      break;
    case 107:
      result = 40;
      break;
    case 110:
      result = 2;
      break;
    case 111:
      result = 12;
      break;
    case 112:
      result = 11;
      break;
    case 113:
      result = 9;
      break;
    default:
      sub_75B10(a1, (int)v7, 0x80u);
      sub_6F554(a2, a3, (int)"unable to convert errno to isc_result: %d: %s", a1, v7);
      result = 34;
      break;
  }
  return result;
}

//----- (0007AC88) --------------------------------------------------------
int __fastcall sub_7AC88(int a1, int a2)
{
  int result; // r0
  int *v3; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 92, 0, "file != ((void *)0)");
  result = _xstat64(3, a1, a2);
  if ( result )
  {
    v3 = _errno_location();
    return sub_7A990(*v3, "./../lib/isc/unix/file.c", 96);
  }
  return result;
}
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);

//----- (0007AD44) --------------------------------------------------------
int __fastcall sub_7AD44(int a1, _DWORD *a2)
{
  int v3; // r6
  int v5[27]; // [sp+0h] [bp-70h] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 106, 0, "file != ((void *)0)");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/unix/file.c", 107, 0, "itime != ((void *)0)");
  v3 = sub_7AC88(a1, (int)v5);
  if ( !v3 )
    sub_75E0C(a2, v5[20], 0);
  return v3;
}

//----- (0007AE04) --------------------------------------------------------
int __fastcall sub_7AE04(const char *a1, _DWORD *a2)
{
  int v2; // r2
  int *v6; // r0
  struct timeval tvp; // [sp+4h] [bp-14h] BYREF
  __time_t v8; // [sp+Ch] [bp-Ch]
  __suseconds_t v9; // [sp+10h] [bp-8h]

  v2 = (int)a2;
  if ( a2 )
    v2 = 1;
  if ( !a1 )
    v2 = 0;
  if ( !v2 )
    sub_6ECC0("./../lib/isc/unix/file.c", 125, 0, "file != ((void *)0) && itime != ((void *)0)");
  v8 = sub_767E8(a2);
  tvp.tv_sec = v8;
  if ( v8 < 0 )
    return 41;
  v9 = sub_76950((int)a2) / 0x3E8;
  tvp.tv_usec = v9;
  if ( utimes(a1, &tvp) >= 0 )
    return 0;
  v6 = _errno_location();
  return sub_7A990(*v6, "./../lib/isc/unix/file.c", 156);
}

//----- (0007AEFC) --------------------------------------------------------
int __fastcall sub_7AEFC(char *a1, char *s, unsigned __int8 *a3, unsigned int a4)
{
  char *v6; // r5
  char *v8; // r0
  char *v9; // r10
  size_t v10; // r0
  int v11; // r10

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 174, 0, "path != ((void *)0)");
  v6 = s;
  if ( !s )
    sub_6ECC0("./../lib/isc/unix/file.c", 175, 0, "templet != ((void *)0)");
  if ( !a3 )
    sub_6ECC0("./../lib/isc/unix/file.c", 176, 0, "buf != ((void *)0)");
  v8 = strrchr(s, 47);
  if ( v8 )
    v6 = v8 + 1;
  v9 = strrchr(a1, 47);
  v10 = strlen(v6);
  if ( v9 )
  {
    v11 = v9 - a1;
    if ( v10 + 2 + v11 <= a4 )
    {
      sub_6D4DC(a3, (unsigned __int8 *)a1, a4);
      a3[v11 + 1] = 0;
      sub_6D58C(a3, v6, a4);
      return 0;
    }
    return 19;
  }
  if ( v10 + 1 > a4 )
    return 19;
  sub_6D4DC(a3, (unsigned __int8 *)v6, a4);
  return 0;
}

//----- (0007B074) --------------------------------------------------------
int __fastcall sub_7B074(char *a1, unsigned __int8 *a2, unsigned int a3)
{
  return sub_7AEFC(a1, "tmp-XXXXXXXXXX", a2, a3);
}

//----- (0007B0D0) --------------------------------------------------------
int __fastcall sub_7B0D0(const char *a1, char *to)
{
  char *i; // r4
  char *v5; // r5
  int v6; // t1
  int v7; // r0
  int v8; // r1
  char *v9; // r4
  char *v10; // r0
  int v12; // r0
  unsigned int v13; // [sp+0h] [bp-Ch] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 210, 0, "file != ((void *)0)");
  if ( !to )
    sub_6ECC0("./../lib/isc/unix/file.c", 211, 0, "templet != ((void *)0)");
  if ( !*to )
    return 25;
  for ( i = to; ; ++i )
  {
    v5 = i + 1;
    if ( !i[1] )
      break;
  }
  if ( to == v5 )
    return 25;
  if ( to <= i && *i == 88 )
  {
    do
    {
      v5 = i;
      sub_7C1B4(&v13);
      *i = aAbcdefghijklmn[v13 % 0x3E];
      if ( i == to )
        break;
      v6 = (unsigned __int8)*--i;
    }
    while ( v6 == 88 );
  }
  while ( link(a1, to) == -1 )
  {
    v7 = *_errno_location();
    if ( v7 != 17 )
      return sub_7A990(v7, "./../lib/isc/unix/file.c", 227);
    v8 = (unsigned __int8)*v5;
    if ( !*v5 )
      return 25;
    v9 = v5;
    while ( 1 )
    {
      v10 = strchr(aAbcdefghijklmn, v8);
      if ( v10 )
      {
        if ( v10[1] )
          break;
      }
      *v9++ = aAbcdefghijklmn[0];
      v8 = (unsigned __int8)*v9;
      if ( !*v9 )
        return 25;
    }
    *v9 = v10[1];
  }
  if ( unlink(a1) >= 0 )
    return 0;
  v12 = *_errno_location();
  if ( v12 == 2 )
    return 0;
  else
    return sub_7A990(v12, "./../lib/isc/unix/file.c", 243);
}

//----- (0007B2F0) --------------------------------------------------------
int __fastcall sub_7B2F0(const char *a1, int a2, FILE **a3)
{
  const char *i; // r3
  const char *v6; // r4
  char *v7; // r10
  int v8; // t1
  int v9; // r0
  int v10; // r11
  int v11; // r0
  int v12; // r1
  char *v13; // r11
  char *v14; // r0
  int v15; // r4
  FILE *v17; // r0
  int *v18; // r0
  unsigned int v20; // [sp+10h] [bp-Ch] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 268, 0, "templet != ((void *)0)");
  if ( !a3 || *a3 )
    sub_6ECC0("./../lib/isc/unix/file.c", 269, 0, "fp != ((void *)0) && *fp == ((void *)0)");
  if ( !*a1 )
    return 25;
  for ( i = a1; ; ++i )
  {
    v6 = i + 1;
    if ( !i[1] )
      break;
  }
  if ( a1 == v6 )
    return 25;
  if ( a1 <= i && *i == 88 )
  {
    v7 = (char *)i;
    do
    {
      v6 = v7;
      sub_7C1B4(&v20);
      *v7 = aAbcdefghijklmn[v20 % 0x3E];
      if ( a1 == v7 )
        break;
      v8 = (unsigned __int8)*--v7;
    }
    while ( v8 == 88 );
  }
  while ( 1 )
  {
    v9 = open64(a1, 194, a2);
    v10 = v9;
    if ( v9 != -1 )
      break;
    v11 = *_errno_location();
    if ( v11 != 17 )
      return sub_7A990(v11, "./../lib/isc/unix/file.c", 287);
    v12 = *(unsigned __int8 *)v6;
    if ( !*v6 )
      return 25;
    v13 = (char *)v6;
    while ( 1 )
    {
      v14 = strchr(aAbcdefghijklmn, v12);
      if ( v14 )
      {
        if ( v14[1] )
          break;
      }
      *v13++ = aAbcdefghijklmn[0];
      v12 = (unsigned __int8)*v13;
      if ( !*v13 )
        return 25;
    }
    *v13 = v14[1];
  }
  v17 = fdopen(v9, "w+");
  if ( v17 )
  {
    v15 = 0;
    *a3 = v17;
  }
  else
  {
    v18 = _errno_location();
    v15 = sub_7A990(*v18, "./../lib/isc/unix/file.c", 303);
    if ( remove(a1) < 0 )
      sub_73300(isc_lctx, (int)&off_B7DC4, (int)&off_B7DAC, -4, (int)"remove '%s': failed", a1);
    close(v10);
  }
  return v15;
}
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// B7DAC: using guessed type _UNKNOWN *;
// B7DC4: using guessed type char *off_B7DC4;
// 10725C: using guessed type int isc_lctx;

//----- (0007B5A8) --------------------------------------------------------
int __fastcall sub_7B5A8(const char *a1, FILE **a2)
{
  return sub_7B2F0(a1, 438, a2);
}

//----- (0007B5F8) --------------------------------------------------------
int __fastcall sub_7B5F8(const char *a1, FILE **a2)
{
  return sub_7B2F0(a1, 384, a2);
}

//----- (0007B648) --------------------------------------------------------
int __fastcall sub_7B648(const char *a1)
{
  int result; // r0
  int *v2; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 320, 0, "filename != ((void *)0)");
  result = unlink(a1);
  if ( result )
  {
    v2 = _errno_location();
    return sub_7A990(*v2, "./../lib/isc/unix/file.c", 326);
  }
  return result;
}

//----- (0007B6F4) --------------------------------------------------------
int __fastcall sub_7B6F4(const char *a1, const char *a2)
{
  int result; // r0
  int *v3; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 333, 0, "oldname != ((void *)0)");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/unix/file.c", 334, 0, "newname != ((void *)0)");
  result = rename(a1, a2);
  if ( result )
  {
    v3 = _errno_location();
    return sub_7A990(*v3, "./../lib/isc/unix/file.c", 340);
  }
  return result;
}

//----- (0007B7D0) --------------------------------------------------------
bool __fastcall sub_7B7D0(int a1)
{
  int v2; // [sp+0h] [bp-70h] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 347, 0, "pathname != ((void *)0)");
  return sub_7AC88(a1, (int)&v2) == 0;
}

//----- (0007B84C) --------------------------------------------------------
int __fastcall sub_7B84C(int a1)
{
  void *v2; // r0
  int *v4; // r0
  _DWORD v5[26]; // [sp+0h] [bp-74h] BYREF

  v2 = memset(v5, 0, sizeof(v5));
  if ( _xstat64(3, a1, v2) == -1 )
  {
    v4 = _errno_location();
    return sub_7A990(*v4, "./../lib/isc/unix/file.c", 361);
  }
  else if ( (v5[4] & 0xF000) == 0x8000 )
  {
    return 0;
  }
  else
  {
    return 30;
  }
}
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);

//----- (0007B8F4) --------------------------------------------------------
bool __fastcall sub_7B8F4(unsigned __int8 *a1)
{
  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 371, 0, "filename != ((void *)0)");
  return *a1 == 47;
}

//----- (0007B974) --------------------------------------------------------
int __fastcall sub_7B974(_BYTE *a1)
{
  bool v1; // zf
  int result; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 377, 0, "filename != ((void *)0)");
  v1 = *a1 == 46;
  if ( *a1 == 46 )
    result = (unsigned __int8)a1[1];
  else
    result = 0;
  if ( v1 )
    return result == 0;
  return result;
}

//----- (0007B9FC) --------------------------------------------------------
bool __fastcall sub_7B9FC(unsigned __int8 *a1)
{
  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 383, 0, "filename != ((void *)0)");
  return sub_7B8F4(a1) || sub_7B974(a1) != 0;
}

//----- (0007BA8C) --------------------------------------------------------
const char *__fastcall sub_7BA8C(const char *a1)
{
  char *v2; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 395, 0, "filename != ((void *)0)");
  v2 = strrchr(a1, 47);
  if ( v2 )
    return v2 + 1;
  else
    return a1;
}

//----- (0007BB10) --------------------------------------------------------
int __fastcall sub_7BB10(const char *a1, void *a2, size_t a3)
{
  const char *v5; // r7
  size_t v6; // r2

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 409, 0, "filename != ((void *)0)");
  if ( !a2 )
    sub_6ECC0("./../lib/isc/unix/file.c", 410, 0, "buf != ((void *)0)");
  v5 = sub_7BA8C(a1);
  v6 = strlen(v5) + 1;
  if ( v6 > a3 )
    return 19;
  memcpy(a2, v5, v6);
  return 0;
}

//----- (0007BBDC) --------------------------------------------------------
int __fastcall sub_7BBDC(char *a1, int a2, size_t size)
{
  size_t v6; // r5
  int result; // r0
  int v8; // r0

  if ( !a2 )
    sub_6ECC0("./../lib/isc/unix/file.c", 433, 0, "dirname != ((void *)0)");
  if ( !size )
    sub_6ECC0("./../lib/isc/unix/file.c", 434, 0, "length > 0U");
  if ( getcwd((char *)a2, size) )
  {
    v6 = strlen((const char *)a2);
    if ( size == v6 + 1 )
      return 19;
    if ( !*(_BYTE *)(a2 + 1) )
    {
LABEL_6:
      if ( strlen(a1) + v6 + 1 <= size )
      {
        sub_6D58C((unsigned __int8 *)a2, a1, size);
        return 0;
      }
      return 19;
    }
    sub_6D58C((unsigned __int8 *)a2, "/", size);
LABEL_11:
    v6 = strlen((const char *)a2);
    goto LABEL_6;
  }
  v8 = *_errno_location();
  if ( v8 == 34 )
    return 19;
  result = sub_7A990(v8, "./../lib/isc/unix/file.c", 442);
  if ( !result )
    goto LABEL_11;
  return result;
}

//----- (0007BD40) --------------------------------------------------------
int sub_7BD40()
{
  int *v1; // r0

  if ( truncate64() >= 0 )
    return 0;
  v1 = _errno_location();
  return sub_7A990(*v1, "./../lib/isc/unix/file.c", 470);
}
// C148: using guessed type int truncate64(void);

//----- (0007BDC8) --------------------------------------------------------
int __fastcall sub_7BDC8(int a1, FILE **a2)
{
  int v4; // r0
  int v5; // r5
  int v6; // r1
  int v7; // r0
  int v8; // r7
  FILE *v9; // r0
  int *v10; // r0
  int *v12; // r0
  _WORD v13[54]; // [sp+0h] [bp-74h] BYREF

  if ( !a1 )
    sub_6ECC0("./../lib/isc/unix/file.c", 482, 0, "filename != ((void *)0)");
  if ( !a2 || *a2 )
    sub_6ECC0("./../lib/isc/unix/file.c", 483, 0, "fp != ((void *)0) && *fp == ((void *)0)");
  v4 = sub_7AC88(a1, (int)v13);
  v5 = v4;
  if ( v4 )
  {
    if ( v4 != 38 )
      return v5;
    v6 = 193;
  }
  else
  {
    if ( (v13[8] & 0x8000) == 0 )
      return 30;
    v6 = 513;
  }
  v7 = open64(a1, v6, 384);
  v8 = v7;
  if ( v7 == -1 )
  {
    v12 = _errno_location();
    return sub_7A990(*v12, "./../lib/isc/unix/file.c", 497);
  }
  else
  {
    v9 = fdopen(v7, "w");
    if ( v9 )
    {
      *a2 = v9;
      return 0;
    }
    else
    {
      v10 = _errno_location();
      v5 = sub_7A990(*v10, "./../lib/isc/unix/file.c", 501);
      close(v8);
    }
  }
  return v5;
}
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);

//----- (0007BF38) --------------------------------------------------------
int __fastcall sub_7BF38(int a1, char *a2, _DWORD *a3, char **a4)
{
  char *v7; // r0
  char *v8; // r7
  size_t v9; // r10
  _BYTE *v10; // r0
  void *v11; // r9

  if ( !a2 )
    sub_6ECC0("./../lib/isc/unix/file.c", 515, 0, "path != ((void *)0)");
  v7 = strrchr(a2, 47);
  if ( a2 == v7 )
  {
    v8 = a2 + 1;
    v11 = sub_63D08("/");
  }
  else
  {
    if ( v7 )
    {
      v8 = v7 + 1;
      v9 = v7 + 1 - a2;
      v10 = sub_63BA4(0, v9, 0, 0);
      v11 = v10;
      if ( v10 )
      {
        sub_6D4DC(v10, (unsigned __int8 *)a2, v9);
        goto LABEL_6;
      }
      return 1;
    }
    v8 = a2;
    v11 = sub_63D08(".");
  }
  if ( !v11 )
    return 1;
LABEL_6:
  if ( *v8 )
  {
    *a3 = v11;
    *a4 = v8;
    return 0;
  }
  else
  {
    free(v11);
    return 30;
  }
}

//----- (0007C06C) --------------------------------------------------------
void sub_7C06C()
{
  __pid_t v0; // r5
  unsigned int v1; // r0

  v0 = getpid();
  v1 = time(0) ^ __ROR4__(v0, 16);
  srand(v1);
}

//----- (0007C0C8) --------------------------------------------------------
int sub_7C0C8()
{
  int result; // r0

  result = pthread_once(&dword_1072BC, sub_7C06C);
  if ( result )
    sub_6F61C("./../lib/isc/random.c", 60, "((pthread_once((&once), (initialize_rand)) == 0) ? 0 : 34) == 0");
  return result;
}
// 1072BC: using guessed type pthread_once_t dword_1072BC;

//----- (0007C160) --------------------------------------------------------
void __fastcall sub_7C160(unsigned int a1)
{
  sub_7C0C8();
  srand(a1);
}

//----- (0007C1B4) --------------------------------------------------------
unsigned int __fastcall sub_7C1B4(unsigned int *a1)
{
  unsigned int v2; // r4
  unsigned int result; // r0

  if ( !a1 )
    sub_6ECC0("./../lib/isc/random.c", 78, 0, "val != ((void *)0)");
  sub_7C0C8();
  v2 = rand();
  result = (unsigned __int16)(v2 >> 4) | (rand() << 12) & 0xFFFF0000;
  *a1 = result;
  return result;
}

//----- (0007C24C) --------------------------------------------------------
unsigned int __fastcall sub_7C24C(unsigned int result, unsigned int a2)
{
  unsigned int v2; // r4
  int v4; // r1
  unsigned int v5; // [sp+0h] [bp-8h] BYREF

  v2 = result;
  if ( a2 < result )
  {
    if ( a2 )
    {
      sub_7C1B4(&v5);
      sub_8B8EC(v5, a2);
      return v2 - v4;
    }
  }
  else
  {
    result |= a2;
    if ( result )
      sub_6ECC0("./../lib/isc/random.c", 106, 0, "jitter < max || (jitter == 0 && max == 0)");
  }
  return result;
}
// 7C2B8: variable 'v4' is possibly undefined

//----- (0007C2F0) --------------------------------------------------------
int __fastcall sub_7C2F0(int a1, _DWORD *a2)
{
  void (*v4)(void); // r7
  int v5; // r2
  int v6; // r3
  int v7; // r2
  int v8; // r12
  int v10; // r2
  int v11; // [sp+4h] [bp-8h]

  v4 = (void (*)(void))a2[10];
  v5 = _stack_chk_guard;
  v6 = a2[4] & 0xFFFFF00 | 8;
  a2[4] = v6;
  v11 = v5;
  if ( v4 )
  {
    v4();
    v6 = a2[4];
  }
  v7 = *(unsigned __int16 *)a2;
  v8 = *(_DWORD *)(a1 + 120);
  a2[6] = *(_DWORD *)(*(_DWORD *)(a1 + 116) + 4 * v7);
  v10 = *(_DWORD *)(v8 + 4 * v7);
  a2[4] = v6 & 0xFFFFF00;
  a2[7] = v10;
  return v11;
}

//----- (0007C38C) --------------------------------------------------------
void __fastcall sub_7C38C(_DWORD *a1)
{
  int v2; // r4
  _DWORD **v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // t1

  if ( (int)*a1 > 0 )
  {
    v2 = *a1 - 1;
    v3 = (_DWORD **)(a1 + 2);
    do
    {
      v5 = *v3++;
      v4 = v5;
      if ( *v5 == 6 )
        sub_7C38C(v4[2]);
      --v2;
      free(v4);
    }
    while ( v2 != -1 );
  }
  free(a1);
}

//----- (0007C420) --------------------------------------------------------
const char *__fastcall sub_7C420(const char *a1)
{
  const unsigned __int16 *v2; // r5
  const char *v3; // r0
  const char *v4; // r3
  int v5; // t1

  v2 = *_ctype_b_loc();
  while ( (v2[*(unsigned __int8 *)a1] & 0x2000) != 0 )
    ++a1;
  v3 = &a1[strlen(a1)];
  if ( a1 < v3 && (v2[*((unsigned __int8 *)v3 - 1)] & 0x2000) != 0 )
  {
    v4 = v3 - 1;
    do
    {
      v3 = v4;
      if ( a1 == v4 )
        break;
      v5 = *(unsigned __int8 *)--v4;
    }
    while ( (v2[v5] & 0x2000) != 0 );
  }
  *v3 = 0;
  return a1;
}

//----- (0007C4EC) --------------------------------------------------------
void __fastcall optionNumericVal(unsigned int a1, int a2)
{
  bool v2; // cc
  int *v5; // r0
  int *v6; // r9
  int v7; // r0
  char *v8; // r3
  int v9; // r7
  char *v10; // r2
  int v11; // r1
  char *v12; // r12
  unsigned int v13; // r0
  char *v14; // [sp+0h] [bp-Ch] BYREF

  v2 = a2 != 0;
  if ( a2 )
    v2 = a1 > 0xF;
  if ( !v2 || (*(_DWORD *)(a2 + 16) & 8) != 0 || !*(_DWORD *)(a2 + 24) )
    return;
  v5 = _errno_location();
  *v5 = 0;
  v6 = v5;
  v7 = strtol(*(const char **)(a2 + 24), &v14, 0);
  v8 = *(char **)(a2 + 24);
  v9 = v7;
  v10 = v14;
  if ( v8 == v14 || *v6 )
    goto LABEL_20;
  v11 = *(_DWORD *)(a2 + 16);
  if ( (v11 & 0x1000000) != 0 )
  {
    v12 = ++v14;
    v13 = (unsigned __int8)*v10;
    if ( v13 == 84 )
    {
      v9 <<= 10;
      goto LABEL_35;
    }
    if ( v13 <= 0x54 )
    {
      if ( v13 != 71 )
      {
        if ( v13 <= 0x47 )
        {
          if ( *v10 )
            goto LABEL_20;
          v14 = v10;
          goto LABEL_19;
        }
        if ( v13 == 75 )
          goto LABEL_18;
        if ( v13 == 77 )
        {
LABEL_17:
          v9 <<= 10;
LABEL_18:
          v9 <<= 10;
          ++v10;
          goto LABEL_19;
        }
LABEL_20:
        fprintf(stderr, off_B851C[0], *(_DWORD *)(a1 + 28));
        if ( (*(_DWORD *)(a1 + 12) & 4) != 0 )
          (*(void (__fastcall **)(unsigned int, int))(a1 + 84))(a1, 1);
        *v6 = 22;
        *(_DWORD *)(a2 + 24) = -1;
        return;
      }
LABEL_35:
      v9 <<= 10;
      goto LABEL_17;
    }
    if ( v13 == 107 )
    {
LABEL_33:
      v10 = v12;
      v9 *= 1000;
      goto LABEL_19;
    }
    if ( v13 <= 0x6B )
    {
      if ( v13 != 103 )
        goto LABEL_20;
    }
    else
    {
      if ( v13 == 109 )
      {
LABEL_32:
        v9 *= 1000;
        goto LABEL_33;
      }
      if ( v13 != 116 )
        goto LABEL_20;
      v9 *= 1000;
    }
    v9 *= 1000;
    goto LABEL_32;
  }
LABEL_19:
  if ( *v10 )
    goto LABEL_20;
  if ( (v11 & 0x40) != 0 )
  {
    free(v8);
    *(_DWORD *)(a2 + 16) &= ~0x40u;
  }
  *(_DWORD *)(a2 + 24) = v9;
}
// B851C: using guessed type char *off_B851C[58];

//----- (0007C6DC) --------------------------------------------------------
int __fastcall sub_7C6DC(int result, const char *a2, const char *a3, const char *a4)
{
  const char *v4; // r4
  FILE *v5; // r6
  char *v6; // r0

  v4 = a2;
  v5 = (FILE *)result;
  if ( !a2 )
  {
    if ( a3 )
    {
      v4 = a3;
    }
    else
    {
      if ( !a4 )
        return result;
      v4 = a4;
    }
  }
  v6 = strchr(v4, 10);
  if ( v6 )
    fwrite(v4, 1u, v6 - v4, v5);
  else
    fputs(v4, v5);
  return fputc(10, v5);
}

//----- (0007C7A4) --------------------------------------------------------
int __fastcall sub_7C7A4(FILE *a1, int a2, const char *a3)
{
  const char *v6; // r6
  size_t v7; // r8
  int v8; // r8
  int v9; // r6
  char *v10; // r0
  char *v11; // r6

  if ( (*(_DWORD *)(a2 + 16) & 0x20) != 0 && *(unsigned __int16 *)(a2 + 8) == 0x8000 )
    v6 = *(const char **)(a2 + 56);
  else
    v6 = *(const char **)(a2 + 52);
  v7 = strlen(v6);
  fputs(v6, a1);
  if ( a3 || (unsigned __int16)*(_DWORD *)(a2 + 16) >> 12 == 5 )
  {
    v8 = 17 - v7;
    v9 = v8 - 1;
    fwrite(" = ", 1u, 3u, a1);
    if ( v8 > 0 )
    {
      do
      {
        --v9;
        fputc(32, a1);
      }
      while ( v9 != -1 );
    }
    if ( (unsigned __int16)*(_DWORD *)(a2 + 16) >> 12 == 5 )
    {
      fprintf(a1, "%d", a3);
    }
    else
    {
      while ( 1 )
      {
        v10 = strchr(a3, 10);
        v11 = v10;
        if ( !v10 )
          break;
        fwrite(a3, v10 - a3, 1u, a1);
        a3 = v11 + 1;
        fwrite("\\\n", 1u, 2u, a1);
      }
      fputs(a3, a1);
    }
  }
  return fputc(10, a1);
}

//----- (0007C924) --------------------------------------------------------
int __fastcall sub_7C924(unsigned int a1, _DWORD *a2, const char **a3, int a4)
{
  bool v4; // cc
  FILE *v6; // r0
  unsigned int v7; // r10
  unsigned int v8; // r11
  int v9; // r2
  const char *v10; // r7
  int v11; // r3
  bool v12; // zf
  int v13; // r3
  const char **v14; // r5
  const char *v15; // r0
  int v16; // r8
  const char *v17; // t1
  size_t v18; // r0
  const char *v19; // r2
  int v20; // r6
  const char **i; // r7
  const char *v22; // t1
  FILE *v23; // r0
  int v25; // r7
  unsigned __int8 **v26; // r6
  int v27; // r8
  unsigned int v28; // r9
  char *v29; // r1
  unsigned __int8 *v30; // r2
  unsigned __int8 *v31; // t1
  int v32; // r5
  const char *v33; // t1
  int v35; // [sp+Ch] [bp-38h]
  int v38; // [sp+1Ch] [bp-28h]
  const char **v39; // [sp+24h] [bp-20h]
  char s[16]; // [sp+2Ch] [bp-18h] BYREF

  v4 = a1 > 0xF;
  v6 = (FILE *)option_usage_fp;
  if ( v4 )
  {
    fprintf((FILE *)option_usage_fp, (const char *)dword_1072C0[0], *(_DWORD *)(a1 + 28), a2[6], a2[13]);
    v6 = (FILE *)option_usage_fp;
  }
  v7 = 0;
  v8 = 0;
  v35 = a4 - 1;
  fprintf(v6, off_B85F8[0]);
  v10 = *a3;
  v11 = *(unsigned __int8 *)*a3;
  v12 = v11 == 127;
  if ( v11 == 127 )
    v13 = a4;
  else
    v13 = 0;
  if ( v12 )
  {
    v10 = a3[1];
    ++a3;
    v9 = a4 - 1;
  }
  v14 = a3;
  if ( v12 )
    v13 -= 2;
  v39 = a3;
  if ( v12 )
  {
    v35 = v13;
    v13 = 1;
    a4 = v9;
  }
  v15 = v10;
  v38 = v13;
  v16 = a4;
  while ( 1 )
  {
    v18 = strlen(v15) + 1;
    --v16;
    v7 += v18;
    if ( v8 < v18 )
      v8 = v18;
    if ( v16 <= 0 )
      break;
    v17 = v14[1];
    ++v14;
    v15 = v17;
  }
  if ( v8 > 0x23 )
  {
    v19 = v10;
    v20 = a4;
    for ( i = v39; ; ++i )
    {
      --v20;
      fprintf((FILE *)option_usage_fp, "  %s\n", v19);
      if ( v20 <= 0 )
        break;
      v22 = i[1];
      v19 = v22;
    }
    goto LABEL_21;
  }
  if ( v7 <= 0x4B )
  {
    v32 = a4;
    fputc(32, (FILE *)option_usage_fp);
    do
    {
      fputc(32, (FILE *)option_usage_fp);
      --v32;
      v33 = *a3++;
      fputs(v33, (FILE *)option_usage_fp);
    }
    while ( v32 > 0 );
    fputc(10, (FILE *)option_usage_fp);
LABEL_21:
    v23 = (FILE *)option_usage_fp;
    if ( a1 <= 0xF )
      goto LABEL_22;
    goto LABEL_34;
  }
  v25 = a4;
  v26 = (unsigned __int8 **)(a3 - 1);
  v27 = 0;
  sprintf(s, "%%-%ds", v8);
  v28 = sub_8B690(0x4Eu, v8);
  fwrite("  ", 1u, 2u, (FILE *)option_usage_fp);
  while ( 1 )
  {
    --v25;
    v31 = v26[1];
    ++v26;
    v30 = v31;
    if ( v25 <= 0 )
      break;
    if ( v28 == ++v27 )
      v29 = "%s\n  ";
    else
      v29 = s;
    if ( v28 == v27 )
      v27 = 0;
    fprintf((FILE *)option_usage_fp, v29);
  }
  fprintf((FILE *)option_usage_fp, "%s\n", v30);
  v23 = (FILE *)option_usage_fp;
  if ( a1 > 0xF )
  {
LABEL_34:
    fprintf(v23, off_B84D4[0], v38, v38 + v35);
    (*(void (__fastcall **)(unsigned int, int))(a1 + 84))(a1, 1);
    v23 = (FILE *)option_usage_fp;
  }
LABEL_22:
  if ( (unsigned __int16)a2[4] >> 12 != 4 )
    return fprintf(v23, off_B84D4[0], v38, v38 + v35);
  fprintf(v23, off_B8578[0], a4);
  return fputs(off_B85F0[0], (FILE *)option_usage_fp);
}
// 7C9CC: variable 'v9' is possibly undefined
// B84D4: using guessed type char *off_B84D4[76];
// B8578: using guessed type char *off_B8578[35];
// B85F0: using guessed type char *off_B85F0[5];
// B85F8: using guessed type char *off_B85F8[3];
// 1072C0: using guessed type int dword_1072C0[];
// 107410: using guessed type int option_usage_fp;

//----- (0007CC34) --------------------------------------------------------
unsigned int __fastcall sub_7CC34(const char *a1, unsigned int a2, _DWORD *a3, const char **a4, unsigned int a5)
{
  size_t v6; // r0
  unsigned int v7; // r3
  size_t v8; // r7
  int v9; // r2
  unsigned int v10; // r9
  unsigned int v11; // r4
  const char **v12; // r11
  const char *v13; // r5
  const char *v14; // t1
  char *v15; // lr
  unsigned int v17; // r0
  _BOOL4 v18; // r3
  char *endptr; // [sp+10h] [bp-Ch] BYREF

  v6 = strlen(a1);
  v7 = *(unsigned __int8 *)a1;
  v8 = v6;
  if ( v7 > 0x7F )
    goto LABEL_5;
  v9 = dword_9F184[v7];
  if ( (v9 & 0x30000) == 0 )
  {
    if ( (v9 & 0x8000) != 0 && !a1[2] )
    {
      if ( v7 == 126 )
      {
        if ( a1[1] != 48 )
          goto LABEL_25;
      }
      else if ( v7 != 45 || a1[1] != 49 )
      {
        goto LABEL_25;
      }
      return a5 - 1;
    }
LABEL_5:
    if ( a5 )
    {
      v10 = a5;
      v11 = 0;
      v12 = a4 - 1;
      do
      {
        v14 = v12[1];
        ++v12;
        v13 = v14;
        if ( !strncmp(v14, a1, v8) )
        {
          if ( !v13[v8] )
            return v11;
          if ( a5 == v10 )
            v10 = v11;
          else
            v10 = -1;
        }
        ++v11;
      }
      while ( a5 != v11 );
      if ( v10 < a5 )
        return v10;
      if ( v10 != a5 )
      {
        v15 = off_B849C[0];
LABEL_17:
        v11 = a5;
        dword_1072C0[0] = (int)v15;
        option_usage_fp = (int)stderr;
        sub_7C924(a2, a3, a4, a5);
        return v11;
      }
    }
LABEL_25:
    v15 = off_B84F8[0];
    goto LABEL_17;
  }
  v17 = strtoul(a1, &endptr, 0);
  v18 = a5 > v17;
  v11 = v17;
  if ( *endptr )
    v18 = 0;
  if ( !v18 )
  {
    v11 = a5;
    dword_1072C0[0] = (int)off_B8520[0];
    option_usage_fp = (int)stderr;
    sub_7C924(a2, a3, a4, a5);
  }
  return v11;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B849C: using guessed type char *off_B849C[90];
// B84F8: using guessed type char *off_B84F8[67];
// B8520: using guessed type char *off_B8520[57];
// 1072C0: using guessed type int dword_1072C0[];
// 107410: using guessed type int option_usage_fp;

//----- (0007CE5C) --------------------------------------------------------
void __fastcall __noreturn sub_7CE5C(int status)
{
  if ( byte_1072C4 )
    printf("\nexit %d\n", status);
  exit(status);
}
// 1072C4: using guessed type char byte_1072C4;

//----- (0007CEC0) --------------------------------------------------------
void __fastcall __noreturn sub_7CEC0(int a1)
{
  fprintf(stderr, off_B8480[0], a1);
  sub_7CE5C(70);
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8480: using guessed type char *off_B8480[97];

//----- (0007CF18) --------------------------------------------------------
void __fastcall __noreturn sub_7CF18(int a1, int a2, int a3)
{
  FILE *v6; // r8
  const char *v7; // r9
  int v8; // r7
  char *v9; // r0

  v6 = stderr;
  v7 = off_B84B0[0];
  v8 = *_errno_location();
  v9 = strerror(v8);
  fprintf(v6, v7, a1, v8, v9, a2, a3);
  sub_7CE5C(1);
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B84B0: using guessed type char *off_B84B0[85];

//----- (0007CFA4) --------------------------------------------------------
int __fastcall sub_7CFA4(int result, int a2, int a3, _DWORD *a4)
{
  int v4; // r8
  FILE *v6; // r4
  int v8; // r8
  int v9; // r2
  int v10; // r3
  FILE *v11; // r0
  const char *v12; // r1
  const char *v13; // r3
  int *v14; // r9
  const char *v15; // r2
  int v16; // r5
  int *v17; // r9
  int i; // r1
  int v19; // t1
  bool v20; // nf
  int v21; // r5
  const char *v22; // r2
  char *v23; // r5
  unsigned int v24; // r9
  unsigned int v25; // t1
  bool v26; // cc
  int v27; // r10
  int v28; // r11
  const char *v29; // r3
  const char *v30; // r0
  int v31; // r3
  const char *v32; // r0

  v4 = a2 - 1;
  v6 = (FILE *)result;
  if ( a2 - 1 >= 0 )
  {
    do
    {
      IO_putc(32, v6);
      --v4;
      result = IO_putc(32, v6);
    }
    while ( v4 != -1 );
  }
  v8 = a4[1];
  switch ( *a4 )
  {
    case 1:
      v22 = (const char *)a4[1];
      v23 = (char *)a4 + 7;
      fprintf(v6, "<%s>", v22);
      break;
    case 2:
    case 4:
      if ( !a3 )
        goto LABEL_4;
      v27 = *(_DWORD *)(a3 + 16);
      v28 = *(_DWORD *)(a3 + 24);
      if ( *a4 == 2 )
        v29 = "keyword";
      else
        v29 = "set-membership";
      fprintf(v6, "<%s type=%s>", (const char *)a4[1], v29);
      (*(void (__fastcall **)(int, int))(a3 + 40))(3, a3);
      v30 = *(const char **)(a3 + 24);
      if ( v30 )
      {
        fputs(v30, v6);
        if ( *a4 != 2 )
          free(*(void **)(a3 + 24));
      }
      v31 = _stack_chk_guard;
      *(_DWORD *)(a3 + 24) = v28;
      *(_DWORD *)(a3 + 16) = v27;
      return fprintf(v6, "</%s>\n", a4[1], v31);
    case 3:
      if ( a4[2] )
        v13 = "true";
      else
        v13 = "false";
      return fprintf(v6, "<%1$s type=boolean>%2$s</%1$s>\n", a4[1], v13);
    case 5:
LABEL_4:
      v9 = a4[1];
      v10 = a4[2];
      v11 = v6;
      v12 = "<%1$s type=integer>0x%2$lX</%1$s>\n";
      return fprintf(v11, v12, v9, v10);
    case 6:
      v14 = (int *)a4[2];
      if ( !v14 )
        return result;
      if ( *v14 <= 0 )
      {
LABEL_6:
        v10 = 2124;
        v9 = a4[1];
        v11 = v6;
        v12 = "<%s/>\n";
      }
      else
      {
        v15 = (const char *)a4[1];
        v16 = *v14 - 1;
        v17 = v14 + 2;
        fprintf(v6, "<%s type=nested>\n", v15);
        for ( i = ++dword_B8164; ; i = dword_B8164 )
        {
          --v16;
          v19 = *v17++;
          sub_7CFA4(v6, i, 0, v19);
          if ( v16 == -1 )
            break;
        }
        v21 = dword_B8164 - 2;
        v20 = dword_B8164 - 2 < 0;
        --dword_B8164;
        if ( !v20 )
        {
          do
          {
            IO_putc(32, v6);
            --v21;
            IO_putc(32, v6);
          }
          while ( v21 != -1 );
        }
        v10 = _stack_chk_guard;
        v9 = v8;
        v11 = v6;
        v12 = "</%s>\n";
      }
      return fprintf(v11, v12, v9, v10);
    default:
      goto LABEL_6;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v25 = (unsigned __int8)*++v23;
      v24 = v25;
      v26 = v25 > 0x26;
      if ( v25 == 38 )
        goto LABEL_35;
      if ( !v26 )
        break;
      if ( v24 == 62 )
        goto LABEL_35;
      if ( v24 > 0x3E )
      {
        if ( v24 >= 0x7F )
          goto LABEL_35;
      }
      else if ( v24 == 60 )
      {
        goto LABEL_35;
      }
LABEL_33:
      IO_putc(v24, v6);
    }
    if ( !v24 )
    {
      v10 = _stack_chk_guard;
      v9 = v8;
      v12 = "</%s>\n";
      v11 = v6;
      return fprintf(v11, v12, v9, v10);
    }
    if ( v24 > 0x1F )
      goto LABEL_33;
LABEL_35:
    IO_putc(38, v6);
    switch ( v24 )
    {
      case '&':
        v32 = (const char *)&unk_9F384;
        goto LABEL_47;
      case '<':
        v32 = (const char *)&off_9F394;
        goto LABEL_47;
      case '>':
        v32 = (const char *)&unk_9F3A4;
        goto LABEL_47;
      case '"':
        v32 = (const char *)&unk_9F3B4;
        goto LABEL_47;
      case '\'':
        v32 = (const char *)&unk_9F3C4;
LABEL_47:
        fputs(v32 + 8, v6);
        break;
      default:
        fprintf(v6, "#x%02X;", v24);
        break;
    }
  }
}
// 1BC: using guessed type int elf_hash_bucket[521];
// 9F394: using guessed type _UNKNOWN **off_9F394;
// B8164: using guessed type int dword_B8164;

//----- (0007D420) --------------------------------------------------------
int __fastcall sub_7D420(char a1, char **a2)
{
  int v2; // r0

  v2 = a1 & 3;
  *a2 = off_B8594[0];
  dword_1072CC = (int)&unk_9F3D4;
  dword_1072C8 = (int)off_B8460[0];
  dword_1072D8 = (int)off_B8458[0];
  dword_1072D0 = (int)off_B845C[0];
  dword_1072EC = (int)&unk_9F3D4;
  dword_1072DC = (int)"=Mbr";
  dword_107300 = (int)"=Tim";
  dword_1072D4 = (int)"=file";
  dword_1072E4 = (int)"=Cplx";
  dword_1072E8 = (int)"[=arg]";
  dword_1072F0 = (int)"\n%s\n\n";
  dword_1072F4 = (int)"      ";
  dword_1072F8 = (int)"   ";
  dword_1072E0 = (int)off_B8454[0];
  if ( v2 == 2 )
  {
    dword_1072FC = (int)"%s";
    *off_B8454[0] = 32;
    *off_B8458[0] = 32;
    *off_B845C[0] = 32;
    *off_B8460[0] = 32;
    dword_1072E8 = (int)" [arg]";
    return 8;
  }
  else if ( v2 == 3 || v2 == 1 )
  {
    dword_1072FC = (int)"--%2$s%1$s";
    return 22;
  }
  else
  {
    dword_1072FC = (int)"%2$s%1$s";
    return 22;
  }
}
// B8454: using guessed type char *off_B8454[108];
// B8458: using guessed type char *off_B8458[107];
// B845C: using guessed type char *off_B845C[106];
// B8460: using guessed type char *off_B8460[105];
// B8594: using guessed type char *off_B8594[28];
// 1072C8: using guessed type int dword_1072C8;
// 1072CC: using guessed type int dword_1072CC;
// 1072D0: using guessed type int dword_1072D0;
// 1072D4: using guessed type int dword_1072D4;
// 1072D8: using guessed type int dword_1072D8;
// 1072DC: using guessed type int dword_1072DC;
// 1072E0: using guessed type int dword_1072E0;
// 1072E4: using guessed type int dword_1072E4;
// 1072E8: using guessed type int dword_1072E8;
// 1072EC: using guessed type int dword_1072EC;
// 1072F0: using guessed type int dword_1072F0;
// 1072F4: using guessed type int dword_1072F4;
// 1072F8: using guessed type int dword_1072F8;
// 1072FC: using guessed type int dword_1072FC;
// 107300: using guessed type int dword_107300;

//----- (0007D588) --------------------------------------------------------
int __fastcall sub_7D588(char a1, char **a2)
{
  int result; // r0

  dword_1072C8 = (int)"Str";
  dword_1072CC = (int)"YES";
  dword_1072D0 = (int)"Num";
  dword_1072D8 = (int)"KWd";
  dword_1072DC = (int)"Mbr";
  dword_107300 = (int)"Tim";
  dword_1072D4 = (int)"Fil";
  dword_1072E0 = (int)"T/F";
  dword_1072E4 = (int)"Cpx";
  dword_1072E8 = (int)"opt";
  dword_1072EC = (int)"no ";
  dword_1072F0 = (int)"\n%s\n\n%s";
  dword_1072F4 = (int)"     ";
  dword_1072F8 = (int)"  ";
  switch ( a1 & 0x12 )
  {
    case 0:
      result = 24;
      *a2 = off_B85E8[0];
      dword_1072FC = (int)" %3s %-14s %s";
      break;
    case 2:
      result = 24;
      *a2 = off_B85EC[0];
      dword_1072FC = (int)" %3s %-14s %s";
      break;
    case 0x10:
      result = 19;
      *a2 = off_B8590[0];
      dword_1072FC = (int)off_B8598[0];
      break;
    case 0x12:
      result = 19;
      *a2 = off_B8594[0];
      dword_1072FC = (int)off_B8598[0];
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// B8590: using guessed type char *off_B8590[29];
// B8594: using guessed type char *off_B8594[28];
// B8598: using guessed type char *off_B8598[27];
// B85E8: using guessed type char *off_B85E8[7];
// B85EC: using guessed type char *off_B85EC[6];
// 1072C8: using guessed type int dword_1072C8;
// 1072CC: using guessed type int dword_1072CC;
// 1072D0: using guessed type int dword_1072D0;
// 1072D4: using guessed type int dword_1072D4;
// 1072D8: using guessed type int dword_1072D8;
// 1072DC: using guessed type int dword_1072DC;
// 1072E0: using guessed type int dword_1072E0;
// 1072E4: using guessed type int dword_1072E4;
// 1072E8: using guessed type int dword_1072E8;
// 1072EC: using guessed type int dword_1072EC;
// 1072F0: using guessed type int dword_1072F0;
// 1072F4: using guessed type int dword_1072F4;
// 1072F8: using guessed type int dword_1072F8;
// 1072FC: using guessed type int dword_1072FC;
// 107300: using guessed type int dword_107300;

//----- (0007D768) --------------------------------------------------------
int __fastcall sub_7D768(int a1, int a2, int a3)
{
  int v3; // r4
  int v6; // r5
  int *v8; // r0

  v3 = a1;
  if ( a1 == -1 )
  {
    v8 = _errno_location();
    if ( !*v8 )
      *v8 = 22;
  }
  else if ( sub_8B908(0x7FFFFFFF, a3) < a2 || (v6 = a2 * a3, 0x7FFFFFFF - v6 < v3) )
  {
    v3 = -1;
    *_errno_location() = 34;
  }
  else
  {
    v3 += v6;
  }
  return v3;
}

//----- (0007D81C) --------------------------------------------------------
int __fastcall sub_7D81C(int a1, const char **a2, const char *a3, int a4)
{
  const char *v6; // r10
  int *v9; // r8
  unsigned int v10; // r10
  char *v11; // r11
  const unsigned __int16 *v12; // r0
  char *v13; // r2
  unsigned __int8 *v14; // r1
  char *v16; // [sp+0h] [bp-Ch] BYREF

  if ( a1 == -1 )
    return -1;
  v6 = *a2;
  v9 = _errno_location();
  *v9 = 0;
  v10 = strtoul(v6, &v16, 10);
  v11 = v16;
  if ( *v9 )
    return -1;
  v12 = *_ctype_b_loc();
  v13 = v11;
  do
    v14 = (unsigned __int8 *)v13++;
  while ( (v12[*v14] & 0x2000) != 0 );
  if ( a3 == (const char *)v14 )
  {
    *a2 = a3;
    return sub_7D768(a1, v10, a4);
  }
  else
  {
    *v9 = 22;
    return -1;
  }
}

//----- (0007D90C) --------------------------------------------------------
int __fastcall sub_7D90C(const char *a1)
{
  const char *v1; // r4
  char *v2; // r0
  char *v3; // r2
  int v4; // r5
  char *v5; // r2
  char *v6; // r2
  const unsigned __int16 *v7; // r2
  const char *i; // r0
  int v9; // r3
  int v10; // t1
  int v12; // r4
  char *v13; // r2
  int v14; // r7
  size_t v15; // r0
  __int16 v16; // r12
  int v17; // r0
  __int16 v18; // r12
  int v19; // r0
  __int16 v20; // r12
  const char *v21; // [sp+0h] [bp-14h] BYREF
  const char *v22; // [sp+4h] [bp-10h] BYREF
  __int16 v23; // [sp+8h] [bp-Ch] BYREF
  char v24[2]; // [sp+Ah] [bp-Ah] BYREF

  v1 = a1;
  v2 = strchr(a1, 58);
  if ( v2 )
  {
    v21 = v1;
    v12 = sub_7D81C(0, &v21, v2, 3600);
    v13 = strchr(++v21, 58);
    if ( v13 )
    {
      v14 = sub_7D81C(v12, &v21, v13, 60);
      v15 = strlen(++v21);
      return sub_7D81C(v14, &v21, &v21[v15], 1);
    }
LABEL_20:
    v4 = -1;
    *_errno_location() = 22;
    return v4;
  }
  if ( !strpbrk(v1, "HMS") )
  {
    if ( strlen(v1) == 6 )
    {
      v16 = *(_WORD *)v1;
      v24[0] = 0;
      v23 = v16;
      v22 = (const char *)&v23;
      v17 = sub_7D81C(0, &v22, v24, 3600);
      v18 = *((_WORD *)v1 + 1);
      v24[0] = 0;
      v23 = v18;
      v22 = (const char *)&v23;
      v19 = sub_7D81C(v17, &v22, v24, 60);
      v20 = *((_WORD *)v1 + 2);
      v24[0] = 0;
      v22 = (const char *)&v23;
      v23 = v20;
      return sub_7D81C(v19, &v22, v24, 1);
    }
    goto LABEL_20;
  }
  v22 = v1;
  v3 = strchr(v1, 72);
  if ( v3 )
  {
    v4 = sub_7D81C(0, &v22, v3, 3600);
    v1 = ++v22;
  }
  else
  {
    v4 = 0;
  }
  v5 = strchr(v1, 77);
  if ( v5 )
  {
    v4 = sub_7D81C(v4, &v22, v5, 60);
    v1 = ++v22;
  }
  v6 = strchr(v1, 83);
  if ( v6 )
  {
    v4 = sub_7D81C(v4, &v22, v6, 1);
    v1 = ++v22;
  }
  v7 = *_ctype_b_loc();
  for ( i = v1; ; v22 = i )
  {
    v10 = *(unsigned __int8 *)i++;
    v9 = v10;
    if ( (v7[v10] & 0x2000) == 0 )
      break;
  }
  if ( v9 )
  {
    v4 = -1;
    *_errno_location() = 22;
  }
  return v4;
}

//----- (0007DB8C) --------------------------------------------------------
int __fastcall sub_7DB8C(int a1, int a2)
{
  char *v4; // r7

  if ( *(unsigned __int16 *)(a2 + 8) == 0x8000 )
    v4 = (char *)&unk_9F3D8;
  else
    v4 = off_B84C4[0];
  fprintf(stderr, off_B8560[0], *(_DWORD *)(a1 + 28));
  if ( *(unsigned __int16 *)(a2 + 12) <= 1u )
    fprintf(stderr, off_B8528[0], *(_DWORD *)(a2 + 52), v4);
  else
    fprintf(stderr, off_B84AC[0]);
  return (*(int (__fastcall **)(int, int))(a1 + 84))(a1, 1);
}
// B84AC: using guessed type char *off_B84AC[86];
// B84C4: using guessed type char *off_B84C4[80];
// B8528: using guessed type char *off_B8528[55];
// B8560: using guessed type char *off_B8560[41];

//----- (0007DC70) --------------------------------------------------------
int __fastcall sub_7DC70(int a1, void ***a2)
{
  void **v4; // r4
  unsigned int v5; // r3
  void (__fastcall *v6)(int, int); // r5
  int v7; // r0
  void **v8; // lr
  int v10; // r2
  int v11; // r1
  int v12; // r12
  int v13; // r2
  void **v14; // r12
  unsigned int v15; // r3
  unsigned int v16; // r1
  unsigned int v17; // r3
  int v18; // r3
  unsigned __int16 v19; // lr

  v4 = *a2;
  v5 = (unsigned int)(*a2)[4];
  v6 = (void (__fastcall *)(int, int))(*a2)[10];
  if ( (v5 & 0x40) != 0 )
  {
    free(v4[6]);
    v5 = (unsigned int)v4[4];
  }
  v7 = *(_DWORD *)(a1 + 12);
  v8 = a2[1];
  v4[6] = v8;
  if ( (v7 & 0x80000) != 0 && (v5 & 0x100) != 0 )
    return 1;
  v10 = *((unsigned __int16 *)v4 + 4);
  v11 = *(unsigned __int16 *)v4;
  if ( v10 == 0x8000 )
  {
    v19 = *((_WORD *)v4 + 1);
    v13 = (int)v4;
    v14 = a2[2];
    *((_WORD *)v4 + 2) = v11;
    *((_WORD *)v4 + 3) = v19;
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 68);
    v13 = v12 + (v10 << 6);
    if ( (v5 & 4) != 0 )
    {
      v18 = *(unsigned __int16 *)(v13 + 4);
      if ( v18 != v11 )
      {
        fprintf(stderr, off_B84E4[0], *(_DWORD *)(v13 + 52), v4[13], *(_DWORD *)(v12 + (v18 << 6) + 52));
        return -1;
      }
      v14 = a2[2];
    }
    else
    {
      v14 = a2[2];
      if ( v11 != 0x8000 )
        LOWORD(v5) = *((_WORD *)v4 + 1);
      *(_WORD *)(v13 + 4) = 0x8000;
      if ( v11 != 0x8000 )
      {
        v14 = (void **)((unsigned int)v14 | 0x10);
        *(_WORD *)(v13 + 4) = v11;
        *(_WORD *)(v13 + 6) = v5;
        a2[2] = v14;
      }
    }
    v5 = *(_DWORD *)(v13 + 16);
    *(_DWORD *)(v13 + 24) = v8;
  }
  v15 = v5 & 0xFFFFF00 | (unsigned int)v14 & 0xF00000FF;
  *(_DWORD *)(v13 + 16) = v15;
  if ( (v15 & 4) != 0
    && (v16 = *(unsigned __int16 *)(v13 + 12),
        v17 = (unsigned __int16)(*(_WORD *)(v13 + 14) + 1),
        *(_WORD *)(v13 + 14) = v17,
        v16 < v17) )
  {
    if ( (v7 & 4) != 0 )
      sub_7DB8C(a1, v13);
    return -1;
  }
  else
  {
    if ( v6 )
      v6(a1, v13);
    return 0;
  }
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B84E4: using guessed type char *off_B84E4[72];

//----- (0007DE38) --------------------------------------------------------
int __fastcall sub_7DE38(const char *a1)
{
  const char *v1; // r9
  int result; // r0
  int v3; // r3
  int v4; // t1
  char *v5; // r0
  char *v6; // r4
  int v7; // r3
  int v8; // t1

  v1 = a1;
  if ( !a1 || !*a1 )
    return fwrite("''", (size_t)&dword_0 + 1, 2u, stdout);
  if ( *a1 != 39 )
    goto LABEL_8;
  do
  {
    result = fwrite("\\'", 1u, 2u, stdout);
    v4 = *(unsigned __int8 *)++v1;
    v3 = v4;
  }
  while ( v4 == 39 );
  if ( v3 )
  {
LABEL_8:
    fputc(39, stdout);
    while ( 1 )
    {
      v5 = strchr(v1, 39);
      v6 = v5;
      if ( !v5 )
        break;
      fwrite(v1, v5 - v1, 1u, stdout);
      result = fputc(39, stdout);
      v7 = (unsigned __int8)*v6;
      if ( v7 == 39 )
      {
        do
        {
          result = fwrite("\\'", 1u, 2u, stdout);
          v8 = (unsigned __int8)*++v6;
          v7 = v8;
        }
        while ( v8 == 39 );
      }
      if ( !v7 )
        return result;
      v1 = v6;
      fputc(39, stdout);
    }
    fputs(v1, stdout);
    return fputc(39, stdout);
  }
  return result;
}
// 0: using guessed type int dword_0;

//----- (0007DFF0) --------------------------------------------------------
int __fastcall sub_7DFF0(int a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  int v5; // r7
  int v6; // r12
  int v7; // r4
  int v8; // r0
  int v9; // r1
  int result; // r0
  unsigned int v11; // r12
  int v12; // r2
  const char *v13; // r2

  v5 = *(_DWORD *)(a1 + 68);
  v6 = *(_DWORD *)(a1 + 100);
  v7 = v5;
  while ( *(unsigned __int16 *)(v7 + 2) != a2 )
  {
    --v6;
    v7 += 64;
    if ( v6 <= 0 )
    {
      if ( a2 <= 0x7F && (dword_9F184[a2] & 0x30000) != 0 )
      {
        v8 = *(unsigned __int16 *)(a1 + 96);
        if ( v8 != 0x8000 )
        {
          v9 = *(_DWORD *)(a1 + 20);
          *a3 = v5 + (v8 << 6);
          *(_DWORD *)(a1 + 20) = v9 - 1;
          *a4 = 1;
          return 0;
        }
      }
      v12 = *(_DWORD *)(a1 + 12) & 4;
LABEL_10:
      if ( !v12 )
        return -1;
      fprintf(stderr, off_B84C8[0], *(_DWORD *)(a1 + 24), a2);
LABEL_20:
      (*(void (__fastcall **)(int, int))(a1 + 84))(a1, 1);
      exit(1);
    }
  }
  v11 = *(_DWORD *)(v7 + 16);
  result = v11 & 0x280000;
  if ( (v11 & 0x280000) != 0 )
  {
    v12 = *(_DWORD *)(a1 + 12) & 4;
    if ( (_UNKNOWN *)v11 != &loc_80100 || !*(_DWORD *)(v7 + 52) )
      goto LABEL_10;
    if ( v12 )
    {
      fprintf(stderr, off_B84C0[0], *(_DWORD *)(a1 + 24));
      v13 = *(const char **)(v7 + 44);
      if ( v13 )
        fprintf(stderr, " -- %s", v13);
      fputc(10, stderr);
      goto LABEL_20;
    }
    return -1;
  }
  else
  {
    *a3 = v7;
    *a4 = 1;
  }
  return result;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B84C0: using guessed type char *off_B84C0[81];
// B84C8: using guessed type char *off_B84C8[79];

//----- (0007E1AC) --------------------------------------------------------
size_t __fastcall sub_7E1AC(int *a1, unsigned __int16 *a2, const char **a3, const char **a4)
{
  int v5; // r12
  int v6; // r0
  int v7; // r3
  FILE *v8; // r1
  const char *v9; // r0
  size_t result; // r0
  const char **v11; // [sp+4h] [bp-Ch]

  v5 = *a1;
  v6 = option_usage_fp;
  if ( (v5 & 2) == 0 )
  {
    v8 = (FILE *)option_usage_fp;
    v9 = *a4;
    return fputs(v9, v8);
  }
  v7 = *a2;
  if ( (v7 & 0x80) != 0 || (dword_9F184[(unsigned __int8)v7] & 0x4000) == 0 )
  {
    if ( (~v5 & 0x1001) == 0 )
    {
      v11 = a3;
      fputc(32, (FILE *)option_usage_fp);
      v6 = option_usage_fp;
      a3 = v11;
    }
    v8 = (FILE *)v6;
    v9 = *a3;
    return fputs(v9, v8);
  }
  result = fprintf((FILE *)option_usage_fp, "   -%c", v7);
  if ( (~*a1 & 0x1001) == 0 )
    return fwrite(", ", 1u, 2u, (FILE *)option_usage_fp);
  return result;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// 107410: using guessed type int option_usage_fp;

//----- (0007E2F8) --------------------------------------------------------
char *__fastcall sub_7E2F8(int a1)
{
  int v1; // r7
  int v2; // r5
  char *v3; // lr
  _DWORD *v4; // r3
  char *v5; // r2
  int v6; // t1

  v1 = a1;
  v2 = dword_9F184[a1 + 150];
  v3 = (char *)calloc(0x100u, 1u);
  if ( !v3 )
  {
    fwrite("no memory for char-mapper span map\n", 1u, 0x23u, stderr);
    exit(1);
  }
  v4 = &unk_9F188;
  v5 = v3 + 2;
  while ( v4 != (_DWORD *)&unk_9F380 )
  {
    v6 = v4[1];
    ++v4;
    ++v5;
    if ( (v2 & v6) != 0 )
      *(v5 - 1) = 1;
  }
  dword_1072C0[v1 + 17] = (int)v3;
  return v3;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// 9F184: using guessed type _DWORD dword_9F184[1];
// 1072C0: using guessed type int dword_1072C0[];

//----- (0007E3DC) --------------------------------------------------------
int __fastcall sub_7E3DC(_DWORD *a1, _DWORD *a2)
{
  int v3; // r5
  int v4; // r2
  int v5; // r3
  bool v6; // zf
  unsigned int v7; // r3
  _BYTE *v9; // r2
  int v10; // r2
  int v11; // r3
  _BYTE *v12; // r2
  int v13; // r0
  int v14; // r0

  v3 = *a2;
  v4 = a2[3];
  v5 = *(_DWORD *)(*a2 + 16) & 0xFFFFF00 | a2[2];
  v6 = (a2[2] & 0x20) == 0;
  a2[2] = v5;
  if ( !v6 || (v5 & 0xF000) == 0 )
  {
    if ( v4 == 1 )
    {
      ++a1[5];
      return 0;
    }
    if ( a2[1] )
    {
      fprintf(stderr, off_B84EC[0], a1[6], *(_DWORD *)(v3 + 52));
      return -1;
    }
LABEL_13:
    a1[5] = 0;
    return 0;
  }
  if ( (v5 & 0x10000) != 0 )
  {
    if ( v4 == 1 )
    {
      v12 = (_BYTE *)(a1[5] + 1);
      a1[5] = v12;
      if ( *v12 )
      {
LABEL_29:
        a2[1] = v12;
        goto LABEL_13;
      }
      v11 = a1[4];
      v12 = *(_BYTE **)(a1[2] + 4 * v11);
      if ( !v12 || *v12 == 45 )
      {
        a2[1] = 0;
        goto LABEL_13;
      }
    }
    else
    {
      if ( v4 != 2 )
        sub_7CEC0((int)off_B8494[0]);
      if ( a2[1] )
        goto LABEL_13;
      if ( (a1[3] & 3) == 0 )
        goto LABEL_13;
      v11 = a1[4];
      v12 = *(_BYTE **)(a1[2] + 4 * v11);
      if ( !v12 || *v12 == 45 )
        goto LABEL_13;
    }
    a1[4] = v11 + 1;
    goto LABEL_29;
  }
  v7 = a1[4];
  if ( v4 == 1 )
  {
    v9 = (_BYTE *)(a1[5] + 1);
    a1[5] = v9;
    if ( !*v9 )
    {
      v10 = a1[2];
      a1[4] = v7 + 1;
      v9 = *(_BYTE **)(v10 + 4 * v7++);
      a1[5] = v9;
    }
    a2[1] = v9;
  }
  else if ( v4 == 2 && !a2[1] )
  {
    v13 = a1[2];
    a1[4] = v7 + 1;
    v14 = *(_DWORD *)(v13 + 4 * v7++);
    a2[1] = v14;
  }
  if ( a1[1] >= v7 )
    goto LABEL_13;
  fprintf(stderr, off_B84E0[0], a1[6], *(_DWORD *)(v3 + 52));
  return -1;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8494: using guessed type char *off_B8494[92];
// B84E0: using guessed type char *off_B84E0[73];
// B84EC: using guessed type char *off_B84EC[70];

//----- (0007E624) --------------------------------------------------------
void __fastcall __noreturn sub_7E624(const char *a1)
{
  size_t v1; // r0

  v1 = strlen(a1);
  fprintf(stderr, off_B8464[0], v1);
  sub_7CE5C(1);
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8464: using guessed type char *off_B8464[104];

//----- (0007E680) --------------------------------------------------------
char *__fastcall sub_7E680(char *result)
{
  int v1; // r5
  int v2; // r8
  int v3; // r4
  char *v4; // r7
  int v5; // r5
  int v6; // r3
  int v7; // r2
  const char *v8; // r11
  int v9; // r10

  v1 = *((_DWORD *)result + 25);
  v2 = *((_DWORD *)result + 20);
  v3 = *((_DWORD *)result + 17);
  if ( v1 > 0 )
  {
    v4 = result;
    v5 = v1 - 1;
    while ( 1 )
    {
      v6 = *(_DWORD *)(v3 + 16);
      v7 = (unsigned __int16)v6 >> 12;
      if ( v7 != 1 )
        break;
      if ( (v6 & 0x400) != 0 )
        *(_DWORD *)(*(_DWORD *)(v2 + 68) + v3 - *((_DWORD *)v4 + 17) + 28) = 0;
      if ( (v6 & 0x40) != 0 )
      {
        v8 = *(const char **)(v3 + 24);
        v9 = *(_DWORD *)(v2 + 68) + v3 - *((_DWORD *)v4 + 17);
        result = _strdup(v8);
        if ( !result )
          sub_7E624(v8);
        --v5;
        *(_DWORD *)(v9 + 24) = result;
        v3 += 64;
        if ( v5 == -1 )
          return result;
      }
      else
      {
LABEL_5:
        --v5;
        v3 += 64;
        if ( v5 == -1 )
          return result;
      }
    }
    if ( v7 == 6 )
      *(_DWORD *)(*(_DWORD *)(v2 + 68) + v3 - *((_DWORD *)v4 + 17) + 28) = 0;
    goto LABEL_5;
  }
  return result;
}

//----- (0007E784) --------------------------------------------------------
int __fastcall sub_7E784(int **a1, int a2)
{
  int *v4; // r4
  int v5; // r3
  int v6; // r0
  int result; // r0
  size_t v8; // r9
  int *v9; // r0
  int *v10; // r0

  v4 = *a1;
  if ( *a1 )
  {
    v5 = *v4;
    v6 = v4[1];
    if ( *v4 >= v6 )
    {
      v4[1] = v6 + 8;
      v8 = 4 * v6 + 40;
      v9 = (int *)realloc(v4, v8);
      if ( !v9 )
      {
        fprintf(stderr, off_B8474[0], v8, v4);
        sub_7CE5C(1);
      }
      v5 = *v9;
      v4 = v9;
      *a1 = v9;
    }
    result = v5 + 1;
  }
  else
  {
    v10 = (int *)malloc(0x20u);
    v4 = v10;
    if ( !v10 )
      sub_C610(32);
    *a1 = v10;
    v5 = 0;
    *v10 = 0;
    result = 1;
    v4[1] = 6;
  }
  *v4 = result;
  v4[v5 + 2] = a2;
  return result;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8474: using guessed type char *off_B8474[100];

//----- (0007E89C) --------------------------------------------------------
int __fastcall sub_7E89C(int **a1, const void *a2, size_t a3, const char *a4, int a5)
{
  size_t v7; // r4
  _DWORD *v8; // r0
  int v9; // r5
  char *v10; // r9
  int v11; // r4
  _BYTE *v12; // r8
  int v13; // r3
  const char *v14; // r7
  signed int v15; // r5
  char *v16; // r10
  int v18; // r3
  int v19; // r2
  const char *v20; // r0
  char v21; // r0
  int v24; // [sp+Ch] [bp-18h]
  char *endptr; // [sp+18h] [bp-Ch] BYREF

  v7 = a5 + 12 + a3;
  v8 = malloc(v7);
  v9 = (int)v8;
  if ( !v8 )
    sub_C610(v7);
  v10 = (char *)(v8 + 2);
  if ( !a4 )
  {
    *v8 = 0;
    v8[1] = v10;
    goto LABEL_20;
  }
  *v8 = 1;
  if ( !a5 )
  {
    *((_BYTE *)v8 + 8) = 0;
    goto LABEL_19;
  }
  v11 = a5;
  v12 = v8 + 2;
  v24 = (int)v8;
  do
  {
    v13 = *(unsigned __int8 *)a4;
    v14 = a4 + 1;
    if ( !*a4 )
      break;
    if ( v13 != 38 || v11 <= 2 )
      goto LABEL_7;
    if ( a4[1] != 35 )
    {
      v15 = 4;
      v16 = (char *)&unk_9F384;
      if ( v11 < 4 )
        goto LABEL_14;
      while ( 1 )
      {
        if ( !strncmp(v14, v16 + 8, v15) )
        {
          v14 += v15;
          v11 -= v15;
          LOBYTE(v13) = *v16;
          goto LABEL_7;
        }
LABEL_14:
        if ( v16 == (char *)&unk_9F3C4 )
          goto LABEL_17;
        while ( 1 )
        {
          v16 += 16;
          v15 = *((_DWORD *)v16 + 1);
          if ( v15 <= v11 )
            break;
          if ( v16 == (char *)&unk_9F3C4 )
            goto LABEL_17;
        }
      }
    }
    v18 = *((unsigned __int8 *)a4 + 2);
    if ( v18 == 120 )
      v19 = 16;
    else
      v19 = 10;
    if ( v18 == 120 )
      v20 = a4 + 3;
    else
      v20 = a4 + 2;
    v21 = strtoul(v20, &endptr, v19);
    if ( *endptr == 59 && endptr - a4 <= v11 )
    {
      v11 -= endptr - a4;
      v14 = endptr + 1;
      LOBYTE(v13) = v21;
      goto LABEL_7;
    }
LABEL_17:
    LOBYTE(v13) = 38;
LABEL_7:
    --v11;
    a4 = v14;
    *v12++ = v13;
  }
  while ( v11 > 0 );
  v9 = v24;
  *v12 = 0;
LABEL_19:
  v10 += a5 + 1;
  *(_DWORD *)(v9 + 4) = v10;
LABEL_20:
  memcpy(v10, a2, a3);
  *(_BYTE *)(*(_DWORD *)(v9 + 4) + a3) = 0;
  sub_7E784(a1, v9);
  return v9;
}

//----- (0007EAC8) --------------------------------------------------------
size_t __fastcall sub_7EAC8(const char **a1, int a2)
{
  unsigned int (__fastcall *v4)(unsigned int, int); // r1
  const char *v5; // r2
  int v6; // r3
  const char *v7; // r1
  int v8; // r3

  v4 = *(unsigned int (__fastcall **)(unsigned int, int))(a2 + 40);
  if ( v4 == optionPrintVersion )
  {
    printf("            echo \"$%s_%s_TEXT\"\n            exit 0\n", *a1, "VERSION");
  }
  else if ( (char *)v4 == (char *)optionPagedUsage )
  {
    printf("            echo \"$%s_LONGUSAGE_TEXT\" | ${PAGER-more}\n            exit 0\n", *a1);
  }
  else if ( v4 == optionLoadOpt )
  {
    printf("            %s\n", "echo 'Warning:  Cannot load options files' >&2");
    printf("            %s\n", "OPT_ARG_NEEDED=YES");
  }
  else
  {
    v5 = *(const char **)(a2 + 48);
    if ( v5 )
    {
      v6 = *(unsigned __int16 *)(a2 + 12);
      v7 = *a1;
      if ( v6 == 1 )
      {
        printf(
          "            if [ -n \"${%1$s_%2$s}\" ] && ${%1$s_%2$s_set} ; then\n"
          "                echo 'Error:  duplicate %2$s option'\n"
          "                echo \"$%1$s_USAGE_TEXT\"\n"
          "                exit 1\n"
          "            fi >&2\n"
          "            %1$s_%2$s_set=true\n"
          "            OPT_NAME='%2$s'\n",
          v7,
          v5);
      }
      else
      {
        if ( v6 != 0xFFFF )
        {
          printf(
            "            if [ $%1$s_%2$s_CT -gt %3$u ] ; then\n"
            "                echo 'Error:  more than %3$d %2$s options'\n"
            "                echo \"$%1$s_USAGE_TEXT\"\n"
            "                exit 1\n"
            "            fi >&2\n",
            v7,
            v5,
            v6);
          v7 = *a1;
          v5 = *(const char **)(a2 + 48);
        }
        printf(
          "            %1$s_%2$s_CT=`expr ${%1$s_%2$s_CT} + 1`\n"
          "            OPT_ELEMENT=\"_${%1$s_%2$s_CT}\"\n"
          "            OPT_NAME='%2$s'\n",
          v7,
          v5);
      }
      v8 = *(_DWORD *)(a2 + 16);
      if ( (v8 & 0xF000) != 0 )
      {
        if ( (v8 & 0x10000) != 0 )
        {
          printf(
            "            eval %1$s_%2$s${OPT_ELEMENT}=true\n            export %1$s_%2$s${OPT_ELEMENT}\n",
            *a1,
            *(const char **)(a2 + 48));
          printf("            %s\n", "OPT_ARG_NEEDED=OK");
        }
        else
        {
          printf("            %s\n", "OPT_ARG_NEEDED=YES");
        }
      }
      else
      {
        printf(
          "            eval %1$s_%2$s${OPT_ELEMENT}=true\n            export %1$s_%2$s${OPT_ELEMENT}\n",
          *a1,
          *(const char **)(a2 + 48));
        printf("            %s\n", "OPT_ARG_NEEDED=NO");
      }
    }
    else if ( v4 )
    {
      printf("            echo \"$%s_%s_TEXT\"\n            exit 0\n", *a1, "LONGUSAGE");
    }
    else
    {
      printf("            %s\n", "echo 'Warning:  Cannot save options files' >&2");
      printf("            %s\n", "OPT_ARG_NEEDED=OK");
    }
  }
  return fwrite("            ;;\n\n", 1u, 0x10u, stdout);
}
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;

//----- (0007ED38) --------------------------------------------------------
int __fastcall sub_7ED38(int a1)
{
  int v2; // r5
  int v3; // r4
  int v4; // r1

  v2 = *(_DWORD *)(a1 + 100);
  v3 = *(_DWORD *)(a1 + 68);
  fwrite("        case \"${OPT_CODE}\" in\n", 1u, 0x1Eu, stdout);
  if ( v2 > 0 )
  {
    do
    {
      if ( (*(_DWORD *)(v3 + 16) & 0x280000) == 0 )
      {
        v4 = *(unsigned __int16 *)(v3 + 2);
        if ( (v4 & 0x80) == 0 && (dword_9F184[(unsigned __int8)v4] & 0x4000) != 0 )
        {
          printf("        '%c' )\n", v4);
          sub_7EAC8((const char **)(a1 + 32), v3);
        }
      }
      --v2;
      v3 += 64;
    }
    while ( v2 );
  }
  return printf(
           "        * )\n"
           "            echo Unknown %s: \"${OPT_CODE}\" >&2\n"
           "            echo \"$%s_USAGE_TEXT\" >&2\n"
           "            exit 1\n"
           "            ;;\n"
           "        esac\n",
           "flag",
           *(const char **)(a1 + 32));
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;

//----- (0007EE38) --------------------------------------------------------
int __fastcall sub_7EE38(const char *a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  size_t v8; // r8
  int v9; // r11
  _DWORD *v10; // r10
  size_t v11; // r9
  bool v12; // cc
  int v13; // r11
  const __int32_t **v14; // r0
  size_t v15; // r2
  const __int32_t *v16; // r3
  const char *v17; // r0
  int v18; // r1
  int v19; // lr
  int v20; // t1
  int v21; // t1
  unsigned __int8 *v22; // r1
  int v23; // r2
  const char *v24; // r0
  size_t v25; // r1
  int v26; // lr
  int v27; // t1
  int v28; // t1
  char *v30; // r5
  const char *v31; // r9
  char v32; // r1
  int v33; // t1
  _BYTE dest[32]; // [sp+Ch] [bp-28h] BYREF

  v8 = strlen(a1) - 1;
  if ( v8 <= 0x1E )
  {
    v9 = *a4;
    v10 = (_DWORD *)*a3;
    v11 = 2;
    v12 = v9 <= 0;
    v13 = v9 - 1;
    if ( !v12 )
    {
      do
      {
        if ( a2 != v10 && (v10[4] & 0x280000) == 0 )
        {
          v14 = _ctype_toupper_loc();
          v15 = 0;
          v16 = *v14;
          v17 = a1 - 1;
          v18 = v10[13] - 1;
          while ( 1 )
          {
            v20 = *(unsigned __int8 *)++v18;
            v19 = v20;
            v21 = *(unsigned __int8 *)++v17;
            if ( v16[v19] != v16[v21] )
              break;
            ++v15;
          }
          v22 = (unsigned __int8 *)v10[14];
          if ( v11 < v15 )
            v11 = v15;
          if ( v22 )
          {
            if ( v16[*(unsigned __int8 *)a1] == v16[*v22] )
            {
              v23 = v10[14];
              v24 = a1;
              v25 = 0;
              do
              {
                v27 = *(unsigned __int8 *)++v23;
                v26 = v27;
                ++v25;
                v28 = *(unsigned __int8 *)++v24;
              }
              while ( v16[v26] == v16[v28] );
              if ( v11 < v25 )
                v11 = v25;
            }
          }
        }
        --v13;
        v10 += 16;
      }
      while ( v13 != -1 );
    }
    if ( v8 > v11 )
    {
      memcpy(dest, a1, v11);
      v30 = &dest[v11];
      v31 = &a1[v11];
      while ( 1 )
      {
        *v30 = 0;
        printf("        '%s' | \\\n", dest);
        v32 = *v31;
        v33 = *(unsigned __int8 *)++v31;
        *v30 = v32;
        if ( !v33 )
          break;
        ++v30;
      }
      v30[1] = 0;
    }
  }
  return printf("        '%s' )\n", a1);
}

//----- (0007F000) --------------------------------------------------------
int __fastcall sub_7F000(int a1)
{
  int v2; // r4
  int v3; // r5
  const char *v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  char *v8; // r0
  FILE **v10; // [sp+0h] [bp-1Ch]

  v2 = *(_DWORD *)(a1 + 68);
  v3 = *(_DWORD *)(a1 + 100);
  v10 = &stdout;
  fwrite("        case \"${OPT_CODE}\" in\n", (size_t)&dword_0 + 1, 0x1Eu, stdout);
  do
  {
    if ( (*(_DWORD *)(v2 + 16) & 0x280000) == 0 )
    {
      sub_7EE38(*(const char **)(v2 + 52), (_DWORD *)v2, (_DWORD *)(a1 + 68), (int *)(a1 + 100));
      sub_7EAC8((const char **)(a1 + 32), v2);
      v4 = *(const char **)(v2 + 56);
      if ( v4 )
      {
        sub_7EE38(v4, (_DWORD *)v2, (_DWORD *)(a1 + 68), (int *)(a1 + 100));
        if ( *(unsigned int (__fastcall **)(unsigned int, int))(v2 + 40) == optionLoadOpt )
        {
          printf("            %s\n", "echo 'Warning:  Cannot suppress the loading of options files' >&2");
        }
        else
        {
          v5 = *(_DWORD *)(a1 + 32);
          v6 = *(_DWORD *)(v2 + 48);
          v7 = *(_DWORD *)(v2 + 60);
          if ( *(_WORD *)(v2 + 12) == 1 )
            v8 = "ME='%2$s'\n";
          else
            v8 = " ;;\n    esac\n";
          if ( *(_WORD *)(v2 + 12) == 1 )
            printf(v8 + 11, v5, v6, v7, v10);
          else
            printf(v8 + 14, v5, v6, v7, v10);
        }
        printf("            %s\n", "OPT_ARG_NEEDED=NO");
        fwrite("            ;;\n\n", 1u, 0x10u, *v10);
      }
    }
    --v3;
    v2 += 64;
  }
  while ( v3 > 0 );
  return printf(
           "        * )\n"
           "            echo Unknown %s: \"${OPT_CODE}\" >&2\n"
           "            echo \"$%s_USAGE_TEXT\" >&2\n"
           "            exit 1\n"
           "            ;;\n"
           "        esac\n",
           "option",
           *(const char **)(a1 + 32));
}
// 7F0F9: variable 'v10' is possibly undefined
// 0: using guessed type int dword_0;
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;

//----- (0007F19C) --------------------------------------------------------
int __fastcall sub_7F19C(_DWORD *a1, _DWORD *a2)
{
  if ( (a2[2] & 4) == 0 || (*(_DWORD *)(*a2 + 16) & 0x2000000) == 0 )
    return sub_7E3DC(a1, a2);
  fprintf(stderr, off_B8508[0], *(_DWORD *)(*a2 + 52));
  return -1;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8508: using guessed type char *off_B8508[63];

//----- (0007F244) --------------------------------------------------------
void __fastcall optionPagedUsage(int a1, int a2)
{
  char *v3; // r7
  char *v4; // r0
  const char *v5; // r9
  size_t v6; // r6
  size_t v7; // r6
  void *v8; // r0
  int v9; // r10
  __pid_t v10; // r10
  char *v11; // r9
  size_t v12; // r7
  void *v13; // r0
  void *v14; // r5
  __mode_t v15; // r8
  int v16; // r7
  void (__fastcall *v17)(int, _DWORD); // r2

  if ( !dword_1073BC )
  {
    if ( (*(_DWORD *)(a2 + 16) & 8) != 0 )
      return;
    v10 = getpid();
    v11 = getenv("TMPDIR");
    if ( !v11 )
      v11 = "/tmp";
    v12 = strlen(v11) + 26;
    v13 = malloc(v12);
    v14 = v13;
    if ( !v13 )
      sub_C610(v12);
    sub_6C054((int)v13, v12, "%s/use-%u.XXXXXX", v11, v10);
    v15 = umask(0x3Fu);
    v16 = mkstemp64(v14);
    umask(v15);
    if ( v16 < 0 )
    {
      free(v14);
      option_usage_fp = 0;
    }
    else
    {
      dword_1073C0 = (int)v14;
      option_usage_fp = (int)fdopen(v16, "w");
      if ( option_usage_fp )
        goto LABEL_19;
    }
    (*(void (__fastcall **)(int, _DWORD))(a1 + 84))(a1, 0);
LABEL_19:
    dword_1073BC = 1;
    byte_1073C4 = byte_1072C4;
    sub_8C1A8((void (*)(void *))optionPagedUsage);
    v17 = *(void (__fastcall **)(int, _DWORD))(a1 + 84);
    byte_1072C4 = 0;
    v17(a1, 0);
    exit(1);
  }
  if ( dword_1073BC == 1 )
  {
    v3 = (char *)dword_1073C0;
    fclose((FILE *)option_usage_fp);
    option_usage_fp = 0;
    v4 = getenv("PAGER");
    v5 = v4;
    if ( v4 )
    {
      v6 = strlen(v4) + 22;
    }
    else
    {
      v6 = 26;
      v5 = "more";
    }
    v7 = v6 + 2 * strlen(v3);
    v8 = malloc(v7);
    v9 = (int)v8;
    if ( !v8 )
      sub_C610(v7);
    sub_6C054((int)v8, v7, "%1$s %2$s ; rm -f %2$s", v5, v3);
    free(v3);
    dword_1073C0 = v9;
    if ( byte_1073C4 )
    {
      fwrite("\nexit 0\n", 1u, 8u, stdout);
      fclose(stdout);
      dup2(2, 1);
    }
    else
    {
      fclose(stderr);
      dup2(1, 2);
    }
    system((const char *)dword_1073C0);
    free((void *)dword_1073C0);
  }
}
// B3E8: using guessed type int __fastcall mkstemp64(_DWORD);
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// 1072C4: using guessed type char byte_1072C4;
// 1073BC: using guessed type int dword_1073BC;
// 1073C0: using guessed type int dword_1073C0;
// 1073C4: using guessed type char byte_1073C4;
// 107410: using guessed type int option_usage_fp;

//----- (0007F530) --------------------------------------------------------
char *__fastcall sub_7F530(int a1, const char **a2)
{
  int v2; // r2
  char *v4; // r4
  int v5; // r1
  int v6; // r3
  int v7; // t1
  const char *v8; // r8
  int *v9; // r11
  char *v10; // r0
  int v11; // r9
  void *v12; // r0
  int v13; // r5
  FILE *v14; // r7
  const char *v15; // r6
  char *v16; // r0
  char *v18; // r0
  _BYTE *v19; // r9
  char *v20; // r0
  int v21; // r4
  const char *v22; // r0
  char *v23; // r0
  const char *v24; // r10
  size_t v25; // r7
  size_t v26; // r7
  char *v27; // r0
  const char *v28; // r3
  size_t v29; // r11
  size_t v30; // r11
  void *v31; // r0
  void *v32; // r9
  int *v33; // r8
  int v34; // r5
  FILE *v35; // r7
  const char *v36; // r6
  char *v37; // r0
  const char *v39; // [sp+14h] [bp-1078h]
  _BYTE v40[16]; // [sp+18h] [bp-1074h] BYREF
  int v41; // [sp+28h] [bp-1064h]
  _BYTE dest[4092]; // [sp+84h] [bp-1008h] BYREF

  v2 = *(unsigned __int16 *)(a1 + 94);
  if ( (v2 & 0x7FFF) == 0 )
    return 0;
  v4 = *(char **)(*(_DWORD *)(a1 + 68) + (v2 << 6) + 24);
  if ( v4 && *v4 )
    goto LABEL_9;
  v5 = *(_DWORD *)(a1 + 52);
  if ( !v5 )
    return 0;
  if ( *(_DWORD *)(v5 + 4) )
  {
    v6 = v5 + 4;
    do
    {
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v6 += 4;
    }
    while ( v7 );
  }
  v4 = *(char **)v5;
  if ( **(_BYTE **)v5 != 36 )
  {
LABEL_9:
    v8 = 0;
    goto LABEL_10;
  }
  v19 = v4 + 1;
  v20 = strchr(v4 + 1, 47);
  v8 = v20;
  if ( !v20 )
  {
    v4 = getenv(v4 + 1);
    if ( v4 )
      goto LABEL_10;
LABEL_43:
    v4 = 0;
    fprintf(stderr, off_B8540[0], *(_DWORD *)(a1 + 28));
    fprintf(stderr, off_B8510[0], v19);
    return v4;
  }
  v21 = v20 - v19;
  if ( v20 - v19 > 127 )
    return 0;
  v22 = (const char *)memcpy(dest, v19, v20 - v19);
  dest[v21] = 0;
  v23 = getenv(v22);
  v24 = v23;
  if ( !v23 )
    goto LABEL_43;
  v25 = strlen(v23);
  v26 = v25 + strlen(v8) + 2;
  v27 = (char *)malloc(v26);
  v4 = v27;
  if ( !v27 )
    sub_C610(v26);
  v28 = v8;
  v8 = (_BYTE *)(&dword_0 + 1);
  sprintf(v27, "%s/%s", v24, v28);
LABEL_10:
  if ( !_xstat64(3, v4, v40) )
  {
    if ( (v41 & 0xF000) == 0x4000 )
    {
      v29 = strlen(v4);
      v39 = *(const char **)(a1 + 36);
      v30 = v29 + strlen(v39) + 2;
      v31 = malloc(v30);
      v32 = v31;
      if ( !v31 )
        sub_C610(v30);
      sub_6C054((int)v31, v30, "%s/%s", v4, v39);
      if ( v8 )
        free(v4);
      if ( _xstat64(3, v32, v40) )
      {
        v33 = _errno_location();
        if ( *v33 != 2 )
        {
          v4 = 0;
          fprintf(stderr, off_B8540[0], *(_DWORD *)(a1 + 28));
          v34 = *v33;
          v35 = stderr;
          v36 = off_B8500[0];
          v37 = strerror(*v33);
          fprintf(v35, v36, v34, v37, v32);
          free(v32);
          return v4;
        }
        v4 = (char *)v32;
        v41 = 0x8000;
        v8 = (_BYTE *)(&dword_0 + 1);
        goto LABEL_17;
      }
      if ( (v41 & 0xF000) == 0x8000 )
      {
        v4 = (char *)v32;
        v8 = (_BYTE *)(&dword_0 + 1);
        goto LABEL_17;
      }
      v4 = (char *)v32;
      fprintf(stderr, off_B8540[0], *(_DWORD *)(a1 + 28), v32);
      goto LABEL_25;
    }
    if ( (v41 & 0xF000) == 0x8000 )
      goto LABEL_17;
    fprintf(stderr, off_B8540[0], *(_DWORD *)(a1 + 28), v4);
    if ( v8 )
    {
LABEL_25:
      v18 = v4;
      v4 = 0;
      free(v18);
      return v4;
    }
    return 0;
  }
  v9 = _errno_location();
  if ( *v9 != 2
    || (v10 = strrchr(v4, 47)) != 0
    && ((v11 = v10 - v4, (unsigned int)(v10 - v4) >= 0x1000)
     || (v12 = memcpy(dest, v4, v10 - v4), dest[v11] = 0, _xstat64(3, v12, v40))
     || (v41 & 0xF000) != 0x4000) )
  {
    fprintf(stderr, off_B8540[0], *(_DWORD *)(a1 + 28));
    v13 = *v9;
    v14 = stderr;
    v15 = off_B8500[0];
    v16 = strerror(*v9);
    fprintf(v14, v15, v13, v16, v4);
    if ( v8 )
      free(v4);
    return 0;
  }
  v41 = 0x8000;
LABEL_17:
  unlink(v4);
  *a2 = v8;
  return v4;
}
// 0: using guessed type int dword_0;
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8500: using guessed type char *off_B8500[65];
// B8510: using guessed type char *off_B8510[61];
// B8540: using guessed type char *off_B8540[49];

//----- (0007F9CC) --------------------------------------------------------
char *__fastcall sub_7F9CC(const char *a1, const char *a2)
{
  size_t v4; // r5
  int v5; // r3
  const char *v6; // r5
  int v7; // t1
  unsigned __int8 *v8; // r5
  char *v9; // r2
  char *v10; // r1
  DIR *v11; // r6
  int v12; // r0
  char *v13; // r10
  int v15; // t1
  int v16; // r4
  size_t v17; // r0
  size_t v18; // r10
  char *v19; // r0
  char *v20; // r11
  char *v21; // r0
  char *v22; // r0
  int v23; // r5
  int v24; // r0
  int v25; // r8
  int v26; // r3
  char *v27; // r9
  int v28; // r2
  int v29; // t1
  int v30; // r7
  bool v31; // zf
  int v32; // r2
  const char *v33; // r3
  int v34; // r12
  const char *v35; // r1
  int v36; // r2
  const char *v37; // r1
  int v38; // r0
  const char *v39; // r1
  bool v40; // zf
  char *v41; // r3
  int v42; // t1
  char *v44; // r0
  char *v45; // r0
  size_t v46; // [sp+4h] [bp-1018h]
  char v47[8]; // [sp+10h] [bp-100Ch] BYREF

  if ( a1 )
  {
    v4 = 0;
    do
    {
LABEL_3:
      if ( strlen(a1) <= v4 )
        return 0;
LABEL_4:
      v5 = (unsigned __int8)a1[v4];
      v6 = &a1[v4];
      if ( v5 == 58 )
      {
        do
        {
          v7 = *(unsigned __int8 *)++v6;
          v5 = v7;
        }
        while ( v7 == 58 );
      }
      v8 = (unsigned __int8 *)(v6 + 1);
      v9 = v47;
      while ( 1 )
      {
        v10 = v9;
        *v9++ = v5;
        if ( !v5 )
          break;
        if ( v5 == 58 )
        {
          *v10 = 0;
          break;
        }
        if ( (unsigned int)(v9 - v47) >= 0x1000 )
          break;
        v15 = *v8++;
        v5 = v15;
      }
      v4 = v8 - (unsigned __int8 *)a1;
      if ( !v47[0] )
        return 0;
      v11 = opendir(v47);
    }
    while ( !v11 );
    do
    {
      v12 = readdir64(v11);
      if ( !v12 )
      {
        closedir(v11);
        if ( strlen(a1) > v4 )
          goto LABEL_4;
        return 0;
      }
    }
    while ( strcmp((const char *)(v12 + 19), a2) );
    v16 = 0;
    if ( *a2 == 47 )
    {
      v20 = _strdup(a2);
    }
    else
    {
      v17 = strlen(a2);
      v18 = v17;
      if ( v47[0] )
      {
        v46 = strlen(v47);
        v19 = (char *)malloc(v18 + 2 + v46);
        v20 = v19;
        if ( v19 )
        {
          memcpy(v19, v47, v46 + 1);
          v21 = &v20[v46];
          if ( v20[v46 - 1] != 47 )
          {
            v21 = &v20[v46 + 1];
            v20[v46] = 47;
            *v21 = 0;
          }
          goto LABEL_25;
        }
      }
      else
      {
        v44 = (char *)malloc(v17 + 3);
        v20 = v44;
        if ( v44 )
        {
          strcpy(v44, "./");
          v21 = v44 + 2;
LABEL_25:
          memcpy(v21, a2, v18 + 1);
          goto LABEL_26;
        }
      }
      v20 = 0;
    }
LABEL_26:
    if ( access(v20, 5) < 0 || (v22 = _strdup(v20)) == 0 )
    {
      free(v20);
      closedir(v11);
      goto LABEL_3;
    }
    v23 = (unsigned __int8)*v20;
    v13 = v22;
    v24 = (unsigned __int8)*v22;
    if ( v23 != 47 )
      LOBYTE(v23) = 46;
LABEL_31:
    v25 = v16;
    if ( v24 )
    {
      do
      {
        v26 = v16 + 1;
        if ( v24 != 47 )
        {
LABEL_33:
          v27 = &v13[v16];
          goto LABEL_34;
        }
        v30 = v16++;
        while ( 1 )
        {
          v24 = (unsigned __int8)v13[v16];
          v27 = &v13[v16];
          if ( v24 == 47 )
          {
            v32 = v16;
            v33 = &v13[v16 + 1];
            do
            {
              v34 = *(unsigned __int8 *)v33;
              v35 = v33;
              ++v32;
              ++v33;
            }
            while ( v34 == 47 );
            if ( v32 != v16 )
            {
              strcpy(&v13[v25 + 1], v35);
              v24 = (unsigned __int8)*v27;
            }
          }
          if ( v30 )
          {
            if ( v13[v25 - 1] == 92 )
              goto LABEL_31;
            if ( !v24 )
              goto LABEL_67;
          }
          if ( v24 != 46 )
            goto LABEL_31;
          v26 = v16 + 1;
          v36 = (unsigned __int8)v13[v16 + 1];
          v37 = &v13[v16 + 1];
          if ( !*v37 )
          {
LABEL_67:
            *(v27 - 1) = 0;
            goto LABEL_59;
          }
          if ( v36 == 47 )
          {
            v45 = &v13[v16];
            v16 = v30;
            strcpy(v45, v37);
            v24 = (unsigned __int8)v13[v30];
            goto LABEL_31;
          }
          if ( v36 != 46 )
            goto LABEL_33;
          v38 = (unsigned __int8)v13[v16 + 2];
          v39 = &v13[v16 + 2];
          v40 = v38 == 0;
          if ( *v39 )
            v40 = v38 == 47;
          if ( v40 )
            break;
          while ( 1 )
          {
LABEL_34:
            v29 = (unsigned __int8)*++v27;
            v28 = v29;
            v30 = v26;
            v25 = v26;
            v31 = v29 == 0;
            if ( v29 )
              v31 = v28 == 47;
            if ( v31 )
              break;
            v16 = v26++;
          }
          v16 += 2;
          if ( !v28 )
            goto LABEL_59;
        }
        v41 = &v13[v30];
        do
        {
          if ( v30-- == 0 )
            break;
          v42 = (unsigned __int8)*--v41;
        }
        while ( v42 != 47 );
        v16 = v30 & ~(v30 >> 31);
        strcpy(&v13[v30 + 1], v39);
        v24 = (unsigned __int8)v13[v16];
        v25 = v16;
      }
      while ( v13[v16] );
    }
LABEL_59:
    if ( !*v13 )
    {
      *v13 = v23;
      v13[1] = 0;
    }
    free(v20);
    closedir(v11);
    return v13;
  }
  return 0;
}
// BEFC: using guessed type int __fastcall readdir64(_DWORD);

//----- (0007FDCC) --------------------------------------------------------
_DWORD *__fastcall sub_7FDCC(_DWORD *result, unsigned __int16 *a2, int a3)
{
  _DWORD *v4; // r4
  int *v5; // r10
  int v6; // r3
  int v7; // t1
  int *v8; // r10
  int v9; // r3
  int v10; // t1
  int v11; // r3
  int v12; // r2
  int v13; // r3
  int v14; // r3
  int v15; // r3
  void (__fastcall *v16)(unsigned int, int); // r6
  bool v17; // zf
  size_t v19; // r10
  int v20; // r8
  int v21; // r7
  __int16 v22; // r3
  size_t v23; // r0
  int v24; // r8
  int v25; // r7
  __int16 v26; // r3
  int v27; // r3
  const char *v28; // r2
  char *v29; // r0
  int v30; // r3
  int v31; // t1
  const char *v32; // r3
  int v33; // r3
  char v34; // r2
  const char *v35; // [sp+14h] [bp-70h]
  char v36[12]; // [sp+20h] [bp-64h] BYREF
  _BYTE v37[80]; // [sp+2Ch] [bp-58h] BYREF

  v4 = result;
  if ( (result[3] & 0x40000) == 0 || a2[3] != 87 )
  {
    if ( !*((_DWORD *)a2 + 8) && !*((_DWORD *)a2 + 9) )
    {
      if ( !*((_DWORD *)a2 + 14) )
        goto LABEL_16;
      goto LABEL_15;
    }
    result = (_DWORD *)fputs(&ao_strs_strtable[dword_1073C8 + 203], (FILE *)option_usage_fp);
    v5 = (int *)*((_DWORD *)a2 + 8);
    if ( v5 )
    {
      if ( v5[1] == 0x8000 )
      {
        result = (_DWORD *)fprintf((FILE *)option_usage_fp, off_B85E0[0], *(_DWORD *)(v4[17] + (*v5 << 6) + 52));
      }
      else
      {
        fputs(off_B85E4[0], (FILE *)option_usage_fp);
        v6 = *v5;
        do
        {
          result = (_DWORD *)fprintf(
                               (FILE *)option_usage_fp,
                               &ao_strs_strtable[dword_1073C8 + 229],
                               *(_DWORD *)(v4[17] + (v6 << 6) + 52));
          v7 = v5[1];
          ++v5;
          v6 = v7;
        }
        while ( v7 != 0x8000 );
      }
      if ( !*((_DWORD *)a2 + 9) )
        goto LABEL_14;
      result = (_DWORD *)fputs(&ao_strs_strtable[dword_1073C8 + 217], (FILE *)option_usage_fp);
    }
    v8 = (int *)*((_DWORD *)a2 + 9);
    if ( v8 )
    {
      if ( v8[1] == 0x8000 )
      {
        result = (_DWORD *)fprintf((FILE *)option_usage_fp, off_B85B8[0], *(_DWORD *)(v4[17] + (*v8 << 6) + 52));
        if ( !*((_DWORD *)a2 + 14) )
        {
LABEL_16:
          v11 = *((_DWORD *)a2 + 4);
          v12 = (unsigned __int16)v11 >> 12;
          if ( v12 == 5 )
          {
            v16 = (void (__fastcall *)(unsigned int, int))*((_DWORD *)a2 + 10);
            v17 = v16 == 0;
            if ( v16 )
              v17 = v16 == optionNumericVal;
            if ( !v17 )
            {
              result = (_DWORD *)((int (__fastcall *)(int, unsigned __int16 *))v16)(1, a2);
              v11 = *((_DWORD *)a2 + 4);
            }
          }
          else if ( v12 == 7 )
          {
            result = (_DWORD *)(*((int (__fastcall **)(int, unsigned __int16 *))a2 + 10))(1, a2);
            if ( (*((_DWORD *)a2 + 4) & 0x800) == 0 )
              goto LABEL_19;
            goto LABEL_39;
          }
          if ( (v11 & 0x800) == 0 )
          {
LABEL_19:
            v13 = a2[4];
            if ( v13 != 0x8000 && a2[2] != v13 )
              return (_DWORD *)fprintf(
                                 (FILE *)option_usage_fp,
                                 &off_B8544[0][dword_1073C8],
                                 *(_DWORD *)(v4[17] + (v13 << 6) + 52));
            v14 = *((_DWORD *)a2 + 4);
            if ( (v14 & 0x100) != 0 && (v4[13] || v4[8]) && *a2 < (int)v4[26] )
            {
              result = (_DWORD *)fputs(&off_B858C[0][dword_1073C8], (FILE *)option_usage_fp);
              v14 = *((_DWORD *)a2 + 4);
            }
            if ( (unsigned __int16)v14 >> 12 == 4 )
            {
              result = (_DWORD *)fputs(&off_B857C[0][dword_1073C8], (FILE *)option_usage_fp);
            }
            else
            {
              v15 = a2[6];
              if ( a2[5] > 1u )
              {
                result = (_DWORD *)fprintf((FILE *)option_usage_fp, &off_B8580[0][dword_1073C8]);
              }
              else if ( v15 != 1 )
              {
                if ( a2[6] )
                {
                  if ( v15 == 0xFFFF )
                    result = (_DWORD *)fputs(&off_B8588[0][dword_1073C8], (FILE *)option_usage_fp);
                  else
                    result = (_DWORD *)fprintf((FILE *)option_usage_fp, &off_B85F4[0][dword_1073C8], a2[6]);
                }
                else
                {
                  result = (_DWORD *)fputs(&off_B85AC[0][dword_1073C8], (FILE *)option_usage_fp);
                }
              }
            }
            if ( (v4[3] & 3) == 0 && *((unsigned __int16 *)v4 + 49) == *a2 )
              return (_DWORD *)fputs(&off_B854C[0][dword_1073C8], (FILE *)option_usage_fp);
            return result;
          }
LABEL_39:
          result = (_DWORD *)fputs(&off_B855C[0][dword_1073C8], (FILE *)option_usage_fp);
          goto LABEL_19;
        }
LABEL_15:
        result = (_DWORD *)fprintf((FILE *)option_usage_fp, &off_B8550[0][dword_1073C8]);
        goto LABEL_16;
      }
      fputs(off_B85B4[0], (FILE *)option_usage_fp);
      v9 = *v8;
      do
      {
        result = (_DWORD *)fprintf(
                             (FILE *)option_usage_fp,
                             &ao_strs_strtable[dword_1073C8 + 229],
                             *(_DWORD *)(v4[17] + (v9 << 6) + 52));
        v10 = v8[1];
        ++v8;
        v9 = v10;
      }
      while ( v10 != 0x8000 );
    }
LABEL_14:
    if ( !*((_DWORD *)a2 + 14) )
      goto LABEL_16;
    goto LABEL_15;
  }
  v19 = 0;
  v20 = result[26];
  v21 = result[17];
  fprintf((FILE *)option_usage_fp, &ao_strs_strtable[dword_1073C8 + 229], off_B8600);
  do
  {
    if ( (*(_DWORD *)(v21 + 16) & 0x6280000) == 0 )
    {
      v22 = *(_WORD *)(v21 + 2);
      if ( (v22 & 0x80) != 0 || (dword_9F184[(unsigned __int8)v22] & 0x4000) == 0 )
      {
        v23 = strlen(*(const char **)(v21 + 52));
        if ( v19 < v23 )
          v19 = v23;
      }
    }
    --v20;
    v21 += 64;
  }
  while ( v20 > 0 );
  result = (_DWORD *)sub_6C054((int)v36, 0xCu, "%%-%us %%s\n", v19 + 4);
  v24 = v4[26];
  v25 = v4[17];
  if ( dword_1073C8 )
    --dword_1073C8;
  do
  {
    if ( (*(_DWORD *)(v25 + 16) & 0x6280000) == 0 )
    {
      v26 = *(_WORD *)(v25 + 2);
      if ( (v26 & 0x80) != 0 || (dword_9F184[(unsigned __int8)v26] & 0x4000) == 0 )
      {
        sub_7E1AC(v4 + 3, (unsigned __int16 *)(v25 + 2), (const char **)&dword_1072F4, (const char **)&dword_1072F8);
        v27 = *(_DWORD *)(v25 + 16);
        if ( (v27 & 0x10000) != 0 )
        {
          v28 = (const char *)dword_1072E8;
        }
        else
        {
          switch ( (unsigned __int16)v27 >> 12 )
          {
            case 0:
              v28 = (const char *)dword_1072EC;
              break;
            case 1:
              v28 = (const char *)dword_1072C8;
              break;
            case 2:
              v28 = (const char *)dword_1072D8;
              break;
            case 3:
              v28 = (const char *)dword_1072E0;
              break;
            case 4:
              v28 = (const char *)dword_1072DC;
              break;
            case 5:
              v28 = (const char *)dword_1072D0;
              break;
            case 6:
              v28 = (const char *)dword_1072E4;
              break;
            case 7:
              v28 = (const char *)dword_1072D4;
              break;
            case 8:
              v28 = (const char *)dword_107300;
              break;
            default:
              fprintf(stderr, off_B84D8[0], v4[7], *(_DWORD *)(v25 + 52));
              sub_7CEC0((int)off_B8490[0]);
          }
        }
        v29 = (char *)dword_107334;
        if ( !dword_107334 )
        {
          v35 = v28;
          v29 = sub_7E2F8(12);
          v28 = v35;
        }
        v30 = *(unsigned __int8 *)v28;
        if ( v29[v30] )
        {
          do
          {
            v31 = *(unsigned __int8 *)++v28;
            v30 = v31;
          }
          while ( v29[v31] );
        }
        v17 = v30 == 0;
        v32 = *(const char **)(v25 + 52);
        if ( v17 )
          sub_6C054((int)v37, 0x50u, (unsigned __int8 *)"%s", v32);
        else
          sub_6C054((int)v37, 0x50u, "%s=%s", v32, v28);
        fprintf((FILE *)option_usage_fp, v36, v37, *(_DWORD *)(v25 + 44));
        v33 = (unsigned __int16)*(_DWORD *)(v25 + 16) >> 12;
        if ( v33 == 2 || v33 == 4 )
        {
          if ( *(_DWORD *)(v25 + 40) )
            v34 = 1;
          else
            v34 = byte_1073CC;
          byte_1073CC = v34;
        }
        result = (_DWORD *)sub_7FDCC(v4, v25, a3);
      }
    }
    --v24;
    v25 += 64;
  }
  while ( v24 > 0 );
  return result;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8490: using guessed type char *off_B8490[93];
// B84D8: using guessed type char *off_B84D8[75];
// B8544: using guessed type char *off_B8544[48];
// B854C: using guessed type char *off_B854C[46];
// B8550: using guessed type char *off_B8550[45];
// B855C: using guessed type char *off_B855C[42];
// B857C: using guessed type char *off_B857C[34];
// B8580: using guessed type char *off_B8580[33];
// B8588: using guessed type char *off_B8588[31];
// B858C: using guessed type char *off_B858C[30];
// B85AC: using guessed type char *off_B85AC[22];
// B85B4: using guessed type char *off_B85B4[20];
// B85B8: using guessed type char *off_B85B8[19];
// B85E0: using guessed type char *off_B85E0[9];
// B85E4: using guessed type char *off_B85E4[8];
// B85F4: using guessed type char *off_B85F4[4];
// B8600: using guessed type char *off_B8600;
// 1072C8: using guessed type int dword_1072C8;
// 1072D0: using guessed type int dword_1072D0;
// 1072D4: using guessed type int dword_1072D4;
// 1072D8: using guessed type int dword_1072D8;
// 1072DC: using guessed type int dword_1072DC;
// 1072E0: using guessed type int dword_1072E0;
// 1072E4: using guessed type int dword_1072E4;
// 1072E8: using guessed type int dword_1072E8;
// 1072EC: using guessed type int dword_1072EC;
// 1072F4: using guessed type int dword_1072F4;
// 1072F8: using guessed type int dword_1072F8;
// 107300: using guessed type int dword_107300;
// 107334: using guessed type int dword_107334;
// 1073C8: using guessed type int dword_1073C8;
// 1073CC: using guessed type char byte_1073CC;
// 107410: using guessed type int option_usage_fp;

//----- (000806BC) --------------------------------------------------------
int __fastcall sub_806BC(_DWORD *a1, int a2, int a3)
{
  int v4; // r6
  int v6; // r5
  int v7; // r4
  __int16 v8; // r2
  _BOOL4 v9; // r2
  _BOOL4 v10; // r2
  int v11; // r3
  int v12; // r3
  int *v13; // r0
  int v14; // r3
  int v15; // r3
  _BOOL4 v16; // r3
  char *v17; // r10
  char v18; // r2
  int v20; // [sp+Ch] [bp-78h]
  _BYTE v22[80]; // [sp+2Ch] [bp-58h] BYREF

  v4 = 0;
  v20 = 0;
  v6 = a1[25];
  v7 = a1[17];
  do
  {
    v15 = *(_DWORD *)(v7 + 16);
    if ( (v15 & 0x6080000) != 0 )
    {
      if ( v15 == 524544 )
      {
        v16 = a2 == 0;
        if ( !*(_DWORD *)(v7 + 52) )
          v16 = 0;
        if ( v16 )
        {
          v17 = *(char **)(v7 + 44);
          if ( !v17 )
            v17 = off_B8558[0];
          sub_7E1AC(a1 + 3, (unsigned __int16 *)(v7 + 2), (const char **)&dword_1072F4, (const char **)&dword_1072F8);
          fprintf((FILE *)option_usage_fp, off_B8554[0], *(_DWORD *)(v7 + 52), v17);
        }
      }
    }
    else if ( (v15 & 0x200000) != 0 )
    {
      if ( !a2 )
      {
        ++v20;
        fprintf((FILE *)option_usage_fp, (const char *)dword_1072F0, *(_DWORD *)(v7 + 44), a3);
      }
    }
    else if ( (a1[3] & 0x40000) == 0
           || (v8 = *(_WORD *)(v7 + 2), (v8 & 0x80) == 0) && (dword_9F184[(unsigned __int8)v8] & 0x4000) != 0 )
    {
      v9 = v20 > 0;
      if ( a2 )
        v9 = 0;
      if ( v9 )
      {
        if ( a1[26] == v4 )
        {
          if ( (*(_DWORD *)(v7 - 48) & 0x200000) == 0 )
            fprintf((FILE *)option_usage_fp, (const char *)dword_1072F0, off_B8548[0], a3);
        }
        else
        {
          v10 = v6 == 1;
          if ( (a1[3] & 0x40000) == 0 )
            v10 = 0;
          if ( v10 )
            fprintf((FILE *)option_usage_fp, (const char *)dword_1072F0, off_B85FC[0], a3);
        }
      }
      sub_7E1AC(a1 + 3, (unsigned __int16 *)(v7 + 2), (const char **)&dword_1072F4, (const char **)&dword_1072F8);
      v11 = *(_DWORD *)(v7 + 16);
      if ( (v11 & 0x10000) != 0 )
      {
        v12 = dword_1072E8;
      }
      else
      {
        switch ( (unsigned __int16)v11 >> 12 )
        {
          case 0:
            v12 = dword_1072EC;
            break;
          case 1:
            v12 = dword_1072C8;
            break;
          case 2:
            v12 = dword_1072D8;
            break;
          case 3:
            v12 = dword_1072E0;
            break;
          case 4:
            v12 = dword_1072DC;
            break;
          case 5:
            v12 = dword_1072D0;
            break;
          case 6:
            v12 = dword_1072E4;
            break;
          case 7:
            v12 = dword_1072D4;
            break;
          case 8:
            v12 = dword_107300;
            break;
          default:
            fprintf(stderr, off_B84D8[0], a1[7], *(_DWORD *)(v7 + 52));
            sub_7CE5C(70);
        }
      }
      if ( *(_WORD *)(v7 + 10) )
        v13 = (int *)dword_1072CC;
      else
        v13 = dword_1072C0;
      if ( !*(_WORD *)(v7 + 10) )
        v13 = (int *)v13[10];
      sub_6C054((int)v22, 0x50u, (unsigned __int8 *)dword_1072FC, v12, *(_DWORD *)(v7 + 52), v13);
      fprintf((FILE *)option_usage_fp, byte_1073D0, v22, *(_DWORD *)(v7 + 44));
      v14 = (unsigned __int16)*(_DWORD *)(v7 + 16) >> 12;
      if ( v14 != 2 && v14 != 4 )
      {
        if ( a2 )
          goto LABEL_24;
LABEL_39:
        sub_7FDCC(a1, (unsigned __int16 *)v7, a3);
        goto LABEL_24;
      }
      if ( *(_DWORD *)(v7 + 40) )
        v18 = 1;
      else
        v18 = byte_1073CC;
      byte_1073CC = v18;
      if ( !a2 )
        goto LABEL_39;
    }
LABEL_24:
    --v6;
    v7 += 64;
    ++v4;
  }
  while ( v6 > 0 );
  return fputc(10, (FILE *)option_usage_fp);
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B84D8: using guessed type char *off_B84D8[75];
// B8548: using guessed type char *off_B8548[47];
// B8554: using guessed type char *off_B8554[44];
// B8558: using guessed type char *off_B8558[43];
// B85FC: using guessed type char *off_B85FC[2];
// 1072C0: using guessed type int dword_1072C0[];
// 1072C8: using guessed type int dword_1072C8;
// 1072CC: using guessed type int dword_1072CC;
// 1072D0: using guessed type int dword_1072D0;
// 1072D4: using guessed type int dword_1072D4;
// 1072D8: using guessed type int dword_1072D8;
// 1072DC: using guessed type int dword_1072DC;
// 1072E0: using guessed type int dword_1072E0;
// 1072E4: using guessed type int dword_1072E4;
// 1072E8: using guessed type int dword_1072E8;
// 1072EC: using guessed type int dword_1072EC;
// 1072F0: using guessed type int dword_1072F0;
// 1072F4: using guessed type int dword_1072F4;
// 1072F8: using guessed type int dword_1072F8;
// 1072FC: using guessed type int dword_1072FC;
// 107300: using guessed type int dword_107300;
// 1073CC: using guessed type char byte_1073CC;
// 107410: using guessed type int option_usage_fp;

//----- (00080B6C) --------------------------------------------------------
int __fastcall sub_80B6C(const char *a1)
{
  const unsigned __int16 **v2; // r7
  const char *v3; // r0
  int v4; // r3
  const char *v5; // r4
  unsigned __int16 v6; // r5
  int v7; // r6
  int *v8; // r0
  int *v9; // r8
  unsigned int v10; // r9
  int v11; // r0
  char *v12; // r5
  unsigned int v13; // r4
  unsigned int v14; // t1
  int v15; // r2
  int v16; // r0
  int v17; // r2
  unsigned int j; // r1
  int v19; // t1
  char *v21; // r5
  int *v22; // r0
  int *v23; // r10
  char *v24; // r0
  const char *v25; // r8
  char *v26; // r4
  _BOOL4 v27; // r9
  char *v28; // r0
  int v29; // r4
  char *v30; // r2
  int v31; // r7
  const char *v32; // r2
  const char **p_endptr; // r1
  int v34; // r0
  char *v35; // r2
  char *v36; // r2
  char *v37; // r2
  char *v38; // r2
  int v39; // r3
  const unsigned __int16 *i; // r1
  int v41; // r3
  int v42; // r0
  int v43; // r0
  __int16 v44; // r12
  int *v45; // r3
  int v46; // r10
  int v47; // r8
  int v48; // r11
  int *v49; // r4
  unsigned int v50; // r0
  int v51; // r0
  int v52; // r4
  int v53; // t1
  bool v54; // zf
  int *v55; // r2
  char *v56; // [sp+14h] [bp-18h] BYREF
  char *endptr; // [sp+18h] [bp-14h] BYREF
  int v58; // [sp+1Ch] [bp-10h] BYREF
  char v59[4]; // [sp+20h] [bp-Ch] BYREF

  v2 = _ctype_b_loc();
  v3 = a1;
  do
  {
    v4 = *(unsigned __int8 *)v3;
    v5 = v3++;
    v6 = (*v2)[v4];
    v7 = v6 & 0x2000;
  }
  while ( (v6 & 0x2000) != 0 );
  if ( v4 == 80 )
  {
    v21 = _strdup(v5 + 1);
    v22 = _errno_location();
    v23 = v22;
    if ( !v21 )
    {
      v7 = -1;
      *v22 = 12;
      return v7;
    }
    v24 = strchr(v21, 84);
    v25 = v24;
    if ( v24 )
    {
      *v24 = 0;
      v26 = (char *)sub_7C420(v21);
      v25 = sub_7C420(v25 + 1);
      v27 = v25 != 0;
    }
    else
    {
      v26 = v21;
      v27 = 0;
    }
    v28 = strchr(v26, 45);
    if ( v28 )
    {
      v56 = v26;
      v29 = sub_7D81C(0, (const char **)&v56, v28, 31536000);
      v30 = strchr(++v56, 45);
      if ( v30 )
      {
        v31 = sub_7D81C(v29, (const char **)&v56, v30, 2592000);
        ++v56;
        v32 = &v56[strlen(v56)];
        p_endptr = (const char **)&v56;
        v34 = v31;
LABEL_40:
        v7 = sub_7D81C(v34, p_endptr, v32, (int)&off_15180);
LABEL_41:
        if ( *v23 )
          v27 = 0;
        if ( v27 )
        {
          v42 = sub_7D90C(v25);
          v7 = sub_7D768(v7, v42, 1);
        }
        goto LABEL_45;
      }
    }
    else if ( strpbrk(v26, "YMWD") )
    {
      endptr = v26;
      v35 = strchr(v26, 89);
      if ( v35 )
      {
        v7 = sub_7D81C(0, (const char **)&endptr, v35, 31536000);
        v26 = ++endptr;
      }
      else
      {
        v7 = 0;
      }
      v36 = strchr(v26, 77);
      if ( v36 )
      {
        v7 = sub_7D81C(v7, (const char **)&endptr, v36, 2592000);
        v26 = ++endptr;
      }
      v37 = strchr(v26, 87);
      if ( v37 )
      {
        v7 = sub_7D81C(v7, (const char **)&endptr, v37, (int)"ound.");
        v26 = ++endptr;
      }
      v38 = strchr(v26, 68);
      if ( v38 )
      {
        v7 = sub_7D81C(v7, (const char **)&endptr, v38, (int)&off_15180);
        v26 = ++endptr;
      }
      v39 = (unsigned __int8)*v26;
      for ( i = *v2; (i[v39] & 0x2000) != 0; v39 = (unsigned __int8)*v26 )
        endptr = ++v26;
      if ( !v39 )
        goto LABEL_41;
    }
    else if ( strlen(v26) == 8 )
    {
      v58 = *(_DWORD *)v26;
      v59[0] = 0;
      endptr = (char *)&v58;
      v43 = sub_7D81C(0, (const char **)&endptr, v59, 31536000);
      LOWORD(v58) = *((_WORD *)v26 + 2);
      endptr = (char *)&v58;
      BYTE2(v58) = 0;
      v34 = sub_7D81C(v43, (const char **)&endptr, (const char *)&v58 + 2, 2592000);
      v44 = *((_WORD *)v26 + 3);
      v32 = (char *)&v58 + 2;
      p_endptr = (const char **)&endptr;
      endptr = (char *)&v58;
      LOWORD(v58) = v44;
      BYTE2(v58) = 0;
      goto LABEL_40;
    }
    v7 = -1;
    *v23 = 22;
LABEL_45:
    free(v21);
    return v7;
  }
  if ( v4 == 84 )
    return sub_7D90C(v5 + 1);
  v8 = _errno_location();
  v9 = v8;
  if ( (v6 & 0x800) == 0 )
  {
    v7 = -1;
    *v8 = 22;
    return v7;
  }
  v10 = v6 & 0x2000;
  while ( 1 )
  {
    *v9 = 0;
    v11 = strtol(v5, &endptr, 10);
    v12 = endptr;
    if ( *v9 )
      goto LABEL_23;
    v13 = (unsigned __int8)*endptr;
    if ( v13 == 58 )
      break;
    if ( ((*v2)[v13] & 0x2000) != 0 )
    {
      do
      {
        v14 = (unsigned __int8)*++v12;
        v13 = v14;
      }
      while ( ((*v2)[v14] & 0x2000) != 0 );
    }
    if ( v13 == 89 )
      goto LABEL_49;
    if ( v13 <= 0x59 )
    {
      if ( v13 == 68 )
        goto LABEL_71;
      if ( v13 <= 0x44 )
      {
        v41 = v11;
        if ( !v13 )
          return sub_7D768(v7, v41, 1);
LABEL_23:
        v7 = -1;
        *v9 = 22;
        return v7;
      }
      if ( v13 == 77 )
      {
        if ( v10 > 1 )
          goto LABEL_23;
        v15 = 2592000;
        v10 = 2;
      }
      else
      {
        if ( v13 != 87 || v10 > 2 )
          goto LABEL_23;
        v15 = (int)"ound.";
        v10 = 3;
      }
    }
    else
    {
      if ( v13 == 109 )
      {
        if ( v10 == 6 )
          goto LABEL_23;
        v15 = 60;
        v10 = 6;
        goto LABEL_19;
      }
      if ( v13 <= 0x6D )
      {
        if ( v13 != 100 )
        {
          if ( v13 != 104 || v10 > 4 )
            goto LABEL_23;
          v15 = 3600;
          v10 = 5;
          goto LABEL_19;
        }
LABEL_71:
        if ( v10 > 3 )
          goto LABEL_23;
        v15 = (int)&off_15180;
        v10 = 4;
        goto LABEL_19;
      }
      if ( v13 != 115 )
      {
        if ( v13 != 121 )
          goto LABEL_23;
LABEL_49:
        if ( v10 )
          goto LABEL_23;
        v15 = 31536000;
        v10 = 1;
        goto LABEL_19;
      }
      v15 = 1;
      v10 = 7;
    }
LABEL_19:
    v16 = sub_7D768(v7, v11, v15);
    v17 = (unsigned __int8)v12[1];
    v7 = v16;
    v5 = v12 + 1;
    for ( j = (*v2)[v17]; (j & 0x2000) != 0; j = (*v2)[v19] )
    {
      v19 = *(unsigned __int8 *)++v5;
      v17 = v19;
    }
    if ( !v17 )
      return v7;
    if ( ((v10 != 7) & (j >> 11)) == 0 )
      goto LABEL_23;
  }
  if ( v10 == 6 )
    goto LABEL_23;
  v45 = v9;
  v46 = 3;
  v47 = (unsigned __int8)*endptr;
  v48 = v11;
  v49 = v45;
  while ( --v46 )
  {
    v50 = strtoul(v12 + 1, &endptr, 10);
    v12 = endptr;
    if ( *v49 || (v51 = sub_7D768(v50, v48, 60), v48 = v51, *v49) )
    {
      v41 = -1;
      return sub_7D768(v7, v41, 1);
    }
    if ( *v12 != 58 )
    {
      v9 = v49;
      v41 = v51;
      v52 = (unsigned __int8)*v12;
      goto LABEL_82;
    }
  }
  v55 = v49;
  v41 = v48;
  v52 = v47;
  v9 = v55;
LABEL_82:
  if ( ((*v2)[v52] & 0x2000) != 0 )
  {
    do
    {
      v53 = (unsigned __int8)*++v12;
      v52 = v53;
    }
    while ( ((*v2)[v53] & 0x2000) != 0 );
  }
  if ( v52 )
  {
    v41 = -1;
    *v9 = 22;
    return sub_7D768(v7, v41, 1);
  }
  v54 = v41 == 3600;
  if ( v41 >= 3600 )
    v54 = v10 == 5;
  if ( v54 )
    goto LABEL_23;
  return sub_7D768(v7, v41, 1);
}
// 15180: using guessed type char *off_15180;

//----- (0008121C) --------------------------------------------------------
int __fastcall sub_8121C(const char *a1, int a2)
{
  int v3; // r2
  unsigned int v4; // r4
  const char *v5; // r8
  int result; // r0

  if ( (unsigned int)(a2 - 3) > 0xB )
    return 0;
  v3 = *(unsigned __int8 *)a1;
  v4 = *((unsigned __int8 *)&dword_9F184[199] + v3) + a2;
  if ( v4 > 0x11 )
    return 0;
  v5 = (const char *)*(&off_B5208 + 2 * v4);
  if ( *(unsigned __int8 *)v5 != v3 )
    return 0;
  result = strncmp(a1 + 1, v5 + 1, a2 - 1);
  if ( result )
    return 0;
  if ( !v5[a2] )
    return (int)*(&off_B5208 + 2 * v4 + 1);
  return result;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B5208: using guessed type _UNKNOWN *off_B5208;

//----- (000812E0) --------------------------------------------------------
int __fastcall sub_812E0(const char *a1, int a2)
{
  int v3; // r2
  unsigned int v4; // r3
  _UNKNOWN **v5; // r5
  const char *v6; // r7
  int result; // r0

  if ( (unsigned int)(a2 - 4) > 4 )
    return 0;
  v3 = *(unsigned __int8 *)a1;
  v4 = *((unsigned __int8 *)&dword_9F184[263] + v3) + a2;
  if ( v4 > 9 )
    return 0;
  v5 = &off_B5208 + 2 * v4;
  v6 = (const char *)v5[36];
  if ( *(unsigned __int8 *)v6 != v3 )
    return 0;
  result = strncmp(a1 + 1, v6 + 1, a2 - 1);
  if ( result )
    return 0;
  if ( !v6[a2] )
    return (int)v5[37];
  return result;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B5208: using guessed type _UNKNOWN *off_B5208;

//----- (000813A4) --------------------------------------------------------
const char *__fastcall sub_813A4(const char *a1, _DWORD *a2, _DWORD *a3)
{
  char *v6; // r0
  int v7; // r3
  const char *v8; // r4
  int v9; // r1
  int v10; // t1
  char *v11; // r0
  int v12; // r3
  int v13; // t1
  char *v14; // r0
  int v15; // r3
  int v16; // t1
  unsigned int v18; // r3
  char *v19; // r0
  unsigned int v20; // r3
  unsigned int v21; // t1
  const char *v22; // r5
  char *v23; // r0
  int v24; // r3
  int v25; // t1
  char *v26; // r0
  int v27; // r3
  int v28; // t1
  unsigned int v29; // r3
  unsigned int v30; // r3
  char *v31; // r0
  const char *v32; // r3
  int v33; // t1
  int v34; // r1
  unsigned int v35; // r3

  while ( 2 )
  {
    v6 = (char *)dword_107358;
    if ( !dword_107358 )
      v6 = sub_7E2F8(21);
    v7 = *(unsigned __int8 *)a1;
    v8 = a1;
    v9 = (unsigned __int8)v6[v7];
    if ( v6[v7] )
    {
      do
        v10 = *(unsigned __int8 *)++v8;
      while ( v6[v10] );
      v9 = v8 - a1;
    }
    switch ( sub_812E0(a1, v9) )
    {
      case 1:
        v22 = v8 + 1;
        if ( *v8 == 61 )
        {
          v31 = (char *)dword_107370;
          if ( !dword_107370 )
            v31 = sub_7E2F8(27);
          if ( v31[*((unsigned __int8 *)v8 + 1)] )
          {
            v32 = v8 + 1;
            do
              v33 = *(unsigned __int8 *)++v32;
            while ( v31[v33] );
            v34 = v32 - v22;
            if ( v32 != v22 )
            {
              v35 = *(unsigned __int8 *)v32;
              v8 = &v22[v34];
              if ( v35 <= 0x7F && (dword_9F184[v35] & 0x1000C01) != 0 )
              {
                switch ( sub_8121C(v22, v34) )
                {
                  case 1:
                    *a3 = 1;
                    goto LABEL_25;
                  case 2:
                    *a3 = 5;
                    goto LABEL_25;
                  case 3:
                  case 4:
                    *a3 = 3;
                    goto LABEL_25;
                  case 5:
                    *a3 = 2;
                    goto LABEL_25;
                  case 6:
                  case 7:
                    *a3 = 4;
                    goto LABEL_25;
                  case 8:
                  case 9:
                    *a3 = 6;
                    goto LABEL_25;
                  default:
                    break;
                }
              }
              v22 = v8;
            }
          }
        }
        *a3 = 0;
        v23 = (char *)dword_107388;
        if ( !dword_107388 )
          v23 = sub_7E2F8(33);
        v24 = *(unsigned __int8 *)v22;
        if ( !*v22 )
          return 0;
        while ( !v23[v24] )
        {
          v25 = *(unsigned __int8 *)++v22;
          v24 = v25;
          if ( !v25 )
            return 0;
        }
        v8 = v22;
        goto LABEL_25;
      case 2:
        v26 = (char *)dword_107388;
        if ( !dword_107388 )
          v26 = sub_7E2F8(33);
        v27 = *(unsigned __int8 *)v8;
        if ( !*v8 )
          return 0;
        while ( !v26[v27] )
        {
          v28 = *(unsigned __int8 *)++v8;
          v27 = v28;
          if ( !v28 )
            return 0;
        }
        goto LABEL_25;
      case 3:
        v14 = (char *)dword_107388;
        if ( !dword_107388 )
          v14 = sub_7E2F8(33);
        v15 = *(unsigned __int8 *)v8;
        if ( !*v8 )
          return 0;
        while ( !v14[v15] )
        {
          v16 = *(unsigned __int8 *)++v8;
          v15 = v16;
          if ( !v16 )
            return 0;
        }
        goto LABEL_25;
      case 4:
        v29 = *(unsigned __int8 *)v8;
        if ( v29 > 0x7F || (dword_9F184[v29] & 0x1000C01) == 0 )
          goto LABEL_7;
        *a2 = 0;
        goto LABEL_25;
      case 5:
        v30 = *(unsigned __int8 *)v8;
        if ( v30 > 0x7F || (dword_9F184[v30] & 0x1000C01) == 0 )
          goto LABEL_7;
        *a2 = 1;
        goto LABEL_25;
      case 6:
        v18 = *(unsigned __int8 *)v8;
        if ( v18 <= 0x7F && (dword_9F184[v18] & 0x1000C01) != 0 )
        {
          *a2 = 2;
LABEL_25:
          v19 = (char *)dword_107334;
          if ( !dword_107334 )
            v19 = sub_7E2F8(12);
          v20 = *(unsigned __int8 *)v8;
          if ( v19[v20] )
          {
            do
            {
              v21 = *(unsigned __int8 *)++v8;
              v20 = v21;
            }
            while ( v19[v21] );
          }
          if ( v20 == 47 )
          {
            *a3 = 0;
            return v8;
          }
          if ( v20 == 62 )
            return v8;
          if ( v20 > 0x7F )
            return 0;
          a1 = v8;
          if ( (dword_9F184[v20] & 0x80000) == 0 )
            return 0;
          continue;
        }
LABEL_7:
        a1 = v8;
LABEL_8:
        *a3 = 0;
        v11 = (char *)dword_107388;
        if ( !dword_107388 )
          v11 = sub_7E2F8(33);
        v12 = *(unsigned __int8 *)a1;
        if ( !*a1 )
          return 0;
        while ( !v11[v12] )
        {
          v13 = *(unsigned __int8 *)++a1;
          v12 = v13;
          if ( !v13 )
            return 0;
        }
        return a1;
      default:
        goto LABEL_8;
    }
  }
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// 107334: using guessed type int dword_107334;
// 107358: using guessed type int dword_107358;
// 107370: using guessed type int dword_107370;
// 107388: using guessed type int dword_107388;

//----- (000817F8) --------------------------------------------------------
int __fastcall sub_817F8(_DWORD *a1, int a2, unsigned int a3)
{
  bool v3; // cc
  int v4; // r2
  int v5; // r6
  int v6; // r12
  int v7; // r4
  void (__fastcall *v8)(_DWORD *, int); // r6
  int v9; // r3
  unsigned int v11; // r12
  unsigned int v12; // r3

  if ( (unsigned int)a1 <= 0xF )
    return 0;
  v3 = a1[25] > a3;
  v4 = a1[17] + (a3 << 6);
  if ( !v3 )
  {
    fputs(off_B8498[0], stderr);
    sub_7CE5C(1);
  }
  v5 = *(_DWORD *)(a2 + 24);
  v6 = *(_DWORD *)(v4 + 16) & 0xFFFFF00;
  *(_DWORD *)(v4 + 16) = v6;
  v7 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v4 + 24) = v5;
  *(_DWORD *)(v4 + 16) = v7 & 0xF00000FF | v6;
  if ( !(v7 & 4 | v6 & 4)
    || (v11 = *(unsigned __int16 *)(v4 + 12),
        v12 = (unsigned __int16)(*(_WORD *)(v4 + 14) + 1),
        *(_WORD *)(v4 + 14) = v12,
        v11 >= v12) )
  {
    v8 = *(void (__fastcall **)(_DWORD *, int))(v4 + 40);
    v9 = *(_DWORD *)(a2 + 16);
    *(_WORD *)(a2 + 14) = 0;
    *(_DWORD *)(a2 + 16) = v9 & 0xFFFFF00;
    if ( v8 )
    {
      v8(a1, v4);
      return 0;
    }
    return 0;
  }
  if ( (a1[3] & 4) != 0 )
    sub_7DB8C((int)a1, v4);
  return -1;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8498: using guessed type char *off_B8498[91];

//----- (00081938) --------------------------------------------------------
void __fastcall sub_81938(unsigned int a1, int a2)
{
  bool v2; // cc
  int v3; // r3
  const char *v5; // r0
  unsigned int v6; // r1
  int v7; // r6
  char *v8; // [sp+0h] [bp-8h] BYREF

  v2 = a2 != 0;
  if ( a2 )
    v2 = a1 > 0xF;
  if ( v2 )
  {
    v3 = *(_DWORD *)(a2 + 16);
    if ( (v3 & 8) == 0 )
    {
      v5 = *(const char **)(a2 + 24);
      if ( v5 )
      {
        v6 = *(unsigned __int8 *)v5;
        if ( v6 == 70 )
          goto LABEL_19;
        if ( v6 > 0x46 )
        {
          if ( v6 == 102 || v6 == 110 || v6 == 78 )
            goto LABEL_19;
        }
        else
        {
          if ( v6 == 35 )
          {
            v7 = *((unsigned __int8 *)v5 + 1) != 102;
            goto LABEL_15;
          }
          if ( v6 == 48 )
          {
            if ( !strtol(v5, &v8, 0) )
            {
              v3 = *(_DWORD *)(a2 + 16);
              v7 = (unsigned __int8)*v8;
              if ( *v8 )
                v7 = 1;
              goto LABEL_15;
            }
            v3 = *(_DWORD *)(a2 + 16);
            goto LABEL_14;
          }
          if ( !*v5 )
          {
LABEL_19:
            v7 = 0;
            goto LABEL_15;
          }
        }
LABEL_14:
        v7 = 1;
LABEL_15:
        if ( (v3 & 0x40) != 0 )
        {
          free(*(void **)(a2 + 24));
          *(_DWORD *)(a2 + 16) &= ~0x40u;
        }
        *(_DWORD *)(a2 + 24) = v7;
      }
    }
  }
}

//----- (00081A54) --------------------------------------------------------
int __fastcall sub_81A54(int a1, int a2)
{
  int *v2; // r3
  int i; // r2
  int *v4; // r3
  int v5; // t1
  int v6; // t1
  int *v8; // r0
  int *v9; // r0
  int v10; // r3
  int *v11; // r0
  int v12; // [sp+4h] [bp-Ch]

  if ( a1 && (unsigned __int16)*(_DWORD *)(a1 + 16) >> 12 == 6 )
  {
    v2 = *(int **)(a1 + 28);
    if ( v2 )
    {
      v5 = *v2;
      v4 = v2 + 2;
      for ( i = v5; ; --i )
      {
        if ( i - 1 < 0 )
          goto LABEL_13;
        v6 = *v4++;
        if ( v6 == a2 )
          break;
      }
      if ( i == 1 || (v10 = *v4) == 0 )
      {
LABEL_13:
        v11 = _errno_location();
        v10 = 0;
        *v11 = 2;
      }
    }
    else
    {
      v12 = *(_DWORD *)(a1 + 28);
      v9 = _errno_location();
      v10 = v12;
      *v9 = 2;
    }
  }
  else
  {
    v8 = _errno_location();
    v10 = 0;
    *v8 = 22;
  }
  return v10;
}

//----- (00081B34) --------------------------------------------------------
int __fastcall sub_81B34(_DWORD *a1, char *s2)
{
  int *v2; // r5
  int v3; // r4
  int v4; // r6
  _DWORD *v6; // r5
  int v8; // t1

  if ( !a1 || *a1 != 6 )
  {
    v4 = 0;
    *_errno_location() = 22;
    return v4;
  }
  v2 = (int *)a1[2];
  v3 = *v2;
  if ( *v2 <= 0 )
    goto LABEL_12;
  v4 = v2[2];
  if ( !s2 )
  {
    if ( v4 )
      return v4;
LABEL_12:
    v4 = 0;
    *_errno_location() = 2;
    return v4;
  }
  v6 = v2 + 2;
  while ( strcmp(*(const char **)(v4 + 4), s2) )
  {
    if ( !--v3 )
      goto LABEL_12;
    v8 = v6[1];
    ++v6;
    v4 = v8;
  }
  return v4;
}

//----- (00081C08) --------------------------------------------------------
_DWORD *__fastcall sub_81C08(int a1, char *s2, int a3)
{
  _DWORD *v3; // r5
  int v4; // r4
  _DWORD **v7; // r5
  _DWORD *v8; // r9
  _DWORD *v9; // t1
  _BOOL4 v10; // r0

  if ( a1 && (unsigned __int16)*(_DWORD *)(a1 + 16) >> 12 == 6 )
  {
    v3 = *(_DWORD **)(a1 + 28);
    if ( v3 )
    {
      v4 = *v3;
      if ( *v3 )
      {
        if ( !s2 )
          return (_DWORD *)v3[2];
        v7 = (_DWORD **)(v3 + 2);
        while ( --v4 >= 0 )
        {
          v9 = *v7++;
          v8 = v9;
          v10 = sub_81B34(v9, s2) != 0;
          if ( a3 )
            v10 = 0;
          if ( v10 )
          {
            if ( v8 )
              return v8;
            break;
          }
        }
      }
    }
    v8 = 0;
    *_errno_location() = 2;
  }
  else
  {
    v8 = 0;
    *_errno_location() = 22;
  }
  return v8;
}

//----- (00081D14) --------------------------------------------------------
int __fastcall sub_81D14(_DWORD *a1, int a2)
{
  int *v2; // r0
  _DWORD *v3; // r0
  int v4; // r2
  int v5; // t1
  int v6; // r5
  int *v7; // r0
  int v8; // r3
  int *v10; // r0

  if ( !a1 || *a1 != 6 )
  {
    v10 = _errno_location();
    v8 = 0;
    *v10 = 22;
    return v8;
  }
  v2 = (int *)a1[2];
  v5 = *v2;
  v3 = v2 + 2;
  v4 = v5;
  while ( 1 )
  {
    if ( v4-- <= 0 )
    {
      v6 = 22;
LABEL_8:
      v7 = _errno_location();
      v8 = 0;
      *v7 = v6;
      return v8;
    }
    if ( *v3 == a2 )
      break;
    ++v3;
  }
  if ( !v4 )
  {
    v6 = 2;
    goto LABEL_8;
  }
  return v3[1];
}

//----- (00081DDC) --------------------------------------------------------
int __fastcall sub_81DDC(char *a1, _BYTE *a2, char a3)
{
  int v4; // r1
  int v5; // r3
  int v6; // r6
  unsigned int v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // r1
  int v13; // r3
  unsigned __int8 v14; // [sp+0h] [bp-8h] BYREF
  char v15; // [sp+1h] [bp-7h]
  char v16; // [sp+2h] [bp-6h]
  int v17; // [sp+4h] [bp-4h]

  v4 = (unsigned __int8)*a1;
  v5 = _stack_chk_guard;
  *a2 = v4;
  v17 = v5;
  switch ( v4 )
  {
    case 0:
      return 0;
    case 10:
      v6 = 1;
      goto LABEL_3;
    case 13:
      if ( a1[1] != 10 )
        goto LABEL_7;
      v6 = 2;
LABEL_3:
      *a2 = a3;
      break;
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
      v8 = (unsigned __int8)a1[1];
      v14 = *a1;
      if ( v8 <= 0x7F && (dword_9F184[v8] & 0x10000) != 0 )
      {
        v9 = (unsigned __int8)a1[2];
        v15 = v8;
        if ( v9 <= 0x7F && (dword_9F184[v9] & 0x10000) != 0 )
        {
          v6 = 3;
          v16 = v9;
        }
        else
        {
          v6 = 2;
        }
      }
      else
      {
        v6 = 1;
      }
      *(&v14 + v6) = 0;
      v10 = strtoul((const char *)&v14, 0, 8);
      if ( v10 >= 0xFF )
        LOBYTE(v10) = -1;
      *a2 = v10;
      return v6;
    case 88:
    case 120:
      v11 = (unsigned __int8)a1[1];
      if ( v11 > 0x7F || (dword_9F184[v11] & 0x70000) == 0 )
        goto LABEL_7;
      v12 = (unsigned __int8)a1[2];
      v14 = a1[1];
      if ( v12 <= 0x7F && (dword_9F184[v12] & 0x70000) != 0 )
      {
        v15 = v12;
        v6 = 3;
        v13 = 2;
      }
      else
      {
        v6 = 2;
        v13 = 1;
      }
      *(&v14 + v13) = 0;
      *a2 = strtoul((const char *)&v14, 0, 16);
      break;
    case 97:
      v6 = 1;
      *a2 = 7;
      return v6;
    case 98:
      v6 = 1;
      *a2 = 8;
      return v6;
    case 102:
      v6 = 1;
      *a2 = 12;
      return v6;
    case 110:
      v6 = 1;
      *a2 = 10;
      return v6;
    case 114:
      v6 = 1;
      *a2 = 13;
      return v6;
    case 116:
      v6 = 1;
      *a2 = 9;
      return v6;
    case 118:
      v6 = 1;
      *a2 = 11;
      return v6;
    default:
LABEL_7:
      v6 = 1;
      break;
  }
  return v6;
}
// 9F184: using guessed type _DWORD dword_9F184[1];

//----- (000821C8) --------------------------------------------------------
char *__fastcall sub_821C8(unsigned __int8 *a1, int *a2)
{
  _BYTE *v2; // r11
  int *v3; // r7
  char *v4; // r2
  unsigned int v5; // r5
  int i; // r3
  char *v7; // r4
  int v8; // r3
  int v10; // r0
  char *v11; // r0
  char *j; // r4
  int v13; // t1
  int v14; // [sp+0h] [bp-Ch] BYREF

  v2 = a1;
  v3 = a2;
  v4 = (char *)(a1 + 1);
  v5 = *a1;
  v14 = 0;
  if ( !a2 )
    v3 = &v14;
  for ( i = a1[1]; ; i = (unsigned __int8)v7[v10] )
  {
    while ( 1 )
    {
      while ( 1 )
      {
LABEL_4:
        while ( 1 )
        {
          v7 = v4 + 1;
          if ( i != v5 )
            break;
LABEL_9:
          *v2 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              v5 = (unsigned __int8)*v7;
              if ( v5 > 0x7F || (dword_9F184[v5] & 0xC01) == 0 )
                break;
              ++v7;
              if ( v5 == 10 )
                ++*v3;
            }
            if ( v5 == 39 )
              break;
            if ( v5 != 47 )
            {
              if ( v5 != 34 )
                return v7;
              break;
            }
            v8 = (unsigned __int8)v7[1];
            if ( v8 == 42 )
            {
              v11 = strstr(v7 + 2, "*/");
              if ( !v11 )
                return 0;
              if ( v7 < v11 )
              {
                for ( j = v7 + 1; v11 != j; ++j )
                {
                  v13 = (unsigned __int8)*j;
                  if ( v13 == 10 )
                    ++*v3;
                }
              }
              v7 = v11 + 2;
            }
            else
            {
              if ( v8 != 47 )
                return 0;
              v7 = strchr(v7, 10);
              if ( !v7 )
                return 0;
            }
          }
          v4 = v7 + 1;
          i = (unsigned __int8)v7[1];
        }
        while ( 1 )
        {
          *v2 = i;
          if ( i == 10 )
          {
            ++v2;
            ++*v3;
            i = (unsigned __int8)v4[1];
            v4 = v7;
            goto LABEL_4;
          }
          if ( i == 92 )
            break;
          if ( !i )
            return 0;
          i = (unsigned __int8)v4[1];
          v4 = v7;
          ++v2;
          ++v7;
          if ( i == v5 )
            goto LABEL_9;
        }
        i = (unsigned __int8)v4[1];
        if ( i != 10 )
          break;
        v4 += 2;
        ++*v3;
        i = (unsigned __int8)*v4;
      }
      if ( v5 != 39 )
        break;
      if ( i == 39 || i == 92 || i == 35 )
      {
        *v2 = i;
        v4 += 2;
        i = (unsigned __int8)*v4;
        ++v2;
      }
      else
      {
        v4 = v7;
        ++v2;
      }
    }
    v10 = sub_81DDC(v7, v2, 10);
    if ( !v10 )
      break;
    ++v2;
    v4 = &v7[v10];
  }
  return 0;
}
// 9F184: using guessed type _DWORD dword_9F184[1];

//----- (00082410) --------------------------------------------------------
int **__fastcall sub_82410(char *a1, const void *a2, size_t a3)
{
  char *v3; // r4
  char *v6; // r0
  int **v7; // r5
  int **v8; // t1
  int **v9; // r0
  int *v10; // r0
  char *v11; // r0
  unsigned int v12; // r3
  unsigned int v13; // t1
  int *v14; // r9
  void *v15; // r0
  int *v17; // r6
  int v18; // r8
  int v19; // r7
  int *v20; // r10
  int v21; // r4
  int v22; // r5
  int v23; // t1
  const char *v24; // r11
  int v25; // t1
  unsigned int v26; // r3
  char *v27; // r8
  const char *v28; // r9
  char *v29; // r0
  int v30; // t1
  unsigned int v31; // r3
  unsigned int v32; // r2
  int v33; // r1
  const char *v34; // r7
  char *v35; // r0
  int v36; // t1
  char *v37; // r2
  char *v38; // r4
  char *v39; // r3
  char v40; // t1
  char *v41; // r0
  char *v42; // r3
  int v43; // r10
  char *v44; // r9
  char *v45; // r2
  int v46; // t1
  size_t v47; // r9
  int v48; // r2
  int v49; // t1
  char *v50; // r0
  char *v51; // r7
  char *v52; // r0
  int v53; // t1
  size_t v54; // r10
  char *v55; // r0
  int v56; // r3
  int v57; // t1
  char *v58; // r0
  char *v59; // r1
  char *v60; // r9
  int v61; // r2
  char *v62; // r8
  int v63; // r0
  char *v64; // r0
  unsigned __int8 *v65; // r8
  int v66; // t1
  bool v67; // zf
  int v68; // r0
  char *v69; // r0
  int v70; // t1
  char *v71; // r2
  char *v72; // r0
  char *v73; // r1
  int v74; // r3
  int v75; // t1
  int v76; // t1
  _BYTE *v77; // r0
  _BYTE *v78; // r10
  int v79; // r3
  _DWORD *v80; // r0
  int v81; // r7
  _DWORD *v82; // r10
  int v83; // r2
  unsigned int v84; // r3
  unsigned int v85; // t1
  _BOOL4 v86; // r3
  int v87; // r2
  int v88; // r0
  int v89; // r9
  unsigned int v90; // r0
  unsigned int v91; // r8
  char *v92; // r10
  _BYTE *v93; // r7
  size_t v94; // r0
  _BYTE *v95; // r2
  int v96; // t1
  int v97; // r3
  int v98; // r3
  _DWORD *v99; // r0
  unsigned int v100; // r1
  unsigned int v101; // r3
  unsigned int v102; // t1
  int v103; // r2
  unsigned __int8 *v104; // r1
  bool v105; // zf
  int v106; // r2
  char *v107; // r1
  char *v108; // r0
  int v109; // t1
  const char *v110; // r0
  char *v111; // r0
  int v112; // r3
  const char *v113; // r7
  int v114; // t1
  size_t v115; // r0
  const char *v116; // r1
  int v117; // [sp+Ch] [bp-78h]
  int **v118; // [sp+10h] [bp-74h]
  size_t n; // [sp+14h] [bp-70h]
  size_t na; // [sp+14h] [bp-70h]
  int v121; // [sp+18h] [bp-6Ch]
  int **v122; // [sp+1Ch] [bp-68h]
  char *v123; // [sp+1Ch] [bp-68h]
  char *v124; // [sp+20h] [bp-64h]
  char *v125; // [sp+20h] [bp-64h]
  int v126[3]; // [sp+28h] [bp-5Ch] BYREF
  char needle[4]; // [sp+34h] [bp-50h] BYREF
  _BYTE s[76]; // [sp+38h] [bp-4Ch] BYREF

  v3 = a1;
  if ( !a1 )
  {
    v7 = 0;
    *_errno_location() = 22;
    return v7;
  }
  v6 = (char *)dword_107334;
  if ( !dword_107334 )
    v6 = sub_7E2F8(12);
  v7 = (int **)(unsigned __int8)*v3;
  if ( *((_BYTE *)v7 + (_DWORD)v6) )
  {
    do
    {
      v8 = (int **)(unsigned __int8)*++v3;
      v7 = v8;
    }
    while ( *((_BYTE *)v8 + (_DWORD)v6) );
  }
  if ( !v7 )
  {
    *_errno_location() = 42;
    return v7;
  }
  v9 = (int **)malloc(a3 + 13);
  v7 = v9;
  if ( !v9 )
    sub_C610(a3 + 13);
  *v9 = (_DWORD *)&byte_6;
  v9[1] = (int *)(v9 + 3);
  *((_BYTE *)memcpy(v9 + 3, a2, a3) + a3) = 0;
  v10 = (int *)malloc(0x20u);
  if ( !v10 )
    sub_C610(32);
  v7[2] = v10;
  *v10 = 0;
  v10[1] = 6;
LABEL_10:
  v11 = (char *)dword_107334;
  if ( !dword_107334 )
    goto LABEL_76;
  while ( 1 )
  {
    v12 = (unsigned __int8)*v3;
    if ( v11[v12] )
    {
      do
      {
        v13 = (unsigned __int8)*++v3;
        v12 = v13;
      }
      while ( v11[v13] );
    }
    if ( v12 <= 0x7F && (dword_9F184[v12] & 0x180040) != 0 )
    {
      v51 = v3 + 1;
      v52 = (char *)dword_107374;
      if ( !dword_107374 )
        v52 = sub_7E2F8(28);
      if ( v52[(unsigned __int8)v3[1]] )
      {
        do
          v53 = (unsigned __int8)*++v51;
        while ( v52[v53] );
      }
      if ( *(v51 - 1) == 58 )
        --v51;
      v54 = v51 - v3;
      v55 = (char *)dword_10732C;
      if ( !dword_10732C )
        v55 = sub_7E2F8(10);
      v56 = (unsigned __int8)*v51;
      if ( v55[v56] )
      {
        do
        {
          v57 = (unsigned __int8)*++v51;
          v56 = v57;
        }
        while ( v55[v57] );
      }
      while ( 2 )
      {
        switch ( v56 )
        {
          case 0:
            goto LABEL_91;
          case 10:
          case 44:
            ++v51;
LABEL_91:
            v59 = v3;
            v3 = v51;
            sub_7E89C(v7 + 2, v59, v54, 0, 0);
            goto LABEL_22;
          case 34:
          case 39:
            v60 = v51 + 1;
            do
            {
              while ( 2 )
              {
                while ( 2 )
                {
                  v62 = v60 + 1;
                  v61 = (unsigned __int8)*v60;
                  if ( !*v60 )
                    goto LABEL_98;
                  if ( v61 == v56 )
                  {
                    v63 = sub_7E89C(v7 + 2, v3, v54, v51, v62 - v51);
                    if ( v63 && !dword_B8168[0] )
                    {
                      ++v60;
                      goto LABEL_101;
                    }
                    goto LABEL_187;
                  }
                  if ( v61 != 92 )
                  {
                    ++v60;
                    continue;
                  }
                  break;
                }
                v103 = (unsigned __int8)v60[1];
                v104 = (unsigned __int8 *)(v60 + 2);
                if ( !v60[1] )
                  goto LABEL_98;
                v105 = v103 == 92;
                if ( v103 != 92 )
                  v105 = v103 == v56;
                if ( !v105 )
                {
                  v60 += 2;
                  continue;
                }
                break;
              }
              v106 = (unsigned __int8)v60[2];
              v60 += 3;
            }
            while ( v106 );
            v60 = (char *)v104;
LABEL_98:
            v63 = sub_7E89C(v7 + 2, v3, v54, v51, v60 - v51);
            if ( v63 )
            {
              if ( dword_B8168[0] )
              {
                v3 = v60;
                goto LABEL_22;
              }
LABEL_101:
              v3 = v60;
              sub_821C8((unsigned __int8 *)(v63 + 8), 0);
              goto LABEL_22;
            }
            goto LABEL_203;
          case 58:
          case 61:
            v64 = (char *)dword_10732C;
            v65 = (unsigned __int8 *)(v51 + 1);
            if ( !dword_10732C )
              v64 = sub_7E2F8(10);
            v56 = (unsigned __int8)v51[1];
            if ( v64[v56] )
            {
              do
              {
                v66 = *++v65;
                v56 = v66;
              }
              while ( v64[v66] );
            }
            v67 = v56 == 58;
            if ( v56 != 58 )
              v67 = v56 == 61;
            v51 = (char *)v65;
            if ( !v67 )
              continue;
            goto LABEL_110;
          default:
LABEL_110:
            v60 = v51;
            while ( 2 )
            {
              v62 = v60 + 1;
              if ( v56 == 10 )
              {
                if ( v62 <= v51 + 2 )
                {
LABEL_201:
                  v107 = v3;
                  v3 = v60 + 1;
                  v68 = sub_7E89C(v7 + 2, v107, v54, v51, v60 - v51);
                  if ( !v68 )
                    goto LABEL_22;
                  break;
                }
                if ( *(v60 - 1) == 92 )
                {
                  v56 = (unsigned __int8)*v62;
                  if ( *v62 )
                    goto LABEL_115;
                }
                v68 = sub_7E89C(v7 + 2, v3, v54, v51, v60 - v51);
                if ( !v68 )
                {
LABEL_187:
                  v3 = v62;
                  goto LABEL_10;
                }
                v3 = v60 + 1;
              }
              else
              {
                if ( v56 == 44 )
                  goto LABEL_201;
                if ( v56 )
                {
                  v56 = (unsigned __int8)*v62;
LABEL_115:
                  ++v60;
                  continue;
                }
                v68 = sub_7E89C(v7 + 2, v3, v54, v51, v60 - v51);
                if ( !v68 )
                {
LABEL_203:
                  v3 = v60;
                  goto LABEL_10;
                }
                v3 = v60;
              }
              break;
            }
            v69 = (char *)(v68 + 8);
            while ( 1 )
            {
              if ( *v69 == 10 )
              {
                do
                  v70 = (unsigned __int8)*++v69;
                while ( v70 == 10 );
              }
              v69 = strchr(v69, 10);
              if ( !v69 )
                break;
              if ( *(v69 - 1) == 92 )
              {
                v71 = v69;
                v72 = v69 - 1;
                v73 = v71;
                while ( 1 )
                {
                  v75 = (unsigned __int8)*v71++;
                  v74 = v75;
                  *v72 = v75;
                  if ( !v75 )
                    goto LABEL_22;
                  while ( v74 != 92 || *v71 != 10 )
                  {
                    v76 = (unsigned __int8)*v71++;
                    v74 = v76;
                    v72 = v73++;
                    *v72 = v76;
                    if ( !v76 )
                      goto LABEL_22;
                  }
                }
              }
            }
LABEL_22:
            if ( !v3 )
              goto LABEL_23;
            break;
        }
        goto LABEL_10;
      }
    }
    if ( v12 == 35 )
    {
      v3 = strchr(v3, 10);
      goto LABEL_22;
    }
    if ( v12 != 60 )
      break;
    v26 = (unsigned __int8)v3[1];
    v27 = v3 + 1;
    if ( v26 > 0x7F || (dword_9F184[v26] & 0x180040) == 0 )
    {
      if ( v26 == 33 )
      {
        v58 = strstr(v3 + 1, "-->");
        if ( !v58 )
          goto LABEL_18;
        v3 = v58 + 3;
      }
      else
      {
        if ( v26 != 63 )
          goto LABEL_18;
        v50 = strchr(v3 + 1, 62);
        if ( !v50 )
          goto LABEL_18;
        v3 = v50 + 1;
      }
      if ( !v3 )
        goto LABEL_18;
      goto LABEL_73;
    }
    v28 = v3 + 2;
    v29 = (char *)dword_107374;
    v121 = dword_B8168[0];
    if ( !dword_107374 )
      v29 = sub_7E2F8(28);
    if ( v29[(unsigned __int8)v3[2]] )
    {
      do
        v30 = *(unsigned __int8 *)++v28;
      while ( v29[v30] );
    }
    n = v28 - v27;
    if ( (unsigned int)(v28 - v27) > 0x40 || (v126[0] = 1, v31 = *(unsigned __int8 *)v28, v32 = v31, v31 > 0x7F) )
    {
LABEL_118:
      v14 = v7[2];
      dword_B8168[0] = v121;
LABEL_19:
      free(v14);
      v15 = v7;
      v7 = 0;
      free(v15);
      return v7;
    }
    v33 = dword_9F184[v31];
    if ( (v33 & 0xC01) != 0 )
    {
      v108 = (char *)dword_107334;
      if ( !dword_107334 )
      {
        v108 = sub_7E2F8(12);
        v31 = *(unsigned __int8 *)v28;
      }
      if ( v108[v31] )
      {
        do
          v109 = *(unsigned __int8 *)++v28;
        while ( v108[v109] );
      }
      v110 = sub_813A4(v28, dword_B8168, v126);
      v28 = v110;
      if ( !v110 )
        goto LABEL_118;
      v32 = *(unsigned __int8 *)v110;
      if ( v32 > 0x7F )
        goto LABEL_118;
      v33 = dword_9F184[v32];
    }
    if ( (v33 & 0x1000C01) == 0 )
      goto LABEL_118;
    v34 = v28 + 1;
    if ( v32 == 47 )
    {
      if ( v28[1] != 62 )
        goto LABEL_118;
      v34 = v28 + 2;
      v126[0] = 0;
      if ( v28 == (const char *)-2 )
        goto LABEL_118;
    }
    else
    {
      if ( v28 == (const char *)-1 )
        goto LABEL_118;
      if ( v126[0] )
      {
        if ( dword_B8168[0] != 2 )
        {
          v35 = (char *)dword_107334;
          if ( !dword_107334 )
            v35 = sub_7E2F8(12);
          if ( v35[*((unsigned __int8 *)v28 + 1)] )
          {
            do
              v36 = *(unsigned __int8 *)++v34;
            while ( v35[v36] );
          }
        }
        *(_DWORD *)needle = 12092;
        memset(s, 0, 0x44u);
        v37 = &needle[1];
        v38 = &v3[n + 1];
        v39 = v27;
        do
        {
          v40 = *v39++;
          *++v37 = v40;
        }
        while ( v39 != v38 );
        *(_WORD *)&needle[n + 2] = 62;
        v41 = strstr(v34, needle);
        v42 = v41;
        if ( !v41 )
          goto LABEL_118;
        v43 = dword_107334;
        if ( dword_B8168[0] != 2 )
        {
          if ( dword_107334 )
          {
            v44 = (char *)dword_107334;
          }
          else
          {
            v125 = v41;
            v44 = sub_7E2F8(12);
            v42 = v125;
            v43 = dword_107334;
          }
          if ( v34 < v42 )
          {
            v41 = v42;
            goto LABEL_58;
          }
          v124 = v42;
          v41 = (char *)&v34[strlen(v34)];
          v42 = v124;
          if ( v34 < v41 )
          {
LABEL_58:
            if ( v44[(unsigned __int8)*(v41 - 1)] )
            {
              v45 = v41 - 1;
              do
              {
                v41 = v45;
                if ( v34 >= v45 )
                  break;
                v46 = (unsigned __int8)*--v45;
              }
              while ( v44[v46] );
            }
          }
        }
        v47 = v41 - v34;
        v48 = &s[n - 1] - needle;
        v3 = &v42[v48];
        if ( !v43 )
        {
          v123 = v42;
          v111 = sub_7E2F8(12);
          v42 = v123;
          v43 = (int)v111;
          v48 = &s[n - 1] - needle;
        }
        if ( *(_BYTE *)(v43 + (unsigned __int8)v42[v48]) )
        {
          do
            v49 = (unsigned __int8)*++v3;
          while ( *(_BYTE *)(v43 + v49) );
        }
        switch ( v126[0] )
        {
          case 0:
            v34 = v3;
            goto LABEL_206;
          case 1:
            v88 = sub_7E89C(v7 + 2, v27, n, v34, v47);
            v89 = v88;
            na = dword_B8168[0];
            if ( dword_B8168[0] != 2 )
            {
              v90 = *(unsigned __int8 *)(v88 + 8);
              v91 = v89 + 8;
              v92 = (char *)dword_107334;
              if ( v90 <= 0x7F && (dword_9F184[v90] & 0xC01) != 0 )
              {
                v113 = (const char *)(v89 + 9);
                if ( !dword_107334 )
                  v92 = sub_7E2F8(12);
                if ( v92[*(unsigned __int8 *)(v89 + 9)] )
                {
                  do
                    v114 = *(unsigned __int8 *)++v113;
                  while ( v92[v114] );
                }
                v92 = (char *)dword_107334;
                v115 = strlen(v113);
                v116 = v113;
                v93 = (_BYTE *)(v91 + v115);
                memmove((void *)(v89 + 8), v116, v115 + 1);
              }
              else
              {
                v93 = (_BYTE *)(v91 + strlen((const char *)(v89 + 8)));
              }
              if ( !v92 )
                v92 = sub_7E2F8(12);
              if ( v91 < (unsigned int)v93
                || (v94 = strlen((const char *)(v89 + 8)), v93 = (_BYTE *)(v91 + v94), v91 < v91 + v94) )
              {
                if ( v92[(unsigned __int8)*(v93 - 1)] )
                {
                  v95 = v93 - 1;
                  do
                  {
                    v93 = v95;
                    if ( v91 >= (unsigned int)v95 )
                      break;
                    v96 = (unsigned __int8)*--v95;
                  }
                  while ( v92[v96] );
                }
              }
              *v93 = 0;
              if ( na != 1 )
              {
                v97 = *(unsigned __int8 *)(v89 + 8);
                if ( v97 == 34 || v97 == 39 )
                {
                  v98 = (unsigned __int8)*(v93 - 1);
                  if ( v98 == 34 || v98 == 39 )
                    sub_821C8((unsigned __int8 *)(v89 + 8), 0);
                }
              }
            }
            goto LABEL_139;
          case 3:
            v122 = v7 + 2;
            v82 = malloc(n + 13);
            v83 = n + 13;
            if ( !v82 )
              goto LABEL_229;
            v84 = *(unsigned __int8 *)v34;
            if ( v84 > 0x7F )
              goto LABEL_148;
            if ( (dword_9F184[v84] & 0xC01) == 0 )
              goto LABEL_220;
            if ( !v47 )
              goto LABEL_219;
            while ( 2 )
            {
              v85 = *(unsigned __int8 *)++v34;
              v84 = v85;
              --v47;
              if ( v85 > 0x7F )
              {
LABEL_148:
                if ( v47 )
                {
                  v86 = 1;
LABEL_151:
                  v82[2] = v86;
                  goto LABEL_152;
                }
LABEL_219:
                v82[2] = 0;
                goto LABEL_152;
              }
              if ( (dword_9F184[v84] & 0xC01) != 0 )
              {
                if ( !v47 )
                  goto LABEL_219;
                continue;
              }
              break;
            }
LABEL_220:
            if ( !v47 )
              goto LABEL_219;
            v112 = dword_9F184[v84];
            if ( (v112 & 0x30000) == 0 )
            {
              v86 = (v112 & 0x8000002) == 0;
              goto LABEL_151;
            }
            v82[2] = strtol(v34, 0, 10);
LABEL_152:
            v87 = 3;
LABEL_183:
            *v82 = v87;
            v82[1] = v82 + 3;
            *((_BYTE *)memcpy(v82 + 3, v27, n) + n) = 0;
            sub_7E784(v122, (int)v82);
            break;
          case 5:
            v122 = v7 + 2;
            v99 = malloc(n + 13);
            v82 = v99;
            v83 = n + 13;
            if ( !v99 )
LABEL_229:
              sub_C610(v83);
            v100 = *(unsigned __int8 *)v34;
            if ( v100 > 0x7F || (dword_9F184[v100] & 0xC01) == 0 )
              goto LABEL_180;
            if ( !v47 )
              goto LABEL_215;
            while ( 1 )
            {
              v102 = *(unsigned __int8 *)++v34;
              v101 = v102;
              --v47;
              if ( v102 > 0x7F || (dword_9F184[v101] & 0xC01) == 0 )
                break;
              if ( !v47 )
                goto LABEL_215;
            }
LABEL_180:
            if ( v47 )
            {
              v99[2] = strtol(v34, 0, 0);
              goto LABEL_182;
            }
LABEL_215:
            v99[2] = 0;
LABEL_182:
            v87 = 5;
            goto LABEL_183;
          case 6:
            v77 = malloc(v47 + 1);
            v78 = v77;
            v79 = v47 + 1;
            if ( !v77 )
              goto LABEL_231;
            memcpy(v77, v34, v47);
            v78[v47] = 0;
            if ( !v47 )
            {
              v80 = malloc(n + 13);
              v81 = (int)v80;
              v79 = n + 13;
              if ( !v80 )
LABEL_231:
                sub_C610(v79);
              v80[2] = 0;
              *v80 = 6;
              v80[1] = v80 + 3;
              *((_BYTE *)memcpy(v80 + 3, v27, n) + n) = 0;
LABEL_137:
              sub_7E784(v7 + 2, v81);
              goto LABEL_138;
            }
            v81 = sub_82410(v78, v27, n);
            if ( v81 )
              goto LABEL_137;
LABEL_138:
            free(v78);
            goto LABEL_139;
          default:
            goto LABEL_139;
        }
        goto LABEL_139;
      }
    }
LABEL_206:
    v3 = (char *)v34;
    sub_7E89C(v7 + 2, v27, n, 0, 0);
LABEL_139:
    dword_B8168[0] = v121;
LABEL_73:
    if ( *v3 == 44 )
    {
      ++v3;
      goto LABEL_22;
    }
    v11 = (char *)dword_107334;
    if ( !dword_107334 )
LABEL_76:
      v11 = sub_7E2F8(12);
  }
  if ( v12 )
  {
LABEL_18:
    v14 = v7[2];
    goto LABEL_19;
  }
LABEL_23:
  v14 = v7[2];
  v117 = *v14;
  if ( !*v14 )
  {
    *_errno_location() = 42;
    goto LABEL_19;
  }
  if ( v117 > 1 )
  {
    v17 = v14 + 2;
    v18 = 1;
    v118 = v7;
    do
    {
      v19 = v17[1];
      v20 = v17 - 1;
      v21 = v18;
      v23 = *v17++;
      v22 = v23;
      v24 = *(const char **)(v19 + 4);
      do
      {
        if ( strcmp(*(const char **)(v22 + 4), v24) <= 0 )
          break;
        --v21;
        v20[2] = v22;
        v25 = *v20--;
        v22 = v25;
      }
      while ( v21 );
      ++v18;
      v14[v21 + 2] = v19;
    }
    while ( v117 != v18 );
    return v118;
  }
  return v7;
}
// 6: using guessed type char byte_6;
// 9F184: using guessed type _DWORD dword_9F184[1];
// B8168: using guessed type int dword_B8168[65];
// 10732C: using guessed type int dword_10732C;
// 107334: using guessed type int dword_107334;
// 107374: using guessed type int dword_107374;

//----- (00083400) --------------------------------------------------------
int __fastcall sub_83400(int a1, int a2)
{
  void *v4; // r0
  void (__fastcall *v5)(int, void *); // r3
  _DWORD s[16]; // [sp+4h] [bp-44h] BYREF

  v4 = memset(s, 0, sizeof(s));
  v5 = *(void (__fastcall **)(int, void *))(a1 + 40);
  s[6] = a2;
  v5(3, v4);
  return s[6];
}

//----- (00083478) --------------------------------------------------------
const char *__fastcall sub_83478(unsigned int a1, _DWORD *a2, const char **a3, unsigned int a4)
{
  unsigned int v6; // r4
  int v7; // r3
  unsigned int v9; // r3
  unsigned int v10; // r1

  switch ( a1 )
  {
    case 2u:
      v10 = a2[6];
      v6 = 0;
      if ( a4 > v10 )
        fputs(a3[v10], stdout);
      else
        printf("INVALID-%d", v10);
      break;
    case 3u:
      v9 = a2[6];
      if ( v9 < a4 )
      {
        v6 = 0;
        a2[6] = a3[v9];
      }
      else
      {
        return "*INVALID*";
      }
      break;
    case 1u:
      v6 = 0;
      sub_7C924(1u, a2, a3, a4);
      break;
    default:
      if ( (a2[4] & 8) != 0 )
      {
        return 0;
      }
      else
      {
        v6 = sub_7CC34((const char *)a2[6], a1, a2, a3, a4);
        if ( (a2[4] & 0x40) != 0 )
        {
          free((void *)a2[6]);
          v7 = a2[4];
          a2[6] = 0;
          a2[4] = v7 & 0xFFFFFFBF;
        }
      }
      break;
  }
  return (const char *)v6;
}
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;

//----- (000835B8) --------------------------------------------------------
int __fastcall sub_835B8(int a1)
{
  int v2; // r6
  int result; // r0

  v2 = *(_DWORD *)(a1 + 24);
  (*(void (__fastcall **)(int, int))(a1 + 40))(3, a1);
  result = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = v2;
  return result;
}

//----- (00083C64) --------------------------------------------------------
void __fastcall sub_83C64(unsigned int a1, _DWORD *a2, char a3, int a4)
{
  void *v8; // r0
  int *v9; // r0
  const char *v10; // r10
  int *v11; // r11
  int v12; // r0
  int v13; // r3
  char *v14; // r0
  int v15; // r2
  size_t v16; // r9
  _BYTE *v17; // r0
  __int16 v18; // r2
  int v19; // r7
  int v20; // r7
  int v21; // r3
  const char *v22; // r6
  __int16 v23; // r3
  char *v24; // r0
  void *ptr; // [sp+4h] [bp-78h]
  _BYTE *ptra; // [sp+4h] [bp-78h]
  _BYTE v27[16]; // [sp+8h] [bp-74h] BYREF
  int v28; // [sp+18h] [bp-64h]

  if ( a1 > 0xF )
  {
    if ( (a2[4] & 8) != 0 )
    {
      v8 = (void *)a2[7];
      if ( v8 )
        free(v8);
    }
    else
    {
      v9 = _errno_location();
      v10 = (const char *)a2[6];
      v11 = v9;
      *v9 = 0;
      if ( (a3 & 3) == 1 )
      {
        if ( _xstat64(3, v10, v27) || (v23 = v28, v15 = 22, *v11 = 22, (v23 & 0xF000) != 0x8000) )
          sub_7CF18(*(_DWORD *)(a1 + 28), (int)"stat", (int)v10);
      }
      else
      {
        if ( (a3 & 3) == 2 )
        {
          v12 = _xstat64(3, v10, v27);
          v13 = *v11;
          if ( !v12 || v13 != 2 )
          {
            if ( !v13 )
              *v11 = 22;
            sub_7CF18(*(_DWORD *)(a1 + 28), (int)"stat", (int)v10);
          }
        }
        v14 = strrchr(v10, 47);
        if ( v14 )
        {
          v16 = v14 - v10;
          ptr = (void *)(v14 - v10 + 1);
          v17 = malloc((size_t)ptr);
          if ( !v17 )
            sub_C610((int)ptr);
          ptra = v17;
          memcpy(v17, v10, v16);
          ptra[v16] = 0;
          if ( _xstat64(3, ptra, v27) || (v18 = v28, *v11 = 22, (v18 & 0xF000) != 0x4000) )
            sub_7CF18(*(_DWORD *)(a1 + 28), (int)"stat", (int)ptra);
          free(ptra);
        }
      }
      v19 = a3 & 0x30;
      if ( v19 == 16 )
      {
        v20 = open64(a2[6], a4, v15);
        if ( v20 < 0 )
          sub_7CF18(*(_DWORD *)(a1 + 28), (int)"open", a2[6]);
      }
      else
      {
        if ( v19 != 32 )
          return;
        v20 = fopen64(a2[6], a4);
        if ( !v20 )
          sub_7CF18(*(_DWORD *)(a1 + 28), (int)"fopen", a2[6]);
      }
      v21 = a2[4];
      v22 = (const char *)a2[6];
      if ( (v21 & 0x40) != 0 )
      {
        a2[7] = v22;
      }
      else
      {
        v24 = _strdup((const char *)a2[6]);
        if ( !v24 )
          sub_7E624(v22);
        v21 = a2[4];
        a2[7] = v24;
      }
      a2[6] = v20;
      a2[4] = v21 & 0xFFFFFFBF;
    }
  }
  else if ( a1 == 1 )
  {
    if ( (a3 & 3) == 1 )
    {
      fputs(&off_B856C[0][dword_1073C8], (FILE *)option_usage_fp);
    }
    else if ( (a3 & 3) == 2 )
    {
      fputs(&off_B8568[0][dword_1073C8], (FILE *)option_usage_fp);
    }
  }
}
// 83EBC: variable 'v15' is possibly undefined
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// B8568: using guessed type char *off_B8568[39];
// B856C: using guessed type char *off_B856C[38];
// 1073C8: using guessed type int dword_1073C8;
// 107410: using guessed type int option_usage_fp;

//----- (00083F7C) --------------------------------------------------------
int __fastcall sub_83F7C(_BYTE *a1, unsigned int a2, char *s, const char *a4)
{
  unsigned int v5; // r4
  size_t v9; // r0
  bool v10; // cc
  int v11; // r6
  int v12; // r1
  char *v13; // r2
  _BYTE *v14; // r0
  int v15; // t1
  const char *v16; // r0
  char *v17; // r4
  size_t v18; // r0
  unsigned int v20; // r1
  const char *v21; // r9
  _BYTE *v22; // r12
  unsigned int v23; // t1
  char *v24; // r0
  const char *v25; // r11
  size_t v26; // r10
  char *v27; // r10
  const char *v28; // r11
  char *v29; // r0
  char *v30; // r0
  int v31; // [sp+8h] [bp-14h]
  char *v32; // [sp+Ch] [bp-10h]

  v5 = a2;
  v9 = strlen(s);
  v10 = v9 != 0;
  if ( v9 )
    v10 = v5 > v9;
  v11 = !v10;
  if ( !v10 )
    return 0;
  v12 = (unsigned __int8)*s;
  if ( v12 == 36 )
  {
    v20 = (unsigned __int8)s[1];
    if ( v20 == 36 )
    {
      if ( s[2] )
      {
        if ( s[2] != 47 )
          return v11;
        v31 = 3;
      }
      else
      {
        v31 = 2;
      }
      if ( strchr(a4, 47) )
      {
        v27 = (char *)a4;
      }
      else
      {
        v29 = getenv("PATH");
        v30 = sub_7F9CC(v29, a4);
        v27 = v30;
        if ( !v30 )
          return 0;
      }
      v32 = strrchr(v27, 47);
      if ( !v32 )
        return 0;
      v28 = &s[v31];
      if ( v5 <= strlen(v28) + v32 - v27 + 1 )
        return 0;
      memcpy(a1, v27, v32 - v27 + 1);
      strcpy(&a1[v32 - v27 + 1], v28);
      if ( a4 != v27 )
        free(v27);
    }
    else if ( v20 == 64 )
    {
      if ( !*off_B8604 || (int)sub_6C054((int)a1, v5, (unsigned __int8 *)"%s%s", off_B8604, s + 2) >= (int)v5 )
        return 0;
    }
    else
    {
      if ( !s[1] )
        return v11;
      v21 = s + 1;
      if ( v20 > 0x7F || (dword_9F184[v20] & 0x3B0060) == 0 )
        return 0;
      v22 = a1;
      do
      {
        *v22++ = v20;
        v23 = *(unsigned __int8 *)++v21;
        v20 = v23;
      }
      while ( v23 <= 0x7F && (dword_9F184[v20] & 0x3B0060) != 0 );
      if ( a1 == v22 )
        return 0;
      *v22 = 0;
      v24 = getenv(a1);
      v25 = v24;
      if ( !v24 )
        return 0;
      v26 = strlen(v24);
      if ( v5 <= v26 + strlen(v21) + 1 )
        return 0;
      sprintf(a1, "%s%s", v25, v21);
    }
  }
  else
  {
    v13 = s;
    v14 = a1;
    while ( 1 )
    {
      *v14++ = v12;
      if ( !v12 )
        break;
      if ( (int)--v5 <= 0 )
        return 0;
      v15 = (unsigned __int8)*++v13;
      v12 = v15;
    }
  }
  v16 = (const char *)canonicalize_file_name(a1);
  v17 = (char *)v16;
  if ( !v16 )
    return 0;
  v18 = strlen(v16);
  if ( a2 > v18 )
  {
    v11 = 1;
    memcpy(a1, v17, v18 + 1);
  }
  free(v17);
  return v11;
}
// B6E0: using guessed type int __fastcall canonicalize_file_name(_DWORD);
// 9F184: using guessed type _DWORD dword_9F184[1];
// B8604: using guessed type char *off_B8604;

//----- (00084264) --------------------------------------------------------
int __fastcall sub_84264(_DWORD *a1, const char *a2, const char *a3)
{
  _DWORD *v6; // r6
  int result; // r0
  _BYTE *v8; // r4
  FILE *v9; // r1
  _BYTE *v10; // t1
  _BYTE *v11; // r9
  int v12; // r3
  bool v13; // zf
  _BYTE v14[16]; // [sp+10h] [bp-1074h] BYREF
  __int16 v15; // [sp+20h] [bp-1064h]
  _BYTE v16[8]; // [sp+78h] [bp-100Ch] BYREF

  v6 = a1 + 1;
  result = fputs(off_B85B0[0], (FILE *)option_usage_fp);
  v8 = (_BYTE *)*a1;
  if ( v8 )
  {
    do
    {
      if ( sub_83F7C(v16, 0x1001u, v8, a3) )
      {
        if ( *v8 == 36 )
        {
          v12 = (unsigned __int8)v8[1];
          v11 = v16;
          v13 = v12 == 64;
          if ( v12 != 64 )
            v13 = v12 == 36;
          if ( v13 )
            v8 = v16;
        }
        else
        {
          v11 = v16;
        }
      }
      else
      {
        v11 = v8;
      }
      fprintf((FILE *)option_usage_fp, off_B85A4[0], v8);
      if ( *a2 && !_xstat64(3, v11, v14) )
      {
        v9 = (FILE *)option_usage_fp;
        if ( (v15 & 0xF000) != 0x4000 )
          goto LABEL_4;
        fputc(47, (FILE *)option_usage_fp);
        fputs(a2, (FILE *)option_usage_fp);
      }
      v9 = (FILE *)option_usage_fp;
LABEL_4:
      result = fputc(10, v9);
      v10 = (_BYTE *)*v6++;
      v8 = v10;
    }
    while ( v10 );
  }
  return result;
}
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);
// B85A4: using guessed type char *off_B85A4[24];
// B85B0: using guessed type char *off_B85B0[21];
// 107410: using guessed type int option_usage_fp;

//----- (000843E0) --------------------------------------------------------
void __fastcall sub_843E0(_DWORD *a1)
{
  if ( a1 )
  {
    if ( *a1 == 6 )
    {
      sub_7C38C((_DWORD *)a1[2]);
      free(a1);
    }
    else
    {
      *_errno_location() = 22;
    }
  }
}

//----- (0008446C) --------------------------------------------------------
void __fastcall sub_8446C(unsigned int a1, int a2)
{
  _DWORD *v3; // r0
  _DWORD **v4; // r5
  int v5; // r4
  _DWORD *v6; // t1
  const char *v7; // r4
  size_t v8; // r0
  int **v9; // r1

  if ( a1 > 0xE )
  {
    if ( (*(_DWORD *)(a2 + 16) & 8) != 0 )
    {
      v3 = *(_DWORD **)(a2 + 28);
      if ( v3 )
      {
        v4 = (_DWORD **)(v3 + 2);
        v5 = *v3 - 1;
        if ( v5 >= 0 )
        {
          do
          {
            --v5;
            v6 = *v4++;
            sub_843E0(v6);
          }
          while ( v5 != -1 );
          v3 = *(_DWORD **)(a2 + 28);
        }
        free(v3);
      }
    }
    else
    {
      v7 = *(const char **)(a2 + 52);
      v8 = strlen(v7);
      v9 = sub_82410(*(char **)(a2 + 24), v7, v8);
      if ( v9 )
        sub_7E784((int **)(a2 + 28), (int)v9);
    }
  }
}

//----- (0008455C) --------------------------------------------------------
int __fastcall sub_8455C(unsigned int a1, _DWORD *a2, int a3, int a4)
{
  bool v6; // zf
  int result; // r0
  FILE *v10; // r0
  char *v11; // r11
  int v12; // r4
  int v13; // r2
  int v14; // r3
  char *v15; // [sp+Ch] [bp-10h]

  v6 = a1 == 1;
  result = 2092;
  if ( v6 )
  {
    v15 = &ao_strs_strtable[dword_1073C8 + 203];
    v10 = (FILE *)option_usage_fp;
    if ( (a2[4] & 0x1000000) == 0 )
      goto LABEL_5;
    goto LABEL_24;
  }
  if ( a1 <= 0xF )
    return result;
  v15 = (char *)&unk_97F7C;
  fprintf((FILE *)option_usage_fp, off_B8538[0], *(_DWORD *)(a1 + 28), a2[13], a2[6]);
  v10 = (FILE *)option_usage_fp;
  if ( (a2[4] & 0x1000000) != 0 )
  {
LABEL_24:
    fprintf(v10, off_B85D4[0], v15);
    v10 = (FILE *)option_usage_fp;
  }
LABEL_5:
  if ( a4 <= 1 )
    fprintf(v10, off_B85CC[0], v15);
  else
    fprintf(v10, off_B85C8[0], v15);
  if ( a1 == 1 )
    v11 = &ao_strs_strtable[dword_1073C8 + 210];
  else
    v11 = "\t";
  v12 = a3 + 8;
  while ( 1 )
  {
    v13 = *(_DWORD *)(v12 - 4);
    v14 = *(_DWORD *)(v12 - 8);
    if ( v13 == 0x80000000 )
    {
      fprintf((FILE *)option_usage_fp, off_B85C4[0], v11, v14);
    }
    else if ( v14 == 0x80000000 )
    {
      fprintf((FILE *)option_usage_fp, off_B85D8[0], v11, *(_DWORD *)(v12 - 4));
    }
    else if ( v13 == 0x7FFFFFFF )
    {
      fprintf((FILE *)option_usage_fp, off_B85C0[0], v11);
    }
    else
    {
      fprintf((FILE *)option_usage_fp, off_B85BC[0], v11);
    }
    --a4;
    v12 += 8;
    if ( a4 <= 0 )
      break;
    fputs(off_B85D0[0], (FILE *)option_usage_fp);
  }
  result = fputc(10, (FILE *)option_usage_fp);
  if ( a1 > 0xF )
    return (*(int (__fastcall **)(unsigned int, int))(a1 + 84))(a1, 1);
  return result;
}
// 180: using guessed type int[4];
// B8538: using guessed type char *off_B8538[51];
// B85BC: using guessed type char *off_B85BC[18];
// B85C0: using guessed type char *off_B85C0[17];
// B85C4: using guessed type char *off_B85C4[16];
// B85C8: using guessed type char *off_B85C8[15];
// B85CC: using guessed type char *off_B85CC[14];
// B85D0: using guessed type char *off_B85D0[13];
// B85D4: using guessed type char *off_B85D4[12];
// B85D8: using guessed type char *off_B85D8[11];
// 1073C8: using guessed type int dword_1073C8;
// 107410: using guessed type int option_usage_fp;

//----- (00084784) --------------------------------------------------------
_BYTE *__fastcall sub_84784(_BYTE *a1, char *s)
{
  size_t v4; // r4
  size_t v5; // r0
  _BYTE *v6; // r2
  size_t v7; // r9
  int v8; // r3
  int v9; // t1
  bool v10; // zf
  int v11; // r3
  int v12; // t1
  _BYTE *v13; // r0
  _BYTE *v14; // r7
  _BYTE *v15; // r4
  _BYTE *v16; // r3
  bool v17; // zf
  int v18; // r2
  int v19; // r1
  _BYTE *v20; // r2
  int v21; // t1
  _BYTE *v22; // r3
  char *v24; // r0
  void *v25; // r0

  v4 = 3;
  v5 = strlen(s);
  v6 = a1;
  v7 = v5;
  while ( 2 )
  {
    v9 = (unsigned __int8)*v6++;
    v8 = v9;
    if ( (unsigned int)(v9 - 32) <= 0x5E )
    {
      do
      {
        v10 = v8 == 92;
        if ( v8 != 92 )
          v10 = v8 == 34;
        if ( v10 )
          v11 = 2;
        else
          v11 = 1;
        v4 += v11;
        v12 = (unsigned __int8)*v6++;
        v8 = v12;
      }
      while ( (unsigned int)(v12 - 32) <= 0x5E );
    }
    switch ( v8 )
    {
      case 0:
        v13 = malloc(v4);
        v14 = v13;
        if ( !v13 )
          sub_C610(v4);
        v15 = v13 + 1;
        *v13 = 34;
        break;
      case 7:
      case 8:
      case 9:
      case 11:
      case 12:
      case 13:
        v4 += 2;
        continue;
      case 10:
        v4 += v5;
        continue;
      default:
        v4 += 4;
        continue;
    }
    break;
  }
  while ( 2 )
  {
    while ( 1 )
    {
      v18 = (unsigned __int8)*a1;
      if ( (unsigned int)(v18 - 32) > 0x5E )
        break;
      v16 = v15 + 1;
      v17 = v18 == 92;
      if ( v18 != 92 )
        v17 = v18 == 34;
      if ( v17 )
      {
        *v15 = 92;
        v15 += 2;
      }
      else
      {
        v16 = v15++;
      }
      *v16 = v18;
LABEL_20:
      ++a1;
    }
    switch ( *a1 )
    {
      case 0:
        goto LABEL_29;
      case 7:
        *v15 = 92;
        v15[1] = 97;
        v15 += 2;
        goto LABEL_20;
      case 8:
        *v15 = 92;
        v15[1] = 98;
        v15 += 2;
        goto LABEL_20;
      case 9:
        *v15 = 92;
        v15[1] = 116;
        v15 += 2;
        goto LABEL_20;
      case 0xA:
        v19 = (unsigned __int8)*++a1;
        if ( v19 == 10 )
        {
          v20 = v15 + 2;
          do
          {
            v21 = (unsigned __int8)*++a1;
            v19 = v21;
            v15 = v20;
            *(v20 - 2) = 92;
            v20 += 2;
            *(v20 - 3) = 110;
          }
          while ( v21 == 10 );
        }
        if ( v19 )
        {
          v25 = v15;
          v15 += v7;
          memcpy(v25, s, v7);
          continue;
        }
        v22 = v15;
        *v15 = 92;
        v15 += 2;
        v22[1] = 110;
LABEL_29:
        *v15 = 34;
        v15[1] = 0;
        return v14;
      case 0xB:
        *v15 = 92;
        v15[1] = 118;
        v15 += 2;
        goto LABEL_20;
      case 0xC:
        *v15 = 92;
        v15[1] = 102;
        v15 += 2;
        goto LABEL_20;
      case 0xD:
        *v15 = 92;
        v15[1] = 114;
        v15 += 2;
        goto LABEL_20;
      default:
        v24 = v15;
        v15 += 4;
        sprintf(v24, "\\%03o", v18);
        goto LABEL_20;
    }
  }
}

//----- (00084A50) --------------------------------------------------------
void __fastcall sub_84A50(_BYTE *a1, FILE *a2)
{
  char *v3; // r7

  v3 = sub_84784(a1, "\\n\\\n");
  fprintf(a2, "  puts(_(%s));\n", v3);
  free(v3);
}

//----- (00085098) --------------------------------------------------------
char *__fastcall sub_85098(void *src)
{
  void *v1; // r3
  _DWORD *v3; // r0
  int v5; // r6
  void *v6; // r0

  v1 = (void *)*((_DWORD *)src + 20);
  if ( !v1 )
  {
    v5 = (*((_DWORD *)src + 25) << 6) + 132;
    v6 = malloc(v5);
    v1 = v6;
    if ( !v6 )
      sub_C610(v5);
    *((_DWORD *)src + 20) = v6;
  }
  v3 = memcpy(v1, src, 0x84u);
  memcpy(v3 + 33, *((const void **)src + 17), v3[25] << 6);
  return sub_7E680((char *)src);
}

//----- (00085140) --------------------------------------------------------
void __fastcall sub_85140(void *dest)
{
  int v2; // r4
  int v3; // r9
  _DWORD *v4; // r0
  unsigned int v5; // r3
  int v6; // r3
  int v7; // r4

  while ( 1 )
  {
    v2 = *((_DWORD *)dest + 17);
    v3 = *((_DWORD *)dest + 25);
    do
    {
      v5 = *(_DWORD *)(v2 + 16);
      if ( (v5 & 0x40) != 0 )
      {
        free(*(void **)(v2 + 24));
        v6 = *(_DWORD *)(v2 + 16);
        *(_DWORD *)(v2 + 24) = 0;
        v5 = v6 & 0xFFFFFFBF;
        *(_DWORD *)(v2 + 16) = v5;
      }
      if ( (unsigned __int16)v5 >> 12 == 6 )
      {
        v4 = *(_DWORD **)(v2 + 28);
        if ( v4 )
          sub_7C38C(v4);
      }
      --v3;
      *(_DWORD *)(v2 + 28) = 0;
      v2 += 64;
    }
    while ( v3 > 0 );
    v7 = *((_DWORD *)dest + 20);
    if ( !v7 )
      break;
    memcpy(dest, *((const void **)dest + 20), 0x84u);
    memcpy(*((void **)dest + 17), (const void *)(v7 + 132), *(_DWORD *)(v7 + 100) << 6);
    free(*((void **)dest + 20));
    *((_DWORD *)dest + 20) = 0;
  }
}

//----- (00085234) --------------------------------------------------------
char *__fastcall sub_85234(int a1)
{
  _DWORD *v1; // r5

  v1 = *(_DWORD **)(a1 + 80);
  if ( !v1 )
  {
    fprintf(stderr, off_B8504[0]);
    sub_7CE5C(1);
  }
  *(_DWORD *)(a1 + 80) = 0;
  sub_85140((void *)a1);
  memcpy((void *)a1, v1, 0x84u);
  memcpy(*(void **)(a1 + 68), v1 + 33, v1[25] << 6);
  *(_DWORD *)(a1 + 80) = v1;
  return sub_7E680((char *)a1);
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8504: using guessed type char *off_B8504[64];

//----- (00085318) --------------------------------------------------------
void __fastcall sub_85318(int *a1)
{
  char *v2; // r0
  char *v3; // r6
  FILE *v4; // r7
  unsigned __int16 *v5; // r6
  char *v6; // r0
  char *v7; // r0
  int v8; // r5
  unsigned __int16 *v9; // r4
  int v10; // r3
  int v11; // r2
  int v12; // r3
  const char *v13; // r2
  char *v14; // r9
  char *v15; // r0
  char *v16; // r8
  int v17; // r3
  int v18; // r2
  int v19; // r3
  _DWORD *v20; // r9
  int v21; // r8
  const char **v22; // r9
  int v23; // t1
  int v24; // r8
  const char *v25; // t1
  int v26; // r8
  _DWORD *v27; // r3
  int v28; // r8
  _DWORD **v29; // r9
  _DWORD *v30; // r5
  _DWORD *v31; // t1
  _DWORD *v32; // r4
  bool v33; // cc
  int v34; // r4
  FILE *v35; // r5
  const char *v36; // r7
  char *v37; // r0
  unsigned __int16 *v38; // [sp+18h] [bp-14h]
  size_t v39; // [sp+1Ch] [bp-10h]
  int v40; // [sp+1Ch] [bp-10h]
  const char *v41; // [sp+20h] [bp-Ch] BYREF

  v41 = 0;
  v2 = sub_7F530((int)a1, &v41);
  v3 = v2;
  if ( v2 )
  {
    v4 = (FILE *)fopen64(v2, "w");
    if ( v4 )
    {
      if ( v41 )
        free(v3);
      fwrite("#  ", 1u, 3u, v4);
      v5 = (unsigned __int16 *)a1[14];
      v6 = strchr((const char *)v5, 10);
      if ( v6 )
        fwrite(v5, 1u, v6 + 1 - (char *)v5, v4);
      v41 = (const char *)time(0);
      v7 = ctime((const time_t *)&v41);
      fprintf(v4, "#  preset/initialization file\n#  %s#\n", v7);
      v8 = a1[26];
      v9 = (unsigned __int16 *)a1[17];
      do
      {
        while ( 2 )
        {
          v10 = *((_DWORD *)v9 + 4);
          if ( (v10 & 0xF) != 0 && (v10 & 0x280100) == 0 )
          {
            v11 = v9[4];
            if ( v11 == 0x8000 || *v9 == v11 )
            {
              v12 = (unsigned __int16)v10 >> 12;
              if ( (*((_DWORD *)v9 + 4) & 0x10) != 0 )
                v11 = v9[2];
              else
                v5 = v9;
              if ( (*((_DWORD *)v9 + 4) & 0x10) != 0 )
                v5 = (unsigned __int16 *)(a1[17] + (v11 << 6));
              switch ( v12 )
              {
                case 0:
                  v17 = *((_DWORD *)v9 + 13);
                  --v8;
                  v9 += 32;
                  if ( (*((_DWORD *)v5 + 4) & 0x20) != 0 )
                    v18 = *((_DWORD *)v9 - 2);
                  else
                    v18 = v17;
                  if ( !v18 )
                    v18 = v17;
                  fprintf(v4, "%s\n", v18, v17);
                  if ( v8 > 0 )
                    continue;
                  goto LABEL_22;
                case 1:
                  v19 = *((_DWORD *)v5 + 4);
                  if ( (v19 & 0x400) == 0 )
                    goto LABEL_24;
                  v20 = (_DWORD *)*((_DWORD *)v5 + 7);
                  v23 = *v20;
                  v22 = (const char **)(v20 + 2);
                  v21 = v23;
                  if ( v23 <= 1 )
                  {
                    v33 = v21 <= 0;
                    v24 = v21 - 1;
                    if ( v33 )
                      goto LABEL_21;
                  }
                  else
                  {
                    v24 = v21 - 1;
                    *((_DWORD *)v5 + 4) = v19 & 0xFFFFFFDF;
                  }
                  do
                  {
                    --v24;
                    v25 = *v22++;
                    sub_7C7A4(v4, (int)v5, v25);
                  }
                  while ( v24 != -1 );
                  break;
                case 2:
                  v26 = *((_DWORD *)v5 + 6);
                  --v8;
                  v9 += 32;
                  (*((void (__fastcall **)(int, unsigned __int16 *, int))v5 + 10))(3, v5, v11);
                  sub_7C7A4(v4, (int)v5, *((const char **)v5 + 6));
                  *((_DWORD *)v5 + 6) = v26;
                  if ( v8 > 0 )
                    continue;
                  goto LABEL_22;
                case 3:
                  if ( *((_DWORD *)v5 + 6) )
                    v13 = "true";
                  else
                    v13 = "false";
                  goto LABEL_20;
                case 4:
                  v14 = (char *)sub_835B8((int)v5);
                  v39 = strlen(v14);
                  v15 = (char *)malloc(v39 + 3);
                  v16 = v15;
                  if ( !v15 )
                    sub_C610(v39 + 3);
                  *v15 = 61;
                  --v8;
                  memcpy(v15 + 1, v14, v39 + 1);
                  v9 += 32;
                  sub_7C7A4(v4, (int)v5, v16);
                  free(v16);
                  free(v14);
                  if ( v8 > 0 )
                    continue;
                  goto LABEL_22;
                case 5:
LABEL_24:
                  --v8;
                  sub_7C7A4(v4, (int)v5, *((const char **)v5 + 6));
                  v9 += 32;
                  if ( v8 <= 0 )
                    goto LABEL_22;
                  continue;
                case 6:
                  v27 = (_DWORD *)*((_DWORD *)v5 + 7);
                  if ( v27 )
                  {
                    v28 = *v27;
                    if ( (int)*v27 > 0 )
                    {
                      v29 = (_DWORD **)(v27 + 2);
                      v38 = v9;
                      v40 = v8;
                      do
                      {
                        v31 = *v29++;
                        v30 = v31;
                        v32 = (_DWORD *)sub_81B34(v31, 0);
                        if ( v32 )
                        {
                          fprintf(v4, "<%s type=nested>\n", *((_DWORD *)v5 + 13));
                          do
                          {
                            sub_7CFA4((int)v4, 1, (int)v5, v32);
                            v32 = (_DWORD *)sub_81D14(v30, (int)v32);
                          }
                          while ( v32 );
                          fprintf(v4, "</%s>\n", *((_DWORD *)v5 + 13));
                        }
                        --v28;
                      }
                      while ( v28 );
                      v9 = v38;
                      v8 = v40;
                    }
                  }
                  goto LABEL_21;
                case 7:
                  v13 = (const char *)*((_DWORD *)v5 + 7);
                  if ( !v13 )
                  {
                    if ( *a1 <= 0x1FFFF )
                      goto LABEL_21;
                    v13 = (const char *)*((_DWORD *)v5 + 6);
                    if ( *(const char **)(a1[29] + 4 * *v5) == v13 )
                      goto LABEL_21;
                  }
LABEL_20:
                  sub_7C7A4(v4, (int)v5, v13);
                  goto LABEL_21;
                default:
                  goto LABEL_21;
              }
            }
          }
          break;
        }
LABEL_21:
        --v8;
        v9 += 32;
      }
      while ( v8 > 0 );
LABEL_22:
      fclose(v4);
    }
    else
    {
      fprintf(stderr, off_B8540[0], a1[7]);
      v34 = *_errno_location();
      v35 = stderr;
      v36 = off_B84F4[0];
      v37 = strerror(v34);
      fprintf(v35, v36, v34, v37, v3);
      if ( v41 )
        free(v3);
    }
  }
}
// B98C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B84F4: using guessed type char *off_B84F4[68];
// B8540: using guessed type char *off_B8540[49];

//----- (000857E4) --------------------------------------------------------
void __fastcall sub_857E4(unsigned int a1, int a2)
{
  bool v2; // cc
  int v3; // r3
  int v5; // r6
  _DWORD *v6; // r9
  int v7; // r11
  const char **v8; // r10
  int v9; // r4
  int v10; // r3
  bool v11; // zf
  char *v12; // r5
  const char *v13; // t1
  char *v14; // r8
  int v15; // r3
  int v16; // r3

  v2 = a2 != 0;
  if ( a2 )
    v2 = a1 > 0xF;
  if ( v2 )
  {
    v3 = *(_DWORD *)(a2 + 16);
    v5 = v3 & 8;
    if ( (v3 & 8) == 0 )
    {
      v6 = *(_DWORD **)(a2 + 28);
      if ( v6 )
      {
        v7 = *v6;
        if ( (int)*v6 > 0 )
        {
          v8 = (const char **)(v6 + 2);
          v9 = v3 & 8;
          while ( 1 )
          {
            while ( 1 )
            {
              v13 = *v8++;
              v12 = (char *)v13;
              v14 = strchr(v13, 61);
              if ( !v14 )
                break;
              *v14 = 0;
              if ( !strcmp(v12, *(const char **)(a2 + 24)) )
                goto LABEL_19;
              v10 = 61;
              *v14 = 61;
LABEL_12:
              v11 = v9++ == v5;
              if ( !v11 )
                v10 = v5 + 2;
              ++v5;
              if ( !v11 )
                v6[v10] = v12;
              if ( v7 == v9 )
              {
LABEL_20:
                v7 = *v6;
                goto LABEL_21;
              }
            }
            if ( strcmp(v12, *(const char **)(a2 + 24)) )
              goto LABEL_12;
LABEL_19:
            ++v9;
            free(v12);
            --*v6;
            if ( v7 == v9 )
              goto LABEL_20;
          }
        }
LABEL_21:
        if ( !v7 )
        {
          v15 = *(_DWORD *)(a2 + 16) & 0xFFFFF00;
          if ( (*(_DWORD *)(a2 + 16) & 0x800) == 0 )
            v15 |= 0x20u;
          *(_DWORD *)(a2 + 16) = v15;
          free(v6);
          *(_DWORD *)(a2 + 28) = 0;
        }
      }
      else
      {
        v16 = v3 & 0xFFFFF00;
        if ( (*(_DWORD *)(a2 + 16) & 0x800) == 0 )
          v16 |= 0x20u;
        *(_DWORD *)(a2 + 16) = v16;
      }
    }
  }
}
// 8587C: variable 'v10' is possibly undefined

//----- (00085948) --------------------------------------------------------
unsigned int __fastcall sub_85948(unsigned int result, int a2)
{
  bool v2; // cc
  const char *v4; // r6
  char *v5; // r1

  v2 = a2 != 0;
  if ( a2 )
    v2 = result > 0xF;
  if ( v2 && (*(_DWORD *)(a2 + 16) & 8) == 0 )
  {
    v4 = *(const char **)(a2 + 24);
    if ( v4 )
    {
      v5 = _strdup(*(const char **)(a2 + 24));
      if ( !v5 )
        sub_7E624(v4);
      return sub_7E784((int **)(a2 + 28), (int)v5);
    }
  }
  return result;
}
// 2FC18: using guessed type double dbl_2FC18;

//----- (000859EC) --------------------------------------------------------
int __fastcall sub_859EC(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r2
  int v4; // r12
  int v5; // t1
  int v6; // r3
  int v7; // t1
  int v8; // r3

  if ( a3 > 0 )
  {
    v3 = &a2[a3];
    do
    {
      v5 = *a1++;
      v4 = v5;
      v7 = *a2++;
      v6 = v7;
      if ( v4 == v7 )
      {
        if ( !v4 )
          return 0;
      }
      else
      {
        v8 = *((unsigned __int8 *)&dword_B8164 + v4 + 8) - *((unsigned __int8 *)&dword_B8164 + v6 + 8);
        if ( v8 || !v4 )
          return v8;
      }
    }
    while ( v3 != a2 );
  }
  return 0;
}
// B8164: using guessed type int dword_B8164;

//----- (00085A98) --------------------------------------------------------
int __fastcall sub_85A98(int a1, char *src, int *a3)
{
  unsigned __int8 *v3; // r6
  unsigned __int8 *v4; // r1
  unsigned __int8 *v5; // r7
  int v6; // r11
  int v7; // r2
  int v8; // t1
  unsigned __int8 *v9; // r1
  int v10; // r5
  _DWORD *v11; // r4
  int v12; // r10
  int v13; // r8
  int v14; // r7
  unsigned __int8 *v15; // r1
  unsigned int v16; // r2
  bool v17; // zf
  unsigned __int8 *v18; // r1
  unsigned __int8 *v20; // r7
  size_t v21; // r9
  const char *v22; // r5
  int v23; // r7
  int v24; // r8
  unsigned __int8 *v25; // r1
  unsigned __int8 *v26; // r1
  int v27; // r3
  int v28; // r0
  _DWORD *v29; // r5
  int v30; // r5
  int v31; // r2
  int v32; // r3
  int v34; // [sp+10h] [bp-9Ch]
  unsigned __int8 *v36; // [sp+1Ch] [bp-90h]
  _BYTE dest[136]; // [sp+24h] [bp-88h] BYREF

  v3 = (unsigned __int8 *)src;
  v4 = (unsigned __int8 *)(src + 128);
  v5 = v3;
  while ( 1 )
  {
    v6 = v5 - v3;
    v8 = *v5++;
    v7 = v8;
    if ( !v8 )
      break;
    if ( v7 == 61 )
    {
      v9 = v3;
      v3 = dest;
      memcpy(dest, v9, v6);
      dest[v6] = 0;
      goto LABEL_5;
    }
    if ( v5 == v4 )
      goto LABEL_21;
  }
  v5 = 0;
LABEL_5:
  if ( v6 <= 1 )
  {
LABEL_21:
    if ( (*(_DWORD *)(a1 + 12) & 4) != 0 )
    {
      fprintf(stderr, off_B84DC[0], *(_DWORD *)(a1 + 28), v3);
      v28 = a1;
      goto LABEL_51;
    }
    return -1;
  }
  v36 = v5;
  v34 = 0;
  v10 = 0;
  v11 = *(_DWORD **)(a1 + 68);
  v12 = 0;
  v13 = *(_DWORD *)(a1 + 100);
  v14 = 0;
  do
  {
    v15 = (unsigned __int8 *)v11[13];
    if ( v15 )
    {
      v16 = v11[4];
      v17 = v16 == (_DWORD)&loc_80100;
      if ( (_UNKNOWN *)v16 != &loc_80100 )
        v17 = (v16 & 0x280000) == 0;
      if ( v17 )
      {
        if ( !sub_859EC(v3, v15, v6) )
        {
          if ( !*(_BYTE *)(v11[13] + v6) )
          {
            v10 = v14;
            v20 = v36;
            goto LABEL_42;
          }
          goto LABEL_8;
        }
        v18 = (unsigned __int8 *)v11[14];
        if ( v18 && !sub_859EC(v3, v18, v6) )
        {
          if ( !*(_BYTE *)(v11[14] + v6) )
          {
            v30 = v14;
            v20 = v36;
            v29 = (_DWORD *)(*(_DWORD *)(a1 + 68) + (v30 << 6));
            if ( (v29[4] & 0x280000) != 0 )
            {
LABEL_46:
              if ( (*(_DWORD *)(a1 + 12) & 4) != 0 )
              {
                fprintf(stderr, off_B84C0[0], *(_DWORD *)(a1 + 28), v29[13]);
                if ( v29[11] )
                  fprintf(stderr, " -- %s");
                fputc(10, stderr);
LABEL_50:
                v28 = a1;
LABEL_51:
                (*(void (__fastcall **)(int, int))(v28 + 84))(v28, 1);
                exit(1);
              }
              return -1;
            }
LABEL_52:
            a3[2] |= 0x20u;
LABEL_44:
            *a3 = (int)v29;
            a3[1] = (int)v20;
            a3[3] = 2;
            return 0;
          }
          v34 = 1;
LABEL_8:
          ++v12;
          v10 = v14;
        }
      }
    }
    ++v14;
    v11 += 16;
  }
  while ( v13 > v14 );
  v20 = v36;
  if ( v12 )
  {
    if ( v12 != 1 )
    {
      if ( (*(_DWORD *)(a1 + 12) & 4) != 0 )
      {
        fprintf(stderr, off_B84A4[0], *(_DWORD *)(a1 + 24), v3, v12);
        if ( v12 <= 4 )
        {
          v21 = strlen((const char *)v3);
          if ( (*(_DWORD *)(a1 + 12) & 3) != 0 )
            v22 = "--";
          else
            v22 = byte_97F7C;
          v23 = 0;
          v24 = *(_DWORD *)(a1 + 68);
          fputs(off_B84A0[0], stderr);
          do
          {
            v25 = *(unsigned __int8 **)(v24 + 52);
            if ( v25 )
            {
              if ( sub_859EC(v3, v25, v21) )
              {
                v26 = *(unsigned __int8 **)(v24 + 56);
                if ( v26 )
                {
                  if ( !sub_859EC(v3, v26, v21) )
                    fprintf(stderr, "  %s%s\n", v22, *(_DWORD *)(v24 + 56));
                }
              }
              else
              {
                fprintf(stderr, "  %s%s\n", v22, *(_DWORD *)(v24 + 52));
              }
            }
            ++v23;
            v24 += 64;
          }
          while ( v23 < *(_DWORD *)(a1 + 100) );
        }
        goto LABEL_50;
      }
      return -1;
    }
LABEL_42:
    v29 = (_DWORD *)(*(_DWORD *)(a1 + 68) + (v10 << 6));
    if ( (v29[4] & 0x280000) != 0 )
      goto LABEL_46;
    if ( v34 )
      goto LABEL_52;
    goto LABEL_44;
  }
  v27 = *(_DWORD *)(a1 + 12);
  if ( v36 || (v27 & 3) != 0 || (v31 = *(unsigned __int16 *)(a1 + 98), v31 == 0x8000) )
  {
    if ( (v27 & 4) != 0 )
    {
      fprintf(stderr, off_B84CC[0], *(_DWORD *)(a1 + 24), v3);
      v28 = a1;
      goto LABEL_51;
    }
    return -1;
  }
  v32 = *(_DWORD *)(a1 + 68) + (v31 << 6);
  a3[1] = (int)v3;
  a3[3] = 3;
  *a3 = v32;
  return 0;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B84A0: using guessed type char *off_B84A0[89];
// B84A4: using guessed type char *off_B84A4[88];
// B84C0: using guessed type char *off_B84C0[81];
// B84CC: using guessed type char *off_B84CC[78];
// B84DC: using guessed type char *off_B84DC[74];

//----- (00085F40) --------------------------------------------------------
char *__fastcall sub_85F40(int a1, int *a2, char *s, int a4, int a5)
{
  char *v9; // r0
  int v10; // t1
  char *v11; // r0
  char *v12; // r3
  unsigned __int8 *v13; // r6
  unsigned int v14; // r2
  _BOOL4 v15; // r11
  char *v16; // r0
  int v17; // r3
  int v18; // t1
  bool v19; // zf
  unsigned int v20; // r2
  char *result; // r0
  int v22; // r3
  int v23; // r3
  void ***v24; // r1
  int v25; // r5
  int v26; // r3
  int v27; // r2
  int v28; // r2
  char *v29; // r0
  int v30; // r3
  char *v31; // r0
  int v32; // r3
  int v33; // t1
  int v34; // r3
  char *v35; // [sp+4h] [bp-10h]

  v9 = (char *)dword_1073B8;
  if ( !dword_1073B8 )
    v9 = sub_7E2F8(45);
  if ( v9[(unsigned __int8)*s] )
  {
    do
      v10 = (unsigned __int8)*++s;
    while ( v9[v10] );
  }
  v11 = strpbrk(s, " \t\n:=");
  v12 = v11;
  if ( v11 )
  {
    v13 = (unsigned __int8 *)(v11 + 1);
    if ( a5 == 2 )
    {
      *v11 = 0;
    }
    else
    {
      v14 = (unsigned __int8)*v11;
      v15 = v14 <= 0x7F && (dword_9F184[v14] & 0xC01) != 0;
      *v11 = 0;
      v16 = (char *)dword_107334;
      if ( !dword_107334 )
      {
        v35 = v12;
        v16 = sub_7E2F8(12);
        v12 = v35;
      }
      v17 = (unsigned __int8)v12[1];
      if ( v16[v17] )
      {
        do
        {
          v18 = *++v13;
          v17 = v18;
        }
        while ( v16[v18] );
      }
      if ( v15 )
      {
        v19 = v17 == 61;
        if ( v17 != 61 )
          v19 = v17 == 58;
        if ( v19 )
        {
          v31 = (char *)dword_107334;
          if ( !dword_107334 )
            v31 = sub_7E2F8(12);
          v32 = *++v13;
          if ( v31[v32] )
          {
            do
              v33 = *++v13;
            while ( v31[v33] );
          }
        }
      }
    }
  }
  else
  {
    v13 = (unsigned __int8 *)&s[strlen(s)];
  }
  v20 = (unsigned __int8)s[1];
  if ( v20 <= 0x7F && (dword_9F184[v20] & 0x3B0040) != 0 )
  {
    result = (char *)sub_85A98(a1, s, a2);
    if ( result )
      return result;
    if ( !a4 )
      goto LABEL_23;
  }
  else
  {
    result = (char *)sub_7DFF0(a1, (unsigned __int8)*s, a2, a2 + 3);
    if ( result )
      return result;
    if ( !a4 )
    {
LABEL_23:
      v22 = *v13;
      if ( v22 != 34 && v22 != 39 )
      {
        a2[1] = (int)v13;
        goto LABEL_27;
      }
      goto LABEL_56;
    }
  }
  v26 = a2[2];
  if ( (v26 & 0x100) != 0 )
    return result;
  v27 = *v13;
  if ( v27 != 34 && v27 != 39 )
  {
    a2[1] = (int)v13;
    goto LABEL_37;
  }
LABEL_56:
  result = sub_821C8(v13, 0);
  a2[1] = (int)v13;
  v26 = a2[2];
  if ( !a4 )
    goto LABEL_27;
LABEL_37:
  v28 = v26 & 0x60000;
  if ( (v26 & 0x60000) == 0x20000 )
  {
    v34 = v26 & 0x20;
    if ( a4 < 0 )
      goto LABEL_64;
    goto LABEL_67;
  }
  if ( (v26 & 0x60000u) > 0x20000 )
  {
    if ( v28 != 0x40000 )
    {
      if ( v28 != 393216 || a4 <= 0 )
        goto LABEL_27;
      return result;
    }
    v34 = v26 & 0x20;
    if ( a4 >= 0 )
    {
LABEL_64:
      if ( v34 )
        goto LABEL_27;
      return result;
    }
LABEL_67:
    if ( !v34 )
      goto LABEL_27;
    return result;
  }
  if ( v28 || a4 >= 0 )
  {
LABEL_27:
    v23 = *(_DWORD *)(*a2 + 16);
    if ( (v23 & 0xF000) == 0 )
    {
      if ( *v13 )
        return result;
      goto LABEL_29;
    }
    if ( (v23 & 0x10000) != 0 )
    {
      if ( !*v13 )
      {
LABEL_29:
        a2[1] = 0;
LABEL_30:
        v24 = (void ***)a2;
        v25 = dword_B8168;
        dword_B8168 = a5;
        result = (char *)sub_7DC70(a1, v24);
        dword_B8168 = v25;
        return result;
      }
    }
    else if ( !*v13 )
    {
      a2[1] = (int)&unk_9F3D8;
      goto LABEL_30;
    }
    v29 = _strdup((const char *)v13);
    if ( !v29 )
      sub_7E624((const char *)v13);
    v30 = a2[2];
    a2[1] = (int)v29;
    a2[2] = v30 | 0x40;
    goto LABEL_30;
  }
  return result;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B8168: using guessed type int dword_B8168;
// 107334: using guessed type int dword_107334;
// 1073B8: using guessed type int dword_1073B8;

//----- (000862F0) --------------------------------------------------------
void __fastcall sub_862F0(int a1, char *s)
{
  int v3; // r6
  char *v5; // r0
  char *v6; // r8
  int v7[4]; // [sp+Ch] [bp-18h] BYREF

  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = v3 & 0xFFFFFFFB;
  v7[0] = 0;
  v7[1] = 0;
  v7[3] = 0;
  v7[2] = 1;
  v5 = _strdup(s);
  v6 = v5;
  if ( !v5 )
    sub_7E624(s);
  sub_85F40(a1, v7, v5, 0, 0);
  free(v6);
  *(_DWORD *)(a1 + 12) = v3;
}

//----- (0008639C) --------------------------------------------------------
int __fastcall sub_8639C(unsigned int a1, int a2)
{
  bool v2; // cc
  int result; // r0
  int v5; // r3
  char *v6; // r8
  unsigned int v7; // r3
  void **v8[2]; // [sp+4h] [bp-14h] BYREF
  int v9; // [sp+Ch] [bp-Ch]
  int v10; // [sp+10h] [bp-8h]

  v2 = a1 > 0xF;
  result = 2;
  v8[0] = 0;
  v8[1] = 0;
  v10 = 0;
  v9 = 2;
  if ( v2 )
  {
    v5 = *(_DWORD *)(a2 + 16);
    if ( (v5 & 8) == 0 )
    {
      v6 = *(char **)(a2 + 24);
      if ( (v5 & 0x8000) == 0 )
        v9 = 4;
      if ( (*(_DWORD *)(a1 + 12) & 0x40000) == 0
        || sub_85A98(a1, v6, (int *)v8)
        || (result = sub_7E3DC((_DWORD *)a1, v8)) != 0 )
      {
        fprintf(stderr, off_B84D0[0], *(_DWORD *)(a1 + 28), v6);
        (*(void (__fastcall **)(unsigned int, int))(a1 + 84))(a1, 1);
        exit(1);
      }
      v7 = (unsigned int)&loc_20020 & v9;
      if ( (*(_DWORD *)(a1 + 12) & 0x8000) == 0 )
      {
        if ( v7 && (v9 & 0x40020) != 0x20 && (v9 & 0x400020) != 0x400000 && (~v9 & 0x800020) != 0 )
          return result;
        return sub_7DC70(a1, v8);
      }
      if ( v7 == 0x20000 || (~v9 & 0x40020) == 0 )
        return sub_7DC70(a1, v8);
    }
  }
  return result;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B84D0: using guessed type char *off_B84D0[77];

//----- (00086524) --------------------------------------------------------
int *__fastcall sub_86524(int *result, int a2)
{
  int v2; // r4
  unsigned __int8 *v3; // r7
  unsigned int v4; // r2
  int v5; // r1
  _DWORD *v6; // r7
  int v7; // r5
  _DWORD *v8[3]; // [sp+4h] [bp-14h] BYREF
  int v9; // [sp+10h] [bp-8h] BYREF

  v8[0] = 0;
  v8[1] = 0;
  v9 = 0;
  v8[2] = (_DWORD *)&byte_4;
  if ( (unsigned int)result > 0xF && !byte_1073F0 )
  {
    v2 = (int)result;
    if ( *result < 0x20000 || !result[30] )
      sub_7CEC0((int)off_B8484[0]);
    v3 = *(unsigned __int8 **)(a2 + 24);
    if ( !v3 || (v4 = *v3) == 0 )
    {
      fprintf(stderr, off_B84FC[0], result[7], *(_DWORD *)(a2 + 52));
      (*(void (__fastcall **)(int, int))(v2 + 84))(v2, 1);
      _assert_fail("0 == 1", "reset.c", 0x60u, "optionResetOpt");
    }
    v5 = v3[1];
    byte_1073F0 = 1;
    if ( v5 )
    {
      if ( sub_85A98((int)result, (char *)v3, (int *)v8) )
      {
        fprintf(stderr, off_B84CC[0], *(_DWORD *)(v2 + 24), v3);
        (*(void (__fastcall **)(int, int))(v2 + 84))(v2, 1);
        _assert_fail("0 == 1", "reset.c", 0x79u, "optionResetOpt");
      }
    }
    else
    {
      if ( v4 == 42 )
      {
        v6 = (_DWORD *)result[17];
        v7 = result[26];
        while ( 1 )
        {
          --v7;
          result = (int *)sub_7C2F0(v2, v6);
          if ( v7 <= 0 )
            break;
          v6 += 16;
        }
        byte_1073F0 = 0;
        return result;
      }
      if ( sub_7DFF0((int)result, v4, v8, &v9) )
      {
        fprintf(stderr, off_B84C8[0], *(_DWORD *)(v2 + 24), *v3);
        (*(void (__fastcall **)(int, int))(v2 + 84))(v2, 1);
        _assert_fail("0 == 1", "reset.c", 0x71u, "optionResetOpt");
      }
    }
    result = (int *)sub_7C2F0(v2, v8[0]);
    byte_1073F0 = 0;
  }
  return result;
}
// 4: using guessed type char byte_4;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8484: using guessed type char *off_B8484[96];
// B84C8: using guessed type char *off_B84C8[79];
// B84CC: using guessed type char *off_B84CC[78];
// B84FC: using guessed type char *off_B84FC[66];
// 1073F0: using guessed type char byte_1073F0;

//----- (000867CC) --------------------------------------------------------
int __fastcall sub_867CC(_DWORD *a1, int *a2)
{
  unsigned __int8 *v3; // r1
  _DWORD *v4; // r4
  unsigned int v5; // r1
  unsigned int v6; // r3
  int v7; // r0
  char *v8; // r1
  int v9; // t1
  __int16 v10; // r6
  int result; // r0

  v3 = (unsigned __int8 *)a1[5];
  v4 = a1;
  if ( v3 )
  {
    v5 = *v3;
    if ( v5 )
      return sub_7DFF0((int)a1, v5, a2, a2 + 3);
  }
  v6 = a1[4];
  if ( v6 >= a1[1] )
    return 1;
  v7 = a1[3];
  v8 = *(char **)(v4[2] + 4 * v6);
  v4[5] = v8;
  if ( (v7 & 3) != 0 )
  {
    v4[5] = v8 + 1;
    if ( *v8 == 45 && v8[1] )
    {
      v4[4] = v6 + 1;
      if ( v8[1] != 45 )
      {
        if ( (v7 & 2) == 0 )
          return sub_85A98((int)v4, ++v8, a2);
        v5 = (unsigned __int8)v8[1];
        a1 = v4;
        return sub_7DFF0((int)a1, v5, a2, a2 + 3);
      }
      v4[5] = v8 + 2;
      if ( v8[2] )
      {
        if ( (v7 & 1) == 0 )
        {
          fprintf(stderr, off_B84CC[0], v4[6], v8);
          return -1;
        }
        v8 += 2;
        return sub_85A98((int)v4, v8, a2);
      }
    }
    return 1;
  }
  v4[4] = v6 + 1;
  if ( *v8 != 45 )
    return sub_85A98((int)v4, v8, a2);
  do
    v9 = (unsigned __int8)*++v8;
  while ( v9 == 45 );
  v10 = *((_WORD *)v4 + 49);
  *((_WORD *)v4 + 49) = 0x8000;
  result = sub_85A98((int)v4, v8, a2);
  *((_WORD *)v4 + 49) = v10;
  return result;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B84CC: using guessed type char *off_B84CC[78];

//----- (000869AC) --------------------------------------------------------
int __fastcall sub_869AC(int a1)
{
  int v2; // r6
  int v3; // r7
  int v4; // r0
  void **v6[2]; // [sp+4h] [bp-18h] BYREF
  int v7; // [sp+Ch] [bp-10h]
  int v8; // [sp+10h] [bp-Ch]

  LOWORD(v3) = (unsigned __int16)&loc_20020;
  HIWORD(v3) = 64;
  while ( 1 )
  {
    v6[0] = 0;
    v6[1] = 0;
    v7 = 4;
    v8 = 0;
    v4 = sub_867CC((_DWORD *)a1, (int *)v6);
    if ( !v4 )
      v4 = sub_7F19C((_DWORD *)a1, v6);
    if ( v4 == -1 )
      break;
    if ( v4 == 1 )
      return 0;
    if ( (v7 & (unsigned int)&loc_20020) == 0 )
      goto LABEL_11;
    HIWORD(v2) = (unsigned int)&loc_40020 >> 16;
    LOWORD(v2) = (unsigned __int16)&loc_20020;
    if ( (v7 & v2) == 0x20 )
      goto LABEL_11;
    if ( (v7 & v3) == 0x400000 || (~v7 & 0x800020) == 0 )
    {
      --*(_WORD *)((char *)v6[0] + (unsigned int)&byte_9[5]);
LABEL_11:
      if ( sub_7DC70(a1, v6) )
        break;
    }
  }
  if ( (*(_DWORD *)(a1 + 12) & 4) != 0 )
    (*(void (__fastcall **)(int, int))(a1 + 84))(a1, 1);
  return -1;
}

//----- (00086AD8) --------------------------------------------------------
int __fastcall sub_86AD8(int a1)
{
  int v2; // r3
  int v3; // r5
  int v4; // r3
  void **v6[2]; // [sp+4h] [bp-14h] BYREF
  int v7; // [sp+Ch] [bp-Ch]
  int v8; // [sp+10h] [bp-8h]
  int v9; // [sp+14h] [bp-4h]

  *(_DWORD *)(a1 + 12) |= 0x8000u;
  v2 = _stack_chk_guard;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  v9 = v2;
  do
  {
    v6[0] = 0;
    v6[1] = 0;
    v8 = 0;
    v7 = 2;
    v3 = sub_867CC((_DWORD *)a1, (int *)v6);
    if ( !v3 )
      v3 = sub_7F19C((_DWORD *)a1, v6);
    if ( v3 == -1 )
      break;
    if ( v3 == 1 )
    {
      v4 = *(_DWORD *)(a1 + 12);
      v3 = 0;
      goto LABEL_11;
    }
  }
  while ( (v7 & (unsigned int)&loc_20020) != 0x20000 && ((unsigned int)&loc_40020 & ~v7) != 0 || !sub_7DC70(a1, v6) );
  v4 = *(_DWORD *)(a1 + 12);
  if ( (v4 & 4) != 0 )
  {
    (*(void (__fastcall **)(int, int))(a1 + 84))(a1, 1);
    v4 = *(_DWORD *)(a1 + 12);
  }
LABEL_11:
  *(_DWORD *)(a1 + 12) = v4 & 0xFFFF7FFF;
  return v3;
}

//----- (00086C00) --------------------------------------------------------
unsigned __int8 *__fastcall sub_86C00(int a1, char *a2)
{
  char *v4; // r6
  size_t v5; // r5
  char *v6; // r0
  unsigned __int8 *v7; // r4
  int v8; // t1
  unsigned int v9; // r1
  unsigned __int8 *result; // r0
  int v11; // r1
  unsigned __int8 *v12; // r3
  int v13; // t1
  int v14; // [sp+Ch] [bp-10h]

  v4 = (char *)malloc(0xAu);
  if ( !v4 )
    sub_C610(10);
  v5 = strlen(*(const char **)(a1 + 28));
  strcpy(v4, "<?program");
  while ( 1 )
  {
    v6 = (char *)dword_107334;
    v7 = (unsigned __int8 *)(a2 + 1);
    if ( !dword_107334 )
      v6 = sub_7E2F8(12);
    if ( v6[(unsigned __int8)a2[1]] )
    {
      do
        v8 = *++v7;
      while ( v6[v8] );
    }
    if ( !sub_859EC(v7, *(unsigned __int8 **)(a1 + 28), v5) )
    {
      v9 = v7[v5];
      if ( v9 <= 0x7F && (dword_9F184[v9] & 0x1000C01) != 0 )
        break;
    }
    a2 = strstr((const char *)v7, v4);
    if ( !a2 )
    {
      free(v4);
      return 0;
    }
  }
  v14 = v7[v5];
  free(v4);
  v11 = v14;
  v12 = &v7[v5 + 1];
  while ( v11 )
  {
    result = v12;
    if ( v11 == 62 )
      return result;
    v13 = *v12++;
    v11 = v13;
  }
  return 0;
}
// 18: using guessed type _UNKNOWN *off_18;
// 1C: using guessed type int dword_1C;
// 9F184: using guessed type _DWORD dword_9F184[1];
// 9FDED: using guessed type _UNKNOWN *off_9FDED;
// 107334: using guessed type int dword_107334;

//----- (00086D90) --------------------------------------------------------
char *__fastcall sub_86D90(int *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // r4
  char *result; // r0
  int v5; // r3
  int v6; // t1
  unsigned int v7; // r5
  char *v8; // r11
  int v9; // r6
  unsigned __int8 *v10; // r1
  int v11; // t1
  int v12; // r3
  unsigned int v13; // r3
  unsigned int v14; // t1
  unsigned int v15; // t1
  char *v16; // r0
  int v17; // r3
  int v18; // t1
  int v19; // t1
  _DWORD *i; // r3
  int v21; // r2
  int v22; // r1
  int v23; // r2

  v2 = a2;
  if ( a2 || (result = getenv("AUTOOPTS_USAGE"), (v2 = (unsigned __int8 *)result) != 0) )
  {
    result = (char *)dword_107334;
    if ( !dword_107334 )
      result = sub_7E2F8(12);
    v5 = *v2;
    if ( result[v5] )
    {
      do
      {
        v6 = *++v2;
        v5 = v6;
      }
      while ( result[v6] );
    }
    if ( v5 )
    {
      v7 = 0;
      while ( 1 )
      {
        v8 = (char *)&unk_B52E8;
        result = (char *)sub_859EC(v2, "gnu", 3);
        v9 = 0;
        if ( result )
          break;
LABEL_11:
        v12 = (int)*(&off_B5208 + 3 * v9 + 56);
        v14 = v2[v12];
        v2 += v12;
        v13 = v14;
        if ( v14 > 0x7F || (dword_9F184[v13] & 0xC13) == 0 )
          return result;
        v7 |= 1 << v9;
        result = (char *)dword_107334;
        if ( !dword_107334 )
        {
          result = sub_7E2F8(12);
          v13 = *v2;
        }
        if ( result[v13] )
        {
          do
          {
            v15 = *++v2;
            v13 = v15;
          }
          while ( result[v15] );
        }
        if ( !v13 )
        {
          if ( (v7 & 3) != 3 && (v7 & 0xC) != 0xC )
          {
            for ( i = &unk_B52E8; ; i += 3 )
            {
              if ( (v7 & 1) != 0 )
              {
                v21 = i[1];
                v22 = *a1;
                if ( (v21 & 1) != 0 )
                  v23 = v21 & v22;
                else
                  v23 = v21 | v22;
                *a1 = v23;
              }
              v7 >>= 1;
              if ( !v7 )
                break;
            }
          }
          return result;
        }
        if ( v13 == 44 )
        {
          v16 = (char *)dword_107334;
          if ( !dword_107334 )
            v16 = sub_7E2F8(12);
          v17 = *++v2;
          if ( v16[v17] )
          {
            do
            {
              v18 = *++v2;
              if ( !v16[v18] )
                break;
              v19 = *++v2;
            }
            while ( v16[v19] );
          }
        }
      }
      while ( ++v9 != 5 )
      {
        v10 = (unsigned __int8 *)*((_DWORD *)v8 + 5);
        v11 = *((_DWORD *)v8 + 3);
        v8 += 12;
        result = (char *)sub_859EC(v2, v10, v11);
        if ( !result )
          goto LABEL_11;
      }
    }
  }
  return result;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// B5208: using guessed type _UNKNOWN *off_B5208;
// 107334: using guessed type int dword_107334;

//----- (00087004) --------------------------------------------------------
char *__fastcall sub_87004(int a1, int a2)
{
  char *v3; // r0
  const char *v4; // r4
  int v5; // t1
  char *v6; // r0
  char *v7; // r7
  unsigned __int8 *v8; // r0
  unsigned __int8 *v9; // r8
  int v11; // [sp+4h] [bp-Ch]

  v3 = (char *)dword_107334;
  v4 = (const char *)(a2 + 1);
  if ( !dword_107334 )
  {
    v11 = a2;
    v3 = sub_7E2F8(12);
    a2 = v11;
  }
  if ( v3[*(unsigned __int8 *)(a2 + 1)] )
  {
    do
      v5 = *(unsigned __int8 *)++v4;
    while ( v3[v5] );
  }
  v6 = strchr(v4, 62);
  v7 = v6;
  if ( v6 )
  {
    v8 = (unsigned __int8 *)malloc(v6 - v4 + 1);
    v9 = v8;
    if ( !v8 )
      sub_C610(v7 - v4 + 1);
    memcpy(v8, v4, v7 - v4);
    v9[v7 - v4] = 0;
    sub_86D90((int *)(a1 + 12), v9);
    ++v7;
    free(v9);
  }
  return v7;
}
// 107334: using guessed type int dword_107334;

//----- (00087100) --------------------------------------------------------
int __fastcall sub_87100(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // r2
  int v3; // t1
  int v4; // r3
  int v5; // t1
  int v6; // r3

  do
  {
    while ( 1 )
    {
      v3 = *a1++;
      v2 = v3;
      v5 = *a2++;
      v4 = v5;
      if ( v2 == v5 )
        break;
      v6 = *((unsigned __int8 *)&dword_B8164 + v2 + 8) - *((unsigned __int8 *)&dword_B8164 + v4 + 8);
      if ( v6 || !v2 )
        return v6;
    }
  }
  while ( v2 );
  return 0;
}
// B8164: using guessed type int dword_B8164;

//----- (00087194) --------------------------------------------------------
char *__fastcall sub_87194(void ***a1, char *name, int a3, int a4)
{
  char *result; // r0
  unsigned __int8 *v8; // r1
  unsigned int v9; // r3
  void **v10; // r3
  unsigned int v11; // r3
  const char *v12; // r5
  void **v13; // r2
  void **v14; // r3
  char *v15; // r0
  void **v16; // r3

  result = getenv(name);
  a1[1] = (void **)result;
  if ( result )
  {
    v8 = (unsigned __int8 *)(*a1)[15];
    v9 = (unsigned int)(*a1)[4];
    a1[3] = 0;
    a1[2] = (void **)(v9 | 0x42);
    if ( v8 )
    {
      result = (char *)sub_87100((unsigned __int8 *)result, v8);
      if ( !result )
      {
        v14 = a1[2];
        a1[1] = 0;
        a1[2] = (void **)((unsigned int)v14 | 0x20);
        return (char *)sub_7DC70(a3, a1);
      }
    }
    if ( a4 == 1 )
    {
      v13 = a1[2];
      if ( ((unsigned int)v13 & 0x20020) != 0x20000 && (~(unsigned int)v13 & 0x40020) != 0 )
        return result;
    }
    else if ( a4 == 2 )
    {
      v10 = a1[2];
      if ( ((unsigned int)v10 & 0x20020) != 0
        && ((unsigned int)v10 & 0x40020) != 0x20
        && ((unsigned int)v10 & 0x400020) != 0x400000
        && (~(unsigned int)v10 & 0x800020) != 0 )
      {
        return result;
      }
    }
    v11 = (unsigned int)(*a1)[4];
    if ( (v11 & 0xF000) == 0 )
      goto LABEL_10;
    v12 = (const char *)a1[1];
    if ( *v12 )
    {
      v15 = _strdup((const char *)a1[1]);
      if ( !v15 )
        sub_7E624(v12);
      v16 = a1[2];
      a1[1] = (void **)v15;
      a1[2] = (void **)((unsigned int)v16 | 0x40);
      return (char *)sub_7DC70(a3, a1);
    }
    if ( (v11 & 0x10000) != 0 )
    {
LABEL_10:
      a1[1] = 0;
      return (char *)sub_7DC70(a3, a1);
    }
  }
  return result;
}

//----- (00087354) --------------------------------------------------------
unsigned int __fastcall sub_87354(unsigned int result, unsigned int a2, int a3)
{
  int v3; // r3
  char *v4; // r2
  unsigned int v6; // r12
  char *v7; // r3
  bool v8; // cc

  if ( a3 )
  {
    v6 = result - a2;
    v7 = (char *)&dword_B8164 + result + 7;
    do
    {
      *++v7 = a2;
      result = ++a2 + v6;
      v8 = a2 > 0xFF;
      if ( a2 <= 0xFF )
        v8 = result > 0xFF;
      if ( v8 )
        break;
      --a3;
    }
    while ( a3 > 0 );
  }
  else
  {
    v3 = 255;
    v4 = aStr;
    do
      *--v4 = v3;
    while ( v3-- != 0 );
  }
  return result;
}
// B8164: using guessed type int dword_B8164;

//----- (00087404) --------------------------------------------------------
char *__fastcall sub_87404(char *result)
{
  char v1; // r2
  int v2; // r3
  int v3; // t1

  if ( result )
  {
    v1 = *result;
    if ( *result )
    {
      v2 = (unsigned __int8)*result;
      do
      {
        *((_BYTE *)&dword_B8164 + v2 + 8) = v1;
        v3 = (unsigned __int8)*++result;
        v2 = v3;
      }
      while ( v3 );
    }
  }
  return result;
}
// B8164: using guessed type int dword_B8164;

//----- (00087480) --------------------------------------------------------
int __fastcall sub_87480(int *a1, char *s)
{
  int v3; // r2
  char *v6; // r0
  bool v7; // zf
  char *v8; // r0
  char *v9; // r0
  void (*v10)(void); // r3
  const char *v11; // r0

  if ( a1 )
  {
    v3 = a1[3];
    byte_1072C4 = (v3 & 0x200000) != 0;
    if ( (v3 & 0x2000) != 0 )
    {
      v10 = (void (*)(void))a1[22];
      if ( v10 )
      {
        if ( option_xlateable_txt )
        {
          if ( (v3 & 0x30000) == 0x20000 )
            a1[3] = v3 | 0x10000;
          v10();
        }
      }
    }
    if ( (unsigned int)(*a1 - 102400) > 0x10001 )
    {
      fprintf(stderr, off_B8470[0], s, *a1 >> 12, ((unsigned int)*a1 >> 7) & 0x1F, *a1 & 0x7F);
      if ( *a1 <= 167937 )
        v11 = off_B8478[0];
      else
        v11 = off_B846C[0];
      fputs(v11, stderr);
      fwrite("41:0:16\n", 8u, 1u, stderr);
      return -1;
    }
    else if ( a1[7] )
    {
      return 0;
    }
    else
    {
      v6 = strrchr(s, 47);
      v7 = v6 == 0;
      if ( v6 )
        ++v6;
      else
        a1[7] = (int)s;
      if ( !v7 )
        a1[7] = (int)v6;
      v8 = getenv("PATH");
      v9 = sub_7F9CC(v8, s);
      if ( !v9 )
        v9 = s;
      a1[6] = (int)v9;
      sub_87404("-_^");
      return 0;
    }
  }
  else
  {
    fputs(off_B8468[0], stderr);
    return -1;
  }
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8450: using guessed type int option_xlateable_txt;
// B8468: using guessed type char *off_B8468[103];
// B846C: using guessed type char *off_B846C[102];
// B8470: using guessed type char *off_B8470[101];
// B8478: using guessed type char *off_B8478[99];
// 1072C4: using guessed type char byte_1072C4;

//----- (00087650) --------------------------------------------------------
_BYTE *__fastcall sub_87650(_BYTE *result, int a2)
{
  _BYTE *v2; // r1
  int v3; // t1

  v2 = (_BYTE *)(a2 - 1);
  do
  {
    v3 = (unsigned __int8)*++v2;
    *result++ = *((_BYTE *)&dword_B8164 + v3 + 8);
  }
  while ( *v2 );
  return result;
}
// B8164: using guessed type int dword_B8164;

//----- (000876C0) --------------------------------------------------------
int __fastcall sub_876C0(int a1, int a2, int a3, int *a4)
{
  int v5; // r12
  int v6; // r1
  int v7; // r0
  int v8; // r2
  int v9; // r5
  int v11; // r0
  int v12; // r1
  int v13; // r3
  int v14; // r0
  int v15; // r3
  int v16; // r3
  int v17; // r0
  int v18; // r0
  int v19; // r5
  int v20; // r0
  int v21; // r3
  int v22; // r0
  int *v23; // r0
  int *v24; // r0
  int v25; // [sp+4h] [bp-7Ch]
  char v26[16]; // [sp+10h] [bp-70h] BYREF
  int v27; // [sp+20h] [bp-60h]
  int v28; // [sp+40h] [bp-40h]
  int v29; // [sp+7Ch] [bp-4h]

  v5 = a2 & 2;
  a4[6] = a2;
  a4[7] = a3;
  v6 = _stack_chk_guard;
  a4[3] = -1;
  *a4 = 0;
  v29 = v6;
  a4[1] = 0;
  a4[2] = 0;
  a4[4] = 0;
  a4[5] = 0;
  if ( v5 )
  {
    if ( (a3 & 3) == 1 )
    {
      if ( (a3 & 1) != 0 )
        v5 = 2;
      else
        v5 = 130;
    }
    else if ( (a3 & 1) != 0 )
    {
      v5 = 0;
    }
    else
    {
      v5 = 128;
    }
  }
  v7 = open64(a1, v5, a3);
  a4[3] = v7;
  if ( v7 < 0 )
  {
    v9 = *_errno_location();
    a4[3] = -1;
    a4[5] = v9;
    goto LABEL_21;
  }
  if ( _fxstat64(3, v7, v26) )
  {
    v21 = *_errno_location();
    v22 = a4[3];
    a4[5] = v21;
    close(v22);
    goto LABEL_10;
  }
  if ( (v27 & 0xF000) != 0x8000 )
  {
    *_errno_location() = 22;
    a4[5] = 22;
    close(a4[3]);
LABEL_10:
    v9 = a4[5];
    if ( v9 )
      return -1;
    goto LABEL_12;
  }
  v8 = a4[3];
  a4[1] = v28;
  if ( v8 != -1 )
    goto LABEL_10;
  v24 = _errno_location();
  v9 = *v24;
  a4[5] = *v24;
LABEL_21:
  if ( v9 )
    return -1;
LABEL_12:
  v11 = sysconf(30);
  v12 = a4[1];
  v13 = -v11;
  v14 = v11 + v12;
  v15 = v13 & v14;
  a4[2] = v15;
  if ( v14 == v15 )
  {
    v17 = ((int (__fastcall *)(int, int, int, int, int))mmap64)(v9, v14, 3, 34, -1);
    if ( v17 == -1 )
      goto LABEL_30;
    v12 = a4[1];
    v16 = a4[7] | 0x10;
    a4[7] = v16;
  }
  else
  {
    v16 = a4[7];
    v17 = v9;
  }
  v18 = mmap64(v17, v12, a4[6], v16, a4[3], v25, 0, 0);
  *a4 = v18;
  if ( v18 != -1 )
  {
    v19 = a4[5];
    goto LABEL_16;
  }
LABEL_30:
  v23 = _errno_location();
  v19 = *v23;
  a4[5] = *v23;
LABEL_16:
  if ( !v19 )
    return *a4;
  v20 = a4[3];
  if ( v20 != -1 )
  {
    close(v20);
    v19 = a4[5];
    a4[3] = -1;
  }
  *_errno_location() = v19;
  *a4 = -1;
  return -1;
}
// 877D8: variable 'v25' is possibly undefined
// B6C8: using guessed type int __fastcall _fxstat64(_DWORD, _DWORD, _DWORD);
// BAA0: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// BC50: using guessed type int __fastcall mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0008791C) --------------------------------------------------------
int __fastcall sub_8791C(int a1)
{
  int *v2; // r6
  void *v3; // r0
  int v4; // r3
  int result; // r0

  v2 = _errno_location();
  v3 = *(void **)a1;
  *v2 = 0;
  munmap(v3, *(_DWORD *)(a1 + 8));
  v4 = *(_DWORD *)(a1 + 12);
  result = *v2;
  *(_DWORD *)(a1 + 20) = *v2;
  if ( v4 != -1 )
  {
    close(v4);
    result = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 12) = -1;
  }
  return result;
}

//----- (000879A8) --------------------------------------------------------
int __fastcall sub_879A8(int a1, int a2, int a3)
{
  int v4; // r11
  int v6; // lr
  int result; // r0
  int v8; // r3
  char *v9; // r4
  char *v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // t1
  char *v13; // r0
  const char *v14; // r5
  size_t v15; // r6
  unsigned int v16; // r3
  char *v17; // r0
  char *v18; // r0
  char *v19; // r5
  int v20; // t1
  unsigned int v21; // r3
  const char *v22; // r7
  const char *v23; // r6
  size_t v24; // r0
  char *v25; // r0
  char *v26; // r4
  char *v27; // r7
  char *v28; // r2
  size_t v29; // r0
  char *v30; // r3
  int v31; // t1
  int v32; // r3
  char *v33; // r5
  char *v34; // r6
  char *v35; // r0
  int v36; // t1
  char *v37; // r0
  int v38; // r3
  int v39; // t1
  bool v40; // zf
  unsigned int v41; // r2
  char *v42; // r12
  char *v43; // r2
  unsigned __int8 *v44; // r7
  char *v45; // r0
  char *v46; // r2
  char *v47; // r0
  const char *v48; // r5
  size_t v49; // r7
  int v50; // r2
  size_t v51; // r7
  unsigned int v52; // r12
  char *v53; // r1
  size_t v54; // r5
  size_t v55; // r5
  unsigned int v56; // r0
  char *v57; // r0
  int v58; // t1
  int v59; // t1
  char *v60; // r0
  const char *v61; // r3
  int v62; // t1
  const char *v63; // r0
  int v64; // r3
  int v65; // r3
  char *v66; // r2
  char *v67; // r5
  char *v68; // r7
  char *v69; // r11
  int v70; // r3
  char v71; // r0
  int v72; // r1
  int v73; // r2
  unsigned int v74; // r3
  int v75; // r2
  int v76; // r2
  unsigned int v77; // r0
  size_t v78; // r5
  int v79; // r6
  char **v80; // r4
  const char *v81; // r1
  unsigned int v82; // r3
  int v83; // [sp+Ch] [bp-B8h]
  int v84; // [sp+14h] [bp-B0h]
  char *v85; // [sp+24h] [bp-A0h]
  int v86; // [sp+28h] [bp-9Ch]
  int v87; // [sp+28h] [bp-9Ch]
  char *v88; // [sp+28h] [bp-9Ch]
  int v89; // [sp+28h] [bp-9Ch]
  int v90; // [sp+2Ch] [bp-98h]
  char *v91; // [sp+2Ch] [bp-98h]
  int v92; // [sp+38h] [bp-8Ch] BYREF
  char *nptr; // [sp+3Ch] [bp-88h] BYREF
  int v94[2]; // [sp+40h] [bp-84h] BYREF
  int v95; // [sp+48h] [bp-7Ch]
  int v96; // [sp+4Ch] [bp-78h]
  int v97[8]; // [sp+50h] [bp-74h] BYREF
  int v98[3]; // [sp+70h] [bp-54h] BYREF
  char s[64]; // [sp+7Ch] [bp-48h] BYREF

  v4 = 2;
  v84 = a3;
  v95 = 2;
  v94[0] = 0;
  v94[1] = 0;
  v6 = *(_DWORD *)(a1 + 12);
  v96 = 0;
  v83 = v6;
  result = sub_876C0(a2, 3, 2, v97);
  if ( result != -1 )
  {
    v8 = *(_DWORD *)(a1 + 12);
    if ( !a3 )
      v4 = 4;
    v9 = (char *)result;
    *(_DWORD *)(a1 + 12) = v8 & 0xFFFFFFFB;
    if ( !a3 )
      v84 = 1;
    if ( (v8 & 0x80000) == 0 )
      v4 = 1;
    v10 = (char *)dword_107334;
    v95 = v4;
    if ( dword_107334 )
      goto LABEL_9;
LABEL_22:
    v10 = sub_7E2F8(12);
    while ( 1 )
    {
LABEL_9:
      v11 = (unsigned __int8)*v9;
      if ( v10[v11] )
      {
        do
        {
          v12 = (unsigned __int8)*++v9;
          v11 = v12;
        }
        while ( v10[v12] );
      }
      if ( v11 <= 0x7F && (dword_9F184[v11] & 0x180040) != 0 )
        break;
      if ( v11 == 60 )
      {
        v16 = (unsigned __int8)v9[1];
        if ( v16 > 0x7F || (dword_9F184[v16] & 0x180040) == 0 )
        {
          if ( v16 == 47 )
          {
            v47 = strchr(v9 + 2, 62);
            v9 = v47 + 1;
            if ( !v47 )
              goto LABEL_16;
            goto LABEL_20;
          }
          if ( v16 != 63 )
          {
            if ( v16 != 33 )
              goto LABEL_16;
            v17 = strstr(v9, "-->");
            if ( !v17 )
              goto LABEL_16;
            v9 = v17 + 3;
            goto LABEL_20;
          }
          v48 = (const char *)dword_1073F4;
          if ( dword_1073F4 )
          {
            v49 = strlen((const char *)dword_1073F4);
          }
          else
          {
            v49 = 7;
            v48 = (const char *)&off_9FDED;
            dword_1073F4 = (int)&off_9FDED;
            dword_1073F8 = (int)"auto-options";
          }
          v50 = strncmp(v9 + 2, v48, v49);
          if ( v50
            || (v51 = v49 + 2, v52 = (unsigned __int8)v9[v51], v53 = &v9[v51], v52 <= 0x7F)
            && (dword_9F184[v52] & 0x3B0060) != 0 )
          {
            v54 = strlen((const char *)dword_1073F8);
            if ( strncmp(v9 + 2, (const char *)dword_1073F8, v54)
              || (v55 = v54 + 2, v56 = (unsigned __int8)v9[v55], v53 = &v9[v55], v56 <= 0x7F)
              && (dword_9F184[v56] & 0x3B0060) != 0 )
            {
              v57 = strchr(v9 + 2, 62);
              if ( !v57 )
                goto LABEL_16;
              goto LABEL_98;
            }
            v50 = 1;
          }
          v9 = (char *)((int (__fastcall *)(int, char *))*(&off_B5208 + v50 + 95))(a1, v53);
          goto LABEL_20;
        }
        v85 = v9 + 1;
        v18 = (char *)dword_107374;
        v92 = dword_B8168;
        if ( !dword_107374 )
          v18 = sub_7E2F8(28);
        v19 = v9 + 1;
        if ( v18[(unsigned __int8)v9[1]] )
        {
          do
            v20 = (unsigned __int8)*++v19;
          while ( v18[v20] );
        }
        v98[0] = 1;
        v21 = (unsigned __int8)*v19;
        if ( v21 != 32 )
        {
          if ( v21 > 0x20 )
          {
            if ( v21 != 47 )
            {
              if ( v21 == 62 )
              {
                v22 = v19;
                goto LABEL_44;
              }
LABEL_121:
              v57 = strchr(v19, 62);
              if ( !v57 )
                goto LABEL_16;
LABEL_98:
              v9 = v57 + 1;
              goto LABEL_20;
            }
LABEL_111:
            if ( v19[1] != 62 )
              goto LABEL_16;
            *v19 = 0;
            v9 = v19 + 2;
            sub_85F40(a1, v94, v85, v84, v92);
            goto LABEL_20;
          }
          if ( v21 != 9 )
            goto LABEL_121;
        }
        v60 = (char *)dword_107334;
        if ( !dword_107334 )
        {
          v60 = sub_7E2F8(12);
          v21 = (unsigned __int8)*v19;
        }
        v40 = v60[v21] == 0;
        v61 = v19;
        if ( !v40 )
        {
          do
            v62 = *(unsigned __int8 *)++v61;
          while ( v60[v62] );
        }
        v63 = sub_813A4(v61, &v92, v98);
        v22 = v63;
        if ( !v63 )
        {
LABEL_16:
          result = sub_8791C((int)v97);
          *(_DWORD *)(a1 + 12) = v83;
          return result;
        }
        v64 = *(unsigned __int8 *)v63;
        if ( v64 != 62 )
        {
          if ( v64 != 47 )
            goto LABEL_16;
          v19 = (char *)v63;
          goto LABEL_111;
        }
LABEL_44:
        *v19 = 0;
        v23 = v22 + 1;
        v24 = strlen(v85);
        v90 = v92;
        if ( v24 + 4 <= 0x3F )
        {
          v87 = sprintf(s, "</%s>", v85);
          *((_BYTE *)v22 + 1) = 32;
          v27 = strstr(v22 + 1, s);
        }
        else
        {
          v86 = v24 + 4;
          v25 = (char *)malloc(v24 + 4);
          v26 = v25;
          if ( !v25 )
            sub_C610(v86);
          v87 = sprintf(v25, "</%s>", v85, v86);
          *((_BYTE *)v22 + 1) = 32;
          v27 = strstr(v22 + 1, v26);
          free(v26);
        }
        if ( !v27 )
          goto LABEL_16;
        v9 = &v27[v87];
        if ( v90 != 1 )
        {
          v28 = (char *)dword_107334;
          if ( !dword_107334 )
            v28 = sub_7E2F8(12);
          if ( v23 < v27 || (v88 = v28, v29 = strlen(v23), v27 = (char *)&v23[v29], v28 = v88, v23 < &v23[v29]) )
          {
            if ( v28[(unsigned __int8)*(v27 - 1)] )
            {
              v30 = v27 - 1;
              do
              {
                v27 = v30;
                if ( v23 >= v30 )
                  break;
                v31 = (unsigned __int8)*--v30;
              }
              while ( v28[v31] );
            }
          }
        }
        *v27 = 0;
        if ( !v9 )
          goto LABEL_16;
        memset(v19, 32, v23 - v19);
        v32 = v92;
        if ( v98[0] != 1 || v92 )
          goto LABEL_59;
        s[2] = 0;
        v67 = (char *)v23;
        v68 = (char *)v23;
        v89 = v4;
        v69 = (char *)(v23 + 1);
        v91 = v9;
        v70 = *(unsigned __int8 *)v23;
        if ( v70 == 37 )
          goto LABEL_135;
LABEL_130:
        if ( v70 != 38 )
        {
          if ( v70 )
          {
            v71 = v70;
            v67 = v69;
            goto LABEL_133;
          }
          v4 = v89;
          v9 = v91;
          *v68 = 0;
LABEL_142:
          v32 = v92;
LABEL_59:
          sub_85F40(a1, v94, v85, v84, v32);
          goto LABEL_20;
        }
        nptr = v69;
        v74 = (unsigned __int8)v67[1];
        if ( v74 == 35 )
        {
          nptr = v67 + 2;
          goto LABEL_147;
        }
        if ( v74 <= 0x7F && (dword_9F184[v74] & 0x30000) != 0 )
        {
LABEL_147:
          v75 = (unsigned __int8)*nptr;
          if ( v75 == 88 || v75 == 120 )
          {
            v76 = 16;
            ++nptr;
          }
          else if ( v75 == 48 )
          {
            if ( nptr[1] == 48 )
              v76 = 16;
            else
              v76 = 10;
          }
          else
          {
            v76 = 10;
          }
          v77 = strtoul(nptr, &nptr, v76);
          if ( *nptr != 59 || v77 > 0x7F )
          {
LABEL_155:
            v4 = v89;
            v9 = v91;
            *v68 = 0;
            goto LABEL_142;
          }
          v67 = nptr + 1;
          v82 = v77;
        }
        else
        {
          v78 = 4;
          v79 = 0;
          v80 = &off_B5324;
          v81 = "amp;";
          while ( strncmp(v69, v81, v78) )
          {
            if ( ++v79 == 12 )
              goto LABEL_155;
            v81 = v80[2];
            v80 += 2;
            v78 = *((unsigned __int16 *)v80 + 2);
          }
          v67 = &v69[v78];
          v82 = *((__int16 *)&off_B5324 + 4 * v79 + 3);
        }
        *v68 = v82;
        if ( !v82 )
        {
          v4 = v89;
          v9 = v91;
          goto LABEL_142;
        }
        while ( 1 )
        {
          v70 = (unsigned __int8)*v67;
          ++v68;
          v69 = v67 + 1;
          if ( v70 != 37 )
            goto LABEL_130;
LABEL_135:
          s[0] = v67[1];
          v72 = (unsigned __int8)s[0];
          v73 = (unsigned __int8)v67[2];
          if ( !s[0] )
            v72 = 1;
          s[1] = v67[2];
          if ( s[0] )
            v72 = v73 == 0;
          if ( v72 )
            goto LABEL_155;
          v67 += 3;
          v71 = strtoul(s, 0, 16);
LABEL_133:
          *v68 = v71;
        }
      }
      if ( v11 != 91 )
      {
        if ( v11 != 35 )
          goto LABEL_16;
        v13 = v9 + 1;
LABEL_19:
        v9 = strchr(v13, 10);
        goto LABEL_20;
      }
      v14 = *(const char **)(a1 + 32);
      v15 = strlen(v14);
      if ( strncmp(v9 + 1, v14, v15) || v9[v15 + 1] != 93 )
      {
        if ( v15 > 0x10 )
          goto LABEL_16;
        sprintf(s, "[%s]", v14);
        v13 = strstr(v9, s);
        if ( !v13 )
          goto LABEL_16;
        goto LABEL_19;
      }
      v9 = strchr(&v9[v15 + 2], 10);
LABEL_20:
      if ( !v9 )
        goto LABEL_16;
      v10 = (char *)dword_107334;
      v95 = v4;
      if ( !dword_107334 )
        goto LABEL_22;
    }
    v33 = v9 + 1;
    v34 = strchr(v9 + 1, 10);
    if ( !v34 )
    {
      v9 = &v33[strlen(v9 + 1)];
      goto LABEL_20;
    }
    v35 = (char *)dword_107374;
    if ( !dword_107374 )
      v35 = sub_7E2F8(28);
    if ( v35[(unsigned __int8)v9[1]] )
    {
      do
        v36 = (unsigned __int8)*++v33;
      while ( v35[v36] );
    }
    v37 = (char *)dword_107334;
    if ( !dword_107334 )
      v37 = sub_7E2F8(12);
    v38 = (unsigned __int8)*v33;
    if ( v37[v38] )
    {
      do
      {
        v39 = (unsigned __int8)*++v33;
        v38 = v39;
      }
      while ( v37[v39] );
    }
    if ( v34 >= v33 )
    {
      v40 = v38 == 58;
      if ( v38 != 58 )
        v40 = v38 == 61;
      if ( !v40 )
      {
        v41 = (unsigned __int8)*(v33 - 1);
        if ( v41 > 0x7F || (dword_9F184[v41] & 0xC01) == 0 )
          goto LABEL_16;
        goto LABEL_77;
      }
      v44 = (unsigned __int8 *)(v33 + 1);
      v45 = (char *)dword_107334;
      if ( !dword_107334 )
        v45 = sub_7E2F8(12);
      if ( v45[(unsigned __int8)v33[1]] )
      {
        do
        {
          v58 = *++v44;
          if ( !v45[v58] )
            break;
          v59 = *++v44;
        }
        while ( v45[v59] );
      }
      if ( v34 >= (char *)v44 )
      {
LABEL_77:
        if ( *(v34 - 1) != 92 )
        {
          v42 = v34 + 1;
          *v34 = 0;
          goto LABEL_80;
        }
        v65 = (unsigned __int8)*v34;
        v66 = v34 - 1;
        v42 = v34 + 1;
        if ( v65 == 10 )
          goto LABEL_119;
        while ( 1 )
        {
          if ( v65 == 92 )
          {
            if ( v34[1] == 10 )
            {
              v42 = v34 + 2;
              LOBYTE(v65) = 10;
            }
          }
          else if ( !v65 )
          {
            v42 = 0;
LABEL_119:
            *v66 = 0;
LABEL_80:
            v43 = v9;
            v9 = v42;
            sub_85F40(a1, v94, v43, v84, 1);
            goto LABEL_20;
          }
          v34 = v42;
          *v66++ = v65;
          v65 = (unsigned __int8)*v42++;
          if ( v65 == 10 )
            goto LABEL_119;
        }
      }
    }
    *v34 = 0;
    v46 = v9;
    v9 = v34 + 1;
    sub_85F40(a1, v94, v46, v84, 1);
    goto LABEL_20;
  }
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// 9F184: using guessed type _DWORD dword_9F184[1];
// 9FDED: using guessed type _UNKNOWN *off_9FDED;
// B5208: using guessed type _UNKNOWN *off_B5208;
// B5324: using guessed type char *off_B5324;
// B8168: using guessed type int dword_B8168;
// 107334: using guessed type int dword_107334;
// 107374: using guessed type int dword_107374;
// 1073F4: using guessed type int dword_1073F4;
// 1073F8: using guessed type int dword_1073F8;

//----- (000884D4) --------------------------------------------------------
int __fastcall sub_884D4(int result)
{
  int v1; // r3
  int v2; // r4
  int v3; // r5
  int v4; // r10
  int v5; // r2
  int v6; // t1
  int v7; // r6
  const char *v8; // r8
  size_t v9; // r12
  char *v10; // r0
  size_t v11; // [sp+4h] [bp-1078h]
  _BYTE v12[16]; // [sp+8h] [bp-1074h] BYREF
  __int16 v13; // [sp+18h] [bp-1064h]
  char v14[8]; // [sp+70h] [bp-100Ch] BYREF

  v1 = *(_DWORD *)(result + 52);
  if ( v1 )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = result;
    v4 = *(_DWORD *)(result + 12);
    *(_DWORD *)(result + 12) = v4 & 0xFFFFFFFB;
    if ( v2 )
    {
      v5 = v1 + 4;
      v2 = 0;
      do
      {
        v6 = *(_DWORD *)(v5 + 4);
        v5 += 4;
        ++v2;
      }
      while ( v6 );
    }
    v7 = -1;
    while ( 1 )
    {
      if ( v2 == -1 )
      {
        v7 = 1;
        v2 = 0;
      }
      else
      {
        v1 += 4 * v2;
      }
      if ( !*(_DWORD *)v1 )
      {
        *(_DWORD *)(v3 + 12) = v4;
        return result;
      }
      result = sub_83F7C(v14, 0x1001u, *(char **)v1, *(const char **)(v3 + 24));
      if ( !result )
        break;
      result = _xstat64(3, v14, v12);
      if ( result )
        break;
      if ( (v13 & 0xF000) == 0x4000 )
      {
        v8 = *(const char **)(v3 + 36);
        v11 = strlen(v14);
        result = strlen(v8);
        v9 = result + 1;
        if ( v11 + 1 + result + 1 > 0x1000 )
          break;
        v10 = &v14[v11];
        if ( v14[v11 - 1] != 47 )
        {
          ++v10;
          v14[v11] = 47;
        }
        memcpy(v10, v8, v9);
      }
      result = sub_879A8(v3, (int)v14, v7);
      if ( ((v7 == -1) & (*(_DWORD *)(*(_DWORD *)(v3 + 68) + (*(unsigned __int16 *)(v3 + 94) << 6) + 80) >> 5)) != 0 )
        v7 = 1;
      else
        v2 += v7;
LABEL_21:
      v1 = *(_DWORD *)(v3 + 52);
    }
    v2 += v7;
    goto LABEL_21;
  }
  return result;
}
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);

//----- (00088688) --------------------------------------------------------
int __fastcall sub_88688(int *a1, char *a2)
{
  if ( sub_87480(a1, a2) )
    return -1;
  a1[7] = (int)a2;
  sub_884D4((int)a1);
  return 0;
}

//----- (000886F8) --------------------------------------------------------
unsigned int __fastcall optionLoadOpt(unsigned int result, int a2)
{
  int v3; // r5
  _WORD v4[54]; // [sp+0h] [bp-70h] BYREF

  if ( result > 0xF && (*(_DWORD *)(a2 + 16) & 0x28) == 0 )
  {
    v3 = result;
    result = _xstat64(3, *(_DWORD *)(a2 + 24), v4);
    if ( result )
    {
      if ( (*(_DWORD *)(v3 + 12) & 4) != 0 )
        sub_7CF18(*(_DWORD *)(v3 + 28), (int)"stat", *(_DWORD *)(a2 + 24));
    }
    else if ( (v4[8] & 0xF000) == 0x8000 )
    {
      return sub_879A8(v3, *(_DWORD *)(a2 + 24), 0);
    }
    else if ( (*(_DWORD *)(v3 + 12) & 4) != 0 )
    {
      *_errno_location() = 22;
      sub_7CF18(*(_DWORD *)(v3 + 28), (int)"stat", *(_DWORD *)(a2 + 24));
    }
  }
  return result;
}
// BC08: using guessed type int __fastcall _xstat64(_DWORD, _DWORD, _DWORD);

//----- (000887E4) --------------------------------------------------------
int **__fastcall sub_887E4(const char *a1)
{
  int v2; // r9
  int v3; // r0
  char *v4; // r6
  size_t v5; // r0
  int **v6; // r6
  int *v8; // r7
  int v9; // r5
  int v10[8]; // [sp+4h] [bp-28h] BYREF

  v2 = dword_B8168[0];
  v3 = sub_876C0((int)a1, 1, 2, v10);
  if ( v3 == -1 )
    return 0;
  v4 = (char *)v3;
  dword_B8168[0] = 0;
  v5 = strlen(a1);
  v6 = sub_82410(v4, a1, v5);
  if ( v6 )
  {
    sub_8791C((int)v10);
  }
  else
  {
    v8 = _errno_location();
    v9 = *v8;
    sub_8791C((int)v10);
    *v8 = v9;
  }
  dword_B8168[0] = v2;
  return v6;
}
// B8168: using guessed type int dword_B8168[65];

//----- (000888C4) --------------------------------------------------------
void __fastcall sub_888C4(unsigned int a1, int a2)
{
  bool v2; // cc
  int v5; // r8

  v2 = a2 != 0;
  if ( a2 )
    v2 = a1 > 0xF;
  if ( v2 && (*(_DWORD *)(a2 + 16) & 8) == 0 )
  {
    v5 = sub_80B6C(*(const char **)(a2 + 24));
    if ( v5 == -1 )
    {
      fprintf(stderr, off_B8514[0], *(_DWORD *)(a1 + 28), *(_DWORD *)(a2 + 24));
      if ( (*(_DWORD *)(a1 + 12) & 4) != 0 )
        (*(void (__fastcall **)(unsigned int, int))(a1 + 84))(a1, 1);
    }
    if ( (*(_DWORD *)(a2 + 16) & 0x40) != 0 )
    {
      free(*(void **)(a2 + 24));
      *(_DWORD *)(a2 + 16) &= ~0x40u;
    }
    *(_DWORD *)(a2 + 24) = v5;
  }
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8514: using guessed type char *off_B8514[60];

//----- (000889B4) --------------------------------------------------------
void __fastcall sub_889B4(unsigned int a1, int a2)
{
  sub_888C4(a1, a2);
  if ( *(_DWORD *)(a2 + 24) != -1 )
    *(_DWORD *)(a2 + 24) += time(0);
}

//----- (00088A20) --------------------------------------------------------
int *__fastcall sub_88A20(char *a1)
{
  char *v1; // r5
  char *v2; // r0
  int v3; // r3
  unsigned __int8 *v4; // r8
  int v5; // t1
  unsigned __int8 *v6; // r7
  int v7; // r6
  int v8; // r2
  unsigned __int8 *v9; // r9
  int v10; // r4
  char *v11; // r0
  int v12; // r3
  int v13; // t1
  int v14; // t1
  int v15; // r6
  int v16; // r8
  int *v17; // r0
  int *v18; // r7
  int v19; // r2
  int *v20; // r6
  unsigned int v21; // r3
  int v22; // r3
  unsigned __int8 *v23; // r2
  unsigned int v24; // r1
  char *v25; // r0
  char *v26; // r3
  int *v27; // r1
  unsigned int v28; // t1
  char *v29; // r1
  char v30; // r2
  int v31; // r0
  char *v32; // r0
  int v33; // r3
  int *v35; // r0
  char *v36; // [sp+8h] [bp-14h]
  char v37; // [sp+13h] [bp-9h] BYREF

  v1 = a1;
  if ( !a1 )
    goto LABEL_76;
  v2 = (char *)dword_107334;
  if ( !dword_107334 )
    v2 = sub_7E2F8(12);
  v3 = (unsigned __int8)*v1;
  v4 = (unsigned __int8 *)v1;
  if ( v2[v3] )
  {
    do
    {
      v5 = *++v4;
      v3 = v5;
    }
    while ( v2[v5] );
  }
  if ( !v3 )
  {
LABEL_76:
    v18 = 0;
    *_errno_location() = 2;
    return v18;
  }
  v6 = v4;
  v7 = 2;
  do
  {
    v8 = dword_107334;
    ++v7;
    v9 = v6 + 1;
    if ( dword_107334 )
    {
      v10 = v6[1];
      if ( !v6[1] )
      {
        ++v6;
        v11 = (char *)dword_107334;
        goto LABEL_16;
      }
      v11 = (char *)dword_107334;
      if ( *(_BYTE *)(dword_107334 + v10) )
        goto LABEL_15;
      do
      {
LABEL_13:
        v13 = *++v9;
        v12 = v13;
      }
      while ( v13 && !*(_BYTE *)(v8 + v12) );
      goto LABEL_14;
    }
    v32 = sub_7E2F8(12);
    v8 = (int)v32;
    if ( v6[1] )
    {
      v33 = (unsigned __int8)v32[v6[1]];
      v11 = (char *)dword_107334;
      if ( !v33 )
        goto LABEL_13;
    }
    else
    {
      v11 = (char *)dword_107334;
    }
LABEL_14:
    if ( v11 )
    {
LABEL_15:
      v10 = *v9;
      v6 = v9;
      goto LABEL_16;
    }
    v6 = v9;
    v11 = sub_7E2F8(12);
    v10 = *v9;
LABEL_16:
    if ( v11[v10] )
    {
      do
      {
        v14 = *++v6;
        v10 = v14;
      }
      while ( v11[v14] );
    }
  }
  while ( v10 );
  v15 = v7;
  v16 = v6 - v4 + v15 * 4 + 8;
  v17 = (int *)malloc(v16);
  v18 = v17;
  if ( !v17 )
    sub_C610(v16);
  v19 = 0;
  v20 = &v17[v15];
  v21 = (unsigned __int8)*v1;
  v17[1] = (int)v20;
LABEL_21:
  *v18 = v19 + 1;
  v18[v19 + 1] = (int)v20;
LABEL_22:
  while ( 2 )
  {
    while ( 2 )
    {
      if ( v21 <= 0x7F && (dword_9F184[v21] & 0xC01) != 0 )
        goto LABEL_35;
      if ( v21 == 34 )
      {
        v29 = v1 + 1;
        while ( 1 )
        {
          v1 = v29 + 1;
          v37 = *v29;
          v30 = v37;
          switch ( v37 )
          {
            case 34:
              if ( v29 == (char *)-1 )
                goto LABEL_74;
              v21 = (unsigned __int8)v29[1];
              if ( v21 > 0x7F || (dword_9F184[v21] & 0xC01) == 0 )
                goto LABEL_22;
LABEL_35:
              v25 = (char *)dword_107334;
              v26 = v1;
              v27 = v20;
              ++v1;
              if ( !dword_107334 )
              {
                v36 = v26;
                v25 = sub_7E2F8(12);
                v26 = v36;
                v27 = v20;
              }
              v21 = (unsigned __int8)v26[1];
              if ( v25[v21] )
              {
                do
                {
                  v28 = (unsigned __int8)*++v1;
                  v21 = v28;
                }
                while ( v25[v28] );
              }
              v20 = (int *)((char *)v20 + 1);
              *(_BYTE *)v27 = 0;
              if ( v21 )
              {
                v19 = *v18;
                goto LABEL_21;
              }
              goto LABEL_72;
            case 92:
              v31 = sub_81DDC(v1, &v37, 127);
              v30 = v37;
              v1 += v31;
              if ( v37 != 127 )
                goto LABEL_47;
              v29 = v1;
              break;
            case 0:
              goto LABEL_74;
            default:
LABEL_47:
              *(_BYTE *)v20 = v30;
              v29 = v1;
              v20 = (int *)((char *)v20 + 1);
              break;
          }
        }
      }
      if ( v21 != 39 )
      {
        if ( v21 )
        {
          *(_BYTE *)v20 = v21;
          v21 = (unsigned __int8)*++v1;
          v20 = (int *)((char *)v20 + 1);
          continue;
        }
        *(_BYTE *)v20 = 0;
LABEL_72:
        v18[*v18 + 1] = 0;
        return v18;
      }
      break;
    }
    v22 = (unsigned __int8)v1[1];
    v23 = (unsigned __int8 *)(v1 + 1);
    while ( 2 )
    {
      v1 = (char *)(v23 + 1);
      if ( v22 != 39 )
      {
LABEL_28:
        if ( v22 == 92 )
        {
          v24 = v23[1];
          if ( v24 == 13 )
          {
            v22 = v23[2];
            if ( v22 == 10 )
            {
              v22 = v23[3];
              v23 += 3;
            }
            else
            {
              v23 += 2;
            }
            continue;
          }
          if ( v24 > 0xD )
          {
            if ( v24 == 39 || v24 == 92 )
            {
              v22 = v23[2];
              v23 += 2;
              goto LABEL_31;
            }
          }
          else
          {
            if ( !v23[1] )
              goto LABEL_74;
            if ( v24 == 10 )
            {
              v22 = v23[2];
              v23 += 2;
              continue;
            }
          }
          v22 = v23[1];
          v23 = (unsigned __int8 *)v1;
          LOBYTE(v24) = 92;
        }
        else
        {
          if ( !v22 )
            goto LABEL_74;
          LOBYTE(v24) = v22;
          v22 = v23[1];
          v23 = (unsigned __int8 *)v1;
        }
LABEL_31:
        *(_BYTE *)v20 = v24;
        v1 = (char *)(v23 + 1);
        v20 = (int *)((char *)v20 + 1);
        if ( v22 == 39 )
          break;
        goto LABEL_28;
      }
      break;
    }
    if ( v1 )
    {
      v21 = (unsigned __int8)*v1;
      if ( v21 <= 0x7F && (dword_9F184[v21] & 0xC01) != 0 )
        goto LABEL_35;
      continue;
    }
    break;
  }
LABEL_74:
  v35 = v18;
  v18 = 0;
  free(v35);
  *_errno_location() = 22;
  return v18;
}
// 9F184: using guessed type _DWORD dword_9F184[1];
// 107334: using guessed type int dword_107334;

//----- (00088E84) --------------------------------------------------------
unsigned int __fastcall sub_88E84(unsigned int result, int a2)
{
  int v3; // r5
  char *v4; // r0
  int *v5; // r0
  int *v6; // r4
  int v7; // r7
  __int64 v8; // r10
  int v9; // r3
  int v10; // r7
  const char *v11; // r3
  int v12; // r4
  bool v13; // cc
  unsigned int v14; // r7
  void **v15; // r11
  int v16; // r3
  int v17; // r3
  const char *v18; // r4
  char *dest; // [sp+4h] [bp-A0h]
  void **v20[4]; // [sp+Ch] [bp-98h] BYREF
  char v21[128]; // [sp+1Ch] [bp-88h] BYREF

  if ( (*(_DWORD *)(result + 12) & 0x100) != 0 )
  {
    v3 = result;
    v4 = getenv(*(const char **)(result + 32));
    if ( v4 )
    {
      v5 = sub_88A20(v4);
      v6 = v5;
      if ( v5 )
      {
        v7 = *(_DWORD *)(v3 + 12);
        v8 = *(_QWORD *)(v3 + 4);
        v9 = *v5 + 1;
        *(_DWORD *)(v3 + 16) = 1;
        *(_DWORD *)(v3 + 20) = 0;
        *(_DWORD *)(v3 + 12) = v7 & 0xFFFFFFFB;
        *(_DWORD *)(v3 + 4) = v9;
        *(_DWORD *)(v3 + 8) = v5;
        if ( a2 == 1 )
        {
          sub_86AD8(v3);
        }
        else
        {
          if ( a2 != 2 )
          {
            sub_86AD8(v3);
            *(_DWORD *)(v3 + 20) = 0;
            *(_DWORD *)(v3 + 16) = 1;
          }
          sub_869AC(v3);
        }
        free(v6);
        *(_QWORD *)(v3 + 4) = v8;
        *(_DWORD *)(v3 + 12) = v7;
      }
    }
    v10 = *(_DWORD *)(v3 + 104);
    v11 = *(const char **)(v3 + 32);
    v12 = v10 - 1;
    v20[0] = *(void ***)(v3 + 68);
    result = sub_6C054((int)v21, 0x80u, "%s_", v11);
    v13 = v10 <= 0;
    dest = &v21[result];
    v14 = 127 - result;
    if ( !v13 )
    {
      v15 = v20[0];
      do
      {
        if ( ((unsigned int)v15[4] & 0x100) == 0 && *((unsigned __int16 *)v15 + 4) == 0x8000 )
        {
          result = strlen((const char *)v15[12]);
          if ( v14 >= result + 1 )
          {
            memcpy(dest, v15[12], result + 1);
            result = (unsigned int)sub_87194(v20, v21, v3, a2);
            v15 = v20[0];
          }
        }
        --v12;
        v15 += 16;
        v20[0] = v15;
      }
      while ( v12 != -1 );
    }
    v16 = *(unsigned __int16 *)(v3 + 94);
    if ( (v16 & 0x7FFF) != 0 )
    {
      v17 = *(_DWORD *)(v3 + 68) + ((v16 + 1) << 6);
      v18 = *(const char **)(v17 + 48);
      v20[0] = (void **)v17;
      if ( v18 )
      {
        result = strlen(v18);
        if ( v14 >= result + 1 )
        {
          memcpy(dest, v18, result + 1);
          return (unsigned int)sub_87194(v20, v21, v3, a2);
        }
      }
    }
  }
  return result;
}

//----- (0008909C) --------------------------------------------------------
unsigned int __fastcall sub_8909C(unsigned int a1, int a2, char **a3)
{
  int v6; // r3
  int v7; // r2
  int v8; // r2
  unsigned int v9; // r3
  int v10; // r7
  int v11; // r2
  void (*v12)(void); // r2
  int v13; // r3
  int v14; // r8
  unsigned int result; // r0
  int v16; // r2
  bool v17; // zf
  unsigned __int16 *v18; // lr
  int v19; // r12
  unsigned __int16 *i; // r1
  int v21; // r3
  int v22; // r0
  int v23; // r3
  int v24; // r3
  unsigned __int16 *v25; // r2
  int v26; // r2
  int v27; // t1
  int v28; // r3
  int v29; // r3
  int v30; // r2
  int v31; // t1
  unsigned __int16 *v32; // r2
  int v33; // r8
  _DWORD *v34; // r10
  unsigned int v35; // r2
  int v36; // r9
  unsigned int v37; // r8
  unsigned int v38; // r3
  int v39; // r0
  _BYTE *v40; // r7
  _DWORD *v41; // r12
  unsigned int v42; // r1
  int v43; // r0
  int v44; // r1
  int v45; // r12
  int v46; // r2
  int v47; // lr
  int v48; // r0
  int v49; // r5
  unsigned int v50; // r9
  int v51; // r3
  int v52; // r2
  _BYTE *v53; // r0
  int v54; // r12
  unsigned int v55; // r1
  _BYTE *v56; // r7
  unsigned int v57; // t1
  int v58; // r3
  _BYTE *v59; // r1
  int v60; // r12
  _DWORD *v61; // r1
  _DWORD *v62; // r0
  _DWORD *v63; // r1
  int v64; // t1
  unsigned int v65; // [sp+Ch] [bp-38h]
  _DWORD *src; // [sp+10h] [bp-34h]
  int v67; // [sp+14h] [bp-30h]
  int v68; // [sp+2Ch] [bp-18h] BYREF
  int v69; // [sp+30h] [bp-14h]
  int v70; // [sp+34h] [bp-10h]
  int v71; // [sp+38h] [bp-Ch] BYREF

  if ( sub_87480((int *)a1, *a3) )
    sub_7CEC0((int)off_B848C[0]);
  v6 = *(_DWORD *)(a1 + 12);
  if ( (v6 & 0x40) == 0 )
  {
    v7 = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 12) = v6 | 0x40;
    *(_DWORD *)(a1 + 4) = a2;
    *(_DWORD *)(a1 + 8) = a3;
    if ( v7 >= 139264 )
      off_B8604 = *(char **)(a1 + 124);
    if ( sub_86AD8(a1) )
      return 0;
    v8 = *(unsigned __int16 *)(a1 + 94);
    v9 = *(_DWORD *)(a1 + 12);
    if ( (v8 & 0x7FFF) != 0 )
    {
      v10 = *(_DWORD *)(a1 + 68) + ((v8 + 1) << 6);
      if ( (*(_DWORD *)(v10 + 16) & 0x20) != 0 )
        goto LABEL_12;
      v11 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a1 + 12) = v9 | 0x80000;
      if ( v11 )
      {
        sub_88E84(a1, 1);
        if ( (*(_DWORD *)(v10 + 16) & 0x20) == 0 )
          sub_884D4(a1);
        goto LABEL_11;
      }
    }
    else
    {
      v16 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a1 + 12) = v9 | 0x80000;
      if ( v16 )
      {
        sub_88E84(a1, 1);
LABEL_11:
        sub_88E84(a1, 2);
        v9 = *(_DWORD *)(a1 + 12) & 0xFFF7FFFF;
        *(_DWORD *)(a1 + 12) = v9;
LABEL_12:
        if ( (v9 & 0x2000) == 0 )
          goto LABEL_16;
        goto LABEL_13;
      }
    }
    sub_88E84(a1, 0);
    v9 = *(_DWORD *)(a1 + 12) & 0xFFF7FFFF;
    v17 = (*(_DWORD *)(a1 + 12) & 0x2000) == 0;
    *(_DWORD *)(a1 + 12) = v9;
    if ( v17 )
      goto LABEL_16;
LABEL_13:
    v12 = *(void (**)(void))(a1 + 88);
    if ( v12 && (v9 & 0x30000) == 0x10000 )
    {
      *(_DWORD *)(a1 + 12) = v9 & 0xFFFEFFFF;
      v12();
      v9 = *(_DWORD *)(a1 + 12);
    }
LABEL_16:
    if ( (v9 & 0x800) != 0 )
    {
      v68 = 0;
      v69 = 0;
      v70 = 4;
      v71 = 0;
      if ( !getenv("POSIXLY_CORRECT") && (*(_DWORD *)(a1 + 12) & 3) != 0 )
      {
        v65 = *(_DWORD *)(a1 + 4);
        v33 = 4 * v65;
        src = malloc(4 * v65);
        if ( !src || (v34 = malloc(v33), v35 = v65, !v34) )
          sub_C610(v33);
        v36 = 0;
        v37 = 0;
        v38 = 1;
        *(_DWORD *)(a1 + 20) = 0;
        *(_DWORD *)(a1 + 16) = 1;
LABEL_54:
        while ( 2 )
        {
          while ( 2 )
          {
            if ( v35 <= v38 )
            {
LABEL_64:
              *_errno_location() = 0;
              goto LABEL_65;
            }
            while ( 1 )
            {
              v39 = *(_DWORD *)(a1 + 8);
              v40 = *(_BYTE **)(v39 + 4 * v38);
              v41 = (_DWORD *)(v39 + 4 * v38);
              if ( *v40 != 45 || (v42 = (unsigned __int8)v40[1], !v40[1]) )
              {
                ++v38;
                v34[v37] = v40;
                *(_DWORD *)(a1 + 16) = v38;
                ++v37;
                goto LABEL_54;
              }
              if ( v42 == 45 )
              {
                if ( !v40[2] )
                {
                  v61 = src;
                  src[v36] = v40;
                  if ( v38 + 1 < v35 )
                    v61 = (_DWORD *)(v39 + 4 * v35);
                  ++v36;
                  *(_DWORD *)(a1 + 16) = v38 + 1;
                  if ( v38 + 1 < v35 )
                  {
                    v62 = &v34[v37];
                    v63 = v61 - 1;
                    do
                    {
                      v64 = v41[1];
                      ++v41;
                      *v62++ = v64;
                    }
                    while ( v63 != v41 );
                    v37 = v37 + v35 - 1 - v38;
                    *(_DWORD *)(a1 + 16) = v35;
                  }
                  goto LABEL_65;
                }
                v43 = sub_85A98(a1, v40 + 2, &v68);
              }
              else
              {
                v43 = (*(_DWORD *)(a1 + 12) & 2) != 0 ? sub_7DFF0(a1, v42, &v68, &v71) : sub_85A98(a1, v40 + 1, &v68);
              }
              if ( v43 < 0 )
                goto LABEL_106;
              v44 = *(_DWORD *)(a1 + 16);
              v45 = *(_DWORD *)(a1 + 8);
              v67 = v36;
              v46 = *(_DWORD *)(v68 + 16);
              v47 = 4 * v44;
              v48 = v71;
              v49 = *(_DWORD *)(v45 + 4 * v44);
              v38 = v44 + 1;
              *(_DWORD *)(a1 + 16) = v44 + 1;
              src[v36] = v49;
              if ( (v46 & 0xF000) != 0 )
                break;
              if ( v48 == 1 )
              {
                v55 = (unsigned __int8)v40[2];
                v56 = v40 + 2;
                if ( v55 )
                {
                  while ( sub_7DFF0(a1, v55, &v68, &v71) >= 0 )
                  {
                    v57 = (unsigned __int8)*++v56;
                    v55 = v57;
                    v58 = *(_DWORD *)(v68 + 16);
                    if ( (v58 & 0xF000) != 0 )
                    {
                      v17 = (v58 & 0x10000) == 0;
                      v38 = *(_DWORD *)(a1 + 16);
                      v35 = *(_DWORD *)(a1 + 4);
                      if ( !v17 )
                      {
                        if ( !v55 )
                        {
                          v59 = *(_BYTE **)(*(_DWORD *)(a1 + 8) + 4 * v38);
                          if ( *v59 != 45 )
                          {
                            ++v38;
                            v36 += 2;
                            *(_DWORD *)(a1 + 16) = v38;
                            src[v67 + 1] = v59;
                            goto LABEL_54;
                          }
                        }
                        goto LABEL_91;
                      }
                      if ( v55 )
                        goto LABEL_91;
                      if ( v35 > v38 )
                      {
                        v36 += 2;
                        v60 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v38);
                        *(_DWORD *)(a1 + 16) = ++v38;
                        src[v67 + 1] = v60;
                        goto LABEL_54;
                      }
                      break;
                    }
                    if ( !v55 )
                    {
                      ++v36;
                      v38 = *(_DWORD *)(a1 + 16);
                      v35 = *(_DWORD *)(a1 + 4);
                      goto LABEL_54;
                    }
                  }
LABEL_106:
                  *_errno_location() = 22;
                  goto LABEL_69;
                }
              }
              v35 = *(_DWORD *)(a1 + 4);
              ++v36;
              if ( v35 <= v38 )
                goto LABEL_64;
            }
            if ( (v46 & 0x10000) != 0 )
            {
              if ( v48 == 1 )
              {
                v35 = *(_DWORD *)(a1 + 4);
                if ( v40[2] )
                  goto LABEL_91;
                goto LABEL_108;
              }
              if ( v48 == 2 )
              {
                v35 = *(_DWORD *)(a1 + 4);
                if ( v69 )
                {
LABEL_91:
                  ++v36;
                  continue;
                }
LABEL_108:
                if ( v35 > v38 )
                {
                  v53 = *(_BYTE **)(v45 + v47 + 4);
                  if ( *v53 == 45 )
                    goto LABEL_91;
                  v38 = v44 + 2;
                  goto LABEL_99;
                }
                ++v36;
                *_errno_location() = 0;
LABEL_65:
                if ( v36 )
                  memcpy((void *)(*(_DWORD *)(a1 + 8) + 4), src, 4 * v36);
                if ( v37 )
                  memcpy((void *)(*(_DWORD *)(a1 + 8) + 4 * (v36 + 1)), v34, 4 * v37);
LABEL_69:
                free(src);
                free(v34);
                goto LABEL_17;
              }
LABEL_100:
              *_errno_location() = 5;
              goto LABEL_69;
            }
            break;
          }
          if ( v48 == 1 )
          {
            v35 = *(_DWORD *)(a1 + 4);
            if ( v40[2] )
              goto LABEL_91;
          }
          else
          {
            if ( v48 != 2 )
              goto LABEL_100;
            v35 = *(_DWORD *)(a1 + 4);
            if ( v69 )
              goto LABEL_91;
          }
          if ( v35 > v38 )
          {
            v38 = v44 + 2;
            v53 = *(_BYTE **)(v45 + v47 + 4);
LABEL_99:
            v54 = v36;
            *(_DWORD *)(a1 + 16) = v38;
            v36 += 2;
            src[v54 + 1] = v53;
            continue;
          }
          goto LABEL_100;
        }
      }
    }
LABEL_17:
    *(_QWORD *)(a1 + 16) = 1;
    goto LABEL_18;
  }
  if ( !*(_DWORD *)(a1 + 16) )
    goto LABEL_17;
LABEL_18:
  if ( sub_869AC(a1) )
    return *(_DWORD *)(a1 + 4);
  v13 = *(unsigned __int16 *)(a1 + 94);
  if ( *(_WORD *)(a1 + 94) && v13 != 0x8000 && (*(_DWORD *)(*(_DWORD *)(a1 + 68) + (v13 << 6) + 16) & 5) != 0 )
  {
    sub_85318((int *)a1);
    sub_7CE5C(0);
  }
  v14 = *(_DWORD *)(a1 + 12);
  if ( (v14 & 4) == 0 )
    return *(_DWORD *)(a1 + 16);
  v18 = *(unsigned __int16 **)(a1 + 68);
  v19 = *(_DWORD *)(a1 + 104);
  for ( i = v18; ; i += 32 )
  {
    v22 = *((_DWORD *)i + 4);
    if ( (v22 & 5) != 0 )
    {
      v23 = *((_DWORD *)i + 8);
      if ( v23 )
      {
        v24 = v23 - 4;
        while ( 1 )
        {
          v27 = *(_DWORD *)(v24 + 4);
          v24 += 4;
          v26 = v27;
          if ( v27 == 0x8000 )
            break;
          v25 = &v18[32 * v26];
          if ( (*((_DWORD *)v25 + 4) & 0xF) == 0 )
          {
            fprintf(stderr, off_B853C[0], *(_DWORD *)(a1 + 28), *((_DWORD *)i + 13), *((_DWORD *)v25 + 13));
            goto LABEL_48;
          }
        }
      }
      v28 = *((_DWORD *)i + 9);
      if ( v28 )
      {
        v29 = v28 - 4;
        while ( 1 )
        {
          v31 = *(_DWORD *)(v29 + 4);
          v29 += 4;
          v30 = v31;
          if ( v31 == 0x8000 )
            break;
          v32 = &v18[32 * v30];
          if ( (*((_DWORD *)v32 + 4) & 5) != 0 )
          {
            fprintf(stderr, off_B84BC[0], *(_DWORD *)(a1 + 28), *((_DWORD *)i + 13), *((_DWORD *)v32 + 13));
            goto LABEL_48;
          }
        }
      }
    }
    v21 = i[4];
    if ( v21 == 0x8000 || *i == v21 )
    {
      v50 = i[5];
      if ( i[7] < v50 && ((v22 & 0x100000) == 0 || (v22 & 3) == 0) )
      {
        v51 = *((_DWORD *)i + 13);
        v52 = *(_DWORD *)(a1 + 28);
        if ( v50 <= 1 )
          fprintf(stderr, off_B84E8[0], v52, v51);
        else
          fprintf(stderr, off_B8518[0], v52, v51, v50);
        goto LABEL_48;
      }
    }
    if ( --v19 <= 0 )
      break;
  }
  result = *(_DWORD *)(a1 + 16);
  if ( (v14 & 0x200) != 0 )
  {
    if ( result < *(_DWORD *)(a1 + 4) )
    {
      fprintf(stderr, off_B84F0[0], *(_DWORD *)(a1 + 28));
      goto LABEL_48;
    }
  }
  else if ( (v14 & 0x400) != 0 && result >= *(_DWORD *)(a1 + 4) )
  {
    fprintf(stderr, off_B84A8[0], *(_DWORD *)(a1 + 28));
LABEL_48:
    (*(void (__fastcall **)(unsigned int, int))(a1 + 84))(a1, 1);
    return *(_DWORD *)(a1 + 16);
  }
  return result;
}
// 1BC: using guessed type int elf_hash_bucket[521];
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B848C: using guessed type char *off_B848C[94];
// B84A8: using guessed type char *[87];
// B84BC: using guessed type char *[82];
// B84E8: using guessed type char *[71];
// B84F0: using guessed type char *[69];
// B8518: using guessed type char *[59];
// B853C: using guessed type char *[50];
// B8604: using guessed type char *off_B8604;

//----- (00089944) --------------------------------------------------------
int __fastcall sub_89944(_DWORD *a1, int a2)
{
  int result; // r0
  char *v5; // r2
  char *v6; // [sp+0h] [bp-Ch] BYREF

  v6 = 0;
  sub_86D90(a1 + 3, 0);
  result = a1[3];
  if ( !a2 || (result & 0x4000) == 0 )
  {
    if ( (result & 0x1000) != 0 )
      sub_7D420(result, &v6);
    else
      sub_7D588(result, &v6);
    sub_806BC(a1, a2, (int)v6);
    fflush((FILE *)option_usage_fp);
    result = ferror((FILE *)option_usage_fp);
    if ( result )
    {
      if ( (struct _IO_FILE *)option_usage_fp == stderr )
        v5 = off_B8530[0];
      else
        v5 = off_B852C[0];
      sub_7CF18(a1[7], (int)off_B8534[0], (int)v5);
    }
  }
  return result;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B852C: using guessed type char *off_B852C[54];
// B8530: using guessed type char *off_B8530[53];
// B8534: using guessed type char *off_B8534[52];
// 107410: using guessed type int option_usage_fp;

//----- (00089A3C) --------------------------------------------------------
void __fastcall sub_89A3C(char *a1, int a2, FILE *a3)
{
  size_t v6; // r0
  int v7; // r8
  unsigned int v8; // r6
  char *v9; // r0
  char *v10; // r10
  char *v11; // r5
  char *v12; // r11
  char *v13; // r0
  char *v14; // r4
  const unsigned __int16 **v15; // r0
  int v16; // r3
  unsigned int v17; // r2
  char *v18; // r4
  char *v19; // r2
  int v20; // t1
  int v21; // t1
  char v22; // [sp+4h] [bp-10h]

  v6 = strlen(a1);
  if ( v6 <= 0xFF )
    v7 = a2 | 1;
  else
    v7 = a2;
  if ( v7 )
  {
    if ( a2 )
      fputs(a1, a3);
    else
      sub_84A50(a1, a3);
  }
  else
  {
    v8 = v6;
    v9 = _strdup(a1);
    v10 = v9;
    if ( !v9 )
      sub_7E624(a1);
    v11 = v9;
    while ( 2 )
    {
      v12 = v11;
      while ( 1 )
      {
LABEL_12:
        v13 = strchr(v12, 10);
        v14 = v13;
        if ( !v13 )
          goto LABEL_26;
        v12 = v13 + 1;
        if ( v13 - v11 > 39 )
        {
          v15 = _ctype_b_loc();
          v16 = (unsigned __int8)v14[1];
          v17 = (((*v15)[v16] ^ 0x2000u) >> 13) & 1;
          if ( v16 == 9 )
            v17 = 1;
          if ( !v17 )
            break;
        }
      }
      if ( v16 == 10 )
      {
        do
        {
          v21 = (unsigned __int8)*++v12;
          LOBYTE(v16) = v21;
        }
        while ( v21 == 10 );
      }
      else if ( v16 == 32 )
      {
        v18 = v14 + 8;
        v19 = v12;
        while ( 1 )
        {
          v20 = (unsigned __int8)*++v19;
          if ( v20 != 32 )
            break;
          if ( v19 == v18 )
          {
            v12 = v19;
            goto LABEL_12;
          }
        }
      }
      *v12 = 0;
      v22 = v16;
      sub_84A50(v11, a3);
      v8 -= v12 - v11;
      if ( v8 )
      {
        *v12 = v22;
        v11 = v12;
        if ( v8 > 0xFF )
          continue;
LABEL_26:
        sub_84A50(v11, a3);
      }
      break;
    }
    free(v10);
  }
}

//----- (00089BE8) --------------------------------------------------------
void __fastcall __noreturn sub_89BE8(int a1, int a2)
{
  int *v4; // r0
  char *v5; // r0
  FILE *v6; // r2
  int v7; // r3
  unsigned int v8; // r0
  int v9; // r8
  int v10; // r3
  int v11; // r3
  int v12; // r3
  const char *v13; // r0
  FILE *v14; // r0
  int v15; // r0
  char *v16; // r1
  char *v17; // r2
  int v18; // r9
  _DWORD *v19; // r0
  int v20; // r3
  int v21; // r2
  int v22; // r12
  int v23; // r3
  int v24; // r0
  int v25; // r0
  __int16 v26; // r3
  int v27; // r9
  int v28; // r7
  int v29; // r3
  const char *v30; // r1
  char *s; // [sp+0h] [bp-24h] BYREF
  char dest[24]; // [sp+4h] [bp-20h] BYREF

  v4 = (int *)(a1 + 12);
  if ( a2 == 10064 )
  {
    byte_1073CC = 0;
    sub_86D90(v4, 0);
  }
  else
  {
    byte_1073CC = 0;
    sub_86D90(v4, 0);
    if ( a2 )
    {
      if ( *(int *)a1 >= 122880 )
        v5 = *(char **)(a1 + 112);
      else
        v5 = 0;
      v6 = (FILE *)option_usage_fp;
      if ( option_usage_fp )
      {
        v7 = *(_DWORD *)(a1 + 12);
        if ( (v7 & 0x100000) != 0 )
        {
LABEL_9:
          fprintf(v6, *(const char **)(a1 + 56), *(_DWORD *)(a1 + 28));
          v8 = *(_DWORD *)(a1 + 12);
          if ( ((v8 >> 14) & 1) != 0 )
          {
            if ( *(int *)a1 < 155648 )
            {
              v25 = *(_DWORD *)(a1 + 12) & 3;
              if ( v25 == 2 )
              {
                strcpy(dest, "-h");
              }
              else if ( v25 == 3 || v25 == 1 )
              {
                strcpy(dest, "--help");
              }
              else
              {
                strcpy(dest, "help");
              }
            }
            else
            {
              v20 = *(_DWORD *)(a1 + 104);
              v21 = *(_DWORD *)(a1 + 68) + (v20 << 6);
              if ( *(_DWORD *)(v21 + 20) != 3 )
              {
                v22 = *(_DWORD *)(a1 + 100);
                v23 = v20 + 1;
                if ( v23 >= v22 )
LABEL_102:
                  sub_7CEC0((int)off_B8488[0]);
                while ( 1 )
                {
                  v21 += 64;
                  if ( *(_DWORD *)(v21 + 20) == 3 )
                    break;
                  if ( ++v23 == v22 )
                    goto LABEL_102;
                }
              }
              v24 = *(_DWORD *)(a1 + 12) & 3;
              if ( v24 == 2 )
              {
                dest[0] = 45;
                v26 = *(_WORD *)(v21 + 2);
                dest[2] = 0;
                dest[1] = v26;
              }
              else if ( v24 == 3 || v24 == 1 )
              {
                v30 = *(const char **)(v21 + 52);
                *(_WORD *)dest = 11565;
                strncpy(&dest[2], v30, 0x14u);
              }
              else
              {
                strncpy(dest, *(const char **)(v21 + 52), 0x14u);
              }
            }
            v9 = a2;
            fprintf((FILE *)option_usage_fp, off_B8524[0], *(_DWORD *)(a1 + 28), dest);
            goto LABEL_43;
          }
          s = 0;
          if ( (v8 & 0x1000) != 0 )
          {
            v9 = a2;
LABEL_13:
            v18 = sub_7D420(v8, &s);
            sprintf(byte_1073D0, "%%-%ds %%s\n", v18);
            fputc(10, (FILE *)option_usage_fp);
            goto LABEL_14;
          }
          v9 = a2;
          v18 = sub_7D588(v8, &s);
          sprintf(byte_1073D0, "%%-%ds %%s\n", v18);
          goto LABEL_55;
        }
      }
      else
      {
        v6 = stderr;
        v7 = *(_DWORD *)(a1 + 12);
        option_usage_fp = (int)stderr;
        if ( (v7 & 0x100000) != 0 )
          goto LABEL_9;
      }
      if ( !v5 )
        goto LABEL_9;
      v9 = a2;
LABEL_41:
      if ( (v7 & 0x2000) != 0 )
        sub_89A3C(v5, 1, v6);
      else
        fputs(v5, v6);
      goto LABEL_43;
    }
  }
  if ( *(int *)a1 < 122880 )
    v5 = 0;
  else
    v5 = *(char **)(a1 + 108);
  v6 = (FILE *)option_usage_fp;
  if ( option_usage_fp )
  {
    v7 = *(_DWORD *)(a1 + 12);
    v9 = v7 & 0x100000;
    if ( (v7 & 0x100000) != 0 )
      goto LABEL_51;
  }
  else
  {
    if ( byte_1072C4 )
      v6 = stderr;
    else
      v6 = stdout;
    v7 = *(_DWORD *)(a1 + 12);
    option_usage_fp = (int)v6;
    v9 = v7 & 0x100000;
    if ( (v7 & 0x100000) != 0 )
      goto LABEL_51;
  }
  if ( v5 )
    goto LABEL_41;
LABEL_51:
  fprintf(v6, *(const char **)(a1 + 56), *(_DWORD *)(a1 + 28));
  v8 = *(_DWORD *)(a1 + 12);
  s = 0;
  v9 = (v8 >> 12) & 1;
  if ( v9 )
  {
    v9 = 0;
    goto LABEL_13;
  }
  v18 = sub_7D588(v8, &s);
  sprintf(byte_1073D0, "%%-%ds %%s\n", v18);
  if ( !a2 )
  {
    v9 = 0;
    if ( (*(_DWORD *)(*(_DWORD *)(a1 + 68) + 16) & 0x200000) != 0 )
    {
LABEL_14:
      v10 = v18 + 15;
      if ( v18 + 15 < 0 )
        v10 = v18 + 22;
      v11 = 4 - (v10 >> 3);
      if ( v11 > 0 )
        dword_1073C8 = v11;
      sub_806BC((_DWORD *)a1, a2, (int)s);
      v12 = *(_DWORD *)(a1 + 12);
      if ( (v12 & 3) == 1 )
      {
        fputs(off_B8584[0], (FILE *)option_usage_fp);
        v12 = *(_DWORD *)(a1 + 12);
      }
      else if ( (v12 & 3) != 0 )
      {
        if ( (v12 & 3) == 3 )
        {
          fputs(off_B8570[0], (FILE *)option_usage_fp);
          v12 = *(_DWORD *)(a1 + 12);
          if ( (v12 & 0x20) == 0 )
          {
LABEL_23:
            if ( (v12 & 0x800) == 0 )
              goto LABEL_24;
LABEL_64:
            fputs(off_B85DC[0], (FILE *)option_usage_fp);
LABEL_24:
            v13 = *(const char **)(a1 + 60);
            if ( v13 )
              fputs(v13, (FILE *)option_usage_fp);
            if ( a2 )
              goto LABEL_27;
            v19 = *(_DWORD **)(a1 + 52);
            if ( v19 )
            {
              sub_84264(v19, *(const char **)(a1 + 36), *(const char **)(a1 + 24));
              if ( (*(_DWORD *)(a1 + 12) & 0x100) == 0 )
              {
LABEL_69:
                v14 = (FILE *)option_usage_fp;
LABEL_70:
                if ( byte_1073CC )
                {
                  v27 = *(_DWORD *)(a1 + 100);
                  v28 = *(_DWORD *)(a1 + 68);
                  fputc(10, v14);
                  fflush((FILE *)option_usage_fp);
                  do
                  {
                    v29 = (unsigned __int16)*(_DWORD *)(v28 + 16) >> 12;
                    if ( v29 == 2 || v29 == 4 )
                      (*(void (__fastcall **)(int, int))(v28 + 40))(1, v28);
                    --v27;
                    v28 += 64;
                  }
                  while ( v27 > 0 );
                  v14 = (FILE *)option_usage_fp;
                }
                if ( !*(_DWORD *)(a1 + 64) )
                {
LABEL_28:
                  if ( *(int *)a1 >= 139264 && *(_DWORD *)(a1 + 128) )
                  {
                    fputs(*(const char **)(a1 + 128), v14);
                    v14 = (FILE *)option_usage_fp;
                  }
                  else if ( *(_DWORD *)(a1 + 72) )
                  {
                    fprintf(v14, off_B85A8[0]);
                    v14 = (FILE *)option_usage_fp;
                  }
                  fflush(v14);
                  if ( ferror((FILE *)option_usage_fp) )
                  {
                    v15 = *(_DWORD *)(a1 + 28);
                    v16 = off_B8534[0];
                    if ( (struct _IO_FILE *)option_usage_fp != stderr )
                    {
LABEL_33:
                      v17 = off_B852C[0];
                      goto LABEL_46;
                    }
LABEL_45:
                    v17 = off_B8530[0];
LABEL_46:
                    sub_7CF18(v15, (int)v16, (int)v17);
                  }
LABEL_43:
                  fflush((FILE *)option_usage_fp);
                  if ( !ferror((FILE *)option_usage_fp) )
                    sub_7CE5C(v9);
                  v15 = *(_DWORD *)(a1 + 28);
                  v16 = off_B8534[0];
                  if ( (struct _IO_FILE *)option_usage_fp == stdout )
                    goto LABEL_33;
                  goto LABEL_45;
                }
                fputs(*(const char **)(a1 + 64), v14);
LABEL_27:
                v14 = (FILE *)option_usage_fp;
                goto LABEL_28;
              }
            }
            else
            {
              v14 = (FILE *)option_usage_fp;
              if ( (*(_DWORD *)(a1 + 12) & 0x100) == 0 )
                goto LABEL_70;
              fputs(off_B85B0[0], (FILE *)option_usage_fp);
            }
            fprintf((FILE *)option_usage_fp, off_B8564[0], *(_DWORD *)(a1 + 32));
            goto LABEL_69;
          }
LABEL_63:
          fputs(off_B859C[0], (FILE *)option_usage_fp);
          if ( (*(_DWORD *)(a1 + 12) & 0x800) == 0 )
            goto LABEL_24;
          goto LABEL_64;
        }
      }
      else
      {
        fputs(off_B85A0[0], (FILE *)option_usage_fp);
        v12 = *(_DWORD *)(a1 + 12);
      }
      if ( (v12 & 0x20) == 0 )
        goto LABEL_23;
      goto LABEL_63;
    }
  }
LABEL_55:
  fputs(s, (FILE *)option_usage_fp);
  goto LABEL_14;
}
// 180: using guessed type int dword_180[4];
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B8488: using guessed type char *off_B8488[95];
// B8524: using guessed type char *off_B8524[56];
// B852C: using guessed type char *off_B852C[54];
// B8530: using guessed type char *off_B8530[53];
// B8534: using guessed type char *off_B8534[52];
// B8564: using guessed type char *off_B8564[40];
// B8570: using guessed type char *off_B8570[37];
// B8584: using guessed type char *off_B8584[32];
// B859C: using guessed type char *off_B859C[26];
// B85A0: using guessed type char *off_B85A0[25];
// B85A8: using guessed type char *off_B85A8[23];
// B85B0: using guessed type char *off_B85B0[21];
// B85DC: using guessed type char *off_B85DC[10];
// 1072C4: using guessed type char byte_1072C4;
// 1073C8: using guessed type int dword_1073C8;
// 1073CC: using guessed type char byte_1073CC;
// 107410: using guessed type int option_usage_fp;

//----- (0008A30C) --------------------------------------------------------
void __fastcall __noreturn sub_8A30C(int a1, int a2)
{
  __pid_t v3; // r0
  int v4; // r8
  const char *v5; // r9
  char *v6; // r0
  char *v7; // r6
  int v8; // r8
  const __int32_t *v9; // r2
  int v10; // t1
  __pid_t v11; // r0
  _BYTE stat_loc[4]; // [sp+8h] [bp-Ch] BYREF

  if ( !a2 )
  {
    fflush(stderr);
    fflush(stdout);
    if ( ferror(stdout) || ferror(stderr) )
      sub_7CE5C(1);
    option_usage_fp = (int)stdout;
    v3 = fork();
    if ( v3 != -1 )
    {
      if ( v3 )
      {
        wait(stat_loc);
        v4 = optionParseShellOptions;
        v5 = *(const char **)(optionParseShellOptions + 32);
        v6 = _strdup(v5);
        v7 = v6;
        if ( v6 )
        {
          *(_DWORD *)(v4 + 28) = v6;
          v8 = (unsigned __int8)*v6;
          if ( *v6 )
          {
            v9 = *_ctype_tolower_loc();
            do
            {
              *v7 = v9[v8];
              v10 = (unsigned __int8)*++v7;
              v8 = v10;
            }
            while ( v10 );
          }
          fprintf((FILE *)option_usage_fp, off_B8574[0], *(_DWORD *)(optionParseShellOptions + 28));
          fflush((FILE *)option_usage_fp);
          v11 = fork();
          if ( v11 != -1 )
          {
            if ( v11 )
            {
              wait(stat_loc);
              fflush(stdout);
              if ( ferror(stdout) )
                sub_7CF18(*(_DWORD *)(a1 + 28), (int)off_B8534[0], (int)off_B852C[0]);
              sub_7CE5C(0);
            }
            dword_1073BC = 2;
          }
          sub_89BE8(optionParseShellOptions, 1);
        }
        sub_7E624(v5);
      }
      dword_1073BC = 2;
      sub_89BE8(a1, 0);
    }
    sub_89BE8(a1, 1);
  }
  sub_89BE8(a1, a2);
}
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B852C: using guessed type char *off_B852C[54];
// B8534: using guessed type char *off_B8534[52];
// B8574: using guessed type char *off_B8574[36];
// 1073BC: using guessed type int dword_1073BC;
// 10740C: using guessed type int optionParseShellOptions;
// 107410: using guessed type int option_usage_fp;

//----- (0008A4F0) --------------------------------------------------------
void __noreturn sub_8A4F0()
{
  sub_8A30C((int)&genshelloptOptions, 0);
}

//----- (0008A534) --------------------------------------------------------
const char *sub_8A534()
{
  return "41.0";
}

//----- (0008A588) --------------------------------------------------------
int __fastcall sub_8A588(int a1, _DWORD *a2, _BYTE **a3, FILE *stream, char a5)
{
  _BYTE *v7; // r3
  int result; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r10
  const char *v13; // r0
  char *v14; // r2

  if ( (*a2 & 0x10000) != 0 )
  {
    v7 = *a3;
    if ( *a3 )
    {
      if ( *v7 )
      {
        switch ( *v7 )
        {
          case 'C':
          case 'c':
            goto LABEL_10;
          case 'N':
          case 'n':
            v10 = *(const char **)(a1 + 40);
            if ( v10 )
              fputs(v10, stream);
            v11 = *(const char **)(a1 + 44);
            if ( v11 )
              fputs(v11, stream);
            fputc(10, stream);
            v12 = off_B847C[0];
            v13 = sub_8A534();
            fprintf(stream, v12, v13);
            if ( *(int *)a1 >= 139264 && *(_DWORD *)(a1 + 128) )
              goto LABEL_24;
            if ( *(_DWORD *)(a1 + 72) )
              goto LABEL_15;
            goto LABEL_7;
          case 'V':
          case 'v':
            goto LABEL_6;
          default:
            fprintf(stderr, off_B84B8[0]);
            sub_7CE5C(1);
        }
      }
    }
  }
  sub_86D90((int *)(a1 + 12), 0);
  if ( (*(_DWORD *)(a1 + 12) & 0x1000) != 0 )
  {
LABEL_10:
    v9 = *(const char **)(a1 + 40);
    if ( v9 || (v9 = *(const char **)(a1 + 48)) != 0 )
      fputs(v9, stream);
    else
      sub_7C6DC((int)stream, *(const char **)(a1 + 56), 0, 0);
    if ( *(int *)a1 >= 139264 && *(_DWORD *)(a1 + 128) )
    {
LABEL_24:
      fputc(10, stream);
      fputs(*(const char **)(a1 + 128), stream);
    }
    else if ( *(_DWORD *)(a1 + 72) )
    {
LABEL_15:
      fputc(10, stream);
      fprintf(stream, off_B85A8[0], *(_DWORD *)(a1 + 72));
    }
  }
  else
  {
LABEL_6:
    sub_7C6DC((int)stream, *(const char **)(a1 + 48), *(const char **)(a1 + 40), *(const char **)(a1 + 56));
  }
LABEL_7:
  fflush(stream);
  result = ferror(stream);
  if ( result )
  {
    if ( stream == stdout )
      v14 = off_B852C[0];
    else
      v14 = off_B8530[0];
    sub_7CF18(*(_DWORD *)(a1 + 28), (int)off_B8534[0], (int)v14);
  }
  if ( a5 )
    sub_7CE5C(0);
  return result;
}
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B847C: using guessed type char *off_B847C[98];
// B84B8: using guessed type char *off_B84B8[83];
// B852C: using guessed type char *off_B852C[54];
// B8530: using guessed type char *off_B8530[53];
// B8534: using guessed type char *off_B8534[52];
// B85A8: using guessed type char *off_B85A8[23];

//----- (0008A8C0) --------------------------------------------------------
unsigned int __fastcall optionPrintVersion(unsigned int result, int a2)
{
  FILE *v2; // r3

  if ( byte_1072C4 )
    v2 = stderr;
  else
    v2 = stdout;
  if ( result > 0xF )
    return sub_8A588(result, (_DWORD *)(a2 + 16), (_BYTE **)(a2 + 24), v2, 1);
  return result;
}
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// 1072C4: using guessed type char byte_1072C4;

//----- (0008A95C) --------------------------------------------------------
size_t __fastcall sub_8A95C(unsigned int a1, int a2, int a3)
{
  int v6; // r4
  __pid_t v7; // r0
  __pid_t v8; // r11
  const char *v9; // r9
  const char *v10; // r10
  FILE *v11; // r8
  int v12; // r0
  int v13; // r6
  int pipedes[2]; // [sp+4h] [bp-10h] BYREF

  fflush(stdout);
  fflush(stderr);
  v6 = pipe(pipedes);
  if ( v6 )
    sub_7CF18(*(_DWORD *)(a1 + 28), (int)"pipe", (int)off_B84B4[0]);
  v7 = fork();
  v8 = v7;
  if ( v7 == -1 )
    sub_7CF18(*(_DWORD *)(a1 + 28), (int)"fork", *(_DWORD *)(a1 + 28));
  if ( !v7 )
  {
    dup2(pipedes[1], 2);
    dup2(pipedes[1], 1);
    close(pipedes[0]);
    if ( a2 != 1 )
    {
      if ( a2 == 2 )
        goto LABEL_22;
      (*(void (__fastcall **)(unsigned int, __pid_t))(a1 + 84))(a1, v8);
    }
    (*(void (__fastcall **)(unsigned int, int))(a1 + 84))(a1, 1);
LABEL_22:
    if ( (*(_DWORD *)(a3 + 16) & 0x40) != 0 )
    {
      free(*(void **)(a3 + 24));
      *(_DWORD *)(a3 + 16) &= ~0x40u;
    }
    *(_DWORD *)(a3 + 24) = "c";
    optionPrintVersion(a1, a3);
    sub_7CE5C(1);
  }
  close(pipedes[1]);
  v9 = *(const char **)(a1 + 32);
  v10 = (const char *)*(&off_B5208 + a2 + 97);
  v11 = fdopen(pipedes[0], "r");
  printf("%s_%s_TEXT='", v9, v10);
  if ( v11 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v12 = fgetc(v11);
          v13 = v12;
          if ( v12 != 10 )
            break;
          ++v6;
        }
        if ( v12 != 39 )
          break;
        for ( ; v6; --v6 )
          fputc(10, stdout);
        fwrite("'\\''", 1u, 4u, stdout);
        v6 = 0;
      }
      if ( v12 == -1 )
        break;
      for ( ; v6; --v6 )
        fputc(10, stdout);
      fputc(v13, stdout);
      v6 = 0;
    }
    fclose(v11);
  }
  return fwrite("'\n\n", 1u, 3u, stdout);
}
// B5208: using guessed type _UNKNOWN *off_B5208;
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// B84B4: using guessed type char *off_B84B4[84];

//----- (0008B580) --------------------------------------------------------
unsigned int __fastcall sub_8B580(unsigned int result, int a2)
{
  FILE *v2; // r3

  if ( byte_1072C4 )
    v2 = stderr;
  else
    v2 = stdout;
  if ( result > 0xF )
    return sub_8A588(result, (_DWORD *)(a2 + 16), (_BYTE **)(a2 + 24), v2, 0);
  return result;
}
// B5EEC: using guessed type _UNKNOWN *stdout_ptr;
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;
// 1072C4: using guessed type char byte_1072C4;

//----- (0008B61C) --------------------------------------------------------
unsigned int __fastcall sub_8B61C(unsigned int result, int a2)
{
  if ( result > 0xF )
    return sub_8A588(result, (_DWORD *)(a2 + 16), (_BYTE **)(a2 + 24), stderr, 1);
  return result;
}
// B5F3C: using guessed type _UNKNOWN *stderr_ptr;

//----- (0008B690) --------------------------------------------------------
unsigned int __fastcall sub_8B690(unsigned int result, unsigned int a2)
{
  if ( a2 != 1 )
  {
    if ( !a2 )
      JUMPOUT(0x8C000);
    if ( result <= a2 )
    {
      return result == a2;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (*)(void))((char *)&loc_8B6C8 + 16 * (31 - (__clz(a2) - __clz(result)))))();
    }
    else
    {
      result >>= 31 - __clz(a2);
    }
  }
  return result;
}
// 8B8E8: control flows out of bounds to 8C000

//----- (0008B8EC) --------------------------------------------------------
unsigned int __fastcall sub_8B8EC(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x8B8E2);
  return sub_8B690(a1, a2);
}
// 8B8EE: control flows out of bounds to 8B8E2

//----- (0008B908) --------------------------------------------------------
int __fastcall sub_8B908(int a1, int a2)
{
  if ( !a2 )
    JUMPOUT(0x8C000);
  return sub_8B90E();
}
// 8BB98: control flows out of bounds to 8C000
// 8B90E: using guessed type int sub_8B90E(void);

//----- (0008B90E) --------------------------------------------------------
int __fastcall sub_8B90E(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_8B950 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 8B912: variable 'v2' is possibly undefined

//----- (0008BB9C) --------------------------------------------------------
int __fastcall sub_8BB9C(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x8C000);
  return sub_8B90E(a1, a2);
}
// 8BB98: control flows out of bounds to 8C000

//----- (0008BEC4) --------------------------------------------------------
int __fastcall sub_8BEC4(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_11;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_11:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_23;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_23:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_27;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_27:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (0008BF30) --------------------------------------------------------
int __fastcall sub_8BF30(signed __int64 a1, signed __int64 a2)
{
  bool v3; // cf
  unsigned __int64 v5; // [sp+8h] [bp-8h] BYREF

  if ( !a2 )
    JUMPOUT(0x8C000);
  if ( a1 < 0 )
  {
    v3 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v3;
    if ( a2 < 0 )
    {
      v3 = (_DWORD)a2 == 0;
      LODWORD(a2) = -(int)a2;
      HIDWORD(a2) -= 2 * HIDWORD(a2) + !v3;
      return sub_8C050(a1, a2, &v5);
    }
    else
    {
      return -sub_8C050(a1, a2, &v5);
    }
  }
  else if ( a2 < 0 )
  {
    v3 = (_DWORD)a2 == 0;
    LODWORD(a2) = -(int)a2;
    HIDWORD(a2) -= 2 * HIDWORD(a2) + !v3;
    return -sub_8C050(a1, a2, &v5);
  }
  else
  {
    return sub_8C050(a1, a2, &v5);
  }
}
// 8BF4E: control flows out of bounds to 8C000

//----- (0008BFD0) --------------------------------------------------------
int __fastcall sub_8BFD0(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return sub_8C050(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (0008C010) --------------------------------------------------------
unsigned int __fastcall sub_8C010(double a1)
{
  return (unsigned int)(a1 - (double)(unsigned int)(a1 * 2.32830644e-10) * 4294967300.0);
}

//----- (0008C050) --------------------------------------------------------
int __fastcall sub_8C050(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}

//----- (0008C168) --------------------------------------------------------
int __fastcall _libc_csu_init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_B36D8;
  v8 = &off_B36DC - &off_B36D8;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// B36D8: using guessed type _UNKNOWN *off_B36D8;
// B36DC: using guessed type _UNKNOWN *off_B36DC;

//----- (0008C1A8) --------------------------------------------------------
int __fastcall sub_8C1A8(void (*a1)(void *))
{
  _UNKNOWN **v1; // r2

  v1 = &off_B6004;
  if ( &off_B6004 )
    v1 = (_UNKNOWN **)off_B6004;
  return sub_B508(a1, 0, v1);
}
// B6004: using guessed type _UNKNOWN *off_B6004;

//----- (0008C1C4) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1834 queued=1179 decompiled=1179 lumina nreq=0 worse=0 better=0
#error "There were 3 decompilation failure(s) on 1179 function(s)"
