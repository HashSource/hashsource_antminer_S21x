/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_11938();
// void *calloc(size_t nmemb, size_t size);
// void login(const struct utmp *entry);
// int raise(int sig);
// struct passwd *getpwnam(const char *name);
// int fsync(int fd);
// int strcmp(const char *s1, const char *s2);
// struct passwd *getpwuid(__uid_t uid);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int clearenv(void);
// int printf(const char *format, ...);
// int __fastcall setrlimit64(_DWORD, _DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// __uid_t getuid(void);
// struct spwd *getspnam(const char *name);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// const char *gai_strerror(int ecode);
// char *fgets(char *s, int n, FILE *stream);
// void exit(int status);
// void *memcpy(void *dest, const void *src, size_t n);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// int rmdir(const char *path);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *inet_ntoa(struct in_addr in);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// char *strdup(const char *s);
// int unlink(const char *name);
// int dup2(int fd, int fd2);
// void *realloc(void *ptr, size_t size);
// int initgroups(const char *, __gid_t group);
// int chdir(const char *path);
// __uid_t geteuid(void);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int seteuid(__uid_t uid);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int ioctl(int fd, unsigned int request, ...);
// int usleep(__useconds_t useconds);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int daemon(int nochdir, int noclose);
// int gethostname(char *name, size_t len);
// int __fastcall open64(_DWORD, _DWORD); weak
// int puts(const char *s);
// int setgid(__gid_t gid);
// void *malloc(size_t size);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// struct tm *localtime(const time_t *timer);
// char *dirname(char *path);
// const __int32_t **_ctype_toupper_loc(void);
// int _gmon_start__(void); weak
// int openpty(int *amaster, int *aslave, char *name, struct termios *termp, struct winsize *winp);
// clock_t clock(void);
// int kill(__pid_t pid, int sig);
// const unsigned __int16 **_ctype_b_loc(void);
// __pid_t getpid(void);
// void exit(int status);
// int syscall(int sysno, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *ttyname(int fd);
// size_t strlen(const char *s);
// __pid_t setsid(void);
// char *strchr(const char *s, int c);
// int atol(const char *nptr);
// int fprintf(FILE *stream, const char *format, ...);
// int chown(const char *file, __uid_t owner, __gid_t group);
// int fcntl(int fd, int cmd, ...);
// int execv(const char *path, char *const argv[]);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// int mkdir(const char *path, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __gid_t getgid(void);
// void *memset(void *s, int c, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// char *_xpg_basename(char *path);
// int fgetc(FILE *stream);
// int link(const char *from, const char *to);
// ssize_t write(int fd, const void *buf, size_t n);
// int rand(void);
// int setegid(__gid_t gid);
// ssize_t writev(int fd, const struct iovec *iovec, int count);
// int fclose(FILE *stream);
// int pipe(int pipedes[2]);
// int shutdown(int fd, int how);
// int sigemptyset(sigset_t *set);
// FILE *popen(const char *command, const char *modes);
// int logout(const char *ut_line);
// __pid_t fork(void);
// int putenv(char *string);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// char *strrchr(const char *s, int c);
// int listen(int fd, int n);
// char *crypt(const char *key, const char *salt);
// int fputc(int c, FILE *stream);
// void syslog(int pri, const char *fmt, ...);
// int setuid(__uid_t uid);
// void openlog(const char *ident, int option, int facility);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int atoi(const char *nptr);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
// __mode_t umask(__mode_t mask);
// int chmod(const char *file, __mode_t mode);
int sub_11F04();
// int _xstat64(void); weak
// int fputs(const char *s, FILE *stream);
// int strncmp(const char *s1, const char *s2, size_t n);
// void abort(void);
// void logwtmp(const char *ut_line, const char *ut_name, const char *ut_host);
// int close(int fd);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// struct group *getgrnam(const char *name);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int tcgetattr(int fd, struct termios *termios_p);
// int pclose(FILE *stream);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_120A0();
void *sub_120C4();
__int64 sub_120E8();
void *sub_12114();
int __fastcall sub_12130(int (__fastcall *a1)(int, int, int), int a2, int a3, unsigned int a4);
int __fastcall sub_121B0(int a1);
int sub_121CC(int result, ...);
int sub_12224(int result, ...);
void sub_12288(int *a1, ...);
int __fastcall sub_122E8(int a1, unsigned __int8 *a2, int a3);
void __fastcall sub_12304(int a1, int a2, int a3);
_DWORD *__fastcall sub_12344(unsigned int a1);
void j_free(void *ptr);
int __fastcall sub_1238C(_DWORD *a1);
_DWORD *__fastcall sub_12398(void *a1, unsigned int a2);
void **__fastcall sub_123F4(int a1);
_DWORD *__fastcall sub_12430(_DWORD *result, unsigned int a2);
int __fastcall sub_12464(int result, unsigned int a2);
int __fastcall sub_124A0(int result, unsigned int a2);
_DWORD *__fastcall sub_124C4(_DWORD *result, unsigned int a2);
int __fastcall sub_1250C(int result, int a2);
int __fastcall sub_12560(int a1);
bool __fastcall sub_12590(int a1);
int __fastcall sub_125A4(int result, char a2);
int __fastcall sub_125E4(_DWORD *a1, unsigned int a2);
int __fastcall sub_12624(_DWORD *a1, unsigned int a2);
unsigned int __fastcall sub_12664(_DWORD *a1);
void *__fastcall sub_12690(_DWORD *a1, unsigned int *a2);
_DWORD *__fastcall sub_12708(_DWORD *a1);
int __fastcall sub_12780(_DWORD *a1);
_DWORD *__fastcall sub_1279C(_DWORD *a1, unsigned int a2);
_DWORD *__fastcall sub_127C4(_DWORD *a1, const void *a2, unsigned int a3);
_DWORD *__fastcall sub_127F8(_DWORD *a1, const void *a2, unsigned int a3);
_DWORD *__fastcall sub_12824(_DWORD *a1, int a2);
_DWORD *__fastcall sub_1282C(_DWORD *a1, int a2);
int __fastcall sub_12910(_DWORD *a1, int a2);
_DWORD *__fastcall sub_1299C(unsigned int a1);
void __fastcall sub_129E4(_DWORD *ptr);
int __fastcall sub_12A14(int a1);
int __fastcall sub_12A1C(_DWORD *a1);
unsigned int __fastcall sub_12A2C(unsigned int *a1);
_DWORD *__fastcall sub_12AF4(_DWORD *result, _DWORD *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5);
int __fastcall sub_12B4C(unsigned int *a1, unsigned int a2);
unsigned int __fastcall sub_12B98(unsigned int *a1, unsigned int a2);
unsigned int __fastcall sub_12C00(unsigned int *a1, unsigned int a2);
int sub_12C50();
int __fastcall sub_12C58(void *src, void *dest, size_t a3);
int __fastcall sub_12C84(unsigned int a1, char *a2, int a3, int a4, int a5, unsigned int *a6);
int __fastcall sub_12CAC(const char *a1, size_t a2, const char **a3);
void __fastcall sub_12D00(_DWORD *a1, int a2);
int __fastcall sub_12D8C(_DWORD *a1, int a2, int *a3, _DWORD *a4);
char *__fastcall sub_12F5C(int a1);
int __fastcall sub_12FC4(const char *a1, const char **a2, const char *a3);
int __fastcall sub_13100(void *a1);
int __fastcall sub_131B4(const char *a1);
_DWORD *__fastcall sub_13214(unsigned int *a1, unsigned int a2, unsigned int a3);
int __fastcall sub_13270(int a1, int fd, int how); // idb
_DWORD *__fastcall sub_13354(unsigned int *a1, unsigned int a2, unsigned int a3);
int __fastcall sub_13558(_DWORD *a1);
_DWORD *__fastcall sub_135EC(int a1, int a2, int a3, int a4);
int __fastcall sub_1371C(int a1, int a2, unsigned int *a3, int a4, int *a5);
int __fastcall sub_13964(int *a1);
_DWORD *__fastcall sub_139C0(_DWORD *result, int a2, unsigned int a3);
_DWORD *__fastcall sub_13BE4(unsigned int a1, unsigned int a2);
_DWORD *__fastcall sub_13C4C(int a1);
void sub_13C88();
int sub_13CD0();
int __fastcall sub_13CD8(int a1, int a2);
_DWORD *__fastcall sub_13E28(int a1, unsigned int a2, unsigned int *a3);
int __fastcall sub_13E70(int a1, int a2, int a3);
_DWORD *sub_13FD4();
_DWORD *sub_13FF4();
int __fastcall sub_14018(int result, unsigned int a2, unsigned int *a3);
int sub_14188();
unsigned int sub_141A0();
int __fastcall sub_141E4(int a1, unsigned int a2, unsigned int a3);
_DWORD *__fastcall sub_14310(int a1);
int sub_14340();
_DWORD *__fastcall sub_143A8(int a1);
int __fastcall sub_143D8(int a1, int a2);
int sub_14490();
int sub_1452C();
_DWORD *sub_1455C();
_DWORD *sub_1457C();
_DWORD *sub_1459C();
_DWORD *__fastcall sub_14604(int a1, const char *a2);
int __fastcall sub_1464C(char *a1, unsigned int a2, void *src, char a4);
int sub_14754();
time_t __fastcall sub_149B4(int a1, int a2);
void sub_149E8();
int __fastcall sub_14AF8(int a1);
void **sub_14B10();
_DWORD *sub_14BDC();
void sub_14D28();
void sub_14D68();
time_t __fastcall sub_14D80(int a1, int a2);
int *sub_150E8();
void __fastcall sub_151F0(char *a1);
void **__fastcall sub_15210(int a1, int *a2, int a3);
_DWORD *sub_1532C();
void __fastcall sub_15388(int *a1, int a2, int a3);
void **__fastcall sub_153A0(_DWORD *a1, _DWORD *a2, int a3);
char *sub_15428();
void __fastcall sub_1549C(void *a1);
void **__fastcall sub_154B8(int a1, int a2, int a3);
int __fastcall sub_155A0(int a1, int a2, int *a3);
void sub_15628();
int sub_15740();
int __fastcall sub_15760(int result, int a2, int a3, _DWORD *a4);
time_t sub_15788();
_DWORD *__fastcall sub_157F0(int a1, int a2);
void __fastcall sub_15914(void **a1);
void __fastcall __noreturn sub_15940(int a1, int a2);
void sub_15EF8();
_DWORD *sub_16030();
const char *sub_16064();
const char **__fastcall sub_1608C(char *name);
int sub_1617C();
_DWORD *__fastcall sub_16214(__int64 a1);
size_t __fastcall sub_16388(int a1, char *s, int a3);
char *__fastcall sub_163DC(char *a1, char *s, int a3);
void sub_1645C();
int __fastcall sub_16500(int result, int a2);
_QWORD *__fastcall sub_16568(int a1, int a2);
_QWORD *__fastcall sub_1659C(_QWORD *result, int *a2, int *a3);
unsigned int *__fastcall sub_16B54(unsigned int *result);
__int64 *__fastcall sub_16DC0(__int64 *result);
int __fastcall sub_16F00(int a1, int a2);
int __fastcall sub_16F24(int a1, int a2, int a3);
void *__fastcall sub_16F70(void *a1, int *a2);
void *__fastcall sub_172F4(void *a1, int *a2, int *a3);
int __fastcall sub_17330(int a1, int a2, int *a3);
int __fastcall j_explicit_bzero(_DWORD, _DWORD); // weak
int __fastcall sub_17ED8(unsigned int *a1, const char *a2, unsigned int a3);
int __fastcall sub_1803C(char *a1, unsigned int a2);
int __fastcall sub_18090(char *a1, unsigned int a2);
int sub_18158();
void __fastcall sub_18314(int *a1, int *a2, int a3);
void __fastcall __noreturn sub_183E4(int a1, const char *a2, void *a3);
int __fastcall sub_18430(int a1, char *format, __gnuc_va_list arg); // idb
void __fastcall sub_18478(const char *a1);
void __noreturn sub_18484(const char *a1, ...);
void __noreturn sub_184AC(const char *a1, ...);
void __fastcall __noreturn sub_184D4(const char *a1, const char *a2, int a3);
int sub_184E8(int a1, char *a2, ...);
int __fastcall sub_1851C(_DWORD *a1, FILE *a2);
int __fastcall sub_185B8(int result);
int __fastcall sub_1867C(_DWORD *a1, int a2);
void *__fastcall sub_18718(size_t a1);
int __fastcall sub_18744(char *a1, unsigned int a2, char *path, int a4);
char *__fastcall sub_187FC(const char *a1);
char *__fastcall sub_1886C(const char *a1);
void *__fastcall sub_18888(void *a1, size_t a2);
int *__fastcall sub_188B0(int a1);
int __fastcall sub_188E4(void (__fastcall *a1)(int), int a2, int *a3, _DWORD *a4, _DWORD *a5, int *a6);
int sub_18AA8();
unsigned int __fastcall sub_18AD0(const char *a1, unsigned int *a2);
char *__fastcall sub_18B34(const char *a1);
int __fastcall sub_18BC0(int a1, int a2, int a3);
time_t __fastcall sub_18BF0(int a1, int a2);
void __fastcall sub_18C84(const char *a1);
int __fastcall sub_18CC0(int a1, int a2);
int __fastcall sub_18E20(const char *a1);
void __fastcall sub_18E3C(int a1, unsigned int a2);
int __fastcall sub_18F5C(const char *a1, unsigned int a2);
int __fastcall sub_1903C(signed int a1, const char **a2);
void sub_1928C();
int __fastcall sub_192EC(int a1);
char *__fastcall sub_19338(int a1, int a2);
_DWORD *__fastcall sub_19370(_DWORD *a1, int a2);
char *__fastcall sub_193DC(_DWORD *a1, int a2);
int *__fastcall sub_196E0(int a1, _DWORD *a2);
bool __fastcall sub_197C0(int a1);
int __fastcall sub_197D4(int a1);
_DWORD *__fastcall sub_1982C(int a1);
char *__fastcall sub_198C8(_DWORD *a1, size_t a2, size_t a3);
int *__fastcall sub_199A4(_DWORD *a1, size_t a2, size_t a3);
_DWORD *__fastcall sub_199E8(_DWORD *a1, int a2);
_DWORD *__fastcall sub_19A64(_DWORD *a1, int a2);
void __fastcall sub_19A84(_DWORD *a1, int a2, _DWORD *a3);
int __fastcall sub_19D30(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __fastcall sub_1A1C8(int *a1, int *a2, int *a3, size_t a4);
int **__fastcall sub_1A2D0(unsigned int a1);
int __fastcall sub_1A440(unsigned int a1, int a2);
int __fastcall sub_1A488(unsigned int a1, int a2, const char *a3, int a4);
int __fastcall sub_1A710(_BYTE *a1, char a2, int a3, char a4);
void *__fastcall sub_1A7A8(const char *a1);
int __fastcall sub_1AC04(_BYTE *a1, int a2, int *a3, int *a4, int *a5);
void *__fastcall sub_1AD00(const char *a1, int a2);
int *__fastcall sub_1AD48(const char *a1, int a2, int *a3);
unsigned int __fastcall sub_1B3B8(const char *a1, int *a2, signed int a3, unsigned int a4);
_DWORD *__fastcall sub_1BD84(int *a1, int a2);
_DWORD *sub_1BDCC();
int __fastcall sub_1BDE8(int *a1);
_DWORD *sub_1BE34();
int __fastcall sub_1BE60(int result);
int __fastcall sub_1BED4(int result);
_DWORD *__fastcall sub_1BF64(int *a1, int a2, int a3, int a4, int a5, int a6);
int __fastcall sub_1C088(int a1, int a2, int (__fastcall *a3)(int, _DWORD));
void __fastcall sub_1C0F0(_DWORD *ptr);
void sub_1C14C();
void j_free_0(void *ptr);
int __fastcall sub_1C198(struct timeval a1);
void *__fastcall sub_1C1C4(void *a1, char *a2, size_t a3);
int __fastcall sub_1C248(int a1, int a2, char *a3, char *a4, char *a5);
void *__fastcall sub_1C2EC(int a1, char *a2, char *a3, char *a4);
void *__fastcall sub_1C32C(void *a1, const char *a2, size_t a3);
void *__fastcall sub_1C378(void *a1, const char *a2, size_t a3);
int __fastcall sub_1C3E0(int result, int a2);
void *__fastcall sub_1C3F4(int a1, char *s);
int __fastcall sub_1C4AC(int a1, int a2, int a3);
int __fastcall sub_1C57C(int a1);
int __fastcall sub_1C5B0(int a1);
int __fastcall sub_1C5BC(int a1);
int sub_1C5C8();
int sub_1C5D0();
int sub_1C5D8();
int __fastcall sub_1C5E0(int a1, _DWORD *a2);
unsigned int __fastcall sub_1C610(char *a1, unsigned int a2);
int sub_1C644();
int sub_1C64C();
int sub_1C654();
int __fastcall sub_1C65C(int result, int a2);
void __fastcall sub_1C66C(void *a1, int *a2);
int __fastcall sub_1C6CC(int result);
struct addrinfo **__fastcall sub_1C6E4(const char *a1, const char *a2, struct addrinfo *a3, struct addrinfo *a4, const char *a5, const char *a6);
int sub_1C7FC();
void __fastcall sub_1C820(int a1);
int __fastcall sub_1C90C(int result, int a2);
int __fastcall sub_1C914(int result, int a2, unsigned int *a3);
void __fastcall sub_1C9A0(int a1, int a2);
int __fastcall sub_1C9FC(int a1);
void __fastcall sub_1CA24(int a1);
int __fastcall sub_1CD04(int a1);
int __fastcall sub_1CD30(int fd, int a2);
int __fastcall sub_1CE04(int a1);
int __fastcall sub_1CE9C(const char *a1, const char *a2, int a3, unsigned int a4, char **a5, int *a6);
char *__fastcall sub_1D188(const struct sockaddr *a1, char **a2, char **a3, int a4);
char *__fastcall sub_1D25C(char *fd, char **a2, char **a3, unsigned int a4, char **a5, int a6);
int __fastcall sub_1D318(int result, _DWORD *a2, _DWORD *a3, unsigned int a4, int a5);
void sub_1D3D8();
_DWORD *sub_1D49C();
_DWORD *sub_1D640();
_DWORD *__fastcall sub_1D84C(int a1, char a2);
_DWORD *sub_1D894();
_DWORD *sub_1DB60();
_DWORD *sub_1DBC0();
void sub_1DBF0();
_DWORD *__fastcall sub_1DD3C(_DWORD *result);
bool __fastcall sub_1DD50(_DWORD *a1);
int __fastcall sub_1DD60(int a1);
int __fastcall sub_1DDB8(int a1);
_DWORD *__fastcall sub_1DDE8(int *a1, int a2);
void __fastcall sub_1DE34(int **a1, int a2, int a3);
int __fastcall sub_1DFAC(_DWORD *a1, int *a2);
int __fastcall sub_1E080(_DWORD *a1, int *a2);
void __fastcall sub_1E158(int *a1);
_DWORD *__fastcall sub_1E19C(_DWORD *a1, int *a2);
_DWORD *__fastcall sub_1E1F0(_DWORD *a1, int *a2);
int __fastcall sub_1E254(_DWORD *a1, int **a2, int a3);
int __fastcall sub_1E394(_DWORD *a1, int **a2, int a3);
char *__fastcall sub_1E594(char *a1, unsigned int a2);
_DWORD *sub_1E644();
char *__fastcall sub_1E660(unsigned int a1, size_t *a2);
int __fastcall sub_1E6A8(const void *a1, size_t a2);
int __fastcall sub_1E708(int a1, int a2);
int __fastcall sub_1E74C(_DWORD *a1, int a2, int *a3);
int __fastcall sub_1E858(_DWORD *a1, int a2, int *a3);
void __fastcall sub_1E964(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_1E9F8(_DWORD *a1, int a2, int a3);
void __fastcall sub_1EA60(int a1);
int __fastcall sub_1EAE0(_DWORD, _DWORD); // weak
void __fastcall sub_1EAE4(_DWORD *a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_1EB84(_DWORD *a1, int a2, _DWORD *a3);
int __fastcall sub_1EC44(const void *a1, unsigned int a2, const void *a3, size_t a4, _DWORD *a5, char **a6);
int __fastcall sub_1ED64(int *a1, int *a2, int a3, int a4);
int __fastcall sub_1EDEC(const char *a1);
int __fastcall sub_1EE78(int *a1, const char *a2);
int __fastcall sub_1EFCC(int a1, __int16 a2, int a3, __int16 a4, int a5);
int __fastcall sub_1EFF8(int a1, const char *a2);
_DWORD *__fastcall sub_1F170(int a1, int fd);
int __fastcall sub_1F1B4(int a1, int a2);
void __fastcall sub_1F334(int a1);
void __fastcall sub_1F3AC(int a1);
int __fastcall sub_1F4D4(int a1);
void *sub_1F5A0();
_DWORD *__fastcall sub_1F5E4(int a1);
_DWORD *__fastcall sub_1F628(int a1, unsigned int a2, unsigned int a3);
int sub_1F75C();
_DWORD *__fastcall sub_1FC2C(int a1, unsigned int a2);
int __fastcall sub_1FD5C(const char *a1);
void __fastcall sub_1FDE0(int a1);
int __fastcall sub_20460(_DWORD *a1, char *s);
bool sub_204C4();
bool sub_204E8();
bool sub_2050C();
bool sub_20530();
char *__fastcall sub_20554(char *result);
void sub_205BC();
int __fastcall sub_20604(_DWORD *a1, int a2, const char *a3);
bool __fastcall sub_20868(int a1);
void *__fastcall sub_2087C(int a1, int a2);
int sub_208E8(); // weak
int __fastcall sub_20960(int *a1);
int __fastcall sub_209D0(int a1);
void __fastcall sub_20A54(int a1);
__pid_t __fastcall sub_20C8C(__pid_t result, int a2, int a3);
int sub_20D50();
int __fastcall sub_20DC8(const char *a1, const char *a2);
void __fastcall __noreturn sub_20E48(int a1);
int __fastcall sub_21004(int *a1, int a2, int a3, int a4);
void __fastcall sub_21430(int *a1);
void __fastcall handler(int a1); // idb
int sub_21B5C();
void __fastcall __noreturn sub_21C30(int a1);
int sub_21C54(); // weak
void __noreturn sub_21CCC();
void __fastcall __noreturn sub_22298(unsigned int a1, const char **a2, void *a3, void *a4);
int __fastcall sub_2235C(int result);
const char *__fastcall sub_223A4(const char *result, _DWORD *a2, _DWORD *a3, int a4);
int __fastcall sub_223DC(const char *a1);
void __fastcall sub_22460(const char *a1, int a2);
struct group *__fastcall sub_2257C(unsigned int a1, const char **a2);
void sub_22C28();
_DWORD *__fastcall sub_22D64(const void *a1, unsigned int a2);
void __fastcall sub_22D9C(int a1, size_t a2);
void sub_22E4C();
void __noreturn sub_22E8C();
void __fastcall __noreturn sub_22EC4(__int64 a1, char *a2, char *a3);
void __fastcall __noreturn sub_22FDC(int a1, char *format, __gnuc_va_list arg); // idb
int __fastcall sub_23100(int a1, char *format, __gnuc_va_list arg); // idb
bool __fastcall sub_231E0(int a1, int a2);
int __fastcall sub_23224(struct addrinfo *a1);
void sub_23334();
int __fastcall sub_235A0(int a1);
int __fastcall sub_235B0(int a1);
int __fastcall sub_23610(int a1);
int __fastcall sub_237E8(int result);
void __fastcall sub_238D8(int a1);
_DWORD *__fastcall sub_23914(int a1, int fd);
void __fastcall sub_239BC(int a1);
_DWORD *__fastcall sub_239E8(int a1, int fd);
int __fastcall sub_23B2C(int a1);
int __fastcall sub_23B3C(int a1);
unsigned int __fastcall sub_23C0C(unsigned int a1);
int __fastcall sub_23C50(unsigned int a1);
int sub_23CA8();
int __fastcall sub_23CB4(unsigned int *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_23FC8(unsigned int *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_2437C(unsigned int *a1, int a2, int a3, _DWORD *a4);
int sub_246BC();
int __fastcall sub_246C4(_DWORD *a1, int a2);
int __fastcall sub_248D4(_DWORD *a1, _DWORD *a2);
int __fastcall sub_24A08(int a1);
int __fastcall sub_24A78(unsigned int *a1, char *src, unsigned int a3);
int sub_24BC4();
int __fastcall sub_24BCC(int a1, int a2);
int __fastcall sub_24D6C(unsigned int *a1, _DWORD *a2);
int __fastcall sub_24EA0(int a1);
int __fastcall sub_24F3C(__int64 *a1, char *src, unsigned int a3);
int sub_25088();
int __fastcall sub_25090(int a1);
int __fastcall sub_25170(unsigned int *a1, int a2);
int sub_25208();
int __fastcall sub_25210(int a1, int a2);
int __fastcall sub_25630(unsigned int *a1, int a2);
int __fastcall sub_25784(int a1);
int __fastcall sub_25860(__int64 *a1, char *src, unsigned int a3);
int __fastcall sub_259AC(int a1, int a2, unsigned int *a3);
int __fastcall sub_25B04(int a1, unsigned int a2, const void *a3, size_t a4);
int __fastcall sub_25C88(int a1, int a2, int a3);
int __fastcall sub_25D08(int a1);
int __fastcall sub_25DB8(int *a1, int a2);
int __fastcall sub_25DE8(int *a1, int *a2, int *a3, int *a4);
int __fastcall sub_25E60(int *a1, int *a2, int *a3, int *a4);
int __fastcall sub_25ED8(int *a1, int a2, _DWORD *a3);
int __fastcall sub_25F40(int *a1, int *a2, int a3, int *a4);
int __fastcall sub_25FB8(int *a1, int *a2, int *a3);
int __fastcall sub_2601C(int *a1, int *a2);
int __fastcall sub_26064(int a1, void **a2);
int __fastcall sub_260E8(int *a1, int a2, int *a3);
int __fastcall sub_26148(int *a1, int *a2, int *a3);
int __fastcall sub_261A8(int *a1, int *a2, int *a3, int *a4);
int __fastcall sub_26220(int *a1, int *a2, int *a3, int a4);
int __fastcall sub_26280(int *a1, int *a2, int *a3);
int __fastcall sub_262E0(int a1, unsigned int a2, unsigned int *a3);
int __fastcall sub_26340(int *a1, int *a2);
int __fastcall sub_26388(int *a1, int *a2, int *a3, int *a4);
int __fastcall sub_263D0(int *a1, int *a2);
int __fastcall sub_26418(int *a1, unsigned int a2, int *a3);
int __fastcall sub_26460(int *a1, int *a2, int *a3);
int __fastcall sub_264C0(int *a1, unsigned int a2, int *a3);
int __fastcall sub_26508(int *a1, int *a2, int *a3);
int __fastcall sub_26568(int *a1, unsigned int a2, int *a3);
int __fastcall sub_265B0(int *a1, int *a2, int *a3);
int __fastcall sub_26610(int a1, unsigned __int8 *a2, int a3);
int __fastcall sub_26658(int *a1, _BYTE *a2);
int __fastcall sub_266C8(int *a1, _BYTE *a2, unsigned int a3);
int __fastcall sub_26710(int *a1, _BYTE *a2, signed int a3);
int __fastcall sub_26758(_DWORD *a1, int a2);
int __fastcall sub_267D8(int a1, unsigned int a2);
int __fastcall sub_26820(int *a1, int *a2);
int __fastcall sub_268A4(int *a1, unsigned int a2);
int __fastcall sub_268D4(int *a1, int *a2);
int __fastcall sub_2691C(int *a1, int *a2);
void __fastcall sub_26964(void *a1);
int __fastcall sub_26998(void **a1);
int __fastcall sub_269F8(int **a1, int *a2);
int sub_26A28(int result, ...);
int sub_26ABC(int result, ...);
int sub_26B0C(int result, ...);
int __fastcall sub_26B70(unsigned __int8 *a1, int a2, int a3, _DWORD *a4, int a5);
int __fastcall sub_26CFC(unsigned __int8 *a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_26D14(unsigned __int8 *a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_26D2C(unsigned __int8 *a1, unsigned int a2, _BYTE *a3, unsigned int *a4);
void __fastcall __noreturn sub_26EB8(const char *a1, const char *a2, int a3);
int __fastcall sub_26EE4(const char *a1);
int __fastcall sub_26F50(const char *a1);
int __fastcall sub_26FBC(unsigned int a1);
int __fastcall sub_26FF0(unsigned __int8 *a1);
int __fastcall sub_27098(const void *a1);
int __fastcall sub_27138(int *a1);
int __fastcall j_j_explicit_bzero(_DWORD, _DWORD); // weak
int __fastcall sub_271F8(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int *a4);
int __fastcall sub_27254(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int *a4);
int __fastcall sub_27470(unsigned int a1, char *a2, int a3, int a4, int a5, __int16 a6, unsigned int *a7);
int __fastcall sub_27634(int a1, _BYTE *a2, unsigned int *a3);
int __fastcall sub_277B4(int *a1, int a2, int a3);
int __fastcall sub_277F4(int a1, unsigned int a2, _DWORD *a3, int *a4);
int __fastcall sub_27A60(int a1, unsigned int a2, int a3, _DWORD *a4);
bool __fastcall sub_27AC4(int a1);
int __fastcall sub_27B00(_DWORD *a1, int a2, int a3);
int __fastcall sub_27CC0(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6);
int __fastcall sub_2828C(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5);
void *sub_28738();
void __fastcall sub_2877C(int *a1);
int __fastcall sub_287A0(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5);
int __fastcall sub_29118(_DWORD *a1, _DWORD *a2, int a3, int a4);
int __fastcall sub_29768(unsigned int a1, int a2, int a3, int a4, unsigned int *a5);
int __fastcall sub_2986C(unsigned int a1);
int __fastcall sub_298A0(unsigned int a1);
int __fastcall sub_298D4(_DWORD *a1, int a2);
int __fastcall sub_29934(int *a1, int *a2, int *a3);
int __fastcall sub_2999C(int *a1, unsigned int a2, int *a3);
int __fastcall sub_29B48(int *a1, int *a2, int *a3, int *a4);
int *__fastcall sub_29BBC(int *result);
int __fastcall sub_29D74(int result);
int sub_29DB8(int result, ...);
int __fastcall sub_29E00(int *a1, int *a2);
int __fastcall sub_29E48(int a1, unsigned int a2);
int __fastcall sub_29E8C(int *a1, int *a2);
int __fastcall sub_2A0A4(int *a1);
int __fastcall sub_2A25C(int *a1, int *a2);
int __fastcall sub_2A310(int *a1);
int __fastcall sub_2A350(int *a1, int *a2);
int __fastcall sub_2A5A8(int *a1, int *a2, int *a3, int *a4);
int __fastcall sub_2AAD4(int *a1, int *a2);
int __fastcall sub_2AB08(int *a1, int *a2, int a3, int *a4);
int __fastcall sub_2AC78(int *a1, int *a2, int *a3, int *a4, int a5);
int __fastcall sub_2B818(int *a1, int *a2, int *a3);
int __fastcall sub_2BA48(int a1, int a2);
int __fastcall sub_2BAD0(int a1);
int __fastcall sub_2BB10(int *a1, int *a2);
int __fastcall sub_2BB58(_DWORD *a1, int a2);
int __fastcall sub_2BBA8(int *a1, int a2, int *a3);
int __fastcall sub_2BC30(int *a1, int *a2, int *a3);
int __fastcall sub_2C074(int *a1, int *a2, int *a3, int a4);
int __fastcall sub_2C160(int *a1, int a2);
int __fastcall sub_2C470(int *a1, int *a2, int *a3);
int __fastcall sub_2C51C(int a1, unsigned int a2, int *a3);
int __fastcall sub_2C528(int *a1, int *a2);
int __fastcall sub_2C7D0(int *a1, int *a2, int a3);
int __fastcall sub_2C930(int a1, int *a2);
int __fastcall sub_2C98C(int *a1, int *a2);
int __fastcall sub_2CA58(int *a1, int a2, int *a3);
int __fastcall sub_2CB6C(int *a1, int *a2, int *a3);
int __fastcall sub_2CBE4(int *a1, unsigned int a2, int *a3);
int __fastcall sub_2CCE0(int *a1, int *a2, int *a3, int *a4);
int __fastcall sub_2CD58(int *a1, int *a2);
int __fastcall sub_2CDA4(int *a1, int a2, _DWORD *a3);
int __fastcall sub_2D094(int *a1, int *a2, _DWORD *a3);
int __fastcall sub_2D44C(int a1, int a2, int a3);
int __fastcall sub_2DB1C(int *a1, int a2);
int __fastcall sub_2DCD0(int *a1, _BYTE *a2, signed int a3);
int __fastcall sub_2DE30(int a1, unsigned __int8 *a2, int a3);
int __fastcall sub_2E030(int *a1, int *a2, unsigned int a3);
int __fastcall sub_2E168(int *a1, _DWORD *a2);
int __fastcall sub_2E1FC(int *a1);
int __fastcall sub_2E444(int *a1);
int *__fastcall sub_2E5A0(int *result, int a2);
_DWORD *__fastcall sub_2E630(int a1, int a2);
int __fastcall sub_2E65C(int *a1, unsigned int a2);
int __fastcall sub_2E6C0(int *a1, int *a2);
int __fastcall sub_2E6F8(int *a1, int *a2, int *a3);
int __fastcall sub_2E764(int *a1, int *a2, int *a3);
int __fastcall sub_2E7D4(int *a1, unsigned int a2, int *a3);
int __fastcall sub_2E954(int *a1, int *a2, int *a3, int *a4);
int __fastcall sub_2E9C8(int *a1, _BYTE *a2, unsigned int a3);
int __fastcall sub_2EACC(int *a1, _BYTE *a2);
int __fastcall sub_2EB68(int *a1);
_DWORD *__fastcall sub_2EB8C(_DWORD *result);
_BYTE *__fastcall sub_2EBC4(_BYTE *result, int a2);
int __fastcall sub_2EC08(int *a1, int *a2, int *a3);
int __fastcall sub_2F1F4(int *a1, int *a2, int *a3, int *a4, int a5);
int __fastcall sub_2FCC8(int *a1, int *a2, int *a3, int a4);
int __fastcall sub_3020C(int *a1, int *a2);
int __fastcall sub_307E4(int *a1, int *a2, int *a3);
int __fastcall sub_30DC0(int *a1, int a2, int *a3);
int __fastcall sub_310B4(int *a1, int *a2, int a3);
int __fastcall sub_31AE4(int *a1, _DWORD *a2, int *a3, int a4);
int __fastcall sub_32018(int *a1, int *a2);
int __fastcall sub_329A8(int *a1, int *a2);
int __fastcall sub_329D0(int *a1, int a2, int *a3, int *a4);
int __fastcall sub_32D70(int a1, unsigned int a2, int *a3, int *a4);
int __fastcall sub_32FCC(int *a1);
int __fastcall sub_33110(int *a1, int *a2, unsigned int a3);
int __fastcall sub_33640(int a1, _DWORD *a2);
int __fastcall sub_33654(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, int a11, int a12, int a13, char a14, int a15, int a16, int a17, char a18);
int __fastcall sub_33984(int *a1, int a2, int *a3);
int __fastcall sub_33A60(int a1, _DWORD *a2);
int __fastcall sub_33BD0(int *a1, int *a2, int *a3);
int __fastcall sub_33C9C(int *a1, int *a2);
int __fastcall sub_33D10(int *a1, int *a2, int *a3);
int __fastcall sub_33E88(int *a1, int *a2);
int __fastcall sub_33EC0(int *a1, int *a2, int *a3, int a4);
int __fastcall sub_34400(int *a1, int *a2, int *a3, int a4);
int __fastcall sub_34968(int *a1, int *a2, _DWORD *a3);
unsigned int __fastcall sub_34BA0(unsigned int result, unsigned int a2);
unsigned int __fastcall sub_34DFC(unsigned int a1, unsigned int a2);
int __fastcall sub_34E18(unsigned __int64 a1, unsigned __int64 a2);
int __fastcall sub_34E54(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall init(int a1, int a2, int a3);
int nullsub_3(); // weak
int sub_34FAC();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN loc_34BD8; // weak
_UNKNOWN unk_35338; // weak
int (*off_35368)() = &sub_12C50; // weak
_UNKNOWN unk_35374; // weak
_UNKNOWN unk_356AC; // weak
char *off_356B0 = "ABRT"; // weak
_UNKNOWN unk_363C8; // weak
_UNKNOWN unk_363D0; // weak
_UNKNOWN unk_363D5; // weak
char *off_368C8 = "dropbear_prng"; // weak
_UNKNOWN unk_36B95; // weak
char *off_36C00[4] =
{
  "ssh-rsa",
  "ecdsa-sha2-nistp256",
  "ecdsa-sha2-nistp384",
  "ecdsa-sha2-nistp521"
}; // weak
_UNKNOWN unk_36E3C; // weak
_UNKNOWN unk_38088; // weak
_UNKNOWN unk_380F4; // weak
_UNKNOWN unk_381D4; // weak
unsigned __int8 byte_384C4[4096] =
{
  99u,
  99u,
  99u,
  99u,
  124u,
  124u,
  124u,
  124u,
  119u,
  119u,
  119u,
  119u,
  123u,
  123u,
  123u,
  123u,
  242u,
  242u,
  242u,
  242u,
  107u,
  107u,
  107u,
  107u,
  111u,
  111u,
  111u,
  111u,
  197u,
  197u,
  197u,
  197u,
  48u,
  48u,
  48u,
  48u,
  1u,
  1u,
  1u,
  1u,
  103u,
  103u,
  103u,
  103u,
  43u,
  43u,
  43u,
  43u,
  254u,
  254u,
  254u,
  254u,
  215u,
  215u,
  215u,
  215u,
  171u,
  171u,
  171u,
  171u,
  118u,
  118u,
  118u,
  118u,
  202u,
  202u,
  202u,
  202u,
  130u,
  130u,
  130u,
  130u,
  201u,
  201u,
  201u,
  201u,
  125u,
  125u,
  125u,
  125u,
  250u,
  250u,
  250u,
  250u,
  89u,
  89u,
  89u,
  89u,
  71u,
  71u,
  71u,
  71u,
  240u,
  240u,
  240u,
  240u,
  173u,
  173u,
  173u,
  173u,
  212u,
  212u,
  212u,
  212u,
  162u,
  162u,
  162u,
  162u,
  175u,
  175u,
  175u,
  175u,
  156u,
  156u,
  156u,
  156u,
  164u,
  164u,
  164u,
  164u,
  114u,
  114u,
  114u,
  114u,
  192u,
  192u,
  192u,
  192u,
  183u,
  183u,
  183u,
  183u,
  253u,
  253u,
  253u,
  253u,
  147u,
  147u,
  147u,
  147u,
  38u,
  38u,
  38u,
  38u,
  54u,
  54u,
  54u,
  54u,
  63u,
  63u,
  63u,
  63u,
  247u,
  247u,
  247u,
  247u,
  204u,
  204u,
  204u,
  204u,
  52u,
  52u,
  52u,
  52u,
  165u,
  165u,
  165u,
  165u,
  229u,
  229u,
  229u,
  229u,
  241u,
  241u,
  241u,
  241u,
  113u,
  113u,
  113u,
  113u,
  216u,
  216u,
  216u,
  216u,
  49u,
  49u,
  49u,
  49u,
  21u,
  21u,
  21u,
  21u,
  4u,
  4u,
  4u,
  4u,
  199u,
  199u,
  199u,
  199u,
  35u,
  35u,
  35u,
  35u,
  195u,
  195u,
  195u,
  195u,
  24u,
  24u,
  24u,
  24u,
  150u,
  150u,
  150u,
  150u,
  5u,
  5u,
  5u,
  5u,
  154u,
  154u,
  154u,
  154u,
  7u,
  7u,
  7u,
  7u,
  18u,
  18u,
  18u,
  18u,
  128u,
  128u,
  128u,
  128u,
  226u,
  226u,
  226u,
  226u,
  235u,
  235u,
  235u,
  235u,
  39u,
  39u,
  39u,
  39u,
  178u,
  178u,
  178u,
  178u,
  117u,
  117u,
  117u,
  117u,
  9u,
  9u,
  9u,
  9u,
  131u,
  131u,
  131u,
  131u,
  44u,
  44u,
  44u,
  44u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  110u,
  110u,
  110u,
  110u,
  90u,
  90u,
  90u,
  90u,
  160u,
  160u,
  160u,
  160u,
  82u,
  82u,
  82u,
  82u,
  59u,
  59u,
  59u,
  59u,
  214u,
  214u,
  214u,
  214u,
  179u,
  179u,
  179u,
  179u,
  41u,
  41u,
  41u,
  41u,
  227u,
  227u,
  227u,
  227u,
  47u,
  47u,
  47u,
  47u,
  132u,
  132u,
  132u,
  132u,
  83u,
  83u,
  83u,
  83u,
  209u,
  209u,
  209u,
  209u,
  0u,
  0u,
  0u,
  0u,
  237u,
  237u,
  237u,
  237u,
  32u,
  32u,
  32u,
  32u,
  252u,
  252u,
  252u,
  252u,
  177u,
  177u,
  177u,
  177u,
  91u,
  91u,
  91u,
  91u,
  106u,
  106u,
  106u,
  106u,
  203u,
  203u,
  203u,
  203u,
  190u,
  190u,
  190u,
  190u,
  57u,
  57u,
  57u,
  57u,
  74u,
  74u,
  74u,
  74u,
  76u,
  76u,
  76u,
  76u,
  88u,
  88u,
  88u,
  88u,
  207u,
  207u,
  207u,
  207u,
  208u,
  208u,
  208u,
  208u,
  239u,
  239u,
  239u,
  239u,
  170u,
  170u,
  170u,
  170u,
  251u,
  251u,
  251u,
  251u,
  67u,
  67u,
  67u,
  67u,
  77u,
  77u,
  77u,
  77u,
  51u,
  51u,
  51u,
  51u,
  133u,
  133u,
  133u,
  133u,
  69u,
  69u,
  69u,
  69u,
  249u,
  249u,
  249u,
  249u,
  2u,
  2u,
  2u,
  2u,
  127u,
  127u,
  127u,
  127u,
  80u,
  80u,
  80u,
  80u,
  60u,
  60u,
  60u,
  60u,
  159u,
  159u,
  159u,
  159u,
  168u,
  168u,
  168u,
  168u,
  81u,
  81u,
  81u,
  81u,
  163u,
  163u,
  163u,
  163u,
  64u,
  64u,
  64u,
  64u,
  143u,
  143u,
  143u,
  143u,
  146u,
  146u,
  146u,
  146u,
  157u,
  157u,
  157u,
  157u,
  56u,
  56u,
  56u,
  56u,
  245u,
  245u,
  245u,
  245u,
  188u,
  188u,
  188u,
  188u,
  182u,
  182u,
  182u,
  182u,
  218u,
  218u,
  218u,
  218u,
  33u,
  33u,
  33u,
  33u,
  16u,
  16u,
  16u,
  16u,
  255u,
  255u,
  255u,
  255u,
  243u,
  243u,
  243u,
  243u,
  210u,
  210u,
  210u,
  210u,
  205u,
  205u,
  205u,
  205u,
  12u,
  12u,
  12u,
  12u,
  19u,
  19u,
  19u,
  19u,
  236u,
  236u,
  236u,
  236u,
  95u,
  95u,
  95u,
  95u,
  151u,
  151u,
  151u,
  151u,
  68u,
  68u,
  68u,
  68u,
  23u,
  23u,
  23u,
  23u,
  196u,
  196u,
  196u,
  196u,
  167u,
  167u,
  167u,
  167u,
  126u,
  126u,
  126u,
  126u,
  61u,
  61u,
  61u,
  61u,
  100u,
  100u,
  100u,
  100u,
  93u,
  93u,
  93u,
  93u,
  25u,
  25u,
  25u,
  25u,
  115u,
  115u,
  115u,
  115u,
  96u,
  96u,
  96u,
  96u,
  129u,
  129u,
  129u,
  129u,
  79u,
  79u,
  79u,
  79u,
  220u,
  220u,
  220u,
  220u,
  34u,
  34u,
  34u,
  34u,
  42u,
  42u,
  42u,
  42u,
  144u,
  144u,
  144u,
  144u,
  136u,
  136u,
  136u,
  136u,
  70u,
  70u,
  70u,
  70u,
  238u,
  238u,
  238u,
  238u,
  184u,
  184u,
  184u,
  184u,
  20u,
  20u,
  20u,
  20u,
  222u,
  222u,
  222u,
  222u,
  94u,
  94u,
  94u,
  94u,
  11u,
  11u,
  11u,
  11u,
  219u,
  219u,
  219u,
  219u,
  224u,
  224u,
  224u,
  224u,
  50u,
  50u,
  50u,
  50u,
  58u,
  58u,
  58u,
  58u,
  10u,
  10u,
  10u,
  10u,
  73u,
  73u,
  73u,
  73u,
  6u,
  6u,
  6u,
  6u,
  36u,
  36u,
  36u,
  36u,
  92u,
  92u,
  92u,
  92u,
  194u,
  194u,
  194u,
  194u,
  211u,
  211u,
  211u,
  211u,
  172u,
  172u,
  172u,
  172u,
  98u,
  98u,
  98u,
  98u,
  145u,
  145u,
  145u,
  145u,
  149u,
  149u,
  149u,
  149u,
  228u,
  228u,
  228u,
  228u,
  121u,
  121u,
  121u,
  121u,
  231u,
  231u,
  231u,
  231u,
  200u,
  200u,
  200u,
  200u,
  55u,
  55u,
  55u,
  55u,
  109u,
  109u,
  109u,
  109u,
  141u,
  141u,
  141u,
  141u,
  213u,
  213u,
  213u,
  213u,
  78u,
  78u,
  78u,
  78u,
  169u,
  169u,
  169u,
  169u,
  108u,
  108u,
  108u,
  108u,
  86u,
  86u,
  86u,
  86u,
  244u,
  244u,
  244u,
  244u,
  234u,
  234u,
  234u,
  234u,
  101u,
  101u,
  101u,
  101u,
  122u,
  122u,
  122u,
  122u,
  174u,
  174u,
  174u,
  174u,
  8u,
  8u,
  8u,
  8u,
  186u,
  186u,
  186u,
  186u,
  120u,
  120u,
  120u,
  120u,
  37u,
  37u,
  37u,
  37u,
  46u,
  46u,
  46u,
  46u,
  28u,
  28u,
  28u,
  28u,
  166u,
  166u,
  166u,
  166u,
  180u,
  180u,
  180u,
  180u,
  198u,
  198u,
  198u,
  198u,
  232u,
  232u,
  232u,
  232u,
  221u,
  221u,
  221u,
  221u,
  116u,
  116u,
  116u,
  116u,
  31u,
  31u,
  31u,
  31u,
  75u,
  75u,
  75u,
  75u,
  189u,
  189u,
  189u,
  189u,
  139u,
  139u,
  139u,
  139u,
  138u,
  138u,
  138u,
  138u,
  112u,
  112u,
  112u,
  112u,
  62u,
  62u,
  62u,
  62u,
  181u,
  181u,
  181u,
  181u,
  102u,
  102u,
  102u,
  102u,
  72u,
  72u,
  72u,
  72u,
  3u,
  3u,
  3u,
  3u,
  246u,
  246u,
  246u,
  246u,
  14u,
  14u,
  14u,
  14u,
  97u,
  97u,
  97u,
  97u,
  53u,
  53u,
  53u,
  53u,
  87u,
  87u,
  87u,
  87u,
  185u,
  185u,
  185u,
  185u,
  134u,
  134u,
  134u,
  134u,
  193u,
  193u,
  193u,
  193u,
  29u,
  29u,
  29u,
  29u,
  158u,
  158u,
  158u,
  158u,
  225u,
  225u,
  225u,
  225u,
  248u,
  248u,
  248u,
  248u,
  152u,
  152u,
  152u,
  152u,
  17u,
  17u,
  17u,
  17u,
  105u,
  105u,
  105u,
  105u,
  217u,
  217u,
  217u,
  217u,
  142u,
  142u,
  142u,
  142u,
  148u,
  148u,
  148u,
  148u,
  155u,
  155u,
  155u,
  155u,
  30u,
  30u,
  30u,
  30u,
  135u,
  135u,
  135u,
  135u,
  233u,
  233u,
  233u,
  233u,
  206u,
  206u,
  206u,
  206u,
  85u,
  85u,
  85u,
  85u,
  40u,
  40u,
  40u,
  40u,
  223u,
  223u,
  223u,
  223u,
  140u,
  140u,
  140u,
  140u,
  161u,
  161u,
  161u,
  161u,
  137u,
  137u,
  137u,
  137u,
  13u,
  13u,
  13u,
  13u,
  191u,
  191u,
  191u,
  191u,
  230u,
  230u,
  230u,
  230u,
  66u,
  66u,
  66u,
  66u,
  104u,
  104u,
  104u,
  104u,
  65u,
  65u,
  65u,
  65u,
  153u,
  153u,
  153u,
  153u,
  45u,
  45u,
  45u,
  45u,
  15u,
  15u,
  15u,
  15u,
  176u,
  176u,
  176u,
  176u,
  84u,
  84u,
  84u,
  84u,
  187u,
  187u,
  187u,
  187u,
  22u,
  22u,
  22u,
  22u,
  80u,
  167u,
  244u,
  81u,
  83u,
  101u,
  65u,
  126u,
  195u,
  164u,
  23u,
  26u,
  150u,
  94u,
  39u,
  58u,
  203u,
  107u,
  171u,
  59u,
  241u,
  69u,
  157u,
  31u,
  171u,
  88u,
  250u,
  172u,
  147u,
  3u,
  227u,
  75u,
  85u,
  250u,
  48u,
  32u,
  246u,
  109u,
  118u,
  173u,
  145u,
  118u,
  204u,
  136u,
  37u,
  76u,
  2u,
  245u,
  252u,
  215u,
  229u,
  79u,
  215u,
  203u,
  42u,
  197u,
  128u,
  68u,
  53u,
  38u,
  143u,
  163u,
  98u,
  181u,
  73u,
  90u,
  177u,
  222u,
  103u,
  27u,
  186u,
  37u,
  152u,
  14u,
  234u,
  69u,
  225u,
  192u,
  254u,
  93u,
  2u,
  117u,
  47u,
  195u,
  18u,
  240u,
  76u,
  129u,
  163u,
  151u,
  70u,
  141u,
  198u,
  249u,
  211u,
  107u,
  231u,
  95u,
  143u,
  3u,
  149u,
  156u,
  146u,
  21u,
  235u,
  122u,
  109u,
  191u,
  218u,
  89u,
  82u,
  149u,
  45u,
  131u,
  190u,
  212u,
  211u,
  33u,
  116u,
  88u,
  41u,
  105u,
  224u,
  73u,
  68u,
  200u,
  201u,
  142u,
  106u,
  137u,
  194u,
  117u,
  120u,
  121u,
  142u,
  244u,
  107u,
  62u,
  88u,
  153u,
  221u,
  113u,
  185u,
  39u,
  182u,
  79u,
  225u,
  190u,
  23u,
  173u,
  136u,
  240u,
  102u,
  172u,
  32u,
  201u,
  180u,
  58u,
  206u,
  125u,
  24u,
  74u,
  223u,
  99u,
  130u,
  49u,
  26u,
  229u,
  96u,
  51u,
  81u,
  151u,
  69u,
  127u,
  83u,
  98u,
  224u,
  119u,
  100u,
  177u,
  132u,
  174u,
  107u,
  187u,
  28u,
  160u,
  129u,
  254u,
  148u,
  43u,
  8u,
  249u,
  88u,
  104u,
  72u,
  112u,
  25u,
  253u,
  69u,
  143u,
  135u,
  108u,
  222u,
  148u,
  183u,
  248u,
  123u,
  82u,
  35u,
  211u,
  115u,
  171u,
  226u,
  2u,
  75u,
  114u,
  87u,
  143u,
  31u,
  227u,
  42u,
  171u,
  85u,
  102u,
  7u,
  40u,
  235u,
  178u,
  3u,
  194u,
  181u,
  47u,
  154u,
  123u,
  197u,
  134u,
  165u,
  8u,
  55u,
  211u,
  242u,
  135u,
  40u,
  48u,
  178u,
  165u,
  191u,
  35u,
  186u,
  106u,
  3u,
  2u,
  92u,
  130u,
  22u,
  237u,
  43u,
  28u,
  207u,
  138u,
  146u,
  180u,
  121u,
  167u,
  240u,
  242u,
  7u,
  243u,
  161u,
  226u,
  105u,
  78u,
  205u,
  244u,
  218u,
  101u,
  213u,
  190u,
  5u,
  6u,
  31u,
  98u,
  52u,
  209u,
  138u,
  254u,
  166u,
  196u,
  157u,
  83u,
  46u,
  52u,
  160u,
  85u,
  243u,
  162u,
  50u,
  225u,
  138u,
  5u,
  117u,
  235u,
  246u,
  164u,
  57u,
  236u,
  131u,
  11u,
  170u,
  239u,
  96u,
  64u,
  6u,
  159u,
  113u,
  94u,
  81u,
  16u,
  110u,
  189u,
  249u,
  138u,
  33u,
  62u,
  61u,
  6u,
  221u,
  150u,
  174u,
  5u,
  62u,
  221u,
  70u,
  189u,
  230u,
  77u,
  181u,
  141u,
  84u,
  145u,
  5u,
  93u,
  196u,
  113u,
  111u,
  212u,
  6u,
  4u,
  255u,
  21u,
  80u,
  96u,
  36u,
  251u,
  152u,
  25u,
  151u,
  233u,
  189u,
  214u,
  204u,
  67u,
  64u,
  137u,
  119u,
  158u,
  217u,
  103u,
  189u,
  66u,
  232u,
  176u,
  136u,
  139u,
  137u,
  7u,
  56u,
  91u,
  25u,
  231u,
  219u,
  238u,
  200u,
  121u,
  71u,
  10u,
  124u,
  161u,
  233u,
  15u,
  66u,
  124u,
  201u,
  30u,
  132u,
  248u,
  0u,
  0u,
  0u,
  0u,
  131u,
  134u,
  128u,
  9u,
  72u,
  237u,
  43u,
  50u,
  172u,
  112u,
  17u,
  30u,
  78u,
  114u,
  90u,
  108u,
  251u,
  255u,
  14u,
  253u,
  86u,
  56u,
  133u,
  15u,
  30u,
  213u,
  174u,
  61u,
  39u,
  57u,
  45u,
  54u,
  100u,
  217u,
  15u,
  10u,
  33u,
  166u,
  92u,
  104u,
  209u,
  84u,
  91u,
  155u,
  58u,
  46u,
  54u,
  36u,
  177u,
  103u,
  10u,
  12u,
  15u,
  231u,
  87u,
  147u,
  210u,
  150u,
  238u,
  180u,
  158u,
  145u,
  155u,
  27u,
  79u,
  197u,
  192u,
  128u,
  162u,
  32u,
  220u,
  97u,
  105u,
  75u,
  119u,
  90u,
  22u,
  26u,
  18u,
  28u,
  10u,
  186u,
  147u,
  226u,
  229u,
  42u,
  160u,
  192u,
  67u,
  224u,
  34u,
  60u,
  29u,
  23u,
  27u,
  18u,
  11u,
  13u,
  9u,
  14u,
  173u,
  199u,
  139u,
  242u,
  185u,
  168u,
  182u,
  45u,
  200u,
  169u,
  30u,
  20u,
  133u,
  25u,
  241u,
  87u,
  76u,
  7u,
  117u,
  175u,
  187u,
  221u,
  153u,
  238u,
  253u,
  96u,
  127u,
  163u,
  159u,
  38u,
  1u,
  247u,
  188u,
  245u,
  114u,
  92u,
  197u,
  59u,
  102u,
  68u,
  52u,
  126u,
  251u,
  91u,
  118u,
  41u,
  67u,
  139u,
  220u,
  198u,
  35u,
  203u,
  104u,
  252u,
  237u,
  182u,
  99u,
  241u,
  228u,
  184u,
  202u,
  220u,
  49u,
  215u,
  16u,
  133u,
  99u,
  66u,
  64u,
  34u,
  151u,
  19u,
  32u,
  17u,
  198u,
  132u,
  125u,
  36u,
  74u,
  133u,
  248u,
  61u,
  187u,
  210u,
  17u,
  50u,
  249u,
  174u,
  109u,
  161u,
  41u,
  199u,
  75u,
  47u,
  158u,
  29u,
  243u,
  48u,
  178u,
  220u,
  236u,
  82u,
  134u,
  13u,
  208u,
  227u,
  193u,
  119u,
  108u,
  22u,
  179u,
  43u,
  153u,
  185u,
  112u,
  169u,
  250u,
  72u,
  148u,
  17u,
  34u,
  100u,
  233u,
  71u,
  196u,
  140u,
  252u,
  168u,
  26u,
  63u,
  240u,
  160u,
  216u,
  44u,
  125u,
  86u,
  239u,
  144u,
  51u,
  34u,
  199u,
  78u,
  73u,
  135u,
  193u,
  209u,
  56u,
  217u,
  254u,
  162u,
  202u,
  140u,
  54u,
  11u,
  212u,
  152u,
  207u,
  129u,
  245u,
  166u,
  40u,
  222u,
  122u,
  165u,
  38u,
  142u,
  183u,
  218u,
  164u,
  191u,
  173u,
  63u,
  228u,
  157u,
  58u,
  44u,
  13u,
  146u,
  120u,
  80u,
  155u,
  204u,
  95u,
  106u,
  98u,
  70u,
  126u,
  84u,
  194u,
  19u,
  141u,
  246u,
  232u,
  184u,
  216u,
  144u,
  94u,
  247u,
  57u,
  46u,
  245u,
  175u,
  195u,
  130u,
  190u,
  128u,
  93u,
  159u,
  124u,
  147u,
  208u,
  105u,
  169u,
  45u,
  213u,
  111u,
  179u,
  18u,
  37u,
  207u,
  59u,
  153u,
  172u,
  200u,
  167u,
  125u,
  24u,
  16u,
  110u,
  99u,
  156u,
  232u,
  123u,
  187u,
  59u,
  219u,
  9u,
  120u,
  38u,
  205u,
  244u,
  24u,
  89u,
  110u,
  1u,
  183u,
  154u,
  236u,
  168u,
  154u,
  79u,
  131u,
  101u,
  110u,
  149u,
  230u,
  126u,
  230u,
  255u,
  170u,
  8u,
  207u,
  188u,
  33u,
  230u,
  232u,
  21u,
  239u,
  217u,
  155u,
  231u,
  186u,
  206u,
  54u,
  111u,
  74u,
  212u,
  9u,
  159u,
  234u,
  214u,
  124u,
  176u,
  41u,
  175u,
  178u,
  164u,
  49u,
  49u,
  35u,
  63u,
  42u,
  48u,
  148u,
  165u,
  198u,
  192u,
  102u,
  162u,
  53u,
  55u,
  188u,
  78u,
  116u,
  166u,
  202u,
  130u,
  252u,
  176u,
  208u,
  144u,
  224u,
  21u,
  216u,
  167u,
  51u,
  74u,
  152u,
  4u,
  241u,
  247u,
  218u,
  236u,
  65u,
  14u,
  80u,
  205u,
  127u,
  47u,
  246u,
  145u,
  23u,
  141u,
  214u,
  77u,
  118u,
  77u,
  176u,
  239u,
  67u,
  84u,
  77u,
  170u,
  204u,
  223u,
  4u,
  150u,
  228u,
  227u,
  181u,
  209u,
  158u,
  27u,
  136u,
  106u,
  76u,
  184u,
  31u,
  44u,
  193u,
  127u,
  81u,
  101u,
  70u,
  4u,
  234u,
  94u,
  157u,
  93u,
  53u,
  140u,
  1u,
  115u,
  116u,
  135u,
  250u,
  46u,
  65u,
  11u,
  251u,
  90u,
  29u,
  103u,
  179u,
  82u,
  210u,
  219u,
  146u,
  51u,
  86u,
  16u,
  233u,
  19u,
  71u,
  214u,
  109u,
  140u,
  97u,
  215u,
  154u,
  122u,
  12u,
  161u,
  55u,
  142u,
  20u,
  248u,
  89u,
  137u,
  60u,
  19u,
  235u,
  238u,
  39u,
  169u,
  206u,
  53u,
  201u,
  97u,
  183u,
  237u,
  229u,
  28u,
  225u,
  60u,
  177u,
  71u,
  122u,
  89u,
  223u,
  210u,
  156u,
  63u,
  115u,
  242u,
  85u,
  121u,
  206u,
  20u,
  24u,
  191u,
  55u,
  199u,
  115u,
  234u,
  205u,
  247u,
  83u,
  91u,
  170u,
  253u,
  95u,
  20u,
  111u,
  61u,
  223u,
  134u,
  219u,
  68u,
  120u,
  129u,
  243u,
  175u,
  202u,
  62u,
  196u,
  104u,
  185u,
  44u,
  52u,
  36u,
  56u,
  95u,
  64u,
  163u,
  194u,
  114u,
  195u,
  29u,
  22u,
  12u,
  37u,
  226u,
  188u,
  139u,
  73u,
  60u,
  40u,
  65u,
  149u,
  13u,
  255u,
  113u,
  1u,
  168u,
  57u,
  222u,
  179u,
  12u,
  8u,
  156u,
  228u,
  180u,
  216u,
  144u,
  193u,
  86u,
  100u,
  97u,
  132u,
  203u,
  123u,
  112u,
  182u,
  50u,
  213u,
  116u,
  92u,
  108u,
  72u,
  66u,
  87u,
  184u,
  208u,
  165u,
  99u,
  99u,
  198u,
  132u,
  124u,
  124u,
  248u,
  153u,
  119u,
  119u,
  238u,
  141u,
  123u,
  123u,
  246u,
  13u,
  242u,
  242u,
  255u,
  189u,
  107u,
  107u,
  214u,
  177u,
  111u,
  111u,
  222u,
  84u,
  197u,
  197u,
  145u,
  80u,
  48u,
  48u,
  96u,
  3u,
  1u,
  1u,
  2u,
  169u,
  103u,
  103u,
  206u,
  125u,
  43u,
  43u,
  86u,
  25u,
  254u,
  254u,
  231u,
  98u,
  215u,
  215u,
  181u,
  230u,
  171u,
  171u,
  77u,
  154u,
  118u,
  118u,
  236u,
  69u,
  202u,
  202u,
  143u,
  157u,
  130u,
  130u,
  31u,
  64u,
  201u,
  201u,
  137u,
  135u,
  125u,
  125u,
  250u,
  21u,
  250u,
  250u,
  239u,
  235u,
  89u,
  89u,
  178u,
  201u,
  71u,
  71u,
  142u,
  11u,
  240u,
  240u,
  251u,
  236u,
  173u,
  173u,
  65u,
  103u,
  212u,
  212u,
  179u,
  253u,
  162u,
  162u,
  95u,
  234u,
  175u,
  175u,
  69u,
  191u,
  156u,
  156u,
  35u,
  247u,
  164u,
  164u,
  83u,
  150u,
  114u,
  114u,
  228u,
  91u,
  192u,
  192u,
  155u,
  194u,
  183u,
  183u,
  117u,
  28u,
  253u,
  253u,
  225u,
  174u,
  147u,
  147u,
  61u,
  106u,
  38u,
  38u,
  76u,
  90u,
  54u,
  54u,
  108u,
  65u,
  63u,
  63u,
  126u,
  2u,
  247u,
  247u,
  245u,
  79u,
  204u,
  204u,
  131u,
  92u,
  52u,
  52u,
  104u,
  244u,
  165u,
  165u,
  81u,
  52u,
  229u,
  229u,
  209u,
  8u,
  241u,
  241u,
  249u,
  147u,
  113u,
  113u,
  226u,
  115u,
  216u,
  216u,
  171u,
  83u,
  49u,
  49u,
  98u,
  63u,
  21u,
  21u,
  42u,
  12u,
  4u,
  4u,
  8u,
  82u,
  199u,
  199u,
  149u,
  101u,
  35u,
  35u,
  70u,
  94u,
  195u,
  195u,
  157u,
  40u,
  24u,
  24u,
  48u,
  161u,
  150u,
  150u,
  55u,
  15u,
  5u,
  5u,
  10u,
  181u,
  154u,
  154u,
  47u,
  9u,
  7u,
  7u,
  14u,
  54u,
  18u,
  18u,
  36u,
  155u,
  128u,
  128u,
  27u,
  61u,
  226u,
  226u,
  223u,
  38u,
  235u,
  235u,
  205u,
  105u,
  39u,
  39u,
  78u,
  205u,
  178u,
  178u,
  127u,
  159u,
  117u,
  117u,
  234u,
  27u,
  9u,
  9u,
  18u,
  158u,
  131u,
  131u,
  29u,
  116u,
  44u,
  44u,
  88u,
  46u,
  26u,
  26u,
  52u,
  45u,
  27u,
  27u,
  54u,
  178u,
  110u,
  110u,
  220u,
  238u,
  90u,
  90u,
  180u,
  251u,
  160u,
  160u,
  91u,
  246u,
  82u,
  82u,
  164u,
  77u,
  59u,
  59u,
  118u,
  97u,
  214u,
  214u,
  183u,
  206u,
  179u,
  179u,
  125u,
  123u,
  41u,
  41u,
  82u,
  62u,
  227u,
  227u,
  221u,
  113u,
  47u,
  47u,
  94u,
  151u,
  132u,
  132u,
  19u,
  245u,
  83u,
  83u,
  166u,
  104u,
  209u,
  209u,
  185u,
  0u,
  0u,
  0u,
  0u,
  44u,
  237u,
  237u,
  193u,
  96u,
  32u,
  32u,
  64u,
  31u,
  252u,
  252u,
  227u,
  200u,
  177u,
  177u,
  121u,
  237u,
  91u,
  91u,
  182u,
  190u,
  106u,
  106u,
  212u,
  70u,
  203u,
  203u,
  141u,
  217u,
  190u,
  190u,
  103u,
  75u,
  57u,
  57u,
  114u,
  222u,
  74u,
  74u,
  148u,
  212u,
  76u,
  76u,
  152u,
  232u,
  88u,
  88u,
  176u,
  74u,
  207u,
  207u,
  133u,
  107u,
  208u,
  208u,
  187u,
  42u,
  239u,
  239u,
  197u,
  229u,
  170u,
  170u,
  79u,
  22u,
  251u,
  251u,
  237u,
  197u,
  67u,
  67u,
  134u,
  215u,
  77u,
  77u,
  154u,
  85u,
  51u,
  51u,
  102u,
  148u,
  133u,
  133u,
  17u,
  207u,
  69u,
  69u,
  138u,
  16u,
  249u,
  249u,
  233u,
  6u,
  2u,
  2u,
  4u,
  129u,
  127u,
  127u,
  254u,
  240u,
  80u,
  80u,
  160u,
  68u,
  60u,
  60u,
  120u,
  186u,
  159u,
  159u,
  37u,
  227u,
  168u,
  168u,
  75u,
  243u,
  81u,
  81u,
  162u,
  254u,
  163u,
  163u,
  93u,
  192u,
  64u,
  64u,
  128u,
  138u,
  143u,
  143u,
  5u,
  173u,
  146u,
  146u,
  63u,
  188u,
  157u,
  157u,
  33u,
  72u,
  56u,
  56u,
  112u,
  4u,
  245u,
  245u,
  241u,
  223u,
  188u,
  188u,
  99u,
  193u,
  182u,
  182u,
  119u,
  117u,
  218u,
  218u,
  175u,
  99u,
  33u,
  33u,
  66u,
  48u,
  16u,
  16u,
  32u,
  26u,
  255u,
  255u,
  229u,
  14u,
  243u,
  243u,
  253u,
  109u,
  210u,
  210u,
  191u,
  76u,
  205u,
  205u,
  129u,
  20u,
  12u,
  12u,
  24u,
  53u,
  19u,
  19u,
  38u,
  47u,
  236u,
  236u,
  195u,
  225u,
  95u,
  95u,
  190u,
  162u,
  151u,
  151u,
  53u,
  204u,
  68u,
  68u,
  136u,
  57u,
  23u,
  23u,
  46u,
  87u,
  196u,
  196u,
  147u,
  242u,
  167u,
  167u,
  85u,
  130u,
  126u,
  126u,
  252u,
  71u,
  61u,
  61u,
  122u,
  172u,
  100u,
  100u,
  200u,
  231u,
  93u,
  93u,
  186u,
  43u,
  25u,
  25u,
  50u,
  149u,
  115u,
  115u,
  230u,
  160u,
  96u,
  96u,
  192u,
  152u,
  129u,
  129u,
  25u,
  209u,
  79u,
  79u,
  158u,
  127u,
  220u,
  220u,
  163u,
  102u,
  34u,
  34u,
  68u,
  126u,
  42u,
  42u,
  84u,
  171u,
  144u,
  144u,
  59u,
  131u,
  136u,
  136u,
  11u,
  202u,
  70u,
  70u,
  140u,
  41u,
  238u,
  238u,
  199u,
  211u,
  184u,
  184u,
  107u,
  60u,
  20u,
  20u,
  40u,
  121u,
  222u,
  222u,
  167u,
  226u,
  94u,
  94u,
  188u,
  29u,
  11u,
  11u,
  22u,
  118u,
  219u,
  219u,
  173u,
  59u,
  224u,
  224u,
  219u,
  86u,
  50u,
  50u,
  100u,
  78u,
  58u,
  58u,
  116u,
  30u,
  10u,
  10u,
  20u,
  219u,
  73u,
  73u,
  146u,
  10u,
  6u,
  6u,
  12u,
  108u,
  36u,
  36u,
  72u,
  228u,
  92u,
  92u,
  184u,
  93u,
  194u,
  194u,
  159u,
  110u,
  211u,
  211u,
  189u,
  239u,
  172u,
  172u,
  67u,
  166u,
  98u,
  98u,
  196u,
  168u,
  145u,
  145u,
  57u,
  164u,
  149u,
  149u,
  49u,
  55u,
  228u,
  228u,
  211u,
  139u,
  121u,
  121u,
  242u,
  50u,
  231u,
  231u,
  213u,
  67u,
  200u,
  200u,
  139u,
  89u,
  55u,
  55u,
  110u,
  183u,
  109u,
  109u,
  218u,
  140u,
  141u,
  141u,
  1u,
  100u,
  213u,
  213u,
  177u,
  210u,
  78u,
  78u,
  156u,
  224u,
  169u,
  169u,
  73u,
  180u,
  108u,
  108u,
  216u,
  250u,
  86u,
  86u,
  172u,
  7u,
  244u,
  244u,
  243u,
  37u,
  234u,
  234u,
  207u,
  175u,
  101u,
  101u,
  202u,
  142u,
  122u,
  122u,
  244u,
  233u,
  174u,
  174u,
  71u,
  24u,
  8u,
  8u,
  16u,
  213u,
  186u,
  186u,
  111u,
  136u,
  120u,
  120u,
  240u,
  111u,
  37u,
  37u,
  74u,
  114u,
  46u,
  46u,
  92u,
  36u,
  28u,
  28u,
  56u,
  241u,
  166u,
  166u,
  87u,
  199u,
  180u,
  180u,
  115u,
  81u,
  198u,
  198u,
  151u,
  35u,
  232u,
  232u,
  203u,
  124u,
  221u,
  221u,
  161u,
  156u,
  116u,
  116u,
  232u,
  33u,
  31u,
  31u,
  62u,
  221u,
  75u,
  75u,
  150u,
  220u,
  189u,
  189u,
  97u,
  134u,
  139u,
  139u,
  13u,
  133u,
  138u,
  138u,
  15u,
  144u,
  112u,
  112u,
  224u,
  66u,
  62u,
  62u,
  124u,
  196u,
  181u,
  181u,
  113u,
  170u,
  102u,
  102u,
  204u,
  216u,
  72u,
  72u,
  144u,
  5u,
  3u,
  3u,
  6u,
  1u,
  246u,
  246u,
  247u,
  18u,
  14u,
  14u,
  28u,
  163u,
  97u,
  97u,
  194u,
  95u,
  53u,
  53u,
  106u,
  249u,
  87u,
  87u,
  174u,
  208u,
  185u,
  185u,
  105u,
  145u,
  134u,
  134u,
  23u,
  88u,
  193u,
  193u,
  153u,
  39u,
  29u,
  29u,
  58u,
  185u,
  158u,
  158u,
  39u,
  56u,
  225u,
  225u,
  217u,
  19u,
  248u,
  248u,
  235u,
  179u,
  152u,
  152u,
  43u,
  51u,
  17u,
  17u,
  34u,
  187u,
  105u,
  105u,
  210u,
  112u,
  217u,
  217u,
  169u,
  137u,
  142u,
  142u,
  7u,
  167u,
  148u,
  148u,
  51u,
  182u,
  155u,
  155u,
  45u,
  34u,
  30u,
  30u,
  60u,
  146u,
  135u,
  135u,
  21u,
  32u,
  233u,
  233u,
  201u,
  73u,
  206u,
  206u,
  135u,
  255u,
  85u,
  85u,
  170u,
  120u,
  40u,
  40u,
  80u,
  122u,
  223u,
  223u,
  165u,
  143u,
  140u,
  140u,
  3u,
  248u,
  161u,
  161u,
  89u,
  128u,
  137u,
  137u,
  9u,
  23u,
  13u,
  13u,
  26u,
  218u,
  191u,
  191u,
  101u,
  49u,
  230u,
  230u,
  215u,
  198u,
  66u,
  66u,
  132u,
  184u,
  104u,
  104u,
  208u,
  195u,
  65u,
  65u,
  130u,
  176u,
  153u,
  153u,
  41u,
  119u,
  45u,
  45u,
  90u,
  17u,
  15u,
  15u,
  30u,
  203u,
  176u,
  176u,
  123u,
  252u,
  84u,
  84u,
  168u,
  214u,
  187u,
  187u,
  109u,
  58u,
  22u,
  22u,
  44u,
  82u,
  82u,
  82u,
  82u,
  9u,
  9u,
  9u,
  9u,
  106u,
  106u,
  106u,
  106u,
  213u,
  213u,
  213u,
  213u,
  48u,
  48u,
  48u,
  48u,
  54u,
  54u,
  54u,
  54u,
  165u,
  165u,
  165u,
  165u,
  56u,
  56u,
  56u,
  56u,
  191u,
  191u,
  191u,
  191u,
  64u,
  64u,
  64u,
  64u,
  163u,
  163u,
  163u,
  163u,
  158u,
  158u,
  158u,
  158u,
  129u,
  129u,
  129u,
  129u,
  243u,
  243u,
  243u,
  243u,
  215u,
  215u,
  215u,
  215u,
  251u,
  251u,
  251u,
  251u,
  124u,
  124u,
  124u,
  124u,
  227u,
  227u,
  227u,
  227u,
  57u,
  57u,
  57u,
  57u,
  130u,
  130u,
  130u,
  130u,
  155u,
  155u,
  155u,
  155u,
  47u,
  47u,
  47u,
  47u,
  255u,
  255u,
  255u,
  255u,
  135u,
  135u,
  135u,
  135u,
  52u,
  52u,
  52u,
  52u,
  142u,
  142u,
  142u,
  142u,
  67u,
  67u,
  67u,
  67u,
  68u,
  68u,
  68u,
  68u,
  196u,
  196u,
  196u,
  196u,
  222u,
  222u,
  222u,
  222u,
  233u,
  233u,
  233u,
  233u,
  203u,
  203u,
  203u,
  203u,
  84u,
  84u,
  84u,
  84u,
  123u,
  123u,
  123u,
  123u,
  148u,
  148u,
  148u,
  148u,
  50u,
  50u,
  50u,
  50u,
  166u,
  166u,
  166u,
  166u,
  194u,
  194u,
  194u,
  194u,
  35u,
  35u,
  35u,
  35u,
  61u,
  61u,
  61u,
  61u,
  238u,
  238u,
  238u,
  238u,
  76u,
  76u,
  76u,
  76u,
  149u,
  149u,
  149u,
  149u,
  11u,
  11u,
  11u,
  11u,
  66u,
  66u,
  66u,
  66u,
  250u,
  250u,
  250u,
  250u,
  195u,
  195u,
  195u,
  195u,
  78u,
  78u,
  78u,
  78u,
  8u,
  8u,
  8u,
  8u,
  46u,
  46u,
  46u,
  46u,
  161u,
  161u,
  161u,
  161u,
  102u,
  102u,
  102u,
  102u,
  40u,
  40u,
  40u,
  40u,
  217u,
  217u,
  217u,
  217u,
  36u,
  36u,
  36u,
  36u,
  178u,
  178u,
  178u,
  178u,
  118u,
  118u,
  118u,
  118u,
  91u,
  91u,
  91u,
  91u,
  162u,
  162u,
  162u,
  162u,
  73u,
  73u,
  73u,
  73u,
  109u,
  109u,
  109u,
  109u,
  139u,
  139u,
  139u,
  139u,
  209u,
  209u,
  209u,
  209u,
  37u,
  37u,
  37u,
  37u,
  114u,
  114u,
  114u,
  114u,
  248u,
  248u,
  248u,
  248u,
  246u,
  246u,
  246u,
  246u,
  100u,
  100u,
  100u,
  100u,
  134u,
  134u,
  134u,
  134u,
  104u,
  104u,
  104u,
  104u,
  152u,
  152u,
  152u,
  152u,
  22u,
  22u,
  22u,
  22u,
  212u,
  212u,
  212u,
  212u,
  164u,
  164u,
  164u,
  164u,
  92u,
  92u,
  92u,
  92u,
  204u,
  204u,
  204u,
  204u,
  93u,
  93u,
  93u,
  93u,
  101u,
  101u,
  101u,
  101u,
  182u,
  182u,
  182u,
  182u,
  146u,
  146u,
  146u,
  146u,
  108u,
  108u,
  108u,
  108u,
  112u,
  112u,
  112u,
  112u,
  72u,
  72u,
  72u,
  72u,
  80u,
  80u,
  80u,
  80u,
  253u,
  253u,
  253u,
  253u,
  237u,
  237u,
  237u,
  237u,
  185u,
  185u,
  185u,
  185u,
  218u,
  218u,
  218u,
  218u,
  94u,
  94u,
  94u,
  94u,
  21u,
  21u,
  21u,
  21u,
  70u,
  70u,
  70u,
  70u,
  87u,
  87u,
  87u,
  87u,
  167u,
  167u,
  167u,
  167u,
  141u,
  141u,
  141u,
  141u,
  157u,
  157u,
  157u,
  157u,
  132u,
  132u,
  132u,
  132u,
  144u,
  144u,
  144u,
  144u,
  216u,
  216u,
  216u,
  216u,
  171u,
  171u,
  171u,
  171u,
  0u,
  0u,
  0u,
  0u,
  140u,
  140u,
  140u,
  140u,
  188u,
  188u,
  188u,
  188u,
  211u,
  211u,
  211u,
  211u,
  10u,
  10u,
  10u,
  10u,
  247u,
  247u,
  247u,
  247u,
  228u,
  228u,
  228u,
  228u,
  88u,
  88u,
  88u,
  88u,
  5u,
  5u,
  5u,
  5u,
  184u,
  184u,
  184u,
  184u,
  179u,
  179u,
  179u,
  179u,
  69u,
  69u,
  69u,
  69u,
  6u,
  6u,
  6u,
  6u,
  208u,
  208u,
  208u,
  208u,
  44u,
  44u,
  44u,
  44u,
  30u,
  30u,
  30u,
  30u,
  143u,
  143u,
  143u,
  143u,
  202u,
  202u,
  202u,
  202u,
  63u,
  63u,
  63u,
  63u,
  15u,
  15u,
  15u,
  15u,
  2u,
  2u,
  2u,
  2u,
  193u,
  193u,
  193u,
  193u,
  175u,
  175u,
  175u,
  175u,
  189u,
  189u,
  189u,
  189u,
  3u,
  3u,
  3u,
  3u,
  1u,
  1u,
  1u,
  1u,
  19u,
  19u,
  19u,
  19u,
  138u,
  138u,
  138u,
  138u,
  107u,
  107u,
  107u,
  107u,
  58u,
  58u,
  58u,
  58u,
  145u,
  145u,
  145u,
  145u,
  17u,
  17u,
  17u,
  17u,
  65u,
  65u,
  65u,
  65u,
  79u,
  79u,
  79u,
  79u,
  103u,
  103u,
  103u,
  103u,
  220u,
  220u,
  220u,
  220u,
  234u,
  234u,
  234u,
  234u,
  151u,
  151u,
  151u,
  151u,
  242u,
  242u,
  242u,
  242u,
  207u,
  207u,
  207u,
  207u,
  206u,
  206u,
  206u,
  206u,
  240u,
  240u,
  240u,
  240u,
  180u,
  180u,
  180u,
  180u,
  230u,
  230u,
  230u,
  230u,
  115u,
  115u,
  115u,
  115u,
  150u,
  150u,
  150u,
  150u,
  172u,
  172u,
  172u,
  172u,
  116u,
  116u,
  116u,
  116u,
  34u,
  34u,
  34u,
  34u,
  231u,
  231u,
  231u,
  231u,
  173u,
  173u,
  173u,
  173u,
  53u,
  53u,
  53u,
  53u,
  133u,
  133u,
  133u,
  133u,
  226u,
  226u,
  226u,
  226u,
  249u,
  249u,
  249u,
  249u,
  55u,
  55u,
  55u,
  55u,
  232u,
  232u,
  232u,
  232u,
  28u,
  28u,
  28u,
  28u,
  117u,
  117u,
  117u,
  117u,
  223u,
  223u,
  223u,
  223u,
  110u,
  110u,
  110u,
  110u,
  71u,
  71u,
  71u,
  71u,
  241u,
  241u,
  241u,
  241u,
  26u,
  26u,
  26u,
  26u,
  113u,
  113u,
  113u,
  113u,
  29u,
  29u,
  29u,
  29u,
  41u,
  41u,
  41u,
  41u,
  197u,
  197u,
  197u,
  197u,
  137u,
  137u,
  137u,
  137u,
  111u,
  111u,
  111u,
  111u,
  183u,
  183u,
  183u,
  183u,
  98u,
  98u,
  98u,
  98u,
  14u,
  14u,
  14u,
  14u,
  170u,
  170u,
  170u,
  170u,
  24u,
  24u,
  24u,
  24u,
  190u,
  190u,
  190u,
  190u,
  27u,
  27u,
  27u,
  27u,
  252u,
  252u,
  252u,
  252u,
  86u,
  86u,
  86u,
  86u,
  62u,
  62u,
  62u,
  62u,
  75u,
  75u,
  75u,
  75u,
  198u,
  198u,
  198u,
  198u,
  210u,
  210u,
  210u,
  210u,
  121u,
  121u,
  121u,
  121u,
  32u,
  32u,
  32u,
  32u,
  154u,
  154u,
  154u,
  154u,
  219u,
  219u,
  219u,
  219u,
  192u,
  192u,
  192u,
  192u,
  254u,
  254u,
  254u,
  254u,
  120u,
  120u,
  120u,
  120u,
  205u,
  205u,
  205u,
  205u,
  90u,
  90u,
  90u,
  90u,
  244u,
  244u,
  244u,
  244u,
  31u,
  31u,
  31u,
  31u,
  221u,
  221u,
  221u,
  221u,
  168u,
  168u,
  168u,
  168u,
  51u,
  51u,
  51u,
  51u,
  136u,
  136u,
  136u,
  136u,
  7u,
  7u,
  7u,
  7u,
  199u,
  199u,
  199u,
  199u,
  49u,
  49u,
  49u,
  49u,
  177u,
  177u,
  177u,
  177u,
  18u,
  18u,
  18u,
  18u,
  16u,
  16u,
  16u,
  16u,
  89u,
  89u,
  89u,
  89u,
  39u,
  39u,
  39u,
  39u,
  128u,
  128u,
  128u,
  128u,
  236u,
  236u,
  236u,
  236u,
  95u,
  95u,
  95u,
  95u,
  96u,
  96u,
  96u,
  96u,
  81u,
  81u,
  81u,
  81u,
  127u,
  127u,
  127u,
  127u,
  169u,
  169u,
  169u,
  169u,
  25u,
  25u,
  25u,
  25u,
  181u,
  181u,
  181u,
  181u,
  74u,
  74u,
  74u,
  74u,
  13u,
  13u,
  13u,
  13u,
  45u,
  45u,
  45u,
  45u,
  229u,
  229u,
  229u,
  229u,
  122u,
  122u,
  122u,
  122u,
  159u,
  159u,
  159u,
  159u,
  147u,
  147u,
  147u,
  147u,
  201u,
  201u,
  201u,
  201u,
  156u,
  156u,
  156u,
  156u,
  239u,
  239u,
  239u,
  239u,
  160u,
  160u,
  160u,
  160u,
  224u,
  224u,
  224u,
  224u,
  59u,
  59u,
  59u,
  59u,
  77u,
  77u,
  77u,
  77u,
  174u,
  174u,
  174u,
  174u,
  42u,
  42u,
  42u,
  42u,
  245u,
  245u,
  245u,
  245u,
  176u,
  176u,
  176u,
  176u,
  200u,
  200u,
  200u,
  200u,
  235u,
  235u,
  235u,
  235u,
  187u,
  187u,
  187u,
  187u,
  60u,
  60u,
  60u,
  60u,
  131u,
  131u,
  131u,
  131u,
  83u,
  83u,
  83u,
  83u,
  153u,
  153u,
  153u,
  153u,
  97u,
  97u,
  97u,
  97u,
  23u,
  23u,
  23u,
  23u,
  43u,
  43u,
  43u,
  43u,
  4u,
  4u,
  4u,
  4u,
  126u,
  126u,
  126u,
  126u,
  186u,
  186u,
  186u,
  186u,
  119u,
  119u,
  119u,
  119u,
  214u,
  214u,
  214u,
  214u,
  38u,
  38u,
  38u,
  38u,
  225u,
  225u,
  225u,
  225u,
  105u,
  105u,
  105u,
  105u,
  20u,
  20u,
  20u,
  20u,
  99u,
  99u,
  99u,
  99u,
  85u,
  85u,
  85u,
  85u,
  33u,
  33u,
  33u,
  33u,
  12u,
  12u,
  12u,
  12u,
  125u,
  125u,
  125u,
  125u
}; // weak
_DWORD dword_394C4[10] =
{
  16777216,
  33554432,
  67108864,
  134217728,
  268435456,
  536870912,
  1073741824,
  2147483648,
  452984832,
  905969664
}; // weak
char *off_394EC = "aes"; // weak
_UNKNOWN *off_395A4 = (_UNKNOWN *)0x354A1; // weak
_DWORD dword_39634[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
_UNKNOWN *off_39734 = (_UNKNOWN *)0x35483; // weak
char *off_397B8 = "sha384"; // weak
_UNKNOWN unk_39840; // weak
char *off_39AC0 = "sha512"; // weak
_DWORD dword_39BA4[3] = { 0, 0, -2 }; // weak
char byte_39BBC[4] = { '\xFF', '\0', '\x01', '\0' }; // weak
char *off_39BC0 = "LibTomMath"; // weak
unsigned __int8 byte_39CC3[256] =
{
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  62u,
  255u,
  255u,
  255u,
  63u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  255u,
  255u,
  255u,
  254u,
  255u,
  255u,
  255u,
  0u,
  1u,
  2u,
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  17u,
  18u,
  19u,
  20u,
  21u,
  22u,
  23u,
  24u,
  25u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  26u,
  27u,
  28u,
  29u,
  30u,
  31u,
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u
}; // weak
char aAbcdefghijklmn[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // weak
_DWORD dword_39FBC[79] =
{
  14,
  237752,
  237762,
  237791,
  237820,
  237849,
  237878,
  16,
  237907,
  237917,
  237950,
  237983,
  238016,
  238049,
  20,
  238082,
  238092,
  238133,
  238174,
  238217,
  238258,
  24,
  238299,
  238307,
  238356,
  238405,
  238454,
  238503,
  28,
  238551,
  238559,
  238616,
  238673,
  238730,
  238787,
  32,
  238844,
  238852,
  238917,
  238982,
  239047,
  239112,
  48,
  239177,
  239185,
  239282,
  239379,
  239476,
  239573,
  66,
  239670,
  239678,
  239810,
  239941,
  240073,
  240204,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1346585939,
  1379021105,
  1111752753,
  1093813047,
  842417730,
  1161114437,
  808990262,
  1161967159,
  808600641,
  905986616,
  1178941749,
  809583160,
  825832244,
  1145390390,
  825833541,
  842020657
}; // weak
_DWORD dword_3AC70[16] = { 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0 }; // weak
_UNKNOWN *off_3ACB0 = (_UNKNOWN *)2; // weak
int dword_3ACB4 = 3; // weak
int dword_3ACBC = 7; // weak
int dword_3B0AC = 1619; // weak
_UNKNOWN *off_4BF00 = (_UNKNOWN *)0x1212D; // weak
_UNKNOWN *off_4BF04 = (_UNKNOWN *)0x12115; // weak
char *off_4C22C = "curve25519-sha256"; // weak
_UNKNOWN *off_4C234 = &unk_352C0; // weak
char *off_4C2E0 = "ecdsa-sha2-nistp256"; // weak
char byte_4C2E4 = '\x01'; // weak
char *off_4C344 = "none"; // weak
char *off_4C36C = "hmac-sha1"; // weak
_UNKNOWN *off_4C3A8 = (_UNKNOWN *)0x3583D; // weak
int dword_4C3E4 = -1; // weak
int (__fastcall *off_4C3E8)(int a1, char *format, __gnuc_va_list arg) = &sub_18430; // weak
void (__fastcall __noreturn *off_4C3EC)(int a1, const char *a2, void *a3) = &sub_183E4; // weak
int dword_4C3F0 = -2; // weak
_UNKNOWN *off_4C3F4 = &unk_4C424; // weak
_UNKNOWN unk_4C404; // weak
int dword_4C408 = 0; // weak
_UNKNOWN unk_4C414; // weak
int dword_4C418 = 0; // weak
_UNKNOWN unk_4C424; // weak
int dword_4C428 = 0; // weak
_UNKNOWN *off_4C434 = &unk_3739C; // weak
char *off_4C440 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/"; // weak
_UNKNOWN unk_4C444; // weak
int stderr; // weak
int stdin; // weak
int stdout; // weak
char byte_4C458; // weak
int dword_4C45C; // weak
char byte_4C460[20]; // weak
int dword_4C474; // weak
int dword_4C478; // weak
_DWORD dword_4C47C[130]; // weak
int dword_4C684; // weak
int dword_4C688; // weak
int (__fastcall *off_4C68C)(_DWORD); // weak
int (__fastcall *off_4C694)(_DWORD); // weak
int (__fastcall *off_4C69C)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6A0)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6A8)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6AC)(_DWORD); // weak
int (__fastcall *off_4C6B0)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6B4)(_DWORD); // weak
int (__fastcall *off_4C6C4)(_DWORD, _DWORD, _DWORD); // weak
int (__fastcall *off_4C6CC)(_DWORD); // weak
int (__fastcall *off_4C6D0)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6D4)(_DWORD, _DWORD, _DWORD); // weak
int (__fastcall *off_4C6D8)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6E0)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6E8)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6F0)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C6F4)(_DWORD, _DWORD, _DWORD); // weak
int (__fastcall *off_4C6F8)(_DWORD); // weak
int (__fastcall *off_4C708)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__fastcall *off_4C710)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C714)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C718)(_DWORD, _DWORD); // weak
int (__fastcall *off_4C71C)(_DWORD, _DWORD, _DWORD); // weak
int (__fastcall *off_4C720)(_DWORD); // weak
int (__fastcall *off_4C72C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__fastcall *off_4C730)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__fastcall *off_4C734)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__fastcall *off_4C738)(_DWORD, _DWORD, _DWORD); // weak
_UNKNOWN *off_4C73C; // weak
_DWORD dword_4C754[130]; // weak
_DWORD dword_4C95C[50]; // weak
int dword_4CA24; // weak
int dword_4CA28; // weak
int dword_4CA2C; // weak
int dword_4CA30; // weak
int dword_4CA34; // weak
int dword_4CA38; // weak
int dword_4CA3C; // weak
char byte_4CA40; // weak
int dword_4CA44; // weak
int dword_4CA48; // weak
int dword_4CA4C; // weak
int dword_4CA50; // weak
int dword_4CA54; // weak
int dword_4CA58; // weak
int dword_4CA5C[3]; // weak
int dword_4CA68; // weak
int dword_4CA6C; // weak
int dword_4CA70; // weak
int dword_4CA74; // weak
int dword_4CA78; // weak
int dword_4CA7C; // weak
int dword_4CA80; // weak
char byte_4CA84; // weak
char byte_4CA85; // weak
char byte_4CA86; // weak
char byte_4CA87; // weak
int pipedes[2]; // idb
int dword_4CA8C; // weak
int dword_4CA90; // weak
int dword_4CA94; // weak
int dword_4CA9C; // weak
int dword_4CAA0; // weak
int dword_4CAA4; // weak
int dword_4CAA8; // weak
char byte_4CAAC; // weak
int dword_4CAB0; // weak
int dword_4CAB4; // weak
int dword_4CAB8; // weak
int dword_4CABC; // weak
int dword_4CAC0; // weak
int dword_4CAC4; // weak
int dword_4CAC8; // weak
int dword_4CACC; // weak
int dword_4CAD0; // weak
int dword_4CAD4; // weak
int dword_4CAD8; // weak
int dword_4CADC; // weak
int dword_4CAE0; // weak
int (*off_4CAE4)(void); // weak
_UNKNOWN *off_4CAE8; // weak
_UNKNOWN *off_4CAEC; // weak
int dword_4CAF0; // weak
char byte_4CAF4; // weak
int dword_4CAF8; // weak
int dword_4CAFC; // weak
int dword_4CB00; // weak
int dword_4CB08; // weak
int dword_4CB0C; // weak
int dword_4CB10; // weak
int dword_4CB14; // weak
int dword_4CB18; // weak
int dword_4CB1C; // weak
int dword_4CB20; // weak
int dword_4CB24; // weak
int dword_4CB28; // weak
int dword_4CB2C; // weak
int dword_4CB30; // weak
int dword_4CB34; // weak
int dword_4CB38; // weak
int dword_4CB3C; // weak
int dword_4CB40; // weak
int dword_4CB44; // weak
int dword_4CB48; // weak
int dword_4CB4C[]; // weak
int dword_4CB50; // weak
int dword_4CB54; // weak
_UNKNOWN unk_4CB78; // weak
int dword_4CB7C; // weak
int dword_4CB80; // weak
int dword_4CBA8; // weak
int dword_4CBAC; // weak
int dword_4CBB0; // weak
int dword_4CBB4; // weak
int dword_4CBB8; // weak
int dword_4CBBC; // weak
int dword_4CBC0; // weak
int dword_4CBC4; // weak
int dword_4CBC8; // weak
int dword_4CBCC; // weak
int dword_4CBD0; // weak
int dword_4CBD4; // weak
int dword_4CBE4; // weak
int dword_4CBE8; // weak
int dword_4CBEC; // weak
int dword_4CBF0; // weak
int dword_4CBF4; // weak
int dword_4CBF8; // weak
int dword_4CBFC; // weak
int dword_4CC00; // weak
_BYTE algn_4CC04[12]; // weak
int dword_4CC10; // weak
int dword_4CC14; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0001192C) --------------------------------------------------------
int init_proc()
{
  return sub_120A0();
}

//----- (00011938) --------------------------------------------------------
void sub_11938()
{
  JUMPOUT(0);
}
// 11944: control flows out of bounds to 0

//----- (00011F04) --------------------------------------------------------
// attributes: thunk
int sub_11F04()
{
  return _xstat64();
}
// 11F08: using guessed type int _xstat64(void);

//----- (00011F90) --------------------------------------------------------
int __fastcall main(int a1, char **a2, char **a3, void *a4)
{
  int i; // r4
  char *v7; // r9
  void *v8; // r2

  for ( i = 0; ; i = 1 )
  {
    if ( a1 > i )
    {
      v7 = _xpg_basename(a2[i]);
      if ( !strcmp(v7, "dropbear") )
        sub_22298(a1 - i, (const char **)&a2[i], v8, a4);
      if ( !strcmp(v7, "dropbearkey") )
        return sub_1903C(a1 - i, (const char **)&a2[i]);
      if ( !strcmp(v7, "dropbearconvert") )
        break;
    }
    if ( i == 1 )
    {
      fprintf(
        (FILE *)stderr,
        "Dropbear SSH multi-purpose v%s\n"
        "Make a symlink pointing at this binary with one of the\n"
        "following names or run 'dropbearmulti <command>'.\n"
        "'dropbear' - the Dropbear server\n"
        "'dropbearkey' - the key generator\n"
        "'dropbearconvert' - the key converter\n",
        "2018.76");
      exit(1);
    }
  }
  return sub_18CC0(a1 - i, (int)&a2[i]);
}
// 11FE0: variable 'v8' is possibly undefined
// 4C448: using guessed type int stderr;

//----- (00012070) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_3,
    a1,
    va);
  abort();
}
// 1207A: positive sp value 4 has been found
// 1208C: variable 'v4' is possibly undefined
// 34F6C: using guessed type int init();
// 34FA8: using guessed type int nullsub_3();

//----- (000120A0) --------------------------------------------------------
int sub_120A0()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 11C10: using guessed type int _gmon_start__(void);

//----- (000120C4) --------------------------------------------------------
void *sub_120C4()
{
  return &unk_4C444;
}

//----- (000120E8) --------------------------------------------------------
__int64 sub_120E8()
{
  __int64 result; // r0

  LODWORD(result) = &unk_4C444;
  HIDWORD(result) = 0;
  return result;
}

//----- (00012114) --------------------------------------------------------
void *sub_12114()
{
  void *result; // r0

  if ( !byte_4C458 )
  {
    result = sub_120C4();
    byte_4C458 = 1;
  }
  return result;
}
// 4C458: using guessed type char byte_4C458;

//----- (00012130) --------------------------------------------------------
int __fastcall sub_12130(int (__fastcall *a1)(int, int, int), int a2, int a3, unsigned int a4)
{
  unsigned int v8; // r4
  int v9; // r0
  int v10; // r3
  bool v11; // zf
  int v12; // r3

  v8 = 0;
  while ( v8 < a4 )
  {
    v9 = a1(a2, a3 + v8, a4 - v8);
    if ( v9 == -1 )
    {
      v10 = *_errno_location();
      v11 = v10 == 11;
      if ( v10 != 11 )
        v11 = v10 == 4;
      v12 = v11;
      if ( !v11 )
        return v12;
    }
    else
    {
      if ( !v9 )
      {
        *_errno_location() = 32;
        return v8;
      }
      v8 += v9;
    }
  }
  return v8;
}

//----- (000121B0) --------------------------------------------------------
int __fastcall sub_121B0(int a1)
{
  int result; // r0

  result = sub_2BAD0(a1);
  if ( result )
    sub_184AC("Mem alloc error");
  return result;
}

//----- (000121CC) --------------------------------------------------------
int sub_121CC(int result, ...)
{
  int v1; // kr00_4
  va_list v2; // [sp+4h] [bp-8h]
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, result);
  va_copy(v2, varg_r1);
  while ( result )
  {
    if ( sub_2BAD0(result) )
      sub_184AC("Mem alloc error");
    v1 = va_arg(v2, _DWORD);
    result = v1;
  }
  return result;
}

//----- (00012224) --------------------------------------------------------
int sub_12224(int result, ...)
{
  _DWORD *v1; // r4
  void *v2; // r0
  _DWORD *v3; // kr00_4
  va_list v4; // [sp+4h] [bp-4h]
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, result);
  v1 = (_DWORD *)result;
  va_copy(v4, varg_r1);
  while ( v1 )
  {
    v2 = sub_18718(0x10u);
    *v1 = v2;
    result = sub_2BAD0((int)v2);
    if ( result )
      sub_184AC("Mem alloc error");
    v3 = va_arg(v4, _DWORD *);
    v1 = v3;
  }
  return result;
}

//----- (00012288) --------------------------------------------------------
void sub_12288(int *a1, ...)
{
  int *v2; // kr00_4
  va_list v3; // [sp+4h] [bp-8h]
  va_list varg_r1; // [sp+1Ch] [bp+10h] BYREF

  va_start(varg_r1, a1);
  va_copy(v3, varg_r1);
  while ( a1 )
  {
    if ( *a1 )
      sub_29D74(*a1);
    free((void *)*a1);
    *a1 = 0;
    v2 = va_arg(v3, int *);
    a1 = v2;
  }
}

//----- (000122E8) --------------------------------------------------------
int __fastcall sub_122E8(int a1, unsigned __int8 *a2, int a3)
{
  int result; // r0

  result = sub_2DE30(a1, a2, a3);
  if ( result )
    sub_184AC("Mem alloc error");
  return result;
}

//----- (00012304) --------------------------------------------------------
void __fastcall sub_12304(int a1, int a2, int a3)
{
  _DWORD *v6; // r4

  v6 = sub_12344(0x214u);
  sub_1282C(v6, a3);
  (*(void (__fastcall **)(int, _DWORD, _DWORD))(a1 + 88))(a2, *v6, v6[1]);
  j_free(v6);
}

//----- (00012344) --------------------------------------------------------
_DWORD *__fastcall sub_12344(unsigned int a1)
{
  _DWORD *result; // r0
  _DWORD *v3; // r3

  if ( a1 > 0x3B9ACA00 )
    sub_184AC("buf->size too big");
  result = sub_18718(a1 + 16);
  result[3] = a1;
  if ( a1 )
    v3 = result + 4;
  else
    *result = 0;
  if ( a1 )
    *result = v3;
  return result;
}
// 12378: variable 'v3' is possibly undefined

//----- (0001238C) --------------------------------------------------------
int __fastcall sub_1238C(_DWORD *a1)
{
  return j_explicit_bzero(*a1, a1[3]);
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);

//----- (00012398) --------------------------------------------------------
_DWORD *__fastcall sub_12398(void *a1, unsigned int a2)
{
  _DWORD *result; // r0
  unsigned int v4; // r2
  unsigned int v5; // r2

  if ( a2 > 0x3B9ACA00 )
    sub_184AC("buf->size too big");
  result = sub_18888(a1, a2 + 16);
  result[3] = a2;
  *result = result + 4;
  v4 = result[1];
  if ( v4 > a2 )
    result[1] = a2;
  else
    result[1] = v4;
  v5 = result[2];
  if ( v5 > a2 )
    result[2] = a2;
  else
    result[2] = v5;
  return result;
}

//----- (000123F4) --------------------------------------------------------
void **__fastcall sub_123F4(int a1)
{
  void **v2; // r0
  void **v3; // r5
  size_t v4; // r2

  v2 = (void **)sub_12344(*(_DWORD *)(a1 + 4));
  v3 = v2;
  v2[1] = *(void **)(a1 + 4);
  v4 = *(_DWORD *)(a1 + 4);
  if ( v4 )
    memcpy(*v2, *(const void **)a1, v4);
  return v3;
}

//----- (00012430) --------------------------------------------------------
_DWORD *__fastcall sub_12430(_DWORD *result, unsigned int a2)
{
  unsigned int v2; // r3

  if ( result[3] < a2 )
    sub_184AC("Bad buf_setlen");
  v2 = result[2];
  result[1] = a2;
  if ( v2 > a2 )
    result[2] = a2;
  else
    result[2] = v2;
  return result;
}

//----- (00012464) --------------------------------------------------------
int __fastcall sub_12464(int result, unsigned int a2)
{
  unsigned int v2; // r1

  if ( a2 > 0x3B9ACA00 || (v2 = a2 + *(_DWORD *)(result + 4), v2 > *(_DWORD *)(result + 12)) )
    sub_184AC("Bad buf_incrlen");
  *(_DWORD *)(result + 4) = v2;
  return result;
}

//----- (000124A0) --------------------------------------------------------
int __fastcall sub_124A0(int result, unsigned int a2)
{
  if ( *(_DWORD *)(result + 4) < a2 )
    sub_184AC("Bad buf_setpos");
  *(_DWORD *)(result + 8) = a2;
  return result;
}

//----- (000124C4) --------------------------------------------------------
_DWORD *__fastcall sub_124C4(_DWORD *result, unsigned int a2)
{
  unsigned int v2; // r1
  unsigned int v3; // r3

  if ( a2 > 0x3B9ACA00 || (v2 = a2 + result[2], v2 > result[3]) )
    sub_184AC("Bad buf_incrwritepos");
  v3 = result[1];
  result[2] = v2;
  if ( v2 > v3 )
    result[1] = v2;
  return result;
}

//----- (0001250C) --------------------------------------------------------
int __fastcall sub_1250C(int result, int a2)
{
  unsigned int v2; // r1

  if ( (unsigned int)(a2 + 1000000000) > 0x77359400
    || (v2 = *(_DWORD *)(result + 8) + a2, (v2 > *(_DWORD *)(result + 4)) | (v2 >> 31)) )
  {
    sub_184AC("Bad buf_incrpos");
  }
  *(_DWORD *)(result + 8) = v2;
  return result;
}

//----- (00012560) --------------------------------------------------------
int __fastcall sub_12560(int a1)
{
  __int64 v1; // r2

  v1 = *(_QWORD *)(a1 + 4);
  if ( HIDWORD(v1) >= (unsigned int)v1 )
    sub_184AC("Bad buf_getbyte");
  LODWORD(v1) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 8) = HIDWORD(v1) + 1;
  return *(unsigned __int8 *)(v1 + HIDWORD(v1));
}

//----- (00012590) --------------------------------------------------------
bool __fastcall sub_12590(int a1)
{
  return sub_12560(a1) != 0;
}

//----- (000125A4) --------------------------------------------------------
int __fastcall sub_125A4(int result, char a2)
{
  _DWORD *v2; // r4

  v2 = (_DWORD *)result;
  if ( *(_DWORD *)(result + 8) >= *(_DWORD *)(result + 4) )
    result = sub_12464(result, 1u);
  *(_BYTE *)(*v2 + v2[2]++) = a2;
  return result;
}

//----- (000125E4) --------------------------------------------------------
int __fastcall sub_125E4(_DWORD *a1, unsigned int a2)
{
  int v2; // r3

  if ( a2 > 0x3B9ACA00 || (v2 = a1[2], v2 + a2 > a1[1]) )
    sub_184AC("Bad buf_getptr");
  return *a1 + v2;
}

//----- (00012624) --------------------------------------------------------
int __fastcall sub_12624(_DWORD *a1, unsigned int a2)
{
  int v2; // r3

  if ( a2 > 0x3B9ACA00 || (v2 = a1[2], v2 + a2 > a1[3]) )
    sub_184AC("Bad buf_getwriteptr");
  return *a1 + v2;
}

//----- (00012664) --------------------------------------------------------
unsigned int __fastcall sub_12664(_DWORD *a1)
{
  unsigned int v2; // r4

  v2 = *(_DWORD *)sub_125E4(a1, 4u);
  sub_1250C((int)a1, 4);
  return bswap32(v2);
}

//----- (00012690) --------------------------------------------------------
void *__fastcall sub_12690(_DWORD *a1, unsigned int *a2)
{
  unsigned int v4; // r0
  unsigned int v5; // r4
  void *v6; // r5
  const void *v7; // r0

  v4 = sub_12664(a1);
  if ( v4 > 0x2328 )
    sub_184AC("String too long");
  v5 = v4;
  if ( a2 )
    *a2 = v4;
  v6 = sub_18718(v4 + 1);
  v7 = (const void *)sub_125E4(a1, v5);
  memcpy(v6, v7, v5);
  sub_1250C((int)a1, v5);
  *((_BYTE *)v6 + v5) = 0;
  return v6;
}

//----- (00012708) --------------------------------------------------------
_DWORD *__fastcall sub_12708(_DWORD *a1)
{
  unsigned int v2; // r0
  unsigned int v3; // r4
  _DWORD *v4; // r5
  void *v5; // r7
  const void *v6; // r0

  v2 = sub_12664(a1);
  if ( v2 > 0x2328 )
    sub_184AC("String too long");
  v3 = v2;
  v4 = sub_12344(v2);
  v5 = (void *)sub_12624(v4, v3);
  v6 = (const void *)sub_125E4(a1, v3);
  memcpy(v5, v6, v3);
  sub_1250C((int)a1, v3);
  sub_12464((int)v4, v3);
  return v4;
}

//----- (00012780) --------------------------------------------------------
int __fastcall sub_12780(_DWORD *a1)
{
  unsigned int v2; // r1

  v2 = sub_12664(a1);
  return sub_1250C((int)a1, v2);
}

//----- (0001279C) --------------------------------------------------------
_DWORD *__fastcall sub_1279C(_DWORD *a1, unsigned int a2)
{
  *(_DWORD *)sub_12624(a1, 4u) = bswap32(a2);
  return sub_124C4(a1, 4u);
}

//----- (000127C4) --------------------------------------------------------
_DWORD *__fastcall sub_127C4(_DWORD *a1, const void *a2, unsigned int a3)
{
  void *v6; // r0

  v6 = (void *)sub_12624(a1, a3);
  memcpy(v6, a2, a3);
  return sub_124C4(a1, a3);
}

//----- (000127F8) --------------------------------------------------------
_DWORD *__fastcall sub_127F8(_DWORD *a1, const void *a2, unsigned int a3)
{
  sub_1279C(a1, a3);
  return sub_127C4(a1, a2, a3);
}

//----- (00012824) --------------------------------------------------------
_DWORD *__fastcall sub_12824(_DWORD *a1, int a2)
{
  return sub_127F8(a1, *(const void **)a2, *(_DWORD *)(a2 + 4));
}

//----- (0001282C) --------------------------------------------------------
_DWORD *__fastcall sub_1282C(_DWORD *a1, int a2)
{
  unsigned int v4; // r4
  int v5; // r5
  unsigned int v6; // r0
  bool v7; // zf
  unsigned int v8; // r0
  _DWORD *result; // r0
  unsigned int v10; // r4
  _BYTE *v11; // r0

  if ( !a2 )
    sub_184D4("mp != NULL", "buffer.c", 294);
  if ( *(_DWORD *)(a2 + 8) == 1 )
    sub_184AC("negative bignum");
  if ( *(_DWORD *)a2 != 1 || (v4 = **(_DWORD **)(a2 + 12)) != 0 )
  {
    v6 = sub_2A310((int *)a2);
    v7 = (v6 & 7) == 0;
    v8 = v6 >> 3;
    v5 = v7;
    v4 = v8 + 1;
  }
  else
  {
    v5 = 0;
  }
  result = sub_1279C(a1, v4);
  if ( v4 )
  {
    if ( v5 )
      sub_125A4((int)a1, 0);
    v10 = v4 - v5;
    v11 = (_BYTE *)sub_12624(a1, v10);
    if ( sub_2EACC((int *)a2, v11) )
      sub_184AC("mpint error");
    return sub_124C4(a1, v10);
  }
  return result;
}

//----- (00012910) --------------------------------------------------------
int __fastcall sub_12910(_DWORD *a1, int a2)
{
  unsigned int v4; // r0
  unsigned int v5; // r4
  _DWORD *v6; // r0
  int v7; // r5
  unsigned __int8 *v9; // r0

  v4 = sub_12664(a1);
  v5 = v4;
  if ( v4 )
  {
    if ( v4 > 0x406 )
      return -1;
    if ( *(char *)sub_125E4(a1, 1u) < 0 )
      return -1;
    v9 = (unsigned __int8 *)sub_125E4(a1, v5);
    v7 = sub_2DE30(a2, v9, v5);
    if ( v7 )
      return -1;
    else
      sub_1250C((int)a1, v5);
  }
  else
  {
    v6 = (_DWORD *)a2;
    v7 = 0;
    sub_2EB8C(v6);
  }
  return v7;
}

//----- (0001299C) --------------------------------------------------------
_DWORD *__fastcall sub_1299C(unsigned int a1)
{
  _DWORD *result; // r0

  if ( a1 > 0x5F5E100 )
    sub_184AC("Bad cbuf size");
  result = sub_18718(0x14u);
  *result = a1;
  result[4] = 0;
  result[3] = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (000129E4) --------------------------------------------------------
void __fastcall sub_129E4(_DWORD *ptr)
{
  int v2; // r0

  v2 = ptr[4];
  if ( v2 )
  {
    j_explicit_bzero(v2, *ptr);
    free((void *)ptr[4]);
  }
  free(ptr);
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);

//----- (00012A14) --------------------------------------------------------
int __fastcall sub_12A14(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (00012A1C) --------------------------------------------------------
int __fastcall sub_12A1C(_DWORD *a1)
{
  return *a1 - a1[3];
}

//----- (00012A2C) --------------------------------------------------------
unsigned int __fastcall sub_12A2C(unsigned int *a1)
{
  unsigned int v1; // r7
  unsigned int v2; // r5
  int v3; // r2
  const char *v4; // r0
  unsigned int v5; // r6
  unsigned int v6; // r4
  int v7; // r1
  int v8; // r9
  int v9; // r1
  int v10; // r1
  int v11; // r8
  int v12; // r1

  v1 = a1[3];
  v2 = *a1;
  if ( v1 > *a1 )
  {
    v3 = 73;
    v4 = "cbuf->used <= cbuf->size";
    goto LABEL_3;
  }
  v5 = a1[1];
  v6 = a1[2];
  sub_34DFC(2 * v2 - v5 + v6, *a1);
  v8 = v7;
  sub_34DFC(v1, v2);
  if ( v8 != v9 )
  {
    v3 = 74;
    v4 = "((2*cbuf->size)+cbuf->writepos-cbuf->readpos)%cbuf->size == cbuf->used%cbuf->size";
    goto LABEL_3;
  }
  sub_34DFC(2 * v2 - v6 + v5, v2);
  v11 = v10;
  sub_34DFC(v2 - v1, v2);
  if ( v11 != v12 )
  {
    v3 = 75;
    v4 = "((2*cbuf->size)+cbuf->readpos-cbuf->writepos)%cbuf->size == (cbuf->size-cbuf->used)%cbuf->size";
LABEL_3:
    sub_184D4(v4, "circbuffer.c", v3);
  }
  if ( v1 == v2 )
    return 0;
  if ( v6 >= v5 )
    return v2 - v6;
  return v5 - v6;
}
// 12A70: variable 'v7' is possibly undefined
// 12A80: variable 'v9' is possibly undefined
// 12AA4: variable 'v10' is possibly undefined
// 12AB4: variable 'v12' is possibly undefined

//----- (00012AF4) --------------------------------------------------------
_DWORD *__fastcall sub_12AF4(_DWORD *result, _DWORD *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  int v5; // r4
  unsigned int v6; // r1
  unsigned int v7; // r2
  bool v8; // cf

  v5 = result[1];
  *a2 = result[4] + v5;
  v6 = *result - v5;
  if ( v6 >= result[3] )
    v6 = result[3];
  *a3 = v6;
  v7 = result[3];
  v8 = v6 >= v7;
  if ( v6 >= v7 )
    v7 = 0;
  else
    result = (_DWORD *)result[4];
  if ( v8 )
  {
    *a4 = v7;
    *a5 = v7;
  }
  else
  {
    v6 = v7 - v6;
  }
  if ( !v8 )
  {
    *a4 = (unsigned int)result;
    *a5 = v6;
  }
  return result;
}

//----- (00012B4C) --------------------------------------------------------
int __fastcall sub_12B4C(unsigned int *a1, unsigned int a2)
{
  if ( sub_12A2C(a1) < a2 )
    sub_184AC("Bad cbuf write");
  if ( !a1[4] )
    a1[4] = (unsigned int)sub_18718(*a1);
  return a1[4] + a1[2];
}

//----- (00012B98) --------------------------------------------------------
unsigned int __fastcall sub_12B98(unsigned int *a1, unsigned int a2)
{
  unsigned int v4; // r1
  unsigned int v5; // r3
  bool v6; // cc
  unsigned int result; // r0
  unsigned int v8; // r1

  if ( sub_12A2C(a1) < a2 )
    sub_184AC("Bad cbuf write");
  v4 = *a1;
  v5 = a2 + a1[3];
  v6 = v5 > *a1;
  a1[3] = v5;
  if ( v6 )
    sub_184D4("cbuf->used <= cbuf->size", "circbuffer.c", 124);
  result = sub_34DFC(a2 + a1[2], v4);
  a1[2] = v8;
  return result;
}
// 12BEC: variable 'v8' is possibly undefined

//----- (00012C00) --------------------------------------------------------
unsigned int __fastcall sub_12C00(unsigned int *a1, unsigned int a2)
{
  unsigned int v2; // r3
  unsigned int result; // r0
  unsigned int v5; // r1

  v2 = a1[3];
  if ( v2 < a2 )
    sub_184D4("cbuf->used >= len", "circbuffer.c", 130);
  a1[3] = v2 - a2;
  result = sub_34DFC(a2 + a1[1], *a1);
  a1[1] = v5;
  return result;
}
// 12C40: variable 'v5' is possibly undefined

//----- (00012C50) --------------------------------------------------------
int sub_12C50()
{
  return 0;
}

//----- (00012C58) --------------------------------------------------------
int __fastcall sub_12C58(void *src, void *dest, size_t a3)
{
  if ( src != dest )
    memmove(dest, src, a3);
  return 0;
}

//----- (00012C84) --------------------------------------------------------
int __fastcall sub_12C84(unsigned int a1, char *a2, int a3, int a4, int a5, unsigned int *a6)
{
  return sub_27470(a1, a2, a3, a4, a5, 4096, a6);
}

//----- (00012CAC) --------------------------------------------------------
int __fastcall sub_12CAC(const char *a1, size_t a2, const char **a3)
{
  int result; // r0

  while ( *a3 )
  {
    if ( strlen(*a3) == a2 )
    {
      result = strncmp(*a3, a1, a2);
      if ( !result )
        return result;
    }
    a3 += 5;
  }
  return -1;
}

//----- (00012D00) --------------------------------------------------------
void __fastcall sub_12D00(_DWORD *a1, int a2)
{
  const char **v3; // r4
  const void **v4; // r0
  int v5; // r3
  const void **v6; // r5
  size_t v7; // r0

  v3 = (const char **)(a2 + 12);
  v4 = (const void **)sub_12344(0x12Cu);
  v5 = 0;
  v6 = v4;
  while ( *(v3 - 3) )
  {
    if ( *(_BYTE *)v3 )
    {
      if ( v5 )
        sub_125A4((int)v6, 44);
      v7 = strlen(*(v3 - 3));
      sub_127C4(v6, *(v3 - 3), v7);
      v5 = 1;
    }
    v3 += 5;
  }
  sub_127F8(a1, *v6, (unsigned int)v6[1]);
  j_free(v6);
}

//----- (00012D8C) --------------------------------------------------------
int __fastcall sub_12D8C(_DWORD *a1, int a2, int *a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // r7
  void *v8; // r0
  void *v9; // r9
  _BYTE *v10; // r3
  unsigned int v11; // r10
  _BYTE *v12; // r2
  _DWORD *v13; // r3
  int v14; // r4
  int v15; // r3
  int i; // r11
  __int64 v17; // r4
  const char **v18; // r3
  int v19; // r2
  const char *v20; // r0
  int v21; // r0
  bool v22; // zf
  int v23; // r5
  const char **v25; // [sp+4h] [bp-B0h]
  unsigned int v26; // [sp+Ch] [bp-A8h] BYREF
  _DWORD v27[41]; // [sp+10h] [bp-A4h] BYREF

  v5 = a4;
  v4 = a4 == 0;
  if ( a4 )
    a4 = 0;
  if ( !v4 )
    *v5 = a4;
  v8 = sub_12690(a1, &v26);
  v9 = v8;
  if ( v26 <= 0x514 )
  {
    v27[0] = v8;
    v10 = v8;
    v11 = 1;
    do
    {
      if ( v26 <= v10 - (_BYTE *)v8 )
        break;
      if ( !*v10 )
        goto LABEL_43;
      v12 = v10 + 1;
      if ( *v10 == 44 )
      {
        *v10 = 0;
        v13 = &v27[v11++ + 40];
        *(v13 - 40) = v12;
      }
      v10 = v12;
    }
    while ( v11 <= 0x13 );
    if ( a3 )
    {
      v14 = *a3;
      if ( !*a3 )
      {
        while ( strcmp((const char *)v27[v14], "kexguess2@matt.ucc.asn.au") )
        {
          if ( v11 == ++v14 )
            goto LABEL_16;
        }
        *a3 = 2;
LABEL_16:
        if ( !*a3 )
          *a3 = 1;
      }
    }
    v15 = a2;
    for ( i = 0; ; ++i )
    {
      LODWORD(v17) = *(_DWORD *)v15;
      if ( !*(_DWORD *)v15 )
        break;
      v19 = *(unsigned __int8 *)(v15 + 12);
      v15 += 20;
      if ( !v19 )
        LODWORD(v17) = 0;
      v27[i + 20] = v17;
    }
    v18 = (const char **)v27;
    do
    {
      for ( HIDWORD(v17) = 0; i != HIDWORD(v17); ++HIDWORD(v17) )
      {
        v20 = (const char *)v27[HIDWORD(v17) + 20];
        if ( v20 )
        {
          if ( *v18 )
          {
            v25 = v18;
            v21 = strcmp(v20, *v18);
            v18 = v25;
            if ( !v21 )
            {
              v22 = v5 == 0;
              if ( v5 )
                v22 = a3 == 0;
              if ( !v22 )
              {
                if ( *a3 == 2 )
                {
                  if ( !(_DWORD)v17 )
                    goto LABEL_35;
                }
                else if ( !v17 )
                {
LABEL_35:
                  *v5 = 1;
                }
              }
              v23 = a2 + 20 * HIDWORD(v17);
              goto LABEL_37;
            }
          }
        }
      }
      LODWORD(v17) = v17 + 1;
      ++v18;
    }
    while ( v11 != (_DWORD)v17 );
  }
LABEL_43:
  v23 = 0;
LABEL_37:
  free(v9);
  return v23;
}

//----- (00012F5C) --------------------------------------------------------
char *__fastcall sub_12F5C(int a1)
{
  _DWORD *v2; // r4
  const char *v3; // r0
  char *v4; // r5

  v2 = sub_12344(0xC8u);
  sub_12D00(v2, a1);
  sub_124A0((int)v2, v2[1]);
  sub_125A4((int)v2, 0);
  sub_124A0((int)v2, 4u);
  v3 = (const char *)sub_125E4(v2, v2[1] - v2[2]);
  v4 = sub_1886C(v3);
  j_free(v2);
  return v4;
}

//----- (00012FC4) --------------------------------------------------------
int __fastcall sub_12FC4(const char *a1, const char **a2, const char *a3)
{
  int v4; // r5
  char *v5; // r7
  char *v6; // r6
  const char *v7; // r11
  int v8; // r8
  bool v9; // zf
  const char **v10; // r4
  int v11; // r3
  int v12; // r0
  const char *v13; // r0
  const char **v14; // r12
  const char *v15; // r1
  const char *v16; // r2
  const char *v17; // r3
  int v21; // [sp+Ch] [bp-1B0h]
  _BYTE v22[424]; // [sp+14h] [bp-1A8h] BYREF

  v4 = 0;
  v5 = sub_1886C(a1);
  v6 = v5;
  v7 = v5;
  memset(v22, 0, 0x1A4u);
  while ( 1 )
  {
    v8 = (unsigned __int8)*v6;
    if ( v4 > 19 )
      sub_184AC("Too many algorithms '%s'", a1);
    v9 = v8 == 0;
    if ( *v6 )
      v9 = v8 == 44;
    if ( v9 )
      break;
LABEL_8:
    ++v6;
  }
  v10 = a2;
  *v6 = 0;
  while ( 1 )
  {
    if ( !*v10 )
    {
      sub_184E8(4, "This Dropbear program does not support '%s' %s algorithm", v7, a3);
      goto LABEL_13;
    }
    v11 = strcmp(*v10, v7);
    if ( !v11 )
      break;
    v10 += 5;
  }
  while ( 1 )
  {
    v13 = *(const char **)&v22[v11];
    if ( !v13 )
      break;
    v21 = v11;
    v12 = strcmp(v13, v7);
    v11 = v21 + 20;
    if ( !v12 )
      goto LABEL_13;
  }
  v14 = (const char **)&v22[20 * v4 + 420];
  v15 = v10[1];
  v16 = v10[2];
  v17 = v10[3];
  ++v4;
  v14 -= 105;
  *v14 = *v10;
  v14[1] = v15;
  v14[2] = v16;
  v14[3] = v17;
  v14[4] = v10[4];
LABEL_13:
  ++v6;
  if ( v8 )
  {
    v7 = v6;
    goto LABEL_8;
  }
  free(v5);
  memcpy(a2, v22, 20 * v4 + 20);
  return v4;
}

//----- (00013100) --------------------------------------------------------
int __fastcall sub_13100(void *a1)
{
  _DWORD *v2; // r0
  void (__fastcall *v3)(void *); // r3
  int v4; // r0

  sub_129E4(*((_DWORD **)a1 + 11));
  v2 = (_DWORD *)*((_DWORD *)a1 + 12);
  *((_DWORD *)a1 + 11) = 0;
  if ( v2 )
  {
    sub_129E4(v2);
    *((_DWORD *)a1 + 12) = 0;
  }
  sub_185B8(*((_DWORD *)a1 + 8));
  sub_185B8(*((_DWORD *)a1 + 9));
  sub_185B8(*((_DWORD *)a1 + 10));
  if ( !*((_DWORD *)a1 + 17) )
  {
    v3 = *(void (__fastcall **)(void *))(*((_DWORD *)a1 + 23) + 20);
    if ( v3 )
    {
      v3(a1);
      *((_DWORD *)a1 + 17) = 1;
    }
  }
  v4 = *((_DWORD *)a1 + 18);
  if ( v4 )
    sub_1C6CC(v4);
  *(_DWORD *)(dword_4CB24 + 4 * *(_DWORD *)a1) = 0;
  free(a1);
  --dword_4CB2C;
  return sub_1617C();
}
// 4CB24: using guessed type int dword_4CB24;
// 4CB2C: using guessed type int dword_4CB2C;

//----- (000131B4) --------------------------------------------------------
int __fastcall sub_131B4(const char *a1)
{
  unsigned int v2; // r0
  unsigned int v3; // r2
  int result; // r0

  v2 = sub_12664((_DWORD *)dword_4CA70);
  v3 = v2;
  if ( dword_4CB28 <= v2 || (result = *(_DWORD *)(dword_4CB24 + 4 * v2)) == 0 )
  {
    if ( a1 )
      sub_184AC("%s for unknown channel %d", a1, v3);
    sub_184AC("Unknown channel %d", v3);
  }
  return result;
}
// 4CA70: using guessed type int dword_4CA70;
// 4CB24: using guessed type int dword_4CB24;
// 4CB28: using guessed type int dword_4CB28;

//----- (00013214) --------------------------------------------------------
_DWORD *__fastcall sub_13214(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  sub_125A4(dword_4CA58, 91);
  sub_1279C((_DWORD *)dword_4CA58, a1[1]);
  sub_1279C((_DWORD *)dword_4CA58, *a1);
  sub_1279C((_DWORD *)dword_4CA58, a2);
  sub_1279C((_DWORD *)dword_4CA58, a3);
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;

//----- (00013270) --------------------------------------------------------
int __fastcall sub_13270(int a1, int fd, int how)
{
  int v5; // r6
  int result; // r0

  if ( **(_DWORD **)(a1 + 92) )
  {
    v5 = how;
    result = shutdown(fd, how);
    if ( v5 )
    {
LABEL_3:
      if ( *(_DWORD *)(a1 + 32) == fd )
        *(_DWORD *)(a1 + 32) = -1;
      if ( *(_DWORD *)(a1 + 48) && *(_DWORD *)(a1 + 40) == fd )
        *(_DWORD *)(a1 + 40) = -1;
      goto LABEL_16;
    }
  }
  else
  {
    v5 = 1;
    result = sub_185B8(fd);
  }
  if ( *(_DWORD *)(a1 + 36) == fd )
    *(_DWORD *)(a1 + 36) = -1;
  if ( !*(_DWORD *)(a1 + 48) && *(_DWORD *)(a1 + 40) == fd )
    *(_DWORD *)(a1 + 40) = -1;
  if ( v5 )
    goto LABEL_3;
LABEL_16:
  if ( **(_DWORD **)(a1 + 92) && *(_DWORD *)(a1 + 36) == -1 && *(_DWORD *)(a1 + 32) == -1 && *(_DWORD *)(a1 + 40) == -1 )
    return sub_185B8(fd);
  return result;
}

//----- (00013354) --------------------------------------------------------
_DWORD *__fastcall sub_13354(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // r3
  int v4; // r2
  const char *v5; // r0
  int v8; // r7
  unsigned int v9; // r3
  int v10; // r2
  unsigned int v11; // r6
  _DWORD *result; // r0
  int v13; // r3
  void (__fastcall *v14)(unsigned int *, int, unsigned int *); // r8
  int v15; // r0
  unsigned int v16; // r3
  unsigned int v17; // r3
  char v18; // r1
  unsigned int v19; // r9
  void *v20; // r0
  ssize_t v21; // r0
  unsigned int v22[2]; // [sp+4h] [bp-8h] BYREF

  v3 = a1[13];
  v22[0] = a2;
  v22[1] = a3;
  if ( v3 )
  {
    v4 = 728;
    v5 = "!channel->sent_close";
    goto LABEL_3;
  }
  if ( a2 )
  {
    v8 = a1[10];
    if ( v8 < 0 )
    {
LABEL_6:
      v4 = 736;
      v5 = "fd >= 0";
LABEL_3:
      sub_184D4(v5, "common-channel.c", v4);
    }
    v16 = a1[3];
    v10 = 4;
    v11 = a1[6];
    result = (_DWORD *)dword_4CA58;
    if ( v11 >= v16 )
      v11 = v16;
    v13 = *(_DWORD *)(dword_4CA58 + 12);
  }
  else
  {
    v8 = a1[9];
    if ( v8 < 0 )
      goto LABEL_6;
    v9 = a1[3];
    v10 = 0;
    v11 = a1[6];
    result = (_DWORD *)dword_4CA58;
    if ( v11 >= v9 )
      v11 = v9;
    v13 = *(_DWORD *)(dword_4CA58 + 12);
  }
  v17 = v13 - 9 - v10;
  if ( v17 < v11 )
    v11 = v17;
  if ( v11 )
  {
    if ( a2 )
      v18 = 95;
    else
      v18 = 94;
    sub_125A4((int)result, v18);
    sub_1279C((_DWORD *)dword_4CA58, a1[1]);
    if ( a2 )
      sub_1279C((_DWORD *)dword_4CA58, 1u);
    v19 = *(_DWORD *)(dword_4CA58 + 8);
    sub_1279C((_DWORD *)dword_4CA58, 0);
    v20 = (void *)sub_12624((_DWORD *)dword_4CA58, v11);
    v21 = read(v8, v20, v11);
    v22[0] = v21;
    if ( v21 <= 0 )
    {
      if ( !v21 || *_errno_location() != 4 )
        sub_13270((int)a1, v8, 0);
      goto LABEL_31;
    }
    v14 = (void (__fastcall *)(unsigned int *, int, unsigned int *))a1[22];
    if ( v14 )
    {
      v15 = sub_12624((_DWORD *)dword_4CA58, v21);
      v14(a1, v15, v22);
      if ( !v22[0] )
      {
LABEL_31:
        sub_124A0(dword_4CA58, 0);
        return sub_12430((_DWORD *)dword_4CA58, 0);
      }
    }
    sub_124C4((_DWORD *)dword_4CA58, v22[0]);
    sub_124A0(dword_4CA58, v19);
    sub_1279C((_DWORD *)dword_4CA58, v22[0]);
    a1[3] -= v22[0];
    result = sub_1D894();
    if ( a1[21] && (int)v22[0] < (int)v11 )
      return (_DWORD *)sub_13270((int)a1, v8, 0);
  }
  return result;
}
// 4CA58: using guessed type int dword_4CA58;

//----- (00013558) --------------------------------------------------------
int __fastcall sub_13558(_DWORD *a1)
{
  void (*v2)(void); // r3
  int v3; // r1

  v2 = *(void (**)(void))(a1[23] + 20);
  if ( v2 && !a1[17] )
  {
    v2();
    a1[17] = 1;
  }
  sub_125A4(dword_4CA58, 97);
  sub_1279C((_DWORD *)dword_4CA58, a1[1]);
  sub_1D894();
  v3 = a1[9];
  a1[16] = 1;
  a1[13] = 1;
  sub_13270((int)a1, v3, 0);
  sub_13270((int)a1, a1[10], 2);
  return sub_13270((int)a1, a1[8], 1);
}
// 4CA58: using guessed type int dword_4CA58;

//----- (000135EC) --------------------------------------------------------
_DWORD *__fastcall sub_135EC(int a1, int a2, int a3, int a4)
{
  unsigned int i; // r7
  _DWORD *v9; // r4
  _DWORD *v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // r2
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  int v15; // r3
  int v16; // r3

  for ( i = 0; dword_4CB28 != i; ++i )
  {
    if ( !*(_DWORD *)(dword_4CB24 + 4 * i) )
      goto LABEL_9;
  }
  if ( i >= 0x3E8 )
    return 0;
  v10 = sub_18888((void *)dword_4CB24, 4 * (i + 3));
  v11 = i;
  dword_4CB24 = (int)v10;
  v12 = dword_4CB28 + 3;
  dword_4CB28 += 3;
  while ( v12 > v11 )
    v10[v11++] = 0;
LABEL_9:
  v13 = sub_18718(0x64u);
  v13[1] = a1;
  v9 = v13;
  v13[23] = a2;
  v13[8] = -2;
  v13[9] = -2;
  v13[10] = -1;
  *v13 = i;
  v13[14] = 0;
  v13[13] = 0;
  v13[15] = 0;
  v13[16] = 0;
  v13[17] = 0;
  v13[3] = a3;
  v13[6] = a4;
  v13[7] = 0;
  v13[20] = 0;
  v13[21] = 0;
  v14 = sub_1299C(dword_4CA28);
  v15 = dword_4CA28;
  v9[11] = v14;
  v9[12] = 0;
  v9[2] = v15;
  v9[5] = 32759;
  v9[24] = 3;
  v16 = dword_4CB24;
  v9[4] = 0;
  *(_DWORD *)(v16 + 4 * i) = v9;
  ++dword_4CB2C;
  return v9;
}
// 4CA28: using guessed type int dword_4CA28;
// 4CB24: using guessed type int dword_4CB24;
// 4CB28: using guessed type int dword_4CB28;
// 4CB2C: using guessed type int dword_4CB2C;

//----- (0001371C) --------------------------------------------------------
int __fastcall sub_1371C(int a1, int a2, unsigned int *a3, int a4, int *a5)
{
  int v9; // r2
  __int64 v10; // r0
  _QWORD *v11; // r3
  ssize_t v12; // r8
  int v13; // r3
  bool v14; // zf
  int v15; // r1
  _QWORD *v16; // r3
  int v17; // r6
  unsigned int v18; // r8
  unsigned int v19; // r7
  int v20; // r2
  const char *v21; // r0
  unsigned int v22; // r5
  _DWORD *v23; // r0
  unsigned int v24; // r4
  void *v26; // [sp+8h] [bp-28h] BYREF
  unsigned int v27; // [sp+Ch] [bp-24h] BYREF
  size_t v28; // [sp+10h] [bp-20h] BYREF
  unsigned int v29; // [sp+14h] [bp-1Ch] BYREF
  struct iovec iovec; // [sp+18h] [bp-18h] BYREF
  _QWORD vars0[3]; // [sp+30h] [bp+0h] BYREF

  sub_12AF4(a3, &v26, &v28, &v27, &v29);
  v9 = v28;
  HIDWORD(v10) = v29;
  if ( v28 )
  {
    iovec.iov_len = v28;
    v9 = 1;
    iovec.iov_base = v26;
  }
  if ( v29 )
  {
    LODWORD(v10) = v27;
    v11 = &vars0[v9++];
    *(v11 - 3) = v10;
    if ( !a5 )
      goto LABEL_5;
  }
  else if ( !a5 )
  {
    if ( !v9 )
      goto LABEL_10;
    goto LABEL_5;
  }
  if ( !a4 )
    _assert_fail("moredata", "common-channel.c", 0x1E3u, "writechannel_writev");
  v15 = *a5;
  v16 = &vars0[v9++];
  *((_DWORD *)v16 - 6) = a4;
  *((_DWORD *)v16 - 5) = v15;
  *a5 = 0;
LABEL_5:
  v12 = writev(a2, &iovec, v9);
  if ( v12 >= 0 )
  {
    v22 = v28 + v29;
    if ( v28 + v29 >= v12 )
      v22 = v12;
    sub_12C00(a3, v22);
    if ( a5 )
      *a5 = v12 - v22;
    *(_DWORD *)(a1 + 16) += v12;
  }
  else
  {
    v13 = *_errno_location();
    v14 = v13 == 4;
    if ( v13 != 4 )
      v14 = v13 == 11;
    if ( !v14 )
    {
      v17 = -1;
      sub_13270(a1, a2, 1);
      goto LABEL_15;
    }
  }
LABEL_10:
  v17 = 0;
LABEL_15:
  v18 = *(_DWORD *)(a1 + 16);
  if ( v18 >= dword_4CA28 / 3u )
  {
    sub_125A4(dword_4CA58, 93);
    sub_1279C((_DWORD *)dword_4CA58, *(_DWORD *)(a1 + 4));
    sub_1279C((_DWORD *)dword_4CA58, v18);
    sub_1D894();
    *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = 0;
  }
  v19 = *(_DWORD *)(a1 + 8);
  if ( v19 > dword_4CA28 )
  {
    v20 = 544;
    v21 = "channel->recvwindow <= opts.recv_window";
    goto LABEL_19;
  }
  if ( v19 > sub_12A1C(*(_DWORD **)(a1 + 44)) )
  {
    v20 = 545;
    v21 = "channel->recvwindow <= cbuf_getavail(channel->writebuf)";
    goto LABEL_19;
  }
  v23 = *(_DWORD **)(a1 + 48);
  if ( v23 )
  {
    v24 = *(_DWORD *)(a1 + 8);
    if ( v24 > sub_12A1C(v23) )
    {
      v20 = 547;
      v21 = "channel->extrabuf == NULL || channel->recvwindow <= cbuf_getavail(channel->extrabuf)";
LABEL_19:
      sub_184D4(v21, "common-channel.c", v20);
    }
  }
  return v17;
}
// 4CA28: using guessed type int dword_4CA28;
// 4CA58: using guessed type int dword_4CA58;

//----- (00013964) --------------------------------------------------------
int __fastcall sub_13964(int *a1)
{
  int result; // r0

  if ( a1[8] >= 0 && sub_12A14(a1[11]) )
    return 1;
  if ( a1[10] < 0 )
    return 0;
  result = a1[12];
  if ( result )
    return sub_12A14(result) != 0;
  return result;
}

//----- (000139C0) --------------------------------------------------------
_DWORD *__fastcall sub_139C0(_DWORD *result, int a2, unsigned int a3)
{
  _DWORD *v3; // r4
  int (*v4)(void); // r3
  int (__fastcall *v5)(_DWORD *); // r3
  int v6; // r5
  int v7; // r3

  v3 = result;
  if ( !result[21] && !result[17] )
  {
    v4 = *(int (**)(void))(result[23] + 12);
    if ( !v4 )
    {
LABEL_18:
      v6 = 1;
      goto LABEL_10;
    }
    result = (_DWORD *)v4();
    if ( result )
      v3[21] = 1;
  }
  v5 = *(int (__fastcall **)(_DWORD *))(v3[23] + 12);
  if ( !v5 )
    goto LABEL_18;
  a3 = v3[17];
  if ( a3 )
    goto LABEL_18;
  result = (_DWORD *)v5(v3);
  v6 = (int)result;
  if ( result )
    v6 = 1;
LABEL_10:
  if ( v3[14] && (sub_13964(v3) ? (result = 0) : (result = (_DWORD *)v6), result) )
  {
    if ( !v3[13] )
      sub_13558(v3);
    return (_DWORD *)sub_13100(v3);
  }
  else
  {
    if ( v3[15] && (result = (_DWORD *)sub_13964(v3)) == 0 || (!*(_DWORD *)(v3[23] + 12) ? (v7 = 0) : (v7 = v6), v7) )
      result = (_DWORD *)sub_13270((int)v3, v3[8], 1);
    if ( v3[21] )
    {
      if ( (int)v3[9] >= 0 && v3[3] )
        result = sub_13354(v3, 0, a3);
      if ( !v3[12] && (int)v3[10] >= 0 && v3[3] )
        result = sub_13354(v3, 1u, a3);
    }
    if ( !v3[16] && v3[9] == -1 && (v3[12] || v3[10] == -1) )
    {
      sub_125A4(dword_4CA58, 96);
      sub_1279C((_DWORD *)dword_4CA58, v3[1]);
      result = sub_1D894();
      v3[16] = 1;
    }
    if ( v3[9] == -1 && v3[8] == -1 && (v3[12] || v3[10] == -1) )
    {
      if ( v3[13] )
        v6 = 0;
      if ( v6 )
      {
        result = (_DWORD *)sub_13964(v3);
        if ( !result )
          return (_DWORD *)sub_13558(v3);
      }
    }
  }
  return result;
}
// 13AE0: variable 'a3' is possibly undefined
// 4CA58: using guessed type int dword_4CA58;

//----- (00013BE4) --------------------------------------------------------
_DWORD *__fastcall sub_13BE4(unsigned int a1, unsigned int a2)
{
  sub_125A4(dword_4CA58, 92);
  sub_1279C((_DWORD *)dword_4CA58, a1);
  sub_1279C((_DWORD *)dword_4CA58, a2);
  sub_127F8((_DWORD *)dword_4CA58, "", 0);
  sub_127F8((_DWORD *)dword_4CA58, "", 0);
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;

//----- (00013C4C) --------------------------------------------------------
_DWORD *__fastcall sub_13C4C(int a1)
{
  _DWORD *v2; // r0

  v2 = sub_18718(4u);
  dword_4CB28 = 1;
  dword_4CB24 = (int)v2;
  *v2 = 0;
  dword_4CB30 = a1;
  dword_4CB2C = 0;
  return sub_1BE34();
}
// 4CB24: using guessed type int dword_4CB24;
// 4CB28: using guessed type int dword_4CB28;
// 4CB2C: using guessed type int dword_4CB2C;
// 4CB30: using guessed type int dword_4CB30;

//----- (00013C88) --------------------------------------------------------
void sub_13C88()
{
  unsigned int i; // r4
  void *v1; // r0

  for ( i = 0; dword_4CB28 > i; ++i )
  {
    v1 = *(void **)(dword_4CB24 + 4 * i);
    if ( v1 )
      sub_13100(v1);
  }
  free((void *)dword_4CB24);
  dword_4CB24 = 0;
}
// 4CB24: using guessed type int dword_4CB24;
// 4CB28: using guessed type int dword_4CB28;

//----- (00013CD0) --------------------------------------------------------
int sub_13CD0()
{
  return sub_131B4(0);
}

//----- (00013CD8) --------------------------------------------------------
int __fastcall sub_13CD8(int a1, int a2)
{
  unsigned int i; // r6
  int v6; // r4
  int v7; // r3
  int v8; // r3
  unsigned int v9; // r2
  int v10; // r2
  unsigned int v11; // r2
  int v12; // r1
  unsigned int *v13; // r2

  for ( i = 0; dword_4CB28 > i; ++i )
  {
    v6 = *(_DWORD *)(dword_4CB24 + 4 * i);
    if ( v6 )
    {
      v7 = *(_DWORD *)(v6 + 36);
      if ( v7 >= 0 )
      {
        v9 = *(_DWORD *)(a1 + 4 * (v7 >> 5));
        v8 = v9 & (1 << (v7 & 0x1F));
        if ( v8 )
        {
          sub_13354(*(unsigned int **)(dword_4CB24 + 4 * i), 0, v9);
          v8 = 1;
        }
      }
      else
      {
        v8 = 0;
      }
      if ( !*(_DWORD *)(v6 + 48) )
      {
        v10 = *(_DWORD *)(v6 + 40);
        if ( v10 >= 0 )
        {
          v11 = *(_DWORD *)(a1 + 4 * (v10 >> 5)) & (1 << (v10 & 0x1F));
          if ( v11 )
          {
            sub_13354((unsigned int *)v6, 1u, v11);
            v8 = 1;
          }
        }
      }
      v12 = *(_DWORD *)(v6 + 32);
      if ( v12 >= 0 && (*(_DWORD *)(a2 + 4 * (v12 >> 5)) & (1 << (v12 & 0x1F))) != 0 )
      {
        sub_1371C(v6, v12, *(unsigned int **)(v6 + 44), 0, 0);
        v8 = 1;
      }
      v13 = *(unsigned int **)(v6 + 48);
      if ( v13 )
      {
        v12 = *(_DWORD *)(v6 + 40);
        if ( v12 >= 0 && (*(_DWORD *)(a2 + 4 * (v12 >> 5)) & (1 << (v12 & 0x1F))) != 0 )
        {
          sub_1371C(v6, v12, v13, 0, 0);
          v8 = 1;
        }
      }
      if ( __PAIR64__(v8, dword_4CA90) )
        sub_139C0((_DWORD *)v6, v12, dword_4CA90);
    }
  }
  return sub_1BED4(a1);
}
// 13E18: variable 'v12' is possibly undefined
// 4CA90: using guessed type int dword_4CA90;
// 4CB24: using guessed type int dword_4CB24;
// 4CB28: using guessed type int dword_4CB28;

//----- (00013E28) --------------------------------------------------------
_DWORD *__fastcall sub_13E28(int a1, unsigned int a2, unsigned int *a3)
{
  if ( a1 )
  {
    sub_13BE4(a3[1], 2u);
    return (_DWORD *)sub_13100(a3);
  }
  else
  {
    a3[8] = a2;
    a3[9] = a2;
    a3[18] = 0;
    return sub_13214(a3, a3[2], a3[5]);
  }
}

//----- (00013E70) --------------------------------------------------------
int __fastcall sub_13E70(int a1, int a2, int a3)
{
  unsigned int i; // r6
  _DWORD *v8; // r4
  _BOOL4 v9; // r3
  int v10; // r3
  int v11; // r3
  bool v12; // nf
  int v13; // r2
  int v14; // r1
  int v15; // r3
  int v16; // r0
  int v17; // r2
  int v18; // r1
  int v19; // r3

  for ( i = 0; dword_4CB28 > i; ++i )
  {
    v8 = *(_DWORD **)(dword_4CB24 + 4 * i);
    if ( v8 )
    {
      if ( v8[3] )
      {
        v9 = a3 && byte_4CA84 & 1;
        if ( v9 || v8[22] )
        {
          v10 = v8[9];
          if ( v10 >= 0 )
            *(_DWORD *)(a1 + 4 * (v10 >> 5)) |= 1 << (v10 & 0x1F);
          if ( !v8[12] )
          {
            v11 = v8[10];
            if ( v11 >= 0 )
              *(_DWORD *)(a1 + 4 * (v11 >> 5)) |= 1 << (v11 & 0x1F);
          }
        }
      }
      if ( (int)v8[8] >= 0 && sub_12A14(v8[11]) )
      {
        v15 = v8[8];
        v12 = -v15 < 0;
        v13 = v15 / 32;
        v14 = -v15 & 0x1F;
        LOBYTE(v15) = v15 & 0x1F;
        if ( !v12 )
          v15 = -v14;
        *(_DWORD *)(a2 + 4 * v13) |= 1 << v15;
      }
      v16 = v8[12];
      if ( v16 && (int)v8[10] >= 0 && sub_12A14(v16) )
      {
        v19 = v8[10];
        v12 = -v19 < 0;
        v17 = v19 / 32;
        v18 = -v19 & 0x1F;
        LOBYTE(v19) = v19 & 0x1F;
        if ( !v12 )
          v19 = -v18;
        *(_DWORD *)(a2 + 4 * v17) |= 1 << v19;
      }
    }
  }
  return sub_1BE60(a1);
}
// 4CA84: using guessed type char byte_4CA84;
// 4CB24: using guessed type int dword_4CB24;
// 4CB28: using guessed type int dword_4CB28;

//----- (00013FD4) --------------------------------------------------------
_DWORD *sub_13FD4()
{
  _DWORD *v0; // r0
  int v1; // r1
  unsigned int v2; // r2

  v0 = (_DWORD *)sub_131B4("EOF");
  v0[15] = 1;
  return sub_139C0(v0, v1, v2);
}
// 13FEC: variable 'v1' is possibly undefined
// 13FEC: variable 'v2' is possibly undefined

//----- (00013FF4) --------------------------------------------------------
_DWORD *sub_13FF4()
{
  _DWORD *v0; // r0
  int v1; // r1

  v0 = (_DWORD *)sub_131B4("Close");
  v0[15] = 1;
  v0[14] = 1;
  return sub_139C0(v0, v1, 1u);
}
// 14010: variable 'v1' is possibly undefined

//----- (00014018) --------------------------------------------------------
int __fastcall sub_14018(int result, unsigned int a2, unsigned int *a3)
{
  int v5; // r7
  unsigned int v6; // r4
  unsigned int v7; // r3
  int v8; // r2
  const char *v9; // r0
  unsigned int v10; // r3
  int v11; // r0
  int v12; // r0
  int v13; // r7
  int v14; // r8
  unsigned int v15; // r0
  void *v16; // r8
  const void *v17; // r0
  unsigned int v18; // [sp+Ch] [bp-8h] BYREF

  if ( *(_DWORD *)(result + 60) )
    sub_184AC("Received data after eof");
  if ( !((a3 == 0) | (a2 >> 31)) )
  {
    v5 = result;
    v6 = sub_12664((_DWORD *)dword_4CA70);
    if ( v6 > sub_12A1C(a3) )
      sub_184AC("Oversized packet");
    v7 = *(_DWORD *)(v5 + 8);
    if ( v6 > v7 )
    {
      v8 = 852;
      v9 = "channel->recvwindow >= datalen";
      goto LABEL_8;
    }
    v10 = v7 - v6;
    *(_DWORD *)(v5 + 8) = v10;
    if ( v10 > dword_4CA28 )
    {
      v8 = 854;
      v9 = "channel->recvwindow <= opts.recv_window";
LABEL_8:
      sub_184D4(v9, "common-channel.c", v8);
    }
    v18 = v6;
    v11 = sub_125E4((_DWORD *)dword_4CA70, v6);
    v12 = sub_1371C(v5, a2, a3, v11, (int *)&v18);
    v13 = v18;
    v14 = v12;
    result = sub_1250C(dword_4CA70, v18);
    if ( !v14 )
    {
      while ( 1 )
      {
        v6 -= v13;
        if ( !v6 )
          break;
        v15 = sub_12A2C(a3);
        if ( v15 >= v6 )
          v13 = v6;
        else
          v13 = v15;
        v16 = (void *)sub_12B4C(a3, v13);
        v17 = (const void *)sub_125E4((_DWORD *)dword_4CA70, v13);
        memcpy(v16, v17, v13);
        sub_12B98(a3, v13);
        result = sub_1250C(dword_4CA70, v13);
      }
    }
  }
  return result;
}
// 4CA28: using guessed type int dword_4CA28;
// 4CA70: using guessed type int dword_4CA70;

//----- (00014188) --------------------------------------------------------
int sub_14188()
{
  int v0; // r0

  v0 = sub_13CD0();
  return sub_14018(v0, *(_DWORD *)(v0 + 32), *(unsigned int **)(v0 + 44));
}

//----- (000141A0) --------------------------------------------------------
unsigned int sub_141A0()
{
  int v0; // r4
  unsigned int v1; // r0
  int v2; // r3
  unsigned int result; // r0

  v0 = sub_13CD0();
  v1 = sub_12664((_DWORD *)dword_4CA70);
  v2 = *(_DWORD *)(v0 + 12);
  if ( v1 > 0x1DCD6500 )
    result = v2 + 500000000;
  else
    result = v2 + v1;
  if ( result > 0x1DCD6500 )
    *(_DWORD *)(v0 + 12) = 500000000;
  else
    *(_DWORD *)(v0 + 12) = result;
  return result;
}
// 4CA70: using guessed type int dword_4CA70;

//----- (000141E4) --------------------------------------------------------
int __fastcall sub_141E4(int a1, unsigned int a2, unsigned int a3)
{
  char *v3; // r6
  unsigned int v4; // r7
  unsigned int v5; // r8
  unsigned int v6; // r0
  int v7; // r5
  unsigned int v8; // r9
  int i; // r4
  unsigned int v10; // r4
  int v11; // t1
  int (__fastcall *v12)(_DWORD *); // r3
  int v13; // r0
  unsigned int v14; // r2
  unsigned int v15; // r1
  int v17; // r2
  int v18; // r3
  _DWORD *v19; // r0
  _DWORD *v20; // r5
  unsigned int v21[2]; // [sp+4h] [bp-8h] BYREF

  v21[0] = a2;
  v21[1] = a3;
  v3 = (char *)sub_12690((_DWORD *)dword_4CA70, v21);
  v4 = sub_12664((_DWORD *)dword_4CA70);
  v5 = sub_12664((_DWORD *)dword_4CA70);
  v6 = sub_12664((_DWORD *)dword_4CA70);
  if ( v21[0] <= 0x40 )
  {
    v7 = dword_4CB30;
    v8 = v6;
    for ( i = *(_DWORD *)dword_4CB30; i; i = v11 )
    {
      if ( !strcmp(v3, *(const char **)(i + 4)) )
      {
        v17 = 500000000;
        if ( v8 >= 0x4000 )
          v18 = 0x4000;
        else
          v18 = v8;
        if ( v5 < 0x1DCD6500 )
          v17 = v5;
        v19 = sub_135EC(v4, i, v17, v18);
        v20 = v19;
        if ( !v19 )
        {
          v10 = 4;
          goto LABEL_12;
        }
        v12 = *(int (__fastcall **)(_DWORD *))(v19[23] + 8);
        if ( v12 )
        {
          v13 = v12(v19);
          if ( v13 == 99 )
            goto LABEL_16;
          if ( v13 > 0 )
          {
            v10 = v13;
            sub_13100(v20);
            goto LABEL_12;
          }
        }
        v14 = v20[5];
        v15 = v20[2];
        if ( v20[24] == 3 )
          v20[24] = 2;
        sub_13214(v20, v15, v14);
        goto LABEL_16;
      }
      v11 = *(_DWORD *)(v7 + 4);
      v7 += 4;
    }
  }
  v10 = 3;
LABEL_12:
  sub_13BE4(v4, v10);
LABEL_16:
  free(v3);
  return sub_1617C();
}
// 4CA70: using guessed type int dword_4CA70;
// 4CB30: using guessed type int dword_4CB30;

//----- (00014310) --------------------------------------------------------
_DWORD *__fastcall sub_14310(int a1)
{
  sub_125A4(dword_4CA58, 100);
  sub_1279C((_DWORD *)dword_4CA58, *(_DWORD *)(a1 + 4));
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;

//----- (00014340) --------------------------------------------------------
int sub_14340()
{
  int result; // r0
  int v1; // r4
  int (*v2)(void); // r3

  result = sub_13CD0();
  if ( !*(_DWORD *)(result + 52) )
  {
    v1 = result;
    v2 = *(int (**)(void))(*(_DWORD *)(result + 92) + 16);
    if ( !v2 || *(_DWORD *)(result + 68) )
    {
      sub_12780((_DWORD *)dword_4CA70);
      result = sub_12590(dword_4CA70);
      if ( result )
        return (int)sub_14310(v1);
    }
    else
    {
      return v2();
    }
  }
  return result;
}
// 4CA70: using guessed type int dword_4CA70;

//----- (000143A8) --------------------------------------------------------
_DWORD *__fastcall sub_143A8(int a1)
{
  sub_125A4(dword_4CA58, 99);
  sub_1279C((_DWORD *)dword_4CA58, *(_DWORD *)(a1 + 4));
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;

//----- (000143D8) --------------------------------------------------------
int __fastcall sub_143D8(int a1, int a2)
{
  unsigned int *v4; // r5
  int v5; // r3
  int v6; // r0
  size_t v7; // r0

  v4 = sub_135EC(0, a2, 0, 0);
  if ( !v4 )
    return -1;
  sub_188B0(a1);
  v4[9] = a1;
  v5 = dword_4CA54;
  v4[8] = a1;
  v6 = dword_4CA58;
  if ( v5 < a1 )
    dword_4CA54 = a1;
  else
    dword_4CA54 = v5;
  v4[20] = 1;
  sub_125A4(v6, 90);
  v7 = strlen(*(const char **)(a2 + 4));
  sub_127F8((_DWORD *)dword_4CA58, *(const void **)(a2 + 4), v7);
  sub_1279C((_DWORD *)dword_4CA58, *v4);
  sub_1279C((_DWORD *)dword_4CA58, dword_4CA28);
  sub_1279C((_DWORD *)dword_4CA58, 0x7FF7u);
  return 0;
}
// 4CA28: using guessed type int dword_4CA28;
// 4CA54: using guessed type int dword_4CA54;
// 4CA58: using guessed type int dword_4CA58;

//----- (00014490) --------------------------------------------------------
int sub_14490()
{
  int v0; // r0
  _DWORD *v1; // r4
  unsigned int v2; // r0
  int v3; // r3
  int (__fastcall *v4)(_DWORD *); // r3

  v0 = sub_13CD0();
  if ( !*(_DWORD *)(v0 + 80) )
    sub_184AC("Unexpected channel reply");
  v1 = (_DWORD *)v0;
  *(_DWORD *)(v0 + 80) = 0;
  *(_DWORD *)(v0 + 4) = sub_12664((_DWORD *)dword_4CA70);
  v1[3] = sub_12664((_DWORD *)dword_4CA70);
  v2 = sub_12664((_DWORD *)dword_4CA70);
  v3 = v1[23];
  v1[6] = v2;
  v4 = *(int (__fastcall **)(_DWORD *))(v3 + 8);
  if ( v4 && v4(v1) > 0 )
    return sub_13100(v1);
  if ( v1[24] == 3 )
    v1[24] = 2;
  return sub_1617C();
}
// 4CA70: using guessed type int dword_4CA70;

//----- (0001452C) --------------------------------------------------------
int sub_1452C()
{
  _DWORD *v0; // r0

  v0 = (_DWORD *)sub_13CD0();
  if ( !v0[20] )
    sub_184AC("Unexpected channel reply");
  v0[20] = 0;
  return sub_13100(v0);
}

//----- (0001455C) --------------------------------------------------------
_DWORD *sub_1455C()
{
  sub_125A4(dword_4CA58, 81);
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;

//----- (0001457C) --------------------------------------------------------
_DWORD *sub_1457C()
{
  sub_125A4(dword_4CA58, 82);
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;

//----- (0001459C) --------------------------------------------------------
_DWORD *sub_1459C()
{
  _DWORD *result; // r0
  int i; // r3

  result = (_DWORD *)dword_4CB2C;
  if ( dword_4CB2C )
  {
    for ( i = 0; dword_4CB28 != i; ++i )
    {
      result = *(_DWORD **)(dword_4CB24 + 4 * i);
      if ( result && !result[16] && !result[15] && !result[20] )
        return result;
    }
    return 0;
  }
  return result;
}
// 4CB24: using guessed type int dword_4CB24;
// 4CB28: using guessed type int dword_4CB28;
// 4CB2C: using guessed type int dword_4CB2C;

//----- (00014604) --------------------------------------------------------
_DWORD *__fastcall sub_14604(int a1, const char *a2)
{
  size_t v4; // r0

  sub_125A4(dword_4CA58, 98);
  sub_1279C((_DWORD *)dword_4CA58, *(_DWORD *)(a1 + 4));
  v4 = strlen(a2);
  return sub_127F8((_DWORD *)dword_4CA58, a2, v4);
}
// 4CA58: using guessed type int dword_4CA58;

//----- (0001464C) --------------------------------------------------------
int __fastcall sub_1464C(char *a1, unsigned int a2, void *src, char a4)
{
  int v7; // r4
  size_t v8; // r2
  unsigned int i; // r5
  size_t v11; // r2
  char v12; // [sp+7h] [bp-111h] BYREF
  _BYTE srca[64]; // [sp+8h] [bp-110h] BYREF
  _BYTE dest[208]; // [sp+48h] [bp-D0h] BYREF

  v12 = a4;
  v7 = *(_DWORD *)(*(_DWORD *)(dword_4CAC0 + 1632) + 16);
  memcpy(dest, src, sizeof(dest));
  (*(void (__fastcall **)(_BYTE *, char *, int))(v7 + 88))(dest, &v12, 1);
  (*(void (__fastcall **)(_BYTE *, _DWORD, _DWORD))(v7 + 88))(
    dest,
    *(_DWORD *)dword_4CAC4,
    *(_DWORD *)(dword_4CAC4 + 4));
  (*(void (__fastcall **)(_BYTE *, _BYTE *))(v7 + 92))(dest, srca);
  v8 = *(_DWORD *)(v7 + 8);
  if ( a2 < v8 )
    v8 = a2;
  memcpy(a1, srca, v8);
  for ( i = *(_DWORD *)(v7 + 8); i < a2; i += *(_DWORD *)(v7 + 8) )
  {
    memcpy(dest, src, sizeof(dest));
    (*(void (__fastcall **)(_BYTE *, char *, unsigned int))(v7 + 88))(dest, a1, i);
    (*(void (__fastcall **)(_BYTE *, _BYTE *))(v7 + 92))(dest, srca);
    v11 = a2 - i;
    if ( a2 - i >= *(_DWORD *)(v7 + 8) )
      v11 = *(_DWORD *)(v7 + 8);
    memcpy(&a1[i], srca, v11);
  }
  return j_explicit_bzero(dest, 208);
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4CAC0: using guessed type int dword_4CAC0;
// 4CAC4: using guessed type int dword_4CAC4;

//----- (00014754) --------------------------------------------------------
int sub_14754()
{
  int v0; // r6
  const char **v1; // r3
  int v2; // r0
  const char **v3; // r3
  int v4; // r0
  _DWORD *v5; // r1
  int v6; // r5
  _DWORD *v7; // r1
  int v8; // r5
  int v9; // r3
  char v11[20]; // [sp+8h] [bp-138h] BYREF
  char v12[20]; // [sp+1Ch] [bp-124h] BYREF
  char v13[32]; // [sp+30h] [bp-110h] BYREF
  char v14[32]; // [sp+50h] [bp-F0h] BYREF
  _BYTE src[208]; // [sp+70h] [bp-D0h] BYREF

  v0 = *(_DWORD *)(*(_DWORD *)(dword_4CAC0 + 1632) + 16);
  (*(void (__fastcall **)(_BYTE *))(v0 + 84))(src);
  sub_12304(v0, (int)src, dword_4CAC8);
  sub_29D74(dword_4CAC8);
  free((void *)dword_4CAC8);
  dword_4CAC8 = 0;
  (*(void (__fastcall **)(_BYTE *, _DWORD, _DWORD))(v0 + 88))(src, *(_DWORD *)dword_4CACC, *(_DWORD *)(dword_4CACC + 4));
  sub_1238C((_DWORD *)dword_4CACC);
  j_free((void *)dword_4CACC);
  dword_4CACC = 0;
  sub_1464C(v11, 0x14u, src, 65);
  sub_1464C(v12, 0x14u, src, 66);
  sub_1464C(v13, 0x20u, src, 67);
  sub_1464C(v14, 0x20u, src, 68);
  v1 = **(const char ****)dword_4CAC0;
  if ( v1 && ((v2 = sub_26EE4(*v1), v2 < 0) || (**(int (__fastcall ***)(int, char *))(dword_4CAC0 + 4))(v2, v11))
    || (v3 = **(const char ****)(dword_4CAC0 + 816)) != 0
    && ((v4 = sub_26EE4(*v3), v4 < 0) || (**(int (__fastcall ***)(int, char *))(dword_4CAC0 + 820))(v4, v12)) )
  {
    sub_184AC("Crypto error");
  }
  v5 = *(_DWORD **)(dword_4CAC0 + 824);
  if ( *v5 )
  {
    sub_1464C((char *)(dword_4CAC0 + 1596), v5[1], src, 70);
    v6 = dword_4CAC0;
    *(_DWORD *)(v6 + 828) = sub_26F50(***(const char ****)(dword_4CAC0 + 824));
  }
  v7 = *(_DWORD **)(dword_4CAC0 + 8);
  if ( *v7 )
  {
    sub_1464C((char *)(dword_4CAC0 + 780), v7[1], src, 69);
    v8 = dword_4CAC0;
    *(_DWORD *)(v8 + 12) = sub_26F50(***(const char ****)(dword_4CAC0 + 8));
  }
  v9 = dword_4CAC0;
  *(_DWORD *)(dword_4CAC0 + 1628) = 1;
  *(_DWORD *)(v9 + 812) = 1;
  j_explicit_bzero(v11, 20);
  j_explicit_bzero(v13, 32);
  j_explicit_bzero(v12, 20);
  j_explicit_bzero(v14, 32);
  return j_explicit_bzero(src, 208);
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4CAC0: using guessed type int dword_4CAC0;
// 4CAC8: using guessed type int dword_4CAC8;
// 4CACC: using guessed type int dword_4CACC;

//----- (000149B4) --------------------------------------------------------
time_t __fastcall sub_149B4(int a1, int a2)
{
  time_t result; // r0

  dword_4CAB4 = 0;
  dword_4CAB8 = 0;
  byte_4CAAC &= 0xA0u;
  result = sub_18BF0(a1, a2);
  dword_4CAB0 = result;
  return result;
}
// 4CAAC: using guessed type char byte_4CAAC;
// 4CAB0: using guessed type int dword_4CAB0;
// 4CAB4: using guessed type int dword_4CAB4;
// 4CAB8: using guessed type int dword_4CAB8;

//----- (000149E8) --------------------------------------------------------
void sub_149E8()
{
  int v0; // r5
  int v1; // r5
  _DWORD *v2; // r0
  int v3; // r3
  int v4; // r2
  int v5; // r0
  int v6; // r1

  if ( (byte_4CAAC & 3) != 3 )
    sub_184AC("Unexpected newkeys message");
  if ( !dword_4CABC )
    dword_4CABC = (int)sub_18718(0x66Cu);
  if ( (byte_4CAAC & 0x10) != 0 )
  {
    v0 = dword_4CAC0;
    if ( *(_DWORD *)(dword_4CAC0 + 812) )
    {
      memcpy((void *)dword_4CABC, (const void *)dword_4CAC0, 0x330u);
      j_explicit_bzero(v0, 816);
      *(_DWORD *)(dword_4CAC0 + 812) = 0;
    }
  }
  if ( (byte_4CAAC & 8) != 0 && *(_DWORD *)(dword_4CAC0 + 1628) )
  {
    v1 = dword_4CAC0 + 816;
    memcpy((void *)(dword_4CABC + 816), (const void *)(dword_4CAC0 + 816), 0x330u);
    j_explicit_bzero(v1, 816);
    *(_DWORD *)(dword_4CAC0 + 1628) = 0;
  }
  if ( (byte_4CAAC & 0x18) == 0x18 )
  {
    v2 = (_DWORD *)dword_4CAC0;
    v3 = dword_4CABC;
    *(_DWORD *)(dword_4CABC + 1632) = *(_DWORD *)(dword_4CAC0 + 1632);
    v4 = v2[409];
    *(_DWORD *)(v3 + 1640) = 0;
    *(_DWORD *)(v3 + 1636) = v4;
    free(v2);
    dword_4CAC0 = 0;
    sub_149B4(v5, v6);
  }
}
// 14AEC: variable 'v5' is possibly undefined
// 14AEC: variable 'v6' is possibly undefined
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4CAAC: using guessed type char byte_4CAAC;
// 4CABC: using guessed type int dword_4CABC;
// 4CAC0: using guessed type int dword_4CAC0;

//----- (00014AF8) --------------------------------------------------------
int __fastcall sub_14AF8(int a1)
{
  return sub_122E8(
           a1,
           *(unsigned __int8 **)(*(_DWORD *)(dword_4CAC0 + 1632) + 4),
           *(_DWORD *)(*(_DWORD *)(dword_4CAC0 + 1632) + 8));
}
// 4CAC0: using guessed type int dword_4CAC0;

//----- (00014B10) --------------------------------------------------------
void **sub_14B10()
{
  int v0; // r5
  void (__fastcall *v1)(_BYTE *, int, _DWORD); // r6
  int v2; // r0
  _DWORD *v3; // r0
  unsigned int v4; // r1
  void (__fastcall *v5)(_BYTE *, int); // r6
  int v6; // r0
  void **result; // r0
  _BYTE v8[208]; // [sp+0h] [bp-D0h] BYREF

  v0 = *(_DWORD *)(*(_DWORD *)(dword_4CAC0 + 1632) + 16);
  (*(void (__fastcall **)(_BYTE *))(v0 + 84))(v8);
  sub_124A0(dword_4CAD0, 0);
  v1 = *(void (__fastcall **)(_BYTE *, int, _DWORD))(v0 + 88);
  v2 = sub_125E4((_DWORD *)dword_4CAD0, *(_DWORD *)(dword_4CAD0 + 4));
  v1(v8, v2, *(_DWORD *)(dword_4CAD0 + 4));
  v3 = sub_12344(*(_DWORD *)(v0 + 8));
  v4 = *(_DWORD *)(v0 + 8);
  v5 = *(void (__fastcall **)(_BYTE *, int))(v0 + 92);
  dword_4CACC = (int)v3;
  v6 = sub_12624(v3, v4);
  v5(v8, v6);
  sub_12430((_DWORD *)dword_4CACC, *(_DWORD *)(v0 + 8));
  sub_1238C((_DWORD *)dword_4CAD0);
  j_free((void *)dword_4CAD0);
  result = (void **)j_explicit_bzero(v8, 208);
  dword_4CAD0 = 0;
  if ( !dword_4CAC4 )
  {
    result = sub_123F4(dword_4CACC);
    dword_4CAC4 = (int)result;
  }
  return result;
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4CAC0: using guessed type int dword_4CAC0;
// 4CAC4: using guessed type int dword_4CAC4;
// 4CACC: using guessed type int dword_4CACC;
// 4CAD0: using guessed type int dword_4CAD0;

//----- (00014BDC) --------------------------------------------------------
_DWORD *sub_14BDC()
{
  char *v0; // r0
  _DWORD *result; // r0
  int (*v2)(void); // r3

  sub_125A4(dword_4CA58, 20);
  v0 = (char *)sub_12624((_DWORD *)dword_4CA58, 0x10u);
  sub_18090(v0, 0x10u);
  sub_124C4((_DWORD *)dword_4CA58, 0x10u);
  sub_12D00((_DWORD *)dword_4CA58, (int)&off_4C22C);
  sub_12D00((_DWORD *)dword_4CA58, (int)&off_4C2E0);
  sub_12D00((_DWORD *)dword_4CA58, (int)&off_4C3A8);
  sub_12D00((_DWORD *)dword_4CA58, (int)&off_4C3A8);
  sub_12D00((_DWORD *)dword_4CA58, (int)&off_4C36C);
  sub_12D00((_DWORD *)dword_4CA58, (int)&off_4C36C);
  sub_12D00((_DWORD *)dword_4CA58, dword_4CAD8);
  sub_12D00((_DWORD *)dword_4CA58, dword_4CAD8);
  sub_127F8((_DWORD *)dword_4CA58, "", 0);
  sub_127F8((_DWORD *)dword_4CA58, "", 0);
  sub_125A4(dword_4CA58, off_4CAEC != 0);
  sub_1279C((_DWORD *)dword_4CA58, 0);
  dword_4CAD4 = (int)sub_123F4(dword_4CA58);
  sub_1D894();
  byte_4CA84 &= ~1u;
  byte_4CAAC |= 1u;
  result = sub_18718(0x66Cu);
  v2 = (int (*)(void))off_4CAEC;
  dword_4CAC0 = (int)result;
  if ( off_4CAEC )
  {
    result[408] = off_4C234;
    result[409] = (unsigned __int8)byte_4C2E4;
    return (_DWORD *)v2();
  }
  return result;
}
// 4C22C: using guessed type char *off_4C22C;
// 4C234: using guessed type _UNKNOWN *off_4C234;
// 4C2E0: using guessed type char *off_4C2E0;
// 4C2E4: using guessed type char byte_4C2E4;
// 4C36C: using guessed type char *off_4C36C;
// 4C3A8: using guessed type _UNKNOWN *off_4C3A8;
// 4CA58: using guessed type int dword_4CA58;
// 4CA84: using guessed type char byte_4CA84;
// 4CAAC: using guessed type char byte_4CAAC;
// 4CAC0: using guessed type int dword_4CAC0;
// 4CAD4: using guessed type int dword_4CAD4;
// 4CAD8: using guessed type int dword_4CAD8;
// 4CAEC: using guessed type _UNKNOWN *off_4CAEC;

//----- (00014D28) --------------------------------------------------------
void sub_14D28()
{
  sub_125A4(dword_4CA58, 21);
  sub_1D894();
  byte_4CAAC |= 0x28u;
  byte_4CA84 |= 1u;
  sub_14754();
  sub_149E8();
}
// 4CA58: using guessed type int dword_4CA58;
// 4CA84: using guessed type char byte_4CA84;
// 4CAAC: using guessed type char byte_4CAAC;

//----- (00014D68) --------------------------------------------------------
void sub_14D68()
{
  byte_4CAAC |= 0x10u;
  sub_149E8();
}
// 4CAAC: using guessed type char byte_4CAAC;

//----- (00014D80) --------------------------------------------------------
time_t __fastcall sub_14D80(int a1, int a2)
{
  byte_4CAAC &= ~0x20u;
  dword_4CAD8 = (int)&off_4C344;
  return sub_149B4(a1, a2);
}
// 4C344: using guessed type char *off_4C344;
// 4CAAC: using guessed type char byte_4CAAC;
// 4CAD8: using guessed type int dword_4CAD8;

//----- (000150E8) --------------------------------------------------------
int *sub_150E8()
{
  int *v0; // r0
  int *v1; // r5
  int *v2; // r6
  int v3; // r2
  int s[4]; // [sp+8h] [bp-30h] BYREF
  int v6[4]; // [sp+18h] [bp-20h] BYREF
  int v7[4]; // [sp+28h] [bp-10h] BYREF

  memset(s, 0, sizeof(s));
  memset(v6, 0, sizeof(v6));
  memset(v7, 0, sizeof(v7));
  v0 = (int *)sub_18718(0x20u);
  v1 = v0 + 4;
  v2 = v0;
  sub_121CC((int)v0, v0 + 4, v7, s, v6, 0);
  sub_14AF8((int)s);
  if ( sub_2E65C(v7, 2u)
    || sub_2E7D4(s, 1u, v1)
    || sub_2A350(v1, v6)
    || (sub_18314(v6, v1, v3), sub_2AB08(v7, v1, (int)s, v2)) )
  {
    sub_184AC("Diffie-Hellman error");
  }
  sub_29DB8((int)v7, s, v6);
  return v2;
}
// 151AC: variable 'v3' is possibly undefined

//----- (000151F0) --------------------------------------------------------
void __fastcall sub_151F0(char *a1)
{
  sub_29DB8((int)a1, a1 + 16, 0);
  free(a1);
}

//----- (00015210) --------------------------------------------------------
void **__fastcall sub_15210(int a1, int *a2, int a3)
{
  int v7[4]; // [sp+0h] [bp-24h] BYREF
  int v8[5]; // [sp+10h] [bp-14h] BYREF

  memset(v7, 0, sizeof(v7));
  memset(v8, 0, 0x10u);
  sub_121CC((int)v7, v8, 0);
  sub_14AF8((int)v7);
  if ( sub_2E7D4(v7, 1u, v8)
    || sub_29E00(a2, v8) != -1
    || sub_29E48((int)a2, 1u) != 1
    || (sub_12224((int)&dword_4CAC8, 0), sub_2AB08(a2, (int *)(a1 + 16), (int)v7, (int *)dword_4CAC8)) )
  {
    sub_184AC("Diffie-Hellman error");
  }
  sub_29DB8((int)v7, v8);
  sub_1E964((_DWORD *)dword_4CAD0, a3, *(_DWORD *)(dword_4CAC0 + 1636));
  sub_1282C((_DWORD *)dword_4CAD0, (int)a2);
  sub_1282C((_DWORD *)dword_4CAD0, a1);
  sub_1282C((_DWORD *)dword_4CAD0, dword_4CAC8);
  return sub_14B10();
}
// 4CAC0: using guessed type int dword_4CAC0;
// 4CAC8: using guessed type int dword_4CAC8;
// 4CAD0: using guessed type int dword_4CAD0;

//----- (0001532C) --------------------------------------------------------
_DWORD *sub_1532C()
{
  _DWORD *v0; // r4

  v0 = sub_18718(0x1Cu);
  if ( sub_277F4(0, dword_4C3E4, v0, *(int **)(*(_DWORD *)(*(_DWORD *)(dword_4CAC0 + 1632) + 12) + 4)) )
    sub_184AC("ECC error");
  return v0;
}
// 4C3E4: using guessed type int dword_4C3E4;
// 4CAC0: using guessed type int dword_4CAC0;

//----- (00015388) --------------------------------------------------------
void __fastcall sub_15388(int *a1, int a2, int a3)
{
  sub_277B4(a1, a2, a3);
  free(a1);
}

//----- (000153A0) --------------------------------------------------------
void **__fastcall sub_153A0(_DWORD *a1, _DWORD *a2, int a3)
{
  char *v5; // r0
  int v6; // r6

  v5 = sub_193DC(a2, *(_DWORD *)(*(_DWORD *)(dword_4CAC0 + 1632) + 12));
  v6 = (int)v5;
  if ( !v5 )
    sub_184AC("ECC error");
  dword_4CAC8 = (int)sub_196E0((int)v5, a1);
  sub_1E964((_DWORD *)dword_4CAD0, a3, *(_DWORD *)(dword_4CAC0 + 1636));
  sub_19370((_DWORD *)dword_4CAD0, v6);
  sub_19370((_DWORD *)dword_4CAD0, (int)a1);
  sub_1282C((_DWORD *)dword_4CAD0, dword_4CAC8);
  return sub_14B10();
}
// 4CAC0: using guessed type int dword_4CAC0;
// 4CAC8: using guessed type int dword_4CAC8;
// 4CAD0: using guessed type int dword_4CAD0;

//----- (00015428) --------------------------------------------------------
char *sub_15428()
{
  char *v0; // r4
  int v2[9]; // [sp+0h] [bp-24h] BYREF

  v0 = (char *)sub_18718(0x40u);
  memset(v2, 0, 0x20u);
  LOBYTE(v2[0]) = 9;
  sub_18090(v0, 0x20u);
  *v0 &= 0xF8u;
  v0[31] = v0[31] & 0x3F | 0x40;
  sub_17330((int)(v0 + 32), (int)v0, v2);
  return v0;
}

//----- (0001549C) --------------------------------------------------------
void __fastcall sub_1549C(void *a1)
{
  j_explicit_bzero(a1, 32);
  free(a1);
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);

//----- (000154B8) --------------------------------------------------------
void **__fastcall sub_154B8(int a1, int a2, int a3)
{
  int *v6; // r6
  unsigned __int8 v8[32]; // [sp+0h] [bp-40h] BYREF
  _BYTE v9[32]; // [sp+20h] [bp-20h] BYREF

  memset(v9, 0, sizeof(v9));
  if ( *(_DWORD *)(a2 + 4) != 32 || (sub_17330((int)v8, a1, *(int **)a2), !sub_18BC0((int)v9, (int)v8, 32)) )
    sub_184AC("Bad curve25519");
  sub_12224((int)&dword_4CAC8, 0);
  sub_122E8(dword_4CAC8, v8, 32);
  j_explicit_bzero(v8, 32);
  v6 = *(int **)a2;
  sub_1E964((_DWORD *)dword_4CAD0, a3, *(_DWORD *)(dword_4CAC0 + 1636));
  sub_127F8((_DWORD *)dword_4CAD0, v6, 0x20u);
  sub_127F8((_DWORD *)dword_4CAD0, (const void *)(a1 + 32), 0x20u);
  sub_1282C((_DWORD *)dword_4CAD0, dword_4CAC8);
  return sub_14B10();
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4CAC0: using guessed type int dword_4CAC0;
// 4CAC8: using guessed type int dword_4CAC8;
// 4CAD0: using guessed type int dword_4CAD0;

//----- (000155A0) --------------------------------------------------------
int __fastcall sub_155A0(int a1, int a2, int *a3)
{
  _DWORD *v6; // r4
  int v7; // r5
  char *v8; // r0

  v6 = sub_12344(0x6A4u);
  if ( sub_1867C(v6, a1) == -1 )
  {
    v7 = -1;
  }
  else
  {
    sub_124A0((int)v6, 0);
    v8 = (char *)sub_125E4(v6, v6[1]);
    sub_1803C(v8, v6[1]);
    v7 = -(sub_1E858(v6, a2, a3) == -1);
  }
  sub_1238C(v6);
  j_free(v6);
  return v7;
}

//----- (00015628) --------------------------------------------------------
void sub_15628()
{
  const char *v0; // r5
  char *v1; // r4
  const char *v2; // r4

  v0 = (const char *)dword_4CA38;
  if ( dword_4CA38 )
  {
    if ( !strcmp((const char *)dword_4CA38, "help") )
    {
      v1 = sub_12F5C((int)&off_4C3A8);
      sub_184E8(6, "Available ciphers:\n%s\n", v1);
      goto LABEL_4;
    }
    if ( !strcmp(v0, "none") )
      dword_4CA38 = (int)"none,aes128-ctr";
    if ( !sub_12FC4((const char *)dword_4CA38, (const char **)&off_4C3A8, "cipher") )
      sub_184AC("No valid ciphers specified for '-c'");
  }
  v2 = (const char *)dword_4CA3C;
  if ( dword_4CA3C )
  {
    if ( !strcmp((const char *)dword_4CA3C, "help") )
    {
      v1 = sub_12F5C((int)&off_4C36C);
      sub_184E8(6, "Available MACs:\n%s\n", v1);
LABEL_4:
      free(v1);
      sub_184AC(".");
    }
    if ( !sub_12FC4(v2, (const char **)&off_4C36C, "MAC") )
      sub_184AC("No valid MACs specified for '-m'");
  }
}
// 4C36C: using guessed type char *off_4C36C;
// 4C3A8: using guessed type _UNKNOWN *off_4C3A8;
// 4CA38: using guessed type int dword_4CA38;
// 4CA3C: using guessed type int dword_4CA3C;

//----- (00015740) --------------------------------------------------------
int sub_15740()
{
  return fprintf((FILE *)stderr, "Dropbear v%s\n", "2018.76");
}
// 4C448: using guessed type int stderr;

//----- (00015760) --------------------------------------------------------
int __fastcall sub_15760(int result, int a2, int a3, _DWORD *a4)
{
  bool v4; // cc
  int v5; // r1

  v4 = a3 <= 0;
  if ( a3 > 0 )
    v4 = result <= 0;
  if ( !v4 )
  {
    v5 = a3 + result - a2;
    if ( *a4 > v5 )
      *a4 = v5;
    else
      *a4 = *a4;
  }
  return result;
}

//----- (00015788) --------------------------------------------------------
time_t sub_15788()
{
  int v0; // r5
  _DWORD *v1; // r0
  _DWORD *v2; // r0
  int v3; // r1
  time_t result; // r0

  v0 = dword_4CAA8;
  v1 = sub_1459C();
  if ( v1 )
  {
    sub_14604((int)v1, "keepalive@openssh.com");
  }
  else
  {
    sub_125A4(dword_4CA58, 80);
    sub_127F8((_DWORD *)dword_4CA58, "keepalive@openssh.com", 0x15u);
  }
  sub_125A4(dword_4CA58, 1);
  v2 = sub_1D894();
  result = sub_18BF0((int)v2, v3);
  dword_4CAA8 = v0;
  dword_4CA9C = result;
  return result;
}
// 157B8: variable 'v3' is possibly undefined
// 4CA58: using guessed type int dword_4CA58;
// 4CA9C: using guessed type int dword_4CA9C;
// 4CAA8: using guessed type int dword_4CAA8;

//----- (000157F0) --------------------------------------------------------
_DWORD *__fastcall sub_157F0(int a1, int a2)
{
  _DWORD *result; // r0
  _DWORD *v3; // r5

  result = (_DWORD *)sub_18BF0(a1, a2);
  v3 = result;
  if ( dword_4CA44 && (int)result - dword_4CA44 >= 300 )
    sub_18484("Timeout before auth");
  if ( dword_4CA50 )
  {
    if ( (byte_4CAAC & 1) == 0
      && ((int)result - dword_4CAB0 > 28799 || (unsigned int)(dword_4CAB8 + dword_4CAB4) > 0x3FFFFFFF) )
    {
      result = sub_14BDC();
    }
    if ( dword_4CA2C > 0 && dword_4CAFC )
    {
      if ( dword_4CA2C <= (int)v3 - dword_4CAA4 )
        result = (_DWORD *)sub_15788();
      if ( (int)v3 - dword_4CAA0 >= dword_4CA2C && dword_4CA2C <= (int)v3 - dword_4CA9C )
        result = (_DWORD *)sub_15788();
      if ( (int)v3 - dword_4CAA0 >= 3 * dword_4CA2C )
        sub_184AC("Keepalive timeout");
    }
    if ( dword_4CA30 > 0 && dword_4CA30 <= (int)v3 - dword_4CAA8 )
      sub_18484("Idle timeout");
  }
  return result;
}
// 4CA2C: using guessed type int dword_4CA2C;
// 4CA30: using guessed type int dword_4CA30;
// 4CA44: using guessed type int dword_4CA44;
// 4CA50: using guessed type int dword_4CA50;
// 4CA9C: using guessed type int dword_4CA9C;
// 4CAA0: using guessed type int dword_4CAA0;
// 4CAA4: using guessed type int dword_4CAA4;
// 4CAA8: using guessed type int dword_4CAA8;
// 4CAAC: using guessed type char byte_4CAAC;
// 4CAB0: using guessed type int dword_4CAB0;
// 4CAB4: using guessed type int dword_4CAB4;
// 4CAB8: using guessed type int dword_4CAB8;
// 4CAFC: using guessed type int dword_4CAFC;

//----- (00015914) --------------------------------------------------------
void __fastcall sub_15914(void **a1)
{
  _DWORD *v2; // r0

  v2 = *a1;
  if ( v2 )
  {
    sub_1238C(v2);
    j_free(*a1);
    *a1 = 0;
  }
}

//----- (00015940) --------------------------------------------------------
void __fastcall __noreturn sub_15940(int a1, int a2)
{
  unsigned int v2; // r8
  time_t v3; // r0
  int v4; // r5
  int v5; // r2
  int i; // r3
  int j; // r3
  int v8; // r3
  int v9; // r3
  int m; // r0
  int v11; // r3
  int n; // r3
  int v13; // r3
  int v14; // r1
  int v15; // r3
  int v16; // r9
  int k; // r3
  int v18; // r8
  int v19; // r3
  _DWORD *v20; // r8
  int v21; // r5
  int v22; // r3
  int v23; // r0
  int v24; // r1
  ssize_t v25; // r0
  char *v26; // r2
  char *v27; // r3
  signed int v28; // r5
  const char *v29; // r5
  int v30; // [sp+Ch] [bp-2A8h]
  int v31; // [sp+10h] [bp-2A4h]
  void (*v32)(void); // [sp+14h] [bp-2A0h]
  char buf; // [sp+1Fh] [bp-295h] BYREF
  struct timeval timeout; // [sp+20h] [bp-294h] BYREF
  struct timeval v35; // [sp+28h] [bp-28Ch] BYREF
  fd_set v36; // [sp+30h] [bp-284h] BYREF
  fd_set v37; // [sp+B0h] [bp-204h] BYREF
  fd_set readfds; // [sp+130h] [bp-184h] BYREF
  _DWORD v39[65]; // [sp+1B0h] [bp-104h] BYREF

  v32 = (void (*)(void))a1;
  while ( 1 )
  {
    v2 = dword_4CA68;
    v39[0] = 28800;
    v3 = sub_18BF0(a1, a2);
    v4 = v3;
    if ( (byte_4CAAC & 1) == 0 )
      sub_15760(28800, v3, dword_4CAB0, v39);
    if ( dword_4CAFC != 1 )
      sub_15760(300, v4, dword_4CA44, v39);
    if ( dword_4CAFC )
    {
      v5 = dword_4CAA0;
      if ( dword_4CA9C >= dword_4CAA0 )
        v5 = dword_4CA9C;
      sub_15760(dword_4CA2C, v4, v5, v39);
    }
    sub_15760(dword_4CA30, v4, dword_4CAA8, v39);
    timeout.tv_usec = 0;
    timeout.tv_sec = v39[0] & ~(v39[0] >> 31);
    for ( i = 0; i != 32; ++i )
      v37.__fds_bits[i] = 0;
    for ( j = 0; j != 32; ++j )
      v36.__fds_bits[j] = 0;
    if ( dword_4CA70 )
      sub_184D4("ses.payload == NULL", "common-session.c", 153);
    LOBYTE(v8) = pipedes[0] & 0x1F;
    if ( pipedes[0] <= 0 )
      v8 = -(-pipedes[0] & 0x1F);
    v36.__fds_bits[pipedes[0] / 32] |= 1 << v8;
    sub_13E70((int)&v36, (int)&v37, v2 <= 0x8000);
    sub_1CA24((int)&v37);
    if ( dword_4CA48 != -1 && (dword_4CA50 || sub_1DD50(dword_4CA5C)) && v2 <= 0x8000 )
    {
      LOBYTE(v11) = dword_4CA48 & 0x1F;
      if ( dword_4CA48 <= 0 )
        v11 = -(-dword_4CA48 & 0x1F);
      v36.__fds_bits[dword_4CA48 / 32] |= 1 << v11;
    }
    if ( dword_4CA4C != -1 && !sub_1DD50(dword_4CA5C) )
    {
      LOBYTE(v9) = dword_4CA4C & 0x1F;
      if ( dword_4CA4C <= 0 )
        v9 = -(-dword_4CA4C & 0x1F);
      v37.__fds_bits[dword_4CA4C / 32] |= 1 << v9;
    }
    m = select(dword_4CA54 + 1, &v36, &v37, 0, &timeout);
    if ( dword_4CB44 )
      sub_184AC("Terminated by signal");
    if ( m < 0 )
      break;
    if ( !m )
      goto LABEL_37;
LABEL_40:
    dword_4CA90 = 0;
    LOBYTE(v13) = pipedes[0] & 0x1F;
    if ( pipedes[0] <= 0 )
      v13 = -(-pipedes[0] & 0x1F);
    v14 = 1;
    if ( (v36.__fds_bits[pipedes[0] / 32] & (1 << v13)) != 0 )
    {
      do
        m = read(pipedes[0], v39, 1u);
      while ( m > 0 );
      dword_4CA90 = 1;
    }
    sub_157F0(m, v14);
    if ( dword_4CA48 == -1 )
      goto LABEL_81;
    LOBYTE(v15) = dword_4CA48 & 0x1F;
    if ( dword_4CA48 <= 0 )
      v15 = -(-dword_4CA48 & 0x1F);
    if ( (v36.__fds_bits[dword_4CA48 / 32] & (1 << v15)) == 0 )
      goto LABEL_79;
    if ( dword_4CA50 )
    {
      sub_1D640();
      goto LABEL_79;
    }
    v30 = 50;
    while ( 1 )
    {
      v16 = dword_4CA48;
      for ( k = 0; k != 32; ++k )
        readfds.__fds_bits[k] = 0;
      v18 = v16 + 31;
      if ( v16 >= 0 )
        v18 = v16;
      LOBYTE(v19) = v16 & 0x1F;
      if ( v16 <= 0 )
        v19 = -(-v16 & 0x1F);
      v31 = 1 << v19;
      v20 = &v39[(v18 >> 5) + 64];
      v21 = 0;
      do
      {
        v22 = *(v20 - 96);
        v35.tv_usec = 0;
        *(v20 - 96) = v22 | v31;
        v35.tv_sec = 1;
        v23 = select(v16 + 1, &readfds, 0, 0, &v35);
        if ( v23 < 0 )
          goto LABEL_59;
        sub_157F0(v23, v24);
        if ( (v31 & *(v20 - 96)) == 0 )
          continue;
        v25 = read(v16, &buf, 1u);
        if ( v25 < 0 )
        {
LABEL_59:
          if ( *_errno_location() != 4 )
            goto LABEL_60;
        }
        else
        {
          if ( !v25 )
          {
LABEL_60:
            if ( *_errno_location() != 4 )
              goto LABEL_72;
            goto LABEL_71;
          }
          if ( buf == 10 )
            break;
          if ( buf != 13 )
          {
            v26 = (char *)&v39[64] + v21++;
            *(v26 - 256) = buf;
          }
        }
      }
      while ( v21 != 255 );
      v27 = (char *)&v39[64] + v21;
      v28 = v21 + 1;
      *(v27 - 256) = 0;
      if ( v28 > 3 && !memcmp(v39, "SSH-", 4u) )
        break;
LABEL_71:
      if ( !--v30 )
      {
LABEL_72:
        off_4CAE4();
        goto LABEL_73;
      }
    }
    dword_4CA50 = (int)sub_18718(v28);
    memcpy((void *)dword_4CA50, v39, v28);
LABEL_73:
    v29 = (const char *)dword_4CA50;
    if ( strncmp((const char *)dword_4CA50, "SSH-2.", 6u) && strncmp(v29, "SSH-1.99-", 9u) )
      sub_184AC("Incompatible remote version '%s'", v29);
LABEL_79:
    if ( dword_4CA70 )
      sub_1DBF0();
LABEL_81:
    sub_1DB60();
    sub_1C820((int)&v37);
    v32();
    a1 = sub_13CD8((int)&v36, (int)&v37);
    if ( dword_4CA4C != -1 )
    {
      a1 = sub_1DD50(dword_4CA5C);
      if ( !a1 )
        sub_1D3D8();
    }
  }
  if ( *_errno_location() != 4 )
    sub_184AC("Error in select");
  for ( m = 0; m != 32; ++m )
LABEL_37:
    v37.__fds_bits[m] = 0;
  for ( n = 0; n != 32; ++n )
    v36.__fds_bits[n] = 0;
  goto LABEL_40;
}
// 15974: variable 'a1' is possibly undefined
// 15974: variable 'a2' is possibly undefined
// 15C5C: variable 'v14' is possibly undefined
// 15D78: variable 'v24' is possibly undefined
// 4CA2C: using guessed type int dword_4CA2C;
// 4CA30: using guessed type int dword_4CA30;
// 4CA44: using guessed type int dword_4CA44;
// 4CA48: using guessed type int dword_4CA48;
// 4CA4C: using guessed type int dword_4CA4C;
// 4CA50: using guessed type int dword_4CA50;
// 4CA54: using guessed type int dword_4CA54;
// 4CA5C: using guessed type int dword_4CA5C[3];
// 4CA68: using guessed type int dword_4CA68;
// 4CA70: using guessed type int dword_4CA70;
// 4CA90: using guessed type int dword_4CA90;
// 4CA9C: using guessed type int dword_4CA9C;
// 4CAA0: using guessed type int dword_4CAA0;
// 4CAA8: using guessed type int dword_4CAA8;
// 4CAAC: using guessed type char byte_4CAAC;
// 4CAB0: using guessed type int dword_4CAB0;
// 4CAE4: using guessed type int (*off_4CAE4)(void);
// 4CAFC: using guessed type int dword_4CAFC;
// 4CB44: using guessed type int dword_4CB44;

//----- (00015EF8) --------------------------------------------------------
void sub_15EF8()
{
  void *v0; // r0

  if ( dword_4CB48 )
  {
    sub_13C88();
    if ( off_4CAE8 )
      ((void (*)(void))off_4CAE8)();
    sub_1C14C();
    sub_1C7FC();
    while ( !sub_1DD50(dword_4CA5C) )
    {
      v0 = (void *)sub_1DD60((int)dword_4CA5C);
      j_free(v0);
    }
    free((void *)dword_4CA50);
    dword_4CA50 = 0;
    free((void *)dword_4CB10);
    dword_4CB10 = 0;
    free((void *)dword_4CB18);
    dword_4CB18 = 0;
    free((void *)dword_4CB14);
    dword_4CB14 = 0;
    free((void *)dword_4CB1C);
    dword_4CB1C = 0;
    free((void *)dword_4CAF0);
    dword_4CAF0 = 0;
    sub_15914((void **)&dword_4CAC4);
    sub_15914((void **)&dword_4CACC);
    sub_15914((void **)&dword_4CA70);
    sub_15914((void **)&dword_4CA6C);
    sub_15914((void **)&dword_4CA58);
    sub_15914((void **)&dword_4CAD0);
    sub_15914((void **)&dword_4CAD4);
    if ( dword_4CAC8 )
      sub_29D74(dword_4CAC8);
    free((void *)dword_4CAC8);
    dword_4CAC8 = 0;
    j_explicit_bzero(dword_4CABC, 1644);
    free((void *)dword_4CABC);
    dword_4CABC = 0;
  }
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4CA50: using guessed type int dword_4CA50;
// 4CA58: using guessed type int dword_4CA58;
// 4CA5C: using guessed type int dword_4CA5C[3];
// 4CA6C: using guessed type int dword_4CA6C;
// 4CA70: using guessed type int dword_4CA70;
// 4CABC: using guessed type int dword_4CABC;
// 4CAC4: using guessed type int dword_4CAC4;
// 4CAC8: using guessed type int dword_4CAC8;
// 4CACC: using guessed type int dword_4CACC;
// 4CAD0: using guessed type int dword_4CAD0;
// 4CAD4: using guessed type int dword_4CAD4;
// 4CAE8: using guessed type _UNKNOWN *off_4CAE8;
// 4CAF0: using guessed type int dword_4CAF0;
// 4CB10: using guessed type int dword_4CB10;
// 4CB14: using guessed type int dword_4CB14;
// 4CB18: using guessed type int dword_4CB18;
// 4CB1C: using guessed type int dword_4CB1C;
// 4CB48: using guessed type int dword_4CB48;

//----- (00016030) --------------------------------------------------------
_DWORD *sub_16030()
{
  _DWORD *v0; // r4

  v0 = sub_12344(0x1Bu);
  sub_127C4(v0, "SSH-2.0-dropbear_2018.76\r\n", 0x1Au);
  return sub_1D84C((int)v0, 0);
}

//----- (00016064) --------------------------------------------------------
const char *sub_16064()
{
  if ( *(_BYTE *)dword_4CB14 )
    return (const char *)dword_4CB14;
  else
    return "/bin/sh";
}
// 4CB14: using guessed type int dword_4CB14;

//----- (0001608C) --------------------------------------------------------
const char **__fastcall sub_1608C(char *name)
{
  const char **result; // r0
  const char **v3; // r5
  const char *v4; // r0
  const char *v5; // r5
  struct spwd *v6; // r0
  const char *sp_pwdp; // r0

  if ( dword_4CB18 )
  {
    free((void *)dword_4CB18);
    dword_4CB18 = 0;
  }
  if ( dword_4CB10 )
  {
    free((void *)dword_4CB10);
    dword_4CB10 = 0;
  }
  if ( dword_4CB14 )
  {
    free((void *)dword_4CB14);
    dword_4CB14 = 0;
  }
  if ( dword_4CB1C )
  {
    free((void *)dword_4CB1C);
    dword_4CB1C = 0;
  }
  result = (const char **)getpwnam(name);
  v3 = result;
  if ( result )
  {
    v4 = *result;
    dword_4CB08 = (int)v3[2];
    dword_4CB0C = (int)v3[3];
    dword_4CB18 = (int)sub_1886C(v4);
    dword_4CB10 = (int)sub_1886C(v3[5]);
    dword_4CB14 = (int)sub_1886C(v3[6]);
    v5 = v3[1];
    v6 = getspnam((const char *)dword_4CB18);
    if ( !v6 || (sp_pwdp = v6->sp_pwdp) == 0 )
    {
      sp_pwdp = "!!";
      if ( v5 )
        sp_pwdp = v5;
    }
    result = (const char **)sub_1886C(sp_pwdp);
    dword_4CB1C = (int)result;
  }
  return result;
}
// 4CB08: using guessed type int dword_4CB08;
// 4CB0C: using guessed type int dword_4CB0C;
// 4CB10: using guessed type int dword_4CB10;
// 4CB14: using guessed type int dword_4CB14;
// 4CB18: using guessed type int dword_4CB18;
// 4CB1C: using guessed type int dword_4CB1C;

//----- (0001617C) --------------------------------------------------------
int sub_1617C()
{
  int result; // r0
  int v1; // r3
  int v2; // r1
  int v3; // r4
  int v4; // r2
  int v5; // r2
  bool v6; // zf

  result = dword_4CA4C;
  if ( dword_4CA4C >= 0 )
  {
    v1 = 0;
    v2 = 0;
    v3 = 12;
    while ( dword_4CB28 != v1 )
    {
      v4 = *(_DWORD *)(dword_4CB24 + 4 * v1);
      if ( v4 )
      {
        v5 = *(_DWORD *)(v4 + 96);
        if ( v5 != 3 )
        {
          if ( !v5 )
          {
            v3 = 11;
            goto LABEL_6;
          }
          v2 = 1;
          v6 = v3 == 12;
          if ( v3 == 12 )
            v6 = v5 == 1;
          if ( v6 )
            v3 = 10;
        }
      }
      ++v1;
    }
    if ( !v2 )
      v3 = 11;
LABEL_6:
    if ( dword_4CB34 != v3 )
    {
      result = sub_1CD30(dword_4CA4C, v3);
      dword_4CB34 = v3;
    }
  }
  return result;
}
// 4CA4C: using guessed type int dword_4CA4C;
// 4CB24: using guessed type int dword_4CB24;
// 4CB28: using guessed type int dword_4CB28;
// 4CB34: using guessed type int dword_4CB34;

//----- (00016214) --------------------------------------------------------
_DWORD *__fastcall sub_16214(__int64 a1)
{
  int v1; // r5
  int v2; // r0
  int v3; // r1
  int v4; // r3
  _DWORD *result; // r0

  v1 = HIDWORD(a1);
  if ( (int)a1 < SHIDWORD(a1) )
    dword_4CA54 = HIDWORD(a1);
  else
    dword_4CA54 = a1;
  *(_QWORD *)&dword_4CA48 = a1;
  if ( (int)a1 >= 0 )
    sub_188B0(a1);
  if ( v1 >= 0 )
    sub_188B0(v1);
  dword_4CB34 = 10;
  v2 = sub_1617C();
  dword_4CA44 = sub_18BF0(v2, v3);
  dword_4CAA0 = dword_4CA44;
  dword_4CAA8 = dword_4CA44;
  dword_4CAA4 = 0;
  dword_4CA9C = 0;
  if ( pipe(pipedes) < 0 )
    sub_184AC("Signal pipe failed");
  sub_188B0(pipedes[0]);
  sub_188B0(dword_4CA8C);
  v4 = pipedes[0];
  if ( pipedes[0] < dword_4CA54 )
    v4 = dword_4CA54;
  if ( v4 < dword_4CA8C )
    dword_4CA54 = dword_4CA8C;
  else
    dword_4CA54 = v4;
  dword_4CA58 = (int)sub_12344(0x4000u);
  dword_4CA78 = 0;
  dword_4CA6C = 0;
  dword_4CA70 = 0;
  dword_4CA7C = 0;
  sub_1DD3C(dword_4CA5C);
  byte_4CA85 = 20;
  byte_4CA86 = 0;
  byte_4CA87 = 0;
  dword_4CADC = 0;
  byte_4CA84 |= 1u;
  dword_4CAE0 = 0;
  result = sub_18718(0x66Cu);
  dword_4CABC = (int)result;
  dword_4CAC0 = 0;
  result[204] = &unk_35374;
  *result = &unk_35374;
  result[4] = 0;
  result[408] = 0;
  result[1] = &off_35368;
  result[205] = &off_35368;
  result[208] = 0;
  result[2] = &unk_35338;
  result[206] = &unk_35338;
  result[409] = -1;
  dword_4CAC4 = 0;
  dword_4CAD0 = 0;
  dword_4CAD4 = 0;
  dword_4CAC8 = 0;
  dword_4CA50 = 0;
  dword_4CB30 = 0;
  dword_4CB40 = 0;
  return result;
}
// 1625C: variable 'v3' is possibly undefined
// 35368: using guessed type int (*off_35368)();
// 4CA44: using guessed type int dword_4CA44;
// 4CA48: using guessed type int dword_4CA48;
// 4CA50: using guessed type int dword_4CA50;
// 4CA54: using guessed type int dword_4CA54;
// 4CA58: using guessed type int dword_4CA58;
// 4CA5C: using guessed type int dword_4CA5C[3];
// 4CA6C: using guessed type int dword_4CA6C;
// 4CA70: using guessed type int dword_4CA70;
// 4CA78: using guessed type int dword_4CA78;
// 4CA7C: using guessed type int dword_4CA7C;
// 4CA84: using guessed type char byte_4CA84;
// 4CA85: using guessed type char byte_4CA85;
// 4CA86: using guessed type char byte_4CA86;
// 4CA87: using guessed type char byte_4CA87;
// 4CA8C: using guessed type int dword_4CA8C;
// 4CA9C: using guessed type int dword_4CA9C;
// 4CAA0: using guessed type int dword_4CAA0;
// 4CAA4: using guessed type int dword_4CAA4;
// 4CAA8: using guessed type int dword_4CAA8;
// 4CABC: using guessed type int dword_4CABC;
// 4CAC0: using guessed type int dword_4CAC0;
// 4CAC4: using guessed type int dword_4CAC4;
// 4CAC8: using guessed type int dword_4CAC8;
// 4CAD0: using guessed type int dword_4CAD0;
// 4CAD4: using guessed type int dword_4CAD4;
// 4CADC: using guessed type int dword_4CADC;
// 4CAE0: using guessed type int dword_4CAE0;
// 4CB30: using guessed type int dword_4CB30;
// 4CB34: using guessed type int dword_4CB34;
// 4CB40: using guessed type int dword_4CB40;

//----- (00016388) --------------------------------------------------------
size_t __fastcall sub_16388(int a1, char *s, int a3)
{
  char *v3; // r12
  _BYTE *v4; // r3
  unsigned int v5; // r2
  char v7; // lr
  int v8; // t1

  if ( !a3 )
    return 0;
  v3 = s - 1;
  v4 = (_BYTE *)a1;
  v5 = a3 - 1;
  while ( v5 > (unsigned int)&v4[-a1] )
  {
    v8 = (unsigned __int8)*++v3;
    v7 = v8;
    if ( !v8 )
      break;
    *v4++ = v7;
  }
  *v4 = 0;
  return strlen(s);
}

//----- (000163DC) --------------------------------------------------------
char *__fastcall sub_163DC(char *a1, char *s, int a3)
{
  char *i; // r3
  char *v4; // r12
  char *v5; // r4
  int v6; // r2
  char *j; // r3
  size_t v8; // r0
  char v10; // r0

  for ( i = a1; ; ++i )
  {
    v4 = i;
    if ( i == &a1[a3] || !*i )
      break;
  }
  v5 = (char *)(i - a1);
  v6 = a3 - (i - a1);
  if ( v6 )
  {
    for ( j = s; ; ++j )
    {
      v10 = *j;
      if ( !*j )
        break;
      if ( v6 != 1 )
      {
        *v4 = v10;
        --v6;
        ++v4;
      }
    }
    *v4 = 0;
    v8 = j - s;
  }
  else
  {
    v8 = strlen(s);
  }
  return &v5[v8];
}

//----- (0001645C) --------------------------------------------------------
void sub_1645C()
{
  _DWORD *v0; // r4
  const void *v1; // r0
  const void *v2; // t1
  _DWORD v3[6]; // [sp+0h] [bp-18h] BYREF

  v3[1] = &off_395A4;
  v3[2] = &off_39734;
  v3[3] = &off_397B8;
  v3[4] = &off_39AC0;
  v3[5] = 0;
  if ( sub_26FF0((unsigned __int8 *)&off_394EC) == -1 )
    goto LABEL_3;
  v0 = v3;
  while ( 1 )
  {
    v2 = (const void *)v0[1];
    ++v0;
    v1 = v2;
    if ( !v2 )
      break;
    if ( sub_27098(v1) == -1 )
      goto LABEL_3;
  }
  dword_4C3E4 = sub_27138((int *)&off_368C8);
  if ( dword_4C3E4 == -1 )
LABEL_3:
    sub_184AC("Error registering crypto");
  memcpy(&dword_4C684, &off_39BC0, 0xD0u);
  sub_1928C();
}
// 368C8: using guessed type char *off_368C8;
// 394EC: using guessed type char *off_394EC;
// 395A4: using guessed type _UNKNOWN *off_395A4;
// 39734: using guessed type _UNKNOWN *off_39734;
// 397B8: using guessed type char *off_397B8;
// 39AC0: using guessed type char *off_39AC0;
// 39BC0: using guessed type char *off_39BC0;
// 4C3E4: using guessed type int dword_4C3E4;
// 4C684: using guessed type int dword_4C684;

//----- (00016500) --------------------------------------------------------
int __fastcall sub_16500(int result, int a2)
{
  int v2; // r2
  int v3; // lr
  int v4; // r3
  int v5; // r5
  int v6; // r12
  int v7; // lr
  int v8; // r4

  v2 = 0;
  do
  {
    v3 = a2 + v2;
    *(_QWORD *)(result + v2) += *(_QWORD *)(a2 + v2);
    v4 = result + v2;
    v2 += 16;
    v5 = *(_DWORD *)(v3 + 8);
    v6 = *(_DWORD *)(v4 + 8);
    v7 = *(_DWORD *)(v3 + 12);
    v8 = *(_DWORD *)(v4 + 12);
    *(_DWORD *)(v4 + 8) = v6 + v5;
    *(_DWORD *)(v4 + 12) = v7 + __CFADD__(v6, v5) + v8;
  }
  while ( v2 != 80 );
  return result;
}

//----- (00016568) --------------------------------------------------------
_QWORD *__fastcall sub_16568(int a1, int a2)
{
  int v2; // r3
  _QWORD *result; // r0
  int v4; // r1
  __int64 v5; // r6
  __int64 v6; // t1
  __int64 v7; // t1

  v2 = a2 - 8;
  result = (_QWORD *)(a1 - 8);
  v4 = a2 + 72;
  do
  {
    v6 = *(_QWORD *)(v2 + 8);
    v2 += 8;
    v5 = v6;
    v7 = result[1];
    *++result = v5 - v7;
  }
  while ( v2 != v4 );
  return result;
}

//----- (0001659C) --------------------------------------------------------
_QWORD *__fastcall sub_1659C(_QWORD *result, int *a2, int *a3)
{
  int v3; // r4
  int v4; // r2
  int v5; // r1
  unsigned __int64 v6; // r2

  *result = *a2 * (__int64)*a3;
  result[1] = a3[2] * (__int64)*a2 + a2[2] * (__int64)*a3;
  result[2] = *a3 * (__int64)a2[4] + a3[4] * (__int64)*a2 + 2LL * a2[2] * a3[2];
  result[3] = *a3 * (__int64)a2[6] + a3[6] * (__int64)*a2 + a3[4] * (__int64)a2[2] + a2[4] * (__int64)a3[2];
  result[4] = *a3 * (__int64)a2[8]
            + a3[8] * (__int64)*a2
            + a3[4] * (__int64)a2[4]
            + 2 * (a3[6] * (__int64)a2[2] + a2[6] * (__int64)a3[2]);
  result[5] = *a3 * (__int64)a2[10]
            + a3[10] * (__int64)*a2
            + a3[2] * (__int64)a2[8]
            + a3[8] * (__int64)a2[2]
            + a3[6] * (__int64)a2[4]
            + a2[6] * (__int64)a3[4];
  result[6] = *a3 * (__int64)a2[12]
            + a3[12] * (__int64)*a2
            + a3[4] * (__int64)a2[8]
            + a3[8] * (__int64)a2[4]
            + 2 * (a3[2] * (__int64)a2[10] + a3[6] * (__int64)a2[6] + a2[2] * (__int64)a3[10]);
  result[7] = *a3 * (__int64)a2[14]
            + a3[14] * (__int64)*a2
            + a3[2] * (__int64)a2[12]
            + a3[12] * (__int64)a2[2]
            + a3[4] * (__int64)a2[10]
            + a3[10] * (__int64)a2[4]
            + a3[8] * (__int64)a2[6]
            + a2[8] * (__int64)a3[6];
  result[8] = *a3 * (__int64)a2[16]
            + a3[16] * (__int64)*a2
            + a3[4] * (__int64)a2[12]
            + a3[12] * (__int64)a2[4]
            + a3[8] * (__int64)a2[8]
            + 2
            * (a3[2] * (__int64)a2[14] + a3[14] * (__int64)a2[2] + a3[10] * (__int64)a2[6] + a2[10] * (__int64)a3[6]);
  result[9] = *a3 * (__int64)a2[18]
            + a3[18] * (__int64)*a2
            + a3[2] * (__int64)a2[16]
            + a3[16] * (__int64)a2[2]
            + a3[4] * (__int64)a2[14]
            + a3[14] * (__int64)a2[4]
            + a3[6] * (__int64)a2[12]
            + a3[12] * (__int64)a2[6]
            + a3[10] * (__int64)a2[8]
            + a2[10] * (__int64)a3[8];
  result[10] = a3[4] * (__int64)a2[16]
             + a3[16] * (__int64)a2[4]
             + a3[8] * (__int64)a2[12]
             + a3[12] * (__int64)a2[8]
             + 2
             * (a3[2] * (__int64)a2[18]
              + a3[18] * (__int64)a2[2]
              + a3[6] * (__int64)a2[14]
              + a3[10] * (__int64)a2[10]
              + a2[6] * (__int64)a3[14]);
  result[11] = a3[4] * (__int64)a2[18]
             + a3[18] * (__int64)a2[4]
             + a3[6] * (__int64)a2[16]
             + a3[16] * (__int64)a2[6]
             + a3[8] * (__int64)a2[14]
             + a3[14] * (__int64)a2[8]
             + a3[12] * (__int64)a2[10]
             + a2[12] * (__int64)a3[10];
  result[12] = a3[8] * (__int64)a2[16]
             + a3[16] * (__int64)a2[8]
             + a3[12] * (__int64)a2[12]
             + 2
             * (a3[6] * (__int64)a2[18] + a3[18] * (__int64)a2[6] + a3[14] * (__int64)a2[10] + a2[14] * (__int64)a3[10]);
  result[13] = a3[8] * (__int64)a2[18]
             + a3[18] * (__int64)a2[8]
             + a3[10] * (__int64)a2[16]
             + a3[16] * (__int64)a2[10]
             + a3[14] * (__int64)a2[12]
             + a2[14] * (__int64)a3[12];
  result[14] = a3[12] * (__int64)a2[16]
             + a3[16] * (__int64)a2[12]
             + 2 * (a3[10] * (__int64)a2[18] + a3[14] * (__int64)a2[14] + a2[10] * (__int64)a3[18]);
  result[15] = a3[12] * (__int64)a2[18] + a3[18] * (__int64)a2[12] + a3[16] * (__int64)a2[14] + a2[16] * (__int64)a3[14];
  result[16] = a3[16] * (__int64)a2[16] + 2 * (a3[18] * (__int64)a2[14] + a2[18] * (__int64)a3[14]);
  result[17] = a3[18] * (__int64)a2[16] + a2[18] * (__int64)a3[16];
  v3 = a2[18];
  v4 = a3[18];
  v5 = 2 * v3 * (v4 >> 31) + v4 * ((unsigned __int64)v3 >> 31);
  v6 = (unsigned int)(2 * v3) * (unsigned __int64)(unsigned int)v4;
  HIDWORD(v6) += v5;
  result[18] = v6;
  return result;
}

//----- (00016B54) --------------------------------------------------------
unsigned int *__fastcall sub_16B54(unsigned int *result)
{
  __int64 v1; // kr08_8
  unsigned int v2; // r12
  unsigned int v3; // r1
  unsigned int v4; // lr
  unsigned int v5; // r4
  unsigned __int64 v6; // kr20_8
  unsigned int v7; // r12
  unsigned int v8; // r1
  unsigned int v9; // lr
  unsigned int v10; // r4
  unsigned __int64 v11; // kr38_8
  unsigned int v12; // r12
  unsigned int v13; // r1
  unsigned int v14; // lr
  unsigned int v15; // r4
  unsigned __int64 v16; // kr50_8
  unsigned int v17; // r12
  unsigned int v18; // r1
  unsigned int v19; // lr
  unsigned int v20; // r4
  unsigned __int64 v21; // kr68_8
  unsigned int v22; // r1
  unsigned __int64 v23; // kr80_8
  unsigned int v24; // r12
  unsigned int v25; // r1
  unsigned int v26; // lr
  unsigned int v27; // r4
  unsigned __int64 v28; // kr98_8
  unsigned int v29; // r12
  unsigned int v30; // r1
  unsigned int v31; // lr
  unsigned int v32; // r4
  unsigned __int64 v33; // krB0_8
  unsigned int v34; // r12
  unsigned int v35; // r1
  unsigned int v36; // lr
  unsigned int v37; // r4

  v1 = 16LL * *((_QWORD *)result + 18)
     + *((_QWORD *)result + 8)
     + 2LL * *((_QWORD *)result + 18)
     + *((_QWORD *)result + 18);
  v2 = result[35];
  v3 = result[34];
  v4 = result[14];
  result[17] = HIDWORD(v1);
  v5 = result[15];
  result[16] = v1;
  v6 = __PAIR64__((16 * v2) | (v3 >> 28), 16 * v3)
     + __PAIR64__(v5, v4)
     + __PAIR64__(v2 + __CFADD__(v3, v3) + v2, 2 * v3)
     + __PAIR64__(v2, v3);
  v7 = result[33];
  v8 = result[32];
  v9 = result[12];
  result[15] = HIDWORD(v6);
  v10 = result[13];
  result[14] = v6;
  v11 = __PAIR64__((16 * v7) | (v8 >> 28), 16 * v8)
      + __PAIR64__(v10, v9)
      + __PAIR64__(v7 + __CFADD__(v8, v8) + v7, 2 * v8)
      + __PAIR64__(v7, v8);
  v12 = result[31];
  v13 = result[30];
  v14 = result[10];
  result[13] = HIDWORD(v11);
  v15 = result[11];
  result[12] = v11;
  v16 = __PAIR64__((16 * v12) | (v13 >> 28), 16 * v13)
      + __PAIR64__(v15, v14)
      + __PAIR64__(v12 + __CFADD__(v13, v13) + v12, 2 * v13)
      + __PAIR64__(v12, v13);
  v17 = result[29];
  v18 = result[28];
  v19 = result[8];
  result[11] = HIDWORD(v16);
  v20 = result[9];
  result[10] = v16;
  v21 = __PAIR64__((16 * v17) | (v18 >> 28), 16 * v18)
      + __PAIR64__(v20, v19)
      + __PAIR64__(v17 + __CFADD__(v18, v18) + v17, 2 * v18)
      + __PAIR64__(v17, v18);
  v22 = result[26];
  *((_QWORD *)result + 4) = v21;
  v23 = __PAIR64__((16 * result[27]) | (v22 >> 28), 16 * v22)
      + *((_QWORD *)result + 3)
      + __PAIR64__(result[27] + __CFADD__(v22, v22) + result[27], 2 * v22)
      + __PAIR64__(result[27], v22);
  v24 = result[25];
  v25 = result[24];
  v26 = result[4];
  result[7] = HIDWORD(v23);
  v27 = result[5];
  result[6] = v23;
  v28 = __PAIR64__((16 * v24) | (v25 >> 28), 16 * v25)
      + __PAIR64__(v27, v26)
      + __PAIR64__(v24 + __CFADD__(v25, v25) + v24, 2 * v25)
      + __PAIR64__(v24, v25);
  v29 = result[23];
  v30 = result[22];
  v31 = result[2];
  result[5] = HIDWORD(v28);
  v32 = result[3];
  result[4] = v28;
  v33 = __PAIR64__((16 * v29) | (v30 >> 28), 16 * v30)
      + __PAIR64__(v32, v31)
      + __PAIR64__(v29 + __CFADD__(v30, v30) + v29, 2 * v30)
      + __PAIR64__(v29, v30);
  v34 = result[21];
  v35 = result[20];
  v36 = *result;
  result[3] = HIDWORD(v33);
  v37 = result[1];
  result[2] = v33;
  *(_QWORD *)result = __PAIR64__((16 * v34) | (v35 >> 28), 16 * v35)
                    + __PAIR64__(v37, v36)
                    + __PAIR64__(v34 + __CFADD__(v35, v35) + v34, 2 * v35)
                    + __PAIR64__(v34, v35);
  return result;
}

//----- (00016DC0) --------------------------------------------------------
__int64 *__fastcall sub_16DC0(__int64 *result)
{
  int *v1; // r1
  __int64 v2; // r8
  bool v3; // cf
  int v4; // r10
  __int64 v5; // r4
  __int64 v6; // r2
  unsigned int v7; // r12
  __int64 v8; // r4
  __int64 v9; // kr18_8
  int v10; // lr

  v1 = (int *)result;
  result[10] = 0;
  do
  {
    v2 = *(_QWORD *)v1;
    v3 = *v1 >= ((*v1 + ((unsigned int)(v1[1] >> 31) >> 6)) & 0xFC000000);
    v4 = (*(_QWORD *)v1 + (unsigned __int64)((unsigned int)(v1[1] >> 31) >> 6)) >> 32;
    *v1 = *(_QWORD *)v1 % 0x4000000LL;
    v1[1] = HIDWORD(v2) - (v4 + !v3);
    v5 = v2 / 0x4000000 + *((_QWORD *)v1 + 1);
    *((_QWORD *)v1 + 1) = v5
                        - __PAIR64__(
                            (v5 + (unsigned __int64)((unsigned int)(SHIDWORD(v5) >> 31) >> 7)) >> 32,
                            (v5 + ((unsigned int)(SHIDWORD(v5) >> 31) >> 7)) & 0xFE000000);
    *((_QWORD *)v1 + 2) += v5 / 0x2000000;
    v1 += 4;
  }
  while ( result + 10 != (__int64 *)v1 );
  v6 = 16 * result[10] + *result + 2 * result[10] + result[10];
  v7 = *((_DWORD *)result + 3);
  *((_DWORD *)result + 20) = 0;
  *((_DWORD *)result + 21) = 0;
  v9 = v6;
  v8 = v6 + ((unsigned int)(SHIDWORD(v6) >> 31) >> 6);
  v3 = (unsigned int)v6 >= (((_DWORD)v6 + ((unsigned int)(SHIDWORD(v6) >> 31) >> 6)) & 0xFC000000);
  v10 = v6 % 0x4000000;
  LODWORD(v6) = *((_DWORD *)result + 2);
  *(_DWORD *)result = v10;
  *((_DWORD *)result + 1) = HIDWORD(v6) - (HIDWORD(v8) + !v3);
  result[1] = __PAIR64__(v7, v6) + v9 / 0x4000000;
  return result;
}

//----- (00016F00) --------------------------------------------------------
int __fastcall sub_16F00(int a1, int a2)
{
  int v2; // r0
  int v3; // r0

  v2 = ~(a1 ^ a2) & (~(a1 ^ a2) << 16);
  v3 = v2 & (v2 << 8) & (16 * (v2 & (v2 << 8)));
  return (v3 & (4 * v3) & (2 * (v3 & (4 * v3)))) >> 31;
}

//----- (00016F24) --------------------------------------------------------
int __fastcall sub_16F24(int a1, int a2, int a3)
{
  int v3; // r3
  int v4; // r2
  int v5; // r1
  int result; // r0
  int v7; // r6
  int v8; // t1
  int v9; // t1
  int v10; // r4

  v3 = a1 - 8;
  v4 = -a3;
  v5 = a2 - 8;
  result = a1 + 72;
  do
  {
    v8 = *(_DWORD *)(v3 + 8);
    v3 += 8;
    v7 = v8;
    v9 = *(_DWORD *)(v5 + 8);
    v5 += 8;
    v10 = (v9 ^ v7) & v4;
    *(_QWORD *)v3 = v7 ^ v10;
    *(_QWORD *)v5 = v10 ^ *(_DWORD *)v5;
  }
  while ( result != v3 );
  return result;
}

//----- (00016F70) --------------------------------------------------------
void *__fastcall sub_16F70(void *a1, int *a2)
{
  int v3; // r10
  int v4; // lr
  int v5; // r1
  int v6; // r11
  int v7; // r7
  int v8; // r6
  int v9; // r2
  int v10; // r3
  int v11; // r4
  unsigned __int64 v12; // r0
  unsigned __int64 v13; // r2
  int v14; // r12
  __int64 v15; // r2
  unsigned __int64 v16; // r2
  __int64 src[19]; // [sp+30h] [bp-9Ch] BYREF

  v3 = *a2;
  v4 = a2[2];
  v5 = 2 * *a2;
  v6 = a2[4];
  v7 = a2[6];
  v8 = a2[8];
  src[0] = v3 * (__int64)v3;
  v9 = v5;
  v10 = (unsigned __int64)v3 >> 31;
  v11 = v4 * v10 + v5 * (v4 >> 31);
  v12 = (unsigned int)v4 * (unsigned __int64)(unsigned int)v5;
  LODWORD(src[1]) = v12;
  HIDWORD(src[1]) = v11 + HIDWORD(v12);
  src[2] = 2 * (v4 * (__int64)v4 + v3 * (__int64)v6);
  src[3] = 2 * (v6 * (__int64)v4 + v3 * (__int64)v7);
  HIDWORD(v12) = v8 * v10 + v9 * (v8 >> 31);
  v13 = (unsigned int)v8 * (unsigned __int64)(unsigned int)v9;
  HIDWORD(v13) += HIDWORD(v12);
  src[4] = v6 * (__int64)v6 + 4LL * v4 * v7 + v13;
  HIDWORD(v13) = a2[10];
  src[5] = 2 * (SHIDWORD(v13) * (__int64)v3 + v7 * (__int64)v6 + v4 * (__int64)v8);
  HIDWORD(v12) = a2[12];
  src[6] = 2 * (SHIDWORD(v12) * (__int64)v3 + v7 * (__int64)v7 + v6 * (__int64)v8 + 2LL * v4 * SHIDWORD(v13));
  LODWORD(v13) = a2[14];
  src[7] = 2 * ((int)v13 * (__int64)v3 + SHIDWORD(v12) * (__int64)v4 + v8 * (__int64)v7 + v6 * (__int64)SHIDWORD(v13));
  LODWORD(v12) = a2[16];
  v14 = a2[18];
  src[8] = v8 * (__int64)v8
         + 2
         * (2 * ((int)v13 * (__int64)v4 + v7 * (__int64)SHIDWORD(v13))
          + SHIDWORD(v12) * (__int64)v6
          + v3 * (__int64)(int)v12);
  src[9] = 2
         * (v14 * (__int64)v3
          + (int)v12 * (__int64)v4
          + (int)v13 * (__int64)v6
          + SHIDWORD(v13) * (__int64)v8
          + v7 * (__int64)SHIDWORD(v12));
  src[10] = 2
          * ((int)v12 * (__int64)v6
           + SHIDWORD(v13) * (__int64)SHIDWORD(v13)
           + v8 * (__int64)SHIDWORD(v12)
           + 2 * ((int)v13 * (__int64)v7 + v4 * (__int64)v14));
  src[11] = 2
          * (v14 * (__int64)v6 + (int)v12 * (__int64)v7
                               + SHIDWORD(v12) * (__int64)SHIDWORD(v13)
                               + v8 * (__int64)(int)v13);
  src[12] = SHIDWORD(v12) * (__int64)SHIDWORD(v12)
          + 2 * ((int)v12 * (__int64)v8 + 2 * ((int)v13 * (__int64)SHIDWORD(v13) + v7 * (__int64)v14));
  src[13] = 2 * (v14 * (__int64)v8 + (int)v13 * (__int64)SHIDWORD(v12) + SHIDWORD(v13) * (__int64)(int)v12);
  src[14] = 2 * ((int)v13 * (__int64)(int)v13 + SHIDWORD(v12) * (__int64)(int)v12 + 2LL * SHIDWORD(v13) * v14);
  src[15] = 2 * ((int)v12 * (__int64)(int)v13 + SHIDWORD(v12) * (__int64)v14);
  v15 = 4LL * (int)v13;
  HIDWORD(v12) = v15 * (v14 >> 31) + v14 * HIDWORD(v15);
  v16 = (unsigned int)v15 * (unsigned __int64)(unsigned int)v14;
  HIDWORD(v16) += HIDWORD(v12);
  src[16] = (int)v12 * (__int64)(int)v12 + v16;
  src[17] = 2LL * (int)v12 * v14;
  src[18] = 2LL * v14 * v14;
  sub_16B54((unsigned int *)src);
  sub_16DC0(src);
  return memcpy(a1, src, 0x50u);
}

//----- (000172F4) --------------------------------------------------------
void *__fastcall sub_172F4(void *a1, int *a2, int *a3)
{
  __int64 v5[19]; // [sp+0h] [bp-98h] BYREF

  sub_1659C(v5, a2, a3);
  sub_16B54((unsigned int *)v5);
  sub_16DC0(v5);
  return memcpy(a1, v5, 0x50u);
}

//----- (00017330) --------------------------------------------------------
int __fastcall sub_17330(int a1, int a2, int *a3)
{
  int i; // r3
  int v6; // r8
  int v7; // r2
  __int64 v8; // r4
  int v9; // r10
  int v10; // r0
  int *v11; // r9
  int v12; // r8
  int v13; // r10
  unsigned int v14; // r8
  int v15; // r2
  int v16; // r0
  __int64 v17; // r4
  int v18; // r2
  int v19; // r10
  int v20; // r0
  int v21; // r3
  int v22; // r10
  int v23; // r3
  int v24; // r10
  int v25; // r10
  int v26; // r0
  int v27; // r2
  int v28; // r10
  int v29; // r2
  unsigned int v30; // r0
  int v31; // r10
  int v32; // r2
  int v33; // r0
  int v34; // r10
  int v35; // r0
  int *v36; // r7
  int *v37; // r8
  int *v38; // r2
  int *v39; // r3
  int *v40; // r3
  int *v41; // r3
  unsigned int v42; // r11
  __int64 *v43; // r0
  unsigned int *v44; // r0
  __int64 *v45; // r0
  unsigned int *v46; // r0
  __int64 *v47; // r0
  unsigned int *v48; // r0
  __int64 *v49; // r0
  int *v50; // r1
  int v51; // r7
  int v52; // r7
  int v53; // r7
  int v54; // r7
  int v55; // r7
  int v56; // r7
  int j; // r3
  int k; // r1
  int *v59; // r12
  int v60; // lr
  int v61; // r2
  int v62; // t1
  bool v63; // zf
  int v64; // r3
  int v65; // r3
  int v66; // r2
  int v67; // r3
  int v68; // r3
  int *v69; // r2
  int *v70; // r3
  int *v71; // r3
  int *v72; // r3
  int v73; // r2
  int m; // r2
  int *v75; // r3
  int v76; // r1
  int v77; // r0
  int v78; // t1
  bool v79; // zf
  int v80; // r12
  int v81; // r12
  int v82; // r0
  int v83; // r4
  int v84; // r4
  int v85; // r1
  int v86; // r0
  int v87; // r2
  int v88; // r3
  int v89; // r3
  int v90; // r0
  int v91; // r2
  int v92; // r3
  int n; // r2
  int v94; // r1
  int v95; // r1
  int v96; // r7
  int v97; // r5
  int v98; // r4
  int v99; // lr
  int v100; // r12
  int v101; // r0
  int v102; // r1
  int v103; // r2
  int v104; // r3
  int *v106; // [sp+4h] [bp-A28h]
  int *v107; // [sp+8h] [bp-A24h]
  int *v108; // [sp+Ch] [bp-A20h]
  int *v109; // [sp+10h] [bp-A1Ch]
  int *v110; // [sp+14h] [bp-A18h]
  int v111; // [sp+18h] [bp-A14h]
  unsigned int v112; // [sp+20h] [bp-A0Ch]
  int *v113; // [sp+24h] [bp-A08h]
  int v114; // [sp+28h] [bp-A04h]
  _BYTE v115[31]; // [sp+30h] [bp-9FCh] BYREF
  char v116; // [sp+4Fh] [bp-9DDh]
  int src[20]; // [sp+50h] [bp-9DCh] BYREF
  _BYTE v118[80]; // [sp+A0h] [bp-98Ch] BYREF
  int v119[20]; // [sp+F0h] [bp-93Ch] BYREF
  _BYTE dest[152]; // [sp+140h] [bp-8ECh] BYREF
  _QWORD v121[19]; // [sp+1D8h] [bp-854h] BYREF
  _QWORD v122[19]; // [sp+270h] [bp-7BCh] BYREF
  int v123[38]; // [sp+308h] [bp-724h] BYREF
  int v124[38]; // [sp+3A0h] [bp-68Ch] BYREF
  _QWORD v125[19]; // [sp+438h] [bp-5F4h] BYREF
  int v126[38]; // [sp+4D0h] [bp-55Ch] BYREF
  _QWORD v127[19]; // [sp+568h] [bp-4C4h] BYREF
  __int64 v128[19]; // [sp+600h] [bp-42Ch] BYREF
  int v129[38]; // [sp+698h] [bp-394h] BYREF
  int v130[36]; // [sp+730h] [bp-2FCh] BYREF
  __int64 v131[19]; // [sp+7C8h] [bp-264h] BYREF
  unsigned int v132[36]; // [sp+860h] [bp-1CCh] BYREF
  int v133; // [sp+8F8h] [bp-134h] BYREF
  int v134; // [sp+8FCh] [bp-130h]
  int v135; // [sp+900h] [bp-12Ch]
  int v136; // [sp+904h] [bp-128h]
  int v137; // [sp+908h] [bp-124h]
  __int16 v138; // [sp+90Ch] [bp-120h]
  __int16 v139; // [sp+90Eh] [bp-11Eh]
  int v140; // [sp+910h] [bp-11Ch]
  int v141; // [sp+914h] [bp-118h]
  int v142; // [sp+918h] [bp-114h]
  int v143; // [sp+91Ch] [bp-110h]
  int v144[39]; // [sp+990h] [bp-9Ch] BYREF

  for ( i = 0; i != 32; ++i )
    v115[i] = *(_BYTE *)(a2 + i);
  v6 = *((unsigned __int8 *)a3 + 3);
  v7 = *((unsigned __int8 *)a3 + 7);
  v8 = *((unsigned __int8 *)a3 + 6);
  v9 = (*((unsigned __int8 *)a3 + 5) << 16) | (*((unsigned __int8 *)a3 + 4) << 8);
  v10 = *((unsigned __int8 *)a3 + 8);
  src[1] = 0;
  v11 = (int *)v127;
  v12 = v9 | v6;
  v13 = *((unsigned __int8 *)a3 + 9);
  v115[0] &= 0xF8u;
  v14 = (((unsigned int)v12 | ((_DWORD)v8 << 24)) >> 2) & 0x1FFFFFF;
  v15 = (v10 << 16) | (v7 << 8);
  v16 = *((unsigned __int8 *)a3 + 11);
  src[3] = 0;
  v17 = v15 | (unsigned int)v8;
  v18 = *((unsigned __int8 *)a3 + 10);
  v116 = v116 & 0x3F | 0x40;
  src[4] = (((unsigned int)v17 | (v13 << 24)) >> 3) & 0x3FFFFFF;
  LODWORD(v17) = *((unsigned __int8 *)a3 + 12);
  v19 = (v16 << 16) | (v18 << 8) | v13;
  v20 = *((unsigned __int8 *)a3 + 14);
  v21 = *a3;
  src[5] = 0;
  src[7] = 0;
  src[0] = v21 & 0x3FFFFFF;
  src[6] = (((unsigned int)v19 | ((_DWORD)v17 << 24)) >> 5) & 0x1FFFFFF;
  v22 = *((unsigned __int8 *)a3 + 13);
  v23 = a3[4];
  src[9] = 0;
  src[11] = 0;
  src[10] = v23 & 0x1FFFFFF;
  LODWORD(v17) = (v20 << 16) | (v22 << 8) | v17;
  v24 = *((unsigned __int8 *)a3 + 15);
  src[2] = v14;
  LODWORD(v17) = v17 | (v24 << 24);
  v25 = *((unsigned __int8 *)a3 + 19);
  src[8] = (unsigned int)v17 >> 6;
  LODWORD(v17) = *((unsigned __int8 *)a3 + 22);
  v26 = *((unsigned __int8 *)a3 + 21);
  v27 = *((unsigned __int8 *)a3 + 20);
  src[13] = 0;
  src[15] = 0;
  src[17] = 0;
  src[19] = 0;
  v28 = (v26 << 16) | (v27 << 8) | v25;
  v29 = *((unsigned __int8 *)a3 + 23);
  v30 = v28 | ((_DWORD)v17 << 24);
  v31 = *((unsigned __int8 *)a3 + 25);
  src[12] = (v30 >> 1) & 0x3FFFFFF;
  LODWORD(v17) = (*((unsigned __int8 *)a3 + 24) << 16) | (v29 << 8) | v17;
  v32 = *((unsigned __int8 *)a3 + 26);
  v33 = *((unsigned __int8 *)a3 + 27) << 16;
  src[14] = (((unsigned int)v17 | (v31 << 24)) >> 3) & 0x1FFFFFF;
  LODWORD(v17) = *((unsigned __int8 *)a3 + 28);
  v34 = v33 | (v32 << 8) | v31;
  v35 = *((unsigned __int8 *)a3 + 30) << 16;
  src[16] = (((unsigned int)v34 | ((_DWORD)v17 << 24)) >> 4) & 0x3FFFFFF;
  src[18] = ((v35 | (*((unsigned __int8 *)a3 + 29) << 8) | (unsigned int)v17 | (*((unsigned __int8 *)a3 + 31) << 24)) >> 6)
          & 0x1FFFFFF;
  LODWORD(v17) = 1;
  memset(&dest[80], 0, 0x48u);
  memset(&v121[1], 0, 0x90u);
  v121[0] = v17;
  memset(&v122[1], 0, 0x90u);
  v122[0] = v17;
  v36 = (int *)v122;
  memset(v123, 0, sizeof(v123));
  memset(v124, 0, sizeof(v124));
  memset(&v125[1], 0, 0x90u);
  v125[0] = v17;
  memset(v126, 0, sizeof(v126));
  memset(&v127[1], 0, 0x90u);
  v127[0] = v17;
  memcpy(dest, src, 0x50u);
  v110 = (int *)v121;
  v113 = src;
  v106 = v126;
  v107 = (int *)v125;
  v37 = v123;
  v108 = v124;
  v109 = (int *)dest;
  do
  {
    v112 = *((unsigned __int8 *)v113 - 1);
    v113 = (int *)((char *)v113 - 1);
    v38 = v110;
    v110 = v107;
    v39 = v11;
    v107 = v38;
    v11 = v37;
    v37 = v39;
    v40 = v108;
    v108 = v109;
    v109 = v40;
    v41 = v106;
    v106 = v36;
    v36 = v41;
    v114 = 8;
    while ( 1 )
    {
      v42 = 0;
      v111 = (unsigned __int8)(v112 >> 7);
      sub_16F24((int)v106, (int)v108, v111);
      sub_16F24((int)v11, (int)v107, v111);
      memcpy(v118, v106, sizeof(v118));
      sub_16500((int)v106, (int)v11);
      sub_16568((int)v11, (int)v118);
      memcpy(v119, v108, sizeof(v119));
      sub_16500((int)v108, (int)v107);
      sub_16568((int)v107, (int)v119);
      sub_1659C(v131, v108, v11);
      sub_1659C(v132, v106, v107);
      sub_16B54((unsigned int *)v131);
      sub_16DC0(v131);
      v43 = (__int64 *)sub_16B54(v132);
      sub_16DC0(v43);
      memcpy(v119, v131, sizeof(v119));
      sub_16500((int)v131, (int)v132);
      sub_16568((int)v132, (int)v119);
      sub_16F70(v144, (int *)v131);
      sub_16F70(&v133, (int *)v132);
      v44 = (unsigned int *)sub_1659C(v132, &v133, src);
      v45 = (__int64 *)sub_16B54(v44);
      sub_16DC0(v45);
      memcpy(v109, v144, 0x50u);
      memcpy(v110, v132, 0x50u);
      sub_16F70(v129, v106);
      sub_16F70(v130, v11);
      v46 = (unsigned int *)sub_1659C(v36, v129, v130);
      v47 = (__int64 *)sub_16B54(v46);
      sub_16DC0(v47);
      sub_16568((int)v130, (int)v129);
      memset(&v128[10], 0, 0x48u);
      do
      {
        v128[v42 / 2] = 121665LL * *(_QWORD *)&v130[v42];
        v42 += 2;
      }
      while ( v42 != 20 );
      sub_16DC0(v128);
      sub_16500((int)v128, (int)v129);
      v48 = (unsigned int *)sub_1659C(v37, v130, (int *)v128);
      v49 = (__int64 *)sub_16B54(v48);
      sub_16DC0(v49);
      sub_16F24((int)v36, (int)v109, v111);
      sub_16F24((int)v37, (int)v110, v111);
      v112 = (unsigned __int8)(2 * v112);
      if ( !--v114 )
        break;
      v69 = v110;
      v110 = v107;
      v70 = v11;
      v107 = v69;
      v11 = v37;
      v37 = v70;
      v71 = v108;
      v108 = v109;
      v109 = v71;
      v72 = v106;
      v106 = v36;
      v36 = v72;
    }
  }
  while ( v115 != (_BYTE *)v113 );
  v50 = v36;
  v51 = 4;
  memcpy(v119, v50, sizeof(v119));
  memcpy(v144, v37, 0x50u);
  sub_16F70(v124, v144);
  sub_16F70(&v133, v124);
  sub_16F70(v132, &v133);
  sub_172F4(v125, (int *)v132, v144);
  sub_172F4(v126, (int *)v125, v124);
  sub_16F70(v132, v126);
  sub_172F4(v127, (int *)v132, (int *)v125);
  sub_16F70(v132, (int *)v127);
  sub_16F70(&v133, (int *)v132);
  sub_16F70(v132, &v133);
  sub_16F70(&v133, (int *)v132);
  sub_16F70(v132, &v133);
  sub_172F4(v128, (int *)v132, (int *)v127);
  sub_16F70(v132, (int *)v128);
  sub_16F70(&v133, (int *)v132);
  do
  {
    sub_16F70(v132, &v133);
    sub_16F70(&v133, (int *)v132);
    --v51;
  }
  while ( v51 );
  sub_172F4(v129, &v133, (int *)v128);
  v52 = 9;
  sub_16F70(v132, v129);
  sub_16F70(&v133, (int *)v132);
  do
  {
    sub_16F70(v132, &v133);
    sub_16F70(&v133, (int *)v132);
    --v52;
  }
  while ( v52 );
  sub_172F4(v132, &v133, v129);
  v53 = 4;
  sub_16F70(&v133, (int *)v132);
  sub_16F70(v132, &v133);
  do
  {
    sub_16F70(&v133, (int *)v132);
    sub_16F70(v132, &v133);
    --v53;
  }
  while ( v53 );
  v54 = 24;
  sub_172F4(v130, (int *)v132, (int *)v128);
  sub_16F70(v132, v130);
  sub_16F70(&v133, (int *)v132);
  do
  {
    sub_16F70(v132, &v133);
    sub_16F70(&v133, (int *)v132);
    --v54;
  }
  while ( v54 );
  sub_172F4(v131, &v133, v130);
  v55 = 49;
  sub_16F70(&v133, (int *)v131);
  sub_16F70(v132, &v133);
  do
  {
    sub_16F70(&v133, (int *)v132);
    sub_16F70(v132, &v133);
    --v55;
  }
  while ( v55 );
  sub_172F4(&v133, (int *)v132, (int *)v131);
  v56 = 24;
  sub_16F70(v132, &v133);
  sub_16F70(&v133, (int *)v132);
  do
  {
    sub_16F70(v132, &v133);
    sub_16F70(&v133, (int *)v132);
    --v56;
  }
  while ( v56 );
  sub_172F4(v132, &v133, v130);
  sub_16F70(&v133, (int *)v132);
  sub_16F70(v132, &v133);
  sub_16F70(&v133, (int *)v132);
  sub_16F70(v132, &v133);
  sub_16F70(&v133, (int *)v132);
  sub_172F4(v123, &v133, v126);
  sub_172F4(v144, v119, v123);
  for ( j = 0; j != 10; ++j )
    *(&v133 + j) = v144[2 * j];
  for ( k = 2; ; k = 1 )
  {
    v59 = &v133;
    v60 = 0;
    do
    {
      v62 = *v59++;
      v61 = v62;
      v63 = (v60++ & 1) == 0;
      v64 = v62 & (v62 >> 31);
      if ( v63 )
        v65 = v64 >> 26;
      else
        v65 = v64 >> 25;
      if ( v63 )
        v66 = v61 - (v65 << 26);
      else
        v66 = v61 - (v65 << 25);
      *(v59 - 1) = v66;
      *v59 += v65;
    }
    while ( v60 != 9 );
    v67 = (v143 & (v143 >> 31)) >> 25;
    v143 -= v67 << 25;
    v68 = v133 + 19 * v67;
    v133 = v68;
    if ( k == 1 )
      break;
  }
  v73 = (v68 & (v68 >> 31)) >> 26;
  v133 = v68 - (v73 << 26);
  v134 += v73;
  for ( m = 2; ; m = 1 )
  {
    v75 = &v133;
    v76 = 0;
    do
    {
      v78 = *v75++;
      v77 = v78;
      v79 = (v76++ & 1) == 0;
      if ( v79 )
        v80 = v77 & 0x3FFFFFF;
      else
        v80 = v77 & 0x1FFFFFF;
      *(v75 - 1) = v80;
      v81 = *v75;
      if ( v79 )
        v82 = v81 + (v77 >> 26);
      else
        v82 = v81 + (v77 >> 25);
      *v75 = v82;
    }
    while ( v76 != 9 );
    v83 = v143;
    v143 &= 0x1FFFFFFu;
    v84 = v133 + 19 * (v83 >> 25);
    v133 = v84;
    if ( m == 1 )
      break;
  }
  do
  {
    if ( (m & 1) != 0 )
      v85 = 0x1FFFFFF;
    else
      v85 = 0x3FFFFFF;
    v86 = sub_16F00(*(&v133 + m), v85);
    m = v87 + 1;
    v89 = v88 & v86;
  }
  while ( m != 10 );
  v90 = v89 & 0x3FFFFFF;
  v91 = v89 & 0x3FFFFED;
  v92 = v89 & 0x1FFFFFF;
  v133 = v84 - v91;
  for ( n = 1; n != 10; ++n )
  {
    v94 = *(&v133 + n);
    if ( (n & 1) != 0 )
      v95 = v94 - v92;
    else
      v95 = v94 - v90;
    *(&v133 + n) = v95;
  }
  v96 = v133;
  v97 = v134;
  v98 = v135;
  *(_BYTE *)a1 = v133;
  v99 = v136;
  v97 *= 4;
  v100 = v137;
  *(_BYTE *)(a1 + 1) = BYTE1(v96);
  v98 *= 8;
  v99 *= 32;
  v101 = v140;
  *(_BYTE *)(a1 + 3) = v97 | HIBYTE(v96);
  v100 <<= 6;
  v102 = v141;
  *(_BYTE *)(a1 + 4) = BYTE1(v97);
  v101 *= 2;
  v103 = v142;
  *(_BYTE *)(a1 + 6) = v98 | HIBYTE(v97);
  v102 *= 8;
  v104 = v143;
  *(_BYTE *)(a1 + 7) = BYTE1(v98);
  v103 *= 16;
  *(_BYTE *)(a1 + 2) = BYTE2(v96);
  *(_BYTE *)(a1 + 9) = v99 | HIBYTE(v98);
  *(_BYTE *)(a1 + 5) = BYTE2(v97);
  v104 <<= 6;
  *(_BYTE *)(a1 + 10) = BYTE1(v99);
  *(_BYTE *)(a1 + 8) = BYTE2(v98);
  *(_BYTE *)(a1 + 11) = BYTE2(v99);
  *(_BYTE *)(a1 + 12) = v100 | HIBYTE(v99);
  *(_BYTE *)(a1 + 13) = BYTE1(v100);
  *(_BYTE *)(a1 + 14) = BYTE2(v100);
  *(_BYTE *)(a1 + 15) = HIBYTE(v100);
  HIWORD(v100) = v139;
  *(_WORD *)(a1 + 16) = v138;
  *(_BYTE *)(a1 + 18) = BYTE2(v100);
  *(_BYTE *)(a1 + 19) = v101 | HIBYTE(v100);
  *(_BYTE *)(a1 + 20) = BYTE1(v101);
  *(_BYTE *)(a1 + 21) = BYTE2(v101);
  *(_BYTE *)(a1 + 22) = v102 | HIBYTE(v101);
  *(_BYTE *)(a1 + 23) = BYTE1(v102);
  *(_BYTE *)(a1 + 24) = BYTE2(v102);
  *(_BYTE *)(a1 + 25) = v103 | HIBYTE(v102);
  *(_BYTE *)(a1 + 26) = BYTE1(v103);
  *(_BYTE *)(a1 + 27) = BYTE2(v103);
  *(_BYTE *)(a1 + 28) = v104 | HIBYTE(v103);
  *(_BYTE *)(a1 + 29) = BYTE1(v104);
  *(_BYTE *)(a1 + 30) = BYTE2(v104);
  *(_BYTE *)(a1 + 31) = HIBYTE(v104);
  return 0;
}
// 17D34: variable 'v87' is possibly undefined
// 17D38: variable 'v88' is possibly undefined

//----- (00017ED8) --------------------------------------------------------
int __fastcall sub_17ED8(unsigned int *a1, const char *a2, unsigned int a3)
{
  int v5; // r0
  int v6; // r6
  int v7; // r5
  unsigned int v8; // r7
  _BOOL4 v9; // r3
  int v10; // r3
  size_t v11; // r2
  ssize_t v12; // r0
  ssize_t v13; // r11
  int v15; // [sp+8h] [bp-1014h]
  __int64 timeout; // [sp+10h] [bp-100Ch] BYREF
  fd_set readfds; // [sp+18h] [bp-1004h] BYREF

  v5 = open64(a2, 0);
  v6 = v5;
  if ( v5 >= 0 )
  {
    v8 = 0;
    v15 = 1 << (v5 & 0x1F);
    do
    {
      while ( 1 )
      {
        v9 = a3 > v8;
        if ( !a3 )
          v9 = 1;
        if ( !v9 )
        {
          v7 = 0;
          goto LABEL_22;
        }
        if ( !dword_4C45C )
        {
          v10 = 0;
          timeout = 2;
          do
            readfds.__fds_bits[v10++] = 0;
          while ( v10 != 32 );
          readfds.__fds_bits[v6 >> 5] |= v15;
          if ( !select(v6 + 1, &readfds, 0, 0, (struct timeval *)&timeout) )
          {
            sub_184E8(
              4,
              "Warning: Reading the randomness source '%s' seems to have blocked.\n"
              "You may need to find a better entropy source.",
              a2);
            dword_4C45C = 1;
          }
        }
        if ( a3 )
        {
          v11 = a3 - v8;
          if ( a3 - v8 >= 0x1000 )
            v11 = 4096;
        }
        else
        {
          v11 = 4096;
        }
        v12 = read(v6, &readfds, v11);
        v13 = v12;
        if ( v12 <= 0 )
          break;
        v8 += v12;
        sub_24A78(a1, (char *)&readfds, v12);
      }
    }
    while ( v12 && *_errno_location() == 4 );
    v7 = a3 | v13;
    if ( v7 )
      v7 = -1;
  }
  else
  {
    v7 = -1;
  }
LABEL_22:
  close(v6);
  return v7;
}
// 11B98: using guessed type int __fastcall open64(_DWORD, _DWORD);
// 4C45C: using guessed type int dword_4C45C;

//----- (0001803C) --------------------------------------------------------
int __fastcall sub_1803C(char *a1, unsigned int a2)
{
  unsigned int v5[52]; // [sp+0h] [bp-D0h] BYREF

  sub_24A08((int)v5);
  sub_24A78(v5, byte_4C460, 0x14u);
  sub_24A78(v5, a1, a2);
  return sub_248D4(v5, byte_4C460);
}

//----- (00018090) --------------------------------------------------------
int __fastcall sub_18090(char *a1, unsigned int a2)
{
  int v5; // r0
  size_t v6; // r7
  _DWORD src[5]; // [sp+4h] [bp-E8h] BYREF
  unsigned int v8[53]; // [sp+18h] [bp-D4h] BYREF

  if ( !dword_4C474 )
    sub_184AC("seedrandom not done");
  while ( a2 )
  {
    sub_24A08((int)v8);
    sub_24A78(v8, byte_4C460, 0x14u);
    sub_24A78(v8, (char *)&dword_4C478, 4u);
    v5 = sub_248D4(v8, src);
    if ( (unsigned int)++dword_4C478 > 0x40000000 )
      sub_18158(v5);
    if ( a2 >= 0x14 )
      v6 = 20;
    else
      v6 = a2;
    memcpy(a1, src, v6);
    a2 -= v6;
    a1 += v6;
  }
  return j_explicit_bzero(src, 20);
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 18158: using guessed type int __fastcall sub_18158(_DWORD);
// 4C474: using guessed type int dword_4C474;
// 4C478: using guessed type int dword_4C478;

//----- (00018158) --------------------------------------------------------
int sub_18158()
{
  int result; // r0
  FILE *v1; // r4
  __pid_t v2; // [sp+0h] [bp-100h] BYREF
  clock_t v3; // [sp+4h] [bp-FCh] BYREF
  struct timeval tv; // [sp+8h] [bp-F8h] BYREF
  char ptr[32]; // [sp+10h] [bp-F0h] BYREF
  unsigned int v6[52]; // [sp+30h] [bp-D0h] BYREF

  sub_24A08((int)v6);
  sub_24A78(v6, byte_4C460, 0x14u);
  if ( sub_17ED8(v6, "/dev/urandom", 0x20u) )
    sub_184AC("Failure reading random device %s", "/dev/urandom");
  sub_17ED8(v6, "/proc/timer_list", 0);
  sub_17ED8(v6, "/proc/interrupts", 0);
  sub_17ED8(v6, "/proc/loadavg", 0);
  sub_17ED8(v6, "/proc/sys/kernel/random/entropy_avail", 0);
  sub_17ED8(v6, "/proc/net/netstat", 0x1000u);
  sub_17ED8(v6, "/proc/net/dev", 0x1000u);
  sub_17ED8(v6, "/proc/net/tcp", 0x1000u);
  sub_17ED8(v6, "/proc/net/rt_cache", 0x1000u);
  sub_17ED8(v6, "/proc/vmstat", 0);
  v2 = getpid();
  sub_24A78(v6, (char *)&v2, 4u);
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  gettimeofday(&tv, 0);
  sub_24A78(v6, (char *)&tv, 8u);
  v3 = clock();
  sub_24A78(v6, (char *)&v3, 4u);
  sub_248D4(v6, byte_4C460);
  dword_4C478 = 0;
  dword_4C474 = 1;
  result = fopen64("/dev/urandom", "w");
  v1 = (FILE *)result;
  if ( result )
  {
    sub_18090(ptr, 0x20u);
    fwrite(ptr, 0x20u, 1u, v1);
    return fclose(v1);
  }
  return result;
}
// 11EA4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 4C474: using guessed type int dword_4C474;
// 4C478: using guessed type int dword_4C478;

//----- (00018314) --------------------------------------------------------
void __fastcall sub_18314(int *a1, int *a2, int a3)
{
  int v5; // r0
  int v6; // r9
  int v7; // r5
  int v8; // r4
  char *v9; // r0
  bool v10; // nf
  int v11; // r4
  int v12; // r4
  char *v13; // r6
  char *v14; // r9
  int v15; // [sp+0h] [bp-Ch]
  int v16; // [sp+4h] [bp-8h]
  int v17; // [sp+8h] [bp-4h] BYREF

  v17 = a3;
  v15 = 117637631;
  v16 = 2134843151;
  v5 = sub_2A310(a1);
  v6 = v5 & 7;
  v7 = v5 / 8;
  v8 = v5;
  if ( (v5 & 7) != 0 )
    ++v7;
  v9 = (char *)sub_18718(v7);
  v11 = -v8;
  v10 = v11 < 0;
  v12 = v11 & 7;
  v13 = v9;
  if ( !v10 )
    v6 = -v12;
  v14 = (char *)&v17 + v6;
  do
  {
    do
    {
      sub_18090(v13, v7);
      *v13 &= *(v14 - 8);
      sub_122E8((int)a2, (unsigned __int8 *)v13, v7);
    }
    while ( sub_29E00(a2, a1) != -1 );
  }
  while ( sub_29E48((int)a2, 0) != 1 );
  j_explicit_bzero(v13, v7);
  free(v13);
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);

//----- (000183E4) --------------------------------------------------------
void __fastcall __noreturn sub_183E4(int a1, const char *a2, void *a3)
{
  char s[304]; // [sp+4h] [bp-130h] BYREF

  snprintf(s, 0x12Cu, "Exited: %s", a2);
  off_4C3E8(6, s, a3);
  exit(a1);
}
// 4C3E8: using guessed type int (__fastcall *off_4C3E8)(int a1, char *format, __gnuc_va_list arg);

//----- (00018430) --------------------------------------------------------
int __fastcall sub_18430(int a1, char *format, __gnuc_va_list arg)
{
  char v4[1028]; // [sp+0h] [bp-404h] BYREF

  vsnprintf(v4, 0x400u, format, arg);
  return fprintf((FILE *)stderr, "%s\n", v4);
}
// 4C448: using guessed type int stderr;

//----- (00018478) --------------------------------------------------------
void __fastcall sub_18478(const char *a1)
{
  openlog(a1, 1, 80);
}

//----- (00018484) --------------------------------------------------------
void __noreturn sub_18484(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  off_4C3EC(0, a1, varg_r1);
}
// 4C3EC: using guessed type void (__fastcall __noreturn *off_4C3EC)(int a1, const char *a2, void *a3);

//----- (000184AC) --------------------------------------------------------
void __noreturn sub_184AC(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  off_4C3EC(1, a1, varg_r1);
}
// 4C3EC: using guessed type void (__fastcall __noreturn *off_4C3EC)(int a1, const char *a2, void *a3);

//----- (000184D4) --------------------------------------------------------
void __fastcall __noreturn sub_184D4(const char *a1, const char *a2, int a3)
{
  sub_184AC("Failed assertion (%s:%d): `%s'", a2, a3, a1);
}

//----- (000184E8) --------------------------------------------------------
int sub_184E8(int a1, char *a2, ...)
{
  va_list varg_r2; // [sp+10h] [bp+8h] BYREF

  va_start(varg_r2, a2);
  return off_4C3E8(a1, a2, varg_r2);
}
// 4C3E8: using guessed type int (__fastcall *off_4C3E8)(int a1, char *format, __gnuc_va_list arg);

//----- (0001851C) --------------------------------------------------------
int __fastcall sub_1851C(_DWORD *a1, FILE *a2)
{
  int v4; // r4
  int v5; // r0
  bool v6; // zf

  v4 = -1;
  sub_124A0((int)a1, 0);
  sub_12430(a1, 0);
  while ( a1[2] < a1[3] )
  {
    v5 = fgetc(a2);
    v6 = v5 == -1;
    if ( v5 != -1 )
      v6 = v5 == 10;
    v4 = v5;
    if ( v6 )
      goto LABEL_4;
    if ( v5 == 13 )
      goto LABEL_11;
    sub_125A4((int)a1, v5);
  }
  sub_12430(a1, 0);
LABEL_4:
  if ( v4 != -1 || a1[2] )
  {
LABEL_11:
    v4 = 0;
    sub_124A0((int)a1, 0);
  }
  return v4;
}

//----- (000185B8) --------------------------------------------------------
int __fastcall sub_185B8(int result)
{
  int v1; // r4
  char *v2; // r0

  v1 = result;
  if ( result >= 0 )
  {
    while ( 1 )
    {
      result = close(v1);
      if ( result >= 0 )
        break;
      result = *_errno_location();
      if ( result != 4 )
      {
        if ( result != 9 )
        {
          v2 = strerror(result);
          sub_184AC("Error closing fd %d, %s", v1, v2);
        }
        return result;
      }
    }
  }
  return result;
}

//----- (0001867C) --------------------------------------------------------
int __fastcall sub_1867C(_DWORD *a1, int a2)
{
  int v3; // r7
  int v4; // r4
  signed int v5; // r5
  void *v6; // r0
  ssize_t v7; // r0
  ssize_t v8; // r4
  int v9; // r3
  bool v10; // zf
  bool v12; // cc

  v3 = open64(a2, 0);
  if ( v3 < 0 )
    return -1;
  while ( 1 )
  {
    v5 = a1[3] - a1[2];
    v6 = (void *)sub_12624(a1, v5);
    v7 = read(v3, v6, v5);
    v8 = v7;
    if ( v7 < 0 )
      break;
    sub_124C4(a1, v7);
LABEL_11:
    v12 = v5 <= v8;
    if ( v5 > v8 )
      v12 = v8 <= 0;
    v4 = !v12;
    if ( v12 )
      goto LABEL_8;
  }
  v9 = *_errno_location();
  v10 = v9 == 11;
  if ( v9 != 11 )
    v10 = v9 == 4;
  if ( v10 )
    goto LABEL_11;
  v4 = -1;
LABEL_8:
  sub_185B8(v3);
  return v4;
}
// 11B98: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00018718) --------------------------------------------------------
void *__fastcall sub_18718(size_t a1)
{
  void *result; // r0

  if ( !a1 || (result = calloc(1u, a1)) == 0 )
    sub_184AC("m_malloc failed");
  return result;
}

//----- (00018744) --------------------------------------------------------
int __fastcall sub_18744(char *a1, unsigned int a2, char *path, int a4)
{
  char *v7; // r0
  const char *v8; // r7
  unsigned int i; // r4
  size_t v10; // r6
  int v11; // r0
  char *v13; // [sp+0h] [bp-10h] BYREF
  const char *v14; // [sp+4h] [bp-Ch]
  char *v15; // [sp+8h] [bp-8h]
  int v16; // [sp+Ch] [bp-4h]

  v13 = a1;
  v14 = (const char *)a2;
  v15 = path;
  v16 = a4;
  v7 = _xpg_basename(path);
  v8 = v7;
  if ( a1 )
  {
    v13 = v7;
    v14 = "-c";
    v15 = a1;
    v16 = 0;
  }
  else
  {
    v10 = strlen(v7) + 2;
    v13 = (char *)sub_18718(v10);
    snprintf(v13, v10, "-%s", v8);
    v14 = 0;
  }
  if ( signal(13, 0) == (__sighandler_t)-1 )
    sub_184AC("signal() error");
  for ( i = 3; i <= a2; ++i )
  {
    v11 = i;
    sub_185B8(v11);
  }
  return execv(path, &v13);
}

//----- (000187FC) --------------------------------------------------------
char *__fastcall sub_187FC(const char *a1)
{
  signed int v2; // r4
  char *result; // r0
  const char *v4; // r1
  int v5; // r12
  char *v6; // lr
  int v7; // r2
  int v8; // t1
  unsigned int v9; // r3
  bool v10; // cc
  int v11; // r3

  v2 = strlen(a1);
  result = (char *)sub_18718(v2 + 1);
  v4 = a1;
  v5 = 0;
  while ( 1 )
  {
    v6 = &result[v5];
    if ( v4 - a1 >= v2 )
      break;
    v8 = *(unsigned __int8 *)v4++;
    v7 = v8;
    v9 = v8 - 32;
    v10 = (unsigned int)(v8 - 9) > 1;
    if ( (unsigned int)(v8 - 9) > 1 )
      v10 = v9 > 0x5E;
    v11 = !v10;
    if ( v7 == 13 )
      v11 |= 1u;
    if ( v11 )
    {
      *v6 = v7;
      ++v5;
    }
  }
  *v6 = 0;
  return result;
}

//----- (0001886C) --------------------------------------------------------
char *__fastcall sub_1886C(const char *a1)
{
  char *result; // r0

  result = strdup(a1);
  if ( !result )
    sub_184AC("m_strdup failed");
  return result;
}

//----- (00018888) --------------------------------------------------------
void *__fastcall sub_18888(void *a1, size_t a2)
{
  void *result; // r0

  if ( !a2 || (result = realloc(a1, a2)) == 0 )
    sub_184AC("m_realloc failed");
  return result;
}

//----- (000188B0) --------------------------------------------------------
int *__fastcall sub_188B0(int a1)
{
  int *result; // r0

  result = (int *)fcntl(a1, 4, 2048);
  if ( (int)result < 0 )
  {
    result = _errno_location();
    if ( *result != 19 )
      sub_184AC("Couldn't set nonblocking");
  }
  return result;
}

//----- (000188E4) --------------------------------------------------------
int __fastcall sub_188E4(void (__fastcall *a1)(int), int a2, int *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  int v10; // r5
  __pid_t v12; // r0
  int v13; // r9
  int v14; // r3
  int fd; // [sp+0h] [bp-1Ch] BYREF
  int v16; // [sp+4h] [bp-18h]
  int pipedes[2]; // [sp+8h] [bp-14h] BYREF
  int v18[3]; // [sp+10h] [bp-Ch] BYREF

  if ( pipe(&fd) )
    return -1;
  v10 = pipe(pipedes);
  if ( v10 || a5 && pipe(v18) )
    return -1;
  v12 = fork();
  v13 = v12;
  if ( v12 < 0 )
    return -1;
  if ( !v12 )
  {
    if ( signal(17, 0) == (__sighandler_t)-1 )
      sub_184AC("signal() error");
    if ( dup2(fd, v13) < 0 || dup2(pipedes[1], 1) < 0 || a5 && dup2(v18[1], 2) < 0 )
      sub_184AC("Child dup2() failure");
    close(v16);
    close(fd);
    close(pipedes[0]);
    close(pipedes[1]);
    if ( a5 )
    {
      close(v18[0]);
      close(v18[1]);
    }
    a1(a2);
    return -1;
  }
  close(fd);
  close(pipedes[1]);
  sub_188B0(pipedes[0]);
  sub_188B0(v16);
  if ( a5 )
  {
    close(v18[1]);
    sub_188B0(v18[0]);
    if ( !a6 )
    {
      *a3 = v16;
      *a4 = pipedes[0];
      goto LABEL_24;
    }
  }
  else if ( !a6 )
  {
    *a3 = v16;
    *a4 = pipedes[0];
    return v10;
  }
  v14 = v16;
  *a6 = v13;
  *a3 = v14;
  *a4 = pipedes[0];
  if ( a5 )
LABEL_24:
    *a5 = v18[0];
  return v10;
}

//----- (00018AA8) --------------------------------------------------------
int sub_18AA8()
{
  __int64 v1; // [sp+0h] [bp-10h] BYREF
  int v2; // [sp+8h] [bp-8h]
  int v3; // [sp+Ch] [bp-4h]

  v1 = 0;
  v2 = 0;
  v3 = 0;
  return setrlimit64(4, &v1);
}
// 119D0: using guessed type int __fastcall setrlimit64(_DWORD, _DWORD);

//----- (00018AD0) --------------------------------------------------------
unsigned int __fastcall sub_18AD0(const char *a1, unsigned int *a2)
{
  int *v4; // r4
  unsigned int result; // r0

  v4 = _errno_location();
  *v4 = 0;
  result = strtoul(a1, 0, 10);
  if ( !result )
  {
    if ( *v4 == 22 )
      return -1;
    goto LABEL_6;
  }
  if ( result != -1 || *v4 != 34 )
  {
LABEL_6:
    *a2 = result;
    return 0;
  }
  return result;
}

//----- (00018B34) --------------------------------------------------------
char *__fastcall sub_18B34(const char *a1)
{
  __uid_t v2; // r0
  struct passwd *v3; // r0
  struct passwd *v4; // r6
  const char *pw_dir; // r7
  size_t v7; // r4
  size_t v8; // r4
  char *v9; // r7

  if ( *a1 == 47 )
    return sub_1886C(a1);
  v2 = getuid();
  v3 = getpwuid(v2);
  v4 = v3;
  if ( !v3 )
    return sub_1886C(a1);
  pw_dir = v3->pw_dir;
  if ( !pw_dir )
    return sub_1886C(a1);
  v7 = strlen(a1);
  v8 = v7 + strlen(pw_dir) + 2;
  v9 = (char *)sub_18718(v8);
  snprintf(v9, v8, "%s/%s", v4->pw_dir, a1);
  return v9;
}

//----- (00018BC0) --------------------------------------------------------
int __fastcall sub_18BC0(int a1, int a2, int a3)
{
  int v3; // r3
  int result; // r0
  int v6; // r12
  int v7; // r4

  v3 = 0;
  result = 0;
  while ( v3 != a3 )
  {
    v6 = *(unsigned __int8 *)(a1 + v3);
    v7 = *(unsigned __int8 *)(a2 + v3++);
    result |= v6 ^ v7;
  }
  return result;
}

//----- (00018BF0) --------------------------------------------------------
time_t __fastcall sub_18BF0(int a1, int a2)
{
  int v2; // r3
  _DWORD v4[2]; // [sp+0h] [bp-8h] BYREF

  v4[0] = a1;
  v4[1] = a2;
  if ( dword_4C3F0 == -2 )
  {
    if ( syscall(263, 6, v4) )
    {
      if ( syscall(263, 1, v4) )
        v2 = -1;
      else
        v2 = 1;
    }
    else
    {
      v2 = 6;
    }
    dword_4C3F0 = v2;
  }
  if ( dword_4C3F0 < 0 )
    return time(0);
  if ( syscall(263) )
    sub_184AC("Clock broke");
  return v4[0];
}
// 4C3F0: using guessed type int dword_4C3F0;

//----- (00018C84) --------------------------------------------------------
void __fastcall sub_18C84(const char *a1)
{
  char *v1; // r5
  char *v2; // r0
  int v3; // r0
  int v4; // r4

  v1 = sub_1886C(a1);
  v2 = dirname(v1);
  v3 = open64(v2, 0);
  if ( v3 != -1 )
  {
    v4 = v3;
    fsync(v3);
    sub_185B8(v4);
  }
  free(v1);
}
// 11B98: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (00018CC0) --------------------------------------------------------
int __fastcall sub_18CC0(int a1, int a2)
{
  const char *v4; // r0
  FILE *v5; // r1
  int v6; // r3
  int v7; // r9
  int v8; // r3
  const char *v9; // r2
  const char *v10; // r1
  int v11; // r4
  unsigned int v13; // r7
  const char *v14; // r8
  const char *v15; // r6
  int *v16; // r0
  int *v17; // r5
  char *v18; // r0

  sub_1645C();
  sub_18158();
  if ( a1 != 5 )
  {
    v4 = "All arguments must be specified\n";
    v5 = (FILE *)stderr;
LABEL_11:
    fputs(v4, v5);
    v9 = *(const char **)a2;
    v10 = "Usage: %s <inputtype> <outputtype> <inputfile> <outputfile>\n"
          "\n"
          "CAUTION: This program is for convenience only, and is not secure if used on\n"
          "untrusted input files, ie it could allow arbitrary code execution.\n"
          "All parameters must be specified in order.\n"
          "\n"
          "The input and output types are one of:\n"
          "openssh\n"
          "dropbear\n"
          "\n"
          "Example:\n"
          "dropbearconvert openssh dropbear /etc/ssh/ssh_host_rsa_key /etc/dropbear_rsa_host_key\n";
LABEL_12:
    v11 = 1;
    fprintf((FILE *)stderr, v10, v9);
    return v11;
  }
  v6 = **(unsigned __int8 **)(a2 + 4);
  if ( v6 == 100 )
  {
    v7 = 0;
  }
  else
  {
    if ( v6 != 111 )
    {
      v5 = (FILE *)stderr;
      v4 = "Invalid input key type\n";
      goto LABEL_11;
    }
    v7 = 1;
  }
  v8 = **(unsigned __int8 **)(a2 + 8);
  if ( v8 == 100 )
  {
    v13 = 0;
  }
  else
  {
    if ( v8 != 111 )
    {
      v5 = (FILE *)stderr;
      v4 = "Invalid output key type\n";
      goto LABEL_11;
    }
    v13 = 1;
  }
  umask(0x3Fu);
  v14 = *(const char **)(a2 + 12);
  v15 = *(const char **)(a2 + 16);
  v16 = sub_1AD48(v14, 0, (int *)v7);
  v17 = v16;
  if ( !v16 )
  {
    v9 = v14;
    v10 = "Error reading key from '%s'\n";
    goto LABEL_12;
  }
  v18 = sub_1E660(*v16, 0);
  fprintf((FILE *)stderr, "Key is a %s key\n", v18);
  if ( sub_1B3B8(v15, v17, 0, v13) == 1 )
  {
    v11 = 0;
    fprintf((FILE *)stderr, "Wrote key to '%s'\n", v15);
  }
  else
  {
    v11 = 1;
    fprintf((FILE *)stderr, "Error writing key to '%s'\n", v15);
  }
  sub_1EA60((int)v17);
  return v11;
}
// 4C448: using guessed type int stderr;

//----- (00018E20) --------------------------------------------------------
int __fastcall sub_18E20(const char *a1)
{
  return fprintf(
           (FILE *)stderr,
           "Usage: %s -t <type> -f <filename> [-s bits]\n"
           "-t type\tType of key to generate. One of:\n"
           "\t\trsa\n"
           "\t\tecdsa\n"
           "-f filename    Use filename for the secret key.\n"
           "               ~/.ssh/id_dropbear is recommended for client keys.\n"
           "-s bits\tKey size in bits, should be a multiple of 8 (optional)\n"
           "           ECDSA has sizes 256 384 521 \n"
           "-y\t\tJust print the publickey and fingerprint for the\n"
           "\t\tprivate key in <filename>.\n",
           a1);
}
// 4C448: using guessed type int stderr;

//----- (00018E3C) --------------------------------------------------------
void __fastcall sub_18E3C(int a1, unsigned int a2)
{
  _DWORD *v4; // r4
  unsigned int v5; // r5
  unsigned __int8 *v6; // r0
  char *v7; // r8
  int v8; // r0
  char *v9; // r5
  __uid_t v10; // r0
  struct passwd *v11; // r0
  const char *pw_name; // r6
  unsigned int v13; // [sp+8h] [bp-DB0h] BYREF
  char v14[100]; // [sp+Ch] [bp-DACh] BYREF
  char v15[3392]; // [sp+70h] [bp-D48h] BYREF

  v4 = sub_12344(0x6A4u);
  sub_1E964(v4, a1, a2);
  sub_124A0((int)v4, 4u);
  v5 = v4[1] - v4[2];
  v13 = 3400;
  v6 = (unsigned __int8 *)sub_125E4(v4, v5);
  if ( sub_26D2C(v6, v5, v15, &v13) )
    fputs("base64 failed", (FILE *)stderr);
  v7 = sub_1E660(a2, 0);
  v8 = sub_125E4(v4, v5);
  v9 = (char *)sub_1EAE0(v8, v5);
  v10 = getuid();
  v11 = getpwuid(v10);
  if ( v11 )
    pw_name = v11->pw_name;
  else
    pw_name = "";
  gethostname(v14, 0x64u);
  v14[99] = 0;
  printf("Public key portion is:\n%s %s %s@%s\nFingerprint: %s\n", v7, v15, pw_name, v14, v9);
  free(v9);
  j_free(v4);
}
// 1EAE0: using guessed type int __fastcall sub_1EAE0(_DWORD, _DWORD);
// 4C448: using guessed type int stderr;

//----- (00018F5C) --------------------------------------------------------
int __fastcall sub_18F5C(const char *a1, unsigned int a2)
{
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r4
  unsigned int v7; // [sp+4h] [bp-4h] BYREF

  v7 = a2;
  v3 = sub_12344(0x6A4u);
  if ( sub_1867C(v3, (int)a1) )
  {
    v4 = -1;
    v5 = 0;
    fprintf((FILE *)stderr, "Failed reading '%s'\n", a1);
  }
  else
  {
    v5 = sub_1E644();
    v7 = 80;
    sub_124A0((int)v3, 0);
    v4 = sub_1E858(v3, (int)v5, (int *)&v7);
    if ( v4 == -1 )
    {
      fprintf((FILE *)stderr, "Bad key in '%s'\n", a1);
    }
    else
    {
      sub_18E3C((int)v5, v7);
      v4 = 0;
    }
  }
  sub_1238C(v3);
  j_free(v3);
  if ( v5 )
    sub_1EA60((int)v5);
  return v4;
}
// 4C448: using guessed type int stderr;

//----- (0001903C) --------------------------------------------------------
int __fastcall sub_1903C(signed int a1, const char **a2)
{
  int v2; // r4
  char **p_s1; // r5
  signed int i; // r1
  const char *v7; // r8
  FILE *v8; // r1
  const char *v9; // r0
  int v10; // r0
  char *v11; // r2
  unsigned int v12; // r3
  char *v13; // r7
  unsigned int v14; // r4
  int v15; // r0
  unsigned int v16; // r1
  const char *v18; // [sp+0h] [bp-10h] BYREF
  char *s1; // [sp+4h] [bp-Ch] BYREF
  int v20; // [sp+8h] [bp-8h] BYREF
  int v21; // [sp+Ch] [bp-4h] BYREF

  v2 = 0;
  p_s1 = 0;
  v18 = 0;
  s1 = 0;
  v20 = 0;
  v21 = 0;
  sub_1645C();
  sub_18158();
  for ( i = 1; i < a1; ++i )
  {
    v11 = (char *)a2[i];
    if ( v11 )
    {
      if ( p_s1 )
      {
        *p_s1 = v11;
        p_s1 = 0;
      }
      else if ( *v11 == 45 )
      {
        v12 = (unsigned __int8)v11[1];
        if ( v12 == 115 )
        {
          p_s1 = (char **)&v20;
        }
        else if ( v12 > 0x73 )
        {
          if ( v12 == 116 )
          {
            p_s1 = &s1;
          }
          else
          {
            if ( v12 != 121 )
              goto LABEL_15;
            v2 = 1;
          }
        }
        else
        {
          if ( v12 != 102 )
          {
            if ( v12 != 104 )
            {
LABEL_15:
              fprintf((FILE *)stderr, "Unknown argument %s\n");
              goto LABEL_16;
            }
            sub_18E20(*a2);
            v10 = 0;
LABEL_25:
            exit(v10);
          }
          p_s1 = (char **)&v18;
        }
      }
    }
  }
  v7 = v18;
  if ( !v18 )
  {
    v8 = (FILE *)stderr;
    v9 = "Must specify a key filename\n";
LABEL_29:
    fputs(v9, v8);
LABEL_16:
    sub_18E20(*a2);
LABEL_17:
    v10 = 1;
    goto LABEL_25;
  }
  if ( v2 )
  {
    v10 = sub_18F5C(v18, i);
    goto LABEL_25;
  }
  v13 = s1;
  if ( !s1 )
  {
    v8 = (FILE *)stderr;
    v9 = "Must specify key type\n";
    goto LABEL_29;
  }
  if ( !strcmp(s1, "rsa") )
    v14 = 0;
  else
    v14 = 90;
  if ( !strcmp(v13, "ecdsa") )
  {
    v14 = 70;
  }
  else if ( v14 == 90 )
  {
    fprintf((FILE *)stderr, "Unknown key type '%s'\n");
    goto LABEL_16;
  }
  if ( v20 )
  {
    if ( _isoc99_sscanf(v20, "%u", &v21) != 1 )
    {
      fputs("Bits must be an integer\n", (FILE *)stderr);
      goto LABEL_17;
    }
    if ( !v14 && ((unsigned int)(v21 - 512) > 0xE00 || (v21 & 7) != 0) )
      sub_184AC("Bits must satisfy 512 <= bits <= 4096, and be a multiple of 8\n");
  }
  v15 = sub_1A440(v14, v21);
  fprintf((FILE *)stderr, "Generating %u bit %s key, this may take a while...\n", v15, v13);
  if ( sub_1A488(v14, v21, v7, 0) == -1 )
    sub_184AC("Failed to generate key.\n");
  sub_18F5C(v7, v16);
  return 0;
}
// 1924C: variable 'v16' is possibly undefined
// 11D0C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 4C448: using guessed type int stderr;

//----- (0001928C) --------------------------------------------------------
void sub_1928C()
{
  int *v0; // r1
  int *v1; // r2
  int v2; // r3
  int v3; // t1

  v0 = &dword_4C3F0;
  v1 = dword_39FBC;
  while ( 1 )
  {
    v3 = v0[1];
    ++v0;
    v2 = v3;
    if ( !v3 )
      break;
    while ( *v1 > 0 )
    {
      if ( *(_DWORD *)v2 == *v1 )
      {
        *(_DWORD *)(v2 + 4) = v1;
        break;
      }
      v1 += 7;
    }
    if ( !*(_DWORD *)(v2 + 4) )
      sub_184AC("Missing ECC params %s", *(const char **)(v2 + 12));
  }
}
// 39FBC: using guessed type _DWORD dword_39FBC[79];
// 4C3F0: using guessed type int dword_4C3F0;

//----- (000192EC) --------------------------------------------------------
int __fastcall sub_192EC(int a1)
{
  int *v1; // r2
  int v2; // r3
  int v3; // t1

  v1 = &dword_4C3F0;
  do
  {
    v3 = v1[1];
    ++v1;
    v2 = v3;
    if ( !v3 )
      _assert_fail("*curve", "ecc.c", 0x47u, "curve_for_dp");
  }
  while ( *(_DWORD *)(v2 + 4) != a1 );
  return v2;
}
// 4C3F0: using guessed type int dword_4C3F0;

//----- (00019338) --------------------------------------------------------
char *__fastcall sub_19338(int a1, int a2)
{
  char *v2; // r4

  v2 = (char *)sub_18718(0x1Cu);
  sub_12224((int)(v2 + 12), v2 + 16, v2 + 20, v2 + 24, 0, a2);
  return v2;
}

//----- (00019370) --------------------------------------------------------
_DWORD *__fastcall sub_19370(_DWORD *a1, int a2)
{
  _DWORD *v2; // r3
  _BYTE *v5; // r0
  unsigned int v7; // [sp+4h] [bp-4h] BYREF

  v2 = *(_DWORD **)(a2 + 8);
  v7 = a2;
  v7 = 2 * *v2 + 1;
  sub_1279C(a1, v7);
  v5 = (_BYTE *)sub_12624(a1, v7);
  if ( sub_27634(a2, v5, &v7) )
    sub_184AC("ECC error");
  return sub_124C4(a1, v7);
}

//----- (000193DC) --------------------------------------------------------
char *__fastcall sub_193DC(_DWORD *a1, int a2)
{
  unsigned int v4; // r5
  int v5; // r0
  int v6; // r1
  char *v7; // r4
  char *v8; // r0
  int v9; // r3
  int v10; // r7
  unsigned __int8 *v11; // r0
  int v12; // r1
  int v13; // r2
  int v14; // r7
  unsigned __int8 *v15; // r0
  int v16; // r5
  int i; // r0
  void *ptr; // [sp+8h] [bp-14h] BYREF
  void *v20; // [sp+Ch] [bp-10h] BYREF
  void *v21; // [sp+10h] [bp-Ch] BYREF
  void *v22; // [sp+14h] [bp-8h] BYREF

  v4 = **(_DWORD **)(a2 + 4);
  sub_124A0((int)a1, 0);
  v5 = sub_12560((int)a1);
  if ( (unsigned __int8)(v5 - 2) <= 1u )
  {
    sub_184E8(4, "Dropbear doesn't support ECC point compression");
    return 0;
  }
  if ( v5 != 4 || a1[1] != 2 * v4 + 1 )
    return 0;
  v8 = sub_19338(4, v6);
  v9 = *(_DWORD *)(a2 + 4);
  v10 = *((_DWORD *)v8 + 3);
  v7 = v8;
  *((_DWORD *)v8 + 2) = v9;
  v11 = (unsigned __int8 *)sub_125E4(a1, v4);
  if ( sub_2DE30(v10, v11, v4) )
    goto LABEL_7;
  sub_1250C((int)a1, v4);
  v14 = *((_DWORD *)v7 + 4);
  v15 = (unsigned __int8 *)sub_125E4(a1, v4);
  if ( sub_2DE30(v14, v15, v4) )
    goto LABEL_7;
  sub_1250C((int)a1, v4);
  sub_2E630(*((_DWORD *)v7 + 5), 1);
  sub_12224((int)&ptr, &v20, &v21, &v22, 0);
  v16 = sub_2DCD0((int *)ptr, *(_BYTE **)(*((_DWORD *)v7 + 2) + 8), 16);
  if ( !v16 )
  {
    v16 = sub_2DCD0((int *)v20, *(_BYTE **)(*((_DWORD *)v7 + 2) + 12), 16);
    if ( !v16 )
    {
      v16 = sub_2E6C0(*((int **)v7 + 4), (int *)v21);
      if ( !v16 )
      {
        v16 = sub_2E6C0(*((int **)v7 + 3), (int *)v22);
        if ( !v16 )
        {
          v16 = sub_2C470((int *)v22, (int *)ptr, (int *)v22);
          if ( !v16 )
          {
            v16 = sub_2CB6C(*((int **)v7 + 3), (int *)v22, (int *)v22);
            if ( !v16 )
            {
              v16 = sub_2E764((int *)v21, (int *)v22, (int *)v21);
              if ( !v16 )
              {
                v16 = sub_29934((int *)v21, *((int **)v7 + 3), (int *)v21);
                if ( !v16 )
                {
                  v16 = sub_29934((int *)v21, *((int **)v7 + 3), (int *)v21);
                  if ( !v16 )
                  {
                    v16 = sub_29934((int *)v21, *((int **)v7 + 3), (int *)v21);
                    if ( !v16 )
                    {
                      for ( i = sub_2C470((int *)v21, (int *)ptr, (int *)v21);
                            ;
                            i = sub_29934((int *)v21, (int *)ptr, (int *)v21) )
                      {
                        v16 = i;
                        if ( i )
                          break;
                        if ( sub_29E48((int)v21, 0) != -1 )
                        {
                          while ( sub_29E00((int *)v21, (int *)ptr) != -1 )
                          {
                            v16 = sub_2E764((int *)v21, (int *)ptr, (int *)v21);
                            if ( v16 )
                              goto LABEL_28;
                          }
                          if ( sub_29E00((int *)v21, (int *)v20) )
                            v16 = 7;
                          else
                            v16 = 0;
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_28:
  sub_29DB8((int)ptr, v20, v21, v22, 0);
  free(ptr);
  free(v20);
  free(v21);
  free(v22);
  if ( v16 || !sub_29E48(*((_DWORD *)v7 + 3), 0) || !sub_29E48(*((_DWORD *)v7 + 4), 0) )
  {
LABEL_7:
    sub_277B4((int *)v7, v12, v13);
    free(v7);
    return 0;
  }
  return v7;
}
// 19444: variable 'v6' is possibly undefined
// 19480: variable 'v12' is possibly undefined
// 19480: variable 'v13' is possibly undefined

//----- (000196E0) --------------------------------------------------------
int *__fastcall sub_196E0(int a1, _DWORD *a2)
{
  int **v4; // r6
  int *v5; // r4
  int *v6; // r5

  if ( *a2 != 1
    || a2[2] != *(_DWORD *)(a1 + 8)
    || (v4 = (int **)sub_28738()) == 0
    || (v5 = (int *)sub_18718(0x10u), sub_121B0((int)v5), sub_2DCD0(v5, *(_BYTE **)(a2[2] + 8), 16))
    || off_4C72C(a2[6], a1 + 12, v4, v5, 1)
    || (v6 = (int *)sub_18718(0x10u), sub_121B0((int)v6), sub_2A25C(*v4, v6)) )
  {
    sub_184AC("ECC error");
  }
  sub_29D74((int)v5);
  free(v5);
  sub_2877C((int *)v4);
  return v6;
}
// 4C72C: using guessed type int (__fastcall *off_4C72C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000197C0) --------------------------------------------------------
bool __fastcall sub_197C0(int a1)
{
  return (unsigned int)(a1 - 1) <= 2;
}

//----- (000197D4) --------------------------------------------------------
int __fastcall sub_197D4(int a1)
{
  int v1; // r0

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 == dword_4C428 )
    return 1;
  if ( v1 == dword_4C418 )
    return 2;
  if ( v1 == dword_4C408 )
    return 3;
  return 90;
}
// 4C408: using guessed type int dword_4C408;
// 4C418: using guessed type int dword_4C418;
// 4C428: using guessed type int dword_4C428;

//----- (0001982C) --------------------------------------------------------
_DWORD *__fastcall sub_1982C(int a1)
{
  void *v1; // r3
  int *v2; // r4
  _DWORD *v3; // r5

  switch ( a1 )
  {
    case 384:
      v1 = &unk_4C414;
      break;
    case 521:
      v1 = &unk_4C404;
      break;
    case 256:
      v1 = &unk_4C424;
      break;
    default:
      goto LABEL_5;
  }
  v2 = (int *)*((_DWORD *)v1 + 1);
  if ( !v2 )
LABEL_5:
    sub_184AC("Key size %d isn't valid. Try 256 384 521 ", a1);
  v3 = sub_18718(0x1Cu);
  if ( sub_277F4(0, dword_4C3E4, v3, v2) )
    sub_184AC("ECC error");
  return v3;
}
// 4C3E4: using guessed type int dword_4C3E4;

//----- (000198C8) --------------------------------------------------------
char *__fastcall sub_198C8(_DWORD *a1, size_t a2, size_t a3)
{
  char *v4; // r8
  void *v5; // r0
  void *v6; // r6
  int *v7; // r5
  char *v8; // r4
  const char *v9; // r4
  size_t v10; // r0
  int *v11; // r9
  char *v12; // t1
  _DWORD *v13; // r5
  _DWORD *v15; // [sp+0h] [bp-Ch] BYREF
  size_t n[2]; // [sp+4h] [bp-8h] BYREF

  v15 = a1;
  n[0] = a2;
  n[1] = a3;
  v4 = (char *)sub_12690(a1, (unsigned int *)&v15);
  v5 = sub_12690(a1, n);
  v6 = v5;
  if ( (_DWORD *)(n[0] + 11) == v15 && !memcmp(v4 + 11, v5, n[0]) )
  {
    v7 = (int *)&off_4C3F4;
    while ( 1 )
    {
      v11 = v7;
      v12 = (char *)*v7++;
      v8 = v12;
      if ( !v12 )
        break;
      v9 = (const char *)*((_DWORD *)v8 + 3);
      v10 = strlen(v9);
      if ( !memcmp(v6, v9, v10) )
      {
        v13 = sub_12708(a1);
        v8 = sub_193DC(v13, *v11);
        goto LABEL_8;
      }
    }
  }
  else
  {
    v8 = 0;
  }
  v13 = 0;
LABEL_8:
  free(v4);
  free(v6);
  if ( v13 )
    j_free(v13);
  return v8;
}
// 4C3F4: using guessed type _UNKNOWN *off_4C3F4;

//----- (000199A4) --------------------------------------------------------
int *__fastcall sub_199A4(_DWORD *a1, size_t a2, size_t a3)
{
  char *v4; // r0
  int *v5; // r4
  int v6; // r1
  int v7; // r2
  int *v8; // r0

  v4 = sub_198C8(a1, a2, a3);
  v5 = (int *)v4;
  if ( v4 && sub_12910(a1, *((_DWORD *)v4 + 6)) )
  {
    sub_277B4(v5, v6, v7);
    v8 = v5;
    v5 = 0;
    free(v8);
  }
  return v5;
}
// 199D0: variable 'v6' is possibly undefined
// 199D0: variable 'v7' is possibly undefined

//----- (000199E8) --------------------------------------------------------
_DWORD *__fastcall sub_199E8(_DWORD *a1, int a2)
{
  int v4; // r6
  size_t v5; // r0
  const char *v6; // r6
  size_t v7; // r0
  char v9[32]; // [sp+0h] [bp-20h] BYREF

  v4 = sub_192EC(*(_DWORD *)(a2 + 8));
  snprintf(v9, 0x1Eu, "ecdsa-sha2-%s", *(const char **)(v4 + 12));
  v5 = strlen(v9);
  sub_127F8(a1, v9, v5);
  v6 = *(const char **)(v4 + 12);
  v7 = strlen(v6);
  sub_127F8(a1, v6, v7);
  return sub_19370(a1, a2);
}

//----- (00019A64) --------------------------------------------------------
_DWORD *__fastcall sub_19A64(_DWORD *a1, int a2)
{
  sub_199E8(a1, a2);
  return sub_1282C(a1, *(_DWORD *)(a2 + 24));
}

//----- (00019A84) --------------------------------------------------------
void __fastcall sub_19A84(_DWORD *a1, int a2, _DWORD *a3)
{
  int v6; // r0
  int v7; // r5
  _DWORD *v8; // r4
  int v9; // r6
  int v10; // r1
  int v11; // r2
  int v12; // r1
  int v13; // r2
  size_t v14; // r0
  int v15; // [sp+8h] [bp-144h] BYREF
  int v16; // [sp+Ch] [bp-140h] BYREF
  int v17; // [sp+10h] [bp-13Ch] BYREF
  int v18; // [sp+14h] [bp-138h] BYREF
  int s[3]; // [sp+18h] [bp-134h] BYREF
  int v20; // [sp+24h] [bp-128h]
  int v21; // [sp+30h] [bp-11Ch]
  _BYTE v22[64]; // [sp+38h] [bp-114h] BYREF
  _BYTE v23[212]; // [sp+78h] [bp-D4h] BYREF

  v6 = *(_DWORD *)(a2 + 8);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v7 = sub_192EC(v6);
  if ( !sub_26A28((int)&v18, &v17, &v16, &v15, 0) )
  {
    (*(void (__fastcall **)(_BYTE *))(*(_DWORD *)(v7 + 8) + 84))(v23);
    (*(void (__fastcall **)(_BYTE *, _DWORD, _DWORD))(*(_DWORD *)(v7 + 8) + 88))(v23, *a3, a3[1]);
    (*(void (__fastcall **)(_BYTE *, _BYTE *))(*(_DWORD *)(v7 + 8) + 92))(v23, v22);
    if ( !off_4C6D4(v15, v22, *(_DWORD *)(*(_DWORD *)(v7 + 8) + 8))
      && !off_4C6C4(v16, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 16), 16) )
    {
      while ( !sub_277F4(0, dword_4C3E4, s, *(int **)(a2 + 8)) && !off_4C6F4(v20, v16, 0) )
      {
        if ( off_4C6B4(v18) )
        {
          if ( off_4C710(v21, v16) )
            break;
          if ( off_4C708(*(_DWORD *)(a2 + 24), v18, v16, v17) )
            break;
          if ( off_4C6D8(v15, v17) )
            break;
          if ( off_4C6F4(v17, v16, 0) )
            break;
          v9 = off_4C708(v17, v21, v16, v17);
          if ( v9 )
            break;
          sub_277B4(s, v12, v13);
          if ( off_4C6B4(v17) )
          {
            snprintf((char *)s, 0x1Eu, "ecdsa-sha2-%s", *(const char **)(v7 + 12));
            v14 = strlen((const char *)s);
            sub_127F8(a1, s, v14);
            v8 = sub_12344(0xC8u);
            sub_1282C(v8, v18);
            sub_1282C(v8, v17);
            sub_12824(a1, (int)v8);
            goto LABEL_3;
          }
        }
        else
        {
          sub_277B4(s, v10, v11);
        }
      }
    }
  }
  v8 = 0;
  v9 = -1;
LABEL_3:
  if ( v18 && v17 && v16 && v15 )
    sub_26ABC(v18);
  if ( v8 )
    j_free(v8);
  if ( v9 == -1 )
    sub_184AC("ECC error");
}
// 19C08: variable 'v10' is possibly undefined
// 19C08: variable 'v11' is possibly undefined
// 19CA0: variable 'v12' is possibly undefined
// 19CA0: variable 'v13' is possibly undefined
// 4C3E4: using guessed type int dword_4C3E4;
// 4C6B4: using guessed type int (__fastcall *off_4C6B4)(_DWORD);
// 4C6C4: using guessed type int (__fastcall *off_4C6C4)(_DWORD, _DWORD, _DWORD);
// 4C6D4: using guessed type int (__fastcall *off_4C6D4)(_DWORD, _DWORD, _DWORD);
// 4C6D8: using guessed type int (__fastcall *off_4C6D8)(_DWORD, _DWORD);
// 4C6F4: using guessed type int (__fastcall *off_4C6F4)(_DWORD, _DWORD, _DWORD);
// 4C708: using guessed type int (__fastcall *off_4C708)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C710: using guessed type int (__fastcall *off_4C710)(_DWORD, _DWORD);

//----- (00019D30) --------------------------------------------------------
int __fastcall sub_19D30(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int v6; // r0
  int v7; // r9
  int *v8; // r5
  int *v9; // r6
  bool v10; // zf
  unsigned int v11; // r4
  int v12; // r11
  int v13; // r4
  int v15; // r0
  int v16; // [sp+18h] [bp-144h]
  int v17; // [sp+1Ch] [bp-140h]
  int v18; // [sp+20h] [bp-13Ch] BYREF
  int v19; // [sp+24h] [bp-138h] BYREF
  int v20; // [sp+28h] [bp-134h] BYREF
  int v21; // [sp+2Ch] [bp-130h] BYREF
  int v22; // [sp+30h] [bp-12Ch] BYREF
  int v23; // [sp+34h] [bp-128h] BYREF
  int v24; // [sp+38h] [bp-124h] BYREF
  int v25; // [sp+3Ch] [bp-120h] BYREF
  int v26; // [sp+40h] [bp-11Ch] BYREF
  int v27; // [sp+44h] [bp-118h] BYREF
  _BYTE v28[64]; // [sp+48h] [bp-114h] BYREF
  _BYTE v29[212]; // [sp+88h] [bp-D4h] BYREF

  v6 = a2[2];
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v7 = sub_192EC(v6);
  v8 = (int *)sub_28738();
  v9 = (int *)sub_28738();
  if ( sub_26A28((int)&v18, &v19, &v20, &v21, &v22, &v23, &v25, &v24, &v26, 0) )
    goto LABEL_6;
  v10 = v9 == 0;
  if ( v9 )
    v10 = v8 == 0;
  if ( v10 )
LABEL_6:
    sub_184AC("ECC error");
  v16 = v19;
  v17 = v18;
  v11 = sub_12664(a1);
  v12 = a1[2];
  if ( sub_12910(a1, v17) )
    goto LABEL_8;
  if ( sub_12910(a1, v16) )
    goto LABEL_8;
  if ( v11 != a1[2] - v12 )
    goto LABEL_8;
  (*(void (__fastcall **)(_BYTE *))(*(_DWORD *)(v7 + 8) + 84))(v29);
  (*(void (__fastcall **)(_BYTE *, _DWORD, _DWORD))(*(_DWORD *)(v7 + 8) + 88))(v29, *a3, a3[1]);
  (*(void (__fastcall **)(_BYTE *, _BYTE *))(*(_DWORD *)(v7 + 8) + 92))(v29, v28);
  if ( off_4C6D4(v24, v28, *(_DWORD *)(*(_DWORD *)(v7 + 8) + 8))
    || off_4C6C4(v25, *(_DWORD *)(a2[2] + 16), 16)
    || off_4C6C4(v26, *(_DWORD *)(a2[2] + 8), 16)
    || !off_4C6B4(v18)
    || !off_4C6B4(v19)
    || off_4C6B0(v18, v25) != -1
    || off_4C6B0(v19, v25) != -1
    || off_4C710(v19, v25)
    || off_4C708(v24, v21, v25, v22)
    || off_4C708(v18, v21, v25, v23)
    || off_4C6C4(*v8, *(_DWORD *)(a2[2] + 20), 16)
    || off_4C6C4(v8[1], *(_DWORD *)(a2[2] + 24), 16)
    || off_4C6A0(v8[2], 1)
    || off_4C69C(a2[3], *v9)
    || off_4C69C(a2[4], v9[1])
    || off_4C69C(a2[5], v9[2]) )
  {
    goto LABEL_8;
  }
  if ( off_4C73C )
  {
    v15 = ((int (__fastcall *)(int *, int, int *, int, int *, int))off_4C73C)(v8, v22, v9, v23, v8, v26);
  }
  else
  {
    if ( off_4C72C(v22, v8, v8, v26, 0)
      || off_4C72C(v23, v9, v9, v26, 0)
      || off_4C714(v26, &v27)
      || off_4C730(v9, v8, v8, v26, v27) )
    {
      goto LABEL_8;
    }
    v15 = off_4C738(v8, v26, v27);
  }
  if ( v15 || off_4C6F4(*v8, v25, 0) )
  {
LABEL_8:
    v13 = -1;
    goto LABEL_9;
  }
  v13 = -(off_4C6B0(v20, v18) != 0);
LABEL_9:
  sub_2877C(v8);
  sub_2877C(v9);
  sub_26ABC(v18, v19, v20, v21, v22, v23, v25, v24, v26, 0);
  if ( v27 )
    off_4C720();
  return v13;
}
// 4C69C: using guessed type int (__fastcall *off_4C69C)(_DWORD, _DWORD);
// 4C6A0: using guessed type int (__fastcall *off_4C6A0)(_DWORD, _DWORD);
// 4C6B0: using guessed type int (__fastcall *off_4C6B0)(_DWORD, _DWORD);
// 4C6B4: using guessed type int (__fastcall *off_4C6B4)(_DWORD);
// 4C6C4: using guessed type int (__fastcall *off_4C6C4)(_DWORD, _DWORD, _DWORD);
// 4C6D4: using guessed type int (__fastcall *off_4C6D4)(_DWORD, _DWORD, _DWORD);
// 4C6F4: using guessed type int (__fastcall *off_4C6F4)(_DWORD, _DWORD, _DWORD);
// 4C708: using guessed type int (__fastcall *off_4C708)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C710: using guessed type int (__fastcall *off_4C710)(_DWORD, _DWORD);
// 4C714: using guessed type int (__fastcall *off_4C714)(_DWORD, _DWORD);
// 4C720: using guessed type int (*off_4C720)(void);
// 4C72C: using guessed type int (__fastcall *off_4C72C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C730: using guessed type int (__fastcall *off_4C730)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C738: using guessed type int (__fastcall *off_4C738)(_DWORD, _DWORD, _DWORD);
// 4C73C: using guessed type _UNKNOWN *off_4C73C;

//----- (0001A1C8) --------------------------------------------------------
void __fastcall sub_1A1C8(int *a1, int *a2, int *a3, size_t a4)
{
  char *v8; // r4
  int v9[5]; // [sp+0h] [bp-14h] BYREF

  memset(v9, 0, 0x10u);
  v8 = (char *)sub_18718(a4);
  sub_121B0((int)v9);
  do
  {
    sub_18090(v8, a4);
    *v8 |= 0x80u;
    sub_122E8((int)a1, (unsigned __int8 *)v8, a4);
    if ( sub_2D44C((int)a1, 8, 0) || sub_2E7D4(a1, 1u, a2) || sub_2B818(a2, a3, v9) )
    {
      fputs("RSA generation failed\n", (FILE *)stderr);
      exit(1);
    }
  }
  while ( sub_29E48((int)v9, 1u) );
  sub_29D74((int)v9);
  j_explicit_bzero(v8, a4);
  free(v8);
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4C448: using guessed type int stderr;

//----- (0001A2D0) --------------------------------------------------------
int **__fastcall sub_1A2D0(unsigned int a1)
{
  int **v2; // r4
  int v3; // r3
  int s[4]; // [sp+8h] [bp-30h] BYREF
  int v6[4]; // [sp+18h] [bp-20h] BYREF
  int v7[4]; // [sp+28h] [bp-10h] BYREF

  memset(s, 0, sizeof(s));
  memset(v6, 0, sizeof(v6));
  memset(v7, 0, sizeof(v7));
  if ( a1 - 512 > 0xE00 || (a1 & 7) != 0 )
    sub_184AC("Bits must satisfy 512 <= bits <= 4096, and be a multiple of 8");
  v2 = (int **)sub_18718(0x14u);
  sub_12224((int)(v2 + 1), v2, v2 + 2, v2 + 3, v2 + 4, a1 & 7);
  sub_121CC((int)s, v7, v6, a1 & 7);
  if ( sub_2E65C(v2[1], 0x10001u) )
    goto LABEL_5;
  do
  {
    sub_1A1C8(v2[3], s, v2[1], a1 >> 4);
    sub_1A1C8(v2[4], v6, v2[1], a1 >> 4);
    if ( sub_2CB6C(v2[3], v2[4], *v2) )
      goto LABEL_5;
  }
  while ( sub_2A310(*v2) != a1 );
  if ( sub_2C074(s, v6, v7, v3) || sub_2BBA8(v2[1], (int)v7, v2[2]) )
  {
LABEL_5:
    fputs("RSA generation failed\n", (FILE *)stderr);
    exit(1);
  }
  sub_29DB8((int)s, v6, v7);
  return v2;
}
// 1A3F0: variable 'v3' is possibly undefined
// 4C448: using guessed type int stderr;

//----- (0001A440) --------------------------------------------------------
int __fastcall sub_1A440(unsigned int a1, int a2)
{
  bool v2; // zf

  if ( !a2 )
  {
    if ( a1 == 2 )
    {
      return 384;
    }
    else
    {
      if ( a1 > 2 )
      {
        if ( a1 == 3 )
          return 521;
        v2 = a1 == 70;
      }
      else
      {
        if ( !a1 )
          return 2048;
        v2 = a1 == 1;
      }
      if ( v2 )
        return 256;
    }
  }
  return a2;
}

//----- (0001A488) --------------------------------------------------------
int __fastcall sub_1A488(unsigned int a1, int a2, const char *a3, int a4)
{
  unsigned int v4; // r5
  int v7; // r4
  _DWORD *v8; // r6
  _DWORD *v9; // r4
  _DWORD *v10; // r4
  size_t v11; // r0
  char *v12; // r6
  size_t v13; // r5
  __pid_t v14; // r0
  int v15; // r8
  int *v16; // r0
  int v17; // r5
  char *v18; // r0
  const void *v20; // r0
  ssize_t v21; // r0
  int v22; // r1
  int v23; // r3
  int *v24; // r0
  char *v25; // r0
  int *v26; // r0
  char *v27; // r0
  int v28; // r0
  char *v29; // r0

  v4 = a1;
  v7 = sub_1A440(a1, a2);
  v8 = sub_1E644();
  sub_18158();
  if ( v4 > 3 )
  {
    if ( v4 != 70 )
      sub_184AC("Internal error");
    goto LABEL_3;
  }
  if ( v4 )
  {
LABEL_3:
    v9 = sub_1982C(v7);
    v4 = sub_197D4((int)v9);
    *(_DWORD *)sub_1E708((int)v8, v4) = v9;
    goto LABEL_7;
  }
  v8[3] = sub_1A2D0(v7);
LABEL_7:
  sub_18158();
  v10 = sub_12344(0x6A4u);
  sub_1E9F8(v10, (int)v8, v4);
  sub_1EA60((int)v8);
  sub_124A0((int)v10, 0);
  v11 = strlen(a3);
  v12 = (char *)sub_18718(v11 + 30);
  v13 = strlen(a3);
  v14 = getpid();
  snprintf(v12, v13 + 30, "%s.tmp%d", a3, v14);
  v15 = open64(v12, 194);
  if ( v15 >= 0 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v22 = v10[1];
        v23 = v10[2];
        if ( v22 == v23 )
        {
          v17 = 0;
          goto LABEL_16;
        }
        v20 = (const void *)sub_125E4(v10, v22 - v23);
        v21 = write(v15, v20, v10[1] - v10[2]);
        if ( v21 != -1 )
          break;
        if ( *_errno_location() != 4 )
          goto LABEL_15;
      }
      if ( v21 <= 0 )
        break;
      sub_1250C((int)v10, v21);
    }
LABEL_15:
    v24 = _errno_location();
    v17 = -1;
    v25 = strerror(*v24);
    sub_184E8(3, "Failed writing file %s: %s", v12, v25);
LABEL_16:
    if ( fsync(v15) )
    {
      v26 = _errno_location();
      v27 = strerror(*v26);
      sub_184E8(3, "fsync of %s failed: %s", v12, v27);
    }
    sub_185B8(v15);
    if ( v17 != -1 )
    {
      if ( link(v12, a3) >= 0 || (v28 = *_errno_location(), a4) && v28 == 17 )
      {
        v17 = 0;
      }
      else
      {
        v17 = -1;
        v29 = strerror(v28);
        sub_184E8(3, "Failed moving key file to %s: %s", a3, v29);
      }
    }
    goto LABEL_23;
  }
  v16 = _errno_location();
  v17 = -1;
  v18 = strerror(*v16);
  sub_184E8(3, "Couldn't create new file %s: %s", v12, v18);
  if ( v10 )
  {
LABEL_23:
    sub_1238C(v10);
    j_free(v10);
  }
  unlink(v12);
  free(v12);
  return v17;
}
// 11B98: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (0001A710) --------------------------------------------------------
int __fastcall sub_1A710(_BYTE *a1, char a2, int a3, char a4)
{
  int i; // r3
  int v6; // r1

  if ( a1 )
  {
    *a1 = a2 | a4;
    if ( a3 <= 127 )
    {
      if ( a1 != (_BYTE *)-1 )
        a1[1] = a3;
      return 2;
    }
    ++a1;
  }
  else if ( a3 <= 127 )
  {
    return 2;
  }
  for ( i = 1; a3 >> (8 * i) > 0; ++i )
    ;
  if ( a1 )
    *a1++ = ~((unsigned int)~(i << 25) >> 25);
  v6 = i;
  while ( v6-- != 0 )
  {
    if ( a1 )
      *a1++ = a3 >> (8 * v6);
  }
  return i + 2;
}

//----- (0001A7A8) --------------------------------------------------------
void *__fastcall sub_1A7A8(const char *a1)
{
  _DWORD *v2; // r0
  _BYTE *v3; // r9
  void *v4; // r4
  FILE *v5; // r7
  size_t v6; // r0
  int v7; // r5
  int v8; // r3
  size_t v9; // r0
  char *v10; // r0
  const char *v11; // r8
  const char *v12; // r6
  int v13; // r11
  int v14; // t1
  const char *v15; // r5
  unsigned __int8 *v16; // r8
  _BYTE *v17; // r11
  unsigned __int8 *v18; // r6
  int v19; // r0
  size_t v20; // r5
  int v21; // r3
  size_t v22; // r1
  void *v23; // r0
  int v24; // r2
  int v25; // r3
  unsigned int v27; // [sp+0h] [bp-10Ch] BYREF
  int v28; // [sp+4h] [bp-108h] BYREF
  char s[256]; // [sp+8h] [bp-104h] BYREF

  v2 = sub_18718(0x34u);
  v3 = v2 + 2;
  v2[10] = 0;
  v2[12] = 0;
  v4 = v2;
  v2[11] = 0;
  v2[1] = 0;
  memset(v2 + 2, 0, 0x20u);
  if ( strlen(a1) == 1 && *a1 == 45 )
    v5 = (FILE *)stdin;
  else
    v5 = (FILE *)fopen64(a1, "r");
  if ( v5 )
  {
    if ( fgets(s, 256, v5)
      && !strncmp(s, "-----BEGIN ", 0xBu)
      && (v6 = strlen(s), (v7 = strcmp(&s[v6 - 17], "PRIVATE KEY-----\n")) == 0) )
    {
      if ( !strcmp(s, "-----BEGIN RSA PRIVATE KEY-----\n") )
      {
        v8 = 1;
LABEL_11:
        *(_DWORD *)v4 = v8;
        goto LABEL_12;
      }
      if ( !strcmp(s, "-----BEGIN DSA PRIVATE KEY-----\n") )
      {
        *(_DWORD *)v4 = 0;
        while ( 1 )
        {
LABEL_12:
          if ( !fgets(s, 256, v5) )
          {
            v15 = "Unexpected end of file";
            goto LABEL_38;
          }
          if ( !strncmp(s, "-----END ", 9u) )
          {
            v9 = strlen(s);
            if ( !strcmp(&s[v9 - 17], "PRIVATE KEY-----\n") )
              break;
          }
          v10 = strchr(s, 58);
          if ( v10 )
          {
            if ( v7 )
            {
              v15 = "Header found in body of key data";
              goto LABEL_38;
            }
            *v10 = 0;
            v11 = v10 + 1;
            do
            {
              v12 = v11;
              v14 = *(unsigned __int8 *)v11++;
              v13 = v14;
            }
            while ( v14 && ((*_ctype_b_loc())[v13] & 0x2000) != 0 );
            if ( !strcmp(s, "Proc-Type") )
            {
              if ( v13 != 52 || v12[1] != 44 )
              {
                v15 = "Proc-Type is not 4 (only 4 is supported)";
                goto LABEL_38;
              }
              v7 = strcmp(v12 + 2, "ENCRYPTED\n");
              if ( v7 )
                v7 = 0;
              else
                *((_DWORD *)v4 + 1) = 1;
            }
            else if ( !strcmp(s, "DEK-Info") )
            {
              v7 = strncmp(v12, "DES-EDE3-CBC,", 0xDu);
              if ( v7 )
              {
                v15 = "Ciphers other than DES-EDE3-CBC not supported";
              }
              else
              {
                v16 = (unsigned __int8 *)(v12 + 13);
                v17 = v3;
                v18 = (unsigned __int8 *)(v12 + 29);
                while ( _isoc99_sscanf(v16, "%2x", &v28) == 1 )
                {
                  v16 += 2;
                  *v17++ = v28;
                  if ( v18 == v16 )
                    goto LABEL_12;
                }
                v15 = "Expected 16-digit iv in DEK-Info";
              }
              goto LABEL_38;
            }
          }
          else
          {
            v20 = strlen(s);
            v21 = *((_DWORD *)v4 + 11);
            v27 = 4 * v20 / 3;
            if ( v27 + v21 > *((_DWORD *)v4 + 12) )
            {
              v22 = v27 + v21 + 256;
              v23 = (void *)*((_DWORD *)v4 + 10);
              *((_DWORD *)v4 + 12) = v22;
              *((_DWORD *)v4 + 10) = sub_18888(v23, v22);
            }
            v24 = *((_DWORD *)v4 + 11);
            v27 = *((_DWORD *)v4 + 12) - v24;
            if ( sub_26CFC((unsigned __int8 *)s, v20, *((_DWORD *)v4 + 10) + v24, &v27) )
            {
              v15 = "Error decoding base64";
              goto LABEL_38;
            }
            v7 = 1;
            *((_DWORD *)v4 + 11) += v27;
          }
        }
        v25 = *((_DWORD *)v4 + 11);
        if ( v25 && *((_DWORD *)v4 + 10) )
        {
          if ( !*((_DWORD *)v4 + 1) || (v25 & 7) == 0 )
          {
            j_explicit_bzero(s, 256);
            return v4;
          }
          v15 = "Encrypted key blob is not a multiple of cipher block size";
        }
        else
        {
          v15 = "Key body not present";
        }
      }
      else
      {
        if ( !strcmp(s, "-----BEGIN EC PRIVATE KEY-----\n") )
        {
          v8 = 2;
          goto LABEL_11;
        }
        v15 = "Unrecognised key type";
      }
    }
    else
    {
      v15 = "File does not begin with OpenSSH key header";
    }
  }
  else
  {
    v15 = "Unable to open key file";
  }
LABEL_38:
  j_explicit_bzero(s, 256);
  v19 = *((_DWORD *)v4 + 10);
  if ( v19 )
  {
    j_explicit_bzero(v19, *((_DWORD *)v4 + 12));
    free(*((void **)v4 + 10));
  }
  free(v4);
  if ( v5 )
    fclose(v5);
  v4 = 0;
  fprintf((FILE *)stderr, "Error: %s\n", v15);
  return v4;
}
// 11D0C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 11EA4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4C448: using guessed type int stderr;
// 4C450: using guessed type int stdin;

//----- (0001AC04) --------------------------------------------------------
int __fastcall sub_1AC04(_BYTE *a1, int a2, int *a3, int *a4, int *a5)
{
  int v6; // lr
  _BYTE *i; // r12
  int v8; // t1
  _BYTE *v9; // r2
  int v10; // lr
  int v11; // lr
  unsigned __int8 *v12; // r4
  unsigned __int8 *v13; // r12
  int v14; // r1
  int v15; // t1

  if ( !a2 )
    return -1;
  *a5 = *a1 & 0xE0;
  v6 = *a1 & 0x1F;
  if ( v6 == 31 )
  {
    *a3 = 0;
    for ( i = a1; ; *a3 = *i & 0x7F | (*a3 << 7) )
    {
      v8 = (char)*i++;
      --a2;
      if ( v8 >= 0 )
        break;
      if ( !a2 )
        return -1;
    }
  }
  else
  {
    i = a1 + 1;
    --a2;
    *a3 = v6;
  }
  if ( !a2 )
    return -1;
  v9 = i + 1;
  v10 = (unsigned __int8)*i;
  if ( (v10 & 0x80) != 0 )
  {
    v11 = v10 & 0x7F;
    if ( v11 > a2 - 1 )
      return -1;
    v12 = i + 1;
    v13 = &i[v11 + 1];
    v14 = 0;
    while ( v12 != v13 )
    {
      v15 = *v12++;
      v14 = v15 | (v14 << 8);
    }
    v9 += v11;
    *a4 = v14;
  }
  else
  {
    *a4 = v10;
  }
  if ( *a4 < 0 )
  {
    puts("Negative ASN.1 length");
    return -1;
  }
  return v9 - a1;
}

//----- (0001AD00) --------------------------------------------------------
void *__fastcall sub_1AD00(const char *a1, int a2)
{
  void *v2; // r5
  void **v4; // r0
  void **v5; // r4

  if ( a2 != 1 )
    return 0;
  v4 = (void **)sub_1A7A8(a1);
  v5 = v4;
  if ( !v4 )
    return 0;
  v2 = v4[1];
  j_explicit_bzero(v4[10], v4[12]);
  free(v5[10]);
  free(v5);
  return v2;
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);

//----- (0001AD48) --------------------------------------------------------
int *__fastcall sub_1AD48(const char *a1, int a2, int *a3)
{
  int *v4; // r4
  int *v5; // r0
  int *v6; // r5
  int v7; // r6
  const char *v8; // r6
  _BYTE *v9; // r7
  int v10; // r0
  unsigned __int8 *v11; // r7
  int v12; // r9
  int v13; // r9
  bool v14; // zf
  _DWORD *v15; // r0
  _DWORD *v16; // r8
  size_t v17; // r10
  unsigned __int8 *v18; // r11
  int v19; // r0
  unsigned __int8 *v20; // r7
  size_t v22; // r2
  int v23; // r3
  int v24; // r3
  unsigned __int8 *v25; // r1
  int v26; // r0
  size_t v27; // r9
  unsigned __int8 *v28; // r7
  int v29; // r1
  int v30; // r0
  unsigned __int8 *v31; // r6
  int v32; // r0
  unsigned __int8 *v33; // r10
  size_t v34; // r6
  void *v35; // r11
  char *v36; // r6
  int v37; // r0
  char *v38; // r6
  int v39; // r0
  char *v40; // r6
  char *v41; // r0
  char *v42; // r6
  _DWORD *v43; // r5
  int v44; // [sp+Ch] [bp-18h]
  int v45; // [sp+10h] [bp-14h] BYREF
  size_t n; // [sp+14h] [bp-10h] BYREF
  int v47; // [sp+18h] [bp-Ch] BYREF
  int v48; // [sp+1Ch] [bp-8h] BYREF

  if ( a3 != (int *)1 )
  {
    v4 = a3;
    if ( a3 )
      return 0;
    v43 = sub_12344(0x6A4u);
    if ( sub_1867C(v43, (int)a1) == -1 )
    {
      if ( !v43 )
        return 0;
    }
    else
    {
      sub_124A0((int)v43, 0);
      v4 = sub_1E644();
      v48 = 80;
      if ( sub_1E858(v43, (int)v4, &v48) != -1 )
      {
        j_free(v43);
        *v4 = v48;
        return v4;
      }
      if ( !v43 )
        goto LABEL_94;
    }
    j_free(v43);
LABEL_94:
    if ( v4 )
      sub_1EA60((int)v4);
    return 0;
  }
  v4 = sub_1E644();
  v5 = (int *)sub_1A7A8(a1);
  v6 = v5;
  if ( !v5 )
    return 0;
  v7 = v5[1];
  if ( v7 )
  {
    v4 = 0;
    v8 = "encrypted keys not supported currently";
    goto LABEL_24;
  }
  v9 = (_BYTE *)v5[10];
  v10 = sub_1AC04(v9, v5[11], &v45, (int *)&n, &v47);
  if ( v10 < 0 || v45 != 16 || (n & 0x80000000) != 0 || (v11 = &v9[v10], (int)n > v6[10] + v6[11] - (int)v11) )
  {
    v4 = 0;
    v8 = "ASN.1 decoding failure";
    goto LABEL_24;
  }
  v12 = *v6;
  if ( *v6 == 1 )
  {
    v13 = 9;
  }
  else
  {
    v14 = v12 == 0;
    if ( v12 )
      v13 = v12 - 2;
    else
      v13 = 6;
    if ( !v14 )
      v13 = v13 == 0;
  }
  v15 = sub_12344(0xBB8u);
  v16 = v15;
  if ( *v6 == 1 )
  {
    sub_127F8(v15, "ssh-rsa", 7u);
    *v4 = 0;
  }
  v17 = -9999;
  v18 = 0;
  while ( v7 != v13 )
  {
    v19 = sub_1AC04(v11, v6[10] + v6[11] - (_DWORD)v11, &v45, (int *)&n, &v47);
    v20 = &v11[v19];
    if ( v19 < 0 )
      goto LABEL_20;
    if ( v45 != 2 )
      goto LABEL_20;
    v22 = n;
    if ( (n & 0x80000000) != 0 || (int)n > v6[10] + v6[11] - (int)v20 )
      goto LABEL_20;
    v23 = *v6;
    if ( !v7 )
    {
      if ( v23 >= 0 )
      {
        if ( v23 <= 1 )
        {
          v24 = 0;
LABEL_37:
          if ( n != 1 || *v20 != v24 )
          {
            v8 = "Version number mismatch";
            goto LABEL_21;
          }
          goto LABEL_46;
        }
        if ( v23 == 2 )
        {
          v24 = 1;
          goto LABEL_37;
        }
      }
      v24 = -1;
      goto LABEL_37;
    }
    if ( v23 != 1 )
    {
      if ( v23 )
        goto LABEL_46;
      v25 = v20;
      goto LABEL_74;
    }
    if ( v7 == 1 )
    {
      v17 = n;
      v18 = v20;
      goto LABEL_46;
    }
    if ( (unsigned int)(v7 - 2) <= 3 )
    {
      sub_127F8(v16, v20, n);
      if ( v7 == 2 )
      {
        v22 = v17;
        v25 = v18;
LABEL_74:
        sub_127F8(v16, v25, v22);
      }
    }
LABEL_46:
    ++v7;
    v11 = &v20[n];
  }
  if ( *v6 != 2 )
    goto LABEL_82;
  v26 = sub_1AC04(v11, v6[10] + v6[11] - (_DWORD)v11, &v45, (int *)&n, &v47);
  if ( v26 < 0 )
    goto LABEL_20;
  if ( v45 != 4 )
    goto LABEL_20;
  v27 = n;
  if ( (n & 0x80000000) != 0 )
    goto LABEL_20;
  v28 = &v11[v26];
  v29 = v6[10] + v6[11];
  if ( (int)n > v29 - (int)v28
    || (v30 = sub_1AC04(&v28[n], v29 - (_DWORD)&v28[n], &v45, (int *)&n, &v47), v31 = &v28[v27 + v30], v30 < 0)
    || v45
    || (n & 0x80000000) != 0
    || (v32 = sub_1AC04(&v28[v27 + v30], v6[10] + v6[11] - (_DWORD)v31, &v45, (int *)&n, &v47), v33 = &v31[v32], v32 < 0)
    || v45 != 6
    || (v34 = n, (n & 0x80000000) != 0)
    || (v44 = v6[11] + v6[10], (int)n > v44 - (int)v33) )
  {
LABEL_20:
    v8 = "ASN.1 decoding failure";
LABEL_21:
    v4 = 0;
    goto LABEL_22;
  }
  if ( n != 8 )
  {
    if ( n == 5 )
    {
      if ( !memcmp(v33, &unk_363D0, 5u) )
      {
        v35 = &unk_4C414;
        *v4 = 2;
        goto LABEL_63;
      }
      if ( !memcmp(v33, &unk_363D5, 5u) )
      {
        v35 = &unk_4C404;
        *v4 = 3;
        goto LABEL_63;
      }
    }
LABEL_86:
    v8 = "Unknown ECC key type";
    goto LABEL_21;
  }
  if ( memcmp(v33, &unk_363C8, 8u) )
    goto LABEL_86;
  v35 = &unk_4C424;
  *v4 = 1;
LABEL_63:
  v36 = (char *)&v33[v34];
  v37 = sub_1AC04(v36, v44 - (_DWORD)v36, &v45, (int *)&n, &v47);
  v38 = &v36[v37];
  if ( v37 < 0 )
    goto LABEL_20;
  if ( v45 != 1 )
    goto LABEL_20;
  if ( (n & 0x80000000) != 0 )
    goto LABEL_20;
  v39 = sub_1AC04(v38, v6[10] + v6[11] - (_DWORD)v38, &v45, (int *)&n, &v47);
  v40 = &v38[v39];
  if ( v39 < 0 || v45 != 3 || (n & 0x80000000) != 0 || (int)n > v6[10] + v6[11] - (int)v40 )
    goto LABEL_20;
  sub_127C4(v16, v40 + 1, n - 1);
  v41 = sub_193DC(v16, (int)v35);
  v42 = v41;
  if ( !v41 || (sub_12224((int)(v41 + 24), 0), sub_2DE30(*((_DWORD *)v42 + 6), v28, v27)) )
  {
    v8 = "Error parsing ECC key";
    goto LABEL_21;
  }
  *(_DWORD *)sub_1E708((int)v4, *v4) = v42;
LABEL_82:
  if ( (unsigned int)*v6 <= 1 )
  {
    sub_124A0((int)v16, 0);
    v48 = 80;
    v8 = (const char *)sub_1E858(v16, (int)v4, &v48);
    if ( v8 )
    {
      v8 = "unable to create key structure";
      sub_1EA60((int)v4);
      goto LABEL_21;
    }
  }
  else
  {
    v8 = 0;
  }
LABEL_22:
  if ( v16 )
  {
    sub_1238C(v16);
    j_free(v16);
  }
LABEL_24:
  j_explicit_bzero(v6[10], v6[12]);
  free((void *)v6[10]);
  v6[10] = 0;
  j_explicit_bzero(v6, 52);
  free(v6);
  if ( v8 )
    fprintf((FILE *)stderr, "Error: %s\n", v8);
  return v4;
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4C448: using guessed type int stderr;

//----- (0001B3B8) --------------------------------------------------------
unsigned int __fastcall sub_1B3B8(const char *a1, int *a2, signed int a3, unsigned int a4)
{
  signed int v4; // r11
  unsigned int v6; // r5
  const char *v7; // r7
  _DWORD *v8; // r4
  unsigned int v9; // r0
  int v10; // r3
  int v11; // r3
  const char *v12; // r0
  FILE *v13; // r1
  _DWORD *v14; // r6
  unsigned int v15; // r6
  unsigned int v16; // r6
  unsigned int v17; // r6
  unsigned int v18; // r6
  unsigned int v19; // r6
  int v20; // r9
  unsigned int v21; // r7
  unsigned int v22; // r7
  unsigned int v23; // r7
  int v24; // r0
  int v25; // r1
  int v26; // r7
  _DWORD *v27; // r3
  int v28; // r10
  signed int v29; // r3
  unsigned __int8 *v30; // r10
  int v31; // r0
  int v32; // r3
  int v33; // r9
  const void **v34; // r7
  int v35; // r9
  int v36; // r11
  _BYTE *v37; // r0
  unsigned int v38; // r0
  int v39; // r10
  int v40; // r2
  const char *v41; // r0
  int v42; // r9
  _BYTE *v43; // r0
  unsigned int v44; // r0
  int *v45; // r11
  _BYTE *v46; // r0
  int v47; // r3
  const void *v48; // r10
  unsigned int v49; // r8
  _BYTE *v50; // r0
  unsigned int v51; // r0
  _BYTE *v52; // r0
  unsigned int v53; // r0
  _BYTE *v54; // r0
  unsigned int v55; // r0
  _BYTE *v56; // r0
  unsigned int v57; // r0
  int v58; // r9
  _BYTE *v59; // r0
  int v60; // r11
  const void **v61; // r0
  const char *v62; // r0
  FILE *v63; // r1
  void *v64; // r0
  unsigned __int8 *v66; // r3
  unsigned __int8 v67; // r9
  FILE *v68; // r8
  unsigned __int8 *v69; // r9
  unsigned int v70; // r3
  _DWORD *v71; // r4
  FILE *v72; // r6
  const void *v73; // r0
  signed int v74; // r5
  int v75; // [sp+4h] [bp-118h]
  unsigned int v76; // [sp+4h] [bp-118h]
  signed int v77; // [sp+8h] [bp-114h]
  char *v78; // [sp+Ch] [bp-110h]
  size_t n; // [sp+14h] [bp-108h]
  int v81; // [sp+18h] [bp-104h]
  char v83; // [sp+24h] [bp-F8h] BYREF
  size_t v84; // [sp+28h] [bp-F4h] BYREF
  int v85[4]; // [sp+2Ch] [bp-F0h] BYREF
  int v86[4]; // [sp+3Ch] [bp-E0h] BYREF
  int v87[4]; // [sp+4Ch] [bp-D0h] BYREF
  int v88[4]; // [sp+5Ch] [bp-C0h] BYREF
  _DWORD v89[18]; // [sp+6Ch] [bp-B0h] BYREF
  unsigned int ptr[25]; // [sp+B4h] [bp-68h] BYREF

  v6 = a4;
  if ( a4 == 1 )
  {
    v7 = (const char *)*a2;
    if ( *a2 )
    {
      v7 = 0;
      v4 = -9999;
      v78 = 0;
      v33 = 0;
      v77 = 0;
      v30 = 0;
      v14 = 0;
      v8 = 0;
    }
    else
    {
      v8 = sub_12344(0xBB8u);
      sub_1E9F8(v8, (int)a2, *a2);
      sub_124A0((int)v8, 0);
      v9 = sub_12664(v8);
      sub_1250C((int)v8, v9);
      v89[1] = 1;
      v89[0] = &v83;
      v10 = *a2;
      v83 = 0;
      if ( v10 )
      {
        v78 = 0;
        v14 = 0;
        v81 = -1;
        v20 = 0;
      }
      else
      {
        v11 = a2[3];
        if ( !*(_DWORD *)(v11 + 12) || !*(_DWORD *)(v11 + 16) )
        {
          v12 = "Pre-0.33 Dropbear keys cannot be converted to OpenSSH keys.\n";
          v13 = (FILE *)stderr;
LABEL_7:
          fputs(v12, v13);
          if ( !v8 )
            return 0;
          v6 = 0;
          v14 = 0;
LABEL_10:
          sub_1238C(v8);
          j_free(v8);
LABEL_55:
          if ( !v14 )
            return v6;
          sub_1238C(v14);
          v64 = v14;
LABEL_57:
          j_free(v64);
          return v6;
        }
        v15 = sub_12664(v8);
        v89[5] = v15;
        v89[4] = sub_125E4(v8, v15);
        sub_1250C((int)v8, v15);
        v16 = sub_12664(v8);
        v89[3] = v16;
        v89[2] = sub_125E4(v8, v16);
        sub_1250C((int)v8, v16);
        v17 = sub_12664(v8);
        v89[7] = v17;
        v89[6] = sub_125E4(v8, v17);
        sub_1250C((int)v8, v17);
        v18 = sub_12664(v8);
        v89[9] = v18;
        v89[8] = sub_125E4(v8, v18);
        sub_1250C((int)v8, v18);
        v19 = sub_12664(v8);
        v89[11] = v19;
        v89[10] = sub_125E4(v8, v19);
        sub_1250C((int)v8, v19);
        sub_121B0((int)v88);
        sub_121B0((int)v85);
        sub_121B0((int)v86);
        sub_121B0((int)v87);
        if ( sub_2E7D4(*(int **)(a2[3] + 12), 1u, v88) )
        {
          v12 = "Bignum error for p-1\n";
          v13 = (FILE *)stderr;
          goto LABEL_7;
        }
        if ( sub_2C470(*(int **)(a2[3] + 8), v88, v85) )
        {
          v12 = "Bignum error for dmp1\n";
          v13 = (FILE *)stderr;
          goto LABEL_7;
        }
        if ( sub_2E7D4(*(int **)(a2[3] + 16), 1u, v88) )
        {
          v12 = "Bignum error for q-1\n";
          v13 = (FILE *)stderr;
          goto LABEL_7;
        }
        if ( sub_2C470(*(int **)(a2[3] + 8), v88, v86) )
        {
          v12 = "Bignum error for dmq1\n";
          v13 = (FILE *)stderr;
          goto LABEL_7;
        }
        v20 = sub_2BBA8(*(int **)(a2[3] + 16), *(_DWORD *)(a2[3] + 12), v87);
        if ( v20 )
        {
          v12 = "Bignum error for iqmp\n";
          v13 = (FILE *)stderr;
          goto LABEL_7;
        }
        v14 = sub_12344(0x7D0u);
        sub_1282C(v14, (int)v85);
        sub_1282C(v14, (int)v86);
        sub_1282C(v14, (int)v87);
        sub_124A0((int)v14, 0);
        sub_29D74((int)v85);
        sub_29D74((int)v86);
        sub_29D74((int)v87);
        sub_29D74((int)v88);
        v21 = sub_12664(v14);
        v89[13] = v21;
        v89[12] = sub_125E4(v14, v21);
        sub_1250C((int)v14, v21);
        v22 = sub_12664(v14);
        v89[15] = v22;
        v89[14] = sub_125E4(v14, v22);
        sub_1250C((int)v14, v22);
        v23 = sub_12664(v14);
        v89[17] = v23;
        v24 = sub_125E4(v14, v23);
        v25 = v23;
        v26 = 0;
        v89[16] = v24;
        sub_1250C((int)v14, v25);
        do
        {
          v27 = &v89[v26];
          v26 += 2;
          v28 = v27[1];
          v20 += v28 + sub_1A710(0, 2, v28, 0);
        }
        while ( v26 != 18 );
        v7 = "-----END RSA PRIVATE KEY-----\n";
        v78 = "-----BEGIN RSA PRIVATE KEY-----\n";
        v81 = 9;
      }
      v77 = sub_1A710(0, 16, v20, 32) + v20;
      v29 = a3;
      if ( a3 )
        v29 = v77;
      else
        v4 = v77;
      if ( a3 )
        v4 = (v29 + 8) & 0xFFFFFFF8;
      v30 = (unsigned __int8 *)sub_18718(v4);
      v31 = sub_1A710(v30, 16, v20, 32);
      v32 = 0;
      v33 = v31;
      while ( 1 )
      {
        v75 = v32;
        if ( v32 >= v81 )
          break;
        n = v89[2 * v32 + 1];
        v42 = v33 + sub_1A710(&v30[v33], 2, n, 0);
        memcpy(&v30[v42], (const void *)v89[2 * v75], n);
        v33 = n + v42;
        v32 = v75 + 1;
      }
    }
    if ( (unsigned int)(*a2 - 1) > 2 )
    {
      if ( v33 != v77 )
      {
        v40 = 1147;
        v41 = "pos == len";
LABEL_34:
        sub_184D4(v41, "keyimport.c", v40);
      }
      v66 = &v30[v33];
      v67 = v4 - v33;
      while ( v66 - v30 < v4 )
        *v66++ = v67;
LABEL_49:
      if ( a3 )
      {
        v62 = "Encrypted keys aren't supported currently\n";
        v63 = (FILE *)stderr;
      }
      else
      {
        if ( strlen(a1) == 1 && *a1 == 45 )
          v68 = (FILE *)stdout;
        else
          v68 = (FILE *)fopen64(a1, "wb");
        if ( v68 )
        {
          v69 = v30;
          fputs(v78, v68);
          while ( v4 > 0 )
          {
            if ( v4 >= 48 )
              v70 = 48;
            else
              v70 = v4;
            v76 = v70;
            v84 = 100;
            sub_26D2C(v69, v70, ptr, &v84);
            v69 += v76;
            v4 -= v76;
            fwrite(ptr, 1u, v84, v68);
            fputc(10, v68);
          }
          fputs(v7, v68);
          fclose(v68);
LABEL_52:
          if ( v30 )
            free(v30);
          if ( !v8 )
            goto LABEL_55;
          goto LABEL_10;
        }
        v62 = "Failed opening output file\n";
        v63 = (FILE *)stderr;
      }
      v6 = 0;
      fputs(v62, v63);
      goto LABEL_52;
    }
    v34 = (const void **)sub_12344(0x190u);
    v35 = sub_1E708((int)a2, *a2);
    v36 = **(_DWORD **)(*(_DWORD *)v35 + 8);
    ptr[0] = 2 * v36 + 1;
    v37 = (_BYTE *)sub_12624(v34, 0xAu);
    v38 = sub_1A710(v37, 2, 1, 0);
    sub_124C4(v34, v38);
    sub_125A4((int)v34, 1);
    v39 = sub_2EB68(*(int **)(*(_DWORD *)v35 + 24));
    if ( v36 < v39 )
    {
      v40 = 1067;
      v41 = "k_size <= curve_size";
      goto LABEL_34;
    }
    v43 = (_BYTE *)sub_12624(v34, 0xAu);
    v44 = sub_1A710(v43, 4, v39, 0);
    sub_124C4(v34, v44);
    v45 = *(int **)(*(_DWORD *)v35 + 24);
    v46 = (_BYTE *)sub_12624(v34, v39);
    sub_2EACC(v45, v46);
    sub_124C4(v34, v39);
    v47 = *a2;
    if ( *a2 == 2 )
    {
      v48 = &unk_363D0;
    }
    else
    {
      if ( v47 != 3 )
      {
        if ( v47 != 1 )
          sub_184AC("Internal error");
        v48 = &unk_363C8;
        v49 = 8;
        goto LABEL_43;
      }
      v48 = &unk_363D5;
    }
    v49 = 5;
LABEL_43:
    v50 = (_BYTE *)sub_12624(v34, 0xAu);
    v51 = sub_1A710(v50, 0, v49 + 2, 160);
    sub_124C4(v34, v51);
    v52 = (_BYTE *)sub_12624(v34, 0xAu);
    v53 = sub_1A710(v52, 6, v49, 0);
    sub_124C4(v34, v53);
    sub_127C4(v34, v48, v49);
    v54 = (_BYTE *)sub_12624(v34, 0xAu);
    v55 = sub_1A710(v54, 1, ptr[0] + 3, 160);
    sub_124C4(v34, v55);
    v56 = (_BYTE *)sub_12624(v34, 0xAu);
    v57 = sub_1A710(v56, 3, ptr[0] + 1, 0);
    sub_124C4(v34, v57);
    sub_125A4((int)v34, 0);
    v58 = *(_DWORD *)v35;
    v59 = (_BYTE *)sub_12624(v34, ptr[0]);
    if ( sub_27634(v58, v59, ptr) )
      sub_184AC("ECC error");
    sub_124C4(v34, ptr[0]);
    sub_124A0((int)v34, 0);
    v30 = (unsigned __int8 *)sub_18718(0x3E8u);
    v60 = sub_1A710(v30, 16, (int)v34[1], 32);
    memcpy(&v30[v60], *v34, (size_t)v34[1]);
    v4 = (signed int)v34[1] + v60;
    sub_1238C(v34);
    v61 = v34;
    v7 = "-----END EC PRIVATE KEY-----\n";
    j_free(v61);
    v78 = "-----BEGIN EC PRIVATE KEY-----\n";
    goto LABEL_49;
  }
  if ( !a4 )
  {
    v71 = sub_12344(0x6A4u);
    sub_1E9F8(v71, (int)a2, *a2);
    v72 = (FILE *)fopen64(a1, "w");
    if ( v72 )
    {
      sub_124A0((int)v71, v6);
      do
      {
        v73 = (const void *)sub_125E4(v71, v71[1] - v71[2]);
        v74 = fwrite(v73, 1u, v71[1] - v71[2], v72);
        sub_1250C((int)v71, v74);
      }
      while ( v74 > 0 && v71[1] != v71[2] );
      fclose(v72);
      v6 = v71[2] == v71[1];
    }
    v64 = v71;
    goto LABEL_57;
  }
  return 0;
}
// 1B7B0: variable 'v4' is possibly undefined
// 11EA4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 4C448: using guessed type int stderr;
// 4C454: using guessed type int stdout;

//----- (0001BD84) --------------------------------------------------------
_DWORD *__fastcall sub_1BD84(int *a1, int a2)
{
  _DWORD *result; // r0
  int v5; // r3
  bool v6; // zf

  result = sub_18718(0x10u);
  *result = a2;
  result[1] = 0;
  v5 = *a1;
  result[3] = a1;
  v6 = v5 == 0;
  if ( v5 )
  {
    v5 = a1[1];
  }
  else
  {
    *a1 = (int)result;
    result[2] = 0;
  }
  if ( !v6 )
  {
    result[2] = v5;
    *(_DWORD *)(v5 + 4) = result;
  }
  a1[1] = (int)result;
  return result;
}

//----- (0001BDCC) --------------------------------------------------------
_DWORD *sub_1BDCC()
{
  _DWORD *result; // r0

  result = sub_18718(8u);
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (0001BDE8) --------------------------------------------------------
int __fastcall sub_1BDE8(int *a1)
{
  int **v1; // r2
  int *v2; // r1
  int v3; // r4
  int *v4; // r3
  bool v5; // zf
  int *v6; // r3
  int v7; // r2

  v1 = (int **)a1[3];
  v2 = (int *)a1[1];
  v3 = *a1;
  v4 = v1[1];
  if ( *v1 == a1 )
    *v1 = v2;
  v5 = v4 == a1;
  v6 = (int *)a1[2];
  if ( v5 )
    v1[1] = v6;
  if ( v6 )
    v6[1] = (int)v2;
  v7 = a1[1];
  if ( v7 )
    *(_DWORD *)(v7 + 8) = v6;
  free(a1);
  return v3;
}

//----- (0001BE34) --------------------------------------------------------
_DWORD *sub_1BE34()
{
  _DWORD *result; // r0

  result = sub_18718(4u);
  dword_4CB38 = (int)result;
  dword_4CB3C = 1;
  *result = 0;
  return result;
}
// 4CB38: using guessed type int dword_4CB38;
// 4CB3C: using guessed type int dword_4CB3C;

//----- (0001BE60) --------------------------------------------------------
int __fastcall sub_1BE60(int result)
{
  int **v1; // r12
  int v2; // lr
  int *v3; // r2
  int *v4; // t1
  int *v5; // r4
  int v6; // r3
  int v7; // t1
  int v8; // r1
  bool v9; // nf
  int v10; // r1
  int v11; // r5

  v1 = (int **)dword_4CB38;
  v2 = dword_4CB38 + 4 * dword_4CB3C;
  while ( v1 != (int **)v2 )
  {
    v4 = *v1++;
    v3 = v4;
    if ( v4 )
    {
      v5 = &v3[v3[2]];
      while ( v3 != v5 )
      {
        v7 = *v3++;
        v6 = v7;
        v8 = v7 + 31;
        if ( v7 >= 0 )
          v8 = v6;
        v9 = -v6 < 0;
        v10 = v8 >> 5;
        v11 = -v6 & 0x1F;
        LOBYTE(v6) = v6 & 0x1F;
        if ( !v9 )
          v6 = -v11;
        *(_DWORD *)(result + 4 * v10) |= 1 << v6;
      }
    }
  }
  return result;
}
// 4CB38: using guessed type int dword_4CB38;
// 4CB3C: using guessed type int dword_4CB3C;

//----- (0001BED4) --------------------------------------------------------
int __fastcall sub_1BED4(int result)
{
  int v1; // r8
  unsigned int i; // r5
  int v3; // r4
  unsigned int j; // r6
  int v5; // r1
  int v6; // r2

  v1 = result;
  for ( i = 0; dword_4CB3C > i; ++i )
  {
    v3 = *(_DWORD *)(dword_4CB38 + 4 * i);
    if ( v3 )
    {
      for ( j = 0; *(_DWORD *)(v3 + 8) > j; ++j )
      {
        v5 = *(_DWORD *)(v3 + 4 * j);
        result = -v5 & 0x1F;
        LOBYTE(v6) = v5 & 0x1F;
        if ( v5 <= 0 )
          v6 = -result;
        if ( (*(_DWORD *)(v1 + 4 * (v5 / 32)) & (1 << v6)) != 0 )
          result = (*(int (__fastcall **)(int))(v3 + 16))(v3);
      }
    }
  }
  return result;
}
// 4CB38: using guessed type int dword_4CB38;
// 4CB3C: using guessed type int dword_4CB3C;

//----- (0001BF64) --------------------------------------------------------
_DWORD *__fastcall sub_1BF64(int *a1, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int i; // r5
  int j; // r4
  _DWORD *v12; // r0
  unsigned int v13; // r3
  unsigned int v14; // r2
  int *k; // r3
  _DWORD *v16; // r0
  _DWORD *v17; // r3
  int v19; // r0
  int v20; // t1

  for ( i = 0; dword_4CB3C != i; ++i )
  {
    if ( !*(_DWORD *)(dword_4CB38 + 4 * i) )
      goto LABEL_9;
  }
  if ( (unsigned int)dword_4CB3C > 0x14 )
  {
    for ( j = 0; j != a2; ++j )
      close(a1[i]);
    return 0;
  }
  v12 = sub_18888((void *)dword_4CB38, 4 * (i + 1));
  v13 = i;
  dword_4CB38 = (int)v12;
  v14 = ++dword_4CB3C;
  while ( v14 > v13 )
    v12[v13++] = 0;
LABEL_9:
  for ( k = a1; &a1[a2] != k; ++k )
  {
    v20 = *k;
    v19 = v20;
    if ( dword_4CA54 < v20 )
      dword_4CA54 = v19;
  }
  v16 = sub_18718(0x20u);
  v16[3] = i;
  v16[6] = a3;
  v16[7] = a4;
  v16[2] = a2;
  v17 = memcpy(v16, a1, 4 * a2);
  v17[4] = a5;
  v17[5] = a6;
  *(_DWORD *)(dword_4CB38 + 4 * i) = v17;
  return v17;
}
// 4CA54: using guessed type int dword_4CA54;
// 4CB38: using guessed type int dword_4CB38;
// 4CB3C: using guessed type int dword_4CB3C;

//----- (0001C088) --------------------------------------------------------
int __fastcall sub_1C088(int a1, int a2, int (__fastcall *a3)(int, _DWORD))
{
  unsigned int v6; // r6
  int v7; // r4

  v6 = 0;
  v7 = *(_DWORD *)dword_4CB38;
  while ( dword_4CB3C > v6 )
  {
    if ( *(_DWORD *)(v7 + 24) == a1 && a3(a2, *(_DWORD *)(v7 + 28)) )
      return v7;
    ++v6;
  }
  return 0;
}
// 4CB38: using guessed type int dword_4CB38;
// 4CB3C: using guessed type int dword_4CB3C;

//----- (0001C0F0) --------------------------------------------------------
void __fastcall sub_1C0F0(_DWORD *ptr)
{
  void (*v1)(void); // r3
  unsigned int i; // r5
  int v4; // r0

  v1 = (void (*)(void))ptr[5];
  if ( v1 )
    v1();
  for ( i = 0; ptr[2] > i; ++i )
  {
    v4 = ptr[i];
    close(v4);
  }
  *(_DWORD *)(dword_4CB38 + 4 * ptr[3]) = 0;
  free(ptr);
}
// 4CB38: using guessed type int dword_4CB38;

//----- (0001C14C) --------------------------------------------------------
void sub_1C14C()
{
  unsigned int i; // r4
  _DWORD *v1; // r0

  for ( i = 0; dword_4CB3C > i; ++i )
  {
    v1 = *(_DWORD **)(dword_4CB38 + 4 * i);
    if ( v1 )
      sub_1C0F0(v1);
  }
  free((void *)dword_4CB38);
  dword_4CB38 = 0;
}
// 4CB38: using guessed type int dword_4CB38;
// 4CB3C: using guessed type int dword_4CB3C;

//----- (0001C198) --------------------------------------------------------
int __fastcall sub_1C198(struct timeval a1)
{
  struct timeval *tv_sec; // r4
  int result; // r0
  struct timeval v3; // [sp+0h] [bp-8h] BYREF

  v3 = a1;
  tv_sec = (struct timeval *)a1.tv_sec;
  result = gettimeofday(&v3, 0);
  tv_sec[59] = v3;
  return result;
}

//----- (0001C1C4) --------------------------------------------------------
void *__fastcall sub_1C1C4(void *a1, char *a2, size_t a3)
{
  memset(a1, 0, a3);
  if ( !strncmp(a2, "/dev/", 5u) || strlen(a2) + 5 > a3 )
  {
    sub_16388((int)a1, a2, a3);
  }
  else
  {
    sub_16388((int)a1, "/dev/", a3);
    sub_163DC((char *)a1, a2, a3);
  }
  return a1;
}

//----- (0001C248) --------------------------------------------------------
int __fastcall sub_1C248(int a1, int a2, char *a3, char *a4, char *a5)
{
  struct passwd *v9; // r0

  memset((void *)a1, 0, 0x260u);
  *(_DWORD *)(a1 + 72) = a2;
  if ( a5 )
    sub_1C1C4((void *)(a1 + 80), a5, 0x40u);
  if ( a3 )
  {
    sub_16388(a1 + 144, a3, 64);
    v9 = getpwnam((const char *)(a1 + 144));
    if ( !v9 )
      sub_184AC("login_init_entry: Cannot find user \"%s\"", (const char *)(a1 + 144));
    *(_DWORD *)(a1 + 76) = v9->pw_uid;
  }
  if ( a4 )
    sub_16388(a1 + 208, a4, 256);
  return 1;
}

//----- (0001C2EC) --------------------------------------------------------
void *__fastcall sub_1C2EC(int a1, char *a2, char *a3, char *a4)
{
  void *v8; // r4

  v8 = sub_18718(0x260u);
  sub_1C248((int)v8, a1, a2, a3, a4);
  return v8;
}

//----- (0001C32C) --------------------------------------------------------
void *__fastcall sub_1C32C(void *a1, const char *a2, size_t a3)
{
  char *v6; // r1

  memset(a1, 0, a3);
  if ( !strncmp(a2, "/dev/", 5u) )
    v6 = (char *)(a2 + 5);
  else
    v6 = (char *)a2;
  sub_16388((int)a1, v6, a3);
  return a1;
}

//----- (0001C378) --------------------------------------------------------
void *__fastcall sub_1C378(void *a1, const char *a2, size_t a3)
{
  size_t v6; // r0

  memset(a1, 0, a3);
  if ( !strncmp(a2, "/dev/", 5u) )
    a2 += 5;
  v6 = strlen(a2);
  if ( v6 )
  {
    if ( a3 != v6 )
      a2 += v6 - a3;
    strncpy((char *)a1, a2, a3);
  }
  return a1;
}

//----- (0001C3E0) --------------------------------------------------------
int __fastcall sub_1C3E0(int result, int a2)
{
  *(_DWORD *)(a2 + 340) = *(_DWORD *)(result + 472);
  *(_DWORD *)(a2 + 344) = *(_DWORD *)(result + 476);
  return result;
}

//----- (0001C3F4) --------------------------------------------------------
void *__fastcall sub_1C3F4(int a1, char *s)
{
  int v4; // r3
  void *result; // r0

  memset(s, 0, 0x180u);
  sub_1C378(s + 40, (const char *)(a1 + 80), 4u);
  v4 = *(__int16 *)(a1 + 68);
  if ( v4 == 7 || v4 == 8 )
    *(_WORD *)s = v4;
  *((_DWORD *)s + 85) = *(_DWORD *)(a1 + 472);
  *((_DWORD *)s + 86) = *(_DWORD *)(a1 + 476);
  result = sub_1C32C(s + 8, (const char *)(a1 + 80), 0x20u);
  *((_DWORD *)s + 1) = *(_DWORD *)(a1 + 72);
  if ( *(_WORD *)(a1 + 68) != 8 )
  {
    strncpy(s + 44, (const char *)(a1 + 144), 0x20u);
    result = strncpy(s + 76, (const char *)(a1 + 208), 0x100u);
    if ( *(_WORD *)(a1 + 480) == 2 )
      *((_DWORD *)s + 87) = *(_DWORD *)(a1 + 484);
  }
  return result;
}

//----- (0001C4AC) --------------------------------------------------------
int __fastcall sub_1C4AC(int a1, int a2, int a3)
{
  int v4; // r2
  char *v6; // r0
  struct utmp *v7; // r4
  int *v8; // r0
  char *v9; // r0
  _DWORD v10[3]; // [sp+0h] [bp-Ch] BYREF

  v10[0] = a1;
  v10[1] = a2;
  v10[2] = a3;
  v4 = *(__int16 *)(a1 + 68);
  if ( v4 == 7 )
  {
    v6 = (char *)malloc(0x180u);
    v7 = (struct utmp *)v6;
    if ( !v6 )
    {
      sub_184E8(4, "syslogin_perform_login: couldn't malloc()");
      return 0;
    }
    sub_1C3F4(a1, v6);
    login(v7);
    free(v7);
  }
  else
  {
    if ( v4 != 8 )
    {
      sub_184E8(4, "syslogin_write_entry: Invalid type field");
      return 0;
    }
    sub_1C32C(v10, (const char *)(a1 + 80), 8u);
    if ( logout((const char *)v10) )
    {
      logwtmp((const char *)v10, "", "");
    }
    else
    {
      v8 = _errno_location();
      v9 = strerror(*v8);
      sub_184E8(4, "syslogin_perform_logout: logout(%s) returned an error: %s", (const char *)v10, v9);
    }
  }
  return 1;
}

//----- (0001C57C) --------------------------------------------------------
int __fastcall sub_1C57C(int a1)
{
  struct timeval v2; // r0
  int v3; // r1
  int v4; // r2

  if ( geteuid() )
    return 1;
  v2.tv_sec = a1;
  sub_1C198(v2);
  sub_1C4AC(a1, v3, v4);
  return 0;
}
// 1C594: variable 'v2' is possibly undefined
// 1C59C: variable 'v3' is possibly undefined
// 1C59C: variable 'v4' is possibly undefined

//----- (0001C5B0) --------------------------------------------------------
int __fastcall sub_1C5B0(int a1)
{
  *(_WORD *)(a1 + 68) = 7;
  return sub_1C57C(a1);
}

//----- (0001C5BC) --------------------------------------------------------
int __fastcall sub_1C5BC(int a1)
{
  *(_WORD *)(a1 + 68) = 8;
  return sub_1C57C(a1);
}

//----- (0001C5C8) --------------------------------------------------------
int sub_1C5C8()
{
  return 0;
}

//----- (0001C5D0) --------------------------------------------------------
int sub_1C5D0()
{
  return 0;
}

//----- (0001C5D8) --------------------------------------------------------
int sub_1C5D8()
{
  return 0;
}

//----- (0001C5E0) --------------------------------------------------------
int __fastcall sub_1C5E0(int a1, _DWORD *a2)
{
  if ( !a2 )
    sub_26EB8("outlen != NULL", "ltc_prng.c", 95);
  *a2 = 0;
  return 0;
}

//----- (0001C610) --------------------------------------------------------
unsigned int __fastcall sub_1C610(char *a1, unsigned int a2)
{
  if ( !a1 )
    sub_26EB8("out != NULL", "ltc_prng.c", 71);
  sub_18090(a1, a2);
  return a2;
}

//----- (0001C644) --------------------------------------------------------
int sub_1C644()
{
  return 0;
}

//----- (0001C64C) --------------------------------------------------------
int sub_1C64C()
{
  return 0;
}

//----- (0001C654) --------------------------------------------------------
int sub_1C654()
{
  return 0;
}

//----- (0001C65C) --------------------------------------------------------
int __fastcall sub_1C65C(int result, int a2)
{
  if ( !result )
    return sub_185B8(a2);
  return result;
}

//----- (0001C66C) --------------------------------------------------------
void __fastcall sub_1C66C(void *a1, int *a2)
{
  struct addrinfo *v3; // r0

  v3 = *(struct addrinfo **)a1;
  if ( v3 )
    freeaddrinfo(v3);
  free(*((void **)a1 + 2));
  free(*((void **)a1 + 3));
  free(*((void **)a1 + 8));
  free(*((void **)a1 + 9));
  free(*((void **)a1 + 10));
  free(a1);
  if ( a2 )
    sub_1BDE8(a2);
}

//----- (0001C6CC) --------------------------------------------------------
int __fastcall sub_1C6CC(int result)
{
  *(_DWORD *)(result + 16) = sub_1C65C;
  *(_DWORD *)(result + 20) = 0;
  return result;
}

//----- (0001C6E4) --------------------------------------------------------
struct addrinfo **__fastcall sub_1C6E4(
        const char *a1,
        const char *a2,
        struct addrinfo *a3,
        struct addrinfo *a4,
        const char *a5,
        const char *a6)
{
  struct addrinfo **v10; // r4
  int v11; // r0
  int v12; // r11
  const char *v13; // r0
  size_t v14; // r10
  char *v15; // r9
  const char *v16; // r0
  struct addrinfo s; // [sp+8h] [bp-24h] BYREF

  v10 = (struct addrinfo **)sub_18718(0x2Cu);
  v10[2] = (struct addrinfo *)sub_1886C(a1);
  v10[3] = (struct addrinfo *)sub_1886C(a2);
  v10[7] = (struct addrinfo *)-1;
  v10[4] = a3;
  v10[5] = a4;
  sub_1BD84(&dword_4CA94, (int)v10);
  memset(&s, 0, sizeof(s));
  s.ai_socktype = 1;
  v11 = getaddrinfo(a1, a2, &s, v10);
  v12 = v11;
  if ( v11 )
  {
    v13 = gai_strerror(v11);
    v14 = strlen(v13) + 100;
    v15 = (char *)sub_18718(v14);
    v10[8] = (struct addrinfo *)v15;
    v16 = gai_strerror(v12);
    snprintf(v15, v14, "Error resolving '%s' port '%s'. %s", a1, a2, v16);
  }
  else
  {
    v10[1] = *v10;
  }
  if ( a5 )
    v10[9] = (struct addrinfo *)sub_1886C(a5);
  if ( a6 )
    v10[10] = (struct addrinfo *)sub_1886C(a6);
  return v10;
}
// 4CA94: using guessed type int dword_4CA94;

//----- (0001C7FC) --------------------------------------------------------
int sub_1C7FC()
{
  int result; // r0

  while ( dword_4CA94 )
    sub_1C66C(*(void **)dword_4CA94, (int *)dword_4CA94);
  return result;
}
// 4CA94: using guessed type int dword_4CA94;

//----- (0001C820) --------------------------------------------------------
void __fastcall sub_1C820(int a1)
{
  int *i; // r5
  int v3; // r4
  int v4; // r0
  void *v5; // r0
  char *v6; // r0
  int optval; // [sp+8h] [bp-Ch] BYREF
  socklen_t optlen[2]; // [sp+Ch] [bp-8h] BYREF

  for ( i = (int *)dword_4CA94; i; i = (int *)i[1] )
  {
    v3 = *i;
    optlen[0] = 4;
    v4 = *(_DWORD *)(v3 + 28);
    if ( v4 >= 0 && (*(_DWORD *)(a1 + 4 * (v4 >> 5)) & (1 << (v4 & 0x1F))) != 0 )
    {
      if ( getsockopt(v4, 1, 4, &optval, optlen) )
      {
        sub_185B8(*(_DWORD *)(v3 + 28));
        *(_DWORD *)(v3 + 28) = -1;
      }
      else
      {
        if ( !optval )
        {
          (*(void (**)(void))(v3 + 16))();
          sub_1C66C((void *)v3, i);
          return;
        }
        sub_185B8(*(_DWORD *)(v3 + 28));
        v5 = *(void **)(v3 + 32);
        *(_DWORD *)(v3 + 28) = -1;
        free(v5);
        *(_DWORD *)(v3 + 32) = 0;
        v6 = strerror(optval);
        *(_DWORD *)(v3 + 32) = sub_1886C(v6);
      }
    }
  }
}
// 4CA94: using guessed type int dword_4CA94;

//----- (0001C90C) --------------------------------------------------------
int __fastcall sub_1C90C(int result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

//----- (0001C914) --------------------------------------------------------
int __fastcall sub_1C914(int result, int a2, unsigned int *a3)
{
  unsigned int v3; // r3
  _DWORD **v5; // r8
  unsigned int v7; // r6
  unsigned int v8; // r2
  int v9; // r3
  int v10; // r4

  v3 = *(_DWORD *)(result + 8);
  v5 = *(_DWORD ***)result;
  v7 = 0;
  v8 = *a3;
  if ( v3 >= 0x400 )
    v3 = 1024;
  if ( v8 > v3 )
    *a3 = v3;
  else
    *a3 = v8;
  while ( *a3 > v7 )
  {
    a2 += 8;
    v9 = (*v5)[2];
    v10 = (*v5)[1] - 1 - v9;
    if ( v10 <= 0 )
      sub_184D4("len > 0", "netio.c", 309);
    ++v7;
    result = sub_125E4(*v5, (*v5)[1] - 1 - v9);
    *(_DWORD *)(a2 - 8) = result;
    *(_DWORD *)(a2 - 4) = v10;
    v5 = (_DWORD **)v5[1];
  }
  return result;
}

//----- (0001C9A0) --------------------------------------------------------
void __fastcall sub_1C9A0(int a1, int a2)
{
  int v4; // r0
  void *v5; // r5
  int v6; // r3

  while ( a2 > 0 )
  {
    v4 = sub_1DDB8(a1);
    v5 = (void *)v4;
    v6 = *(_DWORD *)(v4 + 4) - 1 - *(_DWORD *)(v4 + 8);
    if ( a2 < v6 )
    {
      sub_1250C(v4, a2);
      return;
    }
    a2 -= v6;
    sub_1DD60(a1);
    j_free(v5);
  }
}

//----- (0001C9FC) --------------------------------------------------------
int __fastcall sub_1C9FC(int a1)
{
  int v2; // [sp+Ch] [bp-4h] BYREF

  v2 = 1;
  return setsockopt(a1, 6, 1, &v2, 4u);
}

//----- (0001CA24) --------------------------------------------------------
void __fastcall sub_1CA24(int a1)
{
  int *i; // r6
  int v3; // r4
  int v4; // r5
  int v5; // r3
  int v6; // r0
  const char *v7; // r8
  const char *v8; // r10
  int v9; // r2
  int v10; // r0
  int v11; // r8
  const char *v12; // r0
  size_t v13; // r11
  char *v14; // r0
  int v15; // r3
  char *v16; // r10
  int v17; // r2
  const char *v18; // r0
  int v19; // r10
  char *v20; // r8
  __int64 v21; // r10
  char *v22; // r0
  int v23; // r0
  int *v24; // r8
  char *v25; // r0
  int *v26; // [sp+Ch] [bp-38h]
  int errnum; // [sp+10h] [bp-34h]
  int errnuma; // [sp+10h] [bp-34h]
  int v29; // [sp+14h] [bp-30h]
  struct addrinfo *pai; // [sp+1Ch] [bp-28h] BYREF
  addrinfo req; // [sp+20h] [bp-24h] BYREF

  for ( i = (int *)dword_4CA94; i; i = v26 )
  {
    v3 = *i;
    v26 = (int *)i[1];
LABEL_4:
    while ( 1 )
    {
      v4 = *(_DWORD *)(v3 + 4);
      v5 = *(_DWORD *)(v3 + 28);
      if ( !v4 )
        break;
      if ( v5 >= 0 )
        goto LABEL_6;
      while ( 1 )
      {
        if ( *(_DWORD *)(v3 + 28) != -1 )
          sub_184D4("c->sock == -1", "netio.c", 66);
        v6 = socket(*(_DWORD *)(v4 + 4), *(_DWORD *)(v4 + 8), *(_DWORD *)(v4 + 12));
        *(_DWORD *)(v3 + 28) = v6;
        if ( v6 < 0 )
          goto LABEL_14;
        v7 = *(const char **)(v3 + 36);
        v8 = *(const char **)(v3 + 40);
        if ( !v7 && !v8 )
          break;
        pai = 0;
        memset(&req, 0, sizeof(req));
        v9 = *(_DWORD *)(v4 + 4);
        req.ai_socktype = 1;
        req.ai_flags = 1;
        req.ai_family = v9;
        v10 = getaddrinfo(v7, v8, &req, &pai);
        v11 = v10;
        if ( v10 )
        {
          v12 = gai_strerror(v10);
          v13 = strlen(v12) + 100;
          free(*(void **)(v3 + 32));
          *(_DWORD *)(v3 + 32) = 0;
          v14 = (char *)sub_18718(v13);
          v15 = *(_DWORD *)(v3 + 36);
          v16 = v14;
          v17 = *(_DWORD *)(v3 + 40);
          *(_DWORD *)(v3 + 32) = v14;
          v29 = v15;
          errnum = v17;
          v18 = gai_strerror(v11);
          snprintf(v16, v13, "Error resolving bind address '%s' (port %s). %s", v29, errnum, v18);
        }
        else
        {
          v19 = bind(*(_DWORD *)(v3 + 28), pai->ai_addr, pai->ai_addrlen);
          freeaddrinfo(pai);
          pai = 0;
          if ( v19 >= 0 )
            break;
          errnuma = *_errno_location();
          free(*(void **)(v3 + 32));
          *(_DWORD *)(v3 + 32) = 0;
          v20 = (char *)sub_18718(0x12Cu);
          v21 = *(_QWORD *)(v3 + 36);
          *(_DWORD *)(v3 + 32) = v20;
          v22 = strerror(errnuma);
          snprintf(v20, 0x12Cu, "Error binding local address '%s' (port %s). %s", (_DWORD)v21, HIDWORD(v21), v22);
        }
LABEL_13:
        close(*(_DWORD *)(v3 + 28));
        *(_DWORD *)(v3 + 28) = -1;
LABEL_14:
        v4 = *(_DWORD *)(v4 + 28);
        if ( !v4 )
        {
          *(_DWORD *)(v3 + 4) = 0;
          goto LABEL_4;
        }
      }
      v23 = *(_DWORD *)(v3 + 28);
      if ( dword_4CA54 < v23 )
        dword_4CA54 = *(_DWORD *)(v3 + 28);
      sub_1C9FC(v23);
      sub_188B0(*(_DWORD *)(v3 + 28));
      if ( connect(*(_DWORD *)(v3 + 28), *(const struct sockaddr **)(v4 + 20), *(_DWORD *)(v4 + 16)) < 0 )
      {
        v24 = _errno_location();
        if ( *v24 != 115 )
        {
          free(*(void **)(v3 + 32));
          *(_DWORD *)(v3 + 32) = 0;
          v25 = strerror(*v24);
          *(_DWORD *)(v3 + 32) = sub_1886C(v25);
          goto LABEL_13;
        }
      }
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(v4 + 28);
    }
    if ( v5 >= 0 )
    {
LABEL_6:
      *(_DWORD *)(a1 + 4 * (v5 >> 5)) |= 1 << (v5 & 0x1F);
      continue;
    }
    if ( !*(_DWORD *)(v3 + 32) )
      *(_DWORD *)(v3 + 32) = sub_1886C("unexpected failure");
    (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(v3 + 16))(-1, -1, *(_DWORD *)(v3 + 20), *(_DWORD *)(v3 + 32));
    sub_1C66C((void *)v3, i);
  }
}
// 4CA54: using guessed type int dword_4CA54;
// 4CA94: using guessed type int dword_4CA94;

//----- (0001CD04) --------------------------------------------------------
int __fastcall sub_1CD04(int a1)
{
  int v2; // [sp+Ch] [bp-4h] BYREF

  v2 = 5;
  return setsockopt(a1, 6, 23, &v2, 4u);
}

//----- (0001CD30) --------------------------------------------------------
int __fastcall sub_1CD30(int fd, int a2)
{
  int v4; // r3
  int v5; // r3
  int result; // r0
  char *v7; // r0
  int optval; // [sp+8h] [bp-8h] BYREF
  int v9; // [sp+Ch] [bp-4h] BYREF

  optval = 0;
  v9 = 0;
  if ( a2 == 11 )
  {
    v4 = 16;
  }
  else
  {
    if ( a2 != 12 )
      goto LABEL_6;
    v4 = 8;
  }
  optval = v4;
LABEL_6:
  setsockopt(fd, 41, 67, &optval, 4u);
  setsockopt(fd, 0, 1, &optval, 4u);
  if ( a2 == 11 )
  {
    v5 = 6;
  }
  else
  {
    if ( a2 != 12 )
      goto LABEL_11;
    v5 = 2;
  }
  v9 = v5;
LABEL_11:
  result = setsockopt(fd, 1, 12, &v9, 4u);
  if ( result < 0 )
  {
    result = *_errno_location();
    if ( result != 88 )
    {
      v7 = strerror(result);
      return sub_184E8(4, "Couldn't set SO_PRIORITY (%s)", v7);
    }
  }
  return result;
}

//----- (0001CE04) --------------------------------------------------------
int __fastcall sub_1CE04(int a1)
{
  socklen_t len; // [sp+14h] [bp-A4h] BYREF
  char serv[32]; // [sp+18h] [bp-A0h] BYREF
  struct sockaddr s[8]; // [sp+38h] [bp-80h] BYREF

  len = 128;
  memset(s, 0, sizeof(s));
  if ( getsockname(a1, s, &len) < 0 )
    return 0;
  if ( s[0].sa_family == 10 )
    len = 28;
  if ( (s[0].sa_family & 0xFFF7) != 2 )
    return 0;
  getnameinfo(s, len, 0, 0, serv, 0x20u, 2u);
  return atoi(serv);
}

//----- (0001CE9C) --------------------------------------------------------
int __fastcall sub_1CE9C(const char *a1, const char *a2, int a3, unsigned int a4, char **a5, int *a6)
{
  int v8; // r2
  int v9; // r0
  int v10; // r7
  const char *v11; // r0
  size_t v12; // r5
  char *v13; // r4
  const char *v14; // r0
  struct addrinfo *v16; // r5
  signed int v17; // r9
  unsigned int v18; // r4
  _BOOL4 v19; // r6
  char *v20; // r0
  size_t v21; // r5
  char *v22; // r4
  char *v23; // r0
  int ai_family; // r0
  int v25; // r0
  int v26; // r6
  char *sa_data; // [sp+Ch] [bp-48h]
  struct addrinfo *pai; // [sp+1Ch] [bp-38h] BYREF
  int optval; // [sp+20h] [bp-34h] BYREF
  int v32; // [sp+24h] [bp-30h] BYREF
  _DWORD v33[2]; // [sp+28h] [bp-2Ch] BYREF
  struct addrinfo s; // [sp+30h] [bp-24h] BYREF

  pai = 0;
  memset(&s, 0, sizeof(s));
  s.ai_socktype = 1;
  if ( a1 )
  {
    v8 = *(unsigned __int8 *)a1;
    s.ai_flags = 1;
    if ( !v8 )
      a1 = 0;
  }
  v9 = getaddrinfo(a1, a2, &s, &pai);
  v10 = v9;
  if ( v9 )
  {
    if ( a5 && !*a5 )
    {
      v11 = gai_strerror(v9);
      v12 = strlen(v11) + 20;
      v13 = (char *)sub_18718(v12);
      *a5 = v13;
      v14 = gai_strerror(v10);
      snprintf(v13, v12, "Error resolving: %s", v14);
    }
    if ( pai )
      freeaddrinfo(pai);
    return -1;
  }
  v16 = pai;
  v17 = 0;
  v18 = 0;
  sa_data = 0;
  while ( 1 )
  {
    v19 = v18 < a4;
    if ( !v16 )
      v19 = 0;
    if ( !v19 )
      break;
    ai_family = v16->ai_family;
    if ( v17 > 0 )
    {
      if ( ai_family == 2 || ai_family == 10 )
        sa_data = v16->ai_addr->sa_data;
      *(_WORD *)sa_data = __rev16(v17);
    }
    v25 = socket(ai_family, v16->ai_socktype, v16->ai_protocol);
    v26 = v25;
    *(_DWORD *)(a3 + 4 * v18) = v25;
    if ( v25 >= 0 )
    {
      optval = 1;
      setsockopt(v25, 1, 2, &optval, 4u);
      v33[1] = 5;
      v33[0] = 1;
      setsockopt(v26, 1, 13, v33, 8u);
      if ( v16->ai_family == 10 )
      {
        v32 = 1;
        if ( setsockopt(v26, 41, 26, &v32, 4u) == -1 )
          sub_184E8(4, "Couldn't set IPV6_V6ONLY");
      }
      sub_1C9FC(v26);
      if ( bind(v26, v16->ai_addr, v16->ai_addrlen) < 0 || listen(v26, 1000) < 0 )
      {
        v10 = *_errno_location();
        close(v26);
      }
      else
      {
        if ( !v17 )
          v17 = sub_1CE04(v26);
        ++v18;
        if ( *a6 < v26 )
          *a6 = v26;
        else
          *a6 = *a6;
      }
    }
    else
    {
      v10 = *_errno_location();
    }
    v16 = v16->ai_next;
  }
  if ( pai )
  {
    freeaddrinfo(pai);
    pai = 0;
  }
  if ( !v18 )
  {
    if ( a5 && !*a5 )
    {
      v20 = strerror(v10);
      v21 = strlen(v20) + 20;
      v22 = (char *)sub_18718(v21);
      *a5 = v22;
      v23 = strerror(v10);
      snprintf(v22, v21, "Error listening: %s", v23);
    }
    return -1;
  }
  return v18;
}

//----- (0001D188) --------------------------------------------------------
char *__fastcall sub_1D188(const struct sockaddr *a1, char **a2, char **a3, int a4)
{
  bool v4; // zf
  int sa_family; // r3
  unsigned int flags; // r2
  socklen_t v11; // r1
  char *result; // r0
  const char *v13; // r0
  char serv[36]; // [sp+10h] [bp-428h] BYREF
  char host[1028]; // [sp+34h] [bp-404h] BYREF

  v4 = a4 == 0;
  sa_family = a1->sa_family;
  if ( v4 )
    flags = 3;
  else
    flags = 2;
  if ( sa_family == 2 )
  {
    v11 = 16;
  }
  else if ( sa_family == 10 )
  {
    v11 = 28;
  }
  else
  {
    v11 = 128;
  }
  result = (char *)getnameinfo(a1, v11, host, 0x401u, serv, 0x20u, flags);
  if ( result )
  {
    if ( !a4 )
    {
      v13 = gai_strerror((int)result);
      sub_184AC("Failed lookup: %s", v13);
    }
    return (char *)sub_1D188(a1, a2, a3, 0);
  }
  else
  {
    if ( a2 )
    {
      result = sub_1886C(host);
      *a2 = result;
    }
    if ( a3 )
    {
      result = sub_1886C(serv);
      *a3 = result;
    }
  }
  return result;
}

//----- (0001D25C) --------------------------------------------------------
char *__fastcall sub_1D25C(char *fd, char **a2, char **a3, unsigned int a4, char **a5, int a6)
{
  bool v6; // zf
  char *v7; // r8
  unsigned __int64 v8; // r4
  int *v11; // r0
  char *v12; // r0
  socklen_t v13; // [sp+4h] [bp-84h] BYREF
  struct sockaddr addr; // [sp+8h] [bp-80h] BYREF

  v6 = a3 == 0;
  if ( !a3 )
    v6 = a2 == 0;
  v7 = fd;
  v8 = __PAIR64__((unsigned int)a5, a4);
  if ( !v6 )
  {
    v13 = 128;
    if ( getsockname((int)fd, &addr, &v13) < 0 )
      goto LABEL_5;
    fd = sub_1D188(&addr, a2, a3, a6);
  }
  if ( v8 )
  {
    v13 = 128;
    if ( getpeername((int)v7, &addr, &v13) < 0 )
    {
LABEL_5:
      v11 = _errno_location();
      v12 = strerror(*v11);
      sub_184AC("Failed socket address: %s", v12);
    }
    return sub_1D188(&addr, (char **)v8, a5, a6);
  }
  return fd;
}

//----- (0001D318) --------------------------------------------------------
int __fastcall sub_1D318(int result, _DWORD *a2, _DWORD *a3, unsigned int a4, int a5)
{
  int v5; // r12
  unsigned int v8; // r4
  int v9; // r0
  unsigned int v10; // [sp+0h] [bp-1B8h] BYREF
  unsigned int v11; // [sp+4h] [bp-1B4h] BYREF
  _BYTE v12[432]; // [sp+8h] [bp-1B0h] BYREF

  v5 = a2[2];
  if ( *(_BYTE *)(v5 + 8) )
  {
    v8 = result;
    if ( sub_25B04((int)v12, a2[3], a2 + 195, *(_DWORD *)(v5 + 4))
      || (v10 = bswap32(v8), sub_25C88((int)v12, (int)&v10, 4))
      || (sub_124A0((int)a3, 0), v9 = sub_125E4(a3, a4), sub_25C88((int)v12, v9, a4))
      || (v11 = 32, (result = sub_259AC((int)v12, a5, &v11)) != 0) )
    {
      sub_184AC("HMAC error");
    }
  }
  return result;
}

//----- (0001D3D8) --------------------------------------------------------
void sub_1D3D8()
{
  ssize_t v0; // r0
  ssize_t v1; // r5
  int v2; // r0
  bool v3; // zf
  char *v4; // r0
  int count; // [sp+4h] [bp-198h] BYREF
  struct iovec iovec; // [sp+8h] [bp-194h] BYREF

  count = 50;
  if ( sub_1DD50(dword_4CA5C) )
    sub_184D4("!isempty(&ses.writequeue)", "packet.c", 71);
  sub_1C914((int)dword_4CA5C, (int)&iovec, (unsigned int *)&count);
  v0 = writev(dword_4CA4C, &iovec, count);
  v1 = v0;
  if ( v0 >= 0 )
  {
    sub_1C9A0((int)dword_4CA5C, v0);
    dword_4CA68 -= v1;
    if ( !v1 )
      off_4CAE4();
  }
  else
  {
    v2 = *_errno_location();
    v3 = v2 == 11;
    if ( v2 != 11 )
      v3 = v2 == 4;
    if ( !v3 )
    {
      v4 = strerror(v2);
      sub_184AC("Error writing: %s", v4);
    }
  }
}
// 4CA4C: using guessed type int dword_4CA4C;
// 4CA5C: using guessed type int dword_4CA5C[3];
// 4CA68: using guessed type int dword_4CA68;
// 4CAE4: using guessed type int (*off_4CAE4)(void);

//----- (0001D49C) --------------------------------------------------------
_DWORD *sub_1D49C()
{
  unsigned int v0; // r1
  int v1; // r7
  int v2; // r5
  int (__fastcall *v3)(int, int, int, int); // r6
  int v4; // r8
  int v5; // r0
  int v6; // r5
  unsigned int v7; // r6
  unsigned int v8; // r5
  int v9; // r0
  int v10; // r0
  int v11; // r6
  int v12; // r1
  _DWORD *result; // r0
  _BYTE v14[32]; // [sp+8h] [bp-20h] BYREF

  v0 = *(unsigned __int8 *)(*(_DWORD *)dword_4CABC + 8);
  v1 = *(unsigned __int8 *)(*(_DWORD *)(dword_4CABC + 8) + 8);
  dword_4CAB8 += *(_DWORD *)(dword_4CA6C + 4);
  sub_124A0(dword_4CA6C, v0);
  v2 = *(_DWORD *)(dword_4CA6C + 4) - v1 - *(_DWORD *)(dword_4CA6C + 8);
  v3 = *(int (__fastcall **)(int, int, int, int))(*(_DWORD *)(dword_4CABC + 4) + 8);
  v4 = sub_125E4((_DWORD *)dword_4CA6C, v2);
  v5 = sub_12624((_DWORD *)dword_4CA6C, v2);
  if ( v3(v4, v5, v2, dword_4CABC + 20) )
    sub_184AC("Error decrypting");
  sub_1250C(dword_4CA6C, v2);
  v6 = *(_DWORD *)(dword_4CA6C + 4);
  v7 = *(unsigned __int8 *)(*(_DWORD *)(dword_4CABC + 8) + 8);
  sub_124A0(dword_4CA6C, 0);
  v8 = v6 - v7;
  sub_1D318(dword_4CA7C, (_DWORD *)dword_4CABC, (_DWORD *)dword_4CA6C, v8, (int)v14);
  sub_124A0(dword_4CA6C, v8);
  v9 = sub_125E4((_DWORD *)dword_4CA6C, v7);
  if ( sub_18BC0((int)v14, v9, v7) )
    sub_184AC("Integrity error");
  sub_124A0(dword_4CA6C, 4u);
  v10 = *(_DWORD *)(dword_4CA6C + 4) - sub_12560(dword_4CA6C) - v1;
  v11 = v10 - 5;
  if ( (unsigned int)(v10 - 6) > 0x8014 )
    sub_184AC("Bad packet size %u", v11);
  sub_124A0(dword_4CA6C, 5u);
  v12 = *(_DWORD *)(dword_4CA6C + 8);
  dword_4CA70 = dword_4CA6C;
  dword_4CA74 = v12;
  result = sub_12430((_DWORD *)dword_4CA6C, v12 + v11);
  dword_4CA6C = 0;
  ++dword_4CA7C;
  return result;
}
// 4CA6C: using guessed type int dword_4CA6C;
// 4CA70: using guessed type int dword_4CA70;
// 4CA74: using guessed type int dword_4CA74;
// 4CA7C: using guessed type int dword_4CA7C;
// 4CAB8: using guessed type int dword_4CAB8;
// 4CABC: using guessed type int dword_4CABC;

//----- (0001D640) --------------------------------------------------------
_DWORD *sub_1D640()
{
  unsigned int v0; // r6
  int v1; // r7
  int v2; // r8
  unsigned int v3; // r5
  void *v4; // r0
  ssize_t v5; // r0
  unsigned int v6; // r8
  _DWORD *result; // r0
  int (__fastcall *v8)(int, int, unsigned int, int); // r5
  int v9; // r8
  int v10; // r0
  bool v11; // zf
  char *v12; // r1
  unsigned int v13; // r0
  unsigned int v14; // r5
  int v15; // r1
  int v16; // r3
  size_t v17; // r5
  int v18; // r6
  int v19; // r6
  void *v20; // r0
  ssize_t v21; // r0

  v0 = *(unsigned __int8 *)(*(_DWORD *)dword_4CABC + 8);
  if ( !dword_4CA6C || *(_DWORD *)(dword_4CA6C + 4) < v0 )
  {
    v1 = *(unsigned __int8 *)(*(_DWORD *)(dword_4CABC + 8) + 8);
    if ( !dword_4CA6C )
      dword_4CA6C = (int)sub_12344(0x80u);
    v2 = dword_4CA48;
    v3 = v0 - *(_DWORD *)(dword_4CA6C + 8);
    v4 = (void *)sub_12624((_DWORD *)dword_4CA6C, v3);
    v5 = read(v2, v4, v3);
    v6 = v5;
    if ( v5 )
    {
      if ( v5 < 0 )
        goto LABEL_12;
    }
    else
    {
      off_4CAE4();
    }
    result = sub_124C4((_DWORD *)dword_4CA6C, v6);
    if ( v3 != v6 )
      return result;
    sub_124A0(dword_4CA6C, 0);
    v8 = *(int (__fastcall **)(int, int, unsigned int, int))(*(_DWORD *)(dword_4CABC + 4) + 8);
    v9 = sub_125E4((_DWORD *)dword_4CA6C, v0);
    v10 = sub_12624((_DWORD *)dword_4CA6C, v0);
    if ( v8(v9, v10, v0, dword_4CABC + 20) )
      sub_184AC("Error decrypting");
    v13 = sub_12664((_DWORD *)dword_4CA6C);
    v14 = v1 + 4 + v13;
    if ( v14 > 0x88B8 || v14 < v1 + 16 || (sub_34DFC(v13 + 4, v0), v15) )
      sub_184AC("Integrity error (bad packet size %u)", v14);
    if ( v14 > *(_DWORD *)(dword_4CA6C + 12) )
      dword_4CA6C = (int)sub_12398((void *)dword_4CA6C, v14);
    sub_12430((_DWORD *)dword_4CA6C, v14);
    sub_124A0(dword_4CA6C, v0);
  }
  result = (_DWORD *)dword_4CA6C;
  v16 = *(_DWORD *)(dword_4CA6C + 4);
  v17 = v16 - *(_DWORD *)(dword_4CA6C + 8);
  if ( v16 == *(_DWORD *)(dword_4CA6C + 8) )
  {
    v18 = v16 - *(_DWORD *)(dword_4CA6C + 8);
    goto LABEL_28;
  }
  v19 = dword_4CA48;
  v20 = (void *)sub_125E4((_DWORD *)dword_4CA6C, v16 - *(_DWORD *)(dword_4CA6C + 8));
  v21 = read(v19, v20, v17);
  v18 = v21;
  if ( !v21 )
  {
    off_4CAE4();
LABEL_27:
    result = (_DWORD *)sub_1250C(dword_4CA6C, v18);
LABEL_28:
    if ( v18 == v17 )
      return sub_1D49C();
    return result;
  }
  if ( v21 >= 0 )
    goto LABEL_27;
LABEL_12:
  result = (_DWORD *)*_errno_location();
  v11 = result == (_DWORD *)11;
  if ( result != (_DWORD *)11 )
    v11 = result == (_DWORD *)4;
  if ( !v11 )
  {
    v12 = strerror((int)result);
    sub_184AC("Error reading: %s", v12);
  }
  return result;
}
// 1D790: variable 'v15' is possibly undefined
// 4CA48: using guessed type int dword_4CA48;
// 4CA6C: using guessed type int dword_4CA6C;
// 4CABC: using guessed type int dword_4CABC;
// 4CAE4: using guessed type int (*off_4CAE4)(void);

//----- (0001D84C) --------------------------------------------------------
_DWORD *__fastcall sub_1D84C(int a1, char a2)
{
  _DWORD *result; // r0

  sub_125A4(a1, a2);
  sub_124A0(a1, 0);
  result = sub_1DDE8(dword_4CA5C, a1);
  dword_4CA68 = dword_4CA68 - 1 + *(_DWORD *)(a1 + 4);
  return result;
}
// 4CA5C: using guessed type int dword_4CA5C[3];
// 4CA68: using guessed type int dword_4CA68;

//----- (0001D894) --------------------------------------------------------
_DWORD *sub_1D894()
{
  unsigned int v0; // r7
  bool v1; // cc
  _DWORD *v2; // r5
  _DWORD *result; // r0
  unsigned int v4; // r9
  unsigned int v5; // r8
  unsigned int v6; // r0
  unsigned int v7; // r0
  _DWORD *v8; // r5
  void *v9; // r6
  const void *v10; // r0
  unsigned int v11; // r10
  char v12; // r1
  unsigned int v13; // r6
  char *v14; // r0
  unsigned int v15; // r6
  int (__fastcall *v16)(int, int, unsigned int, int); // r10
  int v17; // r11
  int v18; // r0
  _DWORD *v19; // r0
  int v20; // r1
  bool v21; // cc
  _BYTE v22[36]; // [sp+8h] [bp-24h] BYREF

  sub_124A0(dword_4CA58, 0);
  v0 = sub_12560(dword_4CA58);
  sub_124A0(dword_4CA58, 0);
  if ( (byte_4CA84 & 1) != 0 )
    goto LABEL_10;
  if ( v0 > 0x31 )
    goto LABEL_6;
  v1 = v0 > 0x14;
  if ( v0 != 20 )
    v1 = (unsigned __int8)(v0 - 5) > 1u;
  if ( v1 )
  {
LABEL_10:
    v4 = *(unsigned __int8 *)(*(_DWORD *)(dword_4CABC + 816) + 8);
    v5 = *(unsigned __int8 *)(*(_DWORD *)(dword_4CABC + 824) + 8);
    v6 = *(_DWORD *)(dword_4CA58 + 4) + 9 + v5;
    if ( v4 < 0x10 )
      v7 = v6 + 16;
    else
      v7 = v6 + v4;
    v8 = sub_12344(v7);
    sub_12430(v8, 5u);
    sub_124A0((int)v8, 5u);
    v9 = (void *)sub_12624(v8, *(_DWORD *)(dword_4CA58 + 4));
    v10 = (const void *)sub_125E4((_DWORD *)dword_4CA58, *(_DWORD *)(dword_4CA58 + 4));
    memcpy(v9, v10, *(_DWORD *)(dword_4CA58 + 4));
    sub_124C4(v8, *(_DWORD *)(dword_4CA58 + 4));
    sub_124A0(dword_4CA58, 0);
    sub_12430((_DWORD *)dword_4CA58, 0);
    v11 = v8[1];
    sub_34DFC(v11, v4);
    v13 = (unsigned __int8)(v4 - v12);
    if ( v13 <= 3 )
      v13 = (unsigned __int8)(v4 + v13);
    if ( v13 + v11 <= 0xF )
      v13 = (unsigned __int8)(v13 + v4);
    sub_124A0((int)v8, 0);
    sub_1279C(v8, v8[1] - 4 + v13);
    sub_125A4((int)v8, v13);
    sub_124A0((int)v8, v8[1]);
    sub_12464((int)v8, v13);
    v14 = (char *)sub_125E4(v8, v13);
    sub_18090(v14, v13);
    sub_1D318(dword_4CA78, (_DWORD *)(dword_4CABC + 816), v8, v8[1], (int)v22);
    sub_124A0((int)v8, 0);
    v15 = v8[1];
    v16 = *(int (__fastcall **)(int, int, unsigned int, int))(*(_DWORD *)(dword_4CABC + 820) + 4);
    v17 = sub_125E4(v8, v15);
    v18 = sub_12624(v8, v15);
    if ( v16(v17, v18, v15, dword_4CABC + 836) )
      sub_184AC("Error encrypting");
    sub_1250C((int)v8, v15);
    sub_127C4(v8, v22, v5);
    dword_4CAB4 += v8[1];
    v19 = sub_1D84C((int)v8, v0);
    ++dword_4CA78;
    result = (_DWORD *)sub_18BF0((int)v19, v20);
    dword_4CAA4 = (int)result;
    v21 = v0 > 0x52;
    if ( v0 != 82 )
      v21 = (unsigned __int8)(v0 - 2) > 1u;
    if ( v21 )
      dword_4CAA8 = (int)result;
  }
  else
  {
LABEL_6:
    v2 = sub_18718(8u);
    *v2 = 0;
    v2[1] = sub_123F4(dword_4CA58);
    sub_124A0(dword_4CA58, 0);
    result = sub_12430((_DWORD *)dword_4CA58, 0);
    if ( dword_4CAE0 )
      *(_DWORD *)dword_4CAE0 = v2;
    else
      dword_4CADC = (int)v2;
    dword_4CAE0 = (int)v2;
  }
  return result;
}
// 1D9F8: variable 'v12' is possibly undefined
// 1DB38: variable 'v20' is possibly undefined
// 4CA58: using guessed type int dword_4CA58;
// 4CA78: using guessed type int dword_4CA78;
// 4CA84: using guessed type char byte_4CA84;
// 4CAA4: using guessed type int dword_4CAA4;
// 4CAA8: using guessed type int dword_4CAA8;
// 4CAB4: using guessed type int dword_4CAB4;
// 4CABC: using guessed type int dword_4CABC;
// 4CADC: using guessed type int dword_4CADC;
// 4CAE0: using guessed type int dword_4CAE0;

//----- (0001DB60) --------------------------------------------------------
_DWORD *sub_1DB60()
{
  const void ***i; // r4
  const void **v1; // r6
  _DWORD *result; // r0

  if ( (byte_4CA84 & 1) != 0 )
  {
    for ( i = (const void ***)dword_4CADC; i; i = (const void ***)v1 )
    {
      sub_127C4((_DWORD *)dword_4CA58, *i[1], (unsigned int)i[1][1]);
      j_free(i[1]);
      v1 = *i;
      free(i);
      result = sub_1D894();
    }
    dword_4CAE0 = 0;
    dword_4CADC = 0;
  }
  return result;
}
// 4CA58: using guessed type int dword_4CA58;
// 4CA84: using guessed type char byte_4CA84;
// 4CADC: using guessed type int dword_4CADC;
// 4CAE0: using guessed type int dword_4CAE0;

//----- (0001DBC0) --------------------------------------------------------
_DWORD *sub_1DBC0()
{
  sub_125A4(dword_4CA58, 3);
  sub_1279C((_DWORD *)dword_4CA58, dword_4CA7C - 1);
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;
// 4CA7C: using guessed type int dword_4CA7C;

//----- (0001DBF0) --------------------------------------------------------
void sub_1DBF0()
{
  unsigned int v0; // r5
  int v1; // r1
  time_t v2; // r0
  bool v3; // zf
  _BOOL4 v4; // r3
  _BOOL4 v5; // r2
  _BOOL4 v6; // r3
  void (**v7)(void); // r3
  int v8; // r2
  void (**v9)(void); // r1

  v0 = sub_12560(dword_4CA70);
  byte_4CA87 = v0;
  v2 = sub_18BF0(v0, v1);
  dword_4CAA0 = v2;
  if ( v0 == 1 )
    sub_18484("Disconnect received");
  if ( !v0 || v0 > 4 )
  {
    if ( (v0 & 0xFD) != 0x50 )
      dword_4CAA8 = v2;
    v3 = (unsigned __int8)byte_4CA85 == v0;
    if ( (unsigned __int8)byte_4CA85 != v0 )
      v3 = byte_4CA85 == 0;
    if ( v3 )
    {
      if ( byte_4CA86 )
      {
        byte_4CA86 = 0;
        goto LABEL_14;
      }
      if ( byte_4CA85 )
        v5 = (unsigned __int8)byte_4CA85 == v0;
      else
        v5 = 0;
      if ( v5 )
        byte_4CA85 = 0;
      v6 = v0 > 0x3C;
      if ( dword_4CAFC )
        v6 = 0;
      if ( v6 )
        sub_184AC("Received message %d before userauth", v0);
      v7 = (void (**)(void))dword_4CA80;
      while ( 1 )
      {
        v8 = *(unsigned __int8 *)v7;
        v9 = v7;
        if ( !*(_BYTE *)v7 )
          break;
        v7 += 2;
        if ( v8 == v0 )
        {
          v9[1]();
          goto LABEL_14;
        }
      }
    }
    else
    {
      v4 = v0 - 1 <= 0x30;
      if ( v0 - 5 <= 1 )
        v4 = 0;
      if ( !v4 || v0 == 20 )
        sub_184AC("Unexpected packet type %d, expected %d", v0, (unsigned __int8)byte_4CA85);
    }
    sub_1DBC0();
  }
LABEL_14:
  j_free((void *)dword_4CA70);
  dword_4CA70 = 0;
}
// 1DC08: variable 'v1' is possibly undefined
// 4CA70: using guessed type int dword_4CA70;
// 4CA80: using guessed type int dword_4CA80;
// 4CA85: using guessed type char byte_4CA85;
// 4CA86: using guessed type char byte_4CA86;
// 4CA87: using guessed type char byte_4CA87;
// 4CAA0: using guessed type int dword_4CAA0;
// 4CAA8: using guessed type int dword_4CAA8;
// 4CAFC: using guessed type int dword_4CAFC;

//----- (0001DD3C) --------------------------------------------------------
_DWORD *__fastcall sub_1DD3C(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (0001DD50) --------------------------------------------------------
bool __fastcall sub_1DD50(_DWORD *a1)
{
  return *a1 == 0;
}

//----- (0001DD60) --------------------------------------------------------
int __fastcall sub_1DD60(int a1)
{
  int *v2; // r0
  int v3; // r3
  int v4; // r5

  v2 = *(int **)a1;
  if ( !v2 )
    sub_184D4("!isempty(queue)", "queue.c", 45);
  v3 = v2[1];
  v4 = *v2;
  *(_DWORD *)a1 = v3;
  if ( !v3 )
    *(_DWORD *)(a1 + 4) = 0;
  free(v2);
  --*(_DWORD *)(a1 + 8);
  return v4;
}

//----- (0001DDB8) --------------------------------------------------------
int __fastcall sub_1DDB8(int a1)
{
  if ( !*(_DWORD *)a1 )
    sub_184D4("!isempty(queue)", "queue.c", 65);
  return **(_DWORD **)a1;
}

//----- (0001DDE8) --------------------------------------------------------
_DWORD *__fastcall sub_1DDE8(int *a1, int a2)
{
  _DWORD *result; // r0
  int v5; // r3
  int v6; // r3
  bool v7; // zf
  int v8; // r3

  result = sub_18718(8u);
  *result = a2;
  result[1] = 0;
  v5 = a1[1];
  if ( v5 )
    *(_DWORD *)(v5 + 4) = result;
  v6 = *a1;
  a1[1] = (int)result;
  v7 = v6 == 0;
  v8 = a1[2];
  if ( v7 )
    *a1 = (int)result;
  a1[2] = v8 + 1;
  return result;
}

//----- (0001DE34) --------------------------------------------------------
void __fastcall sub_1DE34(int **a1, int a2, int a3)
{
  char *v3; // r3
  _DWORD *v5; // r2
  int v8; // r0
  int v9; // r1
  int v10; // r2
  const char *v11; // r0
  int v12; // r0
  _DWORD *v13; // r0
  char v14; // r1
  _DWORD *i; // r4
  int v16; // r0
  _DWORD *v17; // r2
  int v18; // r12
  int v19; // r1
  bool v20; // zf
  _DWORD *v21; // r0
  unsigned __int8 *v22; // r0
  _BYTE v23[16]; // [sp+0h] [bp-E4h] BYREF
  unsigned int v24[53]; // [sp+10h] [bp-D4h] BYREF

  v3 = (char *)&unk_36B95;
  v5 = v23;
  do
  {
    v8 = *(_DWORD *)v3;
    v3 += 8;
    v9 = *((_DWORD *)v3 - 1);
    *v5 = v8;
    v5[1] = v9;
    v5 += 2;
  }
  while ( v3 != "rsa.c" );
  if ( !a1 )
  {
    v10 = 368;
    v11 = "key != NULL";
    goto LABEL_5;
  }
  v12 = sub_2EB68(*a1);
  v13 = sub_12344(v12 - 1);
  v14 = 1;
  for ( i = v13; ; v13 = i )
  {
    sub_125A4((int)v13, v14);
    if ( i[2] == i[3] - 36 )
      break;
    v14 = -1;
  }
  v16 = sub_12624(i, 0x10u);
  v17 = v23;
  v18 = v16;
  do
  {
    v18 += 8;
    v19 = v17[1];
    v20 = v17 + 2 == v24;
    *(_DWORD *)(v18 - 8) = *v17;
    *(_DWORD *)(v18 - 4) = v19;
    v17 += 2;
  }
  while ( !v20 );
  sub_124C4(i, 0x10u);
  sub_24A08((int)v24);
  sub_24A78(v24, *(char **)a2, *(_DWORD *)(a2 + 4));
  v21 = (_DWORD *)sub_12624(i, 0x14u);
  sub_248D4(v24, v21);
  sub_124C4(i, 0x14u);
  if ( i[2] != i[3] )
  {
    v10 = 389;
    v11 = "rsa_EM->pos == rsa_EM->size";
LABEL_5:
    sub_184D4(v11, "rsa.c", v10);
  }
  sub_124A0((int)i, 0);
  v22 = (unsigned __int8 *)sub_125E4(i, i[3]);
  sub_122E8(a3, v22, i[3]);
  j_free(i);
}

//----- (0001DFAC) --------------------------------------------------------
int __fastcall sub_1DFAC(_DWORD *a1, int *a2)
{
  if ( !a2 )
    sub_184D4("key != NULL", "rsa.c", 52);
  sub_12224((int)(a2 + 1), a2, 0);
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  sub_1250C((int)a1, 11);
  if ( sub_12910(a1, a2[1]) == -1 || sub_12910(a1, *a2) == -1 )
    goto LABEL_9;
  if ( sub_2A310((int *)*a2) < 1024 )
  {
    sub_184E8(4, "RSA key too short");
LABEL_9:
    sub_12288(a2 + 1, a2, 0);
    return -1;
  }
  if ( sub_2A310((int *)a2[1]) > 64 )
  {
    sub_184E8(4, "RSA key bad e");
    goto LABEL_9;
  }
  return 0;
}

//----- (0001E080) --------------------------------------------------------
int __fastcall sub_1E080(_DWORD *a1, int *a2)
{
  int result; // r0

  if ( !a2 )
    sub_184D4("key != NULL", "rsa.c", 93);
  result = sub_1DFAC(a1, a2);
  if ( result != -1 )
  {
    a2[2] = 0;
    a2[3] = 0;
    a2[4] = 0;
    sub_12224((int)(a2 + 2), 0);
    if ( sub_12910(a1, a2[2]) == -1
      || a1[2] != a1[1]
      && ((sub_12224((int)(a2 + 3), a2 + 4, 0), sub_12910(a1, a2[3]) == -1) || sub_12910(a1, a2[4]) == -1) )
    {
      sub_12288(a2 + 2, a2 + 3, a2 + 4, 0);
      return -1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0001E158) --------------------------------------------------------
void __fastcall sub_1E158(int *a1)
{
  if ( a1 )
  {
    sub_12288(a1 + 2, a1 + 1, a1 + 3, a1 + 4, a1, 0);
    free(a1);
  }
}

//----- (0001E19C) --------------------------------------------------------
_DWORD *__fastcall sub_1E19C(_DWORD *a1, int *a2)
{
  if ( !a2 )
    sub_184D4("key != NULL", "rsa.c", 159);
  sub_127F8(a1, "ssh-rsa", 7u);
  sub_1282C(a1, a2[1]);
  return sub_1282C(a1, *a2);
}

//----- (0001E1F0) --------------------------------------------------------
_DWORD *__fastcall sub_1E1F0(_DWORD *a1, int *a2)
{
  _DWORD *result; // r0
  int v5; // r1
  int v6; // r1

  if ( !a2 )
    sub_184D4("key != NULL", "rsa.c", 174);
  sub_1E19C(a1, a2);
  result = sub_1282C(a1, a2[2]);
  v5 = a2[3];
  if ( v5 )
    result = sub_1282C(a1, v5);
  v6 = a2[4];
  if ( v6 )
    return sub_1282C(a1, v6);
  return result;
}

//----- (0001E254) --------------------------------------------------------
int __fastcall sub_1E254(_DWORD *a1, int **a2, int a3)
{
  unsigned int v6; // r7
  int v7; // r4
  unsigned __int8 *v9; // r0
  int v10[4]; // [sp+0h] [bp-34h] BYREF
  int v11[4]; // [sp+10h] [bp-24h] BYREF
  int s[5]; // [sp+20h] [bp-14h] BYREF

  memset(v10, 0, sizeof(v10));
  memset(v11, 0, sizeof(v11));
  memset(s, 0, 0x10u);
  if ( !a2 )
    sub_184D4("key != NULL", "rsa.c", 203);
  sub_121CC((int)v11, v10, s, 0);
  v6 = sub_12664(a1);
  if ( sub_2EB68(*a2) != v6
    || (v9 = (unsigned __int8 *)sub_125E4(a1, a1[1] - a1[2]), sub_2DE30((int)v10, v9, a1[1] - a1[2]))
    || sub_29E00(v10, *a2) != -1
    || (sub_1DE34(a2, a3, (int)s), sub_2AB08(v10, a2[1], (int)*a2, v11)) )
  {
    v7 = -1;
  }
  else
  {
    v7 = -(sub_29E00(s, v11) != 0);
  }
  sub_29DB8((int)v11, v10, s, 0);
  return v7;
}

//----- (0001E394) --------------------------------------------------------
int __fastcall sub_1E394(_DWORD *a1, int **a2, int a3)
{
  int v6; // r2
  const char *v7; // r0
  int v8; // r2
  unsigned int v9; // r5
  unsigned int v10; // r7
  unsigned int v11; // r0
  unsigned int v12; // r8
  unsigned int v13; // r7
  _BYTE *v14; // r0
  int s[4]; // [sp+8h] [bp-40h] BYREF
  int v17[4]; // [sp+18h] [bp-30h] BYREF
  int v18[4]; // [sp+28h] [bp-20h] BYREF
  int v19[4]; // [sp+38h] [bp-10h] BYREF

  memset(s, 0, sizeof(s));
  memset(v17, 0, sizeof(v17));
  memset(v18, 0, sizeof(v18));
  memset(v19, 0, sizeof(v19));
  if ( !a2 )
  {
    v6 = 258;
    v7 = "key != NULL";
    goto LABEL_3;
  }
  sub_121CC((int)s, v17, v18, v19, 0);
  sub_1DE34(a2, a3, (int)v17);
  sub_18314(*a2, v18, v8);
  if ( sub_2AB08(v18, a2[1], (int)*a2, s) )
    goto LABEL_5;
  if ( sub_2BBA8(v18, (int)*a2, v19) )
    goto LABEL_5;
  if ( sub_2CCE0(v17, s, *a2, v18) )
    goto LABEL_5;
  if ( sub_2AB08(v18, a2[2], (int)*a2, v17) )
    goto LABEL_5;
  v9 = sub_2CCE0(v17, v19, *a2, s);
  if ( v9 )
    goto LABEL_5;
  sub_29DB8((int)v17, v18, v19, 0);
  sub_127F8(a1, "ssh-rsa", 7u);
  v10 = sub_2EB68(*a2);
  sub_1279C(a1, v10);
  v11 = sub_2EB68(s);
  v12 = v11;
  if ( v10 < v11 )
  {
    v6 = 322;
    v7 = "ssize <= nsize";
LABEL_3:
    sub_184D4(v7, "rsa.c", v6);
  }
  v13 = v10 - v11;
  while ( v13 > v9 )
  {
    ++v9;
    sub_125A4((int)a1, 0);
  }
  v14 = (_BYTE *)sub_12624(a1, v12);
  if ( sub_2EACC(s, v14) )
LABEL_5:
    sub_184AC("RSA error");
  sub_124C4(a1, v12);
  return sub_29D74((int)s);
}
// 1E434: variable 'v8' is possibly undefined

//----- (0001E594) --------------------------------------------------------
char *__fastcall sub_1E594(char *a1, unsigned int a2)
{
  char *v4; // r4
  char *v5; // r1
  char *v6; // r2
  unsigned int v7; // t1
  unsigned int v8; // r3
  char v9; // r3
  char v10; // r3
  unsigned int v11; // r3
  char v12; // r3
  char v14; // [sp+3h] [bp-E9h] BYREF
  int v15[5]; // [sp+4h] [bp-E8h] BYREF
  unsigned int v16[53]; // [sp+18h] [bp-D4h] BYREF

  sub_24A08((int)v16);
  sub_24A78(v16, a1, a2);
  sub_248D4(v16, v15);
  v4 = (char *)sub_18718(0x43u);
  strcpy(v4, "sha1!! ");
  v5 = &v14;
  v6 = v4;
  do
  {
    v7 = (unsigned __int8)*++v5;
    v6 += 3;
    v8 = v7 >> 4;
    if ( v7 >> 4 > 9 )
      v9 = v8 + 87;
    else
      v9 = v8 + 48;
    v6[4] = v9;
    v10 = *v5;
    v6[6] = 58;
    v11 = v10 & 0xF;
    if ( v11 > 9 )
      v12 = v11 + 87;
    else
      v12 = v11 + 48;
    v6[5] = v12;
  }
  while ( v6 != v4 + 60 );
  v4[66] = 0;
  return v4;
}

//----- (0001E644) --------------------------------------------------------
_DWORD *sub_1E644()
{
  _DWORD *result; // r0

  result = sub_18718(0x1Cu);
  *result = 90;
  result[1] = 2;
  return result;
}

//----- (0001E660) --------------------------------------------------------
char *__fastcall sub_1E660(unsigned int a1, size_t *a2)
{
  char *v2; // r4

  if ( a1 > 3 )
    sub_184AC("Bad key type %d", a1);
  v2 = off_36C00[a1];
  if ( a2 )
    *a2 = strlen(off_36C00[a1]);
  return v2;
}
// 36C00: using guessed type char *off_36C00[4];

//----- (0001E6A8) --------------------------------------------------------
int __fastcall sub_1E6A8(const void *a1, size_t a2)
{
  int v4; // r4
  int v5; // r5

  v4 = 0;
  while ( 1 )
  {
    v5 = v4;
    if ( strlen(off_36C00[v4]) == a2 && !memcmp(off_36C00[v4], a1, a2) )
      break;
    if ( ++v4 == 4 )
      return 90;
  }
  return v5;
}
// 36C00: using guessed type char *off_36C00[4];

//----- (0001E708) --------------------------------------------------------
int __fastcall sub_1E708(int a1, int a2)
{
  int result; // r0

  switch ( a2 )
  {
    case 0:
      result = a1 + 12;
      break;
    case 1:
      result = a1 + 16;
      break;
    case 2:
      result = a1 + 20;
      break;
    case 3:
      result = a1 + 24;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 1E710: control flows out of bounds to 1E714

//----- (0001E74C) --------------------------------------------------------
int __fastcall sub_1E74C(_DWORD *a1, int a2, int *a3)
{
  void *v6; // r8
  int v7; // r5
  bool v8; // zf
  int v9; // r4
  size_t v10; // r1
  int *v11; // r0
  int **v12; // r0
  size_t v13; // r1
  size_t v14; // r2
  void **v15; // r5
  int *v16; // r0
  char *v17; // r0
  size_t v19; // [sp+4h] [bp-4h] BYREF

  v19 = a2;
  v6 = sub_12690(a1, &v19);
  v7 = sub_1E6A8(v6, v19);
  free(v6);
  v8 = *a3 == v7;
  if ( *a3 != v7 )
    v8 = *a3 == 80;
  if ( !v8 )
    return -1;
  v10 = v19;
  *a3 = v7;
  sub_1250C((int)a1, -4 - v10);
  if ( v7 )
  {
    v9 = -1;
  }
  else
  {
    sub_1E158(*(int **)(a2 + 12));
    v11 = (int *)sub_18718(0x14u);
    *(_DWORD *)(a2 + 12) = v11;
    v9 = sub_1DFAC(a1, v11);
    if ( v9 == -1 )
    {
      sub_1E158(*(int **)(a2 + 12));
      *(_DWORD *)(a2 + 12) = 0;
    }
  }
  if ( sub_197C0(v7) )
  {
    v12 = (int **)sub_1E708(a2, v7);
    v15 = (void **)v12;
    if ( v12 )
    {
      v16 = *v12;
      if ( *v15 )
      {
        sub_277B4(v16, v13, v14);
        free(*v15);
        *v15 = 0;
      }
      v17 = sub_198C8(a1, v13, v14);
      *v15 = v17;
      if ( v17 )
        return 0;
    }
  }
  return v9;
}
// 1E824: variable 'v13' is possibly undefined
// 1E824: variable 'v14' is possibly undefined

//----- (0001E858) --------------------------------------------------------
int __fastcall sub_1E858(_DWORD *a1, int a2, int *a3)
{
  void *v6; // r8
  int v7; // r5
  bool v8; // zf
  int v9; // r4
  size_t v10; // r1
  int *v11; // r0
  int **v12; // r0
  size_t v13; // r1
  size_t v14; // r2
  void **v15; // r5
  int *v16; // r0
  int *v17; // r0
  size_t v19; // [sp+4h] [bp-4h] BYREF

  v19 = a2;
  v6 = sub_12690(a1, &v19);
  v7 = sub_1E6A8(v6, v19);
  free(v6);
  v8 = *a3 == v7;
  if ( *a3 != v7 )
    v8 = *a3 == 80;
  if ( !v8 )
    return -1;
  v10 = v19;
  *a3 = v7;
  sub_1250C((int)a1, -4 - v10);
  if ( v7 )
  {
    v9 = -1;
  }
  else
  {
    sub_1E158(*(int **)(a2 + 12));
    v11 = (int *)sub_18718(0x14u);
    *(_DWORD *)(a2 + 12) = v11;
    v9 = sub_1E080(a1, v11);
    if ( v9 == -1 )
    {
      sub_1E158(*(int **)(a2 + 12));
      *(_DWORD *)(a2 + 12) = 0;
    }
  }
  if ( sub_197C0(v7) )
  {
    v12 = (int **)sub_1E708(a2, v7);
    v15 = (void **)v12;
    if ( v12 )
    {
      v16 = *v12;
      if ( *v15 )
      {
        sub_277B4(v16, v13, v14);
        free(*v15);
        *v15 = 0;
      }
      v17 = sub_199A4(a1, v13, v14);
      *v15 = v17;
      if ( v17 )
        return 0;
    }
  }
  return v9;
}
// 1E930: variable 'v13' is possibly undefined
// 1E930: variable 'v14' is possibly undefined

//----- (0001E964) --------------------------------------------------------
void __fastcall sub_1E964(_DWORD *a1, int a2, int a3)
{
  _DWORD *v6; // r0
  _DWORD *v7; // r4
  int *v8; // r0

  v6 = sub_12344(0x6A4u);
  v7 = v6;
  if ( !a3 )
    sub_1E19C(v6, *(int **)(a2 + 12));
  if ( sub_197C0(a3) )
  {
    v8 = (int *)sub_1E708(a2, a3);
    if ( v8 )
    {
      if ( *v8 )
        sub_199E8(v7, *v8);
    }
  }
  if ( !v7[1] )
    sub_184AC("Bad key types in buf_put_pub_key");
  sub_12824(a1, (int)v7);
  j_free(v7);
}

//----- (0001E9F8) --------------------------------------------------------
_DWORD *__fastcall sub_1E9F8(_DWORD *a1, int a2, int a3)
{
  int *v7; // r0

  if ( !a3 )
    return sub_1E1F0(a1, *(int **)(a2 + 12));
  if ( !sub_197C0(a3) || (v7 = (int *)sub_1E708(a2, a3)) == 0 || !*v7 )
    sub_184AC("Bad key types in put pub key");
  return sub_19A64(a1, *v7);
}

//----- (0001EA60) --------------------------------------------------------
void __fastcall sub_1EA60(int a1)
{
  int v2; // r1
  int v3; // r2
  int *v4; // r0
  int *v5; // r0
  int *v6; // r0

  sub_1E158(*(int **)(a1 + 12));
  v4 = *(int **)(a1 + 16);
  *(_DWORD *)(a1 + 12) = 0;
  if ( v4 )
  {
    sub_277B4(v4, v2, v3);
    free(*(void **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
  }
  v5 = *(int **)(a1 + 20);
  if ( v5 )
  {
    sub_277B4(v5, v2, v3);
    free(*(void **)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
  }
  v6 = *(int **)(a1 + 24);
  if ( v6 )
  {
    sub_277B4(v6, v2, v3);
    free(*(void **)(a1 + 24));
  }
  free(*(void **)(a1 + 8));
  free((void *)a1);
}
// 1EA84: variable 'v2' is possibly undefined
// 1EA84: variable 'v3' is possibly undefined

//----- (0001EAE4) --------------------------------------------------------
void __fastcall sub_1EAE4(_DWORD *a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *v8; // r0
  _DWORD *v9; // r4
  int *v10; // r0

  v8 = sub_12344(0x6A4u);
  v9 = v8;
  if ( !a3 )
    sub_1E394(v8, *(int ***)(a2 + 12), (int)a4);
  if ( sub_197C0(a3) )
  {
    v10 = (int *)sub_1E708(a2, a3);
    if ( v10 )
    {
      if ( *v10 )
        sub_19A84(v9, *v10, a4);
    }
  }
  if ( !v9[1] )
    sub_184AC("Non-matching signing type");
  sub_12824(a1, (int)v9);
  j_free(v9);
}

//----- (0001EB84) --------------------------------------------------------
int __fastcall sub_1EB84(_DWORD *a1, int a2, _DWORD *a3)
{
  void *v6; // r8
  int v7; // r5
  int **v8; // r1
  _DWORD **v10; // r0
  size_t v11; // [sp+4h] [bp-4h] BYREF

  v11 = 0;
  sub_12664(a1);
  v6 = sub_12690(a1, &v11);
  v7 = sub_1E6A8(v6, v11);
  free(v6);
  if ( v7 )
  {
    if ( !sub_197C0(v7) || (v10 = (_DWORD **)sub_1E708(a2, v7)) == 0 || !*v10 )
      sub_184AC("Non-matching signing type");
    return sub_19D30(a1, *v10, a3);
  }
  else
  {
    v8 = *(int ***)(a2 + 12);
    if ( !v8 )
      sub_184AC("No RSA key to verify signature");
    return sub_1E254(a1, v8, (int)a3);
  }
}

//----- (0001EC44) --------------------------------------------------------
int __fastcall sub_1EC44(const void *a1, unsigned int a2, const void *a3, size_t a4, _DWORD *a5, char **a6)
{
  int v10; // r5
  _DWORD *v11; // r4
  unsigned __int8 *v12; // r11
  int v13; // r0
  int v14; // r5
  char *v16; // r0
  const void *v17; // r0
  unsigned int v18; // r5
  const void *v19; // r0
  unsigned int v20[2]; // [sp+4h] [bp-4h] BYREF

  v20[0] = a2;
  v20[1] = (unsigned int)a3;
  v10 = a5[1] - a5[2];
  v20[0] = 2 * v10;
  v11 = sub_12344(2 * v10);
  v12 = (unsigned __int8 *)sub_125E4(a5, v10);
  v13 = sub_12624(v11, v11[3]);
  if ( sub_26CFC(v12, v10, v13, v20) )
    goto LABEL_2;
  sub_12464((int)v11, v20[0]);
  if ( a6 )
  {
    v16 = (char *)sub_125E4(v11, v20[0]);
    *a6 = sub_1E594(v16, v20[0]);
  }
  if ( v20[0] == a2
    && (v17 = (const void *)sub_125E4(v11, v11[1]), !memcmp(v17, a1, v11[1]))
    && (v18 = sub_12664(v11), v19 = (const void *)sub_125E4(v11, v18), v18 == a4) )
  {
    v14 = -(memcmp(v19, a3, a4) != 0);
  }
  else
  {
LABEL_2:
    v14 = -1;
  }
  j_free(v11);
  return v14;
}

//----- (0001ED64) --------------------------------------------------------
int __fastcall sub_1ED64(int *a1, int *a2, int a3, int a4)
{
  int *v7; // r0
  char *v8; // r0
  char *v10; // r1

  if ( openpty(a1, a2, 0, 0, 0) >= 0 )
  {
    v10 = ttyname(*a2);
    if ( !v10 )
      sub_184AC("ttyname fails for openpty device");
    sub_16388(a3, v10, a4);
    return 1;
  }
  else
  {
    v7 = _errno_location();
    v8 = strerror(*v7);
    sub_184E8(4, "pty_allocate: openpty: %.100s", v8);
    return 0;
  }
}

//----- (0001EDEC) --------------------------------------------------------
int __fastcall sub_1EDEC(const char *a1)
{
  int v2; // r0
  char *v3; // r0
  int result; // r0
  char *v5; // r0

  if ( chown(a1, 0, 0) < 0 )
  {
    v2 = *_errno_location();
    if ( v2 != 2 )
    {
      v3 = strerror(v2);
      sub_184E8(3, "chown %.100s 0 0 failed: %.100s", a1, v3);
    }
  }
  result = chmod(a1, 0x1B6u);
  if ( result < 0 )
  {
    result = *_errno_location();
    if ( result != 2 )
    {
      v5 = strerror(result);
      return sub_184E8(3, "chmod %.100s 0666 failed: %.100s", a1, v5);
    }
  }
  return result;
}

//----- (0001EE78) --------------------------------------------------------
int __fastcall sub_1EE78(int *a1, const char *a2)
{
  int v4; // r0
  int v5; // r6
  int *v6; // r0
  char *v7; // r0
  int v8; // r6
  int *v9; // r0
  char *v10; // r0
  int v11; // r0
  int *v12; // r0
  char *v13; // r0
  int v14; // r0
  int *v15; // r0
  char *v16; // r0

  signal(22, (__sighandler_t)1);
  v4 = open64("/dev/tty", 258);
  v5 = v4;
  if ( v4 >= 0 )
  {
    ioctl(v4, 0x5422u, 0);
    close(v5);
  }
  if ( setsid() < 0 )
  {
    v6 = _errno_location();
    v7 = strerror(*v6);
    sub_184E8(3, "setsid: %.100s", v7);
  }
  v8 = open64("/dev/tty", 258);
  if ( v8 >= 0 )
  {
    sub_184E8(3, "Failed to disconnect from controlling tty.\n");
    close(v8);
  }
  if ( ioctl(*a1, 0x540Eu, 0) < 0 )
  {
    v9 = _errno_location();
    v10 = strerror(*v9);
    sub_184E8(3, "ioctl(TIOCSCTTY): %.100s", v10);
  }
  v11 = open64(a2, 2);
  if ( v11 >= 0 )
  {
    close(v11);
  }
  else
  {
    v12 = _errno_location();
    v13 = strerror(*v12);
    sub_184E8(3, "%.100s: %.100s", a2, v13);
  }
  v14 = open64("/dev/tty", 1);
  if ( v14 >= 0 )
    return close(v14);
  v15 = _errno_location();
  v16 = strerror(*v15);
  return sub_184E8(3, "open /dev/tty failed - could not set controlling tty: %.100s", v16);
}
// 11B98: using guessed type int __fastcall open64(_DWORD, _DWORD);

//----- (0001EFCC) --------------------------------------------------------
int __fastcall sub_1EFCC(int a1, __int16 a2, int a3, __int16 a4, int a5)
{
  _WORD v6[4]; // [sp+0h] [bp-Ch] BYREF
  int v7; // [sp+8h] [bp-4h]

  v7 = a3;
  v6[2] = a4;
  v6[0] = a2;
  v6[1] = a3;
  v6[3] = a5;
  return ioctl(a1, 0x5414u, v6, a5);
}

//----- (0001EFF8) --------------------------------------------------------
int __fastcall sub_1EFF8(int a1, const char *a2)
{
  struct group *v4; // r0
  __gid_t gr_gid; // r6
  __mode_t v6; // r5
  int result; // r0
  int *v8; // r0
  char *v9; // r0
  __uid_t v10; // r1
  int v11; // r0
  int v12; // r7
  bool v13; // zf
  char *v14; // r0
  int v15; // r0
  char *v16; // r0
  char *v17; // r0
  char *v18; // r0
  __int16 v19; // [sp+18h] [bp-5Ch]
  int v20; // [sp+20h] [bp-54h]
  int v21; // [sp+24h] [bp-50h]

  v4 = getgrnam("tty");
  if ( v4 )
  {
    gr_gid = v4->gr_gid;
    v6 = 400;
  }
  else
  {
    gr_gid = *(_DWORD *)(a1 + 12);
    v6 = 402;
  }
  result = sub_34FAC();
  if ( result )
  {
    v8 = _errno_location();
    v9 = strerror(*v8);
    sub_184AC("pty_setowner: stat(%.101s) failed: %.100s", a2, v9);
  }
  v10 = *(_DWORD *)(a1 + 8);
  if ( v20 != v10 || v21 != gr_gid )
  {
    result = chown(a2, v10, gr_gid);
    if ( result < 0 )
    {
      v11 = *_errno_location();
      v12 = *(_DWORD *)(a1 + 8);
      if ( v11 != 30 )
        goto LABEL_21;
      v13 = v20 == 0;
      if ( v20 )
        v13 = v20 == v12;
      if ( !v13 )
      {
LABEL_21:
        v17 = strerror(v11);
        sub_184AC("chown(%.100s, %u, %u) failed: %.100s", a2, v12, gr_gid, v17);
      }
      v14 = strerror(30);
      result = sub_184E8(3, "chown(%.100s, %u, %u) failed: %.100s", a2, v12, gr_gid, v14);
    }
  }
  if ( (v19 & 0x1FF) != v6 )
  {
    result = chmod(a2, v6);
    if ( result < 0 )
    {
      v15 = *_errno_location();
      if ( v15 != 30 || (v19 & 0x24) != 0 )
      {
        v18 = strerror(v15);
        sub_184AC("chmod(%.100s, 0%o) failed: %.100s", a2, v6, v18);
      }
      v16 = strerror(30);
      return sub_184E8(3, "chmod(%.100s, 0%o) failed: %.100s", a2, v6, v16);
    }
  }
  return result;
}
// 1F060: variable 'v20' is possibly undefined
// 1F06C: variable 'v21' is possibly undefined
// 1F0CC: variable 'v19' is possibly undefined

//----- (0001F170) --------------------------------------------------------
_DWORD *__fastcall sub_1F170(int a1, int fd)
{
  _DWORD *result; // r0
  _DWORD *v3; // r4

  result = (_DWORD *)accept(fd, 0, 0);
  v3 = result;
  if ( (int)result >= 0 )
  {
    if ( sub_143D8((int)result, (int)&unk_36E3C) )
      return (_DWORD *)close((int)v3);
    else
      return sub_1D894();
  }
  return result;
}

//----- (0001F1B4) --------------------------------------------------------
int __fastcall sub_1F1B4(int a1, int a2)
{
  __uid_t v4; // r8
  __gid_t v5; // r7
  int v6; // r4
  int v7; // r5
  int v9; // [sp+Ch] [bp-150h] BYREF
  char path[108]; // [sp+10h] [bp-14Ch] BYREF
  char v11[108]; // [sp+7Ch] [bp-E0h] BYREF
  struct sockaddr addr[7]; // [sp+E8h] [bp-74h] BYREF

  v4 = getuid();
  v5 = getgid();
  if ( setegid(dword_4CB0C) < 0 || seteuid(dword_4CB08) < 0 )
    sub_184AC("Failed to set euid");
  v6 = 20;
  memset(addr[0].sa_data, 0, 0x6Cu);
  addr[0].sa_family = 1;
  while ( 1 )
  {
    sub_18090((char *)&v9, 4u);
    snprintf(path, 0x6Cu, "/tmp/dropbear-%.8x", v9);
    if ( !mkdir(path, 0x1C0u) )
      break;
    if ( *_errno_location() == 17 )
    {
      if ( --v6 )
        continue;
    }
    goto LABEL_7;
  }
  sub_18090((char *)&v9, 4u);
  snprintf(v11, 0x6Cu, "auth-%.8x-%d", v9, a1);
  snprintf(addr[0].sa_data, 0x6Cu, "%s/%s", path, v11);
  v7 = bind(a1, addr, 0x6Eu);
  if ( v7 )
  {
LABEL_7:
    v7 = -1;
    goto LABEL_8;
  }
  *(_DWORD *)(a2 + 80) = sub_1886C(path);
  *(_DWORD *)(a2 + 76) = sub_1886C(v11);
LABEL_8:
  if ( seteuid(v4) < 0 || setegid(v5) < 0 )
    sub_184AC("Failed to revert euid");
  return v7;
}
// 4CB08: using guessed type int dword_4CB08;
// 4CB0C: using guessed type int dword_4CB0C;

//----- (0001F334) --------------------------------------------------------
void __fastcall sub_1F334(int a1)
{
  size_t v2; // r5
  size_t v3; // r5
  char *v4; // r6

  if ( *(_DWORD *)(a1 + 72) )
  {
    v2 = strlen(*(const char **)(a1 + 80));
    v3 = v2 + strlen(*(const char **)(a1 + 76)) + 2;
    v4 = (char *)sub_18718(v3);
    snprintf(v4, v3, "%s/%s", *(const char **)(a1 + 80), *(const char **)(a1 + 76));
    sub_20DC8("SSH_AUTH_SOCK", v4);
    free(v4);
  }
}

//----- (0001F3AC) --------------------------------------------------------
void __fastcall sub_1F3AC(int a1)
{
  _DWORD *v2; // r0
  __uid_t v3; // r8
  __gid_t v4; // r7
  size_t v5; // r5
  size_t v6; // r5
  char *v7; // r6

  v2 = *(_DWORD **)(a1 + 72);
  if ( v2 )
  {
    sub_1C0F0(v2);
    *(_DWORD *)(a1 + 72) = 0;
  }
  if ( *(_DWORD *)(a1 + 76) && *(_DWORD *)(a1 + 80) )
  {
    v3 = getuid();
    v4 = getgid();
    if ( setegid(dword_4CB0C) < 0 || seteuid(dword_4CB08) < 0 )
      sub_184AC("Failed to set euid");
    v5 = strlen(*(const char **)(a1 + 80));
    v6 = v5 + strlen(*(const char **)(a1 + 76)) + 2;
    v7 = (char *)sub_18718(v6);
    snprintf(v7, v6, "%s/%s", *(const char **)(a1 + 80), *(const char **)(a1 + 76));
    unlink(v7);
    free(v7);
    rmdir(*(const char **)(a1 + 80));
    if ( seteuid(v3) < 0 || setegid(v4) < 0 )
      sub_184AC("Failed to revert euid");
    free(*(void **)(a1 + 76));
    *(_DWORD *)(a1 + 76) = 0;
    free(*(void **)(a1 + 80));
    *(_DWORD *)(a1 + 80) = 0;
  }
}
// 4CB08: using guessed type int dword_4CB08;
// 4CB0C: using guessed type int dword_4CB0C;

//----- (0001F4D4) --------------------------------------------------------
int __fastcall sub_1F4D4(int a1)
{
  int v3; // r0
  _DWORD *v4; // r0
  int fd; // [sp+Ch] [bp-4h] BYREF

  fd = -1;
  if ( !sub_204C4() )
    return -1;
  if ( *(_DWORD *)(a1 + 72) )
    return -1;
  v3 = socket(1, 1, 0);
  fd = v3;
  if ( v3 < 0
    || sub_1F1B4(v3, a1) == -1
    || listen(fd, 20) < 0
    || (sub_188B0(fd), v4 = sub_1BF64(&fd, 1, 0, a1, (int)sub_1F170, 0), (*(_DWORD *)(a1 + 72) = v4) == 0) )
  {
    sub_185B8(fd);
    sub_1F3AC(a1);
    return -1;
  }
  return 0;
}

//----- (0001F5A0) --------------------------------------------------------
void *sub_1F5A0()
{
  void *result; // r0

  result = memset(&dword_4CAF0, 0, 0x34u);
  byte_4CAF4 = 2;
  if ( !dword_4CBB8 )
    byte_4CAF4 = 6;
  return result;
}
// 4CAF0: using guessed type int dword_4CAF0;
// 4CAF4: using guessed type char byte_4CAF4;
// 4CBB8: using guessed type int dword_4CBB8;

//----- (0001F5E4) --------------------------------------------------------
_DWORD *__fastcall sub_1F5E4(int a1)
{
  sub_125A4(dword_4CA58, 53);
  sub_12824((_DWORD *)dword_4CA58, a1);
  sub_127F8((_DWORD *)dword_4CA58, "en", 2u);
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;

//----- (0001F628) --------------------------------------------------------
_DWORD *__fastcall sub_1F628(int a1, unsigned int a2, unsigned int a3)
{
  _DWORD *v5; // r0
  _DWORD *v6; // r5
  char v7; // r1
  _DWORD *result; // r0
  int v9; // r1
  const char *v10; // r1
  unsigned int v11[2]; // [sp+4h] [bp-8h] BYREF

  v11[0] = a2;
  v11[1] = a3;
  sub_125A4(dword_4CA58, 51);
  v5 = sub_12344(0x1Eu);
  v6 = v5;
  if ( (byte_4CAF4 & 2) != 0 )
  {
    sub_127C4(v5, "publickey", 9u);
    if ( (byte_4CAF4 & 4) == 0 )
      goto LABEL_6;
    sub_125A4((int)v6, 44);
  }
  if ( (byte_4CAF4 & 4) != 0 )
    sub_127C4(v6, "password", 8u);
LABEL_6:
  sub_12824((_DWORD *)dword_4CA58, (int)v6);
  j_free(v6);
  v7 = a1;
  if ( a1 )
    v7 = 1;
  sub_125A4(dword_4CA58, v7);
  result = sub_1D894();
  if ( a2 )
  {
    sub_18090((char *)v11, 4u);
    sub_34DFC(v11[0], 0x186A0u);
    v11[0] = v9 + 250000;
    result = (_DWORD *)usleep(v9 + 250000);
    ++dword_4CAF8;
  }
  if ( dword_4CAF8 >= (unsigned int)dword_4CBC4 )
  {
    v10 = (const char *)dword_4CB18;
    if ( !dword_4CB18 )
      v10 = "is invalid";
    sub_184AC("Max auth tries reached - user '%s' from %s", v10, dword_4CC10);
  }
  return result;
}
// 1F6EC: variable 'v9' is possibly undefined
// 4CA58: using guessed type int dword_4CA58;
// 4CAF4: using guessed type char byte_4CAF4;
// 4CAF8: using guessed type int dword_4CAF8;
// 4CB18: using guessed type int dword_4CB18;
// 4CBC4: using guessed type int dword_4CBC4;
// 4CC10: using guessed type int dword_4CC10;

//----- (0001F75C) --------------------------------------------------------
int sub_1F75C()
{
  sub_125A4(dword_4CA58, 52);
  sub_1D894();
  dword_4CA44 = 0;
  dword_4CAFC = 1;
  if ( !dword_4CB08 )
    dword_4CB40 = 1;
  return sub_185B8(dword_4CBF4);
}
// 4CA44: using guessed type int dword_4CA44;
// 4CA58: using guessed type int dword_4CA58;
// 4CAFC: using guessed type int dword_4CAFC;
// 4CB08: using guessed type int dword_4CB08;
// 4CB40: using guessed type int dword_4CB40;
// 4CBF4: using guessed type int dword_4CBF4;

//----- (0001FC2C) --------------------------------------------------------
_DWORD *__fastcall sub_1FC2C(int a1, unsigned int a2)
{
  unsigned int v3; // r2
  const char *v5; // r0
  char *v6; // r8
  char *v7; // r5
  const char *v8; // r6
  size_t v9; // r8
  unsigned int v10; // [sp+4h] [bp-4h] BYREF

  v10 = a2;
  if ( sub_12590(dword_4CA70) )
    return sub_1F628(0, 1u, v3);
  v5 = (const char *)sub_12690((_DWORD *)dword_4CA70, &v10);
  v6 = (char *)v5;
  if ( a1 )
  {
    v8 = (const char *)dword_4CB1C;
    v7 = crypt(v5, (const char *)dword_4CB1C);
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  j_explicit_bzero(v6, v10);
  free(v6);
  if ( !a1 )
    return sub_1F628(0, 1u, v3);
  if ( !v7 )
  {
    sub_184E8(4, "User account '%s' is locked", dword_4CB18);
    return sub_1F628(0, 1u, v3);
  }
  if ( !*v8 )
  {
    sub_184E8(4, "User '%s' has blank password, rejected", dword_4CB18);
    return sub_1F628(0, 1u, v3);
  }
  v9 = strlen(v7);
  if ( v9 != strlen(v8) || sub_18BC0((int)v7, (int)v8, v9) )
  {
    sub_184E8(4, "Bad password attempt for '%s' from %s", (const char *)dword_4CB18, (const char *)dword_4CC10);
    return sub_1F628(0, 1u, v3);
  }
  sub_184E8(5, "Password auth succeeded for '%s' from %s", (const char *)dword_4CB18, (const char *)dword_4CC10);
  return (_DWORD *)sub_1F75C();
}
// 1FC50: variable 'v3' is possibly undefined
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);
// 4CA70: using guessed type int dword_4CA70;
// 4CB18: using guessed type int dword_4CB18;
// 4CB1C: using guessed type int dword_4CB1C;
// 4CC10: using guessed type int dword_4CC10;

//----- (0001FD5C) --------------------------------------------------------
int __fastcall sub_1FD5C(const char *a1)
{
  int result; // r0
  bool v3; // zf
  int v4; // r3
  char v5; // [sp+10h] [bp-58h]
  int v6; // [sp+18h] [bp-50h]

  result = sub_34FAC();
  if ( result )
    return -1;
  v3 = dword_4CB08 == v6;
  if ( dword_4CB08 != v6 )
    v3 = v6 == 0;
  v4 = !v3;
  if ( (v5 & 0x12) != 0 )
    v4 = 1;
  if ( v4 )
  {
    if ( !dword_4CB00 )
    {
      dword_4CB00 = 1;
      sub_184E8(6, "%s must be owned by user or root, and not writable by others", a1);
    }
    return -1;
  }
  return result;
}
// 1FD84: variable 'v6' is possibly undefined
// 1FD98: variable 'v5' is possibly undefined
// 4CB00: using guessed type int dword_4CB00;
// 4CB08: using guessed type int dword_4CB08;

//----- (0001FDE0) --------------------------------------------------------
void __fastcall sub_1FDE0(int a1)
{
  int v2; // r4
  char *v3; // r6
  unsigned int v4; // r10
  int v5; // r0
  unsigned int v6; // r2
  _DWORD *v7; // r7
  size_t v8; // r7
  const void *v9; // r11
  char *v10; // r9
  int v11; // r5
  char *v12; // r5
  size_t v13; // r0
  size_t v14; // r9
  size_t v15; // r4
  __uid_t v16; // r5
  __gid_t v17; // r4
  _DWORD *v18; // r4
  unsigned int v19; // r2
  const char *v20; // r0
  _DWORD *v21; // r8
  unsigned int v22; // r1
  int i; // r5
  int v24; // r0
  int v25; // r0
  int v26; // r3
  int v27; // r0
  bool v28; // zf
  int v29; // r8
  unsigned int v30; // r5
  int v31; // r0
  unsigned __int8 v32; // r3
  int v33; // r0
  bool v34; // zf
  const char *v35; // r0
  int v36; // r0
  unsigned int v37; // r5
  unsigned int v38; // r2
  unsigned int v39; // r0
  unsigned int v40; // r5
  _DWORD *v41; // r8
  const void *v42; // r0
  char *v43; // r5
  unsigned int v44; // r2
  FILE *stream; // [sp+8h] [bp-24h]
  int v46; // [sp+Ch] [bp-20h]
  size_t v47; // [sp+10h] [bp-1Ch]
  _BOOL4 v48; // [sp+14h] [bp-18h]
  unsigned int v49; // [sp+18h] [bp-14h]
  const void *v50; // [sp+18h] [bp-14h]
  unsigned __int8 v51; // [sp+1Ch] [bp-10h]
  size_t v52; // [sp+20h] [bp-Ch] BYREF
  int v53; // [sp+24h] [bp-8h] BYREF

  v2 = -1;
  v53 = -1;
  v48 = sub_12590(dword_4CA70);
  v3 = (char *)sub_12690((_DWORD *)dword_4CA70, &v52);
  v4 = sub_12664((_DWORD *)dword_4CA70);
  v5 = sub_125E4((_DWORD *)dword_4CA70, v4);
  if ( !a1 )
  {
LABEL_2:
    sub_1F628(0, 0, v6);
    goto LABEL_3;
  }
  v8 = v52;
  v9 = (const void *)v5;
  if ( sub_12CAC(v3, v52, (const char **)&off_4C2E0) == -1 )
  {
    sub_184E8(
      4,
      "Pubkey auth attempt with unknown algo for '%s' from %s",
      (const char *)dword_4CB18,
      (const char *)dword_4CC10);
LABEL_9:
    v10 = 0;
LABEL_10:
    v11 = -1;
    goto LABEL_74;
  }
  v12 = (char *)dword_4CB10;
  if ( dword_4CB10 )
  {
    v13 = strlen((const char *)dword_4CB10);
    v14 = v13;
    if ( v13 )
    {
      v12 = (char *)sub_18718(v13 + 22);
      strncpy(v12, (const char *)dword_4CB10, v14 + 1);
      if ( !sub_1FD5C(v12) )
      {
        strcat(v12, "/.ssh");
        if ( !sub_1FD5C(v12) )
        {
          strcat(v12, "/authorized_keys");
          v2 = -(sub_1FD5C(v12) != 0);
        }
      }
    }
    else
    {
      v12 = 0;
    }
  }
  free(v12);
  if ( v2 == -1 )
    goto LABEL_9;
  v15 = strlen((const char *)dword_4CB10) + 22;
  v10 = (char *)sub_18718(v15);
  snprintf(v10, v15, "%s/.ssh/authorized_keys", (const char *)dword_4CB10);
  v16 = getuid();
  v17 = getgid();
  if ( setegid(dword_4CB0C) < 0 || seteuid(dword_4CB08) < 0 )
    sub_184AC("Failed to set euid");
  stream = (FILE *)fopen64(v10, "r");
  if ( seteuid(v16) < 0 || setegid(v17) < 0 )
    sub_184AC("Failed to revert euid");
  if ( !stream )
    goto LABEL_10;
  v11 = -1;
  v18 = sub_12344(0x1068u);
  v46 = 0;
  v47 = v8 + 3;
  while ( sub_1851C(v18, stream) != -1 )
  {
    v19 = v18[1];
    ++v46;
    if ( v19 - 10 > 0x105E || v19 < v47 + v18[2] )
      goto LABEL_59;
    v20 = (const char *)sub_125E4(v18, v8);
    v21 = (_DWORD *)strncmp(v20, v3, v8);
    if ( v21 )
    {
      while ( v18[2] < v18[1] )
      {
        v27 = sub_12560((int)v18);
        v28 = v27 == 9;
        if ( v27 != 9 )
          v28 = v27 == 32;
        if ( !v28 )
        {
          if ( v27 == 35 )
            goto LABEL_59;
          sub_1250C((int)v18, -1);
          break;
        }
      }
      v29 = 0;
      v30 = 0;
      v31 = sub_125E4(v18, 1u);
      v32 = 0;
      v50 = (const void *)v31;
      while ( v18[2] < v18[1] )
      {
        v51 = v32;
        v33 = sub_12560((int)v18);
        if ( !v29 )
        {
          v34 = v33 == 9;
          if ( v33 != 9 )
            v34 = v33 == 32;
          if ( v34 )
            break;
        }
        ++v30;
        if ( v33 == 92 )
          v32 = (v51 ^ 1) & 1;
        else
          v32 = 0;
        if ( v33 == 34 )
          v36 = (v32 ^ 1) & 1;
        else
          v36 = 0;
        if ( v36 )
          v29 ^= 1u;
      }
      v21 = sub_12344(v30);
      sub_127C4(v21, v50, v30);
      if ( v47 + v18[2] > v18[1] )
        goto LABEL_57;
      v35 = (const char *)sub_125E4(v18, v8);
      if ( strncmp(v35, v3, v8) )
        goto LABEL_57;
    }
    sub_1250C((int)v18, v8);
    if ( sub_12560((int)v18) == 32 )
    {
      v22 = v18[2];
      for ( i = 0; v18[2] < v18[1]; ++i )
      {
        v49 = v22;
        v24 = sub_12560((int)v18);
        v22 = v49;
        if ( v24 == 32 )
          break;
      }
      sub_124A0((int)v18, v22);
      sub_12430(v18, i + v18[2]);
      v25 = sub_1EC44(v9, v4, v3, v8, v18, 0);
      v26 = (int)v21;
      v11 = v25;
      if ( v21 )
        v26 = 1;
      if ( v25 )
        v26 = 0;
      if ( v26 )
      {
        v11 = sub_20604(v21, v46, v10);
      }
      else if ( !v21 )
      {
        goto LABEL_71;
      }
LABEL_41:
      j_free(v21);
LABEL_71:
      if ( !v11 )
        break;
    }
    else
    {
LABEL_57:
      if ( v21 )
      {
        v11 = -1;
        goto LABEL_41;
      }
LABEL_59:
      v11 = -1;
    }
  }
  fclose(stream);
  if ( v18 )
    j_free(v18);
LABEL_74:
  free(v10);
  if ( v11 == -1 )
    goto LABEL_2;
  if ( v48 )
  {
    v7 = sub_1E644();
    v53 = 80;
    if ( sub_1E74C((_DWORD *)dword_4CA70, (int)v7, &v53) == -1 )
    {
      sub_1F628(0, 1u, v38);
    }
    else
    {
      v39 = *(_DWORD *)(dword_4CA70 + 8);
      if ( dword_4CA74 > v39 )
        _assert_fail("ses.payload_beginning <= ses.payload->pos", "svr-authpubkey.c", 0x8Au, "svr_auth_pubkey");
      v40 = v39 - dword_4CA74;
      v41 = sub_12344(v39 + *(_DWORD *)(dword_4CAC4 + 4) + 4);
      sub_12824(v41, dword_4CAC4);
      sub_124A0(dword_4CA70, dword_4CA74);
      v42 = (const void *)sub_125E4((_DWORD *)dword_4CA70, v40);
      sub_127C4(v41, v42, v40);
      sub_1250C(dword_4CA70, v40);
      sub_124A0((int)v41, 0);
      v43 = (char *)sub_1EAE0(v9, v4);
      if ( sub_1EB84((_DWORD *)dword_4CA70, (int)v7, v41) )
      {
        sub_184E8(
          4,
          "Pubkey auth bad signature for '%s' with key %s from %s",
          (const char *)dword_4CB18,
          v43,
          (const char *)dword_4CC10);
        sub_1F628(0, 1u, v44);
      }
      else
      {
        sub_184E8(
          5,
          "Pubkey auth succeeded for '%s' with key %s from %s",
          (const char *)dword_4CB18,
          v43,
          (const char *)dword_4CC10);
        sub_1F75C();
      }
      free(v43);
      if ( v41 )
        j_free(v41);
    }
    if ( v3 )
LABEL_6:
      free(v3);
    if ( v7 )
      sub_1EA60((int)v7);
  }
  else
  {
    v37 = v52;
    sub_125A4(dword_4CA58, 60);
    sub_127F8((_DWORD *)dword_4CA58, v3, v37);
    sub_127F8((_DWORD *)dword_4CA58, v9, v4);
    sub_1D894();
LABEL_3:
    if ( v3 )
    {
      v7 = 0;
      goto LABEL_6;
    }
  }
}
// 1FE3C: variable 'v6' is possibly undefined
// 202F4: variable 'v38' is possibly undefined
// 2041C: variable 'v44' is possibly undefined
// 11EA4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 1EAE0: using guessed type int __fastcall sub_1EAE0(_DWORD, _DWORD);
// 4C2E0: using guessed type char *off_4C2E0;
// 4CA58: using guessed type int dword_4CA58;
// 4CA70: using guessed type int dword_4CA70;
// 4CA74: using guessed type int dword_4CA74;
// 4CAC4: using guessed type int dword_4CAC4;
// 4CB08: using guessed type int dword_4CB08;
// 4CB0C: using guessed type int dword_4CB0C;
// 4CB10: using guessed type int dword_4CB10;
// 4CB18: using guessed type int dword_4CB18;
// 4CC10: using guessed type int dword_4CC10;

//----- (00020460) --------------------------------------------------------
int __fastcall sub_20460(_DWORD *a1, char *s)
{
  size_t v4; // r0
  int v5; // r6
  size_t v7; // r5
  const char *v8; // r0

  v4 = strlen(s);
  if ( a1[1] - a1[2] < v4 )
    return -1;
  v7 = v4;
  v8 = (const char *)sub_125E4(a1, v4);
  v5 = strncasecmp(v8, s, v7);
  if ( v5 )
    return -1;
  sub_1250C((int)a1, v7);
  return v5;
}

//----- (000204C4) --------------------------------------------------------
bool sub_204C4()
{
  return !dword_4CB20 || *(_DWORD *)(dword_4CB20 + 4) == 0;
}
// 4CB20: using guessed type int dword_4CB20;

//----- (000204E8) --------------------------------------------------------
bool sub_204E8()
{
  return !dword_4CB20 || *(_DWORD *)dword_4CB20 == 0;
}
// 4CB20: using guessed type int dword_4CB20;

//----- (0002050C) --------------------------------------------------------
bool sub_2050C()
{
  return !dword_4CB20 || *(_DWORD *)(dword_4CB20 + 8) == 0;
}
// 4CB20: using guessed type int dword_4CB20;

//----- (00020530) --------------------------------------------------------
bool sub_20530()
{
  return !dword_4CB20 || *(_DWORD *)(dword_4CB20 + 12) == 0;
}
// 4CB20: using guessed type int dword_4CB20;

//----- (00020554) --------------------------------------------------------
char *__fastcall sub_20554(char *result)
{
  _DWORD *v1; // r4

  if ( dword_4CB20 && *(_DWORD *)(dword_4CB20 + 16) )
  {
    v1 = result;
    if ( *(_DWORD *)result )
    {
      *((_DWORD *)result + 21) = *(_DWORD *)result;
      *(_DWORD *)result = 0;
    }
    else
    {
      *((_DWORD *)result + 21) = sub_1886C("");
    }
    result = sub_1886C(*(const char **)(dword_4CB20 + 16));
    *v1 = result;
  }
  return result;
}
// 4CB20: using guessed type int dword_4CB20;

//----- (000205BC) --------------------------------------------------------
void sub_205BC()
{
  void *v0; // r0

  if ( dword_4CB20 )
  {
    v0 = *(void **)(dword_4CB20 + 16);
    if ( v0 )
    {
      free(v0);
      *(_DWORD *)(dword_4CB20 + 16) = 0;
    }
    free((void *)dword_4CB20);
    dword_4CB20 = 0;
  }
}
// 4CB20: using guessed type int dword_4CB20;

//----- (00020604) --------------------------------------------------------
int __fastcall sub_20604(_DWORD *a1, int a2, const char *a3)
{
  int v6; // r0
  unsigned __int8 v7; // r7
  const void *v8; // r6
  int v9; // r0
  size_t v11; // r7
  int v13; // [sp+4h] [bp-8h]

  dword_4CB20 = (int)sub_18718(0x14u);
  sub_124A0((int)a1, 0);
  do
  {
    if ( a1[2] >= a1[1] )
      return 0;
    if ( sub_20460(a1, "no-port-forwarding") )
    {
      if ( sub_20460(a1, "no-agent-forwarding") )
      {
        if ( sub_20460(a1, "no-X11-forwarding") )
        {
          if ( sub_20460(a1, "no-pty") )
          {
            v6 = sub_20460(a1, "command=\"");
            v7 = v6;
            if ( !v6 )
            {
              v8 = (const void *)sub_125E4(a1, 0);
              while ( 1 )
              {
                if ( a1[2] >= a1[1] )
                {
                  sub_184E8(4, "Badly formatted command= authorized_keys option");
                  goto LABEL_19;
                }
                v9 = sub_12560((int)a1);
                if ( v9 == 34 && (v7 ^ 1) & 1 )
                  break;
                if ( v9 == 92 )
                  v7 = (v7 ^ 1) & 1;
                else
                  v7 = 0;
              }
              v11 = sub_125E4(a1, 0) - (_DWORD)v8;
              v13 = dword_4CB20;
              *(_DWORD *)(v13 + 16) = sub_18718(v11);
              memcpy(*(void **)(dword_4CB20 + 16), v8, v11 - 1);
              *(_BYTE *)(*(_DWORD *)(dword_4CB20 + 16) + v11 - 1) = 0;
              sub_184E8(4, "Forced command '%s'", *(const char **)(dword_4CB20 + 16));
            }
          }
          else
          {
            sub_184E8(4, "Pty allocation disabled.");
            *(_DWORD *)(dword_4CB20 + 12) = 1;
          }
        }
        else
        {
          sub_184E8(4, "X11 forwarding disabled.");
          *(_DWORD *)(dword_4CB20 + 8) = 1;
        }
      }
      else
      {
        sub_184E8(4, "Agent forwarding disabled.");
        *(_DWORD *)(dword_4CB20 + 4) = 1;
      }
    }
    else
    {
      sub_184E8(4, "Port forwarding disabled.");
      *(_DWORD *)dword_4CB20 = 1;
    }
  }
  while ( a1[2] >= a1[1] || sub_12560((int)a1) == 44 );
LABEL_19:
  sub_205BC();
  sub_184E8(4, "Bad public key options at %s:%d", a3, a2);
  return -1;
}
// 4CB20: using guessed type int dword_4CB20;

//----- (00020868) --------------------------------------------------------
bool __fastcall sub_20868(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 28) + 24) != -1;
}

//----- (0002087C) --------------------------------------------------------
void *__fastcall sub_2087C(int a1, int a2)
{
  int v4; // r3
  void *result; // r0
  int v6; // r5
  _DWORD *v7; // r2

  v4 = 0;
  result = (void *)dword_4CBF8;
  while ( 1 )
  {
    v6 = 8 * v4;
    if ( dword_4CBFC == v4 )
      break;
    if ( *(_DWORD *)(dword_4CBF8 + 8 * v4) == -1 )
      goto LABEL_4;
    ++v4;
  }
  result = sub_18888((void *)dword_4CBF8, 8 * (dword_4CBFC + 1));
  dword_4CBF8 = (int)result;
  ++dword_4CBFC;
LABEL_4:
  v7 = (_DWORD *)(dword_4CBF8 + v6);
  *v7 = a2;
  v7[1] = a1;
  return result;
}
// 4CBF8: using guessed type int dword_4CBF8;
// 4CBFC: using guessed type int dword_4CBFC;

//----- (000208E8) --------------------------------------------------------
int sub_208E8()
{
  int *v0; // r4
  int v1; // r5
  int result; // r0
  struct sigaction act; // [sp+4h] [bp-8Ch] BYREF

  v0 = _errno_location();
  v1 = *v0;
  while ( write(dword_4CA8C, &byte_4CA40, 1u) != 1 && *v0 == 4 )
    ;
  act.sa_handler = (__sighandler_t)sub_208E8;
  act.sa_flags = 1;
  sigemptyset(&act.sa_mask);
  result = sigaction(17, &act, 0);
  *v0 = v1;
  return result;
}
// 208E8: using guessed type int sub_208E8();
// 4CA40: using guessed type char byte_4CA40;
// 4CA8C: using guessed type int dword_4CA8C;

//----- (00020960) --------------------------------------------------------
int __fastcall sub_20960(int *a1)
{
  unsigned int v3; // r7
  __int16 v4; // r6
  __int16 v5; // r8
  unsigned int v6; // r0

  if ( *a1 < 0 )
    return -1;
  v3 = sub_12664((_DWORD *)dword_4CA70);
  v4 = sub_12664((_DWORD *)dword_4CA70);
  v5 = sub_12664((_DWORD *)dword_4CA70);
  v6 = sub_12664((_DWORD *)dword_4CA70);
  sub_1EFCC(*a1, v4, v3, v5, v6);
  return 0;
}
// 4CA70: using guessed type int dword_4CA70;

//----- (000209D0) --------------------------------------------------------
int __fastcall sub_209D0(int a1)
{
  _DWORD *v2; // r0

  if ( *(_DWORD *)(a1 + 28) )
    sub_184D4("channel->typedata == NULL", "svr-chansession.c", 244);
  v2 = sub_18718(0x58u);
  *v2 = 0;
  v2[10] = 0;
  v2[11] = 0;
  v2[1] = 0;
  v2[2] = -1;
  v2[3] = -1;
  v2[4] = 0;
  v2[5] = 0;
  v2[6] = -1;
  *(_DWORD *)(a1 + 28) = v2;
  v2[12] = 0;
  v2[14] = 0;
  v2[15] = 0;
  v2[18] = 0;
  v2[19] = 0;
  v2[20] = 0;
  *(_DWORD *)(a1 + 96) = 0;
  return 0;
}

//----- (00020A54) --------------------------------------------------------
void __fastcall sub_20A54(int a1)
{
  int v1; // r4
  int v3; // r2
  const char **v4; // r3
  int v5; // r2
  const char *v6; // r0
  const char *v7; // r7
  void *v8; // r0
  char *v9; // r3
  void *v10; // r7
  int v11; // r1
  int v12; // r3
  int v13; // r0
  int v14; // r2
  size_t v15; // r0

  v1 = *(_DWORD *)(a1 + 28);
  if ( v1 )
  {
    if ( *(int *)(v1 + 24) >= 0 )
    {
      v3 = *(_DWORD *)(v1 + 32);
      if ( v3 <= 0 )
      {
        if ( v3 != -1 )
        {
          v5 = 185;
          v6 = "chansess->exit.exitsignal == -1";
          goto LABEL_7;
        }
        sub_125A4(dword_4CA58, 98);
        sub_1279C((_DWORD *)dword_4CA58, *(_DWORD *)(a1 + 4));
        sub_127F8((_DWORD *)dword_4CA58, "exit-status", 0xBu);
        sub_125A4(dword_4CA58, 0);
        sub_1279C((_DWORD *)dword_4CA58, *(_DWORD *)(v1 + 28));
LABEL_16:
        sub_1D894();
      }
      else
      {
        v4 = (const char **)&off_356B0;
        while ( 1 )
        {
          v7 = *v4;
          if ( !*v4 )
            break;
          v4 += 2;
          if ( (const char *)v3 == *(v4 - 3) )
          {
            sub_125A4(dword_4CA58, 98);
            sub_1279C((_DWORD *)dword_4CA58, *(_DWORD *)(a1 + 4));
            sub_127F8((_DWORD *)dword_4CA58, "exit-signal", 0xBu);
            sub_125A4(dword_4CA58, 0);
            v15 = strlen(v7);
            sub_127F8((_DWORD *)dword_4CA58, v7, v15);
            sub_125A4(dword_4CA58, *(_BYTE *)(v1 + 36));
            sub_127F8((_DWORD *)dword_4CA58, "", 0);
            sub_127F8((_DWORD *)dword_4CA58, "", 0);
            goto LABEL_16;
          }
        }
      }
    }
    free(*(void **)v1);
    v8 = *(void **)(v1 + 20);
    *(_DWORD *)v1 = 0;
    free(v8);
    *(_DWORD *)(v1 + 20) = 0;
    free(*(void **)(v1 + 84));
    v9 = *(char **)(v1 + 16);
    *(_DWORD *)(v1 + 84) = 0;
    if ( v9 )
    {
      v10 = sub_1C2EC(*(_DWORD *)(v1 + 4), (char *)dword_4CAF0, (char *)dword_4CC14, v9);
      sub_1C5BC((int)v10);
      j_free_0(v10);
      sub_1EDEC(*(const char **)(v1 + 16));
      free(*(void **)(v1 + 16));
      *(_DWORD *)(v1 + 16) = 0;
    }
    sub_238D8(v1);
    sub_1F3AC(v1);
    v11 = dword_4CBF8;
    v12 = 0;
    v13 = dword_4CBFC;
    v14 = dword_4CBF8;
    while ( v13 != v12 )
    {
      if ( *(_DWORD *)(v14 + 4) == v1 )
      {
        if ( *(int *)(v11 + 8 * v12) <= 0 )
        {
          v5 = 334;
          v6 = "svr_ses.childpids[i].pid > 0";
LABEL_7:
          sub_184D4(v6, "svr-chansession.c", v5);
        }
        *(_DWORD *)(v11 + 8 * v12) = -1;
        *(_DWORD *)(v14 + 4) = 0;
      }
      ++v12;
      v14 += 8;
    }
    free((void *)v1);
  }
}
// 356B0: using guessed type char *off_356B0;
// 4CA58: using guessed type int dword_4CA58;
// 4CAF0: using guessed type int dword_4CAF0;
// 4CBF8: using guessed type int dword_4CBF8;
// 4CBFC: using guessed type int dword_4CBFC;
// 4CC14: using guessed type int dword_4CC14;

//----- (00020C8C) --------------------------------------------------------
__pid_t __fastcall sub_20C8C(__pid_t result, int a2, int a3)
{
  int i; // r3
  int v4; // r3
  int *v5; // r3
  __int16 v6; // r2
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int stat_loc[5]; // [sp+4h] [bp-14h] BYREF

  if ( dword_4CA90 )
  {
    stat_loc[0] = a2;
    stat_loc[1] = a3;
    while ( 1 )
    {
      result = waitpid(-1, stat_loc, 1);
      if ( result <= 0 )
        break;
      for ( i = 0; ; ++i )
      {
        if ( dword_4CBFC == i )
        {
          v5 = &dword_4CC00;
          goto LABEL_9;
        }
        if ( *(_DWORD *)(dword_4CBF8 + 8 * i) == result )
          break;
      }
      v4 = *(_DWORD *)(dword_4CBF8 + 8 * i + 4);
      if ( v4 == -24 )
        v5 = &dword_4CC00;
      else
        v5 = (int *)(v4 + 24);
LABEL_9:
      v6 = stat_loc[0];
      *v5 = result;
      v7 = v6 & 0x7F;
      if ( (v6 & 0x7F) == 0 )
        v5[1] = HIBYTE(v6);
      v8 = (v7 + 1) << 24 >> 25;
      if ( v8 <= 0 )
        v9 = -1;
      else
        v9 = v6 & 0x80;
      if ( v8 <= 0 )
      {
        v5[2] = v9;
      }
      else
      {
        v5[2] = v7;
        v5[3] = v9;
      }
    }
  }
  return result;
}
// 4CA90: using guessed type int dword_4CA90;
// 4CBF8: using guessed type int dword_4CBF8;
// 4CBFC: using guessed type int dword_4CBFC;
// 4CC00: using guessed type int dword_4CC00;

//----- (00020D50) --------------------------------------------------------
int sub_20D50()
{
  _DWORD *v0; // r0
  int result; // r0
  struct sigaction act; // [sp+4h] [bp-8Ch] BYREF

  v0 = sub_18718(8u);
  dword_4CBF8 = (int)v0;
  *v0 = -1;
  v0[1] = 0;
  dword_4CBFC = 1;
  dword_4CC00 = -1;
  act.sa_flags = 1;
  act.sa_handler = (__sighandler_t)sub_208E8;
  sigemptyset(&act.sa_mask);
  result = sigaction(17, &act, 0);
  if ( result < 0 )
    sub_184AC("signal() error");
  return result;
}
// 208E8: using guessed type int sub_208E8();
// 4CBF8: using guessed type int dword_4CBF8;
// 4CBFC: using guessed type int dword_4CBFC;
// 4CC00: using guessed type int dword_4CC00;

//----- (00020DC8) --------------------------------------------------------
int __fastcall sub_20DC8(const char *a1, const char *a2)
{
  size_t v4; // r4
  size_t v5; // r0
  size_t v6; // r6
  size_t v7; // r8
  char *v8; // r5
  int result; // r0

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = v4 + v5;
  v7 = v5;
  v8 = (char *)sub_18718(v4 + v5 + 2);
  memcpy(v8, a1, v4);
  v8[v4] = 61;
  memcpy(&v8[v4 + 1], a2, v7);
  v8[v6 + 1] = 0;
  result = putenv(v8);
  if ( result < 0 )
    sub_184AC("environ error");
  return result;
}

//----- (00020E48) --------------------------------------------------------
void __fastcall __noreturn sub_20E48(int a1)
{
  const char *v2; // r0
  const char *v3; // r1
  const char *v4; // r1
  const char *v5; // r1
  const char *v6; // r1
  const char *v7; // r1
  const char *v8; // r0
  char *v9; // r0
  int v10; // r3

  sub_1EA60(dword_4CBD0);
  dword_4CBD0 = 0;
  sub_18158();
  clearenv();
  if ( getuid() )
  {
    if ( getuid() != dword_4CB08 )
      sub_184AC("Couldn't\tchange user as non-root");
  }
  else
  {
    if ( setgid(dword_4CB0C) < 0 || initgroups((const char *)dword_4CB18, dword_4CB0C) < 0 )
      sub_184AC("Error changing user group");
    if ( setuid(dword_4CB08) < 0 )
      sub_184AC("Error changing user");
  }
  sub_20DC8("USER", (const char *)dword_4CB18);
  sub_20DC8("LOGNAME", (const char *)dword_4CB18);
  sub_20DC8("HOME", (const char *)dword_4CB10);
  v2 = sub_16064();
  sub_20DC8("SHELL", v2);
  sub_20DC8("PATH", "/bin:/sbin:/usr/bin:/usr/sbin");
  v3 = *(const char **)(a1 + 20);
  if ( v3 )
    sub_20DC8("TERM", v3);
  v4 = *(const char **)(a1 + 16);
  if ( v4 )
    sub_20DC8("SSH_TTY", v4);
  v5 = *(const char **)(a1 + 40);
  if ( v5 )
    sub_20DC8("SSH_CONNECTION", v5);
  v6 = *(const char **)(a1 + 44);
  if ( v6 )
    sub_20DC8("SSH_CLIENT", v6);
  v7 = *(const char **)(a1 + 84);
  if ( v7 )
    sub_20DC8("SSH_ORIGINAL_COMMAND", v7);
  if ( chdir((const char *)dword_4CB10) < 0 )
    sub_184AC("Error changing directory");
  sub_237E8(a1);
  sub_1F334(a1);
  v8 = sub_16064();
  v9 = sub_1886C(v8);
  sub_18744(*(char **)a1, dword_4CA54, v9, v10);
  sub_184AC("Child failed");
}
// 20FB0: variable 'v10' is possibly undefined
// 4CA54: using guessed type int dword_4CA54;
// 4CB08: using guessed type int dword_4CB08;
// 4CB0C: using guessed type int dword_4CB0C;
// 4CB10: using guessed type int dword_4CB10;
// 4CB18: using guessed type int dword_4CB18;
// 4CBD0: using guessed type int dword_4CBD0;

//----- (00021004) --------------------------------------------------------
int __fastcall sub_21004(int *a1, int a2, int a3, int a4)
{
  char *v4; // r9
  void *v8; // r0
  size_t v9; // r2
  void *v10; // r5
  int v11; // r5
  char *v13; // r0
  size_t v14; // r7
  size_t v15; // r7
  char *v16; // r0
  const char *v17; // r3
  size_t v18; // r7
  char *v19; // r0
  const char *v20; // r3
  int v21; // r3
  int v22; // r1
  int i; // r3
  _DWORD *v24; // lr
  int v25; // r1
  int v26; // r2
  int v27; // r3
  _DWORD *v28; // lr
  __pid_t v29; // r0
  int v30; // r7
  void *v31; // r5
  int v32; // r0
  int v33; // r3
  size_t n; // [sp+14h] [bp-18h] BYREF
  char *s; // [sp+18h] [bp-14h] BYREF
  void *ptr; // [sp+1Ch] [bp-10h] BYREF
  char *v37; // [sp+20h] [bp-Ch] BYREF
  void *v38; // [sp+24h] [bp-8h] BYREF

  v4 = *(char **)a2;
  n = 0;
  if ( v4 )
    return -1;
  if ( a3 )
  {
    v8 = sub_12690((_DWORD *)dword_4CA70, &n);
    v9 = n;
    v10 = v8;
    *(_DWORD *)a2 = v8;
    if ( v9 > 0x2328 )
    {
      free(v8);
      *(_DWORD *)a2 = 0;
      return -1;
    }
    if ( a4 )
    {
      if ( v9 != 4 || strncmp((const char *)v8, "sftp", 4u) )
      {
        free(v10);
        *(_DWORD *)a2 = 0;
        return -1;
      }
      free(v10);
      *(_DWORD *)a2 = 0;
      *(_DWORD *)a2 = sub_1886C("/usr/libexec/sftp-server");
    }
  }
  if ( dword_4CBF0 )
  {
    v13 = *(char **)a2;
    if ( !*(_DWORD *)a2 )
      v13 = sub_1886C("");
    *(_DWORD *)(a2 + 84) = v13;
    *(_DWORD *)a2 = sub_1886C((const char *)dword_4CBF0);
  }
  else
  {
    sub_20554((char *)a2);
  }
  v11 = 0;
  sub_1D25C((char *)dword_4CA48, &s, (char **)&ptr, (unsigned int)&v37, (char **)&v38, 0);
  v14 = strlen(s);
  v15 = v14 + strlen(v37) + 20;
  v16 = (char *)sub_18718(v15);
  v17 = (const char *)ptr;
  *(_DWORD *)(a2 + 40) = v16;
  snprintf(v16, v15, "%s %s %s %s", v37, (const char *)v38, s, v17);
  v18 = strlen(v37) + 20;
  v19 = (char *)sub_18718(v18);
  v20 = (const char *)ptr;
  *(_DWORD *)(a2 + 44) = v19;
  snprintf(v19, v18, "%s %s %s", v37, (const char *)v38, v20);
  free(s);
  free(ptr);
  free(v37);
  free(v38);
  if ( *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a2 + 8) != -1 && *(_DWORD *)(a2 + 16) )
    {
      v29 = fork();
      v30 = v29;
      if ( v29 >= 0 )
      {
        if ( v29 )
        {
          *(_DWORD *)(a2 + 4) = v29;
          sub_2087C(a2, v29);
          close(*(_DWORD *)(a2 + 12));
          v32 = *(_DWORD *)(a2 + 8);
          v33 = dword_4CA54;
          a1[8] = v32;
          a1[9] = v32;
          if ( v33 < v32 )
            dword_4CA54 = v32;
          else
            dword_4CA54 = v33;
          sub_188B0(v32);
          goto LABEL_30;
        }
        if ( signal(17, 0) == (__sighandler_t)-1 )
          sub_184AC("signal() error");
        close(*(_DWORD *)(a2 + 8));
        sub_1EE78((int *)(a2 + 12), *(const char **)(a2 + 16));
        if ( dup2(*(_DWORD *)(a2 + 12), v30) >= 0
          && dup2(*(_DWORD *)(a2 + 12), 2) >= 0
          && dup2(*(_DWORD *)(a2 + 12), 1) >= 0 )
        {
          close(*(_DWORD *)(a2 + 12));
          v31 = sub_1C2EC(*(_DWORD *)(a2 + 4), (char *)dword_4CAF0, (char *)dword_4CC14, *(char **)(a2 + 16));
          sub_1C5B0((int)v31);
          j_free_0(v31);
          sub_20E48(a2);
        }
      }
    }
    else
    {
      sub_184E8(4, "No pty was allocated, couldn't execute");
    }
  }
  else if ( sub_188E4((void (__fastcall *)(int))sub_20E48, a2, a1 + 8, a1 + 9, a1 + 10, (int *)(a2 + 4)) != -1 )
  {
    v21 = a1[8];
    v22 = *(_DWORD *)(a2 + 4);
    if ( v21 < a1[9] )
      v21 = a1[9];
    if ( v21 < dword_4CA54 )
      v21 = dword_4CA54;
    if ( v21 < a1[10] )
      dword_4CA54 = a1[10];
    else
      dword_4CA54 = v21;
    sub_2087C(a2, v22);
    if ( dword_4CC00 != -1 )
    {
      for ( i = 0; i != dword_4CBFC; ++i )
      {
        v24 = (_DWORD *)(dword_4CBF8 + 8 * i);
        if ( dword_4CC00 == *v24 )
        {
          v25 = *(_DWORD *)algn_4CC04;
          v26 = *(_DWORD *)&algn_4CC04[4];
          v27 = *(_DWORD *)&algn_4CC04[8];
          v28 = (_DWORD *)(v24[1] + 24);
          *v28 = dword_4CC00;
          v28[1] = v25;
          v28[2] = v26;
          v28[3] = v27;
          dword_4CC00 = -1;
          break;
        }
      }
    }
    v11 = 0;
    a1[24] = 2;
    sub_1617C();
    goto LABEL_30;
  }
  v11 = -1;
LABEL_30:
  free(*(void **)(a2 + 40));
  *(_DWORD *)(a2 + 40) = 0;
  free(*(void **)(a2 + 44));
  *(_DWORD *)(a2 + 44) = 0;
  if ( v11 != -1 )
    return 0;
  free(*(void **)a2);
  *(_DWORD *)a2 = 0;
  return v11;
}
// 4CA48: using guessed type int dword_4CA48;
// 4CA54: using guessed type int dword_4CA54;
// 4CA70: using guessed type int dword_4CA70;
// 4CAF0: using guessed type int dword_4CAF0;
// 4CBF0: using guessed type int dword_4CBF0;
// 4CBF8: using guessed type int dword_4CBF8;
// 4CBFC: using guessed type int dword_4CBFC;
// 4CC00: using guessed type int dword_4CC00;
// 4CC04: using guessed type _BYTE[12];
// 4CC14: using guessed type int dword_4CC14;

//----- (00021430) --------------------------------------------------------
void __fastcall sub_21430(int *a1)
{
  char *v2; // r5
  _BOOL4 v3; // r11
  int v4; // r4
  int v5; // r0
  int v6; // r6
  int v7; // r3
  int v8; // r2
  void *v9; // r0
  unsigned int v10; // r3
  char *v11; // r0
  struct passwd *v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r7
  unsigned int v15; // r0
  int v16; // r2
  tcflag_t v17; // r3
  int v18; // r2
  tcflag_t v19; // r3
  int v20; // r2
  tcflag_t v21; // r3
  int v22; // r2
  tcflag_t v23; // r3
  int v24; // r7
  int v25; // r6
  char *v26; // r9
  const char *v27; // r0
  unsigned int v28; // [sp+0h] [bp-8Ch] BYREF
  unsigned int v29; // [sp+4h] [bp-88h] BYREF
  struct termios termios_p; // [sp+8h] [bp-84h] BYREF
  char v31[68]; // [sp+44h] [bp-48h] BYREF

  v2 = (char *)sub_12690((_DWORD *)dword_4CA70, &v28);
  v3 = sub_12590(dword_4CA70);
  if ( v28 > 0x40 )
    goto LABEL_67;
  v4 = a1[7];
  if ( !v4 )
    sub_184D4("chansess != NULL", "svr-chansession.c", 368);
  if ( !strcmp(v2, "window-change") )
  {
    v5 = sub_20960((int *)(v4 + 8));
LABEL_6:
    v6 = v5;
    goto LABEL_12;
  }
  v7 = strcmp(v2, "shell");
  if ( !v7 )
  {
    v8 = 0;
LABEL_52:
    v5 = sub_21004(a1, v4, v8, v7);
    goto LABEL_6;
  }
  v6 = strcmp(v2, "pty-req");
  if ( v6 )
  {
    v7 = strcmp(v2, "exec");
    if ( !v7 )
    {
LABEL_51:
      v8 = 1;
      goto LABEL_52;
    }
    if ( !strcmp(v2, "subsystem") )
    {
      v7 = 1;
      goto LABEL_51;
    }
    if ( !strcmp(v2, "x11-req") )
    {
      v5 = sub_23610(v4);
      goto LABEL_6;
    }
    if ( !strcmp(v2, "auth-agent-req@openssh.com") )
    {
      v5 = sub_1F4D4(v4);
      goto LABEL_6;
    }
    v24 = strcmp(v2, "signal");
    if ( !v24 && *(_DWORD *)(v4 + 4) )
    {
      v25 = 0;
      v26 = (char *)sub_12690((_DWORD *)dword_4CA70, 0);
      while ( 1 )
      {
        v27 = (const char *)*((_DWORD *)&unk_356AC + 2 * v25 + 1);
        if ( !v27 )
          break;
        if ( !strcmp(v27, v26) )
        {
          v24 = *((_DWORD *)&unk_356AC + 2 * v25);
          break;
        }
        ++v25;
      }
      free(v26);
      if ( v24 )
      {
        if ( kill(*(_DWORD *)(v4 + 4), v24) >= 0 )
        {
          if ( !v3 )
            goto LABEL_15;
          goto LABEL_14;
        }
      }
    }
LABEL_67:
    if ( !v3 )
      goto LABEL_15;
    goto LABEL_68;
  }
  if ( !sub_20530() )
    goto LABEL_11;
  v9 = sub_12690((_DWORD *)dword_4CA70, &v29);
  v10 = v29;
  *(_DWORD *)(v4 + 20) = v9;
  if ( v10 > 0xC8 )
    goto LABEL_11;
  if ( *(_DWORD *)(v4 + 8) != -1 )
    sub_184AC("Multiple pty requests");
  if ( sub_1ED64((int *)(v4 + 8), (int *)(v4 + 12), (int)v31, 64) )
  {
    v11 = sub_1886C(v31);
    *(_DWORD *)(v4 + 16) = v11;
    if ( !v11 )
      sub_184AC("Out of memory");
    v12 = getpwnam((const char *)dword_4CB18);
    if ( !v12 )
      sub_184AC("getpwnam failed after succeeding previously");
    sub_1EFF8((int)v12, *(const char **)(v4 + 16));
    sub_20960((int *)(v4 + 8));
    if ( tcgetattr(*(_DWORD *)(v4 + 8), &termios_p) != -1 )
    {
      v13 = sub_12664((_DWORD *)dword_4CA70);
      if ( v13 != *(_DWORD *)(dword_4CA70 + 4) - *(_DWORD *)(dword_4CA70 + 8) )
        sub_184AC("Bad term mode string");
      if ( v13 )
      {
        while ( 1 )
        {
          v14 = sub_12560(dword_4CA70);
          if ( (unsigned __int8)(v14 - 1) > 0x9Eu )
            break;
          v15 = sub_12664((_DWORD *)dword_4CA70);
          if ( v14 <= 0x5D )
          {
            switch ( *((_BYTE *)&unk_381D4 + 8 * v14 + 4) )
            {
              case 1:
                v22 = *((_DWORD *)&unk_381D4 + 2 * v14);
                if ( v15 )
                  v23 = termios_p.c_cflag | v22;
                else
                  v23 = termios_p.c_cflag & ~v22;
                termios_p.c_cflag = v23;
                break;
              case 2:
                v16 = *((_DWORD *)&unk_381D4 + 2 * v14);
                if ( v15 )
                  v17 = termios_p.c_iflag | v16;
                else
                  v17 = termios_p.c_iflag & ~v16;
                termios_p.c_iflag = v17;
                break;
              case 3:
                v18 = *((_DWORD *)&unk_381D4 + 2 * v14);
                if ( v15 )
                  v19 = termios_p.c_oflag | v18;
                else
                  v19 = termios_p.c_oflag & ~v18;
                termios_p.c_oflag = v19;
                break;
              case 4:
                v20 = *((_DWORD *)&unk_381D4 + 2 * v14);
                if ( v15 )
                  v21 = v20 | termios_p.c_lflag;
                else
                  v21 = termios_p.c_lflag & ~v20;
                termios_p.c_lflag = v21;
                break;
              case 5:
                termios_p.c_cc[*((_DWORD *)&unk_381D4 + 2 * v14)] = v15;
                break;
              default:
                continue;
            }
          }
        }
        if ( tcsetattr(*(_DWORD *)(v4 + 8), 0, &termios_p) < 0 )
          sub_184E8(6, "Error setting terminal attributes");
      }
    }
  }
  else
  {
LABEL_11:
    v6 = -1;
  }
LABEL_12:
  if ( v3 )
  {
    if ( !v6 )
    {
LABEL_14:
      sub_143A8((int)a1);
      goto LABEL_15;
    }
LABEL_68:
    sub_14310((int)a1);
  }
LABEL_15:
  free(v2);
}
// 21644: control flows out of bounds to 21648
// 4CA70: using guessed type int dword_4CA70;
// 4CB18: using guessed type int dword_4CB18;

//----- (00021B48) --------------------------------------------------------
void __fastcall handler(int a1)
{
  dword_4CB44 = 1;
}
// 4CB44: using guessed type int dword_4CB44;

//----- (00021B5C) --------------------------------------------------------
int sub_21B5C()
{
  struct sigaction act; // [sp+4h] [bp-90h] BYREF

  if ( dword_4CA34 )
    sub_18478("dropbear");
  if ( signal(2, handler) == (__sighandler_t)-1
    || signal(15, handler) == (__sighandler_t)-1
    || signal(13, (__sighandler_t)1) == (__sighandler_t)-1
    || (act.sa_handler = (__sighandler_t)sub_21C54,
        act.sa_flags = 1,
        sigemptyset(&act.sa_mask),
        sigaction(17, &act, 0) < 0)
    || signal(11, (__sighandler_t)sub_21C30) == (__sighandler_t)-1 )
  {
    sub_184AC("signal() error");
  }
  sub_1645C();
  sub_22C28();
  return sub_18158();
}
// 21C54: using guessed type int sub_21C54();
// 4CA34: using guessed type int dword_4CA34;

//----- (00021C30) --------------------------------------------------------
void __fastcall __noreturn sub_21C30(int a1)
{
  fputs("Aiee, segfault! You should probably report this as a bug to the developer\n", (FILE *)stderr);
  exit(1);
}
// 4C448: using guessed type int stderr;

//----- (00021C54) --------------------------------------------------------
int sub_21C54()
{
  int *v0; // r4
  int v1; // r5
  int result; // r0
  struct sigaction act; // [sp+4h] [bp-90h] BYREF

  v0 = _errno_location();
  v1 = *v0;
  while ( waitpid(-1, 0, 1) > 0 )
    ;
  act.sa_handler = (__sighandler_t)sub_21C54;
  act.sa_flags = 1;
  sigemptyset(&act.sa_mask);
  result = sigaction(17, &act, 0);
  if ( result < 0 )
    sub_184AC("signal() error");
  *v0 = v1;
  return result;
}
// 21C54: using guessed type int sub_21C54();

//----- (00021CCC) --------------------------------------------------------
void __noreturn sub_21CCC()
{
  int i; // r3
  const char **v1; // r6
  unsigned int v2; // r4
  unsigned int v3; // r9
  int v4; // r1
  _DWORD *v5; // r2
  bool v6; // nf
  int v7; // r12
  int v8; // r3
  int *v9; // r0
  char *v10; // r1
  int v11; // r2
  int v12; // r7
  int v13; // r3
  FILE *v14; // r6
  __pid_t v15; // r0
  int j; // r3
  int v17; // r0
  _DWORD *v18; // r2
  int v19; // r12
  int v20; // r3
  int v21; // r2
  int v22; // r12
  int k; // r0
  int v24; // r3
  int v25; // r0
  int v26; // r7
  int v27; // r0
  unsigned int m; // r10
  int v29; // r0
  int v30; // r2
  int v31; // r7
  unsigned int v32; // r2
  int v33; // r6
  unsigned int v34; // r3
  int v35; // r0
  bool v36; // cc
  unsigned int v37; // r6
  int *v38; // r0
  char *v39; // r0
  int v40; // r0
  _DWORD *v41; // r7
  void *v42; // r3
  int *v43; // r0
  char *v44; // r1
  int v45; // r0
  char *v46; // r2
  char *v47; // r3
  int v48; // [sp+Ch] [bp-2A0h]
  int v49; // [sp+Ch] [bp-2A0h]
  char *s1a; // [sp+10h] [bp-29Ch]
  char *s1; // [sp+10h] [bp-29Ch]
  unsigned int v52; // [sp+14h] [bp-298h]
  unsigned int v53; // [sp+18h] [bp-294h]
  int v54; // [sp+24h] [bp-288h] BYREF
  void *v55; // [sp+28h] [bp-284h] BYREF
  void *v56; // [sp+2Ch] [bp-280h] BYREF
  __pid_t v57; // [sp+30h] [bp-27Ch] BYREF
  socklen_t v58; // [sp+34h] [bp-278h] BYREF
  int pipedes[2]; // [sp+38h] [bp-274h] BYREF
  _DWORD v60[60]; // [sp+40h] [bp-26Ch] BYREF
  _DWORD s[30]; // [sp+130h] [bp-17Ch] BYREF
  fd_set readfds; // [sp+1A8h] [bp-104h] BYREF
  _DWORD ptr[33]; // [sp+228h] [bp-84h] BYREF

  v54 = -1;
  sub_21B5C();
  for ( i = 0; i != 30; ++i )
    v60[i + 30] = -1;
  v1 = (const char **)&dword_4CB7C;
  v2 = 0;
  v3 = 0;
  memset(s, 0, sizeof(s));
  ptr[0] = 0;
  while ( v3 < dword_4CB7C )
  {
    ++v1;
    v11 = sub_1CE9C(*v1, *(v1 - 11), (int)&v60[v2], 30 - v2, (char **)ptr, &v54);
    if ( v11 < 0 )
    {
      sub_184E8(4, "Failed listening on '%s': %s", *(v1 - 11), (const char *)ptr[0]);
      free((void *)ptr[0]);
      ptr[0] = 0;
    }
    else
    {
      v12 = 0;
      while ( v12 != v11 )
      {
        v13 = v60[v2 + v12];
        s1a = (char *)v11;
        ++v12;
        v48 = v13;
        sub_1CD30(v13, 11);
        sub_1CD04(v48);
        v11 = (int)s1a;
      }
      v2 += v12;
    }
    ++v3;
  }
  if ( !v2 )
    sub_184AC("No listening ports available.");
  v4 = 0;
  while ( 1 )
  {
    v8 = v60[v4++];
    v5 = &ptr[v8 / 32 + 32];
    v6 = -v8 < 0;
    v7 = -v8 & 0x1F;
    LOBYTE(v8) = v8 & 0x1F;
    if ( !v6 )
      v8 = -v7;
    *(v5 - 64) |= 1 << v8;
    if ( v4 == v2 )
    {
      if ( dword_4CB50 && daemon(0, dword_4CA34 == 0) < 0 )
      {
        v9 = _errno_location();
        v10 = strerror(*v9);
        sub_184AC("Failed to daemonize: %s", v10);
      }
      if ( dword_4CB50 )
        sub_184E8(6, "Running in background");
      else
        sub_184E8(6, "Not backgrounding");
      v14 = (FILE *)fopen64(dword_4CBEC, "w");
      if ( v14 )
      {
        v15 = getpid();
        fprintf(v14, "%d\n", v15);
        fclose(v14);
      }
      while ( 1 )
      {
        for ( j = 0; j != 32; ++j )
          readfds.__fds_bits[j] = 0;
        v17 = 0;
        do
        {
          v20 = v60[v17++];
          v18 = &ptr[v20 / 32 + 32];
          v6 = -v20 < 0;
          v19 = -v20 & 0x1F;
          LOBYTE(v20) = v20 & 0x1F;
          if ( !v6 )
            v20 = -v19;
          *(v18 - 64) |= 1 << v20;
        }
        while ( v17 != v2 );
        v21 = v54;
        v22 = 0;
        for ( k = 0; k != 30; ++k )
        {
          v24 = v60[k + 30];
          if ( v24 >= 0 )
          {
            if ( v21 < v24 )
              v21 = v60[k + 30];
            readfds.__fds_bits[v24 >> 5] |= 1 << (v24 & 0x1F);
            v22 = 1;
          }
        }
        if ( v22 )
          v54 = v21;
        v25 = select(v54 + 1, &readfds, 0, 0, 0);
        v26 = dword_4CB44;
        if ( dword_4CB44 )
        {
          unlink((const char *)dword_4CBEC);
          sub_184AC("Terminated by signal");
        }
        if ( v25 )
        {
          if ( v25 >= 0 )
          {
            do
            {
              v27 = v60[v26 + 30];
              if ( v27 >= 0 && (readfds.__fds_bits[v27 >> 5] & (1 << (v27 & 0x1F))) != 0 )
              {
                sub_185B8(v27);
                v60[v26 + 30] = -1;
                free((void *)s[v26]);
                s[v26] = 0;
              }
              ++v26;
            }
            while ( v26 != 30 );
            for ( m = 0; m < v2; ++m )
            {
              v29 = v60[m];
              v55 = 0;
              v56 = 0;
              v57 = 0;
              LOBYTE(v30) = v29 & 0x1F;
              if ( v29 <= 0 )
                v30 = -(-v29 & 0x1F);
              if ( (readfds.__fds_bits[v29 / 32] & (1 << v30)) != 0 )
              {
                v58 = 128;
                v49 = accept(v29, (struct sockaddr *)ptr, &v58);
                if ( v49 >= 0 )
                {
                  sub_1D188((const struct sockaddr *)ptr, (char **)&v55, 0, 0);
                  v31 = 0;
                  v32 = 0;
                  v33 = 0;
                  s1 = (char *)v55;
                  v34 = 0;
                  do
                  {
                    if ( (int)v60[v33 + 30] >= 0 )
                    {
                      v52 = v34 + 1;
                      v53 = v32;
                      v35 = strcmp(s1, (const char *)s[v33]);
                      v32 = v53;
                      v34 = v52;
                      if ( !v35 )
                        v32 = v53 + 1;
                    }
                    else
                    {
                      v31 = v33;
                    }
                    ++v33;
                  }
                  while ( v33 != 30 );
                  v36 = v32 > 4;
                  if ( v32 <= 4 )
                    v36 = v34 > 0x1D;
                  v37 = v36;
                  if ( !v36 )
                  {
                    sub_18158();
                    if ( pipe(pipedes) >= 0 )
                    {
                      v57 = fork();
                      if ( v57 >= 0 )
                      {
                        sub_1803C((char *)&v57, 4u);
                        if ( v57 <= 0 )
                        {
                          sub_1D188((const struct sockaddr *)ptr, (char **)v37, (char **)&v56, v37);
                          sub_184E8(6, "Child connection from %s:%s", (const char *)v55, (const char *)v56);
                          free(v55);
                          v55 = (void *)v37;
                          free(v56);
                          v56 = (void *)v37;
                          if ( setsid() < 0 )
                          {
                            v43 = _errno_location();
                            v44 = strerror(*v43);
                            sub_184AC("setsid: %s", v44);
                          }
                          do
                          {
                            v45 = v60[v37++];
                            sub_185B8(v45);
                          }
                          while ( v37 < v2 );
                          sub_185B8(pipedes[0]);
                          sub_22EC4(__SPAIR64__(pipedes[1], v49), v46, v47);
                        }
                        v40 = pipedes[1];
                        v41 = &ptr[v31 + 32];
                        *(v41 - 124) = pipedes[0];
                        sub_185B8(v40);
                        v42 = v55;
                        v55 = (void *)v37;
                        *(v41 - 94) = v42;
                      }
                      else
                      {
                        v38 = _errno_location();
                        v39 = strerror(*v38);
                        sub_184E8(4, "Error forking: %s", v39);
                      }
                    }
                  }
                  sub_185B8(v49);
                  if ( v55 )
                    free(v55);
                }
              }
            }
          }
          else if ( *_errno_location() != 4 )
          {
            sub_184AC("Listening socket error");
          }
        }
      }
    }
  }
}
// 22258: variable 'v46' is possibly undefined
// 22258: variable 'v47' is possibly undefined
// 11EA4: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 4CA34: using guessed type int dword_4CA34;
// 4CB44: using guessed type int dword_4CB44;
// 4CB50: using guessed type int dword_4CB50;
// 4CB7C: using guessed type int dword_4CB7C;
// 4CBEC: using guessed type int dword_4CBEC;

//----- (00022298) --------------------------------------------------------
void __fastcall __noreturn sub_22298(unsigned int a1, const char **a2, void *a3, void *a4)
{
  char *v6; // r2
  char *v7; // r3
  void *ptr; // [sp+8h] [bp-8h] BYREF
  void *v9; // [sp+Ch] [bp-4h] BYREF

  ptr = a3;
  v9 = a4;
  off_4C3EC = (void (__fastcall __noreturn *)(int, const char *, void *))sub_22FDC;
  off_4C3E8 = sub_23100;
  sub_18AA8();
  sub_2257C(a1, a2);
  if ( dword_4CBA8 )
  {
    v9 = 0;
    sub_21B5C();
    sub_1D25C(0, 0, 0, (unsigned int)&ptr, (char **)&v9, 0);
    sub_184E8(6, "Child connection from %s:%s", (const char *)ptr, (const char *)v9);
    free(ptr);
    ptr = 0;
    free(v9);
    v9 = 0;
    setsid();
    sub_22EC4(0xFFFFFFFF00000000LL, v6, v7);
  }
  sub_21CCC();
}
// 2233C: variable 'v6' is possibly undefined
// 2233C: variable 'v7' is possibly undefined
// 4C3E8: using guessed type int (__fastcall *off_4C3E8)(int a1, char *format, __gnuc_va_list arg);
// 4C3EC: using guessed type void (__fastcall __noreturn *off_4C3EC)(int a1, const char *a2, void *a3);
// 4CBA8: using guessed type int dword_4CBA8;

//----- (0002235C) --------------------------------------------------------
int __fastcall sub_2235C(int result)
{
  int i; // r3
  char **v2; // r12

  for ( i = 0; ; ++i )
  {
    v2 = &(&off_4C2E0)[5 * i];
    if ( !*v2 )
      break;
    if ( *((unsigned __int8 *)v2 + 4) == result )
    {
      *((_BYTE *)v2 + 12) = 0;
      return result;
    }
  }
  return result;
}
// 4C2E0: using guessed type char *off_4C2E0;

//----- (000223A4) --------------------------------------------------------
const char *__fastcall sub_223A4(const char *result, _DWORD *a2, _DWORD *a3, int a4)
{
  if ( *a3 )
  {
    if ( a4 )
      sub_184AC("Only one %s key can be specified", result);
  }
  else
  {
    *a3 = *a2;
    *a2 = 0;
  }
  return result;
}

//----- (000223DC) --------------------------------------------------------
int __fastcall sub_223DC(const char *a1)
{
  return fprintf(
           (FILE *)stderr,
           "Dropbear server v%s https://matt.ucc.asn.au/dropbear/dropbear.html\n"
           "Usage: %s [options]\n"
           "-b bannerfile\tDisplay the contents of bannerfile before user login\n"
           "\t\t(default: none)\n"
           "-r keyfile  Specify hostkeys (repeatable)\n"
           "\t\tdefaults: \n"
           "\t\trsa %s\n"
           "\t\tecdsa %s\n"
           "-R\t\tCreate hostkeys as required\n"
           "-F\t\tDon't fork into background\n"
           "-E\t\tLog to stderr rather than syslog\n"
           "-w\t\tDisallow root logins\n"
           "-G\t\tRestrict logins to members of specified group\n"
           "-s\t\tDisable password logins\n"
           "-g\t\tDisable password logins for root\n"
           "-B\t\tAllow blank password logins\n"
           "-T\t\tMaximum authentication tries (default %d)\n"
           "-j\t\tDisable local port forwarding\n"
           "-k\t\tDisable remote port forwarding\n"
           "-a\t\tAllow connections to forwarded ports from any host\n"
           "-c command\tForce executed command\n"
           "-p [address:]port\n"
           "\t\tListen on specified tcp port (and optionally address),\n"
           "\t\tup to %d can be specified\n"
           "\t\t(default port is %s if none specified)\n"
           "-P PidFile\tCreate pid file PidFile\n"
           "\t\t(default %s)\n"
           "-i\t\tStart for inetd\n"
           "-W <receive_window_buffer> (default %d, larger may be faster, max 1MB)\n"
           "-K <keepalive>  (0 is never, default %d, in seconds)\n"
           "-I <idle_timeout>  (0 is never, default %d, in seconds)\n"
           "-V    Version\n",
           "2018.76",
           a1,
           "/etc/dropbear/dropbear_rsa_host_key",
           "/etc/dropbear/dropbear_ecdsa_host_key",
           10,
           10,
           "22",
           "/var/run/dropbear.pid",
           24576,
           0,
           0);
}
// 4C448: using guessed type int stderr;

//----- (00022460) --------------------------------------------------------
void __fastcall sub_22460(const char *a1, int a2)
{
  _DWORD *v4; // r4
  int v5; // [sp+4h] [bp-4h] BYREF

  v4 = sub_1E644();
  v5 = 80;
  if ( sub_155A0((int)a1, (int)v4, &v5) == -1 && !dword_4CBD4 )
    sub_184E8(4, "Failed loading %s", a1);
  if ( !v5 )
    sub_223A4("RSA", v4 + 3, (_DWORD *)(dword_4CBD0 + 12), a2);
  if ( v5 == 1 )
    sub_223A4("ECDSA256", v4 + 4, (_DWORD *)(dword_4CBD0 + 16), a2);
  if ( v5 == 2 )
    sub_223A4("ECDSA384", v4 + 5, (_DWORD *)(dword_4CBD0 + 20), a2);
  if ( v5 == 3 )
    sub_223A4("ECDSA521", v4 + 6, (_DWORD *)(dword_4CBD0 + 24), a2);
  sub_1EA60((int)v4);
}
// 4CBD0: using guessed type int dword_4CBD0;
// 4CBD4: using guessed type int dword_4CBD4;

//----- (0002257C) --------------------------------------------------------
struct group *__fastcall sub_2257C(unsigned int a1, const char **a2)
{
  int *p_nptr; // r4
  unsigned int v4; // r8
  const char *v5; // r1
  unsigned __int8 *v6; // lr
  int v7; // r5
  int v8; // r12
  int v9; // r2
  int v10; // t1
  int v11; // r0
  struct group *result; // r0
  int v13; // r0
  char *v14; // r0
  char *v15; // r5
  const char *v16; // r11
  char *v17; // r0
  char *v18; // r3
  char *v19; // r0
  char *v20; // r2
  char *v21; // r0
  int v22; // r11
  char *v23; // r0
  int v24; // r3
  const char *v25; // r12
  int v26; // r4
  char *v27; // r0
  int v28; // r3
  int gr_gid; // r3
  bool v30; // zf
  char *v31; // r4
  const char *v32; // r4
  const char *v33; // r4
  const char *v34; // r4
  int v35; // [sp+4h] [bp-90h]
  int v36; // [sp+4h] [bp-90h]
  const char *v38; // [sp+Ch] [bp-88h]
  char *nptr; // [sp+14h] [bp-80h] BYREF
  const char *v40; // [sp+18h] [bp-7Ch] BYREF
  const char *v41; // [sp+1Ch] [bp-78h] BYREF
  const char *v42; // [sp+20h] [bp-74h] BYREF
  const char *v43; // [sp+24h] [bp-70h] BYREF
  unsigned int v44[12]; // [sp+28h] [bp-6Ch] BYREF
  __int64 v45; // [sp+58h] [bp-3Ch]

  p_nptr = 0;
  v4 = 1;
  dword_4CBC4 = 10;
  nptr = 0;
  dword_4CBEC = (int)"/var/run/dropbear.pid";
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  dword_4CB4C[0] = 0;
  dword_4CBE8 = 0;
  dword_4CBF0 = 0;
  dword_4CB50 = 1;
  dword_4CBAC = 0;
  dword_4CBB0 = 0;
  dword_4CBB4 = 0;
  dword_4CBB8 = 0;
  dword_4CBBC = 0;
  dword_4CBC0 = 0;
  dword_4CBA8 = 0;
  dword_4CB7C = 0;
  dword_4CBD0 = 0;
  dword_4CBD4 = 0;
  dword_4CBCC = 0;
  dword_4CBC8 = 0;
  dword_4CA34 = 1;
  dword_4CA28 = 24576;
  dword_4CA2C = 0;
  dword_4CA30 = 0;
  dword_4CA24 = 0;
  while ( a1 > v4 )
  {
    v5 = a2[v4];
    v35 = v4;
    if ( *v5 != 45 || !v5[1] )
    {
      result = (struct group *)"Invalid argument: %s";
      goto LABEL_20;
    }
    v6 = (unsigned __int8 *)(v5 + 1);
    v7 = 0;
    while ( 1 )
    {
      v8 = v6 - (unsigned __int8 *)v5;
      v10 = *v6++;
      v9 = v10;
      v11 = p_nptr ? 0 : v7 ^ 1;
      if ( !v9 )
        break;
      if ( !v11 )
        goto LABEL_51;
      switch ( v9 )
      {
        case 'B':
          dword_4CBC0 = 1;
          goto LABEL_25;
        case 'E':
          dword_4CA34 = 0;
          goto LABEL_25;
        case 'F':
          dword_4CB50 = 0;
          goto LABEL_25;
        case 'G':
          v7 = 0;
          p_nptr = &dword_4CBB0;
          continue;
        case 'I':
          v7 = 0;
          p_nptr = (int *)&v41;
          continue;
        case 'K':
          v7 = 0;
          p_nptr = (int *)&v40;
          continue;
        case 'P':
          v7 = 0;
          p_nptr = &dword_4CBEC;
          continue;
        case 'R':
          dword_4CBD4 = 1;
          goto LABEL_25;
        case 'T':
          v7 = 0;
          p_nptr = (int *)&v42;
          continue;
        case 'V':
          sub_15740();
          goto LABEL_45;
        case 'W':
          v7 = 0;
          p_nptr = (int *)&nptr;
          continue;
        case 'a':
          dword_4CA24 = 1;
          goto LABEL_25;
        case 'b':
          v7 = 0;
          p_nptr = dword_4CB4C;
          continue;
        case 'c':
          v7 = 0;
          p_nptr = &dword_4CBF0;
          continue;
        case 'd':
        case 'r':
          v7 = 0;
          p_nptr = (int *)&v43;
          continue;
        case 'g':
          dword_4CBBC = 1;
          goto LABEL_25;
        case 'h':
          sub_223DC(*a2);
LABEL_45:
          v13 = 0;
          goto LABEL_46;
        case 'i':
          dword_4CBA8 = 1;
          goto LABEL_25;
        case 'j':
          dword_4CBCC = 1;
          goto LABEL_25;
        case 'k':
          dword_4CBC8 = 1;
          goto LABEL_25;
        case 'p':
          v7 = 1;
          goto LABEL_33;
        case 's':
          dword_4CBB8 = 1;
          goto LABEL_25;
        case 'u':
          goto LABEL_25;
        case 'w':
          dword_4CBAC = 1;
LABEL_25:
          v7 = 0;
LABEL_33:
          p_nptr = 0;
          break;
        default:
          fprintf((FILE *)stderr, "Invalid option -%c\n", v9);
          sub_223DC(*a2);
          v13 = 1;
LABEL_46:
          exit(v13);
          return result;
      }
    }
    if ( v11 )
    {
      p_nptr = 0;
      goto LABEL_66;
    }
    ++v4;
    if ( !a2[v35 + 1] )
      sub_184AC("Missing argument");
    v8 = 0;
LABEL_51:
    if ( v7 )
    {
      if ( (unsigned int)dword_4CB7C <= 9 )
      {
        v14 = sub_1886C(&a2[v4][v8]);
        v15 = v14;
        if ( *v14 == 91 )
        {
          v16 = v14 + 1;
          v17 = strchr(v14 + 1, 93);
          v18 = v17;
          if ( !v17 )
            sub_184AC("Bad listen address");
          *v17 = 0;
          v19 = v17 + 1;
          if ( v18[1] != 58 )
            sub_184AC("Missing port");
        }
        else
        {
          v16 = v14;
          v19 = strrchr(v14, 58);
        }
        if ( v19 )
        {
          v20 = (char *)v16;
          *v19 = 0;
          v16 = v19 + 1;
        }
        else
        {
          v20 = "";
        }
        if ( !*v16 )
          sub_184AC("Bad port");
        v38 = v20;
        v36 = dword_4CB7C;
        v21 = sub_1886C(v16);
        v22 = dword_4CB7C;
        dword_4CB4C[v36 + 2] = (int)v21;
        v23 = sub_1886C(v38);
        v24 = dword_4CB7C;
        dword_4CB4C[v22 + 13] = (int)v23;
        dword_4CB7C = v24 + 1;
        free(v15);
      }
    }
    else if ( p_nptr )
    {
      v25 = &a2[v4][v8];
      *p_nptr = (int)v25;
      if ( !v25 )
        sub_184AC("Invalid null argument");
      if ( v43 )
      {
        v26 = dword_4CBE4;
        if ( dword_4CBE4 > 2 )
          sub_184AC("Too many hostkeys");
        v27 = sub_1886C(v43);
        v28 = dword_4CBE4;
        v43 = 0;
        dword_4CB4C[v26 + 35] = (int)v27;
        dword_4CBE4 = v28 + 1;
      }
      p_nptr = 0;
    }
LABEL_66:
    ++v4;
  }
  if ( !dword_4CB7C )
  {
    dword_4CB54 = (int)sub_1886C("22");
    dword_4CB80 = (int)sub_1886C("");
    dword_4CB7C = 1;
  }
  if ( dword_4CB4C[0] )
  {
    if ( sub_34FAC() )
      sub_184AC("Error opening banner file '%s'", dword_4CB4C[0]);
    if ( v45 > 2000 )
      sub_184AC("Banner file too large, max is %d bytes", 2000);
    dword_4CBE8 = (int)sub_12344(v45);
    if ( sub_1867C((_DWORD *)dword_4CBE8, dword_4CB4C[0]) )
      sub_184AC("Error reading banner file '%s'", dword_4CB4C[0]);
    sub_124A0(dword_4CBE8, 0);
  }
  result = (struct group *)dword_4CBB0;
  if ( dword_4CBB0 )
  {
    result = getgrnam((const char *)dword_4CBB0);
    v30 = result == 0;
    if ( result )
    {
      gr_gid = result->gr_gid;
    }
    else
    {
      v5 = (const char *)dword_4CBB0;
      result = (struct group *)"Cannot restrict logins to group '%s' as the group does not exist";
    }
    if ( v30 )
LABEL_20:
      sub_184AC((const char *)result, v5);
    dword_4CBB4 = gr_gid;
  }
  v31 = nptr;
  if ( nptr )
  {
    dword_4CA28 = atol(nptr);
    result = (struct group *)(dword_4CA28 - 1);
    if ( (unsigned int)(dword_4CA28 - 1) >= 0x100000 )
      sub_184AC("Bad recv window '%s'", v31);
  }
  v32 = v42;
  if ( v42 )
  {
    v44[0] = 0;
    result = (struct group *)sub_18AD0(v42, v44);
    if ( result == (struct group *)-1 || !v44[0] )
      sub_184AC("Bad maxauthtries '%s'", v32);
    dword_4CBC4 = v44[0];
  }
  v33 = v40;
  if ( v40 )
  {
    result = (struct group *)sub_18AD0(v40, v44);
    if ( result == (struct group *)-1 )
      sub_184AC("Bad keepalive '%s'", v33);
    dword_4CA2C = v44[0];
  }
  v34 = v41;
  if ( v41 )
  {
    result = (struct group *)sub_18AD0(v41, v44);
    if ( result == (struct group *)-1 )
      sub_184AC("Bad idle_timeout '%s'", v34);
    dword_4CA30 = v44[0];
  }
  if ( dword_4CBF0 )
    return (struct group *)sub_184E8(6, "Forced command set to '%s'", (const char *)dword_4CBF0);
  return result;
}
// 22708: control flows out of bounds to 2270C
// 226F8: variable 'v5' is possibly undefined
// 22AC8: variable 'gr_gid' is possibly undefined
// 4C448: using guessed type int stderr;
// 4CA24: using guessed type int dword_4CA24;
// 4CA28: using guessed type int dword_4CA28;
// 4CA2C: using guessed type int dword_4CA2C;
// 4CA30: using guessed type int dword_4CA30;
// 4CA34: using guessed type int dword_4CA34;
// 4CB4C: using guessed type int dword_4CB4C[];
// 4CB50: using guessed type int dword_4CB50;
// 4CB54: using guessed type int dword_4CB54;
// 4CB7C: using guessed type int dword_4CB7C;
// 4CB80: using guessed type int dword_4CB80;
// 4CBA8: using guessed type int dword_4CBA8;
// 4CBAC: using guessed type int dword_4CBAC;
// 4CBB0: using guessed type int dword_4CBB0;
// 4CBB4: using guessed type int dword_4CBB4;
// 4CBB8: using guessed type int dword_4CBB8;
// 4CBBC: using guessed type int dword_4CBBC;
// 4CBC0: using guessed type int dword_4CBC0;
// 4CBC4: using guessed type int dword_4CBC4;
// 4CBC8: using guessed type int dword_4CBC8;
// 4CBCC: using guessed type int dword_4CBCC;
// 4CBD0: using guessed type int dword_4CBD0;
// 4CBD4: using guessed type int dword_4CBD4;
// 4CBE4: using guessed type int dword_4CBE4;
// 4CBE8: using guessed type int dword_4CBE8;
// 4CBEC: using guessed type int dword_4CBEC;
// 4CBF0: using guessed type int dword_4CBF0;

//----- (00022C28) --------------------------------------------------------
void sub_22C28()
{
  int v0; // r6
  int v1; // r5
  int v2; // r1
  _BOOL4 v3; // r3
  int v4; // r5
  int *v5; // r3
  char *v6; // r5

  v0 = 0;
  dword_4CBD0 = (int)sub_1E644();
  while ( dword_4CBE4 > v0 )
  {
    v5 = &dword_4CB4C[v0++];
    v6 = (char *)v5[35];
    sub_22460(v6, 1);
    free(v6);
  }
  if ( !dword_4CBE4 )
  {
    sub_22460("/etc/dropbear/dropbear_rsa_host_key", 0);
    sub_22460("/etc/dropbear/dropbear_ecdsa_host_key", 0);
  }
  v1 = dword_4CBD4;
  if ( dword_4CBD4 || *(_DWORD *)(dword_4CBD0 + 12) )
    v1 = 1;
  else
    sub_2235C(dword_4CBD4);
  v2 = *(_DWORD *)(dword_4CBD0 + 16);
  v3 = v2 || *(_DWORD *)(dword_4CBD0 + 20) || *(_DWORD *)(dword_4CBD0 + 24) != 0;
  v4 = v3 | dword_4CBD4 | v1;
  if ( !v2 )
  {
    if ( !dword_4CBD4 )
      v3 = 1;
    if ( v3 )
      sub_2235C(1);
  }
  if ( !*(_DWORD *)(dword_4CBD0 + 20) )
    sub_2235C(2);
  if ( !*(_DWORD *)(dword_4CBD0 + 24) )
    sub_2235C(3);
  if ( !v4 )
    sub_184AC("No hostkeys available. 'dropbear -R' may be useful or run dropbearkey.");
}
// 4CB4C: using guessed type int dword_4CB4C[];
// 4CBD0: using guessed type int dword_4CBD0;
// 4CBD4: using guessed type int dword_4CBD4;
// 4CBE4: using guessed type int dword_4CBE4;

//----- (00022D64) --------------------------------------------------------
_DWORD *__fastcall sub_22D64(const void *a1, unsigned int a2)
{
  sub_125A4(dword_4CA58, 6);
  sub_127F8((_DWORD *)dword_4CA58, a1, a2);
  return sub_1D894();
}
// 4CA58: using guessed type int dword_4CA58;

//----- (00022D9C) --------------------------------------------------------
void __fastcall sub_22D9C(int a1, size_t a2)
{
  const char *v2; // r0
  size_t v3; // r5
  char *v4; // r4
  size_t n; // [sp+4h] [bp-4h] BYREF

  n = a2;
  v2 = (const char *)sub_12690((_DWORD *)dword_4CA70, &n);
  v3 = n;
  v4 = (char *)v2;
  if ( n == 12 )
  {
    if ( !strncmp("ssh-userauth", v2, 0xCu) )
      goto LABEL_3;
LABEL_9:
    free(v4);
    sub_184AC("Unrecognised SSH_MSG_SERVICE_REQUEST");
  }
  if ( n != 14 || strncmp("ssh-connection", v2, 0xEu) )
    goto LABEL_9;
  if ( dword_4CAFC != 1 )
    sub_184AC("Request for connection before auth");
LABEL_3:
  sub_22D64(v4, v3);
  free(v4);
}
// 4CA70: using guessed type int dword_4CA70;
// 4CAFC: using guessed type int dword_4CAFC;

//----- (00022E4C) --------------------------------------------------------
void sub_22E4C()
{
  sub_205BC();
  free((void *)dword_4CC10);
  dword_4CC10 = 0;
  free((void *)dword_4CC14);
  dword_4CC14 = 0;
  free((void *)dword_4CBF8);
  dword_4CBF8 = 0;
  dword_4CBFC = 0;
}
// 4CBF8: using guessed type int dword_4CBF8;
// 4CBFC: using guessed type int dword_4CBFC;
// 4CC10: using guessed type int dword_4CC10;
// 4CC14: using guessed type int dword_4CC14;

//----- (00022E8C) --------------------------------------------------------
void __noreturn sub_22E8C()
{
  sub_185B8(dword_4CA48);
  sub_185B8(dword_4CA4C);
  dword_4CA48 = -1;
  dword_4CA4C = -1;
  sub_18484("Exited normally");
}
// 4CA48: using guessed type int dword_4CA48;
// 4CA4C: using guessed type int dword_4CA4C;

//----- (00022EC4) --------------------------------------------------------
void __fastcall __noreturn sub_22EC4(__int64 a1, char *a2, char *a3)
{
  int v3; // r4
  size_t v4; // r6
  size_t v5; // r6
  _DWORD *v6; // r0
  int v7; // r1
  int v8; // r1
  char *s; // [sp+8h] [bp-8h] BYREF
  char *v10; // [sp+Ch] [bp-4h] BYREF

  s = a2;
  v10 = a3;
  v3 = HIDWORD(a1);
  HIDWORD(a1) = a1;
  sub_16214(a1);
  dword_4CBF4 = v3;
  sub_1F5A0();
  sub_13C4C((int)&off_4C434);
  sub_20D50();
  sub_1D25C((char *)dword_4CA48, 0, 0, (unsigned int)&s, &v10, 0);
  v4 = strlen(s);
  v5 = v4 + strlen(v10) + 2;
  dword_4CC10 = (int)sub_18718(v5);
  snprintf((char *)dword_4CC10, v5, "%s:%s", s, v10);
  free(s);
  s = 0;
  free(v10);
  v10 = 0;
  sub_1D25C((char *)dword_4CA48, 0, 0, (unsigned int)&dword_4CC14, 0, 1);
  byte_4CA40 = 1;
  dword_4CB48 = 1;
  off_4CAE4 = (int (*)(void))sub_22E8C;
  off_4CAE8 = sub_22E4C;
  dword_4CA80 = (int)"^";
  v6 = sub_16030();
  sub_14D80((int)v6, v7);
  sub_14BDC();
  sub_15940((int)sub_20C8C, v8);
}
// 22FAC: variable 'v7' is possibly undefined
// 22FB8: variable 'v8' is possibly undefined
// 4C434: using guessed type _UNKNOWN *off_4C434;
// 4CA40: using guessed type char byte_4CA40;
// 4CA48: using guessed type int dword_4CA48;
// 4CA80: using guessed type int dword_4CA80;
// 4CAE4: using guessed type int (*off_4CAE4)(void);
// 4CAE8: using guessed type _UNKNOWN *off_4CAE8;
// 4CB48: using guessed type int dword_4CB48;
// 4CBF4: using guessed type int dword_4CBF4;
// 4CC10: using guessed type int dword_4CC10;
// 4CC14: using guessed type int dword_4CC14;

//----- (00022FDC) --------------------------------------------------------
void __fastcall __noreturn sub_22FDC(int a1, char *format, __gnuc_va_list arg)
{
  int *v4; // r4
  void *v5; // t1
  char s[152]; // [sp+Ch] [bp-1C4h] BYREF
  char v7[300]; // [sp+A4h] [bp-12Ch] BYREF

  vsnprintf(s, 0x96u, format, arg);
  if ( dword_4CB48 )
  {
    if ( dword_4CAFC )
    {
      snprintf(v7, 0x12Cu, "Exit (%s): %s", (const char *)dword_4CB18, s);
    }
    else if ( dword_4CB18 )
    {
      snprintf(v7, 0x12Cu, "Exit before auth (user '%s', %u fails): %s", (const char *)dword_4CB18, dword_4CAF8, s);
    }
    else
    {
      snprintf(v7, 0x12Cu, "Exit before auth: %s", s);
    }
  }
  else
  {
    snprintf(v7, 0x12Cu, "Early exit: %s", s);
  }
  sub_184E8(6, "%s", v7);
  sub_15EF8();
  if ( dword_4CBD0 )
  {
    sub_1EA60(dword_4CBD0);
    dword_4CBD0 = 0;
  }
  v4 = &dword_4CB50;
  do
  {
    free((void *)v4[12]);
    v4[12] = 0;
    v5 = (void *)v4[1];
    ++v4;
    free(v5);
    *v4 = 0;
  }
  while ( v4 != (int *)&unk_4CB78 );
  exit(a1);
}
// 4CAF8: using guessed type int dword_4CAF8;
// 4CAFC: using guessed type int dword_4CAFC;
// 4CB18: using guessed type int dword_4CB18;
// 4CB48: using guessed type int dword_4CB48;
// 4CB50: using guessed type int dword_4CB50;
// 4CBD0: using guessed type int dword_4CBD0;

//----- (00023100) --------------------------------------------------------
int __fastcall sub_23100(int a1, char *format, __gnuc_va_list arg)
{
  int result; // r0
  struct tm *v5; // r3
  FILE *v6; // r4
  __pid_t v7; // r0
  time_t timer; // [sp+8h] [bp-418h] BYREF
  char v9[20]; // [sp+Ch] [bp-414h] BYREF
  char s[1024]; // [sp+20h] [bp-400h] BYREF

  vsnprintf(s, 0x400u, format, arg);
  if ( dword_4CA34 )
    syslog(a1, "%s", s);
  result = dword_4CA34;
  if ( !dword_4CA34 )
  {
    timer = time(0);
    v5 = localtime(&timer);
    if ( !v5 || !strftime(v9, 0x14u, "%b %d %H:%M:%S", v5) )
      snprintf(v9, 0x14u, "%d", timer);
    v6 = (FILE *)stderr;
    v7 = getpid();
    return fprintf(v6, "[%d] %s %s\n", v7, v9, s);
  }
  return result;
}
// 4C448: using guessed type int stderr;
// 4CA34: using guessed type int dword_4CA34;

//----- (000231E0) --------------------------------------------------------
bool __fastcall sub_231E0(int a1, int a2)
{
  return *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20)
      && strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8)) == 0;
}

//----- (00023224) --------------------------------------------------------
int __fastcall sub_23224(struct addrinfo *a1)
{
  void *v1; // r4
  int v2; // r5
  char *v3; // r7
  unsigned int v6; // r6
  unsigned int v7; // r0
  bool v8; // cf
  _BOOL4 v9; // r5
  unsigned int v10; // [sp+Ch] [bp-24h] BYREF
  char s[32]; // [sp+10h] [bp-20h] BYREF

  v1 = (void *)dword_4CBCC;
  if ( dword_4CBCC || !sub_204E8() )
  {
    v1 = 0;
    v2 = 1;
    v3 = 0;
  }
  else
  {
    v3 = (char *)sub_12690((_DWORD *)dword_4CA70, &v10);
    if ( v10 > 0xFE )
      goto LABEL_14;
    v6 = sub_12664((_DWORD *)dword_4CA70);
    v1 = sub_12690((_DWORD *)dword_4CA70, &v10);
    if ( v10 > 0xFE )
      goto LABEL_14;
    v7 = sub_12664((_DWORD *)dword_4CA70);
    v8 = v6 >= 0x10000;
    if ( v6 < 0x10000 )
      v8 = v7 >= 0x10000;
    v9 = v8;
    if ( v8 )
    {
LABEL_14:
      v2 = 1;
    }
    else
    {
      snprintf(s, 0x20u, "%u", v6);
      a1[2].ai_socktype = (int)sub_1C6E4(v3, s, (struct addrinfo *)sub_13E28, a1, (const char *)v9, (const char *)v9);
      a1[3].ai_flags = 1;
      v2 = 99;
    }
  }
  free(v3);
  free(v1);
  return v2;
}
// 4CA70: using guessed type int dword_4CA70;
// 4CBCC: using guessed type int dword_4CBCC;

//----- (00023334) --------------------------------------------------------
void sub_23334()
{
  char *v0; // r6
  _BOOL4 v1; // r9
  char *v2; // r7
  _DWORD *v3; // r4
  unsigned int v4; // r0
  unsigned int v5; // r8
  _BOOL4 v6; // r3
  int v7; // r0
  unsigned int v8; // r7
  int v9; // r5
  void *v10; // r7
  _DWORD *v11; // r0
  unsigned int v12; // [sp+4h] [bp-28h] BYREF
  unsigned int v13; // [sp+8h] [bp-24h] BYREF
  unsigned int v14[8]; // [sp+Ch] [bp-20h] BYREF

  if ( dword_4CBC8 || !sub_204E8() )
  {
    v0 = 0;
  }
  else
  {
    v0 = (char *)sub_12690((_DWORD *)dword_4CA70, &v12);
    v1 = sub_12590(dword_4CA70);
    if ( v12 > 0x40 )
      goto LABEL_22;
    if ( !strcmp("tcpip-forward", v0) )
    {
      v2 = (char *)sub_12690((_DWORD *)dword_4CA70, v14);
      if ( v14[0] > 0xF )
        goto LABEL_8;
      v4 = sub_12664((_DWORD *)dword_4CA70);
      v5 = v4;
      if ( !v4 )
        goto LABEL_15;
      if ( v4 - 1 > 0xFFFE )
        goto LABEL_8;
      v6 = v4 < 0x400;
      if ( dword_4CB40 )
        v6 = 0;
      if ( v6 )
      {
LABEL_8:
        v3 = 0;
      }
      else
      {
LABEL_15:
        v3 = sub_18718(0x1Cu);
        *v3 = 0;
        v3[1] = 0;
        v3[3] = v5;
        v3[4] = v2;
        v3[5] = &unk_38088;
        v3[6] = 1;
        if ( dword_4CA24 && strcmp(v2, "localhost") )
          v3[2] = sub_1886C(v2);
        else
          v3[2] = 0;
        v7 = sub_23B3C((int)v3);
        if ( !v7 )
        {
          v8 = sub_1CE04(**(_DWORD **)dword_4CB38);
          v3[3] = v8;
          sub_125A4(dword_4CA58, 81);
          sub_1279C((_DWORD *)dword_4CA58, v8);
          sub_1D894();
          goto LABEL_3;
        }
        if ( v7 != -1 )
          goto LABEL_22;
      }
      free(v2);
      free(v3);
LABEL_22:
      if ( !v1 )
        goto LABEL_3;
LABEL_23:
      sub_1457C();
      goto LABEL_3;
    }
    v9 = strcmp("cancel-tcpip-forward", v0);
    if ( v9 )
      goto LABEL_22;
    v10 = sub_12690((_DWORD *)dword_4CA70, &v13);
    if ( v13 <= 0xF
      && (v14[3] = sub_12664((_DWORD *)dword_4CA70),
          v14[0] = 0,
          v14[1] = 0,
          v14[2] = (unsigned int)v10,
          (v11 = (_DWORD *)sub_1C088(1130441831, (int)v14, (int (__fastcall *)(int, _DWORD))sub_231E0)) != 0) )
    {
      sub_1C0F0(v11);
    }
    else
    {
      v9 = -1;
    }
    free(v10);
    if ( v1 )
    {
      if ( !v9 )
      {
        sub_1455C();
        goto LABEL_3;
      }
      goto LABEL_23;
    }
  }
LABEL_3:
  free(v0);
}
// 4CA24: using guessed type int dword_4CA24;
// 4CA58: using guessed type int dword_4CA58;
// 4CA70: using guessed type int dword_4CA70;
// 4CB38: using guessed type int dword_4CB38;
// 4CB40: using guessed type int dword_4CB40;
// 4CBC8: using guessed type int dword_4CBC8;

//----- (000235A0) --------------------------------------------------------
int __fastcall sub_235A0(int a1)
{
  *(_DWORD *)(a1 + 96) = 0;
  return 0;
}

//----- (000235B0) --------------------------------------------------------
int __fastcall sub_235B0(int a1)
{
  int v1; // r5
  int v2; // r4
  int v3; // t1
  const unsigned __int16 *v5; // r2
  bool v6; // zf
  char v7; // r0
  int v8; // r3
  int v9; // r4

  v1 = a1 - 1;
  do
  {
    v3 = *(unsigned __int8 *)++v1;
    v2 = v3;
    if ( !v3 )
      return 0;
    v5 = *_ctype_b_loc();
    v6 = v2 == 58;
    if ( v2 != 58 )
      v6 = v2 == 95;
    v7 = !v6;
    v8 = v5[v2];
    if ( (unsigned int)(v2 - 45) > 2 )
      v9 = v7 & 1;
    else
      v9 = 0;
  }
  while ( (v9 & ((v8 ^ 8u) >> 3)) == 0 );
  return -1;
}

//----- (00023610) --------------------------------------------------------
int __fastcall sub_23610(int a1)
{
  int v1; // r5
  int v3; // r7
  unsigned int v4; // r5
  _DWORD *v5; // r0
  int fd; // [sp+Ch] [bp-18h] BYREF
  struct sockaddr v8; // [sp+10h] [bp-14h] BYREF

  v1 = -1;
  fd = -1;
  if ( sub_2050C() && !*(_DWORD *)(a1 + 48) )
  {
    *(_BYTE *)(a1 + 68) = sub_12590(dword_4CA70);
    *(_DWORD *)(a1 + 56) = sub_12690((_DWORD *)dword_4CA70, 0);
    *(_DWORD *)(a1 + 60) = sub_12690((_DWORD *)dword_4CA70, 0);
    *(_DWORD *)(a1 + 64) = sub_12664((_DWORD *)dword_4CA70);
    if ( sub_235B0(*(_DWORD *)(a1 + 56)) == -1 || sub_235B0(*(_DWORD *)(a1 + 60)) == -1 )
    {
      sub_184E8(4, "Bad xauth request");
LABEL_6:
      free(*(void **)(a1 + 56));
      *(_DWORD *)(a1 + 56) = 0;
      free(*(void **)(a1 + 60));
      *(_DWORD *)(a1 + 60) = 0;
      v1 = -1;
      sub_185B8(fd);
      return v1;
    }
    v3 = socket(2, 1, 0);
    fd = v3;
    if ( v3 < 0 )
      goto LABEL_6;
    *(_DWORD *)&v8.sa_data[6] = 0;
    v8.sa_family = 2;
    v4 = 6010;
    *(_DWORD *)&v8.sa_data[10] = 0;
    *(_DWORD *)&v8.sa_data[2] = 16777343;
    while ( 1 )
    {
      *(_WORD *)v8.sa_data = __rev16(v4);
      if ( !bind(v3, &v8, 0x10u) )
        break;
      if ( *_errno_location() != 98 )
      {
        sub_184E8(7, "Failed to bind x11 socket");
        *(_DWORD *)(a1 + 52) = -1;
        goto LABEL_6;
      }
      v4 = (unsigned __int16)(v4 + 1);
      if ( v4 == 8010 )
      {
        v4 = -1;
        break;
      }
    }
    *(_DWORD *)(a1 + 52) = v4;
    if ( v4 == -1 )
      goto LABEL_6;
    if ( listen(fd, 20) < 0 )
      goto LABEL_6;
    v1 = 0;
    sub_188B0(fd);
    v5 = sub_1BF64(&fd, 1, 0, a1, (int)sub_23914, 0);
    *(_DWORD *)(a1 + 48) = v5;
    if ( !v5 )
      goto LABEL_6;
  }
  return v1;
}
// 4CA70: using guessed type int dword_4CA70;

//----- (000237E8) --------------------------------------------------------
int __fastcall sub_237E8(int result)
{
  int v1; // r4
  FILE *v2; // r0
  FILE *v3; // r5
  char s[36]; // [sp+Ch] [bp-24h] BYREF

  if ( *(_DWORD *)(result + 48) )
  {
    v1 = result;
    result = snprintf(s, 0x14u, "localhost:%d.%u", *(_DWORD *)(result + 52) - 6000, *(_DWORD *)(result + 64));
    if ( result <= 19 )
    {
      sub_20DC8("DISPLAY", s);
      result = snprintf(s, 0x14u, "unix:%d.%u", *(_DWORD *)(v1 + 52) - 6000, *(_DWORD *)(v1 + 64));
      if ( result <= 19 )
      {
        v2 = popen("/usr/bin/xauth -q", "w");
        v3 = v2;
        if ( v2 )
        {
          fprintf(v2, "add %s %s %s\n", s, *(const char **)(v1 + 56), *(const char **)(v1 + 60));
          return pclose(v3);
        }
        else
        {
          return fprintf((FILE *)stderr, "Failed to run %s\n", "/usr/bin/xauth -q");
        }
      }
    }
  }
  return result;
}
// 4C448: using guessed type int stderr;

//----- (000238D8) --------------------------------------------------------
void __fastcall sub_238D8(int a1)
{
  void *v2; // r0
  _DWORD *v3; // r0

  free(*(void **)(a1 + 56));
  v2 = *(void **)(a1 + 60);
  *(_DWORD *)(a1 + 56) = 0;
  free(v2);
  v3 = *(_DWORD **)(a1 + 48);
  *(_DWORD *)(a1 + 60) = 0;
  if ( v3 )
  {
    sub_1C0F0(v3);
    *(_DWORD *)(a1 + 48) = 0;
  }
}

//----- (00023914) --------------------------------------------------------
_DWORD *__fastcall sub_23914(int a1, int fd)
{
  int v2; // r5
  _DWORD *result; // r0
  int v4; // r4
  char *v5; // r5
  size_t v6; // r0
  socklen_t v7; // [sp+4h] [bp-18h] BYREF
  struct sockaddr addr; // [sp+8h] [bp-14h] BYREF

  v2 = *(_DWORD *)(a1 + 28);
  v7 = 16;
  result = (_DWORD *)accept(fd, &addr, &v7);
  v4 = (int)result;
  if ( (int)result >= 0 )
  {
    if ( *(_BYTE *)(v2 + 68) )
      sub_238D8(v2);
    if ( sub_143D8(v4, (int)&unk_380F4) )
    {
      return (_DWORD *)close(v4);
    }
    else
    {
      v5 = inet_ntoa(*(struct in_addr *)&addr.sa_data[2]);
      v6 = strlen(v5);
      sub_127F8((_DWORD *)dword_4CA58, v5, v6);
      sub_1279C((_DWORD *)dword_4CA58, *(unsigned __int16 *)addr.sa_data);
      return sub_1D894();
    }
  }
  return result;
}
// 4CA58: using guessed type int dword_4CA58;

//----- (000239BC) --------------------------------------------------------
void __fastcall sub_239BC(int a1)
{
  void **v1; // r4

  v1 = *(void ***)(a1 + 28);
  free(*v1);
  free(v1[2]);
  free(v1[4]);
  free(v1);
}

//----- (000239E8) --------------------------------------------------------
_DWORD *__fastcall sub_239E8(int a1, int fd)
{
  int v2; // r5
  _DWORD *result; // r0
  int v4; // r4
  int v5; // r3
  const char *v6; // r4
  unsigned int v7; // r7
  size_t v8; // r0
  size_t v9; // r0
  _DWORD *v10; // r4
  unsigned int v11; // r0
  socklen_t addr_len; // [sp+10h] [bp-4ACh] BYREF
  char serv[32]; // [sp+14h] [bp-4A8h] BYREF
  struct sockaddr addr; // [sp+34h] [bp-488h] BYREF
  char host[1032]; // [sp+B4h] [bp-408h] BYREF

  v2 = *(_DWORD *)(a1 + 28);
  addr_len = 128;
  result = (_DWORD *)accept(fd, &addr, &addr_len);
  v4 = (int)result;
  if ( (int)result >= 0 )
  {
    if ( getnameinfo(&addr, addr_len, host, 0x401u, serv, 0x20u, 3u) )
    {
      return (_DWORD *)sub_185B8(v4);
    }
    else if ( sub_143D8(v4, *(_DWORD *)(v2 + 20)) )
    {
      return (_DWORD *)close(v4);
    }
    else
    {
      v5 = *(_DWORD *)(v2 + 24);
      if ( v5 )
      {
        if ( v5 != 1 )
          sub_184D4("tcpinfo->tcp_type == forwarded", "tcp-accept.c", 87);
        v6 = *(const char **)(v2 + 16);
        v7 = *(_DWORD *)(v2 + 12);
      }
      else
      {
        v6 = *(const char **)v2;
        v7 = *(_DWORD *)(v2 + 4);
      }
      if ( !v6 )
        v6 = "localhost";
      v8 = strlen(v6);
      sub_127F8((_DWORD *)dword_4CA58, v6, v8);
      sub_1279C((_DWORD *)dword_4CA58, v7);
      v9 = strlen(host);
      sub_127F8((_DWORD *)dword_4CA58, host, v9);
      v10 = (_DWORD *)dword_4CA58;
      v11 = atol(serv);
      sub_1279C(v10, v11);
      return sub_1D894();
    }
  }
  return result;
}
// 4CA58: using guessed type int dword_4CA58;

//----- (00023B2C) --------------------------------------------------------
int __fastcall sub_23B2C(int a1)
{
  *(_DWORD *)(a1 + 96) = 1;
  return 0;
}

//----- (00023B3C) --------------------------------------------------------
int __fastcall sub_23B3C(int a1)
{
  int v1; // r3
  int v3; // r6
  void *ptr; // [sp+Ch] [bp-2Ch] BYREF
  int v6[2]; // [sp+10h] [bp-28h] BYREF
  char s[32]; // [sp+18h] [bp-20h] BYREF

  v1 = *(_DWORD *)(a1 + 12);
  ptr = 0;
  snprintf(s, 0x20u, "%u", v1);
  v3 = sub_1CE9C(*(const char **)(a1 + 8), s, (int)v6, 2u, (char **)&ptr, &dword_4CA54);
  if ( v3 >= 0 )
  {
    free(ptr);
    ptr = 0;
    return -(sub_1BF64(v6, v3, 1130441831, a1, (int)sub_239E8, (int)sub_239BC) == 0);
  }
  else
  {
    sub_184E8(6, "TCP forward failed: %s", (const char *)ptr);
    free(ptr);
    return -1;
  }
}
// 4CA54: using guessed type int dword_4CA54;

//----- (00023C0C) --------------------------------------------------------
unsigned int __fastcall sub_23C0C(unsigned int a1)
{
  return *(_DWORD *)&byte_384C4[4 * BYTE2(a1)] & 0xFF000000
       | *(_DWORD *)&byte_384C4[4 * BYTE1(a1)] & 0xFF0000
       | *(_DWORD *)&byte_384C4[4 * (unsigned __int8)a1] & 0xFF00
       | byte_384C4[4 * HIBYTE(a1)];
}
// 384C4: using guessed type unsigned __int8 byte_384C4[4096];

//----- (00023C50) --------------------------------------------------------
int __fastcall sub_23C50(unsigned int a1)
{
  return *(_DWORD *)&byte_384C4[4 * byte_384C4[4 * HIBYTE(a1)] + 1024]
       ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * byte_384C4[4 * (unsigned __int8)a1] + 1024], 24)
       ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * byte_384C4[4 * BYTE2(a1)] + 1024], 8)
       ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * byte_384C4[4 * BYTE1(a1)] + 1024], 16);
}
// 384C4: using guessed type unsigned __int8 byte_384C4[4096];

//----- (00023CA8) --------------------------------------------------------
int sub_23CA8()
{
  return 2;
}

//----- (00023CB4) --------------------------------------------------------
int __fastcall sub_23CB4(unsigned int *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // r2
  const char *v4; // r0
  _DWORD *v5; // r9
  int v6; // r10
  unsigned int v7; // r4
  int v8; // r7
  unsigned int v9; // r5
  unsigned int v10; // r6
  unsigned int v11; // r0
  unsigned int v12; // r12
  unsigned int v13; // lr
  unsigned int v14; // r8
  _DWORD *v15; // r7
  int v16; // r5
  unsigned int v17; // r2
  int v18; // r5
  int v19; // r4
  int v20; // lr
  int v21; // r2
  int v22; // r12

  if ( !a1 )
  {
    v3 = 294;
    v4 = "pt != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 295;
    v4 = "ct != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 296;
    v4 = "skey != NULL";
LABEL_3:
    sub_26EB8(v4, "src/ciphers/aes/aes.c", v3);
  }
  v5 = a3;
  v6 = 0;
  v7 = bswap32(*a1) ^ *a3;
  v8 = a3[120];
  v9 = bswap32(a1[1]) ^ a3[1];
  v10 = bswap32(a1[2]) ^ a3[2];
  v11 = bswap32(a1[3]) ^ a3[3];
  while ( 1 )
  {
    v5 += 4;
    v12 = *v5
        ^ *(_DWORD *)&byte_384C4[4 * HIBYTE(v7) + 2048]
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * (unsigned __int8)v11 + 2048], 24)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE2(v9) + 2048], 8)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE1(v10) + 2048], 16);
    v13 = v5[1]
        ^ *(_DWORD *)&byte_384C4[4 * HIBYTE(v9) + 2048]
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * (unsigned __int8)v7 + 2048], 24)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE2(v10) + 2048], 8)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE1(v11) + 2048], 16);
    v14 = v5[2]
        ^ *(_DWORD *)&byte_384C4[4 * HIBYTE(v10) + 2048]
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * (unsigned __int8)v9 + 2048], 24)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE2(v11) + 2048], 8)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE1(v7) + 2048], 16);
    v11 = v5[3]
        ^ *(_DWORD *)&byte_384C4[4 * HIBYTE(v11) + 2048]
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * (unsigned __int8)v10 + 2048], 24)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE2(v7) + 2048], 8)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE1(v9) + 2048], 16);
    if ( v8 - 2 == v6 )
      break;
    ++v6;
    v10 = v14;
    v9 = v13;
    v7 = v12;
  }
  v15 = &a3[4 * v8 + 1073741820];
  v16 = *(_DWORD *)&byte_384C4[4 * HIBYTE(v13)];
  *a2 = bswap32(
          *(_DWORD *)&byte_384C4[4 * BYTE1(v14)]
        & 0xFF00
        ^ v15[4]
        ^ byte_384C4[4 * (unsigned __int8)v11]
        ^ (*(_DWORD *)&byte_384C4[4 * BYTE2(v13)] & 0xFF0000 | *(_DWORD *)&byte_384C4[4 * HIBYTE(v12)] & 0xFF000000));
  v17 = bswap32(
          *(_DWORD *)&byte_384C4[4 * BYTE1(v11)]
        & 0xFF00
        ^ v15[5]
        ^ byte_384C4[4 * (unsigned __int8)v12]
        ^ (*(_DWORD *)&byte_384C4[4 * BYTE2(v14)] & 0xFF0000 | v16 & 0xFF000000));
  v18 = *(_DWORD *)&byte_384C4[4 * HIBYTE(v14)];
  a2[1] = v17;
  v19 = v15[6] ^ byte_384C4[4 * (unsigned __int8)v13];
  v20 = *(_DWORD *)&byte_384C4[4 * BYTE1(v13)] & 0xFF00;
  v21 = *(_DWORD *)&byte_384C4[4 * BYTE1(v12)] & 0xFF00 ^ v19;
  v22 = *(_DWORD *)&byte_384C4[4 * BYTE2(v12)] & 0xFF0000;
  a2[2] = bswap32(v21 ^ (*(_DWORD *)&byte_384C4[4 * BYTE2(v11)] & 0xFF0000 | v18 & 0xFF000000));
  a2[3] = bswap32(
            (v22 | *(_DWORD *)&byte_384C4[4 * HIBYTE(v11)] & 0xFF000000)
          ^ byte_384C4[4 * (unsigned __int8)v14]
          ^ v15[7]
          ^ v20);
  return 0;
}
// 384C4: using guessed type unsigned __int8 byte_384C4[4096];

//----- (00023FC8) --------------------------------------------------------
int __fastcall sub_23FC8(unsigned int *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // r2
  const char *v4; // r0
  _DWORD *v5; // r10
  _DWORD *v6; // r8
  int v7; // r9
  unsigned int v8; // lr
  int v9; // r7
  unsigned int v10; // r4
  unsigned int v11; // r5
  unsigned int v12; // r2
  unsigned int v13; // r12
  unsigned int v14; // r0
  unsigned int v15; // r6
  _DWORD *v16; // r10
  unsigned __int8 *v17; // lr
  int v18; // r12
  unsigned __int8 *v19; // r4
  int v20; // r0
  unsigned int v21; // r3

  if ( !a2 )
  {
    v3 = 473;
    v4 = "pt != NULL";
    goto LABEL_3;
  }
  if ( !a1 )
  {
    v3 = 474;
    v4 = "ct != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 475;
    v4 = "skey != NULL";
LABEL_3:
    sub_26EB8(v4, "src/ciphers/aes/aes.c", v3);
  }
  v5 = a3 + 60;
  v6 = a3 + 60;
  v7 = 0;
  v8 = bswap32(*a1) ^ a3[60];
  v9 = a3[120];
  v10 = bswap32(a1[1]) ^ a3[61];
  v11 = bswap32(a1[2]) ^ a3[62];
  v12 = a3[63] ^ bswap32(a1[3]);
  while ( 1 )
  {
    v6 += 4;
    v13 = *(_DWORD *)&byte_384C4[4 * HIBYTE(v8) + 1024]
        ^ *v6
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * (unsigned __int8)v10 + 1024], 24)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE2(v12) + 1024], 8)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE1(v11) + 1024], 16);
    v14 = v6[1]
        ^ *(_DWORD *)&byte_384C4[4 * HIBYTE(v10) + 1024]
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * (unsigned __int8)v11 + 1024], 24)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE2(v8) + 1024], 8)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE1(v12) + 1024], 16);
    v15 = v6[2]
        ^ *(_DWORD *)&byte_384C4[4 * HIBYTE(v11) + 1024]
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * (unsigned __int8)v12 + 1024], 24)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE2(v10) + 1024], 8)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE1(v8) + 1024], 16);
    v12 = v6[3]
        ^ *(_DWORD *)&byte_384C4[4 * HIBYTE(v12) + 1024]
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * (unsigned __int8)v8 + 1024], 24)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE2(v11) + 1024], 8)
        ^ __ROR4__(*(_DWORD *)&byte_384C4[4 * BYTE1(v10) + 1024], 16);
    if ( v9 - 2 == v7 )
      break;
    ++v7;
    v11 = v15;
    v10 = v14;
    v8 = v13;
  }
  v16 = &v5[4 * v9 + 1073741820];
  *a2 = bswap32(
          *(_DWORD *)&byte_384C4[4 * BYTE1(v15) + 3072]
        & 0xFF00
        ^ v16[4]
        ^ byte_384C4[4 * (unsigned __int8)v14 + 3072]
        ^ (*(_DWORD *)&byte_384C4[4 * BYTE2(v12) + 3072] & 0xFF0000
         | *(_DWORD *)&byte_384C4[4 * HIBYTE(v13) + 3072] & 0xFF000000));
  a2[1] = bswap32(
            *(_DWORD *)&byte_384C4[4 * BYTE1(v12) + 3072]
          & 0xFF00
          ^ v16[5]
          ^ byte_384C4[4 * (unsigned __int8)v15 + 3072]
          ^ (*(_DWORD *)&byte_384C4[4 * BYTE2(v13) + 3072] & 0xFF0000
           | *(_DWORD *)&byte_384C4[4 * HIBYTE(v14) + 3072] & 0xFF000000));
  v17 = &byte_384C4[4 * BYTE1(v13)];
  v18 = byte_384C4[4 * (unsigned __int8)v13 + 3072];
  v19 = &byte_384C4[4 * BYTE2(v14)];
  v20 = *(_DWORD *)&byte_384C4[4 * BYTE1(v14) + 3072] & 0xFF00;
  v21 = *(_DWORD *)&byte_384C4[4 * HIBYTE(v12) + 3072] & 0xFF000000;
  a2[2] = bswap32(
            *((_DWORD *)v17 + 768)
          & 0xFF00
          ^ v16[6]
          ^ byte_384C4[4 * (unsigned __int8)v12 + 3072]
          ^ (*((_DWORD *)v19 + 768) & 0xFF0000 | *(_DWORD *)&byte_384C4[4 * HIBYTE(v15) + 3072] & 0xFF000000));
  a2[3] = bswap32((*(_DWORD *)&byte_384C4[4 * BYTE2(v15) + 3072] & 0xFF0000 | v21) ^ v20 ^ v18 ^ v16[7]);
  return 0;
}
// 384C4: using guessed type unsigned __int8 byte_384C4[4096];

//----- (0002437C) --------------------------------------------------------
int __fastcall sub_2437C(unsigned int *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // r2
  const char *v5; // r0
  bool v8; // zf
  int v9; // r3
  _DWORD *v10; // r5
  int v11; // r7
  unsigned int v12; // r8
  unsigned int v13; // r0
  int v14; // r3
  int v15; // r0
  int v16; // r3
  int v17; // r0
  int v18; // r3
  int v19; // r0
  _DWORD *v20; // r5
  int v21; // r8
  unsigned int v22; // r7
  unsigned int v23; // r0
  int v24; // r3
  int v25; // r0
  int v26; // r3
  int v27; // r0
  int v28; // r3
  int v29; // r0
  int v30; // r3
  int v31; // r0
  int v32; // r3
  int v33; // r0
  _DWORD *v34; // r5
  int v35; // r9
  unsigned int v36; // r7
  unsigned int v37; // r0
  int v38; // r3
  int v39; // r0
  int v40; // r3
  int v41; // r0
  int v42; // r3
  int v43; // r0
  int v44; // r3
  int v45; // r0
  unsigned int v46; // r0
  int v47; // r3
  int v48; // r0
  int v49; // r3
  int v50; // r0
  int v51; // r6
  int v52; // r7
  int v53; // r3
  unsigned int *v54; // r5
  _DWORD *v55; // r6

  if ( !a1 )
  {
    v4 = 129;
    v5 = "key != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v4 = 130;
    v5 = "skey != NULL";
LABEL_3:
    sub_26EB8(v5, "src/ciphers/aes/aes.c", v4);
  }
  v8 = (a2 & 0xFFFFFFF7) == 16;
  if ( (a2 & 0xFFFFFFF7) != 0x10 )
    v8 = a2 == 32;
  if ( !v8 )
    return 3;
  v9 = 2 * (a2 / 8 + 3);
  if ( a3 && a3 != v9 )
    return 4;
  a4[120] = v9;
  *a4 = bswap32(*a1);
  a4[1] = bswap32(a1[1]);
  a4[2] = bswap32(a1[2]);
  a4[3] = bswap32(a1[3]);
  switch ( a2 )
  {
    case 16:
      v10 = a4;
      v11 = 0;
      while ( 1 )
      {
        v12 = v10[3];
        v13 = sub_23C0C(v12);
        v14 = dword_394C4[v11++];
        v15 = v13 ^ *v10 ^ v14;
        v16 = v10[1];
        v10[4] = v15;
        v17 = v15 ^ v16;
        v18 = v10[2];
        v10[5] = v17;
        v19 = v17 ^ v18;
        v10[6] = v19;
        v10[7] = v19 ^ v12;
        if ( v11 == 10 )
          break;
        v10 += 4;
      }
      break;
    case 24:
      v20 = a4;
      v21 = 0;
      a4[4] = bswap32(a1[4]);
      a4[5] = bswap32(a1[5]);
      while ( 1 )
      {
        v22 = v20[5];
        v23 = sub_23C0C(v22);
        v24 = dword_394C4[v21++];
        v25 = v23 ^ *v20 ^ v24;
        v26 = v20[1];
        v20[6] = v25;
        v27 = v25 ^ v26;
        v28 = v20[2];
        v20[7] = v27;
        v29 = v27 ^ v28;
        v30 = v20[3];
        v20[8] = v29;
        v31 = v29 ^ v30;
        v20[9] = v31;
        if ( v21 == 8 )
          break;
        v32 = v20[4];
        v20 += 6;
        v33 = v31 ^ v32;
        v20[4] = v33;
        v20[5] = v33 ^ v22;
      }
      break;
    case 32:
      v34 = a4;
      v35 = 0;
      a4[4] = bswap32(a1[4]);
      a4[5] = bswap32(a1[5]);
      a4[6] = bswap32(a1[6]);
      a4[7] = bswap32(a1[7]);
      while ( 1 )
      {
        v36 = v34[7];
        v37 = sub_23C0C(v36);
        v38 = dword_394C4[v35++];
        v39 = v37 ^ *v34 ^ v38;
        v40 = v34[1];
        v34[8] = v39;
        v41 = v39 ^ v40;
        v42 = v34[2];
        v34[9] = v41;
        v43 = v41 ^ v42;
        v44 = v34[3];
        v34[10] = v43;
        v45 = v43 ^ v44;
        v34[11] = v45;
        if ( v35 == 7 )
          break;
        v34 += 8;
        v46 = sub_23C0C(__ROR4__(v45, 8)) ^ *(v34 - 4);
        v47 = *(v34 - 3);
        v34[4] = v46;
        v48 = v46 ^ v47;
        v49 = *(v34 - 2);
        v34[5] = v48;
        v50 = v48 ^ v49;
        v34[6] = v50;
        v34[7] = v36 ^ v50;
      }
      break;
    default:
      return 1;
  }
  v51 = a2 + 24;
  v52 = 1;
  v53 = a4[v51];
  v54 = &a4[v51];
  v55 = a4 + 60;
  a4[60] = v53;
  a4[61] = v54[1];
  a4[62] = v54[2];
  a4[63] = v54[3];
  while ( v52 < a4[120] )
  {
    ++v52;
    v55[4] = sub_23C50(*(v54 - 4));
    v54 -= 4;
    v55 += 4;
    v55[1] = sub_23C50(v54[1]);
    v55[2] = sub_23C50(v54[2]);
    v55[3] = sub_23C50(v54[3]);
  }
  v55[4] = *(v54 - 4);
  v55[5] = *(v54 - 3);
  v55[6] = *(v54 - 2);
  v55[7] = *(v54 - 1);
  return 0;
}
// 394C4: using guessed type _DWORD dword_394C4[10];

//----- (000246BC) --------------------------------------------------------
int sub_246BC()
{
  return 2;
}

//----- (000246C4) --------------------------------------------------------
int __fastcall sub_246C4(_DWORD *a1, int a2)
{
  int i; // r3
  int v3; // r11
  char *v4; // r2
  int v5; // r10
  int v6; // r9
  int v7; // r8
  int v8; // r3
  int v9; // t1
  int v10; // r12
  int v11; // r6
  int v12; // r5
  int v13; // r1
  int v14; // r7
  int v15; // r3
  int v16; // r2
  int v17; // r4
  int v18; // r2
  int v19; // r1
  int v20; // lr
  int v21; // r1
  int v22; // r6
  int v23; // r12
  int v24; // r6
  int v25; // r12
  int v26; // r2
  int v27; // r7
  int v28; // r2
  int v29; // r3
  _DWORD v31[64]; // [sp+4h] [bp-148h] BYREF
  char v32; // [sp+104h] [bp-48h] BYREF

  for ( i = 0; i != 16; ++i )
    v31[i + 1] = bswap32(*(_DWORD *)(a2 + i * 4));
  v3 = a1[2];
  v4 = (char *)v31;
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v31[0] = a1[6];
  do
  {
    v8 = *((_DWORD *)v4 + 14) ^ *((_DWORD *)v4 + 9) ^ *((_DWORD *)v4 + 3);
    v9 = *((_DWORD *)v4 + 1);
    v4 += 4;
    *((_DWORD *)v4 + 16) = __ROR4__(v8 ^ v9, 31);
  }
  while ( &v32 != v4 );
  v10 = v31[0];
  v11 = v7;
  v12 = v6;
  v13 = v5;
  v14 = v3;
  v15 = 0;
  while ( 1 )
  {
    v16 = v31[++v15];
    v17 = __ROR4__(v13, 2);
    v18 = v16 + __ROR4__(v14, 27) + 1518500249 + ((v12 ^ v11) & v13 ^ v11) + v10;
    v13 = v14;
    v10 = v11;
    if ( v15 == 20 )
      break;
    v11 = v12;
    v14 = v18;
    v12 = v17;
  }
  while ( 1 )
  {
    v19 = v31[++v15];
    v20 = __ROR4__(v14, 2);
    v21 = v19 + __ROR4__(v18, 27) + 1859775393 + (v14 ^ v17 ^ v12) + v11;
    v14 = v18;
    v11 = v12;
    if ( v15 == 40 )
      break;
    v12 = v17;
    v18 = v21;
    v17 = v20;
  }
  while ( 1 )
  {
    v22 = v31[++v15];
    v23 = ((v18 | v20) & v17 | v18 & v20) + v22 + __ROR4__(v21, 27) - 1894007588;
    v24 = __ROR4__(v18, 2);
    v25 = v23 + v12;
    v18 = v21;
    v12 = v17;
    if ( v15 == 60 )
      break;
    v17 = v20;
    v21 = v25;
    v20 = v24;
  }
  while ( 1 )
  {
    v26 = v31[++v15];
    v27 = __ROR4__(v21, 2);
    v28 = v26 + __ROR4__(v25, 27) - 899497514 + (v21 ^ v24 ^ v20) + v17;
    v21 = v25;
    v17 = v20;
    if ( v15 == 80 )
      break;
    v20 = v24;
    v25 = v28;
    v24 = v27;
  }
  v29 = v31[0];
  a1[2] = v3 + v28;
  a1[3] = v5 + v25;
  a1[4] = v6 + v27;
  a1[5] = v7 + v24;
  a1[6] = v29 + v20;
  return 0;
}

//----- (000248D4) --------------------------------------------------------
int __fastcall sub_248D4(_DWORD *a1, _DWORD *a2)
{
  int v3; // r2
  const char *v4; // r0
  _DWORD *v5; // r5
  unsigned int v6; // r3
  unsigned int v8; // r2
  __int64 v9; // r6
  bool v10; // cc
  char *v11; // r3
  unsigned int v12; // r3
  unsigned int *v13; // r3
  unsigned int *v14; // r4
  unsigned int v15; // t1
  unsigned int v16; // r3
  unsigned int v17; // [sp+4h] [bp-8h]

  if ( !a1 )
  {
    v3 = 195;
    v4 = "md != NULL";
    goto LABEL_3;
  }
  v5 = a2;
  if ( !a2 )
  {
    v3 = 196;
    v4 = "out != NULL";
LABEL_3:
    sub_26EB8(v4, "src/hashes/sha1.c", v3);
  }
  v6 = a1[7];
  if ( v6 > 0x3F )
    return 16;
  v8 = v6 + 1;
  v9 = *(_QWORD *)a1 + 8 * v6;
  v10 = v6 + 1 > 0x38;
  v11 = (char *)a1 + v6;
  a1[7] = v8;
  if ( v10 )
    LOBYTE(v8) = 0;
  *(_QWORD *)a1 = v9;
  v11[32] = 0x80;
  if ( v10 )
  {
    while ( 1 )
    {
      v16 = a1[7];
      if ( v16 > 0x3F )
        break;
      a1[7] = v16 + 1;
      *((_BYTE *)a1 + v16 + 32) = v8;
    }
    sub_246C4(a1, (int)(a1 + 8));
    a1[7] = 0;
  }
  while ( 1 )
  {
    v12 = a1[7];
    if ( v12 > 0x37 )
      break;
    a1[7] = v12 + 1;
    *((_BYTE *)a1 + v12 + 32) = 0;
  }
  v17 = bswap32(*a1);
  a1[22] = bswap32(a1[1]);
  a1[23] = v17;
  sub_246C4(a1, (int)(a1 + 8));
  v13 = a1 + 2;
  v14 = a1 + 7;
  do
  {
    v15 = *v13++;
    *v5++ = bswap32(v15);
  }
  while ( v13 != v14 );
  return 0;
}

//----- (00024A08) --------------------------------------------------------
int __fastcall sub_24A08(int a1)
{
  if ( !a1 )
    sub_26EB8("md != NULL", "src/hashes/sha1.c", 165);
  *(_QWORD *)(a1 + 8) = 0xEFCDAB8967452301LL;
  *(_QWORD *)(a1 + 16) = 0x1032547698BADCFELL;
  *(_DWORD *)(a1 + 24) = -1009589776;
  *(_DWORD *)(a1 + 28) = 0;
  *(_QWORD *)a1 = 0;
  return 0;
}

//----- (00024A78) --------------------------------------------------------
int __fastcall sub_24A78(unsigned int *a1, char *src, unsigned int a3)
{
  const char *v4; // r0
  char *v5; // r6
  __int64 v7; // r2
  __int64 v8; // r0
  bool v9; // cc
  int result; // r0
  unsigned int v11; // r0
  _BOOL4 v12; // r3
  size_t v13; // r7
  const void *v14; // r1
  bool v15; // cf
  char *v16; // r0
  size_t v17; // r3
  unsigned int v18; // r3
  unsigned int v19; // r2

  if ( !a1 )
  {
    v4 = "md != NULL";
    goto LABEL_3;
  }
  v5 = src;
  if ( !src )
  {
    v4 = "in != NULL";
LABEL_3:
    sub_26EB8(v4, "src/hashes/sha1.c", 183);
  }
  if ( a1[7] > 0x40 )
    return 16;
  v7 = *(_QWORD *)a1;
  v8 = *(_QWORD *)a1 + a3;
  v9 = a1[1] > HIDWORD(v8);
  if ( a1[1] == HIDWORD(v8) )
    v9 = (unsigned int)v7 > (unsigned int)v8;
  if ( v9 )
    return 25;
  while ( a3 )
  {
    v11 = a1[7];
    v12 = a3 > 0x3F;
    if ( v11 )
      v12 = 0;
    if ( v12 )
    {
      result = sub_246C4(a1, (int)v5);
      if ( result )
        return result;
      v5 += 64;
      a3 -= 64;
      *(_QWORD *)a1 += 512LL;
    }
    else
    {
      v13 = 64 - v11;
      v14 = v5;
      v15 = 64 - v11 >= a3;
      v16 = (char *)a1 + v11 + 32;
      if ( v15 )
        v13 = a3;
      v5 += v13;
      memcpy(v16, v14, v13);
      a3 -= v13;
      v17 = v13 + a1[7];
      a1[7] = v17;
      if ( v17 == 64 )
      {
        result = sub_246C4(a1, (int)(a1 + 8));
        if ( result )
          return result;
        v18 = *a1;
        v19 = a1[1];
        a1[7] = 0;
        *(_QWORD *)a1 = __PAIR64__(v19, v18) + 512;
      }
    }
  }
  return 0;
}

//----- (00024BC4) --------------------------------------------------------
int sub_24BC4()
{
  return 2;
}

//----- (00024BCC) --------------------------------------------------------
int __fastcall sub_24BCC(int a1, int a2)
{
  int *v2; // r0
  int *v3; // r2
  int i; // r3
  int v5; // t1
  int v6; // r2
  char *v7; // r3
  unsigned int v8; // r1
  char *v9; // r4
  unsigned int v10; // t1
  int v11; // r5
  int v12; // r1
  int v13; // r7
  int v14; // lr
  int v15; // r4
  int v16; // r2
  int v17; // r12
  int v18; // r6
  int v19; // r9
  int v20; // r3
  int v21; // r8
  int v22; // r3
  int v23; // r8
  int v24; // r3
  int v25; // r3
  int v26; // r2
  int v28; // [sp+8h] [bp-124h]
  int v29; // [sp+Ch] [bp-120h]
  int v30; // [sp+10h] [bp-11Ch]
  int v31; // [sp+14h] [bp-118h]
  int v32; // [sp+18h] [bp-114h]
  int v33; // [sp+1Ch] [bp-110h]
  int v34; // [sp+20h] [bp-10Ch]
  int v35; // [sp+24h] [bp-108h]
  _DWORD v36[48]; // [sp+28h] [bp-104h] BYREF
  char v37; // [sp+E8h] [bp-44h] BYREF

  v2 = (int *)(a1 + 8);
  v3 = v2;
  for ( i = 0; i != 8; ++i )
  {
    v5 = *v3++;
    *(&v28 + i) = v5;
  }
  v6 = 0;
  v7 = (char *)v36;
  do
  {
    v36[v6] = bswap32(*(_DWORD *)(a2 + v6 * 4));
    ++v6;
  }
  while ( v6 != 16 );
  do
  {
    v8 = *((_DWORD *)v7 + 14);
    v9 = v7;
    v10 = *((_DWORD *)v7 + 1);
    v7 += 4;
    *((_DWORD *)v7 + 15) = (__ROR4__(v8, 19) ^ __ROR4__(v8, 17) ^ (v8 >> 10))
                         + *((_DWORD *)v9 + 9)
                         + *(_DWORD *)v9
                         + (__ROR4__(v10, 18) ^ __ROR4__(v10, 7) ^ (v10 >> 3));
  }
  while ( &v37 != v7 );
  v11 = v35;
  v12 = v32;
  v13 = v33;
  v14 = v34;
  v15 = 0;
  v16 = v28;
  v17 = v29;
  v18 = v30;
  v19 = v31;
  while ( 1 )
  {
    v20 = (__ROR4__(v12, 11) ^ __ROR4__(v12, 6) ^ __ROR4__(v12, 25)) + ((v13 ^ v14) & v12 ^ v14) + v36[v15];
    v21 = dword_39634[v15++];
    v22 = v20 + v21 + v11;
    v23 = v19 + v22;
    v19 = v18;
    v24 = (__ROR4__(v16, 13) ^ __ROR4__(v16, 2) ^ __ROR4__(v16, 22)) + ((v17 | v16) & v18 | v17 & v16) + v22;
    v11 = v14;
    if ( v15 == 64 )
      break;
    v18 = v17;
    v14 = v13;
    v17 = v16;
    v13 = v12;
    v16 = v24;
    v12 = v23;
  }
  v28 = v24;
  v25 = 0;
  v35 = v14;
  v32 = v23;
  v34 = v13;
  v33 = v12;
  v29 = v16;
  v30 = v17;
  v31 = v18;
  do
  {
    v26 = *(&v28 + v25++);
    *v2++ += v26;
  }
  while ( v25 != 8 );
  return 0;
}
// 39634: using guessed type _DWORD dword_39634[64];

//----- (00024D6C) --------------------------------------------------------
int __fastcall sub_24D6C(unsigned int *a1, _DWORD *a2)
{
  int v3; // r2
  const char *v4; // r0
  _DWORD *v5; // r5
  unsigned int v6; // r3
  unsigned int v8; // r2
  __int64 v9; // r6
  bool v10; // cc
  char *v11; // r3
  unsigned int v12; // r3
  unsigned int *v13; // r3
  unsigned int *v14; // r4
  unsigned int v15; // t1
  unsigned int v16; // r3
  unsigned int v17; // [sp+4h] [bp-8h]

  if ( !a1 )
  {
    v3 = 240;
    v4 = "md != NULL";
    goto LABEL_3;
  }
  v5 = a2;
  if ( !a2 )
  {
    v3 = 241;
    v4 = "out != NULL";
LABEL_3:
    sub_26EB8(v4, "src/hashes/sha2/sha256.c", v3);
  }
  v6 = a1[10];
  if ( v6 > 0x3F )
    return 16;
  v8 = v6 + 1;
  v9 = *(_QWORD *)a1 + 8 * v6;
  v10 = v6 + 1 > 0x38;
  v11 = (char *)a1 + v6;
  a1[10] = v8;
  if ( v10 )
    LOBYTE(v8) = 0;
  *(_QWORD *)a1 = v9;
  v11[44] = 0x80;
  if ( v10 )
  {
    while ( 1 )
    {
      v16 = a1[10];
      if ( v16 > 0x3F )
        break;
      a1[10] = v16 + 1;
      *((_BYTE *)a1 + v16 + 44) = v8;
    }
    sub_24BCC((int)a1, (int)(a1 + 11));
    a1[10] = 0;
  }
  while ( 1 )
  {
    v12 = a1[10];
    if ( v12 > 0x37 )
      break;
    a1[10] = v12 + 1;
    *((_BYTE *)a1 + v12 + 44) = 0;
  }
  v17 = bswap32(*a1);
  a1[25] = bswap32(a1[1]);
  a1[26] = v17;
  sub_24BCC((int)a1, (int)(a1 + 11));
  v13 = a1 + 2;
  v14 = a1 + 10;
  do
  {
    v15 = *v13++;
    *v5++ = bswap32(v15);
  }
  while ( v13 != v14 );
  return 0;
}

//----- (00024EA0) --------------------------------------------------------
int __fastcall sub_24EA0(int a1)
{
  if ( !a1 )
    sub_26EB8("md != NULL", "src/hashes/sha2/sha256.c", 206);
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 8) = 1779033703;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = -1150833019;
  *(_DWORD *)(a1 + 16) = 1013904242;
  *(_DWORD *)(a1 + 20) = -1521486534;
  *(_DWORD *)(a1 + 24) = 1359893119;
  *(_DWORD *)(a1 + 28) = -1694144372;
  *(_DWORD *)(a1 + 32) = 528734635;
  *(_DWORD *)(a1 + 36) = 1541459225;
  return 0;
}

//----- (00024F3C) --------------------------------------------------------
int __fastcall sub_24F3C(__int64 *a1, char *src, unsigned int a3)
{
  const char *v4; // r0
  char *v5; // r6
  __int64 v7; // r2
  __int64 v8; // r0
  bool v9; // cc
  int result; // r0
  int v11; // r0
  _BOOL4 v12; // r3
  size_t v13; // r7
  const void *v14; // r1
  bool v15; // cf
  char *v16; // r0
  size_t v17; // r3
  unsigned int v18; // r3
  unsigned int v19; // r2

  if ( !a1 )
  {
    v4 = "md != NULL";
    goto LABEL_3;
  }
  v5 = src;
  if ( !src )
  {
    v4 = "in != NULL";
LABEL_3:
    sub_26EB8(v4, "src/hashes/sha2/sha256.c", 228);
  }
  if ( *((_DWORD *)a1 + 10) > 0x40u )
    return 16;
  v7 = *a1;
  v8 = *a1 + a3;
  v9 = *((_DWORD *)a1 + 1) > HIDWORD(v8);
  if ( *((_DWORD *)a1 + 1) == HIDWORD(v8) )
    v9 = (unsigned int)v7 > (unsigned int)v8;
  if ( v9 )
    return 25;
  while ( a3 )
  {
    v11 = *((_DWORD *)a1 + 10);
    v12 = a3 > 0x3F;
    if ( v11 )
      v12 = 0;
    if ( v12 )
    {
      result = sub_24BCC((int)a1, (int)v5);
      if ( result )
        return result;
      v5 += 64;
      a3 -= 64;
      *a1 += 512;
    }
    else
    {
      v13 = 64 - v11;
      v14 = v5;
      v15 = 64 - v11 >= a3;
      v16 = (char *)a1 + v11 + 44;
      if ( v15 )
        v13 = a3;
      v5 += v13;
      memcpy(v16, v14, v13);
      a3 -= v13;
      v17 = v13 + *((_DWORD *)a1 + 10);
      *((_DWORD *)a1 + 10) = v17;
      if ( v17 == 64 )
      {
        result = sub_24BCC((int)a1, (int)a1 + 44);
        if ( result )
          return result;
        v18 = *(_DWORD *)a1;
        v19 = *((_DWORD *)a1 + 1);
        *((_DWORD *)a1 + 10) = 0;
        *a1 = __PAIR64__(v19, v18) + 512;
      }
    }
  }
  return 0;
}

//----- (00025088) --------------------------------------------------------
int sub_25088()
{
  return 2;
}

//----- (00025090) --------------------------------------------------------
int __fastcall sub_25090(int a1)
{
  if ( !a1 )
    sub_26EB8("md != NULL", "src/hashes/sha2/sha384.c", 43);
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 8) = 0xCBBB9D5DC1059ED8LL;
  *(_QWORD *)(a1 + 16) = 0x629A292A367CD507LL;
  *(_QWORD *)(a1 + 24) = 0x9159015A3070DD17LL;
  *(_QWORD *)(a1 + 32) = 0x152FECD8F70E5939LL;
  *(_QWORD *)(a1 + 40) = 0x67332667FFC00B31LL;
  *(_QWORD *)(a1 + 48) = 0x8EB44A8768581511LL;
  *(_QWORD *)(a1 + 56) = 0xDB0C2E0D64F98FA7LL;
  *(_QWORD *)(a1 + 64) = 0x47B5481DBEFA4FA4LL;
  return 0;
}

//----- (00025170) --------------------------------------------------------
int __fastcall sub_25170(unsigned int *a1, int a2)
{
  int v2; // r2
  const char *v3; // r0
  _DWORD *v6; // r2
  int v7; // r3
  int v8; // r1
  bool v9; // zf
  _BYTE v10[48]; // [sp+0h] [bp-40h] BYREF
  char v11; // [sp+30h] [bp-10h] BYREF

  if ( !a1 )
  {
    v2 = 68;
    v3 = "md != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v2 = 69;
    v3 = "out != NULL";
LABEL_3:
    sub_26EB8(v3, "src/hashes/sha2/sha384.c", v2);
  }
  if ( a1[18] > 0x7F )
    return 16;
  sub_25630(a1, (int)v10);
  v6 = v10;
  v7 = a2;
  do
  {
    v7 += 8;
    v8 = v6[1];
    v9 = v6 + 2 == (_DWORD *)&v11;
    *(_DWORD *)(v7 - 8) = *v6;
    *(_DWORD *)(v7 - 4) = v8;
    v6 += 2;
  }
  while ( !v9 );
  return 0;
}

//----- (00025208) --------------------------------------------------------
int sub_25208()
{
  return 2;
}

//----- (00025210) --------------------------------------------------------
int __fastcall sub_25210(int a1, int a2)
{
  _QWORD *v2; // r9
  __int64 *v4; // r2
  int i; // r3
  __int64 v6; // t1
  int *v7; // r12
  int v8; // r2
  unsigned int *v9; // lr
  unsigned int v10; // r0
  unsigned int v11; // r1
  __int64 v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  int *v15; // r6
  unsigned int v16; // r5
  unsigned int v17; // lr
  int v18; // r6
  unsigned int v19; // r4
  unsigned int v20; // lr
  unsigned __int64 v21; // kr08_8
  unsigned int v22; // r0
  unsigned int v23; // r12
  unsigned __int64 v24; // kr10_8
  unsigned int v25; // r5
  unsigned int v26; // r11
  int v27; // r2
  int v28; // r10
  int v29; // r8
  _BYTE *v30; // r3
  unsigned __int64 v31; // kr18_8
  int v32; // r2
  unsigned __int64 v33; // kr20_8
  int j; // r3
  char *v35; // r12
  unsigned int v36; // r2
  unsigned int v38; // r3
  int v39; // r3
  int v40; // r3
  unsigned int v41; // [sp+0h] [bp-2FCh]
  unsigned __int64 v42; // [sp+4h] [bp-2F8h]
  unsigned int v43; // [sp+Ch] [bp-2F0h]
  unsigned int v44; // [sp+10h] [bp-2ECh]
  unsigned __int64 v45; // [sp+14h] [bp-2E8h]
  unsigned __int64 v46; // [sp+1Ch] [bp-2E0h]
  unsigned int v47; // [sp+24h] [bp-2D8h]
  int v48; // [sp+30h] [bp-2CCh]
  unsigned __int64 v49; // [sp+30h] [bp-2CCh]
  unsigned __int64 v50; // [sp+38h] [bp-2C4h] BYREF
  unsigned int v51; // [sp+40h] [bp-2BCh]
  unsigned int v52; // [sp+44h] [bp-2B8h]
  unsigned int v53; // [sp+48h] [bp-2B4h]
  unsigned int v54; // [sp+4Ch] [bp-2B0h]
  unsigned int v55; // [sp+50h] [bp-2ACh]
  unsigned int v56; // [sp+54h] [bp-2A8h]
  unsigned __int64 v57; // [sp+58h] [bp-2A4h]
  unsigned __int64 v58; // [sp+60h] [bp-29Ch]
  unsigned __int64 v59; // [sp+68h] [bp-294h]
  unsigned __int64 v60; // [sp+70h] [bp-28Ch]
  _BYTE v61[512]; // [sp+78h] [bp-284h] BYREF
  int v62; // [sp+278h] [bp-84h] BYREF

  v2 = (_QWORD *)(a1 + 8);
  v4 = (__int64 *)(a1 + 8);
  for ( i = 0; i != 64; i += 8 )
  {
    v6 = *v4++;
    *(unsigned __int64 *)((char *)&v50 + i) = v6;
  }
  v7 = (int *)v61;
  v8 = 0;
  v9 = (unsigned int *)v61;
  do
  {
    v10 = *(_DWORD *)(a2 + v8);
    v11 = *(_DWORD *)(a2 + v8 + 4);
    v8 += 8;
    *v9 = v10;
    v9[1] = v11;
    HIDWORD(v12) = bswap32(v10);
    v13 = v9[1];
    v9 += 2;
    LODWORD(v12) = bswap32(v13);
    *((_QWORD *)v9 - 1) = v12;
  }
  while ( v8 != 128 );
  do
  {
    v14 = v7[28];
    v15 = v7;
    v16 = v7[29];
    v7 += 2;
    v17 = v7[1];
    *((_QWORD *)v7 + 15) = __PAIR64__(
                             ((v16 >> 19) | (v14 << 13)) ^ ((8 * v16) | (v14 >> 29)) ^ (v16 >> 6),
                             ((8 * v14) | (v16 >> 29)) ^ ((v14 >> 19) | (v16 << 13)) ^ ((v14 >> 6) | (v16 << 26)))
                         + *((_QWORD *)v15 + 9)
                         + *(_QWORD *)v15
                         + __PAIR64__(
                             ((v17 >> 1) | (*v7 << 31)) ^ ((v17 >> 8) | (*v7 << 24)) ^ (v17 >> 7),
                             (*(__int64 *)v7 >> 7) ^ (*(__int64 *)v7 >> 1) ^ (*(__int64 *)v7 >> 8));
  }
  while ( &v62 != v7 );
  v18 = 0;
  v21 = v57;
  v20 = HIDWORD(v21);
  v19 = v21;
  v46 = v60;
  v24 = v50;
  v22 = HIDWORD(v24);
  v23 = v24;
  v25 = v52;
  v26 = v56;
  v42 = v59;
  v45 = v58;
  v41 = v51;
  v43 = v53;
  v44 = v54;
  v47 = v55;
  while ( 1 )
  {
    v27 = ((v19 >> 14) | (v20 << 18)) ^ ((v19 >> 18) | (v20 << 14)) ^ ((v19 << 23) | (v20 >> 9));
    v28 = *(_DWORD *)((char *)&unk_39840 + v18);
    v29 = *(_DWORD *)((char *)&unk_39840 + v18 + 4);
    v48 = *(_DWORD *)&v61[v18];
    v30 = &v61[v18];
    v18 += 8;
    v31 = __PAIR64__(
            *((_DWORD *)v30 + 1)
          + __CFADD__(v28, v48)
          + v29
          + __CFADD__(v27, v28 + v48)
          + (((v20 >> 14) | (v19 << 18)) ^ ((v20 >> 18) | (v19 << 14)) ^ ((v20 << 23) | (v19 >> 9))),
            v27 + v28 + v48)
        + __PAIR64__((HIDWORD(v45) ^ HIDWORD(v42)) & v20 ^ HIDWORD(v42), (v45 ^ v42) & v19 ^ v42)
        + v46;
    v49 = __PAIR64__(v26, v47) + v31;
    v32 = ((v23 << 30) | (v22 >> 2)) ^ ((v23 >> 28) | (16 * v22)) ^ ((v23 << 25) | (v22 >> 7));
    v33 = __PAIR64__(
            ((v25 | v22) & v44 | v25 & v22)
          + __CFADD__(v32, (v41 | v23) & v43 | v41 & v23)
          + (((v22 << 30) | (v23 >> 2)) ^ ((v22 >> 28) | (16 * v23)) ^ ((v22 << 25) | (v23 >> 7))),
            v32 + ((v41 | v23) & v43 | v41 & v23))
        + v31;
    v46 = v42;
    v47 = v43;
    v26 = v44;
    if ( v18 == 640 )
      break;
    v38 = v41;
    v44 = v25;
    v25 = v22;
    v41 = v23;
    v22 = HIDWORD(v33);
    v43 = v38;
    v23 = v33;
    v39 = v45;
    LODWORD(v45) = v19;
    v19 = v49;
    LODWORD(v42) = v39;
    v40 = HIDWORD(v45);
    HIDWORD(v45) = v20;
    v20 = HIDWORD(v49);
    HIDWORD(v42) = v40;
  }
  v58 = __PAIR64__(v20, v19);
  v60 = v42;
  v50 = __PAIR64__(
          ((v25 | v22) & v44 | v25 & v22)
        + __CFADD__(v32, (v41 | v23) & v43 | v41 & v23)
        + (((v22 << 30) | (v23 >> 2)) ^ ((v22 >> 28) | (16 * v23)) ^ ((v22 << 25) | (v23 >> 7))),
          v32 + ((v41 | v23) & v43 | v41 & v23))
      + v31;
  v51 = v23;
  v52 = v22;
  v57 = v49;
  v54 = v25;
  v56 = v44;
  v59 = v45;
  v53 = v41;
  v55 = v43;
  for ( j = 0; j != 64; j += 8 )
  {
    v35 = (char *)&v50 + j;
    v36 = *(_DWORD *)((char *)&v50 + j);
    *v2++ += __PAIR64__(*((_DWORD *)v35 + 1), v36);
  }
  return 0;
}

//----- (00025630) --------------------------------------------------------
int __fastcall sub_25630(unsigned int *a1, int a2)
{
  int v3; // r2
  const char *v4; // r0
  unsigned int v6; // r1
  unsigned int v8; // r3
  unsigned int *v9; // r2
  int v10; // r3
  unsigned int *v11; // r4
  unsigned int v12; // r1
  unsigned int v13; // r0
  unsigned int v14; // r3
  unsigned int v15; // [sp+4h] [bp-8h]

  if ( !a1 )
  {
    v3 = 208;
    v4 = "md != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 209;
    v4 = "out != NULL";
LABEL_3:
    sub_26EB8(v4, "src/hashes/sha2/sha512.c", v3);
  }
  v6 = a1[18];
  if ( v6 > 0x7F )
    return 16;
  *(_QWORD *)a1 += 8LL * v6;
  a1[18] = v6 + 1;
  *((_BYTE *)a1 + v6 + 76) = 0x80;
  if ( v6 + 1 > 0x70 )
  {
    while ( 1 )
    {
      v14 = a1[18];
      if ( v14 > 0x7F )
        break;
      a1[18] = v14 + 1;
      *((_BYTE *)a1 + v14 + 76) = 0;
    }
    sub_25210((int)a1, (int)(a1 + 19));
    a1[18] = 0;
  }
  while ( 1 )
  {
    v8 = a1[18];
    if ( v8 > 0x77 )
      break;
    a1[18] = v8 + 1;
    *((_BYTE *)a1 + v8 + 76) = 0;
  }
  v15 = bswap32(*a1);
  a1[49] = bswap32(a1[1]);
  a1[50] = v15;
  sub_25210((int)a1, (int)(a1 + 19));
  v9 = a1 + 2;
  v10 = a2;
  v11 = a1 + 18;
  do
  {
    v12 = *v9;
    v13 = v9[1];
    v9 += 2;
    v10 += 8;
    *(_DWORD *)(v10 - 8) = bswap32(v13);
    *(_DWORD *)(v10 - 4) = bswap32(v12);
  }
  while ( v9 != v11 );
  return 0;
}

//----- (00025784) --------------------------------------------------------
int __fastcall sub_25784(int a1)
{
  if ( !a1 )
    sub_26EB8("md != NULL", "src/hashes/sha2/sha512.c", 175);
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 8) = 0x6A09E667F3BCC908LL;
  *(_QWORD *)(a1 + 16) = 0xBB67AE8584CAA73BLL;
  *(_QWORD *)(a1 + 24) = 0x3C6EF372FE94F82BLL;
  *(_QWORD *)(a1 + 32) = 0xA54FF53A5F1D36F1LL;
  *(_QWORD *)(a1 + 40) = 0x510E527FADE682D1LL;
  *(_QWORD *)(a1 + 48) = 0x9B05688C2B3E6C1FLL;
  *(_QWORD *)(a1 + 56) = 0x1F83D9ABFB41BD6BLL;
  *(_QWORD *)(a1 + 64) = 0x5BE0CD19137E2179LL;
  return 0;
}

//----- (00025860) --------------------------------------------------------
int __fastcall sub_25860(__int64 *a1, char *src, unsigned int a3)
{
  const char *v4; // r0
  char *v5; // r6
  __int64 v7; // r2
  __int64 v8; // r0
  bool v9; // cc
  int result; // r0
  int v11; // r0
  _BOOL4 v12; // r3
  size_t v13; // r7
  const void *v14; // r1
  bool v15; // cf
  char *v16; // r0
  size_t v17; // r3
  unsigned int v18; // r3
  unsigned int v19; // r2

  if ( !a1 )
  {
    v4 = "md != NULL";
    goto LABEL_3;
  }
  v5 = src;
  if ( !src )
  {
    v4 = "in != NULL";
LABEL_3:
    sub_26EB8(v4, "src/hashes/sha2/sha512.c", 196);
  }
  if ( *((_DWORD *)a1 + 18) > 0x80u )
    return 16;
  v7 = *a1;
  v8 = *a1 + a3;
  v9 = *((_DWORD *)a1 + 1) > HIDWORD(v8);
  if ( *((_DWORD *)a1 + 1) == HIDWORD(v8) )
    v9 = (unsigned int)v7 > (unsigned int)v8;
  if ( v9 )
    return 25;
  while ( a3 )
  {
    v11 = *((_DWORD *)a1 + 18);
    v12 = a3 > 0x7F;
    if ( v11 )
      v12 = 0;
    if ( v12 )
    {
      result = sub_25210((int)a1, (int)v5);
      if ( result )
        return result;
      v5 += 128;
      a3 -= 128;
      *a1 += 1024;
    }
    else
    {
      v13 = 128 - v11;
      v14 = v5;
      v15 = 128 - v11 >= a3;
      v16 = (char *)a1 + v11 + 76;
      if ( v15 )
        v13 = a3;
      v5 += v13;
      memcpy(v16, v14, v13);
      a3 -= v13;
      v17 = v13 + *((_DWORD *)a1 + 18);
      *((_DWORD *)a1 + 18) = v17;
      if ( v17 == 128 )
      {
        result = sub_25210((int)a1, (int)a1 + 76);
        if ( result )
          return result;
        v18 = *(_DWORD *)a1;
        v19 = *((_DWORD *)a1 + 1);
        *((_DWORD *)a1 + 18) = 0;
        *a1 = __PAIR64__(v19, v18) + 1024;
      }
    }
  }
  return 0;
}

//----- (000259AC) --------------------------------------------------------
int __fastcall sub_259AC(int a1, int a2, unsigned int *a3)
{
  int v4; // r2
  const char *v5; // r0
  unsigned int v7; // r10
  int v9; // r4
  _DWORD *v10; // r11
  int v11; // r8
  int v12; // r2
  _DWORD *v14; // r5
  unsigned int i; // r3
  _BYTE v16[128]; // [sp+0h] [bp-104h] BYREF
  _BYTE v17[132]; // [sp+80h] [bp-84h] BYREF

  if ( !a1 )
  {
    v4 = 33;
    v5 = "hmac != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 34;
    v5 = "out != NULL";
LABEL_3:
    sub_26EB8(v5, "src/mac/hmac/hmac_done.c", v4);
  }
  v7 = *(_DWORD *)(a1 + 208);
  v9 = sub_26FBC(v7);
  if ( !v9 )
  {
    v10 = &dword_4C47C[26 * v7];
    v11 = v10[2];
    v9 = ((int (__fastcall *)(int, _BYTE *))v10[23])(a1, v17);
    if ( !v9 )
    {
      v12 = v10[3];
      while ( v12 != v9 )
      {
        v16[v9] = *(_BYTE *)(*(_DWORD *)(a1 + 424) + v9) ^ 0x5C;
        ++v9;
      }
      v14 = &dword_4C47C[26 * v7];
      v9 = ((int (__fastcall *)(int))v14[21])(a1);
      if ( !v9 )
      {
        v9 = ((int (__fastcall *)(int, _BYTE *, _DWORD))v14[22])(a1, v16, v14[3]);
        if ( !v9 )
        {
          v9 = ((int (__fastcall *)(int, _BYTE *, int))v14[22])(a1, v17, v11);
          if ( !v9 )
          {
            v9 = ((int (__fastcall *)(int, _BYTE *))v14[23])(a1, v16);
            if ( !v9 )
            {
              for ( i = 0; i != v11 && *a3 > i; ++i )
                *(_BYTE *)(a2 + i) = v16[i];
              *a3 = i;
            }
          }
        }
      }
    }
    free(*(void **)(a1 + 424));
  }
  return v9;
}
// 4C47C: using guessed type _DWORD dword_4C47C[130];

//----- (00025B04) --------------------------------------------------------
int __fastcall sub_25B04(int a1, unsigned int a2, const void *a3, size_t a4)
{
  int v5; // r2
  const char *v6; // r0
  int v10; // r6
  _DWORD *v11; // r3
  size_t v12; // r6
  size_t v13; // r9
  void *v14; // r0
  unsigned int v15; // r1
  int v16; // r1
  int i; // r3
  _DWORD *v18; // r4
  size_t v20; // [sp+Ch] [bp-84h] BYREF
  _BYTE v21[128]; // [sp+10h] [bp-80h] BYREF

  if ( !a1 )
  {
    v5 = 35;
    v6 = "hmac != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v5 = 36;
    v6 = "key != NULL";
LABEL_3:
    sub_26EB8(v6, "src/mac/hmac/hmac_init.c", v5);
  }
  v10 = sub_26FBC(a2);
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 208) = a2;
    if ( !a4 )
      return 3;
    v11 = &dword_4C47C[26 * a2];
    v12 = v11[3];
    v13 = v11[2];
    v14 = malloc(v12);
    *(_DWORD *)(a1 + 424) = v14;
    if ( !v14 )
      return 13;
    if ( v12 >= a4 )
    {
      memcpy(v14, a3, a4);
      v13 = a4;
    }
    else
    {
      v20 = v12;
      v10 = sub_29768(a2, (int)a3, a4, (int)v14, &v20);
      if ( v10 )
      {
LABEL_19:
        free(*(void **)(a1 + 424));
        return v10;
      }
    }
    v15 = dword_4C47C[26 * a2 + 3];
    if ( v15 > v13 )
      j_j_explicit_bzero(*(_DWORD *)(a1 + 424) + v13, v15 - v13);
    v16 = dword_4C47C[26 * a2 + 3];
    for ( i = 0; v16 != i; ++i )
      v21[i] = *(_BYTE *)(*(_DWORD *)(a1 + 424) + i) ^ 0x36;
    v18 = &dword_4C47C[26 * a2];
    v10 = ((int (__fastcall *)(int))v18[21])(a1);
    if ( v10 )
      goto LABEL_19;
    v10 = ((int (__fastcall *)(int, _BYTE *, _DWORD))v18[22])(a1, v21, v18[3]);
    if ( v10 )
      goto LABEL_19;
  }
  return v10;
}
// 271F4: using guessed type int __fastcall j_j_explicit_bzero(_DWORD, _DWORD);
// 4C47C: using guessed type _DWORD dword_4C47C[130];

//----- (00025C88) --------------------------------------------------------
int __fastcall sub_25C88(int a1, int a2, int a3)
{
  int v4; // r2
  const char *v5; // r0
  int result; // r0

  if ( !a1 )
  {
    v4 = 28;
    v5 = "hmac != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 29;
    v5 = "in != NULL";
LABEL_3:
    sub_26EB8(v5, "src/mac/hmac/hmac_process.c", v4);
  }
  result = sub_26FBC(*(_DWORD *)(a1 + 208));
  if ( !result )
    return ((int (__fastcall *)(int, int, int))dword_4C47C[26 * *(_DWORD *)(a1 + 208) + 22])(a1, a2, a3);
  return result;
}
// 4C47C: using guessed type _DWORD dword_4C47C[130];

//----- (00025D08) --------------------------------------------------------
int __fastcall sub_25D08(int a1)
{
  if ( a1 )
  {
    if ( a1 == -2 )
    {
      a1 = 1;
    }
    else
    {
      if ( a1 != -3 )
        return 1;
      a1 = 2;
    }
  }
  return dword_39BA4[2 * a1 + 1];
}
// 39BA4: using guessed type _DWORD dword_39BA4[3];

//----- (00025DB8) --------------------------------------------------------
int __fastcall sub_25DB8(int *a1, int a2)
{
  int v2; // r0

  if ( !a1 )
    sub_26EB8("a != NULL", "src/math/ltm_desc.c", 416);
  v2 = sub_2DB1C(a1, a2);
  return sub_25D08(v2);
}

//----- (00025DE8) --------------------------------------------------------
int __fastcall sub_25DE8(int *a1, int *a2, int *a3, int *a4)
{
  int v4; // r2
  const char *v5; // r0
  int v6; // r0

  if ( !a1 )
  {
    v4 = 320;
    v5 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 321;
    v5 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v4 = 322;
    v5 = "c != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v4 = 323;
    v5 = "d != NULL";
LABEL_3:
    sub_26EB8(v5, "src/math/ltm_desc.c", v4);
  }
  v6 = sub_2E954(a1, a2, a3, a4);
  return sub_25D08(v6);
}

//----- (00025E60) --------------------------------------------------------
int __fastcall sub_25E60(int *a1, int *a2, int *a3, int *a4)
{
  int v4; // r2
  const char *v5; // r0
  int v6; // r0

  if ( !a1 )
  {
    v4 = 311;
    v5 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 312;
    v5 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v4 = 313;
    v5 = "c != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v4 = 314;
    v5 = "d != NULL";
LABEL_3:
    sub_26EB8(v5, "src/math/ltm_desc.c", v4);
  }
  v6 = sub_29B48(a1, a2, a3, a4);
  return sub_25D08(v6);
}

//----- (00025ED8) --------------------------------------------------------
int __fastcall sub_25ED8(int *a1, int a2, _DWORD *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v6; // r0
  int result; // r0

  if ( !a1 )
  {
    v3 = 404;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 405;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  if ( !a2 )
    a2 = 40;
  v6 = sub_2CDA4(a1, a2, a3);
  result = sub_25D08(v6);
  *a3 = *a3 == 1;
  return result;
}

//----- (00025F40) --------------------------------------------------------
int __fastcall sub_25F40(int *a1, int *a2, int a3, int *a4)
{
  int v4; // r2
  const char *v5; // r0
  int v6; // r0

  if ( !a1 )
  {
    v4 = 394;
    v5 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 395;
    v5 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v4 = 396;
    v5 = "c != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v4 = 397;
    v5 = "d != NULL";
LABEL_3:
    sub_26EB8(v5, "src/math/ltm_desc.c", v4);
  }
  v6 = sub_2AB08(a1, a2, a3, a4);
  return sub_25D08(v6);
}

//----- (00025FB8) --------------------------------------------------------
int __fastcall sub_25FB8(int *a1, int *a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 380;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 381;
    v4 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 382;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2C7D0(a1, a2, *a3);
  return sub_25D08(v5);
}

//----- (0002601C) --------------------------------------------------------
int __fastcall sub_2601C(int *a1, int *a2)
{
  int v2; // r2
  const char *v3; // r0
  int v4; // r0

  if ( !a1 )
  {
    v2 = 372;
    v3 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v2 = 373;
    v3 = "b != NULL";
LABEL_3:
    sub_26EB8(v3, "src/math/ltm_desc.c", v2);
  }
  v4 = sub_2C528(a1, a2);
  return sub_25D08(v4);
}

//----- (00026064) --------------------------------------------------------
int __fastcall sub_26064(int a1, void **a2)
{
  int v3; // r2
  const char *v4; // r0
  int *v6; // r1
  int v7; // r5
  int v8; // r0

  if ( !a1 )
  {
    v3 = 357;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 358;
    v4 = "b != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v6 = (int *)calloc(1u, 4u);
  *a2 = v6;
  if ( !v6 )
    return 13;
  v8 = sub_2C930(a1, v6);
  v7 = sub_25D08(v8);
  if ( v7 )
    free(*a2);
  return v7;
}

//----- (000260E8) --------------------------------------------------------
int __fastcall sub_260E8(int *a1, int a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 347;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 348;
    v4 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 349;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2BBA8(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (00026148) --------------------------------------------------------
int __fastcall sub_26148(int *a1, int *a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 338;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 339;
    v4 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 340;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2E6F8(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (000261A8) --------------------------------------------------------
int __fastcall sub_261A8(int *a1, int *a2, int *a3, int *a4)
{
  int v4; // r2
  const char *v5; // r0
  int v6; // r0

  if ( !a1 )
  {
    v4 = 329;
    v5 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 330;
    v5 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v4 = 331;
    v5 = "c != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v4 = 332;
    v5 = "d != NULL";
LABEL_3:
    sub_26EB8(v5, "src/math/ltm_desc.c", v4);
  }
  v6 = sub_2CCE0(a1, a2, a3, a4);
  return sub_25D08(v6);
}

//----- (00026220) --------------------------------------------------------
int __fastcall sub_26220(int *a1, int *a2, int *a3, int a4)
{
  int v4; // r2
  const char *v5; // r0
  int v6; // r0

  if ( !a1 )
  {
    v4 = 303;
    v5 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 304;
    v5 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v4 = 305;
    v5 = "c != NULL";
LABEL_3:
    sub_26EB8(v5, "src/math/ltm_desc.c", v4);
  }
  v6 = sub_2C074(a1, a2, a3, a4);
  return sub_25D08(v6);
}

//----- (00026280) --------------------------------------------------------
int __fastcall sub_26280(int *a1, int *a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 294;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 295;
    v4 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 296;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2B818(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (000262E0) --------------------------------------------------------
int __fastcall sub_262E0(int a1, unsigned int a2, unsigned int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v6; // r0
  int result; // r0
  unsigned int v8; // [sp+4h] [bp-4h] BYREF

  v8 = a2;
  if ( !a1 )
  {
    v3 = 281;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 282;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v6 = sub_2C51C(a1, a2, (int *)&v8);
  result = sub_25D08(v6);
  if ( !result )
    *a3 = v8;
  return result;
}

//----- (00026340) --------------------------------------------------------
int __fastcall sub_26340(int *a1, int *a2)
{
  int v2; // r2
  const char *v3; // r0
  int v4; // r0

  if ( !a1 )
  {
    v2 = 270;
    v3 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v2 = 271;
    v3 = "b != NULL";
LABEL_3:
    sub_26EB8(v3, "src/math/ltm_desc.c", v2);
  }
  v4 = sub_2A350(a1, a2);
  return sub_25D08(v4);
}

//----- (00026388) --------------------------------------------------------
int __fastcall sub_26388(int *a1, int *a2, int *a3, int *a4)
{
  int v4; // r2
  const char *v5; // r0
  int v6; // r0

  if ( !a1 )
  {
    v4 = 263;
    v5 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 264;
    v5 = "b != NULL";
LABEL_3:
    sub_26EB8(v5, "src/math/ltm_desc.c", v4);
  }
  v6 = sub_2A5A8(a1, a2, a3, a4);
  return sub_25D08(v6);
}

//----- (000263D0) --------------------------------------------------------
int __fastcall sub_263D0(int *a1, int *a2)
{
  int v2; // r2
  const char *v3; // r0
  int v4; // r0

  if ( !a1 )
  {
    v2 = 255;
    v3 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v2 = 256;
    v3 = "b != NULL";
LABEL_3:
    sub_26EB8(v3, "src/math/ltm_desc.c", v2);
  }
  v4 = sub_2E6C0(a1, a2);
  return sub_25D08(v4);
}

//----- (00026418) --------------------------------------------------------
int __fastcall sub_26418(int *a1, unsigned int a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 247;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 248;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2CBE4(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (00026460) --------------------------------------------------------
int __fastcall sub_26460(int *a1, int *a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 239;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 240;
    v4 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 241;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2CB6C(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (000264C0) --------------------------------------------------------
int __fastcall sub_264C0(int *a1, unsigned int a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 231;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 232;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2E7D4(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (00026508) --------------------------------------------------------
int __fastcall sub_26508(int *a1, int *a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 223;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 224;
    v4 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 225;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2E764(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (00026568) --------------------------------------------------------
int __fastcall sub_26568(int *a1, unsigned int a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 215;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 216;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2999C(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (000265B0) --------------------------------------------------------
int __fastcall sub_265B0(int *a1, int *a2, int *a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 207;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 208;
    v4 = "b != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v3 = 209;
    v4 = "c != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_29934(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (00026610) --------------------------------------------------------
int __fastcall sub_26610(int a1, unsigned __int8 *a2, int a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 199;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 200;
    v4 = "b != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2DE30(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (00026658) --------------------------------------------------------
int __fastcall sub_26658(int *a1, _BYTE *a2)
{
  int v2; // r2
  const char *v3; // r0
  int v4; // r0

  if ( !a1 )
  {
    v2 = 191;
    v3 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v2 = 192;
    v3 = "b != NULL";
LABEL_3:
    sub_26EB8(v3, "src/math/ltm_desc.c", v2);
  }
  v4 = sub_2EACC(a1, a2);
  return sub_25D08(v4);
}

//----- (000266C8) --------------------------------------------------------
int __fastcall sub_266C8(int *a1, _BYTE *a2, unsigned int a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 176;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 177;
    v4 = "b != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2E9C8(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (00026710) --------------------------------------------------------
int __fastcall sub_26710(int *a1, _BYTE *a2, signed int a3)
{
  int v3; // r2
  const char *v4; // r0
  int v5; // r0

  if ( !a1 )
  {
    v3 = 168;
    v4 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v3 = 169;
    v4 = "b != NULL";
LABEL_3:
    sub_26EB8(v4, "src/math/ltm_desc.c", v3);
  }
  v5 = sub_2DCD0(a1, a2, a3);
  return sub_25D08(v5);
}

//----- (00026758) --------------------------------------------------------
int __fastcall sub_26758(_DWORD *a1, int a2)
{
  int v2; // r0

  if ( !a1 )
    sub_26EB8("a != NULL", "src/math/ltm_desc.c", 159);
  v2 = sub_298D4(a1, a2);
  return sub_25D08(v2);
}

//----- (000267D8) --------------------------------------------------------
int __fastcall sub_267D8(int a1, unsigned int a2)
{
  unsigned int v2; // r0

  if ( !a1 )
    sub_26EB8("a != NULL", "src/math/ltm_desc.c", 134);
  v2 = sub_29E48(a1, a2) + 1;
  if ( v2 > 2 )
    return 0;
  else
    return *((char *)&dword_39BA4[6] + v2);
}
// 39BA4: using guessed type _DWORD dword_39BA4[3];

//----- (00026820) --------------------------------------------------------
int __fastcall sub_26820(int *a1, int *a2)
{
  int v2; // r2
  const char *v3; // r0
  unsigned int v4; // r0

  if ( !a1 )
  {
    v2 = 120;
    v3 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v2 = 121;
    v3 = "b != NULL";
LABEL_3:
    sub_26EB8(v3, "src/math/ltm_desc.c", v2);
  }
  v4 = sub_29E00(a1, a2) + 1;
  if ( v4 > 2 )
    return 0;
  else
    return byte_39BBC[v4];
}

//----- (000268A4) --------------------------------------------------------
int __fastcall sub_268A4(int *a1, unsigned int a2)
{
  int v2; // r0

  if ( !a1 )
    sub_26EB8("a != NULL", "src/math/ltm_desc.c", 91);
  v2 = sub_2E65C(a1, a2);
  return sub_25D08(v2);
}

//----- (000268D4) --------------------------------------------------------
int __fastcall sub_268D4(int *a1, int *a2)
{
  int v2; // r2
  const char *v3; // r0
  int v4; // r0

  if ( !a1 )
  {
    v2 = 75;
    v3 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v2 = 76;
    v3 = "b != NULL";
LABEL_3:
    sub_26EB8(v3, "src/math/ltm_desc.c", v2);
  }
  v4 = sub_2A25C(a1, a2);
  return sub_25D08(v4);
}

//----- (0002691C) --------------------------------------------------------
int __fastcall sub_2691C(int *a1, int *a2)
{
  int v2; // r2
  const char *v3; // r0
  int v4; // r0

  if ( !a1 )
  {
    v2 = 68;
    v3 = "a != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v2 = 69;
    v3 = "b != NULL";
LABEL_3:
    sub_26EB8(v3, "src/math/ltm_desc.c", v2);
  }
  v4 = sub_2CD58(a1, a2);
  return sub_25D08(v4);
}

//----- (00026964) --------------------------------------------------------
void __fastcall sub_26964(void *a1)
{
  if ( !a1 )
    sub_26EB8("a != NULL", "src/math/ltm_desc.c", 61);
  sub_29D74((int)a1);
  free(a1);
}

//----- (00026998) --------------------------------------------------------
int __fastcall sub_26998(void **a1)
{
  void *v2; // r0
  int v3; // r4
  int v4; // r0

  if ( !a1 )
    sub_26EB8("a != NULL", "src/math/ltm_desc.c", 46);
  v2 = calloc(1u, 0x10u);
  *a1 = v2;
  if ( !v2 )
    return 13;
  v4 = sub_2BAD0((int)v2);
  v3 = sub_25D08(v4);
  if ( v3 )
    free(*a1);
  return v3;
}

//----- (000269F8) --------------------------------------------------------
int __fastcall sub_269F8(int **a1, int *a2)
{
  if ( sub_26998((void **)a1) )
    return 13;
  else
    return sub_268D4(a2, *a1);
}

//----- (00026A28) --------------------------------------------------------
int sub_26A28(int result, ...)
{
  int v1; // r4
  _DWORD *v2; // r5
  int v4; // kr00_4
  va_list v5; // [sp+0h] [bp-Ch]
  _DWORD *v6; // [sp+4h] [bp-8h]
  va_list varg_r1; // [sp+24h] [bp+18h] BYREF

  va_start(varg_r1, result);
  v1 = 0;
  v2 = (_DWORD *)result;
  va_copy(v5, varg_r1);
  while ( result )
  {
    if ( off_4C68C() )
    {
      va_copy(v6, varg_r1);
      while ( v1-- != 0 )
      {
        off_4C694(*v2);
        v2 = (_DWORD *)*v6++;
      }
      return 13;
    }
    ++v1;
    v4 = va_arg(v5, _DWORD);
    result = v4;
  }
  return result;
}
// 4C68C: using guessed type int (*off_4C68C)(void);
// 4C694: using guessed type int (__fastcall *off_4C694)(_DWORD);

//----- (00026ABC) --------------------------------------------------------
int sub_26ABC(int result, ...)
{
  int v1; // kr00_4
  va_list v2; // [sp+4h] [bp-4h]
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, result);
  va_copy(v2, varg_r1);
  while ( result )
  {
    off_4C694(result);
    v1 = va_arg(v2, _DWORD);
    result = v1;
  }
  return result;
}
// 4C694: using guessed type int (__fastcall *off_4C694)(_DWORD);

//----- (00026B0C) --------------------------------------------------------
int sub_26B0C(int result, ...)
{
  int *v1; // r4
  int *v2; // kr00_4
  va_list v3; // [sp+4h] [bp-4h]
  va_list varg_r1; // [sp+1Ch] [bp+14h] BYREF

  va_start(varg_r1, result);
  v1 = (int *)result;
  va_copy(v3, varg_r1);
  while ( v1 )
  {
    result = *v1;
    if ( *v1 )
    {
      result = off_4C694(result);
      *v1 = 0;
    }
    v2 = va_arg(v3, int *);
    v1 = v2;
  }
  return result;
}
// 4C694: using guessed type int (__fastcall *off_4C694)(_DWORD);

//----- (00026B70) --------------------------------------------------------
int __fastcall sub_26B70(unsigned __int8 *a1, int a2, int a3, _DWORD *a4, int a5)
{
  int v5; // r2
  const char *v6; // r0
  int v7; // r5
  unsigned __int8 *v8; // r1
  int v9; // r4
  int v10; // lr
  int v11; // r12
  unsigned int v13; // r12
  int v14; // r1
  unsigned int v15; // r0
  int v17; // t1
  int v18; // r7
  int v19; // r8
  int v20; // r7
  int v21; // lr
  char v22; // r4

  if ( !a1 )
  {
    v5 = 86;
    v6 = "in != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v5 = 87;
    v6 = "out != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v5 = 88;
    v6 = "outlen != NULL";
LABEL_3:
    sub_26EB8(v6, "src/misc/base64/base64_decode.c", v5);
  }
  v7 = 0;
  v8 = &a1[a2];
  v9 = 0;
  v10 = 0;
  v11 = 0;
  while ( v8 != a1 )
  {
    v17 = *a1++;
    v18 = byte_39CC3[v17];
    if ( v18 == 254 )
    {
      ++v7;
    }
    else
    {
      if ( v7 > 0 )
        v19 = a5 & 1;
      else
        v19 = 0;
      if ( v19 )
        return 7;
      if ( v18 == 255 )
      {
        if ( a5 )
          return 7;
      }
      else
      {
        ++v10;
        v11 = v18 | (v11 << 6);
        if ( v10 == 4 )
        {
          v20 = v9 + 3;
          if ( (unsigned int)(v9 + 3) > *a4 )
            return 6;
          *(_BYTE *)(a3 + v9) = BYTE2(v11);
          v21 = a3 + v9;
          v22 = BYTE1(v11);
          *(_BYTE *)(v21 + 2) = v11;
          v11 = 0;
          *(_BYTE *)(v21 + 1) = v22;
          v9 = v20;
          v10 = 0;
        }
      }
    }
  }
  if ( !v10 )
  {
LABEL_23:
    *a4 = v9;
    return 0;
  }
  if ( v10 == 1 )
    return 7;
  if ( v7 + v10 != 4 && a5 & 1 )
    return 7;
  if ( (unsigned int)(v10 + v9 - 1) <= *a4 )
  {
    v13 = v11 << (-6 * v10 + 24);
    v14 = v9 + 1;
    v15 = HIWORD(v13);
    if ( v10 == 3 )
      v13 >>= 8;
    *(_BYTE *)(a3 + v9) = v15;
    if ( v10 == 3 )
      v9 += 2;
    else
      ++v9;
    if ( v10 == 3 )
      *(_BYTE *)(a3 + v14) = v13;
    goto LABEL_23;
  }
  return 6;
}
// 39CC3: using guessed type unsigned __int8 byte_39CC3[256];

//----- (00026CFC) --------------------------------------------------------
int __fastcall sub_26CFC(unsigned __int8 *a1, int a2, int a3, _DWORD *a4)
{
  return sub_26B70(a1, a2, a3, a4, 0);
}

//----- (00026D14) --------------------------------------------------------
int __fastcall sub_26D14(unsigned __int8 *a1, int a2, int a3, _DWORD *a4)
{
  return sub_26B70(a1, a2, a3, a4, 1);
}

//----- (00026D2C) --------------------------------------------------------
int __fastcall sub_26D2C(unsigned __int8 *a1, unsigned int a2, _BYTE *a3, unsigned int *a4)
{
  int v4; // r2
  const char *v5; // r0
  unsigned int v6; // r12
  _BYTE *v8; // r4
  unsigned int v9; // lr
  _BYTE *v10; // r12
  unsigned __int8 *v11; // r7
  unsigned int v12; // r0
  unsigned int v13; // lr
  unsigned int v14; // r4
  bool v15; // cc
  char v16; // r6
  char v17; // r0
  char v18; // r0

  if ( !a1 )
  {
    v4 = 37;
    v5 = "in != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v4 = 38;
    v5 = "out != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v4 = 39;
    v5 = "outlen != NULL";
LABEL_3:
    sub_26EB8(v5, "src/misc/base64/base64_encode.c", v4);
  }
  v6 = 4 * ((a2 + 2) / 3) + 1;
  if ( *a4 >= v6 )
  {
    v8 = a3;
    v9 = 0;
    while ( 1 )
    {
      v10 = v8;
      v11 = a1;
      v8 += 4;
      a1 += 3;
      if ( 3 * (a2 / 3) <= v9 )
        break;
      v9 += 3;
      *(v8 - 4) = aAbcdefghijklmn[*(a1 - 3) >> 2];
      *(v8 - 3) = aAbcdefghijklmn[((16 * *(a1 - 3)) & 0x30) + (*(a1 - 2) >> 4)];
      *(v8 - 2) = aAbcdefghijklmn[((4 * *(a1 - 2)) & 0x3C) + (*(a1 - 1) >> 6)];
      *(v8 - 1) = aAbcdefghijklmn[*(a1 - 1) & 0x3F];
    }
    if ( a2 > v9 )
    {
      v12 = *v11;
      v13 = v9 + 1;
      if ( a2 <= v13 )
        v14 = 0;
      else
        v14 = v11[1];
      v15 = a2 > v13;
      v10 += 4;
      v16 = aAbcdefghijklmn[v12 >> 2];
      v17 = 16 * v12;
      if ( a2 <= v13 )
        LOBYTE(a2) = 61;
      *(v10 - 4) = v16;
      v18 = aAbcdefghijklmn[(v17 & 0x30) + (v14 >> 4)];
      if ( v15 )
        LOBYTE(a2) = aAbcdefghijklmn[(4 * (_BYTE)v14) & 0x3C];
      *(v10 - 3) = v18;
      *(v10 - 2) = a2;
      *(v10 - 1) = 61;
    }
    *v10 = 0;
    *a4 = v10 - a3;
    return 0;
  }
  else
  {
    *a4 = v6;
    return 6;
  }
}

//----- (00026EB8) --------------------------------------------------------
void __fastcall __noreturn sub_26EB8(const char *a1, const char *a2, int a3)
{
  fprintf((FILE *)stderr, "LTC_ARGCHK '%s' failure on line %d of file %s\n", a1, a3, a2);
  abort();
}
// 4C448: using guessed type int stderr;

//----- (00026EE4) --------------------------------------------------------
int __fastcall sub_26EE4(const char *a1)
{
  int v2; // r4
  const char *v3; // r0

  if ( !a1 )
    sub_26EB8("name != NULL", "src/misc/crypt/crypt_find_cipher.c", 24);
  v2 = 0;
  while ( 1 )
  {
    v3 = (const char *)dword_4C754[26 * v2];
    if ( v3 )
    {
      if ( !strcmp(v3, a1) )
        break;
    }
    if ( ++v2 == 5 )
      return -1;
  }
  return v2;
}
// 4C754: using guessed type _DWORD dword_4C754[130];

//----- (00026F50) --------------------------------------------------------
int __fastcall sub_26F50(const char *a1)
{
  int v2; // r4
  const char *v3; // r0

  if ( !a1 )
    sub_26EB8("name != NULL", "src/misc/crypt/crypt_find_hash.c", 24);
  v2 = 0;
  while ( 1 )
  {
    v3 = (const char *)dword_4C47C[26 * v2];
    if ( v3 )
    {
      if ( !strcmp(v3, a1) )
        break;
    }
    if ( ++v2 == 5 )
      return -1;
  }
  return v2;
}
// 4C47C: using guessed type _DWORD dword_4C47C[130];

//----- (00026FBC) --------------------------------------------------------
int __fastcall sub_26FBC(unsigned int a1)
{
  if ( a1 > 4 )
    return 11;
  if ( dword_4C47C[26 * a1] )
    return 0;
  return 11;
}
// 4C47C: using guessed type _DWORD dword_4C47C[130];

//----- (00026FF0) --------------------------------------------------------
int __fastcall sub_26FF0(unsigned __int8 *a1)
{
  int i; // r4
  _DWORD *v3; // lr
  _DWORD *v4; // r0

  if ( !a1 )
    sub_26EB8("cipher != NULL", "src/misc/crypt/crypt_register_cipher.c", 25);
  i = 0;
  while ( 1 )
  {
    v3 = &dword_4C754[26 * i];
    if ( *v3 )
    {
      if ( *((unsigned __int8 *)v3 + 4) == a1[4] )
        break;
    }
    if ( ++i == 5 )
    {
      for ( i = 0; i != 5; ++i )
      {
        v4 = &dword_4C754[26 * i];
        if ( !*v4 )
        {
          memcpy(v4, a1, 0x68u);
          return i;
        }
      }
      return -1;
    }
  }
  return i;
}
// 4C754: using guessed type _DWORD dword_4C754[130];

//----- (00027098) --------------------------------------------------------
int __fastcall sub_27098(const void *a1)
{
  int i; // r4
  _DWORD *v3; // r0

  if ( !a1 )
    sub_26EB8("hash != NULL", "src/misc/crypt/crypt_register_hash.c", 25);
  i = 0;
  while ( memcmp(&dword_4C47C[26 * i], a1, 0x68u) )
  {
    if ( ++i == 5 )
    {
      for ( i = 0; i != 5; ++i )
      {
        v3 = &dword_4C47C[26 * i];
        if ( !*v3 )
        {
          memcpy(v3, a1, 0x68u);
          return i;
        }
      }
      return -1;
    }
  }
  return i;
}
// 4C47C: using guessed type _DWORD dword_4C47C[130];

//----- (00027138) --------------------------------------------------------
int __fastcall sub_27138(int *a1)
{
  int v2; // r4
  _DWORD *v3; // r2
  int *v4; // r3
  int v5; // r0
  int v6; // r1

  if ( !a1 )
    sub_26EB8("prng != NULL", "src/misc/crypt/crypt_register_prng.c", 25);
  v2 = 0;
  while ( memcmp(&dword_4C95C[10 * v2], a1, 0x28u) )
  {
    if ( ++v2 == 5 )
    {
      v2 = 0;
      while ( 1 )
      {
        v3 = &dword_4C95C[10 * v2];
        if ( !*v3 )
          break;
        if ( ++v2 == 5 )
          return -1;
      }
      v4 = a1;
      do
      {
        v5 = *v4;
        v4 += 2;
        v6 = *(v4 - 1);
        *v3 = v5;
        v3[1] = v6;
        v3 += 2;
      }
      while ( v4 != a1 + 10 );
      return v2;
    }
  }
  return v2;
}
// 4C95C: using guessed type _DWORD dword_4C95C[50];

//----- (000271F8) --------------------------------------------------------
int __fastcall sub_271F8(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int *a4)
{
  int v4; // r2
  const char *v5; // r0

  if ( !a2 )
  {
    v4 = 28;
    v5 = "pt != NULL";
    goto LABEL_3;
  }
  if ( !a1 )
  {
    v4 = 29;
    v5 = "ct != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v4 = 30;
    v5 = "ctr != NULL";
LABEL_3:
    sub_26EB8(v5, "src/modes/ctr/ctr_decrypt.c", v4);
  }
  return sub_27254(a1, a2, a3, a4);
}

//----- (00027254) --------------------------------------------------------
int __fastcall sub_27254(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int *a4)
{
  char *v4; // r8
  int v5; // r2
  const char *v6; // r0
  _BYTE *v7; // r5
  unsigned int v9; // r6
  int v10; // r7
  unsigned int v11; // r1
  unsigned int v12; // r3
  int (__fastcall *v13)(char *, _BYTE *, unsigned int, unsigned int *, unsigned int, unsigned int *, unsigned int); // r10
  _BOOL4 v14; // r3
  unsigned int v15; // r0
  int v16; // r0
  unsigned int v17; // r9
  unsigned int v18; // r0
  unsigned int v19; // r1
  _BYTE *v20; // r6
  __int64 v22; // r2
  signed int v23; // r2
  int v24; // r0
  _BYTE *v25; // r1
  int v26; // r1
  _BYTE *v27; // r3
  char v28; // t1
  int v29; // r3
  int (__fastcall *v30)(unsigned int *, unsigned int *, unsigned int *, _DWORD, _BYTE *, _BYTE *); // r3
  unsigned int v31; // r3
  char v32; // t1
  _BYTE *v33; // [sp+0h] [bp-Ch]
  _BYTE *v34; // [sp+4h] [bp-8h]

  v33 = a1;
  v34 = a2;
  v4 = a1;
  if ( !a1 )
  {
    v5 = 31;
    v6 = "pt != NULL";
    goto LABEL_3;
  }
  v7 = a2;
  if ( !a2 )
  {
    v5 = 32;
    v6 = "ct != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v5 = 33;
    v6 = "ctr != NULL";
LABEL_3:
    sub_26EB8(v6, "src/modes/ctr/ctr_encrypt.c", v5);
  }
  v9 = a3;
  v10 = sub_2986C(*a4);
  if ( !v10 )
  {
    v11 = a4[1];
    if ( v11 - 1 > 0x7F )
      return 16;
    v12 = a4[2];
    if ( v12 > 0x80 )
      return 16;
    if ( v11 == v12 )
    {
      v13 = (int (__fastcall *)(char *, _BYTE *, unsigned int, unsigned int *, unsigned int, unsigned int *, unsigned int))dword_4C754[26 * *a4 + 16];
      v14 = v11 <= v9;
      if ( !v13 )
        v14 = 0;
      if ( v14 )
      {
        v15 = sub_34BA0(v9, v11);
        v16 = v13(v4, v7, v15, a4 + 5, a4[3], a4 + 69, a3);
        if ( v16 )
          return v16;
        v17 = a4[1];
        v18 = v17 * sub_34DFC(v9, v17);
        v9 = v19;
        v4 += v18;
        v7 += v18;
      }
    }
    v20 = &v7[v9];
    while ( v7 != v20 )
    {
      v22 = *(_QWORD *)(a4 + 1);
      if ( HIDWORD(v22) == (_DWORD)v22 )
      {
        v23 = a4[3];
        v24 = a4[4];
        if ( v23 )
        {
          v26 = HIDWORD(v22) - 1;
          v27 = (char *)a4 + HIDWORD(v22) + 20;
          while ( v26 >= v24 )
          {
            v28 = *--v27;
            *v27 = v28 + 1;
            if ( v28 != -1 )
              break;
            --v26;
          }
        }
        else
        {
          v25 = a4 + 5;
          while ( v23 < v24 )
          {
            v29 = (unsigned __int8)(*v25 + 1);
            *v25++ = v29;
            if ( v29 )
              break;
            ++v23;
          }
        }
        v30 = (int (__fastcall *)(unsigned int *, unsigned int *, unsigned int *, _DWORD, _BYTE *, _BYTE *))dword_4C754[26 * *a4 + 7];
        v16 = v30(a4 + 5, a4 + 37, a4 + 69, v30, v33, v34);
        if ( v16 )
          return v16;
        a4[2] = 0;
      }
      v31 = a4[2];
      v32 = *v4++;
      a4[2] = v31 + 1;
      *v7++ = *((_BYTE *)a4 + v31 + 148) ^ v32;
    }
  }
  return v10;
}
// 27354: variable 'v19' is possibly undefined
// 27418: variable 'v33' is possibly undefined
// 27418: variable 'v34' is possibly undefined
// 4C754: using guessed type _DWORD dword_4C754[130];

//----- (00027470) --------------------------------------------------------
int __fastcall sub_27470(unsigned int a1, char *a2, int a3, int a4, int a5, __int16 a6, unsigned int *a7)
{
  int v8; // r2
  const char *v9; // r0
  int result; // r0
  signed int v12; // r1
  signed int v13; // r3
  int v14; // r5
  _DWORD *v15; // r8
  char *v16; // r1
  _BYTE *v17; // r2
  int v18; // r3
  _BYTE *v19; // r12
  char v20; // t1
  int v21; // r1
  int v22; // r12
  _BYTE *v23; // r3
  char v24; // t1
  int v25; // r3

  if ( !a2 )
  {
    v8 = 38;
    v9 = "IV != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v8 = 39;
    v9 = "key != NULL";
    goto LABEL_3;
  }
  if ( !a7 )
  {
    v8 = 40;
    v9 = "ctr != NULL";
LABEL_3:
    sub_26EB8(v9, "src/modes/ctr/ctr_start.c", v8);
  }
  result = sub_2986C(a1);
  if ( !result )
  {
    v12 = (unsigned __int8)a6;
    v13 = dword_4C754[26 * a1 + 4];
    if ( !(_BYTE)a6 )
      v12 = dword_4C754[26 * a1 + 4];
    a7[4] = v12;
    if ( v12 > v13 )
    {
      return 16;
    }
    else
    {
      v14 = a6 & 0x1000;
      v15 = &dword_4C754[26 * a1];
      if ( (a6 & 0x1000) != 0 )
        a7[4] = v13 - v12;
      result = ((int (__fastcall *)(int, int, int, unsigned int *))v15[6])(a3, a4, a5, a7 + 69);
      if ( !result )
      {
        v16 = a2;
        v17 = a7 + 5;
        v18 = v15[4];
        v19 = a7 + 5;
        a7[2] = 0;
        *a7 = a1;
        a7[1] = v18;
        a7[3] = v14;
        while ( v18 > v16 - a2 )
        {
          v20 = *v16++;
          *v19++ = v20;
        }
        if ( (a6 & 0x2000) != 0 )
        {
          v21 = a7[4];
          if ( (a6 & 0x1000) != 0 )
          {
            v22 = v18 - 1;
            v23 = (char *)a7 + v18 + 20;
            while ( v22 >= v21 )
            {
              v24 = *--v23;
              *v23 = v24 + 1;
              if ( v24 != -1 )
                break;
              --v22;
            }
          }
          else
          {
            while ( v14 < v21 )
            {
              v25 = (unsigned __int8)(*v17 + 1);
              *v17++ = v25;
              if ( v25 )
                break;
              ++v14;
            }
          }
        }
        return ((int (*)(void))dword_4C754[26 * a1 + 7])();
      }
    }
  }
  return result;
}
// 4C754: using guessed type _DWORD dword_4C754[130];

//----- (00027634) --------------------------------------------------------
int __fastcall sub_27634(int a1, _BYTE *a2, unsigned int *a3)
{
  int v4; // r2
  const char *v5; // r0
  size_t v8; // r4
  unsigned int v9; // r10
  unsigned int v10; // r0
  bool v11; // cf
  unsigned int v12; // r8
  int v13; // r0
  unsigned int v14; // r6
  int result; // r0
  _BYTE src[260]; // [sp+10h] [bp-104h] BYREF

  if ( !a1 )
  {
    v4 = 35;
    v5 = "key != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v4 = 36;
    v5 = "outlen != NULL";
    goto LABEL_3;
  }
  if ( !sub_27AC4(*(_DWORD *)(a1 + 4)) )
    return 16;
  v8 = **(_DWORD **)(a1 + 8);
  v9 = off_4C6CC(*(_DWORD *)(a1 + 12));
  v10 = off_4C6CC(*(_DWORD *)(a1 + 16));
  v11 = v8 >= v10;
  if ( v8 >= v10 )
    v11 = v8 >= v9;
  v12 = v10;
  v13 = !v11;
  if ( v8 > 0x100 )
    v13 |= 1u;
  if ( v13 )
    return 6;
  v14 = 2 * v8 + 1;
  if ( *a3 < v14 )
  {
    *a3 = v14;
    return 6;
  }
  if ( !a2 )
  {
    v4 = 54;
    v5 = "out != NULL";
LABEL_3:
    sub_26EB8(v5, "src/pk/ecc/ecc_ansi_x963_export.c", v4);
  }
  *a2 = 4;
  j_j_explicit_bzero(src, 256);
  off_4C6D0(*(_DWORD *)(a1 + 12), &src[v8 - v9]);
  memcpy(a2 + 1, src, v8);
  j_j_explicit_bzero(src, 256);
  off_4C6D0(*(_DWORD *)(a1 + 16), &src[v8 - v12]);
  memcpy(&a2[v8 + 1], src, v8);
  result = 0;
  *a3 = v14;
  return result;
}
// 271F4: using guessed type int __fastcall j_j_explicit_bzero(_DWORD, _DWORD);
// 4C6CC: using guessed type int (__fastcall *off_4C6CC)(_DWORD);
// 4C6D0: using guessed type int (__fastcall *off_4C6D0)(_DWORD, _DWORD);

//----- (000277B4) --------------------------------------------------------
int __fastcall sub_277B4(int *a1, int a2, int a3)
{
  if ( !a1 )
    sub_26EB8("key != NULL", "src/pk/ecc/ecc_free.c", 30);
  return sub_26ABC(a1[3], a1[4], a1[5], a1[6], 0, a2, a3);
}

//----- (000277F4) --------------------------------------------------------
int __fastcall sub_277F4(int a1, unsigned int a2, _DWORD *a3, int *a4)
{
  int v5; // r2
  const char *v6; // r0
  int v10; // r5
  int v11; // r8
  void *v12; // r0
  void *v13; // r9
  int *v14; // r7
  int v16; // [sp+10h] [bp-8h] BYREF
  int v17; // [sp+14h] [bp-4h] BYREF

  if ( !a3 )
  {
    v5 = 56;
    v6 = "key != NULL";
    goto LABEL_3;
  }
  if ( !dword_4C684 )
  {
    v5 = 57;
    v6 = "ltc_mp.name != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v5 = 58;
    v6 = "dp != NULL";
LABEL_3:
    sub_26EB8(v6, "src/pk/ecc/ecc_make_key.c", v5);
  }
  v10 = sub_298A0(a2);
  if ( !v10 )
  {
    a3[1] = -1;
    a3[2] = a4;
    v11 = *a4;
    v12 = malloc(0x42u);
    v13 = v12;
    if ( !v12 )
      return 13;
    if ( v11 != ((int (__fastcall *)(void *, int, int))dword_4C95C[10 * a2 + 5])(v12, v11, a1) )
    {
      v10 = 9;
LABEL_25:
      free(v13);
      return v10;
    }
    v10 = sub_26A28((int)(a3 + 3), a3 + 4, a3 + 5, a3 + 6, &v16, &v17, 0);
    if ( v10 )
      goto LABEL_25;
    v14 = (int *)sub_28738();
    if ( v14 )
    {
      v10 = off_4C6C4(v16, *(_DWORD *)(a3[2] + 8), 16);
      if ( !v10 )
      {
        v10 = off_4C6C4(v17, *(_DWORD *)(a3[2] + 16), 16);
        if ( !v10 )
        {
          v10 = off_4C6C4(*v14, *(_DWORD *)(a3[2] + 20), 16);
          if ( !v10 )
          {
            v10 = off_4C6C4(v14[1], *(_DWORD *)(a3[2] + 24), 16);
            if ( !v10 )
            {
              v10 = off_4C6A0(v14[2], 1);
              if ( !v10 )
              {
                v10 = off_4C6D4(a3[6], v13, v11);
                if ( !v10 && (off_4C6B0(a3[6], v17) == -1 || (v10 = off_4C6F4(a3[6], v17, 0)) == 0) )
                {
                  v10 = off_4C72C(a3[6], v14, a3 + 3, v16, 1);
                  if ( !v10 )
                  {
                    *a3 = 1;
LABEL_24:
                    sub_2877C(v14);
                    sub_26ABC(v16, v17, 0);
                    goto LABEL_25;
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      v10 = 13;
    }
    sub_26ABC(a3[3], a3[4], a3[5], a3[6], 0);
    goto LABEL_24;
  }
  return v10;
}
// 4C684: using guessed type int dword_4C684;
// 4C6A0: using guessed type int (__fastcall *off_4C6A0)(_DWORD, _DWORD);
// 4C6B0: using guessed type int (__fastcall *off_4C6B0)(_DWORD, _DWORD);
// 4C6C4: using guessed type int (__fastcall *off_4C6C4)(_DWORD, _DWORD, _DWORD);
// 4C6D4: using guessed type int (__fastcall *off_4C6D4)(_DWORD, _DWORD, _DWORD);
// 4C6F4: using guessed type int (__fastcall *off_4C6F4)(_DWORD, _DWORD, _DWORD);
// 4C72C: using guessed type int (__fastcall *off_4C72C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C95C: using guessed type _DWORD dword_4C95C[50];

//----- (00027A60) --------------------------------------------------------
int __fastcall sub_27A60(int a1, unsigned int a2, int a3, _DWORD *a4)
{
  int i; // r5
  int *v6; // r3
  int v7; // r12
  int result; // r0

  for ( i = 0; ; ++i )
  {
    v6 = &dword_39FBC[7 * i];
    v7 = *v6;
    if ( *v6 >= a3 )
      break;
    if ( !v7 )
      return 3;
  }
  if ( v7 > 66 || !v7 )
    return 3;
  result = sub_277F4(a1, a2, a4, v6);
  a4[1] = i;
  return result;
}
// 39FBC: using guessed type _DWORD dword_39FBC[79];

//----- (00027AC4) --------------------------------------------------------
bool __fastcall sub_27AC4(int a1)
{
  int i; // r3
  bool v2; // cc

  for ( i = 0; dword_39FBC[7 * i]; ++i )
    ;
  v2 = a1 <= -1;
  if ( a1 >= -1 )
    v2 = i <= a1;
  return !v2;
}
// 39FBC: using guessed type _DWORD dword_39FBC[79];

//----- (00027B00) --------------------------------------------------------
int __fastcall sub_27B00(_DWORD *a1, int a2, int a3)
{
  int v4; // r2
  const char *v5; // r0
  int v8; // r4
  _DWORD *v10; // [sp+0h] [bp-Ch] BYREF
  _DWORD v11[2]; // [sp+4h] [bp-8h] BYREF

  v10 = a1;
  v11[0] = a2;
  v11[1] = a3;
  if ( !a1 )
  {
    v4 = 36;
    v5 = "P != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v4 = 37;
    v5 = "modulus != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v4 = 38;
    v5 = "mp != NULL";
LABEL_3:
    sub_26EB8(v5, "src/pk/ecc/ltc_ecc_map.c", v4);
  }
  v8 = sub_26A28((int)&v10, v11, 0);
  if ( !v8 )
  {
    v8 = off_4C71C(a1[2], a2, a3);
    if ( !v8 )
    {
      v8 = off_4C710(a1[2], a2);
      if ( !v8 )
      {
        v8 = off_4C6F0(v10, v11[0]);
        if ( !v8 )
        {
          v8 = off_4C6F4(v11[0], a2, 0);
          if ( !v8 )
          {
            v8 = off_4C6E8(v10, v11[0]);
            if ( !v8 )
            {
              v8 = off_4C6F4(v10, a2, 0);
              if ( !v8 )
              {
                v8 = off_4C6E8(*a1, v11[0]);
                if ( !v8 )
                {
                  v8 = off_4C71C(*a1, a2, a3);
                  if ( !v8 )
                  {
                    v8 = off_4C6E8(a1[1], v10);
                    if ( !v8 )
                    {
                      v8 = off_4C71C(a1[1], a2, a3);
                      if ( !v8 )
                        v8 = off_4C6A0(a1[2], 1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_26ABC((int)v10, v11[0], 0);
  }
  return v8;
}
// 4C6A0: using guessed type int (__fastcall *off_4C6A0)(_DWORD, _DWORD);
// 4C6E8: using guessed type int (__fastcall *off_4C6E8)(_DWORD, _DWORD);
// 4C6F0: using guessed type int (__fastcall *off_4C6F0)(_DWORD, _DWORD);
// 4C6F4: using guessed type int (__fastcall *off_4C6F4)(_DWORD, _DWORD, _DWORD);
// 4C710: using guessed type int (__fastcall *off_4C710)(_DWORD, _DWORD);
// 4C71C: using guessed type int (__fastcall *off_4C71C)(_DWORD, _DWORD, _DWORD);

//----- (00027CC0) --------------------------------------------------------
int __fastcall sub_27CC0(_DWORD *a1, int a2, _DWORD *a3, int a4, _DWORD *a5, int a6)
{
  int v7; // r2
  const char *v8; // r0
  int v12; // r10
  unsigned int v13; // r0
  unsigned int v14; // r1
  unsigned int v15; // r2
  bool v16; // cc
  int v17; // r7
  void *v18; // r0
  int i; // r4
  int *v20; // r0
  _DWORD *v22; // r7
  _DWORD *v23; // r9
  int v24; // r8
  int v25; // r7
  _DWORD *v26; // r8
  int k; // r4
  int *v28; // r0
  int v29; // r0
  int j; // r7
  int v31; // r9
  int v32; // r8
  int v33; // r5
  unsigned int v34; // r11
  int v35; // r0
  _DWORD *v36; // r9
  unsigned __int8 *ptr; // [sp+Ch] [bp-68h]
  int v38; // [sp+10h] [bp-64h]
  unsigned int v39; // [sp+10h] [bp-64h]
  unsigned int v40; // [sp+10h] [bp-64h]
  unsigned __int8 *v41; // [sp+14h] [bp-60h]
  __int64 v42; // [sp+18h] [bp-5Ch]
  unsigned int v43; // [sp+20h] [bp-54h]
  int v44; // [sp+28h] [bp-4Ch] BYREF
  _DWORD v45[2]; // [sp+2Ch] [bp-48h] BYREF
  _DWORD *v46; // [sp+34h] [bp-40h] BYREF
  int v47; // [sp+38h] [bp-3Ch]
  int v48; // [sp+3Ch] [bp-38h]
  _DWORD *v49; // [sp+40h] [bp-34h] BYREF
  int v50; // [sp+50h] [bp-24h]
  int v51; // [sp+60h] [bp-14h]

  if ( !a1 )
  {
    v7 = 47;
    v8 = "A != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v7 = 48;
    v8 = "B != NULL";
    goto LABEL_3;
  }
  if ( !a5 )
  {
    v7 = 49;
    v8 = "C != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v7 = 50;
    v8 = "kA != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v7 = 51;
    v8 = "kB != NULL";
    goto LABEL_3;
  }
  if ( !a6 )
  {
    v7 = 52;
    v8 = "modulus != NULL";
LABEL_3:
    sub_26EB8(v8, "src/pk/ecc/ltc_ecc_mul2add.c", v7);
  }
  ptr = (unsigned __int8 *)calloc(1u, 0x100u);
  if ( !ptr )
    return 13;
  v41 = (unsigned __int8 *)calloc(1u, 0x100u);
  if ( !v41 )
  {
    free(ptr);
    return 13;
  }
  v38 = off_4C6CC(a2);
  v13 = off_4C6CC(a4);
  v14 = v38;
  v39 = v13;
  if ( v14 < v13 )
    v15 = v13;
  else
    v15 = v14;
  v16 = v13 > 0x100;
  if ( v13 <= 0x100 )
    v16 = v14 > 0x100;
  v43 = v15;
  v17 = v16;
  if ( v16 )
  {
    v12 = 16;
    goto LABEL_34;
  }
  off_4C6D0(a2, &ptr[v15 - v14]);
  off_4C6D0(a4, &v41[v43 - v39]);
  do
  {
    v18 = sub_28738();
    v45[v17 + 1] = v18;
    if ( !v18 )
    {
      for ( i = 0; i != v17; ++i )
      {
        v20 = (int *)v45[i + 1];
        sub_2877C(v20);
      }
      v12 = 13;
      goto LABEL_34;
    }
    ++v17;
  }
  while ( v17 != 16 );
  v12 = off_4C714(a6, &v44);
  if ( v12 )
    goto LABEL_53;
  v12 = off_4C68C(v45);
  if ( v12 )
    goto LABEL_52;
  v12 = off_4C718(v45[0], a6);
  if ( v12 )
    goto LABEL_51;
  v22 = v46;
  v12 = off_4C708(*a1, v45[0], a6, *v46);
  if ( v12 )
    goto LABEL_51;
  v12 = off_4C708(a1[1], v45[0], a6, v22[1]);
  if ( v12 )
    goto LABEL_51;
  v12 = off_4C708(a1[2], v45[0], a6, v22[2]);
  if ( v12 )
    goto LABEL_51;
  v23 = v49;
  v12 = off_4C708(*a3, v45[0], a6, *v49);
  if ( v12 )
    goto LABEL_51;
  v12 = off_4C708(a3[1], v45[0], a6, v23[1]);
  if ( v12 )
    goto LABEL_51;
  v12 = off_4C708(a3[2], v45[0], a6, v23[2]);
  if ( v12 )
    goto LABEL_51;
  v24 = v47;
  v12 = off_4C734(v22, v47, a6, v44);
  if ( v12 )
    goto LABEL_51;
  v12 = off_4C730(v22, v24, v48, a6, v44);
  if ( v12 )
    goto LABEL_51;
  v25 = v50;
  v12 = off_4C734(v23, v50, a6, v44);
  if ( v12 )
    goto LABEL_51;
  v12 = off_4C730(v23, v25, v51, a6, v44);
  if ( v12 )
    goto LABEL_51;
  v26 = &v46;
  do
  {
    for ( j = 1; j != 4; ++j )
    {
      v29 = off_4C730(*v26, v45[4 * j + 1], v26[4 * j], a6, v44);
      if ( v29 )
        goto LABEL_77;
    }
    ++v26;
  }
  while ( v26 != &v49 );
  v31 = 1;
  v32 = 3;
  v33 = 0;
  v40 = *ptr;
  v34 = *v41;
  while ( ++v32 != 4 )
  {
LABEL_64:
    LODWORD(v42) = v40 >> 6;
    HIDWORD(v42) = v34 >> 6;
    v34 = (unsigned __int8)(4 * v34);
    v40 = (unsigned __int8)(4 * v40);
    if ( v42 )
    {
      if ( v31 )
      {
        v36 = (_DWORD *)v45[4 * HIDWORD(v42) + 1 + (_DWORD)v42];
        v12 = off_4C69C(*v36, *a5);
        if ( v12 )
          goto LABEL_51;
        v12 = off_4C69C(v36[1], a5[1]);
        if ( v12 )
          goto LABEL_51;
        v35 = off_4C69C(v36[2], a5[2]);
LABEL_74:
        v12 = v35;
        if ( v35 )
          goto LABEL_51;
        v31 = 0;
      }
      else
      {
LABEL_66:
        v12 = off_4C734(a5, a5, a6, v44);
        if ( v12 )
          goto LABEL_51;
        v12 = off_4C734(a5, a5, a6, v44);
        if ( v12 )
          goto LABEL_51;
        if ( v42 )
        {
          v35 = off_4C730(a5, v45[4 * HIDWORD(v42) + 1 + (_DWORD)v42], a5, a6, v44);
          goto LABEL_74;
        }
      }
    }
    else if ( v31 != 1 )
    {
      goto LABEL_66;
    }
  }
  if ( v33 != v43 )
  {
    v32 = 0;
    v40 = ptr[v33];
    v34 = v41[v33++];
    goto LABEL_64;
  }
  v29 = sub_27B00(a5, a6, v44);
LABEL_77:
  v12 = v29;
LABEL_51:
  off_4C694(v45[0]);
LABEL_52:
  off_4C720(v44);
LABEL_53:
  for ( k = 0; k != 16; ++k )
  {
    v28 = (int *)v45[k + 1];
    sub_2877C(v28);
  }
LABEL_34:
  free(ptr);
  free(v41);
  return v12;
}
// 281C0: conditional instruction was optimized away because r9.4==0
// 4C68C: using guessed type int (__fastcall *off_4C68C)(_DWORD);
// 4C694: using guessed type int (__fastcall *off_4C694)(_DWORD);
// 4C69C: using guessed type int (__fastcall *off_4C69C)(_DWORD, _DWORD);
// 4C6CC: using guessed type int (__fastcall *off_4C6CC)(_DWORD);
// 4C6D0: using guessed type int (__fastcall *off_4C6D0)(_DWORD, _DWORD);
// 4C708: using guessed type int (__fastcall *off_4C708)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C714: using guessed type int (__fastcall *off_4C714)(_DWORD, _DWORD);
// 4C718: using guessed type int (__fastcall *off_4C718)(_DWORD, _DWORD);
// 4C720: using guessed type int (__fastcall *off_4C720)(_DWORD);
// 4C730: using guessed type int (__fastcall *off_4C730)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C734: using guessed type int (__fastcall *off_4C734)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002828C) --------------------------------------------------------
int __fastcall sub_2828C(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5)
{
  int v6; // r2
  const char *v7; // r0
  int v10; // r11
  int i; // r6
  int *v13; // r0
  int *v14; // r0
  int *v15; // r0
  int *v16; // r7
  int *v17; // r6
  int *v18; // r8
  int *v19; // r9
  unsigned int v20; // r2
  unsigned int j; // [sp+Ch] [bp-38h]
  int v22; // [sp+10h] [bp-34h]
  int v23; // [sp+14h] [bp-30h]
  int v24; // [sp+18h] [bp-2Ch]
  int v25; // [sp+1Ch] [bp-28h]
  int v27; // [sp+24h] [bp-20h]
  int v28; // [sp+2Ch] [bp-18h] BYREF
  int v29; // [sp+30h] [bp-14h] BYREF
  int *v30; // [sp+34h] [bp-10h]
  int *v31; // [sp+38h] [bp-Ch]
  int *v32; // [sp+3Ch] [bp-8h]

  if ( !a1 )
  {
    v6 = 43;
    v7 = "k != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v6 = 44;
    v7 = "G != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v6 = 45;
    v7 = "R != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v6 = 46;
    v7 = "modulus != NULL";
LABEL_3:
    sub_26EB8(v7, "src/pk/ecc/ltc_ecc_mulmod_timing.c", v6);
  }
  v10 = off_4C714(a4, &v29);
  if ( !v10 )
  {
    v10 = off_4C68C(&v28);
    if ( v10 )
    {
LABEL_12:
      off_4C720(v29);
      return v10;
    }
    v10 = off_4C718(v28, a4);
    if ( v10 )
    {
      off_4C694(v28);
      goto LABEL_12;
    }
    for ( i = 0; i != 3; ++i )
    {
      v13 = (int *)sub_28738();
      (&v30)[i] = v13;
      if ( !v13 )
      {
        while ( v10 != i )
        {
          v14 = (&v30)[v10++];
          sub_2877C(v14);
        }
        v10 = 13;
        off_4C694(v28);
        off_4C720(v29);
        return v10;
      }
    }
    v15 = (int *)sub_28738();
    v16 = v15;
    v17 = v30;
    v18 = v31;
    if ( !v15 )
    {
      v10 = 13;
      goto LABEL_51;
    }
    v10 = off_4C708(*a2, v28, a4, *v15);
    if ( !v10 )
    {
      v10 = off_4C708(a2[1], v28, a4, v16[1]);
      if ( !v10 )
      {
        v10 = off_4C708(a2[2], v28, a4, v16[2]);
        if ( !v10 )
        {
          off_4C694(v28);
          v28 = 0;
          v10 = off_4C69C(*v16, *v17);
          if ( !v10 )
          {
            v10 = off_4C69C(v16[1], v17[1]);
            if ( !v10 )
            {
              v10 = off_4C69C(v16[2], v17[2]);
              if ( !v10 )
              {
                v10 = off_4C734(v16, v18, a4, v29);
                if ( !v10 )
                {
                  v22 = off_4C6AC(a1) - 1;
                  v23 = 1;
                  v24 = 0;
                  for ( j = 0; ; j *= 2 )
                  {
                    if ( !--v23 )
                    {
                      if ( v22 == -1 )
                      {
                        v10 = off_4C69C(*v17, *a3);
                        if ( !v10 )
                        {
                          v10 = off_4C69C(v17[1], a3[1]);
                          if ( !v10 )
                          {
                            v10 = off_4C69C(v17[2], a3[2]);
                            if ( !v10 )
                            {
                              if ( a5 )
                                v10 = sub_27B00(a3, a4, v29);
                            }
                          }
                        }
                        break;
                      }
                      j = off_4C6A8(a1, v22);
                      v23 = dword_4C688;
                      --v22;
                    }
                    v19 = v32;
                    v20 = j >> (dword_4C688 - 1);
                    v25 = v20 & 1;
                    v27 = v10 | v25;
                    if ( v27 )
                    {
                      if ( ((v10 ^ 1) & v25) != 0 )
                      {
                        v10 = off_4C730(v17, v18, v32, a4, v29);
                        if ( v10 )
                          break;
                        v10 = off_4C734(v18, v19, a4, v29);
                        if ( v10 )
                          break;
                        v10 = v27;
                      }
                      else
                      {
                        v10 = off_4C730(v17, v18, (&v30)[(v20 & 1) == 0], a4, v29);
                        if ( v10 )
                          break;
                        v10 = off_4C734((&v30)[v25], (&v30)[v25], a4, v29);
                        if ( v10 )
                          break;
                        v10 = v24;
                      }
                    }
                    else
                    {
                      v10 = off_4C730(v17, v18, v32, a4, v29);
                      if ( v10 )
                        break;
                      v10 = off_4C734(v18, v19, a4, v29);
                      if ( v10 )
                        break;
                    }
                    v24 = v10;
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_51:
    if ( v28 )
      off_4C694(v28);
    off_4C720(v29);
    sub_2877C(v16);
    sub_2877C(v30);
    sub_2877C(v31);
    sub_2877C(v32);
  }
  return v10;
}
// 4C688: using guessed type int dword_4C688;
// 4C68C: using guessed type int (__fastcall *off_4C68C)(_DWORD);
// 4C694: using guessed type int (__fastcall *off_4C694)(_DWORD);
// 4C69C: using guessed type int (__fastcall *off_4C69C)(_DWORD, _DWORD);
// 4C6A8: using guessed type int (__fastcall *off_4C6A8)(_DWORD, _DWORD);
// 4C6AC: using guessed type int (__fastcall *off_4C6AC)(_DWORD);
// 4C708: using guessed type int (__fastcall *off_4C708)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C714: using guessed type int (__fastcall *off_4C714)(_DWORD, _DWORD);
// 4C718: using guessed type int (__fastcall *off_4C718)(_DWORD, _DWORD);
// 4C720: using guessed type int (__fastcall *off_4C720)(_DWORD);
// 4C730: using guessed type int (__fastcall *off_4C730)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C734: using guessed type int (__fastcall *off_4C734)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00028738) --------------------------------------------------------
void *sub_28738()
{
  char *v0; // r0
  void *v1; // r4
  void *v2; // r0

  v0 = (char *)calloc(1u, 0xCu);
  v1 = v0;
  if ( v0 && sub_26A28((int)v0, v0 + 4, v0 + 8, 0) )
  {
    v2 = v1;
    v1 = 0;
    free(v2);
  }
  return v1;
}

//----- (0002877C) --------------------------------------------------------
void __fastcall sub_2877C(int *a1)
{
  if ( a1 )
  {
    sub_26ABC(*a1, a1[1], a1[2], 0);
    free(a1);
  }
}

//----- (000287A0) --------------------------------------------------------
int __fastcall sub_287A0(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5)
{
  int v6; // r2
  const char *v7; // r0
  int v11; // r4
  int v12; // r1
  int v14; // r0
  int v15; // r1
  int v16; // [sp+Ch] [bp-14h] BYREF
  int v17; // [sp+10h] [bp-10h] BYREF
  int v18; // [sp+14h] [bp-Ch] BYREF
  int v19; // [sp+18h] [bp-8h] BYREF
  int v20; // [sp+1Ch] [bp-4h] BYREF

  if ( !a1 )
  {
    v6 = 38;
    v7 = "P != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v6 = 39;
    v7 = "Q != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v6 = 40;
    v7 = "R != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v6 = 41;
    v7 = "modulus != NULL";
    goto LABEL_3;
  }
  if ( !a5 )
  {
    v6 = 42;
    v7 = "mp != NULL";
LABEL_3:
    sub_26EB8(v7, "src/pk/ecc/ltc_ecc_projective_add_point.c", v6);
  }
  v11 = sub_26A28((int)&v16, &v17, &v18, &v19, &v20, 0);
  if ( !v11 )
  {
    v11 = off_4C6E0(a4, a2[1]);
    if ( v11 )
    {
LABEL_26:
      sub_26ABC(v16, v17, v18, v19, v20, 0);
      return v11;
    }
    if ( off_4C6B0(*a1, *a2)
      || (v12 = a2[2]) == 0
      || off_4C6B0(a1[2], v12)
      || off_4C6B0(a1[1], a2[1]) && off_4C6B0(a1[1], v16) )
    {
      v11 = off_4C69C(*a1, v18);
      if ( !v11 )
      {
        v11 = off_4C69C(a1[1], v19);
        if ( !v11 )
        {
          v11 = off_4C69C(a1[2], v20);
          if ( !v11 )
          {
            v14 = a2[2];
            if ( !v14 )
              goto LABEL_25;
            v11 = off_4C6F0(v14, v16);
            if ( !v11 )
            {
              v11 = off_4C71C(v16, a4, a5);
              if ( !v11 )
              {
                v11 = off_4C6E8(v16, v18);
                if ( !v11 )
                {
                  v11 = off_4C71C(v18, a4, a5);
                  if ( !v11 )
                  {
                    v11 = off_4C6E8(a2[2], v16);
                    if ( !v11 )
                    {
                      v11 = off_4C71C(v16, a4, a5);
                      if ( !v11 )
                      {
                        v11 = off_4C6E8(v16, v19);
                        if ( !v11 )
                        {
                          v11 = off_4C71C(v19, a4, a5);
                          if ( !v11 )
                          {
LABEL_25:
                            v11 = off_4C6F0(v20, v16);
                            if ( !v11 )
                            {
                              v11 = off_4C71C(v16, a4, a5);
                              if ( !v11 )
                              {
                                v11 = off_4C6E8(*a2, v16);
                                if ( !v11 )
                                {
                                  v11 = off_4C71C(v17, a4, a5);
                                  if ( !v11 )
                                  {
                                    v11 = off_4C6E8(v20, v16);
                                    if ( !v11 )
                                    {
                                      v11 = off_4C71C(v16, a4, a5);
                                      if ( !v11 )
                                      {
                                        v11 = off_4C6E8(a2[1], v16);
                                        if ( !v11 )
                                        {
                                          v11 = off_4C71C(v16, a4, a5);
                                          if ( !v11 )
                                          {
                                            v11 = off_4C6E0(v19, v16);
                                            if ( !v11 && (off_4C6B4(v19) != -1 || (v11 = off_4C6D8(v19, a4)) == 0) )
                                            {
                                              v11 = off_4C6D8(v16, v16);
                                              if ( !v11 && (off_4C6B0(v16, a4) == -1 || (v11 = off_4C6E0(v16, a4)) == 0) )
                                              {
                                                v11 = off_4C6D8(v16, v19);
                                                if ( !v11
                                                  && (off_4C6B0(v16, a4) == -1 || (v11 = off_4C6E0(v16, a4)) == 0) )
                                                {
                                                  v11 = off_4C6E0(v18, v17);
                                                  if ( !v11 && (off_4C6B4(v18) != -1 || (v11 = off_4C6D8(v18, a4)) == 0) )
                                                  {
                                                    v11 = off_4C6D8(v17, v17);
                                                    if ( !v11
                                                      && (off_4C6B0(v17, a4) == -1 || (v11 = off_4C6E0(v17, a4)) == 0) )
                                                    {
                                                      v11 = off_4C6D8(v17, v18);
                                                      if ( !v11
                                                        && (off_4C6B0(v17, a4) == -1 || (v11 = off_4C6E0(v17, a4)) == 0) )
                                                      {
                                                        v15 = a2[2];
                                                        if ( !v15
                                                          || (v11 = off_4C6E8(v20, v15)) == 0
                                                          && (v11 = off_4C71C(v20, a4, a5)) == 0 )
                                                        {
                                                          v11 = off_4C6E8(v20, v18);
                                                          if ( !v11 )
                                                          {
                                                            v11 = off_4C71C(v20, a4, a5);
                                                            if ( !v11 )
                                                            {
                                                              v11 = off_4C6E8(v16, v18);
                                                              if ( !v11 )
                                                              {
                                                                v11 = off_4C71C(v16, a4, a5);
                                                                if ( !v11 )
                                                                {
                                                                  v11 = off_4C6F0(v18, v18);
                                                                  if ( !v11 )
                                                                  {
                                                                    v11 = off_4C71C(v18, a4, a5);
                                                                    if ( !v11 )
                                                                    {
                                                                      v11 = off_4C6E8(v17, v18);
                                                                      if ( !v11 )
                                                                      {
                                                                        v11 = off_4C71C(v17, a4, a5);
                                                                        if ( !v11 )
                                                                        {
                                                                          v11 = off_4C6E8(v16, v18);
                                                                          if ( !v11 )
                                                                          {
                                                                            v11 = off_4C71C(v16, a4, a5);
                                                                            if ( !v11 )
                                                                            {
                                                                              v11 = off_4C6F0(v19, v18);
                                                                              if ( !v11 )
                                                                              {
                                                                                v11 = off_4C71C(v18, a4, a5);
                                                                                if ( !v11 )
                                                                                {
                                                                                  v11 = off_4C6E0(v18, v17);
                                                                                  if ( !v11
                                                                                    && (off_4C6B4(v18) != -1
                                                                                     || (v11 = off_4C6D8(v18, a4)) == 0) )
                                                                                  {
                                                                                    v11 = off_4C6E0(v17, v18);
                                                                                    if ( !v11
                                                                                      && (off_4C6B4(v17) != -1
                                                                                       || (v11 = off_4C6D8(v17, a4)) == 0) )
                                                                                    {
                                                                                      v11 = off_4C6E0(v17, v18);
                                                                                      if ( !v11
                                                                                        && (off_4C6B4(v17) != -1
                                                                                         || (v11 = off_4C6D8(v17, a4)) == 0) )
                                                                                      {
                                                                                        v11 = off_4C6E8(v17, v19);
                                                                                        if ( !v11 )
                                                                                        {
                                                                                          v11 = off_4C71C(v17, a4, a5);
                                                                                          if ( !v11 )
                                                                                          {
                                                                                            v11 = off_4C6E0(v17, v16);
                                                                                            if ( !v11
                                                                                              && (off_4C6B4(v19) != -1
                                                                                               || (v11 = off_4C6D8(v19, a4)) == 0)
                                                                                              && (off_4C6AC(v19) <= 0
                                                                                               || (off_4C6A8(v19, 0) & 1) == 0
                                                                                               || (v11 = off_4C6D8(v19, a4)) == 0) )
                                                                                            {
                                                                                              v11 = off_4C6F8(v19);
                                                                                              if ( !v11 )
                                                                                              {
                                                                                                v11 = off_4C69C(v18, *a3);
                                                                                                if ( !v11 )
                                                                                                {
                                                                                                  v11 = off_4C69C(v19, a3[1]);
                                                                                                  if ( !v11 )
                                                                                                    v11 = off_4C69C(v20, a3[2]);
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_26;
    }
    sub_26ABC(v16, v17, v18, v19, v20, 0);
    return sub_29118(a1, a3, a4, a5);
  }
  return v11;
}
// 4C69C: using guessed type int (__fastcall *off_4C69C)(_DWORD, _DWORD);
// 4C6A8: using guessed type int (__fastcall *off_4C6A8)(_DWORD, _DWORD);
// 4C6AC: using guessed type int (__fastcall *off_4C6AC)(_DWORD);
// 4C6B0: using guessed type int (__fastcall *off_4C6B0)(_DWORD, _DWORD);
// 4C6B4: using guessed type int (__fastcall *off_4C6B4)(_DWORD);
// 4C6D8: using guessed type int (__fastcall *off_4C6D8)(_DWORD, _DWORD);
// 4C6E0: using guessed type int (__fastcall *off_4C6E0)(_DWORD, _DWORD);
// 4C6E8: using guessed type int (__fastcall *off_4C6E8)(_DWORD, _DWORD);
// 4C6F0: using guessed type int (__fastcall *off_4C6F0)(_DWORD, _DWORD);
// 4C6F8: using guessed type int (__fastcall *off_4C6F8)(_DWORD);
// 4C71C: using guessed type int (__fastcall *off_4C71C)(_DWORD, _DWORD, _DWORD);

//----- (00029118) --------------------------------------------------------
int __fastcall sub_29118(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  int v5; // r2
  const char *v6; // r0
  int v10; // r4
  _DWORD *v12; // [sp+0h] [bp-Ch] BYREF
  _DWORD v13[2]; // [sp+4h] [bp-8h] BYREF

  v12 = a1;
  v13[0] = a2;
  v13[1] = a3;
  if ( !a1 )
  {
    v5 = 37;
    v6 = "P != NULL";
    goto LABEL_3;
  }
  if ( !a2 )
  {
    v5 = 38;
    v6 = "R != NULL";
    goto LABEL_3;
  }
  if ( !a3 )
  {
    v5 = 39;
    v6 = "modulus != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v5 = 40;
    v6 = "mp != NULL";
LABEL_3:
    sub_26EB8(v6, "src/pk/ecc/ltc_ecc_projective_dbl_point.c", v5);
  }
  v10 = sub_26A28((int)&v12, v13, 0);
  if ( !v10 )
  {
    if ( a1 == a2
      || (v10 = off_4C69C(*a1, *a2)) == 0
      && (v10 = off_4C69C(a1[1], a2[1])) == 0
      && (v10 = off_4C69C(a1[2], a2[2])) == 0 )
    {
      v10 = off_4C6F0(a2[2], v12);
      if ( !v10 )
      {
        v10 = off_4C71C(v12, a3, a4);
        if ( !v10 )
        {
          v10 = off_4C6E8(a2[2], a2[1]);
          if ( !v10 )
          {
            v10 = off_4C71C(a2[2], a3, a4);
            if ( !v10 )
            {
              v10 = off_4C6D8(a2[2], a2[2]);
              if ( !v10 && (off_4C6B0(a2[2], a3) == -1 || (v10 = off_4C6E0(a2[2], a3)) == 0) )
              {
                v10 = off_4C6E0(*a2, v12);
                if ( !v10 && (off_4C6B4(v13[0]) != -1 || (v10 = off_4C6D8(v13[0], a3)) == 0) )
                {
                  v10 = off_4C6D8(v12, *a2);
                  if ( !v10 && (off_4C6B0(v12, a3) == -1 || (v10 = off_4C6E0(v12, a3)) == 0) )
                  {
                    v10 = off_4C6E8(v12, v13[0]);
                    if ( !v10 )
                    {
                      v10 = off_4C71C(v13[0], a3, a4);
                      if ( !v10 )
                      {
                        v10 = off_4C6D8(v13[0], v13[0]);
                        if ( !v10 && (off_4C6B0(v12, a3) == -1 || (v10 = off_4C6E0(v12, a3)) == 0) )
                        {
                          v10 = off_4C6D8(v12, v13[0]);
                          if ( !v10 && (off_4C6B0(v12, a3) == -1 || (v10 = off_4C6E0(v12, a3)) == 0) )
                          {
                            v10 = off_4C6D8(a2[1], a2[1]);
                            if ( !v10 && (off_4C6B0(a2[1], a3) == -1 || (v10 = off_4C6E0(a2[1], a3)) == 0) )
                            {
                              v10 = off_4C6F0(a2[1], a2[1]);
                              if ( !v10 )
                              {
                                v10 = off_4C71C(a2[1], a3, a4);
                                if ( !v10 )
                                {
                                  v10 = off_4C6F0(a2[1], v13[0]);
                                  if ( !v10 )
                                  {
                                    v10 = off_4C71C(v13[0], a3, a4);
                                    if ( !v10
                                      && (off_4C6AC(v13[0]) <= 0
                                       || (off_4C6A8(v13[0], 0) & 1) == 0
                                       || (v10 = off_4C6D8(v13[0], a3)) == 0) )
                                    {
                                      v10 = off_4C6F8(v13[0]);
                                      if ( !v10 )
                                      {
                                        v10 = off_4C6E8(a2[1], *a2);
                                        if ( !v10 )
                                        {
                                          v10 = off_4C71C(a2[1], a3, a4);
                                          if ( !v10 )
                                          {
                                            v10 = off_4C6F0(v12, *a2);
                                            if ( !v10 )
                                            {
                                              v10 = off_4C71C(*a2, a3, a4);
                                              if ( !v10 )
                                              {
                                                v10 = off_4C6E0(*a2, a2[1]);
                                                if ( !v10 && (off_4C6B4(*a2) != -1 || (v10 = off_4C6D8(*a2, a3)) == 0) )
                                                {
                                                  v10 = off_4C6E0(*a2, a2[1]);
                                                  if ( !v10 && (off_4C6B4(*a2) != -1 || (v10 = off_4C6D8(*a2, a3)) == 0) )
                                                  {
                                                    v10 = off_4C6E0(a2[1], *a2);
                                                    if ( !v10
                                                      && (off_4C6B4(a2[1]) != -1 || (v10 = off_4C6D8(a2[1], a3)) == 0) )
                                                    {
                                                      v10 = off_4C6E8(a2[1], v12);
                                                      if ( !v10 )
                                                      {
                                                        v10 = off_4C71C(a2[1], a3, a4);
                                                        if ( !v10 )
                                                        {
                                                          v10 = off_4C6E0(a2[1], v13[0]);
                                                          if ( !v10 && off_4C6B4(a2[1]) == -1 )
                                                            v10 = off_4C6D8(a2[1], a3);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_26ABC((int)v12, v13[0], 0);
  }
  return v10;
}
// 4C69C: using guessed type int (__fastcall *off_4C69C)(_DWORD, _DWORD);
// 4C6A8: using guessed type int (__fastcall *off_4C6A8)(_DWORD, _DWORD);
// 4C6AC: using guessed type int (__fastcall *off_4C6AC)(_DWORD);
// 4C6B0: using guessed type int (__fastcall *off_4C6B0)(_DWORD, _DWORD);
// 4C6B4: using guessed type int (__fastcall *off_4C6B4)(_DWORD);
// 4C6D8: using guessed type int (__fastcall *off_4C6D8)(_DWORD, _DWORD);
// 4C6E0: using guessed type int (__fastcall *off_4C6E0)(_DWORD, _DWORD);
// 4C6E8: using guessed type int (__fastcall *off_4C6E8)(_DWORD, _DWORD);
// 4C6F0: using guessed type int (__fastcall *off_4C6F0)(_DWORD, _DWORD);
// 4C6F8: using guessed type int (__fastcall *off_4C6F8)(_DWORD);
// 4C71C: using guessed type int (__fastcall *off_4C71C)(_DWORD, _DWORD, _DWORD);

//----- (00029768) --------------------------------------------------------
int __fastcall sub_29768(unsigned int a1, int a2, int a3, int a4, unsigned int *a5)
{
  int v6; // r2
  const char *v7; // r0
  int v11; // r5
  _DWORD *v12; // r4
  unsigned int v13; // r3
  void *v14; // r7

  if ( !a2 )
  {
    v6 = 31;
    v7 = "in != NULL";
    goto LABEL_3;
  }
  if ( !a4 )
  {
    v6 = 32;
    v7 = "out != NULL";
    goto LABEL_3;
  }
  if ( !a5 )
  {
    v6 = 33;
    v7 = "outlen != NULL";
LABEL_3:
    sub_26EB8(v7, "src/hashes/helper/hash_memory.c", v6);
  }
  v11 = sub_26FBC(a1);
  if ( !v11 )
  {
    v12 = &dword_4C47C[26 * a1];
    v13 = v12[2];
    if ( *a5 >= v13 )
    {
      v14 = malloc(0xD0u);
      if ( v14 )
      {
        v11 = ((int (*)(void))v12[21])();
        if ( !v11 )
        {
          v11 = ((int (__fastcall *)(void *, int, int))v12[22])(v14, a2, a3);
          if ( !v11 )
          {
            v11 = ((int (__fastcall *)(void *, int))v12[23])(v14, a4);
            *a5 = v12[2];
          }
        }
        free(v14);
      }
      else
      {
        return 13;
      }
    }
    else
    {
      *a5 = v13;
      return 6;
    }
  }
  return v11;
}
// 4C47C: using guessed type _DWORD dword_4C47C[130];

//----- (0002986C) --------------------------------------------------------
int __fastcall sub_2986C(unsigned int a1)
{
  if ( a1 > 4 )
    return 10;
  if ( dword_4C754[26 * a1] )
    return 0;
  return 10;
}
// 4C754: using guessed type _DWORD dword_4C754[130];

//----- (000298A0) --------------------------------------------------------
int __fastcall sub_298A0(unsigned int a1)
{
  if ( a1 > 4 )
    return 12;
  if ( dword_4C95C[10 * a1] )
    return 0;
  return 12;
}
// 4C95C: using guessed type _DWORD dword_4C95C[50];

//----- (000298D4) --------------------------------------------------------
int __fastcall sub_298D4(_DWORD *a1, int a2)
{
  int result; // r0
  int v5; // r12

  sub_2EB8C(a1);
  result = sub_2BA48((int)a1, a2 / 28 + 1);
  if ( !result )
  {
    v5 = a1[3];
    *a1 = a2 / 28 + 1;
    *(_DWORD *)(v5 + 4 * (a2 / 28)) = 1 << (a2 % 28);
  }
  return result;
}

//----- (00029934) --------------------------------------------------------
int __fastcall sub_29934(int *a1, int *a2, int *a3)
{
  int v4; // r7
  int v5; // r8
  int *v8; // r2
  int *v9; // r1
  int *v10; // r0

  v4 = a1[2];
  v5 = a2[2];
  if ( v4 == v5 )
  {
    a3[2] = v4;
    return sub_2EC08(a1, a2, a3);
  }
  else
  {
    if ( sub_29E8C(a1, a2) == -1 )
    {
      a3[2] = v5;
      v8 = a3;
      v9 = a1;
      v10 = a2;
    }
    else
    {
      a3[2] = v4;
      v8 = a3;
      v9 = a2;
      v10 = a1;
    }
    return sub_307E4(v10, v9, v8);
  }
}

//----- (0002999C) --------------------------------------------------------
int __fastcall sub_2999C(int *a1, unsigned int a2, int *a3)
{
  int v6; // r1
  int v7; // r0
  _DWORD *v8; // lr
  bool v9; // zf
  int v10; // r7
  int *v11; // r12
  int *v12; // r0
  int v13; // r1
  int *v14; // r12
  int v15; // r2
  unsigned int v16; // r1
  int i; // r6
  int v18; // t1
  unsigned int v19; // r1
  int v20; // r2
  size_t v21; // r2
  int result; // r0
  int v23; // r2
  int v24; // r6
  unsigned int *v25; // lr
  int v26; // r6
  int v27; // r3

  v6 = *a1 + 1;
  if ( a3[1] < v6 )
  {
    result = sub_2BA48((int)a3, v6);
    if ( result )
      return result;
  }
  v7 = a1[2];
  if ( v7 == 1 )
  {
    if ( *a1 > 1 || (v11 = (int *)a1[3], *v11 >= a2) )
    {
      a1[2] = 0;
      v24 = sub_2E7D4(a1, a2, a3);
      a3[2] = 1;
      a1[2] = 1;
      sub_29BBC(a3);
      return v24;
    }
    v8 = (_DWORD *)a3[3];
    v10 = *a3;
    v12 = v8 + 1;
    goto LABEL_21;
  }
  v8 = (_DWORD *)a3[3];
  v9 = v7 == 0;
  v10 = *a3;
  v11 = (int *)a1[3];
  v12 = v8 + 1;
  if ( !v9 )
  {
LABEL_21:
    v23 = 1;
    *a3 = 1;
    v27 = *a1;
    if ( *a1 == 1 )
      v23 = *v11;
    else
      v27 = 1;
    v26 = 2;
    if ( *a1 == 1 )
      a2 -= v23;
    *v8 = a2;
    goto LABEL_12;
  }
  v13 = *v11;
  v14 = v11 + 1;
  v15 = (a2 + v13) & 0xFFFFFFF;
  v16 = (a2 + v13) >> 28;
  *v8 = v15;
  if ( *a1 <= 1 )
  {
    v25 = v8 + 1;
    v26 = 3;
    v27 = 2;
  }
  else
  {
    for ( i = 1; ; ++i )
    {
      v18 = *v14++;
      v19 = v16 + v18;
      v20 = v19 & 0xFFFFFFF;
      v16 = v19 >> 28;
      *v12++ = v20;
      if ( *a1 <= i + 1 )
        break;
    }
    v27 = i + 2;
    v25 = (unsigned int *)v12;
    v26 = i + 3;
  }
  *v25 = v16;
  ++v12;
  *a3 = *a1 + 1;
LABEL_12:
  a3[2] = 0;
  if ( v27 < v10 )
  {
    if ( v26 <= v10 )
      v21 = 4 * (v10 + 1 - v26);
    else
      v21 = 4;
    memset(v12, 0, v21);
  }
  sub_29BBC(a3);
  return 0;
}

//----- (00029B48) --------------------------------------------------------
int __fastcall sub_29B48(int *a1, int *a2, int *a3, int *a4)
{
  int result; // r0
  int v9; // r4
  int v10[4]; // [sp+0h] [bp-10h] BYREF

  result = sub_2BAD0((int)v10);
  if ( !result )
  {
    v9 = sub_29934(a1, a2, v10);
    if ( !v9 )
      v9 = sub_2C470(v10, a3, a4);
    sub_29D74((int)v10);
    return v9;
  }
  return result;
}

//----- (00029BBC) --------------------------------------------------------
int *__fastcall sub_29BBC(int *result)
{
  int v1; // r3
  int v2; // r2
  int v3; // r12
  int v4; // r2
  int v5; // r12
  int v6; // r1
  int v7; // t1
  int v8; // t1
  int v9; // t1
  int v10; // t1
  int v11; // t1
  int v12; // t1
  int v13; // t1
  int v14; // r4
  bool v15; // zf
  int v16; // r5
  int v17; // r6
  int v18; // r7
  int v19; // r8
  int v20; // r12
  int v21; // t1

  v1 = *result;
  if ( *result <= 0 )
  {
    if ( !*result )
      result[2] = 0;
  }
  else
  {
    v2 = result[3];
    v3 = *(_DWORD *)(v2 + 4 * (v1 + 0x3FFFFFFF));
    v4 = v2 + 4 * (v1 + 0x3FFFFFFF);
    if ( !v3 )
    {
      v5 = v1 - 1;
      v6 = (v1 - 1) & 7;
      if ( !v6 )
        goto LABEL_32;
      --v1;
      *result = v5;
      v7 = *(_DWORD *)(v4 - 4);
      v4 -= 4;
      if ( !v7 )
      {
        switch ( v6 )
        {
          case 1:
            goto LABEL_32;
          case 2:
            goto LABEL_33;
          case 3:
            goto LABEL_34;
          case 4:
            goto LABEL_35;
          case 5:
            goto LABEL_36;
        }
        if ( v6 == 6 || (--v1, *result = v1, v8 = *(_DWORD *)(v4 - 4), v4 -= 4, !v8) )
        {
          *result = --v1;
          v9 = *(_DWORD *)(v4 - 4);
          v4 -= 4;
          if ( !v9 )
          {
LABEL_36:
            *result = --v1;
            v10 = *(_DWORD *)(v4 - 4);
            v4 -= 4;
            if ( !v10 )
            {
LABEL_35:
              *result = --v1;
              v11 = *(_DWORD *)(v4 - 4);
              v4 -= 4;
              if ( !v11 )
              {
LABEL_34:
                *result = --v1;
                v12 = *(_DWORD *)(v4 - 4);
                v4 -= 4;
                if ( !v12 )
                {
LABEL_33:
                  *result = --v1;
                  v13 = *(_DWORD *)(v4 - 4);
                  v4 -= 4;
                  if ( !v13 )
                  {
LABEL_32:
                    while ( 1 )
                    {
                      v14 = v1 - 3;
                      v15 = v1 == 1;
                      v16 = v1 - 4;
                      v17 = v1 - 5;
                      v18 = v1 - 6;
                      v19 = v1 - 7;
                      v20 = v1 - 2;
                      *result = v1 - 1;
                      v1 -= 8;
                      if ( v15 )
                        break;
                      if ( !*(_DWORD *)(v4 - 4) )
                      {
                        *result = v20;
                        if ( !*(_DWORD *)(v4 - 8) )
                        {
                          *result = v14;
                          if ( !*(_DWORD *)(v4 - 12) )
                          {
                            *result = v16;
                            if ( !*(_DWORD *)(v4 - 16) )
                            {
                              *result = v17;
                              if ( !*(_DWORD *)(v4 - 20) )
                              {
                                *result = v18;
                                if ( !*(_DWORD *)(v4 - 24) )
                                {
                                  *result = v19;
                                  if ( !*(_DWORD *)(v4 - 28) )
                                  {
                                    *result = v1;
                                    v21 = *(_DWORD *)(v4 - 32);
                                    v4 -= 32;
                                    if ( !v21 )
                                      continue;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      return result;
                    }
                    result[2] = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (00029D74) --------------------------------------------------------
int __fastcall sub_29D74(int result)
{
  int v1; // r3
  int v2; // r4

  v1 = *(_DWORD *)(result + 12);
  if ( v1 )
  {
    v2 = result;
    j_explicit_bzero(v1, 4 * *(_DWORD *)(result + 4));
    free(*(void **)(v2 + 12));
    *(_DWORD *)(v2 + 12) = 0;
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    return 0;
  }
  return result;
}
// 17ED4: using guessed type int __fastcall j_explicit_bzero(_DWORD, _DWORD);

//----- (00029DB8) --------------------------------------------------------
int sub_29DB8(int result, ...)
{
  char *v1; // r4
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, result);
  va_copy(v1, varg_r1);
  for ( ; result; result = *((_DWORD *)v1 - 1) )
  {
    v1 += 4;
    sub_29D74(result);
  }
  return result;
}

//----- (00029E00) --------------------------------------------------------
int __fastcall sub_29E00(int *a1, int *a2)
{
  int v2; // r3

  v2 = a1[2];
  if ( v2 == a2[2] )
  {
    if ( v2 == 1 )
      return sub_29E8C(a2, a1);
    else
      return sub_29E8C(a1, a2);
  }
  else if ( v2 == 1 )
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

//----- (00029E48) --------------------------------------------------------
int __fastcall sub_29E48(int a1, unsigned int a2)
{
  unsigned int v3; // r3

  if ( *(_DWORD *)(a1 + 8) == 1 )
    return -1;
  if ( *(int *)a1 > 1 )
    return 1;
  v3 = **(_DWORD **)(a1 + 12);
  if ( v3 > a2 )
    return 1;
  if ( v3 >= a2 )
    return 0;
  return -1;
}

//----- (00029E8C) --------------------------------------------------------
int __fastcall sub_29E8C(int *a1, int *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // lr
  int v5; // r3
  int v6; // r1
  int v7; // r0
  int v8; // r3
  unsigned int v9; // lr
  unsigned int v10; // r2
  int v11; // r2
  int v12; // r1
  unsigned int v13; // r4
  unsigned int v14; // t1
  unsigned int v15; // t1
  bool v16; // cf
  unsigned int v17; // lr
  unsigned int v18; // t1
  unsigned int v19; // t1
  bool v20; // cf
  unsigned int v21; // lr
  unsigned int v22; // t1
  unsigned int v23; // t1
  bool v24; // cf
  unsigned int v25; // lr
  unsigned int v26; // t1
  unsigned int v27; // t1
  bool v28; // cf
  unsigned int v29; // lr
  unsigned int v30; // t1
  unsigned int v31; // t1
  bool v32; // cf
  unsigned int v33; // lr
  unsigned int v34; // t1
  unsigned int v35; // t1
  bool v36; // cf
  unsigned int v37; // lr
  unsigned int v38; // t1
  unsigned int v39; // t1
  bool v40; // cf
  int v41; // r1
  unsigned int v42; // r5
  int v43; // lr
  unsigned int v44; // r4
  int v45; // r2
  unsigned int v46; // r5
  unsigned int v47; // r4
  unsigned int v48; // r5
  unsigned int v49; // r4
  unsigned int v50; // r5
  unsigned int v51; // r4
  unsigned int v52; // r0
  unsigned int v53; // r3
  unsigned int v54; // r0
  unsigned int v55; // r3
  unsigned int v56; // r0
  unsigned int v57; // r3
  unsigned int v58; // r5
  unsigned int v59; // r4

  v2 = *a1;
  if ( *a1 > *a2 )
    return 1;
  if ( *a1 < *a2 )
    return -1;
  v3 = v2 + 0x3FFFFFFF;
  v4 = a1[3];
  v5 = 4 * (v2 + 0x3FFFFFFF);
  v6 = a2[3];
  v7 = v4 + v5;
  v8 = v6 + v5;
  if ( v2 > 0 )
  {
    v9 = *(_DWORD *)(v4 + 4 * v3);
    v10 = *(_DWORD *)(v6 + 4 * v3);
    if ( v10 >= v9 )
    {
      if ( v10 > v9 )
        return -1;
      v11 = ((_BYTE)v2 - 1) & 7;
      v12 = 0;
      if ( (((_BYTE)v2 - 1) & 7) == 0 )
        goto LABEL_34;
      v14 = *(_DWORD *)(v7 - 4);
      v7 -= 4;
      v13 = v14;
      v12 = 1;
      v15 = *(_DWORD *)(v8 - 4);
      v8 -= 4;
      v16 = v13 >= v15;
      if ( v13 <= v15 )
      {
        if ( !v16 )
          return -1;
        if ( v11 == 1 )
          goto LABEL_34;
        if ( v11 != 2 )
        {
          if ( v11 != 3 )
          {
            if ( v11 != 4 )
            {
              if ( v11 != 5 )
              {
                if ( v11 != 6 )
                {
                  v18 = *(_DWORD *)(v7 - 4);
                  v7 -= 4;
                  v17 = v18;
                  v12 = 2;
                  v19 = *(_DWORD *)(v8 - 4);
                  v8 -= 4;
                  v20 = v17 >= v19;
                  if ( v17 > v19 )
                    return 1;
                  if ( !v20 )
                    return -1;
                }
                v22 = *(_DWORD *)(v7 - 4);
                v7 -= 4;
                v21 = v22;
                ++v12;
                v23 = *(_DWORD *)(v8 - 4);
                v8 -= 4;
                v24 = v21 >= v23;
                if ( v21 > v23 )
                  return 1;
                if ( !v24 )
                  return -1;
              }
              v26 = *(_DWORD *)(v7 - 4);
              v7 -= 4;
              v25 = v26;
              ++v12;
              v27 = *(_DWORD *)(v8 - 4);
              v8 -= 4;
              v28 = v25 >= v27;
              if ( v25 > v27 )
                return 1;
              if ( !v28 )
                return -1;
            }
            v30 = *(_DWORD *)(v7 - 4);
            v7 -= 4;
            v29 = v30;
            ++v12;
            v31 = *(_DWORD *)(v8 - 4);
            v8 -= 4;
            v32 = v29 >= v31;
            if ( v29 > v31 )
              return 1;
            if ( !v32 )
              return -1;
          }
          v34 = *(_DWORD *)(v7 - 4);
          v7 -= 4;
          v33 = v34;
          ++v12;
          v35 = *(_DWORD *)(v8 - 4);
          v8 -= 4;
          v36 = v33 >= v35;
          if ( v33 > v35 )
            return 1;
          if ( !v36 )
            return -1;
        }
        v38 = *(_DWORD *)(v7 - 4);
        v7 -= 4;
        v37 = v38;
        ++v12;
        v39 = *(_DWORD *)(v8 - 4);
        v8 -= 4;
        v40 = v37 >= v39;
        if ( v37 <= v39 )
        {
          while ( v40 )
          {
LABEL_34:
            v41 = v12 + 1;
            if ( v2 == v41 )
              return 0;
            v42 = *(_DWORD *)(v7 - 4);
            v43 = v7 - 4;
            v44 = *(_DWORD *)(v8 - 4);
            v45 = v8 - 4;
            if ( v42 <= v44 )
            {
              if ( v42 < v44 )
                return -1;
              v46 = *(_DWORD *)(v7 - 8);
              v47 = *(_DWORD *)(v8 - 8);
              if ( v46 <= v47 )
              {
                if ( v46 < v47 )
                  return -1;
                v48 = *(_DWORD *)(v7 - 12);
                v49 = *(_DWORD *)(v8 - 12);
                if ( v48 <= v49 )
                {
                  if ( v48 < v49 )
                    return -1;
                  v50 = *(_DWORD *)(v7 - 16);
                  v51 = *(_DWORD *)(v8 - 16);
                  if ( v50 <= v51 )
                  {
                    if ( v50 < v51 )
                      return -1;
                    v52 = *(_DWORD *)(v7 - 20);
                    v53 = *(_DWORD *)(v8 - 20);
                    if ( v52 <= v53 )
                    {
                      if ( v52 < v53 )
                        return -1;
                      v54 = *(_DWORD *)(v43 - 20);
                      v55 = *(_DWORD *)(v45 - 20);
                      if ( v54 <= v55 )
                      {
                        if ( v54 < v55 )
                          return -1;
                        v56 = *(_DWORD *)(v43 - 24);
                        v57 = *(_DWORD *)(v45 - 24);
                        if ( v56 <= v57 )
                        {
                          if ( v56 < v57 )
                            return -1;
                          v58 = *(_DWORD *)(v43 - 28);
                          v12 = v41 + 7;
                          v59 = *(_DWORD *)(v45 - 28);
                          v7 = v43 - 28;
                          v8 = v45 - 28;
                          v40 = v58 >= v59;
                          if ( v58 <= v59 )
                            continue;
                        }
                      }
                    }
                  }
                }
              }
            }
            return 1;
          }
          return -1;
        }
      }
    }
    return 1;
  }
  return 0;
}

//----- (0002A0A4) --------------------------------------------------------
int __fastcall sub_2A0A4(int *a1)
{
  int v1; // r2
  unsigned int *v2; // r1
  unsigned int v3; // r3
  int v4; // r0
  int v5; // r12
  unsigned int v6; // t1
  unsigned int v7; // t1
  unsigned int v8; // t1
  unsigned int v9; // t1
  unsigned int v10; // t1
  unsigned int v11; // t1
  unsigned int v12; // t1
  int v13; // r12
  unsigned int v14; // t1
  int v15; // r2
  int v16; // r1

  v1 = *a1;
  if ( !*a1 )
    return 0;
  v2 = (unsigned int *)a1[3];
  v3 = *v2;
  if ( *a1 <= 0 || v3 )
  {
    v15 = 0;
  }
  else
  {
    v4 = 0;
    v5 = ((_BYTE)v1 - 1) & 7;
    if ( (((_BYTE)v1 - 1) & 7) == 0 )
      goto LABEL_36;
    v6 = v2[1];
    ++v2;
    v3 = v6;
    v4 = 1;
    if ( v6 )
      goto LABEL_27;
    if ( v5 == 1 )
      goto LABEL_36;
    if ( v5 != 2 )
    {
      if ( v5 != 3 )
      {
        if ( v5 != 4 )
        {
          if ( v5 != 5 )
          {
            if ( v5 != 6 )
            {
              v7 = v2[1];
              ++v2;
              v3 = v7;
              v4 = 2;
              if ( v7 )
                goto LABEL_27;
            }
            v8 = v2[1];
            ++v2;
            v3 = v8;
            ++v4;
            if ( v8 )
              goto LABEL_27;
          }
          v9 = v2[1];
          ++v2;
          v3 = v9;
          ++v4;
          if ( v9 )
            goto LABEL_27;
        }
        v10 = v2[1];
        ++v2;
        v3 = v10;
        ++v4;
        if ( v10 )
          goto LABEL_27;
      }
      v11 = v2[1];
      ++v2;
      v3 = v11;
      ++v4;
      if ( v11 )
        goto LABEL_27;
    }
    v12 = v2[1];
    ++v2;
    v3 = v12;
    ++v4;
    if ( v12 )
    {
LABEL_27:
      v15 = 28 * v4;
    }
    else
    {
LABEL_36:
      while ( 1 )
      {
        v13 = ++v4;
        v3 = v2[1];
        if ( v1 == v4 )
          break;
        if ( !v3 )
        {
          v3 = v2[2];
          ++v4;
          if ( !v3 )
          {
            v3 = v2[3];
            v4 = v13 + 2;
            if ( !v3 )
            {
              v3 = v2[4];
              v4 = v13 + 3;
              if ( !v3 )
              {
                v3 = v2[5];
                v4 = v13 + 4;
                if ( !v3 )
                {
                  v3 = v2[6];
                  v4 = v13 + 5;
                  if ( !v3 )
                  {
                    v3 = v2[7];
                    v4 = v13 + 6;
                    if ( !v3 )
                    {
                      v14 = v2[8];
                      v2 += 8;
                      v3 = v14;
                      v4 = v13 + 7;
                      if ( !v14 )
                        continue;
                    }
                  }
                }
              }
            }
          }
        }
        goto LABEL_27;
      }
      v15 = 28 * v1;
    }
  }
  if ( (v3 & 1) == 0 )
  {
    do
    {
      v16 = v3 & 0xF;
      v3 >>= 4;
      v15 += dword_3AC70[v16];
    }
    while ( !v16 );
  }
  return v15;
}
// 3AC70: using guessed type _DWORD dword_3AC70[16];

//----- (0002A25C) --------------------------------------------------------
int __fastcall sub_2A25C(int *a1, int *a2)
{
  int v3; // r3
  int v5; // r1
  _DWORD *v6; // r2
  int v7; // r3
  int v8; // r12
  int v9; // t1
  int v10; // r2
  int result; // r0

  if ( a1 == a2 )
    return 0;
  v3 = a2[1];
  v5 = *a1;
  if ( v3 < *a1 )
  {
    result = sub_2BA48((int)a2, v5);
    if ( result )
      return result;
    v5 = *a1;
  }
  v6 = (_DWORD *)a2[3];
  if ( v5 > 0 )
  {
    v8 = a1[3] - 4;
    v7 = 0;
    do
    {
      v9 = *(_DWORD *)(v8 + 4);
      v8 += 4;
      ++v7;
      *v6++ = v9;
      v5 = *a1;
    }
    while ( *a1 > v7 );
  }
  else
  {
    v7 = 0;
  }
  if ( *a2 > v7 )
  {
    do
    {
      *v6++ = 0;
      ++v7;
    }
    while ( *a2 > v7 );
    v5 = *a1;
  }
  v10 = a1[2];
  *a2 = v5;
  a2[2] = v10;
  return 0;
}

//----- (0002A310) --------------------------------------------------------
int __fastcall sub_2A310(int *a1)
{
  int result; // r0
  unsigned int v3; // r3

  result = *a1;
  if ( result )
  {
    v3 = *(_DWORD *)(a1[3] + 4 * (result + 0x3FFFFFFF));
    for ( result = 28 * (result - 1); v3; ++result )
      v3 >>= 1;
  }
  return result;
}

//----- (0002A350) --------------------------------------------------------
int __fastcall sub_2A350(int *a1, int *a2)
{
  int v3; // r3
  int v5; // r1
  int v6; // r10
  int v7; // r0
  int v8; // r4
  int v9; // r2
  unsigned int *v10; // r9
  int *v11; // r7
  unsigned int *v12; // r12
  int v13; // r8
  int *v14; // r3
  int v15; // r1
  unsigned int v16; // lr
  unsigned int v17; // r1
  int v18; // lr
  unsigned int v19; // r1
  int v20; // r0
  unsigned int v21; // r1
  int v22; // lr
  unsigned int v23; // r1
  int v24; // r0
  unsigned int v25; // r1
  int v26; // lr
  unsigned int v27; // r1
  int v28; // lr
  int v29; // r12
  unsigned int v30; // t1
  int v31; // r0
  unsigned int v32; // t1
  int v33; // r3
  unsigned int v34; // t1
  int v35; // lr
  int *v36; // lr
  unsigned int *v37; // r0
  unsigned int v38; // r3
  int v39; // r8
  unsigned int v40; // r3
  unsigned int v41; // lr
  int result; // r0

  v3 = a2[1];
  v5 = *a1;
  if ( v3 < *a1 )
  {
    result = sub_2BA48((int)a2, v5);
    if ( result )
      return result;
    v5 = *a1;
  }
  v6 = a2[3];
  v7 = 4 * (v5 + 0x3FFFFFFF);
  v8 = v5 - 1;
  v9 = *a2;
  v10 = (unsigned int *)(a1[3] + v7);
  *a2 = v5;
  v11 = (int *)(v6 + v7);
  if ( v5 - 1 >= 0 )
  {
    if ( v5 - 2 <= 6 )
    {
      v15 = 0;
    }
    else
    {
      v12 = v10 - 8;
      v13 = ((_BYTE)v5 - 9) & 7;
      v14 = v11 - 8;
      v15 = 0;
      do
      {
        v16 = v12[8];
        __pld(v12 - 11);
        v8 -= 8;
        __pld(v14 - 11);
        v10 = v12;
        v11 = v14;
        v14[8] = (v15 << 27) | (v16 >> 1);
        v17 = v12[7];
        v14 -= 8;
        v12 -= 8;
        v14[15] = (v16 << 27) & 0x8000000 | (v17 >> 1);
        v18 = (v17 << 27) & 0x8000000;
        v19 = v12[14];
        v14[14] = v18 | (v19 >> 1);
        v20 = (v19 << 27) & 0x8000000;
        v21 = v12[13];
        v14[13] = v20 | (v21 >> 1);
        v22 = (v21 << 27) & 0x8000000;
        v23 = v12[12];
        v14[12] = v22 | (v23 >> 1);
        v24 = (v23 << 27) & 0x8000000;
        v25 = v12[11];
        v14[11] = v24 | (v25 >> 1);
        v26 = (v25 << 27) & 0x8000000;
        v27 = v12[10];
        v14[10] = v26 | (v27 >> 1);
        v28 = (v27 << 27) & 0x8000000 | (v12[9] >> 1);
        v15 = v12[9] & 1;
        v14[9] = v28;
      }
      while ( v13 != v8 );
    }
    v29 = (v8 + 1) & 3;
    if ( !v29 )
      goto LABEL_22;
    if ( v29 != 1 )
    {
      if ( v29 != 2 )
      {
        v30 = *v10--;
        --v8;
        v31 = (v30 >> 1) | (v15 << 27);
        v15 = v30 & 1;
        *v11-- = v31;
      }
      v32 = *v10--;
      --v8;
      v33 = (v32 >> 1) | (v15 << 27);
      v15 = v32 & 1;
      *v11-- = v33;
    }
    v34 = *v10--;
    --v8;
    v35 = (v34 >> 1) | (v15 << 27);
    v15 = v34 & 1;
    *v11-- = v35;
    if ( v8 != -1 )
    {
LABEL_22:
      do
      {
        v36 = v11;
        v37 = v10 - 1;
        v38 = *v10;
        v8 -= 4;
        v11 -= 4;
        v10 -= 4;
        v39 = v38 & 1;
        *v36 = (v38 >> 1) | (v15 << 27);
        v40 = v10[3];
        *(v36 - 1) = (v40 >> 1) | (v39 << 27);
        v41 = *(v37 - 1);
        v11[2] = (v41 >> 1) | ((v40 & 1) << 27);
        v15 = v10[1] & 1;
        v11[1] = (v10[1] >> 1) | ((v41 & 1) << 27);
      }
      while ( v8 != -1 );
    }
    v5 = *a2;
  }
  if ( v9 > v5 )
    memset((void *)(v6 + 4 * v5), 0, 4 * (v9 - v5));
  a2[2] = a1[2];
  sub_29BBC(a2);
  return 0;
}

//----- (0002A5A8) --------------------------------------------------------
int __fastcall sub_2A5A8(int *a1, int *a2, int *a3, int *a4)
{
  int *v5; // r5
  int v8; // r7
  int v10; // r7
  int v11; // r9
  int v12; // r10
  int v13; // r0
  int v14; // r8
  int v15; // r11
  int v16; // r9
  int v17; // r10
  int v18; // r0
  int v19; // r3
  int v20; // r10
  int v21; // r11
  int v22; // r9
  int v23; // r6
  int v24; // r7
  int v25; // r7
  unsigned int v26; // r0
  unsigned int v27; // r2
  int v28; // r4
  int v29; // r5
  int *v30; // r8
  unsigned __int64 v31; // r0
  unsigned __int64 v32; // r0
  int v33; // r2
  int v34; // r12
  int v35; // r2
  int *v36; // r3
  int v37; // r2
  int v38; // r2
  _DWORD *v39; // r0
  int v40; // r2
  int v41; // r1
  _DWORD *v42; // r3
  int v43; // r12
  int v44; // r1
  int v45; // r0
  int v46; // [sp+4h] [bp-80h]
  int v47; // [sp+8h] [bp-7Ch]
  int v48; // [sp+Ch] [bp-78h]
  int v49; // [sp+10h] [bp-74h]
  int v50; // [sp+10h] [bp-74h]
  int v51; // [sp+18h] [bp-6Ch]
  int v52; // [sp+20h] [bp-64h]
  int *v53; // [sp+24h] [bp-60h]
  int *v54; // [sp+28h] [bp-5Ch]
  int *v55; // [sp+2Ch] [bp-58h]
  int v56[3]; // [sp+30h] [bp-54h] BYREF
  int v57; // [sp+3Ch] [bp-48h]
  int v58[2]; // [sp+40h] [bp-44h] BYREF
  int v59; // [sp+48h] [bp-3Ch]
  int v60; // [sp+4Ch] [bp-38h]
  int v61[3]; // [sp+50h] [bp-34h] BYREF
  int v62; // [sp+5Ch] [bp-28h]
  int v63[3]; // [sp+60h] [bp-24h] BYREF
  _DWORD *v64; // [sp+6Ch] [bp-18h]
  int v65[3]; // [sp+70h] [bp-14h] BYREF
  int *v66; // [sp+7Ch] [bp-8h]

  if ( !*a2 )
    return -3;
  v5 = a1;
  if ( sub_29E8C(a1, a2) == -1 )
  {
    if ( a4 )
      v8 = sub_2A25C(v5, a4);
    else
      v8 = 0;
    if ( a3 )
      sub_2EB8C(a3);
    return v8;
  }
  v8 = sub_2BB58(v56, *v5 + 2);
  if ( v8 )
    return v8;
  v56[0] = *v5 + 2;
  v10 = sub_2BAD0((int)v63);
  if ( !v10 )
  {
    v10 = sub_2BAD0((int)v65);
    if ( v10 )
    {
LABEL_13:
      sub_29D74((int)v63);
      goto LABEL_11;
    }
    v10 = sub_2BB10(v58, v5);
    if ( v10 )
    {
LABEL_15:
      sub_29D74((int)v65);
      goto LABEL_13;
    }
    v10 = sub_2BB10(v61, a2);
    if ( v10 )
    {
LABEL_18:
      sub_29D74((int)v58);
      goto LABEL_15;
    }
    v11 = a2[2];
    v12 = v5[2];
    v61[2] = 0;
    v48 = v11;
    v59 = 0;
    v47 = v12;
    v13 = sub_2A310(v61) % 28;
    if ( v13 != 27 )
    {
      v14 = 27 - v13;
      v10 = sub_2CA58(v58, 27 - v13, v58);
      if ( v10 || (v10 = sub_2CA58(v61, v14, v61)) != 0 )
      {
LABEL_21:
        sub_29D74((int)v61);
        goto LABEL_18;
      }
      v10 = v14;
    }
    v15 = v58[0];
    v46 = v61[0];
    v16 = v58[0] - 1;
    v49 = v61[0] - 1;
    v17 = v58[0] - v61[0];
    v18 = sub_2C160(v61, v58[0] - v61[0]);
    if ( v18 )
    {
LABEL_25:
      v10 = v18;
    }
    else
    {
      while ( sub_29E00(v58, v61) != -1 )
      {
        ++*(_DWORD *)(v57 + 4 * v17);
        v18 = sub_2E764(v58, v61, v58);
        if ( v18 )
          goto LABEL_25;
      }
      sub_2E5A0(v61, v17);
      if ( v46 <= v16 )
      {
        v20 = 4 * v16;
        v21 = v15 - 2;
        v52 = v10;
        v53 = a3;
        v51 = v46 - 2;
        v22 = 4 * v49;
        v50 = 4 * v49 - 4;
        v19 = v58[0];
        v54 = a4;
        v55 = v5;
        while ( 1 )
        {
          if ( v19 >= v21 + 1 )
          {
            v25 = v60;
            v23 = v20 - 4;
            v26 = *(_DWORD *)(v60 + v20);
            v27 = *(_DWORD *)(v62 + v22);
            v28 = -4 * v46 + v20;
            v29 = v57;
            if ( v26 == v27 )
              v25 = 0xFFFFFFF;
            v30 = (int *)(v57 + v28);
            if ( v26 == v27 )
            {
              *(_DWORD *)(v57 + v28) = v25;
            }
            else
            {
              HIDWORD(v31) = v26 >> 4;
              LODWORD(v31) = *(_DWORD *)(v25 + v23) | (v26 << 28);
              LODWORD(v32) = sub_34E18(v31, v27);
              if ( v32 > 0xFFFFFFF )
                LODWORD(v32) = 0xFFFFFFF;
              *v30 = v32;
            }
            v33 = v29;
            v24 = v21 - 1;
            *v30 = (*v30 + 1) & 0xFFFFFFF;
            while ( 1 )
            {
              *(_DWORD *)(v33 + v28) = (*(_DWORD *)(v33 + v28) - 1) & 0xFFFFFFF;
              v39 = sub_2EB8C(v63);
              v41 = v62;
              if ( v51 < 0 )
                v39 = 0;
              else
                v40 = v50;
              v42 = v64;
              v43 = v57;
              if ( v51 >= 0 )
                v39 = *(_DWORD **)(v62 + v40);
              *v64 = v39;
              v44 = *(_DWORD *)(v41 + v22);
              v63[0] = 2;
              v42[1] = v44;
              v45 = sub_2CBE4(v63, *(_DWORD *)(v43 + v28), v63);
              v35 = v45;
              if ( v45 )
              {
                v10 = v45;
                goto LABEL_21;
              }
              v34 = v60;
              if ( v24 >= 0 )
                v35 = *(_DWORD *)(v60 + v20 - 8);
              v36 = v66;
              *v66 = v35;
              v37 = v21 >= 0 ? *(_DWORD *)(v34 + v23) : 0;
              v36[1] = v37;
              v38 = *(_DWORD *)(v34 + v20);
              v65[0] = 3;
              v36[2] = v38;
              if ( sub_29E8C(v63, v65) != 1 )
                break;
              v33 = v57;
            }
            v18 = sub_2CBE4(v61, *(_DWORD *)(v57 + v28), v63);
            if ( v18 )
              goto LABEL_25;
            v18 = sub_2C160(v63, 1 - v46 + v21);
            if ( v18 )
              goto LABEL_25;
            v18 = sub_2E764(v58, v63, v58);
            if ( v18 )
              goto LABEL_25;
            if ( v59 == 1 )
            {
              v18 = sub_2A25C(v61, v63);
              if ( v18 )
                goto LABEL_25;
              v18 = sub_2C160(v63, 1 - v46 + v21);
              if ( v18 )
                goto LABEL_25;
              v18 = sub_29934(v58, v63, v58);
              if ( v18 )
                goto LABEL_25;
              *(_DWORD *)(v57 + v28) = (*(_DWORD *)(v57 + v28) - 1) & 0xFFFFFFF;
            }
            v19 = v58[0];
          }
          else
          {
            v23 = v20 - 4;
            v24 = v21 - 1;
          }
          v20 = v23;
          if ( v46 > v21 )
            break;
          v21 = v24;
        }
        v10 = v52;
        a3 = v53;
        a4 = v54;
        v5 = v55;
      }
      else
      {
        v19 = v58[0];
      }
      if ( v19 )
        v19 = v5[2];
      v59 = v19;
      if ( a3 )
      {
        sub_29BBC(v56);
        sub_2AAD4(v56, a3);
        a3[2] = v47 != v48;
      }
      if ( a4 )
      {
        v10 = sub_329D0(v58, v10, v58, 0);
        if ( !v10 )
          sub_2AAD4(v58, a4);
      }
      else
      {
        v10 = 0;
      }
    }
    goto LABEL_21;
  }
LABEL_11:
  sub_29D74((int)v56);
  return v10;
}
// 2A88C: variable 'v32' is possibly undefined
// 2A950: variable 'v40' is possibly undefined

//----- (0002AAD4) --------------------------------------------------------
int __fastcall sub_2AAD4(int *a1, int *a2)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v7; // [sp+0h] [bp-10h]
  int v8; // [sp+4h] [bp-Ch]
  int v9; // [sp+8h] [bp-8h]
  int v10; // [sp+Ch] [bp-4h]

  v7 = *a1;
  v8 = a1[1];
  v9 = a1[2];
  v10 = a1[3];
  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  *a1 = *a2;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  *a2 = v7;
  a2[1] = v8;
  a2[2] = v9;
  a2[3] = v10;
  return v7;
}

//----- (0002AB08) --------------------------------------------------------
int __fastcall sub_2AB08(int *a1, int *a2, int a3, int *a4)
{
  int v8; // r0
  int v9; // r6
  int v11[4]; // [sp+8h] [bp-20h] BYREF
  int v12[4]; // [sp+18h] [bp-10h] BYREF

  if ( *(_DWORD *)(a3 + 8) == 1 )
    return -3;
  if ( a2[2] == 1 )
  {
    v9 = sub_2BAD0((int)v11);
    if ( !v9 )
    {
      v9 = sub_2BBA8(a1, a3, v11);
      if ( v9 || (v9 = sub_2BAD0((int)v12)) != 0 )
      {
        sub_29D74((int)v11);
      }
      else
      {
        v9 = sub_329A8(a2, v12);
        if ( !v9 )
          v9 = sub_2AB08(v11, v12, a3, a4);
        sub_29DB8((int)v11, v12, 0);
      }
    }
    return v9;
  }
  v8 = sub_2E444((int *)a3);
  if ( v8 != 1 )
  {
    v8 = sub_32FCC((int *)a3);
    if ( v8 )
      return sub_2AC78(a1, a2, (int *)a3, a4, v8);
    v8 = 2 * sub_2E1FC((int *)a3);
    if ( *(int *)a3 > 0 && (**(_DWORD **)(a3 + 12) & 1) != 0 )
      return sub_2AC78(a1, a2, (int *)a3, a4, v8);
    if ( v8 )
      return sub_2AC78(a1, a2, (int *)a3, a4, v8);
  }
  return sub_2F1F4(a1, a2, (int *)a3, a4, v8);
}

//----- (0002AC78) --------------------------------------------------------
int __fastcall sub_2AC78(int *a1, int *a2, int *a3, int *a4, int a5)
{
  int v5; // r8
  int v7; // r0
  int v8; // r11
  int v9; // r5
  int v11; // r3
  int *v12; // r7
  int v13; // r10
  int *v14; // r4
  int v15; // r5
  int v16; // r9
  _DWORD *v17; // r0
  int (__fastcall *v18)(int *, int *, int); // r10
  int *v19; // r11
  int *v20; // r9
  unsigned int v21; // r2
  int v22; // r0
  int v23; // r0
  int v24; // r0
  int v25; // r0
  int v26; // r0
  int v27; // r0
  int v28; // r0
  int *v29; // r10
  unsigned int v30; // r6
  int v31; // r0
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0
  int v38; // r1
  bool v39; // cc
  int *v40; // r4
  int v41; // r0
  int v42; // r12
  int v43; // r2
  int v44; // r2
  int v45; // r2
  int v46; // r4
  int v47; // r5
  int *v48; // r9
  int *v49; // r0
  int *v50; // r0
  int v51; // r5
  int *v52; // r7
  int v53; // r12
  int *v54; // r8
  int *v55; // r4
  int v56; // r5
  unsigned int v57; // r4
  int v58; // r3
  int v59; // r9
  int *v60; // r8
  int v61; // r6
  int v62; // lr
  unsigned int v63; // r2
  int v65; // r6
  _BOOL4 v66; // r2
  int *v67; // r6
  int v68; // r9
  int v69; // r4
  int v71; // [sp+4h] [bp-1038h]
  int v72; // [sp+4h] [bp-1038h]
  int v73; // [sp+8h] [bp-1034h]
  int v74; // [sp+8h] [bp-1034h]
  int v75; // [sp+8h] [bp-1034h]
  int v78; // [sp+14h] [bp-1028h]
  int v79; // [sp+18h] [bp-1024h]
  int v80; // [sp+1Ch] [bp-1020h]
  int v81; // [sp+24h] [bp-1018h] BYREF
  int v82[8]; // [sp+28h] [bp-1014h] BYREF
  int v83[1021]; // [sp+48h] [bp-FF4h] BYREF

  v7 = sub_2A310(a2);
  if ( v7 <= 7 )
  {
    v8 = 4;
    v5 = 2;
    v79 = 2;
    v73 = 32;
    v78 = 1;
  }
  else if ( v7 > 36 )
  {
    if ( v7 <= 140 )
    {
      v73 = 128;
      v5 = 8;
      v8 = 16;
      v78 = 3;
      v79 = 4;
    }
    else if ( v7 <= 450 )
    {
      v73 = 256;
      v5 = 16;
      v8 = 32;
      v78 = 4;
      v79 = 5;
    }
    else if ( v7 > 1303 )
    {
      if ( v7 <= 3529 )
        v43 = 1024;
      else
        v43 = 2048;
      v73 = v43;
      if ( v7 <= 3529 )
        v44 = 6;
      else
        v44 = 7;
      if ( v7 > 3529 )
        v5 = 128;
      v78 = v44;
      if ( v7 <= 3529 )
      {
        v45 = 7;
        v5 = 64;
      }
      else
      {
        v45 = 8;
      }
      if ( v7 <= 3529 )
        v8 = 128;
      else
        v8 = 256;
      v79 = v45;
    }
    else
    {
      v5 = 32;
      v8 = 64;
      v73 = 512;
      v78 = 5;
      v79 = 6;
    }
  }
  else
  {
    v5 = 4;
    v8 = 8;
    v73 = 64;
    v78 = 2;
    v79 = 3;
  }
  v9 = sub_2BB58(v83, a3[1]);
  if ( v9 )
    return v9;
  v11 = (v8 - v5) & 7;
  v12 = &v82[4 * v5 + 4];
  v80 = 4 * v5;
  v13 = v5;
  v14 = v12;
  if ( !v11 )
  {
LABEL_32:
    while ( 1 )
    {
      v15 = sub_2BB58(v14, a3[1]);
      if ( v15 )
        goto LABEL_63;
      ++v13;
      v15 = sub_2BB58(v14 + 4, a3[1]);
      v16 = v13;
      if ( v15 )
        goto LABEL_63;
      ++v13;
      v15 = sub_2BB58(v14 + 8, a3[1]);
      if ( v15 )
        goto LABEL_63;
      v13 = v16 + 2;
      v15 = sub_2BB58(v14 + 12, a3[1]);
      if ( v15 )
        goto LABEL_63;
      v13 = v16 + 3;
      v15 = sub_2BB58(v14 + 16, a3[1]);
      if ( v15 )
        goto LABEL_63;
      v13 = v16 + 4;
      v15 = sub_2BB58(v14 + 20, a3[1]);
      if ( v15 )
        goto LABEL_63;
      v13 = v16 + 5;
      v15 = sub_2BB58(v14 + 24, a3[1]);
      v17 = v14 + 28;
      v14 += 32;
      if ( v15 )
        goto LABEL_63;
      v13 = v16 + 6;
      v15 = sub_2BB58(v17, a3[1]);
      if ( v15 )
        goto LABEL_63;
      v13 = v16 + 7;
      if ( v8 == v16 + 7 )
        goto LABEL_41;
    }
  }
  if ( v11 == 1 )
    goto LABEL_30;
  if ( v11 != 2 )
  {
    switch ( v11 )
    {
      case 3:
LABEL_26:
        v15 = sub_2BB58(v14, a3[1]);
        if ( v15 )
          goto LABEL_63;
        ++v13;
        v14 += 4;
        goto LABEL_28;
      case 4:
LABEL_24:
        v15 = sub_2BB58(v14, a3[1]);
        if ( v15 )
          goto LABEL_63;
        ++v13;
        v14 += 4;
        goto LABEL_26;
      case 5:
LABEL_22:
        v15 = sub_2BB58(v14, a3[1]);
        if ( v15 )
          goto LABEL_63;
        ++v13;
        v14 += 4;
        goto LABEL_24;
    }
    if ( v11 != 6 )
    {
      v15 = sub_2BB58(&v82[4 * v5 + 4], a3[1]);
      if ( v15 )
        goto LABEL_63;
      v13 = v5 + 1;
      v14 = v12 + 4;
    }
    v15 = sub_2BB58(v14, a3[1]);
    if ( !v15 )
    {
      ++v13;
      v14 += 4;
      goto LABEL_22;
    }
LABEL_63:
    if ( v13 > v5 )
    {
      v29 = &v82[4 * v13 + 4];
      v30 = (((unsigned int)((char *)v29 - (char *)v12 - 16) >> 4) + 1) & 7;
      if ( !v30 )
        goto LABEL_185;
      if ( v30 != 1 )
      {
        if ( v30 != 2 )
        {
          if ( v30 != 3 )
          {
            if ( v30 != 4 )
            {
              if ( v30 != 5 )
              {
                if ( v30 != 6 )
                {
                  v12 += 4;
                  sub_29D74((int)&v82[4 * v5 + 4]);
                }
                v31 = (int)v12;
                v12 += 4;
                sub_29D74(v31);
              }
              v32 = (int)v12;
              v12 += 4;
              sub_29D74(v32);
            }
            v33 = (int)v12;
            v12 += 4;
            sub_29D74(v33);
          }
          v34 = (int)v12;
          v12 += 4;
          sub_29D74(v34);
        }
        v35 = (int)v12;
        v12 += 4;
        sub_29D74(v35);
      }
      v36 = (int)v12;
      v12 += 4;
      sub_29D74(v36);
      if ( v12 != v29 )
      {
LABEL_185:
        do
        {
          sub_29D74((int)v12);
          sub_29D74((int)(v12 + 4));
          sub_29D74((int)(v12 + 8));
          sub_29D74((int)(v12 + 12));
          sub_29D74((int)(v12 + 16));
          sub_29D74((int)(v12 + 20));
          sub_29D74((int)(v12 + 24));
          v37 = (int)(v12 + 28);
          v12 += 32;
          sub_29D74(v37);
        }
        while ( v12 != v29 );
      }
    }
    sub_29D74((int)v83);
    return v15;
  }
LABEL_28:
  v15 = sub_2BB58(v14, a3[1]);
  if ( v15 )
    goto LABEL_63;
  ++v13;
  v14 += 4;
LABEL_30:
  v15 = sub_2BB58(v14, a3[1]);
  if ( v15 )
    goto LABEL_63;
  ++v13;
  v14 += 4;
  if ( v8 != v13 )
    goto LABEL_32;
LABEL_41:
  if ( a5 )
  {
    if ( a5 == 1 )
    {
      sub_33640((int)a3, &v81);
      v9 = sub_2BB58(v82, a3[1]);
      if ( v9 )
        goto LABEL_46;
      v18 = (int (__fastcall *)(int *, int *, int))sub_33110;
    }
    else
    {
      v9 = sub_2E168(a3, &v81);
      if ( v9 )
        goto LABEL_46;
      v9 = sub_2BB58(v82, a3[1]);
      if ( v9 )
        goto LABEL_46;
      v18 = (int (__fastcall *)(int *, int *, int))sub_2E030;
    }
    sub_2E630((int)v82, 1);
    v9 = sub_2C470(a1, a3, v83);
    if ( v9 )
      goto LABEL_88;
  }
  else
  {
    v9 = sub_2C930((int)a3, &v81);
    if ( v9 )
      goto LABEL_46;
    v38 = a3[1];
    v39 = *a3 < 255;
    if ( *a3 <= 255 )
      v39 = 2 * *a3 + 1 < 512;
    if ( v39 )
    {
      v9 = sub_2BB58(v82, v38);
      if ( v9 )
        goto LABEL_46;
      v18 = sub_310B4;
    }
    else
    {
      v9 = sub_2BB58(v82, v38);
      if ( v9 )
        goto LABEL_46;
      v18 = (int (__fastcall *)(int *, int *, int))sub_2C7D0;
    }
    v9 = sub_2C528(v82, a3);
    if ( v9 )
      goto LABEL_88;
    v9 = sub_2CCE0(a1, v82, a3, v83);
    if ( v9 )
      goto LABEL_88;
  }
  v40 = (int *)((char *)&v82[4] + v73);
  v9 = sub_2A25C(v83, (int *)((char *)&v82[4] + v73));
  if ( v9 )
    goto LABEL_88;
  do
  {
    v42 = sub_2E6C0(v40, v40);
    ++v9;
    if ( v42 )
    {
LABEL_98:
      v9 = v42;
      goto LABEL_88;
    }
    v41 = v18(v40, a3, v81);
    if ( v41 )
    {
      v9 = v41;
      goto LABEL_88;
    }
  }
  while ( v78 > v9 );
  v46 = v5 + 1;
  if ( v8 > v5 + 1 )
  {
    v47 = (v8 - v46) & 3;
    v48 = &v82[v80 + 4];
    if ( !v47 )
      goto LABEL_133;
    if ( v47 != 1 )
    {
      if ( v47 != 2 )
      {
        v48 += 4;
        v9 = sub_2CB6C(&v82[v80 + 4], v83, v48);
        if ( v9 )
          goto LABEL_88;
        v9 = v18(v48, a3, v81);
        if ( v9 )
          goto LABEL_88;
        v46 = v5 + 2;
      }
      v49 = v48;
      v48 += 4;
      v9 = sub_2CB6C(v49, v83, v48);
      if ( v9 )
        goto LABEL_88;
      v9 = v18(v48, a3, v81);
      if ( v9 )
        goto LABEL_88;
      ++v46;
    }
    v50 = v48;
    v48 += 4;
    v9 = sub_2CB6C(v50, v83, v48);
    if ( v9 )
      goto LABEL_88;
    v9 = v18(v48, a3, v81);
    if ( v9 )
      goto LABEL_88;
    if ( v8 > ++v46 )
    {
LABEL_133:
      v51 = v46;
      v71 = v5;
      do
      {
        v52 = v48 + 4;
        v53 = sub_2CB6C(v48, v83, v48 + 4);
        v54 = v48 + 12;
        v55 = v48 + 8;
        v51 += 4;
        v48 += 16;
        if ( !v53 )
        {
          v53 = v18(v52, a3, v81);
          if ( !v53 )
          {
            v53 = sub_2CB6C(v52, v83, v55);
            if ( !v53 )
            {
              v53 = v18(v55, a3, v81);
              if ( !v53 )
              {
                v53 = sub_2CB6C(v55, v83, v54);
                if ( !v53 )
                {
                  v53 = v18(v54, a3, v81);
                  if ( !v53 )
                  {
                    v53 = sub_2CB6C(v54, v83, v48);
                    if ( !v53 )
                    {
                      v53 = v18(v48, a3, v81);
                      if ( !v53 )
                        continue;
                    }
                  }
                }
              }
            }
          }
        }
        v5 = v71;
        v9 = v53;
        goto LABEL_88;
      }
      while ( v8 > v51 );
      v5 = v71;
    }
  }
  v56 = 0;
  v72 = 1;
  v57 = 0;
  v58 = 0;
  v74 = *a2 - 1;
  v59 = v5;
  v60 = a3;
  v61 = 0;
LABEL_145:
  while ( --v72 )
  {
LABEL_148:
    v63 = v57 >> 27;
    v57 *= 2;
    if ( v58 | v63 & 1 )
    {
      if ( v58 == 1 && (v63 & 1) == 0 )
      {
        v42 = sub_2E6C0(v82, v82);
        if ( v42 )
          goto LABEL_159;
        v42 = v18(v82, v60, v81);
        if ( v42 )
          goto LABEL_159;
        v58 = 1;
      }
      else
      {
        v56 |= (v63 & 1) << (v79 - ++v61);
        if ( v79 == v61 )
        {
          v65 = 0;
          while ( 1 )
          {
            v42 = sub_2E6C0(v82, v82);
            ++v65;
            if ( v42 )
              break;
            v42 = v18(v82, v60, v81);
            if ( v42 )
              break;
            if ( v79 <= v65 )
            {
              v42 = sub_2CB6C(v82, &v82[4 * v56 + 4], v82);
              if ( !v42 )
              {
                v42 = v18(v82, v60, v81);
                if ( !v42 )
                {
                  v56 = 0;
                  v58 = 1;
                  v61 = 0;
                  goto LABEL_145;
                }
              }
              break;
            }
          }
LABEL_159:
          v5 = v59;
          goto LABEL_98;
        }
        v58 = 2;
      }
    }
    else
    {
      v58 = 0;
    }
  }
  v62 = v74;
  if ( v74 != -1 )
  {
    v72 = 28;
    --v74;
    v57 = *(_DWORD *)(a2[3] + 4 * v62);
    goto LABEL_148;
  }
  v66 = v58 == 2;
  if ( v61 <= 0 )
    v66 = 0;
  v75 = v61;
  v67 = v60;
  v5 = v59;
  v68 = v56;
  if ( v66 )
  {
    v69 = 0;
    while ( 1 )
    {
      v9 = sub_2E6C0(v82, v82);
      v68 *= 2;
      ++v69;
      if ( v9 )
        break;
      v9 = v18(v82, v67, v81);
      if ( v9 )
        break;
      if ( (v8 & v68) != 0 )
      {
        v9 = sub_2CB6C(v82, v83, v82);
        if ( v9 )
          break;
        v9 = v18(v82, v67, v81);
        if ( v9 )
          break;
      }
      if ( v75 <= v69 )
        goto LABEL_180;
    }
  }
  else
  {
LABEL_180:
    if ( a5 || (v9 = v18(v82, v67, v81)) == 0 )
    {
      sub_2AAD4(v82, a4);
      v9 = 0;
    }
  }
LABEL_88:
  sub_29D74((int)v82);
LABEL_46:
  sub_29D74((int)v83);
  if ( v8 > v5 )
  {
    v19 = &v82[4 * v8 + 4];
    v20 = &v82[v80 + 4];
    v21 = (((unsigned int)((char *)v19 - (char *)&v82[v80 + 4] - 16) >> 4) + 1) & 7;
    if ( !v21 )
      goto LABEL_186;
    if ( v21 != 1 )
    {
      if ( v21 != 2 )
      {
        if ( v21 != 3 )
        {
          if ( v21 != 4 )
          {
            if ( v21 != 5 )
            {
              if ( v21 != 6 )
              {
                v20 += 4;
                sub_29D74((int)&v82[v80 + 4]);
              }
              v22 = (int)v20;
              v20 += 4;
              sub_29D74(v22);
            }
            v23 = (int)v20;
            v20 += 4;
            sub_29D74(v23);
          }
          v24 = (int)v20;
          v20 += 4;
          sub_29D74(v24);
        }
        v25 = (int)v20;
        v20 += 4;
        sub_29D74(v25);
      }
      v26 = (int)v20;
      v20 += 4;
      sub_29D74(v26);
    }
    v27 = (int)v20;
    v20 += 4;
    sub_29D74(v27);
    if ( v19 != v20 )
    {
LABEL_186:
      do
      {
        sub_29D74((int)v20);
        sub_29D74((int)(v20 + 4));
        sub_29D74((int)(v20 + 8));
        sub_29D74((int)(v20 + 12));
        sub_29D74((int)(v20 + 16));
        sub_29D74((int)(v20 + 20));
        sub_29D74((int)(v20 + 24));
        v28 = (int)(v20 + 28);
        v20 += 32;
        sub_29D74(v28);
      }
      while ( v19 != v20 );
    }
  }
  return v9;
}
// 2AD50: variable 'v5' is possibly undefined
// 2C7D0: using guessed type int sub_2C7D0();

//----- (0002B818) --------------------------------------------------------
int __fastcall sub_2B818(int *a1, int *a2, int *a3)
{
  int result; // r0
  int v6; // r4
  int v7; // r5
  int v8; // r0
  int v9; // r7
  int v10; // r8
  int v11; // r0
  int v12; // r0
  int v13[4]; // [sp+0h] [bp-20h] BYREF
  int v14[4]; // [sp+10h] [bp-10h] BYREF

  if ( !*a1 )
    return sub_329A8(a2, a3);
  if ( !*a2 )
    return sub_329A8(a1, a3);
  result = sub_2BB10(v13, a1);
  if ( !result )
  {
    v6 = sub_2BB10(v14, a2);
    if ( !v6 )
    {
      v14[2] = 0;
      v13[2] = 0;
      v7 = sub_2A0A4(v13);
      v8 = sub_2A0A4(v14);
      v9 = v8;
      if ( v7 >= v8 )
        v10 = v8;
      else
        v10 = v7;
      if ( (v10 <= 0 || (v6 = sub_329D0(v13, v10, v13, 0)) == 0 && (v6 = sub_329D0(v14, v10, v14, 0)) == 0)
        && (v7 <= v9 || (v6 = sub_329D0(v13, v7 - v10, v13, 0)) == 0) )
      {
        if ( v7 >= v9 || (v12 = sub_329D0(v14, v9 - v10, v14, 0), (v6 = v12) == 0) )
        {
          while ( v14[0] )
          {
            if ( sub_29E8C(v13, v14) == 1 )
              sub_2AAD4(v13, v14);
            v6 = sub_307E4(v14, v13, v14);
            if ( !v6 )
            {
              v11 = sub_2A0A4(v14);
              v6 = sub_329D0(v14, v11, v14, 0);
              if ( !v6 )
                continue;
            }
            goto LABEL_23;
          }
          v6 = sub_2CA58(v13, v10, a3);
          if ( !v6 )
            a3[2] = 0;
        }
      }
LABEL_23:
      sub_29D74((int)v13);
    }
    sub_29D74((int)v14);
    return v6;
  }
  return result;
}

//----- (0002BA48) --------------------------------------------------------
int __fastcall sub_2BA48(int a1, int a2)
{
  int v4; // r5
  int v5; // r5
  char *v6; // r0
  int v7; // r3
  char *v8; // lr

  if ( *(_DWORD *)(a1 + 4) >= a2 )
    return 0;
  v4 = a2 & 0x1F;
  if ( a2 <= 0 )
    v4 = -(-a2 & 0x1F);
  v5 = 64 - v4 + a2;
  v6 = (char *)realloc(*(void **)(a1 + 12), 4 * v5);
  if ( !v6 )
    return -2;
  v7 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 12) = v6;
  *(_DWORD *)(a1 + 4) = v5;
  if ( v5 > v7 )
  {
    v8 = &v6[4 * v7];
    do
    {
      *(_DWORD *)v8 = 0;
      v8 += 4;
      ++v7;
    }
    while ( *(_DWORD *)(a1 + 4) > v7 );
  }
  return 0;
}

//----- (0002BAD0) --------------------------------------------------------
int __fastcall sub_2BAD0(int a1)
{
  void *v2; // r0

  v2 = calloc(0x80u, 1u);
  *(_DWORD *)(a1 + 12) = v2;
  if ( !v2 )
    return -2;
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 4) = 32;
  return 0;
}

//----- (0002BB10) --------------------------------------------------------
int __fastcall sub_2BB10(int *a1, int *a2)
{
  int v4; // r4

  v4 = sub_2BB58(a1, *a2);
  if ( v4 )
    return v4;
  v4 = sub_2A25C(a2, a1);
  if ( !v4 )
    return v4;
  sub_29D74((int)a1);
  return v4;
}

//----- (0002BB58) --------------------------------------------------------
int __fastcall sub_2BB58(_DWORD *a1, int a2)
{
  int v3; // r4
  int v4; // r4
  void *v5; // r0

  v3 = a2 & 0x1F;
  if ( a2 <= 0 )
    v3 = -(-a2 & 0x1F);
  v4 = 64 - v3 + a2;
  v5 = calloc(4 * v4, 1u);
  a1[3] = v5;
  if ( !v5 )
    return -2;
  *a1 = 0;
  a1[1] = v4;
  a1[2] = 0;
  return 0;
}

//----- (0002BBA8) --------------------------------------------------------
int __fastcall sub_2BBA8(int *a1, int a2, int *a3)
{
  int v6; // r0
  int *v7; // [sp+4h] [bp-14h]

  if ( *(_DWORD *)(a2 + 8) == 1 || !*(_DWORD *)a2 )
    return -3;
  if ( *(int *)a2 > 0 && (**(_DWORD **)(a2 + 12) & 1) != 0 )
  {
    v7 = a3;
    v6 = sub_29E48(a2, 1u);
    a3 = v7;
    if ( v6 )
      return sub_30DC0(a1, a2, v7);
  }
  return sub_2BC30(a1, (int *)a2, a3);
}

//----- (0002BC30) --------------------------------------------------------
int __fastcall sub_2BC30(int *a1, int *a2, int *a3)
{
  int v6; // r6
  int v8; // r6
  int v9; // r1
  char v10; // [sp+14h] [bp-88h]
  int v11[3]; // [sp+18h] [bp-84h] BYREF
  _DWORD *v12; // [sp+24h] [bp-78h]
  int v13[3]; // [sp+28h] [bp-74h] BYREF
  _DWORD *v14; // [sp+34h] [bp-68h]
  int v15[4]; // [sp+38h] [bp-64h] BYREF
  int v16[4]; // [sp+48h] [bp-54h] BYREF
  int v17[4]; // [sp+58h] [bp-44h] BYREF
  int v18[4]; // [sp+68h] [bp-34h] BYREF
  int v19[4]; // [sp+78h] [bp-24h] BYREF
  int v20[5]; // [sp+88h] [bp-14h] BYREF

  if ( a2[2] == 1 || !*a2 )
    return -3;
  v6 = sub_33654(
         (int)v11,
         (int)v13,
         (int)v15,
         (int)v16,
         (int)v17,
         (int)v18,
         (int)v19,
         (int)v20,
         0,
         v10,
         v11[0],
         v11[1],
         v11[2],
         (char)v12,
         v13[0],
         v13[1],
         v13[2],
         (char)v14);
  if ( v6 )
    return v6;
  v8 = sub_2C470(a1, a2, v11);
  if ( !v8 )
  {
    v8 = sub_2A25C(a2, v13);
    if ( !v8 )
    {
      if ( v11[0] <= 0 || (*v12 & 1) != 0 || v13[0] <= 0 || (*v14 & 1) != 0 )
      {
        v8 = sub_2A25C(v11, v15);
        if ( !v8 )
        {
          v8 = sub_2A25C(v13, v16);
          if ( !v8 )
          {
            sub_2E630((int)v17, 1);
            sub_2E630((int)v20, 1);
            v9 = v15[0];
            do
            {
              if ( v9 > 0 )
              {
                do
                {
                  if ( (*(_DWORD *)v15[3] & 1) != 0 )
                    break;
                  v8 = sub_2A350(v15, v15);
                  if ( v8 )
                    goto LABEL_6;
                  if ( v17[0] > 0 && (*(_DWORD *)v17[3] & 1) != 0 || v18[0] > 0 && (*(_DWORD *)v18[3] & 1) != 0 )
                  {
                    v8 = sub_29934(v17, v13, v17);
                    if ( v8 )
                      goto LABEL_6;
                    v8 = sub_2E764(v18, v11, v18);
                    if ( v8 )
                      goto LABEL_6;
                  }
                  v8 = sub_2A350(v17, v17);
                  if ( v8 )
                    goto LABEL_6;
                  v8 = sub_2A350(v18, v18);
                  if ( v8 )
                    goto LABEL_6;
                }
                while ( v15[0] > 0 );
              }
              while ( v16[0] > 0 && (*(_DWORD *)v16[3] & 1) == 0 )
              {
                v8 = sub_2A350(v16, v16);
                if ( !v8
                  && ((v19[0] <= 0 || (*(_DWORD *)v19[3] & 1) == 0) && (v20[0] <= 0 || (*(_DWORD *)v20[3] & 1) == 0)
                   || (v8 = sub_29934(v19, v13, v19)) == 0 && (v8 = sub_2E764(v20, v11, v20)) == 0) )
                {
                  v8 = sub_2A350(v19, v19);
                  if ( !v8 )
                  {
                    v8 = sub_2A350(v20, v20);
                    if ( !v8 )
                      continue;
                  }
                }
                goto LABEL_6;
              }
              if ( sub_29E00(v15, v16) == -1 )
              {
                v8 = sub_2E764(v16, v15, v16);
                if ( v8 )
                  goto LABEL_6;
                v8 = sub_2E764(v19, v17, v19);
                if ( v8 )
                  goto LABEL_6;
                v8 = sub_2E764(v20, v18, v20);
                if ( v8 )
                  goto LABEL_6;
              }
              else
              {
                v8 = sub_2E764(v15, v16, v15);
                if ( v8 )
                  goto LABEL_6;
                v8 = sub_2E764(v17, v19, v17);
                if ( v8 )
                  goto LABEL_6;
                v8 = sub_2E764(v18, v20, v18);
                if ( v8 )
                  goto LABEL_6;
              }
              v9 = v15[0];
            }
            while ( v15[0] );
            if ( sub_29E48((int)v16, 1u) )
              goto LABEL_12;
            while ( sub_29E48((int)v19, 0) == -1 )
            {
              v8 = sub_29934(v19, a2, v19);
              if ( v8 )
                goto LABEL_6;
            }
            while ( sub_29E8C(v19, a2) != -1 )
            {
              v8 = sub_2E764(v19, a2, v19);
              if ( v8 )
                goto LABEL_6;
            }
            v8 = 0;
            sub_2AAD4(v19, a3);
          }
        }
      }
      else
      {
LABEL_12:
        v8 = -3;
      }
    }
  }
LABEL_6:
  sub_29DB8((int)v11, v13, v15, v16, v17, v18, v19, v20, 0);
  return v8;
}
// 2BC94: variable 'v10' is possibly undefined

//----- (0002C074) --------------------------------------------------------
int __fastcall sub_2C074(int *a1, int *a2, int *a3, int a4)
{
  int result; // r0
  int v8; // r4
  int v9[4]; // [sp+0h] [bp-24h] BYREF
  int v10; // [sp+10h] [bp-14h] BYREF
  char v11; // [sp+14h] [bp-10h]
  int v12; // [sp+18h] [bp-Ch]
  int v13; // [sp+1Ch] [bp-8h]
  int v14; // [sp+20h] [bp-4h]
  int savedregs[5]; // [sp+24h] [bp+0h]

  result = sub_33654(
             (int)v9,
             (int)&v10,
             0,
             a4,
             v9[0],
             v9[1],
             v9[2],
             v9[3],
             v10,
             v11,
             v12,
             v13,
             v14,
             savedregs[0],
             savedregs[1],
             savedregs[2],
             savedregs[3],
             savedregs[4]);
  if ( !result )
  {
    v8 = sub_2B818(a1, a2, v9);
    if ( v8 )
    {
LABEL_3:
      sub_29DB8((int)v9, &v10, 0);
      return v8;
    }
    if ( sub_29E8C(a1, a2) == -1 )
    {
      v8 = sub_2A5A8(a1, v9, &v10, 0);
      if ( v8 )
        goto LABEL_3;
      v8 = sub_2CB6C(a2, &v10, a3);
    }
    else
    {
      v8 = sub_2A5A8(a2, v9, &v10, 0);
      if ( v8 )
        goto LABEL_3;
      v8 = sub_2CB6C(a1, &v10, a3);
    }
    a3[2] = 0;
    goto LABEL_3;
  }
  return result;
}

//----- (0002C160) --------------------------------------------------------
int __fastcall sub_2C160(int *a1, int a2)
{
  int v4; // r1
  char *v5; // r0
  int v6; // r2
  char *v7; // r3
  char *v8; // r12
  int v9; // r6
  bool v10; // cc
  unsigned int v11; // r7
  char *v12; // lr
  char *v13; // r4
  int v14; // r12
  int v15; // r7
  int v16; // r1
  int v17; // lr
  int *v18; // r3
  int v19; // t1
  int v20; // r2
  bool v21; // zf
  int v22; // t1
  int v23; // t1
  int v24; // t1
  int v25; // t1
  int v26; // t1
  int v27; // t1
  int v28; // t1
  int *v29; // r2
  int result; // r0

  if ( a2 <= 0 )
    return 0;
  v4 = a2 + *a1;
  if ( a1[1] >= v4 )
  {
LABEL_3:
    v5 = (char *)a1[3];
    v6 = v4 - 1;
    *a1 = v4;
    v7 = &v5[4 * (v4 - a2) - 4];
    v8 = &v5[4 * v4 - 4];
    if ( a2 <= v4 - 1 )
    {
      v9 = a2 + 6;
      v10 = a2 - 1 < 2147483640;
      if ( a2 - 1 <= 2147483640 )
        v10 = v9 < v4 - 2;
      if ( v10 )
      {
        __pld(v7 - 116);
        v7 -= 32;
        v8 -= 32;
        v11 = ((unsigned int)(v6 - v9 - 2) >> 3) & 1;
        v12 = v7 - 32;
        v6 = v4 - 9;
        *((_DWORD *)v8 + 8) = *((_DWORD *)v7 + 8);
        v13 = v8 - 32;
        *((_DWORD *)v8 + 7) = *((_DWORD *)v7 + 7);
        *((_DWORD *)v8 + 6) = *((_DWORD *)v7 + 6);
        *((_DWORD *)v8 + 5) = *((_DWORD *)v7 + 5);
        *((_DWORD *)v8 + 4) = *((_DWORD *)v7 + 4);
        *((_DWORD *)v8 + 3) = *((_DWORD *)v7 + 3);
        *((_DWORD *)v8 + 2) = *((_DWORD *)v7 + 2);
        *((_DWORD *)v8 + 1) = *((_DWORD *)v7 + 1);
        if ( v9 < v4 - 10 )
        {
          if ( !v11 )
            goto LABEL_37;
          v14 = *(_DWORD *)v7;
          __pld(v7 - 116);
          v6 = v4 - 17;
          v7 -= 32;
          *((_DWORD *)v13 + 8) = v14;
          v12 -= 32;
          v8 = v13;
          v13 -= 32;
          *((_DWORD *)v13 + 15) = *((_DWORD *)v12 + 15);
          *((_DWORD *)v13 + 14) = *((_DWORD *)v12 + 14);
          *((_DWORD *)v13 + 13) = *((_DWORD *)v12 + 13);
          *((_DWORD *)v13 + 12) = *((_DWORD *)v12 + 12);
          *((_DWORD *)v13 + 11) = *((_DWORD *)v12 + 11);
          *((_DWORD *)v13 + 10) = *((_DWORD *)v12 + 10);
          *((_DWORD *)v13 + 9) = *((_DWORD *)v12 + 9);
          if ( v9 < v4 - 18 )
          {
LABEL_37:
            do
            {
              v15 = *((_DWORD *)v12 + 8);
              v7 = v12 - 32;
              __pld(v12 - 84);
              v8 = v13 - 32;
              __pld(v12 - 116);
              *((_DWORD *)v13 + 8) = v15;
              v10 = v9 < v6 - 17;
              v6 -= 16;
              *((_DWORD *)v13 + 7) = *((_DWORD *)v12 + 7);
              *((_DWORD *)v13 + 6) = *((_DWORD *)v12 + 6);
              *((_DWORD *)v13 + 5) = *((_DWORD *)v12 + 5);
              *((_DWORD *)v13 + 4) = *((_DWORD *)v12 + 4);
              *((_DWORD *)v13 + 3) = *((_DWORD *)v12 + 3);
              *((_DWORD *)v13 + 2) = *((_DWORD *)v12 + 2);
              v16 = *((_DWORD *)v12 + 1);
              v12 -= 64;
              *((_DWORD *)v13 + 1) = v16;
              v13 -= 64;
              *((_DWORD *)v8 + 8) = *((_DWORD *)v7 + 8);
              *((_DWORD *)v8 + 7) = *((_DWORD *)v7 + 7);
              *((_DWORD *)v8 + 6) = *((_DWORD *)v7 + 6);
              *((_DWORD *)v8 + 5) = *((_DWORD *)v7 + 5);
              *((_DWORD *)v8 + 4) = *((_DWORD *)v7 + 4);
              *((_DWORD *)v8 + 3) = *((_DWORD *)v7 + 3);
              *((_DWORD *)v8 + 2) = *((_DWORD *)v7 + 2);
              *((_DWORD *)v8 + 1) = *((_DWORD *)v7 + 1);
            }
            while ( v10 );
          }
        }
      }
      v17 = v6 - 1;
      v19 = *(_DWORD *)v7;
      v18 = (int *)(v7 - 4);
      v10 = a2 <= v6 - 1;
      v20 = ((_BYTE)v6 - (_BYTE)a2) & 7;
      *(_DWORD *)v8 = v19;
      if ( v10 )
      {
        if ( !v20 )
          goto LABEL_38;
        if ( v20 != 1 )
        {
          if ( v20 != 2 )
          {
            if ( v20 != 3 )
            {
              if ( v20 != 4 )
              {
                if ( v20 != 5 )
                {
                  v21 = v20 == 6;
                  if ( v20 != 6 )
                  {
                    v22 = *v18--;
                    v20 = v22;
                    --v17;
                  }
                  --v17;
                  if ( !v21 )
                  {
                    *((_DWORD *)v8 - 1) = v20;
                    v8 -= 4;
                  }
                  v23 = *v18--;
                  *((_DWORD *)v8 - 1) = v23;
                  v8 -= 4;
                }
                v24 = *v18--;
                --v17;
                *((_DWORD *)v8 - 1) = v24;
                v8 -= 4;
              }
              v25 = *v18--;
              --v17;
              *((_DWORD *)v8 - 1) = v25;
              v8 -= 4;
            }
            v26 = *v18--;
            --v17;
            *((_DWORD *)v8 - 1) = v26;
            v8 -= 4;
          }
          v27 = *v18--;
          --v17;
          *((_DWORD *)v8 - 1) = v27;
          v8 -= 4;
        }
        --v17;
        v28 = *v18--;
        *((_DWORD *)v8 - 1) = v28;
        v8 -= 4;
        if ( a2 <= v17 )
        {
LABEL_38:
          do
          {
            v29 = v18;
            v18 -= 8;
            v17 -= 8;
            *((_DWORD *)v8 - 1) = *v29;
            *((_DWORD *)v8 - 2) = *(v29 - 1);
            *((_DWORD *)v8 - 3) = v18[6];
            *((_DWORD *)v8 - 4) = v18[5];
            *((_DWORD *)v8 - 5) = v18[4];
            *((_DWORD *)v8 - 6) = v18[3];
            *((_DWORD *)v8 - 7) = v18[2];
            *((_DWORD *)v8 - 8) = v18[1];
            v8 -= 32;
          }
          while ( a2 <= v17 );
        }
      }
    }
    memset(v5, 0, 4 * a2);
    return 0;
  }
  result = sub_2BA48((int)a1, v4);
  if ( !result )
  {
    v4 = a2 + *a1;
    goto LABEL_3;
  }
  return result;
}

//----- (0002C470) --------------------------------------------------------
int __fastcall sub_2C470(int *a1, int *a2, int *a3)
{
  int result; // r0
  int v7; // r4
  int v8[5]; // [sp+0h] [bp-14h] BYREF

  result = sub_2BB58(v8, *a2);
  if ( !result )
  {
    v7 = sub_2A5A8(a1, a2, 0, v8);
    if ( !v7 )
    {
      if ( !v8[0] || v8[2] == a2[2] )
      {
        sub_2AAD4(v8, a3);
        sub_29D74((int)v8);
        return v7;
      }
      v7 = sub_29934(a2, v8, a3);
    }
    sub_29D74((int)v8);
    return v7;
  }
  return result;
}

//----- (0002C51C) --------------------------------------------------------
int __fastcall sub_2C51C(int a1, unsigned int a2, int *a3)
{
  return sub_32D70(a1, a2, 0, a3);
}

//----- (0002C528) --------------------------------------------------------
int __fastcall sub_2C528(int *a1, int *a2)
{
  int v4; // r0
  int v5; // r5
  int v6; // r7
  int v7; // r5
  int v8; // r7
  int result; // r0
  int v10; // r5

  v4 = sub_2A310(a2);
  if ( *a2 <= 1 )
  {
    v7 = 0;
    sub_2E630((int)a1, 1);
  }
  else
  {
    v5 = v4 % 28;
    v6 = sub_298D4(a1, v4 % 28 + 28 * (*a2 - 1) - 1);
    if ( v6 )
      return v6;
    v7 = v5 - 1;
  }
  v8 = (28 - v7) & 3;
  if ( !v8 )
    goto LABEL_19;
  if ( v8 != 1 )
  {
    if ( v8 != 2 )
    {
      v6 = sub_2C98C(a1, a1);
      if ( v6 )
        return v6;
      if ( sub_29E8C(a1, a2) != -1 )
      {
        result = sub_307E4(a1, a2, a1);
        if ( result )
          return result;
      }
      ++v7;
    }
    v6 = sub_2C98C(a1, a1);
    if ( !v6 )
    {
      if ( sub_29E8C(a1, a2) == -1 )
      {
        ++v7;
      }
      else
      {
        result = sub_307E4(a1, a2, a1);
        if ( result )
          return result;
        ++v7;
      }
      goto LABEL_15;
    }
    return v6;
  }
LABEL_15:
  v6 = sub_2C98C(a1, a1);
  if ( v6 )
    return v6;
  if ( sub_29E8C(a1, a2) == -1 || (result = sub_307E4(a1, a2, a1)) == 0 )
  {
    if ( ++v7 != 28 )
    {
LABEL_19:
      while ( 1 )
      {
        v6 = sub_2C98C(a1, a1);
        if ( v6 )
          break;
        if ( sub_29E8C(a1, a2) != -1 )
        {
          result = sub_307E4(a1, a2, a1);
          if ( result )
            return result;
        }
        v6 = sub_2C98C(a1, a1);
        v10 = v7 + 1;
        if ( v6 )
          return v6;
        if ( sub_29E8C(a1, a2) != -1 )
        {
          result = sub_307E4(a1, a2, a1);
          if ( result )
            return result;
        }
        v6 = sub_2C98C(a1, a1);
        if ( v6 )
          return v6;
        if ( sub_29E8C(a1, a2) != -1 )
        {
          result = sub_307E4(a1, a2, a1);
          if ( result )
            return result;
        }
        v6 = sub_2C98C(a1, a1);
        if ( v6 )
          return v6;
        if ( sub_29E8C(a1, a2) == -1 )
        {
          v7 = v10 + 3;
          if ( v7 == 28 )
            return v6;
        }
        else
        {
          result = sub_307E4(a1, a2, a1);
          if ( result )
            return result;
          v7 = v10 + 3;
          if ( v7 == 28 )
            return v6;
        }
      }
    }
    return v6;
  }
  return result;
}

//----- (0002C7D0) --------------------------------------------------------
int __fastcall sub_2C7D0(int *a1, int *a2, int a3)
{
  int v3; // r5
  bool v4; // cc
  int v7; // r10
  int v8; // lr
  int *v9; // r0
  int v10; // r9
  int *v11; // r3
  unsigned int *v12; // r2
  unsigned int v13; // r4
  int v14; // r12
  unsigned int v15; // t1
  unsigned __int64 v16; // r4
  int v17; // r10
  __int64 v18; // r4
  unsigned int v19; // r2
  int result; // r0
  unsigned int *v22; // [sp+4h] [bp-8h]

  v3 = 2 * *a2 + 1;
  v4 = *a2 < 255;
  if ( *a2 <= 255 )
    v4 = v3 < 512;
  if ( v4 )
    return sub_310B4(a1, a2, a3);
  if ( a1[1] >= v3 || (result = sub_2BA48((int)a1, v3)) == 0 )
  {
    *a1 = v3;
    v7 = *a2;
    if ( *a2 > 0 )
    {
      v8 = 0;
      v22 = (unsigned int *)a2[3];
      v9 = (int *)a1[3];
      do
      {
        v10 = *v9;
        v11 = v9++;
        if ( v7 <= 0 )
          break;
        v12 = v22;
        v13 = 0;
        v14 = 0;
        do
        {
          v15 = *v12++;
          ++v14;
          v16 = ((v10 * a3) & 0xFFFFFFF) * (unsigned __int64)v15 + v13;
          v17 = (v16 + *v11) & 0xFFFFFFF;
          v18 = v16 + (unsigned int)*v11;
          *v11++ = v17;
          v7 = *a2;
          v13 = v18 >> 28;
        }
        while ( *a2 > v14 );
        if ( v13 )
        {
          do
          {
            v19 = v13 + *v11;
            v13 = v19 >> 28;
            *v11++ = v19 & 0xFFFFFFF;
          }
          while ( v19 >> 28 );
          v7 = *a2;
        }
        ++v8;
      }
      while ( v8 < v7 );
    }
    sub_29BBC(a1);
    sub_2E5A0(a1, *a2);
    if ( sub_29E8C(a1, a2) == -1 )
      return 0;
    else
      return sub_307E4(a1, a2, a1);
  }
  return result;
}

//----- (0002C930) --------------------------------------------------------
int __fastcall sub_2C930(int a1, int *a2)
{
  int v2; // r3
  int v4; // r2
  int v5; // r2

  v2 = **(_DWORD **)(a1 + 12);
  if ( (v2 & 1) == 0 )
    return -3;
  v4 = ((2 * ((_BYTE)v2 + 2)) & 8) + v2;
  v5 = v4 * (2 - v4 * v2) * (2 - v4 * (2 - v4 * v2) * v2);
  *a2 = ((v5 * v2 - 2) * v5) & 0xFFFFFFF;
  return 0;
}

//----- (0002C98C) --------------------------------------------------------
int __fastcall sub_2C98C(int *a1, int *a2)
{
  int v2; // r3
  int v3; // r2
  int v5; // r1
  int v7; // r2
  unsigned int *v8; // r5
  int v9; // r0
  unsigned int v10; // lr
  int *v11; // r4
  int v12; // r1
  unsigned int v13; // t1
  int v14; // r3
  int result; // r0

  v2 = *a1;
  v3 = a2[1];
  v5 = *a1 + 1;
  if ( v3 < v5 )
  {
    result = sub_2BA48((int)a2, v5);
    if ( result )
      return result;
    v2 = *a1;
  }
  v7 = *a2;
  *a2 = v2;
  v8 = (unsigned int *)a1[3];
  v9 = a2[3];
  if ( *a1 > 0 )
  {
    v10 = 0;
    v11 = (int *)a2[3];
    v12 = 0;
    do
    {
      v13 = *v8++;
      ++v12;
      v14 = v10 | (2 * v13);
      v10 = v13 >> 27;
      *v11++ = v14 & 0xFFFFFFF;
    }
    while ( *a1 > v12 );
    v2 = v10 ? 1 : *a2;
    if ( v10 )
    {
      *v11 = v2;
      v2 = *a2 + 1;
      *a2 = v2;
    }
  }
  if ( v7 > v2 )
    memset((void *)(v9 + 4 * v2), 0, 4 * (v7 - v2));
  a2[2] = a1[2];
  return 0;
}

//----- (0002CA58) --------------------------------------------------------
int __fastcall sub_2CA58(int *a1, int a2, int *a3)
{
  int result; // r0
  int v6; // r1
  int v7; // r4
  int v8; // r7
  int v9; // r2
  int v10; // r12
  int *v11; // r1
  int v12; // r3
  int v13; // r3

  if ( a3 == a1 || (result = sub_2A25C(a1, a3)) == 0 )
  {
    v6 = a2 / 28 + *a3 + 1;
    if ( (a3[1] >= v6 || (result = sub_2BA48((int)a3, v6)) == 0) && (a2 <= 27 || (result = sub_2C160(a3, a2 / 28)) == 0) )
    {
      v7 = a2 % 28;
      if ( v7 )
      {
        v8 = a3[3];
        if ( *a3 > 0 )
        {
          v9 = 0;
          v10 = 0;
          v11 = (int *)a3[3];
          do
          {
            ++v9;
            v12 = v10 | (*v11 << v7);
            v10 = ~(-1 << v7) & ((unsigned int)*v11 >> (28 - v7));
            *v11++ = v12 & 0xFFFFFFF;
            v13 = *a3;
          }
          while ( *a3 > v9 );
          if ( v10 )
          {
            *a3 = v13 + 1;
            *(_DWORD *)(v8 + 4 * v13) = v10;
          }
        }
      }
      sub_29BBC(a3);
      return 0;
    }
  }
  return result;
}

//----- (0002CB6C) --------------------------------------------------------
int __fastcall sub_2CB6C(int *a1, int *a2, int *a3)
{
  int v3; // r12
  int v5; // r5
  int v6; // r6
  int v7; // r3
  int result; // r0
  _BOOL4 v9; // r5

  v3 = *a1;
  v5 = a1[2];
  v6 = a2[2];
  v7 = *a1 + *a2 + 1;
  if ( v7 >= 512 )
    goto LABEL_5;
  if ( v3 >= *a2 )
    v3 = *a2;
  if ( v3 <= 256 )
    result = sub_31AE4(a1, a2, a3, v7);
  else
LABEL_5:
    result = sub_2FCC8(a1, a2, a3, v7);
  v9 = *a3 > 0 && v5 != v6;
  a3[2] = v9;
  return result;
}

//----- (0002CBE4) --------------------------------------------------------
int __fastcall sub_2CBE4(int *a1, unsigned int a2, int *a3)
{
  int v3; // r3
  int v6; // r1
  unsigned int *v8; // r1
  int v9; // r12
  unsigned int *v10; // r0
  int v11; // r3
  unsigned int v12; // r4
  unsigned int v13; // t1
  signed __int64 v14; // r10
  int v15; // r1
  int v16; // lr
  void *v17; // r0
  size_t v18; // r2
  int result; // r0

  v3 = *a1;
  v6 = *a1 + 1;
  if ( a3[1] < v6 )
  {
    result = sub_2BA48((int)a3, v6);
    if ( result )
      return result;
    v3 = *a1;
  }
  v8 = (unsigned int *)a1[3];
  v9 = *a3;
  a3[2] = a1[2];
  v10 = (unsigned int *)a3[3];
  if ( v3 <= 0 )
  {
    v16 = 2;
    v15 = 1;
    v12 = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    while ( 1 )
    {
      v13 = *v8++;
      v14 = a2 * (unsigned __int64)v13 + v12;
      *v10++ = v14 & 0xFFFFFFF;
      v12 = v14 >> 28;
      if ( *a1 <= v11 + 1 )
        break;
      ++v11;
    }
    v15 = v11 + 2;
    v16 = v11 + 3;
  }
  *v10 = v12;
  if ( v9 > v15 )
  {
    v17 = v10 + 1;
    if ( v9 < v16 )
      v18 = 4;
    else
      v18 = 4 * (v9 + 1 - v16);
    memset(v17, 0, v18);
  }
  *a3 = *a1 + 1;
  sub_29BBC(a3);
  return 0;
}

//----- (0002CCE0) --------------------------------------------------------
int __fastcall sub_2CCE0(int *a1, int *a2, int *a3, int *a4)
{
  int result; // r0
  int v9; // r4
  int v10[4]; // [sp+0h] [bp-10h] BYREF

  result = sub_2BB58(v10, *a3);
  if ( !result )
  {
    v9 = sub_2CB6C(a1, a2, v10);
    if ( !v9 )
      v9 = sub_2C470(v10, a3, a4);
    sub_29D74((int)v10);
    return v9;
  }
  return result;
}

//----- (0002CD58) --------------------------------------------------------
int __fastcall sub_2CD58(int *a1, int *a2)
{
  int result; // r0

  if ( a1 == a2 || (result = sub_2A25C(a1, a2)) == 0 )
  {
    result = *a2;
    if ( *a2 )
    {
      a2[2] = a1[2] == 0;
      return 0;
    }
    else
    {
      a2[2] = 0;
    }
  }
  return result;
}

//----- (0002CDA4) --------------------------------------------------------
int __fastcall sub_2CDA4(int *a1, int a2, _DWORD *a3)
{
  int *v3; // r8
  unsigned int *v7; // r5
  int v8; // r6
  unsigned int v9; // r1
  int v10; // r1
  int v11; // r2
  int v12; // t1
  int v13; // t1
  int *v14; // r11
  int *v15; // r7
  int v17; // [sp+4h] [bp-18h] BYREF
  int v18[5]; // [sp+8h] [bp-14h] BYREF

  *a3 = 0;
  if ( (unsigned int)(a2 - 1) > 0xFF )
    return -3;
  v3 = (int *)&off_3ACB0;
  v7 = (unsigned int *)&off_3ACB0;
  do
  {
    v8 = sub_29E48((int)a1, *v7);
    if ( v8 )
    {
      v8 = sub_29E48((int)a1, v7[1]);
      if ( v8 )
      {
        v8 = sub_29E48((int)a1, v7[2]);
        if ( v8 )
        {
          v8 = sub_29E48((int)a1, v7[3]);
          if ( v8 )
          {
            v8 = sub_29E48((int)a1, v7[4]);
            if ( v8 )
            {
              v8 = sub_29E48((int)a1, v7[5]);
              if ( v8 )
              {
                v8 = sub_29E48((int)a1, v7[6]);
                if ( v8 )
                {
                  v9 = v7[7];
                  v7 += 8;
                  v8 = sub_29E48((int)a1, v9);
                  if ( v8 )
                    continue;
                }
              }
            }
          }
        }
      }
    }
    *a3 = 1;
    return v8;
  }
  while ( "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/" != (char *)v7 );
  v8 = sub_33A60((int)a1, &v17);
  if ( !v8 && v17 != 1 )
  {
    v8 = sub_2BAD0((int)v18);
    if ( !v8 )
    {
      v10 = a2 & 3;
      if ( (a2 & 3) == 0 )
        goto LABEL_27;
      if ( v10 == 1 )
      {
LABEL_24:
        v13 = *v3++;
        sub_2E630((int)v18, v13);
        v11 = sub_2D094(a1, v18, &v17);
        if ( !v11 )
        {
          if ( !v17 )
            goto LABEL_41;
          if ( a2 == ++v8 )
          {
LABEL_36:
            v8 = 0;
            *a3 = 1;
            goto LABEL_37;
          }
LABEL_27:
          while ( 1 )
          {
            v14 = v3 + 1;
            v15 = v3 + 3;
            sub_2E630((int)v18, *v3);
            v8 += 4;
            v11 = sub_2D094(a1, v18, &v17);
            v3 += 4;
            if ( v11 )
              break;
            if ( !v17 )
              goto LABEL_41;
            sub_2E630((int)v18, *v14);
            v11 = sub_2D094(a1, v18, &v17);
            if ( v11 )
              break;
            if ( !v17 )
              goto LABEL_41;
            sub_2E630((int)v18, v14[1]);
            v11 = sub_2D094(a1, v18, &v17);
            if ( v11 )
              break;
            if ( !v17 )
              goto LABEL_41;
            sub_2E630((int)v18, *v15);
            v11 = sub_2D094(a1, v18, &v17);
            if ( v11 )
              break;
            if ( !v17 )
              goto LABEL_41;
            if ( a2 == v8 )
              goto LABEL_36;
          }
        }
      }
      else
      {
        if ( v10 == 2 )
          goto LABEL_21;
        v3 = &dword_3ACB4;
        sub_2E630((int)v18, 2);
        v11 = sub_2D094(a1, v18, &v17);
        if ( !v11 )
        {
          if ( !v17 )
            goto LABEL_41;
          v8 = 1;
LABEL_21:
          v12 = *v3++;
          sub_2E630((int)v18, v12);
          v11 = sub_2D094(a1, v18, &v17);
          if ( !v11 )
          {
            if ( v17 )
            {
              ++v8;
              goto LABEL_24;
            }
LABEL_41:
            v8 = 0;
LABEL_37:
            sub_29D74((int)v18);
            return v8;
          }
        }
      }
      v8 = v11;
      goto LABEL_37;
    }
  }
  return v8;
}
// 3ACB0: using guessed type _UNKNOWN *off_3ACB0;
// 3ACB4: using guessed type int dword_3ACB4;

//----- (0002D094) --------------------------------------------------------
int __fastcall sub_2D094(int *a1, int *a2, _DWORD *a3)
{
  int v6; // r4
  int v8; // r4
  int v9; // r9
  int v10; // r9
  int v11; // r6
  int v12; // r0
  int v13; // r5
  int v14; // r5
  int v15[4]; // [sp+0h] [bp-34h] BYREF
  int v16[4]; // [sp+10h] [bp-24h] BYREF
  int v17[5]; // [sp+20h] [bp-14h] BYREF

  *a3 = 0;
  if ( sub_29E48((int)a2, 1u) != 1 )
    return -3;
  v6 = sub_2BB10(v15, a1);
  if ( v6 )
    return v6;
  v8 = sub_2E7D4(v15, 1u, v15);
  if ( !v8 )
  {
    v8 = sub_2BB10(v17, v15);
    if ( !v8 )
    {
      v9 = sub_2A0A4(v17);
      v8 = sub_329D0(v17, v9, v17, 0);
      if ( v8 )
        goto LABEL_8;
      v8 = sub_2BAD0((int)v16);
      if ( v8 )
        goto LABEL_8;
      v8 = sub_2AB08(a2, v17, (int)a1, v16);
      if ( v8 )
      {
LABEL_12:
        sub_29D74((int)v16);
LABEL_8:
        sub_29D74((int)v17);
        goto LABEL_5;
      }
      if ( !sub_29E48((int)v16, 1u) || !sub_29E00(v16, v15) )
      {
LABEL_14:
        *a3 = 1;
        goto LABEL_12;
      }
      v10 = v9 - 1;
      if ( v10 <= 0 )
        goto LABEL_49;
      v11 = (v10 - 1) & 3;
      if ( !sub_29E00(v16, v15) )
        goto LABEL_49;
      v12 = sub_2E6F8(v16, a1, v16);
      if ( v12 )
        goto LABEL_51;
      if ( !sub_29E48((int)v16, 1u) )
        goto LABEL_12;
      v13 = 2;
      if ( v10 < 2 )
        goto LABEL_49;
      if ( !v11 )
        goto LABEL_36;
      if ( v11 != 1 )
      {
        if ( v11 != 2 )
        {
          if ( !sub_29E00(v16, v15) )
            goto LABEL_49;
          v12 = sub_2E6F8(v16, a1, v16);
          if ( v12 )
            goto LABEL_51;
          if ( !sub_29E48((int)v16, 1u) )
            goto LABEL_12;
          v13 = 3;
        }
        if ( !sub_29E00(v16, v15) )
        {
LABEL_49:
          if ( sub_29E00(v16, v15) )
            goto LABEL_12;
          goto LABEL_14;
        }
        v12 = sub_2E6F8(v16, a1, v16);
        if ( v12 )
          goto LABEL_51;
        if ( !sub_29E48((int)v16, 1u) )
          goto LABEL_12;
        ++v13;
      }
      if ( sub_29E00(v16, v15) )
      {
        v12 = sub_2E6F8(v16, a1, v16);
        if ( !v12 )
        {
          if ( !sub_29E48((int)v16, 1u) )
            goto LABEL_12;
          if ( ++v13 <= v10 )
          {
LABEL_36:
            while ( sub_29E00(v16, v15) )
            {
              v12 = sub_2E6F8(v16, a1, v16);
              if ( v12 )
                goto LABEL_51;
              if ( !sub_29E48((int)v16, 1u) )
                goto LABEL_12;
              v14 = v13 + 1;
              if ( !sub_29E00(v16, v15) )
                goto LABEL_49;
              v12 = sub_2E6F8(v16, a1, v16);
              if ( v12 )
                goto LABEL_51;
              if ( !sub_29E48((int)v16, 1u) )
                goto LABEL_12;
              if ( !sub_29E00(v16, v15) )
                goto LABEL_49;
              v12 = sub_2E6F8(v16, a1, v16);
              if ( v12 )
                goto LABEL_51;
              if ( !sub_29E48((int)v16, 1u) )
                goto LABEL_12;
              if ( !sub_29E00(v16, v15) )
                goto LABEL_49;
              v12 = sub_2E6F8(v16, a1, v16);
              if ( v12 )
                goto LABEL_51;
              if ( !sub_29E48((int)v16, 1u) )
                goto LABEL_12;
              v13 = v14 + 3;
              if ( v13 > v10 )
                goto LABEL_49;
            }
          }
          goto LABEL_49;
        }
LABEL_51:
        v8 = v12;
        goto LABEL_12;
      }
      goto LABEL_49;
    }
  }
LABEL_5:
  sub_29D74((int)v15);
  return v8;
}

//----- (0002D44C) --------------------------------------------------------
int __fastcall sub_2D44C(int a1, int a2, int a3)
{
  int v6; // r4
  int v7; // r1
  int *v8; // r6
  int *v9; // r8
  int *v10; // r2
  unsigned int v11; // t1
  unsigned int v12; // r11
  unsigned int v13; // r1
  int *v14; // lr
  _UNKNOWN **v15; // r8
  int v16; // r2
  _DWORD *v17; // r12
  unsigned int v18; // r10
  _DWORD *v19; // r3
  unsigned int v20; // r8
  unsigned int v21; // r0
  int v22; // lr
  int v23; // r10
  unsigned int v24; // lr
  int v25; // r10
  unsigned int v26; // r0
  unsigned int v27; // r8
  bool v28; // cc
  unsigned int v29; // lr
  bool v30; // zf
  int v31; // r0
  unsigned int v32; // r10
  unsigned int v33; // r12
  bool v34; // cc
  int v35; // r1
  int v36; // r2
  int v38; // r11
  int *v39; // r4
  int *v40; // r10
  int v41; // r1
  unsigned int v42; // r11
  int v43; // t1
  int v44; // t1
  int v45; // t1
  int v46; // t1
  int v47; // t1
  int v48; // t1
  int v49; // t1
  int v50; // t1
  int v51; // r0
  int v52; // r10
  int v53; // r1
  int *v54; // r8
  int v55; // t1
  int v56; // t1
  int v57; // r0
  int *v58; // r4
  int v59; // [sp+0h] [bp-424h]
  int v60; // [sp+0h] [bp-424h]
  int v61; // [sp+0h] [bp-424h]
  int *v62; // [sp+4h] [bp-420h]
  int v63; // [sp+Ch] [bp-418h] BYREF
  int v64[4]; // [sp+10h] [bp-414h] BYREF
  char v65; // [sp+20h] [bp-404h] BYREF
  int v66; // [sp+24h] [bp-400h] BYREF
  int v67; // [sp+28h] [bp-3FCh] BYREF
  int v68; // [sp+2Ch] [bp-3F8h] BYREF
  char v69; // [sp+30h] [bp-3F4h] BYREF
  int v70; // [sp+41Ch] [bp-8h] BYREF

  v63 = 0;
  if ( (unsigned int)(a2 - 1) > 0xFF )
    return -3;
  *(_DWORD *)(a1 + 8) = 0;
  if ( sub_29E48(a1, 0x653u) == -1 )
  {
    v39 = &dword_3B0AC;
    do
    {
      v40 = v39 - 1;
      if ( sub_29E48(a1, *(v39 - 1)) != -1 )
      {
        v41 = *v39;
        if ( a3 != 1 )
          goto LABEL_83;
        if ( (*v39 & 3) != 3 )
        {
          v42 = ((unsigned int)((char *)&dword_3B0AC - (char *)v39) >> 2) & 7;
          if ( v42 )
          {
            v43 = v39[1];
            ++v39;
            v41 = v43;
            if ( (v43 & 3) == 3 )
              goto LABEL_83;
            if ( v42 != 1 )
            {
              if ( v42 != 2 )
              {
                if ( v42 != 3 )
                {
                  if ( v42 != 4 )
                  {
                    if ( v42 != 5 )
                    {
                      if ( v42 != 6 )
                      {
                        v44 = v39[1];
                        ++v39;
                        v41 = v44;
                        if ( (v44 & 3) == 3 )
                          goto LABEL_83;
                      }
                      v45 = v39[1];
                      ++v39;
                      v41 = v45;
                      if ( (v45 & 3) == 3 )
                        goto LABEL_83;
                    }
                    v46 = v39[1];
                    ++v39;
                    v41 = v46;
                    if ( (v46 & 3) == 3 )
                      goto LABEL_83;
                  }
                  v47 = v39[1];
                  ++v39;
                  v41 = v47;
                  if ( (v47 & 3) == 3 )
                    goto LABEL_83;
                }
                v48 = v39[1];
                ++v39;
                v41 = v48;
                if ( (v48 & 3) == 3 )
                  goto LABEL_83;
              }
              v49 = v39[1];
              ++v39;
              v41 = v49;
              if ( (v49 & 3) == 3 )
              {
LABEL_83:
                sub_2E630(a1, v41);
                return 0;
              }
            }
          }
          while ( v39 != &dword_3B0AC )
          {
            v41 = v39[1];
            if ( (v41 & 3) != 3 )
            {
              v41 = v39[2];
              if ( (v41 & 3) != 3 )
              {
                v41 = v39[3];
                if ( (v41 & 3) != 3 )
                {
                  v41 = v39[4];
                  if ( (v41 & 3) != 3 )
                  {
                    v41 = v39[5];
                    if ( (v41 & 3) != 3 )
                    {
                      v41 = v39[6];
                      if ( (v41 & 3) != 3 )
                      {
                        v41 = v39[7];
                        if ( (v41 & 3) != 3 )
                        {
                          v50 = v39[8];
                          v39 += 8;
                          v41 = v50;
                          if ( (v50 & 3) != 3 )
                            continue;
                        }
                      }
                    }
                  }
                }
              }
            }
            goto LABEL_83;
          }
        }
      }
      v39 = v40;
    }
    while ( &off_3ACB0 != (_UNKNOWN **)v40 );
    if ( !sub_29E48(a1, 1u) )
    {
      sub_2E630(a1, 2);
      return 0;
    }
  }
  if ( a3 == 1 )
  {
    v38 = **(_DWORD **)(a1 + 12) & 3;
    if ( v38 != 3 )
    {
      v7 = sub_2E7D4((int *)a1, v38 + 1, (int *)a1);
      if ( v7 )
        return v7;
    }
    v6 = 4;
    v59 = 268435452;
  }
  else
  {
    if ( *(int *)a1 > 0 && (**(_DWORD **)(a1 + 12) & 1) == 0 )
    {
      v7 = sub_2E7D4((int *)a1, 1u, (int *)a1);
      if ( v7 )
        return v7;
    }
    v6 = 2;
    v59 = 268435454;
  }
  v7 = sub_2C51C(a1, 3u, &v66);
  if ( v7 )
    return v7;
  v7 = sub_2C51C(a1, 5u, &v67);
  if ( v7 )
    return v7;
  v8 = &dword_3ACBC;
  v7 = sub_2C51C(a1, 7u, &v68);
  if ( v7 )
    return v7;
  v9 = (int *)&v69;
  do
  {
    v7 = sub_2C51C(a1, v8[1], v9);
    if ( !v7 )
    {
      v7 = sub_2C51C(a1, v8[2], v9 + 1);
      if ( !v7 )
      {
        v7 = sub_2C51C(a1, v8[3], v9 + 2);
        if ( !v7 )
        {
          v7 = sub_2C51C(a1, v8[4], v9 + 3);
          if ( !v7 )
          {
            v7 = sub_2C51C(a1, v8[5], v9 + 4);
            if ( !v7 )
            {
              v7 = sub_2C51C(a1, v8[6], v9 + 5);
              v10 = v9 + 6;
              v9 += 7;
              if ( !v7 )
              {
                v11 = v8[7];
                v8 += 7;
                v7 = sub_2C51C(a1, v11, v10);
                if ( !v7 )
                  continue;
              }
            }
          }
        }
      }
    }
    return v7;
  }
  while ( v8 != &dword_3B0AC );
  v7 = sub_2BAD0((int)v64);
  if ( v7 )
    return v7;
  v12 = v59;
LABEL_21:
  while ( 1 )
  {
    v13 = 0;
    while ( 1 )
    {
      v13 += v6;
      v14 = (int *)&v65;
      v15 = &off_3ACB0;
      v16 = 0;
      do
      {
        v17 = v15 + 1;
        v18 = (unsigned int)v15[1];
        v19 = v14 + 1;
        v20 = v6 + v14[1];
        v21 = v17[1];
        v14[1] = v20;
        if ( v18 <= v20 )
        {
          v20 -= v18;
          v14[1] = v20;
        }
        v22 = v14[2];
        if ( !v20 )
          v16 = 1;
        v23 = v6 + v22;
        v19[1] = v6 + v22;
        if ( v21 <= v6 + v22 )
        {
          v23 -= v21;
          v19[1] = v23;
        }
        v24 = v17[2];
        if ( !v23 )
          v16 = 1;
        v25 = v19[3];
        v26 = v6 + v19[2];
        v27 = v17[3];
        v28 = v24 > v26;
        v19[2] = v26;
        if ( v24 <= v26 )
          v26 -= v24;
        v29 = v6 + v25;
        if ( !v28 )
          v19[2] = v26;
        v30 = v26 == 0;
        v31 = v19[4];
        if ( v30 )
          v16 = 1;
        v32 = v17[4];
        v19[3] = v29;
        if ( v27 <= v29 )
        {
          v29 -= v27;
          v19[3] = v29;
        }
        v15 = (_UNKNOWN **)(v17 + 4);
        v33 = v6 + v31;
        if ( !v29 )
          v16 = 1;
        v34 = v32 > v33;
        v19[4] = v33;
        if ( v32 <= v33 )
          v33 -= v32;
        v14 = v19 + 4;
        if ( !v34 )
          v19[4] = v33;
        if ( !v33 )
          v16 = 1;
      }
      while ( &v70 != v14 );
      if ( v16 != 1 )
        break;
      if ( v13 >= v12 )
      {
        v35 = sub_2999C((int *)a1, v13, (int *)a1);
        if ( !v35 )
          goto LABEL_21;
        goto LABEL_51;
      }
    }
    v51 = sub_2999C((int *)a1, v13, (int *)a1);
    v52 = v51;
    if ( v51 )
      break;
    v53 = a2 & 3;
    v54 = (int *)&off_3ACB0;
    if ( (a2 & 3) == 0 )
      goto LABEL_104;
    if ( v53 == 1 )
      goto LABEL_101;
    if ( v53 == 2 )
    {
LABEL_98:
      v55 = *v54++;
      sub_2E630((int)v64, v55);
      v35 = sub_2D094((int *)a1, v64, &v63);
      if ( v35 )
        goto LABEL_51;
      if ( v63 )
      {
        ++v52;
LABEL_101:
        v56 = *v54++;
        sub_2E630((int)v64, v56);
        v35 = sub_2D094((int *)a1, v64, &v63);
        if ( v35 )
          goto LABEL_51;
        v57 = v63;
        if ( v63 )
        {
          if ( a2 != ++v52 )
          {
LABEL_104:
            v61 = v6;
            while ( 1 )
            {
              v58 = v54 + 1;
              v52 += 4;
              sub_2E630((int)v64, *v54);
              v35 = sub_2D094((int *)a1, v64, &v63);
              v62 = v54 + 3;
              v54 += 4;
              if ( v35 )
                break;
              if ( !v63 )
                goto LABEL_118;
              sub_2E630((int)v64, *v58);
              v35 = sub_2D094((int *)a1, v64, &v63);
              if ( v35 )
                break;
              if ( !v63 )
                goto LABEL_118;
              sub_2E630((int)v64, v58[1]);
              v35 = sub_2D094((int *)a1, v64, &v63);
              if ( v35 )
                break;
              if ( !v63 )
                goto LABEL_118;
              sub_2E630((int)v64, *v62);
              v35 = sub_2D094((int *)a1, v64, &v63);
              if ( v35 )
                break;
              v57 = v63;
              if ( !v63 )
              {
LABEL_118:
                v6 = v61;
                goto LABEL_21;
              }
              if ( a2 == v52 )
              {
                v6 = v61;
                goto LABEL_115;
              }
            }
LABEL_51:
            v36 = v35;
            goto LABEL_52;
          }
LABEL_115:
          if ( v57 == 1 )
            goto LABEL_51;
        }
      }
    }
    else
    {
      v54 = &dword_3ACB4;
      sub_2E630((int)v64, 2);
      v35 = sub_2D094((int *)a1, v64, &v63);
      if ( v35 )
        goto LABEL_51;
      if ( v63 )
      {
        v52 = 1;
        goto LABEL_98;
      }
    }
  }
  v36 = v51;
LABEL_52:
  v60 = v36;
  sub_29D74((int)v64);
  return v60;
}
// 3ACB0: using guessed type _UNKNOWN *off_3ACB0;
// 3ACB4: using guessed type int dword_3ACB4;
// 3ACBC: using guessed type int dword_3ACBC;
// 3B0AC: using guessed type int dword_3B0AC;

//----- (0002DB1C) --------------------------------------------------------
int __fastcall sub_2DB1C(int *a1, int a2)
{
  unsigned int v4; // r1
  int v5; // r2
  int v6; // r6
  int v7; // r0
  int v8; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r0
  bool v14; // zf

  sub_2EB8C(a1);
  if ( a2 <= 0 )
    return 0;
  do
    v4 = rand() & 0xFFFFFFF;
  while ( !v4 );
  v5 = sub_2999C(a1, v4, a1);
  if ( !v5 )
  {
    v6 = (a2 - 1) & 3;
    if ( !v6 )
      goto LABEL_21;
    --a2;
    v5 = sub_2C160(a1, 1);
    if ( !v5 )
    {
      v7 = rand();
      v5 = sub_2999C(a1, v7 & 0xFFFFFFF, a1);
      if ( !v5 )
      {
        if ( v6 == 1 )
          goto LABEL_21;
        if ( v6 == 2
          || (v5 = sub_2C160(a1, 1), --a2, !v5) && (v8 = rand(), (v5 = sub_2999C(a1, v8 & 0xFFFFFFF, a1)) == 0) )
        {
          v5 = sub_2C160(a1, 1);
          --a2;
          if ( !v5 )
          {
            while ( 1 )
            {
              v13 = rand();
              v5 = sub_2999C(a1, v13 & 0xFFFFFFF, a1);
              if ( v5 )
                break;
LABEL_21:
              v14 = a2 == 1;
              a2 -= 4;
              if ( v14 )
                return 0;
              v5 = sub_2C160(a1, 1);
              if ( !v5 )
              {
                v10 = rand();
                v5 = sub_2999C(a1, v10 & 0xFFFFFFF, a1);
                if ( !v5 )
                {
                  v5 = sub_2C160(a1, 1);
                  if ( !v5 )
                  {
                    v11 = rand();
                    v5 = sub_2999C(a1, v11 & 0xFFFFFFF, a1);
                    if ( !v5 )
                    {
                      v5 = sub_2C160(a1, 1);
                      if ( !v5 )
                      {
                        v12 = rand();
                        v5 = sub_2999C(a1, v12 & 0xFFFFFFF, a1);
                        if ( !v5 )
                        {
                          v5 = sub_2C160(a1, 1);
                          if ( !v5 )
                            continue;
                        }
                      }
                    }
                  }
                }
              }
              return v5;
            }
          }
        }
      }
    }
  }
  return v5;
}

//----- (0002DCD0) --------------------------------------------------------
int __fastcall sub_2DCD0(int *a1, _BYTE *a2, signed int a3)
{
  int v6; // r10
  int v7; // r5
  signed int v8; // r4
  unsigned __int8 *v9; // r12
  signed int v10; // r0
  int v11; // t1
  int result; // r0
  int v13; // t1

  sub_2EB8C(a1);
  if ( (unsigned int)(a3 - 2) > 0x3E )
    return -3;
  if ( *a2 == 45 )
  {
    ++a2;
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  sub_2EB8C(a1);
  v7 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    do
    {
      if ( a3 <= 36 )
        v7 = LOBYTE((*_ctype_toupper_loc())[v7]);
      v8 = 0;
      v9 = (unsigned __int8 *)(off_4C440 - 1);
      while ( v9[1] != v7 )
      {
        v10 = ++v8;
        if ( v9[2] == v7 )
          break;
        ++v8;
        if ( v9[3] == v7 )
          break;
        v8 = v10 + 2;
        if ( v9[4] == v7 )
          break;
        v8 = v10 + 3;
        if ( v9[5] == v7 )
          break;
        v8 = v10 + 4;
        if ( v9[6] == v7 )
          break;
        v8 = v10 + 5;
        if ( v9[7] == v7 )
          break;
        v11 = v9[8];
        v9 += 8;
        v8 = v10 + 6;
        if ( v11 == v7 )
          break;
        v8 = v10 + 7;
        if ( v10 == 57 )
          goto LABEL_18;
      }
      if ( a3 <= v8 )
        break;
      result = sub_2CBE4(a1, a3, a1);
      if ( result )
        return result;
      result = sub_2999C(a1, v8, a1);
      if ( result )
        return result;
      v13 = (unsigned __int8)*++a2;
      v7 = v13;
    }
    while ( v13 );
  }
LABEL_18:
  result = *a1;
  if ( *a1 )
  {
    a1[2] = v6;
    return 0;
  }
  return result;
}
// 4C440: using guessed type char *off_4C440;

//----- (0002DE30) --------------------------------------------------------
int __fastcall sub_2DE30(int a1, unsigned __int8 *a2, int a3)
{
  int v6; // r0
  unsigned __int8 *v7; // r6
  int v8; // r12
  int v9; // t1
  int v10; // t1
  int *v11; // r0
  int v12; // r1
  int v13; // t1
  int v14; // r2
  bool v15; // zf
  int result; // r0

  if ( *(int *)(a1 + 4) > 1 || (result = sub_2BA48(a1, 2)) == 0 )
  {
    sub_2EB8C((_DWORD *)a1);
    if ( a3 <= 0 )
    {
LABEL_19:
      sub_29BBC((int *)a1);
      return 0;
    }
    v6 = a3 & 3;
    v7 = &a2[a3];
    if ( !v6 )
      goto LABEL_12;
    if ( v6 != 1 )
    {
      if ( v6 != 2 )
      {
        v8 = sub_2CA58((int *)a1, 8, (int *)a1);
        if ( v8 )
          return v8;
        v9 = *a2++;
        **(_DWORD **)(a1 + 12) |= v9;
        ++*(_DWORD *)a1;
      }
      v8 = sub_2CA58((int *)a1, 8, (int *)a1);
      if ( v8 )
        return v8;
      v10 = *a2++;
      **(_DWORD **)(a1 + 12) |= v10;
      ++*(_DWORD *)a1;
    }
    v8 = sub_2CA58((int *)a1, 8, (int *)a1);
    if ( !v8 )
    {
      v11 = *(int **)(a1 + 12);
      v13 = *a2++;
      v12 = v13;
      v14 = *v11;
      v15 = v7 == a2;
      while ( 1 )
      {
        *v11 = v14 | v12;
        ++*(_DWORD *)a1;
        if ( v15 )
          break;
LABEL_12:
        v8 = sub_2CA58((int *)a1, 8, (int *)a1);
        if ( v8 )
          return v8;
        **(_DWORD **)(a1 + 12) |= *a2;
        ++*(_DWORD *)a1;
        v8 = sub_2CA58((int *)a1, 8, (int *)a1);
        if ( v8 )
          return v8;
        **(_DWORD **)(a1 + 12) |= a2[1];
        ++*(_DWORD *)a1;
        v8 = sub_2CA58((int *)a1, 8, (int *)a1);
        if ( v8 )
          return v8;
        a2 += 4;
        **(_DWORD **)(a1 + 12) |= *(a2 - 2);
        ++*(_DWORD *)a1;
        v8 = sub_2CA58((int *)a1, 8, (int *)a1);
        if ( v8 )
          return v8;
        v11 = *(int **)(a1 + 12);
        v15 = v7 == a2;
        v12 = *(a2 - 1);
        v14 = *v11;
      }
      goto LABEL_19;
    }
    return v8;
  }
  return result;
}

//----- (0002E030) --------------------------------------------------------
int __fastcall sub_2E030(int *a1, int *a2, unsigned int a3)
{
  int result; // r0
  int v7; // r8
  int v8; // r5
  int v9[4]; // [sp+0h] [bp-10h] BYREF

  result = sub_2BAD0((int)v9);
  if ( !result )
  {
    v7 = sub_2A310(a2);
    if ( a3 == 1 )
    {
      do
      {
        v8 = sub_329D0(a1, v7, v9, a1);
        if ( v8 )
          break;
        v8 = sub_2EC08(a1, v9, a1);
        if ( v8 )
          break;
        if ( sub_29E8C(a1, a2) == -1 )
          break;
        v8 = sub_307E4(a1, a2, a1);
      }
      while ( !v8 );
    }
    else
    {
      do
      {
        v8 = sub_329D0(a1, v7, v9, a1);
        if ( v8 )
          break;
        v8 = sub_2CBE4(v9, a3, v9);
        if ( v8 )
          break;
        v8 = sub_2EC08(a1, v9, a1);
        if ( v8 )
          break;
        if ( sub_29E8C(a1, a2) == -1 )
          break;
        v8 = sub_307E4(a1, a2, a1);
      }
      while ( !v8 );
    }
    sub_29D74((int)v9);
    return v8;
  }
  return result;
}

//----- (0002E168) --------------------------------------------------------
int __fastcall sub_2E168(int *a1, _DWORD *a2)
{
  int result; // r0
  int v5; // r0
  int v6; // r4
  int v7[4]; // [sp+0h] [bp-10h] BYREF

  result = sub_2BAD0((int)v7);
  if ( !result )
  {
    v5 = sub_2A310(a1);
    v6 = sub_298D4(v7, v5);
    if ( v6 || (v6 = sub_307E4(v7, a1, v7)) != 0 )
    {
      sub_29D74((int)v7);
      return v6;
    }
    else
    {
      *a2 = *(_DWORD *)v7[3];
      sub_29D74((int)v7);
      return 0;
    }
  }
  return result;
}

//----- (0002E1FC) --------------------------------------------------------
int __fastcall sub_2E1FC(int *a1)
{
  int v3; // r0
  int v4; // r12
  int v5; // r4
  int v6; // lr
  unsigned int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r1
  unsigned int v11; // r3
  unsigned int v12; // r3
  unsigned int v13; // r3
  unsigned int v14; // r3
  unsigned int v15; // r3
  unsigned int v16; // r3
  int v17; // lr

  if ( !*a1 )
    return 0;
  if ( *a1 <= 1 )
    return 1;
  v3 = sub_2A310(a1);
  if ( v3 <= 28 )
    return 1;
  v4 = a1[3];
  v5 = *(_DWORD *)(v4 + 4);
  if ( (v5 & 1) == 0 )
    return 0;
  v6 = 28;
  v7 = 2;
  v8 = ~(28 - (_BYTE)v3) & 7;
  v9 = 1;
  if ( (~(28 - (_BYTE)v3) & 7) == 0 )
    goto LABEL_55;
  v6 = 29;
  if ( (v5 & 2) == 0 )
    return 0;
  v7 = 4;
  if ( v8 == 1 )
    goto LABEL_55;
  if ( v8 != 2 )
  {
    if ( v8 != 3 )
    {
      if ( v8 != 4 )
      {
        if ( v8 != 5 )
        {
          if ( v8 != 6 )
          {
            v6 = 30;
            if ( (*(_DWORD *)(v4 + 4) & 4) == 0 )
              return 0;
            v7 = 8;
          }
          ++v6;
          if ( (v7 & *(_DWORD *)(v4 + 4)) == 0 )
            return 0;
          v7 *= 2;
          if ( v7 > 0xFFFFFFF )
          {
            v9 = 2;
            v7 = 1;
          }
        }
        ++v6;
        if ( (v7 & *(_DWORD *)(v4 + 4 * v9)) == 0 )
          return 0;
        v7 *= 2;
        if ( v7 > 0xFFFFFFF )
        {
          ++v9;
          v7 = 1;
        }
      }
      ++v6;
      if ( (v7 & *(_DWORD *)(v4 + 4 * v9)) == 0 )
        return 0;
      v7 *= 2;
      if ( v7 > 0xFFFFFFF )
      {
        ++v9;
        v7 = 1;
      }
    }
    ++v6;
    if ( (v7 & *(_DWORD *)(v4 + 4 * v9)) != 0 )
    {
      v7 *= 2;
      if ( v7 > 0xFFFFFFF )
      {
        ++v9;
        v7 = 1;
      }
      goto LABEL_29;
    }
    return 0;
  }
LABEL_29:
  ++v6;
  if ( (v7 & *(_DWORD *)(v4 + 4 * v9)) == 0 )
    return 0;
  while ( 1 )
  {
    v7 *= 2;
    if ( v7 > 0xFFFFFFF )
    {
      ++v9;
      v7 = 1;
    }
LABEL_55:
    v17 = v6 + 1;
    if ( v3 == v17 )
      break;
    v10 = *(_DWORD *)(v4 + 4 * v9);
    if ( (v7 & v10) != 0 )
    {
      v11 = 2 * v7;
      if ( v11 > 0xFFFFFFF )
      {
        ++v9;
        v11 = 1;
        v10 = *(_DWORD *)(v4 + 4 * v9);
      }
      if ( (v11 & v10) != 0 )
      {
        v12 = 2 * v11;
        if ( v12 > 0xFFFFFFF )
        {
          ++v9;
          v12 = 1;
          v10 = *(_DWORD *)(v4 + 4 * v9);
        }
        if ( (v12 & v10) != 0 )
        {
          v13 = 2 * v12;
          if ( v13 > 0xFFFFFFF )
          {
            ++v9;
            v13 = 1;
            v10 = *(_DWORD *)(v4 + 4 * v9);
          }
          if ( (v13 & v10) != 0 )
          {
            v14 = 2 * v13;
            if ( v14 > 0xFFFFFFF )
            {
              ++v9;
              v14 = 1;
              v10 = *(_DWORD *)(v4 + 4 * v9);
            }
            if ( (v14 & v10) != 0 )
            {
              v15 = 2 * v14;
              if ( v15 > 0xFFFFFFF )
              {
                ++v9;
                v15 = 1;
                v10 = *(_DWORD *)(v4 + 4 * v9);
              }
              if ( (v15 & v10) != 0 )
              {
                v16 = 2 * v15;
                if ( v16 > 0xFFFFFFF )
                {
                  ++v9;
                  v16 = 1;
                  v10 = *(_DWORD *)(v4 + 4 * v9);
                }
                if ( (v16 & v10) != 0 )
                {
                  v7 = 2 * v16;
                  v6 = v17 + 7;
                  if ( v7 > 0xFFFFFFF )
                  {
                    ++v9;
                    v7 = 1;
                    v10 = *(_DWORD *)(v4 + 4 * v9);
                  }
                  if ( (v7 & v10) != 0 )
                    continue;
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return 1;
}

//----- (0002E444) --------------------------------------------------------
int __fastcall sub_2E444(int *a1)
{
  int result; // r0
  int *v3; // r3
  int v4; // r1
  int *v5; // r12
  int v6; // r2
  int v7; // t1
  int v8; // t1
  int v9; // t1
  int v10; // t1
  int v11; // t1
  int v12; // t1
  _DWORD *v13; // r3
  int v14; // t1
  int v15; // r2
  int v16; // t1

  result = *a1;
  if ( (unsigned int)result >= 2 )
  {
    if ( result <= 1 )
    {
      return 0;
    }
    else
    {
      v3 = (int *)a1[3];
      v4 = 0;
      v5 = &v3[result];
      v6 = ((unsigned __int8)((unsigned int)(4 * result - 4) >> 2) + 1) & 7;
      if ( (((unsigned __int8)((unsigned int)(4 * result - 4) >> 2) + 1) & 7) == 0 )
        goto LABEL_23;
      if ( v6 != 1 )
      {
        if ( v6 != 2 )
        {
          if ( v6 != 3 )
          {
            if ( v6 != 4 )
            {
              if ( v6 != 5 )
              {
                if ( v6 != 6 )
                {
                  v16 = *v3++;
                  v4 = v16 == 0xFFFFFFF;
                }
                v7 = *v3++;
                if ( v7 == 0xFFFFFFF )
                  ++v4;
              }
              v8 = *v3++;
              if ( v8 == 0xFFFFFFF )
                ++v4;
            }
            v9 = *v3++;
            if ( v9 == 0xFFFFFFF )
              ++v4;
          }
          v10 = *v3++;
          if ( v10 == 0xFFFFFFF )
            ++v4;
        }
        v11 = *v3++;
        if ( v11 == 0xFFFFFFF )
          ++v4;
      }
      v12 = *v3++;
      if ( v12 == 0xFFFFFFF )
        goto LABEL_38;
      while ( v3 != v5 )
      {
LABEL_23:
        v14 = *v3;
        v13 = v3 + 1;
        if ( v14 == 0xFFFFFFF )
          ++v4;
        if ( *v13 == 0xFFFFFFF )
          ++v4;
        v15 = v13[1];
        v3 = v13 + 7;
        if ( v15 == 0xFFFFFFF )
          ++v4;
        if ( *(v3 - 5) == 0xFFFFFFF )
          ++v4;
        if ( *(v3 - 4) == 0xFFFFFFF )
          ++v4;
        if ( *(v3 - 3) == 0xFFFFFFF )
          ++v4;
        if ( *(v3 - 2) == 0xFFFFFFF )
          ++v4;
        if ( *(v3 - 1) == 0xFFFFFFF )
LABEL_38:
          ++v4;
      }
      return v4 >= result >> 1;
    }
  }
  return result;
}

//----- (0002E5A0) --------------------------------------------------------
int *__fastcall sub_2E5A0(int *result, int a2)
{
  int v2; // r3
  int *v3; // r12
  int v4; // r3
  int *v5; // lr
  int v6; // t1
  int v7; // r2

  if ( a2 > 0 )
  {
    v2 = *result;
    v3 = result;
    if ( *result > a2 )
    {
      result = (int *)result[3];
      if ( v2 - a2 <= 0 )
      {
        v4 = 0;
      }
      else
      {
        v4 = 0;
        v5 = &result[a2 - 1];
        do
        {
          v6 = v5[1];
          ++v5;
          ++v4;
          *result++ = v6;
          v7 = *v3 - a2;
        }
        while ( v7 > v4 );
        if ( *v3 <= v4 )
        {
LABEL_9:
          *v3 = v7;
          return result;
        }
      }
      do
      {
        *result++ = 0;
        ++v4;
      }
      while ( *v3 > v4 );
      v7 = *v3 - a2;
      goto LABEL_9;
    }
    return sub_2EB8C(result);
  }
  return result;
}

//----- (0002E630) --------------------------------------------------------
_DWORD *__fastcall sub_2E630(int a1, int a2)
{
  _DWORD *result; // r0
  int v5; // r3

  result = sub_2EB8C((_DWORD *)a1);
  v5 = a2 & 0xFFFFFFF;
  if ( (a2 & 0xFFFFFFF) != 0 )
    v5 = 1;
  **(_DWORD **)(a1 + 12) = a2 & 0xFFFFFFF;
  *(_DWORD *)a1 = v5;
  return result;
}

//----- (0002E65C) --------------------------------------------------------
int __fastcall sub_2E65C(int *a1, unsigned int a2)
{
  int v2; // r6
  int v5; // r7
  int *v6; // r2
  int v7; // r0

  v2 = 8;
  sub_2EB8C(a1);
  while ( 1 )
  {
    v5 = sub_2CA58(a1, 4, a1);
    if ( v5 )
      break;
    v6 = (int *)a1[3];
    --v2;
    v7 = *v6 | (a2 >> 28);
    a2 *= 16;
    *v6 = v7;
    ++*a1;
    if ( !v2 )
    {
      sub_29BBC(a1);
      return v5;
    }
  }
  return v5;
}

//----- (0002E6C0) --------------------------------------------------------
int __fastcall sub_2E6C0(int *a1, int *a2)
{
  bool v3; // cc
  int result; // r0

  v3 = *a1 < 127;
  if ( *a1 <= 127 )
    v3 = 2 * *a1 + 1 < 512;
  if ( v3 )
    result = sub_32018(a1, a2);
  else
    result = sub_3020C(a1, a2);
  a2[2] = 0;
  return result;
}

//----- (0002E6F8) --------------------------------------------------------
int __fastcall sub_2E6F8(int *a1, int *a2, int *a3)
{
  int result; // r0
  int v7; // r4
  int v8[5]; // [sp+0h] [bp-14h] BYREF

  result = sub_2BAD0((int)v8);
  if ( !result )
  {
    v7 = sub_2E6C0(a1, v8);
    if ( !v7 )
      v7 = sub_2C470(v8, a2, a3);
    sub_29D74((int)v8);
    return v7;
  }
  return result;
}

//----- (0002E764) --------------------------------------------------------
int __fastcall sub_2E764(int *a1, int *a2, int *a3)
{
  int v4; // r4
  int *v8; // r2
  int *v9; // r1
  int *v10; // r0

  v4 = a1[2];
  if ( v4 == a2[2] )
  {
    if ( sub_29E8C(a1, a2) == -1 )
    {
      v8 = a3;
      v9 = a1;
      v10 = a2;
      a3[2] = v4 == 0;
    }
    else
    {
      a3[2] = v4;
      v8 = a3;
      v9 = a2;
      v10 = a1;
    }
    return sub_307E4(v10, v9, v8);
  }
  else
  {
    a3[2] = v4;
    return sub_2EC08(a1, a2, a3);
  }
}

//----- (0002E7D4) --------------------------------------------------------
int __fastcall sub_2E7D4(int *a1, unsigned int a2, int *a3)
{
  int v6; // r1
  int v7; // r8
  int v8; // lr
  int *v9; // r1
  int v10; // r6
  unsigned int *v11; // r12
  int *v12; // r0
  int v13; // r12
  int v14; // r1
  size_t v15; // r2
  int v16; // r6
  int *v18; // lr
  unsigned int v19; // r3
  int v20; // r2
  unsigned int v21; // r3
  int i; // r12
  int v23; // t1
  unsigned int v24; // r3
  int v25; // r2
  int v26; // r0
  int v27; // r6

  v6 = *a1 + 1;
  if ( a3[1] < v6 )
  {
    v16 = sub_2BA48((int)a3, v6);
    if ( v16 )
      return v16;
    v7 = a1[2];
    if ( v7 != 1 )
    {
LABEL_3:
      v8 = *a1;
      v9 = (int *)a3[3];
      v10 = *a3;
      v11 = (unsigned int *)a1[3];
      v12 = v9 + 1;
      if ( *a1 == 1 )
      {
        if ( *v11 <= a2 )
        {
          *v9 = a2 - *v11;
          goto LABEL_7;
        }
      }
      else if ( !v8 )
      {
        *v9 = a2;
LABEL_7:
        v13 = 2;
        v14 = 1;
        a3[2] = 1;
        *a3 = 1;
LABEL_8:
        if ( v10 > v14 )
        {
          if ( v10 < v13 )
            v15 = 4;
          else
            v15 = 4 * (v10 + 1 - v13);
          memset(v12, 0, v15);
        }
        v16 = 0;
        sub_29BBC(a3);
        return v16;
      }
      *a3 = v8;
      a3[2] = 0;
      v18 = (int *)(v11 + 1);
      v19 = *v11 - a2;
      v20 = v19 & 0xFFFFFFF;
      v21 = v19 >> 31;
      *v9 = v20;
      if ( *a1 <= 1 )
      {
        v13 = 2;
        v14 = 1;
      }
      else
      {
        for ( i = 1; ; ++i )
        {
          v23 = *v18++;
          v14 = i + 1;
          v24 = v23 - v21;
          v25 = v24 & 0xFFFFFFF;
          v21 = v24 >> 31;
          *v12++ = v25;
          if ( *a1 <= i + 1 )
            break;
        }
        v13 = i + 2;
      }
      goto LABEL_8;
    }
  }
  else
  {
    v7 = a1[2];
    if ( v7 != 1 )
      goto LABEL_3;
  }
  a1[2] = 0;
  v26 = sub_2999C(a1, a2, a3);
  a3[2] = v7;
  v27 = v26;
  a1[2] = v7;
  sub_29BBC(a3);
  return v27;
}
// 2999C: using guessed type int __fastcall sub_2999C(_DWORD, _DWORD, _DWORD);

//----- (0002E954) --------------------------------------------------------
int __fastcall sub_2E954(int *a1, int *a2, int *a3, int *a4)
{
  int result; // r0
  int v9; // r4
  int v10[4]; // [sp+0h] [bp-10h] BYREF

  result = sub_2BAD0((int)v10);
  if ( !result )
  {
    v9 = sub_2E764(a1, a2, v10);
    if ( !v9 )
      v9 = sub_2C470(v10, a3, a4);
    sub_29D74((int)v10);
    return v9;
  }
  return result;
}

//----- (0002E9C8) --------------------------------------------------------
int __fastcall sub_2E9C8(int *a1, _BYTE *a2, unsigned int a3)
{
  int v3; // r4
  _BYTE *v4; // r5
  int v7; // r1
  _BYTE *v8; // r6
  bool v9; // zf
  int v10; // r1
  int v11; // [sp+4h] [bp-14h] BYREF
  int v12[2]; // [sp+8h] [bp-10h] BYREF
  int v13; // [sp+10h] [bp-8h]

  if ( a3 - 2 > 0x3E )
    return -3;
  v3 = *a1;
  v4 = a2;
  if ( !*a1 )
  {
    a2[1] = 0;
    *a2 = 48;
    return v3;
  }
  v3 = sub_2BB10(v12, a1);
  if ( v3 )
    return v3;
  v7 = v12[0];
  if ( v13 == 1 )
  {
    v13 = 0;
    *v4++ = 45;
  }
  if ( v7 )
  {
    v8 = v4;
    while ( 1 )
    {
      v10 = sub_32D70((int)v12, a3, v12, &v11);
      if ( v10 )
        break;
      v9 = v12[0] == 0;
      *v8++ = off_4C440[v11];
      v7 = v8 - v4;
      if ( v9 )
        goto LABEL_14;
    }
    v3 = v10;
    sub_29D74((int)v12);
    return v3;
  }
  v8 = v4;
LABEL_14:
  sub_2EBC4(v4, v7);
  *v8 = 0;
  sub_29D74((int)v12);
  return 0;
}
// 4C440: using guessed type char *off_4C440;

//----- (0002EACC) --------------------------------------------------------
int __fastcall sub_2EACC(int *a1, _BYTE *a2)
{
  int v3; // r4
  _BYTE *v4; // r5
  int v5; // r3
  int v6; // r1
  int v8; // r4
  int v9[4]; // [sp+0h] [bp-10h] BYREF

  v3 = sub_2BB10(v9, a1);
  if ( v3 )
    return v3;
  v4 = a2 - 1;
  do
  {
    if ( !v9[0] )
    {
      v6 = v3;
      v3 = 0;
      sub_2EBC4(a2, v6);
      sub_29D74((int)v9);
      return v3;
    }
    ++v3;
    *++v4 = *(_DWORD *)v9[3];
    v5 = sub_329D0(v9, 8, v9, 0);
  }
  while ( !v5 );
  v8 = v5;
  sub_29D74((int)v9);
  return v8;
}

//----- (0002EB68) --------------------------------------------------------
int __fastcall sub_2EB68(int *a1)
{
  int v1; // r0
  int v2; // r3

  v1 = sub_2A310(a1);
  v2 = v1 & 7;
  if ( (v1 & 7) != 0 )
    v2 = 1;
  return v2 + v1 / 8;
}

//----- (0002EB8C) --------------------------------------------------------
_DWORD *__fastcall sub_2EB8C(_DWORD *result)
{
  int v1; // r2
  int v2; // r3
  bool v3; // cc
  _DWORD *v4; // r2

  v1 = result[1];
  v2 = 0;
  result[2] = 0;
  *result = 0;
  v3 = v1 <= 0;
  v4 = (_DWORD *)result[3];
  if ( !v3 )
  {
    do
    {
      *v4++ = 0;
      ++v2;
    }
    while ( result[1] > v2 );
  }
  return result;
}

//----- (0002EBC4) --------------------------------------------------------
_BYTE *__fastcall sub_2EBC4(_BYTE *result, int a2)
{
  _BYTE *v2; // r12
  int v3; // r3
  char v4; // lr
  char v5; // t1
  char v6; // t1

  if ( a2 - 1 > 0 )
  {
    v2 = result - 1;
    v3 = 0;
    result += a2;
    do
    {
      ++v3;
      v5 = *++v2;
      v4 = v5;
      v6 = *--result;
      *v2 = v6;
      *result = v4;
    }
    while ( v3 < ~v3 + a2 );
  }
  return result;
}

//----- (0002EC08) --------------------------------------------------------
int __fastcall sub_2EC08(int *a1, int *a2, int *a3)
{
  int v3; // r6
  int *v5; // r5
  int v7; // r8
  int v8; // r9
  int v9; // r3
  int *v10; // lr
  int *v11; // r4
  int *v12; // r0
  int v13; // r5
  int *v14; // r2
  int *v15; // r1
  unsigned int v16; // r3
  int *v17; // r12
  int v18; // r11
  int v19; // lr
  int *v20; // r6
  bool v21; // cc
  unsigned int v22; // r3
  unsigned int v23; // r3
  int *v24; // r11
  unsigned int v25; // r3
  unsigned int v26; // r1
  unsigned int v27; // r3
  unsigned int v28; // r1
  unsigned int v29; // r3
  unsigned int v30; // r3
  int v31; // r6
  int *v32; // r9
  int v33; // r11
  int *v34; // lr
  int v35; // t1
  int v36; // r12
  int *v37; // r4
  int v38; // t1
  int v39; // r10
  int v40; // r11
  unsigned int v41; // r3
  int v42; // r2
  int *v43; // r9
  int v44; // r5
  int v45; // t1
  int v46; // t1
  unsigned int v47; // r11
  int v48; // r5
  int v49; // t1
  int v50; // t1
  unsigned int v51; // r3
  int v52; // r11
  int v53; // r2
  _DWORD *v54; // r10
  int *v55; // r5
  int v56; // r1
  _DWORD *v57; // r11
  unsigned int v58; // r3
  unsigned int v59; // r11
  unsigned int v60; // r11
  unsigned int v61; // r10
  int v62; // r9
  int *v63; // r2
  _DWORD *v64; // r12
  int *v65; // lr
  int v66; // r1
  int *v67; // r4
  unsigned int v68; // r3
  unsigned int v69; // r11
  unsigned int v70; // r10
  unsigned int v71; // r10
  unsigned int v72; // r3
  unsigned int v73; // r11
  unsigned int v74; // r1
  unsigned int v75; // r10
  int *v76; // r8
  int v77; // r2
  int *v78; // r8
  int v79; // t1
  int v80; // r10
  unsigned int v81; // r3
  int v82; // r1
  int *v83; // r4
  int v84; // t1
  int v85; // r9
  int v86; // t1
  int v87; // r10
  int v88; // t1
  int v89; // r9
  int v90; // t1
  int v91; // r10
  int v92; // t1
  int v93; // r9
  int v94; // t1
  int v95; // r10
  int v96; // t1
  unsigned int v97; // r3
  int v98; // r9
  int *v99; // r12
  int v100; // r10
  _DWORD *v101; // r11
  unsigned int v102; // r9
  unsigned int v103; // r12
  unsigned int v104; // r3
  unsigned int v105; // r11
  unsigned int v106; // r1
  unsigned int v107; // r10
  unsigned int v108; // lr
  int result; // r0
  int v110; // r5
  int v111; // t1
  int v112; // t1
  unsigned int v113; // r11
  int v114; // [sp+4h] [bp-10h]
  int *v115; // [sp+8h] [bp-Ch]
  int v116; // [sp+Ch] [bp-8h]

  v3 = *a1;
  v5 = a2;
  v7 = *a2;
  if ( *a1 <= *a2 )
  {
    v7 = *a1;
    v3 = *a2;
  }
  v8 = v3 + 1;
  if ( *a1 > *a2 )
    v115 = a1;
  else
    v115 = a2;
  if ( a3[1] >= v8 || (result = sub_2BA48((int)a3, v3 + 1)) == 0 )
  {
    v9 = *a3;
    v10 = (int *)a1[3];
    v11 = (int *)v5[3];
    if ( v7 <= 0 )
      v5 = 0;
    v114 = *a3;
    if ( v7 <= 0 )
      v9 = (int)v5;
    *a3 = v8;
    v12 = (int *)a3[3];
    if ( v7 > 0 )
    {
      v13 = 0;
      if ( v7 - 7 <= 1 )
      {
        v32 = (int *)a3[3];
        v16 = 0;
      }
      else
      {
        v14 = v10 + 8;
        v15 = v11 + 8;
        v16 = 0;
        v17 = v12 + 8;
        v116 = v3;
        do
        {
          v18 = *(v15 - 8);
          v19 = *(v14 - 8);
          v20 = v15 + 8;
          __pld(v14 + 8);
          __pld(v15 + 8);
          v21 = v7 - 7 <= v13 + 9;
          v11 = v15;
          v22 = v19 + v18 + v16;
          v10 = v14;
          v13 += 8;
          *(v17 - 8) = v22 & 0xFFFFFFF;
          v23 = *(v14 - 7) + *(v15 - 7) + (v22 >> 28);
          *(v17 - 7) = v23 & 0xFFFFFFF;
          v24 = v17;
          v17 += 8;
          v25 = *(v14 - 6) + *(v15 - 6) + (v23 >> 28);
          *(v17 - 14) = v25 & 0xFFFFFFF;
          v26 = *(v14 - 5) + *(v15 - 5) + (v25 >> 28);
          *(v17 - 13) = v26 & 0xFFFFFFF;
          v27 = *(v14 - 4) + *(v11 - 4) + (v26 >> 28);
          *(v17 - 12) = v27 & 0xFFFFFFF;
          v28 = *(v14 - 3) + *(v11 - 3) + (v27 >> 28);
          *(v17 - 11) = v28 & 0xFFFFFFF;
          v29 = *(v14 - 2) + *(v11 - 2) + (v28 >> 28);
          v14 += 8;
          *(v17 - 10) = v29 & 0xFFFFFFF;
          v15 = v20;
          v30 = *(v10 - 1) + *(v11 - 1) + (v29 >> 28);
          v31 = v30 & 0xFFFFFFF;
          v16 = v30 >> 28;
          *(v17 - 9) = v31;
        }
        while ( !v21 );
        v3 = v116;
        v32 = v24;
      }
      v35 = *v10;
      v34 = v10 + 1;
      v33 = v35;
      v36 = v13 + 1;
      v38 = *v11;
      v37 = v11 + 1;
      v39 = v33 + v38;
      v40 = (~v13 + v7) & 3;
      v41 = v39 + v16;
      v42 = v41 & 0xFFFFFFF;
      v9 = v41 >> 28;
      *v32 = v42;
      v43 = v32 + 1;
      if ( v7 > v13 + 1 )
      {
        if ( !v40 )
          goto LABEL_58;
        if ( v40 != 1 )
        {
          if ( v40 != 2 )
          {
            v111 = *v34++;
            v110 = v111;
            ++v36;
            v112 = *v37++;
            v113 = v110 + v112 + v9;
            v9 = v113 >> 28;
            *v43++ = v113 & 0xFFFFFFF;
          }
          v45 = *v34++;
          v44 = v45;
          ++v36;
          v46 = *v37++;
          v47 = v44 + v46 + v9;
          v9 = v47 >> 28;
          *v43++ = v47 & 0xFFFFFFF;
        }
        v49 = *v34++;
        v48 = v49;
        ++v36;
        v50 = *v37++;
        v51 = v48 + v50 + v9;
        v52 = v51 & 0xFFFFFFF;
        v9 = v51 >> 28;
        *v43++ = v52;
        if ( v7 > v36 )
        {
LABEL_58:
          do
          {
            v54 = v37 + 1;
            v53 = *v37;
            v55 = v43;
            v57 = v34 + 1;
            v56 = *v34;
            v34 += 4;
            v37 += 4;
            v36 += 4;
            v43 += 4;
            v58 = v56 + v53 + v9;
            *v55 = v58 & 0xFFFFFFF;
            v59 = *v57 + *v54 + (v58 >> 28);
            v55[1] = v59 & 0xFFFFFFF;
            v60 = *(v34 - 2) + *(v37 - 2) + (v59 >> 28);
            *(v43 - 2) = v60 & 0xFFFFFFF;
            v61 = *(v34 - 1) + *(v37 - 1) + (v60 >> 28);
            v9 = v61 >> 28;
            *(v43 - 1) = v61 & 0xFFFFFFF;
          }
          while ( v7 > v36 );
        }
      }
      v12 += v7;
      v5 = (int *)v7;
    }
    if ( v7 != v3 && v3 > (int)v5 )
    {
      v62 = v115[3];
      if ( (int)v5 + 1 >= v3 - 7 )
      {
        v65 = v5;
        v67 = v12;
      }
      else
      {
        v63 = v12 + 8;
        v64 = (_DWORD *)(v62 + 4 * ((_DWORD)v5 + 19));
        v65 = v5;
        do
        {
          v66 = *(v64 - 19);
          __pld(v64);
          v21 = v3 - 7 <= (int)v65 + 9;
          __pld(v63 + 11);
          v67 = v63;
          v68 = v9 + v66;
          v65 += 2;
          v64 += 8;
          *(v63 - 8) = v68 & 0xFFFFFFF;
          v63 += 8;
          v69 = *(v64 - 26) + (v68 >> 28);
          *(v63 - 15) = v69 & 0xFFFFFFF;
          v70 = *(v64 - 25) + (v69 >> 28);
          *(v63 - 14) = v70 & 0xFFFFFFF;
          v71 = *(v64 - 24) + (v70 >> 28);
          *(v63 - 13) = v71 & 0xFFFFFFF;
          v72 = *(v64 - 23) + (v71 >> 28);
          *(v63 - 12) = v72 & 0xFFFFFFF;
          v73 = *(v64 - 22) + (v72 >> 28);
          *(v63 - 11) = v73 & 0xFFFFFFF;
          v74 = *(v64 - 21) + (v73 >> 28);
          *(v63 - 10) = v74 & 0xFFFFFFF;
          v75 = *(v64 - 20) + (v74 >> 28);
          v9 = v75 >> 28;
          *(v63 - 9) = v75 & 0xFFFFFFF;
        }
        while ( !v21 );
      }
      v76 = (int *)(v62 + 4 * (_DWORD)v65);
      v77 = (int)v65 + 1;
      v79 = *v76;
      v78 = v76 + 1;
      v80 = (~(unsigned int)v65 + v3) & 7;
      v81 = v9 + v79;
      v82 = v81 & 0xFFFFFFF;
      v9 = v81 >> 28;
      *v67 = v82;
      v83 = v67 + 1;
      if ( v3 > (int)v65 + 1 )
      {
        if ( !v80 )
          goto LABEL_59;
        if ( v80 != 1 )
        {
          if ( v80 != 2 )
          {
            if ( v80 != 3 )
            {
              if ( v80 != 4 )
              {
                if ( v80 != 5 )
                {
                  if ( v80 != 6 )
                  {
                    v84 = *v78++;
                    v77 = (int)v65 + 2;
                    v85 = v9 + v84;
                    v9 = (unsigned int)(v9 + v84) >> 28;
                    *v83++ = v85 & 0xFFFFFFF;
                  }
                  v86 = *v78++;
                  ++v77;
                  v87 = v9 + v86;
                  v9 = (unsigned int)(v9 + v86) >> 28;
                  *v83++ = v87 & 0xFFFFFFF;
                }
                v88 = *v78++;
                ++v77;
                v89 = v9 + v88;
                v9 = (unsigned int)(v9 + v88) >> 28;
                *v83++ = v89 & 0xFFFFFFF;
              }
              v90 = *v78++;
              ++v77;
              v91 = v9 + v90;
              v9 = (unsigned int)(v9 + v90) >> 28;
              *v83++ = v91 & 0xFFFFFFF;
            }
            v92 = *v78++;
            ++v77;
            v93 = v9 + v92;
            v9 = (unsigned int)(v9 + v92) >> 28;
            *v83++ = v93 & 0xFFFFFFF;
          }
          v94 = *v78++;
          ++v77;
          v95 = v9 + v94;
          v9 = (unsigned int)(v9 + v94) >> 28;
          *v83++ = v95 & 0xFFFFFFF;
        }
        v96 = *v78++;
        ++v77;
        v97 = v9 + v96;
        v98 = v97 & 0xFFFFFFF;
        v9 = v97 >> 28;
        *v83++ = v98;
        if ( v3 > v77 )
        {
LABEL_59:
          do
          {
            v99 = v83;
            v101 = v78 + 1;
            v100 = *v78;
            v77 += 8;
            v83 += 8;
            v78 += 8;
            *v99 = (v9 + v100) & 0xFFFFFFF;
            v102 = *(v78 - 7) + ((unsigned int)(v9 + v100) >> 28);
            v99[1] = v102 & 0xFFFFFFF;
            v103 = v101[1] + (v102 >> 28);
            *(v83 - 6) = v103 & 0xFFFFFFF;
            v104 = *(v78 - 5) + (v103 >> 28);
            *(v83 - 5) = v104 & 0xFFFFFFF;
            v105 = *(v78 - 4) + (v104 >> 28);
            *(v83 - 4) = v105 & 0xFFFFFFF;
            v106 = *(v78 - 3) + (v105 >> 28);
            *(v83 - 3) = v106 & 0xFFFFFFF;
            v107 = *(v78 - 2) + (v106 >> 28);
            *(v83 - 2) = v107 & 0xFFFFFFF;
            v108 = *(v78 - 1) + (v107 >> 28);
            v9 = v108 >> 28;
            *(v83 - 1) = v108 & 0xFFFFFFF;
          }
          while ( v3 > v77 );
        }
      }
      v12 += v3 - (_DWORD)v5;
    }
    *v12 = v9;
    if ( v114 > *a3 )
      memset(v12 + 1, 0, 4 * (v114 - *a3));
    sub_29BBC(a3);
    return 0;
  }
  return result;
}

//----- (0002F1F4) --------------------------------------------------------
int __fastcall sub_2F1F4(int *a1, int *a2, int *a3, int *a4, int a5)
{
  int v5; // r4
  int *v6; // r7
  int v7; // r0
  int v8; // r11
  int v9; // r6
  int v10; // lr
  int *v11; // r5
  int v12; // r9
  int v13; // r10
  int v14; // r11
  int v15; // r8
  int v16; // r0
  int (__fastcall *v17)(int *, int *, int *); // r10
  int *v19; // r10
  unsigned int v20; // r8
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // r0
  int v25; // r0
  int v26; // r0
  int v27; // r0
  int v28; // r3
  int v29; // r4
  int v30; // r9
  int *v31; // r5
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0
  int v38; // r2
  int v39; // r2
  int v40; // r2
  int *v41; // r9
  int v42; // r12
  int v43; // r0
  int v44; // r5
  int v45; // r1
  int *v46; // r8
  int *v47; // r0
  int *v48; // r0
  int *v49; // r11
  int *v50; // r7
  int *v51; // r9
  int *v52; // r4
  int v53; // r9
  int v54; // r3
  int v55; // r1
  int v56; // r5
  int v57; // r6
  int v58; // r8
  int v59; // r11
  char v60; // zf
  int v61; // lr
  unsigned int v62; // r3
  int v63; // r4
  int v65; // r4
  int v66; // r0
  int v67; // r5
  int v68; // r8
  bool v69; // cc
  _BOOL4 v70; // r5
  int v71; // lr
  int v72; // r5
  int v73; // r7
  int v74; // r10
  int v77; // [sp+8h] [bp-103Ch]
  unsigned int v78; // [sp+8h] [bp-103Ch]
  int v79; // [sp+Ch] [bp-1038h]
  int v80; // [sp+Ch] [bp-1038h]
  int v82; // [sp+14h] [bp-1030h]
  int v83; // [sp+18h] [bp-102Ch]
  int v84; // [sp+1Ch] [bp-1028h]
  int v85[4]; // [sp+20h] [bp-1024h] BYREF
  int v86[8]; // [sp+30h] [bp-1014h] BYREF
  int v87[1020]; // [sp+50h] [bp-FF4h] BYREF

  v6 = a2;
  v7 = sub_2A310(a2);
  if ( v7 <= 7 )
  {
    v9 = 4;
    v5 = 2;
    v79 = 32;
    v83 = 2;
    v82 = 1;
    goto LABEL_43;
  }
  if ( v7 > 36 )
  {
    if ( v7 <= 140 )
    {
      v79 = 128;
      v5 = 8;
      v9 = 16;
      v82 = 3;
      v83 = 4;
    }
    else if ( v7 <= 450 )
    {
      v5 = 16;
      v79 = 256;
      v9 = 32;
      v82 = 4;
      v83 = 5;
    }
    else if ( v7 > 1303 )
    {
      if ( v7 <= 3529 )
        v38 = 1024;
      else
        v38 = 2048;
      v79 = v38;
      if ( v7 <= 3529 )
        v39 = 6;
      else
        v39 = 7;
      if ( v7 > 3529 )
        v5 = 128;
      v82 = v39;
      if ( v7 <= 3529 )
      {
        v40 = 7;
        v5 = 64;
      }
      else
      {
        v40 = 8;
      }
      if ( v7 <= 3529 )
        v9 = 128;
      else
        v9 = 256;
      v83 = v40;
    }
    else
    {
      v79 = 512;
      v5 = 32;
      v9 = 64;
      v82 = 5;
      v83 = 6;
    }
LABEL_43:
    v8 = sub_2BAD0((int)v87);
    if ( v8 )
      return v8;
    goto LABEL_4;
  }
  v82 = 2;
  v83 = 3;
  v79 = 64;
  v8 = sub_2BAD0((int)v87);
  v5 = 4;
  v9 = 8;
  if ( v8 )
    return v8;
LABEL_4:
  v10 = (v9 - v5) & 7;
  v11 = &v86[4 * v5 + 4];
  v84 = 4 * v5;
  v12 = v5;
  v13 = (int)v11;
  switch ( v10 )
  {
    case 0:
LABEL_25:
      while ( 1 )
      {
        v14 = sub_2BAD0(v13);
        if ( v14 )
          goto LABEL_49;
        v14 = sub_2BAD0(v13 + 16);
        v15 = ++v12;
        if ( v14 )
          goto LABEL_49;
        v14 = sub_2BAD0(v13 + 32);
        ++v12;
        if ( v14 )
          goto LABEL_49;
        v14 = sub_2BAD0(v13 + 48);
        v12 = v15 + 2;
        if ( v14 )
          goto LABEL_49;
        v14 = sub_2BAD0(v13 + 64);
        v12 = v15 + 3;
        if ( v14 )
          goto LABEL_49;
        v14 = sub_2BAD0(v13 + 80);
        v12 = v15 + 4;
        if ( v14 )
          goto LABEL_49;
        v14 = sub_2BAD0(v13 + 96);
        v12 = v15 + 5;
        v16 = v13 + 112;
        v13 += 128;
        if ( v14 )
          goto LABEL_49;
        v14 = sub_2BAD0(v16);
        v12 = v15 + 6;
        if ( v14 )
          goto LABEL_49;
        v12 = v15 + 7;
        if ( v9 == v15 + 7 )
          goto LABEL_34;
      }
    case 1:
LABEL_23:
      v14 = sub_2BAD0(v13);
      if ( !v14 )
      {
        ++v12;
        v13 += 16;
        if ( v9 != v12 )
          goto LABEL_25;
LABEL_34:
        v8 = sub_2BAD0((int)v86);
        if ( v8 )
        {
          sub_29D74((int)v87);
        }
        else
        {
          if ( a5 )
          {
            v8 = sub_33C9C(a3, v86);
            if ( v8 )
              goto LABEL_40;
            v17 = sub_33BD0;
          }
          else
          {
            v8 = sub_33E88(v86, a3);
            if ( v8 )
              goto LABEL_40;
            v17 = (int (__fastcall *)(int *, int *, int *))sub_33D10;
          }
          v8 = sub_2C470(a1, a3, v87);
          if ( !v8 )
          {
            v41 = (int *)((char *)&v86[4] + v79);
            v8 = sub_2A25C(v87, (int *)((char *)&v86[4] + v79));
            if ( !v8 )
            {
              do
              {
                v42 = sub_2E6C0(v41, v41);
                ++v8;
                if ( v42 )
                  goto LABEL_147;
                v43 = v17(v41, a3, v86);
                if ( v43 )
                {
                  v8 = v43;
                  goto LABEL_40;
                }
              }
              while ( v82 > v8 );
              v44 = v5 + 1;
              if ( v9 <= v5 + 1 )
                goto LABEL_131;
              v45 = (v9 - v44) & 3;
              v46 = &v86[v84 + 4];
              if ( v45 )
              {
                if ( v45 != 1 )
                {
                  if ( v45 != 2 )
                  {
                    v46 += 4;
                    v8 = sub_2CB6C(&v86[v84 + 4], v87, v46);
                    if ( v8 )
                      goto LABEL_40;
                    v8 = v17(v46, a3, v86);
                    if ( v8 )
                      goto LABEL_40;
                    v44 = v5 + 2;
                  }
                  v47 = v46;
                  v46 += 4;
                  v8 = sub_2CB6C(v47, v87, v46);
                  if ( v8 )
                    goto LABEL_40;
                  v8 = v17(v46, a3, v86);
                  if ( v8 )
                    goto LABEL_40;
                  ++v44;
                }
                v48 = v46;
                v46 += 4;
                v8 = sub_2CB6C(v48, v87, v46);
                if ( v8 )
                  goto LABEL_40;
                v8 = v17(v46, a3, v86);
                if ( v8 )
                  goto LABEL_40;
                if ( v9 <= ++v44 )
                  goto LABEL_131;
              }
              v49 = v6;
              v77 = v5;
              while ( 1 )
              {
                v50 = v46 + 4;
                v42 = sub_2CB6C(v46, v87, v46 + 4);
                v51 = v46 + 12;
                v52 = v46 + 8;
                v44 += 4;
                v46 += 16;
                if ( v42 )
                  break;
                v42 = v17(v50, a3, v86);
                if ( v42 )
                  break;
                v42 = sub_2CB6C(v50, v87, v52);
                if ( v42 )
                  break;
                v42 = v17(v52, a3, v86);
                if ( v42 )
                  break;
                v42 = sub_2CB6C(v52, v87, v51);
                if ( v42 )
                  break;
                v42 = v17(v51, a3, v86);
                if ( v42 )
                  break;
                v42 = sub_2CB6C(v51, v87, v46);
                if ( v42 )
                  break;
                v42 = v17(v46, a3, v86);
                if ( v42 )
                  break;
                if ( v9 <= v44 )
                {
                  v5 = v77;
                  v6 = v49;
LABEL_131:
                  v8 = sub_2BAD0((int)v85);
                  if ( v8 )
                    goto LABEL_40;
                  sub_2E630((int)v85, 1);
                  v53 = 0;
                  v54 = v9;
                  v55 = 0;
                  v56 = 0;
                  v78 = 0;
                  v57 = 0;
                  v80 = *v6 - 1;
                  v58 = v5;
                  v59 = v54;
                  if ( v60 )
                    goto LABEL_134;
                  while ( 1 )
                  {
                    v62 = v78;
                    v63 = (v78 >> 27) & 1;
                    if ( v55 | v63 )
                    {
                      if ( v55 == 1 && ((v78 >> 27) & 1) == 0 )
                      {
                        v66 = sub_2E6C0(v85, v85);
                        if ( v66 || (v66 = v17(v85, a3, v86)) != 0 )
                        {
                          v9 = v59;
                          v5 = v58;
                          v8 = v66;
                          goto LABEL_153;
                        }
LABEL_160:
                        v55 = 1;
                        v62 = v78;
                      }
                      else
                      {
                        v65 = v57 | (v63 << (v83 - ++v56));
                        if ( v56 == v83 )
                        {
                          v67 = 0;
                          while ( 1 )
                          {
                            ++v67;
                            v57 = sub_2E6C0(v85, v85);
                            if ( v57 )
                              break;
                            v57 = v17(v85, a3, v86);
                            if ( v57 )
                              break;
                            if ( v67 >= v83 )
                            {
                              v57 = sub_2CB6C(v85, &v86[4 * v65 + 4], v85);
                              if ( !v57 )
                              {
                                v57 = v17(v85, a3, v86);
                                if ( !v57 )
                                {
                                  v56 = 0;
                                  goto LABEL_160;
                                }
                              }
                              break;
                            }
                          }
                          v74 = v59;
                          v5 = v58;
                          v8 = v57;
                          v9 = v74;
LABEL_153:
                          sub_29D74((int)v85);
                          goto LABEL_40;
                        }
                        v62 = v78;
                        v55 = 2;
                        v57 = v65;
                      }
                    }
                    else
                    {
                      v55 = 0;
                    }
                    --v53;
                    v78 = 2 * v62;
                    if ( !v53 )
                    {
LABEL_134:
                      v61 = v80;
                      if ( v80 == -1 )
                      {
                        v5 = v58;
                        v68 = v56;
                        v69 = v56 <= 0;
                        v70 = v55 == 2;
                        if ( v69 )
                          v70 = 0;
                        v71 = v57;
                        v9 = v59;
                        if ( v70 )
                        {
                          v72 = 0;
                          v73 = v71;
                          while ( 1 )
                          {
                            v73 *= 2;
                            v8 = sub_2E6C0(v85, v85);
                            ++v72;
                            if ( v8 )
                              break;
                            v8 = v17(v85, a3, v86);
                            if ( v8 )
                              break;
                            if ( (v9 & v73) != 0 )
                            {
                              v8 = sub_2CB6C(v85, v87, v85);
                              if ( v8 )
                                break;
                              v8 = v17(v85, a3, v86);
                              if ( v8 )
                                break;
                            }
                            if ( v68 <= v72 )
                              goto LABEL_169;
                          }
                        }
                        else
                        {
LABEL_169:
                          sub_2AAD4(v85, a4);
                          v8 = 0;
                        }
                        goto LABEL_153;
                      }
                      v53 = 28;
                      --v80;
                      v78 = *(_DWORD *)(v6[3] + 4 * v61);
                    }
                  }
                }
              }
              v5 = v77;
LABEL_147:
              v8 = v42;
            }
          }
LABEL_40:
          sub_29D74((int)v86);
          sub_29D74((int)v87);
          if ( v9 <= v5 )
            return v8;
        }
        v28 = ~v5;
        v29 = v5 + 1;
        v30 = (v28 + v9) & 7;
        v31 = &v86[v84 + 8];
        sub_29D74((int)&v86[v84 + 4]);
        if ( v9 > v29 )
        {
          if ( !v30 )
            goto LABEL_176;
          if ( v30 != 1 )
          {
            if ( v30 != 2 )
            {
              if ( v30 != 3 )
              {
                if ( v30 != 4 )
                {
                  if ( v30 != 5 )
                  {
                    if ( v30 != 6 )
                    {
                      ++v29;
                      v31 = &v87[v84 + 4];
                      sub_29D74((int)&v86[v84 + 8]);
                    }
                    v32 = (int)v31;
                    ++v29;
                    v31 += 4;
                    sub_29D74(v32);
                  }
                  v33 = (int)v31;
                  ++v29;
                  v31 += 4;
                  sub_29D74(v33);
                }
                v34 = (int)v31;
                ++v29;
                v31 += 4;
                sub_29D74(v34);
              }
              v35 = (int)v31;
              ++v29;
              v31 += 4;
              sub_29D74(v35);
            }
            v36 = (int)v31;
            ++v29;
            v31 += 4;
            sub_29D74(v36);
          }
          ++v29;
          sub_29D74((int)v31);
          v31 += 4;
          if ( v9 > v29 )
          {
LABEL_176:
            do
            {
              sub_29D74((int)v31);
              v29 += 8;
              sub_29D74((int)(v31 + 4));
              sub_29D74((int)(v31 + 8));
              sub_29D74((int)(v31 + 12));
              sub_29D74((int)(v31 + 16));
              sub_29D74((int)(v31 + 20));
              sub_29D74((int)(v31 + 24));
              v37 = (int)(v31 + 28);
              v31 += 32;
              sub_29D74(v37);
            }
            while ( v9 > v29 );
          }
        }
        return v8;
      }
      goto LABEL_49;
    case 2:
LABEL_21:
      v14 = sub_2BAD0(v13);
      if ( v14 )
        goto LABEL_49;
      ++v12;
      v13 += 16;
      goto LABEL_23;
    case 3:
LABEL_19:
      v14 = sub_2BAD0(v13);
      if ( v14 )
        goto LABEL_49;
      ++v12;
      v13 += 16;
      goto LABEL_21;
    case 4:
LABEL_17:
      v14 = sub_2BAD0(v13);
      if ( v14 )
        goto LABEL_49;
      ++v12;
      v13 += 16;
      goto LABEL_19;
    case 5:
LABEL_15:
      v14 = sub_2BAD0(v13);
      if ( v14 )
        goto LABEL_49;
      ++v12;
      v13 += 16;
      goto LABEL_17;
  }
  if ( v10 != 6 )
  {
    v14 = sub_2BAD0((int)&v86[4 * v5 + 4]);
    if ( v14 )
      goto LABEL_49;
    v12 = v5 + 1;
    v13 = (int)(v11 + 4);
  }
  v14 = sub_2BAD0(v13);
  if ( !v14 )
  {
    ++v12;
    v13 += 16;
    goto LABEL_15;
  }
LABEL_49:
  if ( v12 > v5 )
  {
    v19 = &v86[4 * v12 + 4];
    v20 = (((unsigned int)((char *)v19 - (char *)v11 - 16) >> 4) + 1) & 7;
    if ( !v20 )
      goto LABEL_177;
    if ( v20 != 1 )
    {
      if ( v20 != 2 )
      {
        if ( v20 != 3 )
        {
          if ( v20 != 4 )
          {
            if ( v20 != 5 )
            {
              if ( v20 != 6 )
              {
                v11 += 4;
                sub_29D74((int)&v86[4 * v5 + 4]);
              }
              v21 = (int)v11;
              v11 += 4;
              sub_29D74(v21);
            }
            v22 = (int)v11;
            v11 += 4;
            sub_29D74(v22);
          }
          v23 = (int)v11;
          v11 += 4;
          sub_29D74(v23);
        }
        v24 = (int)v11;
        v11 += 4;
        sub_29D74(v24);
      }
      v25 = (int)v11;
      v11 += 4;
      sub_29D74(v25);
    }
    v26 = (int)v11;
    v11 += 4;
    sub_29D74(v26);
    if ( v19 != v11 )
    {
LABEL_177:
      do
      {
        sub_29D74((int)v11);
        sub_29D74((int)(v11 + 4));
        sub_29D74((int)(v11 + 8));
        sub_29D74((int)(v11 + 12));
        sub_29D74((int)(v11 + 16));
        sub_29D74((int)(v11 + 20));
        sub_29D74((int)(v11 + 24));
        v27 = (int)(v11 + 28);
        v11 += 32;
        sub_29D74(v27);
      }
      while ( v19 != v11 );
    }
  }
  sub_29D74((int)v87);
  return v14;
}
// 2F258: variable 'v5' is possibly undefined
// 2FA80: variable 'v60' is possibly undefined
// 33D10: using guessed type int sub_33D10();

//----- (0002FCC8) --------------------------------------------------------
int __fastcall sub_2FCC8(int *a1, int *a2, int *a3, int a4)
{
  int v5; // r5
  int v6; // r3
  int v7; // r6
  unsigned int v8; // lr
  unsigned int *v9; // r1
  unsigned int *v10; // r2
  int *v11; // r11
  unsigned int v12; // r6
  unsigned int v13; // r9
  unsigned int v14; // r4
  signed __int64 v15; // r0
  unsigned int v16; // r6
  unsigned int v17; // r9
  unsigned __int64 v18; // r6
  unsigned int v19; // kr04_4
  unsigned int v20; // r10
  unsigned __int64 v21; // r8
  unsigned int v22; // r3
  __int64 v23; // r8
  unsigned int v24; // kr08_4
  unsigned int v25; // r3
  __int64 v26; // r8
  __int64 v27; // r8
  unsigned int v28; // r3
  __int64 v29; // kr20_8
  int v30; // r10
  int v31; // r3
  unsigned int *v32; // r10
  int *v33; // r12
  int v34; // r7
  unsigned int v35; // lr
  unsigned int *v36; // r10
  unsigned int v37; // t1
  int v38; // r1
  int v39; // r8
  signed __int64 v40; // r6
  int v41; // lr
  unsigned int v42; // r2
  unsigned int v43; // r9
  unsigned int v44; // t1
  unsigned int v45; // t1
  signed __int64 v46; // r2
  unsigned int v47; // r0
  unsigned int v48; // t1
  unsigned int v49; // t1
  unsigned int v50; // kr18_4
  unsigned int v51; // r4
  unsigned int v52; // t1
  unsigned int v53; // t1
  signed __int64 v54; // kr38_8
  int v55; // r4
  unsigned int v56; // r8
  unsigned int *v57; // r11
  unsigned int v58; // kr1C_4
  unsigned int v59; // r2
  signed __int64 v60; // r0
  signed __int64 v61; // r2
  unsigned int v62; // r11
  signed __int64 v63; // r2
  unsigned int v64; // t1
  signed __int64 v65; // r8
  int v66; // r3
  int v67; // r4
  __int64 v69; // [sp+0h] [bp-64h]
  __int64 v70; // [sp+0h] [bp-64h]
  int v71; // [sp+Ch] [bp-58h]
  __int64 v72; // [sp+10h] [bp-54h]
  __int64 v73; // [sp+10h] [bp-54h]
  __int64 v74; // [sp+10h] [bp-54h]
  unsigned int *v75; // [sp+18h] [bp-4Ch]
  int v76; // [sp+1Ch] [bp-48h]
  int v77; // [sp+20h] [bp-44h]
  int v78; // [sp+24h] [bp-40h]
  int v79; // [sp+28h] [bp-3Ch]
  unsigned int v80; // [sp+2Ch] [bp-38h]
  int v82; // [sp+34h] [bp-30h]
  int v84; // [sp+3Ch] [bp-28h]
  int v85; // [sp+44h] [bp-20h]
  unsigned int *v87; // [sp+4Ch] [bp-18h]
  int v88[5]; // [sp+50h] [bp-14h] BYREF

  if ( a4 < 512 )
  {
    v5 = *a2;
    if ( *a2 >= *a1 )
      v5 = *a1;
    if ( v5 <= 255 )
      return sub_31AE4(a1, a2, a3, a4);
  }
  v85 = sub_2BB58(v88, a4);
  if ( !v85 )
  {
    v6 = *a1;
    v88[0] = a4;
    v84 = v6;
    if ( v6 > 0 )
    {
      v77 = 0;
      v78 = v88[3];
      v87 = (unsigned int *)a2[3];
      v82 = a1[3] - 4;
      do
      {
        v7 = a4 - v77;
        v8 = *(_DWORD *)(v82 + 4);
        if ( a4 - v77 >= *a2 )
          v7 = *a2;
        v9 = (unsigned int *)v78;
        v79 = v7;
        v80 = *(_DWORD *)(v82 + 4);
        v82 += 4;
        if ( v7 <= 0 )
        {
          v66 = v77;
          v42 = 0;
        }
        else
        {
          v76 = v7 - 7;
          if ( v7 - 7 <= 1 )
          {
            v33 = (int *)v78;
            v35 = 0;
            v32 = v87;
            v34 = 0;
          }
          else
          {
            v10 = v87 + 8;
            v11 = (int *)(v78 + 32);
            v12 = 0;
            v71 = 0;
            do
            {
              v13 = *(v11 - 8);
              v14 = *(v10 - 8);
              __pld(v11 + 8);
              v75 = (unsigned int *)(v11 + 8);
              __pld(v10 + 8);
              v15 = v8 * (unsigned __int64)v14 + v12 + (unsigned __int64)v13;
              v16 = *(v11 - 7);
              v17 = *(v11 - 6);
              *(v11 - 8) = v15 & 0xFFFFFFF;
              v18 = *(v10 - 7) * (unsigned __int64)v8 + v16;
              v72 = (unsigned int)*(v11 - 5);
              v19 = v15 >> 28;
              *(v11 - 7) = (v18 + v19) & 0xFFFFFFF;
              v20 = (__int64)(v18 + v19) >> 28;
              v21 = *(v10 - 6) * (unsigned __int64)v8 + v17;
              v69 = (unsigned int)*(v11 - 4);
              *(v11 - 6) = (v21 + v20) & 0xFFFFFFF;
              v22 = (__int64)(v21 + v20) >> 28;
              v23 = *(v10 - 5) * (unsigned __int64)v8 + v72;
              v73 = (unsigned int)*(v11 - 3);
              LODWORD(v15) = *(v11 - 2);
              v24 = v23;
              LODWORD(v23) = v23 + v22;
              *(v11 - 5) = v23 & 0xFFFFFFF;
              v25 = ((unsigned int)v23 >> 28) | (16 * ((__PAIR64__(HIDWORD(v23), v24) + v22) >> 32));
              v26 = v69;
              v70 = (unsigned int)v15;
              v27 = *(v10 - 4) * (unsigned __int64)v8 + v26;
              *(v11 - 4) = (v27 + v25) & 0xFFFFFFF;
              v28 = (v27 + v25) >> 28;
              v29 = *(v10 - 3) * (unsigned __int64)v8 + v73;
              v74 = (unsigned int)*(v11 - 1);
              v30 = v71;
              *(v11 - 3) = (v29 + v28) & 0xFFFFFFF;
              LODWORD(v15) = *(v10 - 2);
              v71 += 8;
              LODWORD(v27) = (v29 + v28) >> 28;
              v31 = v30 + 9;
              v32 = v10;
              *(v11 - 2) = (v15 * v8 + v70 + v27) & 0xFFFFFFF;
              v10 += 8;
              v33 = v11;
              v12 = (__int64)(*(v32 - 1) * (unsigned __int64)v8
                            + v74
                            + (unsigned int)((__int64)((unsigned int)v15 * (unsigned __int64)v8 + v70 + (unsigned int)v27) >> 28)) >> 28;
              *(v11 - 1) = (*(v32 - 1) * v8
                          + v74
                          + ((__int64)((unsigned int)v15 * (unsigned __int64)v8 + v70 + (unsigned int)v27) >> 28))
                         & 0xFFFFFFF;
              v11 = (int *)v75;
            }
            while ( v76 > v31 );
            v34 = v71;
            v35 = v12;
          }
          v37 = *v32;
          v36 = v32 + 1;
          v38 = v34 + 1;
          v39 = ~v34;
          v40 = v80 * (unsigned __int64)v37 + v35 + (unsigned __int64)(unsigned int)*v33;
          v41 = (v39 + v79) & 3;
          *v33 = v40 & 0xFFFFFFF;
          v42 = v40 >> 28;
          if ( v79 > v38 )
          {
            if ( !v41 )
              goto LABEL_22;
            if ( v41 != 1 )
            {
              if ( v41 != 2 )
              {
                v44 = v33[1];
                ++v33;
                v43 = v44;
                v45 = *v36++;
                ++v38;
                v46 = v80 * (unsigned __int64)v45 + v42 + (unsigned __int64)v43;
                *v33 = v46 & 0xFFFFFFF;
                v42 = v46 >> 28;
              }
              v48 = v33[1];
              ++v33;
              v47 = v48;
              v49 = *v36++;
              ++v38;
              v50 = v42;
              v42 = (__int64)(v80 * (unsigned __int64)v49 + v42 + (unsigned __int64)v47) >> 28;
              *v33 = (v80 * v49 + v50 + v47) & 0xFFFFFFF;
            }
            v52 = v33[1];
            ++v33;
            v51 = v52;
            v53 = *v36++;
            ++v38;
            v54 = v80 * (unsigned __int64)v53 + v42 + (unsigned __int64)v51;
            *v33 = v54 & 0xFFFFFFF;
            v42 = v54 >> 28;
            if ( v79 > v38 )
            {
LABEL_22:
              v55 = v38;
              do
              {
                v57 = v36 + 1;
                v56 = *v36;
                v36 += 4;
                v55 += 4;
                v58 = v42;
                v59 = v33[2];
                v60 = v80 * (unsigned __int64)v56 + v58 + (unsigned __int64)(unsigned int)v33[1];
                v33[1] = v60 & 0xFFFFFFF;
                v61 = v80 * (unsigned __int64)*v57 + (unsigned int)(v60 >> 28) + (unsigned __int64)v59;
                v62 = v33[3];
                v33[2] = v61 & 0xFFFFFFF;
                v63 = v80 * (unsigned __int64)*(v36 - 2) + (unsigned int)(v61 >> 28) + (unsigned __int64)v62;
                v33[3] = v63 & 0xFFFFFFF;
                v64 = v33[4];
                v33 += 4;
                v65 = v80 * (unsigned __int64)*(v36 - 1)
                    + (((unsigned int)v63 >> 28) | (unsigned __int64)(unsigned int)(16 * HIDWORD(v63)))
                    + v64;
                *v33 = (v80 * *(v36 - 1) + (v63 >> 28) + v64) & 0xFFFFFFF;
                v42 = v65 >> 28;
              }
              while ( v79 > v55 );
            }
          }
          v9 = (unsigned int *)(v78 + 4 * v79);
          v66 = v79 + v77;
        }
        v67 = v77;
        if ( a4 > v66 )
          *v9 = v42;
        ++v77;
        v78 += 4;
      }
      while ( v84 != v67 + 1 );
    }
    sub_29BBC(v88);
    sub_2AAD4(v88, a3);
    sub_29D74((int)v88);
  }
  return v85;
}

//----- (0003020C) --------------------------------------------------------
int __fastcall sub_3020C(int *a1, int *a2)
{
  int v2; // r6
  int v4; // r1
  _DWORD *v5; // lr
  unsigned int v6; // r4
  unsigned int v7; // r10
  int *v8; // r8
  int v9; // r12
  int v10; // r9
  signed __int64 v11; // r4
  unsigned int v12; // r2
  int v13; // r5
  int v14; // r7
  _DWORD *v15; // r0
  _BOOL4 v16; // r12
  int *v17; // r1
  unsigned int v18; // r8
  unsigned int v19; // kr04_4
  int v20; // r11
  unsigned int v21; // r4
  unsigned int v22; // r8
  int v23; // r4
  unsigned int v24; // r8
  int v25; // r10
  int v26; // r5
  unsigned int v27; // r4
  unsigned int v28; // r8
  int v29; // lr
  __int64 v30; // r10
  int v31; // r2
  unsigned int v32; // r8
  __int64 v33; // kr58_8
  int v34; // r6
  unsigned __int64 v35; // kr60_8
  unsigned int v36; // r6
  int v37; // r6
  unsigned __int64 v38; // kr68_8
  unsigned int v39; // r6
  int v40; // r6
  unsigned int v41; // kr70_4
  int v42; // r4
  int v43; // r3
  signed __int64 v44; // kr78_8
  unsigned int v45; // r6
  signed __int64 v46; // kr80_8
  int v47; // r6
  bool v48; // cf
  int v49; // r6
  unsigned int v50; // r0
  char v51; // r3
  int v52; // r7
  int v53; // r9
  int v54; // r12
  unsigned __int64 v55; // r4
  unsigned __int64 v56; // r2
  int v57; // lr
  int *v58; // r1
  unsigned int *v59; // lr
  unsigned __int64 v60; // r4
  unsigned int v61; // r2
  unsigned int v62; // r11
  unsigned int v63; // t1
  unsigned int v64; // r2
  unsigned int v65; // r8
  unsigned int v66; // t1
  unsigned int v67; // r2
  unsigned int v68; // r8
  int v69; // r9
  unsigned int v70; // r7
  _DWORD *v71; // r8
  int *v72; // r0
  unsigned int v73; // r2
  unsigned int v74; // r11
  int v75; // r4
  unsigned int v76; // r4
  int v77; // kr24_4
  unsigned int v78; // r10
  int v79; // r7
  unsigned __int64 v80; // r10
  unsigned int v81; // r8
  unsigned int v82; // r5
  int v83; // kr38_4
  unsigned int v84; // r0
  unsigned int v85; // r7
  unsigned int v86; // kr40_4
  int v87; // r5
  unsigned int v89; // [sp+10h] [bp-44h]
  int v90; // [sp+14h] [bp-40h]
  int v91; // [sp+18h] [bp-3Ch]
  _DWORD *v92; // [sp+1Ch] [bp-38h]
  int *v93; // [sp+20h] [bp-34h]
  int v94; // [sp+24h] [bp-30h]
  int v95; // [sp+28h] [bp-2Ch]
  int v96; // [sp+30h] [bp-24h]
  int v97; // [sp+34h] [bp-20h]
  int v98; // [sp+38h] [bp-1Ch]
  int v100[3]; // [sp+40h] [bp-14h] BYREF
  int v101; // [sp+4Ch] [bp-8h]

  v2 = *a1;
  v90 = *a1;
  v98 = sub_2BB58(v100, 2 * *a1 + 1);
  if ( !v98 )
  {
    v100[0] = 2 * v2 + 1;
    if ( v2 > 0 )
    {
      v97 = v2 - 7;
      v96 = a1[3];
      v4 = v96 - 4;
      v91 = 0;
      v92 = (_DWORD *)(v101 + 16);
      v93 = (int *)(v101 + 4 * v2);
      do
      {
        v5 = v92;
        v6 = *(v92 - 4);
        v7 = *(_DWORD *)(v4 + 4);
        v8 = v92 - 3;
        v9 = v90;
        v10 = v91 + 1;
        __pld(v92);
        v91 = v10;
        v11 = v7 * (unsigned __int64)v7 + v6;
        v94 = v4 + 4;
        *(v5 - 4) = v11 & 0xFFFFFFF;
        v12 = v11 >> 28;
        v13 = *(_DWORD *)(v4 + 4);
        if ( v9 > v10 )
        {
          v95 = *(_DWORD *)(v4 + 4);
          if ( v97 <= v10 + 1 )
          {
            v47 = *(_DWORD *)(v4 + 4);
          }
          else
          {
            v14 = 2 * v13;
            v15 = (_DWORD *)(v4 + 64);
            v16 = __CFADD__(v13, v13);
            v17 = v92 + 5;
            do
            {
              v18 = *(v15 - 14);
              __pld(v15);
              v15 += 8;
              __pld(v17 + 6);
              v19 = *(v17 - 8);
              v20 = v18 * v14;
              v21 = (__PAIR64__(v16, v14) * v18) >> 32;
              v22 = *(v17 - 7);
              *(v17 - 8) = (v12 + v19 + v20) & 0xFFFFFFF;
              v23 = (__int64)(v12 + (unsigned __int64)v19 + __PAIR64__(v21, v20)) >> 28;
              v25 = (__PAIR64__(v16, v14) * (unsigned int)*(v15 - 21) + v22) >> 32;
              v24 = v14 * *(v15 - 21) + v22;
              v48 = __CFADD__(v24, v23);
              v26 = (v24 + v23) & 0xFFFFFFF;
              v27 = (v24 + v23) >> 28;
              *(v17 - 7) = v26;
              v28 = *(v15 - 20);
              v29 = v27 | (16 * (v48 + v25));
              LODWORD(v30) = *(v17 - 6);
              v31 = v28 * v14;
              HIDWORD(v30) = (__PAIR64__(v16, v14) * v28) >> 32;
              v32 = *(v17 - 3);
              v33 = v30 + (unsigned int)v31 + (unsigned int)v29;
              *(v17 - 6) = v33 & 0xFFFFFFF;
              v34 = v33 >> 28;
              v35 = __PAIR64__(v16, v14) * (unsigned int)*(v15 - 19) + (unsigned int)*(v17 - 5);
              v48 = __CFADD__((_DWORD)v35, v34);
              v36 = v35 + v34;
              *(v17 - 5) = v36 & 0xFFFFFFF;
              v37 = (v36 >> 28) | (16 * (v48 + HIDWORD(v35)));
              v38 = __PAIR64__(v16, v14) * (unsigned int)*(v15 - 18) + (unsigned int)*(v17 - 4);
              v48 = __CFADD__((_DWORD)v38, v37);
              v39 = v38 + v37;
              *(v17 - 4) = v39 & 0xFFFFFFF;
              v40 = (v39 >> 28) | (16 * (v48 + HIDWORD(v38)));
              v41 = v14 * *(v15 - 17) + v32;
              v42 = __CFADD__(v41, v40) + ((__PAIR64__(v16, v14) * (unsigned int)*(v15 - 17) + v32) >> 32);
              *(v17 - 3) = (v41 + v40) & 0xFFFFFFF;
              v43 = v10 + 9;
              v10 += 8;
              v44 = __PAIR64__(v16, v14) * (unsigned int)*(v15 - 16)
                  + (unsigned int)*(v17 - 2)
                  + (((v41 + v40) >> 28) | (16 * v42));
              *(v17 - 2) = v44 & 0xFFFFFFF;
              v8 = v17;
              v45 = *(v17 - 1);
              v17 += 8;
              v46 = __PAIR64__(v16, v14) * (unsigned int)*(v15 - 15) + v45 + (unsigned int)(v44 >> 28);
              v12 = v46 >> 28;
              *(v17 - 9) = v46 & 0xFFFFFFF;
            }
            while ( v97 > v43 );
            v47 = v95;
          }
          v48 = __CFADD__(v47, v47);
          v49 = 2 * v47;
          v50 = *(_DWORD *)(v96 + 4 * v10);
          v51 = ~(_BYTE)v10;
          v52 = v10 + 1;
          v53 = v96 + 4 * v10;
          v54 = (v51 + (_BYTE)v90) & 3;
          v55 = v12 + (unsigned __int64)(unsigned int)*v8;
          v56 = __PAIR64__(v48, v49) * v50;
          v57 = (v55 + v56) & 0xFFFFFFF;
          v12 = (__int64)(v55 + v56) >> 28;
          *v8 = v57;
          v58 = v8 + 1;
          v59 = (unsigned int *)(v53 + 4);
          if ( v90 > v52 )
          {
            if ( !v54 )
              goto LABEL_16;
            if ( v54 != 1 )
            {
              if ( v54 != 2 )
              {
                v59 = (unsigned int *)(v53 + 8);
                ++v52;
                v60 = __PAIR64__(v48, v49) * *(unsigned int *)(v53 + 4);
                v62 = (v12 + (unsigned __int64)(unsigned int)*v58) >> 32;
                v61 = v12 + *v58;
                *v58 = (v61 + v60) & 0xFFFFFFF;
                v58 = v8 + 2;
                v12 = (__int64)(__PAIR64__(v62, v61) + v60) >> 28;
              }
              v63 = *v59++;
              ++v52;
              v65 = (v12 + (unsigned __int64)(unsigned int)*v58) >> 32;
              v64 = v12 + *v58;
              *v58++ = (v64 + v49 * v63) & 0xFFFFFFF;
              v12 = (__int64)(__PAIR64__(v65, v64) + __PAIR64__(v48, v49) * v63) >> 28;
            }
            v66 = *v59++;
            ++v52;
            v68 = (v12 + (unsigned __int64)(unsigned int)*v58) >> 32;
            v67 = v12 + *v58;
            *v58++ = (v67 + v49 * v66) & 0xFFFFFFF;
            v12 = (__int64)(__PAIR64__(v68, v67) + __PAIR64__(v48, v49) * v66) >> 28;
            if ( v90 > v52 )
            {
LABEL_16:
              v69 = v52;
              do
              {
                v71 = v59 + 1;
                v70 = *v59;
                v72 = v58;
                v69 += 4;
                v74 = (v12 + (unsigned __int64)(unsigned int)*v58) >> 32;
                v73 = v12 + *v58;
                v58 += 4;
                v75 = v49 * *v59;
                v59 += 4;
                v77 = v75;
                v76 = v73 + v75;
                *v72++ = v76 & 0xFFFFFFF;
                v78 = (v76 >> 28)
                    | (16 * ((__PAIR64__(v74, v73) + __PAIR64__((__PAIR64__(v48, v49) * v70) >> 32, v77)) >> 32));
                v89 = *(v59 - 3);
                v79 = v72[1];
                v80 = v78 + (unsigned __int64)(unsigned int)*(v58 - 3);
                *v72 = (v80 + v49 * v89) & 0xFFFFFFF;
                v81 = v71[1];
                v82 = (__int64)(v80 + __PAIR64__(v48, v49) * v89) >> 28;
                v83 = v79;
                v84 = *(v58 - 1);
                v85 = v82 + v79;
                *(v58 - 2) = (v85 + v49 * v81) & 0xFFFFFFF;
                LODWORD(v80) = *(v59 - 1);
                v86 = (__int64)(__PAIR64__((v82 + (unsigned __int64)(unsigned int)v83) >> 32, v85)
                              + __PAIR64__(v48, v49) * v81) >> 28;
                v12 = (__int64)(v86 + (unsigned __int64)v84 + __PAIR64__(v48, v49) * (unsigned int)v80) >> 28;
                *(v58 - 1) = (v86 + v84 + v49 * v80) & 0xFFFFFFF;
              }
              while ( v90 > v69 );
            }
          }
          v8 = v93;
        }
        for ( ; v12; ++v8 )
        {
          v87 = (*v8 + v12) & 0xFFFFFFF;
          v12 = (__int64)(v12 + (unsigned __int64)(unsigned int)*v8) >> 28;
          *v8 = v87;
        }
        v4 = v94;
        v92 += 2;
        ++v93;
      }
      while ( v90 != v91 );
    }
    sub_29BBC(v100);
    sub_2AAD4(v100, a2);
    sub_29D74((int)v100);
  }
  return v98;
}

//----- (000307E4) --------------------------------------------------------
int __fastcall sub_307E4(int *a1, int *a2, int *a3)
{
  int v4; // r7
  int v7; // r5
  bool v8; // cc
  int *v9; // r3
  int *v10; // r8
  int *v11; // lr
  int *v12; // r10
  int v13; // r4
  int *v14; // r1
  unsigned int v15; // r3
  int *v16; // r2
  int *v17; // r0
  int v18; // r11
  int v19; // r12
  int *v20; // r8
  unsigned int v21; // r3
  int *v22; // r12
  unsigned int v23; // r3
  int *v24; // r11
  unsigned int v25; // r3
  unsigned int v26; // r1
  unsigned int v27; // r3
  unsigned int v28; // r1
  unsigned int v29; // r3
  unsigned int v30; // r3
  int v31; // r8
  int *v32; // r9
  int v33; // r2
  int *v34; // lr
  int v35; // t1
  int v36; // r0
  int *v37; // r12
  int v38; // t1
  int v39; // r4
  unsigned int v40; // r3
  int v41; // r2
  int *v42; // r9
  int v43; // r10
  int v44; // t1
  int v45; // t1
  unsigned int v46; // r4
  int v47; // r10
  int v48; // t1
  int v49; // t1
  unsigned int v50; // r3
  int v51; // r4
  int v52; // r2
  _DWORD *v53; // r10
  int *v54; // r4
  int v55; // r1
  _DWORD *v56; // r11
  unsigned int v57; // r3
  unsigned int v58; // r11
  unsigned int v59; // r11
  unsigned int v60; // r10
  int *v61; // r2
  int v62; // r12
  int *v63; // r0
  int v64; // r10
  int *v65; // lr
  unsigned int v66; // r3
  unsigned int v67; // r10
  unsigned int v68; // r9
  unsigned int v69; // r11
  unsigned int v70; // r10
  unsigned int v71; // r9
  unsigned int v72; // r1
  unsigned int v73; // r3
  int v74; // r10
  int *v75; // r8
  int v76; // t1
  int v77; // r2
  int v78; // r10
  int v79; // r0
  unsigned int v80; // r3
  int *v81; // lr
  int v82; // t1
  int v83; // r4
  int v84; // t1
  int v85; // r9
  int v86; // t1
  int v87; // r12
  int v88; // t1
  int v89; // r11
  int v90; // t1
  int v91; // r0
  int v92; // t1
  int v93; // r1
  int v94; // t1
  unsigned int v95; // r3
  int v96; // r10
  unsigned int *v97; // r0
  int v98; // r4
  _DWORD *v99; // r12
  unsigned int v100; // r10
  unsigned int v101; // r0
  unsigned int v102; // r9
  unsigned int v103; // r3
  unsigned int v104; // r4
  unsigned int v105; // r1
  unsigned int v106; // r12
  int result; // r0
  int v108; // r10
  int v109; // t1
  int v110; // t1
  unsigned int v111; // r4
  int *s; // [sp+4h] [bp-10h]
  int v113; // [sp+8h] [bp-Ch]
  int *v114; // [sp+Ch] [bp-8h]

  v4 = *a1;
  v7 = *a2;
  if ( a3[1] >= *a1 || (result = sub_2BA48((int)a3, *a1)) == 0 )
  {
    v8 = v7 <= 0;
    v9 = (int *)a3[3];
    if ( v7 <= 0 )
      v7 = 0;
    v10 = (int *)a1[3];
    v11 = (int *)a2[3];
    s = (int *)a3[3];
    if ( v8 )
      v9 = (int *)v7;
    v113 = *a3;
    *a3 = v4;
    if ( !v8 )
    {
      if ( v7 - 7 <= 1 )
      {
        v13 = 0;
        v32 = v9;
        v22 = v10;
        v15 = 0;
      }
      else
      {
        v12 = v9;
        v13 = 0;
        v14 = v11 + 8;
        v15 = 0;
        v16 = v10 + 8;
        v17 = v12 + 8;
        v114 = v10;
        do
        {
          v18 = *(v14 - 8);
          v19 = *(v16 - 8);
          v20 = v14 + 8;
          __pld(v16 + 8);
          __pld(v14 + 8);
          v8 = v7 - 7 <= v13 + 9;
          v11 = v14;
          v21 = v19 - v18 - v15;
          v22 = v16;
          v13 += 8;
          *(v17 - 8) = v21 & 0xFFFFFFF;
          v23 = *(v16 - 7) - *(v14 - 7) - (v21 >> 31);
          *(v17 - 7) = v23 & 0xFFFFFFF;
          v24 = v17;
          v17 += 8;
          v25 = *(v16 - 6) - *(v14 - 6) - (v23 >> 31);
          *(v17 - 14) = v25 & 0xFFFFFFF;
          v26 = *(v16 - 5) - *(v14 - 5) - (v25 >> 31);
          *(v17 - 13) = v26 & 0xFFFFFFF;
          v27 = *(v16 - 4) - *(v11 - 4) - (v26 >> 31);
          *(v17 - 12) = v27 & 0xFFFFFFF;
          v28 = *(v16 - 3) - *(v11 - 3) - (v27 >> 31);
          *(v17 - 11) = v28 & 0xFFFFFFF;
          v29 = *(v16 - 2) - *(v11 - 2) - (v28 >> 31);
          v16 += 8;
          *(v17 - 10) = v29 & 0xFFFFFFF;
          v14 = v20;
          v30 = *(v22 - 1) - *(v11 - 1) - (v29 >> 31);
          v31 = v30 & 0xFFFFFFF;
          v15 = v30 >> 31;
          *(v17 - 9) = v31;
        }
        while ( !v8 );
        v10 = v114;
        v32 = v24;
      }
      v35 = *v11;
      v34 = v11 + 1;
      v33 = v35;
      v36 = v13 + 1;
      v38 = *v22;
      v37 = v22 + 1;
      v8 = v7 <= v13 + 1;
      v39 = (~v13 + v7) & 3;
      v40 = v38 - v33 - v15;
      v41 = v40 & 0xFFFFFFF;
      v9 = (int *)(v40 >> 31);
      *v32 = v41;
      v42 = v32 + 1;
      if ( !v8 )
      {
        if ( !v39 )
          goto LABEL_52;
        if ( v39 != 1 )
        {
          if ( v39 != 2 )
          {
            v109 = *v37++;
            v108 = v109;
            ++v36;
            v110 = *v34++;
            v111 = v108 - v110 - (_DWORD)v9;
            v9 = (int *)(v111 >> 31);
            *v42++ = v111 & 0xFFFFFFF;
          }
          v44 = *v37++;
          v43 = v44;
          ++v36;
          v45 = *v34++;
          v46 = v43 - v45 - (_DWORD)v9;
          v9 = (int *)(v46 >> 31);
          *v42++ = v46 & 0xFFFFFFF;
        }
        v48 = *v37++;
        v47 = v48;
        ++v36;
        v49 = *v34++;
        v50 = v47 - v49 - (_DWORD)v9;
        v51 = v50 & 0xFFFFFFF;
        v9 = (int *)(v50 >> 31);
        *v42++ = v51;
        if ( v7 > v36 )
        {
LABEL_52:
          do
          {
            v53 = v34 + 1;
            v52 = *v34;
            v54 = v42;
            v56 = v37 + 1;
            v55 = *v37;
            v37 += 4;
            v34 += 4;
            v36 += 4;
            v42 += 4;
            v57 = v55 - v52 - (_DWORD)v9;
            *v54 = v57 & 0xFFFFFFF;
            v58 = *v56 - *v53 - (v57 >> 31);
            v54[1] = v58 & 0xFFFFFFF;
            v59 = *(v37 - 2) - *(v34 - 2) - (v58 >> 31);
            *(v42 - 2) = v59 & 0xFFFFFFF;
            v60 = *(v37 - 1) - *(v34 - 1) - (v59 >> 31);
            v9 = (int *)(v60 >> 31);
            *(v42 - 1) = v60 & 0xFFFFFFF;
          }
          while ( v7 > v36 );
        }
      }
      v10 += v7;
      s += v7;
    }
    if ( v4 > v7 )
    {
      if ( v7 + 1 >= v4 - 7 )
      {
        v62 = v7;
        v65 = s;
      }
      else
      {
        v61 = v10 + 8;
        v62 = v7;
        v63 = s + 8;
        do
        {
          v64 = *(v61 - 8);
          __pld(v61 + 12);
          v8 = v4 - 7 <= v62 + 9;
          v10 = v61;
          v65 = v63;
          v66 = v64 - (_DWORD)v9;
          v62 += 8;
          v61 += 8;
          *(v63 - 8) = v66 & 0xFFFFFFF;
          v63 += 8;
          v67 = *(v61 - 15) - (v66 >> 31);
          *(v63 - 15) = v67 & 0xFFFFFFF;
          v68 = *(v61 - 14) - (v67 >> 31);
          *(v63 - 14) = v68 & 0xFFFFFFF;
          v69 = *(v61 - 13) - (v68 >> 31);
          *(v63 - 13) = v69 & 0xFFFFFFF;
          v70 = *(v61 - 12) - (v69 >> 31);
          *(v63 - 12) = v70 & 0xFFFFFFF;
          v71 = *(v61 - 11) - (v70 >> 31);
          *(v63 - 11) = v71 & 0xFFFFFFF;
          v72 = *(v61 - 10) - (v71 >> 31);
          *(v63 - 10) = v72 & 0xFFFFFFF;
          v73 = *(v61 - 9) - (v72 >> 31);
          v74 = v73 & 0xFFFFFFF;
          v9 = (int *)(v73 >> 31);
          *(v63 - 9) = v74;
        }
        while ( !v8 );
      }
      v76 = *v10;
      v75 = v10 + 1;
      v77 = v62 + 1;
      v78 = (~v62 + v4) & 7;
      v79 = (v76 - (_DWORD)v9) & 0xFFFFFFF;
      v80 = (unsigned int)(v76 - (_DWORD)v9) >> 31;
      *v65 = v79;
      v81 = v65 + 1;
      if ( v4 > v62 + 1 )
      {
        if ( !v78 )
          goto LABEL_53;
        if ( v78 != 1 )
        {
          if ( v78 != 2 )
          {
            if ( v78 != 3 )
            {
              if ( v78 != 4 )
              {
                if ( v78 != 5 )
                {
                  if ( v78 != 6 )
                  {
                    v82 = *v75++;
                    v77 = v62 + 2;
                    v83 = v82 - v80;
                    v80 = (v82 - v80) >> 31;
                    *v81++ = v83 & 0xFFFFFFF;
                  }
                  v84 = *v75++;
                  ++v77;
                  v85 = v84 - v80;
                  v80 = (v84 - v80) >> 31;
                  *v81++ = v85 & 0xFFFFFFF;
                }
                v86 = *v75++;
                ++v77;
                v87 = v86 - v80;
                v80 = (v86 - v80) >> 31;
                *v81++ = v87 & 0xFFFFFFF;
              }
              v88 = *v75++;
              ++v77;
              v89 = v88 - v80;
              v80 = (v88 - v80) >> 31;
              *v81++ = v89 & 0xFFFFFFF;
            }
            v90 = *v75++;
            ++v77;
            v91 = v90 - v80;
            v80 = (v90 - v80) >> 31;
            *v81++ = v91 & 0xFFFFFFF;
          }
          v92 = *v75++;
          ++v77;
          v93 = v92 - v80;
          v80 = (v92 - v80) >> 31;
          *v81++ = v93 & 0xFFFFFFF;
        }
        v94 = *v75++;
        ++v77;
        v95 = v94 - v80;
        v96 = v95 & 0xFFFFFFF;
        v80 = v95 >> 31;
        *v81++ = v96;
        if ( v4 > v77 )
        {
LABEL_53:
          do
          {
            v97 = (unsigned int *)v81;
            v99 = v75 + 1;
            v98 = *v75;
            v75 += 8;
            v77 += 8;
            v81 += 8;
            *v97 = (v98 - v80) & 0xFFFFFFF;
            v100 = *v99 - ((v98 - v80) >> 31);
            v97[1] = v100 & 0xFFFFFFF;
            v101 = *(v75 - 6) - (v100 >> 31);
            *(v81 - 6) = v101 & 0xFFFFFFF;
            v102 = *(v75 - 5) - (v101 >> 31);
            *(v81 - 5) = v102 & 0xFFFFFFF;
            v103 = *(v75 - 4) - (v102 >> 31);
            *(v81 - 4) = v103 & 0xFFFFFFF;
            v104 = *(v75 - 3) - (v103 >> 31);
            *(v81 - 3) = v104 & 0xFFFFFFF;
            v105 = *(v75 - 2) - (v104 >> 31);
            *(v81 - 2) = v105 & 0xFFFFFFF;
            v106 = *(v75 - 1) - (v105 >> 31);
            v80 = v106 >> 31;
            *(v81 - 1) = v106 & 0xFFFFFFF;
          }
          while ( v4 > v77 );
        }
      }
      s += v4 - v7;
    }
    if ( v113 > *a3 )
      memset(s, 0, 4 * (v113 - *a3));
    sub_29BBC(a3);
    return 0;
  }
  return result;
}

//----- (00030DC0) --------------------------------------------------------
int __fastcall sub_30DC0(int *a1, int a2, int *a3)
{
  int v6; // r5
  int v8; // r5
  int v9; // r5
  int v10; // r6
  int v11; // [sp+Ch] [bp-68h]
  int v12; // [sp+10h] [bp-64h] BYREF
  char v13; // [sp+14h] [bp-60h]
  int v14; // [sp+18h] [bp-5Ch]
  int v15; // [sp+1Ch] [bp-58h]
  int v16; // [sp+20h] [bp-54h] BYREF
  char v17; // [sp+24h] [bp-50h]
  int v18; // [sp+28h] [bp-4Ch]
  int v19; // [sp+2Ch] [bp-48h]
  int v20; // [sp+30h] [bp-44h] BYREF
  char v21; // [sp+34h] [bp-40h]
  _DWORD *v22; // [sp+3Ch] [bp-38h]
  int v23[4]; // [sp+40h] [bp-34h] BYREF
  int v24[4]; // [sp+50h] [bp-24h] BYREF
  int v25[5]; // [sp+60h] [bp-14h] BYREF

  if ( *(int *)a2 > 0 && (**(_DWORD **)(a2 + 12) & 1) == 0 )
    return -3;
  v6 = sub_33654(
         (int)&v12,
         (int)&v16,
         (int)&v20,
         (int)v23,
         (int)v24,
         (int)v25,
         0,
         v11,
         v12,
         v13,
         v14,
         v15,
         v16,
         v17,
         v18,
         v19,
         v20,
         v21);
  if ( v6 )
    return v6;
  v8 = sub_2A25C((int *)a2, &v12);
  if ( !v8 )
  {
    v8 = sub_2C470(a1, (int *)a2, &v16);
    if ( !v8 )
    {
      v8 = sub_2A25C(&v12, &v20);
      if ( !v8 )
      {
        v8 = sub_2A25C(&v16, v23);
        if ( !v8 )
        {
          sub_2E630((int)v25, 1);
          v9 = v20;
          while ( v9 <= 0 )
          {
LABEL_21:
            while ( v23[0] > 0 && (*(_DWORD *)v23[3] & 1) == 0 )
            {
              v8 = sub_2A350(v23, v23);
              if ( !v8 && (v25[0] <= 0 || (*(_DWORD *)v25[3] & 1) == 0 || (v8 = sub_2E764(v25, &v12, v25)) == 0) )
              {
                v8 = sub_2A350(v25, v25);
                if ( !v8 )
                  continue;
              }
              goto LABEL_6;
            }
            if ( sub_29E00(&v20, v23) == -1 )
            {
              v8 = sub_2E764(v23, &v20, v23);
              if ( v8 )
                goto LABEL_6;
              v8 = sub_2E764(v25, v24, v25);
              if ( v8 )
                goto LABEL_6;
            }
            else
            {
              v8 = sub_2E764(&v20, v23, &v20);
              if ( v8 )
                goto LABEL_6;
              v8 = sub_2E764(v24, v25, v24);
              if ( v8 )
                goto LABEL_6;
            }
            v9 = v20;
            if ( !v20 )
            {
              if ( sub_29E48((int)v23, 1u) )
              {
                v8 = -3;
              }
              else
              {
                v10 = a1[2];
                while ( v25[2] == 1 )
                {
                  v8 = sub_29934(v25, (int *)a2, v25);
                  if ( v8 )
                    goto LABEL_6;
                }
                v8 = 0;
                sub_2AAD4(v25, a3);
                a3[2] = v10;
              }
              goto LABEL_6;
            }
          }
          while ( 1 )
          {
            if ( (*v22 & 1) != 0 )
              goto LABEL_21;
            v8 = sub_2A350(&v20, &v20);
            if ( v8 )
              break;
            if ( v24[0] > 0 && (*(_DWORD *)v24[3] & 1) != 0 )
            {
              v8 = sub_2E764(v24, &v12, v24);
              if ( v8 )
                break;
            }
            v8 = sub_2A350(v24, v24);
            if ( v8 )
              break;
            if ( v20 <= 0 )
              goto LABEL_21;
          }
        }
      }
    }
  }
LABEL_6:
  sub_29DB8((int)&v12, &v16, &v20, v23, v24, v25, 0);
  return v8;
}
// 30E18: variable 'v11' is possibly undefined

//----- (000310B4) --------------------------------------------------------
int __fastcall sub_310B4(int *a1, int *a2, int a3)
{
  int v3; // r1
  int v4; // r11
  int v5; // r1
  int *v6; // r7
  int v7; // r6
  int *v8; // r2
  int v9; // r9
  int v10; // r10
  _DWORD *v11; // r3
  int v12; // lr
  int v13; // r4
  int v14; // r8
  char *v15; // r0
  int v16; // r7
  int v17; // r9
  int v18; // r10
  int *v19; // lr
  int v20; // r4
  int v21; // r5
  int v22; // r2
  int v23; // r7
  int v24; // r9
  int v25; // r10
  int v26; // r4
  int v27; // r5
  int v28; // r7
  int v29; // r5
  bool v30; // cc
  int v31; // r8
  int v32; // r7
  int v33; // r3
  int v34; // r5
  int v35; // r9
  int v36; // r8
  int v37; // lr
  int v38; // r7
  int v39; // r0
  int v40; // r8
  int v41; // r0
  int v42; // r7
  int v43; // r0
  int *v44; // r2
  int v45; // lr
  int v46; // t1
  _DWORD *v47; // r3
  int v48; // r10
  int v49; // t1
  int v50; // r5
  int v51; // t1
  int v52; // t1
  int v53; // t1
  int v54; // t1
  int v55; // t1
  int v56; // t1
  int v57; // r5
  int *v58; // r8
  int v59; // r10
  int v60; // r9
  int v61; // r6
  int v62; // r7
  _DWORD *v63; // r4
  _DWORD *v64; // r10
  int v65; // r8
  int v66; // r7
  int v67; // r5
  _DWORD *v68; // r9
  _DWORD *v69; // r0
  int v70; // r6
  int v71; // lr
  int v72; // r6
  __int64 *v73; // r11
  __int64 *v74; // r8
  int v75; // r7
  __int64 *v76; // r3
  int v77; // r1
  unsigned int *v78; // r2
  unsigned int v79; // r0
  __int64 v80; // r4
  unsigned int v81; // r12
  unsigned __int64 v82; // r8
  unsigned int v83; // r10
  __int64 v84; // r4
  unsigned int v85; // r0
  __int64 v86; // r8
  __int64 v87; // r8
  unsigned int v88; // r12
  unsigned __int64 v89; // r4
  unsigned int v90; // r0
  __int64 v91; // r8
  __int64 v92; // r8
  unsigned int v93; // r12
  unsigned __int64 v94; // r4
  unsigned int *v95; // r10
  __int64 v96; // r8
  unsigned __int64 v97; // r4
  __int64 *v98; // r8
  __int64 v99; // t1
  unsigned int v100; // r5
  unsigned int *v101; // r9
  int v102; // r10
  int v103; // r12
  __int64 v104; // r0
  __int64 v105; // t1
  __int64 v106; // r2
  __int64 v107; // t1
  __int64 v108; // r0
  __int64 v109; // t1
  __int64 v110; // r4
  __int64 v111; // t1
  __int64 v112; // r2
  __int64 v113; // t1
  __int64 v114; // r0
  __int64 v115; // t1
  int v116; // r11
  int v117; // r10
  _QWORD *v118; // r0
  unsigned int v119; // r1
  unsigned int *v120; // r6
  _QWORD *v121; // lr
  _QWORD *v122; // r4
  unsigned int v123; // r12
  unsigned int v124; // r6
  _QWORD *v125; // r5
  unsigned __int64 v126; // r2
  unsigned int v127; // r12
  _QWORD *v128; // r1
  __int64 v129; // r2
  __int64 v130; // r2
  unsigned int v131; // r6
  unsigned int v132; // lr
  unsigned int v133; // r0
  unsigned int v134; // t1
  int v135; // r7
  int v136; // r5
  unsigned int *v137; // r10
  __int64 *v138; // r3
  unsigned int v139; // r9
  _DWORD *v140; // r10
  unsigned int v141; // t1
  int v142; // r1
  __int64 *v143; // r3
  __int64 v144; // t1
  int v145; // r0
  unsigned int v146; // r6
  unsigned int v147; // t1
  __int64 v148; // t1
  unsigned int v149; // r0
  unsigned int v150; // t1
  __int64 v151; // t1
  int v152; // r8
  int v153; // r11
  _QWORD *v154; // r2
  unsigned int v155; // r4
  _DWORD *v156; // r7
  unsigned int v157; // r12
  _QWORD *v158; // lr
  __int64 v159; // r4
  _QWORD *v160; // r6
  int v161; // r5
  int *v162; // r7
  int *v163; // r4
  int v164; // t1
  int result; // r0
  __int64 v166; // r2
  __int64 v167; // t1
  unsigned int v168; // r9
  unsigned int v169; // t1
  __int64 v170; // t1
  unsigned int *v172; // [sp+4h] [bp-1038h]
  int v174; // [sp+14h] [bp-1028h]
  __int64 *v175; // [sp+18h] [bp-1024h]
  int v176; // [sp+1Ch] [bp-1020h]
  int *s; // [sp+20h] [bp-101Ch]
  int v178; // [sp+24h] [bp-1018h]
  int v180; // [sp+2Ch] [bp-1010h]
  int v181; // [sp+30h] [bp-100Ch]
  int v182; // [sp+34h] [bp-1008h]
  _DWORD v183[16]; // [sp+38h] [bp-1004h] BYREF
  _DWORD v184[16]; // [sp+78h] [bp-FC4h] BYREF
  _BYTE v185[64]; // [sp+B8h] [bp-F84h] BYREF
  char v186; // [sp+F8h] [bp-F44h] BYREF
  char v187[32]; // [sp+100h] [bp-F3Ch] BYREF
  char v188[32]; // [sp+120h] [bp-F1Ch] BYREF
  int v189; // [sp+140h] [bp-EFCh] BYREF
  int v190; // [sp+160h] [bp-EDCh] BYREF

  v3 = *a2;
  v181 = *a1;
  v178 = v3 + 1;
  v176 = v3 + 1;
  if ( a1[1] < v3 + 1 )
  {
    result = sub_2BA48((int)a1, v3 + 1);
    if ( result )
      return result;
    v5 = *a1;
    v6 = (int *)a1[3];
    v4 = *a2;
    v178 = *a2 + 1;
    v176 = v178;
    s = v6;
    if ( *a1 > 0 )
      goto LABEL_3;
LABEL_80:
    v69 = v183;
    v5 = 0;
    goto LABEL_28;
  }
  v4 = v3;
  v5 = *a1;
  v6 = (int *)a1[3];
  s = v6;
  if ( v181 <= 0 )
    goto LABEL_80;
LABEL_3:
  v7 = v5 - 7;
  if ( v5 - 7 <= 1 )
  {
    v11 = v183;
    v8 = v6;
    v20 = 0;
  }
  else
  {
    v8 = v6 + 8;
    v9 = *v6;
    v10 = v6[2];
    v11 = v184;
    __pld(v187);
    __pld(v188);
    v12 = v6[1];
    v13 = v6[3];
    v14 = v6[4];
    v15 = v185;
    v183[0] = v9;
    v16 = v6[5];
    v17 = *(v8 - 2);
    v183[4] = v10;
    v18 = *(v8 - 1);
    v183[2] = v12;
    v19 = v8 + 8;
    v183[6] = v13;
    v20 = 8;
    v183[8] = v14;
    v183[10] = v16;
    v183[12] = v17;
    v183[14] = v18;
    v183[1] = 0;
    v183[3] = 0;
    v183[5] = 0;
    v183[7] = 0;
    v183[9] = 0;
    v183[11] = 0;
    v183[13] = 0;
    v183[15] = 0;
    if ( v7 > 9 )
    {
      if ( (((unsigned int)(v5 - 9) >> 3) & 1) == 0 )
        goto LABEL_8;
      v21 = v8[2];
      v11 = v185;
      v22 = *v8;
      v23 = *(v19 - 5);
      v24 = *(v19 - 4);
      v184[2] = *(v19 - 7);
      v25 = *(v19 - 3);
      v26 = *(v19 - 2);
      v184[4] = v21;
      v27 = *(v19 - 1);
      v184[0] = v22;
      v8 = v19;
      v184[12] = v26;
      v19 += 8;
      __pld(&v189);
      v20 = 16;
      __pld(&v190);
      v184[1] = 0;
      v184[3] = 0;
      v184[5] = 0;
      v184[7] = 0;
      v184[9] = 0;
      v184[11] = 0;
      v184[13] = 0;
      v184[15] = 0;
      v184[6] = v23;
      v184[8] = v24;
      v184[10] = v25;
      v184[14] = v27;
      v15 = &v186;
      if ( v7 > 17 )
      {
LABEL_8:
        do
        {
          v8 = v19 + 8;
          v28 = *(v19 - 7);
          v29 = *(v19 - 6);
          v30 = v7 <= v20 + 17;
          *((_DWORD *)v15 - 16) = *(v19 - 8);
          v31 = *(v19 - 4);
          v20 += 16;
          *((_DWORD *)v15 - 14) = v28;
          *((_DWORD *)v15 - 12) = v29;
          *((_DWORD *)v15 - 8) = v31;
          v32 = *(v19 - 5);
          v33 = *v19;
          v34 = *(v19 - 3);
          v35 = v19[1];
          v36 = *(v19 - 2);
          v37 = *(v19 - 1);
          *((_DWORD *)v15 - 10) = v32;
          __pld(v15 + 136);
          *((_DWORD *)v15 - 4) = v36;
          *((_DWORD *)v15 - 2) = v37;
          v19 = v8 + 8;
          __pld(v15 + 168);
          *((_DWORD *)v15 - 15) = 0;
          *((_DWORD *)v15 - 13) = 0;
          *((_DWORD *)v15 - 11) = 0;
          *((_DWORD *)v15 - 9) = 0;
          *((_DWORD *)v15 - 7) = 0;
          *((_DWORD *)v15 - 5) = 0;
          *((_DWORD *)v15 - 3) = 0;
          *((_DWORD *)v15 - 1) = 0;
          __pld(v15 + 200);
          __pld(v15 + 232);
          *((_DWORD *)v15 - 6) = v34;
          *(_DWORD *)v15 = v33;
          v11 = v15 + 64;
          *((_DWORD *)v15 + 1) = 0;
          *((_DWORD *)v15 + 2) = v35;
          v38 = *(v8 - 5);
          v39 = *(v8 - 4);
          *(v11 - 12) = *(v8 - 6);
          *(v11 - 10) = v38;
          v40 = *(v8 - 3);
          *(v11 - 8) = v39;
          v41 = *(v8 - 2);
          v42 = *(v8 - 1);
          *(v11 - 13) = 0;
          *(v11 - 11) = 0;
          *(v11 - 4) = v41;
          v15 = (char *)(v11 + 16);
          *(v11 - 9) = 0;
          *(v11 - 7) = 0;
          *(v11 - 5) = 0;
          *(v11 - 3) = 0;
          *(v11 - 1) = 0;
          *(v11 - 6) = v40;
          *(v11 - 2) = v42;
        }
        while ( !v30 );
      }
    }
  }
  v43 = v20 + 1;
  v46 = *v8;
  v44 = v8 + 1;
  v45 = v46;
  *v11 = v46;
  v47 = v11 + 2;
  v48 = (~v20 + v5) & 7;
  *(v47 - 1) = 0;
  if ( v5 > v20 + 1 )
  {
    if ( !v48 )
      goto LABEL_86;
    if ( v48 != 1 )
    {
      if ( v48 != 2 )
      {
        if ( v48 != 3 )
        {
          if ( v48 != 4 )
          {
            if ( v48 != 5 )
            {
              if ( v48 != 6 )
              {
                v49 = *v44++;
                v45 = v49;
                v43 = v20 + 2;
              }
              ++v43;
              v51 = *v44++;
              v50 = v51;
              if ( v48 != 6 )
              {
                *v47 = v45;
                v47 += 2;
                *(v47 - 1) = 0;
              }
              *v47 = v50;
              v47 += 2;
              *(v47 - 1) = 0;
            }
            v52 = *v44++;
            ++v43;
            *v47 = v52;
            v47 += 2;
            *(v47 - 1) = 0;
          }
          v53 = *v44++;
          ++v43;
          *v47 = v53;
          v47 += 2;
          *(v47 - 1) = 0;
        }
        v54 = *v44++;
        ++v43;
        *v47 = v54;
        v47 += 2;
        *(v47 - 1) = 0;
      }
      v55 = *v44++;
      ++v43;
      *v47 = v55;
      v47 += 2;
      *(v47 - 1) = 0;
    }
    ++v43;
    v56 = *v44++;
    *v47 = v56;
    v47 += 2;
    *(v47 - 1) = 0;
    if ( v5 > v43 )
    {
LABEL_86:
      do
      {
        v57 = v44[3];
        v58 = v44 + 1;
        v59 = *v44;
        v60 = v44[2];
        v44 += 8;
        v61 = *(v44 - 3);
        v43 += 8;
        v62 = *v58;
        *v47 = v59;
        v63 = v47 + 12;
        v47[1] = 0;
        v64 = v47 + 10;
        v47[2] = v62;
        v65 = *(v44 - 4);
        v66 = *(v44 - 2);
        v47[3] = 0;
        v47[6] = v57;
        v67 = *(v44 - 1);
        v47[4] = v60;
        v68 = v47 + 14;
        v47[5] = 0;
        v47 += 16;
        *(v47 - 9) = 0;
        *(v47 - 8) = v65;
        *(v64 - 1) = 0;
        *(v63 - 2) = v61;
        *(v63 - 1) = 0;
        *(v68 - 2) = v66;
        *(v68 - 1) = 0;
        *(v47 - 2) = v67;
        *(v47 - 1) = 0;
      }
      while ( v5 > v43 );
    }
  }
  v69 = &v183[2 * v5];
LABEL_28:
  v70 = 2 * v4 + 1;
  v180 = v70;
  if ( v5 < v70 )
    memset(v69, 0, 8 * (v70 - v5));
  if ( v4 <= 0 )
  {
    v137 = v183;
    v135 = 1;
    v182 = 2 * v4;
    v136 = 8;
  }
  else
  {
    v71 = v4 - 7;
    v72 = v4;
    v182 = 2 * v4;
    v73 = (__int64 *)v183;
    v172 = (unsigned int *)a2[3];
    do
    {
      v74 = v73;
      v75 = (*(_DWORD *)v73 * a3) & 0xFFFFFFF;
      if ( v71 <= 1 )
      {
        v95 = v172;
        v77 = 0;
      }
      else
      {
        v76 = v73 + 8;
        v77 = 0;
        v78 = v172 + 8;
        do
        {
          v30 = v71 <= v77 + 9;
          v79 = *(v78 - 7);
          v77 += 8;
          v80 = *(v76 - 7);
          v81 = *(v78 - 6);
          v82 = (unsigned int)v75 * (unsigned __int64)*(v78 - 8) + *(v76 - 8);
          v83 = *(v78 - 3);
          __pld(v76 + 9);
          __pld(v76 + 13);
          v84 = (unsigned int)v75 * (unsigned __int64)v79 + v80;
          v85 = *(v78 - 5);
          *(v76 - 8) = v82;
          v86 = *(v76 - 6);
          *(v76 - 7) = v84;
          v87 = (unsigned int)v75 * (unsigned __int64)v81 + v86;
          v88 = *(v78 - 4);
          v89 = (unsigned int)v75 * (unsigned __int64)v85 + *(v76 - 5);
          v90 = *(v78 - 2);
          *(v76 - 6) = v87;
          v91 = *(v76 - 4);
          *(v76 - 5) = v89;
          v92 = (unsigned int)v75 * (unsigned __int64)v88 + v91;
          v93 = *(v78 - 1);
          v94 = (unsigned int)v75 * (unsigned __int64)v83 + *(v76 - 3);
          v95 = v78;
          v78 += 8;
          *(v76 - 4) = v92;
          v96 = *(v76 - 2);
          *(v76 - 3) = v94;
          v97 = (unsigned int)v75 * (unsigned __int64)v93 + *(v76 - 1);
          *(v76 - 2) = (unsigned int)v75 * (unsigned __int64)v90 + v96;
          v74 = v76;
          v76 += 8;
          *(v76 - 9) = v97;
        }
        while ( !v30 );
      }
      v99 = *v74;
      v98 = v74 + 1;
      v101 = v95 + 1;
      v100 = *v95;
      v102 = v77 + 1;
      v103 = (~v77 + v72) & 7;
      *(v98 - 1) = (unsigned int)v75 * (unsigned __int64)v100 + v99;
      if ( v72 > v77 + 1 )
      {
        if ( !v103 )
          goto LABEL_51;
        if ( v103 != 1 )
        {
          if ( v103 != 2 )
          {
            if ( v103 != 3 )
            {
              if ( v103 != 4 )
              {
                if ( v103 != 5 )
                {
                  if ( v103 != 6 )
                  {
                    v167 = *v98++;
                    v166 = v167;
                    v102 = v77 + 2;
                    LODWORD(v167) = *v101++;
                    *(v98 - 1) = (unsigned int)v75 * (unsigned __int64)(unsigned int)v167 + v166;
                  }
                  v105 = *v98++;
                  v104 = v105;
                  ++v102;
                  LODWORD(v105) = *v101++;
                  *(v98 - 1) = (unsigned int)v75 * (unsigned __int64)(unsigned int)v105 + v104;
                }
                v107 = *v98++;
                v106 = v107;
                ++v102;
                LODWORD(v107) = *v101++;
                *(v98 - 1) = (unsigned int)v75 * (unsigned __int64)(unsigned int)v107 + v106;
              }
              v109 = *v98++;
              v108 = v109;
              ++v102;
              LODWORD(v109) = *v101++;
              *(v98 - 1) = (unsigned int)v75 * (unsigned __int64)(unsigned int)v109 + v108;
            }
            v111 = *v98++;
            v110 = v111;
            ++v102;
            LODWORD(v111) = *v101++;
            *(v98 - 1) = (unsigned int)v75 * (unsigned __int64)(unsigned int)v111 + v110;
          }
          v113 = *v98++;
          v112 = v113;
          ++v102;
          LODWORD(v113) = *v101++;
          *(v98 - 1) = (unsigned int)v75 * (unsigned __int64)(unsigned int)v113 + v112;
        }
        v115 = *v98++;
        v114 = v115;
        ++v102;
        LODWORD(v115) = *v101++;
        *(v98 - 1) = (unsigned int)v75 * (unsigned __int64)(unsigned int)v115 + v114;
        if ( v72 > v102 )
        {
LABEL_51:
          v175 = v73;
          v116 = v102;
          v117 = v72;
          v174 = v71;
          do
          {
            v118 = v98 + 4;
            v120 = v101 + 1;
            v119 = *v101;
            v121 = v98 + 3;
            v122 = v98 + 5;
            v101 += 8;
            v116 += 8;
            v123 = *v120;
            v124 = *(v101 - 6);
            *v98 += (unsigned int)v75 * (unsigned __int64)v119;
            v125 = v98 + 6;
            v126 = (unsigned int)v75 * (unsigned __int64)v123 + v98[1];
            v127 = *(v101 - 4);
            v98[1] = v126;
            v128 = v98 + 7;
            v129 = v98[2];
            v98 += 8;
            v130 = (unsigned int)v75 * (unsigned __int64)v124 + v129;
            v131 = *(v101 - 2);
            *(v121 - 1) = v130;
            v132 = *(v101 - 3);
            *(v118 - 1) += (unsigned int)v75 * (unsigned __int64)*(v101 - 5);
            v133 = *(v101 - 1);
            *(v122 - 1) += (unsigned int)v75 * (unsigned __int64)v127;
            *(v125 - 1) += (unsigned int)v75 * (unsigned __int64)v132;
            *(v128 - 1) += (unsigned int)v75 * (unsigned __int64)v131;
            *(v98 - 1) += (unsigned int)v75 * (unsigned __int64)v133;
          }
          while ( v117 > v116 );
          v71 = v174;
          v72 = v117;
          v73 = v175;
        }
      }
      __pld(v73 + 3);
      v134 = *(_DWORD *)v73++;
      *v73 += __PAIR64__(*((_DWORD *)v73 - 1), v134) >> 28;
    }
    while ( &v183[v182] != (_DWORD *)v73 );
    v135 = v178;
    v136 = v182 * 4 + 8;
    v137 = &v183[v182];
  }
  v138 = (__int64 *)((char *)v183 + v136);
  if ( v180 < v135 )
    goto LABEL_67;
  v141 = *v137;
  v140 = v137 + 2;
  v139 = v141;
  v142 = v135 + 1;
  v144 = *v138;
  v143 = v138 + 1;
  v145 = (v180 - v135) & 3;
  *(v143 - 1) = v144 + (__PAIR64__(*(v140 - 1), v139) >> 28);
  if ( v135 + 1 > v180 )
    goto LABEL_67;
  if ( v145 )
  {
    if ( v145 != 1 )
    {
      if ( v145 != 2 )
      {
        v169 = *v140;
        v140 += 2;
        v168 = v169;
        v142 = v135 + 2;
        v170 = *v143++;
        *(v143 - 1) = v170 + (__PAIR64__(*(v140 - 1), v168) >> 28);
      }
      v147 = *v140;
      v140 += 2;
      v146 = v147;
      ++v142;
      v148 = *v143++;
      *(v143 - 1) = v148 + (__PAIR64__(*(v140 - 1), v146) >> 28);
    }
    v150 = *v140;
    v140 += 2;
    v149 = v150;
    v151 = *v143++;
    *(v143 - 1) = v151 + (__PAIR64__(*(v140 - 1), v149) >> 28);
    if ( v142 + 1 > v180 )
      goto LABEL_67;
    v152 = v180;
    v153 = v142 + 1;
  }
  else
  {
    v152 = v180;
    v153 = v135 + 1;
  }
  do
  {
    v154 = v140 + 2;
    v155 = *v140;
    v156 = v140 + 6;
    v140 += 8;
    v153 += 4;
    v157 = *((_DWORD *)v154 - 1);
    v158 = v143 + 1;
    LODWORD(v159) = (v155 >> 28) | (16 * v157);
    HIDWORD(v159) = v157 >> 28;
    *v143 += v159;
    v160 = v143 + 3;
    v143 += 4;
    *v158 += *v154 >> 28;
    *(v160 - 1) += *((_QWORD *)v156 - 1) >> 28;
    *(v143 - 1) += *((_QWORD *)v140 - 1) >> 28;
  }
  while ( v153 <= v152 );
LABEL_67:
  v161 = 0;
  v162 = &v183[v182];
  if ( v178 > 0 )
  {
    v163 = s;
    do
    {
      v164 = *v162;
      v162 += 2;
      ++v161;
      *v163++ = v164 & 0xFFFFFFF;
    }
    while ( *a2 + 1 > v161 );
    v176 = *a2 + 1;
    s = v163;
  }
  if ( v181 > v161 )
  {
    memset(s, 0, 4 * (v181 - v161));
    v176 = *a2 + 1;
  }
  *a1 = v176;
  sub_29BBC(a1);
  if ( sub_29E8C(a1, a2) == -1 )
    return 0;
  else
    return sub_307E4(a1, a2, a1);
}

//----- (00031AE4) --------------------------------------------------------
int __fastcall sub_31AE4(int *a1, _DWORD *a2, int *a3, int a4)
{
  int v7; // r1
  unsigned __int64 v8; // r8
  int v9; // lr
  int *v10; // r10
  unsigned int *v11; // r3
  int v12; // r11
  unsigned int v13; // lr
  unsigned int v14; // r4
  unsigned int v15; // r2
  unsigned __int64 v16; // r0
  unsigned int v17; // r5
  unsigned __int64 v18; // r0
  _DWORD *v19; // lr
  unsigned int *v20; // r7
  int v21; // r12
  unsigned int v22; // r1
  unsigned int v23; // r12
  unsigned int v24; // r6
  unsigned int v25; // r2
  unsigned __int64 v26; // r0
  unsigned int v27; // r5
  unsigned int v28; // r4
  unsigned __int64 v29; // r0
  unsigned int v30; // r0
  int v31; // r11
  unsigned int v32; // r1
  unsigned int v33; // r12
  unsigned __int64 v34; // r4
  unsigned int v35; // r2
  unsigned int v36; // r6
  unsigned __int64 v37; // r4
  unsigned __int64 v38; // r0
  unsigned int v39; // r6
  unsigned __int64 v40; // r0
  int *v41; // r10
  unsigned int v42; // lr
  unsigned int v43; // t1
  int v44; // r1
  unsigned int v45; // r0
  unsigned int *v46; // r3
  unsigned int v47; // t1
  int v48; // r2
  bool v49; // zf
  int v50; // t1
  unsigned int v51; // t1
  unsigned int v52; // r4
  unsigned int v53; // t1
  unsigned int v54; // r5
  unsigned int v55; // t1
  unsigned int v56; // r7
  unsigned int v57; // t1
  unsigned int v58; // t1
  unsigned int v59; // r12
  unsigned int v60; // t1
  unsigned int v61; // t1
  unsigned int v62; // r6
  unsigned int v63; // t1
  unsigned int v64; // t1
  unsigned int v65; // r4
  unsigned int v66; // t1
  unsigned int v67; // t1
  unsigned int v68; // r7
  unsigned int v69; // t1
  unsigned int v70; // t1
  int v71; // r6
  int v72; // r2
  unsigned int *v73; // r12
  unsigned int *v74; // r0
  unsigned int v75; // r4
  int v76; // r11
  int v77; // r5
  char *v78; // r10
  void *v79; // r0
  int result; // r0
  int v81; // [sp+10h] [bp-82Ch]
  int v82; // [sp+14h] [bp-828h]
  _DWORD *v83; // [sp+18h] [bp-824h]
  int v84; // [sp+1Ch] [bp-820h]
  int v85; // [sp+20h] [bp-81Ch]
  int v86; // [sp+24h] [bp-818h]
  int v87; // [sp+28h] [bp-814h]
  int v88; // [sp+2Ch] [bp-810h]
  int v89; // [sp+30h] [bp-80Ch]
  _BYTE src[2052]; // [sp+38h] [bp-804h] BYREF

  if ( a3[1] >= a4 || (result = sub_2BA48((int)a3, a4)) == 0 )
  {
    v85 = *a1;
    v7 = *a1 + *a2;
    if ( v7 >= a4 )
      v7 = a4;
    v84 = v7;
    if ( v7 > 0 )
    {
      v88 = *a2 - 1;
      v8 = 0;
      v87 = a2[3];
      v86 = a1[3];
      v83 = src;
      v82 = 0;
      do
      {
        v9 = v88;
        if ( v82 < v88 )
          v9 = v82;
        v10 = (int *)(v86 + 4 * (v82 - v9));
        v11 = (unsigned int *)(v87 + 4 * v9);
        if ( v9 + 1 >= v85 - (v82 - v9) )
          v12 = v85 - (v82 - v9);
        else
          v12 = v9 + 1;
        if ( v12 > 0 )
        {
          v81 = v12 - 7;
          if ( v12 - 7 <= 1 )
          {
            v21 = 0;
          }
          else
          {
            v11 -= 8;
            v13 = *v10;
            v14 = v11[8];
            v15 = v10[2];
            v16 = v11[7] * (unsigned __int64)(unsigned int)v10[1];
            v17 = v11[6];
            __pld(v10 + 23);
            v10 += 8;
            v18 = v15 * (unsigned __int64)v17 + v14 * (unsigned __int64)v13 + v16;
            v19 = v10 + 8;
            v20 = v11 - 8;
            v21 = 8;
            v8 += v11[1] * (unsigned __int64)(unsigned int)*(v10 - 1)
                + v11[2] * (unsigned __int64)(unsigned int)*(v10 - 2)
                + v11[3] * (unsigned __int64)(unsigned int)*(v10 - 3)
                + (unsigned int)*(v10 - 4) * (unsigned __int64)v11[4]
                + (unsigned int)*(v10 - 5) * (unsigned __int64)v11[5]
                + v18;
            if ( v81 > 9 )
            {
              if ( (((unsigned int)(v12 - 9) >> 3) & 1) == 0 )
                goto LABEL_16;
              v11 -= 8;
              v22 = v20[7];
              v20 -= 8;
              v23 = *v10;
              v24 = v20[16];
              v25 = v20[14];
              v26 = v22 * (unsigned __int64)(unsigned int)v10[1];
              v27 = v10[2];
              v28 = v10[3];
              __pld(v10 + 23);
              v10 += 8;
              v19 += 8;
              v29 = v24 * (unsigned __int64)v23 + v26;
              v21 = 16;
              v8 += v20[9] * (unsigned __int64)(unsigned int)*(v19 - 9)
                  + v20[10] * (unsigned __int64)(unsigned int)*(v19 - 10)
                  + v20[11] * (unsigned __int64)(unsigned int)*(v19 - 11)
                  + (unsigned int)*(v19 - 12) * (unsigned __int64)v20[12]
                  + v28 * (unsigned __int64)v20[13]
                  + v27 * (unsigned __int64)v25
                  + v29;
              if ( v81 > 17 )
              {
LABEL_16:
                v89 = v12;
                do
                {
                  v10 = v19 + 8;
                  v11 = v20 - 8;
                  v30 = *(v20 - 1);
                  v31 = v21 + 8;
                  v32 = v19[1];
                  v33 = *(v19 - 8);
                  v34 = v20[7] * (unsigned __int64)(unsigned int)*(v19 - 7);
                  v35 = v20[8];
                  v36 = *v19;
                  __pld(v19 + 15);
                  __pld(v19 + 23);
                  v37 = v20[1] * (unsigned __int64)(unsigned int)*(v19 - 1)
                      + v20[2] * (unsigned __int64)(unsigned int)*(v19 - 2)
                      + v20[3] * (unsigned __int64)(unsigned int)*(v19 - 3)
                      + (unsigned int)*(v19 - 4) * (unsigned __int64)v20[4]
                      + (unsigned int)*(v19 - 5) * (unsigned __int64)v20[5]
                      + (unsigned int)*(v19 - 6) * (unsigned __int64)v20[6]
                      + v35 * (unsigned __int64)v33
                      + v34;
                  v21 = v31 + 8;
                  v38 = *(v20 - 6) * (unsigned __int64)(unsigned int)v19[6]
                      + *(v20 - 5) * (unsigned __int64)(unsigned int)v19[5]
                      + (unsigned int)v19[4] * (unsigned __int64)*(v20 - 4)
                      + (unsigned int)v19[3] * (unsigned __int64)*(v20 - 3)
                      + (unsigned int)v19[2] * (unsigned __int64)*(v20 - 2)
                      + *v20 * (unsigned __int64)v36
                      + v30 * (unsigned __int64)v32;
                  v39 = *(v20 - 7);
                  v20 -= 16;
                  v40 = v39 * (unsigned __int64)(unsigned int)v19[7] + v38;
                  v19 += 16;
                  v8 += v37 + v40;
                }
                while ( v81 > v31 + 9 );
                v12 = v89;
              }
            }
          }
          v43 = *v10;
          v41 = v10 + 1;
          v42 = v43;
          v44 = v21 + 1;
          v47 = *v11;
          v46 = v11 - 1;
          v45 = v47;
          v48 = (~v21 + v12) & 7;
          v8 += v47 * (unsigned __int64)v42;
          if ( v12 > v21 + 1 )
          {
            if ( !v48 )
              goto LABEL_36;
            if ( v48 != 1 )
            {
              if ( v48 != 2 )
              {
                if ( v48 != 3 )
                {
                  if ( v48 != 4 )
                  {
                    if ( v48 != 5 )
                    {
                      v49 = v48 == 6;
                      if ( v48 != 6 )
                      {
                        v50 = *v41++;
                        v48 = v50;
                        v44 = v21 + 2;
                        v51 = *v46--;
                        v45 = v51;
                      }
                      ++v44;
                      v53 = *v41++;
                      v52 = v53;
                      v55 = *v46--;
                      v54 = v55;
                      if ( !v49 )
                        v8 += v45 * (unsigned __int64)(unsigned int)v48;
                      v8 += v54 * (unsigned __int64)v52;
                    }
                    v57 = *v41++;
                    v56 = v57;
                    ++v44;
                    v58 = *v46--;
                    v8 += v58 * (unsigned __int64)v56;
                  }
                  v60 = *v41++;
                  v59 = v60;
                  ++v44;
                  v61 = *v46--;
                  v8 += v61 * (unsigned __int64)v59;
                }
                v63 = *v41++;
                v62 = v63;
                ++v44;
                v64 = *v46--;
                v8 += v64 * (unsigned __int64)v62;
              }
              v66 = *v41++;
              v65 = v66;
              ++v44;
              v67 = *v46--;
              v8 += v67 * (unsigned __int64)v65;
            }
            v69 = *v41++;
            v68 = v69;
            ++v44;
            v70 = *v46--;
            v8 += v70 * (unsigned __int64)v68;
            if ( v12 > v44 )
            {
LABEL_36:
              v71 = v44;
              do
              {
                v73 = (unsigned int *)(v41 + 1);
                v72 = *v41;
                v41 += 8;
                v74 = v46 - 1;
                v75 = *v46;
                v46 -= 8;
                v71 += 8;
                v8 += v46[1] * (unsigned __int64)(unsigned int)*(v41 - 1)
                    + v46[2] * (unsigned __int64)(unsigned int)*(v41 - 2)
                    + v46[3] * (unsigned __int64)(unsigned int)*(v41 - 3)
                    + v46[4] * (unsigned __int64)(unsigned int)*(v41 - 4)
                    + v46[5] * (unsigned __int64)(unsigned int)*(v41 - 5)
                    + v46[6] * (unsigned __int64)(unsigned int)*(v41 - 6)
                    + *v74 * (unsigned __int64)*v73
                    + v75 * (unsigned __int64)(unsigned int)v72;
              }
              while ( v12 > v71 );
            }
          }
        }
        v49 = v84 == v82 + 1;
        *v83 = v8 & 0xFFFFFFF;
        ++v82;
        v8 >>= 28;
        ++v83;
      }
      while ( !v49 );
    }
    v76 = v84 + 1;
    v77 = *a3;
    v78 = (char *)a3[3];
    if ( v84 + 1 <= 0 )
      v76 = 0;
    *a3 = v84;
    if ( v84 + 1 > 0 )
    {
      v79 = v78;
      v78 += 4 * v76;
      memcpy(v79, src, 4 * v76);
    }
    if ( v77 > v76 )
      memset(v78, 0, 4 * (v77 - v76));
    sub_29BBC(a3);
    return 0;
  }
  return result;
}

//----- (00032018) --------------------------------------------------------
int __fastcall sub_32018(int *a1, int *a2)
{
  int v3; // r5
  int v4; // r6
  int v5; // r10
  int v6; // r5
  int v7; // r0
  int v8; // r6
  int *v9; // r2
  unsigned int *v10; // r3
  int v11; // r11
  int v12; // lr
  unsigned int v13; // r8
  bool v14; // vf
  unsigned int v15; // r9
  unsigned int v16; // r7
  unsigned __int64 v17; // r0
  unsigned int v18; // r5
  _DWORD *v19; // r6
  unsigned int *v20; // r12
  int v21; // lr
  unsigned __int64 v22; // r0
  unsigned int v23; // r1
  unsigned int v24; // r9
  unsigned int v25; // r4
  unsigned int v26; // r5
  unsigned __int64 v27; // r0
  unsigned int v28; // r7
  unsigned int v29; // lr
  unsigned int v30; // r8
  unsigned __int64 v31; // r0
  unsigned __int64 v32; // r10
  unsigned int v33; // r0
  unsigned int v34; // r1
  unsigned int v35; // r7
  unsigned __int64 v36; // r4
  unsigned int v37; // r8
  unsigned int v38; // r9
  unsigned int v39; // lr
  unsigned __int64 v40; // r0
  unsigned int v41; // lr
  unsigned __int64 v42; // r4
  unsigned int v43; // r7
  unsigned int v44; // r9
  unsigned __int64 v45; // r0
  unsigned __int64 v46; // r4
  unsigned __int64 v47; // r4
  unsigned int v48; // r1
  int *v49; // r2
  unsigned int v50; // t1
  int v51; // r12
  unsigned int *v52; // r3
  unsigned int v53; // t1
  bool v54; // cc
  int v55; // lr
  unsigned __int64 v56; // r4
  unsigned __int64 v57; // r0
  bool v58; // zf
  int v59; // t1
  int v60; // t1
  unsigned int v61; // r8
  unsigned int v62; // t1
  unsigned int v63; // t1
  unsigned int v64; // r5
  unsigned int v65; // t1
  unsigned int v66; // t1
  unsigned int v67; // r7
  unsigned int v68; // t1
  unsigned int v69; // t1
  unsigned int v70; // r8
  unsigned int v71; // t1
  unsigned int v72; // t1
  unsigned int v73; // r4
  unsigned int v74; // t1
  unsigned int v75; // t1
  unsigned int v76; // r6
  unsigned int v77; // t1
  unsigned int v78; // t1
  int v79; // r8
  unsigned int *v80; // lr
  int v81; // r6
  unsigned int *v82; // r9
  unsigned int v83; // lr
  unsigned __int64 v84; // r0
  int v85; // r10
  int v86; // r0
  int *v87; // r3
  int *v88; // r0
  int v89; // r5
  char *v90; // r2
  int *v91; // r1
  int v92; // r7
  int v93; // r5
  _BYTE *v94; // t2
  int v95; // lr
  int *v96; // r2
  int v97; // r1
  int *v98; // r2
  int v99; // r5
  int v100; // t1
  int v101; // r9
  int *v102; // r3
  bool v103; // zf
  int v104; // t1
  int v105; // r6
  int v106; // t1
  int v107; // t1
  int v108; // t1
  int v109; // t1
  int v110; // t1
  int v111; // t1
  int v112; // r11
  int v113; // r5
  int v114; // r12
  int v115; // r0
  int v116; // r11
  int v117; // r4
  int v118; // r8
  int v119; // r9
  int v120; // r5
  int *v121; // r11
  int v122; // r3
  int result; // r0
  __int64 v124; // [sp+0h] [bp-844h]
  unsigned __int64 v125; // [sp+8h] [bp-83Ch]
  int v126; // [sp+8h] [bp-83Ch]
  int v127; // [sp+10h] [bp-834h]
  int *v128; // [sp+14h] [bp-830h]
  _DWORD *v129; // [sp+18h] [bp-82Ch]
  int v130; // [sp+1Ch] [bp-828h]
  int v131; // [sp+20h] [bp-824h]
  int v132; // [sp+28h] [bp-81Ch]
  int v133; // [sp+2Ch] [bp-818h]
  int *s; // [sp+34h] [bp-810h]
  int v136; // [sp+38h] [bp-80Ch]
  int v137; // [sp+3Ch] [bp-808h]
  _DWORD v138[29]; // [sp+40h] [bp-804h] BYREF
  char v139[32]; // [sp+B4h] [bp-790h] BYREF
  _BYTE v140[32]; // [sp+D4h] [bp-770h] BYREF
  char v141; // [sp+F4h] [bp-750h] BYREF

  v3 = 2 * *a1;
  v131 = *a1;
  v128 = (int *)v3;
  if ( a2[1] < v3 )
  {
    result = sub_2BA48((int)a2, v3);
    if ( result )
      return result;
    v4 = v3;
    v131 = *a1;
    v137 = 2 * *a1;
  }
  else
  {
    v4 = 2 * *a1;
    v137 = v4;
  }
  v136 = *a2;
  s = (int *)a2[3];
  if ( v4 <= 0 )
  {
    v121 = 0;
    *a2 = v137;
    goto LABEL_74;
  }
  v5 = 0;
  v129 = v138;
  v130 = a1[3];
  v124 = 0;
  do
  {
    while ( 1 )
    {
      v6 = v131 - 1;
      if ( v131 - 1 >= v5 )
        v6 = v5;
      v7 = v6 + 1;
      v8 = v6 - (v5 - v6);
      if ( v6 + 1 >= v131 - (v5 - v6) )
        v7 = v131 - (v5 - v6);
      v9 = (int *)(v130 + 4 * (v5 - v6));
      v10 = (unsigned int *)(v130 + 4 * v6);
      if ( (v8 + 1) >> 1 >= v7 )
        v11 = v7;
      else
        v11 = (v8 + 1) >> 1;
      if ( v11 > 0 )
      {
        v12 = v11 - 7;
        v127 = v11 - 7;
        if ( v11 - 7 <= 1 )
        {
          v21 = 0;
          v22 = 0;
        }
        else
        {
          v10 -= 8;
          v13 = *v9;
          v14 = __OFSUB__(v12, 9);
          v58 = v12 == 9;
          v15 = v10[8];
          v16 = v10[6];
          v17 = (unsigned int)v9[1] * (unsigned __int64)v10[7];
          v18 = v9[2];
          __pld(v9 + 23);
          v9 += 8;
          v19 = v9 + 8;
          v20 = v10 - 8;
          v21 = 8;
          v22 = v10[1] * (unsigned __int64)(unsigned int)*(v9 - 1)
              + v10[2] * (unsigned __int64)(unsigned int)*(v9 - 2)
              + v10[3] * (unsigned __int64)(unsigned int)*(v9 - 3)
              + v10[4] * (unsigned __int64)(unsigned int)*(v9 - 4)
              + v10[5] * (unsigned __int64)(unsigned int)*(v9 - 5)
              + v16 * (unsigned __int64)v18
              + v15 * (unsigned __int64)v13
              + v17;
          v125 = v22;
          if ( !((v11 - 16 < 0) ^ v14 | v58) )
          {
            if ( (((unsigned int)(v11 - 9) >> 3) & 1) == 0 )
              goto LABEL_18;
            v10 -= 8;
            v23 = v20[7];
            v20 -= 8;
            v24 = *v9;
            v25 = v20[16];
            v26 = v9[2];
            v27 = (unsigned int)v9[1] * (unsigned __int64)v23;
            v28 = v20[14];
            v29 = v9[3];
            v30 = v20[13];
            __pld(v9 + 23);
            v9 += 8;
            v19 += 8;
            v31 = v30 * (unsigned __int64)v29 + v28 * (unsigned __int64)v26 + v25 * (unsigned __int64)v24 + v27;
            v21 = 16;
            v125 += v20[9] * (unsigned __int64)(unsigned int)*(v19 - 9)
                  + v20[10] * (unsigned __int64)(unsigned int)*(v19 - 10)
                  + v20[11] * (unsigned __int64)(unsigned int)*(v19 - 11)
                  + v20[12] * (unsigned __int64)(unsigned int)*(v19 - 12)
                  + v31;
            if ( v127 <= 17 )
            {
              v47 = v125;
            }
            else
            {
LABEL_18:
              v132 = v11;
              v133 = v5;
              v32 = v125;
              do
              {
                v10 = v20 - 8;
                v9 = v19 + 8;
                v33 = v19[1];
                v34 = *(v20 - 1);
                v35 = *(v19 - 8);
                v36 = (unsigned int)*(v19 - 7) * (unsigned __int64)v20[7];
                v37 = v20[8];
                v38 = *v19;
                v126 = v21 + 8;
                v39 = *v20;
                __pld(v19 + 15);
                __pld(v19 + 23);
                v40 = *(v20 - 4) * (unsigned __int64)(unsigned int)v19[4]
                    + *(v20 - 3) * (unsigned __int64)(unsigned int)v19[3]
                    + *(v20 - 2) * (unsigned __int64)(unsigned int)v19[2]
                    + v39 * (unsigned __int64)v38
                    + v33 * (unsigned __int64)v34;
                v41 = *(v19 - 1);
                v42 = v20[2] * (unsigned __int64)(unsigned int)*(v19 - 2)
                    + v20[3] * (unsigned __int64)(unsigned int)*(v19 - 3)
                    + v20[4] * (unsigned __int64)(unsigned int)*(v19 - 4)
                    + v20[5] * (unsigned __int64)(unsigned int)*(v19 - 5)
                    + v20[6] * (unsigned __int64)(unsigned int)*(v19 - 6)
                    + v37 * (unsigned __int64)v35
                    + v36;
                v43 = v19[7];
                v44 = *(v20 - 7);
                v45 = *(v20 - 6) * (unsigned __int64)(unsigned int)v19[6]
                    + *(v20 - 5) * (unsigned __int64)(unsigned int)v19[5]
                    + v40;
                v19 += 16;
                v46 = v20[1] * (unsigned __int64)v41 + v42;
                v20 -= 16;
                v21 = v126 + 8;
                v32 += v46 + v44 * (unsigned __int64)v43 + v45;
              }
              while ( v127 > v126 + 9 );
              v47 = v32;
              v5 = v133;
              v11 = v132;
            }
LABEL_21:
            v50 = *v9;
            v49 = v9 + 1;
            v48 = v50;
            v51 = v21 + 1;
            v53 = *v10;
            v52 = v10 - 1;
            v54 = v11 <= v21 + 1;
            v55 = (~v21 + v11) & 7;
            v56 = v48 * (unsigned __int64)v53 + v47;
            v57 = v56;
            if ( !v54 )
            {
              if ( !v55 )
                goto LABEL_38;
              if ( v55 != 1 )
              {
                if ( v55 != 2 )
                {
                  if ( v55 != 3 )
                  {
                    if ( v55 != 4 )
                    {
                      if ( v55 != 5 )
                      {
                        v58 = v55 == 6;
                        if ( v55 != 6 )
                        {
                          v59 = *v52--;
                          LODWORD(v56) = v59;
                          ++v51;
                          v60 = *v49++;
                          v55 = v60;
                        }
                        ++v51;
                        v62 = *v52--;
                        v61 = v62;
                        if ( !v58 )
                          v57 += (unsigned int)v55 * (unsigned __int64)(unsigned int)v56;
                        v63 = *v49++;
                        v57 += v63 * (unsigned __int64)v61;
                      }
                      v65 = *v52--;
                      v64 = v65;
                      ++v51;
                      v66 = *v49++;
                      v57 += v66 * (unsigned __int64)v64;
                    }
                    v68 = *v52--;
                    v67 = v68;
                    ++v51;
                    v69 = *v49++;
                    v57 += v69 * (unsigned __int64)v67;
                  }
                  v71 = *v52--;
                  v70 = v71;
                  ++v51;
                  v72 = *v49++;
                  v57 += v72 * (unsigned __int64)v70;
                }
                v74 = *v52--;
                v73 = v74;
                ++v51;
                v75 = *v49++;
                v57 += v75 * (unsigned __int64)v73;
              }
              v77 = *v52--;
              v76 = v77;
              ++v51;
              v78 = *v49++;
              v57 += v78 * (unsigned __int64)v76;
              if ( v11 > v51 )
              {
LABEL_38:
                v79 = v51;
                do
                {
                  v80 = v52;
                  v82 = (unsigned int *)(v49 + 1);
                  v81 = *v49;
                  v52 -= 8;
                  v49 += 8;
                  v79 += 8;
                  v57 += (unsigned int)*(v49 - 1) * (unsigned __int64)v52[1]
                       + (unsigned int)*(v49 - 2) * (unsigned __int64)v52[2]
                       + (unsigned int)*(v49 - 3) * (unsigned __int64)v52[3]
                       + (unsigned int)*(v49 - 4) * (unsigned __int64)v52[4]
                       + (unsigned int)*(v49 - 5) * (unsigned __int64)v52[5]
                       + (unsigned int)*(v49 - 6) * (unsigned __int64)v52[6]
                       + *v82 * (unsigned __int64)*(v80 - 1)
                       + (unsigned int)v81 * (unsigned __int64)*v80;
                }
                while ( v11 > v79 );
              }
            }
            v124 += 2 * v57;
            goto LABEL_41;
          }
        }
        v47 = v22;
        goto LABEL_21;
      }
LABEL_41:
      if ( (v5 & 1) != 0 )
        break;
      v83 = *(_DWORD *)(v130 + 4 * (v5++ >> 1));
      v84 = v83 * (unsigned __int64)v83 + v124;
      *v129 = v84 & 0xFFFFFFF;
      v124 = v84 >> 28;
      ++v129;
      if ( v128 == (int *)v5 )
        goto LABEL_43;
    }
    ++v5;
    v122 = v124 >> 28;
    HIDWORD(v124) >>= 28;
    *v129 = v124 & 0xFFFFFFF;
    LODWORD(v124) = v122;
    ++v129;
  }
  while ( v128 != (int *)v5 );
LABEL_43:
  v85 = (int)v128 - 7;
  *a2 = v137;
  if ( (int)v128 - 7 > 1 )
  {
    v88 = s;
    v89 = v138[0];
    __pld(v139);
    v90 = v140;
    v87 = v88 + 8;
    v91 = v88 + 16;
    *v88 = v89 & 0xFFFFFFF;
    v86 = 8;
    *(v87 - 7) = v138[1] & 0xFFFFFFF;
    *(v87 - 6) = v138[2] & 0xFFFFFFF;
    *(v87 - 5) = v138[3] & 0xFFFFFFF;
    *(v87 - 4) = v138[4] & 0xFFFFFFF;
    *(v87 - 3) = v138[5] & 0xFFFFFFF;
    *(v87 - 2) = v138[6] & 0xFFFFFFF;
    *(v87 - 1) = v138[7] & 0xFFFFFFF;
    if ( v85 > 9 )
    {
      if ( ((((unsigned int)v128 - 9) >> 3) & 1) == 0 )
        goto LABEL_49;
      v92 = v138[8];
      __pld(v140);
      v87 = v91;
      v86 = 16;
      v91 += 8;
      *(v91 - 16) = v92 & 0xFFFFFFF;
      *(v91 - 15) = v138[9] & 0xFFFFFFF;
      *(v91 - 14) = v138[10] & 0xFFFFFFF;
      *(v91 - 13) = v138[11] & 0xFFFFFFF;
      *(v91 - 12) = v138[12] & 0xFFFFFFF;
      *(v91 - 11) = v138[13] & 0xFFFFFFF;
      *(v91 - 10) = v138[14] & 0xFFFFFFF;
      v90 = &v141;
      *(v91 - 9) = v138[15] & 0xFFFFFFF;
      if ( v85 > 17 )
      {
LABEL_49:
        do
        {
          v93 = *((_DWORD *)v90 - 29);
          __pld(v90);
          v94 = v90 + 32;
          __pld(v90 + 32);
          v54 = v85 <= v86 + 17;
          v87 = v91 + 8;
          *(v91 - 8) = v93 & 0xFFFFFFF;
          v86 += 16;
          v95 = *((_DWORD *)v90 - 28);
          v90 += 64;
          *(v91 - 7) = v95 & 0xFFFFFFF;
          *(v91 - 6) = *((_DWORD *)v90 - 43) & 0xFFFFFFF;
          *(v91 - 5) = *((_DWORD *)v90 - 42) & 0xFFFFFFF;
          *(v91 - 4) = *((_DWORD *)v90 - 41) & 0xFFFFFFF;
          *(v91 - 3) = *((_DWORD *)v90 - 40) & 0xFFFFFFF;
          *(v91 - 2) = *((_DWORD *)v90 - 39) & 0xFFFFFFF;
          *(v91 - 1) = *((_DWORD *)v90 - 38) & 0xFFFFFFF;
          v91 += 16;
          *(v87 - 8) = *((_DWORD *)v94 - 29) & 0xFFFFFFF;
          *(v87 - 7) = *((_DWORD *)v94 - 28) & 0xFFFFFFF;
          *(v87 - 6) = *((_DWORD *)v94 - 27) & 0xFFFFFFF;
          *(v87 - 5) = *((_DWORD *)v94 - 26) & 0xFFFFFFF;
          *(v87 - 4) = *((_DWORD *)v94 - 25) & 0xFFFFFFF;
          *(v87 - 3) = *((_DWORD *)v94 - 24) & 0xFFFFFFF;
          *(v87 - 2) = *((_DWORD *)v94 - 23) & 0xFFFFFFF;
          *(v87 - 1) = *((_DWORD *)v94 - 22) & 0xFFFFFFF;
        }
        while ( !v54 );
      }
    }
  }
  else
  {
    v86 = 0;
    v87 = s;
  }
  v96 = &v138[v86];
  v97 = v86 + 1;
  v100 = *v96;
  v98 = v96 + 1;
  v99 = v100;
  if ( (int)v128 <= v86 + 1 )
    v98 = v128;
  v101 = (~(_BYTE)v86 + (_BYTE)v128) & 7;
  *v87 = v99 & 0xFFFFFFF;
  v102 = v87 + 1;
  if ( (int)v128 > v86 + 1 )
  {
    if ( ((~(_BYTE)v86 + (_BYTE)v128) & 7) == 0 )
      goto LABEL_88;
    if ( v101 != 1 )
    {
      if ( v101 != 2 )
      {
        if ( v101 != 3 )
        {
          if ( v101 != 4 )
          {
            if ( v101 != 5 )
            {
              v103 = v101 == 6;
              if ( v101 != 6 )
              {
                v104 = *v98++;
                v101 = v104;
                v97 = v86 + 2;
              }
              ++v97;
              v106 = *v98++;
              v105 = v106;
              if ( !v103 )
                *v102++ = v101 & 0xFFFFFFF;
              *v102++ = v105 & 0xFFFFFFF;
            }
            v107 = *v98++;
            ++v97;
            *v102++ = v107 & 0xFFFFFFF;
          }
          v108 = *v98++;
          ++v97;
          *v102++ = v108 & 0xFFFFFFF;
        }
        v109 = *v98++;
        ++v97;
        *v102++ = v109 & 0xFFFFFFF;
      }
      v110 = *v98++;
      ++v97;
      *v102++ = v110 & 0xFFFFFFF;
    }
    ++v97;
    v111 = *v98++;
    v112 = v111 & 0xFFFFFFF;
    if ( (int)v128 <= v97 )
      v98 = v128;
    *v102++ = v112;
    if ( (int)v128 > v97 )
    {
LABEL_88:
      do
      {
        v113 = v98[3];
        v97 += 8;
        v114 = v98[1] & 0xFFFFFFF;
        v115 = v98[2];
        *v102 = *v98 & 0xFFFFFFF;
        v116 = v113 & 0xFFFFFFF;
        v102[1] = v114;
        v117 = v98[4];
        v118 = v98[5];
        v102 += 8;
        v119 = v98[6];
        v98 += 8;
        v120 = *(v98 - 1);
        *(v102 - 6) = v115 & 0xFFFFFFF;
        *(v102 - 5) = v116;
        *(v102 - 4) = v117 & 0xFFFFFFF;
        *(v102 - 3) = v118 & 0xFFFFFFF;
        *(v102 - 2) = v119 & 0xFFFFFFF;
        *(v102 - 1) = v120 & 0xFFFFFFF;
      }
      while ( (int)v128 > v97 );
      v98 = v128;
    }
  }
  v121 = v98;
  s += (int)v98;
LABEL_74:
  if ( (int)v121 < v136 )
    memset(s, 0, 4 * (v136 - (_DWORD)v121));
  sub_29BBC(a2);
  return 0;
}

//----- (000329A8) --------------------------------------------------------
int __fastcall sub_329A8(int *a1, int *a2)
{
  int result; // r0

  if ( a2 == a1 || (result = sub_2A25C(a1, a2)) == 0 )
  {
    a2[2] = 0;
    return 0;
  }
  return result;
}

//----- (000329D0) --------------------------------------------------------
int __fastcall sub_329D0(int *a1, int a2, int *a3, int *a4)
{
  int *v5; // r11
  int v8; // r0
  char v10; // r1
  int v11; // r12
  char v12; // r4
  int v13; // r10
  int *v14; // r0
  int v15; // lr
  int v16; // r2
  int *v17; // r3
  unsigned int v18; // r8
  unsigned int v19; // r0
  unsigned int v20; // r7
  unsigned int v21; // r6
  bool v22; // zf
  int v23; // r2
  unsigned int v24; // r5
  unsigned int v25; // r12
  int v26; // r0
  int v27; // r11
  unsigned int v28; // r8
  unsigned int v29; // r0
  int v30; // r9
  int v31; // r9
  int v32; // r5
  int v33; // r8
  int v34; // r6
  int v35; // r3
  int v36; // r7
  int v37; // r12
  int v38; // r9
  unsigned int v39; // r7
  int *v40; // r12
  unsigned int v41; // r3
  unsigned int v42; // r5
  int v43; // r8
  unsigned int v44; // r9
  unsigned int v45; // r5
  unsigned int v46; // r12
  unsigned int v47; // r2
  unsigned int v48; // r3
  int v49; // r5
  int v50; // r7
  int v51; // r12
  int v52; // [sp+4h] [bp-10h]
  int v53; // [sp+8h] [bp-Ch]
  int *v54; // [sp+Ch] [bp-8h]

  v5 = a3;
  if ( a2 <= 0 )
  {
    v52 = sub_2A25C(a1, a3);
    if ( !a4 )
      return v52;
    sub_2EB8C(a4);
    return v52;
  }
  else
  {
    v52 = sub_2A25C(a1, a3);
    if ( v52 )
      return v52;
    if ( a4 )
    {
      v8 = sub_33984(a1, a2, a4);
      if ( v8 )
        return v8;
    }
    if ( a2 > 27 )
      sub_2E5A0(v5, a2 / 28);
    v10 = a2 % 28;
    if ( a2 != 28 * (a2 / 28) )
    {
      v11 = *v5;
      v12 = 28 - v10;
      v13 = *v5 - 1;
      v14 = (int *)(v5[3] + 4 * (*v5 + 0x3FFFFFFF));
      if ( v13 >= 0 )
      {
        v15 = ~(-1 << v10);
        if ( v11 - 2 <= 6 )
        {
          v16 = 0;
        }
        else
        {
          v16 = 0;
          v17 = v14 - 8;
          v53 = (v11 - 9) & 7;
          v54 = v5;
          do
          {
            v18 = v17[7];
            v19 = v17[8];
            v13 -= 8;
            v20 = v17[6];
            v21 = v17[5];
            v22 = v53 == v13;
            v23 = (v16 << v12) | (v19 >> v10);
            v24 = v17[4];
            v25 = v17[2];
            v26 = (v18 >> v10) | ((v19 & v15) << v12);
            v27 = (v20 >> v10) | ((v15 & v18) << v12);
            v28 = v17[1];
            v17[7] = v26;
            v29 = v17[3];
            v17[8] = v23;
            v30 = v17[3];
            v17[6] = v27;
            v17[5] = (v21 >> v10) | ((v20 & v15) << v12);
            __pld(v17 - 12);
            v17[4] = (v24 >> v10) | ((v21 & v15) << v12);
            v17[3] = (v29 >> v10) | ((v24 & v15) << v12);
            v14 = v17;
            v17[2] = (v25 >> v10) | ((v15 & v30) << v12);
            v16 = v15 & v28;
            v17[1] = (v28 >> v10) | ((v25 & v15) << v12);
            v17 -= 8;
          }
          while ( !v22 );
          v5 = v54;
        }
        v31 = (v13 + 1) & 7;
        if ( !v31 )
          goto LABEL_37;
        if ( v31 != 1 )
        {
          if ( v31 != 2 )
          {
            if ( v31 != 3 )
            {
              if ( v31 != 4 )
              {
                if ( v31 != 5 )
                {
                  if ( v31 != 6 )
                  {
                    --v13;
                    v32 = ((unsigned int)*v14 >> v10) | (v16 << v12);
                    v16 = v15 & *v14;
                    *v14-- = v32;
                  }
                  --v13;
                  v33 = ((unsigned int)*v14 >> v10) | (v16 << v12);
                  v16 = v15 & *v14;
                  *v14-- = v33;
                }
                --v13;
                v34 = ((unsigned int)*v14 >> v10) | (v16 << v12);
                v16 = v15 & *v14;
                *v14-- = v34;
              }
              --v13;
              v35 = ((unsigned int)*v14 >> v10) | (v16 << v12);
              v16 = v15 & *v14;
              *v14-- = v35;
            }
            --v13;
            v36 = ((unsigned int)*v14 >> v10) | (v16 << v12);
            v16 = v15 & *v14;
            *v14-- = v36;
          }
          --v13;
          v37 = ((unsigned int)*v14 >> v10) | (v16 << v12);
          v16 = v15 & *v14;
          *v14-- = v37;
        }
        --v13;
        v38 = ((unsigned int)*v14 >> v10) | (v16 << v12);
        v16 = v15 & *v14;
        *v14-- = v38;
        if ( v13 != -1 )
        {
LABEL_37:
          do
          {
            v39 = *v14;
            v40 = v14;
            v13 -= 8;
            v14 -= 8;
            *v40-- = (v39 >> v10) | (v16 << v12);
            v41 = v14[7];
            v14[7] = (v41 >> v10) | ((v15 & v39) << v12);
            v42 = *(v40 - 1);
            v43 = v15 & v42;
            *(v40 - 1) = (v42 >> v10) | ((v15 & v41) << v12);
            v44 = v14[5];
            v45 = v14[4];
            v46 = v14[3];
            v47 = v14[2];
            v48 = v14[1];
            v14[5] = (v44 >> v10) | (v43 << v12);
            v14[4] = (v45 >> v10) | ((v44 & v15) << v12);
            v49 = (v46 >> v10) | ((v45 & v15) << v12);
            v50 = (v48 >> v10) | ((v47 & v15) << v12);
            v51 = (v47 >> v10) | ((v46 & v15) << v12);
            v14[3] = v49;
            v16 = v15 & v48;
            v14[2] = v51;
            v14[1] = v50;
          }
          while ( v13 != -1 );
        }
      }
    }
    sub_29BBC(v5);
    return 0;
  }
}

//----- (00032D70) --------------------------------------------------------
int __fastcall sub_32D70(int a1, unsigned int a2, int *a3, int *a4)
{
  int *v5; // r4
  int *v6; // r5
  int v8; // r1
  int v9; // r8
  int v11; // r8
  int v12; // r0
  int v13; // r10
  int v14; // r1
  bool v15; // nf
  __int64 v16; // r6
  int v17; // r11
  unsigned int v18; // r0
  int v19; // r9
  int v20; // r10
  unsigned __int64 v21; // r4
  int v22; // t1
  bool v23; // cf
  unsigned __int64 v24; // r0
  int v25; // r0
  int *v26; // [sp+8h] [bp-1Ch]
  int *v27; // [sp+Ch] [bp-18h]
  int v28[5]; // [sp+10h] [bp-14h] BYREF

  if ( !a2 )
    return -3;
  v5 = a4;
  v6 = a3;
  if ( a2 != 1 )
  {
    v8 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 )
    {
      v11 = (a2 - 1) & a2;
      if ( !v11 )
      {
        while ( 1 )
        {
          v12 = ++v11;
          if ( v11 == 28 )
            break;
          if ( a2 != 1 << v11 && a2 != 1 << ++v11 )
          {
            v11 = v12 + 2;
            if ( a2 != 1 << (v12 + 2) )
            {
              v11 = v12 + 3;
              if ( a2 != 1 << (v12 + 3) )
              {
                v11 = v12 + 4;
                if ( a2 != 1 << (v12 + 4) )
                {
                  v11 = v12 + 5;
                  if ( a2 != 1 << (v12 + 5) )
                  {
                    v11 = v12 + 6;
                    if ( a2 != 1 << (v12 + 6) )
                    {
                      v11 = v12 + 7;
                      if ( a2 != 1 << (v12 + 7) )
                      {
                        v11 = v12 + 8;
                        if ( a2 != 1 << (v12 + 8) )
                          continue;
                      }
                    }
                  }
                }
              }
            }
          }
          if ( a4 )
            *a4 = **(_DWORD **)(a1 + 12) & ~(-1 << v11);
          if ( a3 )
            return sub_329D0((int *)a1, v11, a3, 0);
          return 0;
        }
      }
      if ( a2 == 3 )
        return sub_34968((int *)a1, a3, a4);
      v9 = sub_2BB58(v28, v8);
      if ( !v9 )
      {
        v13 = *(_DWORD *)a1;
        v14 = *(_DWORD *)(a1 + 8);
        v15 = *(_DWORD *)a1 - 1 < 0;
        v28[0] = *(_DWORD *)a1;
        v28[2] = v14;
        if ( v15 )
        {
          LODWORD(v16) = 0;
        }
        else
        {
          v17 = *(_DWORD *)(a1 + 12);
          v18 = a2;
          v26 = v6;
          v27 = v5;
          v16 = 0;
          v19 = v17 + 4 * v13;
          v20 = v28[3] + 4 * v13;
          v21 = v18;
          do
          {
            while ( 1 )
            {
              v22 = *(_DWORD *)(v19 - 4);
              v19 -= 4;
              HIDWORD(v16) = v16 >> 4;
              LODWORD(v16) = v22 | ((_DWORD)v16 << 28);
              v23 = HIDWORD(v16) >= HIDWORD(v21);
              HIDWORD(v24) = HIDWORD(v16);
              if ( HIDWORD(v16) == HIDWORD(v21) )
                v23 = (unsigned int)v16 >= (unsigned int)v21;
              LODWORD(v24) = v16;
              if ( !v23 )
                break;
              v25 = sub_34E18(v24, v21);
              *(_DWORD *)(v20 - 4) = v25;
              v20 -= 4;
              v16 -= v21 * (unsigned int)v25;
              if ( v19 == v17 )
                goto LABEL_35;
            }
            *(_DWORD *)(v20 - 4) = 0;
            v20 -= 4;
          }
          while ( v19 != v17 );
LABEL_35:
          v6 = v26;
          v5 = v27;
        }
        if ( v5 )
          *v5 = v16;
        if ( v6 )
        {
          sub_29BBC(v28);
          sub_2AAD4(v28, v6);
        }
        sub_29D74((int)v28);
      }
      return v9;
    }
  }
  if ( a4 )
    *a4 = 0;
  if ( a3 )
    return sub_2A25C((int *)a1, a3);
  return 0;
}

//----- (00032FCC) --------------------------------------------------------
int __fastcall sub_32FCC(int *a1)
{
  int v1; // r12
  _DWORD *v2; // r3
  int v3; // r0
  int v4; // r1
  int v5; // t1
  int v6; // t1
  int v7; // t1
  int v8; // t1
  int v9; // t1
  int v10; // t1
  int v11; // t1
  int v12; // t1

  v1 = *a1;
  if ( *a1 <= 1 )
    return 0;
  v2 = (_DWORD *)a1[3];
  v3 = (v1 - 1) & 7;
  v4 = 1;
  if ( !v3 )
  {
LABEL_23:
    while ( 1 )
    {
      v4 += 8;
      if ( v2[1] != 0xFFFFFFF )
        break;
      if ( v2[2] != 0xFFFFFFF )
        break;
      if ( v2[3] != 0xFFFFFFF )
        break;
      if ( v2[4] != 0xFFFFFFF )
        break;
      if ( v2[5] != 0xFFFFFFF )
        break;
      if ( v2[6] != 0xFFFFFFF )
        break;
      if ( v2[7] != 0xFFFFFFF )
        break;
      v12 = v2[8];
      v2 += 8;
      if ( v12 != 0xFFFFFFF )
        break;
      if ( v1 == v4 )
        return 1;
    }
    return 0;
  }
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      if ( v3 != 3 )
      {
        if ( v3 != 4 )
        {
          if ( v3 != 5 )
          {
            if ( v3 != 6 )
            {
              v5 = v2[1];
              ++v2;
              if ( v5 != 0xFFFFFFF )
                return 0;
              v4 = 2;
            }
            v6 = v2[1];
            ++v2;
            if ( v6 != 0xFFFFFFF )
              return 0;
            ++v4;
          }
          v7 = v2[1];
          ++v2;
          if ( v7 != 0xFFFFFFF )
            return 0;
          ++v4;
        }
        v8 = v2[1];
        ++v2;
        if ( v8 != 0xFFFFFFF )
          return 0;
        ++v4;
      }
      v9 = v2[1];
      ++v2;
      if ( v9 != 0xFFFFFFF )
        return 0;
      ++v4;
    }
    v10 = v2[1];
    ++v2;
    if ( v10 == 0xFFFFFFF )
    {
      ++v4;
      goto LABEL_21;
    }
    return 0;
  }
LABEL_21:
  v11 = v2[1];
  ++v2;
  if ( v11 != 0xFFFFFFF )
    return 0;
  if ( v1 != ++v4 )
    goto LABEL_23;
  return 1;
}

//----- (00033110) --------------------------------------------------------
int __fastcall sub_33110(int *a1, int *a2, unsigned int a3)
{
  int v4; // r1
  bool v5; // cc
  int v6; // r2
  unsigned int *v7; // r12
  int v8; // r2
  unsigned int *v9; // r11
  unsigned int v10; // r4
  unsigned int v11; // r1
  unsigned int v12; // r0
  unsigned int v13; // r4
  signed __int64 v14; // r0
  unsigned int v15; // r5
  unsigned int v16; // r9
  unsigned __int64 v17; // r4
  unsigned int v18; // r10
  unsigned __int64 v19; // r8
  unsigned int v20; // r3
  __int64 v21; // r8
  unsigned int v22; // kr08_4
  unsigned int v23; // r3
  __int64 v24; // r8
  __int64 v25; // kr28_8
  unsigned int v26; // kr10_4
  int v27; // r10
  int v28; // r3
  unsigned int *v29; // r10
  int v30; // r9
  unsigned int *v31; // r10
  unsigned int v32; // t1
  int v33; // lr
  int v34; // r6
  signed __int64 v35; // r4
  unsigned int v36; // r2
  int *v37; // r12
  unsigned int v38; // t1
  unsigned __int64 v39; // r8
  unsigned int v40; // t1
  unsigned __int64 v41; // r4
  unsigned int v42; // r6
  unsigned __int64 v43; // kr38_8
  unsigned int *v44; // r10
  unsigned int v45; // t1
  signed __int64 v46; // kr40_8
  int v47; // r6
  unsigned int v48; // r4
  int v49; // r11
  int *v50; // r3
  unsigned __int64 v51; // r0
  unsigned int v52; // kr1C_4
  unsigned __int64 v53; // kr48_8
  unsigned __int64 v54; // r8
  unsigned int v55; // kr20_4
  unsigned int v56; // kr24_4
  unsigned int *v57; // r3
  unsigned int v58; // r5
  unsigned int v59; // kr50_4
  signed __int64 v60; // r10
  _DWORD *v61; // lr
  int v62; // r0
  int result; // r0
  __int64 v64; // [sp+0h] [bp-44h]
  unsigned int *v65; // [sp+0h] [bp-44h]
  int v66; // [sp+Ch] [bp-38h]
  __int64 v67; // [sp+10h] [bp-34h]
  __int64 v68; // [sp+10h] [bp-34h]
  __int64 v69; // [sp+10h] [bp-34h]
  unsigned int v70; // [sp+20h] [bp-24h]
  int v71; // [sp+24h] [bp-20h]
  unsigned int *v73; // [sp+2Ch] [bp-18h]
  int v75; // [sp+34h] [bp-10h]
  int v76; // [sp+3Ch] [bp-8h]

  v71 = *a2;
  v4 = 2 * *a2;
  if ( a1[1] >= v4 || (result = sub_2BA48((int)a1, v4)) == 0 )
  {
    v70 = a3;
    v5 = v71 <= -2147483641;
    if ( v71 >= -2147483641 )
      v5 = v71 - 7 <= 1;
    v6 = !v5;
    v75 = v71;
    v76 = v6;
    while ( 1 )
    {
      v7 = (unsigned int *)a1[3];
      v73 = &v7[v75];
      if ( v71 > 0 )
        break;
      v36 = 0;
LABEL_23:
      v61 = v7 + 1;
      *v7 = v36;
      if ( *a1 > v71 + 1 )
      {
        v62 = v71 + 1;
        do
        {
          *v61++ = 0;
          ++v62;
        }
        while ( *a1 > v62 );
      }
      sub_29BBC(a1);
      if ( sub_29E8C(a1, a2) == -1 )
        return 0;
      result = sub_307E4(a1, a2, a1);
      if ( result )
        return result;
    }
    if ( v76 )
    {
      v8 = (int)&v7[v75 + 8];
      v9 = v7 + 8;
      v10 = 0;
      v66 = 0;
      do
      {
        v11 = *(v9 - 8);
        v12 = v10;
        v13 = *(_DWORD *)(v8 - 32);
        __pld((void *)(v8 + 32));
        __pld(v9 + 8);
        v14 = v70 * (unsigned __int64)v13 + v12 + (unsigned __int64)v11;
        v15 = *(v9 - 7);
        v16 = *(v9 - 6);
        *(v9 - 8) = v14 & 0xFFFFFFF;
        v17 = *(unsigned int *)(v8 - 28) * (unsigned __int64)v70 + v15;
        v67 = *(v9 - 5);
        *(v9 - 7) = (v17 + (v14 >> 28)) & 0xFFFFFFF;
        v18 = (__int64)(v17 + (unsigned int)(v14 >> 28)) >> 28;
        v19 = *(unsigned int *)(v8 - 24) * (unsigned __int64)v70 + v16;
        v64 = *(v9 - 4);
        *(v9 - 6) = (v19 + v18) & 0xFFFFFFF;
        v20 = (__int64)(v19 + v18) >> 28;
        v21 = *(unsigned int *)(v8 - 20) * (unsigned __int64)v70 + v67;
        v68 = *(v9 - 3);
        LODWORD(v14) = *(v9 - 2);
        v22 = v21;
        LODWORD(v21) = v21 + v20;
        *(v9 - 5) = v21 & 0xFFFFFFF;
        v23 = ((unsigned int)v21 >> 28) | (16 * ((__PAIR64__(HIDWORD(v21), v22) + v20) >> 32));
        v24 = *(unsigned int *)(v8 - 16) * (unsigned __int64)v70 + v64;
        *(v9 - 4) = (v24 + v23) & 0xFFFFFFF;
        v25 = *(unsigned int *)(v8 - 12) * (unsigned __int64)v70 + v68;
        v69 = *(v9 - 1);
        v26 = (v24 + v23) >> 28;
        v27 = v66;
        *(v9 - 3) = (v25 + v26) & 0xFFFFFFF;
        HIDWORD(v14) = *(_DWORD *)(v8 - 8);
        v66 += 8;
        LODWORD(v24) = (v25 + v26) >> 28;
        v28 = v27 + 9;
        v29 = (unsigned int *)v8;
        *(v9 - 2) = (HIDWORD(v14) * v70 + v14 + v24) & 0xFFFFFFF;
        v8 += 32;
        v7 = v9;
        v10 = (__int64)(*(v29 - 1) * (unsigned __int64)v70
                      + v69
                      + (unsigned int)((__int64)(HIDWORD(v14) * (unsigned __int64)v70
                                               + (unsigned int)v14
                                               + (unsigned int)v24) >> 28)) >> 28;
        *(v9 - 1) = (*(v29 - 1) * v70
                   + v69
                   + ((__int64)(HIDWORD(v14) * (unsigned __int64)v70 + (unsigned int)v14 + (unsigned int)v24) >> 28))
                  & 0xFFFFFFF;
        v9 += 8;
      }
      while ( v71 - 7 > v28 );
      v30 = v66;
    }
    else
    {
      v30 = 0;
      v29 = &v7[v75];
      v10 = 0;
    }
    v32 = *v29;
    v31 = v29 + 1;
    v33 = v30 + 1;
    v34 = (~v30 + v71) & 3;
    v35 = v70 * (unsigned __int64)v32 + v10 + *v7;
    v36 = v35 >> 28;
    *v7 = v35 & 0xFFFFFFF;
    v37 = (int *)(v7 + 1);
    if ( v71 > v30 + 1 )
    {
      if ( v34 )
      {
        if ( v34 != 1 )
        {
          if ( v34 != 2 )
          {
            v38 = *v31++;
            v33 = v30 + 2;
            v39 = v70 * (unsigned __int64)v38 + v36;
            v36 = (__int64)(v39 + (unsigned int)*v37) >> 28;
            *v37 = (v39 + *v37) & 0xFFFFFFF;
            ++v37;
          }
          v40 = *v31++;
          ++v33;
          v41 = v70 * (unsigned __int64)v40 + v36;
          v42 = v41 + *v37;
          v43 = v41 + (unsigned int)*v37;
          *v37++ = v42 & 0xFFFFFFF;
          v36 = __SPAIR64__(HIDWORD(v43), v42) >> 28;
        }
        v45 = *v31;
        v44 = v31 + 1;
        ++v33;
        v46 = v70 * (unsigned __int64)v45 + v36 + (unsigned int)*v37;
        *v37++ = v46 & 0xFFFFFFF;
        v36 = v46 >> 28;
        if ( v71 <= v33 )
          goto LABEL_22;
        v47 = v71;
        v48 = v70;
        v65 = v44;
      }
      else
      {
        v48 = v70;
        v47 = v71;
        v65 = v31;
      }
      do
      {
        v49 = *v37;
        v50 = v37;
        v33 += 4;
        v37 += 4;
        v51 = v48 * (unsigned __int64)*v65 + v36;
        v52 = v48 * *v65 + v36;
        *v50++ = (v52 + v49) & 0xFFFFFFF;
        v53 = __PAIR64__(HIDWORD(v51), v52) + (unsigned int)v49;
        HIDWORD(v51) = v50[1];
        v54 = v48 * (unsigned __int64)v65[1]
            + (((v52 + v49) >> 28) | (unsigned __int64)(unsigned int)(16 * HIDWORD(v53)));
        v55 = v48 * v65[1] + (__SPAIR64__(HIDWORD(v53), v52 + v49) >> 28);
        v56 = *(v37 - 3);
        *v50 = (v55 + v56) & 0xFFFFFFF;
        v57 = v65;
        v65 += 4;
        v58 = *(v37 - 1);
        v59 = v48 * v57[2] + ((__int64)(__PAIR64__(HIDWORD(v54), v55) + v56) >> 28) + HIDWORD(v51);
        LODWORD(v54) = (v48 * (unsigned __int64)v57[2]
                      + (unsigned int)((__int64)(__PAIR64__(HIDWORD(v54), v55) + v56) >> 28)
                      + HIDWORD(v51)) >> 32;
        *(v37 - 2) = v59 & 0xFFFFFFF;
        v60 = v48 * (unsigned __int64)*(v65 - 1) + (unsigned int)(__SPAIR64__(v54, v59) >> 28) + v58;
        *(v37 - 1) = v60 & 0xFFFFFFF;
        v36 = v60 >> 28;
      }
      while ( v47 > v33 );
    }
LABEL_22:
    v7 = v73;
    goto LABEL_23;
  }
  return result;
}

//----- (00033640) --------------------------------------------------------
int __fastcall sub_33640(int a1, _DWORD *a2)
{
  int result; // r0

  result = **(_DWORD **)(a1 + 12);
  *a2 = 0x10000000 - result;
  return result;
}

//----- (00033654) --------------------------------------------------------
int __fastcall sub_33654(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        char a10,
        int a11,
        int a12,
        int a13,
        char a14,
        int a15,
        int a16,
        int a17,
        char a18)
{
  int v18; // r8
  int v19; // r5
  int v20; // r7
  int *v21; // r4
  int *v22; // r6
  int v23; // r0
  int v24; // lr
  int v25; // r0
  int *p_varg_r1; // [sp+0h] [bp-8h]
  int varg_r0; // [sp+20h] [bp+18h]
  int varg_r1; // [sp+24h] [bp+1Ch] BYREF
  int varg_r2; // [sp+28h] [bp+20h]
  int varg_r3; // [sp+2Ch] [bp+24h]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  v18 = a1;
  p_varg_r1 = &varg_r1;
  if ( !a1 )
    return 0;
  v19 = 0;
  while ( !sub_2BAD0(a1) )
  {
    ++v19;
    a1 = *p_varg_r1++;
    if ( !a1 )
      return 0;
  }
  v20 = v19 - 1;
  if ( v19 )
  {
    v21 = &varg_r1;
    if ( v20 > 7 )
    {
      v22 = (int *)&a10;
      if ( ((v19 - 9) & 8) != 0 )
        goto LABEL_29;
      __pld(&a14);
      sub_29D74(v18);
      v20 = v19 - 9;
      sub_29D74(varg_r1);
      v21 = (int *)&a10;
      sub_29D74(varg_r2);
      sub_29D74(varg_r3);
      sub_29D74(a5);
      sub_29D74(a6);
      sub_29D74(a7);
      sub_29D74(a8);
      v18 = a9;
      v22 = (int *)&a18;
      if ( (unsigned int)(v19 - 9) > 7 )
      {
LABEL_29:
        do
        {
          __pld(v22 + 4);
          sub_29D74(v18);
          v21 = v22 + 8;
          sub_29D74(*(v22 - 8));
          v20 -= 16;
          sub_29D74(*(v22 - 7));
          sub_29D74(*(v22 - 6));
          sub_29D74(*(v22 - 5));
          sub_29D74(*(v22 - 4));
          sub_29D74(*(v22 - 3));
          sub_29D74(*(v22 - 2));
          sub_29D74(*(v22 - 1));
          v23 = *v22;
          __pld(v22 + 12);
          v22 += 16;
          sub_29D74(v23);
          sub_29D74(*(v21 - 7));
          sub_29D74(*(v21 - 6));
          sub_29D74(*(v21 - 5));
          sub_29D74(*(v21 - 4));
          sub_29D74(*(v21 - 3));
          sub_29D74(*(v21 - 2));
          v18 = *(v21 - 1);
        }
        while ( (unsigned int)v20 > 7 );
      }
    }
    v24 = (v20 + 1) & 7;
    if ( !v24 )
      goto LABEL_30;
    if ( v24 != 1 )
    {
      if ( v24 != 2 )
      {
        if ( v24 != 3 )
        {
          if ( v24 != 4 )
          {
            if ( v24 != 5 )
            {
              if ( v24 != 6 )
              {
                ++v21;
                sub_29D74(v18);
                v18 = *(v21 - 1);
                --v20;
              }
              ++v21;
              sub_29D74(v18);
              v18 = *(v21 - 1);
              --v20;
            }
            ++v21;
            sub_29D74(v18);
            v18 = *(v21 - 1);
            --v20;
          }
          ++v21;
          sub_29D74(v18);
          v18 = *(v21 - 1);
          --v20;
        }
        ++v21;
        sub_29D74(v18);
        v18 = *(v21 - 1);
        --v20;
      }
      ++v21;
      sub_29D74(v18);
      v18 = *(v21 - 1);
      --v20;
    }
    --v20;
    sub_29D74(v18);
    v18 = *v21++;
    if ( v20 != -1 )
    {
LABEL_30:
      do
      {
        sub_29D74(v18);
        sub_29D74(*v21);
        v20 -= 8;
        sub_29D74(v21[1]);
        sub_29D74(v21[2]);
        sub_29D74(v21[3]);
        sub_29D74(v21[4]);
        sub_29D74(v21[5]);
        v25 = v21[6];
        v21 += 8;
        sub_29D74(v25);
        v18 = *(v21 - 1);
      }
      while ( v20 != -1 );
    }
  }
  return -2;
}

//----- (00033984) --------------------------------------------------------
int __fastcall sub_33984(int *a1, int a2, int *a3)
{
  int v5; // r6
  int v6; // lr
  int v7; // r12
  int v8; // r9
  _DWORD *v9; // r2

  if ( a2 <= 0 )
  {
    sub_2EB8C(a3);
    return 0;
  }
  else if ( a2 >= 28 * *a1 )
  {
    return sub_2A25C(a1, a3);
  }
  else
  {
    v5 = sub_2A25C(a1, a3);
    if ( !v5 )
    {
      v6 = a3[3];
      v7 = a2 / 28;
      if ( 28 * (a2 / 28) == a2 )
        v8 = a2 / 28;
      else
        v8 = v7 + 1;
      if ( v8 < *a3 )
      {
        v9 = (_DWORD *)(v6 + 4 * v8);
        do
        {
          *v9++ = 0;
          ++v8;
        }
        while ( *a3 > v8 );
      }
      *(_DWORD *)(v6 + 4 * v7) &= ~(-1 << (a2 % 0x1Cu));
      sub_29BBC(a3);
    }
    return v5;
  }
}

//----- (00033A60) --------------------------------------------------------
int __fastcall sub_33A60(int a1, _DWORD *a2)
{
  unsigned int *v2; // r4
  unsigned int *v5; // r6
  int result; // r0
  unsigned int v7; // r1
  unsigned int *v8; // r4
  int v9[2]; // [sp+4h] [bp-8h] BYREF

  v2 = (unsigned int *)&off_3ACB0;
  *a2 = 0;
  do
  {
    v5 = v2 + 1;
    result = sub_2C51C(a1, *v2, v9);
    if ( result )
      break;
    if ( !v9[0] )
      goto LABEL_20;
    result = sub_2C51C(a1, *v5, v9);
    if ( result )
      return result;
    if ( !v9[0] )
      goto LABEL_20;
    result = sub_2C51C(a1, v2[2], v9);
    if ( result )
      return result;
    if ( !v9[0] )
      goto LABEL_20;
    result = sub_2C51C(a1, v2[3], v9);
    if ( result )
      return result;
    if ( !v9[0] )
      goto LABEL_20;
    v7 = v2[4];
    v8 = v2 + 5;
    result = sub_2C51C(a1, v7, v9);
    if ( result )
      return result;
    if ( !v9[0] )
      goto LABEL_20;
    result = sub_2C51C(a1, *v8, v9);
    if ( result )
      return result;
    if ( !v9[0] )
      goto LABEL_20;
    result = sub_2C51C(a1, v5[5], v9);
    if ( result )
      return result;
    if ( !v9[0] )
      goto LABEL_20;
    v2 = v5 + 7;
    result = sub_2C51C(a1, v5[6], v9);
    if ( result )
      return result;
    if ( !v9[0] )
    {
LABEL_20:
      *a2 = 1;
      return result;
    }
  }
  while ( v2 != (unsigned int *)"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/" );
  return result;
}
// 3ACB0: using guessed type _UNKNOWN *off_3ACB0;

//----- (00033BD0) --------------------------------------------------------
int __fastcall sub_33BD0(int *a1, int *a2, int *a3)
{
  int result; // r0
  int v7; // r8
  int v8; // r5
  int v9[4]; // [sp+0h] [bp-10h] BYREF

  result = sub_2BAD0((int)v9);
  if ( !result )
  {
    v7 = sub_2A310(a2);
    do
    {
      v8 = sub_329D0(a1, v7, v9, a1);
      if ( v8 )
        break;
      v8 = sub_2CB6C(v9, a3, v9);
      if ( v8 )
        break;
      v8 = sub_2EC08(a1, v9, a1);
      if ( v8 )
        break;
      if ( sub_29E8C(a1, a2) == -1 )
        break;
      v8 = sub_307E4(a1, a2, a1);
    }
    while ( !v8 );
    sub_29D74((int)v9);
    return v8;
  }
  return result;
}

//----- (00033C9C) --------------------------------------------------------
int __fastcall sub_33C9C(int *a1, int *a2)
{
  int result; // r0
  int v5; // r0
  int v6; // r4
  int v7[4]; // [sp+0h] [bp-10h] BYREF

  result = sub_2BAD0((int)v7);
  if ( !result )
  {
    v5 = sub_2A310(a1);
    v6 = sub_298D4(v7, v5);
    if ( !v6 )
      v6 = sub_307E4(v7, a1, a2);
    sub_29D74((int)v7);
    return v6;
  }
  return result;
}

//----- (00033D10) --------------------------------------------------------
int __fastcall sub_33D10(int *a1, int *a2, int *a3)
{
  unsigned int v6; // r4
  int result; // r0
  int v8; // r5
  int v9; // r0
  int v10[4]; // [sp+0h] [bp-10h] BYREF

  v6 = *a2;
  result = sub_2BB10(v10, a1);
  if ( !result )
  {
    sub_2E5A0(v10, v6 - 1);
    if ( v6 > 0x8000000 )
    {
      v8 = sub_2CB6C(v10, a3, v10);
      if ( !v8 )
        goto LABEL_4;
    }
    else
    {
      v8 = sub_33EC0(v10, a3, v10, v6);
      if ( !v8 )
      {
LABEL_4:
        sub_2E5A0(v10, v6 + 1);
        v8 = sub_33984(a1, 28 * (v6 + 1), a1);
        if ( !v8 )
        {
          v8 = sub_2FCC8(v10, a2, v10, v6 + 1);
          if ( !v8 )
          {
            v8 = sub_2E764(a1, v10, a1);
            if ( !v8 )
            {
              if ( sub_29E48((int)a1, 0) == -1
                && ((sub_2E630((int)v10, 1), (v9 = sub_2C160(v10, v6 + 1)) != 0) || (v9 = sub_29934(a1, v10, a1)) != 0) )
              {
LABEL_13:
                v8 = v9;
              }
              else
              {
                while ( sub_29E00(a1, a2) != -1 )
                {
                  v9 = sub_307E4(a1, a2, a1);
                  if ( v9 )
                    goto LABEL_13;
                }
              }
            }
          }
        }
      }
    }
    sub_29D74((int)v10);
    return v8;
  }
  return result;
}

//----- (00033E88) --------------------------------------------------------
int __fastcall sub_33E88(int *a1, int *a2)
{
  int result; // r0

  result = sub_298D4(a1, 56 * *a2);
  if ( !result )
    return sub_2A5A8(a1, a2, a1, 0);
  return result;
}

//----- (00033EC0) --------------------------------------------------------
int __fastcall sub_33EC0(int *a1, int *a2, int *a3, int a4)
{
  int v4; // lr
  int v8; // r8
  int v9; // r2
  int v10; // r10
  int v11; // r7
  int v12; // lr
  int v13; // r8
  int v14; // r6
  int v15; // r2
  __int64 v16; // r4
  unsigned int v17; // lr
  unsigned int *v18; // r10
  bool v19; // cc
  unsigned int *v20; // r11
  unsigned int *v21; // r2
  unsigned int v22; // r6
  unsigned int v23; // r8
  unsigned int v24; // r9
  unsigned __int64 v25; // r0
  unsigned int v26; // r6
  __int64 v27; // r0
  unsigned int v28; // r10
  unsigned __int64 v29; // r6
  unsigned __int64 v30; // r8
  unsigned int v31; // r3
  __int64 v32; // r8
  unsigned int v33; // r3
  __int64 v34; // r8
  unsigned int v35; // r3
  __int64 v36; // kr20_8
  unsigned int *v37; // r10
  unsigned int v38; // t1
  signed __int64 v39; // r6
  int v40; // r1
  int v41; // lr
  unsigned int v42; // r2
  unsigned int v43; // r9
  unsigned int v44; // t1
  unsigned int v45; // t1
  signed __int64 v46; // r2
  unsigned int v47; // r9
  unsigned int v48; // t1
  unsigned int v49; // t1
  signed __int64 v50; // r2
  unsigned int v51; // r4
  unsigned int v52; // t1
  unsigned int v53; // t1
  signed __int64 v54; // r2
  int v55; // r4
  unsigned int v56; // r8
  unsigned int *v57; // r11
  unsigned int v58; // kr1C_4
  unsigned int v59; // r2
  signed __int64 v60; // r0
  signed __int64 v61; // r2
  unsigned int v62; // r11
  signed __int64 v63; // r2
  unsigned int v64; // t1
  signed __int64 v65; // r8
  unsigned int *v66; // r4
  bool v67; // zf
  unsigned int *v69; // r12
  __int64 v70; // [sp+0h] [bp-5Ch]
  __int64 v71; // [sp+0h] [bp-5Ch]
  int v72; // [sp+8h] [bp-54h]
  __int64 v73; // [sp+10h] [bp-4Ch]
  __int64 v74; // [sp+10h] [bp-4Ch]
  __int64 v75; // [sp+10h] [bp-4Ch]
  int v76; // [sp+18h] [bp-44h]
  unsigned int v77; // [sp+1Ch] [bp-40h]
  int v78; // [sp+20h] [bp-3Ch]
  int v79; // [sp+24h] [bp-38h]
  unsigned int *v80; // [sp+28h] [bp-34h]
  unsigned int *v81; // [sp+2Ch] [bp-30h]
  int v82; // [sp+30h] [bp-2Ch]
  int v83; // [sp+34h] [bp-28h]
  int v84; // [sp+38h] [bp-24h]
  int v85; // [sp+3Ch] [bp-20h]
  unsigned int *v87; // [sp+44h] [bp-18h]
  int v88[5]; // [sp+48h] [bp-14h] BYREF

  v4 = *a1;
  v8 = *a1 + *a2 + 1;
  if ( v8 < 512 )
  {
    if ( v4 >= *a2 )
      v4 = *a2;
    if ( v4 <= 255 )
      return sub_34400(a1, a2, a3, a4);
  }
  v85 = sub_2BB58(v88, v8);
  if ( !v85 )
  {
    v9 = *a1;
    v10 = *a2;
    v19 = *a1 <= 0;
    v78 = *a2;
    v88[0] = *a1 + *a2 + 1;
    if ( !v19 )
    {
      v11 = 4 * a4;
      v12 = v88[3] + 4 * a4;
      v79 = a4;
      v13 = v12 + 4 * (v10 - a4);
      v14 = a4 - v9;
      v87 = (unsigned int *)v12;
      v15 = a1[3] - 4;
      HIDWORD(v16) = 0;
      v83 = v14;
      v81 = (unsigned int *)v13;
      v82 = v15;
      v80 = (unsigned int *)(a2[3] + v11);
      v84 = v12 + 32;
      v76 = v10 - 7;
      do
      {
        v17 = *(_DWORD *)(v82 + 4);
        v72 = v79;
        v77 = v17;
        v82 += 4;
        v18 = v80;
        if ( v78 <= v79 )
        {
          v66 = v87;
          v42 = 0;
        }
        else
        {
          v19 = v78 <= -2147483641;
          if ( v78 >= -2147483641 )
            v19 = v76 <= v79 + 1;
          if ( v19 )
          {
            v22 = 0;
            v69 = v87;
          }
          else
          {
            v20 = (unsigned int *)v84;
            v21 = v80 + 8;
            v22 = 0;
            do
            {
              v23 = *(v20 - 8);
              v24 = *(v21 - 8);
              __pld(v20 + 8);
              __pld(v21 + 8);
              v25 = v22 + (unsigned __int64)v23;
              v26 = *(v20 - 7);
              v27 = v17 * (unsigned __int64)v24 + v25;
              v28 = *(v20 - 6);
              *(v20 - 8) = v27 & 0xFFFFFFF;
              v29 = v17 * (unsigned __int64)*(v21 - 7) + v26;
              v73 = *(v20 - 5);
              *(v20 - 7) = (v29 + (v27 >> 28)) & 0xFFFFFFF;
              v16 = (unsigned int)((__int64)(v29 + __PAIR64__(HIDWORD(v16), v27 >> 28)) >> 28);
              v30 = *(v21 - 6) * (unsigned __int64)v17 + v28;
              v70 = *(v20 - 4);
              *(v20 - 6) = (v30 + v16) & 0xFFFFFFF;
              v31 = (__int64)(v30 + v16) >> 28;
              v32 = *(v21 - 5) * (unsigned __int64)v17 + v73;
              v74 = *(v20 - 3);
              LODWORD(v27) = *(v20 - 2);
              *(v20 - 5) = (v32 + v31) & 0xFFFFFFF;
              v33 = (__int64)(v32 + __PAIR64__(HIDWORD(v16), v31)) >> 28;
              v34 = *(v21 - 4) * (unsigned __int64)v17 + v70;
              v71 = (unsigned int)v27;
              *(v20 - 4) = (v34 + v33) & 0xFFFFFFF;
              v35 = (__int64)(v34 + __PAIR64__(HIDWORD(v16), v33)) >> 28;
              v36 = *(v21 - 3) * (unsigned __int64)v17 + v74;
              v75 = *(v20 - 1);
              LODWORD(v34) = v72;
              *(v20 - 3) = (v36 + v35) & 0xFFFFFFF;
              LODWORD(v27) = *(v21 - 2);
              v72 += 8;
              HIDWORD(v27) = (__int64)(v36 + __PAIR64__(HIDWORD(v16), v35)) >> 28;
              v18 = v21;
              *(v20 - 2) = (v27 * v17 + v71 + HIDWORD(v27)) & 0xFFFFFFF;
              v21 += 8;
              v69 = v20;
              v22 = (__int64)(*(v18 - 1) * (unsigned __int64)v17
                            + v75
                            + __PAIR64__(
                                HIDWORD(v16),
                                (__int64)((unsigned int)v27 * (unsigned __int64)v17
                                        + v71
                                        + __PAIR64__(HIDWORD(v16), HIDWORD(v27))) >> 28)) >> 28;
              *(v20 - 1) = (*(v18 - 1) * v17
                          + v75
                          + ((__int64)((unsigned int)v27 * (unsigned __int64)v17
                                     + v71
                                     + __PAIR64__(HIDWORD(v16), HIDWORD(v27))) >> 28))
                         & 0xFFFFFFF;
              v20 += 8;
            }
            while ( v76 > (int)v34 + 9 );
          }
          v38 = *v18;
          v37 = v18 + 1;
          v39 = v17 * (unsigned __int64)v38 + v22 + (unsigned __int64)*v69;
          v40 = v72 + 1;
          v41 = (~v72 + v78) & 3;
          *v69 = v39 & 0xFFFFFFF;
          v42 = v39 >> 28;
          if ( v78 > v72 + 1 )
          {
            if ( !v41 )
              goto LABEL_22;
            if ( v41 != 1 )
            {
              if ( v41 != 2 )
              {
                v44 = v69[1];
                ++v69;
                v43 = v44;
                v45 = *v37++;
                v40 = v72 + 2;
                v46 = v77 * (unsigned __int64)v45 + v42 + (unsigned __int64)v43;
                *v69 = v46 & 0xFFFFFFF;
                v42 = v46 >> 28;
              }
              v48 = v69[1];
              ++v69;
              v47 = v48;
              v49 = *v37++;
              ++v40;
              v50 = v77 * (unsigned __int64)v49 + v42 + (unsigned __int64)v47;
              *v69 = v50 & 0xFFFFFFF;
              v42 = v50 >> 28;
            }
            v52 = v69[1];
            ++v69;
            v51 = v52;
            v53 = *v37++;
            ++v40;
            v54 = v77 * (unsigned __int64)v53 + v42 + (unsigned __int64)v51;
            *v69 = v54 & 0xFFFFFFF;
            v42 = v54 >> 28;
            if ( v78 > v40 )
            {
LABEL_22:
              v55 = v40;
              do
              {
                v57 = v37 + 1;
                v56 = *v37;
                v37 += 4;
                v58 = v42;
                v59 = v69[2];
                v55 += 4;
                v60 = v77 * (unsigned __int64)v56 + v58 + (unsigned __int64)v69[1];
                v69[1] = v60 & 0xFFFFFFF;
                v61 = v77 * (unsigned __int64)*v57 + (unsigned int)(v60 >> 28) + (unsigned __int64)v59;
                v62 = v69[3];
                v69[2] = v61 & 0xFFFFFFF;
                v63 = v77 * (unsigned __int64)*(v37 - 2) + (unsigned int)(v61 >> 28) + (unsigned __int64)v62;
                v69[3] = v63 & 0xFFFFFFF;
                v64 = v69[4];
                v69 += 4;
                v65 = v77 * (unsigned __int64)*(v37 - 1)
                    + (((unsigned int)v63 >> 28) | (unsigned __int64)(unsigned int)(16 * HIDWORD(v63)))
                    + v64;
                *v69 = (v77 * *(v37 - 1) + (v63 >> 28) + v64) & 0xFFFFFFF;
                v42 = v65 >> 28;
              }
              while ( v78 > v55 );
            }
          }
          v66 = v81;
        }
        v67 = v79 - 1 == v83;
        *v66 = v42;
        --v79;
        ++v81;
        --v80;
      }
      while ( !v67 );
    }
    sub_29BBC(v88);
    sub_2AAD4(v88, a3);
    sub_29D74((int)v88);
  }
  return v85;
}

//----- (00034400) --------------------------------------------------------
int __fastcall sub_34400(int *a1, int *a2, int *a3, int a4)
{
  int *v6; // r0
  int v8; // r2
  int v9; // r1
  int v10; // r7
  unsigned __int64 v11; // r8
  int v12; // r6
  _DWORD *v13; // r10
  unsigned int *v14; // r3
  int v15; // r11
  unsigned int v16; // r7
  unsigned int v17; // lr
  unsigned int v18; // r4
  unsigned __int64 v19; // r0
  unsigned int v20; // r5
  unsigned int v21; // r12
  unsigned __int64 v22; // r0
  __int64 v23; // r4
  unsigned int *v24; // r7
  unsigned int *v25; // lr
  unsigned __int64 v26; // r0
  int v27; // r12
  unsigned int v28; // r1
  unsigned int v29; // r12
  unsigned int v30; // r4
  unsigned int v31; // r6
  unsigned __int64 v32; // r0
  unsigned int v33; // r2
  unsigned int v34; // r5
  unsigned __int64 v35; // r0
  unsigned int v36; // r0
  int v37; // r11
  unsigned int v38; // r1
  unsigned int v39; // r12
  unsigned __int64 v40; // r4
  unsigned int v41; // r2
  unsigned int v42; // r6
  unsigned __int64 v43; // r4
  unsigned __int64 v44; // r0
  unsigned int v45; // r6
  unsigned __int64 v46; // r0
  int *v47; // r10
  unsigned int v48; // lr
  unsigned int v49; // t1
  int v50; // r1
  unsigned int v51; // r0
  unsigned int *v52; // r3
  unsigned int v53; // t1
  int v54; // r2
  bool v55; // zf
  int v56; // t1
  unsigned int v57; // t1
  unsigned int v58; // r4
  unsigned int v59; // t1
  unsigned int v60; // r5
  unsigned int v61; // t1
  unsigned int v62; // r7
  unsigned int v63; // t1
  unsigned int v64; // t1
  unsigned int v65; // r12
  unsigned int v66; // t1
  unsigned int v67; // t1
  unsigned int v68; // r6
  unsigned int v69; // t1
  unsigned int v70; // t1
  unsigned int v71; // r4
  unsigned int v72; // t1
  unsigned int v73; // t1
  unsigned int v74; // r7
  unsigned int v75; // t1
  unsigned int v76; // t1
  int v77; // r6
  int v78; // r2
  unsigned int *v79; // r12
  unsigned int *v80; // r0
  unsigned int v81; // r4
  size_t v82; // r2
  void *v83; // r0
  int v84; // r0
  int result; // r0
  int v86; // [sp+0h] [bp-84Ch]
  int v87; // [sp+4h] [bp-848h]
  _DWORD *v88; // [sp+18h] [bp-834h]
  int v89; // [sp+1Ch] [bp-830h]
  int v90; // [sp+20h] [bp-82Ch]
  int v91; // [sp+24h] [bp-828h]
  int v92; // [sp+28h] [bp-824h]
  int v93; // [sp+2Ch] [bp-820h]
  int v94; // [sp+30h] [bp-81Ch]
  char *dest; // [sp+38h] [bp-814h]
  int v97; // [sp+3Ch] [bp-810h]
  int v98; // [sp+40h] [bp-80Ch]
  _BYTE *src; // [sp+44h] [bp-808h]
  _BYTE v100[2052]; // [sp+48h] [bp-804h] BYREF

  v6 = a3;
  v8 = *a2;
  v90 = *a1;
  v9 = *a1 + *a2;
  v89 = v9;
  if ( v6[1] < v9 )
  {
    result = sub_2BA48((int)v6, v9);
    if ( result )
      return result;
    v8 = *a2;
    v90 = *a1;
    v9 = *a1 + *a2;
    v6 = a3;
    v89 = v9;
  }
  v10 = 4 * a4;
  v98 = a4;
  v97 = *v6;
  dest = (char *)(v6[3] + 4 * a4);
  if ( a4 >= v9 )
  {
    v84 = *v6;
    *a3 = v89;
  }
  else
  {
    v11 = 0;
    v91 = a1[3];
    v92 = a2[3];
    src = &v100[v10];
    v93 = v8 - 1;
    v88 = &v100[v10];
    v87 = a4;
    do
    {
      v12 = v93;
      if ( v87 < v93 )
        v12 = v87;
      v13 = (_DWORD *)(v91 + 4 * (v87 - v12));
      v14 = (unsigned int *)(v92 + 4 * v12);
      if ( v12 + 1 >= v90 - (v87 - v12) )
        v15 = v90 - (v87 - v12);
      else
        v15 = v12 + 1;
      if ( v15 > 0 )
      {
        v86 = v15 - 7;
        if ( v15 - 7 <= 1 )
        {
          v27 = 0;
        }
        else
        {
          v14 -= 8;
          v16 = *v13;
          v17 = v14[8];
          v18 = v13[2];
          v19 = v14[7] * (unsigned __int64)(unsigned int)v13[1];
          v20 = v14[6];
          v21 = v13[3];
          __pld(v13 + 23);
          v13 += 8;
          v22 = v18 * (unsigned __int64)v20 + v17 * (unsigned __int64)v16 + v19;
          v23 = *((_QWORD *)v13 - 1);
          v24 = v14 - 8;
          v25 = v13 + 8;
          v26 = v14[2] * (unsigned __int64)(unsigned int)v23
              + v14[3] * (unsigned __int64)(unsigned int)*(v13 - 3)
              + v14[4] * (unsigned __int64)(unsigned int)*(v13 - 4)
              + v14[5] * (unsigned __int64)v21
              + v22;
          v27 = 8;
          v11 += v14[1] * (unsigned __int64)HIDWORD(v23) + v26;
          if ( v86 > 9 )
          {
            if ( (((unsigned int)(v15 - 9) >> 3) & 1) == 0 )
              goto LABEL_14;
            v14 -= 8;
            v28 = v24[7];
            v24 -= 8;
            v29 = *v13;
            v30 = v24[16];
            v31 = v24[14];
            v32 = v28 * (unsigned __int64)(unsigned int)v13[1];
            v33 = v13[2];
            v34 = v24[12];
            __pld(v13 + 23);
            v13 += 8;
            v25 += 8;
            v35 = v33 * (unsigned __int64)v31 + v30 * (unsigned __int64)v29 + v32;
            v27 = 16;
            v11 += v24[9] * (unsigned __int64)*(v25 - 9)
                 + v24[10] * (unsigned __int64)*(v25 - 10)
                 + v24[11] * (unsigned __int64)*(v25 - 11)
                 + v34 * (unsigned __int64)*(v25 - 12)
                 + v24[13] * (unsigned __int64)*(v25 - 13)
                 + v35;
            if ( v86 > 17 )
            {
LABEL_14:
              v94 = v15;
              do
              {
                v13 = v25 + 8;
                v14 = v24 - 8;
                v36 = *(v24 - 1);
                v37 = v27 + 8;
                v38 = v25[1];
                v39 = *(v25 - 8);
                v40 = v24[7] * (unsigned __int64)*(v25 - 7);
                v41 = v24[8];
                v42 = *v25;
                __pld(v25 + 15);
                __pld(v25 + 23);
                v43 = v24[1] * (unsigned __int64)*(v25 - 1)
                    + v24[2] * (unsigned __int64)*(v25 - 2)
                    + v24[3] * (unsigned __int64)*(v25 - 3)
                    + v24[4] * (unsigned __int64)*(v25 - 4)
                    + v24[5] * (unsigned __int64)*(v25 - 5)
                    + *(v25 - 6) * (unsigned __int64)v24[6]
                    + v41 * (unsigned __int64)v39
                    + v40;
                v27 = v37 + 8;
                v44 = *(v24 - 6) * (unsigned __int64)v25[6]
                    + *(v24 - 5) * (unsigned __int64)v25[5]
                    + *(v24 - 4) * (unsigned __int64)v25[4]
                    + *(v24 - 3) * (unsigned __int64)v25[3]
                    + v25[2] * (unsigned __int64)*(v24 - 2)
                    + *v24 * (unsigned __int64)v42
                    + v36 * (unsigned __int64)v38;
                v45 = *(v24 - 7);
                v24 -= 16;
                v46 = v45 * (unsigned __int64)v25[7] + v44;
                v25 += 16;
                v11 += v43 + v46;
              }
              while ( v86 > v37 + 9 );
              v15 = v94;
            }
          }
        }
        v49 = *v13;
        v47 = v13 + 1;
        v48 = v49;
        v50 = v27 + 1;
        v53 = *v14;
        v52 = v14 - 1;
        v51 = v53;
        v54 = (~v27 + v15) & 7;
        v11 += v53 * (unsigned __int64)v48;
        if ( v15 > v27 + 1 )
        {
          if ( !v54 )
            goto LABEL_34;
          if ( v54 != 1 )
          {
            if ( v54 != 2 )
            {
              if ( v54 != 3 )
              {
                if ( v54 != 4 )
                {
                  if ( v54 != 5 )
                  {
                    v55 = v54 == 6;
                    if ( v54 != 6 )
                    {
                      v56 = *v47++;
                      v54 = v56;
                      v50 = v27 + 2;
                      v57 = *v52--;
                      v51 = v57;
                    }
                    ++v50;
                    v59 = *v47++;
                    v58 = v59;
                    v61 = *v52--;
                    v60 = v61;
                    if ( !v55 )
                      v11 += v51 * (unsigned __int64)(unsigned int)v54;
                    v11 += v60 * (unsigned __int64)v58;
                  }
                  v63 = *v47++;
                  v62 = v63;
                  ++v50;
                  v64 = *v52--;
                  v11 += v64 * (unsigned __int64)v62;
                }
                v66 = *v47++;
                v65 = v66;
                ++v50;
                v67 = *v52--;
                v11 += v67 * (unsigned __int64)v65;
              }
              v69 = *v47++;
              v68 = v69;
              ++v50;
              v70 = *v52--;
              v11 += v70 * (unsigned __int64)v68;
            }
            v72 = *v47++;
            v71 = v72;
            ++v50;
            v73 = *v52--;
            v11 += v73 * (unsigned __int64)v71;
          }
          v75 = *v47++;
          v74 = v75;
          ++v50;
          v76 = *v52--;
          v11 += v76 * (unsigned __int64)v74;
          if ( v15 > v50 )
          {
LABEL_34:
            v77 = v50;
            do
            {
              v79 = (unsigned int *)(v47 + 1);
              v78 = *v47;
              v47 += 8;
              v80 = v52 - 1;
              v81 = *v52;
              v52 -= 8;
              v77 += 8;
              v11 += v52[1] * (unsigned __int64)(unsigned int)*(v47 - 1)
                   + v52[2] * (unsigned __int64)(unsigned int)*(v47 - 2)
                   + v52[3] * (unsigned __int64)(unsigned int)*(v47 - 3)
                   + v52[4] * (unsigned __int64)(unsigned int)*(v47 - 4)
                   + v52[5] * (unsigned __int64)(unsigned int)*(v47 - 5)
                   + v52[6] * (unsigned __int64)(unsigned int)*(v47 - 6)
                   + *v80 * (unsigned __int64)*v79
                   + v81 * (unsigned __int64)(unsigned int)v78;
            }
            while ( v15 > v77 );
          }
        }
      }
      v55 = v87 + 1 == v89;
      *v88 = v11 & 0xFFFFFFF;
      ++v87;
      v11 >>= 28;
      ++v88;
    }
    while ( !v55 );
    a4 = v87;
    v82 = 4 * (v87 - v98);
    v83 = dest;
    *a3 = v87;
    dest += v82;
    memcpy(v83, src, v82);
    v84 = v97;
  }
  if ( a4 < v84 )
    memset(dest, 0, 4 * (v84 - a4));
  sub_29BBC(a3);
  return 0;
}

//----- (00034968) --------------------------------------------------------
int __fastcall sub_34968(int *a1, int *a2, _DWORD *a3)
{
  int v4; // r9
  int v5; // r0
  bool v6; // nf
  int v7; // r11
  unsigned __int64 v8; // r4
  int v9; // r8
  int v10; // r9
  int v11; // t1
  unsigned __int64 v12; // r6
  char v13; // r0
  int v14; // r2
  int v16; // [sp+Ch] [bp-28h]
  int v19[5]; // [sp+20h] [bp-14h] BYREF

  v16 = sub_2BB58(v19, *a1);
  if ( !v16 )
  {
    v4 = *a1;
    v5 = a1[2];
    v6 = *a1 - 1 < 0;
    v19[0] = *a1;
    v19[2] = v5;
    if ( v6 )
    {
      LODWORD(v8) = 0;
    }
    else
    {
      v7 = a1[3];
      v8 = 0;
      v9 = v7 + 4 * v4;
      v10 = v19[3] + 4 * v4;
      do
      {
        v11 = *(_DWORD *)(v9 - 4);
        v9 -= 4;
        HIDWORD(v8) = (__int64)v8 >> 4;
        LODWORD(v8) = v11 | ((_DWORD)v8 << 28);
        if ( v8 > 2 )
        {
          v12 = (89478485 * v8) >> 28;
          v8 -= 3 * v12;
          if ( v8 > 2 )
          {
            v13 = sub_34E18(v8 - 3, 3u);
            v14 = (v13 + 1) & 7;
            if ( ((v13 + 1) & 7) == 0 )
              goto LABEL_33;
            if ( v14 != 1 )
            {
              if ( v14 != 2 )
              {
                if ( v14 != 3 )
                {
                  if ( v14 != 4 )
                  {
                    if ( v14 != 5 )
                    {
                      if ( v14 != 6 )
                      {
                        v8 -= 3LL;
                        LODWORD(v12) = v12 + 1;
                      }
                      LODWORD(v12) = v12 + 1;
                      v8 -= 3LL;
                    }
                    LODWORD(v12) = v12 + 1;
                    v8 -= 3LL;
                  }
                  LODWORD(v12) = v12 + 1;
                  v8 -= 3LL;
                }
                LODWORD(v12) = v12 + 1;
                v8 -= 3LL;
              }
              LODWORD(v12) = v12 + 1;
              v8 -= 3LL;
            }
            LODWORD(v12) = v12 + 1;
            v8 -= 3LL;
            if ( v8 > 2 )
            {
LABEL_33:
              do
              {
                LODWORD(v12) = v12 + 8;
                v8 -= 24LL;
              }
              while ( v8 > 2 );
            }
          }
        }
        else
        {
          LODWORD(v12) = 0;
        }
        *(_DWORD *)(v10 - 4) = v12;
        v10 -= 4;
      }
      while ( v7 != v9 );
    }
    if ( a3 )
      *a3 = v8;
    if ( a2 )
    {
      sub_29BBC(v19);
      sub_2AAD4(v19, a2);
    }
    sub_29D74((int)v19);
  }
  return v16;
}

//----- (00034BA0) --------------------------------------------------------
unsigned int __fastcall sub_34BA0(unsigned int result, unsigned int a2)
{
  if ( a2 != 1 )
  {
    if ( !a2 )
      JUMPOUT(0x34E48);
    if ( result <= a2 )
    {
      return result == a2;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (*)(void))((char *)&loc_34BD8 + 16 * (31 - (__clz(a2) - __clz(result)))))();
    }
    else
    {
      result >>= 31 - __clz(a2);
    }
  }
  return result;
}
// 34DF8: control flows out of bounds to 34E48

//----- (00034DFC) --------------------------------------------------------
unsigned int __fastcall sub_34DFC(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x34DF2);
  return sub_34BA0(a1, a2);
}
// 34DFE: control flows out of bounds to 34DF2

//----- (00034E18) --------------------------------------------------------
int __fastcall sub_34E18(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return sub_34E54(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (00034E54) --------------------------------------------------------
int __fastcall sub_34E54(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}

//----- (00034F6C) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_4BF00;
  v8 = &off_4BF04 - &off_4BF00;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 4BF00: using guessed type _UNKNOWN *off_4BF00;
// 4BF04: using guessed type _UNKNOWN *off_4BF04;

//----- (00034FAC) --------------------------------------------------------
int sub_34FAC()
{
  return sub_11F04();
}

//----- (00034FB8) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=810 queued=534 decompiled=534 lumina nreq=0 worse=0 better=0
// ALL OK, 534 function(s) have been successfully decompiled
