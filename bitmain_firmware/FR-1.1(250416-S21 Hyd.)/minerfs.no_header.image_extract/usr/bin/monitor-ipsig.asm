;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2025 Hex-Rays, <support@hex-rays.com>           |
; |                      License info: 48-2137-ACAB-99                      |
; |                              elf <elv@ven>                              |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : 6D5631F8EFC153460811C468ACD5447757A7A36A61696968ACC67378EE4A98EB
; Input MD5    : 2BFD1E91B3BE0EAE769A7F4CFD4BB891
; Input CRC32  : 0DA8EF84
; Compiler     : GNU C++

; File Name   : /home/danielsokil/Lab/HashSource/hashsource_antminer_S21x/bitmain_firmware/FR-1.1(250416-S21 Hyd.)/minerfs.no_header.image_extract/usr/bin/monitor-ipsig
; Format      : ELF for ARM (Executable)
; Imagebase   : 10000
; Interpreter '/lib/ld-linux-armhf.so.3'
; Needed Library 'libc.so.6'
;
; Options     : EF_ARM_VFP_FLOAT
; EABI version: 5
;

; Processor       : ARM
; ARM architecture: ARMv7-A
; Target assembler: Generic assembler for ARM
; Byte sex        : Little endian


; Segment type: Pure code
AREA LOAD, CODE, ALIGN=0
; ORG 0x10000
CODE32
dword_10000 DCD 0x464C457F ; File format: \x7FELF
DCB 1                   ; File class: 32-bit
DCB 1                   ; Data encoding: little-endian
DCB 1                   ; File version
DCB 0                   ; OS/ABI: UNIX System V ABI
DCB 0                   ; ABI Version
DCB 0, 0, 0, 0, 0, 0, 0 ; Padding
DCW 2                   ; File type: Executable
DCW 0x28                ; Machine: ARM
DCD 1                   ; File version
DCD start+1             ; Entry point
DCD 0x34                ; PHT file offset
DCD 0x21C8              ; SHT file offset
DCD 0x5000400           ; Processor-specific flags
DCW 0x34                ; ELF header size
DCW 0x20                ; PHT entry size
DCW 9                   ; Number of entries in PHT
DCW 0x28                ; SHT entry size
DCW 0x1A                ; Number of entries in SHT
DCW 0x19                ; SHT entry index for string table
; LOAD ends

; ELF32 Program Header
; PHT Entry 0

; Segment type: Pure code
AREA PHDR, CODE
; ORG 0x10034
CODE32
dword_10034 DCD 0x70000001 ; Type: EXIDX
DCD 0x17C8              ; File offset
DCD unk_117C8           ; Virtual address
DCD 0x117C8             ; Physical address
DCD 8                   ; Size in file image
DCD 8                   ; Size in memory image
DCD 4                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 1
DCD 6                   ; Type: PHDR
DCD 0x34                ; File offset
DCD dword_10034         ; Virtual address
DCD 0x10034             ; Physical address
DCD 0x120               ; Size in file image
DCD 0x120               ; Size in memory image
DCD 5                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 2
DCD 3                   ; Type: INTERP
DCD 0x154               ; File offset
DCD aLibLdLinuxArmh     ; Virtual address
DCD 0x10154             ; Physical address
DCD 0x19                ; Size in file image
DCD 0x19                ; Size in memory image
DCD 4                   ; Flags
DCD 1                   ; Alignment
; PHT Entry 3
DCD 1                   ; Type: LOAD
DCD 0                   ; File offset
DCD dword_10000         ; Virtual address
DCD 0x10000             ; Physical address
DCD 0x17D4              ; Size in file image
DCD 0x17D4              ; Size in memory image
DCD 5                   ; Flags
DCD 0x10000             ; Alignment
; PHT Entry 4
DCD 1                   ; Type: LOAD
DCD 0x1F10              ; File offset
DCD off_21F10           ; Virtual address
DCD 0x21F10             ; Physical address
DCD 0x198               ; Size in file image
DCD 0x1E4               ; Size in memory image
DCD 6                   ; Flags
DCD 0x10000             ; Alignment
; PHT Entry 5
DCD 2                   ; Type: DYNAMIC
DCD 0x1F18              ; File offset
DCD stru_21F18          ; Virtual address
DCD 0x21F18             ; Physical address
DCD 0xE8                ; Size in file image
DCD 0xE8                ; Size in memory image
DCD 6                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 6
DCD 4                   ; Type: NOTE
DCD 0x170               ; File offset
DCD dword_10170         ; Virtual address
DCD 0x10170             ; Physical address
DCD 0x44                ; Size in file image
DCD 0x44                ; Size in memory image
DCD 4                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 7
DCD 0x6474E551          ; Type: STACK
DCD 0                   ; File offset
DCD 0                   ; Virtual address
DCD 0                   ; Physical address
DCD 0                   ; Size in file image
DCD 0                   ; Size in memory image
DCD 6                   ; Flags
DCD 0x10                ; Alignment
; PHT Entry 8
DCD 0x6474E552          ; Type: RO-AFTER
DCD 0x1F10              ; File offset
DCD off_21F10           ; Virtual address
DCD 0x21F10             ; Physical address
DCD 0xF0                ; Size in file image
DCD 0xF0                ; Size in memory image
DCD 4                   ; Flags
DCD 1                   ; Alignment
; PHDR ends


; Segment type: Pure code
AREA LOAD, CODE, ALIGN=0
; ORG 0x10154
CODE32
aLibLdLinuxArmh DCB "/lib/ld-linux-armhf.so.3",0
DCB 0, 0, 0
; ELF Note Entry
dword_10170 DCD 4       ; Name Size
DCD 0x10                ; Desc Size
DCD 1                   ; Type: NT_GNU_ABI_TAG
aGnu DCB "GNU",0        ; Name
DCD 0, 3, 2, 0          ; ABI: Linux 3.2.0
; ELF Note Entry
DCD 4                   ; Name Size
DCD 0x14                ; Desc Size
DCD 3                   ; Type: NT_GNU_BUILD_ID
aGnu_0 DCB "GNU",0      ; Name
DCB 0xAB, 0x59, 0x31, 0x3C, 0xE, 0xE9, 0xE9 ; Desc
DCB 0xBB, 0x11, 0x5C, 0x58, 0x9D, 0xBF, 0x30
DCB 0x93, 0x9A, 0x59, 0x5A, 0xC0, 0x93
; ELF Hash Table
elf_hash_nbucket DCD 0x11
elf_hash_nchain DCD 0x24
elf_hash_bucket DCD 0xE, 0, 0x20, 0x23, 0x1B, 0x1D, 0x1A
DCD 0x13, 0x1F, 0xB, 0x22, 0x21, 0x10, 0x19
DCD 0x18, 0x15, 0xA
elf_hash_chain DCD 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 4, 3
DCD 0, 7, 0, 5, 0xF, 0, 0, 0, 0x14, 8, 0x12
DCD 9, 0x16, 0, 0x17, 1, 0xD, 0xC, 6, 0x11
DCD 0, 0x1E, 0x1C
; ELF Symbol Table
Elf32_Sym <0>
Elf32_Sym <aCalloc - byte_104D0, 0, 0, \ ; "calloc"
           0x12, 0, 0>
Elf32_Sym <aSetsockopt - byte_104D0, 0, \ ; "setsockopt"
           0, 0x12, 0, 0>
Elf32_Sym <aSprintf+1 - byte_104D0, 0, \ ; "printf"
           0, 0x12, 0, 0>
Elf32_Sym <aIsoc99Fscanf - byte_104D0, \ ; "__isoc99_fscanf"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aFree - byte_104D0, 0, 0, \ ; "free"
           0x12, 0, 0>
Elf32_Sym <aMemcpy - byte_104D0, 0, 0, \ ; "memcpy"
           0x12, 0, 0>
Elf32_Sym <aInetNtoa - byte_104D0, 0, 0,\ ; "inet_ntoa"
           0x12, 0, 0>
Elf32_Sym <aSelect - byte_104D0, 0, 0, \ ; "select"
           0x12, 0, 0>
Elf32_Sym <aStpcpy - byte_104D0, 0, 0, \ ; "stpcpy"
           0x12, 0, 0>
Elf32_Sym <aRecvfrom - byte_104D0, 0, 0,\ ; "recvfrom"
           0x12, 0, 0>
Elf32_Sym <aPerror - byte_104D0, 0, 0, \ ; "perror"
           0x12, 0, 0>
Elf32_Sym <aFwrite - byte_104D0, 0, 0, \ ; "fwrite"
           0x12, 0, 0>
Elf32_Sym <aStrcat - byte_104D0, 0, 0, \ ; "strcat"
           0x12, 0, 0>
Elf32_Sym <aIoctl - byte_104D0, 0, 0, \ ; "ioctl"
           0x12, 0, 0>
Elf32_Sym <aUsleep - byte_104D0, 0, 0, \ ; "usleep"
           0x12, 0, 0>
Elf32_Sym <aStrcpy - byte_104D0, 0, 0, \ ; "strcpy"
           0x12, 0, 0>
Elf32_Sym <aGettimeofday - byte_104D0, \ ; "gettimeofday"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aPuts - byte_104D0, 0, 0, \ ; "puts"
           0x12, 0, 0>
Elf32_Sym <aLibcStartMain - byte_104D0, \ ; "__libc_start_main"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aSystem - byte_104D0, 0, 0, \ ; "system"
           0x12, 0, 0>
Elf32_Sym <aGmonStart - byte_104D0, 0, \ ; "__gmon_start__"
           0, 0x20, 0, 0>
Elf32_Sym <aExit - byte_104D0, 0, 0, \ ; "exit"
           0x12, 0, 0>
Elf32_Sym <aStrlen - byte_104D0, 0, 0, \ ; "strlen"
           0x12, 0, 0>
Elf32_Sym <aBind - byte_104D0, 0, 0, \ ; "bind"
           0x12, 0, 0>
Elf32_Sym <aMemset - byte_104D0, 0, 0, \ ; "memset"
           0x12, 0, 0>
Elf32_Sym <aStrncpy - byte_104D0, 0, 0, \ ; "strncpy"
           0x12, 0, 0>
Elf32_Sym <aAccess - byte_104D0, 0, 0, \ ; "access"
           0x12, 0, 0>
Elf32_Sym <aFclose - byte_104D0, 0, 0, \ ; "fclose"
           0x12, 0, 0>
Elf32_Sym <aSendto - byte_104D0, 0, 0, \ ; "sendto"
           0x12, 0, 0>
Elf32_Sym <aSprintf - byte_104D0, 0, 0, \ ; "sprintf"
           0x12, 0, 0>
Elf32_Sym <aFopen64 - byte_104D0, 0, 0, \ ; "fopen64"
           0x12, 0, 0>
Elf32_Sym <aSocket - byte_104D0, 0, 0, \ ; "socket"
           0x12, 0, 0>
Elf32_Sym <aStrncmp - byte_104D0, 0, 0, \ ; "strncmp"
           0x12, 0, 0>
Elf32_Sym <aAbort - byte_104D0, 0, 0, \ ; "abort"
           0x12, 0, 0>
Elf32_Sym <aFclose+1 - byte_104D0, 0, 0,\ ; "close"
           0x12, 0, 0>
; ELF String Table
byte_104D0 DCB 0
aLibcSo6 DCB "libc.so.6",0
aSocket DCB "socket",0
aStrcpy DCB "strcpy",0
aExit DCB "exit",0
aSprintf DCB "sprintf",0
aStrncmp DCB "strncmp",0
aPerror DCB "perror",0
aInetNtoa DCB "inet_ntoa",0
aStrncpy DCB "strncpy",0
aPuts DCB "puts",0
aSelect DCB "select",0
aAbort DCB "abort",0
aCalloc DCB "calloc",0
aStrlen DCB "strlen",0
aMemset DCB "memset",0
aBind DCB "bind",0
aIsoc99Fscanf DCB "__isoc99_fscanf",0
aMemcpy DCB "memcpy",0
aFclose DCB "fclose",0
aSetsockopt DCB "setsockopt",0
aStrcat DCB "strcat",0
aRecvfrom DCB "recvfrom",0
aIoctl DCB "ioctl",0
aSystem DCB "system",0
aUsleep DCB "usleep",0
aFwrite DCB "fwrite",0
aGettimeofday DCB "gettimeofday",0
aSendto DCB "sendto",0
aFopen64 DCB "fopen64",0
aAccess DCB "access",0
aLibcStartMain DCB "__libc_start_main",0
aStpcpy DCB "stpcpy",0
aFree DCB "free",0
aGmonStart DCB "__gmon_start__",0
aGlibc27 DCB "GLIBC_2.7",0
aGlibc24 DCB "GLIBC_2.4",0
DCB 0
; ELF GNU Symbol Version Table
DCW 0
DCW 2                   ; calloc@@GLIBC_2.4
DCW 2                   ; setsockopt@@GLIBC_2.4
DCW 2                   ; printf@@GLIBC_2.4
DCW 3                   ; __isoc99_fscanf@@GLIBC_2.7
DCW 2                   ; free@@GLIBC_2.4
DCW 2                   ; memcpy@@GLIBC_2.4
DCW 2                   ; inet_ntoa@@GLIBC_2.4
DCW 2                   ; select@@GLIBC_2.4
DCW 2                   ; stpcpy@@GLIBC_2.4
DCW 2                   ; recvfrom@@GLIBC_2.4
DCW 2                   ; perror@@GLIBC_2.4
DCW 2                   ; fwrite@@GLIBC_2.4
DCW 2                   ; strcat@@GLIBC_2.4
DCW 2                   ; ioctl@@GLIBC_2.4
DCW 2                   ; usleep@@GLIBC_2.4
DCW 2                   ; strcpy@@GLIBC_2.4
DCW 2                   ; gettimeofday@@GLIBC_2.4
DCW 2                   ; puts@@GLIBC_2.4
DCW 2                   ; __libc_start_main@@GLIBC_2.4
DCW 2                   ; system@@GLIBC_2.4
DCW 0                   ; local  symbol: __gmon_start__
DCW 2                   ; exit@@GLIBC_2.4
DCW 2                   ; strlen@@GLIBC_2.4
DCW 2                   ; bind@@GLIBC_2.4
DCW 2                   ; memset@@GLIBC_2.4
DCW 2                   ; strncpy@@GLIBC_2.4
DCW 2                   ; access@@GLIBC_2.4
DCW 2                   ; fclose@@GLIBC_2.4
DCW 2                   ; sendto@@GLIBC_2.4
DCW 2                   ; sprintf@@GLIBC_2.4
DCW 2                   ; fopen64@@GLIBC_2.4
DCW 2                   ; socket@@GLIBC_2.4
DCW 2                   ; strncmp@@GLIBC_2.4
DCW 2                   ; abort@@GLIBC_2.4
DCW 2                   ; close@@GLIBC_2.4
; ELF GNU Symbol Version Requirements
Elf32_Verneed <1, 2, \  ; "libc.so.6"
               aLibcSo6 - byte_104D0, \
               0x10, 0>
Elf32_Vernaux <0xD696917, 0, 3, \ ; "GLIBC_2.7"
               aGlibc27 - byte_104D0, \
               0x10>
Elf32_Vernaux <0xD696914, 0, 2, \ ; "GLIBC_2.4"
               aGlibc24 - byte_104D0, 0>
; ELF REL Relocation Table
Elf32_Rel <0x22098, 0x1515> ; R_ARM_GLOB_DAT __gmon_start__
; ELF JMPREL Relocation Table
Elf32_Rel <0x2200C, 0x116> ; R_ARM_JUMP_SLOT calloc
Elf32_Rel <0x22010, 0x216> ; R_ARM_JUMP_SLOT setsockopt
Elf32_Rel <0x22014, 0x316> ; R_ARM_JUMP_SLOT printf
Elf32_Rel <0x22018, 0x416> ; R_ARM_JUMP_SLOT __isoc99_fscanf
Elf32_Rel <0x2201C, 0x516> ; R_ARM_JUMP_SLOT free
Elf32_Rel <0x22020, 0x616> ; R_ARM_JUMP_SLOT memcpy
Elf32_Rel <0x22024, 0x716> ; R_ARM_JUMP_SLOT inet_ntoa
Elf32_Rel <0x22028, 0x816> ; R_ARM_JUMP_SLOT select
Elf32_Rel <0x2202C, 0x916> ; R_ARM_JUMP_SLOT stpcpy
Elf32_Rel <0x22030, 0xA16> ; R_ARM_JUMP_SLOT recvfrom
Elf32_Rel <0x22034, 0xB16> ; R_ARM_JUMP_SLOT perror
Elf32_Rel <0x22038, 0xC16> ; R_ARM_JUMP_SLOT fwrite
Elf32_Rel <0x2203C, 0xD16> ; R_ARM_JUMP_SLOT strcat
Elf32_Rel <0x22040, 0xE16> ; R_ARM_JUMP_SLOT ioctl
Elf32_Rel <0x22044, 0xF16> ; R_ARM_JUMP_SLOT usleep
Elf32_Rel <0x22048, 0x1016> ; R_ARM_JUMP_SLOT strcpy
Elf32_Rel <0x2204C, 0x1116> ; R_ARM_JUMP_SLOT gettimeofday
Elf32_Rel <0x22050, 0x1216> ; R_ARM_JUMP_SLOT puts
Elf32_Rel <0x22054, 0x1316> ; R_ARM_JUMP_SLOT __libc_start_main
Elf32_Rel <0x22058, 0x1416> ; R_ARM_JUMP_SLOT system
Elf32_Rel <0x2205C, 0x1516> ; R_ARM_JUMP_SLOT __gmon_start__
Elf32_Rel <0x22060, 0x1616> ; R_ARM_JUMP_SLOT exit
Elf32_Rel <0x22064, 0x1716> ; R_ARM_JUMP_SLOT strlen
Elf32_Rel <0x22068, 0x1816> ; R_ARM_JUMP_SLOT bind
Elf32_Rel <0x2206C, 0x1916> ; R_ARM_JUMP_SLOT memset
Elf32_Rel <0x22070, 0x1A16> ; R_ARM_JUMP_SLOT strncpy
Elf32_Rel <0x22074, 0x1B16> ; R_ARM_JUMP_SLOT access
Elf32_Rel <0x22078, 0x1C16> ; R_ARM_JUMP_SLOT fclose
Elf32_Rel <0x2207C, 0x1D16> ; R_ARM_JUMP_SLOT sendto
Elf32_Rel <0x22080, 0x1E16> ; R_ARM_JUMP_SLOT sprintf
Elf32_Rel <0x22084, 0x1F16> ; R_ARM_JUMP_SLOT fopen64
Elf32_Rel <0x22088, 0x2016> ; R_ARM_JUMP_SLOT socket
Elf32_Rel <0x2208C, 0x2116> ; R_ARM_JUMP_SLOT strncmp
Elf32_Rel <0x22090, 0x2216> ; R_ARM_JUMP_SLOT abort
Elf32_Rel <0x22094, 0x2316> ; R_ARM_JUMP_SLOT close
; LOAD ends


; Segment type: Pure code
AREA .init, CODE
; ORG 0x10794
CODE32



; int init_proc()
EXPORT .init_proc
.init_proc
PUSH            {R3,LR}
BL              sub_109F8
POP             {R3,PC}
; End of function .init_proc

; .init ends


; Segment type: Pure code
AREA .plt, CODE
; ORG 0x107A0
CODE32



; void sub_107A0()
sub_107A0
PUSH            {LR}
LDR             LR, =(_GLOBAL_OFFSET_TABLE_ - 0x107B0)
ADD             LR, PC, LR ; _GLOBAL_OFFSET_TABLE_
LDR             PC, [LR,#(off_22008 - 0x22000)]!
; End of function sub_107A0

off_107B0 DCD _GLOBAL_OFFSET_TABLE_ - 0x107B0
; [0000000C BYTES: COLLAPSED FUNCTION calloc]
; [0000000C BYTES: COLLAPSED FUNCTION setsockopt]
; [0000000C BYTES: COLLAPSED FUNCTION printf]
; [0000000C BYTES: COLLAPSED FUNCTION __isoc99_fscanf]
; [0000000C BYTES: COLLAPSED FUNCTION free]
; [0000000C BYTES: COLLAPSED FUNCTION memcpy]
; [0000000C BYTES: COLLAPSED FUNCTION inet_ntoa]
; [0000000C BYTES: COLLAPSED FUNCTION select]
; [0000000C BYTES: COLLAPSED FUNCTION stpcpy]
; [0000000C BYTES: COLLAPSED FUNCTION recvfrom]
; [0000000C BYTES: COLLAPSED FUNCTION perror]
; [0000000C BYTES: COLLAPSED FUNCTION fwrite]
; [0000000C BYTES: COLLAPSED FUNCTION strcat]
; [0000000C BYTES: COLLAPSED FUNCTION ioctl]
; [0000000C BYTES: COLLAPSED FUNCTION usleep]
; [0000000C BYTES: COLLAPSED FUNCTION strcpy]
; [0000000C BYTES: COLLAPSED FUNCTION gettimeofday]
; [0000000C BYTES: COLLAPSED FUNCTION puts]
; [0000000C BYTES: COLLAPSED FUNCTION __libc_start_main]
; [0000000C BYTES: COLLAPSED FUNCTION system]
; [0000000C BYTES: COLLAPSED FUNCTION __gmon_start__]
; [0000000C BYTES: COLLAPSED FUNCTION exit]
; [0000000C BYTES: COLLAPSED FUNCTION strlen]
; [0000000C BYTES: COLLAPSED FUNCTION bind]
; [0000000C BYTES: COLLAPSED FUNCTION memset]
; [0000000C BYTES: COLLAPSED FUNCTION strncpy]
; [0000000C BYTES: COLLAPSED FUNCTION access]
; [0000000C BYTES: COLLAPSED FUNCTION fclose]
; [0000000C BYTES: COLLAPSED FUNCTION sendto]
; [0000000C BYTES: COLLAPSED FUNCTION sprintf]
; [0000000C BYTES: COLLAPSED FUNCTION fopen64]
; [0000000C BYTES: COLLAPSED FUNCTION socket]
; [0000000C BYTES: COLLAPSED FUNCTION strncmp]
; [0000000C BYTES: COLLAPSED FUNCTION abort]
; [0000000C BYTES: COLLAPSED FUNCTION close]

; Segment type: Pure code
AREA .text, CODE
; ORG 0x10958
CODE32


; Attributes: noreturn

; int main(int, char **, char **)
main
MOVW            R2, #:lower16:a102221 ; "10:22:21"
MOVW            R1, #:lower16:aApr162025 ; "Apr 16 2025"
MOVW            R0, #:lower16:aMonitorIpsigCo ; "monitor-ipsig compile %s--%s\n"
PUSH            {R4-R6,LR}
MOVT            R2, #:upper16:a102221 ; "10:22:21"
MOV             R5, #0x1A80
MOVW            R4, #:lower16:aKeyDown ; "Key Down!!!!!"
MOVT            R1, #:upper16:aApr162025 ; "Apr 16 2025"
MOVT            R0, #:upper16:aMonitorIpsigCo ; "monitor-ipsig compile %s--%s\n"
MOVT            R5, #6
MOVT            R4, #:upper16:aKeyDown ; "Key Down!!!!!"
BL              printf
BL              sub_10FE8

loc_1098C
BL              sub_114A8
CMP             R0, #1
BEQ             loc_109AC

loc_10998               ; useconds
MOV             R0, R5
BL              usleep
BL              sub_114A8
CMP             R0, #1
BNE             loc_10998

loc_109AC               ; s
MOV             R0, R4
BL              puts
BL              sub_110EC
BL              sub_11274
CMP             R0, #1
BNE             loc_109AC
B               loc_1098C
; End of function main

CODE16


; Attributes: noreturn

; void __noreturn start(void (*)(), int, int, int, ...)
EXPORT start
start

arg_0=  0

MOV.W           R11, #0
MOV.W           LR, #0
POP             {R1}    ; argc
MOV             R2, SP  ; ubp_av
PUSH            {R2}    ; stack_end
PUSH            {R0}    ; rtld_fini
LDR.W           R12, =(nullsub_1+1)
PUSH.W          {R12}   ; fini
LDR             R0, =main ; main
LDR             R3, =(init+1) ; init
BLX             __libc_start_main
BLX             abort
; End of function start

off_109EC DCD nullsub_1+1
off_109F0 DCD main
off_109F4 DCD init+1
CODE32



; int sub_109F8()
sub_109F8
LDR             R3, =(_GLOBAL_OFFSET_TABLE_ - 0x10A08)
LDR             R2, =(__gmon_start___ptr_0 - 0x22000)
ADD             R3, PC, R3 ; _GLOBAL_OFFSET_TABLE_
LDR             R2, [R3,R2] ; __imp___gmon_start__
CMP             R2, #0
BXEQ            LR
B               __gmon_start__
; End of function sub_109F8

off_10A14 DCD _GLOBAL_OFFSET_TABLE_ - 0x10A08
off_10A18 DCD __gmon_start___ptr_0 - 0x22000
CODE16



; char *sub_10A1C()
sub_10A1C
MOVW            R0, #:lower16:byte_220A8
MOVW            R3, #:lower16:byte_220A8
MOVT            R0, #:upper16:byte_220A8
MOVT            R3, #:upper16:byte_220A8
CMP             R3, R0
BEQ             locret_10A3C
MOV             R3, #0
CBZ             R3, locret_10A3C
BX              R3

locret_10A3C
BX              LR
; End of function sub_10A1C

ALIGN 0x10



; __int64 sub_10A40()
sub_10A40
MOVW            R0, #:lower16:byte_220A8
MOVW            R1, #:lower16:byte_220A8
MOVT            R0, #:upper16:byte_220A8
MOVT            R1, #:upper16:byte_220A8
SUBS            R1, R1, R0
ASRS            R1, R1, #2
ADD.W           R1, R1, R1,LSR#31
ASRS            R1, R1, #1
BEQ             locret_10A68
MOV             R3, #0
CBZ             R3, locret_10A68
BX              R3

locret_10A68
BX              LR
; End of function sub_10A40

ALIGN 4



; char *sub_10A6C()
sub_10A6C
PUSH            {R4,LR}
MOV             R4, #byte_220A8
LDRB            R3, [R4]
CBNZ            R3, locret_10A82
BL              sub_10A1C
MOVS            R3, #1
STRB            R3, [R4]

locret_10A82
POP             {R4,PC}
; End of function sub_10A6C



; Attributes: thunk

sub_10A84
B               sub_10A40
; End of function sub_10A84

ALIGN 4
CODE32
PUSH            {R4,LR}
SUB             SP, SP, #0x10
MOV             R4, R0
MOV             R1, #0
ADD             R0, SP, #8
BL              gettimeofday
MOVW            R1, #:lower16:unk_11588
LDR             R2, [SP,#0xC]
MOVT            R1, #:upper16:unk_11588
MOV             R0, SP
BL              sprintf
MOV             R3, #0
MOV             R0, SP
STR             R3, [R4]
STR             R3, [R4,#4]
STRH            R3, [R4,#8]
BL              strlen
RSB             R0, R0, #6
ANDS            R2, R0, #0xFF
BEQ             loc_10AE4
MOV             R1, #0x30 ; '0'
MOV             R0, R4
BL              memset

loc_10AE4
MOV             R1, SP
MOV             R0, R4
BL              strcat
MOV             R0, R4
ADD             SP, SP, #0x10
POP             {R4,PC}



; int __fastcall sub_10AFC(const char *, char *)
sub_10AFC

dest= -0x20
var_11= -0x11
var_C= -0xC
var_s0=  0

PUSH            {R4-R6,LR}
MOV             R6, R1
MOV             R1, #2  ; type
SUB             SP, SP, #0x30
MOV             R5, R0
MOV             R2, #0  ; protocol
MOV             R0, R1  ; domain
BL              socket
CMN             R0, #1
MOV             R4, R0
BEQ             loc_10BAC
MOV             R2, #0x14 ; n
MOV             R1, R5  ; src
ADD             R0, SP, #0x30+dest ; dest
BL              strncpy
MOV             R3, #0x30 ; '0'
ADD             R2, SP, #0x30+dest
MOVW            R1, #0x8915 ; request
MOV             R0, R4  ; fd
STRB            R3, [SP,#0x30+var_11]
BL              ioctl
CMP             R0, #0
BLT             loc_10B94
ADD             R3, SP, #0x30+var_s0
MOV             R12, SP
LDMDB           R3, {R0-R3}
STM             R12, {R0-R3}
MOV             R0, R1  ; in
BL              inet_ntoa
MOV             R1, R0  ; src
MOV             R0, R6  ; dest
BL              strcpy
MOV             R0, R4  ; fd
MOV             R4, #1
BL              close

loc_10B88
MOV             R0, R4
ADD             SP, SP, #0x30 ; '0'
POP             {R4-R6,PC}

loc_10B94
MOVW            R0, #:lower16:aNoSuchDeviceSN ; ":No Such Device %s/n"
MOV             R1, R5
MOVT            R0, #:upper16:aNoSuchDeviceSN ; ":No Such Device %s/n"
MOV             R4, #0xFFFFFFFF
BL              printf
B               loc_10B88

loc_10BAC
MOV             R0, #aSocket_0 ; "socket"
BL              perror
B               loc_10B88
; End of function sub_10AFC




; _DWORD *__fastcall sub_10BBC(_DWORD *, const char *)
sub_10BBC

var_2C= -0x2C
var_28= -0x28
dest= -0x24
var_12= -0x12
var_11= -0x11
var_10= -0x10
var_F= -0xF
var_E= -0xE
var_D= -0xD

PUSH            {R4-R7,LR}
MOV             R6, R0
SUB             SP, SP, #0x34
MOV             R7, R1
MOV             R0, #0x28 ; '(' ; nmemb
MOV             R1, #1  ; size
BL              calloc
MOV             R2, #0  ; protocol
MOV             R4, R0
MOV             R1, #1  ; type
MOV             R0, #2  ; domain
BL              socket
SUBS            R5, R0, #0
BLT             loc_10CAC
MOV             R1, R7  ; src
ADD             R0, SP, #0x34+dest ; dest
BL              strcpy
ADD             R2, SP, #0x34+dest
MOVW            R1, #0x8927 ; request
MOV             R0, R5  ; fd
BL              ioctl
CMP             R0, #0
BLT             loc_10C98
MOV             R0, R5  ; fd
BL              close
LDRB            R12, [SP,#0x34+var_E]
MOVW            R1, #:lower16:a02x02x02x02x02 ; "%02X:%02X:%02X:%02X:%02X:%02X"
LDRB            LR, [SP,#0x34+var_F]
MOVT            R1, #:upper16:a02x02x02x02x02 ; "%02X:%02X:%02X:%02X:%02X:%02X"
LDRB            R5, [SP,#0x34+var_D]
MOV             R0, R4  ; s
STR             R12, [SP,#0x34+var_2C]
LDRB            R12, [SP,#0x34+var_10]
LDRB            R3, [SP,#0x34+var_11]
LDRB            R2, [SP,#0x34+var_12]
STMEA           SP, {R12,LR}
STR             R5, [SP,#0x34+var_28]
BL              sprintf
MOVW            R2, #:lower16:aMac ; "MAC="
MOV             R3, R6
MOVT            R2, #:upper16:aMac ; "MAC="
MOV             R1, R4
LDR             R0, [R2] ; "MAC="
STR             R0, [R3],#4
MOV             R0, R3
BL              stpcpy
MOV             R3, #word_115DC
LDRH            R3, [R3]
STRH            R3, [R0]
MOV             R0, R4  ; ptr
BL              free
MOV             R0, R6
ADD             SP, SP, #0x34 ; '4'
POP             {R4-R7,PC}

loc_10C98
MOV             R0, #aIoctl_0 ; "ioctl"
BL              perror
MOV             R0, #0  ; status
BL              exit

loc_10CAC
MOV             R0, #aSocket_0 ; "socket"
BL              perror
MOV             R0, #0  ; status
BL              exit
; End of function sub_10BBC




; char *__fastcall sub_10CC0(char *, const char *)
sub_10CC0

var_2C= -0x2C
var_28= -0x28
dest= -0x24
var_12= -0x12
var_11= -0x11
var_10= -0x10
var_F= -0xF
var_E= -0xE
var_D= -0xD

PUSH            {R4-R7,LR}
MOV             R6, R0
SUB             SP, SP, #0x34
MOV             R7, R1
MOV             R0, #0x28 ; '(' ; nmemb
MOV             R1, #1  ; size
BL              calloc
MOV             R2, #0  ; protocol
MOV             R4, R0
MOV             R1, #1  ; type
MOV             R0, #2  ; domain
BL              socket
SUBS            R5, R0, #0
BLT             loc_10D8C
MOV             R1, R7  ; src
ADD             R0, SP, #0x34+dest ; dest
BL              strcpy
ADD             R2, SP, #0x34+dest
MOVW            R1, #0x8927 ; request
MOV             R0, R5  ; fd
BL              ioctl
CMP             R0, #0
BLT             loc_10D78
MOV             R0, R5  ; fd
BL              close
LDRB            R12, [SP,#0x34+var_E]
MOVW            R1, #:lower16:a02x02x02x02x02 ; "%02X:%02X:%02X:%02X:%02X:%02X"
LDRB            LR, [SP,#0x34+var_F]
MOVT            R1, #:upper16:a02x02x02x02x02 ; "%02X:%02X:%02X:%02X:%02X:%02X"
LDRB            R5, [SP,#0x34+var_D]
MOV             R0, R4  ; s
STR             R12, [SP,#0x34+var_2C]
LDRB            R12, [SP,#0x34+var_10]
LDRB            R3, [SP,#0x34+var_11]
LDRB            R2, [SP,#0x34+var_12]
STMEA           SP, {R12,LR}
STR             R5, [SP,#0x34+var_28]
BL              sprintf
MOV             R1, R4  ; src
MOV             R0, R6  ; dest
BL              strcpy
MOV             R0, R4  ; ptr
BL              free
MOV             R0, R6
ADD             SP, SP, #0x34 ; '4'
POP             {R4-R7,PC}

loc_10D78
MOV             R0, #aIoctl_0 ; "ioctl"
BL              perror
MOV             R0, #0  ; status
BL              exit

loc_10D8C
MOV             R0, #aSocket_0 ; "socket"
BL              perror
MOV             R0, #0  ; status
BL              exit
; End of function sub_10CC0




; int __fastcall sub_10DA0(int)
sub_10DA0
PUSH            {R4,R5,LR}
MOVW            R4, #:lower16:aEchoDSysClassG ; "echo %d > /sys/class/gpio/gpio%d/value"
SUB             SP, SP, #0x44
MOV             R5, R0
MOVT            R4, #:upper16:aEchoDSysClassG ; "echo %d > /sys/class/gpio/gpio%d/value"
MOV             R2, #0x40 ; '@' ; n
MOV             R0, SP  ; s
MOV             R1, #0  ; c
BL              memset
MOV             R1, R4  ; format
MOV             R2, R5
MOVW            R3, #0x3AD
MOV             R0, SP  ; s
BL              sprintf
MOV             R0, SP  ; command
BL              system
MOV             R1, R4  ; format
MOV             R2, R5
MOVW            R3, #0x3AE
MOV             R0, SP  ; s
BL              sprintf
MOV             R0, SP  ; command
BL              system
ADD             SP, SP, #0x44 ; 'D'
POP             {R4,R5,PC}
; End of function sub_10DA0




; bool __fastcall sub_10E04(const char *)
sub_10E04
PUSH            {R4,LR}
MOV             R1, #0  ; type
BL              access
CLZ             R0, R0
MOV             R0, R0,LSR#5
POP             {R4,PC}
; End of function sub_10E04




; int sub_10E1C()
sub_10E1C

var_44= -0x44
s= -0x40

PUSH            {R4,LR}
SUB             SP, SP, #0x48
MOV             R2, #0x40 ; '@' ; n
MOV             R1, #0  ; c
ADD             R0, SP, #0x48+s ; s
BL              memset
MOVW            R1, #:lower16:aSysClassGpioGp ; "/sys/class/gpio/gpio%d"
MOVW            R2, #0x3AF
MOVT            R1, #:upper16:aSysClassGpioGp ; "/sys/class/gpio/gpio%d"
ADD             R0, SP, #0x48+s ; s
BL              sprintf
ADD             R0, SP, #0x48+s ; name
MOV             R1, #0  ; type
BL              access
CMP             R0, #0
BEQ             loc_10EB8
MOVW            R1, #:lower16:aW ; "w"
MOVW            R0, #:lower16:aSysClassGpioEx ; "/sys/class/gpio/export"
MOVT            R1, #:upper16:aW ; "w"
MOVT            R0, #:upper16:aSysClassGpioEx ; "/sys/class/gpio/export"
BL              fopen64
SUBS            R4, R0, #0
BEQ             loc_10F40
MOVW            R1, #:lower16:(aSysClassGpioGp+0x14) ; "%d"
MOVW            R2, #0x3AF
MOVT            R1, #:upper16:(aSysClassGpioGp+0x14) ; format
ADD             R0, SP, #0x48+s ; s
BL              sprintf
ADD             R0, SP, #0x48+s ; s
BL              strlen
MOV             R3, R4  ; s
MOV             R1, R0  ; size
MOV             R2, #1  ; n
ADD             R0, SP, #0x48+s ; ptr
BL              fwrite
CMP             R0, #1
BNE             loc_10F28
MOV             R0, R4  ; stream
BL              fclose

loc_10EB8
MOVW            R1, #:lower16:aSysClassGpioGp_0 ; "/sys/class/gpio/gpio%d/value"
MOVW            R2, #0x3AF
MOVT            R1, #:upper16:aSysClassGpioGp_0 ; "/sys/class/gpio/gpio%d/value"
ADD             R0, SP, #0x48+s ; s
BL              sprintf
MOVW            R1, #:lower16:aR ; "r"
ADD             R0, SP, #0x48+s
MOVT            R1, #:upper16:aR ; "r"
BL              fopen64
SUBS            R4, R0, #0
BEQ             loc_10F10
MOVW            R1, #:lower16:(aSysClassGpioGp+0x14) ; "%d"
ADD             R2, SP, #0x48+var_44
MOVT            R1, #:upper16:(aSysClassGpioGp+0x14) ; "%d"
BL              __isoc99_fscanf
MOV             R0, R4  ; stream
BL              fclose
LDR             R0, [SP,#0x48+var_44]
MOVS            R0, R0
MOVNE           R0, #1
ADD             SP, SP, #0x48 ; 'H'
POP             {R4,PC}

loc_10F10
MOV             R0, #aOpenReadRecove ; "Open read recovery button failure"
BL              puts
MOV             R0, #1
ADD             SP, SP, #0x48 ; 'H'
POP             {R4,PC}

loc_10F28
MOV             R0, #aFileWriteError ; "File Write Error!"
BL              puts
MOV             R0, R4  ; stream
BL              fclose
B               loc_10EB8

loc_10F40
MOV             R0, #aOpenReadGpioEx ; "Open read gpio/export"
BL              puts
MOV             R0, #1
ADD             SP, SP, #0x48 ; 'H'
POP             {R4,PC}
; End of function sub_10E1C




; int __fastcall sub_10F58(int)
sub_10F58
PUSH            {R4-R6,LR}
SUB             SP, SP, #0x40
MOV             R4, R0
MOV             R2, #0x40 ; '@' ; n
MOV             R0, SP  ; s
MOV             R1, #0  ; c
BL              memset
MOVW            R5, #:lower16:aEchoDSysClassG ; "echo %d > /sys/class/gpio/gpio%d/value"
CMP             R4, #0
MOVW            R3, #0x3AD
MOVW            R6, #0x3AE
MOVT            R5, #:upper16:aEchoDSysClassG ; "echo %d > /sys/class/gpio/gpio%d/value"
MOVEQ           R6, R3
MOV             R4, #3

loc_10F90
MOV             R3, R6
MOV             R2, #1
MOV             R1, R5  ; format
MOV             R0, SP  ; s
BL              sprintf
MOV             R0, SP  ; command
BL              system
MOVW            R0, #0xC350 ; useconds
BL              usleep
MOV             R3, R6
MOV             R2, #0
MOV             R1, R5  ; format
MOV             R0, SP  ; s
BL              sprintf
MOV             R0, SP  ; command
BL              system
MOVW            R0, #0xC350 ; useconds
BL              usleep
SUBS            R4, R4, #1
BNE             loc_10F90
ADD             SP, SP, #0x40 ; '@'
POP             {R4-R6,PC}
; End of function sub_10F58




; int sub_10FE8()
sub_10FE8

optlen= -0x14
var_8= -8
var_4= -4

MOV             R1, #2  ; type
PUSH            {R4,R5,LR}
MOV             R2, #0  ; protocol
SUB             SP, SP, #0x14
MOV             R0, R1  ; domain
MOVW            R5, #:lower16:dword_220A4
BL              socket
CMN             R0, #1
MOVT            R5, #:upper16:dword_220A4
STR             R0, [R5]
BEQ             loc_110C0
MOV             R1, #1  ; level
ADD             R3, SP, #0x14+var_4
MOV             R2, #4
STR             R1, [R3,#-4]! ; optval
STR             R2, [SP,#0x14+optlen] ; optlen
MOV             R2, #6  ; optname
BL              setsockopt
CMN             R0, #1
MOV             R4, R0
BEQ             loc_110A8
MOV             R2, #2
MOV             R3, #dword_220D4
MOV             R4, #0
MOV             LR, R2
MOVW            R12, #:lower16:dword_220E4
MOVT            R2, #0x9C37
MOVT            R12, #:upper16:dword_220E4
LDR             R0, [R5] ; fd
MOVT            LR, #0x9B37
STR             R2, [R3]
MOV             R5, #0xFFFFFFFF
MOV             R1, R3  ; addr
STR             R4, [R3,#(dword_220D8 - 0x220D4)]
STR             R4, [R3,#(dword_220DC - 0x220D4)]
MOV             R2, #0x10 ; len
STR             R4, [R3,#(dword_220E0 - 0x220D4)]
STR             R4, [R12,#(dword_220EC - 0x220E4)]
STR             R4, [R12,#(dword_220F0 - 0x220E4)]
STR             LR, [R12]
STR             R5, [R12,#(dword_220E8 - 0x220E4)]
BL              bind
CMP             R0, R5
BEQ             loc_110DC

loc_1109C
MOV             R0, R4
ADD             SP, SP, #0x14
POP             {R4,R5,PC}

loc_110A8
MOV             R0, #aSetSocketError ; "set socket error..."
BL              printf
MOV             R0, R4
ADD             SP, SP, #0x14
POP             {R4,R5,PC}

loc_110C0
MOV             R4, R0
MOV             R0, #aSocketError ; "socket error"
BL              printf
MOV             R0, R4
ADD             SP, SP, #0x14
POP             {R4,R5,PC}

loc_110DC
MOV             R0, #aBindError ; "bind error..."
BL              printf
B               loc_1109C
; End of function sub_10FE8




; int sub_110EC()
sub_110EC

addr= -0xB8
addr_len= -0xB4
s= -0xAC
var_8C= -0x8C
var_64= -0x64

PUSH            {R4-R6,LR}
SUB             SP, SP, #0xB8
MOV             R2, #0x1E ; n
MOV             R1, #0  ; c
ADD             R0, SP, #0xB8+s ; s
ADD             R6, SP, #0xB8+var_64
BL              memset
MOV             R2, #0x28 ; '(' ; n
MOV             R1, #0  ; c
ADD             R0, SP, #0xB8+var_8C ; s
BL              memset
MOV             R2, #0x64 ; 'd' ; n
MOV             R1, #0  ; c
MOV             R0, R6  ; s
BL              memset
MOVW            R0, #:lower16:aEth0 ; "eth0"
ADD             R1, SP, #0xB8+var_8C
MOVT            R0, #:upper16:aEth0 ; "eth0"
BL              sub_10AFC
CMP             R0, #0
BEQ             loc_111F4

loc_11140
MOVW            R1, #:lower16:aEth0 ; "eth0"
ADD             R0, SP, #0xB8+s
MOVT            R1, #:upper16:aEth0 ; "eth0"
BL              sub_10CC0
ADD             R0, SP, #0xB8+s ; s
BL              strlen
MOV             R2, R0  ; n
MOV             R4, R0
MOVW            R0, #:lower16:byte_220AC
ADD             R1, SP, #0xB8+s ; src
MOVT            R0, #:upper16:byte_220AC ; dest
BL              strncpy
ADD             R1, SP, #0xB8+var_8C
MOV             R0, R6
BL              stpcpy
MOV             R2, #0x2C ; ','
MOV             R5, R0
STRB            R2, [R0]
ADD             R1, SP, #0xB8+s ; src
ADD             R2, R4, #1 ; n
ADD             R0, R0, #1 ; dest
BL              memcpy
MOVW            R1, #:lower16:dword_220A4
SUB             R5, R5, R6
MOVT            R1, #:upper16:dword_220A4
MOVW            R3, #:lower16:dword_220E4
LDR             R0, [R1] ; fd
MOVT            R3, #:upper16:dword_220E4
MOV             R1, #0x10
ADD             R2, R4, R5
STR             R3, [SP,#0xB8+addr] ; addr
ADD             R2, R2, #1 ; n
STR             R1, [SP,#0xB8+addr_len] ; addr_len
MOV             R3, #0  ; flags
MOV             R1, R6  ; buf
BL              sendto
CMP             R0, #0
BLT             loc_11204
MOVW            R0, #:lower16:aSendIpmacS ; "send ipmac:\n%s\n"
MOV             R1, R6
MOVT            R0, #:upper16:aSendIpmacS ; "send ipmac:\n%s\n"
BL              printf
MOV             R0, #1
ADD             SP, SP, #0xB8
POP             {R4-R6,PC}

loc_111F4
MOV             R0, #aGetIpError ; "get IP error"
BL              puts
B               loc_11140

loc_11204
MOV             R0, #aSendError ; "send error...."
BL              printf
MOV             R0, #1
ADD             SP, SP, #0xB8
POP             {R4-R6,PC}
; End of function sub_110EC




; int __fastcall sub_1121C(void *buf)
sub_1121C
MOVW            R2, #:lower16:dword_220A4
MOVW            R3, #:lower16:dword_220E4
MOVT            R2, #:upper16:dword_220A4
PUSH            {LR}
LDR             R2, [R2]
SUB             SP, SP, #0xC ; addr
MOV             R12, #0x10
MOVT            R3, #:upper16:dword_220E4
MOV             R1, R0  ; buf
STMEA           SP, {R3,R12}
MOV             R0, R2  ; fd
MOV             R3, #0  ; flags
MOV             R2, #0xA ; n
BL              sendto
CMP             R0, #0
MOVWLT          R0, #0x16FC
MOVWGE          R0, #0x171C
MOVTLT          R0, #1
MOVTGE          R0, #1  ; format
ADD             SP, SP, #0xC
POP             {LR}
B               printf
; End of function sub_1121C




; int sub_11274()
sub_11274

timeout= -0x98
addr_len= -0x94
var_8C= -0x8C
var_88= -0x88
readfds= -0x80
var_s0=  0

PUSH            {R4-R8,LR}
MOV             R1, #0
SUB             SP, SP, #0x98
MOV             R4, R1
ADD             R2, SP, #0x98+readfds.__fds_bits+0x7C
ADD             R3, SP, #0x98+var_s0
MOV             R0, #2
STR             R1, [R3,#-0x84]!
STR             R0, [SP,#0x98+var_88]

loc_11298
STR             R4, [R3,#4]!
CMP             R3, R2
BNE             loc_11298
MOVW            R7, #:lower16:dword_220A4
MOV             R6, #1
MOVT            R7, #:upper16:dword_220A4
MOV             R1, R6  ; size
LDR             R5, [R7]
MOV             R0, #0x1E ; nmemb
CMP             R5, #0
ADD             R3, R5, #0x1F
MOVGE           R3, R5
RSBS            R2, R5, #0
AND             R2, R2, #0x1F
MOV             R3, R3,ASR#5
AND             R12, R5, #0x1F
RSBPL           R12, R2, #0
ADD             R2, SP, #0x98+var_s0
ADD             R3, R2, R3,LSL#2
LDR             R2, [R3,#-0x80]
ORR             R2, R2, R6,LSL R12
STR             R2, [R3,#-0x80]
BL              calloc
ADD             R2, SP, #0x98+var_88
MOV             R3, #0  ; exceptfds
STR             R2, [SP,#0x98+timeout] ; timeout
MOV             R8, R0
MOV             R2, R3  ; writefds
ADD             R0, R5, R6 ; nfds
ADD             R1, SP, #0x98+readfds ; readfds
BL              select
CMN             R0, #1
BEQ             loc_114A4
CMP             R0, #0
BEQ             loc_113A4
LDR             R0, [R7] ; fd
CMP             R0, #0
ADD             R3, R0, #0x1F
MOVGE           R3, R0
RSBS            R1, R0, #0
AND             R1, R1, #0x1F
MOV             R3, R3,ASR#5
AND             R2, R0, #0x1F
RSBPL           R2, R1, #0
ADD             R1, SP, #0x98+var_s0
ADD             R3, R1, R3,LSL#2
LDR             R3, [R3,#-0x80]
ANDS            R3, R3, R6,LSL R2
BNE             loc_113D4
MOV             R3, #byte_220AC
LDR             R2, [R3,#(dword_220CC - 0x220AC)]
CMP             R2, #5
BNE             loc_113C0

loc_11370
MOVW            R0, #:lower16:aTimeOut ; "Time Out"
MOV             R2, #0
MOVT            R0, #:upper16:aTimeOut ; "Time Out"
STR             R2, [R3,#(dword_220CC - 0x220AC)]
BL              puts
MOV             R0, R8  ; ptr
BL              free
MOV             R0, #1
ADD             SP, SP, #0x98
POP             {R4-R8,PC}

loc_11398
MOV             R0, #aReadError ; "read error...."
BL              printf

loc_113A4
MOV             R3, #byte_220AC
LDR             R2, [R3,#(dword_220CC - 0x220AC)]
ADD             R2, R2, #1
CMP             R2, #5
STR             R2, [R3,#(dword_220CC - 0x220AC)]
BEQ             loc_11370

loc_113C0               ; ptr
MOV             R0, R8
BL              free
MOV             R0, #0

loc_113CC
ADD             SP, SP, #0x98
POP             {R4-R8,PC}

loc_113D4
MOVW            R3, #:lower16:dword_220D4
ADD             R2, SP, #0x98+var_s0
MOV             R1, #0x10
MOVT            R3, #:upper16:dword_220D4
STR             R3, [SP,#0x98+timeout] ; addr
MOV             R3, #0  ; flags
STR             R1, [R2,#-0x8C]!
MOV             R1, R8  ; buf
STR             R2, [SP,#0x98+addr_len] ; addr_len
MOV             R2, #0x1E ; n
BL              recvfrom
CMP             R0, #0
BLE             loc_11398
MOVW            R0, #:lower16:aRevS ; "rev:\n%s\t"
MOVW            R5, #:lower16:byte_220AC
MOV             R1, R8
MOVT            R5, #:upper16:byte_220AC
MOVT            R0, #:upper16:aRevS ; "rev:\n%s\t"
BL              printf
MOV             R0, R5  ; s
STR             R4, [R5,#(dword_220CC - 0x220AC)]
BL              strlen
MOV             R1, R5  ; s2
MOV             R2, R0  ; n
MOV             R0, R8  ; s1
BL              strncmp
CMP             R0, #0
BNE             loc_11474
MOV             R0, #aSendAck1 ; "send_ack(\"1\");"
BL              printf
MOV             R0, R6
BL              sub_10F58
MOV             R0, #aOk ; "OK"
BL              sub_1121C
MOV             R0, R8  ; ptr
BL              free
MOV             R0, R6
B               loc_113CC

loc_11474
MOV             R0, #aSendAck0 ; "send_ack(\"0\");"
BL              printf
MOV             R0, #0
BL              sub_10F58
MOV             R0, #aFaild ; "FAILD"
BL              sub_1121C
MOV             R0, R8  ; ptr
BL              free
MOV             R0, #0
B               loc_113CC

loc_114A4
BL              exit
; End of function sub_11274




; int sub_114A8()
sub_114A8
PUSH            {R4-R6,LR}
MOV             R4, #5
MOV             R5, #0

loc_114B4
BL              sub_10E1C
CMP             R0, #0
BEQ             loc_1152C

loc_114C0
SUBS            R4, R4, #1
BNE             loc_114B4
CMP             R5, #5
MOV             R0, R4
POPNE           {R4-R6,PC}
BL              sub_10DA0
B               loc_114E0

loc_114DC
BL              usleep

loc_114E0
BL              sub_10E1C
CMP             R0, #0
MOV             R0, #0x3E8 ; useconds
BEQ             loc_114DC
MOVW            R5, #0x86A0
MOV             R4, #5
MOVT            R5, #1

loc_114FC
MOV             R0, #1
BL              sub_10DA0
MOV             R0, R5  ; useconds
BL              usleep
MOV             R0, #0
BL              sub_10DA0
MOV             R0, R5  ; useconds
BL              usleep
SUBS            R4, R4, #1
BNE             loc_114FC
MOV             R0, #1
POP             {R4-R6,PC}

loc_1152C               ; useconds
MOVW            R0, #0x4E20
ADD             R5, R5, #1
BL              usleep
B               loc_114C0
; End of function sub_114A8

CODE16



; int __fastcall init(int, int, int)
init
PUSH.W          {R3-R9,LR}
MOV             R7, R0
LDR             R6, =(off_21F14 - 0x1154E)
MOV             R8, R1
MOV             R9, R2
LDR             R5, =(off_21F10 - 0x11554)
ADD             R6, PC  ; off_21F14
BLX             .init_proc
ADD             R5, PC  ; off_21F10
SUBS            R6, R6, R5
ASRS            R6, R6, #2
BEQ             locret_1156C
MOVS            R4, #0

loc_1155A
ADDS            R4, #1
LDR.W           R3, [R5],#4
MOV             R2, R9
MOV             R1, R8
MOV             R0, R7
BLX             R3
CMP             R6, R4
BNE             loc_1155A

locret_1156C
POP.W           {R3-R9,PC}
; End of function init

off_11570 DCD off_21F14 - 0x1154E
off_11574 DCD off_21F10 - 0x11554
; [00000002 BYTES: COLLAPSED FUNCTION nullsub_1]
ALIGN 4
; .text ends


; Segment type: Pure code
AREA .fini, CODE
; ORG 0x1157C
CODE32



; void term_proc()
EXPORT .term_proc
.term_proc
PUSH            {R3,LR}
POP             {R3,PC}
; End of function .term_proc

; .fini ends


; Segment type: Pure data
AREA .rodata, DATA, READONLY
; ORG 0x11584
DCB    1
DCB    0
DCB    2
DCB    0
unk_11588 DCB 0x25 ; %
DCB 0x6C ; l
DCB 0x64 ; d
DCB    0
aSocket_0 DCB "socket",0
ALIGN 4
aNoSuchDeviceSN DCB ":No Such Device %s/n",0
ALIGN 4
aIoctl_0 DCB "ioctl",0
ALIGN 4
a02x02x02x02x02 DCB "%02X:%02X:%02X:%02X:%02X:%02X",0
ALIGN 4
aMac DCB "MAC=",0
ALIGN 4
word_115DC DCW 0x2C
ALIGN 0x10
aEchoDSysClassG DCB "echo %d > /sys/class/gpio/gpio%d/v"
DCB "alue",0
ALIGN 4
aSysClassGpioGp DCB "/sys/class/gpio/gpio%d",0
ALIGN 0x10
aW DCB "w",0
ALIGN 4
aSysClassGpioEx DCB "/sys/class/gpio/export",0
ALIGN 4
aOpenReadGpioEx DCB "Open read gpio/export",0
ALIGN 4
aFileWriteError DCB "File Write Error!",0
ALIGN 4
aSysClassGpioGp_0 DCB "/sys/class/gpio/gpio%d/value",0
ALIGN 4
aR DCB "r",0
ALIGN 4
aOpenReadRecove DCB "Open read recovery button failure",0
ALIGN 0x10
aSocketError DCB "socket error",0
ALIGN 0x10
aSetSocketError DCB "set socket error...",0
aBindError DCB "bind error...",0
ALIGN 4
aEth0 DCB "eth0",0
ALIGN 4
aGetIpError DCB "get IP error",0
ALIGN 4
aSendError DCB "send error....",0
ALIGN 4
aSendIpmacS DCB "send ipmac:",0xA
DCB "%s",0xA,0
aSendAckOk DCB "send ack OK!",0xA
DCB " ",0
ALIGN 4
aReadError DCB "read error....",0
ALIGN 4
aRevS DCB "rev:",0xA
DCB "%s",9,0
ALIGN 4
aSendAck1 DCB "send_ack(",0x22,"1",0x22,");",0
ALIGN 4
aOk DCB "OK",0
ALIGN 4
aSendAck0 DCB "send_ack(",0x22,"0",0x22,");",0
ALIGN 4
aFaild DCB "FAILD",0
ALIGN 4
aTimeOut DCB "Time Out",0
ALIGN 0x10
a102221 DCB "10:22:21",0
ALIGN 4
aApr162025 DCB "Apr 16 2025",0
aMonitorIpsigCo DCB "monitor-ipsig compile %s--%s",0xA,0
ALIGN 4
aKeyDown DCB "Key Down!!!!!",0
ALIGN 4
; .rodata ends


; Segment type: Pure data
AREA .ARM.exidx, DATA, READONLY
; ORG 0x117C8
unk_117C8 DCB    0
DCB 0xF2
DCB 0xFF
DCB 0x7F ; 
DCB    1
DCB    0
DCB    0
DCB    0
; .ARM.exidx ends


; Segment type: Pure data
AREA .eh_frame, DATA, READONLY
; ORG 0x117D0
DCB    0
DCB    0
DCB    0
DCB    0
; .eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
AREA .init_array, DATA
; ORG 0x21F10
off_21F10 DCD sub_10A84+1
; .init_array ends

; ELF Termination Function Table

; Segment type: Pure data
AREA .fini_array, DATA
; ORG 0x21F14
off_21F14 DCD sub_10A6C+1
; .fini_array ends

; ELF Dynamic Information

; Segment type: Pure data
AREA LOAD, DATA, ALIGN=0
; ORG 0x21F18
stru_21F18 Elf32_Dyn <1, <1>> ; DT_NEEDED libc.so.6
Elf32_Dyn <0xC, <0x10794>> ; DT_INIT
Elf32_Dyn <0xD, <0x1157C>> ; DT_FINI
Elf32_Dyn <0x19, <0x21F10>> ; DT_INIT_ARRAY
Elf32_Dyn <0x1B, <4>>   ; DT_INIT_ARRAYSZ
Elf32_Dyn <0x1A, <0x21F14>> ; DT_FINI_ARRAY
Elf32_Dyn <0x1C, <4>>   ; DT_FINI_ARRAYSZ
Elf32_Dyn <4, <0x101B4>> ; DT_HASH
Elf32_Dyn <5, <0x104D0>> ; DT_STRTAB
Elf32_Dyn <6, <0x10290>> ; DT_SYMTAB
Elf32_Dyn <0xA, <0x12B>> ; DT_STRSZ
Elf32_Dyn <0xB, <0x10>> ; DT_SYMENT
Elf32_Dyn <0x15, <0>>   ; DT_DEBUG
Elf32_Dyn <3, <0x22000>> ; DT_PLTGOT
Elf32_Dyn <2, <0x118>>  ; DT_PLTRELSZ
Elf32_Dyn <0x14, <0x11>> ; DT_PLTREL
Elf32_Dyn <0x17, <0x1067C>> ; DT_JMPREL
Elf32_Dyn <0x11, <0x10674>> ; DT_REL
Elf32_Dyn <0x12, <8>>   ; DT_RELSZ
Elf32_Dyn <0x13, <8>>   ; DT_RELENT
Elf32_Dyn <0x6FFFFFFE, <0x10644>> ; DT_VERNEED
Elf32_Dyn <0x6FFFFFFF, <1>> ; DT_VERNEEDNUM
Elf32_Dyn <0x6FFFFFF0, <0x105FC>> ; DT_VERSYM
Elf32_Dyn <0>           ; DT_NULL
ALIGN 0x40
; LOAD ends


; Segment type: Pure data
AREA .got, DATA
; ORG 0x22000
_GLOBAL_OFFSET_TABLE_ DCD stru_21F18
DCD 0
off_22008 DCD 0
calloc_ptr DCD __imp_calloc
setsockopt_ptr DCD __imp_setsockopt
printf_ptr DCD __imp_printf
__isoc99_fscanf_ptr DCD __imp___isoc99_fscanf
free_ptr DCD __imp_free
memcpy_ptr DCD __imp_memcpy
inet_ntoa_ptr DCD __imp_inet_ntoa
select_ptr DCD __imp_select
stpcpy_ptr DCD __imp_stpcpy
recvfrom_ptr DCD __imp_recvfrom
perror_ptr DCD __imp_perror
fwrite_ptr DCD __imp_fwrite
strcat_ptr DCD __imp_strcat
ioctl_ptr DCD __imp_ioctl
usleep_ptr DCD __imp_usleep
strcpy_ptr DCD __imp_strcpy
gettimeofday_ptr DCD __imp_gettimeofday
puts_ptr DCD __imp_puts
__libc_start_main_ptr DCD __imp___libc_start_main
system_ptr DCD __imp_system
__gmon_start___ptr DCD __imp___gmon_start__
exit_ptr DCD __imp_exit
strlen_ptr DCD __imp_strlen
bind_ptr DCD __imp_bind
memset_ptr DCD __imp_memset
strncpy_ptr DCD __imp_strncpy
access_ptr DCD __imp_access
fclose_ptr DCD __imp_fclose
sendto_ptr DCD __imp_sendto
sprintf_ptr DCD __imp_sprintf
fopen64_ptr DCD __imp_fopen64
socket_ptr DCD __imp_socket
strncmp_ptr DCD __imp_strncmp
abort_ptr DCD __imp_abort
close_ptr DCD __imp_close
__gmon_start___ptr_0 DCD __imp___gmon_start__
; .got ends


; Segment type: Pure data
AREA .data, DATA
; ORG 0x2209C
ALIGN 0x10
DCB    0
DCB    0
DCB    0
DCB    0
dword_220A4 DCD 0xFFFFFFFF
; .data ends


; Segment type: Uninitialized
AREA .bss, DATA
; ORG 0x220A8
byte_220A8 % 1
ALIGN 4
; char byte_220AC[32]
byte_220AC % 0x20
dword_220CC % 4
% 1
% 1
% 1
% 1
dword_220D4 % 4
dword_220D8 % 4
dword_220DC % 4
dword_220E0 % 4
dword_220E4 % 4
dword_220E8 % 4
dword_220EC % 4
dword_220F0 % 4
; .bss ends


; Segment type: Externs
; void *calloc(size_t nmemb, size_t size)
IMPORT __imp_calloc
; int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen)
IMPORT __imp_setsockopt
; int printf(const char *format, ...)
IMPORT __imp_printf
IMPORT __imp___isoc99_fscanf
; void free(void *ptr)
IMPORT __imp_free
; void *memcpy(void *dest, const void *src, size_t n)
IMPORT __imp_memcpy
; char *inet_ntoa(struct in_addr in)
IMPORT __imp_inet_ntoa
; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
IMPORT __imp_select
IMPORT __imp_stpcpy
; ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)
IMPORT __imp_recvfrom
; void perror(const char *s)
IMPORT __imp_perror
; size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)
IMPORT __imp_fwrite
; char *strcat(char *dest, const char *src)
IMPORT __imp_strcat
; int ioctl(int fd, unsigned int request, ...)
IMPORT __imp_ioctl
; int usleep(__useconds_t useconds)
IMPORT __imp_usleep
; char *strcpy(char *dest, const char *src)
IMPORT __imp_strcpy
; int gettimeofday(struct timeval *tv, __timezone_ptr_t tz)
IMPORT __imp_gettimeofday
; int puts(const char *s)
IMPORT __imp_puts
; int __libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end)
IMPORT __imp___libc_start_main
; int system(const char *command)
IMPORT __imp_system
; void exit(int status)
IMPORT __imp_exit
; size_t strlen(const char *s)
IMPORT __imp_strlen
; int bind(int fd, const struct sockaddr *addr, socklen_t len)
IMPORT __imp_bind
; void *memset(void *s, int c, size_t n)
IMPORT __imp_memset
; char *strncpy(char *dest, const char *src, size_t n)
IMPORT __imp_strncpy
; int access(const char *name, int type)
IMPORT __imp_access
; int fclose(FILE *stream)
IMPORT __imp_fclose
; ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
IMPORT __imp_sendto
; int sprintf(char *s, const char *format, ...)
IMPORT __imp_sprintf
IMPORT __imp_fopen64
; int socket(int domain, int type, int protocol)
IMPORT __imp_socket
; int strncmp(const char *s1, const char *s2, size_t n)
IMPORT __imp_strncmp
; void abort(void)
IMPORT __imp_abort
; int close(int fd)
IMPORT __imp_close
IMPORT __imp___gmon_start__, WEAK

END start
