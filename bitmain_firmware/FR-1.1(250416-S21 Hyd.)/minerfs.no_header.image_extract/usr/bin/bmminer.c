/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_121EC();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int sem_wait(sem_t *sem);
// int fsync(int fd);
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int sem_post(sem_t *sem);
// void srandom(unsigned int seed);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// size_t strcspn(const char *s, const char *reject);
// int printf(const char *format, ...);
// int truncate(const char *file, __off_t length);
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// pthread_t pthread_self(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int tolower(int c);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// __off_t lseek(int fd, __off_t offset, int whence);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// double pow(double x, double y);
// int IO_getc(_IO_FILE *fp);
// int ftell(FILE *stream);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *inet_ntoa(struct in_addr in);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// unsigned int sleep(unsigned int seconds);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// char *strdup(const char *s);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *));
// int unlink(const char *name);
// void *realloc(void *ptr, size_t size);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// struct tm *localtime_r(const time_t *timer, struct tm *tp);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
int j___xstat(int ver, const char *filename, struct stat *stat_buf);
// int _xstat(int ver, const char *filename, struct stat *stat_buf);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
int j___fxstat64();
// int _fxstat64(void); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int ioctl(int fd, unsigned int request, ...);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// float sqrtf(float x);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int gethostname(char *name, size_t len);
// int __fastcall open64(_DWORD, _DWORD, _DWORD); weak
// char *getenv(const char *name);
// int puts(const char *s);
// int sysinfo(struct sysinfo *info);
// void *malloc(size_t size);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
// struct tm *localtime(const time_t *timer);
// int _gmon_start__(void); weak
// int sem_trywait(sem_t *sem);
// int open(const char *file, int oflag, ...);
// int __fastcall timerfd_create(_DWORD, _DWORD); weak
// int rename(const char *old, const char *new);
// const unsigned __int16 **_ctype_b_loc(void);
// __pid_t getpid(void);
// void exit(int status);
// int syscall(int sysno, ...);
// int feof(FILE *stream);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// int round(void); weak
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// char *strchr(const char *s, int c);
// int pthread_setcanceltype(int type, int *oldtype);
// int fprintf(FILE *stream, const char *format, ...);
// int mkstemp(char *template);
// int fcntl(int fd, int cmd, ...);
// double sqrt(double x);
// int pthread_attr_init(pthread_attr_t *attr);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
int j___cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
// int _cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// char *_strdup(const char *s);
// int mkdir(const char *path, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// void *memset(void *s, int c, size_t n);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int putchar(int c);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// struct tm *gmtime(const time_t *timer);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// ssize_t write(int fd, const void *buf, size_t n);
// int fileno(FILE *stream);
// int access(const char *name, int type);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
// int pthread_setspecific(pthread_key_t key, const void *pointer);
// int sigemptyset(sigset_t *set);
// FILE *popen(const char *command, const char *modes);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// void errx(int status, const char *format, ...);
// int glob(const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t *pglob);
// int toupper(int c);
// char *strrchr(const char *s, int c);
// int listen(int fd, int n);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int pthread_join(pthread_t th, void **thread_return);
// int __fastcall lldiv(_DWORD); weak
// int fputc(int c, FILE *stream);
// void syslog(int pri, const char *fmt, ...);
// int sscanf(const char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// void openlog(const char *ident, int option, int facility);
// int __fastcall timerfd_settime(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int remove(const char *filename);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int atoi(const char *nptr);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *strpbrk(const char *s, const char *accept);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int socket(int domain, int type, int protocol);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// in_addr_t inet_addr(const char *cp);
// int random(void);
// void pthread_testcancel(void);
// struct hostent *gethostbyname(const char *name);
// int fseek(FILE *stream, int off, int whence);
// char *strncat(char *dest, const char *src, size_t n);
// int sem_destroy(sem_t *sem);
int j___xstat64();
// int _xstat64(void); weak
// int isatty(int fd);
// int fputs(const char *s, FILE *stream);
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int __fastcall epoll_create1(_DWORD); weak
// int close(int fd);
int j___lxstat64();
// int _lxstat64(void); weak
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// void globfree(glob_t *pglob);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// void *pthread_getspecific(pthread_key_t key);
// int pclose(FILE *stream);
int __fastcall sub_12A90(_DWORD *a1);
int __fastcall sub_13118(_DWORD *a1);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_164DC();
int *sub_16500();
__int64 sub_16524();
int *sub_16550();
void sub_1656C();
int __fastcall sub_165E8(unsigned int a1, int a2);
int sub_1680C();
int __fastcall sub_168B4(int a1);
int sub_169E4();
int sub_16C98();
int sub_16CFC();
int sub_16D68();
int sub_16DCC();
int sub_16E30();
int __fastcall sub_170EC(int a1, int a2);
int __fastcall sub_1712C(int a1, int a2, int a3, int a4, _BYTE *a5);
int __fastcall sub_172A4(int a1, int a2, unsigned int a3, int a4, char a5);
int __fastcall sub_1759C(int a1, int a2, unsigned int a3, int a4, char a5);
int sub_175A8();
int __fastcall sub_175C8(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_1788C(int a1);
int __fastcall sub_17E94(int a1, int a2, int a3);
int __fastcall sub_17FD4(int a1, int a2, int a3);
int __fastcall sub_18068(int a1, int a2, int a3);
const char *__fastcall sub_18120(int a1, int a2);
int __fastcall sub_18160(char a1);
int sub_1818C();
int __fastcall sub_1819C(int a1);
void sub_181EC();
void sub_18200();
void sub_18214();
void sub_18228();
void sub_1823C();
int sub_18250();
void sub_18260();
void sub_18274();
int sub_1828C();
int sub_18310();
int sub_18394();
int sub_18600();
int sub_18954();
int sub_18A14();
int __fastcall sub_18AE4(int a1);
int __fastcall sub_18BC4(int a1, int a2);
int __fastcall sub_18C08(int a1, int a2);
int __fastcall sub_18C14(int a1, int a2);
void sub_18C20();
void sub_18C34();
int __fastcall sub_18C48(int a1, int a2);
int __fastcall sub_18CB4(int a1);
int __fastcall sub_18CFC(int a1, int a2);
int __fastcall sub_18D08(int a1, int a2);
int __fastcall sub_18D48(int a1, int a2);
int __fastcall sub_18DB8(int a1);
int __fastcall sub_18E08(int a1);
int sub_18E58();
int sub_18EBC();
int sub_18F28();
int sub_18F94();
int __fastcall sub_1901C(int a1, int a2);
int __fastcall sub_19068(int a1, int a2);
int __fastcall sub_190B4(int a1, int a2);
int __fastcall sub_190CC(int a1, unsigned int a2);
int __fastcall sub_19194(int a1);
int __fastcall sub_191C8(int a1);
int __fastcall sub_19220(int a1);
int __fastcall sub_19234(int a1);
int __fastcall sub_19294(int a1);
int __fastcall sub_192A8(int a1);
int __fastcall sub_19308(int a1, unsigned int a2);
int __fastcall sub_193D0(int a1);
int sub_19404();
int __fastcall sub_19438(int a1);
int sub_1944C();
int __fastcall sub_19484(int a1);
int sub_19498();
int __fastcall sub_194D0(int a1);
int __fastcall sub_194E4(int a1);
int sub_194F8();
int sub_19530();
int sub_1957C();
int __fastcall sub_1AF60(const char *a1);
int sub_1B8F8();
int sub_1BD64();
int sub_1BD6C();
int __fastcall sub_1BDB4(int result, char *a2, unsigned int a3);
int __fastcall sub_1BEA4(int a1);
int __fastcall sub_1BF3C(int a1);
int sub_1BFD4();
int __fastcall sub_1BFDC(int a1);
int __fastcall sub_1C070(int a1, int a2, int *a3);
int __fastcall sub_1C4E8(int a1, int a2);
int __fastcall sub_1CAAC(int a1, int a2, int *a3);
int __fastcall sub_1CDF0(int a1, int *a2);
int __fastcall sub_1CE9C(int a1, int *a2);
int __fastcall sub_1CF48(int a1, char *a2, unsigned int a3);
int __fastcall sub_1D048(int a1, int a2, int *a3);
int __fastcall sub_1D104(int a1, int a2);
int sub_1D210();
int sub_1D218();
int __fastcall sub_1D220(unsigned int a1, int a2);
int __fastcall sub_1D3AC(unsigned int a1, int a2);
int __fastcall sub_1D538(unsigned int a1, int a2);
int __fastcall sub_1D6C8(unsigned int a1);
_DWORD *__fastcall sub_1D700(int a1, int a2);
_DWORD *__fastcall sub_1D7FC(int a1);
int __fastcall sub_1D858(int a1);
int __fastcall sub_1D864(int a1);
int __fastcall sub_1D874(int a1, char a2);
int __fastcall sub_1D8A0(int a1);
int __fastcall sub_1D8B0(int a1, char a2);
int sub_1D8E0();
int __fastcall sub_1D8E8(int a1);
int __fastcall sub_1D8F4(int a1, char a2);
int __fastcall sub_1D904(int a1);
int __fastcall sub_1D910(int a1, char a2);
int __fastcall sub_1D920(int a1);
int __fastcall sub_1D92C(int a1, char a2);
int __fastcall sub_1D93C(int a1);
int __fastcall sub_1D948(int a1, char a2);
int __fastcall sub_1D958(int a1);
int __fastcall sub_1D964(int a1, char a2);
int __fastcall sub_1D974(int a1);
int __fastcall sub_1D980(int a1, char a2);
int __fastcall sub_1D990(int a1);
int __fastcall sub_1D99C(int a1, char a2);
int __fastcall sub_1D9AC(int a1);
int __fastcall sub_1D9B8(int a1, char a2);
int __fastcall sub_1D9C8(int a1);
int __fastcall sub_1D9D4(int a1, __int16 a2);
int __fastcall sub_1D9E4(int a1);
int __fastcall sub_1D9F0(int a1, __int16 a2);
int __fastcall sub_1DA00(int a1);
int __fastcall sub_1DA0C(int a1, __int16 a2);
int __fastcall sub_1DA1C(int a1);
int __fastcall sub_1DA28(int a1, __int16 a2);
int __fastcall sub_1DA38(int a1);
int __fastcall sub_1DA44(int a1, __int16 a2);
int __fastcall sub_1DA54(int a1);
int __fastcall sub_1DA60(int a1, char a2);
int __fastcall sub_1DA70(int a1);
int __fastcall sub_1DA7C(int a1, char a2);
int __fastcall sub_1DA8C(int a1);
int __fastcall sub_1DA98(int a1, char a2);
int __fastcall sub_1DAA8(int a1);
int __fastcall sub_1DAB4(int a1, char a2);
int __fastcall sub_1DAC4(int a1);
int __fastcall sub_1DAD0(int a1, __int16 a2);
int __fastcall sub_1DAE0(int a1);
int __fastcall sub_1DAEC(int a1, __int16 a2);
int __fastcall sub_1DAFC(int a1);
int __fastcall sub_1DB08(int a1, char a2);
int __fastcall sub_1DB18(int a1);
int __fastcall sub_1DB24(int a1, char a2);
char *__fastcall sub_1DB34(int a1);
int __fastcall sub_1E734(int a1, const void *a2, size_t *a3);
int __fastcall sub_1E764(int a1, void *dest, size_t *a3);
int __fastcall sub_1E798(int a1, const void *a2, size_t *a3);
int __fastcall sub_1E7C8(int a1, void *dest, size_t *a3);
int __fastcall sub_1E7FC(int a1, const void *a2, size_t *a3);
int __fastcall sub_1E82C(int a1, void *dest, size_t *a3);
int __fastcall sub_1E860(int a1, const void *a2, size_t *a3);
int __fastcall sub_1E890(int a1, void *dest, size_t *a3);
int __fastcall sub_1E8C4(int a1, const void *a2, size_t *a3);
int __fastcall sub_1E8F4(int a1, void *dest, size_t *a3);
int __fastcall sub_1E928(int a1, const void *a2, size_t *a3);
int __fastcall sub_1E958(int a1, void *dest, size_t *a3);
int __fastcall sub_1E98C(int a1, const void *a2, size_t *a3);
int __fastcall sub_1E9BC(int a1, void *dest, size_t *a3);
int __fastcall sub_1E9F0(int a1, const void *a2, size_t *a3);
int __fastcall sub_1EA20(int a1, void *dest, size_t *a3);
int __fastcall sub_1EA54(int a1, const void *a2, size_t *a3);
int __fastcall sub_1EA84(int a1, void *dest, size_t *a3);
int __fastcall sub_1EAB8(int a1, void *a2, int *a3, _DWORD *a4);
int __fastcall sub_1EC04(int a1, _DWORD *a2, int *a3, _DWORD *a4);
int __fastcall sub_1ED60(int a1, _WORD *a2, int *a3, _DWORD *a4);
int __fastcall sub_1F09C(int a1, unsigned __int8 *src, size_t n, unsigned int a4);
char *sub_1F534();
void __fastcall sub_1F590(_DWORD *a1);
_DWORD *sub_1F5D4();
int __fastcall sub_1F62C(int a1);
int __fastcall sub_1F638(int a1);
int __fastcall sub_1F648(int a1, char a2);
int __fastcall sub_1F674(int a1);
int __fastcall sub_1F684(int a1, char a2);
int sub_1F6B4();
int __fastcall sub_1F6BC(int a1);
int __fastcall sub_1F6C8(int a1, char a2);
int __fastcall sub_1F6D8(int a1);
int __fastcall sub_1F6E4(int a1, char a2);
int __fastcall sub_1F6F4(int a1);
int __fastcall sub_1F700(int a1, char a2);
int __fastcall sub_1F710(int a1);
int __fastcall sub_1F71C(int a1, char a2);
int __fastcall sub_1F72C(int a1);
int __fastcall sub_1F738(int a1, char a2);
int __fastcall sub_1F748(int a1);
int __fastcall sub_1F754(int a1, char a2);
int __fastcall sub_1F764(int a1);
int __fastcall sub_1F770(int a1, char a2);
int __fastcall sub_1F780(int a1);
int __fastcall sub_1F78C(int a1, char a2);
int __fastcall sub_1F79C(int a1);
int __fastcall sub_1F7A8(int a1, __int16 a2);
int __fastcall sub_1F7B8(int a1);
int __fastcall sub_1F7C4(int a1, __int16 a2);
int __fastcall sub_1F7D4(int a1);
int __fastcall sub_1F7E0(int a1, __int16 a2);
int __fastcall sub_1F7F0(int a1);
int __fastcall sub_1F7FC(int a1, __int16 a2);
int __fastcall sub_1F80C(int a1);
int __fastcall sub_1F818(int a1, __int16 a2);
int __fastcall sub_1F828(int a1);
int __fastcall sub_1F834(int a1, char a2);
int __fastcall sub_1F844(int a1);
int __fastcall sub_1F850(int a1, char a2);
int __fastcall sub_1F860(int a1);
int __fastcall sub_1F86C(int a1, char a2);
int __fastcall sub_1F87C(int a1);
int __fastcall sub_1F888(int a1, char a2);
int __fastcall sub_1F898(int a1);
int __fastcall sub_1F8A4(int a1, __int16 a2);
int __fastcall sub_1F8B4(int a1);
int __fastcall sub_1F8C0(int a1, __int16 a2);
int __fastcall sub_1F8D0(int a1);
int __fastcall sub_1F8DC(int a1, char a2);
int __fastcall sub_1F8EC(int a1);
int __fastcall sub_1F8F8(int a1, char a2);
char *__fastcall sub_1F908(char *result);
int __fastcall sub_20398(int a1, const void *a2, size_t *a3);
int __fastcall sub_203C8(int a1, void *dest, size_t *a3);
int __fastcall sub_203FC(int a1, const void *a2, size_t *a3);
int __fastcall sub_2042C(int a1, void *dest, size_t *a3);
int __fastcall sub_20460(int a1, const void *a2, size_t *a3);
int __fastcall sub_20490(int a1, void *dest, size_t *a3);
int __fastcall sub_204C4(int a1, const void *a2, size_t *a3);
int __fastcall sub_204F4(int a1, void *dest, size_t *a3);
int __fastcall sub_20528(int a1, const void *a2, size_t *a3);
int __fastcall sub_20558(int a1, void *dest, size_t *a3);
int __fastcall sub_2058C(int a1, const void *a2, size_t *a3);
int __fastcall sub_205BC(int a1, void *dest, size_t *a3);
int __fastcall sub_205F0(int a1, const void *a2, size_t *a3);
int __fastcall sub_20620(int a1, void *dest, size_t *a3);
int __fastcall sub_20654(int a1, const void *a2, size_t *a3);
int __fastcall sub_20684(int a1, void *dest, size_t *a3);
int __fastcall sub_206B8(int a1, const void *a2, size_t *a3);
int __fastcall sub_206E8(int a1, void *dest, size_t *a3);
int __fastcall sub_2071C(int a1, void *a2, int *a3, _DWORD *a4);
int __fastcall sub_20868(int a1, _DWORD *a2, int *a3, _DWORD *a4);
int __fastcall sub_209C4(int a1, _WORD *a2, int *a3, _DWORD *a4);
int __fastcall sub_20E10(int a1, unsigned __int8 *src, size_t n, unsigned int a4);
char *sub_2128C();
void __fastcall sub_212E8(_DWORD *a1);
_DWORD *sub_2132C();
int sub_21384();
int sub_213E0();
_DWORD *__fastcall sub_2143C(_DWORD *result, _DWORD *a2, int a3);
char *__fastcall sub_21464(int a1);
int __fastcall sub_2150C(int a1, int a2, int a3, int a4);
int __fastcall sub_215C4(int a1, int a2, int a3, int a4);
int __fastcall sub_2167C(int result, char a2, int a3);
int __fastcall sub_21730(int result);
int sub_21740();
int __fastcall sub_21750(int result, int a2, int a3);
int __fastcall sub_218B4(int result, int a2, int a3);
bool __fastcall sub_21A1C(unsigned __int8 a1);
int __fastcall sub_21A38(_DWORD); // weak
bool __fastcall sub_21A3C(unsigned __int8 a1);
int __fastcall sub_21A54(int a1);
unsigned int __fastcall sub_21B08(unsigned int result, int a2);
int sub_21BA8();
int sub_21C78();
int sub_21D18();
int sub_21DB8();
int sub_21DC8();
int __fastcall sub_21E88(int a1, unsigned int a2);
int __fastcall sub_21F98(int a1);
int sub_2242C();
int sub_2243C();
int sub_226B4();
bool sub_226E8();
bool sub_2270C();
int __fastcall sub_22730(int a1, int a2);
int __fastcall sub_22740(_DWORD *a1, _DWORD *a2);
unsigned int *__fastcall sub_22750(unsigned int *a1, unsigned int *a2, unsigned int *a3, _DWORD *a4);
int __fastcall sub_227C4(int a1, unsigned int *a2, int a3);
int __fastcall sub_229E0(int a1);
int sub_22A64();
int sub_22C10();
int __fastcall sub_22E18(int a1);
int sub_22EC0();
int sub_23180();
int __fastcall sub_23188(int result);
int __fastcall sub_23314(int a1, int a2);
int __fastcall nullsub_3(_DWORD, _DWORD); // weak
int __fastcall sub_23328(int a1, unsigned int *a2, unsigned int *a3, _DWORD *a4, int a5, size_t *a6, unsigned int *a7);
void __fastcall sub_23590(int a1, unsigned int a2, int a3);
int __fastcall sub_23998(unsigned int a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6, char a7);
int __fastcall sub_24238(int a1, int a2, unsigned int a3, unsigned int a4, char a5, int a6);
int __fastcall sub_244C0(int a1, int a2, unsigned int *a3, int a4, unsigned int *a5, int a6, unsigned __int8 a7, int a8);
unsigned int __fastcall sub_246E8(int a1, unsigned int a2, int a3);
int __fastcall sub_24974(int a1, unsigned int a2, int a3);
int __fastcall sub_24A50(int a1, int a2, unsigned int a3, int a4);
int sub_24BC4();
int __fastcall sub_24C5C(unsigned int a1, unsigned int a2, int a3);
unsigned int __fastcall sub_24DC4(signed int a1, signed int a2, int a3, int a4, unsigned __int8 a5);
unsigned int __fastcall sub_25260(int a1, int a2, int a3, int a4);
int __fastcall sub_2565C(signed int *a1, int a2, int a3);
int __fastcall sub_25724(int a1, int a2);
int __fastcall sub_257E0(int result, int a2);
int __fastcall sub_258B8(int a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6);
int __fastcall sub_25BF0(_DWORD *a1);
void __fastcall sub_25D60(int a1);
int __fastcall sub_25E6C(_DWORD *a1);
int __fastcall sub_26448(_DWORD *a1);
int __fastcall sub_269A0(_DWORD *a1);
int __fastcall sub_26ECC(_DWORD *a1);
int __fastcall sub_27230(const char *a1);
int __fastcall sub_27404(int result);
int __fastcall sub_276A8(int a1, const char *a2);
int sub_27CEC();
int sub_27CFC();
int sub_27D0C();
int sub_27D1C();
int sub_27D2C();
int sub_27D3C();
int sub_27D4C();
int sub_27D5C();
int sub_27D6C();
int sub_27D7C();
int sub_27D8C();
int sub_27D9C();
int __fastcall sub_27DAC(int a1);
int sub_27DC8();
int __fastcall sub_27DD8(int a1);
int __fastcall sub_27DF4(int a1);
int __fastcall sub_27E10(int a1);
int __fastcall sub_27E2C(int a1, int a2);
int sub_27EB8();
int __fastcall sub_27EC8(int a1);
int sub_27EE0();
void sub_27EF4();
int sub_27F04();
void sub_27F18();
int sub_27F28();
int sub_27F38();
int __fastcall sub_27F7C(int a1, int a2);
int __fastcall sub_28000(int a1, int a2);
int __fastcall sub_28068(int a1);
int __fastcall sub_280C8(char a1);
int sub_280DC();
int __fastcall sub_280EC(int a1);
int __fastcall sub_28158(int result);
int __fastcall sub_281C8(int a1);
int __fastcall sub_28238(int a1, char a2);
int __fastcall sub_282A4(int a1);
int __fastcall sub_28308(int a1);
int __fastcall sub_28378(int a1, int a2);
int __fastcall sub_283E4(int a1);
int __fastcall sub_28448(int a1, int a2, char a3);
int __fastcall sub_284BC(unsigned int a1, char *s);
int __fastcall sub_28544(unsigned int a1, void *src);
int __fastcall sub_285C4(int a1);
int sub_28618();
int __fastcall sub_28628(int a1);
int sub_28644();
int sub_28654();
int sub_28664();
int sub_28674();
void sub_28684();
int sub_28694();
int sub_286A4();
int sub_286B4();
void __fastcall sub_286C4(int a1);
int sub_286DC();
int sub_28744();
int sub_28758();
int __fastcall sub_2876C(int a1, int a2);
int __fastcall sub_2878C(int a1);
int sub_287A0();
int sub_287B0();
int sub_287B8();
int sub_287C0();
void sub_287D4();
int sub_287E4();
void sub_287F4();
void sub_28804();
int sub_29C30();
int sub_29C40();
int sub_29C50();
int sub_29C60();
int sub_29C70();
int sub_29C80();
int sub_29C90();
int sub_29CA0();
int sub_29CB0();
int sub_29CC0();
char *__fastcall sub_29CD0(int a1);
int __fastcall sub_29CEC(int a1);
char *__fastcall sub_29D04(int a1);
int __fastcall sub_29D20(int a1);
int __fastcall sub_29D38(int a1);
int __fastcall sub_29D50(int a1);
int __fastcall sub_29D68(int a1);
int __fastcall sub_29D80(int a1);
int __fastcall sub_29D98(int a1);
int __fastcall sub_29DB0(int a1);
int __fastcall sub_29DC4(int a1);
int sub_29DD8();
int sub_29DE8();
int __fastcall sub_29DF8(int a1);
int __fastcall sub_29E0C(int a1, int a2);
int __fastcall sub_29E30(int a1, int a2);
int __fastcall sub_29E54(int a1, int a2);
int __fastcall sub_29E78(int a1, int a2);
int sub_29E90();
int sub_29EA0();
int sub_29EB0();
int __fastcall sub_29EF4(unsigned int a1, unsigned int a2);
int __fastcall sub_29EFC(unsigned int a1, unsigned int a2);
int __fastcall sub_29F04(unsigned int a1);
int __fastcall sub_29F0C(unsigned int a1);
int __fastcall sub_29F58(int a1, unsigned int a2, int a3, char a4);
int __fastcall sub_29FC4(int a1);
int __fastcall sub_2A014(unsigned int a1);
int __fastcall sub_2A05C(__int16 a1);
int sub_2A0B4();
int __fastcall sub_2A220(int a1, int a2, char a3, char a4);
int sub_2A338();
int sub_2A364();
int __fastcall sub_2A44C(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_2A514(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17);
int __fastcall sub_2A5DC(int a1, int a2);
int __fastcall sub_2A628(int a1, char a2, char a3, char a4);
int __fastcall sub_2A680(int a1);
int sub_2A6C8();
int __fastcall sub_2A728(int a1, int a2);
int __fastcall sub_2A7AC(int a1, int a2, unsigned int a3, unsigned int a4, int a5, unsigned __int16 a6);
int __fastcall sub_2A834(int a1, int a2);
int __fastcall sub_2A894(int a1);
int __fastcall sub_2A8DC(unsigned __int8 a1, unsigned int a2);
int __fastcall sub_2A8E4(char a1);
int __fastcall sub_2A92C(char a1);
unsigned int __fastcall sub_2A974(int a1);
int __fastcall sub_2AA4C(int a1);
int __fastcall sub_2AA9C(int a1, const char *a2, unsigned int a3);
int __fastcall sub_2AB98(int a1, unsigned int a2);
int sub_2ADB0();
int sub_2AE18();
int __fastcall sub_2AE4C(int result);
int __fastcall sub_2AEF4(int result);
int __fastcall sub_2AF9C(int result);
int __fastcall sub_2B044(int result);
int __fastcall sub_2B12C(int result);
int __fastcall sub_2B23C(int result);
int __fastcall sub_2B324(int result);
int __fastcall sub_2B414(int result);
int __fastcall sub_2B4E8(int result);
int __fastcall sub_2B6B8(int result);
int __fastcall sub_2B8CC(int result);
int __fastcall sub_2BA54(int result, unsigned int a2);
int __fastcall sub_2BB18(int result, unsigned int a2);
int __fastcall sub_2BC24(int result, unsigned int a2);
int __fastcall sub_2BD30(int result, unsigned int a2);
void *__fastcall sub_2BDF4(_DWORD *a1, unsigned int a2);
int __fastcall sub_2BEE8(int result, unsigned int a2);
int __fastcall sub_2C278(int result, unsigned int a2);
int __fastcall sub_2C474(int result, unsigned int a2);
int __fastcall sub_2C5D8(int result, unsigned int a2);
int __fastcall sub_2C768(int result, unsigned int a2);
int __fastcall sub_2C82C(int result, unsigned int a2);
int __fastcall sub_2C8F4(int result, unsigned int a2);
void *__fastcall sub_2C9C8(_DWORD *a1, unsigned int a2);
int __fastcall sub_2CAC4(_DWORD *a1, int a2);
int __fastcall sub_2CB10(_DWORD *a1, int a2);
int __fastcall sub_2CB70(_DWORD *a1, int a2);
int __fastcall sub_2CBBC(_DWORD *a1, int a2);
int __fastcall sub_2CC14(_DWORD *a1, int a2);
char __fastcall sub_2CC60(char result);
char __fastcall sub_2CC78(char result);
char __fastcall sub_2CC90(char result);
char __fastcall sub_2CCA8(char result);
int __fastcall sub_2CCC0(_DWORD *a1);
int __fastcall sub_2CD44(int result);
int __fastcall sub_2CDEC(int result);
int __fastcall sub_2CE98(int result);
int __fastcall sub_2CF40(int result);
void __fastcall sub_2D120(void *a1);
void __fastcall sub_2D490(void *a1);
_DWORD *__fastcall sub_2D96C(_DWORD *result);
int __fastcall sub_2D9E0(_DWORD *a1, unsigned int *a2);
int *__fastcall sub_2FE40(int *result, unsigned int *a2, signed int a3);
int *__fastcall sub_2FF0C(int *result, unsigned int *a2, signed int a3);
int *__fastcall sub_2FF18(int a1, _BYTE *a2);
int *__fastcall sub_300CC(unsigned int *a1, signed int a2, _BYTE *a3);
int __fastcall sub_30174(char *a1, size_t a2, int a3);
int __fastcall sub_30210(const char *a1, int a2, size_t a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void __fastcall sub_30D40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int __fastcall sub_31B08(char *a1);
_BYTE *__fastcall sub_31C08(_BYTE *result, int a2, int a3);
void *sub_31C4C();
ssize_t __fastcall sub_31C80(char **a1, int fd, __int64 *a3);
ssize_t __fastcall sub_31E1C(int a1, int a2, __int64 *a3);
int __fastcall sub_31E38(int a1, _BYTE *a2);
int __fastcall sub_31E68(int result);
_DWORD *__fastcall sub_31EA0(_DWORD *result, int a2);
int __fastcall sub_31EB0(int a1, int a2);
int __fastcall sub_31EF8(int a1);
int __fastcall sub_31F34(int result);
_DWORD *__fastcall sub_31F40(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_31F70(_DWORD *a1, int a2);
bool __fastcall sub_31F88(int a1, __int64 a2);
_DWORD *__fastcall sub_31FAC(_DWORD *result);
int __fastcall sub_32008(int result, int a2);
int __fastcall sub_3202C(int a1, __int64 *a2, int a3, int a4, char a5, char a6);
_DWORD *__fastcall sub_32630(_DWORD *a1, int a2);
_DWORD *__fastcall sub_32698(_DWORD *a1, int a2, int a3);
int __fastcall sub_32828(void **a1, int a2, int a3, int a4);
void *__fastcall sub_328BC(_DWORD *a1, int a2);
int __fastcall sub_32910(int fd, struct sockaddr *addr, char *cp, unsigned int a4);
bool __fastcall sub_32968(_DWORD *a1);
_DWORD *__fastcall sub_329B8(_DWORD *result);
void *__fastcall sub_329F8(_DWORD *a1);
int __fastcall sub_32A58(int result, int a2);
int __fastcall sub_32A60(int a1);
size_t __fastcall sub_32B3C(char *a1);
size_t __fastcall sub_32B78(int a1);
int __fastcall sub_32BA4(int result, int a2);
int __fastcall sub_32BAC(int a1, char *a2);
int __fastcall sub_32C6C(int a1, char *a2);
int __fastcall sub_32C7C(int a1);
int __fastcall sub_32C90(int a1);
int __fastcall sub_32D20(int a1, unsigned __int8 a2);
int __fastcall sub_32F30(int a1, _DWORD *a2, _DWORD *a3, int *a4);
int __fastcall sub_32FAC(_DWORD *a1, _DWORD *a2, _DWORD *a3, int *a4);
_DWORD *__fastcall sub_330B8(_DWORD *a1, _DWORD *a2, char *s);
int __fastcall sub_331B8(int a1);
int __fastcall sub_331C0(int result, int a2);
int __fastcall sub_331C8(int a1);
char *__fastcall sub_331D4(char *result);
int __fastcall sub_332FC(int result, int a2);
_DWORD *__fastcall sub_3332C(_DWORD *result, _DWORD *a2);
_DWORD *sub_33364();
_DWORD *__fastcall sub_333A8(int *a1, int a2, int a3);
int __fastcall sub_33400(int result, int a2);
int __fastcall sub_33414(int result, int a2, int a3);
__int64 __fastcall sub_3341C(void **a1, signed int size, _QWORD *a3);
void *__fastcall sub_33488(void **a1, const void *a2, size_t a3);
int sub_33540(int a1, const char *a2, ...);
int __fastcall sub_3364C(int a1, int *a2, int a3);
int __fastcall sub_336C4(int a1, int *a2, int a3);
int __fastcall sub_3375C(int a1, _DWORD *a2, int *a3);
int __fastcall sub_337D0(int a1, int *a2);
int __fastcall sub_33834(_DWORD *a1);
int __fastcall sub_33B00(int a1, int a2, const char *a3);
_DWORD *__fastcall sub_33B64(int a1);
_DWORD *__fastcall sub_33C94(int a1, int a2);
int __fastcall sub_33DC8(int a1);
int __fastcall sub_33DFC(_DWORD *a1);
char *__fastcall sub_33E88(int a1, int a2);
void __fastcall __noreturn sub_33EFC(int a1, char *a2);
void __fastcall __noreturn sub_33F3C(int a1);
void __noreturn sub_33F48();
int __fastcall sub_33F6C(int *a1);
void __fastcall sub_33FB0(int a1);
void __fastcall sub_33FE0(int a1);
void __fastcall sub_34020(int a1);
void __fastcall sub_340A8(int a1);
int __fastcall sub_340F0(_DWORD *a1);
int __fastcall sub_34194(int a1);
int __fastcall sub_34240(int a1);
int __fastcall sub_34248(int a1);
void sub_3427C();
int sub_34324();
char *__fastcall sub_34458(const char *a1);
int __fastcall sub_3499C(char *a1);
int sub_34A78();
int sub_35078();
void __fastcall sub_35220(int a1);
int sub_35A10();
void __noreturn sub_35C78();
time_t sub_35D88();
int sub_35DF8();
time_t sub_36010();
void sub_36040();
int sub_36470();
void __noreturn sub_3669C();
time_t sub_36B94();
signed int sub_36BCC();
void sub_36C28();
int sub_36E98();
int sub_36EB0();
void __noreturn sub_375A0();
int __fastcall sub_37918(int a1, int a2);
int __fastcall sub_37960(int a1, int a2);
int sub_37A3C();
int sub_37BE0();
int sub_37D24();
int sub_37FF4();
int sub_380A8();
int sub_383B0();
int sub_384C4();
int sub_385D8();
int sub_386EC();
int sub_38800();
int sub_38914();
void sub_38A28();
void sub_38AC8();
void sub_38B68();
void sub_38C08();
void sub_38CA8();
void sub_38D48();
int __fastcall sub_38DE8(signed int a1, int a2);
int sub_38E70();
int __fastcall sub_38E90(const void *a1, size_t a2);
int __fastcall sub_38EC4(const void *a1, size_t a2);
int sub_38EF8();
int __fastcall sub_38F80(int a1);
int __fastcall sub_38FA8(_BYTE *a1);
void __noreturn sub_38FC4(const char *a1, ...);
int __fastcall sub_3900C(int a1);
int __fastcall sub_39024(int a1);
int __fastcall sub_3903C(int a1);
int __fastcall sub_39054(int a1);
void __fastcall __noreturn sub_3906C(const char *a1);
int sub_390C4();
void __fastcall __noreturn sub_395F4(int a1);
const char *__fastcall sub_396E8(const char *a1, int a2);
char *__fastcall sub_39830(_DWORD *a1, int a2, int a3);
char *__fastcall sub_39BCC(const char *a1, _DWORD *a2);
char *__fastcall sub_39BFC(const char *a1, _DWORD *a2);
char *__fastcall sub_39C28(const char *a1, _DWORD *a2);
int __fastcall sub_39C5C(const char *a1, const char *a2, int a3);
int __fastcall sub_39CA4(const char *a1, int a2);
int __fastcall sub_39D00(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_39D74(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_39DE8(const char *a1, int a2);
int __fastcall sub_39E44(const char *a1, int a2);
int __fastcall sub_39EA0(const char *a1, int a2);
int __fastcall sub_39EFC(int a1, const char *a2, int a3);
_DWORD *sub_39F40();
char *__fastcall sub_3A16C(const char *a1, _DWORD *a2, int a3, int a4);
int __fastcall sub_3A1B8(const char *a1, _DWORD *a2, _DWORD *a3);
char *__fastcall sub_3A1E8(char *a1);
int sub_3A2E4();
void *__fastcall sub_3A36C(void *a1);
__int64 __fastcall sub_3A614(int a1, int a2);
void *__fastcall sub_3B08C(void **a1);
void __fastcall sub_3B0C8(void ***a1, const char *a2, const char *a3, int a4);
int __fastcall sub_3B14C(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6);
int __fastcall sub_3B2AC(int a1);
int __fastcall nullsub_1(_DWORD); // weak
time_t sub_3B468();
int sub_3B578();
char *__fastcall sub_3BBB4(size_t *a1, const char **a2, int a3, char a4);
int __fastcall sub_3BD58(int a1, const char **a2, int a3, char a4);
void sub_3BE0C();
int __fastcall sub_3BE68(const char *a1);
int sub_3BFBC();
int __fastcall sub_3C094(const char *a1, int a2);
size_t __fastcall sub_3C12C(int a1, int a2);
int __fastcall sub_3C190(_DWORD *a1, int a2, int a3);
int sub_3C444();
int __fastcall sub_3C480(const void *a1, unsigned int a2);
size_t __fastcall sub_3C980(int *a1);
int __fastcall sub_3CAC4(const char *a1, size_t n);
int __fastcall sub_3CCC4(int a1, int a2);
int __fastcall sub_3CDAC(int a1, const char **a2);
unsigned int sub_3CF98();
int sub_3D02C();
int __fastcall sub_3D1E0(char *a1);
int __fastcall sub_3D5B4(char *a1);
int sub_3DE28();
int sub_3DE60();
int __fastcall sub_3DE98(int a1, int a2);
int __fastcall sub_3E1FC(int a1, int a2);
int __fastcall sub_3E42C(int a1, int a2, int a3);
int __fastcall sub_3E690(int a1, int a2, int a3, int a4);
_BYTE *__fastcall sub_3EBCC(_BYTE *result);
int __fastcall sub_3EFDC(__int64 *a1);
int sub_3F36C();
int __fastcall sub_3F570(int a1, unsigned int a2);
int __fastcall sub_3F63C(unsigned int a1, unsigned int a2);
int sub_3F660();
char *sub_3F82C();
char *__fastcall sub_3F83C(int a1, int a2);
int sub_3F9E4();
int __fastcall sub_3FC14(int a1, unsigned int a2, _DWORD *a3);
int __fastcall sub_3FC44(unsigned int a1);
void __fastcall sub_408E4(int a1);
int __fastcall sub_40AA4(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall sub_41168(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_411F0(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_4121C(int a1, const char *a2, const char *a3, int a4);
const char *__fastcall sub_412E4(int a1, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_413C8(const char **result, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_41524(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char **__fastcall sub_4168C(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char *__fastcall sub_41800(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_418FC(const char **a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_41A84(const char **a1, int a2, const char *a3, const char *a4, int a5);
int __fastcall sub_41C08(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall sub_41D24(const char **ptr, const char *a2, const char *a3, int a4);
int __fastcall sub_41DB8(int a1, const char *a2, int a3);
int __fastcall sub_4205C(const char *a1);
int __fastcall sub_421B0(int a1, const char *a2, const char *a3, const char *a4);
int __fastcall sub_42320(int a1);
void __fastcall __noreturn sub_42500(int a1);
int __fastcall sub_427F4(int a1);
int sub_4287C();
int __fastcall sub_42904(const char *a1, const char *a2, int a3);
int __fastcall sub_4297C(int a1, const char *a2, int a3);
void __fastcall sub_42C04(int a1, const char *a2, int a3);
char *__fastcall sub_42CB4(int a1, const char *a2, int a3);
void sub_43088();
int __fastcall sub_431B8(int result, unsigned __int8 *a2, int a3);
_DWORD *__fastcall sub_433B4(_DWORD *result);
void *__fastcall sub_433E4(unsigned __int8 *a1, char *a2, size_t n);
int __fastcall sub_43490(_DWORD *a1, _BYTE *a2);
int __fastcall sub_4357C(char *a1, size_t n, _BYTE *a3);
int sub_435E0();
int __fastcall sub_435E8(const void *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_43650(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall sub_436CC(const char *a1, int a2);
int __fastcall sub_43730(int a1, char a2);
void *__fastcall sub_43798(size_t a1, const char *a2, const char *a3, int a4);
void *__fastcall sub_4382C(size_t a1, size_t a2, const char *a3, const char *a4, int a5);
void *__fastcall sub_438D0(void *a1, size_t a2, const char *a3, const char *a4, int a5);
_BYTE *__fastcall sub_43A28(int a1, int a2);
int __fastcall sub_43ADC(_BYTE *a1, unsigned __int8 *a2, int a3);
size_t __fastcall sub_43CA0(_BYTE *a1, char *s);
int __fastcall sub_43D78(int a1, int a2);
char *sub_43FB8();
void __fastcall sub_44014(char *a1);
int __fastcall sub_4407C(int a1);
int __fastcall sub_44084(int a1);
int __fastcall sub_4408C(int a1, int a2);
int __fastcall sub_44160(int a1, const struct timespec *a2);
int __fastcall sub_44240(int result);
_DWORD *__fastcall sub_4427C(_DWORD *result, int *a2);
_DWORD *__fastcall sub_442B0(_DWORD *result, int *a2);
bool __fastcall sub_442F4(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_44328(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_4435C(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_4438C(_DWORD *result, _DWORD *a2);
int __fastcall sub_443A8(_QWORD *a1);
int __fastcall sub_443E0(_QWORD *a1);
int __fastcall sub_44420(_QWORD *a1);
int __fastcall sub_44460(_QWORD *a1);
_DWORD *__fastcall sub_4449C(_DWORD *result, _DWORD *a2);
const char *__fastcall sub_44614(const char **a1, const char *a2);
__int64 __fastcall sub_4465C(__time_t *a1);
int __fastcall sub_446A0(_DWORD *a1);
int __fastcall sub_446D0(_DWORD *a1, _DWORD *a2, int *a3);
int __fastcall sub_4470C(struct timespec *a1);
int __fastcall sub_44718(int *a1);
int __fastcall sub_447D8(int *a1);
int sub_44890();
int sub_448BC();
_DWORD *__fastcall sub_448F0(_DWORD *result, _DWORD *a2);
void *__fastcall sub_44930(_DWORD *a1, _DWORD *a2);
void sub_44984();
int __fastcall sub_449C8(const char *a1, _DWORD *a2, char **a3);
char *__fastcall sub_44B3C(char *s1, int a2);
char *__fastcall sub_44C18(char *a1, char *s);
char *__fastcall sub_44CEC(const char *a1);
int __fastcall sub_44E0C(const char *a1);
int __fastcall sub_44E4C(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_44EC8(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4);
int __fastcall sub_44F10(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_44F48(int a1);
int __fastcall sub_4500C(sem_t *a1, int a2, const char *a3, const char *a4, int a5);
int *__fastcall sub_45164(sem_t *sem);
bool __fastcall sub_4519C(int a1, int a2, int a3);
void *__fastcall sub_45268(void *result, const void *a2, size_t a3, int a4, int a5, int a6);
void *__fastcall sub_45594(void *a1, const void *a2);
_BYTE *__fastcall sub_45644(_BYTE *result, int a2);
int __fastcall sub_4596C(int a1, int a2);
int __fastcall sub_459C8(_BYTE *a1, int a2);
int __fastcall sub_45A8C(int result, unsigned int *a2, unsigned int a3);
int __fastcall sub_45AB4(char *a1, int a2);
FILE *__fastcall sub_45AFC(const char *a1);
FILE *__fastcall sub_45B50(int a1, char *a2);
int __fastcall sub_45BA4(_DWORD *a1, _DWORD *a2);
int __fastcall sub_45C48(char a1, char a2);
__int64 sub_45CFC();
int __fastcall sub_46150(int result);
int sub_461AC();
void sub_463F8();
int sub_4640C();
int __fastcall sub_464F0(int result);
char *__fastcall sub_46750(char *a1, int a2);
int __fastcall sub_469CC(int a1, int a2, int a3);
int sub_46B08();
FILE *__fastcall sub_46BB8(const char *a1);
int sub_46E68();
int sub_46F2C();
int sub_46F74();
int __fastcall sub_470D0(int result);
void sub_47198();
int sub_471D4();
int __fastcall sub_47274(const char *a1);
void __fastcall __noreturn sub_472E8(const char *a1);
int sub_47394();
int sub_473A4();
unsigned int __fastcall sub_473B4(unsigned int result, const char *a2);
int __fastcall sub_4758C(int a1);
int __fastcall sub_479C8(int a1);
int __fastcall sub_47A48(int a1, int *a2, int *a3);
int sub_48264();
int sub_4826C();
int __fastcall sub_4827C(int a1);
int sub_482B8();
unsigned int __fastcall sub_482F8(unsigned int result, int a2, int a3);
int __fastcall sub_48690(int result, int a2, int a3);
void *sub_48AA8();
int sub_48AE0();
int sub_48BAC();
int sub_48CB8();
int sub_48CC8();
char *__fastcall sub_48DF4(int a1);
int sub_49058();
int sub_491EC();
int sub_491F8();
char *sub_49204();
char *sub_49744();
int sub_49A60();
int sub_49A70();
time_t sub_49B48();
size_t __fastcall sub_49B6C(_DWORD *a1, int a2, int a3);
int __fastcall sub_49E00(unsigned __int8 *a1);
unsigned int sub_4A32C();
int __fastcall sub_4A348(int result, int a2);
int __fastcall sub_4A75C(unsigned int a1);
int sub_4A908();
int sub_4AA80();
int sub_4AC40();
int sub_4B6FC();
void sub_4B9C4();
int sub_4BFBC();
int __fastcall sub_4C08C(int a1, int a2);
bool sub_4C188();
char *sub_4C1F8();
int sub_4C254();
FILE *sub_4C3B0();
int __fastcall sub_4CA18(int a1);
unsigned int sub_4CB18();
bool sub_4CB28();
int sub_4CB44();
void sub_4CB54();
int sub_4CB68();
int sub_4CB78();
int sub_4CE14();
int sub_4D358();
void sub_4D360();
void sub_4D370();
void sub_4D380();
int sub_4D4B8();
int sub_4D804();
int sub_4DB18();
int __fastcall sub_4E520(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall sub_4F7A8(int a1);
int sub_4FB08();
int __fastcall sub_4FB28(int a1, int a2);
int *sub_4FED0();
int __fastcall sub_4FEDC(int a1);
void __noreturn sub_4FF0C();
int sub_50000();
unsigned int __fastcall sub_500E8(int a1);
void sub_50158();
int __fastcall sub_50208(int **a1, int a2, int a3);
_DWORD *__fastcall sub_5066C(_DWORD *result);
int __fastcall sub_50688(int result);
int sub_50698();
int sub_506A8();
int sub_506AC();
int sub_506C0();
int __fastcall sub_50748(int a1);
int __fastcall sub_509A0(_DWORD *a1);
int sub_509B0();
int __fastcall sub_509C0(int result);
int sub_509D4();
bool __fastcall sub_50A50(int a1);
int __fastcall sub_50AE8(int a1);
int sub_50C4C();
void *sub_50CEC();
int sub_50D70();
void sub_50E74();
void sub_50F10();
int sub_50F6C();
int __fastcall sub_51110(int a1, int a2, unsigned int a3, int a4);
char *__fastcall sub_51224(int a1);
bool __fastcall sub_512E4(int a1);
bool sub_51394();
int __fastcall sub_513D4(int a1, int *a2);
char **sub_519DC();
int sub_51A50();
bool __fastcall sub_51A64(int a1);
int __fastcall sub_51AFC(int a1);
void *sub_51C20();
int __fastcall sub_51C40(int a1);
unsigned int __fastcall sub_51FBC(int a1);
void sub_52280();
void sub_52300();
int __fastcall sub_52318(FILE **a1, int a2, int a3, int a4);
int __fastcall sub_5246C(int a1);
char **sub_527AC();
int __fastcall sub_5281C(int a1);
int __fastcall sub_5287C(int a1);
int __fastcall sub_528F8(_BYTE *a1, unsigned __int8 *a2, int a3);
unsigned int __fastcall sub_52A18(const void *a1);
int sub_52B7C();
int __fastcall sub_52BC0(_DWORD *a1);
int sub_52C78();
int __fastcall sub_52CC0(int result);
int __fastcall sub_52D74(int result);
int __fastcall sub_52EF0(int a1, int a2);
int __fastcall sub_52FF4(int a1, const char *a2);
void sub_531C4();
int sub_532DC();
int sub_5339C();
char *__fastcall sub_53434(char *result);
int __fastcall sub_534AC(int result);
int sub_53578();
int __fastcall sub_5363C(int a1);
int sub_536E4();
int __fastcall sub_53788(int a1);
int sub_5385C();
int __fastcall sub_53908(int a1);
int __fastcall sub_539B0(int result, int a2);
int __fastcall sub_53B24(int a1);
int sub_53C40();
int sub_53CD8();
int sub_53D1C();
int __fastcall sub_53D5C(unsigned int a1);
int sub_53E00();
int __fastcall sub_53EE4(int a1);
int sub_5410C();
int sub_54224();
int __fastcall sub_54338(int a1);
char *__fastcall sub_543D8(char *result, int a2);
int sub_54D24();
int __fastcall sub_54D68(int result);
int sub_5516C();
int sub_55194();
void sub_552CC();
int __fastcall sub_55388(int a1);
int __fastcall sub_553A0(int a1);
int __fastcall sub_55404(int a1);
void sub_5541C();
char *__fastcall sub_55848(int a1);
unsigned int __fastcall sub_55E78(int a1, int a2);
unsigned int __fastcall sub_55F24(int a1, int a2);
unsigned int __fastcall sub_55FF0(int a1, int a2);
int __fastcall sub_560BC(int a1);
unsigned int __fastcall sub_5622C(int a1, int a2);
void sub_56444();
int __fastcall sub_56500(int a1);
int __fastcall sub_5651C(int a1, _DWORD *a2);
int __fastcall sub_565B0(int a1);
char *sub_565D0();
int __fastcall sub_56BCC(int a1);
int sub_56D18();
char *__fastcall sub_579FC(const char *a1, const char *a2);
int __fastcall sub_57A38(_BYTE *a1);
int __fastcall sub_57A48(_BYTE *a1);
int __fastcall sub_57A58(_BYTE *a1);
char *__fastcall sub_57A68(const char *a1, _BYTE *a2);
char *__fastcall sub_57AFC(const char *a1, _BYTE *a2);
int __fastcall sub_57B1C(int a1, _DWORD *a2);
char *__fastcall sub_57BB0(const char *a1, int *a2);
char *__fastcall sub_57C38(const char *a1, _DWORD *a2);
int __fastcall sub_57D00(_DWORD *a1);
void __fastcall __noreturn sub_57D18(const char *a1);
void __fastcall __noreturn sub_57D38(int a1);
char *__fastcall sub_57D78(char *a1, unsigned __int8 *a2);
char *__fastcall sub_57D9C(char *a1, unsigned __int8 *a2);
char *__fastcall sub_57DC0(_BYTE *a1, const char **a2);
int __fastcall sub_57E20(char *a1, _DWORD *a2);
int __fastcall sub_57E34(char *a1, float *a2);
int __fastcall sub_57E60(char *a1, _DWORD *a2);
int __fastcall sub_57E74(char *a1, _DWORD *a2);
int __fastcall sub_57E88(char *a1, _DWORD *a2);
const char *__fastcall sub_57E9C(unsigned int *a1, size_t *a2);
int __fastcall sub_57F3C(int a1, size_t *a2);
int __fastcall sub_57F84(int a1, unsigned int *a2, size_t *a3);
int __fastcall sub_5803C(const char **a1);
int __fastcall sub_581B0(int *a1);
const char *__fastcall sub_58214(unsigned int *a1, size_t *a2);
_BYTE *__fastcall sub_5826C(int a1, unsigned int *a2, size_t *a3);
const char *__fastcall sub_582C4(unsigned int *a1);
_BYTE *__fastcall sub_58324(int a1, unsigned int *a2);
int __fastcall sub_58384(const char *a1, const char *a2, const char *a3, const char *a4, const char *a5, const char *a6, const char *a7);
int __fastcall sub_583C8(int result, int a2);
bool __fastcall sub_5849C(_DWORD *a1, const char **a2, void (*a3)(const char *, ...));
void sub_584F8();
int sub_58518(const char *a1, ...);
void __noreturn sub_58560(const char *a1, ...);
char *__fastcall sub_585A0(const char *a1);
void *__fastcall sub_585D0(_DWORD *a1, int a2, int a3);
int __fastcall sub_58608(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
char *__fastcall sub_58AB8(const char *a1, const char *a2);
char *__fastcall memchr(char *result, __int16 a2, unsigned int a3);
unsigned int __fastcall sub_59010(int a1, unsigned int a2, int *a3);
int __fastcall sub_59120(int a1, int a2, char *s1, unsigned int a4);
int __fastcall memmem(char *a1, unsigned int a2, char *a3, unsigned int a4);
unsigned int *__fastcall sub_59734(unsigned int *result);
int __fastcall sub_597D8(_DWORD *a1);
int sub_59CE4();
void sub_59E14();
void *__fastcall sub_59E5C(void *result);
int __fastcall sub_59EA4(const char *a1, int a2);
int __fastcall sub_5A004(void *a1);
int __fastcall sub_5A060(int a1);
int sub_5A0A8();
void sub_5A0C4();
int __fastcall sub_5A0DC(int a1);
int sub_5A1C0();
int sub_5A1DC();
int __fastcall sub_5A200(int a1);
int __fastcall sub_5A298(int a1);
int __fastcall sub_5A330(int a1);
int sub_5A388();
void sub_5A6B4();
int __fastcall sub_5A800(int a1, _DWORD *a2);
int __fastcall sub_5A87C(int a1, int a2);
int sub_5A8F4();
int __fastcall sub_5A93C(_DWORD *a1, _DWORD *a2);
int sub_5A974();
int sub_5AB38();
int sub_5AB54();
void sub_5AC7C();
int sub_5AC94();
int __fastcall sub_5AD20(int a1, int a2);
int __fastcall sub_5AEA4(int a1, int a2);
int __fastcall sub_5B034(int a1);
int __fastcall sub_5B10C(int a1);
int __fastcall sub_5B308(int a1);
int __fastcall sub_5B564(int a1, int a2);
int __fastcall sub_5B764(int a1, _BYTE *a2);
int __fastcall sub_5B948(int a1, char a2);
int __fastcall sub_5BB2C(unsigned int a1, int a2);
int __fastcall sub_5BC3C(int result);
int __fastcall sub_5BCE8(int a1, unsigned int a2);
int __fastcall sub_5BE0C(int a1, _DWORD *a2);
int __fastcall sub_5BED8(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
int __fastcall sub_5C280(int a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_5C4D4(unsigned __int8 a1);
int __fastcall sub_5C738(int a1, int a2, unsigned int a3);
int sub_5CA90();
void sub_5CB0C();
int __fastcall sub_5CB24(const char *a1, unsigned __int8 *a2, int a3);
size_t __fastcall sub_5CCA0(int a1, const void *a2, size_t a3);
int __fastcall sub_5D1BC(int a1, int a2, unsigned int a3);
int __fastcall sub_5D2F8(int a1, int a2, int *a3);
int __fastcall sub_5D3F8(int a1, int a2, _DWORD *a3, _DWORD *a4);
int __fastcall sub_5D564(int a1, int a2, _DWORD *a3);
int __fastcall sub_5D668(int a1, int a2, int *a3, int a4);
int __fastcall sub_5D7DC(int a1);
int __fastcall sub_5DA0C(int a1);
int __fastcall sub_5DC5C(int a1);
int __fastcall sub_5DC98(int a1);
int __fastcall sub_5DCC0(int a1);
int __fastcall sub_5DCE8(int a1);
int sub_5DD70();
int sub_5DDB8();
int sub_5DE00();
int __fastcall sub_5DFE8(_DWORD *a1, _DWORD *a2);
int __fastcall sub_5E020(unsigned int a1);
int __fastcall sub_5E120(int a1);
int __fastcall sub_5E1CC(int a1, char a2);
int sub_5E2B4();
int sub_5E3B4();
void sub_5E4B4();
int sub_5E4CC();
int __fastcall sub_5E538(int result, int *a2);
int __fastcall sub_5E5B4(int result, int a2, int *a3);
void __fastcall sub_5E65C(int a1, int a2, int a3);
int __fastcall sub_5E758(unsigned int a1, int a2);
int __fastcall sub_5E968(unsigned int a1, int a2);
int sub_5EA88();
int sub_5EAA8();
int sub_5EAC8();
int sub_5EB00();
int sub_5EB20();
int sub_5EB40();
int sub_5EB78();
int sub_5EB98();
int sub_5EBB8();
int __fastcall sub_5EBF0(int a1);
int __fastcall sub_5EDA0(int a1);
int sub_5EEE8();
int sub_5EFB8();
int __fastcall sub_5F088(unsigned __int8 a1, int a2, unsigned int a3);
int sub_5F204();
int __fastcall sub_5F2AC(const char *a1);
int __fastcall sub_5F3D0(int a1, unsigned __int8 a2, int a3, unsigned int a4);
int sub_5F5D4();
int __fastcall sub_5F5F8(int a1);
int __fastcall sub_5F754(int a1);
int sub_5F80C();
int sub_5F84C();
int sub_5F88C();
int sub_5F8CC();
int __fastcall sub_5F90C(int a1);
int __fastcall sub_5F9A8(int a1);
int __fastcall sub_5FA44(int a1);
int sub_5FAE0();
int __fastcall sub_5FBC8(int a1);
int __fastcall sub_5FC88(int a1);
int sub_5FD48();
_DWORD *__fastcall sub_5FDE8(int a1, int a2, int a3);
int __fastcall sub_5FE68(int *a1, const void *a2, size_t a3, const void *a4, size_t a5);
bool __fastcall sub_5FEC8(int *a1, int a2);
int __fastcall sub_5FF34(int *a1, int a2);
int __fastcall sub_60008(int *a1, int a2, void **a3);
int __fastcall sub_60084(void ***a1);
_DWORD *__fastcall sub_600D4(int *a1);
int __fastcall sub_60114(int a1);
void *__fastcall sub_601B8(int a1);
void *__fastcall sub_601E8(int a1, const void *a2, size_t a3);
_DWORD *__fastcall sub_6027C(int a1);
void __fastcall sub_60300(void *a1);
_DWORD *__fastcall sub_60324(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_60438(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_6054C(int a1, int a2, int a3);
_DWORD *__fastcall sub_60614(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_6083C(int a1, int a2);
int __fastcall sub_60920(int a1, const void *a2, size_t a3, const void *a4, size_t a5);
int *__fastcall sub_60B9C(int *result, int a2);
int *__fastcall sub_60E94(int *a1, int *a2);
int *__fastcall sub_6105C(int a1, int a2);
void __fastcall sub_61154(int a1, int a2);
int __fastcall sub_6121C(void **a1);
_DWORD *__fastcall sub_61374(int a1, _DWORD *a2);
int __fastcall sub_613C4(int a1, int a2);
bool __fastcall sub_61414(_DWORD *a1);
int *__fastcall sub_61458(int *a1, int a2);
int __fastcall sub_61530(int *a1);
int __fastcall sub_6159C(int a1, _DWORD *a2);
int __fastcall sub_6164C(int a1, int a2);
int __fastcall sub_616A4(int a1, int a2);
int __fastcall sub_616EC(int a1, int *a2);
int __fastcall sub_61824(int a1, _DWORD *a2);
int __fastcall sub_61860(int a1, _DWORD *a2, int a3, _DWORD *a4);
void *__fastcall sub_61948(void *a1, const void *a2, size_t a3);
void *__fastcall sub_6197C(void *a1, const void *a2, size_t a3);
void **__fastcall sub_619B0(const void *a1, size_t a2);
int __fastcall sub_61A54(int a1, void **a2);
void *__fastcall sub_61AD0(void **a1, const void *a2, size_t a3);
void __fastcall sub_61B34(void **a1);
char *__fastcall sub_61B74(const char *a1);
int __fastcall sub_61B9C(unsigned int a1);
unsigned int __fastcall sub_61CE8(unsigned int result);
int __fastcall sub_61DD8(unsigned int a1, char a2, int a3, unsigned int a4);
int __fastcall sub_61FEC(unsigned int a1, char a2, int a3, unsigned int a4);
int sub_62208();
int sub_62344();
int sub_62360();
int __fastcall sub_623B4(int a1);
int __fastcall sub_62410(int a1, int a2, int a3, int a4);
int __fastcall sub_62468(int a1, unsigned int a2, int a3);
int sub_62550();
int __fastcall sub_625D8(int a1);
__int64 __fastcall sub_62AFC(int a1);
int __fastcall sub_62B94(int a1);
int __fastcall sub_62BD8(int a1);
int __fastcall sub_62C1C(int a1, int a2, unsigned int a3);
unsigned int sub_62CB0();
unsigned int sub_62D08();
int __fastcall sub_62D60(char a1);
int __fastcall sub_62DC0(char a1);
int sub_62E24();
int sub_62E74();
int sub_62EC4();
int __fastcall sub_62EF8(int a1);
int sub_62F20();
int sub_62F48();
int sub_62F70();
int sub_62F98();
int __fastcall sub_62FC0(__int16 a1);
int sub_63004();
int sub_6302C();
int sub_63054();
int sub_6307C();
int sub_630A4();
int sub_630CC();
int sub_630F4();
int sub_6311C();
int sub_63144();
int sub_631A4();
int __fastcall sub_63228(char *a1, size_t a2);
int __fastcall sub_6329C(int a1);
int sub_632C4();
int __fastcall sub_632F0(int a1);
int sub_63328();
int __fastcall sub_63354(int a1);
int __fastcall sub_6339C(int a1);
int __fastcall sub_633D4(unsigned int a1);
int sub_63428();
int __fastcall sub_63454(int a1);
int sub_6348C();
int sub_634A8();
int sub_634C4();
int sub_634E0();
int sub_63510();
int sub_6352C();
int __fastcall sub_6355C(_DWORD *a1);
int __fastcall sub_635B4(_DWORD *a1);
int sub_6366C();
int __fastcall sub_63698(int a1);
int sub_636D0();
int __fastcall sub_636FC(int a1);
int sub_63734();
int __fastcall sub_63760(int a1);
int sub_63798();
int __fastcall sub_637C4(char a1);
int sub_63804();
int __fastcall sub_63830(int a1, int a2, int a3);
int __fastcall sub_638DC(int a1, int a2, int a3);
int sub_63B78();
int __fastcall sub_63BA4(int a1);
int sub_63BDC();
int __fastcall sub_63C08(int a1);
int __fastcall sub_63C40(int result);
int __fastcall sub_63CA8(int a1);
int __fastcall sub_63CE0(unsigned __int16 a1);
int __fastcall sub_63D2C(unsigned __int16 a1);
int __fastcall sub_63D7C(unsigned __int16 a1);
int __fastcall sub_63DCC(int *a1);
int __fastcall sub_63E34(unsigned __int16 a1);
int sub_63E74();
int __fastcall sub_63EA0(int a1);
int sub_63ED8();
int __fastcall sub_63F00(int *a1);
int sub_63F90();
int __fastcall sub_63FBC(int a1);
int sub_64040();
int __fastcall sub_640A8(char a1);
int __fastcall sub_6410C(int a1, char a2);
int __fastcall sub_641A0(int *a1, int a2);
int __fastcall sub_64214(int a1, unsigned int a2);
int sub_642AC();
int __fastcall sub_642D8(int a1);
int sub_64340();
int __fastcall sub_64374(int a1);
int __fastcall sub_6439C(char a1);
int __fastcall sub_643D4(char a1);
int __fastcall sub_64434(char a1);
void sub_64498();
void sub_644D0();
void sub_644F0();
bool sub_64510();
int __fastcall sub_64558(int a1);
int sub_645D8();
int sub_64628();
bool sub_64678();
int sub_646C8();
int sub_64718();
bool sub_64768();
int sub_647B8();
int __fastcall sub_647EC(void *a1);
int __fastcall sub_64910(int a1);
int __fastcall sub_649D8(int a1, void *a2);
int __fastcall sub_64AB4(int a1);
int __fastcall sub_64B90(void *a1);
int __fastcall sub_64C38(const char *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_64EB8(int a1);
int __fastcall sub_65230(int a1);
int __fastcall sub_654B4(int a1);
int __fastcall sub_656F8(int a1);
int __fastcall sub_6598C(int a1);
int __fastcall sub_65C20(int a1);
int __fastcall sub_65EBC(unsigned __int8 a1);
int __fastcall sub_66020(int result);
int __fastcall sub_6612C(unsigned __int8 a1);
int __fastcall sub_6626C(unsigned __int8 a1);
int __fastcall sub_663A4(unsigned __int8 a1);
int __fastcall sub_664DC(unsigned __int8 a1);
int __fastcall sub_66614(unsigned __int8 a1);
int __fastcall sub_6674C(unsigned __int8 a1);
int __fastcall sub_66884(const char *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_66B04(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5);
int __fastcall sub_66F10(int a1, unsigned __int8 a2, unsigned __int8 a3, void *a4, int a5);
unsigned int __fastcall sub_673E0(int a1, unsigned __int8 *a2, unsigned int a3);
unsigned int __fastcall sub_67734(int a1, unsigned __int8 *a2, unsigned int a3);
size_t __fastcall sub_67AAC(int a1, unsigned __int8 a2, void *a3, int a4);
int __fastcall sub_67ED8(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5);
int __fastcall sub_6827C(int a1, int a2);
int __fastcall sub_68810(int a1, __int16 a2);
int __fastcall sub_68AF8(int a1, int a2);
int __fastcall sub_68DB4(int a1);
int __fastcall sub_68F38(unsigned __int8 a1, const char *a2);
int __fastcall sub_694CC(unsigned __int8 a1, int *a2, int a3);
int __fastcall sub_697D0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5);
int __fastcall sub_69930(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, void *a4, int a5);
int __fastcall sub_69A90(unsigned __int8 a1, const char *a2);
size_t __fastcall sub_69BC4(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, void *a4, int a5);
int __fastcall sub_69DB8(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5);
unsigned int __fastcall sub_69F18(unsigned int a1);
unsigned int __fastcall sub_69F40(int a1, unsigned int a2);
int __fastcall sub_69F84(_BYTE *a1, __int16 a2);
int __fastcall sub_6A04C(int a1, int a2);
int __fastcall sub_6A120(int a1, int a2);
int __fastcall sub_6A20C(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall sub_6A3F4(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __fastcall sub_6A6A0(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5);
int __fastcall sub_6A874(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5);
bool sub_6AAC8();
bool sub_6AB50();
void sub_6ABA4();
void sub_6AC28();
void sub_6ACA8();
void sub_6B180();
int sub_6B418();
unsigned int sub_6B5F0();
int sub_6B7C4();
int sub_6B9B4();
int sub_6BAD4();
int __fastcall sub_6BC40(char a1, char a2);
int __fastcall sub_6BE3C(char a1, void *a2);
int sub_6C224();
int sub_6C344();
int __fastcall sub_6C474(int a1);
int __fastcall sub_6C648(int a1);
int __fastcall sub_6C81C(int a1);
int __fastcall sub_6C9C8(int a1);
int __fastcall sub_6CB74(int a1);
int __fastcall sub_6CD2C(int a1);
int __fastcall sub_6CED8(int a1);
int __fastcall sub_6CF58(int a1, char a2);
int __fastcall sub_6D088(int a1);
int __fastcall sub_6D114(int a1);
int __fastcall sub_6D1A0(int a1);
int __fastcall sub_6D36C(int a1, unsigned __int8 a2);
__int64 __fastcall sub_6D584(int a1);
int __fastcall sub_6D7FC(int a1);
int __fastcall sub_6D880(int a1);
int __fastcall sub_6D904(int a1);
int __fastcall sub_6D988(int a1);
int __fastcall sub_6DA3C(int a1);
int __fastcall sub_6DC10(int a1, unsigned __int8 a2);
int __fastcall sub_6DE30(int a1);
int __fastcall sub_6E000(int a1);
int __fastcall sub_6E1F0(int a1);
int __fastcall sub_6E3E0(int a1);
int __fastcall sub_6E5E0(int a1);
int __fastcall sub_6E7AC(int a1);
int __fastcall sub_6E97C(int a1);
int __fastcall sub_6EB6C(int a1);
int __fastcall sub_6ECC0(int *a1);
void sub_6EEB4();
void sub_6F008();
void sub_6F108();
int sub_6F2DC();
int sub_6F4B8();
int sub_6F694();
__int64 sub_6F7BC();
int sub_6F90C();
int sub_6FA34();
int sub_6FB3C();
int __fastcall sub_6FCF4(char a1);
int __fastcall sub_6FE94(_BYTE *a1);
const char *sub_6FF60();
int sub_6FFB0();
int sub_70000();
int sub_702FC();
int sub_703BC();
int sub_7046C();
int sub_7051C();
int sub_705E8();
int sub_70698();
int sub_70750();
void sub_7099C();
int sub_70B80();
unsigned int sub_70C58();
int sub_70DA8();
int __fastcall sub_70EF4(unsigned __int8 a1);
int sub_70FB4();
int sub_71528();
void sub_71588();
void sub_71AF8();
void sub_71B58();
int __fastcall sub_71B98(unsigned __int8 a1, int a2, unsigned __int8 a3);
int __fastcall sub_71E8C(char a1, int a2, unsigned __int8 a3);
int __fastcall sub_7211C(char a1, int a2, unsigned __int8 a3);
int __fastcall sub_72544(int a1, unsigned int a2, unsigned __int64 a3, int a4);
int __fastcall sub_726D8(unsigned __int16 a1);
int __fastcall sub_7279C(_DWORD *a1, int *a2);
int sub_7282C();
int sub_72F64();
int sub_73114();
int sub_7312C();
int sub_73144();
int __fastcall sub_7315C(char a1, char a2);
int __fastcall sub_731A0(char a1, void *a2);
int sub_731D8();
int sub_731F0();
char __fastcall sub_73208(char result);
int __fastcall sub_7323C(unsigned int a1, int a2, unsigned __int8 a3);
int __fastcall sub_73530(unsigned int a1);
int __fastcall sub_73694(unsigned int a1, unsigned __int8 a2, char a3, int a4, unsigned int a5);
int __fastcall sub_73954(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, unsigned int a5);
int __fastcall sub_73BD0(unsigned int a1, unsigned __int8 a2);
int __fastcall sub_73D18(int a1);
int __fastcall sub_73FC0(int a1);
int __fastcall sub_7405C(int a1, int a2, unsigned int a3);
int __fastcall sub_74108(int a1, int a2, unsigned int a3);
int __fastcall sub_741B4(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5, char a6);
int __fastcall sub_7427C(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5, char a6);
int __fastcall sub_74344(_DWORD *a1, _DWORD *a2);
int sub_7437C();
int __fastcall sub_744B8(int a1);
int sub_7468C();
int __fastcall sub_746FC(_BYTE *a1);
int __fastcall sub_74780(int a1, int a2, unsigned int a3);
int __fastcall sub_74A58(int a1, int a2, unsigned int a3);
int __fastcall sub_74D44(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5, char a6);
int __fastcall sub_750D0(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5, char a6);
int __fastcall sub_75468(int a1, __int16 a2, int a3);
int __fastcall sub_75608(int a1, int a2);
int __fastcall sub_75770(const void *a1, size_t a2, int a3);
int __fastcall sub_757A8(const void *a1, size_t a2, _DWORD *a3);
int __fastcall sub_75834(const void *a1, size_t a2, FILE *a3);
int __fastcall sub_7588C(const void *a1, size_t a2, int *a3);
int __fastcall sub_758EC(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
int __fastcall sub_75A0C(unsigned __int8 *a1, int a2, int (__fastcall *a3)(unsigned __int8 *, int, int), int a4, __int16 a5);
int __fastcall sub_75D74(const char **a1, const char **a2);
int __fastcall sub_75DB4(_DWORD *a1, const void *a2, char *a3, size_t a4);
int __fastcall sub_75E30(_DWORD *a1, int a2, int a3, _DWORD *a4, int (__fastcall *a5)(const char *, int, int), int a6);
void *__fastcall sub_767AC(_DWORD *a1, int a2);
int __fastcall sub_76848(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_768B8(_DWORD *a1, int a2, int a3);
int __fastcall sub_768F8(_DWORD *a1, int a2, int a3);
int __fastcall sub_76938(_DWORD *a1, const char *a2, int a3);
int __fastcall sub_769B8(_DWORD *a1, int (__fastcall *a2)(const char *, int, int), int a3, int a4);
int __fastcall sub_76A8C(int result);
int __fastcall sub_76AF4(unsigned __int8 *a1, unsigned int a2, int a3);
_DWORD *__fastcall sub_77A10(_DWORD *result);
int __fastcall sub_77A48(int result, _DWORD *a2);
_DWORD *__fastcall sub_77AA4(_DWORD *result);
bool __fastcall sub_77AEC(int a1, _DWORD *a2);
int __fastcall sub_77B4C(int a1, int *a2, _DWORD *a3);
int __fastcall sub_77BDC(int a1, int *a2, const char *a3, int a4);
int __fastcall sub_77CA0(_DWORD *a1, const char *a2, int a3);
void __fastcall sub_77E0C(int a1);
int __fastcall sub_77E80(int a1);
int __fastcall sub_78010(_DWORD *a1);
void __fastcall sub_78114(int a1);
int __fastcall sub_78148(_DWORD *a1, char *a2, int a3);
int __fastcall sub_78328(int a1, char *a2);
int __fastcall sub_783D4(_DWORD *a1, char *a2);
_DWORD *__fastcall sub_78430(_DWORD *a1);
int __fastcall sub_784F0(int a1);
int __fastcall sub_78524(int a1, char *a2);
int __fastcall sub_785D0(int a1, int a2);
int __fastcall sub_78624(int a1);
int __fastcall sub_78658(int a1);
int __fastcall sub_7868C(int a1, int a2);
int __fastcall sub_786D4(int a1);
int __fastcall sub_78744(int *a1);
int __fastcall sub_787EC(int *a1);
int sub_78854();
int __fastcall sub_788CC(int result);
void __fastcall sub_78980(_DWORD *a1);
int sub_789E8(int result, _DWORD *a2, int a3, const char *a4, ...);
int __fastcall sub_78B9C(int result, int a2, int a3);
int __fastcall sub_78C24(int a1, int a2);
_DWORD *__fastcall sub_78ED0(_DWORD *result, int a2);
int __fastcall sub_79008(int a1, int a2);
int __fastcall sub_7903C(int a1, char a2);
int __fastcall sub_79078(int a1, int a2);
_DWORD *__fastcall sub_790D4(_DWORD *a1, int a2);
_DWORD *__fastcall sub_79104(_DWORD *result, int a2);
int __fastcall sub_79194(int result);
void __fastcall sub_79218(int a1);
int __fastcall sub_7925C(_BYTE *a1);
void __fastcall sub_79390(_DWORD *a1, int a2);
int __fastcall sub_799FC(int a1, int a2, int a3);
int __fastcall sub_79DA4(_DWORD *a1, int a2);
int __fastcall sub_7A064(_DWORD *a1, _DWORD *a2);
int __fastcall sub_7A0D8(int a1, int a2, int a3, int a4);
void __fastcall sub_7A154(int a1);
_DWORD *__fastcall sub_7A198(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_7A3FC(_DWORD *a1, int a2, int a3);
void *__fastcall sub_7A524(int a1, char a2, int a3);
_DWORD *__fastcall sub_7A790(_DWORD *a1, char a2, int a3);
int __fastcall sub_7A8BC(_DWORD *a1);
_DWORD *__fastcall sub_7A92C(int a1, int a2, char *a3);
int __fastcall sub_7A9F0(_DWORD *a1);
_DWORD *__fastcall sub_7AA6C(int a1, int a2, int a3, char *a4);
_DWORD *__fastcall sub_7AB3C(int a1, int a2, char *a3);
int __fastcall sub_7AC20(int *a1);
_DWORD *__fastcall sub_7AC6C(int a1, int a2, char *a3);
_DWORD *__fastcall sub_7AD44(const char *a1, int a2, char *a3);
int __fastcall sub_7AE24(int a1);
_DWORD *__fastcall sub_7AEE8(int a1, int a2, int a3, char *a4);
void *__fastcall sub_7AFCC(size_t a1);
void __fastcall sub_7B014(void *a1);
void *__fastcall sub_7B054(const char *a1);
void *__fastcall sub_7B08C(const void *a1, size_t a2);
void *(*__fastcall sub_7B0FC(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size);
_DWORD *__fastcall sub_7B140(_DWORD *result, _DWORD *a2);
int __fastcall sub_7B1A4(void **a1);
void __fastcall sub_7B220(int a1);
int __fastcall sub_7B280(int result);
int __fastcall sub_7B2BC(int a1);
int __fastcall sub_7B2E4(int *a1);
int __fastcall sub_7B320(int a1, char a2);
int __fastcall sub_7B35C(int a1, const void *a2, size_t a3);
int __fastcall sub_7B4D4(int *a1);
_BYTE **__fastcall sub_7B560(const char **a1);
_BYTE *__fastcall sub_7B5D4(const char *a1);
int __fastcall sub_7B644(int a1, double *a2);
int __fastcall sub_7B740(char *a1, size_t a2, int a3);
int __fastcall sub_7B940(int a1, _BYTE *a2, _DWORD *a3);
int __fastcall sub_7BB58(unsigned __int8 a1);
int __fastcall sub_7BC3C(char *a1, unsigned int a2, int *a3);
unsigned __int8 *__fastcall sub_7BDE8(unsigned __int8 *a1, unsigned int a2, _DWORD *a3);
int __fastcall sub_7BEC0(int a1, unsigned int a2);
int __fastcall sub_7BFB0(int result);
void __fastcall sub_7C010(_DWORD *a1);
int __fastcall sub_7C078(_DWORD *a1, char *a2, int a3);
int __fastcall sub_7C0BC(_DWORD *a1, int a2);
_DWORD *__fastcall sub_7C0F8(_DWORD *result, int a2);
_DWORD *sub_7C134();
void __fastcall sub_7C1C8(void *a1);
int __fastcall sub_7C1FC(_DWORD *a1);
int __fastcall sub_7C250(_DWORD *a1, char *a2);
int __fastcall sub_7C2C0(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall sub_7C380(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall sub_7C3F8(_DWORD *a1, char *a2);
int __fastcall sub_7C468(_DWORD *a1);
int __fastcall sub_7C4C4(_DWORD *a1, _DWORD *a2);
int __fastcall sub_7C5C0(_DWORD *a1, _DWORD *a2);
int __fastcall sub_7C6C0(_DWORD *a1, _DWORD *a2);
int __fastcall sub_7C7C0(_DWORD *a1);
int __fastcall sub_7C81C(_DWORD *a1, char *a2);
int __fastcall sub_7C88C(_DWORD *a1, int a2);
int __fastcall sub_7C8FC(int a1);
int __fastcall sub_7C938(int a1);
int __fastcall sub_7C974(_DWORD *a1, int a2, _DWORD *a3);
int __fastcall sub_7C9EC(int a1);
int __fastcall sub_7CA2C(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_7CB1C(_DWORD *a1);
_DWORD *__fastcall sub_7CBDC(_DWORD *a1);
_DWORD *sub_7CC78();
void __fastcall sub_7CD1C(int a1);
int __fastcall sub_7CD9C(_DWORD *a1);
int __fastcall sub_7CDE8(_DWORD *a1, unsigned int a2);
int __fastcall sub_7CE6C(_DWORD *a1, unsigned int a2, _DWORD *a3);
void *__fastcall sub_7CF4C(int a1, int a2, int a3, int a4);
void *__fastcall sub_7CFAC(int a1, int a2, int a3, int a4, int a5);
void *__fastcall sub_7D004(_DWORD *a1, int a2, int a3);
int __fastcall sub_7D114(_DWORD *a1, _DWORD *a2);
int __fastcall sub_7D1F0(_DWORD *a1, unsigned int a2, _DWORD *a3);
int __fastcall sub_7D388(_DWORD *a1, unsigned int a2);
int __fastcall sub_7D46C(_DWORD *a1);
int __fastcall sub_7D510(_DWORD *a1, _DWORD *a2);
int __fastcall sub_7D644(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_7D6FC(_DWORD *a1);
_DWORD *__fastcall sub_7D784(_DWORD *a1);
_DWORD *__fastcall sub_7D818(void *a1, size_t a2, int a3);
_DWORD *__fastcall sub_7D8E0(char *a1);
_DWORD *__fastcall sub_7D930(void *a1, size_t a2);
_DWORD *__fastcall sub_7D964(void *a1, size_t a2);
_DWORD *__fastcall sub_7D998(char *a1);
_DWORD *__fastcall sub_7D9E4(void *a1, size_t a2);
int __fastcall sub_7DA40(_DWORD *a1);
int __fastcall sub_7DA8C(_DWORD *a1);
int __fastcall sub_7DAD8(int a1, const char *a2);
int __fastcall sub_7DB2C(int a1, const void *a2, size_t a3);
int __fastcall sub_7DBD8(int a1, const char *a2);
int __fastcall sub_7DC2C(int a1, const void *a2, size_t a3);
void __fastcall sub_7DC90(void **a1);
bool __fastcall sub_7DCC4(int a1, int a2);
_DWORD *__fastcall sub_7DD44(int a1);
_DWORD *__fastcall sub_7DD88(const char *a1, void *a2);
_DWORD *sub_7DE74(const char *a1, ...);
_QWORD *__fastcall sub_7DEB4(__int64 a1);
__int64 __fastcall sub_7DF10(int a1);
int __fastcall sub_7DF64(int a1, __int64 a2);
void __fastcall sub_7DFBC(void *a1);
bool __fastcall sub_7DFE0(int a1, int a2);
_QWORD *__fastcall sub_7E034(int a1);
double *sub_7E070();
void sub_7E120();
int __fastcall sub_7E174(int a1);
void __fastcall sub_7E218(void *a1);
int sub_7E23C();
double *sub_7E290();
void __fastcall sub_7E2C4(_DWORD *a1);
void *sub_7E35C();
void *sub_7E37C();
void *sub_7E39C();
void __fastcall sub_7E3BC(_DWORD *a1);
int __fastcall sub_7E450(_DWORD *a1, _DWORD *a2);
void *__fastcall sub_7E558(_DWORD *a1);
void *__fastcall sub_7E618(_DWORD *a1);
char *__fastcall sub_7E6D8(char *result, const char *a2);
char *__fastcall sub_7E75C(char *result, const char *a2);
int sub_7E828(int a1, int a2, int a3, int a4, char a5, char *format, ...);
int __fastcall sub_7E884(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg);
int __fastcall sub_7E92C(unsigned int);
int __fastcall sub_7E930(int a1, int a2, unsigned int a3, unsigned int a4, int a5);
int __fastcall sub_7E9BC(int a1, int a2, unsigned int a3, unsigned int a4, char a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int16 a8);
int __fastcall sub_7EA90(int a1, int a2, unsigned int a3, unsigned int a4, char a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int16 a8, _DWORD *a9);
int __fastcall sub_7EB70(unsigned int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_7EC9C(unsigned int a1, int a2, unsigned int a3);
int __fastcall sub_7EDA4(int a1, int a2, unsigned int a3);
int __fastcall sub_7EE1C(int a1, int a2, unsigned int a3, char a4);
int __fastcall sub_7EE94(int a1, int a2, unsigned __int8 a3, unsigned int a4, unsigned __int8 a5);
int __fastcall sub_7EED4(int a1, int a2, unsigned __int8 a3, unsigned int a4, unsigned __int8 a5);
int __fastcall sub_7EF10(int a1, int a2, unsigned int a3, char a4);
int __fastcall sub_7EF54(int a1, int a2, unsigned int a3, char a4, char a5, char a6);
int __fastcall sub_7EF94(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_7EFE0(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_7F02C(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_7F06C(int a1, int a2, const char *a3, unsigned int a4);
int __fastcall sub_7F13C(int a1, unsigned int a2, char a3, int a4);
int __fastcall sub_7F190(int a1);
int __fastcall sub_7F1CC(int a1, char a2);
int __fastcall sub_7F210(int a1, int a2, char a3, char a4);
int __fastcall sub_7F25C(int a1);
int __fastcall sub_7F26C(_DWORD); // weak
int __fastcall sub_7F270(int a1, unsigned int a2);
int __fastcall sub_7F2C0(int a1, char a2, int a3);
int __fastcall sub_7F308(unsigned int a1, unsigned int a2);
int __fastcall sub_7F4DC(int a1, unsigned int a2);
int __fastcall sub_7F548(int a1, unsigned int a2, unsigned int a3);
int __fastcall sub_7F5B0(int a1, int a2, unsigned __int16 a3);
int __fastcall sub_7F5E8(int a1, unsigned int a2, int a3, unsigned __int16 a4);
int __fastcall sub_7F620(int a1, int a2, unsigned int a3);
int __fastcall sub_7F69C(unsigned int a1, int a2, unsigned int a3, int a4, char a5, char a6, char a7);
int __fastcall sub_7F764(unsigned int a1, int a2, unsigned int a3, char a4);
int __fastcall sub_7F7FC(int a1, char a2);
int __fastcall sub_7F80C(int a1, _BYTE *a2, float *a3);
int __fastcall sub_7FA34(int a1, int a2, unsigned int a3, unsigned int a4, float a5);
int __fastcall sub_7FAAC(int a1, unsigned int a2, int a3, unsigned __int16 a4);
int __fastcall sub_7FB40(int a1, unsigned int a2, unsigned int a3, int a4, unsigned __int16 a5);
int __fastcall sub_7FB90(int a1, unsigned int a2, unsigned int a3, int a4, unsigned __int16 a5, _DWORD *a6);
int __fastcall sub_7FBE8(unsigned int a1, unsigned int a2, unsigned int a3, char a4, char a5);
int __fastcall sub_7FCEC(int a1, unsigned int a2, unsigned int a3, float a4);
int __fastcall sub_7FD10(int a1, unsigned int a2, float a3);
int __fastcall sub_7FD34(int a1, unsigned int a2, char a3);
int __fastcall sub_7FD60(int a1, char a2);
int __fastcall sub_7FD8C(int a1);
int __fastcall sub_7FD9C(unsigned int a1, int a2, int a3, __int16 a4);
int __fastcall sub_7FE84(unsigned int a1);
int __fastcall sub_7FF54(unsigned int a1, unsigned int a2, int a3);
int __fastcall sub_7FFC0(unsigned int a1, int a2);
int __fastcall sub_80138(int a1, unsigned int a2, char a3, unsigned __int8 a4);
int __fastcall sub_80174(unsigned int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_802B4(unsigned int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_803AC(unsigned int a1, int a2);
int __fastcall sub_804A0(unsigned int a1, unsigned int a2, int a3);
int __fastcall sub_804B0(unsigned int a1, unsigned int a2);
int __fastcall sub_804BC(unsigned int a1);
int __fastcall sub_804C8(int a1, int a2);
int __fastcall sub_804EC(int a1, unsigned int a2, int a3);
int __fastcall sub_80510(int a1);
int __fastcall sub_8051C(int a1, unsigned int a2);
int __fastcall sub_80528(int a1, char a2);
int __fastcall sub_80538(int a1, unsigned int a2, char a3);
int __fastcall sub_80548(int a1);
int __fastcall sub_8056C(int a1, unsigned int a2);
int __fastcall sub_80594(int a1, unsigned __int8 a2);
int __fastcall sub_805B8(int a1, unsigned int a2, unsigned __int8 a3);
int __fastcall sub_805DC(int a1);
int __fastcall sub_80600(int a1, unsigned int a2);
int __fastcall sub_80628(int a1, unsigned __int8 a2);
int __fastcall sub_8064C(int a1, unsigned int a2, unsigned __int8 a3);
int __fastcall sub_80670(unsigned int a1);
int __fastcall sub_806C8(unsigned int a1);
int __fastcall sub_80720(unsigned int a1);
int __fastcall sub_80778(int a1, int a2);
int __fastcall sub_8079C(int a1, char a2);
int __fastcall sub_807D4(unsigned int a1);
int __fastcall sub_808C0(int a1);
int __fastcall sub_80924(int a1);
int __fastcall sub_80934(int a1);
int __fastcall sub_80944(int a1);
int __fastcall sub_80954(int a1, char a2, char a3, char a4);
int __fastcall sub_80988(int a1, unsigned int a2, char a3, char a4, char a5);
int __fastcall sub_809B8(int a1, int a2);
int __fastcall sub_809DC(int a1, unsigned int a2, int a3);
int __fastcall sub_80A00(int a1, int a2);
int __fastcall sub_80A24(int a1, unsigned int a2, int a3);
int __fastcall sub_80A48(int a1, int a2);
int __fastcall sub_80A84(int a1, unsigned int a2, int a3);
int __fastcall sub_80AB8(int a1, unsigned int a2, unsigned __int16 a3, char a4, char a5);
int __fastcall sub_80AE8(unsigned int a1, char a2);
int __fastcall sub_80B44(unsigned int a1, unsigned int a2, char a3);
int __fastcall sub_80BA4(int a1, unsigned int a2, unsigned __int8 a3, char a4);
int __fastcall sub_80BF0(int a1, unsigned int a2, int a3, char a4);
int __fastcall sub_80BFC(int a1, int a2, char a3);
int __fastcall sub_80C0C(int a1, unsigned int a2, char a3, char a4, char a5);
int __fastcall sub_80C38(int a1, char a2, char a3, char a4);
int __fastcall sub_80C60(int a1, int a2);
int __fastcall sub_80C70(int a1, unsigned int a2, int a3);
int __fastcall sub_80C80(int a1, int a2);
int __fastcall sub_80C90(int a1, unsigned int a2, int a3);
int __fastcall sub_80CA0(int a1, char a2, int a3);
int __fastcall sub_80CB4(int a1, unsigned int a2);
int __fastcall sub_80CF0(int a1, unsigned int a2);
int __fastcall sub_80D30(int a1, char a2);
int __fastcall sub_80D40(int a1, int a2);
int __fastcall sub_80D50(int a1, unsigned int a2, int a3);
int __fastcall sub_80D60(int a1, int a2);
int __fastcall sub_80D94(int a1, unsigned int a2, int a3);
int __fastcall sub_80E94(int a1, char a2);
int __fastcall sub_80EC8(int a1, unsigned int a2, char a3);
int __fastcall sub_80EFC(int a1, char a2);
int __fastcall sub_80F30(int a1, unsigned int a2, char a3);
int __fastcall sub_80FCC(unsigned int a1, unsigned int a2, char a3);
int __fastcall sub_8102C(unsigned int a1, char a2);
int __fastcall sub_810E8(unsigned int a1, char a2);
unsigned int __fastcall sub_81144(unsigned int a1);
int __fastcall sub_8114C(unsigned int a1, unsigned int a2);
int __fastcall sub_81160(unsigned int a1, int a2);
int sub_81170();
int sub_81180();
int sub_81190();
int sub_81198();
int sub_811A0();
int sub_811A8();
int sub_811B0();
int sub_811B8();
int sub_811C0();
int sub_811D0();
int sub_811E0();
int __fastcall sub_811E8(unsigned int a1, int a2);
int __fastcall sub_811F8(int a1);
int __fastcall sub_81224(int a1, unsigned int a2);
int __fastcall sub_8131C(int a1, unsigned int a2);
int __fastcall sub_8132C(int a1, const char *a2, unsigned int a3);
int __fastcall sub_8133C(unsigned int a1);
void *sub_813CC();
int __fastcall sub_813D8(int a1, unsigned int a2, unsigned int a3, unsigned int a4, _DWORD *a5);
int __fastcall sub_815A0(int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __fastcall sub_81768(int a1, char a2, char a3, int a4, _BYTE *a5);
int __fastcall sub_81800(char a1, _BYTE *a2);
int __fastcall sub_81854(int a1, char a2, char a3, _BYTE *a4);
int __fastcall sub_818C4(_BYTE *a1);
int __fastcall sub_81910(int a1, int a2, unsigned int a3);
int __fastcall sub_819E4(_BYTE *a1, unsigned int a2);
int __fastcall sub_81B0C(int a1);
int __fastcall sub_81DC4(int a1);
int __fastcall sub_82104(int a1, int a2);
int __fastcall sub_82418(int a1);
int sub_826C0();
int __fastcall sub_826D8(int a1, const void *a2, size_t a3, _DWORD *a4);
int sub_82824();
int sub_8282C();
void sub_828F4();
int __fastcall sub_82940(const char *a1);
int __fastcall sub_82B18(const char *a1);
int __fastcall sub_82D48(const char *a1, const char *a2);
int __fastcall sub_82FFC(const char *a1);
int sub_83478();
int *__fastcall sub_835A0(const char *a1);
int __fastcall sub_837EC(const char *a1);
int __fastcall sub_83A3C(const char *a1, const char *a2);
int __fastcall sub_83E14(const char *a1);
int __fastcall sub_84018(const void *a1);
int sub_8417C();
int __fastcall sub_842AC(int a1, int a2);
int __fastcall sub_843B4(int result, const char *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_847B4(int result, const char *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_84BB4(int result, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __fastcall sub_8500C(int result, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int sub_85464(int result, const char *a2, int a3, int a4, int a5, int a6, int a7, int a8, ...);
int sub_85878(const char *a1, int a2, int a3, int a4, int a5, int a6, int a7, ...);
int sub_85CD8();
int __fastcall sub_85EA0(const char *a1, int a2);
bool __fastcall sub_86140(int a1, int a2);
const char *sub_861D0();
int __fastcall sub_861F0(const void **a1, int a2);
void __fastcall sub_862F8(int *a1);
int __fastcall sub_8638C(int result, int a2);
int __fastcall sub_86428(int a1, _DWORD *a2);
char *__fastcall sub_866B8(const char *a1, _DWORD *a2);
int __fastcall sub_86844(_DWORD *a1, _DWORD *a2);
void *__fastcall sub_86970(int a1);
void *__fastcall sub_86A20(int *a1);
int __fastcall sub_86B34(int a1, int a2);
int __fastcall sub_86BD8(const void *a1, int a2);
int __fastcall sub_86C8C(const void *a1);
_DWORD *sub_86D00();
int __fastcall sub_86D84(int a1, _DWORD *a2);
int __fastcall sub_86E4C(int a1);
int __fastcall sub_86ED4(int a1);
int *__fastcall sub_86F5C(int a1, const char *a2, _DWORD *a3);
int __fastcall sub_87068(int a1, int a2);
int __fastcall sub_87470(int a1);
char *__fastcall sub_875A4(const char *a1);
int __fastcall sub_879CC(int a1);
int __fastcall sub_87BA4(int a1);
int __fastcall sub_881B0(int a1, const char *a2, int *a3);
int __fastcall sub_88F94(const char **a1, int a2);
void __fastcall sub_890C8(void **a1);
void *__fastcall sub_8915C(size_t a1);
_DWORD *__fastcall sub_89378(_DWORD *result, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
_DWORD *__fastcall sub_89444(_DWORD *result, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
int __fastcall sub_8950C(int a1, int a2);
void __fastcall sub_895A4(int *a1);
void *__fastcall sub_89640(const char *a1, _DWORD *a2);
int __fastcall sub_89A80(int a1, int a2);
int __fastcall sub_89B60(_DWORD *a1, int a2);
int __fastcall sub_89C44(const void *a1);
bool __fastcall sub_89CB8(int a1);
_DWORD *sub_89DDC();
int __fastcall sub_89E7C(int a1, const char *a2);
int __fastcall sub_89F54(_DWORD *a1, int a2);
int __fastcall sub_8A008(_DWORD *a1, const char *a2);
int __fastcall sub_8A128(int *a1, int a2);
void __fastcall sub_8A21C(int *a1);
void __fastcall sub_8A2B0(void *a1);
char *__fastcall sub_8A2F8(const char *a1, const char *a2);
int *sub_8A3B8();
int __fastcall sub_8A49C(int *a1, const char *a2, const char *a3);
void __fastcall sub_8A554(int *a1);
int __fastcall sub_8A580(int *a1, int a2);
int __fastcall sub_8A5F4(int *a1, int a2);
void __fastcall sub_8A660(const void **a1, const void *a2);
int __fastcall sub_8A694(const void **a1, int a2);
void __fastcall sub_8A718(void *a1);
char *__fastcall sub_8A78C(const char *a1, int a2);
int __fastcall sub_8A8D8(const void *a1, int a2);
int __fastcall sub_8A98C(const void *a1);
_DWORD *sub_8AA00();
int __fastcall sub_8AA84(int a1, int a2);
void __fastcall sub_8AC28(pthread_mutex_t *a1);
pthread_mutex_t *__fastcall sub_8AD38(const char *a1);
void __fastcall sub_8AEBC(char *a1);
void *__fastcall sub_8AF2C(int a1, const char *a2);
bool __fastcall sub_8B0EC(_DWORD *a1, _DWORD *a2);
int __fastcall sub_8B130(int a1);
int __fastcall sub_8B300(int a1);
int __fastcall sub_8B65C(int a1);
int __fastcall sub_8BA60(int a1);
void __fastcall sub_8BD9C(_DWORD *a1);
int __fastcall sub_8BE50(_DWORD *a1, int a2, int a3, int a4);
int __fastcall sub_8BFC0(pthread_mutex_t *a1);
int __fastcall sub_8C168(pthread_mutex_t *a1);
int __fastcall sub_8C260(pthread_mutex_t *a1, const char *a2, int a3, int a4, unsigned int a5, int a6);
int __fastcall sub_8C408(int a1, int a2);
int __fastcall sub_8C630(int a1, int a2);
int __fastcall sub_8CA24(int a1, int a2);
int __fastcall sub_8CB5C(int a1, int a2);
int __fastcall sub_8CF64(int a1, int a2);
int __fastcall sub_8D2B4(int a1, int a2);
int __fastcall sub_8D78C(int a1, int a2);
int __fastcall sub_8D878(int a1, int a2);
int __fastcall sub_8D95C(int a1, int a2);
int __fastcall sub_8DAAC(int a1, int a2);
int __fastcall sub_8DCE4(int a1, int a2);
int __fastcall sub_8DDC8(int a1, int a2);
int __fastcall sub_8DEAC(const char *a1);
int __fastcall sub_8E184(int a1, void *a2, int a3, _DWORD *a4, _DWORD *a5);
char *__fastcall sub_8E3F0(const char *a1, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD *a7);
void __fastcall sub_8F938(int a1);
int __fastcall sub_8FAE4(int a1, int a2);
int __fastcall sub_8FC90(const char *a1);
int __fastcall sub_8FD08(const char *a1, const char *a2);
int __fastcall sub_8FE50(int a1, int a2);
int __fastcall sub_8FEEC(const char **a1, int a2);
int __fastcall sub_90004(int a1, int a2, int a3);
int __fastcall sub_90150(int a1, int a2, int a3);
int __fastcall sub_901D8(int a1, int a2, int a3);
int __fastcall sub_90248(int a1, int a2, int a3);
int __fastcall sub_902F4(int a1, int a2, int a3);
int __fastcall sub_90338(int a1, int a2, int a3);
int __fastcall sub_90384(int a1, int a2, int a3);
int __fastcall sub_90400(int a1, int a2, int a3);
int __fastcall sub_904EC(int a1, int a2, int a3);
int __fastcall sub_90538(int a1, int a2, int a3);
int __fastcall sub_905B4(int a1, int a2, int a3);
int __fastcall sub_90600(int a1, int a2, int a3);
int __fastcall sub_9063C(int a1, int a2, int a3);
int __fastcall sub_90678(int a1, int a2, int a3);
int __fastcall sub_9075C(int a1, int a2, int a3);
int __fastcall sub_907A8(int a1, int a2, int a3);
int __fastcall sub_907F4(int a1, int a2, int a3);
int __fastcall sub_90840(int a1, int a2, int a3);
int __fastcall sub_908B8(int a1, int a2, int a3);
int __fastcall sub_9092C(int a1, int a2, int a3);
int __fastcall sub_90D9C(int a1, int a2);
int __fastcall sub_90DE0(int a1, int a2);
int __fastcall sub_90EF4(int a1, int a2);
int __fastcall sub_90F38(int a1, int a2);
int __fastcall sub_9104C(int a1, int a2);
int __fastcall sub_91090(int a1, int a2);
int __fastcall sub_911A4(int a1);
void __fastcall sub_912C4(void *a1);
const char **__fastcall sub_91334(char *a1, char **a2, _DWORD *a3);
int __fastcall sub_91DA4(int a1, int a2);
void __fastcall sub_91EF4(int a1);
_DWORD *__fastcall sub_92048(int a1, unsigned int a2, unsigned int a3, size_t a4);
int __fastcall sub_922EC(int a1, unsigned int a2, unsigned int a3);
int __fastcall sub_92498(int a1, size_t a2);
_DWORD *__fastcall sub_92568(int a1);
void __fastcall sub_92670(int a1);
int __fastcall sub_9274C(int a1, int a2);
int __fastcall sub_92854(int a1, int a2, int a3);
int __fastcall sub_92968(int a1, int a2);
int __fastcall sub_929A4(_DWORD *a1, int a2, int a3);
int __fastcall sub_92AE0(_DWORD *a1, int (__fastcall *a2)(_DWORD, int), int a3);
_DWORD *__fastcall sub_92BA8(size_t a1, int a2, int a3, int a4, int a5);
void __fastcall sub_92CD8(int a1);
void __fastcall sub_92E14(int a1);
int __fastcall sub_92F1C(int a1);
int __fastcall sub_930D4(int a1, int a2);
int __fastcall sub_93190(int a1, int a2);
int __fastcall sub_93250(int a1, unsigned int a2, unsigned int a3);
void __fastcall sub_93568(const void *a1, const void *a2);
int __fastcall sub_93798(int a1);
unsigned int __fastcall sub_93834(int a1, unsigned int *a2);
int __fastcall sub_93904(unsigned __int8 *a1);
bool __fastcall sub_93974(const char *a1, const char *a2);
size_t __fastcall sub_939B4(char *a1, size_t a2);
int sub_93A0C(int a1, const char *a2, int a3, const char *a4, ...);
int __fastcall sub_93CA8(const char *a1);
int __fastcall sub_93F88(char *a1, int a2);
int __fastcall sub_94328(const void **a1, int a2);
void __fastcall sub_943C4(void **a1);
void *__fastcall sub_9442C(unsigned int a1, unsigned int a2, const char *a3);
_DWORD *__fastcall sub_94674(_DWORD *result);
int __fastcall sub_94714(int a1, unsigned int a2);
int __fastcall sub_9495C(int a1, const char *a2, void *a3);
int __fastcall sub_94C78(int a1, unsigned int a2, unsigned int a3);
int __fastcall sub_94F90(int a1, unsigned __int64 a2, unsigned int a3);
int __fastcall sub_95320(int a1, unsigned int a2, unsigned int a3);
int __fastcall sub_9560C(int a1, const void *a2, size_t a3);
int __fastcall sub_95788(int a1, const void *a2, unsigned int a3, int a4, int a5, unsigned int a6, unsigned int a7);
int __fastcall sub_95B84(const char *a1, int a2);
void __fastcall sub_95C38(void *a1);
int __fastcall sub_95CAC(const char *a1);
_DWORD *__fastcall sub_95E40(const char *a1);
unsigned int __fastcall sub_962A0(unsigned int result, unsigned int a2);
unsigned int __fastcall sub_964FC(unsigned int a1, unsigned int a2);
int __fastcall sub_96518(int a1, int a2);
int __fastcall sub_9651E(int result, unsigned int a2);
int __fastcall sub_967AC(int a1, unsigned int a2);
int __fastcall sub_96AD4(__int64 a1);
int __fastcall sub_96AE4(__int64 a1);
int __fastcall sub_96CD0(__int64 a1);
int __fastcall sub_96CE0(__int64 a1);
int __fastcall sub_96D5C(signed __int64 a1, signed __int64 a2);
int __fastcall sub_96DFC(unsigned __int64 a1, unsigned __int64 a2);
unsigned int __fastcall sub_96E38(double a1);
unsigned int __fastcall sub_96E60(double a1);
int __fastcall sub_96EA0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall init(int a1, int a2, int a3);
int nullsub_9(); // weak
int __fastcall sub_96FF8(void (*a1)(void *));
int __fastcall sub_97014(const char *a1, struct stat *a2);
int sub_97020();
int sub_9702C();
int sub_97038();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN loc_186A0; // weak
_UNKNOWN loc_1C200; // weak
_UNKNOWN loc_1FFFC; // weak
_UNKNOWN loc_61A80; // weak
_UNKNOWN loc_962D8; // weak
_UNKNOWN loc_96560; // weak
char aReadSensorOnAs[29] = "read_sensor_on_asic_synopsys"; // weak
_UNKNOWN *off_97C78 = &unk_647948; // weak
__int16 word_98278 = 10; // weak
int (__fastcall *off_982C4)(int, void *src, size_t n) = &sub_1F09C; // weak
int (__fastcall *off_9899C)(int, void *src, size_t n) = &sub_20E10; // weak
char aIncMixedFreqPr[23] = "inc_mixed_freq_prepare"; // weak
_UNKNOWN unk_9A340; // weak
_UNKNOWN unk_9A37C; // weak
_UNKNOWN unk_9A3AC; // weak
unsigned int dword_9B4B4[16] = { 128u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // weak
char a0123456789abcd_0[17] = "0123456789ABCDEF"; // weak
char aHsStreamReadSo[22] = "hs_stream_read_socket"; // weak
char aContentLength[15] = "content-length"; // weak
const char aHttp_1[] = "HTTP"; // idb
const char aD02d02d02d02d0_2[] = "[%d-%02d-%02d %02d:%02d:%02d"; // idb
char aTqFreezethaw[14] = "tq_freezethaw"; // weak
char *off_9FCEC = "http:"; // weak
_UNKNOWN *off_A3F68 = &unk_203D7C; // weak
char aIn[3] = "in"; // weak
char a01[3] = "01"; // weak
_UNKNOWN unk_A4950; // weak
__int16 asc_A5608[302] =
{
  11,
  -30,
  12,
  -29,
  12,
  -28,
  13,
  -27,
  14,
  -26,
  15,
  -25,
  16,
  -24,
  17,
  -23,
  18,
  -22,
  19,
  -21,
  20,
  -20,
  21,
  -19,
  23,
  -18,
  25,
  -17,
  25,
  -16,
  27,
  -15,
  28,
  -14,
  30,
  -13,
  32,
  -12,
  34,
  -11,
  35,
  -10,
  37,
  -9,
  39,
  -8,
  42,
  -7,
  44,
  -6,
  46,
  -5,
  49,
  -4,
  51,
  -3,
  54,
  -2,
  57,
  -1,
  60,
  0,
  63,
  1,
  66,
  2,
  69,
  3,
  73,
  4,
  77,
  5,
  80,
  6,
  84,
  7,
  88,
  8,
  93,
  9,
  97,
  10,
  102,
  11,
  106,
  12,
  111,
  13,
  117,
  14,
  122,
  15,
  127,
  16,
  133,
  17,
  139,
  18,
  145,
  19,
  151,
  20,
  158,
  21,
  164,
  22,
  172,
  23,
  179,
  24,
  186,
  25,
  194,
  26,
  201,
  27,
  209,
  28,
  218,
  29,
  227,
  30,
  235,
  31,
  244,
  32,
  253,
  33,
  263,
  34,
  272,
  35,
  283,
  36,
  293,
  37,
  303,
  38,
  314,
  39,
  325,
  40,
  336,
  41,
  347,
  42,
  359,
  43,
  371,
  44,
  383,
  45,
  396,
  46,
  408,
  47,
  421,
  48,
  433,
  49,
  447,
  50,
  461,
  51,
  474,
  52,
  488,
  53,
  501,
  54,
  517,
  55,
  530,
  56,
  546,
  57,
  561,
  58,
  575,
  59,
  590,
  60,
  605,
  61,
  620,
  62,
  635,
  63,
  652,
  64,
  666,
  65,
  684,
  66,
  698,
  67,
  715,
  68,
  731,
  69,
  747,
  70,
  763,
  71,
  781,
  72,
  796,
  73,
  812,
  74,
  828,
  75,
  845,
  76,
  863,
  77,
  878,
  78,
  893,
  79,
  909,
  80,
  926,
  81,
  943,
  82,
  961,
  83,
  974,
  84,
  993,
  85,
  1008,
  86,
  1023,
  87,
  1039,
  88,
  1055,
  89,
  1071,
  90,
  1088,
  91,
  1106,
  92,
  1118,
  93,
  1137,
  94,
  1149,
  95,
  1163,
  96,
  1176,
  97,
  1196,
  98,
  1211,
  99,
  1225,
  100,
  1240,
  101,
  1248,
  102,
  1263,
  103,
  1279,
  104,
  1295,
  105,
  1303,
  106,
  1320,
  107,
  1329,
  108,
  1346,
  109,
  1355,
  110,
  1373,
  111,
  1382,
  112,
  1392,
  113,
  1411,
  114,
  1421,
  115,
  1431,
  116,
  1441,
  117,
  1451,
  118,
  1461,
  119,
  1472,
  120
}; // weak
_BYTE byte_A60AC[256] =
{
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64,
  1,
  -64,
  128,
  65,
  1,
  -64,
  128,
  65,
  0,
  -63,
  -127,
  64
}; // weak
_BYTE byte_A61AC[256] =
{
  0,
  -64,
  -63,
  1,
  -61,
  3,
  2,
  -62,
  -58,
  6,
  7,
  -57,
  5,
  -59,
  -60,
  4,
  -52,
  12,
  13,
  -51,
  15,
  -49,
  -50,
  14,
  10,
  -54,
  -53,
  11,
  -55,
  9,
  8,
  -56,
  -40,
  24,
  25,
  -39,
  27,
  -37,
  -38,
  26,
  30,
  -34,
  -33,
  31,
  -35,
  29,
  28,
  -36,
  20,
  -44,
  -43,
  21,
  -41,
  23,
  22,
  -42,
  -46,
  18,
  19,
  -45,
  17,
  -47,
  -48,
  16,
  -16,
  48,
  49,
  -15,
  51,
  -13,
  -14,
  50,
  54,
  -10,
  -9,
  55,
  -11,
  53,
  52,
  -12,
  60,
  -4,
  -3,
  61,
  -1,
  63,
  62,
  -2,
  -6,
  58,
  59,
  -5,
  57,
  -7,
  -8,
  56,
  40,
  -24,
  -23,
  41,
  -21,
  43,
  42,
  -22,
  -18,
  46,
  47,
  -17,
  45,
  -19,
  -20,
  44,
  -28,
  36,
  37,
  -27,
  39,
  -25,
  -26,
  38,
  34,
  -30,
  -29,
  35,
  -31,
  33,
  32,
  -32,
  -96,
  96,
  97,
  -95,
  99,
  -93,
  -94,
  98,
  102,
  -90,
  -89,
  103,
  -91,
  101,
  100,
  -92,
  108,
  -84,
  -83,
  109,
  -81,
  111,
  110,
  -82,
  -86,
  106,
  107,
  -85,
  105,
  -87,
  -88,
  104,
  120,
  -72,
  -71,
  121,
  -69,
  123,
  122,
  -70,
  -66,
  126,
  127,
  -65,
  125,
  -67,
  -68,
  124,
  -76,
  116,
  117,
  -75,
  119,
  -73,
  -74,
  118,
  114,
  -78,
  -77,
  115,
  -79,
  113,
  112,
  -80,
  80,
  -112,
  -111,
  81,
  -109,
  83,
  82,
  -110,
  -106,
  86,
  87,
  -105,
  85,
  -107,
  -108,
  84,
  -100,
  92,
  93,
  -99,
  95,
  -97,
  -98,
  94,
  90,
  -102,
  -101,
  91,
  -103,
  89,
  88,
  -104,
  -120,
  72,
  73,
  -119,
  75,
  -117,
  -118,
  74,
  78,
  -114,
  -113,
  79,
  -115,
  77,
  76,
  -116,
  68,
  -124,
  -123,
  69,
  -121,
  71,
  70,
  -122,
  -126,
  66,
  67,
  -125,
  65,
  -127,
  128,
  64
}; // weak
char a0123456789abcd[68] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZbitmain_get_power_temp_fanspeed"; // weak
char byte_A6D38[4] = { '\0', '\0', '\0', '\0' }; // weak
char aD_0[4] = "\b`d"; // weak
_UNKNOWN *off_BAEF8 = (_UNKNOWN *)0x16569; // weak
_UNKNOWN *off_BAEFC = (_UNKNOWN *)0x16551; // weak
int dword_BB2EC = 0; // weak
int dword_BB2F0 = 1; // weak
int dword_BB2F4 = 1; // weak
_UNKNOWN unk_BB2F8; // weak
_UNKNOWN unk_BB308; // weak
_UNKNOWN *off_BB348 = (_UNKNOWN *)0x9C808; // weak
int dword_BBCA4 = 1; // weak
float flt_BBCA8 = ?flt; // weak
int dword_BBCAC = 20; // weak
char aBitmainSubmitN[21] = "bitmain_submit_nonce"; // weak
char aBitmainApiStat[19] = "bitmain_api_status"; // weak
int (*off_BBDB8)() = &sub_3C480; // weak
char *off_BBFD8 = "--version-file"; // weak
double dbl_BC4A8 = 1.84467441e19; // weak
int dword_BC4B0 = 2; // weak
int dword_BC4B4 = 100; // weak
char *off_BC4B8 = "--config|-c"; // weak
char *off_BC544 = "--bitmain-ccdelay"; // weak
int dword_BC598 = 550; // weak
int dword_BC59C = 1320; // weak
int dword_BC5A4 = 1; // weak
char byte_BC5A8 = '\x01'; // weak
int dword_BC5AC = 1250; // weak
int dword_BC5B0 = 500; // weak
int dword_BC5BC = 100; // weak
char byte_BC5C0 = '\x01'; // weak
float flt_BC5C4 = 6.25; // weak
char byte_BC5C9 = '\x01'; // weak
char *off_BC5E8 = "/var/log/hash_rate"; // weak
_UNKNOWN *off_BC5EC = (_UNKNOWN *)4; // weak
int dword_BC5F4 = 5; // weak
_DWORD dword_BC5F8[63] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817
}; // weak
_UNKNOWN unk_BC6F4; // weak
_UNKNOWN unk_BC714; // weak
int (*off_BC718)() = &sub_435E0; // weak
char aTmpStableFileN[22] = "/tmp/stable_file_name"; // weak
char template[] = "/tmp/stable_test-XXXXXX"; // idb
int dword_BC84C = 1; // weak
int dword_BC898[] = { 1 }; // weak
float flt_BC89C = ?flt; // weak
int dword_BC8A0 = 60; // weak
float flt_BC8A4 = 5.0; // weak
char byte_BC8A8 = '\x01'; // weak
int dword_BC8AC = -1; // weak
int dword_BC8B0 = -1; // weak
int dword_BC8B4 = -1; // weak
_UNKNOWN *off_BC8B8 = (_UNKNOWN *)0x10101; // weak
_UNKNOWN unk_BC8D1; // weak
int dword_BCCEC = 50; // weak
_UNKNOWN unk_BCCF1; // weak
char *off_BCCF4 = "HW Sweep"; // weak
char *off_BCD20 = "SW Sweep"; // weak
_DWORD dword_BCD4C[187] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  16,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  0,
  48,
  49,
  60,
  62,
  63,
  64,
  65,
  66,
  68,
  69,
  70,
  71,
  72,
  73,
  75,
  76,
  77,
  78,
  80,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_DWORD dword_BD038[187] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  32,
  33,
  34,
  35,
  36,
  40,
  37,
  38,
  48,
  48,
  49,
  50,
  51,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  75,
  76,
  77,
  78,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  284,
  285,
  286,
  287,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_BD324 = -1; // weak
char *off_BD328 = "/dev/bitmain-lcd"; // weak
int dword_BD474 = 1; // weak
_DWORD dword_BD478[64] =
{
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  4,
  0,
  0,
  0,
  5,
  0,
  0,
  0,
  6,
  0,
  0,
  0,
  7,
  0,
  0,
  0,
  8,
  0,
  0,
  0,
  9,
  0,
  0,
  0,
  10,
  0,
  0,
  0,
  11,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  13,
  0,
  0,
  0,
  14,
  0,
  0,
  0,
  15,
  0,
  0,
  0
}; // weak
_DWORD dword_BD578[18] = { 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0, 5, 0, 0 }; // weak
int dword_BD5C0 = 941; // weak
int dword_BD5C4 = 942; // weak
int dword_BD5C8 = 921; // weak
int dword_BD5CC = 943; // weak
void *(*off_BD5D0)(size_t size) = &malloc; // weak
void (*off_BD5D4)(void *ptr) = &free; // weak
_UNKNOWN unk_BD5D8; // weak
_UNKNOWN unk_BD5E0; // weak
_UNKNOWN unk_BD5E8; // weak
_UNKNOWN unk_BD5F0; // weak
int dword_BD9F0 = 20000; // weak
char a0123456789abcd_1[17] = "0123456789abcdef"; // weak
int stderr; // weak
int stdin; // weak
int stdout; // weak
char byte_BDA18; // weak
int dword_BDA1C; // weak
int dword_BDA20; // weak
float flt_BDA24; // weak
float flt_BDA28; // weak
int dword_BDA2C; // weak
int dword_BDA30; // weak
int dword_BDA34; // weak
int dword_BDA38; // weak
float flt_BDA3C; // weak
float flt_BDA40; // weak
float flt_BDA44; // weak
int dword_BDA48; // weak
int dword_BDA4C; // weak
int dword_BDA50; // weak
int dword_BDA54; // weak
int dword_BDA58; // weak
int dword_BDA5C; // weak
int dword_BDA60; // weak
int dword_BDA64; // weak
int dword_BDA68; // weak
pthread_mutex_t stru_BDA6C; // idb
int dword_BDA84; // weak
_BYTE algn_BDA88[24]; // weak
char byte_BDAA0; // weak
char byte_BDAA1; // weak
char byte_BDAA2; // weak
int dword_BDAA4; // weak
int dword_BDAA8; // weak
int dword_BDAAC; // weak
int dword_BDAB0; // weak
int dword_BDAB4; // weak
pthread_t newthread; // idb
pthread_t dword_BDABC; // idb
int dword_BDAC0; // weak
pthread_mutex_t stru_BDAC4; // idb
int dword_BDADC; // weak
int dword_BDAE0; // weak
int dword_BDAE4; // weak
char byte_BDAE8; // weak
int dword_BDAEC; // weak
int dword_BDAF0; // weak
_DWORD dword_BDAF4[80]; // weak
int dword_BDC34; // weak
int dword_BDC38; // weak
int dword_BDC3C; // weak
int dword_BDC40; // weak
int dword_BDC44; // weak
char byte_BDC48; // weak
int dword_BDC50; // weak
int dword_BDC54; // weak
int dword_BDC58; // weak
_DWORD dword_BDC5C[4]; // weak
int dword_BDC6C; // weak
int dword_BDC70; // weak
int dword_BDC74; // weak
_DWORD dword_BDC78[4]; // weak
char byte_BDC88; // weak
pthread_mutex_t stru_BDC8C; // weak
__time_t dword_BDCA4[2]; // weak
int dword_BDCAC; // weak
float flt_BDCB0[4096]; // weak
int dword_C1CB0; // weak
int dword_C1CB4; // weak
int dword_C1CB8; // weak
char byte_C1CBC; // weak
_UNKNOWN *off_C1DBC; // weak
__time_t dword_C1DC0[8]; // weak
int dword_C1DE0; // weak
_DWORD dword_C1DE4[4]; // weak
_UNKNOWN unk_C1DF4; // weak
int dword_C1E04; // weak
int dword_C1E08; // weak
float flt_C1E0C; // weak
char byte_C1E10; // weak
int dword_C1E14; // weak
float flt_C1E18; // weak
int dword_C1E1C; // weak
_UNKNOWN unk_C1E20; // weak
int dword_C1E40; // weak
int dword_C1E44; // weak
int dword_C1E48; // weak
int dword_C1E4C; // weak
pthread_mutex_t stru_C1E50; // idb
char byte_C1E68; // weak
int dword_C1E6C; // weak
_UNKNOWN unk_C1E70; // weak
_UNKNOWN unk_C1FB0; // weak
_UNKNOWN unk_C1FD0; // weak
int dword_C1FF0[]; // weak
int dword_C1FF4; // weak
int dword_C1FF8; // weak
int dword_C1FFC; // weak
int dword_C2000[]; // weak
int dword_C2004; // weak
int dword_C2008; // weak
int dword_C200C; // weak
int dword_C2010; // weak
_UNKNOWN unk_C2018; // weak
int dword_C2B58; // weak
char byte_C2B5C; // weak
int dword_C2B60; // weak
int dword_C2B68; // weak
int dword_C2B6C; // weak
int dword_C2B70; // weak
int dword_C2B74; // weak
float flt_C2B78; // weak
int dword_C2B7C; // weak
int dword_C2B80; // weak
float flt_C2B84; // weak
int dword_C2B88; // weak
float flt_C2B8C; // weak
float flt_C2B90; // weak
float flt_C2B94; // weak
int dword_C2B98; // weak
int dword_C2B9C; // weak
int dword_C2BA0; // weak
int dword_C2BA4; // weak
int dword_C2BA8; // weak
int dword_C2BAC; // weak
int dword_C2BB0[]; // weak
_UNKNOWN unk_C2BB4; // weak
char s[512]; // idb
int dword_C2DC0; // weak
int dword_C2DC4; // weak
int dword_C2DC8; // weak
char byte_C2DCC[256]; // weak
pthread_mutex_t stru_C2ECC; // idb
pthread_cond_t cond; // idb
int dword_C2F18; // weak
int dword_C2F1C; // weak
char byte_C2F20[200]; // idb
int dword_C2FE8; // weak
int dword_C2FEC; // weak
int dword_C2FF0; // weak
int dword_C2FF4; // weak
char byte_C2FF8[256]; // idb
char dest[256]; // idb
char byte_C31F8[256]; // idb
char byte_C32F8; // idb
_UNKNOWN unk_C33F8; // weak
_UNKNOWN unk_C3470; // weak
_UNKNOWN unk_C3474; // weak
pthread_mutex_t mutex; // idb
int dword_C3490; // weak
int dword_C3494; // weak
sem_t sem; // idb
double dbl_C34A8; // weak
int dword_C34B0; // weak
int dword_C34B4; // weak
int dword_C34B8; // weak
char byte_C34BC; // weak
int dword_C34C0; // weak
char byte_C34C4; // weak
int dword_C34C8; // weak
int dword_C34CC; // weak
int dword_C34D0; // weak
int dword_C34D4; // weak
int dword_C34D8; // weak
__int64 qword_C34E0; // weak
__int64 qword_C34E8; // weak
__int64 qword_C34F0; // weak
int dword_C34F8; // weak
int dword_C34FC; // weak
int dword_C3500; // weak
int dword_C3504; // weak
int dword_C3510; // weak
int dword_C3514; // weak
char byte_C3518; // weak
int dword_C351C; // weak
char byte_C3520[16]; // weak
double dbl_C3530; // weak
char byte_C3544[256]; // weak
char byte_C3644[]; // weak
char byte_C3645; // weak
int dword_C3748; // weak
_BYTE byte_C3F4C[1024]; // weak
int dword_C434C; // weak
_UNKNOWN unk_C4350; // weak
int dword_C4750; // weak
float flt_C4754; // weak
int dword_C4758; // weak
int dword_C475C; // weak
pthread_mutex_t stru_C4760; // idb
int dword_C4778; // weak
pthread_mutex_t stru_C477C; // idb
char byte_C4794; // weak
int dword_C4798; // weak
int dword_C479C; // weak
int dword_C47A0; // weak
char byte_C47A4; // weak
int dword_C47A8; // weak
float flt_C47AC[4]; // weak
float flt_C47BC; // weak
int dword_C47C0; // weak
_DWORD dword_C47C4[926]; // weak
_DWORD dword_C57C4[1024]; // weak
_DWORD dword_C67C4[2048]; // weak
_DWORD dword_C87C4[2048]; // weak
_DWORD dword_CA7C4[2048]; // weak
_DWORD dword_CC7C4[1024]; // weak
__time_t dword_CD7C4[2048]; // weak
float flt_CF7C4[1024]; // weak
float flt_D07C4[1023]; // weak
_UNKNOWN unk_D17C0; // weak
int dword_D17C4[3]; // weak
_UNKNOWN unk_D17D0; // weak
_UNKNOWN unk_D27D0; // weak
_UNKNOWN unk_F423F; // weak
_UNKNOWN unk_F4240; // weak
_UNKNOWN unk_101000; // weak
_UNKNOWN unk_16E360; // weak
_UNKNOWN unk_202020; // weak
_UNKNOWN unk_202402; // weak
_UNKNOWN unk_202802; // weak
_UNKNOWN unk_202806; // weak
_UNKNOWN unk_202A04; // weak
_UNKNOWN unk_202A08; // weak
_UNKNOWN unk_202A0C; // weak
_UNKNOWN unk_202A10; // weak
_UNKNOWN unk_202A14; // weak
_UNKNOWN unk_202A18; // weak
_UNKNOWN unk_202A1C; // weak
_UNKNOWN unk_202A20; // weak
_UNKNOWN unk_202A24; // weak
_UNKNOWN unk_202A2A; // weak
_UNKNOWN unk_20407F; // weak
_UNKNOWN unk_214B4F; // weak
_UNKNOWN unk_2D5B20; // weak
_UNKNOWN unk_2DC6C0; // weak
_UNKNOWN unk_2E2E2E; // weak
_UNKNOWN unk_303A53; // weak
_UNKNOWN unk_313A43; // weak
_UNKNOWN unk_313A46; // weak
_UNKNOWN unk_313A4D; // weak
_UNKNOWN unk_313A4E; // weak
_UNKNOWN unk_313A50; // weak
_UNKNOWN unk_313A52; // weak
_UNKNOWN unk_313A56; // weak
_UNKNOWN unk_323A4E; // weak
_UNKNOWN unk_323A50; // weak
_UNKNOWN unk_323A52; // weak
_UNKNOWN unk_323A56; // weak
_UNKNOWN unk_333A4E; // weak
_UNKNOWN unk_333A52; // weak
_UNKNOWN unk_333A56; // weak
_UNKNOWN unk_343A50; // weak
_UNKNOWN unk_353A50; // weak
_UNKNOWN unk_36EE80; // weak
_UNKNOWN unk_401010; // weak
_UNKNOWN unk_408FFC; // weak
int dword_4D37D8; // weak
char byte_4D37DC; // weak
int dword_4D37E0; // weak
char modes[]; // idb
char byte_4D3804[256]; // weak
int dword_4D3904; // weak
char ptr; // idb
int dword_4D4108; // weak
int dword_4D410C; // weak
int dword_4D4110; // weak
int dword_4D4114; // weak
char byte_4D4136; // idb
char byte_4D4154[20]; // idb
int dword_4D4168; // weak
char byte_4D4171; // weak
char byte_4D4172; // weak
int dword_4D4174; // weak
int dword_4D4178; // weak
int dword_4D417C; // weak
int dword_4D4180; // weak
char byte_4D4184; // weak
int dword_4D4188; // weak
int dword_4D418C; // weak
char byte_4D4190; // weak
int dword_4D4194; // weak
int dword_4D419C; // weak
char byte_4D41A0; // weak
int dword_4D41A4[4]; // weak
unsigned int dword_4D41B4; // weak
unsigned int dword_4D41B8; // weak
int dword_4D41BC; // weak
char byte_4D41C0; // weak
int dword_4D41C4; // weak
pthread_mutex_t stru_4D41C8; // weak
char byte_4D41E0; // weak
__time_t dword_4D41E4[2]; // weak
char byte_4D41EC; // weak
__int64 qword_4D41F0; // weak
char byte_4D41F8; // weak
char byte_4D41F9; // weak
char byte_4D41FC[32]; // idb
char byte_4D421C[64]; // weak
char byte_4D425C; // weak
char byte_4D429C; // weak
char byte_4D42DC; // weak
char byte_4D431C; // idb
char byte_4D435C; // weak
char byte_4D435D; // weak
int dword_4D4360; // weak
int dword_4D4364; // weak
int dword_4D4368; // weak
__int16 word_4D436C; // weak
char byte_4D436E; // weak
char byte_4D4370; // idb
char byte_4D4390; // weak
int dword_4D4394; // weak
_UNKNOWN unk_4D4398; // weak
_UNKNOWN unk_4D5398; // weak
_UNKNOWN unk_4D53A0; // weak
_DWORD dword_4D73D0[122880]; // weak
_DWORD dword_54F3D0[1024]; // weak
pthread_mutex_t stru_5503D0[2]; // weak
pthread_mutex_t stru_550400; // weak
int dword_550418[16]; // weak
int dword_550458; // weak
int dword_55045C; // weak
int dword_550460; // weak
int dword_550464; // weak
int dword_550468; // weak
int dword_55046C; // weak
int dword_550470; // weak
int dword_550474; // weak
int dword_550478; // weak
int dword_55047C; // weak
_DWORD dword_550480[73]; // weak
int dword_5505A4; // weak
int dword_5505A8; // weak
int dword_5505AC; // weak
int dword_5505B0; // weak
int dword_5505B4; // weak
int dword_5505B8; // weak
int dword_5505BC; // weak
int dword_5505C0; // weak
pthread_mutex_t stru_5505C4; // weak
pthread_mutex_t stru_5505DC; // weak
int dword_5505F4; // weak
_UNKNOWN unk_5505F8; // weak
pthread_mutex_t stru_550608[16]; // weak
pthread_mutex_t stru_550788[16]; // weak
pthread_mutex_t stru_550908; // weak
int dword_550920; // weak
int dword_550924; // weak
int dword_550928; // weak
int dword_55092C; // weak
_DWORD dword_550930[5]; // weak
int dword_550944; // weak
int dword_550948; // weak
int dword_55094C; // weak
pthread_mutex_t stru_550950; // weak
_UNKNOWN unk_550968; // weak
_DWORD dword_5509A8[32]; // weak
pthread_mutex_t stru_550A28; // weak
pthread_mutex_t stru_550A40; // weak
int dword_550A58; // weak
int dword_550A5C; // weak
int dword_550A60; // weak
int dword_550A64; // weak
int dword_550A68; // weak
pthread_mutex_t stru_550A6C; // weak
pthread_mutex_t stru_550A88; // weak
int dword_550AA0; // weak
int dword_550AA4; // weak
int dword_550AA8; // weak
int dword_550AAC; // weak
char byte_550AB0; // weak
_DWORD dword_550AB8[4]; // weak
__int16 word_550AC8; // weak
int dword_550ACC; // weak
int dword_550C10; // weak
char byte_550C18; // weak
_UNKNOWN unk_550C1C; // weak
_UNKNOWN unk_550C20; // weak
_UNKNOWN unk_550C24; // weak
_UNKNOWN unk_550C28; // weak
_UNKNOWN unk_550C2C; // weak
_UNKNOWN unk_550C30; // weak
_UNKNOWN unk_550C34; // weak
_UNKNOWN unk_550C38; // weak
float flt_550C3C; // weak
char byte_550C40; // weak
unsigned __int8 byte_550C44[1088]; // weak
pthread_mutex_t stru_551084; // weak
pthread_mutex_t stru_55109C; // weak
int dword_5510B4; // weak
int dword_5510B8; // weak
int dword_5510BC; // weak
unsigned __int8 byte_5510C0[4]; // weak
pthread_mutex_t stru_5510C4; // weak
_DWORD dword_5510DC[65536]; // weak
_UNKNOWN unk_5910DC; // weak
_UNKNOWN unk_5B8D80; // weak
_DWORD dword_6510DC[1024]; // weak
int dword_6520DC; // weak
int dword_6520E0; // weak
int dword_6520E4; // weak
_BYTE algn_6520E8[24]; // weak
int dword_652100; // weak
_UNKNOWN unk_652104; // weak
_UNKNOWN unk_656104; // weak
char s2[17404]; // idb
pthread_rwlock_t stru_65A504; // weak
int dword_65A524; // weak
int dword_65A528; // weak
int dword_65A52C; // weak
int dword_65A530; // weak
int dword_65A534; // weak
int dword_65A538; // weak
int dword_65A53C; // weak
int dword_65A540; // weak
int dword_65A544; // weak
int dword_65A548; // weak
_BYTE byte_65AAB8[2048]; // weak
int dword_65B2B8; // weak
int dword_65B2BC; // weak
double dbl_65B2C0; // weak
int dword_65B2C8; // weak
int dword_65B2CC; // weak
int dword_65B2D0; // weak
int dword_65B2D4; // weak
int dword_65B2D8; // weak
int dword_65B2DC; // weak
int dword_65B2E0; // weak
int dword_65B2E4; // weak
int dword_65B2E8; // weak
int dword_65B2EC; // weak
int dword_65B2F0; // weak
int dword_65B2F4; // weak
int dword_65B2F8; // weak
int dword_65B2FC; // weak
int dword_65B300; // weak
int dword_65B304; // weak
int dword_65B308; // weak
int dword_65B30C; // weak
int dword_65B310; // weak
int dword_65B314; // weak
int dword_65B318; // weak
int dword_65B320; // weak
char byte_65B324; // weak
int dword_65B328; // weak
char byte_65B32C; // weak
char byte_65B32D; // weak
int dword_65B330; // weak
double dbl_65B338; // weak
double dbl_65B340; // weak
int dword_65B348; // weak
double dbl_65B350; // weak
int dword_65B358; // weak
int dword_65B35C; // weak
int dword_65B360; // weak
int dword_65B364; // weak
float flt_65B368; // weak
int dword_65B36C; // weak
int dword_65B370; // weak
int dword_65B374; // weak
int dword_65B378; // weak
char byte_65B37C; // weak
char byte_65B380[]; // weak
char byte_65B384; // weak
int dword_65B388; // weak
char byte_65B38C; // weak
char byte_65B406; // weak
char byte_65B418; // weak
int dword_65B41C; // weak
int dword_65B420; // weak
char byte_65B424; // weak
char byte_65B430; // weak
char byte_65B5B4; // weak
char byte_65B9B8; // weak
int dword_65B9BC; // weak
int dword_65B9C0; // weak
double dbl_65B9C8[96]; // weak
int dword_65BCC8; // weak
_DWORD dword_65BCD0[8196]; // weak
int dword_663CE0; // weak
_DWORD dword_663CE4[1025]; // weak
_UNKNOWN unk_664CE8; // weak
unsigned __int8 byte_664DE8[4]; // weak
char byte_664DEC; // weak
_DWORD dword_664DF0[256]; // weak
_DWORD dword_6651F0[1024]; // weak
__int64 qword_6661F0; // weak
int dword_6661FC; // weak
int dword_666200; // weak
int dword_666204; // weak
char byte_666208; // weak
int dword_66620C; // weak
struct sigaction stru_666214; // weak
int dword_6662A8; // weak
char byte_6662B0[8192]; // weak
float flt_6682B0; // weak
int dword_6682B8; // weak
char byte_6682BC; // weak
pthread_mutex_t stru_6682C0; // weak
pthread_rwlock_t rwlock; // idb
char byte_6682F8[8224]; // weak
int dword_66A318; // weak
struct sigaction stru_66A31C; // weak
char byte_66A3AC[8192]; // weak
pthread_mutex_t stru_66C3AC; // weak
pthread_mutex_t stru_66C3C4; // weak
struct sigaction stru_66C3DC; // weak
int dword_66C46C; // weak
int dword_66C4F0[]; // weak
int dword_66C4F4; // weak
int dword_66C4F8; // weak
_DWORD dword_6744F4[15]; // weak
_UNKNOWN unk_674530; // weak
_DWORD dword_674534[136]; // weak
int dword_674754; // weak
int dword_674758; // weak
int dword_67475C; // weak
int dword_674760; // weak
int dword_674774; // weak
int dword_674804; // weak
_UNKNOWN unk_67492C; // weak
double dbl_674930[4]; // weak
_DWORD dword_674950[1024]; // weak
_DWORD dword_675950[4096]; // weak
int dword_679950[]; // weak
int dword_679954; // weak
int dword_679958; // weak
int dword_67995C; // weak
int dword_679960; // weak
int dword_679964; // weak
int dword_679968; // weak
int dword_67996C; // weak
int dword_679970; // weak
int dword_679974; // weak
char byte_679978[64]; // weak
int dword_6799B8; // weak
int dword_6799BC; // weak
pthread_t dword_6799C0; // weak
int dword_6799C4; // weak
int dword_6799C8; // weak
int dword_6799CC; // weak
int dword_6799D0; // weak
int dword_6799D8[]; // weak
int dword_6799DC; // weak
int dword_6799E0; // weak
_WORD word_6B59A8[676651]; // weak
char byte_7FFFFF[36861]; // weak
_UNKNOWN unk_808FFC; // weak
_DWORD dword_80A010[256]; // weak
_DWORD dword_80A410[289]; // weak
_DWORD dword_80A894[4]; // weak
_UNKNOWN unk_80A8A4; // weak
_UNKNOWN unk_80ACAC; // weak
_UNKNOWN unk_8154AC; // weak
int dword_AB59A8; // weak
int dword_AB59AC; // weak
int dword_AB59B0; // weak
int dword_AB59B4; // weak
int dword_AB59B8; // weak
int dword_AB59BC; // weak
int dword_AB59C0; // weak
int dword_AB59C4; // weak
_QWORD qword_AB59C8[1024]; // weak
int dword_AB79C8[]; // weak
int dword_AB79D0; // weak
int dword_AB79D8; // weak
int dword_AB79E0; // weak
char byte_AB79E8; // weak
char byte_AB79EC; // weak
_UNKNOWN unk_AB79F0; // weak
char byte_AB79F2; // weak
__int16 word_AB79F4; // weak
__int16 word_AB79F6; // weak
_UNKNOWN unk_AB79F8; // weak
__int16 word_AB79FA; // weak
_UNKNOWN unk_AB79FC; // weak
_UNKNOWN unk_AB7A00; // weak
_UNKNOWN unk_AB7A04; // weak
__int16 word_AB7A06; // weak
sem_t stru_AB7A08; // weak
int dword_AB7A18; // weak
int dword_AB7A1C; // weak
int dword_AB7A20; // weak
int dword_AB7A24; // weak
int dword_AB7A28; // weak
int dword_AB7A2C; // weak
char byte_AB7A30[32]; // weak
double dbl_AB7A50; // weak
__int64 qword_AB7A58; // weak
int dword_AB7A60; // weak
int dword_AB7A64; // weak
int dword_AB7A68; // weak
int dword_AB7A6C; // weak
int dword_AB7A70; // weak
int dword_AB7A74; // weak
_UNKNOWN unk_AB7A78; // weak
_DWORD dword_AB7A7C[32]; // weak
int dword_AB7AFC; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (000121E0) --------------------------------------------------------
int init_proc()
{
  return sub_164DC();
}

//----- (000121EC) --------------------------------------------------------
void sub_121EC()
{
  JUMPOUT(0);
}
// 121F8: control flows out of bounds to 0

//----- (0001247C) --------------------------------------------------------
// attributes: thunk
int j___xstat(int ver, const char *filename, struct stat *stat_buf)
{
  return _xstat(ver, filename, stat_buf);
}

//----- (00012498) --------------------------------------------------------
// attributes: thunk
int j___fxstat64()
{
  return _fxstat64();
}
// 1249C: using guessed type int _fxstat64(void);

//----- (0001270C) --------------------------------------------------------
// attributes: thunk
int j___cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return _cxa_atexit(lpfunc, obj, lpdso_handle);
}

//----- (000129C8) --------------------------------------------------------
// attributes: thunk
int j___xstat64()
{
  return _xstat64();
}
// 129CC: using guessed type int _xstat64(void);

//----- (00012A38) --------------------------------------------------------
// attributes: thunk
int j___lxstat64()
{
  return _lxstat64();
}
// 12A3C: using guessed type int _lxstat64(void);

//----- (00012A90) --------------------------------------------------------
int __fastcall sub_12A90(_DWORD *a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r5
  int v3; // r3
  _DWORD *v4; // r0
  int v5; // r6
  int v6; // r0
  _DWORD *v7; // r0
  int v8; // r6
  int v9; // r0
  _DWORD *v10; // r0
  int v11; // r6
  int v12; // r0
  __int64 v13; // r0
  double v14; // r0
  float v15; // s14
  _DWORD *v16; // r0
  int v17; // r6
  int v18; // r0
  _DWORD *v19; // r0
  int v20; // r6
  int v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r6
  _DWORD *v24; // r0
  int v25; // r6
  int v26; // r0
  _DWORD *v27; // r0
  int v28; // r5
  int v29; // r0
  int v30; // r0
  char v32[8192]; // [sp+0h] [bp-2000h] BYREF

  v1 = (_DWORD *)sub_7C250(a1, "strategy");
  v2 = v1;
  if ( v1 && !*v1 )
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v32, "strategy:\n");
      sub_41DB8(4, v32, 0);
    }
    v4 = (_DWORD *)sub_7C250(v2, "open_core_high_voltage");
    v5 = (int)v4;
    if ( v4 && *v4 == 3 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v6 = sub_7DF10((int)v4);
        snprintf(v32, 0x2000u, "open_core_high_voltage: %d\n", v6);
        sub_41DB8(4, v32, 0);
      }
      dword_65B360 = sub_7DF10(v5);
    }
    else if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v32, "get open_core_high_voltage failed\n");
      sub_41DB8(3, v32, 0);
    }
    v7 = (_DWORD *)sub_7C250(v2, "inc_freq_voltage");
    v8 = (int)v7;
    if ( v7 && *v7 == 3 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v9 = sub_7DF10((int)v7);
        snprintf(v32, 0x2000u, "inc_freq_voltage: %d\n", v9);
        sub_41DB8(4, v32, 0);
      }
      dword_65B364 = sub_7DF10(v8);
    }
    else if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v32, "get inc_freq_voltage failed\n");
      sub_41DB8(3, v32, 0);
    }
    v10 = (_DWORD *)sub_7C250(v2, "inc_freq_step");
    v11 = (int)v10;
    if ( v10 && *v10 == 3 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v12 = sub_7DF10((int)v10);
        snprintf(v32, 0x2000u, "inc_freq_step: %d\n", v12);
        sub_41DB8(4, v32, 0);
      }
      v13 = sub_7DF10(v11);
      LODWORD(v14) = sub_96AE4(v13);
      v15 = v14 / 100.0;
      flt_65B368 = v15;
    }
    else if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v32, "get inc_freq_step failed\n");
      sub_41DB8(3, v32, 0);
    }
    v16 = (_DWORD *)sub_7C250(v2, "inc_freq_delay");
    v17 = (int)v16;
    if ( v16 && *v16 == 3 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v18 = sub_7DF10((int)v16);
        snprintf(v32, 0x2000u, "inc_freq_delay: %d\n", v18);
        sub_41DB8(4, v32, 0);
      }
      dword_65B36C = sub_7DF10(v17);
    }
    else if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v32, "get inc_freq_delay failed\n");
      sub_41DB8(3, v32, 0);
    }
    v19 = (_DWORD *)sub_7C250(v2, "poweron_with_reset_high");
    v20 = (int)v19;
    if ( v19 && *v19 == 3 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v21 = sub_7DF10((int)v19);
        snprintf(v32, 0x2000u, "poweron_with_reset_high: %d\n", v21);
        sub_41DB8(4, v32, 0);
      }
      dword_65B370 = sub_7DF10(v20);
    }
    else if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v32, "get poweron_with_reset_high failed\n");
      sub_41DB8(3, v32, 0);
    }
    v22 = (_DWORD *)sub_7C250(v2, "test_loop_securely_find_asic_num");
    v23 = v22;
    if ( v22 && *v22 == 5 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(v32, 0x2000u, "test_loop_securely_find_asic_num: %d\n", 1);
        sub_41DB8(4, v32, 0);
      }
      byte_65B37C = *v23 == 5;
    }
    else if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v32, "get test_loop_securely_find_asic_num failed\n");
      sub_41DB8(4, v32, 0);
    }
    v24 = (_DWORD *)sub_7C250(v2, "pid_target_temp");
    v25 = (int)v24;
    if ( v24 && *v24 == 3 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v26 = sub_7DF10((int)v24);
        snprintf(v32, 0x2000u, "pid_target_temp: %d\n", v26);
        sub_41DB8(4, v32, 0);
      }
      dword_65B374 = sub_7DF10(v25);
    }
    else if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v32, "get pid_target_temp failed\n");
      sub_41DB8(3, v32, 0);
    }
    v27 = (_DWORD *)sub_7C250(v2, "voltage_adjust_setp");
    v28 = (int)v27;
    if ( v27 && *v27 == 3 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v29 = sub_7DF10((int)v27);
        snprintf(v32, 0x2000u, "voltage_adjust_setp: %d\n", v29);
        sub_41DB8(4, v32, 0);
      }
      v30 = sub_7DF10(v28);
      v3 = 0;
      dword_65B378 = v30;
    }
    else
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v32, "get voltage_adjust_setp failed\n");
        sub_41DB8(3, v32, 0);
      }
      return 0;
    }
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v32, "get strategy failed\n");
      sub_41DB8(3, v32, 0);
    }
    return -1;
  }
  return v3;
}
// 12D68: variable 'v14' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B360: using guessed type int dword_65B360;
// 65B364: using guessed type int dword_65B364;
// 65B368: using guessed type float flt_65B368;
// 65B36C: using guessed type int dword_65B36C;
// 65B370: using guessed type int dword_65B370;
// 65B374: using guessed type int dword_65B374;
// 65B378: using guessed type int dword_65B378;
// 65B37C: using guessed type char byte_65B37C;

//----- (00013118) --------------------------------------------------------
int __fastcall sub_13118(_DWORD *a1)
{
  char *v1; // r0
  _DWORD *v3; // r0
  int v4; // r5
  const char *v5; // r12
  int v6; // r0
  _DWORD *v7; // r0
  int v8; // r6
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  _DWORD *v13; // r12
  int v14; // r1
  int v15; // r0
  _DWORD *v16; // r0
  int v17; // r6
  int v18; // r0
  _DWORD *v19; // r0
  int v20; // r6
  int v21; // r0
  _DWORD *v22; // r0
  int v23; // r6
  const char *v24; // lr
  int v25; // r0
  _DWORD *v26; // r0
  int v27; // r6
  int v28; // r0
  int v29; // r0
  int v30; // r8
  signed int v31; // r7
  signed int v32; // r6
  size_t v33; // r9
  signed int v34; // r11
  int v35; // r8
  int v36; // r10
  void *v37; // r0
  int v38; // r10
  void *v39; // r0
  int v40; // r0
  signed int i; // r3
  int v42; // r2
  int v43; // r2
  _DWORD *v44; // r0
  _DWORD *v45; // r6
  _DWORD *v46; // r0
  const char *v47; // r0
  _DWORD *v48; // r0
  int v49; // r0
  _DWORD *v50; // r0
  _DWORD *v51; // r7
  size_t v52; // r0
  int v53; // r0
  unsigned int j; // r6
  _DWORD *v55; // r0
  _DWORD *v56; // r8
  _DWORD *v57; // r0
  int v58; // r9
  int v59; // r0
  int v60; // r5
  int v61; // r5
  _DWORD *v62; // r0
  const char *v63; // r0
  _DWORD *v64; // r0
  int v65; // r9
  int v66; // r0
  _DWORD *v67; // r0
  _DWORD *v68; // r9
  const char *v69; // r0
  const char *v70; // r0
  int v71; // r0
  char v72; // r3
  _DWORD *v73; // r0
  _DWORD *v74; // r4
  _DWORD *v75; // r0
  const char *v76; // r0
  _DWORD *v77; // r0
  int v78; // r0
  _DWORD *v79; // r0
  _DWORD *v80; // r5
  size_t v81; // r0
  int v82; // r0
  unsigned int k; // r4
  _DWORD *v84; // r0
  _DWORD *v85; // r8
  _DWORD *v86; // r0
  int v87; // r9
  int v88; // r0
  int v89; // r7
  int v90; // r7
  _DWORD *v91; // r0
  const char *v92; // r0
  _DWORD *v93; // r0
  int v94; // r8
  int v95; // r0
  _DWORD *v96; // r0
  _DWORD *v97; // r7
  int v98; // r0
  int v99; // r1
  int v100; // r2
  int v101; // r3
  _DWORD *v102; // lr
  int v103; // r1
  int v104; // r2
  const char *v105; // r4
  size_t v106; // r0
  int v107; // r0
  unsigned int m; // r5
  _DWORD *v109; // r0
  _DWORD *v110; // r8
  _DWORD *v111; // r0
  int v112; // r9
  int v113; // r0
  int v114; // r4
  int v115; // r4
  _DWORD *v116; // r0
  const char *v117; // r0
  _DWORD *v118; // r0
  int v119; // r9
  int v120; // r0
  _DWORD *v121; // r0
  const char *v122; // r0
  _DWORD *v123; // r0
  _DWORD *v124; // r8
  const char *v125; // r0
  const char *v126; // r0
  int v127; // r0
  char v128; // r3
  _DWORD *v129; // r0
  _DWORD *v130; // r8
  _DWORD *v131; // r0
  signed int v132; // r5
  _DWORD *v133; // r4
  int v134; // r4
  signed int n; // r4
  int v136; // r0
  int v137; // r4
  const void *v138; // r5
  int v139; // r3
  int ii; // r9
  int v141; // r5
  int v142; // r3
  int v143; // r6
  char v144; // r2
  int v145; // r2
  char *v146; // [sp+14h] [bp-2018h]
  char *v147; // [sp+14h] [bp-2018h]
  char *v148; // [sp+18h] [bp-2014h]
  int v149; // [sp+24h] [bp-2008h]
  int v150; // [sp+24h] [bp-2008h]
  char s[8196]; // [sp+28h] [bp-2004h] BYREF

  v1 = (char *)sub_7C250(a1, "chain");
  v146 = v1;
  if ( !v1 || *(_DWORD *)v1 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "get chain failed\n");
      sub_41DB8(3, s, 0);
      return -1;
    }
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "chain:\n");
    sub_41DB8(4, s, 0);
  }
  v3 = (_DWORD *)sub_7C250(v146, "chain_num");
  v4 = (int)v3;
  if ( !v3 || *v3 != 3 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v5 = "get chain_num failed\n";
    goto LABEL_18;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v6 = sub_7DF10((int)v3);
    snprintf(s, 0x2000u, "chain_num : %d\n", v6);
    sub_41DB8(4, s, 0);
  }
  dword_65B2C8 = sub_7DF10(v4);
  v7 = (_DWORD *)sub_7C250(v146, "chain_row");
  v8 = (int)v7;
  if ( !v7 || *v7 != 3 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v5 = "get chain_row failed\n";
LABEL_18:
    v9 = *(_DWORD *)v5;
    v10 = *((_DWORD *)v5 + 1);
    v11 = *((_DWORD *)v5 + 2);
    v12 = *((_DWORD *)v5 + 3);
    v13 = v5 + 16;
    *(_DWORD *)s = v9;
    *(_DWORD *)&s[4] = v10;
    *(_DWORD *)&s[8] = v11;
    *(_DWORD *)&s[12] = v12;
    v14 = v13[1];
    *(_DWORD *)&s[16] = *v13;
    *(_WORD *)&s[20] = v14;
    sub_41DB8(3, s, 0);
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v15 = sub_7DF10((int)v7);
    snprintf(s, 0x2000u, "chain_row: %d\n", v15);
    sub_41DB8(4, s, 0);
  }
  dword_65B2CC = sub_7DF10(v8);
  v16 = (_DWORD *)sub_7C250(v146, "chain_column");
  v17 = (int)v16;
  if ( !v16 || *v16 != 3 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "get chain_column failed\n");
      sub_41DB8(3, s, 0);
      return -1;
    }
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v18 = sub_7DF10((int)v16);
    snprintf(s, 0x2000u, "chain_column: %d\n", v18);
    sub_41DB8(4, s, 0);
  }
  dword_65B2D0 = sub_7DF10(v17);
  v19 = (_DWORD *)sub_7C250(v146, "chain_domain_num");
  v20 = (int)v19;
  if ( !v19 || *v19 != 3 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "get chain_domain_num failed\n");
      sub_41DB8(3, s, 0);
      return -1;
    }
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v21 = sub_7DF10((int)v19);
    snprintf(s, 0x2000u, "chain_domain_num : %d\n", v21);
    sub_41DB8(4, s, 0);
  }
  dword_65B2D4 = sub_7DF10(v20);
  v22 = (_DWORD *)sub_7C250(v146, "chain_asic_num");
  v23 = (int)v22;
  if ( !v22 || *v22 != 3 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v24 = "get chain_asic_num failed\n";
    goto LABEL_195;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v25 = sub_7DF10((int)v22);
    snprintf(s, 0x2000u, "chain_asic_num : %d\n", v25);
    sub_41DB8(4, s, 0);
  }
  dword_65B2D8 = sub_7DF10(v23);
  v26 = (_DWORD *)sub_7C250(v146, "domain_asic_num");
  v27 = (int)v26;
  if ( !v26 || *v26 != 3 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "get domain_asic_num failed\n");
      sub_41DB8(3, s, 0);
      return -1;
    }
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v28 = sub_7DF10((int)v26);
    snprintf(s, 0x2000u, "domain_asic_num : %d\n", v28);
    sub_41DB8(4, s, 0);
  }
  v29 = sub_7DF10(v27);
  v30 = v29;
  dword_65B2DC = v29;
  v31 = dword_65B2C8;
  v32 = dword_65B2D4;
  v33 = dword_65B2D8;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(
      s,
      0x2000u,
      "chain_num %d, chain_domain_num %d, chain_asic_num %d, domain_asic_num %d\n",
      dword_65B2C8,
      dword_65B2D4,
      dword_65B2D8,
      v29);
    sub_41DB8(3, s, 0);
  }
  dword_65B2FC = (int)calloc(v31, 0x20u);
  if ( !dword_65B2FC )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    snprintf(s, 0x2000u, "malloc %d chain_t failed\n", v31);
    sub_41DB8(3, s, 0);
    goto LABEL_66;
  }
  v34 = 0;
  v148 = (char *)(28 * v30);
  v35 = -28 * v30;
  while ( v31 > v34 )
  {
    v36 = dword_65B2FC;
    *(_DWORD *)(dword_65B2FC + 32 * v34) = v34;
    v37 = calloc(v32, 8u);
    v38 = v36 + 32 * v34;
    *(_DWORD *)(v38 + 12) = v37;
    if ( !v37 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      snprintf(s, 0x2000u, "malloc %d domain_t failed\n", v32);
LABEL_60:
      sub_41DB8(3, s, 0);
LABEL_66:
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "alloc topol failed\n");
        sub_41DB8(3, s, 0);
        return -1;
      }
      return -1;
    }
    v39 = calloc(v33, 0x1Cu);
    *(_DWORD *)(v38 + 8) = v39;
    if ( !v39 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      snprintf(s, 0x2000u, "malloc %d asic_t failed\n", v33);
      goto LABEL_60;
    }
    v40 = 0;
    for ( i = 0; ; ++i )
    {
      v40 += (int)v148;
      if ( v32 <= i )
        break;
      v42 = *(_DWORD *)(v38 + 12);
      *(_DWORD *)(v42 + 8 * i) = i;
      v43 = v42 + 8 * i;
      *(_DWORD *)(v43 + 4) = *(_DWORD *)(v38 + 8) + v40 + v35;
    }
    ++v34;
  }
  v44 = (_DWORD *)sub_7C250(v146, "pic");
  v45 = v44;
  if ( !v44 || *v44 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy(s, "get pic failed\n");
    sub_41DB8(3, s, 0);
    goto LABEL_133;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "pic:\n");
    sub_41DB8(4, s, 0);
  }
  v46 = (_DWORD *)sub_7C250(v45, "type");
  if ( !v46 || *v46 != 2 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy(s, "get type failed\n");
    sub_41DB8(3, s, 0);
    goto LABEL_133;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v47 = (const char *)sub_7DA40(v46);
    snprintf(s, 0x2000u, "type: %s\n", v47);
    sub_41DB8(4, s, 0);
  }
  v48 = (_DWORD *)sub_7C250(v45, "i2c_addr");
  if ( !v48 || *v48 != 3 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy(s, "get i2c_addr failed\n");
    sub_41DB8(3, s, 0);
    goto LABEL_133;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v49 = sub_7DF10((int)v48);
    snprintf(s, 0x2000u, "i2c_addr: %d\n", v49);
    sub_41DB8(4, s, 0);
  }
  v50 = (_DWORD *)sub_7C250(v45, "sensor");
  v51 = v50;
  if ( v50 && *v50 == 1 )
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(s, "pic sensor:\n");
      sub_41DB8(4, s, 0);
    }
    dword_65B304 = sub_7CD9C(v51);
    v52 = sub_7CD9C(v51);
    dword_65B308 = (int)calloc(v52, 0xCu);
    if ( dword_65B308 )
    {
      for ( j = 0; ; ++j )
      {
        if ( j >= sub_7CD9C(v51) )
          goto LABEL_135;
        v55 = (_DWORD *)sub_7CDE8(v51, j);
        v56 = v55;
        if ( !v55 || *v55 )
          break;
        v57 = (_DWORD *)sub_7C250(v55, "index");
        v58 = (int)v57;
        if ( !v57 || *v57 != 3 )
        {
          if ( (unsigned int)off_BC5EC <= 3 )
            return -1;
          snprintf(s, 0x2000u, "get array %d index failed\n", j);
          goto LABEL_117;
        }
        if ( (unsigned int)off_BC5EC > 4 )
        {
          v59 = sub_7DF10((int)v57);
          snprintf(s, 0x2000u, "index: %d\n", v59);
          sub_41DB8(4, s, 0);
        }
        v149 = dword_65B308;
        v60 = 12 * sub_7DF10(v58);
        *(_DWORD *)(v149 + v60) = sub_7DF10(v58);
        v61 = v149 + v60;
        v62 = (_DWORD *)sub_7C250(v56, "type");
        if ( !v62 || *v62 != 2 )
        {
          if ( (unsigned int)off_BC5EC <= 3 )
            return -1;
          snprintf(s, 0x2000u, "get array %d type failed\n", j);
          goto LABEL_117;
        }
        if ( (unsigned int)off_BC5EC > 4 )
        {
          v63 = (const char *)sub_7DA40(v62);
          snprintf(s, 0x2000u, "type: %s\n", v63);
          sub_41DB8(4, s, 0);
        }
        v64 = (_DWORD *)sub_7C250(v56, "iic");
        v65 = (int)v64;
        if ( !v64 || *v64 != 3 )
        {
          if ( (unsigned int)off_BC5EC <= 3 )
            return -1;
          snprintf(s, 0x2000u, "get array %d bind_asic failed\n", j);
          goto LABEL_117;
        }
        if ( (unsigned int)off_BC5EC > 4 )
        {
          v66 = sub_7DF10((int)v64);
          snprintf(s, 0x2000u, "iic: %d\n", v66);
          sub_41DB8(4, s, 0);
        }
        *(_DWORD *)(v61 + 4) = sub_7DF10(v65);
        v67 = (_DWORD *)sub_7C250(v56, "x");
        v68 = v67;
        if ( !v67 || *v67 != 2 )
        {
          if ( (unsigned int)off_BC5EC <= 3 )
            return -1;
          snprintf(s, 0x2000u, "get array %d x failed\n", j);
          goto LABEL_117;
        }
        if ( (unsigned int)off_BC5EC > 4 )
        {
          v69 = (const char *)sub_7DA40(v67);
          snprintf(s, 0x2000u, "x: %s\n", v69);
          sub_41DB8(4, s, 0);
        }
        if ( !dword_65B314 )
        {
          v70 = (const char *)sub_7DA40(v68);
          v71 = strncasecmp(v70, "right", 5u);
          if ( v71 )
            *(_BYTE *)(v61 + 8) = 0;
          else
            v72 = 1;
          if ( !v71 )
            *(_BYTE *)(v61 + 8) = v72;
        }
      }
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      snprintf(s, 0x2000u, "get array %d failed\n", j);
LABEL_117:
      sub_41DB8(3, s, 0);
    }
    else
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      v53 = sub_7CD9C(v51);
      snprintf(s, 0x2000u, "malloc %d sensor_t failed\n", v53);
      sub_41DB8(3, s, 0);
    }
LABEL_133:
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "parse chain pic failed\n");
      sub_41DB8(3, s, 0);
      return -1;
    }
    return -1;
  }
  if ( strcmp((const char *)dword_65B2B8, "BHB28601") )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy(s, "get pic sensor failed\n");
    sub_41DB8(3, s, 0);
    goto LABEL_133;
  }
LABEL_135:
  v73 = (_DWORD *)sub_7C250(v146, "eeprom");
  v74 = v73;
  if ( !v73 || *v73 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy(s, "get eeprom failed\n");
    sub_41DB8(3, s, 0);
    goto LABEL_153;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "eeprom:\n");
    sub_41DB8(4, s, 0);
  }
  v75 = (_DWORD *)sub_7C250(v74, "type");
  if ( !v75 || *v75 != 2 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy(s, "get type failed\n");
    sub_41DB8(3, s, 0);
    goto LABEL_153;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v76 = (const char *)sub_7DA40(v75);
    snprintf(s, 0x2000u, "type: %s\n", v76);
    sub_41DB8(4, s, 0);
  }
  v77 = (_DWORD *)sub_7C250(v74, "i2c_addr");
  if ( !v77 || *v77 != 3 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy(s, "get i2c_addr failed\n");
    sub_41DB8(3, s, 0);
LABEL_153:
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v24 = "parse chain eeprom failed\n";
    goto LABEL_195;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v78 = sub_7DF10((int)v77);
    snprintf(s, 0x2000u, "i2c_addr: %d\n", v78);
    sub_41DB8(4, s, 0);
  }
  v79 = (_DWORD *)sub_7C250(v146, "sensor");
  v80 = v79;
  if ( !v79 || *v79 != 1 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy(s, "get sensor failed\n");
    sub_41DB8(3, s, 0);
    goto LABEL_193;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "sensor:\n");
    sub_41DB8(4, s, 0);
  }
  dword_65B2E0 = sub_7CD9C(v80);
  v81 = sub_7CD9C(v80);
  dword_65B300 = (int)calloc(v81, 0xCu);
  if ( !dword_65B300 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v82 = sub_7CD9C(v80);
    snprintf(s, 0x2000u, "malloc %d sensor_t failed\n", v82);
    sub_41DB8(3, s, 0);
LABEL_193:
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v24 = "parse chain sensor failed\n";
LABEL_195:
    v98 = *(_DWORD *)v24;
    v99 = *((_DWORD *)v24 + 1);
    v100 = *((_DWORD *)v24 + 2);
    v101 = *((_DWORD *)v24 + 3);
    v102 = v24 + 16;
    *(_DWORD *)s = v98;
    *(_DWORD *)&s[4] = v99;
    *(_DWORD *)&s[8] = v100;
    *(_DWORD *)&s[12] = v101;
    v103 = v102[1];
    v104 = v102[2];
    *(_DWORD *)&s[16] = *v102;
    *(_DWORD *)&s[20] = v103;
    *(_WORD *)&s[24] = v104;
    s[26] = BYTE2(v104);
    sub_41DB8(3, s, 0);
    return -1;
  }
  for ( k = 0; k < sub_7CD9C(v80); ++k )
  {
    v84 = (_DWORD *)sub_7CDE8(v80, k);
    v85 = v84;
    if ( !v84 || *v84 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "get array %d failed\n", k);
        goto LABEL_187;
      }
      return -1;
    }
    v86 = (_DWORD *)sub_7C250(v84, "index");
    v87 = (int)v86;
    if ( !v86 || *v86 != 3 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "get array %d index failed\n", k);
        goto LABEL_187;
      }
      return -1;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v88 = sub_7DF10((int)v86);
      snprintf(s, 0x2000u, "index: %d\n", v88);
      sub_41DB8(4, s, 0);
    }
    v89 = dword_65B300;
    v90 = v89 + 12 * sub_7DF10(v87);
    v91 = (_DWORD *)sub_7C250(v85, "type");
    if ( !v91 || *v91 != 2 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "get array %d type failed\n", k);
        goto LABEL_187;
      }
      return -1;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v92 = (const char *)sub_7DA40(v91);
      snprintf(s, 0x2000u, "type: %s\n", v92);
      sub_41DB8(4, s, 0);
    }
    v93 = (_DWORD *)sub_7C250(v85, "bind_asic");
    v94 = (int)v93;
    if ( !v93 || *v93 != 3 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      snprintf(s, 0x2000u, "get array %d bind_asic failed\n", k);
LABEL_187:
      sub_41DB8(3, s, 0);
      goto LABEL_193;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v95 = sub_7DF10((int)v93);
      snprintf(s, 0x2000u, "bind_asic: %d\n", v95);
      sub_41DB8(4, s, 0);
    }
    *(_DWORD *)(v90 + 4) = sub_7DF10(v94);
  }
  v96 = (_DWORD *)sub_7C250(v146, "ctrlboardsensor");
  v97 = v96;
  if ( !v96 || *v96 != 1 )
  {
    v105 = (const char *)dword_65B2B8;
    if ( !strcmp((const char *)dword_65B2B8, "HHB56601") || !strcmp(v105, "HHB56611") || (unsigned int)off_BC5EC <= 3 )
      goto LABEL_255;
    strcpy(s, "get ctrlboard sensor failed\n");
    sub_41DB8(3, s, 0);
    goto LABEL_253;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "ctrlboard sensor:\n");
    sub_41DB8(4, s, 0);
  }
  dword_65B30C = sub_7CD9C(v97);
  v106 = sub_7CD9C(v97);
  dword_65B310 = (int)calloc(v106, 0xCu);
  if ( !dword_65B310 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_255;
    v107 = sub_7CD9C(v97);
    snprintf(s, 0x2000u, "malloc %d sensor_t failed\n", v107);
    sub_41DB8(3, s, 0);
LABEL_253:
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "parse chain ctrlboard sensor failed\n");
      sub_41DB8(3, s, 0);
    }
    goto LABEL_255;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "ctrlboard_sensor_num:%d\n", dword_65B30C);
    sub_41DB8(4, s, 0);
  }
  for ( m = 0; ; ++m )
  {
    if ( m >= sub_7CD9C(v97) )
      goto LABEL_255;
    v109 = (_DWORD *)sub_7CDE8(v97, m);
    v110 = v109;
    if ( !v109 || *v109 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_255;
      snprintf(s, 0x2000u, "get array %d failed\n", m);
      goto LABEL_237;
    }
    v111 = (_DWORD *)sub_7C250(v109, "index");
    v112 = (int)v111;
    if ( !v111 || *v111 != 3 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_255;
      snprintf(s, 0x2000u, "get array %d index failed\n", m);
      goto LABEL_237;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v113 = sub_7DF10((int)v111);
      snprintf(s, 0x2000u, "index: %d\n", v113);
      sub_41DB8(4, s, 0);
    }
    v150 = dword_65B310;
    v114 = 12 * sub_7DF10(v112);
    *(_DWORD *)(v150 + v114) = sub_7DF10(v112);
    v115 = v150 + v114;
    v116 = (_DWORD *)sub_7C250(v110, "type");
    if ( !v116 || *v116 != 2 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_255;
      snprintf(s, 0x2000u, "get array %d type failed\n", m);
      goto LABEL_237;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v117 = (const char *)sub_7DA40(v116);
      snprintf(s, 0x2000u, "type: %s\n", v117);
      sub_41DB8(4, s, 0);
    }
    v118 = (_DWORD *)sub_7C250(v110, "iic");
    v119 = (int)v118;
    if ( !v118 || *v118 != 3 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_255;
      snprintf(s, 0x2000u, "get array %d bind_asic failed\n", m);
      goto LABEL_237;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v120 = sub_7DF10((int)v118);
      snprintf(s, 0x2000u, "iic: %d\n", v120);
      sub_41DB8(4, s, 0);
    }
    *(_DWORD *)(v115 + 4) = sub_7DF10(v119);
    v121 = (_DWORD *)sub_7C250(v110, "x");
    if ( !v121 || *v121 != 2 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_255;
      snprintf(s, 0x2000u, "get array %d x failed\n", m);
      goto LABEL_237;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v122 = (const char *)sub_7DA40(v121);
      snprintf(s, 0x2000u, "x: %s\n", v122);
      sub_41DB8(4, s, 0);
    }
    v123 = (_DWORD *)sub_7C250(v110, "y");
    v124 = v123;
    if ( !v123 || *v123 != 2 )
      break;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v125 = (const char *)sub_7DA40(v123);
      snprintf(s, 0x2000u, "y: %s\n", v125);
      sub_41DB8(4, s, 0);
    }
    if ( !dword_65B314 )
    {
      v126 = (const char *)sub_7DA40(v124);
      v127 = strncasecmp(v126, "right", 5u);
      if ( v127 )
        *(_BYTE *)(v115 + 8) = 0;
      else
        v128 = 1;
      if ( !v127 )
        *(_BYTE *)(v115 + 8) = v128;
    }
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "get array %d y failed\n", m);
LABEL_237:
    sub_41DB8(3, s, 0);
    goto LABEL_253;
  }
LABEL_255:
  v129 = (_DWORD *)sub_7C250(v146, "tpl");
  v130 = v129;
  if ( v129 )
  {
    if ( *v129 == 1 )
    {
      *(_DWORD *)(dword_65B2FC + 16) = sub_7CD9C(v129);
      v131 = (_DWORD *)sub_7CDE8(v130, 0);
      if ( v131 )
      {
        if ( *v131 == 1 )
        {
          *(_DWORD *)(dword_65B2FC + 20) = sub_7CD9C(v131);
          v132 = 0;
          v133 = (_DWORD *)dword_65B2FC;
          v133[6] = calloc(v133[5] * v133[4], 4u);
          while ( 1 )
          {
            if ( v132 >= *(_DWORD *)(dword_65B2FC + 16) )
              goto LABEL_281;
            v147 = (char *)sub_7CDE8(v130, v132);
            v134 = *(_DWORD *)(dword_65B2FC + 20);
            if ( v134 != sub_7CD9C(v147) )
            {
              if ( (unsigned int)off_BC5EC <= 3 )
                goto LABEL_281;
              snprintf(s, 0x2000u, "tpl row:%d column size is different!!!\n", v132);
              sub_41DB8(3, s, 0);
              goto LABEL_279;
            }
            for ( n = 0; n < *(_DWORD *)(dword_65B2FC + 20); ++n )
            {
              v136 = sub_7CDE8(v147, n);
              *(_DWORD *)(*(_DWORD *)(dword_65B2FC + 24) + 4 * (n + *(_DWORD *)(dword_65B2FC + 20) * v132)) = sub_7DF10(v136);
              if ( n )
              {
                if ( n == *(_DWORD *)(dword_65B2FC + 20) - 1 )
                {
                  if ( (unsigned int)off_BC5EC <= 4 )
                    continue;
                  memset(s, 0, 0x2000u);
                  snprintf(
                    s,
                    0x2000u,
                    "%3d],\n",
                    *(_DWORD *)(*(_DWORD *)(dword_65B2FC + 24) + 4 * (n + *(_DWORD *)(dword_65B2FC + 20) * v132)));
                }
                else
                {
                  if ( (unsigned int)off_BC5EC <= 4 )
                    continue;
                  memset(s, 0, 0x2000u);
                  snprintf(
                    s,
                    0x2000u,
                    "%3d,",
                    *(_DWORD *)(*(_DWORD *)(dword_65B2FC + 24) + 4 * (n + *(_DWORD *)(dword_65B2FC + 20) * v132)));
                }
                sub_42CB4(4, s, 0);
              }
              else if ( (unsigned int)off_BC5EC > 4 )
              {
                memset(s, 0, 0x2000u);
                snprintf(
                  s,
                  0x2000u,
                  "data[%2d]=[%d,",
                  v132,
                  *(_DWORD *)(*(_DWORD *)(dword_65B2FC + 24) + 4 * *(_DWORD *)(dword_65B2FC + 20) * v132));
                sub_42CB4(4, s, 0);
              }
            }
            ++v132;
          }
        }
      }
    }
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "get tpl.data array failed\n");
    sub_41DB8(3, s, 0);
LABEL_279:
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "parse chain tpl failed\n");
      sub_41DB8(3, s, 0);
    }
  }
LABEL_281:
  v137 = 1;
  v138 = *(const void **)(dword_65B2FC + 8);
  while ( v137 < dword_65B2C8 )
  {
    v139 = dword_65B2FC + 32 * v137++;
    memcpy(*(void **)(v139 + 8), v138, 28 * dword_65B2D8);
  }
  for ( ii = 0; ii < dword_65B2E0; ++ii )
  {
    v141 = dword_65B300 + 12 * ii;
    v142 = *(_DWORD *)(v141 + 4);
    v143 = *(_DWORD *)(dword_65B2FC + 8) + 28 * v142;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "asic %d, wind %d, y %d\n", v142, dword_65B314, *(_DWORD *)(v143 + 8));
      sub_41DB8(3, s, 0);
    }
    if ( dword_65B314 == 1 )
    {
      if ( *(_DWORD *)(v143 + 8) <= dword_65B2D0 / 3 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "air in\n");
          sub_41DB8(3, s, 0);
          v144 = 1;
          goto LABEL_308;
        }
        goto LABEL_297;
      }
    }
    else if ( dword_65B314 )
    {
      if ( dword_65B314 == 2 )
      {
        if ( *(_DWORD *)(v143 + 4) <= dword_65B2CC / 3 )
          goto LABEL_303;
      }
      else if ( dword_65B314 == 3 && *(_DWORD *)(v143 + 4) >= 2 * dword_65B2CC / 3 )
      {
LABEL_303:
        if ( (unsigned int)off_BC5EC > 3 )
        {
          v145 = 0;
LABEL_296:
          strcpy(s, "air in\n");
          sub_41DB8(3, s, v145);
        }
LABEL_297:
        v144 = 1;
        goto LABEL_308;
      }
    }
    else if ( *(_DWORD *)(v143 + 8) >= 2 * dword_65B2D0 / 3 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        v145 = dword_65B314;
        goto LABEL_296;
      }
      goto LABEL_297;
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "air out\n");
      sub_41DB8(3, s, 0);
    }
    v144 = 0;
LABEL_308:
    *(_BYTE *)(v141 + 8) = v144;
  }
  return 0;
}
// 13D20: variable 'v72' is possibly undefined
// 147A0: variable 'v128' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B2B8: using guessed type int dword_65B2B8;
// 65B2C8: using guessed type int dword_65B2C8;
// 65B2CC: using guessed type int dword_65B2CC;
// 65B2D0: using guessed type int dword_65B2D0;
// 65B2D4: using guessed type int dword_65B2D4;
// 65B2D8: using guessed type int dword_65B2D8;
// 65B2DC: using guessed type int dword_65B2DC;
// 65B2E0: using guessed type int dword_65B2E0;
// 65B2FC: using guessed type int dword_65B2FC;
// 65B300: using guessed type int dword_65B300;
// 65B304: using guessed type int dword_65B304;
// 65B308: using guessed type int dword_65B308;
// 65B30C: using guessed type int dword_65B30C;
// 65B310: using guessed type int dword_65B310;
// 65B314: using guessed type int dword_65B314;

//----- (00014CD8) --------------------------------------------------------
int __fastcall main(int a1, const char **a2, char **a3)
{
  const char *v4; // r4
  FILE *v5; // r9
  size_t v6; // r0
  size_t v7; // r7
  int v8; // r6
  size_t i; // r5
  const unsigned __int16 **v10; // r0
  int sa_handler_low; // r3
  int v12; // r3
  void *v13; // r5
  _DWORD *v14; // r4
  _DWORD *v15; // r0
  int v16; // r4
  int v17; // r4
  int v18; // r4
  int v19; // r2
  int v20; // r5
  int v21; // r9
  int *v22; // r3
  int v23; // r4
  unsigned int v24; // r6
  int v25; // r3
  int *p_count; // r7
  int v27; // r0
  int v28; // r1
  __int64 v29; // r0
  __int64 v30; // r6
  int v31; // r1
  int v32; // r0
  unsigned __int64 v33; // r2
  unsigned __int64 v34; // kr08_8
  __int64 v35; // r0
  __int64 v36; // r6
  int v37; // r1
  int v38; // r0
  unsigned __int64 v39; // r2
  unsigned __int64 v40; // kr10_8
  void *v41; // r1
  void *v42; // r2
  void *v43; // r3
  void *v44; // r1
  void *v45; // r2
  void *v46; // r3
  unsigned int v47; // r1
  unsigned int v48; // r2
  char *v49; // r2
  void ***v50; // r1
  unsigned int v51; // t1
  double v52; // d8
  double v53; // r0
  unsigned __int64 v54; // r2
  int v55; // t1
  int v56; // r0
  int v57; // r6
  unsigned int v58; // r0
  char v59; // lr
  unsigned int v60; // r7
  int v61; // r3
  int *v62; // r0
  int *v63; // r0
  int *v64; // r0
  int *v65; // r0
  unsigned int v67; // r0
  struct sigaction *act; // [sp+1Ch] [bp-26Ch]
  __int64 v70; // [sp+20h] [bp-268h]
  pthread_mutex_t *v71; // [sp+28h] [bp-260h]
  int *v72; // [sp+2Ch] [bp-25Ch]
  __int64 v73; // [sp+30h] [bp-258h]
  int v74; // [sp+38h] [bp-250h]
  double v75; // [sp+38h] [bp-250h]
  double v76; // [sp+38h] [bp-250h]
  int v77; // [sp+40h] [bp-248h]
  void **v78; // [sp+40h] [bp-248h]
  int v79; // [sp+44h] [bp-244h]
  int v80; // [sp+44h] [bp-244h]
  int v81; // [sp+4Ch] [bp-23Ch]
  __time_t tv_sec; // [sp+50h] [bp-238h]
  int v83; // [sp+60h] [bp-228h]
  int v84; // [sp+64h] [bp-224h]
  void **v85; // [sp+78h] [bp-210h] BYREF
  unsigned int v86[6]; // [sp+7Ch] [bp-20Ch] BYREF
  unsigned int v87; // [sp+94h] [bp-1F4h]
  int v88; // [sp+98h] [bp-1F0h] BYREF
  char dest[32]; // [sp+9Ch] [bp-1ECh] BYREF
  _BYTE command[64]; // [sp+BCh] [bp-1CCh] BYREF
  struct sigaction v91; // [sp+FCh] [bp-18Ch] BYREF
  _DWORD s[64]; // [sp+188h] [bp-100h] BYREF
  struct timespec v93[1023]; // [sp+288h] [bp+0h] BYREF

  v91.sa_handler = (__sighandler_t)sub_395F4;
  v91.sa_flags = 0;
  sigemptyset(&v91.sa_mask);
  sigaction(15, &v91, &stru_66A31C);
  sigaction(2, &v91, &stru_66C3DC);
  sigaction(6, &v91, &stru_666214);
  sem_init(&sem, 0, 0);
  sub_39EFC((int)&stru_6682C0, "main", 3073);
  v4 = *a2;
  memset(s, 0, sizeof(s));
  memset(command, 0, sizeof(command));
  snprintf(command, 0x40u, "pidof %s", v4);
  v5 = popen(command, "r");
  if ( v5 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets((char *)s, 256, v5) )
          {
            v7 = 0;
            v8 = 0;
            pclose(v5);
            act = (struct sigaction *)s;
            for ( i = 1; strlen((const char *)s) >= i; ++i )
            {
              memset(dest, 0, sizeof(dest));
              v10 = _ctype_b_loc();
              sa_handler_low = LOBYTE(act->sa_handler);
              act = (struct sigaction *)((char *)act + 1);
              if ( ((*v10)[sa_handler_low] & 0x2000) != 0 )
              {
                strncpy(dest, (const char *)s + v7, i - v7 - 1);
                v12 = strtol(dest, 0, 10);
                if ( v12 > 0 && (++v8, byte_4D4172) && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
                {
                  v7 = i;
                  snprintf((char *)v93, 0x2000u, "Parsed proc id is: %d\n", v12);
                  sub_41DB8(7, (const char *)v93, 0);
                }
                else
                {
                  v7 = i;
                }
              }
            }
            if ( v8 )
            {
              if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
              {
                snprintf((char *)v93, 0x2000u, " %d instance of %s is  already Running on this machine", v8, v4);
                sub_41DB8(3, (const char *)v93, 0);
              }
              if ( v8 != 1 )
              {
                snprintf((char *)v93, 0x2000u, "%s is forbidden to start twice, will exit immediately!", *a2);
                sub_41DB8(3, (const char *)v93, 1);
              }
            }
            goto LABEL_30;
          }
        }
        while ( !byte_4D4172 );
        if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 6 )
          break;
LABEL_9:
        if ( byte_4D4171 || dword_BC5F4 > 6 )
        {
LABEL_11:
          v6 = strlen((const char *)s);
          snprintf((char *)v93, 0x2000u, "strlen is: %d\n", v6);
          sub_41DB8(7, (const char *)v93, 0);
        }
      }
      snprintf((char *)v93, 0x2000u, "pidof %s command result is: %s\n", v4, (const char *)s);
      sub_41DB8(7, (const char *)v93, 0);
      if ( byte_4D4172 )
      {
        if ( byte_6682BC )
          goto LABEL_11;
        goto LABEL_9;
      }
    }
  }
  if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
  {
    snprintf((char *)v93, 0x2000u, " app-service:%s Not Found!!!", v4);
    sub_41DB8(7, (const char *)v93, 0);
  }
LABEL_30:
  v13 = calloc(1u, 0x1DE0u);
  dword_66A318 = (int)v13;
  v14 = calloc(1u, 0x188u);
  dword_66620C = (int)v14;
  v15 = calloc(1u, 0x40u);
  v15[9] = v14;
  v14[5] = v13;
  dword_666204 = (int)v15;
  sub_82B18("/etc/bitmain_category.conf");
  if ( !sub_3CDAC(a1, a2) )
    sub_473B4(4u, "config load err restore factory config please");
  sub_3BFBC();
  if ( sub_38EF8() )
    sub_473B4(4u, "socket init failed!");
  if ( sub_4AC40() )
  {
    sub_473B4(4u, "basic init failed!");
    while ( 1 )
      sleep(0xAu);
  }
  dword_6682B8 = (int)calloc(1u, 0x40u);
  pthread_attr_init((pthread_attr_t *)command);
  pthread_attr_setstacksize((pthread_attr_t *)command, 0x200000u);
  if ( sub_44EC8(dword_6682B8, (const pthread_attr_t *)command, (void *(*)(void *))sub_390C4, (void *)dword_6682B8)
    && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 2) )
  {
    snprintf((char *)v93, 0x2000u, "%s: create thread for get api status failed\n", "main");
    sub_41DB8(3, (const char *)v93, 0);
  }
  pthread_detach(*(_DWORD *)(dword_6682B8 + 12));
  v16 = *(_DWORD *)(*(_DWORD *)(dword_666204 + 36) + 20);
  if ( pthread_mutex_init((pthread_mutex_t *)(v16 + 112), 0) )
    sub_39E44("bitmain_soc_prepare", 2054);
  sub_39EFC(v16, "bitmain_soc_prepare", 2055);
  sub_39EFC(v16 + 384, "bitmain_soc_prepare", 2056);
  sub_39EFC(v16 + 2248, "bitmain_soc_prepare", 2057);
  sub_39EFC(v16 + 4112, "bitmain_soc_prepare", 2058);
  sub_39EFC(v16 + 5976, "bitmain_soc_prepare", 2059);
  memset(v93, 0, 0x20u);
  LOWORD(v93[1].tv_nsec) = dword_BC598;
  BYTE2(v93[1].tv_sec) = dword_C34C0;
  LOBYTE(v93[0].tv_nsec) = (2 * (byte_C34BC & 1)) | 0xFC;
  HIWORD(v93[1].tv_nsec) = dword_BC59C;
  LOBYTE(v93[0].tv_sec) = 81;
  HIWORD(v93[0].tv_sec) = 26;
  BYTE1(v93[0].tv_nsec) = 7;
  LOWORD(v93[1].tv_sec) = 13833;
  HIBYTE(v93[1].tv_sec) = 80;
  LOWORD(v93[2].tv_sec) = 2570;
  LOBYTE(v93[3].tv_sec) = 4;
  *(__time_t *)((char *)&v93[3].tv_sec + 2) = 39322000;
  HIWORD(v93[3].tv_nsec) = sub_4596C((int)v93, 30);
  v17 = sub_4E520(
          v93[0].tv_sec,
          v93[0].tv_nsec,
          v93[1].tv_sec,
          v93[1].tv_nsec,
          v93[2].tv_sec,
          v93[2].tv_nsec,
          v93[3].tv_sec,
          v93[3].tv_nsec);
  if ( (unsigned int)sub_47394() > 2 && sub_47394() != 3 )
  {
    v67 = sub_473A4();
    sub_473B4(v67, 0);
    while ( 1 )
      sleep(0xAu);
  }
  if ( !v17 )
  {
    sub_473B4(4u, "soc init failed!");
    while ( 1 )
      sleep(0xAu);
  }
  sub_473B4(2u, 0);
  if ( !byte_C34C4 )
    sub_4C3B0();
  pthread_mutex_lock(&mutex);
  if ( dword_C3490 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy((char *)v93, "start the cached job");
      sub_41DB8(3, (const char *)v93, 0);
    }
    sub_3C480((const void *)dword_C3494, dword_C3490);
  }
  pthread_mutex_unlock(&mutex);
  sub_49B48();
  while ( !*(_BYTE *)(dword_66620C + 364) )
  {
    v72 = (int *)dword_666204;
    v18 = *(_DWORD *)(*(_DWORD *)(dword_666204 + 36) + 20);
    v71 = (pthread_mutex_t *)v18;
    pthread_mutex_lock(&stru_550400);
    if ( pthread_mutex_lock((pthread_mutex_t *)v18) )
    {
      v65 = _errno_location();
      snprintf(
        (char *)v93,
        0x2000u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v65,
        "bmminer.c",
        "bitmain_c5_scanhash",
        2186);
      sub_41DB8(3, (const char *)v93, 1);
    }
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v18 + 24)) )
    {
      v64 = _errno_location();
      snprintf(
        (char *)v93,
        0x2000u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v64,
        "bmminer.c",
        "bitmain_c5_scanhash",
        2186);
      sub_41DB8(3, (const char *)v93, 1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)v18) )
    {
      v63 = _errno_location();
      snprintf(
        (char *)v93,
        0x2000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v63,
        "bmminer.c",
        "bitmain_c5_scanhash",
        2186);
      sub_41DB8(3, (const char *)v93, 1);
    }
    v70 = 0;
LABEL_68:
    if ( dword_6799E0 )
    {
      while ( 1 )
      {
        v19 = 0;
        v20 = dword_6799D8[15 * dword_6799DC + 8];
        v21 = dword_6799D8[15 * dword_6799DC + 3];
        v22 = &dword_6799D8[15 * dword_6799DC];
        v74 = v22[6];
        v79 = v22[7];
        v23 = v22[9];
        v77 = v22[4];
        v24 = (v22[5] << 24) | HIBYTE(v22[5]) | ((unsigned int)v22[5] >> 8) & 0xFF00 | (v22[5] << 8) & 0xFF0000;
        do
          ++v19;
        while ( v19 != 32 );
        if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
        {
          snprintf(
            (char *)v93,
            0x2000u,
            "%s: job_id:0x%x   work_id:0x%x   nonce2:0x%llx nonce3:0x%x   version:0x%x\n",
            "bitmain_c5_scanhash",
            v21,
            v77,
            __PAIR64__(v79, v74),
            v20,
            v24);
          sub_41DB8(7, (const char *)v93, 0);
        }
        if ( (unsigned int)dword_6799DC > 0xFFD )
          v25 = 0;
        else
          v25 = dword_6799DC;
        p_count = (int *)&v71[7].__count;
        if ( (unsigned int)dword_6799DC <= 0xFFD )
          ++v25;
        dword_6799DC = v25;
        --dword_6799E0;
        if ( v20 == dword_C34C8 && v77 == dword_C34CC && v24 == dword_C34D0 )
        {
          if ( sub_27EC8(v23) == 1 )
          {
            if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
            {
              strcpy((char *)v93, "repeat nonce error");
              sub_41DB8(7, (const char *)v93, 0);
            }
LABEL_163:
            sub_3B2AC((int)v72);
            sub_28308(v23);
          }
          goto LABEL_68;
        }
        dword_C34C8 = v20;
        dword_C34CC = v77;
        dword_C34D0 = v24;
        if ( byte_4D4172 )
          break;
LABEL_138:
        switch ( dword_BC4B0 - v21 )
        {
          case 0:
            goto LABEL_91;
          case 1:
LABEL_90:
            p_count = &v71[84].__spins;
            goto LABEL_91;
          case 2:
LABEL_136:
            p_count = &v71[162].__kind;
            goto LABEL_91;
          case 3:
LABEL_135:
            p_count = (int *)&v71[240].__count;
LABEL_91:
            sub_3B14C(v72, (int *)&v85, (int)p_count, (int)p_count, __SPAIR64__(v79, v74), v24);
            v80 = *p_count;
            v78 = v85;
            if ( clock_gettime(1, v93) >= 0 )
            {
              tv_sec = v93[0].tv_sec;
              v81 = v93[0].tv_nsec / 1000;
            }
            v75 = *((double *)v78 + 39);
            v83 = dword_C34D4;
            v84 = dword_C34D8;
            LODWORD(v29) = sub_96E60(v75);
            v30 = v29;
            if ( v29 != qword_C34E0 )
            {
              v31 = 0;
              v32 = 0;
              qword_C34E0 = v30;
              qword_C34E8 = 0;
              if ( v30 )
              {
                v33 = v30;
                while ( 1 )
                {
                  v33 >>= 1;
                  if ( !v33 )
                    break;
                  v34 = __PAIR64__(v32, v31) + 1;
                  v32 = HIDWORD(v34);
                  v31 = v34;
                }
              }
              else
              {
                v31 = -1;
                v32 = -1;
              }
              LODWORD(qword_C34E8) = v31;
              HIDWORD(qword_C34E8) = v32;
              if ( byte_4D4172 )
              {
                if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 6 )
                {
                  snprintf(
                    (char *)v93,
                    0x2000u,
                    "%s: pool_diff:%llu work_diff:%f pool_diff_bit:%llu ...\n",
                    "hashtest_submit",
                    v30,
                    v75,
                    __PAIR64__(v32, v31));
                  sub_41DB8(7, (const char *)v93, 0);
                }
              }
            }
            v76 = dbl_BC4A8;
            LODWORD(v35) = sub_96E60(dbl_BC4A8);
            v36 = v35;
            if ( v35 != qword_C34F0 )
            {
              v37 = 0;
              qword_C34F0 = v36;
              v38 = 0;
              if ( v36 )
              {
                v39 = v36;
                while ( 1 )
                {
                  v39 >>= 1;
                  if ( !v39 )
                    break;
                  v40 = __PAIR64__(v38, v37) + 1;
                  v38 = HIDWORD(v40);
                  v37 = v40;
                }
              }
              else
              {
                v37 = -1;
                v38 = -1;
              }
              dword_C34F8 = v37;
              dword_C34FC = v38;
              if ( byte_4D4172 )
              {
                if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 6 )
                {
                  snprintf(
                    (char *)v93,
                    0x2000u,
                    "%s:net_diff:%llu current_diff:%f net_diff_bit %llu ...\n",
                    "hashtest_submit",
                    v36,
                    v76,
                    __PAIR64__(v38, v37));
                  sub_41DB8(7, (const char *)v93, 0);
                }
              }
            }
            v41 = v78[33];
            v42 = v78[34];
            v43 = v78[35];
            s[2] = v78[32];
            s[3] = v41;
            s[4] = v42;
            s[5] = v43;
            v44 = v78[37];
            v45 = v78[38];
            v46 = v78[39];
            s[6] = v78[36];
            s[7] = v44;
            s[8] = v45;
            s[9] = v46;
            s[0] = 80;
            s[1] = 0;
            v47 = (unsigned int)v78[17];
            v48 = (unsigned int)v78[18];
            v86[0] = (unsigned int)v78[16];
            v86[1] = v47;
            v86[2] = v48;
            sub_45A8C((int)&s[10], v86, 0xCu);
            v86[0] = v20;
            sub_45A8C((int)&s[13], v86, 4u);
            sub_2FF18((int)s, v86);
            memset(s, 0, 0xE8u);
            sub_300CC(v86, 32, dest);
            v49 = (char *)&v88;
            v50 = &v85;
            do
            {
              v51 = *((_DWORD *)v49 + 1);
              v49 += 4;
              v50[1] = (void **)bswap32(v51);
              ++v50;
            }
            while ( &dest[28] != v49 );
            if ( v88 )
            {
              if ( ++dword_C3500 > 257 )
              {
                v52 = (double)(v81 - v84) / 1000.0 / 1000.0 + (double)(tv_sec - v83);
                if ( v52 > 10.0 )
                {
                  sub_63ED8();
                  dword_C34D4 = tv_sec;
                  dword_C34D8 = v81;
                  if ( (unsigned int)off_BC5EC > 3 )
                  {
                    snprintf((char *)v93, 0x2000u, "nonce fifo flush by nonce, last_ts = %.2f.\n", v52);
                    sub_41DB8(3, (const char *)v93, 0);
                  }
                }
              }
              if ( sub_27EC8(v23) == 1 )
              {
                if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
                {
                  strcpy((char *)v93, "hash2_32 error");
                  sub_41DB8(7, (const char *)v93, 0);
                }
                sub_3B2AC((int)v72);
                sub_28308(v23);
              }
              if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
              {
                snprintf((char *)v93, 0x2000u, "%s: HASH2_32[7] != 0", "hashtest_submit");
                sub_41DB8(7, (const char *)v93, 0);
              }
              goto LABEL_124;
            }
            HIDWORD(v54) = &v88;
            LODWORD(v54) = 0;
            dword_C3500 = 0;
            break;
          default:
            if ( byte_6682BC )
              goto LABEL_164;
LABEL_160:
            if ( byte_4D4171 || dword_BC5F4 > 2 )
            {
LABEL_164:
              snprintf((char *)v93, 0x2000u, "%s: job_id non't found ...\n", "bitmain_c5_scanhash");
              sub_41DB8(3, (const char *)v93, 0);
            }
            if ( sub_27EC8(v23) == 1 )
              goto LABEL_163;
            goto LABEL_68;
        }
        while ( 1 )
        {
          v55 = *(_DWORD *)(HIDWORD(v54) - 4);
          HIDWORD(v54) -= 4;
          if ( v55 )
            break;
          LODWORD(v54) = v54 + 1;
          if ( (_DWORD)v54 == 7 )
          {
            v54 = 7;
            goto LABEL_146;
          }
        }
        v54 = (int)v54;
LABEL_146:
        if ( (unsigned __int64)qword_C34E8 >> 5 <= v54 )
        {
          v56 = sub_27D1C();
          v57 = sub_81160(v20, v56);
          v58 = sub_81144(v20);
          v59 = qword_C34E8 & 0x1F;
          v60 = v58;
          v61 = qword_C34E8 >> 5;
          ++qword_AB59C8[256 * v23 + v57];
          if ( bswap32(*(&v87 - v61)) < 0xFFFFFFFF >> v59
            && !strcmp(*(const char **)(dword_66A318 + 860), (const char *)v78[72]) )
          {
            if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
            {
              snprintf(
                (char *)v93,
                0x2000u,
                "%s: chain %d which_asic_nonce %d which_core_nonce %d",
                "hashtest_submit",
                v23,
                v57,
                v60);
              sub_41DB8(7, (const char *)v93, 0);
            }
            *(_QWORD *)&dword_AB79C8[2 * v23] += 256LL;
            sub_3BD58((int)v72, (const char **)v78, v20, v80);
            v70 += 256;
          }
          else if ( bswap32(v87) <= 0xFFFFFE )
          {
            *(_QWORD *)&dword_AB79C8[2 * v23] += 256LL;
            v70 += 256;
          }
        }
LABEL_124:
        sub_3B0C8(&v85, "bmminer.c", "bitmain_c5_scanhash", 2281);
        if ( !dword_6799E0 )
          goto LABEL_125;
      }
      if ( !byte_6682BC && !byte_4D4171 && dword_BC5F4 <= 6 )
      {
        v27 = dword_BC4B0;
        v28 = dword_BC4B0 - v21;
        goto LABEL_87;
      }
      snprintf((char *)v93, 0x2000u, "%s: Chain ID J%d ...\n", "bitmain_c5_scanhash", v23 + 1);
      sub_41DB8(7, (const char *)v93, 0);
      if ( !byte_4D4172 )
        goto LABEL_138;
      v27 = dword_BC4B0;
      v28 = dword_BC4B0 - v21;
      if ( !byte_6682BC )
      {
LABEL_87:
        if ( !byte_4D4171 && dword_BC5F4 <= 6 )
        {
          switch ( v28 )
          {
            case 0:
              goto LABEL_91;
            case 1:
              goto LABEL_90;
            case 2:
              goto LABEL_136;
            case 3:
              goto LABEL_135;
            default:
              goto LABEL_160;
          }
        }
      }
      snprintf((char *)v93, 0x2000u, "%s: given_id:%d job_id:%d switch:%d  ...\n", "bitmain_c5_scanhash", v27, v21, v28);
      sub_41DB8(7, (const char *)v93, 0);
      goto LABEL_138;
    }
LABEL_125:
    qword_AB7A58 += v70;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)&v71[1]) )
    {
      v62 = _errno_location();
      snprintf(
        (char *)v93,
        0x2000u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v62,
        "bmminer.c",
        "bitmain_c5_scanhash",
        2284);
      sub_41DB8(3, (const char *)v93, 1);
    }
    off_BC718();
    pthread_mutex_unlock(&stru_550400);
    sub_44890();
    if ( v70 )
    {
      v73 = 0xFFFFFFFFLL * v70;
      if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
      {
        snprintf((char *)v93, 0x2000u, "%s: hashes %llu ...\n", "bitmain_c5_scanhash", v73);
        sub_41DB8(7, (const char *)v93, 0);
      }
      if ( v73 )
      {
        LODWORD(v53) = sub_96AE4(v73);
        dbl_C34A8 = v53 / 1000000000.0 + dbl_C34A8;
      }
    }
  }
  sem_destroy(&sem);
  sub_21D18();
  sub_83478();
  return 0;
}
// 157D8: control flows out of bounds to 157DC
// 15E4C: control flows out of bounds to 15E50
// 158CC: variable 'v29' is possibly undefined
// 159E4: variable 'v35' is possibly undefined
// 15BD4: variable 'v81' is possibly undefined
// 15BE8: variable 'tv_sec' is possibly undefined
// 15DD0: variable 'v53' is possibly undefined
// BC4A8: using guessed type double dbl_BC4A8;
// BC4B0: using guessed type int dword_BC4B0;
// BC598: using guessed type int dword_BC598;
// BC59C: using guessed type int dword_BC59C;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC5F4: using guessed type int dword_BC5F4;
// BC718: using guessed type int (*off_BC718)();
// C3490: using guessed type int dword_C3490;
// C3494: using guessed type int dword_C3494;
// C34A8: using guessed type double dbl_C34A8;
// C34BC: using guessed type char byte_C34BC;
// C34C0: using guessed type int dword_C34C0;
// C34C4: using guessed type char byte_C34C4;
// C34C8: using guessed type int dword_C34C8;
// C34CC: using guessed type int dword_C34CC;
// C34D0: using guessed type int dword_C34D0;
// C34D4: using guessed type int dword_C34D4;
// C34D8: using guessed type int dword_C34D8;
// C34E0: using guessed type __int64 qword_C34E0;
// C34E8: using guessed type __int64 qword_C34E8;
// C34F0: using guessed type __int64 qword_C34F0;
// C34F8: using guessed type int dword_C34F8;
// C34FC: using guessed type int dword_C34FC;
// C3500: using guessed type int dword_C3500;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 550400: using guessed type pthread_mutex_t stru_550400;
// 666204: using guessed type int dword_666204;
// 66620C: using guessed type int dword_66620C;
// 666214: using guessed type struct sigaction stru_666214;
// 6682B8: using guessed type int dword_6682B8;
// 6682BC: using guessed type char byte_6682BC;
// 6682C0: using guessed type pthread_mutex_t stru_6682C0;
// 66A318: using guessed type int dword_66A318;
// 66A31C: using guessed type struct sigaction stru_66A31C;
// 66C3DC: using guessed type struct sigaction stru_66C3DC;
// 6799D8: using guessed type int dword_6799D8[];
// 6799DC: using guessed type int dword_6799DC;
// 6799E0: using guessed type int dword_6799E0;
// AB59C8: using guessed type _QWORD qword_AB59C8[1024];
// AB79C8: using guessed type int dword_AB79C8[];
// AB7A58: using guessed type __int64 qword_AB7A58;

//----- (000164AC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_9,
    a1,
    va);
  abort();
}
// 164B6: positive sp value 4 has been found
// 164C8: variable 'v4' is possibly undefined
// 96FB8: using guessed type int init();
// 96FF4: using guessed type int nullsub_9();

//----- (000164DC) --------------------------------------------------------
int sub_164DC()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 125E0: using guessed type int _gmon_start__(void);

//----- (00016500) --------------------------------------------------------
int *sub_16500()
{
  return &stderr;
}
// BDA08: using guessed type int stderr;

//----- (00016524) --------------------------------------------------------
__int64 sub_16524()
{
  __int64 result; // r0

  LODWORD(result) = &stderr;
  HIDWORD(result) = 0;
  return result;
}
// BDA08: using guessed type int stderr;

//----- (00016550) --------------------------------------------------------
int *sub_16550()
{
  int *result; // r0

  if ( !byte_BDA18 )
  {
    result = sub_16500();
    byte_BDA18 = 1;
  }
  return result;
}
// BDA18: using guessed type char byte_BDA18;

//----- (0001656C) --------------------------------------------------------
void sub_1656C()
{
  flt_BDA3C = flt_BDA24 - flt_BDA28;
  flt_BDA44 = flt_BDA40;
  flt_BDA40 = flt_BDA24 - flt_BDA28;
}
// BDA24: using guessed type float flt_BDA24;
// BDA28: using guessed type float flt_BDA28;
// BDA3C: using guessed type float flt_BDA3C;
// BDA40: using guessed type float flt_BDA40;
// BDA44: using guessed type float flt_BDA44;

//----- (000165E8) --------------------------------------------------------
int __fastcall sub_165E8(unsigned int a1, int a2)
{
  int v3; // r10
  unsigned int i; // r4
  int v5; // r0
  int v6; // r6
  unsigned int v7; // r7
  int v8; // r4
  int v9; // r4
  int v11; // r4
  int v12; // r0
  int v13; // r4
  int v14; // r5
  int v15; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v3 = 10;
  do
  {
    for ( i = 0; i < sub_27F28(); ++i )
    {
      v5 = sub_5A0DC((unsigned __int8)i);
      v6 = v5;
      if ( v5 >= 0 )
      {
        v7 = v5;
        if ( (unsigned int)off_BC5EC > 4 )
        {
          snprintf(s, 0x2000u, "fan[%u] speed[%u]\n", (unsigned __int8)i, v5);
          sub_41DB8(4, s, 0);
        }
        sub_28000((unsigned __int8)i, v6);
        if ( sub_29C30() && sub_29C60() )
        {
          if ( a2 )
            v7 = sub_29DB0((unsigned __int8)i);
          else
            v7 = sub_29DC4((unsigned __int8)i);
        }
        sub_27F7C((unsigned __int8)i, a1 <= v7);
      }
    }
    v8 = sub_27F38();
    if ( v8 >= sub_27F28() )
      break;
    sub_44890();
    --v3;
  }
  while ( v3 );
  v9 = sub_27F38();
  if ( v9 < sub_27F28() )
  {
    if ( (unsigned int)off_BC5EC > 1 )
    {
      v11 = sub_27F38();
      v12 = sub_27F28();
      snprintf(s, 0x2000u, "Error, fan lost, only find %d (< %d)\n", v11, v12);
      sub_41DB8(1, s, 0);
    }
    v13 = 0;
    while ( 1 )
    {
      v14 = (unsigned __int8)v13++;
      if ( v14 >= sub_27F28() )
        break;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        v15 = sub_28068(v14);
        snprintf(s, 0x2000u, "fan_id = %d, fan_speed = %d\n", v14, v15);
        sub_41DB8(3, s, 0);
      }
    }
    sub_4FB28(10, 255);
    sub_2CC60(1);
    sub_473B4(7u, "fan lost");
    return -1;
  }
  else
  {
    sub_2CC60(0);
    return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001680C) --------------------------------------------------------
int sub_1680C()
{
  int result; // r0
  char v1[8192]; // [sp+0h] [bp-2000h] BYREF

  dword_BDA30 = -1082130432;
  dword_BDA34 = -1086324736;
  dword_BDA38 = 0;
  dword_BDA2C = -1056964608;
  result = sub_286A4();
  dword_BDA20 = 1109393408;
  dword_BDA1C = 1120403456;
  flt_BDA24 = (float)result;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v1, 0x2000u, "init fan pid target=%d", (int)(float)result);
    return sub_41DB8(3, v1, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA1C: using guessed type int dword_BDA1C;
// BDA20: using guessed type int dword_BDA20;
// BDA24: using guessed type float flt_BDA24;
// BDA2C: using guessed type int dword_BDA2C;
// BDA30: using guessed type int dword_BDA30;
// BDA34: using guessed type int dword_BDA34;
// BDA38: using guessed type int dword_BDA38;

//----- (000168B4) --------------------------------------------------------
int __fastcall sub_168B4(int a1)
{
  int result; // r0
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  result = dword_BDA48;
  if ( !dword_BDA48 )
  {
    result = sub_5BB2C(0, 100000);
    dword_BDA48 = result;
  }
  if ( result < 0 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      strcpy(v3, "pwm for fan init error");
      return sub_41DB8(3, v3, 0);
    }
  }
  else if ( a1 != dword_BDA4C )
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(v3, 0x2000u, "set pwm = %d", a1);
      sub_41DB8(4, v3, 0);
      result = dword_BDA48;
    }
    sub_5BCE8(result, a1);
    result = sub_280C8(a1);
    dword_BDA4C = a1;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC5F4: using guessed type int dword_BC5F4;
// BDA48: using guessed type int dword_BDA48;
// BDA4C: using guessed type int dword_BDA4C;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (000169E4) --------------------------------------------------------
int sub_169E4()
{
  float v0; // s0
  int v1; // r0
  int v2; // r5
  int v3; // r0
  int v4; // r5
  int result; // r0
  float v6; // s15
  int v7; // r6
  int v8; // r0
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  if ( (byte_AB79EC & 2) != 0 )
  {
    v1 = (unsigned __int8)byte_AB79F2;
    if ( (unsigned __int8)byte_AB79F2 <= 0x64u )
      return sub_168B4(v1);
  }
  if ( dword_BDA84 == 3 )
  {
    if ( sub_19530() <= 65 )
    {
LABEL_5:
      v2 = sub_280DC();
      v3 = dword_BDA84;
      if ( dword_BDA84 )
      {
        if ( dword_BDA84 == 3 )
        {
          flt_BDA28 = (float)sub_19530();
LABEL_9:
          sub_1656C();
          v4 = (int)v0 + v2;
          result = sub_280DC();
          if ( v4 == result )
            return result;
          v6 = (float)v4;
          if ( (float)v4 > *(float *)&dword_BDA20 )
          {
            if ( *(float *)&dword_BDA1C >= v6 )
            {
              v1 = (unsigned __int8)(unsigned int)v6;
              return sub_168B4(v1);
            }
          }
          else if ( *(float *)&dword_BDA1C >= *(float *)&dword_BDA20 )
          {
            v1 = (unsigned __int8)(unsigned int)*(float *)&dword_BDA20;
            return sub_168B4(v1);
          }
          v1 = (unsigned __int8)(unsigned int)*(float *)&dword_BDA1C;
          return sub_168B4(v1);
        }
        v3 = 0;
      }
      flt_BDA28 = (float)sub_191C8(v3);
      goto LABEL_9;
    }
  }
  else if ( sub_191C8(0) <= 65 )
  {
    goto LABEL_5;
  }
  if ( dword_BDA84 == 3 )
  {
    v7 = sub_194F8();
    v8 = sub_19530();
  }
  else
  {
    v7 = sub_19404();
    v8 = sub_191C8(0);
  }
  flt_BDA28 = (float)v8;
  sub_1656C();
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "feedback: %f, input: %d\n", flt_BDA28, 100);
    sub_41DB8(4, s, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "new input: %d\n", 100);
      sub_41DB8(4, s, 0);
    }
  }
  result = sub_168B4(100);
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, " Air out temprature is too high, set fixed full fan speed\n");
    result = sub_41DB8(4, s, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "PWM keep 100:  airin_temp=%d, airout_temp=%f\n", v7, flt_BDA28);
      return sub_41DB8(4, s, 0);
    }
  }
  return result;
}
// 16A70: variable 'v0' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA1C: using guessed type int dword_BDA1C;
// BDA20: using guessed type int dword_BDA20;
// BDA28: using guessed type float flt_BDA28;
// BDA84: using guessed type int dword_BDA84;
// AB79EC: using guessed type char byte_AB79EC;
// AB79F2: using guessed type char byte_AB79F2;

//----- (00016C98) --------------------------------------------------------
int sub_16C98()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "Note: front fan is power on!\n");
    sub_41DB8(4, v1, 0);
  }
  return sub_5A200(0);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00016CFC) --------------------------------------------------------
int sub_16CFC()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "Note: front fan is power off!\n");
    sub_41DB8(4, v1, 0);
  }
  return sub_5A298(0);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00016D68) --------------------------------------------------------
int sub_16D68()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "Note: rear fan is power on!\n");
    sub_41DB8(4, v1, 0);
  }
  return sub_5A200(1);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00016DCC) --------------------------------------------------------
int sub_16DCC()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "Note: rear fan is power off!\n");
    sub_41DB8(4, v1, 0);
  }
  return sub_5A298(1);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00016E30) --------------------------------------------------------
int sub_16E30()
{
  int i; // r4
  unsigned int v1; // r6
  int v2; // r12
  int v4; // r4
  char v5[8192]; // [sp+10h] [bp-2000h] BYREF

  prctl(15, "temp_vol_mtr", 0, 0, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v5, "asic_temperature_and_voltage_monitor_thread start...");
    sub_41DB8(3, v5, 0);
  }
  while ( !dword_BDA50 )
    usleep((__useconds_t)&unk_F4240);
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      sub_7F69C((unsigned __int8)i, 1, 0, 1, 0, 0, 0);
      usleep(0x2710u);
      sub_7F764((unsigned __int8)i, 1, 0, 1);
      usleep(0x2710u);
      sub_7F69C((unsigned __int8)i, 1, 0, 1, 1, 0, 0);
      usleep(0x2710u);
      sub_7F69C((unsigned __int8)i, 1, 0, 1, 0, 1, 0);
      usleep(0x2710u);
    }
  }
  v1 = 1;
LABEL_10:
  v2 = dword_BDA58;
  if ( !dword_BDA58 )
    goto LABEL_13;
  do
  {
    if ( dword_BDA50 )
    {
      v4 = 0;
      memset(&unk_C4350, 0, 0x400u);
      do
      {
        if ( sub_27EC8(v4) )
          sub_2A220((unsigned __int8)v4, 1, 0, 180);
        ++v4;
      }
      while ( v4 != 4 );
      usleep((__useconds_t)sub_30D40);
      if ( !v1 )
      {
        if ( sub_27EC8(0) )
          goto LABEL_25;
        while ( ++v1 != 4 )
        {
          if ( sub_27EC8(v1) )
LABEL_25:
            sub_3FC44(v1);
        }
      }
      v1 = 0;
      ++dword_BDA54;
      goto LABEL_10;
    }
    usleep((__useconds_t)&unk_F4240);
    v2 = dword_BDA58;
  }
  while ( dword_BDA58 );
LABEL_13:
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v5, "asic_temperature_and_voltage_monitor_thread exit");
    sub_41DB8(3, v5, v2);
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA50: using guessed type int dword_BDA50;
// BDA54: using guessed type int dword_BDA54;
// BDA58: using guessed type int dword_BDA58;

//----- (000170EC) --------------------------------------------------------
int __fastcall sub_170EC(int a1, int a2)
{
  int v4; // r4
  int v5; // r5

  v4 = 8;
  do
  {
    v5 = sub_3E42C(28, a1, a2);
    if ( v5 )
      break;
    usleep(0x3E8u);
    --v4;
  }
  while ( v4 );
  return v5;
}

//----- (0001712C) --------------------------------------------------------
int __fastcall sub_1712C(int a1, int a2, int a3, int a4, _BYTE *a5)
{
  int v5; // r6
  int j; // r8
  __int16 v10; // r10
  bool v11; // zf
  int v13; // r11
  int i; // r10
  __int16 v15; // r8

  v5 = a4;
  if ( a4 )
  {
    v13 = 2;
    for ( i = 0; ; i = 1 )
    {
      sub_170EC(a2, a1);
      sub_2A338();
      sub_170EC(a2, a1);
      usleep(0x3E8u);
      sub_170EC(a2, a1);
      sub_2A338();
      v15 = sub_170EC(a2, a1);
      usleep(0x3E8u);
      if ( HIBYTE(v15) == a3 || (unsigned __int8)v15 == (unsigned __int8)*a5 )
        break;
      v11 = v13 == 1;
      v13 = 1;
      if ( v11 )
        return 0;
    }
    if ( !i )
      return v5;
    return 0;
  }
  for ( j = 2; ; j = 1 )
  {
    sub_170EC(a2, a1);
    sub_2A338();
    usleep(0x3E8u);
    v10 = sub_170EC(a2, a1);
    usleep(0x3E8u);
    if ( HIBYTE(v10) == a3 )
      break;
    v11 = j == 1;
    v5 = 1;
    if ( v11 )
      return 0;
  }
  if ( v5 || !(_BYTE)v10 )
    return 0;
  *a5 = v10;
  return 1;
}

//----- (000172A4) --------------------------------------------------------
int __fastcall sub_172A4(int a1, int a2, unsigned int a3, int a4, char a5)
{
  const char *v10; // r0
  const char *v11; // r0
  int v12; // r8
  int v13; // r5
  char v14; // t1
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  char s[8176]; // [sp+10h] [bp-2000h] BYREF

  if ( sub_27EC8(a1) )
  {
    if ( !sub_27EC8(a1) )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "Chain %d is not exist.\n", a1);
        sub_41DB8(3, s, 0);
      }
      return 255;
    }
    v10 = (const char *)sub_27CEC();
    if ( strcmp(v10, "HHB68601") )
    {
      v11 = (const char *)sub_27CEC();
      if ( strcmp(v11, "HHB68602") )
      {
        v15 = (const char *)sub_27CEC();
        if ( strcmp(v15, "HHB68502") )
        {
          v16 = (const char *)sub_27CEC();
          if ( strcmp(v16, "HHB68501") )
          {
            v17 = (const char *)sub_27CEC();
            if ( strcmp(v17, "HHB68701") )
            {
              v18 = (const char *)sub_27CEC();
              if ( strcmp(v18, "HHB68704") )
              {
                v19 = (const char *)sub_27CEC();
                if ( strcmp(v19, "HHB68703") )
                {
                  v20 = (const char *)sub_27CEC();
                  if ( strcmp(v20, "H6HB68702") )
                  {
                    v21 = (const char *)sub_27CEC();
                    if ( strcmp(v21, "H1HB68601") )
                    {
                      v22 = (const char *)sub_27CEC();
                      if ( strcmp(v22, "HHB68503") )
                        return 255;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_7F69C((unsigned __int8)a1, 1, a3, 1, 0, 0, 0);
    usleep(0x2710u);
    sub_7F69C((unsigned __int8)a1, 1, a3, 1, 1, 0, 0);
    usleep(0x2710u);
    sub_7F69C((unsigned __int8)a1, 1, a3, 1, 0, 1, 0);
    usleep(0x2710u);
    if ( a2 )
    {
      sub_2A220((unsigned __int8)a1, a2, a3, 180);
      usleep(0x2710u);
    }
    else if ( a5 )
    {
      v12 = a4 - 1;
      v13 = a4 + (unsigned __int8)(a5 - 1);
      do
      {
        v14 = *(_BYTE *)++v12;
        sub_2A220((unsigned __int8)a1, 0, v14, 180);
      }
      while ( v12 != v13 );
    }
    sub_7F69C((unsigned __int8)a1, 1, a3, 0, 0, 0, 1);
    usleep(0x2710u);
    return 255;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 4 )
      return 255;
    snprintf(s, 0x2000u, "%s chain %d not pluged", "read_sensor_on_asic_synopsys", a1);
    sub_41DB8(4, s, 0);
    return 255;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001759C) --------------------------------------------------------
int __fastcall sub_1759C(int a1, int a2, unsigned int a3, int a4, char a5)
{
  return sub_172A4(a1, a2, a3, a4, a5);
}

//----- (000175A8) --------------------------------------------------------
int sub_175A8()
{
  if ( sub_27D9C() )
    return sub_27D9C();
  else
    return sub_27DC8();
}

//----- (000175C8) --------------------------------------------------------
int __fastcall sub_175C8(int a1, int a2, unsigned int a3, int a4)
{
  char *v10; // r3
  int v11; // r5
  int v12; // r8
  unsigned __int8 v13; // [sp+17h] [bp-2005h] BYREF
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  if ( dword_BDA5C )
  {
    if ( !sub_27EC8(a1) )
    {
      if ( (unsigned int)off_BC5EC <= 4 )
        return 255;
      snprintf(s, 0x2000u, "%s chain %d not pluged", "read_sensor_on_asic", a1);
      sub_41DB8(4, s, 0);
      return 255;
    }
    if ( !sub_27D9C() )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return 255;
      snprintf(s, 0x2000u, "%s chain %d ,index %d not connected", "read_sensor_on_asic", a1, a2);
      sub_41DB8(3, s, 0);
      return 255;
    }
    if ( a2 >= sub_175A8() || a3 > 1 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return 255;
      snprintf(
        s,
        0x2000u,
        "%s invalid param. index = %d, type = %d, model = %d on chain %d",
        "read_sensor_on_asic",
        a2,
        a4,
        a3,
        a1);
    }
    else
    {
      v13 = -1;
      v10 = &aReadSensorOnAs[16 * a3];
      if ( a4 )
        v11 = (unsigned __int8)v10[62];
      else
        v11 = (unsigned __int8)v10[61];
      v12 = sub_1712C(a1, (unsigned __int8)(*(_DWORD *)(dword_BDA60 + 4 * a2) * dword_BDA5C), v11, 0, &v13);
      if ( sub_29C30() && sub_29C90() )
      {
        if ( sub_47394() == 2 )
          v13 = sub_29E54((unsigned __int8)a1, (unsigned __int8)a2) + 64;
        else
          v13 = sub_29E30((unsigned __int8)a1, (unsigned __int8)a2) + 64;
        if ( !sub_29E0C((unsigned __int8)a1, (unsigned __int8)a2) )
          return v13 - 64;
      }
      else if ( v12 )
      {
        return v13 - 64;
      }
      if ( (unsigned int)off_BC5EC <= 3 )
        return 255;
      snprintf(
        s,
        0x2000u,
        "read temp sensor failed: chain = %d, sensor pos = %d, address = %d, reg = %d\n",
        a1,
        *(_DWORD *)(dword_BDA60 + 4 * a2),
        dword_BDA5C * *(_DWORD *)(dword_BDA60 + 4 * a2),
        v11);
    }
    sub_41DB8(3, s, 0);
    return 255;
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    return 255;
  strcpy(s, "can not read temp by asic before calibration");
  sub_41DB8(3, s, dword_BDA5C);
  return 255;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA5C: using guessed type int dword_BDA5C;
// BDA60: using guessed type int dword_BDA60;

//----- (0001788C) --------------------------------------------------------
int __fastcall sub_1788C(int a1)
{
  int v2; // r11
  int v3; // r4
  unsigned int v4; // r5
  int v5; // r6
  unsigned int v7; // r5
  void *v8; // r3
  int v9; // r4
  char v10; // r4
  char v11; // r0
  int v12; // [sp+Ch] [bp-2030h]
  int v13; // [sp+14h] [bp-2028h]
  int v14; // [sp+18h] [bp-2024h]
  const char *v15; // [sp+2Ch] [bp-2010h]
  char v16; // [sp+36h] [bp-2006h] BYREF
  char v17; // [sp+37h] [bp-2005h] BYREF
  char s[8196]; // [sp+38h] [bp-2004h] BYREF

  v2 = 0;
  v13 = 4 * a1;
  v15 = 0;
LABEL_2:
  if ( sub_175A8() <= v2 )
  {
    v8 = off_BC5EC;
    goto LABEL_29;
  }
  v3 = 4;
  v4 = (unsigned __int8)(*(_DWORD *)(dword_BDA60 + 4 * v2) * dword_BDA5C);
  sub_7FD34((unsigned __int8)a1, v4, 0);
  usleep(0x2710u);
  while ( 1 )
  {
    s[0] = 0;
    sub_1712C(a1, v4, 254, 0, s);
    if ( s[0] == 26 )
      break;
    if ( !--v3 )
    {
      v5 = 4;
      do
      {
        s[0] = 0;
        sub_1712C(a1, v4, 254, 0, s);
        if ( s[0] == 85 )
        {
          v7 = 1;
          v15 = "TMP451";
          goto LABEL_13;
        }
        --v5;
      }
      while ( v5 );
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "sensor %d @ chain %d manufacture id unknown", *(_DWORD *)(dword_BDA60 + 4 * v2), a1);
        sub_41DB8(3, s, 0);
      }
      return -1;
    }
  }
  v7 = 0;
  v15 = "NCT218";
LABEL_13:
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "sensor %d @ chain %d is %s", *(_DWORD *)(dword_BDA60 + 4 * v2), a1, v15);
    sub_41DB8(3, s, 0);
  }
  v16 = 4;
  if ( dword_BDA5C )
  {
    if ( !sub_27D9C() )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return 0;
      snprintf(s, 0x2000u, "%s chain %d ,index %d not connected", "set_ext_mode", a1, v2);
      sub_41DB8(3, s, 0);
      goto LABEL_22;
    }
    if ( !sub_1712C(
            a1,
            (unsigned __int8)(*(_DWORD *)(dword_BDA60 + 4 * v2) * dword_BDA5C),
            (unsigned __int8)aReadSensorOnAs[16 * v7 + 63],
            1,
            &v16) )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return 0;
      snprintf(s, 0x2000u, "set ext mode failed for senser %d @ chain %d", *(_DWORD *)(dword_BDA60 + 4 * v2), a1);
      sub_41DB8(3, s, 0);
      goto LABEL_22;
    }
    v14 = 6 * v2;
    LOBYTE(v12) = 11;
    while ( 1 )
    {
      v10 = sub_175C8(a1, v2, v7, 0);
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + v13) + 4) + v14 + 2) = v10;
      v11 = sub_175C8(a1, v2, v7, 1);
      v9 = (char)(v10 - v11);
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + v13) + 8) + v14 + 2) = v11;
      if ( (unsigned __int8)(v9 + 2) <= 4u )
      {
        if ( (unsigned int)off_BC5EC > 4 )
        {
          snprintf(
            s,
            0x2000u,
            "sensor %d @ chain %d chip_temp_offset less than 2, no need to set offset",
            *(_DWORD *)(dword_BDA60 + 4 * v2),
            a1);
          sub_41DB8(4, s, 0);
        }
LABEL_46:
        ++v2;
        goto LABEL_2;
      }
      v17 = v9;
      if ( dword_BDA5C )
      {
        if ( sub_27D9C() )
        {
          if ( sub_1712C(
                 a1,
                 (unsigned __int8)(*(_DWORD *)(dword_BDA60 + 4 * v2) * dword_BDA5C),
                 (unsigned __int8)aReadSensorOnAs[16 * v7 + 64],
                 1,
                 &v17) )
          {
            if ( (unsigned int)off_BC5EC > 3 )
            {
              snprintf(s, 0x2000u, "sensor %d @ chain %d, offset = %d", *(_DWORD *)(dword_BDA60 + 4 * v2), a1, (char)v9);
LABEL_43:
              sub_41DB8(3, s, 0);
              if ( (v9 & 0x80u) != 0 )
                v9 = -(char)v9;
              if ( v9 <= 2 )
                goto LABEL_46;
              goto LABEL_37;
            }
          }
          else if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "set offset failed for senser %d @ chain %d", *(_DWORD *)(dword_BDA60 + 4 * v2), a1);
            sub_41DB8(3, s, 0);
          }
        }
        else if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "%s chain %d ,index %d not connected", "set_sensor_offset", a1, v2);
          goto LABEL_43;
        }
      }
      else if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "can not set ext mode before calibration");
        sub_41DB8(3, s, 0);
      }
      if ( (v9 & 0x80u) != 0 )
        v9 = -(char)v9;
      if ( v9 <= 2 )
        goto LABEL_46;
LABEL_37:
      v12 = (unsigned __int8)(v12 - 1);
      if ( !v12 )
        goto LABEL_46;
    }
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    return 0;
  strcpy(s, "can not set ext mode before calibration");
  sub_41DB8(3, s, 0);
LABEL_22:
  if ( (unsigned int)off_BC5EC <= 3 )
    return 0;
  snprintf(s, 0x2000u, "sensor %d @ chain %d fail to set to ext mode", *(_DWORD *)(dword_BDA60 + 4 * v2), a1);
  sub_41DB8(3, s, 0);
  v8 = off_BC5EC;
LABEL_29:
  if ( (unsigned int)v8 > 3 )
  {
    snprintf(s, 0x2000u, "chain %d temp sensor %s\n", a1, v15);
    sub_41DB8(3, s, 0);
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA5C: using guessed type int dword_BDA5C;
// BDA60: using guessed type int dword_BDA60;
// BDA64: using guessed type int dword_BDA64;

//----- (00017E94) --------------------------------------------------------
int __fastcall sub_17E94(int a1, int a2, int a3)
{
  int v6; // r4
  int v8; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( a2 )
  {
    if ( a2 == 3 )
    {
      if ( sub_28618() <= a3 )
        goto LABEL_7;
    }
    else if ( !sub_27D9C() || sub_175A8() <= a3 || !dword_BDA68 )
    {
      goto LABEL_7;
    }
  }
  else if ( sub_27DC8() <= a3 )
  {
    goto LABEL_7;
  }
  if ( dword_BDA64 )
  {
    pthread_mutex_lock(&stru_BDA6C);
    v6 = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * a1) + 4 * a2) + 6 * a3 + 2);
    pthread_mutex_unlock(&stru_BDA6C);
    return v6;
  }
LABEL_7:
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v8 = sub_27DC8();
    snprintf(
      s,
      0x2000u,
      "get_sensor_temp_by_index invalid return 255!!, location:%d, index:%d, %d, %d",
      a2,
      a3,
      v8,
      dword_BDA64);
    sub_41DB8(4, s, 0);
  }
  return 255;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA64: using guessed type int dword_BDA64;
// BDA68: using guessed type int dword_BDA68;

//----- (00017FD4) --------------------------------------------------------
int __fastcall sub_17FD4(int a1, int a2, int a3)
{
  int v6; // r4
  int v8; // r0

  pthread_mutex_lock(&stru_BDA6C);
  if ( dword_BDA84 != 3 )
  {
    if ( dword_BDA84 )
      goto LABEL_3;
    if ( a2 )
      goto LABEL_6;
LABEL_11:
    v8 = sub_27DC8();
    goto LABEL_7;
  }
  if ( a2 == 3 )
    goto LABEL_11;
LABEL_6:
  v8 = sub_175A8();
LABEL_7:
  if ( a1 <= 3 && a3 < v8 )
  {
    v6 = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * a1) + 4 * a2) + 6 * a3 + 4);
    goto LABEL_4;
  }
LABEL_3:
  v6 = 0;
LABEL_4:
  pthread_mutex_unlock(&stru_BDA6C);
  return v6;
}
// BDA64: using guessed type int dword_BDA64;
// BDA84: using guessed type int dword_BDA84;

//----- (00018068) --------------------------------------------------------
int __fastcall sub_18068(int a1, int a2, int a3)
{
  int v6; // r0
  int v7; // r4

  if ( sub_27EC8(a1) )
    v6 = (unsigned int)a3 >> 31;
  else
    v6 = 1;
  if ( !v6 )
  {
    if ( a2 == 1 )
    {
      if ( sub_175A8() > a3 )
      {
LABEL_9:
        pthread_mutex_lock(&stru_BDA6C);
        v7 = *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * a1) + 4 * a2) + 6 * a3 + 2);
        pthread_mutex_unlock(&stru_BDA6C);
        return v7;
      }
    }
    else if ( a2 == 2 )
    {
      if ( sub_175A8() > a3 && sub_27D9C() )
        goto LABEL_9;
    }
    else if ( a2 || sub_27DC8() > a3 )
    {
      goto LABEL_9;
    }
  }
  return 255;
}
// BDA64: using guessed type int dword_BDA64;

//----- (00018120) --------------------------------------------------------
const char *__fastcall sub_18120(int a1, int a2)
{
  if ( a2 )
    return *(const char **)&aReadSensorOnAs[16 * **(__int16 **)(*(_DWORD *)(dword_BDA64 + 4 * a1) + 4 * a2) + 52];
  else
    return "LM75A";
}
// BDA64: using guessed type int dword_BDA64;

//----- (00018160) --------------------------------------------------------
int __fastcall sub_18160(char a1)
{
  pthread_mutex_lock((pthread_mutex_t *)algn_BDA88);
  byte_BDAA0 = a1;
  return pthread_mutex_unlock((pthread_mutex_t *)algn_BDA88);
}
// BDA88: using guessed type _BYTE[24];
// BDAA0: using guessed type char byte_BDAA0;

//----- (0001818C) --------------------------------------------------------
int sub_1818C()
{
  return (unsigned __int8)byte_BDAA0;
}
// BDAA0: using guessed type char byte_BDAA0;

//----- (0001819C) --------------------------------------------------------
int __fastcall sub_1819C(int a1)
{
  int v2; // r4
  int v3; // r3

  v2 = 0;
  while ( sub_175A8() > v2 )
  {
    v3 = *(_DWORD *)(dword_BDA60 + 4 * v2++);
    if ( v3 == a1 && sub_27D9C() )
      return 1;
  }
  return 0;
}
// BDA60: using guessed type int dword_BDA60;

//----- (000181EC) --------------------------------------------------------
void sub_181EC()
{
  byte_BDAA1 = 1;
}
// BDAA1: using guessed type char byte_BDAA1;

//----- (00018200) --------------------------------------------------------
void sub_18200()
{
  dword_BB2F0 = 1;
}
// BB2F0: using guessed type int dword_BB2F0;

//----- (00018214) --------------------------------------------------------
void sub_18214()
{
  dword_BB2F0 = 0;
}
// BB2F0: using guessed type int dword_BB2F0;

//----- (00018228) --------------------------------------------------------
void sub_18228()
{
  dword_BDA50 = 1;
}
// BDA50: using guessed type int dword_BDA50;

//----- (0001823C) --------------------------------------------------------
void sub_1823C()
{
  byte_BDAA2 = 1;
}
// BDAA2: using guessed type char byte_BDAA2;

//----- (00018250) --------------------------------------------------------
int sub_18250()
{
  return (unsigned __int8)byte_BDAA2;
}
// BDAA2: using guessed type char byte_BDAA2;

//----- (00018260) --------------------------------------------------------
void sub_18260()
{
  dword_BDA50 = 0;
}
// BDA50: using guessed type int dword_BDA50;

//----- (00018274) --------------------------------------------------------
void sub_18274()
{
  ++dword_BDAA4;
}
// BDAA4: using guessed type int dword_BDAA4;

//----- (0001828C) --------------------------------------------------------
int sub_1828C()
{
  int i; // r5
  int j; // r4

  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      for ( j = 0; sub_175A8() > j; ++j )
      {
        if ( sub_27D9C() )
        {
          sub_811A0();
          usleep(0x2710u);
        }
      }
    }
  }
  return 0;
}
// BDA5C: using guessed type int dword_BDA5C;
// BDA60: using guessed type int dword_BDA60;

//----- (00018310) --------------------------------------------------------
int sub_18310()
{
  const char *v0; // r0
  int result; // r0
  const char *v2; // r0
  int v3; // r4
  int v4; // r3
  bool v5; // cc

  v0 = (const char *)sub_27CEC();
  if ( !strcmp(v0, "HHB56601") )
    return 0;
  v2 = (const char *)sub_27CEC();
  if ( !strcmp(v2, "HHB56611") )
    return 0;
  LOWORD(v3) = (unsigned __int16)&dword_BDA50;
  if ( sub_27DC8() <= 0 )
  {
    HIWORD(v3) = 11;
  }
  else
  {
    HIWORD(v3) = (unsigned int)&dword_BDA50 >> 16;
    *(_DWORD *)(v3 + 0x34) = 0;
  }
  if ( sub_175A8() > 0 )
    *(_DWORD *)(v3 + 52) = 1;
  result = sub_28618();
  v5 = result <= 0;
  if ( result <= 0 )
    result = *(_DWORD *)(v3 + 52);
  else
    v4 = 3;
  if ( !v5 )
  {
    *(_DWORD *)(v3 + 52) = v4;
    return v4;
  }
  return result;
}
// 18388: variable 'v4' is possibly undefined
// BDA50: using guessed type int dword_BDA50;

//----- (00018394) --------------------------------------------------------
int sub_18394()
{
  int v0; // r4
  size_t v1; // r0
  int v2; // r4
  size_t v3; // r0
  int v4; // r6
  unsigned int v5; // r6
  int i; // r8
  int v8; // r11
  int v9; // r5
  int v10; // r4
  int v11; // r2
  int v12; // r5
  int v13; // r4
  void *v14; // r2
  char *v15; // [sp+14h] [bp-2038h]
  char *v16; // [sp+1Ch] [bp-2030h]
  int v17; // [sp+20h] [bp-202Ch]
  _DWORD v18[5]; // [sp+34h] [bp-2018h]
  char s[8196]; // [sp+48h] [bp-2004h] BYREF

  v18[0] = "pic";
  v18[1] = "pcb";
  v18[2] = "chp";
  v18[3] = "ctrlboard";
  v18[4] = "max";
  v0 = sub_175A8();
  if ( v0 <= sub_27DC8() )
    v1 = 4 * sub_27DC8() + 5;
  else
    v1 = 4 * sub_175A8() + 5;
  v16 = (char *)malloc(v1);
  v2 = sub_175A8();
  if ( v2 <= sub_27DC8() )
    v3 = 4 * sub_27DC8() + 5;
  else
    v3 = 4 * sub_175A8() + 5;
  v15 = (char *)malloc(v3);
  pthread_mutex_lock(&stru_BDA6C);
  v4 = sub_18310();
  switch ( v4 )
  {
    case 0:
      v17 = sub_27DC8();
      break;
    case 1:
    case 2:
      v17 = sub_175A8();
      break;
    case 3:
      v17 = sub_28618();
      break;
    default:
      v17 = 0;
      break;
  }
  v5 = 4 * v4;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      if ( v17 <= 0 )
      {
        v13 = -1;
        v12 = -1;
      }
      else
      {
        v8 = 0;
        v9 = 0;
        v10 = 0;
        do
        {
          v10 += sprintf(&v16[v10], "%03d-", *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * i) + v5) + v8 + 2));
          v11 = *(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * i) + v5) + v8;
          v8 += 6;
          v9 += sprintf(&v15[v9], "%03d-", *(__int16 *)(v11 + 4));
        }
        while ( 6 * v17 != v8 );
        v12 = v9 - 1;
        v13 = v10 - 1;
      }
      v14 = off_BC5EC;
      v15[v12] = 32;
      v16[v13] = 32;
      if ( (unsigned int)v14 > 3 )
      {
        snprintf(s, 0x2000u, "chain %d %s temp: %s, failure:%s", i, v18[v5 / 4], v16, v15);
        sub_41DB8(3, s, 0);
      }
    }
  }
  return pthread_mutex_unlock(&stru_BDA6C);
}
// 18420: control flows out of bounds to 18424
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA64: using guessed type int dword_BDA64;

//----- (00018600) --------------------------------------------------------
int sub_18600()
{
  const char *v0; // r0
  int v1; // r4
  int v2; // r8
  int v3; // r8
  int v4; // r5
  int v5; // r10
  char *v6; // r9
  char *v7; // r7
  char *v8; // r0
  int v9; // lr
  char *v10; // r12
  char *v11; // r8
  char *v12; // r9
  char *v13; // r1
  char *v14; // r2
  int v15; // r3
  int v16; // r5
  int v17; // r0
  int v18; // r7
  size_t v19; // r0
  int v20; // r5
  size_t v22; // r0
  int v23; // r5
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  pthread_attr_t v34[227]; // [sp+0h] [bp-2000h] BYREF

  v0 = (const char *)sub_27CEC();
  if ( strcmp(v0, "HHB68502") )
  {
    v24 = (const char *)sub_27CEC();
    if ( strcmp(v24, "HHB68501") )
    {
      v25 = (const char *)sub_27CEC();
      if ( strcmp(v25, "HHB68701") )
      {
        v26 = (const char *)sub_27CEC();
        if ( strcmp(v26, "HHB68704") )
        {
          v27 = (const char *)sub_27CEC();
          if ( strcmp(v27, "HHB68703") )
          {
            v28 = (const char *)sub_27CEC();
            if ( strcmp(v28, "H6HB68702") )
            {
              v29 = (const char *)sub_27CEC();
              if ( strcmp(v29, "H1HB68601") )
              {
                v30 = (const char *)sub_27CEC();
                if ( strcmp(v30, "HHB68601") )
                {
                  v31 = (const char *)sub_27CEC();
                  if ( strcmp(v31, "HHB68602") )
                  {
                    v32 = (const char *)sub_27CEC();
                    if ( strcmp(v32, "HHB56611") )
                    {
                      v33 = (const char *)sub_27CEC();
                      if ( strcmp(v33, "HHB68503") )
                        sub_1680C();
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v1 = sub_175A8();
  if ( v1 <= sub_27DC8() )
    v2 = sub_27DC8();
  else
    v2 = sub_175A8();
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v34[0].__size, 0x2000u, "max sensor num = %d", v2);
    sub_41DB8(3, v34[0].__size, 0);
  }
  v3 = 3 * v2;
  v4 = 32 * v3;
  v5 = 8 * v3;
  v6 = (char *)malloc(0x10u);
  dword_BDA64 = (int)v6;
  v7 = (char *)malloc(0x40u);
  v8 = (char *)calloc(32 * v3, 1u);
  v9 = 2 * v3;
  v10 = v6 - 4;
  v11 = v8;
  v12 = v6 + 12;
  do
  {
    v13 = v7;
    v14 = v11;
    v15 = 0;
    *((_DWORD *)v10 + 1) = v7;
    for ( v10 += 4; ; v13 = *(char **)v10 )
    {
      *(_DWORD *)&v13[v15] = v14;
      v15 += 4;
      v14 += v9;
      if ( v15 == 16 )
        break;
    }
    v11 += v5;
    v7 += 16;
  }
  while ( v12 != v10 );
  dword_BDAA8 = (int)&v8[v4];
  v16 = 0;
  v17 = sub_175A8();
  dword_BDA60 = (int)malloc(4 * v17);
  while ( sub_175A8() > v16 )
  {
    v18 = dword_BDA60;
    *(_DWORD *)(v18 + 4 * v16) = sub_27DAC(v16);
    ++v16;
    dword_BDA84 = 1;
  }
  v19 = sub_27DC8();
  v20 = 0;
  dword_BDAAC = (int)malloc(v19);
  while ( sub_27DC8() > v20 )
  {
    *(_BYTE *)(dword_BDAAC + v20) = sub_27DD8(v20);
    ++v20;
    dword_BDA84 = 0;
  }
  if ( sub_28618() )
  {
    v22 = sub_28618();
    v23 = 0;
    dword_BDAB0 = (int)malloc(v22);
    while ( sub_28618() > v23 )
    {
      *(_BYTE *)(dword_BDAB0 + v23) = sub_28628(v23);
      ++v23;
    }
    dword_BDA84 = 3;
  }
  pthread_attr_init(v34);
  pthread_attr_setstacksize(v34, 0x100000u);
  byte_BDAA1 = 0;
  dword_BDAB4 = 1;
  pthread_create(&newthread, v34, (void *(*)(void *))sub_1957C, 0);
  pthread_detach(newthread);
  dword_BDA58 = 1;
  dword_BDA50 = 0;
  pthread_create(&dword_BDABC, 0, (void *(*)(void *))sub_16E30, 0);
  return pthread_detach(dword_BDABC);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA50: using guessed type int dword_BDA50;
// BDA58: using guessed type int dword_BDA58;
// BDA60: using guessed type int dword_BDA60;
// BDA64: using guessed type int dword_BDA64;
// BDA84: using guessed type int dword_BDA84;
// BDAA1: using guessed type char byte_BDAA1;
// BDAA8: using guessed type int dword_BDAA8;
// BDAAC: using guessed type int dword_BDAAC;
// BDAB0: using guessed type int dword_BDAB0;
// BDAB4: using guessed type int dword_BDAB4;

//----- (00018954) --------------------------------------------------------
int sub_18954()
{
  int result; // r0
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( dword_BDAB4 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v1, "uninit_temp_info");
      result = sub_41DB8(3, v1, 0);
      dword_BDAB4 = 0;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v1, "do not read temp anymore...");
        return sub_41DB8(3, v1, 0);
      }
    }
    else
    {
      dword_BDAB4 = 0;
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDAB4: using guessed type int dword_BDAB4;

//----- (00018A14) --------------------------------------------------------
int sub_18A14()
{
  int result; // r0
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( dword_BDA58 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v1, "uninit_asic_temp_vol_info");
      result = sub_41DB8(3, v1, 0);
      dword_BDA58 = 0;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v1, "do not read asic_temp_vol anymore...");
        return sub_41DB8(3, v1, 0);
      }
    }
    else
    {
      dword_BDA58 = 0;
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA58: using guessed type int dword_BDA58;

//----- (00018AE4) --------------------------------------------------------
int __fastcall sub_18AE4(int a1)
{
  int result; // r0
  int v3; // r4
  char v4[8192]; // [sp+0h] [bp-2000h] BYREF

  result = sub_27D9C();
  if ( result )
  {
    v3 = 0;
    pthread_mutex_lock(&stru_BDA6C);
    dword_BDA5C = a1;
    sub_1828C();
    while ( !sub_27EC8(v3) || !sub_1788C(v3) )
    {
      if ( ++v3 == 4 )
      {
        dword_BDA68 = 1;
        pthread_mutex_unlock(&stru_BDA6C);
        return 0;
      }
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v4, 0x2000u, "calibration sensor on chain %d failed", v3);
      sub_41DB8(3, v4, 0);
    }
    dword_BDA68 = 1;
    pthread_mutex_unlock(&stru_BDA6C);
    return -1;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA5C: using guessed type int dword_BDA5C;
// BDA68: using guessed type int dword_BDA68;

//----- (00018BC4) --------------------------------------------------------
int __fastcall sub_18BC4(int a1, int a2)
{
  const char *v4; // r0
  _BOOL4 v5; // r1

  v4 = (const char *)sub_27CEC();
  v5 = strcmp(v4, "BHB28601") == 0;
  return sub_17FD4(a1, v5, a2);
}

//----- (00018C08) --------------------------------------------------------
int __fastcall sub_18C08(int a1, int a2)
{
  return sub_17FD4(a1, 1, a2);
}

//----- (00018C14) --------------------------------------------------------
int __fastcall sub_18C14(int a1, int a2)
{
  return sub_17FD4(a1, 2, a2);
}

//----- (00018C20) --------------------------------------------------------
void sub_18C20()
{
  dword_BDAC0 = 1;
}
// BDAC0: using guessed type int dword_BDAC0;

//----- (00018C34) --------------------------------------------------------
void sub_18C34()
{
  dword_BDAC0 = 0;
}
// BDAC0: using guessed type int dword_BDAC0;

//----- (00018C48) --------------------------------------------------------
int __fastcall sub_18C48(int a1, int a2)
{
  char v2; // r3
  int v4; // r4
  char v5; // r5
  char v6; // r0
  bool v7; // cc
  int result; // r0
  char v9; // [sp+Fh] [bp-5h] BYREF

  if ( a2 )
    v2 = 68;
  else
    v2 = 4;
  v9 = v2;
  v4 = 0;
  while ( 1 )
  {
    v7 = sub_175A8() <= v4;
    result = v4++;
    if ( v7 )
      break;
    v5 = sub_27DAC(result);
    v6 = sub_27D8C();
    sub_1712C(a1, (unsigned __int8)(v5 * v6), 9, 1, &v9);
  }
  return result;
}

//----- (00018CB4) --------------------------------------------------------
int __fastcall sub_18CB4(int a1)
{
  int v1; // r4
  int result; // r0

  v1 = 0;
  result = sub_27EC8(0);
  if ( result )
    goto LABEL_4;
  while ( ++v1 != 4 )
  {
    result = sub_27EC8(v1);
    if ( result )
LABEL_4:
      result = sub_18C48(v1, a1);
  }
  return result;
}

//----- (00018CFC) --------------------------------------------------------
int __fastcall sub_18CFC(int a1, int a2)
{
  return sub_17FD4(a1, 3, a2);
}

//----- (00018D08) --------------------------------------------------------
int __fastcall sub_18D08(int a1, int a2)
{
  int v2; // r2

  switch ( a2 )
  {
    case 0:
    case 2:
      v2 = 0;
      break;
    case 1:
    case 3:
      v2 = 1;
      break;
    default:
      v2 = a2;
      break;
  }
  return sub_17E94(a1, 3, v2);
}
// 18D10: control flows out of bounds to 18D14

//----- (00018D48) --------------------------------------------------------
int __fastcall sub_18D48(int a1, int a2)
{
  const char *v4; // r0

  v4 = (const char *)sub_27CEC();
  if ( !strcmp(v4, "BHB28601") )
    return sub_17E94(a1, 1, a2);
  if ( dword_BDA84 == 3 )
    return sub_18D08(a1, a2);
  return sub_17E94(a1, 0, a2);
}
// BDA84: using guessed type int dword_BDA84;

//----- (00018DB8) --------------------------------------------------------
int __fastcall sub_18DB8(int a1)
{
  int v2; // r4
  int v3; // r5
  int v4; // r0
  int v5; // r1
  bool v6; // zf
  int v7; // r0

  v2 = 0;
  v3 = -127;
  while ( 1 )
  {
    v4 = sub_27DC8();
    v5 = (unsigned __int8)v2;
    if ( v4 <= v2 )
      break;
    v6 = v2 == 3;
    if ( v2 != 3 )
      v6 = v2 == 0;
    ++v2;
    if ( !v6 )
    {
      v7 = sub_18D48(a1, v5);
      if ( v3 < v7 )
        LOWORD(v3) = v7;
      v3 = (__int16)v3;
    }
  }
  return v3;
}

//----- (00018E08) --------------------------------------------------------
int __fastcall sub_18E08(int a1)
{
  int v2; // r4
  int v3; // r5
  int v4; // r0
  int v5; // r1
  bool v6; // zf
  int v7; // r0

  v2 = 0;
  v3 = 255;
  while ( 1 )
  {
    v4 = sub_27DC8();
    v5 = (unsigned __int8)v2;
    if ( v4 <= v2 )
      break;
    v6 = v2 == 3;
    if ( v2 != 3 )
      v6 = v2 == 0;
    ++v2;
    if ( !v6 )
    {
      v7 = sub_18D48(a1, v5);
      if ( v3 >= v7 )
        LOWORD(v3) = v7;
      v3 = (__int16)v3;
    }
  }
  return v3;
}

//----- (00018E58) --------------------------------------------------------
int sub_18E58()
{
  int v0; // r5
  int v1; // r6
  int i; // r4

  v0 = 0;
  v1 = 0;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      ++v0;
      v1 += sub_18E08(i);
    }
  }
  if ( v0 )
    return (__int16)sub_96518(v1, v0);
  else
    return 35;
}

//----- (00018EBC) --------------------------------------------------------
int sub_18EBC()
{
  int v0; // r5
  int v1; // r6
  int i; // r4
  int v4; // r0
  int v5; // r1
  bool v6; // zf
  int v7; // r0

  v0 = 0;
  v1 = -127;
  do
  {
    if ( sub_27EC8(v0) )
    {
      for ( i = 0; ; ++i )
      {
        v4 = sub_27DC8();
        v5 = (unsigned __int8)i;
        if ( v4 <= i )
          break;
        v6 = i == 3;
        if ( i != 3 )
          v6 = i == 0;
        if ( !v6 )
        {
          v7 = sub_18D48(v0, v5);
          if ( v1 < v7 )
            LOWORD(v1) = v7;
          v1 = (__int16)v1;
        }
      }
    }
    ++v0;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (00018F28) --------------------------------------------------------
int sub_18F28()
{
  int v0; // r5
  int v1; // r6
  int i; // r4
  int v4; // r0
  int v5; // r1
  bool v6; // zf
  int v7; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    if ( sub_27EC8(v0) )
    {
      for ( i = 0; ; ++i )
      {
        v4 = sub_27DC8();
        v5 = (unsigned __int8)i;
        if ( v4 <= i )
          break;
        v6 = i == 3;
        if ( i != 3 )
          v6 = i == 0;
        if ( !v6 )
        {
          v7 = sub_18D48(v0, v5);
          if ( v1 >= v7 )
            LOWORD(v1) = v7;
          v1 = (__int16)v1;
        }
      }
    }
    ++v0;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (00018F94) --------------------------------------------------------
int sub_18F94()
{
  int v0; // r5
  int v1; // r6
  int v2; // r7
  int i; // r4
  int v5; // r0
  int v6; // r1
  bool v7; // zf

  v0 = 0;
  v1 = 0;
  v2 = 0;
  do
  {
    if ( sub_27EC8(v0) )
    {
      for ( i = 0; ; ++i )
      {
        v5 = sub_27DC8();
        v6 = (unsigned __int8)i;
        if ( v5 <= i )
          break;
        v7 = i == 3;
        if ( i != 3 )
          v7 = i == 0;
        if ( !v7 )
        {
          ++v1;
          v2 += sub_18D48(v0, v6);
        }
      }
    }
    ++v0;
  }
  while ( v0 != 4 );
  if ( v1 )
    return (__int16)sub_96518(v2, v1);
  else
    return 35;
}

//----- (0001901C) --------------------------------------------------------
int __fastcall sub_1901C(int a1, int a2)
{
  int result; // r0

  if ( sub_27D9C() )
    return sub_17E94(a1, 1, a2);
  result = sub_18D48(a1, a2);
  if ( result != 255 )
    return (__int16)(result + 10);
  return result;
}

//----- (00019068) --------------------------------------------------------
int __fastcall sub_19068(int a1, int a2)
{
  int result; // r0

  if ( sub_27D9C() )
    return sub_17E94(a1, 2, a2);
  result = sub_18D48(a1, a2);
  if ( result != 255 )
    return (__int16)(result + 15);
  return result;
}

//----- (000190B4) --------------------------------------------------------
int __fastcall sub_190B4(int a1, int a2)
{
  return sub_18D48(a1, a2 == 0);
}

//----- (000190CC) --------------------------------------------------------
int __fastcall sub_190CC(int a1, unsigned int a2)
{
  int v4; // r0
  int v5; // r6
  int v7; // r8
  int i; // r4
  int v9; // r0

  v4 = sub_27EC8(a1) == 0;
  if ( a2 > 3 )
    v4 |= 1u;
  if ( v4 )
    return 255;
  v7 = a2 ? sub_175A8() : sub_27DC8();
  if ( v7 <= 0 )
    return 255;
  v5 = 255;
  for ( i = 0; i != v7; ++i )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        v9 = sub_1901C(a1, (unsigned __int8)i);
      }
      else if ( a2 == 3 )
      {
        v9 = sub_18D08(a1, (unsigned __int8)i);
      }
      else
      {
        v9 = sub_19068(a1, (unsigned __int8)i);
      }
    }
    else
    {
      v9 = sub_18D48(a1, (unsigned __int8)i);
    }
    if ( v9 != 255 )
    {
      if ( v5 == 255 )
      {
        v5 = v9;
      }
      else if ( v5 < v9 )
      {
        v5 = v9;
      }
    }
  }
  return v5;
}

//----- (00019194) --------------------------------------------------------
int __fastcall sub_19194(int a1)
{
  const char *v2; // r0
  unsigned int v3; // r1

  v2 = (const char *)sub_27CEC();
  v3 = strcmp(v2, "BHB28601") == 0;
  return (__int16)sub_190CC(a1, v3);
}

//----- (000191C8) --------------------------------------------------------
int __fastcall sub_191C8(int a1)
{
  int v1; // r4
  unsigned __int16 v3; // r6
  int v4; // r5
  int v5; // r0

  v1 = 0;
  v3 = 0;
  v4 = 255;
  do
  {
    v5 = sub_19194(v1);
    if ( v5 != 255 )
    {
      if ( v4 == 255 )
      {
        v4 = v5;
      }
      else if ( v5 > v4 )
      {
        v3 = (unsigned __int8)v1;
        v4 = v5;
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  if ( a1 )
    return (unsigned __int16)v4 | (v3 << 16);
  return v4;
}

//----- (00019220) --------------------------------------------------------
int __fastcall sub_19220(int a1)
{
  return (__int16)sub_190CC(a1, 1u);
}

//----- (00019234) --------------------------------------------------------
int __fastcall sub_19234(int a1)
{
  int v1; // r4
  unsigned __int16 v3; // r6
  int v4; // r5
  __int16 v5; // r0

  v1 = 0;
  v3 = 0;
  v4 = 255;
  do
  {
    v5 = sub_190CC(v1, 1u);
    if ( v5 != 255 )
    {
      if ( v4 == 255 )
      {
        v4 = v5;
      }
      else if ( v5 > v4 )
      {
        v3 = (unsigned __int8)v1;
        v4 = v5;
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  if ( a1 )
    return (unsigned __int16)v4 | (v3 << 16);
  return v4;
}

//----- (00019294) --------------------------------------------------------
int __fastcall sub_19294(int a1)
{
  return (__int16)sub_190CC(a1, 2u);
}

//----- (000192A8) --------------------------------------------------------
int __fastcall sub_192A8(int a1)
{
  int v1; // r4
  unsigned __int16 v3; // r6
  int v4; // r5
  __int16 v5; // r0

  v1 = 0;
  v3 = 0;
  v4 = 255;
  do
  {
    v5 = sub_190CC(v1, 2u);
    if ( v5 != 255 )
    {
      if ( v4 == 255 )
      {
        v4 = v5;
      }
      else if ( v5 > v4 )
      {
        v3 = (unsigned __int8)v1;
        v4 = v5;
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  if ( a1 )
    return (unsigned __int16)v4 | (v3 << 16);
  return v4;
}

//----- (00019308) --------------------------------------------------------
int __fastcall sub_19308(int a1, unsigned int a2)
{
  int v4; // r0
  int v5; // r6
  int v7; // r8
  int i; // r4
  int v9; // r0

  v4 = sub_27EC8(a1) == 0;
  if ( a2 > 3 )
    v4 |= 1u;
  if ( v4 )
    return 255;
  v7 = a2 ? sub_175A8() : sub_27DC8();
  if ( v7 <= 0 )
    return 255;
  v5 = 255;
  for ( i = 0; i != v7; ++i )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        v9 = sub_1901C(a1, (unsigned __int8)i);
      }
      else if ( a2 == 3 )
      {
        v9 = sub_18D08(a1, (unsigned __int8)i);
      }
      else
      {
        v9 = sub_19068(a1, (unsigned __int8)i);
      }
    }
    else
    {
      v9 = sub_18D48(a1, (unsigned __int8)i);
    }
    if ( v9 != 255 )
    {
      if ( v5 == 255 )
      {
        v5 = v9;
      }
      else if ( v5 >= v9 )
      {
        v5 = v9;
      }
    }
  }
  return v5;
}

//----- (000193D0) --------------------------------------------------------
int __fastcall sub_193D0(int a1)
{
  const char *v2; // r0
  unsigned int v3; // r1

  v2 = (const char *)sub_27CEC();
  v3 = strcmp(v2, "BHB28601") == 0;
  return (__int16)sub_19308(a1, v3);
}

//----- (00019404) --------------------------------------------------------
int sub_19404()
{
  int v0; // r5
  int v1; // r4
  int v2; // r0
  int v3; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = v0++;
    v3 = sub_193D0(v2);
    if ( v3 < v1 )
      LOWORD(v1) = v3;
    v1 = (__int16)v1;
  }
  while ( v0 != 4 );
  return (__int16)v1;
}

//----- (00019438) --------------------------------------------------------
int __fastcall sub_19438(int a1)
{
  return (__int16)sub_19308(a1, 1u);
}

//----- (0001944C) --------------------------------------------------------
int sub_1944C()
{
  int v0; // r4
  int v1; // r5
  __int16 v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_19308(v0++, 1u);
    if ( v2 < v1 )
      v1 = v2;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (00019484) --------------------------------------------------------
int __fastcall sub_19484(int a1)
{
  return (__int16)sub_19308(a1, 2u);
}

//----- (00019498) --------------------------------------------------------
int sub_19498()
{
  int v0; // r4
  int v1; // r5
  __int16 v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_19308(v0++, 2u);
    if ( v2 < v1 )
      v1 = v2;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (000194D0) --------------------------------------------------------
int __fastcall sub_194D0(int a1)
{
  return (__int16)sub_19308(a1, 3u);
}

//----- (000194E4) --------------------------------------------------------
int __fastcall sub_194E4(int a1)
{
  return (__int16)sub_190CC(a1, 3u);
}

//----- (000194F8) --------------------------------------------------------
int sub_194F8()
{
  int v0; // r4
  int v1; // r5
  __int16 v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_19308(v0++, 3u);
    if ( v2 < v1 )
      v1 = v2;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (00019530) --------------------------------------------------------
int sub_19530()
{
  int v0; // r4
  int v1; // r5
  __int16 v2; // r0

  v0 = 0;
  v1 = 255;
  do
  {
    v2 = sub_190CC(v0, 3u);
    if ( v2 != 255 )
    {
      if ( v1 == 255 )
      {
        v1 = v2;
      }
      else if ( v2 >= v1 )
      {
        v1 = v2;
      }
    }
    ++v0;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (0001957C) --------------------------------------------------------
int sub_1957C()
{
  int v0; // r12
  int v1; // r11
  int j; // r6
  int v3; // r7
  int v4; // r4
  const char *v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r4
  int v8; // r3
  int v9; // r12
  int v10; // r2
  int v11; // r12
  int v12; // r3
  int v13; // kr00_4
  const char *v14; // r3
  int v15; // r12
  int v16; // r0
  int v17; // r7
  int v18; // r0
  int v19; // r11
  int v20; // r7
  int v21; // r6
  int v22; // r4
  int v23; // r5
  int v24; // r2
  int v25; // r6
  int v26; // r4
  const char *v27; // lr
  const char *v28; // r12
  int *v29; // r0
  int v30; // r11
  int v31; // r6
  unsigned int v32; // r5
  int k; // r4
  __int16 v34; // r0
  int v35; // r10
  int v36; // r4
  unsigned int v37; // r0
  int v38; // r6
  int v39; // r3
  int v40; // r5
  unsigned int v41; // r0
  int v42; // r7
  int v43; // r3
  const char *v44; // r0
  int v45; // r9
  const char *v46; // r0
  const char *v47; // r0
  const char *v48; // r0
  const char *v49; // r0
  _BOOL4 v50; // r7
  const char *v51; // r0
  _BOOL4 v52; // r5
  const char *v53; // r0
  int v54; // r3
  unsigned int v55; // r7
  unsigned int v56; // r6
  unsigned int v57; // r10
  unsigned int v58; // r9
  int v59; // r5
  const char *v60; // r0
  unsigned int v62; // r4
  unsigned __int16 v63; // r0
  int v64; // r3
  int v65; // r4
  size_t v66; // r0
  int v67; // r4
  size_t v68; // r0
  const char *v69; // r0
  const char *v70; // r0
  const char *v71; // r0
  const char *v72; // r0
  const char *v73; // r0
  const char *v74; // r0
  const char *v75; // r0
  const char *v76; // r0
  const char *v77; // r0
  const char *v78; // r0
  const char *v79; // r0
  _BOOL4 v80; // r3
  char v81; // r0
  const char *v82; // r0
  int v83; // r0
  bool v84; // zf
  int v85; // r5
  int v86; // r6
  int v87; // r0
  int v88; // r0
  bool v89; // nf
  const char *v90; // r0
  const char *v91; // r0
  const char *v92; // r0
  const char *v93; // r0
  const char *v94; // r0
  const char *v95; // r0
  const char *v96; // r0
  const char *v97; // r0
  const char *v98; // r0
  const char *v99; // r0
  const char *v100; // r0
  const char *v101; // r0
  const char *v102; // r0
  const char *v103; // r0
  const char *v104; // r0
  const char *v105; // r0
  const char *v106; // r0
  const char *v107; // r0
  const char *v108; // r0
  const char *v109; // r0
  const char *v110; // r0
  const char *v111; // r0
  const char *v112; // r0
  const char *v113; // r0
  const char *v114; // r0
  const char *v115; // r0
  const char *v116; // r0
  const char *v117; // r0
  const char *v118; // r0
  const char *v119; // r0
  const char *v120; // r0
  const char *v121; // r0
  const char *v122; // r0
  const char *v123; // r0
  const char *v124; // r0
  const char *v125; // r0
  const char *v126; // r0
  const char *v127; // r0
  const char *v128; // r0
  const char *v129; // r0
  const char *v130; // r0
  const char *v131; // r0
  const char *v132; // r0
  const char *v133; // r0
  const char *v134; // r0
  const char *v135; // r0
  const char *v136; // r0
  const char *v137; // r0
  int v138; // r7
  const char *v139; // r0
  const char *v140; // r0
  const char *v141; // r0
  const char *v142; // r0
  const char *v143; // r0
  const char *v144; // r0
  const char *v145; // r0
  const char *v146; // r0
  const char *v147; // r0
  const char *v148; // r0
  const char *v149; // r0
  size_t v150; // r7
  unsigned int i; // [sp+34h] [bp-2068h]
  int v152; // [sp+34h] [bp-2068h]
  int v153; // [sp+38h] [bp-2064h]
  int v154; // [sp+38h] [bp-2064h]
  char *s2; // [sp+40h] [bp-205Ch]
  int v156; // [sp+44h] [bp-2058h]
  int v157; // [sp+4Ch] [bp-2050h]
  int v158; // [sp+4Ch] [bp-2050h]
  char v159; // [sp+50h] [bp-204Ch]
  int v160; // [sp+50h] [bp-204Ch]
  int v161; // [sp+58h] [bp-2044h]
  unsigned int v162; // [sp+5Ch] [bp-2040h]
  unsigned int v163; // [sp+60h] [bp-203Ch]
  unsigned int v164; // [sp+64h] [bp-2038h]
  __time_t v165; // [sp+74h] [bp-2028h] BYREF
  int v166; // [sp+78h] [bp-2024h]
  __time_t v167; // [sp+7Ch] [bp-2020h] BYREF
  int v168; // [sp+80h] [bp-201Ch]
  _DWORD v169[5]; // [sp+84h] [bp-2018h] BYREF
  char s[8196]; // [sp+98h] [bp-2004h] BYREF

  prctl(15, "temp_mtr", 0, 0, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "temperature_monitor_thread start...");
    sub_41DB8(3, s, 0);
  }
  v153 = 0;
LABEL_4:
  v0 = dword_BDAB4;
  if ( !dword_BDAB4 )
    goto LABEL_118;
  do
  {
    if ( !dword_BB2F0 )
    {
      usleep((__useconds_t)&unk_F4240);
      goto LABEL_4;
    }
    for ( i = 0; i != 4; ++i )
    {
      if ( !sub_27EC8(i) )
        continue;
      v1 = 0;
      for ( j = 0; ; ++j )
      {
        v4 = sub_175A8();
        if ( v4 <= sub_27DC8() )
          break;
        if ( j >= sub_175A8() )
          goto LABEL_54;
LABEL_15:
        v5 = (const char *)sub_27CEC();
        v6 = strcmp(v5, "BHB28601");
        if ( dword_BDAB0 )
          v7 = 3;
        else
          v7 = __clz(v6);
        if ( !dword_BDAB0 )
          v7 >>= 5;
        dword_BDA84 = v7;
        if ( !v7 )
          goto LABEL_37;
        while ( 1 )
        {
LABEL_21:
          if ( dword_BDA68 )
          {
            v3 = dword_BDAC0;
            if ( dword_BDAC0 )
              goto LABEL_11;
LABEL_41:
            if ( sub_175A8() > j )
            {
              pthread_mutex_lock(&stru_BDAC4);
              sub_4465C(&v165);
              if ( v7 == 1 )
              {
                v153 = sub_175C8(i, j, *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * i) + 4) + v1), v3);
              }
              else if ( v7 == 2 )
              {
                v153 = sub_175C8(i, j, *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * i) + 8) + v1), 1);
              }
              sub_4465C(&v167);
              v11 = v167 - v165;
              v12 = v168 - v166;
              if ( v168 - v166 < 0 )
              {
                --v11;
                v12 += 1000000;
              }
              if ( (unsigned int)off_BC5EC <= 4 )
                goto LABEL_52;
              v13 = v12;
              v14 = "chp";
              v15 = v13 / 1000 + 1000 * v11;
              if ( v7 == 1 )
                v14 = "pcb";
              snprintf(s, 0x2000u, "%s read %d on chain %d takes %ldms\n", v14, j, i, v15);
LABEL_51:
              sub_41DB8(4, s, 0);
LABEL_52:
              pthread_mutex_unlock(&stru_BDAC4);
              goto LABEL_32;
            }
          }
          if ( v7 == 3 )
            break;
          while ( 1 )
          {
LABEL_35:
            if ( ++v7 == 4 )
              goto LABEL_12;
            if ( v7 )
              break;
LABEL_37:
            if ( sub_27DC8() > j )
            {
              pthread_mutex_lock(&stru_BDAC4);
              sub_4465C(&v165);
              if ( !sub_27EC8(i) )
              {
                if ( (unsigned int)off_BC5EC > 4 )
                {
                  snprintf(s, 0x2000u, "%s chain %d not pluged", "read_sensor_on_pic", i);
                  v153 = 255;
                  sub_41DB8(4, s, v7);
                  goto LABEL_260;
                }
                goto LABEL_259;
              }
              if ( j >= sub_27DC8() )
              {
                if ( (unsigned int)off_BC5EC > 3 )
                {
                  v153 = 255;
                  snprintf(s, 0x2000u, "%s invalid index = %d on chain %d", "read_sensor_on_pic", j, i);
                  sub_41DB8(3, s, v7);
                  goto LABEL_260;
                }
LABEL_259:
                v153 = 255;
LABEL_260:
                sub_4465C(&v167);
                v138 = v168 - v166;
                v158 = v167 - v165;
                if ( v168 - v166 < 0 )
                {
                  v138 += 1000000;
                  v158 = v167 - v165 - 1;
                }
                v139 = (const char *)sub_27CEC();
                if ( !strcmp(v139, "HHB68502") )
                  goto LABEL_263;
                v140 = (const char *)sub_27CEC();
                if ( !strcmp(v140, "HHB68501") )
                  goto LABEL_263;
                v141 = (const char *)sub_27CEC();
                if ( !strcmp(v141, "HHB68701") )
                  goto LABEL_263;
                v142 = (const char *)sub_27CEC();
                if ( !strcmp(v142, "HHB68704")
                  || (v143 = (const char *)sub_27CEC(), !strcmp(v143, "HHB68703"))
                  || (v144 = (const char *)sub_27CEC(), !strcmp(v144, "H6HB68702"))
                  || (v145 = (const char *)sub_27CEC(), !strcmp(v145, "H1HB68601"))
                  || (v146 = (const char *)sub_27CEC(), !strcmp(v146, "HHB68601"))
                  || (v147 = (const char *)sub_27CEC(), !strcmp(v147, "HHB68602"))
                  || (v148 = (const char *)sub_27CEC(), !strcmp(v148, "HHB56611"))
                  || (v149 = (const char *)sub_27CEC(), !strcmp(v149, "HHB68503")) )
                {
LABEL_263:
                  if ( (unsigned int)(j - 1) <= 1 )
                    v153 -= dword_BDAA4;
                }
                if ( (unsigned int)off_BC5EC <= 4 )
                  goto LABEL_52;
                snprintf(
                  s,
                  0x2000u,
                  "pic read %d on chain %d takes %ldms temp:%d\n",
                  j,
                  i,
                  v138 / 1000 + 1000 * v158,
                  v153);
                goto LABEL_51;
              }
              v150 = sub_69BC4(i, *(_BYTE *)(dword_BDAAC + j), v7, v169, 2);
              if ( sub_29C30() && sub_29C90() )
              {
                if ( sub_47394() == 2 )
                  LOBYTE(v169[0]) = sub_29E54((unsigned __int8)i, (unsigned __int8)j);
                else
                  LOBYTE(v169[0]) = sub_29E30((unsigned __int8)i, (unsigned __int8)j);
                if ( !sub_29E0C((unsigned __int8)i, (unsigned __int8)j) )
                  goto LABEL_294;
              }
              else if ( v150 == 2 )
              {
LABEL_294:
                v153 = SLOBYTE(v169[0]);
                goto LABEL_260;
              }
              if ( (unsigned int)off_BC5EC > 3 )
              {
                v153 = 255;
                snprintf(s, 0x2000u, "fail to read pic temp for chain %d", i);
                sub_41DB8(3, s, 0);
                goto LABEL_260;
              }
              goto LABEL_259;
            }
            if ( !dword_BDA68 )
            {
              v7 = 1;
              goto LABEL_21;
            }
            v3 = dword_BDAC0;
            if ( !dword_BDAC0 )
              goto LABEL_41;
LABEL_11:
            if ( v7 == 3 )
              goto LABEL_12;
          }
        }
        if ( !dword_BDAC0 && sub_28618() > j )
        {
          sub_4465C(&v165);
          if ( !sub_27EC8(i) )
          {
            if ( (unsigned int)off_BC5EC <= 4 )
              goto LABEL_27;
            snprintf(s, 0x2000u, "%s chain %d not pluged", "read_sensor_on_ctrlboard", i);
            v153 = 255;
            sub_41DB8(4, s, 0);
LABEL_28:
            sub_4465C(&v167);
            v8 = v168 - v166 + (v168 - v166 < 0 ? 0xF4000 : 0);
            v9 = v167 - v165;
            if ( v168 - v166 < 0 )
            {
              --v9;
              v8 += 576;
            }
            if ( (unsigned int)off_BC5EC > 4 )
            {
              snprintf(
                s,
                0x2000u,
                "ctrlborad read %d on chain %d takes %ldms temp:%d",
                j,
                i,
                v8 / 1000 + 1000 * v9,
                v153);
              sub_41DB8(4, s, 0);
            }
LABEL_32:
            pthread_mutex_lock(&stru_BDA6C);
            if ( v153 == 255 )
            {
              v43 = *(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * i) + 4 * v7) + v1;
              ++*(_WORD *)(v43 + 4);
            }
            else
            {
              v10 = dword_BDA64;
              *(_WORD *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * i) + 4 * v7) + v1 + 2) = v153;
              *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v10 + 4 * i) + 4 * v7) + v1 + 4) = 0;
            }
            pthread_mutex_unlock(&stru_BDA6C);
            goto LABEL_35;
          }
          if ( j >= sub_28618() )
          {
            if ( (unsigned int)off_BC5EC > 3 )
            {
              v153 = 255;
              snprintf(s, 0x2000u, "%s invalid index = %d on chain %d", "read_sensor_on_ctrlboard", j, i);
              sub_41DB8(3, s, 0);
              goto LABEL_28;
            }
            goto LABEL_27;
          }
          v154 = sub_73954(i, *(_BYTE *)(dword_BDAB0 + j), 0, (int)v169, 2u);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "%s read ctrlboard tsensor data on chain %d, slave addr %d,tmp %d",
              "read_sensor_on_ctrlboard",
              i,
              *(unsigned __int8 *)(dword_BDAB0 + j),
              SLOBYTE(v169[0]));
            sub_41DB8(4, s, 0);
          }
          if ( sub_29C30() && sub_29C90() )
          {
            if ( sub_47394() == 2 )
              v81 = sub_29E54((unsigned __int8)i, (unsigned __int8)j);
            else
              v81 = sub_29E30((unsigned __int8)i, (unsigned __int8)j);
            LOBYTE(v169[0]) = v81;
            if ( !sub_29E0C((unsigned __int8)i, (unsigned __int8)j) )
              goto LABEL_177;
          }
          else if ( v154 == 2 )
          {
LABEL_177:
            v153 = SLOBYTE(v169[0]);
            goto LABEL_28;
          }
          if ( (unsigned int)off_BC5EC > 3 )
          {
            v153 = 255;
            snprintf(s, 0x2000u, "fail to read pic temp for chain %d", i);
            sub_41DB8(3, s, 0);
            goto LABEL_28;
          }
LABEL_27:
          v153 = 255;
          goto LABEL_28;
        }
LABEL_12:
        v1 += 6;
      }
      if ( j < sub_27DC8() )
        goto LABEL_15;
LABEL_54:
      v169[0] = "pic";
      v169[1] = "pcb";
      v169[2] = "chp";
      v169[3] = "ctrlboard";
      v169[4] = "max";
      memset(s, 0, 0x100u);
      if ( dword_BDADC )
      {
        if ( dword_BDAE0 )
          goto LABEL_56;
LABEL_150:
        v67 = sub_175A8();
        if ( v67 <= sub_27DC8() )
          v68 = 4 * sub_27DC8() + 5;
        else
          v68 = 4 * sub_175A8() + 5;
        dword_BDAE0 = (int)malloc(v68);
      }
      else
      {
        v65 = sub_175A8();
        if ( v65 <= sub_27DC8() )
          v66 = 4 * sub_27DC8() + 5;
        else
          v66 = 4 * sub_175A8() + 5;
        dword_BDADC = (int)malloc(v66);
        if ( !dword_BDAE0 )
          goto LABEL_150;
      }
LABEL_56:
      pthread_mutex_lock(&stru_BDA6C);
      v16 = sub_18310();
      v17 = v16;
      switch ( v16 )
      {
        case 0:
          v18 = sub_27DC8();
          goto LABEL_58;
        case 1:
        case 2:
          v18 = sub_175A8();
          if ( v18 <= 0 )
            goto LABEL_122;
          goto LABEL_59;
        case 3:
          v18 = sub_28618();
LABEL_58:
          if ( v18 <= 0 )
          {
LABEL_122:
            v26 = -1;
            v20 = v17;
            v25 = -1;
          }
          else
          {
LABEL_59:
            v19 = 0;
            v20 = v17;
            v21 = 0;
            v22 = 0;
            v23 = 6 * v18;
            do
            {
              v22 += sprintf(
                       (char *)(dword_BDADC + v22),
                       "%03d-",
                       *(__int16 *)(*(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * i) + v20 * 4) + v19 + 2));
              v24 = *(_DWORD *)(*(_DWORD *)(dword_BDA64 + 4 * i) + v20 * 4) + v19;
              v19 += 6;
              v21 += sprintf((char *)(dword_BDAE0 + v21), "%03d-", *(__int16 *)(v24 + 4));
            }
            while ( v23 != v19 );
            v25 = v21 - 1;
            v26 = v22 - 1;
          }
          break;
        default:
          v26 = -1;
          v20 = v16;
          v25 = -1;
          break;
      }
      v27 = (const char *)dword_BDAE0;
      v28 = (const char *)dword_BDADC;
      *(_BYTE *)(dword_BDAE0 + v25) = 32;
      v28[v26] = 32;
      sprintf(s, "chain %d %s temp: %s, failure:%s", i, (const char *)v169[v20], v28, v27);
      v29 = (int *)dword_BDAE4;
      if ( !dword_BDAE4 )
      {
        v29 = sub_835A0("bmminer_temp");
        dword_BDAE4 = (int)v29;
      }
      sub_85464((int)v29, "temperature/temperature.c", 25, (int)"dump_temp_info", 14, 739, 20, (int)"%s", s);
      pthread_mutex_unlock(&stru_BDA6C);
    }
    v30 = (unsigned __int8)byte_BDAA2;
    if ( !byte_BDAA2 )
      goto LABEL_115;
    if ( dword_BDA84 == 3 )
    {
      v31 = 255;
      v32 = sub_19530();
      for ( k = 0; k != 4; ++k )
      {
        v34 = sub_19308(k, 3u);
        if ( v34 < v31 )
          v31 = v34;
      }
      v35 = v31;
    }
    else
    {
      v32 = sub_191C8(1);
      v35 = sub_18E58();
    }
    v36 = 0;
    v37 = sub_19234(1);
    s2 = (char *)(__int16)v37;
    v163 = HIWORD(v37);
    v38 = 0;
    v162 = HIWORD(v32);
    v39 = (__int16)v32;
    v40 = 0;
    v156 = v39;
    v41 = sub_192A8(1);
    v164 = HIWORD(v41);
    v152 = (__int16)v41;
    do
    {
      if ( sub_27EC8(v40) )
      {
        v42 = 0;
        v38 = (unsigned __int8)(v38 + 1);
        while ( v42 < sub_175A8() )
        {
          if ( dword_BDA84 == 3 )
            v36 += sub_17FD4(v40, 3, (unsigned __int8)v42);
          else
            v36 += sub_18BC4(v40, (unsigned __int8)v42);
          ++v42;
        }
      }
      ++v40;
    }
    while ( v40 != 4 );
    v44 = (const char *)sub_27CEC();
    if ( !strcmp(v44, "HHB68502") || (v82 = (const char *)sub_27CEC(), !strcmp(v82, "HHB68503")) )
      v45 = 59;
    else
      v45 = 54;
    v46 = (const char *)sub_27CEC();
    if ( strcmp(v46, "HHB68502") )
    {
      v90 = (const char *)sub_27CEC();
      if ( strcmp(v90, "HHB68501") )
      {
        v91 = (const char *)sub_27CEC();
        if ( strcmp(v91, "HHB68701") )
        {
          v92 = (const char *)sub_27CEC();
          if ( strcmp(v92, "HHB68704") )
          {
            v93 = (const char *)sub_27CEC();
            if ( strcmp(v93, "HHB68703") )
            {
              v94 = (const char *)sub_27CEC();
              if ( strcmp(v94, "H6HB68702") )
              {
                v95 = (const char *)sub_27CEC();
                if ( strcmp(v95, "H1HB68601") )
                {
                  v96 = (const char *)sub_27CEC();
                  if ( strcmp(v96, "HHB68601") )
                  {
                    v97 = (const char *)sub_27CEC();
                    if ( strcmp(v97, "HHB68602") )
                    {
                      v98 = (const char *)sub_27CEC();
                      if ( strcmp(v98, "HHB56611") )
                      {
                        v99 = (const char *)sub_27CEC();
                        if ( strcmp(v99, "HHB68503") )
                          goto LABEL_87;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ( v35 <= 19 && !sub_48264() )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "too low water temperature pic temp %d (min %d)\n", v35, 20);
        sub_41DB8(3, s, 0);
      }
      v159 = v30;
      sub_473B4(0x10u, "high min temp");
      sub_4FB28(9, 0);
    }
    else
    {
LABEL_87:
      v159 = 0;
    }
    v47 = (const char *)sub_27CEC();
    if ( !strcmp(v47, "HHB68502") )
      goto LABEL_89;
    v128 = (const char *)sub_27CEC();
    if ( !strcmp(v128, "HHB68501") )
      goto LABEL_89;
    v129 = (const char *)sub_27CEC();
    if ( !strcmp(v129, "HHB68701") )
      goto LABEL_89;
    v130 = (const char *)sub_27CEC();
    if ( !strcmp(v130, "HHB68704")
      || (v131 = (const char *)sub_27CEC(), !strcmp(v131, "HHB68703"))
      || (v132 = (const char *)sub_27CEC(), !strcmp(v132, "H6HB68702"))
      || (v133 = (const char *)sub_27CEC(), !strcmp(v133, "H1HB68601"))
      || (v134 = (const char *)sub_27CEC(), !strcmp(v134, "HHB68601"))
      || (v135 = (const char *)sub_27CEC(), !strcmp(v135, "HHB68602"))
      || (v136 = (const char *)sub_27CEC(), !strcmp(v136, "HHB56611"))
      || (v137 = (const char *)sub_27CEC(), !strcmp(v137, "HHB68503")) )
    {
LABEL_89:
      if ( v35 >= v45 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "too hot water temperature pic temp %d (min %d)\n", v35, v45);
          sub_41DB8(3, s, 0);
        }
        v159 = v30;
        sub_473B4(0xFu, "over max temp");
        sub_4FB28(8, 0);
      }
    }
    v48 = (const char *)sub_27CEC();
    if ( !strcmp(v48, "HHB68502") )
      goto LABEL_94;
    v118 = (const char *)sub_27CEC();
    if ( !strcmp(v118, "HHB68501") )
      goto LABEL_94;
    v119 = (const char *)sub_27CEC();
    if ( !strcmp(v119, "HHB68701") )
      goto LABEL_94;
    v120 = (const char *)sub_27CEC();
    if ( !strcmp(v120, "HHB68704")
      || (v121 = (const char *)sub_27CEC(), !strcmp(v121, "HHB68703"))
      || (v122 = (const char *)sub_27CEC(), !strcmp(v122, "H6HB68702"))
      || (v123 = (const char *)sub_27CEC(), !strcmp(v123, "H1HB68601"))
      || (v124 = (const char *)sub_27CEC(), !strcmp(v124, "HHB68601"))
      || (v125 = (const char *)sub_27CEC(), !strcmp(v125, "HHB68602"))
      || (v126 = (const char *)sub_27CEC(), !strcmp(v126, "HHB56611"))
      || (v127 = (const char *)sub_27CEC(), !strcmp(v127, "HHB68503")) )
    {
LABEL_94:
      v157 = 75;
    }
    else
    {
      v157 = 80;
    }
    v49 = (const char *)sub_27CEC();
    if ( !strcmp(v49, "HHB68502") )
      goto LABEL_96;
    v108 = (const char *)sub_27CEC();
    if ( !strcmp(v108, "HHB68501") )
      goto LABEL_96;
    v109 = (const char *)sub_27CEC();
    if ( !strcmp(v109, "HHB68701") )
      goto LABEL_96;
    v110 = (const char *)sub_27CEC();
    if ( !strcmp(v110, "HHB68704")
      || (v111 = (const char *)sub_27CEC(), !strcmp(v111, "HHB68703"))
      || (v112 = (const char *)sub_27CEC(), !strcmp(v112, "H6HB68702"))
      || (v113 = (const char *)sub_27CEC(), !strcmp(v113, "H1HB68601"))
      || (v114 = (const char *)sub_27CEC(), !strcmp(v114, "HHB68601"))
      || (v115 = (const char *)sub_27CEC(), !strcmp(v115, "HHB68602"))
      || (v116 = (const char *)sub_27CEC(), !strcmp(v116, "HHB56611"))
      || (v117 = (const char *)sub_27CEC(), !strcmp(v117, "HHB68503")) )
    {
LABEL_96:
      v50 = (int)s2 > 85;
    }
    else
    {
      v50 = 0;
    }
    v51 = (const char *)sub_27CEC();
    if ( !strcmp(v51, "HHB68501") )
      goto LABEL_98;
    v100 = (const char *)sub_27CEC();
    if ( !strcmp(v100, "HHB68701")
      || (v101 = (const char *)sub_27CEC(), !strcmp(v101, "HHB68704"))
      || (v102 = (const char *)sub_27CEC(), !strcmp(v102, "HHB68703"))
      || (v103 = (const char *)sub_27CEC(), !strcmp(v103, "H6HB68702"))
      || (v104 = (const char *)sub_27CEC(), !strcmp(v104, "H1HB68601"))
      || (v105 = (const char *)sub_27CEC(), !strcmp(v105, "HHB68601"))
      || (v106 = (const char *)sub_27CEC(), !strcmp(v106, "HHB68602"))
      || (v107 = (const char *)sub_27CEC(), !strcmp(v107, "HHB56611")) )
    {
LABEL_98:
      v52 = v152 > 95;
    }
    else
    {
      v52 = 0;
    }
    v53 = (const char *)sub_27CEC();
    if ( (!strcmp(v53, "HHB68502") || (v79 = (const char *)sub_27CEC(), !strcmp(v79, "HHB68503"))) && v152 > 100
      || (v80 = v156 > v157, v30 = v52 || v80 || v50, v52 | (unsigned __int8)(v50 | v80 | v159)) )
    {
      sub_2CC78(1);
    }
    else
    {
      sub_2CC78(0);
    }
    v54 = 2 * v38;
    v55 = 150;
    v56 = 0;
    v160 = v54;
    sub_2CC90(v54 <= v36);
    v57 = 150;
    v58 = 0;
    v59 = 0;
    v161 = v36;
    do
    {
      if ( sub_27EC8(v59) )
      {
        v62 = (unsigned __int16)sub_18D48(v59, 0);
        if ( v62 >= v58 )
          v58 = v62;
        if ( v62 < v57 )
          v57 = v62;
        v63 = sub_18D48(v59, 1);
        v64 = v63 - v62;
        if ( v63 >= v56 )
          v56 = v63;
        if ( v63 < v55 )
          v55 = v63;
        if ( v64 > 16 )
        {
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(
              s,
              0x2000u,
              "difference between inlet and outlet is too large:%d  inlet_temp:%d,outlet_temp:%d",
              v64,
              v62,
              v63);
            sub_41DB8(3, s, 0);
          }
          if ( (unsigned __int8)++byte_BDAE8 > 3u )
          {
            sub_18394();
            sub_473B4(0xFu, "over max temp");
            sub_4FB28(8, 0);
          }
        }
      }
      ++v59;
    }
    while ( v59 != 4 );
    if ( ((int)(v58 - v56) > 2 || (int)(v57 - v55) > 2) && byte_BDC88 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(
          s,
          0x2000u,
          "inlet_board_temp_max:%d, inlet_board_temp_min:%d, outlet_board_temp_max:%d, outlet_board_temp_min:%d",
          v58,
          v57,
          v56,
          v55);
        sub_41DB8(3, s, 0);
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "water flow is reverse, please swap the water pipes at the inlet and outlet");
          sub_41DB8(3, s, 0);
        }
      }
      sub_18394();
      sub_473B4(0x11u, "water flow is reverse");
      sub_4FB28(8, 0);
    }
    if ( !v30 || sub_473A4() != 2 )
    {
      if ( v160 > v161 )
        goto LABEL_185;
LABEL_112:
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(
          s,
          0x2000u,
          "over max temp, pic temp(chain%d) %d (max %d), pcb temp(chain%d) %d (max %d), chip temp(chain%d) %d(max %d) pcb"
          " temp rise %d chip temp rise %d, total_exit_failure %d\n",
          v162,
          v156,
          v157,
          v163,
          s2,
          85,
          v164,
          v152,
          95,
          0,
          0,
          v161);
        sub_41DB8(3, s, 0);
      }
      sub_473B4(0xFu, "over max temp");
      sub_4FB28(11, 0);
      goto LABEL_115;
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(
        s,
        0x2000u,
        "over max temp, pic temp(chain%d) %d (max %d), pcb temp(chain%d) %d (max %d), chip temp(chain%d) %d(max %d) pcb t"
        "emp rise %d chip temp rise %d, total_exit_failure %d\n",
        v162,
        v156,
        v157,
        v163,
        s2,
        85,
        v164,
        v152,
        95,
        0,
        0,
        v161);
      sub_41DB8(3, s, 0);
    }
    sub_473B4(0xFu, "over max temp");
    sub_4FB28(8, 0);
    if ( v160 <= v161 )
      goto LABEL_112;
LABEL_185:
    v83 = sub_473A4();
    v84 = v156 == 0;
    if ( !v156 )
      v84 = v83 == 2;
    if ( v84 )
    {
      v85 = 255;
      v86 = 0;
      do
      {
        v87 = v86++;
        v88 = sub_193D0(v87);
        if ( v88 < v85 )
          LOWORD(v85) = v88;
        v85 = (__int16)v85;
      }
      while ( v86 != 4 );
      if ( !(_WORD)v85 )
      {
        v89 = dword_BDAEC - 9 < 0;
        ++dword_BDAEC;
        if ( !(v89 ^ __OFSUB__(dword_BDAEC, 10) | (dword_BDAEC == 10)) )
          goto LABEL_112;
      }
    }
LABEL_115:
    v60 = (const char *)sub_27CEC();
    if ( strcmp(v60, "HHB68502") )
    {
      v69 = (const char *)sub_27CEC();
      if ( strcmp(v69, "HHB68501") )
      {
        v70 = (const char *)sub_27CEC();
        if ( strcmp(v70, "HHB68701") )
        {
          v71 = (const char *)sub_27CEC();
          if ( strcmp(v71, "HHB68704") )
          {
            v72 = (const char *)sub_27CEC();
            if ( strcmp(v72, "HHB68703") )
            {
              v73 = (const char *)sub_27CEC();
              if ( strcmp(v73, "H6HB68702") )
              {
                v74 = (const char *)sub_27CEC();
                if ( strcmp(v74, "H1HB68601") )
                {
                  v75 = (const char *)sub_27CEC();
                  if ( strcmp(v75, "HHB68601") )
                  {
                    v76 = (const char *)sub_27CEC();
                    if ( strcmp(v76, "HHB68602") )
                    {
                      v77 = (const char *)sub_27CEC();
                      if ( strcmp(v77, "HHB56611") )
                      {
                        v78 = (const char *)sub_27CEC();
                        if ( strcmp(v78, "HHB68503") )
                        {
                          sub_165E8(0x190u, 0);
                          if ( sub_47394() )
                          {
                            if ( dword_C351C != 1
                              && ((unsigned int)(dword_BDAF0 - 1) <= 0x4E
                               || (unsigned int)dword_BDAF0 > 0x4F && (dword_BDAF0 & 3) == 0) )
                            {
                              sub_169E4();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sleep(1u);
    if ( !byte_BDAA1 )
      goto LABEL_4;
    v0 = dword_BDAB4;
    ++dword_BDAF0;
  }
  while ( dword_BDAB4 );
LABEL_118:
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "temp monitor thread exit");
    sub_41DB8(3, s, v0);
  }
  return 0;
}
// 19954: control flows out of bounds to 19958
// BB2F0: using guessed type int dword_BB2F0;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA64: using guessed type int dword_BDA64;
// BDA68: using guessed type int dword_BDA68;
// BDA84: using guessed type int dword_BDA84;
// BDAA1: using guessed type char byte_BDAA1;
// BDAA2: using guessed type char byte_BDAA2;
// BDAA4: using guessed type int dword_BDAA4;
// BDAAC: using guessed type int dword_BDAAC;
// BDAB0: using guessed type int dword_BDAB0;
// BDAB4: using guessed type int dword_BDAB4;
// BDAC0: using guessed type int dword_BDAC0;
// BDADC: using guessed type int dword_BDADC;
// BDAE0: using guessed type int dword_BDAE0;
// BDAE4: using guessed type int dword_BDAE4;
// BDAE8: using guessed type char byte_BDAE8;
// BDAEC: using guessed type int dword_BDAEC;
// BDAF0: using guessed type int dword_BDAF0;
// BDC88: using guessed type char byte_BDC88;
// C351C: using guessed type int dword_C351C;

//----- (0001AF60) --------------------------------------------------------
int __fastcall sub_1AF60(const char *a1)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r4
  int v4; // r7
  _DWORD *v5; // r0
  _DWORD *v6; // r9
  void *v7; // r3
  _DWORD *v8; // r0
  _DWORD *v9; // r6
  void *v10; // r3
  unsigned int *v11; // r3
  unsigned int v12; // r2
  unsigned int v13; // r2
  unsigned int v15; // r8
  _DWORD *v16; // r0
  _DWORD *v17; // r10
  _DWORD *v18; // r0
  const char *v19; // r7
  size_t v20; // r0
  const char *v21; // r2
  const char *v22; // r0
  char *v23; // r7
  const char *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r8
  const char *v27; // r0
  int v28; // r0
  int v29; // r1
  int v30; // r2
  int v31; // r3
  char *v32; // lr
  int v33; // r1
  int v34; // r2
  const char *v35; // r0
  _DWORD *v36; // r0
  _DWORD *v37; // r9
  int v38; // r10
  unsigned int v39; // r8
  unsigned int v40; // r0
  unsigned int v41; // r1
  _BOOL4 v42; // r3
  _DWORD *v43; // r0
  _DWORD *v44; // r4
  _DWORD *v45; // r0
  int v46; // r0
  int v47; // r1
  int v48; // r12
  _DWORD *v49; // r0
  int v50; // r0
  int v51; // r3
  int v52; // r3
  int v53; // r9
  unsigned int v54; // r7
  unsigned int v55; // r0
  unsigned int v56; // r1
  _BOOL4 v57; // r3
  _DWORD *v58; // r0
  _DWORD *v59; // r11
  _DWORD *v60; // r0
  int v61; // r0
  int v62; // r1
  int v63; // r12
  _DWORD *v64; // r0
  int v65; // r0
  int v66; // r3
  int v67; // r3
  void *v68; // r1
  int v69; // r7
  int v70; // r2
  int v71; // r3
  char *v72; // r3
  int v73; // r3
  void *v74; // r1
  int v75; // r8
  int v76; // r2
  int v77; // r3
  char *v78; // r3
  int v79; // r3
  int v80; // [sp+10h] [bp-211Ch]
  int v81; // [sp+10h] [bp-211Ch]
  int v82; // [sp+14h] [bp-2118h]
  int v83; // [sp+14h] [bp-2118h]
  int v84; // [sp+18h] [bp-2114h]
  int v85; // [sp+18h] [bp-2114h]
  int v86; // [sp+1Ch] [bp-2110h]
  int v87; // [sp+1Ch] [bp-2110h]
  _DWORD *v88; // [sp+24h] [bp-2108h]
  char v89[252]; // [sp+2Ch] [bp-2100h] BYREF
  char s[24]; // [sp+128h] [bp-2004h] BYREF
  __int16 v91; // [sp+140h] [bp-1FECh]

  memset(dword_BDAF4, 0, sizeof(dword_BDAF4));
  v2 = sub_7AD44("/etc/levels.json", 0, v89);
  v3 = v2;
  if ( v2 && !*v2 )
  {
    v5 = (_DWORD *)sub_7C250(v2, "config");
    v6 = v5;
    if ( v5 )
    {
      v7 = off_BC5EC;
      if ( *v5 == 1 )
      {
        if ( (unsigned int)off_BC5EC > 4 )
        {
          strcpy(s, "multi miner type mode\n");
          sub_41DB8(4, s, 0);
        }
        v15 = 0;
        while ( sub_7CD9C(v6) > v15 )
        {
          v16 = (_DWORD *)sub_7CDE8(v6, v15);
          v17 = v16;
          if ( !v16 || *v16 )
          {
            if ( (unsigned int)off_BC5EC > 3 )
            {
              v4 = -1;
              snprintf(s, 0x2000u, "get array %d failed\n", v15);
              sub_41DB8(3, s, 0);
              goto LABEL_16;
            }
LABEL_33:
            v4 = -1;
            goto LABEL_16;
          }
          v18 = (_DWORD *)sub_7C250(v16, "miner");
          ++v15;
          if ( !v18 || *v18 != 2 )
          {
            if ( (unsigned int)off_BC5EC > 3 )
            {
              v4 = -1;
              strcpy(s, "get miner failed\n");
              sub_41DB8(3, s, 0);
              goto LABEL_16;
            }
            goto LABEL_33;
          }
          if ( !a1 )
          {
            if ( (unsigned int)off_BC5EC > 3 )
            {
              v4 = -1;
              strcpy(s, "no board_name\n");
              sub_41DB8(3, s, 0);
              goto LABEL_16;
            }
            goto LABEL_33;
          }
          v19 = (const char *)sub_7DA40(v18);
          v20 = strlen(a1);
          if ( !strncmp(v19, a1, v20) )
          {
            v4 = 0;
            v36 = (_DWORD *)sub_7C250(v17, "levels");
            v37 = v36;
            if ( v36 && *v36 == 1 )
            {
              v38 = 0;
              v39 = 0;
              v82 = 9999;
              v80 = 9999;
              v86 = 0;
              v84 = 0;
              v88 = v3;
              while ( 1 )
              {
                v40 = sub_7CD9C(v37);
                v41 = v39;
                v42 = v38 <= 39;
                if ( v40 <= v39 )
                  v42 = 0;
                ++v39;
                if ( !v42 )
                  break;
                v43 = (_DWORD *)sub_7CDE8(v37, v41);
                v44 = v43;
                if ( v43 )
                {
                  if ( !*v43 )
                  {
                    v45 = (_DWORD *)sub_7C250(v43, "frequency");
                    if ( v45 )
                    {
                      if ( *v45 == 3 )
                      {
                        v46 = sub_7DF10((int)v45);
                        v47 = v82;
                        v48 = v86;
                        dword_BDAF4[2 * v38 + 1] = v46;
                        if ( v82 >= v46 )
                          v47 = v46;
                        if ( v86 < v46 )
                          v48 = v46;
                        v82 = v47;
                        v86 = v48;
                        v49 = (_DWORD *)sub_7C250(v44, "voltage");
                        if ( v49 && *v49 == 3 )
                        {
                          v50 = sub_7DF10((int)v49);
                          v51 = v80;
                          dword_BDAF4[2 * v38++] = v50;
                          if ( v80 >= v50 )
                            v51 = v50;
                          v80 = v51;
                          v52 = v84;
                          if ( v84 < v50 )
                            v52 = v50;
                          v84 = v52;
                        }
                      }
                    }
                  }
                }
              }
              v3 = v88;
              v74 = off_BC5EC;
              v75 = 0;
              do
              {
                v76 = dword_BDAF4[2 * v75];
                v77 = 2 * v75++;
                v78 = (char *)&dword_BDAF4[v77];
                if ( v76 )
                {
                  v79 = *((_DWORD *)v78 + 1);
                  if ( v79 )
                  {
                    if ( (unsigned int)v74 > 4 )
                    {
                      snprintf(s, 0x2000u, "level %d, voltage = %d frequency = %d", v75, v76, v79);
                      sub_41DB8(4, s, 0);
                      v74 = off_BC5EC;
                    }
                  }
                }
              }
              while ( v75 != 40 );
              dword_BDC38 = v82;
              dword_BDC34 = v80;
              dword_BDC40 = v86;
              dword_BDC3C = v84;
              if ( (unsigned int)v74 > 4 )
              {
                snprintf(
                  s,
                  0x2000u,
                  "acceptable min_vol = %d min_freq = %d max_vol = %d max_freq = %d",
                  v80,
                  v82,
                  v84,
                  v86);
                sub_41DB8(4, s, 0);
                goto LABEL_16;
              }
LABEL_106:
              v4 = 0;
              goto LABEL_16;
            }
LABEL_44:
            if ( (unsigned int)off_BC5EC > 3 )
            {
              v21 = "failed to get levels in %s\n";
LABEL_35:
              v4 = -2;
              snprintf(s, 0x2000u, v21, "/etc/levels.json");
              sub_41DB8(3, s, 0);
LABEL_16:
              if ( v3[1] != -1 )
              {
                v11 = v3 + 1;
                __dmb(0xBu);
                do
                {
                  v12 = __ldrex(v11);
                  v13 = v12 - 1;
                }
                while ( __strex(v13, v11) );
                if ( !v13 )
                  sub_7E3BC(v3);
              }
              return v4;
            }
LABEL_15:
            v4 = -2;
            goto LABEL_16;
          }
        }
        if ( (unsigned int)off_BC5EC <= 3 )
          goto LABEL_33;
        v4 = -1;
        v28 = *(_DWORD *)"board name doesn't match\n";
        v29 = *(_DWORD *)"d name doesn't match\n";
        v30 = *(_DWORD *)"me doesn't match\n";
        v31 = *(_DWORD *)"oesn't match\n";
        v32 = "'t match\n";
        goto LABEL_50;
      }
    }
    else
    {
      v7 = off_BC5EC;
    }
    if ( (unsigned int)v7 > 4 )
    {
      strcpy(s, "single miner type mode\n");
      sub_41DB8(4, s, 0);
    }
    v8 = (_DWORD *)sub_7C250(v3, "miner");
    v9 = v8;
    if ( !v8 )
    {
      v10 = off_BC5EC;
      goto LABEL_14;
    }
    v10 = off_BC5EC;
    if ( *v8 != 2 )
    {
LABEL_14:
      if ( (unsigned int)v10 > 3 )
      {
        v21 = "failed to get miner type in %s\n";
        goto LABEL_35;
      }
      goto LABEL_15;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v35 = (const char *)sub_7DA40(v8);
      snprintf(s, 0x2000u, "miner type in %s is %s", "/etc/levels.json", v35);
      sub_41DB8(4, s, 0);
    }
    v22 = (const char *)sub_7DA40(v9);
    v23 = strstr(dest, v22);
    if ( v23 )
    {
      v24 = (const char *)sub_7DA40(v9);
      if ( strcasecmp(v23, v24) )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          v4 = -3;
          strcpy(s, "miner type not match");
          sub_41DB8(3, s, 0);
          goto LABEL_16;
        }
        goto LABEL_41;
      }
LABEL_42:
      v25 = (_DWORD *)sub_7C250(v3, "levels");
      v26 = v25;
      if ( v25 && *v25 == 1 )
      {
        v53 = 0;
        v54 = 0;
        v81 = 9999;
        v83 = 0;
        v87 = 0;
        v85 = 9999;
        while ( 1 )
        {
          v55 = sub_7CD9C(v26);
          v56 = v54;
          v57 = v55 > v54;
          if ( v53 > 39 )
            v57 = 0;
          ++v54;
          if ( !v57 )
            break;
          v58 = (_DWORD *)sub_7CDE8(v26, v56);
          v59 = v58;
          if ( !*v3 )
          {
            v60 = (_DWORD *)sub_7C250(v58, "frequency");
            if ( v60 )
            {
              if ( *v60 == 3 )
              {
                v61 = sub_7DF10((int)v60);
                v62 = v81;
                v63 = v83;
                dword_BDAF4[2 * v53 + 1] = v61;
                if ( v81 >= v61 )
                  v62 = v61;
                if ( v83 < v61 )
                  v63 = v61;
                v81 = v62;
                v83 = v63;
                v64 = (_DWORD *)sub_7C250(v59, "voltage");
                if ( v64 && *v64 == 3 )
                {
                  v65 = sub_7DF10((int)v64);
                  v66 = v85;
                  dword_BDAF4[2 * v53++] = v65;
                  if ( v85 >= v65 )
                    v66 = v65;
                  v85 = v66;
                  v67 = v87;
                  if ( v87 < v65 )
                    v67 = v65;
                  v87 = v67;
                }
              }
            }
          }
        }
        v68 = off_BC5EC;
        v69 = 0;
        do
        {
          v70 = dword_BDAF4[2 * v69];
          v71 = 2 * v69++;
          v72 = (char *)&dword_BDAF4[v71];
          if ( v70 )
          {
            v73 = *((_DWORD *)v72 + 1);
            if ( v73 )
            {
              if ( (unsigned int)v68 > 3 )
              {
                snprintf(s, 0x2000u, "level %d, voltage = %d frequency = %d", v69, v70, v73);
                sub_41DB8(3, s, 0);
                v68 = off_BC5EC;
              }
            }
          }
        }
        while ( v69 != 40 );
        dword_BDC38 = v81;
        dword_BDC34 = v85;
        dword_BDC40 = v83;
        dword_BDC3C = v87;
        if ( (unsigned int)v68 > 4 )
        {
          v4 = 0;
          snprintf(s, 0x2000u, "acceptable min_vol = %d min_freq = %d max_vol = %d max_freq = %d", v85, v81, v87, v83);
          sub_41DB8(4, s, 0);
          goto LABEL_16;
        }
        goto LABEL_106;
      }
      goto LABEL_44;
    }
    if ( strstr(dest, "HHB42701") || strstr(dest, "HHB42XXX") || strstr(dest, "TH401") )
    {
      v27 = (const char *)sub_7DA40(v9);
      if ( strstr(v27, (const char *)&off_97C78) )
        goto LABEL_42;
    }
    if ( (unsigned int)off_BC5EC <= 3 )
    {
LABEL_41:
      v4 = -3;
      goto LABEL_16;
    }
    v4 = -3;
    v28 = *(_DWORD *)"miner type does not match";
    v29 = *(_DWORD *)"r type does not match";
    v30 = *(_DWORD *)"pe does not match";
    v31 = *(_DWORD *)"oes not match";
    v32 = "not match";
LABEL_50:
    *(_DWORD *)s = v28;
    *(_DWORD *)&s[4] = v29;
    *(_DWORD *)&s[8] = v30;
    *(_DWORD *)&s[12] = v31;
    v33 = *((_DWORD *)v32 + 1);
    v34 = *((_DWORD *)v32 + 2);
    *(_DWORD *)&s[16] = *(_DWORD *)v32;
    *(_DWORD *)&s[20] = v33;
    v91 = v34;
    sub_41DB8(3, s, 0);
    goto LABEL_16;
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    return -1;
  snprintf(s, 0x2000u, "load vol-freq config file %s failed\n", "/etc/levels.json");
  sub_41DB8(3, s, 0);
  return -1;
}
// 97C78: using guessed type _UNKNOWN *off_97C78;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDAF4: using guessed type _DWORD dword_BDAF4[80];
// BDC34: using guessed type int dword_BDC34;
// BDC38: using guessed type int dword_BDC38;
// BDC3C: using guessed type int dword_BDC3C;
// BDC40: using guessed type int dword_BDC40;

//----- (0001B8F8) --------------------------------------------------------
int sub_1B8F8()
{
  unsigned int i; // r4
  unsigned int v1; // r4
  unsigned int v2; // r5
  int v4; // r11
  int v5; // r8
  _DWORD *v6; // r0
  _DWORD *v7; // r10
  size_t v8; // r8
  size_t v9; // r3
  const char *v10; // r0
  size_t n; // [sp+14h] [bp-2120h]
  unsigned int v12; // [sp+18h] [bp-211Ch] BYREF
  char s1[4]; // [sp+1Ch] [bp-2118h] BYREF
  int v14; // [sp+20h] [bp-2114h]
  int v15; // [sp+24h] [bp-2110h]
  int v16; // [sp+28h] [bp-210Ch]
  int v17; // [sp+2Ch] [bp-2108h]
  _BYTE v18[256]; // [sp+30h] [bp-2104h] BYREF
  char s[8196]; // [sp+130h] [bp-2004h] BYREF

  if ( dword_BDC44 )
  {
    if ( *(_BYTE *)(dword_BDC44 + 28) )
      return -3;
  }
  else
  {
    dword_BDC44 = (int)calloc(1u, 0x20u);
    if ( !dword_BDC44 )
    {
      v2 = -2;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "No memory for configuraion.\n");
        sub_41DB8(3, s, 0);
        if ( dword_BDC44 )
        {
          free((void *)dword_BDC44);
          dword_BDC44 = 0;
        }
      }
      return v2;
    }
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      sub_61B9C(i);
      sub_44890();
    }
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "skip loading levels for now\n");
    sub_41DB8(3, s, 0);
  }
  v1 = 0;
  v2 = 0;
  do
  {
    if ( sub_27EC8(v1) )
    {
      v4 = dword_BDC44;
      v5 = 3;
      v12 = 20;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      *(_DWORD *)s1 = 0;
      while ( 1 )
      {
        if ( sub_61FEC(v1, 0, (int)v18, 0x100u) )
        {
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "Read configuration fail for chain %d.\n", v1);
            sub_41DB8(3, s, 0);
          }
          goto LABEL_23;
        }
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "load chain %d eeprom data\n", v1);
          sub_41DB8(3, s, 0);
        }
        v6 = sub_1D700((int)v18, 256);
        v7 = v6;
        if ( v6 )
          break;
        if ( !--v5 )
        {
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "Data load fail for chain %d.\n", v1);
            sub_41DB8(3, s, 0);
          }
LABEL_23:
          v2 = ~(~HIWORD(v2) << 16) | (1 << (v1 + 16));
          goto LABEL_11;
        }
      }
      ((void (__fastcall *)(_DWORD *, char *, unsigned int *))v6[43])(v6, s1, &v12);
      v8 = v12;
      if ( v12 >= 8 )
        v9 = 8;
      else
        v9 = v12;
      n = v9;
      if ( strncmp(s1, "HHB68501", v9)
        && strncmp(s1, "HHB68502", n)
        && strncmp(s1, "HHB68601", n)
        && strncmp(s1, "HHB68602", n)
        && strncmp(s1, "HHB68701", n)
        && strncmp(s1, "HHB68704", n)
        && strncmp(s1, "HHB68703", n) )
      {
        if ( v8 >= 9 )
          v8 = 9;
        if ( strncmp(s1, "H6HB68702", v8)
          && strncmp(s1, "H1HB68601", v8)
          && strncmp(s1, "HHB56611", n)
          && strncmp(s1, "HHB68503", n) )
        {
          if ( (unsigned int)off_BC5EC > 3 )
          {
            v10 = (const char *)sub_27CEC();
            snprintf(s, 0x2000u, "FW type %s, eeprom[%d] shows %s\n", v10, v1, s1);
            sub_41DB8(3, s, 0);
          }
          ((void (__fastcall *)(_DWORD *))v7[72])(v7);
          goto LABEL_23;
        }
      }
      *(_BYTE *)(v4 + v1 + 16) = 1;
      *(_DWORD *)(v4 + 4 * v1) = v7;
    }
LABEL_11:
    ++v1;
  }
  while ( v1 != 4 );
  if ( !v2 )
    *(_BYTE *)(dword_BDC44 + 28) = 1;
  return v2;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001BD64) --------------------------------------------------------
int sub_1BD64()
{
  return 0;
}

//----- (0001BD6C) --------------------------------------------------------
int sub_1BD6C()
{
  int v0; // r4
  int result; // r0

  v0 = 0;
  while ( 1 )
  {
    if ( sub_27EC8(v0) )
    {
      result = *(unsigned __int8 *)(dword_BDC44 + v0 + 20);
      if ( !*(_BYTE *)(dword_BDC44 + v0 + 20) )
        break;
    }
    if ( ++v0 == 4 )
      return 1;
  }
  return result;
}
// BDC44: using guessed type int dword_BDC44;

//----- (0001BDB4) --------------------------------------------------------
int __fastcall sub_1BDB4(int result, char *a2, unsigned int a3)
{
  int v5; // [sp+0h] [bp-201Ch]
  char v6[20]; // [sp+4h] [bp-2018h] BYREF
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v5 = 20;
  memset(v6, 0, sizeof(v6));
  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    result = (*(int (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * result) + 44))();
    if ( a2 )
    {
      if ( v5 + 1 <= a3 )
        return (int)strcpy(a2, v6);
    }
  }
  else if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "No hash board sn, chain = %d.\n", result);
    return sub_41DB8(4, s, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001BEA4) --------------------------------------------------------
int __fastcall sub_1BEA4(int a1)
{
  char v2[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
    return (*(unsigned __int16 (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * a1) + 124))();
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v2, 0x2000u, "No pcb version, chain = %d.\n", a1);
    sub_41DB8(4, v2, 0);
  }
  return 0xFFFF;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001BF3C) --------------------------------------------------------
int __fastcall sub_1BF3C(int a1)
{
  char v2[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
    return (*(unsigned __int16 (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * a1) + 132))();
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v2, 0x2000u, "No bom version, chain = %d.\n", a1);
    sub_41DB8(4, v2, 0);
  }
  return 0xFFFF;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001BFD4) --------------------------------------------------------
int sub_1BFD4()
{
  return 0;
}

//----- (0001BFDC) --------------------------------------------------------
int __fastcall sub_1BFDC(int a1)
{
  char v2[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
    return (*(int (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * a1) + 212))();
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v2, 0x2000u, "No temp, chain = %d.\n", a1);
    sub_41DB8(4, v2, 0);
  }
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001C070) --------------------------------------------------------
int __fastcall sub_1C070(int a1, int a2, int *a3)
{
  unsigned __int8 v3; // r6
  int v4; // r5
  int v6; // r7
  int v7; // r5
  const char *v8; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  int v20; // r6
  int v21; // r2
  bool v22; // r3
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v3 = a1;
  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    v4 = *(_DWORD *)(dword_BDC44 + 4 * a1);
    v6 = (*(int (__fastcall **)(int))(v4 + 188))(v4);
    v7 = (*(int (__fastcall **)(int))(v4 + 196))(v4);
    if ( sub_29C30() && sub_29C50() )
    {
      v7 = sub_29D50(v3);
      v6 = sub_29D38(v3);
    }
    v8 = (const char *)sub_27CEC();
    if ( strcmp(v8, "HHB68502") )
    {
      v10 = (const char *)sub_27CEC();
      if ( strcmp(v10, "HHB68501") )
      {
        v11 = (const char *)sub_27CEC();
        if ( strcmp(v11, "HHB68701") )
        {
          v12 = (const char *)sub_27CEC();
          if ( strcmp(v12, "HHB68704") )
          {
            v13 = (const char *)sub_27CEC();
            if ( strcmp(v13, "HHB68703") )
            {
              v14 = (const char *)sub_27CEC();
              if ( strcmp(v14, "H6HB68702") )
              {
                v15 = (const char *)sub_27CEC();
                if ( strcmp(v15, "H1HB68601") )
                {
                  v16 = (const char *)sub_27CEC();
                  if ( strcmp(v16, "HHB68601") )
                  {
                    v17 = (const char *)sub_27CEC();
                    if ( strcmp(v17, "HHB68602") )
                    {
                      v18 = (const char *)sub_27CEC();
                      if ( strcmp(v18, "HHB56611") )
                      {
                        v19 = (const char *)sub_27CEC();
                        if ( strcmp(v19, "HHB68503") )
                        {
                          v20 = 0;
                          while ( 1 )
                          {
                            v21 = *(_DWORD *)((char *)&unk_BDAF4 + v20);
                            if ( v21 )
                            {
                              v22 = *(_DWORD *)((char *)&unk_BDAF4 + v20 + 4) == v7;
                              if ( !*(_DWORD *)((char *)&unk_BDAF4 + v20 + 4) )
                                v22 = 0;
                              if ( v21 == v6 && v22 )
                              {
                                if ( dword_C351C == 3 )
                                {
                                  v24 = (const char *)sub_27CEC();
                                  if ( !strcmp(v24, "HHB68502") )
                                    goto LABEL_46;
                                  v25 = (const char *)sub_27CEC();
                                  if ( !strcmp(v25, "HHB68501") )
                                    goto LABEL_46;
                                  v26 = (const char *)sub_27CEC();
                                  if ( !strcmp(v26, "HHB68701") )
                                    goto LABEL_46;
                                  v27 = (const char *)sub_27CEC();
                                  if ( !strcmp(v27, "HHB68704")
                                    || (v28 = (const char *)sub_27CEC(), !strcmp(v28, "HHB68703"))
                                    || (v29 = (const char *)sub_27CEC(), !strcmp(v29, "H6HB68702"))
                                    || (v30 = (const char *)sub_27CEC(), !strcmp(v30, "H1HB68601"))
                                    || (v31 = (const char *)sub_27CEC(), !strcmp(v31, "HHB68601"))
                                    || (v32 = (const char *)sub_27CEC(), !strcmp(v32, "HHB68602"))
                                    || (v33 = (const char *)sub_27CEC(), !strcmp(v33, "HHB56611"))
                                    || (v34 = (const char *)sub_27CEC(), !strcmp(v34, "HHB68503")) )
                                  {
LABEL_46:
                                    v7 -= 25;
                                  }
                                }
                                if ( a3 )
                                  goto LABEL_12;
                              }
                            }
                            v20 += 8;
                            if ( v20 == 320 )
                            {
                              if ( (unsigned int)off_BC5EC > 4 )
                              {
                                strcpy(s, "freq level not match");
                                sub_41DB8(4, s, 0);
                              }
                              return -2;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ( dword_BDC34 <= v6 && dword_BDC3C >= v6 && dword_BDC38 <= v7 && dword_BDC40 >= v7 )
    {
      if ( dword_C351C == 3 )
        v7 -= 25;
      if ( a3 )
      {
LABEL_12:
        *a3 = v7;
        return 0;
      }
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(s, "freq level out of range");
      sub_41DB8(4, s, 0);
      return -2;
    }
    else
    {
      return -2;
    }
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "No work mode freq, chain = %d, mode = %d.\n", a1, a2);
      sub_41DB8(4, s, 0);
    }
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC34: using guessed type int dword_BDC34;
// BDC38: using guessed type int dword_BDC38;
// BDC3C: using guessed type int dword_BDC3C;
// BDC40: using guessed type int dword_BDC40;
// BDC44: using guessed type int dword_BDC44;
// C351C: using guessed type int dword_C351C;

//----- (0001C4E8) --------------------------------------------------------
int __fastcall sub_1C4E8(int a1, int a2)
{
  int v4; // r5
  int v5; // r0
  unsigned int v6; // r8
  int v7; // r3
  unsigned int v8; // r4
  int v9; // t1
  const char *v10; // r0
  int v11; // r9
  _DWORD *v12; // r7
  unsigned int v13; // r6
  int v14; // r4
  const char *v16; // r0
  const char *v17; // r0
  int v18; // r4
  _DWORD *v19; // r6
  int v20; // r4
  unsigned int v21; // r3
  unsigned int v22; // r3
  const char *v23; // r0
  const char *v24; // r0
  int v25; // [sp+4h] [bp-2084h] BYREF
  char s[128]; // [sp+8h] [bp-2080h] BYREF
  char v27[8192]; // [sp+88h] [bp-2000h] BYREF

  memset(s, 0, sizeof(s));
  v25 = 128;
  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    if ( a2 )
    {
      v4 = *(_DWORD *)(dword_BDC44 + 4 * a1);
      if ( (*(int (__fastcall **)(int))(v4 + 24))(v4) == 5 )
      {
        *(_WORD *)a2 = (*(int (__fastcall **)(int))(v4 + 244))(v4);
        v19 = (_DWORD *)(a2 + 8);
        *(_WORD *)(a2 + 2) = (*(int (__fastcall **)(int))(v4 + 252))(v4);
        v20 = 0;
        *(_BYTE *)(a2 + 4) = (*(int (__fastcall **)(int))(v4 + 260))(v4);
        *(_BYTE *)(a2 + 1032) = (*(int (__fastcall **)(int))(v4 + 276))(v4) == 1;
        (*(void (__fastcall **)(int, char *, int *))(v4 + 268))(v4, s, &v25);
        do
        {
          v21 = (unsigned __int8)s[v20 >> 1];
          if ( (v20 & 1) != 0 )
            v22 = v21 >> 4;
          else
            v22 = v21 & 0xF;
          if ( *(_WORD *)(a2 + 2) )
            *v19 = *(unsigned __int16 *)(a2 + 2) + *(unsigned __int8 *)(a2 + 4) * v22;
          else
            *v19 = (*(int (**)(void))(v4 + 196))();
          ++v20;
          ++v19;
        }
        while ( v20 != 256 );
      }
      else if ( (*(int (__fastcall **)(int))(v4 + 24))(v4) == 4 )
      {
        v18 = a2 + 4;
        do
        {
          *(_DWORD *)(v18 + 4) = (*(int (__fastcall **)(int))(v4 + 196))(v4);
          v18 += 4;
        }
        while ( v18 != a2 + 1028 );
      }
      v5 = sub_27D1C();
      v6 = v5;
      if ( v5 )
      {
        v7 = a2 + 4;
        v8 = 0;
        do
        {
          v9 = *(_DWORD *)(v7 + 4);
          v7 += 4;
          v8 += v9;
        }
        while ( a2 + 4 + 4 * v5 != v7 );
        v10 = (const char *)sub_27CEC();
        if ( !strcmp(v10, "HHB68701") || (v16 = (const char *)sub_27CEC(), !strcmp(v16, "HHB68703")) )
        {
          v11 = 10;
          goto LABEL_11;
        }
LABEL_21:
        v17 = (const char *)sub_27CEC();
        if ( !strcmp(v17, "HHB68704") )
          v11 = 10;
        else
          v11 = 5;
        if ( !v6 )
          return 0;
LABEL_11:
        v12 = (_DWORD *)(a2 + 8);
        v13 = sub_962A0(v8, v6);
        v14 = 0;
        do
        {
          ++v14;
          if ( v13 > (*(int (__fastcall **)(int))(v4 + 196))(v4)
            && v13 < (*(int (__fastcall **)(int))(v4 + 196))(v4) + v11 )
          {
            *v12 += v11 - v13 + (*(int (__fastcall **)(int))(v4 + 196))(v4);
          }
          ++v12;
        }
        while ( v6 != v14 );
        return 0;
      }
      v23 = (const char *)sub_27CEC();
      if ( strcmp(v23, "HHB68701") )
      {
        v24 = (const char *)sub_27CEC();
        if ( strcmp(v24, "HHB68703") )
        {
          v8 = 0;
          goto LABEL_21;
        }
      }
    }
    return 0;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v27, 0x2000u, "eeprom is not init, chain = %d\n", a1);
    sub_41DB8(4, v27, 0);
  }
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001CAAC) --------------------------------------------------------
int __fastcall sub_1CAAC(int a1, int a2, int *a3)
{
  unsigned __int8 v3; // r6
  int v4; // r5
  int v6; // r7
  int v7; // r9
  const char *v8; // r0
  _BOOL4 v9; // r5
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  int v21; // r2
  int v22; // r0
  char *v23; // r1
  int v24; // r1
  bool v25; // r3
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v3 = a1;
  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    v4 = *(_DWORD *)(dword_BDC44 + 4 * a1);
    v6 = (*(int (__fastcall **)(int))(v4 + 188))(v4);
    v7 = (*(int (__fastcall **)(int))(v4 + 196))(v4);
    if ( sub_29C30() && sub_29C50() )
    {
      v7 = sub_29D50(v3);
      v6 = sub_29D38(v3);
    }
    v8 = (const char *)sub_27CEC();
    if ( strcmp(v8, "HHB68502") )
    {
      v11 = (const char *)sub_27CEC();
      if ( strcmp(v11, "HHB68501") )
      {
        v12 = (const char *)sub_27CEC();
        if ( strcmp(v12, "HHB68701") )
        {
          v13 = (const char *)sub_27CEC();
          if ( strcmp(v13, "HHB68704") )
          {
            v14 = (const char *)sub_27CEC();
            if ( strcmp(v14, "HHB68703") )
            {
              v15 = (const char *)sub_27CEC();
              if ( strcmp(v15, "H6HB68702") )
              {
                v16 = (const char *)sub_27CEC();
                if ( strcmp(v16, "H1HB68601") )
                {
                  v17 = (const char *)sub_27CEC();
                  if ( strcmp(v17, "HHB68601") )
                  {
                    v18 = (const char *)sub_27CEC();
                    if ( strcmp(v18, "HHB68602") )
                    {
                      v19 = (const char *)sub_27CEC();
                      if ( strcmp(v19, "HHB56611") )
                      {
                        v20 = (const char *)sub_27CEC();
                        if ( strcmp(v20, "HHB68503") )
                        {
                          v21 = 0;
                          while ( 1 )
                          {
                            v22 = *(_DWORD *)((char *)&unk_BDAF4 + v21);
                            v23 = (char *)&unk_BDAF4 + v21;
                            v21 += 8;
                            if ( v22 )
                            {
                              v24 = *((_DWORD *)v23 + 1);
                              v25 = v22 == v6;
                              if ( !a3 )
                                v25 = 0;
                              if ( !v24 )
                                v25 = 0;
                              if ( v24 == v7 && v25 )
                                break;
                            }
                            if ( v21 == 320 )
                            {
                              if ( (unsigned int)off_BC5EC > 4 )
                              {
                                strcpy(s, "voltage level not match");
                                sub_41DB8(4, s, 0);
                              }
                              return -2;
                            }
                          }
                          goto LABEL_38;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ( dword_BDC34 <= v6 && dword_BDC3C >= v6 && dword_BDC38 <= v7 )
    {
      v9 = dword_BDC40 >= v7;
      if ( !a3 )
        v9 = 0;
      if ( v9 )
      {
LABEL_38:
        *a3 = v6;
        return 0;
      }
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(s, "voltage level out of range");
      sub_41DB8(4, s, 0);
      return -2;
    }
    else
    {
      return -2;
    }
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "No work mode voltage, chain = %d, mode = %d.\n", a1, a2);
      sub_41DB8(4, s, 0);
    }
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC34: using guessed type int dword_BDC34;
// BDC38: using guessed type int dword_BDC38;
// BDC3C: using guessed type int dword_BDC3C;
// BDC40: using guessed type int dword_BDC40;
// BDC44: using guessed type int dword_BDC44;

//----- (0001CDF0) --------------------------------------------------------
int __fastcall sub_1CDF0(int a1, int *a2)
{
  int v3; // r0
  int v4; // r3
  char v6[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    if ( !a2 )
      return -2;
    v3 = (*(int (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * a1) + 236))();
    v4 = 0;
    *a2 = v3;
    return v4;
  }
  if ( (unsigned int)off_BC5EC <= 4 )
    return -1;
  snprintf(v6, 0x2000u, "No test standard, chain = %d.\n", a1);
  sub_41DB8(4, v6, 0);
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001CE9C) --------------------------------------------------------
int __fastcall sub_1CE9C(int a1, int *a2)
{
  int v3; // r0
  int v4; // r3
  char v6[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    if ( !a2 )
      return -2;
    v3 = (*(int (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * a1) + 84))();
    v4 = 0;
    *a2 = v3;
    return v4;
  }
  if ( (unsigned int)off_BC5EC <= 4 )
    return -1;
  snprintf(v6, 0x2000u, "No chip bin, chain = %d\n", a1);
  sub_41DB8(4, v6, 0);
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001CF48) --------------------------------------------------------
int __fastcall sub_1CF48(int a1, char *a2, unsigned int a3)
{
  char v6[20]; // [sp+4h] [bp-2018h] BYREF
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  memset(v6, 0, sizeof(v6));
  if ( !dword_BDC44 || !*(_BYTE *)(dword_BDC44 + 28) )
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "No ft ver, chain = %d\n", a1);
      sub_41DB8(4, s, 0);
    }
    return -1;
  }
  if ( !a2 || (*(int (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * a1) + 68))() )
    return -1;
  if ( a3 <= 0x15 )
    return -2;
  strcpy(a2, v6);
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001D048) --------------------------------------------------------
int __fastcall sub_1D048(int a1, int a2, int *a3)
{
  int v4; // r0
  int v5; // r3
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    if ( !a3 )
      return 0;
    v4 = (*(int (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * a1) + 204))();
    v5 = 0;
    *a3 = v4;
    return v5;
  }
  if ( (unsigned int)off_BC5EC <= 4 )
    return 0xFFFF;
  snprintf(s, 0x2000u, "No work mode hash rate, chain = %d, mode = %d.\n", a1, a2);
  sub_41DB8(4, s, 0);
  return 0xFFFF;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001D104) --------------------------------------------------------
int __fastcall sub_1D104(int a1, int a2)
{
  int v3; // [sp+4h] [bp-2018h]
  int v4; // [sp+8h] [bp-2014h]
  int v5; // [sp+Ch] [bp-2010h]
  int v6; // [sp+10h] [bp-200Ch]
  int v7; // [sp+14h] [bp-2008h]
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v3 = 0;
  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    if ( a2 )
      (*(int (**)(void))(*(_DWORD *)(dword_BDC44 + 4 * a1) + 172))();
  }
  else if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "No board name, chain = %d\n", a1);
    sub_41DB8(4, s, 0);
  }
  return -1;
}
// 1D188: conditional instruction was optimized away because %var_2018.1==0
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001D210) --------------------------------------------------------
int sub_1D210()
{
  return -1;
}

//----- (0001D218) --------------------------------------------------------
int sub_1D218()
{
  return -1;
}

//----- (0001D220) --------------------------------------------------------
int __fastcall sub_1D220(unsigned int a1, int a2)
{
  int v4; // r5
  int v5; // r9
  void (__fastcall *v6)(int, char *, int *, int *); // r10
  int v7; // r0
  void (__fastcall *v8)(int, char *, unsigned int *, int *); // r5
  _DWORD *v9; // r0
  int v11; // [sp+8h] [bp-2010h] BYREF
  unsigned int v12; // [sp+Ch] [bp-200Ch] BYREF
  int v13; // [sp+10h] [bp-2008h] BYREF
  int v14; // [sp+14h] [bp-2004h] BYREF
  char s[8192]; // [sp+18h] [bp-2000h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    v4 = *(_DWORD *)(dword_BDC44 + 4 * a1);
    v5 = (*(int (__fastcall **)(int))(v4 + 188))(v4);
    (*(void (__fastcall **)(int, _DWORD))(v4 + 192))(v4, (unsigned __int16)a2);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "eeprom_set_voltage, chain = %d, pre voltage = %d, new voltage = %d.\n", a1, v5, a2);
      sub_41DB8(3, s, 0);
    }
    v6 = *(void (__fastcall **)(int, char *, int *, int *))(v4 + 12);
    v11 = 256;
    v6(v4, s, &v11, &v13);
    v7 = v4;
    v8 = *(void (__fastcall **)(int, char *, unsigned int *, int *))(v4 + 16);
    v12 = 256 - v11;
    v8(v7, &s[v11], &v12, &v14);
    v9 = sub_1D700((int)s, 256);
    if ( v9 )
      ((void (*)(void))v9[71])();
    if ( v5 != a2 )
      sub_61DD8(a1, v14, (int)&s[v14], v12);
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "eeprom_set_voltage, chain = %d, voltage = %d.\n", a1, a2);
      sub_41DB8(4, s, 0);
    }
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001D3AC) --------------------------------------------------------
int __fastcall sub_1D3AC(unsigned int a1, int a2)
{
  int v4; // r5
  int v5; // r9
  void (__fastcall *v6)(int, char *, int *, int *); // r10
  int v7; // r0
  void (__fastcall *v8)(int, char *, unsigned int *, int *); // r5
  _DWORD *v9; // r0
  int v11; // [sp+8h] [bp-2010h] BYREF
  unsigned int v12; // [sp+Ch] [bp-200Ch] BYREF
  int v13; // [sp+10h] [bp-2008h] BYREF
  int v14; // [sp+14h] [bp-2004h] BYREF
  char s[8192]; // [sp+18h] [bp-2000h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    v4 = *(_DWORD *)(dword_BDC44 + 4 * a1);
    v5 = (*(int (__fastcall **)(int))(v4 + 196))(v4);
    (*(void (__fastcall **)(int, _DWORD))(v4 + 200))(v4, (unsigned __int16)a2);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "eeprom_set_freq, chain = %d, pre freq = %d, new freq = %d.\n", a1, v5, a2);
      sub_41DB8(3, s, 0);
    }
    v6 = *(void (__fastcall **)(int, char *, int *, int *))(v4 + 12);
    v11 = 256;
    v6(v4, s, &v11, &v13);
    v7 = v4;
    v8 = *(void (__fastcall **)(int, char *, unsigned int *, int *))(v4 + 16);
    v12 = 256 - v11;
    v8(v7, &s[v11], &v12, &v14);
    v9 = sub_1D700((int)s, 256);
    if ( v9 )
      ((void (*)(void))v9[71])();
    if ( v5 != a2 )
      sub_61DD8(a1, v14, (int)&s[v14], v12);
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "eeprom_set_freq, chain = %d, freq = %d.\n", a1, a2);
      sub_41DB8(4, s, 0);
    }
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001D538) --------------------------------------------------------
int __fastcall sub_1D538(unsigned int a1, int a2)
{
  int v4; // r5
  int v5; // r9
  void (__fastcall *v6)(int, char *, int *, int *); // r10
  int v7; // r0
  void (__fastcall *v8)(int, char *, unsigned int *, int *); // r5
  _DWORD *v9; // r0
  int v11; // [sp+8h] [bp-2010h] BYREF
  unsigned int v12; // [sp+Ch] [bp-200Ch] BYREF
  int v13; // [sp+10h] [bp-2008h] BYREF
  int v14; // [sp+14h] [bp-2004h] BYREF
  char s[8192]; // [sp+18h] [bp-2000h] BYREF

  if ( dword_BDC44 && *(_BYTE *)(dword_BDC44 + 28) )
  {
    v4 = *(_DWORD *)(dword_BDC44 + 4 * a1);
    v5 = (*(int (__fastcall **)(int))(v4 + 156))(v4);
    (*(void (__fastcall **)(int, _DWORD))(v4 + 160))(v4, (unsigned __int8)a2);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "eeprom_set_pt2_result, chain = %d, pre_pt2_result = %d, pt2_result = %d.\n", a1, v5, a2);
      sub_41DB8(3, s, 0);
    }
    v6 = *(void (__fastcall **)(int, char *, int *, int *))(v4 + 12);
    v11 = 256;
    v6(v4, s, &v11, &v13);
    v7 = v4;
    v8 = *(void (__fastcall **)(int, char *, unsigned int *, int *))(v4 + 16);
    v12 = 256 - v11;
    v8(v7, &s[v11], &v12, &v14);
    v9 = sub_1D700((int)s, 256);
    if ( v9 )
      ((void (*)(void))v9[71])();
    if ( v5 != a2 )
      sub_61DD8(a1, v14, (int)&s[v14], v12);
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "eeprom_set_pt2_result, chain = %d, pt2_result = %d.\n", a1, a2);
      sub_41DB8(4, s, 0);
    }
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC44: using guessed type int dword_BDC44;

//----- (0001D6C8) --------------------------------------------------------
int __fastcall sub_1D6C8(unsigned int a1)
{
  unsigned int v1; // r3
  int result; // r0

  if ( !dword_BDC44 || a1 > 4 )
    return 0;
  v1 = dword_BDC44 + a1;
  result = *(unsigned __int8 *)(dword_BDC44 + a1 + 16);
  if ( *(_BYTE *)(v1 + 16) )
    return 1;
  return result;
}
// BDC44: using guessed type int dword_BDC44;

//----- (0001D700) --------------------------------------------------------
_DWORD *__fastcall sub_1D700(int a1, int a2)
{
  _DWORD *(*v2)(); // r3
  int i; // r9
  _DWORD *v6; // r4
  int v7; // r5
  int v8; // r5
  bool v9; // zf
  char v11[8192]; // [sp+0h] [bp-2000h] BYREF

  v2 = sub_1F5D4;
  for ( i = 0; ; i = 1 )
  {
    v6 = v2();
    v7 = ((int (__fastcall *)(_DWORD *, int, int, int))*v6)(v6, a1, a2, 6);
    v8 = v7 | ((int (__fastcall *)(_DWORD *, int, int, int))*v6)(v6, a1, a2, 8);
    if ( v8 >= 0 && (v8 & 6) == 6 )
      break;
    ((void (__fastcall *)(_DWORD *))v6[72])(v6);
    v9 = i == 1;
    v2 = sub_2132C;
    if ( v9 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        memset(v11, 0, sizeof(v11));
        strcpy(v11, "got nothing\n\n");
        sub_42CB4(3, v11, 0);
        return 0;
      }
      return 0;
    }
  }
  return v6;
}
// 98278: using guessed type __int16 word_98278;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001D7FC) --------------------------------------------------------
_DWORD *__fastcall sub_1D7FC(int a1)
{
  _DWORD *v2; // r4
  void (__fastcall *v3)(_DWORD *); // r3
  _DWORD *v4; // r0

  v2 = sub_1F5D4();
  if ( a1 != ((int (*)(void))v2[6])() )
  {
    ((void (__fastcall *)(_DWORD *))v2[72])(v2);
    v2 = sub_2132C();
    if ( a1 != ((int (*)(void))v2[6])() )
    {
      v3 = (void (__fastcall *)(_DWORD *))v2[72];
      v4 = v2;
      v2 = 0;
      v3(v4);
    }
  }
  return v2;
}

//----- (0001D858) --------------------------------------------------------
int __fastcall sub_1D858(int a1)
{
  return **(unsigned __int8 **)(a1 + 292);
}

//----- (0001D864) --------------------------------------------------------
int __fastcall sub_1D864(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 1) >> 4;
}

//----- (0001D874) --------------------------------------------------------
int __fastcall sub_1D874(int a1, char a2)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 292) + 1) &= 0xFu;
  *(_BYTE *)(*(_DWORD *)(a1 + 292) + 1) |= 16 * a2;
  return 0;
}

//----- (0001D8A0) --------------------------------------------------------
int __fastcall sub_1D8A0(int a1)
{
  return *(_BYTE *)(*(_DWORD *)(a1 + 292) + 1) & 0xF;
}

//----- (0001D8B0) --------------------------------------------------------
int __fastcall sub_1D8B0(int a1, char a2)
{
  int v2; // r12

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 1) &= 0xF0u;
  *(_BYTE *)(*(_DWORD *)(a1 + 292) + 1) |= a2 & 0xF;
  return 0;
}

//----- (0001D8E0) --------------------------------------------------------
int sub_1D8E0()
{
  return 14;
}

//----- (0001D8E8) --------------------------------------------------------
int __fastcall sub_1D8E8(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 37);
}

//----- (0001D8F4) --------------------------------------------------------
int __fastcall sub_1D8F4(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 37) = a2;
  return 0;
}

//----- (0001D904) --------------------------------------------------------
int __fastcall sub_1D904(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 52);
}

//----- (0001D910) --------------------------------------------------------
int __fastcall sub_1D910(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 52) = a2;
  return 0;
}

//----- (0001D920) --------------------------------------------------------
int __fastcall sub_1D920(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 95);
}

//----- (0001D92C) --------------------------------------------------------
int __fastcall sub_1D92C(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 95) = a2;
  return 0;
}

//----- (0001D93C) --------------------------------------------------------
int __fastcall sub_1D93C(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 96);
}

//----- (0001D948) --------------------------------------------------------
int __fastcall sub_1D948(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 96) = a2;
  return 0;
}

//----- (0001D958) --------------------------------------------------------
int __fastcall sub_1D958(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 108);
}

//----- (0001D964) --------------------------------------------------------
int __fastcall sub_1D964(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 108) = a2;
  return 0;
}

//----- (0001D974) --------------------------------------------------------
int __fastcall sub_1D974(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 109);
}

//----- (0001D980) --------------------------------------------------------
int __fastcall sub_1D980(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 109) = a2;
  return 0;
}

//----- (0001D990) --------------------------------------------------------
int __fastcall sub_1D990(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 57);
}

//----- (0001D99C) --------------------------------------------------------
int __fastcall sub_1D99C(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 57) = a2;
  return 0;
}

//----- (0001D9AC) --------------------------------------------------------
int __fastcall sub_1D9AC(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 58);
}

//----- (0001D9B8) --------------------------------------------------------
int __fastcall sub_1D9B8(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 58) = a2;
  return 0;
}

//----- (0001D9C8) --------------------------------------------------------
int __fastcall sub_1D9C8(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 48);
}

//----- (0001D9D4) --------------------------------------------------------
int __fastcall sub_1D9D4(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 48) = a2;
  return 0;
}

//----- (0001D9E4) --------------------------------------------------------
int __fastcall sub_1D9E4(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 50);
}

//----- (0001D9F0) --------------------------------------------------------
int __fastcall sub_1D9F0(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 50) = a2;
  return 0;
}

//----- (0001DA00) --------------------------------------------------------
int __fastcall sub_1DA00(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 98);
}

//----- (0001DA0C) --------------------------------------------------------
int __fastcall sub_1DA0C(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 98) = a2;
  return 0;
}

//----- (0001DA1C) --------------------------------------------------------
int __fastcall sub_1DA1C(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 100);
}

//----- (0001DA28) --------------------------------------------------------
int __fastcall sub_1DA28(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 100) = a2;
  return 0;
}

//----- (0001DA38) --------------------------------------------------------
int __fastcall sub_1DA38(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 102);
}

//----- (0001DA44) --------------------------------------------------------
int __fastcall sub_1DA44(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 102) = a2;
  return 0;
}

//----- (0001DA54) --------------------------------------------------------
int __fastcall sub_1DA54(int a1)
{
  return *(char *)(*(_DWORD *)(a1 + 292) + 104);
}

//----- (0001DA60) --------------------------------------------------------
int __fastcall sub_1DA60(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 104) = a2;
  return 0;
}

//----- (0001DA70) --------------------------------------------------------
int __fastcall sub_1DA70(int a1)
{
  return *(char *)(*(_DWORD *)(a1 + 292) + 105);
}

//----- (0001DA7C) --------------------------------------------------------
int __fastcall sub_1DA7C(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 105) = a2;
  return 0;
}

//----- (0001DA8C) --------------------------------------------------------
int __fastcall sub_1DA8C(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 106);
}

//----- (0001DA98) --------------------------------------------------------
int __fastcall sub_1DA98(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 106) = a2;
  return 0;
}

//----- (0001DAA8) --------------------------------------------------------
int __fastcall sub_1DAA8(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 107);
}

//----- (0001DAB4) --------------------------------------------------------
int __fastcall sub_1DAB4(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 107) = a2;
  return 0;
}

//----- (0001DAC4) --------------------------------------------------------
int __fastcall sub_1DAC4(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 114);
}

//----- (0001DAD0) --------------------------------------------------------
int __fastcall sub_1DAD0(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 114) = a2;
  return 0;
}

//----- (0001DAE0) --------------------------------------------------------
int __fastcall sub_1DAE0(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 116);
}

//----- (0001DAEC) --------------------------------------------------------
int __fastcall sub_1DAEC(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 116) = a2;
  return 0;
}

//----- (0001DAFC) --------------------------------------------------------
int __fastcall sub_1DAFC(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 118);
}

//----- (0001DB08) --------------------------------------------------------
int __fastcall sub_1DB08(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 118) = a2;
  return 0;
}

//----- (0001DB18) --------------------------------------------------------
int __fastcall sub_1DB18(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 247);
}

//----- (0001DB24) --------------------------------------------------------
int __fastcall sub_1DB24(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 247) = a2;
  return 0;
}

//----- (0001DB34) --------------------------------------------------------
char *__fastcall sub_1DB34(int a1)
{
  void *v1; // r4
  unsigned __int8 *v2; // r7
  int v3; // r1
  int v4; // r2
  int v5; // r3
  char *result; // r0
  int v7; // r1
  unsigned __int8 *v8; // r8
  int v9; // r5
  int v11; // r3
  int v12; // r3
  int v13; // r1
  int v14; // r2
  unsigned __int8 v15; // r3
  int v16; // r1
  int v17; // r2
  __int16 v18; // r12
  int v19; // r1
  __int16 v20; // r2
  unsigned __int8 v21; // r3
  int v22; // r1
  unsigned __int8 v23; // r2
  int v24; // r1
  int v25; // r2
  int v26; // r3
  int v27; // r1
  _DWORD s[25]; // [sp+Ch] [bp-2068h] BYREF
  char v29[8196]; // [sp+70h] [bp-2004h] BYREF

  v1 = off_BC5EC;
  v2 = *(unsigned __int8 **)(a1 + 292);
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "board_info_version = %d\n", *v2);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "algorithm_and_key_version = 0x%x\n", v2[1]);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  memset(s, 0, sizeof(s));
  v12 = *(_DWORD *)(v2 + 14);
  v13 = *(_DWORD *)(v2 + 6);
  v14 = *(_DWORD *)(v2 + 10);
  s[0] = *(_DWORD *)(v2 + 2);
  s[1] = v13;
  s[2] = v14;
  s[3] = v12;
  LOWORD(s[4]) = *((_WORD *)v2 + 9);
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "board_sn = %s\n", (const char *)s);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  memset(s, 0, sizeof(s));
  v15 = v2[22];
  LOWORD(s[0]) = *((_WORD *)v2 + 10);
  BYTE2(s[0]) = v15;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "chip_die = %s\n", (const char *)s);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  memset(s, 0, sizeof(s));
  v16 = *(_DWORD *)(v2 + 27);
  v17 = *(_DWORD *)(v2 + 31);
  v18 = *(_WORD *)(v2 + 35);
  s[0] = *(_DWORD *)(v2 + 23);
  s[1] = v16;
  s[2] = v17;
  LOWORD(s[3]) = v18;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "chip_marking = %s\n", (const char *)s);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "chip_bin = %d\n", v2[37]);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  memset(s, 0, sizeof(s));
  v19 = *(_DWORD *)(v2 + 42);
  v20 = *((_WORD *)v2 + 23);
  s[0] = *(_DWORD *)(v2 + 38);
  s[1] = v19;
  LOWORD(s[2]) = v20;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "ft_version = %s\n", (const char *)s);
  sub_42CB4(3, v29, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "pcb_version = 0x%x\n", *((unsigned __int16 *)v2 + 24));
    sub_42CB4(3, v29, 0);
    v1 = off_BC5EC;
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_2;
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "bom_version = 0x%x\n", *((unsigned __int16 *)v2 + 25));
    sub_42CB4(3, v29, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_24;
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "asic_sensor_type = 0x%x\n", v2[52]);
    sub_42CB4(3, v29, 0);
    v1 = off_BC5EC;
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_2;
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "asic_sensor_addr[0] = 0x%x\n", v2[53]);
    sub_42CB4(3, v29, 0);
  }
  if ( (unsigned int)off_BC5EC <= 3 )
  {
LABEL_27:
    v1 = off_BC5EC;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(v29, 0, 0x2000u);
      snprintf(v29, 0x2000u, "pic_sensor_addr = 0x%x\n", v2[58]);
      sub_42CB4(3, v29, 0);
      v1 = off_BC5EC;
      goto LABEL_29;
    }
LABEL_2:
    memset(s, 0, sizeof(s));
    v3 = *(_DWORD *)(v2 + 75);
    v4 = *(_DWORD *)(v2 + 79);
    v5 = *(_DWORD *)(v2 + 83);
    s[0] = *(_DWORD *)(v2 + 71);
    s[1] = v3;
    s[2] = v4;
    s[3] = v5;
    result = *(char **)(v2 + 87);
    v7 = *(_DWORD *)(v2 + 91);
    s[4] = result;
    s[5] = v7;
    goto LABEL_3;
  }
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "asic_sensor_addr[1] = 0x%x\n", v2[54]);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "asic_sensor_addr[2] = 0x%x\n", v2[55]);
  sub_42CB4(3, v29, 0);
LABEL_24:
  v1 = off_BC5EC;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "asic_sensor_addr[3] = 0x%x\n", v2[56]);
    sub_42CB4(3, v29, 0);
    v1 = off_BC5EC;
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_2;
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "pic_sensor_type = 0x%x\n", v2[57]);
    sub_42CB4(3, v29, 0);
    goto LABEL_27;
  }
LABEL_29:
  memset(s, 0, sizeof(s));
  v21 = v2[61];
  LOWORD(s[0]) = *(_WORD *)(v2 + 59);
  BYTE2(s[0]) = v21;
  if ( (unsigned int)v1 <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "chip_tech = %s\n", (const char *)s);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  memset(s, 0, sizeof(s));
  v22 = *(_DWORD *)(v2 + 66);
  v23 = v2[70];
  s[0] = *(_DWORD *)(v2 + 62);
  s[1] = v22;
  LOBYTE(s[2]) = v23;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_2;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "board_name = %s\n", (const char *)s);
  sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  memset(s, 0, sizeof(s));
  v24 = *(_DWORD *)(v2 + 75);
  v25 = *(_DWORD *)(v2 + 79);
  v26 = *(_DWORD *)(v2 + 83);
  s[0] = *(_DWORD *)(v2 + 71);
  s[1] = v24;
  s[2] = v25;
  s[3] = v26;
  result = *(char **)(v2 + 87);
  v27 = *(_DWORD *)(v2 + 91);
  s[4] = result;
  s[5] = v27;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_3;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "factory_job = %s\n", (const char *)s);
  result = sub_42CB4(3, v29, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "board_info_crc = 0x%x\n", v2[97]);
    result = sub_42CB4(3, v29, 0);
    v1 = off_BC5EC;
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_3;
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "voltage = %d\n", *((unsigned __int16 *)v2 + 49));
    result = sub_42CB4(3, v29, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_40;
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "frequency = %d\n", *((unsigned __int16 *)v2 + 50));
    result = sub_42CB4(3, v29, 0);
    v1 = off_BC5EC;
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_3;
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "nonce_rate = %d\n", *((unsigned __int16 *)v2 + 51));
    result = sub_42CB4(3, v29, 0);
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_43;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "pcb_temp_in = %d\n", (char)v2[104]);
  result = sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_3;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "pcb_temp_out = %d\n", (char)v2[105]);
  result = sub_42CB4(3, v29, 0);
LABEL_40:
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_46;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "test_version = %d\n", v2[106]);
  result = sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_3;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "test_standard = %d\n", v2[107]);
  result = sub_42CB4(3, v29, 0);
LABEL_43:
  if ( (unsigned int)off_BC5EC <= 3 )
  {
LABEL_49:
    v1 = off_BC5EC;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(v29, 0, 0x2000u);
      snprintf(v29, 0x2000u, "pt2_count = %d\n", v2[109]);
      result = sub_42CB4(3, v29, 0);
      v1 = off_BC5EC;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        memset(v29, 0, 0x2000u);
        snprintf(v29, 0x2000u, "sweep_hashrate = %d\n", *((unsigned __int16 *)v2 + 57));
        result = sub_42CB4(3, v29, 0);
        goto LABEL_52;
      }
    }
    goto LABEL_3;
  }
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "param_info_crc = 0x%x\n", v2[113]);
  result = sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_3;
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "pt1_result = %d\n", v2[95]);
  result = sub_42CB4(3, v29, 0);
LABEL_46:
  if ( (unsigned int)off_BC5EC <= 3 )
  {
LABEL_52:
    v1 = off_BC5EC;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(v29, 0, 0x2000u);
      snprintf(v29, 0x2000u, "sweep_freq_base = %d\n", *((unsigned __int16 *)v2 + 58));
      result = sub_42CB4(3, v29, 0);
      v1 = off_BC5EC;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        memset(v29, 0, 0x2000u);
        snprintf(v29, 0x2000u, "sweep_freq_step = %d\n", v2[118]);
        result = sub_42CB4(3, v29, 0);
        v1 = off_BC5EC;
      }
    }
    goto LABEL_3;
  }
  memset(v29, 0, 0x2000u);
  snprintf(v29, 0x2000u, "pt1_count = %d\n", v2[96]);
  result = sub_42CB4(3, v29, 0);
  v1 = off_BC5EC;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "pt2_result = %d\n", v2[108]);
    result = sub_42CB4(3, v29, 0);
    goto LABEL_49;
  }
LABEL_3:
  v8 = v2 + 118;
  v9 = 0;
  do
  {
    while ( 1 )
    {
      if ( *++v8 )
      {
        if ( (unsigned int)v1 > 3 )
          break;
      }
      if ( ++v9 == 128 )
        goto LABEL_8;
    }
    memset(v29, 0, 0x2000u);
    v11 = v9++;
    snprintf(v29, 0x2000u, "sweep_level[%d] = %2x\n", v11, *v8);
    result = sub_42CB4(3, v29, 0);
    v1 = off_BC5EC;
  }
  while ( v9 != 128 );
LABEL_8:
  if ( (unsigned int)v1 > 3 )
  {
    memset(v29, 0, 0x2000u);
    snprintf(v29, 0x2000u, "sweep_result = 0x%x\n", v2[247]);
    result = sub_42CB4(3, v29, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(v29, 0, 0x2000u);
      snprintf(v29, 0x2000u, "sweep_info_crc = 0x%x\n", v2[249]);
      return sub_42CB4(3, v29, 0);
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001E734) --------------------------------------------------------
int __fastcall sub_1E734(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0x80 )
    v4 = 128;
  memcpy((void *)(v5 + 119), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001E764) --------------------------------------------------------
int __fastcall sub_1E764(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0x80 )
    v4 = 128;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 119), v4);
  *a3 = v4;
  return 0;
}

//----- (0001E798) --------------------------------------------------------
int __fastcall sub_1E798(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0x18 )
    v4 = 24;
  memcpy((void *)(v5 + 71), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001E7C8) --------------------------------------------------------
int __fastcall sub_1E7C8(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0x18 )
    v4 = 24;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 71), v4);
  *a3 = v4;
  return 0;
}

//----- (0001E7FC) --------------------------------------------------------
int __fastcall sub_1E7FC(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 9 )
    v4 = 9;
  memcpy((void *)(v5 + 62), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001E82C) --------------------------------------------------------
int __fastcall sub_1E82C(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 9 )
    v4 = 9;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 62), v4);
  *a3 = v4;
  return 0;
}

//----- (0001E860) --------------------------------------------------------
int __fastcall sub_1E860(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 4 )
    v4 = 4;
  memcpy((void *)(v5 + 53), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001E890) --------------------------------------------------------
int __fastcall sub_1E890(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 4 )
    v4 = 4;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 53), v4);
  *a3 = v4;
  return 0;
}

//----- (0001E8C4) --------------------------------------------------------
int __fastcall sub_1E8C4(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 3 )
    v4 = 3;
  memcpy((void *)(v5 + 59), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001E8F4) --------------------------------------------------------
int __fastcall sub_1E8F4(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 3 )
    v4 = 3;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 59), v4);
  *a3 = v4;
  return 0;
}

//----- (0001E928) --------------------------------------------------------
int __fastcall sub_1E928(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0xA )
    v4 = 10;
  memcpy((void *)(v5 + 38), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001E958) --------------------------------------------------------
int __fastcall sub_1E958(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0xA )
    v4 = 10;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 38), v4);
  *a3 = v4;
  return 0;
}

//----- (0001E98C) --------------------------------------------------------
int __fastcall sub_1E98C(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0xE )
    v4 = 14;
  memcpy((void *)(v5 + 23), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001E9BC) --------------------------------------------------------
int __fastcall sub_1E9BC(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0xE )
    v4 = 14;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 23), v4);
  *a3 = v4;
  return 0;
}

//----- (0001E9F0) --------------------------------------------------------
int __fastcall sub_1E9F0(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 3 )
    v4 = 3;
  memcpy((void *)(v5 + 20), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001EA20) --------------------------------------------------------
int __fastcall sub_1EA20(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 3 )
    v4 = 3;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 20), v4);
  *a3 = v4;
  return 0;
}

//----- (0001EA54) --------------------------------------------------------
int __fastcall sub_1EA54(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0x12 )
    v4 = 18;
  memcpy((void *)(v5 + 2), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0001EA84) --------------------------------------------------------
int __fastcall sub_1EA84(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0x12 )
    v4 = 18;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 2), v4);
  *a3 = v4;
  return 0;
}

//----- (0001EAB8) --------------------------------------------------------
int __fastcall sub_1EAB8(int a1, void *a2, int *a3, _DWORD *a4)
{
  int v4; // r4
  unsigned __int8 *v6; // r4
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v4 = *a3;
  if ( (unsigned int)*a3 <= 0x87 )
  {
    if ( (unsigned int)off_BC5EC > 2 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "INPUT too short %u<%u\n", v4, 136);
      sub_42CB4(2, s, 0);
    }
    return -1;
  }
  v6 = *(unsigned __int8 **)(a1 + 292);
  v6[249] = sub_459C8(v6 + 114, 1080);
  memcpy(a2, v6 + 114, 0x88u);
  if ( sub_2150C((int)a2, 136, v6[1] >> 4, v6[1] & 0xF) )
  {
    *a3 = 136;
    *a4 = 114;
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 2 )
      return -1;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%s: data_enc error\n", "edf_v4_region_3_encode");
    sub_42CB4(2, s, 0);
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001EC04) --------------------------------------------------------
int __fastcall sub_1EC04(int a1, _DWORD *a2, int *a3, _DWORD *a4)
{
  int v4; // r5
  int v6; // r7
  char v10; // r0
  int v11; // r2
  int v12; // r0
  int v13; // r3
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v4 = *a3;
  if ( (unsigned int)*a3 <= 0xF )
  {
    if ( (unsigned int)off_BC5EC > 2 )
    {
      memset(s, 0, sizeof(s));
      snprintf(s, 0x2000u, "INPUT too short %u<%u\n", v4, 16);
      sub_42CB4(2, s, 0);
    }
    return -1;
  }
  v6 = *(_DWORD *)(a1 + 292);
  v10 = sub_459C8((_BYTE *)(v6 + 98), 120);
  v11 = *(_DWORD *)(v6 + 106);
  *(_BYTE *)(v6 + 113) = v10;
  v12 = *(_DWORD *)(v6 + 98);
  v13 = *(_DWORD *)(v6 + 110);
  a2[1] = *(_DWORD *)(v6 + 102);
  *a2 = v12;
  a2[3] = v13;
  a2[2] = v11;
  if ( sub_2150C((int)a2, 16, *(unsigned __int8 *)(v6 + 1) >> 4, *(_BYTE *)(v6 + 1) & 0xF) )
  {
    *a3 = 16;
    *a4 = 98;
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 2 )
      return -1;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "%s: data_enc error\n", "edf_v4_region_2_encode");
    sub_42CB4(2, s, 0);
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001ED60) --------------------------------------------------------
int __fastcall sub_1ED60(int a1, _WORD *a2, int *a3, _DWORD *a4)
{
  int v4; // r5
  _BYTE *v9; // r5
  _BYTE dest[256]; // [sp+8h] [bp-2104h] BYREF
  char s[8196]; // [sp+108h] [bp-2004h] BYREF

  v4 = *a3;
  if ( (unsigned int)*a3 <= 0x61 )
  {
    if ( (unsigned int)off_BC5EC > 2 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "INPUT too short %u<%u\n", v4, 98);
      sub_42CB4(2, s, 0);
    }
    return -1;
  }
  v9 = *(_BYTE **)(a1 + 292);
  if ( (unsigned int)off_BC5EC > 4 )
  {
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "BOARD_CRC_DATA_LEN=%d\n", 97);
    sub_42CB4(4, s, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "BOARD_ENC_DATA_START=%d\n", 2);
      sub_42CB4(4, s, 0);
      if ( (unsigned int)off_BC5EC <= 4 )
        goto LABEL_6;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "BOARD_ENC_DATA_LEN=%d\n", 96);
      sub_42CB4(4, s, 0);
      if ( (unsigned int)off_BC5EC <= 4 )
        goto LABEL_6;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "PARAM_CRC_DATA_START=%d\n", 98);
      sub_42CB4(4, s, 0);
      if ( (unsigned int)off_BC5EC <= 4 )
        goto LABEL_6;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "PARAM_CRC_DATA_LEN=%d\n", 15);
      sub_42CB4(4, s, 0);
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "PARAM_ENC_DATA_START=%d\n", 98);
      sub_42CB4(4, s, 0);
      if ( (unsigned int)off_BC5EC > 4 )
      {
        memset(s, 0, 0x2000u);
        snprintf(s, 0x2000u, "PARAM_ENC_DATA_LEN=%d\n", 16);
        sub_42CB4(4, s, 0);
      }
    }
  }
LABEL_6:
  v9[97] = sub_459C8(v9, 776);
  memcpy(dest, v9 + 2, 0x60u);
  if ( sub_2150C((int)dest, 96, (unsigned __int8)v9[1] >> 4, v9[1] & 0xF) )
  {
    *a2 = *(_WORD *)v9;
    memcpy(a2 + 1, dest, 0x60u);
    *a3 = 98;
    *a4 = 0;
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 2 )
      return -1;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%s: data_enc error\n", "edf_v4_region_1_encode");
    sub_42CB4(2, s, 0);
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001F09C) --------------------------------------------------------
int __fastcall sub_1F09C(int a1, unsigned __int8 *src, size_t n, unsigned int a4)
{
  unsigned __int8 *v5; // r5
  int v6; // r4
  int v7; // r7
  int v9; // r10
  int v10; // r11
  int v11; // r4
  int v13; // r0
  const char *v14; // r4
  const char *v15; // r12
  int v16; // r0
  int v17; // r1
  int v18; // r2
  int v19; // r3
  _DWORD *v20; // r12
  int v21; // r1
  int v22; // r2
  int v23; // r12
  int v24; // r3
  int v25; // r0
  int v26; // r12
  int v27; // r0
  int v28; // r2
  int v29; // r3
  int v30; // r0
  _BYTE dest[2]; // [sp+8h] [bp-2104h] BYREF
  _BYTE v32[96]; // [sp+Ah] [bp-2102h] BYREF
  int v33; // [sp+6Ah] [bp-20A2h] BYREF
  int v34; // [sp+6Eh] [bp-209Eh]
  int v35; // [sp+72h] [bp-209Ah]
  int v36; // [sp+76h] [bp-2096h]
  _BYTE v37[142]; // [sp+7Ah] [bp-2092h] BYREF
  _DWORD s[2049]; // [sp+108h] [bp-2004h] BYREF

  v5 = *(unsigned __int8 **)(a1 + 292);
  v6 = *src;
  if ( *v5 == v6 )
  {
    if ( (a4 & 0xE) == 0 )
    {
      if ( (unsigned int)off_BC5EC > 2 )
      {
        v7 = -1;
        memset(s, 0, 0x2000u);
        strcpy((char *)s, "flag invalid\n");
        sub_42CB4(2, (const char *)s, 0);
        return v7;
      }
      return -1;
    }
    v7 = a4 & 2;
    if ( ((n <= 0x61) & (a4 >> 1)) != 0 )
    {
      if ( (unsigned int)off_BC5EC <= 2 )
        return -1;
      memset(s, 0, 0x2000u);
      v15 = "region1 len invalid\n";
    }
    else
    {
      v9 = a4 & 4;
      if ( ((n <= 0x71) & (a4 >> 2)) != 0 )
      {
        if ( (unsigned int)off_BC5EC <= 2 )
          return -1;
        memset(s, 0, 0x2000u);
        v15 = "region2 len invalid\n";
      }
      else
      {
        v10 = (a4 >> 3) & 1;
        v11 = a4 & 8;
        if ( n > 0xF9 )
          v10 = 0;
        if ( !v10 )
        {
          if ( n > 0x100 && (unsigned int)off_BC5EC > 2 )
          {
            memset(s, 0, 0x2000u);
            strcpy((char *)s, "len too large, should less than 256\n");
            sub_42CB4(2, (const char *)s, 0);
          }
          v5[1] = src[1];
          memcpy(dest, src, n);
          if ( v7 )
          {
            memcpy(v32, src + 2, sizeof(v32));
            if ( !sub_215C4((int)v32, 96, v5[1] >> 4, v5[1] & 0xF) )
            {
              v14 = "DEC 1ST REGION";
              v7 = -1;
              goto LABEL_26;
            }
            v30 = sub_459C8(dest, 776);
            if ( v32[95] != v30 )
            {
              v14 = "CRC 1ST REGION";
              v7 = -1;
              goto LABEL_26;
            }
            memcpy(v5 + 2, v32, 0x60u);
            if ( v5[95] != 1 )
            {
              v14 = "PT1 test NOT pass, redo it";
              v7 = -1;
              goto LABEL_26;
            }
            v7 = 2;
          }
          if ( !v9 )
          {
LABEL_17:
            if ( v11 )
            {
              memcpy(v37, src + 114, 0x88u);
              if ( sub_215C4((int)v37, 136, v5[1] >> 4, v5[1] & 0xF) )
              {
                v13 = sub_459C8(v37, 1080);
                if ( v37[135] == v13 )
                {
                  v7 |= 8u;
                  memcpy(v5 + 114, v37, 0x88u);
                }
              }
            }
            return v7;
          }
          v22 = *(_DWORD *)(src + 106);
          v23 = *(_DWORD *)(src + 102);
          v24 = *(_DWORD *)(src + 110);
          v33 = *(_DWORD *)(src + 98);
          v34 = v23;
          v36 = v24;
          v35 = v22;
          if ( sub_215C4((int)&v33, 16, v5[1] >> 4, v5[1] & 0xF) )
          {
            v25 = sub_459C8(&v33, 120);
            if ( HIBYTE(v36) == v25 )
            {
              v26 = v33;
              v27 = v34;
              v28 = v36;
              *(_DWORD *)(v5 + 106) = v35;
              v29 = v5[108];
              *(_DWORD *)(v5 + 98) = v26;
              *(_DWORD *)(v5 + 102) = v27;
              *(_DWORD *)(v5 + 110) = v28;
              if ( v29 == 1 )
              {
                v7 |= 4u;
                goto LABEL_17;
              }
              v14 = "PT2 test NOT pass, redo it";
            }
            else
            {
              v14 = "CRC 2ND REGION";
            }
          }
          else
          {
            v14 = "DEC 2ND REGION";
          }
LABEL_26:
          if ( (unsigned int)off_BC5EC > 2 )
          {
            memset(s, 0, 0x2000u);
            snprintf((char *)s, 0x2000u, "EEPROM error: %s\n", v14);
            sub_42CB4(2, (const char *)s, 0);
          }
          return v7;
        }
        if ( (unsigned int)off_BC5EC <= 2 )
          return -1;
        memset(s, 0, 0x2000u);
        v15 = "region3 len invalid\n";
      }
    }
    v16 = *(_DWORD *)v15;
    v17 = *((_DWORD *)v15 + 1);
    v18 = *((_DWORD *)v15 + 2);
    v19 = *((_DWORD *)v15 + 3);
    v20 = v15 + 16;
    v7 = -1;
    s[0] = v16;
    s[1] = v17;
    s[2] = v18;
    s[3] = v19;
    v21 = v20[1];
    s[4] = *v20;
    LOBYTE(s[5]) = v21;
    sub_42CB4(2, (const char *)s, 0);
    return v7;
  }
  if ( (unsigned int)off_BC5EC <= 2 )
    return -1;
  memset(s, 0, 0x2000u);
  snprintf((char *)s, 0x2000u, "version invalid %d!=%d\n", v6, *v5);
  sub_42CB4(2, (const char *)s, 0);
  return -1;
}
// 1F184: masking with 0x1 was optimized away because r11.4 <= 0x1
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001F534) --------------------------------------------------------
char *sub_1F534()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  memset(v1, 0, 0x2000u);
  strcpy(v1, "edf_v4_destroy: input arg wrong\n");
  return sub_42CB4(3, v1, 0);
}

//----- (0001F590) --------------------------------------------------------
void __fastcall sub_1F590(_DWORD *a1)
{
  void *v2; // r0

  if ( a1 && (v2 = (void *)a1[73]) != 0 )
  {
    free(v2);
    free(a1);
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    sub_1F534();
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0001F5D4) --------------------------------------------------------
_DWORD *sub_1F5D4()
{
  _DWORD *v0; // r4
  _WORD *v1; // r5

  v0 = malloc(0x128u);
  if ( v0 )
  {
    v1 = malloc(0xFAu);
    memset(v1 + 1, 0, 0xF8u);
    *v1 = 12548;
    memcpy(v0, &off_982C4, 0x128u);
    v0[73] = v1;
  }
  return v0;
}
// 982C4: using guessed type int (__fastcall *off_982C4)(int, void *src, size_t n);

//----- (0001F62C) --------------------------------------------------------
int __fastcall sub_1F62C(int a1)
{
  return **(unsigned __int8 **)(a1 + 292);
}

//----- (0001F638) --------------------------------------------------------
int __fastcall sub_1F638(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 1) >> 4;
}

//----- (0001F648) --------------------------------------------------------
int __fastcall sub_1F648(int a1, char a2)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 292) + 1) &= 0xFu;
  *(_BYTE *)(*(_DWORD *)(a1 + 292) + 1) |= 16 * a2;
  return 0;
}

//----- (0001F674) --------------------------------------------------------
int __fastcall sub_1F674(int a1)
{
  return *(_BYTE *)(*(_DWORD *)(a1 + 292) + 1) & 0xF;
}

//----- (0001F684) --------------------------------------------------------
int __fastcall sub_1F684(int a1, char a2)
{
  int v2; // r12

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 1) &= 0xF0u;
  *(_BYTE *)(*(_DWORD *)(a1 + 292) + 1) |= a2 & 0xF;
  return 0;
}

//----- (0001F6B4) --------------------------------------------------------
int sub_1F6B4()
{
  return 14;
}

//----- (0001F6BC) --------------------------------------------------------
int __fastcall sub_1F6BC(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 37);
}

//----- (0001F6C8) --------------------------------------------------------
int __fastcall sub_1F6C8(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 37) = a2;
  return 0;
}

//----- (0001F6D8) --------------------------------------------------------
int __fastcall sub_1F6D8(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 52);
}

//----- (0001F6E4) --------------------------------------------------------
int __fastcall sub_1F6E4(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 52) = a2;
  return 0;
}

//----- (0001F6F4) --------------------------------------------------------
int __fastcall sub_1F6F4(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 95);
}

//----- (0001F700) --------------------------------------------------------
int __fastcall sub_1F700(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 95) = a2;
  return 0;
}

//----- (0001F710) --------------------------------------------------------
int __fastcall sub_1F710(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 96);
}

//----- (0001F71C) --------------------------------------------------------
int __fastcall sub_1F71C(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 96) = a2;
  return 0;
}

//----- (0001F72C) --------------------------------------------------------
int __fastcall sub_1F72C(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 108);
}

//----- (0001F738) --------------------------------------------------------
int __fastcall sub_1F738(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 108) = a2;
  return 0;
}

//----- (0001F748) --------------------------------------------------------
int __fastcall sub_1F748(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 109);
}

//----- (0001F754) --------------------------------------------------------
int __fastcall sub_1F754(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 109) = a2;
  return 0;
}

//----- (0001F764) --------------------------------------------------------
int __fastcall sub_1F764(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 57);
}

//----- (0001F770) --------------------------------------------------------
int __fastcall sub_1F770(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 57) = a2;
  return 0;
}

//----- (0001F780) --------------------------------------------------------
int __fastcall sub_1F780(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 58);
}

//----- (0001F78C) --------------------------------------------------------
int __fastcall sub_1F78C(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 58) = a2;
  return 0;
}

//----- (0001F79C) --------------------------------------------------------
int __fastcall sub_1F79C(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 48);
}

//----- (0001F7A8) --------------------------------------------------------
int __fastcall sub_1F7A8(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 48) = a2;
  return 0;
}

//----- (0001F7B8) --------------------------------------------------------
int __fastcall sub_1F7B8(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 50);
}

//----- (0001F7C4) --------------------------------------------------------
int __fastcall sub_1F7C4(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 50) = a2;
  return 0;
}

//----- (0001F7D4) --------------------------------------------------------
int __fastcall sub_1F7D4(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 98);
}

//----- (0001F7E0) --------------------------------------------------------
int __fastcall sub_1F7E0(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 98) = a2;
  return 0;
}

//----- (0001F7F0) --------------------------------------------------------
int __fastcall sub_1F7F0(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 100);
}

//----- (0001F7FC) --------------------------------------------------------
int __fastcall sub_1F7FC(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 100) = a2;
  return 0;
}

//----- (0001F80C) --------------------------------------------------------
int __fastcall sub_1F80C(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 102);
}

//----- (0001F818) --------------------------------------------------------
int __fastcall sub_1F818(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 102) = a2;
  return 0;
}

//----- (0001F828) --------------------------------------------------------
int __fastcall sub_1F828(int a1)
{
  return *(char *)(*(_DWORD *)(a1 + 292) + 104);
}

//----- (0001F834) --------------------------------------------------------
int __fastcall sub_1F834(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 104) = a2;
  return 0;
}

//----- (0001F844) --------------------------------------------------------
int __fastcall sub_1F844(int a1)
{
  return *(char *)(*(_DWORD *)(a1 + 292) + 105);
}

//----- (0001F850) --------------------------------------------------------
int __fastcall sub_1F850(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 105) = a2;
  return 0;
}

//----- (0001F860) --------------------------------------------------------
int __fastcall sub_1F860(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 106);
}

//----- (0001F86C) --------------------------------------------------------
int __fastcall sub_1F86C(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 106) = a2;
  return 0;
}

//----- (0001F87C) --------------------------------------------------------
int __fastcall sub_1F87C(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 107);
}

//----- (0001F888) --------------------------------------------------------
int __fastcall sub_1F888(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 107) = a2;
  return 0;
}

//----- (0001F898) --------------------------------------------------------
int __fastcall sub_1F898(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 114);
}

//----- (0001F8A4) --------------------------------------------------------
int __fastcall sub_1F8A4(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 114) = a2;
  return 0;
}

//----- (0001F8B4) --------------------------------------------------------
int __fastcall sub_1F8B4(int a1)
{
  return *(unsigned __int16 *)(*(_DWORD *)(a1 + 292) + 116);
}

//----- (0001F8C0) --------------------------------------------------------
int __fastcall sub_1F8C0(int a1, __int16 a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_WORD *)(v2 + 116) = a2;
  return 0;
}

//----- (0001F8D0) --------------------------------------------------------
int __fastcall sub_1F8D0(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 118);
}

//----- (0001F8DC) --------------------------------------------------------
int __fastcall sub_1F8DC(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 118) = a2;
  return 0;
}

//----- (0001F8EC) --------------------------------------------------------
int __fastcall sub_1F8EC(int a1)
{
  return *(unsigned __int8 *)(*(_DWORD *)(a1 + 292) + 247);
}

//----- (0001F8F8) --------------------------------------------------------
int __fastcall sub_1F8F8(int a1, char a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(v2 + 247) = a2;
  return 0;
}

//----- (0001F908) --------------------------------------------------------
char *__fastcall sub_1F908(char *result)
{
  unsigned __int8 *v1; // r5
  int v2; // r3
  int v3; // r1
  int v4; // r2
  unsigned __int8 v5; // r3
  int v6; // r1
  int v7; // r2
  __int16 v8; // r12
  int v9; // r1
  __int16 v10; // r2
  void *v11; // r6
  unsigned __int8 v12; // r3
  int v13; // r1
  unsigned __int8 v14; // r2
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  void *v19; // r4
  _DWORD v20[32]; // [sp+0h] [bp-2080h] BYREF
  char s[8192]; // [sp+80h] [bp-2000h] BYREF

  v1 = (unsigned __int8 *)*((_DWORD *)result + 73);
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "board_info_version = %d\n", *v1);
  result = sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "algorithm_and_key_version = 0x%x\n", v1[1]);
  sub_42CB4(3, s, 0);
  memset(v20, 0, sizeof(v20));
  result = *(char **)(v1 + 2);
  v2 = *(_DWORD *)(v1 + 14);
  v3 = *(_DWORD *)(v1 + 6);
  v4 = *(_DWORD *)(v1 + 10);
  v20[0] = result;
  v20[1] = v3;
  v20[2] = v4;
  v20[3] = v2;
  LOWORD(v20[4]) = *((_WORD *)v1 + 9);
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "board_sn = %s\n", (const char *)v20);
  sub_42CB4(3, s, 0);
  result = (char *)memset(v20, 0, sizeof(v20));
  v5 = v1[22];
  LOWORD(v20[0]) = *((_WORD *)v1 + 10);
  BYTE2(v20[0]) = v5;
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "chip_die = %s\n", (const char *)v20);
  sub_42CB4(3, s, 0);
  memset(v20, 0, sizeof(v20));
  result = *(char **)(v1 + 23);
  v6 = *(_DWORD *)(v1 + 27);
  v7 = *(_DWORD *)(v1 + 31);
  v8 = *(_WORD *)(v1 + 35);
  v20[0] = result;
  v20[1] = v6;
  v20[2] = v7;
  LOWORD(v20[3]) = v8;
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "chip_marking = %s\n", (const char *)v20);
  result = sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "chip_bin = %d\n", v1[37]);
  sub_42CB4(3, s, 0);
  memset(v20, 0, sizeof(v20));
  result = *(char **)(v1 + 38);
  v9 = *(_DWORD *)(v1 + 42);
  v10 = *((_WORD *)v1 + 23);
  v20[0] = result;
  v20[1] = v9;
  LOWORD(v20[2]) = v10;
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "ft_version = %s\n", (const char *)v20);
  result = sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "pcb_version = 0x%x\n", *((unsigned __int16 *)v1 + 24));
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "bom_version = 0x%x\n", *((unsigned __int16 *)v1 + 25));
    sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_17;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "asic_sensor_type = 0x%x\n", v1[52]);
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "asic_sensor_addr[0] = 0x%x\n", v1[53]);
    result = sub_42CB4(3, s, 0);
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_20;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "asic_sensor_addr[1] = 0x%x\n", v1[54]);
  result = sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "asic_sensor_addr[2] = 0x%x\n", v1[55]);
  sub_42CB4(3, s, 0);
LABEL_17:
  v11 = off_BC5EC;
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_22;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "asic_sensor_addr[3] = 0x%x\n", v1[56]);
  result = sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "pic_sensor_type = 0x%x\n", v1[57]);
  result = sub_42CB4(3, s, 0);
LABEL_20:
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "pic_sensor_addr = 0x%x\n", v1[58]);
  sub_42CB4(3, s, 0);
  v11 = off_BC5EC;
LABEL_22:
  result = (char *)memset(v20, 0, sizeof(v20));
  v12 = v1[61];
  LOWORD(v20[0]) = *(_WORD *)(v1 + 59);
  BYTE2(v20[0]) = v12;
  if ( (unsigned int)v11 <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "chip_tech = %s\n", (const char *)v20);
  sub_42CB4(3, s, 0);
  memset(v20, 0, sizeof(v20));
  result = *(char **)(v1 + 62);
  v13 = *(_DWORD *)(v1 + 66);
  v14 = v1[70];
  v20[0] = result;
  v20[1] = v13;
  LOBYTE(v20[2]) = v14;
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "board_name = %s\n", (const char *)v20);
  sub_42CB4(3, s, 0);
  memset(v20, 0, sizeof(v20));
  v15 = *(_DWORD *)(v1 + 75);
  v16 = *(_DWORD *)(v1 + 79);
  v17 = *(_DWORD *)(v1 + 83);
  v20[0] = *(_DWORD *)(v1 + 71);
  v20[1] = v15;
  v20[2] = v16;
  v20[3] = v17;
  result = *(char **)(v1 + 87);
  v18 = *(_DWORD *)(v1 + 91);
  v20[4] = result;
  v20[5] = v18;
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "factory_job = %s\n", (const char *)v20);
  result = sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "board_info_crc = 0x%x\n", v1[97]);
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "voltage = %d\n", *((unsigned __int16 *)v1 + 49));
    sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_33;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "frequency = %d\n", *((unsigned __int16 *)v1 + 50));
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "nonce_rate = %d\n", *((unsigned __int16 *)v1 + 51));
    result = sub_42CB4(3, s, 0);
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_36;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "pcb_temp_in = %d\n", (char)v1[104]);
  result = sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "pcb_temp_out = %d\n", (char)v1[105]);
  sub_42CB4(3, s, 0);
LABEL_33:
  if ( (unsigned int)off_BC5EC <= 3 )
  {
LABEL_39:
    if ( (unsigned int)off_BC5EC <= 3 )
    {
      v19 = off_BC5EC;
LABEL_45:
      memset(v20, 0, sizeof(v20));
      result = (char *)memcpy(v20, v1 + 119, sizeof(v20));
      if ( (unsigned int)v19 > 3 )
      {
        memset(s, 0, sizeof(s));
        snprintf(s, 0x2000u, "sweep_result = %d\n", v1[247]);
        return sub_42CB4(3, s, 0);
      }
      return result;
    }
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "pt1_count = %d\n", v1[96]);
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "pt2_result = %d\n", v1[108]);
    result = sub_42CB4(3, s, 0);
    goto LABEL_42;
  }
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "test_version = %d\n", v1[106]);
  result = sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC <= 3 )
    return result;
  memset(s, 0, sizeof(s));
  snprintf(s, 0x2000u, "test_standard = %d\n", v1[107]);
  result = sub_42CB4(3, s, 0);
LABEL_36:
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "param_info_crc = 0x%x\n", v1[113]);
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "pt1_result = %d\n", v1[95]);
    sub_42CB4(3, s, 0);
    goto LABEL_39;
  }
LABEL_42:
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "pt2_count = %d\n", v1[109]);
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(s, 0, sizeof(s));
      snprintf(s, 0x2000u, "sweep_hashrate = %d\n", *((unsigned __int16 *)v1 + 57));
      sub_42CB4(3, s, 0);
      v19 = off_BC5EC;
      goto LABEL_45;
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00020398) --------------------------------------------------------
int __fastcall sub_20398(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0x80 )
    v4 = 128;
  memcpy((void *)(v5 + 119), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (000203C8) --------------------------------------------------------
int __fastcall sub_203C8(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0x80 )
    v4 = 128;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 119), v4);
  *a3 = v4;
  return 0;
}

//----- (000203FC) --------------------------------------------------------
int __fastcall sub_203FC(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0x18 )
    v4 = 24;
  memcpy((void *)(v5 + 71), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (0002042C) --------------------------------------------------------
int __fastcall sub_2042C(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0x18 )
    v4 = 24;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 71), v4);
  *a3 = v4;
  return 0;
}

//----- (00020460) --------------------------------------------------------
int __fastcall sub_20460(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 9 )
    v4 = 9;
  memcpy((void *)(v5 + 62), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (00020490) --------------------------------------------------------
int __fastcall sub_20490(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 9 )
    v4 = 9;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 62), v4);
  *a3 = v4;
  return 0;
}

//----- (000204C4) --------------------------------------------------------
int __fastcall sub_204C4(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 4 )
    v4 = 4;
  memcpy((void *)(v5 + 53), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (000204F4) --------------------------------------------------------
int __fastcall sub_204F4(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 4 )
    v4 = 4;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 53), v4);
  *a3 = v4;
  return 0;
}

//----- (00020528) --------------------------------------------------------
int __fastcall sub_20528(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 3 )
    v4 = 3;
  memcpy((void *)(v5 + 59), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (00020558) --------------------------------------------------------
int __fastcall sub_20558(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 3 )
    v4 = 3;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 59), v4);
  *a3 = v4;
  return 0;
}

//----- (0002058C) --------------------------------------------------------
int __fastcall sub_2058C(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0xA )
    v4 = 10;
  memcpy((void *)(v5 + 38), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (000205BC) --------------------------------------------------------
int __fastcall sub_205BC(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0xA )
    v4 = 10;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 38), v4);
  *a3 = v4;
  return 0;
}

//----- (000205F0) --------------------------------------------------------
int __fastcall sub_205F0(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0xE )
    v4 = 14;
  memcpy((void *)(v5 + 23), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (00020620) --------------------------------------------------------
int __fastcall sub_20620(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0xE )
    v4 = 14;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 23), v4);
  *a3 = v4;
  return 0;
}

//----- (00020654) --------------------------------------------------------
int __fastcall sub_20654(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 3 )
    v4 = 3;
  memcpy((void *)(v5 + 20), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (00020684) --------------------------------------------------------
int __fastcall sub_20684(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 3 )
    v4 = 3;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 20), v4);
  *a3 = v4;
  return 0;
}

//----- (000206B8) --------------------------------------------------------
int __fastcall sub_206B8(int a1, const void *a2, size_t *a3)
{
  size_t v4; // r4
  int v5; // r0

  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 292);
  if ( *a3 >= 0x12 )
    v4 = 18;
  memcpy((void *)(v5 + 2), a2, v4);
  *a3 = v4;
  return 0;
}

//----- (000206E8) --------------------------------------------------------
int __fastcall sub_206E8(int a1, void *dest, size_t *a3)
{
  size_t v4; // r4

  v4 = *a3;
  if ( *a3 >= 0x12 )
    v4 = 18;
  memcpy(dest, (const void *)(*(_DWORD *)(a1 + 292) + 2), v4);
  *a3 = v4;
  return 0;
}

//----- (0002071C) --------------------------------------------------------
int __fastcall sub_2071C(int a1, void *a2, int *a3, _DWORD *a4)
{
  int v4; // r4
  unsigned __int8 *v6; // r4
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v4 = *a3;
  if ( (unsigned int)*a3 <= 0x87 )
  {
    if ( (unsigned int)off_BC5EC > 2 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "INPUT too short %u<%u\n", v4, 136);
      sub_42CB4(2, s, 0);
    }
    return -1;
  }
  v6 = *(unsigned __int8 **)(a1 + 292);
  v6[249] = sub_459C8(v6 + 114, 1080);
  memcpy(a2, v6 + 114, 0x88u);
  if ( sub_2150C((int)a2, 136, v6[1] >> 4, v6[1] & 0xF) )
  {
    *a3 = 136;
    *a4 = 114;
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 2 )
      return -1;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%s: data_enc error\n", "edf_v5_region_3_encode");
    sub_42CB4(2, s, 0);
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00020868) --------------------------------------------------------
int __fastcall sub_20868(int a1, _DWORD *a2, int *a3, _DWORD *a4)
{
  int v4; // r5
  int v6; // r7
  char v10; // r0
  int v11; // r2
  int v12; // r0
  int v13; // r3
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v4 = *a3;
  if ( (unsigned int)*a3 <= 0xF )
  {
    if ( (unsigned int)off_BC5EC > 2 )
    {
      memset(s, 0, sizeof(s));
      snprintf(s, 0x2000u, "INPUT too short %u<%u\n", v4, 16);
      sub_42CB4(2, s, 0);
    }
    return -1;
  }
  v6 = *(_DWORD *)(a1 + 292);
  v10 = sub_459C8((_BYTE *)(v6 + 98), 120);
  v11 = *(_DWORD *)(v6 + 106);
  *(_BYTE *)(v6 + 113) = v10;
  v12 = *(_DWORD *)(v6 + 98);
  v13 = *(_DWORD *)(v6 + 110);
  a2[1] = *(_DWORD *)(v6 + 102);
  *a2 = v12;
  a2[3] = v13;
  a2[2] = v11;
  if ( sub_2150C((int)a2, 16, *(unsigned __int8 *)(v6 + 1) >> 4, *(_BYTE *)(v6 + 1) & 0xF) )
  {
    *a3 = 16;
    *a4 = 98;
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 2 )
      return -1;
    memset(s, 0, sizeof(s));
    snprintf(s, 0x2000u, "%s: data_enc error\n", "edf_v5_region_2_encode");
    sub_42CB4(2, s, 0);
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000209C4) --------------------------------------------------------
int __fastcall sub_209C4(int a1, _WORD *a2, int *a3, _DWORD *a4)
{
  int v4; // r5
  _BYTE *v9; // r5
  _BYTE dest[256]; // [sp+8h] [bp-2104h] BYREF
  char s[8196]; // [sp+108h] [bp-2004h] BYREF

  v4 = *a3;
  if ( (unsigned int)*a3 <= 0x61 )
  {
    if ( (unsigned int)off_BC5EC > 2 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "INPUT too short %u<%u\n", v4, 98);
      sub_42CB4(2, s, 0);
    }
    return -1;
  }
  v9 = *(_BYTE **)(a1 + 292);
  if ( (unsigned int)off_BC5EC > 4 )
  {
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "BOARD_CRC_DATA_LEN=%d\n", 97);
    sub_42CB4(4, s, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "BOARD_ENC_DATA_START=%d\n", 2);
      sub_42CB4(4, s, 0);
      if ( (unsigned int)off_BC5EC <= 4 )
        goto LABEL_6;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "BOARD_ENC_DATA_LEN=%d\n", 96);
      sub_42CB4(4, s, 0);
      if ( (unsigned int)off_BC5EC <= 4 )
        goto LABEL_17;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "PARAM_CRC_DATA_START=%d\n", 98);
      sub_42CB4(4, s, 0);
      if ( (unsigned int)off_BC5EC <= 4 )
        goto LABEL_6;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "PARAM_CRC_DATA_LEN=%d\n", 15);
      sub_42CB4(4, s, 0);
    }
    if ( (unsigned int)off_BC5EC <= 4 )
    {
LABEL_20:
      if ( (unsigned int)off_BC5EC > 4 )
      {
        memset(s, 0, 0x2000u);
        snprintf(s, 0x2000u, "SWEEP_ENC_DATA_START=%d\n", 114);
        sub_42CB4(4, s, 0);
        if ( (unsigned int)off_BC5EC > 4 )
        {
          memset(s, 0, 0x2000u);
          snprintf(s, 0x2000u, "SWEEP_ENC_DATA_LEN=%d\n", 136);
          sub_42CB4(4, s, 0);
        }
      }
      goto LABEL_6;
    }
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "PARAM_ENC_DATA_START=%d\n", 98);
    sub_42CB4(4, s, 0);
    if ( (unsigned int)off_BC5EC <= 4 )
      goto LABEL_6;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "PARAM_ENC_DATA_LEN=%d\n", 16);
    sub_42CB4(4, s, 0);
LABEL_17:
    if ( (unsigned int)off_BC5EC <= 4 )
      goto LABEL_6;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "SWEEP_CRC_DATA_START=%d\n", 114);
    sub_42CB4(4, s, 0);
    if ( (unsigned int)off_BC5EC <= 4 )
      goto LABEL_6;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "SWEEP_CRC_DATA_LEN=%d\n", 135);
    sub_42CB4(4, s, 0);
    goto LABEL_20;
  }
LABEL_6:
  v9[97] = sub_459C8(v9, 776);
  memcpy(dest, v9 + 2, 0x60u);
  if ( sub_2150C((int)dest, 96, (unsigned __int8)v9[1] >> 4, v9[1] & 0xF) )
  {
    *a2 = *(_WORD *)v9;
    memcpy(a2 + 1, dest, 0x60u);
    *a3 = 98;
    *a4 = 0;
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 2 )
      return -1;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%s: data_enc error\n", "edf_v5_region_1_encode");
    sub_42CB4(2, s, 0);
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00020E10) --------------------------------------------------------
int __fastcall sub_20E10(int a1, unsigned __int8 *src, size_t n, unsigned int a4)
{
  unsigned __int8 *v5; // r5
  int v6; // r7
  void *v8; // r2
  int v9; // r7
  int v11; // r11
  int v12; // r10
  int v13; // r3
  const char *v14; // r5
  int v15; // r0
  int v16; // r2
  int v17; // r12
  int v18; // r3
  int v19; // r0
  int v20; // r12
  int v21; // r0
  int v22; // r2
  int v23; // r3
  int v24; // r0
  int v25; // [sp+Ch] [bp-2108h]
  _BYTE dest[2]; // [sp+10h] [bp-2104h] BYREF
  _BYTE v27[96]; // [sp+12h] [bp-2102h] BYREF
  int v28; // [sp+72h] [bp-20A2h] BYREF
  int v29; // [sp+76h] [bp-209Eh]
  int v30; // [sp+7Ah] [bp-209Ah]
  int v31; // [sp+7Eh] [bp-2096h]
  _BYTE v32[142]; // [sp+82h] [bp-2092h] BYREF
  char s[8196]; // [sp+110h] [bp-2004h] BYREF

  v5 = *(unsigned __int8 **)(a1 + 292);
  v6 = *src;
  v8 = off_BC5EC;
  if ( *v5 == v6 )
  {
    if ( (a4 & 0xE) == 0 )
    {
      if ( (unsigned int)off_BC5EC > 2 )
      {
        v9 = -1;
        memset(s, a4 & 0xE, 0x2000u);
        strcpy(s, "flag invalid\n");
        sub_42CB4(2, s, 0);
        return v9;
      }
      return -1;
    }
    v9 = a4 & 2;
    if ( ((n <= 0x61) & (a4 >> 1)) != 0 )
      goto LABEL_25;
    v11 = a4 & 4;
    if ( ((n <= 0x71) & (a4 >> 2)) != 0 )
      goto LABEL_25;
    v12 = (a4 >> 3) & 1;
    v13 = a4 & 8;
    if ( n > 0xF9 )
      v12 = 0;
    v25 = v13;
    if ( v12 )
    {
LABEL_25:
      if ( (unsigned int)off_BC5EC > 2 )
      {
        v9 = -1;
        memset(s, 0, 0x2000u);
        strcpy(s, "len invalid\n");
        sub_42CB4(2, s, 0);
        return v9;
      }
      return -1;
    }
    if ( n > 0x100 )
    {
      if ( (unsigned int)off_BC5EC <= 2 )
        goto LABEL_15;
      memset(s, 0, 0x2000u);
      strcpy(s, "len too large, should less than 256\n");
      sub_42CB4(2, s, 0);
      v8 = off_BC5EC;
    }
    if ( (unsigned int)v8 > 3 )
    {
      memset(s, 0, 0x2000u);
      strcpy(s, "v5 load data succ\n");
      sub_42CB4(3, s, 0);
    }
LABEL_15:
    v5[1] = src[1];
    memcpy(dest, src, n);
    if ( v9 )
    {
      memcpy(v27, src + 2, sizeof(v27));
      if ( !sub_215C4((int)v27, 96, v5[1] >> 4, v5[1] & 0xF) )
      {
        v14 = "DEC 1ST REGION";
        v9 = -1;
        goto LABEL_21;
      }
      v15 = sub_459C8(dest, 776);
      if ( v27[95] != v15 )
      {
        v14 = "CRC 1ST REGION";
        v9 = -1;
        goto LABEL_21;
      }
      memcpy(v5 + 2, v27, 0x60u);
      if ( v5[95] != 1 )
      {
        v14 = "PT1 test NOT pass, redo it";
        v9 = -1;
        goto LABEL_21;
      }
      v9 = 2;
    }
    if ( v11 )
    {
      v16 = *(_DWORD *)(src + 106);
      v17 = *(_DWORD *)(src + 102);
      v18 = *(_DWORD *)(src + 110);
      v28 = *(_DWORD *)(src + 98);
      v29 = v17;
      v31 = v18;
      v30 = v16;
      if ( !sub_215C4((int)&v28, 16, v5[1] >> 4, v5[1] & 0xF) )
      {
        v14 = "DEC 2ND REGION";
        goto LABEL_21;
      }
      v19 = sub_459C8(&v28, 120);
      if ( HIBYTE(v31) != v19 )
      {
        v14 = "CRC 2ND REGION";
        goto LABEL_21;
      }
      v20 = v28;
      v21 = v29;
      v22 = v31;
      *(_DWORD *)(v5 + 106) = v30;
      v23 = v5[108];
      *(_DWORD *)(v5 + 98) = v20;
      *(_DWORD *)(v5 + 102) = v21;
      *(_DWORD *)(v5 + 110) = v22;
      if ( v23 != 1 )
      {
        v14 = "PT2 test NOT pass, redo it";
        goto LABEL_21;
      }
      v9 |= 4u;
    }
    if ( !v25 )
      return v9;
    memcpy(v32, src + 114, 0x88u);
    if ( sub_215C4((int)v32, 136, v5[1] >> 4, v5[1] & 0xF) )
    {
      v24 = sub_459C8(v32, 1080);
      if ( v32[135] == v24 )
      {
        memcpy(v5 + 114, v32, 0x88u);
        if ( v5[247] == 1 )
          return v9 | 8;
        v14 = "sweep NOT pass, redo it";
      }
      else
      {
        v14 = "CRC 3RD REGION";
      }
    }
    else
    {
      v14 = "DEC 3ND REGION";
    }
LABEL_21:
    if ( (unsigned int)off_BC5EC > 2 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "EEPROM error: %s\n", v14);
      sub_42CB4(2, s, 0);
    }
    return v9;
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    return -1;
  memset(s, 0, 0x2000u);
  snprintf(s, 0x2000u, "v5 check version invalid %d!=%d\n", v6, *v5);
  sub_42CB4(3, s, 0);
  return -1;
}
// 20EFC: masking with 0x1 was optimized away because r10.4 <= 0x1
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0002128C) --------------------------------------------------------
char *sub_2128C()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  memset(v1, 0, 0x2000u);
  strcpy(v1, "edf_v5_destroy: input arg wrong\n");
  return sub_42CB4(3, v1, 0);
}

//----- (000212E8) --------------------------------------------------------
void __fastcall sub_212E8(_DWORD *a1)
{
  void *v2; // r0

  if ( a1 && (v2 = (void *)a1[73]) != 0 )
  {
    free(v2);
    free(a1);
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    sub_2128C();
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0002132C) --------------------------------------------------------
_DWORD *sub_2132C()
{
  _DWORD *v0; // r4
  _WORD *v1; // r5

  v0 = malloc(0x128u);
  if ( v0 )
  {
    v1 = malloc(0xFAu);
    memset(v1 + 1, 0, 0xF8u);
    *v1 = 12549;
    memcpy(v0, &off_9899C, 0x128u);
    v0[73] = v1;
  }
  return v0;
}
// 9899C: using guessed type int (__fastcall *off_9899C)(int, void *src, size_t n);

//----- (00021384) --------------------------------------------------------
int sub_21384()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  strcpy(v1, "XXTEA requires the input as 64-bit aligned, fail to encode!\n");
  sub_41DB8(3, v1, 0);
  return 0;
}

//----- (000213E0) --------------------------------------------------------
int sub_213E0()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  strcpy(v1, "XXTEA requires the input as 64-bit aligned, fail to decode!\n");
  sub_41DB8(3, v1, 0);
  return 0;
}

//----- (0002143C) --------------------------------------------------------
_DWORD *__fastcall sub_2143C(_DWORD *result, _DWORD *a2, int a3)
{
  _DWORD *v3; // r2

  if ( a3 > 0 )
  {
    v3 = &result[a3];
    do
      *result++ ^= *a2;
    while ( result != v3 );
  }
  return result;
}

//----- (00021464) --------------------------------------------------------
char *__fastcall sub_21464(int a1)
{
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( a1 == 3 && (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v3, "enc/dec undefined data type, use default key!\n");
    sub_41DB8(3, v3, 0);
  }
  if ( dword_BB2F4 == 1 )
    return (char *)&unk_BB308 + 16 * a1;
  if ( dword_BB2F4 == 2 )
    return (char *)&unk_BB2F8 + 4 * a1;
  return 0;
}
// BB2F4: using guessed type int dword_BB2F4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0002150C) --------------------------------------------------------
int __fastcall sub_2150C(int a1, int a2, int a3, int a4)
{
  char *v7; // r0
  int v8; // r5
  _DWORD *v9; // r3
  _DWORD *v10; // r5

  v7 = sub_21464(a4);
  if ( a3 == 1 )
  {
    if ( (a2 & 7) != 0 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
        return sub_21384();
      else
        return 0;
    }
    else
    {
      sub_21750(a1, a2 / 4, (int)v7);
      return 1;
    }
  }
  else
  {
    if ( a3 == 2 )
    {
      v8 = a2 / 4;
      if ( v8 > 0 )
      {
        v9 = (_DWORD *)a1;
        v10 = (_DWORD *)(a1 + 4 * v8);
        do
          *v9++ ^= *(_DWORD *)v7;
        while ( v9 != v10 );
      }
    }
    return 1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000215C4) --------------------------------------------------------
int __fastcall sub_215C4(int a1, int a2, int a3, int a4)
{
  char *v7; // r0
  int v8; // r5
  _DWORD *v9; // r3
  _DWORD *v10; // r5

  v7 = sub_21464(a4);
  if ( a3 == 1 )
  {
    if ( (a2 & 7) != 0 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
        return sub_213E0();
      else
        return 0;
    }
    else
    {
      sub_218B4(a1, a2 / 4, (int)v7);
      return 1;
    }
  }
  else
  {
    if ( a3 == 2 )
    {
      v8 = a2 / 4;
      if ( v8 > 0 )
      {
        v9 = (_DWORD *)a1;
        v10 = (_DWORD *)(a1 + 4 * v8);
        do
          *v9++ ^= *(_DWORD *)v7;
        while ( v9 != v10 );
      }
    }
    return 1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0002167C) --------------------------------------------------------
int __fastcall sub_2167C(int result, char a2, int a3)
{
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (a2 & 3) != 0 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v3, "EEPROM write data is not 32-bit aligned, FAIL ENC/DEC!\n");
      return sub_41DB8(3, v3, 0);
    }
  }
  else if ( a3 )
  {
    return sub_2150C(result, a2, dword_BB2F4, 3);
  }
  else
  {
    return sub_215C4(result, a2, dword_BB2F4, 3);
  }
  return result;
}
// BB2F4: using guessed type int dword_BB2F4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00021730) --------------------------------------------------------
int __fastcall sub_21730(int result)
{
  dword_BB2F4 = result;
  return result;
}
// BB2F4: using guessed type int dword_BB2F4;

//----- (00021740) --------------------------------------------------------
int sub_21740()
{
  return dword_BB2F4;
}
// BB2F4: using guessed type int dword_BB2F4;

//----- (00021750) --------------------------------------------------------
int __fastcall sub_21750(int result, int a2, int a3)
{
  unsigned int *v3; // r7
  unsigned int *v5; // r8
  unsigned int v6; // r4
  int v7; // r11
  unsigned int v8; // r10
  unsigned int *v9; // r5
  int v10; // lr
  unsigned int v11; // r9
  int v12; // r3
  int v13; // [sp+0h] [bp-200Ch]
  char v14[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( a2 <= 1 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v14, "XXTEA encode failes, N <= 1 found.\n");
      return sub_41DB8(3, v14, 0);
    }
  }
  else
  {
    v3 = (unsigned int *)result;
    v5 = (unsigned int *)(result + 4 * (a2 + 0x3FFFFFFF));
    v6 = *v5;
    v7 = a2 - 1;
    v8 = 0;
    v13 = -1253254570 - 1640531527 * sub_96518(52, a2);
    do
    {
      v9 = v3;
      v10 = 0;
      v8 -= 1640531527;
      v11 = v8 >> 2;
      do
      {
        v12 = *(_DWORD *)(a3 + 4 * (((unsigned __int8)v11 ^ (unsigned __int8)v10++) & 3));
        v6 = (((v12 ^ v6) + (v8 ^ v9[1])) ^ (((4 * v9[1]) ^ (v6 >> 5)) + ((16 * v6) ^ (v9[1] >> 3)))) + *v9;
        *v9++ = v6;
      }
      while ( v10 != v7 );
      result = (16 * v6) ^ (*v3 >> 3);
      v6 = (((v6 ^ *(_DWORD *)(a3 + 4 * (((unsigned __int8)v11 ^ (unsigned __int8)v7) & 3))) + (v8 ^ *v3))
          ^ (((4 * *v3) ^ (v6 >> 5)) + result))
         + *v5;
      *v5 = v6;
    }
    while ( v8 != v13 );
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000218B4) --------------------------------------------------------
int __fastcall sub_218B4(int result, int a2, int a3)
{
  unsigned int *v3; // r7
  int v6; // r0
  unsigned int v7; // r2
  unsigned int v8; // r3
  unsigned int *v9; // r10
  int v10; // r11
  int v11; // r5
  unsigned int v12; // r9
  unsigned int *v13; // r6
  unsigned int v14; // t1
  int v15; // r4
  int v16; // r4
  int v17; // [sp+0h] [bp-200Ch]
  char v18[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( a2 <= 1 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v18, "XXTEA decode failes, N <= 1 found.\n");
      return sub_41DB8(3, v18, 0);
    }
  }
  else
  {
    v3 = (unsigned int *)result;
    v6 = sub_96518(52, a2);
    v7 = -1640531527 * (v6 + 6);
    v17 = a2 - 1;
    v8 = *v3;
    v9 = &v3[a2 - 1];
    v10 = v7 + 1640531527 * v6 + 1253254570;
    do
    {
      v11 = v17;
      v12 = v7 >> 2;
      v13 = v9;
      do
      {
        v14 = *--v13;
        v15 = *(_DWORD *)(a3 + 4 * (((unsigned __int8)v12 ^ (unsigned __int8)v11--) & 3));
        v8 = v13[1] - (((v14 ^ v15) + (v7 ^ v8)) ^ (((4 * v8) ^ (v14 >> 5)) + ((16 * v14) ^ (v8 >> 3))));
        v13[1] = v8;
      }
      while ( v11 );
      v16 = v8 ^ v7;
      v7 += 1640531527;
      result = (4 * v8) ^ (*v9 >> 5);
      v8 = *v3 - ((result + ((16 * *v9) ^ (v8 >> 3))) ^ ((*v9 ^ *(_DWORD *)(a3 + 4 * (v12 & 3))) + v16));
      *v3 = v8;
    }
    while ( v7 != v10 );
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00021A1C) --------------------------------------------------------
bool __fastcall sub_21A1C(unsigned __int8 a1)
{
  return (unsigned __int8)sub_6626C(a1) == 0;
}

//----- (00021A3C) --------------------------------------------------------
bool __fastcall sub_21A3C(unsigned __int8 a1)
{
  return (unsigned __int8)sub_6674C(a1) == 0;
}

//----- (00021A54) --------------------------------------------------------
int __fastcall sub_21A54(int a1)
{
  int result; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "chain[%d] PIC jump to app\n", a1);
    sub_41DB8(3, s, 0);
  }
  sub_663A4(a1);
  usleep(0x7A120u);
  result = sub_6612C(a1);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "Check chain[%d] PIC fw version=0x%02x\n", a1, result);
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00021B08) --------------------------------------------------------
unsigned int __fastcall sub_21B08(unsigned int result, int a2)
{
  unsigned int v2; // r4
  double v3; // d8
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v2 = result;
  if ( a2 )
  {
    result = sub_70C58();
    v3 = (double)result / 100.0;
  }
  else
  {
    v3 = 0.0;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "read_feedback_voltage chain = %d, voltage = %f\n", v2, v3);
    return sub_41DB8(4, s, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00021BA8) --------------------------------------------------------
int sub_21BA8()
{
  double v0; // d0
  unsigned int v1; // r4
  double v2; // d8
  int result; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v1 = 0;
  v2 = 0.0;
  do
  {
    result = sub_27EC8(v1);
    if ( result )
    {
      result = sub_21B08(v1, 1);
      if ( v0 > 0.1 )
      {
        if ( v0 >= v2 )
        {
          if ( v2 < 0.1 )
            v2 = v0;
        }
        else
        {
          v2 = v0;
        }
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "the minimal voltage = %.2f", v2);
    return sub_41DB8(4, s, 0);
  }
  return result;
}
// 21C44: variable 'v0' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00021C78) --------------------------------------------------------
int sub_21C78()
{
  int v0; // r4
  int result; // r0
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v2, "power on");
    sub_41DB8(3, v2, 0);
  }
  sub_5DD70();
  v0 = 0;
  sub_44890();
  do
  {
    if ( sub_27EC8(v0) )
      sub_64434(v0);
    ++v0;
  }
  while ( v0 != 4 );
  result = sub_44890();
  byte_BDC48 = 1;
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC48: using guessed type char byte_BDC48;

//----- (00021D18) --------------------------------------------------------
int sub_21D18()
{
  int v0; // r4
  int result; // r0
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v2, "power off\n");
    sub_41DB8(3, v2, 0);
  }
  sub_5DDB8();
  v0 = 0;
  sub_44890();
  do
  {
    result = sub_27EC8(v0);
    if ( result )
      result = sub_643D4(v0);
    ++v0;
  }
  while ( v0 != 4 );
  byte_BDC48 = 0;
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC48: using guessed type char byte_BDC48;

//----- (00021DB8) --------------------------------------------------------
int sub_21DB8()
{
  return (unsigned __int8)byte_BDC48;
}
// BDC48: using guessed type char byte_BDC48;

//----- (00021DC8) --------------------------------------------------------
int sub_21DC8()
{
  int v0; // r4
  int v1; // r5
  int result; // r0
  int v3; // r3
  int v4; // r5
  int v5; // r0
  int v6; // r1
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v0 = 1;
  sleep(1u);
  do
  {
    do
    {
      ++v0;
      sleep(1u);
    }
    while ( v0 <= 29 );
    v1 = sub_191C8(0);
    result = sub_19404();
    v3 = v1 - result;
    if ( v1 - result < 0 )
      v3 = result - v1;
  }
  while ( v3 > 5 && v0 != 120 );
  if ( (unsigned int)off_BC5EC > 3 )
  {
    v4 = sub_191C8(0);
    v5 = sub_19404();
    v6 = v4 - v5;
    if ( v4 - v5 < 0 )
      v6 = v5 - v4;
    snprintf(s, 0x2000u, "Slept %d seconds, diff = %d.\n", v0, v6);
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00021E88) --------------------------------------------------------
int __fastcall sub_21E88(int a1, unsigned int a2)
{
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  if ( a2 < (unsigned int)off_BC5EC )
  {
    snprintf(s, 0x2000u, "%s to %d.\n", "set_voltage_by_steps", a1);
    sub_41DB8(a2, s, 0);
  }
  if ( sub_70DA8() >= 0 )
  {
    usleep(0x7A120u);
    dword_BDC50 = a1;
    dword_BDC54 = a1;
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "bitmain_set_voltage failed");
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC50: using guessed type int dword_BDC50;
// BDC54: using guessed type int dword_BDC54;

//----- (00021F98) --------------------------------------------------------
int __fastcall sub_21F98(int a1)
{
  double v1; // d0
  int v3; // r6
  int v4; // r6
  int v6; // r0
  int v7; // r5
  double v8; // d7
  unsigned int v9; // r5
  const char *v10; // r3
  double v11; // d10
  int v12; // r7
  int v13; // [sp+4h] [bp-200Ch]
  char s[8192]; // [sp+10h] [bp-2000h] BYREF

  v3 = sub_7051C();
  if ( sub_29C30() && sub_29C70() )
    v3 = sub_29DD8();
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "power type version: 0x%04x\n", v3);
    sub_41DB8(3, s, 0);
  }
  dword_BDC58 = v3;
  if ( sub_285C4((unsigned __int16)v3) )
  {
    if ( (unsigned int)(dword_BDC58 - 100) <= 2 )
    {
      v6 = sub_6FCF4(0);
      v4 = v6;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "disable power watchdog: 0x%04x\n", v6);
        sub_41DB8(3, s, 0);
        if ( v4 )
        {
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "%s power disable watchdog error.\n", "power_init");
            sub_41DB8(3, s, 0);
          }
          return v4;
        }
      }
      else if ( v6 )
      {
        return v4;
      }
      sleep(1u);
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "Initializing the power, please wait, this may take up to 2 minutes...\n");
      sub_41DB8(3, s, 0);
    }
    sub_21D18();
    sub_21DC8();
    v4 = sub_21E88(a1, 3u);
    if ( !v4 )
    {
      sleep(2u);
      if ( (unsigned int)(dword_BDC58 - 100) > 2 )
      {
        v11 = (double)a1;
        v12 = 3;
        while ( 1 )
        {
          sleep(1u);
          sub_21BA8();
          if ( v1 >= v11 * 0.75 / 100.0 )
            break;
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "power voltage can not meet the target, retry:%d", v12);
            sub_41DB8(3, s, 0);
          }
          if ( !--v12 )
            return -1;
        }
      }
      else
      {
        v7 = 3;
        while ( 1 )
        {
          sleep(1u);
          sub_21B08(0, 1);
          if ( v1 < 0.0 )
            break;
          v1 = v1 * 100.0;
          v8 = (double)a1;
          if ( v1 <= (double)a1 * 1.1 && v1 >= v8 * 0.9 )
          {
            v4 = 0;
            goto LABEL_21;
          }
          v10 = "drop";
          if ( (unsigned int)off_BC5EC > 3 )
          {
            if ( v1 - v8 > 0.0 )
              v10 = "rise";
            snprintf(s, 0x2000u, "chain avg vol %s from %d to %.2f", v10, a1, v13, v1);
            sub_41DB8(3, s, 0);
            if ( (unsigned int)off_BC5EC > 3 )
            {
              strcpy(s, "power voltage can not meet the target");
              sub_41DB8(3, s, 0);
            }
          }
          if ( !--v7 )
          {
            v4 = -1;
            goto LABEL_21;
          }
        }
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "read_feedback_voltage failed!");
          sub_41DB8(3, s, 0);
        }
        sub_4FB28(12, 0);
        v4 = 0;
        sub_473B4(9u, "power voltage read failed, pls check!");
LABEL_21:
        v9 = 0;
        while ( 1 )
        {
          ++v9;
          if ( !sub_6F2DC() )
            break;
          if ( v9 == 5 * (v9 / 5) && (unsigned int)off_BC5EC > 3 )
          {
            strcpy(s, "bitmain_get_power_status failed!");
            sub_41DB8(3, s, v9 % 5);
          }
          sleep(3u);
          if ( v9 == 20 )
            return -1;
        }
      }
    }
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    v4 = -1;
    strcpy(s, "power type version error\n");
    sub_41DB8(3, s, 0);
  }
  else
  {
    return -1;
  }
  return v4;
}
// 220C0: variable 'v1' is possibly undefined
// 222C4: variable 'v13' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC58: using guessed type int dword_BDC58;

//----- (0002242C) --------------------------------------------------------
int sub_2242C()
{
  return dword_BDC50;
}
// BDC50: using guessed type int dword_BDC50;

//----- (0002243C) --------------------------------------------------------
int sub_2243C()
{
  double v0; // d0

  sub_71AF8();
  return (int)(v0 * 100.0);
}
// 2244C: variable 'v0' is possibly undefined

//----- (000226B4) --------------------------------------------------------
int sub_226B4()
{
  if ( sub_29C30() && sub_29C70() )
    return sub_29DE8();
  else
    return sub_73144();
}

//----- (000226E8) --------------------------------------------------------
bool sub_226E8()
{
  bool v0; // cc

  v0 = (unsigned int)dword_BDC58 > 0x62;
  if ( dword_BDC58 != 98 )
    v0 = (unsigned int)(dword_BDC58 - 100) > 2;
  return !v0;
}
// BDC58: using guessed type int dword_BDC58;

//----- (0002270C) --------------------------------------------------------
bool sub_2270C()
{
  return (unsigned int)(dword_BDC58 - 100) <= 2;
}
// BDC58: using guessed type int dword_BDC58;

//----- (00022730) --------------------------------------------------------
int __fastcall sub_22730(int a1, int a2)
{
  return *(_DWORD *)(a2 + 4) - *(_DWORD *)(a1 + 4);
}

//----- (00022740) --------------------------------------------------------
int __fastcall sub_22740(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (00022750) --------------------------------------------------------
unsigned int *__fastcall sub_22750(unsigned int *a1, unsigned int *a2, unsigned int *a3, _DWORD *a4)
{
  unsigned int *result; // r0
  unsigned int *v9; // r6
  int v10; // r5
  unsigned int *v11; // r6
  unsigned int v12; // lr
  unsigned int v13; // r4
  unsigned int v14; // r12
  unsigned int v15; // t1

  result = (unsigned int *)sub_27D1C();
  v9 = result;
  if ( (int)result <= 0 )
  {
    v10 = 0;
    v13 = 0xFFFFFF;
    v12 = 0;
  }
  else
  {
    v10 = 0;
    result = a1;
    v11 = &a1[(_DWORD)v9];
    v12 = 0;
    v13 = 0xFFFFFF;
    do
    {
      v15 = *result++;
      v14 = v15;
      v10 += v15;
      if ( v12 < v15 )
        v12 = v14;
      if ( v13 >= v14 )
        v13 = v14;
    }
    while ( result != v11 );
  }
  *a2 = v13;
  *a3 = v12;
  *a4 = v10;
  return result;
}

//----- (000227C4) --------------------------------------------------------
int __fastcall sub_227C4(int a1, unsigned int *a2, int a3)
{
  float v3; // s0
  int result; // r0
  float v7; // s14
  unsigned int *v8; // r3
  unsigned int v9; // s15
  float v10; // s15
  float v11; // s14
  int j; // r6
  int v13; // r7
  int v14; // r5
  int v15; // r11
  char v16; // r0
  int v17; // r3
  int v18; // [sp+10h] [bp-2024h]
  int v19; // [sp+14h] [bp-2020h]
  int i; // [sp+18h] [bp-201Ch]
  unsigned int v21; // [sp+1Ch] [bp-2018h]
  char v22[4]; // [sp+2Ch] [bp-2008h] BYREF
  int s; // [sp+30h] [bp-2004h] BYREF
  int v24; // [sp+34h] [bp-2000h]

  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf((char *)&s, 0x2000u, "chain = %d, start = %d, freq_step = %.2f\n", a1, a3, v3);
    sub_41DB8(3, (const char *)&s, 0);
  }
  s = 0;
  v24 = 0;
  result = sub_27D1C();
  v7 = 0.0;
  if ( result )
  {
    v8 = a2;
    do
    {
      v9 = *v8++;
      v10 = (float)v9;
      if ( v10 > v7 )
        v7 = v10;
    }
    while ( &a2[result] != v8 );
  }
  v11 = (float)((float)(v3 + v7) - 1.0) / v3;
  v21 = (unsigned int)v11;
  if ( ((unsigned int)v11 & 1) != 0 )
    v21 = (unsigned int)v11 + 1;
  if ( v21 )
  {
    v19 = 0;
    for ( i = 2; ; i = v17 )
    {
      ++v19;
      v18 = sub_27D2C();
      if ( v18 )
      {
        for ( j = 0; j != v18; ++j )
        {
          v13 = sub_27D0C();
          if ( v13 )
          {
            v14 = 0;
            do
            {
              v15 = j + v14 * sub_27D2C();
              ++v14;
              sub_7F80C((int)&s, v22, 0);
              BYTE2(v24) = v22[0];
              v16 = sub_27D8C();
              sub_2A7AC(a1, 0, (unsigned __int8)(v16 * v15), (unsigned __int8)i, s, v24);
            }
            while ( v13 != v14 );
          }
          usleep(0x1388u);
        }
      }
      sub_44890();
      result = sub_80BFC((unsigned __int8)a1, 0, i);
      if ( v19 == v21 )
        break;
      if ( i )
        v17 = 0;
      else
        v17 = 2;
    }
  }
  return result;
}
// 229C0: variable 'v3' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000229E0) --------------------------------------------------------
int __fastcall sub_229E0(int a1)
{
  int v2; // r4
  int v3; // r4
  int v4; // [sp+4h] [bp-4h] BYREF

  v4 = 0;
  if ( dword_BC898 == 2 )
  {
    v2 = dword_BDC5C[a1];
    v3 = sub_27D1C() * v2;
    return sub_27D5C() * v3 / 1000 + v4;
  }
  else
  {
    sub_1D048(a1, (unsigned __int8)dword_C351C, &v4);
    return v4;
  }
}
// BC898: using guessed type int dword_BC898;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// C351C: using guessed type int dword_C351C;

//----- (00022A64) --------------------------------------------------------
int sub_22A64()
{
  size_t v0; // r0
  int *v1; // r7
  int v2; // r4
  int i; // r5
  int v4; // r1
  int v5; // kr00_4
  __int64 v6; // r4
  int v8; // r5
  int v9; // r8
  int v10; // r8
  int v11; // r0
  int *v12; // r9
  int *v13; // r6
  int v14; // t1
  char v15[8192]; // [sp+0h] [bp-2000h] BYREF

  v0 = sub_27D1C();
  v1 = (int *)calloc(v0, 4u);
  if ( v1 )
  {
    v2 = 0;
    if ( dword_BC898 == 2 )
    {
      v8 = 0;
      if ( sub_27EC8(0) )
        goto LABEL_14;
      while ( ++v8 != 4 )
      {
        if ( sub_27EC8(v8) )
        {
LABEL_14:
          v9 = dword_BDC5C[v8];
          v10 = sub_27D1C() * v9;
          v2 += sub_27D5C() * v10;
        }
      }
    }
    else
    {
      for ( i = 0; i != 4; ++i )
      {
        if ( sub_27EC8(i) )
        {
          sub_1C070(i, (unsigned __int8)dword_C351C, v1);
          v11 = sub_27D1C();
          if ( v11 > 0 )
          {
            v12 = &v1[v11];
            v13 = v1;
            do
            {
              v14 = *v13++;
              v2 += v14 * sub_27D5C();
            }
            while ( v13 != v12 );
          }
        }
      }
    }
    v4 = v2 >> 31;
    v5 = v2;
    v6 = 274877907LL * v2;
    LODWORD(v6) = v5 / 1000;
    dword_BDC6C = v6;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(v15, 0x2000u, "max_hash_rate = %d\n", (SHIDWORD(v6) >> 6) - v4);
      sub_41DB8(4, v15, 0);
      LODWORD(v6) = dword_BDC6C;
    }
    free(v1);
  }
  else
  {
    LODWORD(v6) = 0;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v15, "malloc buf failed!\n");
      sub_41DB8(3, v15, 0);
    }
  }
  return v6;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// BDC6C: using guessed type int dword_BDC6C;
// C351C: using guessed type int dword_C351C;

//----- (00022C10) --------------------------------------------------------
int sub_22C10()
{
  unsigned int v0; // r5
  int result; // r0
  int k; // r4
  int v3; // r6
  int m; // r4
  int v5; // r0
  int v6; // r7
  int j; // r6
  int v8; // r5
  int i; // r4
  int v10; // r0
  int v11; // r6
  int v12; // r8
  int v13; // r7
  int v14; // r7
  unsigned int v15; // [sp+4h] [bp-2004h] BYREF
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v0 = sub_4CB28();
  if ( v0 )
  {
    if ( dword_BC898 == 2 )
    {
      v8 = 0;
      for ( i = 0; i != 4; ++i )
      {
        v10 = i;
        if ( sub_27EC8(v10) )
        {
          v11 = sub_27D1C();
          v12 = dword_4D4180;
          v8 += v12 * sub_27D5C() * v11;
        }
      }
      result = v8 / 1000;
    }
    else
    {
      result = 0;
    }
  }
  else if ( dword_BC898 == 2 )
  {
    for ( j = 0; j != 4; ++j )
    {
      if ( sub_27EC8(j) )
      {
        v13 = dword_BDC5C[j];
        v14 = sub_27D1C() * v13;
        v0 += sub_27D5C() * v14;
      }
    }
    result = (int)v0 / 1000;
  }
  else
  {
    for ( k = 0; k != 4; ++k )
    {
      if ( sub_27EC8(k) && !sub_1C070(k, (unsigned __int8)dword_C351C, (int *)&v15) )
      {
        if ( v0 )
        {
          if ( v0 >= v15 )
            v0 = v15;
        }
        else
        {
          v0 = v15;
        }
      }
    }
    v3 = 0;
    for ( m = 0; m != 4; ++m )
    {
      v5 = m;
      if ( sub_27EC8(v5) )
      {
        v6 = v0 * sub_27D1C();
        v3 += sub_27D5C() * v6;
      }
    }
    result = v3 / 1000;
  }
  dword_BDC70 = result;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "ideal_hash_rate = %d\n", result);
    sub_41DB8(4, s, 0);
    return dword_BDC70;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// BDC70: using guessed type int dword_BDC70;
// C351C: using guessed type int dword_C351C;
// 4D4180: using guessed type int dword_4D4180;

//----- (00022E18) --------------------------------------------------------
int __fastcall sub_22E18(int a1)
{
  int v2; // r5
  int i; // r4
  int v5; // r0
  int v6; // r7

  if ( dword_BC898 != 2 )
    return 0;
  v2 = 0;
  for ( i = 0; i != 4; ++i )
  {
    v5 = i;
    if ( sub_27EC8(v5) )
    {
      v6 = a1 * sub_27D1C();
      v2 += sub_27D5C() * v6;
    }
  }
  return 1000 * ((int)((double)(v2 / 1000) * 0.99) / 1000);
}
// BC898: using guessed type int dword_BC898;

//----- (00022EC0) --------------------------------------------------------
int sub_22EC0()
{
  const char *v0; // r0
  int v1; // r3
  const char *v2; // r0
  int v3; // r3
  const char *v4; // r0
  int result; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  dword_BDC74 = 1000 * ((int)((double)sub_22C10() * 0.99) / 1000);
  v0 = (const char *)sub_27CEC();
  if ( !strcmp(v0, "HHB68601") || (v6 = (const char *)sub_27CEC(), !strcmp(v6, "HHB68602")) )
  {
    v1 = dword_BDC74;
    if ( dword_BDC74 <= 318999 )
    {
      if ( dword_BDC74 <= 301999 )
      {
        if ( dword_BDC74 <= 285999 )
        {
          if ( dword_BDC74 >= 270000 )
            v1 = 270000;
        }
        else
        {
          v1 = 286000;
        }
      }
      else
      {
        v1 = 302000;
      }
    }
    else
    {
      v1 = 319000;
    }
    dword_BDC74 = v1;
  }
  v2 = (const char *)sub_27CEC();
  if ( !strcmp(v2, "HHB68502")
    || (v11 = (const char *)sub_27CEC(), !strcmp(v11, "HHB68501"))
    || (v12 = (const char *)sub_27CEC(), !strcmp(v12, "HHB68503")) )
  {
    v3 = dword_BDC74;
    if ( dword_BDC74 <= 334999 )
    {
      if ( dword_BDC74 <= 318999 )
      {
        if ( dword_BDC74 >= 302000 )
          v3 = 302000;
      }
      else
      {
        v3 = 319000;
      }
    }
    else
    {
      v3 = 335000;
    }
    dword_BDC74 = v3;
  }
  v4 = (const char *)sub_27CEC();
  if ( !strcmp(v4, "HHB68701")
    || (v7 = (const char *)sub_27CEC(), !strcmp(v7, "HHB68704"))
    || (v8 = (const char *)sub_27CEC(), !strcmp(v8, "HHB68703"))
    || (v9 = (const char *)sub_27CEC(), !strcmp(v9, "H6HB68702"))
    || (v10 = (const char *)sub_27CEC(), !strcmp(v10, "H1HB68601")) )
  {
    result = dword_BDC74;
    if ( dword_BDC74 <= 292999 )
    {
      if ( dword_BDC74 <= 278999 )
      {
        if ( dword_BDC74 <= 265999 )
        {
          if ( dword_BDC74 >= 252000 )
            result = 252000;
        }
        else
        {
          result = 266000;
        }
      }
      else
      {
        result = 279000;
      }
    }
    else
    {
      result = 293000;
    }
    dword_BDC74 = result;
  }
  else
  {
    result = dword_BDC74;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "sale_hash_rate = %d, hash_rate_budget = %d\n", result, 0);
    sub_41DB8(4, s, 0);
    return dword_BDC74;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC74: using guessed type int dword_BDC74;

//----- (00023180) --------------------------------------------------------
int sub_23180()
{
  return 0;
}

//----- (00023188) --------------------------------------------------------
int __fastcall sub_23188(int result)
{
  char *v1; // r3

  v1 = (char *)dword_BDC5C;
  if ( dword_BC898 == 2 )
    result = dword_BDC5C[result];
  else
    v1 = (char *)&dword_BDC5C[result];
  if ( dword_BC898 != 2 )
    return *((_DWORD *)v1 + 7);
  return result;
}
// BC898: using guessed type int dword_BC898;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];

//----- (00023314) --------------------------------------------------------
int __fastcall sub_23314(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) - *(_DWORD *)(a2 + 4);
}

//----- (00023328) --------------------------------------------------------
int __fastcall sub_23328(int a1, unsigned int *a2, unsigned int *a3, _DWORD *a4, int a5, size_t *a6, unsigned int *a7)
{
  int v8; // r7
  int v11; // r4
  size_t v12; // r2
  size_t v13; // r4
  int v15; // r0
  int v16; // r1
  _DWORD *v17; // r2
  int v18; // r12
  int v19; // t1
  int v20; // r3
  unsigned int v21; // r0
  size_t v22; // [sp+0h] [bp-2024h]
  int v23; // [sp+4h] [bp-2020h]
  unsigned int v24; // [sp+10h] [bp-2014h]
  int v25; // [sp+14h] [bp-2010h]
  unsigned int v26; // [sp+1Ch] [bp-2008h] BYREF
  char s[8224]; // [sp+20h] [bp-2004h] BYREF

  v8 = a1 - 4;
  v11 = 0;
  v26 = 0;
  do
  {
    if ( sub_27EC8(v11) )
    {
      sub_22750((unsigned int *)(v8 + 4), a2, a3, &v26);
      a4[(*a6)++] = *a2;
      if ( *a7 < *a3 )
        *a7 = *a3;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "chain[%d] min = %d max =%d\n", v11, *a2, *a3);
        sub_41DB8(3, s, 0);
      }
      v15 = sub_27D1C();
      if ( v15 )
      {
        v18 = v8;
        v17 = 0;
        v16 = a5 - 4 + (v11 << 10);
        do
        {
          v19 = *(_DWORD *)(v18 + 4);
          v18 += 4;
          v17 = (_DWORD *)((char *)v17 + 1);
          *(_DWORD *)(v16 + 4) = v19 - *a2;
          v16 += 4;
        }
        while ( (_DWORD *)v15 != v17 );
      }
      v20 = dword_BC898[0];
      if ( dword_BC898[0] == 2 )
      {
        v17 = dword_BDC5C;
        v16 = dword_4D4180;
      }
      else
      {
        v20 = 4 * v11;
      }
      if ( dword_BC898[0] == 2 )
      {
        v20 = 4 * v11;
        v17[v11] = v16;
      }
      v25 = v20;
      v24 = v26;
      v21 = sub_27D1C();
      *(_DWORD *)((char *)dword_BDC78 + v25) = sub_962A0(v24, v21);
    }
    ++v11;
    v8 += 1024;
    ++a2;
    ++a3;
  }
  while ( v11 != 4 );
  qsort(a4, *a6, 4u, (__compar_fn_t)sub_22740);
  v12 = *a6;
  if ( *a6 )
  {
    v13 = 0;
    do
    {
      while ( (unsigned int)off_BC5EC <= 3 )
      {
        if ( v12 <= ++v13 )
          return 0;
      }
      v22 = v13;
      v23 = a4[v13++];
      snprintf(s, 0x2000u, "%s min_sorted[%d]=%d,*max_global=%d", "inc_mixed_freq_prepare", v22, v23, *a7);
      sub_41DB8(3, s, 0);
      v12 = *a6;
    }
    while ( *a6 > v13 );
  }
  return 0;
}
// 2351C: variable 'v16' is possibly undefined
// 2351C: variable 'v17' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898[];
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// BDC78: using guessed type _DWORD dword_BDC78[4];
// 4D4180: using guessed type int dword_4D4180;

//----- (00023590) --------------------------------------------------------
void __fastcall sub_23590(int a1, unsigned int a2, int a3)
{
  float v3; // s0
  const char *v4; // r3
  unsigned int v5; // r11
  unsigned int v6; // r8
  void *v7; // r2
  unsigned int v8; // r6
  unsigned int v9; // r5
  _QWORD *v10; // r4
  int v11; // r7
  char *v12; // r4
  unsigned __int8 *v13; // r6
  int v14; // r5
  int v15; // lr
  int v16; // r3
  int v17; // r1
  int v18; // r0
  int v19; // r12
  int v20; // r7
  char v21; // r1
  char v22; // r3
  char v23; // r2
  unsigned int v24; // r0
  size_t nmemb; // [sp+10h] [bp-21BCh]
  int v26; // [sp+14h] [bp-21B8h]
  unsigned int v27; // [sp+24h] [bp-21A8h]
  _BYTE v30[4]; // [sp+34h] [bp-2198h] BYREF
  int v31; // [sp+38h] [bp-2194h] BYREF
  int v32; // [sp+3Ch] [bp-2190h]
  _QWORD base[49]; // [sp+40h] [bp-218Ch] BYREF
  char s[8196]; // [sp+1C8h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    v4 = "false";
    if ( a3 )
      v4 = "true";
    snprintf(s, 0x2000u, "chain = %d, freq = %g, is_higher_voltage = %s\n", a1, v3, v4);
    sub_41DB8(3, s, 0);
  }
  sub_2A728(a1, 1);
  v32 = 0;
  v31 = 0;
  memset(base, 0, sizeof(base));
  sub_7F80C((int)&v31, v30, 0);
  v5 = v30[0];
  BYTE2(v32) = v30[0];
  v27 = BYTE1(v31);
  if ( (unsigned __int8)v31 > 7u )
  {
    nmemb = 0;
    v7 = off_BC5EC;
  }
  else
  {
    v26 = (unsigned __int8)v31;
    v6 = (unsigned __int8)v31;
    nmemb = 0;
    v7 = off_BC5EC;
    do
    {
      if ( v27 <= v6 )
      {
        v8 = v27;
        do
        {
          if ( v5 <= 1 )
          {
            v9 = v5;
            v10 = &base[nmemb];
            v11 = v8 * v26 * v5;
            do
            {
              *(_BYTE *)v10 = v6;
              *((_BYTE *)v10 + 1) = v8;
              *((_BYTE *)v10 + 2) = v9;
              *((_DWORD *)v10 + 1) = v11;
              if ( (unsigned int)v7 > 4 )
              {
                snprintf(s, 0x2000u, "post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n", v26, v8, v9, v11);
                sub_41DB8(4, s, 0);
                v7 = off_BC5EC;
              }
              ++v9;
              ++v10;
              v11 += v8 * v26;
            }
            while ( (unsigned __int8)v9 <= 1u );
            nmemb += (unsigned __int8)(1 - v5) + 1;
          }
          v8 = (unsigned __int8)(v8 + 1);
        }
        while ( v8 <= v6 );
      }
      v6 = (unsigned __int8)++v26;
    }
    while ( (unsigned __int8)v26 <= 7u );
  }
  if ( (unsigned int)v7 > 4 )
  {
    strcpy(s, "\n");
    sub_41DB8(4, s, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(s, "sorted\n");
      sub_41DB8(4, s, 0);
    }
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_22730);
  if ( nmemb )
  {
    v12 = (char *)base;
    v13 = (unsigned __int8 *)base;
    v14 = 0;
    do
    {
      while ( (unsigned int)off_BC5EC <= 4 )
      {
        ++v14;
        v13 += 8;
        if ( v14 == nmemb )
          goto LABEL_24;
      }
      v15 = *((_DWORD *)v13 + 1);
      v16 = v14;
      v17 = v13[2];
      v18 = v13[1];
      ++v14;
      v19 = *v13;
      v13 += 8;
      snprintf(
        s,
        0x2000u,
        "[%d] post_div1 = %d, post_div2 = %d, user_div = %d, div_ret = %d\n",
        v16,
        v19,
        v18,
        v17,
        v15);
      sub_41DB8(4, s, 0);
    }
    while ( v14 != nmemb );
LABEL_24:
    v20 = 0;
    do
    {
      v21 = *v12;
      v12 += 8;
      v22 = *(v12 - 6);
      v23 = *(v12 - 7);
      LOBYTE(v31) = v21;
      BYTE2(v32) = v22;
      BYTE1(v31) = v23;
      v24 = sub_2A6C8();
      if ( dword_BCCEC < v24 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(
            s,
            0x2000u,
            "[%d] _POSTDIV1 = %d, _POSTDIV2 = %d, USER_DIV = %d, freq = %d\n",
            v20,
            (unsigned __int8)v31,
            BYTE1(v31),
            BYTE2(v32),
            v24);
          sub_41DB8(3, s, 0);
        }
        sub_2A7AC(a1, 1, 0, a2, v31, v32);
        usleep((__useconds_t)&unk_F4240);
      }
      ++v20;
    }
    while ( v20 != v14 );
  }
}
// 23600: variable 'v3' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BCCEC: using guessed type int dword_BCCEC;

//----- (00023998) --------------------------------------------------------
int __fastcall sub_23998(
        unsigned int a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        unsigned int a5,
        unsigned int a6,
        char a7)
{
  float v7; // s0
  double v11; // d8
  int i; // r6
  unsigned int v13; // r3
  unsigned int v14; // s15
  const char *v15; // r0
  unsigned int v16; // r1
  bool v17; // cc
  float v18; // s17
  unsigned int v19; // r6
  float v20; // s19
  float v21; // s16
  float v22; // s16
  int j; // r4
  const char *v24; // r0
  int v25; // r3
  int k; // r9
  const char *v27; // r0
  int m; // r4
  const char *v29; // r0
  int result; // r0
  int v31; // r3
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  const char *v35; // r0
  const char *v36; // r0
  const char *v37; // r0
  const char *v38; // r0
  const char *v39; // r0
  const char *v40; // r0
  const char *v41; // r0
  const char *v42; // r0
  const char *v43; // r0
  const char *v44; // r0
  const char *v45; // r0
  const char *v46; // r0
  const char *v47; // r0
  const char *v48; // r0
  const char *v49; // r0
  const char *v50; // r0
  const char *v51; // r0
  const char *v52; // r0
  const char *v53; // r0
  const char *v54; // r0
  const char *v55; // r0
  const char *v56; // r0
  const char *v57; // r0
  const char *v58; // r0
  const char *v59; // r0
  const char *v60; // r0
  const char *v61; // r0
  const char *v62; // r0
  const char *v63; // r0
  const char *v64; // r0
  const char *v65; // r0
  const char *v66; // r0
  const char *v67; // r0
  const char *v68; // r0
  const char *v69; // r0
  const char *v70; // r0
  const char *v71; // r0
  unsigned int v73; // [sp+18h] [bp-2034h]
  unsigned int v74; // [sp+20h] [bp-202Ch]
  unsigned int v75; // [sp+2Ch] [bp-2020h]
  int useconds; // [sp+30h] [bp-201Ch]
  char v77[4]; // [sp+3Ch] [bp-2010h] BYREF
  int v78; // [sp+40h] [bp-200Ch] BYREF
  int v79; // [sp+44h] [bp-2008h]
  char s[8248]; // [sp+48h] [bp-2004h] BYREF

  v75 = a5;
  v11 = v7;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "fixed step freq_start = %d, freq_end = %d, freq_step = %.2f", a2, a3, v7);
    sub_41DB8(3, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
      sub_2A728(i, 1);
  }
  if ( a2 < a3 )
    v13 = a3 - a2;
  else
    v13 = a2;
  if ( a2 >= a3 )
    v13 -= a3;
  v14 = (unsigned int)(((float)((float)v13 + v7) - 0.01) / v11);
  v73 = v14;
  if ( (v14 & 1) != 0 )
    v73 = v14 + 1;
  v15 = (const char *)sub_27CEC();
  if ( strcmp(v15, "HHB68502") )
  {
    v62 = (const char *)sub_27CEC();
    if ( strcmp(v62, "HHB68501") )
    {
      v63 = (const char *)sub_27CEC();
      if ( strcmp(v63, "HHB68701") )
      {
        v64 = (const char *)sub_27CEC();
        if ( strcmp(v64, "HHB68704") )
        {
          v65 = (const char *)sub_27CEC();
          if ( strcmp(v65, "HHB68703") )
          {
            v66 = (const char *)sub_27CEC();
            if ( strcmp(v66, "H6HB68702") )
            {
              v67 = (const char *)sub_27CEC();
              if ( strcmp(v67, "H1HB68601") )
              {
                v68 = (const char *)sub_27CEC();
                if ( strcmp(v68, "HHB68601") )
                {
                  v69 = (const char *)sub_27CEC();
                  if ( strcmp(v69, "HHB68602") )
                  {
                    v70 = (const char *)sub_27CEC();
                    if ( strcmp(v70, "HHB56611") )
                    {
                      v71 = (const char *)sub_27CEC();
                      if ( strcmp(v71, "HHB68503") )
                        goto LABEL_19;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( a3 <= 0x195 )
    goto LABEL_19;
  v16 = (unsigned int)(((float)((float)(a3 - 402) + v7) - 0.01) / v11);
  v17 = v16 != 0;
  if ( v16 )
    v17 = a5 > a6;
  if ( v17 )
    v74 = sub_962A0(a5 - a6, v16);
  else
LABEL_19:
    v74 = 0;
  if ( v73 )
  {
    v18 = (float)a3;
    v19 = 1;
    useconds = 1000 * a4;
    v20 = (float)a2;
    do
    {
      if ( a1 )
        a1 = 0;
      else
        a1 = 2;
      v78 = 0;
      v79 = 0;
      v21 = (float)v19 * v7;
      if ( a2 >= a3 )
      {
        v22 = v20 - v21;
        if ( v18 > v22 )
          v22 = (float)a3;
      }
      else
      {
        v22 = v20 + v21;
        if ( v18 < v22 )
          v22 = (float)a3;
      }
      for ( j = 0; j != 4; ++j )
      {
        if ( sub_27EC8(j) )
        {
          sub_7F80C((int)&v78, v77, 0);
          BYTE2(v79) = v77[0];
          sub_2A7AC(j, 1, 0, a1, v78, v79);
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "chain = %d set freq to %.2f", j, v22);
            sub_41DB8(3, s, 0);
          }
          dword_BDC5C[j] = (int)v22;
          dword_BDC78[j] = (int)v22;
        }
      }
      v24 = (const char *)sub_27CEC();
      if ( !strcmp(v24, "HHB68502") )
        goto LABEL_33;
      v32 = (const char *)sub_27CEC();
      if ( !strcmp(v32, "HHB68501") )
        goto LABEL_33;
      v33 = (const char *)sub_27CEC();
      if ( !strcmp(v33, "HHB68701") )
        goto LABEL_33;
      v34 = (const char *)sub_27CEC();
      if ( !strcmp(v34, "HHB68704")
        || (v35 = (const char *)sub_27CEC(), !strcmp(v35, "HHB68703"))
        || (v36 = (const char *)sub_27CEC(), !strcmp(v36, "H6HB68702"))
        || (v37 = (const char *)sub_27CEC(), !strcmp(v37, "H1HB68601"))
        || (v38 = (const char *)sub_27CEC(), !strcmp(v38, "HHB68601"))
        || (v39 = (const char *)sub_27CEC(), !strcmp(v39, "HHB68602"))
        || (v40 = (const char *)sub_27CEC(), !strcmp(v40, "HHB56611"))
        || (v41 = (const char *)sub_27CEC(), !strcmp(v41, "HHB68503")) )
      {
LABEL_33:
        if ( v74 && v22 > 405.0 )
        {
          v25 = v75 - v74;
          v75 -= v74;
          if ( a7 )
            sub_21E88(v25, 4u);
          sleep(2u);
        }
      }
      if ( sub_4826C() )
        sleep(5u);
      else
        usleep(useconds);
      for ( k = 0; k != 4; ++k )
      {
        if ( sub_27EC8(k) )
          sub_80BFC((unsigned __int8)k, 0, a1);
      }
      v27 = (const char *)sub_27CEC();
      if ( !strcmp(v27, "HHB68502") )
        goto LABEL_44;
      v42 = (const char *)sub_27CEC();
      if ( !strcmp(v42, "HHB68501") )
        goto LABEL_44;
      v43 = (const char *)sub_27CEC();
      if ( !strcmp(v43, "HHB68701") )
        goto LABEL_44;
      v44 = (const char *)sub_27CEC();
      if ( !strcmp(v44, "HHB68704")
        || (v45 = (const char *)sub_27CEC(), !strcmp(v45, "HHB68703"))
        || (v46 = (const char *)sub_27CEC(), !strcmp(v46, "H6HB68702"))
        || (v47 = (const char *)sub_27CEC(), !strcmp(v47, "H1HB68601"))
        || (v48 = (const char *)sub_27CEC(), !strcmp(v48, "HHB68601"))
        || (v49 = (const char *)sub_27CEC(), !strcmp(v49, "HHB68602"))
        || (v50 = (const char *)sub_27CEC(), !strcmp(v50, "HHB56611"))
        || (v51 = (const char *)sub_27CEC(), !strcmp(v51, "HHB68503")) )
      {
LABEL_44:
        if ( 2 * v73 / 3 == v19 )
          sub_18274();
      }
      ++v19;
    }
    while ( v73 >= v19 );
  }
  for ( m = 0; m != 4; ++m )
  {
    if ( sub_27EC8(m) )
    {
      dword_BDC5C[m] = a3;
      dword_BDC78[m] = a3;
    }
  }
  v29 = (const char *)sub_27CEC();
  result = strcmp(v29, "HHB68502");
  if ( !result )
    goto LABEL_52;
  v52 = (const char *)sub_27CEC();
  result = strcmp(v52, "HHB68501");
  if ( !result )
    goto LABEL_52;
  v53 = (const char *)sub_27CEC();
  result = strcmp(v53, "HHB68701");
  if ( !result )
    goto LABEL_52;
  v54 = (const char *)sub_27CEC();
  result = strcmp(v54, "HHB68704");
  if ( !result )
    goto LABEL_52;
  v55 = (const char *)sub_27CEC();
  result = strcmp(v55, "HHB68703");
  if ( !result )
    goto LABEL_52;
  v56 = (const char *)sub_27CEC();
  result = strcmp(v56, "H6HB68702");
  if ( !result )
    goto LABEL_52;
  v57 = (const char *)sub_27CEC();
  result = strcmp(v57, "H1HB68601");
  if ( !result )
    goto LABEL_52;
  v58 = (const char *)sub_27CEC();
  result = strcmp(v58, "HHB68601");
  if ( !result
    || (v59 = (const char *)sub_27CEC(), (result = strcmp(v59, "HHB68602")) == 0)
    || (v60 = (const char *)sub_27CEC(), (result = strcmp(v60, "HHB56611")) == 0)
    || (v61 = (const char *)sub_27CEC(), (result = strcmp(v61, "HHB68503")) == 0) )
  {
LABEL_52:
    if ( v75 == a6 )
      v31 = 0;
    else
      v31 = a7 & 1;
    if ( v31 )
      return sub_21E88(a6, 4u);
  }
  return result;
}
// 239EC: variable 'v7' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// BDC78: using guessed type _DWORD dword_BDC78[4];

//----- (00024238) --------------------------------------------------------
int __fastcall sub_24238(int a1, int a2, unsigned int a3, unsigned int a4, char a5, int a6)
{
  float v6; // s0
  float v9; // s18
  const char *v10; // r3
  int result; // r0
  unsigned int v12; // r3
  unsigned int v13; // s15
  int v14; // r5
  float v15; // s17
  unsigned int v16; // r4
  float v17; // s19
  float v18; // s16
  bool v19; // zf
  unsigned int v20; // r6
  float v21; // s0
  unsigned int v23; // [sp+20h] [bp-20h]
  _BYTE v24[4]; // [sp+34h] [bp-Ch] BYREF
  int v25; // [sp+38h] [bp-8h] BYREF
  int v26; // [sp+3Ch] [bp-4h]
  char v27[8192]; // [sp+40h] [bp+0h] BYREF

  v9 = v6;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v10 = "false";
    if ( a5 )
      v10 = "true";
    snprintf(
      v27,
      0x2000u,
      "fixed step chain = %d, freq_start = %d, freq_end = %d, freq_step = %.2f, is_higher_voltage = %s\n",
      a1,
      a3,
      a4,
      v6,
      v10);
    sub_41DB8(4, v27, 0);
  }
  result = sub_2A728(a1, 1);
  v25 = 0;
  v26 = 0;
  if ( a3 < a4 )
    v12 = a4 - a3;
  else
    v12 = a3;
  if ( a3 >= a4 )
    v12 -= a4;
  v13 = (unsigned int)(((float)((float)v12 + v6) - 0.01) / v6);
  v23 = v13;
  if ( (v13 & 1) != 0 )
    v23 = v13 + 1;
  if ( v23 )
  {
    v14 = 0;
    v15 = (float)a4;
    v16 = 1;
    v17 = (float)a3;
    do
    {
      v21 = (float)v16 * v9;
      if ( a3 < a4 )
      {
        v18 = v21 + v17;
        if ( (float)(v21 + v17) > v15 )
          v18 = (float)a4;
      }
      else
      {
        v18 = v17 - v21;
        if ( (float)(v17 - v21) < v15 )
          v18 = (float)a4;
      }
      v19 = v14 == 0;
      v14 = 0;
      v20 = 0;
      if ( v19 )
      {
        v14 = 2;
        v20 = 2;
      }
      ++v16;
      sub_7F80C((int)&v25, v24, 0);
      BYTE2(v26) = v24[0];
      sub_2A7AC(a1, 1, 0, v20, v25, v26);
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(v27, 0x2000u, "chain = %d set freq to %.2f", a1, v18);
        sub_41DB8(4, v27, 0);
      }
      usleep(1000 * a6);
      result = sub_80BFC((unsigned __int8)a1, 0, v20);
    }
    while ( v23 >= v16 );
  }
  if ( byte_BDC88 )
  {
    dword_BDC5C[a1] = a4;
    dword_BDC5C[a1 + 7] = a4;
  }
  return result;
}
// 24270: variable 'v6' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// BDC88: using guessed type char byte_BDC88;

//----- (000244C0) --------------------------------------------------------
int __fastcall sub_244C0(
        int a1,
        int a2,
        unsigned int *a3,
        int a4,
        unsigned int *a5,
        int a6,
        unsigned __int8 a7,
        int a8)
{
  unsigned int *v9; // r5
  unsigned int v10; // r6
  int i; // r4
  unsigned int v12; // r3
  int j; // r4
  int v14; // r2
  int k; // r4
  int v16; // r3
  char s[8232]; // [sp+18h] [bp-2004h] BYREF

  if ( *a3 != *(_DWORD *)a6 )
  {
    if ( *a5 > 1 )
    {
      v9 = a3;
      v10 = 1;
      do
      {
        for ( i = 0; i != 4; ++i )
        {
          if ( sub_27EC8(i) )
          {
            v12 = v9[1];
            if ( *(_DWORD *)(a1 + 4 * i) >= v12 )
            {
              if ( (unsigned int)off_BC5EC > 3 )
              {
                snprintf(s, 0x2000u, "2.chain_%d inc freq to %d\n", i, v9[1]);
                sub_41DB8(3, s, 0);
                v12 = v9[1];
              }
              sub_24238(i, a7, *v9, v12, 0, a8);
            }
          }
        }
        ++v10;
        ++v9;
      }
      while ( *a5 > v10 );
    }
    for ( j = 0; j != 4; ++j )
    {
      if ( sub_27EC8(j) )
      {
        v14 = *(_DWORD *)(a1 + 4 * j);
        if ( v14 != *(_DWORD *)(a2 + 4 * j) )
        {
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "3.chain %d min = %d, max = %d", j, v14, *(_DWORD *)(a2 + 4 * j));
            sub_41DB8(3, s, 0);
            v14 = *(_DWORD *)(a1 + 4 * j);
          }
          sub_227C4(j, (unsigned int *)(a4 + (j << 10)), v14);
        }
      }
    }
  }
  for ( k = 0; k != 4; ++k )
  {
    if ( sub_27EC8(k) )
    {
      v16 = dword_4D41A4[k];
      dword_BDC5C[k] = v16;
      dword_BDC78[k] = v16;
    }
  }
  return *(_DWORD *)a6;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// BDC78: using guessed type _DWORD dword_BDC78[4];
// 4D41A4: using guessed type int dword_4D41A4[4];

//----- (000246E8) --------------------------------------------------------
unsigned int __fastcall sub_246E8(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // r8
  size_t v4; // r9
  int v5; // r4
  unsigned int *v6; // r5
  int i; // r6
  int j; // r4
  unsigned int v9; // r3
  int k; // r4
  int v11; // r2
  unsigned int *v13; // r5
  unsigned int *v14; // r3
  int v15; // r0
  int v16; // r1
  unsigned int *v17; // r0
  unsigned int *v18; // r2
  unsigned int v19; // t1
  unsigned int v20; // r5
  unsigned int v21; // r0
  _DWORD v25[3]; // [sp+1Ch] [bp-Ch] BYREF
  _DWORD v26[4]; // [sp+28h] [bp+0h] BYREF
  unsigned int v27[4]; // [sp+38h] [bp+10h] BYREF
  _DWORD base[4]; // [sp+48h] [bp+20h] BYREF
  unsigned int s[1025]; // [sp+58h] [bp+30h] BYREF

  v3 = 0;
  v4 = 0;
  v5 = 0;
  memset(v25, 0, sizeof(v25));
  memset(s, 0, 0x1000u);
  memset(v27, 0, sizeof(v27));
  memset(base, 0, sizeof(base));
  memset(v26, 255, sizeof(v26));
  do
  {
    if ( sub_27EC8(v5) )
    {
      v13 = (unsigned int *)(a1 + (v5 << 10));
      sub_22750(v13, &v26[v5], &v27[v5], v25);
      v14 = &s[v4++];
      if ( v3 < v27[v5] )
        v3 = v27[v5];
      *(v14 - 4) = v26[v5];
      v15 = sub_27D1C();
      if ( v15 )
      {
        v16 = v26[v5];
        v17 = &v13[v15];
        v18 = &s[256 * v5];
        do
        {
          v19 = *v13++;
          *v18++ = v19 - v16;
        }
        while ( v13 != v17 );
      }
      if ( dword_BC898[0] == 2 )
        dword_BDC5C[v5] = dword_4D4180;
      v20 = v25[0];
      v21 = sub_27D1C();
      dword_BDC78[v5] = sub_962A0(v20, v21);
    }
    ++v5;
  }
  while ( v5 != 4 );
  qsort(base, v4, 4u, (__compar_fn_t)sub_22740);
  sub_23590(255, a2, a3);
  if ( base[0] != v3 )
  {
    if ( v4 > 1 )
    {
      v6 = base;
      for ( i = 1; i != v4; ++i )
      {
        for ( j = 0; j != 4; ++j )
        {
          if ( sub_27EC8(j) )
          {
            v9 = v6[1];
            if ( v26[j] >= v9 )
              sub_24238(j, a2, *v6, v9, a3, 100);
          }
        }
        ++v6;
      }
    }
    for ( k = 0; k != 4; ++k )
    {
      if ( sub_27EC8(k) )
      {
        v11 = v26[k];
        if ( v11 != v27[k] )
          sub_227C4(k, &s[256 * k], v11);
      }
    }
  }
  return v3;
}
// BC898: using guessed type int dword_BC898[];
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// BDC78: using guessed type _DWORD dword_BDC78[4];
// 4D4180: using guessed type int dword_4D4180;

//----- (00024974) --------------------------------------------------------
int __fastcall sub_24974(int a1, unsigned int a2, int a3)
{
  _BYTE v7[4]; // [sp+Ch] [bp-2004h] BYREF
  int s; // [sp+10h] [bp-2000h] BYREF
  int v9; // [sp+14h] [bp-1FFCh]

  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf((char *)&s, 0x2000u, "chain = %d, freq = %d\n", a1, a3);
    sub_41DB8(3, (const char *)&s, 0);
  }
  s = 0;
  v9 = 0;
  sub_7F80C((int)&s, v7, 0);
  BYTE2(v9) = v7[0];
  sub_2A7AC(a1, 1, 0, a2, s, v9);
  dword_BDC5C[a1] = a3;
  dword_BDC5C[a1 + 7] = a3;
  usleep(0xC350u);
  return sub_80BFC((unsigned __int8)a1, 0, a2);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];

//----- (00024A50) --------------------------------------------------------
int __fastcall sub_24A50(int a1, int a2, unsigned int a3, int a4)
{
  int v8; // r5
  char v9; // r0
  int v10; // r0
  unsigned __int8 v13; // [sp+10h] [bp-2008h]
  _BYTE v14[4]; // [sp+14h] [bp-2004h] BYREF
  int s; // [sp+18h] [bp-2000h] BYREF
  int v16; // [sp+1Ch] [bp-1FFCh]

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf((char *)&s, 0x2000u, "chain = %d, asic = %d, pll_id = %d, freq = %d\n", a1, a2, a3, a4);
    sub_41DB8(4, (const char *)&s, 0);
  }
  v8 = 0;
  s = 0;
  v16 = 0;
  sub_7F80C((int)&s, v14, 0);
  BYTE2(v16) = v14[0];
  if ( a2 == 255 )
  {
    sub_2A7AC(a1, 1, 0, a3, s, v16);
    dword_BDC5C[a1] = a4;
    dword_BDC5C[a1 + 7] = a4;
    while ( sub_27D1C() > v8++ )
      dword_54F3D0[256 * a1 + 255] = a4;
  }
  else
  {
    v9 = sub_27D8C();
    sub_2A7AC(a1, 0, (unsigned __int8)(v9 * a2), a3, s, v16);
    dword_54F3D0[256 * a1 + a2] = a4;
  }
  usleep(0xC350u);
  v13 = sub_4A75C(4u);
  v10 = sub_27D8C();
  return sub_80BF0((unsigned __int8)a1, a2 * v10, v13, a3);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// 54F3D0: using guessed type _DWORD dword_54F3D0[1024];

//----- (00024BC4) --------------------------------------------------------
int sub_24BC4()
{
  unsigned int v0; // r5
  int i; // r4
  int v3; // r5
  unsigned int v4; // [sp+4h] [bp-Ch] BYREF
  unsigned int v5; // [sp+8h] [bp-8h] BYREF
  int v6; // [sp+Ch] [bp-4h] BYREF

  if ( dword_BC898[0] == 2 )
  {
    v3 = dword_4D4180;
    if ( (unsigned int)dword_4D4180 < 0x32 )
      return 50;
    return v3;
  }
  else
  {
    v0 = 50;
    for ( i = 0; i != 4; ++i )
    {
      if ( sub_27EC8(i) )
      {
        sub_22750(&dword_54F3D0[256 * i], &v4, &v5, &v6);
        if ( v0 < v5 )
          v0 = v5;
      }
    }
    return v0;
  }
}
// BC898: using guessed type int dword_BC898[];
// 4D4180: using guessed type int dword_4D4180;
// 54F3D0: using guessed type _DWORD dword_54F3D0[1024];

//----- (00024C5C) --------------------------------------------------------
int __fastcall sub_24C5C(unsigned int a1, unsigned int a2, int a3)
{
  int v3; // r4
  float v4; // s16
  char s[8192]; // [sp+10h] [bp-2000h] BYREF

  v3 = (unsigned __int8)byte_4D4190;
  if ( byte_4D4190 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "stop mining %s", "inc_freq_delay");
      sub_41DB8(3, s, 0);
    }
    while ( 1 )
      sleep(0xAu);
  }
  v4 = (float)a3;
  while ( v3++ != 5 && flt_C47BC < v4 )
  {
    sub_44890();
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(
        s,
        0x2000u,
        "inc_freq to %d timeout spend %ds, wait target temp:%d failed, real_temp=%.2f",
        a1,
        v3,
        a3,
        flt_C47BC);
      sub_41DB8(4, s, 0);
    }
  }
  sub_23998((unsigned __int8)byte_4D4184, a1, a2, 1000, 0, 0, 0);
  return sub_44890();
}
// BC5C4: using guessed type float flt_BC5C4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C47BC: using guessed type float flt_C47BC;
// 4D4184: using guessed type char byte_4D4184;
// 4D4190: using guessed type char byte_4D4190;

//----- (00024DC4) --------------------------------------------------------
unsigned int __fastcall sub_24DC4(signed int a1, signed int a2, int a3, int a4, unsigned __int8 a5)
{
  int v7; // r5
  int v8; // r3
  int v9; // lr
  int *v10; // r9
  int v11; // r12
  int v12; // r4
  int v13; // r8
  int i; // r3
  signed int v15; // r2
  signed int v16; // t1
  int v17; // r11
  int v18; // r9
  char *v19; // r3
  unsigned int *v20; // r8
  bool v21; // cc
  unsigned int v22; // r0
  int v23; // r2
  unsigned int v24; // t1
  char *v25; // r4
  unsigned int result; // r0
  bool v27; // zf
  int v28; // r11
  int v29; // [sp+10h] [bp-209Ch]
  void *v31; // [sp+20h] [bp-208Ch]
  _DWORD v32[15]; // [sp+28h] [bp-2084h]
  int v33; // [sp+64h] [bp-2048h] BYREF
  _DWORD v34[16]; // [sp+68h] [bp-2044h] BYREF
  char v35[8196]; // [sp+A8h] [bp-2004h] BYREF

  v31 = off_BC5EC;
  if ( a5 )
  {
    v7 = a3;
    v8 = (a3 - a4) / 10;
    if ( v8 < 10 )
      v8 = 10;
    v29 = v8;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(
        v35,
        0x2000u,
        "tuning_frequency from freq %d to freq %d, set vol to target voltage=%d, vol_cur=%d, vol_step=%d",
        a1,
        a2,
        a4,
        a3,
        v8);
      sub_41DB8(3, v35, 0);
      v31 = off_BC5EC;
    }
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v35, 0x2000u, "tuning_frequency from freq %d to freq %d, end_vol=%d, not set vol", a1, a2, a4);
    v7 = a5;
    v29 = a5;
    sub_41DB8(3, v35, a5);
    v31 = off_BC5EC;
  }
  else
  {
    v7 = a5;
    v29 = a5;
  }
  v9 = 0;
  v10 = &v33;
  v11 = 0;
  v32[0] = *(_DWORD *)")";
  v32[1] = *(_DWORD *)",";
  v32[2] = *(_DWORD *)"/";
  v32[3] = *(_DWORD *)"2";
  v32[4] = *(_DWORD *)"3";
  v32[5] = *(_DWORD *)"4";
  v32[6] = *(_DWORD *)"5";
  v32[7] = *(_DWORD *)"6";
  v32[8] = *(_DWORD *)"7";
  v32[9] = *(_DWORD *)"8";
  v32[10] = *(_DWORD *)"9";
  v32[11] = *(_DWORD *)":";
  v32[12] = *(_DWORD *)";";
  v32[13] = *(_DWORD *)"<";
  v32[14] = *(_DWORD *)"=";
  v33 = *(_DWORD *)">";
  v12 = 0;
  v34[0] = *(_DWORD *)"2";
  v34[1] = 150;
  v34[2] = 200;
  v34[3] = 250;
  v34[4] = 270;
  v34[5] = 290;
  v34[6] = 310;
  v34[7] = 330;
  v34[8] = 350;
  v34[9] = 370;
  v34[10] = 390;
  v34[11] = 410;
  v13 = 0;
  v34[12] = 430;
  v34[13] = 450;
  v34[14] = 470;
  v34[15] = 490;
  for ( i = 0; i != 16; ++i )
  {
    v16 = v10[1];
    ++v10;
    v15 = v16;
    if ( v16 <= a1 )
    {
      v13 = i;
      v11 = 1;
    }
    if ( v15 <= a2 )
      v12 = i;
    if ( v15 <= a2 )
      v9 = 1;
  }
  v17 = v11 ^ 1 | v9 ^ 1;
  if ( !v17 )
  {
    if ( (unsigned int)v31 <= 3 )
      goto LABEL_29;
    goto LABEL_28;
  }
  v12 = 2;
  if ( (unsigned int)v31 > 3 )
  {
    snprintf(v35, 0x2000u, "not find freq, set default freq start = %d, end = %d", 0, 2);
    v13 = 0;
    sub_41DB8(3, v35, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
    {
      v18 = 1;
      goto LABEL_19;
    }
LABEL_28:
    snprintf(v35, 0x2000u, "start = %d, end = %d", v13, v12);
    sub_41DB8(3, v35, 0);
LABEL_29:
    if ( v13 >= v12 )
      goto LABEL_30;
    goto LABEL_18;
  }
  v13 = 0;
LABEL_18:
  v18 = v13 + 1;
  v17 = v13 + 1;
LABEL_19:
  v19 = &v35[4 * v13];
  v20 = &v34[v18];
  sub_24C5C(a1, v34[v17], *((_DWORD *)v19 - 32));
  if ( !a5 )
    goto LABEL_24;
LABEL_20:
  v21 = v29 <= 0;
  if ( v29 )
    v21 = (int)*v20 <= 329;
  if ( !v21 )
  {
    v28 = 2;
    do
    {
      v21 = v29 + a4 < v7;
      v7 -= v29;
      if ( !v21 )
        v7 = a4;
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(v35, 0x2000u, "set voltage to=%d", v7);
        sub_41DB8(4, v35, 0);
      }
      sub_21E88(v7, 3u);
      sub_44890();
      v27 = v28 == 1;
      v28 = 1;
    }
    while ( !v27 );
  }
LABEL_24:
  while ( v18 < v12 )
  {
    v22 = *v20;
    v23 = v32[v18++];
    v24 = v20[1];
    ++v20;
    sub_24C5C(v22, v24, v23);
    if ( a5 )
      goto LABEL_20;
  }
LABEL_30:
  v25 = &v35[4 * v12];
  result = *((_DWORD *)v25 - 16);
  v27 = result == a2;
  if ( result != a2 )
    v27 = a1 == a2;
  if ( !v27 )
    result = sub_24C5C(result, a2, *((_DWORD *)v25 - 32));
  if ( a5 )
  {
    for ( ; v7 > v29 + a4; result = sub_44890() )
    {
      v7 -= v29;
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(v35, 0x2000u, "set voltage to=%d", v7);
        sub_41DB8(4, v35, 0);
      }
      sub_21E88(v7, 3u);
    }
    if ( a4 != v7 )
    {
      sub_21E88(a4, 3u);
      result = sub_44890();
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(v35, 0x2000u, "set voltage to=%d, end_freq=%d", a4, a2);
        return sub_41DB8(4, v35, 0);
      }
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00025260) --------------------------------------------------------
unsigned int __fastcall sub_25260(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // r11
  size_t v5; // r10
  int v6; // r4
  int v7; // r7
  int v8; // r2
  int v9; // r3
  unsigned int *v10; // r5
  int i; // r4
  unsigned int v12; // r3
  int j; // r4
  int v14; // r2
  unsigned int v15; // r3
  unsigned int v16; // r3
  unsigned int *v18; // r5
  unsigned int v19; // r1
  void *v20; // r2
  _BYTE *v21; // r3
  unsigned int v22; // r12
  int v23; // r0
  unsigned int v24; // r1
  unsigned int *v25; // r0
  _DWORD *v26; // r2
  unsigned int v27; // t1
  unsigned int v28; // r5
  unsigned int v29; // r0
  _DWORD v33[3]; // [sp+24h] [bp-3040h] BYREF
  unsigned int v34[4]; // [sp+30h] [bp-3034h] BYREF
  unsigned int v35[4]; // [sp+40h] [bp-3024h] BYREF
  signed int base[4]; // [sp+50h] [bp-3014h] BYREF
  _BYTE s[4096]; // [sp+60h] [bp-3004h] BYREF
  char v38[8196]; // [sp+1060h] [bp-2004h] BYREF

  v4 = 0;
  v5 = 0;
  v6 = 0;
  memset(v33, 0, sizeof(v33));
  memset(s, 0, sizeof(s));
  memset(v35, 0, sizeof(v35));
  memset(base, 0, sizeof(base));
  memset(v34, 255, sizeof(v34));
  do
  {
    if ( sub_27EC8(v6) )
    {
      v18 = (unsigned int *)(a1 + (v6 << 10));
      sub_22750(v18, &v34[v6], &v35[v6], v33);
      v19 = v35[v6];
      v20 = off_BC5EC;
      v21 = &s[4 * v5];
      v22 = v34[v6];
      ++v5;
      if ( v4 < v19 )
        v4 = v35[v6];
      *((_DWORD *)v21 - 4) = v22;
      if ( (unsigned int)v20 > 4 )
      {
        snprintf(v38, 0x2000u, "chain[%d] min = %d max =%d\n", v6, v22, v19);
        sub_41DB8(4, v38, 0);
      }
      v23 = sub_27D1C();
      if ( v23 )
      {
        v24 = v34[v6];
        v25 = &v18[v23];
        v26 = &s[1024 * v6];
        do
        {
          v27 = *v18++;
          *v26++ = v27 - v24;
        }
        while ( v18 != v25 );
      }
      if ( dword_BC898[0] == 2 )
        dword_BDC5C[v6] = dword_4D4180;
      v28 = v33[0];
      v29 = sub_27D1C();
      dword_BDC78[v6] = sub_962A0(v28, v29);
    }
    ++v6;
  }
  while ( v6 != 4 );
  qsort(base, v5, 4u, (__compar_fn_t)sub_22740);
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v38, 0x2000u, "1.inc all chain freq to %d\n", base[0]);
    sub_41DB8(4, v38, 0);
  }
  v7 = 1;
  v8 = sub_2242C();
  v9 = dword_4D419C + dword_4D41BC;
  if ( dword_4D419C + dword_4D41BC >= 2150 )
    v9 = 2150;
  sub_24DC4(50, base[0], v8, v9, 1u);
  if ( base[0] != v4 )
  {
    if ( v5 > 1 )
    {
      v10 = (unsigned int *)base;
      do
      {
        for ( i = 0; i != 4; ++i )
        {
          if ( sub_27EC8(i) )
          {
            v12 = v10[1];
            if ( v34[i] >= v12 )
            {
              if ( (unsigned int)off_BC5EC > 4 )
              {
                snprintf(v38, 0x2000u, "2.chain_%d inc freq to %d\n", i, v10[1]);
                sub_41DB8(4, v38, 0);
                v12 = v10[1];
              }
              sub_24238(i, a2, *v10, v12, 0, a4);
            }
          }
        }
        ++v7;
        ++v10;
      }
      while ( v5 != v7 );
    }
    for ( j = 0; j != 4; ++j )
    {
      if ( sub_27EC8(j) )
      {
        v14 = v34[j];
        v15 = v35[j];
        if ( v14 != v15 )
        {
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(v38, 0x2000u, "3.chain %d min = %d, max = %d", j, v34[j], v15);
            sub_41DB8(4, v38, 0);
            v14 = v34[j];
          }
          sub_227C4(j, (unsigned int *)&s[1024 * j], v14);
          v16 = v35[j];
          dword_BDC5C[j] = v16;
          dword_BDC78[j] = v16;
        }
      }
    }
  }
  return v4;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898[];
// BDC5C: using guessed type _DWORD dword_BDC5C[4];
// BDC78: using guessed type _DWORD dword_BDC78[4];
// 4D4180: using guessed type int dword_4D4180;
// 4D419C: using guessed type int dword_4D419C;
// 4D41BC: using guessed type int dword_4D41BC;

//----- (0002565C) --------------------------------------------------------
int __fastcall sub_2565C(signed int *a1, int a2, int a3)
{
  signed int v5; // r1
  int v6; // r3
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v5 = *a1;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "1.inc all chain freq to %d", *a1);
    sub_41DB8(3, s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "start_vol :%d end_vol %d", a2, a3);
      sub_41DB8(3, s, 0);
    }
    v5 = *a1;
  }
  v6 = 2150;
  if ( a3 < 2150 )
    v6 = a3;
  sub_24DC4(50, v5, a2, v6, 0);
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00025724) --------------------------------------------------------
int __fastcall sub_25724(int a1, int a2)
{
  int result; // r0
  _DWORD s[259]; // [sp+4h] [bp-2410h] BYREF
  char v6[8176]; // [sp+410h] [bp-2004h] BYREF

  memset(s, 0, sizeof(s));
  if ( !sub_1C4E8(a1, (int)s) )
    return s[a2 + 2];
  result = dword_4D4180;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v6, 0x2000u, "can not find sweep in eeprom,test return %d", dword_4D4180);
    sub_41DB8(4, v6, 0);
    return dword_4D4180;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 4D4180: using guessed type int dword_4D4180;

//----- (000257E0) --------------------------------------------------------
int __fastcall sub_257E0(int result, int a2)
{
  unsigned int v3; // r6
  unsigned __int8 v4; // r4
  int v5; // r0
  int v6; // [sp+Ch] [bp-14h] BYREF

  if ( (unsigned __int8)byte_4D4184 <= 2u )
  {
    v3 = (unsigned __int8)aIncMixedFreqPr[(unsigned __int8)byte_4D4184 + 168];
    v4 = result;
    v5 = sub_27D8C();
    return sub_813D8(1, v4, a2 * v5, v3, &v6);
  }
  return result;
}
// 4D4184: using guessed type char byte_4D4184;

//----- (000258B8) --------------------------------------------------------
int __fastcall sub_258B8(int a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6)
{
  float v6; // s0
  float v11; // s18
  int result; // r0
  unsigned int v13; // r3
  unsigned int v14; // r5
  float v15; // s17
  float v16; // s19
  float v17; // s16
  char v18; // r0
  int v19; // r0
  int v20; // r0
  float v21; // s0
  int v22; // [sp+4h] [bp-2030h]
  unsigned int v23; // [sp+10h] [bp-2024h]
  _BYTE v24[4]; // [sp+24h] [bp-2010h] BYREF
  int v25; // [sp+28h] [bp-200Ch] BYREF
  int v26; // [sp+2Ch] [bp-2008h]
  __int16 s; // [sp+30h] [bp-2004h] BYREF
  char v28; // [sp+32h] [bp-2002h]

  v11 = v6;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(
      (char *)&s,
      0x2000u,
      "%s, chain %d asic %d set freq from %d to %d",
      "adjust_asic_freq_with_fixed_step",
      a1,
      a2,
      a4,
      a5);
    sub_41DB8(4, (const char *)&s, 0);
  }
  sub_27D8C();
  result = sub_2A728(a1, 0);
  v25 = 0;
  v26 = 0;
  if ( a4 >= a5 )
    v13 = a4 - a5;
  else
    v13 = a5 - a4;
  v23 = (unsigned int)(((float)((float)v13 + v6) - 0.01) / v6);
  if ( v23 )
  {
    v14 = 1;
    v15 = (float)a5;
    v16 = (float)a4;
    do
    {
      v21 = (float)v14 * v11;
      if ( a4 < a5 )
      {
        v17 = v21 + v16;
        if ( (float)(v21 + v16) > v15 )
          v17 = (float)a5;
      }
      else
      {
        v17 = v16 - v21;
        if ( (float)(v16 - v21) < v15 )
          v17 = (float)a5;
      }
      sub_7F80C((int)&v25, v24, 0);
      ++v14;
      BYTE2(v26) = v24[0];
      v18 = sub_27D8C();
      sub_2A7AC(a1, 0, (unsigned __int8)(v18 * a2), a3, v25, v26);
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf((char *)&s, 0x2000u, "chain %d asic %d set freq to %.2f", a1, a2, v22, v17);
        sub_41DB8(4, (const char *)&s, 0);
      }
      usleep(1000 * a6);
      v19 = sub_4A75C(4u);
      v28 = BYTE2(v19);
      s = v19;
      v20 = sub_27D8C();
      result = sub_80BF0((unsigned __int8)a1, a2 * v20, (unsigned __int8)s, a3);
    }
    while ( v23 >= v14 );
  }
  return result;
}
// 258E4: variable 'v6' is possibly undefined
// 25ABC: variable 'v22' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00025BF0) --------------------------------------------------------
int __fastcall sub_25BF0(_DWORD *a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r5
  void *v3; // r3
  _DWORD *v4; // r0
  void *v5; // r3
  const char *v7; // r0
  char v8[8196]; // [sp+0h] [bp-2004h] BYREF

  v1 = (_DWORD *)sub_7C250(a1, "processor");
  v2 = v1;
  if ( !v1 )
  {
    v3 = off_BC5EC;
    goto LABEL_12;
  }
  v3 = off_BC5EC;
  if ( *v1 )
  {
LABEL_12:
    if ( (unsigned int)v3 <= 3 )
      return -1;
    strcpy(v8, "get processor failed\n");
    sub_41DB8(3, v8, 0);
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v8, "processor:\n");
    sub_41DB8(4, v8, 0);
  }
  v4 = (_DWORD *)sub_7C250(v2, "type");
  if ( !v4 )
  {
    v5 = off_BC5EC;
    goto LABEL_8;
  }
  v5 = off_BC5EC;
  if ( *v4 != 2 )
  {
LABEL_8:
    if ( (unsigned int)v5 > 3 )
    {
      strcpy(v8, "get type failed\n");
      sub_41DB8(3, v8, 0);
    }
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v7 = (const char *)sub_7DA40(v4);
    snprintf(v8, 0x2000u, "type: %s\n", v7);
    sub_41DB8(4, v8, 0);
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00025D60) --------------------------------------------------------
void __fastcall sub_25D60(int a1)
{
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0
  void *v8; // r0
  int v9; // r6
  int v10; // r4

  v2 = *(void **)a1;
  if ( v2 )
  {
    free(v2);
    *(_DWORD *)a1 = 0;
  }
  v3 = *(void **)(a1 + 164);
  if ( v3 )
  {
    free(v3);
    *(_DWORD *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 160) = 0;
  }
  v4 = *(void **)(a1 + 112);
  if ( v4 )
  {
    free(v4);
    *(_DWORD *)(a1 + 112) = 0;
  }
  v5 = *(void **)(a1 + 120);
  if ( v5 )
  {
    free(v5);
    *(_DWORD *)(a1 + 120) = 0;
  }
  v6 = *(void **)(a1 + 72);
  if ( v6 )
  {
    free(v6);
    *(_DWORD *)(a1 + 72) = 0;
  }
  v7 = *(void **)(a1 + 80);
  if ( v7 )
  {
    free(v7);
    *(_DWORD *)(a1 + 80) = 0;
  }
  v8 = *(void **)(a1 + 88);
  if ( v8 )
  {
    free(v8);
    *(_DWORD *)(a1 + 88) = 0;
  }
  if ( *(int *)(a1 + 16) > 0 )
  {
    v9 = 0;
    do
    {
      v10 = *(_DWORD *)(a1 + 68) + 32 * v9++;
      free(*(void **)(v10 + 12));
      free(*(void **)(v10 + 8));
      *(_DWORD *)(v10 + 12) = 0;
      *(_DWORD *)(v10 + 8) = 0;
    }
    while ( v9 < *(_DWORD *)(a1 + 16) );
  }
  free(*(void **)(a1 + 68));
  *(_DWORD *)(a1 + 68) = 0;
}

//----- (00025E6C) --------------------------------------------------------
int __fastcall sub_25E6C(_DWORD *a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r5
  void *v3; // r3
  _DWORD *v4; // r0
  void *v5; // r3
  int v6; // r3
  _DWORD *v8; // r0
  _DWORD *v9; // r6
  void *v10; // r3
  const char *v11; // r0
  int v12; // r0
  const char *v13; // r0
  _DWORD *v14; // r0
  int v15; // r7
  void *v16; // r3
  const char *v17; // r0
  int v18; // r0
  _DWORD *v19; // r0
  int v20; // r7
  void *v21; // r3
  const char *v22; // r12
  int v23; // r0
  int v24; // r1
  int v25; // r2
  int v26; // r3
  _DWORD *v27; // r12
  int v28; // r1
  int v29; // r2
  int v30; // r3
  int v31; // r0
  _DWORD *v32; // r0
  int v33; // r7
  _DWORD *v34; // r0
  int v35; // r7
  int v36; // r0
  int v37; // r0
  _DWORD *v38; // r0
  int v39; // r5
  int v40; // r0
  int v41; // r0
  _DWORD v42[2049]; // [sp+0h] [bp-2004h] BYREF

  v1 = (_DWORD *)sub_7C250(a1, "asic");
  v2 = v1;
  if ( v1 )
  {
    v3 = off_BC5EC;
    if ( !*v1 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        strcpy((char *)v42, "asic:\n");
        sub_41DB8(4, (const char *)v42, 0);
      }
      v4 = (_DWORD *)sub_7C250(v2, "asic_id");
      if ( !v4 )
      {
        v5 = off_BC5EC;
        goto LABEL_8;
      }
      v5 = off_BC5EC;
      if ( *v4 != 2 )
      {
LABEL_8:
        if ( (unsigned int)v5 > 3 )
        {
          strcpy((char *)v42, "get asic_id failed\n");
          sub_41DB8(3, (const char *)v42, 0);
          return -1;
        }
        return -1;
      }
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v13 = (const char *)sub_7DA40(v4);
        snprintf((char *)v42, 0x2000u, "asic_id: %s\n", v13);
        sub_41DB8(4, (const char *)v42, 0);
      }
      v8 = (_DWORD *)sub_7C250(v2, "asic_addr");
      v9 = v8;
      if ( !v8 )
      {
        v10 = off_BC5EC;
        goto LABEL_20;
      }
      v10 = off_BC5EC;
      if ( *v8 != 2 )
      {
LABEL_20:
        if ( (unsigned int)v10 > 3 )
        {
          strcpy((char *)v42, "get asic_addr failed\n");
          sub_41DB8(3, (const char *)v42, 0);
          return -1;
        }
        return -1;
      }
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v17 = (const char *)sub_7DA40(v8);
        snprintf((char *)v42, 0x2000u, "asic_addr : %s\n", v17);
        sub_41DB8(4, (const char *)v42, 0);
      }
      v11 = (const char *)sub_7DA40(v9);
      v12 = strtol(v11, 0, 0);
      dword_65B2E4 = v12;
      if ( !v12 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy((char *)v42, "convert asic_addr failed\n");
          sub_41DB8(3, (const char *)v42, 0);
          return -1;
        }
        return -1;
      }
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf((char *)v42, 0x2000u, "asic_addr 0x%x\n", v12);
        sub_41DB8(4, (const char *)v42, 0);
      }
      v14 = (_DWORD *)sub_7C250(v2, "asic_core_num");
      v15 = (int)v14;
      if ( !v14 )
      {
        v16 = off_BC5EC;
        goto LABEL_32;
      }
      v16 = off_BC5EC;
      if ( *v14 != 3 )
      {
LABEL_32:
        if ( (unsigned int)v16 > 3 )
        {
          strcpy((char *)v42, "get asic_core_num failed\n");
          sub_41DB8(3, (const char *)v42, 0);
          return -1;
        }
        return -1;
      }
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v18 = sub_7DF10((int)v14);
        snprintf((char *)v42, 0x2000u, "asic_core_num: %d\n", v18);
        sub_41DB8(4, (const char *)v42, 0);
      }
      dword_65B2E8 = sub_7DF10(v15);
      v19 = (_DWORD *)sub_7C250(v2, "asic_small_core_num");
      v20 = (int)v19;
      if ( v19 )
      {
        v21 = off_BC5EC;
        if ( *v19 == 3 )
        {
          if ( (unsigned int)off_BC5EC > 4 )
          {
            v31 = sub_7DF10((int)v19);
            snprintf((char *)v42, 0x2000u, "asic_small_core_num: %d\n", v31);
            sub_41DB8(4, (const char *)v42, 0);
          }
          dword_65B2EC = sub_7DF10(v20);
          v32 = (_DWORD *)sub_7C250(v2, "core_small_core_num");
          v33 = (int)v32;
          if ( v32 && *v32 == 3 )
          {
            if ( (unsigned int)off_BC5EC > 4 )
            {
              v36 = sub_7DF10((int)v32);
              snprintf((char *)v42, 0x2000u, "core_small_core_num: %d\n", v36);
              sub_41DB8(4, (const char *)v42, 0);
            }
            dword_65B2F0 = sub_7DF10(v33);
            v34 = (_DWORD *)sub_7C250(v2, "asic_domain_num");
            v35 = (int)v34;
            if ( v34 && *v34 == 3 )
            {
              if ( (unsigned int)off_BC5EC > 4 )
              {
                v37 = sub_7DF10((int)v34);
                snprintf((char *)v42, 0x2000u, "asic_domain_num : %d\n", v37);
                sub_41DB8(4, (const char *)v42, 0);
              }
              dword_65B2F4 = sub_7DF10(v35);
              v38 = (_DWORD *)sub_7C250(v2, "asic_addr_interval");
              v39 = (int)v38;
              if ( v38 && *v38 == 3 )
              {
                if ( (unsigned int)off_BC5EC > 4 )
                {
                  v40 = sub_7DF10((int)v38);
                  snprintf((char *)v42, 0x2000u, "asic_addr_interval : %d\n", v40);
                  sub_41DB8(4, (const char *)v42, 0);
                }
                v41 = sub_7DF10(v39);
                v6 = 0;
                dword_65B2F8 = v41;
                return v6;
              }
              if ( (unsigned int)off_BC5EC > 3 )
              {
                strcpy((char *)v42, "get asic_addr_interval failed\n");
                sub_41DB8(3, (const char *)v42, 0);
                return -1;
              }
              return -1;
            }
            if ( (unsigned int)off_BC5EC <= 3 )
              return -1;
            strcpy((char *)v42, "get asic_domain_num failed\n");
LABEL_43:
            sub_41DB8(3, (const char *)v42, 0);
            return -1;
          }
          if ( (unsigned int)off_BC5EC <= 3 )
            return -1;
          v22 = "get core_small_core_num failed\n";
LABEL_42:
          v23 = *(_DWORD *)v22;
          v24 = *((_DWORD *)v22 + 1);
          v25 = *((_DWORD *)v22 + 2);
          v26 = *((_DWORD *)v22 + 3);
          v27 = v22 + 16;
          v42[0] = v23;
          v42[1] = v24;
          v42[2] = v25;
          v42[3] = v26;
          v28 = v27[1];
          v29 = v27[2];
          v30 = v27[3];
          v42[4] = *v27;
          v42[5] = v28;
          v42[6] = v29;
          v42[7] = v30;
          goto LABEL_43;
        }
      }
      else
      {
        v21 = off_BC5EC;
      }
      if ( (unsigned int)v21 <= 3 )
        return -1;
      v22 = "get asic_small_core_num failed\n";
      goto LABEL_42;
    }
  }
  else
  {
    v3 = off_BC5EC;
  }
  if ( (unsigned int)v3 <= 3 )
    return -1;
  strcpy((char *)v42, "get asic failed\n");
  sub_41DB8(3, (const char *)v42, 0);
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B2E4: using guessed type int dword_65B2E4;
// 65B2E8: using guessed type int dword_65B2E8;
// 65B2EC: using guessed type int dword_65B2EC;
// 65B2F0: using guessed type int dword_65B2F0;
// 65B2F4: using guessed type int dword_65B2F4;
// 65B2F8: using guessed type int dword_65B2F8;

//----- (00026448) --------------------------------------------------------
int __fastcall sub_26448(_DWORD *a1)
{
  double v1; // d0
  _DWORD *v3; // r0
  _DWORD *v4; // r5
  const char *v6; // r0
  const char *v7; // r8
  size_t v8; // r0
  char *v9; // r12
  _DWORD *v10; // r0
  void *v11; // r3
  const char *v12; // lr
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  _DWORD *v17; // lr
  int v18; // r1
  const char *v19; // r0
  size_t v20; // r0
  _DWORD *v21; // r0
  void *v22; // r3
  const char *v23; // r0
  const char *v24; // r5
  _DWORD *v25; // r0
  const char *v26; // r0
  int v27; // r3
  _DWORD *v28; // r0
  _DWORD *v29; // r5
  const char *v30; // r0
  const char *v31; // r0
  _DWORD v32[2048]; // [sp+0h] [bp-2000h] BYREF

  v3 = (_DWORD *)sub_7C250(a1, "machine");
  v4 = v3;
  if ( !v3 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
LABEL_19:
    strcpy((char *)v32, "get machine failed\n");
    sub_41DB8(3, (const char *)v32, 0);
    return -1;
  }
  if ( *v3 != 2 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    goto LABEL_19;
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    v19 = (const char *)sub_7DA40(v3);
    snprintf((char *)v32, 0x2000u, "load machine %s conf\n", v19);
    sub_41DB8(3, (const char *)v32, 0);
  }
  v6 = (const char *)sub_7DA40(v4);
  v7 = v6;
  if ( dword_65B2B8 )
  {
    v8 = strlen((const char *)dword_65B2B8);
    memset((void *)dword_65B2B8, 0, v8);
    v9 = (char *)dword_65B2B8;
  }
  else
  {
    v20 = strlen(v6);
    v9 = (char *)calloc(v20 + 1, 1u);
    dword_65B2B8 = (int)v9;
    if ( !v9 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      strcpy((char *)v32, "get machine failed, Cannot allocate space\n");
      sub_41DB8(3, (const char *)v32, 0);
      return -1;
    }
  }
  strcpy(v9, v7);
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf((char *)v32, 0x2000u, "machine : %s \n", (const char *)dword_65B2B8);
    sub_41DB8(4, (const char *)v32, 0);
  }
  v10 = (_DWORD *)sub_7C250(a1, "hw_version");
  if ( !v10 )
  {
    v11 = off_BC5EC;
LABEL_14:
    if ( (unsigned int)v11 <= 3 )
      return -1;
    v12 = "get hw_version failed\n";
LABEL_17:
    v13 = *(_DWORD *)v12;
    v14 = *((_DWORD *)v12 + 1);
    v15 = *((_DWORD *)v12 + 2);
    v16 = *((_DWORD *)v12 + 3);
    v17 = v12 + 16;
    v32[0] = v13;
    v32[1] = v14;
    v32[2] = v15;
    v32[3] = v16;
    v18 = v17[1];
    v32[4] = *v17;
    LOWORD(v32[5]) = v18;
    BYTE2(v32[5]) = BYTE2(v18);
    sub_41DB8(3, (const char *)v32, 0);
    return -1;
  }
  v11 = off_BC5EC;
  if ( *v10 != 2 )
    goto LABEL_14;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v23 = (const char *)sub_7DA40(v10);
    snprintf((char *)v32, 0x2000u, "hw_version: %s\n", v23);
    sub_41DB8(4, (const char *)v32, 0);
  }
  v21 = (_DWORD *)sub_7C250(a1, "sw_version");
  if ( !v21 )
  {
    v22 = off_BC5EC;
LABEL_28:
    if ( (unsigned int)v22 <= 3 )
      return -1;
    v12 = "get sw_version failed\n";
    goto LABEL_17;
  }
  v22 = off_BC5EC;
  if ( *v21 != 2 )
    goto LABEL_28;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v26 = (const char *)sub_7DA40(v21);
    snprintf((char *)v32, 0x2000u, "sw_version: %s\n", v26);
    sub_41DB8(4, (const char *)v32, 0);
  }
  v24 = (const char *)dword_65B2B8;
  if ( strcmp((const char *)dword_65B2B8, "HHB68502")
    && strcmp(v24, "HHB68501")
    && strcmp(v24, "HHB68701")
    && strcmp(v24, "HHB68704")
    && strcmp(v24, "HHB68703")
    && strcmp(v24, "H6HB68702")
    && strcmp(v24, "H1HB68601")
    && strcmp(v24, "HHB68601")
    && strcmp(v24, "HHB68602")
    && strcmp(v24, "HHB56611")
    && strcmp(v24, "HHB68503") )
  {
    return 0;
  }
  v25 = (_DWORD *)sub_7C250(a1, "power_target");
  if ( v25 && *v25 == 3 )
  {
    v27 = sub_7DF10((int)v25);
    dword_65B2BC = v27;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf((char *)v32, 0x2000u, "power_target: %d\n", v27);
      sub_41DB8(4, (const char *)v32, 0);
    }
    v28 = (_DWORD *)sub_7C250(a1, "jt_target");
    v29 = v28;
    if ( !v28 || *v28 != 2 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy((char *)v32, "get jt_target failed\n");
        sub_41DB8(3, (const char *)v32, 0);
      }
      return -1;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v31 = (const char *)sub_7DA40(v28);
      snprintf((char *)v32, 0x2000u, "jt_target: %s\n", v31);
      sub_41DB8(4, (const char *)v32, 0);
    }
    v30 = (const char *)sub_7DA40(v29);
    strtod(v30, 0);
    dbl_65B2C0 = v1;
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    strcpy((char *)v32, "get power_target failed\n");
    sub_41DB8(3, (const char *)v32, 0);
    return -1;
  }
}
// 26968: variable 'v1' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B2B8: using guessed type int dword_65B2B8;
// 65B2BC: using guessed type int dword_65B2BC;
// 65B2C0: using guessed type double dbl_65B2C0;

//----- (000269A0) --------------------------------------------------------
int __fastcall sub_269A0(_DWORD *a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r7
  unsigned int v4; // r5
  const char *v5; // r6
  const char *v6; // r8
  _DWORD *v7; // r0
  _DWORD *v8; // r8
  void *v9; // r3
  _DWORD *v10; // r0
  _DWORD *v11; // r6
  void *v12; // r3
  _DWORD *v13; // r0
  _DWORD *v14; // r6
  _DWORD *v15; // r0
  void *v16; // r3
  int v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v1 = (_DWORD *)sub_7C250(a1, "fan");
  v2 = v1;
  if ( !v1 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    goto LABEL_25;
  }
  if ( *v1 != 1 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
LABEL_25:
    strcpy(s, "get fan failed\n");
    sub_41DB8(3, s, 0);
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "fan:\n");
    sub_41DB8(4, s, 0);
  }
  v4 = 0;
  v5 = 0;
  v6 = 0;
  while ( 1 )
  {
    if ( v4 >= sub_7CD9C(v2) )
    {
      dword_65B318 = v4;
      if ( !strncmp(v6, "right", 5u) )
      {
        if ( !strncmp(v5, "in", 2u) )
          goto LABEL_51;
        if ( strncmp(v6, "left", 4u) )
        {
          if ( !strncmp(v5, "out", 2u) )
          {
LABEL_42:
            dword_65B314 = 1;
            return 0;
          }
LABEL_46:
          if ( strncmp(v6, "up", 2u) )
            goto LABEL_47;
          goto LABEL_58;
        }
      }
      else if ( strncmp(v6, "left", 4u) )
      {
        if ( strncmp(v6, "up", 2u) )
        {
LABEL_47:
          if ( strncmp(v6, "down", 4u) )
            goto LABEL_56;
          if ( strncmp(v5, "out", 3u) )
          {
            if ( !strncmp(v5, "in", 2u) )
            {
LABEL_50:
              dword_65B314 = 3;
              return 0;
            }
LABEL_56:
            if ( (unsigned int)off_BC5EC > 3 )
            {
              snprintf(s, 0x2000u, "unkonwn wind position %s, direction %s\n", v6, v5);
              goto LABEL_28;
            }
            return -1;
          }
          goto LABEL_54;
        }
        if ( !strncmp(v5, "in", 2u) )
          goto LABEL_54;
LABEL_58:
        if ( strncmp(v6, "down", 4u) )
        {
          if ( !strncmp(v5, "out", 3u) )
            goto LABEL_50;
          goto LABEL_56;
        }
        if ( strncmp(v5, "out", 3u) )
          goto LABEL_56;
LABEL_54:
        dword_65B314 = 2;
        return 0;
      }
      if ( strncmp(v5, "out", 2u) )
      {
        if ( !strncmp(v5, "in", 2u) )
          goto LABEL_42;
        goto LABEL_46;
      }
LABEL_51:
      dword_65B314 = 0;
      return 0;
    }
    v13 = (_DWORD *)sub_7CDE8(v2, v4);
    v14 = v13;
    if ( !v13 || *v13 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      snprintf(s, 0x2000u, "get array %d failed\n", v4);
      goto LABEL_28;
    }
    v15 = (_DWORD *)sub_7C250(v13, "id");
    if ( !v15 )
      break;
    v16 = off_BC5EC;
    if ( *v15 != 3 )
      goto LABEL_30;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v17 = sub_7DF10((int)v15);
      snprintf(s, 0x2000u, "id: %d\n", v17);
      sub_41DB8(4, s, 0);
    }
    v7 = (_DWORD *)sub_7C250(v14, "position");
    v8 = v7;
    if ( !v7 )
    {
      v9 = off_BC5EC;
LABEL_33:
      if ( (unsigned int)v9 > 3 )
      {
        snprintf(s, 0x2000u, "get arrya %d position failed\n", v4);
        goto LABEL_28;
      }
      return -1;
    }
    v9 = off_BC5EC;
    if ( *v7 != 2 )
      goto LABEL_33;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v18 = (const char *)sub_7DA40(v7);
      snprintf(s, 0x2000u, "position: %s\n", v18);
      sub_41DB8(4, s, 0);
    }
    v6 = (const char *)sub_7DA40(v8);
    v10 = (_DWORD *)sub_7C250(v14, "direction");
    v11 = v10;
    if ( !v10 )
    {
      v12 = off_BC5EC;
LABEL_36:
      if ( (unsigned int)v12 > 3 )
      {
        snprintf(s, 0x2000u, "get arrya%d direction failed\n", v4);
        goto LABEL_28;
      }
      return -1;
    }
    v12 = off_BC5EC;
    if ( *v10 != 2 )
      goto LABEL_36;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      v19 = (const char *)sub_7DA40(v10);
      snprintf(s, 0x2000u, "direction: %s\n", v19);
      sub_41DB8(4, s, 0);
    }
    ++v4;
    v5 = (const char *)sub_7DA40(v11);
  }
  v16 = off_BC5EC;
LABEL_30:
  if ( (unsigned int)v16 > 3 )
  {
    snprintf(s, 0x2000u, "get arrya %d id failed\n", v4);
LABEL_28:
    sub_41DB8(3, s, 0);
    return -1;
  }
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B314: using guessed type int dword_65B314;
// 65B318: using guessed type int dword_65B318;

//----- (00026ECC) --------------------------------------------------------
int __fastcall sub_26ECC(_DWORD *a1)
{
  _DWORD *v1; // r0
  _DWORD *v2; // r5
  void *v3; // r3
  _DWORD *v4; // r0
  void *v5; // r3
  const char *v6; // r12
  int *v8; // r12
  _DWORD *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r12
  _DWORD *v15; // r0
  void *v16; // r3
  int v17; // r0
  int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // r12
  _DWORD *v22; // r0
  _DWORD *v23; // r8
  signed int v24; // r6
  signed int v25; // r6
  int v26; // r0
  __int16 v27; // r0
  int v28; // r3
  const char *v29; // r0
  _DWORD *v30; // r0
  void *v31; // r3
  int v32; // r0
  int v33; // r0
  _DWORD v34[2049]; // [sp+0h] [bp-2004h] BYREF

  v1 = (_DWORD *)sub_7C250(a1, "power");
  v2 = v1;
  if ( !v1 )
  {
    v3 = off_BC5EC;
    goto LABEL_12;
  }
  v3 = off_BC5EC;
  if ( *v1 )
  {
LABEL_12:
    if ( (unsigned int)v3 <= 3 )
      return -1;
    v8 = (int *)&unk_9A340;
    v9 = v34;
    goto LABEL_14;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy((char *)v34, "power:\n");
    sub_41DB8(4, (const char *)v34, 0);
  }
  v4 = (_DWORD *)sub_7C250(v2, "type");
  if ( !v4 )
  {
    v5 = off_BC5EC;
    goto LABEL_8;
  }
  v5 = off_BC5EC;
  if ( *v4 != 2 )
  {
LABEL_8:
    if ( (unsigned int)v5 > 3 )
    {
      v6 = "get type failed\n";
LABEL_22:
      v17 = *(_DWORD *)v6;
      v18 = *((_DWORD *)v6 + 1);
      v19 = *((_DWORD *)v6 + 2);
      v20 = *((_DWORD *)v6 + 3);
      v21 = *((_DWORD *)v6 + 4);
      v34[0] = v17;
      v34[1] = v18;
      v34[2] = v19;
      v34[3] = v20;
      LOBYTE(v34[4]) = v21;
      sub_41DB8(3, (const char *)v34, 0);
      return -1;
    }
    return -1;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v29 = (const char *)sub_7DA40(v4);
    snprintf((char *)v34, 0x2000u, "type: %s\n", v29);
    sub_41DB8(4, (const char *)v34, 0);
  }
  v22 = (_DWORD *)sub_7C250(v2, "release_version");
  v23 = v22;
  if ( !v22 || *v22 != 1 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v8 = (int *)&unk_9A37C;
    qmemcpy(v34, "get release vers", 16);
    v9 = &v34[4];
LABEL_14:
    v10 = *v8;
    v11 = v8[1];
    v12 = v8[2];
    v13 = v8[3];
    v14 = v8[4];
    *v9 = v10;
    v9[1] = v11;
    v9[2] = v12;
    v9[3] = v13;
    *((_WORD *)v9 + 8) = v14;
    sub_41DB8(3, (const char *)v34, 0);
    return -1;
  }
  v24 = sub_7CD9C(v22);
  dword_65B358 = v24;
  dword_65B35C = (int)calloc(v24, 2u);
  if ( v24 > 0 )
  {
    v25 = 0;
    do
    {
      v26 = sub_7CDE8(v23, v25);
      v27 = sub_7DF10(v26);
      v28 = 2 * v25++;
      *(_WORD *)(dword_65B35C + v28) = v27;
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf((char *)v34, 0x2000u, "psu version = 0x%x", *(unsigned __int16 *)(dword_65B35C + v28));
        sub_41DB8(4, (const char *)v34, 0);
      }
    }
    while ( v25 < dword_65B358 );
  }
  v30 = (_DWORD *)sub_7C250(v2, "i2c_addr");
  if ( v30 )
  {
    v31 = off_BC5EC;
    if ( *v30 == 3 )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        v32 = sub_7DF10((int)v30);
        snprintf((char *)v34, 0x2000u, "i2c_addr: %d\n", v32);
        sub_41DB8(4, (const char *)v34, 0);
      }
      v15 = (_DWORD *)sub_7C250(v2, "gpio");
      if ( v15 )
      {
        v16 = off_BC5EC;
        if ( *v15 == 3 )
        {
          if ( (unsigned int)off_BC5EC > 4 )
          {
            v33 = sub_7DF10((int)v15);
            snprintf((char *)v34, 0x2000u, "gpio: %d\n", v33);
            sub_41DB8(4, (const char *)v34, 0);
          }
          return 0;
        }
      }
      else
      {
        v16 = off_BC5EC;
      }
      if ( (unsigned int)v16 > 3 )
      {
        v6 = (const char *)&unk_9A3AC;
        goto LABEL_22;
      }
      return -1;
    }
  }
  else
  {
    v31 = off_BC5EC;
  }
  if ( (unsigned int)v31 <= 3 )
    return -1;
  strcpy((char *)v34, "get i2c_addr failed\n");
  sub_41DB8(3, (const char *)v34, 0);
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B358: using guessed type int dword_65B358;
// 65B35C: using guessed type int dword_65B35C;

//----- (00027230) --------------------------------------------------------
int __fastcall sub_27230(const char *a1)
{
  void *v2; // r6
  size_t v3; // r0
  char *v4; // r0
  const char *v5; // r6
  void *v6; // r8
  char v8[8192]; // [sp+0h] [bp-2000h] BYREF

  dword_65B2C8 = 4;
  dword_65B318 = 4;
  v2 = calloc(4u, 0x210u);
  dword_65B328 = (int)v2;
  if ( v2 )
  {
    dword_65B330 = (int)calloc(4u, 8u);
    if ( dword_65B330 )
    {
      if ( !a1 )
      {
LABEL_7:
        dword_65B320 = 1;
        return 0;
      }
      v3 = strlen(a1);
      v4 = (char *)calloc(v3 + 1, 1u);
      v5 = v4;
      dword_65B2B8 = (int)v4;
      v6 = off_BC5EC;
      if ( v4 )
      {
        strcpy(v4, a1);
        if ( (unsigned int)v6 > 4 )
        {
          snprintf(v8, 0x2000u, "initial machine : %s \n", v5);
          sub_41DB8(4, v8, 0);
        }
        goto LABEL_7;
      }
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v8, "get machine failed, Cannot allocate space\n");
        sub_41DB8(3, v8, 0);
      }
      return -1;
    }
    else
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(v8, 0x2000u, "malloc %d runtime_fan failed\n", 4);
        sub_41DB8(3, v8, 0);
        v2 = (void *)dword_65B328;
      }
      free(v2);
      return -2147482624;
    }
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v8, 0x2000u, "malloc %d runtime_chain failed\n", 4);
      sub_41DB8(3, v8, 0);
    }
    return -2147482624;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B2B8: using guessed type int dword_65B2B8;
// 65B2C8: using guessed type int dword_65B2C8;
// 65B318: using guessed type int dword_65B318;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;
// 65B330: using guessed type int dword_65B330;

//----- (00027404) --------------------------------------------------------
int __fastcall sub_27404(int result)
{
  int v1; // r4
  float v2; // s15
  void *v3; // r3
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v1 = result;
  if ( (unsigned int)(*(_DWORD *)(result + 168) - 1000) > 0x47E )
  {
    *(_DWORD *)(result + 168) = 2100;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "set default open_core_high_voltage: %d\n", 2100);
      result = sub_41DB8(3, s, 0);
    }
  }
  if ( (unsigned int)(*(_DWORD *)(v1 + 172) - 1000) > 0x44C )
  {
    *(_DWORD *)(v1 + 172) = 2000;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "set default inc_freq_voltage: %d\n", 2000);
      result = sub_41DB8(3, s, 0);
    }
  }
  v2 = *(float *)(v1 + 176);
  if ( v2 < 1.0 || v2 > 100.0 )
  {
    v3 = off_BC5EC;
    *(_DWORD *)(v1 + 176) = 1086849024;
    if ( (unsigned int)v3 > 3 )
    {
      snprintf(s, 0x2000u, "set default inc_freq_step: %f\n", 6.25);
      result = sub_41DB8(3, s, 0);
    }
  }
  if ( (unsigned int)(*(_DWORD *)(v1 + 180) - 100) > 0x384 )
  {
    *(_DWORD *)(v1 + 180) = 200;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "set default inc_freq_delay: %d\n", 200);
      result = sub_41DB8(3, s, 0);
    }
  }
  if ( *(int *)(v1 + 184) < 0 )
  {
    *(_DWORD *)(v1 + 184) = 0;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "set default poweron_with_reset_high: %d\n", 0);
      result = sub_41DB8(3, s, 0);
    }
  }
  if ( (unsigned int)(*(_DWORD *)(v1 + 188) - 1) > 0x4F )
  {
    *(_DWORD *)(v1 + 188) = 50;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "set default pid_target_temp: %d\n", 50);
      result = sub_41DB8(3, s, 0);
    }
  }
  if ( (unsigned int)(*(_DWORD *)(v1 + 192) - 1) >= 0x1F4 )
  {
    *(_DWORD *)(v1 + 192) = 10;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "set default voltage_adjust_setp: %d\n", 10);
      return sub_41DB8(3, s, 0);
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000276A8) --------------------------------------------------------
int __fastcall sub_276A8(int a1, const char *a2)
{
  int v3; // r4
  _DWORD *v5; // r0
  _DWORD *v6; // r6
  _DWORD *v7; // r0
  _DWORD *v8; // r7
  void *v9; // r3
  unsigned int *v10; // r3
  unsigned int v11; // r2
  unsigned int v12; // r2
  unsigned int v13; // r4
  _DWORD *v14; // r0
  _DWORD *v15; // r9
  _DWORD *v16; // r0
  const char *v17; // r10
  size_t v18; // r0
  const char *v19; // r12
  int v20; // r0
  int v21; // r1
  int v22; // r2
  int v23; // r3
  int v24; // r12
  unsigned int v25; // r3
  char v26[252]; // [sp+4h] [bp-2100h] BYREF
  char s[8196]; // [sp+100h] [bp-2004h] BYREF

  if ( a1 )
  {
    v3 = sub_27230(a2);
    if ( v3 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "init topol runtime failed\n");
        sub_41DB8(3, s, 0);
      }
    }
    return v3;
  }
  v5 = sub_7AD44("/etc/topol.conf", 0, v26);
  v6 = v5;
  if ( v5 && !*v5 )
  {
    memset(&dword_65B360, 0, 0x20u);
    v7 = (_DWORD *)sub_7C250(v6, "config");
    v8 = v7;
    if ( v7 )
    {
      v9 = off_BC5EC;
      if ( *v7 == 1 )
      {
        if ( (unsigned int)off_BC5EC > 4 )
        {
          strcpy(s, "multi machine mode\n");
          sub_41DB8(4, s, 0);
        }
        v13 = 0;
        do
        {
          if ( sub_7CD9C(v8) <= v13 )
          {
            v3 = -1;
            if ( (unsigned int)off_BC5EC > 3 )
            {
              strcpy(s, "board name doesn't match\n");
              sub_41DB8(3, s, 0);
            }
            goto LABEL_18;
          }
          v14 = (_DWORD *)sub_7CDE8(v8, v13);
          v15 = v14;
          if ( !v14 || *v14 )
          {
            if ( (unsigned int)off_BC5EC <= 3 )
              return -1;
            v25 = v13;
            v3 = -1;
            snprintf(s, 0x2000u, "get array %d failed\n", v25);
            sub_41DB8(3, s, 0);
            return v3;
          }
          v16 = (_DWORD *)sub_7C250(v14, "machine");
          ++v13;
          if ( !v16 || *v16 != 2 )
          {
            if ( (unsigned int)off_BC5EC <= 3 )
              return -1;
            v3 = -1;
            strcpy(s, "get machine failed\n");
            sub_41DB8(3, s, 0);
            return v3;
          }
          if ( !a2 )
          {
            if ( (unsigned int)off_BC5EC <= 3 )
              return -1;
            v3 = -1;
            strcpy(s, "no board_name\n");
            sub_41DB8(3, s, 0);
            return v3;
          }
          v17 = (const char *)sub_7DA40(v16);
          v18 = strlen(a2);
        }
        while ( strncmp(v17, a2, v18) );
        v3 = sub_26448(v15);
        if ( v3 )
          goto LABEL_16;
        v3 = sub_25BF0(v15);
        if ( v3 )
          goto LABEL_25;
        v3 = sub_26ECC(v15);
        if ( v3 )
          goto LABEL_40;
        v3 = sub_269A0(v15);
        if ( !v3 )
        {
          v3 = sub_25E6C(v15);
          if ( v3 )
            goto LABEL_58;
          v3 = sub_13118(v15);
          if ( v3 )
          {
LABEL_61:
            if ( (unsigned int)off_BC5EC <= 3 )
              goto LABEL_18;
            v19 = "parse chain failed\n";
LABEL_43:
            v20 = *(_DWORD *)v19;
            v21 = *((_DWORD *)v19 + 1);
            v22 = *((_DWORD *)v19 + 2);
            v23 = *((_DWORD *)v19 + 3);
            v24 = *((_DWORD *)v19 + 4);
            *(_DWORD *)s = v20;
            *(_DWORD *)&s[4] = v21;
            *(_DWORD *)&s[8] = v22;
            *(_DWORD *)&s[12] = v23;
            *(_DWORD *)&s[16] = v24;
            sub_41DB8(3, s, 0);
LABEL_18:
            if ( v6[1] != -1 )
            {
              v10 = v6 + 1;
              __dmb(0xBu);
              do
              {
                v11 = __ldrex(v10);
                v12 = v11 - 1;
              }
              while ( __strex(v12, v10) );
              if ( !v12 )
                sub_7E3BC(v6);
            }
            return v3;
          }
          v3 = sub_12A90(v15);
          if ( v3 )
            goto LABEL_64;
          goto LABEL_70;
        }
LABEL_54:
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "parse fan failed\n");
          sub_41DB8(3, s, 0);
        }
        goto LABEL_18;
      }
    }
    else
    {
      v9 = off_BC5EC;
    }
    if ( (unsigned int)v9 > 4 )
    {
      strcpy(s, "single machine mode\n");
      sub_41DB8(4, s, 0);
    }
    v3 = sub_26448(v6);
    if ( v3 )
    {
LABEL_16:
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "parse machine failed\n");
        sub_41DB8(3, s, 0);
      }
      goto LABEL_18;
    }
    v3 = sub_25BF0(v6);
    if ( v3 )
    {
LABEL_25:
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "parse processor failed\n");
        sub_41DB8(3, s, 0);
      }
      goto LABEL_18;
    }
    v3 = sub_26ECC(v6);
    if ( v3 )
    {
LABEL_40:
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_18;
      v19 = "parse power failed\n";
      goto LABEL_43;
    }
    v3 = sub_269A0(v6);
    if ( !v3 )
    {
      v3 = sub_25E6C(v6);
      if ( v3 )
      {
LABEL_58:
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "parse asic failed\n");
          sub_41DB8(3, s, 0);
        }
        goto LABEL_18;
      }
      v3 = sub_13118(v6);
      if ( v3 )
        goto LABEL_61;
      v3 = sub_12A90(v6);
      if ( v3 )
      {
LABEL_64:
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "parse strategy failed\n");
          sub_41DB8(3, s, 0);
        }
        goto LABEL_66;
      }
LABEL_70:
      v3 = 0;
LABEL_66:
      sub_27404((int)&dword_65B2B8);
      goto LABEL_18;
    }
    goto LABEL_54;
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    return -1;
  snprintf(s, 0x2000u, "load topol config file %s failed\n", "/etc/topol.conf");
  sub_41DB8(3, s, 0);
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B2B8: using guessed type int dword_65B2B8;
// 65B360: using guessed type int dword_65B360;

//----- (00027CEC) --------------------------------------------------------
int sub_27CEC()
{
  return dword_65B2B8;
}
// 65B2B8: using guessed type int dword_65B2B8;

//----- (00027CFC) --------------------------------------------------------
int sub_27CFC()
{
  return dword_65B2C8;
}
// 65B2C8: using guessed type int dword_65B2C8;

//----- (00027D0C) --------------------------------------------------------
int sub_27D0C()
{
  return dword_65B2D4;
}
// 65B2D4: using guessed type int dword_65B2D4;

//----- (00027D1C) --------------------------------------------------------
int sub_27D1C()
{
  return dword_65B2D8;
}
// 65B2D8: using guessed type int dword_65B2D8;

//----- (00027D2C) --------------------------------------------------------
int sub_27D2C()
{
  return dword_65B2DC;
}
// 65B2DC: using guessed type int dword_65B2DC;

//----- (00027D3C) --------------------------------------------------------
int sub_27D3C()
{
  return dword_65B2E4;
}
// 65B2E4: using guessed type int dword_65B2E4;

//----- (00027D4C) --------------------------------------------------------
int sub_27D4C()
{
  return dword_65B2E8;
}
// 65B2E8: using guessed type int dword_65B2E8;

//----- (00027D5C) --------------------------------------------------------
int sub_27D5C()
{
  return dword_65B2EC;
}
// 65B2EC: using guessed type int dword_65B2EC;

//----- (00027D6C) --------------------------------------------------------
int sub_27D6C()
{
  return dword_65B2F0;
}
// 65B2F0: using guessed type int dword_65B2F0;

//----- (00027D7C) --------------------------------------------------------
int sub_27D7C()
{
  return dword_65B2F4;
}
// 65B2F4: using guessed type int dword_65B2F4;

//----- (00027D8C) --------------------------------------------------------
int sub_27D8C()
{
  return dword_65B2F8;
}
// 65B2F8: using guessed type int dword_65B2F8;

//----- (00027D9C) --------------------------------------------------------
int sub_27D9C()
{
  return dword_65B2E0;
}
// 65B2E0: using guessed type int dword_65B2E0;

//----- (00027DAC) --------------------------------------------------------
int __fastcall sub_27DAC(int a1)
{
  return *(_DWORD *)(dword_65B300 + 12 * a1 + 4);
}
// 65B300: using guessed type int dword_65B300;

//----- (00027DC8) --------------------------------------------------------
int sub_27DC8()
{
  return dword_65B304;
}
// 65B304: using guessed type int dword_65B304;

//----- (00027DD8) --------------------------------------------------------
int __fastcall sub_27DD8(int a1)
{
  return *(_DWORD *)(dword_65B308 + 12 * a1 + 4);
}
// 65B308: using guessed type int dword_65B308;

//----- (00027DF4) --------------------------------------------------------
int __fastcall sub_27DF4(int a1)
{
  return *(unsigned __int8 *)(dword_65B308 + 12 * a1 + 8);
}
// 65B308: using guessed type int dword_65B308;

//----- (00027E10) --------------------------------------------------------
int __fastcall sub_27E10(int a1)
{
  return *(unsigned __int8 *)(dword_65B300 + 12 * a1 + 8);
}
// 65B300: using guessed type int dword_65B300;

//----- (00027E2C) --------------------------------------------------------
int __fastcall sub_27E2C(int a1, int a2)
{
  int v2; // r3
  int result; // r0
  int v6; // r4
  char v7; // r3

  v2 = (unsigned int)a1 >> 31;
  if ( dword_65B2C8 <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
  }
  else
  {
    result = sub_27230(0);
    if ( result < 0 )
      return result;
  }
  v6 = 528 * a1;
  if ( *(unsigned __int8 *)(dword_65B328 + v6) != a2 )
  {
    *(_BYTE *)(dword_65B328 + v6) = a2;
    if ( a2 )
      v7 = byte_65B324 + 1;
    else
      v7 = byte_65B324 - 1;
    byte_65B324 = v7;
  }
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B324: using guessed type char byte_65B324;
// 65B328: using guessed type int dword_65B328;

//----- (00027EB8) --------------------------------------------------------
int sub_27EB8()
{
  return (unsigned __int8)byte_65B324;
}
// 65B324: using guessed type char byte_65B324;

//----- (00027EC8) --------------------------------------------------------
int __fastcall sub_27EC8(int a1)
{
  return *(unsigned __int8 *)(dword_65B328 + 528 * a1);
}
// 65B328: using guessed type int dword_65B328;

//----- (00027EE0) --------------------------------------------------------
int sub_27EE0()
{
  double v0; // d0

  dbl_65B338 = v0;
  return 0;
}
// 27EEC: variable 'v0' is possibly undefined
// 65B338: using guessed type double dbl_65B338;

//----- (00027EF4) --------------------------------------------------------
void sub_27EF4()
{
  ;
}
// 65B338: using guessed type double dbl_65B338;

//----- (00027F04) --------------------------------------------------------
int sub_27F04()
{
  double v0; // d0

  dbl_65B340 = v0;
  return 0;
}
// 27F10: variable 'v0' is possibly undefined
// 65B340: using guessed type double dbl_65B340;

//----- (00027F18) --------------------------------------------------------
void sub_27F18()
{
  ;
}
// 65B340: using guessed type double dbl_65B340;

//----- (00027F28) --------------------------------------------------------
int sub_27F28()
{
  return dword_65B318;
}
// 65B318: using guessed type int dword_65B318;

//----- (00027F38) --------------------------------------------------------
int sub_27F38()
{
  int result; // r0
  int v1; // r3

  if ( dword_65B318 <= 0 )
    return 0;
  result = 0;
  v1 = 0;
  do
  {
    if ( *(unsigned __int8 *)(dword_65B330 + 8 * v1++) )
      ++result;
  }
  while ( v1 != dword_65B318 );
  return result;
}
// 65B318: using guessed type int dword_65B318;
// 65B330: using guessed type int dword_65B330;

//----- (00027F7C) --------------------------------------------------------
int __fastcall sub_27F7C(int a1, int a2)
{
  int v2; // r3
  int result; // r0
  char v6; // r3

  v2 = (unsigned int)a1 >> 31;
  if ( dword_65B318 <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
  }
  else
  {
    result = sub_27230(0);
    if ( result < 0 )
      return result;
  }
  if ( *(unsigned __int8 *)(dword_65B330 + 8 * a1) != a2 )
  {
    *(_BYTE *)(dword_65B330 + 8 * a1) = a2;
    if ( a2 )
      v6 = byte_65B32C + 1;
    else
      v6 = byte_65B32C - 1;
    byte_65B32C = v6;
  }
  return result;
}
// 65B318: using guessed type int dword_65B318;
// 65B320: using guessed type int dword_65B320;
// 65B32C: using guessed type char byte_65B32C;
// 65B330: using guessed type int dword_65B330;

//----- (00028000) --------------------------------------------------------
int __fastcall sub_28000(int a1, int a2)
{
  int v2; // r3
  int result; // r0

  v2 = (unsigned int)a1 >> 31;
  if ( dword_65B318 <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
LABEL_7:
    *(_DWORD *)(dword_65B330 + 8 * a1 + 4) = a2;
    return result;
  }
  result = sub_27230(0);
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 65B318: using guessed type int dword_65B318;
// 65B320: using guessed type int dword_65B320;
// 65B330: using guessed type int dword_65B330;

//----- (00028068) --------------------------------------------------------
int __fastcall sub_28068(int a1)
{
  int result; // r0

  if ( (dword_65B318 <= a1) | ((unsigned int)a1 >> 31) )
    return -2147482623;
  if ( dword_65B320 )
    return *(_DWORD *)(dword_65B330 + 8 * a1 + 4);
  result = sub_27230(0);
  if ( result >= 0 )
    return *(_DWORD *)(dword_65B330 + 8 * a1 + 4);
  return result;
}
// 65B318: using guessed type int dword_65B318;
// 65B320: using guessed type int dword_65B320;
// 65B330: using guessed type int dword_65B330;

//----- (000280C8) --------------------------------------------------------
int __fastcall sub_280C8(char a1)
{
  byte_65B32D = a1;
  return 0;
}
// 65B32D: using guessed type char byte_65B32D;

//----- (000280DC) --------------------------------------------------------
int sub_280DC()
{
  return (unsigned __int8)byte_65B32D;
}
// 65B32D: using guessed type char byte_65B32D;

//----- (000280EC) --------------------------------------------------------
int __fastcall sub_280EC(int a1)
{
  __int64 v1; // d0
  int v2; // r3
  int result; // r0

  v2 = (unsigned int)a1 >> 31;
  if ( dword_65B2C8 <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
LABEL_7:
    *(_QWORD *)(dword_65B328 + 528 * a1 + 8) = v1;
    return result;
  }
  result = sub_27230(0);
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 28134: variable 'v1' is possibly undefined
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (00028158) --------------------------------------------------------
int __fastcall sub_28158(int result)
{
  int v1; // r4

  if ( !((dword_65B2C8 <= result) | ((unsigned int)result >> 31)) )
  {
    v1 = result;
    if ( dword_65B320 )
      return dword_65B328 + 528 * v1;
    result = sub_27230(0);
    if ( result >= 0 )
      return dword_65B328 + 528 * v1;
  }
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (000281C8) --------------------------------------------------------
int __fastcall sub_281C8(int a1)
{
  int v1; // r3
  int result; // r0

  v1 = (unsigned int)a1 >> 31;
  if ( dword_65B2C8 <= a1 )
    v1 = 1;
  if ( v1 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
LABEL_7:
    ++*(_BYTE *)(dword_65B328 + 528 * a1 + 1);
    return result;
  }
  result = sub_27230(0);
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (00028238) --------------------------------------------------------
int __fastcall sub_28238(int a1, char a2)
{
  int v2; // r3
  int result; // r0

  v2 = (unsigned int)a1 >> 31;
  if ( dword_65B2C8 <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
LABEL_7:
    *(_BYTE *)(dword_65B328 + 528 * a1 + 1) = a2;
    return result;
  }
  result = sub_27230(0);
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (000282A4) --------------------------------------------------------
int __fastcall sub_282A4(int a1)
{
  int result; // r0

  if ( (dword_65B2C8 <= a1) | ((unsigned int)a1 >> 31) )
    return -2147482623;
  if ( dword_65B320 )
    return *(unsigned __int8 *)(dword_65B328 + 528 * a1 + 1);
  result = sub_27230(0);
  if ( result >= 0 )
    return *(unsigned __int8 *)(dword_65B328 + 528 * a1 + 1);
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (00028308) --------------------------------------------------------
int __fastcall sub_28308(int a1)
{
  int v1; // r3
  int result; // r0

  v1 = (unsigned int)a1 >> 31;
  if ( dword_65B2C8 <= a1 )
    v1 = 1;
  if ( v1 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
LABEL_7:
    ++*(_DWORD *)(dword_65B328 + 528 * a1 + 4);
    return result;
  }
  result = sub_27230(0);
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (00028378) --------------------------------------------------------
int __fastcall sub_28378(int a1, int a2)
{
  int v2; // r3
  int result; // r0

  v2 = (unsigned int)a1 >> 31;
  if ( dword_65B2C8 <= a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
LABEL_7:
    *(_DWORD *)(dword_65B328 + 528 * a1 + 4) = a2;
    return result;
  }
  result = sub_27230(0);
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (000283E4) --------------------------------------------------------
int __fastcall sub_283E4(int a1)
{
  int result; // r0

  if ( (dword_65B2C8 <= a1) | ((unsigned int)a1 >> 31) )
    return -2147482623;
  if ( dword_65B320 )
    return *(_DWORD *)(dword_65B328 + 528 * a1 + 4);
  result = sub_27230(0);
  if ( result >= 0 )
    return *(_DWORD *)(dword_65B328 + 528 * a1 + 4);
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (00028448) --------------------------------------------------------
int __fastcall sub_28448(int a1, int a2, char a3)
{
  int v3; // r3
  int result; // r0

  v3 = (unsigned int)a1 >> 31;
  if ( dword_65B2C8 <= a1 )
    v3 = 1;
  if ( v3 )
    return -2147482623;
  if ( dword_65B320 )
  {
    result = 0;
LABEL_7:
    *(_BYTE *)(dword_65B328 + 528 * a1 + a2 + 16) = a3;
    return result;
  }
  result = sub_27230(0);
  if ( result >= 0 )
    goto LABEL_7;
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (000284BC) --------------------------------------------------------
int __fastcall sub_284BC(unsigned int a1, char *s)
{
  unsigned int v2; // r5
  int result; // r0

  if ( dword_65B2C8 <= (int)a1 )
    return -2147482623;
  v2 = (s == 0) | (a1 >> 31);
  if ( v2 )
    return -2147482623;
  if ( dword_65B320 || (result = sub_27230(0), v2 = result, result >= 0) )
  {
    snprintf(s, 0x200u, "%s", (const char *)(dword_65B328 + 528 * a1 + 16));
    return v2;
  }
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (00028544) --------------------------------------------------------
int __fastcall sub_28544(unsigned int a1, void *src)
{
  unsigned int v2; // r3
  int v5; // r5
  int result; // r0

  v2 = a1 >> 31;
  if ( dword_65B2C8 <= (int)a1 )
    v2 = 1;
  if ( v2 )
    return -2147482623;
  if ( dword_65B320 )
  {
    v5 = 0;
LABEL_6:
    memcpy((void *)(dword_65B328 + 528 * a1 + 16), src, 0x200u);
    return v5;
  }
  result = sub_27230(0);
  v5 = result;
  if ( result >= 0 )
    goto LABEL_6;
  return result;
}
// 65B2C8: using guessed type int dword_65B2C8;
// 65B320: using guessed type int dword_65B320;
// 65B328: using guessed type int dword_65B328;

//----- (000285C4) --------------------------------------------------------
int __fastcall sub_285C4(int a1)
{
  unsigned __int16 *i; // r3
  int v2; // t1

  if ( dword_65B358 <= 0 )
    return 0;
  if ( *(unsigned __int16 *)dword_65B35C != a1 )
  {
    for ( i = (unsigned __int16 *)(dword_65B35C + 2); i != (unsigned __int16 *)(dword_65B35C + 2 * dword_65B358); ++i )
    {
      v2 = *i;
      if ( v2 == a1 )
        return 1;
    }
    return 0;
  }
  return 1;
}
// 65B358: using guessed type int dword_65B358;
// 65B35C: using guessed type int dword_65B35C;

//----- (00028618) --------------------------------------------------------
int sub_28618()
{
  return dword_65B30C;
}
// 65B30C: using guessed type int dword_65B30C;

//----- (00028628) --------------------------------------------------------
int __fastcall sub_28628(int a1)
{
  return *(_DWORD *)(dword_65B310 + 12 * a1 + 4);
}
// 65B310: using guessed type int dword_65B310;

//----- (00028644) --------------------------------------------------------
int sub_28644()
{
  return dword_65B360;
}
// 65B360: using guessed type int dword_65B360;

//----- (00028654) --------------------------------------------------------
int sub_28654()
{
  return dword_65B370;
}
// 65B370: using guessed type int dword_65B370;

//----- (00028664) --------------------------------------------------------
int sub_28664()
{
  return (unsigned __int8)byte_65B37C;
}
// 65B37C: using guessed type char byte_65B37C;

//----- (00028674) --------------------------------------------------------
int sub_28674()
{
  return dword_65B364;
}
// 65B364: using guessed type int dword_65B364;

//----- (00028684) --------------------------------------------------------
void sub_28684()
{
  ;
}

//----- (00028694) --------------------------------------------------------
int sub_28694()
{
  return dword_65B36C;
}
// 65B36C: using guessed type int dword_65B36C;

//----- (000286A4) --------------------------------------------------------
int sub_286A4()
{
  return dword_65B374;
}
// 65B374: using guessed type int dword_65B374;

//----- (000286B4) --------------------------------------------------------
int sub_286B4()
{
  return dword_65B378;
}
// 65B378: using guessed type int dword_65B378;

//----- (000286C4) --------------------------------------------------------
void __fastcall sub_286C4(int a1)
{
  if ( a1 )
  {
    if ( !*(_DWORD *)(a1 + 68) )
      sub_25D60(a1);
  }
}

//----- (000286DC) --------------------------------------------------------
int sub_286DC()
{
  char v1[8200]; // [sp-2008h] [bp-2008h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v1, "update_conf failed!!!");
    sub_41DB8(3, v1, 0);
  }
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00028744) --------------------------------------------------------
int sub_28744()
{
  return *(_DWORD *)(dword_65B2FC + 16);
}
// 65B2FC: using guessed type int dword_65B2FC;

//----- (00028758) --------------------------------------------------------
int sub_28758()
{
  return *(_DWORD *)(dword_65B2FC + 20);
}
// 65B2FC: using guessed type int dword_65B2FC;

//----- (0002876C) --------------------------------------------------------
int __fastcall sub_2876C(int a1, int a2)
{
  return *(_DWORD *)(*(_DWORD *)(dword_65B2FC + 24) + 4 * (a2 + *(_DWORD *)(dword_65B2FC + 20) * a1));
}
// 65B2FC: using guessed type int dword_65B2FC;

//----- (0002878C) --------------------------------------------------------
int __fastcall sub_2878C(int a1)
{
  dword_65B348 = a1;
  return 0;
}
// 65B348: using guessed type int dword_65B348;

//----- (000287A0) --------------------------------------------------------
int sub_287A0()
{
  return dword_65B348;
}
// 65B348: using guessed type int dword_65B348;

//----- (000287B0) --------------------------------------------------------
int sub_287B0()
{
  return 5850;
}

//----- (000287B8) --------------------------------------------------------
int sub_287B8()
{
  return 5450;
}

//----- (000287C0) --------------------------------------------------------
int sub_287C0()
{
  double v0; // d0

  dbl_65B350 = v0;
  return 0;
}
// 287CC: variable 'v0' is possibly undefined
// 65B350: using guessed type double dbl_65B350;

//----- (000287D4) --------------------------------------------------------
void sub_287D4()
{
  ;
}
// 65B350: using guessed type double dbl_65B350;

//----- (000287E4) --------------------------------------------------------
int sub_287E4()
{
  return dword_65B2BC;
}
// 65B2BC: using guessed type int dword_65B2BC;

//----- (000287F4) --------------------------------------------------------
void sub_287F4()
{
  ;
}

//----- (00028804) --------------------------------------------------------
void sub_28804()
{
  char *v0; // r4
  _DWORD *v1; // r0
  _DWORD *v2; // r5
  _DWORD *v3; // r0
  int v4; // r3
  _DWORD *v5; // r0
  _DWORD *v6; // r7
  _DWORD *v7; // r0
  _DWORD *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r7
  _DWORD *v11; // r0
  _DWORD *v12; // r7
  _DWORD *v13; // r0
  _DWORD *v14; // r7
  _DWORD *v15; // r0
  _DWORD *v16; // r7
  _DWORD *v17; // r0
  _DWORD *v18; // r7
  _DWORD *v19; // r0
  _DWORD *v20; // r7
  unsigned int *v21; // r3
  unsigned int v22; // r2
  unsigned int v23; // r2
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r9
  unsigned int i; // r7
  _DWORD *v33; // r0
  _DWORD *v34; // r8
  _DWORD *v35; // r0
  int v36; // r10
  int v37; // r10
  _DWORD *v38; // r0
  _DWORD *v39; // r0
  _DWORD *v40; // r0
  _DWORD *v41; // r0
  _DWORD *v42; // r0
  _DWORD *v43; // r0
  _DWORD *v44; // r0
  _DWORD *v45; // r0
  _DWORD *v46; // r0
  _DWORD *v47; // r0
  _DWORD *v48; // r0
  _DWORD *v49; // r8
  unsigned int j; // r7
  _DWORD *v51; // r0
  _DWORD *v52; // r9
  _DWORD *v53; // r0
  int v54; // r11
  int v55; // r11
  _DWORD *v56; // r0
  _DWORD *v57; // r0
  _DWORD *v58; // r0
  _DWORD *v59; // r0
  _DWORD *v60; // r7
  _DWORD *v61; // r0
  _DWORD *v62; // r0
  _DWORD *v63; // r0
  _DWORD *v64; // r0
  _DWORD *v65; // r8
  unsigned int v66; // r7
  _DWORD *v67; // r0
  _DWORD *v68; // r5
  _DWORD *v69; // r0
  int v70; // r11
  int v71; // r11
  _DWORD *v72; // r0
  _DWORD *v73; // r0
  _DWORD *v74; // r0
  _DWORD *v75; // r8
  unsigned int k; // r7
  _DWORD *v77; // r0
  _DWORD *v78; // r9
  _DWORD *v79; // r0
  int v80; // r10
  int v81; // r10
  _DWORD *v82; // r0
  _DWORD *v83; // r0
  _DWORD *v84; // r0
  int v85; // r11
  _DWORD *v86; // r0
  _DWORD *v87; // r0
  _DWORD *v88; // r8
  unsigned int v89; // r7
  bool v90; // cc
  unsigned int v91; // r1
  _DWORD *v92; // r0
  int v93; // r9
  int v94; // r0
  void *v95; // r3
  char *v96; // r2
  char *v97; // r2
  char *v98; // r11
  int v99; // r4
  char *v100; // r5
  int v101; // r11
  char *v102; // r4
  int m; // r9
  const char *v104; // r0
  const char *v105; // r0
  _DWORD *v106; // [sp+Ch] [bp-2118h]
  _DWORD *v107; // [sp+18h] [bp-210Ch]
  char *v108; // [sp+18h] [bp-210Ch]
  char *v109; // [sp+1Ch] [bp-2108h]
  char v110[252]; // [sp+24h] [bp-2100h] BYREF
  char s[8196]; // [sp+120h] [bp-2004h] BYREF

  v0 = byte_65B380;
  memset(byte_65B380, 0, 0x644u);
  v1 = sub_7AD44("/tmp/miner_simulator.json", 0, v110);
  v2 = v1;
  if ( !v1 || *v1 )
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "load miner simulator config file %s failed\n", "/tmp/miner_simulator.json");
      sub_41DB8(4, s, 0);
    }
    return;
  }
  v3 = (_DWORD *)sub_7C250(v1, "enable_sim_mode");
  if ( !v3 || (unsigned int)(*v3 - 5) > 1 )
    goto LABEL_7;
  v4 = *v3 == 5;
  byte_65B380[0] = *v3 == 5;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "miner_sim.enable_sim_mode:%d\n", v4);
    sub_41DB8(4, s, 0);
LABEL_7:
    v4 = (unsigned __int8)byte_65B380[0];
  }
  if ( v4 && (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "miner sim mode enabled\n");
    sub_41DB8(3, s, 0);
  }
  v5 = (_DWORD *)sub_7C250(v2, "chain_present");
  v6 = v5;
  if ( v5 && !*v5 )
  {
    v27 = (_DWORD *)sub_7C250(v5, "enable_sim_mode");
    if ( v27 && (unsigned int)(*v27 - 5) <= 1 )
      byte_65B384 = *v27 == 5;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.chain_present.enable_sim_mode:%d\n", (unsigned __int8)byte_65B384);
      sub_41DB8(4, s, 0);
    }
    v28 = (_DWORD *)sub_7C250(v6, "chain_present_map");
    if ( v28 && *v28 == 3 )
      dword_65B388 = sub_7DF10((int)v28);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.chain_present.chain_present_map:%d\n", dword_65B388);
      sub_41DB8(4, s, 0);
    }
  }
  v7 = (_DWORD *)sub_7C250(v2, "eeprom");
  v8 = v7;
  if ( v7 && !*v7 )
  {
    v29 = (_DWORD *)sub_7C250(v7, "enable_sim_mode");
    if ( v29 && (unsigned int)(*v29 - 5) <= 1 )
      byte_65B38C = *v29 == 5;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.eeprom.enable_sim_mode:%d\n", (unsigned __int8)byte_65B38C);
      sub_41DB8(4, s, 0);
    }
    v30 = (_DWORD *)sub_7C250(v8, "eeprom_info");
    v31 = v30;
    if ( v30 && *v30 == 1 )
    {
      for ( i = 0; sub_7CD9C(v31) > i; ++i )
      {
        v33 = (_DWORD *)sub_7CDE8(v31, i);
        v34 = v33;
        if ( v33 && !*v33 )
        {
          v35 = (_DWORD *)sub_7C250(v33, "chain_id");
          v36 = (int)v35;
          if ( v35 && *v35 == 3 && sub_7DF10((int)v35) < 4 )
            v37 = sub_7DF10(v36);
          else
            v37 = 0;
          v38 = (_DWORD *)sub_7C250(v34, "board_name");
          if ( v38 && *v38 == 2 )
          {
            v105 = (const char *)sub_7DA40(v38);
            strncpy(&byte_65B380[30 * v37 + 14], v105, 0xAu);
          }
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(s, 0x2000u, "miner_sim.eeprom.eeprom_info[%d].board_name:%s\n", v37, &byte_65B380[30 * v37 + 14]);
            sub_41DB8(4, s, 0);
          }
          v39 = (_DWORD *)sub_7C250(v34, "chip_bin");
          if ( v39 && *v39 == 3 )
            byte_65B380[30 * v37 + 24] = sub_7DF10((int)v39);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.eeprom.eeprom_info[%d].chip_bin:%d\n",
              v37,
              (unsigned __int8)byte_65B380[30 * v37 + 24]);
            sub_41DB8(4, s, 0);
          }
          v40 = (_DWORD *)sub_7C250(v34, "ft_version");
          if ( v40 && *v40 == 2 )
          {
            v104 = (const char *)sub_7DA40(v40);
            strncpy(&byte_65B380[30 * v37 + 25], v104, 0xAu);
          }
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(s, 0x2000u, "miner_sim.eeprom.eeprom_info[%d].ft_version:%s\n", v37, &byte_65B380[30 * v37 + 25]);
            sub_41DB8(4, s, 0);
          }
          v41 = (_DWORD *)sub_7C250(v34, "pt1_result");
          if ( v41 && *v41 == 3 )
            byte_65B380[30 * v37 + 35] = sub_7DF10((int)v41);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.eeprom.eeprom_info[%d].pt1_result:%d\n",
              v37,
              (unsigned __int8)byte_65B380[30 * v37 + 35]);
            sub_41DB8(4, s, 0);
          }
          v42 = (_DWORD *)sub_7C250(v34, "voltage");
          if ( v42 && *v42 == 3 )
            *(_WORD *)&byte_65B380[30 * v37 + 36] = sub_7DF10((int)v42);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.eeprom.eeprom_info[%d].voltage:%d\n",
              v37,
              *(unsigned __int16 *)&byte_65B380[30 * v37 + 36]);
            sub_41DB8(4, s, 0);
          }
          v43 = (_DWORD *)sub_7C250(v34, "frequency");
          if ( v43 && *v43 == 3 )
            *(_WORD *)&byte_65B380[30 * v37 + 38] = sub_7DF10((int)v43);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.eeprom.eeprom_info[%d].frequency:%d\n",
              v37,
              *(unsigned __int16 *)&byte_65B380[30 * v37 + 38]);
            sub_41DB8(4, s, 0);
          }
          v44 = (_DWORD *)sub_7C250(v34, "test_standard");
          if ( v44 && *v44 == 3 )
            byte_65B380[30 * v37 + 40] = sub_7DF10((int)v44);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.eeprom.eeprom_info[%d].test_standard:%d\n",
              v37,
              (unsigned __int8)byte_65B380[30 * v37 + 40]);
            sub_41DB8(4, s, 0);
          }
          v45 = (_DWORD *)sub_7C250(v34, "pt2_result");
          if ( v45 && *v45 == 3 )
            byte_65B380[30 * v37 + 41] = sub_7DF10((int)v45);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.eeprom.eeprom_info[%d].pt2_result:%d\n",
              v37,
              (unsigned __int8)byte_65B380[30 * v37 + 41]);
            sub_41DB8(4, s, 0);
          }
          v46 = (_DWORD *)sub_7C250(v34, "clearance_flag");
          if ( v46 && *v46 == 3 )
            byte_65B380[30 * v37 + 42] = sub_7DF10((int)v46);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.eeprom.eeprom_info[%d].clearance_flag:%d\n",
              v37,
              (unsigned __int8)byte_65B380[30 * v37 + 42]);
            sub_41DB8(4, s, 0);
          }
        }
      }
    }
  }
  v9 = (_DWORD *)sub_7C250(v2, "fan");
  v10 = v9;
  if ( v9 && !*v9 )
  {
    v47 = (_DWORD *)sub_7C250(v9, "enable_sim_mode");
    if ( v47 && (unsigned int)(*v47 - 5) <= 1 )
      byte_65B406 = *v47 == 5;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.fan.enable_sim_mode:%d\n", (unsigned __int8)byte_65B406);
      sub_41DB8(4, s, 0);
    }
    v48 = (_DWORD *)sub_7C250(v10, "fan_info");
    v49 = v48;
    if ( v48 && *v48 == 1 )
    {
      for ( j = 0; sub_7CD9C(v49) > j; ++j )
      {
        v51 = (_DWORD *)sub_7CDE8(v49, j);
        v52 = v51;
        if ( v51 && !*v51 )
        {
          v53 = (_DWORD *)sub_7C250(v51, "fan_id");
          v54 = (int)v53;
          if ( v53 && *v53 == 3 && sub_7DF10((int)v53) < 4 )
            v55 = sub_7DF10(v54);
          else
            v55 = 0;
          v56 = (_DWORD *)sub_7C250(v52, "bringup_speed");
          if ( v56 && *v56 == 3 )
            *(_WORD *)&byte_65B380[4 * v55 + 136] = sub_7DF10((int)v56);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.fan.fan_info[%d].bringup_speed:%d\n",
              v55,
              *(unsigned __int16 *)&byte_65B380[4 * v55 + 136]);
            sub_41DB8(4, s, 0);
          }
          v57 = (_DWORD *)sub_7C250(v52, "running_speed");
          if ( v57 && *v57 == 3 )
            *(_WORD *)&byte_65B380[4 * v55 + 138] = sub_7DF10((int)v57);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.fan.fan_info[%d].running_speed:%d\n",
              v55,
              *(unsigned __int16 *)&byte_65B380[4 * v55 + 138]);
            sub_41DB8(4, s, 0);
          }
        }
      }
    }
  }
  v11 = (_DWORD *)sub_7C250(v2, "power");
  v12 = v11;
  if ( v11 && !*v11 )
  {
    v58 = (_DWORD *)sub_7C250(v11, "enable_sim_mode");
    if ( v58 && (unsigned int)(*v58 - 5) <= 1 )
      byte_65B418 = *v58 == 5;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.power.enable_sim_mode:%d\n", (unsigned __int8)byte_65B418);
      sub_41DB8(4, s, 0);
    }
    v59 = (_DWORD *)sub_7C250(v12, "power_info");
    v60 = v59;
    if ( v59 && !*v59 )
    {
      v61 = (_DWORD *)sub_7C250(v59, "power_version");
      if ( v61 && *v61 == 3 )
        dword_65B41C = sub_7DF10((int)v61);
      v62 = (_DWORD *)sub_7C250(v60, "power");
      if ( v62 && *v62 == 3 )
        dword_65B420 = sub_7DF10((int)v62);
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.power.power_info.power_version:%d\n", dword_65B41C);
      sub_41DB8(4, s, 0);
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(s, 0x2000u, "miner_sim.power.power_info.power:%d\n", dword_65B420);
        sub_41DB8(4, s, 0);
      }
    }
  }
  v13 = (_DWORD *)sub_7C250(v2, "chain_asic");
  v14 = v13;
  if ( v13 && !*v13 )
  {
    v63 = (_DWORD *)sub_7C250(v13, "enable_sim_mode");
    if ( v63 && (unsigned int)(*v63 - 5) <= 1 )
      byte_65B424 = *v63 == 5;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.asic.enable_sim_mode:%d\n", (unsigned __int8)byte_65B424);
      sub_41DB8(4, s, 0);
    }
    v64 = (_DWORD *)sub_7C250(v14, "asic_info");
    v65 = v64;
    if ( v64 && *v64 == 1 )
    {
      v66 = 0;
      v106 = v2;
      while ( sub_7CD9C(v65) > v66 )
      {
        v67 = (_DWORD *)sub_7CDE8(v65, v66);
        v68 = v67;
        if ( v67 && !*v67 )
        {
          v69 = (_DWORD *)sub_7C250(v67, "chain_id");
          v70 = (int)v69;
          if ( v69 && *v69 == 3 && sub_7DF10((int)v69) < 4 )
            v71 = sub_7DF10(v70);
          else
            v71 = 0;
          v72 = (_DWORD *)sub_7C250(v68, "asic_num");
          if ( v72 && *v72 == 3 )
            *(_WORD *)&byte_65B380[2 * v71 + 166] = sub_7DF10((int)v72);
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.asic.asic_info[%d].asic_num:%d\n",
              v71,
              *(unsigned __int16 *)&byte_65B380[2 * v71 + 166]);
            sub_41DB8(4, s, 0);
          }
        }
        ++v66;
      }
      v2 = v106;
    }
  }
  v15 = (_DWORD *)sub_7C250(v2, "sensor");
  v16 = v15;
  if ( v15 && !*v15 )
  {
    v73 = (_DWORD *)sub_7C250(v15, "enable_sim_mode");
    if ( v73 && (unsigned int)(*v73 - 5) <= 1 )
      byte_65B430 = *v73 == 5;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.sensor.enable_sim_mode:%d\n", (unsigned __int8)byte_65B430);
      sub_41DB8(4, s, 0);
    }
    v74 = (_DWORD *)sub_7C250(v16, "sensor_info");
    v75 = v74;
    if ( v74 && *v74 == 1 )
    {
      for ( k = 0; sub_7CD9C(v75) > k; ++k )
      {
        v77 = (_DWORD *)sub_7CDE8(v75, k);
        v78 = v77;
        if ( v77 && !*v77 )
        {
          v79 = (_DWORD *)sub_7C250(v77, "sensor_id");
          v80 = (int)v79;
          if ( v79 && *v79 == 3 && sub_7DF10((int)v79) < 8 )
            v81 = sub_7DF10(v80);
          else
            v81 = 0;
          v82 = (_DWORD *)sub_7C250(v78, "force_failed");
          if ( v82 && (unsigned int)(*v82 - 5) <= 1 )
          {
            v97 = &v0[12 * v81];
            v97[180] = *v82 == 5;
            v97[276] = *v82 == 5;
            v97[372] = *v82 == 5;
            v97[468] = *v82 == 5;
          }
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.sensor.sensor_info[0][%d].force_failed:%d\n",
              v81,
              (unsigned __int8)v0[12 * v81 + 180]);
            sub_41DB8(4, s, 0);
          }
          v83 = (_DWORD *)sub_7C250(v78, "bringup_temp");
          if ( v83 && *v83 == 3 )
          {
            v107 = v2;
            v98 = &v0[12 * v81];
            v109 = v0;
            v99 = 0;
            v100 = v98;
            v101 = (int)v83;
            do
            {
              ++v99;
              *((_DWORD *)v100 + 46) = sub_7DF10(v101);
              v100 += 96;
            }
            while ( v99 != 4 );
            v2 = v107;
            v0 = v109;
          }
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.sensor.sensor_info[0][%d].bringup_temp:%d\n",
              v81,
              *(_DWORD *)&v0[12 * v81 + 184]);
            sub_41DB8(4, s, 0);
          }
          v84 = (_DWORD *)sub_7C250(v78, "running_temp");
          v85 = (int)v84;
          if ( v84 && *v84 == 3 )
          {
            v108 = v0;
            v102 = &v0[12 * v81];
            for ( m = 0; m != 4; ++m )
            {
              *((_DWORD *)v102 + 47) = sub_7DF10(v85);
              v102 += 96;
            }
            v0 = v108;
          }
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "miner_sim.sensor.sensor_info[0][%d].bringup_temp:%d\n",
              v81,
              *(_DWORD *)&v0[12 * v81 + 188]);
            sub_41DB8(4, s, 0);
          }
        }
      }
    }
  }
  v17 = (_DWORD *)sub_7C250(v2, "miner_bad_asic");
  v18 = v17;
  if ( v17 && !*v17 )
  {
    v86 = (_DWORD *)sub_7C250(v17, "enable_sim_mode");
    if ( v86 && (unsigned int)(*v86 - 5) <= 1 )
      v0[564] = *v86 == 5;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.bad_asic.enable_sim_mode:%d\n", (unsigned __int8)v0[564]);
      sub_41DB8(4, s, 0);
    }
    v87 = (_DWORD *)sub_7C250(v18, "bad_asic_info");
    v88 = v87;
    if ( v87 && *v87 == 1 )
    {
      v89 = 0;
      while ( 1 )
      {
        v90 = sub_7CD9C(v88) > v89;
        v91 = v89++;
        if ( !v90 )
          break;
        v92 = (_DWORD *)sub_7CDE8(v88, v91);
        v93 = (int)v92;
        if ( v92 )
        {
          if ( *v92 == 3 && sub_7DF10((int)v92) < 256 )
          {
            v94 = sub_7DF10(v93);
            v95 = off_BC5EC;
            v96 = &v0[v94];
            v96[565] = 1;
            v96[821] = 1;
            v96[1077] = 1;
            v96[1333] = 1;
            if ( (unsigned int)v95 > 4 )
            {
              snprintf(s, 0x2000u, "miner_sim.bad_asic.bad_asic_info[0][%d].bad_asic:%d\n", v94, 1);
              sub_41DB8(4, s, 0);
            }
          }
        }
      }
    }
  }
  v19 = (_DWORD *)sub_7C250(v2, "miner_hashrate");
  v20 = v19;
  if ( v19 && !*v19 )
  {
    v24 = (_DWORD *)sub_7C250(v19, "enable_sim_mode");
    if ( v24 && (unsigned int)(*v24 - 5) <= 1 )
      v0[1592] = *v24 == 5;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.hashrate.enable_sim_mode:%d\n", (unsigned __int8)v0[1592]);
      sub_41DB8(4, s, 0);
    }
    v25 = (_DWORD *)sub_7C250(v20, "hashrate");
    if ( v25 && *v25 == 3 )
      *((_DWORD *)v0 + 399) = sub_7DF10((int)v25);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.hashrate.hashrate:%d\n", *((_DWORD *)v0 + 399));
      sub_41DB8(4, s, 0);
    }
    v26 = (_DWORD *)sub_7C250(v20, "avg_hashrate");
    if ( v26 && *v26 == 3 )
      *((_DWORD *)v0 + 400) = sub_7DF10((int)v26);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "miner_sim.hashrate.avg_hashrate:%d\n", *((_DWORD *)v0 + 400));
      sub_41DB8(4, s, 0);
    }
  }
  if ( v2[1] != -1 )
  {
    v21 = v2 + 1;
    __dmb(0xBu);
    do
    {
      v22 = __ldrex(v21);
      v23 = v22 - 1;
    }
    while ( __strex(v23, v21) );
    if ( !v23 )
      sub_7E3BC(v2);
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 65B384: using guessed type char byte_65B384;
// 65B388: using guessed type int dword_65B388;
// 65B38C: using guessed type char byte_65B38C;
// 65B406: using guessed type char byte_65B406;
// 65B418: using guessed type char byte_65B418;
// 65B41C: using guessed type int dword_65B41C;
// 65B420: using guessed type int dword_65B420;
// 65B424: using guessed type char byte_65B424;
// 65B430: using guessed type char byte_65B430;

//----- (00029C30) --------------------------------------------------------
int sub_29C30()
{
  return (unsigned __int8)byte_65B380;
}
// 65B380: using guessed type char byte_65B380;

//----- (00029C40) --------------------------------------------------------
int sub_29C40()
{
  return (unsigned __int8)byte_65B384;
}
// 65B384: using guessed type char byte_65B384;

//----- (00029C50) --------------------------------------------------------
int sub_29C50()
{
  return (unsigned __int8)byte_65B38C;
}
// 65B38C: using guessed type char byte_65B38C;

//----- (00029C60) --------------------------------------------------------
int sub_29C60()
{
  return (unsigned __int8)byte_65B406;
}
// 65B406: using guessed type char byte_65B406;

//----- (00029C70) --------------------------------------------------------
int sub_29C70()
{
  return (unsigned __int8)byte_65B418;
}
// 65B418: using guessed type char byte_65B418;

//----- (00029C80) --------------------------------------------------------
int sub_29C80()
{
  return (unsigned __int8)byte_65B424;
}
// 65B424: using guessed type char byte_65B424;

//----- (00029C90) --------------------------------------------------------
int sub_29C90()
{
  return (unsigned __int8)byte_65B430;
}
// 65B430: using guessed type char byte_65B430;

//----- (00029CA0) --------------------------------------------------------
int sub_29CA0()
{
  return (unsigned __int8)byte_65B5B4;
}
// 65B5B4: using guessed type char byte_65B5B4;

//----- (00029CB0) --------------------------------------------------------
int sub_29CB0()
{
  return (unsigned __int8)byte_65B9B8;
}
// 65B9B8: using guessed type char byte_65B9B8;

//----- (00029CC0) --------------------------------------------------------
int sub_29CC0()
{
  return dword_65B388;
}
// 65B388: using guessed type int dword_65B388;

//----- (00029CD0) --------------------------------------------------------
char *__fastcall sub_29CD0(int a1)
{
  return &byte_65B380[30 * a1 + 14];
}

//----- (00029CEC) --------------------------------------------------------
int __fastcall sub_29CEC(int a1)
{
  return (unsigned __int8)byte_65B380[30 * a1 + 24];
}

//----- (00029D04) --------------------------------------------------------
char *__fastcall sub_29D04(int a1)
{
  return &byte_65B380[30 * a1 + 25];
}

//----- (00029D20) --------------------------------------------------------
int __fastcall sub_29D20(int a1)
{
  return (unsigned __int8)byte_65B380[30 * a1 + 35];
}

//----- (00029D38) --------------------------------------------------------
int __fastcall sub_29D38(int a1)
{
  return *(unsigned __int16 *)&byte_65B380[30 * a1 + 36];
}

//----- (00029D50) --------------------------------------------------------
int __fastcall sub_29D50(int a1)
{
  return *(unsigned __int16 *)&byte_65B380[30 * a1 + 38];
}

//----- (00029D68) --------------------------------------------------------
int __fastcall sub_29D68(int a1)
{
  return (unsigned __int8)byte_65B380[30 * a1 + 40];
}

//----- (00029D80) --------------------------------------------------------
int __fastcall sub_29D80(int a1)
{
  return (unsigned __int8)byte_65B380[30 * a1 + 41];
}

//----- (00029D98) --------------------------------------------------------
int __fastcall sub_29D98(int a1)
{
  return (unsigned __int8)byte_65B380[30 * a1 + 42];
}

//----- (00029DB0) --------------------------------------------------------
int __fastcall sub_29DB0(int a1)
{
  return (unsigned __int8)byte_65B380[4 * a1 + 136];
}

//----- (00029DC4) --------------------------------------------------------
int __fastcall sub_29DC4(int a1)
{
  return (unsigned __int8)byte_65B380[4 * a1 + 138];
}

//----- (00029DD8) --------------------------------------------------------
int sub_29DD8()
{
  return dword_65B41C;
}
// 65B41C: using guessed type int dword_65B41C;

//----- (00029DE8) --------------------------------------------------------
int sub_29DE8()
{
  return dword_65B420;
}
// 65B420: using guessed type int dword_65B420;

//----- (00029DF8) --------------------------------------------------------
int __fastcall sub_29DF8(int a1)
{
  return (unsigned __int8)byte_65B380[2 * a1 + 166];
}

//----- (00029E0C) --------------------------------------------------------
int __fastcall sub_29E0C(int a1, int a2)
{
  return (unsigned __int8)byte_65B380[96 * a1 + 180 + 12 * a2];
}

//----- (00029E30) --------------------------------------------------------
int __fastcall sub_29E30(int a1, int a2)
{
  return *(_DWORD *)&byte_65B380[96 * a1 + 184 + 12 * a2];
}

//----- (00029E54) --------------------------------------------------------
int __fastcall sub_29E54(int a1, int a2)
{
  return *(_DWORD *)&byte_65B380[96 * a1 + 188 + 12 * a2];
}

//----- (00029E78) --------------------------------------------------------
int __fastcall sub_29E78(int a1, int a2)
{
  return (unsigned __int8)byte_65B380[256 * a1 + 565 + a2];
}

//----- (00029E90) --------------------------------------------------------
int sub_29E90()
{
  return dword_65B9BC;
}
// 65B9BC: using guessed type int dword_65B9BC;

//----- (00029EA0) --------------------------------------------------------
int sub_29EA0()
{
  return dword_65B9C0;
}
// 65B9C0: using guessed type int dword_65B9C0;

//----- (00029EB0) --------------------------------------------------------
int sub_29EB0()
{
  int v0; // r4
  int result; // r0

  v0 = 0;
  result = sub_27EC8(0);
  if ( result )
    goto LABEL_4;
  while ( ++v0 != 4 )
  {
    result = sub_27EC8(v0);
    if ( result )
LABEL_4:
      result = sub_803AC((unsigned __int8)v0, 0);
  }
  return result;
}

//----- (00029EF4) --------------------------------------------------------
int __fastcall sub_29EF4(unsigned int a1, unsigned int a2)
{
  return sub_80B44(a1, a2, 1);
}

//----- (00029EFC) --------------------------------------------------------
int __fastcall sub_29EFC(unsigned int a1, unsigned int a2)
{
  return sub_80B44(a1, a2, 0);
}

//----- (00029F04) --------------------------------------------------------
int __fastcall sub_29F04(unsigned int a1)
{
  return sub_80AE8(a1, 1);
}

//----- (00029F0C) --------------------------------------------------------
int __fastcall sub_29F0C(unsigned int a1)
{
  int v1; // r4
  int result; // r0

  v1 = 0;
  result = sub_27EC8(0);
  if ( result )
    goto LABEL_4;
  while ( ++v1 != 4 )
  {
    result = sub_27EC8(v1);
    if ( result )
LABEL_4:
      result = sub_7F308((unsigned __int8)v1, a1);
  }
  return result;
}

//----- (00029F58) --------------------------------------------------------
int __fastcall sub_29F58(int a1, unsigned int a2, int a3, char a4)
{
  int i; // r4
  int result; // r0
  bool v10; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      v10 = a1 == 255;
      if ( a1 != 255 )
        v10 = a1 == (unsigned __int8)i;
      if ( v10 )
      {
        if ( a3 )
          result = sub_7FD60((unsigned __int8)i, a4);
        else
          result = sub_7FD34((unsigned __int8)i, a2, a4);
      }
    }
  }
  return result;
}

//----- (00029FC4) --------------------------------------------------------
int __fastcall sub_29FC4(int a1)
{
  int v2; // r4
  int v3; // r0
  int v4; // r5
  int result; // r0
  bool v6; // zf

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_27EC8(v3);
      if ( result )
      {
        v6 = a1 == 255;
        if ( a1 != 255 )
          v6 = a1 == v4;
        if ( v6 )
          break;
      }
      if ( v2 == 4 )
        return result;
    }
    result = sub_81190();
  }
  while ( v2 != 4 );
  return result;
}

//----- (0002A014) --------------------------------------------------------
int __fastcall sub_2A014(unsigned int a1)
{
  int v2; // r4
  int v3; // r0
  int v4; // r5
  int result; // r0

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_27EC8(v3);
      if ( result )
        break;
      if ( v2 == 4 )
        return result;
    }
    result = sub_7F4DC(v4, a1);
  }
  while ( v2 != 4 );
  return result;
}

//----- (0002A05C) --------------------------------------------------------
int __fastcall sub_2A05C(__int16 a1)
{
  int v2; // r4
  int v3; // r0
  unsigned int v4; // r5
  int result; // r0

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_27EC8(v3);
      if ( result )
        break;
      if ( v2 == 4 )
        return result;
    }
    result = sub_7FD9C(v4, 1, (unsigned __int8)dword_BC5A4, a1);
  }
  while ( v2 != 4 );
  return result;
}
// BC5A4: using guessed type int dword_BC5A4;

//----- (0002A0B4) --------------------------------------------------------
int sub_2A0B4()
{
  int result; // r0
  int v1; // r5
  int v2; // r10
  int i; // r4
  int v4; // r6
  int v6; // r0
  int v7; // r4
  int v8; // r9
  int v9; // r0
  int v10; // r6
  int v12; // r10
  __int16 v13; // r7
  __int16 v14; // r0
  int v15; // r9
  __int16 v16; // r7
  __int16 v17; // r0
  char v18[8192]; // [sp+8h] [bp-2000h] BYREF

  result = sub_27D0C();
  if ( result > 9 )
  {
    result = sub_27D0C();
    v1 = result - 1;
    if ( result - 1 >= 0 )
    {
      do
      {
        v2 = v1 * sub_27D2C();
        for ( i = 0; i != 4; ++i )
        {
          v4 = (unsigned __int8)i;
          if ( sub_27EC8(i) )
          {
            v15 = sub_27D8C();
            v16 = sub_27D0C() - v1;
            v17 = sub_27D2C();
            sub_80AB8(v4, v2 * v15, v17 * v16 + 14, 1, 1);
          }
        }
        v6 = sub_27D2C();
        v7 = 0;
        v8 = v6 + v1 * v6 - 1;
        do
        {
          v9 = v7;
          v10 = (unsigned __int8)v7++;
          result = sub_27EC8(v9);
          if ( result )
          {
            v12 = sub_27D8C();
            v13 = sub_27D0C() - v1;
            v14 = sub_27D2C();
            result = sub_80AB8(v10, v8 * v12, v14 * v13 + 14, 1, 1);
          }
        }
        while ( v7 != 4 );
      }
      while ( v1-- != 0 );
    }
  }
  else if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v18, "no need to set uart relay\n");
    return sub_41DB8(4, v18, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0002A220) --------------------------------------------------------
int __fastcall sub_2A220(int a1, int a2, char a3, char a4)
{
  double v4; // d0
  int i; // r4
  int result; // r0
  bool v11; // zf
  __time_t v12[3]; // [sp+0h] [bp-Ch] BYREF

  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      v11 = a1 == i;
      if ( a1 != i )
        v11 = a1 == 255;
      if ( v11 )
      {
        if ( a2 == 1 )
        {
          pthread_mutex_lock(&stru_BDC8C);
          sub_4465C(v12);
          sub_44984();
          if ( v4 < 0.006 )
            sub_448BC();
          sub_7F210((unsigned __int8)i, 1, a3, a4);
          sub_27D1C();
          sub_448BC();
          result = pthread_mutex_unlock(&stru_BDC8C);
        }
        else
        {
          pthread_mutex_lock(&stru_BDC8C);
          sub_7F210((unsigned __int8)i, a2, a3, a4);
          sub_4465C(dword_BDCA4);
          result = pthread_mutex_unlock(&stru_BDC8C);
        }
      }
    }
  }
  return result;
}
// 2A2DC: variable 'v4' is possibly undefined
// BDC8C: using guessed type pthread_mutex_t stru_BDC8C;
// BDCA4: using guessed type __time_t[2];

//----- (0002A338) --------------------------------------------------------
int sub_2A338()
{
  return 0;
}

//----- (0002A364) --------------------------------------------------------
int sub_2A364()
{
  int i; // r4
  unsigned __int8 v2; // r0
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
  {
    snprintf(v3, 0x2000u, "--- %s\n", "dhash_chip_set_addr_all");
    sub_41DB8(7, v3, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      sub_7F26C((unsigned __int8)i);
      sub_44890();
      v2 = sub_27D8C();
      sub_7F270((unsigned __int8)i, v2);
    }
  }
  return sub_44890();
}
// 7F26C: using guessed type int __fastcall sub_7F26C(_DWORD);
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002A44C) --------------------------------------------------------
int __fastcall sub_2A44C(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  unsigned int *p_varg_r0; // r2
  unsigned __int8 *v10; // r1
  int v11; // r12
  int v12; // r3
  int *v13; // r1
  int v14; // r3
  _DWORD var34[17]; // [sp+4h] [bp-34h] BYREF
  unsigned int varg_r0; // [sp+48h] [bp+10h] BYREF
  int varg_r1; // [sp+4Ch] [bp+14h]
  int varg_r2; // [sp+50h] [bp+18h]
  int varg_r3; // [sp+54h] [bp+1Ch]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  memset(&var34[2], 0, 0x2Cu);
  p_varg_r0 = &varg_r0;
  v10 = (unsigned __int8 *)&varg_r0;
  v11 = 2;
  var34[0] = bswap32(varg_r0);
  var34[1] = varg_r1;
  do
  {
    v12 = v10[9];
    v10 += 4;
    var34[v11++] = (v12 << 16) | (v10[4] << 24) | v10[7] | (v10[6] << 8);
  }
  while ( v11 != 5 );
  v13 = &var34[5];
  do
  {
    v14 = *((unsigned __int8 *)p_varg_r0++ + 21);
    *v13++ = (v14 << 16)
           | (*((unsigned __int8 *)p_varg_r0 + 16) << 24)
           | *((unsigned __int8 *)p_varg_r0 + 19)
           | (*((unsigned __int8 *)p_varg_r0 + 18) << 8);
  }
  while ( p_varg_r0 != (unsigned int *)&a9 );
  return sub_64214((int)var34, 0x34u);
}

//----- (0002A514) --------------------------------------------------------
int __fastcall sub_2A514(
        unsigned int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17)
{
  unsigned int *p_varg_r0; // r2
  unsigned __int8 *v18; // r1
  int v19; // r12
  int v20; // r3
  int *v21; // r1
  int v22; // r3
  _DWORD var94[41]; // [sp+4h] [bp-94h] BYREF
  unsigned int varg_r0; // [sp+A8h] [bp+10h] BYREF
  int varg_r1; // [sp+ACh] [bp+14h]
  int varg_r2; // [sp+B0h] [bp+18h]
  int varg_r3; // [sp+B4h] [bp+1Ch]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  memset(&var94[2], 0, 0x8Cu);
  p_varg_r0 = &varg_r0;
  v18 = (unsigned __int8 *)&varg_r0;
  v19 = 2;
  var94[0] = bswap32(varg_r0);
  var94[1] = varg_r1;
  do
  {
    v20 = v18[9];
    v18 += 4;
    var94[v19++] = (v20 << 16) | (v18[4] << 24) | v18[7] | (v18[6] << 8);
  }
  while ( v19 != 5 );
  v21 = &var94[5];
  do
  {
    v22 = *((unsigned __int8 *)p_varg_r0++ + 21);
    *v21++ = (v22 << 16)
           | (*((unsigned __int8 *)p_varg_r0 + 16) << 24)
           | *((unsigned __int8 *)p_varg_r0 + 19)
           | (*((unsigned __int8 *)p_varg_r0 + 18) << 8);
  }
  while ( p_varg_r0 != (unsigned int *)&a17 );
  return sub_64214((int)var94, 0x54u);
}

//----- (0002A5DC) --------------------------------------------------------
int __fastcall sub_2A5DC(int a1, int a2)
{
  int v2; // r4
  int result; // r0

  v2 = 0;
  result = sub_27EC8(0);
  if ( result )
    goto LABEL_4;
  while ( ++v2 != 4 )
  {
    result = sub_27EC8(v2);
    if ( result )
LABEL_4:
      result = sub_80BFC((unsigned __int8)v2, a2, 0);
  }
  return result;
}

//----- (0002A628) --------------------------------------------------------
int __fastcall sub_2A628(int a1, char a2, char a3, char a4)
{
  int v4; // r4
  int result; // r0

  v4 = 0;
  result = sub_27EC8(0);
  if ( result )
    goto LABEL_4;
  while ( ++v4 != 4 )
  {
    result = sub_27EC8(v4);
    if ( result )
LABEL_4:
      result = sub_80C38((unsigned __int8)v4, a2, a3, a4);
  }
  return result;
}

//----- (0002A680) --------------------------------------------------------
int __fastcall sub_2A680(int a1)
{
  int i; // r4
  int result; // r0
  bool v4; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      v4 = a1 == i;
      if ( a1 != i )
        v4 = a1 == 255;
      result = (unsigned __int8)i;
      if ( v4 )
        result = sub_80D40((unsigned __int8)i, 1);
    }
  }
  return result;
}

//----- (0002A6C8) --------------------------------------------------------
int sub_2A6C8()
{
  unsigned __int8 vars0; // [sp+0h] [bp+0h]
  unsigned __int8 vars1; // [sp+1h] [bp+1h]
  unsigned __int8 vars2; // [sp+2h] [bp+2h]
  unsigned __int16 vars4; // [sp+4h] [bp+4h]
  unsigned __int8 vars6; // [sp+6h] [bp+6h]

  return (int)(float)((float)((float)(25.0 / (float)vars2) * (float)vars4) / (float)(vars6 * vars0 * vars1));
}
// 2A6E4: variable 'vars2' is possibly undefined
// 2A6F4: variable 'vars4' is possibly undefined
// 2A6FC: variable 'vars6' is possibly undefined
// 2A6F0: variable 'vars0' is possibly undefined
// 2A6F0: variable 'vars1' is possibly undefined

//----- (0002A728) --------------------------------------------------------
int __fastcall sub_2A728(int a1, int a2)
{
  int i; // r4
  int result; // r0
  bool v6; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      v6 = a1 == 255;
      if ( a1 != 255 )
        v6 = i == a1;
      if ( v6 )
      {
        if ( a2 )
          result = sub_81180();
        else
          result = sub_81170();
      }
    }
  }
  return result;
}

//----- (0002A7AC) --------------------------------------------------------
int __fastcall sub_2A7AC(int a1, int a2, unsigned int a3, unsigned int a4, int a5, unsigned __int16 a6)
{
  int i; // r4
  int result; // r0
  bool v12; // zf

  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      v12 = a1 == 255;
      if ( a1 != 255 )
        v12 = i == a1;
      if ( v12 )
      {
        if ( a2 )
          result = sub_7FAAC((unsigned __int8)i, a4, a5, a6);
        else
          result = sub_7FB40((unsigned __int8)i, a3, a4, a5, a6);
      }
    }
  }
  return result;
}

//----- (0002A834) --------------------------------------------------------
int __fastcall sub_2A834(int a1, int a2)
{
  int v2; // r4
  int result; // r0

  v2 = 0;
  result = sub_27EC8(0);
  if ( result )
    goto LABEL_4;
  while ( ++v2 != 4 )
  {
    result = sub_27EC8(v2);
    if ( result )
    {
LABEL_4:
      sub_81198();
      if ( a2 )
        result = sub_806C8((unsigned __int8)v2);
      else
        result = sub_80720((unsigned __int8)v2);
    }
  }
  return result;
}

//----- (0002A894) --------------------------------------------------------
int __fastcall sub_2A894(int a1)
{
  int v1; // r4
  int result; // r0

  v1 = 0;
  result = sub_27EC8(0);
  if ( result )
    goto LABEL_4;
  while ( ++v1 != 4 )
  {
    result = sub_27EC8(v1);
    if ( result )
LABEL_4:
      result = sub_804C8((unsigned __int8)v1, a1);
  }
  return result;
}

//----- (0002A8DC) --------------------------------------------------------
int __fastcall sub_2A8DC(unsigned __int8 a1, unsigned int a2)
{
  return sub_8051C(a1, a2);
}

//----- (0002A8E4) --------------------------------------------------------
int __fastcall sub_2A8E4(char a1)
{
  int v2; // r4
  int v3; // r0
  unsigned int v4; // r5
  int result; // r0

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_27EC8(v3);
      if ( result )
        break;
      if ( v2 == 4 )
        return result;
    }
    result = sub_8102C(v4, a1);
  }
  while ( v2 != 4 );
  return result;
}

//----- (0002A92C) --------------------------------------------------------
int __fastcall sub_2A92C(char a1)
{
  int v2; // r4
  int v3; // r0
  unsigned int v4; // r5
  int result; // r0

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_27EC8(v3);
      if ( result )
        break;
      if ( v2 == 4 )
        return result;
    }
    result = sub_810E8(v4, a1);
  }
  while ( v2 != 4 );
  return result;
}

//----- (0002A974) --------------------------------------------------------
unsigned int __fastcall sub_2A974(int a1)
{
  unsigned int v1; // r6
  unsigned int v2; // r8
  int v3; // r5
  _DWORD *v4; // r7
  unsigned int v6; // r4
  bool v7; // cc
  int v8; // r1
  _DWORD vars0[6]; // [sp+8h] [bp+0h] BYREF

  v2 = 0;
  v3 = 0;
  v4 = &vars0[a1];
  do
  {
    if ( sub_27EC8(v3) )
    {
      v6 = 0;
      while ( 1 )
      {
        v7 = sub_27D1C() > v6;
        v8 = v6;
        v6 += 10;
        if ( !v7 )
          break;
        v1 = sub_3E42C(*(v4 - 2), v8, v3);
      }
      if ( v2 < (unsigned int)(25.0
                             / (double)((v1 >> 8) & 0x3F)
                             * (double)(HIWORD(v1) & 0xFFF)
                             / (double)(int)(((v1 >> 4) & 7) + 1)
                             / (double)(int)((v1 & 7) + 1)) )
        v2 = (unsigned int)(25.0
                          / (double)((v1 >> 8) & 0x3F)
                          * (double)(HIWORD(v1) & 0xFFF)
                          / (double)(int)(((v1 >> 4) & 7) + 1)
                          / (double)(int)((v1 & 7) + 1));
    }
    ++v3;
  }
  while ( v3 != 4 );
  return v2;
}
// 2A9EC: variable 'v1' is possibly undefined

//----- (0002AA4C) --------------------------------------------------------
int __fastcall sub_2AA4C(int a1)
{
  int v2; // r4
  int v3; // r0
  int v4; // r5
  int result; // r0
  bool v6; // zf

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v3 = v2;
      v4 = (unsigned __int8)v2++;
      result = sub_27EC8(v3);
      if ( result )
      {
        v6 = a1 == 255;
        if ( a1 != 255 )
          v6 = a1 == v4;
        if ( v6 )
          break;
      }
      if ( v2 == 4 )
        return result;
    }
    result = sub_811F8(v4);
  }
  while ( v2 != 4 );
  return result;
}

//----- (0002AA9C) --------------------------------------------------------
int __fastcall sub_2AA9C(int a1, const char *a2, unsigned int a3)
{
  int v3; // r4
  int result; // r0
  char v7[8196]; // [sp+0h] [bp-2004h] BYREF

  v3 = 10;
  sub_8132C(a1, a2, a3);
  do
  {
    result = sub_3E42C(189, (int)a2, a1);
    if ( result < 0 )
      return result & 0x7FFF;
    --v3;
  }
  while ( v3 );
  if ( (unsigned int)off_BC5EC > 5 )
  {
    strcpy(v7, "ADC_VOLTAGE_DATAOUT is not ready");
    return sub_41DB8(5, v7, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0002AB98) --------------------------------------------------------
int __fastcall sub_2AB98(int a1, unsigned int a2)
{
  double v2; // d0
  int v5; // r0
  float *p_s; // r8
  float *v7; // r5
  const char *v8; // r4
  bool v9; // zf
  int *v10; // r0
  float v11; // s16
  int result; // r0
  float v13; // s15
  float *v14; // r2
  float v15; // s14
  int v16; // r3
  int v17; // s15
  int *v18; // r0
  const char *v19; // [sp+18h] [bp-4Ch]
  const char *s; // [sp+28h] [bp-3Ch] BYREF
  float *v21; // [sp+2Ch] [bp-38h]
  const char *v22; // [sp+30h] [bp-34h]
  int v23; // [sp+34h] [bp-30h]

  v5 = sub_27D1C();
  p_s = (float *)&s;
  v21 = (float *)&s;
  memset(&s, 0, 4 * v5);
  v23 = sub_27D1C();
  if ( v23 > 0 )
  {
    v7 = (float *)((char *)&unk_BDCB0 + 4096 * a1 + 4 * a2);
    s = "bmminer_adc";
    v8 = 0;
    v22 = "miner_api/driver-hash-chip.c";
    do
    {
      sub_2AA9C(a1, v8, a2);
      v10 = (int *)dword_BDCAC;
      v11 = v2;
      *p_s++ = v11;
      if ( !v10 )
      {
        v10 = sub_835A0(s);
        dword_BDCAC = (int)v10;
      }
      v19 = v8++;
      sub_85464(
        (int)v10,
        v22,
        28,
        (int)"get_chain_asic_domain_avg_voltage",
        33,
        555,
        20,
        (int)"chain%d, domain%d, asic %03d, voltage:%f",
        a1,
        a2,
        v19,
        v11);
      v9 = v23 == (_DWORD)v8;
      *v7 = v11;
      v7 += 4;
    }
    while ( !v9 );
  }
  result = sub_27D1C();
  if ( result <= 0 )
  {
    v15 = 0.0;
  }
  else
  {
    v13 = *v21;
    if ( *v21 == 0.0 )
      return result;
    v14 = v21 + 1;
    v15 = 0.0;
    v16 = 0;
    while ( 1 )
    {
      ++v16;
      v15 = v15 + v13;
      if ( result == v16 )
        break;
      v13 = *v14++;
      if ( v13 == 0.0 )
        return result;
    }
  }
  v17 = result;
  v18 = (int *)dword_BDCAC;
  if ( !dword_BDCAC )
  {
    v18 = sub_835A0("bmminer_adc");
    dword_BDCAC = (int)v18;
  }
  return sub_85464(
           (int)v18,
           "miner_api/driver-hash-chip.c",
           28,
           (int)"get_chain_asic_domain_avg_voltage",
           33,
           568,
           20,
           (int)"chain%d, domain%d, asic avg voltage:%f",
           a1,
           a2,
           (float)(v15 / (float)v17));
}
// 2AC94: variable 'v2' is possibly undefined
// BDCAC: using guessed type int dword_BDCAC;

//----- (0002ADB0) --------------------------------------------------------
int sub_2ADB0()
{
  int result; // r0

  result = sub_29C30();
  if ( result )
  {
    result = sub_29CB0();
    if ( result )
      return sub_29E90();
  }
  return result;
}
// 6661FC: using guessed type int dword_6661FC;
// 6682B0: using guessed type float flt_6682B0;

//----- (0002AE18) --------------------------------------------------------
int sub_2AE18()
{
  int result; // r0

  result = (unsigned __int8)byte_4D41EC;
  if ( byte_4D41EC )
    return LODWORD(flt_6682B0) - dword_6661FC;
  return result;
}
// 4D41EC: using guessed type char byte_4D41EC;
// 6661FC: using guessed type int dword_6661FC;
// 6682B0: using guessed type float flt_6682B0;

//----- (0002AE4C) --------------------------------------------------------
int __fastcall sub_2AE4C(int result)
{
  _DWORD *v1; // r4
  __int64 v2; // r0
  _QWORD *v3; // r0
  char v4[8192]; // [sp+0h] [bp-2000h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = (unsigned int)sub_47394();
    v3 = sub_7DEB4(v2);
    return sub_7C380(v1, "inited", v3);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v4, 0x2000u, "%s: input bad json param\n", "api_miner_inited");
    return sub_41DB8(3, v4, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002AEF4) --------------------------------------------------------
int __fastcall sub_2AEF4(int result)
{
  _DWORD *v1; // r4
  int v2; // r0
  _QWORD *v3; // r0
  char v4[8192]; // [sp+0h] [bp-2000h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_27EB8();
    v3 = sub_7DEB4(v2);
    return sub_7C380(v1, "chain_num", v3);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v4, 0x2000u, "%s: input bad json param\n", "api_miner_chain_num");
    return sub_41DB8(3, v4, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002AF9C) --------------------------------------------------------
int __fastcall sub_2AF9C(int result)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_7D998(dest);
    return sub_7C380(v1, "real_miner_type", v2);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v3, 0x2000u, "%s: input bad json param\n", "api_miner_real_miner_type");
    return sub_41DB8(3, v3, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002B044) --------------------------------------------------------
int __fastcall sub_2B044(int result)
{
  double v1; // d0
  _DWORD *v2; // r5
  _DWORD *v3; // r0
  char v4[16]; // [sp+8h] [bp-2014h] BYREF
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v2 = (_DWORD *)result;
  memset(v4, 0, sizeof(v4));
  if ( result )
  {
    sub_27EF4();
    snprintf(v4, 0x10u, "%.2f", v1);
    v3 = sub_7D998(v4);
    return sub_7C380(v2, "rate_5s", v3);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "%s: input bad json param\n", "api_miner_rate_5s");
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// 2B0E4: variable 'v1' is possibly undefined
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002B12C) --------------------------------------------------------
int __fastcall sub_2B12C(int result)
{
  double v1; // d0
  _DWORD *v2; // r4
  _DWORD *v3; // r0
  char s[4]; // [sp+10h] [bp-2010h] BYREF
  int v5; // [sp+14h] [bp-200Ch]
  int v6; // [sp+18h] [bp-2008h]
  int v7; // [sp+1Ch] [bp-2004h]
  char v8[8192]; // [sp+20h] [bp-2000h] BYREF

  v2 = (_DWORD *)result;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  *(_DWORD *)s = 0;
  if ( result )
  {
    sub_27F18();
    if ( v1 < 0.01 )
      sub_2ADB0();
    snprintf(s, 0x10u, "%.2lf", v1);
    v3 = sub_7D998(s);
    return sub_7C380(v2, "rate_30m", v3);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v8, 0x2000u, "%s: input bad json param\n", "api_miner_rate_30m");
    return sub_41DB8(3, v8, 0);
  }
  return result;
}
// 2B168: variable 'v1' is possibly undefined
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002B23C) --------------------------------------------------------
int __fastcall sub_2B23C(int result)
{
  double v1; // d0
  _DWORD *v2; // r5
  _DWORD *v3; // r0
  char v4[16]; // [sp+8h] [bp-2014h] BYREF
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v2 = (_DWORD *)result;
  memset(v4, 0, sizeof(v4));
  if ( result )
  {
    sub_2ADB0();
    snprintf(v4, 0x10u, "%.2lf", v1);
    v3 = sub_7D998(v4);
    return sub_7C380(v2, "rate_avg", v3);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "%s: input bad json param\n", "api_miner_rate_avg");
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// 2B2DC: variable 'v1' is possibly undefined
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002B324) --------------------------------------------------------
int __fastcall sub_2B324(int result)
{
  _DWORD *v1; // r5
  int v2; // r0
  _DWORD *v3; // r0
  char v4[16]; // [sp+8h] [bp-2014h] BYREF
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v1 = (_DWORD *)result;
  memset(v4, 0, sizeof(v4));
  if ( result )
  {
    v2 = sub_22EC0();
    snprintf(v4, 0x10u, "%.2lf", (double)v2);
    v3 = sub_7D998(v4);
    return sub_7C380(v1, "rate_ideal", v3);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "%s: input bad json param\n", "api_miner_rate_ideal");
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002B414) --------------------------------------------------------
int __fastcall sub_2B414(int result)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  int v3; // [sp+4h] [bp-2004h] BYREF
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v1 = (_DWORD *)result;
  v3 = 0;
  if ( result )
  {
    strcpy((char *)&v3, "GH");
    v2 = sub_7D998((char *)&v3);
    return sub_7C380(v1, "rate_unit", v2);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "%s: input bad json param\n", "api_miner_rate_unit");
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002B4E8) --------------------------------------------------------
int __fastcall sub_2B4E8(int result)
{
  _DWORD *v1; // r5
  int v2; // r4
  const char *v3; // r0
  __int64 v4; // r0
  _QWORD *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  char v16[8196]; // [sp+0h] [bp-2004h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_27F38();
    v3 = (const char *)sub_27CEC();
    if ( !strcmp(v3, "HHB68502") )
      goto LABEL_3;
    v6 = (const char *)sub_27CEC();
    if ( !strcmp(v6, "HHB68501") )
      goto LABEL_3;
    v7 = (const char *)sub_27CEC();
    if ( !strcmp(v7, "HHB68701") )
      goto LABEL_3;
    v8 = (const char *)sub_27CEC();
    if ( !strcmp(v8, "HHB68704")
      || (v9 = (const char *)sub_27CEC(), !strcmp(v9, "HHB68703"))
      || (v10 = (const char *)sub_27CEC(), !strcmp(v10, "H6HB68702"))
      || (v11 = (const char *)sub_27CEC(), !strcmp(v11, "H1HB68601"))
      || (v12 = (const char *)sub_27CEC(), !strcmp(v12, "HHB68601"))
      || (v13 = (const char *)sub_27CEC(), !strcmp(v13, "HHB68602"))
      || (v14 = (const char *)sub_27CEC(), !strcmp(v14, "HHB56611"))
      || (v15 = (const char *)sub_27CEC(), !strcmp(v15, "HHB68503")) )
    {
LABEL_3:
      v4 = 4;
    }
    else
    {
      v4 = v2;
    }
    v5 = sub_7DEB4(v4);
    return sub_7C380(v1, "fan_num", v5);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v16, 0x2000u, "%s: input bad json param\n", "api_miner_fan_num");
    return sub_41DB8(3, v16, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002B6B8) --------------------------------------------------------
int __fastcall sub_2B6B8(int result)
{
  _DWORD *v1; // r6
  _DWORD *v2; // r5
  const char *v3; // r0
  int v4; // r4
  _QWORD *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  int v16; // r4
  int v17; // r7
  bool v18; // cc
  int v19; // r0
  int v20; // r0
  _QWORD *v21; // r0
  char v22[8196]; // [sp+0h] [bp-2004h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_7CC78();
    v3 = (const char *)sub_27CEC();
    if ( !strcmp(v3, "HHB68502") )
      goto LABEL_3;
    v6 = (const char *)sub_27CEC();
    if ( !strcmp(v6, "HHB68501") )
      goto LABEL_3;
    v7 = (const char *)sub_27CEC();
    if ( !strcmp(v7, "HHB68701") )
      goto LABEL_3;
    v8 = (const char *)sub_27CEC();
    if ( !strcmp(v8, "HHB68704")
      || (v9 = (const char *)sub_27CEC(), !strcmp(v9, "HHB68703"))
      || (v10 = (const char *)sub_27CEC(), !strcmp(v10, "H6HB68702"))
      || (v11 = (const char *)sub_27CEC(), !strcmp(v11, "H1HB68601"))
      || (v12 = (const char *)sub_27CEC(), !strcmp(v12, "HHB68601"))
      || (v13 = (const char *)sub_27CEC(), !strcmp(v13, "HHB68602"))
      || (v14 = (const char *)sub_27CEC(), !strcmp(v14, "HHB56611"))
      || (v15 = (const char *)sub_27CEC(), !strcmp(v15, "HHB68503")) )
    {
LABEL_3:
      v4 = 4;
      do
      {
        v5 = sub_7DEB4(0);
        sub_7D114(v2, v5);
        --v4;
      }
      while ( v4 );
    }
    else
    {
      v16 = 0;
      v17 = sub_27F28();
      while ( 1 )
      {
        v18 = v16 < v17;
        v19 = v16++;
        if ( !v18 )
          break;
        v20 = sub_28068(v19);
        v21 = sub_7DEB4(v20);
        sub_7D114(v2, v21);
      }
    }
    return sub_7C380(v1, "fan", v2);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v22, 0x2000u, "%s: input bad json param\n", "api_miner_fan_speed");
    return sub_41DB8(3, v22, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002B8CC) --------------------------------------------------------
int __fastcall sub_2B8CC(int result)
{
  double v1; // d0
  _DWORD *v2; // r5
  int v3; // r6
  double v4; // d7
  __int64 v5; // r0
  int v6; // r3
  _QWORD *v7; // r0
  int v8; // r3
  _DWORD *v9; // r0
  char s[4]; // [sp+10h] [bp-2008h] BYREF
  int v11; // [sp+14h] [bp-2004h]
  char v12[8192]; // [sp+18h] [bp-2000h] BYREF

  v2 = (_DWORD *)result;
  v11 = 0;
  *(_DWORD *)s = 0;
  if ( result )
  {
    v3 = sub_287A0();
    v4 = (double)sub_287E4();
    LODWORD(v5) = v3;
    if ( (double)v3 <= v4 * 1.05 )
      v6 = dword_C1CB0 & 0xFFFFFFFE;
    else
      v6 = dword_C1CB0 | 1;
    dword_C1CB0 = v6;
    HIDWORD(v5) = v3 >> 31;
    v7 = sub_7DEB4(v5);
    sub_7C380(v2, "miner_power", v7);
    sub_287D4();
    sub_287F4();
    if ( v1 * 1.05 >= v1 )
      v8 = dword_C1CB0 & 0xFFFFFFFD;
    else
      v8 = dword_C1CB0 | 2;
    dword_C1CB0 = v8;
    snprintf(s, 8u, "%.2f", s, v1);
    v9 = sub_7D998(s);
    return sub_7C380(v2, "miner_jt", v9);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v12, 0x2000u, "%s: input bad json param\n", "api_miner_power_jt");
    return sub_41DB8(3, v12, 0);
  }
  return result;
}
// 2B97C: variable 'v1' is possibly undefined
// BC5F4: using guessed type int dword_BC5F4;
// C1CB0: using guessed type int dword_C1CB0;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002BA54) --------------------------------------------------------
int __fastcall sub_2BA54(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  int v4; // r0
  _QWORD *v5; // r0
  char v6[8192]; // [sp+0h] [bp-2000h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(v6, 0x2000u, "%s: input bad param\n", "api_miner_chain_frequency");
      return sub_41DB8(3, v6, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_23188(a2);
    v5 = sub_7DEB4(v4);
    return sub_7C380(v3, "freq_avg", v5);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002BB18) --------------------------------------------------------
int __fastcall sub_2BB18(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r5
  int v4; // r0
  _DWORD *v5; // r0
  _DWORD v6[4]; // [sp+0h] [bp-2014h] BYREF
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  memset(v6, 0, sizeof(v6));
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(s, 0x2000u, "%s: input bad param\n", "api_miner_chain_rate_ideal");
      return sub_41DB8(3, s, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_229E0(a2);
    snprintf((char *)v6, 0x10u, "%d", v4);
    v5 = sub_7D998((char *)v6);
    return sub_7C380(v3, "rate_ideal", v5);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002BC24) --------------------------------------------------------
int __fastcall sub_2BC24(int result, unsigned int a2)
{
  double v2; // d0
  _BOOL4 v3; // r3
  _DWORD *v4; // r5
  _DWORD *v5; // r0
  char v6[16]; // [sp+8h] [bp-2014h] BYREF
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v3 = a2 > 3;
  if ( !result )
    v3 = 1;
  memset(v6, 0, sizeof(v6));
  if ( v3 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(s, 0x2000u, "%s: input bad param\n", "api_miner_chain_rate_real");
      return sub_41DB8(3, s, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)result;
    sub_28158(a2);
    snprintf(v6, 0x10u, "%.2f", v2);
    v5 = sub_7D998(v6);
    return sub_7C380(v4, "rate_real", v5);
  }
  return result;
}
// 2BD00: variable 'v2' is possibly undefined
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002BD30) --------------------------------------------------------
int __fastcall sub_2BD30(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  int v4; // r0
  _QWORD *v5; // r0
  char v6[8192]; // [sp+0h] [bp-2000h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(v6, 0x2000u, "%s: input bad param\n", "api_miner_chain_asic_num");
      return sub_41DB8(3, v6, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_282A4(a2);
    v5 = sub_7DEB4(v4);
    return sub_7C380(v3, "asic_num", v5);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002BDF4) --------------------------------------------------------
void *__fastcall sub_2BDF4(_DWORD *a1, unsigned int a2)
{
  void *result; // r0
  _BOOL4 v5; // r3
  _DWORD *v6; // r0
  char v7[512]; // [sp+0h] [bp-2204h] BYREF
  char s[8196]; // [sp+200h] [bp-2004h] BYREF

  result = memset(v7, 0, sizeof(v7));
  v5 = a2 > 3;
  if ( !a1 )
    v5 = 1;
  if ( v5 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(s, 0x2000u, "%s: input bad param\n", "api_miner_chain_asic_status");
      return (void *)sub_41DB8(3, s, 0);
    }
  }
  else
  {
    sub_284BC(a2, v7);
    v6 = sub_7D998(v7);
    return (void *)sub_7C380(a1, "asic", v6);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002BEE8) --------------------------------------------------------
int __fastcall sub_2BEE8(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v4; // r9
  _DWORD *v5; // r10
  const char *v6; // r0
  float v7; // s16
  unsigned int v8; // r6
  int v9; // r4
  float v10; // s17
  int v11; // r8
  int i; // r11
  int v13; // r0
  int v14; // r1
  int v15; // r5
  int v16; // r4
  int v17; // r6
  int v18; // r0
  bool v19; // cc
  int v20; // r2
  __int16 v21; // r7
  _QWORD *v22; // r0
  _QWORD *v23; // r0
  _QWORD *v24; // r0
  _QWORD *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(s, 0x2000u, "%s: input bad param\n", "api_miner_chain_temp_pic");
      return sub_41DB8(3, s, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)result;
    v5 = sub_7CC78();
    v6 = (const char *)sub_27CEC();
    if ( !strcmp(v6, "HHB68601") )
      goto LABEL_10;
    v26 = (const char *)sub_27CEC();
    if ( !strcmp(v26, "HHB68602") )
      goto LABEL_10;
    v27 = (const char *)sub_27CEC();
    if ( !strcmp(v27, "HHB68502")
      || (v28 = (const char *)sub_27CEC(), !strcmp(v28, "HHB68501"))
      || (v29 = (const char *)sub_27CEC(), !strcmp(v29, "HHB68701"))
      || (v30 = (const char *)sub_27CEC(), !strcmp(v30, "HHB68704"))
      || (v31 = (const char *)sub_27CEC(), !strcmp(v31, "HHB68703"))
      || (v32 = (const char *)sub_27CEC(), !strcmp(v32, "H6HB68702"))
      || (v33 = (const char *)sub_27CEC(), !strcmp(v33, "H1HB68601"))
      || (v34 = (const char *)sub_27CEC(), !strcmp(v34, "HHB68503")) )
    {
LABEL_10:
      v7 = 0.0;
      v8 = a2 << 8;
      v9 = 0;
      v10 = 0.0;
      while ( 1 )
      {
        v11 = sub_27D0C();
        if ( v11 > 0 )
        {
          for ( i = 0; i != v11; ++i )
          {
            v7 = v7 + flt_D07C4[v8 - 1 + sub_2876C(v9, i)];
            v13 = sub_28744();
            v14 = i;
            v10 = v10 + flt_D07C4[v8 - 1 + sub_2876C(v13 - v9 - 1, v14)];
          }
        }
        if ( v9 == 1 )
          break;
        v9 = 1;
      }
      v15 = (__int16)(int)(float)((float)(v10 / (float)sub_27D0C()) * 0.5);
      v16 = (__int16)(int)(float)((float)(v7 / (float)sub_27D0C()) * 0.5);
    }
    else
    {
      v16 = 0;
      v15 = 0;
    }
    v17 = sub_18D48(a2, 0);
    v18 = sub_18D48(a2, 1);
    v19 = v16 < v18;
    if ( v16 >= v18 )
      v19 = v15 < v17;
    v20 = v19;
    v21 = v18;
    if ( v20 )
    {
      v16 = v18;
      v15 = v17;
    }
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(
        s,
        0x2000u,
        "inlet_board_temp=%d,outlet_board_temp=%d,inlet_water_temp=%d,outlet_water_temp=%d",
        v15,
        v16,
        v17,
        v18);
      sub_41DB8(4, s, 0);
    }
    v22 = sub_7DEB4((__int16)v15);
    sub_7D114(v5, v22);
    v23 = sub_7DEB4(v21);
    sub_7D114(v5, v23);
    v24 = sub_7DEB4((__int16)v17);
    sub_7D114(v5, v24);
    v25 = sub_7DEB4((__int16)v16);
    sub_7D114(v5, v25);
    return sub_7C380(v4, "temp_pic", v5);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC5F4: using guessed type int dword_BC5F4;
// D07C4: using guessed type float flt_D07C4[1023];
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002C278) --------------------------------------------------------
int __fastcall sub_2C278(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v4; // r6
  _DWORD *v5; // r7
  int v6; // r9
  int i; // r5
  __int16 v8; // r0
  _QWORD *v9; // r0
  int j; // r5
  __int16 v11; // r0
  _QWORD *v12; // r0
  char v13[8196]; // [sp+0h] [bp-2004h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(v13, 0x2000u, "%s: input bad param\n", "api_miner_chain_temp_chip");
      return sub_41DB8(3, v13, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)result;
    v5 = sub_7CC78();
    switch ( dword_BDA84 )
    {
      case 0:
        v6 = sub_27DC8();
        goto LABEL_11;
      case 1:
      case 2:
        v6 = sub_175A8();
        goto LABEL_11;
      case 3:
        v6 = sub_28618();
LABEL_11:
        if ( dword_C351C == 1 || dword_4D419C <= 0 )
          goto LABEL_25;
        if ( v6 > 0 )
        {
          for ( i = 0; i != v6; ++i )
          {
            if ( dword_BDA84 == 3 )
              v8 = sub_18D08(a2, (unsigned __int8)i);
            else
              v8 = sub_19068(a2, (unsigned __int8)i);
            v9 = sub_7DEB4(v8);
            sub_7D114(v5, v9);
          }
        }
        break;
      default:
        if ( dword_C351C != 1 && dword_4D419C > 0 )
          return sub_7C380(v4, "temp_chip", v5);
LABEL_25:
        for ( j = 0; sub_27DC8() > j; ++j )
        {
          v11 = sub_18D48(a2, (unsigned __int8)j);
          v12 = sub_7DEB4(v11);
          sub_7D114(v5, v12);
        }
        break;
    }
    return sub_7C380(v4, "temp_chip", v5);
  }
  return result;
}
// 2C334: control flows out of bounds to 2C338
// BC5F4: using guessed type int dword_BC5F4;
// BDA84: using guessed type int dword_BDA84;
// C351C: using guessed type int dword_C351C;
// 4D4171: using guessed type char byte_4D4171;
// 4D419C: using guessed type int dword_4D419C;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002C474) --------------------------------------------------------
int __fastcall sub_2C474(int result, unsigned int a2)
{
  int v2; // r4
  _DWORD *v4; // r6
  _DWORD *v5; // r7
  __int16 v6; // r0
  _QWORD *v7; // r0
  bool v8; // cc
  int v9; // r1
  __int16 v10; // r0
  _QWORD *v11; // r0
  char v12[8196]; // [sp+0h] [bp-2004h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(v12, 0x2000u, "%s: input bad param\n", "api_miner_chain_temp_pcb");
      return sub_41DB8(3, v12, 0);
    }
  }
  else
  {
    v4 = (_DWORD *)result;
    v5 = sub_7CC78();
    if ( dword_C351C == 1 || dword_4D419C <= 0 )
    {
      while ( sub_27DC8() > v2 )
      {
        v10 = sub_18D48(a2, (unsigned __int8)v2++);
        v11 = sub_7DEB4(v10);
        sub_7D114(v5, v11);
      }
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_175A8() <= v2;
        v9 = (unsigned __int8)v2++;
        if ( v8 )
          break;
        v6 = sub_1901C(a2, v9);
        v7 = sub_7DEB4(v6);
        sub_7D114(v5, v7);
      }
    }
    return sub_7C380(v4, "temp_pcb", v5);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// C351C: using guessed type int dword_C351C;
// 4D4171: using guessed type char byte_4D4171;
// 4D419C: using guessed type int dword_4D419C;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002C5D8) --------------------------------------------------------
int __fastcall sub_2C5D8(int result, unsigned int a2)
{
  unsigned int v2; // r6
  _DWORD *v3; // r8
  _DWORD *v4; // r5
  double *v5; // r4
  double v6; // t1
  __int64 v7; // r0
  _QWORD *v8; // r0
  unsigned int v9; // r10
  unsigned int v10; // r9
  unsigned int v11; // r3
  __int64 v12; // r0
  _QWORD *v13; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(s, 0x2000u, "%s: input bad param\n", "api_miner_chain_rate_array");
      return sub_41DB8(3, s, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_7CC78();
    if ( (unsigned int)dword_C1CB4 > 0x17 )
    {
      v9 = dword_C1CB4 % 0x18u;
      v10 = dword_C1CB4 % 0x18u + 24;
      do
      {
        v11 = v9 % 0x18;
        ++v9;
        LODWORD(v12) = sub_96E38(dbl_65B9C8[24 * a2 + v11]);
        v13 = sub_7DEB4(v12);
        sub_7D114(v4, v13);
      }
      while ( v10 != v9 );
    }
    else if ( dword_C1CB4 )
    {
      v5 = &dbl_65B9C8[24 * a2];
      do
      {
        v6 = *v5++;
        ++v2;
        LODWORD(v7) = sub_96E38(v6);
        v8 = sub_7DEB4(v7);
        sub_7D114(v4, v8);
      }
      while ( v2 < dword_C1CB4 );
    }
    return sub_7C380(v3, "rate_array", v4);
  }
  return result;
}
// 2C6BC: variable 'v7' is possibly undefined
// 2C748: variable 'v12' is possibly undefined
// BC5F4: using guessed type int dword_BC5F4;
// C1CB4: using guessed type int dword_C1CB4;
// 4D4171: using guessed type char byte_4D4171;
// 65B9C8: using guessed type double dbl_65B9C8[96];
// 6682BC: using guessed type char byte_6682BC;

//----- (0002C768) --------------------------------------------------------
int __fastcall sub_2C768(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  int v4; // r0
  _QWORD *v5; // r0
  char v6[8192]; // [sp+0h] [bp-2000h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(v6, 0x2000u, "%s: input bad param\n", "api_miner_chain_hw");
      return sub_41DB8(3, v6, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_283E4(a2);
    v5 = sub_7DEB4(v4);
    return sub_7C380(v3, "hw", v5);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002C82C) --------------------------------------------------------
int __fastcall sub_2C82C(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  _QWORD *v4; // r0
  char v5[8192]; // [sp+0h] [bp-2000h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(v5, 0x2000u, "%s: input bad param\n", "api_miner_chain_nonce");
      return sub_41DB8(3, v5, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    v4 = sub_7DEB4(dword_D17C4[a2]);
    return sub_7C380(v3, "nonce", v4);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// D17C4: using guessed type int dword_D17C4[3];
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002C8F4) --------------------------------------------------------
int __fastcall sub_2C8F4(int result, unsigned int a2)
{
  _BOOL4 v2; // r3
  _DWORD *v3; // r4
  _DWORD *v4; // r2
  char v5[8192]; // [sp+0h] [bp-2000h] BYREF

  v2 = a2 > 3;
  if ( !result )
    v2 = 1;
  if ( v2 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(v5, 0x2000u, "%s: input bad param\n", "api_miner_chain_eeprom");
      return sub_41DB8(3, v5, 0);
    }
  }
  else
  {
    v3 = (_DWORD *)result;
    if ( sub_1D6C8(a2) )
      v4 = sub_7E35C();
    else
      v4 = sub_7E37C();
    return sub_7C380(v3, "eeprom", v4);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002C9C8) --------------------------------------------------------
void *__fastcall sub_2C9C8(_DWORD *a1, unsigned int a2)
{
  void *result; // r0
  _BOOL4 v5; // r3
  _DWORD *v6; // r0
  char v7[32]; // [sp+0h] [bp-2020h] BYREF
  char s[8192]; // [sp+20h] [bp-2000h] BYREF

  result = memset(v7, 0, sizeof(v7));
  v5 = a2 > 3;
  if ( !a1 )
    v5 = 1;
  if ( v5 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(s, 0x2000u, "%s: input bad param\n", "api_miner_chain_sn");
      return (void *)sub_41DB8(3, s, 0);
    }
  }
  else
  {
    sub_1BDB4(a2, v7, 0x20u);
    v6 = sub_7D998(v7);
    return (void *)sub_7C380(a1, "sn", v6);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002CAC4) --------------------------------------------------------
int __fastcall sub_2CAC4(_DWORD *a1, int a2)
{
  _QWORD *v3; // r0
  unsigned int v5; // [sp+4h] [bp-8h] BYREF

  v5 = 0;
  sub_1CAAC(a2, 2, (int *)&v5);
  v3 = sub_7DEB4(v5);
  return sub_7C380(a1, "eeprom_vol", v3);
}

//----- (0002CB10) --------------------------------------------------------
int __fastcall sub_2CB10(_DWORD *a1, int a2)
{
  __int64 v3; // r0
  _DWORD *v4; // r3
  bool v5; // zf
  _QWORD *v6; // r0
  int v8; // [sp+4h] [bp-4h] BYREF

  v8 = 0;
  v3 = (unsigned int)sub_1C070(a2, 2, &v8);
  v5 = (_DWORD)v3 == 0;
  if ( (_DWORD)v3 )
    LOWORD(v4) = 16768;
  else
    LODWORD(v3) = v8;
  if ( !v5 )
  {
    HIWORD(v4) = 77;
    LODWORD(v3) = *v4;
    v8 = *v4;
  }
  v6 = sub_7DEB4(v3);
  return sub_7C380(a1, "eeprom_freq", v6);
}
// 2CB48: variable 'v4' is possibly undefined

//----- (0002CB70) --------------------------------------------------------
int __fastcall sub_2CB70(_DWORD *a1, int a2)
{
  _QWORD *v3; // r0
  unsigned int v5; // [sp+4h] [bp-8h] BYREF

  v5 = 0;
  sub_1CE9C(a2, (int *)&v5);
  v3 = sub_7DEB4(v5);
  return sub_7C380(a1, "eeprom_bin", v3);
}

//----- (0002CBBC) --------------------------------------------------------
int __fastcall sub_2CBBC(_DWORD *a1, int a2)
{
  _DWORD *v3; // r0
  _DWORD v5[4]; // [sp+0h] [bp-10h] BYREF

  memset(v5, 0, sizeof(v5));
  sub_1CF48(a2, (char *)v5, 0x10u);
  v3 = sub_7D998((char *)v5);
  return sub_7C380(a1, "eeprom_ft", v3);
}

//----- (0002CC14) --------------------------------------------------------
int __fastcall sub_2CC14(_DWORD *a1, int a2)
{
  _QWORD *v3; // r0
  unsigned int v5; // [sp+4h] [bp-8h] BYREF

  v5 = 0;
  sub_1CDF0(a2, (int *)&v5);
  v3 = sub_7DEB4(v5);
  return sub_7C380(a1, "eeprom_code", v3);
}

//----- (0002CC60) --------------------------------------------------------
char __fastcall sub_2CC60(char result)
{
  LOBYTE(dword_C1CB8) = dword_C1CB8 & 0xFE | result & 1;
  return result;
}
// C1CB8: using guessed type int dword_C1CB8;

//----- (0002CC78) --------------------------------------------------------
char __fastcall sub_2CC78(char result)
{
  LOBYTE(dword_C1CB8) = dword_C1CB8 & 0xFD | (2 * (result & 1));
  return result;
}
// C1CB8: using guessed type int dword_C1CB8;

//----- (0002CC90) --------------------------------------------------------
char __fastcall sub_2CC90(char result)
{
  LOBYTE(dword_C1CB8) = dword_C1CB8 & 0xFB | (4 * (result & 1));
  return result;
}
// C1CB8: using guessed type int dword_C1CB8;

//----- (0002CCA8) --------------------------------------------------------
char __fastcall sub_2CCA8(char result)
{
  LOBYTE(dword_C1CB8) = dword_C1CB8 & 0xF7 | (8 * (result & 1));
  return result;
}
// C1CB8: using guessed type int dword_C1CB8;

//----- (0002CCC0) --------------------------------------------------------
int __fastcall sub_2CCC0(_DWORD *a1)
{
  int v2; // r4
  _QWORD *v3; // r0
  char v5[8196]; // [sp+0h] [bp-2004h] BYREF

  v2 = dword_C1CB8;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v5, 0x2000u, "error_code = %d\n", dword_C1CB8);
    sub_41DB8(4, v5, 0);
  }
  v3 = sub_7DEB4(v2);
  return sub_7C380(a1, "error_code", v3);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C1CB8: using guessed type int dword_C1CB8;

//----- (0002CD44) --------------------------------------------------------
int __fastcall sub_2CD44(int result)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_7D998(byte_C3544);
    return sub_7C380(v1, "miner_version", v2);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v3, 0x2000u, "%s: input bad json param\n", "api_miner_version");
    return sub_41DB8(3, v3, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002CDEC) --------------------------------------------------------
int __fastcall sub_2CDEC(int result)
{
  _DWORD *v1; // r4
  double *v2; // r0
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_7E070();
    return sub_7C380(v1, "total_hash", v2);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v3, 0x2000u, "%s: input bad json param\n", "api_total_hash");
    return sub_41DB8(3, v3, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002CE98) --------------------------------------------------------
int __fastcall sub_2CE98(int result)
{
  _DWORD *v1; // r4
  _DWORD *v2; // r0
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  v1 = (_DWORD *)result;
  if ( result )
  {
    v2 = sub_7D998(byte_AB7A30);
    return sub_7C380(v1, "miner_id", v2);
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(v3, 0x2000u, "%s: input bad json param\n", "api_miner_id");
    return sub_41DB8(3, v3, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002CF40) --------------------------------------------------------
int __fastcall sub_2CF40(int result)
{
  _BOOL4 v1; // r4
  _DWORD *v2; // r9
  int v3; // r8
  int v4; // r6
  _DWORD *v5; // r10
  int i; // r5
  _DWORD *v7; // r7
  int j; // r4
  int v9; // r0
  _QWORD *v10; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v2 = (_DWORD *)result;
  if ( result )
  {
    v3 = sub_28744();
    result = sub_28758();
    if ( !v3 )
      v1 = 1;
    v4 = result;
    if ( v3 )
      v1 = result == 0;
    if ( v1 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "miner tpl is empty!!!");
        return sub_41DB8(3, s, 0);
      }
    }
    else
    {
      v5 = sub_7CC78();
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(s, 0x2000u, "api_miner_asic_tpl r=%d,c=%d", v3, v4);
        sub_41DB8(4, s, 0);
      }
      if ( v3 > 0 )
      {
        for ( i = 0; i != v3; ++i )
        {
          v7 = sub_7CC78();
          if ( v4 > 0 )
          {
            for ( j = 0; j != v4; ++j )
            {
              v9 = sub_2876C(i, j);
              v10 = sub_7DEB4(v9);
              sub_7D114(v7, v10);
            }
          }
          sub_7D114(v5, v7);
        }
      }
      return sub_7C380(v2, "tpl", v5);
    }
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "%s: input bad json param\n", "api_miner_asic_tpl");
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// 2CF7C: variable 'v1' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002D120) --------------------------------------------------------
void __fastcall sub_2D120(void *a1)
{
  _DWORD *v2; // r5
  int v3; // r4
  _DWORD *v4; // r0
  _DWORD *v5; // r0
  _DWORD *v6; // r0
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r6
  _DWORD *v12; // r7
  int v13; // r4
  _DWORD *v14; // r9
  int v15; // r4
  const char *v16; // r0
  char *v17; // r4
  size_t v18; // r0
  unsigned int *v19; // r3
  unsigned int v20; // r2
  unsigned int v21; // r2
  __int64 v22; // r0
  bool v23; // zf
  _QWORD *v24; // r0
  _QWORD *v25; // r0
  _DWORD *v26; // r0
  unsigned int v27; // [sp+0h] [bp-200Ch] BYREF
  int v28; // [sp+4h] [bp-2008h] BYREF
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v2 = sub_7C134();
  if ( v2 )
  {
    v3 = 0;
    v4 = sub_7D998(dest);
    sub_7C380(v2, "miner_type", v4);
    v5 = sub_7D998("zynq7007");
    sub_7C380(v2, "ctrlboard_type", v5);
    v6 = sub_7D998(byte_4D41FC);
    sub_7C380(v2, "board_type", v6);
    v7 = sub_7D998(&byte_C32F8);
    sub_7C380(v2, "miner_sn", v7);
    v8 = sub_7D998(&byte_4D4370);
    sub_7C380(v2, "power_sn", v8);
    v9 = sub_7D998(byte_C2FF8);
    sub_7C380(v2, "firmware_version", v9);
    v10 = sub_7D998("Release");
    sub_7C380(v2, "firmware_type", v10);
    v11 = sub_7CC78();
    memset(s, 0, 0x20u);
    do
    {
      if ( sub_27EC8(v3) )
      {
        memset(s, 0, 0x20u);
        sub_1BDB4(v3, s, 0x20u);
        v26 = sub_7D998(s);
        sub_7D114(v11, v26);
      }
      ++v3;
    }
    while ( v3 != 4 );
    sub_7C380(v2, "board_sn", v11);
    v12 = sub_7CC78();
    v13 = 0;
    v27 = 0;
    do
    {
      if ( sub_27EC8(v13) )
      {
        sub_1CAAC(v13, 2, (int *)&v27);
        v25 = sub_7DEB4(v27);
        sub_7D114(v12, v25);
      }
      ++v13;
    }
    while ( v13 != 4 );
    sub_7C380(v2, "vols", v12);
    v14 = sub_7CC78();
    v15 = 0;
    v28 = 0;
    do
    {
      if ( sub_27EC8(v15) )
      {
        v22 = (unsigned int)sub_1C070(v15, 2, &v28);
        v23 = (_DWORD)v22 == 0;
        if ( (_DWORD)v22 )
          LODWORD(v22) = dword_4D4180;
        else
          LODWORD(v22) = v28;
        if ( !v23 )
          v28 = v22;
        v24 = sub_7DEB4(v22);
        sub_7D114(v14, v24);
      }
      ++v15;
    }
    while ( v15 != 4 );
    sub_7C380(v2, "freqs", v14);
    v16 = (const char *)sub_767AC(v2, 0);
    v17 = (char *)v16;
    if ( v16 )
    {
      v18 = strlen(v16);
      memcpy(a1, v17, v18 + 1);
      free(v17);
    }
    if ( v2[1] != -1 )
    {
      v19 = v2 + 1;
      __dmb(0xBu);
      do
      {
        v20 = __ldrex(v19);
        v21 = v20 - 1;
      }
      while ( __strex(v21, v19) );
      if ( !v21 )
        sub_7E3BC(v2);
    }
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "%s: input bad json param\n", "api_get_miner_info");
    sub_41DB8(3, s, 0);
  }
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 4D4180: using guessed type int dword_4D4180;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002D490) --------------------------------------------------------
void __fastcall sub_2D490(void *a1)
{
  _DWORD *v2; // r4
  const char *v3; // r1
  _DWORD *v4; // r0
  _QWORD *v5; // r0
  _QWORD *v6; // r0
  _QWORD *v7; // r0
  int v8; // r0
  _QWORD *v9; // r0
  _QWORD *v10; // r0
  int v11; // r0
  _QWORD *v12; // r0
  int v13; // r0
  _QWORD *v14; // r0
  __int16 v15; // r0
  _QWORD *v16; // r0
  const char *v17; // r0
  char *v18; // r5
  size_t v19; // r0
  unsigned int *v20; // r3
  unsigned int v21; // r2
  unsigned int v22; // r2
  _DWORD v23[2049]; // [sp+0h] [bp-2004h] BYREF

  v2 = sub_7C134();
  if ( v2 )
  {
    memset(v23, 0, 20);
    if ( dword_C351C )
    {
      if ( dword_C351C == 1 )
      {
        strncpy((char *)v23, "sleep mode", 0x14u);
      }
      else
      {
        if ( dword_C351C == 2 )
          LOWORD(v3) = -19528;
        else
          LOWORD(v3) = -19516;
        HIWORD(v3) = 9;
        strncpy((char *)v23, v3, 0x14u);
      }
    }
    else
    {
      strncpy((char *)v23, "normal mode", 0x14u);
    }
    v4 = sub_7D998((char *)v23);
    sub_7C380(v2, "work_mode", v4);
    v5 = sub_7DEB4((unsigned int)dword_4D417C);
    sub_7C380(v2, "working_freq", v5);
    v6 = sub_7DEB4(dword_4D419C);
    sub_7C380(v2, "working_vol", v6);
    v7 = sub_7DEB4((unsigned int)dword_4D4180);
    sub_7C380(v2, "current_freq", v7);
    v8 = sub_2242C();
    v9 = sub_7DEB4(v8);
    sub_7C380(v2, "current_vol", v9);
    v10 = sub_7DEB4((unsigned int)(dword_4D417C - dword_4D4180));
    sub_7C380(v2, "decreased_freq", v10);
    v11 = sub_22E18(dword_4D417C - dword_4D4180);
    v12 = sub_7DEB4(v11);
    sub_7C380(v2, "decreased_hashrate", v12);
    v13 = sub_287A0();
    v14 = sub_7DEB4(v13);
    sub_7C380(v2, "current_power", v14);
    v15 = sub_18F28();
    v16 = sub_7DEB4(v15);
    sub_7C380(v2, "water_in_temp", v16);
    v17 = (const char *)sub_767AC(v2, 0);
    v18 = (char *)v17;
    if ( v17 )
    {
      v19 = strlen(v17);
      memcpy(a1, v18, v19 + 1);
      free(v18);
    }
    if ( v2[1] != -1 )
    {
      v20 = v2 + 1;
      __dmb(0xBu);
      do
      {
        v21 = __ldrex(v20);
        v22 = v21 - 1;
      }
      while ( __strex(v22, v20) );
      if ( !v22 )
        sub_7E3BC(v2);
    }
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf((char *)v23, 0x2000u, "%s: input bad json param\n", "api_get_miner_freq_adjust_info");
    sub_41DB8(3, (const char *)v23, 0);
  }
}
// BC5F4: using guessed type int dword_BC5F4;
// C351C: using guessed type int dword_C351C;
// 4D4171: using guessed type char byte_4D4171;
// 4D417C: using guessed type int dword_4D417C;
// 4D4180: using guessed type int dword_4D4180;
// 4D419C: using guessed type int dword_4D419C;
// 6682BC: using guessed type char byte_6682BC;

//----- (0002D96C) --------------------------------------------------------
_DWORD *__fastcall sub_2D96C(_DWORD *result)
{
  result[2] = 1779033703;
  result[3] = -1150833019;
  result[4] = 1013904242;
  result[5] = -1521486534;
  result[6] = 1359893119;
  result[7] = -1694144372;
  result[8] = 528734635;
  result[9] = 1541459225;
  *result = 0;
  result[1] = 0;
  return result;
}

//----- (0002D9E0) --------------------------------------------------------
int __fastcall sub_2D9E0(_DWORD *a1, unsigned int *a2)
{
  int v2; // r7
  int v4; // r8
  int v5; // r1
  int v6; // r9
  unsigned int v7; // r5
  unsigned int v8; // r3
  int v9; // r6
  unsigned int v10; // r12
  int v11; // r3
  int v12; // r0
  int v13; // r5
  int v14; // r3
  int v15; // r2
  int v16; // r4
  int v17; // lr
  int v18; // r3
  int v19; // r11
  int v20; // r6
  unsigned int v21; // r12
  int v22; // r10
  int v23; // r6
  int v24; // r0
  int v25; // r6
  int v26; // r8
  int v27; // r5
  int v28; // r2
  int v29; // r9
  int v30; // r3
  int v31; // r9
  int v32; // r11
  int v33; // r10
  int v34; // r11
  int v35; // r12
  int v36; // r6
  int v37; // r7
  int v38; // r12
  int v39; // r5
  int v40; // lr
  int v41; // r12
  int v42; // r2
  int v43; // r9
  int v44; // r10
  int v45; // r4
  int v46; // r11
  int v47; // r6
  int v48; // r7
  int v49; // r0
  int v50; // r5
  int v51; // r6
  int v52; // lr
  int v53; // r9
  int v54; // r2
  int v55; // r11
  int v56; // r9
  int v57; // r3
  unsigned int v58; // r10
  int v59; // r1
  int v60; // r4
  int v61; // r12
  int v62; // lr
  int v63; // r6
  int v64; // r0
  int v65; // r2
  int v66; // r1
  int v67; // r5
  int v68; // r9
  int v69; // lr
  int v70; // r2
  int v71; // r4
  int v72; // r12
  int v73; // r3
  int v74; // r4
  int v75; // r0
  int v76; // r4
  int v77; // r8
  int v78; // r1
  int v79; // r9
  unsigned int v80; // r10
  int v81; // r7
  int v82; // r2
  int v83; // r7
  int v84; // r6
  int v85; // r12
  int v86; // r3
  int v87; // r6
  int v88; // r4
  int v89; // r0
  int v90; // r6
  int v91; // r1
  int v92; // r9
  int v93; // r5
  int v94; // r7
  int v95; // r5
  int v96; // lr
  int v97; // r12
  int v98; // r3
  int v99; // lr
  int v100; // r0
  int v101; // r4
  int v102; // lr
  int v103; // r9
  int v104; // r1
  int v105; // lr
  int v106; // r8
  int v107; // r5
  int v108; // r11
  int v109; // r6
  int v110; // r3
  int v111; // r10
  int v112; // r1
  int v113; // r4
  int v114; // r8
  int v115; // r1
  int v116; // r6
  int v117; // r2
  int v118; // r5
  int v119; // r0
  int v120; // r12
  int v121; // lr
  int v122; // r7
  int v123; // r3
  int v124; // r9
  int v125; // r1
  int v126; // r4
  int v127; // r5
  int v128; // r9
  int v129; // r10
  int v130; // r5
  int v131; // r12
  int v132; // r2
  int v133; // r8
  int v134; // r3
  int v135; // r0
  int v136; // r7
  int v137; // r11
  int v138; // r1
  int v139; // r10
  int v140; // r8
  int v141; // r5
  int v142; // r2
  int v143; // r9
  int v144; // r5
  int v145; // r0
  int v146; // r12
  int v147; // r7
  int v148; // r11
  int v149; // r3
  int v150; // r7
  int v151; // r10
  int v152; // lr
  int v153; // r7
  int v154; // r9
  int v155; // r8
  int v156; // r6
  int v157; // r5
  int v158; // r12
  int v159; // r0
  int v160; // r3
  int v161; // r0
  int v162; // r11
  int v163; // lr
  int v164; // r11
  int v165; // r10
  int v166; // r8
  int v167; // r10
  int v168; // r9
  int v169; // r5
  int v170; // r9
  int v171; // r12
  int v172; // r0
  int v173; // r12
  int v174; // r7
  int v175; // r11
  int v176; // r3
  unsigned int v177; // r6
  unsigned int v178; // r1
  int v179; // lr
  int v180; // r2
  int v181; // r3
  unsigned int v182; // r7
  int v183; // r4
  int v184; // r12
  int v185; // r4
  unsigned int v186; // r10
  int v187; // r1
  int v188; // r8
  int v189; // lr
  int v190; // r10
  unsigned int v191; // r7
  int v192; // r6
  int v193; // r1
  int v194; // r2
  unsigned int v195; // r8
  int v196; // r9
  int v197; // r3
  int v198; // r0
  int v199; // r6
  int v200; // r5
  int v201; // r4
  int v202; // r12
  int v203; // r9
  int result; // r0
  unsigned int *v205; // [sp+4h] [bp-78h]
  unsigned int v206; // [sp+4h] [bp-78h]
  unsigned int v207; // [sp+4h] [bp-78h]
  int v208; // [sp+4h] [bp-78h]
  unsigned int v209; // [sp+8h] [bp-74h]
  unsigned int v210; // [sp+8h] [bp-74h]
  unsigned int v211; // [sp+8h] [bp-74h]
  unsigned int v212; // [sp+Ch] [bp-70h]
  unsigned int v213; // [sp+Ch] [bp-70h]
  unsigned int v214; // [sp+Ch] [bp-70h]
  unsigned int v215; // [sp+10h] [bp-6Ch]
  unsigned int v216; // [sp+10h] [bp-6Ch]
  unsigned int v217; // [sp+10h] [bp-6Ch]
  unsigned int v218; // [sp+14h] [bp-68h]
  unsigned int v219; // [sp+14h] [bp-68h]
  unsigned int v220; // [sp+14h] [bp-68h]
  unsigned int v221; // [sp+18h] [bp-64h]
  unsigned int v222; // [sp+18h] [bp-64h]
  unsigned int v223; // [sp+18h] [bp-64h]
  unsigned int v224; // [sp+18h] [bp-64h]
  unsigned int v225; // [sp+1Ch] [bp-60h]
  unsigned int v226; // [sp+1Ch] [bp-60h]
  unsigned int v227; // [sp+1Ch] [bp-60h]
  int v228; // [sp+1Ch] [bp-60h]
  int v229; // [sp+1Ch] [bp-60h]
  unsigned int v230; // [sp+20h] [bp-5Ch]
  unsigned int v231; // [sp+20h] [bp-5Ch]
  unsigned int v232; // [sp+20h] [bp-5Ch]
  unsigned int v233; // [sp+20h] [bp-5Ch]
  unsigned int v234; // [sp+24h] [bp-58h]
  int v235; // [sp+24h] [bp-58h]
  unsigned int v236; // [sp+24h] [bp-58h]
  unsigned int v237; // [sp+24h] [bp-58h]
  unsigned int v238; // [sp+24h] [bp-58h]
  unsigned int v239; // [sp+28h] [bp-54h]
  unsigned int v240; // [sp+28h] [bp-54h]
  unsigned int v241; // [sp+28h] [bp-54h]
  int v242; // [sp+28h] [bp-54h]
  unsigned int v243; // [sp+2Ch] [bp-50h]
  unsigned int v244; // [sp+2Ch] [bp-50h]
  unsigned int v245; // [sp+2Ch] [bp-50h]
  int v246; // [sp+2Ch] [bp-50h]
  unsigned int v247; // [sp+30h] [bp-4Ch]
  unsigned int v248; // [sp+30h] [bp-4Ch]
  unsigned int v249; // [sp+30h] [bp-4Ch]
  unsigned int v250; // [sp+34h] [bp-48h]
  unsigned int v251; // [sp+34h] [bp-48h]
  unsigned int v252; // [sp+34h] [bp-48h]
  unsigned int v253; // [sp+34h] [bp-48h]
  unsigned int v254; // [sp+38h] [bp-44h]
  unsigned int v255; // [sp+38h] [bp-44h]
  unsigned int v256; // [sp+38h] [bp-44h]
  unsigned int v257; // [sp+3Ch] [bp-40h]
  unsigned int v258; // [sp+3Ch] [bp-40h]
  unsigned int v259; // [sp+3Ch] [bp-40h]
  unsigned int v260; // [sp+40h] [bp-3Ch]
  unsigned int v261; // [sp+40h] [bp-3Ch]
  unsigned int v262; // [sp+40h] [bp-3Ch]
  unsigned int v263; // [sp+40h] [bp-3Ch]
  unsigned int v264; // [sp+44h] [bp-38h]
  unsigned int v265; // [sp+44h] [bp-38h]
  unsigned int v266; // [sp+44h] [bp-38h]
  unsigned int v267; // [sp+44h] [bp-38h]
  unsigned int v268; // [sp+48h] [bp-34h]
  unsigned int v269; // [sp+48h] [bp-34h]
  unsigned int v270; // [sp+48h] [bp-34h]
  int v271; // [sp+4Ch] [bp-30h]
  unsigned int v272; // [sp+50h] [bp-2Ch]
  unsigned int v273; // [sp+54h] [bp-28h]
  int v274; // [sp+58h] [bp-24h]
  int v275; // [sp+5Ch] [bp-20h]
  int v276; // [sp+60h] [bp-1Ch]
  int v277; // [sp+64h] [bp-18h]
  int v278; // [sp+68h] [bp-14h]
  int v279; // [sp+6Ch] [bp-10h]
  int v280; // [sp+70h] [bp-Ch]

  v2 = a1[2];
  v4 = a1[6];
  v5 = a1[8];
  v6 = a1[7];
  v205 = a2;
  v275 = a1[3];
  v277 = a1[5];
  v280 = a1[9];
  v7 = bswap32(*a2);
  v276 = a1[4];
  v8 = (__ROR4__(v4, 11) ^ __ROR4__(v4, 6) ^ __ROR4__(v4, 25)) + v280 + 1116352408 + ((v6 ^ v5) & v4 ^ v5) + v7;
  v225 = v7;
  v9 = v277 + v8;
  v10 = (__ROR4__(v2, 13) ^ __ROR4__(v2, 2) ^ __ROR4__(v2, 22)) + ((v2 | v275) & v276 | v2 & v275) + v8;
  v209 = bswap32(a2[1]);
  v274 = v2;
  v279 = v5;
  v11 = ((v4 ^ v6) & (v277 + v8) ^ v6)
      + v5
      + 1899447441
      + v209
      + (__ROR4__(v277 + v8, 11) ^ __ROR4__(v277 + v8, 6) ^ __ROR4__(v277 + v8, 25));
  v271 = v4;
  v12 = (__ROR4__(v10, 13) ^ __ROR4__(v10, 2) ^ __ROR4__(v10, 22)) + ((v2 | v10) & v275 | v2 & v10) + v11;
  v13 = v276 + v11;
  v278 = v6;
  v260 = bswap32(a2[2]);
  v14 = ((v271 ^ v9) & (v276 + v11) ^ v271)
      + v6
      - 1245643825
      + v260
      + (__ROR4__(v276 + v11, 11) ^ __ROR4__(v276 + v11, 6) ^ __ROR4__(v276 + v11, 25));
  v15 = (__ROR4__(v12, 13) ^ __ROR4__(v12, 2) ^ __ROR4__(v12, 22)) + ((v10 | v12) & v2 | v10 & v12) + v14;
  v16 = v275 + v14;
  v230 = bswap32(a2[3]);
  v17 = ((v9 ^ v13) & v16 ^ v9)
      + v4
      - 373957723
      + v230
      + (__ROR4__(v275 + v14, 11) ^ __ROR4__(v16, 6) ^ __ROR4__(v16, 25));
  v18 = (__ROR4__(v15, 13) ^ __ROR4__(v15, 2) ^ __ROR4__(v15, 22)) + ((v12 | v15) & v10 | v12 & v15) + v17;
  v19 = v2 + v17;
  v221 = a2[8];
  v264 = bswap32(a2[4]);
  v20 = ((v13 ^ v16) & (v274 + v17) ^ v13)
      + v264
      + 961987163
      + v9
      + (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v274 + v17, 25));
  v21 = v10 + v20;
  v234 = a2[9];
  v250 = a2[10];
  v22 = (__ROR4__(v18, 13) ^ __ROR4__(v18, 2) ^ __ROR4__(v18, 22)) + ((v15 | v18) & v12 | v15 & v18) + v20;
  v239 = bswap32(v205[5]);
  v23 = ((v16 ^ (v2 + v17)) & v21 ^ v16)
      + v239
      + 1508970993
      + v13
      + (__ROR4__(v21, 11) ^ __ROR4__(v21, 6) ^ __ROR4__(v21, 25));
  v24 = v12 + v23;
  v25 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v18 | v22) & v15 | v18 & v22) + v23;
  v257 = bswap32(v205[6]);
  v26 = ((v19 ^ v21) & v24 ^ v19) + v257 - 1841331548 + v16 + (__ROR4__(v24, 11) ^ __ROR4__(v24, 6) ^ __ROR4__(v24, 25));
  v27 = (__ROR4__(v25, 13) ^ __ROR4__(v25, 2) ^ __ROR4__(v25, 22)) + ((v22 | v25) & v18 | v22 & v25) + v26;
  v28 = v15 + v26;
  v243 = bswap32(v205[7]);
  v29 = ((v21 ^ v24) & v28 ^ v21)
      + v243
      - 1424204075
      + v2
      + v17
      + (__ROR4__(v28, 11) ^ __ROR4__(v28, 6) ^ __ROR4__(v28, 25));
  v30 = v18 + v29;
  v247 = bswap32(v221);
  v212 = bswap32(v234);
  v31 = (__ROR4__(v27, 13) ^ __ROR4__(v27, 2) ^ __ROR4__(v27, 22)) + ((v25 | v27) & v22 | v25 & v27) + v29;
  v215 = bswap32(v250);
  v218 = bswap32(v205[11]);
  v32 = ((v24 ^ v28) & v30 ^ v24) + v247 - 670586216 + v21 + (__ROR4__(v30, 11) ^ __ROR4__(v30, 6) ^ __ROR4__(v30, 25));
  v33 = v22 + v32;
  v251 = bswap32(v205[12]);
  v34 = (__ROR4__(v31, 13) ^ __ROR4__(v31, 2) ^ __ROR4__(v31, 22)) + ((v27 | v31) & v25 | v27 & v31) + v32;
  v35 = ((v28 ^ v30) & v33 ^ v28) + v212 + 310598401 + v24 + (__ROR4__(v33, 11) ^ __ROR4__(v33, 6) ^ __ROR4__(v33, 25));
  v36 = v25 + v35;
  v254 = bswap32(v205[13]);
  v37 = (__ROR4__(v34, 13) ^ __ROR4__(v34, 2) ^ __ROR4__(v34, 22)) + ((v31 | v34) & v27 | v31 & v34) + v35;
  v222 = bswap32(v205[14]);
  v38 = ((v30 ^ v33) & v36 ^ v30) + v215 + 607225278 + v28 + (__ROR4__(v36, 11) ^ __ROR4__(v36, 6) ^ __ROR4__(v36, 25));
  v206 = bswap32(v205[15]);
  v39 = v27 + v38;
  v40 = (__ROR4__(v37, 13) ^ __ROR4__(v37, 2) ^ __ROR4__(v37, 22)) + ((v34 | v37) & v31 | v34 & v37) + v38;
  v268 = v209 + v215;
  v41 = ((v33 ^ v36) & v39 ^ v33) + v218 + 1426881987 + v30 + (__ROR4__(v39, 11) ^ __ROR4__(v39, 6) ^ __ROR4__(v39, 25));
  v42 = (__ROR4__(v40, 13) ^ __ROR4__(v40, 2) ^ __ROR4__(v40, 22)) + ((v37 | v40) & v34 | v37 & v40) + v41;
  v43 = v31 + v41;
  v44 = ((v36 ^ v39) & v43 ^ v36) + v251 + 1925078388 + v33 + (__ROR4__(v43, 11) ^ __ROR4__(v43, 6) ^ __ROR4__(v43, 25));
  v45 = (__ROR4__(v42, 13) ^ __ROR4__(v42, 2) ^ __ROR4__(v42, 22)) + ((v40 | v42) & v37 | v40 & v42) + v44;
  v46 = v34 + v44;
  v47 = ((v39 ^ v43) & v46 ^ v39) + v254 - 2132889090 + v36 + (__ROR4__(v46, 11) ^ __ROR4__(v46, 6) ^ __ROR4__(v46, 25));
  v48 = v37 + v47;
  v49 = (__ROR4__(v45, 13) ^ __ROR4__(v45, 2) ^ __ROR4__(v45, 22)) + ((v42 | v45) & v40 | v42 & v45) + v47;
  v50 = ((v43 ^ v46) & v48 ^ v43) + v222 - 1680079193 + v39 + (__ROR4__(v48, 11) ^ __ROR4__(v48, 6) ^ __ROR4__(v48, 25));
  v51 = (__ROR4__(v49, 13) ^ __ROR4__(v49, 2) ^ __ROR4__(v49, 22)) + ((v45 | v49) & v42 | v45 & v49) + v50;
  v52 = v40 + v50;
  v53 = ((v46 ^ v48) & v52 ^ v46) + v206 - 1046744716 + v43 + (__ROR4__(v52, 11) ^ __ROR4__(v52, 6) ^ __ROR4__(v52, 25));
  v54 = v42 + v53;
  v210 = (__ROR4__(v222, 19) ^ __ROR4__(v222, 17) ^ (v222 >> 10))
       + v225
       + v212
       + (__ROR4__(v209, 18) ^ __ROR4__(v209, 7) ^ (v209 >> 3));
  v235 = (__ROR4__(v51, 13) ^ __ROR4__(v51, 2) ^ __ROR4__(v51, 22)) + ((v49 | v51) & v45 | v49 & v51) + v53;
  v55 = ((v48 ^ v52) & v54 ^ v48) + v210 - 459576895 + v46 + (__ROR4__(v54, 11) ^ __ROR4__(v54, 6) ^ __ROR4__(v54, 25));
  v56 = v45 + v55;
  v57 = (__ROR4__(v235, 13) ^ __ROR4__(v235, 2) ^ __ROR4__(v235, 22)) + ((v51 | v235) & v49 | v51 & v235) + v55;
  v58 = (__ROR4__(v206, 19) ^ __ROR4__(v206, 17) ^ (v206 >> 10))
      + v268
      + (__ROR4__(v260, 18) ^ __ROR4__(v260, 7) ^ (v260 >> 3));
  v59 = ((v52 ^ v54) & (v45 + v55) ^ v52)
      + v58
      - 272742522
      + v48
      + (__ROR4__(v45 + v55, 11) ^ __ROR4__(v45 + v55, 6) ^ __ROR4__(v45 + v55, 25));
  v60 = v49 + v59;
  v61 = (__ROR4__(v57, 13) ^ __ROR4__(v57, 2) ^ __ROR4__(v57, 22)) + ((v235 | v57) & v51 | v235 & v57) + v59;
  v226 = (__ROR4__(v230, 18) ^ __ROR4__(v230, 7) ^ (v230 >> 3))
       + v260
       + v218
       + (__ROR4__(v210, 19) ^ __ROR4__(v210, 17) ^ (v210 >> 10));
  v62 = ((v54 ^ v56) & v60 ^ v54)
      + v226
      + 264347078
      + v52
      + (__ROR4__(v49 + v59, 11) ^ __ROR4__(v60, 6) ^ __ROR4__(v60, 25));
  v63 = v51 + v62;
  v64 = (__ROR4__(v61, 13) ^ __ROR4__(v61, 2) ^ __ROR4__(v61, 22)) + ((v57 | v61) & v235 | v57 & v61) + v62;
  v261 = v58;
  v231 = (__ROR4__(v264, 18) ^ __ROR4__(v264, 7) ^ (v264 >> 3))
       + v230
       + v251
       + (__ROR4__(v58, 19) ^ __ROR4__(v58, 17) ^ (v58 >> 10));
  v65 = ((v56 ^ v60) & v63 ^ v56) + v231 + 604807628 + v54 + (__ROR4__(v63, 11) ^ __ROR4__(v63, 6) ^ __ROR4__(v63, 25));
  v66 = (__ROR4__(v64, 13) ^ __ROR4__(v64, 2) ^ __ROR4__(v64, 22)) + ((v61 | v64) & v57 | v61 & v64) + v65;
  v67 = v235 + v65;
  v236 = (__ROR4__(v239, 18) ^ __ROR4__(v239, 7) ^ (v239 >> 3))
       + v264
       + v254
       + (__ROR4__(v226, 19) ^ __ROR4__(v226, 17) ^ (v226 >> 10));
  v68 = ((v60 ^ v63) & v67 ^ v60) + v236 + 770255983 + v56 + (__ROR4__(v67, 11) ^ __ROR4__(v67, 6) ^ __ROR4__(v67, 25));
  v69 = v57 + v68;
  v70 = (__ROR4__(v66, 13) ^ __ROR4__(v66, 2) ^ __ROR4__(v66, 22)) + ((v64 | v66) & v61 | v64 & v66) + v68;
  v240 = (__ROR4__(v257, 18) ^ __ROR4__(v257, 7) ^ (v257 >> 3))
       + v239
       + v222
       + (__ROR4__(v231, 19) ^ __ROR4__(v231, 17) ^ (v231 >> 10));
  v71 = ((v63 ^ v67) & (v57 + v68) ^ v63)
      + v240
      + 1249150122
      + v60
      + (__ROR4__(v69, 11) ^ __ROR4__(v69, 6) ^ __ROR4__(v69, 25));
  v72 = v61 + v71;
  v73 = (__ROR4__(v70, 13) ^ __ROR4__(v70, 2) ^ __ROR4__(v70, 22)) + ((v66 | v70) & v64 | v66 & v70) + v71;
  v265 = (__ROR4__(v243, 18) ^ __ROR4__(v243, 7) ^ (v243 >> 3))
       + v257
       + v206
       + (__ROR4__(v236, 19) ^ __ROR4__(v236, 17) ^ (v236 >> 10));
  v74 = ((v67 ^ v69) & v72 ^ v67) + v265 + 1555081692 + v63 + (__ROR4__(v72, 11) ^ __ROR4__(v72, 6) ^ __ROR4__(v72, 25));
  v75 = v64 + v74;
  v76 = (__ROR4__(v73, 13) ^ __ROR4__(v73, 2) ^ __ROR4__(v73, 22)) + ((v70 | v73) & v66 | v70 & v73) + v74;
  v244 = (__ROR4__(v247, 18) ^ __ROR4__(v247, 7) ^ (v247 >> 3))
       + v243
       + v210
       + (__ROR4__(v240, 19) ^ __ROR4__(v240, 17) ^ (v240 >> 10));
  v77 = ((v69 ^ v72) & v75 ^ v69) + v244 + 1996064986 + v67 + (__ROR4__(v75, 11) ^ __ROR4__(v75, 6) ^ __ROR4__(v75, 25));
  v78 = v66 + v77;
  v79 = (__ROR4__(v76, 13) ^ __ROR4__(v76, 2) ^ __ROR4__(v76, 22)) + ((v73 | v76) & v70 | v73 & v76) + v77;
  v80 = (__ROR4__(v212, 18) ^ __ROR4__(v212, 7) ^ (v212 >> 3))
      + v247
      + v58
      + (__ROR4__(v265, 19) ^ __ROR4__(v265, 17) ^ (v265 >> 10));
  v81 = ((v72 ^ v75) & v78 ^ v72) + v80 - 1740746414 + v69 + (__ROR4__(v78, 11) ^ __ROR4__(v78, 6) ^ __ROR4__(v78, 25));
  v82 = v70 + v81;
  v83 = (__ROR4__(v79, 13) ^ __ROR4__(v79, 2) ^ __ROR4__(v79, 22)) + ((v76 | v79) & v73 | v76 & v79) + v81;
  v248 = (__ROR4__(v215, 18) ^ __ROR4__(v215, 7) ^ (v215 >> 3))
       + v212
       + v226
       + (__ROR4__(v244, 19) ^ __ROR4__(v244, 17) ^ (v244 >> 10));
  v269 = v80;
  v84 = ((v75 ^ v78) & v82 ^ v75) + v248 - 1473132947 + v72 + (__ROR4__(v82, 11) ^ __ROR4__(v82, 6) ^ __ROR4__(v82, 25));
  v85 = (__ROR4__(v83, 13) ^ __ROR4__(v83, 2) ^ __ROR4__(v83, 22)) + ((v79 | v83) & v76 | v79 & v83) + v84;
  v86 = v73 + v84;
  v216 = (__ROR4__(v218, 18) ^ __ROR4__(v218, 7) ^ (v218 >> 3))
       + v215
       + v231
       + (__ROR4__(v80, 19) ^ __ROR4__(v80, 17) ^ (v80 >> 10));
  v87 = ((v78 ^ v82) & v86 ^ v78) + v216 - 1341970488 + v75 + (__ROR4__(v86, 11) ^ __ROR4__(v86, 6) ^ __ROR4__(v86, 25));
  v88 = v76 + v87;
  v89 = (__ROR4__(v85, 13) ^ __ROR4__(v85, 2) ^ __ROR4__(v85, 22)) + ((v83 | v85) & v79 | v83 & v85) + v87;
  v219 = (__ROR4__(v251, 18) ^ __ROR4__(v251, 7) ^ (v251 >> 3))
       + v218
       + v236
       + (__ROR4__(v248, 19) ^ __ROR4__(v248, 17) ^ (v248 >> 10));
  v90 = ((v82 ^ v86) & v88 ^ v82) + v219 - 1084653625 + v78 + (__ROR4__(v88, 11) ^ __ROR4__(v88, 6) ^ __ROR4__(v88, 25));
  v91 = (__ROR4__(v89, 13) ^ __ROR4__(v89, 2) ^ __ROR4__(v89, 22)) + ((v85 | v89) & v83 | v85 & v89) + v90;
  v92 = v79 + v90;
  v252 = (__ROR4__(v254, 18) ^ __ROR4__(v254, 7) ^ (v254 >> 3))
       + v251
       + v240
       + (__ROR4__(v216, 19) ^ __ROR4__(v216, 17) ^ (v216 >> 10));
  v93 = ((v86 ^ v88) & v92 ^ v86) + v252 - 958395405 + v82 + (__ROR4__(v92, 11) ^ __ROR4__(v92, 6) ^ __ROR4__(v92, 25));
  v94 = v83 + v93;
  v95 = (__ROR4__(v91, 13) ^ __ROR4__(v91, 2) ^ __ROR4__(v91, 22)) + ((v89 | v91) & v85 | v89 & v91) + v93;
  v213 = (__ROR4__(v222, 18) ^ __ROR4__(v222, 7) ^ (v222 >> 3))
       + v254
       + v265
       + (__ROR4__(v219, 19) ^ __ROR4__(v219, 17) ^ (v219 >> 10));
  v96 = ((v88 ^ v92) & v94 ^ v88) + v213 - 710438585 + v86 + (__ROR4__(v94, 11) ^ __ROR4__(v94, 6) ^ __ROR4__(v94, 25));
  v97 = v85 + v96;
  v98 = (__ROR4__(v95, 13) ^ __ROR4__(v95, 2) ^ __ROR4__(v95, 22)) + ((v91 | v95) & v89 | v91 & v95) + v96;
  v223 = (__ROR4__(v206, 18) ^ __ROR4__(v206, 7) ^ (v206 >> 3))
       + v222
       + v244
       + (__ROR4__(v252, 19) ^ __ROR4__(v252, 17) ^ (v252 >> 10));
  v99 = ((v92 ^ v94) & v97 ^ v92) + v223 + 113926993 + v88 + (__ROR4__(v97, 11) ^ __ROR4__(v97, 6) ^ __ROR4__(v97, 25));
  v100 = v89 + v99;
  v101 = (__ROR4__(v98, 13) ^ __ROR4__(v98, 2) ^ __ROR4__(v98, 22)) + ((v95 | v98) & v91 | v95 & v98) + v99;
  v255 = (__ROR4__(v210, 18) ^ __ROR4__(v210, 7) ^ (v210 >> 3))
       + v206
       + v80
       + (__ROR4__(v213, 19) ^ __ROR4__(v213, 17) ^ (v213 >> 10));
  v102 = ((v94 ^ v97) & v100 ^ v94)
       + v255
       + 338241895
       + v92
       + (__ROR4__(v100, 11) ^ __ROR4__(v100, 6) ^ __ROR4__(v100, 25));
  v103 = v91 + v102;
  v104 = __ROR4__(v91 + v102, 11);
  v105 = (__ROR4__(v101, 13) ^ __ROR4__(v101, 2) ^ __ROR4__(v101, 22)) + ((v98 | v101) & v95 | v98 & v101) + v102;
  v258 = (__ROR4__(v261, 18) ^ __ROR4__(v261, 7) ^ (v261 >> 3))
       + v210
       + v248
       + (__ROR4__(v223, 19) ^ __ROR4__(v223, 17) ^ (v223 >> 10));
  v106 = ((v97 ^ v100) & v103 ^ v97) + v258 + 666307205 + v94 + (v104 ^ __ROR4__(v103, 6) ^ __ROR4__(v103, 25));
  v107 = v95 + v106;
  v108 = (__ROR4__(v105, 13) ^ __ROR4__(v105, 2) ^ __ROR4__(v105, 22)) + ((v101 | v105) & v98 | v101 & v105) + v106;
  v262 = (__ROR4__(v226, 18) ^ __ROR4__(v226, 7) ^ (v226 >> 3))
       + v261
       + v216
       + (__ROR4__(v255, 19) ^ __ROR4__(v255, 17) ^ (v255 >> 10));
  v109 = ((v100 ^ v103) & v107 ^ v100)
       + v262
       + 773529912
       + v97
       + (__ROR4__(v107, 11) ^ __ROR4__(v107, 6) ^ __ROR4__(v107, 25));
  v110 = v98 + v109;
  v111 = (__ROR4__(v108, 13) ^ __ROR4__(v108, 2) ^ __ROR4__(v108, 22)) + ((v105 | v108) & v101 | v105 & v108) + v109;
  v227 = (__ROR4__(v231, 18) ^ __ROR4__(v231, 7) ^ (v231 >> 3))
       + v226
       + v219
       + (__ROR4__(v258, 19) ^ __ROR4__(v258, 17) ^ (v258 >> 10));
  v112 = ((v103 ^ v107) & v110 ^ v103)
       + v227
       + 1294757372
       + v100
       + (__ROR4__(v110, 11) ^ __ROR4__(v110, 6) ^ __ROR4__(v110, 25));
  v113 = v101 + v112;
  v114 = (__ROR4__(v111, 13) ^ __ROR4__(v111, 2) ^ __ROR4__(v111, 22)) + ((v108 | v111) & v105 | v108 & v111) + v112;
  v232 = (__ROR4__(v236, 18) ^ __ROR4__(v236, 7) ^ (v236 >> 3))
       + v231
       + v252
       + (__ROR4__(v262, 19) ^ __ROR4__(v262, 17) ^ (v262 >> 10));
  v115 = ((v107 ^ v110) & v113 ^ v107)
       + v232
       + 1396182291
       + v103
       + (__ROR4__(v113, 11) ^ __ROR4__(v113, 6) ^ __ROR4__(v113, 25));
  v116 = v105 + v115;
  v117 = (__ROR4__(v114, 13) ^ __ROR4__(v114, 2) ^ __ROR4__(v114, 22)) + ((v111 | v114) & v108 | v111 & v114) + v115;
  v237 = (__ROR4__(v240, 18) ^ __ROR4__(v240, 7) ^ (v240 >> 3))
       + v236
       + v213
       + (__ROR4__(v227, 19) ^ __ROR4__(v227, 17) ^ (v227 >> 10));
  v118 = ((v110 ^ v113) & v116 ^ v110)
       + v237
       + 1695183700
       + v107
       + (__ROR4__(v105 + v115, 11) ^ __ROR4__(v105 + v115, 6) ^ __ROR4__(v116, 25));
  v119 = v108 + v118;
  v120 = (__ROR4__(v117, 13) ^ __ROR4__(v117, 2) ^ __ROR4__(v117, 22)) + ((v114 | v117) & v111 | v114 & v117) + v118;
  v241 = (__ROR4__(v265, 18) ^ __ROR4__(v265, 7) ^ (v265 >> 3))
       + v240
       + v223
       + (__ROR4__(v232, 19) ^ __ROR4__(v232, 17) ^ (v232 >> 10));
  v121 = ((v113 ^ (v105 + v115)) & (v108 + v118) ^ v113)
       + v241
       + 1986661051
       + v110
       + (__ROR4__(v108 + v118, 11) ^ __ROR4__(v108 + v118, 6) ^ __ROR4__(v108 + v118, 25));
  v122 = v111 + v121;
  v123 = (__ROR4__(v120, 13) ^ __ROR4__(v120, 2) ^ __ROR4__(v120, 22)) + ((v117 | v120) & v114 | v117 & v120) + v121;
  v266 = (__ROR4__(v244, 18) ^ __ROR4__(v244, 7) ^ (v244 >> 3))
       + v265
       + v255
       + (__ROR4__(v237, 19) ^ __ROR4__(v237, 17) ^ (v237 >> 10));
  v124 = ((v116 ^ (v108 + v118)) & v122 ^ v116)
       + v266
       - 2117940946
       + v113
       + (__ROR4__(v111 + v121, 11) ^ __ROR4__(v122, 6) ^ __ROR4__(v122, 25));
  v125 = v114 + v124;
  v126 = (__ROR4__(v123, 13) ^ __ROR4__(v123, 2) ^ __ROR4__(v123, 22)) + ((v120 | v123) & v117 | v120 & v123) + v124;
  v245 = (__ROR4__(v269, 18) ^ __ROR4__(v269, 7) ^ (v269 >> 3))
       + v244
       + v258
       + (__ROR4__(v241, 19) ^ __ROR4__(v241, 17) ^ (v241 >> 10));
  v127 = ((v119 ^ (v111 + v121)) & v125 ^ v119)
       + v245
       - 1838011259
       + v116
       + (__ROR4__(v114 + v124, 11) ^ __ROR4__(v114 + v124, 6) ^ __ROR4__(v125, 25));
  v128 = (__ROR4__(v126, 13) ^ __ROR4__(v126, 2) ^ __ROR4__(v126, 22)) + ((v123 | v126) & v120 | v123 & v126) + v127;
  v129 = v117 + v127;
  v270 = (__ROR4__(v248, 18) ^ __ROR4__(v248, 7) ^ (v248 >> 3))
       + v269
       + v262
       + (__ROR4__(v266, 19) ^ __ROR4__(v266, 17) ^ (v266 >> 10));
  v130 = ((v122 ^ v125) & (v117 + v127) ^ v122)
       + v270
       - 1564481375
       + v119
       + (__ROR4__(v117 + v127, 11) ^ __ROR4__(v117 + v127, 6) ^ __ROR4__(v117 + v127, 25));
  v131 = v120 + v130;
  v132 = (__ROR4__(v128, 13) ^ __ROR4__(v128, 2) ^ __ROR4__(v128, 22)) + ((v126 | v128) & v123 | v126 & v128) + v130;
  v207 = (__ROR4__(v216, 18) ^ __ROR4__(v216, 7) ^ (v216 >> 3))
       + v248
       + v227
       + (__ROR4__(v245, 19) ^ __ROR4__(v245, 17) ^ (v245 >> 10));
  v133 = ((v125 ^ v129) & v131 ^ v125)
       + v207
       - 1474664885
       + v122
       + (__ROR4__(v131, 11) ^ __ROR4__(v131, 6) ^ __ROR4__(v131, 25));
  v134 = v123 + v133;
  v135 = (__ROR4__(v132, 13) ^ __ROR4__(v132, 2) ^ __ROR4__(v132, 22)) + ((v128 | v132) & v126 | v128 & v132) + v133;
  v249 = (__ROR4__(v219, 18) ^ __ROR4__(v219, 7) ^ (v219 >> 3))
       + v216
       + v232
       + (__ROR4__(v270, 19) ^ __ROR4__(v270, 17) ^ (v270 >> 10));
  v136 = ((v129 ^ v131) & v134 ^ v129)
       + v249
       - 1035236496
       + v125
       + (__ROR4__(v134, 11) ^ __ROR4__(v134, 6) ^ __ROR4__(v134, 25));
  v137 = (__ROR4__(v135, 13) ^ __ROR4__(v135, 2) ^ __ROR4__(v135, 22)) + ((v132 | v135) & v128 | v132 & v135) + v136;
  v220 = (__ROR4__(v252, 18) ^ __ROR4__(v252, 7) ^ (v252 >> 3))
       + v219
       + v237
       + (__ROR4__(v207, 19) ^ __ROR4__(v207, 17) ^ (v207 >> 10));
  v138 = ((v131 ^ v134) & (v126 + v136) ^ v131)
       + v220
       - 949202525
       + v129
       + (__ROR4__(v126 + v136, 11) ^ __ROR4__(v126 + v136, 6) ^ __ROR4__(v126 + v136, 25));
  v139 = (__ROR4__(v137, 13) ^ __ROR4__(v137, 2) ^ __ROR4__(v137, 22)) + ((v135 | v137) & v132 | v135 & v137) + v138;
  v140 = v128 + v138;
  v211 = (__ROR4__(v213, 18) ^ __ROR4__(v213, 7) ^ (v213 >> 3))
       + v252
       + v241
       + (__ROR4__(v249, 19) ^ __ROR4__(v249, 17) ^ (v249 >> 10));
  v141 = ((v134 ^ (v126 + v136)) & v140 ^ v134)
       + v211
       - 778901479
       + v131
       + (__ROR4__(v128 + v138, 11) ^ __ROR4__(v128 + v138, 6) ^ __ROR4__(v140, 25));
  v142 = v132 + v141;
  v143 = (__ROR4__(v139, 13) ^ __ROR4__(v139, 2) ^ __ROR4__(v139, 22)) + ((v137 | v139) & v135 | v137 & v139) + v141;
  v214 = (__ROR4__(v223, 18) ^ __ROR4__(v223, 7) ^ (v223 >> 3))
       + v213
       + v266
       + (__ROR4__(v220, 19) ^ __ROR4__(v220, 17) ^ (v220 >> 10));
  v144 = (((v126 + v136) ^ v140) & v142 ^ (v126 + v136))
       + v214
       - 694614492
       + v134
       + (__ROR4__(v142, 11) ^ __ROR4__(v142, 6) ^ __ROR4__(v142, 25));
  v145 = v135 + v144;
  v146 = (__ROR4__(v143, 13) ^ __ROR4__(v143, 2) ^ __ROR4__(v143, 22)) + ((v139 | v143) & v137 | v139 & v143) + v144;
  v224 = (__ROR4__(v255, 18) ^ __ROR4__(v255, 7) ^ (v255 >> 3))
       + v223
       + v245
       + (__ROR4__(v211, 19) ^ __ROR4__(v211, 17) ^ (v211 >> 10));
  v147 = ((v140 ^ v142) & v145 ^ v140)
       + v224
       - 200395387
       + v126
       + v136
       + (__ROR4__(v145, 11) ^ __ROR4__(v145, 6) ^ __ROR4__(v145, 25));
  v148 = v137 + v147;
  v149 = (__ROR4__(v146, 13) ^ __ROR4__(v146, 2) ^ __ROR4__(v146, 22)) + ((v143 | v146) & v139 | v143 & v146) + v147;
  v217 = (__ROR4__(v258, 18) ^ __ROR4__(v258, 7) ^ (v258 >> 3))
       + v255
       + v270
       + (__ROR4__(v214, 19) ^ __ROR4__(v214, 17) ^ (v214 >> 10));
  v150 = ((v142 ^ v145) & v148 ^ v142)
       + v217
       + 275423344
       + v140
       + (__ROR4__(v148, 11) ^ __ROR4__(v148, 6) ^ __ROR4__(v148, 25));
  v151 = v139 + v150;
  v152 = (__ROR4__(v149, 13) ^ __ROR4__(v149, 2) ^ __ROR4__(v149, 22)) + ((v146 | v149) & v143 | v146 & v149) + v150;
  v253 = (__ROR4__(v262, 18) ^ __ROR4__(v262, 7) ^ (v262 >> 3))
       + v258
       + v207
       + (__ROR4__(v224, 19) ^ __ROR4__(v224, 17) ^ (v224 >> 10));
  v153 = ((v145 ^ v148) & v151 ^ v145)
       + v253
       + 430227734
       + v142
       + (__ROR4__(v151, 11) ^ __ROR4__(v151, 6) ^ __ROR4__(v151, 25));
  v154 = v143 + v153;
  v155 = (__ROR4__(v152, 13) ^ __ROR4__(v152, 2) ^ __ROR4__(v152, 22)) + ((v149 | v152) & v146 | v149 & v152) + v153;
  v256 = (__ROR4__(v227, 18) ^ __ROR4__(v227, 7) ^ (v227 >> 3))
       + v262
       + v249
       + (__ROR4__(v217, 19) ^ __ROR4__(v217, 17) ^ (v217 >> 10));
  v156 = ((v148 ^ v151) & v154 ^ v148)
       + v256
       + 506948616
       + v145
       + (__ROR4__(v154, 11) ^ __ROR4__(v154, 6) ^ __ROR4__(v154, 25));
  v157 = (__ROR4__(v155, 13) ^ __ROR4__(v155, 2) ^ __ROR4__(v155, 22)) + ((v152 | v155) & v149 | v152 & v155) + v156;
  v158 = v146 + v156;
  v259 = (__ROR4__(v232, 18) ^ __ROR4__(v232, 7) ^ (v232 >> 3))
       + v227
       + v220
       + (__ROR4__(v253, 19) ^ __ROR4__(v253, 17) ^ (v253 >> 10));
  v159 = ((v151 ^ v154) & v158 ^ v151)
       + v259
       + 659060556
       + v148
       + (__ROR4__(v158, 11) ^ __ROR4__(v158, 6) ^ __ROR4__(v158, 25));
  v160 = v149 + v159;
  v161 = (__ROR4__(v157, 13) ^ __ROR4__(v157, 2) ^ __ROR4__(v157, 22)) + ((v155 | v157) & v152 | v155 & v157) + v159;
  v263 = (__ROR4__(v237, 18) ^ __ROR4__(v237, 7) ^ (v237 >> 3))
       + v232
       + v211
       + (__ROR4__(v256, 19) ^ __ROR4__(v256, 17) ^ (v256 >> 10));
  v162 = ((v154 ^ v158) & v160 ^ v154)
       + v263
       + 883997877
       + v151
       + (__ROR4__(v160, 11) ^ __ROR4__(v160, 6) ^ __ROR4__(v160, 25));
  v163 = v152 + v162;
  v164 = (__ROR4__(v161, 13) ^ __ROR4__(v161, 2) ^ __ROR4__(v161, 22)) + ((v157 | v161) & v155 | v157 & v161) + v162;
  v272 = (__ROR4__(v241, 18) ^ __ROR4__(v241, 7) ^ (v241 >> 3))
       + v237
       + v214
       + (__ROR4__(v259, 19) ^ __ROR4__(v259, 17) ^ (v259 >> 10));
  v165 = ((v158 ^ v160) & v163 ^ v158)
       + v272
       + 958139571
       + v154
       + (__ROR4__(v163, 11) ^ __ROR4__(v163, 6) ^ __ROR4__(v163, 25));
  v166 = v155 + v165;
  v167 = (__ROR4__(v164, 13) ^ __ROR4__(v164, 2) ^ __ROR4__(v164, 22)) + ((v161 | v164) & v157 | v161 & v164) + v165;
  v273 = (__ROR4__(v266, 18) ^ __ROR4__(v266, 7) ^ (v266 >> 3))
       + v241
       + v224
       + (__ROR4__(v263, 19) ^ __ROR4__(v263, 17) ^ (v263 >> 10));
  v168 = ((v160 ^ v163) & v166 ^ v160)
       + v273
       + 1322822218
       + v158
       + (__ROR4__(v166, 11) ^ __ROR4__(v166, 6) ^ __ROR4__(v166, 25));
  v169 = v157 + v168;
  v170 = (__ROR4__(v167, 13) ^ __ROR4__(v167, 2) ^ __ROR4__(v167, 22)) + ((v164 | v167) & v161 | v164 & v167) + v168;
  v267 = (__ROR4__(v245, 18) ^ __ROR4__(v245, 7) ^ (v245 >> 3))
       + v266
       + v217
       + (__ROR4__(v272, 19) ^ __ROR4__(v272, 17) ^ (v272 >> 10));
  v171 = ((v163 ^ v166) & v169 ^ v163)
       + v267
       + 1537002063
       + v160
       + (__ROR4__(v169, 11) ^ __ROR4__(v169, 6) ^ __ROR4__(v169, 25));
  v172 = v161 + v171;
  v173 = (__ROR4__(v170, 13) ^ __ROR4__(v170, 2) ^ __ROR4__(v170, 22)) + ((v167 | v170) & v164 | v167 & v170) + v171;
  v233 = (__ROR4__(v270, 18) ^ __ROR4__(v270, 7) ^ (v270 >> 3))
       + v245
       + v253
       + (__ROR4__(v273, 19) ^ __ROR4__(v273, 17) ^ (v273 >> 10));
  v174 = ((v166 ^ v169) & v172 ^ v166)
       + v233
       + 1747873779
       + v163
       + (__ROR4__(v172, 11) ^ __ROR4__(v172, 6) ^ __ROR4__(v172, 25));
  v175 = v164 + v174;
  v228 = (__ROR4__(v173, 13) ^ __ROR4__(v173, 2) ^ __ROR4__(v173, 22)) + ((v170 | v173) & v167 | v170 & v173) + v174;
  v238 = (__ROR4__(v207, 18) ^ __ROR4__(v207, 7) ^ (v207 >> 3))
       + v270
       + v256
       + (__ROR4__(v267, 19) ^ __ROR4__(v267, 17) ^ (v267 >> 10));
  v176 = ((v169 ^ v172) & v175 ^ v169)
       + v238
       + 1955562222
       + v166
       + (__ROR4__(v175, 11) ^ __ROR4__(v175, 6) ^ __ROR4__(v175, 25));
  v177 = (__ROR4__(v249, 18) ^ __ROR4__(v249, 7) ^ (v249 >> 3)) + v207;
  v208 = (__ROR4__(v228, 13) ^ __ROR4__(v228, 2) ^ __ROR4__(v228, 22)) + ((v173 | v228) & v170 | v173 & v228) + v176;
  v178 = v177 + v259 + (__ROR4__(v233, 19) ^ __ROR4__(v233, 17) ^ (v233 >> 10));
  v242 = v167 + v176;
  v179 = ((v172 ^ v175) & v242 ^ v172)
       + v178
       + 2024104815
       + v169
       + (__ROR4__(v242, 11) ^ __ROR4__(v242, 6) ^ __ROR4__(v242, 25));
  v180 = v170 + v179;
  v181 = (__ROR4__(v208, 13) ^ __ROR4__(v208, 2) ^ __ROR4__(v208, 22)) + ((v228 | v208) & v173 | v228 & v208) + v179;
  v182 = (__ROR4__(v220, 18) ^ __ROR4__(v220, 7) ^ (v220 >> 3))
       + v249
       + v263
       + (__ROR4__(v238, 19) ^ __ROR4__(v238, 17) ^ (v238 >> 10));
  v183 = ((v175 ^ v242) & (v170 + v179) ^ v175)
       + v182
       - 2067236844
       + v172
       + (__ROR4__(v170 + v179, 11) ^ __ROR4__(v170 + v179, 6) ^ __ROR4__(v170 + v179, 25));
  v184 = v173 + v183;
  v185 = (__ROR4__(v181, 13) ^ __ROR4__(v181, 2) ^ __ROR4__(v181, 22)) + ((v208 | v181) & v228 | v208 & v181) + v183;
  v186 = (__ROR4__(v211, 18) ^ __ROR4__(v211, 7) ^ (v211 >> 3))
       + v220
       + v272
       + (__ROR4__(v178, 19) ^ __ROR4__(v178, 17) ^ (v178 >> 10));
  v187 = ((v242 ^ (v170 + v179)) & v184 ^ v242)
       + v186
       - 1933114872
       + v175
       + (__ROR4__(v184, 11) ^ __ROR4__(v184, 6) ^ __ROR4__(v184, 25));
  v246 = __ROR4__(v186, 19) ^ __ROR4__(v186, 17) ^ (v186 >> 10);
  v188 = v228;
  v189 = (__ROR4__(v185, 13) ^ __ROR4__(v185, 2) ^ __ROR4__(v185, 22)) + ((v181 | v185) & v208 | v181 & v185) + v187;
  v229 = v180;
  v190 = v188 + v187;
  v191 = (__ROR4__(v214, 18) ^ __ROR4__(v214, 7) ^ (v214 >> 3))
       + v211
       + v273
       + (__ROR4__(v182, 19) ^ __ROR4__(v182, 17) ^ (v182 >> 10));
  v192 = ((v180 ^ v184) & v190 ^ v180)
       + v191
       - 1866530822
       + v242
       + (__ROR4__(v190, 11) ^ __ROR4__(v190, 6) ^ __ROR4__(v190, 25));
  v193 = (__ROR4__(v189, 13) ^ __ROR4__(v189, 2) ^ __ROR4__(v189, 22)) + ((v185 | v189) & v181 | v185 & v189) + v192;
  v194 = v208 + v192;
  v195 = (__ROR4__(v224, 18) ^ __ROR4__(v224, 7) ^ (v224 >> 3)) + v214 + v267 + v246;
  v196 = ((v184 ^ v190) & v194 ^ v184)
       + v195
       - 1538233109
       + v229
       + (__ROR4__(v194, 11) ^ __ROR4__(v194, 6) ^ __ROR4__(v194, 25));
  v197 = v181 + v196;
  v198 = (__ROR4__(v193, 13) ^ __ROR4__(v193, 2) ^ __ROR4__(v193, 22)) + ((v189 | v193) & v185 | v189 & v193) + v196;
  v199 = (__ROR4__(v217, 18) ^ __ROR4__(v217, 7) ^ (v217 >> 3))
       + v224
       - 1090935817
       + v233
       + (__ROR4__(v191, 19) ^ __ROR4__(v191, 17) ^ (v191 >> 10))
       + v184
       + ((v190 ^ (v208 + v192)) & v197 ^ v190)
       + (__ROR4__(v197, 11) ^ __ROR4__(v197, 6) ^ __ROR4__(v197, 25));
  v200 = (__ROR4__(v198, 13) ^ __ROR4__(v198, 2) ^ __ROR4__(v198, 22)) + ((v193 | v198) & v189 | v193 & v198) + v199;
  v201 = v185 + v199;
  v202 = (__ROR4__(v253, 18) ^ __ROR4__(v253, 7) ^ (v253 >> 3))
       + v217
       - 965641998
       + v238
       + (__ROR4__(v195, 19) ^ __ROR4__(v195, 17) ^ (v195 >> 10))
       + v190
       + ((v194 ^ v197) & v201 ^ v194)
       + (__ROR4__(v201, 11) ^ __ROR4__(v201, 6) ^ __ROR4__(v201, 25));
  v203 = (__ROR4__(v200, 13) ^ __ROR4__(v200, 2) ^ __ROR4__(v200, 22))
       + ((v198 | v200) & v193 | v198 & v200)
       + v274
       + v202;
  result = v276 + v198;
  a1[9] = v280 + v194;
  a1[5] = v277 + v193;
  a1[8] = v279 + v197;
  a1[4] = result;
  a1[3] = v275 + v200;
  a1[7] = v278 + v201;
  a1[2] = v203;
  a1[6] = v271 + v189 + v202;
  return result;
}

//----- (0002FE40) --------------------------------------------------------
int *__fastcall sub_2FE40(int *result, unsigned int *a2, signed int a3)
{
  signed int v3; // r5
  int v4; // r3
  int *v5; // r6
  unsigned int *v6; // r4
  bool v7; // cf
  int v8; // r2
  int v9; // r8
  signed int v10; // r7
  _BOOL4 v11; // r3
  unsigned int v12; // r5
  unsigned int *v13; // r7
  unsigned int *v14; // r1
  unsigned int *v15; // r9

  v3 = a3;
  v4 = *result;
  v5 = result;
  v6 = a2;
  v7 = __CFADD__(*result, a3);
  v8 = *result + a3;
  v9 = *result & 0x3F;
  if ( v7 )
    v4 = result[1];
  v10 = 64 - v9;
  *result = v8;
  if ( v7 )
    result[1] = v4 + 1;
  v11 = v10 <= v3;
  if ( !v9 )
    v11 = 0;
  if ( v11 )
  {
    v15 = (unsigned int *)(result + 10);
    v3 -= v10;
    memcpy((char *)result + v9 + 40, a2, 64 - v9);
    v6 = (unsigned int *)((char *)v6 + v10);
    v9 = 0;
    result = (int *)sub_2D9E0(v5, v15);
  }
  if ( v3 > 63 )
  {
    v12 = v3 - 64;
    v13 = &v6[16 * (v12 >> 6) + 16];
    do
    {
      v14 = v6;
      v6 += 16;
      result = (int *)sub_2D9E0(v5, v14);
    }
    while ( v6 != v13 );
    v3 = v12 - (v12 >> 6 << 6);
  }
  if ( v3 > 0 )
    return (int *)memcpy((char *)v5 + v9 + 40, v6, v3);
  return result;
}

//----- (0002FF0C) --------------------------------------------------------
int *__fastcall sub_2FF0C(int *result, unsigned int *a2, signed int a3)
{
  if ( a3 > 0 )
    return sub_2FE40(result, a2, a3);
  return result;
}

//----- (0002FF18) --------------------------------------------------------
int *__fastcall sub_2FF18(int a1, _BYTE *a2)
{
  unsigned int v4; // r2
  int v5; // r1
  unsigned int v6; // r3
  unsigned int v7; // r0
  unsigned int v8; // r3
  signed int v9; // r2
  int *result; // r0
  unsigned int v11; // [sp+0h] [bp-Ch] BYREF
  char v12; // [sp+4h] [bp-8h]
  char v13; // [sp+5h] [bp-7h]
  char v14; // [sp+6h] [bp-6h]
  char v15; // [sp+7h] [bp-5h]

  v4 = *(_DWORD *)a1 & 0x3F;
  v5 = *(_QWORD *)a1 >> 29;
  v6 = 8 * *(_DWORD *)a1;
  v15 = 8 * *(_BYTE *)a1;
  v12 = HIBYTE(v6);
  HIBYTE(v11) = v5;
  BYTE1(v11) = BYTE2(v5);
  v7 = HIWORD(v6);
  v8 = v6 >> 8;
  BYTE2(v11) = BYTE1(v5);
  v13 = v7;
  if ( v4 > 0x37 )
    v9 = 120 - v4;
  else
    v9 = 56 - v4;
  v14 = v8;
  LOBYTE(v11) = HIBYTE(v5);
  sub_2FE40((int *)a1, dword_9B4B4, v9);
  result = sub_2FE40((int *)a1, &v11, 8);
  *a2 = *(_BYTE *)(a1 + 11);
  a2[1] = *(_WORD *)(a1 + 10);
  a2[2] = BYTE1(*(_DWORD *)(a1 + 8));
  a2[3] = *(_DWORD *)(a1 + 8);
  a2[4] = *(_BYTE *)(a1 + 15);
  a2[5] = *(_WORD *)(a1 + 14);
  a2[6] = BYTE1(*(_DWORD *)(a1 + 12));
  a2[7] = *(_DWORD *)(a1 + 12);
  a2[8] = *(_BYTE *)(a1 + 19);
  a2[9] = *(_WORD *)(a1 + 18);
  a2[10] = BYTE1(*(_DWORD *)(a1 + 16));
  a2[11] = *(_DWORD *)(a1 + 16);
  a2[12] = *(_BYTE *)(a1 + 23);
  a2[13] = *(_WORD *)(a1 + 22);
  a2[14] = BYTE1(*(_DWORD *)(a1 + 20));
  a2[15] = *(_DWORD *)(a1 + 20);
  a2[16] = *(_BYTE *)(a1 + 27);
  a2[17] = *(_WORD *)(a1 + 26);
  a2[18] = BYTE1(*(_DWORD *)(a1 + 24));
  a2[19] = *(_DWORD *)(a1 + 24);
  a2[20] = *(_BYTE *)(a1 + 31);
  a2[21] = *(_WORD *)(a1 + 30);
  a2[22] = BYTE1(*(_DWORD *)(a1 + 28));
  a2[23] = *(_DWORD *)(a1 + 28);
  a2[24] = *(_BYTE *)(a1 + 35);
  a2[25] = *(_WORD *)(a1 + 34);
  a2[26] = BYTE1(*(_DWORD *)(a1 + 32));
  a2[27] = *(_DWORD *)(a1 + 32);
  a2[28] = *(_BYTE *)(a1 + 39);
  a2[29] = *(_WORD *)(a1 + 38);
  a2[30] = BYTE1(*(_DWORD *)(a1 + 36));
  a2[31] = *(_DWORD *)(a1 + 36);
  return result;
}
// 9B4B4: using guessed type unsigned int dword_9B4B4[16];

//----- (000300CC) --------------------------------------------------------
int *__fastcall sub_300CC(unsigned int *a1, signed int a2, _BYTE *a3)
{
  int v5[59]; // [sp+0h] [bp-ECh] BYREF

  v5[2] = 1779033703;
  v5[4] = 1013904242;
  v5[5] = -1521486534;
  v5[6] = 1359893119;
  v5[7] = -1694144372;
  v5[3] = -1150833019;
  v5[8] = 528734635;
  v5[9] = 1541459225;
  v5[0] = 0;
  v5[1] = 0;
  if ( a2 > 0 )
    sub_2FE40(v5, a1, a2);
  return sub_2FF18((int)v5, a3);
}

//----- (00030174) --------------------------------------------------------
int __fastcall sub_30174(char *a1, size_t a2, int a3)
{
  int v6; // r0
  int *v8; // r0

  v6 = sub_509B0();
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      v8 = sub_4FED0();
      snprintf(a1, a2, "%s:%s", "searchfailed", (const char *)v8);
    }
    else
    {
      snprintf(a1, a2, "searching");
    }
    return 0;
  }
  else
  {
    snprintf(a1, a2, "%d", a3);
    return 0;
  }
}

//----- (00030210) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall sub_30210(
        const char *a1,
        int a2,
        size_t a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  double v13; // d0
  char *v15; // r7
  int v18; // r0
  int v19; // r0
  int v20; // r0
  const char *v21; // lr
  int v22; // r0
  int v23; // r1
  int v24; // r2
  int v25; // r3
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  int v35; // r8
  int k; // r6
  int v37; // r0
  void *v38; // r0
  char *v39; // r4
  unsigned int *v40; // r3
  unsigned int v41; // t1
  char v42; // r2
  int v43; // r0
  int v44; // r0
  int v46; // r5
  const char *v47; // r12
  int v48; // r0
  int v49; // r1
  int v50; // r2
  int v51; // r3
  int *v52; // r12
  int v53; // r0
  int v54; // r1
  int v55; // r2
  unsigned int i; // r9
  int v57; // r0
  int v58; // r0
  int v59; // r0
  unsigned int v60; // r7
  const char *v61; // r0
  const char *v62; // r0
  int v63; // r10
  int j; // r5
  bool v65; // zf
  unsigned int v66; // r7
  int v67; // r0
  int v68; // r6
  char *v69; // r0
  int v70; // r7
  char *v71; // r0
  int v72; // r9
  char *v73; // r0
  int v74; // r0
  int v75; // r10
  char *v76; // r0
  int v77; // r10
  char *v78; // r0
  int v79; // r7
  char *v80; // r0
  int v81; // r0
  int v82; // r9
  int v83; // r0
  int v84; // r0
  int v85; // r7
  int v86; // r8
  int v87; // r12
  char *v88; // r0
  int v89; // r7
  char *v90; // r0
  int v91; // r0
  int v92; // r9
  size_t v93; // r1
  char *v94; // r0
  int v95; // r7
  int v96; // [sp-24B4h] [bp-4940h]
  int v97; // [sp-24B4h] [bp-4940h]
  int v98; // [sp-247Ch] [bp-4908h]
  int v99; // [sp-247Ch] [bp-4908h]
  _WORD v100[32]; // [sp-246Ch] [bp-48F8h] BYREF
  _DWORD v101[256]; // [sp-242Ch] [bp-48B8h] BYREF
  unsigned int v102[2059]; // [sp-202Ch] [bp-44B8h] BYREF

  v15 = (char *)(a1 + 4);
  if ( !strncmp(a1 + 4, "/rate", 5u) )
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy((char *)v102, "cmd : get rate");
      sub_41DB8(7, (const char *)v102, 0);
    }
    v18 = sub_22EC0();
    sub_30174((char *)a2, a3, v18);
    goto LABEL_8;
  }
  if ( !strncmp(v15, "/clear_find_asic_fail_record", 0x1Cu) )
  {
    remove("/config/find_asic_counter");
    v21 = "clear find asic fail record success";
    do
    {
      a2 += 16;
      v22 = *(_DWORD *)v21;
      v23 = *((_DWORD *)v21 + 1);
      v24 = *((_DWORD *)v21 + 2);
      v25 = *((_DWORD *)v21 + 3);
      v21 += 16;
      *(_DWORD *)(a2 - 16) = v22;
      *(_DWORD *)(a2 - 12) = v23;
      *(_DWORD *)(a2 - 8) = v24;
      *(_DWORD *)(a2 - 4) = v25;
    }
    while ( v21 != "ess" );
    *(_DWORD *)a2 = *(_DWORD *)v21;
    goto LABEL_8;
  }
  if ( !strncmp(v15, "/ideal_rate", 0xBu) )
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy((char *)v102, "cmd : get ideal rate");
      sub_41DB8(7, (const char *)v102, 0);
    }
    v19 = sub_22C10();
    sub_30174((char *)a2, a3, v19);
    goto LABEL_8;
  }
  if ( !strncmp(v15, "/max_rate", 9u) )
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy((char *)v102, "cmd : get max rate");
      sub_41DB8(7, (const char *)v102, 0);
    }
    v20 = sub_22A64();
    sub_30174((char *)a2, a3, v20);
    goto LABEL_8;
  }
  if ( !strncmp(v15, "/miner_status", 0xDu) )
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy((char *)v102, "cmd : get miner status");
      sub_41DB8(7, (const char *)v102, 0);
    }
    goto LABEL_8;
  }
  if ( !strncmp(v15, "/board_type", 0xBu) )
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy((char *)v102, "cmd : get hash board type");
      sub_41DB8(7, (const char *)v102, 0);
    }
    snprintf((char *)a2, 0x20u, "%s", byte_4D41FC);
    goto LABEL_8;
  }
  if ( !strncmp(v15, "/productName", 0xCu) )
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy((char *)v102, "cmd : get miner type");
      sub_41DB8(7, (const char *)v102, 0);
    }
    snprintf((char *)a2, 0x100u, "%s", dest);
    goto LABEL_8;
  }
  if ( !strncmp(v15, "/miner_power", 0xCu) )
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy((char *)v102, "cmd : get miner power");
      sub_41DB8(7, (const char *)v102, 0);
    }
    if ( sub_226E8() )
    {
      v37 = sub_287A0();
      snprintf((char *)a2, 0x14u, "miner power:%d", v37);
    }
    else
    {
      strcpy((char *)a2, "no power supported");
    }
    goto LABEL_8;
  }
  if ( strncmp(v15, "/power_err_code", 0xFu) )
  {
    if ( !strncmp(v15, "/power_err_data", 0xFu) )
    {
      if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
      {
        strcpy((char *)v102, "cmd : get miner power err data");
        sub_41DB8(7, (const char *)v102, 0);
      }
      memset(v102, 0, 0x64u);
      sub_731A0(1, v102);
      v38 = (void *)a2;
      v39 = (char *)(a2 + 1);
      memset(v38, 0, 0xC8u);
      v40 = (_DWORD *)((char *)&v101[255] + 3);
      do
      {
        v41 = *((unsigned __int8 *)v40 + 1);
        v40 = (unsigned int *)((char *)v40 + 1);
        v42 = a0123456789abcd_0[v41 & 0xF];
        *(v39 - 1) = a0123456789abcd_0[v41 >> 4];
        *v39 = v42;
        v39 += 2;
      }
      while ( (unsigned int *)((char *)&v102[16] + 3) != v40 );
      goto LABEL_8;
    }
    if ( !strncmp(v15, "/power_reset_rc", 0xFu) )
    {
      if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
      {
        strcpy((char *)v102, "cmd : get miner power reset root cause");
        sub_41DB8(7, (const char *)v102, 0);
      }
      v43 = sub_731D8();
      snprintf((char *)a2, 0x28u, "power reset root cause:0x%08x", v43);
      goto LABEL_8;
    }
    if ( !strncmp(v15, "/power_uptime", 0xDu) )
    {
      if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
      {
        strcpy((char *)v102, "cmd : get miner power uptime");
        sub_41DB8(7, (const char *)v102, 0);
      }
      v44 = sub_731F0();
      snprintf((char *)a2, 0x28u, "power power_uptime:%.1f", (float)v44 / 10.0);
      goto LABEL_8;
    }
    if ( !strncmp(v15, "/power_fw_ver", 0xDu) )
    {
      v46 = sub_703BC();
      if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
      {
        snprintf((char *)v102, 0x2000u, "fw_ver:%d", v46);
        sub_41DB8(5, (const char *)v102, 0);
      }
      snprintf((char *)a2, 0x32u, "power firmware version:%d", v46);
    }
    else
    {
      if ( !strncmp(v15, "/get_sn", 7u) )
      {
        if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
        {
          strcpy((char *)v102, "cmd : get miner sn");
          sub_41DB8(7, (const char *)v102, 0);
        }
        if ( byte_C1CBC )
        {
          snprintf((char *)a2, 0x100u, "%s", &byte_C1CBC);
          goto LABEL_8;
        }
        v47 = "no miner sn stored on board";
LABEL_139:
        v48 = *(_DWORD *)v47;
        v49 = *((_DWORD *)v47 + 1);
        v50 = *((_DWORD *)v47 + 2);
        v51 = *((_DWORD *)v47 + 3);
        v52 = (int *)(v47 + 16);
        *(_DWORD *)a2 = v48;
        *(_DWORD *)(a2 + 4) = v49;
        *(_DWORD *)(a2 + 8) = v50;
        v53 = *v52;
        v54 = v52[1];
        v55 = v52[2];
        *(_DWORD *)(a2 + 12) = v51;
        *(_DWORD *)(a2 + 16) = v53;
        *(_DWORD *)(a2 + 20) = v54;
        *(_DWORD *)(a2 + 24) = v55;
        goto LABEL_8;
      }
      if ( !strncmp(v15, "/set_sn", 7u) )
      {
        if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
        {
          strcpy((char *)v102, "cmd : set miner sn, doesn't spport");
          sub_41DB8(5, (const char *)v102, 0);
        }
        snprintf((char *)a2, 0x14u, "doesn't support sn set in Release mode");
        goto LABEL_8;
      }
      if ( !strncmp(v15, "/get_water_permit", 0x11u) )
      {
        v101[0] = 0;
        if ( _isoc99_sscanf(v15, "/get_water_permit:%d", v101) == 1 )
        {
          if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
          {
            v57 = sub_48264();
            snprintf((char *)v102, 0x2000u, "get_water_permit:%d", v57);
            sub_41DB8(5, (const char *)v102, 0);
          }
          v58 = sub_48264();
          snprintf((char *)a2, 0x32u, "get_water_permit:%d", v58);
        }
        else
        {
          if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
          {
            strcpy((char *)v102, "get_water_permit failed");
            sub_41DB8(5, (const char *)v102, 0);
          }
          strcpy((char *)a2, "get_water_permit failed");
        }
      }
      else
      {
        if ( !strncmp(v15, "/miner_info", 0xBu) )
        {
          sub_2D120((void *)a2);
          goto LABEL_8;
        }
        if ( !strncmp(v15, "/freq_info", 0xAu) )
        {
          sub_2D490((void *)a2);
          goto LABEL_8;
        }
        if ( !strncmp(v15, "/power_sn", 9u) )
        {
          if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
          {
            strcpy((char *)v102, "cmd : get miner sn");
            sub_41DB8(7, (const char *)v102, 0);
          }
          if ( byte_4D4370 )
          {
            snprintf((char *)a2, 0x20u, "%s", &byte_4D4370);
            goto LABEL_8;
          }
          v47 = "no power sn stored on board";
          goto LABEL_139;
        }
        if ( !strncmp(v15, "/readreg", 8u) )
        {
          LOWORD(v101[0]) = 45;
          if ( !strtok(v15, (const char *)v101) )
            goto LABEL_174;
          v76 = strtok(0, (const char *)v101);
          if ( !v76 )
            goto LABEL_174;
          v77 = strtol(v76, 0, 10);
          v78 = strtok(0, (const char *)v101);
          if ( !v78 )
            goto LABEL_174;
          v79 = strtol(v78, 0, 10);
          v80 = strtok(0, (const char *)v101);
          if ( !v80 )
            goto LABEL_174;
          v81 = strtol(v80, 0, 16);
          v82 = v81;
          if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
          {
            snprintf((char *)v102, 0x2000u, "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n", a1, v77, v79, v81);
            sub_41DB8(5, (const char *)v102, 0);
          }
          v83 = sub_27D8C();
          v84 = sub_3E42C(v82, v79 * v83, v77);
          snprintf((char *)a2, a3, "reg 0x%08x of asic %2d @ chain %2d, val = 0x%08x", v82, v79, v77, v84);
        }
        else if ( !strncmp(v15, "/readcorereg", 0xCu) )
        {
          v100[0] = 45;
          memset(v101, 0, sizeof(v101));
          if ( !strtok(v15, (const char *)v100) )
            goto LABEL_174;
          v69 = strtok(0, (const char *)v100);
          if ( !v69 )
            goto LABEL_174;
          v70 = strtol(v69, 0, 10);
          v71 = strtok(0, (const char *)v100);
          if ( !v71 )
            goto LABEL_174;
          v72 = strtol(v71, 0, 10);
          v73 = strtok(0, (const char *)v100);
          if ( !v73 )
            goto LABEL_174;
          v74 = strtol(v73, 0, 16);
          v75 = v74;
          if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
          {
            snprintf((char *)v102, 0x2000u, "recvBuf = %s, chain = %d, asic = %d, reg = 0x%x\n", a1, v70, v72, v74);
            sub_41DB8(5, (const char *)v102, 0);
          }
          if ( sub_3E690(v75, v72, v70, (int)v101) )
          {
            snprintf((char *)a2, a3, "500 server error");
          }
          else
          {
            v85 = 0;
            v86 = 0;
            v98 = sub_27D4C();
            while ( v86 < v98 )
            {
              v87 = v101[v86];
              v96 = v86++;
              v85 += snprintf(
                       (char *)(a2 + v85),
                       a3 - v85,
                       "asic\t%03d\tcore\t%03d\treg\t0x%02x\tval\t0x%08x\n",
                       v72,
                       v96,
                       v75,
                       v87);
            }
          }
        }
        else if ( !strncmp(v15, "/resetcore", 0xAu) )
        {
          LOWORD(v101[0]) = 45;
          if ( !strtok(v15, (const char *)v101) )
            goto LABEL_174;
          v88 = strtok(0, (const char *)v101);
          if ( !v88 )
            goto LABEL_174;
          v89 = strtol(v88, 0, 10);
          v90 = strtok(0, (const char *)v101);
          if ( !v90 )
            goto LABEL_174;
          v91 = strtol(v90, 0, 10);
          v92 = v91;
          if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
          {
            snprintf((char *)v102, 0x2000u, "recvBuf = %s, chain = %d, asic = %d\n", a1, v89, v91);
            sub_41DB8(5, (const char *)v102, 0);
          }
          if ( v92 == 255 )
            sub_4CA18(v89);
          else
            sub_4C08C(v89, v92);
          snprintf((char *)a2, a3, "reset chain %d asic %d core success!!!.", v89, v92);
        }
        else
        {
          if ( !strncmp(v15, "/nonce", 6u) )
          {
            for ( i = 0; i != 4; ++i )
            {
              if ( sub_27EC8(i) )
              {
                v63 = 0;
                memset(v102, 0, 0x100u);
                memset(v101, 0, 0x80u);
                snprintf((char *)v101, 0x80u, "\nchain[%d] nonce info:\n", i);
                strcat((char *)a2, (const char *)v101);
                while ( sub_28744() >= v63 )
                {
                  for ( j = 0; sub_28758() > j; ++j )
                  {
                    v65 = sub_28744() == v63;
                    v66 = v102[j];
                    if ( v65 )
                    {
                      memset(v100, 0, sizeof(v100));
                      sprintf((char *)v100, "[%02d]=%-10u ", j, v66);
                      strcat((char *)a2, (const char *)v100);
                    }
                    else
                    {
                      v67 = sub_2876C(v63, j);
                      v68 = sub_3F63C(i, v67 - 1);
                      memset(v100, 0, sizeof(v100));
                      sprintf((char *)v100, "%-15u ", v68);
                      strcat((char *)a2, (const char *)v100);
                      v102[j] = v68 + v66;
                    }
                  }
                  ++v63;
                  *(_WORD *)(a2 + strlen((const char *)a2)) = 10;
                }
              }
            }
            goto LABEL_8;
          }
          if ( strncmp(v15, "/adc", 4u) )
          {
            if ( !strncmp(v15, "/flush", 6u) )
            {
              sub_63ED8();
              goto LABEL_8;
            }
            if ( strncmp(v15, "/power", 6u) )
            {
              if ( !strncmp(v15, "/inlet_temp", 0xBu) )
              {
                if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
                {
                  strcpy((char *)v102, "cmd : get inlet_temp");
                  sub_41DB8(7, (const char *)v102, 0);
                }
                v59 = sub_18F28();
                snprintf((char *)a2, 4u, "%d", v59);
              }
              goto LABEL_8;
            }
            v102[0] = 0;
            if ( _isoc99_sscanf(v15, "/power-%d", v102) == 1 )
            {
              v60 = v102[0];
              if ( (int)v102[0] <= 3 )
              {
                sub_21B08(v102[0], 1);
                snprintf((char *)a2, a3, "chain %d power is %.2f", v60, v13);
                goto LABEL_8;
              }
            }
LABEL_174:
            snprintf((char *)a2, a3, "404 not found");
            goto LABEL_8;
          }
          v61 = (const char *)sub_27CEC();
          if ( !strcmp(v61, "HHB68502") )
            goto LABEL_179;
          v62 = (const char *)sub_27CEC();
          if ( !strcmp(v62, "HHB68501") )
            goto LABEL_179;
          v26 = (const char *)sub_27CEC();
          if ( !strcmp(v26, "HHB68701") )
            goto LABEL_179;
          v27 = (const char *)sub_27CEC();
          if ( !strcmp(v27, "HHB68704")
            || (v28 = (const char *)sub_27CEC(), !strcmp(v28, "HHB68703"))
            || (v29 = (const char *)sub_27CEC(), !strcmp(v29, "H6HB68702"))
            || (v30 = (const char *)sub_27CEC(), !strcmp(v30, "H1HB68601"))
            || (v31 = (const char *)sub_27CEC(), !strcmp(v31, "HHB68601"))
            || (v32 = (const char *)sub_27CEC(), !strcmp(v32, "HHB68602"))
            || (v33 = (const char *)sub_27CEC(), !strcmp(v33, "HHB56611"))
            || (v34 = (const char *)sub_27CEC(), !strcmp(v34, "HHB68503")) )
          {
LABEL_179:
            snprintf((char *)a2, a3, "Not Supported");
          }
          else
          {
            v35 = 0;
            for ( k = 0; k != 4; ++k )
            {
              if ( sub_27EC8(k) )
              {
                v93 = a3 - v35;
                v94 = (char *)(a2 + v35);
                v95 = 0;
                v35 += 23;
                snprintf(v94, v93, "\t\t\td0\td1\td2\td3\tsum\tavg\n");
                v99 = sub_27D1C();
                while ( v95 != v99 )
                {
                  sub_4D360();
                  sub_4D360();
                  sub_4D360();
                  sub_4D360();
                  sub_4D370();
                  sub_4D380();
                  v97 = v95++;
                  v35 += snprintf(
                           (char *)(a2 + v35),
                           a3 - v35,
                           "chain %2d asic %03d adc:\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n",
                           k,
                           v97,
                           v13,
                           v13,
                           v13,
                           v13,
                           v13,
                           v13);
                }
              }
            }
          }
        }
      }
    }
LABEL_8:
    __asm { POP             {R4-R11,PC} }
  }
  v101[0] = 0;
  if ( _isoc99_sscanf(v15, "/power_err_code:%d", v101) != 1 )
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy((char *)v102, "cmd : get miner power err code");
      sub_41DB8(7, (const char *)v102, 0);
    }
    JUMPOUT(0x30B14);
  }
  if ( !byte_4D4172 || !byte_6682BC && !byte_4D4171 && dword_BC5F4 <= 6 )
    JUMPOUT(0x30D68);
  return ((int (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))sub_30D40)(
           *(_DWORD *)"cmd : get miner power err code",
           *(_DWORD *)": get miner power err code",
           *(_DWORD *)"t miner power err code",
           *(_DWORD *)"ner power err code");
}
// 302F8: positive sp value 24B4 has been found
// 30B10: control flows out of bounds to 30B14
// 30CF0: control flows out of bounds to 30D68
// 314BC: variable 'v13' is possibly undefined
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 30D40: using guessed type int sub_30D40();
// 98278: using guessed type __int16 word_98278;
// BC5F4: using guessed type int dword_BC5F4;
// C1CBC: using guessed type char byte_C1CBC;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 6682BC: using guessed type char byte_6682BC;

//----- (00030D40) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_30D40(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r0
  char *v14; // r4
  const char *v15; // r5
  _DWORD *v16; // r12
  _DWORD *v17; // lr
  _DWORD *v18; // r12
  int v19; // r1
  int v20; // r2
  int v21; // r3

  *v16 = a1;
  v16[1] = a2;
  v16[2] = a3;
  v16[3] = a4;
  v18 = v16 + 4;
  v19 = v17[1];
  v20 = v17[2];
  v21 = v17[3];
  *v18 = *v17;
  v18[1] = v19;
  v18[2] = v20;
  v18 += 3;
  *(_WORD *)v18 = v21;
  *((_BYTE *)v18 + 2) = BYTE2(v21);
  sub_41DB8(7, v15, 0);
  v13 = sub_7315C(*((_DWORD *)v15 - 256) != 0, 1);
  snprintf(v14, 0x28u, "power error code:0x%08x", v13);
  __asm { POP             {R4-R11,PC} }
}
// 302F8: positive sp value 24B4 has been found
// 30D40: variable 'v16' is possibly undefined
// 30D44: variable 'v17' is possibly undefined
// 30D64: variable 'v15' is possibly undefined
// 30B2C: variable 'v14' is possibly undefined

//----- (00031B08) --------------------------------------------------------
int __fastcall sub_31B08(char *a1)
{
  int v1; // r7
  int v2; // r5
  int v3; // r4
  char *v5; // r8
  int v6; // r0
  char *v7; // r0
  int v9; // r5
  int v10; // r5
  int v11; // r5
  int v12; // [sp+4h] [bp-8h]

  v1 = 0;
  v2 = 0;
  v3 = 0;
  v5 = a1;
  v12 = sub_2242C();
  do
  {
    v6 = v3++;
    if ( sub_27EC8(v6) )
    {
      v9 = sprintf(v5, "chain%d_voltage=%d;", v3, v12) + v2;
      ++v1;
      v10 = v9 + sprintf(&a1[v9], "chain%d_voladded=%d;", v3, 0);
      v11 = v10 + sprintf(&a1[v10], "chain%d_basefreq=%d;", v3, 300);
      v2 = v11 + sprintf(&a1[v11], "chain%d_badcore=%d;", v3, 0);
      v5 = &a1[v2];
    }
  }
  while ( v3 != 4 );
  v7 = &a1[v2 + sprintf(v5, "chainnum=%d;", v1)];
  return sprintf(v7, "version=%s;", byte_C2FF8);
}

//----- (00031C08) --------------------------------------------------------
_BYTE *__fastcall sub_31C08(_BYTE *result, int a2, int a3)
{
  int v3; // r1
  unsigned int v4; // t1

  if ( a2 )
  {
    v3 = a3 + 2 * a2;
    --result;
    do
    {
      v4 = (unsigned __int8)*++result;
      a3 += 2;
      *(_BYTE *)(a3 - 2) = a0123456789abcd_0[v4 >> 4];
      *(_BYTE *)(a3 - 1) = a0123456789abcd_0[*result & 0xF];
    }
    while ( v3 != a3 );
  }
  return result;
}

//----- (00031C4C) --------------------------------------------------------
void *sub_31C4C()
{
  void *result; // r0

  result = memcpy(&byte_C1CBC, &byte_C32F8, 0x100u);
  off_C1DBC = sub_30210;
  return result;
}
// C1CBC: using guessed type char byte_C1CBC;
// C1DBC: using guessed type _UNKNOWN *off_C1DBC;

//----- (00031C80) --------------------------------------------------------
ssize_t __fastcall sub_31C80(char **a1, int fd, __int64 *a3)
{
  char *v4; // r1
  char *v7; // r2
  __int64 v8; // r0
  char *v9; // r12
  ssize_t v10; // r5
  __int64 v11; // r2
  bool v12; // cc
  char *v13; // r0
  ssize_t result; // r0
  char *v15; // r0
  int v16; // r3

  v4 = *a1;
  if ( *a1 )
  {
    v7 = a1[4];
  }
  else
  {
    *a3 += 1024;
    v15 = (char *)calloc(1u, 0x400u);
    v4 = v15;
    if ( v15 )
      v16 = 1024;
    *a1 = v15;
    if ( !v15 )
      _assert_fail("stream->buf != NULL", "miner_api/httpserver.h", 0x2DBu, "hs_stream_read_socket");
    v7 = (char *)v16;
    a1[4] = (char *)v16;
  }
  while ( 1 )
  {
    v10 = read(fd, &a1[5][(_DWORD)v4], v7 - a1[5]);
    v9 = a1[5];
    if ( v10 <= 0 )
      break;
    v8 = *((_QWORD *)a1 + 1);
    v9 += v10;
    v7 = a1[4];
    a1[5] = v9;
    *((_QWORD *)a1 + 1) = v8 + v10;
    if ( v9 == v7 )
    {
      if ( v7 == &byte_7FFFFF[1] )
        goto LABEL_17;
      goto LABEL_9;
    }
    if ( (int)v7 > (int)byte_7FFFFF )
      goto LABEL_17;
LABEL_5:
    v4 = *a1;
  }
  if ( v9 != a1[4] || v9 == &byte_7FFFFF[1] )
    goto LABEL_17;
LABEL_9:
  v11 = *a3;
  *a3 -= (int)v9;
  LODWORD(v11) = 2 * (_DWORD)a1[4];
  v12 = (int)v11 <= 0x800000;
  if ( (int)v11 > 0x800000 )
  {
    a1[4] = byte_7FFFFF + 1;
    LODWORD(v11) = 0x800000;
  }
  else
  {
    a1[4] = (char *)v11;
    v11 = (int)v11;
  }
  if ( !v12 )
    HIDWORD(v11) = 0;
  *a3 += v11;
  v13 = (char *)realloc(*a1, (size_t)a1[4]);
  *a1 = v13;
  if ( !v13 )
    _assert_fail("stream->buf != NULL", "miner_api/httpserver.h", 0x2F4u, "hs_stream_read_socket");
  if ( v10 > 0 )
  {
    v7 = a1[4];
    if ( (int)v7 <= (int)byte_7FFFFF )
      goto LABEL_5;
  }
LABEL_17:
  result = v10;
  if ( v10 )
    return 1;
  return result;
}
// 31DC4: variable 'v16' is possibly undefined

//----- (00031E1C) --------------------------------------------------------
ssize_t __fastcall sub_31E1C(int a1, int a2, __int64 *a3)
{
  if ( *(_DWORD *)(a1 + 24) < *(_DWORD *)(a1 + 20) )
    return 1;
  else
    return sub_31C80((char **)a1, a2, a3);
}

//----- (00031E38) --------------------------------------------------------
int __fastcall sub_31E38(int a1, _BYTE *a2)
{
  int v2; // r2
  int v3; // r12
  int v4; // r3
  int result; // r0

  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(a1 + 20);
  v4 = *(_BYTE *)(a1 + 44) & 0xFE;
  *(_BYTE *)(a1 + 44) = v4;
  if ( v2 >= v3 )
  {
    result = 0;
  }
  else
  {
    v4 = *(_DWORD *)a1;
    result = 1;
  }
  if ( v2 < v3 )
    *a2 = *(_BYTE *)(v4 + v2);
  return result;
}

//----- (00031E68) --------------------------------------------------------
int __fastcall sub_31E68(int result)
{
  int v1; // r1
  int v2; // r2
  int v3; // r12

  if ( (*(_BYTE *)(result + 44) & 1) == 0 )
  {
    v1 = *(_DWORD *)(result + 40);
    v2 = *(_DWORD *)(result + 24);
    v3 = *(_DWORD *)(result + 36);
    *(_BYTE *)(result + 44) |= 1u;
    if ( v1 )
      v1 = v3 + 1;
    *(_DWORD *)(result + 24) = v2 + 1;
    *(_DWORD *)(result + 36) = v1;
  }
  return result;
}

//----- (00031EA0) --------------------------------------------------------
_DWORD *__fastcall sub_31EA0(_DWORD *result, int a2)
{
  int v2; // r3

  v2 = result[6];
  result[10] = a2;
  result[8] = v2;
  return result;
}

//----- (00031EB0) --------------------------------------------------------
int __fastcall sub_31EB0(int a1, int a2)
{
  int v2; // r12
  int v3; // r3
  int v4; // r2

  v2 = *(_DWORD *)(a1 + 20);
  v3 = a2 + *(_DWORD *)(a1 + 24);
  *(_BYTE *)(a1 + 44) |= 1u;
  if ( v3 > v2 )
    return 0;
  v4 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 24) = v3;
  if ( v4 )
    v4 = *(_DWORD *)(a1 + 36) + a2;
  *(_DWORD *)(a1 + 36) = v4;
  return 1;
}

//----- (00031EF8) --------------------------------------------------------
int __fastcall sub_31EF8(int a1)
{
  int v2; // r1
  char v3; // r2
  int v4; // r12
  int v5; // r0
  int v6; // lr
  int result; // r0

  v2 = *(_DWORD *)(a1 + 40);
  v3 = *(_BYTE *)(a1 + 44);
  v4 = *(_DWORD *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 24);
  v6 = *(_DWORD *)(a1 + 36);
  *(_BYTE *)(a1 + 44) = v3 | 1;
  result = v4 - v5;
  *(_DWORD *)(a1 + 24) = v4;
  if ( v2 )
    v2 = v6 + result;
  *(_DWORD *)(a1 + 36) = v2;
  return result;
}

//----- (00031F34) --------------------------------------------------------
int __fastcall sub_31F34(int result)
{
  *(_DWORD *)(result + 28) = *(_DWORD *)(result + 24);
  return result;
}

//----- (00031F40) --------------------------------------------------------
_DWORD *__fastcall sub_31F40(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r2
  int v5; // r0
  int v6; // r1
  int v7; // r2

  v2 = a2 + 8;
  v5 = a2[8];
  v6 = a2[9];
  v7 = v2[2];
  a2[8] = 0;
  a2[9] = 0;
  *a1 = v5;
  a1[1] = v6;
  a1[2] = v7;
  a2[10] = 0;
  return a1;
}

//----- (00031F70) --------------------------------------------------------
_DWORD *__fastcall sub_31F70(_DWORD *a1, int a2)
{
  int *v2; // r1
  int v4; // r0
  int v5; // r1
  int v6; // r2
  _DWORD *v7; // t0

  v2 = (int *)(a2 + 32);
  v4 = *v2;
  v7 = v2 + 1;
  v5 = v2[1];
  v6 = v7[1];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  return a1;
}

//----- (00031F88) --------------------------------------------------------
bool __fastcall sub_31F88(int a1, __int64 a2)
{
  return 8388609 - *(_DWORD *)(a1 + 24) >= a2;
}

//----- (00031FAC) --------------------------------------------------------
_DWORD *__fastcall sub_31FAC(_DWORD *result)
{
  int v1; // r2
  int v2; // r12
  _DWORD *v3; // r4
  int v4; // r3
  int v5; // r3

  v1 = result[8];
  v2 = result[7];
  if ( v1 != v2 )
  {
    v3 = result;
    v4 = result[9];
    if ( v4 > 0 )
    {
      result = memcpy((void *)(*result + v2), (const void *)(*result + v1), result[5] - v1);
      v2 = v3[7];
      v4 = v3[9];
    }
    v5 = v2 + v4;
    v3[8] = v2;
    v3[6] = v5;
    v3[5] = v5;
  }
  return result;
}

//----- (00032008) --------------------------------------------------------
int __fastcall sub_32008(int result, int a2)
{
  *(_BYTE *)(result + 21) = *(_DWORD *)&aHsStreamReadSo[24 * *(char *)(result + 21) + 24 + 4 * a2];
  return result;
}

//----- (0003202C) --------------------------------------------------------
int __fastcall sub_3202C(int a1, __int64 *a2, int a3, int a4, char a5, char a6)
{
  __int64 v6; // r6
  int v7; // r5
  int v9; // r4
  int v12; // r2
  int v13; // r3
  int v14; // r2
  int v15; // r0
  int v17; // r3
  __int64 v18; // r0
  int v19; // r2
  __int64 v20; // r0
  int v21; // r2
  int v22; // r3
  int v23; // r3
  int v24; // r2
  int v25; // r8
  char v26; // r1
  char v27; // r1
  int v28; // r11
  int v29; // r3
  int v30; // r1
  int v31; // r0
  __int64 v32; // r0
  int v33; // r2
  unsigned int v34; // r0
  int v35; // r12
  int v36; // r1
  __int64 v37; // r8
  __int64 v38; // r0
  int v39; // r3
  unsigned int v40; // r3
  int v41; // r2
  _BOOL4 v42; // r8
  __int64 v43; // r0
  int v44; // r2
  int v45; // r3
  unsigned int v46; // r0
  int v47; // r2
  __int16 v48; // r3

  v7 = a5;
  v9 = a1;
  if ( a5 == 14 )
  {
    a1 = *(_DWORD *)(a3 + 24);
    if ( a6 == 14 )
    {
      v6 = 0;
      v7 = 0;
    }
    *(_DWORD *)(a3 + 28) = a1;
    if ( a6 == 14 )
    {
LABEL_54:
      v38 = *a2;
      v39 = *((char *)a2 + 21);
      if ( v39 == 6 )
      {
        if ( 8388609 - *(_DWORD *)(a3 + 24) < v38 )
        {
          v7 = 8;
          *((_BYTE *)a2 + 21) = 13;
          goto LABEL_25;
        }
        *((_BYTE *)a2 + 21) = 15;
        if ( v38 )
          goto LABEL_25;
      }
      else
      {
        v40 = (unsigned __int8)(v39 - 7);
        v41 = aHsStreamReadSo[24 * *((char *)a2 + 21) + 40];
        v42 = v41 == 15 && *a2 == 0;
        if ( v40 <= 1 )
          v7 = 8;
        *((_BYTE *)a2 + 21) = v41;
        if ( !v42 )
        {
          if ( v41 == 16 )
            v7 = 7;
          goto LABEL_25;
        }
      }
      v7 = 7;
      *((_BYTE *)a2 + 21) = 16;
      goto LABEL_25;
    }
    v12 = *(_DWORD *)&aHsStreamReadSo[4 * a6 + 432];
    if ( !v12 )
    {
      if ( a6 != 8 )
        goto LABEL_10;
      goto LABEL_31;
    }
    goto LABEL_6;
  }
  if ( a5 == a6 )
  {
    v7 = 0;
    v6 = 0;
    goto LABEL_13;
  }
  v12 = *(_DWORD *)&aHsStreamReadSo[4 * a6 + 432];
  if ( v12 )
  {
    a1 = *(_DWORD *)(a3 + 24);
LABEL_6:
    *(_DWORD *)(a3 + 32) = a1;
    *(_DWORD *)(a3 + 40) = v12;
  }
  if ( v7 == 16 )
  {
    a1 = 1;
    *((_BYTE *)a2 + 21) = *(_DWORD *)&aHsStreamReadSo[24 * *((char *)a2 + 21) + 28];
  }
  if ( a6 != 8 )
  {
LABEL_10:
    if ( a6 == 9 )
    {
      a1 = 0;
      *((_BYTE *)a2 + 21) = *(_DWORD *)&aHsStreamReadSo[24 * *((char *)a2 + 21) + 32];
      v6 = *(_QWORD *)(a3 + 32);
      v7 = *(_DWORD *)(a3 + 40);
      *(_DWORD *)(a3 + 32) = 0;
      *(_DWORD *)(a3 + 36) = 0;
      *(_DWORD *)(a3 + 40) = 0;
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_31:
  v17 = (__int16)(*((_WORD *)a2 + 9) + 1);
  *((_WORD *)a2 + 9) = v17;
  if ( v17 > 127 )
  {
    v7 = 11;
    v6 = 0;
    goto LABEL_12;
  }
LABEL_11:
  v7 = 0;
  v6 = 0;
LABEL_12:
  *((_WORD *)a2 + 8) = 0;
LABEL_13:
  LOWORD(v13) = a6 - 2;
  switch ( a6 )
  {
    case 2:
    case 4:
      v18 = *(_QWORD *)(a3 + 32);
      v19 = *(_DWORD *)(a3 + 40);
      *(_DWORD *)(a3 + 32) = 0;
      *(_DWORD *)(a3 + 36) = 0;
      *(_DWORD *)(a3 + 40) = 0;
      v6 = v18;
      v7 = v19;
      break;
    case 6:
    case 11:
      *((_BYTE *)a2 + 21) = *(_DWORD *)&aHsStreamReadSo[24 * *((char *)a2 + 21) + 36];
      v20 = *(_QWORD *)(a3 + 32);
      v21 = *(_DWORD *)(a3 + 40);
      *(_DWORD *)(a3 + 32) = 0;
      *(_DWORD *)(a3 + 36) = 0;
      *(_DWORD *)(a3 + 40) = 0;
      v6 = v20;
      v7 = v21;
      break;
    case 8:
      v14 = *((__int16 *)a2 + 8);
      if ( v14 > 16 )
        a1 = 0;
      else
        LOWORD(v13) = -15052;
      if ( v14 <= 16 )
      {
        HIWORD(v13) = 9;
        a1 = *(unsigned __int8 *)(v13 + v14);
      }
      if ( (unsigned int)(a4 - 65) <= 0x19 )
        a4 = (unsigned __int8)(a4 + 32);
      if ( a1 == a4 )
      {
        if ( v14 > 13 )
          goto LABEL_24;
      }
      else
      {
        v15 = aHsStreamReadSo[24 * *((char *)a2 + 21) + 28];
        *((_BYTE *)a2 + 21) = v15;
        if ( v14 > 13 )
        {
LABEL_23:
          *((_BYTE *)a2 + 21) = *(_DWORD *)&aHsStreamReadSo[24 * v15 + 24];
          goto LABEL_24;
        }
      }
      if ( (unsigned __int8)aContentLength[v14] != a4 )
      {
        v15 = *((char *)a2 + 21);
        goto LABEL_23;
      }
LABEL_24:
      *((_WORD *)a2 + 8) = v14 + 1;
      break;
    case 10:
      v22 = *((char *)a2 + 21);
      if ( v22 == 5 )
      {
        v45 = *((__int16 *)a2 + 8);
        v46 = a4 - 65;
        if ( v45 > 6 )
          v47 = 0;
        else
          v47 = 50520;
        if ( v45 <= 6 )
        {
          HIWORD(v47) = 9;
          v47 = *(unsigned __int8 *)(v47 + v45);
        }
        if ( v46 <= 0x19 )
          a4 += 32;
        v48 = v45 + 1;
        if ( v46 <= 0x19 )
          a4 = (unsigned __int8)a4;
        *((_WORD *)a2 + 8) = v48;
        if ( v47 != a4 )
          *((_BYTE *)a2 + 21) = 0;
      }
      else if ( v22 == 4 )
      {
        *a2 = 10 * *a2 + a4 - 48;
      }
      break;
    case 14:
      goto LABEL_54;
    case 15:
    case 17:
      v23 = *((char *)a2 + 21);
      v24 = *(_DWORD *)(a3 + 24);
      v25 = *(_DWORD *)(a3 + 20);
      v26 = *(_BYTE *)(a3 + 44);
      if ( v23 == 13 )
      {
        *(_DWORD *)(a3 + 32) = v24;
        *(_DWORD *)(a3 + 40) = 6;
        a1 = 6;
      }
      v27 = v26 | 1;
      if ( v23 != 13 )
        a1 = *(_DWORD *)(a3 + 40);
      v28 = *(_DWORD *)(a3 + 36);
      v29 = *(_DWORD *)a2 - *((_DWORD *)a2 + 2);
      *(_BYTE *)(a3 + 44) = v27;
      if ( v29 + v24 <= v25 )
      {
        if ( a1 )
          a1 = v29 + v28;
        *(_DWORD *)(a3 + 36) = a1;
        *(_DWORD *)(a3 + 24) = v29 + v24;
        v43 = *(_QWORD *)(a3 + 32);
        v44 = *(_DWORD *)(a3 + 40);
        *(_DWORD *)(a3 + 32) = 0;
        *(_DWORD *)(a3 + 36) = 0;
        *(_DWORD *)(a3 + 40) = 0;
        v6 = v43;
        v7 = v44;
        *((_BYTE *)a2 + 21) = *(_DWORD *)&aHsStreamReadSo[24 * *((char *)a2 + 21) + 24];
        if ( a6 == 17 )
          *((_BYTE *)a2 + 20) = 21;
        *a2 = 0;
        a2[1] = 0;
      }
      else
      {
        v30 = v25 - v24;
        if ( a1 )
          a1 = v30 + v28;
        *(_DWORD *)(a3 + 24) = v25;
        *(_DWORD *)(a3 + 36) = a1;
        v31 = *((char *)a2 + 21);
        a2[1] += v30;
        if ( v31 == 13 )
        {
          v32 = *(_QWORD *)(a3 + 32);
          v33 = *(_DWORD *)(a3 + 40);
          *(_DWORD *)(a3 + 32) = 0;
          *(_DWORD *)(a3 + 36) = 0;
          *(_DWORD *)(a3 + 40) = 0;
          v6 = v32;
          v7 = v33;
          sub_31FAC((_DWORD *)a3);
        }
      }
      break;
    case 16:
      if ( a4 == 48 )
        goto LABEL_88;
      *((_BYTE *)a2 + 21) = *(_DWORD *)&aHsStreamReadSo[24 * *((char *)a2 + 21) + 24];
      if ( (unsigned int)(a4 - 65) <= 5 )
      {
        v34 = *(_DWORD *)a2;
        v35 = *((_DWORD *)a2 + 1);
        v36 = a4 - 55;
LABEL_52:
        LODWORD(v37) = 16 * v34;
        HIDWORD(v37) = (16 * v35) | (v34 >> 28);
        *a2 = v37 + v36;
        break;
      }
      if ( (unsigned int)(a4 - 97) <= 5 )
      {
        v34 = *(_DWORD *)a2;
        v35 = *((_DWORD *)a2 + 1);
        v36 = a4 - 87;
        goto LABEL_52;
      }
LABEL_88:
      v36 = a4 - 48;
      if ( (unsigned __int8)v36 <= 9u )
      {
        v34 = *(_DWORD *)a2;
        v35 = *((_DWORD *)a2 + 1);
        goto LABEL_52;
      }
      break;
    case 23:
      *((_BYTE *)a2 + 21) = *(_DWORD *)&aHsStreamReadSo[24 * *((char *)a2 + 21) + 32];
      break;
    case 24:
      v7 = 11;
      break;
    default:
      break;
  }
LABEL_25:
  *(_QWORD *)v9 = v6;
  *(_DWORD *)(v9 + 8) = v7;
  return v9;
}
// 320E0: control flows out of bounds to 320E4
// 321B8: variable 'v6' is possibly undefined

//----- (00032630) --------------------------------------------------------
_DWORD *__fastcall sub_32630(_DWORD *a1, int a2)
{
  int v2; // r2
  int v4; // r0

  v2 = *(char *)(a2 + 21);
  if ( v2 == 14 )
  {
    v4 = 6;
    *(_BYTE *)(a2 + 21) = 16;
  }
  else if ( v2 == 16 )
  {
    v4 = 9;
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 0;
  }
  else
  {
    v4 = 0;
  }
  a1[2] = v4;
  *a1 = 0;
  a1[1] = 0;
  return a1;
}

//----- (00032698) --------------------------------------------------------
_DWORD *__fastcall sub_32698(_DWORD *a1, int a2, int a3)
{
  int v4; // r1
  int v5; // r0
  int v6; // r5
  int v7; // r2
  int v8; // r2
  int v9; // r3
  int v10; // lr
  int v11; // r12
  bool v12; // zf
  int v13; // r1
  int v14; // r2
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v19; // r2
  _BOOL4 v20; // r3
  int v21; // r1
  int v22; // r2
  char v23; // [sp+0h] [bp-10h]
  _DWORD v25[2]; // [sp+10h] [bp+0h] BYREF
  int v26; // [sp+18h] [bp+8h]
  _DWORD v27[2]; // [sp+1Ch] [bp+Ch] BYREF
  int v28; // [sp+24h] [bp+14h]

  sub_32630(v25, a2);
  if ( v26 )
  {
LABEL_22:
    v21 = v25[1];
    v22 = v26;
    *a1 = v25[0];
    a1[1] = v21;
    a1[2] = v22;
    return a1;
  }
  v5 = *(_DWORD *)(a3 + 24);
  v6 = v4;
  v7 = *(_DWORD *)(a3 + 20);
  *(_BYTE *)(a3 + 44) &= ~1u;
  if ( v5 >= v7 )
  {
LABEL_15:
    if ( *(_BYTE *)(v6 + 20) == 17 )
      sub_31FAC((_DWORD *)a3);
    sub_32630(v25, v6);
    v19 = v26;
    v20 = (unsigned int)(*(_DWORD *)(a3 + 40) - 6) > 1;
    if ( *(int *)(a3 + 36) <= 0x2000 )
      v20 = 0;
    if ( v20 )
      v19 = 11;
    v26 = v19;
    goto LABEL_22;
  }
  while ( 1 )
  {
    v9 = *(unsigned __int8 *)(*(_DWORD *)a3 + v5);
    v23 = *(_BYTE *)(v6 + 20);
    v10 = *(__int16 *)(v6 + 20);
    v11 = *(_DWORD *)&aHsStreamReadSo[48 * v23 + 528 + 4 * *(_DWORD *)&aHsStreamReadSo[4 * v9 + 1680]];
    v12 = v10 == 2318;
    if ( v10 == 2318 )
      v12 = v11 == 15;
    if ( v12 )
      LOBYTE(v11) = 16;
    *(_BYTE *)(v6 + 20) = v11;
    sub_3202C((int)v27, (__int64 *)v6, a3, v9, v23, v11);
    if ( (*(_BYTE *)(a3 + 44) & 1) == 0 )
    {
      v13 = *(_DWORD *)(a3 + 40);
      v14 = *(_DWORD *)(a3 + 24);
      v15 = *(_DWORD *)(a3 + 36);
      *(_BYTE *)(a3 + 44) |= 1u;
      if ( v13 )
        v13 = v15 + 1;
      *(_DWORD *)(a3 + 24) = v14 + 1;
      *(_DWORD *)(a3 + 36) = v13;
    }
    if ( v28 )
      break;
    v5 = *(_DWORD *)(a3 + 24);
    v8 = *(_DWORD *)(a3 + 20);
    *(_BYTE *)(a3 + 44) &= ~1u;
    if ( v5 >= v8 )
      goto LABEL_15;
  }
  v16 = v27[1];
  v17 = v28;
  *a1 = v27[0];
  a1[1] = v16;
  a1[2] = v17;
  return a1;
}
// 326C4: variable 'v4' is possibly undefined

//----- (00032828) --------------------------------------------------------
int __fastcall sub_32828(void **a1, int a2, int a3, int a4)
{
  void *v5; // r12
  char *v6; // r3
  char *v8; // r12
  void *v9; // r0

  v5 = a1[2];
  v6 = (char *)*a1;
  if ( v5 == a1[1] )
  {
    v9 = *a1;
    a1[1] = (void *)(2 * (_DWORD)v5);
    v6 = (char *)realloc(v9, 24 * (_DWORD)v5);
    *a1 = v6;
    if ( !v6 )
      _assert_fail("dyn->buf != NULL", "miner_api/httpserver.h", 0x3EBu, "http_token_dyn_push");
    v5 = a1[2];
  }
  v8 = &v6[12 * (_DWORD)v5];
  *(_DWORD *)v8 = a2;
  *((_DWORD *)v8 + 1) = a3;
  *((_DWORD *)v8 + 2) = a4;
  a1[2] = (char *)a1[2] + 1;
  return a2;
}

//----- (000328BC) --------------------------------------------------------
void *__fastcall sub_328BC(_DWORD *a1, int a2)
{
  void *result; // r0

  result = malloc(12 * a2);
  *a1 = result;
  if ( !result )
    _assert_fail("dyn->buf != NULL", "miner_api/httpserver.h", 0x3F3u, "http_token_dyn_init");
  a1[1] = a2;
  a1[2] = 0;
  return result;
}

//----- (00032910) --------------------------------------------------------
int __fastcall sub_32910(int fd, struct sockaddr *addr, char *cp, unsigned int a4)
{
  int result; // r0

  addr->sa_family = 2;
  if ( cp )
    *(_DWORD *)&addr->sa_data[2] = inet_addr(cp);
  else
    *(_DWORD *)&addr->sa_data[2] = 0;
  *(_WORD *)addr->sa_data = __rev16(a4);
  result = bind(fd, addr, 0x10u);
  if ( result < 0 )
    exit(1);
  return result;
}

//----- (00032968) --------------------------------------------------------
bool __fastcall sub_32968(_DWORD *a1)
{
  ssize_t v2; // r0

  v2 = write(a1[25], (const void *)(a1[6] + a1[8]), a1[11] - a1[8]);
  if ( v2 > 0 )
    *((_QWORD *)a1 + 4) += v2;
  return *_errno_location() != 32;
}

//----- (000329B8) --------------------------------------------------------
_DWORD *__fastcall sub_329B8(_DWORD *result)
{
  void *v1; // r3
  _DWORD *v2; // r4

  v1 = (void *)result[6];
  if ( v1 )
  {
    v2 = result;
    free(v1);
    *(_QWORD *)(v2[27] + 8) -= (int)v2[10];
    v2[6] = 0;
    return 0;
  }
  return result;
}

//----- (000329F8) --------------------------------------------------------
void *__fastcall sub_329F8(_DWORD *a1)
{
  _DWORD *v2; // r0
  void *v3; // r0

  v2 = a1 + 6;
  *((_BYTE *)v2 + 100) = 8;
  v2[12] = 0;
  a1[19] = 0;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = 0;
  a1[23] = 0;
  memset(v2, 0, 0x30u);
  v3 = (void *)a1[28];
  if ( v3 )
  {
    free(v3);
    a1[28] = 0;
  }
  return sub_328BC(a1 + 28, 32);
}

//----- (00032A58) --------------------------------------------------------
int __fastcall sub_32A58(int result, int a2)
{
  *(_DWORD *)(result + 104) = a2;
  return result;
}

//----- (00032A60) --------------------------------------------------------
int __fastcall sub_32A60(int a1)
{
  __int64 v2; // r0
  int v3; // r0
  int v4; // r2
  int v5; // r0
  struct epoll_event v7; // [sp+0h] [bp-10h] BYREF

  LODWORD(v2) = sub_32968((_DWORD *)a1);
  if ( (_DWORD)v2 )
  {
    v2 = *(_QWORD *)(a1 + 32);
    if ( v2 == *(_DWORD *)(a1 + 44) )
    {
      if ( (*(_BYTE *)(a1 + 124) & 0x20) != 0 )
      {
        *(_DWORD *)(a1 + 104) = 20;
        *(_DWORD *)(a1 + 96) = 2;
        sub_329B8((_DWORD *)a1);
        LODWORD(v2) = (*(int (__fastcall **)(int))(a1 + 12))(a1);
      }
      else if ( (*(_BYTE *)(a1 + 124) & 1) != 0 )
      {
        *(_DWORD *)(a1 + 96) = 0;
        LODWORD(v2) = sub_329B8((_DWORD *)a1);
        *(_DWORD *)(a1 + 104) = 120;
      }
      else
      {
        *(_BYTE *)(a1 + 124) |= 2u;
      }
    }
    else
    {
      v3 = *(_DWORD *)(a1 + 108);
      v4 = *(_DWORD *)(a1 + 100);
      v7.data.fd = a1;
      v5 = *(_DWORD *)(v3 + 24);
      v7.events = -2147483644;
      LODWORD(v2) = epoll_ctl(v5, 3, v4, &v7);
      *(_DWORD *)(a1 + 96) = 2;
      *(_DWORD *)(a1 + 104) = 20;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 124) |= 2u;
  }
  return v2;
}

//----- (00032B3C) --------------------------------------------------------
size_t __fastcall sub_32B3C(char *a1)
{
  struct tm *v2; // r0
  time_t timer; // [sp+4h] [bp-4h] BYREF

  time(&timer);
  v2 = gmtime(&timer);
  return strftime(a1, 0x20u, "%a, %d %b %Y %T GMT", v2);
}

//----- (00032B78) --------------------------------------------------------
size_t __fastcall sub_32B78(int a1)
{
  int v1; // r4
  int v3; // [sp+0h] [bp-8h] BYREF

  v1 = *(_DWORD *)(a1 + 8);
  read(*(_DWORD *)(v1 + 24), &v3, 8u);
  return sub_32B3C((char *)(v1 + 56));
}

//----- (00032BA4) --------------------------------------------------------
int __fastcall sub_32BA4(int result, int a2)
{
  *(_DWORD *)(result + 56) = a2;
  return result;
}

//----- (00032BAC) --------------------------------------------------------
int __fastcall sub_32BAC(int a1, char *a2)
{
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r2
  int v8; // r0
  int v10; // [sp+Ch] [bp-18h] BYREF
  struct epoll_event event; // [sp+10h] [bp-14h] BYREF

  signal(13, (__sighandler_t)1);
  v4 = socket(2, 1, 0);
  *(_DWORD *)(a1 + 16) = v4;
  v10 = 1;
  setsockopt(v4, 1, 15, &v10, 4u);
  sub_32910(*(_DWORD *)(a1 + 16), (struct sockaddr *)(a1 + 40), a2, *(_DWORD *)(a1 + 20));
  v5 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 32) = 16;
  v6 = fcntl(v5, 3, 0);
  fcntl(*(_DWORD *)(a1 + 16), 4, v6 | 0x800);
  listen(*(_DWORD *)(a1 + 16), 128);
  v7 = *(_DWORD *)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 24);
  event.data.fd = a1;
  event.events = -2147483647;
  return epoll_ctl(v8, 1, v7, &event);
}

//----- (00032C6C) --------------------------------------------------------
int __fastcall sub_32C6C(int a1, char *a2)
{
  sub_32BAC(a1, a2);
  return 0;
}

//----- (00032C7C) --------------------------------------------------------
int __fastcall sub_32C7C(int a1)
{
  sub_32BAC(a1, 0);
  return 0;
}

//----- (00032C90) --------------------------------------------------------
int __fastcall sub_32C90(int a1)
{
  return *(_DWORD *)(a1 + 24);
}

//----- (00032D20) --------------------------------------------------------
int __fastcall sub_32D20(int a1, unsigned __int8 a2)
{
  return *(_BYTE *)(a1 + 124) & a2;
}

//----- (00032F30) --------------------------------------------------------
int __fastcall sub_32F30(int a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v4; // r4
  int v5; // r12
  int v6; // lr
  int v7; // r4
  int v8; // r5
  int v9; // lr
  int v10; // r1
  int v11; // lr
  int v12; // r3
  int v13; // r1
  int v14; // r0
  int v15; // r3

  v4 = *(_DWORD *)(a1 + 112);
  v5 = 12 * *a4;
  v6 = v4 + v5;
  if ( *(_DWORD *)(v4 + v5 + 8) == 7 )
    return 0;
  v8 = *(_DWORD *)(v4 + v5);
  v7 = 1;
  v9 = *(_DWORD *)(v6 + 4);
  *a2 = *(_DWORD *)(a1 + 24) + v8;
  a2[1] = v9;
  v10 = *a4 + 1;
  *a4 = v10;
  v11 = *(_DWORD *)(a1 + 112);
  v12 = 12 * v10;
  v13 = *(_DWORD *)(a1 + 24);
  v14 = *(_DWORD *)(v11 + v12 + 4);
  v15 = v13 + *(_DWORD *)(v11 + v12);
  a3[1] = v14;
  *a3 = v15;
  return v7;
}

//----- (00032FAC) --------------------------------------------------------
int __fastcall sub_32FAC(_DWORD *a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  _DWORD *v4; // r12
  int v5; // r4
  int v6; // lr
  int v9; // r12
  int v10; // r5
  int v11; // r12
  int v12; // r4
  int v13; // r1
  int v14; // r12
  int v15; // r1
  _DWORD *v16; // r0
  int v17; // r3
  int v18; // r5

  if ( *a4 )
  {
    v9 = *a4 + 1;
    *a4 = v9;
    v10 = a1[28];
    v11 = 12 * v9;
    if ( *(_DWORD *)(v10 + v11 + 8) != 7 )
    {
      v12 = *(_DWORD *)(v10 + v11 + 4);
      *a2 = a1[6] + *(_DWORD *)(v10 + v11);
      a2[1] = v12;
      goto LABEL_10;
    }
    return 0;
  }
  if ( (int)a1[30] <= 0 )
    return 0;
  v4 = (_DWORD *)a1[28];
  if ( v4[2] != 4 )
  {
    v5 = 12;
    v6 = 1;
    do
    {
      *a4 = v6;
      if ( v6++ >= a1[30] )
        return 0;
      v4 = (_DWORD *)(a1[28] + v5);
      v5 += 12;
    }
    while ( v4[2] != 4 );
  }
  v18 = v4[1];
  *a2 = a1[6] + *v4;
  a2[1] = v18;
LABEL_10:
  v13 = *a4 + 1;
  v14 = 3 * v13;
  *a4 = v13;
  v15 = a1[6];
  v16 = (_DWORD *)(a1[28] + 4 * v14);
  v17 = v15 + *v16;
  a3[1] = v16[1];
  *a3 = v17;
  return 1;
}

//----- (000330B8) --------------------------------------------------------
_DWORD *__fastcall sub_330B8(_DWORD *a1, _DWORD *a2, char *s)
{
  signed int v5; // r0
  int v6; // r5
  int *v7; // r3
  int v8; // r2
  int v9; // r12
  bool v10; // zf
  int v12; // r11
  int v13; // r1
  unsigned __int8 *v14; // lr
  unsigned __int8 *v15; // r7
  char *v16; // r4
  int v17; // r12
  int v18; // t1
  unsigned __int8 v19; // r6
  bool v20; // cc
  int v21; // r1
  int v22; // t1
  _DWORD *v23; // r1
  int v24; // r11

  v5 = strlen(s);
  v6 = a2[30];
  if ( v6 <= 0 )
  {
LABEL_7:
    *a1 = 0;
    a1[1] = 0;
    return a1;
  }
  v7 = (int *)a2[28];
  v8 = 0;
  while ( 1 )
  {
    v9 = v7[2];
    v10 = v9 == 4;
    if ( v9 == 4 )
      v10 = v7[1] == v5;
    if ( v10 )
      break;
LABEL_6:
    ++v8;
    v7 += 3;
    if ( v8 == v6 )
      goto LABEL_7;
  }
  v12 = a2[6];
  v13 = *v7;
  if ( v5 > 0 )
  {
    v14 = (unsigned __int8 *)(v12 + v13);
    v15 = (unsigned __int8 *)(v12 + v5 + v13);
    v16 = s - 1;
    do
    {
      v18 = *v14++;
      v17 = v18;
      v19 = v18 + 32;
      v20 = (unsigned int)(v18 - 65) > 0x19;
      v22 = (unsigned __int8)*++v16;
      v21 = v22;
      if ( !v20 )
        v17 = v19;
      if ( (unsigned int)(v21 - 65) <= 0x19 )
        v21 = (unsigned __int8)(v21 + 32);
      if ( v17 != v21 )
        goto LABEL_6;
    }
    while ( v15 != v14 );
  }
  v23 = (_DWORD *)(a2[28] + 12 * (v8 + 1));
  v24 = v12 + *v23;
  a1[1] = v23[1];
  *a1 = v24;
  return a1;
}

//----- (000331B8) --------------------------------------------------------
int __fastcall sub_331B8(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (000331C0) --------------------------------------------------------
int __fastcall sub_331C0(int result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

//----- (000331C8) --------------------------------------------------------
int __fastcall sub_331C8(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 108) + 56);
}

//----- (000331D4) --------------------------------------------------------
char *__fastcall sub_331D4(char *result)
{
  __int64 *v1; // r3
  int v2; // lr
  __int64 v3; // r4
  int v4; // r2
  char *v5; // r6
  int v6; // r4
  _BOOL4 v7; // r4
  char v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // t1
  unsigned __int8 v12; // lr
  bool v13; // cc
  int v14; // r3
  int v15; // t1
  int v16; // [sp+0h] [bp-18h] BYREF
  int v17; // [sp+4h] [bp-14h]

  v1 = (__int64 *)*((_DWORD *)result + 28);
  if ( v1 )
  {
    v2 = *((_DWORD *)result + 30);
    if ( v2 > 0 )
    {
      v3 = *v1;
      if ( *((_DWORD *)v1 + 2) == 3 )
      {
LABEL_9:
        LODWORD(v3) = *((_DWORD *)result + 6) + v3;
        if ( (_DWORD)v3 )
        {
          v5 = result;
          v6 = *(unsigned __int8 *)(v3 + HIDWORD(v3) - 1) - 49;
          result = (char *)sub_330B8(&v16, result, "Connection");
          v7 = v6 == 0;
          if ( v17 == 5 )
          {
            result = "close";
            v9 = v16 - 1;
            while ( 1 )
            {
              v11 = *(unsigned __int8 *)++v9;
              v10 = v11;
              v12 = v11 + 32;
              v13 = (unsigned int)(v11 - 65) > 0x19;
              v15 = (unsigned __int8)*result++;
              v14 = v15;
              if ( !v13 )
                v10 = v12;
              if ( (unsigned int)(v14 - 65) <= 0x19 )
                v14 = (unsigned __int8)(v14 + 32);
              if ( v10 != v14 )
                break;
              if ( v16 + 4 == v9 )
              {
                v8 = v5[124];
                goto LABEL_21;
              }
            }
            v8 = v5[124];
          }
          else
          {
            v8 = v5[124];
            if ( !(v7 | v17) )
            {
LABEL_21:
              v5[124] = v8 & 0xFE;
              return result;
            }
          }
          v5[124] = v8 | 1;
        }
      }
      else
      {
        v4 = 0;
        while ( ++v4 != v2 )
        {
          v3 = *(__int64 *)((char *)v1 + 12);
          v1 = (__int64 *)((char *)v1 + 12);
          if ( *((_DWORD *)v1 + 2) == 3 )
            goto LABEL_9;
        }
      }
    }
  }
  return result;
}

//----- (000332FC) --------------------------------------------------------
int __fastcall sub_332FC(int result, int a2)
{
  if ( a2 == 1 )
  {
    *(_BYTE *)(result + 124) = *(_BYTE *)(result + 124) & 0xF6 | 1;
  }
  else if ( !a2 )
  {
    *(_BYTE *)(result + 124) &= 0xF6u;
  }
  return result;
}

//----- (0003332C) --------------------------------------------------------
_DWORD *__fastcall sub_3332C(_DWORD *result, _DWORD *a2)
{
  int v2; // r2
  int *v3; // r1
  int v4; // r3
  int v5; // r1

  v2 = a2[6];
  v3 = (int *)(a2[28] + 12 * a2[30] - 12);
  v4 = *v3;
  v5 = v3[1];
  *result = v2 + v4;
  result[1] = v5;
  return result;
}

//----- (00033364) --------------------------------------------------------
_DWORD *sub_33364()
{
  _DWORD *result; // r0

  result = calloc(1u, 0x10u);
  if ( !result )
    _assert_fail("response != NULL", "miner_api/httpserver.h", 0x576u, "http_response_init");
  result[3] = 200;
  return result;
}

//----- (000333A8) --------------------------------------------------------
_DWORD *__fastcall sub_333A8(int *a1, int a2, int a3)
{
  _DWORD *result; // r0
  int v7; // r3

  result = malloc(0xCu);
  if ( !result )
    _assert_fail("header != NULL", "miner_api/httpserver.h", 0x57Du, "http_response_header");
  v7 = *a1;
  *result = a2;
  result[1] = a3;
  result[2] = v7;
  *a1 = (int)result;
  return result;
}

//----- (00033400) --------------------------------------------------------
int __fastcall sub_33400(int result, int a2)
{
  if ( (unsigned int)(a2 - 100) >= 0x1F4 )
    a2 = 500;
  *(_DWORD *)(result + 12) = a2;
  return result;
}

//----- (00033414) --------------------------------------------------------
int __fastcall sub_33414(int result, int a2, int a3)
{
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)(result + 8) = a3;
  return result;
}

//----- (0003341C) --------------------------------------------------------
__int64 __fastcall sub_3341C(void **a1, signed int size, _QWORD *a3)
{
  __int64 result; // r0

  a1[3] = a3;
  a1[2] = 0;
  *a1 = malloc(size);
  result = *a3 + size;
  *a3 = result;
  if ( !*a1 )
    _assert_fail("ctx->buf != NULL", "miner_api/httpserver.h", 0x59Au, "grwprintf_init");
  a1[1] = (void *)size;
  return result;
}

//----- (00033488) --------------------------------------------------------
void *__fastcall sub_33488(void **a1, const void *a2, size_t a3)
{
  char *v4; // r3
  signed int v7; // r1
  char *v8; // r0
  signed int v9; // r1
  char *v10; // r0
  void *result; // r0

  v4 = (char *)a1[2];
  v7 = (signed int)a1[1];
  if ( (int)&v4[a3] <= v7 )
  {
    v10 = (char *)*a1;
  }
  else
  {
    *(_QWORD *)a1[3] -= v7;
    v8 = (char *)a1[3];
    v9 = (signed int)a1[2] + a3;
    a1[1] = (void *)v9;
    *(_QWORD *)v8 += v9;
    v10 = (char *)realloc(*a1, (size_t)a1[1]);
    *a1 = v10;
    if ( !v10 )
      _assert_fail("ctx->buf != NULL", "miner_api/httpserver.h", 0x5A4u, "grwmemcpy");
    v4 = (char *)a1[2];
  }
  result = memcpy(&v4[(_DWORD)v10], a2, a3);
  a1[2] = (char *)a1[2] + a3;
  return result;
}

//----- (00033540) --------------------------------------------------------
int sub_33540(int a1, const char *a2, ...)
{
  int v3; // r5
  int v4; // r1
  int result; // r0
  int v6; // r3
  int v7; // r2
  char *v8; // r0
  va_list varg_r2; // [sp+20h] [bp+18h] BYREF

  va_start(varg_r2, a2);
  v3 = vsnprintf((char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)), *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8), a2, varg_r2);
  v4 = *(_DWORD *)(a1 + 4);
  result = v3 + *(_DWORD *)(a1 + 8);
  if ( result > v4 )
  {
    *(_QWORD *)*(_DWORD *)(a1 + 12) -= v4;
    v6 = *(_DWORD *)(a1 + 4);
    v7 = v3 + *(_DWORD *)(a1 + 8);
    if ( v6 < v7 )
    {
      do
        v6 *= 2;
      while ( v6 < v7 );
      *(_DWORD *)(a1 + 4) = v6;
    }
    *(_QWORD *)*(_DWORD *)(a1 + 12) += v6;
    v8 = (char *)realloc(*(void **)a1, *(_DWORD *)(a1 + 4));
    *(_DWORD *)a1 = v8;
    if ( !v8 )
      _assert_fail("ctx->buf != NULL", "miner_api/httpserver.h", 0x5B4u, "grwprintf");
    result = v3
           + vsnprintf(&v8[*(_DWORD *)(a1 + 8)], *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8), a2, varg_r2)
           + *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (0003364C) --------------------------------------------------------
int __fastcall sub_3364C(int a1, int *a2, int a3)
{
  int i; // r4

  for ( i = *a2; i; i = *(_DWORD *)(i + 8) )
    sub_33540(a3, "%s: %s\r\n", *(const char **)i, *(const char **)(i + 4));
  if ( (*(_BYTE *)(a1 + 124) & 0x20) == 0 )
    sub_33540(a3, "Content-Length: %d\r\n", a2[2]);
  return sub_33540(a3, "\r\n");
}

//----- (000336C4) --------------------------------------------------------
int __fastcall sub_336C4(int a1, int *a2, int a3)
{
  char v4; // r3
  int v7; // r2

  v4 = *(_BYTE *)(a1 + 124);
  if ( (v4 & 8) != 0 )
  {
    sub_331D4((char *)a1);
    v4 = *(_BYTE *)(a1 + 124);
  }
  if ( (v4 & 1) != 0 )
    LOWORD(v7) = -14856;
  else
    LOWORD(v7) = -14956;
  HIWORD(v7) = 9;
  sub_333A8(a2, 640392, v7);
  sub_33540(
    a3,
    "HTTP/1.1 %d %s\r\nDate: %s\r\n",
    a2[3],
    (const char *)*(&off_BB348 + a2[3]),
    (const char *)(*(_DWORD *)(a1 + 108) + 60));
  return sub_3364C(a1, a2, a3);
}
// BB348: using guessed type _UNKNOWN *off_BB348;

//----- (0003375C) --------------------------------------------------------
int __fastcall sub_3375C(int a1, _DWORD *a2, int *a3)
{
  _DWORD *v4; // r0
  _DWORD *v7; // r4
  int v8; // r3
  int v9; // r3

  v4 = (_DWORD *)*a2;
  if ( *a2 )
  {
    do
    {
      v7 = (_DWORD *)v4[2];
      free(v4);
      v4 = v7;
    }
    while ( v7 );
  }
  sub_329B8((_DWORD *)a1);
  free(a2);
  v8 = *a3;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = v8;
  *(_DWORD *)(a1 + 44) = a3[2];
  v9 = a3[1];
  *(_DWORD *)(a1 + 96) = 2;
  *(_DWORD *)(a1 + 40) = v9;
  return sub_32A60(a1);
}

//----- (000337D0) --------------------------------------------------------
int __fastcall sub_337D0(int a1, int *a2)
{
  const void *v4; // r1
  void *v6[5]; // [sp+0h] [bp-14h] BYREF

  sub_3341C(v6, 1024, (_QWORD *)(*(_DWORD *)(a1 + 108) + 8));
  sub_336C4(a1, a2, (int)v6);
  v4 = (const void *)a2[1];
  if ( v4 )
    sub_33488(v6, v4, a2[2]);
  return sub_3375C(a1, a2, (int *)v6);
}

//----- (00033834) --------------------------------------------------------
int __fastcall sub_33834(_DWORD *a1)
{
  int *v2; // r3
  int v3; // lr
  int v4; // r1
  size_t v5; // r2
  int v6; // r0
  size_t v7; // r4
  int v8; // r7
  const void *v9; // r8
  int (__fastcall *v10)(_BYTE *, char *, int); // r3
  int *v11; // r0
  int *v12; // r4
  size_t v13; // r0
  char v15[24580]; // [sp+0h] [bp-803Ch] BYREF
  _BYTE v16[28]; // [sp+6004h] [bp-2038h] BYREF
  char v17[8196]; // [sp+6020h] [bp-201Ch] BYREF

  memset(v15, 0, 0x6000u);
  v2 = (int *)a1[28];
  if ( !v2 || (v3 = a1[30], v3 <= 0) )
  {
LABEL_8:
    v7 = 0;
    v8 = 4;
    v9 = 0;
    goto LABEL_9;
  }
  v4 = *v2;
  v5 = v2[1];
  if ( v2[2] != 2 )
  {
    v6 = 0;
    while ( v3 != ++v6 )
    {
      v4 = v2[3];
      v2 += 3;
      v5 = v2[1];
      if ( v2[2] == 2 )
        goto LABEL_18;
    }
    goto LABEL_8;
  }
LABEL_18:
  v7 = v5;
  v8 = v5 + 4;
  v9 = (const void *)(a1[6] + v4);
LABEL_9:
  memset(v16, 72, 0x19u);
  memcpy(&v16[4], v9, v7);
  v10 = (int (__fastcall *)(_BYTE *, char *, int))off_C1DBC;
  v16[v8] = 0;
  if ( v10 )
  {
    if ( v10(v16, v15, 24576) )
    {
      if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
      {
        strcpy(v17, "http_test_case exit for Error cmd!");
        sub_41DB8(7, v17, 0);
      }
      strcpy(v15, "error 6060 cmd");
    }
  }
  else
  {
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      strcpy(v17, "No 6060 test case found.");
      sub_41DB8(7, v17, 0);
    }
    strcpy(v15, "No 6060 test case found");
  }
  v11 = sub_33364();
  v11[3] = 200;
  v12 = v11;
  sub_333A8(v11, (int)"Content-Type", (int)"text/plain");
  v13 = strlen(v15);
  v12[1] = (int)v15;
  v12[2] = v13;
  return sub_337D0((int)a1, v12);
}
// BC5F4: using guessed type int dword_BC5F4;
// C1DBC: using guessed type _UNKNOWN *off_C1DBC;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 6682BC: using guessed type char byte_6682BC;

//----- (00033B00) --------------------------------------------------------
int __fastcall sub_33B00(int a1, int a2, const char *a3)
{
  int *v6; // r0
  int *v7; // r4
  size_t v8; // r0

  v6 = sub_33364();
  if ( (unsigned int)(a2 - 100) >= 0x1F4 )
    a2 = 500;
  v6[3] = a2;
  v7 = v6;
  sub_333A8(v6, (int)"Content-Type", (int)"text/plain");
  v8 = strlen(a3);
  v7[1] = (int)a3;
  v7[2] = v8;
  sub_337D0(a1, v7);
  return sub_32A60(a1);
}

//----- (00033B64) --------------------------------------------------------
_DWORD *__fastcall sub_33B64(int a1)
{
  int v2; // r2
  int v3; // r3
  _DWORD *result; // r0
  int v5; // r5
  int v6[2]; // [sp+4h] [bp-10h] BYREF
  int v7; // [sp+Ch] [bp-8h]

  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 96) = 1;
  *(_DWORD *)(a1 + 104) = 20;
  if ( v2 < v3
    || (result = (_DWORD *)sub_31C80((char **)(a1 + 24), *(_DWORD *)(a1 + 100), (__int64 *)(*(_DWORD *)(a1 + 108) + 8))) != 0 )
  {
    do
    {
      result = sub_32698(v6, a1 + 72, a1 + 24);
      v5 = v7;
      if ( !v7 )
        break;
      result = (_DWORD *)sub_32828((void **)(a1 + 112), v6[0], v6[1], v7);
      switch ( v5 )
      {
        case 6:
          *(_DWORD *)(a1 + 96) = 3;
          result = (_DWORD *)(*(int (__fastcall **)(int))(a1 + 12))(a1);
          break;
        case 7:
        case 8:
          *(_DWORD *)(a1 + 96) = 3;
          if ( v5 == 8 )
            *(_BYTE *)(a1 + 124) |= 1u;
          result = (_DWORD *)(*(int (__fastcall **)(int))(*(_DWORD *)(a1 + 108) + 36))(a1);
          break;
        case 11:
          result = (_DWORD *)sub_33B00(a1, 400, "Bad Request");
          break;
        default:
          break;
      }
    }
    while ( *(_DWORD *)(a1 + 96) == 1 );
  }
  else
  {
    *(_BYTE *)(a1 + 124) |= 2u;
  }
  return result;
}
// 33BE8: control flows out of bounds to 33BEC

//----- (00033C94) --------------------------------------------------------
_DWORD *__fastcall sub_33C94(int a1, int a2)
{
  *(_DWORD *)(a1 + 12) = a2;
  return sub_33B64(a1);
}

//----- (00033DC8) --------------------------------------------------------
int __fastcall sub_33DC8(int a1)
{
  int v2; // r2
  int v3; // r0
  struct epoll_event v5; // [sp+0h] [bp-14h] BYREF

  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 24);
  v5.data.fd = a1;
  v5.events = -2147483647;
  return epoll_ctl(v3, 1, v2, &v5);
}

//----- (00033DFC) --------------------------------------------------------
int __fastcall sub_33DFC(_DWORD *a1)
{
  int v2; // r7
  int v3; // r0
  int result; // r0
  struct epoll_event v5; // [sp+0h] [bp-24h] BYREF
  _DWORD v6[4]; // [sp+10h] [bp-14h] BYREF

  a1[6] = epoll_create1(0);
  a1[1] = sub_32B78;
  v2 = timerfd_create();
  v6[0] = 1;
  v6[1] = 0;
  v6[3] = 0;
  v6[2] = 1;
  timerfd_settime(v2, 0, v6, 0);
  v3 = a1[6];
  v5.data.fd = (int)(a1 + 1);
  v5.events = -2147483647;
  result = epoll_ctl(v3, 1, v2, &v5);
  a1[7] = v2;
  return result;
}
// 12604: using guessed type int timerfd_create(void);
// 128FC: using guessed type int __fastcall timerfd_settime(_DWORD, _DWORD, _DWORD, _DWORD);
// 12A20: using guessed type int __fastcall epoll_create1(_DWORD);

//----- (00033E88) --------------------------------------------------------
char *__fastcall sub_33E88(int a1, int a2)
{
  char *v4; // r0
  char *v5; // r4

  v4 = (char *)malloc(0x60u);
  v5 = v4;
  if ( !v4 )
    _assert_fail("serv != NULL", "miner_api/httpserver.h", 0x4B5u, "http_server_init");
  *((_DWORD *)v4 + 5) = a1;
  *((_QWORD *)v4 + 1) = 0;
  *(_DWORD *)v4 = sub_34240;
  sub_33DFC(v4);
  sub_32B3C(v5 + 60);
  *((_DWORD *)v5 + 9) = a2;
  return v5;
}

//----- (00033EFC) --------------------------------------------------------
void __fastcall __noreturn sub_33EFC(int a1, char *a2)
{
  struct epoll_event v3; // [sp+0h] [bp-10h] BYREF

  sub_32BAC(a1, a2);
  while ( 1 )
  {
    while ( epoll_wait(*(_DWORD *)(a1 + 24), &v3, 1, -1) <= 0 )
      ;
    (*(void (__fastcall **)(struct epoll_event *))v3.data.ptr)(&v3);
  }
}

//----- (00033F3C) --------------------------------------------------------
void __fastcall __noreturn sub_33F3C(int a1)
{
  sub_33EFC(a1, 0);
}

//----- (00033F48) --------------------------------------------------------
void __noreturn sub_33F48()
{
  dword_65BCC8 = (int)sub_33E88(6060, (int)sub_33834);
  sub_33F3C(dword_65BCC8);
}
// 65BCC8: using guessed type int dword_65BCC8;

//----- (00033F6C) --------------------------------------------------------
int __fastcall sub_33F6C(int *a1)
{
  epoll_ctl(*(_DWORD *)(a1[27] + 24), 2, a1[25], 0);
  epoll_ctl(*(_DWORD *)(a1[27] + 24), 2, a1[2], 0);
  return close(a1[2]);
}

//----- (00033FB0) --------------------------------------------------------
void __fastcall sub_33FB0(int a1)
{
  sub_33F6C((int *)a1);
  close(*(_DWORD *)(a1 + 100));
  sub_329B8((_DWORD *)a1);
  free(*(void **)(a1 + 112));
  free((void *)a1);
}

//----- (00033FE0) --------------------------------------------------------
void __fastcall sub_33FE0(int a1)
{
  int v1; // r4
  int v3; // [sp+0h] [bp-8h] BYREF

  v1 = *(_DWORD *)(a1 + 8);
  read(*(_DWORD *)(v1 + 4), &v3, 8u);
  if ( (*(_DWORD *)(v1 + 100))-- == 1 )
    sub_33FB0(v1 - 4);
}

//----- (00034020) --------------------------------------------------------
void __fastcall sub_34020(int a1)
{
  int v2; // r3
  int v3; // r3

  v2 = *(_DWORD *)(a1 + 96);
  if ( v2 == 1 )
  {
LABEL_8:
    sub_33B64(a1);
    goto LABEL_4;
  }
  if ( v2 != 2 )
  {
    if ( v2 )
      goto LABEL_4;
    sub_329F8((_DWORD *)a1);
    v3 = *(_DWORD *)(a1 + 108);
    *(_DWORD *)(a1 + 96) = 1;
    if ( *(__int64 *)(v3 + 8) >= 0x100000001LL )
    {
      sub_33B00(a1, 503, "Service Unavailable");
      return;
    }
    goto LABEL_8;
  }
  sub_32A60(a1);
LABEL_4:
  if ( (*(_BYTE *)(a1 + 124) & 2) != 0 )
    sub_33FB0(a1);
}

//----- (000340A8) --------------------------------------------------------
void __fastcall sub_340A8(int a1)
{
  sub_34020(*(_DWORD *)(a1 + 8));
}

//----- (000340F0) --------------------------------------------------------
int __fastcall sub_340F0(_DWORD *a1)
{
  int v1; // r1
  int v3; // r2
  int v4; // r0
  int v5; // r0
  int v6; // r6
  int v7; // r0
  int v8; // r0
  int result; // r0
  struct epoll_event v10; // [sp+0h] [bp-24h] BYREF
  _DWORD v11[4]; // [sp+10h] [bp-14h] BYREF

  v1 = a1[27];
  v3 = a1[25];
  a1[1] = sub_33FE0;
  v4 = *(_DWORD *)(v1 + 24);
  v10.data.fd = (int)a1;
  v10.events = -2147483647;
  epoll_ctl(v4, 1, v3, &v10);
  v5 = timerfd_create(1, 0);
  v11[0] = 1;
  v6 = v5;
  v11[1] = 0;
  v11[3] = 0;
  v11[2] = 1;
  timerfd_settime(v5, 0, v11, 0);
  v7 = a1[27];
  v10.events = -2147483647;
  v8 = *(_DWORD *)(v7 + 24);
  v10.data.fd = (int)(a1 + 1);
  result = epoll_ctl(v8, 1, v6, &v10);
  a1[2] = v6;
  return result;
}
// 12604: using guessed type int __fastcall timerfd_create(_DWORD, _DWORD);
// 128FC: using guessed type int __fastcall timerfd_settime(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00034194) --------------------------------------------------------
int __fastcall sub_34194(int a1)
{
  struct sockaddr *v2; // r8
  socklen_t *v3; // r7
  int result; // r0
  int v5; // r5
  _DWORD *v6; // r0
  _DWORD *v7; // r4
  int v8; // r0

  v2 = (struct sockaddr *)(a1 + 40);
  v3 = (socklen_t *)(a1 + 32);
  while ( 1 )
  {
    result = accept(*(_DWORD *)(a1 + 16), v2, v3);
    v5 = result;
    if ( result <= 0 )
      break;
    v6 = calloc(1u, 0x80u);
    v7 = v6;
    if ( !v6 )
      _assert_fail("session != NULL", "miner_api/httpserver.h", 0x49Eu, "hs_accept_connections");
    v6[25] = v5;
    v6[26] = 20;
    v6[27] = a1;
    *v6 = sub_340A8;
    v8 = fcntl(v5, 3, 0);
    fcntl(v5, 4, v8 | 0x800);
    sub_340F0(v7);
    sub_34020((int)v7);
  }
  return result;
}

//----- (00034240) --------------------------------------------------------
int __fastcall sub_34240(int a1)
{
  return sub_34194(*(_DWORD *)(a1 + 8));
}

//----- (00034248) --------------------------------------------------------
int __fastcall sub_34248(int a1)
{
  int v1; // lr
  int v2; // r2
  int v3; // r0
  struct epoll_event v5; // [sp+0h] [bp-14h] BYREF

  v1 = *(_DWORD *)(a1 + 108);
  v2 = *(_DWORD *)(a1 + 100);
  v5.data.fd = a1;
  v3 = *(_DWORD *)(v1 + 24);
  v5.events = -2147483644;
  return epoll_ctl(v3, 3, v2, &v5);
}

//----- (0003427C) --------------------------------------------------------
void sub_3427C()
{
  char v0[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( dword_65BCC8 )
    free((void *)dword_65BCC8);
  if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
  {
    strcpy(v0, "httpserver6060 quit!\n");
    sub_41DB8(5, v0, 0);
  }
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 65BCC8: using guessed type int dword_65BCC8;
// 6682BC: using guessed type char byte_6682BC;

//----- (00034324) --------------------------------------------------------
int sub_34324()
{
  int result; // r0
  char *v1; // r3
  pthread_t v2; // [sp+0h] [bp-202Ch] BYREF
  pthread_attr_t attr; // [sp+4h] [bp-2028h] BYREF
  char v4[8196]; // [sp+28h] [bp-2004h] BYREF

  if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
  {
    strcpy(v4, "start the http server\n");
    sub_41DB8(5, v4, 0);
  }
  pthread_attr_init(&attr);
  result = pthread_create(&v2, &attr, (void *(*)(void *))sub_33F48, 0);
  if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
  {
    v1 = "ok";
    if ( result )
      v1 = "failed";
    snprintf(v4, 0x2000u, "httpserver:6060 started %s", v1);
    return sub_41DB8(5, v4, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (00034458) --------------------------------------------------------
char *__fastcall sub_34458(const char *a1)
{
  const char *v2; // r4
  char *v3; // r6
  size_t v4; // r0
  size_t v5; // r5
  size_t v6; // r8
  size_t v7; // r5
  int v8; // r3
  char *v9; // r0
  unsigned int v10; // r4
  struct hostent *v11; // r3
  int v12; // r0
  int v13; // r5
  int v14; // r6
  signed int v15; // r7
  int v16; // r4
  ssize_t v17; // r0
  const char *v18; // r12
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r3
  _DWORD *v23; // r12
  char *v24; // r4
  int v25; // r1
  ssize_t v27; // r0
  char *v28; // r0
  char *v29; // r0
  char *v30; // r5
  size_t v31; // r0
  char *v32; // r0
  _DWORD v33[2]; // [sp+8h] [bp-3808h] BYREF
  char dest[1024]; // [sp+10h] [bp-3800h] BYREF
  char v35[1024]; // [sp+410h] [bp-3400h] BYREF
  char s[4096]; // [sp+810h] [bp-3000h] BYREF
  struct sockaddr v37[512]; // [sp+1810h] [bp-2000h] BYREF

  memset(s, 0, sizeof(s));
  memset(dest, 0, sizeof(dest));
  memset(v35, 0, sizeof(v35));
  if ( !a1 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
    {
      v24 = 0;
      strcpy((char *)v37, "url is null!\n");
      sub_41DB8(5, (const char *)v37, 0);
      return v24;
    }
    return 0;
  }
  if ( !strncmp(a1, "http://", 7u) )
  {
    v2 = a1 + 7;
    v3 = strchr(v2, 47);
    v4 = strlen(v2);
    v5 = v4;
    if ( v3 )
    {
      v6 = strlen(v3);
      v7 = v5 - v6;
      memcpy(dest, v2, v7);
      v8 = (unsigned __int8)v3[1];
      dest[v7] = 0;
      if ( v8 )
      {
        memcpy(v35, v3 + 1, v6 - 1);
        dest[v6 + 1023] = 0;
      }
    }
    else
    {
      memcpy(dest, v2, v4);
      dest[v5] = 0;
    }
    v9 = strchr(dest, 58);
    if ( v9 )
    {
      *v9 = 0;
      v10 = strtol(v9 + 1, 0, 10);
    }
    else
    {
      v10 = 80;
    }
    v11 = gethostbyname(dest);
    if ( !v11 )
      goto LABEL_37;
    *(_WORD *)v37[0].sa_data = __rev16(v10);
    v37[0].sa_family = 2;
    *(_DWORD *)&v37[0].sa_data[2] = **(_DWORD **)v11->h_addr_list;
    v12 = socket(2, 1, 0);
    v13 = v12;
    if ( v12 == -1
      || (v33[0] = 10, v33[1] = 0, setsockopt(v12, 1, 21, v33, 8u))
      || (v14 = setsockopt(v13, 1, 20, v33, 8u)) != 0
      || connect(v13, v37, 0x10u) == -1
      || v13 < 0 )
    {
LABEL_37:
      if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
      {
        v24 = 0;
        strcpy((char *)v37, "tcp client create failed\n");
        sub_41DB8(5, (const char *)v37, 0);
        return v24;
      }
    }
    else
    {
      sprintf(s, "GET /%s HTTP/1.1\r\nHOST: %s:%d\r\nAccept: */*\r\n\r\n", v35, dest, v10);
      v15 = strlen(s);
      if ( v15 )
      {
        v16 = 0;
        while ( 1 )
        {
          v17 = send(v13, &s[v16], v15 - v16, 0);
          v16 += v17;
          if ( v17 == -1 )
            break;
          if ( v15 <= v16 )
            goto LABEL_41;
        }
        if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
        {
          v18 = "tcp client send failed\n";
LABEL_23:
          v19 = *(_DWORD *)v18;
          v20 = *((_DWORD *)v18 + 1);
          v21 = *((_DWORD *)v18 + 2);
          v22 = *((_DWORD *)v18 + 3);
          v23 = v18 + 16;
          v24 = 0;
          *(_DWORD *)&v37[0].sa_family = v19;
          *(_DWORD *)&v37[0].sa_data[2] = v20;
          *(_DWORD *)&v37[0].sa_data[6] = v21;
          *(_DWORD *)&v37[0].sa_data[10] = v22;
          v25 = v23[1];
          *(_DWORD *)&v37[1].sa_family = *v23;
          *(_DWORD *)&v37[1].sa_data[2] = v25;
          sub_41DB8(5, (const char *)v37, 0);
          return v24;
        }
      }
      else
      {
LABEL_41:
        while ( 1 )
        {
          v27 = recv(v13, &s[v14], 4095 - v14, 0);
          if ( v27 <= 0 )
            break;
          v14 += v27;
        }
        if ( v14 )
        {
          close(v13);
          v28 = strstr(s, aHttp_1);
          if ( v28 )
          {
            if ( strtol(v28 + 9, 0, 10) == 200 )
            {
              v29 = strstr(s, "\r\n\r\n");
              v30 = v29;
              if ( v29 )
              {
                v31 = strlen(v29);
                v32 = (char *)malloc(v31 + 1);
                v24 = v32;
                if ( v32 )
                  strcpy(v32, v30 + 4);
                return v24;
              }
            }
          }
        }
        else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
        {
          v18 = "tcp client recv failed\n";
          goto LABEL_23;
        }
      }
    }
    return 0;
  }
  if ( !byte_6682BC && !byte_4D4171 && dword_BC5F4 <= 4 )
    return 0;
  strcpy((char *)v37, "parse url failed!\n");
  sub_41DB8(5, (const char *)v37, 0);
  return 0;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003499C) --------------------------------------------------------
int __fastcall sub_3499C(char *a1)
{
  int v2; // r0
  int v3; // r6
  int v4; // r9
  int v5; // r5
  struct in_addr *i; // r4
  char *v8; // r1
  _DWORD v10[2]; // [sp+0h] [bp-208h] BYREF
  _OWORD v11[32]; // [sp+8h] [bp-200h] BYREF

  v2 = socket(2, 2, 0);
  v3 = v2;
  if ( v2 < 0 )
    return -1;
  v10[0] = 512;
  v10[1] = v11;
  if ( ioctl(v2, 0x8912u, v10) )
  {
    v4 = -1;
  }
  else
  {
    v4 = -1;
    v5 = v10[0] >> 5;
    for ( i = (struct in_addr *)&v11[2 * (v10[0] >> 5) - 2]; v5-- != 0; i -= 8 )
    {
      if ( !ioctl(v3, 0x8915u, i) )
      {
        v8 = inet_ntoa(i[5]);
        if ( v8 )
        {
          strcpy(a1, v8);
          v4 = strcmp("127.0.0.1", a1);
          if ( v4 )
          {
            v4 = 0;
            break;
          }
        }
      }
    }
  }
  close(v3);
  return v4;
}

//----- (00034A78) --------------------------------------------------------
int sub_34A78()
{
  double v0; // d0
  _DWORD *v1; // r5
  int v2; // r6
  double i; // d8
  double v4; // d9
  double v5; // d14
  int v6; // r3
  double v7; // d9
  unsigned int j; // r4
  double v9; // d7
  const char *v10; // r3
  int v11; // r4
  bool v12; // cc
  int v13; // r12
  int v15; // r0
  int v16; // r6
  const char *v17; // r3
  int v18; // [sp+4h] [bp-2024h]
  int v19; // [sp+14h] [bp-2014h]
  _DWORD v20[4]; // [sp+18h] [bp-2010h] BYREF
  char s[8192]; // [sp+28h] [bp-2000h] BYREF

  LOWORD(v1) = (unsigned __int16)&off_BC5EC;
  memset(v20, 0, sizeof(v20));
  prctl(15, "heart_beat", 0, 0, 0);
  if ( !sub_2270C() )
  {
    HIWORD(v1) = (unsigned int)&off_BC5EC >> 16;
    goto LABEL_3;
  }
  HIWORD(v1) = (unsigned int)&off_BC5EC >> 16;
  v15 = sub_6FCF4(1);
  v16 = v15;
  if ( *v1 <= 3u )
  {
    if ( v15 != 1 )
      return 0;
    goto LABEL_3;
  }
  snprintf(s, 0x2000u, "enable power watchdog: 0x%04x\n", v15);
  sub_41DB8(3, s, 0);
  if ( v16 == 1 )
  {
LABEL_3:
    v2 = 0;
    for ( i = -1.0; ; i = v7 )
    {
      while ( 1 )
      {
        pthread_setcancelstate(1, 0);
        if ( !sub_2270C() )
          break;
        sub_21B08(0, 1);
        i = v0;
        v19 = sub_2242C();
        if ( v0 < 0.0 )
        {
          if ( *v1 > 3u )
          {
            strcpy(s, "read_feedback_voltage failed!");
            sub_41DB8(3, s, 0);
          }
          sub_4FB28(12, 0);
          sub_473B4(9u, "power voltage read failed, pls check!");
          return 0;
        }
        v4 = v0 * 100.0;
        v5 = (double)(unsigned int)v19;
        if ( (v0 * 100.0 > (double)(unsigned int)v19 * 1.1 || v4 < v5 * 0.9) && sub_21DB8() )
        {
          if ( *v1 > 3u )
          {
            v17 = "drop";
            if ( v4 - v5 > 0.0 )
              v17 = "rise";
            snprintf(s, 0x2000u, "chain avg vol %s from %d to %.2f", v17, v19, v18, v0 * 100.0);
            sub_41DB8(3, s, 0);
          }
          sub_4FB28(12, 0);
          sub_473B4(9u, "power voltage rise or drop, pls check!");
          return 0;
        }
        if ( *v1 > 4u )
        {
          snprintf(s, 0x2000u, "cur_voltage = %d, avg_voltage = %.2f", v19, v0 * 100.0);
          sub_41DB8(4, s, 0);
        }
        v6 = sub_6F2DC();
        if ( v6 )
        {
          if ( *v1 > 3u )
          {
            snprintf(s, 0x2000u, "power status error = 0x%0x", v6);
            sub_41DB8(3, s, 0);
          }
          sub_4FB28(12, 0);
          sub_473B4(9u, "power status error!");
        }
        pthread_setcancelstate(0, 0);
        pthread_testcancel();
        sleep(0xAu);
      }
      if ( v2 > 9 )
        break;
LABEL_17:
      v7 = 0.0;
      for ( j = 0; j != 4; ++j )
      {
        if ( sub_27EC8(j) )
        {
          sub_21B08(j, (unsigned __int8)byte_4D4390);
          v7 = v7 + v0;
          sub_44890();
        }
      }
      if ( sub_27EB8() )
        v7 = v7 / (double)sub_27EB8();
      if ( i < -0.1 )
        i = v7;
      if ( *v1 > 4u )
      {
        snprintf(s, 0x2000u, "last avg = %.2f, current voltage = %.2f", i, v7);
        sub_41DB8(4, s, 0);
      }
      v9 = (double)(dword_4D419C / 100) * 0.75;
      if ( (v9 < i && i * 0.75 > v7 || v9 < v7 && v7 * 0.75 > i) && *v1 > 3u )
      {
        v10 = "drop";
        if ( v7 - i > 0.0 )
          v10 = "rise";
        snprintf(s, 0x2000u, "chain avg vol %s to %.2f", v10, v7);
        sub_41DB8(3, s, 0);
      }
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      if ( (sub_47394() == 2 || sub_47394() == 3) && (double)(dword_4D419C / 100) * 0.75 > v7 && !dword_C351C )
      {
        sub_4FB28(12, 0);
        sub_473B4(9u, "pic check voltage drop");
      }
      if ( ++v2 > 10 )
        v2 = 0;
    }
    v11 = 0;
    if ( sub_27EC8(0) )
      goto LABEL_47;
    while ( 1 )
    {
      do
      {
        if ( ++v11 == 4 )
          goto LABEL_17;
      }
      while ( !sub_27EC8(v11) );
LABEL_47:
      if ( sub_21A3C(v11) )
        break;
      v12 = *v1 > 1u;
      v13 = v20[v11] + 1;
      v20[v11] = v13;
      if ( v12 )
      {
        snprintf(s, 0x2000u, "chain[%d] heart beat fail %d times.\n", v11, v13);
        sub_41DB8(1, s, 0);
        sub_44890();
      }
      else
      {
LABEL_50:
        sub_44890();
      }
    }
    v20[v11] = 0;
    goto LABEL_50;
  }
  if ( *v1 > 3u )
  {
    snprintf(s, 0x2000u, "%s power enable watchdog error.\n", "pic_heart_beat_thread");
    sub_41DB8(3, s, 0);
  }
  return 0;
}
// 34B14: variable 'v0' is possibly undefined
// 34FD8: variable 'v18' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C351C: using guessed type int dword_C351C;
// 4D419C: using guessed type int dword_4D419C;
// 4D4390: using guessed type char byte_4D4390;

//----- (00035078) --------------------------------------------------------
int sub_35078()
{
  int v0; // r6
  int v1; // r6
  int result; // r0
  unsigned int *v3; // r7
  int v4; // r5
  unsigned int *v5; // r8
  unsigned __int64 v6; // r10
  unsigned int v7; // r4
  int v8; // r0
  unsigned __int64 v9; // r0
  unsigned __int64 v10; // r0
  unsigned int *v11; // lr
  int v12; // r12
  unsigned int v13; // t1
  char v14[8192]; // [sp+0h] [bp-2000h] BYREF

  v0 = sub_27D0C();
  v1 = sub_27D7C() * v0;
  result = (int)malloc(4 * v1);
  v3 = (unsigned int *)result;
  if ( result )
  {
    v4 = 0;
    while ( 1 )
    {
      if ( sub_27EC8(v4) )
      {
        if ( v1 )
        {
          v5 = v3 - 1;
          v6 = 0;
          v7 = 0;
          do
          {
            v8 = sub_3F570(v4, v7++);
            v6 += (unsigned int)v8;
            v5[1] = v8;
            ++v5;
          }
          while ( v1 != v7 );
          LODWORD(v9) = sub_96DFC(v6, (unsigned int)v1);
          if ( v9 > 0x1387 )
          {
            v10 = v9 >> 1;
            if ( *v3 < v10 )
            {
LABEL_16:
              if ( (unsigned int)off_BC5EC > 3 )
              {
                strcpy(v14, "Domain unbalance happened!\n");
                sub_41DB8(3, v14, 0);
              }
              free(v3);
              return 1;
            }
            v11 = v3;
            v12 = 0;
            while ( ++v12 != v7 )
            {
              v13 = v11[1];
              ++v11;
              if ( v13 < v10 )
                goto LABEL_16;
            }
          }
        }
      }
      if ( ++v4 == 4 )
      {
        free(v3);
        return 0;
      }
    }
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v14, "failed alloc memory!\n");
    sub_41DB8(3, v14, 0);
    return 0;
  }
  return result;
}
// 35134: variable 'v9' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00035220) --------------------------------------------------------
void __fastcall sub_35220(int a1)
{
  double v1; // d0
  int v2; // r4
  double v4; // d8
  double *v5; // r10
  int v6; // r11
  int v7; // r0
  _BOOL4 v8; // r3
  int v9; // r4
  int v10; // r5
  int v11; // r6
  int v12; // r4
  int v13; // r7
  _BOOL4 v14; // r2
  unsigned __int8 v15; // r12
  int v16; // r9
  int v17; // r8
  double v18; // d14
  double v19; // d15
  int v20; // r0
  bool v21; // zf
  int v22; // r1
  int v23; // r0
  int v24; // r0
  _BOOL4 v25; // r3
  bool v26; // r0
  int v27; // r0
  int v28; // r2
  int v29; // r0
  int v30; // r0
  int v31; // r2
  int v32; // r2
  int v33; // r3
  bool v34; // nf
  int v35; // r3
  unsigned int v36; // r6
  unsigned __int8 *v37; // r5
  int v38; // t1
  size_t v39; // r0
  _WORD *v40; // r0
  int v41; // [sp+14h] [bp-2848h]
  int v42; // [sp+18h] [bp-2844h]
  int v43; // [sp+1Ch] [bp-2840h]
  bool *v44; // [sp+20h] [bp-283Ch]
  int v45; // [sp+24h] [bp-2838h]
  int v46; // [sp+28h] [bp-2834h]
  int v47; // [sp+2Ch] [bp-2830h]
  int v48; // [sp+38h] [bp-2824h]
  int v49; // [sp+3Ch] [bp-2820h]
  char v50[4]; // [sp+44h] [bp-2818h] BYREF
  int v51; // [sp+48h] [bp-2814h]
  int v52; // [sp+4Ch] [bp-2810h]
  int v53; // [sp+50h] [bp-280Ch]
  int v54; // [sp+54h] [bp-2808h]
  _BYTE s[1024]; // [sp+58h] [bp-2804h] BYREF
  char v56[1024]; // [sp+458h] [bp-2404h] BYREF
  __time_t v57[2049]; // [sp+858h] [bp-2004h] BYREF

  v2 = 0;
  dword_679950[0] = 0;
  dword_679954 = 0;
  dword_679958 = 0;
  dword_67995C = 0;
  memset(s, 0, sizeof(s));
  memset(v56, 0, sizeof(v56));
  v51 = 0;
  *(_DWORD *)v50 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  if ( dword_BBCA4 != 1 )
  {
    v4 = 1000.0;
    dword_BBCA4 = 1;
    do
    {
      if ( sub_27EC8(v2) )
      {
        sub_2A220((unsigned __int8)v2, 1, 0, 144);
        sub_4465C(v57);
        sub_44984();
        v4 = v1;
        dbl_674930[v2] = v1;
      }
      ++v2;
    }
    while ( v2 != 4 );
    if ( (double)(a1 + 30) <= v4 )
    {
      byte_664DEC = 0;
      return;
    }
    v5 = dbl_674930;
    v6 = 0;
    v45 = 0;
    v48 = 0;
    while ( 1 )
    {
      if ( sub_27EC8(v6) )
      {
        v9 = dword_679950[v6];
        v46 = 4 * v6;
        if ( v9 == sub_27D1C() )
        {
          v10 = v6 << 8;
          v11 = 0;
          v44 = (bool *)&unk_664CE8 + 64 * v6;
          v47 = 0;
          v43 = 0;
          v49 = 0;
          v41 = 0;
          while ( sub_27D0C() > v11 )
          {
            v12 = 0;
            v13 = 0;
            v42 = 0;
            while ( sub_27D2C() > v12 )
            {
              v16 = v12 + v11 * sub_27D2C();
              v17 = v10 + v16;
              if ( !byte_C3F4C[v10 + v16] )
              {
                sub_257E0(v6, v16);
                v18 = v1;
                if ( v1 < 50.0 )
                  v18 = 50.0;
                v19 = (double)(unsigned int)dword_674950[v17] * 256.0 / 255.0;
                v20 = sub_27D5C();
                v21 = dword_6651F0[v17] == 0;
                v22 = (int)(v19 / (double)v20 / *v5 * 4294967300.0 / 1000.0 / 1000.0 / v18 * 10000.0);
                dword_663CE4[v17] = v22;
                if ( v21 )
                  v14 = v22 < 8000;
                else
                  v14 = v22 <= 8999;
                v13 += v22;
                dword_6651F0[v10 + v16] = v14;
                v15 = v43 + 1;
                v41 += v22;
                if ( v22 <= 6999 )
                {
                  v43 = v15;
                  *((_BYTE *)&v57[-512] + v10 + v15 - 1) = v16;
                  ++v42;
                }
              }
              ++v12;
            }
            v23 = sub_27D2C();
            v24 = sub_96518(v13, v23);
            v25 = *v44;
            dword_664DF0[64 * v6 + v11] = v24;
            if ( v25 )
              v26 = v24 <= 8999;
            else
              v26 = v24 < 8000;
            *v44++ = v26;
            v27 = sub_27D2C() - 2;
            if ( v27 <= v42 )
            {
              v49 = 1;
              v28 = v47 | (1 << v11);
            }
            ++v11;
            if ( v27 <= v42 )
              v47 = v28;
          }
          v29 = sub_27D1C();
          v30 = sub_96518(v41, v29);
          v31 = byte_664DE8[v6];
          dword_65BCD0[v6] = v30;
          if ( v31 )
            v32 = 9899;
          else
            v32 = 9799;
          byte_664DE8[v6] = v30 <= v32;
          if ( dword_C1DE4[v6] != v47 && (unsigned int)off_BC5EC > 3 )
          {
            snprintf((char *)v57, 0x2000u, "chain = %d, domain curr_sta = 0x%x", v6, v47);
            sub_41DB8(3, (const char *)v57, 0);
          }
          dword_C1DE4[v6] = v47;
          if ( v49 )
          {
            v33 = *(_DWORD *)((char *)&unk_C1DF4 + v46) + 1;
            v34 = *(_DWORD *)((char *)&unk_C1DF4 + v46) - 1 < 0;
            *(_DWORD *)((char *)&unk_C1DF4 + v46) = v33;
            if ( !(v34 ^ __OFSUB__(v33, 2) | (v33 == 2)) )
            {
              if ( (unsigned int)off_BC5EC <= 3 )
                goto LABEL_54;
              snprintf(
                (char *)v57,
                0x2000u,
                "chain[%d], imbalance happen, imbalance time = %d, bad asic num = %d, curr imbalance sta= 0x%x",
                v6,
                v33,
                v43,
                v47);
LABEL_67:
              sub_41DB8(3, (const char *)v57, 0);
              goto LABEL_54;
            }
          }
          else if ( v43 < 2 * sub_27D2C() )
          {
            *(_DWORD *)((char *)&unk_C1DF4 + v46) = 0;
          }
          else
          {
            v35 = *(_DWORD *)((char *)&unk_C1DF4 + v46) + 1;
            v34 = *(_DWORD *)((char *)&unk_C1DF4 + v46) - 1 < 0;
            *(_DWORD *)((char *)&unk_C1DF4 + v46) = v35;
            if ( !(v34 ^ __OFSUB__(v35, 2) | (v35 == 2)) )
            {
              if ( v43 >= 2 * sub_27D2C() )
              {
                if ( (unsigned int)off_BC5EC > 3 )
                {
                  snprintf(
                    (char *)v57,
                    0x2000u,
                    "chain[%d], imbalance happen, imbalance time = %d, bad asi list:\n",
                    v6,
                    *(_DWORD *)((char *)&unk_C1DF4 + v46));
                  sub_41DB8(3, (const char *)v57, 0);
                }
                v36 = 0;
                *(_DWORD *)v50 = 0;
                v51 = 0;
                v52 = 0;
                v53 = 0;
                v54 = 0;
                memset(v56, 0, sizeof(v56));
                if ( v43 )
                {
                  v37 = &s[v10];
                  do
                  {
                    v38 = *v37++;
                    snprintf(v50, 0x14u, "%3d ", v38);
                    v39 = strlen(v56);
                    v40 = (_WORD *)stpcpy(&v56[v39], v50);
                    v21 = v36 == 10 * (v36 / 0xA);
                    ++v36;
                    if ( v21 )
                      *v40 = 10;
                  }
                  while ( v43 != v36 );
                }
                if ( (unsigned int)off_BC5EC > 3 )
                {
                  snprintf((char *)v57, 0x2000u, "%s", v56);
                  goto LABEL_67;
                }
              }
LABEL_54:
              sub_4FB28(21, 0);
              sub_473B4(0xBu, "Unbalance happened, waiting!\n");
            }
          }
          ++v45;
          v48 += dword_65BCD0[v6];
          goto LABEL_9;
        }
        byte_664DEC = 0;
        ++dword_C1DE0;
      }
LABEL_9:
      ++v6;
      ++v5;
      if ( v6 == 4 )
      {
        v7 = sub_27EB8();
        v8 = v45 > 0;
        if ( v7 != v45 )
          v8 = 0;
        if ( v8 )
        {
          byte_664DEC = 1;
          dword_663CE0 = sub_96518(v48, v45);
        }
        return;
      }
    }
  }
  do
  {
    if ( sub_27EC8(v2) )
    {
      sub_7E930((unsigned __int8)v2, 1, 0, 0x90u, 0);
      sub_4465C(&dword_C1DC0[2 * v2]);
    }
    ++v2;
  }
  while ( v2 != 4 );
  dword_BBCA4 = 0;
}
// 353A0: variable 'v1' is possibly undefined
// 35670: variable 'v28' is possibly undefined
// 123D4: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 98278: using guessed type __int16 word_98278;
// BBCA4: using guessed type int dword_BBCA4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C1DC0: using guessed type __time_t dword_C1DC0[8];
// C1DE0: using guessed type int dword_C1DE0;
// C1DE4: using guessed type _DWORD dword_C1DE4[4];
// C3F4C: using guessed type _BYTE byte_C3F4C[1024];
// 65BCD0: using guessed type _DWORD dword_65BCD0[8196];
// 663CE0: using guessed type int dword_663CE0;
// 663CE4: using guessed type _DWORD dword_663CE4[1025];
// 664DE8: using guessed type unsigned __int8 byte_664DE8[4];
// 664DEC: using guessed type char byte_664DEC;
// 664DF0: using guessed type _DWORD dword_664DF0[256];
// 6651F0: using guessed type _DWORD dword_6651F0[1024];
// 674930: using guessed type double dbl_674930[4];
// 674950: using guessed type _DWORD dword_674950[1024];
// 679950: using guessed type int dword_679950[];
// 679954: using guessed type int dword_679954;
// 679958: using guessed type int dword_679958;
// 67995C: using guessed type int dword_67995C;

//----- (00035A10) --------------------------------------------------------
int sub_35A10()
{
  int result; // r0
  bool v1; // zf
  int v2; // r2
  unsigned int v3; // r0
  unsigned int v4; // r0
  __time_t v5; // [sp+0h] [bp-200Ch] BYREF
  unsigned int seed; // [sp+4h] [bp-2008h]
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  sub_4465C(&v5);
  result = (int)dword_4D41E4;
  v1 = dword_4D41E4[0] == 0;
  if ( !dword_4D41E4[0] )
    v1 = dword_4D41E4[1] == 0;
  if ( v1 )
    return sub_4465C(dword_4D41E4);
  v2 = v5 - dword_4D41E4[0];
  if ( (int)(seed - dword_4D41E4[1]) < 0 )
    --v2;
  if ( v2 > 300 && byte_BDC88 )
  {
    if ( dword_C1E04 )
    {
      if ( dword_C1E04 + 299 < v2 && !dword_C1E08 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "network connection lost for 5 min + %d seconds, power off...", dword_C1E04);
          sub_41DB8(3, s, 0);
        }
        result = sub_21D18();
        dword_C1E08 = 1;
      }
    }
    else
    {
      sub_473B4(3u, "network connection lost");
      v4 = sub_3C444();
      if ( !v4 )
        v4 = seed;
      srandom(v4);
      result = random();
      dword_C1E04 = result % 300 + 1;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "will power off in %d seconds in case not resume", result % 300 + 1);
        return sub_41DB8(3, s, 0);
      }
    }
  }
  else if ( dword_C1E08 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "network connection resume, restart");
      sub_41DB8(3, s, 0);
    }
    result = sub_473B4(6u, "network connection resume, restart...");
    dword_C1E08 = 0;
    dword_C1E04 = 0;
  }
  else if ( dword_C1E04 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "network connection resume");
      sub_41DB8(3, s, 0);
    }
    v3 = sub_473A4();
    result = sub_473B4(v3, 0);
    dword_C1E04 = 0;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDC88: using guessed type char byte_BDC88;
// C1E04: using guessed type int dword_C1E04;
// C1E08: using guessed type int dword_C1E08;
// 4D41E4: using guessed type __time_t dword_4D41E4[2];

//----- (00035C78) --------------------------------------------------------
void __noreturn sub_35C78()
{
  int v0; // r4
  int v1; // r0
  unsigned int v2; // r0
  unsigned int v3; // r5
  int v4; // r4
  int v5; // r0
  __int64 v6[2]; // [sp+8h] [bp-2010h] BYREF
  char v7[8192]; // [sp+18h] [bp-2000h] BYREF

  v0 = 0;
  v1 = sub_63E74();
  sub_63EA0(v1 | 0x10000);
  prctl(15, "nonce_reg_process", 0, 0, 0);
  while ( 1 )
  {
    v2 = sub_6352C();
    if ( v2 != 1 )
      break;
    while ( (unsigned int)++v0 <= 1 )
    {
LABEL_9:
      sub_44890();
      v2 = sub_6352C();
      if ( v2 != 1 )
        goto LABEL_3;
    }
    v5 = sub_63E74();
    sub_63EA0(v5 | 0x10000);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v7, "nonce fifo flush because of misalign_count.\n");
      sub_41DB8(3, v7, 0);
    }
  }
LABEL_3:
  v3 = v2 >> 1;
  if ( v2 >> 1 )
  {
    v4 = 0;
    do
    {
      while ( 1 )
      {
        sub_635B4(v6);
        if ( (v6[0] & 0x80000000LL) != 0 )
          break;
        ++v4;
        sub_3EFDC(v6);
        if ( v3 == v4 )
          goto LABEL_8;
      }
      ++v4;
      sub_3EBCC(v6);
    }
    while ( v3 != v4 );
  }
LABEL_8:
  v0 = 0;
  goto LABEL_9;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00035D88) --------------------------------------------------------
time_t sub_35D88()
{
  int v0; // r4
  char *v1; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    v0 = *_errno_location();
    v1 = strerror(v0);
    snprintf(s, 0x2000u, "Failed to get sysinfo, errno = %u, reason = %s.\n", v0, v1);
    sub_41DB8(3, s, 0);
  }
  return time(0);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00035DF8) --------------------------------------------------------
int sub_35DF8()
{
  double v0; // d0
  int i; // r10
  int result; // r0
  double v3; // d8
  int v4; // r4
  int v5; // r6
  int *v6; // r8
  int v7; // r4
  int *v8; // r5
  int v9; // t1
  char *v10; // r7
  double v11; // d10
  char v12; // r0
  char v13; // r3
  unsigned int v14; // r1
  _BYTE v15[4]; // [sp+1Ch] [bp-10h] BYREF
  int v16; // [sp+20h] [bp-Ch] BYREF
  int v17; // [sp+24h] [bp-8h]

  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      result = sub_27D1C();
      v5 = result;
      if ( result > 0 )
      {
        v6 = &dword_D17C4[256 * i];
        v7 = 0;
        v8 = &dword_6651F0[256 * i];
        do
        {
          while ( 1 )
          {
            v9 = *v8++;
            if ( v9 == 1 )
            {
              v10 = (char *)&unk_401010 + 4 * v7;
              if ( *(int *)&v10[(_DWORD)v6] <= 29 )
              {
                v17 = 0;
                v16 = 0;
                result = sub_257E0(i, v7);
                v11 = v0;
                if ( v0 >= 50.0 )
                  break;
              }
            }
            if ( v5 == ++v7 )
              goto LABEL_3;
          }
          sub_27D8C();
          sub_2A728(i, 0);
          v0 = v0 - 15.0;
          *(float *)&v0 = v11 - 15.0;
          sub_7F80C((int)&v16, v15, 0);
          BYTE2(v17) = v15[0];
          v12 = sub_27D8C();
          v13 = v7++;
          result = sub_2A7AC(i, 0, (unsigned __int8)(v12 * v13), (unsigned __int8)byte_4D4184, v16, v17);
          *(v8 - 1) = 2;
          v14 = LODWORD(flt_C1E0C);
          *(_DWORD *)&v10[(_DWORD)v6] = (int)((double)*(int *)&v10[(_DWORD)v6] + 15.0);
          LODWORD(flt_C1E0C) = (unsigned int)((double)v14 + 15.0);
        }
        while ( v5 != v7 );
      }
    }
LABEL_3:
    ;
  }
  if ( !byte_C1E10 )
  {
    v3 = (double)LODWORD(flt_C1E0C);
    v4 = sub_27EB8();
    result = 5 * sub_27D1C() * v4;
    if ( v3 > (double)result * 0.8 )
      byte_C1E10 = 1;
  }
  return result;
}
// 35F28: variable 'v0' is possibly undefined
// C1E0C: using guessed type float flt_C1E0C;
// C1E10: using guessed type char byte_C1E10;
// D17C4: using guessed type int dword_D17C4[3];
// 4D4184: using guessed type char byte_4D4184;
// 6651F0: using guessed type _DWORD dword_6651F0[1024];

//----- (00036010) --------------------------------------------------------
time_t sub_36010()
{
  struct sysinfo v1; // [sp+0h] [bp-44h] BYREF

  if ( sysinfo(&v1) )
    return sub_35D88();
  else
    return v1.uptime;
}

//----- (00036040) --------------------------------------------------------
void sub_36040()
{
  time_t v0; // r0
  __int64 v1; // r8
  int v2; // r3
  int v3; // r4
  double v4; // r0
  double v5; // d6
  int v6; // r5
  const char *v7; // r0
  double v8; // d8
  double v9; // d7
  char v11; // r0
  int v12; // r0
  bool v13; // nf
  const char *v14; // r0
  unsigned int v15; // r8
  FILE *v16; // r4
  time_t tv_sec; // [sp+2Ch] [bp-2010h] BYREF
  struct timeval tv; // [sp+30h] [bp-200Ch] BYREF
  struct tm s[186]; // [sp+38h] [bp-2004h] BYREF

  v0 = sub_36010();
  v1 = qword_AB7A58;
  v2 = dword_C1E14;
  dword_C1E14 = v0;
  v3 = v0 - v2;
  LODWORD(v4) = sub_96AD4(qword_AB7A58 - qword_6661F0);
  qword_6661F0 = v1;
  v5 = v4 * 4294967300.0 / 1000000000.0;
  if ( v3 )
    v5 = v5 / (double)v3;
  dbl_AB7A50 = v5;
  if ( sub_29C30() && sub_29CB0() )
    dbl_AB7A50 = (double)(unsigned int)sub_29EA0();
  if ( (double)sub_22EC0() * 0.75 > dbl_AB7A50 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_6;
    snprintf((char *)s, 0x2000u, "avg rate is lower than ideal rate, %0.2f in %ld mins\n", dbl_AB7A50, v3 / 60);
    sub_41DB8(3, (const char *)s, 0);
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf((char *)s, 0x2000u, "30m avg rate is %0.2f in %ld mins\n", dbl_AB7A50, v3 / 60);
    sub_41DB8(3, (const char *)s, 0);
  }
LABEL_6:
  v6 = sub_22EC0();
  v7 = (const char *)sub_27CEC();
  if ( !strcmp(v7, "HHB56601") || (v14 = (const char *)sub_27CEC(), !strcmp(v14, "HHB56611")) )
  {
    if ( v6 >= 260000 )
      v6 = 260000;
  }
  if ( sub_4CB28() )
  {
    v11 = sub_4CB44();
    v8 = (double)v6;
    if ( v3 > 1499 )
      v12 = v11 & 1;
    else
      v12 = 0;
    v9 = (double)SLODWORD(flt_C1E18) + dbl_AB7A50;
    if ( v12 )
    {
      if ( v9 < v8 )
      {
        dword_C1E1C = 0;
        sub_4B6FC();
        sub_4CB54();
        v9 = (double)SLODWORD(flt_C1E18) + dbl_AB7A50;
      }
      else
      {
        v13 = dword_C1E1C++ - 1 < 0;
        if ( !(v13 ^ __OFSUB__(dword_C1E1C, 2) | (dword_C1E1C == 2)) )
        {
          sub_4CB54();
          dword_C1E1C = 0;
          v9 = (double)SLODWORD(flt_C1E18) + dbl_AB7A50;
        }
      }
    }
  }
  else
  {
    v8 = (double)v6;
    v9 = (double)SLODWORD(flt_C1E18) + dbl_AB7A50;
  }
  if ( v3 > 1739 && v8 * 1.1 < v9 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf((char *)s, 0x2000u, "avg rate is abnormal, %0.2f in %ld mins\n", v9, v3 / 60);
      sub_41DB8(3, (const char *)s, 0);
    }
    v15 = sub_2A974((unsigned __int8)byte_4D4184);
    v16 = fopen("/tmp/miner/hashrate.log", "a");
    if ( v16 )
    {
      tv.tv_sec = 0;
      tv.tv_usec = 0;
      gettimeofday(&tv, 0);
      tv_sec = tv.tv_sec;
      localtime_r(&tv_sec, s);
      fprintf(
        v16,
        "[%d-%02d-%02d %02d:%02d:%02d] %d %0.2f %d\n",
        s[0].tm_year + 1900,
        s[0].tm_mon + 1,
        s[0].tm_mday,
        s[0].tm_hour,
        s[0].tm_min,
        s[0].tm_sec,
        v6,
        (double)SLODWORD(flt_C1E18) + dbl_AB7A50,
        v15);
      fclose(v16);
    }
    sub_4FB28(14, 255);
    sub_473B4(0x15u, "hash rate abnormal");
  }
}
// 360B4: variable 'v4' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C1E14: using guessed type int dword_C1E14;
// C1E18: using guessed type float flt_C1E18;
// C1E1C: using guessed type int dword_C1E1C;
// 4D4184: using guessed type char byte_4D4184;
// 6661F0: using guessed type __int64 qword_6661F0;
// AB7A50: using guessed type double dbl_AB7A50;
// AB7A58: using guessed type __int64 qword_AB7A58;

//----- (00036470) --------------------------------------------------------
int sub_36470()
{
  time_t v0; // r0
  int v1; // r2
  unsigned int *v2; // r9
  int v3; // r7
  unsigned int v4; // r10
  unsigned int *v5; // r6
  int v6; // r3
  __int64 v7; // r4
  int v8; // r12
  int v9; // r2
  int v10; // r3
  int v11; // r5
  bool v12; // zf
  int result; // r0
  unsigned int v14; // r8
  unsigned int v15; // r11
  unsigned int v16; // r4
  unsigned __int64 v17; // r0
  __int64 v18; // r0
  double v19; // r0
  double v20; // d5
  unsigned __int64 v21; // [sp+10h] [bp-2024h]
  int v22; // [sp+2Ch] [bp-2008h]
  char s[8196]; // [sp+30h] [bp-2004h] BYREF

  if ( dword_C34B8 == 1 )
  {
    memset(&unk_C1E20, 0, 0x20u);
    dword_C34B8 = 0;
  }
  v0 = sub_36010();
  v1 = dword_C1E40;
  LOWORD(v2) = (unsigned __int16)&dword_C1CB4;
  LOWORD(v3) = (unsigned __int16)&dword_AB79C8;
  LOWORD(v4) = -21845;
  dword_C1E40 = v0;
  v5 = (unsigned int *)&unk_C1E20;
  v6 = v0 - v1;
  v7 = -2004318071LL * (v0 - v1);
  v8 = (v0 - v1) >> 31;
  if ( v0 == v1 )
    v9 = 1;
  else
    v9 = v0 - v1;
  HIWORD(v2) = (unsigned int)&dword_C1CB4 >> 16;
  HIWORD(v3) = (unsigned int)&dword_AB79C8 >> 16;
  HIWORD(v4) = -21846;
  v10 = v6 + HIDWORD(v7);
  v11 = 0;
  v21 = v9;
  v22 = (v10 >> 5) - v8;
  do
  {
    while ( 1 )
    {
      v12 = sub_27EC8(v11) == 0;
      result = v3 + 8 * v11;
      if ( !v12 )
      {
        v14 = *(_DWORD *)(8 * v11 + v3);
        v15 = *(_DWORD *)(result + 4);
        v16 = *v2;
        LODWORD(v17) = sub_96DFC(0xFFFFFFFEFFFFFFFFLL * (__PAIR64__(v15, v14) - *(_QWORD *)v5), v21);
        LODWORD(v18) = sub_96DFC(v17, 0x3B9ACA00u);
        LODWORD(v19) = sub_96AD4(v18);
        v20 = v19;
        *v5 = v14;
        v5[1] = v15;
        dbl_65B9C8[24 * v11 + v16 - 24 * ((unsigned int)((v16 * (unsigned __int64)v4) >> 32) >> 4)] = v19;
        result = 24 * v11 + v16 - 1 - 24 * ((unsigned int)(((v16 - 1) * (unsigned __int64)v4) >> 32) >> 4);
        if ( v16 > 1 && v20 < dbl_65B9C8[result] * 0.75 && (unsigned int)off_BC5EC > 3 )
          break;
      }
      ++v11;
      v5 += 2;
      if ( v11 == 4 )
        goto LABEL_12;
    }
    snprintf(s, 0x2000u, "chain %d hash rate %.2f low in %ld mins", v11++, v20, v22);
    result = sub_41DB8(3, s, 0);
    v5 += 2;
  }
  while ( v11 != 4 );
LABEL_12:
  ++*v2;
  return result;
}
// 36564: variable 'v17' is possibly undefined
// 36568: variable 'v18' is possibly undefined
// 3656C: variable 'v19' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C1CB4: using guessed type int dword_C1CB4;
// C1E40: using guessed type int dword_C1E40;
// C34B8: using guessed type int dword_C34B8;
// 65B9C8: using guessed type double dbl_65B9C8[96];
// AB79C8: using guessed type int dword_AB79C8;

//----- (0003669C) --------------------------------------------------------
void __noreturn sub_3669C()
{
  double v0; // d0
  const char *v1; // r0
  int v2; // r8
  time_t v3; // r5
  unsigned int v4; // r0
  unsigned int v5; // r4
  unsigned int v6; // r7
  unsigned int v7; // r7
  int v8; // r10
  double v9; // d8
  double v10; // d9
  int v11; // r0
  int *v12; // r7
  int v13; // r9
  int v14; // r7
  int *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  int v28; // [sp+14h] [bp-28h]
  int v29; // [sp+2Ch] [bp-10h]

  prctl(15, "chk_sys", 0);
  v1 = (const char *)sub_27CEC();
  if ( !strcmp(v1, "BHB28601") )
    goto LABEL_2;
  v16 = (const char *)sub_27CEC();
  if ( !strcmp(v16, "BHB28701") )
    goto LABEL_2;
  v17 = (const char *)sub_27CEC();
  if ( !strcmp(v17, "HHB68502") )
    goto LABEL_36;
  v18 = (const char *)sub_27CEC();
  if ( !strcmp(v18, "HHB68501") )
    goto LABEL_36;
  v19 = (const char *)sub_27CEC();
  if ( !strcmp(v19, "HHB68701") )
    goto LABEL_36;
  v20 = (const char *)sub_27CEC();
  if ( !strcmp(v20, "HHB68704")
    || (v21 = (const char *)sub_27CEC(), !strcmp(v21, "HHB68703"))
    || (v22 = (const char *)sub_27CEC(), !strcmp(v22, "H6HB68702"))
    || (v23 = (const char *)sub_27CEC(), !strcmp(v23, "H1HB68601"))
    || (v24 = (const char *)sub_27CEC(), !strcmp(v24, "HHB68601"))
    || (v25 = (const char *)sub_27CEC(), !strcmp(v25, "HHB68602"))
    || (v26 = (const char *)sub_27CEC(), !strcmp(v26, "HHB56611"))
    || (v27 = (const char *)sub_27CEC(), !strcmp(v27, "HHB68503")) )
  {
LABEL_36:
    v2 = 0;
  }
  else
  {
LABEL_2:
    v2 = 1;
  }
  v3 = sub_36010();
  while ( 1 )
  {
    if ( sub_47394() == 2 )
    {
      v4 = sub_36010() - v3;
      if ( *(_QWORD *)&dword_AB7A58 || v4 > 0x708 )
        break;
    }
    sub_44890();
  }
  dword_C1E44 = sub_36010();
  dword_C1E14 = dword_C1E44;
  dword_C1E48 = dword_C1E44;
  dword_C1E40 = dword_C1E44;
  *(_QWORD *)&dword_6661F0 = 0;
  pthread_setcancelstate(1, 0);
  v5 = 1;
  while ( 1 )
  {
    do
    {
      v6 = v5 % 0x78;
      if ( v5 == 120 * (v5 / 0x78) )
      {
        if ( sub_226E8() )
        {
          pthread_setcancelstate(1, (int *)v6);
          sub_226B4();
          pthread_setcancelstate(v6, (int *)v6);
          v8 = (int)*(float *)&v0;
          sub_2878C((int)*(float *)&v0);
          v9 = dbl_AB7A50;
          if ( dbl_AB7A50 <= 100.0 )
          {
            sub_27F18();
            v9 = v0;
          }
          v10 = *(float *)&v0 * 1000.0 / v9;
          v0 = v10;
          sub_287C0();
          pthread_setcancelstate(1, 0);
          v11 = sub_18F28();
          v12 = (int *)dword_C1E4C;
          v13 = v11;
          if ( !dword_C1E4C )
          {
            v12 = sub_835A0("bmminer_power");
            dword_C1E4C = (int)v12;
          }
          v29 = sub_2242C();
          sub_85464(
            (int)v12,
            "thread.c",
            8,
            (int)"check_system_work_thread",
            24,
            689,
            20,
            (int)"%d/%.2f/%.2f/%d/%d",
            v8,
            v28,
            v9 / 1000.0,
            v10,
            v13,
            v29);
          pthread_setcancelstate(0, 0);
          sleep(1u);
          if ( (int)v5 > 300 )
          {
            pthread_setcancelstate(1, 0);
            v14 = sub_7315C(0, 0);
            pthread_setcancelstate(0, 0);
            sleep(1u);
            if ( v14 )
            {
              v15 = (int *)dword_C1E4C;
              if ( !dword_C1E4C )
              {
                v15 = sub_835A0("bmminer_power");
                dword_C1E4C = (int)v15;
              }
              sub_85464(
                (int)v15,
                "thread.c",
                8,
                (int)"check_system_work_thread",
                24,
                707,
                20,
                (int)"power err_code:0x%08x\n",
                v14);
            }
          }
          else
          {
            sleep(1u);
          }
          if ( sub_4CB28() )
            sub_4CB78();
        }
        else
        {
          sub_2878C(0);
          v0 = 0.0;
          sub_287C0();
        }
      }
      if ( !pthread_mutex_trylock(&stru_C1E50) )
      {
        if ( byte_C1E68 )
        {
          pthread_setcancelstate(1, 0);
          sub_4CE14();
          pthread_setcancelstate(0, 0);
        }
        pthread_mutex_unlock(&stru_C1E50);
      }
      ++v5;
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      sub_44890();
      pthread_setcancelstate(1, 0);
      v7 = v5 % 0x1E;
    }
    while ( v5 != 30 * (v5 / 0x1E) || !v2 );
    if ( sub_27EC8(v5 % 0x1E) )
    {
LABEL_19:
      sub_27D8C();
      sub_4D358();
    }
    while ( ++v7 != 4 )
    {
      if ( sub_27EC8(v7) )
        goto LABEL_19;
    }
  }
}
// 36890: variable 'v0' is possibly undefined
// 36924: variable 'v28' is possibly undefined
// C1E14: using guessed type int dword_C1E14;
// C1E40: using guessed type int dword_C1E40;
// C1E44: using guessed type int dword_C1E44;
// C1E48: using guessed type int dword_C1E48;
// C1E4C: using guessed type int dword_C1E4C;
// C1E68: using guessed type char byte_C1E68;
// 6661F0: using guessed type int dword_6661F0;
// AB7A50: using guessed type double dbl_AB7A50;
// AB7A58: using guessed type int dword_AB7A58;

//----- (00036B94) --------------------------------------------------------
time_t sub_36B94()
{
  time_t result; // r0

  result = sub_36010();
  dword_C1E44 = result;
  dword_C1E14 = result;
  dword_C1E48 = result;
  dword_C1E40 = result;
  qword_6661F0 = 0;
  return result;
}
// C1E14: using guessed type int dword_C1E14;
// C1E40: using guessed type int dword_C1E40;
// C1E44: using guessed type int dword_C1E44;
// C1E48: using guessed type int dword_C1E48;
// 6661F0: using guessed type __int64 qword_6661F0;

//----- (00036BCC) --------------------------------------------------------
signed int sub_36BCC()
{
  signed int result; // r0

  result = sub_22EC0();
  if ( (double)result * 0.95 > dbl_AB7A50 )
  {
    result = sub_35078();
    if ( result )
      return sub_473B4(0xBu, "Unbalance happened, reboot!\n");
  }
  return result;
}
// AB7A50: using guessed type double dbl_AB7A50;

//----- (00036C28) --------------------------------------------------------
void sub_36C28()
{
  double v0; // d0
  FILE *v1; // r0
  FILE *v2; // r4
  int v3; // r5
  int v4; // r5
  char *v5; // r6
  int v6; // r8
  int tm_hour; // r9
  int tm_min; // r10
  int tm_sec; // r11
  int v10; // r5
  int v11; // r7
  int v12; // r0
  size_t v13; // r0
  int v14; // r4
  int v15; // r0
  int tm_mday; // [sp+28h] [bp-201Ch]
  int v17; // [sp+2Ch] [bp-2018h]
  time_t tv_sec; // [sp+34h] [bp-2010h] BYREF
  struct timeval tv; // [sp+38h] [bp-200Ch] BYREF
  struct tm tp; // [sp+40h] [bp-2004h] BYREF

  v1 = fopen("/tmp/miner/droa.log", "r+");
  v2 = v1;
  if ( v1 )
  {
    fseek(v1, -2, 2);
    v3 = 0;
    while ( fgetc(v2) != 10 )
    {
      ++v3;
      fseek(v2, -2, 1);
    }
    v4 = ~v3;
    fseek(v2, v4, 2);
    v5 = (char *)calloc(0x200u, 1u);
    fgets(v5, 512, v2);
    if ( strstr(v5, "RTime:") )
    {
      tv.tv_sec = 0;
      tv.tv_usec = 0;
      gettimeofday(&tv, 0);
      tv_sec = tv.tv_sec;
      localtime_r(&tv_sec, &tp);
      fseek(v2, v4, 2);
      v6 = ftell(v2);
      memset(v5, 0, 0x200u);
      tm_hour = tp.tm_hour;
      tm_min = tp.tm_min;
      tm_sec = tp.tm_sec;
      tm_mday = tp.tm_mday;
      v17 = tp.tm_mon + 1;
      v10 = tp.tm_year + 1888;
      v11 = sub_2AE18();
      sub_27EF4();
      v12 = sub_47394();
      sprintf(
        v5,
        "%d-%02d-%02d %02d:%02d:%02d RTime:%ld,AR:%1f,RStat:%d\n",
        v10 + 12,
        v17,
        tm_mday,
        tm_hour,
        tm_min,
        tm_sec,
        v11,
        v0,
        v12);
      fprintf(v2, v5);
      fflush(v2);
      fclose(v2);
      v13 = strlen(v5);
      truncate("/tmp/miner/droa.log", v6 + v13);
    }
    else if ( (unsigned int)off_BC5EC > 3 )
    {
      v14 = sub_2AE18();
      sub_27EF4();
      v15 = sub_47394();
      snprintf((char *)&tp, 0x2000u, "RTime:%ld,AR:%f,RStat:%d", v14, v0, v15);
      sub_4297C(3, (const char *)&tp, 0);
    }
    free(v5);
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy((char *)&tp, "droalog open failed in 15 minute");
    sub_41DB8(3, (const char *)&tp, 0);
  }
}
// 36D94: variable 'v0' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00036E98) --------------------------------------------------------
int sub_36E98()
{
  int result; // r0

  if ( byte_664DEC )
    return sub_35DF8();
  return result;
}
// 664DEC: using guessed type char byte_664DEC;

//----- (00036EB0) --------------------------------------------------------
int sub_36EB0()
{
  int v0; // r3
  int v1; // r2
  int v2; // r4
  int v3; // r3
  int v4; // r3
  bool v5; // zf
  int v6; // r3
  int v8; // r1
  time_t v9; // r0
  int *v10; // r9
  double v11; // d8
  unsigned int *v12; // r10
  int v13; // r7
  int v14; // r4
  int v15; // lr
  int v16; // r6
  int v17; // r12
  __int64 v18; // r0
  bool v19; // cc
  int v20; // r0
  __time_t *v21; // r2
  int v22; // r8
  int v23; // r4
  unsigned int v24; // r3
  int v25; // r12
  int v26; // r4
  bool v27; // cf
  __time_t v28; // r3
  int v29; // r1
  __int64 v30; // r0
  double v31; // r0
  double v32; // d6
  int v33; // r4
  time_t v34; // r0
  int v35; // r7
  int v36; // r7
  double v37; // r0
  double v38; // d7
  int v39; // r12
  double *v40; // r3
  double v41; // d6
  __int64 v42; // r0
  int v43; // r2
  __time_t *v44; // r1
  double v45; // d7
  double v46; // d6
  double v47; // d6
  int v48; // [sp+10h] [bp-14h]

  sub_48CC8();
  v0 = dword_C1E6C;
  v1 = dword_C1E6C >> 31;
  if ( !(dword_C1E6C % 5) )
  {
    if ( dword_C34B0 == 1 )
    {
      memset(&unk_C1E70, 0, 0x140u);
      memset(&unk_C1FB0, 0, 0x20u);
      memset(&unk_C1FD0, 0, 0x20u);
      dword_C1FF0[0] = 0;
      dword_C2000[0] = 0;
      dword_C34B0 = 0;
      dword_C1FF4 = 0;
      dword_C1FF8 = 0;
      dword_C1FFC = 0;
      dword_C2004 = 0;
      dword_C2008 = 0;
      dword_C200C = 0;
    }
    v9 = sub_36010();
    v10 = (int *)&unk_C1FD0;
    v11 = 0.0;
    v12 = (unsigned int *)&unk_C1FB0;
    v13 = 0;
    v48 = v9 - dword_C1E44;
    dword_C1E44 = v9;
    do
    {
      if ( sub_27EC8(v13) )
      {
        v14 = dword_C1FF0[v13];
        v15 = dword_AB79C8[2 * v13 + 1];
        v16 = dword_C2000[v13];
        v17 = v14 + 1;
        v18 = 1717986919LL * (v14 + 1);
        v19 = v16 <= 9;
        if ( v16 <= 9 )
          ++v16;
        v20 = v17 >> 31;
        v21 = &dword_C1DC0[20 * v13 + 2 * v14];
        if ( v19 )
          v20 = (int)dword_C2000;
        v22 = *v10;
        if ( v19 )
          *(_DWORD *)(v20 + 4 * v13) = v16;
        LODWORD(v18) = dword_AB79C8[2 * v13];
        v23 = v17 - 10 * ((SHIDWORD(v18) >> 2) - (v17 >> 31));
        v24 = *v12;
        v25 = v10[1];
        dword_C1FF0[v13] = v23;
        v26 = v23 + 10 * v13;
        HIDWORD(v18) = v12[1];
        v27 = (unsigned int)v18 >= v24;
        v28 = v18 - v24;
        v21[44] = v28;
        *v12 = v18;
        v29 = v15 - (HIDWORD(v18) + !v27);
        v21[45] = v29;
        v12[1] = v15;
        LODWORD(v30) = v28 + v22;
        *v10 = v28 + v22;
        HIDWORD(v30) = v25 + __CFADD__(v28, v22) + v29;
        v10[1] = HIDWORD(v30);
        LODWORD(v31) = sub_96AD4(v30);
        v32 = v31 * 4294967300.0 / (double)v16;
        if ( v48 )
          v32 = v32 / (double)v48;
        sub_280EC(v13);
        v11 = v11 + v32 / 1000000000.0;
        *(_QWORD *)v10 -= *(_QWORD *)&dword_C1DC0[2 * v26 + 44];
      }
      ++v13;
      v10 += 2;
      v12 += 2;
    }
    while ( v13 != 4 );
    v33 = 0;
    sub_27EE0();
    sprintf(byte_C3520, "%.2f", v11);
    if ( dword_C34B4 == 1 )
    {
      *(_QWORD *)&dword_C2010 = 0;
      memset(&unk_C2018, 0, 0xB40u);
      dword_C2B58 = 0;
      dword_C34B4 = 0;
    }
    v34 = sub_36010();
    v35 = dword_C1E48;
    dword_C1E48 = v34;
    if ( qword_AB7A58 )
    {
      v36 = v34 - v35;
      LODWORD(v37) = sub_96AD4(0xFFFFFFFFLL * (qword_AB7A58 - *(_QWORD *)&dword_C2010));
      v38 = 1000000000.0;
      v39 = dword_C2B58;
      v40 = (double *)&unk_C2018;
      v41 = v37 / 1000000000.0;
      if ( v36 )
        v38 = (double)v36;
      v42 = 381774871LL * ((unsigned int)dword_C2B58 >> 3);
      v43 = ++dword_C2B58;
      v44 = &dword_C1DC0[2 * (v39 - 360 * (HIDWORD(v42) >> 2))];
      if ( v36 )
        v41 = v41 / v38;
      v45 = 0.0;
      *((double *)v44 + 75) = v41;
      do
      {
        v5 = v43 == v33++;
        if ( v5 )
          goto LABEL_54;
        v46 = *v40++;
        v45 = v45 + v46;
      }
      while ( v33 != 360 );
      if ( (unsigned int)v43 < 0x168 )
      {
LABEL_54:
        v47 = (double)v43;
        goto LABEL_55;
      }
      v47 = 360.0;
LABEL_55:
      dbl_C3530 = v45 / v47;
      sub_27F04();
      v0 = dword_C1E6C;
      v1 = dword_C1E6C >> 31;
      *(_QWORD *)&dword_C2010 = qword_AB7A58;
    }
    else
    {
      v0 = dword_C1E6C;
      v1 = dword_C1E6C >> 31;
    }
  }
  if ( v0 == 10 * (((int)((unsigned __int64)(1717986919LL * v0) >> 32) >> 2) - v1) )
  {
    if ( sub_47394() == 2 )
      sub_3F9E4();
    v0 = dword_C1E6C;
  }
  v2 = v0 + 1;
  v3 = (v0 + 1) >> 31;
  dword_C1E6C = v2;
  if ( v2 == 60 * (v2 / 60) )
  {
    sub_47394();
    sub_49058();
    v2 = dword_C1E6C;
    v3 = dword_C1E6C >> 31;
  }
  if ( v2 == 1800 * (((int)((unsigned __int64)(2443359173LL * v2) >> 32) >> 10) - v3) )
  {
    sub_36040();
    v2 = dword_C1E6C;
    v3 = dword_C1E6C >> 31;
  }
  v4 = 120 * (((int)((unsigned __int64)(2290649225LL * v2) >> 32) >> 6) - v3);
  v5 = v2 == 1200;
  if ( v2 >= 1200 )
    v5 = v4 == v2;
  if ( v5 )
  {
    if ( sub_47394() == 2 )
      sub_48DF4(dword_C1E6C > 1800);
    v2 = dword_C1E6C;
  }
  if ( !byte_C2B5C )
  {
    byte_C2B5C = 1;
    if ( (unsigned int)(dword_4D4180 - 50) <= 0xF9 )
    {
      LODWORD(flt_BBCA8) = (int)((double)SLODWORD(flt_BBCA8) * 300.0 / (double)dword_4D4180 + 0.99);
      dword_BBCAC = (int)((double)dword_BBCAC * 300.0 / (double)dword_4D4180 + 0.99);
    }
  }
  if ( !(_BYTE)dword_BDAC0 )
  {
    if ( byte_C1E68 )
    {
      sub_967AC(v2, dword_BBCAC);
      if ( !v8 )
      {
        if ( sub_47394() == 2 )
        {
          sub_35220(dword_BBCAC);
          if ( dword_C2B60 <= 4 )
          {
            v2 = dword_C1E6C;
            ++dword_C2B60;
          }
          else
          {
            if ( byte_664DEC )
              sub_35DF8();
            v2 = dword_C1E6C;
            dword_C2B60 = 0;
          }
        }
        else
        {
          v2 = dword_C1E6C;
        }
      }
    }
  }
  v6 = v2 >> 31;
  if ( v2 == 60 * (v2 / 60) )
  {
    sub_3F36C();
    sub_3F660();
    v2 = dword_C1E6C;
    v6 = dword_C1E6C >> 31;
  }
  if ( v2 == 180 * (((int)((unsigned __int64)(3054198967LL * v2) >> 32) >> 7) - v6) && !byte_C34C4 )
  {
    sub_36C28();
    v2 = dword_C1E6C;
    v6 = dword_C1E6C >> 31;
  }
  if ( v2 == 900 * (((int)((unsigned __int64)(2443359173LL * v2) >> 32) >> 9) - v6) )
    sub_36470();
  return 0;
}
// 37078: variable 'v8' is possibly undefined
// 37278: variable 'v31' is possibly undefined
// 3739C: variable 'v37' is possibly undefined
// BBCA8: using guessed type float flt_BBCA8;
// BBCAC: using guessed type int dword_BBCAC;
// BDAC0: using guessed type int dword_BDAC0;
// C1DC0: using guessed type __time_t dword_C1DC0[8];
// C1E44: using guessed type int dword_C1E44;
// C1E48: using guessed type int dword_C1E48;
// C1E68: using guessed type char byte_C1E68;
// C1E6C: using guessed type int dword_C1E6C;
// C1FF0: using guessed type int dword_C1FF0[];
// C1FF4: using guessed type int dword_C1FF4;
// C1FF8: using guessed type int dword_C1FF8;
// C1FFC: using guessed type int dword_C1FFC;
// C2000: using guessed type int dword_C2000[];
// C2004: using guessed type int dword_C2004;
// C2008: using guessed type int dword_C2008;
// C200C: using guessed type int dword_C200C;
// C2010: using guessed type int dword_C2010;
// C2B58: using guessed type int dword_C2B58;
// C2B5C: using guessed type char byte_C2B5C;
// C2B60: using guessed type int dword_C2B60;
// C34B0: using guessed type int dword_C34B0;
// C34B4: using guessed type int dword_C34B4;
// C34C4: using guessed type char byte_C34C4;
// C3530: using guessed type double dbl_C3530;
// 4D4180: using guessed type int dword_4D4180;
// 664DEC: using guessed type char byte_664DEC;
// AB79C8: using guessed type int dword_AB79C8[];
// AB7A58: using guessed type __int64 qword_AB7A58;

//----- (000375A0) --------------------------------------------------------
void __noreturn sub_375A0()
{
  prctl(15, "chk_status", 0);
  while ( 1 )
  {
    sub_35A10();
    sub_36EB0();
    sub_44890();
  }
}

//----- (00037918) --------------------------------------------------------
int __fastcall sub_37918(int a1, int a2)
{
  int v4; // r12
  int result; // r0
  int v6; // r3
  int v7; // r1
  int v8; // t1

  v4 = sub_27D1C();
  if ( v4 <= 0 )
    return 0;
  result = 0;
  v6 = 0;
  v7 = a2 + (a1 << 10) - 4;
  do
  {
    ++v6;
    v8 = *(_DWORD *)(v7 + 4);
    v7 += 4;
    result += v8;
  }
  while ( v4 != v6 );
  return result;
}

//----- (00037960) --------------------------------------------------------
int __fastcall sub_37960(int a1, int a2)
{
  int v4; // r0
  int v5; // r5
  int v6; // r3
  int v7; // r2
  int v8; // t1
  int v9; // r0
  int v10; // r5
  int v11; // r0
  int v12; // r1
  int v13; // r4
  int v14; // r2
  int v15; // r1
  int v16; // t1
  int v17; // r0
  double v18; // r0

  v4 = sub_27D1C();
  if ( v4 > 0 )
  {
    v5 = 0;
    v6 = 0;
    v7 = a2 + (a1 << 10) - 4;
    do
    {
      ++v6;
      v8 = *(_DWORD *)(v7 + 4);
      v7 += 4;
      v5 += v8;
    }
    while ( v4 != v6 );
  }
  else
  {
    v5 = 0;
  }
  v9 = sub_27D1C();
  v10 = sub_96518(v5, v9);
  v11 = sub_27D1C();
  if ( v11 <= 0 )
    return sub_27D1C();
  v12 = a2 + (a1 << 10);
  v13 = 0;
  v14 = 0;
  v15 = v12 - 4;
  do
  {
    v16 = *(_DWORD *)(v15 + 4);
    v15 += 4;
    ++v14;
    v13 += (v16 - v10) * (v16 - v10);
  }
  while ( v11 != v14 );
  v17 = sub_27D1C();
  LODWORD(v18) = sub_96518(v13, v17);
  if ( (double)SLODWORD(v18) < 0.0 )
    v18 = sqrt(v18);
  return LODWORD(v18);
}
// 37A30: variable 'v18' is possibly undefined

//----- (00037A3C) --------------------------------------------------------
int sub_37A3C()
{
  unsigned int v0; // r8
  int v1; // r4
  int v2; // r8
  int v3; // r0
  int v4; // r2
  __int64 v5; // r2
  int v6; // r6
  int v7; // r7
  int v8; // r4

  v0 = dword_4D4180;
  v1 = 0;
  dword_4D419C = 10 * ((dword_BC5BC * (dword_4D419C - dword_BC5AC) / 100 + dword_BC5AC) / 10);
  dword_4D4180 = 5 * ((dword_BC5B0 + dword_BC5BC * (dword_4D4180 - dword_BC5B0) / 0x64u) / 5);
  do
  {
    if ( sub_27EC8(v1) )
      sub_24238(v1, (unsigned __int8)byte_4D4184, v0, dword_4D4180, 0, 100);
    ++v1;
  }
  while ( v1 != 4 );
  v2 = sub_2242C();
  v3 = dword_4D419C;
  v4 = dword_4D419C - v2;
  if ( dword_4D419C - v2 < 0 )
    v4 = v2 - dword_4D419C;
  v5 = 3435973837LL * (unsigned int)v4;
  if ( HIDWORD(v5) >> 3 > 1 )
  {
    v7 = v2 + 10 * (HIDWORD(v5) >> 3);
    v8 = v2 + 10;
    do
    {
      v6 = 2 * v2 - v8;
      if ( v3 > v2 )
        v6 = v8;
      sub_21E88(v6, 3u);
      v8 += 10;
      usleep((__useconds_t)sub_30D40);
      v3 = dword_4D419C;
    }
    while ( v8 != v7 );
  }
  else
  {
    v6 = 0;
  }
  if ( v3 != v6 )
    sub_21E88(v3, 3u);
  return sub_2A014(0xFu);
}
// BC5AC: using guessed type int dword_BC5AC;
// BC5B0: using guessed type int dword_BC5B0;
// BC5BC: using guessed type int dword_BC5BC;
// 4D4180: using guessed type int dword_4D4180;
// 4D4184: using guessed type char byte_4D4184;
// 4D419C: using guessed type int dword_4D419C;

//----- (00037BE0) --------------------------------------------------------
int sub_37BE0()
{
  int v0; // r4
  const char *v1; // r0
  int result; // r0
  const char *v3; // r0
  const char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0

  if ( dword_BDA84 == 3 )
    v0 = sub_194F8();
  else
    v0 = sub_19404();
  v1 = (const char *)sub_27CEC();
  if ( strcmp(v1, "HHB68601") )
  {
    v3 = (const char *)sub_27CEC();
    if ( strcmp(v3, "HHB68602") )
    {
      v4 = (const char *)sub_27CEC();
      if ( strcmp(v4, "HHB68502") )
      {
        v5 = (const char *)sub_27CEC();
        if ( strcmp(v5, "HHB68501") )
        {
          v6 = (const char *)sub_27CEC();
          if ( strcmp(v6, "HHB68701") )
          {
            v7 = (const char *)sub_27CEC();
            if ( strcmp(v7, "HHB68704") )
            {
              v8 = (const char *)sub_27CEC();
              if ( strcmp(v8, "HHB68703") )
              {
                v9 = (const char *)sub_27CEC();
                if ( strcmp(v9, "H6HB68702") )
                {
                  v10 = (const char *)sub_27CEC();
                  if ( strcmp(v10, "H1HB68601") )
                  {
                    v11 = (const char *)sub_27CEC();
                    if ( strcmp(v11, "HHB68503") )
                      return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( v0 > 37 )
    return 0;
  result = 6 * (39 - v0);
  if ( result >= 240 )
    return 240;
  return result;
}
// BDA84: using guessed type int dword_BDA84;

//----- (00037D24) --------------------------------------------------------
int sub_37D24()
{
  unsigned int v0; // r5
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "tuning_freq_thread start waiting to work");
    sub_41DB8(3, s, 0);
  }
  sem_wait(&stru_AB7A08);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "tuning freq start");
    sub_41DB8(3, s, 0);
  }
  sub_37BE0();
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "waiting board temp come to %d", 55);
    sub_41DB8(4, s, 0);
  }
  v0 = 0;
  while ( 1 )
  {
    ++v0;
    if ( flt_C47BC >= 55.0 )
      break;
    sub_44890();
    if ( v0 == 10 * (v0 / 0xA) && (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "waiting asic temp to %d, curr temp %f when time %ds", 55, flt_C47BC, v0);
      sub_41DB8(4, s, v0 % 0xA);
      if ( v0 == 10 )
      {
LABEL_13:
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "can not heat up to %d", 55);
          sub_41DB8(3, s, 0);
        }
        break;
      }
    }
    else if ( v0 == 10 )
    {
      goto LABEL_13;
    }
  }
  sub_244C0(
    (int)&dword_AB59A8,
    (int)&dword_AB59B8,
    (unsigned int *)&dword_AB7A18,
    (int)&unk_4D4398,
    &dword_4D41B8,
    (int)&unk_4D41B4,
    byte_4D4184,
    1000);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "tuning_freq_matrix_thread set freq complete");
    sub_41DB8(3, s, 0);
  }
  sub_44890();
  byte_C1E68 = 1;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "tuning freq end");
    sub_41DB8(3, s, 0);
  }
  remove("/config/find_asic_counter");
  return 0;
}
// BC5C4: using guessed type float flt_BC5C4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C1E68: using guessed type char byte_C1E68;
// C47BC: using guessed type float flt_C47BC;
// 4D4184: using guessed type char byte_4D4184;
// 4D41B8: using guessed type unsigned int dword_4D41B8;
// AB59A8: using guessed type int dword_AB59A8;
// AB59B8: using guessed type int dword_AB59B8;
// AB7A08: using guessed type sem_t stru_AB7A08;
// AB7A18: using guessed type int dword_AB7A18;

//----- (00037FF4) --------------------------------------------------------
int sub_37FF4()
{
  int v0; // r0
  const char *v1; // r0
  int result; // r0
  int v3; // r3
  const char *v4; // r0
  const char *v5; // r0

  memset(&dword_C2B68, 0, 0x30u);
  dword_C2B7C = 1065353216;
  dword_C2B88 = 1053609165;
  dword_C2B80 = 1065353216;
  v0 = sub_2242C();
  dword_C2B6C = 1900;
  dword_C2B74 = 1169915904;
  dword_C2B70 = v0;
  v1 = (const char *)sub_27CEC();
  result = strcmp(v1, "HHB68701");
  if ( result
    && (v4 = (const char *)sub_27CEC(), (result = strcmp(v4, "HHB68703")) != 0)
    && (v5 = (const char *)sub_27CEC(), (result = strcmp(v5, "HHB68704")) != 0) )
  {
    v3 = 2150;
  }
  else
  {
    v3 = 2180;
  }
  dword_C2B68 = v3;
  return result;
}
// C2B68: using guessed type int dword_C2B68;
// C2B6C: using guessed type int dword_C2B6C;
// C2B70: using guessed type int dword_C2B70;
// C2B74: using guessed type int dword_C2B74;
// C2B7C: using guessed type int dword_C2B7C;
// C2B80: using guessed type int dword_C2B80;
// C2B88: using guessed type int dword_C2B88;

//----- (000380A8) --------------------------------------------------------
int sub_380A8()
{
  float v0; // s0
  int v1; // r0
  float v2; // s12
  float v3; // s14
  float v4; // s16
  int v5; // r3
  int v6; // r7
  const char *v7; // r0
  int v8; // r7
  int v9; // r9
  int v10; // r10
  int v11; // r11
  int v12; // r0
  const char *v13; // r0
  int v15; // r0
  char v16[8196]; // [sp+0h] [bp-2004h] BYREF

  sub_37FF4();
  while ( !byte_C1E68 )
  {
    if ( (unsigned int)sub_47394() > 2 )
      break;
    pthread_setcancelstate(1, 0);
    v7 = (const char *)sub_27CEC();
    v8 = strcmp(v7, "HHB68501");
    if ( !v8 )
    {
      v9 = 0x7FFF;
      v10 = 0x7FFF;
      do
      {
        if ( sub_27EC8(v8) )
        {
          v11 = sub_18D48(v8, 0);
          v12 = sub_18D48(v8, 1);
          if ( v10 >= v11 )
            v10 = v11;
          if ( v9 >= v12 )
            v9 = v12;
        }
        ++v8;
      }
      while ( v8 != 4 );
      if ( v10 <= 39 )
      {
        if ( v9 > 44 )
          *(float *)&dword_C2B74 = (float)(16 * (sub_22EC0() / 1000) + 200);
      }
      else
      {
        dword_C2B74 = 1169506304;
      }
    }
    sub_226B4();
    flt_C2B78 = (float)(20 * (((int)v0 + 19) / 20));
    v1 = sub_2242C();
    v2 = flt_C2B90;
    v3 = *(float *)&dword_C2B74 - flt_C2B78;
    dword_C2B70 = v1;
    flt_C2B8C = v3;
    v0 = (float)((float)((float)(flt_C2B78
                               + (float)((float)(*(float *)&dword_C2B74 - flt_C2B78) * *(float *)&dword_C2B7C))
                       + (float)((float)((float)(v3 + v2) + flt_C2B94) * flt_C2B84))
               + (float)((float)((float)((float)(v3 - v2) + v2) - flt_C2B94) * *(float *)&dword_C2B88))
       / flt_C2B78;
    v4 = sqrtf(v0);
    if ( v0 < 0.0 )
    {
      sqrtf(*(float *)&v1);
      v2 = flt_C2B90;
      v1 = dword_C2B70;
      v3 = flt_C2B8C;
    }
    v5 = dword_C2B68;
    if ( (unsigned int)((int)(float)((float)v1 * v4) - v1 + 4) > 8 )
      v1 = (int)(float)((float)v1 * v4);
    if ( dword_C2B68 >= v1 )
    {
      v5 = dword_C2B6C;
      if ( v1 >= dword_C2B6C )
        v5 = v1;
    }
    flt_C2B94 = v2;
    flt_C2B90 = v3;
    v6 = (int)(float)v5;
    if ( sub_2242C() != v6 && !byte_C1E68 )
    {
      v13 = (const char *)sub_27CEC();
      if ( !strcmp(v13, "HHB68501") )
      {
        v15 = v6 - sub_2242C();
        if ( v15 < 0 )
          v15 = -v15;
        if ( v15 > 30 )
        {
          if ( sub_2242C() <= v6 )
            v6 = sub_2242C() + 30;
          else
            v6 = sub_2242C() - 30;
        }
      }
      sub_21E88(v6, 3u);
    }
    pthread_setcancelstate(0, 0);
    sleep(0xAu);
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v16, 0x2000u, "thead %s exit ", "vol_adjust_thread");
    sub_41DB8(3, v16, 0);
  }
  return 0;
}
// 380F4: variable 'v0' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C1E68: using guessed type char byte_C1E68;
// C2B68: using guessed type int dword_C2B68;
// C2B6C: using guessed type int dword_C2B6C;
// C2B70: using guessed type int dword_C2B70;
// C2B74: using guessed type int dword_C2B74;
// C2B78: using guessed type float flt_C2B78;
// C2B7C: using guessed type int dword_C2B7C;
// C2B84: using guessed type float flt_C2B84;
// C2B88: using guessed type int dword_C2B88;
// C2B8C: using guessed type float flt_C2B8C;
// C2B90: using guessed type float flt_C2B90;
// C2B94: using guessed type float flt_C2B94;

//----- (000383B0) --------------------------------------------------------
int sub_383B0()
{
  pthread_attr_t attr; // [sp+4h] [bp-2024h] BYREF
  char s[8192]; // [sp+28h] [bp-2000h] BYREF

  if ( dword_C2B98 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  dword_C2B98 = (int)calloc(1u, 0x40u);
  if ( sub_44EC8(dword_C2B98, &attr, (void *(*)(void *))sub_34A78, (void *)dword_C2B98) )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "create thread failed\n");
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_C2B98 + 12));
    if ( (unsigned int)off_BC5EC <= 3 )
      return 0;
    snprintf(s, 0x2000u, "create thread %s\n", "pic_heart_beat_thread");
    sub_41DB8(3, s, 0);
    return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2B98: using guessed type int dword_C2B98;

//----- (000384C4) --------------------------------------------------------
int sub_384C4()
{
  pthread_attr_t attr; // [sp+4h] [bp-2024h] BYREF
  char s[8192]; // [sp+28h] [bp-2000h] BYREF

  if ( dword_C2B9C )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x800000u);
  dword_C2B9C = (int)calloc(1u, 0x40u);
  if ( sub_44EC8(dword_C2B9C, &attr, (void *(*)(void *))sub_35C78, (void *)dword_C2B9C) )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "create thread failed\n");
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_C2B9C + 12));
    if ( (unsigned int)off_BC5EC <= 3 )
      return 0;
    snprintf(s, 0x2000u, "create thread %s\n", "get_nonce_and_register_thread");
    sub_41DB8(3, s, 0);
    return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2B9C: using guessed type int dword_C2B9C;

//----- (000385D8) --------------------------------------------------------
int sub_385D8()
{
  pthread_attr_t attr; // [sp+4h] [bp-2024h] BYREF
  char s[8192]; // [sp+28h] [bp-2000h] BYREF

  if ( dword_C2BA0 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_C2BA0 = (int)calloc(1u, 0x40u);
  if ( sub_44EC8(dword_C2BA0, &attr, (void *(*)(void *))sub_3669C, (void *)dword_C2BA0) )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "create thread failed\n");
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_C2BA0 + 12));
    if ( (unsigned int)off_BC5EC <= 3 )
      return 0;
    snprintf(s, 0x2000u, "create thread %s\n", "check_system_work_thread");
    sub_41DB8(3, s, 0);
    return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2BA0: using guessed type int dword_C2BA0;

//----- (000386EC) --------------------------------------------------------
int sub_386EC()
{
  pthread_attr_t attr; // [sp+4h] [bp-2024h] BYREF
  char s[8192]; // [sp+28h] [bp-2000h] BYREF

  if ( dword_C2BA4 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_C2BA4 = (int)calloc(1u, 0x40u);
  if ( sub_44EC8(dword_C2BA4, &attr, (void *(*)(void *))sub_375A0, (void *)dword_C2BA4) )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "create thread failed\n");
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_C2BA4 + 12));
    if ( (unsigned int)off_BC5EC <= 3 )
      return 0;
    snprintf(s, 0x2000u, "create thread %s\n", "check_miner_status_thread");
    sub_41DB8(3, s, 0);
    return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2BA4: using guessed type int dword_C2BA4;

//----- (00038800) --------------------------------------------------------
int sub_38800()
{
  pthread_attr_t attr; // [sp+4h] [bp-2024h] BYREF
  char s[8192]; // [sp+28h] [bp-2000h] BYREF

  if ( dword_C2BA8 )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  dword_C2BA8 = (int)calloc(1u, 0x40u);
  if ( sub_44EC8(dword_C2BA8, &attr, (void *(*)(void *))sub_37D24, (void *)dword_C2BA8) )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "create thread failed\n");
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_C2BA8 + 12));
    if ( (unsigned int)off_BC5EC <= 3 )
      return 0;
    snprintf(s, 0x2000u, "create thread %s\n", "tuning_freq_thread");
    sub_41DB8(3, s, 0);
    return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2BA8: using guessed type int dword_C2BA8;

//----- (00038914) --------------------------------------------------------
int sub_38914()
{
  pthread_attr_t attr; // [sp+4h] [bp-2024h] BYREF
  char s[8192]; // [sp+28h] [bp-2000h] BYREF

  if ( dword_C2BAC )
    return 0;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  dword_C2BAC = (int)calloc(1u, 0x40u);
  if ( sub_44EC8(dword_C2BAC, &attr, (void *(*)(void *))sub_380A8, (void *)dword_C2BAC) )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "create thread failed\n");
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_C2BAC + 12));
    if ( (unsigned int)off_BC5EC <= 3 )
      return 0;
    snprintf(s, 0x2000u, "create thread %s\n", "vol_adjust_thread");
    sub_41DB8(3, s, 0);
    return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2BAC: using guessed type int dword_C2BAC;

//----- (00038A28) --------------------------------------------------------
void sub_38A28()
{
  int v0; // r5
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  v0 = dword_C2B98;
  if ( dword_C2B98 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_41DB8(3, v1, 0);
      v0 = dword_C2B98;
    }
    sub_44240(v0);
    free((void *)dword_C2B98);
    dword_C2B98 = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2B98: using guessed type int dword_C2B98;

//----- (00038AC8) --------------------------------------------------------
void sub_38AC8()
{
  int v0; // r5
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  v0 = dword_C2B9C;
  if ( dword_C2B9C && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_41DB8(3, v1, 0);
      v0 = dword_C2B9C;
    }
    sub_44240(v0);
    free((void *)dword_C2B9C);
    dword_C2B9C = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2B9C: using guessed type int dword_C2B9C;

//----- (00038B68) --------------------------------------------------------
void sub_38B68()
{
  int v0; // r5
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  v0 = dword_C2BA0;
  if ( dword_C2BA0 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_41DB8(3, v1, 0);
      v0 = dword_C2BA0;
    }
    sub_44240(v0);
    free((void *)dword_C2BA0);
    dword_C2BA0 = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2BA0: using guessed type int dword_C2BA0;

//----- (00038C08) --------------------------------------------------------
void sub_38C08()
{
  int v0; // r5
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  v0 = dword_C2BA4;
  if ( dword_C2BA4 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_41DB8(3, v1, 0);
      v0 = dword_C2BA4;
    }
    sub_44240(v0);
    free((void *)dword_C2BA4);
    dword_C2BA4 = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2BA4: using guessed type int dword_C2BA4;

//----- (00038CA8) --------------------------------------------------------
void sub_38CA8()
{
  int v0; // r5
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  v0 = dword_C2BA8;
  if ( dword_C2BA8 && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_41DB8(3, v1, 0);
      v0 = dword_C2BA8;
    }
    sub_44240(v0);
    free((void *)dword_C2BA8);
    dword_C2BA8 = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2BA8: using guessed type int dword_C2BA8;

//----- (00038D48) --------------------------------------------------------
void sub_38D48()
{
  int v0; // r5
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  v0 = dword_C2BAC;
  if ( dword_C2BAC && *(_DWORD *)(v0 + 12) != pthread_self() )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v1, "cancel thread\n");
      sub_41DB8(3, v1, 0);
      v0 = dword_C2BAC;
    }
    sub_44240(v0);
    free((void *)dword_C2BAC);
    dword_C2BAC = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2BAC: using guessed type int dword_C2BAC;

//----- (00038DE8) --------------------------------------------------------
int __fastcall sub_38DE8(signed int a1, int a2)
{
  char v4[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( a1 > (int)&unk_2DC6C0 )
    a2 |= 1u;
  if ( a2 )
  {
    sub_2A0B4();
    sub_44890();
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v4, 0x2000u, "set UART baud to %d\n", a1);
    sub_41DB8(3, v4, 0);
  }
  sub_29F0C(a1);
  sub_27D8C();
  return sub_1828C();
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00038E70) --------------------------------------------------------
int sub_38E70()
{
  sub_38DE8(12000000, 0);
  return sub_44890();
}

//----- (00038E90) --------------------------------------------------------
int __fastcall sub_38E90(const void *a1, size_t a2)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  return sub_826D8((int)aBitmainSubmitN, a1, a2, &v3);
}

//----- (00038EC4) --------------------------------------------------------
int __fastcall sub_38EC4(const void *a1, size_t a2)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  return sub_826D8((int)aBitmainApiStat, a1, a2, &v3);
}

//----- (00038EF8) --------------------------------------------------------
int sub_38EF8()
{
  puts("bmminer_socket_init");
  while ( sub_82104((int)&off_BBDB8, 4) )
    sleep(3u);
  puts("regist ..");
  while ( 1 )
  {
    sub_82418((int)aBitmainSubmitN);
    if ( !sub_82418((int)aBitmainApiStat) )
      break;
    sleep(3u);
  }
  puts("regist done!");
  return 0;
}
// BBDB8: using guessed type int (*off_BBDB8)();

//----- (00038F80) --------------------------------------------------------
int __fastcall sub_38F80(int a1)
{
  int *v1; // r1

  if ( dword_C2BB0[0] <= 2 )
  {
    v1 = &dword_C2BB0[dword_C2BB0[0]++];
    v1[1] = a1;
  }
  return 0;
}
// C2BB0: using guessed type int dword_C2BB0[];

//----- (00038FA8) --------------------------------------------------------
int __fastcall sub_38FA8(_BYTE *a1)
{
  *a1 = 1;
  byte_4D4171 = 1;
  return 0;
}
// 4D4171: using guessed type char byte_4D4171;

//----- (00038FC4) --------------------------------------------------------
void __noreturn sub_38FC4(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vsnprintf(s, 0x200u, a1, varg_r1);
  sub_41DB8(3, s, 1);
  exit(1);
}

//----- (0003900C) --------------------------------------------------------
int __fastcall sub_3900C(int a1)
{
  sub_57B1C(a1, &dword_C2DC0);
  return 0;
}
// C2DC0: using guessed type int dword_C2DC0;

//----- (00039024) --------------------------------------------------------
int __fastcall sub_39024(int a1)
{
  sub_57B1C(a1, &dword_C2DC4);
  return 0;
}
// C2DC4: using guessed type int dword_C2DC4;

//----- (0003903C) --------------------------------------------------------
int __fastcall sub_3903C(int a1)
{
  sub_57B1C(a1, &dword_C2DC8);
  return 0;
}
// C2DC8: using guessed type int dword_C2DC8;

//----- (00039054) --------------------------------------------------------
int __fastcall sub_39054(int a1)
{
  sub_57B1C(a1, &dword_6662A8);
  return 0;
}
// 6662A8: using guessed type int dword_6662A8;

//----- (0003906C) --------------------------------------------------------
void __fastcall __noreturn sub_3906C(const char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", byte_C2DCC);
  v2 = sub_58AB8((const char *)dword_AB7A70, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// BDA14: using guessed type int stdout;
// AB7A70: using guessed type int dword_AB7A70;

//----- (000390C4) --------------------------------------------------------
int sub_390C4()
{
  int v0; // r4
  char *v1; // r0
  _DWORD *v2; // r8
  const char *v3; // r0
  const char *v4; // r0
  __int64 v5; // r4
  _DWORD *v6; // r10
  const char *v7; // r0
  char *v8; // r4
  size_t v9; // r0
  unsigned int *v10; // r3
  unsigned int v11; // r2
  unsigned int v12; // r2
  _DWORD *v14; // r6
  _QWORD *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  struct sysinfo info; // [sp+18h] [bp-2044h] BYREF
  char s[8196]; // [sp+58h] [bp-2004h] BYREF

  prctl(15, "api", 0);
  while ( !*(_BYTE *)(dword_66620C + 364) )
  {
    pthread_mutex_lock(&stru_C2ECC);
    pthread_cond_wait(&cond, &stru_C2ECC);
    if ( sysinfo(&info) )
    {
      if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 5 )
      {
        v0 = *_errno_location();
        v1 = strerror(v0);
        snprintf(s, 0x2000u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
        sub_41DB8(6, s, 0);
      }
      LODWORD(flt_6682B0) = time(0);
    }
    else
    {
      flt_6682B0 = *(float *)&info.uptime;
    }
    v2 = sub_7C134();
    sub_2AE4C((int)v2);
    sub_2AEF4((int)v2);
    sub_2AF9C((int)v2);
    sub_2B044((int)v2);
    sub_2B12C((int)v2);
    sub_2B23C((int)v2);
    sub_2B324((int)v2);
    sub_2B414((int)v2);
    sub_2B4E8((int)v2);
    sub_2B6B8((int)v2);
    v3 = (const char *)sub_27CEC();
    if ( !strcmp(v3, "HHB68502") )
      goto LABEL_10;
    v4 = (const char *)sub_27CEC();
    if ( !strcmp(v4, "HHB68501") )
      goto LABEL_10;
    v16 = (const char *)sub_27CEC();
    if ( !strcmp(v16, "HHB68701") )
      goto LABEL_10;
    v17 = (const char *)sub_27CEC();
    if ( !strcmp(v17, "HHB68704")
      || (v18 = (const char *)sub_27CEC(), !strcmp(v18, "HHB68703"))
      || (v19 = (const char *)sub_27CEC(), !strcmp(v19, "H6HB68702"))
      || (v20 = (const char *)sub_27CEC(), !strcmp(v20, "H1HB68601"))
      || (v21 = (const char *)sub_27CEC(), !strcmp(v21, "HHB68601"))
      || (v22 = (const char *)sub_27CEC(), !strcmp(v22, "HHB68602"))
      || (v23 = (const char *)sub_27CEC(), !strcmp(v23, "HHB56611"))
      || (v24 = (const char *)sub_27CEC(), !strcmp(v24, "HHB68503")) )
    {
LABEL_10:
      sub_2B8CC((int)v2);
    }
    v5 = 0;
    v6 = sub_7CC78();
    do
    {
      if ( sub_27EC8(v5) )
      {
        v14 = sub_7C134();
        if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
        {
          snprintf(s, 0x2000u, "%s: now i = %d", "bitmain_update_api_stats", (_DWORD)v5);
          sub_41DB8(7, s, 0);
        }
        v15 = sub_7DEB4(v5);
        sub_7C380(v14, "index", v15);
        sub_2BA54((int)v14, v5);
        sub_2BB18((int)v14, v5);
        sub_2BC24((int)v14, v5);
        sub_2BD30((int)v14, v5);
        sub_2BDF4(v14, v5);
        sub_2BEE8((int)v14, v5);
        sub_2C474((int)v14, v5);
        sub_2C278((int)v14, v5);
        sub_2C768((int)v14, v5);
        sub_2C5D8((int)v14, v5);
        sub_2C82C((int)v14, v5);
        sub_2C8F4((int)v14, v5);
        sub_2C9C8(v14, v5);
        sub_2CAC4(v14, v5);
        sub_2CB10(v14, v5);
        sub_2CB70(v14, v5);
        sub_2CBBC(v14, v5);
        sub_2CC14(v14, v5);
        sub_2CF40((int)v14);
        sub_7D114(v6, v14);
      }
      ++v5;
    }
    while ( v5 != 4 );
    sub_7C380(v2, "chain", v6);
    sub_2CD44((int)v2);
    sub_2CDEC((int)v2);
    sub_2CE98((int)v2);
    sub_2CCC0(v2);
    v7 = (const char *)sub_767AC(v2, 0);
    v8 = (char *)v7;
    if ( v7 )
    {
      v9 = strlen(v7);
      sub_38EC4(v8, v9 + 1);
      free(v8);
    }
    if ( v2 )
    {
      if ( v2[1] != -1 )
      {
        v10 = v2 + 1;
        __dmb(0xBu);
        do
        {
          v11 = __ldrex(v10);
          v12 = v11 - 1;
        }
        while ( __strex(v12, v10) );
        if ( !v12 )
          sub_7E3BC(v2);
      }
    }
    pthread_mutex_unlock(&stru_C2ECC);
  }
  return 0;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 66620C: using guessed type int dword_66620C;
// 6682B0: using guessed type float flt_6682B0;
// 6682BC: using guessed type char byte_6682BC;

//----- (000395F4) --------------------------------------------------------
void __fastcall __noreturn sub_395F4(int a1)
{
  int v2; // r4
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  sigaction(15, &stru_66A31C, 0);
  sigaction(2, &stru_66C3DC, 0);
  sigaction(6, &stru_666214, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v3, 0x2000u, "sig:%d", a1);
    sub_41DB8(3, v3, 0);
  }
  v2 = 30;
  system("dmesg > /nvdata/diag_dmsg.txt");
  system("netstat -anpt > /nvdata/diag_netstat.txt");
  system("top -n 1 -b > /nvdata/diag_top.txt");
  system("free -m > /nvdata/diag_mem.txt");
  system("df -h > /nvdata/diag_df.txt");
  sub_47198();
  sub_471D4();
  do
  {
    sub_44890();
    --v2;
  }
  while ( v2 );
  sub_3427C();
  exit(0);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 666214: using guessed type struct sigaction stru_666214;
// 66A31C: using guessed type struct sigaction stru_66A31C;
// 66C3DC: using guessed type struct sigaction stru_66C3DC;

//----- (000396E8) --------------------------------------------------------
const char *__fastcall sub_396E8(const char *a1, int a2)
{
  bool v4; // nf
  _DWORD *v7; // r0
  size_t v8; // r6
  size_t v9; // r6
  char *v10; // r4
  char *v11; // r6
  void *v12; // r4
  char v13[92]; // [sp+Ch] [bp-100h] BYREF
  char v14[164]; // [sp+68h] [bp-A4h] BYREF

  if ( !dword_C2F18 )
    dword_C2F18 = (int)_strdup(a1);
  v4 = dword_C2F1C - 9 < 0;
  ++dword_C2F1C;
  if ( !(v4 ^ __OFSUB__(dword_C2F1C, 10) | (dword_C2F1C == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  v7 = sub_7AD44(a1, 0, v13);
  if ( v7 && !*v7 )
  {
    v11 = sub_39830(v7, a2, 1);
    if ( !v11 )
      return 0;
    v12 = sub_43798(0xC8u, "bmminer.c", "load_config", 948);
    sub_45268(v12, v11, 0xC8u, (int)"bmminer.c", (int)"load_config", 949);
    return (const char *)v12;
  }
  else
  {
    v8 = strlen(a1);
    v9 = v8 + strlen(v14) + 35;
    v10 = (char *)sub_43798(v9, "bmminer.c", "load_config", 937);
    snprintf(v10, v9, "JSON decode of file '%s' failed\n %s", a1, v14);
    return v10;
  }
}
// C2F18: using guessed type int dword_C2F18;
// C2F1C: using guessed type int dword_C2F1C;

//----- (00039830) --------------------------------------------------------
char *__fastcall sub_39830(_DWORD *a1, int a2, int a3)
{
  int v4; // r3
  int v5; // r4
  int v6; // r3
  const char *v7; // r0
  char *v8; // r11
  char *v9; // r5
  _DWORD *v10; // r0
  int v11; // r1
  int v12; // r2
  const char *v13; // r2
  _DWORD *v14; // r0
  int v15; // r0
  _BYTE *v17; // r0
  int v18; // r0
  _DWORD *v19; // r11
  unsigned int v20; // r5
  _DWORD *v21; // r0
  int v22; // r0
  int v25; // [sp+10h] [bp-2014h]
  char *v26; // [sp+10h] [bp-2014h]
  const char *v27; // [sp+14h] [bp-2010h]
  char *v28; // [sp+14h] [bp-2010h]
  int v29; // [sp+18h] [bp-200Ch]
  const char *v30; // [sp+1Ch] [bp-2008h]
  char s[8196]; // [sp+20h] [bp-2004h] BYREF

  if ( a3 && !dword_C2FE8 )
    dword_C2FE8 = 1;
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 == 16 )
    goto LABEL_28;
  if ( (v4 & 8) != 0 )
LABEL_53:
    _assert_fail("!(opt->type & OPT_SUBTABLE)", "bmminer.c", 0x302u, "parse_config");
  v5 = a2 + 28;
  while ( 1 )
  {
    v7 = *(const char **)(v5 - 28);
    if ( !v7 )
    {
      v6 = *(_DWORD *)(v5 + 4);
      if ( v6 == 16 )
        break;
      goto LABEL_8;
    }
    v8 = _strdup(v7);
    v9 = strtok(v8, "|");
    if ( !v9 )
      goto LABEL_27;
    while ( 2 )
    {
      if ( v9[1] != 45 )
        goto LABEL_12;
      v10 = (_DWORD *)sub_7C250(a1, v9 + 2);
      if ( !v10 )
        goto LABEL_12;
      v11 = *(_DWORD *)(v5 - 24);
      v12 = *v10;
      if ( (v11 & 6) == 0 )
      {
LABEL_18:
        if ( (unsigned int)(v12 - 5) > 1 )
        {
          v13 = "Invalid value";
          goto LABEL_21;
        }
        v17 = *(_BYTE **)(v5 - 8);
        if ( (v11 & 1) == 0 )
        {
          if ( v12 == 5 )
            sub_57A38(v17);
          else
            sub_57A48(v17);
          goto LABEL_12;
        }
        v13 = (const char *)(*(int (__fastcall **)(_BYTE *))(v5 - 20))(v17);
        goto LABEL_33;
      }
      if ( v12 == 2 )
      {
        v25 = sub_7DA40(v10);
        v18 = (*(int (__fastcall **)(int, _DWORD))(v5 - 16))(v25, *(_DWORD *)(v5 - 8));
        v13 = (const char *)v18;
        if ( *(_DWORD *)(v5 - 24) == 4 )
        {
          v27 = (const char *)v18;
          sub_57B1C(v25, *(_DWORD **)(v5 - 8));
          v13 = v27;
        }
LABEL_33:
        if ( !v13 )
          goto LABEL_12;
        if ( a3 )
          goto LABEL_22;
LABEL_35:
        snprintf(byte_C2F20, 0xC8u, "Parsing JSON option %s: %s", v9, v13);
        return byte_C2F20;
      }
      if ( v12 != 1 )
        goto LABEL_18;
      v26 = v8;
      v19 = v10;
      v28 = v9;
      v20 = 0;
      if ( !sub_7CD9C(v10) )
      {
LABEL_46:
        v8 = v26;
        goto LABEL_12;
      }
      while ( 1 )
      {
        v21 = (_DWORD *)sub_7CDE8(v19, v20);
        if ( !v21 )
          goto LABEL_46;
        if ( *v21 == 2 )
          break;
        if ( !*v21 )
        {
          v13 = (const char *)sub_39830();
          goto LABEL_49;
        }
LABEL_45:
        if ( sub_7CD9C(v19) <= ++v20 )
          goto LABEL_46;
      }
      v29 = sub_7DA40(v21);
      v22 = (*(int (__fastcall **)(int, _DWORD))(v5 - 16))(v29, *(_DWORD *)(v5 - 8));
      v13 = (const char *)v22;
      if ( *(_DWORD *)(v5 - 24) == 4 )
      {
        v30 = (const char *)v22;
        sub_57B1C(v29, *(_DWORD **)(v5 - 8));
        v13 = v30;
      }
LABEL_49:
      if ( !v13 )
        goto LABEL_45;
      v8 = v26;
      v9 = v28;
LABEL_21:
      if ( !a3 )
        goto LABEL_35;
LABEL_22:
      if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
      {
        snprintf(s, 0x2000u, "Invalid config option %s: %s", v9, v13);
        sub_41DB8(3, s, 0);
      }
      dword_C2FE8 = -1;
LABEL_12:
      v9 = strtok(0, "|");
      if ( v9 )
        continue;
      break;
    }
LABEL_27:
    free(v8);
    v6 = *(_DWORD *)(v5 + 4);
    if ( v6 == 16 )
      break;
LABEL_8:
    v5 += 28;
    if ( (v6 & 8) != 0 )
      goto LABEL_53;
  }
LABEL_28:
  v14 = (_DWORD *)sub_7C250(a1, "include");
  if ( !v14 || *v14 != 2 )
    return 0;
  v15 = sub_7DA40(v14);
  return (char *)sub_396E8(v15, a2, 0);
}
// 396E8: using guessed type int __fastcall sub_396E8(_DWORD, _DWORD, _DWORD);
// BC5F4: using guessed type int dword_BC5F4;
// C2FE8: using guessed type int dword_C2FE8;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (00039BCC) --------------------------------------------------------
char *__fastcall sub_39BCC(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_57C38(a1, a2);
  if ( !result && *a2 > 0x270Fu )
    return "Value out of range";
  return result;
}

//----- (00039BFC) --------------------------------------------------------
char *__fastcall sub_39BFC(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_57C38(a1, a2);
  if ( !result && *a2 > 0x64u )
    return "Value out of range";
  return result;
}

//----- (00039C28) --------------------------------------------------------
char *__fastcall sub_39C28(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_57C38(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 0xFFFE )
    return "Value out of range";
  return result;
}

//----- (00039C5C) --------------------------------------------------------
int __fastcall sub_39C5C(const char *a1, const char *a2, int a3)
{
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  snprintf(s, 0x2000u, "Free work called with NULL work from %s %s:%d", a1, a2, a3);
  return sub_41DB8(3, s, 0);
}

//----- (00039CA4) --------------------------------------------------------
int __fastcall sub_39CA4(const char *a1, int a2)
{
  int *v4; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x2000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", a1, a2);
  return sub_41DB8(3, s, 1);
}

//----- (00039D00) --------------------------------------------------------
int __fastcall sub_39D00(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  result = pthread_rwlock_init(a1, 0);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x2000u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v6, "bmminer.c", a2, a3);
    return sub_41DB8(3, s, 1);
  }
  return result;
}

//----- (00039D74) --------------------------------------------------------
int __fastcall sub_39D74(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  result = pthread_rwlock_wrlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x2000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "bmminer.c", a2, a3);
    return sub_41DB8(3, s, 1);
  }
  return result;
}

//----- (00039DE8) --------------------------------------------------------
int __fastcall sub_39DE8(const char *a1, int a2)
{
  int *v4; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x2000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", a1, a2);
  return sub_41DB8(3, s, 1);
}

//----- (00039E44) --------------------------------------------------------
int __fastcall sub_39E44(const char *a1, int a2)
{
  int *v4; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x2000u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v4, "bmminer.c", a1, a2);
  return sub_41DB8(3, s, 1);
}

//----- (00039EA0) --------------------------------------------------------
int __fastcall sub_39EA0(const char *a1, int a2)
{
  int *v4; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x2000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", a1, a2);
  return sub_41DB8(3, s, 1);
}

//----- (00039EFC) --------------------------------------------------------
int __fastcall sub_39EFC(int a1, const char *a2, int a3)
{
  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    sub_39E44(a2, a3);
  return sub_39D00((pthread_rwlock_t *)(a1 + 24), a2, a3);
}

//----- (00039F40) --------------------------------------------------------
_DWORD *sub_39F40()
{
  _DWORD *v0; // r4
  int v1; // r5
  int *v3; // r0
  int *v4; // r0
  int *v5; // r0
  int *v6; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v0 = sub_4382C(1u, 0x1C0u, "bmminer.c", "make_work", 1416);
  if ( !v0 )
  {
    strcpy(s, "Failed to calloc work in make_work");
    sub_41DB8(3, s, 1);
  }
  if ( pthread_mutex_lock(&stru_6682C0) )
  {
    v3 = _errno_location();
    snprintf(s, 0x2000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v3, "bmminer.c", "total_work_inc", 1407);
    sub_41DB8(3, s, 1);
    if ( !pthread_rwlock_wrlock(&rwlock) )
      goto LABEL_5;
  }
  else if ( !pthread_rwlock_wrlock(&rwlock) )
  {
    goto LABEL_5;
  }
  v4 = _errno_location();
  snprintf(s, 0x2000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "bmminer.c", "total_work_inc", 1407);
  sub_41DB8(3, s, 1);
LABEL_5:
  v1 = dword_C2FEC++;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v5 = _errno_location();
    snprintf(s, 0x2000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v5, "bmminer.c", "total_work_inc", 1409);
    sub_41DB8(3, s, 1);
  }
  if ( pthread_mutex_unlock(&stru_6682C0) )
  {
    v6 = _errno_location();
    snprintf(s, 0x2000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "bmminer.c", "total_work_inc", 1409);
    sub_41DB8(3, s, 1);
  }
  off_BC718();
  v0[85] = v1;
  return v0;
}
// BC718: using guessed type int (*off_BC718)();
// C2FEC: using guessed type int dword_C2FEC;
// 6682C0: using guessed type pthread_mutex_t stru_6682C0;

//----- (0003A16C) --------------------------------------------------------
char *__fastcall sub_3A16C(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0
  _BOOL4 v8; // r4
  int v9; // r3

  result = sub_57C38(a1, a2);
  if ( !result )
  {
    v8 = *a2 < a3;
    if ( *a2 > a4 )
      v9 = v8 | 1;
    else
      v9 = v8;
    if ( v9 )
      return "Value out of range";
  }
  return result;
}

//----- (0003A1B8) --------------------------------------------------------
int __fastcall sub_3A1B8(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (0003A1E8) --------------------------------------------------------
char *__fastcall sub_3A1E8(char *a1)
{
  size_t v2; // r0
  char *v3; // r12
  size_t v4; // lr
  char *v6; // r0

  if ( dword_6662A8 && *(_BYTE *)dword_6662A8 )
    return strcpy(a1, (const char *)dword_6662A8);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    *(_WORD *)stpcpy(a1, v6) = 47;
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".bmminer/");
  mkdir(a1, 0x1FFu);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  *(_DWORD *)&a1[v4] = *(_DWORD *)"bmminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return *(char **)"bmminer.conf";
}
// 123D4: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 6662A8: using guessed type int dword_6662A8;

//----- (0003A2E4) --------------------------------------------------------
int sub_3A2E4()
{
  char *v0; // r0

  dword_C2F18 = (int)sub_43798(0x1000u, "bmminer.c", "load_default_config", 991);
  sub_3A1E8((char *)dword_C2F18);
  if ( access((const char *)dword_C2F18, 4) )
  {
    free((void *)dword_C2F18);
    dword_C2F18 = 0;
    return 0;
  }
  else
  {
    v0 = (char *)sub_396E8((const char *)dword_C2F18, (int)&off_BBFD8);
    if ( v0 )
    {
      free(v0);
      return 0;
    }
    else
    {
      return 1;
    }
  }
}
// BBFD8: using guessed type char *off_BBFD8;
// C2F18: using guessed type int dword_C2F18;

//----- (0003A36C) --------------------------------------------------------
void *__fastcall sub_3A36C(void *a1)
{
  double v1; // d0
  __int64 v3; // r0
  __int64 v4; // r6
  double v5; // r0
  double v6; // d8
  __int64 v7; // r0
  __int64 v8; // kr00_8
  double v9; // r0
  double v10; // d8
  __int64 v11; // r0
  int v12; // r9
  double v13; // r0
  unsigned int v14; // r0
  int v15; // r1
  int v16; // r3
  const char *v18; // r0
  char *v19; // r6
  int v20; // [sp+Ch] [bp-2028h]
  _DWORD v21[4]; // [sp+10h] [bp-2024h] BYREF
  __int64 v22; // [sp+20h] [bp-2014h]
  __int64 v23; // [sp+28h] [bp-200Ch]
  char v24[8196]; // [sp+30h] [bp-2004h] BYREF

  if ( v1 == 0.0 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      v4 = 4294901760LL;
      strcpy(v24, "Diff zero passed to set_target");
      sub_41DB8(3, v24, 0);
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v12 = 0;
      v8 = 0;
    }
    else
    {
      v14 = 0;
      v4 = 4294901760LL;
      v15 = 0;
      v16 = 0;
      v12 = 0;
      v8 = 0;
    }
  }
  else
  {
    LODWORD(v3) = sub_96E60(2.69595353e67 / v1 * 1.59309191e-58);
    v4 = v3;
    LODWORD(v5) = sub_96AD4(v3);
    v6 = 2.69595353e67 / v1 - v5 * 6.27710174e57;
    LODWORD(v7) = sub_96E60(v6 * 2.93873588e-39);
    v8 = v7;
    LODWORD(v9) = sub_96AD4(v7);
    v10 = v6 - v9 * 3.40282367e38;
    LODWORD(v11) = sub_96E60(v10 * 5.42101086e-20);
    v12 = HIDWORD(v11);
    v20 = v11;
    LODWORD(v13) = sub_96AD4(v11);
    v14 = sub_96E60(v10 - v13 * 1.84467441e19);
    v16 = v20;
  }
  v21[2] = v16;
  v21[0] = v14;
  v23 = v4;
  v22 = v8;
  v21[3] = v12;
  v21[1] = v15;
  if ( byte_4D4172 )
  {
    v18 = sub_43A28((int)v21, 32);
    v19 = (char *)v18;
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      snprintf(v24, 0x2000u, "Generated target %s", v18);
      sub_41DB8(7, v24, 0);
    }
    free(v19);
  }
  return sub_45268(a1, v21, 0x20u, (int)"bmminer.c", (int)"set_target", 1172);
}
// 3A388: variable 'v1' is possibly undefined
// 3A3A8: variable 'v3' is possibly undefined
// 3A3C0: variable 'v5' is possibly undefined
// 3A3D4: variable 'v7' is possibly undefined
// 3A3E8: variable 'v9' is possibly undefined
// 3A3FC: variable 'v11' is possibly undefined
// 3A40C: variable 'v13' is possibly undefined
// 3A444: variable 'v15' is possibly undefined
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003A614) --------------------------------------------------------
__int64 __fastcall sub_3A614(int a1, int a2)
{
  pthread_mutex_t *v2; // r9
  int v5; // r11
  void *v6; // r0
  size_t v7; // r2
  int v8; // r3
  int v9; // r2
  int v10; // r6
  const void *v11; // r1
  int *v12; // r1
  int *v13; // r0
  unsigned int v14; // t1
  int v15; // r1
  int *v16; // r2
  unsigned int v17; // t1
  double v18; // d8
  unsigned __int64 v19; // r0
  int v20; // r6
  char *v21; // r6
  int v22; // r0
  double v23; // d7
  double v24; // d7
  double v25; // d7
  double v27; // r0
  double v28; // d8
  double v29; // r0
  double v30; // d8
  double v31; // r0
  double v32; // d8
  double v33; // r0
  double v34; // d7
  int v35; // r0
  int v36; // r0
  char *v37; // r10
  const char *v38; // r0
  char *v39; // r11
  int v40; // r0
  int *v41; // r0
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  int *v45; // r0
  int *v46; // r0
  int v47; // r0
  pthread_rwlock_t *rwlock; // [sp+14h] [bp-20B8h]
  int v49; // [sp+20h] [bp-20ACh] BYREF
  int v50; // [sp+24h] [bp-20A8h] BYREF
  _BYTE v51[28]; // [sp+28h] [bp-20A4h] BYREF
  char v52; // [sp+44h] [bp-2088h] BYREF
  char v53[28]; // [sp+48h] [bp-2084h] BYREF
  int v54; // [sp+64h] [bp-2068h] BYREF
  _BYTE v55[28]; // [sp+68h] [bp-2064h] BYREF
  char v56; // [sp+84h] [bp-2048h] BYREF
  char v57[60]; // [sp+88h] [bp-2044h] BYREF
  int v58; // [sp+C4h] [bp-2008h] BYREF
  char s[136]; // [sp+C8h] [bp-2004h] BYREF
  int v60; // [sp+150h] [bp-1F7Ch] BYREF

  v2 = (pthread_mutex_t *)(a1 + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
  {
    v41 = _errno_location();
    snprintf(s, 0x2000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v41, "bmminer.c", "gen_stratum_work", 1316);
    sub_41DB8(3, s, 1);
  }
  rwlock = (pthread_rwlock_t *)(a1 + 236);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v42 = _errno_location();
    snprintf(
      s,
      0x2000u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v42,
      "bmminer.c",
      "gen_stratum_work",
      1316);
    sub_41DB8(3, s, 1);
  }
  v5 = *(_DWORD *)(a1 + 644);
  v6 = (void *)(*(_DWORD *)(a1 + 1584) + *(_DWORD *)(a1 + 1592));
  v7 = *(_DWORD *)(a1 + 648);
  v49 = *(_DWORD *)(a1 + 640);
  v50 = v5;
  sub_45268(v6, &v49, v7, (int)"bmminer.c", (int)"gen_stratum_work", 1321);
  v8 = *(_DWORD *)(a1 + 640);
  v9 = *(_DWORD *)(a1 + 644);
  *(_DWORD *)(a1 + 640) = v8 + 1;
  *(_DWORD *)(a1 + 644) = __CFADD__(v8, 1) + v9;
  *(_DWORD *)(a2 + 296) = v8;
  *(_DWORD *)(a2 + 300) = v9;
  *(_DWORD *)(a2 + 304) = *(_DWORD *)(a1 + 648);
  if ( !pthread_rwlock_unlock(rwlock) )
  {
    if ( !pthread_rwlock_rdlock(rwlock) )
      goto LABEL_7;
LABEL_62:
    v44 = _errno_location();
    snprintf(
      s,
      0x2000u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v44,
      "bmminer.c",
      "gen_stratum_work",
      1327);
    sub_41DB8(3, s, 1);
    if ( !pthread_mutex_unlock(v2) )
      goto LABEL_8;
    goto LABEL_63;
  }
  v43 = _errno_location();
  snprintf(
    s,
    0x2000u,
    "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v43,
    "bmminer.c",
    "gen_stratum_work",
    1327);
  sub_41DB8(3, s, 1);
  if ( pthread_rwlock_rdlock(rwlock) )
    goto LABEL_62;
LABEL_7:
  if ( !pthread_mutex_unlock(v2) )
    goto LABEL_8;
LABEL_63:
  v45 = _errno_location();
  snprintf(s, 0x2000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v45, "bmminer.c", "gen_stratum_work", 1327);
  sub_41DB8(3, s, 1);
LABEL_8:
  sub_4357C(*(char **)(a1 + 1584), *(_DWORD *)(a1 + 1588), s);
  sub_4357C(s, 0x20u, v51);
  sub_45268(v53, v51, 0x20u, (int)"bmminer.c", (int)"gen_stratum_work", 1331);
  if ( *(int *)(a1 + 1724) > 0 )
  {
    v10 = 0;
    do
    {
      v11 = *(const void **)(*(_DWORD *)(a1 + 692) + 4 * v10++);
      sub_45268(v55, v11, 0x20u, (int)"bmminer.c", (int)"gen_stratum_work", 1335);
      sub_4357C(v53, 0x40u, s);
      sub_4357C(s, 0x20u, v51);
      sub_45268(v53, v51, 0x20u, (int)"bmminer.c", (int)"gen_stratum_work", 1337);
    }
    while ( *(_DWORD *)(a1 + 1724) > v10 );
  }
  v12 = (int *)&v52;
  v13 = &v50;
  do
  {
    v14 = v12[1];
    ++v12;
    v13[1] = bswap32(v14);
    ++v13;
  }
  while ( &v54 != v12 );
  sub_45268((void *)a2, (const void *)(a1 + 1596), 0x70u, (int)"bmminer.c", (int)"gen_stratum_work", 1346);
  sub_45268((void *)(a2 + 36), v51, 0x20u, (int)"bmminer.c", (int)"gen_stratum_work", 1347);
  *(_QWORD *)(a2 + 312) = *(_QWORD *)(a1 + 1840);
  *(_DWORD *)(a2 + 288) = _strdup(*(const char **)(a1 + 688));
  *(_DWORD *)(a2 + 320) = _strdup(*(const char **)(a1 + 628));
  *(_DWORD *)(a2 + 308) = _strdup((const char *)(a1 + 1820));
  if ( pthread_rwlock_unlock(rwlock) )
  {
    v46 = _errno_location();
    snprintf(
      s,
      0x2000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v46,
      "bmminer.c",
      "gen_stratum_work",
      1358);
    sub_41DB8(3, s, 1);
  }
  off_BC718();
  if ( byte_4D4172 )
  {
    v37 = sub_43A28(a2, 112);
    v38 = sub_43A28((int)v51, 32);
    v39 = (char *)v38;
    if ( byte_4D4172 )
    {
      if ( !byte_6682BC && !byte_4D4171 && dword_BC5F4 <= 6 )
        goto LABEL_52;
      snprintf(s, 0x2000u, "Generated stratum merkle %s", v38);
      sub_41DB8(7, s, 0);
      if ( !byte_4D4172 )
        goto LABEL_58;
      if ( !byte_6682BC )
      {
LABEL_52:
        if ( !byte_4D4171 && dword_BC5F4 <= 6 )
          goto LABEL_55;
      }
      snprintf(s, 0x2000u, "Generated stratum header %s", v37);
      sub_41DB8(7, s, 0);
      if ( byte_4D4172 )
      {
        if ( byte_6682BC )
        {
LABEL_57:
          snprintf(
            s,
            0x2000u,
            "Work job_id %s nonce2 %llu ntime %s",
            *(const char **)(a2 + 288),
            *(_QWORD *)(a2 + 296),
            *(const char **)(a2 + 308));
          sub_41DB8(7, s, 0);
          goto LABEL_58;
        }
LABEL_55:
        if ( !byte_4D4171 && dword_BC5F4 <= 6 )
          goto LABEL_58;
        goto LABEL_57;
      }
    }
LABEL_58:
    free(v37);
    free(v39);
  }
  v15 = a2 - 4;
  v16 = (int *)&v56;
  do
  {
    v17 = *(_DWORD *)(v15 + 4);
    v15 += 4;
    v16[1] = bswap32(v17);
    ++v16;
  }
  while ( &v58 != v16 );
  sub_433B4(s);
  sub_433E4((unsigned __int8 *)s, v57, 0x40u);
  sub_45268((void *)(a2 + 128), &v60, 0x20u, (int)"bmminer.c", (int)"calc_midstate", 1077);
  sub_3A36C((void *)(a2 + 160));
  ++dword_66C46C;
  if ( time(0) - dword_C2FF0 > 5 )
  {
    dword_C2FF0 = time(0);
    dword_C2FF4 = dword_66C46C;
  }
  v18 = *(double *)(a2 + 312);
  *(_BYTE *)(a2 + 284) = 1;
  *(_DWORD *)(a2 + 260) = a1;
  *(_DWORD *)(a2 + 248) = 0;
  *(_BYTE *)(a2 + 280) = 0;
  *(_DWORD *)(a2 + 336) = 0;
  *(_BYTE *)(a2 + 440) = 83;
  *(_DWORD *)(a2 + 244) = 60;
  if ( v18 == 0.0 )
  {
    LODWORD(v27) = sub_96AD4(*(_QWORD *)(a2 + 184));
    v28 = v27 * 6.27710174e57;
    LODWORD(v29) = sub_96AD4(*(_QWORD *)(a2 + 176));
    v30 = v28 + v29 * 3.40282367e38;
    LODWORD(v31) = sub_96AD4(*(_QWORD *)(a2 + 168));
    v32 = v30 + v31 * 1.84467441e19;
    LODWORD(v33) = sub_96AD4(*(_QWORD *)(a2 + 160));
    v34 = v33 + v32;
    if ( v33 + v32 == 0.0 )
    {
      v18 = 2.69595353e67;
      v19 = -1;
    }
    else
    {
      v18 = 2.69595353e67 / v34;
      round();
      LODWORD(v19) = sub_96E60(2.69595353e67 / v34);
    }
    *(double *)(a2 + 376) = v18;
  }
  else
  {
    *(double *)(a2 + 376) = v18;
    round();
    LODWORD(v19) = sub_96E60(v18);
  }
  *(double *)(a1 + 480) = v18;
  v20 = *(_DWORD *)(a2 + 260);
  *(_WORD *)s = 0;
  v21 = (char *)(v20 + 48);
  if ( v19 > 0xDE0B6B3A763FFFFLL )
  {
    v22 = sub_96DFC(v19, 0x38D7EA4C68000uLL);
    strcpy(s, "E");
    v23 = (double)v22 / 1000.0;
LABEL_24:
    snprintf(v21, 8u, "%.3g%s", v23, s);
    goto LABEL_25;
  }
  if ( v19 > 0x38D7EA4C67FFFLL )
  {
    v35 = sub_96DFC(v19, 0xE8D4A51000uLL);
    strcpy(s, "P");
    v23 = (double)v35 / 1000.0;
    goto LABEL_24;
  }
  if ( v19 > 0xE8D4A50FFFLL )
  {
    v40 = sub_96DFC(v19, 0x3B9ACA00u);
    strcpy(s, "T");
    v23 = (double)v40 / 1000.0;
    goto LABEL_24;
  }
  if ( v19 > 0x3B9AC9FF )
  {
    v36 = sub_96DFC(v19, (unsigned int)&unk_F4240);
    strcpy(s, "G");
    v23 = (double)v36 / 1000.0;
    goto LABEL_24;
  }
  if ( v19 > 0xF423F )
  {
    v47 = sub_96DFC(v19, 0x3E8u);
    strcpy(s, "M");
    v23 = (double)v47 / 1000.0;
    goto LABEL_24;
  }
  if ( v19 > 0x3E7 )
  {
    strcpy(s, "K");
    v23 = (double)(int)v19 / 1000.0;
    goto LABEL_24;
  }
  snprintf(v21, 8u, "%d%s", (_DWORD)v19, s);
LABEL_25:
  v24 = *(double *)(a1 + 464);
  if ( v24 == v18 )
  {
    ++*(_DWORD *)(a1 + 488);
    goto LABEL_27;
  }
  if ( v24 <= v18 )
  {
    if ( v24 != 0.0 )
    {
LABEL_27:
      v25 = *(double *)(a1 + 472);
      if ( v25 != v18 )
        goto LABEL_28;
LABEL_37:
      ++*(_DWORD *)(a1 + 492);
      return sub_4465C((__time_t *)(a2 + 264));
    }
    *(double *)(a1 + 464) = v18;
    *(_DWORD *)(a1 + 488) = 1;
  }
  else
  {
    *(double *)(a1 + 464) = v18;
    *(_DWORD *)(a1 + 488) = 1;
  }
  v25 = *(double *)(a1 + 472);
  if ( v25 == v18 )
    goto LABEL_37;
LABEL_28:
  if ( v25 < v18 )
  {
    *(double *)(a1 + 472) = v18;
    *(_DWORD *)(a1 + 492) = 1;
  }
  return sub_4465C((__time_t *)(a2 + 264));
}
// 3A9F4: variable 'v19' is possibly undefined
// 3AAA4: variable 'v27' is possibly undefined
// 3AAB8: variable 'v29' is possibly undefined
// 3AACC: variable 'v31' is possibly undefined
// 3AAD8: variable 'v33' is possibly undefined
// 1267C: using guessed type int round(void);
// BC5F4: using guessed type int dword_BC5F4;
// BC718: using guessed type int (*off_BC718)();
// C2FF0: using guessed type int dword_C2FF0;
// C2FF4: using guessed type int dword_C2FF4;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 6682BC: using guessed type char byte_6682BC;
// 66C46C: using guessed type int dword_66C46C;

//----- (0003B08C) --------------------------------------------------------
void *__fastcall sub_3B08C(void **a1)
{
  free(a1[72]);
  free(a1[77]);
  free(a1[82]);
  free(a1[80]);
  return memset(a1, 0, 0x1C0u);
}

//----- (0003B0C8) --------------------------------------------------------
void __fastcall sub_3B0C8(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v4; // r5

  v4 = *a1;
  if ( *a1 )
  {
    sub_3B08C(*a1);
    free(v4);
    *a1 = 0;
  }
  else if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    sub_39C5C(a2, a3, a4);
  }
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003B14C) --------------------------------------------------------
int __fastcall sub_3B14C(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6)
{
  pthread_mutex_t *v7; // r7
  int v10; // r9
  unsigned int v11; // r2
  unsigned int v13; // r1

  v7 = (pthread_mutex_t *)(a3 + 212);
  *a2 = (int)sub_39F40();
  v10 = *a1;
  if ( pthread_mutex_lock(v7) )
    sub_39EA0("get_work_by_nonce2", 1471);
  sub_39D74((pthread_rwlock_t *)(a3 + 236), "get_work_by_nonce2", 1471);
  v11 = bswap32(a6);
  *(_QWORD *)(a3 + 640) = a5;
  a6 = v11;
  sub_45268((void *)(a3 + 1596), &a6, 4u, (int)"bmminer.c", (int)"get_work_by_nonce2", 1474);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a3 + 236)) )
  {
    sub_39CA4("get_work_by_nonce2", 1475);
    if ( !pthread_mutex_unlock(v7) )
      goto LABEL_5;
LABEL_7:
    sub_39DE8("get_work_by_nonce2", 1475);
    goto LABEL_5;
  }
  if ( pthread_mutex_unlock(v7) )
    goto LABEL_7;
LABEL_5:
  off_BC718();
  sub_3A614(a3, *a2);
  v13 = a6;
  *(_DWORD *)(*a2 + 260) = a4;
  *(_DWORD *)(*a2 + 256) = v10;
  *(_DWORD *)(*a2 + 336) = 0;
  ++*(_DWORD *)(*(_DWORD *)(*a2 + 260) + 68);
  *(_BYTE *)(*a2 + 272) = 1;
  *(_DWORD *)(*a2 + 444) = v13;
  return 1;
}
// BC718: using guessed type int (*off_BC718)();

//----- (0003B2AC) --------------------------------------------------------
int __fastcall sub_3B2AC(int a1)
{
  int v2; // r12
  int v3; // r2
  int result; // r0
  int (__fastcall *v5)(int); // r3
  int *v6; // r0
  int *v7; // r0
  char s[8192]; // [sp+10h] [bp-2000h] BYREF

  if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
  {
    snprintf(
      s,
      0x2000u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_41DB8(7, s, 0);
  }
  if ( pthread_mutex_lock(&stru_66C3AC) )
  {
    v6 = _errno_location();
    snprintf(s, 0x2000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "bmminer.c", "inc_hw_errors", 1494);
    sub_41DB8(3, s, 1);
  }
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)(v2 + 44) + 1;
  ++dword_666200;
  *(_DWORD *)(v2 + 44) = v3;
  if ( pthread_mutex_unlock(&stru_66C3AC) )
  {
    v7 = _errno_location();
    snprintf(s, 0x2000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v7, "bmminer.c", "inc_hw_errors", 1497);
    sub_41DB8(3, s, 1);
  }
  result = off_BC718();
  v5 = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84);
  if ( v5 )
    return v5(a1);
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// BC718: using guessed type int (*off_BC718)();
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 666200: using guessed type int dword_666200;
// 6682BC: using guessed type char byte_6682BC;
// 66C3AC: using guessed type pthread_mutex_t stru_66C3AC;

//----- (0003B468) --------------------------------------------------------
time_t sub_3B468()
{
  time_t result; // r0
  int v1; // r4
  char *v2; // r0
  struct sysinfo v3; // [sp+0h] [bp-2140h] BYREF
  char s[256]; // [sp+40h] [bp-2100h] BYREF
  char v5[8192]; // [sp+140h] [bp-2000h] BYREF

  if ( sysinfo(&v3) )
  {
    v1 = *_errno_location();
    v2 = strerror(v1);
    sprintf(s, "Failed to get sysinfo, errno:%u, reason:%s\n", v1, v2);
    result = time(0);
    dword_6661FC = result;
    LODWORD(flt_6682B0) = result + 1;
  }
  else
  {
    dword_6661FC = v3.uptime;
    LODWORD(flt_6682B0) = v3.uptime + 1;
    result = sprintf(s, "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n", v3.uptime, v3.uptime + 1);
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
    {
      snprintf(v5, 0x2000u, "%s", s);
      return sub_41DB8(5, v5, 0);
    }
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6661FC: using guessed type int dword_6661FC;
// 6682B0: using guessed type float flt_6682B0;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003B578) --------------------------------------------------------
int sub_3B578()
{
  FILE *v0; // r6
  signed int v1; // r0
  char *v2; // r0
  char *v3; // r6
  int v4; // r6
  char *v5; // r0
  size_t v6; // r0
  int v7; // r3
  size_t v8; // r0
  int v9; // r3
  bool v10; // zf
  int v11; // r6
  FILE *v12; // r7
  signed int v13; // r0
  char *v14; // r0
  FILE *v15; // r7
  signed int v16; // r0
  char *v17; // r0
  int v18; // r7
  int result; // r0
  int v20; // r3
  char v21[256]; // [sp+10h] [bp-2104h] BYREF
  char s[8196]; // [sp+110h] [bp-2004h] BYREF

  v0 = fopen((const char *)dword_C2DC8, "rb");
  memset(v21, 0, sizeof(v21));
  if ( v0 )
  {
    v1 = fread(v21, 1u, 0x100u, v0);
    if ( v1 <= 0 )
    {
      v11 = (int)&byte_6682BC;
      if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
      {
        snprintf(s, 0x2000u, "Read miner version file %s error %d", (const char *)dword_C2DC8, v1);
        sub_41DB8(3, s, 0);
      }
    }
    else
    {
      v2 = strchr(v21, 10);
      v3 = v2;
      if ( v2 )
      {
        sub_45268(byte_C2FF8, v21, v2 - v21, (int)"bmminer.c", (int)"read_version_file", 1563);
        v4 = stpcpy(v21, v3 + 1);
        v5 = strchr(v21, 10);
        if ( v5 )
          sub_45268(dest, v21, v5 - v21, (int)"bmminer.c", (int)"read_version_file", 1572);
        else
          memcpy(dest, v21, v4 - (_DWORD)v21 + 1);
      }
      else
      {
        strcpy(byte_C2FF8, v21);
      }
      v6 = strlen(byte_C2FF8) - 1;
      v7 = *((unsigned __int8 *)&dword_C2BB0[274] + v6);
      if ( v7 == 10 )
      {
        *((_BYTE *)&dword_C2BB0[274] + v6) = 0;
        v6 = strlen(byte_C2FF8) - 1;
        v7 = *((unsigned __int8 *)&dword_C2BB0[274] + v6);
      }
      if ( v7 == 13 )
        *((_BYTE *)&dword_C2BB0[274] + v6) = 0;
      v8 = strlen(dest) - 1;
      v9 = *((unsigned __int8 *)&dword_C2BB0[338] + v8);
      if ( v9 == 10 )
      {
        *((_BYTE *)&dword_C2BB0[338] + v8) = 0;
        v8 = strlen(dest) - 1;
        v9 = *((unsigned __int8 *)&dword_C2BB0[338] + v8);
      }
      v10 = v9 == 13;
      v11 = 33468;
      if ( v9 == 13 )
      {
        v8 += (size_t)dword_C2BB0;
        LOBYTE(v9) = 0;
      }
      else
      {
        HIWORD(v11) = 102;
      }
      if ( v10 )
      {
        HIWORD(v11) = 102;
        *(_BYTE *)(v8 + 1352) = v9;
      }
    }
  }
  else
  {
    v11 = (int)&byte_6682BC;
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      snprintf(s, 0x2000u, "Open miner version file %s error", (const char *)dword_C2DC8);
      sub_41DB8(3, s, 0);
    }
  }
  v12 = fopen("/usr/bin/v_version", "rb");
  memset(v21, 0, sizeof(v21));
  if ( v12 )
  {
    v13 = fread(v21, 1u, 0x100u, v12);
    if ( v13 <= 0 )
    {
      if ( *(_BYTE *)v11 || byte_4D4171 || dword_BC5F4 > 2 )
      {
        snprintf(s, 0x2000u, "Read miner version file %s error %d", "/usr/bin/v_version", v13);
        sub_41DB8(3, s, 0);
      }
    }
    else
    {
      v14 = strstr(v21, "\r\n");
      if ( v14 )
        sub_45268(byte_C31F8, v21, v14 - v21, (int)"bmminer.c", (int)"read_version_file", 1621);
      else
        strcpy(byte_C31F8, v21);
    }
    fclose(v12);
  }
  else if ( *(_BYTE *)v11 || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "Open miner version file %s error", "/usr/bin/v_version");
    sub_41DB8(3, s, 0);
  }
  v15 = fopen("/config/sn", "rb");
  if ( v15 )
  {
    memset(v21, 0, sizeof(v21));
    v16 = fread(v21, 1u, 0xFAu, v15);
    if ( v16 <= 0 )
    {
      if ( *(_BYTE *)v11 || byte_4D4171 || dword_BC5F4 > 2 )
      {
        snprintf(s, 0x2000u, "Read miner sn file %s error %d", "/config/sn", v16);
        sub_41DB8(3, s, 0);
      }
    }
    else
    {
      v17 = strstr(v21, "\r\n");
      if ( v17 )
        sub_45268(&byte_C32F8, v21, v17 - v21, (int)"bmminer.c", (int)"read_version_file", 1652);
      else
        strcpy(&byte_C32F8, v21);
    }
    fclose(v15);
    v18 = *(unsigned __int8 *)v11;
  }
  else if ( *(_BYTE *)v11 || (v18 = (unsigned __int8)byte_4D4171, byte_4D4171) || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "Open miner sn file %s error", "/config/sn");
    sub_41DB8(3, s, 0);
    v18 = *(unsigned __int8 *)v11;
  }
  result = strlen(&byte_C32F8) - 1;
  v20 = *((unsigned __int8 *)&dword_C2BB0[466] + result);
  if ( v20 == 10 )
  {
    *((_BYTE *)&dword_C2BB0[466] + result) = 0;
    result = strlen(&byte_C32F8) - 1;
    v20 = *((unsigned __int8 *)&dword_C2BB0[466] + result);
  }
  if ( v20 == 13 )
    *((_BYTE *)&dword_C2BB0[466] + result) = 0;
  if ( v18 || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "Miner compile time: %s V:%s type: %s sn :%s", byte_C2FF8, byte_C31F8, dest, &byte_C32F8);
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// 123D4: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// BC5F4: using guessed type int dword_BC5F4;
// C2BB0: using guessed type int dword_C2BB0[];
// C2DC8: using guessed type int dword_C2DC8;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003BBB4) --------------------------------------------------------
char *__fastcall sub_3BBB4(size_t *a1, const char **a2, int a3, char a4)
{
  const char *v4; // r11
  const char *v8; // r10
  size_t v9; // r4
  const char *v10; // r8
  size_t v11; // r4
  size_t v12; // r4
  char *v13; // r0
  char *v14; // r5
  size_t v15; // r7
  size_t v16; // r2
  size_t v17; // r6
  size_t v18; // r7
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v4 = a2[72];
  v8 = a2[77];
  v9 = strlen(v4);
  v10 = a2[80];
  v11 = v9 + strlen(a2[77]) + 456;
  v12 = v11 + 3 + strlen(v10);
  v13 = (char *)calloc(1u, v12);
  v14 = v13;
  if ( v13 )
  {
    *(_DWORD *)(v13 + 1) = a3;
    *v13 = a4;
    memcpy(v13 + 5, a2, 0x1C0u);
    v15 = (unsigned __int8)(strlen(v4) + 1);
    v14[453] = v15;
    memcpy(v14 + 454, v4, v15);
    v16 = (unsigned __int8)(strlen(v8) + 1);
    v14[v15 + 454] = v16;
    v17 = v16 + v15 + 455;
    memcpy(&v14[v15 + 455], v8, v16);
    v18 = (unsigned __int8)(strlen(v10) + 1);
    v14[v17] = v18;
    memcpy(&v14[v17 + 1], v10, v18);
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      snprintf(s, 0x2000u, "need data size:%d, actual size:%d\n", v12, v18 + v17 + 1);
      sub_41DB8(7, s, 0);
    }
    *a1 = v12;
  }
  return v14;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003BD58) --------------------------------------------------------
int __fastcall sub_3BD58(int a1, const char **a2, int a3, char a4)
{
  char *v4; // r4
  size_t v6; // [sp+4h] [bp-2004h] BYREF
  char v7[8192]; // [sp+8h] [bp-2000h] BYREF

  v4 = sub_3BBB4(&v6, a2, a3, a4);
  if ( sub_38E90(v4, v6) && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 2) )
  {
    strcpy(v7, "cgminer return err for this nonce!\n");
    sub_41DB8(3, v7, 0);
  }
  free(v4);
  return 1;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003BE0C) --------------------------------------------------------
void sub_3BE0C()
{
  ;
}

//----- (0003BE68) --------------------------------------------------------
int __fastcall sub_3BE68(const char *a1)
{
  int v2; // r4
  time_t v3; // r3
  struct tm *v4; // r0
  __time_t timer[2]; // [sp+1Ch] [bp-B0h] BYREF
  char s[32]; // [sp+24h] [bp-A8h] BYREF
  char v8[32]; // [sp+44h] [bp-88h] BYREF
  char v9[40]; // [sp+64h] [bp-68h] BYREF
  char v10[64]; // [sp+8Ch] [bp-40h] BYREF

  memset(s, 0, sizeof(s));
  memset(v8, 0, sizeof(v8));
  memset(v9, 0, sizeof(v9));
  memset(v10, 0, 0x3Bu);
  v2 = 0;
  sub_4465C(timer);
  while ( 1 )
  {
    v3 = timer[0] - v2++;
    timer[0] = v3;
    v4 = localtime(timer);
    snprintf(
      v9,
      0x28u,
      aD02d02d02d02d0_2,
      v4->tm_year + 1900,
      v4->tm_mon + 1,
      v4->tm_mday,
      v4->tm_hour,
      v4->tm_min,
      v4->tm_sec);
    snprintf(v10, 0x3Bu, "%s%s", "BITMAIN_OPENSOURCE", v9);
    sub_4357C(v10, 0x3Bu, v8);
    sub_4357C(v8, 0x20u, s);
    if ( !strncmp(s, a1, 0x20u) )
      break;
    if ( v2 == 4 )
      return 0;
  }
  puts("socket auth pass!!!!!!!!!!!!!!!!!!!!");
  return 1;
}

//----- (0003BFBC) --------------------------------------------------------
int sub_3BFBC()
{
  _DWORD *v0; // r4
  int v1; // r3
  _DWORD *v2; // r3
  char v4[8196]; // [sp+0h] [bp-2004h] BYREF

  v0 = (_DWORD *)dword_66620C;
  if ( !dword_66620C )
    _assert_fail("cgpu", "bmminer.c", 0x864u, "bitmain_primary_init");
  v1 = dword_66A318;
  *(_DWORD *)(dword_66620C + 32) = 0;
  v0[1] = &unk_C33F8;
  v0[5] = v1;
  v0[37] = 1;
  if ( !v1 )
  {
    strcpy(v4, "Failed to calloc cgpu_info data");
    sub_41DB8(3, v4, 1);
    v1 = v0[5];
  }
  v2 = (_DWORD *)(v1 + 4096);
  v2[883] = 0;
  v2[884] = 1;
  v2[885] = 2;
  v2[886] = 3;
  return 1;
}
// 66620C: using guessed type int dword_66620C;
// 66A318: using guessed type int dword_66A318;

//----- (0003C094) --------------------------------------------------------
int __fastcall sub_3C094(const char *a1, int a2)
{
  char v4[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( a2 != 32 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 2) )
  {
    snprintf(v4, 0x2000u, "invald hash size %d\n", a2);
    sub_41DB8(3, v4, 0);
  }
  byte_4D41F8 = sub_3BE68(a1);
  return 0;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 4D41F8: using guessed type char byte_4D41F8;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003C12C) --------------------------------------------------------
size_t __fastcall sub_3C12C(int a1, int a2)
{
  int v3; // r4
  char *v4; // r6
  size_t v5; // r4
  char *v6; // r6
  size_t v7; // r5

  v3 = *(_DWORD *)(a1 + 1588) + 1864 + 32 * *(_DWORD *)(a1 + 1724);
  v4 = _strdup((const char *)(a2 + v3));
  v5 = v3 + 1 + strlen(v4);
  free(v4);
  v6 = _strdup((const char *)(a2 + v5));
  v7 = strlen(v6);
  free(v6);
  return v7 + 17 + v5;
}

//----- (0003C190) --------------------------------------------------------
int __fastcall sub_3C190(_DWORD *a1, int a2, int a3)
{
  size_t v6; // r0
  size_t v7; // r7
  size_t v8; // r4
  void *v9; // r0
  void *v10; // r3
  int v11; // r0
  size_t v12; // r10
  _DWORD *v13; // r0
  int v14; // r3
  _DWORD *v15; // r8
  size_t v16; // r7
  int *v17; // r4
  int v18; // r5
  _DWORD *v19; // r3
  int v20; // r12
  int v21; // r0
  int v22; // r1
  int v23; // r2
  int v24; // r0
  int v25; // r1
  int v26; // r2
  char *v27; // r4
  size_t v28; // r0
  size_t v29; // r10
  char *v30; // r4
  size_t v31; // r10
  _DWORD *v32; // r2
  int v33; // r1
  _DWORD *v34; // r9
  int v35; // r1
  int result; // r0
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  memcpy(a1, (const void *)a2, 0x748u);
  v6 = sub_3C12C((int)a1, a2);
  if ( v6 == a3 )
  {
    v7 = a1[397];
    v8 = v7 + 1864;
    v9 = calloc(1u, v7);
    v10 = memcpy(v9, (const void *)(a2 + 1864), v7);
    v11 = a1[431];
    a1[396] = v10;
    v12 = v7 + 1864;
    v13 = sub_43798(4 * v11 + 1, "bmminer.c", "parse_job_buf", 2341);
    v14 = a1[431];
    v15 = v13;
    a1[173] = v13;
    if ( v14 > 0 )
    {
      v16 = v7 + 1896;
      v17 = (int *)(a2 + v8);
      v18 = 0;
      while ( 1 )
      {
        v15[v18] = sub_43798(0x20u, "bmminer.c", "parse_job_buf", 2344);
        v12 = v16 + 32 * v18;
        v19 = *(_DWORD **)(a1[173] + 4 * v18);
        if ( !v19 )
        {
          strcpy(s, "Failed to malloc local merkle_bin");
          sub_41DB8(3, s, 1);
          v19 = *(_DWORD **)(a1[173] + 4 * v18);
        }
        v20 = *v17;
        ++v18;
        v21 = v17[1];
        v17 += 8;
        v22 = *(v17 - 6);
        v23 = *(v17 - 5);
        *v19 = v20;
        v19[1] = v21;
        v19[2] = v22;
        v19[3] = v23;
        v24 = *(v17 - 3);
        v25 = *(v17 - 2);
        v26 = *(v17 - 1);
        v19[4] = *(v17 - 4);
        v19[5] = v24;
        v19[6] = v25;
        v19[7] = v26;
        if ( a1[431] <= v18 )
          break;
        v15 = (_DWORD *)a1[173];
      }
    }
    v27 = _strdup((const char *)(a2 + v12));
    v28 = strlen(v27);
    a1[172] = v27;
    v29 = v28 + 1 + v12;
    v30 = _strdup((const char *)(a2 + v29));
    v31 = v29 + strlen(v30);
    a1[157] = v30;
    v32 = (_DWORD *)(a2 + v31 + 1);
    v33 = v32[1];
    v34 = (_DWORD *)(a2 + v31 + 9);
    unk_C3470 = *v32;
    unk_C3474 = v33;
    v35 = v34[1];
    LODWORD(dbl_BC4A8) = *v34;
    HIDWORD(dbl_BC4A8) = v35;
    if ( byte_4D4172 )
    {
      if ( byte_6682BC || (result = (unsigned __int8)byte_4D4171, byte_4D4171) || dword_BC5F4 > 6 )
      {
        snprintf(s, 0x2000u, "parse job buf len:%d\n", v31 + 17);
        sub_41DB8(7, s, 0);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    snprintf(s, 0x2000u, "ERR: data trans/recv unmathced! chk=%d, data_size=%d, coinbase_len=%d", v6, a3, a1[397]);
    sub_41DB8(3, s, 1);
    return -1;
  }
  return result;
}
// BC4A8: using guessed type double dbl_BC4A8;
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003C444) --------------------------------------------------------
int sub_3C444()
{
  int v0; // r4

  pthread_mutex_lock(&mutex);
  v0 = sub_45AB4((char *)dword_C3494, dword_C3490);
  pthread_mutex_unlock(&mutex);
  return v0;
}
// C3490: using guessed type int dword_C3490;
// C3494: using guessed type int dword_C3494;

//----- (0003C480) --------------------------------------------------------
int __fastcall sub_3C480(const void *a1, unsigned int a2)
{
  int v4; // r4
  void **v5; // r5
  int v6; // r7
  int v7; // r2
  int v8; // r4
  void *v9; // r0
  void *v11; // r0
  int *v12; // r0
  int *v13; // r0
  int *v14; // r0
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  void *ptr; // [sp+14h] [bp-2008h] BYREF
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v4 = dword_66A318;
  ptr = 0;
  if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
  {
    snprintf(s, 0x2000u, "%s, rec job data %p size: %d\n", "bitmain_update_job_cb", a1, a2);
    sub_41DB8(7, s, 0);
  }
  if ( (unsigned int)sub_47394() <= 1 )
  {
    pthread_mutex_lock(&mutex);
    v11 = (void *)dword_C3494;
    if ( !dword_C3494 || dword_C3490 < a2 )
    {
      v11 = realloc((void *)dword_C3494, a2);
      dword_C3494 = (int)v11;
    }
    memcpy(v11, a1, a2);
    dword_C3490 = a2;
    pthread_mutex_unlock(&mutex);
    return 0;
  }
  else
  {
    v5 = (void **)calloc(1u, 0x748u);
    v6 = sub_3C190(v5, (int)a1, a2);
    if ( v6 )
    {
      v6 = -1;
      free(v5);
    }
    else
    {
      if ( !*((_BYTE *)v5 + 656) )
      {
        strcpy(s, "Bitmain S9 has to use stratum pools");
        sub_41DB8(3, s, 1);
      }
      if ( pthread_mutex_lock((pthread_mutex_t *)(v4 + 112)) )
      {
        v17 = _errno_location();
        snprintf(
          s,
          0x2000u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v17,
          "bmminer.c",
          "bitmain_update_job_cb",
          2412);
        sub_41DB8(3, s, 1);
      }
      if ( pthread_mutex_lock((pthread_mutex_t *)v4) )
      {
        v12 = _errno_location();
        snprintf(
          s,
          0x2000u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v12,
          "bmminer.c",
          "bitmain_update_job_cb",
          2414);
        sub_41DB8(3, s, 1);
      }
      if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 24)) )
      {
        v13 = _errno_location();
        snprintf(
          s,
          0x2000u,
          "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v13,
          "bmminer.c",
          "bitmain_update_job_cb",
          2414);
        sub_41DB8(3, s, 1);
      }
      *(_DWORD *)(v4 + 168) = *v5;
      sub_4A348(v4 + 5764, v4 + 3900);
      *(_DWORD *)(v4 + 7640) = *(_DWORD *)(v4 + 7636);
      sub_4A348(v4 + 3900, v4 + 2036);
      *(_DWORD *)(v4 + 7636) = *(_DWORD *)(v4 + 7632);
      sub_4A348(v4 + 2036, v4 + 172);
      *(_DWORD *)(v4 + 7632) = *(_DWORD *)(v4 + 7628);
      sub_4A348(v4 + 172, (int)v5);
      v7 = dword_BC4B0 + 1;
      *(_DWORD *)(v4 + 7628) = dword_BC4B0 + 1;
      dword_BC4B0 = v7;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 24)) )
      {
        v14 = _errno_location();
        snprintf(
          s,
          0x2000u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v14,
          "bmminer.c",
          "bitmain_update_job_cb",
          2429);
        sub_41DB8(3, s, 1);
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)v4) )
      {
        v15 = _errno_location();
        snprintf(
          s,
          0x2000u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v15,
          "bmminer.c",
          "bitmain_update_job_cb",
          2429);
        sub_41DB8(3, s, 1);
      }
      off_BC718();
      sub_49B6C(&ptr, (int)v5, *(_DWORD *)(v4 + 7628));
      pthread_mutex_lock(stru_5503D0);
      sub_49E00((unsigned __int8 *)ptr);
      pthread_mutex_unlock(stru_5503D0);
      free(ptr);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(v4 + 112)) )
      {
        v16 = _errno_location();
        snprintf(
          s,
          0x2000u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v16,
          "bmminer.c",
          "bitmain_update_job_cb",
          2439);
        sub_41DB8(3, s, 1);
      }
      off_BC718();
      if ( (int)v5[431] > 0 )
      {
        v8 = 0;
        do
        {
          v9 = (void *)*((_DWORD *)v5[173] + v8++);
          free(v9);
        }
        while ( (int)v5[431] > v8 );
      }
      free(v5[173]);
      free(v5[396]);
      free(v5[172]);
      free(v5[157]);
      free(v5);
    }
    return v6;
  }
}
// BC4B0: using guessed type int dword_BC4B0;
// BC5F4: using guessed type int dword_BC5F4;
// BC718: using guessed type int (*off_BC718)();
// C3490: using guessed type int dword_C3490;
// C3494: using guessed type int dword_C3494;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 5503D0: using guessed type pthread_mutex_t stru_5503D0[2];
// 6682BC: using guessed type char byte_6682BC;
// 66A318: using guessed type int dword_66A318;

//----- (0003C980) --------------------------------------------------------
size_t __fastcall sub_3C980(int *a1)
{
  int v1; // r3
  size_t result; // r0
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  v1 = *a1;
  switch ( *a1 )
  {
    case 0:
    case 1:
    case 2:
      result = strlen((const char *)a1[2]) + 1;
      break;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 19:
    case 22:
    case 26:
      result = 4;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
    case 15:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      result = 8;
      break;
    case 14:
      result = 1;
      break;
    default:
      if ( byte_6682BC || (result = (unsigned __int8)byte_4D4171, byte_4D4171) || dword_BC5F4 > 2 )
      {
        snprintf(v3, 0x2000u, "Should not happen for unknown data type %d", v1);
        sub_41DB8(3, v3, 0);
        result = 0;
      }
      break;
  }
  return result;
}
// 3C998: control flows out of bounds to 3C99C
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003CAC4) --------------------------------------------------------
int __fastcall sub_3CAC4(const char *a1, size_t n)
{
  int v4; // r3
  char v5[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( n == 1 )
  {
    pthread_mutex_lock(&stru_C2ECC);
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&stru_C2ECC);
    return 0;
  }
  if ( n == 4 )
  {
    v4 = *(_DWORD *)a1;
    dword_BC4B4 = *(_DWORD *)a1;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v5, 0x2000u, "freq_level = %d\n", v4);
      sub_41DB8(3, v5, 0);
      return 0;
    }
    return 0;
  }
  if ( n != 2 )
    return 0;
  if ( !strncmp(a1, "go", 2u) )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v5, "start to init...\n");
      sub_41DB8(3, v5, 0);
    }
    sem_post(&sem);
  }
  if ( strncmp(a1, "re", 2u) )
    return 0;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v5, "reload pool, need recalculate\n");
    sub_41DB8(3, v5, 0);
  }
  sub_36B94();
  dbl_C34A8 = 0.0;
  *(_QWORD *)dword_AB79C8 = 0;
  *(_QWORD *)&dword_AB79D0 = 0;
  *(_QWORD *)&dword_AB79D8 = 0;
  *(_QWORD *)&dword_AB79E0 = 0;
  qword_AB7A58 = 0;
  sub_49B48();
  dword_C34B0 = 1;
  dword_C34B4 = 1;
  dword_C34B8 = 1;
  return 0;
}
// BC4B4: using guessed type int dword_BC4B4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C34A8: using guessed type double dbl_C34A8;
// C34B0: using guessed type int dword_C34B0;
// C34B4: using guessed type int dword_C34B4;
// C34B8: using guessed type int dword_C34B8;
// AB79C8: using guessed type int dword_AB79C8[];
// AB79D0: using guessed type int dword_AB79D0;
// AB79D8: using guessed type int dword_AB79D8;
// AB79E0: using guessed type int dword_AB79E0;
// AB7A58: using guessed type __int64 qword_AB7A58;

//----- (0003CCC4) --------------------------------------------------------
int __fastcall sub_3CCC4(int a1, int a2)
{
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
  {
    snprintf(s, 0x2000u, "%s %d\n", "bitmain_shutdown_cb", a2);
    sub_41DB8(5, s, 0);
  }
  sub_471D4();
  sub_44240(dword_C2BA0);
  sub_44240(dword_C2B9C);
  sub_44240(dword_C2B98);
  sub_44240(dword_6682B8);
  sub_63144();
  *(_BYTE *)(dword_66620C + 364) = 1;
  return 0;
}
// BC5F4: using guessed type int dword_BC5F4;
// C2B98: using guessed type int dword_C2B98;
// C2B9C: using guessed type int dword_C2B9C;
// C2BA0: using guessed type int dword_C2BA0;
// 4D4171: using guessed type char byte_4D4171;
// 66620C: using guessed type int dword_66620C;
// 6682B8: using guessed type int dword_6682B8;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003CDAC) --------------------------------------------------------
int __fastcall sub_3CDAC(int a1, const char **a2)
{
  int v3; // r4
  char *v5; // r0
  int v6; // [sp+Ch] [bp-2008h] BYREF
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v6 = a1;
  sub_583C8((int)&off_BBFD8, (int)"Options for both config file and command line");
  sub_583C8((int)&off_BC4B8, (int)"Options for command line only");
  sub_5849C(&v6, a2, (void (*)(const char *, ...))sub_38FC4);
  if ( v6 != 1 )
  {
    strcpy(s, "Unexpected extra commandline arguments");
    sub_41DB8(3, s, 1);
  }
  v3 = sub_3A2E4();
  if ( !v3 )
    return v3;
  v5 = (char *)sub_396E8("/etc/cgminer.conf.factory", (int)&off_BC544);
  if ( !v5 )
  {
    if ( dword_C2DC8 )
      sub_3B578();
    if ( dword_C2DC0 )
    {
      byte_4D37DC = 1;
      strcpy(byte_4D3804, (const char *)dword_C2DC0);
      if ( dword_C2DC4 )
        strcpy(modes, (const char *)dword_C2DC4);
      else
        strcpy(modes, "a+");
      if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
      {
        snprintf(s, 0x2000u, "Log file path: %s Open flag: %s", byte_4D3804, modes);
        sub_41DB8(3, s, 0);
      }
    }
    return v3;
  }
  free(v5);
  return 0;
}
// BBFD8: using guessed type char *off_BBFD8;
// BC4B8: using guessed type char *off_BC4B8;
// BC544: using guessed type char *off_BC544;
// BC5F4: using guessed type int dword_BC5F4;
// C2DC0: using guessed type int dword_C2DC0;
// C2DC4: using guessed type int dword_C2DC4;
// C2DC8: using guessed type int dword_C2DC8;
// 4D37DC: using guessed type char byte_4D37DC;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (0003CF98) --------------------------------------------------------
unsigned int sub_3CF98()
{
  struct timespec v1; // [sp+0h] [bp-8h] BYREF

  clock_gettime(0, &v1);
  v1.tv_sec += 300;
  do
  {
    if ( sem_timedwait(&sem, &v1) != -1 )
      return sub_4FB08();
  }
  while ( *_errno_location() == 4 );
  if ( (unsigned int)(sub_4F7A8(0) - 1) <= 1 )
    return sub_473B4(0x14u, "something error when miner init, restart...");
  else
    return sem_wait(&sem);
}

//----- (0003D02C) --------------------------------------------------------
int sub_3D02C()
{
  FILE *v0; // r4
  int *v1; // r0
  char *v2; // r0
  int v4; // r5
  size_t v5; // r6
  char s1[32]; // [sp+4h] [bp-2084h] BYREF
  _DWORD s[25]; // [sp+24h] [bp-2064h] BYREF
  char v8[8192]; // [sp+88h] [bp-2000h] BYREF

  v0 = fopen("/config/find_asic_counter", "r");
  if ( v0 )
  {
    memset(s, 0, sizeof(s));
    if ( fread(s, 0x64u, 1u, v0) == 1 )
    {
      v4 = 0;
      while ( 1 )
      {
        sub_1BDB4(v4, s1, 0x20u);
        v5 = strlen(s1);
        if ( strncmp(s1, (const char *)&s[1], v5) )
        {
          if ( strncmp(s1, (const char *)&s[9], v5) && strncmp(s1, (const char *)&s[17], v5) )
            break;
        }
        if ( ++v4 == 3 )
        {
          fclose(v0);
          return s[0];
        }
      }
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v8, "board_sn change, find_asic_counter clean");
        sub_41DB8(3, v8, 0);
      }
      fclose(v0);
      remove("/config/find_asic_counter");
    }
    else
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        v1 = _errno_location();
        v2 = strerror(*v1);
        snprintf(v8, 0x2000u, "read find_asic_counter file failed! err:%s\n", v2);
        sub_41DB8(3, v8, 0);
      }
      fclose(v0);
    }
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0003D1E0) --------------------------------------------------------
int __fastcall sub_3D1E0(char *a1)
{
  int v1; // r3
  char v4; // r5
  int v5; // r6
  int v6; // r0
  unsigned int v7; // r5
  unsigned __int8 v8; // r0
  char v9; // r5
  int v10; // r6
  int v11; // r0
  unsigned int v12; // r5
  unsigned __int8 v13; // r0
  char v14; // r5
  int v15; // r6
  int v16; // r0
  unsigned int v17; // r5
  unsigned __int8 v18; // r0
  char v19; // r5
  int v20; // r6
  int v21; // r0
  unsigned int v22; // r5
  unsigned __int8 v23; // r0
  char v24; // r5
  int v25; // r6
  int v26; // r0
  unsigned int v27; // r5
  unsigned __int8 v28; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v1 = (unsigned __int8)a1[1];
  switch ( v1 )
  {
    case 144:
      v4 = *a1;
      v5 = (unsigned __int8)a1[2];
      v6 = sub_27D8C();
      v7 = v4 & 0xF;
      v8 = sub_96518(v5, v6);
      if ( v7 <= 3 )
      {
        ++dword_679950[v7];
        dword_674950[256 * v7 + v8] = *((_DWORD *)a1 + 1);
        return 0;
      }
      else
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "%s, invalid chain or asic, chain %d, asic %03d", "handle_got_nonce_counter", v7, v8);
          sub_41DB8(3, s, 0);
        }
        return -1;
      }
    case 136:
      v14 = *a1;
      v15 = (unsigned __int8)a1[2];
      v16 = sub_27D8C();
      v17 = v14 & 0xF;
      v18 = sub_96518(v15, v16);
      if ( v17 <= 3 )
      {
        ++dword_6744F4[4 * v17];
        dword_675950[1024 * v17 + 4 * v18] = *((_DWORD *)a1 + 1);
        return 0;
      }
      else
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "%s, invalid chain or asic, chain %d, asic %03d", "handle_got_nonce_counter", v17, v18);
          sub_41DB8(3, s, 0);
        }
        return -2;
      }
    case 137:
      v19 = *a1;
      v20 = (unsigned __int8)a1[2];
      v21 = sub_27D8C();
      v22 = v19 & 0xF;
      v23 = sub_96518(v20, v21);
      if ( v22 <= 3 )
      {
        ++dword_6744F4[4 * v22 + 1];
        dword_675950[1024 * v22 + 1 + 4 * v23] = *((_DWORD *)a1 + 1);
        return 0;
      }
      else
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "%s, invalid chain or asic, chain %d, asic %03d", "handle_got_nonce_counter", v22, v23);
          sub_41DB8(3, s, 0);
        }
        return -3;
      }
    case 138:
      v9 = *a1;
      v10 = (unsigned __int8)a1[2];
      v11 = sub_27D8C();
      v12 = v9 & 0xF;
      v13 = sub_96518(v10, v11);
      if ( v12 <= 3 )
      {
        ++dword_6744F4[4 * v12 + 2];
        dword_675950[1024 * v12 + 2 + 4 * v13] = *((_DWORD *)a1 + 1);
        return 0;
      }
      else
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "%s, invalid chain or asic, chain %d, asic %03d", "handle_got_nonce_counter", v12, v13);
          sub_41DB8(3, s, 0);
        }
        return -4;
      }
    case 139:
      v24 = *a1;
      v25 = (unsigned __int8)a1[2];
      v26 = sub_27D8C();
      v27 = v24 & 0xF;
      v28 = sub_96518(v25, v26);
      if ( v27 <= 3 )
      {
        ++dword_6744F4[4 * v27 + 3];
        dword_675950[1024 * v27 + 3 + 4 * v28] = *((_DWORD *)a1 + 1);
        return 0;
      }
      else
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "%s, invalid chain or asic, chain %d, asic %03d", "handle_got_nonce_counter", v27, v28);
          sub_41DB8(3, s, 0);
        }
        return -5;
      }
    default:
      return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 6744F4: using guessed type _DWORD dword_6744F4[15];
// 674950: using guessed type _DWORD dword_674950[1024];
// 675950: using guessed type _DWORD dword_675950[4096];
// 679950: using guessed type int dword_679950[];

//----- (0003D5B4) --------------------------------------------------------
int __fastcall sub_3D5B4(char *a1)
{
  double v1; // d0
  const char *v3; // r0
  int v4; // r6
  int v5; // r8
  int v7; // r7
  char v8; // r4
  int v9; // r5
  int v10; // r4
  const char *v11; // r0
  double v12; // d7
  double v13; // d6
  float v14; // s17
  const char *v15; // r0
  float v16; // s16
  int v17; // r6
  int v18; // r1
  int v19; // r11
  int v20; // r2
  int v21; // r3
  bool v22; // nf
  char *v23; // r0
  int v24; // r2
  int v25; // r12
  int v26; // r11
  float v27; // s12
  int v28; // r3
  int *v29; // r0
  float v30; // s14
  char *v31; // r3
  int v32; // r8
  int v33; // r2
  int v34; // r9
  const char *v35; // r0
  int v36; // r0
  bool v37; // cc
  int v38; // r0
  int v39; // r1
  _DWORD *v40; // r7
  const char *v41; // r0
  const char *v42; // r0
  const char *v43; // r0
  int v44; // r0
  char *v45; // r2
  int v46; // t1
  char *v47; // r7
  int v48; // r0
  char *v49; // r3
  int v50; // r0
  int v51; // r0
  char *v52; // r3
  int v53; // r0
  int v54; // r9
  int v55; // r0
  __int64 v56; // r2
  int v57; // r0
  __int64 v58; // [sp+10h] [bp-204Ch]
  int v59; // [sp+4Ch] [bp-2010h]
  int *v60; // [sp+50h] [bp-200Ch]
  int v61; // [sp+54h] [bp-2008h]
  char s[8196]; // [sp+58h] [bp-2004h] BYREF

  v3 = (const char *)sub_27CEC();
  if ( !strcmp(v3, "HHB68502") || (v11 = (const char *)sub_27CEC(), !strcmp(v11, "HHB68503")) )
    v4 = 100;
  else
    v4 = 95;
  if ( (unsigned int)dword_BDA54 > 0x707 && !(dword_BDA54 % 0x708u) )
  {
    byte_C3644[0] = 0;
    byte_C3645 = 0;
    memset(dword_CC7C4, 0, sizeof(dword_CC7C4));
  }
  if ( (unsigned __int8)a1[1] != 180 )
    return 0;
  v7 = *((_DWORD *)a1 + 1);
  if ( v7 >= 0 )
    return 0;
  v8 = *a1;
  v9 = (unsigned __int8)a1[2];
  v10 = v8 & 0xF;
  if ( v10 < sub_27EB8() && v9 < sub_27D1C() )
  {
    v12 = (double)(unsigned __int16)v7;
    v13 = v12 * 0.171342 - 299.5144;
    v14 = v13;
    if ( v14 < 0.0 || v14 > 200.0 )
    {
      v5 = -2;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "asic invalid temp, chain %d, asic %03d, temp:%.2f", v10, v9, v14);
        sub_41DB8(3, s, 0);
      }
      return v5;
    }
    v15 = (const char *)sub_27CEC();
    if ( !strcmp(v15, "HHB68701")
      || (v41 = (const char *)sub_27CEC(), !strcmp(v41, "HHB68704"))
      || (v42 = (const char *)sub_27CEC(), !strcmp(v42, "HHB68703"))
      || (v43 = (const char *)sub_27CEC(), !strcmp(v43, "H1HB68601")) )
    {
      LODWORD(v12) = v4;
      v16 = (float)v4;
      if ( (float)(v4 - 3) < v14 && v14 < v16 )
      {
        v47 = &byte_C3644[64 * v10];
        v48 = sub_27D2C();
        if ( v47[sub_96518(v9, v48) + 4] <= 2 )
        {
          v17 = v10 << 8;
          if ( dword_C3748 <= 6449 )
          {
            v49 = &byte_C3644[v17 + v9];
            if ( !v49[264] )
            {
              v37 = (unsigned __int8)byte_C3645++ > 2u;
              if ( !v37 )
              {
                if ( !v49[1288] )
                {
                  v50 = sub_27D2C();
                  v51 = sub_96518(v9, v50);
                  ++v47[v51 + 4];
                }
                v52 = &byte_C3644[v17 + v9];
                v52[264] = 1;
                v52[2312] = 1;
                sub_4465C(&dword_CD7C4[2 * v17 + 2 * v9]);
                sub_7FF54(v10, v9, 0);
                sub_80600(v10, v9);
                sub_257E0(v10, v9);
                dword_C3748 += (int)v1;
              }
            }
          }
          goto LABEL_26;
        }
      }
    }
    else
    {
      v16 = (float)v4;
    }
    v17 = v10 << 8;
LABEL_26:
    if ( v14 > v16 )
    {
      ++dword_C434C;
      if ( (unsigned __int8)++byte_C3644[0] > 2u )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          v53 = sub_27D2C();
          v54 = sub_96518(v9, v53);
          v55 = sub_27D2C();
          LODWORD(v56) = dword_C3748;
          HIDWORD(v56) = (unsigned __int8)byte_C3644[v17 + 264 + v9];
          v58 = v56;
          v57 = sub_96518(v9, v55);
          snprintf(
            s,
            0x2000u,
            "%s, %d, chain:%d domain:%d  domain_err_cnt:%d total_dec_freq:%d core_off_cnt:%d",
            "handle_temp_sensor_data",
            942,
            v10,
            v54,
            byte_C3644[64 * v10 + 4 + v57],
            (_DWORD)v58,
            HIDWORD(v58));
          sub_41DB8(3, s, 0);
          if ( (unsigned int)off_BC5EC > 3 )
          {
            v12 = v14;
            snprintf(s, 0x2000u, "asic temp too high, chain %d, asic %03d, temp:%.2f", v10, v9, v14);
            sub_41DB8(3, s, 0);
          }
        }
        sub_473B4(0xFu, "asic temp too high");
        sub_4FB28(8, v10);
        sub_2CC78(1);
      }
    }
    v18 = 2 * (v17 + v9);
    v59 = v18 * 4;
    if ( dword_CA7C4[v18] || (v5 = dword_CA7C4[v18 + 1]) != 0 )
    {
      v19 = v17 + v9;
      byte_C3644[v17 + 3340 + v9] = 1;
      v60 = &dword_C87C4[v18];
      flt_D07C4[v17 + v9] = v14;
      sub_4465C(&dword_C87C4[v18]);
      v20 = dword_C87C4[2 * v19] - dword_CA7C4[2 * v19];
      v21 = dword_C87C4[2 * v19 + 1] - dword_CA7C4[2 * v19 + 1];
      dword_C67C4[2 * v19] = v20;
      v22 = v21 < 0;
      v23 = (char *)&dword_C67C4[2 * v17 + 2 * v9];
      if ( v21 < 0 )
        --v20;
      *((_DWORD *)v23 + 1) = v21;
      if ( v21 < 0 )
      {
        dword_C67C4[2 * v19] = v20;
        v21 += 999424;
      }
      LOWORD(v24) = 19923;
      if ( v22 )
        v21 += 576;
      HIWORD(v24) = 4194;
      if ( v22 )
        *((_DWORD *)v23 + 1) = v21;
      v25 = v17 + v9;
      *((float *)&v12 + 1) = flt_D07C4[v25];
      v26 = ((int)((unsigned __int64)(v21 * (__int64)v24) >> 32) >> 6)
          - (v21 >> 31)
          + 1000 * dword_C67C4[2 * v17 + 2 * v9];
      v27 = flt_CF7C4[v25];
      if ( v26 <= 200 )
      {
        v16 = 0.0;
      }
      else
      {
        HIDWORD(v13) = 1148846080;
        *(float *)&v12 = (float)v26;
        *((float *)&v12 + 1) = *((float *)&v12 + 1) - v27;
      }
      v28 = dword_C4750;
      v29 = (int *)dword_C4758;
      if ( v26 > 200 )
        v16 = *((float *)&v12 + 1) / *(float *)&v12;
      v30 = flt_C4754;
      if ( v26 > 200 )
        v16 = v16 * *((float *)&v13 + 1);
      if ( v26 >= dword_C4750 )
        v28 = v26;
      dword_C4750 = v28;
      if ( flt_C4754 <= v16 )
        v30 = v16;
      flt_C4754 = v30;
      if ( !dword_C4758 )
      {
        v29 = sub_835A0("bmminer_auto_temp");
        v30 = flt_C4754;
        dword_C4758 = (int)v29;
        v28 = dword_C4750;
        v27 = flt_CF7C4[v17 + v9];
      }
      sub_85464(
        (int)v29,
        "asic_response.c",
        15,
        (int)"handle_temp_sensor_data",
        23,
        976,
        20,
        (int)"chain %d, asic %03d, temp:%.2f, temp_pre:%.2f, diff_time:%dms, temp_change_rate:%.2f, all_rate_failure:%d, "
             "max_diff_time:%d, max_rate:%.2f",
        v10,
        v9,
        v14,
        v27,
        v26,
        v16,
        dword_C475C,
        v28,
        v30);
      if ( v16 > 3.0 )
      {
        v31 = &byte_C3644[v17 + v9];
        v32 = (unsigned __int8)v31[2312];
        if ( !v31[2312] )
        {
          v33 = dword_CC7C4[v17 + v9];
          v61 = (unsigned __int8)v31[2312];
          ++dword_C475C;
          v34 = v32;
          dword_CC7C4[v17 + v9] = v33 + 1;
          do
          {
            if ( sub_27EC8(v34) )
            {
              v44 = sub_27D1C();
              if ( v44 > 0 )
              {
                v45 = (char *)&dword_CC7C4[256 * v34];
                do
                {
                  v46 = *(_DWORD *)v45;
                  v45 += 4;
                  if ( v46 > 0 )
                    ++v61;
                }
                while ( v45 != (char *)&dword_CC7C4[256 * v34 + v44] );
              }
            }
            ++v34;
          }
          while ( v34 != 4 );
          v35 = (const char *)sub_27CEC();
          v36 = strcmp(v35, "H1HB68601");
          v37 = v36 <= 0;
          if ( v36 )
            v37 = v61 <= 44;
          if ( !v37 )
          {
            if ( (unsigned int)off_BC5EC > 3 )
            {
              snprintf(
                s,
                0x2000u,
                "asic temp_change_rate too big, chain %d, asic %03d, temp:%.2f, temp_pre:%.2f, diff_time:%dms, temp_change_rate:%.2f",
                v10,
                v9,
                v14,
                flt_CF7C4[v17 + v9],
                v26,
                v16);
              sub_41DB8(3, s, 0);
            }
            sub_4FB28(8, v10);
            sub_2CC78(1);
            sub_473B4(0xFu, "asic temp_change_rate too big");
          }
        }
      }
      v5 = 0;
      v38 = *v60;
      v39 = v60[1];
      flt_CF7C4[v17 + v9] = v14;
      v40 = (_DWORD *)((char *)dword_CA7C4 + v59);
      *v40 = v38;
      v40[1] = v39;
    }
    else
    {
      flt_CF7C4[v17 + v9] = v14;
      sub_4465C(&dword_CA7C4[v18]);
    }
    return v5;
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "invalid chain or asic, chain %d, asic %03d", v10, v9);
    sub_41DB8(3, s, 0);
  }
  return -1;
}
// 3DCC4: variable 'v1' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA54: using guessed type int dword_BDA54;
// C3645: using guessed type char byte_C3645;
// C3748: using guessed type int dword_C3748;
// C434C: using guessed type int dword_C434C;
// C4750: using guessed type int dword_C4750;
// C4754: using guessed type float flt_C4754;
// C4758: using guessed type int dword_C4758;
// C475C: using guessed type int dword_C475C;
// C67C4: using guessed type _DWORD dword_C67C4[2048];
// C87C4: using guessed type _DWORD dword_C87C4[2048];
// CA7C4: using guessed type _DWORD dword_CA7C4[2048];
// CC7C4: using guessed type _DWORD dword_CC7C4[1024];
// CD7C4: using guessed type __time_t dword_CD7C4[2048];
// CF7C4: using guessed type float flt_CF7C4[1024];
// D07C4: using guessed type float flt_D07C4[1023];

//----- (0003DE28) --------------------------------------------------------
int sub_3DE28()
{
  pthread_mutex_lock(&stru_C4760);
  dword_66C4F0 = 0;
  dword_66C4F4 = 0;
  dword_66C4F8 = 0;
  return pthread_mutex_unlock(&stru_C4760);
}
// 66C4F0: using guessed type int dword_66C4F0;
// 66C4F4: using guessed type int dword_66C4F4;
// 66C4F8: using guessed type int dword_66C4F8;

//----- (0003DE60) --------------------------------------------------------
int sub_3DE60()
{
  pthread_mutex_lock(&stru_550400);
  dword_6799D8 = 0;
  dword_6799DC = 0;
  dword_6799E0 = 0;
  return pthread_mutex_unlock(&stru_550400);
}
// 550400: using guessed type pthread_mutex_t stru_550400;
// 6799D8: using guessed type int dword_6799D8;
// 6799DC: using guessed type int dword_6799DC;
// 6799E0: using guessed type int dword_6799E0;

//----- (0003DE98) --------------------------------------------------------
int __fastcall sub_3DE98(int a1, int a2)
{
  int result; // r0
  int v4; // r8
  float v5; // s21
  int v6; // r2
  int v7; // r6
  int v8; // r5
  int v9; // r1
  unsigned int v10; // r3
  int *v11; // r2
  int *v12; // r1
  int v13; // r12
  unsigned int v14; // r2
  int *v16; // r0
  float v17; // s20
  int v18; // r5
  int *v19; // r0
  int v20; // r5
  int v22; // [sp+24h] [bp-2010h]
  int *v23; // [sp+28h] [bp-200Ch]
  unsigned int v24; // [sp+2Ch] [bp-2008h]
  char s[8196]; // [sp+30h] [bp-2004h] BYREF

  result = sub_27EC8(a1);
  if ( result )
  {
    if ( !a2 )
      sub_28238(a1, 0);
    v4 = 0;
    v22 = 0;
    sub_3DE28();
    v5 = 0.0;
    sub_2A220((unsigned __int8)a1, 1, 0, a2);
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          sub_44890();
          pthread_mutex_lock(&stru_C4760);
          v6 = dword_66C4F8;
          v4 += dword_66C4F8;
          v7 = dword_66C4F8;
          if ( dword_66C4F8 > 0 )
          {
            v8 = 0;
            while ( 1 )
            {
              v9 = 4094;
              dword_66C4F8 = v6 - 1;
              v10 = dword_66C4F4 + 1;
              v11 = &dword_66C4F0[2 * dword_66C4F4 + 2];
              if ( (unsigned int)(dword_66C4F4 + 1) <= 0xFFE )
                ++dword_66C4F4;
              else
                v9 = 0;
              if ( v10 > 0xFFE )
                dword_66C4F4 = v9;
              v12 = &dword_66C4F0[2 * v10];
              v13 = *((unsigned __int8 *)v11 + 10);
              v14 = v11[1];
              if ( *((unsigned __int8 *)v12 + 11) == a1 && v13 == 180 && v14 >> 31 )
              {
                v16 = (int *)dword_C4778;
                if ( dword_C4778 )
                  v12 = (int *)a1;
                v17 = (double)(unsigned __int16)v14 * 0.171342 - 299.5144;
                v5 = v5 + v17;
                if ( !dword_C4778 )
                {
                  v24 = v10;
                  v23 = v12;
                  v16 = sub_835A0("bmminer_auto_temp");
                  dword_C4778 = (int)v16;
                  v10 = v24;
                  v12 = (int *)*((unsigned __int8 *)v23 + 11);
                }
                sub_85464(
                  (int)v16,
                  "asic_response.c",
                  15,
                  (int)"check_asic_sensor_one_chain",
                  27,
                  118,
                  20,
                  (int)"chain %d, asic %03d, temp:%.2f",
                  v12,
                  BYTE1(dword_66C4F0[2 * v10 + 2]),
                  v17);
              }
              if ( v7 == ++v8 )
                break;
              v6 = dword_66C4F8;
            }
          }
          if ( sub_27D1C() == v7 )
          {
            v19 = (int *)dword_C4778;
            v5 = v5 / (float)v7;
            if ( !dword_C4778 )
            {
              v19 = sub_835A0("bmminer_auto_temp");
              dword_C4778 = (int)v19;
            }
            sub_85464(
              (int)v19,
              "asic_response.c",
              15,
              (int)"check_asic_sensor_one_chain",
              27,
              123,
              20,
              (int)"chain%d, sensor num:%d, avg temp:%.2f",
              a1,
              v7,
              v5);
          }
          v18 = sub_27D1C();
          if ( 5 * sub_27EB8() * v18 < v4 )
          {
LABEL_29:
            pthread_mutex_unlock(&stru_C4760);
            return 1;
          }
          if ( v7 <= 0 )
            break;
          v22 = 0;
          pthread_mutex_unlock(&stru_C4760);
        }
        if ( !v7 )
          break;
        if ( !a2 )
        {
          v20 = sub_27D1C();
          if ( v20 == sub_282A4(a1) )
            goto LABEL_29;
        }
        pthread_mutex_unlock(&stru_C4760);
      }
      ++v22;
      sub_44890();
      pthread_mutex_unlock(&stru_C4760);
    }
    while ( v22 != 4 );
    return 1;
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "Chain %d is not exist.\n", a1);
    sub_41DB8(3, s, 0);
    return 0;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C4778: using guessed type int dword_C4778;
// 66C4F0: using guessed type int dword_66C4F0[];
// 66C4F4: using guessed type int dword_66C4F4;
// 66C4F8: using guessed type int dword_66C4F8;

//----- (0003E1FC) --------------------------------------------------------
int __fastcall sub_3E1FC(int a1, int a2)
{
  int result; // r0
  int v4; // r7
  int v5; // r11
  int v6; // r2
  int v7; // r10
  int v8; // r9
  int v9; // r3
  int *v10; // r12
  int v11; // r2
  int v12; // r0
  bool v13; // zf
  int v14; // r9
  int v15; // r9
  unsigned int v16; // [sp+4h] [bp-2010h]
  int v17; // [sp+4h] [bp-2010h]
  int v19; // [sp+Ch] [bp-2008h]
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  result = sub_27EC8(a1);
  if ( !result )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "Chain %d is not exist.\n", a1);
      sub_41DB8(3, s, 0);
      return 0;
    }
    return result;
  }
  if ( !a2 )
    sub_28238(a1, 0);
  v4 = 0;
  sub_3DE28();
  v5 = 0;
  sub_2A220((unsigned __int8)a1, 1, 0, a2);
LABEL_8:
  while ( 2 )
  {
    sub_44890();
    pthread_mutex_lock(&stru_C4760);
    v6 = dword_66C4F8;
    v4 += dword_66C4F8;
    v7 = dword_66C4F8;
    if ( dword_66C4F8 > 0 )
    {
      v8 = 0;
      while ( 1 )
      {
        dword_66C4F8 = v6 - 1;
        ++v8;
        v9 = dword_66C4F4 + 1;
        v10 = &dword_66C4F0[2 * dword_66C4F4 + 2];
        if ( (unsigned int)(dword_66C4F4 + 1) > 0xFFE )
          v9 = 0;
        v11 = *((unsigned __int8 *)v10 + 10);
        v12 = *((unsigned __int8 *)v10 + 11);
        dword_66C4F4 = v9;
        v13 = v12 == a1;
        if ( v12 == a1 )
          v13 = v11 == 0;
        if ( v13 && (v16 = v10[1], sub_27D3C() == HIWORD(v16)) )
        {
          sub_281C8(a1);
          if ( v7 == v8 )
          {
LABEL_20:
            v14 = sub_27D1C();
            if ( v4 > 5 * sub_27EB8() * v14 )
              goto LABEL_21;
            v5 = 0;
            pthread_mutex_unlock(&stru_C4760);
            goto LABEL_8;
          }
        }
        else if ( v7 == v8 )
        {
          goto LABEL_20;
        }
        v6 = dword_66C4F8;
      }
    }
    v19 = dword_66C4F8;
    v17 = sub_27D1C();
    if ( v4 > 5 * sub_27EB8() * v17 )
      goto LABEL_21;
    if ( v19 )
    {
      if ( a2 || (v15 = sub_27D1C(), v15 != sub_282A4(a1)) )
      {
        pthread_mutex_unlock(&stru_C4760);
        continue;
      }
LABEL_21:
      pthread_mutex_unlock(&stru_C4760);
      return 1;
    }
    else
    {
      ++v5;
      sub_44890();
      pthread_mutex_unlock(&stru_C4760);
      if ( v5 != 4 )
        continue;
      return 1;
    }
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 66C4F0: using guessed type int dword_66C4F0[];
// 66C4F4: using guessed type int dword_66C4F4;
// 66C4F8: using guessed type int dword_66C4F8;

//----- (0003E42C) --------------------------------------------------------
int __fastcall sub_3E42C(int a1, int a2, int a3)
{
  int v6; // r2
  int v7; // r10
  int v8; // r5
  unsigned int v9; // r3
  int *v10; // r1
  int v11; // r4
  char *format; // [sp+18h] [bp-201Ch]
  char v14; // [sp+1Ch] [bp-2018h]
  char v15; // [sp+20h] [bp-2014h]
  int v16; // [sp+24h] [bp-2010h]
  int v17; // [sp+28h] [bp-200Ch]
  int v18; // [sp+2Ch] [bp-2008h]
  char s[8196]; // [sp+30h] [bp-2004h] BYREF

  v14 = a1;
  v15 = a2;
  v16 = (unsigned __int8)a3;
  v18 = 5;
  pthread_mutex_lock(&stru_C477C);
  while ( 2 )
  {
    v17 = 8;
    sub_3DE28();
    sub_2A220(v16, 0, v15, v14);
    do
    {
      sub_44890();
      pthread_mutex_lock(&stru_C4760);
      v6 = dword_66C4F8;
      if ( dword_66C4F8 )
      {
        v7 = dword_66C4F8;
        v8 = 0;
        while ( 1 )
        {
          ++v8;
          dword_66C4F8 = v6 - 1;
          v9 = dword_66C4F4 + 1;
          if ( (unsigned int)(dword_66C4F4 + 1) > 0xFFE )
            dword_66C4F4 = 0;
          v10 = &dword_66C4F0[2 * v9];
          if ( v9 <= 0xFFE )
            dword_66C4F4 = v9;
          if ( *((unsigned __int8 *)v10 + 11) == a3
            && *((unsigned __int8 *)v10 + 9) == a2
            && *((unsigned __int8 *)v10 + 10) == a1 )
          {
            break;
          }
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(
              s,
              0x2000u,
              "read asic reg error: expect chain = %d, chip = %d, reg = %d, got chain = %d, chip = %d, reg = %d\n",
              a3,
              a2,
              a1,
              *((unsigned __int8 *)v10 + 11),
              BYTE1(dword_66C4F0[2 * v9 + 2]),
              BYTE2(dword_66C4F0[2 * v9 + 2]));
            sub_41DB8(3, s, 0);
            if ( v7 == v8 )
              goto LABEL_20;
          }
          else if ( v7 == v8 )
          {
            goto LABEL_20;
          }
          v6 = dword_66C4F8;
        }
        if ( a1 == 28 )
        {
          v11 = v10[1];
          if ( (v11 & 0xE0000000) != 0 )
            v11 = 0;
          pthread_mutex_unlock(&stru_C4760);
          sub_3DE28();
          pthread_mutex_unlock(&stru_C477C);
          return v11;
        }
        else
        {
          format = (char *)&dword_66C4F0[2 * v9];
          pthread_mutex_unlock(&stru_C4760);
          sub_3DE28();
          pthread_mutex_unlock(&stru_C477C);
          return *((_DWORD *)format + 1);
        }
      }
LABEL_20:
      pthread_mutex_unlock(&stru_C4760);
      --v17;
    }
    while ( v17 );
    if ( --v18 )
      continue;
    break;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "read asic reg timeout: expect chain = %d, chip = %d, reg = %d\n", a3, a2, a1);
    sub_41DB8(4, s, 0);
  }
  sub_3DE28();
  pthread_mutex_unlock(&stru_C477C);
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 66C4F0: using guessed type int dword_66C4F0[];
// 66C4F4: using guessed type int dword_66C4F4;
// 66C4F8: using guessed type int dword_66C4F8;

//----- (0003E690) --------------------------------------------------------
int __fastcall sub_3E690(int a1, int a2, int a3, int a4)
{
  int v7; // r0
  int v8; // r0
  int v9; // r6
  int v10; // r8
  int v11; // r5
  int v12; // r3
  int *v13; // r6
  int v14; // r2
  int v15; // r0
  unsigned int v16; // r0
  int v17; // r1
  unsigned int v18; // r6
  unsigned int v19; // r0
  int v20; // r1
  int v21; // r0
  int v22; // r0
  int v23; // r0
  int v24; // [sp+Ch] [bp-2030h]
  unsigned int v25; // [sp+Ch] [bp-2030h]
  int v28; // [sp+18h] [bp-2024h]
  int v29; // [sp+1Ch] [bp-2020h]
  int v30; // [sp+28h] [bp-2014h] BYREF
  __time_t v31[2]; // [sp+30h] [bp-200Ch] BYREF
  char s[8196]; // [sp+38h] [bp-2004h] BYREF

  if ( sub_27EC8(a3) )
  {
    pthread_mutex_lock(&stru_C477C);
    sub_18C20();
    byte_C4794 = 1;
    v7 = sub_27D8C();
    sub_802B4((unsigned __int8)a3, 0, a2 * v7, 1);
    usleep(0x186A0u);
    sub_3DE28();
    if ( a1 == 4 )
    {
      v22 = sub_27D8C();
      sub_8051C((unsigned __int8)a3, a2 * v22);
    }
    else
    {
      v8 = sub_27D8C();
      if ( a1 == 16 )
        sub_80538((unsigned __int8)a3, a2 * v8, 2);
      else
        sub_80EC8((unsigned __int8)a3, a2 * v8, a1);
    }
    v28 = 0;
    v29 = 0;
    usleep((__useconds_t)&loc_186A0);
    do
    {
      pthread_mutex_lock(&stru_C4760);
      v9 = dword_66C4F8;
      v10 = dword_66C4F8;
      if ( dword_66C4F8 > 0 )
      {
        v11 = 0;
        while ( 1 )
        {
          dword_66C4F8 = v9 - 1;
          ++v11;
          v12 = dword_66C4F4 + 1;
          v13 = &dword_66C4F0[2 * dword_66C4F4 + 2];
          if ( (unsigned int)(dword_66C4F4 + 1) > 0xFFE )
            v12 = 0;
          v14 = *((unsigned __int8 *)v13 + 11);
          dword_66C4F4 = v12;
          if ( v14 == a3
            && *((_BYTE *)v13 + 10) == 64
            && (v24 = *((unsigned __int8 *)v13 + 9), v15 = sub_27D8C(), sub_96518(v24, v15) == a2)
            && (v25 = *((unsigned __int16 *)v13 + 3),
                ++v28,
                v16 = sub_27D4C(),
                sub_964FC(v25, v16),
                !*(_DWORD *)(a4 + 4 * v17)) )
          {
            v18 = v13[1];
            ++v29;
            v19 = sub_27D4C();
            sub_964FC(HIWORD(v18), v19);
            *(_DWORD *)(a4 + 4 * v20) = (unsigned __int16)v18;
            if ( v10 == v11 )
            {
LABEL_20:
              pthread_mutex_unlock(&stru_C4760);
              goto LABEL_21;
            }
          }
          else if ( v10 == v11 )
          {
            goto LABEL_20;
          }
          v9 = dword_66C4F8;
        }
      }
      pthread_mutex_unlock(&stru_C4760);
      if ( !v9 )
        usleep(0x3E8u);
LABEL_21:
      sub_4465C(v31);
    }
    while ( (int)sub_44930(v31, &v30) <= 199 );
    if ( v29 != sub_27D4C() && (unsigned int)off_BC5EC > 3 )
    {
      v23 = sub_27D4C();
      snprintf(s, 0x2000u, "recv core response not enough!!!, total recv::%d, valid::%d, need::%d.\n", v28, v29, v23);
      sub_41DB8(3, s, 0);
    }
    byte_C4794 = 0;
    sub_18C34();
    v21 = sub_27D8C();
    sub_802B4((unsigned __int8)a3, 0, a2 * v21, 1);
    usleep(0x186A0u);
    pthread_mutex_unlock(&stru_C477C);
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "chain::%d don't exist!!!\n", a3);
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
}
// 3E878: variable 'v17' is possibly undefined
// 3E8B0: variable 'v20' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C4794: using guessed type char byte_C4794;
// 66C4F0: using guessed type int dword_66C4F0[];
// 66C4F4: using guessed type int dword_66C4F4;
// 66C4F8: using guessed type int dword_66C4F8;

//----- (0003EBCC) --------------------------------------------------------
_BYTE *__fastcall sub_3EBCC(_BYTE *result)
{
  _BYTE *v1; // r4
  int v2; // r7
  int v3; // r10
  int v4; // r5
  int *v5; // r9
  int v6; // r0
  void *v7; // r3
  int v8; // r0
  int v9; // r3
  int v10; // r5
  int *v11; // r4
  unsigned int v12; // r5
  int v13; // r4
  unsigned int v14; // r9
  int v15; // r0
  unsigned int v16; // r7
  unsigned int v17; // r3
  bool v18; // cc
  unsigned int v19; // r0
  bool v20; // cf
  unsigned int v21; // r3
  unsigned int v22; // r2
  int v23; // r0
  int v24; // r12
  char s[8224]; // [sp+10h] [bp-2020h] BYREF

  if ( byte_4D41F9 )
  {
    v1 = result;
    if ( (*result & 0x80) != 0 )
    {
      if ( (*result & 0x40) != 0 )
      {
        v18 = (unsigned int)dword_C4798++ > 0x14;
        if ( !v18 && (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "!!! nonce crc error");
          result = (_BYTE *)sub_41DB8(3, s, 0);
        }
        ++dword_679964;
      }
      else
      {
        pthread_mutex_lock(&stru_550400);
        if ( (unsigned int)dword_6799E0 > 0xFFE )
        {
          if ( !dword_C479C )
          {
            if ( (unsigned int)off_BC5EC > 3 )
            {
              strcpy(s, "nonce_read_out buffer is full!\n");
              sub_41DB8(3, s, dword_C479C);
            }
            dword_C479C = 1;
          }
        }
        else
        {
          v2 = *((_WORD *)v1 + 1) & 0x7FFF;
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(
              s,
              0x2000u,
              "job_id: %x %02x, work_id:%d, diff:%d\n",
              (unsigned __int8)v1[1] >> 7,
              (unsigned __int8)v1[11],
              *((_WORD *)v1 + 1) & 0x7FFF,
              v1[1] & 0x7F);
            sub_41DB8(4, s, 0);
            v2 = *((_WORD *)v1 + 1) & 0x7FFF;
          }
          v3 = dword_6799D8[0];
          v4 = 16 * dword_6799D8[0];
          v5 = &dword_6799D8[15 * dword_6799D8[0]];
          v5[4] = v2;
          v5[8] = *((_DWORD *)v1 + 1);
          v5[9] = *v1 & 0xF;
          v6 = sub_62B94(v2);
          v7 = off_BC5EC;
          v5[3] = v6;
          if ( (unsigned int)v7 > 4 )
          {
            snprintf(s, 0x2000u, "blk ver = 0x%x\n", *(unsigned __int16 *)(v1 + 9));
            sub_41DB8(4, s, 0);
          }
          v8 = sub_62BD8(v2);
          v9 = *(unsigned __int16 *)(v1 + 9);
          v10 = v4 - v3;
          v11 = &dword_6799D8[v10];
          dword_6799D8[v10 + 5] = v8 | bswap32(v9 << 13);
          *((_QWORD *)v11 + 3) = sub_62AFC(v2);
          sub_62C1C(v2, (int)&dword_6799D8[v10 + 10], 0x20u);
          v12 = dword_6799D8[v10 + 8];
          v13 = v11[9];
          v14 = sub_81144(v12);
          v15 = sub_27D1C();
          v16 = sub_81160(v12, v15);
          if ( v13 > 3 || v16 >= sub_27D1C() )
            goto LABEL_38;
          v19 = sub_27D4C();
          v20 = 1;
          if ( v12 )
            v20 = v14 >= v19;
          if ( v20 )
          {
LABEL_38:
            if ( (unsigned int)off_BC5EC > 4 )
            {
              snprintf(s, 0x2000u, "buf [%x] is error!\n", v12);
              sub_41DB8(4, s, 0);
              if ( (unsigned int)off_BC5EC > 4 )
              {
                snprintf(s, 0x2000u, "chain = %d, chip = %d, core = %d\n", v13, v16, v14);
                sub_41DB8(4, s, 0);
              }
            }
          }
          else
          {
            v21 = v16 + (v13 << 8);
            v22 = v14 + (v21 << 10);
            v21 += 4;
            v22 += 1028;
            v23 = dword_D17C4[v22];
            v24 = dword_D17C4[v21] + 1;
            ++dword_D17C4[v13];
            dword_D17C4[v21] = v24;
            dword_D17C4[v22] = v23 + 1;
          }
          v17 = dword_6799D8[0] + 1;
          v18 = (unsigned int)(dword_6799D8[0] + 1) > 0xFFE;
          dword_6799D8[0] = v17;
          if ( v17 > 0xFFE )
            v17 = 0;
          if ( v18 )
            dword_6799D8[0] = v17;
          ++dword_6799E0;
          dword_C479C = 0;
        }
        return (_BYTE *)pthread_mutex_unlock(&stru_550400);
      }
    }
    else
    {
      v18 = (unsigned int)dword_C4798++ > 0x14;
      if ( !v18 && (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "!!! nonce invalid");
        return (_BYTE *)sub_41DB8(3, s, 0);
      }
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C4798: using guessed type int dword_C4798;
// C479C: using guessed type int dword_C479C;
// D17C4: using guessed type int dword_D17C4[3];
// 4D41F9: using guessed type char byte_4D41F9;
// 550400: using guessed type pthread_mutex_t stru_550400;
// 679964: using guessed type int dword_679964;
// 6799D8: using guessed type int dword_6799D8[];
// 6799E0: using guessed type int dword_6799E0;

//----- (0003EFDC) --------------------------------------------------------
int __fastcall sub_3EFDC(__int64 *a1)
{
  int result; // r0
  int v3; // r2
  _DWORD *v4; // r3
  int (__fastcall *v5)(__int64 *); // r2
  int v6; // r3
  bool v7; // cc
  int v8; // r6
  int v9; // r4
  int v10; // r0
  int v11; // r0
  int v12; // lr
  unsigned int v13; // r1
  int *v14; // r2
  int v15; // r12
  int v16; // r3
  bool v17; // zf
  int v18; // r8
  __int64 v19; // r6
  int v20; // r5
  int v21; // r0
  int v22; // r0
  int v23; // [sp+10h] [bp-2008h]
  char s[8192]; // [sp+18h] [bp-2000h] BYREF

  if ( (*(_BYTE *)a1 & 0x40) != 0 )
  {
    result = sub_47394();
    if ( result == 2 )
    {
      if ( byte_C1E68 )
      {
        v7 = (unsigned int)dword_C47A0++ > 0x14;
        if ( !v7 && (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "!!! reg crc error");
          result = sub_41DB8(3, s, 0);
          if ( (unsigned int)off_BC5EC > 3 )
          {
            v18 = *((unsigned __int8 *)a1 + 2);
            v19 = *a1;
            v20 = *((_DWORD *)a1 + 2);
            v21 = sub_27D8C();
            v23 = *((unsigned __int8 *)a1 + 1);
            v22 = sub_96518(v18, v21);
            snprintf(
              s,
              0x2000u,
              "!!!  %0x %0x %0x %0x asic %d  core 0x%02x ",
              (_DWORD)v19,
              HIDWORD(v19),
              v20,
              v20,
              v22,
              v23);
            result = sub_41DB8(3, s, 0);
          }
        }
      }
    }
    ++dword_679960;
  }
  else if ( (*((_BYTE *)a1 + 3) & 0x60) != 0 )
  {
    result = sub_47394();
    if ( result == 2 )
    {
      if ( byte_C1E68 )
      {
        v7 = (unsigned int)dword_C47A0++ > 0x14;
        if ( !v7 && (unsigned int)off_BC5EC > 3 )
        {
          v8 = *((unsigned __int8 *)a1 + 2);
          v9 = *(_DWORD *)a1;
          v10 = sub_27D8C();
          v11 = sub_96518(v8, v10);
          snprintf(s, 0x2000u, "!!! REG_TYPE = 1. %u asic %d", v9, v11);
          return sub_41DB8(3, s, 0);
        }
      }
    }
  }
  else
  {
    result = *((unsigned __int8 *)a1 + 1);
    v3 = (unsigned __int8)byte_C47A4;
    if ( !byte_C47A4 )
    {
      v4 = &unk_674530;
      do
      {
        v4[1] = v3;
        ++v4;
      }
      while ( v4 != (_DWORD *)&unk_67492C );
      dword_674804 = (int)sub_3D5B4;
      dword_674774 = (int)sub_3D1E0;
      dword_674754 = (int)sub_3D1E0;
      dword_674758 = (int)sub_3D1E0;
      dword_67475C = (int)sub_3D1E0;
      dword_674760 = (int)sub_3D1E0;
      byte_C47A4 = 1;
    }
    if ( result != 255 && (v5 = (int (__fastcall *)(__int64 *))dword_674534[result]) != 0 && dword_BDA50 == 1 )
    {
      v17 = result == 180;
      if ( result != 180 )
        v17 = result == 144;
      if ( v17 || (unsigned __int8)(result + 120) <= 3u )
        return v5(a1);
    }
    else
    {
      pthread_mutex_lock(&stru_C4760);
      v6 = dword_66C4F8;
      if ( (unsigned int)dword_66C4F8 <= 0xFFE )
      {
        v12 = (unsigned __int8)byte_C4794;
        v13 = dword_66C4F0[0] + 1;
        v14 = &dword_66C4F0[2 * dword_66C4F0[0] + 2];
        v14[1] = *((_DWORD *)a1 + 1);
        *((_BYTE *)v14 + 8) = *((_BYTE *)a1 + 3) & 0x1F;
        *((_BYTE *)v14 + 9) = *((_BYTE *)a1 + 2);
        v15 = *((unsigned __int8 *)a1 + 1);
        if ( v15 != 64 )
          v12 |= 1u;
        *((_BYTE *)v14 + 10) = v15;
        *((_BYTE *)v14 + 11) = *(_BYTE *)a1 & 0xF;
        if ( v12 )
        {
          v16 = v6 + 1;
          dword_66C4F8 = v16;
          if ( v13 > 0xFFE )
            v16 = 0;
          dword_66C4F0[0] = v13;
          if ( v13 > 0xFFE )
            dword_66C4F0[0] = v16;
        }
      }
      else
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "reg_value_buf buffer is full! will clear it!");
          sub_41DB8(3, s, 0);
        }
        dword_66C4F0[0] = 0;
        dword_66C4F4 = 0;
        dword_66C4F8 = 0;
      }
      return pthread_mutex_unlock(&stru_C4760);
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA50: using guessed type int dword_BDA50;
// C1E68: using guessed type char byte_C1E68;
// C4794: using guessed type char byte_C4794;
// C47A0: using guessed type int dword_C47A0;
// C47A4: using guessed type char byte_C47A4;
// 66C4F0: using guessed type int dword_66C4F0[];
// 66C4F4: using guessed type int dword_66C4F4;
// 66C4F8: using guessed type int dword_66C4F8;
// 674534: using guessed type _DWORD dword_674534[136];
// 674754: using guessed type int dword_674754;
// 674758: using guessed type int dword_674758;
// 67475C: using guessed type int dword_67475C;
// 674760: using guessed type int dword_674760;
// 674774: using guessed type int dword_674774;
// 674804: using guessed type int dword_674804;
// 679960: using guessed type int dword_679960;

//----- (0003F36C) --------------------------------------------------------
int sub_3F36C()
{
  int v0; // r7
  int i; // r6
  int result; // r0
  int v3; // r10
  int v4; // r8
  int v5; // r4
  int v6; // r0
  int v7; // r2
  char *v8; // r3
  char *v9; // r0
  int v10; // t1
  unsigned int v11; // r0
  int v12; // r1
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "\n dump asic nonce number...\n");
    sub_41DB8(4, s, 0);
  }
  v0 = 0;
  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(s, 0x2000u, "Chain[%d]:\n", i);
        sub_41DB8(4, s, 0);
      }
      result = sub_27D1C();
      v3 = result;
      v4 = 0;
      if ( result > 0 )
      {
        v5 = 0;
        do
        {
          v6 = sub_27D4C();
          if ( v6 > 0 )
          {
            v7 = 0;
            v8 = (char *)&unk_D27D0 + 4096 * (v5 + v0);
            v9 = (char *)&unk_D27D0 + 4096 * (v5 + v0) + 4 * v6;
            do
            {
              v10 = *((_DWORD *)v8 + 1);
              v8 += 4;
              v7 += v10;
            }
            while ( v8 != v9 );
            v4 += v7;
          }
          else
          {
            v7 = 0;
          }
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(s, 0x2000u, "IC[%03d] = %-10d ", v5, v7);
            sub_41DB8(4, s, 0);
          }
          ++v5;
          v11 = sub_27D2C();
          result = sub_967AC(v5, v11);
          if ( !v12 && (unsigned int)off_BC5EC > 4 )
          {
            strcpy(s, "\n");
            result = sub_41DB8(4, s, 0);
          }
        }
        while ( v5 != v3 );
      }
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(s, 0x2000u, "Chain[%d] total nonce number = %d\n", i, v4);
        result = sub_41DB8(4, s, 0);
        if ( (unsigned int)off_BC5EC > 4 )
        {
          strcpy(s, "\n");
          result = sub_41DB8(4, s, 0);
        }
      }
    }
    v0 += 256;
  }
  return result;
}
// 3F454: variable 'v12' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0003F570) --------------------------------------------------------
int __fastcall sub_3F570(int a1, unsigned int a2)
{
  int v4; // r4
  int v5; // r0
  int v6; // r5
  unsigned int v7; // r0
  unsigned int v8; // r4
  unsigned int v9; // r4
  unsigned int v10; // r0
  int v11; // r1
  unsigned int v12; // r6
  int v13; // r0
  unsigned int v14; // r1
  unsigned int v15; // r7
  int v16; // r5
  int result; // r0
  char *v18; // lr
  char *v19; // r3
  int v20; // t1

  v4 = sub_27D4C();
  v5 = sub_27D7C();
  v6 = sub_96518(v4, v5);
  v7 = sub_27D7C();
  v8 = sub_962A0(a2, v7);
  v9 = v8 * sub_27D2C();
  v10 = sub_27D7C();
  sub_964FC(a2, v10);
  v12 = v6 * v11;
  v13 = sub_27D2C();
  v14 = v13 + v9;
  v15 = v6 + v12;
  if ( v9 >= v13 + v9 )
    return 0;
  v16 = 4 * v6;
  result = 0;
  v18 = (char *)&unk_D17C0 + 4096 * (v9 + (a1 << 8)) + 4 * v12 + 4112;
  do
  {
    if ( v12 < v15 )
    {
      v19 = v18;
      do
      {
        v20 = *((_DWORD *)v19 + 1);
        v19 += 4;
        result += v20;
      }
      while ( v19 != &v18[v16] );
    }
    ++v9;
    v18 += 4096;
  }
  while ( v14 != v9 );
  return result;
}
// 3F5C4: variable 'v11' is possibly undefined

//----- (0003F63C) --------------------------------------------------------
int __fastcall sub_3F63C(unsigned int a1, unsigned int a2)
{
  bool v2; // cc

  v2 = a2 > 0xFF;
  if ( a2 <= 0xFF )
    v2 = a1 > 3;
  if ( v2 )
    return 0;
  else
    return *((_DWORD *)&unk_D17C4 + 256 * a1 + a2 + 4);
}

//----- (0003F660) --------------------------------------------------------
int sub_3F660()
{
  int i; // r5
  int result; // r0
  int v2; // r7
  unsigned int j; // r4
  unsigned int v4; // r0
  int v5; // r1
  int v6; // r6
  int v7; // r3
  int v8; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "\n dump domain nonce number...\n");
    sub_41DB8(4, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      if ( (unsigned int)off_BC5EC > 4 )
      {
        snprintf(s, 0x2000u, "Chain[%d]:\n", i);
        sub_41DB8(4, s, 0);
      }
      v2 = 0;
      for ( j = 0; ; ++j )
      {
        v6 = sub_27D0C();
        v7 = sub_27D7C() * v6;
        result = i;
        if ( v7 <= (int)j )
          break;
        v8 = sub_3F570(i, j);
        v2 += v8;
        if ( (unsigned int)off_BC5EC > 4 )
        {
          snprintf(s, 0x2000u, "D[%02d]:%-10d ", j, v8);
          sub_41DB8(4, s, 0);
        }
        v4 = sub_27D7C();
        sub_967AC(j + 1, v4);
        if ( !v5 )
        {
          if ( (unsigned int)off_BC5EC > 4 )
          {
            snprintf(s, 0x2000u, "D_BIG[%02d]:%-10d\n", j >> 2, v2);
            v2 = 0;
            sub_41DB8(4, s, 0);
          }
          else
          {
            v2 = 0;
          }
        }
      }
      if ( (unsigned int)off_BC5EC > 4 )
      {
        strcpy(s, "\n");
        result = sub_41DB8(4, s, 0);
      }
    }
  }
  return result;
}
// 3F6F4: variable 'v5' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0003F82C) --------------------------------------------------------
char *sub_3F82C()
{
  return off_BC5E8;
}
// BC5E8: using guessed type char *off_BC5E8;

//----- (0003F83C) --------------------------------------------------------
char *__fastcall sub_3F83C(int a1, int a2)
{
  char *result; // r0
  char *v5; // r6
  void *v6; // r12
  int v7; // r7
  char *v8; // r4
  char *v9; // r3
  int v10; // r1
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "\n asic nonce number for chain[%d] asic[%d]...\n", a1, a2);
    sub_42CB4(3, s, 0);
    result = (char *)sub_27D4C();
    v5 = result;
    if ( (int)result > 0 )
      goto LABEL_3;
  }
  else
  {
    result = (char *)sub_27D4C();
    v5 = result;
    if ( (int)result > 0 )
    {
LABEL_3:
      v6 = off_BC5EC;
      v7 = (a2 + (a1 << 8)) << 12;
      v8 = 0;
      while ( 1 )
      {
        if ( (unsigned int)v6 > 3 )
        {
          memset(s, 0, 0x2000u);
          v9 = v8;
          v10 = v7 + 4 * (_DWORD)v8++ + 4112;
          snprintf(s, 0x2000u, "core[%03d]=%-8d", v9, *(int *)((char *)dword_D17C4 + v10));
          sub_42CB4(3, s, 0);
          result = s;
          v6 = off_BC5EC;
          if ( v8 != (char *)(10 * ((unsigned int)v8 / 0xA)) || (unsigned int)off_BC5EC <= 3 )
            goto LABEL_4;
          memset(s, (unsigned int)v8 % 0xA, 0x2000u);
          *(_WORD *)s = 10;
          result = sub_42CB4(3, s, (unsigned int)v8 % 0xA);
          v6 = off_BC5EC;
          if ( v5 == v8 )
            goto LABEL_10;
        }
        else
        {
          ++v8;
LABEL_4:
          if ( v5 == v8 )
            goto LABEL_10;
        }
      }
    }
  }
  v6 = off_BC5EC;
LABEL_10:
  if ( (unsigned int)v6 > 3 )
  {
    memset(s, 0, 0x2000u);
    *(_WORD *)s = 10;
    return sub_42CB4(3, s, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// D17C4: using guessed type int dword_D17C4[3];

//----- (0003F9E4) --------------------------------------------------------
int sub_3F9E4()
{
  int v0; // r4
  int v1; // r11
  int v2; // r6
  int result; // r0
  int *v4; // r0
  int v5; // r5
  char *v6; // r8
  int v7; // t1
  int v8; // r7
  int v9; // r9
  unsigned int v10; // r0
  int v11; // r1
  int *v12; // r9
  int v13; // r0
  int v14; // r0
  int v15; // [sp+18h] [bp-11Ch]
  int v16; // [sp+20h] [bp-114h]
  char s[260]; // [sp+30h] [bp-104h] BYREF

  v0 = 0;
  v1 = 0;
  v2 = 0;
  memset(s, 0, 0x100u);
  do
  {
    result = sub_27EC8(v1);
    if ( result )
    {
      v4 = (int *)dword_C47A8;
      if ( !dword_C47A8 )
      {
        v4 = sub_835A0("bmminer_nonce");
        dword_C47A8 = (int)v4;
      }
      sub_85464(
        (int)v4,
        "asic_response.c",
        15,
        (int)"dump_nonce_info_all_core",
        24,
        793,
        20,
        (int)"\n asic nonce number for chain[%d]...\n",
        v1);
      result = sub_27D1C();
      v16 = result;
      if ( result > 0 )
      {
        v5 = 0;
        v6 = (char *)&unk_D17D0 + 1024 * v1;
        do
        {
          v7 = *((_DWORD *)v6 + 1);
          v6 += 4;
          v8 = v5 + 1;
          v2 += v7;
          v9 = snprintf(&s[v0], 256 - v0, "asic[%03d]=%-8d", v5, v7);
          v10 = sub_27D2C();
          result = sub_967AC(v5 + 1, v10);
          v0 += v9;
          if ( !v11 )
          {
            v12 = (int *)dword_C47A8;
            if ( !dword_C47A8 )
            {
              v12 = sub_835A0("bmminer_nonce");
              dword_C47A8 = (int)v12;
            }
            v13 = sub_27D2C();
            v15 = v2;
            v2 = 0;
            v0 = 0;
            v14 = sub_96518(v5, v13);
            result = sub_85464(
                       (int)v12,
                       "asic_response.c",
                       15,
                       (int)"dump_nonce_info_all_core",
                       24,
                       799,
                       20,
                       (int)"domain %02d %s total=%-8u",
                       v14,
                       s,
                       v15);
          }
          ++v5;
        }
        while ( v8 != v16 );
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  return result;
}
// 3FAFC: variable 'v11' is possibly undefined
// C47A8: using guessed type int dword_C47A8;

//----- (0003FC14) --------------------------------------------------------
int __fastcall sub_3FC14(int a1, unsigned int a2, _DWORD *a3)
{
  if ( a2 > 0xFE )
    return -1;
  if ( a3 )
    *a3 = dword_674534[a2];
  dword_674534[a2] = a1;
  return 0;
}
// 674534: using guessed type _DWORD dword_674534[136];

//----- (0003FC44) --------------------------------------------------------
int __fastcall sub_3FC44(unsigned int a1)
{
  double v1; // d0
  const char *v2; // r0
  int v3; // r3
  int v4; // s20
  const char *v5; // r0
  float *v6; // r10
  float v7; // s17
  unsigned int v8; // r7
  int v9; // r8
  float v10; // s19
  int v11; // r9
  char v12; // r11
  float v13; // s18
  float v14; // s16
  unsigned int i; // r4
  float *v16; // r3
  float v17; // s15
  int v18; // r5
  int v19; // r6
  void *v20; // r1
  int v21; // r3
  int v22; // r0
  float v23; // s15
  int j; // r3
  float v25; // s14
  int *v26; // r0
  const char *v27; // r0
  float v29; // s15
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  float *v35; // r6
  unsigned int k; // r10
  unsigned int v37; // r4
  int v38; // r5
  unsigned int v39; // r9
  float v40; // s15
  int v41; // r0
  char *v42; // r8
  char *v43; // r9
  int v44; // r0
  int v45; // r8
  int v46; // r0
  int v47; // r0
  char *v48; // r7
  int v49; // r0
  unsigned __int8 *v50; // r8
  int v51; // r0
  int v52; // r0
  char v53; // r3
  unsigned int v54; // r3
  signed int v55; // r9
  int v56; // r0
  int v57; // r9
  int v58; // r0
  int v59; // r0
  int v60; // r1
  float v61; // s15
  char *v62; // r7
  int v63; // r8
  unsigned int v64; // s17
  unsigned int v65; // r9
  int v66; // r0
  char *v67; // r0
  char v68; // r3
  bool v69; // cc
  int v70; // r0
  int v71; // r9
  int v72; // r0
  int v73; // r0
  int v74; // r0
  int v75; // r0
  double v76; // d9
  signed int v77; // r0
  int v78; // r0
  int v79; // r8
  int v80; // r0
  int v81; // r0
  int v82; // [sp+10h] [bp-4454h]
  int v83; // [sp+10h] [bp-4454h]
  int v84; // [sp+10h] [bp-4454h]
  int v85; // [sp+10h] [bp-4454h]
  int v86; // [sp+14h] [bp-4450h]
  int v87; // [sp+14h] [bp-4450h]
  int v88; // [sp+14h] [bp-4450h]
  int v89; // [sp+14h] [bp-4450h]
  unsigned int v90; // [sp+44h] [bp-4420h]
  unsigned int v91; // [sp+44h] [bp-4420h]
  char *v92; // [sp+48h] [bp-441Ch]
  int v93; // [sp+4Ch] [bp-4418h]
  int v94; // [sp+4Ch] [bp-4418h]
  char *v96; // [sp+54h] [bp-4410h]
  int v97; // [sp+58h] [bp-440Ch]
  char *v98; // [sp+58h] [bp-440Ch]
  unsigned int v99; // [sp+5Ch] [bp-4408h]
  _BYTE s[1024]; // [sp+60h] [bp-4404h] BYREF
  _QWORD v101[1024]; // [sp+460h] [bp-4004h] BYREF
  char v102[8196]; // [sp+2460h] [bp-2004h] BYREF

  v2 = (const char *)sub_27CEC();
  if ( !strcmp(v2, "H1HB68601") )
    v3 = 9;
  else
    v3 = 10;
  v4 = v3;
  v5 = (const char *)sub_27CEC();
  if ( !strcmp(v5, "HHB68701")
    || (v30 = (const char *)sub_27CEC(), !strcmp(v30, "HHB68704"))
    || (v31 = (const char *)sub_27CEC(), !strcmp(v31, "HHB68703")) )
  {
    v4 = 8;
  }
  if ( sub_27EB8() < a1 )
    return -1;
  v6 = (float *)s;
  v7 = 0.0;
  memset(s, 0, sizeof(s));
  v90 = a1 << 8;
  v8 = 0;
  memset(v101, 0, sizeof(v101));
  v93 = 0;
  v9 = 255;
  v10 = 0.0;
  v92 = &byte_C3644[256 * a1];
  v11 = 255;
  v12 = 1;
  v13 = 300.0;
  if ( !sub_28744() )
    goto LABEL_24;
  do
  {
    v14 = *v6;
    for ( i = 0; sub_28758() > i; ++i )
    {
      v18 = sub_2876C(v8, i) - 1;
      if ( v18 < 0 )
        continue;
      v19 = (unsigned __int8)v92[v18 + 3340];
      if ( v92[v18 + 3340] )
      {
        v16 = &flt_D07C4[v90 + v18];
        dword_C57C4[v90 + v18] = 0;
        v17 = *v16;
        v14 = v14 + *v16;
        if ( *v16 > v7 )
          v11 = v18;
        v10 = v10 + v17;
        if ( *v16 > v7 )
          v7 = *v16;
        if ( v17 < v13 )
        {
          v9 = v18;
          v13 = *v16;
        }
        *v6 = v14;
      }
      else
      {
        ++v93;
        v20 = off_BC5EC;
        v21 = dword_C57C4[v90 + v18] + 1;
        dword_C57C4[v90 + v18] = v21;
        if ( v21 == 100 )
        {
          if ( (unsigned int)v20 <= 4
            || (snprintf(
                  v102,
                  0x2000u,
                  "chain %d asic %d temp not update last %d times, pre_temp:%.2f",
                  a1,
                  v18,
                  100,
                  flt_CF7C4[v90 + v18]),
                sub_41DB8(4, v102, v19),
                (unsigned int)off_BC5EC <= 4) )
          {
LABEL_22:
            v12 = 0;
            continue;
          }
        }
        else if ( (unsigned int)v20 <= 4 )
        {
          goto LABEL_22;
        }
        v12 = 0;
        snprintf(v102, 0x2000u, "chain %d asic %d temp not update", a1, v18);
        sub_41DB8(4, v102, 0);
      }
    }
    ++v8;
    *v6++ = v14 / (float)sub_28758();
  }
  while ( sub_28744() > v8 );
LABEL_24:
  if ( sub_27D1C() != v93 )
  {
    v29 = (float)(unsigned int)(sub_27D1C() - v93);
    v94 = a1;
    flt_C47AC[a1] = v10 / v29;
    v22 = sub_27EB8();
    if ( v22 )
      goto LABEL_26;
    goto LABEL_37;
  }
  v94 = a1;
  v22 = sub_27EB8();
  if ( !v22 )
  {
LABEL_37:
    v23 = 0.0;
    goto LABEL_28;
  }
LABEL_26:
  v23 = 0.0;
  for ( j = 0; j != v22; ++j )
    v23 = v23 + flt_C47AC[v94];
LABEL_28:
  v25 = (float)v22;
  v26 = (int *)dword_C47C0;
  flt_C47BC = v23 / v25;
  if ( !dword_C47C0 )
  {
    v26 = sub_835A0("bmminer_auto_temp");
    dword_C47C0 = (int)v26;
  }
  sub_85464(
    (int)v26,
    "asic_response.c",
    15,
    (int)"check_chain_asic_temp",
    21,
    1094,
    20,
    (int)"chain:%d, avg temp:%.2f, asic[%d] max temp:%.2f, asic[%d] min temp:%.2f",
    a1,
    flt_C47AC[v94],
    v11,
    v7,
    v9,
    v13);
  v27 = (const char *)sub_27CEC();
  if ( !strcmp(v27, "HHB68701")
    || (v32 = (const char *)sub_27CEC(), !strcmp(v32, "HHB68704"))
    || (v33 = (const char *)sub_27CEC(), !strcmp(v33, "H1HB68601"))
    || (v34 = (const char *)sub_27CEC(), !strcmp(v34, "HHB68703")) )
  {
    if ( ((unsigned __int8)v12 & (unsigned __int8)byte_C1E68) != 0 )
    {
      v35 = (float *)s;
      v91 = a1 << 8;
      for ( k = 0; sub_28744() > k; ++k )
      {
        v37 = 0;
        v96 = &byte_C3644[v91];
        while ( sub_28758() > v37 )
        {
          v38 = sub_2876C(k, v37) - 1;
          if ( v38 >= 0 )
          {
            v39 = v91 + v38;
            v40 = flt_D07C4[v91 + v38] - *v35;
            if ( v40 <= (float)(v4 + 5) )
            {
              if ( v40 > (float)v4 )
              {
                v48 = &byte_C3644[64 * a1];
                v49 = sub_27D2C();
                if ( v48[sub_96518(v38, v49) + 4] <= 2 && dword_C3748 <= 6449 )
                {
                  v50 = (unsigned __int8 *)&v96[v38];
                  if ( !v96[v38 + 264] )
                  {
                    v97 = v50[1288];
                    if ( !v50[1288] )
                    {
                      ++dword_C47C4[v39];
                      v51 = sub_27D2C();
                      v52 = sub_96518(v38, v51);
                      v53 = v48[v52 + 4];
                      v50[1288] = 1;
                      v50[2312] = 1;
                      v48[v52 + 4] = v53 + 1;
                      sub_4465C(&dword_CD7C4[2 * v39]);
                      sub_257E0(a1, v38);
                      v54 = (int)v1;
                      v55 = (int)v1 - 100;
                      LODWORD(v1) = 6.25;
                      v99 = v54;
                      if ( v55 < 200 )
                        v55 = 200;
                      sub_258B8(a1, (unsigned __int8)v38, (unsigned __int8)byte_4D4184, v54, v55, 10);
                      dword_C3748 += v99 - v55;
                      if ( (unsigned int)off_BC5EC > 4 )
                      {
                        v56 = sub_27D2C();
                        v57 = sub_96518(v38, v56);
                        v58 = sub_27D2C();
                        v87 = v50[264];
                        v83 = dword_C3748;
                        v59 = sub_96518(v38, v58);
                        snprintf(
                          v102,
                          0x2000u,
                          "%s, %d, chain:%d domain:%d  domain_err_cnt:%d total_dec_freq:%d core_off_cnt:%d",
                          "check_chain_asic_temp",
                          1178,
                          a1,
                          v57,
                          v48[v59 + 4],
                          v83,
                          v87);
                        sub_41DB8(4, v102, v97);
                      }
                    }
                  }
                }
              }
              else if ( v40 < 3.0 )
              {
                dword_C47C4[v39] = 0;
                sub_4465C((__time_t *)&v101[v39]);
                v60 = LODWORD(v101[v39]) - dword_CD7C4[2 * v39];
                if ( HIDWORD(v101[v39]) - dword_CD7C4[2 * v39 + 1] < 0 )
                  --v60;
                if ( v60 > 600 )
                {
                  v61 = flt_D07C4[v91 + v38];
                  if ( v61 < 80.0 && (float)(v61 - flt_C47AC[v94]) < 8.0 )
                  {
                    v62 = &v96[v38];
                    v63 = (unsigned __int8)v96[v38 + 264];
                    if ( v96[v38 + 264] )
                    {
                      v62[1288] = 1;
                      sub_4465C(&dword_CD7C4[2 * v39]);
                      sub_257E0(a1, v38);
                      v76 = v1;
                      v77 = sub_25724(a1, v38) - 200;
                      if ( v77 < 200 )
                        v77 = 200;
                      LODWORD(v1) = 6.25;
                      sub_258B8(a1, (unsigned __int8)v38, (unsigned __int8)byte_4D4184, (int)v76, v77, 10);
                      sub_7FF54((unsigned __int8)a1, v38, 1);
                      sub_8056C((unsigned __int8)a1, v38);
                      v62[264] = 0;
                      sub_257E0(a1, v38);
                      LODWORD(v1) = (int)v1;
                      dword_C3748 -= LODWORD(v1);
                      if ( (unsigned int)off_BC5EC > 4 )
                      {
                        snprintf(v102, 0x2000u, "chain %d asic %d core enable", a1, v38);
                        sub_41DB8(4, v102, 0);
                        if ( (unsigned int)off_BC5EC > 4 )
                        {
                          v78 = sub_27D2C();
                          v79 = sub_96518(v38, v78);
                          v80 = sub_27D2C();
                          v89 = (unsigned __int8)v62[264];
                          v85 = dword_C3748;
                          v81 = sub_96518(v38, v80);
                          snprintf(
                            v102,
                            0x2000u,
                            "%s, %d, chain:%d domain:%d  domain_err_cnt:%d total_dec_freq:%d core_off_cnt:%d",
                            "check_chain_asic_temp",
                            1207,
                            a1,
                            v79,
                            byte_C3644[64 * a1 + 4 + v81],
                            v85,
                            v89);
                          sub_41DB8(4, v102, 0);
                        }
                      }
                    }
                    else if ( v62[1288] )
                    {
                      sub_257E0(a1, v38);
                      v64 = (int)v1;
                      v98 = &byte_C3644[64 * a1];
                      v65 = sub_25724(a1, v38);
                      LODWORD(v1) = 6.25;
                      sub_258B8(a1, (unsigned __int8)v38, (unsigned __int8)byte_4D4184, v64, v65, 10);
                      v62[1288] = v63;
                      v66 = sub_27D2C();
                      v67 = &v98[sub_96518(v38, v66)];
                      v68 = v67[4];
                      v69 = (unsigned int)off_BC5EC > 4;
                      dword_C3748 -= v65 - v64;
                      v67[4] = v68 - 1;
                      if ( v69 )
                      {
                        v70 = sub_27D2C();
                        v71 = sub_96518(v38, v70);
                        v72 = sub_27D2C();
                        v88 = (unsigned __int8)v62[264];
                        v84 = dword_C3748;
                        v73 = sub_96518(v38, v72);
                        snprintf(
                          v102,
                          0x2000u,
                          "%s, %d, chain:%d domain:%d  domain_err_cnt:%d total_dec_freq:%d core_off_cnt:%d",
                          "check_chain_asic_temp",
                          1219,
                          a1,
                          v71,
                          v98[v73 + 4],
                          v84,
                          v88);
                        sub_41DB8(4, v102, v63);
                      }
                    }
                  }
                }
              }
              else
              {
                dword_C47C4[v39] = 0;
              }
            }
            else
            {
              v41 = sub_27D2C();
              v42 = &byte_C3644[64 * a1];
              if ( v42[sub_96518(v38, v41) + 4] <= 2 && dword_C3748 <= 6449 && !v96[v38 + 264] )
              {
                if ( !v96[v38 + 1288] )
                {
                  v74 = sub_27D2C();
                  v75 = sub_96518(v38, v74);
                  ++v42[v75 + 4];
                }
                ++dword_C47C4[v91 + v38];
                v43 = &v96[v38];
                v43[264] = 1;
                v43[2312] = 1;
                sub_4465C(&dword_CD7C4[2 * v91 + 2 * v38]);
                sub_7FF54((unsigned __int8)a1, v38, 0);
                sub_80600((unsigned __int8)a1, v38);
                sub_257E0(a1, v38);
                LODWORD(v1) = (int)v1;
                dword_C3748 += LODWORD(v1);
                if ( (unsigned int)off_BC5EC > 4 )
                {
                  snprintf(v102, 0x2000u, "chain %d asic %d core disable", a1, v38);
                  sub_41DB8(4, v102, 0);
                  if ( (unsigned int)off_BC5EC > 4 )
                  {
                    v44 = sub_27D2C();
                    v45 = sub_96518(v38, v44);
                    v46 = sub_27D2C();
                    v86 = (unsigned __int8)v43[264];
                    v82 = dword_C3748;
                    v47 = sub_96518(v38, v46);
                    snprintf(
                      v102,
                      0x2000u,
                      "%s, %d, chain:%d domain:%d  domain_err_cnt:%d total_dec_freq:%d core_off_cnt:%d",
                      "check_chain_asic_temp",
                      1160,
                      a1,
                      v45,
                      byte_C3644[64 * a1 + 4 + v47],
                      v82,
                      v86);
                    sub_41DB8(4, v102, 0);
                  }
                }
              }
            }
          }
          ++v37;
        }
        ++v35;
      }
    }
  }
  return 0;
}
// 40274: variable 'v1' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C1E68: using guessed type char byte_C1E68;
// C3748: using guessed type int dword_C3748;
// C47AC: using guessed type float flt_C47AC[4];
// C47BC: using guessed type float flt_C47BC;
// C47C0: using guessed type int dword_C47C0;
// C47C4: using guessed type _DWORD dword_C47C4[926];
// C57C4: using guessed type _DWORD dword_C57C4[1024];
// CD7C4: using guessed type __time_t dword_CD7C4[2048];
// CF7C4: using guessed type float flt_CF7C4[1024];
// D07C4: using guessed type float flt_D07C4[1023];
// 4D4184: using guessed type char byte_4D4184;

//----- (000408E4) --------------------------------------------------------
void __fastcall sub_408E4(int a1)
{
  int v2; // r5
  char *v3; // r6
  float v4; // s17
  int v5; // r4
  int v6; // r0
  float v7; // s16
  bool v8; // cc
  int v9; // r1
  float v10; // s16
  char s[128]; // [sp+8h] [bp-2080h] BYREF
  char src[4]; // [sp+88h] [bp-2000h] BYREF
  int v13; // [sp+8Ch] [bp-1FFCh]
  int v14; // [sp+90h] [bp-1FF8h]
  int v15; // [sp+94h] [bp-1FF4h]
  int v16; // [sp+98h] [bp-1FF0h]
  int v17; // [sp+9Ch] [bp-1FECh]
  char v18; // [sp+A0h] [bp-1FE8h]

  v2 = 0;
  v3 = (char *)calloc(1u, 0x6000u);
  memset(s, 0, sizeof(s));
  snprintf(s, 0x40u, "\nchain[%d] asic temperature:\n", a1);
  strcat(v3, s);
  v4 = 0.0;
  if ( sub_28744() > 0 )
  {
    do
    {
      v5 = 0;
      while ( 1 )
      {
        v8 = sub_28758() <= v5;
        v9 = v5++;
        if ( v8 )
          break;
        v6 = sub_2876C(v2, v9);
        *(_DWORD *)src = 0;
        v7 = flt_D07C4[256 * a1 - 1 + v6];
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        sprintf(src, "%.2f ", v7);
        v4 = v4 + v7;
        strcat(v3, src);
      }
      ++v2;
      *(_WORD *)&v3[strlen(v3)] = 10;
    }
    while ( sub_28744() > v2 );
  }
  v10 = (float)sub_27D1C();
  memset(s, 0, sizeof(s));
  sprintf(s, "chain%d avg temperature = %.2f\n", a1, (float)(v4 / v10));
  strcat(v3, s);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(src, 0x2000u, "%s", v3);
    sub_41DB8(3, src, 0);
  }
  free(v3);
}
// 98278: using guessed type __int16 word_98278;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// D07C4: using guessed type float flt_D07C4[1023];

//----- (00040AA4) --------------------------------------------------------
int __fastcall sub_40AA4(const char **a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  const char *v7; // r2
  signed int v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  char *v12; // r5
  const char *v13; // r3
  const char *v14; // r1
  __int64 v15; // r2
  int v16; // r0
  int v17; // r3
  int v18; // r2
  const char *v19; // r3
  char *v20; // r0
  int v21; // r1
  const char *v22; // r0
  char s[8192]; // [sp+20h] [bp-2000h] BYREF

  result = *((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      0x2000u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    sub_41DB8(3, s, 1);
    result = nullsub_1(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (signed int)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (signed int)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x2000u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    sub_41DB8(3, s, 1);
    nullsub_1(1);
  }
  v12 = (char *)calloc(v8, 0x10u);
  if ( !v12 )
  {
    snprintf(
      s,
      0x2000u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    sub_41DB8(3, s, 1);
    nullsub_1(1);
  }
  *(_DWORD *)&a1[13][4 * (_DWORD)(a1[12] + 0x3FFFFFFF)] = v12;
  v13 = a1[6];
  v14 = *a1;
  a1[7] = (const char *)v8;
  a1[8] = (const char *)v8;
  a1[6] = &v13[v8];
  *(_DWORD *)v12 = v14;
  *((_DWORD *)v12 + 1) = 0;
  *((_DWORD *)v12 + 2) = v12 + 16;
  if ( v8 > 2 )
  {
    HIDWORD(v15) = v12 + 32;
    do
    {
      LODWORD(v15) = HIDWORD(v15) - 32;
      *(_DWORD *)(HIDWORD(v15) - 16) = v14;
      *(_QWORD *)(HIDWORD(v15) - 12) = v15;
      HIDWORD(v15) += 16;
    }
    while ( (char *)HIDWORD(v15) != &v12[16 * v8] );
  }
  v16 = *((unsigned __int8 *)a1 + 44);
  v17 = 16 * (v8 + 0xFFFFFFF);
  *(_DWORD *)&v12[v17] = v14;
  a1[3] = v12;
  v18 = v17 - 16;
  v19 = &v12[v17];
  *((_DWORD *)v19 + 1) = &v12[v18];
  *((_DWORD *)v19 + 2) = 0;
  if ( v16 )
    a1[4] = v19;
  do
  {
    v20 = (char *)a1[15];
    v21 = (int)(a1[14] + 1);
    a1[14] = (const char *)v21;
    v22 = (const char *)realloc(v20, 4 * v21);
    a1[15] = v22;
    if ( !v22 )
    {
      snprintf(
        s,
        0x2000u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      sub_41DB8(3, s, 1);
      nullsub_1(1);
    }
    result = (int)calloc(1u, (size_t)a1[5]);
    *((_DWORD *)v12 + 3) = result;
    if ( !result )
    {
      snprintf(s, 0x2000u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      sub_41DB8(3, s, 1);
      nullsub_1(1);
      result = *((_DWORD *)v12 + 3);
    }
    *(_DWORD *)&a1[15][4 * (_DWORD)(a1[14] + 0x3FFFFFFF)] = result;
    v12 = (char *)*((_DWORD *)v12 + 2);
  }
  while ( v12 );
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00041168) --------------------------------------------------------
int __fastcall sub_41168(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r12
  int v6; // r3

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return 0;
    sub_40AA4((const char **)a1, a2, a3, a4);
    v5 = *(_DWORD *)(a1 + 12);
    if ( !v5 )
      return 0;
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return v5;
}

//----- (000411F0) --------------------------------------------------------
int __fastcall sub_411F0(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = sub_41168(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (0004121C) --------------------------------------------------------
int __fastcall sub_4121C(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  char s[8196]; // [sp+20h] [bp-2004h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    sub_41DB8(3, s, 1);
    nullsub_1(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      a3 = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = a3;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    --*(_DWORD *)(a1 + 28);
  }
  return result;
}
// 41258: variable 'a3' is possibly undefined
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (000412E4) --------------------------------------------------------
const char *__fastcall sub_412E4(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  int v8; // r3
  int v9; // r3
  __int64 v10; // r2
  char s[8160]; // [sp+20h] [bp-2000h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_add_head",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    sub_41DB8(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  v8 = *(_DWORD *)(a1 + 12);
  if ( v8 )
    *(_DWORD *)(v8 + 4) = a2;
  v9 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v9 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v10 = *(_QWORD *)(a1 + 28);
  LODWORD(v10) = v10 + 1;
  ++HIDWORD(v10);
  *(_QWORD *)(a1 + 28) = v10;
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (000413C8) --------------------------------------------------------
const char **__fastcall sub_413C8(const char **result, int a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char **v8; // r4
  const char *v10; // r3
  const char *v11; // r3
  const char *v12; // r3
  bool v13; // zf
  __int64 v14; // r2
  char s[8160]; // [sp+20h] [bp-2004h] BYREF

  v7 = *(const char **)a2;
  v8 = result;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      v7,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    sub_41DB8(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  if ( !*((_BYTE *)v8 + 44) )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *v8,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    sub_41DB8(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  v10 = v8[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v10;
  v11 = v8[4];
  if ( v11 )
    *((_DWORD *)v11 + 2) = a2;
  v12 = v8[3];
  v8[4] = (const char *)a2;
  v13 = v12 == 0;
  v14 = *(_QWORD *)(v8 + 7);
  if ( v13 )
    v8[3] = (const char *)a2;
  LODWORD(v14) = v14 + 1;
  ++HIDWORD(v14);
  *(_QWORD *)(v8 + 7) = v14;
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00041524) --------------------------------------------------------
const char **__fastcall sub_41524(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v8; // r1
  const char **v9; // r4
  int v11; // r3
  __int64 v12; // r2
  char s[8160]; // [sp+20h] [bp-2004h] BYREF

  v8 = *(const char **)a2;
  v9 = result;
  if ( v8 != *result )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_before",
      v8,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    sub_41DB8(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x2000u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *v9,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    sub_41DB8(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  v11 = *(_DWORD *)(a3 + 4);
  if ( v11 )
    *(_DWORD *)(v11 + 8) = a2;
  else
    v9[3] = (const char *)a2;
  *(_DWORD *)(a3 + 4) = a2;
  v12 = *(_QWORD *)(v9 + 7);
  LODWORD(v12) = v12 + 1;
  ++HIDWORD(v12);
  *(_QWORD *)(v9 + 7) = v12;
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0004168C) --------------------------------------------------------
const char **__fastcall sub_4168C(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v8; // r1
  const char **v9; // r4
  int v11; // r3
  __int64 v12; // r2
  char s[8160]; // [sp+20h] [bp-2004h] BYREF

  v8 = *(const char **)a2;
  v9 = result;
  if ( v8 != *result )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_after",
      v8,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    sub_41DB8(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x2000u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *v9,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    sub_41DB8(3, s, 1);
    result = (const char **)nullsub_1(1);
  }
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  v11 = *(_DWORD *)(a3 + 8);
  if ( v11 )
  {
    *(_DWORD *)(v11 + 4) = a2;
  }
  else if ( *((_BYTE *)v9 + 44) )
  {
    v9[4] = (const char *)a2;
  }
  *(_DWORD *)(a3 + 8) = a2;
  v12 = *(_QWORD *)(v9 + 7);
  LODWORD(v12) = v12 + 1;
  ++HIDWORD(v12);
  *(_QWORD *)(v9 + 7) = v12;
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00041800) --------------------------------------------------------
const char *__fastcall sub_41800(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  __int64 v8; // r2
  char s[8160]; // [sp+20h] [bp-2000h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_item",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    sub_41DB8(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  v8 = *(_QWORD *)(a2 + 4);
  if ( (_DWORD)v8 )
  {
    *(_DWORD *)(v8 + 8) = HIDWORD(v8);
    HIDWORD(v8) = *(_DWORD *)(a2 + 8);
  }
  if ( HIDWORD(v8) )
    *(_DWORD *)(HIDWORD(v8) + 4) = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 12) == a2 )
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 16) == a2 )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (000418FC) --------------------------------------------------------
const char *__fastcall sub_418FC(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v9; // r1
  int v11; // r2
  const char *v12; // r3
  const char *v13; // r1
  char s[8160]; // [sp+20h] [bp-2000h] BYREF

  result = *a1;
  v9 = *(const char **)a2;
  if ( result != v9 )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_head",
      v9,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    sub_41DB8(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    sub_41DB8(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  if ( a1[3] )
  {
    v11 = *(_DWORD *)(a2 + 12);
    v12 = a1[4];
    if ( v11 )
      *(_DWORD *)(v11 + 4) = v12;
    else
      *(_DWORD *)(a2 + 16) = v12;
    if ( v11 )
      v11 = *(_DWORD *)(a2 + 12);
    *((_DWORD *)a1[4] + 2) = v11;
    *(_DWORD *)(a2 + 12) = a1[3];
    a1[4] = 0;
    v13 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v13;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00041A84) --------------------------------------------------------
const char *__fastcall sub_41A84(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v9; // r1
  const char *v11; // r3
  int v12; // r2
  const char *v13; // r1
  char s[8160]; // [sp+20h] [bp-2000h] BYREF

  result = *a1;
  v9 = *(const char **)a2;
  if ( result != v9 )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_tail",
      v9,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    sub_41DB8(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    sub_41DB8(3, s, 1);
    result = (const char *)nullsub_1(1);
  }
  v11 = a1[3];
  if ( v11 )
  {
    v12 = *(_DWORD *)(a2 + 16);
    if ( v12 )
      *(_DWORD *)(v12 + 8) = v11;
    else
      *(_DWORD *)(a2 + 12) = v11;
    if ( v12 )
      v12 = *(_DWORD *)(a2 + 16);
    *((_DWORD *)a1[3] + 1) = v12;
    *(_DWORD *)(a2 + 16) = a1[4];
    a1[4] = 0;
    v13 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v13;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00041C08) --------------------------------------------------------
int __fastcall sub_41C08(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[8196]; // [sp+20h] [bp-2004h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      0x2000u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    sub_41DB8(3, s, 1);
    nullsub_1(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00041D24) --------------------------------------------------------
int __fastcall sub_41D24(const char **ptr, const char *a2, const char *a3, int a4)
{
  char s[8196]; // [sp+20h] [bp-2004h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      0x2000u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    sub_41DB8(3, s, 1);
    nullsub_1(1);
  }
  free(ptr);
  return 0;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00041DB8) --------------------------------------------------------
int __fastcall sub_41DB8(int a1, const char *a2, int a3)
{
  int *v5; // r0
  int result; // r0
  int v8; // r4
  struct tm *v9; // r0
  int v10; // r0
  FILE *v11; // r6
  size_t v12; // r0
  size_t v13; // r0
  int *v14; // r0
  int v15; // r7
  time_t timer; // [sp+1Ch] [bp-4Ch] BYREF
  __time_t v17; // [sp+20h] [bp-48h] BYREF
  int v18; // [sp+24h] [bp-44h]
  char s[64]; // [sp+28h] [bp-40h] BYREF

  if ( byte_6682BC )
  {
    syslog(a1 | 0x80, "%s", a2);
    v5 = (int *)dword_4D37D8;
    if ( !dword_4D37D8 )
    {
      v5 = sub_835A0("bmminer_miner");
      dword_4D37D8 = (int)v5;
    }
    return sub_85464((int)v5, "logging.c", 9, (int)"_applog", 7, 136, 60, (int)"%s", a2);
  }
  else
  {
    v17 = 0;
    v18 = 0;
    sub_4465C(&v17);
    timer = v17;
    v8 = v18 / 1000;
    v9 = localtime(&timer);
    snprintf(
      s,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      v9->tm_year + 1900,
      v9->tm_mon + 1,
      v9->tm_mday,
      v9->tm_hour,
      v9->tm_min,
      v9->tm_sec,
      v8);
    v10 = fileno((FILE *)stderr);
    if ( !isatty(v10) )
    {
      fprintf((FILE *)stderr, "%s%s\n", s, a2);
      fflush((FILE *)stderr);
    }
    if ( byte_4D37DC )
    {
      v11 = (FILE *)dword_4D37E0;
      if ( dword_4D37E0 || (v11 = fopen(byte_4D3804, modes), (dword_4D37E0 = (int)v11) != 0) )
      {
        v12 = strlen(s);
        fwrite(s, v12, 1u, v11);
        v13 = strlen(a2);
        fwrite(a2, v13, 1u, (FILE *)dword_4D37E0);
        fwrite(&word_98278, 1u, 1u, (FILE *)dword_4D37E0);
        fflush((FILE *)dword_4D37E0);
      }
    }
    v14 = (int *)dword_4D37D8;
    if ( !dword_4D37D8 )
    {
      v14 = sub_835A0("bmminer_miner");
      dword_4D37D8 = (int)v14;
    }
    result = sub_85464((int)v14, "logging.c", 9, (int)"_applog", 7, 182, 60, (int)"%s", a2);
    if ( a1 == 3 )
      v15 = 0;
    else
      v15 = byte_666208 & 1;
    if ( !v15 )
      return sub_42904(s, a2, a3);
  }
  return result;
}
// 98278: using guessed type __int16 word_98278;
// BDA08: using guessed type int stderr;
// 4D37D8: using guessed type int dword_4D37D8;
// 4D37DC: using guessed type char byte_4D37DC;
// 4D37E0: using guessed type int dword_4D37E0;
// 666208: using guessed type char byte_666208;
// 6682BC: using guessed type char byte_6682BC;

//----- (0004205C) --------------------------------------------------------
int __fastcall sub_4205C(const char *a1)
{
  FILE *v1; // r4
  int v2; // r0
  int v3; // r6
  int *v5; // r0
  char *v6; // r0
  char v7[1024]; // [sp+0h] [bp-2400h] BYREF
  char s[8192]; // [sp+400h] [bp-2000h] BYREF

  v1 = popen(a1, "r");
  if ( !v1 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v5 = _errno_location();
    v3 = -1;
    v6 = strerror(*v5);
    snprintf(s, 0x2000u, "popen error: %s/n", v6);
    sub_41DB8(3, s, 0);
    return v3;
  }
  while ( fgets(v7, 1024, v1) )
    ;
  v2 = pclose(v1);
  v3 = v2;
  if ( v2 != -1 )
  {
    if ( v2 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "pclose res is :%d\n", (v2 & 0x7F) == 0);
        sub_41DB8(3, s, 0);
      }
      return BYTE1(v3);
    }
    return v3;
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "close popen file pointer fp error!\n");
    sub_41DB8(3, s, 0);
    return v3;
  }
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000421B0) --------------------------------------------------------
int __fastcall sub_421B0(int a1, const char *a2, const char *a3, const char *a4)
{
  int v4; // r5
  char s[4072]; // [sp+18h] [bp-3004h] BYREF
  char v7[8196]; // [sp+1018h] [bp-2004h] BYREF

  if ( (unsigned int)snprintf(
                       s,
                       0x1000u,
                       "/usr/bin/updatename.sh %s %s %s %s %s %s",
                       *(const char **)(a1 + 8),
                       (const char *)(a1 + 42),
                       (const char *)(a1 + 72),
                       a2,
                       a3,
                       a4) < 0x1000 )
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v7, "_log_update_name\n");
      sub_41DB8(4, v7, 0);
      v4 = sub_4205C(s);
      if ( !v4 )
        return v4;
    }
    else
    {
      v4 = sub_4205C(s);
      if ( !v4 )
        return v4;
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v7, 0x2000u, "my_system returned failed %d on LOGUPDATENAME\n", v4);
      sub_41DB8(3, v7, 0);
    }
    return v4;
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v7, "too large command LOGUPDATENAME\n");
    sub_41DB8(3, v7, 0);
    return -1;
  }
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00042320) --------------------------------------------------------
int __fastcall sub_42320(int a1)
{
  int v2; // r4
  int v4; // r3
  int v5; // r0
  char s[4072]; // [sp+18h] [bp-3000h] BYREF
  char v7[8192]; // [sp+1018h] [bp-2000h] BYREF

  if ( (unsigned int)snprintf(s, 0x1000u, "/usr/bin/checksize.sh %d %s", 0, *(const char **)(a1 + 8)) < 0x1000 )
  {
    v4 = sub_4205C(s);
    if ( v4 && (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v7, 0x2000u, "my_system returned failed %d on LOGCHECKSIZE\n", v4);
      sub_41DB8(3, v7, 0);
    }
    if ( (unsigned int)snprintf(
                         s,
                         0x1000u,
                         "/usr/bin/rotate.sh %d %d %s %s %s %s %s",
                         0,
                         *(_DWORD *)a1,
                         *(const char **)(a1 + 8),
                         *(const char **)(a1 + 4),
                         (const char *)(a1 + 42),
                         (const char *)(a1 + 72),
                         *(const char **)(a1 + 92)) >= 0x1000 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        v2 = -1;
        strcpy(v7, "too large command LOGROTATE\n");
        sub_41DB8(3, v7, 0);
        return v2;
      }
      return -1;
    }
    v5 = sub_4205C(s);
    v2 = v5;
    if ( !v5 || (unsigned int)off_BC5EC <= 3 )
      return v2;
    snprintf(v7, 0x2000u, "my_system returned failed %d on LOGROTATE\n", v5);
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    v2 = -1;
    strcpy(v7, "too large command LOGCHECKSIZE\n");
  }
  sub_41DB8(3, v7, 0);
  return v2;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00042500) --------------------------------------------------------
void __fastcall __noreturn sub_42500(int a1)
{
  unsigned int v2; // r4
  struct tm *v3; // r7
  size_t v4; // r0
  int v5; // r7
  int v6; // r3
  char *dest; // [sp+14h] [bp-3048h]
  time_t timer; // [sp+20h] [bp-303Ch] BYREF
  char s[20]; // [sp+24h] [bp-3038h] BYREF
  char v10[32]; // [sp+38h] [bp-3024h] BYREF
  char v11[4072]; // [sp+58h] [bp-3004h] BYREF
  char v12[8196]; // [sp+1058h] [bp-2004h] BYREF

  if ( a1 )
  {
    v2 = 1;
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 92) = "cglog_sync";
    dest = (char *)(a1 + 72);
    while ( 1 )
    {
      do
      {
        ++v2;
        sleep(1u);
      }
      while ( v2 != 30 * (v2 / 0x1E) );
      time(&timer);
      v3 = localtime(&timer);
      strftime(v10, 0xFu, "%Y-%m/%d", v3);
      strftime(s, 0xAu, "%H-%M-%S", v3);
      if ( !strncmp((const char *)(a1 + 42), "1970", 4u) && timer > 31536000 )
      {
        v5 = sub_421B0(a1, "cglog_init", v10, s);
        if ( !(v5 | sub_421B0(a1, "cglog_sync", v10, s)) )
        {
          strncpy((char *)(a1 + 42), v10, 0x1Eu);
          strncpy(dest, s, 0x14u);
          strcpy((char *)(a1 + 12), (const char *)(a1 + 42));
        }
      }
      if ( *(_BYTE *)(a1 + 12) )
      {
        v4 = strlen(v10);
        if ( strncmp((const char *)(a1 + 12), v10, v4) )
        {
          if ( (unsigned int)snprintf(
                               v11,
                               0x1000u,
                               "/usr/bin/symbollink.sh %s %s %s %s %s",
                               *(const char **)(a1 + 8),
                               (const char *)(a1 + 42),
                               dest,
                               "cglog_sync",
                               v10) < 0x1000 )
          {
            v6 = sub_4205C(v11);
            if ( v6 )
            {
              if ( (unsigned int)off_BC5EC > 3 )
              {
                snprintf(v12, 0x2000u, "my_system returned failed %d on LOG_SYMBOL_LINK\n", v6);
                sub_41DB8(3, v12, 0);
              }
            }
            else
            {
              strncpy((char *)(a1 + 12), v10, 0x1Eu);
            }
          }
          else if ( (unsigned int)off_BC5EC > 3 )
          {
            strcpy(v12, "too large command LOG_SYMBOL_LINK\n");
            sub_41DB8(3, v12, 0);
          }
        }
      }
      else
      {
        strcpy((char *)(a1 + 12), (const char *)(a1 + 42));
      }
      sub_42320(a1);
    }
  }
  strcpy(v12, "input arg wrong\n");
  sub_41DB8(0, v12, 0);
  _assert_fail("0", "logging.c", 0x1CFu, "log_thread_routine");
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000427F4) --------------------------------------------------------
int __fastcall sub_427F4(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[8192]; // [sp+10h] [bp-2000h] BYREF

  result = pthread_mutex_unlock(&stru_66C3C4);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 0x2000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    sub_41DB8(3, s, 1);
    return nullsub_1(1);
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);
// 41DB8: using guessed type int __fastcall sub_41DB8(_DWORD, _DWORD, _DWORD);
// 66C3C4: using guessed type pthread_mutex_t stru_66C3C4;

//----- (0004287C) --------------------------------------------------------
int sub_4287C()
{
  int result; // r0
  int *v1; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  result = pthread_mutex_lock(&stru_66C3C4);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 0x2000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 55);
    sub_41DB8(3, s, 1);
    return nullsub_1(1);
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);
// 41DB8: using guessed type int __fastcall sub_41DB8(_DWORD, _DWORD, _DWORD);
// 66C3C4: using guessed type pthread_mutex_t stru_66C3C4;

//----- (00042904) --------------------------------------------------------
int __fastcall sub_42904(const char *a1, const char *a2, int a3)
{
  if ( a3 )
  {
    pthread_mutex_trylock(&stru_66C3C4);
    sub_427F4(44);
    off_BC718();
  }
  sub_4287C();
  printf("%s%s%s", a1, a2, "                    \n");
  sub_427F4(57);
  return off_BC718();
}
// BC718: using guessed type int (*off_BC718)();
// 66C3C4: using guessed type pthread_mutex_t stru_66C3C4;

//----- (0004297C) --------------------------------------------------------
int __fastcall sub_4297C(int a1, const char *a2, int a3)
{
  int *v5; // r0
  int result; // r0
  int v8; // r4
  struct tm *v9; // r0
  int v10; // r0
  FILE *v11; // r4
  size_t v12; // r0
  size_t v13; // r0
  int *v14; // r0
  int v15; // r7
  time_t timer; // [sp+1Ch] [bp-4Ch] BYREF
  __time_t v17; // [sp+20h] [bp-48h] BYREF
  int v18; // [sp+24h] [bp-44h]
  char s[64]; // [sp+28h] [bp-40h] BYREF

  if ( byte_6682BC )
  {
    syslog(a1 | 0x80, "%s", a2);
    v5 = (int *)dword_4D3904;
    if ( !dword_4D3904 )
    {
      v5 = sub_835A0("bmminer_droa");
      dword_4D3904 = (int)v5;
    }
    return sub_85464((int)v5, "logging.c", 9, (int)"_droa_log", 9, 72, 60, (int)"%s", a2);
  }
  else
  {
    v17 = 0;
    v18 = 0;
    sub_4465C(&v17);
    timer = v17;
    v8 = v18 / 1000;
    v9 = localtime(&timer);
    snprintf(
      s,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      v9->tm_year + 1900,
      v9->tm_mon + 1,
      v9->tm_mday,
      v9->tm_hour,
      v9->tm_min,
      v9->tm_sec,
      v8);
    v10 = fileno((FILE *)stderr);
    if ( !isatty(v10) )
    {
      fprintf((FILE *)stderr, "%s%s\n", s, a2);
      fflush((FILE *)stderr);
    }
    v11 = fopen("/tmp/miner/droa.log", modes);
    if ( v11 )
    {
      v12 = strlen(s);
      fwrite(s, v12, 1u, v11);
      v13 = strlen(a2);
      fwrite(a2, v13, 1u, v11);
      fwrite(&word_98278, 1u, 1u, v11);
      fflush(v11);
      fclose(v11);
    }
    v14 = (int *)dword_4D3904;
    if ( !dword_4D3904 )
    {
      v14 = sub_835A0("bmminer_droa");
      dword_4D3904 = (int)v14;
    }
    result = sub_85464((int)v14, "logging.c", 9, (int)"_droa_log", 9, 118, 60, (int)"%s", a2);
    if ( a1 == 3 )
      v15 = 0;
    else
      v15 = byte_666208 & 1;
    if ( !v15 )
      return sub_42904(s, a2, a3);
  }
  return result;
}
// 98278: using guessed type __int16 word_98278;
// BDA08: using guessed type int stderr;
// 4D3904: using guessed type int dword_4D3904;
// 666208: using guessed type char byte_666208;
// 6682BC: using guessed type char byte_6682BC;

//----- (00042C04) --------------------------------------------------------
void __fastcall sub_42C04(int a1, const char *a2, int a3)
{
  int v6; // r0
  int v7; // r0

  if ( byte_6682BC )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", a2);
      fflush((FILE *)stderr);
    }
    if ( a1 == 3 )
      v7 = 0;
    else
      v7 = byte_666208 & 1;
    if ( !v7 )
      sub_42904("", a2, a3);
  }
}
// BDA08: using guessed type int stderr;
// 666208: using guessed type char byte_666208;
// 6682BC: using guessed type char byte_6682BC;

//----- (00042CB4) --------------------------------------------------------
char *__fastcall sub_42CB4(int a1, const char *a2, int a3)
{
  size_t v6; // r5
  int *v7; // r0
  char *result; // r0
  char *v9; // r2
  int v10; // r3
  int v11; // t1
  bool v12; // zf
  int *v13; // r0
  int v14; // r0
  FILE *v15; // r5
  size_t v16; // r0
  int *v17; // r0
  int v18; // r7
  int v19; // r0
  FILE *v20; // r5
  size_t v21; // r0
  int *v22; // r0
  int v23; // r3

  v6 = strlen(&ptr);
  if ( v6 + strlen(a2) + 1 >= 0x800 )
  {
    if ( byte_6682BC )
    {
      syslog(a1 | 0x80, "%s", &ptr);
      v7 = (int *)dword_4D4108;
      if ( !dword_4D4108 )
      {
        v7 = sub_835A0("bmminer_miner");
        dword_4D4108 = (int)v7;
      }
      sub_85464((int)v7, "logging.c", 9, (int)"_applawlog", 10, 232, 60, (int)"%s", &ptr);
    }
    else
    {
      v19 = fileno((FILE *)stderr);
      if ( !isatty(v19) )
      {
        fputs(&ptr, (FILE *)stderr);
        fflush((FILE *)stderr);
      }
      if ( byte_4D37DC )
      {
        v20 = (FILE *)dword_4D37E0;
        if ( dword_4D37E0 || (v20 = fopen(byte_4D3804, modes), (dword_4D37E0 = (int)v20) != 0) )
        {
          v21 = strlen(&ptr);
          fwrite(&ptr, v21, 1u, v20);
          fflush((FILE *)dword_4D37E0);
        }
      }
      v22 = (int *)dword_4D4108;
      if ( !dword_4D4108 )
      {
        v22 = sub_835A0("bmminer_miner");
        dword_4D4108 = (int)v22;
      }
      sub_85464((int)v22, "logging.c", 9, (int)"_applawlog", 10, 260, 60, (int)"%s", &ptr);
      if ( a1 == 3 )
        v23 = 0;
      else
        v23 = byte_666208 & 1;
      if ( !v23 )
        sub_42904("", &ptr, a3);
    }
    ptr = 0;
  }
  result = strcat(&ptr, a2);
  v9 = &ptr;
  while ( 1 )
  {
    v11 = (unsigned __int8)*v9++;
    v10 = v11;
    v12 = v11 == 13;
    if ( v11 != 13 )
      v12 = v10 == 10;
    if ( v12 )
      break;
    if ( !v10 )
      return result;
  }
  if ( byte_6682BC )
  {
    syslog(a1 | 0x80, "%s", &ptr);
    v13 = (int *)dword_4D4108;
    if ( !dword_4D4108 )
    {
      v13 = sub_835A0("bmminer_miner");
      dword_4D4108 = (int)v13;
    }
    result = (char *)sub_85464((int)v13, "logging.c", 9, (int)"_applawlog", 10, 270, 60, (int)"%s", &ptr);
  }
  else
  {
    v14 = fileno((FILE *)stderr);
    if ( !isatty(v14) )
    {
      fputs(&ptr, (FILE *)stderr);
      fflush((FILE *)stderr);
    }
    if ( byte_4D37DC )
    {
      v15 = (FILE *)dword_4D37E0;
      if ( dword_4D37E0 || (v15 = fopen(byte_4D3804, modes), (dword_4D37E0 = (int)v15) != 0) )
      {
        v16 = strlen(&ptr);
        fwrite(&ptr, v16, 1u, v15);
        fflush((FILE *)dword_4D37E0);
      }
    }
    v17 = (int *)dword_4D4108;
    if ( !dword_4D4108 )
    {
      v17 = sub_835A0("bmminer_miner");
      dword_4D4108 = (int)v17;
    }
    result = (char *)sub_85464((int)v17, "logging.c", 9, (int)"_applawlog", 10, 298, 60, (int)"%s", &ptr);
    if ( a1 == 3 )
      v18 = 0;
    else
      v18 = byte_666208 & 1;
    if ( !v18 )
      result = (char *)sub_42904("", &ptr, a3);
  }
  ptr = 0;
  return result;
}
// BDA08: using guessed type int stderr;
// 4D37DC: using guessed type char byte_4D37DC;
// 4D37E0: using guessed type int dword_4D37E0;
// 4D4108: using guessed type int dword_4D4108;
// 666208: using guessed type char byte_666208;
// 6682BC: using guessed type char byte_6682BC;

//----- (00043088) --------------------------------------------------------
void sub_43088()
{
  int v0; // r5
  struct tm *v1; // r6
  time_t v2; // [sp+0h] [bp-2008h] BYREF
  pthread_t newthread; // [sp+4h] [bp-2004h] BYREF
  char v4[8192]; // [sp+8h] [bp-2000h] BYREF

  v0 = (unsigned __int8)byte_4D4136;
  if ( !byte_4D4136 )
  {
    time(&v2);
    v1 = localtime(&v2);
    strftime(&byte_4D4136, 0xFu, "%Y-%m/%d", v1);
    strftime(byte_4D4154, 0xAu, "%H-%M-%S", v1);
    dword_4D4110 = (int)"/var/log";
    dword_4D4114 = (int)"nvdata";
    dword_4D4168 = (int)"cglog_init";
    dword_4D410C = 1;
    sub_42320((int)&dword_4D410C);
    if ( pthread_create(&newthread, (const pthread_attr_t *)v0, (void *(*)(void *))sub_42500, &dword_4D410C) )
    {
      strcpy(v4, "Failed to create log thread");
      sub_41DB8(v0, v4, v0);
      _assert_fail("0", "logging.c", 0x21Eu, "log_init");
    }
    pthread_detach(newthread);
  }
}
// 4D410C: using guessed type int dword_4D410C;
// 4D4110: using guessed type int dword_4D4110;
// 4D4114: using guessed type int dword_4D4114;
// 4D4168: using guessed type int dword_4D4168;

//----- (000431B8) --------------------------------------------------------
int __fastcall sub_431B8(int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r0
  int *v4; // lr
  char *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r1
  int v9; // t1
  unsigned int v10; // lr
  char *v11; // r3
  unsigned int v12; // t1
  int *v13; // r0
  int **v14; // r3
  int *v15; // r2
  int *v16; // t1
  int v17; // r6
  int v18; // r3
  int v19; // r4
  int v20; // r10
  int v21; // r9
  int v22; // r5
  int v23; // r8
  int v24; // r7
  int v25; // r11
  int v26; // r2
  int v27; // r12
  int v28; // r3
  int v29; // lr
  int v30; // r1
  int **v31; // r1
  int *v32; // r3
  int *v33; // t1
  bool v34; // zf
  unsigned __int8 *v35; // [sp+4h] [bp-164h]
  int *v36; // [sp+8h] [bp-160h]
  unsigned __int8 *v37; // [sp+14h] [bp-154h]
  int *v38; // [sp+18h] [bp-150h]
  int *v39; // [sp+1Ch] [bp-14Ch] BYREF
  int v40; // [sp+20h] [bp-148h]
  int v41; // [sp+24h] [bp-144h]
  int v42; // [sp+28h] [bp-140h]
  int v43; // [sp+2Ch] [bp-13Ch]
  int v44; // [sp+30h] [bp-138h]
  int v45; // [sp+34h] [bp-134h]
  int v46; // [sp+38h] [bp-130h]
  int v47; // [sp+3Ch] [bp-12Ch] BYREF
  _DWORD v48[15]; // [sp+40h] [bp-128h] BYREF
  char v49; // [sp+7Ch] [bp-ECh] BYREF
  char v50; // [sp+100h] [bp-68h] BYREF

  if ( a3 > 0 )
  {
    v38 = (int *)(result + 136);
    v35 = a2;
    v37 = &a2[64 * a3];
    v39 = (int *)(result + 168);
    do
    {
      v3 = v35;
      v4 = &v47;
      v5 = (char *)v48;
      do
      {
        v6 = v3[1];
        v7 = v3[2];
        v8 = v3[3];
        v9 = *v3;
        v3 += 4;
        v4[1] = (v6 << 16) | (v7 << 8) | v8 | (v9 << 24);
        ++v4;
      }
      while ( &v49 != (char *)v4 );
      do
      {
        v10 = *((_DWORD *)v5 + 14);
        v11 = v5;
        v12 = *((_DWORD *)v5 + 1);
        v5 += 4;
        *((_DWORD *)v5 + 15) = (__ROR4__(v10, 19) ^ __ROR4__(v10, 17) ^ (v10 >> 10))
                             + *((_DWORD *)v11 + 9)
                             + *(_DWORD *)v11
                             + (__ROR4__(v12, 18) ^ __ROR4__(v12, 7) ^ (v12 >> 3));
      }
      while ( &v50 != v5 );
      v13 = v39;
      v14 = &v39;
      v15 = v38;
      do
      {
        v16 = (int *)*v15++;
        v14[1] = v16;
        ++v14;
      }
      while ( v13 != v15 );
      v36 = v15;
      v17 = 0;
      v18 = v47;
      v19 = v44;
      v20 = v45;
      v21 = v46;
      v22 = v40;
      v23 = v41;
      v24 = v42;
      v25 = v43;
      while ( 1 )
      {
        v26 = (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v19, 25)) + (v21 & ~v19 ^ v20 & v19) + v48[v17];
        v27 = dword_BC5F8[v17++];
        v28 = v26 + v27 + v18;
        v29 = v25 + v28;
        v30 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v24 ^ v23) & v22 ^ v24 & v23) + v28;
        v25 = v24;
        v18 = v21;
        if ( v17 == 64 )
          break;
        v24 = v23;
        v21 = v20;
        v23 = v22;
        v20 = v19;
        v22 = v30;
        v19 = v29;
      }
      v40 = v30;
      v31 = &v39;
      v32 = v38;
      v47 = v21;
      v44 = v29;
      v45 = v19;
      v46 = v20;
      v41 = v22;
      v42 = v23;
      v43 = v24;
      do
      {
        result = *v32;
        v33 = v31[1];
        ++v31;
        *v32++ += (int)v33;
      }
      while ( v36 != v32 );
      v34 = v37 == v35 + 64;
      v35 += 64;
    }
    while ( !v34 );
  }
  return result;
}
// BC5F8: using guessed type _DWORD dword_BC5F8[63];

//----- (000433B4) --------------------------------------------------------
_DWORD *__fastcall sub_433B4(_DWORD *result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r3
  int v3; // t1

  v1 = &unk_BC6F4;
  v2 = result + 34;
  do
  {
    v3 = v1[1];
    ++v1;
    *v2++ = v3;
  }
  while ( v2 != result + 42 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (000433E4) --------------------------------------------------------
void *__fastcall sub_433E4(unsigned __int8 *a1, char *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r2
  unsigned __int8 *v8; // r0
  size_t v9; // r6
  void *result; // r0
  unsigned int v11; // r3
  size_t v12; // r5
  unsigned __int8 *v13; // r6
  int v14; // r3

  v4 = *((_DWORD *)a1 + 1);
  v7 = 64 - v4;
  v8 = &a1[v4 + 8];
  if ( v7 >= n )
    v9 = n;
  else
    v9 = v7;
  result = memcpy(v8, a2, v9);
  v11 = n + *((_DWORD *)a1 + 1);
  if ( v11 > 0x3F )
  {
    v12 = n - v9;
    v13 = (unsigned __int8 *)&a2[v9];
    sub_431B8((int)a1, a1 + 8, 1);
    sub_431B8((int)a1, v13, v12 >> 6);
    result = memcpy(a1 + 8, &v13[v12 & 0xFFFFFFC0], v12 & 0x3F);
    v14 = *(_DWORD *)a1;
    *((_DWORD *)a1 + 1) = v12 & 0x3F;
    *(_DWORD *)a1 = v14 + (((v12 >> 6) + 1) << 6);
  }
  else
  {
    *((_DWORD *)a1 + 1) = v11;
  }
  return result;
}

//----- (00043490) --------------------------------------------------------
int __fastcall sub_43490(_DWORD *a1, _BYTE *a2)
{
  int v2; // r8
  int v3; // r9
  int v4; // r10
  int v5; // r11
  int v6; // r3
  unsigned __int8 *v9; // r6
  bool v10; // cf
  int v11; // r2
  int v12; // r7
  size_t v13; // r2
  unsigned __int8 *v14; // r0
  int v15; // r3
  int v16; // r7
  int result; // r0
  int *v18; // r3
  int *v19; // r5
  int v20; // t1
  int v21; // [sp+4h] [bp-8h]

  v6 = a1[1];
  v9 = (unsigned __int8 *)(a1 + 2);
  v10 = (v6 & 0x3Fu) >= 0x38;
  if ( (v6 & 0x3Fu) >= 0x38 )
    v11 = 128;
  else
    v11 = 64;
  v12 = v6 + *a1;
  v13 = v11 - v6;
  v14 = &v9[v6];
  if ( (v6 & 0x3Fu) >= 0x38 )
    v15 = 124;
  else
    v15 = 60;
  v16 = 8 * v12;
  if ( !v10 )
    v2 = 61;
  v21 = v15;
  if ( v10 )
    v2 = 125;
  else
    v3 = 62;
  if ( v10 )
    v3 = 126;
  else
    v4 = 63;
  if ( v10 )
    v4 = 127;
  else
    v5 = 1;
  if ( v10 )
    v5 = 2;
  memset(v14, 0, v13);
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  v9[v4] = v16;
  v9[v3] = BYTE1(v16);
  v9[v2] = BYTE2(v16);
  v9[v21] = HIBYTE(v16);
  result = sub_431B8((int)a1, v9, v5);
  v18 = a1 + 34;
  v19 = a1 + 42;
  do
  {
    a2[3] = *v18;
    v20 = *v18++;
    a2[2] = BYTE1(v20);
    a2[1] = *((_WORD *)v18 - 1);
    *a2 = *((_BYTE *)v18 - 1);
    a2 += 4;
  }
  while ( v19 != v18 );
  return result;
}
// 43524: variable 'v4' is possibly undefined
// 4352C: variable 'v3' is possibly undefined
// 43530: variable 'v2' is possibly undefined
// 4353C: variable 'v5' is possibly undefined

//----- (0004357C) --------------------------------------------------------
int __fastcall sub_4357C(char *a1, size_t n, _BYTE *a3)
{
  _DWORD *v3; // r3
  char *v5; // r2
  int v6; // t1
  _DWORD v8[34]; // [sp+0h] [bp-ACh] BYREF
  char v9; // [sp+88h] [bp-24h] BYREF

  v3 = &unk_BC6F4;
  v5 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *(_DWORD *)v5 = v6;
    v5 += 4;
  }
  while ( v3 != (_DWORD *)&unk_BC714 );
  v8[0] = 0;
  v8[1] = 0;
  sub_433E4((unsigned __int8 *)v8, a1, n);
  return sub_43490(v8, a3);
}

//----- (000435E0) --------------------------------------------------------
int sub_435E0()
{
  return 0;
}

//----- (000435E8) --------------------------------------------------------
int __fastcall sub_435E8(const void *a1, const char *a2, const char *a3, int a4)
{
  int *v8; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v8 = _errno_location();
  snprintf(s, 0x2000u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v8, a1, a2, a3, a4);
  sub_41DB8(3, s, 1);
  return nullsub_1(1);
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00043650) --------------------------------------------------------
int __fastcall sub_43650(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x2000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_41DB8(3, s, 1);
    return nullsub_1(1);
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (000436CC) --------------------------------------------------------
int __fastcall sub_436CC(const char *a1, int a2)
{
  int *v4; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x2000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  sub_41DB8(3, s, 1);
  return nullsub_1(1);
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00043730) --------------------------------------------------------
int __fastcall sub_43730(int a1, char a2)
{
  pthread_mutex_t *v2; // r5

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_436CC("tq_freezethaw", 1108);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_43650(v2, "tq_freezethaw", 1111);
  return off_BC718();
}
// BC718: using guessed type int (*off_BC718)();

//----- (00043798) --------------------------------------------------------
void *__fastcall sub_43798(size_t a1, const char *a2, const char *a3, int a4)
{
  size_t v4; // r4
  void *result; // r0
  char s[8192]; // [sp+10h] [bp-2000h] BYREF

  v4 = a1;
  if ( (a1 & 3) != 0 )
    v4 = (a1 & 0xFFFFFFFC) + 4;
  result = malloc(v4);
  if ( !result )
  {
    snprintf(s, 0x2000u, "Failed to malloc size %d from %s %s:%d", v4, a2, a3, a4);
    sub_41DB8(3, s, 1);
    nullsub_1(1);
    return 0;
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (0004382C) --------------------------------------------------------
void *__fastcall sub_4382C(size_t a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[8176]; // [sp+10h] [bp-2000h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = calloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x2000u, "Failed to calloc memb %d size %d from %s %s:%d", a1, v5, a3, a4, a5);
    sub_41DB8(3, s, 1);
    nullsub_1(1);
    return 0;
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (000438D0) --------------------------------------------------------
void *__fastcall sub_438D0(void *a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[8176]; // [sp+10h] [bp-2004h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = realloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x2000u, "Failed to realloc size %d from %s %s:%d", v5, a3, a4, a5);
    sub_41DB8(3, s, 1);
    nullsub_1(1);
    return 0;
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00043A28) --------------------------------------------------------
_BYTE *__fastcall sub_43A28(int a1, int a2)
{
  int v2; // r5
  int v4; // r0
  int v6; // r12
  _BYTE *result; // r0
  _BYTE *v8; // r5
  _BYTE *v9; // r2
  char *v10; // r12
  unsigned int v11; // t1

  v2 = 2 * a2;
  v4 = 2 * a2 + 1;
  v6 = v4 & 3;
  if ( v4 <= 0 )
    v6 = -(-v4 & 3);
  result = sub_4382C(4 - v6 + v4, 1u, "util.c", "bin2hex", 789);
  if ( a2 > 0 )
  {
    v9 = (_BYTE *)(a1 - 1);
    v10 = result + 2;
    do
    {
      v11 = (unsigned __int8)*++v9;
      v10 += 2;
      *(v10 - 4) = aTqFreezethaw[(v11 >> 4) + 72];
      *(v10 - 3) = aTqFreezethaw[(*v9 & 0xF) + 72];
    }
    while ( v9 != (_BYTE *)(a1 - 1 + a2) );
    v8 = &result[v2];
  }
  else
  {
    v8 = result;
  }
  *v8 = 0;
  return result;
}

//----- (00043ADC) --------------------------------------------------------
int __fastcall sub_43ADC(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4; // r3
  unsigned int v5; // lr
  int result; // r0
  unsigned __int8 *v7; // r1
  int v8; // r3
  bool v9; // zf
  char *v10; // r3
  int v11; // r12
  char *v12; // r12
  char v13[8208]; // [sp-2010h] [bp-2010h] BYREF

  if ( !*a2 )
    return !a3;
  if ( !a3 )
    return 0;
  if ( !a2[1] )
  {
LABEL_16:
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
    {
      strcpy(v13, "hex2bin str truncated");
      sub_41DB8(3, v13, 0);
    }
    return 0;
  }
  v4 = *(_DWORD *)&aTqFreezethaw[4 * a2[1] + 96];
  v5 = *(_DWORD *)&aTqFreezethaw[4 * *a2 + 96];
  result = (v4 >> 31) | (v5 >> 31);
  if ( !result )
  {
    v7 = a2 + 4;
    while ( 1 )
    {
      --a3;
      *a1++ = v4 | (16 * v5);
      v8 = *(v7 - 2);
      v9 = v8 == 0;
      v10 = &aTqFreezethaw[4 * v8];
      if ( v9 )
        break;
      if ( !a3 )
        return result;
      v11 = *(v7 - 1);
      v7 += 2;
      v9 = v11 == 0;
      v12 = &aTqFreezethaw[4 * v11];
      if ( v9 )
        goto LABEL_16;
      v5 = *((_DWORD *)v10 + 24);
      v4 = *((_DWORD *)v12 + 24);
      if ( ((v5 | v4) & 0x80000000) != 0 )
        goto LABEL_11;
    }
    return !a3;
  }
LABEL_11:
  if ( !byte_6682BC && !byte_4D4171 && dword_BC5F4 <= 2 )
    return 0;
  strcpy(v13, "hex2bin scan failed");
  sub_41DB8(3, v13, 0);
  return 0;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (00043CA0) --------------------------------------------------------
size_t __fastcall sub_43CA0(_BYTE *a1, char *s)
{
  size_t result; // r0
  char v5; // r1
  char *v6; // r7
  unsigned int v7; // r12
  char *v8; // r6
  int v9; // t1
  unsigned int *v10; // r2
  unsigned int v11; // r3
  size_t *v12; // r3
  unsigned int *v13; // r2
  size_t *v14; // r5
  unsigned int v15; // t1
  int v16; // [sp+0h] [bp-20h] BYREF
  int v17; // [sp+4h] [bp-1Ch]
  unsigned int v18[5]; // [sp+8h] [bp-18h] BYREF
  unsigned int v19; // [sp+1Ch] [bp-4h] BYREF

  memset(v18, 0, sizeof(v18));
  v17 = 0;
  v19 = 0;
  result = strlen(s);
  if ( result )
  {
    v6 = s - 1;
    v7 = 0;
    v8 = &v6[result];
    while ( 1 )
    {
      v9 = (unsigned __int8)*++v6;
      v10 = &v19;
      v11 = *(_DWORD *)&aTqFreezethaw[4 * v9 + 1120];
      while ( 1 )
      {
        *v10-- = 58 * v7 + v11;
        v11 = (58LL * v7 + (unsigned __int64)v11) >> 32;
        if ( &v16 == (int *)v10 )
          break;
        v7 = *v10;
      }
      if ( v8 == v6 )
        break;
      v7 = v19;
    }
    v5 = v17;
    result = bswap32(v18[0]);
  }
  else
  {
    v5 = 0;
  }
  v12 = (size_t *)(a1 + 1);
  v13 = v18;
  *a1 = v5;
  v14 = (size_t *)(a1 + 25);
  while ( 1 )
  {
    *v12++ = result;
    if ( v12 == v14 )
      break;
    v15 = v13[1];
    ++v13;
    result = bswap32(v15);
  }
  return result;
}

//----- (00043D78) --------------------------------------------------------
int __fastcall sub_43D78(int a1, int a2)
{
  char v3; // r2
  int result; // r0
  int v5; // r2

  if ( a2 > 127 )
  {
    v5 = (unsigned __int16)&unk_20407F;
    if ( a2 > v5 )
    {
      HIWORD(v5) = (unsigned int)&unk_20407F >> 16;
      if ( a2 <= v5 )
        result = 4;
      else
        result = 5;
      if ( a2 <= v5 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (00043FB8) --------------------------------------------------------
char *sub_43FB8()
{
  char *v0; // r4

  v0 = (char *)sub_4382C(1u, 0x58u, "util.c", "tq_new", 1077);
  *(_DWORD *)v0 = v0;
  *((_DWORD *)v0 + 1) = v0;
  pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v0 + 40), 0);
  return v0;
}

//----- (00044014) --------------------------------------------------------
void __fastcall sub_44014(char *a1)
{
  int v2; // r2
  _DWORD *v3; // r0
  _DWORD *v4; // r4
  _DWORD *v5; // r3
  bool v6; // zf

  if ( a1 )
  {
    v2 = **(_DWORD **)a1;
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = (_DWORD *)(v2 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v5 = (_DWORD *)v3[2];
        *(_DWORD *)(v2 + 4) = v5;
        *v5 = v2;
        free(v3);
        v3 = v4;
        v2 = v4[1];
        v6 = v4 + 1 == (_DWORD *)a1;
        v4 = (_DWORD *)(v2 - 4);
      }
      while ( !v6 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    free(a1);
  }
}

//----- (0004407C) --------------------------------------------------------
int __fastcall sub_4407C(int a1)
{
  return sub_43730(a1, 1);
}

//----- (00044084) --------------------------------------------------------
int __fastcall sub_44084(int a1)
{
  return sub_43730(a1, 0);
}

//----- (0004408C) --------------------------------------------------------
int __fastcall sub_4408C(int a1, int a2)
{
  _DWORD *v4; // r6
  _DWORD *v5; // r4
  _DWORD *v6; // r3
  int v7; // r8

  v4 = sub_4382C(1u, 0xCu, "util.c", "tq_push", 1129);
  *v4 = a2;
  v5 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_436CC("tq_push", 1133);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v7 = 0;
    free(v4);
  }
  else
  {
    v6 = *(_DWORD **)(a1 + 4);
    v7 = 1;
    *(_DWORD *)(a1 + 4) = v5;
    v4[1] = a1;
    v4[2] = v6;
    *v6 = v5;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_43650((pthread_mutex_t *)(a1 + 12), "tq_push", 1146);
  off_BC718();
  return v7;
}
// BC718: using guessed type int (*off_BC718)();

//----- (00044160) --------------------------------------------------------
int __fastcall sub_44160(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r6
  int *v5; // r4
  _DWORD *v6; // r2
  int v7; // r1
  int v8; // r5
  pthread_cond_t *v10; // r0
  int v11; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_436CC("tq_pop", 1158);
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v10 = (pthread_cond_t *)(a1 + 40);
    if ( a2 )
      v11 = pthread_cond_timedwait(v10, v2, a2);
    else
      v11 = pthread_cond_wait(v10, v2);
    if ( v11 )
    {
      v8 = 0;
      goto LABEL_5;
    }
    if ( v5 == *(int **)a1 )
    {
      v8 = 0;
      goto LABEL_5;
    }
    v5 = *(int **)a1;
  }
  v6 = (_DWORD *)v5[1];
  v7 = *v5;
  v8 = *(v5 - 1);
  *(_DWORD *)(v7 + 4) = v6;
  *v6 = v7;
  *v5 = 0;
  v5[1] = 0;
  free(v5 - 1);
LABEL_5:
  sub_43650(v2, "tq_pop", 1184);
  off_BC718();
  return v8;
}
// BC718: using guessed type int (*off_BC718)();

//----- (00044240) --------------------------------------------------------
int __fastcall sub_44240(int result)
{
  int v1; // r4
  pthread_t v2; // r0
  sem_t *v3; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      v3 = (sem_t *)(v1 + 16);
      *(_DWORD *)(v1 + 12) = 0;
    }
    else
    {
      v3 = (sem_t *)(v1 + 16);
    }
    return sem_destroy(v3);
  }
  return result;
}

//----- (0004427C) --------------------------------------------------------
_DWORD *__fastcall sub_4427C(_DWORD *result, int *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result - *a2;
  *a2 = v3;
  v4 = result[1] - v2;
  a2[1] = v4;
  if ( v4 < 0 )
  {
    LODWORD(v5) = v3 - 1;
    HIDWORD(v5) = v4 + 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (000442B0) --------------------------------------------------------
_DWORD *__fastcall sub_442B0(_DWORD *result, int *a2)
{
  int v2; // lr
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result + *a2;
  *a2 = v3;
  v4 = result[1] + v2;
  a2[1] = v4;
  if ( v4 > (int)&unk_F423F )
  {
    LODWORD(v5) = v3 + 1;
    HIDWORD(v5) = v4 - 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (000442F4) --------------------------------------------------------
bool __fastcall sub_442F4(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (00044328) --------------------------------------------------------
bool __fastcall sub_44328(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (0004435C) --------------------------------------------------------
_DWORD *__fastcall sub_4435C(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1] / 1000;
  return result;
}

//----- (0004438C) --------------------------------------------------------
_DWORD *__fastcall sub_4438C(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = 1000 * a2[1];
  return result;
}

//----- (000443A8) --------------------------------------------------------
int __fastcall sub_443A8(_QWORD *a1)
{
  int result; // r0
  _DWORD v3[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v3);
  *a1 = __PAIR64__(v3[2], v3[0]);
  return result;
}
// 128A8: using guessed type int __fastcall lldiv(_DWORD);

//----- (000443E0) --------------------------------------------------------
int __fastcall sub_443E0(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 128A8: using guessed type int __fastcall lldiv(_DWORD);

//----- (00044420) --------------------------------------------------------
int __fastcall sub_44420(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = (_DWORD)&unk_F4240 * v4[2];
  *a1 = v3;
  return result;
}
// 128A8: using guessed type int __fastcall lldiv(_DWORD);

//----- (00044460) --------------------------------------------------------
int __fastcall sub_44460(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 128A8: using guessed type int __fastcall lldiv(_DWORD);

//----- (0004449C) --------------------------------------------------------
_DWORD *__fastcall sub_4449C(_DWORD *result, _DWORD *a2)
{
  int v2; // r3
  __int64 v3; // r2
  int v4; // lr
  int v5; // r1

  v2 = result[1];
  LODWORD(v3) = *result + *a2;
  *result = v3;
  HIDWORD(v3) = v2 + a2[1];
  result[1] = HIDWORD(v3);
  if ( SHIDWORD(v3) <= 999999999 )
  {
    if ( v3 < 0 )
    {
      do
      {
        HIDWORD(v3) += 1000000000;
        LODWORD(v3) = v3 - 1;
      }
      while ( v3 < 0 );
      *(_QWORD *)result = v3;
    }
  }
  else
  {
    v4 = v3 + 1;
    v5 = HIDWORD(v3) - 1000000000;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
    {
      v5 = -2000000000;
      v4 = v3 + 2;
    }
    *result = v4;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
      v5 += HIDWORD(v3);
    result[1] = v5;
  }
  return result;
}

//----- (00044614) --------------------------------------------------------
const char *__fastcall sub_44614(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    *a1 = 0;
    return v3;
  }
}

//----- (0004465C) --------------------------------------------------------
__int64 __fastcall sub_4465C(__time_t *a1)
{
  int tv_nsec; // kr00_4
  __int64 result; // r0
  struct timespec v4; // [sp+0h] [bp-8h] BYREF

  clock_gettime(1, &v4);
  tv_nsec = v4.tv_nsec;
  result = 274877907LL * v4.tv_nsec;
  *a1 = v4.tv_sec;
  a1[1] = tv_nsec / 1000;
  return result;
}

//----- (000446A0) --------------------------------------------------------
int __fastcall sub_446A0(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (000446D0) --------------------------------------------------------
int __fastcall sub_446D0(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // r3
  int v4; // r1
  int result; // r0

  v3 = *a1 - *a2;
  *a3 = v3;
  v4 = a2[1];
  result = a1[1] - v4;
  if ( result >= 0 )
  {
    a3[1] = result;
  }
  else
  {
    v4 = 1000000000;
    --v3;
  }
  if ( result < 0 )
  {
    *a3 = v3;
    a3[1] = result + v4;
  }
  return result;
}

//----- (0004470C) --------------------------------------------------------
int __fastcall sub_4470C(struct timespec *a1)
{
  return clock_gettime(1, a1);
}

//----- (00044718) --------------------------------------------------------
int __fastcall sub_44718(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8; // [sp+0h] [bp-8h] BYREF

  sub_44420(&v8);
  v2 = *a1;
  v8.tv_nsec += a1[1];
  tv_nsec = v8.tv_nsec;
  v4 = v8.tv_sec + v2;
  v8.tv_sec += v2;
  if ( v8.tv_nsec <= 999999999 )
  {
    if ( v8.tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8.tv_sec = v4;
      v8.tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8.tv_nsec - 1000000000;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8.tv_sec = v5;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
      v6 += v8.tv_nsec;
    v8.tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, &v8, 0);
  while ( result == 4 );
  return result;
}

//----- (000447D8) --------------------------------------------------------
int __fastcall sub_447D8(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8; // [sp+0h] [bp-8h] BYREF

  sub_443E0(&v8);
  v2 = *a1;
  v8.tv_nsec += a1[1];
  tv_nsec = v8.tv_nsec;
  v4 = v8.tv_sec + v2;
  v8.tv_sec += v2;
  if ( v8.tv_nsec <= 999999999 )
  {
    if ( v8.tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8.tv_sec = v4;
      v8.tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8.tv_nsec - 1000000000;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8.tv_sec = v5;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
      v6 += v8.tv_nsec;
    v8.tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, &v8, 0);
  while ( result == 4 );
  return result;
}

//----- (00044890) --------------------------------------------------------
int sub_44890()
{
  struct timespec v1; // [sp+0h] [bp-8h] BYREF

  clock_gettime(1, &v1);
  return sub_44718(&v1.tv_sec);
}

//----- (000448BC) --------------------------------------------------------
int sub_448BC()
{
  struct timespec v1; // [sp+0h] [bp-Ch] BYREF

  clock_gettime(1, &v1);
  return sub_447D8(&v1.tv_sec);
}

//----- (000448F0) --------------------------------------------------------
_DWORD *__fastcall sub_448F0(_DWORD *result, _DWORD *a2)
{
  if ( *result - *a2 <= 60 )
    return &unk_F4240;
  return result;
}

//----- (00044930) --------------------------------------------------------
void *__fastcall sub_44930(_DWORD *a1, _DWORD *a2)
{
  int v2; // r2

  v2 = *a1 - *a2;
  if ( v2 > 3600 )
    return &unk_36EE80;
  else
    return (void *)((a1[1] - a2[1]) / 1000 + 1000 * v2);
}

//----- (00044984) --------------------------------------------------------
void sub_44984()
{
  ;
}

//----- (000449C8) --------------------------------------------------------
int __fastcall sub_449C8(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r6
  char *v8; // r0
  char v9; // r5
  int v10; // r5
  char *v11; // r6
  size_t v12; // r0
  int v13; // r3
  int v14; // r7
  char *v16; // r0
  char v17[8]; // [sp+8h] [bp-10Ch] BYREF
  char s[260]; // [sp+10h] [bp-104h] BYREF

  v4 = a1;
  *a2 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = (char)v8;
  if ( v8 )
    v9 = 1;
  if ( !v7 )
    v9 = 0;
  if ( v7 < v8 )
    v10 = v9 & 1;
  else
    v10 = 0;
  if ( !v10 )
    v8 = (char *)v4;
  v11 = strchr(v8, 58);
  v12 = strlen(v4);
  if ( v11 )
  {
    v13 = v11 - v4;
    v14 = ~(v11 - v4) + v12;
    if ( v14 <= 0 )
      return 0;
    ++v11;
  }
  else
  {
    v13 = v12;
    v14 = 0;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v10 )
  {
    ++v4;
    v13 -= 2;
  }
  snprintf(s, 0xFEu, "%.*s", v13, v4);
  if ( v14 )
  {
    snprintf(v17, 6u, "%.*s", v14, v11);
    v16 = strpbrk(v17, "/#");
    if ( v16 )
      *v16 = 0;
  }
  else
  {
    strcpy(v17, "80");
  }
  *a3 = _strdup(v17);
  *a2 = _strdup(s);
  return 1;
}

//----- (00044B3C) --------------------------------------------------------
char *__fastcall sub_44B3C(char *s1, int a2)
{
  const char *v2; // r4
  int v4; // r5
  size_t v5; // r6
  char *v7; // r0
  char *v8; // r8
  char *v9; // r0
  const char *v10; // r1

  v2 = "http:";
  v4 = 0;
  v5 = 5;
  *(_DWORD *)(a2 + 184) = 0;
  while ( strncmp(s1, v2, v5) )
  {
    ++v4;
    v2 = (&off_9FCEC)[2 * v4];
    if ( !v2 )
      return s1;
    v5 = strlen((&off_9FCEC)[2 * v4]);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)sub_43798(1 - v5 + v7 - s1, "util.c", "get_proxy", 750);
    v10 = &s1[v5];
    *(_DWORD *)(a2 + 184) = v9;
    s1 = v8 + 1;
    strcpy(v9, v10);
    sub_449C8(*(const char **)(a2 + 184), (_DWORD *)(a2 + 620), (char **)(a2 + 624));
    *(_DWORD *)(a2 + 180) = *(_DWORD *)&aTqFreezethaw[8 * v4 + 20];
  }
  return s1;
}
// 9FCEC: using guessed type char *off_9FCEC;

//----- (00044C18) --------------------------------------------------------
char *__fastcall sub_44C18(char *a1, char *s)
{
  size_t v4; // r0
  const char *v5; // r1
  char *v6; // r4
  size_t v7; // r4
  size_t v8; // r0
  char *v10; // r4

  v4 = strlen(s);
  if ( !v4 )
    return a1;
  v7 = v4 + 1;
  if ( a1 )
  {
    v8 = strlen(a1) + v7;
    if ( (v8 & 3) != 0 )
      v8 = (v8 & 0xFFFFFFFC) + 4;
    v6 = (char *)sub_43798(v8, "util.c", "realloc_strcat", 3382);
    sprintf(v6, "%s%s", a1, s);
    free(a1);
    return v6;
  }
  if ( (v7 & 3) != 0 )
    v4 = v7 & 0xFFFFFFFC;
  else
    LOWORD(v5) = 3068;
  if ( (v7 & 3) != 0 )
    LOWORD(v5) = 3068;
  else
    v4 = v7;
  if ( (v7 & 3) != 0 )
    v4 += 4;
  HIWORD(v5) = 10;
  v10 = (char *)sub_43798(v4, v5, "realloc_strcat", 3382);
  strcpy(v10, s);
  return v10;
}
// 44CC4: variable 'v5' is possibly undefined

//----- (00044CEC) --------------------------------------------------------
char *__fastcall sub_44CEC(const char *a1)
{
  size_t v2; // r0
  char *v3; // r5
  char *v4; // r7
  char *v5; // r4
  char v6; // r3
  char v7; // r2
  int v8; // t1
  char *v10; // r2
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( !a1 )
  {
    v10 = (char *)malloc(7u);
    if ( v10 )
    {
      strcpy(v10, "(null)");
    }
    else
    {
      snprintf(s, 0x2000u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3407);
      sub_41DB8(3, s, 1);
      nullsub_1(1);
    }
  }
  v2 = strlen(a1);
  v3 = (char *)(a1 - 1);
  v4 = (char *)sub_43798(4 * v2 + 5, "util.c", "str_text", 3412);
  v5 = v4;
  do
  {
    while ( 1 )
    {
      v8 = (unsigned __int8)*++v3;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) <= 0x5E )
        break;
      sprintf(v5, "0x%02x");
      v6 = *v3;
      v5 += 4;
      if ( !*v3 )
        goto LABEL_7;
    }
    *v5++ = v7;
    v6 = *v3;
  }
  while ( *v3 );
LABEL_7:
  *v5 = v6;
  return v4;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00044E0C) --------------------------------------------------------
int __fastcall sub_44E0C(const char *a1)
{
  char s[20]; // [sp+8h] [bp-14h] BYREF

  snprintf(s, 0x10u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (00044E4C) --------------------------------------------------------
int __fastcall sub_44E4C(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  result = sem_init(a1, 0, 0);
  v8 = result;
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x2000u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    sub_41DB8(3, s, 1);
    return nullsub_1(1);
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00044EC8) --------------------------------------------------------
int __fastcall sub_44EC8(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  sub_44E4C((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1191);
  return pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (00044F10) --------------------------------------------------------
int __fastcall sub_44F10(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0

  result = sem_post(a1);
  if ( result )
    return sub_435E8(a1, a2, a3, a4);
  return result;
}

//----- (00044F48) --------------------------------------------------------
int __fastcall sub_44F48(int a1)
{
  pthread_setcanceltype(1, 0);
  (*(void (__fastcall **)(_DWORD))(a1 + 16))(*(_DWORD *)(a1 + 20));
  sub_44F10((sem_t *)a1, "util.c", "completion_thread", 3638);
  return 0;
}

//----- (0004500C) --------------------------------------------------------
int __fastcall sub_4500C(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  __time_t tv_sec; // r10
  int v8; // r5
  int v9; // r3
  __time_t v10; // r2
  bool v11; // cc
  int v12; // r1
  __time_t v13; // r0
  int result; // r0
  struct timespec abstime; // [sp+18h] [bp-200Ch] BYREF
  struct timespec tp; // [sp+20h] [bp-2004h] BYREF

  clock_gettime(1, &tp);
  tv_sec = tp.tv_sec;
  v8 = 1000 * (tp.tv_nsec / 1000);
  sub_44420(&abstime);
  while ( 1 )
  {
    v9 = v8 + abstime.tv_nsec;
    v10 = tv_sec + abstime.tv_sec;
    v11 = v8 + abstime.tv_nsec <= 999999999;
    abstime.tv_sec += tv_sec;
    abstime.tv_nsec += v8;
    if ( v11 )
    {
      if ( v9 < 0 )
      {
        do
        {
          v9 += 1000000000;
          --v10;
        }
        while ( v9 < 0 );
        abstime.tv_sec = v10;
        abstime.tv_nsec = v9;
      }
    }
    else
    {
      v12 = v9 - 1000000000;
      v13 = v10 + 1;
      if ( v9 - 1000000000 > 999999999 )
      {
        v12 = v9 - 2000000000;
        v13 = v10 + 2;
      }
      abstime.tv_sec = v13;
      abstime.tv_nsec = v12;
    }
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    result = *_errno_location();
    if ( result == 110 )
      break;
    if ( result != 4 )
    {
      snprintf(
        (char *)&tp,
        0x2000u,
        "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d",
        result,
        a1,
        a3,
        a4,
        a5);
      sub_41DB8(3, (const char *)&tp, 1);
      nullsub_1(1);
      return 0;
    }
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);

//----- (00045164) --------------------------------------------------------
int *__fastcall sub_45164(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (0004519C) --------------------------------------------------------
bool __fastcall sub_4519C(int a1, int a2, int a3)
{
  sem_t *v6; // r4
  int v7; // r5
  pthread_t newthread[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = (sem_t *)sub_43798(0x18u, "util.c", "cg_completion_timeout", 3649);
  sub_44E4C(v6, "util.c", "cg_completion_timeout", 3650);
  v6[1].__align = a1;
  *(&v6[1].__align + 1) = a2;
  pthread_create(newthread, 0, (void *(*)(void *))sub_44F48, v6);
  v7 = sub_4500C(v6, a3, "util.c", "cg_completion_timeout", 3656);
  if ( v7 )
  {
    pthread_cancel(newthread[0]);
    return v7 == 0;
  }
  else
  {
    pthread_join(newthread[0], 0);
    free(v6);
    return 1;
  }
}

//----- (00045268) --------------------------------------------------------
void *__fastcall sub_45268(void *result, const void *a2, size_t a3, int a4, int a5, int a6)
{
  char s[8176]; // [sp+10h] [bp-2000h] BYREF

  if ( (int)(a3 - 1) < 0 )
  {
    if ( !byte_6682BC && !byte_4D4171 && dword_BC5F4 <= 2 )
      return result;
    snprintf(s, 0x2000u, "ERR: Asked to memcpy %u bytes from %s %s():%d", a3, a4, a5, a6);
    return (void *)sub_41DB8(3, s, 0);
  }
  if ( !result )
  {
    if ( !byte_6682BC && !byte_4D4171 && dword_BC5F4 <= 2 )
      return result;
    snprintf(s, 0x2000u, "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d", a3, a4, a5, a6);
    return (void *)sub_41DB8(3, s, 0);
  }
  if ( a2 )
    return memcpy(result, a2, a3);
  if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 2 )
  {
    snprintf(s, 0x2000u, "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d", a3, a4, a5, a6);
    return (void *)sub_41DB8(3, s, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (00045594) --------------------------------------------------------
void *__fastcall sub_45594(void *a1, const void *a2)
{
  return sub_45268(a1, a2, 8u, (int)"util.c", (int)"copy_time", 1236);
}

//----- (00045644) --------------------------------------------------------
_BYTE *__fastcall sub_45644(_BYTE *result, int a2)
{
  _BYTE *v2; // r12
  unsigned int v3; // r3
  char v4; // lr
  char v5; // t1
  char v6; // t1

  if ( a2 != 1 )
  {
    v2 = result - 1;
    v3 = 0;
    result += a2;
    do
    {
      ++v3;
      v5 = *++v2;
      v4 = v5;
      v6 = *--result;
      *v2 = v6;
      *result = v4;
    }
    while ( v3 < ~v3 + a2 );
  }
  return result;
}

//----- (0004596C) --------------------------------------------------------
int __fastcall sub_4596C(int a1, int a2)
{
  int v2; // r3
  int v3; // r1
  int v4; // r2
  int v5; // r12
  int v6; // t1
  char *v7; // r0

  if ( !a2 )
    return 0xFFFF;
  v2 = 255;
  v3 = a1 + (unsigned __int16)(a2 - 1);
  v4 = a1 - 1;
  v5 = 255;
  do
  {
    v6 = *(unsigned __int8 *)++v4;
    v7 = &aTqFreezethaw[v2 ^ v6];
    v2 = (unsigned __int8)v7[2280] ^ v5;
    v5 = (unsigned __int8)v7[2536];
  }
  while ( v3 != v4 );
  return v2 | (v5 << 8);
}

//----- (000459C8) --------------------------------------------------------
int __fastcall sub_459C8(_BYTE *a1, int a2)
{
  unsigned __int8 v2; // r3
  int v3; // r12
  int v4; // r6
  int v5; // r8
  int v6; // r5
  int v7; // r7
  int v8; // r4
  unsigned int v9; // lr
  unsigned int v10; // r2
  int v11; // r9
  int v12; // r2
  int result; // r0

  if ( !a2 )
  {
    v11 = 1;
    result = 28;
LABEL_21:
    result |= 2u;
    goto LABEL_17;
  }
  v2 = 1;
  v3 = 0;
  v4 = 1;
  v5 = 1;
  v6 = 1;
  v7 = 1;
  v8 = 0;
  v9 = 128;
  while ( 1 )
  {
    ++v3;
    ++v8;
    v10 = *a1 & v9;
    v9 >>= 1;
    if ( v10 )
      v2 ^= 1u;
    v11 = v2;
    if ( v3 == 8 )
    {
      ++a1;
      v3 = 0;
      v9 = 128;
    }
    v12 = (unsigned __int8)(v2 ^ v6);
    v2 = v4;
    if ( a2 == v8 )
      break;
    v4 = v5;
    v6 = v7;
    v5 = v12;
    v7 = v11;
  }
  if ( v4 )
    result = 16;
  else
    result = 0;
  if ( v5 )
    result |= 8u;
  if ( v11 != v6 )
    result |= 4u;
  if ( v7 )
    goto LABEL_21;
LABEL_17:
  if ( v11 )
    return result | 1;
  return result;
}

//----- (00045A8C) --------------------------------------------------------
int __fastcall sub_45A8C(int result, unsigned int *a2, unsigned int a3)
{
  unsigned int v3; // r2
  unsigned int *v4; // r2
  unsigned int v5; // t1

  v3 = a3 >> 2;
  if ( v3 )
  {
    v4 = &a2[v3];
    result -= 4;
    do
    {
      v5 = *a2++;
      *(_DWORD *)(result + 4) = bswap32(v5);
      result += 4;
    }
    while ( a2 != v4 );
  }
  return result;
}

//----- (00045AB4) --------------------------------------------------------
int __fastcall sub_45AB4(char *a1, int a2)
{
  char *v2; // r1
  unsigned int v3; // r2
  char v4; // t1

  if ( !a2 )
    return 0;
  v2 = &a1[a2];
  v3 = -1;
  do
  {
    v4 = *a1++;
    v3 = *(_DWORD *)&aTqFreezethaw[4 * (unsigned __int8)(v4 ^ v3) + 2792] ^ (v3 >> 8);
  }
  while ( a1 != v2 );
  return ~v3;
}

//----- (00045AFC) --------------------------------------------------------
FILE *__fastcall sub_45AFC(const char *a1)
{
  FILE *result; // r0
  FILE *v3; // r4
  size_t v4; // r0

  result = fopen(aTmpStableFileN, "w");
  v3 = result;
  if ( result )
  {
    v4 = strlen(a1);
    fwrite(a1, 1u, v4, v3);
    fflush(v3);
    return (FILE *)fclose(v3);
  }
  return result;
}

//----- (00045B50) --------------------------------------------------------
FILE *__fastcall sub_45B50(int a1, char *a2)
{
  FILE *result; // r0
  FILE *v4; // r5

  if ( a1 )
    return sub_45AFC(a2);
  result = fopen(aTmpStableFileN, "r");
  v4 = result;
  if ( result )
  {
    fread(a2, 1u, 0x40u, result);
    return (FILE *)fclose(v4);
  }
  return result;
}

//----- (00045BA4) --------------------------------------------------------
int __fastcall sub_45BA4(_DWORD *a1, _DWORD *a2)
{
  int v4; // r0
  int v6; // r3
  __int16 v7; // [sp+4h] [bp-4h] BYREF

  sub_45B50(0, byte_679978);
  if ( access(byte_679978, 0) == -1 )
    return 0;
  v4 = open(byte_679978, 0);
  dword_679974 = v4;
  if ( v4 == -1 )
    return 0;
  v7 = 0;
  if ( read(v4, &v7, 2u) != 2 )
    return 0;
  v6 = HIBYTE(v7);
  *a1 = (unsigned __int8)v7;
  *a2 = v6;
  close(dword_679974);
  return 1;
}
// 679974: using guessed type int dword_679974;

//----- (00045C48) --------------------------------------------------------
int __fastcall sub_45C48(char a1, char a2)
{
  char *v4; // r5
  _BYTE buf[8]; // [sp+4h] [bp-8h] BYREF

  sub_45AFC(byte_679978);
  if ( !access(byte_679978, 0) )
    unlink(byte_679978);
  dword_679974 = mkstemp(template);
  v4 = _strdup(template);
  buf[0] = a1;
  buf[1] = a2;
  write(dword_679974, buf, 2u);
  close(dword_679974);
  strcpy(byte_679978, v4);
  free(v4);
  sub_45AFC(byte_679978);
  return 1;
}
// 679974: using guessed type int dword_679974;

//----- (00045CFC) --------------------------------------------------------
__int64 sub_45CFC()
{
  int v0; // lr
  int v1; // r12
  const char *v2; // r12
  const char *v3; // lr
  const char *v4; // r1
  int v5; // r3
  bool v7; // zf
  int v8; // r12
  char *v9; // r12
  int v10; // r0
  int v11; // r3
  int v12; // [sp+0h] [bp-48h]
  char v13[48]; // [sp+18h] [bp-30h] BYREF
  char v14[8196]; // [sp+48h] [bp+0h] BYREF

  v0 = dword_4D4174;
  v1 = dword_BC84C;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    if ( dword_BC84C )
      v2 = "off";
    else
      v2 = "run";
    snprintf(
      v14,
      0x2000u,
      "stable_test,next test index[%d],item[%d],action:%s,duration:[%d]",
      dword_4D4174 + 3,
      dword_BC84C,
      v2,
      *(_DWORD *)&aTmpStableFileN[12 * dword_4D4174 + 52 + 4 * dword_BC84C]);
    sub_41DB8(3, v14, 0);
    v0 = dword_4D4174;
    v1 = dword_BC84C;
  }
  while ( 1 )
  {
    v5 = v0 + 3;
    v4 = (const char *)0x2000;
    if ( *(_DWORD *)&aTmpStableFileN[12 * v0 + 52 + 4 * v1] )
      break;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v3 = "off";
      if ( !v1 )
        v3 = "run";
      snprintf(v14, 0x2000u, "stable_test,test index[%d],item[%d],action:%s,duration is 0,goto next test.", v5, v1, v3);
      sub_41DB8(3, v14, 0);
      v1 = dword_BC84C;
      v0 = dword_4D4174;
    }
    v7 = v1 == 0;
    v1 = 0;
    if ( v7 )
    {
      v1 = 1;
      dword_BC84C = 1;
    }
    else
    {
      dword_BC84C = 0;
      dword_4D4174 = ++v0;
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v7 = v1 == 0;
      v12 = v1;
      v8 = 3 * v0 + v1;
      if ( v7 )
        v4 = "run";
      v9 = &aTmpStableFileN[4 * v8];
      if ( !v7 )
        v4 = "off";
      snprintf(
        v14,
        0x2000u,
        "stable_test,next test index[%d],item[%d],action:%s,duration[%d]",
        v0 + 3,
        v12,
        v4,
        *((_DWORD *)v9 + 13));
      sub_41DB8(3, v14, 0);
      v0 = dword_4D4174;
      v1 = dword_BC84C;
    }
  }
  if ( !v1 )
  {
    snprintf(v13, 0x30u, "stable_test,run test %d", v5);
    sub_45C48(dword_4D4174, dword_BC84C);
    sub_472E8(v13);
  }
  snprintf(v13, 0x30u, "stable_test,off test %d", v5);
  sub_47274(v13);
  sleep(0xAu);
  if ( *(_DWORD *)&aTmpStableFileN[12 * dword_4D4174 + 60] )
    v10 = 100;
  else
    v10 = 0;
  sub_168B4(v10);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    v11 = *(_DWORD *)&aTmpStableFileN[12 * dword_4D4174 + 60];
    if ( v11 )
      v11 = 100;
    snprintf(v14, 0x2000u, "stable_test,fan_pwm:%d", v11);
    sub_41DB8(3, v14, 0);
  }
  return sub_4465C(&dword_67996C);
}
// 45EE4: variable 'v4' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC84C: using guessed type int dword_BC84C;
// 4D4174: using guessed type int dword_4D4174;
// 67996C: using guessed type int dword_67996C;

//----- (00046150) --------------------------------------------------------
int __fastcall sub_46150(int result)
{
  int v1; // r1
  int v2; // r3

  v1 = dword_4D4174;
  if ( (unsigned int)dword_4D4174 <= 5 )
  {
    v2 = *(_DWORD *)&aTmpStableFileN[12 * dword_4D4174 + 52 + 4 * dword_BC84C];
    if ( v2 < result )
    {
      if ( dword_BC84C )
        v1 = dword_4D4174 + 1;
      else
        v2 = 1;
      if ( dword_BC84C )
      {
        v2 = 0;
        dword_4D4174 = v1;
      }
      dword_BC84C = v2;
      return sub_45CFC();
    }
  }
  return result;
}
// BC84C: using guessed type int dword_BC84C;
// 4D4174: using guessed type int dword_4D4174;

//----- (000461AC) --------------------------------------------------------
int sub_461AC()
{
  __int64 v0; // r2
  int v1; // r0
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v3, "stable_test,test_handler start.");
    sub_41DB8(3, v3, 0);
  }
  sub_4465C(&dword_6799B8);
  if ( !dword_4D4174 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v3, 0x2000u, "stable_test,first run ,wait until:%d.", 3600);
      sub_41DB8(3, v3, 0);
    }
    do
    {
      sleep(0xAu);
      sub_4465C(&dword_6799C4);
      dword_6799D0 = dword_6799C8 - dword_6799BC;
      LODWORD(v0) = dword_6799C4 - dword_6799B8;
      dword_6799CC = dword_6799C4 - dword_6799B8;
      if ( dword_6799C8 - dword_6799BC < 0 )
      {
        LODWORD(v0) = v0 - 1;
        HIDWORD(v0) = dword_6799C8 - dword_6799BC + 1000000;
        *(_QWORD *)&dword_6799CC = v0;
      }
    }
    while ( (int)v0 <= 3600 );
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v3, "stable_test,auto test start..");
    sub_41DB8(3, v3, 0);
  }
  sub_4465C(&dword_67996C);
  while ( sub_509B0() != 1 || dword_BC84C && dword_4D4174 )
  {
    sleep(0xAu);
    sub_4465C(&dword_6799C4);
    dword_6799D0 = dword_6799C8 - dword_679970;
    v1 = dword_6799C4 - dword_67996C;
    dword_6799CC = dword_6799C4 - dword_67996C;
    if ( dword_6799C8 - dword_679970 < 0 )
    {
      dword_6799CC = --v1;
      dword_6799D0 = dword_6799C8 - dword_679970 + (dword_6799C8 - dword_679970 < 0 ? 0xF4000 : 0) + 576;
    }
    sub_46150(v1);
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v3, "catch test err ,stop stable test!");
    sub_41DB8(3, v3, 0);
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC84C: using guessed type int dword_BC84C;
// 4D4174: using guessed type int dword_4D4174;
// 67996C: using guessed type int dword_67996C;
// 679970: using guessed type int dword_679970;
// 6799B8: using guessed type int dword_6799B8;
// 6799BC: using guessed type int dword_6799BC;
// 6799C4: using guessed type int dword_6799C4;
// 6799C8: using guessed type int dword_6799C8;
// 6799CC: using guessed type int dword_6799CC;
// 6799D0: using guessed type int dword_6799D0;

//----- (000463F8) --------------------------------------------------------
void sub_463F8()
{
  dword_679968 = 1;
}
// 679968: using guessed type int dword_679968;

//----- (0004640C) --------------------------------------------------------
int sub_4640C()
{
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "start_stable_test *****");
    sub_41DB8(3, s, 0);
  }
  sub_168B4(100);
  sleep(0xAu);
  sub_45BA4(&dword_4D4174, &dword_BC84C);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "last status index:%d,item:%d", dword_4D4174, dword_BC84C);
    sub_41DB8(3, s, 0);
  }
  return pthread_create(&dword_6799C0, 0, (void *(*)(void *))sub_461AC, 0);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC84C: using guessed type int dword_BC84C;
// 4D4174: using guessed type int dword_4D4174;
// 6799C0: using guessed type pthread_t dword_6799C0;

//----- (000464F0) --------------------------------------------------------
int __fastcall sub_464F0(int result)
{
  unsigned int *v1; // r10
  int v2; // r3
  unsigned int *v3; // r5
  unsigned int v4; // r8
  unsigned int v5; // r2
  unsigned int v6; // r4
  int v7; // r3
  char dest[8196]; // [sp+8h] [bp-2004h] BYREF

  v1 = (unsigned int *)result;
  if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
  {
    strcpy(dest, "==========================capability start==========================\n");
    result = sub_41DB8(5, dest, 0);
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
    {
      snprintf(dest, 0x2000u, "board num = %d\n", *v1);
      result = sub_41DB8(5, dest, 0);
    }
  }
  v2 = (unsigned __int8)byte_6682BC;
  if ( *v1 )
  {
    v3 = v1;
    v4 = 0;
    do
    {
      if ( v2 || (v2 = (unsigned __int8)byte_4D4171, byte_4D4171) || dword_BC5F4 > 4 )
      {
        snprintf(dest, 0x2000u, "board id = %d, chain num = %d\n", v3[1], v3[2]);
        result = sub_41DB8(5, dest, 0);
        v2 = (unsigned __int8)byte_6682BC;
      }
      v5 = v3[2];
      if ( v5 )
      {
        v6 = 0;
        do
        {
          if ( !v2 )
          {
            while ( 1 )
            {
              v2 = (unsigned __int8)byte_4D4171;
              if ( byte_4D4171 || dword_BC5F4 > 4 )
                break;
              if ( v5 <= ++v6 )
                goto LABEL_17;
            }
          }
          v7 = v3[v6++ + 3];
          snprintf(dest, 0x2000u, "\tchain id = %d\n", v7);
          result = sub_41DB8(5, dest, 0);
          v5 = v3[2];
          v2 = (unsigned __int8)byte_6682BC;
        }
        while ( v5 > v6 );
      }
LABEL_17:
      ++v4;
      v3 += 18;
    }
    while ( *v1 > v4 );
  }
  if ( v2 || byte_4D4171 || dword_BC5F4 > 4 )
  {
    strcpy(dest, "==========================capability end============================\n");
    return sub_41DB8(5, dest, 0);
  }
  return result;
}
// BC5F4: using guessed type int dword_BC5F4;
// 4D4171: using guessed type char byte_4D4171;
// 6682BC: using guessed type char byte_6682BC;

//----- (00046750) --------------------------------------------------------
char *__fastcall sub_46750(char *a1, int a2)
{
  int v4; // r5
  int v5; // r8
  char *result; // r0
  int v7; // r7
  int v8; // r3
  int v9; // r0
  int v10; // r2
  int v11; // r7
  size_t v12; // r0
  int v13; // r5
  int v14; // r1
  int v15; // r3
  int v16; // r12
  int v17; // r2
  size_t v18; // r0
  size_t v19; // r0
  size_t v20; // r4
  size_t v21; // r0
  char src[4]; // [sp+24h] [bp-818h] BYREF
  int v23; // [sp+28h] [bp-814h]
  int v24; // [sp+2Ch] [bp-810h]
  int v25; // [sp+30h] [bp-80Ch]
  int v26; // [sp+34h] [bp-808h]
  char dest[4]; // [sp+38h] [bp-804h] BYREF
  _BYTE s[2044]; // [sp+3Ch] [bp-800h] BYREF

  v4 = 0;
  do
  {
    v5 = v4 + 1;
    if ( sub_27EC8(v4) )
    {
      v7 = 0;
      *(_DWORD *)dest = 123;
      memset(s, 0, sizeof(s));
      *(_DWORD *)src = 0;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      snprintf(src, 0x14u, "Chain%d:{", v4 + 1);
      strncat(dest, src, 0x7FEu);
      v8 = dword_4D4178 % 60 - 1;
      v9 = v8 - a2;
      do
      {
        v10 = v8 + (v8 < 0 ? 0x3C : 0);
        --v8;
        v7 += dword_4D73D0[30720 * v4 + 2 * v10];
      }
      while ( v9 != v8 );
      snprintf(src, 0x14u, "N%d=%d", 0, v7);
      v11 = 1;
      v12 = strlen(dest);
      strncat(dest, src, 2047 - v12);
      v13 = 15360 * v4;
      if ( sub_27D1C() > 1 )
      {
        do
        {
          v14 = 0;
          v15 = dword_4D4178 % 60 - 1;
          v16 = v15 - a2;
          do
          {
            v17 = v15 + (v15 < 0 ? 0x3C : 0);
            --v15;
            v14 += dword_4D73D0[120 * v11 + 2 * v13 + 2 * v17];
          }
          while ( v16 != v15 );
          snprintf(src, 0x14u, ",N%d=%d", v11++, v14);
          v18 = strlen(dest);
          strncat(dest, src, 2047 - v18);
        }
        while ( sub_27D1C() > v11 );
      }
      v19 = strlen(dest);
      strncat(dest, "},", 2047 - v19);
      v20 = strlen(a1);
      v21 = strlen(dest);
      strncat(a1, dest, 0x1FFF - (v20 + v21));
    }
    v4 = v5;
  }
  while ( v5 != 4 );
  result = &a1[strlen(a1)];
  *(result - 1) = 0;
  return result;
}
// 4D4178: using guessed type int dword_4D4178;
// 4D73D0: using guessed type _DWORD dword_4D73D0[122880];

//----- (000469CC) --------------------------------------------------------
int __fastcall sub_469CC(int a1, int a2, int a3)
{
  const char *v4; // r0
  int v5; // r4
  const char *v6; // r0
  int v7; // r3
  float v8; // s17
  const char *v9; // r0
  int v10; // r3
  float v11; // s16
  const char *v12; // r0
  int v13; // r3
  int v14; // r5
  const char *v15; // r0
  int v16; // r3
  const char *v18; // r0

  v4 = (const char *)sub_27CEC();
  if ( !strcmp(v4, "HHB68502") || (v18 = (const char *)sub_27CEC(), !strcmp(v18, "HHB68503")) )
    v5 = 54;
  else
    v5 = 49;
  if ( a1 <= v5 )
  {
    v6 = (const char *)sub_27CEC();
    if ( !strcmp(v6, "H1HB68601") )
      v7 = 41;
    else
      v7 = 42;
    v8 = (float)(a1 - v7);
    v9 = (const char *)sub_27CEC();
    if ( !strcmp(v9, "H1HB68601") )
      v10 = 41;
    else
      v10 = 42;
    v11 = (float)(v8 / (float)(v5 - v10)) * (float)a3;
    v12 = (const char *)sub_27CEC();
    if ( !strcmp(v12, "H1HB68601") )
      v13 = 41;
    else
      v13 = 42;
    v14 = v13 - a1;
    v15 = (const char *)sub_27CEC();
    if ( !strcmp(v15, "H1HB68601") )
      v16 = 41;
    else
      v16 = 42;
    return (int)(float)(v11 + (float)((float)((float)((float)v14 / (float)(v5 - v16)) + 1.0) * (float)a2));
  }
  return a3;
}

//----- (00046B08) --------------------------------------------------------
int sub_46B08()
{
  const char *v0; // r0
  int result; // r0
  int v2; // r4
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  v0 = (const char *)sub_27CEC();
  result = strcmp(v0, "HHB68503");
  v2 = result;
  if ( !result )
  {
    do
    {
      result = sub_27EC8(v2);
      if ( result )
      {
        result = sub_1BEA4(v2);
        if ( result == 305 )
        {
          result = sub_810E8((unsigned __int8)v2, 5);
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(v3, 0x2000u, "chain_%d set ro ds to 5\n", v2);
            result = sub_41DB8(3, v3, 0);
          }
        }
      }
      ++v2;
    }
    while ( v2 != 4 );
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00046BB8) --------------------------------------------------------
FILE *__fastcall sub_46BB8(const char *a1)
{
  FILE *result; // r0
  FILE *v2; // r8
  int v3; // r5
  int v4; // r4
  char *v5; // r6
  char *v6; // r7
  size_t v8; // r12
  int v9; // r3
  size_t v10; // r0
  int v11; // r5
  char *v12; // r6
  int v13; // r4
  const char *v14; // r3
  int v15; // [sp+Ch] [bp-2590h]
  char s1[128]; // [sp+18h] [bp-2584h] BYREF
  char s[1280]; // [sp+98h] [bp-2504h] BYREF
  char v19[8196]; // [sp+598h] [bp-2004h] BYREF

  memset(s, 0, sizeof(s));
  memset(s1, 0, sizeof(s1));
  result = fopen((const char *)dword_C2DC8, "r");
  v2 = result;
  if ( result )
  {
    v3 = 0;
    v15 = 0;
    while ( 1 )
    {
      v4 = v3 << 7;
      v5 = &s[128 * v3];
      v6 = &v19[128 * v3];
      if ( feof(v2) )
        break;
      if ( v3++ == 10 )
      {
        result = (FILE *)fclose(v2);
        if ( !v15 )
          return result;
        v11 = 9;
        memset(s1, 0, sizeof(s1));
        snprintf(s1, 0x80u, "echo %s > %s", s, (const char *)dword_C2DC8);
        system(s1);
LABEL_20:
        v12 = &s[128];
        v13 = 1;
        do
        {
          ++v13;
          memset(s1, 0, sizeof(s1));
          v14 = v12;
          v12 += 128;
          snprintf(s1, 0x80u, "echo %s >> %s", v14, (const char *)dword_C2DC8);
          result = (FILE *)system(s1);
        }
        while ( v13 < v11 );
LABEL_15:
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(v19, 0x2000u, "updated miner type to: Antminer %s\n", a1);
          return (FILE *)sub_41DB8(3, v19, 0);
        }
        return result;
      }
      fgets(v5, 128, v2);
      v8 = strlen(v5) - 1;
      v9 = (unsigned __int8)v6[v8 - 1280];
      if ( v9 == 10 )
      {
        v6[v8 - 1280] = 0;
        v8 = strlen(v5) - 1;
        v9 = (unsigned __int8)v6[v8 - 1280];
      }
      if ( v9 == 13 )
        v19[v4 - 1280 + v8] = 0;
      if ( _isoc99_sscanf(v5, "Antminer %s", s1) == 1 )
      {
        v10 = strlen(a1);
        if ( strncmp(s1, a1, v10) )
        {
          v15 = 1;
          snprintf(v5, 0x80u, "Antminer %s", a1);
        }
      }
    }
    result = (FILE *)fclose(v2);
    if ( v15 )
    {
      v11 = v3 - 1;
      memset(s1, 0, sizeof(s1));
      snprintf(s1, 0x80u, "echo %s > %s", s, (const char *)dword_C2DC8);
      result = (FILE *)system(s1);
      if ( v11 > 1 )
        goto LABEL_20;
      goto LABEL_15;
    }
  }
  return result;
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C2DC8: using guessed type int dword_C2DC8;

//----- (00046E68) --------------------------------------------------------
int sub_46E68()
{
  unsigned int v0; // r5
  int v1; // r4
  unsigned int v3; // [sp+4h] [bp-2008h] BYREF
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v0 = 0;
  v1 = 0;
  v3 = 0;
  do
  {
    if ( sub_27EC8(v1) && !sub_1CAAC(v1, (unsigned __int8)dword_C351C, (int *)&v3) && v0 < v3 )
      v0 = v3;
    ++v1;
  }
  while ( v1 != 4 );
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "max voltage in eeprom = %d\n", v0);
    sub_41DB8(4, s, 0);
  }
  if ( v0 )
    return v0;
  else
    return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C351C: using guessed type int dword_C351C;

//----- (00046F2C) --------------------------------------------------------
int sub_46F2C()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  strcpy(v1, "This is fix-freq version\n");
  return sub_41DB8(3, v1, 0);
}

//----- (00046F74) --------------------------------------------------------
int sub_46F74()
{
  unsigned int v1; // r4
  const char *v2; // r0
  const char *v3; // r0
  const char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0

  if ( dword_4D417C <= (unsigned int)dword_4D4180 )
    return 0;
  v1 = (dword_4D417C - dword_4D4180) / 0x14u;
  v2 = (const char *)sub_27CEC();
  if ( strcmp(v2, "HHB68502") )
  {
    v3 = (const char *)sub_27CEC();
    if ( strcmp(v3, "HHB68501") )
    {
      v4 = (const char *)sub_27CEC();
      if ( strcmp(v4, "HHB68701") )
      {
        v5 = (const char *)sub_27CEC();
        if ( strcmp(v5, "HHB68704") )
        {
          v6 = (const char *)sub_27CEC();
          if ( strcmp(v6, "HHB68703") )
          {
            v7 = (const char *)sub_27CEC();
            if ( strcmp(v7, "H1HB68601") )
            {
              v8 = (const char *)sub_27CEC();
              if ( strcmp(v8, "HHB68601") )
              {
                v9 = (const char *)sub_27CEC();
                if ( strcmp(v9, "HHB68602") )
                {
                  v10 = (const char *)sub_27CEC();
                  if ( strcmp(v10, "HHB56611") )
                  {
                    v11 = (const char *)sub_27CEC();
                    if ( strcmp(v11, "HHB68503") )
                      return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  switch ( v1 )
  {
    case 2u:
      return 10;
    case 3u:
      return 15;
    case 1u:
      return 5;
  }
  return 20;
}
// 4D417C: using guessed type int dword_4D417C;
// 4D4180: using guessed type int dword_4D4180;

//----- (000470D0) --------------------------------------------------------
int __fastcall sub_470D0(int result)
{
  unsigned int v1; // r5
  int i; // r4
  int v3; // r1
  char *v4; // r3

  if ( dword_BC898[0] == 2 )
  {
    v1 = result;
    for ( i = 0; i != 4; ++i )
    {
      result = sub_27EC8(i);
      if ( result )
      {
        result = sub_27D1C();
        if ( result > 0 )
        {
          v3 = dword_4D4180;
          v4 = (char *)&unk_54F3D0 + 1024 * i;
          do
          {
            *(_DWORD *)v4 = v3;
            v4 += 4;
          }
          while ( v4 != (char *)&unk_54F3D0 + 1024 * i + 4 * result );
        }
      }
    }
    if ( flt_BC5C4 > 0.0 )
      return sub_23998((unsigned __int8)byte_4D4184, v1, dword_4D4180, 3000, 0, 0, 0);
  }
  return result;
}
// BC5C4: using guessed type float flt_BC5C4;
// BC898: using guessed type int dword_BC898[];
// 4D4180: using guessed type int dword_4D4180;
// 4D4184: using guessed type char byte_4D4184;

//----- (00047198) --------------------------------------------------------
void sub_47198()
{
  sub_18954();
  sub_18A14();
  sub_38B68();
  sub_38AC8();
  sub_38A28();
  if ( !byte_C1E68 )
  {
    sub_38CA8();
    byte_C1E68 = 1;
  }
}
// C1E68: using guessed type char byte_C1E68;

//----- (000471D4) --------------------------------------------------------
int sub_471D4()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v1, "****power off hashboard****\n");
    sub_41DB8(3, v1, 0);
  }
  if ( !dword_BDA84 )
  {
    sub_27EC8(0);
    sub_27EC8(1);
    sub_27EC8(2);
    sub_27EC8(3);
    sub_44890();
  }
  sub_21D18();
  return sub_62F48();
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA84: using guessed type int dword_BDA84;

//----- (00047274) --------------------------------------------------------
int __fastcall sub_47274(const char *a1)
{
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 1 )
  {
    snprintf(s, 0x2000u, "%s: %s\n", "stop_mining", a1);
    sub_41DB8(1, s, 0);
  }
  sub_47198();
  sub_471D4();
  sub_5EA88();
  sub_5EB20();
  return sub_2CCA8(1);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000472E8) --------------------------------------------------------
void __fastcall __noreturn sub_472E8(const char *a1)
{
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 1 )
  {
    snprintf(s, 0x2000u, "%s: %s\n", "stop_mining_and_restart", a1);
    sub_41DB8(1, s, 0);
  }
  sub_47198();
  sub_471D4();
  sub_5EA88();
  sub_5EB20();
  strcpy(s, "restart\n");
  sub_41DB8(0, s, 0);
  _assert_fail("0", "driver-btm-api.c", 0xE6u, "stop_mining_and_restart");
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00047394) --------------------------------------------------------
int sub_47394()
{
  return dword_4D4188;
}
// 4D4188: using guessed type int dword_4D4188;

//----- (000473A4) --------------------------------------------------------
int sub_473A4()
{
  return dword_4D418C;
}
// 4D418C: using guessed type int dword_4D418C;

//----- (000473B4) --------------------------------------------------------
unsigned int __fastcall sub_473B4(unsigned int result, const char *a2)
{
  int v3; // r5
  int v4; // r3
  int v5; // r3
  int v6; // r3
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v3 = result;
  dword_4D4188 = result;
  if ( a2 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      if ( result > 0x15 )
        v4 = 0;
      else
        v4 = 4 * result + 659804;
      if ( result <= 0x15 )
        v4 = *(_DWORD *)(v4 + 60);
      snprintf(s, 0x2000u, "%s: %s\n", v4, a2);
      result = sub_41DB8(3, s, 0);
      goto LABEL_9;
    }
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    if ( result > 0x15 )
      v6 = 0;
    else
      v6 = 4444;
    if ( result <= 0x15 )
    {
      HIWORD(v6) = 10;
      v6 = *(_DWORD *)(v6 + 4 * result + 60);
    }
    snprintf(s, 0x2000u, "%s\n", v6);
    result = sub_41DB8(3, s, 0);
LABEL_9:
    v5 = dword_4D4188;
    if ( v3 == 3 )
      goto LABEL_11;
    goto LABEL_10;
  }
  if ( result == 3 )
    return result;
  v5 = result;
LABEL_10:
  dword_4D418C = v3;
LABEL_11:
  switch ( v5 )
  {
    case 4:
    case 8:
    case 9:
    case 14:
      if ( (unsigned int)off_BC5EC > 1 )
      {
        snprintf(s, 0x2000u, "%s: %s\n", "stop_mining_waiting", a2);
        sub_41DB8(1, s, 0);
      }
      sub_47198();
      sub_471D4();
      sub_5EA88();
      sub_5EB20();
      sub_2CCA8(1);
      while ( 1 )
        sleep(1u);
    case 5:
    case 7:
    case 10:
    case 11:
    case 12:
    case 15:
    case 16:
    case 17:
    case 21:
      byte_4D4190 = 1;
      result = sub_47274(a2);
      break;
    case 6:
    case 13:
    case 20:
      sub_472E8(a2);
    case 18:
    case 19:
      result = sub_471D4();
      break;
    default:
      return result;
  }
  return result;
}
// 47448: control flows out of bounds to 4744C
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 4D4188: using guessed type int dword_4D4188;
// 4D418C: using guessed type int dword_4D418C;
// 4D4190: using guessed type char byte_4D4190;

//----- (0004758C) --------------------------------------------------------
int __fastcall sub_4758C(int a1)
{
  float v1; // s0
  int v3; // r9
  const char *v4; // r0
  int v5; // r8
  _DWORD *v6; // r4
  int v7; // r5
  void *v8; // r2
  int v9; // r3
  bool v10; // cc
  int v11; // r3
  float v12; // s16
  double v13; // r0
  double v14; // d9
  double v15; // d0
  double v16; // d8
  float v17; // s17
  double v18; // d10
  double v19; // d0
  double v20; // d9
  int v21; // r10
  const char *v22; // r0
  bool v23; // zf
  const char *v24; // r0
  char s[8192]; // [sp+18h] [bp-2000h] BYREF

  v3 = sub_2242C();
  v4 = (const char *)sub_27CEC();
  if ( !strcmp(v4, "H1HB68601") )
    v5 = sub_469CC(a1, (int)((double)SLODWORD(flt_BC89C) * 0.95), (int)((double)SLODWORD(flt_BC89C) * 0.99));
  else
    v5 = sub_469CC(a1, (int)((double)SLODWORD(flt_BC89C) * 0.96), SLODWORD(flt_BC89C));
  pthread_setcancelstate(1, 0);
  sub_226B4();
  LOWORD(v6) = (unsigned __int16)&dword_4D4178;
  v7 = (int)v1;
  pthread_setcancelstate(0, 0);
  if ( (int)v1 <= 6100 )
  {
    HIWORD(v6) = (unsigned int)&dword_4D4178 >> 16;
    v6[7] = 0;
    v8 = off_BC5EC;
  }
  else
  {
    HIWORD(v6) = (unsigned int)&dword_4D4178 >> 16;
    v8 = off_BC5EC;
    v9 = v6[7] + 1;
    v10 = v7 <= 6450;
    if ( v7 <= 6450 )
      v10 = v9 <= 15;
    v6[7] = v9;
    if ( !v10 )
    {
      if ( (unsigned int)v8 > 3 )
      {
        snprintf(s, 0x2000u, "power over max %d(%d %d) count: %d", (int)v1, 6100, 6450, v9);
        sub_41DB8(3, s, 0);
      }
      sub_4FB28(26, 0);
      sub_473B4(9u, "power over max on hem");
      v8 = off_BC5EC;
    }
  }
  v11 = v6[8];
  v12 = (float)v7;
  if ( v11 > 0 )
    v6[8] = v11 - 1;
  if ( (unsigned int)v8 > 4 )
  {
    v17 = (float)(v12 / (float)v3) * 100.0;
    snprintf(
      s,
      0x2000u,
      "HEM power adjust current v: %d  I :%f miner power %d target_power %d entrance_temp :%d g_target_power: %d",
      v3,
      v17,
      (int)v1,
      v5,
      a1,
      flt_BC89C);
    sub_41DB8(4, s, 0);
    if ( v17 > 300.0 && (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "over max I 300 which is : %f  ", v17);
      sub_41DB8(4, s, 0);
    }
  }
  LODWORD(v13) = pthread_setcancelstate(1, 0);
  if ( v7 < v5 + 50 )
    goto LABEL_16;
  if ( v6[8] )
    return LODWORD(v13);
  v18 = (double)v3;
  v19 = (float)(v12 / (float)v5);
  v20 = sqrt(v19);
  if ( v19 < 0.0 )
    sqrt(v13);
  v21 = (int)(v18 / v20);
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "set to target_vol = %d", (int)(v18 / v20));
    sub_41DB8(4, s, 0);
  }
  if ( v21 <= 1800 )
  {
    v24 = (const char *)sub_27CEC();
    LODWORD(v13) = strcmp(v24, "H1HB68601");
    if ( LODWORD(v13) )
    {
      v21 = 1800;
      goto LABEL_41;
    }
    goto LABEL_47;
  }
  v22 = (const char *)sub_27CEC();
  LODWORD(v13) = strcmp(v22, "H1HB68601");
  v23 = v21 == 1870;
  if ( v21 <= 1870 )
    v23 = LODWORD(v13) == 0;
  if ( v23 )
LABEL_47:
    v21 = 1870;
LABEL_41:
  if ( v3 - v21 > 20 )
    v21 = v3 - 20;
  if ( v3 > v21 )
  {
    LODWORD(v13) = sub_21E88(v21, 3u);
    v6[8] = 2;
    return LODWORD(v13);
  }
LABEL_16:
  if ( v7 <= v5 - 50 && !v6[8] )
  {
    v14 = (double)v3;
    v15 = (float)(v12 / (float)v5);
    v16 = sqrt(v15);
    if ( v15 < 0.0 )
      sqrt(v13);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "set to target_vol = %d", (int)(v14 / v16));
      sub_41DB8(4, s, 0);
    }
    LODWORD(v13) = v6[9];
    if ( (int)(v14 / v16) < SLODWORD(v13) )
      LODWORD(v13) = (int)(v14 / v16);
    if ( LODWORD(v13) - v3 > 20 )
      LODWORD(v13) = v3 + 20;
    if ( v3 < SLODWORD(v13) )
      LODWORD(v13) = sub_21E88(SLODWORD(v13), 3u);
  }
  return LODWORD(v13);
}
// 4761C: variable 'v1' is possibly undefined
// 47994: variable 'v13' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC89C: using guessed type float flt_BC89C;
// 4D4178: using guessed type int dword_4D4178;

//----- (000479C8) --------------------------------------------------------
int __fastcall sub_479C8(int a1)
{
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v3, 0x2000u, "Chain %d PIC reset failed.\n", a1);
    sub_41DB8(3, v3, 0);
  }
  sub_27E2C(a1, 0);
  sub_4FB28(4, a1);
  sub_473B4(8u, "PIC reset failed.\n");
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00047A48) --------------------------------------------------------
int __fastcall sub_47A48(int a1, int *a2, int *a3)
{
  const char *v3; // r0
  const char *v4; // r0
  int v5; // r5
  const char *v6; // r0
  int result; // r0
  const char *v10; // r0
  int v11; // r3
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  const char *v35; // r0
  const char *v36; // r0
  const char *v37; // r0
  const char *v38; // r0
  const char *v39; // r0
  const char *v40; // r0
  const char *v41; // r0
  const char *v42; // r0
  int v43; // r3
  const char *v44; // r0
  const char *v45; // r0
  const char *v46; // r0
  const char *v47; // r0
  const char *v48; // r0
  const char *v49; // r0
  const char *v50; // r0
  const char *v51; // r0
  const char *v52; // r0
  const char *v53; // r0
  const char *v54; // r0
  const char *v55; // r0
  const char *v56; // r0
  const char *v57; // r0
  const char *v58; // r0
  const char *v59; // r0
  const char *v60; // r0
  const char *v61; // r0
  const char *v62; // r0
  const char *v63; // r0
  const char *v64; // r0
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( !a1 )
  {
    if ( a2 )
    {
      v10 = (const char *)sub_27CEC();
      if ( !strcmp(v10, "HHB68601") )
        goto LABEL_15;
      v14 = (const char *)sub_27CEC();
      if ( !strcmp(v14, "HHB68602") )
        goto LABEL_15;
      v15 = (const char *)sub_27CEC();
      if ( !strcmp(v15, "HHB68502")
        || (v16 = (const char *)sub_27CEC(), !strcmp(v16, "HHB68501"))
        || (v17 = (const char *)sub_27CEC(), !strcmp(v17, "HHB68701"))
        || (v18 = (const char *)sub_27CEC(), !strcmp(v18, "HHB68704"))
        || (v19 = (const char *)sub_27CEC(), !strcmp(v19, "HHB68703"))
        || (v20 = (const char *)sub_27CEC(), !strcmp(v20, "H6HB68702"))
        || (v21 = (const char *)sub_27CEC(), !strcmp(v21, "H1HB68601"))
        || (v22 = (const char *)sub_27CEC(), !strcmp(v22, "HHB68503")) )
      {
LABEL_15:
        v11 = dword_AB7A28;
        if ( dword_AB7A28 > 44 )
        {
          *a2 = -30;
          goto LABEL_44;
        }
        if ( dword_AB7A28 > 42 )
        {
          *a2 = -20;
          goto LABEL_44;
        }
        if ( dword_AB7A28 > 39 )
        {
          *a2 = -10;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 5 )
        {
          *a2 = 120;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 8 )
        {
          *a2 = 110;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 11 )
        {
          *a2 = 100;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 14 )
        {
          *a2 = 90;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 17 )
        {
          *a2 = 80;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 20 )
        {
          *a2 = 70;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 23 )
        {
          *a2 = 60;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 26 )
        {
          *a2 = 50;
          goto LABEL_44;
        }
        if ( dword_AB7A28 <= 29 )
        {
          *a2 = 40;
          goto LABEL_44;
        }
        if ( dword_AB7A28 != 30 )
        {
          if ( dword_AB7A28 <= 34 )
          {
            *a2 = 20;
            goto LABEL_44;
          }
          v11 = 0;
        }
        *a2 = v11;
      }
    }
LABEL_44:
    if ( a3 )
    {
      if ( dword_C351C != 2 )
      {
        v12 = (const char *)sub_27CEC();
        if ( !strcmp(v12, "HHB68502")
          || (v27 = (const char *)sub_27CEC(), !strcmp(v27, "HHB68501"))
          || (v28 = (const char *)sub_27CEC(), !strcmp(v28, "HHB68601"))
          || (v29 = (const char *)sub_27CEC(), !strcmp(v29, "HHB68602"))
          || (v30 = (const char *)sub_27CEC(), !strcmp(v30, "HHB56611"))
          || (v31 = (const char *)sub_27CEC(), !strcmp(v31, "HHB68503")) )
        {
          *a3 = 410;
        }
        v13 = (const char *)sub_27CEC();
        if ( strcmp(v13, "HHB68701") )
        {
          v23 = (const char *)sub_27CEC();
          if ( strcmp(v23, "HHB68704") )
          {
            v24 = (const char *)sub_27CEC();
            if ( strcmp(v24, "HHB68703") )
            {
              v25 = (const char *)sub_27CEC();
              if ( strcmp(v25, "H6HB68702") )
              {
                v26 = (const char *)sub_27CEC();
                if ( strcmp(v26, "H1HB68601") )
                  return 0;
              }
            }
          }
        }
        *a3 = 430;
        return 0;
      }
      v42 = (const char *)sub_27CEC();
      if ( !strcmp(v42, "HHB68502") )
        goto LABEL_85;
      v55 = (const char *)sub_27CEC();
      if ( !strcmp(v55, "HHB68501") )
        goto LABEL_85;
      v56 = (const char *)sub_27CEC();
      if ( !strcmp(v56, "HHB68701") )
        goto LABEL_85;
      v57 = (const char *)sub_27CEC();
      if ( !strcmp(v57, "HHB68704")
        || (v58 = (const char *)sub_27CEC(), !strcmp(v58, "HHB68703"))
        || (v59 = (const char *)sub_27CEC(), !strcmp(v59, "H6HB68702"))
        || (v60 = (const char *)sub_27CEC(), !strcmp(v60, "H1HB68601"))
        || (v61 = (const char *)sub_27CEC(), !strcmp(v61, "HHB68601"))
        || (v62 = (const char *)sub_27CEC(), !strcmp(v62, "HHB68602"))
        || (v63 = (const char *)sub_27CEC(), !strcmp(v63, "HHB56611"))
        || (v64 = (const char *)sub_27CEC(), !strcmp(v64, "HHB68503")) )
      {
LABEL_85:
        if ( dword_AB7A28 > 47 )
        {
          *a3 = 415;
          return 0;
        }
        else if ( dword_AB7A28 > 45 )
        {
          *a3 = 435;
          return 0;
        }
        else
        {
          result = 0;
          if ( dword_AB7A28 <= 42 )
            v43 = 475;
          else
            v43 = 455;
          *a3 = v43;
        }
        return result;
      }
    }
    return 0;
  }
  if ( dword_BDA84 == 3 )
    dword_AB7A28 = sub_194F8();
  else
    dword_AB7A28 = sub_19404();
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "Sensor localtion:%d, Bring up temperature is %d\n", dword_BDA84, dword_AB7A28);
    sub_41DB8(3, s, 0);
  }
  v3 = (const char *)sub_27CEC();
  if ( strcmp(v3, "HHB68502") )
  {
    v32 = (const char *)sub_27CEC();
    if ( strcmp(v32, "HHB68501") )
    {
      v33 = (const char *)sub_27CEC();
      if ( strcmp(v33, "HHB68701") )
      {
        v34 = (const char *)sub_27CEC();
        if ( strcmp(v34, "HHB68704") )
        {
          v35 = (const char *)sub_27CEC();
          if ( strcmp(v35, "HHB68703") )
          {
            v36 = (const char *)sub_27CEC();
            if ( strcmp(v36, "H6HB68702") )
            {
              v37 = (const char *)sub_27CEC();
              if ( strcmp(v37, "H1HB68601") )
              {
                v38 = (const char *)sub_27CEC();
                if ( strcmp(v38, "HHB68601") )
                {
                  v39 = (const char *)sub_27CEC();
                  if ( strcmp(v39, "HHB68602") )
                  {
                    v40 = (const char *)sub_27CEC();
                    if ( strcmp(v40, "HHB56611") )
                    {
                      v41 = (const char *)sub_27CEC();
                      if ( strcmp(v41, "HHB68503") )
                        goto LABEL_8;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( dword_AB7A28 <= 19 )
  {
    byte_4D41A0 = 1;
    sub_4FB28(9, 255);
    sub_2CC78(1);
    sub_473B4(0x10u, "Water temperature is too low!");
    return 1;
  }
  else
  {
LABEL_8:
    v4 = (const char *)sub_27CEC();
    if ( !strcmp(v4, "HHB68502") || (v54 = (const char *)sub_27CEC(), !strcmp(v54, "HHB68503")) )
      v5 = 56;
    else
      v5 = 51;
    v6 = (const char *)sub_27CEC();
    if ( strcmp(v6, "HHB68502") )
    {
      v44 = (const char *)sub_27CEC();
      if ( strcmp(v44, "HHB68501") )
      {
        v45 = (const char *)sub_27CEC();
        if ( strcmp(v45, "HHB68701") )
        {
          v46 = (const char *)sub_27CEC();
          if ( strcmp(v46, "HHB68704") )
          {
            v47 = (const char *)sub_27CEC();
            if ( strcmp(v47, "HHB68703") )
            {
              v48 = (const char *)sub_27CEC();
              if ( strcmp(v48, "H6HB68702") )
              {
                v49 = (const char *)sub_27CEC();
                if ( strcmp(v49, "H1HB68601") )
                {
                  v50 = (const char *)sub_27CEC();
                  if ( strcmp(v50, "HHB68601") )
                  {
                    v51 = (const char *)sub_27CEC();
                    if ( strcmp(v51, "HHB68602") )
                    {
                      v52 = (const char *)sub_27CEC();
                      if ( strcmp(v52, "HHB56611") )
                      {
                        v53 = (const char *)sub_27CEC();
                        if ( strcmp(v53, "HHB68503") )
                          return 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ( dword_AB7A28 < v5 )
      return 0;
    sub_4FB28(8, 255);
    sub_2CC78(1);
    sub_473B4(0xEu, "Water temperature is too high!");
    return 1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDA84: using guessed type int dword_BDA84;
// C351C: using guessed type int dword_C351C;
// 4D41A0: using guessed type char byte_4D41A0;
// AB7A28: using guessed type int dword_AB7A28;

//----- (00048264) --------------------------------------------------------
int sub_48264()
{
  return 0;
}

//----- (0004826C) --------------------------------------------------------
int sub_4826C()
{
  return (unsigned __int8)byte_4D41A0;
}
// 4D41A0: using guessed type char byte_4D41A0;

//----- (0004827C) --------------------------------------------------------
int __fastcall sub_4827C(int a1)
{
  int v1; // r5

  v1 = (unsigned __int8)a1;
  if ( !sub_21A1C(a1) )
    return sub_479C8(a1);
  sub_21A54(a1);
  sub_21A38(v1);
  return 0;
}
// 21A38: using guessed type int __fastcall sub_21A38(_DWORD);

//----- (000482B8) --------------------------------------------------------
int sub_482B8()
{
  int v0; // r4
  int v1; // r5

  v0 = 0;
  v1 = 0;
  do
  {
    if ( sub_27EC8(v0) )
      v1 |= sub_4827C(v0);
    ++v0;
  }
  while ( v0 != 4 );
  return v1;
}

//----- (000482F8) --------------------------------------------------------
unsigned int __fastcall sub_482F8(unsigned int result, int a2, int a3)
{
  float v5; // s15
  unsigned __int8 *v6; // r4
  int v7; // r7
  int i; // r11
  int j; // r4
  int v10; // r9
  signed int v11; // r6
  int v12; // r0
  int v13; // r3
  int v14; // r0
  int *v15; // r2
  int *v16; // r0
  int v17; // r1
  int v18; // r3
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    v13 = 3000;
    if ( result < 0x64 )
      result = 100;
    if ( result < 0xBB8 )
      v13 = result;
    snprintf(s, 0x2000u, "inc freq delay:%d", v13);
    result = sub_41DB8(4, s, 0);
  }
  if ( dword_BC898[0] != 2 )
  {
    v5 = flt_BC5C4;
    goto LABEL_4;
  }
  v6 = (unsigned __int8 *)&unk_4D53A0;
  v7 = 0;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      if ( v6[1024] )
      {
        v7 = v6[1024];
        memcpy((char *)&unk_54F3D0 + 1024 * i, v6, 0x400u);
      }
      else
      {
        v14 = sub_27D1C();
        if ( v14 > 0 )
        {
          v15 = (int *)((char *)&unk_54F3D0 + 1024 * i);
          v16 = (int *)((char *)&unk_54F3D0 + 1024 * i + 4 * v14);
          v17 = dword_4D41A4[i];
          do
            *v15++ = v17;
          while ( v15 != v16 );
        }
      }
    }
    v6 += 1036;
  }
  for ( j = 0; j != 4; ++j )
  {
    result = sub_27EC8(j);
    if ( result && dword_4D41A4[0] != dword_4D41A4[j] )
      v7 = 1;
  }
  v5 = flt_BC5C4;
  if ( flt_BC5C4 > 0.0 )
  {
    if ( !v7 )
    {
      v10 = dword_4D4180;
      v11 = dword_4D4180 - dword_BC8A0;
      if ( dword_4D4180 - dword_BC8A0 > 200 )
      {
        v12 = sub_2242C();
        v18 = dword_4D419C + dword_4D41BC;
        if ( dword_4D419C + dword_4D41BC >= 2150 )
          v18 = 2150;
      }
      else
      {
        v12 = sub_2242C();
        v11 = v10;
        if ( v10 == 50 )
        {
          do
          {
            result = sub_27EC8(v7);
            if ( result )
              result = sub_24974(v7, (unsigned __int8)byte_4D4184, 50);
            ++v7;
          }
          while ( v7 != 4 );
          goto LABEL_23;
        }
        v18 = dword_4D419C + dword_4D41BC;
        if ( dword_4D419C + dword_4D41BC >= 2150 )
          v18 = 2150;
      }
      result = sub_24DC4(50, v11, v12, v18, 0);
LABEL_23:
      v5 = flt_BC5C4;
      goto LABEL_4;
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "enter mixed freq mode\n");
      sub_41DB8(3, s, 0);
    }
    dword_AB59A8 = -1;
    dword_AB59AC = -1;
    dword_AB59B0 = -1;
    dword_AB59B4 = -1;
    dword_AB59B8 = 0;
    dword_AB59BC = 0;
    dword_AB59C0 = 0;
    dword_AB59C4 = 0;
    dword_AB7A18 = 0;
    dword_AB7A1C = 0;
    dword_AB7A20 = 0;
    dword_AB7A24 = 0;
    sub_23328(
      (int)&unk_54F3D0,
      (unsigned int *)&dword_AB59A8,
      (unsigned int *)&dword_AB59B8,
      &dword_AB7A18,
      (int)&unk_4D4398,
      &dword_4D41B8,
      &dword_4D41B4);
    result = sub_2565C(&dword_AB7A18, a2, a3);
    v5 = flt_BC5C4;
  }
LABEL_4:
  byte_BDC88 = 1;
  if ( v5 <= 0.0 )
  {
    result = sub_246E8((int)&unk_54F3D0, (unsigned __int8)byte_4D4184, 1);
    dword_4D4180 = result;
  }
  return result;
}
// BC5C4: using guessed type float flt_BC5C4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898[];
// BC8A0: using guessed type int dword_BC8A0;
// BDC88: using guessed type char byte_BDC88;
// 4D4180: using guessed type int dword_4D4180;
// 4D4184: using guessed type char byte_4D4184;
// 4D419C: using guessed type int dword_4D419C;
// 4D41A4: using guessed type int dword_4D41A4[4];
// 4D41B4: using guessed type unsigned int dword_4D41B4;
// 4D41B8: using guessed type unsigned int dword_4D41B8;
// 4D41BC: using guessed type int dword_4D41BC;
// AB59A8: using guessed type int dword_AB59A8;
// AB59AC: using guessed type int dword_AB59AC;
// AB59B0: using guessed type int dword_AB59B0;
// AB59B4: using guessed type int dword_AB59B4;
// AB59B8: using guessed type int dword_AB59B8;
// AB59BC: using guessed type int dword_AB59BC;
// AB59C0: using guessed type int dword_AB59C0;
// AB59C4: using guessed type int dword_AB59C4;
// AB7A18: using guessed type int dword_AB7A18;
// AB7A1C: using guessed type int dword_AB7A1C;
// AB7A20: using guessed type int dword_AB7A20;
// AB7A24: using guessed type int dword_AB7A24;

//----- (00048690) --------------------------------------------------------
int __fastcall sub_48690(int result, int a2, int a3)
{
  int v3; // r5
  int v6; // r0
  int v7; // r9
  unsigned int v8; // r10
  unsigned int v9; // r0
  int i; // r2
  unsigned int v11; // r1
  unsigned __int64 v12; // r0
  __int64 v13; // r0
  double v14; // r0
  unsigned int v15; // r9
  int v16; // r0
  int v17; // r6
  unsigned int v18; // r1
  unsigned int v19; // r10
  unsigned int v20; // r0
  int k; // r2
  unsigned int v22; // r1
  __int64 v23; // r0
  __int64 v24; // r0
  double v25; // r0
  int v26; // r6
  unsigned int v27; // r1
  unsigned int v28; // r1
  int v29; // r0
  int v30; // r1
  unsigned __int64 v31; // r10
  unsigned int v32; // r0
  unsigned __int64 v33; // r2
  unsigned __int64 v34; // r0
  unsigned int v35; // r12
  int v36; // lr
  bool v37; // cf
  __int64 v38; // r0
  double v39; // r0
  unsigned int v40; // r0
  unsigned int j; // r3
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v3 = result;
  if ( result && (result = sub_27D8C()) != 0 && (result = sub_27D4C()) != 0 )
  {
    v6 = sub_27D8C();
    v7 = v6 << 24;
    v8 = (unsigned __int64)v6 >> 8;
    v9 = sub_27D5C();
    if ( v9 )
    {
      if ( v9 != 1 )
      {
        for ( i = 1; i < v9; i *= 2 )
          ;
        v7 = sub_96DFC(__PAIR64__(v8, v7), i);
        v8 = v11;
      }
    }
    else
    {
      v7 = sub_96DFC(__PAIR64__(v8, v7), 0);
      v8 = v28;
    }
    LODWORD(v12) = sub_96DFC(a2 * (__int64)a3 * __PAIR64__(v8, v7), 0x64u);
    LODWORD(v13) = sub_96DFC(v12, v3);
    LODWORD(v14) = sub_96AD4(v13);
    v15 = (unsigned int)(v14 * 0.4);
    dword_AB7A2C = v15;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v40 = sub_27D5C();
      if ( v40 < 2 )
      {
        j = v40;
      }
      else
      {
        for ( j = 1; j < v40; j *= 2 )
          ;
      }
      snprintf(s, 0x2000u, "calculate_core_number(topol_get_asic_small_core_num()):%d, mid_num:%d", j, a2);
      sub_41DB8(3, s, 0);
    }
    v16 = sub_27D1C();
    v17 = sub_96DFC(0x100000000uLL, v16);
    v19 = v18;
    v20 = sub_27D4C();
    if ( v20 )
    {
      if ( v20 != 1 )
      {
        for ( k = 1; k < v20; k *= 2 )
          ;
        v17 = sub_96DFC(__PAIR64__(v19, v17), k);
        v19 = v22;
      }
    }
    else
    {
      v17 = sub_96DFC(__PAIR64__(v19, v17), 0);
      v19 = v27;
    }
    LODWORD(v23) = 2 * v17;
    HIDWORD(v23) = v19 + __CFADD__(v17, v17) + v19;
    LODWORD(v24) = sub_96DFC(8 * (v23 + __PAIR64__(v19, v17)) + __PAIR64__(v19, v17), v3);
    LODWORD(v25) = sub_96AD4(v24);
    if ( v25 * 0.8 * 0.5 - 800.0 >= 2800.0 )
    {
      v29 = sub_27D1C();
      LODWORD(v31) = sub_96DFC(0x100000000uLL, v29);
      HIDWORD(v31) = v30;
      v32 = sub_27D4C();
      if ( v32 )
      {
        LODWORD(v33) = 1;
        if ( v32 == 1 )
        {
          HIDWORD(v33) = 0;
        }
        else
        {
          do
            LODWORD(v33) = 2 * v33;
          while ( v32 > (unsigned int)v33 );
          v33 = (int)v33;
        }
      }
      else
      {
        v33 = 0;
      }
      LODWORD(v34) = sub_96DFC(v31, v33);
      v35 = 3 * v34;
      v36 = 8 * ((3 * v34) >> 32);
      v37 = __CFADD__(24 * v34, (_DWORD)v34);
      LODWORD(v34) = 25 * v34;
      HIDWORD(v34) += v37 + (v36 | (v35 >> 29));
      LODWORD(v38) = sub_96DFC(v34, v3);
      LODWORD(v39) = sub_96AD4(v38);
      v26 = (unsigned int)(v39 * 0.8 * 0.5 - 800.0);
    }
    else
    {
      v26 = 2800;
    }
    if ( (byte_AB79EC & 4) != 0 && word_AB79FA )
      dword_AB7A2C = HIBYTE(word_AB79FA) + 1000 * (unsigned __int8)word_AB79FA;
    sub_2A894(v26);
    result = sub_633D4(v15);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "freq = %d, percent = %d, hcn = %d, timeout = %d\n", v3, a3, v26, v15);
      return sub_41DB8(3, s, 0);
    }
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "Note: addrInterval or corenum is not initialized.\n");
      result = sub_41DB8(3, s, 0);
    }
    dword_AB7A2C = (int)&loc_1FFFC + 3;
  }
  return result;
}
// 48788: variable 'v11' is possibly undefined
// 487D0: variable 'v12' is possibly undefined
// 487D4: variable 'v13' is possibly undefined
// 487E4: variable 'v14' is possibly undefined
// 48818: variable 'v18' is possibly undefined
// 48854: variable 'v22' is possibly undefined
// 48884: variable 'v24' is possibly undefined
// 48898: variable 'v25' is possibly undefined
// 48994: variable 'v30' is possibly undefined
// 48950: variable 'v27' is possibly undefined
// 48970: variable 'v28' is possibly undefined
// 489E8: variable 'v34' is possibly undefined
// 48A04: variable 'v38' is possibly undefined
// 48A18: variable 'v39' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// AB79EC: using guessed type char byte_AB79EC;
// AB79FA: using guessed type __int16 word_AB79FA;
// AB7A2C: using guessed type int dword_AB7A2C;

//----- (00048AA8) --------------------------------------------------------
void *sub_48AA8()
{
  void *result; // r0

  result = off_BC5EC;
  dword_BC898[0] = 2;
  byte_4D41C0 = 1;
  if ( (unsigned int)off_BC5EC > 3 )
    return (void *)sub_46F2C();
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898[];
// 4D41C0: using guessed type char byte_4D41C0;

//----- (00048AE0) --------------------------------------------------------
int sub_48AE0()
{
  int i; // r4
  int result; // r0
  int v2; // r0
  int v3; // r0
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result && (unsigned int)off_BC5EC > 3 )
    {
      v2 = sub_1BEA4(i);
      snprintf(s, 0x2000u, "Chain [%d] PCB Version: 0x%04x\n", i, v2);
      sub_41DB8(3, s, 0);
      result = i;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        v3 = sub_1BF3C(i);
        snprintf(s, 0x2000u, "Chain [%d] BOM Version: 0x%04x\n", i, v3);
        result = sub_41DB8(3, s, 0);
      }
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00048BAC) --------------------------------------------------------
int sub_48BAC()
{
  int result; // r0
  unsigned int v1; // r3
  _DWORD *v2; // r6
  unsigned int v3; // r7
  _DWORD *v4; // r5
  unsigned int v5; // r4
  int v6; // t1
  int v7; // r4
  unsigned int v8; // r0
  int v9; // r2
  int v10; // r5
  int v11; // r1
  int v12; // r3
  _DWORD *v13; // r12
  int v14; // lr
  _DWORD s[74]; // [sp+4h] [bp-128h] BYREF

  sub_59E5C(s);
  if ( sub_29C30() )
  {
    v7 = sub_29C40();
    if ( v7 )
    {
      memset(s, 0, 0x124u);
      v8 = sub_29CC0();
      if ( v8 )
      {
        v9 = s[0];
        v10 = 0;
        v11 = 0;
        do
        {
          v12 = 9 * v9;
          v13 = &s[18 * v9 + 73];
          if ( (v8 & 1) != 0 )
          {
            v14 = *(v13 - 71);
            ++v9;
            *(v13 - 72) = v11;
            v10 = v7;
            *(v13 - 71) = v14 + 1;
            s[2 * v12 + 3 + v14] = v11;
          }
          v8 >>= 1;
          ++v11;
        }
        while ( v8 );
        if ( v10 )
          s[0] = v9;
      }
    }
  }
  result = sub_464F0((int)s);
  v1 = s[0];
  if ( s[0] )
  {
    v2 = s;
    v3 = 0;
    do
    {
      if ( v2[2] )
      {
        v4 = v2 + 2;
        v5 = 0;
        do
        {
          v6 = v4[1];
          ++v4;
          result = sub_27E2C(v6, 1);
          ++v5;
        }
        while ( v2[2] > v5 );
        v1 = s[0];
      }
      ++v3;
      v2 += 18;
    }
    while ( v1 > v3 );
  }
  return result;
}

//----- (00048CB8) --------------------------------------------------------
int sub_48CB8()
{
  sub_5EA88();
  return sub_5EB00();
}

//----- (00048CC8) --------------------------------------------------------
int sub_48CC8()
{
  int result; // r0
  int v1; // r3
  int v2; // r3
  int v3; // r3
  int v4; // r3

  result = sub_509B0();
  if ( dword_BC898[0] )
  {
    switch ( dword_4D4188 )
    {
      case 0:
      case 1:
        return result;
      case 2:
        goto LABEL_9;
      case 21:
        goto LABEL_13;
      default:
        v4 = (unsigned __int8)byte_BC8A8 ^ 1;
        byte_BC8A8 ^= 1u;
        if ( v4 )
          goto LABEL_13;
        sub_5EAA8();
        return sub_5EB20();
    }
  }
  if ( !result )
  {
LABEL_13:
    sub_5EA88();
    return sub_5EB20();
  }
  if ( result != 1 )
  {
LABEL_9:
    sub_5EAA8();
    v3 = (unsigned __int8)byte_BC8A8 ^ 1;
    byte_BC8A8 ^= 1u;
    if ( v3 )
      return sub_5EB00();
    return sub_5EB20();
  }
  v1 = (unsigned __int8)byte_BC8A8 ^ 1;
  byte_BC8A8 ^= 1u;
  if ( v1 )
    sub_5EA88();
  else
    sub_5EAA8();
  v2 = (unsigned __int8)byte_BC8A8 ^ 1;
  byte_BC8A8 ^= 1u;
  if ( !v2 )
    return sub_5EB20();
  return sub_5EB00();
}
// 48D3C: control flows out of bounds to 48D40
// BC898: using guessed type int dword_BC898[];
// BC8A8: using guessed type char byte_BC8A8;
// 4D4188: using guessed type int dword_4D4188;

//----- (00048DF4) --------------------------------------------------------
char *__fastcall sub_48DF4(int a1)
{
  double v1; // d0
  char *result; // r0
  int v3; // r4
  double *v4; // r6
  double v5; // d8
  int v6; // r10
  int *v7; // r7
  bool v8; // cc
  int *v9; // r3
  int v10; // r1
  signed __int64 v11; // r0
  double v12; // d9
  __int64 v13; // r0
  __int64 v14; // r2
  __int64 v15; // r0
  int v16; // r4
  unsigned int v17; // r10
  unsigned int v18; // r9
  float v19; // s16
  int v20; // s17
  int v21; // r3
  signed __int64 v22; // [sp+10h] [bp-4024h]
  _BYTE *v23; // [sp+10h] [bp-4024h]
  double *v24; // [sp+1Ch] [bp-4018h]
  int v25; // [sp+1Ch] [bp-4018h]
  char *format; // [sp+2Ch] [bp-4008h]
  _BYTE s[8192]; // [sp+30h] [bp-4004h] BYREF
  char v29[8196]; // [sp+2030h] [bp-2004h] BYREF

  result = (char *)memset(s, 0, sizeof(s));
  v3 = dword_4D41C4;
  if ( !dword_4D41C4 )
  {
    do
    {
      result = (char *)sub_27EC8(v3);
      if ( result )
      {
        result = (char *)sub_27D1C();
        if ( result )
        {
          v4 = (double *)&s[2048 * v3];
          v5 = 0.0;
          v6 = 0;
          format = result;
          v24 = v4;
          v7 = &dword_D17C4[256 * v3];
          v22 = 0;
          while ( 1 )
          {
            v8 = sub_27D1C() <= v6;
            v9 = &v7[v6];
            v10 = v6++;
            if ( v8 )
              break;
            v22 += v9[4];
            sub_257E0(v3, v10);
            v5 = v5 + v1;
            *v24++ = v1;
          }
          v11 = v22;
          v23 = &byte_C3F4C[256 * v3];
          v12 = v5 / (double)(int)format;
          LODWORD(v13) = sub_96D5C(v11, (int)format);
          LODWORD(v14) = 2 * v13;
          HIDWORD(v14) = HIDWORD(v13) + __CFSHL__(v13, 1) + HIDWORD(v13);
          v25 = v3;
          v15 = v14 + v13;
          v16 = 0;
          v17 = (unsigned __int64)(v15 / 4) >> 32;
          v18 = v15 / 4;
          while ( 1 )
          {
            result = (char *)sub_27D1C();
            v19 = 1.0;
            if ( (int)result <= v16 )
              break;
            if ( v12 != 0.0 )
            {
              v19 = *v4 / v12;
              if ( (unsigned int)off_BC5EC > 4 )
              {
                snprintf(v29, 0x2000u, "test avg_freq:%.f, freq:%.f", v21, v12, *(_DWORD *)v4, *((_DWORD *)v4 + 1));
                sub_41DB8(4, v29, 0);
              }
            }
            ++v4;
            if ( a1 )
            {
              v20 = v7[v16 + 4];
              if ( (float)v20 < (float)(COERCE_FLOAT(sub_96CE0(__SPAIR64__(v17, v18))) * v19) && !v23[v16] )
                ++dword_4D41C4;
            }
            ++v16;
          }
          v3 = v25;
        }
      }
      ++v3;
    }
    while ( v3 != 4 );
    if ( dword_4D41C4 <= 4 )
      dword_4D41C4 = 0;
  }
  return result;
}
// 48EE0: variable 'v1' is possibly undefined
// 48F48: variable 'v13' is possibly undefined
// 49034: variable 'v21' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C3F4C: using guessed type _BYTE byte_C3F4C[1024];
// D17C4: using guessed type int dword_D17C4[3];
// 4D41C4: using guessed type int dword_4D41C4;

//----- (00049058) --------------------------------------------------------
int sub_49058()
{
  unsigned int v0; // r5
  int result; // r0
  unsigned int v2; // r4

  v0 = 0;
  memset(byte_66A3AC, 0, sizeof(byte_66A3AC));
  memset(byte_6682F8, 0, 0x2000u);
  memset(byte_6662B0, 0, sizeof(byte_6662B0));
  sub_46750(byte_66A3AC, 10);
  sub_46750(byte_6682F8, 30);
  sub_46750(byte_6662B0, 60);
  result = sub_27EC8(0);
  if ( result )
    goto LABEL_4;
  while ( ++v0 != 4 )
  {
    result = sub_27EC8(v0);
    if ( result )
    {
LABEL_4:
      v2 = 0;
      while ( sub_27D1C() > v2++ )
        sub_27D2C();
      result = sub_28544(v0, (char *)&unk_65AAB8 + 512 * v0);
    }
  }
  return result;
}

//----- (000491EC) --------------------------------------------------------
int sub_491EC()
{
  return pthread_mutex_lock(&stru_4D41C8);
}
// 4D41C8: using guessed type pthread_mutex_t stru_4D41C8;

//----- (000491F8) --------------------------------------------------------
int sub_491F8()
{
  return pthread_mutex_unlock(&stru_4D41C8);
}
// 4D41C8: using guessed type pthread_mutex_t stru_4D41C8;

//----- (00049204) --------------------------------------------------------
char *sub_49204()
{
  double v0; // d0
  float v1; // s17
  float v2; // s16
  float v3; // s21
  int v4; // r4
  int i; // r10
  char *result; // r0
  int v7; // r5
  float v8; // s19
  float *v9; // r6
  float v10; // s18
  float v11; // s20
  float v12; // s17
  int v13; // r4
  float v14; // s16
  bool v15; // cc
  int v16; // r1
  float v17; // s16
  size_t v18; // r0
  float v19; // s16
  int v20; // r4
  int v21; // r0
  _BYTE v22[96]; // [sp+28h] [bp-50E4h] BYREF
  char s[128]; // [sp+88h] [bp-5084h] BYREF
  char src[8184]; // [sp+108h] [bp-5004h] BYREF
  char v25[12292]; // [sp+2108h] [bp-3004h] BYREF

  memset(flt_BDCB0, 0, sizeof(flt_BDCB0));
  v1 = (float)sub_2242C() / 100.0;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v25, 0x2000u, "cur vol:%.2f ", v1);
    sub_41DB8(3, v25, 0);
  }
  v2 = v1 / (float)sub_27D0C();
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v25, 0x2000u, "cur expect big domain vol:%.2f ", v2);
    sub_41DB8(3, v25, 0);
    v3 = (float)(v2 * 0.25) * 3.0;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v25, 0x2000u, "cur expect big domain vol after check:%.2f ", v3);
      sub_41DB8(3, v25, 0);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v25, "start read asic vol");
        sub_41DB8(3, v25, 0);
      }
    }
  }
  else
  {
    v3 = (float)(v2 * 0.25) * 3.0;
  }
  sub_18260();
  v4 = 0;
  usleep((__useconds_t)sub_30D40);
  do
  {
    if ( sub_27EC8(v4) )
    {
      pthread_mutex_lock(&stru_4D41C8);
      sub_2AB98((unsigned __int8)v4, 2u);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        v0 = *(float *)&v0;
        snprintf(v25, 0x2000u, "chain%d domain %d avg vol=%f ", v4, 2, v0);
        sub_41DB8(3, v25, 0);
      }
      pthread_mutex_unlock(&stru_4D41C8);
    }
    ++v4;
  }
  while ( v4 != 4 );
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v25, "end read asic vol");
    sub_41DB8(3, v25, 0);
  }
  sub_18228();
  if ( (unsigned int)off_BC5EC > 3 )
  {
    v20 = sub_28744();
    v21 = sub_28758();
    snprintf(v25, 0x2000u, "row:%d col:%d", v20, v21);
    sub_41DB8(3, v25, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    result = (char *)sub_27EC8(i);
    if ( result )
    {
      v7 = 0;
      memset(s, 0, sizeof(s));
      memset(v25, 0, 0x3000u);
      snprintf(s, 0x80u, "\nchain[%d] domain[%d] asic voltage:\n", i, 2);
      v8 = -1000.0;
      strcat(v25, s);
      v9 = (float *)v22;
      memset(v22, 0, sizeof(v22));
      v10 = 1000.0;
      v11 = 0.0;
      if ( sub_28744() > 0 )
      {
        do
        {
          v12 = *v9;
          v13 = 0;
          while ( 1 )
          {
            v15 = sub_28758() <= v13;
            v16 = v13++;
            if ( v15 )
              break;
            v14 = flt_BDCB0[1024 * i - 2 + 4 * sub_2876C(v7, v16)];
            memset(src, 0, 0x80u);
            sprintf(src, "%.4f  ", v14);
            v12 = v12 + v14;
            strcat(v25, src);
            v11 = v11 + v14;
            if ( v8 < v14 )
              v8 = v14;
            if ( v10 > v14 )
              v10 = v14;
            *v9 = v12;
          }
          ++v7;
          v17 = v12 / (float)sub_28758();
          *v9++ = v17;
          memset(src, 0, 0x80u);
          sprintf(src, "    %.4f", v17);
          v18 = strlen(v25);
          *(_WORD *)stpcpy(&v25[v18], src) = 10;
        }
        while ( sub_28744() > v7 );
      }
      v19 = (float)sub_27D1C();
      memset(s, 0, sizeof(s));
      sprintf(
        s,
        "chain[%d] domain[%d] asic avg voltage:%.4f,min:%.4f,max:%.4f,expect:%.4f\n",
        i,
        2,
        (float)(v11 / v19),
        v10,
        v8,
        v3);
      result = strcat(v25, s);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(src, 0x2000u, v25);
        result = (char *)sub_41DB8(3, src, 0);
      }
    }
  }
  return result;
}
// 49578: variable 'v0' is possibly undefined
// 123D4: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 98278: using guessed type __int16 word_98278;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BDCB0: using guessed type float flt_BDCB0[4096];
// 4D41C8: using guessed type pthread_mutex_t stru_4D41C8;

//----- (00049744) --------------------------------------------------------
char *sub_49744()
{
  int v0; // r4
  int v1; // r10
  char *result; // r0
  int v3; // r5
  float v4; // s18
  float v5; // s17
  float v6; // s19
  int v7; // r4
  int v8; // r0
  float v9; // s16
  bool v10; // cc
  int v11; // r1
  float v12; // s16
  char s[128]; // [sp+20h] [bp-5084h] BYREF
  char src[4]; // [sp+A0h] [bp-5004h] BYREF
  int v15; // [sp+A4h] [bp-5000h]
  int v16; // [sp+A8h] [bp-4FFCh]
  int v17; // [sp+ACh] [bp-4FF8h]
  int v18; // [sp+B0h] [bp-4FF4h]
  int v19; // [sp+B4h] [bp-4FF0h]
  char v20; // [sp+B8h] [bp-4FECh]
  char v21[12292]; // [sp+20A0h] [bp-3004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v21, "start read asic temp");
    sub_41DB8(3, v21, 0);
  }
  sub_18260();
  v0 = 0;
  usleep((__useconds_t)sub_30D40);
  do
  {
    if ( sub_27EC8(v0) )
    {
      pthread_mutex_lock(&stru_4D41C8);
      sub_1759C(v0, 1, 0, 0, 0);
      pthread_mutex_unlock(&stru_4D41C8);
    }
    ++v0;
  }
  while ( v0 != 4 );
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v21, "end read asic temp");
    sub_41DB8(3, v21, 0);
  }
  v1 = 0;
  sub_18228();
  do
  {
    result = (char *)sub_27EC8(v1);
    if ( result )
    {
      v3 = 0;
      memset(v21, 0, 0x3000u);
      v4 = -1000.0;
      memset(s, 0, sizeof(s));
      snprintf(s, 0x40u, "\nchain[%d] asic temperature:\n", v1);
      strcat(v21, s);
      v5 = 1000.0;
      v6 = 0.0;
      if ( sub_28744() > 0 )
      {
        do
        {
          v7 = 0;
          while ( 1 )
          {
            v10 = sub_28758() <= v7;
            v11 = v7++;
            if ( v10 )
              break;
            v8 = sub_2876C(v3, v11);
            *(_DWORD *)src = 0;
            v9 = flt_D07C4[256 * v1 - 1 + v8];
            v15 = 0;
            v16 = 0;
            v17 = 0;
            v18 = 0;
            v19 = 0;
            v20 = 0;
            sprintf(src, "%.2f ", v9);
            strcat(v21, src);
            v6 = v6 + v9;
            if ( v4 < v9 )
              v4 = v9;
            if ( v5 > v9 )
              v5 = v9;
          }
          ++v3;
          *(_WORD *)&v21[strlen(v21)] = 10;
        }
        while ( sub_28744() > v3 );
      }
      v12 = (float)sub_27D1C();
      memset(s, 0, sizeof(s));
      sprintf(s, "chain%d avg temperature = %.2f,min:%.2f,max:%.2f\n", v1, (float)(v6 / v12), v5, v4);
      result = strcat(v21, s);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(src, 0x2000u, v21);
        result = (char *)sub_41DB8(3, src, 0);
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  return result;
}
// 98278: using guessed type __int16 word_98278;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// D07C4: using guessed type float flt_D07C4[1023];
// 4D41C8: using guessed type pthread_mutex_t stru_4D41C8;

//----- (00049A60) --------------------------------------------------------
int sub_49A60()
{
  return (unsigned __int8)byte_4D41E0;
}
// 4D41E0: using guessed type char byte_4D41E0;

//----- (00049A70) --------------------------------------------------------
int sub_49A70()
{
  int v0; // r0
  int v1; // r5
  int v2; // r4
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  sub_63228(byte_AB7A30, 0x20u);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "miner ID : %s\n", byte_AB7A30);
    sub_41DB8(3, s, 0);
  }
  v0 = sub_647B8();
  v1 = BYTE2(v0);
  v2 = (unsigned __int8)v0;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "FPGA Version = 0x%04X\n", (unsigned __int16)v0);
    sub_41DB8(3, s, 0);
  }
  return sprintf(byte_C3544, "%d.%d.%d.%d", v2, v1, 1, 3);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00049B48) --------------------------------------------------------
time_t sub_49B48()
{
  time_t result; // r0

  sub_4465C(dword_4D41E4);
  result = sub_3B468();
  byte_4D41EC = 1;
  return result;
}
// 4D41E4: using guessed type __time_t dword_4D41E4[2];
// 4D41EC: using guessed type char byte_4D41EC;

//----- (00049B6C) --------------------------------------------------------
size_t __fastcall sub_49B6C(_DWORD *a1, int a2, int a3)
{
  bool v4; // lr
  int v5; // r2
  int v6; // r3
  int v7; // r0
  char *v8; // r9
  size_t v9; // r4
  size_t v10; // r2
  int v11; // r1
  __int64 v12; // r6
  int v13; // r10
  size_t v14; // r11
  char *v15; // r6
  _DWORD **v16; // lr
  char *v17; // r4
  _DWORD **v18; // r3
  _DWORD *v19; // t1
  int v20; // r12
  int v21; // r0
  int v22; // r1
  int v23; // r12
  int v24; // r0
  int v25; // r1
  __int16 v26; // r0
  __int64 v27; // kr00_8
  void *v28; // r0
  __int64 src; // [sp+8h] [bp-206Ch] BYREF
  _DWORD v32[24]; // [sp+10h] [bp-2064h] BYREF
  char v33[8196]; // [sp+70h] [bp-2004h] BYREF

  v4 = dword_BC8AC != a3;
  dword_BC8AC = a3;
  v32[3] = a3;
  BYTE1(v32[2]) = BYTE1(v32[2]) & 0xFE | v4 | 2;
  LOWORD(v32[0]) = 82;
  LOBYTE(v32[2]) = qword_4D41F0;
  BYTE2(v32[2]) = 15;
  src = 0;
  if ( byte_4D41F8 )
  {
    v5 = *(_DWORD *)(a2 + 664);
    v6 = *(_DWORD *)(a2 + 668);
    LOBYTE(v32[20]) = *(_BYTE *)(a2 + 660);
    v32[21] = v5;
    v32[22] = v6;
  }
  sub_43ADC(&v32[4], (unsigned __int8 *)(a2 + 1796), 4);
  sub_43ADC(&v32[5], (unsigned __int8 *)(a2 + 1728), 32);
  sub_43ADC(&v32[14], (unsigned __int8 *)(a2 + 1808), 4);
  sub_43ADC(&v32[13], (unsigned __int8 *)(a2 + 1820), 4);
  v7 = *(_DWORD *)(a2 + 1592);
  v8 = *(char **)(a2 + 1584);
  v9 = *(_DWORD *)(a2 + 1588);
  v10 = *(_DWORD *)(a2 + 648);
  HIWORD(v32[15]) = v7;
  LOWORD(v32[15]) = v9;
  LOWORD(v32[16]) = v10;
  v11 = *(_DWORD *)&v8[v7 + 4];
  v12 = *(_QWORD *)(a2 + 640);
  v32[18] = *(_DWORD *)&v8[v7];
  v32[19] = v11;
  src = v12;
  memcpy(&v32[18], &src, v10);
  v13 = *(_DWORD *)(a2 + 1724);
  HIWORD(v32[16]) = v13;
  v14 = v9 + 32 * v13;
  v15 = (char *)malloc(v14 + 98);
  if ( !v15 )
  {
    strcpy(v33, "Failed to malloc tmp_buf");
    sub_41DB8(3, v33, 1);
    nullsub_1(1);
    v13 = *(_DWORD *)(a2 + 1724);
    v8 = *(char **)(a2 + 1584);
    v9 = *(_DWORD *)(a2 + 1588);
  }
  v32[1] = v14 + 90;
  memset(v15, 0, v14 + 98);
  memcpy(v15, v32, 0x60u);
  memcpy(v15 + 96, v8, v9);
  if ( v13 > 0 )
  {
    v16 = *(_DWORD ***)(a2 + 692);
    v17 = &v15[v9 + 96];
    v18 = &v16[v13];
    do
    {
      v19 = *v16++;
      v17 += 32;
      v20 = v19[1];
      v21 = v19[2];
      v22 = v19[3];
      *((_DWORD *)v17 - 8) = *v19;
      *((_DWORD *)v17 - 7) = v20;
      *((_DWORD *)v17 - 6) = v21;
      *((_DWORD *)v17 - 5) = v22;
      v23 = v19[5];
      v24 = v19[6];
      v25 = v19[7];
      *((_DWORD *)v17 - 4) = v19[4];
      *((_DWORD *)v17 - 3) = v23;
      *((_DWORD *)v17 - 2) = v24;
      *((_DWORD *)v17 - 1) = v25;
    }
    while ( v16 != v18 );
  }
  v26 = sub_4596C((int)v15, (unsigned __int16)(v14 + 96));
  v27 = qword_4D41F0;
  *(_WORD *)&v15[v14 + 96] = v26;
  qword_4D41F0 = v27 + 1;
  v28 = malloc(v14 + 98);
  *a1 = v28;
  memcpy(v28, v15, v14 + 98);
  free(v15);
  return v14 + 98;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);
// BC8AC: using guessed type int dword_BC8AC;
// 4D41F0: using guessed type __int64 qword_4D41F0;
// 4D41F8: using guessed type char byte_4D41F8;

//----- (00049E00) --------------------------------------------------------
int __fastcall sub_49E00(unsigned __int8 *a1)
{
  int v3; // r7
  size_t v4; // r6
  _DWORD *v5; // r0
  _DWORD *v6; // r7
  int v7; // r2
  int v8; // r3
  int v9; // r3
  char v10; // r2
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r0
  int v15; // r2
  int v16; // r3
  int v17; // lr
  int v18; // r0
  __int64 v19; // r2
  int v20; // r0
  int v21; // r0
  _DWORD v22[16]; // [sp+10h] [bp-2054h] BYREF
  __int64 v23; // [sp+50h] [bp-2014h]
  int v24; // [sp+58h] [bp-200Ch]
  int v25; // [sp+5Ch] [bp-2008h]
  char s[8196]; // [sp+60h] [bp-2004h] BYREF

  if ( *a1 == 82 )
  {
    v3 = *((_DWORD *)a1 + 1);
    if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      snprintf(s, 0x2000u, "%s: len = 0x%x\n", "dhash_chip_send_job", *((_DWORD *)a1 + 1));
      sub_41DB8(7, s, 0);
    }
    v4 = v3 + 8;
    v5 = calloc(v3 + 8, 1u);
    v6 = v5;
    if ( v5 )
    {
      memcpy(v5, a1, v4);
      if ( byte_4D41F8 )
      {
        v7 = *((unsigned __int8 *)v6 + 80);
        if ( *((_BYTE *)v6 + 80) )
        {
          v8 = v6[21];
          v7 = v6[22];
          dword_BC5A4 = v8;
        }
        else
        {
          v8 = 1;
          dword_BC5A4 = 1;
        }
        dword_C3504 = v7;
        if ( dword_BC8B0 != v8 )
        {
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "Version num %d\n", v8);
            sub_41DB8(3, s, 0);
            v8 = dword_BC5A4;
          }
          dword_BC8B0 = v8;
        }
        v9 = dword_C3504;
        if ( dword_BC8B4 != dword_C3504 )
        {
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "Mask num 0x%x\n", dword_C3504);
            sub_41DB8(3, s, 0);
            v9 = dword_C3504;
          }
          dword_BC8B4 = v9;
          sub_48690(dword_4D4180, dword_BC5A4, 90);
          sub_630A4();
          sub_2A05C((unsigned int)dword_C3504 >> 13);
        }
        v10 = *((_BYTE *)v6 + 9);
        if ( (v10 & 2) != 0 )
        {
          sub_63698(*((unsigned __int8 *)v6 + 10));
          v10 = *((_BYTE *)v6 + 9);
        }
        v11 = *((unsigned __int16 *)v6 + 30);
        v25 = v10 & 1;
        v12 = v6[3];
        v22[4] = &a1[v11 + 96];
        v13 = *((unsigned __int16 *)v6 + 33);
        v24 = dword_AB7A2C;
        v22[8] = v12;
        v14 = v6[14];
        v15 = *((unsigned __int16 *)v6 + 32);
        v22[5] = v13;
        v16 = *((unsigned __int16 *)v6 + 31);
        v22[10] = dword_C3504;
        v22[7] = v14;
        v17 = v6[4];
        v18 = v6[13];
        v22[14] = v15;
        v22[13] = v16;
        v19 = *((_QWORD *)v6 + 9);
        v22[1] = dword_BC5A4;
        v22[3] = v11;
        v22[2] = a1 + 96;
        v22[9] = v17;
        v22[6] = v18;
        v22[11] = v6 + 5;
        v23 = v19;
        v22[12] = 32;
        v22[0] = 1;
        if ( !byte_4D41F9 )
        {
          v20 = sub_63E74();
          sub_63EA0(v20 | 0x10000);
          v21 = sub_62EC4();
          sub_62EF8(v21 | 0x80);
          byte_4D41F9 = 1;
        }
        if ( (unsigned int)off_BC5EC > 4 )
        {
          snprintf(s, 0x2000u, "start to send job, mid_auto_gen = %d", v22[0]);
          sub_41DB8(4, s, 0);
        }
        sub_625D8((int)v22);
        free(v6);
        if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
        {
          snprintf(s, 0x2000u, "--- %s end\n", "dhash_chip_send_job");
          sub_41DB8(7, s, 0);
        }
        sub_4465C(dword_4D41E4);
        sub_44890();
        return 0;
      }
      else
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, "only support asic boost");
          sub_41DB8(3, s, (unsigned __int8)byte_4D41F8);
        }
        free(v6);
        return 0;
      }
    }
    else if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
    {
      snprintf(s, 0x2000u, "%s: malloc buffer failed.\n", "dhash_chip_send_job");
      sub_41DB8(7, s, 0);
      return -2;
    }
    else
    {
      return -2;
    }
  }
  else if ( byte_4D4172 && (byte_6682BC || byte_4D4171 || dword_BC5F4 > 6) )
  {
    snprintf(s, 0x2000u, "%s: SEND_JOB_TYPE is wrong : 0x%x\n", "dhash_chip_send_job", *a1);
    sub_41DB8(7, s, 0);
    return -1;
  }
  else
  {
    return -1;
  }
}
// BC5A4: using guessed type int dword_BC5A4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC5F4: using guessed type int dword_BC5F4;
// BC8B0: using guessed type int dword_BC8B0;
// BC8B4: using guessed type int dword_BC8B4;
// C3504: using guessed type int dword_C3504;
// 4D4171: using guessed type char byte_4D4171;
// 4D4172: using guessed type char byte_4D4172;
// 4D4180: using guessed type int dword_4D4180;
// 4D41E4: using guessed type __time_t dword_4D41E4[2];
// 4D41F8: using guessed type char byte_4D41F8;
// 4D41F9: using guessed type char byte_4D41F9;
// 6682BC: using guessed type char byte_6682BC;
// AB7A2C: using guessed type int dword_AB7A2C;

//----- (0004A32C) --------------------------------------------------------
unsigned int sub_4A32C()
{
  sub_631A4();
  sub_642D8(15);
  return sleep(2u);
}

//----- (0004A348) --------------------------------------------------------
int __fastcall sub_4A348(int result, int a2)
{
  pthread_mutex_t *v2; // r8
  int v3; // r4
  int v5; // r7
  size_t v6; // r5
  void *v7; // r0
  int v8; // r5
  void *v9; // r0
  int v10; // lr
  int v11; // r12
  _DWORD *v12; // r11
  int v13; // r5
  int v14; // r10
  _DWORD *v15; // r3
  _DWORD *v16; // r2
  int v17; // r12
  int v18; // r0
  int v19; // r1
  int v20; // r12
  int v21; // r0
  int v22; // r1
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  char s[8232]; // [sp+10h] [bp-2028h] BYREF

  if ( *(_DWORD *)(a2 + 688) )
  {
    v2 = (pthread_mutex_t *)(result + 212);
    v3 = result;
    v5 = *(_DWORD *)(a2 + 1724);
    v6 = *(_DWORD *)(a2 + 1588);
    if ( pthread_mutex_lock((pthread_mutex_t *)(result + 212)) )
    {
      v24 = _errno_location();
      snprintf(
        s,
        0x2000u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v24,
        "driver-btm-api.c",
        "copy_pool_stratum",
        2502);
      sub_41DB8(3, s, 1);
      nullsub_1(1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 236)) )
    {
      v25 = _errno_location();
      snprintf(
        s,
        0x2000u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v25,
        "driver-btm-api.c",
        "copy_pool_stratum",
        2502);
      sub_41DB8(3, s, 1);
      nullsub_1(1);
    }
    free(*(void **)(v3 + 688));
    free(*(void **)(v3 + 628));
    free(*(void **)(v3 + 1584));
    if ( (v6 & 3) != 0 )
      v6 = (v6 & 0xFFFFFFFC) + 4;
    v7 = calloc(v6, 1u);
    *(_DWORD *)(v3 + 1584) = v7;
    if ( !v7 )
    {
      strcpy(s, "Failed to calloc pool_stratum coinbase in c5");
      sub_41DB8(3, s, 1);
      nullsub_1(1);
      v7 = *(void **)(v3 + 1584);
    }
    memcpy(v7, *(const void **)(a2 + 1584), v6);
    if ( *(int *)(v3 + 1724) > 0 )
    {
      v8 = 0;
      do
      {
        v9 = *(void **)(*(_DWORD *)(v3 + 692) + 4 * v8++);
        free(v9);
      }
      while ( *(_DWORD *)(v3 + 1724) > v8 );
    }
    if ( v5 )
    {
      v12 = realloc(*(void **)(v3 + 692), 4 * v5 + 1);
      *(_DWORD *)(v3 + 692) = v12;
      if ( v5 > 0 )
      {
        v13 = 0;
        while ( 1 )
        {
          v14 = 4 * v13;
          v12[v13] = malloc(0x20u);
          v15 = *(_DWORD **)(*(_DWORD *)(v3 + 692) + 4 * v13);
          if ( !v15 )
          {
            strcpy(s, "Failed to malloc pool_stratum swork merkle_bin");
            sub_41DB8(3, s, 1);
            nullsub_1(1);
            v15 = *(_DWORD **)(*(_DWORD *)(v3 + 692) + 4 * v13);
          }
          ++v13;
          v16 = *(_DWORD **)(*(_DWORD *)(a2 + 692) + v14);
          v17 = v16[1];
          v18 = v16[2];
          v19 = v16[3];
          *v15 = *v16;
          v15[1] = v17;
          v15[2] = v18;
          v15[3] = v19;
          v20 = v16[5];
          v21 = v16[6];
          v22 = v16[7];
          v15[4] = v16[4];
          v15[5] = v20;
          v15[6] = v21;
          v15[7] = v22;
          if ( v5 == v13 )
            break;
          v12 = *(_DWORD **)(v3 + 692);
        }
      }
    }
    *(_DWORD *)v3 = *(_DWORD *)a2;
    *(_QWORD *)(v3 + 1840) = *(_QWORD *)(a2 + 1840);
    *(_DWORD *)(v3 + 1588) = *(_DWORD *)(a2 + 1588);
    *(_DWORD *)(v3 + 1592) = *(_DWORD *)(a2 + 1592);
    *(_DWORD *)(v3 + 648) = *(_DWORD *)(a2 + 648);
    *(_DWORD *)(v3 + 1724) = *(_DWORD *)(a2 + 1724);
    *(_DWORD *)(v3 + 688) = _strdup(*(const char **)(a2 + 688));
    *(_DWORD *)(v3 + 628) = _strdup(*(const char **)(a2 + 628));
    v10 = *(_DWORD *)(a2 + 1824);
    v11 = *(_DWORD *)(a2 + 1828);
    *(_DWORD *)(v3 + 1820) = *(_DWORD *)(a2 + 1820);
    *(_DWORD *)(v3 + 1824) = v10;
    *(_DWORD *)(v3 + 1828) = v11;
    memcpy((void *)(v3 + 1596), (const void *)(a2 + 1596), 0x80u);
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 236)) )
    {
      v26 = _errno_location();
      snprintf(
        s,
        0x2000u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v26,
        "driver-btm-api.c",
        "copy_pool_stratum",
        2540);
      sub_41DB8(3, s, 1);
      nullsub_1(1);
    }
    if ( pthread_mutex_unlock(v2) )
    {
      v23 = _errno_location();
      snprintf(
        s,
        0x2000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v23,
        "driver-btm-api.c",
        "copy_pool_stratum",
        2540);
      sub_41DB8(3, s, 1);
      nullsub_1(1);
    }
    return off_BC718();
  }
  return result;
}
// 3B464: using guessed type int __fastcall nullsub_1(_DWORD);
// BC718: using guessed type int (*off_BC718)();

//----- (0004A75C) --------------------------------------------------------
int __fastcall sub_4A75C(unsigned int a1)
{
  const char *v2; // r0
  const char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v2 = (const char *)sub_27CEC();
  if ( !strcmp(v2, "HHB68701")
    || (v4 = (const char *)sub_27CEC(), !strcmp(v4, "HHB68704"))
    || (v5 = (const char *)sub_27CEC(), !strcmp(v5, "HHB68703"))
    || (v6 = (const char *)sub_27CEC(), !strcmp(v6, "H6HB68702"))
    || (v7 = (const char *)sub_27CEC(), !strcmp(v7, "H1HB68601")) )
  {
    BYTE1(off_BC8B8) = 5;
  }
  else
  {
    v8 = (const char *)sub_27CEC();
    if ( !strcmp(v8, "HHB68502")
      || (v9 = (const char *)sub_27CEC(), !strcmp(v9, "HHB68501"))
      || (v10 = (const char *)sub_27CEC(), !strcmp(v10, "HHB68503")) )
    {
      BYTE1(off_BC8B8) = 4;
    }
    else
    {
      BYTE1(off_BC8B8) = dword_C3510;
    }
  }
  BYTE2(off_BC8B8) = dword_C3514;
  if ( a1 < (unsigned int)off_BC5EC )
  {
    snprintf(
      s,
      0x2000u,
      "pulse_mode = %d, ccdly_sel = %d, pwth_sel = %d\n",
      (unsigned __int8)off_BC8B8,
      (unsigned __int8)dword_C3514,
      BYTE1(off_BC8B8));
    sub_41DB8(a1, s, 0);
  }
  *(_WORD *)s = (_WORD)off_BC8B8;
  s[2] = BYTE2(off_BC8B8);
  return (unsigned __int8)off_BC8B8 | (unsigned __int16)(BYTE1(off_BC8B8) << 8) | (BYTE2(off_BC8B8) << 16);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC8B8: using guessed type _UNKNOWN *off_BC8B8;
// C3510: using guessed type int dword_C3510;
// C3514: using guessed type int dword_C3514;

//----- (0004A908) --------------------------------------------------------
int sub_4A908()
{
  int i; // r4
  int v1; // r4
  int v2; // r0
  int v4; // r7
  int v5; // r5
  int v6; // r6
  unsigned int v7; // r0
  int v8; // r1
  int v9; // r0
  __int16 v10; // [sp+4h] [bp-4h]
  char v11; // [sp+6h] [bp-2h]

  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
      sub_7FE84((unsigned __int8)i);
  }
  v1 = 0;
  v2 = sub_4A75C(3u);
  v11 = BYTE2(v2);
  v10 = v2;
  sub_29EB0();
  sub_44890();
  sub_2A364();
  sub_44890();
  sub_2A5DC(255, (unsigned __int8)v10);
  sub_44890();
  sub_2A628(255, SHIBYTE(v10), v11, 0);
  sub_44890();
  sub_2A014(0xFFu);
  sub_44890();
  sub_29F58(255, 0, 1, 3);
  sub_44890();
  sub_29FC4(255);
  sub_44890();
  sub_2A8E4(1);
  sub_46B08();
  do
  {
    if ( sub_27EC8(v1) )
    {
      v4 = sub_27D1C();
      if ( v4 )
      {
        v5 = 0;
        do
        {
          v6 = v5 + 1;
          v7 = sub_27D2C();
          sub_964FC(v5 + 1, v7);
          if ( !v8 )
          {
            v9 = sub_27D8C();
            sub_80FCC((unsigned __int8)v1, v5 * v9, 3);
          }
          ++v5;
        }
        while ( v4 != v6 );
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
  sub_44890();
  sub_2AA4C(255);
  return sub_44890();
}
// 4AA64: variable 'v8' is possibly undefined

//----- (0004AA80) --------------------------------------------------------
int sub_4AA80()
{
  const char *v0; // r0
  unsigned int v1; // r10
  int v2; // r5
  int v3; // r6
  int v4; // r4
  int v5; // r11
  int result; // r0
  bool v7; // cc
  int v8; // r2
  int v9; // r6
  const char *v10; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v0 = (const char *)sub_27CEC();
  if ( !strcmp(v0, "HHB68502") || (v10 = (const char *)sub_27CEC(), !strcmp(v10, "HHB68503")) )
    v1 = 56;
  else
    v1 = 51;
  v2 = 0;
  v3 = 5;
  while ( 1 )
  {
    v4 = sub_18EBC();
    v5 = sub_18F28();
    result = v4 - v5;
    if ( v4 - v5 <= 2 && v4 <= v1 )
      break;
    if ( v2 > 9 )
    {
      v7 = v4 <= 45;
      if ( v4 <= 45 )
        v7 = result <= 4;
      v8 = v7;
      if ( v7 )
        break;
      if ( v2 == 10 )
      {
        v9 = v8;
        sub_2CC78(1);
        sub_4FB28(9, 255);
        sub_473B4(0xFu, "Water is not flowing!");
        sub_44890();
        sub_2CC78(1);
        do
        {
          if ( sub_27EC8(v9) )
            sub_408E4((unsigned __int8)v9);
          ++v9;
        }
        while ( v9 != 4 );
        v3 = 60;
      }
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "water temp %d ~ %d, sleep %ds to cool down\n", v5, v4, v3);
      sub_41DB8(3, s, 0);
    }
    v2 += v3;
    sub_44890();
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "water temp %d ~ %d, stop.\n", v5, v4);
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0004AC40) --------------------------------------------------------
int sub_4AC40()
{
  void *v0; // r1
  int v1; // r6
  const char *v3; // r0
  int v4; // r0
  int v5; // r0
  int i; // r7
  int v7; // r0
  unsigned int v8; // r8
  int v9; // r0
  int v10; // r1
  size_t v11; // r0
  const char *v12; // r0
  int v13; // r9
  size_t v14; // r2
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  char *v25; // r0
  int v26; // r3
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  const char *v30; // r0
  const char *v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  const char *v34; // r0
  const char *v35; // r0
  const char *v36; // r0
  char v37[32]; // [sp+8h] [bp-2040h] BYREF
  char v38[32]; // [sp+28h] [bp-2020h] BYREF
  char s[8192]; // [sp+48h] [bp-2000h] BYREF

  v0 = off_BC5EC;
  dword_BC898 = 2;
  byte_4D41C0 = 1;
  if ( (unsigned int)off_BC5EC <= 3 || (sub_46F2C(), v0 = off_BC5EC, (unsigned int)off_BC5EC <= 3) )
  {
    if ( byte_C32F8 )
      goto LABEL_3;
  }
  else
  {
    snprintf(s, 0x2000u, "Miner compile time: %s type: %s\n", byte_C2FF8, dest);
    sub_41DB8(3, s, 0);
    v0 = off_BC5EC;
    if ( byte_C32F8 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_3;
      snprintf(s, 0x2000u, "Miner sn: %s\n", &byte_C32F8);
      sub_41DB8(3, s, 0);
      v0 = off_BC5EC;
    }
  }
  if ( (unsigned int)v0 > 3 )
  {
    strcpy(s, "commit version: 3c182d4d 2025-01-16 15:11:29, build by: jenkins 2025-04-16 10:21:34\n");
    sub_41DB8(3, s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "opt_multi_version     = %d\n", dword_BC5A4);
      sub_41DB8(3, s, 0);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "opt_bitmain_ab        = %d\n", (unsigned __int8)byte_BC5A8);
        sub_41DB8(3, s, 0);
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "mid_auto_gen          = %d\n", 1);
          sub_41DB8(3, s, 0);
          if ( (unsigned int)off_BC5EC > 3 )
          {
            snprintf(s, 0x2000u, "opt_bitmain_work_mode = %d\n", dword_C351C);
            sub_41DB8(3, s, 0);
            if ( sub_59CE4() )
              return 0;
            goto LABEL_16;
          }
        }
      }
    }
  }
LABEL_3:
  if ( sub_59CE4() )
    return 0;
LABEL_16:
  sub_5A0C4();
  sub_16C98();
  sub_16D68();
  sub_5EA88();
  sub_5EB00();
  byte_BC5A8 = 1;
  sub_31C4C();
  sub_34324();
  sub_28804();
  v1 = sub_276A8(1, "HHB68601");
  if ( v1 )
    return v1;
  sub_18310();
  sub_4A32C();
  sub_21D18();
  v3 = (const char *)sub_27CEC();
  if ( strcmp(v3, "HHB68502") )
  {
    v15 = (const char *)sub_27CEC();
    if ( strcmp(v15, "HHB68501") )
    {
      v16 = (const char *)sub_27CEC();
      if ( strcmp(v16, "HHB68701") )
      {
        v17 = (const char *)sub_27CEC();
        if ( strcmp(v17, "HHB68704") )
        {
          v18 = (const char *)sub_27CEC();
          if ( strcmp(v18, "HHB68703") )
          {
            v19 = (const char *)sub_27CEC();
            if ( strcmp(v19, "H6HB68702") )
            {
              v20 = (const char *)sub_27CEC();
              if ( strcmp(v20, "H1HB68601") )
              {
                v21 = (const char *)sub_27CEC();
                if ( strcmp(v21, "HHB68601") )
                {
                  v22 = (const char *)sub_27CEC();
                  if ( strcmp(v22, "HHB68602") )
                  {
                    v23 = (const char *)sub_27CEC();
                    if ( strcmp(v23, "HHB56611") )
                    {
                      v24 = (const char *)sub_27CEC();
                      if ( strcmp(v24, "HHB68503") )
                        sub_168B4(100);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  sub_49A70();
  sub_62208();
  sub_48BAC();
  if ( sub_2270C() && sub_27EB8() != 3 )
  {
    if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
    {
      v4 = sub_27EB8();
      snprintf(s, 0x2000u, "chain num = %d", v4);
      sub_41DB8(5, s, 0);
    }
    sub_4FB28(1, 255);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v1 = -1;
      strcpy(s, "No full chain exist, exit.\n");
      sub_41DB8(3, s, 0);
      return v1;
    }
    return -1;
  }
  if ( !sub_27EB8() )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v1 = -1;
      strcpy(s, "No chain exist, exit.\n");
      sub_41DB8(3, s, 0);
      return v1;
    }
    return -1;
  }
  if ( byte_6682BC || byte_4D4171 || dword_BC5F4 > 4 )
  {
    v5 = sub_27EB8();
    snprintf(s, 0x2000u, "chain num = %d", v5);
    sub_41DB8(5, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    v7 = i;
    v8 = (unsigned __int8)i;
    if ( sub_27EC8(v7) )
      sub_7E92C(v8);
  }
  v9 = sub_1B8F8();
  if ( v9 )
  {
    v10 = v9 <= 0 ? 255 : v9 >> 16;
    sub_4FB28(3, v10);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "Fixture data load failed, exit.\n");
      sub_41DB8(3, s, 0);
    }
  }
  memset(v37, 0, sizeof(v37));
  memset(v38, 0, sizeof(v38));
  do
  {
    if ( !sub_27EC8(v1) )
      goto LABEL_43;
    memset(v38, 0, sizeof(v38));
    v13 = sub_1D104(v1, (int)v38);
    if ( sub_29C30() && sub_29C50() )
    {
      v25 = sub_29CD0((unsigned __int8)v1);
      strncpy(v38, v25, 0x20u);
    }
    else if ( v13 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      v26 = v1;
      v1 = -1;
      snprintf(s, 0x2000u, "get board name failed for chain:%d\n", v26);
      sub_41DB8(3, s, 0);
      return v1;
    }
    if ( !strncmp(v38, "H1HB68601", 9u) )
    {
      v14 = 9;
      if ( !v37[0] )
        goto LABEL_83;
      if ( strncmp(v37, v38, 9u) )
      {
        if ( (unsigned int)off_BC5EC <= 3 )
          return -1;
        goto LABEL_65;
      }
    }
    else
    {
      v14 = 8;
      if ( !v37[0] )
      {
LABEL_83:
        strncpy(v37, v38, v14);
        goto LABEL_43;
      }
      if ( strncmp(v37, v38, 8u) )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
LABEL_65:
          snprintf(
            s,
            0x2000u,
            "get a different board name for chain:%d, pre board_name:%s, current board_name:%s\n",
            v1,
            v37,
            v38);
          v1 = -1;
          sub_41DB8(3, s, 0);
          return v1;
        }
        return -1;
      }
    }
LABEL_43:
    ++v1;
  }
  while ( v1 != 4 );
  v11 = strlen(v37);
  strncpy(byte_4D41FC, v37, v11);
  if ( !strcmp(v37, "HHB68701") || !strcmp(v37, "HHB68704") || !strcmp(v37, "HHB68703") || !strcmp(v37, "H6HB68702") )
  {
    strncpy(dest, "Antminer S19 XP+ Hyd.", 0x100u);
    sub_46BB8("S19 XP+ Hyd.");
  }
  else if ( !strcmp(v37, "H1HB68601") )
  {
    strncpy(dest, "Antminer U3S19XP+H", 0x100u);
    sub_46BB8("U3S19XP+H");
  }
  else
  {
    strncpy(dest, "Antminer S21 Hyd.", 0x100u);
    sub_46BB8("S21 Hyd.");
  }
  v1 = sub_276A8(0, v37);
  if ( v1 )
    return v1;
  v1 = sub_1AF60(v37);
  if ( v1 )
    return v1;
  if ( dword_C351C == 1 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "enter sleep mode.\n");
      sub_41DB8(3, s, 0);
    }
    sub_21D18();
    v12 = (const char *)sub_27CEC();
    if ( strcmp(v12, "HHB68502") )
    {
      v27 = (const char *)sub_27CEC();
      if ( strcmp(v27, "HHB68501") )
      {
        v28 = (const char *)sub_27CEC();
        if ( strcmp(v28, "HHB68701") )
        {
          v29 = (const char *)sub_27CEC();
          if ( strcmp(v29, "HHB68704") )
          {
            v30 = (const char *)sub_27CEC();
            if ( strcmp(v30, "HHB68703") )
            {
              v31 = (const char *)sub_27CEC();
              if ( strcmp(v31, "H6HB68702") )
              {
                v32 = (const char *)sub_27CEC();
                if ( strcmp(v32, "H1HB68601") )
                {
                  v33 = (const char *)sub_27CEC();
                  if ( strcmp(v33, "HHB68601") )
                  {
                    v34 = (const char *)sub_27CEC();
                    if ( strcmp(v34, "HHB68602") )
                    {
                      v35 = (const char *)sub_27CEC();
                      if ( strcmp(v35, "HHB56611") )
                      {
                        v36 = (const char *)sub_27CEC();
                        if ( strcmp(v36, "HHB68503") )
                          sub_168B4(0);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    while ( 1 )
      sleep(0xAu);
  }
  if ( sub_3D02C() > 10 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "miner has reached find asic max fail num");
      sub_41DB8(3, s, 0);
    }
    sub_4FB28(1, 1);
    while ( sub_3D02C() )
      sleep(0xAu);
  }
  return 0;
}
// BC5A4: using guessed type int dword_BC5A4;
// BC5A8: using guessed type char byte_BC5A8;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC5F4: using guessed type int dword_BC5F4;
// BC898: using guessed type int dword_BC898;
// C351C: using guessed type int dword_C351C;
// 4D4171: using guessed type char byte_4D4171;
// 4D41C0: using guessed type char byte_4D41C0;
// 6682BC: using guessed type char byte_6682BC;

//----- (0004B6FC) --------------------------------------------------------
int sub_4B6FC()
{
  int v0; // r0
  int i; // r6
  int result; // r0
  int v3; // r7
  int v4; // r4
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  unsigned int v10; // r1
  __int16 v11; // [sp+14h] [bp-2008h]
  char v12; // [sp+16h] [bp-2006h]
  char v13[8196]; // [sp+18h] [bp-2004h] BYREF

  v0 = sub_4A75C(3u);
  v11 = v0;
  v12 = BYTE2(v0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v13, "start do_core_reset");
    sub_41DB8(3, v13, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      result = sub_27D1C();
      v3 = result;
      if ( result > 0 )
      {
        v4 = 0;
        do
        {
          v5 = sub_27D8C();
          sub_7FF54((unsigned __int8)i, v4 * v5, 0);
          v6 = sub_27D8C();
          sub_804B0((unsigned __int8)i, v4 * v6);
          usleep(0x2710u);
          v7 = sub_27D8C();
          sub_7FF54((unsigned __int8)i, v4 * v7, 1);
          v8 = sub_27D8C();
          sub_80BF0((unsigned __int8)i, v4 * v8, (unsigned __int8)v11, 0);
          sub_44890();
          v9 = sub_27D8C();
          sub_80C0C((unsigned __int8)i, v4 * v9, SHIBYTE(v11), v12, 0);
          sub_44890();
          v10 = v4 * sub_27D8C();
          ++v4;
          sub_8056C((unsigned __int8)i, v10);
          result = usleep(0x2710u);
        }
        while ( v3 != v4 );
      }
    }
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v13, "end do_core_reset");
    return sub_41DB8(3, v13, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0004B9C4) --------------------------------------------------------
void sub_4B9C4()
{
  int v0; // r11
  int v1; // r0
  int *v2; // r10
  int v3; // r0
  pthread_mutex_t *v4; // r8
  int v5; // r3
  int v6; // r7
  int v7; // r5
  int v8; // r4
  unsigned int v9; // r4
  bool v10; // cc
  int *v11; // r4
  int v12; // r6
  int v13; // r8
  int v14; // r0
  int v15; // r0
  int v16; // r9
  int v17; // r6
  int v18; // r0
  char v20; // r8
  int v21; // r9
  int v22; // r10
  int v23; // r7
  int v24; // r3
  int v25; // r5
  unsigned __int16 *v26; // r4
  int v27; // r6
  int v28; // r8
  int v29; // r0
  int v30; // r0
  int v31; // r0
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r4
  int v37; // r8
  int v38; // [sp+10h] [bp-2054h]
  pthread_mutex_t *v39; // [sp+24h] [bp-2040h]
  int v40; // [sp+24h] [bp-2040h]
  int v41; // [sp+2Ch] [bp-2038h]
  int *v42; // [sp+2Ch] [bp-2038h]
  int v43; // [sp+30h] [bp-2034h]
  int v44; // [sp+34h] [bp-2030h]
  int v45; // [sp+44h] [bp-2020h]
  __int16 v46; // [sp+54h] [bp-2010h]
  char v47; // [sp+56h] [bp-200Eh]
  __time_t v48[2]; // [sp+58h] [bp-200Ch] BYREF
  __time_t v49[2049]; // [sp+60h] [bp-2004h] BYREF

  v0 = 0;
  v44 = 0;
  v1 = sub_4A75C(3u);
  v46 = v1;
  v47 = BYTE2(v1);
  sub_18C20();
  do
  {
    if ( !sub_27EC8(v0) )
      goto LABEL_3;
    v2 = dword_66C4F0;
    v45 = 0;
    sub_2A728(v0, 1);
    while ( 1 )
    {
      byte_C4794 = 1;
      sub_3DE28();
      memset(&word_6B59A8[0x80000 * v0], 0, 0x100000u);
      v43 = sub_27D1C();
      if ( v43 > 0 )
      {
        v41 = 0;
        do
        {
          v3 = sub_27D8C();
          v4 = &stru_C4760;
          sub_8051C((unsigned __int8)v0, v41 * v3);
          sub_4465C(v48);
          do
          {
            pthread_mutex_lock(v4);
            v5 = v2[2];
            v6 = v5;
            if ( v5 > 0 )
            {
              v7 = 0;
              v39 = v4;
              while ( 1 )
              {
                v8 = v2[1];
                ++v7;
                v2[2] = v5 - 1;
                v9 = v8 + 1;
                v10 = v9 > 0xFFE;
                if ( v9 <= 0xFFE )
                  v2[1] = v9;
                v11 = &v2[2 * v9];
                if ( v10 )
                  v2[1] = 0;
                if ( *((unsigned __int8 *)v11 + 11) == v0 && *((_BYTE *)v11 + 10) == 64 )
                {
                  v12 = *((unsigned __int8 *)v11 + 9);
                  v13 = v11[1];
                  v14 = sub_27D8C();
                  v15 = sub_96518(v12, v14);
                  v16 = *((unsigned __int8 *)v11 + 9);
                  v17 = *((_BYTE *)v11 + 11) & 3;
                  word_6B59A8[0x80000 * (v0 & 3) + 1 + 2048 * v15 + 2 * (*((_WORD *)v11 + 3) & 0x3FF)] = v13;
                  v18 = sub_27D8C();
                  word_6B59A8[2048 * (sub_96518(v16, v18) + (v17 << 8)) + 2 * (*((_WORD *)v11 + 3) & 0x3FF)] = 1;
                }
                if ( v6 == v7 )
                  break;
                v5 = v2[2];
              }
              v4 = v39;
            }
            pthread_mutex_unlock(v4);
            usleep(0x3E8u);
            sub_4465C(v49);
          }
          while ( (int)sub_44930(v49, v48) <= 99 );
        }
        while ( v43 != ++v41 );
      }
      v40 = sub_27D1C();
      if ( v40 <= 0 )
        break;
      v20 = 0;
      v42 = v2;
      v21 = 0;
      v22 = 0;
      do
      {
        v23 = sub_27D4C();
        if ( v23 > 0 )
        {
          v24 = 0;
          v25 = 0;
          v26 = &word_6B59A8[2048 * (v21 + v44)];
          do
          {
            v27 = v26[1];
            if ( !v26[1] )
            {
              v28 = *v26;
              if ( *v26 )
              {
                if ( (unsigned int)off_BC5EC > 3 )
                {
                  snprintf((char *)v49, 0x2000u, "core %8d data in asic %d is zero", v25, v21);
                  sub_41DB8(3, (const char *)v49, v27);
                }
              }
              else if ( (unsigned int)off_BC5EC > 3 )
              {
                snprintf((char *)v49, 0x2000u, "core %8d in asic %d not returned", v25, v21);
                sub_41DB8(3, (const char *)v49, v28);
              }
              v24 = 1;
              ++v22;
              v20 = 1;
            }
            ++v25;
            v26 += 2;
          }
          while ( v23 != v25 );
          if ( v24 )
          {
            if ( (unsigned int)off_BC5EC > 3 )
            {
              snprintf((char *)v49, 0x2000u, "reopen asic %d", v21);
              sub_41DB8(3, (const char *)v49, 0);
            }
            v29 = sub_27D8C();
            sub_804A0((unsigned __int8)v0, v21 * v29, 1);
            usleep(0x2710u);
            v30 = sub_27D8C();
            sub_804A0((unsigned __int8)v0, v21 * v30, 0);
            usleep(0x2710u);
            v31 = sub_27D8C();
            sub_80BF0((unsigned __int8)v0, v21 * v31, (unsigned __int8)v46, 0);
            sub_44890();
            v32 = sub_27D8C();
            sub_80C0C((unsigned __int8)v0, v21 * v32, SHIBYTE(v46), v47, 0);
            v33 = sub_27D8C();
            sub_8056C((unsigned __int8)v0, v21 * v33);
            usleep(0x2710u);
            if ( (unsigned int)off_BC5EC > 3 )
            {
              snprintf((char *)v49, 0x2000u, "reset clock asic %d", v21);
              sub_41DB8(3, (const char *)v49, 0);
            }
            v34 = sub_27D8C();
            sub_80D94((unsigned __int8)v0, v21 * v34, 0);
            sub_27D8C();
            sub_811C0();
            usleep(0x186A0u);
            v35 = sub_27D8C();
            sub_80D94((unsigned __int8)v0, v21 * v35, 1);
          }
        }
        ++v21;
      }
      while ( v40 != v21 );
      v36 = v22;
      v2 = v42;
      if ( (unsigned int)off_BC5EC > 3 )
        goto LABEL_55;
LABEL_44:
      if ( v36 <= 155 )
        goto LABEL_51;
      usleep((__useconds_t)&unk_F4240);
      if ( v45 <= 1 )
        v37 = v20 & 1;
      else
        v37 = 0;
      if ( !v37 )
        goto LABEL_3;
    }
    v36 = 0;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v20 = 0;
LABEL_55:
      v38 = v45++;
      snprintf(
        (char *)v49,
        0x2000u,
        "chain %d, bad core num %8d, rate = %.2f ========================round %d",
        v0,
        v36,
        (float)((float)v36 / 12168.0),
        v38);
      sub_41DB8(3, (const char *)v49, 0);
      goto LABEL_44;
    }
LABEL_51:
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf((char *)v49, 0x2000u, "bad count is acceptable = %d", v36);
      sub_41DB8(3, (const char *)v49, 0);
    }
    usleep((__useconds_t)&unk_F4240);
LABEL_3:
    ++v0;
    v44 += 256;
  }
  while ( v0 != 4 );
  byte_C4794 = 0;
  sub_18C34();
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C4794: using guessed type char byte_C4794;
// 66C4F0: using guessed type int dword_66C4F0[];
// 6B59A8: using guessed type _WORD word_6B59A8[676651];

//----- (0004BFBC) --------------------------------------------------------
int sub_4BFBC()
{
  int i; // r4
  int result; // r0
  char v2[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v2, "soft open core");
    sub_41DB8(3, v2, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      sub_803AC((unsigned __int8)i, 1);
      usleep((__useconds_t)sub_30D40);
      sub_803AC((unsigned __int8)i, 0);
      usleep((__useconds_t)&loc_61A80);
      sub_80548((unsigned __int8)i);
      result = usleep((__useconds_t)sub_30D40);
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0004C08C) --------------------------------------------------------
int __fastcall sub_4C08C(int a1, int a2)
{
  int v4; // r0
  int result; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  __int16 v12; // [sp+Ch] [bp-8h]
  char v13; // [sp+Eh] [bp-6h]

  v4 = sub_4A75C(4u);
  v12 = v4;
  v13 = BYTE2(v4);
  result = sub_27EC8(a1);
  if ( result )
  {
    v6 = sub_27D8C();
    sub_7FF54((unsigned __int8)a1, a2 * v6, 0);
    v7 = sub_27D8C();
    sub_804B0((unsigned __int8)a1, a2 * v7);
    usleep(0x2710u);
    v8 = sub_27D8C();
    sub_7FF54((unsigned __int8)a1, a2 * v8, 1);
    v9 = sub_27D8C();
    sub_80BF0((unsigned __int8)a1, a2 * v9, (unsigned __int8)v12, byte_4D4184);
    usleep(0x2710u);
    v10 = sub_27D8C();
    sub_80C0C((unsigned __int8)a1, a2 * v10, SHIBYTE(v12), v13, 0);
    usleep(0x2710u);
    v11 = sub_27D8C();
    sub_8056C((unsigned __int8)a1, a2 * v11);
    return usleep(0x2710u);
  }
  return result;
}
// 4D4184: using guessed type char byte_4D4184;

//----- (0004C188) --------------------------------------------------------
bool sub_4C188()
{
  _BOOL4 v0; // r5
  const char **v1; // r4
  const char **v2; // r6
  int v3; // r5
  const char *v4; // t1

  if ( dword_C2BB0[0] > 0 )
  {
    v1 = (const char **)&unk_C2BB4;
    v2 = (const char **)((char *)&unk_C2BB4 + 4 * dword_C2BB0[0]);
    v3 = 0;
    do
    {
      v4 = *v1++;
      if ( !strcmp(v4, "TEST") )
        ++v3;
    }
    while ( v1 != v2 );
    v0 = v3 > 2;
  }
  else
  {
    v0 = 0;
  }
  byte_C34C4 = v0;
  return v0;
}
// C2BB0: using guessed type int dword_C2BB0[];
// C34C4: using guessed type char byte_C34C4;

//----- (0004C1F8) --------------------------------------------------------
char *sub_4C1F8()
{
  int i; // r4
  const char *v1; // r0

  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
      sub_1BDB4(i, &byte_4D421C[64 * i], 0x40u);
  }
  v1 = sub_6FF60();
  return strncpy(&byte_4D431C, v1, 0x40u);
}

//----- (0004C254) --------------------------------------------------------
int sub_4C254()
{
  const char *v0; // r4
  int v1; // r5
  const char *v2; // r6
  const char *v3; // r1
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v0 = (const char *)&unk_BC8D1;
  v1 = 0;
  while ( strstr(*(const char **)(v0 - 17), "str") )
  {
    v2 = *(const char **)(v0 - 9);
    if ( *v2 )
      v3 = *(const char **)(v0 - 9);
    else
      v3 = "None";
    if ( strcmp(v0, v3) )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "droa,%s strcmp different, %s,%s", (const char *)dword_BC898[22 * v1 + 9], v0, v2);
        sub_41DB8(3, s, 0);
        return 1;
      }
      return 1;
    }
LABEL_6:
    ++v1;
    v0 += 88;
    if ( v1 == 12 )
      return 0;
  }
  if ( **(unsigned __int8 **)(v0 - 5) == *((unsigned __int8 *)v0 - 1) )
    goto LABEL_6;
  if ( (unsigned int)off_BC5EC <= 3 )
    return 1;
  snprintf(
    s,
    0x2000u,
    "droa,%s intcmp different, %d",
    (const char *)dword_BC898[22 * v1 + 9],
    *((unsigned __int8 *)v0 - 1));
  sub_41DB8(3, s, 0);
  return 1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898[];

//----- (0004C3B0) --------------------------------------------------------
FILE *sub_4C3B0()
{
  FILE *v0; // r10
  char *v1; // r6
  char *v2; // r4
  size_t v3; // r0
  const char *v4; // r5
  char *v5; // r7
  size_t v6; // r5
  const char *v7; // r11
  FILE *result; // r0
  FILE *v9; // r7
  char *v10; // r5
  int v11; // r6
  const char *v12; // r5
  bool v13; // zf
  int v14; // r2
  const char *v15; // r8
  char *v16; // r9
  int v17; // r11
  const char *v18; // r12
  const char *v19; // r3
  const char *v20; // lr
  const char *v21; // r9
  const char *v22; // r6
  int v23; // r8
  int v24; // r9
  int v25; // r10
  const char *v26; // r12
  const char *v27; // r4
  const char *v28; // lr
  const char *v29; // r0
  int v30; // r4
  char *v31; // r0
  char *v32; // r8
  const char *v33; // r3
  int v34; // r9
  int v35; // r10
  int v36; // r11
  const char *v37; // r1
  char *v38; // r2
  char *v39; // r12
  char *v40; // r1
  const char *v41; // [sp+4h] [bp-2238h]
  int v42; // [sp+10h] [bp-222Ch]
  int v43; // [sp+14h] [bp-2228h]
  int v44; // [sp+14h] [bp-2228h]
  const char *v45; // [sp+18h] [bp-2224h]
  int v46; // [sp+30h] [bp-220Ch]
  const char *v47; // [sp+30h] [bp-220Ch]
  int v48; // [sp+34h] [bp-2208h]
  char s[512]; // [sp+38h] [bp-2204h] BYREF
  char v50[8196]; // [sp+238h] [bp-2004h] BYREF

  sub_4C1F8();
  v0 = fopen("/nvdata/mbin.data", "r+");
  if ( !v0 )
  {
    result = fopen("/nvdata/mbin.data", "w+");
    v9 = result;
    if ( result )
    {
      v14 = (unsigned __int8)byte_C32F8;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        v15 = "None";
        if ( byte_C32F8 )
          v16 = &byte_C32F8;
        else
          v16 = "None";
        v17 = sub_27EB8();
        v48 = sub_27D0C();
        v46 = sub_27D1C();
        v41 = v16;
        v43 = sub_27D2C();
        v18 = byte_4D421C;
        v19 = &byte_4D425C;
        v20 = &byte_4D429C;
        if ( !byte_4D421C[0] )
          v18 = "None";
        v21 = &byte_4D42DC;
        if ( !byte_4D425C )
          v19 = "None";
        if ( !byte_4D429C )
          v20 = "None";
        if ( !byte_4D42DC )
          v21 = "None";
        if ( byte_4D431C )
          v15 = &byte_4D431C;
        snprintf(
          v50,
          0x2000u,
          "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
          byte_C2FF8,
          dest,
          v41,
          v17,
          v48,
          v46,
          v43,
          v18,
          v19,
          v20,
          v21,
          v15);
        sub_4297C(3, v50, 0);
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(v50, 0x2000u, "InitStat:%d", dword_4D4188);
          sub_4297C(3, v50, 0);
        }
        v14 = (unsigned __int8)byte_C32F8;
      }
      v12 = "None";
      v13 = v14 == 0;
LABEL_36:
      if ( v13 )
        v22 = "None";
      else
        v22 = &byte_C32F8;
      v23 = sub_27EB8();
      v24 = sub_27D0C();
      v25 = sub_27D1C();
      v42 = sub_27D2C();
      if ( byte_4D421C[0] )
        v26 = byte_4D421C;
      else
        v26 = "None";
      if ( byte_4D425C )
        v27 = &byte_4D425C;
      else
        v27 = "None";
      if ( byte_4D429C )
        v28 = &byte_4D429C;
      else
        v28 = "None";
      if ( byte_4D42DC )
        v29 = &byte_4D42DC;
      else
        v29 = "None";
      if ( byte_4D431C )
        v12 = &byte_4D431C;
      fprintf(
        v9,
        "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
        byte_C2FF8,
        dest,
        v22,
        v23,
        v24,
        v25,
        v42,
        v26,
        v27,
        v28,
        v29,
        v12);
      fflush(v9);
      return (FILE *)fclose(v9);
    }
    else if ( (unsigned int)off_BC5EC > 3 )
    {
      v30 = *_errno_location();
      v31 = strerror(v30);
      snprintf(v50, 0x2000u, "file op errno = %d reason = %s", v30, v31);
      return (FILE *)sub_41DB8(3, v50, 0);
    }
    return result;
  }
  memset(s, 0, sizeof(s));
  fgets(s, 511, v0);
  v1 = strtok(s, ",");
  if ( !v1 )
    goto LABEL_10;
  do
  {
    v2 = (char *)&unk_BC8D1;
    do
    {
      while ( 1 )
      {
        v4 = *(const char **)(v2 - 21);
        if ( !strstr(v1, v4) )
          goto LABEL_5;
        v5 = strstr(*(const char **)(v2 - 17), "str");
        v6 = strlen(v4);
        v7 = &v1[v6];
        if ( !v5 )
          break;
        v3 = strlen(v1);
        strncpy(v2, v7, v3 - v6);
LABEL_5:
        v2 += 88;
        if ( &unk_BCCF1 == (_UNKNOWN *)v2 )
          goto LABEL_9;
      }
      v2 += 88;
      *(v2 - 89) = strtol(v7, 0, 10);
    }
    while ( &unk_BCCF1 != (_UNKNOWN *)v2 );
LABEL_9:
    v1 = strtok(0, ",");
  }
  while ( v1 );
LABEL_10:
  result = (FILE *)sub_4C254();
  if ( !result )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v50, 0x2000u, "InitStat:%d", dword_4D4188);
      return (FILE *)sub_4297C(3, v50, 0);
    }
    return result;
  }
  fclose(v0);
  result = fopen("/nvdata/mbin.data", "w");
  v9 = result;
  if ( result )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      LOWORD(v10) = (unsigned __int16)&byte_C32F8;
      strcpy(v50, "update droa bin data");
      sub_41DB8(3, v50, 0);
      if ( (unsigned int)off_BC5EC <= 3 )
      {
        HIWORD(v10) = (unsigned int)&byte_C32F8 >> 16;
      }
      else
      {
        HIWORD(v10) = (unsigned int)&byte_C32F8 >> 16;
        v32 = "None";
        if ( *v10 )
          v33 = v10;
        else
          v33 = "None";
        v47 = v33;
        v34 = sub_27EB8();
        v35 = sub_27D0C();
        v36 = sub_27D1C();
        v44 = sub_27D2C();
        v37 = byte_4D421C;
        v38 = &byte_4D425C;
        v39 = &byte_4D429C;
        if ( !byte_4D421C[0] )
          v37 = "None";
        v45 = v37;
        if ( !byte_4D425C )
          v38 = "None";
        if ( !byte_4D429C )
          v39 = "None";
        if ( byte_4D42DC )
          v40 = &byte_4D42DC;
        else
          v40 = "None";
        if ( byte_4D431C )
          v32 = &byte_4D431C;
        snprintf(
          v50,
          0x2000u,
          "MCT:%s,TYPE:%s,SN:%s,ChN:%d,ChDN:%d,ChAN:%d,DoAN:%d,ChSN0:%s,ChSN1:%s,ChSN2:%s,ChSN3:%s,PWR:%s",
          byte_C2FF8,
          dest,
          v47,
          v34,
          v35,
          v36,
          v44,
          v45,
          v38,
          v39,
          v40,
          v32);
        sub_4297C(3, v50, 0);
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(v50, 0x2000u, "InitStat:%d", dword_4D4188);
          sub_4297C(3, v50, 0);
        }
      }
    }
    else
    {
      v10 = &byte_C32F8;
    }
    v11 = (unsigned __int8)*v10;
    v12 = "None";
    v13 = v11 == 0;
    goto LABEL_36;
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v50, "droa log miner bin data update failed");
    return (FILE *)sub_41DB8(3, v50, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 4D4188: using guessed type int dword_4D4188;
// 4D425C: using guessed type char byte_4D425C;
// 4D429C: using guessed type char byte_4D429C;
// 4D42DC: using guessed type char byte_4D42DC;

//----- (0004CA18) --------------------------------------------------------
int __fastcall sub_4CA18(int a1)
{
  int v2; // r0
  int result; // r0
  int v4; // r7
  int v5; // r4
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  __int16 v10; // [sp+Ch] [bp-8h]
  char v11; // [sp+Eh] [bp-6h]

  v2 = sub_4A75C(3u);
  v10 = v2;
  v11 = BYTE2(v2);
  result = sub_27EC8(a1);
  if ( result )
  {
    result = sub_27D1C();
    v4 = result;
    if ( result > 0 )
    {
      v5 = 0;
      do
      {
        v6 = sub_27D8C();
        sub_804A0((unsigned __int8)a1, v5 * v6, 1);
        usleep(0x2710u);
        v7 = sub_27D8C();
        sub_804A0((unsigned __int8)a1, v5 * v7, 0);
        usleep(0x2710u);
        v8 = sub_27D8C();
        sub_80BF0((unsigned __int8)a1, v5 * v8, (unsigned __int8)v10, byte_4D4184);
        usleep(0x2710u);
        v9 = sub_27D8C();
        sub_80C0C((unsigned __int8)a1, v5 * v9, SHIBYTE(v10), v11, 0);
        ++v5;
        result = usleep(0x2710u);
      }
      while ( v4 != v5 );
    }
  }
  return result;
}
// 4D4184: using guessed type char byte_4D4184;

//----- (0004CB18) --------------------------------------------------------
unsigned int sub_4CB18()
{
  return sub_473B4(0xEu, "Can't get temperature sensor type!");
}

//----- (0004CB28) --------------------------------------------------------
bool sub_4CB28()
{
  return dword_C351C == 2;
}
// C351C: using guessed type int dword_C351C;

//----- (0004CB44) --------------------------------------------------------
int sub_4CB44()
{
  return (unsigned __int8)byte_4D435C;
}
// 4D435C: using guessed type char byte_4D435C;

//----- (0004CB54) --------------------------------------------------------
void sub_4CB54()
{
  byte_4D435C = 0;
}
// 4D435C: using guessed type char byte_4D435C;

//----- (0004CB68) --------------------------------------------------------
int sub_4CB68()
{
  return (unsigned __int8)byte_4D435D;
}
// 4D435D: using guessed type char byte_4D435D;

//----- (0004CB78) --------------------------------------------------------
int sub_4CB78()
{
  int v0; // r4
  int result; // r0
  const char *v2; // r0
  unsigned int v3; // r3
  int v4; // r3
  int *v5; // r5
  int v6; // r4
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  int v17; // r0
  int v18; // r6
  int v19; // r7
  int v20; // r0

  v0 = sub_287A0();
  result = sub_287B0();
  if ( v0 <= result )
  {
    v6 = sub_287A0();
    result = sub_287B8();
    if ( v6 >= result || (result = sub_287A0()) == 0 )
    {
      dword_4D4360 = 0;
      dword_4D4364 = 0;
      return result;
    }
    dword_4D4360 = 0;
    v4 = ++dword_4D4364;
  }
  else
  {
    dword_4D4364 = 0;
    if ( ++dword_4D4360 <= 3 )
      return result;
    v2 = (const char *)sub_27CEC();
    if ( !strcmp(v2, "HHB68502") )
      goto LABEL_5;
    v7 = (const char *)sub_27CEC();
    if ( !strcmp(v7, "HHB68501") )
      goto LABEL_5;
    v8 = (const char *)sub_27CEC();
    if ( !strcmp(v8, "HHB68701") )
      goto LABEL_5;
    v9 = (const char *)sub_27CEC();
    if ( !strcmp(v9, "HHB68704")
      || (v10 = (const char *)sub_27CEC(), !strcmp(v10, "HHB68703"))
      || (v11 = (const char *)sub_27CEC(), !strcmp(v11, "H6HB68702"))
      || (v12 = (const char *)sub_27CEC(), !strcmp(v12, "H1HB68601"))
      || (v13 = (const char *)sub_27CEC(), !strcmp(v13, "HHB68601"))
      || (v14 = (const char *)sub_27CEC(), !strcmp(v14, "HHB68602"))
      || (v15 = (const char *)sub_27CEC(), !strcmp(v15, "HHB56611"))
      || (v16 = (const char *)sub_27CEC(), !strcmp(v16, "HHB68503")) )
    {
LABEL_5:
      v3 = 350;
    }
    else
    {
      v3 = 395;
    }
    result = dword_4D4180;
    if ( dword_4D4180 > v3 )
    {
      dword_4D4180 -= 20;
      result = sub_470D0(result);
      v4 = dword_4D4364;
      byte_4D435C = 1;
      dword_4D4360 = 0;
    }
    else
    {
      v4 = dword_4D4364;
    }
  }
  if ( v4 > 9 && dword_4D4180 < (unsigned int)dword_4D417C )
  {
    v5 = &dword_C351C;
    if ( dword_C351C == 2 )
    {
      v17 = sub_46F74();
      v18 = v17;
      if ( dword_C351C != 2 )
        v5 = (int *)v17;
      dword_4D4180 += 20;
      if ( dword_C351C == 2 )
      {
        v19 = sub_46F74();
        v5 = (int *)(v18 - v19);
      }
      else
      {
        v19 = 0;
      }
      v20 = (int)v5 + sub_2242C();
      if ( v19 < v18 )
      {
        sub_21E88(v20, 3u);
        sleep(3u);
        sub_470D0(dword_4D4180 - 20);
        result = sleep(2u);
        goto LABEL_13;
      }
    }
    else
    {
      dword_4D4180 += 20;
      sub_2242C();
    }
    result = sub_470D0(dword_4D4180 - 20);
LABEL_13:
    byte_4D435C = 1;
    dword_4D4364 = 0;
  }
  return result;
}
// C351C: using guessed type int dword_C351C;
// 4D417C: using guessed type int dword_4D417C;
// 4D4180: using guessed type int dword_4D4180;
// 4D435C: using guessed type char byte_4D435C;
// 4D4360: using guessed type int dword_4D4360;
// 4D4364: using guessed type int dword_4D4364;

//----- (0004CE14) --------------------------------------------------------
int sub_4CE14()
{
  const char *v0; // r0
  const char *v1; // r0
  int v2; // r7
  int v3; // r6
  int v4; // r4
  const char *v5; // r0
  int v6; // r3
  const char *v8; // r0
  int v9; // r0
  int v10; // r9
  int v11; // r4
  int v12; // r6
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  int v24; // r3
  int v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  int v28; // r4
  int v29; // r7
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v0 = (const char *)sub_27CEC();
  if ( strcmp(v0, "HHB68502") )
  {
    v1 = (const char *)sub_27CEC();
    if ( strcmp(v1, "HHB68501") )
    {
      v13 = (const char *)sub_27CEC();
      if ( strcmp(v13, "HHB68701") )
      {
        v14 = (const char *)sub_27CEC();
        if ( strcmp(v14, "HHB68704") )
        {
          v15 = (const char *)sub_27CEC();
          if ( strcmp(v15, "HHB68703") )
          {
            v16 = (const char *)sub_27CEC();
            if ( strcmp(v16, "H6HB68702") )
            {
              v17 = (const char *)sub_27CEC();
              if ( strcmp(v17, "H1HB68601") )
              {
                v18 = (const char *)sub_27CEC();
                if ( strcmp(v18, "HHB68601") )
                {
                  v19 = (const char *)sub_27CEC();
                  if ( strcmp(v19, "HHB68602") )
                  {
                    v20 = (const char *)sub_27CEC();
                    if ( strcmp(v20, "HHB56611") )
                    {
                      v21 = (const char *)sub_27CEC();
                      if ( strcmp(v21, "HHB68503") )
                        return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v2 = sub_18E58();
  v3 = dword_4D419C;
  if ( dword_C351C == 2 )
    v3 -= sub_46F74();
  if ( v3 <= 0 )
    return 0;
  v4 = sub_2242C();
  if ( (unsigned int)off_BC5EC <= 4 )
  {
    if ( v2 > 37 )
      goto LABEL_8;
LABEL_23:
    dword_4D4368 = 0;
    dword_4D4194 = 0;
    v8 = (const char *)sub_27CEC();
    v9 = strcmp(v8, "HHB68701");
    if ( 240 * (38 - v2) / 0x28u > 0xF0 )
      v10 = v3 + 240;
    else
      v10 = v3 + 240 * (38 - v2) / 0x28u;
    if ( !v9
      || (v26 = (const char *)sub_27CEC(), !strcmp(v26, "HHB68703"))
      || (v27 = (const char *)sub_27CEC(), !strcmp(v27, "HHB68704")) )
    {
      if ( v10 >= 2180 )
        v10 = 2180;
    }
    else if ( v10 >= 2150 )
    {
      v10 = 2150;
    }
    if ( v10 > v4 )
    {
      word_4D436C = v2;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "entrance_temp = %d, work_vol = %d, curr_vol = %d, ->tgt_volt = %d\n", v2, v3, v4, v10);
        sub_41DB8(3, s, 0);
      }
      v11 = v4 + 20;
      if ( v10 <= v11 )
        goto LABEL_35;
      do
      {
        sub_21E88(v11, 3u);
        v12 = v11;
        v11 += 20;
        usleep((__useconds_t)sub_30D40);
      }
      while ( v10 > v11 );
      if ( v10 != v12 )
LABEL_35:
        sub_21E88(v10, 3u);
      return 0;
    }
    LOBYTE(v24) = byte_4D436E;
    if ( !byte_4D436E )
    {
      v24 = v2 - word_4D436C > 1;
      if ( v10 >= v4 )
        v24 = 0;
      if ( !v24 )
        return 0;
    }
    word_4D436C = v2;
    if ( v10 != v4 )
    {
      LOBYTE(v24) = (_BYTE)off_BC5EC;
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "entrance_temp = %d, work_vol = %d, curr_vol = %d, ->tgt_volt = %d\n", v2, v3, v4, v10);
        sub_41DB8(3, s, 0);
      }
    }
    v25 = v4 - 10;
    if ( v4 - 10 > v10 )
      LOBYTE(v24) = 1;
    else
      v25 = v10;
    if ( v4 - 10 <= v10 )
      LOBYTE(v24) = 0;
    byte_4D436E = v24;
LABEL_64:
    sub_21E88(v25, 3u);
    return 0;
  }
  snprintf(s, 0x2000u, "entrance_temp = %d, current_voltage = %d, work_wol = %d\n", v2, v4, v3);
  sub_41DB8(4, s, 0);
  if ( v2 <= 37 )
    goto LABEL_23;
LABEL_8:
  if ( v2 != 38 )
  {
    v5 = (const char *)sub_27CEC();
    if ( !strcmp(v5, "H1HB68601") )
      v6 = 41;
    else
      v6 = 42;
    if ( v6 > v2 )
    {
      dword_4D4368 = 0;
      dword_4D4194 = 0;
      if ( v3 != v4 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "entrance_temp = %d, ->work_vol = %d, curr_vol = %d\n", v2, v3, v4);
          sub_41DB8(3, s, 0);
        }
        if ( v3 < v4 )
        {
          if ( v4 - 9 > v3 )
            v3 = v4 - 10;
          sub_21E88(v3, 3u);
          usleep((__useconds_t)sub_30D40);
          return 0;
        }
        if ( v3 <= v4 )
          return 0;
        v28 = v4 + 20;
        if ( v3 > v28 )
        {
          do
          {
            sub_21E88(v28, 3u);
            v29 = v28;
            v28 += 20;
            usleep((__useconds_t)sub_30D40);
          }
          while ( v3 > v28 );
          if ( v3 == v29 )
            return 0;
        }
        v25 = v3;
        goto LABEL_64;
      }
      return 0;
    }
    v22 = (const char *)sub_27CEC();
    if ( strcmp(v22, "H1HB68601") && v2 <= 41 )
      return 0;
    ++dword_4D4368;
    v23 = (const char *)sub_27CEC();
    if ( !strcmp(v23, "H1HB68601") )
    {
      if ( dword_4D4368 <= 4 )
        return 0;
    }
    else if ( dword_4D4368 <= 6 )
    {
      return 0;
    }
    if ( byte_C1E68 )
    {
      if ( sub_226E8() )
        sub_4758C(v2);
      dword_4D4368 = 0;
    }
    return 0;
  }
  sub_27CEC();
  return 0;
}
// 4D218: variable 'v24' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// C1E68: using guessed type char byte_C1E68;
// C351C: using guessed type int dword_C351C;
// 4D4194: using guessed type int dword_4D4194;
// 4D419C: using guessed type int dword_4D419C;
// 4D4368: using guessed type int dword_4D4368;
// 4D436C: using guessed type __int16 word_4D436C;
// 4D436E: using guessed type char byte_4D436E;

//----- (0004D358) --------------------------------------------------------
int sub_4D358()
{
  return 0;
}

//----- (0004D360) --------------------------------------------------------
void sub_4D360()
{
  ;
}

//----- (0004D370) --------------------------------------------------------
void sub_4D370()
{
  ;
}

//----- (0004D380) --------------------------------------------------------
void sub_4D380()
{
  ;
}

//----- (0004D4B8) --------------------------------------------------------
int sub_4D4B8()
{
  FILE *v0; // r0
  FILE *v1; // r4
  int i; // r5
  char *v4; // r0
  int *v5; // r0
  char *v6; // r0
  int *v7; // r0
  char *v8; // r0
  _DWORD s[25]; // [sp+4h] [bp-2064h] BYREF
  char v10[8192]; // [sp+68h] [bp-2000h] BYREF

  v0 = fopen("/config/find_asic_counter", "r");
  if ( v0 )
  {
    fclose(v0);
  }
  else
  {
    v1 = fopen("/config/find_asic_counter", "w+b");
    if ( !v1 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return 0;
      strcpy(v10, "fail to create find_asic_counter file");
      sub_41DB8(3, v10, 0);
      return 0;
    }
    memset(s, 0, sizeof(s));
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v10, "exist chain");
      sub_41DB8(3, v10, 0);
    }
    for ( i = 0; i != 3; ++i )
    {
      memset(v10, 0, 0x20u);
      sub_1BDB4(i, v10, 0x20u);
      v4 = (char *)&s[8 * i + 1];
      strcpy(v4, v10);
    }
    if ( fwrite(s, 0x64u, 1u, v1) != 1 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v10, "fail to w open find_asic_counter file");
        sub_41DB8(3, v10, 0);
      }
      goto LABEL_6;
    }
    fflush(v1);
    fclose(v1);
  }
  v1 = fopen("/config/find_asic_counter", "r+");
  if ( v1 )
  {
    memset(s, 0, sizeof(s));
    if ( fread(s, 0x64u, 1u, v1) != 1 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
      {
LABEL_6:
        fclose(v1);
        return 0;
      }
      v5 = _errno_location();
      v6 = strerror(*v5);
      snprintf(v10, 0x2000u, "read find_asic_counter file failed! err:%s\n", v6);
LABEL_20:
      sub_41DB8(3, v10, 0);
      fclose(v1);
      return 0;
    }
    ++s[0];
    fseek(v1, 0, 0);
    if ( fwrite(s, 0x64u, 1u, v1) != 1 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_6;
      v7 = _errno_location();
      v8 = strerror(*v7);
      snprintf(v10, 0x2000u, "write find_asic_counter file failed! err:%s\n", v8);
      goto LABEL_20;
    }
    fflush(v1);
    fclose(v1);
    return s[0];
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return 0;
    strcpy(v10, "fail to r+ open find_asic_counter file");
    sub_41DB8(3, v10, 0);
    return 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0004D804) --------------------------------------------------------
int sub_4D804()
{
  double v0; // d0
  int v1; // r8
  int i; // r4
  int j; // r4
  int v4; // r0
  int v5; // r5
  int v7; // r5
  int v8; // r0
  int v9; // r6
  int v10; // r5
  char v11; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v1 = 0;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      v7 = 0;
      do
      {
        sub_643D4(i);
        sub_44890();
        sub_64434(i);
        sub_44890();
        sub_643D4(i);
        sub_44890();
        sub_64434(i);
        sub_44890();
        sub_643D4(i);
        sub_44890();
        sub_64434(i);
        sub_44890();
        sub_3E1FC(i, 0);
        if ( sub_29C30() && sub_29C80() )
        {
          v11 = sub_29DF8((unsigned __int8)i);
          sub_28238(i, v11);
        }
        v8 = sub_282A4(i);
        v9 = v8;
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "Chain[%d]: find %d asic, times %d", i, v8, v7);
          sub_41DB8(3, s, 0);
        }
        ++v7;
      }
      while ( v9 != sub_27D1C() && v7 != 3 );
      v10 = sub_282A4(i);
      if ( sub_27D1C() != v10 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(s, 0x2000u, "Chain %d only find %d asic, will power off hash board %d\n", i, v10, i);
          sub_41DB8(3, s, 0);
        }
        v1 = -1;
        sub_4FB28(1, 1 << i);
        sub_27E2C(i, 0);
      }
    }
  }
  if ( sub_2270C() )
  {
    if ( !v1 )
      return v1;
    for ( j = 0; j != 4; ++j )
    {
      if ( sub_27EC8(j) )
        sub_27E2C(j, 0);
    }
  }
  else if ( !v1 )
  {
    return v1;
  }
  v4 = sub_4D4B8();
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "ATTENTION: Failed to find the chip on the %d consecutive startup", v4);
    sub_41DB8(3, s, 0);
  }
  sub_473B4(0xAu, "asic number is not right");
  pthread_setcancelstate(1, 0);
  v5 = sub_7315C(0, 0);
  sub_6F108();
  pthread_setcancelstate(0, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "got power error code:0x%08x!\n", v5);
    sub_41DB8(3, s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "got power adc vol: %lf!\n", v0);
      sub_41DB8(3, s, 0);
    }
  }
  return v1;
}
// 4DAD4: variable 'v0' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0004DB18) --------------------------------------------------------
int sub_4DB18()
{
  int v0; // r4
  bool v1; // cc
  char v2; // r0
  const char *v3; // r0
  const char *v4; // r0
  const char *v5; // r0
  int v6; // r0
  int v7; // r6
  const char *v9; // r0
  const char *v10; // r6
  int v11; // r0
  const char *v12; // r0
  const char *v13; // r0
  const char *v14; // r0
  const char *v15; // r0
  const char *v16; // r0
  const char *v17; // r0
  const char *v18; // r0
  const char *v19; // r0
  const char *v20; // r0
  const char *v21; // r0
  const char *v22; // r0
  const char *v23; // r0
  const char *v24; // r0
  const char *v25; // r0
  const char *v26; // r0
  const char *v27; // r0
  const char *v28; // r0
  const char *v29; // r0
  int v30; // r6
  char v31; // r0
  const char *v32; // r0
  const char *v33; // r0
  int v34; // r6
  int v35; // r6
  int v36; // r6
  char v37; // r0
  int v38; // r0
  const char *v39; // r0
  int v40; // r6
  int v41; // r3
  const char *v42; // r0
  const char *v43; // r0
  const char *v44; // r0
  const char *v45; // r0
  const char *v46; // r0
  const char *v47; // r0
  const char *v48; // r0
  const char *v49; // r0
  const char *v50; // r0
  const char *v51; // r0
  const char *v52; // r0
  const char *v53; // r0
  const char *v54; // r0
  const char *v55; // r0
  const char *v56; // r0
  const char *v57; // r0
  const char *v58; // r0
  const char *v59; // r0
  const char *v60; // r0
  char v61; // [sp+7h] [bp-2005h] BYREF
  char v62[8196]; // [sp+8h] [bp-2004h] BYREF

  v0 = 0;
  sub_48AE0();
  while ( 1 )
  {
    v1 = sub_27CFC() <= v0;
    v2 = v0++;
    if ( v1 )
      break;
    sub_643D4(v2);
  }
  v3 = (const char *)sub_27CEC();
  if ( strcmp(v3, "HHB68502") )
  {
    v4 = (const char *)sub_27CEC();
    if ( strcmp(v4, "HHB68501") )
    {
      v12 = (const char *)sub_27CEC();
      if ( strcmp(v12, "HHB68701") )
      {
        v13 = (const char *)sub_27CEC();
        if ( strcmp(v13, "HHB68704") )
        {
          v14 = (const char *)sub_27CEC();
          if ( strcmp(v14, "HHB68703") )
          {
            v15 = (const char *)sub_27CEC();
            if ( strcmp(v15, "H6HB68702") )
            {
              v16 = (const char *)sub_27CEC();
              if ( strcmp(v16, "H1HB68601") )
              {
                v17 = (const char *)sub_27CEC();
                if ( strcmp(v17, "HHB68601") )
                {
                  v18 = (const char *)sub_27CEC();
                  if ( strcmp(v18, "HHB68602") )
                  {
                    v19 = (const char *)sub_27CEC();
                    if ( strcmp(v19, "HHB56611") )
                    {
                      v20 = (const char *)sub_27CEC();
                      if ( strcmp(v20, "HHB68503") )
                      {
                        v7 = sub_165E8(0xFA0u, 1);
                        if ( v7 )
                          return v7;
                        if ( (unsigned int)off_BC5EC > 3 )
                        {
                          strcpy(v62, "Fan check passed.\n");
                          sub_41DB8(3, v62, 0);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  sub_18600();
  sub_473B4(1u, "soc init done!");
  sleep(5u);
  sub_18214();
  sleep(5u);
  v61 = 0;
  if ( sub_6FE94(&v61) || !v61 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v62, "warning:power is not calibrated.\n");
      sub_41DB8(3, v62, 0);
    }
    goto LABEL_10;
  }
  sub_73208(1);
  v9 = sub_6FF60();
  v10 = v9;
  if ( v9 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
    {
      if ( *v9 == 78 )
        goto LABEL_10;
      goto LABEL_18;
    }
    snprintf(v62, 0x2000u, "power sn:%s\n", v9);
    sub_41DB8(3, v62, 0);
    if ( *v10 != 78 )
LABEL_18:
      strncpy(&byte_4D4370, v10, 0x1Fu);
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    v11 = sub_6FFB0();
    snprintf(v62, 0x2000u, "enable_power_calibration, calibration date:%d.\n", v11);
    sub_41DB8(3, v62, 0);
  }
LABEL_10:
  sub_3CF98();
  sub_18200();
  v5 = (const char *)sub_27CEC();
  if ( !strcmp(v5, "HHB68601") )
    goto LABEL_11;
  v21 = (const char *)sub_27CEC();
  if ( !strcmp(v21, "HHB68602") )
    goto LABEL_11;
  v22 = (const char *)sub_27CEC();
  if ( !strcmp(v22, "HHB68502")
    || (v23 = (const char *)sub_27CEC(), !strcmp(v23, "HHB68501"))
    || (v24 = (const char *)sub_27CEC(), !strcmp(v24, "HHB68701"))
    || (v25 = (const char *)sub_27CEC(), !strcmp(v25, "HHB68704"))
    || (v26 = (const char *)sub_27CEC(), !strcmp(v26, "HHB68703"))
    || (v27 = (const char *)sub_27CEC(), !strcmp(v27, "H6HB68702"))
    || (v28 = (const char *)sub_27CEC(), !strcmp(v28, "H1HB68601"))
    || (v29 = (const char *)sub_27CEC(), !strcmp(v29, "HHB68503")) )
  {
LABEL_11:
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v6 = sub_19404();
      snprintf(v62, 0x2000u, "start up min temp by 75a = %d", v6);
      sub_41DB8(3, v62, 0);
    }
  }
  v7 = sub_47A48(1, 0, 0);
  if ( v7 )
    return v7;
  if ( sub_28654() <= 0 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v62, "reset low before power init\n");
      sub_41DB8(3, v62, 0);
    }
    v36 = 0;
    while ( 1 )
    {
      v1 = sub_27CFC() <= v36;
      v37 = v36++;
      if ( v1 )
        break;
      sub_643D4(v37);
    }
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v62, "reset high before power init\n");
      sub_41DB8(3, v62, 0);
    }
    v30 = 0;
    while ( 1 )
    {
      v1 = sub_27CFC() <= v30;
      v31 = v30++;
      if ( v1 )
        break;
      sub_64434(v31);
    }
  }
  if ( byte_BC5C9 )
  {
    if ( !sub_28644() )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      strcpy(v62, "warning topol_get_open_core_high_voltage=0,please check topol.conf!");
      v7 = -1;
      sub_41DB8(3, v62, 0);
      return v7;
    }
    v38 = sub_28644();
    v35 = sub_21F98(v38);
    if ( !v35 )
      goto LABEL_51;
  }
  else if ( dword_4D419C <= 0 || (v35 = sub_21F98(dword_4D419C)) == 0 )
  {
LABEL_51:
    byte_4D4390 = 1;
    v32 = (const char *)sub_27CEC();
    if ( !strcmp(v32, "HHB68502") )
      goto LABEL_53;
    v33 = (const char *)sub_27CEC();
    if ( !strcmp(v33, "HHB68501") )
      goto LABEL_53;
    v52 = (const char *)sub_27CEC();
    if ( !strcmp(v52, "HHB68701") )
      goto LABEL_53;
    v53 = (const char *)sub_27CEC();
    if ( !strcmp(v53, "HHB68704")
      || (v54 = (const char *)sub_27CEC(), !strcmp(v54, "HHB68703"))
      || (v55 = (const char *)sub_27CEC(), !strcmp(v55, "H6HB68702"))
      || (v56 = (const char *)sub_27CEC(), !strcmp(v56, "H1HB68601"))
      || (v57 = (const char *)sub_27CEC(), !strcmp(v57, "HHB68601"))
      || (v58 = (const char *)sub_27CEC(), !strcmp(v58, "HHB68602"))
      || (v59 = (const char *)sub_27CEC(), !strcmp(v59, "HHB56611"))
      || (v60 = (const char *)sub_27CEC(), !strcmp(v60, "HHB68503")) )
    {
LABEL_53:
      sub_4AA80();
    }
    sub_1823C();
    sub_47A48(1, 0, 0);
    v34 = (unsigned __int8)byte_4D4190;
    if ( byte_4D4190 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(v62, 0x2000u, "stop mining %s", "bitmain_board_init");
        sub_41DB8(3, v62, 0);
      }
      while ( 1 )
        sleep(0xAu);
    }
    sub_21C78();
    sub_63004();
    sub_630CC();
    sub_6311C();
    sub_44890();
    sub_38DE8((signed int)&loc_1C200, v34);
    sub_44890();
    v39 = (const char *)sub_27CEC();
    if ( strcmp(v39, "HHB68502") )
    {
      v42 = (const char *)sub_27CEC();
      if ( strcmp(v42, "HHB68501") )
      {
        v43 = (const char *)sub_27CEC();
        if ( strcmp(v43, "HHB68701") )
        {
          v44 = (const char *)sub_27CEC();
          if ( strcmp(v44, "HHB68704") )
          {
            v45 = (const char *)sub_27CEC();
            if ( strcmp(v45, "HHB68703") )
            {
              v46 = (const char *)sub_27CEC();
              if ( strcmp(v46, "H6HB68702") )
              {
                v47 = (const char *)sub_27CEC();
                if ( strcmp(v47, "H1HB68601") )
                {
                  v48 = (const char *)sub_27CEC();
                  if ( strcmp(v48, "HHB68601") )
                  {
                    v49 = (const char *)sub_27CEC();
                    if ( strcmp(v49, "HHB68602") )
                    {
                      v50 = (const char *)sub_27CEC();
                      if ( strcmp(v50, "HHB56611") )
                      {
                        v51 = (const char *)sub_27CEC();
                        if ( strcmp(v51, "HHB68503") )
                          sub_168B4(100);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v7 = sub_4D804();
    byte_4D41E0 = 1;
    if ( sub_28664() )
    {
      if ( v7 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(v62, "test:find asic num failed, whileloop");
          sub_41DB8(3, v62, 0);
        }
        sub_21D18();
        while ( 1 )
          sleep(0xAu);
      }
LABEL_77:
      v40 = 8;
      while ( 1 )
      {
        v41 = sub_18F94();
        if ( dword_4D4394 )
        {
          if ( v41 - dword_4D4394 <= 1 )
            break;
        }
        dword_4D4394 = v41;
        sleep(0xAu);
        if ( !--v40 )
          goto LABEL_83;
      }
      if ( (unsigned int)off_BC5EC > 4 )
      {
        strcpy(v62, "no temp raise, stop monitoring\n");
        sub_41DB8(4, v62, 0);
      }
LABEL_83:
      if ( (unsigned int)(dword_4D4188 - 15) <= 1 )
        return 1;
      byte_4D435D = 1;
      sub_4A908();
      dword_BDC6C = 0;
      dword_BDC74 = 0;
      v7 = 0;
      dword_BDC70 = 0;
      return v7;
    }
    if ( !v7 || sub_27EB8() && dword_BC898[0] )
      goto LABEL_77;
    return v7;
  }
  sub_4FB28(12, 0);
  sub_473B4(9u, "get power type version failed!");
  return v35;
}
// BC5C9: using guessed type char byte_BC5C9;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898[];
// BDC6C: using guessed type int dword_BDC6C;
// BDC70: using guessed type int dword_BDC70;
// BDC74: using guessed type int dword_BDC74;
// 4D4188: using guessed type int dword_4D4188;
// 4D4190: using guessed type char byte_4D4190;
// 4D419C: using guessed type int dword_4D419C;
// 4D41E0: using guessed type char byte_4D41E0;
// 4D435D: using guessed type char byte_4D435D;
// 4D4390: using guessed type char byte_4D4390;
// 4D4394: using guessed type int dword_4D4394;

//----- (0004E520) --------------------------------------------------------
int __fastcall sub_4E520(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *v8; // r4
  int v10; // r0
  int v11; // r8
  int v12; // r10
  int v13; // r0
  unsigned int v14; // r9
  int v15; // r0
  int v16; // r8
  int v17; // r8
  int v18; // r11
  int v19; // r8
  bool v20; // cc
  const char *v21; // r0
  const char *v22; // r0
  char v23; // r0
  unsigned int v24; // r3
  int v25; // r6
  int v26; // r0
  int v27; // r7
  int v28; // r0
  int i; // r11
  int v30; // r7
  char *v31; // r10
  unsigned int v32; // r5
  _QWORD *j; // r9
  int v34; // r6
  unsigned int v35; // r0
  int v36; // r1
  int v37; // r1
  int v38; // r7
  unsigned int v39; // r3
  int v40; // r0
  const char *v41; // r0
  const char *v42; // r0
  const char *v43; // r0
  const char *v44; // r0
  const char *v45; // r0
  const char *v46; // r0
  const char *v47; // r0
  const char *v48; // r0
  const char *v49; // r0
  const char *v50; // r0
  const char *v51; // r0
  const char *v52; // r0
  const char *v53; // r0
  const char *v54; // r0
  const char *v55; // r0
  unsigned __int8 v56; // r0
  int v57; // r6
  const char *v58; // r0
  const char *v59; // r0
  int v60; // r6
  int v61; // r7
  int v62; // r0
  int v63; // r11
  const char *v64; // r0
  const char *v65; // r0
  int v66; // r6
  int v67; // r7
  int v68; // r0
  int v69; // r7
  int v70; // r6
  int v71; // r0
  int v72; // r7
  int v73; // r8
  unsigned int v74; // r0
  const char *v75; // r0
  const char *v76; // r0
  const char *v77; // r0
  const char *v78; // r0
  const char *v79; // r0
  const char *v80; // r0
  const char *v81; // r0
  const char *v82; // r0
  const char *v83; // r0
  const char *v84; // r0
  const char *v85; // r0
  unsigned int v86; // r0
  const char *v87; // r0
  const char *v88; // r0
  const char *v89; // r0
  const char *v90; // r0
  const char *v91; // r0
  const char *v92; // r0
  const char *v93; // r0
  const char *v94; // r0
  const char *v95; // r0
  const char *v96; // r0
  const char *v97; // r0
  const char *v98; // r0
  const char *v99; // r0
  const char *v100; // r0
  const char *v101; // r0
  const char *v102; // r0
  const char *v103; // r0
  const char *v104; // r0
  const char *v105; // r0
  const char *v106; // r0
  const char *v107; // r0
  const char *v108; // r0
  const char *v109; // r0
  const char *v110; // r0
  const char *v111; // r0
  const char *v112; // r0
  const char *v113; // r0
  const char *v114; // r0
  const char *v115; // r0
  const char *v116; // r0
  const char *v117; // r0
  const char *v118; // r0
  const char *v119; // r0
  const char *v120; // r0
  const char *v121; // r0
  const char *v122; // r0
  const char *v123; // r0
  const char *v124; // r0
  const char *v125; // r0
  const char *v126; // r0
  const char *v127; // r0
  const char *v128; // r0
  int v129[9]; // [sp+1Ch] [bp-2028h] BYREF
  char v130[8192]; // [sp+40h] [bp-2004h] BYREF
  _DWORD savedregs[13]; // [sp+2044h] [bp+0h]

  LOWORD(v8) = (unsigned __int16)&off_BC5EC;
  savedregs[9] = a1;
  savedregs[10] = a2;
  savedregs[11] = a3;
  savedregs[12] = a4;
  if ( sub_4C188() )
  {
    HIWORD(v8) = (unsigned int)&off_BC5EC >> 16;
  }
  else
  {
    HIWORD(v8) = (unsigned int)&off_BC5EC >> 16;
    if ( *v8 > 3u )
    {
      strcpy(v130, "Miner Bootsup");
      sub_4297C(3, v130, 0);
    }
  }
  sem_init(&stru_AB7A08, 0, 0);
  v129[1] = savedregs[9];
  v129[2] = savedregs[10];
  v129[3] = savedregs[11];
  v129[4] = savedregs[12];
  v129[5] = a5;
  v129[6] = a6;
  v129[7] = a7;
  v129[8] = a8;
  *(_DWORD *)&byte_AB79E8 = savedregs[9];
  *(_DWORD *)&byte_AB79EC = savedregs[10];
  unk_AB79F0 = savedregs[11];
  *(_DWORD *)&word_AB79F4 = savedregs[12];
  unk_AB79F8 = a5;
  unk_AB79FC = a6;
  unk_AB7A00 = a7;
  unk_AB7A04 = a8;
  if ( LOBYTE(savedregs[9]) != 81 )
  {
    if ( *v8 <= 4u )
      return 0;
    snprintf(v130, 0x2000u, "config_parameter.token_type != 0x%x, it is 0x%x\n", 81, (unsigned __int8)byte_AB79E8);
LABEL_9:
    sub_41DB8(4, v130, 0);
    return 0;
  }
  v10 = sub_4596C((int)&byte_AB79E8, 30);
  if ( v10 != (unsigned __int16)word_AB7A06 )
  {
    if ( *v8 <= 4u )
      return 0;
    snprintf(
      v130,
      0x2000u,
      "config_parameter.crc = 0x%x, but we calculate it as 0x%x\n",
      (unsigned __int16)word_AB7A06,
      v10);
    goto LABEL_9;
  }
  if ( *v8 > 4u )
  {
    snprintf(
      v130,
      0x2000u,
      "fan_eft : %d  fan_pwm : %d\n",
      ((unsigned __int8)byte_AB79EC >> 1) & 1,
      (unsigned __int8)byte_AB79F2);
    sub_41DB8(4, v130, 0);
  }
  v11 = dword_BC898[0];
  if ( !dword_BC898[0] )
  {
    v12 = (unsigned __int8)sub_50748(161);
    do
    {
      v13 = v11;
      v14 = (unsigned __int8)v11++;
      if ( sub_27EC8(v13) )
        sub_7E92C(v14);
    }
    while ( v11 != 4 );
    if ( v12 )
      return 0;
  }
  if ( (unsigned __int8)sub_384C4() )
    return 0;
  if ( byte_4D41C0 && (byte_AB79EC & 0x10) != 0 )
  {
    dword_4D419C = (unsigned __int16)word_AB79F6;
    v15 = sub_46E68();
    dword_4D419C = v15;
    if ( v15 >= 0 )
    {
LABEL_26:
      if ( *v8 > 3u )
      {
        snprintf(v130, 0x2000u, "fixed working voltage = %d\n", dword_4D419C);
        sub_41DB8(3, v130, 0);
      }
      goto LABEL_28;
    }
  }
  else
  {
    v15 = sub_46E68();
    if ( v15 > 0 )
    {
      dword_4D419C = v15;
      goto LABEL_26;
    }
  }
  if ( (_BYTE)v15 )
    return 0;
LABEL_28:
  if ( (unsigned __int8)sub_4DB18() )
    return 0;
  if ( byte_4D41C0 && (byte_AB79EC & 8) != 0 )
  {
    v16 = 0;
    dword_4D4180 = (unsigned __int16)word_AB79F4;
    do
    {
      if ( sub_27EC8(v16) )
        dword_4D41A4[v16] = dword_4D4180;
      ++v16;
    }
    while ( v16 != 4 );
    v17 = 0;
    v18 = 0;
    v129[0] = 0;
    do
    {
      if ( sub_27EC8(v18) )
      {
        if ( sub_1C070(v18, (unsigned __int8)dword_C351C, v129) )
        {
          dword_4D41A4[v18] = 200;
        }
        else
        {
          v39 = v129[0];
          dword_4D41A4[v18] = v129[0];
          if ( v17 < v39 )
            v17 = v39;
        }
      }
      ++v18;
    }
    while ( v18 != 4 );
    if ( *v8 > 3u )
    {
      snprintf(v130, 0x2000u, "max freq in eeprom = %d\n", v17);
      sub_41DB8(3, v130, 0);
    }
    if ( v17 <= 0 )
    {
      if ( *v8 > 3u )
      {
        strcpy(v130, "failed to load freq in eeprom, using default");
        sub_41DB8(3, v130, 0);
      }
      v19 = 0;
      dword_4D4180 = 200;
      do
      {
        if ( sub_27EC8(v19) )
          dword_4D41A4[v19] = 200;
        ++v19;
      }
      while ( v19 != 4 );
    }
    else
    {
      dword_4D4180 = v17;
      v63 = 0;
      while ( !sub_27EC8(v63) || !sub_1C4E8(v63, (int)&unk_4D5398 + 1036 * v63) )
      {
        if ( ++v63 == 4 )
          goto LABEL_48;
      }
      if ( *v8 > 3u )
      {
        strcpy(v130, "eeprom_get_sweep_result error");
        sub_41DB8(3, v130, 0);
      }
    }
  }
  else
  {
    v38 = 0;
    dword_4D4180 = 200;
    do
    {
      if ( sub_27EC8(v38) )
        dword_4D41A4[v38] = 200;
      ++v38;
    }
    while ( v38 != 4 );
  }
LABEL_48:
  v20 = *v8 > 3u;
  dword_4D417C = dword_4D4180;
  if ( v20 )
  {
    snprintf(v130, 0x2000u, "fixed frequency is %d, g_frequency_offset is %d\n", dword_4D4180, dword_BC8A0);
    sub_41DB8(3, v130, 0);
  }
  v21 = (const char *)sub_27CEC();
  if ( !strcmp(v21, "HHB68701")
    || (v41 = (const char *)sub_27CEC(), !strcmp(v41, "HHB68704"))
    || (v42 = (const char *)sub_27CEC(), !strcmp(v42, "HHB68703"))
    || (v43 = (const char *)sub_27CEC(), !strcmp(v43, "H6HB68702"))
    || (v44 = (const char *)sub_27CEC(), !strcmp(v44, "H1HB68601")) )
  {
    LODWORD(flt_BC89C) = dword_4D4180 * LODWORD(flt_BC89C) / 0x1AEu;
  }
  else
  {
    v45 = (const char *)sub_27CEC();
    if ( !strcmp(v45, "HHB68502")
      || (v107 = (const char *)sub_27CEC(), !strcmp(v107, "HHB68501"))
      || (v108 = (const char *)sub_27CEC(), !strcmp(v108, "HHB68503")) )
    {
      LODWORD(flt_BC89C) = dword_4D4180 * LODWORD(flt_BC89C) / 0x19Au;
    }
  }
  if ( dword_C351C == 1 || dword_4D419C <= 0 )
  {
    sub_21D18();
    v22 = (const char *)sub_27CEC();
    if ( strcmp(v22, "HHB68502") )
    {
      v46 = (const char *)sub_27CEC();
      if ( strcmp(v46, "HHB68501") )
      {
        v47 = (const char *)sub_27CEC();
        if ( strcmp(v47, "HHB68701") )
        {
          v48 = (const char *)sub_27CEC();
          if ( strcmp(v48, "HHB68704") )
          {
            v49 = (const char *)sub_27CEC();
            if ( strcmp(v49, "HHB68703") )
            {
              v50 = (const char *)sub_27CEC();
              if ( strcmp(v50, "H6HB68702") )
              {
                v51 = (const char *)sub_27CEC();
                if ( strcmp(v51, "H1HB68601") )
                {
                  v52 = (const char *)sub_27CEC();
                  if ( strcmp(v52, "HHB68601") )
                  {
                    v53 = (const char *)sub_27CEC();
                    if ( strcmp(v53, "HHB68602") )
                    {
                      v54 = (const char *)sub_27CEC();
                      if ( strcmp(v54, "HHB56611") )
                      {
                        v55 = (const char *)sub_27CEC();
                        if ( strcmp(v55, "HHB68503") )
                          sub_168B4(0);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_44890();
  }
  else
  {
    v40 = sub_27D8C();
    if ( (unsigned __int8)sub_18AE4(v40) )
    {
      sub_2CC90(1);
      sub_473B4(0xEu, "Can't get temperature sensor type!");
    }
    else
    {
      sub_2CC90(0);
    }
  }
  v129[0] = 0;
  v23 = sub_47A48(0, &dword_4D41BC, v129);
  v24 = dword_4D4180;
  if ( v129[0] < (unsigned int)dword_4D4180 )
  {
    v24 = v129[0];
    dword_4D4180 = v129[0];
  }
  if ( v24 <= 0x31 )
    dword_4D4180 = 50;
  if ( v23 )
    return 0;
  if ( byte_C3518 )
  {
    if ( *v8 > 3u )
    {
      strcpy(v130, "press any key to start rising frequency...");
      sub_41DB8(3, v130, 0);
    }
    IO_getc((_IO_FILE *)stdin);
  }
  v25 = 0;
  pthread_mutex_lock(&stru_BDAC4);
  sub_38DE8(12000000, 0);
  pthread_mutex_unlock(&stru_BDAC4);
  sub_38914();
  sub_4B6FC();
  do
  {
    v26 = v25;
    v27 = (unsigned __int8)v25++;
    if ( sub_27EC8(v26) )
      sub_80C80(v27, 1);
  }
  while ( v25 != 4 );
  sub_18228();
  v28 = (unsigned __int8)sub_386EC();
  if ( (_BYTE)v28 )
    return 0;
  for ( i = v28; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      v30 = 0;
      v31 = &byte_65AAB8[512 * i];
      v32 = 0;
      for ( j = (_QWORD *)((char *)&unk_AB59C8 + 2048 * i); ; ++j )
      {
        v34 = v32 + v30;
        if ( v32 >= sub_282A4(i) )
          break;
        v35 = sub_27D2C();
        sub_964FC(v32, v35);
        if ( !v36 )
        {
          v37 = v32 + v30++;
          sub_28448(i, v37, 32);
          v31[v34] = 32;
          v34 = v32 + v30;
        }
        ++v32;
        sub_28448(i, v34, 111);
        v31[v34] = 111;
        *j = 0;
      }
      sub_28448(i, v32 + v30, 111);
      byte_65AAB8[512 * i + v34] = 10;
    }
  }
  v56 = sub_385D8();
  v57 = v56;
  if ( v56 )
    return 0;
  if ( byte_BC5C9 && sub_19404() <= 9 )
  {
    if ( *v8 > 4u )
    {
      strcpy(v130, "opt_bitmain_high_voltage_open_core");
      sub_41DB8(4, v130, v57);
    }
    v64 = (const char *)sub_27CEC();
    if ( strcmp(v64, "HHB68502") )
    {
      v97 = (const char *)sub_27CEC();
      if ( strcmp(v97, "HHB68501") )
      {
        v98 = (const char *)sub_27CEC();
        if ( strcmp(v98, "HHB68701") )
        {
          v99 = (const char *)sub_27CEC();
          if ( strcmp(v99, "HHB68704") )
          {
            v100 = (const char *)sub_27CEC();
            if ( strcmp(v100, "HHB68703") )
            {
              v101 = (const char *)sub_27CEC();
              if ( strcmp(v101, "H6HB68702") )
              {
                v102 = (const char *)sub_27CEC();
                if ( strcmp(v102, "H1HB68601") )
                {
                  v103 = (const char *)sub_27CEC();
                  if ( strcmp(v103, "HHB68601") )
                  {
                    v104 = (const char *)sub_27CEC();
                    if ( strcmp(v104, "HHB68602") )
                    {
                      v105 = (const char *)sub_27CEC();
                      if ( strcmp(v105, "HHB56611") )
                      {
                        v106 = (const char *)sub_27CEC();
                        if ( strcmp(v106, "HHB68503") )
                          sub_168B4(40);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v65 = (const char *)sub_27CEC();
    if ( !strcmp(v65, "HHB68502") )
      goto LABEL_157;
    v87 = (const char *)sub_27CEC();
    if ( !strcmp(v87, "HHB68501") )
      goto LABEL_157;
    v88 = (const char *)sub_27CEC();
    if ( !strcmp(v88, "HHB68701") )
      goto LABEL_157;
    v89 = (const char *)sub_27CEC();
    if ( !strcmp(v89, "HHB68704")
      || (v90 = (const char *)sub_27CEC(), !strcmp(v90, "HHB68703"))
      || (v91 = (const char *)sub_27CEC(), !strcmp(v91, "H6HB68702"))
      || (v92 = (const char *)sub_27CEC(), !strcmp(v92, "H1HB68601"))
      || (v93 = (const char *)sub_27CEC(), !strcmp(v93, "HHB68601"))
      || (v94 = (const char *)sub_27CEC(), !strcmp(v94, "HHB68602"))
      || (v95 = (const char *)sub_27CEC(), !strcmp(v95, "HHB56611"))
      || (v96 = (const char *)sub_27CEC(), !strcmp(v96, "HHB68503")) )
    {
LABEL_157:
      v66 = dword_4D41BC + 2150;
      if ( dword_4D41BC + 2150 >= 2150 )
        v66 = 2150;
    }
    else
    {
      v66 = 0;
    }
    v67 = dword_4D419C + dword_4D41BC;
    v68 = sub_18E58();
    v69 = v67 + 120;
    if ( (unsigned int)(unsigned __int16)v68 - 46 > 1 )
    {
      if ( (unsigned int)(unsigned __int16)v68 - 48 > 3 )
      {
        if ( (unsigned int)(unsigned __int16)v68 - 52 > 3 )
        {
          if ( v68 > 55 )
          {
            v69 = dword_4D419C - 46;
            v66 = dword_4D419C - 36;
          }
        }
        else
        {
          v69 = dword_4D419C - 36;
          v66 = dword_4D419C - 26;
        }
      }
      else
      {
        v69 = dword_4D419C - 25;
        v66 = dword_4D419C - 15;
      }
    }
    else
    {
      v66 = dword_4D419C;
      v69 = dword_4D419C - 10;
    }
    sub_482F8(0xBB8u, v66, v69);
  }
  else
  {
    if ( *v8 > 4u )
    {
      strcpy(v130, "normal inc freq voltage");
      sub_41DB8(4, v130, 0);
    }
    v58 = (const char *)sub_27CEC();
    if ( strcmp(v58, "HHB68502") )
    {
      v119 = (const char *)sub_27CEC();
      if ( strcmp(v119, "HHB68501") )
      {
        v120 = (const char *)sub_27CEC();
        if ( strcmp(v120, "HHB68701") )
        {
          v121 = (const char *)sub_27CEC();
          if ( strcmp(v121, "HHB68704") )
          {
            v122 = (const char *)sub_27CEC();
            if ( strcmp(v122, "HHB68703") )
            {
              v123 = (const char *)sub_27CEC();
              if ( strcmp(v123, "H6HB68702") )
              {
                v124 = (const char *)sub_27CEC();
                if ( strcmp(v124, "H1HB68601") )
                {
                  v125 = (const char *)sub_27CEC();
                  if ( strcmp(v125, "HHB68601") )
                  {
                    v126 = (const char *)sub_27CEC();
                    if ( strcmp(v126, "HHB68602") )
                    {
                      v127 = (const char *)sub_27CEC();
                      if ( strcmp(v127, "HHB56611") )
                      {
                        v128 = (const char *)sub_27CEC();
                        if ( strcmp(v128, "HHB68503") )
                          sub_168B4(40);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v59 = (const char *)sub_27CEC();
    if ( !strcmp(v59, "HHB68502") )
      goto LABEL_119;
    v109 = (const char *)sub_27CEC();
    if ( !strcmp(v109, "HHB68501") )
      goto LABEL_119;
    v110 = (const char *)sub_27CEC();
    if ( !strcmp(v110, "HHB68701") )
      goto LABEL_119;
    v111 = (const char *)sub_27CEC();
    if ( !strcmp(v111, "HHB68704")
      || (v112 = (const char *)sub_27CEC(), !strcmp(v112, "HHB68703"))
      || (v113 = (const char *)sub_27CEC(), !strcmp(v113, "H6HB68702"))
      || (v114 = (const char *)sub_27CEC(), !strcmp(v114, "H1HB68601"))
      || (v115 = (const char *)sub_27CEC(), !strcmp(v115, "HHB68601"))
      || (v116 = (const char *)sub_27CEC(), !strcmp(v116, "HHB68602"))
      || (v117 = (const char *)sub_27CEC(), !strcmp(v117, "HHB56611"))
      || (v118 = (const char *)sub_27CEC(), !strcmp(v118, "HHB68503")) )
    {
LABEL_119:
      v60 = dword_4D41BC + 2150;
      if ( dword_4D41BC + 2150 >= 2150 )
        v60 = 2150;
      if ( dword_4D41BC > 0 )
        v61 = dword_4D419C + 70 + dword_4D41BC;
      else
        v61 = dword_4D419C + 40 + dword_4D41BC / 2;
      if ( v61 >= 2150 )
        v61 = 2150;
    }
    else
    {
      v61 = 0;
      v60 = 0;
    }
    v62 = sub_18E58();
    if ( (unsigned int)(unsigned __int16)v62 - 43 <= 1 )
    {
      v60 = dword_4D419C;
      v61 = dword_4D419C - 15;
    }
    else if ( (unsigned int)(unsigned __int16)v62 - 45 > 1 )
    {
      if ( (unsigned int)(unsigned __int16)v62 - 47 > 1 )
      {
        if ( (unsigned int)(unsigned __int16)v62 - 49 > 1 )
        {
          if ( (unsigned int)(unsigned __int16)v62 - 51 > 1 )
          {
            if ( (unsigned int)(unsigned __int16)v62 - 53 > 1 )
            {
              if ( v62 > 54 )
              {
                v61 = dword_4D419C - 105;
                v60 = dword_4D419C - 90;
              }
            }
            else
            {
              v61 = dword_4D419C - 90;
              v60 = dword_4D419C - 75;
            }
          }
          else
          {
            v61 = dword_4D419C - 75;
            v60 = dword_4D419C - 60;
          }
        }
        else
        {
          v61 = dword_4D419C - 60;
          v60 = dword_4D419C - 45;
        }
      }
      else
      {
        v61 = dword_4D419C - 45;
        v60 = dword_4D419C - 30;
      }
    }
    else
    {
      v61 = dword_4D419C - 30;
      v60 = dword_4D419C - 15;
    }
    if ( v61 <= 1799 )
    {
      v61 = 1800;
      v60 = 1815;
    }
    if ( byte_4D4190 )
    {
      if ( *v8 > 3u )
      {
        snprintf(v130, 0x2000u, "stop mining %s", "bitmain_soc_init");
        sub_41DB8(3, v130, 0);
      }
      while ( 1 )
        sleep(0xAu);
    }
    v86 = sub_28694();
    sub_482F8(v86, v60, v61);
    sem_post(&stru_AB7A08);
  }
  if ( byte_BC5C0 )
    sub_38800();
  v70 = 0;
  sub_181EC();
  do
  {
    v71 = v70;
    v72 = (unsigned __int8)v70++;
    if ( sub_27EC8(v71) )
    {
      v73 = sub_27D8C();
      v74 = sub_27D1C();
      sub_7F620(v72, v73, v74);
    }
  }
  while ( v70 != 4 );
  sub_6348C();
  if ( sub_2270C() )
  {
    if ( (unsigned __int8)sub_383B0() )
      return 0;
  }
  v75 = (const char *)sub_27CEC();
  if ( !strcmp(v75, "HHB68502") )
    goto LABEL_174;
  v76 = (const char *)sub_27CEC();
  if ( !strcmp(v76, "HHB68501") )
    goto LABEL_174;
  v77 = (const char *)sub_27CEC();
  if ( !strcmp(v77, "HHB68701") )
    goto LABEL_174;
  v78 = (const char *)sub_27CEC();
  if ( !strcmp(v78, "HHB68704")
    || (v79 = (const char *)sub_27CEC(), !strcmp(v79, "HHB68703"))
    || (v80 = (const char *)sub_27CEC(), !strcmp(v80, "H6HB68702"))
    || (v81 = (const char *)sub_27CEC(), !strcmp(v81, "H1HB68601"))
    || (v82 = (const char *)sub_27CEC(), !strcmp(v82, "HHB68601"))
    || (v83 = (const char *)sub_27CEC(), !strcmp(v83, "HHB68602"))
    || (v84 = (const char *)sub_27CEC(), !strcmp(v84, "HHB56611"))
    || (v85 = (const char *)sub_27CEC(), !strcmp(v85, "HHB68503")) )
  {
LABEL_174:
    sub_18274();
  }
  if ( *v8 > 3u )
  {
    strcpy(v130, "Init done!\n");
    sub_41DB8(3, v130, 0);
  }
  return 1;
}
// 4EAA4: variable 'v36' is possibly undefined
// BC5C0: using guessed type char byte_BC5C0;
// BC5C9: using guessed type char byte_BC5C9;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC898: using guessed type int dword_BC898[];
// BC89C: using guessed type float flt_BC89C;
// BC8A0: using guessed type int dword_BC8A0;
// BDA10: using guessed type int stdin;
// C3518: using guessed type char byte_C3518;
// C351C: using guessed type int dword_C351C;
// 4D417C: using guessed type int dword_4D417C;
// 4D4180: using guessed type int dword_4D4180;
// 4D4190: using guessed type char byte_4D4190;
// 4D419C: using guessed type int dword_4D419C;
// 4D41A4: using guessed type int dword_4D41A4[4];
// 4D41BC: using guessed type int dword_4D41BC;
// 4D41C0: using guessed type char byte_4D41C0;
// 65AAB8: using guessed type _BYTE byte_65AAB8[2048];
// AB79E8: using guessed type char byte_AB79E8;
// AB79EC: using guessed type char byte_AB79EC;
// AB79F2: using guessed type char byte_AB79F2;
// AB79F4: using guessed type __int16 word_AB79F4;
// AB79F6: using guessed type __int16 word_AB79F6;
// AB7A06: using guessed type __int16 word_AB7A06;
// AB7A08: using guessed type sem_t stru_AB7A08;

//----- (0004F7A8) --------------------------------------------------------
int __fastcall sub_4F7A8(int a1)
{
  const char *v1; // r4
  FILE *v2; // r5
  FILE *v3; // r0
  FILE *v4; // r0
  FILE *v5; // r4
  FILE *v7; // r0
  int *v8; // r0
  char *v9; // r0
  int *v10; // r0
  char *v11; // r0
  int *v12; // r0
  char *v13; // r0
  int *v14; // r0
  char *v15; // r0
  int *v16; // r0
  char *v17; // r0
  int ptr; // [sp+4h] [bp-2008h] BYREF
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( a1 )
    v1 = "/config/counter";
  else
    v1 = "/tmp/counter";
  v2 = fopen(v1, "r");
  if ( !v2 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v10 = _errno_location();
      v11 = strerror(*v10);
      snprintf(s, 0x2000u, "fail to open counter file, err:%s", v11);
      sub_41DB8(3, s, 0);
    }
    v7 = fopen(v1, "w");
    v2 = v7;
    if ( !v7 )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        v8 = _errno_location();
        v9 = strerror(*v8);
        snprintf(s, 0x2000u, "can not open counter file, err:%s", v9);
        sub_41DB8(3, s, 0);
        return -1;
      }
      return -1;
    }
    ptr = 0;
    if ( fwrite(&ptr, 1u, 4u, v7) != 4 )
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_26;
      v14 = _errno_location();
      v15 = strerror(*v14);
      snprintf(s, 0x2000u, "can not write,err:%s", v15);
      goto LABEL_29;
    }
    fflush(v2);
  }
  fclose(v2);
  v3 = fopen(v1, "r");
  v2 = v3;
  if ( !v3 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "fail to w+ open counter file");
      sub_41DB8(3, s, 0);
      return -1;
    }
    return -1;
  }
  ptr = 0;
  if ( fread(&ptr, 1u, 4u, v3) != 4 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
    {
LABEL_26:
      fclose(v2);
      return -1;
    }
    v16 = _errno_location();
    v17 = strerror(*v16);
    snprintf(s, 0x2000u, "read counter file failed! err:%s\n", v17);
LABEL_29:
    sub_41DB8(3, s, 0);
    goto LABEL_26;
  }
  ++ptr;
  fclose(v2);
  v4 = fopen(v1, "w");
  v5 = v4;
  if ( !v4 )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "fail to w open counter file");
      sub_41DB8(3, s, 0);
    }
    return -1;
  }
  if ( fwrite(&ptr, 1u, 4u, v4) == 4 )
  {
    fflush(v5);
    fclose(v5);
    sleep(0x1Eu);
    return ptr;
  }
  else
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v12 = _errno_location();
      v13 = strerror(*v12);
      snprintf(s, 0x2000u, "can not write,err:%s", v13);
      sub_41DB8(3, s, 0);
    }
    fclose(v5);
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0004FB08) --------------------------------------------------------
int sub_4FB08()
{
  remove("/tmp/counter");
  return remove("/config/counter");
}

//----- (0004FB28) --------------------------------------------------------
int __fastcall sub_4FB28(int a1, int a2)
{
  int result; // r0
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  switch ( a1 )
  {
    case 0:
      snprintf((char *)dword_550418, 0x40u, "J%d:1", a2);
      break;
    case 1:
      snprintf((char *)dword_550418, 0x40u, "J%d:2", a2);
      break;
    case 2:
      snprintf((char *)dword_550418, 0x40u, "J%d:8", a2);
      break;
    case 3:
      snprintf((char *)dword_550418, 0x40u, "J%d:4", a2);
      break;
    case 4:
      snprintf((char *)dword_550418, 0x40u, "J%d:5", a2);
      break;
    case 5:
      dword_550418[0] = (int)&unk_313A52;
      break;
    case 6:
      dword_550418[0] = (int)&unk_323A52;
      break;
    case 7:
      snprintf((char *)dword_550418, 0x40u, "T:%d", a2);
      break;
    case 8:
      dword_550418[0] = (int)&unk_313A50;
      break;
    case 9:
      dword_550418[0] = (int)&unk_323A50;
      break;
    case 10:
      dword_550418[0] = (int)&unk_313A46;
      break;
    case 11:
      snprintf((char *)dword_550418, 0x40u, "J%d:6", a2);
      break;
    case 12:
      dword_550418[0] = (int)&unk_313A56;
      break;
    case 13:
      dword_550418[0] = (int)&unk_313A4D;
      break;
    case 14:
      dword_550418[0] = (int)&unk_313A4E;
      break;
    case 15:
      dword_550418[0] = (int)&unk_343A50;
      break;
    case 17:
      dword_550418[0] = (int)&unk_333A52;
      break;
    case 18:
      dword_550418[0] = (int)&unk_313A43;
      break;
    case 19:
      dword_550418[0] = (int)&unk_323A4E;
      break;
    case 20:
      dword_550418[0] = (int)&unk_303A53;
      break;
    case 21:
      dword_550418[0] = (int)&unk_333A4E;
      break;
    case 22:
      dword_550418[0] = (int)&unk_353A50;
      break;
    case 23:
      snprintf((char *)dword_550418, 0x40u, "L%d:1", a2);
      break;
    case 24:
      snprintf((char *)dword_550418, 0x40u, "L%d:2", a2);
      break;
    case 25:
      dword_550418[0] = (int)&unk_323A56;
      break;
    case 26:
      dword_550418[0] = (int)&unk_333A56;
      break;
    default:
      strcpy((char *)dword_550418, "unknown");
      break;
  }
  result = sub_509C0(1);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(v3, 0x2000u, "Sweep error string = %s.\n", (const char *)dword_550418);
    return sub_41DB8(3, v3, 0);
  }
  return result;
}
// 4FB3C: control flows out of bounds to 4FB40
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550418: using guessed type int dword_550418[16];

//----- (0004FED0) --------------------------------------------------------
int *sub_4FED0()
{
  return &dword_550418;
}
// 550418: using guessed type int dword_550418;

//----- (0004FEDC) --------------------------------------------------------
int __fastcall sub_4FEDC(int a1)
{
  return 3000 * ((a1 - 2000) / 3000) + 2000;
}

//----- (0004FF0C) --------------------------------------------------------
void __noreturn sub_4FF0C()
{
  int v0; // r0
  unsigned int v1; // r8
  int v2; // r4
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v3, "[DEBUG] Recv nonce and register.\n");
    sub_41DB8(4, v3, 0);
  }
  v0 = sub_63E74();
  sub_63EA0(v0 | 0x10000);
  sub_3DE28();
  while ( 1 )
  {
    v1 = ((unsigned int)sub_6352C() >> 1) & 0x7FF;
    if ( v1 )
      break;
LABEL_12:
    usleep(0x3E8u);
  }
  v2 = 0;
  while ( 1 )
  {
    sub_635B4(v3);
    if ( v3[3] < 0 )
      break;
    if ( (unsigned int)dword_66C4F8 <= 0xFFE && dword_66C4F0[0] <= 0xFFEu )
    {
      sub_534AC((int)v3);
LABEL_7:
      if ( v1 == ++v2 )
        goto LABEL_12;
    }
    else
    {
      ++v2;
      sub_3DE28();
      if ( v1 == v2 )
        goto LABEL_12;
    }
  }
  sub_5339C();
  goto LABEL_7;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 66C4F0: using guessed type int dword_66C4F0[];
// 66C4F8: using guessed type int dword_66C4F8;

//----- (00050000) --------------------------------------------------------
int sub_50000()
{
  int v0; // r8
  int i; // r5
  int v2; // r4
  int v3; // r2
  float v4; // s12
  float v5; // s14
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v0 = 0;
  for ( i = 0; i != 4; ++i )
  {
    v2 = 4 * (i + 1032);
    if ( sub_27EC8(i) )
    {
      v3 = dword_550458;
      v4 = *(float *)(dword_550458 + v2);
      v5 = *(float *)(*(_DWORD *)(dword_550458 + 8) + 20);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "chain = %d, nonce_rate_max = %.4f, nonce_rate_threshold = %.4f\n", i, v4, v5);
        sub_41DB8(3, s, 0);
        v3 = dword_550458;
        v4 = *(float *)(dword_550458 + v2);
        v5 = *(float *)(*(_DWORD *)(dword_550458 + 8) + 20);
      }
      if ( v4 < v5 )
      {
        v0 = 1;
        *(_DWORD *)(v3 + 4 * (i + 1040)) = 1;
      }
    }
  }
  return v0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550458: using guessed type int dword_550458;

//----- (000500E8) --------------------------------------------------------
unsigned int __fastcall sub_500E8(int a1)
{
  unsigned int v1; // r6
  int v2; // r10
  int i; // r4
  int v5; // r9
  int v6; // r7
  int j; // r5
  int v8; // t1

  v1 = 0;
  v2 = a1 - 4;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      v5 = sub_27D1C();
      if ( v5 )
      {
        v6 = v2 + (i << 10);
        for ( j = 0; j != v5; ++j )
        {
          v8 = *(_DWORD *)(v6 + 4);
          v6 += 4;
          v1 += v8 * sub_27D5C();
        }
      }
    }
  }
  return v1 / 0x3E8;
}

//----- (00050158) --------------------------------------------------------
void sub_50158()
{
  char v0[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v0, "[DEBUG] Sweep exit.\n");
    sub_41DB8(4, v0, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for sweep.\n");
      sub_41DB8(4, v0, 0);
    }
  }
  if ( dword_550458 )
  {
    free((void *)dword_550458);
    dword_550458 = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550458: using guessed type int dword_550458;

//----- (00050208) --------------------------------------------------------
int __fastcall sub_50208(int **a1, int a2, int a3)
{
  int v5; // r8
  int result; // r0
  int v7; // r12
  int v8; // r2
  int v9; // r3
  unsigned int v10; // r9
  int i; // r5
  int v12; // r0
  int v13; // r0
  int v14; // r3
  unsigned int v15; // r2
  unsigned int v16; // t1
  unsigned int v17; // r5
  int j; // r10
  int v19; // r0
  int v20; // r0
  int v21; // r3
  unsigned int v22; // r2
  unsigned int v23; // t1
  int v24; // r10
  char *v25; // r9
  int v26; // r5
  char *v27; // r10
  int v28; // r5
  int v30; // r0
  int v31; // lr
  int v32; // r1
  char *v33; // r12
  int v34; // r3
  int v35; // t1
  int v36; // t1
  bool v37; // cc
  int v38; // [sp+Ch] [bp-2010h]
  unsigned int v39; // [sp+14h] [bp-2008h] BYREF
  _WORD s[4098]; // [sp+18h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    s[0] = 10;
    sub_42CB4(3, (const char *)s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf((char *)s, 0x2000u, ">>>> Get ideal hash rate, round %d.\n", a3);
      sub_41DB8(3, (const char *)s, 0);
    }
  }
  v5 = sub_54338(a2);
  if ( v5 )
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return v5;
    strcpy((char *)s, "Board init failed.\n");
    sub_41DB8(3, (const char *)s, 0);
    return v5;
  }
  else
  {
    sub_53E00();
    v7 = **a1;
    v8 = (*a1)[4];
    if ( v7 > v8 )
    {
      **a1 = v8;
      v7 = **a1;
    }
    v9 = *(_DWORD *)(dword_550458 + 8);
    dword_55045C = v7;
    sub_246E8(dword_550458 + 12, (unsigned __int8)byte_4D4184, *(unsigned __int8 *)(v9 + 8));
    if ( sub_2242C() == dword_55045C || (result = sub_21E88(dword_55045C, 3u)) == 0 )
    {
      v10 = 0xFFFFFF;
      for ( i = 0; i != 4; ++i )
      {
        if ( sub_27EC8(i) )
        {
          v12 = sub_27D1C();
          if ( v12 )
          {
            v13 = dword_550458 + 8 + 4 * (v12 + (i << 8));
            v14 = dword_550458 + (i << 10) + 8;
            do
            {
              v16 = *(_DWORD *)(v14 + 4);
              v14 += 4;
              v15 = v16;
              if ( v10 >= v16 )
                v10 = v15;
            }
            while ( v14 != v13 );
          }
        }
      }
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf((char *)s, 0x2000u, "chain = %d, freq_min = %d\n", 255, v10);
        sub_41DB8(3, (const char *)s, 0);
      }
      v17 = 0;
      for ( j = 0; j != 4; ++j )
      {
        if ( sub_27EC8(j) )
        {
          v19 = sub_27D1C();
          if ( v19 )
          {
            v20 = dword_550458 + 8 + 4 * (v19 + (j << 8));
            v21 = dword_550458 + (j << 10) + 8;
            do
            {
              v23 = *(_DWORD *)(v21 + 4);
              v21 += 4;
              v22 = v23;
              if ( v17 < v23 )
                v17 = v22;
            }
            while ( v21 != v20 );
          }
        }
      }
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf((char *)s, 0x2000u, "chain = %d, freq_max = %d\n", 255, v17);
        sub_41DB8(3, (const char *)s, 0);
      }
      v24 = 0;
      v39 = v17;
      sub_48690(v10, dword_BC5A4, 20);
      do
      {
        if ( sub_27EC8(v24) )
          sub_539B0(v24, 1);
        ++v24;
      }
      while ( v24 != 4 );
      v25 = 0;
      sub_54D68((int)&v39);
      v26 = sub_53578();
      do
      {
        if ( sub_27EC8((int)v25) )
          sub_543D8(v25, v26);
        ++v25;
      }
      while ( v25 != (char *)4 );
      v27 = (char *)&unk_808FFC + v26;
      v28 = 0;
      v38 = 0;
      do
      {
        if ( sub_27EC8(v28) )
        {
          v30 = sub_27D1C();
          if ( v30 )
          {
            v31 = dword_550458 + 8 + 4 * (v30 + (v28 << 8));
            v30 = 0;
            v32 = dword_550458 + (v28 << 10) + 8;
            v33 = &v27[1024 * v28];
            do
            {
              v35 = *(_DWORD *)(v32 + 4);
              v32 += 4;
              v34 = v35;
              v36 = *((_DWORD *)v33 + 1);
              v33 += 4;
              v30 += v36 * v34 / 0x1F40u;
            }
            while ( v31 != v32 );
            v38 += v30;
          }
          v37 = (unsigned int)off_BC5EC > 3;
          *(_DWORD *)(dword_550458 + 4 * (v28 + 1026) + 4) = v30;
          if ( v37 )
          {
            snprintf((char *)s, 0x2000u, "chain = %d, ideal_hash_rate_GH = %d\n", v28, v30);
            sub_41DB8(3, (const char *)s, 0);
          }
        }
        ++v28;
      }
      while ( v28 != 4 );
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf((char *)s, 0x2000u, "hash_rate_total_GH = %d\n", v38);
        sub_41DB8(3, (const char *)s, 0);
      }
      return v5;
    }
  }
  return result;
}
// BC5A4: using guessed type int dword_BC5A4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 4D4184: using guessed type char byte_4D4184;
// 550458: using guessed type int dword_550458;
// 55045C: using guessed type int dword_55045C;

//----- (0005066C) --------------------------------------------------------
_DWORD *__fastcall sub_5066C(_DWORD *result)
{
  *result = 3000;
  result[1] = 2000;
  result[2] = 327388;
  return result;
}

//----- (00050688) --------------------------------------------------------
int __fastcall sub_50688(int result)
{
  dword_55045C = result;
  return result;
}
// 55045C: using guessed type int dword_55045C;

//----- (00050698) --------------------------------------------------------
int sub_50698()
{
  return dword_55045C;
}
// 55045C: using guessed type int dword_55045C;

//----- (000506AC) --------------------------------------------------------
int sub_506AC()
{
  return sub_21E88(dword_55045C, 3u);
}
// 55045C: using guessed type int dword_55045C;

//----- (000506C0) --------------------------------------------------------
int sub_506C0()
{
  FILE *v0; // r4
  int result; // r0
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  v0 = fopen("/config/scanfreqdone", "r");
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v2, "[DEBUG] Check if sweep is already done.\n");
    sub_41DB8(4, v2, 0);
  }
  result = (int)v0;
  if ( v0 )
  {
    fclose(v0);
    return 1;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00050748) --------------------------------------------------------
int __fastcall sub_50748(int a1)
{
  unsigned int v3; // r8
  _DWORD *v4; // r7
  int v5; // r5
  char *v6; // lr
  char *v7; // r12
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _DWORD *v12; // lr
  char *v13; // r12
  int v14; // r1
  int v15; // r2
  int v16; // r0
  int v17; // r2
  int v18; // r3
  __time_t v19[2]; // [sp+0h] [bp-2008h] BYREF
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  if ( !sub_506C0() )
  {
    sub_4465C(v19);
    v3 = a1 - 160;
    dword_550460 = 2;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "[DEBUG] Sweep init, sweep_type = 0x%X.\n", a1);
      sub_41DB8(4, s, 0);
      if ( v3 > 1 )
        goto LABEL_7;
      if ( (unsigned int)off_BC5EC > 4 )
      {
        strcpy(s, "[DEBUG] Allocate memory for sweep.\n");
        sub_41DB8(4, s, 0);
      }
    }
    else if ( v3 > 1 )
    {
LABEL_7:
      sub_4FB28(20, 255);
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_8;
      v6 = "Sweep type error, exit.\n";
      v7 = s;
      goto LABEL_18;
    }
    v4 = (_DWORD *)dword_550458;
    if ( dword_550458 || (v4 = calloc(0x107Cu, 1u), (dword_550458 = (int)v4) != 0) )
    {
      v5 = 0;
      *v4 = a1;
      v4[1] = 1199570688;
      do
      {
        if ( sub_27EC8(v5) )
        {
          v16 = sub_27D1C();
          if ( v16 > 0 )
          {
            v17 = dword_550458 + 8 + 4 * (v16 + (v5 << 8));
            v18 = dword_550458 + (v5 << 10) + 8;
            do
            {
              *(_DWORD *)(v18 + 4) = 300;
              v18 += 4;
            }
            while ( v18 != v17 );
          }
        }
        ++v5;
      }
      while ( v5 != 4 );
      goto LABEL_8;
    }
    sub_4FB28(13, 255);
    if ( (unsigned int)off_BC5EC <= 3 )
    {
LABEL_8:
      dword_550460 = 1;
      return -1;
    }
    v6 = " memory for sweep ctxt.\n";
    qmemcpy(s, "Fail to allocate", 16);
    v7 = &s[16];
LABEL_18:
    v8 = *(_DWORD *)v6;
    v9 = *((_DWORD *)v6 + 1);
    v10 = *((_DWORD *)v6 + 2);
    v11 = *((_DWORD *)v6 + 3);
    v12 = v6 + 16;
    *(_DWORD *)v7 = v8;
    *((_DWORD *)v7 + 1) = v9;
    *((_DWORD *)v7 + 2) = v10;
    *((_DWORD *)v7 + 3) = v11;
    v13 = v7 + 16;
    v14 = v12[1];
    v15 = v12[2];
    *(_DWORD *)v13 = *v12;
    *((_DWORD *)v13 + 1) = v14;
    v13[8] = v15;
    sub_41DB8(3, s, 0);
    goto LABEL_8;
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "Sweep already done, exit.\n");
    sub_41DB8(3, s, 0);
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550458: using guessed type int dword_550458;
// 550460: using guessed type int dword_550460;

//----- (000509A0) --------------------------------------------------------
int __fastcall sub_509A0(_DWORD *a1)
{
  *a1 = 1000;
  return 0;
}

//----- (000509B0) --------------------------------------------------------
int sub_509B0()
{
  return dword_550460;
}
// 550460: using guessed type int dword_550460;

//----- (000509C0) --------------------------------------------------------
int __fastcall sub_509C0(int result)
{
  dword_550460 = result;
  return result;
}
// 550460: using guessed type int dword_550460;

//----- (000509D4) --------------------------------------------------------
int sub_509D4()
{
  char v1[8200]; // [sp-2008h] [bp-2008h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "[DEBUG] Get stats.\n");
    sub_41DB8(4, v1, 0);
  }
  return dword_550464 + 8;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (00050A50) --------------------------------------------------------
bool __fastcall sub_50A50(int a1)
{
  unsigned int v2; // r5
  int v3; // r4
  char v5[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v5, 0x2000u, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", a1);
    sub_41DB8(4, v5, 0);
  }
  v2 = *(_DWORD *)(dword_550464 + 4 * ((_DWORD)&unk_202802 + a1));
  v3 = 8 * sub_27D5C();
  return v2 >= sub_27D1C() * v3;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (00050AE8) --------------------------------------------------------
int __fastcall sub_50AE8(int a1)
{
  int v1; // r9
  int v2; // r7
  int v3; // r4
  char *v4; // r11
  unsigned int v5; // r10
  unsigned int v6; // s16
  int v8; // [sp+0h] [bp-201Ch]
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "[DEBUG] Check if is unbalanche happen, chain = %d\n", a1);
    sub_41DB8(4, s, 0);
  }
  v1 = sub_27D1C();
  if ( v1 )
  {
    v3 = 0;
    v2 = 0;
    while ( 1 )
    {
      v4 = (char *)&unk_202402 + 256 * a1 + v3;
      v5 = *(_DWORD *)(dword_550464 + 4 * (_DWORD)v4);
      if ( v5 > 8 * sub_27D5C() )
      {
        v2 = 1;
        if ( (unsigned int)off_BC5EC <= 3 )
          goto LABEL_7;
LABEL_11:
        v8 = v3++;
        snprintf(s, 0x2000u, "Unbalance happened: chain = %d, asic = %d\n", a1, v8);
        v2 = 1;
        sub_41DB8(3, s, 0);
        if ( v1 == v3 )
          return v2;
      }
      else
      {
        v6 = *(_DWORD *)(dword_550464 + 4 * (_DWORD)v4);
        if ( (double)v6 < (double)(8 * sub_27D5C()) * 0.75 )
        {
          v2 = 1;
          if ( (unsigned int)off_BC5EC > 3 )
            goto LABEL_11;
        }
LABEL_7:
        if ( v1 == ++v3 )
          return v2;
      }
    }
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (00050C4C) --------------------------------------------------------
int sub_50C4C()
{
  int v0; // r4
  int v1; // r0
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v3, "[DEBUG] HW sweep reset.\n");
    sub_41DB8(4, v3, 0);
  }
  v0 = 0;
  sub_2A834(255, 0);
  do
  {
    if ( sub_27EC8(v0) )
      sub_80670((unsigned __int8)v0);
    ++v0;
  }
  while ( v0 != 4 );
  v1 = sub_62EC4();
  return sub_62EF8(v1 & 0xFFFF70FF | 0x8400);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00050CEC) --------------------------------------------------------
void *sub_50CEC()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "[DEBUG] HW sweep clear stats.\n");
    sub_41DB8(4, v1, 0);
  }
  return memset((void *)(dword_550464 + 8), 0, (size_t)&unk_80A8A4);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (00050D70) --------------------------------------------------------
int sub_50D70()
{
  int v0; // r4
  int result; // r0
  unsigned int s[2048]; // [sp+28h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy((char *)s, "[DEBUG] Send 1-midstate work.\n");
    sub_41DB8(4, (const char *)s, 0);
  }
  v0 = 0;
  memset(s, 0, 0x34u);
  LOBYTE(s[0]) = 1;
  do
  {
    result = sub_27EC8(v0);
    if ( result )
    {
      while ( (sub_63798() & (1 << v0)) == 0 )
        sub_44890();
      BYTE1(s[0]) = v0 | 0x80;
      sub_2A44C(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8]);
      result = sub_44890();
    }
    ++v0;
  }
  while ( v0 != 4 );
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00050E74) --------------------------------------------------------
void sub_50E74()
{
  void *v0; // r0
  char v1[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "[DEBUG] Free memory for hw sweep.\n");
    sub_41DB8(4, v1, 0);
  }
  v0 = (void *)dword_550464;
  if ( dword_550464 )
  {
    if ( *(_DWORD *)(dword_550464 + 4) )
    {
      free(*(void **)(dword_550464 + 4));
      v0 = (void *)dword_550464;
    }
    free(v0);
    dword_550464 = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (00050F10) --------------------------------------------------------
void sub_50F10()
{
  char v0[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v0, "[DEBUG] HW sweep exit.\n");
    sub_41DB8(4, v0, 0);
  }
  sub_50E74();
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00050F6C) --------------------------------------------------------
int sub_50F6C()
{
  _DWORD *v1; // r6
  void *v2; // r5
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v3, "[DEBUG] HW sweep init.\n");
    sub_41DB8(4, v3, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v3, "[DEBUG] Allocate memory for hw sweep.\n");
      sub_41DB8(4, v3, 0);
    }
  }
  if ( dword_550464 )
    return 0;
  v1 = calloc((size_t)&unk_8154AC, 1u);
  dword_550464 = (int)v1;
  if ( !v1 )
  {
    sub_4FB28(13, 255);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v3, "Fail to allocate memory for hw sweep ctxt.\n");
      sub_41DB8(3, v3, 0);
      return -1;
    }
    return -1;
  }
  v2 = malloc(0x400u);
  v1[1] = v2;
  if ( !v2 )
  {
    sub_50E74();
    sub_4FB28(13, 255);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v3, "Fail to allocate memory for hw sweep private data.\n");
      sub_41DB8(3, v3, 0);
    }
    return -1;
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (00051110) --------------------------------------------------------
int __fastcall sub_51110(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // r9
  int v6; // r6
  int v7; // r5
  unsigned __int16 v10; // r11
  int v11; // r10
  int v12; // r0
  int v13; // r1
  int *v14; // r2
  int v15; // r3
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int v19; // r9
  int result; // r0
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v4 = a1 << 8;
  v6 = HIWORD(a3);
  v7 = a4 + 4 * ((a1 << 8) + a2) + 0x800000;
  v10 = a3;
  v11 = *(_DWORD *)(dword_550464 + 4);
  *(_DWORD *)(a4 + 4 * ((a1 << 8) + a2) + 8425472) += HIWORD(a3);
  v12 = sub_27D5C();
  v15 = 4 * a1;
  if ( v6 <= 8 * v12 )
    v14 = (int *)(a4 + v15);
  v16 = a4 + v15;
  if ( v6 <= 8 * v12 )
    v14 += 0x200000;
  v17 = v16 + 0x800000;
  if ( v6 <= 8 * v12 )
    v14 += 10240;
  v18 = v17 + 40960;
  if ( v6 <= 8 * v12 )
    v13 = *v14;
  v19 = v11 + v4;
  if ( v6 <= 8 * v12 )
    *v14 = v13 + v6;
  *(_DWORD *)(v18 + 2144) += v10 - v6;
  *(_BYTE *)(v19 + a2) = 1;
  result = sub_27D5C();
  if ( v6 > 8 * result && (unsigned int)off_BC5EC > 3 )
  {
    snprintf(
      s,
      0x2000u,
      "Nonce counter overflow: chain = %d, asic = %d, nonce_return = %d, nonce_match = %d, nonce_accumulate = %d\n",
      a1,
      a2,
      v10,
      v6,
      *(_DWORD *)(v7 + 36864));
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// 51178: variable 'v14' is possibly undefined
// 51194: variable 'v13' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (00051224) --------------------------------------------------------
char *__fastcall sub_51224(int a1)
{
  int v2; // r6
  unsigned int v3; // r5
  int v4; // r0
  char *result; // r0
  int v6; // r7
  int v7; // r8
  unsigned int v8; // r6

  v2 = *(unsigned __int8 *)(a1 + 2);
  v3 = *(_BYTE *)a1 & 0xF;
  v4 = sub_27D8C();
  if ( v3 > 3 )
    return sub_53434((char *)a1);
  v6 = v4;
  v7 = *(unsigned __int8 *)(a1 + 1);
  if ( !sub_27EC8(v3) )
    return sub_53434((char *)a1);
  v8 = sub_96518(v2, v6);
  result = (char *)sub_27D1C();
  if ( (unsigned int)result <= v8 )
    return sub_53434((char *)a1);
  if ( v7 != 208 )
  {
    if ( v7 == 224 )
      return (char *)sub_51110(v3, v8, *(_DWORD *)(a1 + 4), dword_550464 + 8);
    return sub_53434((char *)a1);
  }
  if ( (*(_DWORD *)(a1 + 4) & 0x88) != 0 )
    *(_BYTE *)(*(_DWORD *)(dword_550464 + 4) + (v3 << 8) + v8) = 1;
  return result;
}
// 550464: using guessed type int dword_550464;

//----- (000512E4) --------------------------------------------------------
bool __fastcall sub_512E4(int a1)
{
  int v2; // r4
  int v3; // r5
  unsigned __int8 *v4; // r0
  unsigned __int8 *v5; // r2
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v2 = *(_DWORD *)(dword_550464 + 4);
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "[DEBUG] Check if read reg done, chain = %d, done_threshold = %d.\n", a1, 1);
    sub_41DB8(4, s, 0);
  }
  v3 = sub_27D1C();
  if ( v3 )
  {
    v4 = (unsigned __int8 *)(v2 + (a1 << 8));
    v5 = &v4[v3];
    v3 = 0;
    do
    {
      if ( *v4++ )
        ++v3;
    }
    while ( v4 != v5 );
  }
  return sub_27D1C() == v3;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (00051394) --------------------------------------------------------
bool sub_51394()
{
  int v0; // r4
  _BOOL4 result; // r0

  v0 = 0;
  while ( 1 )
  {
    if ( sub_27EC8(v0) )
    {
      result = sub_512E4(v0);
      if ( !result )
        break;
    }
    if ( ++v0 == 4 )
      return 1;
  }
  return result;
}

//----- (000513D4) --------------------------------------------------------
int __fastcall sub_513D4(int a1, int *a2)
{
  int v3; // r0
  void *v4; // r3
  int v5; // r12
  int v6; // r10
  _DWORD *v7; // r9
  int v8; // r0
  int v9; // r4
  int v10; // r4
  int v11; // r0
  int i; // r4
  int v13; // r4
  signed int v14; // r5
  int j; // r8
  __useconds_t v16; // r5
  int v17; // r6
  int k; // r4
  int v19; // r4
  int v20; // r9
  int m; // r4
  int v23; // r7
  int v24; // r5
  unsigned __int8 *v25; // r6
  int v26; // t1
  char v27; // r0
  bool v28; // cc
  int v29[19]; // [sp+0h] [bp-68h] BYREF
  __useconds_t useconds; // [sp+4Ch] [bp-1Ch]
  _DWORD *v31; // [sp+50h] [bp-18h]
  int v32; // [sp+54h] [bp-14h]
  int v33; // [sp+58h] [bp-10h]
  int v34; // [sp+5Ch] [bp-Ch]
  __int16 v35; // [sp+64h] [bp-4h]
  char v36; // [sp+66h] [bp-2h]
  unsigned int v37[2049]; // [sp+68h] [bp+0h] BYREF

  v31 = &off_BC5EC;
  v3 = sub_4A75C(3u);
  v4 = off_BC5EC;
  v5 = *a2;
  v32 = BYTE1(v3);
  v34 = v5;
  v35 = v3;
  v36 = BYTE2(v3);
  v33 = BYTE2(v3);
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf((char *)v37, 0x2000u, "[DEBUG] Send work, max_freq = %d\n", v5);
    sub_41DB8(4, (const char *)v37, 0);
    v4 = (void *)*v31;
  }
  v6 = 3;
  useconds = (__useconds_t)&loc_186A0;
  v7 = v31;
  if ( (unsigned int)v4 > 4 )
    goto LABEL_15;
  while ( 1 )
  {
    sub_5A87C(24, 0);
    v8 = sub_62EC4();
    v9 = 0;
    sub_62EF8(v8 & 0xFFFF70FF | 0x8400);
    do
    {
      if ( sub_27EC8(v9) )
        sub_7F5B0((unsigned __int8)v9, 1, 0);
      ++v9;
    }
    while ( v9 != 4 );
    if ( *v7 > 4u )
    {
      strcpy((char *)v37, "[DEBUG] Send null work.\n");
      sub_41DB8(4, (const char *)v37, 0);
    }
    v10 = 0;
    memset(v37, 0, 0x54u);
    LOBYTE(v37[0]) = 1;
    do
    {
      if ( sub_27EC8(v10) )
      {
        while ( (sub_63798() & (1 << v10)) == 0 )
          sub_44890();
        BYTE1(v37[0]) = v10 | 0x80;
        memcpy(v29, &v37[4], 0x44u);
        sub_2A514(
          v37[0],
          v37[1],
          v37[2],
          v37[3],
          v29[0],
          v29[1],
          v29[2],
          v29[3],
          v29[4],
          v29[5],
          v29[6],
          v29[7],
          v29[8],
          v29[9],
          v29[10],
          v29[11],
          v29[12]);
        sub_44890();
      }
      ++v10;
    }
    while ( v10 != 4 );
    sleep(1u);
    v11 = sub_62EC4();
    sub_62EF8(v11 & 0xFFFF70FF | 0x8100);
    usleep(useconds);
    if ( !--v6 )
      break;
    if ( *v7 > 4u )
    {
LABEL_15:
      strcpy((char *)v37, "[DEBUG] Set start nonce offset invalid.\n");
      sub_41DB8(4, (const char *)v37, 0);
    }
  }
  sub_2A834(255, 1);
  sub_2A628(255, v32, v33, 1);
  sub_50D70();
  usleep(0x186A0u);
  sub_50D70();
  usleep(0x186A0u);
  sub_50D70();
  usleep(0x186A0u);
  do
  {
    if ( sub_27EC8(v6) )
      sub_7FFC0((unsigned __int8)v6, 0);
    ++v6;
  }
  while ( v6 != 4 );
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
      sub_80670((unsigned __int8)i);
  }
  v13 = 3;
  v14 = 30000 - (v34 - 250) / 0x14u;
  do
  {
    for ( j = 0; j != 4; ++j )
    {
      if ( sub_27EC8(j) )
        sub_80778((unsigned __int8)j, v14 / 333);
    }
    usleep((__useconds_t)&loc_186A0);
    --v13;
  }
  while ( v13 );
  do
  {
    if ( sub_27EC8(v13) )
      sub_8079C((unsigned __int8)v13, 8);
    ++v13;
  }
  while ( v13 != 4 );
  v16 = v14 + 1000;
  v17 = 8;
  do
  {
    for ( k = 0; k != 4; ++k )
    {
      if ( sub_27EC8(k) )
        sub_807D4((unsigned __int8)k);
    }
    usleep(v16);
    --v17;
  }
  while ( v17 );
  sub_50D70();
  usleep(0x186A0u);
  sub_50D70();
  usleep(0x186A0u);
  sub_50D70();
  usleep(0x186A0u);
  sub_2A628(255, v32, v33, 0);
  if ( *v31 > 4u )
  {
    strcpy((char *)v37, "[DEBUG] Get nonce counter, chain.\n");
    sub_41DB8(4, (const char *)v37, 0);
    v28 = *v31 > 4u;
    useconds = *(_DWORD *)(dword_550464 + 4);
    if ( v28 )
    {
      snprintf((char *)v37, 0x2000u, "[DEBUG] Read reg and wait done, reg = %d, done_threshold = %d.\n", 224, 1);
      sub_41DB8(4, (const char *)v37, 0);
    }
  }
  else
  {
    useconds = *(_DWORD *)(dword_550464 + 4);
  }
  memset((void *)useconds, 0, 0x400u);
  v19 = 5;
  sub_2A220(255, 1, 0, 224);
  while ( !sub_51394() )
  {
    usleep((__useconds_t)&loc_186A0);
    if ( !--v19 )
    {
      v20 = 95;
      while ( 1 )
      {
        for ( m = 0; m != 4; ++m )
        {
          if ( sub_27EC8(m) )
          {
            v23 = sub_27D1C();
            if ( v23 )
            {
              v24 = 0;
              v25 = (unsigned __int8 *)(useconds + (m << 8));
              do
              {
                v26 = *v25++;
                if ( v26 != 1 )
                {
                  v27 = sub_27D8C();
                  sub_2A220((unsigned __int8)m, 0, v27 * v24, 224);
                }
                ++v24;
              }
              while ( v23 != v24 );
            }
          }
        }
        usleep((__useconds_t)&loc_186A0);
        if ( sub_51394() )
          break;
        if ( !--v20 )
        {
          if ( *v31 > 3u )
          {
            snprintf((char *)v37, 0x2000u, "Read REG[0x%X] done failed.\n", 224);
            sub_41DB8(3, (const char *)v37, 0);
          }
          return -1;
        }
      }
      return 0;
    }
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550464: using guessed type int dword_550464;

//----- (000519DC) --------------------------------------------------------
char **sub_519DC()
{
  char v1[8200]; // [sp-2008h] [bp-2008h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "[DEBUG] Get hw ops.\n");
    sub_41DB8(4, v1, 0);
  }
  return &off_BCCF4;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BCCF4: using guessed type char *off_BCCF4;

//----- (00051A50) --------------------------------------------------------
int sub_51A50()
{
  return dword_550468 + 8;
}
// 550468: using guessed type int dword_550468;

//----- (00051A64) --------------------------------------------------------
bool __fastcall sub_51A64(int a1)
{
  unsigned int v2; // r5
  int v3; // r4
  char v5[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v5, 0x2000u, "[DEBUG] Check if is recv nonce enough, chain = %d.\n", a1);
    sub_41DB8(4, v5, 0);
  }
  v2 = *(_DWORD *)(dword_550468 + 4 * ((_DWORD)&unk_202802 + a1));
  v3 = 8 * sub_27D5C();
  return v2 >= sub_27D1C() * v3;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550468: using guessed type int dword_550468;

//----- (00051AFC) --------------------------------------------------------
int __fastcall sub_51AFC(int a1)
{
  unsigned int v2; // r4
  unsigned int v3; // r0
  unsigned int v4; // r4
  unsigned int v5; // r0
  unsigned int v6; // r7
  int v7; // r10
  int i; // r5
  unsigned int j; // r4
  unsigned int v10; // r2
  int v12; // [sp+14h] [bp-2008h]
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v2 = *(_DWORD *)(dword_550468 + 4 * (a1 + 2107394));
  v3 = sub_27D0C();
  v4 = sub_962A0(v2, v3);
  v5 = sub_27D7C();
  v6 = sub_962A0(v4, v5) >> 1;
  v12 = sub_27D0C();
  if ( !v12 )
    return 0;
  v7 = 0;
  for ( i = 0; i != v12; ++i )
  {
    for ( j = 0; sub_27D7C() > j; ++j )
    {
      v10 = j + i * sub_27D7C();
      if ( *(_DWORD *)(dword_550468 + 4 * ((_DWORD)&unk_202806 + 64 * a1 + v10)) < v6 )
      {
        v7 = 1;
        if ( (unsigned int)off_BC5EC > 3 )
        {
          snprintf(
            s,
            0x2000u,
            "Domain unbalance happen, chain = %d, domain = %d, nonce_num_domain = %d, threshold = %d.\n",
            a1,
            v10,
            *(_DWORD *)(dword_550468 + 4 * ((_DWORD)&unk_202806 + 64 * a1 + v10)),
            v6);
          sub_41DB8(3, s, 0);
        }
      }
    }
  }
  return v7;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550468: using guessed type int dword_550468;

//----- (00051C20) --------------------------------------------------------
void *sub_51C20()
{
  return memset((void *)(dword_550468 + 8), 0, (size_t)&unk_80A8A4);
}
// 550468: using guessed type int dword_550468;

//----- (00051C40) --------------------------------------------------------
int __fastcall sub_51C40(int a1)
{
  int v1; // r9
  unsigned int v2; // r6
  int v3; // r10
  _DWORD *v4; // r4
  _DWORD *v5; // r5
  _DWORD *v6; // r4
  int v7; // r0
  int v8; // lr
  _DWORD *v9; // r12
  int v10; // r1
  int v11; // r2
  _DWORD *v12; // lr
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r3
  int v17; // r4
  char *v18; // r7
  _BYTE *v19; // r6
  int v20; // r5
  bool v21; // zf
  _BYTE *v22; // r1
  char *v23; // r0
  int v24; // r4
  int v25; // r3
  int v27[17]; // [sp+0h] [bp-150h] BYREF
  int v28; // [sp+4Ch] [bp-104h]
  _DWORD *v29; // [sp+50h] [bp-100h]
  _DWORD *v30; // [sp+54h] [bp-FCh]
  unsigned int v31; // [sp+58h] [bp-F8h]
  int v32; // [sp+5Ch] [bp-F4h]
  int v33; // [sp+60h] [bp-F0h]
  _DWORD *v34; // [sp+64h] [bp-ECh]
  int v35; // [sp+68h] [bp-E8h]
  char *v36; // [sp+6Ch] [bp-E4h]
  int v37; // [sp+70h] [bp-E0h]
  int v38; // [sp+74h] [bp-DCh]
  int v39; // [sp+78h] [bp-D8h]
  int v40; // [sp+7Ch] [bp-D4h]
  void *v41; // [sp+80h] [bp-D0h]
  _DWORD *v42; // [sp+84h] [bp-CCh]
  __time_t v43[2]; // [sp+88h] [bp-C8h] BYREF
  __time_t v44[2]; // [sp+90h] [bp-C0h] BYREF
  _DWORD v45[4]; // [sp+98h] [bp-B8h] BYREF
  _BYTE dest[84]; // [sp+A8h] [bp-A8h] BYREF
  unsigned int v47; // [sp+FCh] [bp-54h]
  unsigned int v48; // [sp+100h] [bp-50h]
  int v49; // [sp+104h] [bp-4Ch]
  int v50; // [sp+108h] [bp-48h]
  _DWORD src[17]; // [sp+10Ch] [bp-44h] BYREF
  char v52[8196]; // [sp+150h] [bp+0h] BYREF

  v39 = a1;
  v42 = &off_BC5EC;
  v45[0] = 0;
  v45[1] = 64;
  v45[2] = 128;
  v45[3] = 192;
  sub_4465C(v43);
  if ( (unsigned int)off_BC5EC <= 3 || (memset(v52, 0, 0x2000u), *(_WORD *)v52 = 10, sub_42CB4(3, v52, 0), *v42 <= 3u) )
  {
    v40 = sub_27D1C();
    if ( !v40 )
    {
LABEL_34:
      v1 = v40;
      goto LABEL_27;
    }
  }
  else
  {
    snprintf(v52, 0x2000u, ">>>> Send work for chain %d.\n", v39);
    sub_41DB8(3, v52, 0);
    v40 = sub_27D1C();
    if ( !v40 )
      goto LABEL_34;
  }
  v1 = 0;
  v2 = 0;
  v38 = 0;
  v3 = 1 << v39;
  v41 = &unk_202A2A;
  v36 = (char *)&unk_80ACAC + 10752 * v39;
  do
  {
    v4 = *(_DWORD **)(dword_550468 + 4 * ((_DWORD)v41 + v38) + 4);
    v37 = sub_27D5C();
    if ( v37 )
    {
      v35 = 0;
      v34 = v4;
      v30 = &src[1];
      v32 = (unsigned __int8)~((unsigned int)~(v39 << 25) >> 25);
      do
      {
        v5 = v34;
        v33 = v35 & 3;
        v28 = 0;
        do
        {
          while ( (v3 & sub_63798()) == 0 )
          {
            ++v1;
            usleep(0x3E8u);
          }
          v29 = v5 + 21;
          v6 = &src[1];
          memcpy(dest, v5, sizeof(dest));
          v7 = v5[2];
          v8 = v28;
          *((_WORD *)v30 - 9) = 0;
          v30 = &src[1];
          v48 = v2 & 0x7F | v8;
          v9 = v5 + 5;
          BYTE1(v47) = v32;
          v10 = v5[3];
          v11 = v5[4];
          v49 = v7;
          v50 = v10;
          src[0] = v11;
          LOBYTE(v47) = 1;
          do
          {
            v9 += 4;
            v12 = v6;
            v6 += 4;
            v13 = *(v9 - 3);
            v14 = *(v9 - 2);
            v15 = *(v9 - 1);
            v21 = v9 == v29;
            *v12 = *(v9 - 4);
            v12[1] = v13;
            v12[2] = v14;
            v12[3] = v15;
          }
          while ( !v21 );
          v16 = 84;
          v17 = 0;
          v31 = v2;
          v18 = &v36[84 * v2];
          v19 = v5;
          v20 = v33;
          do
          {
            v21 = v17 == v20;
            if ( v17 != v20 )
              v16 = (int)v45;
            v22 = dest;
            if ( v17 == v20 )
              v22 = v19;
            else
              v9 = *(_DWORD **)(v16 + 4 * v17);
            v23 = &v18[dword_550468];
            ++v17;
            v18 += 84;
            if ( !v21 )
              dest[82] = (_BYTE)v9;
            memcpy(v23, v22, 0x54u);
          }
          while ( v17 != 4 );
          memcpy(v27, src, sizeof(v27));
          v2 = v31 + 8;
          v5 = v29;
          v24 = v28 + 128;
          v28 += 128;
          sub_2A514(
            v47,
            v48,
            v49,
            v50,
            v27[0],
            v27[1],
            v27[2],
            v27[3],
            v27[4],
            v27[5],
            v27[6],
            v27[7],
            v27[8],
            v27[9],
            v27[10],
            v27[11],
            v27[12]);
          if ( v2 >= 0x80 )
            v2 = 0;
        }
        while ( v24 != 1024 );
        v34 += 168;
        ++v35;
      }
      while ( v37 != v35 );
    }
    v21 = v40 == ++v38;
  }
  while ( !v21 );
LABEL_27:
  sub_4465C(v44);
  v25 = v44[0] - v43[0];
  if ( v44[1] - v43[1] < 0 )
    --v25;
  if ( *v42 > 3u )
  {
    snprintf(v52, 0x2000u, "Send work for chain %d done, time cost %lds, sleep_count = %d\n", v39, v25, v1);
    sub_41DB8(3, v52, 0);
  }
  return 0;
}
// 51E24: variable 'v16' is possibly undefined
// 51E3C: variable 'v9' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550468: using guessed type int dword_550468;

//----- (00051FBC) --------------------------------------------------------
unsigned int __fastcall sub_51FBC(int a1)
{
  unsigned int v2; // r7
  unsigned int v3; // r0
  unsigned int v4; // r8
  unsigned int v5; // r9
  unsigned int v6; // r5
  int v7; // r6
  unsigned int v8; // r10
  unsigned int result; // r0
  unsigned int v10; // r11
  int v11; // r3
  int v12; // r6
  int v13; // r9
  unsigned int v14; // r10
  _BOOL4 v15; // r3
  int v16; // r2
  int v17; // r2
  int v18; // r2
  unsigned int v19; // r8
  int v20; // r6
  int v21; // r3

  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_27D8C();
  v4 = sub_8114C(v2, v3);
  v5 = *(unsigned __int16 *)(a1 + 9);
  v6 = *(_BYTE *)a1 & 0xF;
  v7 = *(_WORD *)(a1 + 2) & 0x7FFF;
  v8 = sub_81144(v2);
  result = sub_27D6C();
  if ( v6 <= 3 && (v10 = result, (result = sub_27EC8(v6)) != 0) )
  {
    if ( (*(_BYTE *)a1 & 0x20) != 0 )
    {
      ++*(_DWORD *)(dword_550468 + 4 * v6 + 8431656);
    }
    else if ( (*(_BYTE *)a1 & 0x40) != 0 )
    {
      ++*(_DWORD *)(dword_550468 + 4 * v6 + 8431672);
    }
    else if ( (*(_BYTE *)a1 & 0x80) != 0 )
    {
      result = sub_27D1C();
      if ( result > v4 )
      {
        v11 = v7 & 0x7F;
        v12 = v7 >> 7;
        v13 = v11 + (v5 >> 9);
        v14 = (v13 & 3) + v10 * v8;
        result = sub_27D5C();
        v15 = v12 > 7;
        if ( result <= v14 )
          v15 = 1;
        if ( v15 )
        {
          ++*(_DWORD *)(dword_550468 + 4 * v6 + 8431720);
        }
        else
        {
          v16 = dword_550468;
          if ( *(_DWORD *)(*(_DWORD *)(dword_550468 + 4 * ((_DWORD)&unk_202A2A + v4) + 4) + 84 * v12 + 672 * v14 + 4) == v2 )
          {
            v19 = v4 + (v6 << 8);
            v20 = 1 << v12;
            v21 = dword_550468 + 4 * (v14 + (v19 << 10));
            result = *(_DWORD *)(v21 + 8);
            if ( (result & v20) != 0 )
            {
              ++*(_DWORD *)(dword_550468 + 4 * v6 + 8431640);
            }
            else
            {
              *(_DWORD *)(v21 + 8) = result | v20;
              result = *(_DWORD *)(v21 + 4231176) + 1;
              *(_DWORD *)(v21 + 4231176) = result;
              ++*(_DWORD *)(v16 + 4 * v19 + 8425480);
              ++*(_DWORD *)(v16 + 4 * v6 + 8429576);
            }
          }
          else
          {
            result = sub_52A18((char *)&unk_80ACAC + 10752 * v6 + 84 * v13 + dword_550468);
            if ( result )
              v17 = *(_DWORD *)(dword_550468 + 4 * v6 + 8431704);
            else
              v17 = *(_DWORD *)(dword_550468 + 4 * v6 + 8431720);
            v18 = v17 + 1;
            if ( result )
              *(_DWORD *)(dword_550468 + 4 * v6 + 8431704) = v18;
            else
              *(_DWORD *)(dword_550468 + 4 * v6 + 8431720) = v18;
          }
        }
      }
      else
      {
        ++*(_DWORD *)(dword_550468 + 4 * v6 + 8431756);
      }
    }
    else
    {
      ++*(_DWORD *)(dword_550468 + 4 * v6 + 8431688);
    }
  }
  else
  {
    ++*(_DWORD *)(dword_550468 + 8431752);
  }
  return result;
}
// 550468: using guessed type int dword_550468;

//----- (00052280) --------------------------------------------------------
void sub_52280()
{
  void **v0; // r6
  int v1; // r9
  int v2; // r5
  char *v3; // r2
  char *v4; // r4
  int v5; // r4

  LOWORD(v0) = (unsigned __int16)&dword_550468;
  v1 = sub_27D1C();
  if ( v1 )
  {
    HIWORD(v0) = (unsigned int)&dword_550468 >> 16;
    v2 = 0;
    v3 = (char *)*v0;
    do
    {
      v4 = (char *)&unk_202A2A + v2++;
      v5 = 4 * (_DWORD)v4;
      if ( *(_DWORD *)&v3[v5 + 4] )
      {
        free(*(void **)&v3[v5 + 4]);
        v3 = (char *)*v0;
        *(_DWORD *)((char *)*v0 + v5 + 4) = 0;
      }
    }
    while ( v1 != v2 );
  }
  else
  {
    HIWORD(v0) = (unsigned int)&dword_550468 >> 16;
    v3 = (char *)*v0;
  }
  free(v3);
  *v0 = 0;
}
// 550468: using guessed type int dword_550468;

//----- (00052300) --------------------------------------------------------
void sub_52300()
{
  if ( dword_550468 )
    sub_52280();
}
// 550468: using guessed type int dword_550468;

//----- (00052318) --------------------------------------------------------
int __fastcall sub_52318(FILE **a1, int a2, int a3, int a4)
{
  int v4; // r8
  int v5; // r7
  int v7; // r5
  int v8; // r11
  _DWORD *v9; // r4
  char *v10; // r11
  _DWORD *v11; // lr
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r0
  int v17; // r1
  int v18; // r2
  _DWORD ptr[4]; // [sp+8h] [bp-2054h] BYREF
  char v22; // [sp+18h] [bp-2044h] BYREF
  char v23[8196]; // [sp+58h] [bp-2004h] BYREF

  if ( !a4 )
    return 0;
  v4 = 4 * ((_DWORD)&unk_202A2A + a2);
  v5 = 84 * a3 * a4;
  v7 = 0;
  while ( 1 )
  {
    v8 = v7;
    v9 = (_DWORD *)(*(_DWORD *)(dword_550468 + v4 + 4) + v5);
    if ( fread(ptr, 1u, 0x50u, *a1) != 80 )
      break;
    v10 = &v22;
    v11 = v9 + 5;
    v9[1] = ptr[0];
    do
    {
      v11 += 4;
      v12 = *(_DWORD *)v10;
      v13 = *((_DWORD *)v10 + 1);
      v14 = *((_DWORD *)v10 + 2);
      v15 = *((_DWORD *)v10 + 3);
      v10 += 16;
      *(v11 - 4) = v12;
      *(v11 - 3) = v13;
      *(v11 - 2) = v14;
      *(v11 - 1) = v15;
    }
    while ( v10 != v23 );
    v5 += 84;
    v16 = ptr[1];
    v17 = ptr[2];
    v18 = ptr[3];
    *v9 = v7++;
    v9[2] = v16;
    v9[3] = v17;
    v9[4] = v18;
    if ( v7 == a4 )
      return v7;
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    return v8;
  strcpy(v23, "Load core pattern failed!\n");
  sub_41DB8(3, v23, 0);
  return v7;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550468: using guessed type int dword_550468;

//----- (0005246C) --------------------------------------------------------
int __fastcall sub_5246C(int a1)
{
  _DWORD *v2; // r10
  const char *v3; // r5
  int v4; // r9
  int v5; // r6
  int v6; // r7
  unsigned int v7; // r5
  int i; // r4
  int v9; // r2
  int v10; // r4
  int v12; // r9
  int v13; // r11
  int v14; // r0
  void *v15; // r0
  _DWORD *v16; // r3
  int v17; // r3
  int v18; // r0
  FILE *stream; // [sp+Ch] [bp-2008h] BYREF
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(s, "[DEBUG] Free memory for sw sweep.\n");
    sub_41DB8(4, s, 0);
  }
  v2 = (_DWORD *)dword_550468;
  if ( !dword_550468 )
  {
    dword_550468 = (int)calloc((size_t)&unk_8154AC, 1u);
    if ( dword_550468 )
    {
      v12 = sub_27D1C();
      if ( !v12 )
      {
        v2 = (_DWORD *)dword_550468;
        goto LABEL_4;
      }
      v13 = 0;
      while ( 1 )
      {
        v14 = sub_27D5C();
        v2 = (_DWORD *)dword_550468;
        v15 = malloc(672 * v14);
        v16 = &v2[(_DWORD)&unk_202A2A + v13++];
        v16[1] = v15;
        if ( !v15 )
          break;
        if ( v12 == v13 )
          goto LABEL_4;
      }
      if ( (unsigned int)off_BC5EC <= 3 )
      {
LABEL_27:
        sub_52280();
LABEL_28:
        sub_4FB28(13, 255);
        return -1;
      }
      strcpy(s, "Fail to allocate memory for works.\n");
      sub_41DB8(3, s, 0);
      v17 = dword_550468;
    }
    else
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_28;
      strcpy(s, "Fail to allocate memory for sw sweep ctxt.\n");
      sub_41DB8(3, s, 0);
      v17 = dword_550468;
    }
    if ( !v17 )
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_4:
  *v2 = a1;
  v3 = *(const char **)dword_550468;
  stream = fopen(*(const char **)dword_550468, "r");
  if ( !stream )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "Fail to open pattern file %s.\n", v3);
      sub_41DB8(3, s, 0);
    }
LABEL_16:
    sub_4FB28(22, 255);
    v10 = -1;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "Load pattern file failed.\n");
      sub_41DB8(3, s, 0);
    }
    goto LABEL_18;
  }
  v4 = sub_27D1C();
  if ( v4 )
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = sub_27D5C();
      if ( v6 )
      {
        v7 = 0;
        for ( i = 0; i != v6; ++i )
        {
          v9 = i;
          v7 += sub_52318(&stream, v5, v9, 8);
        }
      }
      else
      {
        v7 = 0;
      }
      if ( v7 < 8 * sub_27D5C() )
        break;
      if ( v4 == ++v5 )
        goto LABEL_13;
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      v18 = sub_27D5C();
      snprintf(s, 0x2000u, "No enough work, asic = %d, work_count = %d, work_count_target = %d.\n", v5, v7, 8 * v18);
      sub_41DB8(3, s, 0);
    }
    fclose(stream);
    goto LABEL_16;
  }
LABEL_13:
  v10 = 0;
  fclose(stream);
LABEL_18:
  sub_6307C();
  sub_62FC0(4);
  return v10;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550468: using guessed type int dword_550468;

//----- (000527AC) --------------------------------------------------------
char **sub_527AC()
{
  char v1[8200]; // [sp-2008h] [bp-2008h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "[DEBUG] Get sw ops.\n");
    sub_41DB8(4, v1, 0);
  }
  return &off_BCD20;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BCD20: using guessed type char *off_BCD20;

//----- (0005281C) --------------------------------------------------------
int __fastcall sub_5281C(int a1)
{
  char v2[8200]; // [sp-2008h] [bp-2008h] BYREF

  if ( (unsigned int)off_BC5EC > 1 )
  {
    snprintf(v2, 0x2000u, "input value error: %c\n", a1);
    sub_41DB8(1, v2, 0);
  }
  return 255;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (0005287C) --------------------------------------------------------
int __fastcall sub_5287C(int a1)
{
  int v1; // r3

  if ( (unsigned int)(a1 - 48) <= 9 )
    return a1 & 0xF;
  v1 = a1 & 0xDF;
  switch ( v1 )
  {
    case 'A':
      return 10;
    case 'B':
      return 11;
    case 'C':
      return 12;
    case 'D':
      return 13;
    case 'E':
      return 14;
    case 'F':
      return 15;
  }
  return sub_5281C(a1);
}

//----- (000528F8) --------------------------------------------------------
int __fastcall sub_528F8(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  bool v3; // cc
  int v4; // r3
  int v8; // r7
  unsigned __int8 *v9; // r8
  unsigned __int8 *v10; // r4
  char *v11; // r11
  int v12; // r6
  int v13; // t1
  char v14; // r5
  char v15; // r4
  int v16; // [sp+Ch] [bp-2008h]
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  v3 = (int)a1 <= 0;
  if ( a1 )
    v3 = a3 <= 0;
  v4 = v3;
  if ( !a2 )
    v4 = 1;
  if ( v4 )
  {
    if ( (unsigned int)off_BC5EC > 4 )
    {
      snprintf(s, 0x2000u, "s2hex para error dst(%p), src(%p), inlen(%d)\n", a1, a2, a3);
      sub_41DB8(4, s, 0);
    }
    return -1;
  }
  else
  {
    v8 = a3 >> 1;
    v16 = a3 & 1;
    if ( a3 >> 1 )
    {
      v9 = &a2[2 * v8];
      v10 = a2;
      v11 = a1 - 1;
      do
      {
        v12 = v10[1];
        v13 = *v10;
        v10 += 2;
        v14 = sub_5287C(v13);
        *++v11 = sub_5287C(v12) ^ (16 * v14);
      }
      while ( v10 != v9 );
    }
    if ( v16 )
    {
      v15 = sub_5287C(a2[2 * v8]);
      a1[v8] = sub_5281C(0) ^ (16 * v15);
    }
    return v8 + v16;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00052A18) --------------------------------------------------------
unsigned int __fastcall sub_52A18(const void *a1)
{
  unsigned int result; // r0
  unsigned int *v3; // r2
  int *v4; // r1
  unsigned int v5; // t1
  int v6; // [sp+0h] [bp-128h] BYREF
  unsigned int s[8]; // [sp+4h] [bp-124h] BYREF
  _BYTE v8[32]; // [sp+24h] [bp-104h] BYREF
  unsigned int v9; // [sp+44h] [bp-E4h] BYREF
  int v10; // [sp+48h] [bp-E0h]
  int v11; // [sp+4Ch] [bp-DCh]
  _DWORD v12[13]; // [sp+50h] [bp-D8h] BYREF
  unsigned int v13[20]; // [sp+84h] [bp-A4h] BYREF
  _DWORD dest[21]; // [sp+D4h] [bp-54h] BYREF

  memset(s, 0, sizeof(s));
  memset(v8, 0, sizeof(v8));
  if ( !a1 )
    return 0;
  memcpy(dest, a1, sizeof(dest));
  sub_45644(&dest[5], 64);
  v9 = dest[5];
  v10 = dest[6];
  v11 = dest[7];
  v12[0] = dest[8];
  v12[1] = dest[9];
  v12[2] = dest[10];
  v12[3] = dest[11];
  v12[4] = dest[12];
  v12[5] = dest[13];
  v12[6] = dest[14];
  v12[7] = dest[15];
  v12[8] = dest[16];
  v12[9] = dest[17];
  v12[10] = dest[18];
  v12[11] = dest[19];
  v12[12] = dest[20];
  sub_45A8C((int)&dest[5], &v9, 0x40u);
  sub_45644(&dest[2], 12);
  memset(v12, 0, sizeof(v12));
  v9 = dest[2];
  v10 = dest[3];
  v11 = dest[4];
  sub_45A8C((int)&dest[2], &v9, 0xCu);
  sub_45644(&dest[1], 4);
  v13[0] = dest[5];
  v13[1] = dest[6];
  v13[2] = dest[7];
  v13[3] = dest[8];
  v13[4] = dest[9];
  v13[5] = dest[10];
  v13[6] = dest[11];
  v13[7] = dest[12];
  v13[8] = dest[13];
  v13[9] = dest[14];
  v13[10] = dest[15];
  v13[11] = dest[16];
  v13[12] = dest[17];
  v13[13] = dest[18];
  v13[14] = dest[19];
  v13[15] = dest[20];
  v13[16] = dest[2];
  v13[17] = dest[3];
  v13[18] = dest[4];
  v13[19] = dest[1];
  sub_300CC(v13, 80, s);
  sub_300CC(s, 32, v8);
  v3 = &s[7];
  v4 = &v6;
  do
  {
    v5 = v3[1];
    ++v3;
    v4[1] = bswap32(v5);
    ++v4;
  }
  while ( v3 != (unsigned int *)&v8[28] );
  result = s[7];
  if ( s[7] )
    return 1;
  return result;
}

//----- (00052B7C) --------------------------------------------------------
int sub_52B7C()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  strcpy(v1, "Handle is NULL.\n");
  return sub_41DB8(3, v1, 0);
}

//----- (00052BC0) --------------------------------------------------------
int __fastcall sub_52BC0(_DWORD *a1)
{
  int v2; // r3
  char v4[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v4, 0x2000u, "[DEBUG] Send work one chain, chain = %d.\n", *a1);
    sub_41DB8(4, v4, 0);
  }
  if ( dword_55046C )
  {
    v2 = *(_DWORD *)(dword_55046C + 4);
    if ( v2 )
    {
      (*(void (__fastcall **)(_DWORD, _DWORD))(v2 + 28))(*a1, a1[2]);
      a1[1] = 1;
      return 0;
    }
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    return 0;
  sub_52B7C();
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00052C78) --------------------------------------------------------
int sub_52C78()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  strcpy(v1, "Handle is NULL.\n");
  sub_41DB8(3, v1, 0);
  return 1;
}

//----- (00052CC0) --------------------------------------------------------
int __fastcall sub_52CC0(int result)
{
  int v1; // r5
  int v2; // r3
  char v3[8196]; // [sp+0h] [bp-2004h] BYREF

  v1 = result;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v3, "[DEBUG] Send work for hw sweep.\n");
    result = sub_41DB8(4, v3, 0);
  }
  if ( dword_55046C )
  {
    v2 = *(_DWORD *)(dword_55046C + 4);
    if ( v2 )
      return (*(int (__fastcall **)(int, int))(v2 + 28))(255, v1);
  }
  if ( (unsigned int)off_BC5EC > 3 )
    return sub_52B7C();
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00052D74) --------------------------------------------------------
int __fastcall sub_52D74(int result)
{
  int v1; // r8
  int v2; // r4
  int *v3; // r6
  int i; // r4
  _DWORD v5[4]; // [sp+0h] [bp-2014h] BYREF
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
  {
    v1 = result;
    v2 = 0;
    v3 = (int *)s;
    memset(v5, 0, sizeof(v5));
    memset(s, 0, 0x30u);
    do
    {
      if ( sub_27EC8(v2) && *(_DWORD *)(dword_55046C + 4 * (v2 + 2)) == 1 )
      {
        *v3 = v2;
        v3[1] = 0;
        v3[2] = v1;
        pthread_create(&v5[v2], 0, (void *(*)(void *))sub_52BC0, v3);
        pthread_detach(v5[v2]);
      }
      ++v2;
      v3 += 3;
    }
    while ( v2 != 4 );
    for ( i = 0; i != 4; ++i )
    {
      while ( 1 )
      {
        result = sub_27EC8(i);
        if ( !result || !v5[i] || *(_DWORD *)&s[12 * i + 4] )
          break;
        i = 0;
        usleep((__useconds_t)&loc_186A0);
      }
    }
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "Handle is NULL.\n");
    return sub_41DB8(3, s, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00052EF0) --------------------------------------------------------
int __fastcall sub_52EF0(int a1, int a2)
{
  int v4; // r0
  int v5; // r4
  char *v6; // r0
  char *v7; // r3
  int v8; // t1
  int v9; // r0
  int v10; // r5
  int v11; // r0
  char *v12; // r2
  int v13; // r4
  int v14; // t1
  int v15; // r0
  double v16; // r0

  v4 = sub_27D1C();
  if ( v4 > 0 )
  {
    v6 = (char *)&unk_808FFC + 1024 * a1 + 4 * v4 + a2;
    v7 = (char *)&unk_808FFC + 1024 * a1 + a2;
    v5 = 0;
    do
    {
      v8 = *((_DWORD *)v7 + 1);
      v7 += 4;
      v5 += v8;
    }
    while ( v7 != v6 );
  }
  else
  {
    v5 = 0;
  }
  v9 = sub_27D1C();
  v10 = sub_96518(v5, v9);
  v11 = sub_27D1C();
  if ( v11 <= 0 )
    return sub_27D1C();
  v12 = (char *)&unk_808FFC + 1024 * a1 + a2;
  v13 = 0;
  do
  {
    v14 = *((_DWORD *)v12 + 1);
    v12 += 4;
    v13 += (v14 - v10) * (v14 - v10);
  }
  while ( v12 != (char *)&unk_808FFC + 1024 * a1 + 4 * v11 + a2 );
  v15 = sub_27D1C();
  LODWORD(v16) = sub_96518(v13, v15);
  if ( (double)SLODWORD(v16) < 0.0 )
    v16 = sqrt(v16);
  return LODWORD(v16);
}
// 52FE8: variable 'v16' is possibly undefined

//----- (00052FF4) --------------------------------------------------------
int __fastcall sub_52FF4(int a1, const char *a2)
{
  unsigned int v4; // r6
  int *v6; // r8
  int *v7; // r0
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v4 = a1 - 160;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "[DEBUG] sweep_type = 0x%X, pattern_file_path = %s\n", a1, a2);
    sub_41DB8(4, s, 0);
    if ( v4 > 1 )
      goto LABEL_3;
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(s, "[DEBUG] allocate memory for pattern test.\n");
      sub_41DB8(4, s, 0);
    }
  }
  else if ( v4 > 1 )
  {
LABEL_3:
    sub_4FB28(20, 255);
    if ( (unsigned int)off_BC5EC <= 3 )
      return -1;
    snprintf(s, 0x2000u, "Invalid sweep type 0x%X\n", a1);
LABEL_13:
    sub_41DB8(3, s, 0);
    return -1;
  }
  v6 = (int *)dword_55046C;
  if ( !dword_55046C )
  {
    v7 = (int *)calloc(0x44u, 1u);
    v6 = v7;
    dword_55046C = (int)v7;
    if ( !v7 )
    {
      sub_4FB28(13, 255);
      if ( (unsigned int)off_BC5EC <= 3 )
        return -1;
      strcpy(s, "Fail to allocate memory for send work context.\n");
      goto LABEL_13;
    }
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = 0;
    v7[5] = 0;
  }
  *v6 = a1;
  if ( a1 == 160 )
    v6[1] = (int)sub_527AC();
  else
    v6[1] = (int)sub_519DC();
  return (*(int (__fastcall **)(const char *))(*(_DWORD *)(dword_55046C + 4) + 4))(a2);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (000531C4) --------------------------------------------------------
void sub_531C4()
{
  _DWORD *v0; // r0
  int v1; // r3
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v2, "[DEBUG] Pattern test exit.\n");
    sub_41DB8(4, v2, 0);
    v0 = (_DWORD *)dword_55046C;
    if ( !dword_55046C )
    {
      if ( (unsigned int)off_BC5EC <= 4 )
        return;
      goto LABEL_9;
    }
  }
  else
  {
    v0 = (_DWORD *)dword_55046C;
    if ( !dword_55046C )
      return;
  }
  v1 = v0[1];
  if ( v1 )
  {
    (*(void (**)(void))(v1 + 8))();
    if ( (unsigned int)off_BC5EC <= 4 )
      goto LABEL_5;
    goto LABEL_9;
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
LABEL_9:
    strcpy(v2, "[DEBUG] Free memory for pattern test.\n");
    sub_41DB8(4, v2, 0);
LABEL_5:
    v0 = (_DWORD *)dword_55046C;
    if ( !dword_55046C )
      return;
  }
  free(v0);
  dword_55046C = 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (000532DC) --------------------------------------------------------
int sub_532DC()
{
  int v0; // r3
  int result; // r0
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v2, "[DEBUG] Pattern test reset.\n");
    result = sub_41DB8(4, v2, 0);
  }
  if ( dword_55046C )
  {
    v0 = *(_DWORD *)(dword_55046C + 4);
    if ( v0 )
      return (*(int (**)(void))(v0 + 16))();
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    return sub_41DB8(3, v2, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (0005339C) --------------------------------------------------------
int sub_5339C()
{
  int v0; // r2
  int result; // r0
  char v2[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( dword_55046C && (v0 = *(_DWORD *)(dword_55046C + 4)) != 0 )
  {
    if ( *(_DWORD *)(dword_55046C + 64) )
      return (*(int (**)(void))(v0 + 20))();
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    return sub_41DB8(3, v2, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00053434) --------------------------------------------------------
char *__fastcall sub_53434(char *result)
{
  int v1; // r12
  bool v2; // cc
  int *v3; // r2
  char v4; // r1
  int v5; // r2

  v1 = dword_66C4F0[0] + 1;
  v2 = dword_66C4F0[0] > 0xFFDu;
  v3 = &dword_66C4F0[2 * dword_66C4F0[0] + 2];
  v3[1] = *((_DWORD *)result + 1);
  *((_BYTE *)v3 + 8) = result[3] & 0x1F;
  *((_BYTE *)v3 + 9) = result[2];
  *((_BYTE *)v3 + 10) = result[1];
  v4 = *result;
  if ( !v2 )
    dword_66C4F0[0] = v1;
  *((_BYTE *)v3 + 11) = v4 & 0xF;
  if ( v2 )
    dword_66C4F0[0] = 0;
  if ( (unsigned int)dword_66C4F8 > 0xFFE )
    v5 = 4095;
  else
    v5 = dword_66C4F8 + 1;
  dword_66C4F8 = v5;
  return result;
}
// 66C4F0: using guessed type int dword_66C4F0[];
// 66C4F8: using guessed type int dword_66C4F8;

//----- (000534AC) --------------------------------------------------------
int __fastcall sub_534AC(int result)
{
  char *v1; // r5
  char v2[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
  {
    v1 = (char *)result;
    pthread_mutex_lock(&stru_C4760);
    if ( *(_DWORD *)(dword_55046C + 64) )
      (*(void (__fastcall **)(char *))(*(_DWORD *)(dword_55046C + 4) + 24))(v1);
    else
      sub_53434(v1);
    return pthread_mutex_unlock(&stru_C4760);
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    return sub_41DB8(3, v2, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00053578) --------------------------------------------------------
int sub_53578()
{
  int v0; // r3
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v2, "[DEBUG] Get stats.\n");
    sub_41DB8(4, v2, 0);
  }
  if ( dword_55046C )
  {
    v0 = *(_DWORD *)(dword_55046C + 4);
    if ( v0 )
      return (*(int (**)(void))(v0 + 32))();
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    sub_41DB8(3, v2, 0);
  }
  return 0;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (0005363C) --------------------------------------------------------
int __fastcall sub_5363C(int a1)
{
  int v2; // r3
  char v4[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v4, 0x2000u, "[DEBUG] Check if chain is unbalance happen, chain = %d.\n", a1);
    sub_41DB8(4, v4, 0);
  }
  if ( dword_55046C )
  {
    v2 = *(_DWORD *)(dword_55046C + 4);
    if ( v2 )
      return (*(int (__fastcall **)(int))(v2 + 36))(a1);
  }
  if ( (unsigned int)off_BC5EC > 3 )
    return sub_52C78();
  return 1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (000536E4) --------------------------------------------------------
int sub_536E4()
{
  int v0; // r4
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v2, "[DEBUG] Check if is unbalance happen.\n");
    sub_41DB8(4, v2, 0);
  }
  v0 = 0;
  while ( !sub_27EC8(v0) || !sub_5363C(v0) )
  {
    if ( ++v0 == 4 )
      return 0;
  }
  return 1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00053788) --------------------------------------------------------
int __fastcall sub_53788(int a1)
{
  float v1; // s0
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(
      s,
      0x2000u,
      "[DEBUG] Check if chain is unqualified happen, chain = %d, nonce_rate_threshold = %.2f\n",
      a1,
      v1);
    sub_41DB8(4, s, 0);
  }
  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
  {
    if ( *(float *)(dword_55046C + 4 * a1 + 48) < v1 )
    {
      *(_BYTE *)(dword_55046C + a1 + 28) = 1;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    return sub_52C78();
  }
  else
  {
    return 1;
  }
}
// 53840: variable 'v1' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (0005385C) --------------------------------------------------------
int sub_5385C()
{
  int v0; // r4
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v2, "[DEBUG] check if is unqualified happen.\n");
    sub_41DB8(4, v2, 0);
  }
  v0 = 0;
  while ( !sub_27EC8(v0) || !sub_53788(v0) )
  {
    if ( ++v0 == 4 )
      return 0;
  }
  return 1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00053908) --------------------------------------------------------
int __fastcall sub_53908(int a1)
{
  int v2; // r3
  char v4[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v4, 0x2000u, "[DEBUG] Check if recv nonce enough, chain = %d.\n", a1);
    sub_41DB8(4, v4, 0);
  }
  if ( dword_55046C )
  {
    v2 = *(_DWORD *)(dword_55046C + 4);
    if ( v2 )
      return (*(int (__fastcall **)(int))(v2 + 40))(a1);
  }
  if ( (unsigned int)off_BC5EC > 3 )
    return sub_52C78();
  return 1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (000539B0) --------------------------------------------------------
int __fastcall sub_539B0(int result, int a2)
{
  int v2; // r6
  const char *v4; // r3
  int v5; // r4
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v2 = result;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        v4 = "READY";
      }
      else
      {
        v4 = "DONE";
        if ( a2 != 2 )
          v4 = "UNKNOWN";
      }
    }
    else
    {
      v4 = "BLOCK";
    }
    snprintf(s, 0x2000u, "chain = %d, status = %s\n", result, v4);
    result = sub_41DB8(3, s, 0);
    if ( !dword_55046C || !*(_DWORD *)(dword_55046C + 4) )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(s, "Handle is NULL.\n");
        return sub_41DB8(3, s, 0);
      }
      return result;
    }
LABEL_12:
    v5 = 0;
    while ( 1 )
    {
      result = sub_27EC8(v5);
      if ( result )
      {
        if ( v2 == 255 )
        {
          *(_DWORD *)(dword_55046C + 4 * (v5 + 2)) = a2;
        }
        else if ( v2 == v5 )
        {
          *(_DWORD *)(dword_55046C + 4 * (v2 + 2)) = a2;
          return result;
        }
      }
      if ( ++v5 == 4 )
        return result;
    }
  }
  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
    goto LABEL_12;
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00053B24) --------------------------------------------------------
int __fastcall sub_53B24(int a1)
{
  int v2; // r2
  int v3; // r2
  const char *v4; // r3
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v2 = dword_55046C;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    v3 = *(_DWORD *)(dword_55046C + 4 * (a1 + 2));
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v4 = "READY";
      }
      else
      {
        v4 = "UNKNOWN";
        if ( v3 == 2 )
          v4 = "DONE";
      }
    }
    else
    {
      v4 = "BLOCK";
    }
    snprintf(s, 0x2000u, "[DEBUG] chain = %d, status = %s\n", a1, v4);
    sub_41DB8(4, s, 0);
    v2 = dword_55046C;
  }
  if ( v2 && *(_DWORD *)(v2 + 4) )
    return *(_DWORD *)(v2 + 4 * (a1 + 2));
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "Handle is NULL.\n");
    sub_41DB8(3, s, 0);
  }
  return 2;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00053C40) --------------------------------------------------------
int sub_53C40()
{
  int v0; // r3
  int result; // r0
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v2, "[DEBUG] Clear stats.\n");
    result = sub_41DB8(4, v2, 0);
  }
  if ( dword_55046C )
  {
    v0 = *(_DWORD *)(dword_55046C + 4);
    if ( v0 )
      return (*(int (**)(void))(v0 + 12))();
  }
  if ( (unsigned int)off_BC5EC > 3 )
    return sub_52B7C();
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00053CD8) --------------------------------------------------------
int sub_53CD8()
{
  int v0; // r4

  v0 = 0;
  while ( !sub_27EC8(v0) || sub_53B24(v0) )
  {
    if ( ++v0 == 4 )
      return 0;
  }
  return 1;
}

//----- (00053D1C) --------------------------------------------------------
int sub_53D1C()
{
  int v0; // r4
  int result; // r0

  v0 = 0;
  while ( 1 )
  {
    if ( sub_27EC8(v0) )
    {
      result = sub_53B24(v0);
      if ( result == 1 )
        break;
    }
    if ( ++v0 == 4 )
      return 0;
  }
  return result;
}

//----- (00053D5C) --------------------------------------------------------
int __fastcall sub_53D5C(unsigned int a1)
{
  unsigned int v2; // r5
  int i; // r4
  bool v4; // zf
  int result; // r0
  char v6[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v6, 0x2000u, "[DEBUG] Set chain serial, chain_serial_count = %d.\n", a1);
    sub_41DB8(4, v6, 0);
  }
  v2 = 0;
  for ( i = 0; i != 4; ++i )
  {
    v4 = sub_27EC8(i) == 0;
    result = i;
    if ( !v4 )
    {
      if ( a1 <= v2 )
        return result;
      result = sub_53B24(i);
      if ( !result )
      {
        ++v2;
        result = sub_539B0(i, 1);
      }
    }
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00053E00) --------------------------------------------------------
int sub_53E00()
{
  _DWORD *v0; // r3
  int result; // r0
  char v2[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v2, "[DEBUG] Clear ctxt.\n");
    result = sub_41DB8(4, v2, 0);
  }
  v0 = (_DWORD *)dword_55046C;
  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
  {
    *(_DWORD *)(dword_55046C + 24) = 0;
    v0[7] = 0;
    v0[8] = 0;
    v0[9] = 0;
    v0[10] = 0;
    v0[11] = 0;
    v0[12] = 0;
    v0[13] = 0;
    v0[14] = 0;
    v0[15] = 0;
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v2, "Handle is NULL.\n");
    return sub_41DB8(3, v2, 0);
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00053EE4) --------------------------------------------------------
int __fastcall sub_53EE4(int a1)
{
  float v1; // s0
  float v2; // s1
  float v3; // s2
  int v5; // r8
  int v6; // r9
  int v7; // r5
  int v8; // r5
  unsigned int v10; // s16
  int v11; // r5
  int v12; // r0
  int v13; // r9
  void *v14; // r3
  float v15; // s13
  float v16; // s12
  float v17; // s14
  char s[8196]; // [sp+18h] [bp-2004h] BYREF

  v5 = sub_53578();
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(
      s,
      0x2000u,
      "[DEBUG] Check if is need stop, chain = %d, hw_threshold = %.4f, nonce_rate_threshold = %.2f, nonce_rate_dec_threshold = %.2f.\n",
      a1,
      v1,
      v2,
      v3);
    sub_41DB8(4, s, 0);
  }
  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
  {
    v6 = 4 * a1;
    v7 = 8 * sub_27D5C();
    v8 = sub_27D1C() * v7;
    if ( *(_DWORD *)(v5 + 4 * a1 + 8431696) > (unsigned int)(float)((float)v8 * v1) )
    {
      if ( (unsigned int)off_BC5EC > 3 )
      {
        snprintf(
          s,
          0x2000u,
          "chain = %d, hw = %d, hw_threshold = %d, too much hw.\n",
          a1,
          *(_DWORD *)(v5 + v6 + 8431696),
          (unsigned int)(float)((float)v8 * v1));
        sub_41DB8(3, s, 0);
      }
      return 1;
    }
    v10 = *(_DWORD *)(v5 + 4 * a1 + 8429568);
    v11 = 8 * sub_27D5C();
    v12 = sub_27D1C();
    v13 = dword_55046C + v6;
    v14 = off_BC5EC;
    v15 = *(float *)(v13 + 48);
    v16 = *(float *)(v13 + 32);
    v17 = (float)v10 / (float)(v12 * v11);
    *(float *)(v13 + 32) = v17;
    if ( v15 < v17 )
      *(float *)(v13 + 48) = v17;
    if ( (unsigned int)v14 > 3 )
    {
      snprintf(
        s,
        0x2000u,
        "chain = %d, nonce_rate_curr = %.4f, nonce_rate_last = %.4f, nonce_rate_max = %.4f\n",
        a1,
        v17,
        v16,
        *(float *)(v13 + 48));
      sub_41DB8(3, s, 0);
    }
    return 0;
  }
  else
  {
    if ( (unsigned int)off_BC5EC <= 3 )
      return 1;
    strcpy(s, "Handle is NULL.\n");
    sub_41DB8(3, s, 0);
    return 1;
  }
}
// 54014: variable 'v1' is possibly undefined
// 54018: variable 'v2' is possibly undefined
// 54010: variable 'v3' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (0005410C) --------------------------------------------------------
int sub_5410C()
{
  int v0; // r4
  int v1; // r0
  int v2; // r3
  char v4[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v4, "[DEBUG] Check if all chain pattern test done.\n");
    sub_41DB8(4, v4, 0);
  }
  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
  {
    v0 = 0;
    while ( 1 )
    {
      v1 = sub_27EC8(v0);
      v2 = v0 + 2;
      ++v0;
      if ( v1 )
      {
        if ( *(_DWORD *)(dword_55046C + 4 * v2) != 2 )
          break;
      }
      if ( v0 == 4 )
        return 1;
    }
    return 0;
  }
  else if ( (unsigned int)off_BC5EC <= 3 )
  {
    return 1;
  }
  else
  {
    strcpy(v4, "Handle is NULL.\n");
    sub_41DB8(3, v4, 0);
    return 1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00054224) --------------------------------------------------------
int sub_54224()
{
  int v0; // r4
  int v1; // r0
  int v2; // r3
  char v4[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v4, "[DEBUG] Check if all chain pattern test done except block.\n");
    sub_41DB8(4, v4, 0);
  }
  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
  {
    v0 = 0;
    while ( 1 )
    {
      v1 = sub_27EC8(v0);
      v2 = v0 + 2;
      ++v0;
      if ( v1 )
      {
        if ( (*(_DWORD *)(dword_55046C + 4 * v2) & 0xFFFFFFFD) != 0 )
          break;
      }
      if ( v0 == 4 )
        return 1;
    }
    return 0;
  }
  else if ( (unsigned int)off_BC5EC <= 3 )
  {
    return 1;
  }
  else
  {
    strcpy(v4, "Handle is NULL.\n");
    sub_41DB8(3, v4, 0);
    return 1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;

//----- (00054338) --------------------------------------------------------
int __fastcall sub_54338(int a1)
{
  int i; // r4
  int v2; // r4
  char v4[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v4, 0x2000u, "[DEBUG] Board init, is_power_off = %d.\n", a1);
    sub_41DB8(4, v4, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
      sub_7E92C((unsigned __int8)i);
  }
  sub_4A32C();
  v2 = sub_4DB18();
  sub_44890();
  sub_38E70();
  sub_44890();
  return v2;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000543D8) --------------------------------------------------------
char *__fastcall sub_543D8(char *result, int a2)
{
  char *v2; // r7
  char *v4; // r8
  void *v5; // r2
  unsigned int v6; // r4
  unsigned int v7; // r0
  int v8; // r1
  unsigned int v9; // r8
  int v10; // r10
  unsigned int i; // r4
  int v12; // r4
  int v13; // r0
  unsigned int v14; // s16
  int v15; // r4
  int v16; // r0
  _WORD s[4098]; // [sp+18h] [bp-2004h] BYREF

  if ( !dword_55046C || !*(_DWORD *)(dword_55046C + 4) )
  {
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy((char *)s, "Handle is NULL.\n");
      return (char *)sub_41DB8(3, (const char *)s, 0);
    }
    return result;
  }
  v2 = result;
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    snprintf((char *)s, 0x2000u, "chain %d stats:\n", v2);
    sub_42CB4(3, (const char *)s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(s, 0, 0x2000u);
      v12 = sub_27D5C();
      v13 = sub_27D1C();
      snprintf((char *)s, 0x2000u, "%-30s : %d\n", "send_nonce_num", v13 * 8 * v12);
      sub_42CB4(3, (const char *)s, 0);
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_4;
      memset(s, 0, 0x2000u);
      snprintf((char *)s, 0x2000u, "%-30s : %d\n", "recv_nonce_num", *(_DWORD *)(a2 + 4 * (_DWORD)(v2 + 2107392)));
      sub_42CB4(3, (const char *)s, 0);
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_39;
      memset(s, 0, 0x2000u);
      v14 = *(_DWORD *)(a2 + 4 * (_DWORD)(v2 + 2107392));
      v15 = sub_27D5C();
      v16 = sub_27D1C();
      snprintf((char *)s, 0x2000u, "%-30s : %f\n", "nonce_return_rate", (float)((float)v14 / (float)(v16 * 8 * v15)));
      sub_42CB4(3, (const char *)s, 0);
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_4;
      memset(s, 0, 0x2000u);
      snprintf(
        (char *)s,
        0x2000u,
        "%-30s : %d\n",
        "nonce_num_repeated",
        *(_DWORD *)(a2 + 4 * ((int)&unk_202A04 + (_DWORD)v2)));
      sub_42CB4(3, (const char *)s, 0);
    }
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_42;
    memset(s, 0, 0x2000u);
    snprintf(
      (char *)s,
      0x2000u,
      "%-30s : %d\n",
      "nonce_num_top_check_fail",
      *(_DWORD *)(a2 + 4 * ((int)&unk_202A08 + (_DWORD)v2)));
    sub_42CB4(3, (const char *)s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_4;
    memset(s, 0, 0x2000u);
    snprintf(
      (char *)s,
      0x2000u,
      "%-30s : %d\n",
      "nonce_num_crc_err",
      *(_DWORD *)(a2 + 4 * ((int)&unk_202A0C + (_DWORD)v2)));
    sub_42CB4(3, (const char *)s, 0);
LABEL_39:
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_45;
    memset(s, 0, 0x2000u);
    snprintf(
      (char *)s,
      0x2000u,
      "%-30s : %d\n",
      "nonce_num_invalid",
      *(_DWORD *)(a2 + 4 * ((int)&unk_202A10 + (_DWORD)v2)));
    sub_42CB4(3, (const char *)s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_4;
    memset(s, 0, 0x2000u);
    snprintf((char *)s, 0x2000u, "%-30s : %d\n", "nonce_num_hw", *(_DWORD *)(a2 + 4 * ((int)&unk_202A14 + (_DWORD)v2)));
    sub_42CB4(3, (const char *)s, 0);
LABEL_42:
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_48;
    memset(s, 0, 0x2000u);
    snprintf(
      (char *)s,
      0x2000u,
      "%-30s : %d\n",
      "nonce_num_extra",
      *(_DWORD *)(a2 + 4 * ((int)&unk_202A18 + (_DWORD)v2)));
    sub_42CB4(3, (const char *)s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_4;
    memset(s, 0, 0x2000u);
    snprintf(
      (char *)s,
      0x2000u,
      "%-30s : %d\n",
      "nonce_num_unknown_err",
      *(_DWORD *)(a2 + 4 * ((int)&unk_202A1C + (_DWORD)v2)));
    sub_42CB4(3, (const char *)s, 0);
LABEL_45:
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_51;
    memset(s, 0, 0x2000u);
    snprintf(
      (char *)s,
      0x2000u,
      "%-30s : %d\n",
      "invalid_asic_num",
      *(_DWORD *)(a2 + 4 * ((int)&unk_202A20 + (_DWORD)v2) + 4));
    sub_42CB4(3, (const char *)s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_4;
    memset(s, 0, 0x2000u);
    snprintf((char *)s, 0x2000u, "%-30s : %d\n", "invalid_chain_num", *(_DWORD *)(a2 + 8431744));
    sub_42CB4(3, (const char *)s, 0);
LABEL_48:
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_4;
    memset(s, 0, 0x2000u);
    snprintf((char *)s, 0x2000u, "%-30s : %.2f\n", "stddev", *(float *)(a2 + 4 * ((int)&unk_202A24 + (_DWORD)v2) + 4));
    sub_42CB4(3, (const char *)s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_4;
    memset(s, 0, 0x2000u);
    s[0] = 10;
    sub_42CB4(3, (const char *)s, 0);
LABEL_51:
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf((char *)s, 0x2000u, "Chain %d nonce:\n", v2);
      sub_41DB8(3, (const char *)s, 0);
    }
  }
LABEL_4:
  result = (char *)sub_27D1C();
  v4 = result;
  v5 = off_BC5EC;
  if ( result )
  {
    v6 = 0;
    do
    {
      if ( (unsigned int)v5 > 3 )
      {
        memset(s, 0, 0x2000u);
        snprintf((char *)s, 0x2000u, "IC[%03d]:%04d ", v6, *(_DWORD *)(a2 + ((_DWORD)v2 << 10) + 4 * v6 + 8425472));
        sub_42CB4(3, (const char *)s, 0);
      }
      ++v6;
      v7 = sub_27D2C();
      result = (char *)sub_964FC(v6, v7);
      v5 = off_BC5EC;
      if ( !v8 && (unsigned int)off_BC5EC > 3 )
      {
        memset(s, 0, 0x2000u);
        s[0] = 10;
        result = sub_42CB4(3, (const char *)s, 0);
        v5 = off_BC5EC;
      }
    }
    while ( (char *)v6 != v4 );
  }
  if ( (unsigned int)v5 > 3 )
  {
    memset(s, 0, 0x2000u);
    s[0] = 10;
    result = sub_42CB4(3, (const char *)s, 0);
    if ( *(_DWORD *)dword_55046C == 161 )
      return result;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(s, 0, 0x2000u);
      snprintf((char *)s, 0x2000u, "Chain %d domain:\n", v2);
      sub_42CB4(3, (const char *)s, 0);
    }
  }
  else if ( *(_DWORD *)dword_55046C == 161 )
  {
    return result;
  }
  v9 = 0;
  result = (char *)sub_27D0C();
  if ( result )
  {
    while ( 1 )
    {
      v10 = v9 * sub_27D7C();
      for ( i = 0; sub_27D7C() > i; ++i )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          memset(s, 0, 0x2000u);
          snprintf(
            (char *)s,
            0x2000u,
            "D[%02d]:%04d ",
            i + v10,
            *(_DWORD *)((char *)&dword_80A010[64 * (_DWORD)v2 + v10 + i] + a2));
          sub_42CB4(3, (const char *)s, 0);
        }
      }
      if ( sub_27D7C() <= 1 )
        goto LABEL_28;
      if ( (unsigned int)off_BC5EC > 3 )
        break;
LABEL_24:
      ++v9;
      result = (char *)sub_27D0C();
      if ( (unsigned int)result <= v9 )
        goto LABEL_25;
    }
    memset(s, 0, 0x2000u);
    snprintf((char *)s, 0x2000u, "D_BIG[%02d]:%05d", v9, *(_DWORD *)((char *)&dword_80A410[64 * (_DWORD)v2 + v9] + a2));
    sub_42CB4(3, (const char *)s, 0);
LABEL_28:
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(s, 0, 0x2000u);
      s[0] = 10;
      sub_42CB4(3, (const char *)s, 0);
    }
    goto LABEL_24;
  }
LABEL_25:
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    strcpy((char *)s, "\n\n");
    return sub_42CB4(3, (const char *)s, 0);
  }
  return result;
}
// 54468: variable 'v8' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;
// 80A010: using guessed type _DWORD dword_80A010[256];
// 80A410: using guessed type _DWORD dword_80A410[289];

//----- (00054D24) --------------------------------------------------------
int sub_54D24()
{
  int v0; // r4

  v0 = 8 * sub_27D5C();
  return sub_27D1C() * v0;
}

//----- (00054D68) --------------------------------------------------------
int __fastcall sub_54D68(int result)
{
  int v1; // s0
  int v2; // r4
  int v3; // r0
  int v4; // r2
  int i; // r4
  int v6; // r11
  int v7; // r7
  int v8; // r3
  int v9; // r5
  unsigned int v10; // r0
  unsigned int v11; // r9
  int v12; // r10
  int v13; // r5
  char *v14; // r11
  int v15; // r4
  unsigned int v16; // r8
  unsigned int v17; // r0
  unsigned int v18; // r0
  int v19; // t1
  int v20; // r0
  int v22; // r0
  int v23; // r12
  int v24; // lr
  _DWORD *v25; // r3
  int v26; // [sp+0h] [bp-2044h]
  unsigned int v27; // [sp+8h] [bp-203Ch]
  int v28; // [sp+10h] [bp-2034h]
  int v29; // [sp+14h] [bp-2030h]
  int v30; // [sp+1Ch] [bp-2028h]
  __time_t v31; // [sp+30h] [bp-2014h] BYREF
  int v32; // [sp+34h] [bp-2010h]
  __time_t v33[2]; // [sp+38h] [bp-200Ch] BYREF
  char v34[8196]; // [sp+40h] [bp-2004h] BYREF

  if ( dword_55046C && *(_DWORD *)(dword_55046C + 4) )
  {
    v2 = result;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v34, "Pattern test start...\n");
      sub_41DB8(3, v34, 0);
    }
    sub_4465C(&v31);
    sub_53C40();
    v3 = sub_63E74();
    sub_63EA0(v3 | 0x10000);
    v4 = *(_DWORD *)dword_55046C;
    *(_DWORD *)(dword_55046C + 64) = 1;
    if ( v4 == 161 )
      sub_52CC0(v2);
    else
      sub_52D74(v2);
    for ( i = 0; i != 4; ++i )
    {
      if ( sub_27EC8(i) && *(_DWORD *)(dword_55046C + 4 * (i + 2)) == 1 )
      {
        v9 = 3;
        do
        {
          if ( sub_53908(i) )
            break;
          usleep((__useconds_t)&loc_186A0);
          --v9;
        }
        while ( v9 );
      }
    }
    v6 = 0;
    *(_DWORD *)(dword_55046C + 64) = 0;
    v7 = sub_53578();
    do
    {
      if ( sub_27EC8(v6) && *(_DWORD *)(dword_55046C + 4 * (v6 + 2)) == 1 )
      {
        v28 = sub_27D1C();
        if ( v28 )
        {
          v29 = v6;
          v30 = v6 << 8;
          v26 = v6 << 6;
          v27 = 0;
          do
          {
            v10 = sub_27D2C();
            v11 = sub_962A0(v27, v10);
            v12 = sub_27D5C();
            if ( v12 )
            {
              v13 = 0;
              v14 = (char *)&unk_408FFC + 4096 * (v27 + v30) + v7;
              do
              {
                v15 = v11 * sub_27D7C();
                v16 = v13 * sub_27D7C();
                ++v13;
                v17 = sub_27D5C();
                v18 = sub_962A0(v16, v17);
                v19 = *((_DWORD *)v14 + 1);
                v14 += 4;
                v20 = v7 + 4 * (v18 + v15 + v26) + 8429568;
                *(_DWORD *)(v20 + 16) += v19;
                *(_DWORD *)(v7 + 4 * (v11 + v26) + 8430608) += v19;
                ++*(_DWORD *)(v7 + 4 * (9 * v27 + 2304 * v29 + v19) + 0x400000);
              }
              while ( v12 != v13 );
            }
          }
          while ( v28 != ++v27 );
          v6 = v29;
        }
        v22 = sub_27D1C();
        if ( v22 )
        {
          v23 = v7 + 0x400000 + 9216 * v6;
          v24 = v23 + 36 * v22;
          do
          {
            v25 = (_DWORD *)v23;
            do
            {
              v25[1] += *v25;
              ++v25;
            }
            while ( v25 != (_DWORD *)(v23 + 32) );
            v23 += 36;
          }
          while ( v23 != v24 );
        }
        sub_52EF0(v6, v7);
        *(_DWORD *)((char *)&dword_80A894[v6] + v7) = v1;
      }
      ++v6;
    }
    while ( v6 != 4 );
    sub_4465C(v33);
    result = v32;
    v8 = v33[0] - v31;
    if ( v33[1] - v32 < 0 )
      --v8;
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(v34, 0x2000u, "Pattern test done, time cost %lds\n", v8);
      return sub_41DB8(3, v34, 0);
    }
  }
  else if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v34, "Handle is NULL.\n");
    return sub_41DB8(3, v34, 0);
  }
  return result;
}
// 550E4: variable 'v1' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 55046C: using guessed type int dword_55046C;
// 80A894: using guessed type _DWORD dword_80A894[4];

//----- (0005516C) --------------------------------------------------------
int sub_5516C()
{
  int v0; // r4

  v0 = sub_506A8();
  if ( v0 == sub_50698() )
    return 0;
  else
    return sub_506AC();
}

//----- (00055194) --------------------------------------------------------
int sub_55194()
{
  char v1[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v1, "[DEBUG] Freq tuning basic init.\n");
    sub_41DB8(4, v1, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v1, "[DEBUG] Allocate memory for freq tuning basic.\n");
      sub_41DB8(4, v1, 0);
    }
  }
  if ( dword_550470 )
    return 0;
  dword_550470 = (int)calloc(0x34u, 1u);
  if ( dword_550470 )
    return 0;
  sub_4FB28(13, 255);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v1, "Fail to allocate memory for freq tuning basic context.\n");
    sub_41DB8(3, v1, 0);
  }
  return -1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550470: using guessed type int dword_550470;

//----- (000552CC) --------------------------------------------------------
void sub_552CC()
{
  char v0[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v0, "[DEBUG] Freq tuning basic exit.\n");
    sub_41DB8(4, v0, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for freq tuning basic.\n");
      sub_41DB8(4, v0, 0);
    }
  }
  if ( dword_550470 )
  {
    free((void *)dword_550470);
    dword_550470 = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550470: using guessed type int dword_550470;

//----- (00055388) --------------------------------------------------------
int __fastcall sub_55388(int a1)
{
  return *(_DWORD *)(dword_550470 + 4 * a1 + 20);
}
// 550470: using guessed type int dword_550470;

//----- (000553A0) --------------------------------------------------------
int __fastcall sub_553A0(int a1)
{
  char v3[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v3, 0x2000u, "[DEBUG] Get freq result, chain = %d.\n", a1);
    sub_41DB8(4, v3, 0);
  }
  return *(_DWORD *)(dword_550470 + 4 * a1 + 4);
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550470: using guessed type int dword_550470;

//----- (00055404) --------------------------------------------------------
int __fastcall sub_55404(int a1)
{
  return dword_550470 + 4 * a1;
}
// 550470: using guessed type int dword_550470;

//----- (0005541C) --------------------------------------------------------
void sub_5541C()
{
  void *v0; // r3
  const char *v1; // r6
  const char *v2; // r12
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC <= 3 )
    return;
  memset(s, 0, 0x2000u);
  snprintf(s, 0x2000u, "%-40s : %d\n", "voltage", **(_DWORD **)dword_550470);
  sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %d\n", "freq_base", *(_DWORD *)(*(_DWORD *)dword_550470 + 4));
    sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %d\n", "freq_threshold", *(_DWORD *)(*(_DWORD *)dword_550470 + 8));
    sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      goto LABEL_16;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %d\n", "freq_serial_threshold", *(_DWORD *)(*(_DWORD *)dword_550470 + 12));
    sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %d\n", "freq_step", *(_DWORD *)(*(_DWORD *)dword_550470 + 16));
    sub_42CB4(3, s, 0);
  }
  v0 = off_BC5EC;
  if ( (unsigned int)off_BC5EC <= 3 )
  {
LABEL_19:
    if ( (unsigned int)v0 > 3 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "%-40s : %.2f\n", "nonce_rate_threshold", *(float *)(*(_DWORD *)dword_550470 + 32));
      sub_42CB4(3, s, 0);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        memset(s, 0, 0x2000u);
        snprintf(s, 0x2000u, "%-40s : %.2f\n", "nonce_rate_dec_threshold", *(float *)(*(_DWORD *)dword_550470 + 36));
        sub_42CB4(3, s, 0);
      }
    }
    return;
  }
  v1 = "false";
  memset(s, 0, 0x2000u);
  if ( *(_BYTE *)(*(_DWORD *)dword_550470 + 20) )
    v2 = "true";
  else
    v2 = "false";
  snprintf(s, 0x2000u, "%-40s : %s\n", "is_inc_freq_with_high_vol", v2);
  sub_42CB4(3, s, 0);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    if ( *(_BYTE *)(*(_DWORD *)dword_550470 + 21) )
      v1 = "true";
    snprintf(s, 0x2000u, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v1);
    sub_42CB4(3, s, 0);
LABEL_16:
    if ( (unsigned int)off_BC5EC <= 3 )
      return;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %d\n", "is_board_init_with_power_off", *(_DWORD *)(*(_DWORD *)dword_550470 + 24));
    sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %.4f\n", "hw_threshold", *(float *)(*(_DWORD *)dword_550470 + 28));
    sub_42CB4(3, s, 0);
    v0 = off_BC5EC;
    goto LABEL_19;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550470: using guessed type int dword_550470;

//----- (00055848) --------------------------------------------------------
char *__fastcall sub_55848(int a1)
{
  _DWORD *v2; // r4
  char *v3; // r4
  int i; // r4
  int v6; // r6
  int v7; // r0
  int j; // r4
  int v9; // r9
  int k; // r4
  int v11; // r10
  int *v12; // r9
  int *v13; // r11
  int v14; // r0
  int v15; // r2
  int v16; // r3
  int v17; // r9
  int v18; // r1
  float *v19; // r2
  int v20; // r3
  float v21; // s12
  int v22; // r0
  bool v23; // cc
  float v24; // s0
  int v25; // r3
  unsigned int v26; // [sp+14h] [bp-2150h]
  unsigned int v27; // [sp+18h] [bp-214Ch]
  int v28; // [sp+1Ch] [bp-2148h]
  int v29[76]; // [sp+30h] [bp-2134h] BYREF
  char v30[8196]; // [sp+160h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(v30, "Do freq tuning basic.\n");
    sub_41DB8(3, v30, 0);
  }
  v2 = (_DWORD *)dword_550470;
  memset((void *)(dword_550470 + 4), 0, 0x30u);
  *v2 = a1;
  sub_53E00();
  sub_50688(**(_DWORD **)dword_550470);
  v3 = (char *)sub_5516C();
  if ( !v3 )
  {
    sub_23590(255, (unsigned __int8)byte_4D4184, *(unsigned __int8 *)(*(_DWORD *)dword_550470 + 20));
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(v30, 0, 0x2000u);
      strcpy(v30, "\n");
      sub_42CB4(3, v30, 0);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v30, ">>>> Do tuning parallel.\n");
        sub_41DB8(3, v30, 0);
      }
    }
    for ( i = 0; i != 4; ++i )
    {
      if ( sub_27EC8(i) )
        sub_539B0(i, 1);
    }
    v26 = *(_DWORD *)(*(_DWORD *)dword_550470 + 4);
    v28 = *(_DWORD *)(*(_DWORD *)dword_550470 + 16);
    v27 = *(_DWORD *)(*(_DWORD *)dword_550470 + 12);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(
        v30,
        0x2000u,
        "freq_prev = %d, freq_start = %d, freq_step = %d, freq_min = %d\n",
        v26,
        v26,
        v28,
        *(_DWORD *)(*(_DWORD *)dword_550470 + 12));
      sub_41DB8(3, v30, 0);
    }
    v29[0] = v26;
    if ( v26 < v27 )
    {
      v6 = 0;
      v3 = 0;
    }
    else
    {
      v6 = 0;
      while ( 1 )
      {
        if ( (unsigned int)off_BC5EC <= 3
          || (memset(v30, 0, 0x2000u), strcpy(v30, "\n"), sub_42CB4(3, v30, 0), (unsigned int)off_BC5EC <= 3) )
        {
          v7 = sub_53D1C();
          if ( !v7 )
            goto LABEL_59;
        }
        else
        {
          snprintf(v30, 0x2000u, ">>>> freq_curr = %d\n", v29[0]);
          sub_41DB8(3, v30, 0);
          v7 = sub_53D1C();
          if ( !v7 )
          {
LABEL_59:
            v3 = (char *)v7;
            if ( (unsigned int)off_BC5EC > 3 )
            {
              strcpy(v30, "All ready chain done, exit.\n");
              sub_41DB8(3, v30, v7);
            }
            goto LABEL_36;
          }
        }
        for ( j = 0; j != 4; ++j )
        {
          if ( sub_27EC8(j) && sub_53B24(j) == 1 )
            sub_24238(j, (unsigned __int8)byte_4D4184, v26, v29[0], *(_BYTE *)(*(_DWORD *)dword_550470 + 21), 100);
        }
        v26 = v29[0];
        v3 = (char *)sub_5516C();
        if ( v3 )
          break;
        sub_48690(v29[0], dword_BC5A4, 20);
        sub_54D68((int)v29);
        v9 = sub_53578();
        do
        {
          if ( sub_27EC8((int)v3) && sub_53B24((int)v3) == 1 )
            sub_543D8(v3, v9);
          ++v3;
        }
        while ( v3 != (char *)4 );
        for ( k = 0; k != 4; ++k )
        {
          if ( sub_27EC8(k) && sub_53B24(k) == 1 )
          {
            v24 = *(float *)(*(_DWORD *)dword_550470 + 28);
            if ( sub_53EE4(k) )
              sub_539B0(k, 2);
            else
              *(_DWORD *)(dword_550470 + 4 * k + 20) = 1;
            sub_54D24();
            v25 = dword_550470 + 4 * k;
            if ( v24 > *(float *)(v25 + 36) )
              *(float *)(v25 + 36) = v24;
          }
        }
        v11 = 0;
        v12 = (_DWORD *)((char *)dword_80A894 + v9);
        v13 = &v29[4 * v6 + 16];
        do
        {
          v14 = sub_27EC8(v11++);
          if ( v14 )
            v16 = *v12;
          ++v13;
          if ( v14 )
            v15 = v29[0];
          ++v12;
          if ( v14 )
          {
            *(v13 - 1) = v16;
            v29[v6 + 1] = v15;
          }
        }
        while ( v11 != 4 );
        ++v6;
        v29[0] -= v28;
        if ( v27 > v29[0] )
        {
          v3 = 0;
          goto LABEL_36;
        }
      }
      if ( (unsigned int)off_BC5EC > 3 )
      {
        strcpy(v30, "Set voltage failed, exit.\n");
        sub_41DB8(3, v30, 0);
      }
    }
LABEL_36:
    v17 = 0;
    if ( sub_27EC8(0) )
      goto LABEL_39;
    while ( ++v17 != 4 )
    {
      if ( sub_27EC8(v17) )
      {
LABEL_39:
        v18 = 0;
        v19 = (float *)&v29[v17 + 16];
        v20 = 0;
        while ( v20 < v6 - 1 )
        {
          v21 = *v19;
          if ( *v19 < 5.0 )
          {
            v18 = v20;
            break;
          }
          v19 += 4;
          ++v20;
          if ( v21 > *v19 * 1.5 )
            v18 = v20;
        }
        v22 = v29[v18 + 1];
        v23 = (unsigned int)off_BC5EC > 3;
        *(_DWORD *)(dword_550470 + 4 * v17 + 4) = v22;
        if ( v23 )
        {
          snprintf(v30, 0x2000u, "chain %d best level %d, freq %d\n", v17, v18, v22);
          sub_41DB8(3, v30, 0);
        }
      }
    }
  }
  return v3;
}
// 55A68: variable 'v16' is possibly undefined
// 55A6C: variable 'v15' is possibly undefined
// BC5A4: using guessed type int dword_BC5A4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 4D4184: using guessed type char byte_4D4184;
// 550470: using guessed type int dword_550470;
// 80A894: using guessed type _DWORD dword_80A894[4];

//----- (00055E78) --------------------------------------------------------
unsigned int __fastcall sub_55E78(int a1, int a2)
{
  int v4; // r0
  unsigned int v5; // r4
  int v6; // r1
  int v7; // r3
  int v8; // r1
  int v9; // t1
  unsigned int v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r4
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  v4 = sub_27D1C();
  if ( v4 )
  {
    v6 = a2 + (a1 << 10);
    v5 = 0;
    v7 = 0;
    v8 = v6 - 4;
    do
    {
      ++v7;
      v9 = *(_DWORD *)(v8 + 4);
      v8 += 4;
      v5 += v9;
    }
    while ( v4 != v7 );
  }
  else
  {
    v5 = 0;
  }
  v10 = sub_27D1C();
  v11 = sub_962A0(v5, v10);
  v12 = v11;
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "chain = %d, freq_avg = %d\n", a1, v11);
    sub_41DB8(4, s, 0);
  }
  return v12;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00055F24) --------------------------------------------------------
unsigned int __fastcall sub_55F24(int a1, int a2)
{
  int v3; // r8
  unsigned int v4; // r6
  int i; // r4
  bool v6; // zf
  int v8; // r0
  int v9; // r1
  int j; // r3
  unsigned int v11; // r2
  unsigned int v12; // t1
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v3 = a2 - 4;
  v4 = 0xFFFFFF;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      v6 = a1 == 255;
      if ( a1 != 255 )
        v6 = a1 == i;
      if ( v6 )
      {
        v8 = sub_27D1C();
        if ( v8 )
        {
          v9 = v3 + (i << 10);
          for ( j = 0; j != v8; ++j )
          {
            v12 = *(_DWORD *)(v9 + 4);
            v9 += 4;
            v11 = v12;
            if ( v4 >= v12 )
              v4 = v11;
          }
        }
      }
    }
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "chain = %d, freq_min = %d\n", a1, v4);
    sub_41DB8(4, s, 0);
  }
  return v4;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00055FF0) --------------------------------------------------------
unsigned int __fastcall sub_55FF0(int a1, int a2)
{
  unsigned int v2; // r5
  int v4; // r8
  int i; // r4
  bool v6; // zf
  int v8; // r0
  int v9; // r1
  int j; // r3
  unsigned int v11; // r2
  unsigned int v12; // t1
  char s[8192]; // [sp+8h] [bp-2000h] BYREF

  v2 = 0;
  v4 = a2 - 4;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      v6 = a1 == 255;
      if ( a1 != 255 )
        v6 = a1 == i;
      if ( v6 )
      {
        v8 = sub_27D1C();
        if ( v8 )
        {
          v9 = v4 + (i << 10);
          for ( j = 0; j != v8; ++j )
          {
            v12 = *(_DWORD *)(v9 + 4);
            v9 += 4;
            v11 = v12;
            if ( v2 < v12 )
              v2 = v11;
          }
        }
      }
    }
  }
  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "chain = %d, freq_max = %d\n", a1, v2);
    sub_41DB8(4, s, 0);
  }
  return v2;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (000560BC) --------------------------------------------------------
int __fastcall sub_560BC(int a1)
{
  unsigned int v2; // r6
  unsigned int v3; // r8
  unsigned int v4; // r7
  unsigned int v5; // r0
  int v6; // r3
  unsigned int v7; // r1
  char s[8192]; // [sp+10h] [bp-2000h] BYREF

  v2 = sub_55E78(a1, dword_550474 + 4);
  v3 = sub_55F24(a1, dword_550474 + 4);
  v4 = sub_55FF0(a1, dword_550474 + 4);
  v5 = sub_55FF0(a1, dword_550474 + 4116);
  v6 = *(_DWORD *)dword_550474;
  v7 = *(_DWORD *)(*(_DWORD *)dword_550474 + 20);
  if ( v7 > v2 )
  {
    if ( *(_DWORD *)(v6 + 28) > v4 - v3 )
    {
      if ( v7 >= v5 )
        return 0;
      if ( (unsigned int)off_BC5EC <= 3 )
        return 1;
      snprintf(s, 0x2000u, "chain = %d, freq_max_runtime = %d, freq_threshold = %d, max freq enough\n", a1, v5, v7);
    }
    else
    {
      if ( (unsigned int)off_BC5EC <= 3 )
        return 1;
      snprintf(
        s,
        0x2000u,
        "chain = %d, freq_max = %d, freq_min = %d, freq_diff = %d, freq_diff_threshold = %d, freq diff enough\n",
        a1,
        v4,
        v3,
        v4 - v3,
        *(_DWORD *)(v6 + 28));
    }
LABEL_13:
    sub_41DB8(3, s, 0);
    return 1;
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    snprintf(s, 0x2000u, "chain = %d, freq_avg = %d, freq_threshold = %d, avg freq enough\n", a1, v2, v7);
    goto LABEL_13;
  }
  return 1;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550474: using guessed type int dword_550474;

//----- (0005622C) --------------------------------------------------------
unsigned int __fastcall sub_5622C(int a1, int a2)
{
  int i; // r5
  unsigned int result; // r0
  bool v5; // zf
  int v6; // r4
  unsigned int v7; // r8
  void *v8; // r2
  unsigned int v9; // r4
  unsigned int v10; // r0
  int v11; // r1
  char s[8196]; // [sp+10h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(s, 0x2000u, "[DEBUG] Dump freq table, chain = %d.\n", a1);
    sub_41DB8(4, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    result = sub_27EC8(i);
    if ( result )
    {
      v5 = a1 == 255;
      if ( a1 != 255 )
        v5 = a1 == i;
      v6 = !v5;
      if ( v5 )
      {
        if ( (unsigned int)off_BC5EC > 3 )
        {
          memset(s, v6, 0x2000u);
          snprintf(s, 0x2000u, "chain = %d\n", i);
          sub_42CB4(3, s, v6);
        }
        result = sub_27D1C();
        v7 = result;
        v8 = off_BC5EC;
        if ( result )
        {
          v9 = 0;
          do
          {
            if ( (unsigned int)v8 > 3 )
            {
              memset(s, 0, 0x2000u);
              snprintf(s, 0x2000u, "[%3d]:%-3d", v9, *(_DWORD *)(a2 + (i << 10) + 4 * v9));
              sub_42CB4(3, s, 0);
              if ( (unsigned int)off_BC5EC > 3 )
              {
                memset(s, 0, 0x2000u);
                *(_DWORD *)s = &unk_202020;
                sub_42CB4(3, s, 0);
              }
            }
            ++v9;
            v10 = sub_27D2C();
            result = sub_964FC(v9, v10);
            v8 = off_BC5EC;
            if ( !v11 && (unsigned int)off_BC5EC > 3 )
            {
              memset(s, 0, 0x2000u);
              *(_WORD *)s = 10;
              result = (unsigned int)sub_42CB4(3, s, 0);
              v8 = off_BC5EC;
            }
          }
          while ( v7 != v9 );
        }
        if ( (unsigned int)v8 > 3 )
        {
          memset(s, 0, 0x2000u);
          *(_WORD *)s = 10;
          result = (unsigned int)sub_42CB4(3, s, 0);
        }
      }
    }
  }
  return result;
}
// 562D8: variable 'v11' is possibly undefined
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;

//----- (00056444) --------------------------------------------------------
void sub_56444()
{
  char v0[8192]; // [sp+0h] [bp-2000h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v0, "[DEBUG] freq tuning fine exit.\n");
    sub_41DB8(4, v0, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v0, "[DEBUG] Free memory for pm grade.\n");
      sub_41DB8(4, v0, 0);
    }
  }
  if ( dword_550474 )
  {
    free((void *)dword_550474);
    dword_550474 = 0;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550474: using guessed type int dword_550474;

//----- (00056500) --------------------------------------------------------
int __fastcall sub_56500(int a1)
{
  return *(_DWORD *)(dword_550474 + 4 * (a1 + 1024) + 4);
}
// 550474: using guessed type int dword_550474;

//----- (0005651C) --------------------------------------------------------
int __fastcall sub_5651C(int a1, _DWORD *a2)
{
  int result; // r0
  _DWORD *v5; // r2
  _DWORD *v6; // r1
  int v7; // t1
  char v8[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    snprintf(v8, 0x2000u, "[DEBUG] Get freq result, chain = %d.\n", a1);
    sub_41DB8(4, v8, 0);
  }
  result = sub_27D1C();
  if ( result )
  {
    v5 = &a2[result];
    v6 = a2;
    result = dword_550474 + (a1 << 10);
    do
    {
      v7 = *(_DWORD *)(result + 4);
      result += 4;
      *v6++ = v7;
    }
    while ( v6 != v5 );
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550474: using guessed type int dword_550474;

//----- (000565B0) --------------------------------------------------------
int __fastcall sub_565B0(int a1)
{
  return dword_550474 + 4 * (a1 + 3084);
}
// 550474: using guessed type int dword_550474;

//----- (000565D0) --------------------------------------------------------
char *sub_565D0()
{
  int i; // r4
  char *result; // r0
  void *v2; // r3
  const char *v3; // r6
  const char *v4; // r12
  char s[8196]; // [sp+8h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %d\n", "voltage", **(_DWORD **)dword_550474);
    sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "%-40s : ", "freq_base");
      sub_42CB4(3, s, 0);
    }
  }
  for ( i = 0; i != 4; ++i )
  {
    result = (char *)sub_27EC8(i);
    if ( result && (unsigned int)off_BC5EC > 3 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "[%d] = %d ", i, *(_DWORD *)(*(_DWORD *)dword_550474 + 4 * i + 4));
      result = sub_42CB4(3, s, 0);
    }
  }
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    *(_WORD *)s = 10;
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "%-40s : %d\n", "freq_threshold", *(_DWORD *)(*(_DWORD *)dword_550474 + 20));
      result = sub_42CB4(3, s, 0);
      if ( (unsigned int)off_BC5EC <= 3 )
        return result;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "%-40s : %d\n", "freq_serial_threshold", *(_DWORD *)(*(_DWORD *)dword_550474 + 24));
      result = sub_42CB4(3, s, 0);
      if ( (unsigned int)off_BC5EC <= 3 )
        goto LABEL_24;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "%-40s : %d\n", "freq_diff_threshold", *(_DWORD *)(*(_DWORD *)dword_550474 + 28));
      result = sub_42CB4(3, s, 0);
      if ( (unsigned int)off_BC5EC <= 3 )
        return result;
      memset(s, 0, 0x2000u);
      snprintf(s, 0x2000u, "%-40s : %d\n", "freq_step", *(_DWORD *)(*(_DWORD *)dword_550474 + 32));
      result = sub_42CB4(3, s, 0);
    }
    v2 = off_BC5EC;
    if ( (unsigned int)off_BC5EC <= 3 )
    {
LABEL_27:
      if ( (unsigned int)v2 > 3 )
      {
        memset(s, 0, 0x2000u);
        snprintf(s, 0x2000u, "%-40s : %.2f\n", "nonce_rate_threshold", *(float *)(*(_DWORD *)dword_550474 + 48));
        result = sub_42CB4(3, s, 0);
        if ( (unsigned int)off_BC5EC > 3 )
        {
          memset(s, 0, 0x2000u);
          snprintf(s, 0x2000u, "%-40s : %.2f\n", "nonce_rate_dec_threshold", *(float *)(*(_DWORD *)dword_550474 + 52));
          result = sub_42CB4(3, s, 0);
          if ( (unsigned int)off_BC5EC > 3 )
          {
            memset(s, 0, 0x2000u);
            snprintf(s, 0x2000u, "%-40s : %d\n", "freq_tuning_fine_step", *(_DWORD *)(*(_DWORD *)dword_550474 + 56));
            result = sub_42CB4(3, s, 0);
            if ( (unsigned int)off_BC5EC > 3 )
            {
              memset(s, 0, 0x2000u);
              snprintf(s, 0x2000u, "%-40s : %d\n", "freq_tuning_fine_count", *(_DWORD *)(*(_DWORD *)dword_550474 + 60));
              return sub_42CB4(3, s, 0);
            }
          }
        }
      }
      return result;
    }
    v3 = "false";
    memset(s, 0, 0x2000u);
    if ( *(_BYTE *)(*(_DWORD *)dword_550474 + 36) )
      v4 = "true";
    else
      v4 = "false";
    snprintf(s, 0x2000u, "%-40s : %s\n", "is_inc_freq_with_high_vol", v4);
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, 0x2000u);
    if ( *(_BYTE *)(*(_DWORD *)dword_550474 + 37) )
      v3 = "true";
    snprintf(s, 0x2000u, "%-40s : %s\n", "is_inc_freq_with_high_vol_runtime", v3);
    result = sub_42CB4(3, s, 0);
LABEL_24:
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %d\n", "is_board_init_with_power_off", *(_DWORD *)(*(_DWORD *)dword_550474 + 40));
    result = sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC <= 3 )
      return result;
    memset(s, 0, 0x2000u);
    snprintf(s, 0x2000u, "%-40s : %.4f\n", "hw_threshold", *(float *)(*(_DWORD *)dword_550474 + 44));
    result = sub_42CB4(3, s, 0);
    v2 = off_BC5EC;
    goto LABEL_27;
  }
  return result;
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550474: using guessed type int dword_550474;

//----- (00056BCC) --------------------------------------------------------
int __fastcall sub_56BCC(int a1)
{
  _DWORD *v2; // r6
  char v4[8196]; // [sp+0h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 4 )
  {
    strcpy(v4, "[DEBUG] freq tuning fine init.\n");
    sub_41DB8(4, v4, 0);
    if ( (unsigned int)off_BC5EC > 4 )
    {
      strcpy(v4, "[DEBUG] Allocate memory for pm grade.\n");
      sub_41DB8(4, v4, 0);
    }
  }
  v2 = (_DWORD *)dword_550474;
  if ( dword_550474 || (v2 = calloc(0x3044u, 1u), (dword_550474 = (int)v2) != 0) )
  {
    *v2 = a1;
    sub_565D0();
    return 0;
  }
  else
  {
    sub_4FB28(13, 255);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(v4, "Fail to allocate memory for pm grade context.\n");
      sub_41DB8(3, v4, 0);
    }
    return -1;
  }
}
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// 550474: using guessed type int dword_550474;

//----- (00056D18) --------------------------------------------------------
int sub_56D18()
{
  int *v0; // r9
  int i; // r4
  int j; // r4
  int k; // r4
  int v4; // r5
  _DWORD *v6; // r3
  int v7; // r4
  int v8; // r4
  float v9; // s0
  int m; // r4
  int v11; // r4
  int n; // r5
  char *v13; // r5
  unsigned int v14; // r0
  int v15; // r6
  int v16; // r4
  int v17; // r5
  int v18; // r0
  int v19; // r6
  char *v20; // r7
  int *v21; // r4
  int v22; // r9
  int v23; // r6
  unsigned int v24; // t1
  int v25; // r0
  int v26; // r2
  double v27; // d8
  int v28; // r1
  int v29; // r3
  double v30; // d7
  int v31; // r0
  int v32; // r2
  int v33; // r0
  int v34; // r3
  int v35; // t1
  int v36; // r0
  int v37; // r12
  int v38; // r0
  int v39; // r3
  int v40; // r2
  int v41; // t1
  int v42; // r12
  bool v43; // cc
  int v44; // r5
  int v45; // r0
  unsigned int v46; // r6
  int v47; // r12
  int v48; // r0
  _DWORD *v49; // r3
  int v50; // r2
  int v51; // r1
  int v52; // t1
  int v53; // r7
  int v54; // r1
  unsigned __int8 v55; // r2
  unsigned int v56; // r12
  int v57; // r0
  int v58; // r0
  int v59; // r1
  int v60; // r0
  char *v61; // r3
  char *v62; // r1
  void *v63; // r3
  bool v64; // zf
  int v65; // r1
  int v66; // r0
  int v67; // r0
  int v68; // r3
  char *v69; // r2
  int v70; // r0
  int v71; // t1
  int v72; // r0
  int v73; // r1
  int v74; // r3
  int v75; // r0
  int v76; // r0
  int v77; // r3
  char *v78; // r2
  int v79; // r0
  int v80; // t1
  char *v81; // [sp+Ch] [bp-2030h]
  char *v82; // [sp+10h] [bp-202Ch]
  unsigned int v83; // [sp+28h] [bp-2014h] BYREF
  char v84[4]; // [sp+2Ch] [bp-2010h] BYREF
  int v85; // [sp+30h] [bp-200Ch] BYREF
  unsigned __int16 v86; // [sp+34h] [bp-2008h]
  char v87; // [sp+36h] [bp-2006h]
  char s[8196]; // [sp+38h] [bp-2004h] BYREF

  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "Do freq tuning fine.\n");
    sub_41DB8(3, s, 0);
  }
  v0 = &dword_550474;
  for ( i = 0; i != 4; ++i )
  {
    if ( sub_27EC8(i) )
    {
      v72 = sub_27D1C();
      if ( v72 )
      {
        v73 = dword_550474 + 4 * (v72 + (i << 8));
        v74 = dword_550474 + (i << 10);
        v75 = *(_DWORD *)dword_550474 + 4 * i;
        do
        {
          *(_DWORD *)(v74 + 4) = *(_DWORD *)(v75 + 4);
          v74 += 4;
        }
        while ( v74 != v73 );
      }
    }
  }
  sub_50688(**(_DWORD **)dword_550474);
  memcpy((void *)(dword_550474 + 4116), (const void *)(dword_550474 + 4), 0x1000u);
  if ( (unsigned int)off_BC5EC > 3 )
  {
    memset(s, 0, 0x2000u);
    strcpy(s, "\n");
    sub_42CB4(3, s, 0);
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, ">>>> Do freq tuning fine parallel.\n");
      sub_41DB8(3, s, 0);
    }
  }
  for ( j = 0; j != 4; ++j )
  {
    if ( sub_27EC8(j) )
    {
      v64 = sub_560BC(j) == 0;
      v65 = 2;
      v66 = j;
      if ( v64 )
      {
        v65 = 1;
        v66 = j;
      }
      sub_539B0(v66, v65);
    }
  }
LABEL_10:
  while ( 2 )
  {
    if ( !sub_53D1C() )
    {
      v4 = 0;
      goto LABEL_141;
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      snprintf(s, 0x2000u, "is_need_serial = %d\n", 0);
      sub_41DB8(3, s, 0);
      if ( (unsigned int)off_BC5EC > 3 )
      {
        memset(s, 0, 0x2000u);
        strcpy(s, "\n");
        sub_42CB4(3, s, 0);
        if ( (unsigned int)off_BC5EC > 3 )
        {
          strcpy(s, ">>>> Do single grade tuning.\n");
          sub_41DB8(3, s, 0);
        }
      }
    }
    for ( k = 0; k != 4; ++k )
    {
      if ( sub_27EC8(k) && sub_53B24(k) == 1 && (unsigned int)off_BC5EC > 3 )
      {
        snprintf(s, 0x2000u, "chain = %d, grade = %d\n", k, *(_DWORD *)(*v0 + 4 * (k + 3076) + 4));
        sub_41DB8(3, s, 0);
      }
    }
    if ( (unsigned int)off_BC5EC > 3 )
    {
      strcpy(s, "Board init start.\n");
      sub_41DB8(3, s, 0);
    }
    v4 = sub_54338(*(_DWORD *)(*(_DWORD *)*v0 + 40));
    if ( !v4 )
    {
      sub_53E00();
      v6 = (_DWORD *)*v0;
      v7 = 0;
      v6[3081] = 0;
      v6 += 3081;
      v6[1] = 0;
      v6[2] = 0;
      v6[3] = 0;
      memset(s, 0, 0x1000u);
      do
      {
        if ( sub_27EC8(v7) )
        {
          if ( sub_53B24(v7) == 1 )
          {
            v76 = sub_27D1C();
            if ( v76 )
            {
              v77 = *v0 + (v7 << 10);
              v78 = &s[1024 * v7];
              v79 = *v0 + 4 * (v76 + (v7 << 8));
              do
              {
                v80 = *(_DWORD *)(v77 + 4);
                v77 += 4;
                *(_DWORD *)v78 = v80;
                v78 += 4;
              }
              while ( v77 != v79 );
            }
          }
          else if ( sub_55E78(v7, *v0 + 4) <= *(_DWORD *)(*(_DWORD *)*v0 + 24) )
          {
            v67 = sub_27D1C();
            if ( v67 )
            {
              v68 = *v0 + (v7 << 10);
              v69 = &s[1024 * v7];
              v70 = *v0 + 4 * (v67 + (v7 << 8));
              do
              {
                v71 = *(_DWORD *)(v68 + 4);
                v68 += 4;
                *(_DWORD *)v69 = v71;
                v69 += 4;
              }
              while ( v68 != v70 );
            }
          }
          else
          {
            v58 = sub_27D1C();
            if ( v58 )
            {
              v59 = v58 + (v7 << 8);
              v60 = *v0;
              v61 = &s[1024 * v7];
              v62 = &s[4 * v59];
              do
              {
                *(_DWORD *)v61 = *(_DWORD *)(*(_DWORD *)v60 + 24);
                v61 += 4;
              }
              while ( v61 != v62 );
            }
          }
        }
        ++v7;
      }
      while ( v7 != 4 );
      v8 = sub_506A8();
      if ( v8 == sub_50698() )
      {
        v9 = (float)SLODWORD(flt_BC8A4);
        sub_246E8((int)s, (unsigned __int8)byte_4D4184, *(unsigned __int8 *)(*(_DWORD *)*v0 + 36));
      }
      else
      {
        v4 = sub_506AC();
        v9 = (float)SLODWORD(flt_BC8A4);
        sub_246E8((int)s, (unsigned __int8)byte_4D4184, *(unsigned __int8 *)(*(_DWORD *)*v0 + 36));
        if ( v4 )
        {
          v63 = off_BC5EC;
          goto LABEL_121;
        }
      }
      while ( sub_53D1C() )
      {
        for ( m = 0; m != 4; ++m )
        {
          if ( sub_27EC8(m) )
          {
            if ( sub_53B24(m) == 1 )
            {
              v56 = sub_55E78(m, *v0 + 4116);
              if ( (unsigned int)off_BC5EC > 3 )
              {
                snprintf(
                  s,
                  0x2000u,
                  "chain = %d, freq_avg = %d, freq_threshold = %d\n",
                  m,
                  v56,
                  *(_DWORD *)(*(_DWORD *)*v0 + 24));
                sub_41DB8(3, s, 0);
              }
            }
          }
        }
        v11 = 1;
        for ( n = 0; n != 4; ++n )
        {
          if ( sub_27EC8(n) && sub_53B24(n) == 1 )
          {
            v57 = *(_DWORD *)(*v0 + 4 * n + 12324);
            if ( (unsigned int)off_BC5EC > 3 )
            {
              snprintf(
                s,
                0x2000u,
                "chain = %d, grade_curr = %d, is_grade_curr_done = %d\n",
                n,
                *(_DWORD *)(*v0 + 4 * n + 12308),
                *(_DWORD *)(*v0 + 4 * n + 12324));
              sub_41DB8(3, s, 0);
              v57 = *(_DWORD *)(*v0 + 4 * (n + 3080) + 4);
            }
            if ( !v57 )
              v11 = 0;
          }
        }
        if ( (unsigned int)off_BC5EC > 3 )
          goto LABEL_112;
LABEL_39:
        if ( v11 )
          goto LABEL_10;
        do
        {
          if ( sub_27EC8(v11) )
          {
            if ( sub_53B24(v11) == 1 )
            {
              v44 = *(_DWORD *)(*v0 + 4 * (v11 + 3080) + 4);
              if ( !v44 )
              {
                v45 = sub_27D1C();
                v46 = v45;
                if ( v45 )
                {
                  v46 = 0;
                  v47 = *(_DWORD *)*v0;
                  v48 = *v0 + 4 * (v45 + (v11 << 8));
                  v49 = (_DWORD *)(*v0 + (v11 << 10) + 4116);
                  v50 = *v0 + (v11 << 10);
                  do
                  {
                    v52 = *(_DWORD *)(v50 + 4);
                    v50 += 4;
                    v51 = v52;
                    *v49++ = v52;
                    if ( v49[1023] == 1 )
                    {
                      v46 = v51 - *(_DWORD *)(v47 + 32);
                      *(v49 - 1) = v46;
                    }
                  }
                  while ( v50 != v48 );
                }
                else
                {
                  v47 = *(_DWORD *)*v0;
                }
                if ( *(_BYTE *)(v47 + 37) )
                  nullsub_3(v46, 1);
                v9 = (float)v46;
                sub_7F80C((int)&v85, v84, 0);
                v87 = v84[0];
                if ( (unsigned int)off_BC5EC > 3 )
                {
                  snprintf(
                    s,
                    0x2000u,
                    "chain = %d, grade_curr = %d, freq_target = %d\n",
                    v11,
                    *(_DWORD *)(*v0 + 4 * (v11 + 3076) + 4),
                    v46);
                  sub_41DB8(3, s, 0);
                }
                v53 = sub_27D1C();
                v54 = *v0;
                if ( v53 )
                {
                  do
                  {
                    while ( *(_DWORD *)(v54 + 4 * ((v11 << 8) + v44 + 1028) + 4) != v46 )
                    {
                      if ( v53 == ++v44 )
                        goto LABEL_100;
                    }
                    if ( (unsigned int)off_BC5EC > 3 )
                    {
                      snprintf(s, 0x2000u, "chain = %d, asic = %d, freq = %d\n", v11, v44, v46);
                      sub_41DB8(3, s, 0);
                    }
                    v55 = sub_27D8C() * v44++;
                    sub_2A7AC(v11, 0, v55, (unsigned __int8)byte_4D4184, v85, v86);
                    usleep((__useconds_t)&unk_F4240);
                    v54 = *v0;
                  }
                  while ( v53 != v44 );
                }
LABEL_100:
                sub_5622C(v11, v54 + 4116);
              }
            }
          }
          ++v11;
        }
        while ( v11 != 4 );
        v13 = 0;
        v14 = sub_55F24(255, *v0 + 4116);
        sub_48690(v14, dword_BC5A4, 20);
        v83 = sub_55FF0(255, *v0 + 4116);
        sub_54D68((int)&v83);
        v15 = sub_53578();
        do
        {
          if ( sub_27EC8((int)v13) && sub_53B24((int)v13) == 1 && !*(_DWORD *)(*v0 + 4 * (_DWORD)(v13 + 3080) + 4) )
            sub_543D8(v13, v15);
          ++v13;
        }
        while ( v13 != (char *)4 );
        v16 = 0;
        v81 = (char *)&unk_808FFC + v15;
        if ( sub_27EC8(0) )
        {
LABEL_48:
          if ( sub_53B24(v16) == 1 )
          {
            v17 = *(_DWORD *)(*v0 + 4 * (v16 + 3080) + 4);
            if ( !v17 )
            {
              v18 = sub_27D1C();
              if ( v18 > 0 )
              {
                v19 = v16 << 8;
                v82 = (char *)v16;
                v20 = &v81[1024 * v16];
                v21 = v0;
                v22 = v19;
                v23 = v18;
                do
                {
                  v24 = *((_DWORD *)v20 + 1);
                  v20 += 4;
                  v25 = sub_27D5C();
                  v27 = (double)v24;
                  v28 = v22 + v17++ + 2052;
                  v29 = v28;
                  v30 = (double)(8 * v25) * 0.98;
                  if ( (double)v24 <= v30 )
                    v29 = *v21;
                  else
                    v26 = 0;
                  if ( v27 <= v30 )
                    v29 += 4 * v28;
                  else
                    v28 = *v21;
                  if ( v27 <= v30 )
                    *(_DWORD *)(v29 + 4) = 1;
                  else
                    v29 = v28 + 4 * v29;
                  if ( v27 > v30 )
                    *(_DWORD *)(v29 + 4) = v26;
                }
                while ( v23 != v17 );
                v0 = v21;
                v16 = (int)v82;
              }
              v31 = sub_27D1C();
              if ( v31 <= 0 )
                goto LABEL_119;
              v32 = 0;
              v33 = *v0 + 8208 + 4 * (v31 + (v16 << 8));
              v34 = *v0 + (v16 << 10) + 8208;
              do
              {
                v35 = *(_DWORD *)(v34 + 4);
                v34 += 4;
                v32 += v35;
              }
              while ( v33 != v34 );
              if ( !v32 )
LABEL_119:
                sub_539B0(v16, 2);
              v36 = sub_27D1C();
              v37 = *v0;
              if ( v36 )
              {
                v38 = v37 + 4 * (v36 + (v16 << 8));
                v39 = v37 + (v16 << 10);
                v40 = v37 + (v16 << 10) + 4112;
                do
                {
                  v41 = *(_DWORD *)(v40 + 4);
                  v40 += 4;
                  *(_DWORD *)(v39 + 4) = v41;
                  v39 += 4;
                }
                while ( v39 != v38 );
              }
              v42 = v37 + 4 * v16;
              v43 = (unsigned int)off_BC5EC > 3;
              *(_DWORD *)(v42 + 4100) = 1;
              if ( v43 )
              {
                snprintf(
                  s,
                  0x2000u,
                  "Update freq result of high grade, chain = %d, grade_curr = %d.\n",
                  v16,
                  *(_DWORD *)(v42 + 12308));
                sub_41DB8(3, s, 0);
              }
              sub_54D24();
              if ( v9 > *(float *)(*v0 + 4 * v16 + 12340) )
                *(float *)(*v0 + 4 * v16 + 12340) = v9;
              if ( sub_560BC(v16) )
                sub_539B0(v16, 2);
            }
          }
        }
        while ( ++v16 != 4 )
        {
          if ( sub_27EC8(v16) )
            goto LABEL_48;
        }
      }
      if ( (unsigned int)off_BC5EC <= 3 )
        continue;
      v11 = 1;
LABEL_112:
      snprintf(s, 0x2000u, "is_single_grade_done = %d\n", v11);
      sub_41DB8(3, s, 0);
      goto LABEL_39;
    }
    break;
  }
  if ( (unsigned int)off_BC5EC <= 3 )
    goto LABEL_19;
  strcpy(s, "Board init failed, exit.\n");
  sub_41DB8(3, s, 0);
  v63 = off_BC5EC;
LABEL_121:
  if ( (unsigned int)v63 <= 3 )
    goto LABEL_19;
  strcpy(s, "Parallel tuning failed, exit.\n");
  sub_41DB8(3, s, 0);
LABEL_141:
  if ( (unsigned int)off_BC5EC > 3 )
  {
    strcpy(s, "Dump freq tuning fine result:\n");
    sub_41DB8(3, s, 0);
  }
LABEL_19:
  sub_5622C(255, *v0 + 4);
  return v4;
}
// 57244: variable 'v26' is possibly undefined
// 23324: using guessed type int __fastcall nullsub_3(_DWORD, _DWORD);
// BC5A4: using guessed type int dword_BC5A4;
// BC5EC: using guessed type _UNKNOWN *off_BC5EC;
// BC8A4: using guessed type float flt_BC8A4;
// 4D4184: using guessed type char byte_4D4184;
// 550474: using guessed type int dword_550474;

//----- (000579FC) --------------------------------------------------------
char *__fastcall sub_579FC(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v4 + v5);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (00057A38) --------------------------------------------------------
int __fastcall sub_57A38(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (00057A48) --------------------------------------------------------
int __fastcall sub_57A48(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (00057A58) --------------------------------------------------------
int __fastcall sub_57A58(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (00057A68) --------------------------------------------------------
char *__fastcall sub_57A68(const char *a1, _BYTE *a2)
{
  if ( !strcasecmp(a1, "yes") || !strcasecmp(a1, "true") )
  {
    *a2 = 1;
    return 0;
  }
  else if ( !strcasecmp(a1, "no") || !strcasecmp(a1, "false") )
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    return sub_585A0(a1);
  }
}

//----- (00057AFC) --------------------------------------------------------
char *__fastcall sub_57AFC(const char *a1, _BYTE *a2)
{
  char *result; // r0

  result = sub_57A68(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (00057B1C) --------------------------------------------------------
int __fastcall sub_57B1C(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (00057BB0) --------------------------------------------------------
char *__fastcall sub_57BB0(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return sub_579FC("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return sub_579FC("'%s' is out of range", a1);
  return result;
}

//----- (00057C38) --------------------------------------------------------
char *__fastcall sub_57C38(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  result = sub_57BB0(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (00057D00) --------------------------------------------------------
int __fastcall sub_57D00(_DWORD *a1)
{
  ++*a1;
  return 0;
}

//----- (00057D18) --------------------------------------------------------
void __fastcall __noreturn sub_57D18(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// BDA14: using guessed type int stdout;

//----- (00057D38) --------------------------------------------------------
void __fastcall __noreturn sub_57D38(int a1)
{
  const char *v1; // r0

  v1 = (const char *)sub_58AB8(dword_AB7A70, a1);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 58AB8: using guessed type int __fastcall sub_58AB8(_DWORD, _DWORD);
// BDA14: using guessed type int stdout;
// AB7A70: using guessed type int dword_AB7A70;

//----- (00057D78) --------------------------------------------------------
char *__fastcall sub_57D78(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( !v2 )
    v3 = "false";
  return strncpy(a1, v3, 0x50u);
}

//----- (00057D9C) --------------------------------------------------------
char *__fastcall sub_57D9C(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( !v2 )
    v3 = "true";
  return strncpy(a1, v3, 0x50u);
}

//----- (00057DC0) --------------------------------------------------------
char *__fastcall sub_57DC0(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  bool v5; // cc
  size_t v6; // r5
  char *v7; // r0
  const char *v8; // r1
  _BYTE *v9; // r4
  char *result; // r0

  v4 = strlen(*a2);
  v5 = v4 > 0x4E;
  v6 = v4;
  *a1 = 34;
  v7 = a1 + 1;
  v8 = *a2;
  if ( v5 )
  {
    result = strncpy(v7, v8, 0x4Eu);
    a1[79] = 34;
  }
  else
  {
    v9 = &a1[v6];
    result = strncpy(v7, v8, v6);
    v9[1] = 34;
    if ( v6 != 78 )
      v9[2] = 0;
  }
  return result;
}

//----- (00057E20) --------------------------------------------------------
int __fastcall sub_57E20(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%i", *a2);
}

//----- (00057E34) --------------------------------------------------------
int __fastcall sub_57E34(char *a1, float *a2)
{
  return snprintf(a1, 0x50u, "%.1f", *a2);
}

//----- (00057E60) --------------------------------------------------------
int __fastcall sub_57E60(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%u", *a2);
}

//----- (00057E74) --------------------------------------------------------
int __fastcall sub_57E74(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%li", *a2);
}

//----- (00057E88) --------------------------------------------------------
int __fastcall sub_57E88(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%lu", *a2);
}

//----- (00057E9C) --------------------------------------------------------
const char *__fastcall sub_57E9C(unsigned int *a1, size_t *a2)
{
  _DWORD *v2; // r12
  const char *v3; // r4
  int v5; // r4
  unsigned int v6; // lr

  *a1 = 0;
  if ( !dword_AB7A74 )
    return 0;
  v2 = (_DWORD *)dword_AB7A6C;
  if ( *(_DWORD *)(dword_AB7A6C + 4) == 8 )
  {
    v5 = 28;
    v6 = 1;
    do
    {
      *a1 = v6;
      if ( dword_AB7A74 <= v6++ )
        return 0;
      v2 = (_DWORD *)(dword_AB7A6C + v5);
      v5 += 28;
    }
    while ( v2[1] == 8 );
  }
  v3 = (const char *)(*v2 + 1);
  *a2 = strcspn(v3, (const char *)&off_A3F68);
  return v3;
}
// A3F68: using guessed type _UNKNOWN *off_A3F68;
// AB7A6C: using guessed type int dword_AB7A6C;
// AB7A74: using guessed type int dword_AB7A74;

//----- (00057F3C) --------------------------------------------------------
int __fastcall sub_57F3C(int a1, size_t *a2)
{
  int v2; // r3
  size_t v3; // r0
  bool v4; // zf
  int v5; // r4

  v2 = *(unsigned __int8 *)(a1 + *a2);
  v3 = a1 + *a2;
  v4 = (v2 & 0xDF) == 0;
  if ( (v2 & 0xDF) != 0 )
    v4 = v2 == 61;
  if ( v4 )
    return 0;
  v5 = v3 + 2;
  *a2 = strcspn((const char *)(v3 + 2), (const char *)&off_A3F68);
  return v5;
}
// A3F68: using guessed type _UNKNOWN *off_A3F68;

//----- (00057F84) --------------------------------------------------------
int __fastcall sub_57F84(int a1, unsigned int *a2, size_t *a3)
{
  unsigned int v3; // r3
  _DWORD *v7; // r2
  int result; // r0
  const char *v9; // r4

  v3 = *a2;
  if ( *a2 >= dword_AB7A74 )
    return 0;
  while ( 1 )
  {
    v7 = (_DWORD *)(dword_AB7A6C + 28 * v3);
    if ( v7[1] != 8 )
      break;
LABEL_6:
    *a2 = ++v3;
    if ( v3 >= dword_AB7A74 )
      return 0;
  }
  if ( a1 )
  {
    result = sub_57F3C(a1, a3);
    a1 = result;
    if ( result )
      return result;
    v3 = *a2;
    goto LABEL_6;
  }
  v9 = (const char *)(*v7 + 1);
  *a3 = strcspn(v9, (const char *)&off_A3F68);
  return (int)v9;
}
// A3F68: using guessed type _UNKNOWN *off_A3F68;
// AB7A6C: using guessed type int dword_AB7A6C;
// AB7A74: using guessed type int dword_AB7A74;

//----- (0005803C) --------------------------------------------------------
int __fastcall sub_5803C(const char **a1)
{
  __int64 v1; // r2
  bool v2; // cc
  _BYTE *v4; // r4
  int v5; // r0
  const char *v6; // r12
  unsigned int v7; // r3
  int v8; // r3
  bool v9; // zf
  int result; // r0
  int status; // [sp+Ch] [bp-4h] BYREF

  v1 = *(_QWORD *)a1;
  v2 = (unsigned int)a1[1] > 4;
  if ( a1[1] != (const char *)4 )
    v2 = (unsigned int)(a1[1] - 1) > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", (const char *)v1, HIDWORD(v1));
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", (const char *)v1);
  if ( *(_BYTE *)v1 != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)v1);
  v4 = (_BYTE *)(v1 + 1);
  v5 = strcspn((const char *)(v1 + 1), (const char *)&off_A3F68);
  for ( status = v5; ; v5 = status )
  {
    if ( *v4 == 45 )
    {
      if ( v5 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v6 = a1[1];
      ++dword_AB7A64;
    }
    else
    {
      if ( v5 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v5 + 1, v4 - 1);
      v6 = a1[1];
      v7 = (unsigned int)(v6 - 2) & 0xFFFFFFFD;
      if ( !v7 )
        v7 = dword_AB7A60;
      ++dword_AB7A68;
      if ( ((unsigned int)(v6 - 2) & 0xFFFFFFFD) == 0 )
        dword_AB7A60 = v7 + 1;
    }
    if ( v6 == (const char *)1 )
    {
      v8 = (unsigned __int8)v4[v5];
      v9 = v8 == 61;
      if ( v8 != 61 )
        v9 = v8 == 32;
      if ( v9 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, &v4[v5 + 1]);
    }
    result = sub_57F3C((int)v4, (size_t *)&status);
    v4 = (_BYTE *)result;
    if ( !result )
      break;
  }
  return result;
}
// A3F68: using guessed type _UNKNOWN *off_A3F68;
// AB7A60: using guessed type int dword_AB7A60;
// AB7A64: using guessed type int dword_AB7A64;
// AB7A68: using guessed type int dword_AB7A68;

//----- (000581B0) --------------------------------------------------------
int __fastcall sub_581B0(int *a1)
{
  char *v2; // r0
  int v3; // r3
  int *v4; // lr
  char *v5; // r12
  int v6; // r4
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  char *v11; // r12
  int result; // r0
  int v13; // r1
  int v14; // r2

  v2 = (char *)realloc((void *)dword_AB7A6C, 28 * (dword_AB7A74 + 1));
  v3 = dword_AB7A74;
  v4 = a1;
  v5 = v2;
  dword_AB7A6C = (int)v2;
  ++dword_AB7A74;
  v6 = 7 * v3;
  v7 = *v4;
  v8 = v4[1];
  v9 = v4[2];
  v10 = v4[3];
  v4 += 4;
  v11 = &v5[4 * v6];
  *(_DWORD *)v11 = v7;
  *((_DWORD *)v11 + 1) = v8;
  *((_DWORD *)v11 + 2) = v9;
  *((_DWORD *)v11 + 3) = v10;
  v11 += 16;
  result = *v4;
  v13 = v4[1];
  v14 = v4[2];
  *(_DWORD *)v11 = *v4;
  *((_DWORD *)v11 + 1) = v13;
  *((_DWORD *)v11 + 2) = v14;
  return result;
}
// AB7A6C: using guessed type int dword_AB7A6C;
// AB7A74: using guessed type int dword_AB7A74;

//----- (00058214) --------------------------------------------------------
const char *__fastcall sub_58214(unsigned int *a1, size_t *a2)
{
  const char *v4; // r0

  v4 = sub_57E9C(a1, a2);
  if ( !v4 )
    return 0;
  while ( *v4 != 45 )
  {
    v4 = (const char *)sub_57F84((int)v4, a1, a2);
    if ( !v4 )
      return 0;
  }
  --*a2;
  return v4 + 1;
}

//----- (0005826C) --------------------------------------------------------
_BYTE *__fastcall sub_5826C(int a1, unsigned int *a2, size_t *a3)
{
  _BYTE *v5; // r0

  v5 = (_BYTE *)sub_57F84(a1, a2, a3);
  if ( !v5 )
    return 0;
  while ( *v5 != 45 )
  {
    v5 = (_BYTE *)sub_57F84((int)v5, a2, a3);
    if ( !v5 )
      return 0;
  }
  --*a3;
  return v5 + 1;
}

//----- (000582C4) --------------------------------------------------------
const char *__fastcall sub_582C4(unsigned int *a1)
{
  const char *result; // r0
  size_t v3; // [sp+4h] [bp-8h] BYREF

  v3 = 0;
  result = sub_57E9C(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (const char *)sub_57F84((int)result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00058324) --------------------------------------------------------
_BYTE *__fastcall sub_58324(int a1, unsigned int *a2)
{
  _BYTE *result; // r0
  size_t v4; // [sp+4h] [bp-8h] BYREF

  v4 = 1;
  result = (_BYTE *)sub_57F84(a1, a2, &v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (_BYTE *)sub_57F84((int)result, a2, &v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00058384) --------------------------------------------------------
int __fastcall sub_58384(
        const char *a1,
        const char *a2,
        const char *a3,
        const char *a4,
        const char *a5,
        const char *a6,
        const char *a7)
{
  const char *v8[8]; // [sp+4h] [bp-20h] BYREF

  v8[1] = a2;
  v8[0] = a1;
  v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  v8[5] = a6;
  v8[6] = a7;
  sub_5803C(v8);
  return sub_581B0((int *)v8);
}

//----- (000583C8) --------------------------------------------------------
int __fastcall sub_583C8(int result, int a2)
{
  const char **v3; // r4
  int v4; // r6
  const char *v5; // r3
  int v6[8]; // [sp+4h] [bp-20h] BYREF

  v3 = (const char **)result;
  v4 = dword_AB7A74;
  if ( a2 )
  {
    v6[0] = 0;
    memset(&v6[2], 0, 16);
    v6[6] = a2;
    v6[1] = 8;
    sub_581B0(v6);
    v5 = v3[1];
    if ( v5 == (const char *)16 )
    {
LABEL_7:
      result = 7 * v4;
      *(_DWORD *)(dword_AB7A6C + 28 * v4 + 20) = dword_AB7A74 - v4;
      return result;
    }
  }
  else
  {
    v5 = *(const char **)(result + 4);
    if ( v5 == (const char *)16 )
      return result;
  }
  do
  {
    if ( v5 == (const char *)8 )
    {
      result = sub_583C8(*v3, v3[6]);
    }
    else
    {
      sub_5803C(v3);
      result = sub_581B0((int *)v3);
    }
    v3 += 7;
    v5 = v3[1];
  }
  while ( v5 != (const char *)16 );
  if ( a2 )
    goto LABEL_7;
  return result;
}
// AB7A6C: using guessed type int dword_AB7A6C;
// AB7A74: using guessed type int dword_AB7A74;

//----- (0005849C) --------------------------------------------------------
bool __fastcall sub_5849C(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  int v6; // r0
  int v8; // [sp+4h] [bp-8h] BYREF

  dword_AB7A70 = (int)*a2;
  v8 = 0;
  do
    v6 = sub_58608(a1, a2, &v8, a3);
  while ( v6 == 1 );
  return v6 == 0;
}
// AB7A70: using guessed type int dword_AB7A70;

//----- (000584F8) --------------------------------------------------------
void sub_584F8()
{
  free((void *)dword_AB7A6C);
  dword_AB7A6C = 0;
}
// AB7A6C: using guessed type int dword_AB7A6C;

//----- (00058518) --------------------------------------------------------
int sub_58518(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  return fputc(10, (FILE *)stderr);
}
// BDA08: using guessed type int stderr;

//----- (00058560) --------------------------------------------------------
void __noreturn sub_58560(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// BDA08: using guessed type int stderr;

//----- (000585A0) --------------------------------------------------------
char *__fastcall sub_585A0(const char *a1)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", a1);
  return v3;
}

//----- (000585D0) --------------------------------------------------------
void *__fastcall sub_585D0(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(a2 + 4 * a3), (const void *)(a2 + 4 * a3 + 4), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (00058608) --------------------------------------------------------
int __fastcall sub_58608(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  bool v8; // zf
  int result; // r0
  const char **v10; // r6
  int *v11; // r3
  int v12; // r4
  int v13; // t1
  unsigned __int8 *v14; // r0
  int v15; // lr
  unsigned int v16; // r12
  int v17; // r1
  int v18; // r3
  char *v19; // r10
  int v20; // r3
  int v21; // r1
  char *v22; // r11
  int v23; // r10
  const char *v24; // r0
  int *v25; // r3
  const char *v26; // r7
  int *v27; // r11
  const char *v28; // r10
  size_t v29; // r4
  size_t v30; // lr
  int *v31; // r3
  const char *v32; // r11
  size_t v33; // r0
  int *v34; // r2
  const char *v35; // r11
  const char *v36; // r3
  size_t v37; // r10
  const char *v38; // [sp+8h] [bp-14h]
  int v39; // [sp+Ch] [bp-10h]
  unsigned int v40; // [sp+10h] [bp-Ch] BYREF
  size_t n[2]; // [sp+14h] [bp-8h] BYREF

  v8 = getenv("POSIXLY_CORRECT") == 0;
  result = (int)a2[1];
  if ( !v8 )
  {
    v10 = a2 + 1;
    if ( !result )
      return result;
    if ( *(_BYTE *)result != 45 )
      return 0;
    v12 = 1;
    if ( *(_BYTE *)(result + 1) == 45 )
      goto LABEL_23;
LABEL_15:
    v14 = (unsigned __int8 *)sub_582C4(&v40);
    if ( v14 )
    {
      v15 = *a3 + 1;
      if ( *v14 == (unsigned __int8)(*v10)[v15] )
      {
LABEL_17:
        v16 = v40;
        v38 = (const char *)(v14 - 1);
        *a3 = v15;
        n[0] = 2;
        v17 = 28 * v16;
        v18 = dword_AB7A6C + 28 * v16;
        if ( *(_DWORD *)(v18 + 4) != 1 )
        {
LABEL_18:
          if ( v15 )
          {
            v19 = (char *)&(*v10)[v15 + 1];
            if ( *v19 )
            {
              *a3 = 0;
              goto LABEL_20;
            }
          }
          v19 = (char *)a2[v12 + 1];
          if ( v19 )
            goto LABEL_20;
          a4("%s: %.*s: %s", *a2, n[0], v38, "requires an argument");
          return -1;
        }
LABEL_37:
        v19 = 0;
        v22 = (char *)(*(int (__fastcall **)(_DWORD))(v18 + 8))(*(_DWORD *)(v18 + 20));
        goto LABEL_38;
      }
      while ( 1 )
      {
        v14 = sub_58324((int)v14, &v40);
        if ( !v14 )
          break;
        v15 = *a3 + 1;
        if ( (unsigned __int8)(*v10)[v15] == *v14 )
          goto LABEL_17;
      }
    }
LABEL_36:
    v33 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v33, *v10, "unrecognized option");
    return -1;
  }
  if ( !result )
    return result;
  if ( *(_BYTE *)result == 45 )
  {
    v10 = a2 + 1;
    v12 = 1;
  }
  else
  {
    v11 = (int *)(a2 + 2);
    v12 = 1;
    do
    {
      v10 = (const char **)v11;
      v13 = *v11++;
      result = v13;
      ++v12;
      if ( !v13 )
        return result;
    }
    while ( *(_BYTE *)result != 45 );
  }
  if ( *(_BYTE *)(result + 1) != 45 )
    goto LABEL_15;
LABEL_23:
  v23 = *(unsigned __int8 *)(result + 2);
  if ( !*(_BYTE *)(result + 2) )
  {
    sub_585D0(a1, (int)a2, v12);
    return v23;
  }
  if ( *a3 )
    _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, "parse_one");
  v24 = sub_58214(&v40, n);
  if ( !v24 )
    goto LABEL_36;
  v25 = a3;
  v26 = v24;
  v27 = v25;
  v39 = v12;
  while ( 1 )
  {
    v28 = *v10;
    v29 = n[0];
    if ( strncmp(*v10 + 2, v26, n[0]) )
      goto LABEL_35;
    v30 = v29 + 2;
    if ( v28[v29 + 2] == 61 )
      break;
    if ( !v28[v29 + 2] )
    {
      v16 = v40;
      v31 = v27;
      v32 = v26;
      a3 = v31;
      v12 = v39;
      v38 = v32 - 2;
      v17 = 28 * v40;
      n[0] = v30;
      v18 = dword_AB7A6C + 28 * v40;
      if ( *(_DWORD *)(v18 + 4) == 1 )
        goto LABEL_37;
      goto LABEL_34;
    }
LABEL_35:
    v26 = sub_5826C((int)v26, &v40, n);
    if ( !v26 )
      goto LABEL_36;
  }
  v16 = v40;
  v34 = v27;
  v35 = v26;
  a3 = v34;
  v36 = v28;
  v37 = v29 + 3;
  v12 = v39;
  v17 = 28 * v40;
  v19 = (char *)&v36[v37];
  n[0] = v30;
  v38 = v35 - 2;
  v18 = dword_AB7A6C + 28 * v40;
  if ( *(_DWORD *)(v18 + 4) == 1 )
  {
    if ( v19 )
    {
      a4("%s: %.*s: %s", *a2, v30, v38, "doesn't allow an argument");
      return -1;
    }
    goto LABEL_37;
  }
  if ( !v19 )
  {
LABEL_34:
    v15 = *a3;
    goto LABEL_18;
  }
LABEL_20:
  v20 = dword_AB7A6C;
  v21 = dword_AB7A6C + v17;
  if ( *(_DWORD *)(v21 + 4) == 4 )
  {
    sub_57B1C((int)v19, *(_DWORD **)(v21 + 20));
    v16 = v40;
    v20 = dword_AB7A6C;
  }
  v22 = (char *)(*(int (__fastcall **)(char *, _DWORD))(v20 + 28 * v16 + 12))(v19, *(_DWORD *)(v20 + 28 * v16 + 20));
LABEL_38:
  if ( v22 )
  {
    a4("%s: %.*s: %s", *a2, n[0], v38, v22);
    free(v22);
    return -1;
  }
  else
  {
    if ( *a3 )
    {
      if ( !(*v10)[*a3 + 1] )
      {
        *a3 = 0;
        goto LABEL_42;
      }
    }
    else
    {
LABEL_42:
      sub_585D0(a1, (int)a2, v12);
      if ( v19 )
      {
        if ( *v10 == v19 )
          sub_585D0(a1, (int)a2, v12);
      }
    }
    return 1;
  }
}
// AB7A6C: using guessed type int dword_AB7A6C;

//----- (00058AB8) --------------------------------------------------------
char *__fastcall sub_58AB8(const char *a1, const char *a2)
{
  size_t v3; // r7
  int v4; // r4
  unsigned int v5; // r8
  size_t v6; // r7
  size_t v7; // r0
  size_t v8; // r7
  size_t v9; // r5
  const char *v10; // r11
  char *v11; // r0
  char *v12; // r4
  int v13; // r0
  char *v14; // r1
  char *v15; // r4
  char *v16; // r7
  char *v17; // r12
  int v18; // r8
  int v19; // r0
  int v20; // r2
  char *v21; // r5
  int v22; // r7
  unsigned int v23; // r8
  int v24; // r2
  unsigned int v25; // r4
  unsigned int v26; // r4
  char *v27; // r3
  int v28; // r3
  const char *v29; // r2
  int v30; // r0
  unsigned int v31; // r4
  char *v32; // r3
  char *v33; // r0
  char *v34; // r0
  int v36; // r2
  int v37; // r3
  __int16 *v39; // [sp+0h] [bp-74h]
  const char *v40; // [sp+4h] [bp-70h]
  char *s; // [sp+8h] [bp-6Ch]
  char *v42; // [sp+10h] [bp-64h]
  char *v43; // [sp+14h] [bp-60h]
  unsigned int v44[22]; // [sp+1Ch] [bp-58h] BYREF

  v3 = dword_AB7A68 + 20 + strlen(a1);
  if ( a2 )
  {
    v3 += strlen(a2);
    if ( !dword_AB7A74 )
      goto LABEL_13;
    v4 = dword_AB7A6C;
  }
  else
  {
    if ( !dword_AB7A74 )
    {
      a2 = "";
      goto LABEL_13;
    }
    v36 = 0;
    v4 = dword_AB7A6C;
    v37 = dword_AB7A6C;
    do
    {
      ++v36;
      if ( *(void (__fastcall __noreturn **)(int))(v37 + 8) == sub_57D38 )
      {
        a2 = *(const char **)(v37 + 20);
        if ( a2 )
        {
          v3 += strlen(*(const char **)(v37 + 20));
          goto LABEL_4;
        }
      }
      v37 += 28;
    }
    while ( v36 != dword_AB7A74 );
    a2 = "";
  }
LABEL_4:
  v5 = 0;
  v40 = a2;
  do
  {
    while ( 1 )
    {
      v9 = v3 + 6;
      v10 = *(const char **)(v4 + 24);
      if ( *(_DWORD *)(v4 + 4) != 8 )
        break;
      ++v5;
      v3 += strlen(*(const char **)(v4 + 24)) + 3;
      v4 += 28;
      if ( v5 >= dword_AB7A74 )
        goto LABEL_12;
    }
    if ( v10 != (const char *)&unk_AB7A78 )
    {
      v6 = strlen(*(const char **)v4);
      v7 = v6 + v9 + strlen(v10);
      v8 = v7 + 118;
      if ( !*(_DWORD *)(v4 + 16) )
        v8 = v7 + 21;
      v3 = v8 + 1;
    }
    ++v5;
    v4 += 28;
  }
  while ( v5 < dword_AB7A74 );
LABEL_12:
  a2 = v40;
LABEL_13:
  v11 = (char *)malloc(v3);
  v12 = v11;
  v43 = v11;
  if ( v11 )
  {
    v13 = sprintf(v11, "Usage: %s", a1);
    v14 = v12;
    v15 = &v12[v13];
    v16 = v15 + 3;
    *(_DWORD *)&v14[v13] = &unk_2D5B20;
    v17 = (char *)sub_582C4(v44);
    if ( v17 )
    {
      v18 = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_AB7A6C + 28 * v44[0] + 24) != &unk_AB7A78 )
          v16[v18++] = *v17;
        v17 = sub_58324((int)v17, v44);
      }
      while ( v17 );
      if ( v18 )
      {
        v15 = &v16[v18 + 1];
        *(_WORD *)&v16[v18] = 93;
      }
    }
    v19 = sprintf(v15, " %s", a2);
    v20 = dword_AB7A74;
    v39 = &word_98278;
    v21 = &v15[v19 + 1];
    *(_WORD *)&v15[v19] = 10;
    if ( v20 )
    {
      v22 = 0;
      v23 = 0;
      do
      {
        v28 = dword_AB7A6C + v22;
        v29 = *(const char **)(dword_AB7A6C + v22 + 24);
        if ( v29 != (const char *)&unk_AB7A78 )
        {
          if ( *(_DWORD *)(v28 + 4) == 8 )
          {
            v21 += sprintf(v21, "%s:\n", v29);
          }
          else
          {
            v30 = sprintf(v21, "%s", *(const char **)v28);
            v31 = v30;
            v32 = &v21[v30];
            if ( *(_DWORD *)(dword_AB7A6C + v22 + 4) == 2 )
            {
              v42 = &v21[v30];
              s = *(char **)(dword_AB7A6C + v22);
              v33 = strchr(s, 32);
              v32 = v42;
              if ( !v33 )
              {
                v34 = strchr(s, 61);
                v32 = v42;
                if ( !v34 )
                {
                  v31 += 6;
                  strcpy(v42, " <arg>");
                  v32 = &v21[v31];
                }
              }
            }
            if ( v31 > 0x13 )
              v24 = 1;
            else
              v24 = 20 - v31;
            v25 = sprintf(v32, "%.*s", v24, "                    ", v39) + v31;
            v26 = sprintf(&v21[v25], "%s", *(const char **)(dword_AB7A6C + v22 + 24)) + v25;
            v27 = &v21[v26];
            if ( *(_DWORD *)(dword_AB7A6C + v22 + 16) )
            {
              v44[20] = (unsigned int)&unk_2E2E2E;
              (*(void (__fastcall **)(unsigned int *, _DWORD))(dword_AB7A6C + v22 + 16))(
                v44,
                *(_DWORD *)(dword_AB7A6C + v22 + 20));
              v27 = &v21[sprintf(&v21[v26], " (default: %s)", (const char *)v44) + v26];
            }
            *(_WORD *)v27 = *v39;
            v21 = v27 + 1;
          }
        }
        ++v23;
        v22 += 28;
      }
      while ( dword_AB7A74 > v23 );
    }
    *v21 = 0;
  }
  return v43;
}
// 58CE4: variable 'v39' is possibly undefined
// 98278: using guessed type __int16 word_98278;
// AB7A68: using guessed type int dword_AB7A68;
// AB7A6C: using guessed type int dword_AB7A6C;
// AB7A74: using guessed type int dword_AB7A74;

//----- (00058EFC) --------------------------------------------------------
char *__fastcall memchr(char *result, __int16 a2, unsigned int a3)
{
  _DWORD *v3; // r3
  bool v4; // zf
  int v5; // r4
  char *v6; // r12
  char *v7; // r2
  char *v8; // r3

  if ( !a3 )
    return 0;
  if ( ((unsigned __int8)result & 3) != 0 )
  {
    if ( (unsigned __int8)*result == (unsigned __int8)a2 )
      return result;
    v3 = result + 1;
    while ( 1 )
    {
      --a3;
      result = (char *)v3;
      if ( !a3 )
        return 0;
      v4 = ((unsigned __int8)v3 & 3) == 0;
      v3 = (_DWORD *)((char *)v3 + 1);
      if ( v4 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
  }
  v5 = (unsigned __int16)(a2 << 8) | (unsigned __int8)a2 | (((unsigned __int16)(a2 << 8) | (unsigned __int8)a2) << 16);
  if ( a3 > 3 && (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) == 0 )
  {
    v6 = result + 4;
    while ( 1 )
    {
      a3 -= 4;
      result = v6;
      v6 += 4;
      if ( a3 <= 3 )
        break;
      if ( (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) != 0 )
        goto LABEL_16;
    }
    if ( !a3 )
      return 0;
  }
LABEL_16:
  if ( (unsigned __int8)*result != (unsigned __int8)a2 )
  {
    v7 = &result[a3];
    v8 = result + 1;
    while ( 1 )
    {
      result = v8++;
      if ( result == v7 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (00059010) --------------------------------------------------------
unsigned int __fastcall sub_59010(int a1, unsigned int a2, int *a3)
{
  int v3; // r6
  int v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // r5
  unsigned int v10; // r7
  int v11; // r8
  unsigned int v12; // r4
  int v13; // r12
  int v14; // r5
  unsigned int v15; // r3
  int v16; // r6
  unsigned int v17; // r6
  unsigned int v18; // r7
  unsigned int result; // r0
  unsigned int v20; // r5
  bool v21; // zf

  v3 = 1;
  v4 = 1;
  v5 = 0;
  v6 = -1;
  while ( 1 )
  {
    v7 = v4 + v5;
    v8 = a1 + v6;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v4);
      v10 = *(unsigned __int8 *)(a1 + v7);
      if ( v10 >= v9 )
        break;
      v5 = v7;
      v4 = 1;
      v3 = v7 - v6;
      ++v7;
      v8 = a1 + v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( v10 == v9 )
    {
      v21 = v4++ == v3;
      if ( v21 )
      {
        v5 = v7;
        v4 = 1;
      }
    }
    else
    {
      v3 = 1;
      v6 = v5;
      v4 = 1;
      ++v5;
    }
  }
LABEL_5:
  v11 = 1;
  v12 = 0;
  v13 = 1;
  v14 = -1;
  *a3 = v3;
  while ( 1 )
  {
    v15 = v13 + v12;
    v16 = a1 + v14;
    if ( a2 <= v13 + v12 )
      break;
    while ( 1 )
    {
      v17 = *(unsigned __int8 *)(v16 + v13);
      v18 = *(unsigned __int8 *)(a1 + v15);
      if ( v18 <= v17 )
        break;
      v12 = v15;
      v13 = 1;
      v11 = v15 - v14;
      ++v15;
      v16 = a1 + v14;
      if ( a2 <= v15 )
        goto LABEL_9;
    }
    if ( v18 == v17 )
    {
      v21 = v13++ == v11;
      if ( v21 )
      {
        v12 = v15;
        v13 = 1;
      }
    }
    else
    {
      v11 = 1;
      v14 = v12;
      v13 = 1;
      ++v12;
    }
  }
LABEL_9:
  result = v6 + 1;
  v20 = v14 + 1;
  if ( v20 >= v6 + 1 )
  {
    *a3 = v11;
    return v20;
  }
  return result;
}

//----- (00059120) --------------------------------------------------------
int __fastcall sub_59120(int a1, int a2, char *s1, unsigned int a4)
{
  size_t v8; // r4
  size_t v9; // r6
  int *v10; // r3
  char *v11; // r1
  int v12; // r3
  int v13; // t1
  unsigned int v14; // r0
  unsigned int v15; // r3
  bool v16; // cf
  unsigned int v17; // r1
  unsigned int v18; // r1
  char *v19; // lr
  unsigned __int8 *v20; // r12
  int v21; // r9
  int v22; // t1
  int v23; // t1
  unsigned int v24; // lr
  unsigned __int8 *v25; // r1
  char *v26; // r8
  int v27; // r10
  int v28; // t1
  int v29; // t1
  int result; // r0
  size_t v31; // r3
  size_t v32; // r2
  unsigned int v33; // r10
  unsigned int v34; // r9
  int v35; // r3
  unsigned __int8 *v36; // r1
  size_t v37; // r3
  char *v38; // r12
  int v39; // r8
  int v40; // t1
  int v41; // t1
  unsigned __int8 *v42; // r3
  char *v43; // r1
  int v44; // lr
  int v45; // t1
  int v46; // t1
  unsigned int v47; // [sp+0h] [bp-424h]
  unsigned int v48; // [sp+4h] [bp-420h]
  int v49; // [sp+4h] [bp-420h]
  unsigned int v50; // [sp+Ch] [bp-418h]
  int v51[253]; // [sp+1Ch] [bp-408h] BYREF
  int v52; // [sp+41Ch] [bp-8h] BYREF

  v8 = a4 - 1;
  if ( a4 > 2 )
  {
    v9 = sub_59010((int)s1, a4, v51);
    v48 = v51[0];
  }
  else
  {
    v9 = a4 - 1;
    v48 = 1;
    v51[0] = 1;
  }
  v10 = v51;
  do
  {
    v10[1] = a4;
    ++v10;
  }
  while ( v10 != &v52 );
  if ( a4 )
  {
    v11 = s1 - 1;
    v12 = v8;
    do
    {
      v13 = (unsigned __int8)*++v11;
      v51[v13 + 1] = v12;
      v16 = v12-- != 0;
    }
    while ( v16 );
  }
  v14 = memcmp(s1, &s1[v48], v9);
  if ( !v14 )
  {
    v47 = a2 - a4;
    v50 = a4 - v48;
    v15 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = v51[*(unsigned __int8 *)(a1 + v15 + v8) + 1];
        if ( v17 )
        {
          v16 = 1;
          if ( v14 )
            v16 = v17 >= v48;
          v14 = 0;
          if ( !v16 )
            v17 = v50;
          v15 += v17;
          goto LABEL_15;
        }
        v18 = v9 < v14 ? v14 : v9;
        if ( v18 < v8 )
          break;
LABEL_25:
        v24 = v9 - 1;
        if ( v9 > v14 && (v25 = (unsigned __int8 *)(a1 + v9 - 1 + v15), (unsigned __int8)s1[v9 - 1] == *v25) )
        {
          v26 = &s1[v9 - 1];
          while ( v24 - 1 != v14 - 1 )
          {
            v28 = (unsigned __int8)*--v26;
            v27 = v28;
            v29 = *--v25;
            if ( v27 != v29 )
              break;
            --v24;
          }
        }
        else
        {
          v24 = v9;
        }
        if ( v14 + 1 > v24 )
          return a1 + v15;
        v14 = v50;
        v15 += v48;
        if ( v47 < v15 )
          return 0;
      }
      v19 = &s1[v18];
      v20 = (unsigned __int8 *)(a1 + v18 + v15);
      if ( *v20 == (unsigned __int8)s1[v18] )
      {
        while ( ++v18 < v8 )
        {
          v22 = (unsigned __int8)*++v19;
          v21 = v22;
          v23 = *++v20;
          if ( v21 != v23 )
            goto LABEL_35;
        }
        goto LABEL_25;
      }
LABEL_35:
      v14 = 0;
      v15 += v18 + 1 - v9;
LABEL_15:
      if ( v47 < v15 )
        return 0;
    }
  }
  v31 = a4 - v9;
  v32 = v9 - 1;
  v33 = a2 - a4;
  if ( a4 - v9 < v9 )
    v31 = v9;
  v34 = 0;
  v49 = v31 + 1;
  while ( 1 )
  {
    result = a1 + v34;
    v35 = v51[*(unsigned __int8 *)(a1 + v34 + v8) + 1];
    if ( !v35 )
      break;
LABEL_52:
    v34 += v35;
LABEL_53:
    if ( v34 > v33 )
      return 0;
  }
  if ( v9 < v8 )
  {
    v36 = (unsigned __int8 *)(a1 + v9 + v34);
    if ( *v36 != (unsigned __int8)s1[v9] )
    {
      v37 = v9;
LABEL_55:
      v34 += v37 + 1 - v9;
      goto LABEL_53;
    }
    v38 = &s1[v9];
    v37 = v9;
    while ( ++v37 < v8 )
    {
      v40 = (unsigned __int8)*++v38;
      v39 = v40;
      v41 = *++v36;
      if ( v39 != v41 )
        goto LABEL_55;
    }
  }
  if ( !v9 )
    return result;
  v42 = (unsigned __int8 *)(a1 + v32 + v34);
  if ( *v42 != (unsigned __int8)s1[v32] )
  {
LABEL_51:
    v35 = v49;
    goto LABEL_52;
  }
  v43 = &s1[v32];
  while ( v43 != s1 )
  {
    v45 = (unsigned __int8)*--v43;
    v44 = v45;
    v46 = *--v42;
    if ( v44 != v46 )
      goto LABEL_51;
  }
  return result;
}

//----- (0005944C) --------------------------------------------------------
int __fastcall memmem(char *a1, unsigned int a2, char *a3, unsigned int a4)
{
  char *v6; // r5
  char *v9; // r0
  _BOOL4 v10; // r3
  unsigned int v11; // r7
  size_t v12; // r6
  unsigned int v13; // r0
  unsigned int v14; // r2
  size_t v15; // r12
  size_t v16; // r3
  char *v17; // lr
  char *v18; // r1
  int v19; // r8
  int v20; // t1
  int v21; // t1
  unsigned int v22; // lr
  char *v23; // r3
  char *v24; // r7
  int v25; // r9
  int v26; // t1
  int v27; // t1
  size_t v29; // r3
  size_t v30; // r9
  unsigned int v31; // r0
  unsigned int v32; // r7
  char *v33; // r2
  size_t v34; // r3
  char *v35; // r1
  int v36; // lr
  int v37; // t1
  int v38; // t1
  char *v39; // r3
  char *v40; // r2
  int v41; // r12
  int v42; // t1
  int v43; // t1
  int v44; // [sp+4h] [bp-20h]
  int v45; // [sp+8h] [bp-1Ch]
  int v46; // [sp+1Ch] [bp-8h] BYREF

  if ( !a4 )
    return (int)a1;
  if ( a4 > a2 )
    return 0;
  if ( a4 > 0x1F )
    return sub_59120((int)a1, a2, a3, a4);
  v9 = memchr(a1, (unsigned __int8)*a3, a2);
  v6 = v9;
  v10 = a4 == 1;
  if ( !v9 )
    v10 = 1;
  if ( v10 )
    return (int)v6;
  v11 = a2 - (v9 - a1);
  if ( a4 > v11 )
    return 0;
  if ( a4 > 2 )
  {
    v12 = sub_59010((int)a3, a4, &v46);
    v45 = v46;
  }
  else
  {
    v12 = a4 - 1;
    v45 = 1;
    v46 = 1;
  }
  v13 = memcmp(a3, &a3[v45], v12);
  if ( !v13 )
  {
    v14 = v11 - a4;
    v15 = 0;
    while ( 1 )
    {
      if ( v12 < v15 )
        v16 = v15;
      else
        v16 = v12;
      if ( a4 > v16 )
      {
        v17 = &a3[v16];
        v18 = &v6[v16 + v13];
        if ( a3[v16] != *v18 )
        {
LABEL_32:
          v15 = 0;
          v13 += 1 - v12 + v16;
          goto LABEL_29;
        }
        while ( a4 != ++v16 )
        {
          v20 = (unsigned __int8)*++v17;
          v19 = v20;
          v21 = (unsigned __int8)*++v18;
          if ( v19 != v21 )
            goto LABEL_32;
        }
      }
      v22 = v12 - 1;
      if ( v12 > v15 && (v23 = &v6[v12 - 1 + v13], a3[v12 - 1] == *v23) )
      {
        v24 = &a3[v12 - 1];
        while ( v22 - 1 != v15 - 1 )
        {
          v26 = (unsigned __int8)*--v24;
          v25 = v26;
          v27 = (unsigned __int8)*--v23;
          if ( v25 != v27 )
            break;
          --v22;
        }
      }
      else
      {
        v22 = v12;
      }
      if ( v15 + 1 > v22 )
      {
        v6 += v13;
        return (int)v6;
      }
      v15 = a4 - v45;
      v13 += v45;
LABEL_29:
      if ( v14 < v13 )
        return 0;
    }
  }
  v29 = a4 - v12;
  v30 = v12 - 1;
  v31 = v11 - a4;
  if ( a4 - v12 < v12 )
    v29 = v12;
  v32 = 0;
  v44 = v29 + 1;
  while ( 1 )
  {
    if ( a4 > v12 )
    {
      v33 = &v6[v12 + v32];
      if ( *v33 != a3[v12] )
      {
        v34 = v12;
LABEL_49:
        v32 += 1 - v12 + v34;
        goto LABEL_50;
      }
      v35 = &a3[v12];
      v34 = v12;
      while ( a4 != ++v34 )
      {
        v37 = (unsigned __int8)*++v35;
        v36 = v37;
        v38 = (unsigned __int8)*++v33;
        if ( v36 != v38 )
          goto LABEL_49;
      }
    }
    if ( !v12 )
      return (int)&v6[v32];
    v39 = &v6[v30 + v32];
    if ( *v39 == a3[v30] )
      break;
LABEL_52:
    v32 += v44;
LABEL_50:
    if ( v31 < v32 )
      return 0;
  }
  v40 = &a3[v30];
  while ( v40 != a3 )
  {
    v42 = (unsigned __int8)*--v40;
    v41 = v42;
    v43 = (unsigned __int8)*--v39;
    if ( v41 != v43 )
      goto LABEL_52;
  }
  return (int)&v6[v32];
}

//----- (00059734) --------------------------------------------------------
unsigned int *__fastcall sub_59734(unsigned int *result)
{
  unsigned int j; // [sp+808h] [bp-Ch]
  unsigned int i; // [sp+80Ch] [bp-8h]

  if ( result )
  {
    for ( i = 0; *result > i; ++i )
    {
      for ( j = 0; result[18 * i + 2] > j; ++j )
        ;
    }
  }
  return result;
}

//----- (000597D8) --------------------------------------------------------
int __fastcall sub_597D8(_DWORD *a1)
{
  int result; // r0
  char v3[2048]; // [sp+8h] [bp-80Ch] BYREF
  unsigned int v4; // [sp+808h] [bp-Ch] BYREF
  int v5; // [sp+80Ch] [bp-8h]

  v4 = 0;
  v5 = 0;
  memset(a1, 0, 0x124u);
  result = sub_5A800(2, &v4);
  if ( v4 )
  {
    if ( (v4 & 0x80000000) == 0 )
    {
      dword_55047C = 0;
      v4 = (unsigned __int16)v4;
      while ( v4 )
      {
        if ( (v4 & 1) != 0 )
        {
          a1[18 * *a1 + 1] = v5;
          a1[18 * *a1 + 3 + a1[18 * *a1 + 2]] = v5;
          result = (int)a1;
          ++a1[18 * (*a1)++ + 2];
        }
        v4 >>= 1;
        ++v5;
      }
    }
    else
    {
      dword_55047C = 1;
      v4 >>= 24;
      snprintf(v3, 0x800u, "HASH_ON_PLUG T9 = 0x%x\n", v4);
      result = sub_41DB8(2, v3, 0);
      while ( v4 )
      {
        if ( (v4 & 1) != 0 )
        {
          a1[18 * *a1 + 1] = v5;
          if ( v5 == 1 )
          {
            a1[18 * *a1 + 3] = 2;
            a1[18 * *a1 + 4] = 10;
            a1[18 * *a1 + 5] = 11;
            a1[18 * *a1 + 2] = 3;
          }
          else if ( v5 )
          {
            if ( v5 == 2 )
            {
              a1[18 * *a1 + 3] = 3;
              a1[18 * *a1 + 4] = 12;
              a1[18 * *a1 + 5] = 13;
              a1[18 * *a1 + 2] = 3;
            }
          }
          else
          {
            a1[18 * *a1 + 3] = 1;
            a1[18 * *a1 + 4] = 8;
            a1[18 * *a1 + 5] = 9;
            a1[18 * *a1 + 2] = 3;
          }
          ++*a1;
        }
        v4 >>= 1;
        ++v5;
      }
    }
  }
  else
  {
    strcpy(v3, "Cannot Find Any Plug In!\r\n");
    return sub_41DB8(0, v3, 0);
  }
  return result;
}
// 55047C: using guessed type int dword_55047C;

//----- (00059CE4) --------------------------------------------------------
int sub_59CE4()
{
  char v2[2048]; // [sp+0h] [bp-804h] BYREF

  if ( dword_550478 )
    return 0;
  if ( sub_5A388() )
  {
    strcpy(v2, "fpga init failed\n");
    sub_41DB8(0, v2, 0);
    return -1;
  }
  else if ( sub_5AB38() )
  {
    strcpy(v2, "gpio init failed\n");
    sub_41DB8(0, v2, 0);
    return -2;
  }
  else
  {
    memset(dword_550480, 0, sizeof(dword_550480));
    sub_597D8(dword_550480);
    sub_59734(dword_550480);
    dword_550478 = 1;
    sub_5A0A8();
    sub_5E2B4();
    sub_5CA90();
    return 0;
  }
}
// 550478: using guessed type int dword_550478;
// 550480: using guessed type _DWORD dword_550480[73];

//----- (00059E14) --------------------------------------------------------
void sub_59E14()
{
  if ( dword_550478 )
  {
    sub_5CB0C();
    sub_5A6B4();
    sub_5A0C4();
    sub_5E4B4();
    sub_5AC7C();
    dword_550478 = 0;
  }
}
// 550478: using guessed type int dword_550478;

//----- (00059E5C) --------------------------------------------------------
void *__fastcall sub_59E5C(void *result)
{
  void *dest; // [sp+4h] [bp-8h]

  dest = result;
  if ( result )
  {
    sub_597D8(dword_550480);
    return memcpy(dest, dword_550480, 0x124u);
  }
  return result;
}
// 550480: using guessed type _DWORD dword_550480[73];

//----- (00059EA4) --------------------------------------------------------
int __fastcall sub_59EA4(const char *a1, int a2)
{
  char v6[12]; // [sp+8h] [bp-82Ch] BYREF
  char dest[32]; // [sp+808h] [bp-2Ch] BYREF
  int fd; // [sp+828h] [bp-Ch]
  int i; // [sp+82Ch] [bp-8h]

  fd = socket(2, 1, 0);
  if ( fd >= 0 )
  {
    strcpy(dest, a1);
    if ( ioctl(fd, 0x8927u, dest) >= 0 )
    {
      for ( i = 0; i <= 5; ++i )
        *(_BYTE *)(a2 + i) = dest[i + 18];
      close(fd);
      return 0;
    }
    else
    {
      strcpy(v6, "error ioctl");
      sub_41DB8(0, v6, 0);
      close(fd);
      return -2;
    }
  }
  else
  {
    strcpy(v6, "error sock");
    sub_41DB8(0, v6, 0);
    return -1;
  }
}

//----- (0005A004) --------------------------------------------------------
int __fastcall sub_5A004(void *a1)
{
  if ( !a1 )
    return -1;
  memset(a1, 0, 0x10u);
  return sub_59EA4("eth0", (int)a1);
}

//----- (0005A060) --------------------------------------------------------
int __fastcall sub_5A060(int a1)
{
  if ( a1 )
    return sub_59EA4("eth0", a1);
  else
    return -1;
}

//----- (0005A0A8) --------------------------------------------------------
int sub_5A0A8()
{
  return 0;
}

//----- (0005A0C4) --------------------------------------------------------
void sub_5A0C4()
{
  ;
}

//----- (0005A0DC) --------------------------------------------------------
int __fastcall sub_5A0DC(int a1)
{
  int v4; // [sp+80Ch] [bp-10h] BYREF
  int v5; // [sp+810h] [bp-Ch] BYREF
  int i; // [sp+814h] [bp-8h]

  v5 = 0;
  sub_5A800(0, &v4);
  v4 = (unsigned __int16)v4;
  for ( i = 0; ; ++i )
  {
    if ( i > 5 )
      return -1;
    sub_5A800(1, &v5);
    if ( a1 == (BYTE1(v5) & 7) )
      break;
    usleep(0x2710u);
  }
  if ( v4 == 45093 )
    return 240 * (unsigned __int8)v5;
  else
    return 120 * (unsigned __int8)v5;
}

//----- (0005A1C0) --------------------------------------------------------
int sub_5A1C0()
{
  return 6;
}

//----- (0005A1DC) --------------------------------------------------------
int sub_5A1DC()
{
  return -1;
}

//----- (0005A200) --------------------------------------------------------
int __fastcall sub_5A200(int a1)
{
  int v2; // [sp+Ch] [bp-8h]

  if ( !a1 )
    return sub_5B948(954, 1);
  if ( a1 == 1 )
    return sub_5B948(955, 1);
  v2 = sub_5B948(954, 1);
  return v2 + sub_5B948(955, 1);
}

//----- (0005A298) --------------------------------------------------------
int __fastcall sub_5A298(int a1)
{
  int v2; // [sp+Ch] [bp-8h]

  if ( !a1 )
    return sub_5B948(954, 0);
  if ( a1 == 1 )
    return sub_5B948(955, 0);
  v2 = sub_5B948(954, 0);
  return v2 + sub_5B948(955, 0);
}

//----- (0005A330) --------------------------------------------------------
int __fastcall sub_5A330(int a1)
{
  if ( dword_55047C )
    return dword_BCD4C[a1];
  else
    return dword_BD038[a1];
}
// BCD4C: using guessed type _DWORD dword_BCD4C[187];
// BD038: using guessed type _DWORD dword_BD038[187];
// 55047C: using guessed type int dword_55047C;

//----- (0005A388) --------------------------------------------------------
int sub_5A388()
{
  char v2[4]; // [sp+8h] [bp-804h] BYREF

  if ( dword_5505A4 )
    return 0;
  dword_5505A8 = open("/dev/axi_fpga_dev", 2);
  if ( dword_5505A8 >= 0 )
  {
    dword_5505AC = (int)mmap(0, 0x1200u, 3, 1, dword_5505A8, 0);
    if ( dword_5505AC )
    {
      dword_5505B0 = open("/dev/fpga_mem", 2);
      if ( dword_5505B0 >= 0 )
      {
        dword_5505B4 = (int)mmap(0, 0x1000000u, 3, 1, dword_5505B0, 0);
        if ( dword_5505B4 )
        {
          snprintf(v2, 0x800u, "mmap fpga_mem_addr_hal = 0x%x\n", dword_5505B4);
          sub_41DB8(3, v2, 0);
          dword_5505A4 = 1;
          return 0;
        }
        else
        {
          snprintf(v2, 0x800u, "mmap fpga_mem_addr_hal failed. fpga_mem_addr_hal = 0x%x\n", 0);
          sub_41DB8(0, v2, 0);
          munmap((void *)dword_5505AC, 0x1200u);
          close(dword_5505A8);
          close(dword_5505B0);
          return -1;
        }
      }
      else
      {
        snprintf(v2, 0x800u, "/dev/fpga_mem open failed. fd_fpga_mem_hal = %d\n", dword_5505B0);
        sub_41DB8(0, v2, 0);
        perror("open");
        munmap((void *)dword_5505AC, 0x1200u);
        close(dword_5505A8);
        return -1;
      }
    }
    else
    {
      snprintf(v2, 0x800u, "mmap axi_fpga_addr failed. axi_fpga_addr = %p\n", 0);
      sub_41DB8(0, v2, 0);
      close(dword_5505A8);
      return -2;
    }
  }
  else
  {
    snprintf(v2, 0x800u, "/dev/axi_fpga_dev open failed. fd = %d\n", dword_5505A8);
    sub_41DB8(0, v2, 0);
    return -1;
  }
}
// 5505A4: using guessed type int dword_5505A4;
// 5505A8: using guessed type int dword_5505A8;
// 5505AC: using guessed type int dword_5505AC;
// 5505B0: using guessed type int dword_5505B0;
// 5505B4: using guessed type int dword_5505B4;

//----- (0005A6B4) --------------------------------------------------------
void sub_5A6B4()
{
  char v0[2048]; // [sp+4h] [bp-808h] BYREF
  int v1; // [sp+804h] [bp-8h]

  if ( dword_5505A4 )
  {
    v1 = munmap((void *)dword_5505AC, 0x1200u);
    if ( v1 < 0 )
    {
      strcpy(v0, "munmap failed!\n");
      sub_41DB8(0, v0, 0);
    }
    v1 = munmap((void *)dword_5505B4, 0x1000000u);
    if ( v1 < 0 )
    {
      strcpy(v0, "munmap fpga_mem_addr_hal failed!\n");
      sub_41DB8(0, v0, 0);
    }
    dword_5505A4 = 0;
    close(dword_5505A8);
    close(dword_5505B0);
  }
}
// 5505A4: using guessed type int dword_5505A4;
// 5505A8: using guessed type int dword_5505A8;
// 5505AC: using guessed type int dword_5505AC;
// 5505B0: using guessed type int dword_5505B0;
// 5505B4: using guessed type int dword_5505B4;

//----- (0005A800) --------------------------------------------------------
int __fastcall sub_5A800(int a1, _DWORD *a2)
{
  int v3; // r4

  if ( !dword_5505A4 && sub_5A388() )
    return -1;
  v3 = dword_5505AC;
  *a2 = *(_DWORD *)(v3 + 4 * sub_5A330(a1));
  return 0;
}
// 5505A4: using guessed type int dword_5505A4;
// 5505AC: using guessed type int dword_5505AC;

//----- (0005A87C) --------------------------------------------------------
int __fastcall sub_5A87C(int a1, int a2)
{
  int v3; // r4

  if ( !dword_5505A4 && sub_5A388() )
    return -1;
  v3 = dword_5505AC;
  *(_DWORD *)(v3 + 4 * sub_5A330(a1)) = a2;
  return 0;
}
// 5505A4: using guessed type int dword_5505A4;
// 5505AC: using guessed type int dword_5505AC;

//----- (0005A8F4) --------------------------------------------------------
int sub_5A8F4()
{
  if ( dword_5505A4 || !sub_5A388() )
    return dword_5505B4;
  else
    return 0;
}
// 5505A4: using guessed type int dword_5505A4;
// 5505B4: using guessed type int dword_5505B4;

//----- (0005A93C) --------------------------------------------------------
int __fastcall sub_5A93C(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0005A974) --------------------------------------------------------
int sub_5A974()
{
  _DWORD v1[2]; // [sp+814h] [bp-28h] BYREF
  unsigned __int8 v2; // [sp+81Fh] [bp-1Dh] BYREF
  int v3; // [sp+820h] [bp-1Ch]
  void *ptr; // [sp+824h] [bp-18h]
  int v5; // [sp+828h] [bp-14h]
  _DWORD *v6; // [sp+82Ch] [bp-10h]
  int v7; // [sp+830h] [bp-Ch]
  int i; // [sp+834h] [bp-8h]

  v7 = 0;
  prctl(15, "gpio", 0, 0, 0);
  while ( dword_5505BC )
  {
    if ( !pthread_mutex_lock(&stru_5505DC) )
    {
      v6 = sub_6027C(dword_5505F4);
      for ( i = ((int (__fastcall *)(_DWORD *))*v6)(v6); i; i = ((int (__fastcall *)(_DWORD *))*v6)(v6) )
      {
        v5 = v6[5];
        ptr = (void *)((int (__fastcall *)(int))v6[2])(i);
        v3 = ***(_DWORD ***)(v5 + 16);
        v2 = 0;
        v7 = sub_5B764(v3, &v2);
        if ( v7 )
        {
          free(ptr);
          break;
        }
        if ( *((_DWORD *)ptr + 1) != v2 )
        {
          (*(void (__fastcall **)(int, _DWORD))ptr)(v3, v2);
          v1[0] = *(_DWORD *)ptr;
          v1[1] = v2;
          ((void (__fastcall *)(_DWORD *, _DWORD *, int))v6[1])(v6, v1, 8);
        }
        free(ptr);
      }
      sub_60300(v6);
      pthread_mutex_unlock(&stru_5505DC);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 5505BC: using guessed type int dword_5505BC;
// 5505DC: using guessed type pthread_mutex_t stru_5505DC;
// 5505F4: using guessed type int dword_5505F4;

//----- (0005AB38) --------------------------------------------------------
int sub_5AB38()
{
  return 0;
}

//----- (0005AB54) --------------------------------------------------------
int sub_5AB54()
{
  char v1[2048]; // [sp+0h] [bp-82Ch] BYREF
  pthread_attr_t attr; // [sp+800h] [bp-2Ch] BYREF
  size_t stacksize; // [sp+824h] [bp-8h]

  if ( dword_5505B8 )
  {
    strcpy(v1, "gpio re init\n");
    sub_41DB8(1, v1, 0);
  }
  else
  {
    pthread_mutex_init(&stru_5505DC, 0);
    dword_5505F4 = (int)sub_5FDE8((int)sub_5A93C, 0, 0);
    pthread_mutex_init(&stru_5505C4, 0);
    dword_5505BC = 1;
    pthread_attr_init(&attr);
    stacksize = 0x200000;
    pthread_attr_setstacksize(&attr, 0x200000u);
    pthread_create((pthread_t *)&dword_5505C0, &attr, (void *(*)(void *))sub_5A974, 0);
    dword_5505B8 = 1;
  }
  return 0;
}
// 5505B8: using guessed type int dword_5505B8;
// 5505BC: using guessed type int dword_5505BC;
// 5505C0: using guessed type int dword_5505C0;
// 5505C4: using guessed type pthread_mutex_t stru_5505C4;
// 5505DC: using guessed type pthread_mutex_t stru_5505DC;
// 5505F4: using guessed type int dword_5505F4;

//----- (0005AC7C) --------------------------------------------------------
void sub_5AC7C()
{
  ;
}

//----- (0005AC94) --------------------------------------------------------
int sub_5AC94()
{
  int result; // r0

  if ( dword_5505B8 )
  {
    dword_5505BC = 0;
    pthread_join(dword_5505C0, 0);
    pthread_mutex_destroy(&stru_5505DC);
    sub_60084((void ***)dword_5505F4);
    dword_5505B8 = 0;
    return pthread_mutex_destroy(&stru_5505C4);
  }
  return result;
}
// 5505B8: using guessed type int dword_5505B8;
// 5505BC: using guessed type int dword_5505BC;
// 5505C0: using guessed type int dword_5505C0;
// 5505C4: using guessed type pthread_mutex_t stru_5505C4;
// 5505DC: using guessed type pthread_mutex_t stru_5505DC;
// 5505F4: using guessed type int dword_5505F4;

//----- (0005AD20) --------------------------------------------------------
int __fastcall sub_5AD20(int a1, int a2)
{
  int v5; // [sp+Ch] [bp-810h] BYREF
  char v6[2048]; // [sp+10h] [bp-80Ch] BYREF
  _DWORD v7[2]; // [sp+810h] [bp-Ch] BYREF

  v5 = a1;
  if ( a2 )
  {
    if ( !dword_5505B8 )
      sub_5AB54();
    if ( pthread_mutex_lock(&stru_5505DC) )
    {
      strcpy(v6, "fail to lock gpio ctrl mutex\n");
      sub_41DB8(0, v6, 0);
      return -1;
    }
    else
    {
      if ( !sub_5FEC8((int *)dword_5505F4, (int)&v5) )
      {
        v7[0] = a2;
        v7[1] = -1;
        sub_5FE68((int *)dword_5505F4, &v5, 4u, v7, 8u);
      }
      pthread_mutex_unlock(&stru_5505DC);
      return 0;
    }
  }
  else
  {
    strcpy(v6, "bad param\n");
    sub_41DB8(0, v6, 0);
    return -1;
  }
}
// 5505B8: using guessed type int dword_5505B8;
// 5505DC: using guessed type pthread_mutex_t stru_5505DC;
// 5505F4: using guessed type int dword_5505F4;

//----- (0005AEA4) --------------------------------------------------------
int __fastcall sub_5AEA4(int a1, int a2)
{
  int v4; // [sp+4h] [bp-808h] BYREF
  char v5[2048]; // [sp+8h] [bp-804h] BYREF

  v4 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&stru_5505DC) )
    {
      strcpy(v5, "fail to lock gpio ctrl mutex\n");
      sub_41DB8(0, v5, 0);
      return -1;
    }
    else
    {
      if ( sub_5FEC8((int *)dword_5505F4, (int)&v4) )
      {
        sub_5FF34((int *)dword_5505F4, (int)&v4);
      }
      else
      {
        strcpy(v5, "callback function not registered before\n");
        sub_41DB8(1, v5, 0);
      }
      pthread_mutex_unlock(&stru_5505DC);
      return 0;
    }
  }
  else
  {
    strcpy(v5, "bad param\n");
    sub_41DB8(0, v5, 0);
    return -1;
  }
}
// 5505DC: using guessed type pthread_mutex_t stru_5505DC;
// 5505F4: using guessed type int dword_5505F4;

//----- (0005B034) --------------------------------------------------------
int __fastcall sub_5B034(int a1)
{
  char v4[2048]; // [sp+8h] [bp-844h] BYREF
  char s[64]; // [sp+808h] [bp-44h] BYREF

  if ( pthread_mutex_lock(&stru_5505C4) )
  {
    strcpy(v4, "failed to api lock\n");
    sub_41DB8(0, v4, 0);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(s, 0) )
    {
      pthread_mutex_unlock(&stru_5505C4);
      return 0;
    }
    else
    {
      pthread_mutex_unlock(&stru_5505C4);
      return 1;
    }
  }
}
// 5505C4: using guessed type pthread_mutex_t stru_5505C4;

//----- (0005B10C) --------------------------------------------------------
int __fastcall sub_5B10C(int a1)
{
  char v4[2048]; // [sp+8h] [bp-84Ch] BYREF
  char s[64]; // [sp+808h] [bp-4Ch] BYREF
  size_t n; // [sp+848h] [bp-Ch]
  int fd; // [sp+84Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_5505C4) )
  {
    strcpy(v4, "failed to api lock\n");
    sub_41DB8(0, v4, 0);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(s, 0) )
    {
      fd = open("/sys/class/gpio/export", 1);
      if ( fd >= 0 )
      {
        n = snprintf(s, 0x40u, "%d", a1);
        if ( write(fd, s, n) >= 0 )
        {
          close(fd);
          pthread_mutex_unlock(&stru_5505C4);
          return 0;
        }
        else
        {
          snprintf(v4, 0x800u, "Failed to export gpio %d!", a1);
          sub_41DB8(0, v4, 0);
          close(fd);
          pthread_mutex_unlock(&stru_5505C4);
          return -3;
        }
      }
      else
      {
        strcpy(v4, "Failed to open export for writing!\n");
        sub_41DB8(0, v4, 0);
        pthread_mutex_unlock(&stru_5505C4);
        return -2;
      }
    }
    else
    {
      pthread_mutex_unlock(&stru_5505C4);
      return 0;
    }
  }
}
// 5505C4: using guessed type pthread_mutex_t stru_5505C4;

//----- (0005B308) --------------------------------------------------------
int __fastcall sub_5B308(int a1)
{
  char v4[2048]; // [sp+10h] [bp-84Ch] BYREF
  char s[64]; // [sp+810h] [bp-4Ch] BYREF
  size_t n; // [sp+850h] [bp-Ch]
  int fd; // [sp+854h] [bp-8h]

  if ( pthread_mutex_lock(&stru_5505C4) )
  {
    strcpy(v4, "failed to api lock\n");
    sub_41DB8(0, v4, 0);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    fd = access(s, 0);
    if ( fd )
    {
      snprintf(v4, 0x800u, "port %d already unexported, ret = %d\n", a1, fd);
      sub_41DB8(1, v4, 0);
      perror("access error");
      pthread_mutex_unlock(&stru_5505C4);
      return 0;
    }
    else
    {
      fd = open("/sys/class/gpio/unexport", 1);
      if ( fd >= 0 )
      {
        n = snprintf(s, 0x40u, "%d", a1);
        if ( write(fd, s, n) >= 0 )
        {
          close(fd);
          pthread_mutex_unlock(&stru_5505C4);
          return 0;
        }
        else
        {
          snprintf(v4, 0x800u, "Failed to unexport gpio %d!", a1);
          sub_41DB8(0, v4, 0);
          close(fd);
          pthread_mutex_unlock(&stru_5505C4);
          return -2;
        }
      }
      else
      {
        strcpy(v4, "Failed to open unexport for writing!\n");
        sub_41DB8(0, v4, 0);
        pthread_mutex_unlock(&stru_5505C4);
        return -2;
      }
    }
  }
}
// 5505C4: using guessed type pthread_mutex_t stru_5505C4;

//----- (0005B564) --------------------------------------------------------
int __fastcall sub_5B564(int a1, int a2)
{
  int v3; // r2
  size_t v4; // r3
  int v5; // r2
  char v9[2048]; // [sp+14h] [bp-848h] BYREF
  char s[64]; // [sp+814h] [bp-48h] BYREF
  int fd; // [sp+854h] [bp-8h]

  if ( pthread_mutex_lock(&stru_5505C4) )
  {
    strcpy(v9, "failed to api lock\n");
    sub_41DB8(0, v9, 0);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/direction", a1);
    fd = open(s, 1);
    if ( fd >= 0 )
    {
      if ( a2 )
        v3 = 3;
      else
        v3 = 0;
      if ( a2 )
        v4 = 3;
      else
        v4 = 2;
      if ( write(fd, &aIn[v3], v4) >= 0 )
      {
        close(fd);
        pthread_mutex_unlock(&stru_5505C4);
        return 0;
      }
      else
      {
        if ( a2 )
          v5 = 3;
        else
          v5 = 0;
        snprintf(v9, 0x800u, "Failed to set gpio %d direction %s !\n", a1, &aIn[v5]);
        sub_41DB8(0, v9, 0);
        close(fd);
        pthread_mutex_unlock(&stru_5505C4);
        return -3;
      }
    }
    else
    {
      snprintf(v9, 0x800u, "Failed to open gpio %d direction for writing!\n", a1);
      sub_41DB8(0, v9, 0);
      pthread_mutex_unlock(&stru_5505C4);
      return -2;
    }
  }
}
// 5505C4: using guessed type pthread_mutex_t stru_5505C4;

//----- (0005B764) --------------------------------------------------------
int __fastcall sub_5B764(int a1, _BYTE *a2)
{
  char v6[2048]; // [sp+8h] [bp-84Ch] BYREF
  int buf; // [sp+808h] [bp-4Ch] BYREF
  char s[64]; // [sp+80Ch] [bp-48h] BYREF
  int fd; // [sp+84Ch] [bp-8h]

  buf = 0;
  if ( pthread_mutex_lock(&stru_5505C4) )
  {
    strcpy(v6, "failed to api lock\n");
    sub_41DB8(0, v6, 0);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    fd = open(s, 2048);
    if ( fd >= 0 )
    {
      if ( read(fd, &buf, 4u) >= 0 )
      {
        close(fd);
        pthread_mutex_unlock(&stru_5505C4);
        *a2 = atoi((const char *)&buf);
        return 0;
      }
      else
      {
        strcpy(v6, "Failed to read value!\n");
        sub_41DB8(0, v6, 0);
        close(fd);
        pthread_mutex_unlock(&stru_5505C4);
        return -3;
      }
    }
    else
    {
      snprintf(v6, 0x800u, "Failed to open gpio %d value for reading!\n", a1);
      sub_41DB8(0, v6, 0);
      pthread_mutex_unlock(&stru_5505C4);
      return -2;
    }
  }
}
// 5505C4: using guessed type pthread_mutex_t stru_5505C4;

//----- (0005B948) --------------------------------------------------------
int __fastcall sub_5B948(int a1, char a2)
{
  char v6[2048]; // [sp+Ch] [bp-848h] BYREF
  char s[64]; // [sp+80Ch] [bp-48h] BYREF
  int fd; // [sp+84Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_5505C4) )
  {
    strcpy(v6, "failed to api lock\n");
    sub_41DB8(0, v6, 0);
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    fd = open(s, 2049);
    if ( fd >= 0 )
    {
      if ( write(fd, &a01[a2 != 0], 1u) >= 0 )
      {
        close(fd);
        pthread_mutex_unlock(&stru_5505C4);
        return 0;
      }
      else
      {
        strcpy(v6, "Failed to write value!\n");
        sub_41DB8(0, v6, 0);
        close(fd);
        pthread_mutex_unlock(&stru_5505C4);
        return -3;
      }
    }
    else
    {
      strcpy(v6, "Failed to open gpio value for writing!\n");
      sub_41DB8(0, v6, 0);
      pthread_mutex_unlock(&stru_5505C4);
      return -2;
    }
  }
}
// 5505C4: using guessed type pthread_mutex_t stru_5505C4;

//----- (0005BB2C) --------------------------------------------------------
int __fastcall sub_5BB2C(unsigned int a1, int a2)
{
  char v4[2048]; // [sp+8h] [bp-804h] BYREF

  if ( dword_550478 )
  {
    if ( a1 <= 1 )
    {
      *((_DWORD *)&unk_5505F8 + 2 * a1) = a2;
      *((_BYTE *)&unk_5505F8 + 8 * a1 + 4) = 1;
      return a1 + 1;
    }
    else
    {
      strcpy(v4, "bad param\n");
      sub_41DB8(0, v4, 0);
      return -3;
    }
  }
  else
  {
    strcpy(v4, "please init platform first!!\n");
    sub_41DB8(0, v4, 0);
    return -2;
  }
}
// 550478: using guessed type int dword_550478;

//----- (0005BC3C) --------------------------------------------------------
int __fastcall sub_5BC3C(int result)
{
  char v1[2048]; // [sp+8h] [bp-804h] BYREF

  if ( result - 1 <= 1 )
  {
    *((_DWORD *)&unk_5505F8 + 2 * result - 2) = 0;
    *((_BYTE *)&unk_5505F8 + 8 * result - 4) = 0;
  }
  else
  {
    strcpy(v1, "bad param\n");
    return sub_41DB8(0, v1, 0);
  }
  return result;
}

//----- (0005BCE8) --------------------------------------------------------
int __fastcall sub_5BCE8(int a1, unsigned int a2)
{
  int v3; // r3
  int v5; // [sp+0h] [bp-80Ch]
  char v6[2048]; // [sp+8h] [bp-804h] BYREF

  if ( a1 - 1 <= 1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      if ( a2 >= 0x64 )
        v3 = 100;
      v5 = v3;
      sub_5A87C(19, (v3 << 16) | (100 - v3));
      sub_5A87C(23, (v5 << 16) | (100 - v5));
    }
    else
    {
      snprintf(v6, 0x800u, "pwm type %d not supported\n", a1 - 1);
      sub_41DB8(0, v6, 0);
    }
    return 0;
  }
  else
  {
    strcpy(v6, "bad param\n");
    sub_41DB8(0, v6, 0);
    return -3;
  }
}

//----- (0005BE0C) --------------------------------------------------------
int __fastcall sub_5BE0C(int a1, _DWORD *a2)
{
  char v5[2048]; // [sp+Ch] [bp-808h] BYREF
  int v6; // [sp+80Ch] [bp-8h]

  v6 = -5;
  if ( a1 - 1 <= 1 )
  {
    if ( a1 == 1 )
    {
      sub_5A800(19, a2);
      *a2 >>= 16;
      return 0;
    }
    return v6;
  }
  else
  {
    strcpy(v5, "bad param\n");
    sub_41DB8(0, v5, 0);
    return -3;
  }
}

//----- (0005BED8) --------------------------------------------------------
int __fastcall sub_5BED8(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  char v6[8]; // [sp+1Ch] [bp-808h] BYREF
  int v7; // [sp+81Ch] [bp-8h]

  v7 = 0;
  switch ( a1 )
  {
    case 0:
      *a2 = 24;
      *a3 = 65;
      *a4 = 69;
      *a5 = 70;
      break;
    case 1:
      *a2 = 16;
      *a3 = 65;
      *a4 = 71;
      *a5 = 72;
      break;
    case 2:
      *a2 = 8;
      *a3 = 65;
      *a4 = 73;
      *a5 = 74;
      break;
    case 3:
      *a2 = 0;
      *a3 = 65;
      *a4 = 75;
      *a5 = 76;
      break;
    case 4:
      *a2 = 24;
      *a3 = 66;
      *a4 = 77;
      *a5 = 78;
      break;
    case 5:
      *a2 = 16;
      *a3 = 66;
      *a4 = 79;
      *a5 = 80;
      break;
    case 6:
      *a2 = 8;
      *a3 = 66;
      *a4 = 81;
      *a5 = 82;
      break;
    case 7:
      *a2 = 0;
      *a3 = 66;
      *a4 = 83;
      *a5 = 84;
      break;
    case 8:
      *a2 = 24;
      *a3 = 67;
      *a4 = 85;
      *a5 = 86;
      break;
    case 9:
      *a2 = 16;
      *a3 = 67;
      *a4 = 87;
      *a5 = 88;
      break;
    case 10:
      *a2 = 8;
      *a3 = 67;
      *a4 = 116;
      *a5 = 117;
      break;
    case 11:
      *a2 = 0;
      *a3 = 67;
      *a4 = 118;
      *a5 = 119;
      break;
    case 12:
      *a2 = 24;
      *a3 = 68;
      *a4 = 120;
      *a5 = 121;
      break;
    case 13:
      *a2 = 16;
      *a3 = 68;
      *a4 = 122;
      *a5 = 123;
      break;
    default:
      snprintf(v6, 0x800u, "%s: The uart %d is not supported!!!\n", "get_send_address_info", a1);
      sub_41DB8(0, v6, 0);
      v7 = -1;
      break;
  }
  return v7;
}
// 5BF08: control flows out of bounds to 5BF0C

//----- (0005C280) --------------------------------------------------------
int __fastcall sub_5C280(int a1, _DWORD *a2, _DWORD *a3)
{
  char v4[8]; // [sp+1Ch] [bp-808h] BYREF
  int v5; // [sp+81Ch] [bp-8h]

  v5 = 0;
  switch ( a1 )
  {
    case 0:
      *a2 = 96;
      *a3 = 97;
      break;
    case 1:
      *a2 = 98;
      *a3 = 99;
      break;
    case 2:
      *a2 = 100;
      *a3 = 101;
      break;
    case 3:
      *a2 = 102;
      *a3 = 103;
      break;
    case 4:
      *a2 = 104;
      *a3 = 105;
      break;
    case 5:
      *a2 = 106;
      *a3 = 107;
      break;
    case 6:
      *a2 = 108;
      *a3 = 109;
      break;
    case 7:
      *a2 = 110;
      *a3 = 111;
      break;
    case 8:
      *a2 = 112;
      *a3 = 113;
      break;
    case 9:
      *a2 = 114;
      *a3 = 115;
      break;
    case 10:
      *a2 = 124;
      *a3 = 125;
      break;
    case 11:
      *a2 = 126;
      *a3 = 127;
      break;
    case 12:
      *a2 = 128;
      *a3 = 129;
      break;
    case 13:
      *a2 = 130;
      *a3 = 131;
      break;
    default:
      snprintf(v4, 0x800u, "%s: The uart%d is not supported!!!\n", "get_read_address_info", a1);
      sub_41DB8(0, v4, 0);
      v5 = -1;
      break;
  }
  return v5;
}
// 5C2AC: control flows out of bounds to 5C2B0

//----- (0005C4D4) --------------------------------------------------------
int __fastcall sub_5C4D4(unsigned __int8 a1)
{
  int v1; // r3
  char v3[8]; // [sp+14h] [bp-808h] BYREF
  int v4; // [sp+814h] [bp-8h] BYREF

  v4 = 0;
  switch ( a1 )
  {
    case 0u:
      sub_5A800(89, &v4);
      v1 = HIWORD(v4) & 0x3FF;
      break;
    case 1u:
      sub_5A800(89, &v4);
      v1 = v4 & 0x3FF;
      break;
    case 2u:
      sub_5A800(90, &v4);
      v1 = HIWORD(v4) & 0x3FF;
      break;
    case 3u:
      sub_5A800(90, &v4);
      v1 = v4 & 0x3FF;
      break;
    case 4u:
      sub_5A800(91, &v4);
      v1 = HIWORD(v4) & 0x3FF;
      break;
    case 5u:
      sub_5A800(91, &v4);
      v1 = v4 & 0x3FF;
      break;
    case 6u:
      sub_5A800(92, &v4);
      v1 = HIWORD(v4) & 0x3FF;
      break;
    case 7u:
      sub_5A800(92, &v4);
      v1 = v4 & 0x3FF;
      break;
    case 8u:
      sub_5A800(93, &v4);
      v1 = HIWORD(v4) & 0x3FF;
      break;
    case 9u:
      sub_5A800(93, &v4);
      v1 = v4 & 0x3FF;
      break;
    case 0xAu:
      sub_5A800(94, &v4);
      v1 = HIWORD(v4) & 0x3FF;
      break;
    case 0xBu:
      sub_5A800(94, &v4);
      v1 = v4 & 0x3FF;
      break;
    case 0xCu:
      sub_5A800(95, &v4);
      v1 = HIWORD(v4) & 0x3FF;
      break;
    case 0xDu:
      sub_5A800(95, &v4);
      v1 = v4 & 0x3FF;
      break;
    default:
      snprintf(v3, 0x800u, "%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      sub_41DB8(0, v3, 0);
      v1 = 0;
      break;
  }
  return v1;
}
// 5C500: control flows out of bounds to 5C504

//----- (0005C738) --------------------------------------------------------
int __fastcall sub_5C738(int a1, int a2, unsigned int a3)
{
  char v8[16]; // [sp+1Ch] [bp-820h] BYREF
  int v9; // [sp+81Ch] [bp-20h] BYREF
  int v10; // [sp+820h] [bp-1Ch] BYREF
  int v11; // [sp+824h] [bp-18h] BYREF
  unsigned int v12; // [sp+828h] [bp-14h]
  unsigned int v13; // [sp+82Ch] [bp-10h]
  int v14; // [sp+830h] [bp-Ch]
  unsigned int i; // [sp+834h] [bp-8h]

  v11 = 0;
  v10 = 0;
  v13 = 0;
  v12 = 0;
  i = 0;
  v9 = 0;
  v14 = 0;
  if ( sub_5C280(a1, &v11, &v10) )
  {
    snprintf(v8, 0x800u, "get_read_address_info error, chain_id = %d\n", a1);
    sub_41DB8(0, v8, 0);
    return 0;
  }
  else
  {
    v13 = a3 & 0x3FF | 0x80000000;
    sub_5A87C(v11, v13);
    v12 = a3 >> 2;
    for ( i = 0; i < v12; ++i )
    {
      sub_5A800(v10, &v9);
      *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
      *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v9);
      *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(v9);
      *(_BYTE *)(a2 + 4 * i + 3) = v9;
    }
    v14 = 4 * v12;
    v12 = a3 & 3;
    if ( (a3 & 3) != 0 )
    {
      sub_5A800(v10, &v9);
      switch ( v12 )
      {
        case 2u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
          *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v9);
          v14 += 2;
          break;
        case 3u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
          *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v9);
          *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(v9);
          v14 += 3;
          break;
        case 1u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v9);
          ++v14;
          break;
        default:
          snprintf(v8, 0x800u, "%s: the uart%d left data is 4*N length, error!!!\n", "read_uart_data_in_fpga", a1);
          sub_41DB8(0, v8, 0);
          break;
      }
    }
    return v14;
  }
}

//----- (0005CA90) --------------------------------------------------------
int sub_5CA90()
{
  char v2[2048]; // [sp+0h] [bp-804h] BYREF

  if ( dword_550478 )
    return 0;
  strcpy(v2, "please init platform first!!\n");
  sub_41DB8(0, v2, 0);
  return -1;
}
// 550478: using guessed type int dword_550478;

//----- (0005CB0C) --------------------------------------------------------
void sub_5CB0C()
{
  ;
}

//----- (0005CB24) --------------------------------------------------------
int __fastcall sub_5CB24(const char *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v4; // r3
  int v5; // [sp+4h] [bp-18h]
  unsigned int i; // [sp+10h] [bp-Ch]
  unsigned int j; // [sp+10h] [bp-Ch]
  unsigned __int8 *v8; // [sp+14h] [bp-8h]

  v5 = a3;
  v8 = a2;
  result = printf("Dumping %u %s bytes from %p:\n", a3, a1, a2);
  while ( v5 > 0 )
  {
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( i >= v5 )
        printf("   ");
      else
        printf("%02x ", v8[i]);
    }
    for ( j = 0; j <= 0xF; ++j )
    {
      if ( j >= v5 )
      {
        putchar(32);
      }
      else
      {
        if ( v8[j] <= 0x1Fu || v8[j] > 0x7Eu )
          v4 = 46;
        else
          v4 = v8[j];
        putchar(v4);
      }
    }
    result = putchar(10);
    v8 += 16;
    if ( v5 <= 16 )
      break;
    v5 -= 16;
  }
  return result;
}

//----- (0005CCA0) --------------------------------------------------------
size_t __fastcall sub_5CCA0(int a1, const void *a2, size_t a3)
{
  int v4; // r3
  char v9[12]; // [sp+18h] [bp-92Ch] BYREF
  int v10; // [sp+818h] [bp-12Ch] BYREF
  size_t v11; // [sp+81Ch] [bp-128h] BYREF
  int v12; // [sp+820h] [bp-124h] BYREF
  int v13; // [sp+824h] [bp-120h] BYREF
  int v14; // [sp+828h] [bp-11Ch] BYREF
  _BYTE s[256]; // [sp+82Ch] [bp-118h] BYREF
  size_t v16; // [sp+92Ch] [bp-18h]
  signed int v17; // [sp+930h] [bp-14h]
  int v18; // [sp+934h] [bp-10h]
  signed int i; // [sp+938h] [bp-Ch]
  int v20; // [sp+93Ch] [bp-8h]

  v20 = 0;
  v17 = 0;
  i = 0;
  memset(s, 0, sizeof(s));
  v16 = a3;
  v18 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  pthread_mutex_lock(&stru_550608[a1]);
  if ( sub_5BED8(a1, &v10, &v14, &v13, &v12) )
  {
    snprintf(v9, 0x800u, "get_send_address_info error, chain_id = %d\n", a1);
    sub_41DB8(0, v9, 0);
    pthread_mutex_unlock(&stru_550608[a1]);
    return 0;
  }
  else
  {
    v20 = 0;
    while ( 1 )
    {
      sub_5A800(v14, &v11);
      v11 = (unsigned __int8)(v11 >> v10);
      if ( a3 <= v11 )
        break;
      usleep(0xBB8u);
      if ( ++v20 > 20 )
      {
        pthread_mutex_unlock(&stru_550608[a1]);
        snprintf(v9, 0x800u, "%s: uart%d always dose not has enough send fifo space, break\n", "uart_send", a1);
        sub_41DB8(0, v9, 0);
        return 0;
      }
    }
    v20 = 0;
    while ( 1 )
    {
      sub_5A800(v13, &v11);
      if ( v11 >> 31 != 1 )
        break;
      usleep(0xBB8u);
      v4 = v20++;
      if ( v4 > 20 )
      {
        pthread_mutex_unlock(&stru_550608[a1]);
        snprintf(v9, 0x800u, "%s: uart%d always busy, break\n", "uart_send", a1);
        sub_41DB8(0, v9, 0);
        return 0;
      }
    }
    memcpy(s, a2, a3);
    v17 = v16 >> 2;
    for ( i = 0; i < v17; ++i )
    {
      v18 = ((unsigned __int8)s[4 * i] << 24)
          | ((unsigned __int8)s[4 * i + 1] << 16)
          | ((unsigned __int8)s[4 * i + 2] << 8)
          | (unsigned __int8)s[4 * i + 3];
      sub_5A87C(v12, v18);
    }
    v17 = v16 & 3;
    if ( (v16 & 3) != 0 )
    {
      switch ( v17 )
      {
        case 2:
          v18 = ((unsigned __int8)s[4 * i] << 24) | ((unsigned __int8)s[4 * i + 1] << 16);
          break;
        case 3:
          v18 = ((unsigned __int8)s[4 * i] << 24)
              | ((unsigned __int8)s[4 * i + 1] << 16)
              | ((unsigned __int8)s[4 * i + 2] << 8);
          break;
        case 1:
          v18 = (unsigned __int8)s[4 * i] << 24;
          break;
        default:
          printf("%s: the uart%d send left data is 4*N length, error!!!\n", "uart_send", a1);
          break;
      }
      sub_5A87C(v12, v18);
    }
    sub_5A87C(v13, v16 | 0x80000000);
    pthread_mutex_unlock(&stru_550608[a1]);
    return v16;
  }
}
// 550608: using guessed type pthread_mutex_t stru_550608[16];

//----- (0005D1BC) --------------------------------------------------------
int __fastcall sub_5D1BC(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // r0
  int v9; // [sp+18h] [bp-Ch]
  unsigned int v10; // [sp+1Ch] [bp-8h]

  pthread_mutex_lock(&stru_550788[a1]);
  v10 = sub_5C4D4(a1);
  if ( v10 > a3 )
    v10 = a3;
  if ( v10 )
  {
    v3 = sub_962A0(v10, 1u);
    v9 = sub_5C738(a1, a2, v3);
    sub_962A0(v10, 1u);
    pthread_mutex_unlock(&stru_550788[a1]);
    return v9;
  }
  else
  {
    pthread_mutex_unlock(&stru_550788[a1]);
    return 0;
  }
}
// 550788: using guessed type pthread_mutex_t stru_550788[16];

//----- (0005D2F8) --------------------------------------------------------
int __fastcall sub_5D2F8(int a1, int a2, int *a3)
{
  char v8[8]; // [sp+14h] [bp-808h] BYREF
  int v9; // [sp+814h] [bp-8h]

  v9 = -5;
  if ( !a3 )
    return -3;
  pthread_mutex_lock(&stru_550608[a1]);
  if ( a2 )
  {
    snprintf(v8, 0x800u, "unknown set config type = %d\n", a2);
    sub_41DB8(1, v8, 0);
  }
  else
  {
    sub_5A87C(15, *a3);
  }
  pthread_mutex_unlock(&stru_550608[a1]);
  return v9;
}
// 550608: using guessed type pthread_mutex_t stru_550608[16];

//----- (0005D3F8) --------------------------------------------------------
int __fastcall sub_5D3F8(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  char v10[12]; // [sp+10h] [bp-80Ch] BYREF
  int v11; // [sp+810h] [bp-Ch] BYREF
  int v12; // [sp+814h] [bp-8h]

  v12 = -5;
  if ( !a3 || !a4 )
    return -3;
  pthread_mutex_lock(&stru_550608[a1]);
  if ( a2 )
  {
    snprintf(v10, 0x800u, "unknown set config type = %d\n", a2);
    sub_41DB8(1, v10, 0);
  }
  else
  {
    v11 = 0;
    v12 = sub_5A800(15, &v11);
    *a3 = v11;
    *a4 = 4;
    snprintf(v10, 0x800u, "uart_get_config return %d\n", *a3);
    sub_41DB8(3, v10, 0);
  }
  pthread_mutex_unlock(&stru_550608[a1]);
  return v12;
}
// 550608: using guessed type pthread_mutex_t stru_550608[16];

//----- (0005D564) --------------------------------------------------------
int __fastcall sub_5D564(int a1, int a2, _DWORD *a3)
{
  char v8[8]; // [sp+14h] [bp-808h] BYREF
  int v9; // [sp+814h] [bp-8h]

  v9 = -5;
  if ( !a3 )
    return -3;
  pthread_mutex_lock(&stru_550608[a1]);
  if ( a2 )
  {
    snprintf(v8, 0x800u, "unknown set config type = %d\n", a2);
    sub_41DB8(1, v8, 0);
  }
  else
  {
    sub_5A87C(15, *a3 << 16);
  }
  pthread_mutex_unlock(&stru_550608[a1]);
  return v9;
}
// 550608: using guessed type pthread_mutex_t stru_550608[16];

//----- (0005D668) --------------------------------------------------------
int __fastcall sub_5D668(int a1, int a2, int *a3, int a4)
{
  char v9[12]; // [sp+10h] [bp-80Ch] BYREF
  int v10; // [sp+810h] [bp-Ch] BYREF
  int v11; // [sp+814h] [bp-8h]

  v11 = -5;
  if ( !a3 || a4 )
    return -3;
  pthread_mutex_lock(&stru_550608[a1]);
  if ( a2 )
  {
    snprintf(v9, 0x800u, "unknown set config type = %d\n", a2);
    sub_41DB8(1, v9, 0);
  }
  else
  {
    v10 = 0;
    v11 = sub_5A800(15, &v10);
    *a3 = BYTE2(v10) & 0x3F;
    MEMORY[0] = 4;
    snprintf(v9, 0x800u, "uart_get_config return %d\n", *a3);
    sub_41DB8(3, v9, 0);
  }
  pthread_mutex_unlock(&stru_550608[a1]);
  return v11;
}
// 550608: using guessed type pthread_mutex_t stru_550608[16];

//----- (0005D7DC) --------------------------------------------------------
int __fastcall sub_5D7DC(int a1)
{
  char v3[12]; // [sp+10h] [bp-81Ch] BYREF
  int v4; // [sp+810h] [bp-1Ch] BYREF
  unsigned int v5; // [sp+814h] [bp-18h] BYREF
  int v6; // [sp+818h] [bp-14h] BYREF
  int v7; // [sp+81Ch] [bp-10h] BYREF
  int v8; // [sp+820h] [bp-Ch] BYREF
  unsigned int i; // [sp+824h] [bp-8h]

  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  i = 0;
  pthread_mutex_lock(&stru_550608[a1]);
  if ( sub_5BED8(a1, &v4, &v8, &v7, &v6) )
  {
    snprintf(v3, 0x800u, "get_send_address_info error, chain_id = %d\n", a1);
    sub_41DB8(0, v3, 0);
    return pthread_mutex_unlock(&stru_550608[a1]);
  }
  else
  {
    for ( i = 0; i <= 0x14; ++i )
    {
      sub_5A800(v8, &v5);
      v5 = (unsigned __int8)(v5 >> v4);
      if ( v5 == 255 )
        return pthread_mutex_unlock(&stru_550608[a1]);
      printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_tx_fifo", a1);
      sub_5A87C(v7, v5 | 0x80000000);
      usleep(0xBB8u);
    }
    snprintf(v3, 0x800u, "%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_tx_fifo", a1);
    sub_41DB8(0, v3, 0);
    return pthread_mutex_unlock(&stru_550608[a1]);
  }
}
// 550608: using guessed type pthread_mutex_t stru_550608[16];

//----- (0005DA0C) --------------------------------------------------------
int __fastcall sub_5DA0C(int a1)
{
  char v3[16]; // [sp+1Ch] [bp-810h] BYREF
  void *ptr; // [sp+81Ch] [bp-10h]
  size_t size; // [sp+820h] [bp-Ch]
  int v6; // [sp+824h] [bp-8h]

  v6 = 0;
  ptr = 0;
  pthread_mutex_lock(&stru_550788[a1]);
  size = sub_5C4D4(a1);
  if ( !size )
    return pthread_mutex_unlock(&stru_550788[a1]);
  ptr = malloc(size);
  if ( ptr )
  {
    v6 = sub_5C738(a1, (int)ptr, size);
    if ( v6 == size )
    {
      free(ptr);
      usleep(0x2710u);
      return pthread_mutex_unlock(&stru_550788[a1]);
    }
    else
    {
      snprintf(
        v3,
        0x800u,
        "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
        "clear_uart_rx_fifo",
        a1,
        size,
        v6);
      sub_41DB8(0, v3, 0);
      free(ptr);
      ptr = 0;
      usleep(0x2710u);
      return pthread_mutex_unlock(&stru_550788[a1]);
    }
  }
  else
  {
    snprintf(v3, 0x800u, "%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
    sub_41DB8(0, v3, 0);
    ptr = 0;
    usleep(0x7A120u);
    return pthread_mutex_unlock(&stru_550788[a1]);
  }
}
// 550788: using guessed type pthread_mutex_t stru_550788[16];

//----- (0005DC5C) --------------------------------------------------------
int __fastcall sub_5DC5C(int a1)
{
  sub_5DA0C(a1);
  usleep(0x2710u);
  sub_5D7DC(a1);
  return 0;
}

//----- (0005DC98) --------------------------------------------------------
int __fastcall sub_5DC98(int a1)
{
  sub_5D7DC(a1);
  return 0;
}

//----- (0005DCC0) --------------------------------------------------------
int __fastcall sub_5DCC0(int a1)
{
  sub_5DA0C(a1);
  return 0;
}

//----- (0005DCE8) --------------------------------------------------------
int __fastcall sub_5DCE8(int a1)
{
  int v3; // [sp+Ch] [bp-8h]

  pthread_mutex_lock(&stru_550788[a1]);
  v3 = sub_5C4D4(a1);
  pthread_mutex_unlock(&stru_550788[a1]);
  return v3;
}
// 550788: using guessed type pthread_mutex_t stru_550788[16];

//----- (0005DD70) --------------------------------------------------------
int sub_5DD70()
{
  if ( !sub_5B034(907) )
  {
    sub_5B10C(907);
    sub_5B564(907, 1);
  }
  return sub_5B948(907, 0);
}

//----- (0005DDB8) --------------------------------------------------------
int sub_5DDB8()
{
  if ( !sub_5B034(907) )
  {
    sub_5B10C(907);
    sub_5B564(907, 1);
  }
  return sub_5B948(907, 1);
}

//----- (0005DE00) --------------------------------------------------------
int sub_5DE00()
{
  _DWORD v1[3]; // [sp+14h] [bp-20h] BYREF
  int v2; // [sp+20h] [bp-14h]
  void *ptr; // [sp+24h] [bp-10h]
  _DWORD *v4; // [sp+28h] [bp-Ch]
  int i; // [sp+2Ch] [bp-8h]

  prctl(15, &unk_A4950, 0, 0, 0);
  while ( dword_550928 )
  {
    if ( !pthread_mutex_lock(&stru_550908) )
    {
      v4 = sub_6027C(dword_550920);
      for ( i = ((int (__fastcall *)(_DWORD *))*v4)(v4); i; i = ((int (__fastcall *)(_DWORD *))*v4)(v4) )
      {
        ptr = (void *)((int (__fastcall *)(int))v4[2])(i);
        v2 = v4[5];
        if ( !*((_DWORD *)ptr + 1) )
        {
          sub_5B948(***(_DWORD ***)(v2 + 16), *((_DWORD *)ptr + 2));
          *((_DWORD *)ptr + 2) = *((_DWORD *)ptr + 2) != 1;
          *((_DWORD *)ptr + 1) = *(_DWORD *)ptr;
        }
        *((_DWORD *)ptr + 1) -= 200;
        *((_DWORD *)ptr + 1) = *((_DWORD *)ptr + 1);
        v1[0] = *(_DWORD *)ptr;
        v1[1] = *((_DWORD *)ptr + 1);
        v1[2] = *((_DWORD *)ptr + 2);
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v4[1])(v4, v1, 12);
        free(ptr);
      }
      sub_60300(v4);
      pthread_mutex_unlock(&stru_550908);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 550908: using guessed type pthread_mutex_t stru_550908;
// 550920: using guessed type int dword_550920;
// 550928: using guessed type int dword_550928;

//----- (0005DFE8) --------------------------------------------------------
int __fastcall sub_5DFE8(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0005E020) --------------------------------------------------------
int __fastcall sub_5E020(unsigned int a1)
{
  int v6; // [sp+Ch] [bp-8h]

  v6 = 0;
  if ( a1 == 2 )
  {
    if ( sub_5F84C() < 0 )
      return 0;
    else
      return sub_5F84C();
  }
  else if ( a1 > 2 )
  {
    if ( a1 == 256 )
    {
      if ( sub_5F88C() < 0 )
        return 0;
      else
        return sub_5F88C();
    }
    else if ( a1 == 257 )
    {
      if ( sub_5F8CC() < 0 )
        return 0;
      else
        return sub_5F8CC();
    }
  }
  else if ( a1 == 1 )
  {
    if ( sub_5F80C() < 0 )
      return 0;
    else
      return sub_5F80C();
  }
  return v6;
}

//----- (0005E120) --------------------------------------------------------
int __fastcall sub_5E120(int a1)
{
  char v3[8]; // [sp+Ch] [bp-808h] BYREF
  int v4; // [sp+80Ch] [bp-8h]

  v4 = 259;
  if ( a1 == sub_5F88C() )
    return 256;
  if ( a1 == sub_5F8CC() )
    return 257;
  snprintf(v3, 0x800u, "unmaped port = %d\n", a1);
  sub_41DB8(0, v3, 0);
  return v4;
}

//----- (0005E1CC) --------------------------------------------------------
int __fastcall sub_5E1CC(int a1, char a2)
{
  int result; // r0
  char v5[12]; // [sp+8h] [bp-80Ch] BYREF
  int v6; // [sp+808h] [bp-Ch]
  int i; // [sp+80Ch] [bp-8h]

  result = sub_5E120(a1);
  v6 = result;
  if ( result == 259 )
  {
    snprintf(v5, 0x800u, "gpio port %d is not a supported key\n", a1);
    return sub_41DB8(1, v5, 0);
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( dword_550930[i] )
        result = ((int (__fastcall *)(int, bool))dword_550930[i])(v6, a2 != 0);
    }
  }
  return result;
}
// 550930: using guessed type _DWORD dword_550930[5];

//----- (0005E2B4) --------------------------------------------------------
int sub_5E2B4()
{
  int v0; // r0
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0

  if ( !dword_550924 )
  {
    v0 = sub_5E020(1u);
    sub_5B10C(v0);
    v1 = sub_5E020(1u);
    sub_5B564(v1, 1);
    v2 = sub_5E020(2u);
    sub_5B10C(v2);
    v3 = sub_5E020(2u);
    sub_5B564(v3, 1);
    v4 = sub_5E020(0x100u);
    sub_5B10C(v4);
    v5 = sub_5E020(0x100u);
    sub_5B564(v5, 0);
    v6 = sub_5E020(0x101u);
    sub_5B10C(v6);
    v7 = sub_5E020(0x101u);
    sub_5B564(v7, 0);
    dword_550924 = 1;
  }
  return 0;
}
// 550924: using guessed type int dword_550924;

//----- (0005E3B4) --------------------------------------------------------
int sub_5E3B4()
{
  pthread_attr_t attr; // [sp+4h] [bp-30h] BYREF
  size_t stacksize; // [sp+28h] [bp-Ch]
  int i; // [sp+2Ch] [bp-8h]

  i = 0;
  if ( !dword_550928 )
  {
    pthread_mutex_init(&stru_550908, 0);
    for ( i = 0; i <= 4; ++i )
      dword_550930[i] = 0;
    dword_550920 = (int)sub_5FDE8((int)sub_5DFE8, 0, 0);
    pthread_attr_init(&attr);
    stacksize = 0x200000;
    pthread_attr_setstacksize(&attr, 0x200000u);
    pthread_create((pthread_t *)&dword_55092C, &attr, (void *(*)(void *))sub_5DE00, 0);
    dword_550928 = 1;
  }
  return 0;
}
// 550908: using guessed type pthread_mutex_t stru_550908;
// 550920: using guessed type int dword_550920;
// 550928: using guessed type int dword_550928;
// 55092C: using guessed type int dword_55092C;
// 550930: using guessed type _DWORD dword_550930[5];

//----- (0005E4B4) --------------------------------------------------------
void sub_5E4B4()
{
  ;
}

//----- (0005E4CC) --------------------------------------------------------
int sub_5E4CC()
{
  int result; // r0

  if ( dword_550928 )
  {
    dword_550928 = 0;
    pthread_join(dword_55092C, 0);
    sub_60084((void ***)dword_550920);
    return pthread_mutex_destroy(&stru_550908);
  }
  return result;
}
// 550908: using guessed type pthread_mutex_t stru_550908;
// 550920: using guessed type int dword_550920;
// 550928: using guessed type int dword_550928;
// 55092C: using guessed type int dword_55092C;

//----- (0005E538) --------------------------------------------------------
int __fastcall sub_5E538(int result, int *a2)
{
  _DWORD v3[2]; // [sp+4h] [bp-808h] BYREF

  v3[0] = result;
  if ( a2 )
  {
    result = sub_5FEC8(a2, (int)v3);
    if ( result == 1 )
      return sub_5FF34(a2, (int)v3);
  }
  return result;
}

//----- (0005E5B4) --------------------------------------------------------
int __fastcall sub_5E5B4(int result, int a2, int *a3)
{
  _DWORD v5[2]; // [sp+14h] [bp-818h] BYREF
  _DWORD v6[3]; // [sp+81Ch] [bp-10h] BYREF

  v5[0] = result;
  if ( a3 )
  {
    result = sub_5FEC8(a3, (int)v5);
    if ( !result )
    {
      v6[0] = a2;
      v6[1] = 0;
      v6[2] = 1;
      return sub_5FE68(a3, v5, 4u, v6, 0xCu);
    }
  }
  return result;
}

//----- (0005E65C) --------------------------------------------------------
void __fastcall sub_5E65C(int a1, int a2, int a3)
{
  _DWORD v5[3]; // [sp+814h] [bp-20h] BYREF
  void *ptr; // [sp+820h] [bp-14h]
  int v7; // [sp+824h] [bp-10h]
  _DWORD *v8; // [sp+828h] [bp-Ch]
  int i; // [sp+82Ch] [bp-8h]

  if ( a3 )
  {
    v8 = sub_6027C(a3);
    for ( i = ((int (__fastcall *)(_DWORD *))*v8)(v8); i; i = ((int (__fastcall *)(_DWORD *))*v8)(v8) )
    {
      v7 = v8[5];
      if ( a1 == ***(_DWORD ***)(v7 + 16) )
      {
        ptr = (void *)((int (__fastcall *)(int))v8[2])(i);
        v5[0] = a2;
        v5[1] = 0;
        v5[2] = 1;
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v8[1])(v8, v5, 12);
        free(ptr);
        break;
      }
    }
    sub_60300(v8);
  }
}

//----- (0005E758) --------------------------------------------------------
int __fastcall sub_5E758(unsigned int a1, int a2)
{
  char v5[2048]; // [sp+8h] [bp-80Ch] BYREF
  int v6; // [sp+808h] [bp-Ch]
  int v7; // [sp+80Ch] [bp-8h]

  v7 = -1;
  v6 = sub_5E020(a1);
  if ( v6 )
  {
    if ( pthread_mutex_lock(&stru_550908) )
    {
      strcpy(v5, "failed to api lock\n");
      sub_41DB8(0, v5, 0);
      return -1;
    }
    else
    {
      if ( a2 == 1 )
      {
        sub_5E538(v6, (int *)dword_550920);
        v7 = sub_5B948(v6, 0);
      }
      else if ( a2 )
      {
        if ( a2 == 2 )
        {
          sub_5E5B4(v6, 200, (int *)dword_550920);
        }
        else
        {
          strcpy(v5, "unsuported led status\n");
          sub_41DB8(0, v5, 0);
          v7 = -2;
        }
      }
      else
      {
        sub_5E538(v6, (int *)dword_550920);
        v7 = sub_5B948(v6, 1);
      }
      pthread_mutex_unlock(&stru_550908);
      return v7;
    }
  }
  else
  {
    strcpy(v5, "unsuported gpio port\n");
    sub_41DB8(0, v5, 0);
    return -1;
  }
}
// 550908: using guessed type pthread_mutex_t stru_550908;
// 550920: using guessed type int dword_550920;

//----- (0005E968) --------------------------------------------------------
int __fastcall sub_5E968(unsigned int a1, int a2)
{
  char v5[2048]; // [sp+Ch] [bp-808h] BYREF
  int v6; // [sp+80Ch] [bp-8h]

  v6 = sub_5E020(a1);
  if ( v6 )
  {
    if ( a2 == 200 )
    {
      strcpy(v5, "interval is same with default\n");
      sub_41DB8(1, v5, 0);
    }
    else
    {
      sub_5E65C(v6, a2, dword_550920);
    }
    return 0;
  }
  else
  {
    strcpy(v5, "unsuported led port\n");
    sub_41DB8(0, v5, 0);
    return -1;
  }
}
// 550920: using guessed type int dword_550920;

//----- (0005EA88) --------------------------------------------------------
int sub_5EA88()
{
  return sub_5E758(1u, 0);
}

//----- (0005EAA8) --------------------------------------------------------
int sub_5EAA8()
{
  return sub_5E758(1u, 1);
}

//----- (0005EAC8) --------------------------------------------------------
int sub_5EAC8()
{
  if ( !dword_550928 )
    sub_5E3B4();
  return sub_5E758(1u, 2);
}
// 550928: using guessed type int dword_550928;

//----- (0005EB00) --------------------------------------------------------
int sub_5EB00()
{
  return sub_5E758(2u, 0);
}

//----- (0005EB20) --------------------------------------------------------
int sub_5EB20()
{
  return sub_5E758(2u, 1);
}

//----- (0005EB40) --------------------------------------------------------
int sub_5EB40()
{
  if ( !dword_550928 )
    sub_5E3B4();
  return sub_5E758(2u, 2);
}
// 550928: using guessed type int dword_550928;

//----- (0005EB78) --------------------------------------------------------
int sub_5EB78()
{
  return sub_5E758(0x10u, 0);
}

//----- (0005EB98) --------------------------------------------------------
int sub_5EB98()
{
  return sub_5E758(0x10u, 1);
}

//----- (0005EBB8) --------------------------------------------------------
int sub_5EBB8()
{
  if ( !dword_550928 )
    sub_5E3B4();
  return sub_5E758(0x10u, 2);
}
// 550928: using guessed type int dword_550928;

//----- (0005EBF0) --------------------------------------------------------
int __fastcall sub_5EBF0(int a1)
{
  int v2; // r0
  int v3; // r0
  char v6[2048]; // [sp+8h] [bp-80Ch] BYREF
  int v7; // [sp+808h] [bp-Ch]
  int i; // [sp+80Ch] [bp-8h]

  i = 0;
  v7 = 0;
  if ( pthread_mutex_lock(&stru_550908) )
  {
    strcpy(v6, "failed to api lock\n");
    sub_41DB8(0, v6, 0);
    return -1;
  }
  else
  {
    if ( !dword_550944 )
    {
      v2 = sub_5E020(0x100u);
      sub_5AD20(v2, (int)sub_5E1CC);
      v3 = sub_5E020(0x101u);
      sub_5AD20(v3, (int)sub_5E1CC);
      dword_550944 = 1;
    }
    for ( i = 0; i <= 4; ++i )
    {
      if ( !dword_550930[i] )
      {
        dword_550930[i] = a1;
        break;
      }
    }
    if ( i > 4 )
    {
      v7 = -2;
      strcpy(v6, "no more listener available\n");
      sub_41DB8(0, v6, 0);
    }
    pthread_mutex_unlock(&stru_550908);
    return v7;
  }
}
// 550908: using guessed type pthread_mutex_t stru_550908;
// 550930: using guessed type _DWORD dword_550930[5];
// 550944: using guessed type int dword_550944;

//----- (0005EDA0) --------------------------------------------------------
int __fastcall sub_5EDA0(int a1)
{
  char v4[2048]; // [sp+Ch] [bp-808h] BYREF
  int i; // [sp+80Ch] [bp-8h]

  i = 0;
  if ( pthread_mutex_lock(&stru_550908) )
  {
    strcpy(v4, "failed to api lock\n");
    sub_41DB8(0, v4, 0);
    return -1;
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( a1 == dword_550930[i] )
      {
        dword_550930[i] = 0;
        break;
      }
    }
    if ( i > 4 )
    {
      strcpy(v4, "listener not registered before\n");
      sub_41DB8(1, v4, 0);
    }
    pthread_mutex_unlock(&stru_550908);
    return 0;
  }
}
// 550908: using guessed type pthread_mutex_t stru_550908;
// 550930: using guessed type _DWORD dword_550930[5];

//----- (0005EEE8) --------------------------------------------------------
int sub_5EEE8()
{
  int v1; // r0
  char v3[2051]; // [sp+0h] [bp-80Ch] BYREF
  char v4; // [sp+803h] [bp-9h] BYREF
  _BOOL4 v5; // [sp+804h] [bp-8h]

  v5 = 1;
  if ( pthread_mutex_lock(&stru_550908) )
  {
    strcpy(v3, "failed to api lock\n");
    sub_41DB8(0, v3, 0);
    return -1;
  }
  else
  {
    v1 = sub_5F88C();
    sub_5B764(v1, &v4);
    v5 = v4 != 0;
    pthread_mutex_unlock(&stru_550908);
    return v5;
  }
}
// 550908: using guessed type pthread_mutex_t stru_550908;

//----- (0005EFB8) --------------------------------------------------------
int sub_5EFB8()
{
  int v1; // r0
  char v3[2051]; // [sp+0h] [bp-80Ch] BYREF
  char v4; // [sp+803h] [bp-9h] BYREF
  _BOOL4 v5; // [sp+804h] [bp-8h]

  v5 = 1;
  if ( pthread_mutex_lock(&stru_550908) )
  {
    strcpy(v3, "failed to api lock\n");
    sub_41DB8(0, v3, 0);
    return -1;
  }
  else
  {
    v1 = sub_5F8CC();
    sub_5B764(v1, &v4);
    v5 = v4 != 0;
    pthread_mutex_unlock(&stru_550908);
    return v5;
  }
}
// 550908: using guessed type pthread_mutex_t stru_550908;

//----- (0005F088) --------------------------------------------------------
int __fastcall sub_5F088(unsigned __int8 a1, int a2, unsigned int a3)
{
  char v8[2048]; // [sp+14h] [bp-808h] BYREF
  int v9; // [sp+814h] [bp-8h]

  v9 = -1;
  if ( pthread_mutex_lock(&stru_550908) )
  {
    strcpy(v8, "failed to api lock\n");
    sub_41DB8(0, v8, 0);
    return -4;
  }
  else
  {
    if ( dword_BD324 < 0 )
    {
      dword_BD324 = sub_5F2AC(off_BD328);
      sub_5F5F8(dword_BD324);
    }
    if ( dword_BD324 <= 0 )
    {
      snprintf(v8, 0x800u, "failed to init %s\n", off_BD328);
      sub_41DB8(0, v8, 0);
      v9 = -1;
    }
    else
    {
      v9 = sub_5F3D0(dword_BD324, a1, a2, a3);
    }
    pthread_mutex_unlock(&stru_550908);
    return v9;
  }
}
// BD324: using guessed type int dword_BD324;
// BD328: using guessed type char *off_BD328;
// 550908: using guessed type pthread_mutex_t stru_550908;

//----- (0005F204) --------------------------------------------------------
int sub_5F204()
{
  char v1[2048]; // [sp+0h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_550908) )
  {
    strcpy(v1, "failed to api lock\n");
    return sub_41DB8(0, v1, 0);
  }
  else
  {
    if ( dword_BD324 > 0 )
      sub_5F5F8(dword_BD324);
    return pthread_mutex_unlock(&stru_550908);
  }
}
// BD324: using guessed type int dword_BD324;
// 550908: using guessed type pthread_mutex_t stru_550908;

//----- (0005F2AC) --------------------------------------------------------
int __fastcall sub_5F2AC(const char *a1)
{
  char v3[2048]; // [sp+8h] [bp-804h] BYREF

  if ( dword_55094C )
    return 0;
  if ( a1 )
  {
    dword_550948 = open(a1, 2050);
    if ( dword_550948 >= 0 )
    {
      dword_55094C = 1;
      return dword_550948;
    }
    else
    {
      strcpy(v3, "open lcd failed!!!\n");
      sub_41DB8(0, v3, 0);
      return -1;
    }
  }
  else
  {
    strcpy(v3, "bad param\n");
    sub_41DB8(0, v3, 0);
    return -3;
  }
}
// 550948: using guessed type int dword_550948;
// 55094C: using guessed type int dword_55094C;

//----- (0005F3D0) --------------------------------------------------------
int __fastcall sub_5F3D0(int a1, unsigned __int8 a2, int a3, unsigned int a4)
{
  size_t v5; // r3
  int v6; // r2
  unsigned int v8; // [sp+0h] [bp-81Ch]
  unsigned __int8 v10; // [sp+Bh] [bp-811h]
  char v11[2048]; // [sp+10h] [bp-80Ch] BYREF
  size_t n; // [sp+810h] [bp-Ch]
  int v13; // [sp+814h] [bp-8h]

  v8 = a4;
  v10 = a2;
  v13 = 0;
  if ( !dword_55094C )
    return -2;
  if ( a1 == dword_550948 && a2 <= 3u && a4 <= 0x40 )
  {
    if ( pthread_mutex_lock(&stru_550950) )
    {
      strcpy(v11, "failed to lcd lock\n");
      sub_41DB8(0, v11, 0);
      return -4;
    }
    else
    {
      do
      {
        v5 = v8;
        if ( v8 >= 0x10 )
          v5 = 16;
        n = v5;
        v6 = (char)v10++;
        memcpy((char *)&unk_550968 + 16 * v6, (const void *)(a3 + v13), v5);
        v13 += n;
        v8 -= n;
      }
      while ( v8 && v10 <= 3u );
      write(dword_550948, &unk_550968, 0x40u);
      pthread_mutex_unlock(&stru_550950);
      return 0;
    }
  }
  else
  {
    strcpy(v11, "bad param\n");
    sub_41DB8(1, v11, 0);
    return -3;
  }
}
// 550948: using guessed type int dword_550948;
// 55094C: using guessed type int dword_55094C;
// 550950: using guessed type pthread_mutex_t stru_550950;

//----- (0005F5D4) --------------------------------------------------------
int sub_5F5D4()
{
  return 0;
}

//----- (0005F5F8) --------------------------------------------------------
int __fastcall sub_5F5F8(int a1)
{
  char v3[2048]; // [sp+8h] [bp-804h] BYREF

  if ( !dword_55094C )
    return -2;
  if ( a1 == dword_550948 )
  {
    if ( pthread_mutex_lock(&stru_550950) )
    {
      strcpy(v3, "failed to lcd lock\n");
      sub_41DB8(0, v3, 0);
      return -4;
    }
    else
    {
      memset(&unk_550968, 32, 0x40u);
      lseek(dword_550948, 0, 0);
      write(dword_550948, &unk_550968, 0x40u);
      pthread_mutex_unlock(&stru_550950);
      return 0;
    }
  }
  else
  {
    strcpy(v3, "bad param\n");
    sub_41DB8(1, v3, 0);
    return -3;
  }
}
// 550948: using guessed type int dword_550948;
// 55094C: using guessed type int dword_55094C;
// 550950: using guessed type pthread_mutex_t stru_550950;

//----- (0005F754) --------------------------------------------------------
int __fastcall sub_5F754(int a1)
{
  char v2[2048]; // [sp+Ch] [bp-808h] BYREF
  int v3; // [sp+80Ch] [bp-8h]

  v3 = 0;
  if ( dword_55094C )
  {
    if ( close(a1) )
    {
      strcpy(v2, "lcd close failed!!!\n");
      sub_41DB8(0, v2, 0);
      v3 = -1;
    }
    dword_55094C = 0;
  }
  return v3;
}
// 55094C: using guessed type int dword_55094C;

//----- (0005F80C) --------------------------------------------------------
int sub_5F80C()
{
  if ( dword_BD474 )
    return dword_BD5C0;
  else
    return -1;
}
// BD474: using guessed type int dword_BD474;
// BD5C0: using guessed type int dword_BD5C0;

//----- (0005F84C) --------------------------------------------------------
int sub_5F84C()
{
  if ( dword_BD474 )
    return dword_BD5C4;
  else
    return -1;
}
// BD474: using guessed type int dword_BD474;
// BD5C4: using guessed type int dword_BD5C4;

//----- (0005F88C) --------------------------------------------------------
int sub_5F88C()
{
  if ( dword_BD474 )
    return dword_BD5C8;
  else
    return -1;
}
// BD474: using guessed type int dword_BD474;
// BD5C8: using guessed type int dword_BD5C8;

//----- (0005F8CC) --------------------------------------------------------
int sub_5F8CC()
{
  if ( dword_BD474 )
    return dword_BD5CC;
  else
    return -1;
}
// BD474: using guessed type int dword_BD474;
// BD5CC: using guessed type int dword_BD5CC;

//----- (0005F90C) --------------------------------------------------------
int __fastcall sub_5F90C(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_BD474 )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( a1 == dword_BD478[4 * i] )
      return dword_BD478[4 * i + 1];
  }
  return -2;
}
// BD474: using guessed type int dword_BD474;
// BD478: using guessed type _DWORD dword_BD478[64];

//----- (0005F9A8) --------------------------------------------------------
int __fastcall sub_5F9A8(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_BD474 )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( a1 == dword_BD478[4 * i] )
      return dword_BD478[4 * i + 2];
  }
  return -2;
}
// BD474: using guessed type int dword_BD474;
// BD478: using guessed type _DWORD dword_BD478[64];

//----- (0005FA44) --------------------------------------------------------
int __fastcall sub_5FA44(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_BD474 )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( a1 == dword_BD478[4 * i] )
      return dword_BD478[4 * i + 3];
  }
  return -2;
}
// BD474: using guessed type int dword_BD474;
// BD478: using guessed type _DWORD dword_BD478[64];

//----- (0005FAE0) --------------------------------------------------------
int sub_5FAE0()
{
  int i; // [sp+4h] [bp-8h]

  if ( !dword_BD474 )
    return -1;
  for ( i = 0;
        i <= 15
     && (dword_BD478[4 * i] != 255
      || dword_BD478[4 * i + 1] != 255
      || dword_BD478[4 * i + 2] != 255
      || dword_BD478[4 * i + 3] != 255);
        ++i )
  {
    ;
  }
  return i;
}
// BD474: using guessed type int dword_BD474;
// BD478: using guessed type _DWORD dword_BD478[64];

//----- (0005FBC8) --------------------------------------------------------
int __fastcall sub_5FBC8(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_BD474 )
    return -1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( a1 == dword_BD578[3 * i] )
      return dword_BD578[3 * i + 1];
  }
  return -2;
}
// BD474: using guessed type int dword_BD474;
// BD578: using guessed type _DWORD dword_BD578[18];

//----- (0005FC88) --------------------------------------------------------
int __fastcall sub_5FC88(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !dword_BD474 )
    return -1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( a1 == dword_BD578[3 * i] )
      return dword_BD578[3 * i + 2];
  }
  return -1;
}
// BD474: using guessed type int dword_BD474;
// BD578: using guessed type _DWORD dword_BD578[18];

//----- (0005FD48) --------------------------------------------------------
int sub_5FD48()
{
  int i; // [sp+0h] [bp-Ch]
  int v3; // [sp+4h] [bp-8h]

  v3 = 0;
  if ( !dword_BD474 )
    return -1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( dword_BD578[3 * i] != -1 )
      ++v3;
  }
  return v3;
}
// BD474: using guessed type int dword_BD474;
// BD578: using guessed type _DWORD dword_BD578[18];

//----- (0005FDE8) --------------------------------------------------------
_DWORD *__fastcall sub_5FDE8(int a1, int a2, int a3)
{
  _DWORD *v8; // [sp+14h] [bp-8h]

  v8 = malloc(4u);
  if ( !v8 )
    return 0;
  *v8 = sub_6054C(a1, a2, a3);
  if ( *v8 )
    return v8;
  else
    return 0;
}

//----- (0005FE68) --------------------------------------------------------
int __fastcall sub_5FE68(int *a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  if ( a1 )
    return sub_60920(*a1, a2, a3, a4, a5);
  else
    return 501;
}

//----- (0005FEC8) --------------------------------------------------------
bool __fastcall sub_5FEC8(int *a1, int a2)
{
  return a1 && sub_6083C(*a1, a2) != 0;
}

//----- (0005FF34) --------------------------------------------------------
int __fastcall sub_5FF34(int *a1, int a2)
{
  void *ptr; // [sp+Ch] [bp-10h] BYREF
  void *v5; // [sp+10h] [bp-Ch]
  int v6; // [sp+14h] [bp-8h]

  v6 = 0;
  if ( !a1 )
    return 501;
  v5 = sub_6105C(*a1, a2);
  if ( v5 )
  {
    sub_61A54(*((_DWORD *)v5 + 4), &ptr);
    free(ptr);
    sub_61B34(*((void ***)v5 + 4));
    sub_61A54(*((_DWORD *)v5 + 5), &ptr);
    free(ptr);
    sub_61B34(*((void ***)v5 + 5));
    free(v5);
  }
  return v6;
}

//----- (00060008) --------------------------------------------------------
int __fastcall sub_60008(int *a1, int a2, void **a3)
{
  _DWORD *v6; // [sp+14h] [bp-8h]

  if ( !a1 )
    return 0;
  v6 = sub_6083C(*a1, a2);
  if ( !v6 )
    return 0;
  sub_61A54(v6[5], a3);
  return 1;
}

//----- (00060084) --------------------------------------------------------
int __fastcall sub_60084(void ***a1)
{
  int v3; // [sp+Ch] [bp-8h]

  v3 = 0;
  if ( a1 )
  {
    v3 = sub_6121C(*a1);
    free(a1);
  }
  return v3;
}

//----- (000600D4) --------------------------------------------------------
_DWORD *__fastcall sub_600D4(int *a1)
{
  return sub_61374(*a1, *(_DWORD **)*a1);
}

//----- (00060114) --------------------------------------------------------
int __fastcall sub_60114(int a1)
{
  int *v1; // r0

  if ( *(_DWORD *)(a1 + 20) )
    v1 = sub_61458(**(int ***)(a1 + 12), *(_DWORD *)(a1 + 20));
  else
    v1 = sub_600D4(*(int **)(a1 + 12));
  *(_DWORD *)(a1 + 20) = v1;
  if ( *(_DWORD *)(a1 + 20) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 20) + 20);
  else
    return 0;
}

//----- (000601B8) --------------------------------------------------------
void *__fastcall sub_601B8(int a1)
{
  void *v2; // [sp+Ch] [bp-8h] BYREF

  sub_61A54(a1, &v2);
  return v2;
}

//----- (000601E8) --------------------------------------------------------
void *__fastcall sub_601E8(int a1, const void *a2, size_t a3)
{
  void *v7; // [sp+10h] [bp-Ch] BYREF
  int v8; // [sp+14h] [bp-8h]

  v8 = *(_DWORD *)(a1 + 12);
  if ( *(_DWORD *)(*(_DWORD *)v8 + 32) )
  {
    sub_61A54(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 20), &v7);
    (*(void (__fastcall **)(void *))(*(_DWORD *)v8 + 32))(v7);
  }
  return sub_61AD0(*(void ***)(*(_DWORD *)(a1 + 20) + 20), a2, a3);
}

//----- (0006027C) --------------------------------------------------------
_DWORD *__fastcall sub_6027C(int a1)
{
  _DWORD *result; // r0

  result = malloc(0x18u);
  *result = 393492;
  result[2] = 393656;
  result[1] = 393704;
  result[3] = a1;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (00060300) --------------------------------------------------------
void __fastcall sub_60300(void *a1)
{
  free(a1);
}

//----- (00060324) --------------------------------------------------------
_DWORD *__fastcall sub_60324(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // [sp+Ch] [bp-8h]

  v2 = (_DWORD *)a2[1];
  a2[1] = *v2;
  if ( (_DWORD *)*v2 != result + 1 )
    *(_DWORD *)(*v2 + 8) = a2;
  if ( v2 != result + 1 )
    v2[2] = a2[2];
  if ( a2[2] )
  {
    if ( a2 == *(_DWORD **)a2[2] )
      *(_DWORD *)a2[2] = v2;
    else
      *(_DWORD *)(a2[2] + 4) = v2;
  }
  else
  {
    *result = v2;
  }
  *v2 = a2;
  if ( a2 != result + 1 )
    a2[2] = v2;
  return result;
}

//----- (00060438) --------------------------------------------------------
_DWORD *__fastcall sub_60438(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // [sp+Ch] [bp-8h]

  v2 = (_DWORD *)*a2;
  *a2 = *(_DWORD *)(*a2 + 4);
  if ( (_DWORD *)v2[1] != result + 1 )
    *(_DWORD *)(v2[1] + 8) = a2;
  if ( v2 != result + 1 )
    v2[2] = a2[2];
  if ( a2[2] )
  {
    if ( a2 == *(_DWORD **)(a2[2] + 4) )
      *(_DWORD *)(a2[2] + 4) = v2;
    else
      *(_DWORD *)a2[2] = v2;
  }
  else
  {
    *result = v2;
  }
  v2[1] = a2;
  if ( a2 != result + 1 )
    a2[2] = v2;
  return result;
}

//----- (0006054C) --------------------------------------------------------
_DWORD *__fastcall sub_6054C(int a1, int a2, int a3)
{
  _DWORD *s; // [sp+14h] [bp-8h]

  s = malloc(0x28u);
  if ( !s )
    return 0;
  memset(s, 0, 0x28u);
  s[9] = a1;
  s[7] = a2;
  s[8] = a3;
  *s = s + 1;
  s[1] = s + 1;
  s[2] = s + 1;
  s[3] = 0;
  s[4] = 0;
  return s;
}

//----- (00060614) --------------------------------------------------------
_DWORD *__fastcall sub_60614(_DWORD *result, _DWORD *a2)
{
  _DWORD *v3; // [sp+4h] [bp-10h]
  int v4; // [sp+8h] [bp-Ch]
  int v5; // [sp+Ch] [bp-8h]

  v3 = result;
  while ( a2 != (_DWORD *)*v3 && *(_DWORD *)(a2[2] + 12) == 1 )
  {
    if ( a2[2] == **(_DWORD **)(a2[2] + 8) )
    {
      v4 = *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 4);
      if ( *(_DWORD *)(v4 + 12) == 1 )
      {
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(v4 + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        a2 = *(_DWORD **)(a2[2] + 8);
      }
      else
      {
        if ( a2 == *(_DWORD **)(a2[2] + 4) )
        {
          a2 = (_DWORD *)a2[2];
          sub_60324(v3, a2);
        }
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        result = sub_60438(v3, *(_DWORD **)(a2[2] + 8));
      }
    }
    else
    {
      v5 = **(_DWORD **)(a2[2] + 8);
      if ( *(_DWORD *)(v5 + 12) == 1 )
      {
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(v5 + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        a2 = *(_DWORD **)(a2[2] + 8);
      }
      else
      {
        if ( a2 == *(_DWORD **)a2[2] )
        {
          a2 = (_DWORD *)a2[2];
          sub_60438(v3, a2);
        }
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        result = sub_60324(v3, *(_DWORD **)(a2[2] + 8));
      }
    }
  }
  *(_DWORD *)(*v3 + 12) = 0;
  return result;
}

//----- (0006083C) --------------------------------------------------------
_DWORD *__fastcall sub_6083C(int a1, int a2)
{
  _DWORD *v2; // r3
  void *ptr; // [sp+Ch] [bp-10h] BYREF
  int v8; // [sp+10h] [bp-Ch]
  _DWORD *i; // [sp+14h] [bp-8h]

  for ( i = *(_DWORD **)a1; i != (_DWORD *)(a1 + 4); i = v2 )
  {
    v8 = 0;
    sub_61A54(i[4], &ptr);
    v8 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v8 )
      break;
    if ( v8 >= 0 )
      v2 = (_DWORD *)i[1];
    else
      v2 = (_DWORD *)*i;
  }
  if ( i == (_DWORD *)(a1 + 4) )
    return 0;
  else
    return i;
}

//----- (00060920) --------------------------------------------------------
int __fastcall sub_60920(int a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  void *v11; // [sp+10h] [bp-2Ch] BYREF
  void *v12; // [sp+14h] [bp-28h] BYREF
  void *v13; // [sp+18h] [bp-24h] BYREF
  void *ptr; // [sp+1Ch] [bp-20h] BYREF
  int v15; // [sp+20h] [bp-1Ch]
  int v16; // [sp+24h] [bp-18h]
  _DWORD *v17; // [sp+28h] [bp-14h]
  int v18; // [sp+2Ch] [bp-10h]
  _DWORD *v19; // [sp+30h] [bp-Ch]
  _DWORD *v20; // [sp+34h] [bp-8h]

  v18 = 0;
  v17 = malloc(0x18u);
  if ( !v17 )
    return 2;
  *v17 = a1 + 4;
  v17[1] = a1 + 4;
  v17[3] = 1;
  v17[4] = sub_619B0(a2, a3);
  if ( a4 )
    v17[5] = sub_619B0(a4, a5);
  else
    v17[5] = 0;
  v20 = *(_DWORD **)a1;
  v19 = 0;
  while ( v20 != (_DWORD *)(a1 + 4) )
  {
    v15 = 0;
    sub_61A54(v20[4], &ptr);
    sub_61A54(v17[4], &v13);
    v15 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v13, ptr);
    free(ptr);
    free(v13);
    if ( !v15 )
      return 401;
    v19 = v20;
    if ( v15 >= 0 )
      v20 = (_DWORD *)v20[1];
    else
      v20 = (_DWORD *)*v20;
  }
  v17[2] = v19;
  if ( v19 )
  {
    v16 = 0;
    sub_61A54(v19[4], &v12);
    sub_61A54(v17[4], &v11);
    v16 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v11, v12);
    free(v12);
    free(v11);
    if ( v16 >= 0 )
      v19[1] = v17;
    else
      *v19 = v17;
  }
  else
  {
    *(_DWORD *)a1 = v17;
  }
  sub_60614((_DWORD *)a1, v17);
  sub_61530((int *)a1);
  return v18;
}

//----- (00060B9C) --------------------------------------------------------
int *__fastcall sub_60B9C(int *result, int a2)
{
  int *v3; // [sp+4h] [bp-10h]
  _DWORD *v4; // [sp+8h] [bp-Ch]
  _DWORD *v5; // [sp+Ch] [bp-8h]

  v3 = result;
  while ( a2 != *v3 && !*(_DWORD *)(a2 + 12) )
  {
    if ( a2 == **(_DWORD **)(a2 + 8) )
    {
      v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
      if ( v5[3] == 1 )
      {
        v5[3] = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 1;
        result = sub_60324(v3, *(_DWORD **)(a2 + 8));
        v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
      }
      if ( *(_DWORD *)(*v5 + 12) || *(_DWORD *)(v5[1] + 12) )
      {
        if ( !*(_DWORD *)(v5[1] + 12) )
        {
          *(_DWORD *)(*v5 + 12) = 0;
          v5[3] = 1;
          sub_60438(v3, v5);
          v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
        }
        v5[3] = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 0;
        *(_DWORD *)(v5[1] + 12) = 0;
        result = sub_60324(v3, *(_DWORD **)(a2 + 8));
        a2 = *v3;
      }
      else
      {
        v5[3] = 1;
        a2 = *(_DWORD *)(a2 + 8);
      }
    }
    else
    {
      v4 = **(_DWORD ***)(a2 + 8);
      if ( v4[3] == 1 )
      {
        v4[3] = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 1;
        result = sub_60438(v3, *(_DWORD **)(a2 + 8));
        v4 = **(_DWORD ***)(a2 + 8);
      }
      if ( *(_DWORD *)(v4[1] + 12) || *(_DWORD *)(*v4 + 12) )
      {
        if ( !*(_DWORD *)(*v4 + 12) )
        {
          *(_DWORD *)(v4[1] + 12) = 0;
          v4[3] = 1;
          sub_60324(v3, v4);
          v4 = **(_DWORD ***)(a2 + 8);
        }
        v4[3] = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 0;
        *(_DWORD *)(*v4 + 12) = 0;
        result = sub_60438(v3, *(_DWORD **)(a2 + 8));
        a2 = *v3;
      }
      else
      {
        v4[3] = 1;
        a2 = *(_DWORD *)(a2 + 8);
      }
    }
  }
  *(_DWORD *)(a2 + 12) = 0;
  return result;
}

//----- (00060E94) --------------------------------------------------------
int *__fastcall sub_60E94(int *a1, int *a2)
{
  int v4; // [sp+Ch] [bp-10h]
  int v5; // [sp+Ch] [bp-10h]
  int *i; // [sp+10h] [bp-Ch]
  int v7; // [sp+14h] [bp-8h]

  if ( (int *)*a2 == a1 + 1 || (int *)a2[1] == a1 + 1 )
  {
    i = a2;
  }
  else
  {
    for ( i = (int *)a2[1]; (int *)*i != a1 + 1; i = (int *)*i )
      ;
  }
  if ( (int *)*i == a1 + 1 )
    v7 = i[1];
  else
    v7 = *i;
  *(_DWORD *)(v7 + 8) = i[2];
  if ( i[2] )
  {
    if ( i == *(int **)i[2] )
      *(_DWORD *)i[2] = v7;
    else
      *(_DWORD *)(i[2] + 4) = v7;
  }
  else
  {
    *a1 = v7;
  }
  if ( i != a2 )
  {
    v4 = a2[4];
    a2[4] = i[4];
    i[4] = v4;
    v5 = a2[5];
    a2[5] = i[5];
    i[5] = v5;
  }
  if ( !i[3] )
    sub_60B9C(a1, v7);
  sub_61530(a1);
  return i;
}

//----- (0006105C) --------------------------------------------------------
int *__fastcall sub_6105C(int a1, int a2)
{
  int *v2; // r3
  void *ptr; // [sp+Ch] [bp-10h] BYREF
  int v8; // [sp+10h] [bp-Ch]
  int *i; // [sp+14h] [bp-8h]

  i = 0;
  for ( i = *(int **)a1; i != (int *)(a1 + 4); i = v2 )
  {
    v8 = 0;
    sub_61A54(i[4], &ptr);
    v8 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v8 )
      break;
    if ( v8 >= 0 )
      v2 = (int *)i[1];
    else
      v2 = (int *)*i;
  }
  if ( i == (int *)(a1 + 4) )
    return 0;
  else
    return sub_60E94((int *)a1, i);
}

//----- (00061154) --------------------------------------------------------
void __fastcall sub_61154(int a1, int a2)
{
  void *v4; // [sp+8h] [bp-Ch] BYREF
  void *v5; // [sp+Ch] [bp-8h] BYREF

  if ( *(_DWORD *)(a1 + 28) )
  {
    sub_61A54(*(_DWORD *)(a2 + 16), &v5);
    (*(void (__fastcall **)(void *))(a1 + 28))(v5);
  }
  sub_61B34(*(void ***)(a2 + 16));
  if ( *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a1 + 32) )
    {
      sub_61A54(*(_DWORD *)(a2 + 20), &v4);
      (*(void (__fastcall **)(void *))(a1 + 32))(v4);
    }
    sub_61B34(*(void ***)(a2 + 20));
  }
}

//----- (0006121C) --------------------------------------------------------
int __fastcall sub_6121C(void **a1)
{
  void **ptr; // [sp+Ch] [bp-8h]

  ptr = (void **)*a1;
  while ( ptr != a1 + 1 )
  {
    if ( *ptr == a1 + 1 )
    {
      if ( ptr[1] == a1 + 1 )
      {
        sub_61154((int)a1, (int)ptr);
        if ( ptr[2] )
        {
          ptr = (void **)ptr[2];
          if ( *ptr == a1 + 1 )
          {
            if ( ptr[1] != a1 + 1 )
            {
              free(ptr[1]);
              ptr[1] = a1 + 1;
            }
          }
          else
          {
            free(*ptr);
            *ptr = a1 + 1;
          }
        }
        else
        {
          free(ptr);
          ptr = a1 + 1;
        }
      }
      else
      {
        ptr = (void **)ptr[1];
      }
    }
    else
    {
      ptr = (void **)*ptr;
    }
  }
  free(a1);
  return 0;
}

//----- (00061374) --------------------------------------------------------
_DWORD *__fastcall sub_61374(int a1, _DWORD *a2)
{
  while ( *a2 != a1 + 4 )
    a2 = (_DWORD *)*a2;
  return a2;
}

//----- (000613C4) --------------------------------------------------------
int __fastcall sub_613C4(int a1, int a2)
{
  while ( *(_DWORD *)(a2 + 4) != a1 + 4 )
    a2 = *(_DWORD *)(a2 + 4);
  return a2;
}

//----- (00061414) --------------------------------------------------------
bool __fastcall sub_61414(_DWORD *a1)
{
  return *a1 != (_DWORD)(a1 + 1);
}

//----- (00061458) --------------------------------------------------------
int *__fastcall sub_61458(int *a1, int a2)
{
  int *v4; // [sp+0h] [bp-14h]
  int *i; // [sp+Ch] [bp-8h]

  v4 = (int *)a2;
  if ( *(int **)(a2 + 4) != a1 + 1 )
    return sub_61374((int)a1, *(_DWORD **)(a2 + 4));
  if ( a2 == sub_613C4((int)a1, *a1) )
    return 0;
  for ( i = (int *)v4[2]; i != a1 + 1 && v4 == (int *)i[1]; i = (int *)i[2] )
    v4 = i;
  return i;
}

//----- (00061530) --------------------------------------------------------
int __fastcall sub_61530(int *a1)
{
  sub_6159C((int)a1, (_DWORD *)*a1);
  sub_6164C((int)a1, *a1);
  sub_616EC((int)a1, (int *)*a1);
  return sub_61824((int)a1, (_DWORD *)*a1);
}

//----- (0006159C) --------------------------------------------------------
int __fastcall sub_6159C(int a1, _DWORD *a2)
{
  int result; // r0

  result = sub_616A4(a1, (int)a2);
  if ( result != 1 )
  {
    result = sub_616A4(a1, (int)a2);
    if ( result )
      _assert_fail(
        "debug_node_color(pTree,n) == clib_red || debug_node_color(pTree,n) == clib_black",
        "3rdparty/cstl/src/c_rb.c",
        0x1DFu,
        "debug_verify_property_1");
  }
  if ( a2 != (_DWORD *)(a1 + 4) )
  {
    sub_6159C(a1, *a2);
    return sub_6159C(a1, a2[1]);
  }
  return result;
}

//----- (0006164C) --------------------------------------------------------
int __fastcall sub_6164C(int a1, int a2)
{
  int result; // r0

  result = sub_616A4(a1, a2);
  if ( result )
    _assert_fail(
      "debug_node_color(pTree,root) == clib_black",
      "3rdparty/cstl/src/c_rb.c",
      0x1E6u,
      "debug_verify_property_2");
  return result;
}

//----- (000616A4) --------------------------------------------------------
int __fastcall sub_616A4(int a1, int a2)
{
  if ( a2 == a1 + 4 )
    return 0;
  else
    return *(_DWORD *)(a2 + 12);
}

//----- (000616EC) --------------------------------------------------------
int __fastcall sub_616EC(int a1, int *a2)
{
  int result; // r0

  result = sub_616A4(a1, (int)a2);
  if ( result == 1 )
  {
    if ( sub_616A4(a1, *a2) )
      _assert_fail(
        "debug_node_color(pTree,n->left) == clib_black",
        "3rdparty/cstl/src/c_rb.c",
        0x1EFu,
        "debug_verify_property_4");
    if ( sub_616A4(a1, a2[1]) )
      _assert_fail(
        "debug_node_color(pTree,n->right) == clib_black",
        "3rdparty/cstl/src/c_rb.c",
        0x1F0u,
        "debug_verify_property_4");
    result = sub_616A4(a1, a2[2]);
    if ( result )
      _assert_fail(
        "debug_node_color(pTree,n->parent) == clib_black",
        "3rdparty/cstl/src/c_rb.c",
        0x1F1u,
        "debug_verify_property_4");
  }
  if ( a2 != (int *)(a1 + 4) )
  {
    sub_616EC(a1, *a2);
    return sub_616EC(a1, a2[1]);
  }
  return result;
}

//----- (00061824) --------------------------------------------------------
int __fastcall sub_61824(int a1, _DWORD *a2)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  v3 = -1;
  return sub_61860(a1, a2, 0, &v3);
}

//----- (00061860) --------------------------------------------------------
int __fastcall sub_61860(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // r0

  result = sub_616A4(a1, (int)a2);
  if ( !result )
    ++a3;
  if ( a2 == (_DWORD *)(a1 + 4) )
  {
    if ( *a4 == -1 )
    {
      *a4 = a3;
    }
    else if ( a3 != *a4 )
    {
      _assert_fail(
        "black_count == *path_black_count",
        "3rdparty/cstl/src/c_rb.c",
        0x205u,
        "debug_verify_property_5_helper");
    }
  }
  else
  {
    sub_61860(a1, *a2, a3, a4);
    return sub_61860(a1, a2[1], a3, a4);
  }
  return result;
}

//----- (00061948) --------------------------------------------------------
void *__fastcall sub_61948(void *a1, const void *a2, size_t a3)
{
  return memcpy(a1, a2, a3);
}

//----- (0006197C) --------------------------------------------------------
void *__fastcall sub_6197C(void *a1, const void *a2, size_t a3)
{
  return memcpy(a1, a2, a3);
}

//----- (000619B0) --------------------------------------------------------
void **__fastcall sub_619B0(const void *a1, size_t a2)
{
  void **ptr; // [sp+Ch] [bp-8h]

  ptr = (void **)malloc(8u);
  if ( !ptr )
    return 0;
  ptr[1] = (void *)a2;
  *ptr = malloc(a2);
  if ( *ptr )
  {
    memcpy(*ptr, a1, a2);
    return ptr;
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (00061A54) --------------------------------------------------------
int __fastcall sub_61A54(int a1, void **a2)
{
  *a2 = malloc(*(_DWORD *)(a1 + 4));
  if ( !*a2 )
    return 3;
  memcpy(*a2, *(const void **)a1, *(_DWORD *)(a1 + 4));
  return 0;
}

//----- (00061AD0) --------------------------------------------------------
void *__fastcall sub_61AD0(void **a1, const void *a2, size_t a3)
{
  free(*a1);
  *a1 = malloc(a3);
  return memcpy(*a1, a2, a3);
}

//----- (00061B34) --------------------------------------------------------
void __fastcall sub_61B34(void **a1)
{
  if ( a1 )
  {
    free(*a1);
    free(a1);
  }
}

//----- (00061B74) --------------------------------------------------------
char *__fastcall sub_61B74(const char *a1)
{
  return strdup(a1);
}

//----- (00061B9C) --------------------------------------------------------
int __fastcall sub_61B9C(unsigned int a1)
{
  char v4[16]; // [sp+14h] [bp-810h] BYREF
  unsigned int v5; // [sp+814h] [bp-10h] BYREF
  __int16 v6; // [sp+818h] [bp-Ch]
  char v7; // [sp+81Ah] [bp-Ah]
  char v8; // [sp+81Bh] [bp-9h]
  int v9; // [sp+81Ch] [bp-8h]

  v9 = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_5509A8[2 * a1] && dword_5509A8[2 * a1 + 1] )
    {
      return dword_5509A8[2 * a1];
    }
    else
    {
      v5 = a1;
      v6 = 0;
      v7 = 10;
      v8 = a1;
      v9 = sub_73D18((int)&v5);
      if ( v9 >= 0 )
      {
        dword_5509A8[2 * a1] = v9;
        dword_5509A8[2 * a1 + 1] = 1;
      }
      return v9;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_open", a1);
    sub_41DB8(0, v4, 0);
    return -2147483391;
  }
}
// 5509A8: using guessed type _DWORD dword_5509A8[32];

//----- (00061CE8) --------------------------------------------------------
unsigned int __fastcall sub_61CE8(unsigned int result)
{
  unsigned int v1; // [sp+Ch] [bp-808h]
  char v2[4]; // [sp+10h] [bp-804h] BYREF

  v1 = result;
  if ( result <= 0xF )
  {
    if ( dword_5509A8[2 * result] || dword_5509A8[2 * result + 1] )
    {
      result = sub_73FC0(dword_5509A8[2 * result]);
      dword_5509A8[2 * v1] = 0;
      dword_5509A8[2 * v1 + 1] = 0;
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_close", result);
    return sub_41DB8(0, v2, 0);
  }
  return result;
}
// 5509A8: using guessed type _DWORD dword_5509A8[32];

//----- (00061DD8) --------------------------------------------------------
int __fastcall sub_61DD8(unsigned int a1, char a2, int a3, unsigned int a4)
{
  char v10[16]; // [sp+1Ch] [bp-810h] BYREF
  unsigned __int8 v11; // [sp+81Fh] [bp-Dh] BYREF
  int v12; // [sp+820h] [bp-Ch]
  unsigned int i; // [sp+824h] [bp-8h]

  v12 = 0;
  i = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_5509A8[2 * a1 + 1] || (v12 = sub_61B9C(a1), v12 >= 0) )
    {
      for ( i = 0; a4 > i; ++i )
      {
        v11 = i + a2;
        v12 = sub_7427C(dword_5509A8[2 * a1], &v11, 1, a3 + i, 1u, 1);
        if ( v12 != 1 )
        {
          snprintf(v10, 0x800u, "fail to write eeprom by iic, chain:%d, addr: %d", a1, v11);
          sub_41DB8(0, v10, 0);
          return -2147483392;
        }
      }
      sleep(1u);
      return 0;
    }
    else
    {
      snprintf(v10, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_write", a1);
      sub_41DB8(0, v10, 0);
      return v12;
    }
  }
  else
  {
    snprintf(v10, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_write", a1);
    sub_41DB8(0, v10, 0);
    return -2147483391;
  }
}
// 5509A8: using guessed type _DWORD dword_5509A8[32];

//----- (00061FEC) --------------------------------------------------------
int __fastcall sub_61FEC(unsigned int a1, char a2, int a3, unsigned int a4)
{
  char v10[16]; // [sp+1Ch] [bp-810h] BYREF
  unsigned __int8 v11; // [sp+81Fh] [bp-Dh] BYREF
  int v12; // [sp+820h] [bp-Ch]
  unsigned int i; // [sp+824h] [bp-8h]

  v12 = 0;
  i = 0;
  if ( a1 <= 0xF )
  {
    if ( dword_5509A8[2 * a1 + 1] || (v12 = sub_61B9C(a1), v12 >= 0) )
    {
      for ( i = 0; a4 > i; ++i )
      {
        v11 = i + a2;
        v12 = sub_741B4(dword_5509A8[2 * a1], &v11, 1, a3 + i, 1u, 1);
        if ( v12 != 1 )
        {
          snprintf(v10, 0x800u, "fail to read eeprom by iic, chain: %d, addr: %d\n", a1, v11);
          sub_41DB8(0, v10, 0);
          return -2147483392;
        }
      }
      usleep(0x7A120u);
      return 0;
    }
    else
    {
      snprintf(v10, 0x800u, "%s: auto exec eeprom_open, but chain %d open eeprom failed\n", "eeprom_read", a1);
      sub_41DB8(0, v10, 0);
      return v12;
    }
  }
  else
  {
    snprintf(v10, 0x800u, "%s: Bad eeprom param, input chain is %d\n", "eeprom_read", a1);
    sub_41DB8(0, v10, 0);
    return -2147483391;
  }
}
// 5509A8: using guessed type _DWORD dword_5509A8[32];

//----- (00062208) --------------------------------------------------------
int sub_62208()
{
  struct sysinfo info; // [sp+4h] [bp-48h] BYREF
  int v2; // [sp+44h] [bp-8h]

  v2 = sub_5A8F4();
  dword_550A5C = v2;
  dword_550A60 = v2 + 0x200000;
  dword_550A64 = v2 + 2162688;
  sysinfo(&info);
  if ( info.totalram <= 0x3B9ACA00 )
  {
    if ( info.totalram <= 0x1DCD6500 )
    {
      if ( info.totalram <= 0xBEBC200 )
        dword_550A58 = 117440512;
      else
        dword_550A58 = 251658240;
    }
    else
    {
      dword_550A58 = 520093696;
    }
  }
  else
  {
    dword_550A58 = 1056964608;
  }
  dword_550A68 = dword_550A60;
  sub_63354(dword_550A58);
  sub_632F0(dword_550A58 + 0x200000);
  sub_64628();
  sub_646C8();
  return 0;
}
// 550A58: using guessed type int dword_550A58;
// 550A5C: using guessed type int dword_550A5C;
// 550A60: using guessed type int dword_550A60;
// 550A64: using guessed type int dword_550A64;
// 550A68: using guessed type int dword_550A68;

//----- (00062344) --------------------------------------------------------
int sub_62344()
{
  return 0;
}

//----- (00062360) --------------------------------------------------------
int sub_62360()
{
  if ( dword_550A68 == dword_550A60 )
    return dword_550A64;
  else
    return dword_550A60;
}
// 550A60: using guessed type int dword_550A60;
// 550A64: using guessed type int dword_550A64;
// 550A68: using guessed type int dword_550A68;

//----- (000623B4) --------------------------------------------------------
int __fastcall sub_623B4(int a1)
{
  if ( a1 == dword_550A60 )
    return dword_550A58 + 0x200000;
  else
    return dword_550A58 + 2162688;
}
// 550A58: using guessed type int dword_550A58;
// 550A60: using guessed type int dword_550A60;

//----- (00062410) --------------------------------------------------------
int __fastcall sub_62410(int a1, int a2, int a3, int a4)
{
  if ( a1 )
    return sub_638DC(a2, 1, a4);
  else
    return sub_638DC(a2, a3, a4);
}

//----- (00062468) --------------------------------------------------------
int __fastcall sub_62468(int a1, unsigned int a2, int a3)
{
  int v3; // r0
  int v5; // [sp+10h] [bp-14h]
  int v6; // [sp+18h] [bp-Ch]
  int v7; // [sp+1Ch] [bp-8h]

  if ( a1 || a2 <= 1 )
    v7 = 256;
  else
    v7 = ((_WORD)a2 << 8) & 0x1F00;
  if ( a1 )
    v6 = 0x4000;
  else
    v6 = 0;
  if ( a3 )
  {
    sub_63ED8();
    v5 = 128;
  }
  else
  {
    v5 = 0;
  }
  v3 = sub_62EC4();
  return sub_62EF8(v3 & 0xFFFFE0BF | v7 | v6 | v5 | 0x8060);
}

//----- (00062550) --------------------------------------------------------
int sub_62550()
{
  int v0; // r0
  int result; // r0
  int v2; // r0
  unsigned int i; // [sp+4h] [bp-8h]

  v0 = sub_62EC4();
  result = sub_62EF8(v0 & 0xFFFFFFBF);
  for ( i = 0; i <= 9; ++i )
  {
    usleep(0x3E8u);
    result = sub_62EC4();
    if ( (result & 0x40) == 0 )
      break;
    v2 = sub_62EC4();
    result = sub_62EF8(v2 & 0xFFFFFFBF);
  }
  return result;
}

//----- (000625D8) --------------------------------------------------------
int __fastcall sub_625D8(int a1)
{
  int v2; // r0
  int s[8]; // [sp+14h] [bp-48h] BYREF
  size_t v6; // [sp+34h] [bp-28h]
  int v7; // [sp+38h] [bp-24h]
  void *dest; // [sp+3Ch] [bp-20h]
  int v9; // [sp+40h] [bp-1Ch]
  unsigned int m; // [sp+44h] [bp-18h]
  unsigned int k; // [sp+48h] [bp-14h]
  size_t j; // [sp+4Ch] [bp-10h]
  size_t i; // [sp+50h] [bp-Ch]
  size_t size; // [sp+54h] [bp-8h]

  memset(s, 0, sizeof(s));
  v9 = sub_62360();
  size = 0;
  if ( (*(_DWORD *)(a1 + 12) & 0x3Fu) <= 0x37 )
    size = (*(_DWORD *)(a1 + 12) & 0xFFFFFFC0) + 64;
  else
    size = (*(_DWORD *)(a1 + 12) & 0xFFFFFFC0) + 128;
  dest = malloc(size);
  if ( !dest )
    return -4;
  memset(dest, 0, size);
  memcpy(dest, *(const void **)(a1 + 8), *(_DWORD *)(a1 + 12));
  *((_BYTE *)dest + *(_DWORD *)(a1 + 12)) = 0x80;
  *(_DWORD *)((char *)dest + ((size - 4) & 0xFFFFFFFC)) = ((unsigned int)(8 * *(_DWORD *)(a1 + 12)) >> 24)
                                                        | ((unsigned int)(8 * *(_DWORD *)(a1 + 12)) >> 8) & 0xFF00
                                                        | (*(_DWORD *)(a1 + 12) << 11) & 0xFF0000
                                                        | (*(_DWORD *)(a1 + 12) << 27);
  *(_DWORD *)((char *)dest + ((size - 8) & 0xFFFFFFFC)) = 0;
  for ( i = 0; i < size; ++i )
    *(_BYTE *)(v9 + i) = *((_BYTE *)dest + i);
  for ( j = 0; j < size; ++j )
  {
    if ( *(unsigned __int8 *)(v9 + j) != *((unsigned __int8 *)dest + j) )
      printf(
        "%s: coinbase_padding_in_ddr[%d] = 0x%x, but *(coinbase_padding + %d) = 0x%x",
        "dhash_send_job",
        j,
        *(unsigned __int8 *)(v9 + j),
        j,
        *((unsigned __int8 *)dest + j));
  }
  for ( k = 0; k < *(_DWORD *)(a1 + 20); ++k )
    memcpy((void *)(v9 + 32 * k + size), (const void *)(*(_DWORD *)(a1 + 16) + 32 * k), 0x20u);
  sub_62550();
  v2 = sub_623B4(v9);
  sub_632F0(v2);
  sub_636FC(*(_DWORD *)(a1 + 32));
  sub_62410(*(_DWORD *)a1, *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 40));
  memset(s, 0, sizeof(s));
  for ( m = 0; m <= 7; ++m )
    s[m] = (*(unsigned __int8 *)(*(_DWORD *)(a1 + 44) + 4 * m + 3) << 24)
         | (*(unsigned __int8 *)(*(_DWORD *)(a1 + 44) + 4 * m + 2) << 16)
         | (*(unsigned __int8 *)(*(_DWORD *)(a1 + 44) + 4 * m + 1) << 8)
         | *(unsigned __int8 *)(*(_DWORD *)(a1 + 44) + 4 * m);
  sub_63C40((int)s);
  sub_63BA4(*(_DWORD *)(a1 + 24));
  sub_63C08(*(_DWORD *)(a1 + 28));
  v7 = (*(_DWORD *)(a1 + 52) << 16) | ((unsigned __int8)*(_DWORD *)(a1 + 56) << 8) | (unsigned __int8)(size >> 6);
  sub_63CA8(v7);
  *(_QWORD *)s = 0;
  *(_QWORD *)s = *(_QWORD *)(a1 + 64);
  sub_63DCC(s);
  sub_63E34(*(_DWORD *)(a1 + 20));
  v6 = size + 32 * *(_DWORD *)(a1 + 20);
  sub_63760((unsigned __int16)v6);
  usleep(0x3E8u);
  sub_633D4(*(_DWORD *)(a1 + 72));
  sub_62468(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 76));
  if ( dest )
    free(dest);
  dword_550A68 = v9;
  return 0;
}
// 550A68: using guessed type int dword_550A68;

//----- (00062AFC) --------------------------------------------------------
__int64 __fastcall sub_62AFC(int a1)
{
  __int64 v1; // r2

  HIDWORD(v1) = *(_DWORD *)(dword_550A5C + (a1 << 6) + 12);
  LODWORD(v1) = 0;
  return v1 | *(unsigned int *)(dword_550A5C + (a1 << 6) + 8);
}
// 550A5C: using guessed type int dword_550A5C;

//----- (00062B94) --------------------------------------------------------
int __fastcall sub_62B94(int a1)
{
  return *(_DWORD *)(dword_550A5C + (a1 << 6));
}
// 550A5C: using guessed type int dword_550A5C;

//----- (00062BD8) --------------------------------------------------------
int __fastcall sub_62BD8(int a1)
{
  return *(_DWORD *)(dword_550A5C + (a1 << 6) + 4);
}
// 550A5C: using guessed type int dword_550A5C;

//----- (00062C1C) --------------------------------------------------------
int __fastcall sub_62C1C(int a1, int a2, unsigned int a3)
{
  int v4; // [sp+10h] [bp-Ch]
  unsigned int i; // [sp+14h] [bp-8h]

  v4 = dword_550A5C + (a1 << 6);
  for ( i = 0; i < a3; ++i )
    *(_BYTE *)(a2 + i) = *(_BYTE *)(v4 + i + 32);
  return 0;
}
// 550A5C: using guessed type int dword_550A5C;

//----- (00062CB0) --------------------------------------------------------
unsigned int sub_62CB0()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(13, &v1);
  v1 = ~(~HIWORD(v1) << 16);
  sub_5A87C(13, v1);
  return sleep(2u);
}

//----- (00062D08) --------------------------------------------------------
unsigned int sub_62D08()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(13, &v1);
  v1 = HIWORD(v1) << 16;
  sub_5A87C(13, v1);
  return sleep(2u);
}

//----- (00062D60) --------------------------------------------------------
int __fastcall sub_62D60(char a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  v3 = 0;
  sub_5A800(13, &v3);
  return sub_5A87C(13, (1 << a1) | v3);
}

//----- (00062DC0) --------------------------------------------------------
int __fastcall sub_62DC0(char a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  v3 = 0;
  sub_5A800(13, &v3);
  return sub_5A87C(13, v3 & ~(1 << a1));
}

//----- (00062E24) --------------------------------------------------------
int sub_62E24()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(13, &v1);
  return sub_5A87C(13, ~(~HIWORD(v1) << 16));
}

//----- (00062E74) --------------------------------------------------------
int sub_62E74()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(13, &v1);
  return sub_5A87C(13, HIWORD(v1) << 16);
}

//----- (00062EC4) --------------------------------------------------------
int sub_62EC4()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(35, &v1);
  return v1;
}

//----- (00062EF8) --------------------------------------------------------
int __fastcall sub_62EF8(int a1)
{
  return sub_5A87C(35, a1);
}

//----- (00062F20) --------------------------------------------------------
int sub_62F20()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 | 0x40);
  return 0;
}

//----- (00062F48) --------------------------------------------------------
int sub_62F48()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 & 0xFFFFFFBF);
  return 0;
}

//----- (00062F70) --------------------------------------------------------
int sub_62F70()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 | 0x80);
  return 0;
}

//----- (00062F98) --------------------------------------------------------
int sub_62F98()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 & 0xFFFFFF7F);
  return 0;
}

//----- (00062FC0) --------------------------------------------------------
int __fastcall sub_62FC0(__int16 a1)
{
  int v1; // r0

  v1 = sub_62EC4();
  sub_62EF8(v1 & 0xFFFFE0FF | (a1 << 8) & 0x1F00);
  return 0;
}

//----- (00063004) --------------------------------------------------------
int sub_63004()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 | 0x8000);
  return 0;
}

//----- (0006302C) --------------------------------------------------------
int sub_6302C()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 & 0xFFFF7FFF);
  return 0;
}

//----- (00063054) --------------------------------------------------------
int sub_63054()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 | 0x20);
  return 0;
}

//----- (0006307C) --------------------------------------------------------
int sub_6307C()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 & 0xFFFFFFDF);
  return 0;
}

//----- (000630A4) --------------------------------------------------------
int sub_630A4()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 | 0x4000);
  return 0;
}

//----- (000630CC) --------------------------------------------------------
int sub_630CC()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 & 0xFFFFBFFF);
  return 0;
}

//----- (000630F4) --------------------------------------------------------
int sub_630F4()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 | 0x2000);
  return 0;
}

//----- (0006311C) --------------------------------------------------------
int sub_6311C()
{
  int v0; // r0

  v0 = sub_62EC4();
  sub_62EF8(v0 & 0xFFFFDFFF);
  return 0;
}

//----- (00063144) --------------------------------------------------------
int sub_63144()
{
  int v0; // r0
  int v2; // [sp+4h] [bp-8h] BYREF

  v2 = 0;
  sub_5A800(27, &v2);
  v2 &= ~0x400000u;
  sub_5A87C(27, v2);
  v0 = sub_62EC4();
  return sub_62EF8(v0 & 0xFFFFFFBF);
}

//----- (000631A4) --------------------------------------------------------
int sub_631A4()
{
  unsigned int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(13, &v1);
  sub_5A87C(13, ~(~HIWORD(v1) << 16));
  sleep(3u);
  sub_5A800(13, &v1);
  sub_5A87C(13, HIWORD(v1) << 16);
  sleep(1u);
  return sub_62550();
}

//----- (00063228) --------------------------------------------------------
int __fastcall sub_63228(char *a1, size_t a2)
{
  int v5; // [sp+10h] [bp-Ch] BYREF
  int v6; // [sp+14h] [bp-8h] BYREF

  v6 = 0;
  v5 = 0;
  sub_5A800(31, &v6);
  sub_5A800(32, &v5);
  return snprintf(a1, a2, "%08x%08x", v5, v6);
}

//----- (0006329C) --------------------------------------------------------
int __fastcall sub_6329C(int a1)
{
  return sub_5A87C(0, a1);
}

//----- (000632C4) --------------------------------------------------------
int sub_632C4()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(41, &v1);
  return v1;
}

//----- (000632F0) --------------------------------------------------------
int __fastcall sub_632F0(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(41, a1);
  return sub_5A800(41, &v2);
}

//----- (00063328) --------------------------------------------------------
int sub_63328()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(39, &v1);
  return v1;
}

//----- (00063354) --------------------------------------------------------
int __fastcall sub_63354(int a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  sub_5A800(39, &v3);
  sub_5A87C(39, a1);
  return sub_5A800(39, &v3);
}

//----- (0006339C) --------------------------------------------------------
int __fastcall sub_6339C(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(20, a1);
  return sub_5A800(20, &v2);
}

//----- (000633D4) --------------------------------------------------------
int __fastcall sub_633D4(unsigned int a1)
{
  int v2; // [sp+4h] [bp-8h]

  if ( a1 < 0x20000 )
    v2 = a1;
  else
    v2 = 0x1FFFF;
  return sub_6339C(v2 | 0x80000000);
}
// 63408: masking with 0x1FFFF was optimized away because r0.4 <= 0x1FFFF

//----- (00063428) --------------------------------------------------------
int sub_63428()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(22, &v1);
  return v1;
}

//----- (00063454) --------------------------------------------------------
int __fastcall sub_63454(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(22, a1);
  return sub_5A800(22, &v2);
}

//----- (0006348C) --------------------------------------------------------
int sub_6348C()
{
  return sub_5A87C(45, -1);
}

//----- (000634A8) --------------------------------------------------------
int sub_634A8()
{
  return sub_5A87C(33, 196608);
}

//----- (000634C4) --------------------------------------------------------
int sub_634C4()
{
  return sub_5A87C(33, 0x10000);
}

//----- (000634E0) --------------------------------------------------------
int sub_634E0()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(33, &v1);
  return (unsigned __int16)v1;
}

//----- (00063510) --------------------------------------------------------
int sub_63510()
{
  return sub_5A87C(33, 0);
}

//----- (0006352C) --------------------------------------------------------
int sub_6352C()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(6, &v1);
  return v1 & 0x7FFF;
}

//----- (0006355C) --------------------------------------------------------
int __fastcall sub_6355C(_DWORD *a1)
{
  int result; // r0
  int v3; // [sp+8h] [bp-Ch] BYREF
  int v4; // [sp+Ch] [bp-8h] BYREF

  sub_5A800(4, &v4);
  result = sub_5A800(5, &v3);
  *a1 = v4;
  a1[1] = v3;
  return result;
}

//----- (000635B4) --------------------------------------------------------
int __fastcall sub_635B4(_DWORD *a1)
{
  int result; // r0
  int v3; // [sp+8h] [bp-14h] BYREF
  int v4; // [sp+Ch] [bp-10h] BYREF
  int v5; // [sp+10h] [bp-Ch] BYREF
  int v6; // [sp+14h] [bp-8h] BYREF

  v6 = 0;
  v5 = 0;
  v4 = 0;
  v3 = 0;
  sub_5A800(4, &v6);
  sub_5A800(5, &v5);
  sub_5A800(4, &v4);
  result = sub_5A800(5, &v3);
  *a1 = v6;
  a1[1] = v5;
  a1[2] = v4;
  a1[3] = v3;
  return result;
}

//----- (0006366C) --------------------------------------------------------
int sub_6366C()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(21, &v1);
  return v1;
}

//----- (00063698) --------------------------------------------------------
int __fastcall sub_63698(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(21, a1);
  return sub_5A800(21, &v2);
}

//----- (000636D0) --------------------------------------------------------
int sub_636D0()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(44, &v1);
  return v1;
}

//----- (000636FC) --------------------------------------------------------
int __fastcall sub_636FC(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(44, a1);
  return sub_5A800(44, &v2);
}

//----- (00063734) --------------------------------------------------------
int sub_63734()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(42, &v1);
  return v1;
}

//----- (00063760) --------------------------------------------------------
int __fastcall sub_63760(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(42, a1);
  return sub_5A800(42, &v2);
}

//----- (00063798) --------------------------------------------------------
int sub_63798()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(3, &v1);
  return v1;
}

//----- (000637C4) --------------------------------------------------------
int __fastcall sub_637C4(char a1)
{
  return (unsigned __int8)(1 << a1) & (unsigned __int8)sub_63798();
}

//----- (00063804) --------------------------------------------------------
int sub_63804()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(46, &v1);
  return v1;
}

//----- (00063830) --------------------------------------------------------
int __fastcall sub_63830(int a1, int a2, int a3)
{
  unsigned int i; // [sp+10h] [bp-Ch]
  int v5; // [sp+14h] [bp-8h]

  v5 = 0;
  for ( i = 0; i <= 0x1F && v5 < a3; ++i )
  {
    if ( (a1 & (1 << i)) != 0 )
      *(_BYTE *)(a2 + v5++) = i;
  }
  return v5;
}

//----- (000638DC) --------------------------------------------------------
int __fastcall sub_638DC(int a1, int a2, int a3)
{
  _DWORD v6[3]; // [sp+14h] [bp-10h] BYREF

  v6[0] = 0;
  v6[1] = 0;
  v6[2] = sub_63830(a3, (int)v6, 8);
  if ( a2 == 4 )
  {
    sub_5A87C(46, a1);
    sub_5A87C(58, (1 << SLOBYTE(v6[0])) | a1);
    sub_5A87C(59, (1 << SBYTE1(v6[0])) | a1);
    return sub_5A87C(60, (1 << SLOBYTE(v6[0])) | a1 | (1 << SBYTE1(v6[0])));
  }
  else if ( a2 == 8 )
  {
    sub_5A87C(46, a1);
    sub_5A87C(58, (1 << SLOBYTE(v6[0])) | a1);
    sub_5A87C(59, (1 << SBYTE1(v6[0])) | a1);
    sub_5A87C(60, (1 << SBYTE2(v6[0])) | a1);
    sub_5A87C(61, (1 << SLOBYTE(v6[0])) | a1 | (1 << SBYTE1(v6[0])));
    sub_5A87C(62, (1 << SLOBYTE(v6[0])) | a1 | (1 << SBYTE2(v6[0])));
    sub_5A87C(63, (1 << SBYTE1(v6[0])) | a1 | (1 << SBYTE2(v6[0])));
    return sub_5A87C(64, (1 << SLOBYTE(v6[0])) | a1 | (1 << SBYTE1(v6[0])) | (1 << SBYTE2(v6[0])));
  }
  else
  {
    return sub_5A87C(46, a1);
  }
}

//----- (00063B78) --------------------------------------------------------
int sub_63B78()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(47, &v1);
  return v1;
}

//----- (00063BA4) --------------------------------------------------------
int __fastcall sub_63BA4(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(47, a1);
  return sub_5A800(47, &v2);
}

//----- (00063BDC) --------------------------------------------------------
int sub_63BDC()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(48, &v1);
  return v1;
}

//----- (00063C08) --------------------------------------------------------
int __fastcall sub_63C08(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(48, a1);
  return sub_5A800(48, &v2);
}

//----- (00063C40) --------------------------------------------------------
int __fastcall sub_63C40(int result)
{
  int v1; // [sp+4h] [bp-10h]
  int i; // [sp+Ch] [bp-8h]

  v1 = result;
  for ( i = 0; i <= 7; ++i )
    result = sub_5A87C(i + 49, *(_DWORD *)(v1 + 4 * i));
  return result;
}

//----- (00063CA8) --------------------------------------------------------
int __fastcall sub_63CA8(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(36, a1);
  return sub_5A800(36, &v2);
}

//----- (00063CE0) --------------------------------------------------------
int __fastcall sub_63CE0(unsigned __int16 a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  sub_5A800(36, &v3);
  sub_63CA8(v3 & 0xFFFFFF00 | a1);
  return 0;
}

//----- (00063D2C) --------------------------------------------------------
int __fastcall sub_63D2C(unsigned __int16 a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  sub_5A800(36, &v3);
  sub_63CA8(v3 & 0xFFFF00FF | (a1 << 8));
  return 0;
}

//----- (00063D7C) --------------------------------------------------------
int __fastcall sub_63D7C(unsigned __int16 a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  sub_5A800(36, &v3);
  sub_63CA8((unsigned __int16)v3 | (a1 << 16));
  return 0;
}

//----- (00063DCC) --------------------------------------------------------
int __fastcall sub_63DCC(int *a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(37, *a1);
  sub_5A87C(38, a1[1]);
  sub_5A800(37, &v3);
  return sub_5A800(38, &v3);
}

//----- (00063E34) --------------------------------------------------------
int __fastcall sub_63E34(unsigned __int16 a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(40, a1);
  return sub_5A800(40, &v2);
}

//----- (00063E74) --------------------------------------------------------
int sub_63E74()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(7, &v1);
  return v1;
}

//----- (00063EA0) --------------------------------------------------------
int __fastcall sub_63EA0(int a1)
{
  int v2; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(7, a1);
  return sub_5A800(7, &v2);
}

//----- (00063ED8) --------------------------------------------------------
int sub_63ED8()
{
  int v0; // r0

  v0 = sub_63E74();
  sub_63EA0(v0 | 0x10000);
  return 0;
}

//----- (00063F00) --------------------------------------------------------
int __fastcall sub_63F00(int *a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  sub_5A87C(28, *a1);
  sub_5A87C(29, a1[1]);
  sub_5A87C(30, a1[2]);
  sub_5A800(28, &v3);
  sub_5A800(29, &v3);
  return sub_5A800(30, &v3);
}

//----- (00063F90) --------------------------------------------------------
int sub_63F90()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(27, &v1);
  return v1;
}

//----- (00063FBC) --------------------------------------------------------
int __fastcall sub_63FBC(int a1)
{
  int result; // r0
  unsigned int v3; // [sp+Ch] [bp-8h]

  v3 = 0;
  sub_5A87C(27, a1);
  if ( a1 >= 0 )
    return sub_63F90();
  do
  {
    result = sub_63F90();
    if ( result >= 0 )
      break;
    result = usleep(0x3E8u);
    ++v3;
  }
  while ( v3 <= 0xBB8 );
  return result;
}

//----- (00064040) --------------------------------------------------------
int sub_64040()
{
  pthread_mutex_lock(&stru_550A40);
  sub_63F90();
  return pthread_mutex_unlock(&stru_550A40);
}
// 550A40: using guessed type pthread_mutex_t stru_550A40;

//----- (000640A8) --------------------------------------------------------
int __fastcall sub_640A8(char a1)
{
  unsigned int v3; // [sp+Ch] [bp-8h]

  pthread_mutex_lock(&stru_550A40);
  usleep(0xC350u);
  v3 = sub_63F90() & 0xFFFFFFC0 | a1 & 0x3F;
  sub_63FBC(v3);
  return pthread_mutex_unlock(&stru_550A40);
}
// 550A40: using guessed type pthread_mutex_t stru_550A40;

//----- (0006410C) --------------------------------------------------------
int __fastcall sub_6410C(int a1, char a2)
{
  unsigned int v5; // [sp+Ch] [bp-8h]
  int v6; // [sp+Ch] [bp-8h]

  pthread_mutex_lock(&stru_550A40);
  v5 = (a1 << 16) | sub_63F90() & 0xFFF0FFFF | 0x800000;
  if ( a2 )
    v6 = v5 | 0x400000;
  else
    v6 = v5 & 0xFFBFFFFF;
  sub_63FBC(v6);
  return pthread_mutex_unlock(&stru_550A40);
}
// 550A40: using guessed type pthread_mutex_t stru_550A40;

//----- (000641A0) --------------------------------------------------------
int __fastcall sub_641A0(int *a1, int a2)
{
  unsigned int v5; // [sp+Ch] [bp-8h]

  pthread_mutex_lock(&stru_550A40);
  sub_63F00(a1);
  v5 = (a2 << 16) | sub_63F90() & 0xFFF0FFFF | 0x80800000;
  sub_63FBC(v5);
  return pthread_mutex_unlock(&stru_550A40);
}
// 550A40: using guessed type pthread_mutex_t stru_550A40;

//----- (00064214) --------------------------------------------------------
int __fastcall sub_64214(int a1, unsigned int a2)
{
  int v2; // r0
  unsigned int i; // [sp+Ch] [bp-8h]

  pthread_mutex_lock(&stru_550A28);
  for ( i = 0; i < a2 >> 2; ++i )
  {
    if ( i )
      v2 = 17;
    else
      v2 = 16;
    sub_5A87C(v2, *(_DWORD *)(a1 + 4 * i));
  }
  return pthread_mutex_unlock(&stru_550A28);
}
// 550A28: using guessed type pthread_mutex_t stru_550A28;

//----- (000642AC) --------------------------------------------------------
int sub_642AC()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  sub_5A800(18, &v1);
  return v1;
}

//----- (000642D8) --------------------------------------------------------
int __fastcall sub_642D8(int a1)
{
  sub_5A87C(18, a1 | 0x80808000);
  dword_550A68 = dword_550A60;
  return sub_63354(dword_550A58);
}
// 550A58: using guessed type int dword_550A58;
// 550A60: using guessed type int dword_550A60;
// 550A68: using guessed type int dword_550A68;

//----- (00064340) --------------------------------------------------------
int sub_64340()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(15, &v1);
  return v1;
}

//----- (00064374) --------------------------------------------------------
int __fastcall sub_64374(int a1)
{
  return sub_5A87C(15, a1);
}

//----- (0006439C) --------------------------------------------------------
int __fastcall sub_6439C(char a1)
{
  sub_643D4(a1);
  usleep(0x186A0u);
  return sub_64434(a1);
}

//----- (000643D4) --------------------------------------------------------
int __fastcall sub_643D4(char a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  v3 = 0;
  sub_5A800(13, &v3);
  return sub_5A87C(13, (1 << a1) | v3);
}

//----- (00064434) --------------------------------------------------------
int __fastcall sub_64434(char a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  v3 = 0;
  sub_5A800(13, &v3);
  return sub_5A87C(13, v3 & ~(1 << a1));
}

//----- (00064498) --------------------------------------------------------
void sub_64498()
{
  sub_644D0();
  usleep(0x186A0u);
  sub_644F0();
}

//----- (000644D0) --------------------------------------------------------
void sub_644D0()
{
  ;
}

//----- (000644F0) --------------------------------------------------------
void sub_644F0()
{
  ;
}

//----- (00064510) --------------------------------------------------------
bool sub_64510()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(0, &v1);
  return v1 < 0;
}

//----- (00064558) --------------------------------------------------------
int __fastcall sub_64558(int a1)
{
  int v3; // [sp+Ch] [bp-8h] BYREF

  v3 = 0;
  sub_5A800(0, &v3);
  if ( a1 )
  {
    if ( a1 == 1 )
      v3 |= 0x80000000;
  }
  else
  {
    v3 &= ~0x80000000;
  }
  sub_5A87C(0, v3);
  return 0;
}

//----- (000645D8) --------------------------------------------------------
int sub_645D8()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(0, &v1);
  sub_5A87C(0, v1 | 0x20000000);
  return 0;
}

//----- (00064628) --------------------------------------------------------
int sub_64628()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(0, &v1);
  sub_5A87C(0, v1 & 0xDFFFFFFF);
  return 0;
}

//----- (00064678) --------------------------------------------------------
bool sub_64678()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(0, &v1);
  return (v1 & 0x20000000) != 0;
}

//----- (000646C8) --------------------------------------------------------
int sub_646C8()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(0, &v1);
  sub_5A87C(0, v1 | 0x40000000);
  return 0;
}

//----- (00064718) --------------------------------------------------------
int sub_64718()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(0, &v1);
  sub_5A87C(0, v1 & 0xBFFFFFFF);
  return 0;
}

//----- (00064768) --------------------------------------------------------
bool sub_64768()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(0, &v1);
  return (v1 & 0x40000000) != 0;
}

//----- (000647B8) --------------------------------------------------------
int sub_647B8()
{
  int v1; // [sp+4h] [bp-8h] BYREF

  v1 = 0;
  sub_5A800(0, &v1);
  return v1;
}

//----- (000647EC) --------------------------------------------------------
int __fastcall sub_647EC(void *a1)
{
  if ( a1 == &loc_1C200 )
    return 26;
  if ( a1 == &unk_F4240 )
    return 2;
  if ( (double)(int)a1 == 1500000.0 )
    return 1;
  if ( a1 == &unk_2DC6C0 )
    return 0;
  if ( a1 == &unk_5B8D80 )
    return 3;
  if ( a1 == (void *)12000000 )
    return 4;
  if ( a1 == (void *)25000000 )
    return 5;
  return (int)a1;
}

//----- (00064910) --------------------------------------------------------
int __fastcall sub_64910(int a1)
{
  switch ( a1 )
  {
    case 0:
      return (int)&unk_2DC6C0;
    case 1:
      return (int)&unk_16E360;
    case 3:
      return (int)&unk_5B8D80;
    case 4:
      return 12000000;
    case 5:
      return 25000000;
  }
  return 115200;
}

//----- (000649D8) --------------------------------------------------------
int __fastcall sub_649D8(int a1, void *a2)
{
  int v4; // [sp+8h] [bp-Ch]
  char v5; // [sp+Ch] [bp-8h]

  v5 = sub_647EC(a2);
  v4 = sub_64340();
  if ( !a1 )
    LOBYTE(v4) = v4 & 0xC0 | v5 & 0x3F;
  if ( a1 == 1 )
    BYTE1(v4) = BYTE1(v4) & 0xC0 | v5 & 0x3F;
  if ( a1 == 2 )
    BYTE2(v4) = BYTE2(v4) & 0xC0 | v5 & 0x3F;
  if ( a1 == 3 )
    HIBYTE(v4) = HIBYTE(v4) & 0xC0 | v5 & 0x3F;
  sub_64374(v4);
  return 0;
}

//----- (00064AB4) --------------------------------------------------------
int __fastcall sub_64AB4(int a1)
{
  int v4; // [sp+Ch] [bp-8h]

  v4 = sub_64340();
  switch ( a1 )
  {
    case 0:
      return sub_64910(v4 & 0x3F);
    case 1:
      return sub_64910(BYTE1(v4) & 0x3F);
    case 2:
      return sub_64910(BYTE2(v4) & 0x3F);
    case 3:
      return sub_64910(HIBYTE(v4) & 0x3F);
  }
  return -1;
}

//----- (00064B90) --------------------------------------------------------
int __fastcall sub_64B90(void *a1)
{
  int v1; // r0
  int v3; // [sp+8h] [bp-Ch]
  char v4; // [sp+Ch] [bp-8h]

  v4 = sub_647EC(a1);
  v1 = sub_64340();
  LOBYTE(v3) = v1 & 0xC0 | v4 & 0x3F;
  BYTE1(v3) = BYTE1(v1) & 0xC0 | v4 & 0x3F;
  BYTE2(v3) = BYTE2(v1) & 0xC0 | v4 & 0x3F;
  HIBYTE(v3) = HIBYTE(v1) & 0xC0 | v4 & 0x3F;
  sub_64374(v3);
  return 0;
}

//----- (00064C38) --------------------------------------------------------
int __fastcall sub_64C38(const char *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v4; // r3
  int v5; // [sp+Ch] [bp-818h]
  _DWORD v6[3]; // [sp+18h] [bp-80Ch] BYREF
  unsigned int i; // [sp+818h] [bp-Ch]
  unsigned __int8 *v8; // [sp+81Ch] [bp-8h]

  v5 = a3;
  v8 = a2;
  snprintf((char *)v6, 0x800u, "Dumping %u %s bytes from %p:\n", a3, a1, a2);
  result = sub_41DB8(2, (const char *)v6, 0);
  while ( v5 > 0 )
  {
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( i >= v5 )
        v6[0] = &unk_202020;
      else
        snprintf((char *)v6, 0x800u, "%02x ", v8[i]);
      sub_41DB8(2, (const char *)v6, 0);
    }
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( i >= v5 )
      {
        LOWORD(v6[0]) = 32;
        sub_41DB8(2, (const char *)v6, 0);
      }
      else
      {
        if ( v8[i] <= 0x1Fu || v8[i] > 0x7Eu )
          v4 = 46;
        else
          v4 = v8[i];
        snprintf((char *)v6, 0x800u, "%c", v4);
        sub_41DB8(2, (const char *)v6, 0);
      }
    }
    LOWORD(v6[0]) = 10;
    result = sub_41DB8(2, (const char *)v6, 0);
    v8 += 16;
    if ( v5 <= 16 )
      break;
    v5 -= 16;
  }
  return result;
}

//----- (00064EB8) --------------------------------------------------------
int __fastcall sub_64EB8(int a1)
{
  int v1; // r0
  char v4[8]; // [sp+Ch] [bp-828h] BYREF
  int v5; // [sp+80Ch] [bp-28h] BYREF
  unsigned __int8 v6; // [sp+810h] [bp-24h]
  _DWORD v7[4]; // [sp+814h] [bp-20h] BYREF
  char v8; // [sp+827h] [bp-Dh]
  unsigned __int16 v9; // [sp+828h] [bp-Ch]
  __int16 v10; // [sp+82Ah] [bp-Ah]
  int v11; // [sp+82Ch] [bp-8h]

  v11 = -2147483136;
  pthread_mutex_lock(&stru_550A6C);
  v8 = 4;
  v7[0] = 386181717;
  v7[2] = 0;
  v7[3] = 0;
  v5 = 0;
  v6 = 0;
  v10 = 27;
  v7[1] = 6912;
  v9 = 6;
  v1 = sub_74108(a1, (int)v7, 6u);
  if ( v1 == v9 )
  {
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v5, 5u) == 5 )
    {
      if ( BYTE1(v5) == 23 && (unsigned __int8)v5 == 5 )
      {
        v9 = 0;
        v10 = 0;
        while ( v9 <= 2u )
          v10 += *((unsigned __int8 *)&v5 + v9++);
        if ( HIBYTE(v10) == HIBYTE(v5) && (unsigned __int8)v10 == v6 )
        {
          v11 = BYTE2(v5);
        }
        else
        {
          snprintf(v4, 0x800u, "%s failed 2!\n", "_bitmain_pic_get_sw_ver_common");
          sub_41DB8(0, v4, 0);
          sub_64C38("read return data", (unsigned __int8 *)&v5, 5);
        }
      }
      else
      {
        snprintf(v4, 0x800u, "%s failed!\n", "_bitmain_pic_get_sw_ver_common");
        sub_41DB8(0, v4, 0);
        sub_64C38("read return data", (unsigned __int8 *)&v5, 5);
      }
    }
    else
    {
      snprintf(v4, 0x800u, "%s read iic err\n", "_bitmain_pic_get_sw_ver_common");
      sub_41DB8(0, v4, 0);
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s write iic err\n", "_bitmain_pic_get_sw_ver_common");
    sub_41DB8(0, v4, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v11;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (00065230) --------------------------------------------------------
int __fastcall sub_65230(int a1)
{
  int v1; // r0
  char v4[4]; // [sp+10h] [bp-824h] BYREF
  __int16 v5; // [sp+810h] [bp-24h] BYREF
  _DWORD v6[4]; // [sp+814h] [bp-20h] BYREF
  char v7; // [sp+827h] [bp-Dh]
  unsigned __int16 v8; // [sp+828h] [bp-Ch]
  __int16 v9; // [sp+82Ah] [bp-Ah]
  int v10; // [sp+82Ch] [bp-8h]

  v10 = -2147483136;
  pthread_mutex_lock(&stru_550A6C);
  v7 = 4;
  v6[0] = 100969045;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  v9 = 10;
  v6[1] = 2560;
  v8 = 6;
  v1 = sub_74108(a1, (int)v6, 6u);
  if ( v1 == v8 )
  {
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v5, 2u) == 2 )
    {
      usleep(0x493E0u);
      if ( (unsigned __int8)v5 == 6 && HIBYTE(v5) == 1 )
      {
        v10 = 0;
      }
      else
      {
        snprintf(
          v4,
          0x800u,
          "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_bitmain_pic_start_app_common",
          (unsigned __int8)v5,
          HIBYTE(v5));
        sub_41DB8(0, v4, 0);
      }
    }
    else
    {
      snprintf(v4, 0x800u, "%s read iic err\n", "_bitmain_pic_start_app_common");
      sub_41DB8(0, v4, 0);
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s write iic err\n", "_bitmain_pic_start_app_common");
    sub_41DB8(0, v4, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v10;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (000654B4) --------------------------------------------------------
int __fastcall sub_654B4(int a1)
{
  int v1; // r0
  char v4[4]; // [sp+8h] [bp-824h] BYREF
  __int16 v5; // [sp+808h] [bp-24h] BYREF
  _DWORD v6[4]; // [sp+80Ch] [bp-20h] BYREF
  char v7; // [sp+81Fh] [bp-Dh]
  unsigned __int16 v8; // [sp+820h] [bp-Ch]
  __int16 v9; // [sp+822h] [bp-Ah]
  int v10; // [sp+824h] [bp-8h]

  v10 = -2147483136;
  pthread_mutex_lock(&stru_550A6C);
  v7 = 4;
  v6[0] = 117746261;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  v9 = 11;
  v6[1] = 2816;
  v8 = 6;
  v1 = sub_74108(a1, (int)v6, 6u);
  if ( v1 == v8 )
  {
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v5, 2u) == 2 )
    {
      if ( (unsigned __int8)v5 == 7 && HIBYTE(v5) == 1 )
        v10 = 0;
    }
    else
    {
      snprintf(v4, 0x800u, "%s read iic err\n", "_bitmain_pic_reset_common");
      sub_41DB8(0, v4, 0);
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s write iic err\n", "_bitmain_pic_reset_common");
    sub_41DB8(0, v4, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  usleep(0x7A120u);
  return v10;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (000656F8) --------------------------------------------------------
int __fastcall sub_656F8(int a1)
{
  int v1; // r0
  char v4[4]; // [sp+10h] [bp-824h] BYREF
  __int16 v5; // [sp+810h] [bp-24h] BYREF
  _DWORD v6[4]; // [sp+814h] [bp-20h] BYREF
  char v7; // [sp+827h] [bp-Dh]
  unsigned __int16 v8; // [sp+828h] [bp-Ch]
  __int16 v9; // [sp+82Ah] [bp-Ah]
  int v10; // [sp+82Ch] [bp-8h]

  v10 = -2147483136;
  pthread_mutex_lock(&stru_550A6C);
  v7 = 5;
  v6[0] = 352692821;
  v6[1] = 1769473;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  v9 = 27;
  v8 = 7;
  v1 = sub_74108(a1, (int)v6, 7u);
  if ( v1 == v8 )
  {
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v5, 2u) == 2 )
    {
      if ( (unsigned __int8)v5 == 21 && HIBYTE(v5) == 1 )
      {
        v10 = 0;
      }
      else
      {
        snprintf(
          v4,
          0x800u,
          "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_bitmain_pic_enable_dc_dc_common",
          (unsigned __int8)v5,
          HIBYTE(v5));
        sub_41DB8(0, v4, 0);
      }
    }
    else
    {
      snprintf(v4, 0x800u, "%s read iic err\n", "_bitmain_pic_enable_dc_dc_common");
      sub_41DB8(0, v4, 0);
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s write iic err\n", "_bitmain_pic_enable_dc_dc_common");
    sub_41DB8(0, v4, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v10;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (0006598C) --------------------------------------------------------
int __fastcall sub_6598C(int a1)
{
  int v1; // r0
  char v4[4]; // [sp+10h] [bp-824h] BYREF
  __int16 v5; // [sp+810h] [bp-24h] BYREF
  _DWORD v6[4]; // [sp+814h] [bp-20h] BYREF
  char v7; // [sp+827h] [bp-Dh]
  unsigned __int16 v8; // [sp+828h] [bp-Ch]
  __int16 v9; // [sp+82Ah] [bp-Ah]
  int v10; // [sp+82Ch] [bp-8h]

  v10 = -2147483136;
  pthread_mutex_lock(&stru_550A6C);
  v7 = 5;
  v6[0] = 352692821;
  v6[1] = 1703936;
  v6[2] = 0;
  v6[3] = 0;
  v5 = 0;
  v9 = 26;
  v8 = 7;
  v1 = sub_74108(a1, (int)v6, 7u);
  if ( v1 == v8 )
  {
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v5, 2u) == 2 )
    {
      if ( (unsigned __int8)v5 == 21 && HIBYTE(v5) == 1 )
      {
        v10 = 0;
      }
      else
      {
        snprintf(
          v4,
          0x800u,
          "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_bitmain_pic_disable_dc_dc_common",
          (unsigned __int8)v5,
          HIBYTE(v5));
        sub_41DB8(0, v4, 0);
      }
    }
    else
    {
      snprintf(v4, 0x800u, "%s read iic err\n", "_bitmain_pic_disable_dc_dc_common");
      sub_41DB8(0, v4, 0);
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s write iic err\n", "_bitmain_pic_disable_dc_dc_common");
    sub_41DB8(0, v4, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v10;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (00065C20) --------------------------------------------------------
int __fastcall sub_65C20(int a1)
{
  int v1; // r0
  char v4[8]; // [sp+Ch] [bp-828h] BYREF
  int v5; // [sp+80Ch] [bp-28h] BYREF
  __int16 v6; // [sp+810h] [bp-24h]
  _DWORD v7[4]; // [sp+814h] [bp-20h] BYREF
  char v8; // [sp+827h] [bp-Dh]
  unsigned __int16 v9; // [sp+828h] [bp-Ch]
  __int16 v10; // [sp+82Ah] [bp-Ah]
  int v11; // [sp+82Ch] [bp-8h]

  v11 = -2147483136;
  pthread_mutex_lock(&stru_550A6C);
  v8 = 4;
  v7[0] = 369404501;
  v7[2] = 0;
  v7[3] = 0;
  v5 = 0;
  v6 = 0;
  v10 = 26;
  v7[1] = 6656;
  v9 = 6;
  v1 = sub_74108(a1, (int)v7, 6u);
  if ( v1 == v9 )
  {
    usleep(0x2710u);
    if ( sub_7405C(a1, (int)&v5, 6u) == 6 )
    {
      if ( BYTE1(v5) == 22 && BYTE2(v5) == 1 )
      {
        v11 = 0;
      }
      else
      {
        snprintf(v4, 0x800u, "%s failed!\n", "_bitmain_pic_heart_beat_common");
        sub_41DB8(0, v4, 0);
        sub_64C38("read return data", (unsigned __int8 *)&v5, 6);
      }
    }
    else
    {
      snprintf(v4, 0x800u, "%s read iic err\n", "_bitmain_pic_heart_beat_common");
      sub_41DB8(0, v4, 0);
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s write iic err\n", "_bitmain_pic_heart_beat_common");
    sub_41DB8(0, v4, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v11;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (00065EBC) --------------------------------------------------------
int __fastcall sub_65EBC(unsigned __int8 a1)
{
  char v4[16]; // [sp+14h] [bp-810h] BYREF
  int v5; // [sp+814h] [bp-10h] BYREF
  __int16 v6; // [sp+818h] [bp-Ch]
  char v7; // [sp+81Ah] [bp-Ah]
  unsigned __int8 v8; // [sp+81Bh] [bp-9h]
  int v9; // [sp+81Ch] [bp-8h]

  v9 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1] && dword_AB7A7C[2 * a1 + 1] )
    {
      return dword_AB7A7C[2 * a1];
    }
    else
    {
      v5 = a1;
      v6 = 0;
      v7 = 4;
      v8 = a1;
      pthread_mutex_lock(&stru_550A6C);
      v9 = sub_73D18((int)&v5);
      pthread_mutex_unlock(&stru_550A6C);
      if ( v9 >= 0 )
      {
        dword_AB7A7C[2 * a1] = v9;
        dword_AB7A7C[2 * a1 + 1] = 1;
      }
      return v9;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad pic param, input chain is %d\n", "open_pic", a1);
    sub_41DB8(0, v4, 0);
    return -2147483135;
  }
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (00066020) --------------------------------------------------------
int __fastcall sub_66020(int result)
{
  unsigned __int8 v1; // [sp+Fh] [bp-805h]
  char v2[4]; // [sp+10h] [bp-804h] BYREF

  v1 = result;
  if ( (unsigned __int8)result <= 0xFu )
  {
    if ( dword_AB7A7C[2 * (unsigned __int8)result] || dword_AB7A7C[2 * (unsigned __int8)result + 1] )
    {
      pthread_mutex_lock(&stru_550A6C);
      sub_73FC0(dword_AB7A7C[2 * v1]);
      dword_AB7A7C[2 * v1] = 0;
      dword_AB7A7C[2 * v1 + 1] = 0;
      return pthread_mutex_unlock(&stru_550A6C);
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: Bad pic param, input chain is %d\n", "close_pic", (unsigned __int8)result);
    return sub_41DB8(0, v2, 0);
  }
  return result;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (0006612C) --------------------------------------------------------
int __fastcall sub_6612C(unsigned __int8 a1)
{
  char v4[12]; // [sp+10h] [bp-80Ch] BYREF
  int v5; // [sp+810h] [bp-Ch]
  int v6; // [sp+814h] [bp-8h]

  v6 = 0;
  v5 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_64EB8(dword_AB7A7C[2 * a1]);
    v6 = sub_65EBC(a1);
    if ( v6 >= 0 )
    {
      return sub_64EB8(dword_AB7A7C[2 * a1]);
    }
    else
    {
      snprintf(v4, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "get_pic_version", a1);
      sub_41DB8(0, v4, 0);
      return v6;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad pic param, input chain is %d\n", "get_pic_version", a1);
    sub_41DB8(0, v4, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (0006626C) --------------------------------------------------------
int __fastcall sub_6626C(unsigned __int8 a1)
{
  char v4[8]; // [sp+14h] [bp-808h] BYREF
  int v5; // [sp+814h] [bp-8h]

  v5 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_654B4(dword_AB7A7C[2 * a1]);
    v5 = sub_65EBC(a1);
    if ( v5 >= 0 )
    {
      return sub_654B4(dword_AB7A7C[2 * a1]);
    }
    else
    {
      snprintf(v4, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "reset_pic", a1);
      sub_41DB8(0, v4, 0);
      return v5;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad pic param, input chain is %d\n", "reset_pic", a1);
    sub_41DB8(0, v4, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (000663A4) --------------------------------------------------------
int __fastcall sub_663A4(unsigned __int8 a1)
{
  char v4[8]; // [sp+14h] [bp-808h] BYREF
  int v5; // [sp+814h] [bp-8h]

  v5 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_65230(dword_AB7A7C[2 * a1]);
    v5 = sub_65EBC(a1);
    if ( v5 >= 0 )
    {
      return sub_65230(dword_AB7A7C[2 * a1]);
    }
    else
    {
      snprintf(v4, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "jump_from_loader_to_app", a1);
      sub_41DB8(0, v4, 0);
      return v5;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad pic param, input chain is %d\n", "jump_from_loader_to_app", a1);
    sub_41DB8(0, v4, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (000664DC) --------------------------------------------------------
int __fastcall sub_664DC(unsigned __int8 a1)
{
  char v4[8]; // [sp+14h] [bp-808h] BYREF
  int v5; // [sp+814h] [bp-8h]

  v5 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_656F8(dword_AB7A7C[2 * a1]);
    v5 = sub_65EBC(a1);
    if ( v5 >= 0 )
    {
      return sub_656F8(dword_AB7A7C[2 * a1]);
    }
    else
    {
      snprintf(v4, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "enable_dc_dc", a1);
      sub_41DB8(0, v4, 0);
      return v5;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad pic param, input chain is %d\n", "enable_dc_dc", a1);
    sub_41DB8(0, v4, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (00066614) --------------------------------------------------------
int __fastcall sub_66614(unsigned __int8 a1)
{
  char v4[8]; // [sp+14h] [bp-808h] BYREF
  int v5; // [sp+814h] [bp-8h]

  v5 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_6598C(dword_AB7A7C[2 * a1]);
    v5 = sub_65EBC(a1);
    if ( v5 >= 0 )
    {
      return sub_6598C(dword_AB7A7C[2 * a1]);
    }
    else
    {
      snprintf(v4, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "disable_dc_dc", a1);
      sub_41DB8(0, v4, 0);
      return v5;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad pic param, input chain is %d\n", "disable_dc_dc", a1);
    sub_41DB8(0, v4, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (0006674C) --------------------------------------------------------
int __fastcall sub_6674C(unsigned __int8 a1)
{
  char v4[8]; // [sp+14h] [bp-808h] BYREF
  int v5; // [sp+814h] [bp-8h]

  v5 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_65C20(dword_AB7A7C[2 * a1]);
    v5 = sub_65EBC(a1);
    if ( v5 >= 0 )
    {
      return sub_65C20(dword_AB7A7C[2 * a1]);
    }
    else
    {
      snprintf(v4, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "send_pic_heart_beat", a1);
      sub_41DB8(0, v4, 0);
      return v5;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: Bad pic param, input chain is %d\n", "send_pic_heart_beat", a1);
    sub_41DB8(0, v4, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (00066884) --------------------------------------------------------
int __fastcall sub_66884(const char *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v4; // r3
  int v5; // [sp+Ch] [bp-818h]
  _DWORD v6[3]; // [sp+18h] [bp-80Ch] BYREF
  unsigned int i; // [sp+818h] [bp-Ch]
  unsigned __int8 *v8; // [sp+81Ch] [bp-8h]

  v5 = a3;
  v8 = a2;
  snprintf((char *)v6, 0x800u, "Dumping %u %s bytes from %p:\n", a3, a1, a2);
  result = sub_41DB8(2, (const char *)v6, 0);
  while ( v5 > 0 )
  {
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( i >= v5 )
        v6[0] = &unk_202020;
      else
        snprintf((char *)v6, 0x800u, "%02x ", v8[i]);
      sub_41DB8(2, (const char *)v6, 0);
    }
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( i >= v5 )
      {
        LOWORD(v6[0]) = 32;
        sub_41DB8(2, (const char *)v6, 0);
      }
      else
      {
        if ( v8[i] <= 0x1Fu || v8[i] > 0x7Eu )
          v4 = 46;
        else
          v4 = v8[i];
        snprintf((char *)v6, 0x800u, "%c", v4);
        sub_41DB8(2, (const char *)v6, 0);
      }
    }
    LOWORD(v6[0]) = 10;
    result = sub_41DB8(2, (const char *)v6, 0);
    v8 += 16;
    if ( v5 <= 16 )
      break;
    v5 -= 16;
  }
  return result;
}

//----- (00066B04) --------------------------------------------------------
int __fastcall sub_66B04(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5)
{
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r0
  char v14[12]; // [sp+18h] [bp-83Ch] BYREF
  __int16 v15; // [sp+818h] [bp-3Ch] BYREF
  _BYTE s[35]; // [sp+81Ch] [bp-38h] BYREF
  __int16 v17; // [sp+83Fh] [bp-15h]
  char v18; // [sp+841h] [bp-13h]
  unsigned __int16 v19; // [sp+842h] [bp-12h]
  int i; // [sp+844h] [bp-10h]
  _BYTE v21[6]; // [sp+84Ah] [bp-Ah]
  int v22; // [sp+858h] [bp+4h]

  *(_WORD *)&v21[4] = 0;
  pthread_mutex_lock(&stru_550A6C);
  v18 = 0;
  v17 = (unsigned __int8)(a5 + 6);
  memset(s, 0, 0x20u);
  v15 = 0;
  *(_DWORD *)v21 = (unsigned __int16)((unsigned __int8)v17 + a2 + a3 + 53);
  s[0] = 85;
  s[1] = -86;
  s[2] = a5 + 6;
  s[3] = 53;
  s[4] = a2;
  v19 = 6;
  s[5] = a3;
  v5 = a5;
  if ( a5 >= 16 )
    v5 = 16;
  v22 = v5;
  for ( i = 0; i < v22; ++i )
  {
    if ( (i & 1) == 0 && *(unsigned __int8 *)(a4 + i) > 0x3Fu )
    {
      snprintf(v14, 0x800u, "%s: the data[%d] must less than 0x3f\n", "_app_write_data_into_flash_1704_v8", i);
      sub_41DB8(0, v14, 0);
    }
    *(_WORD *)v21 += *(unsigned __int8 *)(a4 + i);
    s[v19 + i] = *(_BYTE *)(a4 + i);
  }
  v19 += v22;
  v6 = v19++;
  s[v6] = v21[1];
  v7 = v19++;
  s[v7] = v21[0];
  v8 = sub_74108(a1, (int)s, v19);
  if ( v8 == v19 )
  {
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v15, 2u) == 2 )
    {
      if ( (unsigned __int8)v15 == 53 && HIBYTE(v15) == 1 )
      {
        *(_DWORD *)&v21[2] = v22;
      }
      else
      {
        snprintf(
          v14,
          0x800u,
          "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_app_write_data_into_flash_1704_v8",
          (unsigned __int8)v15,
          HIBYTE(v15));
        sub_41DB8(0, v14, 0);
      }
    }
    else
    {
      snprintf(v14, 0x800u, "%s read iic 2 err\n", "_app_write_data_into_flash_1704_v8");
      sub_41DB8(0, v14, 0);
    }
  }
  else
  {
    snprintf(v14, 0x800u, "%s write iic 2 err\n", "_app_write_data_into_flash_1704_v8");
    sub_41DB8(0, v14, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return *(_DWORD *)&v21[2];
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (00066F10) --------------------------------------------------------
int __fastcall sub_66F10(int a1, unsigned __int8 a2, unsigned __int8 a3, void *a4, int a5)
{
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r3
  int v9; // r0
  int v10; // r0
  size_t v11; // r3
  char v17[4]; // [sp+20h] [bp-824h] BYREF
  int v18; // [sp+820h] [bp-24h] BYREF
  int v19; // [sp+824h] [bp-20h]
  char v20; // [sp+828h] [bp-1Ch]
  void *ptr; // [sp+82Ch] [bp-18h]
  size_t size; // [sp+830h] [bp-14h]
  char v23; // [sp+835h] [bp-Fh]
  __int16 v24; // [sp+836h] [bp-Eh]
  unsigned __int16 v25; // [sp+838h] [bp-Ch]
  _BYTE v26[6]; // [sp+83Ah] [bp-Ah]
  int v27; // [sp+848h] [bp+4h]

  *(_WORD *)&v26[4] = 0;
  pthread_mutex_lock(&stru_550A6C);
  v24 = 0;
  v23 = 7;
  v18 = 906472021;
  v20 = 0;
  size = a5 + 5;
  ptr = malloc(a5 + 5);
  *(_DWORD *)v26 = (unsigned __int16)(a2 + 7 + a3 + 54);
  v19 = a2;
  v25 = 6;
  BYTE1(v19) = a3;
  v5 = a5;
  if ( a5 >= 16 )
    v5 = 16;
  v27 = v5;
  v6 = v25++;
  *((_BYTE *)&v18 + v6) = v27;
  *(_WORD *)v26 += v27;
  v7 = v25++;
  *((_BYTE *)&v18 + v7) = v26[1];
  v8 = v25++;
  *((_BYTE *)&v18 + v8) = v26[0];
  v9 = sub_74108(a1, (int)&v18, v25);
  if ( v9 == v25 )
  {
    usleep(0x493E0u);
    v10 = sub_7405C(a1, (int)ptr, size);
    if ( size == v10 )
    {
      if ( *((_BYTE *)ptr + 1) == 54 && *((_BYTE *)ptr + 2) == 1 && size == *(unsigned __int8 *)ptr )
      {
        v25 = 0;
        *(_WORD *)v26 = 0;
        while ( v25 < (int)(size - 2) )
          *(_WORD *)v26 += *((unsigned __int8 *)ptr + v25++);
        if ( v26[1] == *((unsigned __int8 *)ptr + size - 2) && v26[0] == *((unsigned __int8 *)ptr + size - 1) )
        {
          v11 = v27;
          if ( v27 >= 16 )
            v11 = 16;
          *(_DWORD *)&v26[2] = v11;
          memcpy(a4, (char *)ptr + 3, v11);
          *(_DWORD *)&v26[2] = v27;
        }
        else
        {
          snprintf(v17, 0x800u, "%s failed 2!\n", "_app_read_data_from_flash_1704_v8");
          sub_41DB8(0, v17, 0);
          sub_66884("read return data", (unsigned __int8 *)ptr, size);
        }
      }
      else
      {
        snprintf(
          v17,
          0x800u,
          "%s failed !\n read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x\n",
          "_app_read_data_from_flash_1704_v8",
          *(unsigned __int8 *)ptr,
          *((unsigned __int8 *)ptr + 1),
          *((unsigned __int8 *)ptr + 2));
        sub_41DB8(0, v17, 0);
        sub_66884("read return data", (unsigned __int8 *)ptr, size);
      }
    }
    else
    {
      snprintf(v17, 0x800u, "%s read iic 2 err\n", "_app_read_data_from_flash_1704_v8");
      sub_41DB8(0, v17, 0);
    }
  }
  else
  {
    snprintf(v17, 0x800u, "%s write iic 2 err\n", "_app_read_data_from_flash_1704_v8");
    sub_41DB8(0, v17, 0);
  }
  free(ptr);
  pthread_mutex_unlock(&stru_550A6C);
  return *(_DWORD *)&v26[2];
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (000673E0) --------------------------------------------------------
unsigned int __fastcall sub_673E0(int a1, unsigned __int8 *a2, unsigned int a3)
{
  int v3; // r0
  char v8[4]; // [sp+18h] [bp-814h] BYREF
  int v9; // [sp+818h] [bp-14h] BYREF
  __int16 v10; // [sp+81Ch] [bp-10h]
  char v11; // [sp+81Fh] [bp-Dh]
  int v12; // [sp+820h] [bp-Ch]
  unsigned __int16 v13; // [sp+824h] [bp-8h]
  __int16 v14; // [sp+826h] [bp-6h]

  v11 = 4;
  v9 = 923052629;
  v12 = -1;
  v14 = 59;
  v10 = 15104;
  v13 = 6;
  v3 = sub_74108(a1, (int)&v9, 6u);
  if ( v3 == v13 )
  {
    usleep(0x2710u);
    if ( a3 == sub_7405C(a1, (int)a2, a3) )
    {
      if ( *a2 == 11 && a2[1] == 55 )
      {
        v13 = 0;
        v14 = 0;
        while ( v13 < (int)(a3 - 2) )
          v14 += a2[v13++];
        if ( HIBYTE(v14) == a2[a3 - 2] && (unsigned __int8)v14 == a2[a3 - 1] )
        {
          return a3;
        }
        else
        {
          snprintf(v8, 0x800u, "%s failed 2!\n", "_read_an_voltage");
          sub_41DB8(0, v8, 0);
        }
      }
      else
      {
        snprintf(
          v8,
          0x800u,
          "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_read_an_voltage",
          *a2,
          a2[1]);
        sub_41DB8(0, v8, 0);
      }
    }
    else
    {
      snprintf(v8, 0x800u, "%s read iic err\n", "_read_an_voltage");
      sub_41DB8(0, v8, 0);
    }
  }
  else
  {
    snprintf(v8, 0x800u, "%s write iic err\n", "_read_an_voltage");
    sub_41DB8(0, v8, 0);
  }
  return v12;
}

//----- (00067734) --------------------------------------------------------
unsigned int __fastcall sub_67734(int a1, unsigned __int8 *a2, unsigned int a3)
{
  int v3; // r0
  char v8[4]; // [sp+20h] [bp-814h] BYREF
  int v9; // [sp+820h] [bp-14h] BYREF
  __int16 v10; // [sp+824h] [bp-10h]
  char v11; // [sp+827h] [bp-Dh]
  int v12; // [sp+828h] [bp-Ch]
  unsigned __int16 v13; // [sp+82Ch] [bp-8h]
  __int16 v14; // [sp+82Eh] [bp-6h]

  v11 = 4;
  v9 = 973384277;
  v12 = -1;
  v14 = 62;
  v10 = 15872;
  v13 = 6;
  v3 = sub_74108(a1, (int)&v9, 6u);
  if ( v3 == v13 )
  {
    usleep(0x2710u);
    if ( a3 == sub_7405C(a1, (int)a2, a3) )
    {
      if ( *a2 == 7 && a2[1] == 58 && a2[2] == 1 )
      {
        v13 = 0;
        v14 = 0;
        while ( v13 < (int)(a3 - 2) )
          v14 += a2[v13++];
        if ( HIBYTE(v14) == a2[a3 - 2] && (unsigned __int8)v14 == a2[a3 - 1] )
        {
          return a3;
        }
        else
        {
          snprintf(v8, 0x800u, "%s failed 2!\n", "_read_an6_voltage");
          sub_41DB8(0, v8, 0);
        }
      }
      else
      {
        snprintf(
          v8,
          0x800u,
          "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
          "_read_an6_voltage",
          *a2,
          a2[1],
          a2[2]);
        sub_41DB8(0, v8, 0);
      }
    }
    else
    {
      snprintf(v8, 0x800u, "%s read iic err\n", "_read_an6_voltage");
      sub_41DB8(0, v8, 0);
    }
  }
  else
  {
    snprintf(v8, 0x800u, "%s write iic err\n", "_read_an6_voltage");
    sub_41DB8(0, v8, 0);
  }
  return v12;
}

//----- (00067AAC) --------------------------------------------------------
size_t __fastcall sub_67AAC(int a1, unsigned __int8 a2, void *a3, int a4)
{
  int v4; // r3
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r3
  int v9; // r3
  int v10; // r3
  int v11; // r3
  int v12; // r3
  int v13; // r0
  int v14; // r0
  size_t n; // [sp+10h] [bp-844h]
  char v21[4]; // [sp+20h] [bp-834h] BYREF
  _BYTE v22[20]; // [sp+820h] [bp-34h] BYREF
  __int16 v23; // [sp+834h] [bp-20h]
  _DWORD v24[2]; // [sp+838h] [bp-1Ch] BYREF
  unsigned int v25; // [sp+840h] [bp-14h]
  unsigned __int8 v26; // [sp+847h] [bp-Dh]
  unsigned __int16 v27; // [sp+848h] [bp-Ch]
  __int16 v28; // [sp+84Ah] [bp-Ah]
  size_t v29; // [sp+84Ch] [bp-8h]

  pthread_mutex_lock(&stru_550A6C);
  v29 = 0;
  v26 = 6;
  v28 = 0;
  v27 = 0;
  v24[0] = 0;
  v24[1] = 0;
  memset(v22, 0, sizeof(v22));
  v23 = 0;
  v25 = 0;
  v4 = a4;
  if ( a4 >= 16 )
    v4 = 16;
  n = v4;
  v28 = v26 + a2 + v4 + 60;
  v25 = v4 + 5;
  v5 = v27++;
  *((_BYTE *)v24 + v5) = 85;
  v6 = v27++;
  *((_BYTE *)v24 + v6) = -86;
  v7 = v27++;
  *((_BYTE *)v24 + v7) = v26;
  v8 = v27++;
  *((_BYTE *)v24 + v8) = 60;
  v9 = v27++;
  *((_BYTE *)v24 + v9) = a2;
  v10 = v27++;
  *((_BYTE *)v24 + v10) = n;
  v11 = v27++;
  *((_BYTE *)v24 + v11) = HIBYTE(v28);
  v12 = v27++;
  *((_BYTE *)v24 + v12) = v28;
  v13 = sub_74108(a1, (int)v24, v27);
  if ( v13 == v27 )
  {
    usleep(0x2710u);
    v14 = sub_7405C(a1, (int)v22, v25);
    if ( v25 == v14 )
    {
      if ( v25 == v22[0] && v22[1] == 60 && v22[2] == 1 )
      {
        v27 = 0;
        v28 = 0;
        while ( v27 < (int)(v25 - 2) )
          v28 += (unsigned __int8)v22[v27++];
        if ( HIBYTE(v28) == (unsigned __int8)v22[v25 - 2] && (unsigned __int8)v28 == (unsigned __int8)v22[v25 - 1] )
        {
          memcpy(a3, &v22[3], n);
          v29 = n;
        }
        else
        {
          snprintf(v21, 0x800u, "%s failed 2!\n", "_pic_read_iic");
          sub_41DB8(0, v21, 0);
        }
      }
      else
      {
        snprintf(
          v21,
          0x800u,
          "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
          "_pic_read_iic",
          v22[0],
          v22[1],
          v22[2]);
        sub_41DB8(0, v21, 0);
      }
    }
    else
    {
      snprintf(v21, 0x800u, "%s read iic err\n", "_pic_read_iic");
      sub_41DB8(0, v21, 0);
    }
  }
  else
  {
    snprintf(v21, 0x800u, "%s write iic err\n", "_pic_read_iic");
    sub_41DB8(0, v21, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v29;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (00067ED8) --------------------------------------------------------
int __fastcall sub_67ED8(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5)
{
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r3
  int v9; // r3
  int v10; // r3
  int v11; // r3
  int v12; // r3
  int v13; // r3
  int v14; // r3
  int v15; // r0
  int v16; // r0
  char v22[16]; // [sp+1Ch] [bp-830h] BYREF
  __int16 v23; // [sp+81Ch] [bp-30h] BYREF
  _BYTE v24[24]; // [sp+820h] [bp-2Ch] BYREF
  unsigned int v25; // [sp+838h] [bp-14h]
  unsigned __int8 v26; // [sp+83Dh] [bp-Fh]
  unsigned __int16 i; // [sp+83Eh] [bp-Eh]
  unsigned __int16 v28; // [sp+840h] [bp-Ch]
  __int16 v29; // [sp+842h] [bp-Ah]
  int v30; // [sp+844h] [bp-8h]
  int v31; // [sp+850h] [bp+4h]

  pthread_mutex_lock(&stru_550A6C);
  v30 = -2147483136;
  v26 = a5 + 6;
  v29 = 0;
  v28 = 0;
  i = 0;
  memset(v24, 0, sizeof(v24));
  v23 = 0;
  v25 = 2;
  v5 = a5;
  if ( a5 >= 16 )
    v5 = 16;
  v31 = v5;
  v29 = v26 + a2 + a3 + 59;
  v6 = v28++;
  v24[v6] = 85;
  v7 = v28++;
  v24[v7] = -86;
  v8 = v28++;
  v24[v8] = v26;
  v9 = v28++;
  v24[v9] = 59;
  v10 = v28++;
  v24[v10] = a2;
  v11 = v28++;
  v24[v11] = a3;
  for ( i = 0; v31 > i; ++i )
  {
    v12 = v28++;
    v24[v12] = *(_BYTE *)(a4 + i);
    v29 += *(unsigned __int8 *)(a4 + i);
  }
  v13 = v28++;
  v24[v13] = HIBYTE(v29);
  v14 = v28++;
  v24[v14] = v29;
  v15 = sub_74108(a1, (int)v24, v28);
  if ( v15 == v28 )
  {
    usleep(0x2710u);
    v16 = sub_7405C(a1, (int)&v23, v25);
    if ( v25 == v16 )
    {
      if ( (unsigned __int8)v23 == 59 && HIBYTE(v23) == 1 )
      {
        v30 = v31;
      }
      else
      {
        snprintf(
          v22,
          0x800u,
          "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_pic_write_iic",
          (unsigned __int8)v23,
          HIBYTE(v23));
        sub_41DB8(0, v22, 0);
      }
    }
    else
    {
      snprintf(v22, 0x800u, "%s read iic err\n", "_pic_write_iic");
      sub_41DB8(0, v22, 0);
    }
  }
  else
  {
    snprintf(v22, 0x800u, "%s write iic err\n", "_pic_write_iic");
    sub_41DB8(0, v22, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v30;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (0006827C) --------------------------------------------------------
int __fastcall sub_6827C(int a1, int a2)
{
  int v2; // r3
  int v3; // r3
  int v4; // r0
  int v5; // r0
  char v9[8]; // [sp+14h] [bp-838h] BYREF
  __int16 v10; // [sp+814h] [bp-38h] BYREF
  _BYTE s[33]; // [sp+818h] [bp-34h] BYREF
  char v12; // [sp+839h] [bp-13h]
  unsigned __int16 v13; // [sp+83Ah] [bp-12h]
  int i; // [sp+83Ch] [bp-10h]
  __int16 v15; // [sp+842h] [bp-Ah]
  int v16; // [sp+844h] [bp-8h]

  v16 = -2147483136;
  pthread_mutex_lock(&stru_550A6C);
  memset(s, 0, 0x20u);
  v10 = 0;
  v12 = 20;
  v15 = 22;
  s[0] = 85;
  s[1] = -86;
  s[2] = 20;
  v13 = 4;
  s[3] = 2;
  memset(&s[4], 0, 0x10u);
  for ( i = 0; i <= 15; ++i )
  {
    s[v13 + i] = *(_BYTE *)(a2 + i);
    v15 += *(unsigned __int8 *)(a2 + i);
  }
  v13 += 16;
  v2 = v13++;
  s[v2] = HIBYTE(v15);
  v3 = v13++;
  s[v3] = v15;
  v4 = sub_74108(a1, (int)s, v13);
  if ( v4 == v13 )
  {
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v10, 2u) == 2 )
    {
      if ( (unsigned __int8)v10 == 2 && HIBYTE(v10) == 1 )
      {
        v12 = 4;
        v15 = 9;
        s[0] = 85;
        s[1] = -86;
        s[2] = 4;
        s[3] = 5;
        s[4] = 0;
        v13 = 6;
        s[5] = 9;
        v5 = sub_74108(a1, (int)s, 6u);
        if ( v5 == v13 )
        {
          usleep(0x493E0u);
          if ( sub_7405C(a1, (int)&v10, 2u) == 2 )
          {
            if ( (unsigned __int8)v10 == 5 && HIBYTE(v10) == 1 )
            {
              v16 = 0;
              snprintf(v9, 0x800u, "%s  success write to pic flash\n", "_bitmain_pic_write_1704");
              sub_41DB8(2, v9, 0);
            }
            else
            {
              snprintf(
                v9,
                0x800u,
                "%s failed 2! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
                "_bitmain_pic_write_1704",
                (unsigned __int8)v10,
                HIBYTE(v10));
              sub_41DB8(0, v9, 0);
            }
          }
          else
          {
            snprintf(v9, 0x800u, "%s read iic 2 err\n", "_bitmain_pic_write_1704");
            sub_41DB8(0, v9, 0);
          }
        }
        else
        {
          snprintf(v9, 0x800u, "%s write iic 2 err\n", "_bitmain_pic_write_1704");
          sub_41DB8(0, v9, 0);
        }
      }
      else
      {
        snprintf(
          v9,
          0x800u,
          "%s failed 1! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_bitmain_pic_write_1704",
          (unsigned __int8)v10,
          HIBYTE(v10));
        sub_41DB8(0, v9, 0);
      }
    }
    else
    {
      snprintf(v9, 0x800u, "%s read iic 1 err\n", "_bitmain_pic_write_1704");
      sub_41DB8(0, v9, 0);
    }
  }
  else
  {
    snprintf(v9, 0x800u, "%s write iic 1 err\n", "_bitmain_pic_write_1704");
    sub_41DB8(0, v9, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v16;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (00068810) --------------------------------------------------------
int __fastcall sub_68810(int a1, __int16 a2)
{
  int v2; // r0
  char v6[4]; // [sp+10h] [bp-824h] BYREF
  __int16 v7; // [sp+810h] [bp-24h] BYREF
  int v8; // [sp+814h] [bp-20h] BYREF
  char v9; // [sp+818h] [bp-1Ch]
  char v10; // [sp+819h] [bp-1Bh]
  int v11; // [sp+81Ah] [bp-1Ah]
  __int16 v12; // [sp+81Eh] [bp-16h]
  int v13; // [sp+820h] [bp-14h]
  __int16 v14; // [sp+825h] [bp-Fh]
  char v15; // [sp+827h] [bp-Dh]
  unsigned __int16 v16; // [sp+828h] [bp-Ch]
  __int16 v17; // [sp+82Ah] [bp-Ah]
  int v18; // [sp+82Ch] [bp-8h]

  v18 = -2147483136;
  pthread_mutex_lock(&stru_550A6C);
  v15 = 6;
  v8 = 17214037;
  v12 = 0;
  v13 = 0;
  v7 = 0;
  v14 = a2;
  v17 = HIBYTE(a2) + 6 + (unsigned __int8)a2 + 1;
  v9 = HIBYTE(a2);
  v10 = a2;
  v11 = HIBYTE(v17);
  v16 = 8;
  *(_WORD *)((char *)&v11 + 1) = (unsigned __int8)(HIBYTE(a2) + 6 + a2 + 1);
  v2 = sub_74108(a1, (int)&v8, 8u);
  if ( v2 == v16 )
  {
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v7, 2u) == 2 )
    {
      if ( (unsigned __int8)v7 == 1 && HIBYTE(v7) == 1 )
      {
        v18 = 0;
      }
      else
      {
        snprintf(
          v6,
          0x800u,
          "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
          "_bitmain_pic_seek_1704",
          (unsigned __int8)v7,
          HIBYTE(v7));
        sub_41DB8(0, v6, 0);
      }
    }
    else
    {
      snprintf(v6, 0x800u, "%s read iic err\n", "_bitmain_pic_seek_1704");
      sub_41DB8(0, v6, 0);
    }
  }
  else
  {
    snprintf(v6, 0x800u, "%s write iic err\n", "_bitmain_pic_seek_1704");
    sub_41DB8(0, v6, 0);
  }
  pthread_mutex_unlock(&stru_550A6C);
  return v18;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (00068AF8) --------------------------------------------------------
int __fastcall sub_68AF8(int a1, int a2)
{
  int v2; // r3
  int v3; // r3
  int v4; // r3
  int v5; // r3
  int v6; // r3
  int v7; // r3
  int v8; // r0
  int v11; // [sp+8h] [bp-824h]
  char v13[12]; // [sp+10h] [bp-81Ch] BYREF
  __int16 v14; // [sp+810h] [bp-1Ch] BYREF
  int v15; // [sp+814h] [bp-18h] BYREF
  __int16 v16; // [sp+818h] [bp-14h]
  unsigned __int8 v17; // [sp+81Dh] [bp-Fh]
  __int16 v18; // [sp+81Eh] [bp-Eh]
  int v19; // [sp+820h] [bp-Ch]
  unsigned __int16 v20; // [sp+826h] [bp-6h]

  v11 = a2;
  v19 = a2;
  pthread_mutex_lock(&stru_550A6C);
  v18 = 0;
  v20 = 0;
  v17 = 4;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  while ( 1 )
  {
    v18 = v17 + 4;
    v2 = v20++;
    *((_BYTE *)&v15 + v2) = 85;
    v3 = v20++;
    *((_BYTE *)&v15 + v3) = -86;
    v4 = v20++;
    *((_BYTE *)&v15 + v4) = v17;
    v5 = v20++;
    *((_BYTE *)&v15 + v5) = 4;
    v6 = v20++;
    *((_BYTE *)&v15 + v6) = HIBYTE(v18);
    v7 = v20++;
    *((_BYTE *)&v15 + v7) = v18;
    v8 = sub_74108(a1, (int)&v15, v20);
    if ( v8 != v20 )
    {
      snprintf(v13, 0x800u, "%s write iic err\n", "_bitmain_pic_erase_1704");
      sub_41DB8(0, v13, 0);
      goto LABEL_10;
    }
    usleep(0x493E0u);
    if ( sub_7405C(a1, (int)&v14, 2u) != 2 )
    {
      snprintf(v13, 0x800u, "%s read iic err\n", "_bitmain_pic_erase_1704");
      sub_41DB8(0, v13, 0);
      goto LABEL_10;
    }
    usleep(0x493E0u);
    if ( (unsigned __int8)v14 != 4 || HIBYTE(v14) != 1 )
      break;
    v11 -= 32;
    if ( v11 <= 31 )
      goto LABEL_10;
  }
  snprintf(
    v13,
    0x800u,
    "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
    "_bitmain_pic_erase_1704",
    (unsigned __int8)v14,
    HIBYTE(v14));
  sub_41DB8(0, v13, 0);
LABEL_10:
  pthread_mutex_unlock(&stru_550A6C);
  if ( v11 <= 0 )
    return 0;
  else
    return v19;
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;

//----- (00068DB4) --------------------------------------------------------
int __fastcall sub_68DB4(int a1)
{
  char v3[12]; // [sp+8h] [bp-81Ch] BYREF
  int v4; // [sp+808h] [bp-1Ch]
  int v5; // [sp+80Ch] [bp-18h]
  unsigned __int8 v6; // [sp+810h] [bp-14h]
  unsigned __int8 v7; // [sp+811h] [bp-13h]
  unsigned __int8 v8; // [sp+812h] [bp-12h]
  unsigned __int8 v9; // [sp+813h] [bp-11h]
  int v10; // [sp+814h] [bp-10h]
  int v11; // [sp+818h] [bp-Ch]
  int v12; // [sp+81Ch] [bp-8h]

  v11 = 0;
  v10 = 0;
  v9 = 6;
  v8 = 0;
  v7 = 15;
  v6 = 127;
  v5 = 0;
  v4 = 1536;
  v12 = sub_68810(a1, 1536);
  if ( v12 )
  {
    snprintf(v3, 0x800u, "%s set 1704 flash pointer err\n", "_erase_pic_app");
    sub_41DB8(0, v3, 0);
  }
  else
  {
    v5 = (v7 << 8) + v6 - ((v9 << 8) + v8) + 1;
    v12 = sub_68AF8(a1, v5);
    if ( v5 == v12 )
    {
      return 0;
    }
    else
    {
      snprintf(v3, 0x800u, "%s erase pic err\n", "_erase_pic_app");
      sub_41DB8(0, v3, 0);
      return -2147483136;
    }
  }
  return v12;
}

//----- (00068F38) --------------------------------------------------------
int __fastcall sub_68F38(unsigned __int8 a1, const char *a2)
{
  int *v2; // r3
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  char v10[12]; // [sp+10h] [bp-1BCCh] BYREF
  int v11; // [sp+810h] [bp-13CCh] BYREF
  int v12; // [sp+814h] [bp-13C8h]
  int v13; // [sp+818h] [bp-13C4h]
  int v14; // [sp+81Ch] [bp-13C0h]
  int v15; // [sp+820h] [bp-13BCh] BYREF
  char v16; // [sp+824h] [bp-13B8h]
  _BYTE v17[5000]; // [sp+828h] [bp-13B4h] BYREF
  FILE *stream; // [sp+1BB0h] [bp-2Ch]
  int v19; // [sp+1BB4h] [bp-28h]
  unsigned int v20; // [sp+1BB8h] [bp-24h]
  unsigned __int8 v21; // [sp+1BBCh] [bp-20h]
  unsigned __int8 v22; // [sp+1BBDh] [bp-1Fh]
  unsigned __int8 v23; // [sp+1BBEh] [bp-1Eh]
  unsigned __int8 v24; // [sp+1BBFh] [bp-1Dh]
  unsigned int v25; // [sp+1BC0h] [bp-1Ch]
  int v26; // [sp+1BC4h] [bp-18h]
  int v27; // [sp+1BC8h] [bp-14h]
  unsigned int j; // [sp+1BCCh] [bp-10h]
  unsigned int i; // [sp+1BD0h] [bp-Ch]
  int v30; // [sp+1BD4h] [bp-8h]

  v30 = -2147483136;
  memset(v17, 0, sizeof(v17));
  v27 = 0;
  i = 0;
  v15 = 0;
  v16 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v26 = dword_AB7A7C[2 * a1];
  v25 = 0;
  v24 = 6;
  v23 = 0;
  v22 = 15;
  v21 = 127;
  v20 = 0;
  v19 = 1536;
  snprintf(v10, 0x800u, "%s\n", "_update_pic_app_program_1704");
  sub_41DB8(2, v10, 0);
  stream = fopen(a2, "r");
  if ( stream )
  {
    fseek(stream, 0, 0);
    memset(v17, 0, sizeof(v17));
    v20 = (v22 << 8) + v21 - ((v24 << 8) + v23) + 1;
    snprintf(v10, 0x800u, "%s: pic_flash_length = %d\n", "_update_pic_app_program_1704", v20);
    sub_41DB8(2, v10, 0);
    for ( i = 0; i < v20; ++i )
    {
      fgets((char *)&v15, 1023, stream);
      v25 = strtoul((const char *)&v15, 0, 16);
      v17[2 * i] = BYTE1(v25);
      v17[2 * i + 1] = v25;
    }
    fclose(stream);
    v30 = sub_6626C(a1);
    if ( !v30 )
    {
      v30 = sub_68DB4(v26);
      if ( v30 )
      {
        snprintf(v10, 0x800u, "%s: erase app flash error!\n\n", "_update_pic_app_program_1704");
        sub_41DB8(0, v10, 0);
        return v30;
      }
      v30 = sub_68810(v26, v19);
      if ( v30 )
      {
        snprintf(v10, 0x800u, "%s: set 1704 flash pointer err!\n\n", "_update_pic_app_program_1704");
        sub_41DB8(0, v10, 0);
        return v30;
      }
      for ( i = 0; i < 4 * (v20 >> 5); ++i )
      {
        v2 = (int *)&v17[16 * i];
        v3 = *v2;
        v4 = v2[1];
        v5 = v2[2];
        v6 = v2[3];
        v11 = v3;
        v12 = v4;
        v13 = v5;
        v14 = v6;
        snprintf(v10, 0x800u, "send pic program time: %d", i);
        sub_41DB8(2, v10, 0);
        for ( j = 0; j <= 0xF; ++j )
          ;
        sub_6827C(v26, (int)&v11);
      }
      v30 = sub_6626C(a1);
      if ( !v30 )
        return 0;
    }
    snprintf(v10, 0x800u, "%s: reset pic error!\n\n", "_update_pic_app_program_1704");
    sub_41DB8(0, v10, 0);
  }
  else
  {
    snprintf(v10, 0x800u, "%s: open %s failed\n", "_update_pic_app_program_1704", a2);
    sub_41DB8(0, v10, 0);
  }
  return v30;
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (000694CC) --------------------------------------------------------
int __fastcall sub_694CC(unsigned __int8 a1, int *a2, int a3)
{
  char v8[4]; // [sp+18h] [bp-824h] BYREF
  unsigned __int8 v9[8]; // [sp+818h] [bp-24h] BYREF
  unsigned __int8 v10[4]; // [sp+820h] [bp-1Ch] BYREF
  _DWORD v11[2]; // [sp+824h] [bp-18h]
  int v12; // [sp+82Ch] [bp-10h]
  int i; // [sp+830h] [bp-Ch]
  int v14; // [sp+834h] [bp-8h]

  v14 = -2147483136;
  i = 0;
  v12 = 3;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] || (v14 = sub_65EBC(a1), v14 >= 0) )
    {
      if ( a3 == 3 )
      {
        pthread_mutex_lock(&stru_550A6C);
        *(_DWORD *)v10 = 0;
        v11[0] = 0;
        *(_DWORD *)((char *)v11 + 3) = 0;
        v14 = sub_673E0(dword_AB7A7C[2 * a1], v10, 0xBu);
        if ( v14 == 11 )
        {
          for ( i = 0; i < 3; ++i )
          {
            a2[i] = (v10[v12] << 8) | v10[v12 + 1];
            v12 += 2;
          }
        }
        pthread_mutex_unlock(&stru_550A6C);
      }
      else if ( a3 == 1 )
      {
        pthread_mutex_lock(&stru_550A6C);
        memset(v9, 0, 7);
        v14 = sub_67734(dword_AB7A7C[2 * a1], v9, 7u);
        if ( v14 == 7 )
        {
          *a2 = (v9[v12] << 8) | v9[v12 + 1];
          v12 += 2;
        }
        pthread_mutex_unlock(&stru_550A6C);
      }
      else
      {
        snprintf(v8, 0x800u, "%s failed: parameters error!\n", "pic_get_voltage");
        sub_41DB8(0, v8, 0);
        return -2147483135;
      }
      return v14;
    }
    else
    {
      snprintf(v8, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_get_voltage", a1);
      sub_41DB8(0, v8, 0);
      return v14;
    }
  }
  else
  {
    snprintf(v8, 0x800u, "%s: Bad pic param, input chain is %d\n", "pic_get_voltage", a1);
    sub_41DB8(0, v8, 0);
    return -2147483135;
  }
}
// 550A6C: using guessed type pthread_mutex_t stru_550A6C;
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (000697D0) --------------------------------------------------------
int __fastcall sub_697D0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5)
{
  char v11[8]; // [sp+14h] [bp-808h] BYREF
  int v12; // [sp+814h] [bp-8h]

  v12 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_66B04(dword_AB7A7C[2 * a1], a2, a3, a4, a5);
    v12 = sub_65EBC(a1);
    if ( v12 >= 0 )
    {
      return sub_66B04(dword_AB7A7C[2 * a1], a2, a3, a4, a5);
    }
    else
    {
      snprintf(
        v11,
        0x800u,
        "%s: auto exec open_pic, but chain %d open eeprom failed\n",
        "app_write_data_into_flash",
        a1);
      sub_41DB8(0, v11, 0);
      return v12;
    }
  }
  else
  {
    snprintf(v11, 0x800u, "%s: Bad pic param, input chain is %d\n", "app_write_data_into_flash", a1);
    sub_41DB8(0, v11, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (00069930) --------------------------------------------------------
int __fastcall sub_69930(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, void *a4, int a5)
{
  char v11[8]; // [sp+14h] [bp-808h] BYREF
  int v12; // [sp+814h] [bp-8h]

  v12 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_66F10(dword_AB7A7C[2 * a1], a2, a3, a4, a5);
    v12 = sub_65EBC(a1);
    if ( v12 >= 0 )
    {
      return sub_66F10(dword_AB7A7C[2 * a1], a2, a3, a4, a5);
    }
    else
    {
      snprintf(v11, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "app_read_data_from_flash", a1);
      sub_41DB8(0, v11, 0);
      return v12;
    }
  }
  else
  {
    snprintf(v11, 0x800u, "%s: Bad pic param, input chain is %d\n", "app_read_data_from_flash", a1);
    sub_41DB8(0, v11, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (00069A90) --------------------------------------------------------
int __fastcall sub_69A90(unsigned __int8 a1, const char *a2)
{
  char v6[8]; // [sp+14h] [bp-808h] BYREF
  int v7; // [sp+814h] [bp-8h]

  v7 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_68F38(a1, a2);
    v7 = sub_65EBC(a1);
    if ( v7 >= 0 )
    {
      return sub_68F38(a1, a2);
    }
    else
    {
      snprintf(v6, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "upgrade_pic", a1);
      sub_41DB8(0, v6, 0);
      return v7;
    }
  }
  else
  {
    snprintf(v6, 0x800u, "%s: Bad pic param, input chain is %d\n", "upgrade_pic", a1);
    sub_41DB8(0, v6, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (00069BC4) --------------------------------------------------------
size_t __fastcall sub_69BC4(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, void *a4, int a5)
{
  char v11[8]; // [sp+14h] [bp-808h] BYREF
  int v12; // [sp+814h] [bp-8h]

  v12 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] || (v12 = sub_65EBC(a1), v12 >= 0) )
    {
      v12 = sub_67ED8(dword_AB7A7C[2 * a1], a2, a3, 0, 0);
      if ( v12 >= 0 )
      {
        usleep(0x2710u);
        return sub_67AAC(dword_AB7A7C[2 * a1], a2, a4, a5);
      }
      else
      {
        snprintf(v11, 0x800u, "%s: select slave: 0x%02x, reg/command: 0x%02x is failed", "pic_read_iic", a2, a3);
        sub_41DB8(0, v11, 0);
        return v12;
      }
    }
    else
    {
      snprintf(v11, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_read_iic", a1);
      sub_41DB8(0, v11, 0);
      return v12;
    }
  }
  else
  {
    snprintf(v11, 0x800u, "%s: Bad pic param, input chain is %d\n", "pic_read_iic", a1);
    sub_41DB8(0, v11, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (00069DB8) --------------------------------------------------------
int __fastcall sub_69DB8(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5)
{
  char v11[8]; // [sp+14h] [bp-808h] BYREF
  int v12; // [sp+814h] [bp-8h]

  v12 = 0;
  if ( a1 <= 0xFu )
  {
    if ( dword_AB7A7C[2 * a1 + 1] )
      return sub_67ED8(dword_AB7A7C[2 * a1], a2, a3, a4, a5);
    v12 = sub_65EBC(a1);
    if ( v12 >= 0 )
    {
      return sub_67ED8(dword_AB7A7C[2 * a1], a2, a3, a4, a5);
    }
    else
    {
      snprintf(v11, 0x800u, "%s: auto exec open_pic, but chain %d open eeprom failed\n", "pic_write_iic", a1);
      sub_41DB8(0, v11, 0);
      return v12;
    }
  }
  else
  {
    snprintf(v11, 0x800u, "%s: Bad pic param, input chain is %d\n", "pic_write_iic", a1);
    sub_41DB8(0, v11, 0);
    return -2147483135;
  }
}
// AB7A7C: using guessed type _DWORD dword_AB7A7C[32];

//----- (00069F18) --------------------------------------------------------
unsigned int __fastcall sub_69F18(unsigned int a1)
{
  return bswap32(a1);
}

//----- (00069F40) --------------------------------------------------------
unsigned int __fastcall sub_69F40(int a1, unsigned int a2)
{
  return bswap32(a2);
}

//----- (00069F84) --------------------------------------------------------
int __fastcall sub_69F84(_BYTE *a1, __int16 a2)
{
  _BYTE *v2; // r3
  unsigned __int16 v7; // [sp+Ch] [bp-8h]
  unsigned __int8 v8; // [sp+Eh] [bp-6h]
  unsigned __int8 v9; // [sp+Fh] [bp-5h]

  v9 = -1;
  v8 = -1;
  while ( a2-- )
  {
    v2 = a1++;
    v7 = (unsigned __int8)(v8 ^ *v2);
    v8 = v9 ^ byte_A60AC[v8 ^ *v2];
    v9 = byte_A61AC[v7];
  }
  return (unsigned __int16)(v9 << 8) | (unsigned __int16)v8;
}
// A60AC: using guessed type _BYTE byte_A60AC[256];
// A61AC: using guessed type _BYTE byte_A61AC[256];

//----- (0006A04C) --------------------------------------------------------
int __fastcall sub_6A04C(int a1, int a2)
{
  int i; // [sp+1Ch] [bp-8h]

  if ( a2 <= 1 || a2 > 256 )
    return 0;
  for ( i = 0; i < a2; ++i )
  {
    round();
    *(_BYTE *)(a1 + i) = (unsigned int)((double)i * (255.0 / (double)(a2 - 1)));
  }
  return 1;
}
// 1267C: using guessed type int round(void);

//----- (0006A120) --------------------------------------------------------
int __fastcall sub_6A120(int a1, int a2)
{
  double v2; // d0
  int i; // [sp+24h] [bp-8h]

  if ( a2 <= 1 )
    return 0;
  sub_6ABA4();
  sub_6AC28();
  if ( v2 < 0.0 )
    return 0;
  for ( i = 0; i < a2; ++i )
    *(double *)(a1 + 8 * i) = v2 - (double)i * ((v2 - v2) / (double)(a2 - 1));
  return 1;
}
// 6A164: variable 'v2' is possibly undefined

//----- (0006A20C) --------------------------------------------------------
int __fastcall sub_6A20C(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int16 v5; // [sp+16h] [bp-Eh]
  int v6; // [sp+18h] [bp-Ch]
  unsigned int v7; // [sp+1Ch] [bp-8h]
  unsigned int i; // [sp+1Ch] [bp-8h]

  v6 = 0;
  if ( !a1 || !a2 || !a3 )
    return -2147482879;
  v7 = 2;
  v5 = 0;
  while ( a3 - 2 > v7 )
    v5 += a2[v7++];
  if ( v5 == (unsigned __int16)((a2[a3 - 1] << 8) + a2[a3 - 2]) )
  {
    if ( *a1 != *a2 || a1[1] != a2[1] || a1[3] != a2[3] || a3 != a2[2] + 2 )
      v6 = -2147482880;
  }
  else
  {
    v6 = -2147482880;
  }
  if ( v6 )
  {
    for ( i = 0; a3 > i; ++i )
      ;
  }
  return v6;
}

//----- (0006A3F4) --------------------------------------------------------
int __fastcall sub_6A3F4(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  char v7[16]; // [sp+1Ch] [bp-810h] BYREF
  unsigned __int16 v8; // [sp+81Ch] [bp-10h]
  unsigned __int16 v9; // [sp+81Eh] [bp-Eh]
  int v10; // [sp+820h] [bp-Ch]
  unsigned int i; // [sp+824h] [bp-8h]

  i = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  if ( !a1 || !a2 || !a3 )
    return -2147482879;
  i = 2;
  v9 = 0;
  while ( a3 - 2 > i )
  {
    v9 += a2[i] + (a2[i + 1] << 8);
    i += 2;
  }
  v8 = (a2[a3 - 1] << 8) + a2[a3 - 2];
  if ( v9 == v8 )
  {
    if ( *a1 != *a2 || a1[1] != a2[1] || a1[3] != a2[3] || a3 != a2[2] + 2 )
      v10 = -2147482880;
  }
  else
  {
    snprintf(v7, 0x800u, "power reply the bad crc, crc = 0x%04x, crc_read = 0x%04x\n", v9, v8);
    sub_41DB8(0, v7, 0);
    v10 = -2147482880;
  }
  if ( v10 )
  {
    for ( i = 0; a3 > i; ++i )
    {
      snprintf(v7, 0x800u, "read_back_data[%d] = 0x%02x", i, a2[i]);
      sub_41DB8(0, v7, 0);
    }
  }
  return v10;
}

//----- (0006A6A0) --------------------------------------------------------
int __fastcall sub_6A6A0(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  char v10; // [sp+1Eh] [bp-Eh] BYREF
  unsigned __int8 v11; // [sp+1Fh] [bp-Dh] BYREF
  int v12; // [sp+20h] [bp-Ch]
  unsigned __int8 i; // [sp+26h] [bp-6h]
  unsigned __int8 j; // [sp+27h] [bp-5h]

  j = 0;
  i = 0;
  v12 = 0;
  v11 = 0;
  pthread_mutex_lock(&stru_550A88);
  if ( byte_550C40 != 1 )
  {
    v10 = 4;
    sub_7427C(a1, &v11, 1, (int)&v10, 1u, 1);
    byte_550C40 = 1;
  }
  for ( i = 0; i <= 2u; ++i )
  {
    for ( j = 0; a3 > j; sub_7427C(a1, &v11, 1, (int)&a2[j++], 1u, 1) )
      ;
    usleep(0x61A80u);
    for ( j = 0; a5 > j; sub_741B4(a1, &v11, 1, (int)&a4[j++], 1u, 0) )
      ;
    usleep(0x186A0u);
    v12 = sub_6A20C(a2, a4, a5);
    if ( !v12 )
      break;
  }
  pthread_mutex_unlock(&stru_550A88);
  return v12;
}
// 550A88: using guessed type pthread_mutex_t stru_550A88;
// 550C40: using guessed type char byte_550C40;

//----- (0006A874) --------------------------------------------------------
int __fastcall sub_6A874(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  char v11[2051]; // [sp+18h] [bp-814h] BYREF
  unsigned __int8 v12; // [sp+81Bh] [bp-11h] BYREF
  unsigned __int8 *v13; // [sp+81Ch] [bp-10h]
  int v14; // [sp+820h] [bp-Ch]
  unsigned __int8 i; // [sp+826h] [bp-6h]
  unsigned __int8 j; // [sp+827h] [bp-5h]

  j = 0;
  i = 0;
  v14 = 0;
  v12 = 17;
  if ( (a3 & 1) != 0 || (a5 & 1) != 0 )
  {
    strcpy(v11, "WARNING: exec_power_cmd_v2 only support even len\n");
    sub_41DB8(3, v11, 0);
    return -1;
  }
  else
  {
    pthread_mutex_lock(&stru_550A88);
    for ( i = 0; i <= 3u; ++i )
    {
      for ( j = 0; a3 > j; sub_7427C(a1, &v12, 1, (int)&a2[j++], 1u, 0) )
        ;
      usleep(0x7A120u);
      v13 = a4;
      for ( j = 0; a5 > j; sub_741B4(a1, &v12, 1, (int)&v13[j++], 1u, 0) )
        ;
      usleep(0x186A0u);
      v14 = sub_6A3F4(a2, a4, a5);
      if ( !v14 )
        break;
    }
    pthread_mutex_unlock(&stru_550A88);
    return v14;
  }
}
// 550A88: using guessed type pthread_mutex_t stru_550A88;

//----- (0006AAC8) --------------------------------------------------------
bool sub_6AAC8()
{
  return dword_550AA8 == 98 || dword_550AA8 == 100 || dword_550AA8 == 101 || dword_550AA8 == 102 || dword_550AA8 == 26;
}
// 550AA8: using guessed type int dword_550AA8;

//----- (0006AB50) --------------------------------------------------------
bool sub_6AB50()
{
  return dword_550AA8 == 193 || dword_550AA8 == 194;
}
// 550AA8: using guessed type int dword_550AA8;

//----- (0006ABA4) --------------------------------------------------------
void sub_6ABA4()
{
  ;
}
// 550AA8: using guessed type int dword_550AA8;

//----- (0006AC28) --------------------------------------------------------
void sub_6AC28()
{
  ;
}
// 550AA8: using guessed type int dword_550AA8;

//----- (0006ACA8) --------------------------------------------------------
void sub_6ACA8()
{
  double v0; // d0
  int i; // [sp+3Ch] [bp-8h]

  sub_6ABA4();
  sub_6AC28();
  if ( v0 >= 0.0 && dword_550ACC > 1 )
  {
    for ( i = 0;
          i < dword_550ACC - 1
       && (v0 <= *(double *)&dword_550AB8[2 * i + 46] - 0.001 || v0 >= *(double *)&dword_550AB8[2 * i + 48] + 0.001)
       && (v0 >= *(double *)&dword_550AB8[2 * i + 46] + 0.001 || v0 <= *(double *)&dword_550AB8[2 * i + 48] - 0.001);
          ++i )
    {
      ;
    }
  }
}
// 6ACF4: variable 'v0' is possibly undefined
// 550AB8: using guessed type _DWORD dword_550AB8[4];
// 550ACC: using guessed type int dword_550ACC;

//----- (0006B180) --------------------------------------------------------
void sub_6B180()
{
  double v0; // d0
  int i; // [sp+3Ch] [bp-8h]

  sub_6ABA4();
  sub_6AC28();
  if ( v0 >= 0.0 && v0 <= v0 + 0.5 && v0 >= v0 - 0.5 )
  {
    for ( i = 0;
          i < dword_550ACC - 1
       && (v0 <= *((double *)&unk_550AB8 + i + 3) - 0.001 || v0 >= *((double *)&unk_550AB8 + i + 4) + 0.001)
       && (v0 <= *((double *)&unk_550AB8 + i + 3) - 0.001 || v0 >= *((double *)&unk_550AB8 + i + 4) + 0.001);
          ++i )
    {
      ;
    }
  }
}
// 6B1D4: variable 'v0' is possibly undefined
// 550ACC: using guessed type int dword_550ACC;

//----- (0006B418) --------------------------------------------------------
int sub_6B418()
{
  double v0; // d0
  float v1; // s15
  unsigned __int8 s[32]; // [sp+814h] [bp-40h] BYREF
  _DWORD v5[2]; // [sp+834h] [bp-20h] BYREF
  __int16 v6; // [sp+83Ch] [bp-18h]
  float v7; // [sp+840h] [bp-14h]
  int i; // [sp+844h] [bp-10h]
  unsigned __int16 j; // [sp+848h] [bp-Ch]
  __int16 v10; // [sp+84Ah] [bp-Ah]
  int v11; // [sp+84Ch] [bp-8h]

  v11 = 0;
  v1 = v0;
  v7 = v1;
  v5[0] = -2096584107;
  v5[1] = 0;
  v6 = 0;
  memset(s, 0, sizeof(s));
  v10 = 0;
  if ( byte_550AB0 )
  {
    if ( byte_550C18 )
    {
      sub_6ACA8();
      v7 = *(float *)&v0;
      if ( *(float *)&v0 < 0.0 )
        return -1;
    }
  }
  for ( i = 0; i <= 3; ++i )
    *((_BYTE *)&v5[1] + i) = *((_BYTE *)&v7 + i);
  for ( j = 2; j <= 7u; j += 2 )
  {
    v10 += *((unsigned __int8 *)v5 + j);
    v10 += *((unsigned __int8 *)v5 + j + 1) << 8;
  }
  v6 = v10;
  return sub_6A874(dword_550AA0, (unsigned __int8 *)v5, 0xAu, s, 0xAu);
}
// 6B444: variable 'v0' is possibly undefined
// 550AA0: using guessed type int dword_550AA0;
// 550AB0: using guessed type char byte_550AB0;
// 550C18: using guessed type char byte_550C18;

//----- (0006B5F0) --------------------------------------------------------
unsigned int sub_6B5F0()
{
  double v1; // d0
  char v3[2048]; // [sp+Ch] [bp-840h] BYREF
  float v4; // [sp+80Ch] [bp-40h]
  unsigned __int8 s[32]; // [sp+810h] [bp-3Ch] BYREF
  int v6; // [sp+830h] [bp-1Ch] BYREF
  __int16 v7; // [sp+834h] [bp-18h]
  unsigned int v9; // [sp+83Ch] [bp-10h]
  __int16 v10; // [sp+842h] [bp-Ah]
  int i; // [sp+844h] [bp-8h]

  v6 = 50637397;
  v7 = 772;
  memset(s, 0, sizeof(s));
  v10 = 0;
  v9 = 0;
  if ( sub_6A874(dword_550AA0, (unsigned __int8 *)&v6, 6u, s, 0xAu) )
  {
    strcpy(v3, "Get power set_volt value failed\n");
    sub_41DB8(3, v3, 0);
    return 0;
  }
  else
  {
    for ( i = 0; i <= 3; ++i )
      s[i - 4] = s[i + 4];
    v9 = (unsigned int)((float)(v4 * 100.0) + 0.00001);
    if ( byte_550AB0 && byte_550C18 )
    {
      v1 = (double)v9 / 100.0;
      sub_6B180();
      return (unsigned int)(float)(*(float *)&v1 * 100.0);
    }
    else
    {
      return v9;
    }
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AB0: using guessed type char byte_550AB0;
// 550C18: using guessed type char byte_550C18;

//----- (0006B7C4) --------------------------------------------------------
int sub_6B7C4()
{
  double v1; // d0
  unsigned __int8 v3[32]; // [sp+Ch] [bp-840h] BYREF
  char v4[2048]; // [sp+2Ch] [bp-820h] BYREF
  float v5; // [sp+82Ch] [bp-20h]
  int v6; // [sp+830h] [bp-1Ch] BYREF
  __int16 v7; // [sp+834h] [bp-18h]
  __int16 v9; // [sp+83Eh] [bp-Eh]
  unsigned int v10; // [sp+840h] [bp-Ch]
  int i; // [sp+844h] [bp-8h]

  v10 = 0;
  if ( !sub_6AAC8() )
    return 0;
  v6 = 67414613;
  v7 = 1028;
  memset(v3, 0, sizeof(v3));
  v9 = 0;
  if ( sub_6A874(dword_550AA0, (unsigned __int8 *)&v6, 6u, v3, 0xAu) )
  {
    strcpy(v4, "Get power dc_volt value failed\n");
    sub_41DB8(3, v4, 0);
    return 0;
  }
  else
  {
    for ( i = 0; i <= 3; ++i )
      *((_BYTE *)&v5 + i) = v3[i + 4];
    v10 = (unsigned int)((float)(v5 * 100.0) + 0.00001);
    if ( byte_550AB0 && byte_550C18 )
    {
      v1 = (double)v10 / 100.0;
      sub_6B180();
      return (int)(float)(*(float *)&v1 * 100.0);
    }
    else
    {
      return v10;
    }
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AB0: using guessed type char byte_550AB0;
// 550C18: using guessed type char byte_550C18;

//----- (0006B9B4) --------------------------------------------------------
int sub_6B9B4()
{
  unsigned __int8 v2[32]; // [sp+8h] [bp-834h] BYREF
  char v3[2048]; // [sp+28h] [bp-814h] BYREF
  int v4; // [sp+828h] [bp-14h] BYREF
  __int16 v5; // [sp+82Ch] [bp-10h]
  __int16 v7; // [sp+836h] [bp-6h]

  if ( !sub_6AAC8() )
    return -1;
  v4 = 84191829;
  v5 = 1284;
  memset(v2, 0, sizeof(v2));
  v7 = 0;
  if ( !sub_6A874(dword_550AA0, (unsigned __int8 *)&v4, 6u, v2, 8u) )
    return v2[4] == 1;
  strcpy(v3, "power 0x05 cmd failed\n");
  sub_41DB8(3, v3, 0);
  return -1;
}
// 550AA0: using guessed type int dword_550AA0;

//----- (0006BAD4) --------------------------------------------------------
int sub_6BAD4()
{
  int result; // r0
  unsigned __int8 v1[32]; // [sp+Ch] [bp-840h] BYREF
  char v2[2052]; // [sp+2Ch] [bp-820h] BYREF
  int v3; // [sp+830h] [bp-1Ch] BYREF
  __int16 v4; // [sp+834h] [bp-18h]
  int v5; // [sp+838h] [bp-14h]
  __int16 v6; // [sp+83Eh] [bp-Eh]
  int v7; // [sp+840h] [bp-Ch]
  int i; // [sp+844h] [bp-8h]

  v7 = 0;
  result = sub_6AAC8();
  if ( result )
  {
    v3 = 134523477;
    v4 = 2052;
    memset(v1, 0, sizeof(v1));
    v6 = 0;
    result = sub_6A874(dword_550AA0, (unsigned __int8 *)&v3, 6u, v1, 0xAu);
    v5 = result;
    if ( result )
    {
      strcpy(v2, "Get ac power failed\n");
      return sub_41DB8(3, v2, 0);
    }
    else
    {
      for ( i = 0; i <= 3; ++i )
        v2[i + 2048] = v1[i + 4];
    }
  }
  return result;
}
// 550AA0: using guessed type int dword_550AA0;

//----- (0006BC40) --------------------------------------------------------
int __fastcall sub_6BC40(char a1, char a2)
{
  _DWORD v6[8]; // [sp+2Ch] [bp-848h] BYREF
  char v7[2048]; // [sp+4Ch] [bp-828h] BYREF
  int v8; // [sp+84Ch] [bp-28h]
  int v9; // [sp+850h] [bp-24h] BYREF
  __int16 v10; // [sp+854h] [bp-20h]
  __int16 v12; // [sp+85Eh] [bp-16h]

  if ( !sub_6AAC8() )
    return -1;
  v9 = 235186773;
  v10 = 3588;
  memset(v6, 0, sizeof(v6));
  v12 = 0;
  if ( a1 )
  {
    HIBYTE(v10) = -114;
    HIBYTE(v9) = -114;
  }
  if ( sub_6A874(dword_550AA0, (unsigned __int8 *)&v9, 6u, (unsigned __int8 *)v6, 0xEu) )
  {
    strcpy(v7, "Get power error code failed\n");
    sub_41DB8(3, v7, 0);
    return -1;
  }
  else
  {
    v8 = v6[2];
    if ( a2 )
    {
      snprintf(
        v7,
        0x800u,
        "Get power error code[4-7 8-11] %02x%02x%02x%02x %02x%02x%02x%02x, err_code:0x%08x\n",
        LOBYTE(v6[1]),
        BYTE1(v6[1]),
        BYTE2(v6[1]),
        HIBYTE(v6[1]),
        LOBYTE(v6[2]),
        BYTE1(v6[2]),
        BYTE2(v6[2]),
        HIBYTE(v6[2]),
        v8);
      sub_41DB8(3, v7, 0);
    }
    return v8;
  }
}
// 550AA0: using guessed type int dword_550AA0;

//----- (0006BE3C) --------------------------------------------------------
int __fastcall sub_6BE3C(char a1, void *a2)
{
  unsigned __int8 v6[80]; // [sp+4Ch] [bp-888h] BYREF
  char v7[2048]; // [sp+9Ch] [bp-838h] BYREF
  int v8; // [sp+89Ch] [bp-38h] BYREF
  __int16 v9; // [sp+8A0h] [bp-34h]
  __int16 v11; // [sp+8AAh] [bp-2Ah]
  int i; // [sp+8ACh] [bp-28h]

  if ( !sub_6AAC8() )
    return -1;
  v8 = 251963989;
  v9 = 3844;
  memset(v6, 0, sizeof(v6));
  v11 = 0;
  if ( sub_6A874(dword_550AA0, (unsigned __int8 *)&v8, 6u, v6, 0x4Au) )
  {
    strcpy(v7, "Get power error data failed\n");
    sub_41DB8(3, v7, 0);
    return -1;
  }
  else
  {
    memcpy(a2, &v6[4], 0x44u);
    if ( a1 )
    {
      strcpy(v7, "Get power error data:\n");
      sub_41DB8(3, v7, 0);
      for ( i = 0; i <= 59; i += 12 )
      {
        snprintf(
          v7,
          0x800u,
          "data[%02d-%02d]: %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x\n",
          i,
          i + 11,
          v6[i + 4],
          v6[i + 5],
          v6[i + 6],
          v6[i + 7],
          v6[i + 8],
          v6[i + 9],
          v6[i + 10],
          v6[i + 11],
          v6[i + 12],
          v6[i + 13],
          v6[i + 14],
          v6[i + 15]);
        sub_41DB8(3, v7, 0);
      }
      snprintf(
        v7,
        0x800u,
        "data[60-67]: %02x%02x%02x%02x %02x%02x%02x%02x\n",
        v6[64],
        v6[65],
        v6[66],
        v6[67],
        v6[68],
        v6[69],
        v6[70],
        v6[71]);
      sub_41DB8(3, v7, 0);
    }
    return 0;
  }
}
// 550AA0: using guessed type int dword_550AA0;

//----- (0006C224) --------------------------------------------------------
int sub_6C224()
{
  _DWORD v2[8]; // [sp+Ch] [bp-838h] BYREF
  char v3[2048]; // [sp+2Ch] [bp-818h] BYREF
  int v4; // [sp+82Ch] [bp-18h]
  int v5; // [sp+830h] [bp-14h] BYREF
  __int16 v6; // [sp+834h] [bp-10h]
  __int16 v8; // [sp+83Eh] [bp-6h]

  if ( !sub_6AAC8() )
    return -1;
  v5 = 218409557;
  v6 = 3332;
  memset(v2, 0, sizeof(v2));
  v8 = 0;
  if ( sub_6A874(dword_550AA0, (unsigned __int8 *)&v5, 6u, (unsigned __int8 *)v2, 0xAu) )
  {
    strcpy(v3, "Get power update time failed\n");
    sub_41DB8(3, v3, 0);
    return -1;
  }
  else
  {
    v4 = v2[1];
    return v2[1];
  }
}
// 550AA0: using guessed type int dword_550AA0;

//----- (0006C344) --------------------------------------------------------
int sub_6C344()
{
  _DWORD v2[8]; // [sp+Ch] [bp-838h] BYREF
  char v3[2048]; // [sp+2Ch] [bp-818h] BYREF
  int v4; // [sp+82Ch] [bp-18h]
  int v5; // [sp+830h] [bp-14h] BYREF
  __int16 v6; // [sp+834h] [bp-10h]
  __int16 v8; // [sp+83Eh] [bp-6h]

  if ( !sub_6AAC8() )
    return -1;
  v5 = 201632341;
  v6 = 3076;
  memset(v2, 0, sizeof(v2));
  v8 = 0;
  if ( sub_6A874(dword_550AA0, (unsigned __int8 *)&v5, 6u, (unsigned __int8 *)v2, 0xAu) )
  {
    strcpy(v3, "Get power reset root cause failed\n");
    sub_41DB8(3, v3, 0);
    return -1;
  }
  else
  {
    v4 = v2[1];
    return v2[1];
  }
}
// 550AA0: using guessed type int dword_550AA0;

//----- (0006C474) --------------------------------------------------------
int __fastcall sub_6C474(int a1)
{
  char v3[2048]; // [sp+10h] [bp-824h] BYREF
  int v4; // [sp+810h] [bp-24h] BYREF
  __int16 v5; // [sp+814h] [bp-20h]
  int v6; // [sp+818h] [bp-1Ch] BYREF
  int v7; // [sp+81Ch] [bp-18h]
  int v8; // [sp+820h] [bp-14h]
  __int16 v9; // [sp+826h] [bp-Eh]
  char v10; // [sp+829h] [bp-Bh]
  char v11; // [sp+82Ah] [bp-Ah]
  char v12; // [sp+82Bh] [bp-9h]
  int v13; // [sp+82Ch] [bp-8h]

  v13 = -2147482880;
  v12 = 4;
  v11 = 1;
  v6 = 0;
  v7 = 0;
  v4 = 17082965;
  v8 = -1;
  v9 = 5;
  v5 = 5;
  v10 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v4, 6u, (unsigned __int8 *)&v6, 8u) )
  {
    strcpy(v3, "get power version failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v7) << 8) | (unsigned __int8)v7;
  }
}

//----- (0006C648) --------------------------------------------------------
int __fastcall sub_6C648(int a1)
{
  char v3[2048]; // [sp+10h] [bp-824h] BYREF
  int v4; // [sp+810h] [bp-24h] BYREF
  __int16 v5; // [sp+814h] [bp-20h]
  int v6; // [sp+818h] [bp-1Ch] BYREF
  int v7; // [sp+81Ch] [bp-18h]
  int v8; // [sp+820h] [bp-14h]
  __int16 v9; // [sp+826h] [bp-Eh]
  char v10; // [sp+829h] [bp-Bh]
  char v11; // [sp+82Ah] [bp-Ah]
  char v12; // [sp+82Bh] [bp-9h]
  int v13; // [sp+82Ch] [bp-8h]

  v13 = -2147482880;
  v12 = 4;
  v11 = 2;
  v6 = 0;
  v7 = 0;
  v4 = 33860181;
  v8 = -1;
  v9 = 6;
  v5 = 6;
  v10 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v4, 6u, (unsigned __int8 *)&v6, 8u) )
  {
    strcpy(v3, "get power version failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v7) << 8) | (unsigned __int8)v7;
  }
}

//----- (0006C81C) --------------------------------------------------------
int __fastcall sub_6C81C(int a1)
{
  char v3[2048]; // [sp+14h] [bp-820h] BYREF
  int v4; // [sp+814h] [bp-20h] BYREF
  __int16 v5; // [sp+818h] [bp-1Ch]
  int v6; // [sp+81Ch] [bp-18h] BYREF
  int v7; // [sp+820h] [bp-14h]
  int v8; // [sp+824h] [bp-10h]
  char v9; // [sp+829h] [bp-Bh]
  char v10; // [sp+82Ah] [bp-Ah]
  char v11; // [sp+82Bh] [bp-9h]
  int v12; // [sp+82Ch] [bp-8h]

  v12 = -2147482880;
  v11 = 4;
  v10 = 1;
  v6 = 0;
  v7 = 0;
  v4 = 17082965;
  v5 = 260;
  v8 = -1;
  v9 = 6;
  if ( sub_6A874(a1, (unsigned __int8 *)&v4, 6u, (unsigned __int8 *)&v6, 8u) )
  {
    strcpy(v3, "get power fw ver failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v7) << 8) | (unsigned __int8)v7;
  }
}

//----- (0006C9C8) --------------------------------------------------------
int __fastcall sub_6C9C8(int a1)
{
  char v3[2048]; // [sp+14h] [bp-820h] BYREF
  int v4; // [sp+814h] [bp-20h] BYREF
  __int16 v5; // [sp+818h] [bp-1Ch]
  int v6; // [sp+81Ch] [bp-18h] BYREF
  int v7; // [sp+820h] [bp-14h]
  int v8; // [sp+824h] [bp-10h]
  char v9; // [sp+829h] [bp-Bh]
  char v10; // [sp+82Ah] [bp-Ah]
  char v11; // [sp+82Bh] [bp-9h]
  int v12; // [sp+82Ch] [bp-8h]

  v12 = -2147482880;
  v11 = 4;
  v10 = 11;
  v6 = 0;
  v7 = 0;
  v4 = 184855125;
  v5 = 2820;
  v8 = -1;
  v9 = 6;
  if ( sub_6A874(a1, (unsigned __int8 *)&v4, 6u, (unsigned __int8 *)&v6, 8u) )
  {
    strcpy(v3, "get power aging time failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v7) << 8) | (unsigned __int8)v7;
  }
}

//----- (0006CB74) --------------------------------------------------------
int __fastcall sub_6CB74(int a1)
{
  char v3[2048]; // [sp+14h] [bp-820h] BYREF
  int v4; // [sp+814h] [bp-20h] BYREF
  __int16 v5; // [sp+818h] [bp-1Ch]
  int v6; // [sp+81Ch] [bp-18h] BYREF
  int v7; // [sp+820h] [bp-14h]
  int v8; // [sp+824h] [bp-10h]
  char v9; // [sp+829h] [bp-Bh]
  char v10; // [sp+82Ah] [bp-Ah]
  char v11; // [sp+82Bh] [bp-9h]
  int v12; // [sp+82Ch] [bp-8h]

  v12 = -2147482880;
  v11 = 4;
  v10 = 7;
  v6 = 0;
  v7 = 0;
  v4 = 117746261;
  v5 = 1796;
  v8 = -1;
  v9 = 6;
  if ( sub_6A874(a1, (unsigned __int8 *)&v4, 6u, (unsigned __int8 *)&v6, 8u) )
  {
    strcpy(v3, "get power release date failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v7) << 8) | (unsigned __int8)v7;
  }
}

//----- (0006CD2C) --------------------------------------------------------
int __fastcall sub_6CD2C(int a1)
{
  char v3[2048]; // [sp+14h] [bp-820h] BYREF
  int v4; // [sp+814h] [bp-20h] BYREF
  __int16 v5; // [sp+818h] [bp-1Ch]
  int v6; // [sp+81Ch] [bp-18h] BYREF
  int v7; // [sp+820h] [bp-14h]
  int v8; // [sp+824h] [bp-10h]
  char v9; // [sp+829h] [bp-Bh]
  char v10; // [sp+82Ah] [bp-Ah]
  char v11; // [sp+82Bh] [bp-9h]
  int v12; // [sp+82Ch] [bp-8h]

  v12 = -2147482880;
  v11 = 4;
  v10 = 2;
  v6 = 0;
  v7 = 0;
  v4 = 33860181;
  v5 = 516;
  v8 = -1;
  v9 = 6;
  if ( sub_6A874(a1, (unsigned __int8 *)&v4, 6u, (unsigned __int8 *)&v6, 8u) )
  {
    strcpy(v3, "get power version failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v7) << 8) | (unsigned __int8)v7;
  }
}

//----- (0006CED8) --------------------------------------------------------
int __fastcall sub_6CED8(int a1)
{
  unsigned __int8 v2[12]; // [sp+814h] [bp-20h] BYREF
  __int16 v3; // [sp+820h] [bp-14h]
  int v4; // [sp+824h] [bp-10h] BYREF
  __int16 v5; // [sp+828h] [bp-Ch]
  int v6; // [sp+82Ch] [bp-8h]

  v6 = 0;
  v4 = 151300693;
  v5 = 2308;
  memset(v2, 0, sizeof(v2));
  v3 = 0;
  return sub_6A874(a1, (unsigned __int8 *)&v4, 6u, v2, 0xEu);
}

//----- (0006CF58) --------------------------------------------------------
int __fastcall sub_6CF58(int a1, char a2)
{
  unsigned __int8 s[32]; // [sp+810h] [bp-34h] BYREF
  int v7; // [sp+830h] [bp-14h] BYREF
  int v8; // [sp+834h] [bp-10h]
  int v9; // [sp+838h] [bp-Ch]
  unsigned __int16 i; // [sp+83Ch] [bp-8h]
  __int16 v11; // [sp+83Eh] [bp-6h]

  v9 = 0;
  v7 = -2130269611;
  v8 = 0;
  memset(s, 0, sizeof(s));
  v11 = 0;
  BYTE1(v8) = a2;
  for ( i = 2; i <= 5u; i += 2 )
  {
    v11 += *((unsigned __int8 *)&v7 + i);
    v11 += *((unsigned __int8 *)&v7 + i + 1) << 8;
  }
  HIWORD(v8) = v11;
  v9 = sub_6A874(a1, (unsigned __int8 *)&v7, 8u, s, 8u);
  if ( v9 )
    return -1;
  else
    return BYTE1(v8);
}

//----- (0006D088) --------------------------------------------------------
int __fastcall sub_6D088(int a1)
{
  unsigned __int8 v2[20]; // [sp+810h] [bp-24h] BYREF
  int v3; // [sp+824h] [bp-10h] BYREF
  __int16 v4; // [sp+828h] [bp-Ch]
  __int16 v5; // [sp+82Ah] [bp-Ah]
  int v6; // [sp+82Ch] [bp-8h]

  v6 = 0;
  v3 = 235186773;
  v4 = 3588;
  memset(v2, 0, sizeof(v2));
  v5 = 0;
  return sub_6A874(a1, (unsigned __int8 *)&v3, 6u, v2, 0xEu);
}

//----- (0006D114) --------------------------------------------------------
int __fastcall sub_6D114(int a1)
{
  unsigned __int8 v2[16]; // [sp+814h] [bp-28h] BYREF
  _DWORD v3[2]; // [sp+824h] [bp-18h]
  int v4; // [sp+82Ch] [bp-10h] BYREF
  __int16 v5; // [sp+830h] [bp-Ch]
  int v6; // [sp+834h] [bp-8h]

  v6 = 0;
  v4 = 168077909;
  v5 = 2564;
  memset(v2, 0, sizeof(v2));
  v3[0] = 0;
  *(_DWORD *)((char *)v3 + 3) = 0;
  return sub_6A874(a1, (unsigned __int8 *)&v4, 6u, v2, 0x17u);
}

//----- (0006D1A0) --------------------------------------------------------
int __fastcall sub_6D1A0(int a1)
{
  char v3[2048]; // [sp+10h] [bp-81Ch] BYREF
  int v4; // [sp+810h] [bp-1Ch] BYREF
  int v5; // [sp+814h] [bp-18h]
  int v6; // [sp+818h] [bp-14h] BYREF
  __int16 v7; // [sp+81Ch] [bp-10h]
  __int16 v8; // [sp+81Eh] [bp-Eh]
  int v9; // [sp+820h] [bp-Ch]
  char v10; // [sp+825h] [bp-7h]
  char v11; // [sp+826h] [bp-6h]
  char v12; // [sp+827h] [bp-5h]

  v12 = 4;
  v11 = 3;
  v6 = 50637397;
  v4 = 0;
  v5 = 0;
  v9 = -2147482880;
  v8 = 7;
  v7 = 7;
  v10 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v4, 8u) )
  {
    strcpy(v3, "get AD conversion N failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006D36C) --------------------------------------------------------
int __fastcall sub_6D36C(int a1, unsigned __int8 a2)
{
  char v4[2048]; // [sp+14h] [bp-820h] BYREF
  int v5; // [sp+814h] [bp-20h] BYREF
  int v6; // [sp+818h] [bp-1Ch]
  int v7; // [sp+81Ch] [bp-18h] BYREF
  unsigned __int8 v8; // [sp+820h] [bp-14h]
  char v9; // [sp+821h] [bp-13h]
  __int16 v10; // [sp+822h] [bp-12h]
  __int16 v11; // [sp+826h] [bp-Eh]
  int v12; // [sp+828h] [bp-Ch]
  char v13; // [sp+82Dh] [bp-7h]
  char v14; // [sp+82Eh] [bp-6h]
  char v15; // [sp+82Fh] [bp-5h]

  v15 = 6;
  v14 = -125;
  v7 = -2096715179;
  v5 = 0;
  v6 = 0;
  v12 = -2147482880;
  v11 = a2 + 137;
  v8 = a2;
  v9 = 0;
  v10 = v11;
  v13 = 8;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v7, 8u, (unsigned __int8 *)&v5, 8u) )
  {
    strcpy(v4, "set DA conversion N failed\n");
    sub_41DB8(0, v4, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v6) << 8) | (unsigned __int8)v6;
  }
}

//----- (0006D584) --------------------------------------------------------
__int64 __fastcall sub_6D584(int a1)
{
  double v1; // r0
  double v3; // r2
  unsigned int v4; // r4
  unsigned int v5; // r2
  unsigned int v6; // r1
  char v8[2048]; // [sp+10h] [bp-834h] BYREF
  unsigned __int8 v9[12]; // [sp+810h] [bp-34h] BYREF
  __int16 v10; // [sp+81Ch] [bp-28h]
  _DWORD v11[2]; // [sp+820h] [bp-24h] BYREF
  __int16 v12; // [sp+82Ah] [bp-1Ah]
  char v13; // [sp+82Dh] [bp-17h]
  char v14; // [sp+82Eh] [bp-16h]
  char v15; // [sp+82Fh] [bp-15h]
  int i; // [sp+830h] [bp-14h]
  int v17; // [sp+834h] [bp-10h]
  char vars0; // [sp+838h] [bp-Ch] BYREF

  v15 = 4;
  v14 = -118;
  v11[0] = -1979405739;
  memset(v9, 0, sizeof(v9));
  v10 = 0;
  v17 = -2147482880;
  v12 = 142;
  v11[1] = 142;
  v13 = 6;
  LODWORD(v1) = sub_6A6A0(a1, (unsigned __int8 *)v11, 8u, v9, 0xEu);
  if ( LODWORD(v1) )
  {
    strcpy(v8, "clear power status failed\n");
    sub_41DB8(0, v8, 0);
    return 2147484416LL;
  }
  else
  {
    for ( i = 0; i <= 7; ++i )
    {
      LODWORD(v3) = &vars0;
      v4 = v9[i + 4];
      HIDWORD(v3) = 8 * i;
      pow(v1, v3);
      v5 = sub_96E38(2.0);
      LODWORD(v1) = 0;
      HIDWORD(v1) = (__PAIR64__(v6, v5) * v4) >> 32;
      v17 |= v4 * v5;
    }
    return v17;
  }
}
// 6D788: variable 'v1' is possibly undefined
// 6D7B4: variable 'v6' is possibly undefined

//----- (0006D7FC) --------------------------------------------------------
int __fastcall sub_6D7FC(int a1)
{
  unsigned __int16 i; // [sp+80Ah] [bp-Ah]
  int v4; // [sp+80Ch] [bp-8h]

  v4 = -2147482880;
  for ( i = 0; i <= 2u; ++i )
  {
    v4 = sub_6C81C(a1);
    if ( v4 )
    {
      if ( v4 != -2147482880 )
        break;
    }
  }
  return v4;
}

//----- (0006D880) --------------------------------------------------------
int __fastcall sub_6D880(int a1)
{
  unsigned __int16 i; // [sp+80Ah] [bp-Ah]
  int v4; // [sp+80Ch] [bp-8h]

  v4 = -2147482880;
  for ( i = 0; i <= 2u; ++i )
  {
    v4 = sub_6C9C8(a1);
    if ( v4 )
    {
      if ( v4 != -2147482880 )
        break;
    }
  }
  return v4;
}

//----- (0006D904) --------------------------------------------------------
int __fastcall sub_6D904(int a1)
{
  unsigned __int16 i; // [sp+80Ah] [bp-Ah]
  int v4; // [sp+80Ch] [bp-8h]

  v4 = -2147482880;
  for ( i = 0; i <= 2u; ++i )
  {
    v4 = sub_6CB74(a1);
    if ( v4 )
    {
      if ( v4 != -2147482880 )
        break;
    }
  }
  return v4;
}

//----- (0006D988) --------------------------------------------------------
int __fastcall sub_6D988(int a1)
{
  char v3[2048]; // [sp+Ch] [bp-808h] BYREF
  int v4; // [sp+80Ch] [bp-8h]

  v4 = sub_6C648(a1);
  if ( v4 == -2147482880 )
  {
    strcpy(v3, "check power version failed, use v2 protocal to try it again\n");
    sub_41DB8(0, v3, 0);
    return sub_6CD2C(a1);
  }
  return v4;
}

//----- (0006DA3C) --------------------------------------------------------
int __fastcall sub_6DA3C(int a1)
{
  char v3[2048]; // [sp+10h] [bp-81Ch] BYREF
  int v4; // [sp+810h] [bp-1Ch] BYREF
  int v5; // [sp+814h] [bp-18h]
  int v6; // [sp+818h] [bp-14h] BYREF
  __int16 v7; // [sp+81Ch] [bp-10h]
  __int16 v8; // [sp+81Eh] [bp-Eh]
  int v9; // [sp+820h] [bp-Ch]
  char v10; // [sp+825h] [bp-7h]
  char v11; // [sp+826h] [bp-6h]
  char v12; // [sp+827h] [bp-5h]

  v12 = 4;
  v11 = 4;
  v6 = 67414613;
  v4 = 0;
  v5 = 0;
  v9 = -2147482880;
  v8 = 8;
  v7 = 8;
  v10 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v4, 8u) )
  {
    strcpy(v3, "get sample N failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006DC10) --------------------------------------------------------
int __fastcall sub_6DC10(int a1, unsigned __int8 a2)
{
  char v4[2048]; // [sp+14h] [bp-820h] BYREF
  int v5; // [sp+814h] [bp-20h] BYREF
  int v6; // [sp+818h] [bp-1Ch]
  int v7; // [sp+81Ch] [bp-18h] BYREF
  unsigned __int8 v8; // [sp+820h] [bp-14h]
  char v9; // [sp+821h] [bp-13h]
  __int16 v10; // [sp+822h] [bp-12h]
  __int16 v11; // [sp+826h] [bp-Eh]
  int v12; // [sp+828h] [bp-Ch]
  char v13; // [sp+82Dh] [bp-7h]
  char v14; // [sp+82Eh] [bp-6h]
  char v15; // [sp+82Fh] [bp-5h]

  v15 = 6;
  v14 = -127;
  v7 = -2130269611;
  v5 = 0;
  v6 = 0;
  v12 = -2147482880;
  v11 = a2 + 135;
  v8 = a2;
  v9 = 0;
  v10 = v11;
  v13 = 8;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v7, 8u, (unsigned __int8 *)&v5, 8u) )
  {
    strcpy(v4, "set watchdog failed\n");
    sub_41DB8(0, v4, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v6) << 8) | (unsigned __int8)v6;
  }
}

//----- (0006DE30) --------------------------------------------------------
int __fastcall sub_6DE30(int a1)
{
  char v3[2048]; // [sp+10h] [bp-81Ch] BYREF
  int v4; // [sp+810h] [bp-1Ch] BYREF
  int v5; // [sp+814h] [bp-18h]
  int v6; // [sp+818h] [bp-14h] BYREF
  __int16 v7; // [sp+81Ch] [bp-10h]
  __int16 v8; // [sp+81Eh] [bp-Eh]
  int v9; // [sp+820h] [bp-Ch]
  char v10; // [sp+825h] [bp-7h]
  char v11; // [sp+826h] [bp-6h]
  char v12; // [sp+827h] [bp-5h]

  v12 = 4;
  v11 = 10;
  v6 = 168077909;
  v4 = 0;
  v5 = 0;
  v9 = -2147482880;
  v8 = 14;
  v7 = 14;
  v10 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v4, 8u) )
  {
    strcpy(v3, "get power status failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006E000) --------------------------------------------------------
int __fastcall sub_6E000(int a1)
{
  char v3[2048]; // [sp+10h] [bp-824h] BYREF
  int v4; // [sp+810h] [bp-24h] BYREF
  int v5; // [sp+814h] [bp-20h]
  int v6; // [sp+818h] [bp-1Ch]
  __int16 v7; // [sp+81Ch] [bp-18h]
  int v8; // [sp+820h] [bp-14h] BYREF
  __int16 v9; // [sp+824h] [bp-10h]
  __int16 v10; // [sp+826h] [bp-Eh]
  int v11; // [sp+828h] [bp-Ch]
  char v12; // [sp+82Dh] [bp-7h]
  char v13; // [sp+82Eh] [bp-6h]
  char v14; // [sp+82Fh] [bp-5h]

  v14 = 4;
  v13 = 10;
  v8 = 168077909;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v11 = -2147482880;
  v10 = 14;
  v9 = 14;
  v12 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v8, 6u, (unsigned __int8 *)&v4, 0xEu) )
  {
    strcpy(v3, "get power status failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (HIBYTE(v5) << 24) | (BYTE2(v5) << 16) & 0xFF0000 | (unsigned __int16)(BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006E1F0) --------------------------------------------------------
int __fastcall sub_6E1F0(int a1)
{
  char v3[2048]; // [sp+10h] [bp-824h] BYREF
  _DWORD v4[2]; // [sp+810h] [bp-24h] BYREF
  int v5; // [sp+818h] [bp-1Ch]
  __int16 v6; // [sp+81Ch] [bp-18h]
  int v7; // [sp+820h] [bp-14h] BYREF
  __int16 v8; // [sp+824h] [bp-10h]
  __int16 v9; // [sp+826h] [bp-Eh]
  int v10; // [sp+828h] [bp-Ch]
  char v11; // [sp+82Dh] [bp-7h]
  char v12; // [sp+82Eh] [bp-6h]
  char v13; // [sp+82Fh] [bp-5h]

  v13 = 4;
  v12 = 10;
  v7 = 168077909;
  v4[0] = 0;
  v4[1] = 0;
  v5 = 0;
  v6 = 0;
  v10 = -2147482880;
  v9 = 14;
  v8 = 14;
  v11 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v7, 6u, (unsigned __int8 *)v4, 0xEu) )
  {
    strcpy(v3, "get power status failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (HIBYTE(v5) << 24) | (BYTE2(v5) << 16) & 0xFF0000 | (unsigned __int16)(BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006E3E0) --------------------------------------------------------
int __fastcall sub_6E3E0(int a1)
{
  char v3[2048]; // [sp+14h] [bp-820h] BYREF
  int v4; // [sp+814h] [bp-20h] BYREF
  int v5; // [sp+818h] [bp-1Ch]
  __int16 v6; // [sp+81Ch] [bp-18h]
  int v7; // [sp+820h] [bp-14h] BYREF
  __int16 v8; // [sp+824h] [bp-10h]
  __int16 v9; // [sp+826h] [bp-Eh]
  int v10; // [sp+828h] [bp-Ch]
  char v11; // [sp+82Dh] [bp-7h]
  char v12; // [sp+82Eh] [bp-6h]
  char v13; // [sp+82Fh] [bp-5h]

  v13 = 4;
  v12 = 13;
  v7 = 218409557;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v10 = -2147482880;
  v9 = 17;
  v8 = 17;
  v11 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v7, 6u, (unsigned __int8 *)&v4, 0xAu) )
  {
    strcpy(v3, "get power input status failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (HIBYTE(v5) << 24) | (BYTE2(v5) << 16) & 0xFF0000 | (unsigned __int16)(BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006E5E0) --------------------------------------------------------
int __fastcall sub_6E5E0(int a1)
{
  char v3[2048]; // [sp+10h] [bp-81Ch] BYREF
  int v4; // [sp+810h] [bp-1Ch] BYREF
  int v5; // [sp+814h] [bp-18h]
  int v6; // [sp+818h] [bp-14h] BYREF
  __int16 v7; // [sp+81Ch] [bp-10h]
  __int16 v8; // [sp+81Eh] [bp-Eh]
  int v9; // [sp+820h] [bp-Ch]
  char v10; // [sp+825h] [bp-7h]
  char v11; // [sp+826h] [bp-6h]
  char v12; // [sp+827h] [bp-5h]

  v12 = 4;
  v11 = 5;
  v6 = 84191829;
  v4 = 0;
  v5 = 0;
  v9 = -2147482880;
  v8 = 9;
  v7 = 9;
  v10 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v4, 8u) )
  {
    strcpy(v3, "get power enable status failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006E7AC) --------------------------------------------------------
int __fastcall sub_6E7AC(int a1)
{
  char v3[2048]; // [sp+10h] [bp-81Ch] BYREF
  int v4; // [sp+810h] [bp-1Ch] BYREF
  int v5; // [sp+814h] [bp-18h]
  int v6; // [sp+818h] [bp-14h] BYREF
  __int16 v7; // [sp+81Ch] [bp-10h]
  __int16 v8; // [sp+81Eh] [bp-Eh]
  int v9; // [sp+820h] [bp-Ch]
  char v10; // [sp+825h] [bp-7h]
  char v11; // [sp+826h] [bp-6h]
  char v12; // [sp+827h] [bp-5h]

  v12 = 4;
  v11 = 8;
  v6 = 134523477;
  v4 = 0;
  v5 = 0;
  v9 = -2147482880;
  v8 = 12;
  v7 = 12;
  v10 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v6, 6u, (unsigned __int8 *)&v4, 8u) )
  {
    strcpy(v3, "get power status failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006E97C) --------------------------------------------------------
int __fastcall sub_6E97C(int a1)
{
  char v3[2048]; // [sp+14h] [bp-820h] BYREF
  int v4; // [sp+814h] [bp-20h] BYREF
  int v5; // [sp+818h] [bp-1Ch]
  __int16 v6; // [sp+81Ch] [bp-18h]
  int v7; // [sp+820h] [bp-14h] BYREF
  __int16 v8; // [sp+824h] [bp-10h]
  __int16 v9; // [sp+826h] [bp-Eh]
  int v10; // [sp+828h] [bp-Ch]
  char v11; // [sp+82Dh] [bp-7h]
  char v12; // [sp+82Eh] [bp-6h]
  char v13; // [sp+82Fh] [bp-5h]

  v13 = 4;
  v12 = 12;
  v7 = 201632341;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v10 = 0;
  v9 = 16;
  v8 = 16;
  v11 = 6;
  if ( sub_6A6A0(a1, (unsigned __int8 *)&v7, 6u, (unsigned __int8 *)&v4, 0xAu) )
  {
    strcpy(v3, "get power run time failed\n");
    sub_41DB8(0, v3, 0);
    return -2147482880;
  }
  else
  {
    return (HIBYTE(v5) << 24) | (BYTE2(v5) << 16) | (BYTE1(v5) << 8) | (unsigned __int8)v5;
  }
}

//----- (0006EB6C) --------------------------------------------------------
int __fastcall sub_6EB6C(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( a1 < 11 )
    return -30;
  if ( a1 > 1527 )
    return 125;
  for ( i = 0; i < 151; ++i )
  {
    if ( a1 >= asc_A5608[2 * i] && a1 < asc_A5608[2 * i + 2] )
      return asc_A5608[2 * i + 1];
  }
  return 125;
}
// A5608: using guessed type __int16 asc_A5608[302];

//----- (0006ECC0) --------------------------------------------------------
int __fastcall sub_6ECC0(int *a1)
{
  char v4[2048]; // [sp+14h] [bp-820h] BYREF
  unsigned __int8 v5[12]; // [sp+814h] [bp-20h] BYREF
  int v6; // [sp+820h] [bp-14h] BYREF
  __int16 v7; // [sp+824h] [bp-10h]
  int v8; // [sp+828h] [bp-Ch]
  int v9; // [sp+82Ch] [bp-8h]

  v9 = 0;
  if ( dword_550AA4 || (v9 = sub_70000(), v9 >= 0) )
  {
    if ( (unsigned int)dword_550AA8 > 0xC0 )
    {
      v8 = dword_550AA0;
      v6 = 151300693;
      v7 = 13;
      if ( sub_6A6A0(dword_550AA0, (unsigned __int8 *)&v6, 6u, v5, 0xCu) )
      {
        strcpy(v4, "get power status failed\n");
        sub_41DB8(0, v4, 0);
        return -2147482880;
      }
      else
      {
        if ( a1 && v5[3] == 9 )
        {
          *a1 = sub_6EB6C(v5[4] | (v5[5] << 8));
          a1[1] = sub_6EB6C(v5[6] | (v5[7] << 8));
          a1[2] = sub_6EB6C(v5[8] | (v5[9] << 8));
        }
        return 0;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_temp");
    sub_41DB8(0, v4, 0);
    return v9;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;
// 550AA8: using guessed type int dword_550AA8;

//----- (0006EEB4) --------------------------------------------------------
void sub_6EEB4()
{
  char v0[4]; // [sp+0h] [bp-814h] BYREF
  double v1; // [sp+800h] [bp-14h]
  int v2; // [sp+80Ch] [bp-8h]

  v2 = 0;
  if ( dword_550AA4 || (v2 = sub_70000(), v2 >= 0) )
  {
    if ( dword_550AA8 == 193 || dword_550AA8 == 194 )
    {
      v1 = 0.200000003;
      v2 = sub_6E97C(dword_550AA0);
      if ( v2 == -2147482880 )
      {
        snprintf(v0, 0x800u, "can't get power running time ret = 0x%x\n", -2147482880);
        sub_41DB8(0, v0, 0);
      }
    }
  }
  else
  {
    snprintf(v0, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_running_time");
    sub_41DB8(0, v0, 0);
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;
// 550AA8: using guessed type int dword_550AA8;

//----- (0006F008) --------------------------------------------------------
void sub_6F008()
{
  ;
}
// 550AA8: using guessed type int dword_550AA8;

//----- (0006F108) --------------------------------------------------------
void sub_6F108()
{
  char v0[2048]; // [sp+4h] [bp-808h] BYREF
  int v1; // [sp+804h] [bp-8h]

  v1 = 0;
  if ( dword_550AA4 || (v1 = sub_70000(), v1 >= 0) )
  {
    if ( sub_6AAC8() )
    {
      v1 = sub_6B7C4();
      if ( !v1 )
      {
        strcpy(v0, "can nont get power status\n");
        sub_41DB8(0, v0, 0);
      }
    }
    else
    {
      v1 = sub_6DA3C(dword_550AA0);
      if ( v1 >= 0 )
      {
        sub_6F008();
      }
      else
      {
        strcpy(v0, "can nont get voltage\n");
        sub_41DB8(0, v0, 0);
      }
    }
  }
  else
  {
    snprintf(v0, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_sample_voltage");
    sub_41DB8(0, v0, 0);
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;
// 550C3C: using guessed type float flt_550C3C;

//----- (0006F2DC) --------------------------------------------------------
int sub_6F2DC()
{
  char v2[2048]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 || (v3 = sub_70000(), v3 >= 0) )
  {
    if ( sub_6AAC8() )
    {
      v3 = sub_6D088(dword_550AA0);
      if ( v3 )
      {
        strcpy(v2, "can nont get power status\n");
        sub_41DB8(0, v2, 0);
        return v3;
      }
    }
    else if ( sub_6AB50() )
    {
      v3 = sub_6E000(dword_550AA0);
    }
    else
    {
      v3 = sub_6DE30(dword_550AA0);
    }
    if ( v3 == -2147482880 )
    {
      strcpy(v2, "can nont get power status\n");
      sub_41DB8(0, v2, 0);
    }
    return v3;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_status");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0006F4B8) --------------------------------------------------------
int sub_6F4B8()
{
  char v2[2048]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 || (v3 = sub_70000(), v3 >= 0) )
  {
    if ( sub_6AAC8() )
    {
      v3 = sub_6D114(dword_550AA0);
      if ( v3 )
      {
        strcpy(v2, "can nont get power status\n");
        sub_41DB8(0, v2, 0);
        return v3;
      }
    }
    else if ( sub_6AB50() )
    {
      v3 = sub_6E000(dword_550AA0);
    }
    else
    {
      v3 = sub_6DE30(dword_550AA0);
    }
    if ( v3 == -2147482880 )
    {
      strcpy(v2, "can nont get power status\n");
      sub_41DB8(0, v2, 0);
    }
    return v3;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_status_1");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0006F694) --------------------------------------------------------
int sub_6F694()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 || (v3 = sub_70000(), v3 >= 0) )
  {
    if ( !sub_6AB50() )
    {
      return -1;
    }
    else
    {
      v3 = sub_6E1F0(dword_550AA0);
      if ( v3 == -2147482880 )
      {
        snprintf(v2, 0x800u, "can nont get history power status; ret = 0x%x\n", -2147482880);
        sub_41DB8(0, v2, 0);
        return -1;
      }
      else
      {
        return v3;
      }
    }
  }
  else
  {
    snprintf(
      v2,
      0x800u,
      "%s: auto exec bitmain_power_open, but open power failed\n",
      "bitmain_get_history_power_status");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0006F7BC) --------------------------------------------------------
__int64 sub_6F7BC()
{
  char v2[12]; // [sp+0h] [bp-80Ch] BYREF
  __int64 v3; // [sp+800h] [bp-Ch]

  v3 = 0;
  if ( dword_550AA4 || (v3 = sub_70000(), v3 >= 0) )
  {
    if ( !sub_6AB50() )
    {
      return -1;
    }
    else
    {
      v3 = sub_6D584(dword_550AA0);
      if ( v3 == 2147484416LL )
      {
        snprintf(v2, 0x800u, "can nont clear power status; ret = 0x%x\n", -2147482880);
        sub_41DB8(0, v2, 0);
        return -1;
      }
      else
      {
        return v3;
      }
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_clear_power_status");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0006F90C) --------------------------------------------------------
int sub_6F90C()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 || (v3 = sub_70000(), v3 >= 0) )
  {
    if ( !sub_6AB50() )
    {
      return -1;
    }
    else
    {
      v3 = sub_6E3E0(dword_550AA0);
      if ( v3 == -2147482880 )
      {
        snprintf(v2, 0x800u, "can nont get power input status; ret = 0x%x\n", -2147482880);
        sub_41DB8(0, v2, 0);
        return -1;
      }
      else
      {
        return v3;
      }
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_input_status");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0006FA34) --------------------------------------------------------
int sub_6FA34()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 || (v3 = sub_70000(), v3 >= 0) )
  {
    v3 = sub_6E5E0(dword_550AA0);
    if ( v3 == -2147482880 )
    {
      snprintf(v2, 0x800u, "can nont get power enable status; ret = 0x%x\n", -2147482880);
      sub_41DB8(0, v2, 0);
      return -1;
    }
    else
    {
      return v3;
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_enable_status");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0006FB3C) --------------------------------------------------------
int sub_6FB3C()
{
  float v0; // s0
  char v3[8]; // [sp+4h] [bp-808h] BYREF
  int v4; // [sp+804h] [bp-8h]

  v4 = 0;
  if ( dword_550AA4 || (v4 = sub_70000(), v4 >= 0) )
  {
    if ( dword_550AA8 == 26 )
    {
      sub_6BAD4();
      v4 = (int)v0;
      if ( (int)v0 )
      {
        return v4;
      }
      else
      {
        snprintf(v3, 0x800u, "can nont get power ret = 0x%x\n", 0);
        sub_41DB8(0, v3, 0);
        return -1;
      }
    }
    else if ( dword_550AA8 == 193 || dword_550AA8 == 194 )
    {
      v4 = sub_6E7AC(dword_550AA0);
      if ( v4 == -2147482880 )
      {
        snprintf(v3, 0x800u, "can nont get power ret = 0x%x\n", -2147482880);
        sub_41DB8(0, v3, 0);
        return -1;
      }
      else
      {
        return v4;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    snprintf(v3, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_miner_power");
    sub_41DB8(0, v3, 0);
    return v4;
  }
}
// 6FBE8: variable 'v0' is possibly undefined
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;
// 550AA8: using guessed type int dword_550AA8;

//----- (0006FCF4) --------------------------------------------------------
int __fastcall sub_6FCF4(char a1)
{
  char v4[2048]; // [sp+Ch] [bp-808h] BYREF
  int v5; // [sp+80Ch] [bp-8h]

  v5 = 0;
  if ( dword_550AA4 || (v5 = sub_70000(), v5 >= 0) )
  {
    if ( sub_6AAC8() )
    {
      if ( a1 == 1 )
        v5 = sub_6CF58(dword_550AA0, 1);
      else
        v5 = sub_6CF58(dword_550AA0, 0);
    }
    else if ( a1 == 1 )
    {
      v5 = sub_6DC10(dword_550AA0, 1u);
    }
    else
    {
      v5 = sub_6DC10(dword_550AA0, 0);
    }
    if ( v5 < 0 )
    {
      strcpy(v4, "can nont set power watchdog\n");
      sub_41DB8(0, v4, 0);
    }
    return v5;
  }
  else
  {
    snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_watchdog");
    sub_41DB8(0, v4, 0);
    return v5;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0006FE94) --------------------------------------------------------
int __fastcall sub_6FE94(_BYTE *a1)
{
  char v4[8]; // [sp+Ch] [bp-808h] BYREF
  int v5; // [sp+80Ch] [bp-8h]

  v5 = 0;
  if ( dword_550AA4 || (v5 = sub_70000(), v5 >= 0) )
  {
    if ( a1 )
      *a1 = byte_550AB0;
    return 0;
  }
  else
  {
    snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_is_calibrated");
    sub_41DB8(0, v4, 0);
    return v5;
  }
}
// 6FF24: conditional instruction was optimized away because %var_4.4>=0
// 550AA4: using guessed type int dword_550AA4;
// 550AB0: using guessed type char byte_550AB0;

//----- (0006FF60) --------------------------------------------------------
const char *sub_6FF60()
{
  char v2; // [sp+7h] [bp-5h] BYREF

  if ( sub_6FE94(&v2) || !v2 )
    return "NOSNGOT0000000000";
  else
    return (const char *)dword_550AB8;
}
// 550AB8: using guessed type _DWORD dword_550AB8[4];

//----- (0006FFB0) --------------------------------------------------------
int sub_6FFB0()
{
  char v2; // [sp+7h] [bp-5h] BYREF

  if ( sub_6FE94(&v2) || !v2 )
    return -1;
  else
    return dword_550C10;
}
// 550C10: using guessed type int dword_550C10;

//----- (00070000) --------------------------------------------------------
int sub_70000()
{
  char v2[2048]; // [sp+0h] [bp-814h] BYREF
  int v3; // [sp+800h] [bp-14h] BYREF
  __int16 v4; // [sp+804h] [bp-10h]
  char v5; // [sp+806h] [bp-Eh]
  char v6; // [sp+807h] [bp-Dh]
  int v7; // [sp+808h] [bp-Ch]
  int v8; // [sp+80Ch] [bp-8h]

  v8 = 0;
  v7 = 0;
  if ( dword_550AA0 && dword_550AA4 )
    return dword_550AA0;
  v3 = 0;
  v4 = 1;
  v5 = 2;
  v6 = 0;
  pthread_mutex_lock(&stru_550A88);
  v8 = sub_73D18((int)&v3);
  pthread_mutex_unlock(&stru_550A88);
  if ( v8 < 0 )
    return v8;
  dword_550AA0 = v8;
  dword_550AA4 = 1;
  v8 = sub_7051C();
  if ( v8 >= 0 )
  {
    dword_550AA8 = v8;
    snprintf(v2, 0x800u, "power open power_version = 0x%x\n", v8);
    sub_41DB8(3, v2, 0);
    if ( dword_550AA8 == 193 || dword_550AA8 == 194 )
    {
      v7 = sub_6C474(dword_550AA0);
      snprintf(v2, 0x800u, "power fw_version = 0x%x\n", v7);
      sub_41DB8(0, v2, 0);
      dword_550AAC = v7;
    }
    memset(dword_550AB8, 0, 0x160u);
    if ( sub_7282C() )
    {
      byte_550AB0 = 0;
      strcpy(v2, "power is not Calibrated\n");
    }
    else
    {
      byte_550AB0 = 1;
      strcpy(v2, "power is Calibrated\n");
    }
    sub_41DB8(1, v2, 0);
    return 0;
  }
  else
  {
    strcpy(v2, "power open power_version < 0 will close power\n");
    sub_41DB8(3, v2, 0);
    sub_702FC();
    return v8;
  }
}
// 550A88: using guessed type pthread_mutex_t stru_550A88;
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;
// 550AA8: using guessed type int dword_550AA8;
// 550AAC: using guessed type int dword_550AAC;
// 550AB0: using guessed type char byte_550AB0;
// 550AB8: using guessed type _DWORD dword_550AB8[4];

//----- (000702FC) --------------------------------------------------------
int sub_702FC()
{
  char v1[2048]; // [sp+0h] [bp-804h] BYREF

  if ( dword_550AA4 )
  {
    pthread_mutex_lock(&stru_550A88);
    strcpy(v1, "bitmain power close ===========\n");
    sub_41DB8(3, v1, 0);
    sub_73FC0(dword_550AA0);
    memset(&dword_550AA0, 0, 0x178u);
    pthread_mutex_unlock(&stru_550A88);
  }
  return 0;
}
// 550A88: using guessed type pthread_mutex_t stru_550A88;
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (000703BC) --------------------------------------------------------
int sub_703BC()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 )
    return sub_6D7FC(dword_550AA0);
  v3 = sub_70000();
  if ( v3 >= 0 )
    return sub_6D7FC(dword_550AA0);
  snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_sw_ver");
  sub_41DB8(0, v2, 0);
  return v3;
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0007046C) --------------------------------------------------------
int sub_7046C()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 )
    return sub_6D880(dword_550AA0);
  v3 = sub_70000();
  if ( v3 >= 0 )
    return sub_6D880(dword_550AA0);
  snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_aging_time");
  sub_41DB8(0, v2, 0);
  return v3;
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (0007051C) --------------------------------------------------------
int sub_7051C()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 || (v3 = sub_70000(), v3 >= 0) )
  {
    v3 = sub_6D988(dword_550AA0);
    if ( v3 > 0 )
      dword_550AA8 = v3;
    return v3;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_version");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 70000: using guessed type int sub_70000(void);
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;
// 550AA8: using guessed type int dword_550AA8;

//----- (000705E8) --------------------------------------------------------
int sub_705E8()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 )
    return sub_6D904(dword_550AA0);
  v3 = sub_70000();
  if ( v3 >= 0 )
    return sub_6D904(dword_550AA0);
  snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_release_date");
  sub_41DB8(0, v2, 0);
  return v3;
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (00070698) --------------------------------------------------------
int sub_70698()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  dword_550AA4 = 0;
  v3 = sub_70000();
  if ( v3 >= 0 )
  {
    v3 = dword_550AA8;
    return dword_550AA8;
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "power_need_open");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 550AA4: using guessed type int dword_550AA4;
// 550AA8: using guessed type int dword_550AA8;

//----- (00070750) --------------------------------------------------------
int sub_70750()
{
  double v0; // d0
  double v2; // d0
  int i; // [sp+1Ch] [bp-8h]

  if ( dword_550ACC <= 1 )
    return -1;
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_550ACC - 1 )
      return -1;
    if ( v0 > *((double *)&unk_550AB8 + i + 23) - 0.001 && v0 < *((double *)&unk_550AB8 + i + 24) + 0.001
      || v0 < *((double *)&unk_550AB8 + i + 23) + 0.001 && v0 > *((double *)&unk_550AB8 + i + 24) - 0.001 )
    {
      break;
    }
  }
  v2 = (v0 - *((double *)&unk_550AB8 + i + 23))
     * ((double)(*((unsigned __int8 *)&unk_550AB8 + i + 25) - *((unsigned __int8 *)&unk_550AB8 + i + 24))
      / (*((double *)&unk_550AB8 + i + 24) - *((double *)&unk_550AB8 + i + 23)))
     + (double)*((unsigned __int8 *)&unk_550AB8 + i + 24);
  round();
  if ( (unsigned int)(int)v2 >= 0x100 )
    return -1;
  else
    return (int)v2;
}
// 707C0: variable 'v0' is possibly undefined
// 1267C: using guessed type int round(void);
// 550ACC: using guessed type int dword_550ACC;

//----- (0007099C) --------------------------------------------------------
void sub_7099C()
{
  int i; // [sp+14h] [bp-10h]

  if ( dword_550ACC > 1 )
  {
    for ( i = 0; i < dword_550ACC - 1; ++i )
      ;
  }
}
// 550ACC: using guessed type int dword_550ACC;

//----- (00070B80) --------------------------------------------------------
int sub_70B80()
{
  char v2[8]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AAC )
    return dword_550AAC;
  if ( dword_550AA4 )
    return sub_6C474(dword_550AA0);
  v3 = sub_70000();
  if ( v3 >= 0 )
    return sub_6C474(dword_550AA0);
  snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_fw_version");
  sub_41DB8(0, v2, 0);
  return v3;
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;
// 550AAC: using guessed type int dword_550AAC;

//----- (00070C58) --------------------------------------------------------
unsigned int sub_70C58()
{
  double v0; // d0
  char v3[2048]; // [sp+4h] [bp-808h] BYREF
  int v4; // [sp+804h] [bp-8h]

  v4 = 0;
  if ( sub_6AAC8() )
    return sub_6B5F0();
  if ( dword_550AA4 || (v4 = sub_70000(), v4 >= 0) )
  {
    v4 = sub_6D1A0(dword_550AA0);
    if ( v4 >= 0 )
    {
      sub_71AF8();
      return (unsigned int)(v0 * 100.0);
    }
    else
    {
      strcpy(v3, "can nont get voltage\n");
      sub_41DB8(0, v3, 0);
      return v4;
    }
  }
  else
  {
    snprintf(v3, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_voltage");
    sub_41DB8(0, v3, 0);
    return v4;
  }
}
// 70D88: variable 'v0' is possibly undefined
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (00070DA8) --------------------------------------------------------
int sub_70DA8()
{
  double v0; // d0
  float v2; // s15
  char v4[12]; // [sp+8h] [bp-80Ch] BYREF
  unsigned int v5; // [sp+808h] [bp-Ch]
  int v6; // [sp+80Ch] [bp-8h]

  v6 = 0;
  if ( sub_6AAC8() )
    return sub_6B418();
  v5 = 0;
  if ( dword_550AA4 || (v6 = sub_70000(), v6 >= 0) )
  {
    v5 = sub_71528();
    if ( v5 < 0x100 )
    {
      v6 = sub_6D36C(dword_550AA0, v5);
      sub_71B58();
      v2 = v0;
      flt_550C3C = v2;
      return v6;
    }
    return -2147482879;
  }
  else
  {
    snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage");
    sub_41DB8(0, v4, 0);
    return v6;
  }
}
// 70ED4: variable 'v0' is possibly undefined
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;
// 550C3C: using guessed type float flt_550C3C;

//----- (00070EF4) --------------------------------------------------------
int __fastcall sub_70EF4(unsigned __int8 a1)
{
  char v4[8]; // [sp+Ch] [bp-808h] BYREF
  int v5; // [sp+80Ch] [bp-8h]

  v5 = 0;
  if ( dword_550AA4 )
    return sub_6D36C(dword_550AA0, a1);
  v5 = sub_70000();
  if ( v5 >= 0 )
    return sub_6D36C(dword_550AA0, a1);
  snprintf(v4, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_set_voltage_by_n");
  sub_41DB8(0, v4, 0);
  return v5;
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (00070FB4) --------------------------------------------------------
int sub_70FB4()
{
  double v0; // d0
  int v2; // [sp+Ch] [bp-8h]

  switch ( dword_550AA8 )
  {
    case 26:
    case 98:
    case 100:
    case 101:
    case 102:
      v2 = (int)(0.0 - v0);
      break;
    case 34:
      v2 = (int)(1215.89444 - v0 * 59.931507);
      break;
    case 65:
      v2 = (int)(765.411764 - v0 * 35.833333);
      break;
    case 66:
      v2 = (int)(765.411764 - v0 * 35.833333);
      break;
    case 67:
      v2 = (int)(933.240365 - v0 * 59.806034);
      break;
    case 97:
      v2 = (int)(1144.50226 - v0 * 52.243589);
      break;
    case 113:
    case 117:
      v2 = (int)(1190.93534 - v0 * 78.742588);
      break;
    case 114:
    case 119:
      v2 = (int)(1190.93534 - v0 * 78.742588);
      break;
    case 115:
    case 120:
      v2 = (int)(1280.57782 - v0 * 73.979365);
      break;
    case 116:
    case 118:
      v2 = (int)(1156.10758 - v0 * 76.090494);
      break;
    case 193:
    case 194:
      if ( dword_550AAC == -2147482880 || (unsigned __int8)dword_550AAC <= 3u )
        v2 = (int)(1275.0 - v0 * 85.0);
      else
        v2 = (int)(1083.75 - v0 * 70.8333333);
      break;
    default:
      v2 = -1;
      break;
  }
  return v2;
}
// 70FEC: control flows out of bounds to 70FF0
// 7129C: variable 'v0' is possibly undefined
// 550AA8: using guessed type int dword_550AA8;
// 550AAC: using guessed type int dword_550AAC;

//----- (00071528) --------------------------------------------------------
int sub_71528()
{
  if ( byte_550AB0 && byte_550C18 )
    return sub_70750();
  else
    return sub_70FB4();
}
// 550AB0: using guessed type char byte_550AB0;
// 550C18: using guessed type char byte_550C18;

//----- (00071588) --------------------------------------------------------
void sub_71588()
{
  ;
}
// 715C8: control flows out of bounds to 715CC
// 550AA8: using guessed type int dword_550AA8;
// 550AAC: using guessed type int dword_550AAC;

//----- (00071AF8) --------------------------------------------------------
void sub_71AF8()
{
  if ( byte_550AB0 && byte_550C18 )
    sub_7099C();
  else
    sub_71588();
}
// 550AB0: using guessed type char byte_550AB0;
// 550C18: using guessed type char byte_550C18;

//----- (00071B58) --------------------------------------------------------
void sub_71B58()
{
  sub_71AF8();
  sub_71588();
}

//----- (00071B98) --------------------------------------------------------
int __fastcall sub_71B98(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  void *v3; // r0
  int v5; // r3
  char v10[2048]; // [sp+14h] [bp-850h] BYREF
  unsigned __int8 s[52]; // [sp+814h] [bp-50h] BYREF
  int v12; // [sp+848h] [bp-1Ch] BYREF
  unsigned __int8 v13; // [sp+84Ch] [bp-18h]
  unsigned __int8 v14; // [sp+84Dh] [bp-17h]
  __int16 v15; // [sp+84Eh] [bp-16h]
  __int16 v16; // [sp+850h] [bp-14h]
  char v17; // [sp+852h] [bp-12h]
  char v18; // [sp+853h] [bp-11h]
  int v19; // [sp+854h] [bp-10h]
  unsigned __int8 i; // [sp+85Bh] [bp-9h]
  int v21; // [sp+85Ch] [bp-8h]

  v21 = 0;
  v18 = 6;
  v17 = 6;
  v12 = 101100117;
  v3 = memset(s, 0, 0x32u);
  v19 = 5;
  v16 = a1 + 12 + a3;
  v13 = a1;
  v14 = a3;
  v15 = v16;
  i = 8;
  if ( dword_550AA4 || (v21 = sub_70000(v3), v21 >= 0) )
  {
    if ( sub_6A6A0(dword_550AA0, (unsigned __int8 *)&v12, 8u, s, a3 + 7) )
    {
      strcpy(v10, "set DA conversion N failed\n");
      sub_41DB8(0, v10, 0);
      return -2147482880;
    }
    else
    {
      for ( i = 0; i < (unsigned int)a3; ++i )
      {
        v5 = v19++;
        *(_BYTE *)(a2 + i) = s[v5];
      }
      return v21;
    }
  }
  else
  {
    snprintf(v10, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_power_read");
    sub_41DB8(0, v10, 0);
    return v21;
  }
}
// 70000: using guessed type int __fastcall sub_70000(_DWORD);
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (00071E8C) --------------------------------------------------------
int __fastcall sub_71E8C(char a1, int a2, unsigned __int8 a3)
{
  int v4; // r3
  char v9[2048]; // [sp+10h] [bp-864h] BYREF
  unsigned __int8 s[72]; // [sp+810h] [bp-64h] BYREF
  int v11; // [sp+858h] [bp-1Ch] BYREF
  char v12; // [sp+85Ch] [bp-18h]
  char v13; // [sp+85Dh] [bp-17h]
  unsigned __int8 v14; // [sp+85Eh] [bp-16h]
  char v15; // [sp+85Fh] [bp-15h]
  __int16 v16; // [sp+860h] [bp-14h]
  int v17; // [sp+864h] [bp-10h]
  unsigned __int16 i; // [sp+868h] [bp-Ch]
  __int16 v19; // [sp+86Ah] [bp-Ah]
  int v20; // [sp+86Ch] [bp-8h]

  if ( a3 <= 0x40u )
  {
    if ( (a1 & 1) != 0 )
    {
      strcpy(v9, "read data should start from even address\n");
      sub_41DB8(3, v9, 0);
      return -1;
    }
    else
    {
      v20 = 0;
      v11 = 101231189;
      v16 = 0;
      memset(s, 0, sizeof(s));
      v19 = 0;
      v17 = 6;
      v12 = a1;
      v13 = 0;
      v14 = a3;
      v15 = 0;
      for ( i = 2; i <= 7u; i += 2 )
      {
        v19 += *((unsigned __int8 *)&v11 + i);
        v19 += *((unsigned __int8 *)&v11 + i + 1) << 8;
      }
      v16 = v19;
      if ( sub_6A874(dword_550AA0, (unsigned __int8 *)&v11, 0xAu, s, a3 + 8) )
        return -1;
      for ( i = 0; i < (unsigned int)a3; ++i )
      {
        v4 = v17++;
        *(_BYTE *)(a2 + i) = s[v4];
      }
      return v20;
    }
  }
  else
  {
    strcpy(v9, "read length should less then 64\n");
    sub_41DB8(3, v9, 0);
    return -1;
  }
}
// 550AA0: using guessed type int dword_550AA0;

//----- (0007211C) --------------------------------------------------------
int __fastcall sub_7211C(char a1, int a2, unsigned __int8 a3)
{
  unsigned int v4; // r12
  int v6; // [sp+8h] [bp-83Ch] BYREF
  char v7; // [sp+Ch] [bp-838h]
  char v8; // [sp+Dh] [bp-837h]
  unsigned __int8 v9; // [sp+Eh] [bp-836h]
  char v10; // [sp+Fh] [bp-835h]
  char v11[2048]; // [sp+14h] [bp-830h] BYREF
  unsigned __int8 v12[12]; // [sp+814h] [bp-30h] BYREF
  unsigned __int8 *v13; // [sp+820h] [bp-24h]
  int v14; // [sp+824h] [bp-20h]
  int v15; // [sp+828h] [bp-1Ch]
  int v16; // [sp+82Ch] [bp-18h]
  int v17; // [sp+830h] [bp-14h]
  __int16 v18; // [sp+834h] [bp-10h]
  unsigned __int16 i; // [sp+836h] [bp-Eh]

  v6 = a2;
  v10 = a1;
  v9 = a3;
  if ( a3 <= 0x40u )
  {
    if ( (v10 & 1) != 0 )
    {
      strcpy(v11, "write data should start from even address\n");
      sub_41DB8(3, v11, 0);
      return -1;
    }
    else
    {
      v17 = 0;
      v18 = 0;
      v16 = 6;
      v15 = v9 + 8;
      v4 = v15;
      v14 = v9 + 7;
      v13 = (unsigned __int8 *)&v6;
      LOWORD(v6) = -21931;
      BYTE2(v6) = v9 + 6;
      HIBYTE(v6) = -122;
      v7 = v10;
      v8 = 0;
      for ( i = 0; i < (unsigned int)v9; ++i )
        v13[i + 6] = *(_BYTE *)(v6 + i);
      for ( i = 2; i < v4 - 2; i += 2 )
      {
        v18 += v13[i];
        v18 += v13[i + 1] << 8;
      }
      v13[v4 - 2] = v18;
      v13[v4 - 1] = HIBYTE(v18);
      if ( sub_6A874(dword_550AA0, v13, v4, v12, v9 + 8) )
      {
        v17 = -1;
        return -1;
      }
      else if ( v12[6] && v12[7] )
      {
        strcpy(v11, "write data to power register 0x86 success\n");
        sub_41DB8(3, v11, 0);
        return -1;
      }
      else
      {
        strcpy(v11, "write data to power register 0x86 success\n");
        sub_41DB8(3, v11, 0);
        return 0;
      }
    }
  }
  else
  {
    strcpy(v11, "write length should less then 64\n");
    sub_41DB8(3, v11, 0);
    return -1;
  }
}
// 550AA0: using guessed type int dword_550AA0;

//----- (00072544) --------------------------------------------------------
int __fastcall sub_72544(int a1, unsigned int a2, unsigned __int64 a3, int a4)
{
  int v5; // r2
  unsigned __int64 v6; // r0
  int v9; // [sp+8h] [bp-5Ch]
  _DWORD v11[17]; // [sp+14h] [bp-50h] BYREF
  unsigned int j; // [sp+58h] [bp-Ch]
  unsigned int i; // [sp+5Ch] [bp-8h]

  v9 = a2;
  memset(v11, 0, 65);
  if ( a4 <= 1 || (unsigned int)a4 > 0x24 || !a2 )
    return 0;
  if ( a2 > 0x41 )
    v9 = 65;
  for ( i = 0; i < v9 - 1; ++i )
  {
    sub_96DFC(a3, a4);
    *((_BYTE *)v11 + i) = a0123456789abcd[v5];
    LODWORD(v6) = sub_96DFC(a3, a4);
    a3 = v6;
  }
  if ( a3 )
    return 0;
  for ( j = 0; j < v9 - 1; ++j )
    *(_BYTE *)(a1 + j) = *((_BYTE *)v11 + v9 - j - 2);
  *(_BYTE *)(a1 + v9 - 1) = 0;
  return 1;
}
// 725E8: variable 'v5' is possibly undefined
// 72620: variable 'v6' is possibly undefined

//----- (000726D8) --------------------------------------------------------
int __fastcall sub_726D8(unsigned __int16 a1)
{
  if ( a1 == 113 )
    return 64;
  if ( a1 > 0x71u )
  {
    if ( a1 > 0x78u )
    {
      if ( (unsigned int)a1 - 193 <= 1 )
        return 0;
      return (unsigned __int8)-1;
    }
    if ( a1 < 0x75u && a1 != 115 )
      return (unsigned __int8)-1;
    return 64;
  }
  if ( a1 == 98 )
    return 0;
  if ( a1 > 0x62u )
  {
    if ( (unsigned int)a1 - 100 <= 2 )
      return 0;
    return (unsigned __int8)-1;
  }
  if ( a1 != 26 )
  {
    if ( a1 != 65 )
      return (unsigned __int8)-1;
    return 64;
  }
  return 0;
}

//----- (0007279C) --------------------------------------------------------
int __fastcall sub_7279C(_DWORD *a1, int *a2)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r1
  int v7; // r2
  int v8; // r3

  if ( *a2 <= 31 || !a1 )
    return 0;
  v3 = unk_550C20;
  v4 = unk_550C24;
  v5 = unk_550C28;
  *a1 = unk_550C1C;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  v6 = unk_550C30;
  v7 = unk_550C34;
  v8 = unk_550C38;
  a1[4] = unk_550C2C;
  a1[5] = v6;
  a1[6] = v7;
  a1[7] = v8;
  *a2 = 32;
  return 1;
}

//----- (0007282C) --------------------------------------------------------
int sub_7282C()
{
  double v0; // d0
  __int64 v2; // r0
  char v4[2048]; // [sp+10h] [bp-894h] BYREF
  int v5; // [sp+810h] [bp-94h] BYREF
  int v6; // [sp+814h] [bp-90h]
  int v7; // [sp+818h] [bp-8Ch] BYREF
  int v8; // [sp+81Ch] [bp-88h]
  __int16 v9; // [sp+820h] [bp-84h]
  unsigned int v10; // [sp+824h] [bp-80h]
  __int64 dest; // [sp+828h] [bp-7Ch] BYREF
  _DWORD src[2]; // [sp+834h] [bp-70h] BYREF
  unsigned int v13; // [sp+83Ch] [bp-68h]
  _DWORD v14[4]; // [sp+840h] [bp-64h] BYREF
  int v15; // [sp+850h] [bp-54h]
  double *v16; // [sp+854h] [bp-50h]
  char *v17; // [sp+858h] [bp-4Ch]
  unsigned int v18; // [sp+85Ch] [bp-48h]
  unsigned int v19; // [sp+860h] [bp-44h]
  unsigned int v20; // [sp+864h] [bp-40h]
  unsigned __int16 v21; // [sp+86Ah] [bp-3Ah]
  unsigned int v22; // [sp+86Ch] [bp-38h]
  __int64 v23; // [sp+870h] [bp-34h]
  char v24; // [sp+87Dh] [bp-27h]
  __int16 v25; // [sp+87Eh] [bp-26h]
  __int16 v26; // [sp+880h] [bp-24h]
  unsigned __int8 v27; // [sp+883h] [bp-21h]
  unsigned int m; // [sp+884h] [bp-20h]
  unsigned int k; // [sp+888h] [bp-1Ch]
  int v30; // [sp+88Ch] [bp-18h]
  unsigned int j; // [sp+890h] [bp-14h]
  unsigned int i; // [sp+894h] [bp-10h]

  v27 = sub_726D8(dword_550AA8);
  if ( v27 == 255 )
    return -1;
  if ( sub_6AAC8() )
  {
    if ( sub_71E8C(v27, (int)src, 0x20u) )
      return -1;
  }
  else if ( sub_71B98(v27, (int)src, 0x20u) )
  {
    return -1;
  }
  unk_550C1C = src[0];
  unk_550C20 = src[1];
  unk_550C24 = v13;
  unk_550C28 = v14[0];
  unk_550C2C = v14[1];
  unk_550C30 = v14[2];
  unk_550C34 = v14[3];
  unk_550C38 = v15;
  strcpy(v4, "power calibration data:");
  sub_41DB8(0, v4, 0);
  for ( i = 0; (int)i <= 31; i += 4 )
  {
    snprintf(
      v4,
      0x800u,
      "%2X %2X %2X %2X  ",
      LOBYTE(src[i / 4]),
      BYTE1(src[i / 4]),
      BYTE2(src[i / 4]),
      HIBYTE(src[i / 4]));
    sub_41DB8(0, v4, 0);
  }
  v26 = (BYTE2(v15) << 8) + HIBYTE(v15);
  v25 = sub_69F84(src, 30);
  if ( v26 == v25 )
  {
    v24 = src[0];
    if ( (src[0] & 0xFE) == 2 )
      v24 = 2;
    memcpy(&dest, src, sizeof(dest));
    v10 = v13;
    LODWORD(v2) = sub_69F40(dest, HIDWORD(dest));
    dest = v2;
    v10 = sub_69F18(v10);
    v23 = dest & 0x1FFFFFFFFFFFFFFLL;
    v22 = v10;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    sub_72544((int)&v5, 0xCu, dest & 0x1FFFFFFFFFFFFFFLL, 36);
    sub_72544((int)&v7 + 3, 7u, v22, 36);
    dword_550AB8[0] = v5;
    dword_550AB8[1] = v6;
    dword_550AB8[2] = v7;
    dword_550AB8[3] = v8;
    word_550AC8 = v9;
    v21 = ((unsigned __int8)v15 << 8) + BYTE1(v15);
    v20 = v21 / 0x174u;
    v19 = v21 / 0x1Fu % 0xC + 1;
    v18 = v21 % 0x1Fu + 1;
    dword_550C10 = 10000 * v20 + 100 * v19 + v18;
    v17 = (char *)v14 + 2;
    for ( j = 0; j <= 0xD && v17[j] != -128; ++j )
      ;
    v16 = (double *)dword_550AB8;
    dword_550ACC = j + 1;
    v30 = (__int16)((LOBYTE(v14[0]) << 8) + BYTE1(v14[0]));
    if ( sub_6AAC8() )
    {
      if ( (unsigned __int8)sub_6A120((int)(v16 + 3), *((_DWORD *)v16 + 5)) != 1 )
        return -1;
      v16[23] = v16[3] + (double)v30 / 1000.0;
      for ( k = 0; k < j; ++k )
      {
        v30 += v17[k];
        v16[k + 24] = v16[k + 4] + (double)v30 / 1000.0;
      }
    }
    else
    {
      if ( (unsigned __int8)sub_6A04C((int)(v16 + 3), *((_DWORD *)v16 + 5)) != 1 )
        return -1;
      sub_71588();
      v16[23] = v0 + (double)v30 / 1000.0;
      for ( m = 0; m < j; ++m )
      {
        v30 += v17[m];
        sub_71588();
        v16[m + 24] = v0 + (double)v30 / 1000.0;
      }
    }
    return 0;
  }
  strcpy(v4, "calibration data crc err");
  sub_41DB8(0, v4, 0);
  return -1;
}
// 72AF4: variable 'v2' is possibly undefined
// 72EA0: variable 'v0' is possibly undefined
// 550AA8: using guessed type int dword_550AA8;
// 550AB8: using guessed type _DWORD dword_550AB8[4];
// 550AC8: using guessed type __int16 word_550AC8;
// 550ACC: using guessed type int dword_550ACC;
// 550C10: using guessed type int dword_550C10;

//----- (00072F64) --------------------------------------------------------
int sub_72F64()
{
  char v2[2048]; // [sp+4h] [bp-808h] BYREF
  int v3; // [sp+804h] [bp-8h]

  v3 = 0;
  if ( dword_550AA4 || (v3 = sub_70000(), v3 >= 0) )
  {
    if ( sub_6AAC8() && (v3 = sub_6CED8(dword_550AA0)) != 0 )
    {
      strcpy(v2, "can nont get power temp and fan speed\n");
      sub_41DB8(0, v2, 0);
      return v3;
    }
    else
    {
      if ( v3 == -2147482880 )
      {
        strcpy(v2, "can nont get power temp and fan speed\n");
        sub_41DB8(0, v2, 0);
      }
      return v3;
    }
  }
  else
  {
    snprintf(v2, 0x800u, "%s: auto exec bitmain_power_open, but open power failed\n", "bitmain_get_power_temp_fanspeed");
    sub_41DB8(0, v2, 0);
    return v3;
  }
}
// 550AA0: using guessed type int dword_550AA0;
// 550AA4: using guessed type int dword_550AA4;

//----- (00073114) --------------------------------------------------------
int sub_73114()
{
  return sub_6B7C4();
}

//----- (0007312C) --------------------------------------------------------
int sub_7312C()
{
  return sub_6B9B4();
}

//----- (00073144) --------------------------------------------------------
int sub_73144()
{
  return sub_6BAD4();
}

//----- (0007315C) --------------------------------------------------------
int __fastcall sub_7315C(char a1, char a2)
{
  return sub_6BC40(a1, a2);
}

//----- (000731A0) --------------------------------------------------------
int __fastcall sub_731A0(char a1, void *a2)
{
  return sub_6BE3C(a1, a2);
}

//----- (000731D8) --------------------------------------------------------
int sub_731D8()
{
  return sub_6C344();
}

//----- (000731F0) --------------------------------------------------------
int sub_731F0()
{
  return sub_6C224();
}

//----- (00073208) --------------------------------------------------------
char __fastcall sub_73208(char result)
{
  byte_550C18 = result;
  return result;
}
// 550C18: using guessed type char byte_550C18;

//----- (0007323C) --------------------------------------------------------
int __fastcall sub_7323C(unsigned int a1, int a2, unsigned __int8 a3)
{
  int v4; // r1
  char v9[8]; // [sp+1Ch] [bp-818h] BYREF
  unsigned int v10; // [sp+81Ch] [bp-18h] BYREF
  __int16 v11; // [sp+820h] [bp-14h]
  char v12; // [sp+822h] [bp-12h]
  char v13; // [sp+823h] [bp-11h]
  int v14; // [sp+824h] [bp-10h]
  int v15; // [sp+828h] [bp-Ch]
  unsigned __int8 i; // [sp+82Fh] [bp-5h]

  v15 = -2147482111;
  if ( a1 <= 0xF )
  {
    if ( a3 <= 7u )
    {
      for ( i = 0; i < (unsigned int)a3; ++i )
      {
        v14 = sub_73BD0(a1, *(_BYTE *)(a2 + i));
        if ( v14 == -2147482112 )
        {
          v10 = a1;
          v11 = 0;
          v12 = ((*(unsigned __int8 *)(a2 + i) + a1) >> 3) & 0xF;
          v13 = (*(_BYTE *)(a2 + i) + a1) & 7;
          v15 = sub_73D18((int)&v10);
          if ( v15 < 0 )
          {
            snprintf(
              v9,
              0x800u,
              " open T-sensor error, chain is %d,slave addr is %d\n",
              a1,
              *(unsigned __int8 *)(a2 + i));
            sub_41DB8(0, v9, 0);
            return v15;
          }
          v4 = byte_550C44[68 * a1];
          byte_550C44[68 * a1] = v4 + 1;
          v14 = v4;
          byte_550C44[68 * a1 + 4 + 8 * v4] = *(_BYTE *)(a2 + i);
          *(_DWORD *)&byte_550C44[68 * a1 + 8 + 8 * v14] = v15;
        }
      }
      return 0;
    }
    else
    {
      snprintf(v9, 0x800u, " Bad T-sensor param, input num is %d\n", a3);
      sub_41DB8(0, v9, 0);
      return -2147482111;
    }
  }
  else
  {
    snprintf(v9, 0x800u, " Bad T-sensor param, input chain is %d\n", a1);
    sub_41DB8(0, v9, 0);
    return -2147482111;
  }
}
// 550C44: using guessed type unsigned __int8 byte_550C44[1088];

//----- (00073530) --------------------------------------------------------
int __fastcall sub_73530(unsigned int a1)
{
  char v4[8]; // [sp+Ch] [bp-808h] BYREF
  unsigned __int8 i; // [sp+80Fh] [bp-5h]

  if ( a1 <= 0xF )
  {
    for ( i = 0; i < (unsigned int)byte_550C44[68 * a1]; ++i )
    {
      if ( *(_DWORD *)&byte_550C44[68 * a1 + 8 + 8 * i] )
        sub_73FC0(*(_DWORD *)&byte_550C44[68 * a1 + 8 + 8 * i]);
    }
    memset(&byte_550C44[68 * a1], 0, 0x44u);
    return 0;
  }
  else
  {
    snprintf(v4, 0x800u, " Bad T-sensor param, input chain is %d\n", a1);
    sub_41DB8(0, v4, 0);
    return -2147482111;
  }
}
// 550C44: using guessed type unsigned __int8 byte_550C44[1088];

//----- (00073694) --------------------------------------------------------
int __fastcall sub_73694(unsigned int a1, unsigned __int8 a2, char a3, int a4, unsigned int a5)
{
  unsigned __int8 v9; // [sp+13h] [bp-821h] BYREF
  unsigned int v10; // [sp+14h] [bp-820h]
  char v11[8]; // [sp+1Ch] [bp-818h] BYREF
  unsigned __int8 v12; // [sp+81Fh] [bp-15h] BYREF
  int v13; // [sp+820h] [bp-14h]
  int v14; // [sp+824h] [bp-10h]
  int v15; // [sp+828h] [bp-Ch]
  unsigned int i; // [sp+82Ch] [bp-8h]

  v10 = a1;
  v9 = a2;
  v14 = 0;
  i = 0;
  v13 = 0;
  if ( a1 <= 0xF )
  {
    v15 = sub_73BD0(v10, v9);
    if ( v15 == -2147482112
      && ((v14 = sub_7323C(v10, (int)&v9, 1u), v14 < 0) || (v15 = sub_73BD0(v10, v9), v15 == -2147482112)) )
    {
      snprintf(v11, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed\n", v10, v9);
      sub_41DB8(0, v11, 0);
      return v14;
    }
    else
    {
      for ( i = 0; a5 > i; ++i )
      {
        v12 = i + a3;
        v14 = sub_7427C(*(_DWORD *)&byte_550C44[68 * v10 + 8 + 8 * v15], &v12, 1, a4 + i, 1u, 1);
        if ( v14 != 1 )
        {
          snprintf(v11, 0x800u, "fail to write tsensor by iic, chain:%d, slave: %d, addr: %d", v10, v9, v12);
          sub_41DB8(0, v11, 0);
          return -2147482112;
        }
      }
      return a5;
    }
  }
  else
  {
    snprintf(v11, 0x800u, " Bad T-sensor param, input chain is %d\n", v10);
    sub_41DB8(0, v11, 0);
    return -2147482111;
  }
}
// 550C44: using guessed type unsigned __int8 byte_550C44[1088];

//----- (00073954) --------------------------------------------------------
int __fastcall sub_73954(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, int a4, unsigned int a5)
{
  unsigned __int8 v8; // [sp+12h] [bp-81Ah] BYREF
  unsigned __int8 v9; // [sp+13h] [bp-819h] BYREF
  unsigned int v10; // [sp+14h] [bp-818h]
  char v11[16]; // [sp+1Ch] [bp-810h] BYREF
  int v12; // [sp+81Ch] [bp-10h]
  int v13; // [sp+820h] [bp-Ch]
  int v14; // [sp+824h] [bp-8h]

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v13 = 0;
  v12 = 0;
  if ( a1 <= 0xF )
  {
    v14 = sub_73BD0(v10, v9);
    if ( v14 == -2147482112
      && ((v13 = sub_7323C(v10, (int)&v9, 1u), v13 < 0) || (v14 = sub_73BD0(v10, v9), v14 == -2147482112)) )
    {
      snprintf(v11, 0x800u, " auto exec tsensor_open, but chain %d,slave_addr %d open failed\n", v10, v9);
      sub_41DB8(0, v11, 0);
      return v13;
    }
    else
    {
      v13 = sub_741B4(*(_DWORD *)&byte_550C44[68 * v10 + 8 + 8 * v14], &v8, 2, a4, a5, 1);
      if ( a5 == v13 )
      {
        return v13;
      }
      else
      {
        snprintf(v11, 0x800u, "fail to read tsensor by iic, chain: %d, slave: %d, addr: %d\n", v10, v9, v8);
        sub_41DB8(0, v11, 0);
        return -2147482112;
      }
    }
  }
  else
  {
    snprintf(v11, 0x800u, " Bad T-sensor param, input chain is %d\n", v10);
    sub_41DB8(0, v11, 0);
    return -2147482111;
  }
}
// 550C44: using guessed type unsigned __int8 byte_550C44[1088];

//----- (00073BD0) --------------------------------------------------------
int __fastcall sub_73BD0(unsigned int a1, unsigned __int8 a2)
{
  char v4[8]; // [sp+Ch] [bp-808h] BYREF
  unsigned __int8 i; // [sp+80Fh] [bp-5h]

  if ( a1 <= 0xF )
  {
    if ( byte_550C44[68 * a1] )
    {
      for ( i = 0; i < (unsigned int)byte_550C44[68 * a1]; ++i )
      {
        if ( a2 == byte_550C44[68 * a1 + 4 + 8 * i] )
          return i;
      }
      return -2147482112;
    }
    else
    {
      return -2147482112;
    }
  }
  else
  {
    snprintf(v4, 0x800u, " Bad T-sensor param, input chain is %d\n", a1);
    sub_41DB8(0, v4, 0);
    return -2147482111;
  }
}
// 550C44: using guessed type unsigned __int8 byte_550C44[1088];

//----- (00073D18) --------------------------------------------------------
int __fastcall sub_73D18(int a1)
{
  char v4[2048]; // [sp+8h] [bp-80Ch] BYREF
  int v5; // [sp+808h] [bp-Ch]
  int v6; // [sp+80Ch] [bp-8h]

  v6 = -1;
  v5 = 0;
  if ( pthread_mutex_lock(&stru_551084) )
  {
    strcpy(v4, "failed to iic lock\n");
    sub_41DB8(0, v4, 0);
    return -4;
  }
  else
  {
    if ( a1 )
    {
      v5 = sub_7437C();
      if ( v5 >= 0 )
      {
        if ( sub_75608(v5, *(unsigned __int16 *)(a1 + 4)) )
        {
          strcpy(v4, "failed to i2c_select\n");
          sub_41DB8(0, v4, 0);
          v6 = -1;
        }
        else
        {
          if ( !sub_75468(v5, 1795, (16 * *(unsigned __int8 *)(a1 + 6)) | (2 * *(unsigned __int8 *)(a1 + 7))) )
          {
            pthread_mutex_unlock(&stru_551084);
            return v5;
          }
          strcpy(v4, "failed to i2c_ioctl\n");
          sub_41DB8(0, v4, 0);
          v6 = -1;
        }
      }
      else
      {
        strcpy(v4, "failed to i2c_init\n");
        sub_41DB8(0, v4, 0);
        v6 = -1;
      }
    }
    else
    {
      strcpy(v4, "bad param\n");
      sub_41DB8(0, v4, 0);
      v6 = -3;
    }
    if ( v5 > 0 )
      sub_744B8(v5);
    pthread_mutex_unlock(&stru_551084);
    return v6;
  }
}
// 551084: using guessed type pthread_mutex_t stru_551084;

//----- (00073FC0) --------------------------------------------------------
int __fastcall sub_73FC0(int a1)
{
  char v3[2048]; // [sp+Ch] [bp-808h] BYREF
  int v4; // [sp+80Ch] [bp-8h]

  v4 = 0;
  if ( pthread_mutex_lock(&stru_551084) )
  {
    strcpy(v3, "failed to i2c lock\n");
    return sub_41DB8(0, v3, 0);
  }
  else
  {
    sub_744B8(a1);
    return pthread_mutex_unlock(&stru_551084);
  }
}
// 551084: using guessed type pthread_mutex_t stru_551084;

//----- (0007405C) --------------------------------------------------------
int __fastcall sub_7405C(int a1, int a2, unsigned int a3)
{
  int v6; // [sp+4h] [bp-810h]
  char v9[2048]; // [sp+10h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_551084) )
  {
    strcpy(v9, "failed to i2c lock\n");
    sub_41DB8(0, v9, 0);
    return -4;
  }
  else
  {
    v6 = sub_74780(a1, a2, a3);
    pthread_mutex_unlock(&stru_551084);
    return v6;
  }
}
// 551084: using guessed type pthread_mutex_t stru_551084;

//----- (00074108) --------------------------------------------------------
int __fastcall sub_74108(int a1, int a2, unsigned int a3)
{
  int v6; // [sp+4h] [bp-810h]
  char v9[2048]; // [sp+10h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_551084) )
  {
    strcpy(v9, "failed to i2c lock\n");
    sub_41DB8(0, v9, 0);
    return -4;
  }
  else
  {
    v6 = sub_74A58(a1, a2, a3);
    pthread_mutex_unlock(&stru_551084);
    return v6;
  }
}
// 551084: using guessed type pthread_mutex_t stru_551084;

//----- (000741B4) --------------------------------------------------------
int __fastcall sub_741B4(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5, char a6)
{
  char v12[2048]; // [sp+18h] [bp-804h] BYREF
  int v13; // [sp+820h] [bp+4h]

  if ( pthread_mutex_lock(&stru_551084) )
  {
    strcpy(v12, "failed to i2c lock\n");
    sub_41DB8(0, v12, 0);
    return -4;
  }
  else
  {
    v13 = sub_74D44(a1, a2, a3, a4, a5, a6);
    pthread_mutex_unlock(&stru_551084);
    return v13;
  }
}
// 551084: using guessed type pthread_mutex_t stru_551084;

//----- (0007427C) --------------------------------------------------------
int __fastcall sub_7427C(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5, char a6)
{
  char v12[2048]; // [sp+18h] [bp-804h] BYREF
  int v13; // [sp+820h] [bp+4h]

  if ( pthread_mutex_lock(&stru_551084) )
  {
    strcpy(v12, "failed to i2c lock\n");
    sub_41DB8(0, v12, 0);
    return -4;
  }
  else
  {
    v13 = sub_750D0(a1, a2, a3, a4, a5, a6);
    pthread_mutex_unlock(&stru_551084);
    return v13;
  }
}
// 551084: using guessed type pthread_mutex_t stru_551084;

//----- (00074344) --------------------------------------------------------
int __fastcall sub_74344(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0007437C) --------------------------------------------------------
int sub_7437C()
{
  char v2[2048]; // [sp+14h] [bp-810h] BYREF
  _DWORD v3[2]; // [sp+814h] [bp-10h] BYREF
  int v4; // [sp+81Ch] [bp-8h] BYREF

  v4 = -1;
  if ( dword_550478 )
  {
    if ( !dword_5510B8 )
    {
      dword_5510B4 = (int)sub_5FDE8(475972, 0, 0);
      pthread_mutex_init(&stru_55109C, 0);
    }
    v4 = ++dword_5510B8;
    v3[0] = 0;
    v3[1] = 0;
    sub_5FE68((int *)dword_5510B4, &v4, 4u, v3, 8u);
    return v4;
  }
  else
  {
    strcpy(v2, "please init platform first!!\n");
    sub_41DB8(0, v2, 0);
    return -2;
  }
}
// 550478: using guessed type int dword_550478;
// 55109C: using guessed type pthread_mutex_t stru_55109C;
// 5510B4: using guessed type int dword_5510B4;
// 5510B8: using guessed type int dword_5510B8;

//----- (000744B8) --------------------------------------------------------
int __fastcall sub_744B8(int a1)
{
  int result; // r0
  _DWORD v2[2]; // [sp+4h] [bp-818h] BYREF
  char v3[2048]; // [sp+Ch] [bp-810h] BYREF
  _DWORD *v4; // [sp+80Ch] [bp-10h]
  int i; // [sp+810h] [bp-Ch]
  int v6; // [sp+814h] [bp-8h]

  v2[0] = a1;
  v6 = 0;
  if ( pthread_mutex_lock(&stru_55109C) )
  {
    strcpy(v3, "failed to i2c lock\n");
    return sub_41DB8(0, v3, 0);
  }
  else
  {
    if ( sub_5FEC8((int *)dword_5510B4, (int)v2) )
    {
      sub_5FF34((int *)dword_5510B4, (int)v2);
    }
    else
    {
      snprintf(v3, 0x800u, "ctx(%d) is not inited\n", v2[0]);
      sub_41DB8(1, v3, 0);
    }
    v4 = sub_6027C(dword_5510B4);
    for ( i = ((int (__fastcall *)(_DWORD *))*v4)(v4); i; i = ((int (__fastcall *)(_DWORD *))*v4)(v4) )
      ++v6;
    sub_60300(v4);
    result = pthread_mutex_unlock(&stru_55109C);
    if ( !v6 )
    {
      dword_5510B8 = 0;
      result = sub_60084((void ***)dword_5510B4);
      dword_5510B4 = 0;
    }
  }
  return result;
}
// 55109C: using guessed type pthread_mutex_t stru_55109C;
// 5510B4: using guessed type int dword_5510B4;
// 5510B8: using guessed type int dword_5510B8;

//----- (0007468C) --------------------------------------------------------
int sub_7468C()
{
  unsigned int v1; // r3
  unsigned int v3; // [sp+0h] [bp-Ch] BYREF
  unsigned int v4; // [sp+4h] [bp-8h]

  v3 = 0;
  v4 = 0;
  do
  {
    sub_5A800(12, &v3);
    if ( v3 >> 31 == 1 )
      return 1;
    usleep(0x1388u);
    v1 = v4++;
  }
  while ( v1 < 0x258 );
  return 0;
}

//----- (000746FC) --------------------------------------------------------
int __fastcall sub_746FC(_BYTE *a1)
{
  unsigned int v2; // r3
  unsigned int v5; // [sp+8h] [bp-Ch] BYREF
  unsigned int v6; // [sp+Ch] [bp-8h]

  v5 = 0;
  v6 = 0;
  do
  {
    sub_5A800(12, &v5);
    if ( v5 >> 30 == 2 )
    {
      *a1 = v5;
      return 1;
    }
    usleep(0x1388u);
    v2 = v6++;
  }
  while ( v2 < 0x258 );
  return 0;
}

//----- (00074780) --------------------------------------------------------
int __fastcall sub_74780(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+Ch] [bp-818h] BYREF
  char v8[2048]; // [sp+10h] [bp-814h] BYREF
  void *ptr[2]; // [sp+810h] [bp-14h] BYREF
  int v10; // [sp+818h] [bp-Ch]
  unsigned int i; // [sp+81Ch] [bp-8h]

  v7 = a1;
  i = 0;
  if ( pthread_mutex_lock(&stru_55109C) )
  {
    strcpy(v8, "failed to i2c lock\n");
    sub_41DB8(0, v8, 0);
    return -1;
  }
  else
  {
    v10 = 0;
    ptr[0] = 0;
    if ( sub_60008((int *)dword_5510B4, (int)&v7, ptr) == 1 )
    {
      ptr[1] = ptr[0];
      v10 = (*(_DWORD *)ptr[0] << 26)
          | (*((_DWORD *)ptr[0] + 1) >> 4 << 20)
          | (*((_DWORD *)ptr[0] + 1) >> 1 << 16) & 0x70000
          | 0x2080000;
      for ( i = 0; i < a3; ++i )
      {
        if ( !sub_7468C() )
        {
          free(ptr[0]);
          strcpy(v8, "iic not ready 4 read1\n");
          sub_41DB8(0, v8, 0);
          pthread_mutex_unlock(&stru_55109C);
          return -2;
        }
        sub_5A87C(12, v10);
        usleep(0xC350u);
        if ( !sub_746FC((_BYTE *)(a2 + i)) )
        {
          free(ptr[0]);
          strcpy(v8, "iic not ready 4 read2\n");
          sub_41DB8(0, v8, 0);
          pthread_mutex_unlock(&stru_55109C);
          return -3;
        }
      }
      free(ptr[0]);
      usleep(0x2710u);
      pthread_mutex_unlock(&stru_55109C);
      return a3;
    }
    else
    {
      snprintf(v8, 0x800u, "ctx %d not inited\n", v7);
      sub_41DB8(0, v8, 0);
      pthread_mutex_unlock(&stru_55109C);
      return -2;
    }
  }
}
// 55109C: using guessed type pthread_mutex_t stru_55109C;
// 5510B4: using guessed type int dword_5510B4;

//----- (00074A58) --------------------------------------------------------
int __fastcall sub_74A58(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+Ch] [bp-820h] BYREF
  char v8[2048]; // [sp+14h] [bp-818h] BYREF
  void *ptr; // [sp+814h] [bp-18h] BYREF
  char v10; // [sp+81Bh] [bp-11h] BYREF
  _DWORD *v11; // [sp+81Ch] [bp-10h]
  int v12; // [sp+820h] [bp-Ch]
  unsigned int i; // [sp+824h] [bp-8h]

  v7 = a1;
  i = 0;
  if ( pthread_mutex_lock(&stru_55109C) )
  {
    strcpy(v8, "failed to i2c lock\n");
    sub_41DB8(0, v8, 0);
    return -1;
  }
  else
  {
    v12 = 0;
    ptr = 0;
    if ( sub_60008((int *)dword_5510B4, (int)&v7, &ptr) == 1 )
    {
      v11 = ptr;
      for ( i = 0; i < a3; ++i )
      {
        v12 = (*v11 << 26) | (v11[1] >> 4 << 20) | (v11[1] >> 1 << 16) & 0x70000 | *(unsigned __int8 *)(a2 + i);
        if ( !sub_7468C() )
        {
          free(ptr);
          strcpy(v8, "iic not ready 4 write\n");
          sub_41DB8(0, v8, 0);
          pthread_mutex_unlock(&stru_55109C);
          return -2;
        }
        sub_5A87C(12, v12);
        usleep(0x2710u);
        if ( !sub_746FC(&v10) )
        {
          strcpy(v8, "iic write failed\n");
          sub_41DB8(0, v8, 0);
          free(ptr);
          pthread_mutex_unlock(&stru_55109C);
          return -3;
        }
      }
      free(ptr);
      usleep(0x2710u);
      pthread_mutex_unlock(&stru_55109C);
      return a3;
    }
    else
    {
      snprintf(v8, 0x800u, "ctx %d not inited\n", v7);
      sub_41DB8(0, v8, 0);
      pthread_mutex_unlock(&stru_55109C);
      return -2;
    }
  }
}
// 55109C: using guessed type pthread_mutex_t stru_55109C;
// 5510B4: using guessed type int dword_5510B4;

//----- (00074D44) --------------------------------------------------------
int __fastcall sub_74D44(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5, char a6)
{
  int v11; // [sp+Ch] [bp-818h] BYREF
  char v12[2048]; // [sp+10h] [bp-814h] BYREF
  void *ptr; // [sp+810h] [bp-14h] BYREF
  _DWORD *v14; // [sp+814h] [bp-10h]
  int v15; // [sp+818h] [bp-Ch]
  unsigned int i; // [sp+81Ch] [bp-8h]

  v11 = a1;
  i = 0;
  if ( a3 == 1 || a3 == 2 )
  {
    if ( pthread_mutex_lock(&stru_55109C) )
    {
      strcpy(v12, "failed to i2c lock\n");
      sub_41DB8(0, v12, 0);
      return -1;
    }
    else
    {
      v15 = 0;
      ptr = 0;
      if ( sub_60008((int *)dword_5510B4, (int)&v11, &ptr) == 1 )
      {
        v14 = ptr;
        for ( i = 0; i < a5; i += a3 )
        {
          if ( a3 == 2 )
            v15 = (*v14 << 26) | (v14[1] >> 4 << 20) | (v14[1] >> 1 << 16) & 0x70000 | 0x2000000;
          else
            v15 = (*v14 << 26) | (v14[1] >> 4 << 20) | (v14[1] >> 1 << 16) & 0x70000 | 0x2080000;
          if ( a6 )
            v15 |= ((*a2 + i) << 8) | 0x1000000;
          if ( !sub_7468C() )
          {
            strcpy(v12, "iic not ready 4 read1\n");
            sub_41DB8(0, v12, 0);
            free(ptr);
            pthread_mutex_unlock(&stru_55109C);
            return -2;
          }
          sub_5A87C(12, v15);
          usleep(0x2710u);
          if ( !sub_746FC((_BYTE *)(a4 + i)) )
          {
            free(ptr);
            pthread_mutex_unlock(&stru_55109C);
            return -3;
          }
          ++i;
        }
        free(ptr);
        usleep(0x2710u);
        pthread_mutex_unlock(&stru_55109C);
        return a5;
      }
      else
      {
        snprintf(v12, 0x800u, "ctx %d not inited\n", v11);
        sub_41DB8(0, v12, 0);
        pthread_mutex_unlock(&stru_55109C);
        return -2;
      }
    }
  }
  else
  {
    strcpy(v12, "more than two byte reg data len is not supported\n");
    sub_41DB8(0, v12, 0);
    return -3;
  }
}
// 55109C: using guessed type pthread_mutex_t stru_55109C;
// 5510B4: using guessed type int dword_5510B4;

//----- (000750D0) --------------------------------------------------------
int __fastcall sub_750D0(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5, char a6)
{
  int v10; // [sp+Ch] [bp-820h] BYREF
  char v11[2048]; // [sp+14h] [bp-818h] BYREF
  void *ptr; // [sp+814h] [bp-18h] BYREF
  char v13; // [sp+81Bh] [bp-11h] BYREF
  _DWORD *v14; // [sp+81Ch] [bp-10h]
  int v15; // [sp+820h] [bp-Ch]
  unsigned int i; // [sp+824h] [bp-8h]

  v10 = a1;
  i = 0;
  if ( a3 == 1 )
  {
    if ( pthread_mutex_lock(&stru_55109C) )
    {
      strcpy(v11, "failed to i2c lock\n");
      sub_41DB8(0, v11, 0);
      return -1;
    }
    else
    {
      v15 = 0;
      ptr = 0;
      if ( sub_60008((int *)dword_5510B4, (int)&v10, &ptr) == 1 )
      {
        v14 = ptr;
        for ( i = 0; i < a5; ++i )
        {
          v15 = (*v14 << 26) | (v14[1] >> 4 << 20) | (v14[1] >> 1 << 16) & 0x70000 | *(unsigned __int8 *)(a4 + i);
          if ( a6 )
            v15 |= ((*a2 + i) << 8) | 0x1000000;
          if ( !sub_7468C() )
          {
            strcpy(v11, "iic not ready 4 write\n");
            sub_41DB8(0, v11, 0);
            free(ptr);
            pthread_mutex_unlock(&stru_55109C);
            return -2;
          }
          sub_5A87C(12, v15);
          usleep(0x2710u);
          if ( !sub_746FC(&v13) )
          {
            strcpy(v11, "iic write reg failed\n");
            sub_41DB8(0, v11, 0);
            free(ptr);
            pthread_mutex_unlock(&stru_55109C);
            return -3;
          }
        }
        free(ptr);
        usleep(0x2710u);
        pthread_mutex_unlock(&stru_55109C);
        return a5;
      }
      else
      {
        snprintf(v11, 0x800u, "ctx %d not inited\n", v10);
        sub_41DB8(0, v11, 0);
        pthread_mutex_unlock(&stru_55109C);
        return -2;
      }
    }
  }
  else
  {
    strcpy(v11, "more than one byte reg address is not supported\n");
    sub_41DB8(0, v11, 0);
    return -3;
  }
}
// 55109C: using guessed type pthread_mutex_t stru_55109C;
// 5510B4: using guessed type int dword_5510B4;

//----- (00075468) --------------------------------------------------------
int __fastcall sub_75468(int a1, __int16 a2, int a3)
{
  char v8[2048]; // [sp+10h] [bp-81Ch] BYREF
  _DWORD v9[2]; // [sp+810h] [bp-1Ch] BYREF
  void *ptr; // [sp+818h] [bp-14h]
  int v11; // [sp+81Ch] [bp-10h]
  _DWORD *v12; // [sp+820h] [bp-Ch]
  int i; // [sp+824h] [bp-8h]

  if ( pthread_mutex_lock(&stru_55109C) )
  {
    strcpy(v8, "failed to i2c lock\n");
    sub_41DB8(0, v8, 0);
    return -4;
  }
  else
  {
    v12 = sub_6027C(dword_5510B4);
    for ( i = ((int (__fastcall *)(_DWORD *))*v12)(v12); i; i = ((int (__fastcall *)(_DWORD *))*v12)(v12) )
    {
      v11 = v12[5];
      if ( ***(_DWORD ***)(v11 + 16) == a1 )
      {
        ptr = (void *)((int (__fastcall *)(int))v12[2])(i);
        if ( a2 == 1795 )
        {
          v9[0] = *(_DWORD *)ptr;
          v9[1] = a3;
          ((void (__fastcall *)(_DWORD *, _DWORD *, int))v12[1])(v12, v9, 8);
          free(ptr);
        }
        break;
      }
    }
    sub_60300(v12);
    pthread_mutex_unlock(&stru_55109C);
    return 0;
  }
}
// 55109C: using guessed type pthread_mutex_t stru_55109C;
// 5510B4: using guessed type int dword_5510B4;

//----- (00075608) --------------------------------------------------------
int __fastcall sub_75608(int a1, int a2)
{
  char v6[2048]; // [sp+8h] [bp-81Ch] BYREF
  _DWORD v7[2]; // [sp+808h] [bp-1Ch] BYREF
  void *ptr; // [sp+810h] [bp-14h]
  int v9; // [sp+814h] [bp-10h]
  _DWORD *v10; // [sp+818h] [bp-Ch]
  int i; // [sp+81Ch] [bp-8h]

  if ( pthread_mutex_lock(&stru_55109C) )
  {
    strcpy(v6, "failed to i2c lock\n");
    sub_41DB8(0, v6, 0);
    return -4;
  }
  else
  {
    v10 = sub_6027C(dword_5510B4);
    for ( i = ((int (__fastcall *)(_DWORD *))*v10)(v10); i; i = ((int (__fastcall *)(_DWORD *))*v10)(v10) )
    {
      v9 = v10[5];
      if ( ***(_DWORD ***)(v9 + 16) == a1 )
      {
        ptr = (void *)((int (__fastcall *)(int))v10[2])(i);
        v7[0] = a2;
        v7[1] = *((_DWORD *)ptr + 1);
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v10[1])(v10, v7, 8);
        free(ptr);
        break;
      }
    }
    sub_60300(v10);
    pthread_mutex_unlock(&stru_55109C);
    return 0;
  }
}
// 55109C: using guessed type pthread_mutex_t stru_55109C;
// 5510B4: using guessed type int dword_5510B4;

//----- (00075770) --------------------------------------------------------
int __fastcall sub_75770(const void *a1, size_t a2, int a3)
{
  return sub_7B35C(a3, a1, a2);
}

//----- (000757A8) --------------------------------------------------------
int __fastcall sub_757A8(const void *a1, size_t a2, _DWORD *a3)
{
  if ( a3[1] + a2 <= *a3 )
    memcpy((void *)(a3[2] + a3[1]), a1, a2);
  a3[1] += a2;
  return 0;
}

//----- (00075834) --------------------------------------------------------
int __fastcall sub_75834(const void *a1, size_t a2, FILE *a3)
{
  if ( fwrite(a1, a2, 1u, a3) == 1 )
    return 0;
  else
    return -1;
}

//----- (0007588C) --------------------------------------------------------
int __fastcall sub_7588C(const void *a1, size_t a2, int *a3)
{
  if ( write(*a3, a1, a2) == a2 )
    return 0;
  else
    return -1;
}

//----- (000758EC) --------------------------------------------------------
int __fastcall sub_758EC(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  int v6; // r3
  int v9; // [sp+14h] [bp-10h]
  unsigned int v10; // [sp+1Ch] [bp-8h]

  if ( (a1 & 0x1F) == 0 )
  {
    if ( a3 && (a1 & 0x20) == 0 )
      return a4(" ", 1, a5);
    return 0;
  }
  v10 = a2 * (a1 & 0x1F);
  if ( !a4("\n", 1, a5) )
  {
    while ( v10 )
    {
      v6 = v10;
      if ( v10 >= 0x20 )
        v6 = 32;
      v9 = v6;
      if ( a4("                                ", v6, a5) )
        return -1;
      v10 -= v9;
    }
    return 0;
  }
  return -1;
}

//----- (00075A0C) --------------------------------------------------------
int __fastcall sub_75A0C(
        unsigned __int8 *a1,
        int a2,
        int (__fastcall *a3)(unsigned __int8 *, int, int),
        int a4,
        __int16 a5)
{
  char s[16]; // [sp+18h] [bp-34h] BYREF
  int v12; // [sp+28h] [bp-24h] BYREF
  int v13; // [sp+2Ch] [bp-20h]
  int v14; // [sp+30h] [bp-1Ch]
  unsigned __int8 *v15; // [sp+34h] [bp-18h]
  int v16; // [sp+38h] [bp-14h]
  char *v17; // [sp+3Ch] [bp-10h]
  unsigned __int8 *v18; // [sp+40h] [bp-Ch]
  unsigned __int8 *v19; // [sp+44h] [bp-8h]

  v12 = 0;
  if ( !a3("\"", 1, a4) )
  {
    v19 = a1;
    v18 = a1;
    v15 = &a1[a2];
    while ( 1 )
    {
      while ( v18 < v15 )
      {
        v18 = sub_7BDE8(v19, v15 - v19, &v12);
        if ( !v18 )
          return -1;
        if ( v12 == 92 || v12 == 34 || v12 <= 31 || (a5 & 0x400) != 0 && v12 == 47 || (a5 & 0x40) != 0 && v12 > 127 )
          break;
        v19 = v18;
      }
      if ( v19 != a1 && a3(a1, v19 - a1, a4) )
        return -1;
      if ( v18 == v19 )
        return a3("\"", 1, a4);
      v16 = 2;
      if ( v12 == 12 )
      {
        v17 = "\\f";
        goto LABEL_44;
      }
      if ( v12 > 12 )
      {
        if ( v12 == 34 )
        {
          v17 = "\\\"";
          goto LABEL_44;
        }
        if ( v12 > 34 )
        {
          if ( v12 == 47 )
          {
            v17 = "\\/";
            goto LABEL_44;
          }
          if ( v12 == 92 )
          {
            v17 = "\\\\";
            goto LABEL_44;
          }
        }
        else if ( v12 == 13 )
        {
          v17 = "\\r";
          goto LABEL_44;
        }
      }
      else
      {
        switch ( v12 )
        {
          case 9:
            v17 = "\\t";
            goto LABEL_44;
          case 10:
            v17 = "\\n";
            goto LABEL_44;
          case 8:
            v17 = "\\b";
            goto LABEL_44;
        }
      }
      if ( v12 >= 0x10000 )
      {
        v12 -= 0x10000;
        v14 = (v12 >> 10) & 0x3FF | 0xD800;
        v13 = v12 & 0x3FF | 0xDC00;
        snprintf(s, 0xDu, "\\u%04X\\u%04X", v14, v13);
        v16 = 12;
      }
      else
      {
        snprintf(s, 0xDu, "\\u%04X", v12);
        v16 = 6;
      }
      v17 = s;
LABEL_44:
      if ( a3((unsigned __int8 *)v17, v16, a4) )
        return -1;
      v19 = v18;
      a1 = v18;
    }
  }
  return -1;
}

//----- (00075D74) --------------------------------------------------------
int __fastcall sub_75D74(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (00075DB4) --------------------------------------------------------
int __fastcall sub_75DB4(_DWORD *a1, const void *a2, char *a3, size_t a4)
{
  void *v5; // r0

  snprintf(a3, a4, "%p", a2);
  if ( sub_78328((int)a1, a3) )
    return -1;
  v5 = sub_7E39C();
  return sub_78148(a1, a3, (int)v5);
}

//----- (00075E30) --------------------------------------------------------
int __fastcall sub_75E30(_DWORD *a1, int a2, int a3, _DWORD *a4, int (__fastcall *a5)(const char *, int, int), int a6)
{
  double v6; // d0
  __int64 v8; // r0
  unsigned __int8 *v9; // r4
  int v10; // r0
  int v11; // r0
  int *v12; // r4
  size_t v13; // r0
  size_t v14; // r0
  int v15; // r0
  unsigned int v19; // [sp+10h] [bp-D4h]
  char s[100]; // [sp+18h] [bp-CCh] BYREF
  char v22[12]; // [sp+7Ch] [bp-68h] BYREF
  char v23[12]; // [sp+88h] [bp-5Ch] BYREF
  int v24; // [sp+94h] [bp-50h]
  char *v25; // [sp+98h] [bp-4Ch]
  void *base; // [sp+9Ch] [bp-48h]
  size_t nmemb; // [sp+A0h] [bp-44h]
  char *v28; // [sp+A4h] [bp-40h]
  int v29; // [sp+A8h] [bp-3Ch]
  unsigned int v30; // [sp+ACh] [bp-38h]
  unsigned int v31; // [sp+B0h] [bp-34h]
  int v32; // [sp+B4h] [bp-30h]
  double v33; // [sp+B8h] [bp-2Ch]
  int v34; // [sp+C0h] [bp-24h]
  size_t i; // [sp+C4h] [bp-20h]
  int v36; // [sp+C8h] [bp-1Ch]
  const char *v37; // [sp+CCh] [bp-18h]
  int v38; // [sp+D0h] [bp-14h]
  unsigned int j; // [sp+D4h] [bp-10h]

  v34 = a2 & 0x10000;
  v19 = a2 & 0xFFFEFFFF;
  if ( a1 )
  {
    switch ( *a1 )
    {
      case 0:
        if ( (a2 & 0x20) != 0 )
        {
          v37 = ":";
          v36 = 1;
        }
        else
        {
          v37 = ": ";
          v36 = 2;
        }
        if ( sub_75DB4(a4, a1, v22, 0xBu) )
          return -1;
        v38 = sub_7C7C0(a1);
        if ( !v34 && a5("{", 1, a6) )
          return -1;
        if ( v38 )
        {
          if ( sub_758EC(v19, a3 + 1, 0, a5, a6) )
            return -1;
          if ( (v19 & 0x80) == 0 )
          {
            while ( 1 )
            {
              if ( !v38 )
                goto LABEL_86;
              v29 = sub_7C88C(a1, v38);
              v28 = (char *)sub_7C8FC(v38);
              v14 = strlen(v28);
              sub_75A0C((unsigned __int8 *)v28, v14, (int (__fastcall *)(unsigned __int8 *, int, int))a5, a6, v19);
              if ( a5(v37, v36, a6) )
                return -1;
              v15 = sub_7C938(v38);
              if ( sub_75E30(v15, v19, a3 + 1, a4, a5, a6) )
                return -1;
              if ( v29 )
              {
                if ( a5(",", 1, a6) || sub_758EC(v19, a3 + 1, 1, a5, a6) )
                  return -1;
              }
              else if ( sub_758EC(v19, a3, 0, a5, a6) )
              {
                return -1;
              }
              v38 = v29;
            }
          }
          nmemb = sub_7C1FC(a1);
          base = sub_7AFCC(4 * nmemb);
          if ( !base )
            return -1;
          i = 0;
          while ( v38 )
          {
            v12 = (int *)((char *)base + 4 * i);
            *v12 = sub_7C8FC(v38);
            v38 = sub_7C88C(a1, v38);
            ++i;
          }
          if ( i != nmemb )
            _assert_fail("i == size", "dump.c", 0x160u, "do_dump");
          qsort(base, nmemb, 4u, (__compar_fn_t)sub_75D74);
          for ( i = 0; i < nmemb; ++i )
          {
            v25 = (char *)*((_DWORD *)base + i);
            v24 = sub_7C250(a1, v25);
            if ( !v24 )
              _assert_fail("value", "dump.c", 0x16Bu, "do_dump");
            v13 = strlen(v25);
            sub_75A0C((unsigned __int8 *)v25, v13, (int (__fastcall *)(unsigned __int8 *, int, int))a5, a6, v19);
            if ( a5(v37, v36, a6) || sub_75E30(v24, v19, a3 + 1, a4, a5, a6) )
            {
LABEL_71:
              sub_7B014(base);
              return -1;
            }
            if ( i >= nmemb - 1 )
            {
              if ( sub_758EC(v19, a3, 0, a5, a6) )
                goto LABEL_71;
            }
            else if ( a5(",", 1, a6) || sub_758EC(v19, a3 + 1, 1, a5, a6) )
            {
              goto LABEL_71;
            }
          }
          sub_7B014(base);
LABEL_86:
          sub_783D4(a4, v22);
          if ( v34 )
            return 0;
        }
        else
        {
          sub_783D4(a4, v22);
          if ( v34 )
            return 0;
        }
        return a5("}", 1, a6);
      case 1:
        if ( sub_75DB4(a4, a1, v23, 0xBu) )
          return -1;
        v30 = sub_7CD9C(a1);
        if ( !v34 && a5("[", 1, a6) )
          return -1;
        if ( v30 )
        {
          if ( sub_758EC(v19, a3 + 1, 0, a5, a6) )
            return -1;
          for ( j = 0; j < v30; ++j )
          {
            v11 = sub_7CDE8(a1, j);
            if ( sub_75E30(v11, v19, a3 + 1, a4, a5, a6) )
              return -1;
            if ( j >= v30 - 1 )
            {
              if ( sub_758EC(v19, a3, 0, a5, a6) )
                return -1;
            }
            else if ( a5(",", 1, a6) || sub_758EC(v19, a3 + 1, 1, a5, a6) )
            {
              return -1;
            }
          }
          sub_783D4(a4, v23);
          if ( v34 )
            return 0;
        }
        else
        {
          sub_783D4(a4, v23);
          if ( v34 )
            return 0;
        }
        return a5("]", 1, a6);
      case 2:
        v9 = (unsigned __int8 *)sub_7DA40(a1);
        v10 = sub_7DA8C(a1);
        return sub_75A0C(v9, v10, (int (__fastcall *)(unsigned __int8 *, int, int))a5, a6, v19);
      case 3:
        v8 = sub_7DF10((int)a1);
        v31 = snprintf(s, 0x64u, "%lld", v8);
        if ( v31 < 0x64 )
          return a5(s, v31, a6);
        else
          return -1;
      case 4:
        sub_7E120();
        v33 = v6;
        v32 = sub_7B740(s, 0x64u, (unsigned __int16)v19 >> 11);
        if ( v32 >= 0 )
          return a5(s, v32, a6);
        else
          return -1;
      case 5:
        return a5("true", 4, a6);
      case 6:
        return a5("false", 5, a6);
      case 7:
        return a5("null", 4, a6);
      default:
        return -1;
    }
  }
  return -1;
}
// 75E88: control flows out of bounds to 75E8C
// 75F7C: variable 'v6' is possibly undefined

//----- (000767AC) --------------------------------------------------------
void *__fastcall sub_767AC(_DWORD *a1, int a2)
{
  const char *v3; // r0
  void *v7[3]; // [sp+8h] [bp-14h] BYREF
  void *v8; // [sp+14h] [bp-8h]

  if ( sub_7B1A4(v7) )
    return 0;
  if ( sub_769B8(a1, (int (__fastcall *)(const char *, int, int))sub_75770, (int)v7, a2) )
  {
    v8 = 0;
  }
  else
  {
    v3 = (const char *)sub_7B2BC((int)v7);
    v8 = sub_7B054(v3);
  }
  sub_7B220((int)v7);
  return v8;
}
// 75770: using guessed type int sub_75770();

//----- (00076848) --------------------------------------------------------
int __fastcall sub_76848(_DWORD *a1, int a2, int a3, int a4)
{
  int v6; // [sp+14h] [bp-10h] BYREF
  int v7; // [sp+18h] [bp-Ch]
  int v8; // [sp+1Ch] [bp-8h]

  v6 = a3;
  v7 = 0;
  v8 = a2;
  if ( sub_769B8(a1, (int (__fastcall *)(const char *, int, int))sub_757A8, (int)&v6, a4) )
    return 0;
  else
    return v7;
}

//----- (000768B8) --------------------------------------------------------
int __fastcall sub_768B8(_DWORD *a1, int a2, int a3)
{
  return sub_769B8(a1, (int (__fastcall *)(const char *, int, int))sub_75834, a2, a3);
}

//----- (000768F8) --------------------------------------------------------
int __fastcall sub_768F8(_DWORD *a1, int a2, int a3)
{
  _DWORD v4[2]; // [sp+8h] [bp-Ch] BYREF

  v4[1] = a1;
  v4[0] = a2;
  return sub_769B8(a1, (int (__fastcall *)(const char *, int, int))sub_7588C, (int)v4, a3);
}

//----- (00076938) --------------------------------------------------------
int __fastcall sub_76938(_DWORD *a1, const char *a2, int a3)
{
  int v7; // [sp+10h] [bp-Ch]
  FILE *stream; // [sp+14h] [bp-8h]

  stream = fopen(a2, "w");
  if ( !stream )
    return -1;
  v7 = sub_768B8(a1, (int)stream, a3);
  if ( fclose(stream) )
    return -1;
  else
    return v7;
}

//----- (000769B8) --------------------------------------------------------
int __fastcall sub_769B8(_DWORD *a1, int (__fastcall *a2)(const char *, int, int), int a3, int a4)
{
  _DWORD v10[7]; // [sp+18h] [bp-24h] BYREF
  int v11; // [sp+34h] [bp-8h]

  if ( (a4 & 0x200) == 0 && (!a1 || *a1 != 1) && (!a1 || *a1) )
    return -1;
  if ( sub_78010(v10) )
    return -1;
  v11 = sub_75E30(a1, a4, 0, v10, a2, a3);
  sub_78114((int)v10);
  return v11;
}

//----- (00076A8C) --------------------------------------------------------
int __fastcall sub_76A8C(int result)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( result && *(_DWORD *)(result + 4) != -1 )
  {
    v1 = (unsigned int *)(result + 4);
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      return sub_7E3BC(result);
  }
  return result;
}
// 7E3BC: using guessed type int __fastcall sub_7E3BC(_DWORD);

//----- (00076AF4) --------------------------------------------------------
int __fastcall sub_76AF4(unsigned __int8 *a1, unsigned int a2, int a3)
{
  int v3; // r3
  unsigned int v5; // [sp+8h] [bp-2Ch]
  unsigned __int8 *v6; // [sp+18h] [bp-1Ch]
  unsigned __int16 *v7; // [sp+1Ch] [bp-18h]
  _DWORD *v8; // [sp+20h] [bp-14h]
  int v9; // [sp+24h] [bp-10h]
  int v10; // [sp+24h] [bp-10h]
  int v11; // [sp+24h] [bp-10h]
  int v12; // [sp+24h] [bp-10h]
  int v13; // [sp+24h] [bp-10h]
  int v14; // [sp+24h] [bp-10h]
  int v15; // [sp+24h] [bp-10h]
  int v16; // [sp+24h] [bp-10h]
  int v17; // [sp+24h] [bp-10h]
  int v18; // [sp+24h] [bp-10h]
  int v19; // [sp+24h] [bp-10h]
  int v20; // [sp+24h] [bp-10h]
  int v21; // [sp+24h] [bp-10h]
  int v22; // [sp+24h] [bp-10h]
  int v23; // [sp+24h] [bp-10h]
  int v24; // [sp+28h] [bp-Ch]
  int v25; // [sp+28h] [bp-Ch]
  int v26; // [sp+28h] [bp-Ch]
  int v27; // [sp+28h] [bp-Ch]
  int v28; // [sp+28h] [bp-Ch]
  int v29; // [sp+28h] [bp-Ch]
  int v30; // [sp+28h] [bp-Ch]
  int v31; // [sp+28h] [bp-Ch]
  int v32; // [sp+28h] [bp-Ch]
  int v33; // [sp+28h] [bp-Ch]
  int v34; // [sp+28h] [bp-Ch]
  int v35; // [sp+28h] [bp-Ch]
  int v36; // [sp+28h] [bp-Ch]
  int v37; // [sp+28h] [bp-Ch]
  int v38; // [sp+28h] [bp-Ch]
  int v39; // [sp+2Ch] [bp-8h]
  int v40; // [sp+2Ch] [bp-8h]
  int v41; // [sp+2Ch] [bp-8h]
  int v42; // [sp+2Ch] [bp-8h]
  int v43; // [sp+2Ch] [bp-8h]
  int v44; // [sp+2Ch] [bp-8h]
  int v45; // [sp+2Ch] [bp-8h]
  int v46; // [sp+2Ch] [bp-8h]
  int v47; // [sp+2Ch] [bp-8h]
  int v48; // [sp+2Ch] [bp-8h]
  int v49; // [sp+2Ch] [bp-8h]
  int v50; // [sp+2Ch] [bp-8h]
  int v51; // [sp+2Ch] [bp-8h]

  v5 = a2;
  v9 = a2 + a3 - 559038737;
  v24 = v9;
  v39 = v9;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( ((unsigned __int8)a1 & 1) != 0 )
    {
      v6 = a1;
      while ( v5 > 0xC )
      {
        v33 = v24 + v6[4] + (v6[5] << 8) + (v6[6] << 16) + (v6[7] << 24);
        v18 = v9 + v6[8] + (v6[9] << 8) + (v6[10] << 16) + (v6[11] << 24);
        v47 = __ROR4__(v18, 28) ^ (v39 + *v6 + (v6[1] << 8) + (v6[2] << 16) + (v6[3] << 24) - v18);
        v19 = v18 + v33;
        v34 = __ROR4__(v47, 26) ^ (v33 - v47);
        v48 = v47 + v19;
        v20 = __ROR4__(v34, 24) ^ (v19 - v34);
        v35 = v34 + v48;
        v49 = __ROR4__(v20, 16) ^ (v48 - v20);
        v21 = v20 + v35;
        v36 = __ROR4__(v49, 13) ^ (v35 - v49);
        v39 = v49 + v21;
        v9 = __ROR4__(v36, 28) ^ (v21 - v36);
        v24 = v36 + v39;
        v5 -= 12;
        v6 += 12;
      }
      switch ( v5 )
      {
        case 0u:
          return v9;
        case 1u:
          goto LABEL_52;
        case 2u:
          goto LABEL_51;
        case 3u:
          goto LABEL_50;
        case 4u:
          goto LABEL_49;
        case 5u:
          goto LABEL_48;
        case 6u:
          goto LABEL_47;
        case 7u:
          goto LABEL_46;
        case 8u:
          goto LABEL_45;
        case 9u:
          goto LABEL_44;
        case 0xAu:
          goto LABEL_43;
        case 0xBu:
          goto LABEL_42;
        case 0xCu:
          v9 += v6[11] << 24;
LABEL_42:
          v9 += v6[10] << 16;
LABEL_43:
          v9 += v6[9] << 8;
LABEL_44:
          v9 += v6[8];
LABEL_45:
          v24 += v6[7] << 24;
LABEL_46:
          v24 += v6[6] << 16;
LABEL_47:
          v24 += v6[5] << 8;
LABEL_48:
          v24 += v6[4];
LABEL_49:
          v39 += v6[3] << 24;
LABEL_50:
          v39 += v6[2] << 16;
LABEL_51:
          v39 += v6[1] << 8;
LABEL_52:
          v43 = v39 + *v6;
          break;
      }
    }
    else
    {
      v7 = (unsigned __int16 *)a1;
      while ( v5 > 0xC )
      {
        v29 = v24 + v7[2] + (v7[3] << 16);
        v14 = v9 + v7[4] + (v7[5] << 16);
        v44 = __ROR4__(v14, 28) ^ (v39 + *v7 + (v7[1] << 16) - v14);
        v15 = v14 + v29;
        v30 = __ROR4__(v44, 26) ^ (v29 - v44);
        v45 = v44 + v15;
        v16 = __ROR4__(v30, 24) ^ (v15 - v30);
        v31 = v30 + v45;
        v46 = __ROR4__(v16, 16) ^ (v45 - v16);
        v17 = v16 + v31;
        v32 = __ROR4__(v46, 13) ^ (v31 - v46);
        v39 = v46 + v17;
        v9 = __ROR4__(v32, 28) ^ (v17 - v32);
        v24 = v32 + v39;
        v5 -= 12;
        v7 += 6;
      }
      switch ( v5 )
      {
        case 0u:
          return v9;
        case 1u:
          v43 = v39 + *(unsigned __int8 *)v7;
          break;
        case 2u:
          goto LABEL_34;
        case 3u:
          v39 += *((unsigned __int8 *)v7 + 2) << 16;
LABEL_34:
          v43 = v39 + *v7;
          break;
        case 4u:
          goto LABEL_32;
        case 5u:
          v24 += *((unsigned __int8 *)v7 + 4);
LABEL_32:
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
        case 6u:
          goto LABEL_30;
        case 7u:
          v24 += *((unsigned __int8 *)v7 + 6) << 16;
LABEL_30:
          v24 += v7[2];
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
        case 8u:
          goto LABEL_28;
        case 9u:
          v9 += *((unsigned __int8 *)v7 + 8);
LABEL_28:
          v24 += v7[2] + (v7[3] << 16);
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
        case 0xAu:
          goto LABEL_26;
        case 0xBu:
          v9 += *((unsigned __int8 *)v7 + 10) << 16;
LABEL_26:
          v9 += v7[4];
          v24 += v7[2] + (v7[3] << 16);
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
        case 0xCu:
          v9 += v7[4] + (v7[5] << 16);
          v24 += v7[2] + (v7[3] << 16);
          v43 = v39 + *v7 + (v7[1] << 16);
          break;
      }
    }
LABEL_54:
    v22 = (v24 ^ v9) - __ROR4__(v24, 18);
    v50 = (v22 ^ v43) - __ROR4__(v22, 21);
    v37 = (v50 ^ v24) - __ROR4__(v50, 7);
    v23 = (v37 ^ v22) - __ROR4__(v37, 16);
    v51 = (v23 ^ v50) - __ROR4__(v23, 28);
    v38 = (v51 ^ v37) - __ROR4__(v51, 18);
    return (v38 ^ v23) - __ROR4__(v38, 8);
  }
  else
  {
    v8 = a1;
    while ( v5 > 0xC )
    {
      v25 = v24 + v8[1];
      v10 = v9 + v8[2];
      v40 = __ROR4__(v10, 28) ^ (v39 + *v8 - v10);
      v11 = v10 + v25;
      v26 = __ROR4__(v40, 26) ^ (v25 - v40);
      v41 = v40 + v11;
      v12 = __ROR4__(v26, 24) ^ (v11 - v26);
      v27 = v26 + v41;
      v42 = __ROR4__(v12, 16) ^ (v41 - v12);
      v13 = v12 + v27;
      v28 = __ROR4__(v42, 13) ^ (v27 - v42);
      v39 = v42 + v13;
      v9 = __ROR4__(v28, 28) ^ (v13 - v28);
      v24 = v28 + v39;
      v5 -= 12;
      v8 += 3;
    }
    switch ( v5 )
    {
      case 0u:
        v3 = v9;
        break;
      case 1u:
        v43 = v39 + (unsigned __int8)*v8;
        goto LABEL_54;
      case 2u:
        v43 = v39 + (unsigned __int16)*v8;
        goto LABEL_54;
      case 3u:
        v43 = v39 + (*v8 & 0xFFFFFF);
        goto LABEL_54;
      case 4u:
        v43 = v39 + *v8;
        goto LABEL_54;
      case 5u:
        v24 += (unsigned __int8)v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 6u:
        v24 += (unsigned __int16)v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 7u:
        v24 += v8[1] & 0xFFFFFF;
        v43 = v39 + *v8;
        goto LABEL_54;
      case 8u:
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 9u:
        v9 += (unsigned __int8)v8[2];
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 0xAu:
        v9 += (unsigned __int16)v8[2];
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 0xBu:
        v9 += v8[2] & 0xFFFFFF;
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
      case 0xCu:
        v9 += v8[2];
        v24 += v8[1];
        v43 = v39 + *v8;
        goto LABEL_54;
    }
  }
  return v3;
}
// 76D08: control flows out of bounds to 76D0C
// 771C4: control flows out of bounds to 771C8
// 77770: control flows out of bounds to 77774
// 76D04: the default case was optimized away because %var_2C.4<Du
// 771C0: the default case was optimized away because %var_2C.4<Du
// 7776C: the default case was optimized away because %var_2C.4<Du

//----- (00077A10) --------------------------------------------------------
_DWORD *__fastcall sub_77A10(_DWORD *result)
{
  result[1] = result;
  *result = result;
  return result;
}

//----- (00077A48) --------------------------------------------------------
int __fastcall sub_77A48(int result, _DWORD *a2)
{
  a2[1] = result;
  *a2 = *(_DWORD *)result;
  *(_DWORD *)(*(_DWORD *)result + 4) = a2;
  *(_DWORD *)result = a2;
  return result;
}

//----- (00077AA4) --------------------------------------------------------
_DWORD *__fastcall sub_77AA4(_DWORD *result)
{
  *(_DWORD *)(*result + 4) = result[1];
  *(_DWORD *)result[1] = *result;
  return result;
}

//----- (00077AEC) --------------------------------------------------------
bool __fastcall sub_77AEC(int a1, _DWORD *a2)
{
  return *a2 == a1 + 12 && *a2 == a2[1];
}

//----- (00077B4C) --------------------------------------------------------
int __fastcall sub_77B4C(int a1, int *a2, _DWORD *a3)
{
  int result; // r0

  if ( sub_77AEC(a1, a2) )
  {
    result = sub_77A48(a1 + 12, a3);
    a2[1] = (int)a3;
    *a2 = a2[1];
  }
  else
  {
    result = sub_77A48(*a2, a3);
    *a2 = (int)a3;
  }
  return result;
}

//----- (00077BDC) --------------------------------------------------------
int __fastcall sub_77BDC(int a1, int *a2, const char *a3, int a4)
{
  int i; // [sp+14h] [bp-8h]

  if ( sub_77AEC(a1, a2) )
    return 0;
  for ( i = *a2; ; i = *(_DWORD *)(i + 4) )
  {
    if ( a4 == *(_DWORD *)(i + 16) && !strcmp((const char *)(i + 24), a3) )
      return i;
    if ( i == a2[1] )
      break;
  }
  return 0;
}

//----- (00077CA0) --------------------------------------------------------
int __fastcall sub_77CA0(_DWORD *a1, const char *a2, int a3)
{
  int *v6; // [sp+14h] [bp-10h]
  int *v7; // [sp+18h] [bp-Ch]

  v7 = (int *)(a1[1] + 8 * (((1 << a1[2]) - 1) & a3));
  v6 = (int *)sub_77BDC((int)a1, v7, a2, a3);
  if ( !v6 )
    return -1;
  if ( v6 == (int *)*v7 && v6 == (int *)v7[1] )
  {
    v7[1] = (int)(a1 + 3);
    *v7 = v7[1];
  }
  else if ( v6 == (int *)*v7 )
  {
    *v7 = v6[1];
  }
  else if ( v6 == (int *)v7[1] )
  {
    v7[1] = *v6;
  }
  sub_77AA4(v6);
  sub_77AA4(v6 + 2);
  sub_76A8C(v6[5]);
  sub_7B014(v6);
  --*a1;
  return 0;
}

//----- (00077E0C) --------------------------------------------------------
void __fastcall sub_77E0C(int a1)
{
  _DWORD *v2; // [sp+10h] [bp-Ch]
  _DWORD *i; // [sp+14h] [bp-8h]

  for ( i = *(_DWORD **)(a1 + 16); i != (_DWORD *)(a1 + 12); i = v2 )
  {
    v2 = (_DWORD *)i[1];
    sub_76A8C(i[5]);
    sub_7B014(i);
  }
}

//----- (00077E80) --------------------------------------------------------
int __fastcall sub_77E80(int a1)
{
  int v2; // r3
  int v3; // r1
  _DWORD *v6; // [sp+10h] [bp-1Ch]
  void *v7; // [sp+14h] [bp-18h]
  int v8; // [sp+1Ch] [bp-10h]
  unsigned int i; // [sp+20h] [bp-Ch]
  _DWORD *v10; // [sp+24h] [bp-8h]

  v8 = *(_DWORD *)(a1 + 8) + 1;
  v7 = sub_7AFCC(8 * (1 << v8));
  if ( !v7 )
    return -1;
  sub_7B014(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = v7;
  *(_DWORD *)(a1 + 8) = v8;
  for ( i = 0; i < 1 << *(_DWORD *)(a1 + 8); ++i )
  {
    v2 = *(_DWORD *)(a1 + 4) + 8 * i;
    *(_DWORD *)(v2 + 4) = a1 + 12;
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8 * i) = *(_DWORD *)(v2 + 4);
  }
  v10 = *(_DWORD **)(a1 + 16);
  sub_77A10((_DWORD *)(a1 + 12));
  while ( v10 != (_DWORD *)(a1 + 12) )
  {
    v6 = (_DWORD *)v10[1];
    sub_964FC(v10[4], 1 << v8);
    sub_77B4C(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * v3), v10);
    v10 = v6;
  }
  return 0;
}
// 77FCC: variable 'v3' is possibly undefined

//----- (00078010) --------------------------------------------------------
int __fastcall sub_78010(_DWORD *a1)
{
  int v2; // r3
  unsigned int i; // [sp+Ch] [bp-8h]

  *a1 = 0;
  a1[2] = 3;
  a1[1] = sub_7AFCC(8 << a1[2]);
  if ( !a1[1] )
    return -1;
  sub_77A10(a1 + 3);
  sub_77A10(a1 + 5);
  for ( i = 0; i < 1 << a1[2]; ++i )
  {
    v2 = a1[1] + 8 * i;
    *(_DWORD *)(v2 + 4) = a1 + 3;
    *(_DWORD *)(a1[1] + 8 * i) = *(_DWORD *)(v2 + 4);
  }
  return 0;
}

//----- (00078114) --------------------------------------------------------
void __fastcall sub_78114(int a1)
{
  sub_77E0C(a1);
  sub_7B014(*(void **)(a1 + 4));
}

//----- (00078148) --------------------------------------------------------
int __fastcall sub_78148(_DWORD *a1, char *a2, int a3)
{
  size_t v4; // r0
  size_t v9; // [sp+14h] [bp-18h]
  int v10; // [sp+18h] [bp-14h]
  char *v11; // [sp+18h] [bp-14h]
  int *v12; // [sp+1Ch] [bp-10h]
  int v13; // [sp+24h] [bp-8h]

  if ( !(*a1 >> a1[2]) || !sub_77E80((int)a1) )
  {
    v4 = strlen(a2);
    v13 = sub_76AF4((unsigned __int8 *)a2, v4, dword_5510BC);
    v12 = (int *)(a1[1] + 8 * (((1 << a1[2]) - 1) & v13));
    v10 = sub_77BDC((int)a1, v12, a2, v13);
    if ( v10 )
    {
      sub_76A8C(*(_DWORD *)(v10 + 20));
      *(_DWORD *)(v10 + 20) = a3;
    }
    else
    {
      v9 = strlen(a2);
      if ( v9 > 0xFFFFFFE6 )
        return -1;
      v11 = (char *)sub_7AFCC(v9 + 25);
      if ( !v11 )
        return -1;
      *((_DWORD *)v11 + 4) = v13;
      strncpy(v11 + 24, a2, v9 + 1);
      *((_DWORD *)v11 + 5) = a3;
      sub_77A10(v11);
      sub_77A10((_DWORD *)v11 + 2);
      sub_77B4C((int)a1, v12, v11);
      sub_77A48((int)(a1 + 5), (_DWORD *)v11 + 2);
      ++*a1;
    }
    return 0;
  }
  return -1;
}
// 5510BC: using guessed type int dword_5510BC;

//----- (00078328) --------------------------------------------------------
int __fastcall sub_78328(int a1, char *a2)
{
  size_t v2; // r0
  int v7; // [sp+Ch] [bp-10h]
  int v8; // [sp+14h] [bp-8h]

  v2 = strlen(a2);
  v8 = sub_76AF4((unsigned __int8 *)a2, v2, dword_5510BC);
  v7 = sub_77BDC(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v8 & ((1 << *(_DWORD *)(a1 + 8)) - 1))), a2, v8);
  if ( v7 )
    return *(_DWORD *)(v7 + 20);
  else
    return 0;
}
// 5510BC: using guessed type int dword_5510BC;

//----- (000783D4) --------------------------------------------------------
int __fastcall sub_783D4(_DWORD *a1, char *a2)
{
  size_t v2; // r0
  int v6; // [sp+Ch] [bp-8h]

  v2 = strlen(a2);
  v6 = sub_76AF4((unsigned __int8 *)a2, v2, dword_5510BC);
  return sub_77CA0(a1, a2, v6);
}
// 5510BC: using guessed type int dword_5510BC;

//----- (00078430) --------------------------------------------------------
_DWORD *__fastcall sub_78430(_DWORD *a1)
{
  int v1; // r3
  _DWORD *result; // r0
  unsigned int i; // [sp+Ch] [bp-8h]

  sub_77E0C((int)a1);
  for ( i = 0; i < 1 << a1[2]; ++i )
  {
    v1 = a1[1] + 8 * i;
    *(_DWORD *)(v1 + 4) = a1 + 3;
    *(_DWORD *)(a1[1] + 8 * i) = *(_DWORD *)(v1 + 4);
  }
  sub_77A10(a1 + 3);
  result = sub_77A10(a1 + 5);
  *a1 = 0;
  return result;
}

//----- (000784F0) --------------------------------------------------------
int __fastcall sub_784F0(int a1)
{
  return sub_785D0(a1, a1 + 20);
}

//----- (00078524) --------------------------------------------------------
int __fastcall sub_78524(int a1, char *a2)
{
  size_t v2; // r0
  int v7; // [sp+Ch] [bp-10h]
  int v8; // [sp+14h] [bp-8h]

  v2 = strlen(a2);
  v8 = sub_76AF4((unsigned __int8 *)a2, v2, dword_5510BC);
  v7 = sub_77BDC(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v8 & ((1 << *(_DWORD *)(a1 + 8)) - 1))), a2, v8);
  if ( v7 )
    return v7 + 8;
  else
    return 0;
}
// 5510BC: using guessed type int dword_5510BC;

//----- (000785D0) --------------------------------------------------------
int __fastcall sub_785D0(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 4) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a2 + 4);
}

//----- (00078624) --------------------------------------------------------
int __fastcall sub_78624(int a1)
{
  return a1 + 16;
}

//----- (00078658) --------------------------------------------------------
int __fastcall sub_78658(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (0007868C) --------------------------------------------------------
int __fastcall sub_7868C(int a1, int a2)
{
  int result; // r0
  int v4; // [sp+Ch] [bp-8h]

  v4 = a1 - 8;
  result = sub_76A8C(*(_DWORD *)(a1 + 12));
  *(_DWORD *)(v4 + 20) = a2;
  return result;
}

//----- (000786D4) --------------------------------------------------------
int __fastcall sub_786D4(int a1)
{
  int v2; // [sp+8h] [bp-Ch]
  unsigned int i; // [sp+Ch] [bp-8h]

  v2 = 0;
  for ( i = 0; i <= 3; ++i )
    v2 = (v2 << 8) | *(unsigned __int8 *)(a1 + i);
  return v2;
}

//----- (00078744) --------------------------------------------------------
int __fastcall sub_78744(int *a1)
{
  _BYTE buf[4]; // [sp+Ch] [bp-10h] BYREF
  _BOOL4 v5; // [sp+10h] [bp-Ch]
  int fd; // [sp+14h] [bp-8h]

  fd = open("/dev/urandom", 0);
  if ( fd == -1 )
    return 1;
  v5 = read(fd, buf, 4u) == 4;
  close(fd);
  if ( !v5 )
    return 1;
  *a1 = sub_786D4((int)buf);
  return 0;
}

//----- (000787EC) --------------------------------------------------------
int __fastcall sub_787EC(int *a1)
{
  struct timeval tv; // [sp+8h] [bp-Ch] BYREF

  gettimeofday(&tv, 0);
  *a1 = tv.tv_sec ^ tv.tv_usec;
  *a1 ^= getpid();
  return 0;
}

//----- (00078854) --------------------------------------------------------
int sub_78854()
{
  int v1; // [sp+0h] [bp-Ch] BYREF

  v1 = 0;
  if ( sub_78744(&v1) != 0 )
    sub_787EC(&v1);
  if ( !v1 )
    return 1;
  return v1;
}

//----- (000788CC) --------------------------------------------------------
int __fastcall sub_788CC(int result)
{
  unsigned __int8 v1; // r2
  int v2; // r3
  int v3; // [sp+Ch] [bp-8h]

  v3 = result;
  if ( !dword_5510BC )
  {
    do
    {
      v1 = __ldrex(byte_5510C0);
      result = __strex(1u, byte_5510C0);
    }
    while ( result );
    if ( v1 != 1 )
    {
      if ( !v3 )
      {
        result = sub_78854();
        v3 = result;
      }
      __dmb(0xBu);
      dword_5510BC = v3;
    }
    else
    {
      do
      {
        result = sched_yield();
        v2 = dword_5510BC;
        __dmb(0xBu);
      }
      while ( !v2 );
    }
  }
  return result;
}
// 5510BC: using guessed type int dword_5510BC;
// 5510C0: using guessed type unsigned __int8 byte_5510C0[4];

//----- (00078980) --------------------------------------------------------
void __fastcall sub_78980(_DWORD *a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && a1[1] != -1 )
  {
    v1 = a1 + 1;
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      sub_7E3BC(a1);
  }
}

//----- (000789E8) --------------------------------------------------------
int sub_789E8(int result, _DWORD *a2, int a3, const char *a4, ...)
{
  int v6; // [sp+1Ch] [bp-164h]
  char v7[159]; // [sp+20h] [bp-160h] BYREF
  char v8; // [sp+BFh] [bp-C1h]
  char s[160]; // [sp+C0h] [bp-C0h] BYREF
  __gnuc_va_list arg; // [sp+160h] [bp-20h]
  const char *v11; // [sp+164h] [bp-1Ch]
  char v12[4]; // [sp+168h] [bp-18h]
  int v13; // [sp+16Ch] [bp-14h]
  int v14; // [sp+170h] [bp-10h]
  int v15; // [sp+174h] [bp-Ch]
  const char *varg_r3; // [sp+184h] [bp+4h]
  va_list va; // [sp+188h] [bp+8h] BYREF

  va_start(va, a4);
  varg_r3 = a4;
  v6 = result;
  v15 = -1;
  v14 = -1;
  v13 = 0;
  *(_DWORD *)v12 = s;
  if ( result )
  {
    va_copy(arg, va);
    vsnprintf(s, 0xA0u, varg_r3, va);
    s[159] = 0;
    if ( a2 )
    {
      v11 = (const char *)sub_7B2BC((int)(a2 + 10));
      v15 = a2[6];
      v14 = a2[7];
      v13 = a2[9];
      if ( v11 && *v11 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v7, 0xA0u, "%s near '%s'", s, v11);
          v8 = 0;
          *(_DWORD *)v12 = v7;
        }
      }
      else
      {
        if ( a3 == 8 )
          LOBYTE(a3) = 6;
        if ( a2[5] == -2 )
        {
          *(_DWORD *)v12 = s;
        }
        else
        {
          snprintf(v7, 0xA0u, "%s near end of file", s);
          v8 = 0;
          *(_DWORD *)v12 = v7;
        }
      }
    }
    return sub_7E828(v6, v15, v14, v13, a3, "%s", *(const char **)v12);
  }
  return result;
}

//----- (00078B9C) --------------------------------------------------------
int __fastcall sub_78B9C(int result, int a2, int a3)
{
  *(_DWORD *)result = a2;
  *(_DWORD *)(result + 4) = a3;
  *(_BYTE *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 1;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 36) = 0;
  return result;
}

//----- (00078C24) --------------------------------------------------------
int __fastcall sub_78C24(int a1, int a2)
{
  int v3; // r3
  unsigned int v7; // [sp+14h] [bp-10h]
  int v8; // [sp+18h] [bp-Ch]
  int v9; // [sp+18h] [bp-Ch]
  unsigned int i; // [sp+1Ch] [bp-8h]

  if ( *(_DWORD *)(a1 + 20) )
    return *(_DWORD *)(a1 + 20);
  if ( !*(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8) )
  {
    v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    if ( v8 == -1 )
    {
      *(_DWORD *)(a1 + 20) = -1;
      return -1;
    }
    *(_BYTE *)(a1 + 8) = v8;
    *(_DWORD *)(a1 + 16) = 0;
    if ( v8 <= 127 || v8 > 255 )
    {
      *(_BYTE *)(a1 + 9) = 0;
    }
    else
    {
      v7 = sub_7BB58(v8);
      if ( !v7 )
        goto LABEL_22;
      if ( v7 <= 1 )
        _assert_fail("count >= 2", "load.c", 0xBDu, "stream_get");
      for ( i = 1; i < v7; *(_BYTE *)(a1 + i++ + 8) = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4)) )
        ;
      if ( !sub_7BC3C((char *)(a1 + 8), v7, 0) )
      {
LABEL_22:
        *(_DWORD *)(a1 + 20) = -2;
        sub_789E8(a2, (_DWORD *)a1, 5, "unable to decode byte 0x%x", v8);
        return -2;
      }
      *(_BYTE *)(a1 + v7 + 8) = 0;
    }
  }
  v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v3 + 1;
  v9 = *(unsigned __int8 *)(a1 + v3 + 8);
  ++*(_DWORD *)(a1 + 36);
  if ( v9 == 10 )
  {
    ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 28) = 0;
  }
  else if ( sub_7BB58(v9) )
  {
    ++*(_DWORD *)(a1 + 28);
  }
  return v9;
}

//----- (00078ED0) --------------------------------------------------------
_DWORD *__fastcall sub_78ED0(_DWORD *result, int a2)
{
  _DWORD *v3; // [sp+4h] [bp-8h]

  v3 = result;
  if ( a2 != -1 && a2 != -2 )
  {
    --result[9];
    if ( a2 == 10 )
    {
      --result[6];
      result[7] = result[8];
    }
    else
    {
      result = (_DWORD *)sub_7BB58(a2);
      if ( result )
        --v3[7];
    }
    if ( !v3[4] )
      _assert_fail("stream->buffer_pos > 0", "load.c", 0xEEu, "stream_unget");
    if ( a2 != *((unsigned __int8 *)v3 + --v3[4] + 8) )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 0xF0u, "stream_unget");
  }
  return result;
}

//----- (00079008) --------------------------------------------------------
int __fastcall sub_79008(int a1, int a2)
{
  return sub_78C24(a1, a2);
}

//----- (0007903C) --------------------------------------------------------
int __fastcall sub_7903C(int a1, char a2)
{
  return sub_7B320(a1 + 40, a2);
}

//----- (00079078) --------------------------------------------------------
int __fastcall sub_79078(int a1, int a2)
{
  int v4; // [sp+Ch] [bp-8h]

  v4 = sub_78C24(a1, a2);
  if ( v4 != -1 && v4 != -2 )
    sub_7903C(a1, v4);
  return v4;
}

//----- (000790D4) --------------------------------------------------------
_DWORD *__fastcall sub_790D4(_DWORD *a1, int a2)
{
  return sub_78ED0(a1, a2);
}

//----- (00079104) --------------------------------------------------------
_DWORD *__fastcall sub_79104(_DWORD *result, int a2)
{
  _DWORD *v3; // [sp+4h] [bp-10h]

  v3 = result;
  if ( a2 != -1 && a2 != -2 )
  {
    sub_78ED0(result, a2);
    result = (_DWORD *)sub_7B4D4(v3 + 10);
    if ( a2 != (unsigned __int8)result )
      _assert_fail("c == d", "load.c", 0x11Au, "lex_unget_unsave");
  }
  return result;
}

//----- (00079194) --------------------------------------------------------
int __fastcall sub_79194(int result)
{
  int i; // [sp+4h] [bp-8h]

  for ( i = result; *(_BYTE *)(i + *(_DWORD *)(i + 16) + 8); ++*(_DWORD *)(i + 36) )
  {
    result = sub_7903C(i, *(_BYTE *)(i + *(_DWORD *)(i + 16) + 8));
    ++*(_DWORD *)(i + 16);
  }
  return result;
}

//----- (00079218) --------------------------------------------------------
void __fastcall sub_79218(int a1)
{
  sub_7B014(*(void **)(a1 + 64));
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
}

//----- (0007925C) --------------------------------------------------------
int __fastcall sub_7925C(_BYTE *a1)
{
  unsigned __int8 v3; // [sp+Fh] [bp-Dh]
  int v4; // [sp+10h] [bp-Ch]
  int v5; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  v4 = 0;
  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 0x135u, "decode_unicode_escape");
  for ( i = 1; i <= 4; ++i )
  {
    v3 = a1[i];
    v5 = 16 * v4;
    if ( v3 <= 0x2Fu || v3 > 0x39u )
    {
      if ( v3 <= 0x60u || v3 > 0x7Au )
      {
        if ( v3 <= 0x40u || v3 > 0x5Au )
          return -1;
        v4 = v5 + v3 - 55;
      }
      else
      {
        v4 = v5 + v3 - 87;
      }
    }
    else
    {
      v4 = v5 + v3 - 48;
    }
  }
  return v4;
}

//----- (00079390) --------------------------------------------------------
void __fastcall sub_79390(_DWORD *a1, int a2)
{
  int v2; // r3
  _BYTE *v3; // r2
  _BYTE *v4; // r3
  int v7; // [sp+14h] [bp-20h] BYREF
  int v8; // [sp+18h] [bp-1Ch]
  int v9; // [sp+1Ch] [bp-18h]
  int i; // [sp+20h] [bp-14h]
  _BYTE *v11; // [sp+24h] [bp-10h]
  _BYTE *v12; // [sp+28h] [bp-Ch]
  int v13; // [sp+2Ch] [bp-8h]

  a1[16] = 0;
  a1[15] = -1;
  v13 = sub_79078((int)a1, a2);
  while ( v13 != 34 )
  {
    if ( v13 == -2 )
      goto LABEL_80;
    if ( v13 == -1 )
    {
      sub_789E8(a2, a1, 6, "premature end of input");
LABEL_80:
      sub_79218((int)a1);
      return;
    }
    if ( (unsigned int)v13 < 0x20 )
    {
      sub_79104(a1, v13);
      if ( v13 == 10 )
        sub_789E8(a2, a1, 8, "unexpected newline");
      else
        sub_789E8(a2, a1, 8, "control character 0x%x", v13);
      goto LABEL_80;
    }
    if ( v13 == 92 )
    {
      v13 = sub_79078((int)a1, a2);
      if ( v13 != 117 )
      {
        if ( v13 != 34 && v13 != 92 && v13 != 47 && v13 != 98 && v13 != 102 && v13 != 110 && v13 != 114 && v13 != 116 )
        {
LABEL_18:
          sub_789E8(a2, a1, 8, "invalid escape");
          goto LABEL_80;
        }
        goto LABEL_32;
      }
      v13 = sub_79078((int)a1, a2);
      for ( i = 0; i <= 3; ++i )
      {
        if ( (v13 <= 47 || v13 > 57) && (v13 <= 64 || v13 > 70) && (v13 <= 96 || v13 > 102) )
          goto LABEL_18;
        v13 = sub_79078((int)a1, a2);
      }
    }
    else
    {
LABEL_32:
      v13 = sub_79078((int)a1, a2);
    }
  }
  v11 = sub_7AFCC(a1[11] + 1);
  if ( !v11 )
    goto LABEL_80;
  a1[16] = v11;
  v12 = (_BYTE *)(sub_7B2BC((int)(a1 + 10)) + 1);
  while ( *v12 != 34 )
  {
    if ( *v12 == 92 )
    {
      if ( *++v12 == 117 )
      {
        v9 = sub_7925C(v12);
        if ( v9 < 0 )
          goto LABEL_39;
        v12 += 5;
        if ( v9 < 55296 || v9 >= 56320 )
        {
          if ( v9 >= 56320 && v9 < 57344 )
          {
LABEL_52:
            sub_789E8(a2, a1, 8, "invalid Unicode '\\u%04X'", v9);
            goto LABEL_80;
          }
        }
        else
        {
          if ( *v12 != 92 || v12[1] != 117 )
            goto LABEL_52;
          v8 = sub_7925C(++v12);
          if ( v8 < 0 )
          {
LABEL_39:
            sub_789E8(a2, a1, 8, "invalid Unicode escape '%.6s'", v12 - 1);
            goto LABEL_80;
          }
          v12 += 5;
          if ( v8 < 56320 || v8 >= 57344 )
          {
            sub_789E8(a2, a1, 8, "invalid Unicode '\\u%04X\\u%04X'", v9, v8);
            goto LABEL_80;
          }
          v9 = ((v9 - 55296) << 10) + v8 - 56320 + 0x10000;
        }
        if ( sub_7B940(v9, v11, &v7) )
          _assert_fail("0", "load.c", 0x1C4u, "lex_scan_string");
        v11 += v7;
      }
      else
      {
        v2 = (unsigned __int8)*v12;
        if ( v2 == 98 )
        {
          *v11 = 8;
        }
        else if ( (unsigned __int8)*v12 > 0x62u )
        {
          if ( v2 == 110 )
          {
            *v11 = 10;
          }
          else if ( (unsigned __int8)*v12 > 0x6Eu )
          {
            if ( v2 == 114 )
            {
              *v11 = 13;
            }
            else
            {
              if ( v2 != 116 )
                goto LABEL_75;
              *v11 = 9;
            }
          }
          else
          {
            if ( v2 != 102 )
              goto LABEL_75;
            *v11 = 12;
          }
        }
        else
        {
          if ( v2 != 47 && v2 != 92 && v2 != 34 )
LABEL_75:
            _assert_fail("0", "load.c", 0x1D0u, "lex_scan_string");
          *v11 = *v12;
        }
        ++v11;
        ++v12;
      }
    }
    else
    {
      v3 = v12++;
      v4 = v11++;
      *v4 = *v3;
    }
  }
  *v11 = 0;
  a1[17] = &v11[-a1[16]];
  a1[15] = 256;
}

//----- (000799FC) --------------------------------------------------------
int __fastcall sub_799FC(int a1, int a2, int a3)
{
  int v6; // [sp+8h] [bp-2Ch]
  int v7; // [sp+8h] [bp-2Ch]
  double v9; // [sp+10h] [bp-24h] BYREF
  char *endptr; // [sp+1Ch] [bp-18h] BYREF
  __int64 v11; // [sp+20h] [bp-14h]
  char *nptr; // [sp+2Ch] [bp-8h]

  v6 = a2;
  *(_DWORD *)(a1 + 60) = -1;
  if ( a2 == 45 )
    v6 = sub_79078(a1, a3);
  if ( v6 == 48 )
  {
    v6 = sub_79078(a1, a3);
    if ( v6 > 47 && v6 <= 57 )
    {
LABEL_6:
      sub_79104((_DWORD *)a1, v6);
      return -1;
    }
  }
  else
  {
    if ( v6 <= 47 || v6 > 57 )
      goto LABEL_6;
    do
      v6 = sub_79078(a1, a3);
    while ( v6 > 47 && v6 <= 57 );
  }
  if ( (*(_DWORD *)(a1 + 52) & 8) != 0 || v6 == 46 || v6 == 69 || v6 == 101 )
  {
    if ( v6 == 46 )
    {
      v7 = sub_79008(a1, a3);
      if ( v7 <= 47 || v7 > 57 )
      {
        sub_790D4((_DWORD *)a1, v7);
        return -1;
      }
      sub_7903C(a1, v7);
      do
        v6 = sub_79078(a1, a3);
      while ( v6 > 47 && v6 <= 57 );
    }
    if ( v6 == 69 || v6 == 101 )
    {
      v6 = sub_79078(a1, a3);
      if ( v6 == 43 || v6 == 45 )
        v6 = sub_79078(a1, a3);
      if ( v6 <= 47 || v6 > 57 )
        goto LABEL_6;
      do
        v6 = sub_79078(a1, a3);
      while ( v6 > 47 && v6 <= 57 );
    }
    sub_79104((_DWORD *)a1, v6);
    if ( sub_7B644(a1 + 40, &v9) )
    {
      sub_789E8(a3, (_DWORD *)a1, 15, "real number overflow");
      return -1;
    }
    *(_DWORD *)(a1 + 60) = 258;
    *(double *)(a1 + 64) = v9;
    return 0;
  }
  else
  {
    sub_79104((_DWORD *)a1, v6);
    nptr = (char *)sub_7B2BC(a1 + 40);
    *_errno_location() = 0;
    v11 = strtoll(nptr, &endptr, 10);
    if ( *_errno_location() == 34 )
    {
      if ( v11 >= 0 )
        sub_789E8(a3, (_DWORD *)a1, 15, "too big integer");
      else
        sub_789E8(a3, (_DWORD *)a1, 15, "too big negative integer");
      return -1;
    }
    if ( &nptr[*(_DWORD *)(a1 + 44)] != endptr )
      _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 0x21Du, "lex_scan_number");
    *(_DWORD *)(a1 + 60) = 257;
    *(_QWORD *)(a1 + 64) = v11;
    return 0;
  }
}
// 799FC: too many cbuild loops

//----- (00079DA4) --------------------------------------------------------
int __fastcall sub_79DA4(_DWORD *a1, int a2)
{
  char *s1; // [sp+8h] [bp-Ch]
  int v6; // [sp+Ch] [bp-8h]
  int v7; // [sp+Ch] [bp-8h]

  sub_7B280((int)(a1 + 10));
  if ( a1[15] == 256 )
    sub_79218((int)a1);
  do
  {
    do
      v6 = sub_79008((int)a1, a2);
    while ( v6 == 32 );
  }
  while ( v6 == 9 || v6 == 10 || v6 == 13 );
  if ( v6 == -1 )
  {
    a1[15] = 0;
  }
  else if ( v6 == -2 )
  {
    a1[15] = -1;
  }
  else
  {
    sub_7903C((int)a1, v6);
    if ( v6 == 123 || v6 == 125 || v6 == 91 || v6 == 93 || v6 == 58 || v6 == 44 )
    {
      a1[15] = v6;
    }
    else if ( v6 == 34 )
    {
      sub_79390(a1, a2);
    }
    else if ( v6 > 47 && v6 <= 57 || v6 == 45 )
    {
      sub_799FC((int)a1, v6, a2);
    }
    else if ( (v6 <= 64 || v6 > 90) && (v6 <= 96 || v6 > 122) )
    {
      sub_79194((int)a1);
      a1[15] = -1;
    }
    else
    {
      do
      {
        do
          v7 = sub_79078((int)a1, a2);
        while ( v7 > 64 && v7 <= 90 );
      }
      while ( v7 > 96 && v7 <= 122 );
      sub_79104(a1, v7);
      s1 = (char *)sub_7B2BC((int)(a1 + 10));
      if ( !strcmp(s1, "true") )
      {
        a1[15] = 259;
      }
      else if ( !strcmp(s1, "false") )
      {
        a1[15] = 260;
      }
      else if ( !strcmp(s1, "null") )
      {
        a1[15] = 261;
      }
      else
      {
        a1[15] = -1;
      }
    }
  }
  return a1[15];
}

//----- (0007A064) --------------------------------------------------------
int __fastcall sub_7A064(_DWORD *a1, _DWORD *a2)
{
  int v3; // [sp+Ch] [bp-8h]

  v3 = 0;
  if ( a1[15] == 256 )
  {
    v3 = a1[16];
    *a2 = a1[17];
    a1[16] = 0;
    a1[17] = 0;
  }
  return v3;
}

//----- (0007A0D8) --------------------------------------------------------
int __fastcall sub_7A0D8(int a1, int a2, int a3, int a4)
{
  sub_78B9C(a1, a2, a4);
  if ( sub_7B1A4((void **)(a1 + 40)) )
    return -1;
  *(_DWORD *)(a1 + 52) = a3;
  *(_DWORD *)(a1 + 60) = -1;
  return 0;
}

//----- (0007A154) --------------------------------------------------------
void __fastcall sub_7A154(int a1)
{
  if ( *(_DWORD *)(a1 + 60) == 256 )
    sub_79218(a1);
  sub_7B220(a1 + 40);
}

//----- (0007A198) --------------------------------------------------------
_DWORD *__fastcall sub_7A198(_DWORD *a1, int a2, int a3)
{
  unsigned int v8; // [sp+10h] [bp-14h] BYREF
  _DWORD *v9; // [sp+14h] [bp-10h]
  void *v10; // [sp+18h] [bp-Ch]
  _DWORD *v11; // [sp+1Ch] [bp-8h]

  v11 = sub_7C134();
  if ( !v11 )
    return 0;
  sub_79DA4(a1, a3);
  if ( a1[15] == 125 )
    return v11;
  while ( 1 )
  {
    if ( a1[15] != 256 )
    {
      sub_789E8(a3, a1, 8, "string or '}' expected");
      goto LABEL_24;
    }
    v10 = (void *)sub_7A064(a1, &v8);
    if ( !v10 )
      return 0;
    if ( memchr((char *)v10, 0, v8) )
    {
      sub_7B014(v10);
      sub_789E8(a3, a1, 13, "NUL byte in object key not supported");
      goto LABEL_24;
    }
    if ( (a2 & 1) != 0 && sub_7C250(v11, (char *)v10) )
    {
      sub_7B014(v10);
      sub_789E8(a3, a1, 14, "duplicate object key");
      goto LABEL_24;
    }
    sub_79DA4(a1, a3);
    if ( a1[15] != 58 )
    {
      sub_7B014(v10);
      sub_789E8(a3, a1, 8, "':' expected");
      goto LABEL_24;
    }
    sub_79DA4(a1, a3);
    v9 = (_DWORD *)sub_7A524(a1, a2, a3);
    if ( !v9 || sub_7C2C0(v11, (char *)v10, v9) )
    {
      sub_7B014(v10);
      goto LABEL_24;
    }
    sub_7B014(v10);
    sub_79DA4(a1, a3);
    if ( a1[15] != 44 )
      break;
    sub_79DA4(a1, a3);
  }
  if ( a1[15] == 125 )
    return v11;
  sub_789E8(a3, a1, 8, "'}' expected");
LABEL_24:
  sub_78980(v11);
  return 0;
}
// 7A524: using guessed type int __fastcall sub_7A524(_DWORD, _DWORD, _DWORD);

//----- (0007A3FC) --------------------------------------------------------
_DWORD *__fastcall sub_7A3FC(_DWORD *a1, int a2, int a3)
{
  _DWORD *v8; // [sp+10h] [bp-Ch]
  _DWORD *v9; // [sp+14h] [bp-8h]

  v9 = sub_7CC78();
  if ( !v9 )
    return 0;
  sub_79DA4(a1, a3);
  if ( a1[15] == 93 )
    return v9;
  while ( a1[15] )
  {
    v8 = (_DWORD *)sub_7A524(a1, a2, a3);
    if ( !v8 || sub_7D114(v9, v8) )
      goto LABEL_13;
    sub_79DA4(a1, a3);
    if ( a1[15] != 44 )
      break;
    sub_79DA4(a1, a3);
  }
  if ( a1[15] == 93 )
    return v9;
  sub_789E8(a3, a1, 8, "']' expected");
LABEL_13:
  sub_78980(v9);
  return 0;
}
// 7A524: using guessed type int __fastcall sub_7A524(_DWORD, _DWORD, _DWORD);

//----- (0007A524) --------------------------------------------------------
void *__fastcall sub_7A524(int a1, char a2, int a3)
{
  int v4; // r3
  unsigned int v8; // [sp+14h] [bp-10h]
  char *v9; // [sp+18h] [bp-Ch]
  void *v10; // [sp+1Ch] [bp-8h]

  if ( ++*(_DWORD *)(a1 + 56) > 0x800u )
  {
    sub_789E8(a3, (_DWORD *)a1, 2, "maximum parsing depth reached");
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 60);
  if ( v4 == 257 )
  {
    v10 = sub_7DEB4(*(_QWORD *)(a1 + 64));
  }
  else if ( v4 > 257 )
  {
    if ( v4 == 259 )
    {
      v10 = sub_7E35C();
    }
    else if ( v4 < 259 )
    {
      v10 = sub_7E070();
    }
    else if ( v4 == 260 )
    {
      v10 = sub_7E37C();
    }
    else
    {
      if ( v4 != 261 )
        goto LABEL_29;
      v10 = sub_7E39C();
    }
  }
  else if ( v4 == 91 )
  {
    v10 = sub_7A3FC((_DWORD *)a1, a2, a3);
  }
  else
  {
    if ( v4 <= 91 )
    {
      if ( v4 == -1 )
      {
        sub_789E8(a3, (_DWORD *)a1, 8, "invalid token");
        return 0;
      }
LABEL_29:
      sub_789E8(a3, (_DWORD *)a1, 8, "unexpected token");
      return 0;
    }
    if ( v4 == 123 )
    {
      v10 = sub_7A198((_DWORD *)a1, a2, a3);
    }
    else
    {
      if ( v4 != 256 )
        goto LABEL_29;
      v9 = *(char **)(a1 + 64);
      v8 = *(_DWORD *)(a1 + 68);
      if ( (a2 & 0x10) == 0 && memchr(v9, 0, v8) )
      {
        sub_789E8(a3, (_DWORD *)a1, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
        return 0;
      }
      v10 = sub_7D964(v9, v8);
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 68) = 0;
    }
  }
  if ( !v10 )
    return 0;
  --*(_DWORD *)(a1 + 56);
  return v10;
}

//----- (0007A790) --------------------------------------------------------
_DWORD *__fastcall sub_7A790(_DWORD *a1, char a2, int a3)
{
  _DWORD *v8; // [sp+14h] [bp-8h]

  a1[14] = 0;
  sub_79DA4(a1, a3);
  if ( (a2 & 4) != 0 || a1[15] == 91 || a1[15] == 123 )
  {
    v8 = sub_7A524((int)a1, a2, a3);
    if ( v8 )
    {
      if ( (a2 & 2) != 0 || (sub_79DA4(a1, a3), !a1[15]) )
      {
        if ( a3 )
          *(_DWORD *)(a3 + 8) = a1[9];
        return v8;
      }
      else
      {
        sub_789E8(a3, a1, 7, "end of file expected");
        sub_78980(v8);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_789E8(a3, a1, 8, "'[' or '{' expected");
    return 0;
  }
}

//----- (0007A8BC) --------------------------------------------------------
int __fastcall sub_7A8BC(_DWORD *a1)
{
  unsigned __int8 v3; // [sp+Bh] [bp-9h]

  v3 = *(_BYTE *)(*a1 + a1[1]);
  if ( !v3 )
    return -1;
  ++a1[1];
  return v3;
}

//----- (0007A92C) --------------------------------------------------------
_DWORD *__fastcall sub_7A92C(int a1, int a2, char *a3)
{
  _DWORD v8[2]; // [sp+10h] [bp-5Ch] BYREF
  _DWORD v9[19]; // [sp+18h] [bp-54h] BYREF
  _DWORD *v10; // [sp+64h] [bp-8h]

  sub_7E6D8(a3, "<string>");
  if ( a1 )
  {
    v8[0] = a1;
    v8[1] = 0;
    if ( sub_7A0D8((int)v9, 501948, a2, (int)v8) )
    {
      return 0;
    }
    else
    {
      v10 = sub_7A790(v9, a2, (int)a3);
      sub_7A154((int)v9);
      return v10;
    }
  }
  else
  {
    sub_789E8((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (0007A9F0) --------------------------------------------------------
int __fastcall sub_7A9F0(_DWORD *a1)
{
  if ( a1[2] >= a1[1] )
    return -1;
  return *(unsigned __int8 *)(*a1 + a1[2]++);
}

//----- (0007AA6C) --------------------------------------------------------
_DWORD *__fastcall sub_7AA6C(int a1, int a2, int a3, char *a4)
{
  _DWORD v10[3]; // [sp+14h] [bp-60h] BYREF
  _DWORD v11[19]; // [sp+20h] [bp-54h] BYREF
  _DWORD *v12; // [sp+6Ch] [bp-8h]

  sub_7E6D8(a4, "<buffer>");
  if ( a1 )
  {
    v10[0] = a1;
    v10[2] = 0;
    v10[1] = a2;
    if ( sub_7A0D8((int)v11, (int)sub_7A9F0, a3, (int)v10) )
    {
      return 0;
    }
    else
    {
      v12 = sub_7A790(v11, a3, (int)a4);
      sub_7A154((int)v11);
      return v12;
    }
  }
  else
  {
    sub_789E8((int)a4, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (0007AB3C) --------------------------------------------------------
_DWORD *__fastcall sub_7AB3C(int a1, int a2, char *a3)
{
  _DWORD v8[18]; // [sp+10h] [bp-54h] BYREF
  _DWORD *v9; // [sp+58h] [bp-Ch]
  const char *v10; // [sp+5Ch] [bp-8h]

  if ( a1 == stdin )
    v10 = "<stdin>";
  else
    v10 = "<stream>";
  sub_7E6D8(a3, v10);
  if ( a1 )
  {
    if ( sub_7A0D8((int)v8, (int)fgetc, a2, a1) )
    {
      return 0;
    }
    else
    {
      v9 = sub_7A790(v8, a2, (int)a3);
      sub_7A154((int)v8);
      return v9;
    }
  }
  else
  {
    sub_789E8((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}
// BDA10: using guessed type int stdin;

//----- (0007AC20) --------------------------------------------------------
int __fastcall sub_7AC20(int *a1)
{
  unsigned __int8 buf; // [sp+Fh] [bp-5h] BYREF

  if ( read(*a1, &buf, 1u) == 1 )
    return buf;
  else
    return -1;
}

//----- (0007AC6C) --------------------------------------------------------
_DWORD *__fastcall sub_7AC6C(int a1, int a2, char *a3)
{
  int v7; // [sp+Ch] [bp-58h] BYREF
  _DWORD v8[18]; // [sp+10h] [bp-54h] BYREF
  _DWORD *v9; // [sp+58h] [bp-Ch]
  const char *v10; // [sp+5Ch] [bp-8h]

  v7 = a1;
  if ( a1 )
    v10 = "<stream>";
  else
    v10 = "<stdin>";
  sub_7E6D8(a3, v10);
  if ( v7 >= 0 )
  {
    if ( sub_7A0D8((int)v8, (int)sub_7AC20, a2, (int)&v7) )
    {
      return 0;
    }
    else
    {
      v9 = sub_7A790(v8, a2, (int)a3);
      sub_7A154((int)v8);
      return v9;
    }
  }
  else
  {
    sub_789E8((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (0007AD44) --------------------------------------------------------
_DWORD *__fastcall sub_7AD44(const char *a1, int a2, char *a3)
{
  int *v4; // r0
  char *v5; // r0
  _DWORD *v10; // [sp+18h] [bp-Ch]
  FILE *stream; // [sp+1Ch] [bp-8h]

  sub_7E6D8(a3, a1);
  if ( a1 )
  {
    stream = fopen(a1, "rb");
    if ( stream )
    {
      v10 = sub_7AB3C((int)stream, a2, a3);
      fclose(stream);
      return v10;
    }
    else
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      sub_789E8((int)a3, 0, 3, "unable to open %s: %s", a1, v5);
      return 0;
    }
  }
  else
  {
    sub_789E8((int)a3, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (0007AE24) --------------------------------------------------------
int __fastcall sub_7AE24(int a1)
{
  if ( *(_DWORD *)(a1 + 1028) >= *(_DWORD *)(a1 + 1024) )
  {
    *(_DWORD *)(a1 + 1028) = 0;
    *(_DWORD *)(a1 + 1024) = (*(int (__fastcall **)(int, int, _DWORD))(a1 + 1032))(a1, 1024, *(_DWORD *)(a1 + 1036));
    if ( !*(_DWORD *)(a1 + 1024) || *(_DWORD *)(a1 + 1024) == -1 )
      return -1;
  }
  return *(unsigned __int8 *)(a1 + (*(_DWORD *)(a1 + 1028))++);
}

//----- (0007AEE8) --------------------------------------------------------
_DWORD *__fastcall sub_7AEE8(int a1, int a2, int a3, char *a4)
{
  _DWORD v10[260]; // [sp+10h] [bp-464h] BYREF
  _DWORD v11[19]; // [sp+420h] [bp-54h] BYREF
  _DWORD *v12; // [sp+46Ch] [bp-8h]

  memset(v10, 0, sizeof(v10));
  v10[258] = a1;
  v10[259] = a2;
  sub_7E6D8(a4, "<callback>");
  if ( a1 )
  {
    if ( sub_7A0D8((int)v11, (int)sub_7AE24, a3, (int)v10) )
    {
      return 0;
    }
    else
    {
      v12 = sub_7A790(v11, a3, (int)a4);
      sub_7A154((int)v11);
      return v12;
    }
  }
  else
  {
    sub_789E8((int)a4, 0, 4, "wrong arguments");
    return 0;
  }
}

//----- (0007AFCC) --------------------------------------------------------
void *__fastcall sub_7AFCC(size_t a1)
{
  if ( a1 )
    return off_BD5D0(a1);
  else
    return 0;
}
// BD5D0: using guessed type void *(*off_BD5D0)(size_t size);

//----- (0007B014) --------------------------------------------------------
void __fastcall sub_7B014(void *a1)
{
  if ( a1 )
    off_BD5D4(a1);
}
// BD5D4: using guessed type void (*off_BD5D4)(void *ptr);

//----- (0007B054) --------------------------------------------------------
void *__fastcall sub_7B054(const char *a1)
{
  size_t v1; // r0

  v1 = strlen(a1);
  return sub_7B08C(a1, v1);
}

//----- (0007B08C) --------------------------------------------------------
void *__fastcall sub_7B08C(const void *a1, size_t a2)
{
  void *dest; // [sp+Ch] [bp-8h]

  dest = sub_7AFCC(a2 + 1);
  if ( !dest )
    return 0;
  memcpy(dest, a1, a2);
  *((_BYTE *)dest + a2) = 0;
  return dest;
}

//----- (0007B0FC) --------------------------------------------------------
void *(*__fastcall sub_7B0FC(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size)
{
  off_BD5D0 = result;
  off_BD5D4 = a2;
  return result;
}
// BD5D0: using guessed type void *(*off_BD5D0)(size_t size);
// BD5D4: using guessed type void (*off_BD5D4)(void *ptr);

//----- (0007B140) --------------------------------------------------------
_DWORD *__fastcall sub_7B140(_DWORD *result, _DWORD *a2)
{
  if ( result )
    *result = off_BD5D0;
  if ( a2 )
    *a2 = off_BD5D4;
  return result;
}
// BD5D0: using guessed type void *(*off_BD5D0)(size_t size);
// BD5D4: using guessed type void (*off_BD5D4)(void *ptr);

//----- (0007B1A4) --------------------------------------------------------
int __fastcall sub_7B1A4(void **a1)
{
  a1[2] = (void *)16;
  a1[1] = 0;
  *a1 = sub_7AFCC((size_t)a1[2]);
  if ( !*a1 )
    return -1;
  *(_BYTE *)*a1 = 0;
  return 0;
}

//----- (0007B220) --------------------------------------------------------
void __fastcall sub_7B220(int a1)
{
  if ( *(_DWORD *)a1 )
    sub_7B014(*(void **)a1);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (0007B280) --------------------------------------------------------
int __fastcall sub_7B280(int result)
{
  *(_DWORD *)(result + 4) = 0;
  **(_BYTE **)result = 0;
  return result;
}

//----- (0007B2BC) --------------------------------------------------------
int __fastcall sub_7B2BC(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0007B2E4) --------------------------------------------------------
int __fastcall sub_7B2E4(int *a1)
{
  int v2; // [sp+Ch] [bp-8h]

  v2 = *a1;
  *a1 = 0;
  return v2;
}

//----- (0007B320) --------------------------------------------------------
int __fastcall sub_7B320(int a1, char a2)
{
  char v3; // [sp+3h] [bp-9h] BYREF
  int v4; // [sp+4h] [bp-8h]

  v4 = a1;
  v3 = a2;
  return sub_7B35C(a1, &v3, 1u);
}

//----- (0007B35C) --------------------------------------------------------
int __fastcall sub_7B35C(int a1, const void *a2, size_t a3)
{
  size_t v4; // r3
  void *dest; // [sp+10h] [bp-Ch]
  size_t v10; // [sp+14h] [bp-8h]

  if ( a3 < *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4) )
    goto LABEL_11;
  if ( *(int *)(a1 + 8) >= 0 && a3 != -1 && *(_DWORD *)(a1 + 4) <= -2 - a3 )
  {
    v4 = 2 * *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)(a1 + 4) + a3 + 1 >= v4 )
      v4 = *(_DWORD *)(a1 + 4) + a3 + 1;
    v10 = v4;
    dest = sub_7AFCC(v4);
    if ( !dest )
      return -1;
    memcpy(dest, *(const void **)a1, *(_DWORD *)(a1 + 4));
    sub_7B014(*(void **)a1);
    *(_DWORD *)a1 = dest;
    *(_DWORD *)(a1 + 8) = v10;
LABEL_11:
    memcpy((void *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)), a2, a3);
    *(_DWORD *)(a1 + 4) += a3;
    *(_BYTE *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) = 0;
    return 0;
  }
  return -1;
}

//----- (0007B4D4) --------------------------------------------------------
int __fastcall sub_7B4D4(int *a1)
{
  int v1; // r2
  unsigned __int8 v4; // [sp+Fh] [bp-5h]

  if ( !a1[1] )
    return 0;
  v1 = *a1;
  --a1[1];
  v4 = *(_BYTE *)(v1 + a1[1]);
  *(_BYTE *)(*a1 + a1[1]) = 0;
  return v4;
}

//----- (0007B560) --------------------------------------------------------
_BYTE **__fastcall sub_7B560(const char **a1)
{
  _BYTE **result; // r0
  _BYTE *v3; // [sp+Ch] [bp-8h]

  result = (_BYTE **)localeconv();
  v3 = *result;
  if ( **result != 46 )
  {
    result = (_BYTE **)strchr(*a1, 46);
    if ( result )
      *(_BYTE *)result = *v3;
  }
  return result;
}

//----- (0007B5D4) --------------------------------------------------------
_BYTE *__fastcall sub_7B5D4(const char *a1)
{
  _BYTE *result; // r0

  result = localeconv();
  if ( **(_BYTE **)result != 46 )
  {
    result = strchr(a1, **(unsigned __int8 **)result);
    if ( result )
      *result = 46;
  }
  return result;
}

//----- (0007B644) --------------------------------------------------------
int __fastcall sub_7B644(int a1, double *a2)
{
  double v2; // d0
  char *endptr; // [sp+Ch] [bp-10h] BYREF
  double v8; // [sp+10h] [bp-Ch]

  sub_7B560((const char **)a1);
  *_errno_location() = 0;
  strtod(*(const char **)a1, &endptr);
  v8 = v2;
  if ( (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) != endptr )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 0x4Eu, "jsonp_strtod");
  if ( (v8 > 1.79769313e308 || v8 < -1.79769313e308) && *_errno_location() == 34 )
    return -1;
  *a2 = v8;
  return 0;
}
// 7B688: variable 'v2' is possibly undefined

//----- (0007B740) --------------------------------------------------------
int __fastcall sub_7B740(char *a1, size_t a2, int a3)
{
  double v3; // d0
  int v6; // [sp+Ch] [bp-28h]
  int v9; // [sp+20h] [bp-14h]
  int v10; // [sp+24h] [bp-10h]
  _BYTE *src; // [sp+28h] [bp-Ch]
  char *dest; // [sp+2Ch] [bp-8h]
  _BYTE *desta; // [sp+2Ch] [bp-8h]

  v6 = a3;
  if ( !a3 )
    v6 = 17;
  v9 = snprintf(a1, a2, "%.*g", v6, v3);
  if ( v9 < 0 )
    return -1;
  v10 = v9;
  if ( v9 >= a2 )
    return -1;
  sub_7B5D4(a1);
  if ( !strchr(a1, 46) && !strchr(a1, 101) )
  {
    if ( a2 <= v9 + 3 )
      return -1;
    a1[v9] = 46;
    a1[v9 + 1] = 48;
    a1[v9 + 2] = 0;
    v10 = v9 + 2;
  }
  dest = strchr(a1, 101);
  if ( dest )
  {
    desta = dest + 1;
    src = desta + 1;
    if ( *desta == 45 )
      ++desta;
    while ( *src == 48 )
      ++src;
    if ( src != desta )
    {
      memmove(desta, src, v10 - (src - a1));
      v10 -= src - desta;
    }
  }
  return v10;
}
// 7B78C: variable 'v3' is possibly undefined

//----- (0007B940) --------------------------------------------------------
int __fastcall sub_7B940(int a1, _BYTE *a2, _DWORD *a3)
{
  if ( a1 >= 0 )
  {
    if ( a1 > 127 )
    {
      if ( a1 >= 2048 )
      {
        if ( a1 >= 0x10000 )
        {
          if ( a1 >= 1114112 )
            return -1;
          *a2 = ((a1 >> 18) & 7) - 16;
          a2[1] = ((a1 >> 12) & 0x3F) + 0x80;
          a2[2] = ((a1 >> 6) & 0x3F) + 0x80;
          a2[3] = (a1 & 0x3F) + 0x80;
          *a3 = 4;
        }
        else
        {
          *a2 = ((a1 >> 12) & 0xF) - 32;
          a2[1] = ((a1 >> 6) & 0x3F) + 0x80;
          a2[2] = (a1 & 0x3F) + 0x80;
          *a3 = 3;
        }
      }
      else
      {
        *a2 = ((a1 >> 6) & 0x1F) - 64;
        a2[1] = (a1 & 0x3F) + 0x80;
        *a3 = 2;
      }
    }
    else
    {
      *a2 = a1;
      *a3 = 1;
    }
    return 0;
  }
  return -1;
}

//----- (0007BB58) --------------------------------------------------------
int __fastcall sub_7BB58(unsigned __int8 a1)
{
  if ( (a1 & 0x80u) == 0 )
    return 1;
  if ( a1 <= 0xBFu )
    return 0;
  if ( a1 == 192 || a1 == 193 )
    return 0;
  if ( a1 > 0xC1u && a1 <= 0xDFu )
    return 2;
  if ( a1 > 0xDFu && a1 <= 0xEFu )
    return 3;
  if ( a1 <= 0xEFu || a1 > 0xF4u )
    return 0;
  return 4;
}

//----- (0007BC3C) --------------------------------------------------------
int __fastcall sub_7BC3C(char *a1, unsigned int a2, int *a3)
{
  char v5; // [sp+17h] [bp-Dh]
  unsigned __int8 v6; // [sp+17h] [bp-Dh]
  int v7; // [sp+18h] [bp-Ch]
  unsigned int i; // [sp+1Ch] [bp-8h]

  v5 = *a1;
  switch ( a2 )
  {
    case 2u:
      v7 = v5 & 0x1F;
      break;
    case 3u:
      v7 = v5 & 0xF;
      break;
    case 4u:
      v7 = v5 & 7;
      break;
    default:
      return 0;
  }
  for ( i = 1; i < a2; ++i )
  {
    v6 = a1[i];
    if ( (v6 & 0x80u) == 0 || v6 > 0xBFu )
      return 0;
    v7 = (v7 << 6) + (v6 & 0x3F);
  }
  if ( v7 >= 1114112 )
    return 0;
  if ( v7 >= 55296 && v7 < 57344 )
    return 0;
  if ( a2 == 2 && v7 <= 127 || a2 == 3 && v7 < 2048 || a2 == 4 && v7 < 0x10000 )
    return 0;
  if ( a3 )
    *a3 = v7;
  return 1;
}

//----- (0007BDE8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_7BDE8(unsigned __int8 *a1, unsigned int a2, _DWORD *a3)
{
  int v8; // [sp+10h] [bp-Ch] BYREF
  unsigned int v9; // [sp+14h] [bp-8h]

  if ( !a2 )
    return a1;
  v9 = sub_7BB58(*a1);
  if ( !v9 )
    return 0;
  if ( v9 == 1 )
  {
    v8 = *a1;
  }
  else if ( v9 > a2 || !sub_7BC3C((char *)a1, v9, &v8) )
  {
    return 0;
  }
  if ( a3 )
    *a3 = v8;
  return &a1[v9];
}

//----- (0007BEC0) --------------------------------------------------------
int __fastcall sub_7BEC0(int a1, unsigned int a2)
{
  unsigned int v6; // [sp+8h] [bp-Ch]
  unsigned int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i < a2; ++i )
  {
    v6 = sub_7BB58(*(_BYTE *)(a1 + i));
    if ( !v6 )
      return 0;
    if ( v6 > 1 )
    {
      if ( v6 > a2 - i )
        return 0;
      if ( !sub_7BC3C((char *)(a1 + i), v6, 0) )
        return 0;
      i = v6 + i - 1;
    }
  }
  return 1;
}

//----- (0007BFB0) --------------------------------------------------------
int __fastcall sub_7BFB0(int result)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2

  if ( result && *(_DWORD *)(result + 4) != -1 )
  {
    v1 = (unsigned int *)(result + 4);
    do
      v2 = __ldrex(v1);
    while ( __strex(v2 + 1, v1) );
    __dmb(0xBu);
  }
  return result;
}

//----- (0007C010) --------------------------------------------------------
void __fastcall sub_7C010(_DWORD *a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  if ( a1 && a1[1] != -1 )
  {
    v1 = a1 + 1;
    __dmb(0xBu);
    do
    {
      v2 = __ldrex(v1);
      v3 = v2 - 1;
    }
    while ( __strex(v3, v1) );
    if ( !v3 )
      sub_7E3BC(a1);
  }
}

//----- (0007C078) --------------------------------------------------------
int __fastcall sub_7C078(_DWORD *a1, char *a2, int a3)
{
  _DWORD *v3; // r0

  v3 = (_DWORD *)sub_7BFB0(a3);
  return sub_7C2C0(a1, a2, v3);
}

//----- (0007C0BC) --------------------------------------------------------
int __fastcall sub_7C0BC(_DWORD *a1, int a2)
{
  _DWORD *v2; // r0

  v2 = (_DWORD *)sub_7BFB0(a2);
  return sub_7D114(a1, v2);
}

//----- (0007C0F8) --------------------------------------------------------
_DWORD *__fastcall sub_7C0F8(_DWORD *result, int a2)
{
  *result = a2;
  result[1] = 1;
  return result;
}

//----- (0007C134) --------------------------------------------------------
_DWORD *sub_7C134()
{
  _DWORD *v2; // [sp+4h] [bp-8h]

  v2 = sub_7AFCC(0x24u);
  if ( !v2 )
    return 0;
  if ( !dword_5510BC )
    sub_788CC(0);
  sub_7C0F8(v2, 0);
  if ( !sub_78010(v2 + 2) )
    return v2;
  sub_7B014(v2);
  return 0;
}
// 5510BC: using guessed type int dword_5510BC;

//----- (0007C1C8) --------------------------------------------------------
void __fastcall sub_7C1C8(void *a1)
{
  sub_78114((int)a1 + 8);
  sub_7B014(a1);
}

//----- (0007C1FC) --------------------------------------------------------
int __fastcall sub_7C1FC(_DWORD *a1)
{
  if ( a1 && !*a1 )
    return a1[2];
  else
    return 0;
}

//----- (0007C250) --------------------------------------------------------
int __fastcall sub_7C250(_DWORD *a1, char *a2)
{
  if ( a2 && a1 && !*a1 )
    return sub_78328((int)(a1 + 2), a2);
  else
    return 0;
}

//----- (0007C2C0) --------------------------------------------------------
int __fastcall sub_7C2C0(_DWORD *a1, char *a2, _DWORD *a3)
{
  if ( !a3 )
    return -1;
  if ( a2 && a1 && !*a1 && a1 != a3 && !sub_78148(a1 + 2, a2, (int)a3) )
    return 0;
  sub_7C010(a3);
  return -1;
}

//----- (0007C380) --------------------------------------------------------
int __fastcall sub_7C380(_DWORD *a1, char *a2, _DWORD *a3)
{
  size_t v3; // r0

  if ( a2 )
  {
    v3 = strlen(a2);
    if ( sub_7BEC0((int)a2, v3) )
      return sub_7C2C0(a1, a2, a3);
  }
  sub_7C010(a3);
  return -1;
}

//----- (0007C3F8) --------------------------------------------------------
int __fastcall sub_7C3F8(_DWORD *a1, char *a2)
{
  if ( a2 && a1 && !*a1 )
    return sub_783D4(a1 + 2, a2);
  else
    return -1;
}

//----- (0007C468) --------------------------------------------------------
int __fastcall sub_7C468(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return -1;
  sub_78430(a1 + 2);
  return 0;
}

//----- (0007C4C4) --------------------------------------------------------
int __fastcall sub_7C4C4(_DWORD *a1, _DWORD *a2)
{
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v10; // [sp+8h] [bp-Ch]
  char *i; // [sp+Ch] [bp-8h]

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v3 = sub_7C7C0(a2);
  for ( i = (char *)sub_7C8FC(v3); i; i = (char *)sub_7C8FC(v5) )
  {
    v6 = sub_7C9EC((int)i);
    v10 = sub_7C938(v6);
    if ( !v10 )
      break;
    if ( sub_7C078(a1, i, v10) )
      return -1;
    v4 = sub_7C9EC((int)i);
    v5 = sub_7C88C(a2, v4);
  }
  return 0;
}

//----- (0007C5C0) --------------------------------------------------------
int __fastcall sub_7C5C0(_DWORD *a1, _DWORD *a2)
{
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v10; // [sp+8h] [bp-Ch]
  char *i; // [sp+Ch] [bp-8h]

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v3 = sub_7C7C0(a2);
  for ( i = (char *)sub_7C8FC(v3); i; i = (char *)sub_7C8FC(v5) )
  {
    v6 = sub_7C9EC((int)i);
    v10 = sub_7C938(v6);
    if ( !v10 )
      break;
    if ( sub_7C250(a1, i) )
      sub_7C078(a1, i, v10);
    v4 = sub_7C9EC((int)i);
    v5 = sub_7C88C(a2, v4);
  }
  return 0;
}

//----- (0007C6C0) --------------------------------------------------------
int __fastcall sub_7C6C0(_DWORD *a1, _DWORD *a2)
{
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v10; // [sp+8h] [bp-Ch]
  char *i; // [sp+Ch] [bp-8h]

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v3 = sub_7C7C0(a2);
  for ( i = (char *)sub_7C8FC(v3); i; i = (char *)sub_7C8FC(v5) )
  {
    v6 = sub_7C9EC((int)i);
    v10 = sub_7C938(v6);
    if ( !v10 )
      break;
    if ( !sub_7C250(a1, i) )
      sub_7C078(a1, i, v10);
    v4 = sub_7C9EC((int)i);
    v5 = sub_7C88C(a2, v4);
  }
  return 0;
}

//----- (0007C7C0) --------------------------------------------------------
int __fastcall sub_7C7C0(_DWORD *a1)
{
  if ( a1 && !*a1 )
    return sub_784F0((int)(a1 + 2));
  else
    return 0;
}

//----- (0007C81C) --------------------------------------------------------
int __fastcall sub_7C81C(_DWORD *a1, char *a2)
{
  if ( a2 && a1 && !*a1 )
    return sub_78524((int)(a1 + 2), a2);
  else
    return 0;
}

//----- (0007C88C) --------------------------------------------------------
int __fastcall sub_7C88C(_DWORD *a1, int a2)
{
  if ( a1 && !*a1 && a2 )
    return sub_785D0((int)(a1 + 2), a2);
  else
    return 0;
}

//----- (0007C8FC) --------------------------------------------------------
int __fastcall sub_7C8FC(int a1)
{
  if ( a1 )
    return sub_78624(a1);
  else
    return 0;
}

//----- (0007C938) --------------------------------------------------------
int __fastcall sub_7C938(int a1)
{
  if ( a1 )
    return sub_78658(a1);
  else
    return 0;
}

//----- (0007C974) --------------------------------------------------------
int __fastcall sub_7C974(_DWORD *a1, int a2, _DWORD *a3)
{
  if ( a1 && !*a1 && a2 && a3 )
  {
    sub_7868C(a2, (int)a3);
    return 0;
  }
  else
  {
    sub_7C010(a3);
    return -1;
  }
}

//----- (0007C9EC) --------------------------------------------------------
int __fastcall sub_7C9EC(int a1)
{
  if ( a1 )
    return a1 - 16;
  else
    return 0;
}

//----- (0007CA2C) --------------------------------------------------------
int __fastcall sub_7CA2C(_DWORD *a1, _DWORD *a2)
{
  int v2; // r4
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  _DWORD *v11; // [sp+Ch] [bp-18h]
  _DWORD *v12; // [sp+10h] [bp-14h]
  char *i; // [sp+14h] [bp-10h]

  v2 = sub_7C1FC(a1);
  if ( v2 != sub_7C1FC(a2) )
    return 0;
  v4 = sub_7C7C0(a1);
  for ( i = (char *)sub_7C8FC(v4); i; i = (char *)sub_7C8FC(v6) )
  {
    v7 = sub_7C9EC((int)i);
    v12 = (_DWORD *)sub_7C938(v7);
    if ( !v12 )
      break;
    v11 = (_DWORD *)sub_7C250(a2, i);
    if ( !sub_7E450(v12, v11) )
      return 0;
    v5 = sub_7C9EC((int)i);
    v6 = sub_7C88C(a1, v5);
  }
  return 1;
}

//----- (0007CB1C) --------------------------------------------------------
_DWORD *__fastcall sub_7CB1C(_DWORD *a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v8; // [sp+Ch] [bp-10h]
  _DWORD *v9; // [sp+10h] [bp-Ch]
  char *i; // [sp+14h] [bp-8h]

  v9 = sub_7C134();
  if ( !v9 )
    return 0;
  v2 = sub_7C7C0(a1);
  for ( i = (char *)sub_7C8FC(v2); i; i = (char *)sub_7C8FC(v4) )
  {
    v5 = sub_7C9EC((int)i);
    v8 = sub_7C938(v5);
    if ( !v8 )
      break;
    sub_7C078(v9, i, v8);
    v3 = sub_7C9EC((int)i);
    v4 = sub_7C88C(a1, v3);
  }
  return v9;
}

//----- (0007CBDC) --------------------------------------------------------
_DWORD *__fastcall sub_7CBDC(_DWORD *a1)
{
  _DWORD *v2; // r0
  _DWORD *v5; // [sp+8h] [bp-14h]
  char *v6; // [sp+Ch] [bp-10h]
  _DWORD *v7; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  v7 = sub_7C134();
  if ( !v7 )
    return 0;
  for ( i = sub_7C7C0(a1); i; i = sub_7C88C(a1, i) )
  {
    v6 = (char *)sub_7C8FC(i);
    v5 = (_DWORD *)sub_7C938(i);
    v2 = sub_7E618(v5);
    sub_7C2C0(v7, v6, v2);
  }
  return v7;
}

//----- (0007CC78) --------------------------------------------------------
_DWORD *sub_7CC78()
{
  _DWORD *v2; // [sp+4h] [bp-8h]

  v2 = sub_7AFCC(0x14u);
  if ( !v2 )
    return 0;
  sub_7C0F8(v2, 1);
  v2[3] = 0;
  v2[2] = 8;
  v2[4] = sub_7AFCC(4 * v2[2]);
  if ( v2[4] )
    return v2;
  sub_7B014(v2);
  return 0;
}

//----- (0007CD1C) --------------------------------------------------------
void __fastcall sub_7CD1C(int a1)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i < *(_DWORD *)(a1 + 12); ++i )
    sub_7C010(*(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * i));
  sub_7B014(*(void **)(a1 + 16));
  sub_7B014((void *)a1);
}
// 7C010: using guessed type int __fastcall sub_7C010(_DWORD);

//----- (0007CD9C) --------------------------------------------------------
int __fastcall sub_7CD9C(_DWORD *a1)
{
  if ( a1 && *a1 == 1 )
    return a1[3];
  else
    return 0;
}

//----- (0007CDE8) --------------------------------------------------------
int __fastcall sub_7CDE8(_DWORD *a1, unsigned int a2)
{
  if ( !a1 || *a1 != 1 )
    return 0;
  if ( a2 < a1[3] )
    return *(_DWORD *)(a1[4] + 4 * a2);
  return 0;
}

//----- (0007CE6C) --------------------------------------------------------
int __fastcall sub_7CE6C(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  if ( !a3 )
    return -1;
  if ( a1 && *a1 == 1 && a1 != a3 && a2 < a1[3] )
  {
    sub_7C010(*(_DWORD **)(a1[4] + 4 * a2));
    *(_DWORD *)(a1[4] + 4 * a2) = a3;
    return 0;
  }
  else
  {
    sub_7C010(a3);
    return -1;
  }
}

//----- (0007CF4C) --------------------------------------------------------
void *__fastcall sub_7CF4C(int a1, int a2, int a3, int a4)
{
  return memmove((void *)(*(_DWORD *)(a1 + 16) + 4 * a2), (const void *)(*(_DWORD *)(a1 + 16) + 4 * a3), 4 * a4);
}

//----- (0007CFAC) --------------------------------------------------------
void *__fastcall sub_7CFAC(int a1, int a2, int a3, int a4, int a5)
{
  return memcpy((void *)(a1 + 4 * a2), (const void *)(a3 + 4 * a4), 4 * a5);
}

//----- (0007D004) --------------------------------------------------------
void *__fastcall sub_7D004(_DWORD *a1, int a2, int a3)
{
  unsigned int v4; // r3
  void *v8; // [sp+1Ch] [bp-10h]
  unsigned int v9; // [sp+20h] [bp-Ch]
  void *v10; // [sp+24h] [bp-8h]

  if ( (unsigned int)(a1[3] + a2) <= a1[2] )
    return (void *)a1[4];
  v10 = (void *)a1[4];
  v4 = a1[2] + a2;
  if ( 2 * a1[2] >= v4 )
    v4 = 2 * a1[2];
  v9 = v4;
  v8 = sub_7AFCC(4 * v4);
  if ( !v8 )
    return 0;
  a1[2] = v9;
  a1[4] = v8;
  if ( !a3 )
    return v10;
  sub_7CFAC(a1[4], 0, (int)v10, 0, a1[3]);
  sub_7B014(v10);
  return (void *)a1[4];
}

//----- (0007D114) --------------------------------------------------------
int __fastcall sub_7D114(_DWORD *a1, _DWORD *a2)
{
  if ( !a2 )
    return -1;
  if ( a1 && *a1 == 1 && a1 != a2 && sub_7D004(a1, 1, 1) )
  {
    *(_DWORD *)(a1[4] + 4 * a1[3]++) = a2;
    return 0;
  }
  else
  {
    sub_7C010(a2);
    return -1;
  }
}

//----- (0007D1F0) --------------------------------------------------------
int __fastcall sub_7D1F0(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  void *v8; // [sp+18h] [bp-Ch]

  if ( !a3 )
    return -1;
  if ( a1 && *a1 == 1 && a1 != a3 && a2 <= a1[3] )
  {
    v8 = sub_7D004(a1, 1, 0);
    if ( v8 )
    {
      if ( v8 == (void *)a1[4] )
      {
        sub_7CF4C((int)a1, a2 + 1, a2, a1[3] - a2);
      }
      else
      {
        sub_7CFAC(a1[4], 0, (int)v8, 0, a2);
        sub_7CFAC(a1[4], a2 + 1, (int)v8, a2, a1[3] - a2);
        sub_7B014(v8);
      }
      *(_DWORD *)(a1[4] + 4 * a2) = a3;
      ++a1[3];
      return 0;
    }
    else
    {
      sub_7C010(a3);
      return -1;
    }
  }
  else
  {
    sub_7C010(a3);
    return -1;
  }
}

//----- (0007D388) --------------------------------------------------------
int __fastcall sub_7D388(_DWORD *a1, unsigned int a2)
{
  if ( !a1 || *a1 != 1 )
    return -1;
  if ( a2 >= a1[3] )
    return -1;
  sub_7C010(*(_DWORD **)(a1[4] + 4 * a2));
  if ( a2 < a1[3] - 1 )
    sub_7CF4C((int)a1, a2, a2 + 1, a1[3] - a2 - 1);
  --a1[3];
  return 0;
}

//----- (0007D46C) --------------------------------------------------------
int __fastcall sub_7D46C(_DWORD *a1)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  if ( !a1 || *a1 != 1 )
    return -1;
  for ( i = 0; i < a1[3]; ++i )
    sub_7C010(*(_DWORD **)(a1[4] + 4 * i));
  a1[3] = 0;
  return 0;
}

//----- (0007D510) --------------------------------------------------------
int __fastcall sub_7D510(_DWORD *a1, _DWORD *a2)
{
  unsigned int i; // [sp+1Ch] [bp-8h]

  if ( !a1 || *a1 != 1 || !a2 || *a2 != 1 )
    return -1;
  if ( !sub_7D004(a1, a2[3], 1) )
    return -1;
  for ( i = 0; i < a2[3]; ++i )
    sub_7BFB0(*(_DWORD *)(a2[4] + 4 * i));
  sub_7CFAC(a1[4], a1[3], a2[4], 0, a2[3]);
  a1[3] += a2[3];
  return 0;
}

//----- (0007D644) --------------------------------------------------------
int __fastcall sub_7D644(_DWORD *a1, _DWORD *a2)
{
  int v6; // [sp+8h] [bp-14h]
  int v7; // [sp+Ch] [bp-10h]
  unsigned int v8; // [sp+10h] [bp-Ch]
  unsigned int i; // [sp+14h] [bp-8h]

  v8 = sub_7CD9C(a1);
  if ( v8 != sub_7CD9C(a2) )
    return 0;
  for ( i = 0; i < v8; ++i )
  {
    v7 = sub_7CDE8(a1, i);
    v6 = sub_7CDE8(a2, i);
    if ( !sub_7E450(v7, v6) )
      return 0;
  }
  return 1;
}
// 7E450: using guessed type int __fastcall sub_7E450(_DWORD, _DWORD);

//----- (0007D6FC) --------------------------------------------------------
_DWORD *__fastcall sub_7D6FC(_DWORD *a1)
{
  int v2; // r0
  _DWORD *v5; // [sp+8h] [bp-Ch]
  unsigned int i; // [sp+Ch] [bp-8h]

  v5 = sub_7CC78();
  if ( !v5 )
    return 0;
  for ( i = 0; i < sub_7CD9C(a1); ++i )
  {
    v2 = sub_7CDE8(a1, i);
    sub_7C0BC(v5, v2);
  }
  return v5;
}

//----- (0007D784) --------------------------------------------------------
_DWORD *__fastcall sub_7D784(_DWORD *a1)
{
  int v2; // r0
  _DWORD *v3; // r0
  _DWORD *v6; // [sp+8h] [bp-Ch]
  unsigned int i; // [sp+Ch] [bp-8h]

  v6 = sub_7CC78();
  if ( !v6 )
    return 0;
  for ( i = 0; i < sub_7CD9C(a1); ++i )
  {
    v2 = sub_7CDE8(a1, i);
    v3 = (_DWORD *)sub_7E618(v2);
    sub_7D114(v6, v3);
  }
  return v6;
}
// 7E618: using guessed type int __fastcall sub_7E618(_DWORD);

//----- (0007D818) --------------------------------------------------------
_DWORD *__fastcall sub_7D818(void *a1, size_t a2, int a3)
{
  _DWORD *v6; // [sp+10h] [bp-Ch]
  void *v7; // [sp+14h] [bp-8h]

  if ( !a1 )
    return 0;
  if ( a3 )
  {
    v7 = a1;
  }
  else
  {
    v7 = sub_7B08C(a1, a2);
    if ( !v7 )
      return 0;
  }
  v6 = sub_7AFCC(0x10u);
  if ( v6 )
  {
    sub_7C0F8(v6, 2);
    v6[2] = v7;
    v6[3] = a2;
    return v6;
  }
  else
  {
    sub_7B014(v7);
    return 0;
  }
}

//----- (0007D8E0) --------------------------------------------------------
_DWORD *__fastcall sub_7D8E0(char *a1)
{
  size_t v2; // r0

  if ( !a1 )
    return 0;
  v2 = strlen(a1);
  return sub_7D818(a1, v2, 0);
}

//----- (0007D930) --------------------------------------------------------
_DWORD *__fastcall sub_7D930(void *a1, size_t a2)
{
  return sub_7D818(a1, a2, 0);
}

//----- (0007D964) --------------------------------------------------------
_DWORD *__fastcall sub_7D964(void *a1, size_t a2)
{
  return sub_7D818(a1, a2, 1);
}

//----- (0007D998) --------------------------------------------------------
_DWORD *__fastcall sub_7D998(char *a1)
{
  size_t v2; // r0

  if ( !a1 )
    return 0;
  v2 = strlen(a1);
  return sub_7D9E4(a1, v2);
}

//----- (0007D9E4) --------------------------------------------------------
_DWORD *__fastcall sub_7D9E4(void *a1, size_t a2)
{
  if ( a1 && sub_7BEC0((int)a1, a2) )
    return sub_7D930(a1, a2);
  else
    return 0;
}

//----- (0007DA40) --------------------------------------------------------
int __fastcall sub_7DA40(_DWORD *a1)
{
  if ( a1 && *a1 == 2 )
    return a1[2];
  else
    return 0;
}

//----- (0007DA8C) --------------------------------------------------------
int __fastcall sub_7DA8C(_DWORD *a1)
{
  if ( a1 && *a1 == 2 )
    return a1[3];
  else
    return 0;
}

//----- (0007DAD8) --------------------------------------------------------
int __fastcall sub_7DAD8(int a1, const char *a2)
{
  size_t v3; // r0

  if ( !a2 )
    return -1;
  v3 = strlen(a2);
  return sub_7DB2C(a1, a2, v3);
}

//----- (0007DB2C) --------------------------------------------------------
int __fastcall sub_7DB2C(int a1, const void *a2, size_t a3)
{
  void *v7; // [sp+14h] [bp-8h]

  if ( !a1 || *(_DWORD *)a1 != 2 || !a2 )
    return -1;
  v7 = sub_7B08C(a2, a3);
  if ( !v7 )
    return -1;
  sub_7B014(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 12) = a3;
  return 0;
}

//----- (0007DBD8) --------------------------------------------------------
int __fastcall sub_7DBD8(int a1, const char *a2)
{
  size_t v3; // r0

  if ( !a2 )
    return -1;
  v3 = strlen(a2);
  return sub_7DC2C(a1, a2, v3);
}

//----- (0007DC2C) --------------------------------------------------------
int __fastcall sub_7DC2C(int a1, const void *a2, size_t a3)
{
  if ( a2 && sub_7BEC0((int)a2, a3) )
    return sub_7DB2C(a1, a2, a3);
  else
    return -1;
}

//----- (0007DC90) --------------------------------------------------------
void __fastcall sub_7DC90(void **a1)
{
  sub_7B014(a1[2]);
  sub_7B014(a1);
}

//----- (0007DCC4) --------------------------------------------------------
bool __fastcall sub_7DCC4(int a1, int a2)
{
  return *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && !memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), *(_DWORD *)(a1 + 12));
}

//----- (0007DD44) --------------------------------------------------------
_DWORD *__fastcall sub_7DD44(int a1)
{
  return sub_7D930(*(void **)(a1 + 8), *(_DWORD *)(a1 + 12));
}

//----- (0007DD88) --------------------------------------------------------
_DWORD *__fastcall sub_7DD88(const char *a1, void *a2)
{
  char *s; // [sp+Ch] [bp-10h]
  size_t v6; // [sp+10h] [bp-Ch]
  int v7; // [sp+14h] [bp-8h]

  v7 = 0;
  v6 = vsnprintf(0, 0, a1, a2);
  if ( !v6 )
    return sub_7D998(byte_A6D38);
  s = (char *)sub_7AFCC(v6 + 1);
  if ( s )
  {
    vsnprintf(s, v6 + 1, a1, a2);
    if ( sub_7BEC0((int)s, v6) )
      return sub_7D964(s, v6);
    else
      sub_7B014(s);
  }
  return (_DWORD *)v7;
}

//----- (0007DE74) --------------------------------------------------------
_DWORD *sub_7DE74(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  return sub_7DD88(a1, varg_r1);
}

//----- (0007DEB4) --------------------------------------------------------
_QWORD *__fastcall sub_7DEB4(__int64 a1)
{
  _QWORD *v4; // [sp+Ch] [bp-8h]

  v4 = sub_7AFCC(0x10u);
  if ( !v4 )
    return 0;
  sub_7C0F8(v4, 3);
  v4[1] = a1;
  return v4;
}

//----- (0007DF10) --------------------------------------------------------
__int64 __fastcall sub_7DF10(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (0007DF64) --------------------------------------------------------
int __fastcall sub_7DF64(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (0007DFBC) --------------------------------------------------------
void __fastcall sub_7DFBC(void *a1)
{
  sub_7B014(a1);
}

//----- (0007DFE0) --------------------------------------------------------
bool __fastcall sub_7DFE0(int a1, int a2)
{
  __int64 v2; // r4

  v2 = sub_7DF10(a1);
  return v2 == sub_7DF10(a2);
}

//----- (0007E034) --------------------------------------------------------
_QWORD *__fastcall sub_7E034(int a1)
{
  __int64 v1; // r0

  v1 = sub_7DF10(a1);
  return sub_7DEB4(v1);
}

//----- (0007E070) --------------------------------------------------------
double *sub_7E070()
{
  double v0; // d0
  double *v3; // [sp+Ch] [bp-8h]

  if ( fabs(v0) > 1.79769313e308 )
    return 0;
  v3 = (double *)sub_7AFCC(0x10u);
  if ( !v3 )
    return 0;
  sub_7C0F8(v3, 4);
  v3[1] = v0;
  return v3;
}
// 7E098: variable 'v0' is possibly undefined

//----- (0007E120) --------------------------------------------------------
void sub_7E120()
{
  ;
}

//----- (0007E174) --------------------------------------------------------
int __fastcall sub_7E174(int a1)
{
  double v1; // d0

  if ( !a1 || *(_DWORD *)a1 != 4 || fabs(v1) > 1.79769313e308 )
    return -1;
  *(double *)(a1 + 8) = v1;
  return 0;
}
// 7E1BC: variable 'v1' is possibly undefined

//----- (0007E218) --------------------------------------------------------
void __fastcall sub_7E218(void *a1)
{
  sub_7B014(a1);
}

//----- (0007E23C) --------------------------------------------------------
int sub_7E23C()
{
  sub_7E120();
  sub_7E120();
  return 1;
}

//----- (0007E290) --------------------------------------------------------
double *sub_7E290()
{
  sub_7E120();
  return sub_7E070();
}

//----- (0007E2C4) --------------------------------------------------------
void __fastcall sub_7E2C4(_DWORD *a1)
{
  __int64 v1; // r0

  if ( a1 && *a1 == 3 )
  {
    v1 = sub_7DF10((int)a1);
    sub_96AE4(v1);
  }
  else if ( a1 )
  {
    if ( *a1 == 4 )
      sub_7E120();
  }
}

//----- (0007E35C) --------------------------------------------------------
void *sub_7E35C()
{
  return &unk_BD5D8;
}

//----- (0007E37C) --------------------------------------------------------
void *sub_7E37C()
{
  return &unk_BD5E0;
}

//----- (0007E39C) --------------------------------------------------------
void *sub_7E39C()
{
  return &unk_BD5E8;
}

//----- (0007E3BC) --------------------------------------------------------
void __fastcall sub_7E3BC(_DWORD *a1)
{
  if ( a1 )
  {
    switch ( *a1 )
    {
      case 0:
        sub_7C1C8(a1);
        break;
      case 1:
        sub_7CD1C((int)a1);
        break;
      case 2:
        sub_7DC90((void **)a1);
        break;
      case 3:
        sub_7DFBC(a1);
        break;
      case 4:
        sub_7E218(a1);
        break;
      default:
        return;
    }
  }
}
// 7E3E8: control flows out of bounds to 7E3EC

//----- (0007E450) --------------------------------------------------------
int __fastcall sub_7E450(_DWORD *a1, _DWORD *a2)
{
  int v2; // r3

  if ( !a1 || !a2 )
    return 0;
  if ( *a1 != *a2 )
    return 0;
  if ( a1 == a2 )
    return 1;
  switch ( *a1 )
  {
    case 0:
      v2 = sub_7CA2C(a1, a2);
      break;
    case 1:
      v2 = sub_7D644(a1, a2);
      break;
    case 2:
      v2 = sub_7DCC4((int)a1, (int)a2);
      break;
    case 3:
      v2 = sub_7DFE0((int)a1, (int)a2);
      break;
    case 4:
      v2 = sub_7E23C();
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}
// 7E4CC: control flows out of bounds to 7E4D0
// 7CA2C: using guessed type int __fastcall sub_7CA2C(_DWORD, _DWORD);

//----- (0007E558) --------------------------------------------------------
void *__fastcall sub_7E558(_DWORD *a1)
{
  void *v1; // r3

  if ( !a1 )
    return 0;
  switch ( *a1 )
  {
    case 0:
      v1 = sub_7CB1C(a1);
      break;
    case 1:
      v1 = sub_7D6FC(a1);
      break;
    case 2:
      v1 = sub_7DD44((int)a1);
      break;
    case 3:
      v1 = sub_7E034((int)a1);
      break;
    case 4:
      v1 = sub_7E290();
      break;
    case 5:
    case 6:
    case 7:
      v1 = a1;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}
// 7E58C: control flows out of bounds to 7E590

//----- (0007E618) --------------------------------------------------------
void *__fastcall sub_7E618(_DWORD *a1)
{
  void *v1; // r3

  if ( !a1 )
    return 0;
  switch ( *a1 )
  {
    case 0:
      v1 = (void *)sub_7CBDC(a1);
      break;
    case 1:
      v1 = sub_7D784(a1);
      break;
    case 2:
      v1 = sub_7DD44((int)a1);
      break;
    case 3:
      v1 = sub_7E034((int)a1);
      break;
    case 4:
      v1 = sub_7E290();
      break;
    case 5:
    case 6:
    case 7:
      v1 = a1;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}
// 7E64C: control flows out of bounds to 7E650
// 7CBDC: using guessed type int __fastcall sub_7CBDC(_DWORD);

//----- (0007E6D8) --------------------------------------------------------
char *__fastcall sub_7E6D8(char *result, const char *a2)
{
  if ( result )
  {
    result[92] = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    *((_DWORD *)result + 2) = 0;
    if ( a2 )
      return sub_7E75C(result, a2);
    else
      result[12] = 0;
  }
  return result;
}

//----- (0007E75C) --------------------------------------------------------
char *__fastcall sub_7E75C(char *result, const char *a2)
{
  char *v3; // [sp+4h] [bp-10h]
  size_t v4; // [sp+Ch] [bp-8h]

  v3 = result;
  if ( result && a2 )
  {
    v4 = strlen(a2);
    if ( v4 > 0x4F )
    {
      memcpy(v3 + 12, "...", 3u);
      return strncpy(v3 + 15, &a2[v4 - 76], 0x4Du);
    }
    else
    {
      return strncpy(v3 + 12, a2, v4 + 1);
    }
  }
  return result;
}

//----- (0007E828) --------------------------------------------------------
int sub_7E828(int a1, int a2, int a3, int a4, char a5, char *format, ...)
{
  va_list va; // [sp+38h] [bp+Ch] BYREF

  va_start(va, format);
  return sub_7E884(a1, a2, a3, a4, a5, format, va);
}

//----- (0007E884) --------------------------------------------------------
int __fastcall sub_7E884(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg)
{
  int v7; // [sp+Ch] [bp-8h]

  v7 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v7 + 250) = 0;
      *(_BYTE *)(v7 + 251) = a5;
    }
  }
  return result;
}

//----- (0007E930) --------------------------------------------------------
int __fastcall sub_7E930(int a1, int a2, unsigned int a3, unsigned int a4, int a5)
{
  int v9; // r10
  unsigned int v10; // r1
  unsigned int v11; // r2
  int v12; // r0
  _BYTE v14[12]; // [sp+Ch] [bp-Ch] BYREF

  v9 = sub_81768(a2, a3, a4, a5, v14);
  if ( v9 )
    return -1;
  sub_81910(a1, (int)v14, 9u);
  if ( a2 == 1 )
  {
    v10 = a1;
    v11 = 0;
    v12 = 0;
  }
  else
  {
    v11 = a3;
    v10 = a1;
    v12 = 1;
  }
  sub_815A0(v12, v10, v11, a4, a5);
  return v9;
}

//----- (0007E9BC) --------------------------------------------------------
int __fastcall sub_7E9BC(
        int a1,
        int a2,
        unsigned int a3,
        unsigned int a4,
        char a5,
        unsigned __int8 a6,
        unsigned __int8 a7,
        unsigned __int16 a8)
{
  unsigned int v8; // r3
  float v9; // s15
  int v11; // [sp+10h] [bp+10h]

  if ( a4 <= 2 )
  {
    v8 = (unsigned __int8)aD_0[a4];
    v9 = (float)(25.0 / (float)a7) * (float)a8;
    if ( v9 >= 1600.0 && v9 < 2400.0 )
    {
      v11 = (a6 - 1) & 7
          | 0x40000000
          | (unsigned __int8)(16 * ((a5 - 1) & 7))
          | ((a7 & 0x3F) << 8)
          | ((a8 & 0xFFF) << 16) & 0xEFFFFFFF;
      return sub_7E930(a1, a2, a3, v8, v11);
    }
    if ( v9 >= 2400.0 && v9 <= 3200.0 )
    {
      v11 = (a6 - 1) & 7
          | 0x40000000
          | (unsigned __int8)(16 * ((a5 - 1) & 7))
          | ((a7 & 0x3F) << 8)
          | ((a8 & 0xFFF) << 16)
          | 0x10000000;
      return sub_7E930(a1, a2, a3, v8, v11);
    }
  }
  return -1;
}

//----- (0007EA90) --------------------------------------------------------
int __fastcall sub_7EA90(
        int a1,
        int a2,
        unsigned int a3,
        unsigned int a4,
        char a5,
        unsigned __int8 a6,
        unsigned __int8 a7,
        unsigned __int16 a8,
        _DWORD *a9)
{
  unsigned int v9; // r3
  float v10; // s15
  int v12; // [sp+14h] [bp+14h]

  if ( a4 <= 2 )
  {
    v9 = (unsigned __int8)aD_0[a4];
    v10 = (float)(25.0 / (float)a7) * (float)a8;
    if ( v10 >= 1600.0 && v10 < 2400.0 )
    {
      *a9 = (a6 - 1) & 7
          | 0x40000000
          | (unsigned __int8)(16 * ((a5 - 1) & 7))
          | ((a7 & 0x3F) << 8)
          | ((a8 & 0xFFF) << 16) & 0xEFFFFFFF;
      v12 = (a6 - 1) & 7
          | 0x40000000
          | (unsigned __int8)(16 * ((a5 - 1) & 7))
          | ((a7 & 0x3F) << 8)
          | ((a8 & 0xFFF) << 16) & 0xEFFFFFFF;
      return sub_7E930(a1, a2, a3, v9, v12);
    }
    if ( v10 >= 2400.0 && v10 <= 3200.0 )
    {
      *a9 = (a6 - 1) & 7
          | 0x40000000
          | (unsigned __int8)(16 * ((a5 - 1) & 7))
          | ((a7 & 0x3F) << 8)
          | ((a8 & 0xFFF) << 16)
          | 0x10000000;
      v12 = (a6 - 1) & 7
          | 0x40000000
          | (unsigned __int8)(16 * ((a5 - 1) & 7))
          | ((a7 & 0x3F) << 8)
          | ((a8 & 0xFFF) << 16)
          | 0x10000000;
      return sub_7E930(a1, a2, a3, v9, v12);
    }
  }
  return -1;
}

//----- (0007EB70) --------------------------------------------------------
int __fastcall sub_7EB70(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int result; // r0
  int v9; // [sp+8h] [bp-Ch] BYREF
  int v10[2]; // [sp+Ch] [bp-8h] BYREF

  if ( a2 == 1 )
  {
    sub_813D8(0, a1, 0, 0xA8u, &v9);
    sub_813D8(0, a1, 0, 0x18u, v10);
  }
  else
  {
    sub_813D8(1, a1, a3, 0xA8u, &v9);
    sub_813D8(1, a1, a3, 0x18u, v10);
  }
  if ( a4 )
  {
    LOWORD(v9) = v9 | 0x10F;
    HIWORD(v10[0]) = BYTE2(v10[0]) & 0xF0;
  }
  else
  {
    HIBYTE(v10[0]) = -1;
    LOBYTE(v9) = v9 & 0xF0;
    BYTE2(v10[0]) |= 0xFu;
  }
  result = sub_7E930(a1, a2, a3, 0xA8u, v9);
  if ( !result )
    return sub_7E930(a1, a2, a3, 0x18u, v10[0]);
  return result;
}

//----- (0007EC9C) --------------------------------------------------------
int __fastcall sub_7EC9C(unsigned int a1, int a2, unsigned int a3)
{
  int result; // r0
  int v7; // [sp+8h] [bp-8h] BYREF
  int v8; // [sp+Ch] [bp-4h] BYREF

  if ( a2 == 1 )
  {
    sub_813D8(0, a1, 0, 0xA8u, &v7);
    sub_813D8(0, a1, 0, 0x18u, &v8);
  }
  else
  {
    sub_813D8(1, a1, a3, 0xA8u, &v7);
    sub_813D8(1, a1, a3, 0x18u, &v8);
  }
  HIBYTE(v8) = -16;
  LOWORD(v7) = v7 | 0x1F0;
  BYTE2(v8) &= 0xF0u;
  result = sub_7E930(a1, a2, a3, 0xA8u, v7);
  if ( !result )
  {
    usleep(0x2710u);
    return sub_7E930(a1, a2, a3, 0x18u, v8);
  }
  return result;
}

//----- (0007EDA4) --------------------------------------------------------
int __fastcall sub_7EDA4(int a1, int a2, unsigned int a3)
{
  sub_7E930(a1, a2, a3, 0x3Cu, -2147450111);
  usleep(0x2710u);
  return sub_7E930(a1, a2, a3, 0x3Cu, -2147482624);
}

//----- (0007EE1C) --------------------------------------------------------
int __fastcall sub_7EE1C(int a1, int a2, unsigned int a3, char a4)
{
  unsigned int v5; // r4

  v5 = a4 & 3 | 0x80008F04;
  sub_7E930(a1, a2, a3, 0x3Cu, v5);
  usleep(0x2710u);
  return sub_7E930(a1, a2, a3, 0x3Cu, v5 & 0xFFFF60FF | 0x1000);
}

//----- (0007EE94) --------------------------------------------------------
int __fastcall sub_7EE94(int a1, int a2, unsigned __int8 a3, unsigned int a4, unsigned __int8 a5)
{
  return sub_7E930(a1, a2, a4, 0x3Cu, (a5 << 16) & 0x7FFF7D55 | 0x82AA | (a3 << 31));
}

//----- (0007EED4) --------------------------------------------------------
int __fastcall sub_7EED4(int a1, int a2, unsigned __int8 a3, unsigned int a4, unsigned __int8 a5)
{
  return sub_7E930(a1, a2, a4, 0x3Cu, (a5 << 16) & 0x7FFF7DFF | 0x8200 | (a3 << 31));
}

//----- (0007EF10) --------------------------------------------------------
int __fastcall sub_7EF10(int a1, int a2, unsigned int a3, char a4)
{
  return sub_7E930(a1, a2, a3, 0x3Cu, (unsigned __int8)(2 * (a4 & 3)) | 0x80008B00);
}

//----- (0007EF54) --------------------------------------------------------
int __fastcall sub_7EF54(int a1, int a2, unsigned int a3, char a4, char a5, char a6)
{
  unsigned __int8 v6; // r12

  if ( a6 )
    v6 = (8 * (a4 & 7)) & 0x3F | ((a5 & 3) << 6) | 1;
  else
    v6 = (8 * (a4 & 7)) & 0x3E | ((a5 & 3) << 6);
  return sub_7E930(a1, a2, a3, 0x3Cu, v6 | 0x80008000);
}

//----- (0007EF94) --------------------------------------------------------
int __fastcall sub_7EF94(int a1, int a2, unsigned int a3, int a4)
{
  char v4; // r12
  bool v5; // zf

  v5 = a4 == 0;
  if ( a4 )
    v4 = 0;
  else
    LOBYTE(a4) = 1;
  if ( !v5 )
    LOBYTE(a4) = v4;
  return sub_7E930(a1, a2, a3, 0x3Cu, (unsigned __int8)a4 | 0x80008700);
}
// 7EFAC: variable 'v4' is possibly undefined

//----- (0007EFE0) --------------------------------------------------------
int __fastcall sub_7EFE0(int a1, int a2, unsigned int a3, int a4)
{
  bool v4; // zf
  char v5; // r3

  v4 = a4 == 0;
  v5 = -1;
  if ( !v4 )
    v5 = -2;
  return sub_7E930(a1, a2, a3, 0x3Cu, v5 & 0xEB | 0x80008D04);
}

//----- (0007F02C) --------------------------------------------------------
int __fastcall sub_7F02C(int a1, int a2, unsigned int a3, int a4)
{
  if ( a4 )
    LOBYTE(a4) = 64;
  return sub_7E930(a1, a2, a3, 0x3Cu, (unsigned __int8)a4 | 0x80009600);
}

//----- (0007F06C) --------------------------------------------------------
int __fastcall sub_7F06C(int a1, int a2, const char *a3, unsigned int a4)
{
  int v4; // r8
  unsigned int v5; // r6
  int v6; // r2
  int v8; // r7

  v5 = (unsigned int)a3;
  if ( a4 > 3 )
    v4 = 49925;
  else
    a3 = "\b`d";
  if ( a4 > 3 )
    v6 = v4;
  else
    v6 = (int)&a3[4 * a4];
  if ( a4 > 3 )
    HIWORD(v6) = 8204;
  else
    v6 = *(_DWORD *)(v6 + 4);
  if ( a4 > 3 )
    HIWORD(v4) = 8236;
  else
    v4 = v6 | 0x200000;
  v8 = ((_BYTE)a4 + 4) & 0xF;
  sub_7E930(a1, a2, v5, 0xB8u, v6);
  sub_7E930(a1, a2, v5, 0xB9u, (int)_xstat);
  sub_7E930(a1, a2, v5, 0xBAu, 272);
  sub_7E930(a1, a2, v5, 0x54u, v8);
  sub_7E930(a1, a2, v5, 0xB8u, v4);
  return 0;
}
// 7F088: variable 'v4' is possibly undefined

//----- (0007F13C) --------------------------------------------------------
int __fastcall sub_7F13C(int a1, unsigned int a2, char a3, int a4)
{
  char v4; // lr

  v4 = a4 != 0;
  if ( !a4 )
    v4 &= ~1u;
  return sub_7E930(a1, 1, a2, 0x3Cu, v4 & 0x9F | (unsigned __int8)(32 * (a3 & 3)) | 0x80008800);
}

//----- (0007F190) --------------------------------------------------------
int __fastcall sub_7F190(int a1)
{
  _BYTE v3[8]; // [sp+0h] [bp-8h] BYREF

  if ( sub_818C4(v3) )
    return -1;
  else
    return sub_81910(a1, (int)v3, 5u);
}

//----- (0007F1CC) --------------------------------------------------------
int __fastcall sub_7F1CC(int a1, char a2)
{
  _BYTE v4[8]; // [sp+0h] [bp-8h] BYREF

  if ( sub_81800(a2, v4) )
    return -1;
  else
    return sub_81910(a1, (int)v4, 5u);
}

//----- (0007F210) --------------------------------------------------------
int __fastcall sub_7F210(int a1, int a2, char a3, char a4)
{
  _BYTE v6[8]; // [sp+0h] [bp-8h] BYREF

  if ( sub_81854(a2, a3, a4, v6) )
    return -1;
  else
    return sub_81910(a1, (int)v6, 5u);
}

//----- (0007F25C) --------------------------------------------------------
int __fastcall sub_7F25C(int a1)
{
  return sub_7F210(a1, 1, 0, 0);
}

//----- (0007F270) --------------------------------------------------------
int __fastcall sub_7F270(int a1, unsigned int a2)
{
  char v3; // r8
  unsigned int v4; // r6
  int v5; // r4
  char v6; // r5

  v3 = a2;
  v4 = sub_962A0(0x100u, a2);
  if ( v4 )
  {
    v5 = 0;
    v6 = 0;
    do
    {
      sub_7F1CC(a1, v6);
      ++v5;
      usleep(0x2710u);
      v6 += v3;
    }
    while ( v5 != v4 );
  }
  return 0;
}

//----- (0007F2C0) --------------------------------------------------------
int __fastcall sub_7F2C0(int a1, char a2, int a3)
{
  int v4; // r4
  char v7; // r5

  if ( a3 )
  {
    v4 = 0;
    v7 = 0;
    do
    {
      sub_7F1CC(a1, v7);
      ++v4;
      usleep(0x2710u);
      v7 += a2;
    }
    while ( a3 != v4 );
  }
  return 0;
}

//----- (0007F308) --------------------------------------------------------
int __fastcall sub_7F308(unsigned int a1, unsigned int a2)
{
  unsigned int v4; // r7
  char v5; // r12
  char v6; // r0
  __int16 v7; // r2
  char v9; // r0
  int v10; // [sp+8h] [bp-8h] BYREF
  unsigned int v11; // [sp+Ch] [bp-4h] BYREF

  v4 = 8 * a2;
  if ( a2 <= (unsigned int)&unk_2DC6C0 )
  {
    sub_813D8(0, a1, 0, 0x28u, &v11);
    v9 = sub_962A0(0x17D7840u, v4);
    v11 = v11 & 0xFFFE00FF | ((unsigned __int8)(v9 - 1) << 8);
    HIBYTE(v11) &= 0xA3u;
  }
  else
  {
    sub_813D8(0, a1, 0, 0x60u, &v10);
    HIBYTE(v10) = HIBYTE(v10) & 0x9F | 0x40;
    BYTE1(v10) = BYTE1(v10) & 0xC0 | 1;
    LOBYTE(v10) = v10 & 0x88 | 0x11;
    v5 = (unsigned __int16)(HIWORD(v10) & 0xF000 | 0x60) >> 8;
    BYTE2(v10) = 96;
    HIBYTE(v10) = v5 | 0x10;
    sub_7E930(a1, 1, 0, 0x60u, v10);
    usleep(0x2710u);
    sub_7E930(a1, 1, 0, 0x60u, v10);
    usleep(0x2710u);
    sub_813D8(0, a1, 0, 0x28u, &v11);
    v6 = sub_962A0(0x17D78400u, v4);
    v11 = v11 & 0xFFFE00FF | ((unsigned __int8)(v6 - 1) << 8);
    HIBYTE(v11) &= 0xE7u;
    v7 = HIWORD(v11) & 0xFC0F | 0x50;
    BYTE2(v11) = BYTE2(v11) & 0xF | 0x50;
    HIBYTE(v11) = HIBYTE(v7) | 0x84;
  }
  sub_7E930(a1, 1, 0, 0x28u, v11);
  usleep(0x2710u);
  usleep(0xC350u);
  sub_649D8(a1, (void *)a2);
  return 0;
}

//----- (0007F4DC) --------------------------------------------------------
int __fastcall sub_7F4DC(int a1, unsigned int a2)
{
  return sub_7E930(
           a1,
           1,
           0,
           0x14u,
           (unsigned __int8)aD_0[(unsigned __int8)a2 + 20]
         | (unsigned __int16)((unsigned __int8)aD_0[BYTE1(a2) + 20] << 8)
         | ((unsigned __int8)aD_0[BYTE2(a2) + 20] << 16) & 0xFFFFFF
         | ((unsigned __int8)aD_0[HIBYTE(a2) + 20] << 24));
}

//----- (0007F548) --------------------------------------------------------
int __fastcall sub_7F548(int a1, unsigned int a2, unsigned int a3)
{
  return sub_7E930(
           a1,
           0,
           a3,
           0x14u,
           (unsigned __int8)aD_0[(unsigned __int8)a2 + 20]
         | (unsigned __int16)((unsigned __int8)aD_0[BYTE1(a2) + 20] << 8)
         | ((unsigned __int8)aD_0[BYTE2(a2) + 20] << 16) & 0xFFFFFF
         | ((unsigned __int8)aD_0[HIBYTE(a2) + 20] << 24));
}

//----- (0007F5B0) --------------------------------------------------------
int __fastcall sub_7F5B0(int a1, int a2, unsigned __int16 a3)
{
  int v3; // r3

  if ( a2 )
    v3 = 0x80000000;
  else
    v3 = 0;
  if ( !a2 )
    v3 = v3 & 0x7FFFFFFF | ((unsigned __int8)v3 << 31);
  return sub_7E930(a1, 1, 0, 0xCu, v3 & 0xFFFF0000 | a3);
}

//----- (0007F5E8) --------------------------------------------------------
int __fastcall sub_7F5E8(int a1, unsigned int a2, int a3, unsigned __int16 a4)
{
  int v4; // r12

  if ( a3 )
    v4 = 0x80000000;
  else
    v4 = 0;
  if ( !a3 )
    v4 = v4 & 0x7FFFFFFF | ((unsigned __int8)v4 << 31);
  return sub_7E930(a1, 0, a2, 0xCu, v4 & 0xFFFF0000 | a4);
}

//----- (0007F620) --------------------------------------------------------
int __fastcall sub_7F620(int a1, int a2, unsigned int a3)
{
  int v4; // r7
  unsigned int v5; // r5
  int v8; // r11
  unsigned int v9; // r4
  unsigned int v10; // r0
  unsigned __int16 v11; // r0
  int v12; // r0

  if ( !a3 )
    return 0;
  v5 = 0;
  v4 = 0;
  v8 = 65537 * a3 - 1;
  v9 = a3 - 1;
  do
  {
    v10 = v9;
    v9 += 0x10000;
    v11 = sub_962A0(v10, a3);
    v12 = sub_7E930(a1, 0, v5, 0xCu, v11 | 0x80000000);
    v5 += a2;
    v4 |= v12;
  }
  while ( v9 != v8 );
  return v4;
}

//----- (0007F69C) --------------------------------------------------------
int __fastcall sub_7F69C(unsigned int a1, int a2, unsigned int a3, int a4, char a5, char a6, char a7)
{
  _BOOL4 v12; // r0
  char v14; // r3
  char v15; // r3
  char v16; // r3
  char v17; // r3
  int v18; // r1
  int v19; // r0
  int v21; // [sp+Ch] [bp-4h] BYREF

  v12 = a2 != 1;
  sub_813D8(v12, a1, a3, 0xB0u, &v21);
  if ( a4 )
    v14 = BYTE2(v21) | 2;
  else
    v14 = BYTE2(v21) & 0xFD;
  BYTE2(v21) = v14;
  if ( a5 )
    v15 = HIBYTE(v21) | 1;
  else
    v15 = HIBYTE(v21) & 0xFE;
  HIBYTE(v21) = v15;
  if ( a6 )
    v16 = v15 | 0x10;
  else
    v16 = v15 & 0xEF;
  HIBYTE(v21) = v16;
  if ( a7 )
    v17 = v16 | 0x80;
  else
    v17 = v16 & 0x7F;
  HIBYTE(v21) = v17;
  if ( a2 == 1 )
  {
    v18 = 1;
    v19 = a1;
  }
  else
  {
    v19 = a1;
    v18 = 0;
  }
  return sub_7E930(v19, v18, a3, 0xB0u, v21);
}

//----- (0007F764) --------------------------------------------------------
int __fastcall sub_7F764(unsigned int a1, int a2, unsigned int a3, char a4)
{
  char v7; // r12
  unsigned int v8; // r2
  int v9; // r0
  int v10; // r1
  int v12[2]; // [sp+Ch] [bp-8h] BYREF

  if ( a2 == 1 )
  {
    sub_813D8(0, a1, a3, 0xB0u, v12);
    v7 = HIBYTE(v12[0]);
    v8 = a3;
    v10 = 1;
    v9 = a1;
  }
  else
  {
    sub_813D8(1, a1, a3, 0xB0u, v12);
    v7 = HIBYTE(v12[0]);
    v8 = a3;
    v9 = a1;
    v10 = 0;
  }
  HIBYTE(v12[0]) = v7 & 0xDF | (32 * (a4 & 1));
  return sub_7E930(v9, v10, v8, 0xB0u, v12[0]);
}

//----- (0007F7FC) --------------------------------------------------------
int __fastcall sub_7F7FC(int a1, char a2)
{
  return sub_7F210(a1, 0, a2, 180);
}

//----- (0007F80C) --------------------------------------------------------
int __fastcall sub_7F80C(int a1, _BYTE *a2, float *a3)
{
  float v3; // s0
  int v4; // r12
  int v5; // r4
  int v7; // r5
  int v8; // r8
  int v9; // r2
  int v10; // r9
  int v11; // r11
  float v12; // s11
  int v14; // r1
  float v15; // s13
  int v16; // r0
  int v17; // lr
  int v18; // r3
  float v19; // s7
  int v20; // s14
  float v21; // s15
  float v22; // s15
  float v23; // s16

  v4 = 2;
  v5 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 2;
  v10 = 0;
  v11 = 0;
  v12 = 10.0;
  while ( 1 )
  {
    v14 = 1;
    v15 = (float)v9;
    do
    {
      v16 = v14 * v14;
      v17 = (unsigned __int8)v14;
      v18 = v14;
      v19 = (float)v14 * v3;
      do
      {
        v20 = (int)((float)((float)((float)((float)v18 * v19) * v15) / 25.0) + 0.5);
        if ( (unsigned int)(v20 - 16) <= 0xEA )
        {
          v21 = (float)v20 * (float)(25.0 / (float)v9);
          if ( (v9 != 1 || v21 <= 3125.0) && v21 <= 3200.0 && v21 >= 2000.0 )
          {
            v22 = fabsf(v3 - (float)(v21 / (float)v16));
            if ( v22 < v12 )
            {
              v8 = (unsigned __int8)v14;
              v10 = v17;
              v12 = v22;
              v11 = v9;
              v5 = (int)((float)((float)((float)((float)v18 * v19) * v15) / 25.0) + 0.5);
              v7 = 1;
            }
          }
        }
        ++v18;
        v16 += v14;
        v17 = (unsigned __int8)v18;
      }
      while ( (unsigned __int8)v18 != 8 );
      ++v14;
    }
    while ( v14 != 8 );
    v9 = 1;
    if ( v4 == 1 )
      break;
    v4 = 1;
  }
  if ( v5 )
  {
    v23 = (float)((float)(25.0 / (float)v11) * (float)v5) / (float)(v7 * (__int16)v10 * (__int16)v8);
    if ( a3 )
      *a3 = v23;
    printf(
      "final refdiv: %d, fbdiv: %d, postdiv1: %d, postdiv2: %d, usr divider: %d, min diff value: %f\n",
      v11,
      v5,
      v10,
      v8,
      v7,
      v12);
    printf("Want freq: %f, Real freq: %f\n", v3, v23);
    *(_BYTE *)a1 = v10;
    *(_BYTE *)(a1 + 1) = v8;
    *(_BYTE *)(a1 + 2) = v11;
    *(_WORD *)(a1 + 4) = v5;
    *a2 = v7;
    a2[1] = v7;
    a2[2] = v7;
    a2[3] = v7;
    return 0;
  }
  else
  {
    puts("find div fail, use default value");
    return -1;
  }
}
// 7F888: variable 'v3' is possibly undefined

//----- (0007FA34) --------------------------------------------------------
int __fastcall sub_7FA34(int a1, int a2, unsigned int a3, unsigned int a4, float a5)
{
  _BYTE v10[4]; // [sp+14h] [bp-10h] BYREF
  char v11[4]; // [sp+18h] [bp-Ch] BYREF
  unsigned __int16 v12; // [sp+1Ch] [bp-8h]

  if ( sub_7F80C((int)v11, v10, 0) )
    return -1;
  else
    return sub_7E9BC(a1, a2, a3, a4, v11[0], v11[1], v11[2], v12);
}

//----- (0007FAAC) --------------------------------------------------------
int __fastcall sub_7FAAC(int a1, unsigned int a2, int a3, unsigned __int16 a4)
{
  return sub_7E9BC(a1, 1, 0, a2, a3, BYTE1(a3), BYTE2(a3), a4);
}

//----- (0007FB40) --------------------------------------------------------
int __fastcall sub_7FB40(int a1, unsigned int a2, unsigned int a3, int a4, unsigned __int16 a5)
{
  return sub_7E9BC(a1, 0, a2, a3, a4, BYTE1(a4), BYTE2(a4), a5);
}

//----- (0007FB90) --------------------------------------------------------
int __fastcall sub_7FB90(int a1, unsigned int a2, unsigned int a3, int a4, unsigned __int16 a5, _DWORD *a6)
{
  return sub_7EA90(a1, 0, a2, a3, a4, BYTE1(a4), BYTE2(a4), a5, a6);
}

//----- (0007FBE8) --------------------------------------------------------
int __fastcall sub_7FBE8(unsigned int a1, unsigned int a2, unsigned int a3, char a4, char a5)
{
  unsigned int v7; // r8
  int v10; // [sp+Ch] [bp-4h] BYREF

  if ( a3 > 2 )
    return -1;
  v7 = (unsigned __int8)aD_0[a3];
  sub_813D8(1, a1, a2, v7, &v10);
  LOBYTE(v10) = v10 & 0x88 | (16 * (a4 & 7)) | a5 & 7;
  return sub_7E930(a1, 0, a2, v7, v10);
}

//----- (0007FCEC) --------------------------------------------------------
int __fastcall sub_7FCEC(int a1, unsigned int a2, unsigned int a3, float a4)
{
  return sub_7FA34(a1, 0, a2, a3, a4);
}

//----- (0007FD10) --------------------------------------------------------
int __fastcall sub_7FD10(int a1, unsigned int a2, float a3)
{
  return sub_7FA34(a1, 1, 0, a2, a3);
}

//----- (0007FD34) --------------------------------------------------------
int __fastcall sub_7FD34(int a1, unsigned int a2, char a3)
{
  return sub_7E930(a1, 0, a2, 0x54u, a3 & 0xF);
}

//----- (0007FD60) --------------------------------------------------------
int __fastcall sub_7FD60(int a1, char a2)
{
  return sub_7E930(a1, 1, 0, 0x54u, a2 & 0xF);
}

//----- (0007FD8C) --------------------------------------------------------
int __fastcall sub_7FD8C(int a1)
{
  return sub_7F210(a1, 1, 0, 72);
}

//----- (0007FD9C) --------------------------------------------------------
int __fastcall sub_7FD9C(unsigned int a1, int a2, int a3, __int16 a4)
{
  char v7; // r3
  int v9; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(0, a1, 0, 0xA4u, &v9);
  LOWORD(v9) = a4;
  if ( a2 )
    v7 = HIBYTE(v9) | 0x80;
  else
    v7 = HIBYTE(v9) & 0x7F;
  HIBYTE(v9) = v7 & 0x8F | 0x10;
  return sub_7E930(a1, 1, 0, 0xA4u, v9);
}

//----- (0007FE84) --------------------------------------------------------
int __fastcall sub_7FE84(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(0, a1, 0, 0xC4u, &v3);
  BYTE1(v3) = BYTE1(v3) & 0x1F | 0xA0;
  sub_7E930(a1, 1, 0, 0xC4u, v3);
  usleep(0x4E20u);
  return 0;
}

//----- (0007FF54) --------------------------------------------------------
int __fastcall sub_7FF54(unsigned int a1, unsigned int a2, int a3)
{
  char v6; // r3
  int v8; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(1, a1, a2, 0x18u, &v8);
  if ( a3 )
    v6 = BYTE1(v8) | 3;
  else
    v6 = BYTE1(v8) & 0xFD;
  if ( !a3 )
    v6 &= ~1u;
  BYTE1(v8) = v6;
  return sub_7E930(a1, 0, a2, 0x18u, v8);
}

//----- (0007FFC0) --------------------------------------------------------
int __fastcall sub_7FFC0(unsigned int a1, int a2)
{
  char v4; // r3
  int v6; // [sp+Ch] [bp-8h] BYREF

  sub_813D8(0, a1, 0, 0x18u, &v6);
  if ( a2 )
    v4 = BYTE1(v6) | 0x80;
  else
    v4 = BYTE1(v6) & 0x7F;
  BYTE1(v6) = v4;
  return sub_7E930(a1, 1, 0, 0x18u, v6);
}

//----- (00080138) --------------------------------------------------------
int __fastcall sub_80138(int a1, unsigned int a2, char a3, unsigned __int8 a4)
{
  return sub_7E930(a1, 0, a2, 0x3Cu, a4 | ((a3 & 0x1F) << 8) & 0x7FFF | 0x80008000);
}

//----- (00080174) --------------------------------------------------------
int __fastcall sub_80174(unsigned int a1, int a2, unsigned int a3, int a4)
{
  char v8; // r0
  int result; // r0
  int v10; // [sp+8h] [bp-Ch] BYREF
  int v11[2]; // [sp+Ch] [bp-8h] BYREF

  if ( a2 == 1 )
  {
    sub_813D8(0, a1, 0, 0xA8u, &v10);
    sub_813D8(0, a1, 0, 0x18u, v11);
  }
  else
  {
    sub_813D8(1, a1, a3, 0xA8u, &v10);
    sub_813D8(1, a1, a3, 0x18u, v11);
  }
  LOWORD(v10) = v10 | 0x1F0;
  v8 = HIBYTE(v11[0]) & 0xF0;
  HIWORD(v11[0]) &= 0xF0F0u;
  if ( a4 )
  {
    HIBYTE(v11[0]) = v8 | 0xF0;
  }
  else
  {
    printf("disable core return nonce");
    HIBYTE(v11[0]) &= 0xFu;
  }
  result = sub_7E930(a1, a2, a3, 0xA8u, v10);
  if ( !result )
  {
    usleep(0x2710u);
    return sub_7E930(a1, a2, a3, 0x18u, v11[0]);
  }
  return result;
}

//----- (000802B4) --------------------------------------------------------
int __fastcall sub_802B4(unsigned int a1, int a2, unsigned int a3, int a4)
{
  char v8; // r2
  char v9; // r3
  int v11[2]; // [sp+Ch] [bp-8h] BYREF

  if ( a2 == 1 )
    sub_813D8(0, a1, 0, 0x18u, v11);
  else
    sub_813D8(1, a1, a3, 0x18u, v11);
  if ( a4 )
    v8 = HIBYTE(v11[0]) | 0xF;
  else
    v8 = HIBYTE(v11[0]) & 0xF0;
  if ( a4 )
    v9 = BYTE2(v11[0]) | 0xF;
  else
    v9 = BYTE2(v11[0]) & 0xF0;
  HIBYTE(v11[0]) = v8;
  BYTE2(v11[0]) = v9;
  return sub_7E930(a1, a2, a3, 0x18u, v11[0]);
}

//----- (000803AC) --------------------------------------------------------
int __fastcall sub_803AC(unsigned int a1, int a2)
{
  return sub_7EB70(a1, 1, 0, a2);
}

//----- (000804A0) --------------------------------------------------------
int __fastcall sub_804A0(unsigned int a1, unsigned int a2, int a3)
{
  return sub_7EB70(a1, 0, a2, a3);
}

//----- (000804B0) --------------------------------------------------------
int __fastcall sub_804B0(unsigned int a1, unsigned int a2)
{
  return sub_7EC9C(a1, 0, a2);
}

//----- (000804BC) --------------------------------------------------------
int __fastcall sub_804BC(unsigned int a1)
{
  return sub_7EC9C(a1, 1, 0);
}

//----- (000804C8) --------------------------------------------------------
int __fastcall sub_804C8(int a1, int a2)
{
  return sub_7E930(a1, 1, 0, 0x10u, a2);
}

//----- (000804EC) --------------------------------------------------------
int __fastcall sub_804EC(int a1, unsigned int a2, int a3)
{
  return sub_7E930(a1, 0, a2, 0x10u, a3);
}

//----- (00080510) --------------------------------------------------------
int __fastcall sub_80510(int a1)
{
  return sub_7EDA4(a1, 1, 0);
}

//----- (0008051C) --------------------------------------------------------
int __fastcall sub_8051C(int a1, unsigned int a2)
{
  return sub_7EDA4(a1, 0, a2);
}

//----- (00080528) --------------------------------------------------------
int __fastcall sub_80528(int a1, char a2)
{
  return sub_7EE1C(a1, 1, 0, a2);
}

//----- (00080538) --------------------------------------------------------
int __fastcall sub_80538(int a1, unsigned int a2, char a3)
{
  return sub_7EE1C(a1, 0, a2, a3);
}

//----- (00080548) --------------------------------------------------------
int __fastcall sub_80548(int a1)
{
  return sub_7EE94(a1, 1, 1u, 0, 0);
}

//----- (0008056C) --------------------------------------------------------
int __fastcall sub_8056C(int a1, unsigned int a2)
{
  return sub_7EE94(a1, 0, 1u, a2, 0);
}

//----- (00080594) --------------------------------------------------------
int __fastcall sub_80594(int a1, unsigned __int8 a2)
{
  return sub_7EE94(a1, 1, 0, 0, a2);
}

//----- (000805B8) --------------------------------------------------------
int __fastcall sub_805B8(int a1, unsigned int a2, unsigned __int8 a3)
{
  return sub_7EE94(a1, 0, 0, a2, a3);
}

//----- (000805DC) --------------------------------------------------------
int __fastcall sub_805DC(int a1)
{
  return sub_7EED4(a1, 1, 1u, 0, 0);
}

//----- (00080600) --------------------------------------------------------
int __fastcall sub_80600(int a1, unsigned int a2)
{
  return sub_7EED4(a1, 0, 1u, a2, 0);
}

//----- (00080628) --------------------------------------------------------
int __fastcall sub_80628(int a1, unsigned __int8 a2)
{
  return sub_7EED4(a1, 1, 0, 0, a2);
}

//----- (0008064C) --------------------------------------------------------
int __fastcall sub_8064C(int a1, unsigned int a2, unsigned __int8 a3)
{
  return sub_7EED4(a1, 0, 0, a2, a3);
}

//----- (00080670) --------------------------------------------------------
int __fastcall sub_80670(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(0, a1, 0, 0xD0u, &v3);
  BYTE1(v3) |= 8u;
  return sub_7E930(a1, 1, 0, 0xD0u, v3);
}

//----- (000806C8) --------------------------------------------------------
int __fastcall sub_806C8(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(0, a1, 0, 0x18u, &v3);
  LOBYTE(v3) = v3 | 4;
  return sub_7E930(a1, 1, 0, 0x18u, v3);
}

//----- (00080720) --------------------------------------------------------
int __fastcall sub_80720(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(0, a1, 0, 0x18u, &v3);
  LOBYTE(v3) = v3 & 0xFB;
  return sub_7E930(a1, 1, 0, 0x18u, v3);
}

//----- (00080778) --------------------------------------------------------
int __fastcall sub_80778(int a1, int a2)
{
  return sub_7E930(a1, 1, 0, 0xDCu, a2);
}

//----- (0008079C) --------------------------------------------------------
int __fastcall sub_8079C(int a1, char a2)
{
  return sub_7E930(a1, 1, 0, 0xD0u, (16 * ((a2 - 1) & 7)) | 0x38001801);
}

//----- (000807D4) --------------------------------------------------------
int __fastcall sub_807D4(unsigned int a1)
{
  int v3; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(0, a1, 0, 0xD0u, &v3);
  LOBYTE(v3) = v3 | 0x8A;
  HIBYTE(v3) |= 8u;
  BYTE1(v3) &= ~8u;
  return sub_7E930(a1, 1, 0, 0xD0u, v3);
}

//----- (000808C0) --------------------------------------------------------
int __fastcall sub_808C0(int a1)
{
  return sub_7F210(a1, 1, 0, 208);
}

//----- (00080924) --------------------------------------------------------
int __fastcall sub_80924(int a1)
{
  return sub_7F210(a1, 1, 0, 216);
}

//----- (00080934) --------------------------------------------------------
int __fastcall sub_80934(int a1)
{
  return sub_7F210(a1, 1, 0, 240);
}

//----- (00080944) --------------------------------------------------------
int __fastcall sub_80944(int a1)
{
  return sub_7F210(a1, 1, 0, 224);
}

//----- (00080954) --------------------------------------------------------
int __fastcall sub_80954(int a1, char a2, char a3, char a4)
{
  return sub_7E930(a1, 1, 0, 0xECu, a4 & 3 | (4 * (a3 & 1)) & 0xF7 | (8 * (a2 & 1)));
}

//----- (00080988) --------------------------------------------------------
int __fastcall sub_80988(int a1, unsigned int a2, char a3, char a4, char a5)
{
  return sub_7E930(a1, 0, a2, 0xECu, a5 & 3 | (4 * (a4 & 1)) & 0xF7 | (8 * (a3 & 1)));
}

//----- (000809B8) --------------------------------------------------------
int __fastcall sub_809B8(int a1, int a2)
{
  return sub_7E930(a1, 1, 0, 0xE4u, a2);
}

//----- (000809DC) --------------------------------------------------------
int __fastcall sub_809DC(int a1, unsigned int a2, int a3)
{
  return sub_7E930(a1, 0, a2, 0xE4u, a3);
}

//----- (00080A00) --------------------------------------------------------
int __fastcall sub_80A00(int a1, int a2)
{
  return sub_7E930(a1, 1, 0, 0xE8u, a2);
}

//----- (00080A24) --------------------------------------------------------
int __fastcall sub_80A24(int a1, unsigned int a2, int a3)
{
  return sub_7E930(a1, 0, a2, 0xE8u, a3);
}

//----- (00080A48) --------------------------------------------------------
int __fastcall sub_80A48(int a1, int a2)
{
  int v2; // r3

  if ( a2 )
    v2 = -1342177280;
  else
    v2 = 0;
  return sub_7E930(a1, 1, 0, 0x9Cu, v2);
}

//----- (00080A84) --------------------------------------------------------
int __fastcall sub_80A84(int a1, unsigned int a2, int a3)
{
  if ( a3 )
    LOBYTE(a3) = 11;
  return sub_7E930(a1, 0, a2, 0x9Cu, (unsigned __int8)a3 << 28);
}

//----- (00080AB8) --------------------------------------------------------
int __fastcall sub_80AB8(int a1, unsigned int a2, unsigned __int16 a3, char a4, char a5)
{
  return sub_7E930(a1, 0, a2, 0x2Cu, a5 & 1 | (unsigned __int16)(2 * (a4 & 1)) | (a3 << 16));
}

//----- (00080AE8) --------------------------------------------------------
int __fastcall sub_80AE8(unsigned int a1, char a2)
{
  int v5; // [sp+Ch] [bp-8h] BYREF

  sub_813D8(0, a1, 0, 0x18u, &v5);
  LOBYTE(v5) = v5 & 0xF7 | (8 * (a2 & 1));
  return sub_7E930(a1, 1, 0, 0x18u, v5);
}

//----- (00080B44) --------------------------------------------------------
int __fastcall sub_80B44(unsigned int a1, unsigned int a2, char a3)
{
  int v7; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(0, a1, a2, 0x18u, &v7);
  LOBYTE(v7) = v7 & 0xF7 | (8 * (a3 & 1));
  return sub_7E930(a1, 0, a2, 0x18u, v7);
}

//----- (00080BA4) --------------------------------------------------------
int __fastcall sub_80BA4(int a1, unsigned int a2, unsigned __int8 a3, char a4)
{
  return sub_7E930(a1, 0, a2, 0x3Cu, (unsigned __int8)(2 * (a4 & 3)) | 0x8B00 | (a3 << 16) & 0xFFFFFF);
}

//----- (00080BF0) --------------------------------------------------------
int __fastcall sub_80BF0(int a1, unsigned int a2, int a3, char a4)
{
  return sub_7EF10(a1, 0, a2, a4);
}

//----- (00080BFC) --------------------------------------------------------
int __fastcall sub_80BFC(int a1, int a2, char a3)
{
  return sub_7EF10(a1, 1, 0, a3);
}

//----- (00080C0C) --------------------------------------------------------
int __fastcall sub_80C0C(int a1, unsigned int a2, char a3, char a4, char a5)
{
  return sub_7EF54(a1, 0, a2, a3, a4, a5);
}

//----- (00080C38) --------------------------------------------------------
int __fastcall sub_80C38(int a1, char a2, char a3, char a4)
{
  return sub_7EF54(a1, 1, 0, a2, a3, a4);
}

//----- (00080C60) --------------------------------------------------------
int __fastcall sub_80C60(int a1, int a2)
{
  return sub_7EF94(a1, 1, 0, a2);
}

//----- (00080C70) --------------------------------------------------------
int __fastcall sub_80C70(int a1, unsigned int a2, int a3)
{
  return sub_7EF94(a1, 0, a2, a3);
}

//----- (00080C80) --------------------------------------------------------
int __fastcall sub_80C80(int a1, int a2)
{
  return sub_7EFE0(a1, 1, 0, a2);
}

//----- (00080C90) --------------------------------------------------------
int __fastcall sub_80C90(int a1, unsigned int a2, int a3)
{
  return sub_7EFE0(a1, 0, a2, a3);
}

//----- (00080CA0) --------------------------------------------------------
int __fastcall sub_80CA0(int a1, char a2, int a3)
{
  return sub_7F13C(a1, 0, a2, a3);
}

//----- (00080CB4) --------------------------------------------------------
int __fastcall sub_80CB4(int a1, unsigned int a2)
{
  return sub_7E930(a1, 0, a2, 0x3Cu, 0x80000000);
}

//----- (00080CF0) --------------------------------------------------------
int __fastcall sub_80CF0(int a1, unsigned int a2)
{
  return sub_7E930(a1, 0, a2, 0x3Cu, -2147480320);
}

//----- (00080D30) --------------------------------------------------------
int __fastcall sub_80D30(int a1, char a2)
{
  return sub_7F210(a1, 0, a2, 224);
}

//----- (00080D40) --------------------------------------------------------
int __fastcall sub_80D40(int a1, int a2)
{
  return sub_7F02C(a1, 1, 0, a2);
}

//----- (00080D50) --------------------------------------------------------
int __fastcall sub_80D50(int a1, unsigned int a2, int a3)
{
  return sub_7F02C(a1, 0, a2, a3);
}

//----- (00080D60) --------------------------------------------------------
int __fastcall sub_80D60(int a1, int a2)
{
  int v2; // r3

  if ( a2 )
    v2 = 3;
  else
    v2 = 0;
  return sub_7E930(a1, 1, 0, 0x20u, v2);
}

//----- (00080D94) --------------------------------------------------------
int __fastcall sub_80D94(int a1, unsigned int a2, int a3)
{
  int v3; // r3

  if ( a3 )
    v3 = 3;
  else
    v3 = 0;
  return sub_7E930(a1, 0, a2, 0x20u, v3);
}

//----- (00080E94) --------------------------------------------------------
int __fastcall sub_80E94(int a1, char a2)
{
  return sub_7E930(a1, 1, 0, 0x3Cu, ((a2 & 0x1F) << 8) & 0x7FFF | 0x80000000);
}

//----- (00080EC8) --------------------------------------------------------
int __fastcall sub_80EC8(int a1, unsigned int a2, char a3)
{
  return sub_7E930(a1, 0, a2, 0x3Cu, ((a3 & 0x1F) << 8) & 0x7FFF | 0x80000000);
}

//----- (00080EFC) --------------------------------------------------------
int __fastcall sub_80EFC(int a1, char a2)
{
  return sub_7E930(a1, 1, 0, 0x3Cu, ((a2 & 0x1F) << 8) & 0x7FFF);
}

//----- (00080F30) --------------------------------------------------------
int __fastcall sub_80F30(int a1, unsigned int a2, char a3)
{
  return sub_7E930(a1, 0, a2, 0x3Cu, ((a3 & 0x1F) << 8) & 0x7FFF);
}

//----- (00080FCC) --------------------------------------------------------
int __fastcall sub_80FCC(unsigned int a1, unsigned int a2, char a3)
{
  int v7; // [sp+Ch] [bp-4h] BYREF

  sub_813D8(1, a1, a2, 0x58u, &v7);
  BYTE1(v7) = BYTE1(v7) & 0xF | (16 * (a3 & 0xF));
  return sub_7E930(a1, 0, a2, 0x58u, v7);
}

//----- (0008102C) --------------------------------------------------------
int __fastcall sub_8102C(unsigned int a1, char a2)
{
  int v5; // [sp+Ch] [bp-8h] BYREF

  sub_813D8(0, a1, 0, 0x58u, &v5);
  BYTE1(v5) = BYTE1(v5) & 0xF | (16 * (a2 & 0xF));
  return sub_7E930(a1, 1, 0, 0x58u, v5);
}

//----- (000810E8) --------------------------------------------------------
int __fastcall sub_810E8(unsigned int a1, char a2)
{
  int v5; // [sp+Ch] [bp-8h] BYREF

  sub_813D8(0, a1, 0, 0x58u, &v5);
  BYTE2(v5) = BYTE2(v5) & 0xF0 | a2 & 0xF;
  return sub_7E930(a1, 1, 0, 0x58u, v5);
}

//----- (00081144) --------------------------------------------------------
unsigned int __fastcall sub_81144(unsigned int a1)
{
  return a1 >> 25;
}

//----- (0008114C) --------------------------------------------------------
int __fastcall sub_8114C(unsigned int a1, unsigned int a2)
{
  return (unsigned __int8)sub_962A0((unsigned __int8)(a1 >> 17), a2);
}

//----- (00081160) --------------------------------------------------------
int __fastcall sub_81160(unsigned int a1, int a2)
{
  return (unsigned __int8)((a2 * (unsigned int)(unsigned __int16)(a1 >> 9)) >> 16);
}

//----- (00081170) --------------------------------------------------------
int sub_81170()
{
  return -1;
}

//----- (00081180) --------------------------------------------------------
int sub_81180()
{
  return -1;
}

//----- (00081190) --------------------------------------------------------
int sub_81190()
{
  return -1;
}

//----- (00081198) --------------------------------------------------------
int sub_81198()
{
  return 0;
}

//----- (000811A0) --------------------------------------------------------
int sub_811A0()
{
  return 0;
}

//----- (000811A8) --------------------------------------------------------
int sub_811A8()
{
  return 0;
}

//----- (000811B0) --------------------------------------------------------
int sub_811B0()
{
  return 0;
}

//----- (000811B8) --------------------------------------------------------
int sub_811B8()
{
  return 0;
}

//----- (000811C0) --------------------------------------------------------
int sub_811C0()
{
  return 0;
}

//----- (000811D0) --------------------------------------------------------
int sub_811D0()
{
  return 0;
}

//----- (000811E0) --------------------------------------------------------
int sub_811E0()
{
  return 0;
}

//----- (000811E8) --------------------------------------------------------
int __fastcall sub_811E8(unsigned int a1, int a2)
{
  return sub_80174(a1, 1, 0, a2);
}

//----- (000811F8) --------------------------------------------------------
int __fastcall sub_811F8(int a1)
{
  return sub_7E930(a1, 1, 0, 0x68u, 1520786085);
}

//----- (00081224) --------------------------------------------------------
int __fastcall sub_81224(int a1, unsigned int a2)
{
  return sub_7E930(a1, 0, a2, 0x68u, 1520786085);
}

//----- (0008131C) --------------------------------------------------------
int __fastcall sub_8131C(int a1, unsigned int a2)
{
  return sub_7F06C(a1, 1, 0, a2);
}

//----- (0008132C) --------------------------------------------------------
int __fastcall sub_8132C(int a1, const char *a2, unsigned int a3)
{
  return sub_7F06C(a1, 0, a2, a3);
}

//----- (0008133C) --------------------------------------------------------
int __fastcall sub_8133C(unsigned int a1)
{
  int i; // r7
  char *v4; // r4
  void *v5; // r0

  if ( a1 > 3 )
    return -1;
  for ( i = 0; i != 4; ++i )
  {
    if ( a1 == i )
    {
      v4 = (char *)&unk_5510DC + 0x40000 * a1;
      do
      {
        v5 = v4;
        v4 += 1024;
        memcpy(v5, &unk_BD5F0, 0x400u);
      }
      while ( v4 != (char *)&unk_5910DC + 0x40000 * a1 );
      memcpy((char *)&unk_6510DC + 1024 * i, &unk_BD5F0, 0x400u);
    }
  }
  return 0;
}

//----- (000813CC) --------------------------------------------------------
void *sub_813CC()
{
  return &unk_6510DC;
}

//----- (000813D8) --------------------------------------------------------
int __fastcall sub_813D8(int a1, unsigned int a2, unsigned int a3, unsigned int a4, _DWORD *a5)
{
  unsigned int v5; // r8
  unsigned int v10; // r10
  int v11; // r11
  unsigned int v13; // r3
  unsigned int v14; // r3
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v5 = a4 >> 2;
  if ( a4 - 140 > 0x2F )
  {
    if ( a4 > 0xBB )
      v5 += 6;
  }
  else
  {
    v5 += 3;
  }
  if ( a2 > 3 )
    return -1;
  if ( a3 > 0xFF )
    return -2;
  if ( v5 > 0x7F )
    return -3;
  pthread_mutex_lock(&stru_5510C4);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v10 = a2 << 7;
      v11 = -6;
      pthread_mutex_unlock(&stru_5510C4);
LABEL_11:
      snprintf(
        s,
        0x800u,
        "[%s] level::%d, which_chain::%u, which_asic::%u,register_index::%u, hash_reg_val::%08x, register_address::%02x failed.\r\n",
        "get_register_cache_value",
        a1,
        a2,
        a3,
        v5,
        dword_6510DC[2 * v10 + 2 * v5],
        a4);
      sub_41DB8(3, s, 0);
      return v11;
    }
    v13 = v5 + ((a3 + (a2 << 8)) << 7);
    if ( dword_5510DC[2 * v13] != a4 )
    {
      v10 = a2 << 7;
      v11 = -5;
      pthread_mutex_unlock(&stru_5510C4);
      goto LABEL_11;
    }
    *a5 = dword_5510DC[2 * v13 + 1];
    pthread_mutex_unlock(&stru_5510C4);
    return 0;
  }
  else
  {
    v10 = a2 << 7;
    v14 = (a2 << 7) + v5;
    if ( dword_6510DC[2 * v14] != a4 )
    {
      v11 = -4;
      pthread_mutex_unlock(&stru_5510C4);
      goto LABEL_11;
    }
    *a5 = dword_6510DC[2 * v14 + 1];
    pthread_mutex_unlock(&stru_5510C4);
    return 0;
  }
}
// 5510C4: using guessed type pthread_mutex_t stru_5510C4;
// 5510DC: using guessed type _DWORD dword_5510DC[65536];
// 6510DC: using guessed type _DWORD dword_6510DC[1024];

//----- (000815A0) --------------------------------------------------------
int __fastcall sub_815A0(int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v5; // r10
  unsigned int v10; // r11
  int v11; // r7
  unsigned int v13; // r3
  unsigned int v14; // r2
  int v15; // r3
  char *v16; // r2
  char *v17; // r3

  v5 = (a4 & 3) + (a4 >> 2);
  if ( a4 - 140 > 0x2F )
  {
    if ( a4 > 0xBB )
      v5 += 6;
  }
  else
  {
    v5 += 3;
  }
  if ( a2 > 3 )
    return -1;
  if ( a3 > 0xFF )
    return -2;
  if ( v5 > 0x80 )
    return -3;
  pthread_mutex_lock(&stru_5510C4);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v10 = a2 << 7;
      v11 = -6;
      pthread_mutex_unlock(&stru_5510C4);
LABEL_11:
      printf(
        "[%s] level::%d, which_chain::%u, which_asic::%u,register_index::%u, hash_register_value::%08x, register_address:"
        ":%02x failed ,ret:%d.\r\n",
        "set_register_cache_value",
        a1,
        a2,
        a3,
        v5,
        dword_6510DC[2 * v10 + 2 * v5],
        a4,
        v11);
      return v11;
    }
    v13 = v5 + ((a3 + (a2 << 8)) << 7);
    if ( dword_5510DC[2 * v13] != a4 )
    {
      pthread_mutex_unlock(&stru_5510C4);
      v11 = -5;
      v10 = a2 << 7;
      goto LABEL_11;
    }
    dword_5510DC[2 * v13 + 1] = a5;
    pthread_mutex_unlock(&stru_5510C4);
    return 0;
  }
  else
  {
    v10 = a2 << 7;
    v14 = (a2 << 7) + v5;
    if ( dword_6510DC[2 * v14] != a4 )
    {
      v11 = -4;
      pthread_mutex_unlock(&stru_5510C4);
      goto LABEL_11;
    }
    v15 = 2 * (v5 + (a2 << 15));
    dword_6510DC[2 * v14 + 1] = a5;
    v16 = (char *)&unk_5910DC + v15 * 4;
    v17 = (char *)&dword_5510DC[v15];
    do
    {
      *((_DWORD *)v17 + 1) = a5;
      v17 += 1024;
    }
    while ( v17 != v16 );
    pthread_mutex_unlock(&stru_5510C4);
    return 0;
  }
}
// 5510C4: using guessed type pthread_mutex_t stru_5510C4;
// 5510DC: using guessed type _DWORD dword_5510DC[65536];
// 6510DC: using guessed type _DWORD dword_6510DC[1024];

//----- (00081768) --------------------------------------------------------
int __fastcall sub_81768(int a1, char a2, char a3, int a4, _BYTE *a5)
{
  int v5; // r5

  if ( !a5 )
    return -1;
  v5 = 0;
  *(_DWORD *)a5 = 0;
  a5[3] = a3;
  a5[7] = a4;
  a5[2] = a2;
  a5[4] = HIBYTE(a4);
  a5[5] = BYTE2(a4);
  a5[6] = BYTE1(a4);
  a5[8] = 0;
  *a5 = (16 * (a1 != 0)) & 0x1E | 0x41;
  a5[1] = 9;
  a5[8] = a5[8] & 0xE0 | sub_819E4(a5, 0x40u) & 0x1F;
  return v5;
}

//----- (00081800) --------------------------------------------------------
int __fastcall sub_81800(char a1, _BYTE *a2)
{
  int v2; // r5

  if ( !a2 )
    return -1;
  v2 = 0;
  *(_DWORD *)a2 = 0;
  a2[4] = 0;
  a2[2] = a1;
  a2[1] = 5;
  *a2 = 64;
  a2[4] = a2[4] & 0xE0 | sub_819E4(a2, 0x20u) & 0x1F;
  return v2;
}

//----- (00081854) --------------------------------------------------------
int __fastcall sub_81854(int a1, char a2, char a3, _BYTE *a4)
{
  int v4; // r5

  if ( !a4 )
    return -1;
  v4 = 0;
  *(_DWORD *)a4 = 0;
  a4[3] = a3;
  a4[2] = a2;
  a4[4] = 0;
  a4[1] = 5;
  *a4 = (16 * (a1 != 0)) & 0x1D | 0x42;
  a4[4] = a4[4] & 0xE0 | sub_819E4(a4, 0x20u) & 0x1F;
  return v4;
}

//----- (000818C4) --------------------------------------------------------
int __fastcall sub_818C4(_BYTE *a1)
{
  int v1; // r5

  if ( !a1 )
    return -1;
  v1 = 0;
  *(_DWORD *)a1 = 0;
  a1[4] = 0;
  a1[1] = 5;
  *a1 = 83;
  a1[4] = a1[4] & 0xE0 | sub_819E4(a1, 0x20u) & 0x1F;
  return v1;
}

//----- (00081910) --------------------------------------------------------
int __fastcall sub_81910(int a1, int a2, unsigned int a3)
{
  int *v3; // r4
  unsigned int v4; // lr
  int v5; // r3
  int v6; // r12
  int v8; // r5
  int v9[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = 0;
  v9[0] = 0;
  if ( a3 )
    v3 = v9;
  v9[1] = 0;
  v9[2] = 0;
  if ( !a3 )
    goto LABEL_9;
LABEL_4:
  while ( 2 )
  {
    v5 = 0;
    if ( v4 < a3 )
    {
      do
      {
        v6 = *v3;
        if ( v5 )
        {
          v8 = *(unsigned __int8 *)(a2 + v4 + v5);
          if ( v5 == 1 )
          {
            *v3 = v6 | (v8 << 16);
          }
          else if ( v5 == 2 )
          {
            *v3 = v6 | (v8 << 8);
          }
          else
          {
            *v3 = v8 | v6;
            if ( v5 == 3 )
            {
              v4 += 4;
              ++v3;
              if ( v4 >= a3 )
                goto LABEL_9;
              goto LABEL_4;
            }
          }
        }
        else
        {
          *v3 = v6 | (*(unsigned __int8 *)(a2 + v4) << 24);
        }
        ++v5;
      }
      while ( v4 + v5 < a3 );
    }
    v4 += 4;
    ++v3;
    if ( v4 < a3 )
      continue;
    break;
  }
LABEL_9:
  sub_641A0(v9, a1);
  return 0;
}
// 81954: variable 'v3' is possibly undefined

//----- (000819E4) --------------------------------------------------------
int __fastcall sub_819E4(_BYTE *a1, unsigned int a2)
{
  int v2; // r2
  char v3; // r9
  unsigned int v4; // r12
  int v5; // r6
  int v6; // r8
  int v7; // r5
  int v8; // r7
  unsigned int v9; // r4
  unsigned int v10; // r3
  unsigned __int8 v11; // r3
  int v12; // lr
  int result; // r0

  if ( !a2 )
    return 31;
  LOBYTE(v2) = 0;
  v3 = 1;
  LOBYTE(v4) = 0;
  v5 = 1;
  v6 = 1;
  v7 = 1;
  v8 = 1;
  v9 = 128;
  while ( 1 )
  {
    v2 = (unsigned __int8)(v2 + 1);
    v4 = (unsigned __int8)(v4 + 1);
    v10 = *a1 & v9;
    v9 >>= 1;
    if ( v10 )
      v11 = v3 ^ 1;
    else
      v11 = v3;
    if ( v2 == 8 )
    {
      ++a1;
      LOBYTE(v2) = 0;
      v9 = 128;
    }
    v12 = (unsigned __int8)(v11 ^ v7);
    v3 = v5;
    if ( v4 >= a2 )
      break;
    v5 = v6;
    v7 = v8;
    v6 = v12;
    v8 = v11;
  }
  if ( v5 )
    result = 16;
  else
    result = 0;
  if ( v6 )
    result |= 8u;
  if ( v11 != v7 )
    result |= 4u;
  if ( v8 )
    result |= 2u;
  if ( v11 )
    return result | 1;
  return result;
}

//----- (00081B0C) --------------------------------------------------------
int __fastcall sub_81B0C(int a1)
{
  pthread_t v2; // r0
  unsigned int v3; // r2
  int v4; // r0
  int v5; // r4
  unsigned int i; // r3
  int v8; // r5
  size_t v9; // r0
  size_t v10; // r8
  void *v11; // r6
  ssize_t v12; // r0
  ssize_t v13; // r1
  int (__fastcall *v14)(void *, ssize_t); // r4
  size_t v15; // r0
  int v16; // [sp+Ch] [bp-240h] BYREF
  int v17; // [sp+10h] [bp-23Ch] BYREF
  socklen_t v18; // [sp+14h] [bp-238h] BYREF
  char s[4]; // [sp+18h] [bp-234h] BYREF
  int v20; // [sp+1Ch] [bp-230h]
  int v21; // [sp+20h] [bp-22Ch]
  int v22; // [sp+24h] [bp-228h]
  struct sockaddr addr; // [sp+28h] [bp-224h] BYREF
  struct sockaddr v24; // [sp+38h] [bp-214h] BYREF
  char buf[4]; // [sp+48h] [bp-204h] BYREF
  char v26[252]; // [sp+4Ch] [bp-200h] BYREF
  char v27[4]; // [sp+148h] [bp-104h] BYREF
  _BYTE v28[252]; // [sp+14Ch] [bp-100h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *(_DWORD *)a1;
  *(_DWORD *)s = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  sprintf(s, "ct_b/fcb/%d", v3);
  prctl(15, s);
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  v4 = socket(2, 1, 0);
  v5 = v4;
  if ( v4 < 0 )
  {
    perror("socket error");
    return 0;
  }
  else
  {
    v16 = 1;
    if ( setsockopt(v4, 1, 2, &v16, 4u) < 0 || (v17 = 9216, setsockopt(v5, 1, 8, &v17, 4u) < 0) )
    {
      perror("set sockopt err");
      return 0;
    }
    for ( i = *(_DWORD *)a1; ; *(_DWORD *)a1 = i )
    {
      *(_WORD *)addr.sa_data = __rev16(i);
      if ( bind(v5, &addr, 0x10u) >= 0 )
        break;
      perror("bind error");
      i = *(_DWORD *)a1 + 1;
    }
    if ( listen(v5, 5) >= 0 )
    {
      v18 = 16;
      *(_DWORD *)(a1 + 144) = 1;
      v8 = accept(v5, &v24, &v18);
      if ( v8 >= 0 )
      {
        *(_DWORD *)buf = 0;
        memset(v26, 0, sizeof(v26));
        sprintf(buf, "%x %s\n", 63, (const char *)(a1 + 16));
        v9 = strlen(buf);
        send(v8, buf, v9 + 1, 0);
        v10 = *(_DWORD *)(a1 + 148);
        v11 = malloc(v10);
        v12 = recv(v8, v11, v10, 0);
        if ( v12 > 0 )
          *((_BYTE *)v11 + v12) = 0;
        while ( 1 )
        {
          v13 = recv(v8, v11, *(_DWORD *)(a1 + 148), 0);
          if ( v13 > 0 )
          {
            v14 = *(int (__fastcall **)(void *, ssize_t))(a1 + 12);
            if ( v14 )
              v14 = (int (__fastcall *)(void *, ssize_t))v14(v11, v13);
          }
          else
          {
            v14 = 0;
          }
          *(_DWORD *)v27 = 0;
          memset(v28, 0, sizeof(v28));
          sprintf(v27, "%x %d %s %s", 63, v14, (const char *)(a1 + 16), "OK");
          v15 = strlen(v27);
          send(v8, v27, v15 + 1, 0);
        }
      }
      perror("accept error");
      return 0;
    }
    perror("listen error");
    return 0;
  }
}

//----- (00081DC4) --------------------------------------------------------
int __fastcall sub_81DC4(int a1)
{
  pthread_t v2; // r0
  int v3; // r7
  ssize_t v4; // r0
  int v5; // r4
  int v6; // r4
  _DWORD *v7; // r0
  int v8; // r11
  _DWORD *v9; // r10
  const char *v10; // r5
  int v11; // r0
  int v12; // r3
  size_t v13; // r0
  int v14; // r10
  size_t v15; // r0
  size_t v17; // r0
  int v18; // [sp+14h] [bp-200h] BYREF
  pthread_t newthread; // [sp+18h] [bp-1FCh] BYREF
  _BYTE v20[8]; // [sp+1Ch] [bp-1F8h] BYREF
  int v21; // [sp+24h] [bp-1F0h]
  int v22; // [sp+28h] [bp-1ECh]
  char src[4]; // [sp+2Ch] [bp-1E8h] BYREF
  int v24; // [sp+30h] [bp-1E4h]
  int v25; // [sp+34h] [bp-1E0h]
  int v26; // [sp+38h] [bp-1DCh]
  int v27; // [sp+3Ch] [bp-1D8h]
  int v28; // [sp+40h] [bp-1D4h]
  int v29; // [sp+44h] [bp-1D0h]
  int v30; // [sp+48h] [bp-1CCh]
  char s1[4]; // [sp+4Ch] [bp-1C8h] BYREF
  int v32; // [sp+50h] [bp-1C4h]
  int v33; // [sp+54h] [bp-1C0h]
  int v34; // [sp+58h] [bp-1BCh]
  int v35; // [sp+5Ch] [bp-1B8h]
  int v36; // [sp+60h] [bp-1B4h]
  int v37; // [sp+64h] [bp-1B0h]
  int v38; // [sp+68h] [bp-1ACh]
  pthread_attr_t attr; // [sp+6Ch] [bp-1A8h] BYREF
  _DWORD buf[32]; // [sp+90h] [bp-184h] BYREF
  char v41[4]; // [sp+110h] [bp-104h] BYREF
  _BYTE v42[252]; // [sp+114h] [bp-100h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v22 = 0;
  qmemcpy(v20, "ct_b/mai", sizeof(v20));
  v21 = *(unsigned __int16 *)"n";
  prctl(15, v20);
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  v3 = *(_DWORD *)(a1 + 8);
  while ( 1 )
  {
    memset(buf, 0, sizeof(buf));
    v4 = recv(v3, buf, 0x80u, 0);
    if ( v4 <= 0 )
      return 0;
    *((_BYTE *)buf + v4) = 0;
    *(_DWORD *)src = 0;
    v24 = 0;
    *(_DWORD *)s1 = 0;
    v32 = 0;
    v18 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    _isoc99_sscanf(buf, "%x%s%s", &v18, s1, src);
    v5 = strcmp(s1, "regist");
    if ( v5 )
    {
      v6 = dword_6520DC + 1;
      memcpy((char *)&unk_652104 + 128 * dword_6520DC, buf, 0x80u);
      dword_6520DC = v6;
    }
    else
    {
      v7 = calloc(0x98u, 1u);
      v8 = dword_6520E0;
      v9 = v7;
      if ( !dword_6520E0 )
        goto LABEL_18;
      v10 = s2;
      while ( 1 )
      {
        v11 = strcmp(src, v10);
        v10 += 136;
        if ( !v11 )
          break;
        if ( ++v5 == v8 )
          goto LABEL_11;
      }
      v12 = *((_DWORD *)&unk_656104 + 34 * v5 + 33);
      v9[3] = *((_DWORD *)&unk_656104 + 34 * v5);
      v9[37] = v12;
LABEL_11:
      if ( v8 == v5 )
      {
LABEL_18:
        *(_DWORD *)v41 = 0;
        memset(v42, 0, sizeof(v42));
        sprintf(v41, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", src);
        v17 = strlen(v41);
        send(v3, v41, v17 + 1, 0);
        free(v9);
      }
      else
      {
        *v9 = dword_BD9F0;
        v13 = strlen(src);
        memcpy(v9 + 4, src, v13 + 1);
        v9[36] = 0;
        pthread_create(&newthread, &attr, (void *(*)(void *))sub_81B0C, v9);
        while ( !v9[36] )
          usleep(0x2710u);
        v14 = *v9;
        *(_DWORD *)v41 = 0;
        if ( v14 != dword_BD9F0 )
          dword_BD9F0 = v14;
        memset(v42, 0, sizeof(v42));
        sprintf(v41, "%x %d %s %s %s", 63, v14, "reg_resp", "OK", src);
        v15 = strlen(v41);
        send(v3, v41, v15 + 1, 0);
        ++dword_BD9F0;
      }
    }
  }
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// BD9F0: using guessed type int dword_BD9F0;
// 6520DC: using guessed type int dword_6520DC;
// 6520E0: using guessed type int dword_6520E0;

//----- (00082104) --------------------------------------------------------
int __fastcall sub_82104(int a1, int a2)
{
  int v2; // r7
  char *v5; // r4
  char *v6; // r3
  char *v7; // r5
  char *v8; // r0
  int v9; // r2
  int v10; // r0
  int v11; // r8
  unsigned int v12; // r4
  int v13; // r5
  size_t v14; // r0
  ssize_t v15; // r0
  ssize_t v16; // r0
  _DWORD *v17; // r0
  int optval; // [sp+8h] [bp-454h] BYREF
  socklen_t addr_len; // [sp+Ch] [bp-450h] BYREF
  pthread_t newthread; // [sp+10h] [bp-44Ch] BYREF
  struct sockaddr addr; // [sp+14h] [bp-448h] BYREF
  struct sockaddr v23; // [sp+24h] [bp-438h] BYREF
  pthread_attr_t attr; // [sp+34h] [bp-428h] BYREF
  char buf[4]; // [sp+58h] [bp-404h] BYREF
  _BYTE s[124]; // [sp+5Ch] [bp-400h] BYREF
  _DWORD v27[32]; // [sp+D8h] [bp-384h] BYREF
  char v28[256]; // [sp+158h] [bp-304h] BYREF
  _DWORD v29[129]; // [sp+258h] [bp-204h] BYREF

  v2 = dword_6520E4;
  if ( dword_6520E4 )
    return -1;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  pthread_mutex_init((pthread_mutex_t *)algn_6520E8, 0);
  dword_6520E0 = a2;
  if ( a2 )
  {
    v5 = (char *)(a1 + 4);
    v6 = s2;
    v7 = &v5[136 * a2];
    do
    {
      v8 = (char *)memcpy(v6, v5, 0x80u);
      v5 += 136;
      v9 = *((_DWORD *)v5 - 35);
      v6 = v8 + 136;
      *((_DWORD *)v8 + 32) = *((_DWORD *)v5 - 2);
      *((_DWORD *)v8 - 1) = v9;
    }
    while ( v5 != v7 );
  }
  *(_WORD *)&addr.sa_data[6] = 0;
  *(_DWORD *)&addr.sa_data[8] = 0;
  *(_WORD *)&addr.sa_data[12] = 0;
  *(_WORD *)addr.sa_data = 0;
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  optval = 1;
  v10 = socket(2, 1, 0);
  v11 = v10;
  if ( v10 < 0 )
  {
    v2 = -4;
    perror("socket error");
  }
  else if ( setsockopt(v10, 1, 2, &optval, 4u) < 0 )
  {
    v2 = -4;
    perror("set sockopt err");
  }
  else
  {
    v12 = 22026;
    while ( 1 )
    {
      *(_WORD *)addr.sa_data = __rev16(v12++);
      if ( bind(v11, &addr, 0x10u) >= 0 )
        break;
      perror("bind error");
    }
    if ( listen(v11, 5) < 0 )
    {
      v2 = -4;
      perror("listen error");
    }
    else
    {
      addr_len = 16;
      v13 = accept(v11, &v23, &addr_len);
      if ( v13 < 0 )
      {
        v2 = -4;
        perror("accept error");
      }
      else
      {
        *(_DWORD *)buf = 0;
        memset(s, 0, sizeof(s));
        sprintf(buf, "Hello!0x%x\n", 63);
        v14 = strlen(buf);
        send(v13, buf, v14 + 1, 0);
        dword_6520E4 = 1;
        memset(v29, 0, 512);
        dword_652100 = v13;
        v15 = recv(v13, v29, 0x400u, 0);
        if ( v15 > 0 )
          *((_BYTE *)v29 + v15) = 0;
        strcpy(v28, "123 456 789 abc");
        memset(&v28[16], 0, 0xF0u);
        send(v13, v28, 0x10u, 0);
        memset(v27, 0, sizeof(v27));
        v16 = recv(v13, v27, 0x15u, 0);
        if ( v16 > 0 )
          *((_BYTE *)v27 + v16) = 0;
        v17 = malloc(0xCu);
        v17[2] = v13;
        v17[1] = v11;
        pthread_create(&newthread, &attr, (void *(*)(void *))sub_81DC4, v17);
      }
    }
  }
  return v2;
}
// 6520E0: using guessed type int dword_6520E0;
// 6520E4: using guessed type int dword_6520E4;
// 6520E8: using guessed type _BYTE[24];
// 652100: using guessed type int dword_652100;

//----- (00082418) --------------------------------------------------------
int __fastcall sub_82418(int a1)
{
  pthread_mutex_t *v2; // r8
  int v3; // r9
  int v4; // r5
  size_t v5; // r0
  int v6; // r0
  int v7; // r5
  ssize_t v8; // r0
  unsigned int v9; // r3
  int result; // r0
  unsigned int v11; // [sp+10h] [bp-47Ch] BYREF
  int v12; // [sp+14h] [bp-478h] BYREF
  struct sockaddr addr; // [sp+18h] [bp-474h] BYREF
  _DWORD v14[8]; // [sp+28h] [bp-464h] BYREF
  _DWORD v15[8]; // [sp+48h] [bp-444h] BYREF
  _DWORD v16[8]; // [sp+68h] [bp-424h] BYREF
  _DWORD dest[32]; // [sp+88h] [bp-404h] BYREF
  _DWORD v18[32]; // [sp+108h] [bp-384h] BYREF
  char buf[4]; // [sp+188h] [bp-304h] BYREF
  _BYTE s[252]; // [sp+18Ch] [bp-300h] BYREF
  _DWORD v21[129]; // [sp+288h] [bp-204h] BYREF

  if ( !dword_6520E4 )
    return -1;
  v2 = (pthread_mutex_t *)malloc(0x24u);
  pthread_mutex_init(v2, 0);
  v3 = dword_652100;
  *(_DWORD *)buf = 0;
  memset(s, 0, sizeof(s));
  sprintf(buf, "%x regist %s", 63, (const char *)a1);
  v4 = dword_6520DC;
  v5 = strlen(buf);
  send(v3, buf, v5 + 1, 0);
  memset(dest, 0, sizeof(dest));
  while ( dword_6520DC == v4 )
    usleep(0x3E8u);
  memcpy(dest, (char *)&unk_652104 + 128 * v4, sizeof(dest));
  v11 = 0;
  v12 = 0;
  memset(v14, 0, sizeof(v14));
  memset(v15, 0, sizeof(v15));
  memset(v16, 0, sizeof(v16));
  _isoc99_sscanf(dest, "%x%d%s%s%s", &v12, &v11, v14, v15, v16);
  if ( !v11 )
    return -4;
  addr.sa_family = 2;
  memset(addr.sa_data, 0, sizeof(addr.sa_data));
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)addr.sa_data = __rev16(v11);
  v6 = socket(2, 1, 0);
  v7 = v6;
  if ( v6 < 0 )
  {
    perror("socket err:");
    return -4;
  }
  else if ( connect(v6, &addr, 0x10u) < 0 )
  {
    perror("connect err:");
    return -3;
  }
  else
  {
    memset(v21, 0, 512);
    v8 = recv(v7, v21, 0x200u, 0);
    if ( v8 > 0 )
      *((_BYTE *)v21 + v8) = 0;
    memset(&v18[1], 0, 0x7Cu);
    v18[0] = &unk_214B4F;
    send(v7, v18, 4u, 0);
    v9 = v11;
    result = 0;
    v2[1].__owner = v7;
    *(_DWORD *)(a1 + 128) = v2;
    v2[1].__lock = v9;
  }
  return result;
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 6520DC: using guessed type int dword_6520DC;
// 6520E4: using guessed type int dword_6520E4;
// 652100: using guessed type int dword_652100;

//----- (000826C0) --------------------------------------------------------
int sub_826C0()
{
  return 0;
}

//----- (000826D8) --------------------------------------------------------
int __fastcall sub_826D8(int a1, const void *a2, size_t a3, _DWORD *a4)
{
  pthread_mutex_t *v4; // r5
  int v8; // r4
  ssize_t v9; // r0
  int v11; // [sp+8h] [bp-148h] BYREF
  int v12; // [sp+Ch] [bp-144h] BYREF
  int v13; // [sp+10h] [bp-140h] BYREF
  int v14; // [sp+14h] [bp-13Ch]
  int v15; // [sp+18h] [bp-138h]
  int v16; // [sp+1Ch] [bp-134h]
  int v17; // [sp+20h] [bp-130h]
  int v18; // [sp+24h] [bp-12Ch]
  int v19; // [sp+28h] [bp-128h]
  int v20; // [sp+2Ch] [bp-124h]
  int v21; // [sp+30h] [bp-120h] BYREF
  int v22; // [sp+34h] [bp-11Ch]
  int v23; // [sp+38h] [bp-118h]
  int v24; // [sp+3Ch] [bp-114h]
  int v25; // [sp+40h] [bp-110h]
  int v26; // [sp+44h] [bp-10Ch]
  int v27; // [sp+48h] [bp-108h]
  int v28; // [sp+4Ch] [bp-104h]
  _DWORD buf[64]; // [sp+50h] [bp-100h] BYREF

  if ( !dword_6520E4 )
    return -1;
  v4 = *(pthread_mutex_t **)(a1 + 128);
  if ( !v4 )
    return -2;
  v8 = pthread_mutex_trylock(*(pthread_mutex_t **)(a1 + 128));
  if ( v8 )
    return -3;
  if ( send(v4[1].__owner, a2, a3, 0) <= 0 )
  {
    v8 = -4;
    pthread_mutex_unlock(v4);
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    v9 = recv(v4[1].__owner, buf, 0x100u, 0);
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v21 = 0;
    v22 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    if ( v9 > 0 )
      _isoc99_sscanf(buf, "%x%d%s%s", &v11, &v12, &v13, &v21);
    if ( a4 )
      *a4 = v12;
    pthread_mutex_unlock(v4);
  }
  return v8;
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 6520E4: using guessed type int dword_6520E4;

//----- (00082824) --------------------------------------------------------
int sub_82824()
{
  return 0;
}

//----- (0008282C) --------------------------------------------------------
int sub_8282C()
{
  int result; // r0

  if ( dword_65A528 )
    result = sub_86C8C((const void *)dword_65A528);
  dword_65A528 = 0;
  dword_65A530 = 0;
  if ( dword_65A52C )
    result = sub_8A98C((const void *)dword_65A52C);
  dword_65A52C = 0;
  if ( dword_AB7AFC )
    result = sub_87470(dword_AB7AFC);
  dword_AB7AFC = 0;
  return result;
}
// 65A528: using guessed type int dword_65A528;
// 65A52C: using guessed type int dword_65A52C;
// 65A530: using guessed type int dword_65A530;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (000828F4) --------------------------------------------------------
void sub_828F4()
{
  void *v0; // [sp+4h] [bp-8h]

  v0 = pthread_getspecific(dword_65A524);
  if ( v0 )
    sub_91EF4((int)v0);
}
// 65A524: using guessed type int dword_65A524;

//----- (00082940) --------------------------------------------------------
int __fastcall sub_82940(const char *a1)
{
  int v4; // [sp+14h] [bp-8h]
  int v5; // [sp+14h] [bp-8h]

  if ( !dword_65A53C )
  {
    v4 = pthread_key_create((pthread_key_t *)&dword_65A524, (void (*)(void *))sub_91EF4);
    if ( v4 )
    {
      sub_93A0C(2, "src/zlog.c", 76, "pthread_key_create fail, rc[%d]", v4);
LABEL_14:
      sub_8282C();
      return -1;
    }
    v5 = sub_96FF8((void (*)(void *))sub_828F4);
    if ( v5 )
    {
      sub_93A0C(2, "src/zlog.c", 85, "atexit fail, rc[%d]", v5);
      goto LABEL_14;
    }
    ++dword_65A53C;
  }
  dword_AB7AFC = (int)sub_875A4(a1);
  if ( !dword_AB7AFC )
  {
    sub_93A0C(2, "src/zlog.c", 93, "zlog_conf_new[%s] fail", a1);
    goto LABEL_14;
  }
  dword_65A528 = (int)sub_86D00();
  if ( !dword_65A528 )
  {
    sub_93A0C(2, "src/zlog.c", 99, "zlog_category_table_new fail");
    goto LABEL_14;
  }
  dword_65A52C = (int)sub_8AA00();
  if ( !dword_65A52C )
  {
    sub_93A0C(2, "src/zlog.c", 105, "zlog_record_table_new fail");
    goto LABEL_14;
  }
  return 0;
}
// 828F4: using guessed type int sub_828F4();
// 65A524: using guessed type int dword_65A524;
// 65A528: using guessed type int dword_65A528;
// 65A52C: using guessed type int dword_65A52C;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00082B18) --------------------------------------------------------
int __fastcall sub_82B18(const char *a1)
{
  int v4; // [sp+1Ch] [bp-8h]
  int v5; // [sp+1Ch] [bp-8h]
  int v6; // [sp+1Ch] [bp-8h]

  sub_93A0C(0, "src/zlog.c", 119, "------zlog_init start------");
  sub_93A0C(0, "src/zlog.c", 120, "------compile time[%s %s], version[%s]------", "Apr 16 2025", "10:21:31", "1.2.12");
  v4 = pthread_rwlock_wrlock(&stru_65A504);
  if ( v4 )
  {
    sub_93A0C(2, "src/zlog.c", 124, "pthread_rwlock_wrlock fail, rc[%d]", v4);
    return -1;
  }
  if ( dword_65A538 )
  {
    sub_93A0C(2, "src/zlog.c", 129, "already init, use zlog_reload pls");
  }
  else
  {
    if ( !sub_82940(a1) )
    {
      dword_65A538 = 1;
      ++dword_65A53C;
      sub_93A0C(0, "src/zlog.c", 142, "------zlog_init success end------");
      v5 = pthread_rwlock_unlock(&stru_65A504);
      if ( !v5 )
        return 0;
      sub_93A0C(2, "src/zlog.c", 145, "pthread_rwlock_unlock fail, rc=[%d]", v5);
      return -1;
    }
    sub_93A0C(2, "src/zlog.c", 135, "zlog_init_inner[%s] fail", a1);
  }
  sub_93A0C(2, "src/zlog.c", 150, "------zlog_init fail end------");
  v6 = pthread_rwlock_unlock(&stru_65A504);
  if ( v6 )
    sub_93A0C(2, "src/zlog.c", 153, "pthread_rwlock_unlock fail, rc=[%d]", v6);
  return -1;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;

//----- (00082D48) --------------------------------------------------------
int __fastcall sub_82D48(const char *a1, const char *a2)
{
  int v6; // [sp+1Ch] [bp-8h]
  int v7; // [sp+1Ch] [bp-8h]
  int v8; // [sp+1Ch] [bp-8h]

  sub_93A0C(0, "src/zlog.c", 162, "------dzlog_init start------");
  sub_93A0C(0, "src/zlog.c", 164, "------compile time[%s %s], version[%s]------", "Apr 16 2025", "10:21:31", "1.2.12");
  v6 = pthread_rwlock_wrlock(&stru_65A504);
  if ( v6 )
  {
    sub_93A0C(2, "src/zlog.c", 168, "pthread_rwlock_wrlock fail, rc[%d]", v6);
    return -1;
  }
  if ( dword_65A538 )
  {
    sub_93A0C(2, "src/zlog.c", 173, "already init, use zlog_reload pls");
  }
  else if ( sub_82940(a1) )
  {
    sub_93A0C(2, "src/zlog.c", 178, "zlog_init_inner[%s] fail", a1);
  }
  else
  {
    dword_65A530 = (int)sub_86F5C(dword_65A528, a2, *(_DWORD **)(dword_AB7AFC + 9288));
    if ( dword_65A530 )
    {
      dword_65A538 = 1;
      ++dword_65A53C;
      sub_93A0C(0, "src/zlog.c", 194, "------dzlog_init success end------");
      v7 = pthread_rwlock_unlock(&stru_65A504);
      if ( !v7 )
        return 0;
      sub_93A0C(2, "src/zlog.c", 197, "pthread_rwlock_unlock fail, rc=[%d]", v7);
      return -1;
    }
    sub_93A0C(2, "src/zlog.c", 187, "zlog_category_table_fetch_category[%s] fail", a2);
  }
  sub_93A0C(2, "src/zlog.c", 202, "------dzlog_init fail end------");
  v8 = pthread_rwlock_unlock(&stru_65A504);
  if ( v8 )
    sub_93A0C(2, "src/zlog.c", 205, "pthread_rwlock_unlock fail, rc=[%d]", v8);
  return -1;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A528: using guessed type int dword_65A528;
// 65A530: using guessed type int dword_65A530;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00082FFC) --------------------------------------------------------
int __fastcall sub_82FFC(const char *a1)
{
  char *v4; // [sp+18h] [bp-14h]
  int v5; // [sp+1Ch] [bp-10h]
  int v6; // [sp+1Ch] [bp-10h]
  int v7; // [sp+1Ch] [bp-10h]
  int v8; // [sp+1Ch] [bp-10h]
  int i; // [sp+24h] [bp-8h]

  sub_93A0C(0, "src/zlog.c", 219, "------zlog_reload start------");
  v5 = pthread_rwlock_wrlock(&stru_65A504);
  if ( v5 )
  {
    sub_93A0C(2, "src/zlog.c", 222, "pthread_rwlock_wrlock fail, rc[%d]", v5);
    return -1;
  }
  if ( !dword_65A538 )
  {
    sub_93A0C(2, "src/zlog.c", 227, "never call zlog_init() or dzlog_init() before");
    goto LABEL_26;
  }
  if ( !a1 )
    a1 = (const char *)dword_AB7AFC;
  if ( a1 == (const char *)-1 )
  {
    if ( *(_DWORD *)(dword_AB7AFC + 9276) >= (unsigned int)dword_65A534 )
    {
LABEL_26:
      sub_93A0C(0, "src/zlog.c", 291, "------zlog_reload do nothing------");
      v8 = pthread_rwlock_unlock(&stru_65A504);
      if ( !v8 )
        return 0;
      sub_93A0C(2, "src/zlog.c", 294, "pthread_rwlock_unlock fail, rc=[%d]", v8);
      return -1;
    }
    a1 = (const char *)dword_AB7AFC;
  }
  dword_65A534 = 0;
  v4 = sub_875A4(a1);
  if ( v4 )
  {
    for ( i = 0; i < *(_DWORD *)(*((_DWORD *)v4 + 2322) + 4); ++i )
      sub_8FE50(*(_DWORD *)(**((_DWORD **)v4 + 2322) + 4 * i), dword_65A52C);
    if ( !sub_86D84(dword_65A528, *((_DWORD **)v4 + 2322)) )
    {
      ++dword_65A53C;
      sub_86E4C(dword_65A528);
      sub_87470(dword_AB7AFC);
      dword_AB7AFC = (int)v4;
      sub_93A0C(0, "src/zlog.c", 271, "------zlog_reload success, total init verison[%d] ------", dword_65A53C);
      v6 = pthread_rwlock_unlock(&stru_65A504);
      if ( !v6 )
        return 0;
      sub_93A0C(2, "src/zlog.c", 274, "pthread_rwlock_unlock fail, rc=[%d]", v6);
      return -1;
    }
    sub_93A0C(2, "src/zlog.c", 260, "zlog_category_table_update fail");
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 250, "zlog_conf_new fail");
  }
  sub_93A0C(1, "src/zlog.c", 280, "zlog_reload fail, use old conf file, still working");
  if ( v4 )
    sub_87470((int)v4);
  sub_93A0C(2, "src/zlog.c", 283, "------zlog_reload fail, total init version[%d] ------", dword_65A53C);
  v7 = pthread_rwlock_unlock(&stru_65A504);
  if ( v7 )
    sub_93A0C(2, "src/zlog.c", 286, "pthread_rwlock_unlock fail, rc=[%d]", v7);
  return -1;
}
// 8336C: conditional instruction was optimized away because %var_8.4==0
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A528: using guessed type int dword_65A528;
// 65A52C: using guessed type int dword_65A52C;
// 65A534: using guessed type int dword_65A534;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00083478) --------------------------------------------------------
int sub_83478()
{
  int result; // r0
  int v1; // [sp+Ch] [bp-8h]

  sub_93A0C(0, "src/zlog.c", 304, "------zlog_fini start------");
  v1 = pthread_rwlock_wrlock(&stru_65A504);
  if ( v1 )
    return sub_93A0C(2, "src/zlog.c", 307, "pthread_rwlock_wrlock fail, rc[%d]", v1);
  if ( dword_65A538 )
  {
    sub_8282C();
    dword_65A538 = 0;
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 312, "before finish, must zlog_init() or dzlog_init() fisrt");
  }
  sub_93A0C(0, "src/zlog.c", 320, "------zlog_fini end------");
  result = pthread_rwlock_unlock(&stru_65A504);
  if ( result )
    return sub_93A0C(2, "src/zlog.c", 323, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A538: using guessed type int dword_65A538;

//----- (000835A0) --------------------------------------------------------
int *__fastcall sub_835A0(const char *a1)
{
  int *v4; // [sp+10h] [bp-Ch]
  int v5; // [sp+14h] [bp-8h]
  int v6; // [sp+14h] [bp-8h]
  int v7; // [sp+14h] [bp-8h]

  if ( !a1 )
  {
    sub_93A0C(2, "src/zlog.c", 334, "cname is null or 0");
    return 0;
  }
  sub_93A0C(0, "src/zlog.c", 335, "------zlog_get_category[%s] start------", a1);
  v5 = pthread_rwlock_wrlock(&stru_65A504);
  if ( v5 )
  {
    sub_93A0C(2, "src/zlog.c", 338, "pthread_rwlock_wrlock fail, rc[%d]", v5);
    return 0;
  }
  if ( dword_65A538 )
  {
    v4 = sub_86F5C(dword_65A528, a1, *(_DWORD **)(dword_AB7AFC + 9288));
    if ( v4 )
    {
      sub_93A0C(0, "src/zlog.c", 357, "------zlog_get_category[%s] success, end------ ", a1);
      v6 = pthread_rwlock_unlock(&stru_65A504);
      if ( !v6 )
        return v4;
      sub_93A0C(2, "src/zlog.c", 360, "pthread_rwlock_unlock fail, rc=[%d]", v6);
      return 0;
    }
    sub_93A0C(2, "src/zlog.c", 353, "zlog_category_table_fetch_category[%s] fail", a1);
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 343, "never call zlog_init() or dzlog_init() before");
  }
  sub_93A0C(2, "src/zlog.c", 365, "------zlog_get_category[%s] fail, end------ ", a1);
  v7 = pthread_rwlock_unlock(&stru_65A504);
  if ( v7 )
    sub_93A0C(2, "src/zlog.c", 368, "pthread_rwlock_unlock fail, rc=[%d]", v7);
  return 0;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A528: using guessed type int dword_65A528;
// 65A538: using guessed type int dword_65A538;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (000837EC) --------------------------------------------------------
int __fastcall sub_837EC(const char *a1)
{
  int v4; // [sp+14h] [bp-8h]
  int v5; // [sp+14h] [bp-8h]
  int v6; // [sp+14h] [bp-8h]

  if ( !a1 )
  {
    sub_93A0C(2, "src/zlog.c", 377, "cname is null or 0");
    return -1;
  }
  sub_93A0C(0, "src/zlog.c", 379, "------dzlog_set_category[%s] start------", a1);
  v4 = pthread_rwlock_wrlock(&stru_65A504);
  if ( v4 )
  {
    sub_93A0C(2, "src/zlog.c", 382, "pthread_rwlock_wrlock fail, rc[%d]", v4);
    return -1;
  }
  if ( dword_65A538 )
  {
    dword_65A530 = (int)sub_86F5C(dword_65A528, a1, *(_DWORD **)(dword_AB7AFC + 9288));
    if ( dword_65A530 )
    {
      sub_93A0C(0, "src/zlog.c", 400, "------dzlog_set_category[%s] end, success------ ", a1);
      v5 = pthread_rwlock_unlock(&stru_65A504);
      if ( !v5 )
        return 0;
      sub_93A0C(2, "src/zlog.c", 403, "pthread_rwlock_unlock fail, rc=[%d]", v5);
      return -1;
    }
    sub_93A0C(2, "src/zlog.c", 396, "zlog_category_table_fetch_category[%s] fail", a1);
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 387, "never call zlog_init() or dzlog_init() before");
  }
  sub_93A0C(2, "src/zlog.c", 408, "------dzlog_set_category[%s] end, fail------ ", a1);
  v6 = pthread_rwlock_unlock(&stru_65A504);
  if ( v6 )
    sub_93A0C(2, "src/zlog.c", 411, "pthread_rwlock_unlock fail, rc=[%d]", v6);
  return -1;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A528: using guessed type int dword_65A528;
// 65A530: using guessed type int dword_65A530;
// 65A538: using guessed type int dword_65A538;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00083A3C) --------------------------------------------------------
int __fastcall sub_83A3C(const char *a1, const char *a2)
{
  int v6; // [sp+14h] [bp-10h]
  int v7; // [sp+14h] [bp-10h]
  int v8; // [sp+18h] [bp-Ch]
  int v9; // [sp+18h] [bp-Ch]
  int v10; // [sp+18h] [bp-Ch]
  int **pointer; // [sp+1Ch] [bp-8h]

  if ( !a1 )
  {
    sub_93A0C(2, "src/zlog.c", 462, "key is null or 0");
    return -1;
  }
  if ( !a2 )
  {
    sub_93A0C(2, "src/zlog.c", 463, "value is null or 0");
    return -1;
  }
  v8 = pthread_rwlock_rdlock(&stru_65A504);
  if ( v8 )
  {
    sub_93A0C(2, "src/zlog.c", 467, "pthread_rwlock_wrlock fail, rc[%d]", v8);
    return -1;
  }
  if ( dword_65A538 )
  {
    pointer = (int **)pthread_getspecific(dword_65A524);
    if ( !pointer )
    {
      pointer = (int **)sub_92048(
                          dword_65A53C,
                          *(_DWORD *)(dword_AB7AFC + 1052),
                          *(_DWORD *)(dword_AB7AFC + 1056),
                          *(_DWORD *)(dword_AB7AFC + 9292));
      if ( !pointer )
      {
        sub_93A0C(2, "src/zlog.c", 476, "zlog_thread_new fail");
        goto LABEL_24;
      }
      v6 = pthread_setspecific(dword_65A524, pointer);
      if ( v6 )
      {
        sub_91EF4((int)pointer);
        sub_93A0C(2, "src/zlog.c", 476, "pthread_setspecific fail, rd[%d]", v6);
        goto LABEL_24;
      }
    }
    if ( *pointer != (int *)dword_65A53C )
    {
      v7 = sub_922EC((int)pointer, *(_DWORD *)(dword_AB7AFC + 1052), *(_DWORD *)(dword_AB7AFC + 1056));
      if ( v7 || (v7 = sub_92498((int)pointer, *(_DWORD *)(dword_AB7AFC + 9292))) != 0 )
      {
        sub_93A0C(2, "src/zlog.c", 476, "zlog_thread_resize_msg_buf fail, rd[%d]", v7);
        goto LABEL_24;
      }
      *pointer = (int *)dword_65A53C;
    }
    if ( !sub_8A49C(pointer[1], a1, a2) )
    {
      v9 = pthread_rwlock_unlock(&stru_65A504);
      if ( !v9 )
        return 0;
      sub_93A0C(2, "src/zlog.c", 485, "pthread_rwlock_unlock fail, rc=[%d]", v9);
      return -1;
    }
    sub_93A0C(2, "src/zlog.c", 479, "zlog_mdc_put fail, key[%s], value[%s]", a1, a2);
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 472, "never call zlog_init() or dzlog_init() before");
  }
LABEL_24:
  v10 = pthread_rwlock_unlock(&stru_65A504);
  if ( v10 )
    sub_93A0C(2, "src/zlog.c", 492, "pthread_rwlock_unlock fail, rc=[%d]", v10);
  return -1;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00083E14) --------------------------------------------------------
int __fastcall sub_83E14(const char *a1)
{
  int **v4; // [sp+14h] [bp-10h]
  int v5; // [sp+18h] [bp-Ch]
  int v6; // [sp+1Ch] [bp-8h]
  int v7; // [sp+1Ch] [bp-8h]
  int v8; // [sp+1Ch] [bp-8h]

  if ( !a1 )
  {
    sub_93A0C(2, "src/zlog.c", 504, "key is null or 0");
    return 0;
  }
  v6 = pthread_rwlock_rdlock(&stru_65A504);
  if ( v6 )
  {
    sub_93A0C(2, "src/zlog.c", 508, "pthread_rwlock_rdlock fail, rc[%d]", v6);
    return 0;
  }
  if ( dword_65A538 )
  {
    v4 = (int **)pthread_getspecific(dword_65A524);
    if ( v4 )
    {
      v5 = sub_8A580(v4[1], (int)a1);
      if ( v5 )
      {
        v7 = pthread_rwlock_unlock(&stru_65A504);
        if ( !v7 )
          return v5;
        sub_93A0C(2, "src/zlog.c", 531, "pthread_rwlock_unlock fail, rc=[%d]", v7);
        return 0;
      }
      sub_93A0C(2, "src/zlog.c", 525, "key[%s] not found in mdc", a1);
    }
    else
    {
      sub_93A0C(2, "src/zlog.c", 519, "thread not found, maybe not use zlog_put_mdc before");
    }
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 513, "never call zlog_init() or dzlog_init() before");
  }
  v8 = pthread_rwlock_unlock(&stru_65A504);
  if ( v8 )
    sub_93A0C(2, "src/zlog.c", 538, "pthread_rwlock_unlock fail, rc=[%d]", v8);
  return 0;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A538: using guessed type int dword_65A538;

//----- (00084018) --------------------------------------------------------
int __fastcall sub_84018(const void *a1)
{
  int result; // r0
  const void ***v3; // [sp+10h] [bp-Ch]
  int v4; // [sp+14h] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/zlog.c", 549, "key is null or 0");
  v4 = pthread_rwlock_rdlock(&stru_65A504);
  if ( v4 )
    return sub_93A0C(2, "src/zlog.c", 553, "pthread_rwlock_rdlock fail, rc[%d]", v4);
  if ( dword_65A538 )
  {
    v3 = (const void ***)pthread_getspecific(dword_65A524);
    if ( v3 )
      sub_8A660(v3[1], a1);
    else
      sub_93A0C(2, "src/zlog.c", 564, "thread not found, maybe not use zlog_put_mdc before");
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 558, "never call zlog_init() or dzlog_init() before");
  }
  result = pthread_rwlock_unlock(&stru_65A504);
  if ( result )
    return sub_93A0C(2, "src/zlog.c", 573, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A538: using guessed type int dword_65A538;

//----- (0008417C) --------------------------------------------------------
int sub_8417C()
{
  int result; // r0
  int **v1; // [sp+8h] [bp-Ch]
  int v2; // [sp+Ch] [bp-8h]

  v2 = pthread_rwlock_rdlock(&stru_65A504);
  if ( v2 )
    return sub_93A0C(2, "src/zlog.c", 586, "pthread_rwlock_rdlock fail, rc[%d]", v2);
  if ( dword_65A538 )
  {
    v1 = (int **)pthread_getspecific(dword_65A524);
    if ( v1 )
      sub_8A554(v1[1]);
    else
      sub_93A0C(2, "src/zlog.c", 597, "thread not found, maybe not use zlog_put_mdc before");
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 591, "never call zlog_init() or dzlog_init() before");
  }
  result = pthread_rwlock_unlock(&stru_65A504);
  if ( result )
    return sub_93A0C(2, "src/zlog.c", 606, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A538: using guessed type int dword_65A538;

//----- (000842AC) --------------------------------------------------------
int __fastcall sub_842AC(int a1, int a2)
{
  int v2; // r3

  memset((void *)(a1 + 1032), 0, 0x20u);
  LOBYTE(v2) = a2 & 7;
  if ( a2 <= 0 )
    v2 = -(-a2 & 7);
  *(_BYTE *)(a1 + a2 / 8 + 1032) |= ~(unsigned __int8)(255 << (8 - v2));
  memset((void *)(a1 + 1032 + a2 / 8 + 1), 255, 31 - a2 / 8);
  return 0;
}

//----- (000843B4) --------------------------------------------------------
int __fastcall sub_843B4(int result, const char *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // [sp+20h] [bp-1Ch]
  int v12; // [sp+2Ch] [bp-10h]
  int v13; // [sp+30h] [bp-Ch]
  int v14; // [sp+30h] [bp-Ch]
  _DWORD *pointer; // [sp+34h] [bp-8h]

  v12 = result;
  v9 = a4;
  LOBYTE(a4) = a7 & 7;
  if ( a7 <= 0 )
    a4 = -(-a7 & 7);
  if ( (((int)*(unsigned __int8 *)(result + a7 / 8 + 1032) >> (7 - a4)) & 1) != 0 )
  {
    pthread_rwlock_rdlock(&stru_65A504);
    if ( !dword_65A538 )
    {
      sub_93A0C(2, "src/zlog.c", 647, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_65A504);
    }
    pointer = pthread_getspecific(dword_65A524);
    if ( !pointer )
    {
      pointer = sub_92048(
                  dword_65A53C,
                  *(_DWORD *)(dword_AB7AFC + 1052),
                  *(_DWORD *)(dword_AB7AFC + 1056),
                  *(_DWORD *)(dword_AB7AFC + 9292));
      if ( !pointer )
      {
        sub_93A0C(2, "src/zlog.c", 651, "zlog_thread_new fail");
        return pthread_rwlock_unlock(&stru_65A504);
      }
      v13 = pthread_setspecific(dword_65A524, pointer);
      if ( v13 )
      {
        sub_91EF4((int)pointer);
        sub_93A0C(2, "src/zlog.c", 651, "pthread_setspecific fail, rd[%d]", v13);
        return pthread_rwlock_unlock(&stru_65A504);
      }
    }
    if ( *pointer != dword_65A53C )
    {
      v14 = sub_922EC((int)pointer, *(_DWORD *)(dword_AB7AFC + 1052), *(_DWORD *)(dword_AB7AFC + 1056));
      if ( v14 || (v14 = sub_92498((int)pointer, *(_DWORD *)(dword_AB7AFC + 9292))) != 0 )
      {
        sub_93A0C(2, "src/zlog.c", 651, "zlog_thread_resize_msg_buf fail, rd[%d]", v14);
        return pthread_rwlock_unlock(&stru_65A504);
      }
      *pointer = dword_65A53C;
    }
    sub_89378((_DWORD *)pointer[2], v12, *(_DWORD *)(v12 + 1028), (int)a2, a3, v9, a5, a6, a7, a8, a9);
    if ( sub_86B34(v12, (int)pointer) )
    {
      sub_93A0C(2, "src/zlog.c", 659, "zlog_output fail, srcfile[%s], srcline[%ld]", a2, a6);
      return pthread_rwlock_unlock(&stru_65A504);
    }
    if ( !*(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    if ( (unsigned int)++dword_65A534 <= *(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    pthread_rwlock_unlock(&stru_65A504);
    result = sub_82FFC((const char *)0xFFFFFFFF);
    if ( result )
      return sub_93A0C(
               2,
               "src/zlog.c",
               676,
               "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  }
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A534: using guessed type int dword_65A534;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (000847B4) --------------------------------------------------------
int __fastcall sub_847B4(int result, const char *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // [sp+20h] [bp-1Ch]
  int v12; // [sp+2Ch] [bp-10h]
  int v13; // [sp+30h] [bp-Ch]
  int v14; // [sp+30h] [bp-Ch]
  _DWORD *pointer; // [sp+34h] [bp-8h]

  v12 = result;
  v9 = a4;
  LOBYTE(a4) = a7 & 7;
  if ( a7 <= 0 )
    a4 = -(-a7 & 7);
  if ( (((int)*(unsigned __int8 *)(result + a7 / 8 + 1032) >> (7 - a4)) & 1) != 0 )
  {
    pthread_rwlock_rdlock(&stru_65A504);
    if ( !dword_65A538 )
    {
      sub_93A0C(2, "src/zlog.c", 694, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_65A504);
    }
    pointer = pthread_getspecific(dword_65A524);
    if ( !pointer )
    {
      pointer = sub_92048(
                  dword_65A53C,
                  *(_DWORD *)(dword_AB7AFC + 1052),
                  *(_DWORD *)(dword_AB7AFC + 1056),
                  *(_DWORD *)(dword_AB7AFC + 9292));
      if ( !pointer )
      {
        sub_93A0C(2, "src/zlog.c", 698, "zlog_thread_new fail");
        return pthread_rwlock_unlock(&stru_65A504);
      }
      v13 = pthread_setspecific(dword_65A524, pointer);
      if ( v13 )
      {
        sub_91EF4((int)pointer);
        sub_93A0C(2, "src/zlog.c", 698, "pthread_setspecific fail, rd[%d]", v13);
        return pthread_rwlock_unlock(&stru_65A504);
      }
    }
    if ( *pointer != dword_65A53C )
    {
      v14 = sub_922EC((int)pointer, *(_DWORD *)(dword_AB7AFC + 1052), *(_DWORD *)(dword_AB7AFC + 1056));
      if ( v14 || (v14 = sub_92498((int)pointer, *(_DWORD *)(dword_AB7AFC + 9292))) != 0 )
      {
        sub_93A0C(2, "src/zlog.c", 698, "zlog_thread_resize_msg_buf fail, rd[%d]", v14);
        return pthread_rwlock_unlock(&stru_65A504);
      }
      *pointer = dword_65A53C;
    }
    sub_89444((_DWORD *)pointer[2], v12, *(_DWORD *)(v12 + 1028), (int)a2, a3, v9, a5, a6, a7, a8, a9);
    if ( sub_86B34(v12, (int)pointer) )
    {
      sub_93A0C(2, "src/zlog.c", 706, "zlog_output fail, srcfile[%s], srcline[%ld]", a2, a6);
      return pthread_rwlock_unlock(&stru_65A504);
    }
    if ( !*(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    if ( (unsigned int)++dword_65A534 <= *(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    pthread_rwlock_unlock(&stru_65A504);
    result = sub_82FFC((const char *)0xFFFFFFFF);
    if ( result )
      return sub_93A0C(
               2,
               "src/zlog.c",
               723,
               "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  }
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A534: using guessed type int dword_65A534;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00084BB4) --------------------------------------------------------
int __fastcall sub_84BB4(int result, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // [sp+20h] [bp-1Ch]
  const char *v11; // [sp+2Ch] [bp-10h]
  int v12; // [sp+30h] [bp-Ch]
  int v13; // [sp+30h] [bp-Ch]
  _DWORD *pointer; // [sp+34h] [bp-8h]

  v11 = (const char *)result;
  v8 = a4;
  LOBYTE(a4) = a6 & 7;
  if ( a6 <= 0 )
    a4 = -(-a6 & 7);
  if ( (((int)*(unsigned __int8 *)(dword_65A530 + a6 / 8 + 1032) >> (7 - a4)) & 1) != 0 )
  {
    pthread_rwlock_rdlock(&stru_65A504);
    if ( !dword_65A538 )
    {
      sub_93A0C(2, "src/zlog.c", 742, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_65A504);
    }
    if ( !dword_65A530 )
    {
      sub_93A0C(
        2,
        "src/zlog.c",
        749,
        "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
      return pthread_rwlock_unlock(&stru_65A504);
    }
    pointer = pthread_getspecific(dword_65A524);
    if ( !pointer )
    {
      pointer = sub_92048(
                  dword_65A53C,
                  *(_DWORD *)(dword_AB7AFC + 1052),
                  *(_DWORD *)(dword_AB7AFC + 1056),
                  *(_DWORD *)(dword_AB7AFC + 9292));
      if ( !pointer )
      {
        sub_93A0C(2, "src/zlog.c", 753, "zlog_thread_new fail");
        return pthread_rwlock_unlock(&stru_65A504);
      }
      v12 = pthread_setspecific(dword_65A524, pointer);
      if ( v12 )
      {
        sub_91EF4((int)pointer);
        sub_93A0C(2, "src/zlog.c", 753, "pthread_setspecific fail, rd[%d]", v12);
        return pthread_rwlock_unlock(&stru_65A504);
      }
    }
    if ( *pointer != dword_65A53C )
    {
      v13 = sub_922EC((int)pointer, *(_DWORD *)(dword_AB7AFC + 1052), *(_DWORD *)(dword_AB7AFC + 1056));
      if ( v13 || (v13 = sub_92498((int)pointer, *(_DWORD *)(dword_AB7AFC + 9292))) != 0 )
      {
        sub_93A0C(2, "src/zlog.c", 753, "zlog_thread_resize_msg_buf fail, rd[%d]", v13);
        return pthread_rwlock_unlock(&stru_65A504);
      }
      *pointer = dword_65A53C;
    }
    sub_89378(
      (_DWORD *)pointer[2],
      dword_65A530,
      *(_DWORD *)(dword_65A530 + 1028),
      (int)v11,
      a2,
      a3,
      v8,
      a5,
      a6,
      a7,
      a8);
    if ( sub_86B34(dword_65A530, (int)pointer) )
    {
      sub_93A0C(2, "src/zlog.c", 761, "zlog_output fail, srcfile[%s], srcline[%ld]", v11, a5);
      return pthread_rwlock_unlock(&stru_65A504);
    }
    if ( !*(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    if ( (unsigned int)++dword_65A534 <= *(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    pthread_rwlock_unlock(&stru_65A504);
    result = sub_82FFC((const char *)0xFFFFFFFF);
    if ( result )
      return sub_93A0C(
               2,
               "src/zlog.c",
               778,
               "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  }
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A530: using guessed type int dword_65A530;
// 65A534: using guessed type int dword_65A534;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (0008500C) --------------------------------------------------------
int __fastcall sub_8500C(int result, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // [sp+20h] [bp-1Ch]
  const char *v11; // [sp+2Ch] [bp-10h]
  int v12; // [sp+30h] [bp-Ch]
  int v13; // [sp+30h] [bp-Ch]
  _DWORD *pointer; // [sp+34h] [bp-8h]

  v11 = (const char *)result;
  v8 = a4;
  LOBYTE(a4) = a6 & 7;
  if ( a6 <= 0 )
    a4 = -(-a6 & 7);
  if ( (((int)*(unsigned __int8 *)(dword_65A530 + a6 / 8 + 1032) >> (7 - a4)) & 1) != 0 )
  {
    pthread_rwlock_rdlock(&stru_65A504);
    if ( !dword_65A538 )
    {
      sub_93A0C(2, "src/zlog.c", 795, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_65A504);
    }
    if ( !dword_65A530 )
    {
      sub_93A0C(
        2,
        "src/zlog.c",
        802,
        "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
      return pthread_rwlock_unlock(&stru_65A504);
    }
    pointer = pthread_getspecific(dword_65A524);
    if ( !pointer )
    {
      pointer = sub_92048(
                  dword_65A53C,
                  *(_DWORD *)(dword_AB7AFC + 1052),
                  *(_DWORD *)(dword_AB7AFC + 1056),
                  *(_DWORD *)(dword_AB7AFC + 9292));
      if ( !pointer )
      {
        sub_93A0C(2, "src/zlog.c", 806, "zlog_thread_new fail");
        return pthread_rwlock_unlock(&stru_65A504);
      }
      v12 = pthread_setspecific(dword_65A524, pointer);
      if ( v12 )
      {
        sub_91EF4((int)pointer);
        sub_93A0C(2, "src/zlog.c", 806, "pthread_setspecific fail, rd[%d]", v12);
        return pthread_rwlock_unlock(&stru_65A504);
      }
    }
    if ( *pointer != dword_65A53C )
    {
      v13 = sub_922EC((int)pointer, *(_DWORD *)(dword_AB7AFC + 1052), *(_DWORD *)(dword_AB7AFC + 1056));
      if ( v13 || (v13 = sub_92498((int)pointer, *(_DWORD *)(dword_AB7AFC + 9292))) != 0 )
      {
        sub_93A0C(2, "src/zlog.c", 806, "zlog_thread_resize_msg_buf fail, rd[%d]", v13);
        return pthread_rwlock_unlock(&stru_65A504);
      }
      *pointer = dword_65A53C;
    }
    sub_89444(
      (_DWORD *)pointer[2],
      dword_65A530,
      *(_DWORD *)(dword_65A530 + 1028),
      (int)v11,
      a2,
      a3,
      v8,
      a5,
      a6,
      a7,
      a8);
    if ( sub_86B34(dword_65A530, (int)pointer) )
    {
      sub_93A0C(2, "src/zlog.c", 814, "zlog_output fail, srcfile[%s], srcline[%ld]", v11, a5);
      return pthread_rwlock_unlock(&stru_65A504);
    }
    if ( !*(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    if ( (unsigned int)++dword_65A534 <= *(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    pthread_rwlock_unlock(&stru_65A504);
    result = sub_82FFC((const char *)0xFFFFFFFF);
    if ( result )
      return sub_93A0C(
               2,
               "src/zlog.c",
               831,
               "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  }
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A530: using guessed type int dword_65A530;
// 65A534: using guessed type int dword_65A534;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00085464) --------------------------------------------------------
int sub_85464(int result, const char *a2, int a3, int a4, int a5, int a6, int a7, int a8, ...)
{
  int v8; // r3
  int v12; // [sp+2Ch] [bp-18h]
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+38h] [bp-Ch]
  _DWORD *pointer; // [sp+3Ch] [bp-8h]
  va_list va; // [sp+58h] [bp+14h] BYREF

  va_start(va, a8);
  v12 = result;
  if ( !result )
    goto LABEL_5;
  LOBYTE(v8) = a7 & 7;
  if ( a7 <= 0 )
    v8 = -(-a7 & 7);
  if ( (((int)*(unsigned __int8 *)(result + a7 / 8 + 1032) >> (7 - v8)) & 1) != 0 )
  {
LABEL_5:
    pthread_rwlock_rdlock(&stru_65A504);
    if ( !dword_65A538 )
    {
      sub_93A0C(2, "src/zlog.c", 850, "never call zlog_init() or dzlog_init() before");
      return pthread_rwlock_unlock(&stru_65A504);
    }
    pointer = pthread_getspecific(dword_65A524);
    if ( !pointer )
    {
      pointer = sub_92048(
                  dword_65A53C,
                  *(_DWORD *)(dword_AB7AFC + 1052),
                  *(_DWORD *)(dword_AB7AFC + 1056),
                  *(_DWORD *)(dword_AB7AFC + 9292));
      if ( !pointer )
      {
        sub_93A0C(2, "src/zlog.c", 854, "zlog_thread_new fail");
        return pthread_rwlock_unlock(&stru_65A504);
      }
      v13 = pthread_setspecific(dword_65A524, pointer);
      if ( v13 )
      {
        sub_91EF4((int)pointer);
        sub_93A0C(2, "src/zlog.c", 854, "pthread_setspecific fail, rd[%d]", v13);
        return pthread_rwlock_unlock(&stru_65A504);
      }
    }
    if ( *pointer != dword_65A53C )
    {
      v14 = sub_922EC((int)pointer, *(_DWORD *)(dword_AB7AFC + 1052), *(_DWORD *)(dword_AB7AFC + 1056));
      if ( v14 || (v14 = sub_92498((int)pointer, *(_DWORD *)(dword_AB7AFC + 9292))) != 0 )
      {
        sub_93A0C(2, "src/zlog.c", 854, "zlog_thread_resize_msg_buf fail, rd[%d]", v14);
        return pthread_rwlock_unlock(&stru_65A504);
      }
      *pointer = dword_65A53C;
    }
    sub_89378((_DWORD *)pointer[2], v12, *(_DWORD *)(v12 + 1028), (int)a2, a3, a4, a5, a6, a7, a8, (int)va);
    if ( sub_86B34(v12, (int)pointer) )
    {
      sub_93A0C(2, "src/zlog.c", 861, "zlog_output fail, srcfile[%s], srcline[%ld]", a2, a6);
      return pthread_rwlock_unlock(&stru_65A504);
    }
    if ( !*(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    if ( (unsigned int)++dword_65A534 <= *(_DWORD *)(dword_AB7AFC + 9276) )
      return pthread_rwlock_unlock(&stru_65A504);
    pthread_rwlock_unlock(&stru_65A504);
    result = sub_82FFC((const char *)0xFFFFFFFF);
    if ( result )
      return sub_93A0C(
               2,
               "src/zlog.c",
               880,
               "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  }
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A534: using guessed type int dword_65A534;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00085878) --------------------------------------------------------
int sub_85878(const char *a1, int a2, int a3, int a4, int a5, int a6, int a7, ...)
{
  int v7; // r3
  int result; // r0
  int v13; // [sp+38h] [bp-Ch]
  int v14; // [sp+38h] [bp-Ch]
  _DWORD *pointer; // [sp+3Ch] [bp-8h]
  va_list va; // [sp+54h] [bp+10h] BYREF

  va_start(va, a7);
  pthread_rwlock_rdlock(&stru_65A504);
  if ( !dword_65A538 )
  {
    sub_93A0C(2, "src/zlog.c", 896, "never call zlog_init() or dzlog_init() before");
    return pthread_rwlock_unlock(&stru_65A504);
  }
  if ( !dword_65A530 )
  {
    sub_93A0C(
      2,
      "src/zlog.c",
      903,
      "zlog_default_category is null,dzlog_init() or dzlog_set_cateogry() is not called above");
    return pthread_rwlock_unlock(&stru_65A504);
  }
  LOBYTE(v7) = a6 & 7;
  if ( a6 <= 0 )
    v7 = -(-a6 & 7);
  if ( (((int)*(unsigned __int8 *)(dword_65A530 + a6 / 8 + 1032) >> (7 - v7)) & 1) == 0 )
    return pthread_rwlock_unlock(&stru_65A504);
  pointer = pthread_getspecific(dword_65A524);
  if ( !pointer )
  {
    pointer = sub_92048(
                dword_65A53C,
                *(_DWORD *)(dword_AB7AFC + 1052),
                *(_DWORD *)(dword_AB7AFC + 1056),
                *(_DWORD *)(dword_AB7AFC + 9292));
    if ( !pointer )
    {
      sub_93A0C(2, "src/zlog.c", 909, "zlog_thread_new fail");
      return pthread_rwlock_unlock(&stru_65A504);
    }
    v13 = pthread_setspecific(dword_65A524, pointer);
    if ( v13 )
    {
      sub_91EF4((int)pointer);
      sub_93A0C(2, "src/zlog.c", 909, "pthread_setspecific fail, rd[%d]", v13);
      return pthread_rwlock_unlock(&stru_65A504);
    }
  }
  if ( *pointer != dword_65A53C )
  {
    v14 = sub_922EC((int)pointer, *(_DWORD *)(dword_AB7AFC + 1052), *(_DWORD *)(dword_AB7AFC + 1056));
    if ( v14 || (v14 = sub_92498((int)pointer, *(_DWORD *)(dword_AB7AFC + 9292))) != 0 )
    {
      sub_93A0C(2, "src/zlog.c", 909, "zlog_thread_resize_msg_buf fail, rd[%d]", v14);
      return pthread_rwlock_unlock(&stru_65A504);
    }
    *pointer = dword_65A53C;
  }
  sub_89378(
    (_DWORD *)pointer[2],
    dword_65A530,
    *(_DWORD *)(dword_65A530 + 1028),
    (int)a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    (int)va);
  if ( sub_86B34(dword_65A530, (int)pointer) )
  {
    sub_93A0C(2, "src/zlog.c", 918, "zlog_output fail, srcfile[%s], srcline[%ld]", a1, a5);
    return pthread_rwlock_unlock(&stru_65A504);
  }
  if ( !*(_DWORD *)(dword_AB7AFC + 9276) )
    return pthread_rwlock_unlock(&stru_65A504);
  if ( (unsigned int)++dword_65A534 <= *(_DWORD *)(dword_AB7AFC + 9276) )
    return pthread_rwlock_unlock(&stru_65A504);
  pthread_rwlock_unlock(&stru_65A504);
  result = sub_82FFC((const char *)0xFFFFFFFF);
  if ( result )
    return sub_93A0C(
             2,
             "src/zlog.c",
             937,
             "reach reload-conf-period but zlog_reload fail, zlog-chk-conf [file] see detail");
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A524: using guessed type int dword_65A524;
// 65A530: using guessed type int dword_65A530;
// 65A534: using guessed type int dword_65A534;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00085CD8) --------------------------------------------------------
int sub_85CD8()
{
  int result; // r0
  int v1; // [sp+Ch] [bp-8h]

  v1 = pthread_rwlock_rdlock(&stru_65A504);
  if ( v1 )
    return sub_93A0C(2, "src/zlog.c", 948, "pthread_rwlock_wrlock fail, rc[%d]", v1);
  sub_93A0C(1, "src/zlog.c", 951, "------zlog_profile start------ ");
  sub_93A0C(1, "src/zlog.c", 952, "is init:[%d]", dword_65A538);
  sub_93A0C(1, "src/zlog.c", 953, "init version:[%d]", dword_65A53C);
  sub_87068(dword_AB7AFC, 1);
  sub_8A8D8((const void *)dword_65A52C, 1);
  sub_86BD8((const void *)dword_65A528, 1);
  if ( dword_65A530 )
  {
    sub_93A0C(1, "src/zlog.c", 958, "-default_category-");
    sub_861F0((const void **)dword_65A530, 1);
  }
  sub_93A0C(1, "src/zlog.c", 961, "------zlog_profile end------ ");
  result = pthread_rwlock_unlock(&stru_65A504);
  if ( result )
    return sub_93A0C(2, "src/zlog.c", 964, "pthread_rwlock_unlock fail, rc=[%d]", result);
  return result;
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A528: using guessed type int dword_65A528;
// 65A52C: using guessed type int dword_65A52C;
// 65A530: using guessed type int dword_65A530;
// 65A538: using guessed type int dword_65A538;
// 65A53C: using guessed type int dword_65A53C;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00085EA0) --------------------------------------------------------
int __fastcall sub_85EA0(const char *a1, int a2)
{
  char *v6; // [sp+18h] [bp-14h]
  int v7; // [sp+1Ch] [bp-10h]
  int v8; // [sp+1Ch] [bp-10h]
  int i; // [sp+20h] [bp-Ch]
  int v10; // [sp+24h] [bp-8h]

  v10 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v7 = pthread_rwlock_wrlock(&stru_65A504);
      if ( v7 )
      {
        sub_93A0C(2, "src/zlog.c", 983, "pthread_rwlock_rdlock fail, rd[%d]", v7);
        return -1;
      }
      else
      {
        if ( dword_65A538 )
        {
          v6 = sub_8A78C(a1, a2);
          if ( v6 )
          {
            v10 = sub_93250(dword_65A52C, (unsigned int)v6, (unsigned int)v6);
            if ( v10 )
            {
              sub_8A718(v6);
              sub_93A0C(2, "src/zlog.c", 1002, "zc_hashtable_put fail");
            }
            else
            {
              for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(dword_AB7AFC + 9288) + 4); ++i )
                sub_8FE50(*(_DWORD *)(**(_DWORD **)(dword_AB7AFC + 9288) + 4 * i), dword_65A52C);
            }
          }
          else
          {
            v10 = -1;
            sub_93A0C(2, "src/zlog.c", 995, "zlog_record_new fail");
          }
        }
        else
        {
          sub_93A0C(2, "src/zlog.c", 988, "never call zlog_init() or dzlog_init() before");
        }
        v8 = pthread_rwlock_unlock(&stru_65A504);
        if ( v8 )
        {
          sub_93A0C(2, "src/zlog.c", 1013, "pthread_rwlock_unlock fail, rd=[%d]", v8);
          return -1;
        }
        else
        {
          return v10;
        }
      }
    }
    else
    {
      sub_93A0C(2, "src/zlog.c", 979, "record_output is null or 0");
      return -1;
    }
  }
  else
  {
    sub_93A0C(2, "src/zlog.c", 978, "rname is null or 0");
    return -1;
  }
}
// 65A504: using guessed type pthread_rwlock_t stru_65A504;
// 65A52C: using guessed type int dword_65A52C;
// 65A538: using guessed type int dword_65A538;
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (00086140) --------------------------------------------------------
bool __fastcall sub_86140(int a1, int a2)
{
  int v2; // r3

  if ( !a1 )
    return 0;
  LOBYTE(v2) = a2 & 7;
  if ( a2 <= 0 )
    v2 = -(-a2 & 7);
  return (((int)*(unsigned __int8 *)(a1 + a2 / 8 + 1032) >> (7 - v2)) & 1) != 0;
}

//----- (000861D0) --------------------------------------------------------
const char *sub_861D0()
{
  return "1.2.12";
}

//----- (000861F0) --------------------------------------------------------
int __fastcall sub_861F0(const void **a1, int a2)
{
  int result; // r0
  int i; // [sp+1Ch] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/category.c", 22, "a_category is null or 0");
  result = sub_93A0C(a2, "src/category.c", 26, "--category[%p][%s][%p]--", a1, (const char *)a1, a1[274]);
  if ( a1[274] )
  {
    for ( i = 0; i < *((_DWORD *)a1[274] + 1); ++i )
      result = sub_8C408(*(_DWORD *)(*(_DWORD *)a1[274] + 4 * i), a2);
  }
  return result;
}

//----- (000862F8) --------------------------------------------------------
void __fastcall sub_862F8(int *a1)
{
  if ( a1 )
  {
    if ( a1[274] )
      sub_92670(a1[274]);
    sub_93A0C(0, "src/category.c", 40, "zlog_category_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_93A0C(2, "src/category.c", 38, "a_category is null or 0");
  }
}

//----- (0008638C) --------------------------------------------------------
int __fastcall sub_8638C(int result, int a2)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i <= 0x1F; ++i )
    *(_BYTE *)(result + i + 1032) |= *(_BYTE *)(a2 + i + 4104);
  return result;
}

//----- (00086428) --------------------------------------------------------
int __fastcall sub_86428(int a1, _DWORD *a2)
{
  const char *v6; // [sp+14h] [bp-18h]
  int v7; // [sp+1Ch] [bp-10h]
  int v8; // [sp+20h] [bp-Ch]
  int i; // [sp+24h] [bp-8h]

  v8 = 0;
  v7 = 0;
  if ( *(_DWORD *)(a1 + 1096) )
    sub_92670(*(_DWORD *)(a1 + 1096));
  memset((void *)(a1 + 1032), 0, 0x20u);
  *(_DWORD *)(a1 + 1096) = sub_92568(0);
  if ( !*(_DWORD *)(a1 + 1096) )
  {
    sub_93A0C(2, "src/category.c", 72, "zc_arraylist_new fail");
    return -1;
  }
  for ( i = 0; i < a2[1]; ++i )
  {
    v6 = *(const char **)(*a2 + 4 * i);
    if ( sub_8FD08(v6, (const char *)a1) )
    {
      if ( sub_92968(*(_DWORD *)(a1 + 1096), (int)v6) )
      {
        sub_93A0C(2, "src/category.c", 81, "zc_arrylist_add fail");
        goto LABEL_22;
      }
      sub_8638C(a1, (int)v6);
      ++v8;
    }
    if ( sub_8FC90(v6) )
      v7 = (int)v6;
  }
  if ( v8 )
    return 0;
  if ( !v7 )
  {
    sub_93A0C(0, "src/category.c", 103, "category[%s], no match rules & no wastebin_rule", (const char *)a1);
    return 0;
  }
  sub_93A0C(0, "src/category.c", 95, "category[%s], no match rules, use wastebin_rule", (const char *)a1);
  if ( !sub_92968(*(_DWORD *)(a1 + 1096), v7) )
  {
    sub_8638C(a1, v7);
    return 0;
  }
  sub_93A0C(2, "src/category.c", 97, "zc_arrylist_add fail");
LABEL_22:
  sub_92670(*(_DWORD *)(a1 + 1096));
  *(_DWORD *)(a1 + 1096) = 0;
  return -1;
}

//----- (000866B8) --------------------------------------------------------
char *__fastcall sub_866B8(const char *a1, _DWORD *a2)
{
  int *v3; // r0
  char *dest; // [sp+10h] [bp-Ch]
  size_t v8; // [sp+14h] [bp-8h]

  if ( a1 )
  {
    if ( a2 )
    {
      v8 = strlen(a1);
      if ( v8 <= 0x400 )
      {
        dest = (char *)calloc(1u, 0x450u);
        if ( dest )
        {
          strcpy(dest, a1);
          *((_DWORD *)dest + 257) = v8;
          if ( sub_86428((int)dest, a2) )
          {
            sub_93A0C(2, "src/category.c", 135, "zlog_category_fit_rules fail");
            sub_862F8((int *)dest);
            return 0;
          }
          else
          {
            sub_861F0((const void **)dest, 0);
            return dest;
          }
        }
        else
        {
          v3 = _errno_location();
          sub_93A0C(2, "src/category.c", 129, "calloc fail, errno[%d]", *v3);
          return 0;
        }
      }
      else
      {
        sub_93A0C(2, "src/category.c", 124, "name[%s] too long", a1);
        return 0;
      }
    }
    else
    {
      sub_93A0C(2, "src/category.c", 120, "rules is null or 0");
      return 0;
    }
  }
  else
  {
    sub_93A0C(2, "src/category.c", 119, "name is null or 0");
    return 0;
  }
}

//----- (00086844) --------------------------------------------------------
int __fastcall sub_86844(_DWORD *a1, _DWORD *a2)
{
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a1[275] )
        sub_92670(a1[275]);
      a1[275] = a1[274];
      a1[274] = 0;
      memcpy(a1 + 266, a1 + 258, 0x20u);
      if ( sub_86428((int)a1, a2) )
      {
        sub_93A0C(2, "src/category.c", 163, "zlog_category_obtain_rules fail");
        a1[274] = 0;
        return -1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      sub_93A0C(2, "src/category.c", 151, "new_rules is null or 0");
      return -1;
    }
  }
  else
  {
    sub_93A0C(2, "src/category.c", 150, "a_category is null or 0");
    return -1;
  }
}

//----- (00086970) --------------------------------------------------------
void *__fastcall sub_86970(int a1)
{
  if ( !a1 )
    return (void *)sub_93A0C(2, "src/category.c", 176, "a_category is null or 0");
  if ( !*(_DWORD *)(a1 + 1100) )
    return (void *)sub_93A0C(1, "src/category.c", 178, "a_category->fit_rules_backup is NULL, never update before");
  sub_92670(*(_DWORD *)(a1 + 1100));
  *(_DWORD *)(a1 + 1100) = 0;
  return memset((void *)(a1 + 1064), 0, 0x20u);
}

//----- (00086A20) --------------------------------------------------------
void *__fastcall sub_86A20(int *a1)
{
  if ( !a1 )
    return (void *)sub_93A0C(2, "src/category.c", 194, "a_category is null or 0");
  if ( !a1[275] )
    return (void *)sub_93A0C(1, "src/category.c", 196, "a_category->fit_rules_backup in NULL, never update before");
  if ( a1[274] )
    sub_92670(a1[274]);
  a1[274] = a1[275];
  a1[275] = 0;
  memcpy(a1 + 258, a1 + 266, 0x20u);
  return memset(a1 + 266, 0, 0x20u);
}

//----- (00086B34) --------------------------------------------------------
int __fastcall sub_86B34(int a1, int a2)
{
  int v5; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  v5 = 0;
  for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(a1 + 1096) + 4); ++i )
    v5 = sub_8FAE4(*(_DWORD *)(**(_DWORD **)(a1 + 1096) + 4 * i), a2);
  return v5;
}

//----- (00086BD8) --------------------------------------------------------
int __fastcall sub_86BD8(const void *a1, int a2)
{
  int result; // r0
  int i; // [sp+14h] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/category_table.c", 21, "categories is null or 0");
  sub_93A0C(a2, "src/category_table.c", 22, "-category_table[%p]-", a1);
  result = sub_93798((int)a1);
  for ( i = result; i; i = result )
  {
    sub_861F0(*(const void ***)(i + 8), a2);
    result = sub_93834((int)a1, (unsigned int *)i);
  }
  return result;
}

//----- (00086C8C) --------------------------------------------------------
int __fastcall sub_86C8C(const void *a1)
{
  if ( !a1 )
    return sub_93A0C(2, "src/category_table.c", 34, "categories is null or 0");
  sub_92CD8((int)a1);
  return sub_93A0C(0, "src/category_table.c", 36, "zlog_category_table_del[%p]", a1);
}

//----- (00086D00) --------------------------------------------------------
_DWORD *sub_86D00()
{
  _DWORD *v2; // [sp+Ch] [bp-8h]

  v2 = sub_92BA8(0x14u, 604420, 604532, 0, (int)sub_862F8);
  if ( v2 )
  {
    sub_86BD8(v2, 0);
    return v2;
  }
  else
  {
    sub_93A0C(2, "src/category_table.c", 49, "zc_hashtable_new fail");
    return 0;
  }
}

//----- (00086D84) --------------------------------------------------------
int __fastcall sub_86D84(int a1, _DWORD *a2)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  if ( a1 )
  {
    for ( i = sub_93798(a1); i; i = sub_93834(a1, (unsigned int *)i) )
    {
      if ( sub_86844(*(_DWORD **)(i + 8), a2) )
      {
        sub_93A0C(2, "src/category_table.c", 66, "zlog_category_update_rules fail, try rollback");
        return -1;
      }
    }
    return 0;
  }
  else
  {
    sub_93A0C(2, "src/category_table.c", 62, "categories is null or 0", a2, 0);
    return -1;
  }
}

//----- (00086E4C) --------------------------------------------------------
int __fastcall sub_86E4C(int a1)
{
  int result; // r0
  int i; // [sp+Ch] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/category_table.c", 78, "categories is null or 0");
  result = sub_93798(a1);
  for ( i = result; i; i = result )
  {
    sub_86970(*(_DWORD *)(i + 8));
    result = sub_93834(a1, (unsigned int *)i);
  }
  return result;
}

//----- (00086ED4) --------------------------------------------------------
int __fastcall sub_86ED4(int a1)
{
  int result; // r0
  int i; // [sp+Ch] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/category_table.c", 91, "categories is null or 0");
  result = sub_93798(a1);
  for ( i = result; i; i = result )
  {
    sub_86A20(*(int **)(i + 8));
    result = sub_93834(a1, (unsigned int *)i);
  }
  return result;
}

//----- (00086F5C) --------------------------------------------------------
int *__fastcall sub_86F5C(int a1, const char *a2, _DWORD *a3)
{
  int v8; // [sp+14h] [bp-8h]
  int *v9; // [sp+14h] [bp-8h]

  if ( a1 )
  {
    v8 = sub_93190(a1, (int)a2);
    if ( v8 )
    {
      return (int *)v8;
    }
    else
    {
      v9 = (int *)sub_866B8(a2, a3);
      if ( v9 )
      {
        if ( sub_93250(a1, (unsigned int)v9, (unsigned int)v9) )
        {
          sub_93A0C(2, "src/category_table.c", 119, "zc_hashtable_put fail");
          sub_862F8(v9);
          return 0;
        }
        else
        {
          return v9;
        }
      }
      else
      {
        sub_93A0C(2, "src/category_table.c", 114, "zc_category_new fail");
        return 0;
      }
    }
  }
  else
  {
    sub_93A0C(2, "src/category_table.c", 105, "categories is null or 0");
    return 0;
  }
}

//----- (00087068) --------------------------------------------------------
int __fastcall sub_87068(int a1, int a2)
{
  int result; // r0
  int i; // [sp+1Ch] [bp-8h]
  int j; // [sp+1Ch] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/conf.c", 44, "a_conf is null or 0");
  sub_93A0C(a2, "src/conf.c", 45, "-conf[%p]-", (const void *)a1);
  sub_93A0C(a2, "src/conf.c", 46, "--global--");
  sub_93A0C(a2, "src/conf.c", 47, "---file[%s],mtime[%s]---", (const char *)a1, (const char *)(a1 + 1025));
  sub_93A0C(a2, "src/conf.c", 48, "---strict init[%d]---", *(_DWORD *)(a1 + 1048));
  sub_93A0C(a2, "src/conf.c", 49, "---buffer min[%ld]---", *(_DWORD *)(a1 + 1052));
  sub_93A0C(a2, "src/conf.c", 50, "---buffer max[%ld]---", *(_DWORD *)(a1 + 1056));
  if ( *(_DWORD *)(a1 + 9264) )
  {
    sub_93A0C(a2, "src/conf.c", 52, "---default_format---");
    sub_8950C(*(_DWORD *)(a1 + 9264), a2);
  }
  sub_93A0C(a2, "src/conf.c", 55, "---file perms[0%o]---", *(_DWORD *)(a1 + 9268));
  sub_93A0C(a2, "src/conf.c", 56, "---reload conf period[%ld]---", *(_DWORD *)(a1 + 9276));
  sub_93A0C(a2, "src/conf.c", 57, "---fsync period[%ld]---", *(_DWORD *)(a1 + 9272));
  result = sub_93A0C(a2, "src/conf.c", 59, "---rotate lock file[%s]---", (const char *)(a1 + 1060));
  if ( *(_DWORD *)(a1 + 5160) )
    result = sub_8AA84(*(_DWORD *)(a1 + 5160), a2);
  if ( *(_DWORD *)(a1 + 9280) )
    result = sub_89B60(*(_DWORD **)(a1 + 9280), a2);
  if ( *(_DWORD *)(a1 + 9284) )
  {
    result = sub_93A0C(a2, "src/conf.c", 65, "--format list[%p]--", *(const void **)(a1 + 9284));
    for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(a1 + 9284) + 4); ++i )
      result = sub_8950C(*(_DWORD *)(**(_DWORD **)(a1 + 9284) + 4 * i), a2);
  }
  if ( *(_DWORD *)(a1 + 9288) )
  {
    result = sub_93A0C(a2, "src/conf.c", 72, "--rule_list[%p]--", *(const void **)(a1 + 9288));
    for ( j = 0; j < *(_DWORD *)(*(_DWORD *)(a1 + 9288) + 4); ++j )
      result = sub_8C408(*(_DWORD *)(**(_DWORD **)(a1 + 9288) + 4 * j), a2);
  }
  return result;
}

//----- (00087470) --------------------------------------------------------
int __fastcall sub_87470(int a1)
{
  const void *v2; // [sp+0h] [bp-Ch]

  if ( !a1 )
    return sub_93A0C(2, "src/conf.c", 83, "a_conf is null or 0");
  if ( *(_DWORD *)(a1 + 5160) )
    sub_8AC28(*(pthread_mutex_t **)(a1 + 5160));
  if ( *(_DWORD *)(a1 + 9280) )
    sub_89C44(*(const void **)(a1 + 9280));
  if ( *(_DWORD *)(a1 + 9264) )
    sub_895A4(*(int **)(a1 + 9264));
  if ( *(_DWORD *)(a1 + 9284) )
    sub_92670(*(_DWORD *)(a1 + 9284));
  if ( *(_DWORD *)(a1 + 9288) )
    sub_92670(*(_DWORD *)(a1 + 9288));
  free((void *)a1);
  return sub_93A0C(0, "src/conf.c", 90, "zlog_conf_del[%p]", v2);
}
// 87594: variable 'v2' is possibly undefined

//----- (000875A4) --------------------------------------------------------
char *__fastcall sub_875A4(const char *a1)
{
  int *v1; // r0
  char *v3; // r0
  int *v4; // r0
  const char *v5; // r12
  _DWORD *v6; // r5
  int v7; // r1
  int v8; // r2
  int v9; // r3
  char *s; // [sp+14h] [bp-20h]
  int v13; // [sp+18h] [bp-1Ch]
  unsigned int v14; // [sp+1Ch] [bp-18h]

  v14 = 0;
  s = (char *)calloc(1u, 0x2450u);
  if ( s )
  {
    if ( a1 && *a1 )
    {
      v14 = snprintf(s, 0x401u, "%s", a1);
      v13 = 1;
    }
    else if ( getenv("ZLOG_CONF_PATH") )
    {
      v3 = getenv("ZLOG_CONF_PATH");
      v14 = snprintf(s, 0x401u, "%s", v3);
      v13 = 1;
    }
    else
    {
      memset(s, 0, 0x401u);
      v13 = 0;
    }
    if ( v14 <= 0x400 )
    {
      *((_DWORD *)s + 262) = 1;
      *((_DWORD *)s + 263) = 1024;
      *((_DWORD *)s + 264) = 0x200000;
      if ( v13 )
        strcpy(s + 1060, s);
      else
        strcpy(s + 1060, "/tmp/zlog.lock");
      v5 = "default = \"%D %V [%p:%F:%L] %m%n\"";
      v6 = s + 5164;
      do
      {
        v7 = *((_DWORD *)v5 + 1);
        v8 = *((_DWORD *)v5 + 2);
        v9 = *((_DWORD *)v5 + 3);
        *v6 = *(_DWORD *)v5;
        v6[1] = v7;
        v6[2] = v8;
        v6[3] = v9;
        v5 += 16;
        v6 += 4;
      }
      while ( v5 != "\"" );
      *(_WORD *)v6 = *(_WORD *)v5;
      *((_DWORD *)s + 2317) = 384;
      *((_DWORD *)s + 2319) = 0;
      *((_DWORD *)s + 2318) = 0;
      *((_DWORD *)s + 2320) = sub_89DDC();
      if ( *((_DWORD *)s + 2320) )
      {
        *((_DWORD *)s + 2321) = sub_92568((int)sub_895A4);
        if ( *((_DWORD *)s + 2321) )
        {
          *((_DWORD *)s + 2322) = sub_92568((int)sub_8F938);
          if ( *((_DWORD *)s + 2322) )
          {
            if ( v13 )
            {
              if ( sub_87BA4((int)s) )
              {
                sub_93A0C(2, "src/conf.c", 160, "zlog_conf_build_with_file fail");
                goto LABEL_28;
              }
            }
            else if ( sub_879CC((int)s) )
            {
              sub_93A0C(2, "src/conf.c", 165, "zlog_conf_build_without_file fail");
              goto LABEL_28;
            }
            sub_87068((int)s, 0);
            return s;
          }
          sub_93A0C(2, "src/conf.c", 154, "init rule_list fail");
        }
        else
        {
          sub_93A0C(2, "src/conf.c", 148, "zc_arraylist_new fail");
        }
      }
      else
      {
        sub_93A0C(2, "src/conf.c", 142, "zlog_level_list_new fail");
      }
    }
    else
    {
      v4 = _errno_location();
      sub_93A0C(2, "src/conf.c", 120, "not enough space for path name, nwrite=[%d], errno[%d]", v14, *v4);
    }
LABEL_28:
    sub_87470((int)s);
    return 0;
  }
  v1 = _errno_location();
  sub_93A0C(2, "src/conf.c", 105, "calloc fail, errno[%d]", *v1);
  return 0;
}

//----- (000879CC) --------------------------------------------------------
int __fastcall sub_879CC(int a1)
{
  char *v4; // [sp+1Ch] [bp-8h]

  *(_DWORD *)(a1 + 9264) = sub_89640((const char *)(a1 + 5164), (_DWORD *)(a1 + 9292));
  if ( *(_DWORD *)(a1 + 9264) )
  {
    *(_DWORD *)(a1 + 5160) = sub_8AD38((const char *)(a1 + 1060));
    if ( *(_DWORD *)(a1 + 5160) )
    {
      v4 = sub_8E3F0(
             "*.*        >stdout",
             *(_DWORD **)(a1 + 9280),
             *(_DWORD *)(a1 + 9264),
             *(_DWORD *)(a1 + 9284),
             *(_DWORD *)(a1 + 9268),
             *(_DWORD *)(a1 + 9272),
             (_DWORD *)(a1 + 9292));
      if ( v4 )
      {
        if ( sub_92968(*(_DWORD *)(a1 + 9288), (int)v4) )
        {
          sub_8F938((int)v4);
          sub_93A0C(2, "src/conf.c", 209, "zc_arraylist_add fail");
          return -1;
        }
        else
        {
          return 0;
        }
      }
      else
      {
        sub_93A0C(2, "src/conf.c", 202, "zlog_rule_new fail");
        return -1;
      }
    }
    else
    {
      sub_93A0C(2, "src/conf.c", 189, "zlog_rotater_new fail");
      return -1;
    }
  }
  else
  {
    sub_93A0C(2, "src/conf.c", 183, "zlog_format_new fail");
    return -1;
  }
}

//----- (00087BA4) --------------------------------------------------------
int __fastcall sub_87BA4(int a1)
{
  int *v1; // r0
  int v5; // [sp+14h] [bp-10C8h] BYREF
  char v6[4100]; // [sp+18h] [bp-10C4h] BYREF
  struct tm tp; // [sp+101Ch] [bp-C0h] BYREF
  time_t v8; // [sp+1098h] [bp-44h] BYREF
  size_t v9; // [sp+10B0h] [bp-2Ch]
  FILE *stream; // [sp+10B4h] [bp-28h]
  int v11; // [sp+10B8h] [bp-24h]
  int j; // [sp+10BCh] [bp-20h]
  int v13; // [sp+10C0h] [bp-1Ch]
  char *i; // [sp+10C4h] [bp-18h]
  char *s; // [sp+10C8h] [bp-14h]
  int v16; // [sp+10CCh] [bp-10h]

  v16 = 0;
  stream = 0;
  s = 0;
  i = 0;
  v13 = 0;
  j = 0;
  v11 = 0;
  v5 = 0;
  if ( !sub_97038() )
  {
    localtime_r(&v8, &tp);
    strftime((char *)(a1 + 1025), 0x15u, "%F %T", &tp);
    stream = (FILE *)fopen64(a1, "r");
    if ( !stream )
    {
      sub_93A0C(2, "src/conf.c", 245, "open configure file[%s] fail", (const char *)a1);
      return -1;
    }
    s = v6;
    memset(v6, 0, 0x1001u);
    while ( 1 )
    {
      do
      {
        if ( !fgets(s, 4097 - (s - v6), stream) )
        {
LABEL_41:
          fclose(stream);
          return v16;
        }
        ++v13;
        v9 = strlen(s);
        if ( s[v9 - 1] == 10 )
          s[v9 - 1] = 0;
        for ( i = s; *i && ((*_ctype_b_loc())[(unsigned __int8)*i] & 0x2000) != 0; ++i )
          ;
      }
      while ( !*i || *i == 35 );
      for ( j = 0; i[j]; ++j )
        s[j] = i[j];
      s[j] = 0;
      for ( i = &s[strlen(s) - 1]; ((*_ctype_b_loc())[(unsigned __int8)*i] & 0x2000) != 0; --i )
        ;
      if ( *i != 92 )
        break;
      if ( i - v6 <= 4066 )
      {
        --i;
        while ( ((*_ctype_b_loc())[(unsigned __int8)*i] & 0x2000) != 0 )
          --i;
        *++i = 0;
        s = i;
      }
      else
      {
        s = v6;
LABEL_28:
        *++i = 0;
        v11 = 0;
        for ( i = v6; *i; ++i )
        {
          if ( *i == 34 )
          {
            v11 ^= 1u;
          }
          else if ( *i == 35 && !v11 )
          {
            *i = 0;
            break;
          }
        }
        v16 = sub_881B0(a1, v6, &v5);
        if ( v16 < 0 )
        {
          sub_93A0C(2, "src/conf.c", 314, "parse configure file[%s]line_no[%ld] fail", (const char *)a1, v13);
          sub_93A0C(2, "src/conf.c", 315, "line[%s]", v6);
          goto LABEL_41;
        }
        if ( v16 > 0 )
        {
          sub_93A0C(1, "src/conf.c", 318, "parse configure file[%s]line_no[%ld] fail", (const char *)a1, v13);
          sub_93A0C(1, "src/conf.c", 319, "line[%s]", v6);
          sub_93A0C(1, "src/conf.c", 320, "as strict init is set to false, ignore and go on");
          v16 = 0;
        }
      }
    }
    s = v6;
    goto LABEL_28;
  }
  v1 = _errno_location();
  sub_93A0C(2, "src/conf.c", 238, "lstat conf file[%s] fail, errno[%d]", (const char *)a1, *v1);
  return -1;
}
// 1292C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (000881B0) --------------------------------------------------------
int __fastcall sub_881B0(int a1, const char *a2, int *a3)
{
  size_t v3; // r0
  int v6; // [sp+0h] [bp-5054h]
  int v7; // [sp+4h] [bp-5050h]
  char v11[4100]; // [sp+20h] [bp-5034h] BYREF
  char v12[4100]; // [sp+1024h] [bp-4030h] BYREF
  char v13[4100]; // [sp+2028h] [bp-302Ch] BYREF
  char v14[4100]; // [sp+302Ch] [bp-2028h] BYREF
  char v15[4100]; // [sp+4030h] [bp-1024h] BYREF
  int v16; // [sp+5034h] [bp-20h] BYREF
  int v17; // [sp+5038h] [bp-1Ch]
  int v18; // [sp+503Ch] [bp-18h]
  char *v19; // [sp+5040h] [bp-14h]
  int *v20; // [sp+5044h] [bp-10h]

  v20 = 0;
  v19 = 0;
  if ( strlen(a2) <= 0x1000 )
  {
    if ( *a2 != 91 )
    {
      switch ( *a3 )
      {
        case 1:
          memset(v15, 0, 0x1001u);
          memset(v11, 0, 0x1001u);
          v18 = _isoc99_sscanf(a2, " %[^=]= %s ", v15, v11);
          if ( v18 == 2 )
          {
            memset(v14, 0, 0x1001u);
            memset(v13, 0, 0x1001u);
            memset(v12, 0, 0x1001u);
            v16 = 0;
            v18 = _isoc99_sscanf(v15, "%s%n%s%s", v14, &v16, v13, v12);
            if ( !strcmp(v14, "strict") && !strcmp(v13, "init") )
            {
              *(_DWORD *)(a1 + 1048) = strcasecmp(v11, "false") || getenv("ZLOG_STRICT_INIT");
              return 0;
            }
            if ( !strcmp(v14, "buffer") && !strcmp(v13, "min") )
            {
              *(_DWORD *)(a1 + 1052) = sub_93CA8(v11);
              return 0;
            }
            if ( !strcmp(v14, "buffer") && !strcmp(v13, "max") )
            {
              *(_DWORD *)(a1 + 1056) = sub_93CA8(v11);
              return 0;
            }
            if ( !strcmp(v14, "file") && !strcmp(v13, "perms") )
            {
              _isoc99_sscanf(v11, "%o", a1 + 9268);
              return 0;
            }
            if ( !strcmp(v14, "rotate") && !strcmp(v13, "lock") && !strcmp(v12, "file") )
            {
              if ( !strcmp(v11, "self") )
                strcpy((char *)(a1 + 1060), (const char *)a1);
              else
                strcpy((char *)(a1 + 1060), v11);
              return 0;
            }
            if ( !strcmp(v14, "default") && !strcmp(v13, "format") )
            {
              strcpy((char *)(a1 + 5164), &a2[v16]);
              return 0;
            }
            if ( !strcmp(v14, "reload") && !strcmp(v13, "conf") && !strcmp(v12, "period") )
            {
              *(_DWORD *)(a1 + 9276) = sub_93CA8(v11);
              return 0;
            }
            if ( !strcmp(v14, "fsync") && !strcmp(v13, "period") )
            {
              *(_DWORD *)(a1 + 9272) = sub_93CA8(v11);
              return 0;
            }
            sub_93A0C(2, "src/conf.c", 454, "name[%s] is not any one of global options", v15);
            if ( !*(_DWORD *)(a1 + 1048) )
              return 0;
            return -1;
          }
          else
          {
            sub_93A0C(2, "src/conf.c", 412, "sscanf [%s] fail, name or value is null", a2);
            return -1;
          }
        case 2:
          if ( !sub_89E7C(*(_DWORD *)(a1 + 9280), a2) )
            return 0;
          sub_93A0C(2, "src/conf.c", 460, "zlog_level_list_set fail");
          if ( !*(_DWORD *)(a1 + 1048) )
            return 0;
          return -1;
        case 3:
          v20 = (int *)sub_89640(a2, (_DWORD *)(a1 + 9292));
          if ( v20 )
          {
            if ( !sub_92968(*(_DWORD *)(a1 + 9284), (int)v20) )
              return 0;
            sub_895A4(v20);
            sub_93A0C(2, "src/conf.c", 473, "zc_arraylist_add fail");
            return -1;
          }
          else
          {
            sub_93A0C(2, "src/conf.c", 467, "zlog_format_new fail [%s]", a2);
            if ( !*(_DWORD *)(a1 + 1048) )
              return 0;
            return -1;
          }
        case 4:
          v19 = sub_8E3F0(
                  a2,
                  *(_DWORD **)(a1 + 9280),
                  *(_DWORD *)(a1 + 9264),
                  *(_DWORD *)(a1 + 9284),
                  *(_DWORD *)(a1 + 9268),
                  *(_DWORD *)(a1 + 9272),
                  (_DWORD *)(a1 + 9292));
          if ( v19 )
          {
            if ( sub_92968(*(_DWORD *)(a1 + 9288), (int)v19) )
            {
              sub_8F938((int)v19);
              sub_93A0C(2, "src/conf.c", 493, "zc_arraylist_add fail");
              return -1;
            }
          }
          else
          {
            sub_93A0C(2, "src/conf.c", 487, "zlog_rule_new fail [%s]", a2);
            if ( *(_DWORD *)(a1 + 1048) )
              return -1;
          }
          return 0;
        default:
          sub_93A0C(2, "src/conf.c", 498, "not in any section");
          return -1;
      }
    }
    v17 = *a3;
    v18 = _isoc99_sscanf(a2, "[ %[^] \t]", v15);
    if ( !strcmp(v15, "global") )
    {
      *a3 = 1;
    }
    else if ( !strcmp(v15, "levels") )
    {
      *a3 = 2;
    }
    else if ( !strcmp(v15, "formats") )
    {
      *a3 = 3;
    }
    else
    {
      if ( strcmp(v15, "rules") )
      {
        sub_93A0C(2, "src/conf.c", 363, "wrong section name[%s]", v15);
        return -1;
      }
      *a3 = 4;
    }
    if ( v17 < *a3 )
    {
      if ( *a3 == 4 )
      {
        if ( *(_DWORD *)(a1 + 9276) && *(_DWORD *)(a1 + 9272) >= *(_DWORD *)(a1 + 9276) )
        {
          sub_93A0C(
            1,
            "src/conf.c",
            382,
            "fsync_period[%ld] >= reload_conf_period[%ld],set fsync_period to zero",
            v6,
            v7);
          *(_DWORD *)(a1 + 9272) = 0;
        }
        *(_DWORD *)(a1 + 5160) = sub_8AD38((const char *)(a1 + 1060));
        if ( !*(_DWORD *)(a1 + 5160) )
        {
          sub_93A0C(2, "src/conf.c", 391, "zlog_rotater_new fail");
          return -1;
        }
        *(_DWORD *)(a1 + 9264) = sub_89640((const char *)(a1 + 5164), (_DWORD *)(a1 + 9292));
        if ( !*(_DWORD *)(a1 + 9264) )
        {
          sub_93A0C(2, "src/conf.c", 398, "zlog_format_new fail");
          return -1;
        }
      }
      return 0;
    }
    sub_93A0C(2, "src/conf.c", 368, "wrong sequence of section, must follow global->levels->formats->rules");
    return -1;
  }
  else
  {
    v3 = strlen(a2);
    sub_93A0C(2, "src/conf.c", 346, "line_len[%ld] > MAXLEN_CFG_LINE[%ld], may cause overflow", v3, 4096);
    return -1;
  }
}
// 885E4: control flows out of bounds to 885E8
// 884A0: variable 'v6' is possibly undefined
// 884A0: variable 'v7' is possibly undefined
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (00088F94) --------------------------------------------------------
int __fastcall sub_88F94(const char **a1, int a2)
{
  if ( a1 )
    return sub_93A0C(
             a2,
             "src/event.c",
             40,
             "---event[%p][%s,%s][%s(%ld),%s(%ld),%ld,%d][%p,%s][%ld,%ld][%ld,%ld][%d]---",
             a1,
             *a1,
             (const char *)a1 + 8,
             a1[68],
             a1[69],
             a1[70],
             a1[71],
             a1[72],
             a1[73],
             a1[74],
             a1[76],
             a1[79],
             a1[80],
             a1[95],
             a1[106],
             a1[94]);
  else
    return sub_93A0C(2, "src/event.c", 30, "a_event is null or 0");
}

//----- (000890C8) --------------------------------------------------------
void __fastcall sub_890C8(void **a1)
{
  if ( a1 )
  {
    if ( a1[93] )
      free(a1[93]);
    sub_93A0C(0, "src/event.c", 50, "zlog_event_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_93A0C(2, "src/event.c", 48, "a_event is null or 0");
  }
}

//----- (0008915C) --------------------------------------------------------
void *__fastcall sub_8915C(size_t a1)
{
  int *v1; // r0
  int *v3; // r0
  int *v4; // r0
  void *ptr; // [sp+14h] [bp-8h]

  ptr = calloc(1u, 0x21Cu);
  if ( ptr )
  {
    *((_DWORD *)ptr + 93) = calloc(a1, 0x100Cu);
    if ( *((_DWORD *)ptr + 93) )
    {
      *((_DWORD *)ptr + 94) = a1;
      if ( gethostname((char *)ptr + 8, 0x100u) )
      {
        v4 = _errno_location();
        sub_93A0C(2, "src/event.c", 78, "gethostname fail, errno[%d]", *v4);
        sub_890C8((void **)ptr);
        return 0;
      }
      else
      {
        *((_DWORD *)ptr + 67) = strlen((const char *)ptr + 8);
        *((_DWORD *)ptr + 106) = pthread_self();
        *((_DWORD *)ptr + 115) = sprintf((char *)ptr + 428, "%lu", *((_DWORD *)ptr + 106));
        *((_DWORD *)ptr + 124) = sprintf((char *)ptr + 464, "%x", *((_DWORD *)ptr + 106));
        *((_DWORD *)ptr + 125) = syscall(224);
        *((_DWORD *)ptr + 134) = sprintf((char *)ptr + 504, "%u", *((_DWORD *)ptr + 125));
        return ptr;
      }
    }
    else
    {
      v3 = _errno_location();
      sub_93A0C(2, "src/event.c", 67, "calloc fail, errno[%d]", *v3);
      free(ptr);
      return 0;
    }
  }
  else
  {
    v1 = _errno_location();
    sub_93A0C(2, "src/event.c", 61, "calloc fail, errno[%d]", *v1);
    return 0;
  }
}

//----- (00089378) --------------------------------------------------------
_DWORD *__fastcall sub_89378(
        _DWORD *result,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  *result = a2;
  result[1] = a3;
  result[68] = a4;
  result[69] = a5;
  result[70] = a6;
  result[71] = a7;
  result[72] = a8;
  result[73] = a9;
  result[78] = 0;
  result[76] = a10;
  result[77] = a11;
  result[95] = 0;
  result[79] = 0;
  return result;
}

//----- (00089444) --------------------------------------------------------
_DWORD *__fastcall sub_89444(
        _DWORD *result,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  *result = a2;
  result[1] = a3;
  result[68] = a4;
  result[69] = a5;
  result[70] = a6;
  result[71] = a7;
  result[72] = a8;
  result[73] = a9;
  result[78] = 1;
  result[74] = a10;
  result[75] = a11;
  result[95] = 0;
  result[79] = 0;
  return result;
}

//----- (0008950C) --------------------------------------------------------
int __fastcall sub_8950C(int a1, int a2)
{
  if ( a1 )
    return sub_93A0C(
             a2,
             "src/format.c",
             29,
             "---format[%p][%s = %s(%p)]---",
             (const void *)a1,
             (const char *)a1,
             (const char *)(a1 + 4097),
             *(const void **)(a1 + 8196));
  else
    return sub_93A0C(2, "src/format.c", 24, "a_format is null or 0");
}

//----- (000895A4) --------------------------------------------------------
void __fastcall sub_895A4(int *a1)
{
  if ( a1 )
  {
    if ( a1[2049] )
      sub_92670(a1[2049]);
    sub_93A0C(0, "src/format.c", 49, "zlog_format_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_93A0C(2, "src/format.c", 45, "a_format is null or 0");
  }
}

//----- (00089640) --------------------------------------------------------
void *__fastcall sub_89640(const char *a1, _DWORD *a2)
{
  int *v3; // r0
  _DWORD *v4; // r0
  char *v8; // [sp+10h] [bp-24h] BYREF
  int v9; // [sp+14h] [bp-20h] BYREF
  const char **v10; // [sp+18h] [bp-1Ch]
  char *v11; // [sp+1Ch] [bp-18h]
  char *v12; // [sp+20h] [bp-14h]
  void *s; // [sp+24h] [bp-10h]
  int v14; // [sp+28h] [bp-Ch]
  char *i; // [sp+2Ch] [bp-8h]

  v14 = 0;
  s = 0;
  v9 = 0;
  if ( !a1 )
  {
    sub_93A0C(2, "src/format.c", 65, "line is null or 0");
    return 0;
  }
  s = calloc(1u, 0x2008u);
  if ( !s )
  {
    v3 = _errno_location();
    sub_93A0C(2, "src/format.c", 69, "calloc fail, errno[%d]", *v3);
    return 0;
  }
  memset(s, 0, 0x1001u);
  v9 = 0;
  v14 = _isoc99_sscanf(a1, " %[^= \t] = %n", s, &v9);
  if ( v14 != 1 )
  {
    sub_93A0C(2, "src/format.c", 81, "format[%s], syntax wrong", a1);
LABEL_31:
    sub_895A4((int *)s);
    return 0;
  }
  if ( a1[v9] != 34 )
  {
    sub_93A0C(2, "src/format.c", 86, "the 1st char of pattern is not \", line+nread[%s]", &a1[v9]);
    goto LABEL_31;
  }
  for ( i = (char *)s; *i; ++i )
  {
    if ( ((*_ctype_b_loc())[(unsigned __int8)*i] & 8) == 0 && *i != 95 )
    {
      sub_93A0C(2, "src/format.c", 92, "a_format->name[%s] character is not in [a-Z][0-9][_]", (const char *)s);
      goto LABEL_31;
    }
  }
  v12 = (char *)&a1[v9 + 1];
  v11 = strrchr(v12, 34);
  if ( !v11 )
  {
    sub_93A0C(2, "src/format.c", 100, "there is no \" at end of pattern, line[%s]", a1);
    goto LABEL_31;
  }
  if ( (unsigned int)(v11 - v12) > 0x1000 )
  {
    sub_93A0C(2, "src/format.c", 105, "pattern is too long");
    goto LABEL_31;
  }
  memset((char *)s + 4097, 0, 0x1001u);
  memcpy((char *)s + 4097, v12, v11 - v12);
  if ( sub_93F88((char *)s + 4097, 4097) )
  {
    sub_93A0C(2, "src/format.c", 112, "zc_str_replace_env fail");
    goto LABEL_31;
  }
  v4 = sub_92568((int)sub_912C4);
  *((_DWORD *)s + 2049) = v4;
  if ( !*((_DWORD *)s + 2049) )
  {
    sub_93A0C(2, "src/format.c", 119, "zc_arraylist_new fail");
    goto LABEL_31;
  }
  for ( i = (char *)s + 4097; *i; i = v8 )
  {
    v10 = sub_91334(i, &v8, a2);
    if ( !v10 )
    {
      sub_93A0C(2, "src/format.c", 126, "zlog_spec_new fail");
      goto LABEL_31;
    }
    if ( sub_92968(*((_DWORD *)s + 2049), (int)v10) )
    {
      sub_912C4(v10);
      sub_93A0C(2, "src/format.c", 132, "zc_arraylist_add fail");
      goto LABEL_31;
    }
  }
  sub_8950C((int)s, 0);
  return s;
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (00089A80) --------------------------------------------------------
int __fastcall sub_89A80(int a1, int a2)
{
  int i; // [sp+Ch] [bp-8h]

  *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) = **(_DWORD **)(a2 + 28);
  for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(a1 + 8196) + 4); ++i )
  {
    if ( (*(int (__fastcall **)(_DWORD, int))(*(_DWORD *)(**(_DWORD **)(a1 + 8196) + 4 * i) + 9256))(
           *(_DWORD *)(**(_DWORD **)(a1 + 8196) + 4 * i),
           a2) )
    {
      return -1;
    }
  }
  return 0;
}

//----- (00089B60) --------------------------------------------------------
int __fastcall sub_89B60(_DWORD *a1, int a2)
{
  int result; // r0
  const char *v5; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/level_list.c", 25, "levels is null or 0");
  result = sub_93A0C(a2, "src/level_list.c", 26, "--level_list[%p]--", a1);
  for ( i = 0; i < a1[1]; ++i )
  {
    v5 = *(const char **)(*a1 + 4 * i);
    if ( v5 )
      result = sub_95B84(v5, a2);
  }
  return result;
}

//----- (00089C44) --------------------------------------------------------
int __fastcall sub_89C44(const void *a1)
{
  if ( !a1 )
    return sub_93A0C(2, "src/level_list.c", 37, "levels is null or 0");
  sub_92670((int)a1);
  return sub_93A0C(0, "src/level_list.c", 39, "zc_level_list_del[%p]", a1);
}

//----- (00089CB8) --------------------------------------------------------
bool __fastcall sub_89CB8(int a1)
{
  return sub_89E7C(a1, "* = 0, LOG_INFO")
      || sub_89E7C(a1, "DEBUG = 20, LOG_DEBUG")
      || sub_89E7C(a1, "INFO = 40, LOG_INFO")
      || sub_89E7C(a1, "NOTICE = 60, LOG_NOTICE")
      || sub_89E7C(a1, "WARN = 80, LOG_WARNING")
      || sub_89E7C(a1, "ERROR = 100, LOG_ERR")
      || sub_89E7C(a1, "FATAL = 120, LOG_ALERT")
      || sub_89E7C(a1, "UNKNOWN = 254, LOG_ERR")
      || sub_89E7C(a1, "! = 255, LOG_INFO");
}

//----- (00089DDC) --------------------------------------------------------
_DWORD *sub_89DDC()
{
  _DWORD *v2; // [sp+4h] [bp-8h]

  v2 = sub_92568((int)sub_95C38);
  if ( v2 )
  {
    if ( sub_89CB8((int)v2) )
    {
      sub_93A0C(2, "src/level_list.c", 67, "zlog_level_set_default fail");
      sub_92670((int)v2);
      return 0;
    }
    else
    {
      return v2;
    }
  }
  else
  {
    sub_93A0C(2, "src/level_list.c", 62, "zc_arraylist_new fail");
    return 0;
  }
}

//----- (00089E7C) --------------------------------------------------------
int __fastcall sub_89E7C(int a1, const char *a2)
{
  _DWORD *v6; // [sp+14h] [bp-8h]

  v6 = sub_95E40(a2);
  if ( v6 )
  {
    if ( sub_92854(a1, *v6, (int)v6) )
    {
      sub_93A0C(2, "src/level_list.c", 90, "zc_arraylist_set fail");
      sub_93A0C(2, "src/level_list.c", 96, "line[%s]", a2);
      sub_95C38(v6);
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_93A0C(2, "src/level_list.c", 85, "zlog_level_new fail");
    return -1;
  }
}

//----- (00089F54) --------------------------------------------------------
int __fastcall sub_89F54(_DWORD *a1, int a2)
{
  int v2; // r3

  if ( a2 >= a1[1] )
    v2 = 0;
  else
    v2 = *(_DWORD *)(*a1 + 4 * a2);
  if ( !v2 )
  {
    sub_93A0C(
      2,
      "src/level_list.c",
      119,
      "l[%d] not in (0,254), or has no level defined,see configure file define, set to UNKOWN",
      a2);
    if ( (int)a1[1] <= 254 )
      return 0;
    else
      return *(_DWORD *)(*a1 + 1016);
  }
  return v2;
}

//----- (0008A008) --------------------------------------------------------
int __fastcall sub_8A008(_DWORD *a1, const char *a2)
{
  int v6; // [sp+10h] [bp-Ch]
  int i; // [sp+14h] [bp-8h]

  if ( a2 && *a2 )
  {
    for ( i = 0; i < a1[1]; ++i )
    {
      v6 = *(_DWORD *)(*a1 + 4 * i);
      if ( v6 && !strcasecmp(a2, (const char *)(v6 + 4)) )
        return i;
    }
    sub_93A0C(2, "src/level_list.c", 142, "str[%s] can't found in level list", a2);
    return -1;
  }
  else
  {
    sub_93A0C(2, "src/level_list.c", 132, "str is [%s], can't find level", a2);
    return -1;
  }
}

//----- (0008A128) --------------------------------------------------------
int __fastcall sub_8A128(int *a1, int a2)
{
  int result; // r0
  int i; // [sp+1Ch] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/mdc.c", 21, "a_mdc is null or 0");
  sub_93A0C(a2, "src/mdc.c", 22, "---mdc[%p]---", a1);
  result = sub_93798(*a1);
  for ( i = result; i; i = result )
  {
    sub_93A0C(
      a2,
      "src/mdc.c",
      28,
      "----mdc_kv[%p][%s]-[%s]----",
      *(const void **)(i + 8),
      *(const char **)(i + 8),
      (const char *)(*(_DWORD *)(i + 8) + 1025));
    result = sub_93834(*a1, (unsigned int *)i);
  }
  return result;
}

//----- (0008A21C) --------------------------------------------------------
void __fastcall sub_8A21C(int *a1)
{
  if ( a1 )
  {
    if ( *a1 )
      sub_92CD8(*a1);
    sub_93A0C(0, "src/mdc.c", 37, "zlog_mdc_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_93A0C(2, "src/mdc.c", 35, "a_mdc is null or 0");
  }
}

//----- (0008A2B0) --------------------------------------------------------
void __fastcall sub_8A2B0(void *a1)
{
  sub_93A0C(0, "src/mdc.c", 44, "zlog_mdc_kv_del[%p]", a1);
  free(a1);
}

//----- (0008A2F8) --------------------------------------------------------
char *__fastcall sub_8A2F8(const char *a1, const char *a2)
{
  int *v2; // r0
  char *s; // [sp+14h] [bp-8h]

  s = (char *)calloc(1u, 0x808u);
  if ( s )
  {
    snprintf(s, 0x401u, "%s", a1);
    *((_DWORD *)s + 513) = snprintf(s + 1025, 0x401u, "%s", a2);
    return s;
  }
  else
  {
    v2 = _errno_location();
    sub_93A0C(2, "src/mdc.c", 54, "calloc fail, errno[%d]", *v2);
    return 0;
  }
}

//----- (0008A3B8) --------------------------------------------------------
int *sub_8A3B8()
{
  int *v0; // r0
  int *v3; // [sp+Ch] [bp-8h]

  v3 = (int *)calloc(1u, 4u);
  if ( v3 )
  {
    *v3 = (int)sub_92BA8(0x14u, 604420, 604532, 0, 565936);
    if ( *v3 )
    {
      return v3;
    }
    else
    {
      sub_93A0C(2, "src/mdc.c", 78, "zc_hashtable_new fail");
      sub_8A21C(v3);
      return 0;
    }
  }
  else
  {
    v0 = _errno_location();
    sub_93A0C(2, "src/mdc.c", 69, "calloc fail, errno[%d]", *v0);
    return 0;
  }
}

//----- (0008A49C) --------------------------------------------------------
int __fastcall sub_8A49C(int *a1, const char *a2, const char *a3)
{
  char *v6; // [sp+14h] [bp-8h]

  v6 = sub_8A2F8(a2, a3);
  if ( v6 )
  {
    if ( sub_93250(*a1, (unsigned int)v6, (unsigned int)v6) )
    {
      sub_93A0C(2, "src/mdc.c", 101, "zc_hashtable_put fail");
      sub_8A2B0(v6);
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_93A0C(2, "src/mdc.c", 96, "zlog_mdc_kv_new failed");
    return -1;
  }
}

//----- (0008A554) --------------------------------------------------------
void __fastcall sub_8A554(int *a1)
{
  sub_92E14(*a1);
}

//----- (0008A580) --------------------------------------------------------
int __fastcall sub_8A580(int *a1, int a2)
{
  int v6; // [sp+Ch] [bp-8h]

  v6 = sub_93190(*a1, a2);
  if ( v6 )
    return v6 + 1025;
  sub_93A0C(2, "src/mdc.c", 121, "zc_hashtable_get fail", a2, a1);
  return 0;
}

//----- (0008A5F4) --------------------------------------------------------
int __fastcall sub_8A5F4(int *a1, int a2)
{
  int v6; // [sp+Ch] [bp-8h]

  v6 = sub_93190(*a1, a2);
  if ( v6 )
    return v6;
  sub_93A0C(2, "src/mdc.c", 134, "zc_hashtable_get fail", a2, a1);
  return 0;
}

//----- (0008A660) --------------------------------------------------------
void __fastcall sub_8A660(const void **a1, const void *a2)
{
  sub_93568(*a1, a2);
}

//----- (0008A694) --------------------------------------------------------
int __fastcall sub_8A694(const void **a1, int a2)
{
  if ( a1 )
    return sub_93A0C(a2, "src/record.c", 15, "--record:[%p][%s:%p]--", a1, (const char *)a1, a1[257]);
  else
    return sub_93A0C(2, "src/record.c", 14, "a_record is null or 0");
}

//----- (0008A718) --------------------------------------------------------
void __fastcall sub_8A718(void *a1)
{
  if ( a1 )
  {
    sub_93A0C(0, "src/record.c", 22, "zlog_record_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_93A0C(2, "src/record.c", 21, "a_record is null or 0");
  }
}

//----- (0008A78C) --------------------------------------------------------
char *__fastcall sub_8A78C(const char *a1, int a2)
{
  int *v3; // r0
  char *dest; // [sp+14h] [bp-8h]

  if ( a1 )
  {
    if ( a2 )
    {
      dest = (char *)calloc(1u, 0x408u);
      if ( dest )
      {
        if ( strlen(a1) <= 0x400 )
        {
          strcpy(dest, a1);
          *((_DWORD *)dest + 257) = a2;
          sub_8A694((const void **)dest, 0);
          return dest;
        }
        else
        {
          sub_93A0C(2, "src/record.c", 41, "name[%s] is too long", a1);
          sub_8A718(dest);
          return 0;
        }
      }
      else
      {
        v3 = _errno_location();
        sub_93A0C(2, "src/record.c", 36, "calloc fail, errno[%d]", *v3);
        return 0;
      }
    }
    else
    {
      sub_93A0C(2, "src/record.c", 32, "output is null or 0");
      return 0;
    }
  }
  else
  {
    sub_93A0C(2, "src/record.c", 31, "name is null or 0");
    return 0;
  }
}

//----- (0008A8D8) --------------------------------------------------------
int __fastcall sub_8A8D8(const void *a1, int a2)
{
  int result; // r0
  int i; // [sp+14h] [bp-8h]

  if ( !a1 )
    return sub_93A0C(2, "src/record_table.c", 21, "records is null or 0");
  sub_93A0C(a2, "src/record_table.c", 22, "-record_table[%p]-", a1);
  result = sub_93798((int)a1);
  for ( i = result; i; i = result )
  {
    sub_8A694(*(const void ***)(i + 8), a2);
    result = sub_93834((int)a1, (unsigned int *)i);
  }
  return result;
}

//----- (0008A98C) --------------------------------------------------------
int __fastcall sub_8A98C(const void *a1)
{
  if ( !a1 )
    return sub_93A0C(2, "src/record_table.c", 34, "records is null or 0");
  sub_92CD8((int)a1);
  return sub_93A0C(0, "src/record_table.c", 36, "zlog_record_table_del[%p]", a1);
}

//----- (0008AA00) --------------------------------------------------------
_DWORD *sub_8AA00()
{
  _DWORD *v2; // [sp+Ch] [bp-8h]

  v2 = sub_92BA8(0x14u, 604420, 604532, 0, 567064);
  if ( v2 )
  {
    sub_8A8D8(v2, 0);
    return v2;
  }
  else
  {
    sub_93A0C(2, "src/record_table.c", 49, "zc_hashtable_new fail");
    return 0;
  }
}

//----- (0008AA84) --------------------------------------------------------
int __fastcall sub_8AA84(int a1, int a2)
{
  int result; // r0
  int v5; // [sp+38h] [bp-24h]
  int i; // [sp+3Ch] [bp-20h]

  if ( !a1 )
    return sub_93A0C(2, "src/rotater.c", 34, "a_rotater is null or 0");
  result = sub_93A0C(
             a2,
             "src/rotater.c",
             50,
             "--rotater[%p][%p,%s,%d][%s,%s,%s,%ld,%ld,%d,%d,%d]--",
             (const void *)a1,
             (const void *)a1,
             *(const char **)(a1 + 24),
             *(_DWORD *)(a1 + 28),
             *(const char **)(a1 + 32),
             *(const char **)(a1 + 36),
             (const char *)(a1 + 40),
             *(_DWORD *)(a1 + 1068),
             *(_DWORD *)(a1 + 1072),
             *(_DWORD *)(a1 + 1076),
             *(_DWORD *)(a1 + 1080),
             *(_DWORD *)(a1 + 1084));
  if ( *(_DWORD *)(a1 + 1088) )
  {
    for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4); ++i )
    {
      v5 = *(_DWORD *)(**(_DWORD **)(a1 + 1088) + 4 * i);
      result = sub_93A0C(a2, "src/rotater.c", 55, "[%s,%d]->", (const char *)(v5 + 4), *(_DWORD *)v5);
    }
  }
  return result;
}

//----- (0008AC28) --------------------------------------------------------
void __fastcall sub_8AC28(pthread_mutex_t *a1)
{
  int *v1; // r0
  int *v2; // r0

  if ( a1 )
  {
    if ( a1[1].__count && close(a1[1].__count) )
    {
      v1 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 68, "close fail, errno[%d]", *v1);
    }
    if ( pthread_mutex_destroy(a1) )
    {
      v2 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 73, "pthread_mutex_destroy fail, errno[%d]", *v2);
    }
    sub_93A0C(0, "src/rotater.c", 76, "zlog_rotater_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_93A0C(2, "src/rotater.c", 64, "a_rotater is null or 0");
  }
}

//----- (0008AD38) --------------------------------------------------------
pthread_mutex_t *__fastcall sub_8AD38(const char *a1)
{
  int *v2; // r0
  int *v3; // r0
  int *v4; // r0
  pthread_mutex_t *mutex; // [sp+10h] [bp-Ch]
  int v8; // [sp+14h] [bp-8h]

  if ( a1 )
  {
    mutex = (pthread_mutex_t *)calloc(1u, 0x444u);
    if ( mutex )
    {
      if ( pthread_mutex_init(mutex, 0) )
      {
        v3 = _errno_location();
        sub_93A0C(2, "src/rotater.c", 95, "pthread_mutex_init fail, errno[%d]", *v3);
        free(mutex);
        return 0;
      }
      else
      {
        v8 = open(a1, 66, 438);
        if ( v8 >= 0 )
        {
          mutex[1].__count = v8;
          mutex[1].__lock = (int)a1;
          return mutex;
        }
        else
        {
          v4 = _errno_location();
          sub_93A0C(2, "src/rotater.c", 108, "open file[%s] fail, errno[%d]", a1, *v4);
          sub_8AC28(mutex);
          return 0;
        }
      }
    }
    else
    {
      v2 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 90, "calloc fail, errno[%d]", *v2);
      return 0;
    }
  }
  else
  {
    sub_93A0C(2, "src/rotater.c", 86, "lock_file is null or 0");
    return 0;
  }
}

//----- (0008AEBC) --------------------------------------------------------
void __fastcall sub_8AEBC(char *a1)
{
  sub_93A0C(0, "src/rotater.c", 126, "del onefile[%p]", a1);
  sub_93A0C(0, "src/rotater.c", 127, "a_file->path[%s]", a1 + 4);
  free(a1);
}

//----- (0008AF2C) --------------------------------------------------------
void *__fastcall sub_8AF2C(int a1, const char *a2)
{
  int *v3; // r0
  int *v4; // r0
  int v8; // [sp+14h] [bp-10h] BYREF
  unsigned int v9; // [sp+18h] [bp-Ch]
  void *ptr; // [sp+1Ch] [bp-8h]

  if ( !strcmp(*(const char **)(a1 + 32), a2) )
    return 0;
  if ( a2[strlen(a2) - 1] == 47 )
    return 0;
  ptr = calloc(1u, 0x408u);
  if ( ptr )
  {
    v9 = snprintf((char *)ptr + 4, 0x401u, "%s", a2);
    if ( v9 <= 0x400 )
    {
      v8 = 0;
      _isoc99_sscanf((char *)ptr + *(_DWORD *)(a1 + 1068) + 4, "%d%n", ptr, &v8);
      if ( !*(_DWORD *)(a1 + 1076) || *(_DWORD *)(a1 + 1076) <= v8 )
        return ptr;
      sub_93A0C(1, "src/rotater.c", 164, "aa.1.log is not expect, need aa.01.log");
    }
    else
    {
      v4 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 155, "snprintf fail or overflow, nwrite=[%d], errno[%d]", v9, *v4);
    }
    free(ptr);
    return 0;
  }
  v3 = _errno_location();
  sub_93A0C(2, "src/rotater.c", 149, "calloc fail, errno[%d]", *v3);
  return 0;
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0008B0EC) --------------------------------------------------------
bool __fastcall sub_8B0EC(_DWORD *a1, _DWORD *a2)
{
  return *a1 > *a2;
}

//----- (0008B130) --------------------------------------------------------
int __fastcall sub_8B130(int a1)
{
  int *v2; // r0
  glob_t pglob; // [sp+14h] [bp-38h] BYREF
  void *v7; // [sp+38h] [bp-14h]
  int v8; // [sp+3Ch] [bp-10h]
  char **gl_pathv; // [sp+40h] [bp-Ch]
  size_t gl_pathc; // [sp+44h] [bp-8h]

  v8 = 0;
  *(_DWORD *)(a1 + 1088) = sub_92568((int)sub_8AEBC);
  if ( *(_DWORD *)(a1 + 1088) )
  {
    v8 = glob((const char *)(a1 + 40), 7, 0, &pglob);
    if ( v8 != 3 )
    {
      if ( v8 )
      {
        v2 = _errno_location();
        sub_93A0C(2, "src/rotater.c", 200, "glob err, rc=[%d], errno[%d]", v8, *v2);
        return -1;
      }
      gl_pathv = pglob.gl_pathv;
      gl_pathc = pglob.gl_pathc;
      while ( gl_pathc-- )
      {
        v7 = sub_8AF2C(a1, *gl_pathv);
        if ( v7 )
        {
          v8 = sub_92AE0(*(_DWORD **)(a1 + 1088), (int (__fastcall *)(_DWORD, int))sub_8B0EC, (int)v7);
          if ( v8 )
          {
            sub_93A0C(2, "src/rotater.c", 219, "zc_arraylist_sortadd fail");
            globfree(&pglob);
            return -1;
          }
        }
        else
        {
          sub_93A0C(1, "src/rotater.c", 211, "not the expect pattern file");
        }
        ++gl_pathv;
      }
    }
    globfree(&pglob);
    return 0;
  }
  sub_93A0C(2, "src/rotater.c", 191, "zc_arraylist_new fail");
  return -1;
}

//----- (0008B300) --------------------------------------------------------
int __fastcall sub_8B300(int a1)
{
  int *v1; // r0
  int v3; // r3
  int v4; // r3
  int *v5; // r0
  const char *v6; // r4
  int *v7; // r0
  char v10[1028]; // [sp+18h] [bp-424h] BYREF
  int v11; // [sp+41Ch] [bp-20h]
  unsigned int v12; // [sp+420h] [bp-1Ch]
  int v13; // [sp+424h] [bp-18h]
  int v14; // [sp+428h] [bp-14h]
  int v15; // [sp+42Ch] [bp-10h]

  v13 = 0;
  v12 = 0;
  v15 = 0;
  v11 = ***(_DWORD ***)(a1 + 1088);
  while ( v15 < *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) )
  {
    v11 = *(_DWORD *)(**(_DWORD **)(a1 + 1088) + 4 * v15);
    if ( *(int *)(a1 + 1084) > 0 && v15 < *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) - *(_DWORD *)(a1 + 1084) )
    {
      v13 = unlink((const char *)(v11 + 4));
      if ( v13 )
      {
        v1 = _errno_location();
        sub_93A0C(2, "src/rotater.c", 246, "unlink[%s] fail, errno[%d]", (const char *)(v11 + 4), *v1);
        return -1;
      }
    }
    ++v15;
  }
  if ( *(int *)(*(_DWORD *)(a1 + 1088) + 4) <= 0 )
  {
    v14 = 0;
  }
  else
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) - 1 >= *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) )
      v3 = 0;
    else
      v3 = *(_DWORD *)(**(_DWORD **)(a1 + 1088) + 4 * (*(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) + 0x3FFFFFFF));
    v11 = v3;
    if ( !v3 )
    {
      sub_93A0C(2, "src/rotater.c", 256, "zc_arraylist_get fail");
      return -1;
    }
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) - 1;
    if ( *(_DWORD *)v11 >= v4 )
      v4 = *(_DWORD *)v11;
    v14 = v4 + 1;
  }
  memset(v10, 0, 0x401u);
  v12 = snprintf(
          v10,
          0x401u,
          "%.*s%0*d%s",
          *(_DWORD *)(a1 + 1068),
          (const char *)(a1 + 40),
          *(_DWORD *)(a1 + 1076),
          v14,
          (const char *)(a1 + 40 + *(_DWORD *)(a1 + 1072)));
  if ( v12 <= 0x400 )
  {
    if ( rename(*(const char **)(a1 + 32), v10) )
    {
      v6 = *(const char **)(a1 + 32);
      v7 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 277, "rename[%s]->[%s] fail, errno[%d]", v6, v10, *v7);
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v5 = _errno_location();
    sub_93A0C(2, "src/rotater.c", 272, "nwirte[%d], overflow or errno[%d]", v12, *v5);
    return -1;
  }
}

//----- (0008B65C) --------------------------------------------------------
int __fastcall sub_8B65C(int a1)
{
  int v1; // r3
  const char *v3; // r4
  int *v4; // r0
  int *v5; // r0
  const char *v6; // r4
  int *v7; // r0
  int *v8; // r0
  const char *v9; // r4
  int *v10; // r0
  char v13[1028]; // [sp+1Ch] [bp-420h] BYREF
  int v14; // [sp+420h] [bp-1Ch]
  unsigned int v15; // [sp+424h] [bp-18h]
  int v16; // [sp+428h] [bp-14h]
  int i; // [sp+42Ch] [bp-10h]

  v16 = 0;
  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) - 1; i >= 0; --i )
  {
    if ( i >= *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) )
      v1 = 0;
    else
      v1 = *(_DWORD *)(**(_DWORD **)(a1 + 1088) + 4 * i);
    v14 = v1;
    if ( !v1 )
    {
      sub_93A0C(2, "src/rotater.c", 297, "zc_arraylist_get fail");
      return -1;
    }
    if ( *(int *)(a1 + 1084) <= 0 || i < *(_DWORD *)(a1 + 1084) - 1 )
    {
      memset(v13, 0, 0x401u);
      v15 = snprintf(
              v13,
              0x401u,
              "%.*s%0*d%s",
              *(_DWORD *)(a1 + 1068),
              (const char *)(a1 + 40),
              *(_DWORD *)(a1 + 1076),
              i + 1,
              (const char *)(a1 + 40 + *(_DWORD *)(a1 + 1072)));
      if ( v15 > 0x400 )
      {
        v5 = _errno_location();
        sub_93A0C(2, "src/rotater.c", 318, "nwirte[%d], overflow or errno[%d]", v15, *v5);
        return -1;
      }
      if ( rename((const char *)(v14 + 4), v13) )
      {
        v6 = (const char *)(v14 + 4);
        v7 = _errno_location();
        sub_93A0C(2, "src/rotater.c", 323, "rename[%s]->[%s] fail, errno[%d]", v6, v13, *v7);
        return -1;
      }
    }
    else
    {
      v16 = unlink((const char *)(v14 + 4));
      if ( v16 )
      {
        v3 = (const char *)(v14 + 4);
        v4 = _errno_location();
        sub_93A0C(2, "src/rotater.c", 305, "unlink[%s] fail, errno[%d]", v3, *v4);
        return -1;
      }
    }
  }
  memset(v13, 0, 0x401u);
  v15 = snprintf(
          v13,
          0x401u,
          "%.*s%0*d%s",
          *(_DWORD *)(a1 + 1068),
          (const char *)(a1 + 40),
          *(_DWORD *)(a1 + 1076),
          0,
          (const char *)(a1 + 40 + *(_DWORD *)(a1 + 1072)));
  if ( v15 <= 0x400 )
  {
    if ( rename(*(const char **)(a1 + 32), v13) )
    {
      v9 = *(const char **)(a1 + 32);
      v10 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 340, "rename[%s]->[%s] fail, errno[%d]", v9, v13, *v10);
      return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v8 = _errno_location();
    sub_93A0C(2, "src/rotater.c", 335, "nwirte[%d], overflow or errno[%d]", v15, *v8);
    return -1;
  }
}

//----- (0008BA60) --------------------------------------------------------
int __fastcall sub_8BA60(int a1)
{
  int *v1; // r0
  int *v3; // r0
  int v6; // [sp+10h] [bp-14h] BYREF
  int v7; // [sp+14h] [bp-10h]
  size_t n; // [sp+18h] [bp-Ch]
  char *v9; // [sp+1Ch] [bp-8h]

  if ( **(_BYTE **)(a1 + 36) )
  {
    v9 = strchr(*(const char **)(a1 + 36), 35);
    if ( v9 )
    {
      v6 = 0;
      _isoc99_sscanf(v9, "#%d%n", a1 + 1076, &v6);
      if ( !v6 )
        v6 = 1;
      if ( v9[v6] == 114 )
      {
        *(_DWORD *)(a1 + 1080) = 1;
      }
      else
      {
        if ( v9[v6] != 115 )
        {
          sub_93A0C(2, "src/rotater.c", 386, "#r or #s not found");
          return -1;
        }
        *(_DWORD *)(a1 + 1080) = 2;
      }
      n = (size_t)&v9[-*(_DWORD *)(a1 + 36)];
      if ( n <= 0x400 )
      {
        memcpy((void *)(a1 + 40), *(const void **)(a1 + 36), n);
        v7 = snprintf((char *)(a1 + 40 + n), 1025 - n, "*%s", &v9[v6 + 1]);
        if ( v7 >= 0 && 1025 - n >= v7 )
        {
          *(_DWORD *)(a1 + 1068) = n;
          *(_DWORD *)(a1 + 1072) = n + 1;
          return 0;
        }
        else
        {
          v3 = _errno_location();
          sub_93A0C(2, "src/rotater.c", 401, "nwirte[%d], overflow or errno[%d]", v7, *v3);
          return -1;
        }
      }
      else
      {
        sub_93A0C(2, "src/rotater.c", 393, "sizeof glob_path not enough,len[%ld]", n);
        return -1;
      }
    }
    else
    {
      sub_93A0C(2, "src/rotater.c", 374, "no # in archive_path[%s]", *(const char **)(a1 + 36));
      return -1;
    }
  }
  else
  {
    v7 = snprintf((char *)(a1 + 40), 0x401u, "%s.*", *(const char **)(a1 + 32));
    if ( (unsigned int)v7 < 0x402 )
    {
      *(_DWORD *)(a1 + 1080) = 1;
      *(_DWORD *)(a1 + 1076) = 0;
      *(_DWORD *)(a1 + 1068) = strlen(*(const char **)(a1 + 32)) + 1;
      *(_DWORD *)(a1 + 1072) = strlen(*(const char **)(a1 + 32)) + 2;
      return 0;
    }
    else
    {
      v1 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 360, "nwirte[%d], overflow or errno[%d]", v7, *v1);
      return -1;
    }
  }
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0008BD9C) --------------------------------------------------------
void __fastcall sub_8BD9C(_DWORD *a1)
{
  a1[8] = 0;
  a1[9] = 0;
  a1[271] = 0;
  a1[270] = 0;
  a1[269] = 0;
  a1[267] = 0;
  a1[268] = 0;
  memset(a1 + 10, 0, 0x401u);
  if ( a1[272] )
    sub_92670(a1[272]);
  a1[272] = 0;
}

//----- (0008BE50) --------------------------------------------------------
int __fastcall sub_8BE50(_DWORD *a1, int a2, int a3, int a4)
{
  a1[8] = a2;
  a1[9] = a3;
  a1[271] = a4;
  if ( sub_8BA60((int)a1) )
  {
    sub_93A0C(2, "src/rotater.c", 437, "zlog_rotater_parse_archive_path fail", a4, a3, a2);
LABEL_12:
    sub_8BD9C(a1);
    return -1;
  }
  if ( sub_8B130((int)a1) )
  {
    sub_93A0C(2, "src/rotater.c", 443, "zlog_rotater_add_archive_files fail", a4, a3, a2);
    goto LABEL_12;
  }
  if ( a1[270] == 1 )
  {
    if ( sub_8B65C((int)a1) )
    {
      sub_93A0C(2, "src/rotater.c", 450, "zlog_rotater_roll_files fail", a4, a3, a2);
      goto LABEL_12;
    }
  }
  else if ( a1[270] == 2 && sub_8B300((int)a1) )
  {
    sub_93A0C(2, "src/rotater.c", 456, "zlog_rotater_seq_files fail", a4, a3, a2);
    goto LABEL_12;
  }
  sub_8BD9C(a1);
  return 0;
}

//----- (0008BFC0) --------------------------------------------------------
int __fastcall sub_8BFC0(pthread_mutex_t *a1)
{
  unsigned int count; // r4
  int *v3; // r0
  int *v4; // r0
  _WORD v7[2]; // [sp+14h] [bp-20h] BYREF
  int v8; // [sp+18h] [bp-1Ch]
  int v9; // [sp+1Ch] [bp-18h]
  int v10; // [sp+24h] [bp-10h]

  v7[0] = 1;
  v8 = 0;
  v7[1] = 0;
  v9 = 0;
  v10 = pthread_mutex_trylock(a1);
  if ( v10 == 16 )
  {
    sub_93A0C(1, "src/rotater.c", 481, "pthread_mutex_trylock fail, as lock_mutex is locked by other threads");
    return -1;
  }
  else if ( v10 )
  {
    sub_93A0C(2, "src/rotater.c", 484, "pthread_mutex_trylock fail, rc[%d]", v10);
    return -1;
  }
  else if ( fcntl(a1[1].__count, 6, v7) )
  {
    if ( *_errno_location() == 11 || *_errno_location() == 13 )
    {
      sub_93A0C(1, "src/rotater.c", 493, "fcntl lock fail, as file is lock by other process");
    }
    else
    {
      count = a1[1].__count;
      v3 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 495, "lock fd[%d] fail, errno[%d]", count, *v3);
    }
    if ( pthread_mutex_unlock(a1) )
    {
      v4 = _errno_location();
      sub_93A0C(2, "src/rotater.c", 498, "pthread_mutex_unlock fail, errno[%d]", *v4);
    }
    return -1;
  }
  else
  {
    return 0;
  }
}

//----- (0008C168) --------------------------------------------------------
int __fastcall sub_8C168(pthread_mutex_t *a1)
{
  const char *count; // r4
  int *v2; // r0
  int *v3; // r0
  _WORD v6[2]; // [sp+14h] [bp-20h] BYREF
  int v7; // [sp+18h] [bp-1Ch]
  int v8; // [sp+1Ch] [bp-18h]
  int v9; // [sp+24h] [bp-10h]

  v9 = 0;
  v6[0] = 2;
  v7 = 0;
  v6[1] = 0;
  v8 = 0;
  if ( fcntl(a1[1].__count, 6, v6) )
  {
    v9 = -1;
    count = (const char *)a1[1].__count;
    v2 = _errno_location();
    sub_93A0C(2, "src/rotater.c", 518, "unlock fd[%s] fail, errno[%d]", count, *v2);
  }
  if ( pthread_mutex_unlock(a1) )
  {
    v9 = -1;
    v3 = _errno_location();
    sub_93A0C(2, "src/rotater.c", 523, "pthread_mutext_unlock fail, errno[%d]", *v3);
  }
  return v9;
}

//----- (0008C260) --------------------------------------------------------
int __fastcall sub_8C260(pthread_mutex_t *a1, const char *a2, int a3, int a4, unsigned int a5, int a6)
{
  int *v7; // r0
  struct stat v13; // [sp+18h] [bp-64h] BYREF
  int v14; // [sp+74h] [bp-8h]

  v14 = 0;
  if ( a2 )
  {
    if ( sub_8BFC0(a1) )
    {
      sub_93A0C(1, "src/rotater.c", 539, "zlog_rotater_trylock fail, maybe lock by other process or threads");
      return 0;
    }
    else
    {
      if ( sub_97014(a2, &v13) )
      {
        v14 = -1;
        v7 = _errno_location();
        sub_93A0C(2, "src/rotater.c", 545, "stat [%s] fail, errno[%d]", a2, *v7);
      }
      else if ( v13.st_size + a3 > a5 )
      {
        v14 = sub_8BE50(a1, (int)a2, a4, a6);
        if ( v14 )
        {
          sub_93A0C(2, "src/rotater.c", 560, "zlog_rotater_lsmv [%s] fail, return", a2);
          v14 = -1;
        }
      }
      else
      {
        v14 = 0;
      }
      if ( sub_8C168(a1) )
        sub_93A0C(2, "src/rotater.c", 569, "zlog_rotater_unlock fail");
      return v14;
    }
  }
  else
  {
    sub_93A0C(2, "src/rotater.c", 536, "base_path is null or 0");
    return -1;
  }
}

//----- (0008C408) --------------------------------------------------------
int __fastcall sub_8C408(int a1, int a2)
{
  int result; // r0
  int i; // [sp+64h] [bp-28h]

  if ( !a1 )
    return sub_93A0C(2, "src/rule.c", 39, "a_rule is null or 0");
  result = sub_93A0C(
             a2,
             "src/rule.c",
             65,
             "---rule:[%p][%s%c%d]-[%d,%d][%s,%p,%d:%ld*%d~%s][%d][%d][%s:%s:%p];[%p]---",
             (const void *)a1,
             (const char *)a1,
             *(unsigned __int8 *)(a1 + 4097),
             *(_DWORD *)(a1 + 4100),
             *(_DWORD *)(a1 + 4136),
             *(_DWORD *)(a1 + 4140),
             (const char *)(a1 + 4144),
             *(const void **)(a1 + 5172),
             *(_DWORD *)(a1 + 5176),
             *(_DWORD *)(a1 + 5200),
             *(_DWORD *)(a1 + 5204),
             (const char *)(a1 + 5208),
             *(_DWORD *)(a1 + 6244),
             *(_DWORD *)(a1 + 6260),
             (const char *)(a1 + 6272),
             (const char *)(a1 + 7297),
             *(const void **)(a1 + 8324),
             *(const void **)(a1 + 6264));
  if ( *(_DWORD *)(a1 + 5172) )
  {
    for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(a1 + 5172) + 4); ++i )
      result = sub_8FEEC(*(const char ***)(**(_DWORD **)(a1 + 5172) + 4 * i), a2);
  }
  return result;
}

//----- (0008C630) --------------------------------------------------------
int __fastcall sub_8C630(int a1, int a2)
{
  int *v3; // r0
  _BOOL4 v4; // r3
  int *v5; // r0
  int *v6; // r0
  int *v7; // r0
  int v8; // r4
  int *v9; // r0
  __int64 v13; // [sp+10h] [bp-7Ch]
  __int64 v14; // [sp+70h] [bp-1Ch]
  int v15; // [sp+78h] [bp-14h]
  int v16; // [sp+7Ch] [bp-10h]

  v15 = 0;
  if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_93A0C(2, "src/rule.c", 84, "zlog_format_gen_msg fail");
    return -1;
  }
  else
  {
    if ( sub_97020() )
    {
      if ( *_errno_location() != 2 )
      {
        v3 = _errno_location();
        sub_93A0C(2, "src/rule.c", 91, "stat fail on [%s], errno[%d]", (const char *)(a1 + 4144), *v3);
        return -1;
      }
      v16 = 1;
      v15 = 1;
    }
    else
    {
      v4 = v14 != *(_QWORD *)(a1 + 5192) || v13 != *(_QWORD *)(a1 + 5184);
      v16 = v4;
    }
    if ( v16 )
    {
      close(*(_DWORD *)(a1 + 5176));
      *(_DWORD *)(a1 + 5176) = open64(a1 + 4144, *(_DWORD *)(a1 + 4140) | 0x441, *(_DWORD *)(a1 + 4136));
      if ( *(int *)(a1 + 5176) < 0 )
      {
        v5 = _errno_location();
        sub_93A0C(2, "src/rule.c", 107, "open file[%s] fail, errno[%d]", (const char *)(a1 + 4144), *v5);
        return -1;
      }
      if ( v15 && sub_97020() )
      {
        v6 = _errno_location();
        sub_93A0C(2, "src/rule.c", 114, "stat fail on new file[%s], errno[%d]", (const char *)(a1 + 4144), *v6);
        return -1;
      }
      *(_QWORD *)(a1 + 5184) = v13;
      *(_QWORD *)(a1 + 5192) = v14;
    }
    if ( write(
           *(_DWORD *)(a1 + 5176),
           **(const void ***)(a2 + 28),
           *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) >= 0 )
    {
      if ( *(_DWORD *)(a1 + 6248) )
      {
        if ( ++*(_DWORD *)(a1 + 6252) >= *(_DWORD *)(a1 + 6248) )
        {
          *(_DWORD *)(a1 + 6252) = 0;
          if ( fsync(*(_DWORD *)(a1 + 5176)) )
          {
            v8 = *(_DWORD *)(a1 + 5176);
            v9 = _errno_location();
            sub_93A0C(2, "src/rule.c", 133, "fsync[%d] fail, errno[%d]", v8, *v9);
          }
        }
      }
      return 0;
    }
    else
    {
      v7 = _errno_location();
      sub_93A0C(2, "src/rule.c", 125, "write fail, errno[%d]", *v7);
      return -1;
    }
  }
}
// 8C74C: variable 'v14' is possibly undefined
// 8C768: variable 'v13' is possibly undefined
// 12550: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);

//----- (0008CA24) --------------------------------------------------------
int __fastcall sub_8CA24(int a1, int a2)
{
  int i; // [sp+Ch] [bp-8h]

  if ( !*(_DWORD *)(a1 + 6236) )
    return a1 + 5208;
  *(_DWORD *)(*(_DWORD *)(a2 + 20) + 4) = **(_DWORD **)(a2 + 20);
  for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(a1 + 6236) + 4); ++i )
  {
    if ( (*(int (__fastcall **)(_DWORD, int))(*(_DWORD *)(**(_DWORD **)(a1 + 6236) + 4 * i) + 9264))(
           *(_DWORD *)(**(_DWORD **)(a1 + 6236) + 4 * i),
           a2) )
    {
      sub_93A0C(2, "src/rule.c", 151, "zlog_spec_gen_path fail");
      return 0;
    }
  }
  **(_BYTE **)(*(_DWORD *)(a2 + 20) + 4) = 0;
  return **(_DWORD **)(a2 + 20);
}

//----- (0008CB5C) --------------------------------------------------------
int __fastcall sub_8CB5C(int a1, int a2)
{
  int *v3; // r0
  int *v4; // r0
  int *v5; // r0
  int *v6; // r0
  int *v7; // r0
  pthread_mutex_t *v8; // r5
  int v9; // r0
  __int64 v13; // [sp+40h] [bp-4Ch]
  unsigned int n; // [sp+78h] [bp-14h]
  int fd; // [sp+7Ch] [bp-10h]

  if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_93A0C(2, "src/rule.c", 167, "zlog_format_gen_msg fail");
    return -1;
  }
  else
  {
    fd = open64(a1 + 4144, *(_DWORD *)(a1 + 4140) | 0x441, *(_DWORD *)(a1 + 4136));
    if ( fd >= 0 )
    {
      n = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28);
      if ( write(fd, **(const void ***)(a2 + 28), n) >= 0 )
      {
        if ( *(_DWORD *)(a1 + 6248) )
        {
          if ( ++*(_DWORD *)(a1 + 6252) >= *(_DWORD *)(a1 + 6248) )
          {
            *(_DWORD *)(a1 + 6252) = 0;
            if ( fsync(fd) )
            {
              v5 = _errno_location();
              sub_93A0C(2, "src/rule.c", 187, "fsync[%d] fail, errno[%d]", fd, *v5);
            }
          }
        }
        if ( close(fd) >= 0 )
        {
          if ( n <= *(_DWORD *)(a1 + 5200) )
          {
            if ( sub_97020() )
            {
              v7 = _errno_location();
              sub_93A0C(
                1,
                "src/rule.c",
                202,
                "stat [%s] fail, errno[%d], maybe in rotating",
                (const char *)(a1 + 4144),
                *v7);
              return 0;
            }
            else if ( v13 + n >= *(int *)(a1 + 5200) )
            {
              v8 = *(pthread_mutex_t **)(dword_AB7AFC + 5160);
              v9 = sub_8CA24(a1, a2);
              if ( sub_8C260(v8, (const char *)(a1 + 4144), n, v9, *(_DWORD *)(a1 + 5200), *(_DWORD *)(a1 + 5204)) )
              {
                sub_93A0C(2, "src/rule.c", 214, "zlog_rotater_rotate fail");
                return -1;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              return 0;
            }
          }
          else
          {
            sub_93A0C(
              0,
              "src/rule.c",
              197,
              "one msg's len[%ld] > archive_max_size[%ld], no rotate",
              n,
              *(_DWORD *)(a1 + 5200));
            return 0;
          }
        }
        else
        {
          v6 = _errno_location();
          sub_93A0C(2, "src/rule.c", 191, "close fail, maybe cause by write, errno[%d]", *v6);
          return -1;
        }
      }
      else
      {
        v4 = _errno_location();
        sub_93A0C(2, "src/rule.c", 180, "write fail, errno[%d]", *v4);
        close(fd);
        return -1;
      }
    }
    else
    {
      v3 = _errno_location();
      sub_93A0C(2, "src/rule.c", 174, "open file[%s] fail, errno[%d]", (const char *)(a1 + 4144), *v3);
      return -1;
    }
  }
}
// 8CE94: variable 'v13' is possibly undefined
// 12550: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (0008CF64) --------------------------------------------------------
int __fastcall sub_8CF64(int a1, int a2)
{
  const char *v3; // r4
  int *v4; // r0
  int *v5; // r0
  int *v6; // r0
  int *v7; // r0
  int fd; // [sp+14h] [bp-18h]
  int i; // [sp+1Ch] [bp-10h]

  *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4) = **(_DWORD **)(a2 + 16);
  for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(a1 + 5172) + 4); ++i )
  {
    if ( (*(int (__fastcall **)(_DWORD, int))(*(_DWORD *)(**(_DWORD **)(a1 + 5172) + 4 * i) + 9260))(
           *(_DWORD *)(**(_DWORD **)(a1 + 5172) + 4 * i),
           a2) )
    {
      sub_93A0C(2, "src/rule.c", 245, "zlog_spec_gen_path fail");
      return -1;
    }
  }
  **(_BYTE **)(*(_DWORD *)(a2 + 16) + 4) = 0;
  if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_93A0C(2, "src/rule.c", 248, "zlog_format_output fail");
    return -1;
  }
  else
  {
    fd = open64(**(_DWORD **)(a2 + 16), *(_DWORD *)(a1 + 4140) | 0x441, *(_DWORD *)(a1 + 4136));
    if ( fd >= 0 )
    {
      if ( write(fd, **(const void ***)(a2 + 28), *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) >= 0 )
      {
        if ( *(_DWORD *)(a1 + 6248) )
        {
          if ( ++*(_DWORD *)(a1 + 6252) >= *(_DWORD *)(a1 + 6248) )
          {
            *(_DWORD *)(a1 + 6252) = 0;
            if ( fsync(fd) )
            {
              v6 = _errno_location();
              sub_93A0C(2, "src/rule.c", 267, "fsync[%d] fail, errno[%d]", fd, *v6);
            }
          }
        }
        if ( close(fd) >= 0 )
        {
          return 0;
        }
        else
        {
          v7 = _errno_location();
          sub_93A0C(2, "src/rule.c", 271, "close fail, maybe cause by write, errno[%d]", *v7);
          return -1;
        }
      }
      else
      {
        v5 = _errno_location();
        sub_93A0C(2, "src/rule.c", 260, "write fail, errno[%d]", *v5);
        close(fd);
        return -1;
      }
    }
    else
    {
      v3 = **(const char ***)(a2 + 16);
      v4 = _errno_location();
      sub_93A0C(2, "src/rule.c", 255, "open file[%s] fail, errno[%d]", v3, *v4);
      return -1;
    }
  }
}
// 12550: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);

//----- (0008D2B4) --------------------------------------------------------
int __fastcall sub_8D2B4(int a1, int a2)
{
  const char *v3; // r4
  int *v4; // r0
  int *v5; // r0
  int *v6; // r0
  int *v7; // r0
  int *v8; // r0
  pthread_mutex_t *v9; // r4
  int v10; // r0
  __int64 v14; // [sp+40h] [bp-5Ch]
  unsigned int n; // [sp+7Ch] [bp-20h]
  int fd; // [sp+80h] [bp-1Ch]
  const char *v17; // [sp+84h] [bp-18h]
  int i; // [sp+8Ch] [bp-10h]

  *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4) = **(_DWORD **)(a2 + 16);
  for ( i = 0; i < *(_DWORD *)(*(_DWORD *)(a1 + 5172) + 4); ++i )
  {
    if ( (*(int (__fastcall **)(_DWORD, int))(*(_DWORD *)(**(_DWORD **)(a1 + 5172) + 4 * i) + 9260))(
           *(_DWORD *)(**(_DWORD **)(a1 + 5172) + 4 * i),
           a2) )
    {
      sub_93A0C(2, "src/rule.c", 285, "zlog_spec_gen_path fail");
      return -1;
    }
  }
  **(_BYTE **)(*(_DWORD *)(a2 + 16) + 4) = 0;
  if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_93A0C(2, "src/rule.c", 288, "zlog_format_output fail");
    return -1;
  }
  else
  {
    v17 = **(const char ***)(a2 + 16);
    fd = open64(v17, *(_DWORD *)(a1 + 4140) | 0x441, *(_DWORD *)(a1 + 4136));
    if ( fd >= 0 )
    {
      n = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28);
      if ( write(fd, **(const void ***)(a2 + 28), n) >= 0 )
      {
        if ( *(_DWORD *)(a1 + 6248) )
        {
          if ( ++*(_DWORD *)(a1 + 6252) >= *(_DWORD *)(a1 + 6248) )
          {
            *(_DWORD *)(a1 + 6252) = 0;
            if ( fsync(fd) )
            {
              v6 = _errno_location();
              sub_93A0C(2, "src/rule.c", 308, "fsync[%d] fail, errno[%d]", fd, *v6);
            }
          }
        }
        if ( close(fd) >= 0 )
        {
          if ( n <= *(_DWORD *)(a1 + 5200) )
          {
            if ( sub_97020() )
            {
              v8 = _errno_location();
              sub_93A0C(1, "src/rule.c", 323, "stat [%s] fail, errno[%d], maybe in rotating", v17, *v8);
              return 0;
            }
            else if ( v14 + n >= *(int *)(a1 + 5200) )
            {
              v9 = *(pthread_mutex_t **)(dword_AB7AFC + 5160);
              v10 = sub_8CA24(a1, a2);
              if ( sub_8C260(v9, v17, n, v10, *(_DWORD *)(a1 + 5200), *(_DWORD *)(a1 + 5204)) )
              {
                sub_93A0C(2, "src/rule.c", 335, "zlog_rotater_rotate fail");
                return -1;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              return 0;
            }
          }
          else
          {
            sub_93A0C(
              0,
              "src/rule.c",
              318,
              "one msg's len[%ld] > archive_max_size[%ld], no rotate",
              n,
              *(_DWORD *)(a1 + 5200));
            return 0;
          }
        }
        else
        {
          v7 = _errno_location();
          sub_93A0C(2, "src/rule.c", 312, "write fail, maybe cause by write, errno[%d]", *v7);
          return -1;
        }
      }
      else
      {
        v5 = _errno_location();
        sub_93A0C(2, "src/rule.c", 301, "write fail, errno[%d]", *v5);
        close(fd);
        return -1;
      }
    }
    else
    {
      v3 = **(const char ***)(a2 + 16);
      v4 = _errno_location();
      sub_93A0C(2, "src/rule.c", 295, "open file[%s] fail, errno[%d]", v3, *v4);
      return -1;
    }
  }
}
// 8D6C8: variable 'v14' is possibly undefined
// 12550: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (0008D78C) --------------------------------------------------------
int __fastcall sub_8D78C(int a1, int a2)
{
  int *v3; // r0

  if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_93A0C(2, "src/rule.c", 345, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(
              *(_DWORD *)(a1 + 6244),
              **(const void ***)(a2 + 28),
              *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) >= 0 )
  {
    return 0;
  }
  else
  {
    v3 = _errno_location();
    sub_93A0C(2, "src/rule.c", 352, "write fail, errno[%d]", *v3);
    return -1;
  }
}

//----- (0008D878) --------------------------------------------------------
int __fastcall sub_8D878(int a1, int a2)
{
  int v6; // [sp+Ch] [bp-8h]

  if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_93A0C(2, "src/rule.c", 364, "zlog_format_gen_msg fail");
    return -1;
  }
  else
  {
    v6 = sub_89F54(*(_DWORD **)(dword_AB7AFC + 9280), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292));
    **(_BYTE **)(*(_DWORD *)(a2 + 28) + 4) = 0;
    syslog(*(_DWORD *)(a1 + 6260) | *(_DWORD *)(v6 + 2060), "%s", **(const char ***)(a2 + 28));
    return 0;
  }
}
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (0008D95C) --------------------------------------------------------
int __fastcall sub_8D95C(int a1, int a2)
{
  _DWORD v6[3]; // [sp+14h] [bp-10h] BYREF

  if ( *(_DWORD *)(a1 + 8324) )
  {
    if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
    {
      sub_93A0C(2, "src/rule.c", 391, "zlog_format_gen_msg fail");
      return -1;
    }
    else
    {
      **(_BYTE **)(*(_DWORD *)(a2 + 28) + 4) = 0;
      v6[0] = **(_DWORD **)(a2 + 28);
      v6[1] = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28);
      v6[2] = a1 + 7297;
      if ( (*(int (__fastcall **)(_DWORD *))(a1 + 8324))(v6) )
      {
        sub_93A0C(2, "src/rule.c", 401, "a_rule->record fail");
        return -1;
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    sub_93A0C(
      2,
      "src/rule.c",
      386,
      "user defined record funcion for [%s] not set, no output",
      (const char *)(a1 + 6272));
    return -1;
  }
}

//----- (0008DAAC) --------------------------------------------------------
int __fastcall sub_8DAAC(int a1, int a2)
{
  _DWORD v6[3]; // [sp+14h] [bp-18h] BYREF
  int v7; // [sp+20h] [bp-Ch]
  int v8; // [sp+24h] [bp-8h]

  if ( *(_DWORD *)(a1 + 8324) )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4) = **(_DWORD **)(a2 + 16);
    v8 = 0;
    v7 = ***(_DWORD ***)(a1 + 5172);
    while ( v8 < *(_DWORD *)(*(_DWORD *)(a1 + 5172) + 4) )
    {
      v7 = *(_DWORD *)(**(_DWORD **)(a1 + 5172) + 4 * v8);
      if ( (*(int (__fastcall **)(int, int))(v7 + 9260))(v7, a2) )
      {
        sub_93A0C(2, "src/rule.c", 417, "zlog_spec_gen_path fail");
        return -1;
      }
      ++v8;
    }
    **(_BYTE **)(*(_DWORD *)(a2 + 16) + 4) = 0;
    if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
    {
      sub_93A0C(2, "src/rule.c", 420, "zlog_format_gen_msg fail");
      return -1;
    }
    else
    {
      **(_BYTE **)(*(_DWORD *)(a2 + 28) + 4) = 0;
      v6[0] = **(_DWORD **)(a2 + 28);
      v6[1] = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28);
      v6[2] = **(_DWORD **)(a2 + 16);
      if ( (*(int (__fastcall **)(_DWORD *))(a1 + 8324))(v6) )
      {
        sub_93A0C(2, "src/rule.c", 430, "a_rule->record fail");
        return -1;
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    sub_93A0C(
      2,
      "src/rule.c",
      413,
      "user defined record funcion for [%s] not set, no output",
      (const char *)(a1 + 6272));
    return -1;
  }
}

//----- (0008DCE4) --------------------------------------------------------
int __fastcall sub_8DCE4(int a1, int a2)
{
  int *v3; // r0

  if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_93A0C(2, "src/rule.c", 441, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(1, **(const void ***)(a2 + 28), *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) >= 0 )
  {
    return 0;
  }
  else
  {
    v3 = _errno_location();
    sub_93A0C(2, "src/rule.c", 447, "write fail, errno[%d]", *v3);
    return -1;
  }
}

//----- (0008DDC8) --------------------------------------------------------
int __fastcall sub_8DDC8(int a1, int a2)
{
  int *v3; // r0

  if ( sub_89A80(*(_DWORD *)(a1 + 6264), a2) )
  {
    sub_93A0C(2, "src/rule.c", 459, "zlog_format_gen_msg fail");
    return -1;
  }
  else if ( write(2, **(const void ***)(a2 + 28), *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4) - **(_DWORD **)(a2 + 28)) >= 0 )
  {
    return 0;
  }
  else
  {
    v3 = _errno_location();
    sub_93A0C(2, "src/rule.c", 465, "write fail, errno[%d]", *v3);
    return -1;
  }
}

//----- (0008DEAC) --------------------------------------------------------
int __fastcall sub_8DEAC(const char *a1)
{
  if ( a1 )
  {
    if ( !strcasecmp(a1, "LOG_LOCAL0") )
    {
      return 128;
    }
    else if ( !strcasecmp(a1, "LOG_LOCAL1") )
    {
      return 136;
    }
    else if ( !strcasecmp(a1, "LOG_LOCAL2") )
    {
      return 144;
    }
    else if ( !strcasecmp(a1, "LOG_LOCAL3") )
    {
      return 152;
    }
    else if ( !strcasecmp(a1, "LOG_LOCAL4") )
    {
      return 160;
    }
    else if ( !strcasecmp(a1, "LOG_LOCAL5") )
    {
      return 168;
    }
    else if ( !strcasecmp(a1, "LOG_LOCAL6") )
    {
      return 176;
    }
    else if ( !strcasecmp(a1, "LOG_LOCAL7") )
    {
      return 184;
    }
    else if ( !strcasecmp(a1, "LOG_USER") )
    {
      return 8;
    }
    else if ( !strcasecmp(a1, "LOG_AUTHPRIV") )
    {
      return 80;
    }
    else if ( !strcasecmp(a1, "LOG_CRON") )
    {
      return 72;
    }
    else if ( !strcasecmp(a1, "LOG_DAEMON") )
    {
      return 24;
    }
    else if ( !strcasecmp(a1, "LOG_FTP") )
    {
      return 88;
    }
    else if ( !strcasecmp(a1, "LOG_KERN") )
    {
      return 0;
    }
    else if ( !strcasecmp(a1, "LOG_LPR") )
    {
      return 48;
    }
    else if ( !strcasecmp(a1, "LOG_MAIL") )
    {
      return 16;
    }
    else if ( !strcasecmp(a1, "LOG_NEWS") )
    {
      return 56;
    }
    else if ( !strcasecmp(a1, "LOG_SYSLOG") )
    {
      return 40;
    }
    else
    {
      return 80;
    }
  }
  else
  {
    sub_93A0C(2, "src/rule.c", 477, "facility is null or 0");
    return -187;
  }
}

//----- (0008E184) --------------------------------------------------------
int __fastcall sub_8E184(int a1, void *a2, int a3, _DWORD *a4, _DWORD *a5)
{
  char *v11; // [sp+1Ch] [bp-18h] BYREF
  const char **v12; // [sp+20h] [bp-14h]
  _DWORD *v13; // [sp+24h] [bp-10h]
  size_t n; // [sp+28h] [bp-Ch]
  char *s; // [sp+2Ch] [bp-8h]

  s = (char *)(a1 + 1);
  v11 = strrchr((const char *)(a1 + 1), 34);
  if ( v11 )
  {
    n = v11 - s;
    if ( v11 - s <= (unsigned int)(a3 - 1) )
    {
      memcpy(a2, s, n);
      if ( sub_93F88((char *)a2, a3) )
      {
        sub_93A0C(2, "src/rule.c", 528, "zc_str_replace_env fail");
        return -1;
      }
      else if ( strchr((const char *)a2, 37) )
      {
        v13 = sub_92568((int)sub_912C4);
        if ( a4 )
        {
          for ( s = (char *)a2; ; s = v11 )
          {
            if ( !*s )
            {
              *a4 = v13;
              return 0;
            }
            v12 = sub_91334(s, &v11, a5);
            if ( !v12 )
            {
              sub_93A0C(2, "src/rule.c", 546, "zlog_spec_new fail");
              goto LABEL_19;
            }
            if ( sub_92968((int)v13, (int)v12) )
              break;
          }
          sub_93A0C(2, "src/rule.c", 551, "zc_arraylist_add fail");
LABEL_19:
          if ( v13 )
            sub_92670((int)v13);
          if ( v12 )
            sub_912C4(v12);
          return -1;
        }
        else
        {
          sub_93A0C(2, "src/rule.c", 539, "zc_arraylist_new fail");
          return -1;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      sub_93A0C(2, "src/rule.c", 521, "file_path too long %ld > %ld", n, a3 - 1);
      return -1;
    }
  }
  else
  {
    sub_93A0C(2, "src/rule.c", 516, "matching \" not found in conf line[%s]", (const char *)a1);
    return -1;
  }
}

//----- (0008E3F0) --------------------------------------------------------
char *__fastcall sub_8E3F0(const char *a1, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  int *v8; // r0
  int v9; // r0
  bool v10; // nf
  int v11; // r0
  int v12; // r3
  int v13; // r0
  int v14; // r0
  int v15; // r3
  int v16; // r0
  int v17; // r0
  int v18; // r3
  int v19; // r0
  int v20; // r0
  int v21; // r0
  const char *v22; // r4
  int *v23; // r0
  const char *v24; // r4
  int *v25; // r0
  FILE *v26; // r0
  int *v27; // r0
  int v28; // r0
  int *v29; // r0
  int v30; // r0
  _DWORD *v31; // r0
  __int64 v37; // [sp+18h] [bp-70C4h]
  __int64 v38; // [sp+78h] [bp-7064h]
  char *v39; // [sp+80h] [bp-705Ch] BYREF
  char v40[4100]; // [sp+84h] [bp-7058h] BYREF
  char v41[4100]; // [sp+1088h] [bp-6054h] BYREF
  char v42[4100]; // [sp+208Ch] [bp-5050h] BYREF
  char v43[4100]; // [sp+3090h] [bp-404Ch] BYREF
  _BYTE v44[4100]; // [sp+4094h] [bp-3048h] BYREF
  char v45[4100]; // [sp+5098h] [bp-2044h] BYREF
  char v46[4100]; // [sp+609Ch] [bp-1040h] BYREF
  int v47; // [sp+70A0h] [bp-3Ch] BYREF
  const char **v48; // [sp+70A4h] [bp-38h]
  size_t n; // [sp+70A8h] [bp-34h]
  char *s1; // [sp+70ACh] [bp-30h]
  const char *v51; // [sp+70B0h] [bp-2Ch]
  char *dest; // [sp+70B4h] [bp-28h]
  int v53; // [sp+70B8h] [bp-24h]
  int v54; // [sp+70BCh] [bp-20h]
  int v55; // [sp+70C0h] [bp-1Ch]
  int v56; // [sp+70C4h] [bp-18h]
  char *i; // [sp+70C8h] [bp-14h]
  char *s; // [sp+70CCh] [bp-10h]

  v54 = 0;
  v53 = 0;
  v47 = 0;
  if ( a1 )
  {
    if ( !a3 )
    {
      sub_93A0C(2, "src/rule.c", 593, "default_format is null or 0");
      return 0;
    }
    if ( !a4 )
    {
      sub_93A0C(2, "src/rule.c", 594, "formats is null or 0");
      return 0;
    }
    dest = (char *)calloc(1u, 0x2088u);
    if ( !dest )
    {
      v8 = _errno_location();
      sub_93A0C(2, "src/rule.c", 598, "calloc fail, errno[%d]", *v8);
      return 0;
    }
    *((_DWORD *)dest + 1034) = a5;
    *((_DWORD *)dest + 1562) = a6;
    memset(v46, 0, 0x1001u);
    v53 = _isoc99_sscanf(a1, "%s %n", v46, &v47);
    if ( v53 != 1 )
    {
      sub_93A0C(2, "src/rule.c", 612, "sscanf [%s] fail, selector", a1);
LABEL_134:
      sub_8F938((int)dest);
      return 0;
    }
    v51 = &a1[v47];
    memset(v45, 0, 0x1001u);
    memset(v44, 0, 0x1001u);
    v53 = _isoc99_sscanf(v46, " %[^.].%s", v45, v44);
    if ( v53 != 2 )
    {
      sub_93A0C(2, "src/rule.c", 627, "sscanf [%s] fail, category or level is null", v46);
      goto LABEL_134;
    }
    for ( i = v45; *i; ++i )
    {
      if ( ((*_ctype_b_loc())[(unsigned __int8)*i] & 8) == 0 && *i != 95 && *i != 45 && *i != 42 && *i != 33 )
      {
        sub_93A0C(2, "src/rule.c", 634, "category name[%s] character is not in [a-Z][0-9][_!*-]", v45);
        goto LABEL_134;
      }
    }
    strcpy(dest, v45);
    switch ( v44[0] )
    {
      case '*':
        dest[4097] = 42;
        i = v44;
        break;
      case '=':
        dest[4097] = 61;
        i = &v44[1];
        break;
      case '!':
        dest[4097] = 33;
        i = &v44[1];
        break;
      default:
        dest[4097] = 46;
        i = v44;
        break;
    }
    v9 = sub_8A008(a2, i);
    *((_DWORD *)dest + 1025) = v9;
    switch ( dest[4097] )
    {
      case '!':
        memset(dest + 4104, 255, 0x20u);
        v15 = *((_DWORD *)dest + 1025);
        v14 = -v15;
        v10 = -v15 < 0;
        LOBYTE(v15) = v15 & 7;
        v16 = v14 & 7;
        if ( !v10 )
          v15 = -v16;
        dest[*((_DWORD *)dest + 1025) / 8 + 4104] &= ~(unsigned __int8)(1 << (7 - v15));
        break;
      case '*':
        memset(dest + 4104, 255, 0x20u);
        break;
      case '.':
        memset(dest + 4104, 0, 0x20u);
        v18 = *((_DWORD *)dest + 1025);
        v17 = -v18;
        v10 = -v18 < 0;
        LOBYTE(v18) = v18 & 7;
        v19 = v17 & 7;
        if ( !v10 )
          v18 = -v19;
        dest[*((_DWORD *)dest + 1025) / 8 + 4104] |= ~(unsigned __int8)(255 << (8 - v18));
        memset(&dest[*((_DWORD *)dest + 1025) / 8 + 4105], 255, 31 - *((_DWORD *)dest + 1025) / 8);
        break;
      case '=':
        memset(dest + 4104, 0, 0x20u);
        v12 = *((_DWORD *)dest + 1025);
        v11 = -v12;
        v10 = -v12 < 0;
        LOBYTE(v12) = v12 & 7;
        v13 = v11 & 7;
        if ( !v10 )
          v12 = -v13;
        dest[*((_DWORD *)dest + 1025) / 8 + 4104] |= 1 << (7 - v12);
        break;
      default:
        break;
    }
    memset(v43, 0, 0x1001u);
    memset(v42, 0, 0x1001u);
    v53 = _isoc99_sscanf(v51, " %[^;];%s", v43, v42);
    if ( v53 <= 0 )
    {
      sub_93A0C(2, "src/rule.c", 700, "sscanf [%s] fail", v51);
      goto LABEL_134;
    }
    if ( v42[0] )
    {
      v55 = 0;
      v56 = 0;
      s1 = **(char ***)a4;
      while ( v56 < *(_DWORD *)(a4 + 4) )
      {
        s1 = *(char **)(*(_DWORD *)a4 + 4 * v56);
        if ( !strcmp(s1, v42) )
        {
          *((_DWORD *)dest + 1566) = s1;
          v55 = 1;
          break;
        }
        ++v56;
      }
      if ( !v55 )
      {
        sub_93A0C(2, "src/rule.c", 722, "in conf file can't find format[%s], pls check", v42);
        goto LABEL_134;
      }
    }
    else
    {
      sub_93A0C(0, "src/rule.c", 706, "no format specified, use default");
      *((_DWORD *)dest + 1566) = a3;
    }
    memset(v41, 0, 0x1001u);
    v53 = _isoc99_sscanf(v43, " %[^,],", v41);
    if ( v53 <= 0 )
    {
      sub_93A0C(2, "src/rule.c", 734, "sscanf [%s] fail", v51);
      goto LABEL_134;
    }
    s = strchr(v43, 44);
    if ( s )
    {
      ++s;
      while ( ((*_ctype_b_loc())[(unsigned __int8)*s] & 0x2000) != 0 )
        ++s;
    }
    i = 0;
    if ( v41[0] == 45 )
    {
      if ( v41[1] != 34 )
      {
        sub_93A0C(2, "src/rule.c", 751, " - must set before a file output");
        goto LABEL_134;
      }
      *((_DWORD *)dest + 1562) = 0;
      i = &v41[1];
      *((_DWORD *)dest + 1035) = &unk_101000;
    }
    else
    {
      if ( (unsigned __int8)v41[0] > 0x2Du )
      {
        if ( v41[0] == 62 )
        {
          if ( !strncmp(&v41[1], "syslog", 6u) )
          {
            v30 = sub_8DEAC(s);
            *((_DWORD *)dest + 1565) = v30;
            if ( *((_DWORD *)dest + 1565) == -187 )
            {
              sub_93A0C(2, "src/rule.c", 853, "-187 get");
              goto LABEL_134;
            }
            *((_DWORD *)dest + 1567) = 579704;
            openlog(0, 25, 8);
          }
          else if ( !strncmp(&v41[1], "stdout", 6u) )
          {
            *((_DWORD *)dest + 1567) = 580836;
          }
          else
          {
            if ( strncmp(&v41[1], "stderr", 6u) )
            {
              sub_93A0C(2, "src/rule.c", 864, "[%s]the string after is not syslog, stdout or stderr", v43);
              goto LABEL_134;
            }
            *((_DWORD *)dest + 1567) = 581064;
          }
        }
        else
        {
          if ( v41[0] != 124 )
            goto LABEL_132;
          v26 = popen(&v43[1], "w");
          *((_DWORD *)dest + 1560) = v26;
          if ( !*((_DWORD *)dest + 1560) )
          {
            v27 = _errno_location();
            sub_93A0C(2, "src/rule.c", 839, "popen fail, errno[%d]", *v27);
            goto LABEL_134;
          }
          v28 = fileno(*((FILE **)dest + 1560));
          *((_DWORD *)dest + 1561) = v28;
          if ( *((int *)dest + 1561) < 0 )
          {
            v29 = _errno_location();
            sub_93A0C(2, "src/rule.c", 844, "fileno fail, errno[%d]", *v29);
            goto LABEL_134;
          }
          *((_DWORD *)dest + 1567) = 579468;
        }
        return dest;
      }
      if ( v41[0] != 34 )
      {
        if ( v41[0] != 36 )
        {
LABEL_132:
          sub_93A0C(2, "src/rule.c", 930, "the 1st char[%c] of file_path[%s] is wrong", (unsigned __int8)v41[0], v41);
          goto LABEL_134;
        }
        _isoc99_sscanf(&v41[1], "%s", dest + 6272);
        if ( s )
        {
          i = strchr(s, 34);
          if ( !i )
          {
            sub_93A0C(2, "src/rule.c", 874, "record_path not start with \", [%s]", s);
            goto LABEL_134;
          }
          v39 = strrchr(++i, 34);
          if ( !v39 )
          {
            sub_93A0C(2, "src/rule.c", 881, "matching \" not found in conf line[%s]", i);
            goto LABEL_134;
          }
          n = v39 - i;
          if ( (unsigned int)(v39 - i) > 0x400 )
          {
            sub_93A0C(2, "src/rule.c", 886, "record_path too long %ld > %ld", n, 1024);
            goto LABEL_134;
          }
          memcpy(dest + 7297, i, n);
        }
        v54 = sub_93F88(dest + 7297, 1025);
        if ( v54 )
        {
          sub_93A0C(2, "src/rule.c", 895, "zc_str_replace_env fail");
          goto LABEL_134;
        }
        if ( strchr(dest + 7297, 37) )
        {
          *((_DWORD *)dest + 1567) = 580268;
          v31 = sub_92568((int)sub_912C4);
          *((_DWORD *)dest + 1293) = v31;
          if ( !*((_DWORD *)dest + 1293) )
          {
            sub_93A0C(2, "src/rule.c", 909, "zc_arraylist_new fail");
            goto LABEL_134;
          }
          for ( i = dest + 7297; *i; i = v39 )
          {
            v48 = sub_91334(i, &v39, a7);
            if ( !v48 )
            {
              sub_93A0C(2, "src/rule.c", 915, "zlog_spec_new fail");
              goto LABEL_134;
            }
            v54 = sub_92968(*((_DWORD *)dest + 1293), (int)v48);
            if ( v54 )
            {
              sub_912C4(v48);
              sub_93A0C(2, "src/rule.c", 922, "zc_arraylist_add fail");
              goto LABEL_134;
            }
          }
        }
        else
        {
          *((_DWORD *)dest + 1567) = 579932;
        }
        return dest;
      }
    }
    if ( !i )
      i = v41;
    v54 = sub_8E184((int)i, dest + 4144, 1025, (_DWORD *)dest + 1293, a7);
    if ( v54 )
    {
      sub_93A0C(2, "src/rule.c", 767, "zlog_rule_parse_path fail");
      goto LABEL_134;
    }
    if ( s )
    {
      memset(v40, 0, 0x1001u);
      v53 = _isoc99_sscanf(s, " %[0-9MmKkBb] * %d ~", v40, dest + 5204);
      if ( v53 )
      {
        v20 = sub_93CA8(v40);
        *((_DWORD *)dest + 1300) = v20;
      }
      i = strchr(s, 34);
      if ( i )
      {
        v54 = sub_8E184((int)i, dest + 5208, 1025, (_DWORD *)dest + 1559, a7);
        if ( v54 )
        {
          sub_93A0C(2, "src/rule.c", 784, "zlog_rule_parse_path fail");
          goto LABEL_134;
        }
        i = strchr(dest + 5208, 35);
        if ( !i || !strchr(i, 114) && !strchr(i, 115) )
        {
          sub_93A0C(2, "src/rule.c", 790, "archive_path must contain #r or #s");
          goto LABEL_134;
        }
      }
    }
    if ( *((_DWORD *)dest + 1293) )
    {
      if ( *((int *)dest + 1300) > 0 )
        *((_DWORD *)dest + 1567) = 578228;
      else
        *((_DWORD *)dest + 1567) = 577380;
    }
    else
    {
      if ( *((int *)dest + 1300) > 0 )
        *((_DWORD *)dest + 1567) = 576348;
      else
        *((_DWORD *)dest + 1567) = 575024;
      v21 = open64(dest + 4144, *((_DWORD *)dest + 1035) | 0x441, *((_DWORD *)dest + 1034));
      *((_DWORD *)dest + 1294) = v21;
      if ( *((int *)dest + 1294) < 0 )
      {
        v22 = dest + 4144;
        v23 = _errno_location();
        sub_93A0C(2, "src/rule.c", 817, "open file[%s] fail, errno[%d]", v22, *v23);
        goto LABEL_134;
      }
      if ( sub_9702C() )
      {
        v24 = dest + 4144;
        v25 = _errno_location();
        sub_93A0C(2, "src/rule.c", 823, "stat [%s] fail, errno[%d], failing to open static_fd", v24, *v25);
        goto LABEL_134;
      }
      if ( *((int *)dest + 1300) > 0 )
      {
        close(*((_DWORD *)dest + 1294));
        *((_DWORD *)dest + 1294) = -1;
      }
      *((_QWORD *)dest + 648) = v37;
      *((_QWORD *)dest + 649) = v38;
    }
    return dest;
  }
  sub_93A0C(2, "src/rule.c", 592, "line is null or 0");
  return 0;
}
// 8E89C: control flows out of bounds to 8E8A0
// 8F334: variable 'v37' is possibly undefined
// 8F350: variable 'v38' is possibly undefined
// 12550: using guessed type int __fastcall open64(_DWORD, _DWORD, _DWORD);
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (0008F938) --------------------------------------------------------
void __fastcall sub_8F938(int a1)
{
  int *v1; // r0
  int *v2; // r0

  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 5172) )
    {
      sub_92670(*(_DWORD *)(a1 + 5172));
      *(_DWORD *)(a1 + 5172) = 0;
    }
    if ( *(_DWORD *)(a1 + 5176) && close(*(_DWORD *)(a1 + 5176)) )
    {
      v1 = _errno_location();
      sub_93A0C(2, "src/rule.c", 949, "close fail, maybe cause by write, errno[%d]", *v1);
    }
    if ( *(_DWORD *)(a1 + 6240) && pclose(*(FILE **)(a1 + 6240)) == -1 )
    {
      v2 = _errno_location();
      sub_93A0C(2, "src/rule.c", 954, "pclose fail, errno[%d]", *v2);
    }
    if ( *(_DWORD *)(a1 + 6236) )
    {
      sub_92670(*(_DWORD *)(a1 + 6236));
      *(_DWORD *)(a1 + 6236) = 0;
    }
    sub_93A0C(0, "src/rule.c", 961, "zlog_rule_del[%p]", (const void *)a1);
    free((void *)a1);
  }
  else
  {
    sub_93A0C(2, "src/rule.c", 942, "a_rule is null or 0");
  }
}

//----- (0008FAE4) --------------------------------------------------------
int __fastcall sub_8FAE4(int a1, int a2)
{
  int v2; // r3

  switch ( *(_BYTE *)(a1 + 4097) )
  {
    case '!':
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292) != *(_DWORD *)(a1 + 4100) )
        goto LABEL_8;
      return 0;
    case '*':
      goto LABEL_8;
    case '.':
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292) >= *(_DWORD *)(a1 + 4100) )
        goto LABEL_8;
      v2 = 0;
      break;
    case '=':
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292) == *(_DWORD *)(a1 + 4100) )
LABEL_8:
        v2 = (*(int (__fastcall **)(int, int))(a1 + 6268))(a1, a2);
      else
        v2 = 0;
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}
// 8FB10: control flows out of bounds to 8FB14

//----- (0008FC90) --------------------------------------------------------
int __fastcall sub_8FC90(const char *a1)
{
  if ( a1 )
    return strcmp(a1, "!") == 0;
  sub_93A0C(2, "src/rule.c", 1002, "a_rule is null or 0");
  return -1;
}

//----- (0008FD08) --------------------------------------------------------
int __fastcall sub_8FD08(const char *a1, const char *a2)
{
  size_t n; // [sp+Ch] [bp-8h]

  if ( a1 )
  {
    if ( a2 )
    {
      if ( !strcmp(a1, "*") )
      {
        return 1;
      }
      else if ( !strcmp(a1, a2) )
      {
        return 1;
      }
      else
      {
        n = strlen(a1);
        if ( a1[n - 1] != 95 )
          return 0;
        if ( strlen(a2) == n - 1 )
          --n;
        return !strncmp(a1, a2, n);
      }
    }
    else
    {
      sub_93A0C(2, "src/rule.c", 1015, "category is null or 0");
      return -1;
    }
  }
  else
  {
    sub_93A0C(2, "src/rule.c", 1014, "a_rule is null or 0");
    return -1;
  }
}

//----- (0008FE50) --------------------------------------------------------
int __fastcall sub_8FE50(int a1, int a2)
{
  int v4; // [sp+Ch] [bp-8h]

  if ( *(_DWORD *)(a1 + 6268) == 579932 || *(_DWORD *)(a1 + 6268) == 580268 )
  {
    v4 = sub_93190(a2, a1 + 6272);
    if ( v4 )
      *(_DWORD *)(a1 + 8324) = *(_DWORD *)(v4 + 1028);
  }
  return 0;
}

//----- (0008FEEC) --------------------------------------------------------
int __fastcall sub_8FEEC(const char **a1, int a2)
{
  const char *v3; // r0
  const char *v4; // r3

  if ( !a1 )
    return sub_93A0C(2, "src/spec.c", 34, "a_spec is null or 0");
  v3 = a1[1];
  if ( a1[2310] )
    v4 = "true";
  else
    v4 = "false";
  return sub_93A0C(
           a2,
           "src/spec.c",
           41,
           "----spec[%p][%.*s][%s|%d][%s,%ld,%ld,%s][%s]----",
           a1,
           (int)v3,
           *a1,
           (const char *)a1 + 8,
           a1[1027],
           (const char *)a1 + 5137,
           a1[2311],
           a1[2312],
           v4,
           (const char *)a1 + 4112);
}

//----- (00090004) --------------------------------------------------------
int __fastcall sub_90004(int a1, int a2, int a3)
{
  size_t v3; // r0
  time_t timer; // [sp+14h] [bp-10h] BYREF
  struct tm *tp; // [sp+18h] [bp-Ch]
  char *s; // [sp+1Ch] [bp-8h]

  s = (char *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 372) + 4108 * *(_DWORD *)(a1 + 4108));
  timer = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 316);
  tp = (struct tm *)(*(_DWORD *)(a2 + 8) + 328);
  if ( !timer )
  {
    gettimeofday((struct timeval *)(*(_DWORD *)(a2 + 8) + 316), 0);
    timer = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 316);
  }
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 324) != timer )
  {
    localtime_r(&timer, tp);
    *(_DWORD *)(*(_DWORD *)(a2 + 8) + 324) = timer;
  }
  if ( *((_DWORD *)s + 1026) != timer )
  {
    v3 = strftime(s, 0x1001u, (const char *)(a1 + 8), tp);
    *((_DWORD *)s + 1025) = v3;
    *((_DWORD *)s + 1026) = timer;
  }
  return sub_9560C(a3, s, *((_DWORD *)s + 1025));
}

//----- (00090150) --------------------------------------------------------
int __fastcall sub_90150(int a1, int a2, int a3)
{
  if ( !*(_DWORD *)(*(_DWORD *)(a2 + 8) + 316) )
    gettimeofday((struct timeval *)(*(_DWORD *)(a2 + 8) + 316), 0);
  return sub_94C78(a3, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 320) / 1000, 3u);
}

//----- (000901D8) --------------------------------------------------------
int __fastcall sub_901D8(int a1, int a2, int a3)
{
  if ( !*(_DWORD *)(*(_DWORD *)(a2 + 8) + 316) )
    gettimeofday((struct timeval *)(*(_DWORD *)(a2 + 8) + 316), 0);
  return sub_94C78(a3, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 320), 6u);
}

//----- (00090248) --------------------------------------------------------
int __fastcall sub_90248(int a1, int a2, int a3)
{
  int v7; // [sp+1Ch] [bp-8h]

  v7 = sub_8A5F4(*(int **)(a2 + 4), a1 + 4112);
  if ( v7 )
    return sub_9560C(a3, (const void *)(v7 + 1025), *(_DWORD *)(v7 + 2052));
  sub_93A0C(2, "src/spec.c", 123, "zlog_mdc_get_kv key[%s] fail", (const char *)(a1 + 4112));
  return 0;
}

//----- (000902F4) --------------------------------------------------------
int __fastcall sub_902F4(int a1, int a2, int a3)
{
  return sub_9560C(a3, *(const void **)a1, *(_DWORD *)(a1 + 4));
}

//----- (00090338) --------------------------------------------------------
int __fastcall sub_90338(int a1, int a2, int a3)
{
  return sub_9560C(a3, **(const void ***)(a2 + 8), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4));
}

//----- (00090384) --------------------------------------------------------
int __fastcall sub_90384(int a1, int a2, int a3)
{
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 272) )
    return sub_9560C(a3, *(const void **)(*(_DWORD *)(a2 + 8) + 272), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 276));
  else
    return sub_9560C(a3, "(file=null)", 0xBu);
}

//----- (00090400) --------------------------------------------------------
int __fastcall sub_90400(int a1, int a2, int a3)
{
  char *v7; // [sp+14h] [bp-8h]

  v7 = strrchr(*(const char **)(*(_DWORD *)(a2 + 8) + 272), 47);
  if ( v7 )
    return sub_9560C(
             a3,
             v7 + 1,
             *(_DWORD *)(*(_DWORD *)(a2 + 8) + 272) + *(_DWORD *)(*(_DWORD *)(a2 + 8) + 276) - (_DWORD)v7 - 1);
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 272) )
    return sub_9560C(a3, *(const void **)(*(_DWORD *)(a2 + 8) + 272), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 276));
  return sub_9560C(a3, "(file=null)", 0xBu);
}

//----- (000904EC) --------------------------------------------------------
int __fastcall sub_904EC(int a1, int a2, int a3)
{
  return sub_94F90(a3, *(int *)(*(_DWORD *)(a2 + 8) + 288), 0);
}

//----- (00090538) --------------------------------------------------------
int __fastcall sub_90538(int a1, int a2, int a3)
{
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 272) )
    return sub_9560C(a3, *(const void **)(*(_DWORD *)(a2 + 8) + 280), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 284));
  else
    return sub_9560C(a3, "(func=null)", 0xBu);
}

//----- (000905B4) --------------------------------------------------------
int __fastcall sub_905B4(int a1, int a2, int a3)
{
  return sub_9560C(a3, (const void *)(*(_DWORD *)(a2 + 8) + 8), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 268));
}

//----- (00090600) --------------------------------------------------------
int __fastcall sub_90600(int a1, int a2, int a3)
{
  return sub_9560C(a3, "\n", 1u);
}

//----- (0009063C) --------------------------------------------------------
int __fastcall sub_9063C(int a1, int a2, int a3)
{
  return sub_9560C(a3, "%", 1u);
}

//----- (00090678) --------------------------------------------------------
int __fastcall sub_90678(int a1, int a2, int a3)
{
  int v3; // r4

  if ( !*(_DWORD *)(*(_DWORD *)(a2 + 8) + 380) )
  {
    v3 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v3 + 380) = getpid();
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 380) != *(_DWORD *)(*(_DWORD *)(a2 + 8) + 384) )
    {
      *(_DWORD *)(*(_DWORD *)(a2 + 8) + 384) = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 380);
      *(_DWORD *)(*(_DWORD *)(a2 + 8) + 420) = sprintf(
                                                 (char *)(*(_DWORD *)(a2 + 8) + 388),
                                                 "%u",
                                                 *(_DWORD *)(*(_DWORD *)(a2 + 8) + 380));
    }
  }
  return sub_9560C(a3, (const void *)(*(_DWORD *)(a2 + 8) + 388), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 420));
}

//----- (0009075C) --------------------------------------------------------
int __fastcall sub_9075C(int a1, int a2, int a3)
{
  return sub_9560C(a3, (const void *)(*(_DWORD *)(a2 + 8) + 464), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 496));
}

//----- (000907A8) --------------------------------------------------------
int __fastcall sub_907A8(int a1, int a2, int a3)
{
  return sub_9560C(a3, (const void *)(*(_DWORD *)(a2 + 8) + 428), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 460));
}

//----- (000907F4) --------------------------------------------------------
int __fastcall sub_907F4(int a1, int a2, int a3)
{
  return sub_9560C(a3, (const void *)(*(_DWORD *)(a2 + 8) + 504), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 536));
}

//----- (00090840) --------------------------------------------------------
int __fastcall sub_90840(int a1, int a2, int a3)
{
  int v5; // [sp+14h] [bp-8h]

  v5 = sub_89F54(*(_DWORD **)(dword_AB7AFC + 9280), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292));
  return sub_9560C(a3, (const void *)(v5 + 1029), *(_DWORD *)(v5 + 2056));
}
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (000908B8) --------------------------------------------------------
int __fastcall sub_908B8(int a1, int a2, int a3)
{
  int v5; // [sp+14h] [bp-8h]

  v5 = sub_89F54(*(_DWORD **)(dword_AB7AFC + 9280), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 292));
  return sub_9560C(a3, (const void *)(v5 + 4), *(_DWORD *)(v5 + 2056));
}
// AB7AFC: using guessed type int dword_AB7AFC;

//----- (0009092C) --------------------------------------------------------
int __fastcall sub_9092C(int a1, int a2, int a3)
{
  unsigned __int8 v7; // [sp+1Bh] [bp-11h] BYREF
  int j; // [sp+1Ch] [bp-10h]
  int i; // [sp+20h] [bp-Ch]
  int v10; // [sp+24h] [bp-8h]

  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 312) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 312) == 1 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 296) )
      {
        v10 = sub_9560C(a3, "\n             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F    0123456789ABCDEF", 0x50u);
        if ( !v10 )
        {
          for ( i = 0; ; ++i )
          {
            v10 = sub_9560C(a3, "\n", 1u);
            if ( v10 )
              break;
            v10 = sub_94F90(a3, i + 1, 0xAu);
            if ( v10 )
              break;
            v10 = sub_9560C(a3, "   ", 3u);
            if ( v10 )
              break;
            for ( j = 0; j <= 15; ++j )
            {
              if ( (unsigned int)(16 * i + j) >= *(_DWORD *)(*(_DWORD *)(a2 + 8) + 300) )
              {
                v10 = sub_9560C(a3, "   ", 3u);
                if ( v10 )
                  goto LABEL_35;
              }
              else
              {
                v7 = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 296) + 16 * i + j);
                v10 = sub_95320(a3, v7, 2u);
                if ( v10 )
                  goto LABEL_35;
                v10 = sub_9560C(a3, " ", 1u);
                if ( v10 )
                  goto LABEL_35;
              }
            }
            v10 = sub_9560C(a3, "  ", 2u);
            if ( v10 )
              break;
            for ( j = 0; j <= 15; ++j )
            {
              if ( (unsigned int)(16 * i + j) >= *(_DWORD *)(*(_DWORD *)(a2 + 8) + 300) )
              {
                v10 = sub_9560C(a3, " ", 1u);
                if ( v10 )
                  goto LABEL_35;
              }
              else
              {
                v7 = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 296) + 16 * i + j);
                if ( v7 <= 0x1Fu || v7 > 0x7Eu )
                {
                  v10 = sub_9560C(a3, ".", 1u);
                  if ( v10 )
                    goto LABEL_35;
                }
                else
                {
                  v10 = sub_9560C(a3, &v7, 1u);
                  if ( v10 )
                    goto LABEL_35;
                }
              }
            }
            if ( (unsigned int)(16 * i + j) >= *(_DWORD *)(*(_DWORD *)(a2 + 8) + 300) )
              break;
          }
        }
      }
      else
      {
        v10 = sub_9560C(a3, "buf=(null)", 0xAu);
      }
LABEL_35:
      if ( v10 >= 0 )
      {
        if ( v10 <= 0 )
        {
          return 0;
        }
        else
        {
          sub_93A0C(2, "src/spec.c", 339, "write hex msg, buf is full");
          return 1;
        }
      }
      else
      {
        sub_93A0C(2, "src/spec.c", 336, "write hex msg fail");
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 304) )
  {
    return sub_9495C(a3, *(const char **)(*(_DWORD *)(a2 + 8) + 304), *(void **)(*(_DWORD *)(a2 + 8) + 308));
  }
  else
  {
    return sub_9560C(a3, "format=(null)", 0xDu);
  }
}

//----- (00090D9C) --------------------------------------------------------
int __fastcall sub_90D9C(int a1, int a2)
{
  return (*(int (__fastcall **)(int, int, _DWORD, _DWORD, int, int))(a1 + 9252))(
           a1,
           a2,
           *(_DWORD *)(a2 + 28),
           *(_DWORD *)(a1 + 9252),
           a2,
           a1);
}

//----- (00090DE0) --------------------------------------------------------
int __fastcall sub_90DE0(int a1, int a2)
{
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 4) = **(_DWORD **)(a2 + 24);
  if ( (*(int (__fastcall **)(int, int, _DWORD))(a1 + 9252))(a1, a2, *(_DWORD *)(a2 + 24)) >= 0 )
    return sub_95788(
             *(_DWORD *)(a2 + 28),
             **(const void ***)(a2 + 24),
             *(_DWORD *)(*(_DWORD *)(a2 + 24) + 4) - **(_DWORD **)(a2 + 24),
             *(_DWORD *)(a1 + 9236),
             *(_DWORD *)(a1 + 9240),
             *(_DWORD *)(a1 + 9248),
             *(_DWORD *)(a1 + 9244));
  sub_93A0C(2, "src/spec.c", 366, "a_spec->gen_buf fail");
  return -1;
}

//----- (00090EF4) --------------------------------------------------------
int __fastcall sub_90EF4(int a1, int a2)
{
  return (*(int (__fastcall **)(int, int, _DWORD, _DWORD, int, int))(a1 + 9252))(
           a1,
           a2,
           *(_DWORD *)(a2 + 16),
           *(_DWORD *)(a1 + 9252),
           a2,
           a1);
}

//----- (00090F38) --------------------------------------------------------
int __fastcall sub_90F38(int a1, int a2)
{
  *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) = **(_DWORD **)(a2 + 12);
  if ( (*(int (__fastcall **)(int, int, _DWORD))(a1 + 9252))(a1, a2, *(_DWORD *)(a2 + 12)) >= 0 )
    return sub_95788(
             *(_DWORD *)(a2 + 16),
             **(const void ***)(a2 + 12),
             *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) - **(_DWORD **)(a2 + 12),
             *(_DWORD *)(a1 + 9236),
             *(_DWORD *)(a1 + 9240),
             *(_DWORD *)(a1 + 9248),
             *(_DWORD *)(a1 + 9244));
  sub_93A0C(2, "src/spec.c", 392, "a_spec->gen_buf fail");
  return -1;
}

//----- (0009104C) --------------------------------------------------------
int __fastcall sub_9104C(int a1, int a2)
{
  return (*(int (__fastcall **)(int, int, _DWORD, _DWORD, int, int))(a1 + 9252))(
           a1,
           a2,
           *(_DWORD *)(a2 + 20),
           *(_DWORD *)(a1 + 9252),
           a2,
           a1);
}

//----- (00091090) --------------------------------------------------------
int __fastcall sub_91090(int a1, int a2)
{
  *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) = **(_DWORD **)(a2 + 12);
  if ( (*(int (__fastcall **)(int, int, _DWORD))(a1 + 9252))(a1, a2, *(_DWORD *)(a2 + 12)) >= 0 )
    return sub_95788(
             *(_DWORD *)(a2 + 20),
             **(const void ***)(a2 + 12),
             *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4) - **(_DWORD **)(a2 + 12),
             *(_DWORD *)(a1 + 9236),
             *(_DWORD *)(a1 + 9240),
             *(_DWORD *)(a1 + 9248),
             *(_DWORD *)(a1 + 9244));
  sub_93A0C(2, "src/spec.c", 418, "a_spec->gen_buf fail");
  return -1;
}

//----- (000911A4) --------------------------------------------------------
int __fastcall sub_911A4(int a1)
{
  int v3; // [sp+8h] [bp-14h] BYREF
  int v4; // [sp+Ch] [bp-10h] BYREF
  char *v5; // [sp+10h] [bp-Ch]
  char *s; // [sp+14h] [bp-8h]

  s = (char *)(a1 + 5137);
  if ( *(_BYTE *)(a1 + 5137) == 45 )
  {
    *(_DWORD *)(a1 + 9236) = 1;
    ++s;
  }
  else
  {
    if ( *s == 48 )
      *(_DWORD *)(a1 + 9240) = 1;
    *(_DWORD *)(a1 + 9236) = 0;
  }
  v3 = 0;
  v4 = 0;
  _isoc99_sscanf(s, "%ld.", &v4);
  v5 = strchr(s, 46);
  if ( v5 )
    _isoc99_sscanf(v5, ".%ld", &v3);
  *(_DWORD *)(a1 + 9248) = v4;
  *(_DWORD *)(a1 + 9244) = v3;
  return 0;
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (000912C4) --------------------------------------------------------
void __fastcall sub_912C4(void *a1)
{
  if ( a1 )
  {
    sub_93A0C(0, "src/spec.c", 461, "zlog_spec_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_93A0C(2, "src/spec.c", 460, "a_spec is null or 0");
  }
}

//----- (00091334) --------------------------------------------------------
const char **__fastcall sub_91334(char *a1, char **a2, _DWORD *a3)
{
  int *v4; // r0
  char *v5; // r2
  char *v6; // r2
  char *v7; // r2
  int v12; // [sp+18h] [bp-14h] BYREF
  const char **v13; // [sp+1Ch] [bp-10h]
  int v14; // [sp+20h] [bp-Ch]
  char *s1; // [sp+24h] [bp-8h]

  v14 = 0;
  v12 = 0;
  if ( a1 )
  {
    if ( !a2 )
    {
      sub_93A0C(2, "src/spec.c", 477, "pattern_next is null or 0");
      return 0;
    }
    v13 = (const char **)calloc(1u, 0x2434u);
    if ( !v13 )
    {
      v4 = _errno_location();
      sub_93A0C(2, "src/spec.c", 481, "calloc fail, errno[%d]", *v4);
      return 0;
    }
    s1 = a1;
    *v13 = a1;
    if ( *s1 == 37 )
    {
      v12 = 0;
      v14 = _isoc99_sscanf(s1, "%%%[.0-9-]%n", (char *)v13 + 5137, &v12);
      if ( v14 == 1 )
      {
        v13[2314] = (_BYTE *)sub_90DE0;
        v13[2315] = (_BYTE *)sub_90F38;
        v13[2316] = (_BYTE *)sub_91090;
        if ( sub_911A4((int)v13) )
        {
          sub_93A0C(2, "src/spec.c", 499, "zlog_spec_parse_print_fmt fail");
LABEL_57:
          sub_912C4(v13);
          return 0;
        }
      }
      else
      {
        v12 = 1;
        v13[2314] = (_BYTE *)sub_90D9C;
        v13[2315] = (_BYTE *)sub_90EF4;
        v13[2316] = (_BYTE *)sub_9104C;
      }
      s1 += v12;
      if ( *s1 == 100 )
      {
        if ( s1[1] == 40 )
        {
          if ( !strncmp(s1, "d()", 3u) )
          {
            v6 = (char *)(v13 + 2);
            v13[2] = *(const char **)"%F %T";
            strcpy(v6 + 4, "T");
            s1 += 3;
          }
          else
          {
            v12 = 0;
            v14 = _isoc99_sscanf(s1, "d(%[^)])%n", v13 + 2, &v12);
            if ( v14 != 1 )
              v12 = 0;
            s1 += v12;
            if ( *(s1 - 1) != 41 )
            {
              sub_93A0C(2, "src/spec.c", 529, "in string[%s] can't find match ')'", *v13);
              goto LABEL_57;
            }
          }
        }
        else
        {
          v5 = (char *)(v13 + 2);
          v13[2] = *(const char **)"%F %T";
          strcpy(v5 + 4, "T");
          ++s1;
        }
        v13[1027] = (const char *)(*a3)++;
        v13[2313] = (_BYTE *)sub_90004;
        *a2 = s1;
        v13[1] = (const char *)(s1 - *v13);
      }
      else if ( *s1 == 77 )
      {
        v12 = 0;
        v14 = _isoc99_sscanf(s1, "M(%[^)])%n", v13 + 1028, &v12);
        if ( v14 != 1 )
        {
          v12 = 0;
          if ( !strncmp(s1, "M()", 3u) )
            v12 = 3;
        }
        s1 += v12;
        if ( *(s1 - 1) != 41 )
        {
          sub_93A0C(2, "src/spec.c", 554, "in string[%s] can't find match ')'", *v13);
          goto LABEL_57;
        }
        *a2 = s1;
        v13[1] = (const char *)(s1 - *v13);
        v13[2313] = (_BYTE *)sub_90248;
      }
      else if ( !strncmp(s1, "ms", 2u) )
      {
        s1 += 2;
        *a2 = s1;
        v13[1] = (const char *)(s1 - *v13);
        v13[2313] = (_BYTE *)sub_90150;
      }
      else
      {
        if ( strncmp(s1, "us", 2u) )
        {
          *a2 = s1 + 1;
          v13[1] = (const char *)(s1 - *v13 + 1);
          switch ( *s1 )
          {
            case '%':
              v13[2313] = (_BYTE *)sub_9063C;
              goto LABEL_56;
            case 'D':
              v7 = (char *)(v13 + 2);
              v13[2] = *(const char **)"%F %T";
              strcpy(v7 + 4, "T");
              v13[1027] = (const char *)(*a3)++;
              v13[2313] = (_BYTE *)sub_90004;
              goto LABEL_56;
            case 'F':
              v13[2313] = (_BYTE *)sub_90384;
              goto LABEL_56;
            case 'H':
              v13[2313] = (_BYTE *)sub_905B4;
              goto LABEL_56;
            case 'L':
              v13[2313] = (_BYTE *)sub_904EC;
              goto LABEL_56;
            case 'T':
              v13[2313] = (_BYTE *)sub_907A8;
              goto LABEL_56;
            case 'U':
              v13[2313] = (_BYTE *)sub_90538;
              goto LABEL_56;
            case 'V':
              v13[2313] = (_BYTE *)sub_908B8;
              goto LABEL_56;
            case 'c':
              v13[2313] = (_BYTE *)sub_90338;
              goto LABEL_56;
            case 'f':
              v13[2313] = (_BYTE *)sub_90400;
              goto LABEL_56;
            case 'k':
              v13[2313] = (_BYTE *)sub_907F4;
              goto LABEL_56;
            case 'm':
              v13[2313] = (_BYTE *)sub_9092C;
              goto LABEL_56;
            case 'n':
              v13[2313] = (_BYTE *)sub_90600;
              goto LABEL_56;
            case 'p':
              v13[2313] = (_BYTE *)sub_90678;
              goto LABEL_56;
            case 't':
              v13[2313] = (_BYTE *)sub_9075C;
              goto LABEL_56;
            case 'v':
              v13[2313] = (_BYTE *)sub_90840;
              goto LABEL_56;
            default:
              sub_93A0C(2, "src/spec.c", 634, "str[%s] in wrong format, p[%c]", *v13, (unsigned __int8)*s1);
              goto LABEL_57;
          }
        }
        s1 += 2;
        *a2 = s1;
        v13[1] = (const char *)(s1 - *v13);
        v13[2313] = (_BYTE *)sub_901D8;
      }
    }
    else
    {
      *a2 = strchr(s1, 37);
      if ( *a2 )
      {
        v13[1] = (const char *)(*a2 - s1);
      }
      else
      {
        v13[1] = (const char *)strlen(s1);
        *a2 = (char *)&v13[1][(_DWORD)s1];
      }
      v13[2313] = (_BYTE *)sub_902F4;
      v13[2314] = (_BYTE *)sub_90D9C;
      v13[2315] = (_BYTE *)sub_90EF4;
      v13[2316] = (_BYTE *)sub_9104C;
    }
LABEL_56:
    sub_8FEEC(v13, 0);
    return v13;
  }
  sub_93A0C(2, "src/spec.c", 476, "pattern_start is null or 0");
  return 0;
}
// 9190C: control flows out of bounds to 91910
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 90004: using guessed type int sub_90004();
// 90150: using guessed type int sub_90150();
// 901D8: using guessed type int sub_901D8();
// 90248: using guessed type int sub_90248();
// 902F4: using guessed type int sub_902F4();
// 90338: using guessed type int sub_90338();
// 90384: using guessed type int sub_90384();
// 90400: using guessed type int sub_90400();
// 904EC: using guessed type int sub_904EC();
// 90538: using guessed type int sub_90538();
// 905B4: using guessed type int sub_905B4();
// 90600: using guessed type int sub_90600();
// 9063C: using guessed type int sub_9063C();
// 90678: using guessed type int sub_90678();
// 9075C: using guessed type int sub_9075C();
// 907A8: using guessed type int sub_907A8();
// 907F4: using guessed type int sub_907F4();
// 90840: using guessed type int sub_90840();
// 908B8: using guessed type int sub_908B8();
// 9092C: using guessed type int sub_9092C();
// 90DE0: using guessed type int sub_90DE0();
// 90F38: using guessed type int sub_90F38();
// 91090: using guessed type int sub_91090();

//----- (00091DA4) --------------------------------------------------------
int __fastcall sub_91DA4(int a1, int a2)
{
  if ( !a1 )
    return sub_93A0C(2, "src/thread.c", 20, "a_thread is null or 0");
  sub_93A0C(
    a2,
    "src/thread.c",
    29,
    "--thread[%p][%p][%p][%p,%p,%p,%p,%p]--",
    (const void *)a1,
    *(const void **)(a1 + 4),
    *(const void **)(a1 + 8),
    *(const void **)(a1 + 12),
    *(const void **)(a1 + 16),
    *(const void **)(a1 + 20),
    *(const void **)(a1 + 24),
    *(const void **)(a1 + 28));
  sub_8A128(*(int **)(a1 + 4), a2);
  sub_88F94(*(const char ***)(a1 + 8), a2);
  sub_94328(*(const void ***)(a1 + 12), a2);
  sub_94328(*(const void ***)(a1 + 16), a2);
  sub_94328(*(const void ***)(a1 + 20), a2);
  sub_94328(*(const void ***)(a1 + 24), a2);
  return sub_94328(*(const void ***)(a1 + 28), a2);
}

//----- (00091EF4) --------------------------------------------------------
void __fastcall sub_91EF4(int a1)
{
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      sub_8A21C(*(int **)(a1 + 4));
    if ( *(_DWORD *)(a1 + 8) )
      sub_890C8(*(void ***)(a1 + 8));
    if ( *(_DWORD *)(a1 + 12) )
      sub_943C4(*(void ***)(a1 + 12));
    if ( *(_DWORD *)(a1 + 16) )
      sub_943C4(*(void ***)(a1 + 16));
    if ( *(_DWORD *)(a1 + 20) )
      sub_943C4(*(void ***)(a1 + 20));
    if ( *(_DWORD *)(a1 + 24) )
      sub_943C4(*(void ***)(a1 + 24));
    if ( *(_DWORD *)(a1 + 28) )
      sub_943C4(*(void ***)(a1 + 28));
    sub_93A0C(0, "src/thread.c", 59, "zlog_thread_del[%p]", (const void *)a1);
    free((void *)a1);
  }
  else
  {
    sub_93A0C(2, "src/thread.c", 43, "a_thread is null or 0");
  }
}

//----- (00092048) --------------------------------------------------------
_DWORD *__fastcall sub_92048(int a1, unsigned int a2, unsigned int a3, size_t a4)
{
  int *v4; // r0
  _DWORD *v11; // [sp+1Ch] [bp-8h]

  v11 = calloc(1u, 0x20u);
  if ( v11 )
  {
    *v11 = a1;
    v11[1] = sub_8A3B8();
    if ( v11[1] )
    {
      v11[2] = sub_8915C(a4);
      if ( v11[2] )
      {
        v11[3] = sub_9442C(0x401u, 0x401u, 0);
        if ( v11[3] )
        {
          v11[4] = sub_9442C(0x401u, 0x401u, 0);
          if ( v11[4] )
          {
            v11[5] = sub_9442C(0x401u, 0x401u, 0);
            if ( v11[5] )
            {
              v11[6] = sub_9442C(a2, a3, "...\n");
              if ( v11[6] )
              {
                v11[7] = sub_9442C(a2, a3, "...\n");
                if ( v11[7] )
                  return v11;
                sub_93A0C(2, "src/thread.c", 114, "zlog_buf_new fail");
              }
              else
              {
                sub_93A0C(2, "src/thread.c", 108, "zlog_buf_new fail");
              }
            }
            else
            {
              sub_93A0C(2, "src/thread.c", 102, "zlog_buf_new fail");
            }
          }
          else
          {
            sub_93A0C(2, "src/thread.c", 96, "zlog_buf_new fail");
          }
        }
        else
        {
          sub_93A0C(2, "src/thread.c", 90, "zlog_buf_new fail");
        }
      }
      else
      {
        sub_93A0C(2, "src/thread.c", 84, "zlog_event_new fail");
      }
    }
    else
    {
      sub_93A0C(2, "src/thread.c", 78, "zlog_mdc_new fail");
    }
    sub_91EF4((int)v11);
    return 0;
  }
  v4 = _errno_location();
  sub_93A0C(2, "src/thread.c", 70, "calloc fail, errno[%d]", *v4);
  return 0;
}

//----- (000922EC) --------------------------------------------------------
int __fastcall sub_922EC(int a1, unsigned int a2, unsigned int a3)
{
  void **v8; // [sp+10h] [bp-Ch]
  void *v9; // [sp+14h] [bp-8h]

  if ( a1 )
  {
    if ( a2 == *(_DWORD *)(*(_DWORD *)(a1 + 28) + 16) && a3 == *(_DWORD *)(*(_DWORD *)(a1 + 28) + 20) )
    {
      sub_93A0C(0, "src/thread.c", 135, "buf size not changed, no need rebuild");
      return 0;
    }
    else
    {
      v8 = (void **)sub_9442C(a2, a3, "...\n");
      if ( v8 )
      {
        v9 = sub_9442C(a2, a3, "...\n");
        if ( v9 )
        {
          sub_943C4(*(void ***)(a1 + 24));
          *(_DWORD *)(a1 + 24) = v8;
          sub_943C4(*(void ***)(a1 + 28));
          *(_DWORD *)(a1 + 28) = v9;
          return 0;
        }
        sub_93A0C(2, "src/thread.c", 147, "zlog_buf_new fail");
      }
      else
      {
        sub_93A0C(2, "src/thread.c", 141, "zlog_buf_new fail");
      }
      if ( v8 )
        sub_943C4(v8);
      return -1;
    }
  }
  else
  {
    sub_93A0C(2, "src/thread.c", 131, "a_thread is null or 0");
    return -1;
  }
}
// 9247C: conditional instruction was optimized away because %var_4.4==0

//----- (00092498) --------------------------------------------------------
int __fastcall sub_92498(int a1, size_t a2)
{
  void *v5; // [sp+Ch] [bp-8h]

  if ( a1 )
  {
    v5 = sub_8915C(a2);
    if ( v5 )
    {
      sub_890C8(*(void ***)(a1 + 8));
      *(_DWORD *)(a1 + 8) = v5;
      return 0;
    }
    else
    {
      sub_93A0C(2, "src/thread.c", 171, "zlog_event_new fail");
      return -1;
    }
  }
  else
  {
    sub_93A0C(2, "src/thread.c", 167, "a_thread is null or 0", a2);
    return -1;
  }
}
// 92524: conditional instruction was optimized away because %var_4.4==0

//----- (00092568) --------------------------------------------------------
_DWORD *__fastcall sub_92568(int a1)
{
  int *v1; // r0
  int *v3; // r0
  _DWORD *ptr; // [sp+14h] [bp-8h]

  ptr = calloc(1u, 0x10u);
  if ( ptr )
  {
    ptr[2] = 32;
    ptr[1] = 0;
    ptr[3] = a1;
    *ptr = calloc(ptr[2], 4u);
    if ( *ptr )
    {
      return ptr;
    }
    else
    {
      v3 = _errno_location();
      sub_93A0C(2, "src/zc_arraylist.c", 32, "calloc fail, errno[%d]", *v3);
      free(ptr);
      return 0;
    }
  }
  else
  {
    v1 = _errno_location();
    sub_93A0C(2, "src/zc_arraylist.c", 22, "calloc fail, errno[%d]", *v1);
    return 0;
  }
}

//----- (00092670) --------------------------------------------------------
void __fastcall sub_92670(int a1)
{
  int i; // [sp+Ch] [bp-8h]

  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
      {
        if ( *(_DWORD *)(*(_DWORD *)a1 + 4 * i) )
          (*(void (__fastcall **)(_DWORD))(a1 + 12))(*(_DWORD *)(*(_DWORD *)a1 + 4 * i));
      }
    }
    if ( *(_DWORD *)a1 )
      free(*(void **)a1);
    free((void *)a1);
  }
}

//----- (0009274C) --------------------------------------------------------
int __fastcall sub_9274C(int a1, int a2)
{
  int v2; // r3
  int *v3; // r0
  int v7; // [sp+14h] [bp-10h]
  void *v8; // [sp+18h] [bp-Ch]
  int v9; // [sp+1Ch] [bp-8h]

  v2 = 2 * *(_DWORD *)(a1 + 8);
  if ( a2 >= v2 )
    v2 = a2;
  v9 = v2;
  v8 = realloc(*(void **)a1, 4 * v2);
  if ( v8 )
  {
    *(_DWORD *)a1 = v8;
    v7 = v9 - *(_DWORD *)(a1 + 8);
    if ( v7 )
      memset((void *)(*(_DWORD *)a1 + 4 * *(_DWORD *)(a1 + 8)), 0, 4 * v7);
    *(_DWORD *)(a1 + 8) = v9;
    return 0;
  }
  else
  {
    v3 = _errno_location();
    sub_93A0C(2, "src/zc_arraylist.c", 67, "realloc fail, errno[%d]", *v3);
    return -1;
  }
}

//----- (00092854) --------------------------------------------------------
int __fastcall sub_92854(int a1, int a2, int a3)
{
  if ( a2 > *(_DWORD *)(a1 + 8) - 1 && sub_9274C(a1, a2) )
  {
    sub_93A0C(2, "src/zc_arraylist.c", 81, "expand_internal fail");
    return -1;
  }
  else
  {
    if ( *(_DWORD *)(*(_DWORD *)a1 + 4 * a2) && *(_DWORD *)(a1 + 12) )
      (*(void (__fastcall **)(_DWORD))(a1 + 12))(*(_DWORD *)(*(_DWORD *)a1 + 4 * a2));
    *(_DWORD *)(*(_DWORD *)a1 + 4 * a2) = a3;
    if ( a2 >= *(_DWORD *)(a1 + 4) )
      *(_DWORD *)(a1 + 4) = a2 + 1;
    return 0;
  }
}

//----- (00092968) --------------------------------------------------------
int __fastcall sub_92968(int a1, int a2)
{
  return sub_92854(a1, *(_DWORD *)(a1 + 4), a2);
}

//----- (000929A4) --------------------------------------------------------
int __fastcall sub_929A4(_DWORD *a1, int a2, int a3)
{
  if ( *(_DWORD *)(*a1 + 4 * a2) )
  {
    if ( a1[1] > a1[2] - 1 && sub_9274C((int)a1, 0) )
    {
      sub_93A0C(2, "src/zc_arraylist.c", 107, "expand_internal fail");
      return -1;
    }
    else
    {
      memmove((void *)(*a1 + 4 * (a2 + 1)), (const void *)(*a1 + 4 * a2), 4 * (a1[1] - a2));
      *(_DWORD *)(*a1 + 4 * a2) = a3;
      ++a1[1];
      return 0;
    }
  }
  else
  {
    *(_DWORD *)(*a1 + 4 * a2) = a3;
    return 0;
  }
}

//----- (00092AE0) --------------------------------------------------------
int __fastcall sub_92AE0(_DWORD *a1, int (__fastcall *a2)(_DWORD, int), int a3)
{
  int i; // [sp+14h] [bp-8h]

  for ( i = 0; i < a1[1] && a2(*(_DWORD *)(*a1 + 4 * i), a3) <= 0; ++i )
    ;
  if ( i == a1[1] )
    return sub_92968((int)a1, a3);
  else
    return sub_929A4(a1, i, a3);
}

//----- (00092BA8) --------------------------------------------------------
_DWORD *__fastcall sub_92BA8(size_t a1, int a2, int a3, int a4, int a5)
{
  int *v5; // r0
  int *v7; // r0
  _DWORD *ptr; // [sp+1Ch] [bp-8h]

  ptr = calloc(1u, 0x1Cu);
  if ( ptr )
  {
    ptr[1] = calloc(a1, 4u);
    if ( ptr[1] )
    {
      ptr[2] = a1;
      *ptr = 0;
      ptr[3] = a2;
      ptr[4] = a3;
      ptr[5] = a4;
      ptr[6] = a5;
      return ptr;
    }
    else
    {
      v7 = _errno_location();
      sub_93A0C(2, "src/zc_hashtable.c", 44, "calloc fail, errno[%d]", *v7);
      free(ptr);
      return 0;
    }
  }
  else
  {
    v5 = _errno_location();
    sub_93A0C(2, "src/zc_hashtable.c", 38, "calloc fail, errno[%d]", *v5);
    return 0;
  }
}

//----- (00092CD8) --------------------------------------------------------
void __fastcall sub_92CD8(int a1)
{
  _DWORD *v2; // [sp+14h] [bp-10h]
  _DWORD *ptr; // [sp+18h] [bp-Ch]
  unsigned int i; // [sp+1Ch] [bp-8h]

  if ( a1 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
    {
      for ( ptr = *(_DWORD **)(*(_DWORD *)(a1 + 4) + 4 * i); ptr; ptr = v2 )
      {
        v2 = (_DWORD *)ptr[4];
        if ( *(_DWORD *)(a1 + 20) )
          (*(void (__fastcall **)(_DWORD))(a1 + 20))(ptr[1]);
        if ( *(_DWORD *)(a1 + 24) )
          (*(void (__fastcall **)(_DWORD))(a1 + 24))(ptr[2]);
        free(ptr);
      }
    }
    if ( *(_DWORD *)(a1 + 4) )
      free(*(void **)(a1 + 4));
    free((void *)a1);
  }
  else
  {
    sub_93A0C(2, "src/zc_hashtable.c", 68, "a_table[%p] is NULL, just do nothing", 0);
  }
}

//----- (00092E14) --------------------------------------------------------
void __fastcall sub_92E14(int a1)
{
  _DWORD *v2; // [sp+Ch] [bp-10h]
  _DWORD *ptr; // [sp+10h] [bp-Ch]
  unsigned int i; // [sp+14h] [bp-8h]

  for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
  {
    for ( ptr = *(_DWORD **)(*(_DWORD *)(a1 + 4) + 4 * i); ptr; ptr = v2 )
    {
      v2 = (_DWORD *)ptr[4];
      if ( *(_DWORD *)(a1 + 20) )
        (*(void (__fastcall **)(_DWORD))(a1 + 20))(ptr[1]);
      if ( *(_DWORD *)(a1 + 24) )
        (*(void (__fastcall **)(_DWORD))(a1 + 24))(ptr[2]);
      free(ptr);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i) = 0;
  }
  *(_DWORD *)a1 = 0;
}

//----- (00092F1C) --------------------------------------------------------
int __fastcall sub_92F1C(int a1)
{
  int *v1; // r0
  int v3; // r1
  unsigned int *v6; // [sp+14h] [bp-18h]
  _DWORD *v7; // [sp+18h] [bp-14h]
  int nmemb; // [sp+1Ch] [bp-10h]
  unsigned int *j; // [sp+20h] [bp-Ch]
  unsigned int i; // [sp+24h] [bp-8h]

  nmemb = 2 * *(_DWORD *)(a1 + 8);
  v7 = calloc(nmemb, 4u);
  if ( v7 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
    {
      for ( j = *(unsigned int **)(*(_DWORD *)(a1 + 4) + 4 * i); j; j = v6 )
      {
        v6 = (unsigned int *)j[4];
        j[4] = 0;
        j[3] = 0;
        sub_964FC(*j, nmemb);
        if ( v7[v3] )
        {
          *(_DWORD *)(v7[v3] + 12) = j;
          j[4] = v7[v3];
        }
        v7[v3] = j;
      }
    }
    free(*(void **)(a1 + 4));
    *(_DWORD *)(a1 + 4) = v7;
    *(_DWORD *)(a1 + 8) = nmemb;
    return 0;
  }
  else
  {
    v1 = _errno_location();
    sub_93A0C(2, "src/zc_hashtable.c", 126, "calloc fail, errno[%d]", *v1);
    return -1;
  }
}
// 93000: variable 'v3' is possibly undefined

//----- (000930D4) --------------------------------------------------------
int __fastcall sub_930D4(int a1, int a2)
{
  unsigned int v2; // r0
  int v3; // r1
  int i; // [sp+Ch] [bp-8h]

  v2 = (*(int (__fastcall **)(int))(a1 + 12))(a2);
  sub_964FC(v2, *(_DWORD *)(a1 + 8));
  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v3); i; i = *(_DWORD *)(i + 16) )
  {
    if ( (*(int (__fastcall **)(int, _DWORD))(a1 + 16))(a2, *(_DWORD *)(i + 4)) )
      return i;
  }
  return 0;
}
// 93124: variable 'v3' is possibly undefined

//----- (00093190) --------------------------------------------------------
int __fastcall sub_93190(int a1, int a2)
{
  unsigned int v2; // r0
  int v3; // r1
  _DWORD *i; // [sp+Ch] [bp-8h]

  v2 = (*(int (__fastcall **)(int))(a1 + 12))(a2);
  sub_964FC(v2, *(_DWORD *)(a1 + 8));
  for ( i = *(_DWORD **)(*(_DWORD *)(a1 + 4) + 4 * v3); i; i = (_DWORD *)i[4] )
  {
    if ( (*(int (__fastcall **)(int, _DWORD))(a1 + 16))(a2, i[1]) )
      return i[2];
  }
  return 0;
}
// 931E0: variable 'v3' is possibly undefined

//----- (00093250) --------------------------------------------------------
int __fastcall sub_93250(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // r0
  int v4; // r1
  int *v6; // r0
  int v7; // r1
  _DWORD *i; // [sp+24h] [bp-8h]
  unsigned int *v13; // [sp+24h] [bp-8h]

  v3 = (*(int (__fastcall **)(unsigned int))(a1 + 12))(a2);
  sub_964FC(v3, *(_DWORD *)(a1 + 8));
  for ( i = *(_DWORD **)(*(_DWORD *)(a1 + 4) + 4 * v4);
        i && !(*(int (__fastcall **)(unsigned int, _DWORD))(a1 + 16))(a2, i[1]);
        i = (_DWORD *)i[4] )
  {
    ;
  }
  if ( i )
  {
    if ( *(_DWORD *)(a1 + 20) )
      (*(void (__fastcall **)(_DWORD))(a1 + 20))(i[1]);
    if ( *(_DWORD *)(a1 + 24) )
      (*(void (__fastcall **)(_DWORD))(a1 + 24))(i[2]);
    i[1] = a2;
    i[2] = a3;
    return 0;
  }
  else if ( (double)*(unsigned int *)a1 > (double)*(unsigned int *)(a1 + 8) * 1.3 && sub_92F1C(a1) )
  {
    sub_93A0C(2, "src/zc_hashtable.c", 205, "rehash fail");
    return -1;
  }
  else
  {
    v13 = (unsigned int *)calloc(1u, 0x14u);
    if ( v13 )
    {
      *v13 = (*(int (__fastcall **)(unsigned int))(a1 + 12))(a2);
      v13[1] = a2;
      v13[2] = a3;
      v13[4] = 0;
      v13[3] = 0;
      sub_964FC(*v13, *(_DWORD *)(a1 + 8));
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v7) )
      {
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v7) + 12) = v13;
        v13[4] = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v7);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v7) = v13;
      ++*(_DWORD *)a1;
      return 0;
    }
    else
    {
      v6 = _errno_location();
      sub_93A0C(2, "src/zc_hashtable.c", 212, "calloc fail, errno[%d]", *v6);
      return -1;
    }
  }
}
// 932B4: variable 'v4' is possibly undefined
// 934CC: variable 'v7' is possibly undefined

//----- (00093568) --------------------------------------------------------
void __fastcall sub_93568(const void *a1, const void *a2)
{
  unsigned int v2; // r0
  int v3; // r1
  int v4; // r1
  unsigned int *ptr; // [sp+1Ch] [bp-8h]

  if ( a1 && a2 )
  {
    v2 = (*((int (__fastcall **)(const void *))a1 + 3))(a2);
    sub_964FC(v2, *((_DWORD *)a1 + 2));
    for ( ptr = *(unsigned int **)(*((_DWORD *)a1 + 1) + 4 * v3);
          ptr && !(*((int (__fastcall **)(const void *, unsigned int))a1 + 4))(a2, ptr[1]);
          ptr = (unsigned int *)ptr[4] )
    {
      ;
    }
    if ( ptr )
    {
      if ( *((_DWORD *)a1 + 5) )
        (*((void (__fastcall **)(unsigned int))a1 + 5))(ptr[1]);
      if ( *((_DWORD *)a1 + 6) )
        (*((void (__fastcall **)(unsigned int))a1 + 6))(ptr[2]);
      if ( ptr[4] )
        *(_DWORD *)(ptr[4] + 12) = ptr[3];
      if ( ptr[3] )
      {
        *(_DWORD *)(ptr[3] + 16) = ptr[4];
      }
      else
      {
        sub_964FC(*ptr, *((_DWORD *)a1 + 2));
        *(_DWORD *)(*((_DWORD *)a1 + 1) + 4 * v4) = ptr[4];
      }
      free(ptr);
      --*(_DWORD *)a1;
    }
    else
    {
      sub_93A0C(2, "src/zc_hashtable.c", 251, "p[%p] not found in hashtable", 0);
    }
  }
  else
  {
    sub_93A0C(2, "src/zc_hashtable.c", 240, "a_table[%p] or a_key[%p] is NULL, just do nothing", a1, a2);
  }
}
// 93600: variable 'v3' is possibly undefined
// 9375C: variable 'v4' is possibly undefined

//----- (00093798) --------------------------------------------------------
int __fastcall sub_93798(int a1)
{
  unsigned int i; // [sp+Ch] [bp-8h]

  for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i) )
      return *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i);
  }
  return 0;
}

//----- (00093834) --------------------------------------------------------
unsigned int __fastcall sub_93834(int a1, unsigned int *a2)
{
  int v3; // r1
  unsigned int i; // [sp+Ch] [bp-8h]

  if ( a2[4] )
    return a2[4];
  sub_964FC(*a2, *(_DWORD *)(a1 + 8));
  for ( i = v3 + 1; i < *(_DWORD *)(a1 + 8); ++i )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i) )
      return *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i);
  }
  return 0;
}
// 93890: variable 'v3' is possibly undefined

//----- (00093904) --------------------------------------------------------
int __fastcall sub_93904(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // r3
  int v4; // [sp+Ch] [bp-8h]

  v4 = 5381;
  while ( *a1 )
  {
    v1 = a1++;
    v4 = 33 * v4 + *v1;
  }
  return v4;
}

//----- (00093974) --------------------------------------------------------
bool __fastcall sub_93974(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

//----- (000939B4) --------------------------------------------------------
size_t __fastcall sub_939B4(char *a1, size_t a2)
{
  struct tm tp; // [sp+8h] [bp-34h] BYREF
  time_t timer; // [sp+34h] [bp-8h] BYREF

  time(&timer);
  localtime_r(&timer, &tp);
  return strftime(a1, a2, "%m-%d %T", &tp);
}

//----- (00093A0C) --------------------------------------------------------
int sub_93A0C(int a1, const char *a2, int a3, const char *a4, ...)
{
  __pid_t v5; // r0
  __pid_t v6; // r0
  __pid_t v7; // r0
  char v12[24]; // [sp+18h] [bp-28h] BYREF
  __gnuc_va_list arg; // [sp+30h] [bp-10h]
  FILE *stream; // [sp+34h] [bp-Ch]
  const char *varg_r3; // [sp+44h] [bp+4h]
  va_list va; // [sp+48h] [bp+8h] BYREF

  va_start(va, a4);
  varg_r3 = a4;
  stream = 0;
  if ( !dword_65A540 )
  {
    dword_65A540 = 1;
    dword_65A544 = (int)getenv("ZLOG_PROFILE_DEBUG");
    dword_65A548 = (int)getenv("ZLOG_PROFILE_ERROR");
  }
  if ( a1 == 1 )
  {
    if ( !dword_65A548 )
      return 0;
    stream = (FILE *)fopen64(dword_65A548, "a");
    if ( !stream )
      return -1;
    sub_939B4(v12, 0x15u);
    v6 = getpid();
    fprintf(stream, "%s WARN  (%d:%s:%ld) ", v12, v6, a2, a3);
    goto LABEL_21;
  }
  if ( a1 == 2 )
  {
    if ( !dword_65A548 )
      return 0;
    stream = (FILE *)fopen64(dword_65A548, "a");
    if ( !stream )
      return -1;
    sub_939B4(v12, 0x15u);
    v7 = getpid();
    fprintf(stream, "%s ERROR (%d:%s:%ld) ", v12, v7, a2, a3);
    goto LABEL_21;
  }
  if ( a1 )
    goto LABEL_21;
  if ( dword_65A544 )
  {
    stream = (FILE *)fopen64(dword_65A544, "a");
    if ( !stream )
      return -1;
    sub_939B4(v12, 0x15u);
    v5 = getpid();
    fprintf(stream, "%s DEBUG (%d:%s:%ld) ", v12, v5, a2, a3);
LABEL_21:
    va_copy(arg, va);
    vfprintf(stream, varg_r3, va);
    fputc(10, stream);
    fclose(stream);
    return 0;
  }
  return 0;
}
// 1292C: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 65A540: using guessed type int dword_65A540;
// 65A544: using guessed type int dword_65A544;
// 65A548: using guessed type int dword_65A548;

//----- (00093CA8) --------------------------------------------------------
int __fastcall sub_93CA8(const char *a1)
{
  size_t v4; // [sp+10h] [bp-1Ch]
  int v5; // [sp+14h] [bp-18h]
  int v6; // [sp+18h] [bp-14h]
  int v7; // [sp+1Ch] [bp-10h]
  char *v8; // [sp+20h] [bp-Ch]
  const char *i; // [sp+24h] [bp-8h]

  if ( a1 )
  {
    v8 = (char *)a1;
    for ( i = a1; *i; ++i )
    {
      if ( ((*_ctype_b_loc())[*(unsigned __int8 *)i] & 0x2000) == 0 )
        *v8++ = *i;
    }
    *v8 = 0;
    v4 = strlen(a1);
    v7 = strtol(a1, 0, 10);
    if ( v7 > 0 )
    {
      if ( a1[v4 - 1] == 66 || a1[v4 - 1] == 98 )
      {
        v6 = (unsigned __int8)a1[v4 - 2];
        v5 = 1024;
      }
      else
      {
        v6 = (unsigned __int8)a1[v4 - 1];
        v5 = 1000;
      }
      switch ( v6 )
      {
        case 'G':
        case 'g':
          v7 *= v5 * v5 * v5;
          break;
        case 'K':
        case 'k':
          v7 *= v5;
          break;
        case 'M':
        case 'm':
          v7 *= v5 * v5;
          break;
        default:
          if ( ((*_ctype_b_loc())[v6] & 0x800) == 0 )
            sub_93A0C(2, "src/zc_util.c", 70, "Wrong suffix parsing size in bytes for string [%s], ignoring suffix", a1);
          break;
      }
      return v7;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_93A0C(2, "src/zc_util.c", 27, "astring is null or 0");
    return 0;
  }
}
// 93E34: control flows out of bounds to 93E38

//----- (00093F88) --------------------------------------------------------
int __fastcall sub_93F88(char *a1, int a2)
{
  char *v3; // r0
  int *v4; // r0
  size_t v5; // r0
  int v9; // [sp+14h] [bp-3030h] BYREF
  char v10[4100]; // [sp+18h] [bp-302Ch] BYREF
  char v11[4100]; // [sp+101Ch] [bp-2028h] BYREF
  char v12[4100]; // [sp+2020h] [bp-1024h] BYREF
  size_t n; // [sp+3024h] [bp-20h]
  int v14; // [sp+3028h] [bp-1Ch]
  void *dest; // [sp+302Ch] [bp-18h]
  size_t v16; // [sp+3030h] [bp-14h]
  char *s; // [sp+3034h] [bp-10h]

  v16 = strlen(a1);
  s = a1;
  while ( 1 )
  {
    dest = strchr(s, 37);
    if ( !dest )
      break;
    memset(v12, 0, 0x1001u);
    memset(v11, 0, 0x1001u);
    memset(v10, 0, 0x1001u);
    v9 = 0;
    v14 = _isoc99_sscanf((char *)dest + 1, "%[.0-9-]%n", &v12[1], &v9);
    if ( v14 == 1 )
    {
      v12[0] = 37;
      v12[v9 + 1] = 115;
    }
    else
    {
      v9 = 0;
      strcpy(v12, "%s");
    }
    s = (char *)dest + v9 + 1;
    v14 = _isoc99_sscanf(s, "E(%[^)])%n", v11, &v9);
    if ( v14 )
    {
      s += v9;
      if ( *(s - 1) != 41 )
      {
        sub_93A0C(2, "src/zc_util.c", 124, "in string[%s] can't find match )", (const char *)dest);
        return -1;
      }
      v3 = getenv(v11);
      n = snprintf(v10, 0x1001u, v12, v3);
      if ( n > 0x1000 )
      {
        v4 = _errno_location();
        sub_93A0C(2, "src/zc_util.c", 131, "snprintf fail, errno[%d], evn_value_len[%d]", *v4, n);
        return -1;
      }
      v16 = n + v16 - (s - (_BYTE *)dest);
      if ( a2 - 1 < v16 )
      {
        sub_93A0C(2, "src/zc_util.c", 137, "repalce env_value[%s] cause overlap", v10);
        return -1;
      }
      v5 = strlen(s);
      memmove((char *)dest + n, s, v5 + 1);
      memcpy(dest, v10, n);
    }
  }
  return 0;
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (00094328) --------------------------------------------------------
int __fastcall sub_94328(const void **a1, int a2)
{
  return sub_93A0C(
           a2,
           "src/buf.c",
           74,
           "---buf[%p][%ld-%ld][%ld][%s][%p:%ld]---",
           a1,
           a1[4],
           a1[5],
           a1[6],
           (const char *)a1 + 28,
           *a1,
           (_BYTE *)a1[1] - (_BYTE *)*a1);
}

//----- (000943C4) --------------------------------------------------------
void __fastcall sub_943C4(void **a1)
{
  if ( *a1 )
    free(*a1);
  sub_93A0C(0, "src/buf.c", 82, "zlog_buf_del[%p]", a1);
  free(a1);
}

//----- (0009442C) --------------------------------------------------------
void *__fastcall sub_9442C(unsigned int a1, unsigned int a2, const char *a3)
{
  int *v4; // r0
  int *v5; // r0
  void *v10; // [sp+1Ch] [bp-8h]

  if ( a1 )
  {
    if ( a2 && a2 < a1 )
    {
      sub_93A0C(2, "src/buf.c", 98, "buf_size_max[%lu] < buf_size_min[%lu] && buf_size_max != 0", a2, a1);
      return 0;
    }
    v10 = calloc(1u, 0x424u);
    if ( !v10 )
    {
      v4 = _errno_location();
      sub_93A0C(2, "src/buf.c", 104, "calloc fail, errno[%d]", *v4);
      return 0;
    }
    if ( a3 )
    {
      if ( strlen(a3) > 0x400 )
      {
        sub_93A0C(2, "src/buf.c", 110, "truncate_str[%s] overflow", a3);
        goto LABEL_15;
      }
      strcpy((char *)v10 + 28, a3);
      *((_DWORD *)v10 + 264) = strlen(a3);
    }
    *((_DWORD *)v10 + 4) = a1;
    *((_DWORD *)v10 + 5) = a2;
    *((_DWORD *)v10 + 6) = *((_DWORD *)v10 + 4);
    *(_DWORD *)v10 = calloc(1u, *((_DWORD *)v10 + 6));
    if ( *(_DWORD *)v10 )
    {
      *((_DWORD *)v10 + 1) = *(_DWORD *)v10;
      *((_DWORD *)v10 + 3) = *(_DWORD *)v10 + *((_DWORD *)v10 + 6);
      *((_DWORD *)v10 + 2) = *((_DWORD *)v10 + 3) - 1;
      return v10;
    }
    v5 = _errno_location();
    sub_93A0C(2, "src/buf.c", 124, "calloc fail, errno[%d]", *v5);
LABEL_15:
    sub_943C4((void **)v10);
    return 0;
  }
  sub_93A0C(2, "src/buf.c", 92, "buf_size_min == 0, not allowed");
  return 0;
}

//----- (00094674) --------------------------------------------------------
_DWORD *__fastcall sub_94674(_DWORD *result)
{
  void *dest; // [sp+Ch] [bp-8h]

  if ( *((_BYTE *)result + 28) )
  {
    dest = (void *)(result[1] - result[264]);
    if ( (unsigned int)dest < *result )
      dest = (void *)*result;
    return memcpy(dest, result + 7, result[1] - (_DWORD)dest);
  }
  return result;
}

//----- (00094714) --------------------------------------------------------
int __fastcall sub_94714(int a1, unsigned int a2)
{
  int *v3; // r0
  char *v6; // [sp+10h] [bp-14h]
  int v7; // [sp+14h] [bp-10h]
  unsigned int size; // [sp+18h] [bp-Ch]
  int v9; // [sp+1Ch] [bp-8h]

  v9 = 0;
  if ( *(_DWORD *)(a1 + 20) && *(_DWORD *)(a1 + 24) >= *(_DWORD *)(a1 + 20) )
  {
    sub_93A0C(
      2,
      "src/buf.c",
      169,
      "a_buf->size_real[%ld] >= a_buf->size_max[%ld]",
      *(_DWORD *)(a1 + 24),
      *(_DWORD *)(a1 + 20));
    return 1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 20) )
    {
      if ( *(_DWORD *)(a1 + 24) + a2 > *(_DWORD *)(a1 + 20) )
      {
        size = *(_DWORD *)(a1 + 20);
        v9 = 1;
      }
      else
      {
        size = a2 + *(_DWORD *)(a1 + 24);
      }
    }
    else
    {
      size = (unsigned int)((double)*(unsigned int *)(a1 + 24) + (double)a2 * 1.5);
    }
    v7 = *(_DWORD *)(a1 + 4) - *(_DWORD *)a1;
    v6 = (char *)realloc(*(void **)a1, size);
    if ( v6 )
    {
      *(_DWORD *)a1 = v6;
      *(_DWORD *)(a1 + 4) = &v6[v7];
      *(_DWORD *)(a1 + 24) = size;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)a1 + size;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12) - 1;
      return v9;
    }
    else
    {
      v3 = _errno_location();
      sub_93A0C(2, "src/buf.c", 189, "realloc fail, errno[%d]", *v3);
      free(*(void **)a1);
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      return -1;
    }
  }
}

//----- (0009495C) --------------------------------------------------------
int __fastcall sub_9495C(int a1, const char *a2, void *a3)
{
  int *v4; // r0
  int *v5; // r0
  int v10; // [sp+24h] [bp-10h]
  int v11; // [sp+28h] [bp-Ch]
  int v12; // [sp+28h] [bp-Ch]
  unsigned int maxlen; // [sp+2Ch] [bp-8h]
  int maxlenb; // [sp+2Ch] [bp-8h]
  int maxlena; // [sp+2Ch] [bp-8h]

  if ( *(_DWORD *)a1 )
  {
    maxlen = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
    v11 = vsnprintf(*(char **)(a1 + 4), maxlen, a2, a3);
    if ( v11 < 0 || maxlen <= v11 )
    {
      if ( v11 >= 0 )
      {
        if ( maxlen > v11 )
        {
          return 0;
        }
        else
        {
          v10 = sub_94714(a1, v11 - maxlen + 1);
          if ( v10 <= 0 )
          {
            if ( v10 >= 0 )
            {
              maxlena = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
              v12 = vsnprintf(*(char **)(a1 + 4), maxlena, a2, a3);
              if ( v12 >= 0 )
              {
                *(_DWORD *)(a1 + 4) += v12;
                return 0;
              }
              else
              {
                v5 = _errno_location();
                sub_93A0C(2, "src/buf.c", 252, "vsnprintf fail, errno[%d]", *v5);
                sub_93A0C(2, "src/buf.c", 253, "nwrite[%d], size_left[%ld], format[%s]", v12, maxlena, a2);
                return -1;
              }
            }
            else
            {
              sub_93A0C(2, "src/buf.c", 243, "zlog_buf_resize fail");
              return -1;
            }
          }
          else
          {
            sub_93A0C(2, "src/buf.c", 234, "conf limit to %ld, can't extend, so truncate", *(_DWORD *)(a1 + 20));
            maxlenb = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
            vsnprintf(*(char **)(a1 + 4), maxlenb, a2, a3);
            *(_DWORD *)(a1 + 4) += maxlenb - 1;
            sub_94674((_DWORD *)a1);
            return 1;
          }
        }
      }
      else
      {
        v4 = _errno_location();
        sub_93A0C(2, "src/buf.c", 226, "vsnprintf fail, errno[%d]", *v4);
        sub_93A0C(2, "src/buf.c", 227, "nwrite[%d], size_left[%ld], format[%s]", v11, maxlen, a2);
        return -1;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) += v11;
      return 0;
    }
  }
  else
  {
    sub_93A0C(2, "src/buf.c", 214, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
}

//----- (00094C78) --------------------------------------------------------
int __fastcall sub_94C78(int a1, unsigned int a2, unsigned int a3)
{
  char v7; // [sp+23h] [bp-21h] BYREF
  size_t v8; // [sp+24h] [bp-20h]
  int v9; // [sp+28h] [bp-1Ch]
  size_t v10; // [sp+2Ch] [bp-18h]
  size_t n; // [sp+30h] [bp-14h]
  size_t v12; // [sp+34h] [bp-10h]
  size_t v13; // [sp+38h] [bp-Ch]
  void *src; // [sp+3Ch] [bp-8h]

  if ( !*(_DWORD *)a1 )
  {
    sub_93A0C(2, "src/buf.c", 276, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  src = &v7;
  do
  {
    src = (char *)src - 1;
    *(_BYTE *)src = a2 % 0xA + 48;
    a2 /= 0xAu;
  }
  while ( a2 );
  v12 = &v7 - (_BYTE *)src;
  if ( &v7 - (_BYTE *)src >= a3 )
  {
    n = 0;
    v10 = v12;
  }
  else
  {
    n = a3 - v12;
    v10 = a3;
  }
  v13 = *(_DWORD *)(a1 + 4) + v10;
  if ( v13 > *(_DWORD *)(a1 + 8) )
  {
    v9 = sub_94714(a1, v10 - (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4)));
    if ( v9 > 0 )
    {
      sub_93A0C(2, "src/buf.c", 302, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
      v8 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
      if ( v8 > n )
      {
        v12 = v8 - n;
      }
      else
      {
        n = v8;
        v12 = 0;
      }
      if ( n )
        memset(*(void **)(a1 + 4), 48, n);
      memcpy((void *)(*(_DWORD *)(a1 + 4) + n), src, v12);
      *(_DWORD *)(a1 + 4) += v8;
      sub_94674((_DWORD *)a1);
      return 1;
    }
    if ( v9 < 0 )
    {
      sub_93A0C(2, "src/buf.c", 318, "zlog_buf_resize fail");
      return -1;
    }
    v13 = *(_DWORD *)(a1 + 4) + v10;
  }
  if ( n )
    memset(*(void **)(a1 + 4), 48, n);
  memcpy((void *)(*(_DWORD *)(a1 + 4) + n), src, v12);
  *(_DWORD *)(a1 + 4) = v13;
  return 0;
}

//----- (00094F90) --------------------------------------------------------
int __fastcall sub_94F90(int a1, unsigned __int64 a2, unsigned int a3)
{
  bool v5; // cc
  char v6; // r2
  unsigned __int64 v7; // r0
  unsigned __int64 v9; // [sp+8h] [bp-4Ch]
  int v11; // [sp+2Ch] [bp-28h] BYREF
  size_t v12; // [sp+30h] [bp-24h]
  int v13; // [sp+34h] [bp-20h]
  unsigned int v14; // [sp+38h] [bp-1Ch]
  size_t v15; // [sp+3Ch] [bp-18h]
  size_t n; // [sp+40h] [bp-14h]
  size_t v17; // [sp+44h] [bp-10h]
  size_t v18; // [sp+48h] [bp-Ch]
  void *src; // [sp+4Ch] [bp-8h]

  v9 = a2;
  if ( !*(_DWORD *)a1 )
  {
    sub_93A0C(2, "src/buf.c", 342, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  src = &v11;
  v5 = HIDWORD(a2) != 0;
  if ( !HIDWORD(a2) )
    v5 = 0;
  if ( v5 )
  {
    do
    {
      sub_96DFC(v9, 0xAu);
      src = (char *)src - 1;
      *(_BYTE *)src = v6 + 48;
      LODWORD(v7) = sub_96DFC(v9, 0xAu);
      v9 = v7;
    }
    while ( v7 );
  }
  else
  {
    v14 = a2;
    do
    {
      src = (char *)src - 1;
      *(_BYTE *)src = v14 % 0xA + 48;
      v14 /= 0xAu;
    }
    while ( v14 );
  }
  v17 = (char *)&v11 - (_BYTE *)src;
  if ( (char *)&v11 - (_BYTE *)src >= a3 )
  {
    n = 0;
    v15 = v17;
  }
  else
  {
    n = a3 - v17;
    v15 = a3;
  }
  v18 = *(_DWORD *)(a1 + 4) + v15;
  if ( v18 > *(_DWORD *)(a1 + 8) )
  {
    v13 = sub_94714(a1, v15 - (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4)));
    if ( v13 > 0 )
    {
      sub_93A0C(2, "src/buf.c", 393, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
      v12 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
      if ( v12 > n )
      {
        v17 = v12 - n;
      }
      else
      {
        n = v12;
        v17 = 0;
      }
      if ( n )
        memset(*(void **)(a1 + 4), 48, n);
      memcpy((void *)(*(_DWORD *)(a1 + 4) + n), src, v17);
      *(_DWORD *)(a1 + 4) += v12;
      sub_94674((_DWORD *)a1);
      return 1;
    }
    if ( v13 < 0 )
    {
      sub_93A0C(2, "src/buf.c", 409, "zlog_buf_resize fail");
      return -1;
    }
    v18 = *(_DWORD *)(a1 + 4) + v15;
  }
  if ( n )
    memset(*(void **)(a1 + 4), 48, n);
  memcpy((void *)(*(_DWORD *)(a1 + 4) + n), src, v17);
  *(_DWORD *)(a1 + 4) = v18;
  return 0;
}
// 95098: variable 'v6' is possibly undefined
// 950BC: variable 'v7' is possibly undefined

//----- (00095320) --------------------------------------------------------
int __fastcall sub_95320(int a1, unsigned int a2, unsigned int a3)
{
  char v7; // [sp+23h] [bp-21h] BYREF
  size_t v8; // [sp+24h] [bp-20h]
  int v9; // [sp+28h] [bp-1Ch]
  size_t v10; // [sp+2Ch] [bp-18h]
  size_t n; // [sp+30h] [bp-14h]
  size_t v12; // [sp+34h] [bp-10h]
  size_t v13; // [sp+38h] [bp-Ch]
  void *src; // [sp+3Ch] [bp-8h]

  if ( !*(_DWORD *)a1 )
  {
    sub_93A0C(2, "src/buf.c", 434, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  src = &v7;
  do
  {
    src = (char *)src - 1;
    *(_BYTE *)src = a0123456789abcd_1[a2 & 0xF];
    a2 >>= 4;
  }
  while ( a2 );
  v12 = &v7 - (_BYTE *)src;
  if ( &v7 - (_BYTE *)src >= a3 )
  {
    n = 0;
    v10 = v12;
  }
  else
  {
    n = a3 - v12;
    v10 = a3;
  }
  v13 = *(_DWORD *)(a1 + 4) + v10;
  if ( v13 > *(_DWORD *)(a1 + 8) )
  {
    v9 = sub_94714(a1, v10 - (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4)));
    if ( v9 > 0 )
    {
      sub_93A0C(2, "src/buf.c", 473, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
      v8 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
      if ( v8 > n )
      {
        v12 = v8 - n;
      }
      else
      {
        n = v8;
        v12 = 0;
      }
      if ( n )
        memset(*(void **)(a1 + 4), 48, n);
      memcpy((void *)(*(_DWORD *)(a1 + 4) + n), src, v12);
      *(_DWORD *)(a1 + 4) += v8;
      sub_94674((_DWORD *)a1);
      return 1;
    }
    if ( v9 < 0 )
    {
      sub_93A0C(2, "src/buf.c", 489, "zlog_buf_resize fail");
      return -1;
    }
    v13 = *(_DWORD *)(a1 + 4) + v10;
  }
  if ( n )
    memset(*(void **)(a1 + 4), 48, n);
  memcpy((void *)(*(_DWORD *)(a1 + 4) + n), src, v12);
  *(_DWORD *)(a1 + 4) = v13;
  return 0;
}

//----- (0009560C) --------------------------------------------------------
int __fastcall sub_9560C(int a1, const void *a2, size_t a3)
{
  int n; // [sp+1Ch] [bp-10h]
  int v9; // [sp+20h] [bp-Ch]
  size_t v10; // [sp+24h] [bp-8h]

  v10 = *(_DWORD *)(a1 + 4) + a3;
  if ( v10 <= *(_DWORD *)(a1 + 8) )
    goto LABEL_7;
  v9 = sub_94714(a1, a3 - (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4)));
  if ( v9 <= 0 )
  {
    if ( v9 < 0 )
    {
      sub_93A0C(2, "src/buf.c", 533, "zlog_buf_resize fail");
      return -1;
    }
    v10 = *(_DWORD *)(a1 + 4) + a3;
LABEL_7:
    memcpy(*(void **)(a1 + 4), a2, a3);
    *(_DWORD *)(a1 + 4) = v10;
    return 0;
  }
  sub_93A0C(2, "src/buf.c", 525, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
  n = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
  memcpy(*(void **)(a1 + 4), a2, n);
  *(_DWORD *)(a1 + 4) += n;
  sub_94674((_DWORD *)a1);
  return 1;
}

//----- (00095788) --------------------------------------------------------
int __fastcall sub_95788(int a1, const void *a2, unsigned int a3, int a4, int a5, unsigned int a6, unsigned int a7)
{
  int v12; // [sp+18h] [bp-14h]
  unsigned int n; // [sp+1Ch] [bp-10h]
  size_t na; // [sp+1Ch] [bp-10h]
  unsigned int v15; // [sp+20h] [bp-Ch]
  size_t v16; // [sp+20h] [bp-Ch]
  unsigned int v17; // [sp+24h] [bp-8h]
  unsigned int v18; // [sp+24h] [bp-8h]

  if ( !*(_DWORD *)a1 )
  {
    sub_93A0C(2, "src/buf.c", 562, "pre-use of zlog_buf_resize fail, so can't convert");
    return -1;
  }
  if ( a7 && a3 >= a7 )
    v15 = a7;
  else
    v15 = a3;
  if ( a6 && v15 < a6 )
  {
    v17 = a6;
    n = a6 - v15;
  }
  else
  {
    v17 = v15;
    n = 0;
  }
  if ( v17 > *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4) )
  {
    v12 = sub_94714(a1, v17 - (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4)));
    if ( v12 > 0 )
    {
      sub_93A0C(2, "src/buf.c", 592, "conf limit to %ld, can't extend, so output", *(_DWORD *)(a1 + 20));
      v18 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
      if ( a4 )
      {
        if ( v15 >= v18 )
        {
          v15 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
          na = 0;
        }
        else
        {
          na = v18 - v15;
        }
        if ( na )
          memset((void *)(*(_DWORD *)(a1 + 4) + v15), 32, na);
        memcpy(*(void **)(a1 + 4), a2, v15);
      }
      else
      {
        if ( n >= v18 )
        {
          n = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
          v16 = 0;
        }
        else
        {
          v16 = v18 - n;
        }
        if ( n )
        {
          if ( a5 )
            memset(*(void **)(a1 + 4), 48, n);
          else
            memset(*(void **)(a1 + 4), 32, n);
        }
        memcpy((void *)(*(_DWORD *)(a1 + 4) + n), a2, v16);
      }
      *(_DWORD *)(a1 + 4) += v18;
      sub_94674((_DWORD *)a1);
      return 1;
    }
    if ( v12 < 0 )
    {
      sub_93A0C(2, "src/buf.c", 624, "zlog_buf_resize fail");
      return -1;
    }
  }
  if ( a4 )
  {
    if ( n )
      memset((void *)(*(_DWORD *)(a1 + 4) + v15), 32, n);
    memcpy(*(void **)(a1 + 4), a2, v15);
  }
  else
  {
    if ( n )
    {
      if ( a5 )
        memset(*(void **)(a1 + 4), 48, n);
      else
        memset(*(void **)(a1 + 4), 32, n);
    }
    memcpy((void *)(*(_DWORD *)(a1 + 4) + n), a2, v15);
  }
  *(_DWORD *)(a1 + 4) += v17;
  return 0;
}

//----- (00095B84) --------------------------------------------------------
int __fastcall sub_95B84(const char *a1, int a2)
{
  if ( a1 )
    return sub_93A0C(
             a2,
             "src/level.c",
             26,
             "---level[%p][%d,%s,%s,%d,%d]---",
             a1,
             *(_DWORD *)a1,
             a1 + 4,
             a1 + 1029,
             *((_DWORD *)a1 + 514),
             *((_DWORD *)a1 + 515));
  else
    return sub_93A0C(2, "src/level.c", 19, "a_level is null or 0");
}

//----- (00095C38) --------------------------------------------------------
void __fastcall sub_95C38(void *a1)
{
  if ( a1 )
  {
    sub_93A0C(0, "src/level.c", 34, "zlog_level_del[%p]", a1);
    free(a1);
  }
  else
  {
    sub_93A0C(2, "src/level.c", 33, "a_level is null or 0");
  }
}

//----- (00095CAC) --------------------------------------------------------
int __fastcall sub_95CAC(const char *a1)
{
  if ( a1 )
  {
    if ( !strcasecmp(a1, "LOG_EMERG") )
    {
      return 0;
    }
    else if ( !strcasecmp(a1, "LOG_ALERT") )
    {
      return 1;
    }
    else if ( !strcasecmp(a1, "LOG_CRIT") )
    {
      return 2;
    }
    else if ( !strcasecmp(a1, "LOG_ERR") )
    {
      return 3;
    }
    else if ( !strcasecmp(a1, "LOG_WARNING") )
    {
      return 4;
    }
    else if ( !strcasecmp(a1, "LOG_NOTICE") )
    {
      return 5;
    }
    else if ( !strcasecmp(a1, "LOG_INFO") )
    {
      return 6;
    }
    else if ( !strcasecmp(a1, "LOG_DEBUG") )
    {
      return 7;
    }
    else
    {
      sub_93A0C(2, "src/level.c", 63, "wrong syslog level[%s]", a1);
      return -187;
    }
  }
  else
  {
    sub_93A0C(2, "src/level.c", 44, "str is null or 0");
    return -187;
  }
}

//----- (00095E40) --------------------------------------------------------
_DWORD *__fastcall sub_95E40(const char *a1)
{
  int *v2; // r0
  int v3; // r0
  char v6[4100]; // [sp+10h] [bp-201Ch] BYREF
  unsigned int v7; // [sp+1014h] [bp-1018h] BYREF
  char v8[4100]; // [sp+1018h] [bp-1014h] BYREF
  int v9; // [sp+201Ch] [bp-10h]
  _DWORD *v10; // [sp+2020h] [bp-Ch]
  unsigned int i; // [sp+2024h] [bp-8h]

  v10 = 0;
  v7 = 0;
  if ( a1 )
  {
    memset(v8, 0, 0x1001u);
    memset(v6, 0, 0x1001u);
    v9 = _isoc99_sscanf(a1, " %[^= \t] = %d ,%s", v8, &v7, v6);
    if ( v9 <= 1 )
    {
      sub_93A0C(2, "src/level.c", 84, "level[%s], syntax wrong", a1);
      return 0;
    }
    if ( v7 >= 0x100 )
    {
      sub_93A0C(2, "src/level.c", 90, "l[%d] not in [0,255], wrong", v7);
      return 0;
    }
    if ( !v8[0] )
    {
      sub_93A0C(2, "src/level.c", 95, "str[0] = 0");
      return 0;
    }
    v10 = calloc(1u, 0x810u);
    if ( !v10 )
    {
      v2 = _errno_location();
      sub_93A0C(2, "src/level.c", 101, "calloc fail, errno[%d]", *v2);
      return 0;
    }
    *v10 = v7;
    if ( v6[0] )
    {
      v3 = sub_95CAC(v6);
      v10[515] = v3;
      if ( v10[515] == -187 )
      {
        sub_93A0C(2, "src/level.c", 113, "syslog_level_atoi fail");
        goto LABEL_22;
      }
    }
    else
    {
      v10[515] = 7;
    }
    for ( i = 0; i < 0x400 && v8[i]; ++i )
    {
      *((_BYTE *)v10 + i + 4) = toupper((unsigned __int8)v8[i]);
      *((_BYTE *)v10 + i + 1029) = tolower((unsigned __int8)v8[i]);
    }
    if ( !v8[i] )
    {
      *((_BYTE *)v10 + i + 4) = 0;
      *((_BYTE *)v10 + i + 1029) = 0;
      v10[514] = i;
      return v10;
    }
    sub_93A0C(2, "src/level.c", 126, "not enough space for str, str[%s] > %d", v8, i);
LABEL_22:
    sub_93A0C(2, "src/level.c", 138, "line[%s]", a1);
    sub_95C38(v10);
    return 0;
  }
  sub_93A0C(2, "src/level.c", 77, "line is null or 0");
  return 0;
}
// 1271C: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);

//----- (000962A0) --------------------------------------------------------
unsigned int __fastcall sub_962A0(unsigned int result, unsigned int a2)
{
  if ( a2 != 1 )
  {
    if ( !a2 )
      JUMPOUT(0x96E2C);
    if ( result <= a2 )
    {
      return result == a2;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (*)(void))((char *)&loc_962D8 + 16 * (31 - (__clz(a2) - __clz(result)))))();
    }
    else
    {
      result >>= 31 - __clz(a2);
    }
  }
  return result;
}
// 964F8: control flows out of bounds to 96E2C

//----- (000964FC) --------------------------------------------------------
unsigned int __fastcall sub_964FC(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x964F2);
  return sub_962A0(a1, a2);
}
// 964FE: control flows out of bounds to 964F2

//----- (00096518) --------------------------------------------------------
int __fastcall sub_96518(int a1, int a2)
{
  if ( !a2 )
    JUMPOUT(0x96E2C);
  return sub_9651E();
}
// 967A8: control flows out of bounds to 96E2C
// 9651E: using guessed type int sub_9651E(void);

//----- (0009651E) --------------------------------------------------------
int __fastcall sub_9651E(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_96560 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 96522: variable 'v2' is possibly undefined

//----- (000967AC) --------------------------------------------------------
int __fastcall sub_967AC(int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x96E2C);
  return sub_9651E(a1, a2);
}
// 967A8: control flows out of bounds to 96E2C

//----- (00096AD4) --------------------------------------------------------
int __fastcall sub_96AD4(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x96AFA);
  return a1;
}
// 96AE2: control flows out of bounds to 96AFA

//----- (00096AE4) --------------------------------------------------------
int __fastcall sub_96AE4(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (00096CD0) --------------------------------------------------------
int __fastcall sub_96CD0(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x96CF4);
  return a1;
}
// 96CDC: control flows out of bounds to 96CF4

//----- (00096CE0) --------------------------------------------------------
int __fastcall sub_96CE0(__int64 a1)
{
  unsigned int v1; // r3
  bool v2; // cf
  bool v3; // zf
  unsigned int v4; // r12
  int v5; // r3
  signed int v6; // r2
  bool v7; // cc
  int v8; // r2
  int v9; // r3
  int v10; // r12
  char v11; // r2

  if ( a1 )
  {
    v1 = HIDWORD(a1) & 0x80000000;
    if ( a1 < 0 )
    {
      v2 = (_DWORD)a1 == 0;
      LODWORD(a1) = -(int)a1;
      HIDWORD(a1) -= 2 * HIDWORD(a1) + !v2;
    }
    v4 = HIDWORD(a1);
    v3 = HIDWORD(a1) == 0;
    if ( !HIDWORD(a1) )
    {
      v4 = a1;
      HIDWORD(a1) = a1;
      LODWORD(a1) = 0;
    }
    v5 = v1 | 0x5B000000;
    if ( v3 )
      v5 -= 0x10000000;
    v6 = __clz(v4);
    v7 = v6 < 8;
    v8 = v6 - 8;
    v9 = v5 - 0x800000 - (v8 << 23);
    if ( v7 )
    {
      v11 = v8 + 32;
      v3 = ((unsigned int)a1 | (2 * (HIDWORD(a1) << v11))) == 0;
      LODWORD(a1) = (HIDWORD(a1) >> (32 - v11)) + __CFSHL__(HIDWORD(a1) << v11, 1) + v9;
      if ( v3 )
        LODWORD(a1) = a1 & ~(HIDWORD(a1) << v11 >> 31);
    }
    else
    {
      v10 = (_DWORD)a1 << v8;
      LODWORD(a1) = ((unsigned int)a1 >> (32 - v8)) + ((_DWORD)a1 << v8 >= 0x80000000) + v9 + (HIDWORD(a1) << v8);
      if ( v10 == 0x80000000 )
        LODWORD(a1) = a1 & 0xFFFFFFFE;
    }
  }
  return a1;
}

//----- (00096D5C) --------------------------------------------------------
int __fastcall sub_96D5C(signed __int64 a1, signed __int64 a2)
{
  bool v3; // cf
  unsigned __int64 v5; // [sp+8h] [bp-8h] BYREF

  if ( !a2 )
    JUMPOUT(0x96E2C);
  if ( a1 < 0 )
  {
    v3 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v3;
    if ( a2 < 0 )
    {
      v3 = (_DWORD)a2 == 0;
      LODWORD(a2) = -(int)a2;
      HIDWORD(a2) -= 2 * HIDWORD(a2) + !v3;
      return sub_96EA0(a1, a2, &v5);
    }
    else
    {
      return -sub_96EA0(a1, a2, &v5);
    }
  }
  else if ( a2 < 0 )
  {
    v3 = (_DWORD)a2 == 0;
    LODWORD(a2) = -(int)a2;
    HIDWORD(a2) -= 2 * HIDWORD(a2) + !v3;
    return -sub_96EA0(a1, a2, &v5);
  }
  else
  {
    return sub_96EA0(a1, a2, &v5);
  }
}
// 96D7A: control flows out of bounds to 96E2C

//----- (00096DFC) --------------------------------------------------------
int __fastcall sub_96DFC(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return sub_96EA0(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (00096E38) --------------------------------------------------------
unsigned int __fastcall sub_96E38(double a1)
{
  if ( a1 >= 0.0 )
    return sub_96E60(a1);
  HIDWORD(a1) ^= 0x80000000;
  return -sub_96E60(a1);
}

//----- (00096E60) --------------------------------------------------------
unsigned int __fastcall sub_96E60(double a1)
{
  return (unsigned int)(a1 - (double)(unsigned int)(a1 * 2.32830644e-10) * 4294967300.0);
}

//----- (00096EA0) --------------------------------------------------------
int __fastcall sub_96EA0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}

//----- (00096FB8) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_BAEF8;
  v8 = &off_BAEFC - &off_BAEF8;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// BAEF8: using guessed type _UNKNOWN *off_BAEF8;
// BAEFC: using guessed type _UNKNOWN *off_BAEFC;

//----- (00096FF8) --------------------------------------------------------
int __fastcall sub_96FF8(void (*a1)(void *))
{
  int *v1; // r2

  v1 = &dword_BB2EC;
  if ( &dword_BB2EC )
    v1 = (int *)dword_BB2EC;
  return j___cxa_atexit(a1, 0, v1);
}
// BB2EC: using guessed type int dword_BB2EC;

//----- (00097014) --------------------------------------------------------
int __fastcall sub_97014(const char *a1, struct stat *a2)
{
  return j___xstat(3, a1, a2);
}

//----- (00097020) --------------------------------------------------------
int sub_97020()
{
  return j___xstat64();
}

//----- (0009702C) --------------------------------------------------------
int sub_9702C()
{
  return j___fxstat64();
}

//----- (00097038) --------------------------------------------------------
int sub_97038()
{
  return j___lxstat64();
}

//----- (00097044) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=2349 queued=1965 decompiled=1965 lumina nreq=0 worse=0 better=0
// ALL OK, 1965 function(s) have been successfully decompiled
