/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_12408();
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int __fastcall X509_check_host(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigemptyset(sigset_t *set);
// char *strerror(int errnum);
// int fileno(FILE *stream);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int mkdir(const char *path, __mode_t mode);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// void abort(void);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int __fastcall TLS_client_method(_DWORD); weak
// struct tm *localtime(const time_t *timer);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int memcmp(const void *s1, const void *s2, size_t n);
// int __fastcall SSL_CTX_free(_DWORD); weak
// int sysconf(int name);
// void syslog(int pri, const char *fmt, ...);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int _gmon_start__(void); weak
// int __fastcall SSL_get_current_cipher(_DWORD); weak
// int sched_yield(void);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// in_addr_t inet_addr(const char *cp);
// char *strncpy(char *dest, const char *src, size_t n);
// int fclose(FILE *stream);
// char *fgets(char *s, int n, FILE *stream);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *getenv(const char *name);
// double strtod(const char *nptr, char **endptr);
// char *strchr(const char *s, int c);
// int strcasecmp(const char *s1, const char *s2);
// char *dirname(char *path);
// int setlogmask(int mask);
// int pclose(FILE *stream);
// int listen(int fd, int n);
// void *calloc(size_t nmemb, size_t size);
// int __fastcall SSL_write(_DWORD, _DWORD, _DWORD); weak
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// void *memset(void *s, int c, size_t n);
// int sem_destroy(sem_t *sem);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// void freeaddrinfo(struct addrinfo *ai);
// void perror(const char *s);
// int __fastcall SSL_set_fd(_DWORD, _DWORD); weak
// __int64 strtoll(const char *nptr, char **endptr, int base);
// double floor(double x);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// double exp(double x);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int __fastcall SSL_CIPHER_get_name(_DWORD); weak
// int usleep(__useconds_t useconds);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// void free(void *ptr);
// ssize_t read(int fd, void *buf, size_t nbytes);
// ssize_t write(int fd, const void *buf, size_t n);
// int __fastcall SSL_new(_DWORD); weak
// int access(const char *name, int type);
// void openlog(const char *ident, int option, int facility);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int sem_trywait(sem_t *sem);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int _res_init(void);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int __fastcall SSL_read(_DWORD, _DWORD, _DWORD); weak
// int round(void); weak
// int __fastcall BIO_new(_DWORD); weak
// int socket(int domain, int type, int protocol);
// int execl(const char *path, const char *arg, ...);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int fflush(FILE *stream);
// int ioctl(int fd, unsigned int request, ...);
// int isatty(int fd);
// int __fastcall SSL_CTX_get_cert_store(_DWORD); weak
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// size_t strlen(const char *s);
// int sscanf(const char *s, const char *format, ...);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int execv(const char *path, char *const argv[]);
// int __fastcall lldiv(_DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// int pthread_cond_signal(pthread_cond_t *cond);
// struct lconv *localeconv(void);
// int BIO_s_mem(void); weak
// int fgetc(FILE *stream);
// int strtol(const char *nptr, char **endptr, int base);
// char *strcpy(char *dest, const char *src);
// int sem_post(sem_t *sem);
// int pthread_cond_destroy(pthread_cond_t *cond);
// char *strncat(char *dest, const char *src, size_t n);
// int __fastcall X509_STORE_add_cert(_DWORD, _DWORD); weak
// int settimeofday(const struct timeval *tv, const struct timezone *tz);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int __fastcall SSL_connect(_DWORD); weak
// int printf(const char *format, ...);
// int __fastcall open64(_DWORD); weak
// int raise(int sig);
// void errx(int status, const char *format, ...);
// int __fastcall strtof(_DWORD, _DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int shutdown(int fd, int how);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// char *strstr(const char *haystack, const char *needle);
// int nice(int inc);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int close(int fd);
// int __fastcall SSL_free(_DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// time_t time(time_t *timer);
// double log10(double x);
// const unsigned __int16 **_ctype_b_loc(void);
// int fprintf(FILE *stream, const char *format, ...);
// int __fastcall BIO_write(_DWORD, _DWORD, _DWORD); weak
// void *malloc(size_t size);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// int pthread_attr_init(pthread_attr_t *attr);
// int __fastcall SSL_get_peer_certificate(_DWORD); weak
// int __fastcall SSL_get_verify_result(_DWORD); weak
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// int __fastcall OPENSSL_init_ssl(_DWORD, _DWORD, _DWORD); weak
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// unsigned int sleep(unsigned int seconds);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int __fastcall SSL_shutdown(_DWORD); weak
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// char *strcat(char *dest, const char *src);
// void *memmove(void *dest, const void *src, size_t n);
// void pthread_testcancel(void);
// FILE *popen(const char *command, const char *modes);
// int __fastcall X509_verify_cert_error_string(_DWORD); weak
// int dup2(int fd, int fd2);
// int puts(const char *s);
// __pid_t getpid(void);
// int prctl(int option, ...);
// int fcntl(int fd, int cmd, ...);
// __pid_t fork(void);
// int __fastcall PEM_read_bio_X509(_DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_CTX_new(_DWORD); weak
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int __fastcall BIO_free(_DWORD); weak
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int __fastcall OPENSSL_init_crypto(_DWORD, _DWORD, _DWORD); weak
// size_t strcspn(const char *s, const char *reject);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int strncmp(const char *s1, const char *s2, size_t n);
// int kill(__pid_t pid, int sig);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int pthread_detach(pthread_t th);
// void *realloc(void *ptr, size_t size);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_setcancelstate(int state, int *oldstate);
// int sysinfo(struct sysinfo *info);
// int __fastcall X509_free(_DWORD); weak
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int pipe(int pipedes[2]);
// char *_strdup(const char *s);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// char *strpbrk(const char *s, const char *accept);
// int __fastcall SSL_get_error(_DWORD, _DWORD); weak
// int sem_wait(sem_t *sem);
// void *memchr(const void *s, int c, size_t n);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// int pthread_setcanceltype(int type, int *oldtype);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int *_errno_location(void);
// pthread_t pthread_self(void);
// int pthread_cancel(pthread_t th);
// int sprintf(char *s, const char *format, ...);
// int pthread_join(pthread_t th, void **thread_return);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_16608();
void *sub_1662C();
__int64 sub_16650();
void *sub_1667C();
int __fastcall sub_16698(const char *a1, char *a2, socklen_t a3);
int __fastcall sub_16824(const char *a1, char *a2, socklen_t a3);
int __fastcall sub_1689C(char *a1, socklen_t a2);
void *__fastcall sub_168E8(_DWORD *a1);
void *__fastcall sub_16A28(_DWORD *a1, int a2, int a3, const char *a4);
int __fastcall sub_16DAC(int result, const char **a2);
int __fastcall sub_16EC8(_DWORD *a1, const char **a2);
int __fastcall sub_170D4(_DWORD *a1, const char **a2);
int __fastcall sub_17640(_DWORD *a1, int a2);
int sub_17F44();
int __fastcall sub_18098(_DWORD *a1, const char **a2);
int *__fastcall sub_18328(int *result);
int __fastcall sub_1836C(_DWORD *a1, const char *a2, unsigned int a3);
char *__fastcall sub_18518(char *a1, int *a2);
int __fastcall sub_1861C(int result, _DWORD *a2, int a3);
int __fastcall sub_186D4(int result, _DWORD *a2);
int __fastcall sub_18700(int result, _DWORD *a2);
int __fastcall sub_18724(int result, _DWORD *a2);
int sub_187D4();
int __fastcall sub_1890C(int result, _DWORD *a2);
void __fastcall sub_189CC(int *a1, char *s);
int __fastcall sub_18C70(_DWORD *a1, int a2);
int __fastcall sub_19DF0(_DWORD *a1, int a2);
int __fastcall sub_1A6C8(_DWORD *a1, const char **a2);
int __fastcall sub_1AA98(_DWORD *a1, const char **a2);
int __fastcall sub_1AF38(_DWORD *a1, int a2);
int sub_1B804();
void *__fastcall sub_1CB1C(const char **a1, const char *a2, const char *a3, int a4);
_DWORD *__fastcall sub_1CE58(int a1);
_BYTE *__fastcall sub_1CF00(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8);
int __fastcall sub_1D1B0(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_1D238(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_1D264(int a1, const char *a2, const char *a3, int a4);
const char *__fastcall sub_1D32C(int a1, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_1D400(const char **result, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_1D54C(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char **__fastcall sub_1D694(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char *__fastcall sub_1D7E8(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_1D8D4(const char **a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_1DA44(const char **a1, int a2, const char *a3, const char *a4, int a5);
int __fastcall sub_1DBB0(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall sub_1DCCC(const char **ptr, const char *a2, const char *a3, int a4);
void __fastcall sub_1DD60(int a1, const char *a2, int a3);
int __fastcall sub_1DF40(int a1);
void __fastcall sub_1DFB8(int a1, int a2, int a3, int a4, int a5, int a6);
int sub_1DFC0();
void __fastcall sub_1E040(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_1E04C(const char *a1, const char *a2, int a3);
void __fastcall sub_1E0C4(int a1, const char *a2, int a3);
__int64 __fastcall sub_1E240(int a1, _QWORD *a2, _QWORD *a3);
int __fastcall sub_1E678(int result, unsigned __int8 *a2, int a3);
_DWORD *__fastcall sub_1E874(_DWORD *result);
void *__fastcall sub_1E8A4(unsigned __int8 *a1, char *a2, size_t n);
int __fastcall sub_1E950(_DWORD *a1, _BYTE *a2);
int __fastcall sub_1EA3C(char *a1, size_t n, _BYTE *a3);
int sub_1EAA0();
int __fastcall sub_1EAA8(int a1, const char *a2, int a3);
int __fastcall sub_1ED38(const char **a1, int a2, int a3);
int __fastcall sub_1F1EC(int a1);
int __fastcall sub_1F26C(int a1);
bool __fastcall sub_1F294(int a1, int a2);
_DWORD *__fastcall sub_1F328(_DWORD *a1, unsigned int a2);
char *__fastcall sub_1F38C(_DWORD *a1, unsigned int a2);
void __fastcall __noreturn sub_1F3A4(const void *a1, const char *a2, const char *a3, int a4);
void __fastcall sub_1F400(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_1F40C(const char *a1, const char *a2, int a3);
int __fastcall sub_1F55C(pthread_rwlock_t *a1, const char *a2, int a3);
void __fastcall sub_1F5CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_1F5D8(pthread_rwlock_t *a1, const char *a2, int a3);
void __fastcall sub_1F648(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_1F654(pthread_mutex_t *a1, const char *a2, int a3);
void __fastcall sub_1F6C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_1F6D0(const char *a1, int a2);
void __fastcall sub_1F728(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall sub_1F734(int a1);
int __fastcall sub_1F7C4(int a1, char a2);
void *__fastcall sub_1F828(size_t a1, const char *a2, const char *a3, int a4);
void __fastcall sub_1F8A4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void *__fastcall sub_1F8B0(size_t a1, size_t a2, const char *a3, const char *a4, int a5);
void __fastcall sub_1F934(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void *__fastcall sub_1F940(void *a1, size_t a2, const char *a3, const char *a4, int a5);
void __fastcall sub_1F9C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
char *__fastcall sub_1F9D4(char *a1);
_BYTE *__fastcall sub_1FA20(_BYTE *result, int a2, int a3);
_BYTE *__fastcall sub_1FA90(int a1, int a2);
int __fastcall sub_1FB44(_BYTE *a1, unsigned __int8 *a2, int a3);
size_t __fastcall sub_1FCE8(_BYTE *a1, char *s);
int __fastcall sub_1FDC0(int a1, int a2);
int __fastcall sub_1FE0C(unsigned int *a1, unsigned int *a2);
char *sub_1FFFC();
void __fastcall sub_20058(char *a1);
int __fastcall sub_200C0(int a1);
int __fastcall sub_200C8(int a1);
int __fastcall sub_200D0(int a1, int a2);
int __fastcall sub_201A4(int a1, const struct timespec *a2);
int __fastcall sub_20284(int result);
_DWORD *__fastcall sub_202C0(_DWORD *result, int *a2);
_DWORD *__fastcall sub_202F4(_DWORD *result, int *a2);
bool __fastcall sub_20338(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_2036C(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_203A0(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_203D0(_DWORD *result, _DWORD *a2);
int __fastcall sub_203EC(_QWORD *a1);
int __fastcall sub_20424(_QWORD *a1);
int __fastcall sub_20464(_QWORD *a1);
int __fastcall sub_204A4(_QWORD *a1);
_DWORD *__fastcall sub_204E0(_DWORD *result, _DWORD *a2);
const char *__fastcall sub_20658(const char **a1, const char *a2);
__int64 __fastcall sub_206A0(__time_t *a1);
int __fastcall sub_206E4(_DWORD *a1);
int __fastcall sub_20714(_DWORD *a1, _DWORD *a2, int *a3);
int __fastcall sub_20750(struct timespec *tp); // idb
int __fastcall sub_2075C(int *a1);
int __fastcall sub_2081C(int *a1);
int sub_208D4();
int __fastcall sub_20934(int result, _DWORD *a2);
void sub_209CC();
int __fastcall sub_20A10(const char *a1, _DWORD *a2, char **a3);
char *__fastcall sub_20B84(char *s1, int a2);
bool __fastcall sub_20C5C(int a1);
void **__fastcall sub_20C7C(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6);
int __fastcall sub_20CE8(int a1, int *a2);
int __fastcall sub_20DA8(int a1, char *s); // idb
int __fastcall sub_20FF0(_DWORD *a1, int a2);
int __fastcall sub_21338(pthread_mutex_t *a1);
int __fastcall sub_2149C(pthread_mutex_t *a1, const char *a2, int a3);
char *__fastcall sub_21850(int a1);
int __fastcall sub_21DDC(_DWORD *a1);
time_t __fastcall sub_22BB4(_DWORD *a1, int a2);
char *__fastcall sub_22CA4(char *a1, char *s);
char *__fastcall sub_22D78(const char *a1);
int __fastcall sub_22E98(const char *a1);
int __fastcall sub_22ED8(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_22F54(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4);
int __fastcall sub_22F9C(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_22FD4(int a1);
int __fastcall sub_23018(sem_t *sem, const char *a2, const char *a3, int a4);
int __fastcall sub_23098(sem_t *a1, int a2, const char *a3, const char *a4, int a5);
void sub_231E0();
int *__fastcall sub_231E8(sem_t *sem);
bool __fastcall sub_23220(int a1, int a2, int a3);
void __fastcall sub_232EC(void *a1, const void *a2, size_t a3, int a4, int a5, int a6);
void __fastcall sub_235FC(void *a1, const void *a2);
int __fastcall sub_23630(int a1, _DWORD *a2);
int __fastcall sub_24798(const char **a1, int a2, int a3);
int __fastcall sub_24A54(pthread_mutex_t *a1);
int __fastcall sub_26020(pthread_mutex_t *a1);
int __fastcall sub_260AC(pthread_mutex_t *a1, _DWORD *a2);
int __fastcall sub_26480(pthread_mutex_t *a1, int a2);
int __fastcall sub_2705C(pthread_mutex_t *a1, int a2);
int __fastcall sub_27070(pthread_mutex_t *a1);
int __fastcall sub_27468(pthread_mutex_t *a1);
int __fastcall sub_27758(int *a1, _DWORD *a2, _DWORD *a3);
_BYTE *__fastcall sub_277D4(_BYTE *result, int a2);
int __fastcall sub_27814(int result, char a2);
void __fastcall sub_27AFC(int a1, char *a2, int a3);
void __fastcall sub_2811C(int a1, char *a2, int a3);
void __fastcall sub_28134(int a1, int a2, int a3);
int __fastcall sub_282A4(int result, unsigned int *a2, unsigned int a3);
int __fastcall sub_282D0(_DWORD *a1);
int __fastcall sub_282E0(_DWORD *a1);
int __fastcall sub_282F0(_DWORD *a1);
int __fastcall sub_28300(_BYTE *a1);
int sub_2831C();
int nullsub_3(); // weak
int nullsub_1(); // weak
int sub_2832C();
__int64 sub_28334();
int sub_28340();
int nullsub_4(); // weak
int sub_2834C();
int __fastcall sub_28354(int result);
void __noreturn sub_28370(const char *a1, ...);
int __fastcall sub_283B8(int a1);
int __fastcall sub_283D0(int a1);
int __fastcall sub_283E8(int a1);
int __fastcall sub_28400(int a1);
int __fastcall sub_28418(int a1);
int __fastcall sub_28430(int a1);
_BYTE *__fastcall sub_28448(const char *a1);
void __fastcall __noreturn sub_28714(const char *a1);
time_t __fastcall sub_2876C(int a1);
time_t __fastcall sub_287A4(int a1);
int __fastcall sub_287D8(unsigned __int64 a1, char *s, size_t maxlen, int a4);
int __fastcall sub_28A90(int a1);
int __fastcall sub_28C30(int a1);
void __fastcall sub_28C84(int a1);
void sub_28CFC();
int sub_28E18();
int __fastcall sub_28E2C(int a1);
void __noreturn sub_28F68();
_DWORD *__fastcall sub_28F90(_DWORD *result);
int __fastcall sub_28FB0(unsigned __int8 *a1);
int __fastcall sub_28FD4(int a1);
int __fastcall sub_2905C(int a1);
int __fastcall sub_290E8(int a1);
const char *__fastcall sub_29150(const char *a1);
char *__fastcall sub_291BC(char *a1);
char *__fastcall sub_292B8(_DWORD *a1, int a2);
int sub_29640();
char *__fastcall sub_297CC(const char *a1, float *a2);
char *__fastcall sub_29824(const char *a1, float *a2);
void sub_2987C();
int __fastcall sub_299A8(int a1, int a2, int (__fastcall **a3)(int));
void sub_29B50();
void sub_29BA0();
int __fastcall sub_29BFC(int a1);
char *__fastcall sub_29C38(const char *a1);
char *__fastcall sub_29C80(const char *a1, _DWORD *a2);
char *__fastcall sub_29CB0(const char *a1, _DWORD *a2);
char *__fastcall sub_29CE4(const char *a1, _DWORD *a2);
char *__fastcall sub_29D10(const char *a1, _DWORD *a2);
char *__fastcall sub_29D40(const char *a1, _DWORD *a2);
char *__fastcall sub_29D70(const char *a1, _DWORD *a2);
char *__fastcall sub_29DA0(const char *a1, _DWORD *a2);
char *__fastcall sub_29DD0(const char *a1, _DWORD *a2);
char *__fastcall sub_29E00(const char *a1, _DWORD *a2);
char *__fastcall sub_29E2C(const char *a1, _DWORD *a2);
char *__fastcall sub_29E58(const char *a1, _DWORD *a2);
char *__fastcall sub_29E84(const char *a1, _DWORD *a2);
char *__fastcall sub_29EB4(const char *a1, _DWORD *a2);
char *__fastcall sub_29EE0(const char *a1, _DWORD *a2);
char *__fastcall sub_29F10(const char *a1, _DWORD *a2);
int __fastcall sub_29F3C(_DWORD *a1, char *s1);
void __fastcall sub_2A090(const char *a1, const char *a2, int a3);
double __fastcall sub_2A0D8(double a1);
int nullsub_2(); // weak
int nullsub_5(); // weak
int sub_2A128();
int sub_2A130();
int nullsub_6(); // weak
int nullsub_7(); // weak
int nullsub_8(); // weak
const char *__fastcall sub_2A144(const char *a1);
int __fastcall sub_2A1B0(char *a1, size_t a2, time_t *a3);
void sub_2A248();
char *__fastcall sub_2A3CC(const char *a1, _DWORD *a2, int a3, int a4);
int __fastcall sub_2A418(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_2A448(int a1, char *a2);
int __fastcall sub_2A47C(int a1, char *s1); // idb
const char *__fastcall sub_2A55C(const char *a1);
void *__fastcall sub_2A5B8(void **a1);
char *__fastcall sub_2A5F4(int a1, int a2, int a3);
void __fastcall sub_2A70C(void ***a1, const char *a2, const char *a3, int a4);
void __fastcall sub_2A7A0(int a1);
void sub_2A804();
void sub_2A82C();
void __fastcall sub_2A854(int a1, unsigned int a2);
_BYTE *__fastcall sub_2A91C(_BYTE *result, unsigned int a2);
unsigned int __fastcall sub_2A954(__int64 *a1);
void __fastcall sub_2AA08(void ***a1, const char *a2, const char *a3, int a4);
int *__fastcall sub_2AC40(int *result);
void __fastcall sub_2ACFC(FILE *s);
int sub_2B2E4();
char *__fastcall sub_2B370(char *a1);
void sub_2B46C();
void __fastcall sub_2B4D0(void *a1);
int __fastcall sub_2B764(int a1);
bool __fastcall sub_2B77C(int a1, int a2);
bool __fastcall sub_2B79C(int a1, int a2);
int __fastcall sub_2B7E8(int a1, int a2);
void __fastcall sub_2B88C(int *a1, int a2);
void __fastcall sub_2BB40(int *a1, unsigned int a2);
int __fastcall sub_2BB68(int *a1, unsigned int a2);
void __fastcall sub_2BBB4(int a1, int a2);
int __fastcall sub_2BFEC(int a1, void *s2, size_t n, const void *a4, int a5, size_t na);
int __fastcall sub_2C05C(int result, int a2);
void __fastcall sub_2C0A8(int a1, _DWORD *a2);
int __fastcall sub_2C218(int result);
void __fastcall __noreturn sub_2C230(int a1, int a2);
void __noreturn sub_2C2B0();
void __noreturn sub_2C30C();
int __fastcall sub_2C350(char *a1, size_t a2, int a3);
void __noreturn sub_2C524();
int sub_2C568();
int __fastcall sub_2C5A8(_BYTE *a1);
void __fastcall __noreturn sub_2C9B4(const char *a1, int a2);
int __fastcall sub_2CA10(pthread_mutex_t *a1, const char *a2, int a3);
void __fastcall __noreturn sub_2CA38(const char *a1, int a2);
int __fastcall sub_2CA94(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_2CABC(int a1, const char *a2, int a3);
void __fastcall __noreturn sub_2CB04(const char *a1, int a2);
void __fastcall __noreturn sub_2CB60(const char *a1, int a2);
void __fastcall __noreturn sub_2CBBC(const char *a1, int a2);
int __fastcall sub_2CC18(int a1, _BYTE *a2);
int __fastcall sub_2CC84(int a1, _BYTE *a2);
int __fastcall sub_2CCEC(_DWORD *a1, int a2);
int __fastcall sub_2D4CC(int a1, int a2);
int sub_2D548();
int __fastcall sub_2D5B0(int a1, unsigned int a2);
void __fastcall __noreturn sub_2D6AC(const char *a1, int a2);
int __fastcall sub_2D708(pthread_rwlock_t *a1, const char *a2, int a3);
int sub_2D740();
int __fastcall sub_2D7F0(int a1);
_DWORD *sub_2D914();
_DWORD *__fastcall sub_2D9AC(int a1, int a2);
_DWORD *__fastcall sub_2D9D4(int a1);
int __fastcall sub_2DA20(pthread_rwlock_t *a1, int a2);
void __fastcall sub_2DA8C(pthread_rwlock_t *a1, void **a2);
_DWORD *__fastcall sub_2DB18(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_2DBC4(pthread_rwlock_t *a1);
void __fastcall __noreturn sub_2DCC0(const char *a1, int a2);
_DWORD *__fastcall sub_2DD1C(pthread_rwlock_t *a1, int a2);
_DWORD *__fastcall sub_2DDE8(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_2DEA4(pthread_rwlock_t *a1, int a2);
int __fastcall sub_2DF58(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_2DFF4(int a1);
int sub_2E068();
int __fastcall sub_2F420(int a1);
void sub_2F548();
int __fastcall sub_2F688(int a1);
int __fastcall sub_2F6FC(int a1);
bool sub_2F710();
bool sub_2FA50();
void sub_2FA68();
int sub_2FB78();
int __fastcall sub_2FC20(int a1, int a2, int a3);
int sub_2FD10();
void __fastcall sub_2FDBC(_DWORD *a1);
void __fastcall sub_2FEF4(_DWORD *a1);
void __fastcall sub_2FF84(int a1);
int __fastcall sub_2FFA8(int a1);
_BYTE *sub_3003C();
const char *__fastcall sub_30288(char *s);
const char *__fastcall sub_30374(const char *a1);
const char *__fastcall sub_304F0(const char *a1);
int sub_30514();
const char *__fastcall sub_3077C(int a1);
int sub_307F8();
void __fastcall sub_308D8(pthread_rwlock_t *a1);
int sub_30A48();
int __fastcall sub_30E60(int a1);
int __fastcall sub_30FE8(int a1, int a2);
unsigned __int64 __fastcall sub_3117C(int a1);
int __fastcall sub_31450(int *a1, int a2);
int __fastcall sub_3167C(int a1, _DWORD *a2, int a3, _DWORD *a4);
void __fastcall sub_31774(_DWORD *a1);
int __fastcall sub_31A9C(int a1);
void __fastcall sub_31F20(int a1);
void __noreturn sub_32050();
int *__fastcall sub_3285C(int a1);
int __fastcall sub_32BF8(int a1);
int __fastcall sub_33090(_DWORD *a1);
void __fastcall sub_33320(const char *a1, _DWORD *a2);
__int64 __fastcall sub_335C8(int a1, int a2);
int __fastcall sub_33BA8(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6);
int __fastcall sub_33D04(int a1, int a2);
void **__fastcall sub_341EC(int a1, void *a2);
void **__fastcall sub_34538(int a1, pthread_rwlock_t *a2, void *a3);
void **__fastcall sub_34560(int a1);
void **__fastcall sub_345E0(pthread_rwlock_t *a1);
void sub_3464C();
int sub_34994();
void __fastcall sub_34B04(int a1, unsigned __int64 a2);
void __fastcall sub_35C74(int a1);
void __noreturn sub_36338();
int __fastcall sub_36B90(_DWORD *a1);
int __fastcall sub_37C80(int a1);
int __fastcall sub_395C4(_DWORD *a1);
int __fastcall sub_3B058(int a1);
void __fastcall sub_3B824(__time_t *a1);
int __fastcall sub_3BF78(int a1, int a2);
int __fastcall sub_3C064(int a1, int a2, unsigned int a3);
void __fastcall sub_3C0F8(int a1);
int __fastcall sub_3C120(int a1, int a2, int a3);
void __fastcall __noreturn sub_3C2EC(int a1);
int __fastcall sub_3C2F8(int a1, int a2, char *s1, const char *a4, const char *a5);
int __fastcall sub_3C3EC(int result);
int __fastcall sub_3C54C(int result);
int __fastcall sub_3C634(pthread_rwlock_t *a1);
int __fastcall sub_3C720(_DWORD *a1);
_BYTE *__fastcall sub_3D12C(const void *a1);
void sub_3D190();
unsigned int sub_3D2A0();
void sub_3DA90();
void sub_3DDB0();
char *__fastcall sub_3E49C(const char *a1, const char *a2);
int __fastcall sub_3E4D8(_BYTE *a1);
int __fastcall sub_3E4E8(_BYTE *a1);
int __fastcall sub_3E4F8(_BYTE *a1);
char *__fastcall sub_3E508(const char *a1, _BYTE *a2);
char *__fastcall sub_3E59C(const char *a1, _BYTE *a2);
int __fastcall sub_3E5BC(int a1, _DWORD *a2);
char *__fastcall sub_3E5C8(const char *a1, _DWORD *a2);
char *__fastcall sub_3E650(const char *a1, int *a2);
char *__fastcall sub_3E6D8(const char *a1, _DWORD *a2);
int __fastcall sub_3E7A0(_DWORD *a1);
void __fastcall __noreturn sub_3E7B8(const char *a1);
void __fastcall __noreturn sub_3E7D8(int a1);
char *__fastcall sub_3E818(char *a1, unsigned __int8 *a2);
char *__fastcall sub_3E83C(char *a1, unsigned __int8 *a2);
char *__fastcall sub_3E860(_BYTE *a1, const char **a2);
int __fastcall sub_3E8C0(char *a1, _DWORD *a2);
int __fastcall sub_3E8D4(char *a1, float *a2);
int __fastcall sub_3E900(char *a1, _DWORD *a2);
int __fastcall sub_3E914(char *a1, _DWORD *a2);
int __fastcall sub_3E928(char *a1, _DWORD *a2);
const char *__fastcall sub_3E93C(unsigned int *a1, size_t *a2);
int __fastcall sub_3E9DC(int a1, size_t *a2);
int __fastcall sub_3EA24(int a1, unsigned int *a2, size_t *a3);
int __fastcall sub_3EADC(const char **a1);
int __fastcall sub_3EC50(int *a1);
const char *__fastcall sub_3ECB4(unsigned int *a1, size_t *a2);
_BYTE *__fastcall sub_3ED0C(int a1, unsigned int *a2, size_t *a3);
const char *__fastcall sub_3ED64(unsigned int *a1);
_BYTE *__fastcall sub_3EDC4(int a1, unsigned int *a2);
int __fastcall sub_3EE24(const char *a1, const char *a2, const char *a3, const char *a4, const char *a5, const char *a6, const char *a7);
int __fastcall sub_3EE68(int result, int a2);
bool __fastcall sub_3EF3C(_DWORD *a1, const char **a2, void (*a3)(const char *, ...));
void sub_3EF98();
int sub_3EFB8(const char *a1, ...);
void __noreturn sub_3F000(const char *a1, ...);
char *__fastcall sub_3F040(const char *a1);
void *__fastcall sub_3F070(_DWORD *a1, int a2, int a3);
int __fastcall sub_3F0A8(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
char *__fastcall sub_3F558(const char *a1, const char *a2);
char *__fastcall sub_3F99C(char *result, __int16 a2, unsigned int a3);
unsigned int __fastcall sub_3FAB0(int a1, unsigned int a2, int *a3);
int __fastcall sub_3FBC0(int a1, int a2, char *s1, unsigned int a4);
int __fastcall memmem(char *a1, unsigned int a2, char *a3, unsigned int a4);
void __fastcall sub_401D8(_DWORD *a1);
int __fastcall sub_40200(unsigned __int8 *a1, int a2);
int __fastcall sub_40484(int a1);
int __fastcall sub_40500(const char *a1, int a2);
int __fastcall sub_42448(const char *a1, int a2);
int __fastcall sub_424FC(const void *a1, size_t a2);
int __fastcall sub_425B8(const void *a1, size_t a2);
int __fastcall sub_42680(const void *a1, size_t a2);
int __fastcall sub_42754(const void *a1, size_t a2);
int sub_42818();
int __fastcall sub_42A88(_DWORD *a1);
void sub_42C84();
int sub_42D80();
void __fastcall __noreturn sub_42F10(const char *a1, int a2);
void __fastcall __noreturn sub_42F74(const char *a1, int a2);
_DWORD *sub_42FD8();
__int64 sub_43708();
int sub_437A0();
char *__fastcall sub_43B30(int a1, size_t *a2);
void __fastcall sub_43F94(int a1);
int __fastcall sub_44188(int a1);
int __fastcall sub_444BC(int a1);
int __fastcall sub_44744(int a1, int a2);
int __fastcall sub_44998(int a1);
int sub_44C40();
int __fastcall sub_44C58(int a1, const void *a2, size_t a3, _DWORD *a4);
int sub_44DA4();
int __fastcall sub_44DAC(void *src, size_t n, const void **a3);
int __fastcall sub_44DC0(void *src, size_t n, _DWORD *a3);
size_t __fastcall sub_44E04(const void *a1, size_t a2, FILE *s);
int __fastcall sub_44E20(void *buf, size_t n, int *a3);
int __fastcall sub_44E48(const char **a1, const char **a2);
int __fastcall sub_44E54(char *a1, int a2, int (__fastcall *a3)(char *, int, int), int a4, unsigned int a5);
int __fastcall sub_450DC(char a1, int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5);
int __fastcall sub_4518C(int a1, const void *a2, char *s);
int __fastcall sub_451E4(_DWORD *a1, int a2, int a3, int a4, int (__fastcall *a5)(__int16 *, int, int), int a6);
int __fastcall sub_459F4(_DWORD *a1, int (__fastcall *a2)(__int16 *, int, int), int a3, int a4);
_BYTE *__fastcall sub_45A6C(_DWORD *a1, int a2);
int __fastcall sub_45B14(_DWORD *a1, int a2, int a3);
int __fastcall sub_45B28(_DWORD *a1, int a2, int a3);
int __fastcall sub_45B8C(_DWORD *a1, int a2, int a3);
int __fastcall sub_45BB8(unsigned __int16 *a1, unsigned int a2, int a3);
int __fastcall sub_460FC(int a1, int *a2, char *s2, int a4);
void __fastcall sub_46170(int a1);
int __fastcall sub_461E0(_DWORD *a1);
void __fastcall sub_4625C(int a1);
int __fastcall sub_46274(int a1, char *a2, int a3);
int __fastcall sub_46508(int a1, char *s); // idb
int __fastcall sub_46568(_DWORD *a1, char *s);
int __fastcall sub_46688(_DWORD *a1);
int __fastcall sub_466E4(int a1);
int __fastcall sub_466FC(int a1, char *s); // idb
int __fastcall sub_4675C(int a1, int a2);
int __fastcall sub_46774(int a1);
int __fastcall sub_4677C(int a1);
void __fastcall sub_46784(int a1, int a2);
int __fastcall sub_467F0(int result);
int __fastcall sub_468EC(_DWORD *a1);
int __fastcall sub_46910(int a1);
int __fastcall sub_46934(_DWORD *a1);
int sub_46990(int result, _DWORD *a2, int a3, const char *a4, ...);
void __fastcall sub_46AC0(int a1);
int __fastcall sub_46B00(int *a1);
int __fastcall sub_46B2C(_BYTE *a1);
_DWORD *__fastcall sub_46BC0(_DWORD *result, int a2);
int __fastcall sub_46C7C(int a1, int a2);
int __fastcall sub_46E04(int a1, int a2);
_DWORD *__fastcall sub_46E44(_DWORD *result, int a2);
unsigned int __fastcall sub_46E90(int a1, int a2);
_DWORD *__fastcall sub_476A8(int a1, int a2, int a3);
_DWORD *__fastcall sub_47B4C(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_47C50(int a1, int a2, char *a3);
_DWORD *__fastcall sub_47D18(int a1, int a2, int a3, char *a4);
_DWORD *__fastcall sub_47DEC(int a1, int a2, char *a3);
_DWORD *__fastcall sub_47ECC(int a1, int a2, char *a3);
_DWORD *__fastcall sub_47FA8(char *a1, int a2, char *a3);
void *__fastcall sub_48144(void *result);
void __fastcall sub_4815C(void *a1);
_BYTE *__fastcall sub_48174(const void *a1, size_t a2);
_BYTE *__fastcall sub_481C0(const char *a1);
int __fastcall sub_481DC(__int64 a1);
_DWORD *__fastcall sub_481EC(_DWORD *result, _DWORD *a2);
int __fastcall sub_48218(_DWORD *a1);
void __fastcall sub_4824C(int a1);
int __fastcall sub_48278(int result);
int __fastcall sub_4828C(int a1);
int __fastcall sub_48294(int *a1);
int __fastcall sub_482A8(const void **a1, void *src, size_t n);
int __fastcall sub_48374(const void **a1, char a2);
int __fastcall sub_48398(int *a1, char a2, int a3);
int __fastcall sub_483C0(int a1, double *a2);
int __fastcall sub_484B0(char *a1, size_t a2, int a3);
int __fastcall sub_485F0(int a1, _BYTE *a2, _DWORD *a3);
int __fastcall sub_486DC(int a1);
int __fastcall sub_48748(char *a1, unsigned int a2, int *a3);
char *__fastcall sub_48830(char *result, int a2, _DWORD *a3);
int __fastcall sub_488AC(int a1, unsigned int a2);
_QWORD *__fastcall sub_48928(int a1);
void *__fastcall sub_48978(_DWORD *a1, int a2, int a3);
_DWORD *__fastcall sub_48A04(_BYTE *a1, size_t a2, int a3);
_DWORD *sub_48A70();
_DWORD *__fastcall sub_48AD8(_DWORD *result);
int __fastcall sub_48AF4(_DWORD *a1, char *a2);
bool __fastcall sub_48B1C(int *a1, int *a2);
int __fastcall sub_48CFC(_DWORD *a1, char *a2);
int __fastcall sub_48D5C(_DWORD *a1);
int __fastcall sub_48D80(_DWORD *a1, char *a2);
int __fastcall sub_48DA8(_DWORD *a1, int a2);
int __fastcall sub_48DDC(int a1);
int __fastcall sub_48DE8(int a1);
int __fastcall sub_48DF4(int result);
_DWORD *sub_48E00();
_DWORD *__fastcall sub_48E60(_DWORD *result);
_DWORD *__fastcall sub_48E7C(_DWORD *result, unsigned int a2);
int __fastcall sub_48EB0(_DWORD *a1, _DWORD *a2);
const char *__fastcall sub_48F88(const char *result);
_DWORD *__fastcall sub_48FB0(_BYTE *a1, size_t a2);
_DWORD *__fastcall sub_48FB8(_BYTE *a1, size_t a2);
_DWORD *__fastcall sub_48FC0(_BYTE *a1, size_t a2);
const char *__fastcall sub_49004(const char *result);
_DWORD *__fastcall sub_49028(_DWORD *result);
_DWORD *__fastcall sub_49044(_DWORD *result);
int __fastcall sub_49060(int a1, const void *a2, size_t a3);
int __fastcall sub_490C4(int a1, const char *a2);
int __fastcall sub_490F8(int a1, const void *a2, size_t a3);
int __fastcall sub_4913C(int a1, const char *a2);
_DWORD *__fastcall sub_49170(char *format, __gnuc_va_list arg);
_DWORD *sub_49220(char *a1, ...);
_QWORD *__fastcall sub_49250(__int64 a1);
__int64 __fastcall sub_49284(int a1);
int __fastcall sub_492AC(int a1, __int64 a2);
double *sub_492D4();
void sub_49330();
int __fastcall sub_493C0(int result);
void *sub_49408();
void *sub_49414();
void *sub_49420();
void __fastcall sub_4942C(_DWORD *a1);
int __fastcall sub_494F8(_DWORD *a1);
int __fastcall sub_49588(_DWORD *a1, int a2, _DWORD *a3);
int __fastcall sub_49620(_DWORD *a1, unsigned int a2);
int __fastcall sub_496EC(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall sub_497A8(_DWORD *a1, _DWORD *a2);
int __fastcall sub_49894(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall sub_49928(_DWORD *a1, _DWORD *a2);
int __fastcall sub_49A08(_DWORD *a1, _DWORD *a2);
int __fastcall sub_49AF8(_DWORD *a1, unsigned int a2, _DWORD *a3);
int __fastcall sub_49D54(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_49E30(int *a1, int *a2);
double *__fastcall sub_49E48(int a1);
double *__fastcall sub_4A004(int a1);
char *__fastcall sub_4A168(char *a1, char *s);
char *__fastcall sub_4A1CC(char *result, char *a2);
char *__fastcall sub_4A20C(char *a1, char *s);
int sub_4A21C(int result, int a2, int a3, int a4, char a5, char *format, ...);
int __fastcall sub_4A280(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg);
unsigned int __fastcall sub_4A2D0(unsigned int result, unsigned int a2);
unsigned int __fastcall sub_4A52C(unsigned int a1, unsigned int a2);
int __fastcall sub_4A548(int result, unsigned int a2);
int __fastcall sub_4AB04(__int64 a1);
int __fastcall sub_4AB14(__int64 a1);
int __fastcall sub_4AB70(unsigned __int64 a1, unsigned __int64 a2);
unsigned int __fastcall sub_4ABAC(double a1);
unsigned int __fastcall sub_4ABD0(double a1);
int __fastcall sub_4AC10(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
int __fastcall init(int a1, int a2, int a3);
int nullsub_9(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN loc_186A0; // weak
_UNKNOWN loc_4A308; // weak
_UNKNOWN loc_4A590; // weak
const char asc_4C1D0[] = "                    "; // idb
__int16 word_4C1E4 = 10; // weak
_DWORD dword_4C28C[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char *off_4C6A8 = "http:"; // weak
_UNKNOWN unk_4DA08; // weak
_UNKNOWN unk_4DA3C; // weak
char aJsonEscape[12] = "json_escape"; // weak
_DWORD dword_4EA18[10] = { 1, 351304, 64, 351312, 64, 351324, 8, 351336, 10, 336060 }; // weak
char a00000002c01f50[321] = "00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f"; // weak
char a000000029c6bf4[321] = "000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b10020000000080000000000000000000000000000000000000000000000000000000000000000000000000000000008002000064e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4"; // weak
const char aUserS[] = "\n\t\t\"user\" : \"%s\""; // idb
__int16 word_51D00 = 44; // weak
_UNKNOWN unk_5211C; // weak
_UNKNOWN unk_52140; // weak
__int16 word_540E4 = 11105; // weak
const char a10[] = "1.0."; // idb
__int16 word_55C44 = 48; // weak
int (*off_55F30)() = &sub_42448; // weak
__int16 word_563F8 = 93; // weak
_UNKNOWN *off_66EE0 = (_UNKNOWN *)0x16695; // weak
_UNKNOWN *off_66EE4 = (_UNKNOWN *)0x1667D; // weak
char *off_67308 = "summary"; // weak
char *off_67368 = "summary"; // weak
char *off_673C8 = "rate"; // weak
int dword_67840 = 5; // weak
_DWORD dword_67844[63] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817
}; // weak
_UNKNOWN unk_67940; // weak
_UNKNOWN unk_67960; // weak
int (*off_67964)() = &sub_1EAA0; // weak
char *off_67A68 = "--version-file"; // weak
int dword_67A6C = 2; // weak
_UNKNOWN unk_67A84; // weak
int dword_681BC = 1; // weak
double dbl_681C0 = 1.0; // weak
char dword_681C8[] = { '0', '\0', '\0', '\0' }; // idb
int dword_681CC = 0; // weak
int dword_681D0 = 5; // weak
char *off_681D4 = ":D"; // weak
int dword_681D8 = 0; // weak
double dbl_681E0 = 1.0; // weak
double dbl_681E8 = 1.84467441e19; // weak
int dword_681F0 = 120; // weak
int dword_681F4 = -1; // weak
int dword_681F8 = 120; // weak
char byte_681FC = '\x01'; // weak
char byte_681FD = '\x01'; // weak
int dword_68200 = 100; // weak
char *off_68204 = "--config|-c"; // weak
char *off_68290 = "000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"; // weak
int dword_68298 = 2; // weak
_UNKNOWN *off_682C0 = &unk_55C38; // weak
char byte_682C4 = '\x01'; // weak
char aBitmainApiDete[19] = "bitmain_api_detect"; // weak
char aBitmainUpdateJ[19] = "bitmain_update_job"; // weak
char aBitmainShutdow[17] = "bitmain_shutdown"; // weak
char aBitmainFlushAp_0[18] = "bitmain_flush_api"; // weak
_UNKNOWN unk_684F0; // weak
int dword_68568 = 25000; // weak
void *(*off_6856C)(size_t size) = &malloc; // weak
void (*off_68570)(void *ptr) = &free; // weak
_UNKNOWN unk_68574; // weak
_UNKNOWN unk_6857C; // weak
_UNKNOWN unk_68584; // weak
_UNKNOWN unk_6858C; // weak
int stdin; // weak
int stdout; // weak
int stderr; // weak
char byte_6859C; // weak
int dword_685A0; // weak
char s1[16]; // idb
char byte_685B4; // weak
char byte_685B8; // weak
int dword_685BC; // weak
__int16 word_685C0; // weak
int dword_685E0; // weak
char byte_686E0; // weak
char byte_686E1; // weak
char byte_686E2; // weak
char byte_686E8[512]; // weak
int dword_688E8; // weak
int dword_688EC; // weak
int dword_688F0; // weak
int dword_688F4; // weak
int dword_688F8; // weak
int dword_688FC; // weak
int dword_68900; // weak
char s[256]; // idb
char byte_68A04; // weak
int dword_68A08; // weak
int dword_68A0C; // weak
char byte_68A10; // weak
char byte_68A14[200]; // idb
int dword_68ADC; // weak
int dword_68AE0; // weak
int dword_68AE4; // weak
int dword_68AE8; // weak
__time_t dword_68AEC[2]; // weak
__time_t dword_68AF4[2]; // weak
_UNKNOWN unk_68AFC; // weak
__int64 qword_68B00; // weak
int dword_68B08; // weak
int dword_68B0C; // weak
int dword_68B10; // weak
int dword_68B14; // weak
int dword_68B18; // weak
char byte_68B1C; // weak
int dword_68B20; // weak
int dword_68B24; // weak
int dword_68B28; // weak
int dword_68B2C; // weak
int dword_68B30; // weak
int dword_68B34; // weak
char byte_68B38[40]; // weak
int dword_68B60; // weak
int dword_68B64; // weak
int dword_68B68; // weak
int dword_68B6C; // weak
int dword_68B70; // weak
int dword_68B74; // weak
char byte_68B78; // weak
int dword_68B7C; // weak
int dword_68B80; // weak
int dword_68B84; // weak
int dword_68B88; // weak
int dword_68B8C; // weak
int dword_68B90; // weak
__time_t dword_68B94[3]; // weak
_UNKNOWN unk_68BA0; // weak
double dbl_68BA8[11]; // weak
int dword_68C00; // weak
int dword_68C04; // weak
pthread_mutex_t mutex; // idb
pthread_cond_t cond; // idb
char byte_68C50; // weak
pthread_mutex_t stru_68C54; // idb
int dword_68C6C; // weak
int dword_68C70; // weak
int dword_68C78; // weak
pthread_mutex_t stru_68C7C; // idb
int dword_68C94; // weak
int dword_68C98; // weak
int dword_68C9C; // weak
_UNKNOWN unk_68CA0; // weak
_UNKNOWN unk_696A0; // weak
int dword_6A0A0; // weak
double dbl_6A0A8; // weak
char byte_6A0B0[256]; // weak
pthread_rwlock_t stru_6A1B0; // idb
int dword_6A1D0; // weak
char byte_6A1D4[8]; // weak
_UNKNOWN unk_6A1DC; // weak
char byte_6A1FC[32]; // weak
char dest[8]; // idb
char byte_6A224; // weak
int dword_6A228; // weak
int dword_6A22C; // weak
int dword_6A230; // weak
int dword_6A234; // weak
int dword_6A238; // weak
_UNKNOWN unk_6A23C; // weak
_UNKNOWN unk_6A240; // weak
int dword_6A254; // weak
int dword_6A258; // weak
char byte_6A25C[4]; // weak
char byte_6A35C[256]; // idb
_UNKNOWN unk_6A464; // weak
int dword_6A484; // weak
int dword_6A488; // weak
int dword_6A48C[65]; // weak
char byte_6A590; // weak
_UNKNOWN unk_6A594; // weak
int dword_6A6B0; // weak
char byte_6A6B8[24]; // weak
char byte_6A6D0[16]; // weak
unsigned __int8 byte_6A6E0[253]; // weak
char byte_6A7DD; // weak
__int64 qword_6A7E8; // weak
int dword_6A7F0; // weak
int dword_6A7F4; // weak
int dword_6A7F8; // weak
pthread_mutex_t stru_6A7FC; // weak
int dword_6A814; // weak
_UNKNOWN unk_6A818; // weak
_UNKNOWN unk_6E818; // weak
char s2[17404]; // idb
int dword_72C18; // weak
_BYTE algn_72C1C[4]; // weak
_UNKNOWN unk_72C20; // weak
int (__fastcall *off_72C2C)(_DWORD); // weak
_UNKNOWN unk_72C98; // weak
_UNKNOWN unk_72D10; // weak
int (__fastcall *off_72D1C)(_DWORD); // weak
double dbl_72D88; // weak
char byte_72D90; // weak
pthread_mutex_t stru_72D94; // weak
int dword_72DAC; // weak
int dword_72DB0; // weak
int dword_72DB4; // weak
int dword_72DB8; // weak
int dword_72DBC; // weak
int dword_72DC0; // weak
__int64 qword_72DC8; // weak
struct sigaction stru_72DD0; // weak
char byte_72E5C; // weak
int dword_72E60; // weak
char byte_72E64; // weak
pthread_cond_t stru_72E68; // weak
char byte_72E98; // weak
pthread_rwlock_t stru_72E9C; // weak
double dbl_72EC0; // weak
char byte_72EC8; // weak
int dword_72ED0; // weak
pthread_mutex_t stru_72ED8; // weak
__int64 qword_72EF0; // weak
double dbl_72EF8; // weak
int dword_72F04; // weak
int dword_72F08; // weak
int dword_72F0C; // weak
int dword_72F10; // weak
int dword_72F14; // weak
int dword_73F1C; // weak
int dword_73F20; // weak
int dword_74F24; // weak
double dbl_74F28; // weak
char byte_74F30; // weak
int dword_74F38; // weak
int dword_74F3C; // weak
int dword_74F60; // weak
char byte_74F65; // weak
int dword_74F68; // weak
pthread_mutex_t stru_74F6C; // weak
char byte_74F84; // weak
int dword_74F88; // weak
int dword_74F8C; // weak
pthread_rwlock_t stru_74F90; // weak
double dbl_74FB0; // weak
__int64 qword_74FB8; // weak
pthread_rwlock_t stru_74FC0; // weak
int dword_74FE0; // weak
pthread_mutex_t stru_74FE4; // weak
int dword_74FFC[3]; // weak
__int64 qword_75008; // weak
char byte_75010; // weak
char byte_76014; // weak
pthread_mutex_t stru_76018; // weak
char byte_76030; // weak
int dword_76038; // weak
int dword_7603C; // weak
int dword_76060; // weak
int dword_76064; // weak
char byte_76068; // weak
int dword_7606C; // weak
int dword_76070; // weak
int dword_76074; // weak
char byte_76078; // weak
char byte_7607A; // weak
int dword_76080; // weak
struct sigaction stru_76084; // weak
pthread_mutex_t stru_76110; // weak
pthread_rwlock_t stru_76128; // idb
pthread_mutex_t stru_76148; // weak
pthread_rwlock_t rwlock; // idb
int dword_76188; // weak
int dword_76194; // weak
pthread_cond_t stru_76198; // weak
double dbl_761C8; // weak
char byte_761D0; // weak
int dword_761D4; // weak
int dword_761D8; // weak
int dword_761DC; // weak
int dword_761E0; // weak
char byte_761E4[68]; // weak
int dword_76228; // weak
int dword_76230; // weak
char byte_76234; // weak
struct sigaction stru_76238; // weak
char byte_762C4; // weak
__int64 qword_762C8; // weak
double dbl_762D0; // weak
double dbl_762D8; // weak
char byte_762E0; // weak
int dword_762E4; // weak
int dword_762E8; // weak
int dword_762EC; // weak
int dword_762F0; // weak
int dword_762F4; // weak
int dword_762F8; // weak
_UNKNOWN unk_762FC; // weak
pthread_mutex_t stru_76300; // weak
_UNKNOWN unk_76318; // weak
int dword_7631C; // weak
int dword_76320; // weak
char byte_76324; // weak
char byte_76424[16]; // idb
char byte_76434[32]; // idb
char byte_76454[3780]; // idb
char src[48]; // idb
double dbl_77CF0; // weak
char byte_77CF8[32]; // weak
int dword_77D18; // weak
int dword_77D1C; // weak
int dword_77D20; // weak
pthread_mutex_t stru_77D28; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (000123FC) --------------------------------------------------------
int init_proc()
{
  return sub_16608();
}

//----- (00012408) --------------------------------------------------------
void sub_12408()
{
  JUMPOUT(0);
}
// 12414: control flows out of bounds to 0

//----- (00012CF0) --------------------------------------------------------
void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  const char *v4; // r7
  FILE *v5; // r8
  size_t v6; // r0
  size_t v7; // r5
  int v8; // r8
  unsigned __int8 *v9; // r6
  size_t i; // r4
  const unsigned __int16 **v11; // r0
  int v12; // t1
  int v13; // r3
  int v14; // r0
  int (*v15)(void); // r2
  int (**v16)(); // r3
  bool v17; // zf
  int v18; // r0
  char *v19; // r0
  int v20; // r3
  char *v21; // r5
  char *v22; // r6
  int v23; // r4
  const char **v24; // r7
  const char *v25; // t1
  char *v26; // r0
  const char *v27; // r0
  int v28; // r4
  char *v29; // r0
  char *v30; // r7
  char *v31; // r6
  char *v32; // r0
  size_t v33; // r0
  int *v34; // lr
  char *v35; // r5
  size_t v36; // r0
  char *v37; // r10
  unsigned int v38; // r12
  int v39; // r6
  int v40; // r3
  unsigned __int8 *v41; // r9
  unsigned int v42; // r12
  unsigned __int8 *v43; // r0
  unsigned int v44; // r1
  unsigned int v45; // r2
  int v46; // r3
  unsigned int v47; // r1
  unsigned int v48; // r2
  int v49; // r3
  unsigned int v50; // r1
  unsigned int v51; // r2
  unsigned int v52; // r6
  int v53; // r3
  unsigned int v54; // r12
  unsigned int v55; // r2
  int v56; // r3
  unsigned int v57; // r1
  unsigned int v58; // r2
  unsigned int v59; // r3
  unsigned int v60; // r4
  size_t v61; // r0
  int *v62; // r3
  int v63; // r6
  int v64; // r3
  char *v65; // r7
  int v66; // r3
  int v67; // r4
  int v68; // r2
  _DWORD *v69; // r2
  int v70; // r1
  int v71; // r3
  _DWORD *v72; // r7
  int v73; // r2
  int v74; // r2
  _DWORD *v75; // r0
  _DWORD *v76; // r6
  _DWORD *v77; // r8
  int v78; // r4
  char *v79; // r10
  unsigned int v80; // r3
  int v81; // r2
  int v82; // r3
  _DWORD *v83; // r3
  unsigned int v84; // r2
  unsigned int v85; // r1
  bool v86; // cc
  int v87; // r2
  int v88; // r3
  char *v89; // r0
  _BYTE *v90; // r5
  _DWORD *v91; // r0
  char **v92; // r3
  _DWORD *v93; // r2
  int *v94; // r3
  int v95; // r0
  int v96; // r1
  __int16 v97; // r3
  int v98; // r3
  int v99; // r3
  char *v100; // r8
  int v101; // r4
  _BYTE *v102; // r5
  _BYTE *v103; // r0
  unsigned __int8 *v104; // r1
  char *v105; // r4
  const char *v106; // r1
  const char *v107; // r1
  const char *v108; // r4
  const char *v109; // r3
  int v110; // r3
  char *v111; // r4
  int v112; // r2
  int v113; // r4
  int v114; // r1
  int v115; // r5
  pthread_rwlock_t *v116; // r0
  char *v117; // r0
  int v118; // r4
  unsigned int v119; // r5
  char *j; // r0
  const char *v121; // r0
  int v122; // r0
  bool v123; // zf
  int v124; // r0
  int v125; // r3
  int v126; // r3
  int v127; // r4
  int *v128; // r9
  int v129; // r0
  int v130; // r3
  int v131; // r3
  char *v132; // r6
  char *v133; // r9
  int i2; // r4
  int v135; // r0
  int v136; // r3
  void *v137; // r0
  void **v138; // r8
  void *v139; // r0
  char *v140; // r12
  int *v141; // lr
  int v142; // r0
  int v143; // r1
  int v144; // r2
  int v145; // r3
  _DWORD *v146; // r12
  _DWORD *v147; // lr
  int v148; // r1
  const char *v149; // r1
  int v150; // r0
  int v151; // r3
  int v152; // r0
  int v153; // r12
  int v154; // r1
  int v155; // r3
  int v156; // r0
  int v157; // r12
  int k; // r3
  int v159; // r2
  char *v160; // r9
  int v161; // r6
  int m; // r4
  int v163; // r3
  int n; // r8
  _DWORD *v165; // r3
  int v166; // r4
  int v167; // r3
  const char *v168; // r0
  size_t v169; // r5
  size_t v170; // r5
  char *v171; // r0
  const char *v172; // r3
  char *v173; // r8
  __sighandler_t v174; // r4
  __sighandler_t v175; // r0
  bool v176; // zf
  __pid_t v177; // r0
  __pid_t v178; // r4
  size_t v179; // r0
  int ii; // r4
  int v181; // r5
  int v182; // r4
  _DWORD *v183; // r5
  _DWORD *v184; // r0
  int v185; // r2
  char *v186; // r7
  sem_t *v187; // r0
  sem_t *v188; // r6
  int *v189; // r10
  int *v190; // r7
  char *v191; // r6
  int *v192; // r0
  int v193; // r12
  int v194; // r1
  int v195; // r0
  int v196; // lr
  int v197; // r5
  int v198; // r5
  int v199; // r3
  int *v200; // r0
  int v201; // r2
  int v202; // r3
  int v203; // r1
  int v204; // r4
  int v205; // r5
  int v206; // r3
  const char **v207; // r8
  char *v208; // r5
  int *v209; // r4
  pthread_mutex_t *v210; // r0
  int v211; // r3
  int v212; // r0
  unsigned __int8 *v213; // r8
  int v214; // r3
  int v215; // r1
  int v216; // r3
  void **v217; // r0
  int v218; // r0
  _DWORD *v219; // r8
  int v220; // r3
  int v221; // r1
  int v222; // r3
  void **v223; // r0
  int kk; // r3
  _DWORD *v225; // r12
  int v226; // r3
  int v227; // r3
  char *v228; // r10
  int v229; // r3
  int v230; // r5
  int v231; // r1
  int v232; // r3
  int v233; // r12
  int v234; // r0
  int nn; // r3
  _DWORD *v236; // r12
  int v237; // r3
  int v238; // r3
  char *v239; // r10
  int v240; // r3
  int v241; // r5
  int v242; // r1
  int v243; // r3
  int v244; // r12
  int v245; // r0
  int mm; // r10
  int v247; // r0
  _DWORD *v248; // r1
  char *v249; // r2
  pthread_mutex_t *v250; // r10
  void **v251; // r8
  char *v252; // r1
  void **v253; // r3
  int v254; // r3
  const char *v255; // lr
  char *v256; // r12
  int v257; // r0
  int v258; // r1
  int v259; // r2
  int v260; // r3
  _DWORD *v261; // lr
  _DWORD *v262; // r12
  int v263; // r1
  int v264; // r2
  _DWORD *v265; // r1
  int i1; // r10
  int v267; // r0
  unsigned __int8 *v268; // r1
  unsigned __int8 *v269; // r1
  void **v270; // r10
  __time_t *v271; // r8
  void **v272; // r3
  int *v273; // r0
  int *v274; // r0
  int v275; // r0
  int v276; // r1
  int v277; // r3
  int v278; // r12
  char *v279; // r6
  int v280; // r3
  pthread_mutex_t *v281; // r0
  int v282; // r6
  int jj; // r4
  int *v284; // r0
  int *v285; // r0
  int v286; // r3
  int v287; // r4
  size_t v288; // r0
  int v289; // r0
  char v290; // [sp+10h] [bp-2A5Ch] BYREF
  char v291[4088]; // [sp+1018h] [bp-1A54h] BYREF
  const char *v292; // [sp+2010h] [bp-A5Ch]
  int *v293; // [sp+2020h] [bp-A4Ch]
  char *v294; // [sp+2024h] [bp-A48h]
  char *v295; // [sp+2028h] [bp-A44h]
  int *v296; // [sp+202Ch] [bp-A40h]
  int v297; // [sp+2030h] [bp-A3Ch]
  int *v298; // [sp+2034h] [bp-A38h]
  char **v299; // [sp+2038h] [bp-A34h]
  char *v300; // [sp+203Ch] [bp-A30h]
  char *v301; // [sp+2040h] [bp-A2Ch]
  char *v302; // [sp+2044h] [bp-A28h]
  char *v303; // [sp+2048h] [bp-A24h]
  char *v304; // [sp+204Ch] [bp-A20h]
  int *v305; // [sp+2050h] [bp-A1Ch]
  char *format; // [sp+2054h] [bp-A18h]
  const char **v307; // [sp+2058h] [bp-A14h]
  int v308; // [sp+205Ch] [bp-A10h] BYREF
  void **v309; // [sp+2064h] [bp-A08h] BYREF
  char v310[32]; // [sp+2068h] [bp-A04h] BYREF
  pthread_attr_t v311; // [sp+2088h] [bp-9E4h] BYREF
  struct sigaction s; // [sp+20ACh] [bp-9C0h] BYREF
  _DWORD v313[64]; // [sp+2138h] [bp-934h] BYREF
  int v314[513]; // [sp+2238h] [bp-834h] BYREF

  v308 = a1;
  v307 = a2;
  v309 = 0;
  pthread_attr_init(&v311);
  v303 = &byte_685B8;
  pthread_attr_setstacksize(&v311, 0x200000u);
  byte_685B8 = 0;
  v4 = *a2;
  memset(v313, 0, sizeof(v313));
  memset(&s, 0, 0x40u);
  snprintf((char *)&s, 0x40u, "pidof %s", v4);
  v5 = popen((const char *)&s, "r");
  if ( v5 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets((char *)v313, 256, v5) )
          {
            v7 = 0;
            pclose(v5);
            v8 = 0;
            format = "Parsed proc id is: %d\n";
            v9 = (unsigned __int8 *)v313;
            for ( i = 1; strlen((const char *)v313) >= i; ++i )
            {
              memset(v310, 0, sizeof(v310));
              v11 = _ctype_b_loc();
              v12 = *v9++;
              if ( ((*v11)[v12] & 0x2000) != 0 )
              {
                strncpy(v310, (const char *)v313 + v7, i - v7 - 1);
                v13 = strtol(v310, 0, 10);
                if ( v13 > 0 && (++v8, byte_686E1) && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
                {
                  v7 = i;
                  v305 = v314;
                  snprintf((char *)v314, 0x800u, format, v13);
                  sub_1DD60(7, (const char *)v314, 0);
                }
                else
                {
                  v7 = i;
                }
              }
            }
            if ( v8 )
            {
              if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
              {
                snprintf((char *)v314, 0x800u, " %d instance of %s is  already Running on this machine", v8, v4);
                sub_1DD60(3, (const char *)v314, 0);
              }
              if ( v8 != 1 )
              {
                snprintf((char *)v314, 0x800u, "%s is forbidden to start twice, will exit immediately!", *v307);
                sub_1DD60(3, (const char *)v314, 1);
                sub_2C230(-1, 0);
              }
            }
            goto LABEL_34;
          }
        }
        while ( !byte_686E1 );
        if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
          break;
LABEL_9:
        if ( byte_686E0 || dword_67840 > 6 )
        {
LABEL_11:
          v6 = strlen((const char *)v313);
          snprintf((char *)v314, 0x800u, "strlen is: %d\n", v6);
          sub_1DD60(7, (const char *)v314, 0);
        }
      }
      snprintf((char *)v314, 0x800u, "pidof %s command result is: %s\n", v4, (const char *)v313);
      sub_1DD60(7, (const char *)v314, 0);
      if ( byte_686E1 )
      {
        if ( byte_72D90 )
          goto LABEL_11;
        goto LABEL_9;
      }
    }
  }
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf((char *)v314, 0x800u, " app-service:%s Not Found!!!", v4);
    sub_1DD60(7, (const char *)v314, 0);
  }
LABEL_34:
  strcpy((char *)&dword_685E0, "bmminer.log");
  strcpy((char *)&word_685C0, "a+");
  v302 = (char *)&word_685C0;
  v14 = sysconf(84);
  v17 = v14 == 1;
  if ( v14 == 1 )
  {
    v16 = &off_67964;
    v15 = sched_yield;
  }
  v18 = v308 + 1;
  if ( v17 )
    *v16 = v15;
  format = byte_686E8;
  v19 = (char *)sub_1F828(4 * v18, "cgminer.c", "main", 12107);
  v20 = v308;
  v21 = v19;
  dword_68B64 = (int)v19;
  if ( v308 > 0 )
  {
    v22 = v19 - 4;
    v23 = 0;
    v24 = v307 - 1;
    do
    {
      v25 = v24[1];
      ++v24;
      ++v23;
      *((_DWORD *)v22 + 1) = _strdup(v25);
      v22 += 4;
      v20 = v308;
    }
    while ( v308 > v23 );
  }
  *(_DWORD *)&v21[4 * v20] = 0;
  sub_2CA10(&stru_72ED8, "main", 12116);
  sub_2CA10(&stru_76018, "main", 12117);
  sub_2CA10(&stru_74FE4, "main", 12118);
  sub_2CABC((int)&stru_76148, "main", 12119);
  sub_2CA10(&stru_72D94, "main", 12120);
  v305 = (int *)byte_6A6E0;
  sub_2CA10(&stru_68C7C, "main", 12121);
  sub_2CABC((int)&stru_76110, "main", 12122);
  sub_2CA10(&stru_68C54, "main", 12123);
  sub_2CA94(&stru_6A1B0, "main", 12124);
  sub_2CA94(&stru_72E9C, "main", 12125);
  sub_2CA94(&stru_74F90, "main", 12126);
  sub_2CA94(&stru_74FC0, "main", 12127);
  sub_2CA10(&mutex, "main", 12129);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v314, "Failed to pthread_cond_init lp_cond");
    sub_1DD60(3, (const char *)v314, 1);
    sub_2C230(1, 0);
  }
  sub_2CA10(&stru_74F6C, "main", 12136);
  if ( pthread_cond_init(&stru_76198, 0) )
  {
    strcpy((char *)v314, "Failed to pthread_cond_init restart_cond");
    sub_1DD60(3, (const char *)v314, 1);
    sub_2C230(1, 0);
  }
  if ( pthread_cond_init(&stru_72E68, 0) )
  {
    strcpy((char *)v314, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v26 = sub_1FFFC();
    dword_74F60 = (int)v26;
    if ( v26 )
    {
      v292 = (const char *)&unk_55C40;
      *((_DWORD *)format + 270) = v26 + 12;
      snprintf(::s, 0x100u, "%s %s", "cgminer", v292);
      s.sa_handler = (__sighandler_t)sub_2C30C;
      s.sa_flags = 0;
      sigemptyset(&s.sa_mask);
      sigaction(15, &s, &stru_72DD0);
      sigaction(2, &s, &stru_76084);
      sigaction(6, &s, &stru_76238);
      strcpy(v291, "/usr/bin");
      dword_76230 = (int)v291;
      dword_76070 = (int)&v290;
      v27 = *v307;
      v300 = (char *)&dword_76230;
      v28 = 36;
      v301 = "/";
      v29 = _strdup(v27);
      v30 = (char *)dword_76070;
      v31 = v29;
      v32 = dirname(v29);
      strcpy(v30, v32);
      free(v31);
      v33 = strlen((const char *)dword_76070);
      v34 = v305;
      strcpy((char *)(dword_76070 + v33), "/");
      *(int *)((char *)v34 + 0xFFFFFD7C) = 9;
      v35 = (char *)sub_1F8B0(0x68u, 1u, "cgminer.c", "main", 12183);
      do
      {
        v36 = strlen(v35);
        --v28;
        *(_WORD *)&v35[v36] = 48;
      }
      while ( v28 );
      v37 = (char *)(v36 + 1);
      v38 = -1640531527;
      v39 = -17973521;
      v304 = (char *)(v36 + 1);
      v40 = -1640531527;
      if ( v36 + 1 <= 0xB )
      {
        v43 = (unsigned __int8 *)v35;
        v37 = v304;
      }
      else
      {
        v41 = (unsigned __int8 *)(v35 + 12);
        do
        {
          v37 -= 12;
          v42 = (*(v41 - 6) << 16) + (*(v41 - 7) << 8) + *(v41 - 8) + (*(v41 - 5) << 24) + v38;
          v43 = v41;
          v44 = (*(v41 - 10) << 16) + (*(v41 - 11) << 8) + *(v41 - 12) + (*(v41 - 9) << 24) - v42;
          v45 = (*(v41 - 2) << 16) + (*(v41 - 3) << 8) + *(v41 - 4) + (*(v41 - 1) << 24) + v39;
          v41 += 12;
          v46 = (v44 - v45 + v40) ^ (v45 >> 13);
          v47 = (v42 - v45 - v46) ^ (v46 << 8);
          v48 = (v45 - v46 - v47) ^ (v47 >> 13);
          v49 = (v46 - v47 - v48) ^ (v48 >> 12);
          v50 = (v47 - v48 - v49) ^ (v49 << 16);
          v51 = (v48 - v49 - v50) ^ (v50 >> 5);
          v40 = (v49 - v50 - v51) ^ (v51 >> 3);
          v38 = (v50 - v51 - v40) ^ (v40 << 10);
          v39 = (v51 - v40 - v38) ^ (v38 >> 15);
        }
        while ( (unsigned int)v37 > 0xB );
      }
      v52 = (unsigned int)&v304[v39];
      switch ( (unsigned int)v37 )
      {
        case 1u:
          goto LABEL_61;
        case 2u:
          goto LABEL_60;
        case 3u:
          goto LABEL_59;
        case 4u:
          goto LABEL_58;
        case 5u:
          goto LABEL_57;
        case 6u:
          goto LABEL_56;
        case 7u:
          goto LABEL_55;
        case 8u:
          goto LABEL_54;
        case 9u:
          goto LABEL_53;
        case 0xAu:
          goto LABEL_52;
        case 0xBu:
          v52 += v43[10] << 24;
LABEL_52:
          v52 += v43[9] << 16;
LABEL_53:
          v52 += v43[8] << 8;
LABEL_54:
          v38 += v43[7] << 24;
LABEL_55:
          v38 += v43[6] << 16;
LABEL_56:
          v38 += v43[5] << 8;
LABEL_57:
          v38 += v43[4];
LABEL_58:
          v40 += v43[3] << 24;
LABEL_59:
          v40 += v43[2] << 16;
LABEL_60:
          v40 += v43[1] << 8;
LABEL_61:
          v40 += *v43;
          break;
        default:
          break;
      }
      *((_DWORD *)v35 + 22) = v35;
      v53 = (v40 - v38 - v52) ^ (v52 >> 13);
      v54 = (v38 - v52 - v53) ^ (v53 << 8);
      v55 = (v52 - v53 - v54) ^ (v54 >> 13);
      v56 = (v53 - v54 - v55) ^ (v55 >> 12);
      v57 = (v54 - v55 - v56) ^ (v56 << 16);
      v58 = (v55 - v56 - v57) ^ (v57 >> 5);
      v59 = v56 - v57 - v58;
      v60 = (v58 - (v59 ^ (v58 >> 3)) - ((v57 - v58 - (v59 ^ (v58 >> 3))) ^ ((v59 ^ (v58 >> 3)) << 10)))
          ^ (((v57 - v58 - (v59 ^ (v58 >> 3))) ^ ((v59 ^ (v58 >> 3)) << 10)) >> 15);
      *((_DWORD *)v35 + 24) = v60;
      v61 = strlen(v35);
      v62 = v305;
      *((_DWORD *)v35 + 23) = v61;
      v63 = *(int *)((char *)v62 + 0xFFFFFAF0);
      if ( v63 )
      {
        v64 = *(_DWORD *)(v63 + 68);
        *((_DWORD *)v35 + 19) = 0;
        v65 = v35 + 68;
        *((_DWORD *)v35 + 17) = v64;
        *((_DWORD *)v35 + 18) = *(_DWORD *)(*(_DWORD *)(v63 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v63 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v63 + 68) + 16) + 8) = v35;
        *(_DWORD *)(*(_DWORD *)(v63 + 68) + 16) = v35 + 68;
      }
      else
      {
        *((_DWORD *)v35 + 19) = 0;
        *((_DWORD *)v35 + 18) = 0;
        *(int *)((char *)v62 + 0xFFFFFAF0) = (int)v35;
        v137 = malloc(0x2Cu);
        *((_DWORD *)v35 + 17) = v137;
        if ( !v137 )
          goto LABEL_184;
        memset(v137, 0, 0x2Cu);
        v65 = v35 + 68;
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 16) = v35 + 68;
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 4) = 32;
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 8) = 5;
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 20) = 68;
        v138 = (void **)*((_DWORD *)v35 + 17);
        *v138 = malloc(0x180u);
        v139 = (void *)**((_DWORD **)v35 + 17);
        if ( !v139 )
          goto LABEL_184;
        memset(v139, 0, 0x180u);
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 40) = -1609490463;
      }
      v66 = *(int *)((char *)v305 + 0xFFFFFAF0);
      ++*(_DWORD *)(*(_DWORD *)(v66 + 68) + 12);
      v67 = 12 * (v60 & (*(_DWORD *)(*(_DWORD *)(v66 + 68) + 4) - 1));
      ++*(_DWORD *)(**(_DWORD **)(v66 + 68) + v67 + 4);
      v68 = *(_DWORD *)(**(_DWORD **)(v66 + 68) + v67);
      *((_DWORD *)v35 + 20) = 0;
      *((_DWORD *)v35 + 21) = v68;
      v69 = *(_DWORD **)(v66 + 68);
      v70 = *(_DWORD *)(*v69 + v67);
      if ( v70 )
      {
        *(_DWORD *)(v70 + 12) = v65;
        v69 = *(_DWORD **)(v66 + 68);
      }
      *(_DWORD *)(*v69 + v67) = v65;
      if ( *(_DWORD *)(**(_DWORD **)(v66 + 68) + v67 + 4) < (unsigned int)(10
                                                                         * *(_DWORD *)(**(_DWORD **)(v66 + 68) + v67 + 8)
                                                                         + 10)
        || (v71 = *((_DWORD *)v35 + 17), *(_DWORD *)(v71 + 36) == 1) )
      {
LABEL_85:
        strcpy(byte_761E4, v35);
        dword_72F0C = (int)&dword_72F0C;
        dword_72F10 = (int)&dword_72F0C;
        sub_3EE68((int)&off_67A68, (int)"Options for both config file and command line");
        sub_3EE68((int)&off_68204, (int)"Options for command line only");
        sub_3EF3C(&v308, v307, (void (*)(const char *, ...))sub_28370);
        if ( v308 != 1 )
        {
          strcpy((char *)v314, "Unexpected extra commandline arguments");
          sub_1DD60(3, (const char *)v314, 1);
          sub_2C230(1, 0);
        }
        if ( !format[808] )
          sub_2B46C();
        *(int *)((char *)v305 + 0xFFFFFD80) = 8;
        v89 = (char *)sub_1F8B0(8u, 0x40u, "cgminer.c", "main", 12219);
        dword_72DC0 = (int)v89;
        v298 = &dword_72DC0;
        *((_DWORD *)format + 290) = 1;
        v297 = sub_22F54((int)(v89 + 64), &v311, (void *(*)(void *))sub_29BFC, v89 + 64);
        if ( v297 )
        {
          strcpy((char *)v314, "API thread create failed");
          sub_1DD60(3, (const char *)v314, 1);
          sub_2C230(1, 0);
        }
        v17 = format[1384] == 0;
        v299 = (char **)&dword_72DB0;
        if ( !v17 || dword_72DB0 )
        {
          v90 = sub_3003C();
          v91 = sub_1F828(0xFFu, "cgminer.c", "main", 12236);
          v92 = v299;
          v93 = v91;
          *((_DWORD *)v90 + 41) = v91;
          if ( *v92 )
            LOWORD(v94) = 16936;
          else
            LOWORD(v94) = 16948;
          HIWORD(v94) = 5;
          v95 = *v94;
          v96 = v94[1];
          v97 = *((_WORD *)v94 + 4);
          *v93 = v95;
          v93[1] = v96;
          *((_WORD *)v93 + 4) = v97;
          v98 = *((_DWORD *)v90 + 41);
          *((_DWORD *)v90 + 43) = v98;
          *((_DWORD *)v90 + 44) = v98;
          *((_DWORD *)v90 + 42) = v98;
          *((_DWORD *)v90 + 154) = v98;
          strncpy(v90 + 48, "?", 7u);
          v99 = *((_DWORD *)v90 + 25);
          v90[55] = 0;
          if ( v99 != 1 )
            sub_28F90((_DWORD *)v90 + 25);
          v100 = (char *)&unk_68CA0;
          v101 = 0;
          v90[97] = 0;
          v102 = &unk_696A0;
          byte_686E2 = 1;
          do
          {
            v103 = v100;
            v100 += 160;
            sub_1FB44(v103, (unsigned __int8 *)&a000000029c6bf4[v101], 160);
            v104 = (unsigned __int8 *)&a00000002c01f50[v101];
            v101 += 324;
            sub_1FB44(v102, v104, 160);
            v102 += 160;
          }
          while ( v101 != 5184 );
          sub_2B4D0(&unk_6A464);
        }
        if ( *((_DWORD *)format + 132) )
          sub_3DA90();
        v105 = format;
        v106 = (const char *)*((_DWORD *)format + 128);
        if ( v106 )
        {
          *v303 = 1;
          strcpy((char *)&dword_685E0, v106);
          v107 = (const char *)*((_DWORD *)v105 + 131);
          if ( v107 )
            strcpy((char *)&word_685C0, v107);
          if ( !byte_72D90 )
          {
            v307 = (const char **)&byte_686E0;
            if ( !byte_686E0 && dword_67840 <= 2 )
            {
              v108 = (const char *)*((_DWORD *)format + 130);
              if ( !v108 )
              {
LABEL_109:
                if ( dword_67840 <= 3 )
                {
                  v109 = (const char *)*((_DWORD *)format + 200);
                  if ( !v109 )
                    goto LABEL_120;
LABEL_111:
                  if ( dword_67840 <= 4 )
                  {
                    v110 = *((_DWORD *)format + 253);
                    if ( v110 != -1 )
                      goto LABEL_113;
LABEL_206:
                    if ( !*(_BYTE *)v307 && dword_67840 <= 3 )
                    {
                      if ( !byte_7607A )
                        goto LABEL_119;
                      goto LABEL_209;
                    }
LABEL_211:
                    strcpy((char *)v314, "Error in configuration file, partially loaded.");
                    sub_1DD60(4, (const char *)v314, 0);
                    if ( !byte_7607A )
                      goto LABEL_119;
                    if ( byte_72D90 || *(_BYTE *)v307 )
                      goto LABEL_210;
LABEL_209:
                    if ( dword_67840 > 3 )
                    {
LABEL_210:
                      strcpy((char *)v314, "Start cgminer with -T to see what failed to load.");
                      sub_1DD60(4, (const char *)v314, 0);
                    }
LABEL_119:
                    v111 = format;
                    free(*((void **)format + 200));
                    *((_DWORD *)v111 + 200) = 0;
                    goto LABEL_120;
                  }
LABEL_112:
                  snprintf((char *)v314, 0x800u, "Loaded configuration file %s", v109);
                  sub_1DD60(5, (const char *)v314, 0);
                  v110 = *((_DWORD *)format + 253);
                  if ( v110 != -1 )
                  {
LABEL_113:
                    if ( !v110 )
                    {
                      if ( (byte_72D90 || *(_BYTE *)v307 || dword_67840 > 3)
                        && ((strcpy((char *)v314, "Fatal JSON error in configuration file."),
                             sub_1DD60(4, (const char *)v314, 0),
                             byte_72D90)
                         || *(_BYTE *)v307)
                        || dword_67840 > 3 )
                      {
                        strcpy((char *)v314, "Configuration file could not be used.");
                        sub_1DD60(4, (const char *)v314, 0);
                      }
                    }
                    goto LABEL_119;
                  }
                  if ( byte_72D90 )
                    goto LABEL_211;
                  goto LABEL_206;
                }
LABEL_177:
                snprintf((char *)v314, 0x800u, "Started %s", ::s);
                sub_1DD60(4, (const char *)v314, 0);
                v109 = (const char *)*((_DWORD *)format + 200);
                if ( !v109 )
                {
LABEL_120:
                  *(_WORD *)(*(_DWORD *)v300 + strlen(*(const char **)v300)) = *(_WORD *)v301;
                  if ( byte_76014 )
                  {
                    *(_BYTE *)v307 = 1;
                  }
                  else if ( !*(_BYTE *)v307 )
                  {
                    setlogmask(63);
LABEL_123:
                    v112 = dword_681F4;
                    LOWORD(v113) = (unsigned __int16)&unk_684F0;
                    if ( dword_681F4 < 0 )
                      v112 = 60;
                    HIWORD(v113) = (unsigned int)&unk_684F0 >> 16;
                    if ( dword_681F4 < 0 )
                      dword_681F4 = v112;
                    sub_3C3EC((int)&unk_72C98);
                    sub_3C3EC((int)&unk_72C20);
                    sub_3C3EC((int)&unk_72D10);
                    v304 = (char *)&dword_76228;
                    sub_3C3EC(v113);
                    (*(void (__fastcall **)(_DWORD))(v114 + 12))(0);
                    off_72C2C(0);
                    off_72D1C(0);
                    v115 = 0;
                    (*(void (__fastcall **)())(v113 + 0xC))();
                    dword_76228 = 0;
                    while ( dword_74FE0 > v115 )
                    {
                      v116 = *(pthread_rwlock_t **)(dword_74F68 + 4 * v115++);
                      sub_3C634(v116);
                    }
                    if ( !dword_74FE0 )
                    {
                      strcpy((char *)v314, "All devices disabled, cannot mint!");
                      sub_1DD60(3, (const char *)v314, 1);
                      sub_2C230(1, 0);
                    }
                    v117 = (char *)*((_DWORD *)format + 256);
                    *(int *)((char *)v305 + 0xFFFFFB58) = dword_74FE0;
                    if ( v117 )
                    {
                      v118 = 0;
                      v119 = 0;
                      for ( j = strtok(v117, (const char *)&word_51D00); j; j = strtok(v303, (const char *)&word_51D00) )
                      {
                        if ( dword_74FE0 <= v118 )
                        {
                          strcpy((char *)v314, "Too many values passed to set temp cutoff");
                          sub_1DD60(3, (const char *)v314, 1);
                          sub_2C230(1, 1);
                        }
                        v119 = strtol(j, 0, 10);
                        if ( v119 > 0xC8 )
                        {
                          v140 = "ssed to set temp cutoff";
                          qmemcpy(v314, "Invalid value pa", 16);
                          v141 = &v314[4];
                          goto LABEL_200;
                        }
                        if ( pthread_rwlock_rdlock(&stru_74FC0) )
                          sub_2DCC0("load_temp_cutoffs", 1385);
                        *(_DWORD *)(*(_DWORD *)(dword_74F68 + 4 * v118) + 184) = v119;
                        if ( pthread_rwlock_unlock(&stru_74FC0) )
                        {
                          v200 = _errno_location();
                          snprintf(
                            (char *)v314,
                            0x800u,
                            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                            *v200,
                            "cgminer.c",
                            "load_temp_cutoffs",
                            1387);
                          v149 = (const char *)v314;
                          goto LABEL_201;
                        }
                        ++v118;
                        v303 = 0;
                        off_67964();
                      }
                      if ( v118 <= 1 )
                      {
                        if ( pthread_rwlock_rdlock(&stru_74FC0) )
                          sub_2DCC0("load_temp_cutoffs", 1408);
                        v201 = dword_74FE0;
                        v303 = (char *)&dword_74F68;
                        v202 = dword_74F68;
                        while ( v118 < v201 )
                        {
                          v203 = *(_DWORD *)(v202 + 4 * v118++);
                          *(_DWORD *)(v203 + 184) = v119;
                        }
                        sub_2D708(&stru_74FC0, "load_temp_cutoffs", 1414);
                      }
                      else
                      {
                        v303 = (char *)&dword_74F68;
                      }
                    }
                    else
                    {
                      v152 = pthread_rwlock_rdlock(&stru_74FC0);
                      if ( v152 )
                        sub_2DCC0("load_temp_cutoffs", 1392);
                      v153 = dword_74FE0;
                      v303 = (char *)&dword_74F68;
                      v154 = dword_74F68;
                      while ( v152 < v153 )
                      {
                        v155 = *(_DWORD *)(v154 + 4 * v152++);
                        if ( !*(_DWORD *)(v155 + 184) )
                          *(_DWORD *)(v155 + 184) = 95;
                      }
                      sub_2D708(&stru_74FC0, "load_temp_cutoffs", 1401);
                    }
                    v156 = dword_74FE0;
                    v157 = *(_DWORD *)v303;
                    for ( k = 0; v156 > k; ++k )
                    {
                      v159 = *(_DWORD *)(v157 + 4 * k);
                      *(_DWORD *)(v159 + 312) = 99999999;
                    }
                    v301 = (char *)&dword_74FE0;
                    v160 = (char *)v314;
                    if ( !byte_76078 )
                      *(v305 - 161) = *(int *)((char *)v305 + 0xFFFFFD7C) + *(int *)((char *)v305 + 0xFFFFFB58);
                    v302 = (char *)&dword_67840;
                    while ( 1 )
                    {
                      v161 = 0;
                      for ( m = 0; m < dword_72E60; ++m )
                      {
                        v163 = *(_DWORD *)(dword_72F04 + 4 * m);
                        if ( **(_BYTE **)(v163 + 164) )
                        {
                          if ( **(_BYTE **)(v163 + 172) )
                          {
                            ++v161;
                          }
                          else if ( byte_686E1 && (byte_72D90 || *(_BYTE *)v307 || *(int *)v302 > 6) )
                          {
                            strcpy((char *)v314, "Blank worker exists.\n");
                            sub_1DD60(7, (const char *)v314, 0);
                          }
                        }
                      }
                      if ( v161 )
                        break;
                      if ( !*(int *)((char *)v305 + 0xFFFFFFB8) )
                      {
                        if ( byte_72D90 || *(_BYTE *)v307 || *(int *)v302 > 4 )
                        {
                          strcpy((char *)v314, "No valid pools, please configure them first!\n");
                          sub_1DD60(5, (const char *)v314, 0);
                        }
                        *(int *)((char *)v305 + 0xFFFFFFB8) = 1;
                      }
                      if ( byte_686E1 && (byte_72D90 || *(_BYTE *)v307 || *(int *)v302 > 6) )
                      {
                        strcpy((char *)v314, "check no pool and user retry!");
                        sub_1DD60(7, (const char *)v314, 0);
                      }
                      sleep(1u);
                    }
                    if ( !dword_72E60 )
                    {
                      if ( byte_72D90 || *(_BYTE *)v307 || dword_67840 > 3 )
                      {
                        strcpy((char *)v314, "Need to specify at least one pool server.");
                        sub_1DD60(4, (const char *)v314, 0);
                      }
                      strcpy((char *)v314, "Pool setup failed");
                      sub_1DD60(3, (const char *)v314, 1);
                      sub_2C230(1, 0);
                    }
                    v302 = (char *)&dword_72F04;
                    v300 = v301;
                    v301 = "cgminer.c";
                    for ( n = 0; ; ++n )
                    {
                      v165 = *(_DWORD **)v302;
                      if ( dword_72E60 <= n )
                        break;
                      v166 = v165[n];
                      v167 = *(_DWORD *)(v166 + 168);
                      *(_DWORD *)(v166 + 404) = 99999999;
                      *(_DWORD *)(v166 + 440) = 99999999;
                      if ( !v167 )
                      {
                        if ( !*(_DWORD *)(v166 + 176) )
                          *(_DWORD *)(v166 + 176) = calloc(1u, 1u);
                        v168 = *(const char **)(v166 + 172);
                        if ( !v168 )
                        {
                          snprintf(
                            (char *)v314,
                            0x800u,
                            "No login credentials supplied for pool %u %s",
                            n,
                            *(const char **)(v166 + 164));
                          sub_1DD60(3, (const char *)v314, 1);
                          sub_2C230(1, 0);
                        }
                        v169 = strlen(v168);
                        v170 = v169 + strlen(*(const char **)(v166 + 176)) + 2;
                        v171 = (char *)sub_1F828(v170, v301, "main", 12512);
                        v172 = *(const char **)(v166 + 176);
                        *(_DWORD *)(v166 + 168) = v171;
                        snprintf(v171, v170, "%s:%s", *(const char **)(v166 + 172), v172);
                      }
                    }
                    v173 = v300;
                    v17 = byte_72D90 == 0;
                    *((_DWORD *)format + 291) = *v165;
                    if ( !v17 )
                      openlog("cgminer", 1, 8);
                    if ( *(int *)((char *)v305 + 0xFFFFFFBC) )
                    {
                      if ( pipe(v314) < 0 )
                      {
                        perror("pipe - failed to create pipe for --monitor");
                        exit(1);
                      }
                      fflush((FILE *)stderr);
                      if ( dup2(v314[1], 2) < 0 )
                      {
                        perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                        exit(1);
                      }
                      if ( close(v314[1]) < 0 )
                      {
                        perror("close - failed to close write end of pipe for --monitor");
                        exit(1);
                      }
                      v174 = signal(13, (__sighandler_t)1);
                      v175 = signal(13, (__sighandler_t)1);
                      v176 = (__sighandler_t)((char *)v174 + 1) == 0;
                      if ( v174 != (__sighandler_t)-1 )
                        v176 = (__sighandler_t)((char *)v175 + 1) == 0;
                      if ( v176 )
                      {
                        perror("signal - failed to edit signal mask for --monitor");
                        exit(1);
                      }
                      v177 = fork();
                      v178 = v177;
                      *((_DWORD *)format + 265) = v177;
                      if ( v177 < 0 )
                      {
                        perror("fork - failed to fork child process for --monitor");
                        exit(1);
                      }
                      if ( !v177 )
                      {
                        if ( dup2(v314[0], v177) >= 0 )
                        {
                          close(v314[0]);
                          execl("/bin/bash", "/bin/bash", "-c", *(int *)((char *)v305 + 0xFFFFFFBC), v178);
                          perror("execl - in child failed to exec user specified command for --monitor");
                          exit(1);
                        }
                        perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                        exit(1);
                      }
                      if ( close(v314[0]) < 0 )
                      {
                        perror("close - failed to close read end of pipe for --monitor");
                        exit(1);
                      }
                    }
                    v179 = *(_DWORD *)v304;
                    v296 = &dword_73F20;
                    dword_73F20 = (int)sub_1F8B0(v179, 4u, "cgminer.c", "main", 12529);
                    for ( ii = 0; *(_DWORD *)v304 > ii; ++ii )
                    {
                      v181 = *v296;
                      *(_DWORD *)(v181 + 4 * ii) = sub_1F8B0(1u, 0x40u, "cgminer.c", "main", 12533);
                    }
                    v301 = 0;
                    v300 = 0;
                    v294 = &byte_686E1;
                    v295 = &byte_72D90;
                    v293 = &dword_72E60;
                    while ( *(_DWORD *)v173 > (int)v301 )
                    {
                      v182 = 0;
                      v183 = *(_DWORD **)(*(_DWORD *)v303 + 4 * (_DWORD)v301);
                      v184 = sub_1F828(4 * (v183[37] + 1), "cgminer.c", "main", 12542);
                      v185 = v183[37];
                      v183[38] = v184;
                      v184[v185] = 0;
                      v183[24] = 4;
                      while ( 1 )
                      {
                        v186 = &v300[v182];
                        if ( v183[37] <= v182 )
                          break;
                        v187 = (sem_t *)sub_2F688((int)&v300[v182]);
                        v187->__align = (int)v186;
                        v188 = v187;
                        *(&v187[2].__align + 1) = (int)v183;
                        *(&v187->__align + 1) = v182;
                        if ( (*(int (**)(void))(v183[1] + 44))() )
                        {
                          if ( sub_22F54((int)v188, &v311, (void *(*)(void *))sub_28E2C, v188) )
                          {
                            snprintf((char *)v314, 0x800u, "thread %d create failed", v188->__align);
                            sub_1DD60(3, (const char *)v314, 1);
                            sub_2C230(1, 0);
                          }
                          *(_DWORD *)(v183[38] + 4 * v182) = v188;
                          if ( v183[8] != 1 )
                          {
                            if ( *v294 && (*v295 || *(_BYTE *)v307 || dword_67840 > 6) )
                            {
                              snprintf((char *)v314, 0x800u, "Pushing sem post to thread %d", v188->__align);
                              sub_1DD60(7, (const char *)v314, 0);
                            }
                            sub_22F9C(v188 + 1, "cgminer.c", "main", 12570);
                          }
                        }
                        ++v182;
                      }
                      v300 += v182;
                      ++v301;
                    }
                    v189 = (int *)v295;
                    v190 = v293;
                    if ( format[1384] )
                      goto LABEL_310;
                    v191 = *v299;
                    if ( *v299 )
                      goto LABEL_310;
                    pthread_mutex_lock((pthread_mutex_t *)&unk_6A23C);
                    v301 = (char *)v314;
                    while ( *v190 > (int)v191 )
                    {
                      v204 = *(_DWORD *)(*(_DWORD *)v302 + 4 * (_DWORD)v191);
                      if ( *(_DWORD *)(v204 + 100) != 1 )
                        sub_28F90((_DWORD *)(v204 + 100));
                      ++v191;
                      *(_BYTE *)(v204 + 97) = 1;
                    }
                    v160 = v301;
                    if ( *((_DWORD *)format + 132) )
                      sub_3DA90();
                    if ( *(_BYTE *)v189 || *(_BYTE *)v307 || dword_67840 > 4 )
                    {
                      strcpy(v160, "Probing for an alive pool");
                      sub_1DD60(5, v160, 0);
                    }
                    sub_28CFC();
                    v205 = 0;
                    pthread_mutex_unlock((pthread_mutex_t *)&unk_6A23C);
                    do
                    {
                      ++v205;
                      sleep(1u);
                      if ( v205 == 180 )
                        v206 = 0;
                      else
                        v206 = ((unsigned __int8)format[796] ^ 1) & 1;
                    }
                    while ( v206 );
                    v300 = v173;
                    v207 = v307;
                    v301 = &byte_686E1;
                    while ( !format[796] )
                    {
                      if ( v206 )
                        goto LABEL_356;
                      if ( ((*(_BYTE *)v189 || *(_BYTE *)v207 || dword_67840 > 2)
                         && ((strcpy(v160, "No servers were found that could be used to get work from."),
                              sub_1DD60(3, v160, 0),
                              *(_BYTE *)v189)
                          || *(_BYTE *)v207)
                         || dword_67840 > 2)
                        && ((strcpy(v160, "Please check the details from the list below of the servers you have input"),
                             sub_1DD60(3, v160, 0),
                             *(_BYTE *)v189)
                         || *(_BYTE *)v207)
                        || dword_67840 > 2 )
                      {
                        strcpy(
                          v160,
                          "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                        sub_1DD60(3, v160, 0);
                      }
                      for ( jj = 0; *v190 > jj; ++jj )
                      {
                        if ( *(_BYTE *)v189 || *(_BYTE *)v207 || dword_67840 > 3 )
                        {
                          snprintf(
                            v160,
                            0x800u,
                            "Pool: %d  URL: %s  User: %s  Password: %s",
                            jj,
                            *(const char **)(*(_DWORD *)(*(_DWORD *)v302 + 4 * jj) + 164),
                            *(const char **)(*(_DWORD *)(*(_DWORD *)v302 + 4 * jj) + 172),
                            *(const char **)(*(_DWORD *)(*(_DWORD *)v302 + 4 * jj) + 176));
                          sub_1DD60(4, v160, 0);
                        }
                      }
                      if ( byte_7607A )
                      {
                        if ( !*(_BYTE *)v189 && !*(_BYTE *)v207 && dword_67840 <= 2 )
                          goto LABEL_362;
                        strcpy(v160, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                        sub_1DD60(3, v160, 0);
LABEL_356:
                        if ( byte_7607A )
                          goto LABEL_362;
                      }
                      if ( *v301 && (*(_BYTE *)v189 || *(_BYTE *)v207 || dword_67840 > 6) )
                      {
                        strcpy(v160, "No servers could be used! Exiting.");
                        sub_1DD60(7, v160, 0);
                      }
LABEL_362:
                      sub_208D4();
                      v206 = 1;
                    }
                    v286 = *(unsigned __int8 *)v189;
                    v173 = v300;
                    v313[0] = 28519;
                    if ( v286 || *(_BYTE *)v307 || dword_67840 > 4 )
                    {
                      snprintf(v160, 0x800u, "check success, send %s", (const char *)v313);
                      sub_1DD60(5, v160, 0);
                    }
                    v287 = 0;
                    while ( 1 )
                    {
                      v288 = strlen((const char *)v313);
                      v289 = sub_42680(v313, v288);
                      if ( !v289 )
                        break;
                      if ( *(_BYTE *)v189 || *(_BYTE *)v307 || dword_67840 > 4 )
                      {
                        snprintf(
                          v160,
                          0x800u,
                          "bitmain_flush_api fail: send %s, times=%d, ret=%d",
                          (const char *)v313,
                          v287,
                          v289);
                        sub_1DD60(5, v160, 0);
                      }
                      ++v287;
                      sub_208D4();
                      if ( v287 == 8 )
                        goto LABEL_310;
                    }
                    if ( *(_BYTE *)v189 || *(_BYTE *)v307 || dword_67840 > 4 )
                    {
                      snprintf(v160, 0x800u, "check success, send %s, times=%d", (const char *)v313, v287);
                      sub_1DD60(5, v160, 0);
                    }
LABEL_310:
                    v192 = (int *)&unk_68BA0;
                    dbl_72D88 = 0.0;
                    do
                    {
                      *(_QWORD *)v192 = 0;
                      v192 += 2;
                    }
                    while ( &dword_68C00 != v192 );
                    v193 = *(_DWORD *)v173;
                    v194 = v297;
                    v195 = *(_DWORD *)v303;
                    *((_DWORD *)format + 326) = 0;
                    while ( v193 > v194 )
                    {
                      v196 = *(_DWORD *)(v195 + 4 * v194++);
                      *(_QWORD *)(v196 + 80) = 0;
                      *(_QWORD *)(v196 + 48) = 0;
                    }
                    sub_206A0(&dword_68B30);
                    sub_206A0(&dword_68B28);
                    sub_206A0(dword_68B94);
                    sub_2A1B0(byte_68B38, 0x28u, &dword_68B30);
                    v197 = *v298;
                    *((_DWORD *)format + 288) = 3;
                    if ( sub_22F54(v197 + 192, &v311, (void *(*)(void *))sub_32050, 0) )
                    {
                      strcpy(v160, "watchpool thread create failed");
                      sub_1DD60(3, v160, 1);
                      sub_2C230(1, 0);
                    }
                    pthread_detach(*(_DWORD *)(v197 + 204));
                    v198 = *v298;
                    *((_DWORD *)format + 289) = 4;
                    if ( sub_22F54(v198 + 256, &v311, (void *(*)(void *))sub_36338, 0) )
                    {
                      strcpy(v160, "watchdog thread create failed");
                      sub_1DD60(3, v160, 1);
                      sub_2C230(1, 0);
                    }
                    pthread_detach(*(_DWORD *)(v198 + 268));
                    v199 = *(int *)((char *)v305 + 0xFFFFFD80);
                    if ( v199 != 8 )
                    {
                      snprintf(v160, 0x800u, "incorrect total_control_threads (%d) should be 8", v199);
                      sub_1DD60(3, v160, 1);
                      sub_2C230(1, 0);
                    }
                    if ( !nice(-10) && byte_686E1 && (*(_BYTE *)v189 || *(_BYTE *)v307 || dword_67840 > 6) )
                    {
                      strcpy(v160, "Unable to set thread to high priority");
                      sub_1DD60(7, v160, 0);
                    }
                    v208 = v302;
                    v209 = v305;
                    v300 = &byte_76068;
                    v301 = &byte_74F65;
                    v305 = v189;
LABEL_371:
                    while ( 2 )
                    {
                      if ( *v300 )
                      {
                        if ( *(_BYTE *)v305 || *(_BYTE *)v307 || dword_67840 > 5 )
                        {
                          strcpy(v160, "Work update message received");
                          sub_1DD60(6, v160, 0);
                        }
                        sub_206A0(dword_68AF4);
                        v275 = pthread_rwlock_rdlock(&stru_74F90);
                        if ( v275 )
                        {
                          v284 = _errno_location();
                          snprintf(
                            v160,
                            0x800u,
                            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                            *v284,
                            "cgminer.c",
                            "signal_work_update",
                            5570);
                          goto LABEL_489;
                        }
                        v276 = *(_DWORD *)v304;
                        v277 = *v296;
                        while ( v275 < v276 )
                        {
                          v278 = *(_DWORD *)(v277 + 4 * v275++);
                          *(_BYTE *)(v278 + 63) = 1;
                        }
                        if ( pthread_rwlock_unlock(&stru_74F90) )
                        {
                          v285 = _errno_location();
                          snprintf(
                            v160,
                            0x800u,
                            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                            *v285,
                            "cgminer.c",
                            "signal_work_update",
                            5577);
LABEL_489:
                          v149 = v160;
LABEL_201:
                          sub_1DD60(3, v149, 1);
                          sub_2C230(1, 1);
                        }
                        off_67964();
                      }
                      v210 = (pthread_mutex_t *)*((_DWORD *)format + 270);
                      *v300 = 0;
                      if ( pthread_mutex_lock(v210) )
                      {
                        v274 = _errno_location();
                        snprintf(
                          v160,
                          0x800u,
                          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                          *v274,
                          "cgminer.c",
                          "main",
                          12768);
                        goto LABEL_489;
                      }
                      v211 = *((_DWORD *)format + 327);
                      if ( v211
                        && *(int *)(*(_DWORD *)(v211 + 344) + 12) > 1
                        && (v279 = format,
                            pthread_cond_wait(&stru_72E68, *((pthread_mutex_t **)format + 270)),
                            (v280 = *((_DWORD *)v279 + 327)) != 0) )
                      {
                        v281 = (pthread_mutex_t *)*((_DWORD *)v279 + 270);
                        v282 = *(_DWORD *)(*(_DWORD *)(v280 + 344) + 12);
                        if ( pthread_mutex_unlock(v281) )
                        {
LABEL_488:
                          v273 = _errno_location();
                          snprintf(
                            v160,
                            0x800u,
                            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                            *v273,
                            "cgminer.c",
                            "main",
                            12779);
                          goto LABEL_489;
                        }
                        off_67964();
                        if ( v282 > 1 )
                        {
                          v309 = (void **)sub_32BF8(0);
                          if ( v309 )
                            sub_2AA08(&v309, "cgminer.c", "main", 12791);
                          continue;
                        }
                      }
                      else
                      {
                        if ( pthread_mutex_unlock(*((pthread_mutex_t **)format + 270)) )
                          goto LABEL_488;
                        off_67964();
                      }
                      break;
                    }
                    if ( v309 )
                      sub_2AA08(&v309, "cgminer.c", "main", 12799);
                    v303 = (char *)&unk_6A240;
                    v302 = "Selecting pool %d for work";
                    v309 = (void **)sub_2D914();
                    while ( 1 )
                    {
                      pthread_mutex_lock((pthread_mutex_t *)(v303 - 4));
                      v218 = sub_2FB78();
                      v219 = (_DWORD *)v218;
                      v220 = *((_DWORD *)format + 255);
                      if ( v220 == 4 )
                        break;
                      if ( v220 != 3 )
                        goto LABEL_380;
                      v221 = *v190;
                      v222 = 0;
                      v223 = *(void ***)v208;
                      while ( v222 < v221 )
                      {
                        if ( *((_DWORD *)v223[v222] + 16) < *((_DWORD *)v223[v222] + 15) )
                          goto LABEL_411;
                        ++v222;
                      }
                      for ( kk = 0; v221 > kk; ++kk )
                      {
                        v225 = v223[kk];
                        v225[16] = 0;
                      }
                      v226 = *(int *)((char *)v209 + 0xFFFFFFC0) + 1;
                      if ( v221 <= v226 )
                        v226 = 0;
                      *(int *)((char *)v209 + 0xFFFFFFC0) = v226;
LABEL_411:
                      v227 = 0;
                      v228 = v208;
                      while ( 1 )
                      {
                        v230 = v227 + 1;
                        if ( v227 >= *v190 )
                          break;
                        v231 = *(_DWORD *)(*(_DWORD *)v228 + 4 * *(int *)((char *)v209 + 0xFFFFFFC0));
                        v232 = *(_DWORD *)(v231 + 64);
                        v233 = *(_DWORD *)(v231 + 60);
                        *(_DWORD *)(v231 + 64) = v232 + 1;
                        if ( v232 < v233 )
                        {
                          if ( !*(_BYTE *)(v231 + 97)
                            && *(_DWORD *)(v231 + 100) == 1
                            && !sub_28FB0((unsigned __int8 *)v231) )
                          {
                            v208 = v228;
                            v219 = v265;
                            goto LABEL_447;
                          }
                          if ( *v301 )
                          {
                            v234 = sub_290E8(0);
                            --*(_DWORD *)(v234 + 64);
                          }
                        }
                        v229 = *(int *)((char *)v209 + 0xFFFFFFC0) + 1;
                        v86 = v229 < *v190;
                        *(int *)((char *)v209 + 0xFFFFFFC0) = v229;
                        if ( !v86 )
                          *(int *)((char *)v209 + 0xFFFFFFC0) = 0;
                        v227 = v230;
                      }
                      v208 = v228;
                      for ( mm = 0; ; ++mm )
                      {
                        if ( mm >= *v190 )
                          goto LABEL_380;
                        v247 = sub_290E8(mm);
                        if ( !*(_BYTE *)(v247 + 97)
                          && *(_DWORD *)(v247 + 100) == 1
                          && !sub_28FB0((unsigned __int8 *)v247) )
                        {
                          break;
                        }
                      }
                      v219 = v248;
LABEL_447:
                      if ( byte_686E1 )
                        goto LABEL_381;
LABEL_448:
                      if ( !sub_28FB0((unsigned __int8 *)v219) )
                      {
                        v249 = v303;
                        *(int *)((char *)v209 + 0xFFFFFB78) = 0;
                        v302 = 0;
                        v250 = (pthread_mutex_t *)(v249 - 4);
                        pthread_mutex_unlock((pthread_mutex_t *)(v249 - 4));
                        pthread_mutex_lock(v250);
                        if ( *(int *)((char *)v209 + 0xFFFFFB78) == 1 )
                        {
                          *(int *)((char *)v209 + 0xFFFFFB78) = (int)v302;
                          pthread_mutex_unlock(v250);
                        }
                        else if ( *((_BYTE *)v219 + 656) )
                        {
                          sub_335C8((int)v219, (int)v309);
                          if ( byte_686E1 && (*(_BYTE *)v305 || *(_BYTE *)v307 || dword_67840 > 6) )
                          {
                            strcpy(v160, "Generated stratum work");
                            sub_1DD60(7, v160, 0);
                          }
                          sub_3B058((int)v309);
                          v309 = 0;
                          pthread_mutex_unlock((pthread_mutex_t *)(v303 - 4));
                        }
                        else
                        {
                          pthread_mutex_unlock(v250);
                          v303 = *v299;
                          if ( v303 )
                          {
                            v270 = v309;
                            v271 = (__time_t *)(v309 + 100);
                            sub_2C5A8(v309);
                            v272 = *(void ***)v208;
                            *((_BYTE *)v270 + 282) = 1;
                            v270[65] = *v272;
                            sub_206A0(v271);
                            sub_235FC(v270 + 102, v271);
                            *((_BYTE *)v270 + 440) = 66;
                            sub_28A90((int)v270);
                            if ( byte_686E1 && (*(_BYTE *)v305 || *(_BYTE *)v307 || dword_67840 > 6) )
                            {
                              v255 = "Generated benchfile work";
                              v256 = v160;
LABEL_458:
                              v257 = *(_DWORD *)v255;
                              v258 = *((_DWORD *)v255 + 1);
                              v259 = *((_DWORD *)v255 + 2);
                              v260 = *((_DWORD *)v255 + 3);
                              v261 = v255 + 16;
                              *(_DWORD *)v256 = v257;
                              *((_DWORD *)v256 + 1) = v258;
                              *((_DWORD *)v256 + 2) = v259;
                              *((_DWORD *)v256 + 3) = v260;
                              v262 = v256 + 16;
                              v263 = v261[1];
                              v264 = v261[2];
                              *v262 = *v261;
                              v262[1] = v263;
                              *((_BYTE *)v262 + 8) = v264;
                              sub_1DD60(7, v160, 0);
                            }
LABEL_459:
                            sub_3B058((int)v309);
                            v309 = 0;
                          }
                          else if ( format[1384] )
                          {
                            v251 = v309;
                            *((_QWORD *)v309 + 47) = 0x4040000000000000LL;
                            sub_232EC(v251 + 40, &unk_6A464, 0x20u, (int)"cgminer.c", (int)"get_benchmark_work", 4329);
                            v252 = v303;
                            v253 = *(void ***)v208;
                            *((_BYTE *)v251 + 282) = 1;
                            v251[61] = v252;
                            v251[65] = *v253;
                            sub_206A0((__time_t *)v251 + 100);
                            sub_235FC(v251 + 102, v251 + 100);
                            v254 = (unsigned __int8)byte_686E1;
                            *((_BYTE *)v251 + 440) = 66;
                            if ( v254 && (*(_BYTE *)v305 || *(_BYTE *)v307 || dword_67840 > 6) )
                            {
                              v255 = "Generated benchmark work";
                              v256 = v160;
                              goto LABEL_458;
                            }
                            goto LABEL_459;
                          }
                        }
                        goto LABEL_371;
                      }
LABEL_387:
                      sub_31A9C(0);
                      v212 = sub_2FB78();
                      v213 = (unsigned __int8 *)v212;
                      v214 = *((_DWORD *)format + 255);
                      if ( v214 == 4 )
                      {
                        v213 = (unsigned __int8 *)sub_28FD4(v212);
LABEL_390:
                        if ( !byte_686E1 )
                          goto LABEL_395;
                        goto LABEL_391;
                      }
                      if ( v214 != 3 )
                        goto LABEL_390;
                      v215 = *v190;
                      v216 = 0;
                      v217 = *(void ***)v208;
                      while ( v216 < v215 )
                      {
                        if ( *((_DWORD *)v217[v216] + 16) < *((_DWORD *)v217[v216] + 15) )
                          goto LABEL_430;
                        ++v216;
                      }
                      for ( nn = 0; v215 > nn; ++nn )
                      {
                        v236 = v217[nn];
                        v236[16] = 0;
                      }
                      v237 = *(int *)((char *)v209 + 0xFFFFFFC0) + 1;
                      if ( v215 <= v237 )
                        v237 = 0;
                      *(int *)((char *)v209 + 0xFFFFFFC0) = v237;
LABEL_430:
                      v238 = 0;
                      v239 = v208;
                      while ( 1 )
                      {
                        v241 = v238 + 1;
                        if ( v238 >= *v190 )
                          break;
                        v242 = *(_DWORD *)(*(_DWORD *)v239 + 4 * *(int *)((char *)v209 + 0xFFFFFFC0));
                        v243 = *(_DWORD *)(v242 + 64);
                        v244 = *(_DWORD *)(v242 + 60);
                        *(_DWORD *)(v242 + 64) = v243 + 1;
                        if ( v243 < v244 )
                        {
                          if ( !*(_BYTE *)(v242 + 97)
                            && *(_DWORD *)(v242 + 100) == 1
                            && !sub_28FB0((unsigned __int8 *)v242) )
                          {
                            v208 = v239;
                            v213 = v269;
                            goto LABEL_469;
                          }
                          if ( *v301 )
                          {
                            v245 = sub_290E8(0);
                            --*(_DWORD *)(v245 + 64);
                          }
                        }
                        v240 = *(int *)((char *)v209 + 0xFFFFFFC0) + 1;
                        v86 = v240 < *v190;
                        *(int *)((char *)v209 + 0xFFFFFFC0) = v240;
                        if ( !v86 )
                          *(int *)((char *)v209 + 0xFFFFFFC0) = 0;
                        v238 = v241;
                      }
                      v208 = v239;
                      for ( i1 = 0; ; ++i1 )
                      {
                        if ( i1 >= *v190 )
                          goto LABEL_390;
                        v267 = sub_290E8(i1);
                        if ( !*(_BYTE *)(v267 + 97)
                          && *(_DWORD *)(v267 + 100) == 1
                          && !sub_28FB0((unsigned __int8 *)v267) )
                        {
                          break;
                        }
                      }
                      v213 = v268;
LABEL_469:
                      if ( !byte_686E1 )
                        goto LABEL_470;
LABEL_391:
                      if ( *(_BYTE *)v305 || *(_BYTE *)v307 || dword_67840 > 6 )
                      {
                        snprintf(v160, 0x800u, v302, *(_DWORD *)v213);
                        sub_1DD60(7, v160, 0);
                      }
LABEL_395:
                      if ( v213[97] || *((_DWORD *)v213 + 25) != 1 )
                      {
LABEL_397:
                        pthread_mutex_unlock((pthread_mutex_t *)(v303 - 4));
                        sub_208D4();
                        continue;
                      }
LABEL_470:
                      if ( sub_28FB0(v213) )
                        goto LABEL_397;
                      pthread_mutex_unlock((pthread_mutex_t *)(v303 - 4));
                    }
                    v219 = (_DWORD *)sub_28FD4(v218);
LABEL_380:
                    if ( byte_686E1 )
                    {
LABEL_381:
                      if ( *(_BYTE *)v305 || *(_BYTE *)v307 || dword_67840 > 6 )
                      {
                        snprintf(v160, 0x800u, v302, *v219);
                        sub_1DD60(7, v160, 0);
                      }
                    }
                    if ( *((_BYTE *)v219 + 97) || v219[25] != 1 )
                      goto LABEL_387;
                    goto LABEL_448;
                  }
                  setlogmask(255);
                  goto LABEL_123;
                }
                if ( byte_72D90 || *(_BYTE *)v307 )
                  goto LABEL_112;
                goto LABEL_111;
              }
              goto LABEL_145;
            }
          }
          snprintf((char *)v314, 0x800u, "Log file path: %s Open flag: %s", (const char *)&dword_685E0, v302);
          sub_1DD60(3, (const char *)v314, 0);
        }
        v108 = (const char *)*((_DWORD *)format + 130);
        if ( !v108 )
        {
          v307 = (const char **)&byte_686E0;
          goto LABEL_175;
        }
LABEL_145:
        memset(v313, 0, sizeof(v313));
        v121 = (const char *)*((_DWORD *)format + 129);
        if ( v121 )
        {
          if ( !*v121 )
          {
            v140 = "Log work asic num empty";
            v141 = v314;
LABEL_200:
            v142 = *(_DWORD *)v140;
            v143 = *((_DWORD *)v140 + 1);
            v144 = *((_DWORD *)v140 + 2);
            v145 = *((_DWORD *)v140 + 3);
            v146 = v140 + 16;
            *v141 = v142;
            v141[1] = v143;
            v141[2] = v144;
            v141[3] = v145;
            v147 = v141 + 4;
            v148 = v146[1];
            *v147 = *v146;
            v147[1] = v148;
            v149 = (const char *)v314;
            goto LABEL_201;
          }
          v122 = strtol(v121, 0, 10);
          v123 = v122 == 1;
          if ( v122 != 1 )
            v123 = ((v122 - 32) & 0xFFFFFFDF) == 0;
          *(int *)((char *)v305 + 0xFFFFFDA4) = v122;
          if ( !v123 )
          {
            strcpy((char *)v314, "Log work asic num must be 1, 32, 64");
            sub_1DD60(3, (const char *)v314, 1);
            sub_2C230(1, 1);
          }
          v307 = (const char **)&byte_686E0;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
          {
            snprintf(
              (char *)v314,
              0x800u,
              "Log work path: %s Asic num: %s",
              *((const char **)format + 130),
              *((const char **)format + 129));
            sub_1DD60(3, (const char *)v314, 0);
          }
        }
        else
        {
          v307 = (const char **)&byte_686E0;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
          {
            snprintf((char *)v314, 0x800u, "Log work path: %s", v108);
            sub_1DD60(3, (const char *)v314, 0);
          }
        }
        sprintf((char *)v313, "%s.txt", *((const char **)format + 130));
        v124 = fopen64(v313, &word_540E4);
        v125 = (unsigned __int8)byte_72D90;
        *(int *)((char *)v305 + 0xFFFFFDA8) = v124;
        if ( v125 || *(_BYTE *)v307 || dword_67840 > 2 )
        {
          snprintf((char *)v314, 0x800u, "Log work open file %s", (const char *)v313);
          sub_1DD60(3, (const char *)v314, 0);
        }
        v126 = *(int *)((char *)v305 + 0xFFFFFDA4);
        if ( v126 == 1 )
        {
          sprintf((char *)v313, "%s%02d.txt", *((const char **)format + 130), 1);
          v150 = fopen64(v313, &word_540E4);
          v151 = (unsigned __int8)byte_72D90;
          *(int *)((char *)v305 + 0xFFFFFDAC) = v150;
          if ( v151 || *(_BYTE *)v307 || dword_67840 > 2 )
          {
            snprintf(
              (char *)v314,
              0x800u,
              "Log work open asic %d file %s",
              *(int *)((char *)v305 + 0xFFFFFDA4),
              (const char *)v313);
            sub_1DD60(3, (const char *)v314, 0);
          }
        }
        else if ( ((v126 - 32) & 0xFFFFFFDF) == 0 )
        {
          v127 = 0;
          v128 = v305;
          while ( 1 )
          {
            v131 = *(int *)((char *)v128 + 0xFFFFFDA4);
            if ( v131 < v127 )
              break;
            sprintf((char *)v313, "%s%02d_%02d.txt", *((const char **)format + 130), v131, v127);
            v129 = fopen64(v313, &word_540E4);
            v130 = (unsigned __int8)byte_72D90;
            dword_6A48C[v127] = v129;
            if ( v130 || *(_BYTE *)v307 || dword_67840 > 2 )
            {
              snprintf(
                (char *)v314,
                0x800u,
                "Log work open asic %d file %s",
                *(int *)((char *)v128 + 0xFFFFFDA4),
                (const char *)v313);
              sub_1DD60(3, (const char *)v314, 0);
            }
            ++v127;
          }
        }
        if ( *((_BYTE *)v305 + 0xFFFFFEB0) )
        {
          v132 = &byte_6A590;
          v304 = "Log work open diff file %s";
          v133 = format;
          for ( i2 = 0; i2 != 65; ++i2 )
          {
            sprintf((char *)v313, "%s_diff_%02d.txt", *((const char **)v133 + 130), i2);
            v135 = fopen64(v313, &word_540E4);
            v136 = (unsigned __int8)byte_72D90;
            *((_DWORD *)v132 + 1) = v135;
            v132 += 4;
            if ( v136 || *(_BYTE *)v307 || dword_67840 > 2 )
            {
              snprintf((char *)v314, 0x800u, v304, v313);
              sub_1DD60(3, (const char *)v314, 0);
            }
          }
        }
LABEL_175:
        if ( byte_72D90 || *(_BYTE *)v307 )
          goto LABEL_177;
        goto LABEL_109;
      }
      v72 = calloc(24 * *(_DWORD *)(v71 + 4), 1u);
      if ( v72 )
      {
        v73 = *((_DWORD *)v35 + 17);
        v304 = 0;
        *(_DWORD *)(v73 + 24) = (((2 * *(_DWORD *)(v73 + 4) - 1) & *(_DWORD *)(v73 + 12)) != 0)
                              + (*(_DWORD *)(v73 + 12) >> (*(_BYTE *)(v73 + 8) + 1));
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 28) = 0;
        v74 = *((_DWORD *)v35 + 17);
        while ( 1 )
        {
          v75 = *(_DWORD **)v74;
          if ( *(_DWORD *)(v74 + 4) <= (unsigned int)v304 )
            break;
          v76 = (_DWORD *)v75[3 * (_DWORD)v304];
          if ( v76 )
          {
            do
            {
              v77 = (_DWORD *)v76[4];
              v78 = 3 * ((2 * *(_DWORD *)(v74 + 4) - 1) & v76[7]);
              v79 = (char *)&v72[3 * ((2 * *(_DWORD *)(v74 + 4) - 1) & v76[7])];
              v80 = *((_DWORD *)v79 + 1) + 1;
              *((_DWORD *)v79 + 1) = v80;
              v81 = *((_DWORD *)v35 + 17);
              if ( v80 > *(_DWORD *)(v81 + 24) )
              {
                ++*(_DWORD *)(v81 + 28);
                *((_DWORD *)v79 + 2) = sub_4A2D0(*((_DWORD *)v79 + 1), *(_DWORD *)(*((_DWORD *)v35 + 17) + 24));
              }
              v76[3] = 0;
              v76[4] = v72[v78];
              v82 = v72[v78];
              if ( v82 )
                *(_DWORD *)(v82 + 12) = v76;
              v72[v78] = v76;
              v76 = v77;
              v74 = *((_DWORD *)v35 + 17);
            }
            while ( v77 );
          }
          ++v304;
        }
        free(v75);
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v35 + 17) + 8);
        **((_DWORD **)v35 + 17) = v72;
        v83 = (_DWORD *)*((_DWORD *)v35 + 17);
        v84 = v83[7];
        v85 = v83[3];
        v86 = v84 > v85 >> 1;
        if ( v84 <= v85 >> 1 )
          v87 = 0;
        else
          v87 = v83[8];
        if ( v86 )
          ++v87;
        v83[8] = v87;
        v88 = *((_DWORD *)v35 + 17);
        if ( *(_DWORD *)(v88 + 32) > 1u )
          *(_DWORD *)(v88 + 36) = 1;
        goto LABEL_85;
      }
LABEL_184:
      exit(-1);
    }
    strcpy((char *)v314, "Failed to create getq");
  }
  sub_1DD60(3, (const char *)v314, 1);
  sub_2C230(1, 0);
}
// 13644: control flows out of bounds to 13648
// 131BC: variable 'v15' is possibly undefined
// 131BC: variable 'v16' is possibly undefined
// 13E34: variable 'v114' is possibly undefined
// 15C8C: variable 'v248' is possibly undefined
// 15E18: variable 'v265' is possibly undefined
// 15E6C: variable 'v268' is possibly undefined
// 15EB0: variable 'v269' is possibly undefined
// 12830: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 51D00: using guessed type __int16 word_51D00;
// 540E4: using guessed type __int16 word_540E4;
// 55C44: using guessed type __int16 word_55C44;
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 67A68: using guessed type char *off_67A68;
// 681F4: using guessed type int dword_681F4;
// 68204: using guessed type char *off_68204;
// 68598: using guessed type int stderr;
// 685B8: using guessed type char byte_685B8;
// 685C0: using guessed type __int16 word_685C0;
// 685C2: using guessed type char byte_685C2;
// 685E0: using guessed type int dword_685E0;
// 685E8: using guessed type int dword_685E8;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 686E2: using guessed type char byte_686E2;
// 68AF4: using guessed type __time_t dword_68AF4[2];
// 68B28: using guessed type int dword_68B28;
// 68B30: using guessed type int dword_68B30;
// 68B64: using guessed type int dword_68B64;
// 68B94: using guessed type __time_t dword_68B94[3];
// 68C00: using guessed type int dword_68C00;
// 6A48C: using guessed type int dword_6A48C[65];
// 6A590: using guessed type char byte_6A590;
// 6A6E0: using guessed type unsigned __int8 byte_6A6E0[253];
// 72C2C: using guessed type int (__fastcall *off_72C2C)(_DWORD);
// 72D1C: using guessed type int (__fastcall *off_72D1C)(_DWORD);
// 72D88: using guessed type double dbl_72D88;
// 72D90: using guessed type char byte_72D90;
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 72DB0: using guessed type int dword_72DB0;
// 72DC0: using guessed type int dword_72DC0;
// 72DD0: using guessed type struct sigaction stru_72DD0;
// 72E60: using guessed type int dword_72E60;
// 72E68: using guessed type pthread_cond_t stru_72E68;
// 72E9C: using guessed type pthread_rwlock_t stru_72E9C;
// 72ED8: using guessed type pthread_mutex_t stru_72ED8;
// 72F04: using guessed type int dword_72F04;
// 72F0C: using guessed type int dword_72F0C;
// 72F10: using guessed type int dword_72F10;
// 73F20: using guessed type int dword_73F20;
// 74F60: using guessed type int dword_74F60;
// 74F65: using guessed type char byte_74F65;
// 74F68: using guessed type int dword_74F68;
// 74F6C: using guessed type pthread_mutex_t stru_74F6C;
// 74F90: using guessed type pthread_rwlock_t stru_74F90;
// 74FC0: using guessed type pthread_rwlock_t stru_74FC0;
// 74FE0: using guessed type int dword_74FE0;
// 74FE4: using guessed type pthread_mutex_t stru_74FE4;
// 76014: using guessed type char byte_76014;
// 76018: using guessed type pthread_mutex_t stru_76018;
// 76068: using guessed type char byte_76068;
// 76070: using guessed type int dword_76070;
// 76078: using guessed type char byte_76078;
// 7607A: using guessed type char byte_7607A;
// 76084: using guessed type struct sigaction stru_76084;
// 76110: using guessed type pthread_mutex_t stru_76110;
// 76148: using guessed type pthread_mutex_t stru_76148;
// 76198: using guessed type pthread_cond_t stru_76198;
// 76228: using guessed type int dword_76228;
// 76230: using guessed type int dword_76230;
// 76238: using guessed type struct sigaction stru_76238;

//----- (000165D8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_9,
    a1,
    va);
  abort();
}
// 165E2: positive sp value 4 has been found
// 165F4: variable 'v4' is possibly undefined
// 4AD28: using guessed type int init();
// 4AD64: using guessed type int nullsub_9();

//----- (00016608) --------------------------------------------------------
int sub_16608()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 12524: using guessed type int _gmon_start__(void);

//----- (0001662C) --------------------------------------------------------
void *sub_1662C()
{
  return &unk_6858C;
}

//----- (00016650) --------------------------------------------------------
__int64 sub_16650()
{
  __int64 result; // r0

  LODWORD(result) = &unk_6858C;
  HIDWORD(result) = 0;
  return result;
}

//----- (0001667C) --------------------------------------------------------
void *sub_1667C()
{
  void *result; // r0

  if ( !byte_6859C )
  {
    result = sub_1662C();
    byte_6859C = 1;
  }
  return result;
}
// 6859C: using guessed type char byte_6859C;

//----- (00016698) --------------------------------------------------------
int __fastcall sub_16698(const char *a1, char *a2, socklen_t a3)
{
  int v6; // r4
  int v7; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  char v12[16]; // [sp+0h] [bp-24h] BYREF
  int af; // [sp+10h] [bp-14h]
  _BYTE v14[4]; // [sp+14h] [bp-10h] BYREF
  _BYTE cp[12]; // [sp+18h] [bp-Ch] BYREF

  if ( strlen(a1) > 0xF )
  {
    v6 = -1;
    fprintf((FILE *)stderr, "Error: Interface name '%s' is too long. Max length is %d.\n", a1, 15);
    return v6;
  }
  v6 = socket(2, 2, 0);
  if ( v6 == -1 )
  {
    perror("Failed to create socket for IPv4");
    return v6;
  }
  strncpy(v12, a1, 0xFu);
  v12[15] = 0;
  if ( ioctl(v6, 0x8915u, v12) != -1 )
    goto LABEL_4;
  close(v6);
  v9 = socket(10, 2, 0);
  v6 = v9;
  if ( v9 == -1 )
  {
    perror("Failed to create socket for IPv6");
    return v6;
  }
  if ( ioctl(v9, 0x8915u, v12) == -1 )
  {
    perror("IOCTL failed to get IP address");
    v10 = v6;
    v6 = -1;
    close(v10);
  }
  else
  {
LABEL_4:
    if ( (unsigned __int16)af == 2 )
    {
      inet_ntop(2, v14, a2, a3);
    }
    else
    {
      if ( (unsigned __int16)af != 10 )
      {
        fwrite("Unknown address family.\n", 1u, 0x18u, (FILE *)stderr);
        v11 = v6;
        v6 = -1;
        close(v11);
        return v6;
      }
      inet_ntop(10, cp, a2, a3);
    }
    v7 = v6;
    v6 = 0;
    close(v7);
  }
  return v6;
}
// 68598: using guessed type int stderr;

//----- (00016824) --------------------------------------------------------
int __fastcall sub_16824(const char *a1, char *a2, socklen_t a3)
{
  int v5; // r5
  size_t v6; // r0
  char *v7; // r1
  char *v8; // r0
  int v9; // r3
  int v10; // t1
  bool v11; // zf

  v5 = sub_16698(a1, a2, a3);
  if ( v5 )
  {
    v5 = -1;
    fprintf((FILE *)stderr, "Failed to get IP address from interface '%s'.\n", a1);
  }
  else
  {
    v6 = strlen(a2);
    if ( v6 )
    {
      v7 = a2 - 1;
      v8 = &a2[v6 - 1];
      do
      {
        v10 = (unsigned __int8)*++v7;
        v9 = v10;
        v11 = v10 == 46;
        if ( v10 != 46 )
          v11 = v9 == 58;
        if ( v11 )
          *v7 = 88;
      }
      while ( v7 != v8 );
    }
  }
  return v5;
}
// 68598: using guessed type int stderr;

//----- (0001689C) --------------------------------------------------------
int __fastcall sub_1689C(char *a1, socklen_t a2)
{
  int result; // r0

  result = sub_16824("eth0", a1, a2);
  if ( result )
  {
    fwrite("Failed to retrieve and modify IP address for eth0.\n", 1u, 0x33u, (FILE *)stderr);
    return -1;
  }
  return result;
}
// 68598: using guessed type int stderr;

//----- (000168E8) --------------------------------------------------------
void *__fastcall sub_168E8(_DWORD *a1)
{
  void *result; // r0
  _DWORD *v3; // r4
  char *v4; // r0
  char *v5; // r0
  char *v6; // r0
  char v7[64]; // [sp+0h] [bp-C4h] BYREF
  char s[64]; // [sp+40h] [bp-84h] BYREF
  char v9[68]; // [sp+80h] [bp-44h] BYREF

  memset(v7, 0, sizeof(v7));
  memset(s, 0, sizeof(s));
  result = memset(v9, 0, 0x40u);
  if ( a1 )
  {
    v3 = sub_48A70();
    snprintf(v7, 0x40u, "%s", byte_6A6D0);
    v4 = (char *)sub_49004(v7);
    sub_49894(v3, "miner_version", v4);
    snprintf(s, 0x40u, "%s", byte_6A25C);
    v5 = (char *)sub_49004(s);
    sub_49894(v3, "CompileTime", v5);
    snprintf(v9, 0x40u, "%s", byte_6A35C);
    if ( byte_76324 )
      snprintf(v9, 0x40u, "%s", &byte_76324);
    v6 = (char *)sub_49004(v9);
    sub_49894(v3, "type", v6);
    return (void *)sub_49894(a1, "INFO", v3);
  }
  return result;
}
// 76324: using guessed type char byte_76324;

//----- (00016A28) --------------------------------------------------------
void *__fastcall sub_16A28(_DWORD *a1, int a2, int a3, const char *a4)
{
  void *result; // r0
  bool v9; // zf
  _DWORD *v10; // r9
  _DWORD *v11; // r6
  __int16 v12; // r3
  char *v13; // r0
  _QWORD *v14; // r0
  _QWORD *v15; // r0
  const char *v16; // r2
  _DWORD *v17; // r3
  char *v18; // r0
  char *v19; // r0
  _QWORD *v20; // r0
  __int16 v21; // [sp+4h] [bp-38h] BYREF
  char s[48]; // [sp+8h] [bp-34h] BYREF

  v21 = 0;
  result = memset(s, 0, sizeof(s));
  v9 = a4 == 0;
  if ( a4 )
    v9 = a1 == 0;
  if ( !v9 )
  {
    v10 = sub_48E00();
    v11 = sub_48A70();
    if ( a2 )
      v12 = 83;
    else
      v12 = 69;
    v21 = v12;
    v13 = (char *)sub_49004((const char *)&v21);
    sub_49894(v11, "STATUS", v13);
    v14 = sub_49250(dword_685A0);
    sub_49894(v11, "When", v14);
    v15 = sub_49250(a3);
    sub_49894(v11, "Code", v15);
    if ( a3 == 7 )
      LOWORD(v17) = 11872;
    else
      LOWORD(v16) = -12528;
    if ( a3 == 7 )
    {
      HIWORD(v17) = 7;
      snprintf(s, 0x30u, a4, *v17);
    }
    else
    {
      HIWORD(v16) = 4;
      snprintf(s, 0x30u, v16, a4);
    }
    v18 = (char *)sub_49004(s);
    sub_49894(v11, "Msg", v18);
    v19 = (char *)sub_49004((const char *)off_682C0);
    sub_49894(v11, "Description", v19);
    sub_49D54(v10, v11);
    result = (void *)sub_49894(a1, "STATUS", v10);
    if ( !a2 )
    {
      v20 = sub_49250(1);
      return (void *)sub_49894(a1, "id", v20);
    }
  }
  return result;
}
// 16B0C: variable 'v17' is possibly undefined
// 16B1C: variable 'v16' is possibly undefined
// 682C0: using guessed type _UNKNOWN *off_682C0;
// 685A0: using guessed type int dword_685A0;

//----- (00016DAC) --------------------------------------------------------
int __fastcall sub_16DAC(int result, const char **a2)
{
  bool v2; // zf
  _DWORD *v4; // r5
  _DWORD *v5; // r6
  char *v6; // r0
  _QWORD *v7; // r0
  char *v8; // r0
  char *v9; // r0
  _DWORD v10[4]; // [sp+0h] [bp-20h] BYREF
  _DWORD v11[4]; // [sp+10h] [bp-10h] BYREF

  v2 = a2 == 0;
  if ( a2 )
    v2 = result == 0;
  memset(v10, 0, sizeof(v10));
  memset(v11, 0, sizeof(v11));
  if ( !v2 )
  {
    v4 = (_DWORD *)result;
    v5 = sub_48A70();
    v6 = (char *)sub_49004("S");
    sub_49894(v5, "STATUS", v6);
    v7 = sub_49250(dword_685A0);
    sub_49894(v5, "when", v7);
    snprintf((char *)v10, 0x10u, "%s", *a2);
    v8 = (char *)sub_49004((const char *)v10);
    sub_49894(v5, "Msg", v8);
    snprintf((char *)v11, 0x10u, "%s", a2[1]);
    v9 = (char *)sub_49004((const char *)v11);
    sub_49894(v5, "api_version", v9);
    return sub_49894(v4, "STATUS", v5);
  }
  return result;
}
// 685A0: using guessed type int dword_685A0;

//----- (00016EC8) --------------------------------------------------------
int __fastcall sub_16EC8(_DWORD *a1, const char **a2)
{
  int v2; // r4
  _DWORD *v6; // r7
  int v7; // r0
  int v8; // r0
  int v9; // r3
  int (*v10)(void); // r3
  _DWORD *v11; // r0
  __int16 v12; // [sp+24h] [bp-808h] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  v2 = a1 == 0;
  if ( !a2 )
    v2 = 1;
  v12 = 0;
  if ( v2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: input bad api param\n", "get_stats");
      sub_1DD60(3, s, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    sub_42680(&v12, 1u);
    sub_16DAC((int)a1, a2);
    sub_168E8(a1);
    v6 = sub_48E00();
    if ( dword_74FE0 > 0 )
    {
      do
      {
        v7 = v2++;
        v8 = sub_2DFF4(v7);
        if ( v8 )
        {
          v9 = *(_DWORD *)(v8 + 4);
          if ( v9 )
          {
            v10 = *(int (**)(void))(v9 + 28);
            if ( v10 )
            {
              v11 = (_DWORD *)v10();
              sub_49D54(v6, v11);
            }
          }
        }
      }
      while ( dword_74FE0 > v2 );
    }
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(
        s,
        0x800u,
        "total_mhashes_done = %lf\n new_total_mhashes_done = %lf\n total_secs = %lf\n, new_total_secs = %lf",
        dbl_72D88,
        *(double *)&dword_72ED0,
        dbl_681C0,
        *(double *)&dword_681D8);
      sub_1DD60(7, s, 0);
    }
    sub_49894(a1, "STATS", v6);
    return 0;
  }
}
// 67840: using guessed type int dword_67840;
// 681C0: using guessed type double dbl_681C0;
// 681D8: using guessed type int dword_681D8;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D88: using guessed type double dbl_72D88;
// 72D90: using guessed type char byte_72D90;
// 72ED0: using guessed type int dword_72ED0;
// 74FE0: using guessed type int dword_74FE0;

//----- (000170D4) --------------------------------------------------------
int __fastcall sub_170D4(_DWORD *a1, const char **a2)
{
  bool v4; // zf
  __int64 v6; // kr00_8
  char *v7; // r0
  _QWORD *v8; // r0
  _QWORD *v9; // r0
  _QWORD *v10; // r0
  _QWORD *v11; // r0
  _QWORD *v12; // r0
  _QWORD *v13; // r0
  char *v14; // r0
  _QWORD *v15; // r0
  __int64 v16; // r0
  _QWORD *v17; // r0
  __int64 v18; // r0
  _QWORD *v19; // r0
  __int64 v20; // r0
  _QWORD *v21; // r0
  __int64 v22; // r0
  _QWORD *v23; // r0
  int v24; // r3
  bool v25; // cc
  time_t v26; // r0
  unsigned int v27; // lr
  char *v28; // r0
  int v29; // r8
  _DWORD *v30; // r4
  _QWORD *v31; // r0
  char *v32; // r0
  char *v33; // r0
  int v34; // r2
  bool v35; // zf
  _DWORD *v36; // r3
  int v37; // r1
  _DWORD *v38; // [sp+Ch] [bp-948h]
  char v40[4]; // [sp+24h] [bp-930h] BYREF
  int v41; // [sp+28h] [bp-92Ch]
  _DWORD v42[3]; // [sp+2Ch] [bp-928h] BYREF
  char v43[4]; // [sp+38h] [bp-91Ch] BYREF
  int v44; // [sp+3Ch] [bp-918h]
  int v45; // [sp+40h] [bp-914h]
  int v46; // [sp+44h] [bp-910h]
  int v47; // [sp+48h] [bp-90Ch]
  int v48; // [sp+4Ch] [bp-908h]
  char s[128]; // [sp+50h] [bp-904h] BYREF
  char v50[128]; // [sp+D0h] [bp-884h] BYREF
  char v51[2052]; // [sp+150h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  memset(v50, 0, sizeof(v50));
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  memset(v42, 0, sizeof(v42));
  *(_DWORD *)v40 = 0;
  *(_DWORD *)v43 = 0;
  v41 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  if ( v4 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(v51, 0x800u, "%s: input bad api param\n", "get_pools");
      sub_1DD60(3, v51, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    sub_16DAC((int)a1, a2);
    sub_168E8(a1);
    v38 = sub_48E00();
    if ( dword_72E60 > 0 )
    {
      v6 = 0;
      do
      {
        v29 = *(_DWORD *)(dword_72F04 + 4 * v6);
        if ( v29 )
        {
          v30 = sub_48A70();
          v31 = sub_49250(v6);
          sub_49894(v30, "index", v31);
          memset(s, 0, sizeof(s));
          snprintf(s, 0x80u, "%s", *(const char **)(v29 + 164));
          v32 = (char *)sub_49004(s);
          sub_49894(v30, "url", v32);
          memset(v50, 0, sizeof(v50));
          snprintf(v50, 0x80u, "%s", *(const char **)(v29 + 172));
          v33 = (char *)sub_49004(v50);
          sub_49894(v30, "user", v33);
          v34 = *(_DWORD *)(v29 + 100);
          memset(v42, 0, sizeof(v42));
          if ( v34 == 1 )
          {
            v35 = *(_BYTE *)(v29 + 97) == 0;
            if ( *(_BYTE *)(v29 + 97) )
              LOWORD(v36) = -20136;
            else
              LOWORD(v36) = -20128;
            HIWORD(v36) = 4;
            v37 = v36[1];
            v42[0] = *v36;
            if ( v35 )
              LOWORD(v42[1]) = v37;
            else
              LOBYTE(v42[1]) = v37;
          }
          else if ( v34 )
          {
            if ( v34 == 2 )
              strcpy((char *)v42, "Rejecting");
            else
              strcpy((char *)v42, "Unknown");
          }
          else
          {
            strcpy((char *)v42, "Disabled");
          }
          v7 = (char *)sub_49004((const char *)v42);
          sub_49894(v30, "status", v7);
          v8 = sub_49250(*(int *)(v29 + 4));
          sub_49894(v30, "priority", v8);
          v9 = sub_49250(*(unsigned int *)(v29 + 116));
          sub_49894(v30, "getworks", v9);
          v10 = sub_49250(*(_QWORD *)(v29 + 8));
          sub_49894(v30, "accepted", v10);
          v11 = sub_49250(*(_QWORD *)(v29 + 16));
          sub_49894(v30, "rejected", v11);
          v12 = sub_49250(*(unsigned int *)(v29 + 124));
          sub_49894(v30, "discarded", v12);
          v13 = sub_49250(*(unsigned int *)(v29 + 120));
          sub_49894(v30, "stale", v13);
          *(_DWORD *)v40 = 0;
          v41 = 0;
          snprintf(v40, 8u, "%s", (const char *)(v29 + 48));
          v14 = (char *)sub_49004(v40);
          sub_49894(v30, "diff", v14);
          v15 = sub_49250(*(_QWORD *)(v29 + 40));
          sub_49894(v30, "diff1", v15);
          LODWORD(v16) = sub_4ABAC(*(double *)(v29 + 72));
          v17 = sub_49250(v16);
          sub_49894(v30, "diffa", v17);
          LODWORD(v18) = sub_4ABAC(*(double *)(v29 + 80));
          v19 = sub_49250(v18);
          sub_49894(v30, "diffr", v19);
          LODWORD(v20) = sub_4ABAC(*(double *)(v29 + 88));
          v21 = sub_49250(v20);
          sub_49894(v30, "diffs", v21);
          LODWORD(v22) = sub_4ABAC(*(double *)(v29 + 360));
          v23 = sub_49250(v22);
          sub_49894(v30, "lsdiff", v23);
          v24 = *(_DWORD *)(v29 + 352);
          *(_DWORD *)v43 = 0;
          v44 = 0;
          v25 = v24 <= 0;
          v45 = 0;
          if ( v24 <= 0 )
            LOWORD(v24) = 48;
          v46 = 0;
          v47 = 0;
          v48 = 0;
          if ( v25 )
          {
            *(_WORD *)v43 = v24;
          }
          else
          {
            v26 = time(0);
            v27 = (v26 - *(_DWORD *)(v29 + 352)) & ~((v26 - *(_DWORD *)(v29 + 352)) >> 31);
            snprintf(v43, 0x18u, "%d:%02d:%02d", v27 / 0xE10, v27 % 0xE10 / 0x3C, v27 % 0xE10 % 0x3C);
          }
          v28 = (char *)sub_49004(v43);
          sub_49894(v30, "lstime", v28);
          sub_49D54(v38, v30);
        }
        ++v6;
      }
      while ( dword_72E60 > (int)v6 );
    }
    sub_49894(a1, "POOLS", v38);
    return 0;
  }
}
// 17390: variable 'v16' is possibly undefined
// 173B0: variable 'v18' is possibly undefined
// 173D0: variable 'v20' is possibly undefined
// 173F4: variable 'v22' is possibly undefined
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (00017640) --------------------------------------------------------
int __fastcall sub_17640(_DWORD *a1, int a2)
{
  bool v4; // zf
  int v5; // r4
  __int64 v7; // kr08_8
  int v8; // r4
  int v9; // r6
  _DWORD *v10; // r5
  _QWORD *v11; // r0
  char *v12; // r0
  int v13; // r3
  char *v14; // r0
  _QWORD *v15; // r0
  _QWORD *v16; // r0
  const char *v17; // r0
  char *v18; // r0
  _QWORD *v19; // r0
  _QWORD *v20; // r0
  _QWORD *v21; // r0
  _QWORD *v22; // r0
  _QWORD *v23; // r0
  _QWORD *v24; // r0
  _QWORD *v25; // r0
  char *v26; // r0
  int v27; // r3
  bool v28; // cc
  time_t v29; // r0
  unsigned int v30; // lr
  char *v31; // r0
  char *v32; // r0
  _QWORD *v33; // r0
  char *v34; // r0
  char *v35; // r0
  const char *v36; // r0
  char *v37; // r0
  __int64 v38; // r0
  double *v39; // r0
  __int64 v40; // r0
  double *v41; // r0
  __int64 v42; // r0
  double *v43; // r0
  __int64 v44; // r0
  double *v45; // r0
  _DWORD *v46; // r2
  _DWORD *v47; // r2
  int v48; // r0
  char *v49; // r0
  _DWORD *v50; // r2
  unsigned int v51; // r3
  __int64 v52; // r0
  unsigned __int64 v53; // kr00_8
  double *v54; // r0
  double v55; // d5
  double v56; // d7
  __int64 v57; // r0
  double *v58; // r0
  double v59; // d5
  double v60; // d7
  __int64 v61; // r0
  double *v62; // r0
  _QWORD *v63; // r0
  char *v64; // r0
  bool v65; // zf
  _DWORD *v66; // r3
  int v67; // r1
  _DWORD *v69; // [sp+20h] [bp-944h]
  char v70[4]; // [sp+34h] [bp-930h] BYREF
  int v71; // [sp+38h] [bp-92Ch]
  _DWORD v72[3]; // [sp+3Ch] [bp-928h] BYREF
  char v73[4]; // [sp+48h] [bp-91Ch] BYREF
  int v74; // [sp+4Ch] [bp-918h]
  int v75; // [sp+50h] [bp-914h]
  int v76; // [sp+54h] [bp-910h]
  int v77; // [sp+58h] [bp-90Ch]
  int v78; // [sp+5Ch] [bp-908h]
  char s[128]; // [sp+60h] [bp-904h] BYREF
  char v80[128]; // [sp+E0h] [bp-884h] BYREF
  char v81[2052]; // [sp+160h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  memset(v80, 0, sizeof(v80));
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  memset(v72, 0, sizeof(v72));
  *(_DWORD *)v70 = 0;
  *(_DWORD *)v73 = 0;
  v71 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  if ( v4 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      v5 = -2147483646;
      snprintf(v81, 0x800u, "%s: input bad api param\n", "get_pools_old");
      sub_1DD60(3, v81, 0);
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    v5 = dword_72E60;
    if ( dword_72E60 )
    {
      sub_16A28(a1, 1, 7, *(const char **)(a2 + 8));
      v69 = sub_48E00();
      if ( dword_72E60 > 0 )
      {
        v7 = 0;
        do
        {
          v8 = *(_DWORD *)(dword_72F04 + 4 * v7);
          v9 = *(unsigned __int8 *)(v8 + 105);
          if ( !*(_BYTE *)(v8 + 105) )
          {
            v10 = sub_48A70();
            v11 = sub_49250(v7);
            sub_49894(v10, "POOL", v11);
            memset(s, v9, sizeof(s));
            snprintf(s, 0x80u, "%s", *(_DWORD *)(v8 + 164));
            v12 = (char *)sub_49004(s);
            sub_49894(v10, "URL", v12);
            v13 = *(_DWORD *)(v8 + 100);
            v72[0] = v9;
            v72[1] = v9;
            v72[2] = v9;
            if ( v13 == 1 )
            {
              v65 = *(_BYTE *)(v8 + 97) == 0;
              if ( *(_BYTE *)(v8 + 97) )
                LOWORD(v66) = -19956;
              else
                LOWORD(v66) = -20128;
              HIWORD(v66) = 4;
              v67 = v66[1];
              v72[0] = *v66;
              if ( v65 )
                LOWORD(v72[1]) = v67;
              else
                LOBYTE(v72[1]) = v67;
            }
            else if ( v13 )
            {
              if ( v13 == 2 )
                strcpy((char *)v72, "Rejecting");
              else
                strcpy((char *)v72, "Unknown");
            }
            else
            {
              strcpy((char *)v72, "Disabled");
            }
            v14 = (char *)sub_49004((const char *)v72);
            sub_49894(v10, "Status", v14);
            v15 = sub_49250(*(int *)(v8 + 4));
            sub_49894(v10, "Priority", v15);
            v16 = sub_49250(*(int *)(v8 + 56));
            sub_49894(v10, "Quota", v16);
            if ( *(_DWORD *)(v8 + 108) )
              LOWORD(v17) = -19920;
            else
              LOWORD(v17) = -19904;
            HIWORD(v17) = 4;
            v18 = (char *)sub_49004(v17);
            sub_49894(v10, "Long Poll", v18);
            v19 = sub_49250(*(unsigned int *)(v8 + 116));
            sub_49894(v10, "Getworks", v19);
            v20 = sub_49250(*(_QWORD *)(v8 + 8));
            sub_49894(v10, "Accepted", v20);
            v21 = sub_49250(*(_QWORD *)(v8 + 16));
            sub_49894(v10, "Rejected", v21);
            v22 = sub_49250(*(unsigned int *)(v8 + 124));
            sub_49894(v10, "Discarded", v22);
            v23 = sub_49250(*(unsigned int *)(v8 + 120));
            sub_49894(v10, "Stale", v23);
            v24 = sub_49250(*(unsigned int *)(v8 + 128));
            sub_49894(v10, "Get Failures", v24);
            v25 = sub_49250(*(unsigned int *)(v8 + 132));
            sub_49894(v10, "Remote Failures", v25);
            memset(v80, 0, sizeof(v80));
            snprintf(v80, 0x80u, "%s", *(_DWORD *)(v8 + 172));
            v26 = (char *)sub_49004(v80);
            sub_49894(v10, "User", v26);
            v27 = *(_DWORD *)(v8 + 352);
            *(_DWORD *)v73 = 0;
            v74 = 0;
            v28 = v27 <= 0;
            v75 = 0;
            if ( v27 <= 0 )
              LOWORD(v27) = 48;
            v76 = 0;
            v77 = 0;
            v78 = 0;
            if ( v28 )
            {
              *(_WORD *)v73 = v27;
            }
            else
            {
              v29 = time(0);
              v30 = (v29 - *(_DWORD *)(v8 + 352)) & ~((v29 - *(_DWORD *)(v8 + 352)) >> 31);
              snprintf(v73, 0x18u, "%d:%02d:%02d", v30 / 0xE10, v30 % 0xE10 / 0x3C, v30 % 0xE10 % 0x3C);
            }
            v31 = (char *)sub_49004(v73);
            sub_49894(v10, "Last Share Time", v31);
            *(_DWORD *)v70 = 0;
            v71 = 0;
            snprintf(v70, 8u, "%s", v8 + 48);
            v32 = (char *)sub_49004(v70);
            sub_49894(v10, "Diff", v32);
            v33 = sub_49250(*(_QWORD *)(v8 + 40));
            sub_49894(v10, "Diff1 Shares", v33);
            if ( *(_DWORD *)(v8 + 184) )
            {
              v34 = sub_1F9D4(*(char **)(v8 + 180));
              v35 = (char *)sub_49004(v34);
              sub_49894(v10, "Proxy Type", v35);
              v36 = *(const char **)(v8 + 184);
            }
            else
            {
              v64 = (char *)sub_49004("");
              sub_49894(v10, "Proxy Type", v64);
              v36 = "";
            }
            v37 = (char *)sub_49004(v36);
            sub_49894(v10, "Proxy", v37);
            LODWORD(v38) = sub_4ABAC(*(double *)(v8 + 72) * 100.0);
            sub_4AB14(v38);
            v39 = sub_492D4();
            sub_49894(v10, "Difficulty Accepted", v39);
            LODWORD(v40) = sub_4ABAC(*(double *)(v8 + 80) * 100.0);
            sub_4AB14(v40);
            v41 = sub_492D4();
            sub_49894(v10, "Difficulty Rejected", v41);
            LODWORD(v42) = sub_4ABAC(*(double *)(v8 + 88) * 100.0);
            sub_4AB14(v42);
            v43 = sub_492D4();
            sub_49894(v10, "Difficulty Stale", v43);
            LODWORD(v44) = sub_4ABAC(*(double *)(v8 + 360) * 100.0);
            sub_4AB14(v44);
            v45 = sub_492D4();
            sub_49894(v10, "Last Share Difficulty", v45);
            if ( *(_BYTE *)(v8 + 656) )
              v46 = sub_49408();
            else
              v46 = sub_49414();
            sub_49894(v10, "Has Stratum", v46);
            if ( *(_BYTE *)(v8 + 657) )
              v47 = sub_49408();
            else
              v47 = sub_49414();
            sub_49894(v10, "Stratum Active", v47);
            if ( *(_BYTE *)(v8 + 657) )
              v48 = *(_DWORD *)(v8 + 576);
            else
              v48 = 53128;
            if ( !*(_BYTE *)(v8 + 657) )
              HIWORD(v48) = 4;
            v49 = (char *)sub_49004((const char *)v48);
            sub_49894(v10, "Stratum URL", v49);
            if ( *(_BYTE *)(v8 + 752) )
              v50 = sub_49408();
            else
              v50 = sub_49414();
            sub_49894(v10, "Has GBT", v50);
            v51 = *(_DWORD *)(v8 + 368);
            HIDWORD(v52) = *(_DWORD *)(v8 + 372);
            v53 = 33 * (2LL * *(_QWORD *)(v8 + 368) + __PAIR64__(HIDWORD(v52), v51));
            LODWORD(v52) = v53;
            sub_4AB14(v52 + __PAIR64__(HIDWORD(v53), v51));
            v54 = sub_492D4();
            sub_49894(v10, "Best Share", v54);
            v55 = *(double *)(v8 + 80);
            v56 = v55 + *(double *)(v8 + 72) + *(double *)(v8 + 88);
            if ( v56 != 0.0 )
            {
              LODWORD(v57) = sub_4ABAC(v55 / v56 * 100.0);
              sub_4AB14(v57);
            }
            v58 = sub_492D4();
            sub_49894(v10, "Pool Rejected%", v58);
            v59 = *(double *)(v8 + 88);
            v60 = *(double *)(v8 + 72) + *(double *)(v8 + 80) + v59;
            if ( v60 != 0.0 )
            {
              LODWORD(v61) = sub_4ABAC(v59 / v60 * 100.0);
              sub_4AB14(v61);
            }
            v62 = sub_492D4();
            sub_49894(v10, "Pool Stale%%", v62);
            sub_49D54(v69, v10);
          }
          ++v7;
        }
        while ( dword_72E60 > (int)v7 );
      }
      v5 = 0;
      sub_49894(a1, "POOLS", v69);
      v63 = sub_49250(1);
      sub_49894(a1, "id", v63);
    }
    else
    {
      sub_16A28(a1, 0, 8, "No pools");
    }
  }
  return v5;
}
// 17BA4: variable 'v38' is possibly undefined
// 17BD8: variable 'v40' is possibly undefined
// 17C0C: variable 'v42' is possibly undefined
// 17C40: variable 'v44' is possibly undefined
// 17D88: variable 'v57' is possibly undefined
// 17DE0: variable 'v61' is possibly undefined
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (00017F44) --------------------------------------------------------
int sub_17F44()
{
  int v0; // r5
  char v2[8]; // [sp+0h] [bp-80Ch] BYREF
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "<<<<<<<<<<<<<<<<<<<<exec %s start>>>>>>>>>>>>>>>>", "enter_sleep");
    sub_1DD60(7, s, 0);
  }
  v0 = strcmp(s1, "127.0.0.1");
  if ( v0 )
    return -2147483643;
  strcpy(v2, "sleep");
  sub_42680(v2, 5u);
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "<<<<<<<<<<<<<<<<<<<<exec %s end>>>>>>>>>>>>>>>>>>", "enter_sleep");
    sub_1DD60(7, s, 0);
  }
  return v0;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (00018098) --------------------------------------------------------
int __fastcall sub_18098(_DWORD *a1, const char **a2)
{
  bool v4; // zf
  int v6; // r0
  FILE *v7; // r8
  _DWORD *v8; // r4
  char *v9; // r0
  char *v10; // r0
  char *v11; // r0
  char *v12; // r0
  _DWORD *v13; // [sp+Ch] [bp-B30h]
  int v14; // [sp+1Ch] [bp-B20h] BYREF
  int v15; // [sp+20h] [bp-B1Ch]
  __int16 v16; // [sp+24h] [bp-B18h]
  int v17; // [sp+28h] [bp-B14h] BYREF
  int v18; // [sp+2Ch] [bp-B10h]
  _DWORD v19[2]; // [sp+30h] [bp-B0Ch]
  char s[128]; // [sp+38h] [bp-B04h] BYREF
  char v21[128]; // [sp+B8h] [bp-A84h] BYREF
  char v22[512]; // [sp+138h] [bp-A04h] BYREF
  char v23[2052]; // [sp+338h] [bp-804h] BYREF

  v15 = 0;
  v16 = 0;
  v14 = 0;
  memset(s, 0, sizeof(s));
  memset(v21, 0, sizeof(v21));
  v19[0] = 0;
  v17 = 0;
  v18 = 0;
  *(_DWORD *)((char *)v19 + 3) = 0;
  memset(v22, 0, sizeof(v22));
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( v4 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(v23, 0x800u, "%s: input bad api param\n", "get_warning");
      sub_1DD60(3, v23, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    sub_16DAC((int)a1, a2);
    sub_168E8(a1);
    v6 = fopen64("/tmp/warning.log", "r");
    v7 = (FILE *)v6;
    if ( v6 )
    {
      v13 = sub_48E00();
      while ( fgets(v22, 512, v7) )
      {
        v14 = 0;
        v15 = 0;
        v16 = 0;
        memset(s, 0, sizeof(s));
        memset(v21, 0, sizeof(v21));
        v19[0] = 0;
        v17 = 0;
        v18 = 0;
        *(_DWORD *)((char *)v19 + 3) = 0;
        sscanf(v22, "%[^;]; %[^;]; %[^;]; %s", &v14, s, v21, &v17);
        memset(v22, 0, sizeof(v22));
        v8 = sub_48A70();
        v9 = (char *)sub_49004((const char *)&v14);
        sub_49894(v8, "code", v9);
        v10 = (char *)sub_49004(s);
        sub_49894(v8, "cause", v10);
        v11 = (char *)sub_49004(v21);
        sub_49894(v8, "suggestion", v11);
        v12 = (char *)sub_49004((const char *)&v17);
        sub_49894(v8, "timestamp", v12);
        sub_49D54(v13, v8);
      }
      fclose(v7);
      sub_49894(a1, "WARNING", v13);
      return 0;
    }
    else
    {
      return -2147483647;
    }
  }
}
// 12830: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00018328) --------------------------------------------------------
int *__fastcall sub_18328(int *result)
{
  int v1; // r2
  int *v2; // r4

  v1 = *result;
  byte_685B4 = 1;
  if ( v1 != -1 )
  {
    v2 = result;
    shutdown(v1, 2);
    result = (int *)close(*v2);
    *v2 = -1;
  }
  return result;
}
// 685B4: using guessed type char byte_685B4;

//----- (0001836C) --------------------------------------------------------
int __fastcall sub_1836C(_DWORD *a1, const char *a2, unsigned int a3)
{
  int result; // r0
  int v7; // r5
  const char *v8; // r1
  const char *v9; // r1
  char **v10; // r9
  const char *v11; // t1
  char *v12; // r0
  char dest[4]; // [sp+4h] [bp-78h] BYREF
  int v14; // [sp+8h] [bp-74h]
  int v15; // [sp+Ch] [bp-70h]
  int v16; // [sp+10h] [bp-6Ch]
  char s[104]; // [sp+14h] [bp-68h] BYREF

  memset(s, 0, 0x64u);
  if ( !a1 || a3 > 2 )
    return -2147483646;
  v7 = 0;
  result = strlen(a2);
  v14 = 0;
  *(_DWORD *)dest = 0;
  v15 = 0;
  v16 = 0;
  if ( (unsigned int)(result - 1) > 0xF )
  {
    if ( a3 )
      return result;
    goto LABEL_22;
  }
  strncpy(dest, a2, result);
  if ( a3 )
  {
    v8 = off_67308;
    if ( !off_67308 )
      return (int)sub_16A28(a1, 0, 14, "Invalid command");
    while ( strcmp(dest, v8) )
    {
      ++v7;
      v8 = (&off_67308)[4 * v7];
      if ( !v8 )
        return (int)sub_16A28(a1, 0, 14, "Invalid command");
    }
    return ((int (__fastcall *)(_DWORD *))(&off_67308)[4 * v7 + 3])(a1);
  }
  v9 = off_67368;
  if ( !off_67368 )
  {
LABEL_19:
    snprintf(s, 0x64u, "not support (%s)", a2);
    goto LABEL_18;
  }
  v10 = &off_67368;
  while ( strcmp(dest, v9) )
  {
    v11 = v10[3];
    v10 += 3;
    v9 = v11;
    ++a3;
    if ( !v11 )
      goto LABEL_19;
  }
  result = ((int (__fastcall *)(_DWORD *, char **))(&off_67308)[3 * a3 + 26])(a1, &(&off_67368)[3 * a3]);
  if ( result < 0 )
  {
    if ( result != -2147483646 )
    {
LABEL_18:
      v12 = (char *)sub_49004(s);
      return sub_49894(a1, "error_message", v12);
    }
LABEL_22:
    strcpy(s, "bad param");
    goto LABEL_18;
  }
  return result;
}
// 67308: using guessed type char *off_67308;
// 67368: using guessed type char *off_67368;

//----- (00018518) --------------------------------------------------------
char *__fastcall sub_18518(char *a1, int *a2)
{
  double v2; // d0
  char *result; // r0
  int v6; // r3
  __int64 v7; // r0
  const char *v8; // r0
  _DWORD s[65]; // [sp+8h] [bp-104h] BYREF

  result = (char *)memset(s, 0, 0x100u);
  if ( a2 )
  {
    v6 = *a2;
    if ( *a2 == 6 )
    {
      strcpy((char *)s, "false");
    }
    else
    {
      switch ( v6 )
      {
        case 5:
          strcpy((char *)s, "true");
          break;
        case 3:
          v7 = sub_49284((int)a2);
          snprintf((char *)s, 0x100u, "%lld", v7);
          break;
        case 4:
          sub_49330();
          snprintf((char *)s, 0x100u, "%.2lf", v2);
          break;
        case 2:
          v8 = (const char *)sub_49028(a2);
          snprintf((char *)s, 0x100u, "%s", v8);
          break;
      }
    }
    return strcat(a1, (const char *)s);
  }
  return result;
}
// 185F0: variable 'v2' is possibly undefined

//----- (0001861C) --------------------------------------------------------
int __fastcall sub_1861C(int result, _DWORD *a2, int a3)
{
  int v3; // r4
  _DWORD *v4; // r12
  int v5; // r3
  int v6; // t1
  _DWORD *v7; // r6
  char *v9; // r0
  _QWORD *v10; // r0
  char *v11; // r2
  int v12; // r5

  v3 = a2[2];
  if ( v3 > 0 )
  {
    v4 = (_DWORD *)a2[4];
    if ( a3 == *v4 )
    {
      v12 = 0;
LABEL_7:
      v7 = (_DWORD *)result;
      v9 = (char *)sub_49004(*(const char **)(a2[3] + v12));
      sub_49894(v7, "status", v9);
      v10 = sub_49250(*(int *)(a2[4] + v12));
      sub_49894(v7, "code", v10);
      v11 = (char *)sub_49004(*(const char **)(a2[5] + v12));
      return sub_49894(v7, "msg", v11);
    }
    else
    {
      v5 = 0;
      while ( 1 )
      {
        ++v5;
        v12 = 4 * v5;
        if ( v5 == v3 )
          break;
        v6 = v4[1];
        ++v4;
        if ( v6 == a3 )
          goto LABEL_7;
      }
    }
  }
  return result;
}

//----- (000186D4) --------------------------------------------------------
int __fastcall sub_186D4(int result, _DWORD *a2)
{
  int v2; // r2

  if ( result )
  {
    if ( (dword_77D20 & 4) != 0 )
      v2 = -2;
    else
      v2 = (unsigned __int8)dword_77D20 << 30 >> 31;
    if ( a2 )
      return sub_1861C(result, a2, v2);
  }
  return result;
}
// 77D20: using guessed type int dword_77D20;

//----- (00018700) --------------------------------------------------------
int __fastcall sub_18700(int result, _DWORD *a2)
{
  if ( result )
  {
    if ( a2 )
      return sub_1861C(result, a2, (unsigned __int8)dword_77D20 << 31 >> 31);
  }
  return result;
}
// 77D20: using guessed type int dword_77D20;

//----- (00018724) --------------------------------------------------------
int __fastcall sub_18724(int result, _DWORD *a2)
{
  int v2; // r5
  int v4; // r2
  double v5; // [sp+0h] [bp-14h] BYREF
  double v6; // [sp+8h] [bp-Ch] BYREF

  v2 = result;
  v5 = 0.0;
  v6 = 0.0;
  if ( result )
  {
    sscanf(byte_76434, "%lf", &v5);
    result = sscanf(byte_76454, "%lf", &v6);
    if ( v6 * 0.95 <= v5 )
      v4 = (unsigned __int8)dword_77D20 << 28 >> 31;
    else
      v4 = -1;
    if ( a2 )
      return sub_1861C(v2, a2, v4);
  }
  return result;
}
// 77D20: using guessed type int dword_77D20;

//----- (000187D4) --------------------------------------------------------
int sub_187D4()
{
  int v0; // r5
  char v2[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(v2, 0x800u, "<<<<<<<<<<<<<<<<<<<<exec %s start>>>>>>>>>>>>>>>>", "reload_config");
    sub_1DD60(7, v2, 0);
  }
  v0 = strcmp(s1, "127.0.0.1");
  if ( v0 )
    return -2147483643;
  sub_3DDB0();
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(v2, 0x800u, "<<<<<<<<<<<<<<<<<<<<exec %s end>>>>>>>>>>>>>>>>>>", "reload_config");
    sub_1DD60(7, v2, 0);
  }
  return v0;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (0001890C) --------------------------------------------------------
int __fastcall sub_1890C(int result, _DWORD *a2)
{
  int v2; // r7
  int v4; // r8
  int v5; // r3
  int v6; // lr
  int v7; // r12
  int v8; // t1

  v2 = result;
  if ( !result )
    return result;
  result = pthread_mutex_trylock((pthread_mutex_t *)&unk_6A23C);
  v4 = result;
  if ( result )
  {
    v4 = 0;
LABEL_10:
    if ( !a2 )
      return result;
    return sub_1861C(v2, a2, v4);
  }
  if ( dword_72E60 <= 0 )
  {
LABEL_9:
    v4 = -1;
    result = pthread_mutex_unlock((pthread_mutex_t *)&unk_6A23C);
    goto LABEL_10;
  }
  v5 = 0;
  v6 = dword_72F04 - 4;
  while ( 1 )
  {
    v8 = *(_DWORD *)(v6 + 4);
    v6 += 4;
    v7 = v8;
    ++v5;
    if ( *(_DWORD *)(v8 + 100) )
    {
      if ( !*(_BYTE *)(v7 + 97) )
        break;
    }
    if ( v5 == dword_72E60 )
      goto LABEL_9;
  }
  result = pthread_mutex_unlock((pthread_mutex_t *)&unk_6A23C);
  if ( a2 )
    return sub_1861C(v2, a2, v4);
  return result;
}
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (000189CC) --------------------------------------------------------
void __fastcall sub_189CC(int *a1, char *s)
{
  int v3; // r8
  char *v4; // r6
  signed int v5; // r5
  fd_set *p_tv_usec; // r3
  int v7; // r0
  int v8; // lr
  int v9; // r0
  ssize_t v10; // r0
  _BOOL4 v11; // r3
  int v12; // r0
  char *v13; // r0
  signed int v14; // [sp+14h] [bp-898h]
  struct timeval timeout; // [sp+20h] [bp-88Ch] BYREF
  fd_set writefds; // [sp+28h] [bp-884h] BYREF
  char sa[2040]; // [sp+A8h] [bp-804h] BYREF

  v3 = 0;
  v4 = s;
  v5 = strlen(s) + 1;
  v14 = v5;
  while ( 1 )
  {
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( p_tv_usec != (fd_set *)&writefds.__fds_bits[31] );
    v7 = *a1;
    LOBYTE(v8) = *a1 & 0x1F;
    if ( *a1 <= 0 )
      v8 = -(-v7 & 0x1F);
    writefds.__fds_bits[*a1 / 32] |= 1 << v8;
    v9 = select(v7 + 1, 0, &writefds, 0, &timeout);
    if ( v9 <= 0 )
      break;
    v10 = send(*a1, v4, v5, 0);
    if ( v10 < 0 )
    {
      v12 = *_errno_location();
      if ( v12 != 11 )
      {
        if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
        {
          v13 = strerror(v12);
          snprintf(sa, 0x800u, "%s: send (%d:%d) failed %s", "send_api_result", v14, v14 - v5, v13);
          sub_1DD60(3, sa, 0);
        }
        return;
      }
      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        snprintf(sa, 0x800u, "%s: send EAGAIN ", "send_api_result");
        sub_1DD60(7, sa, 0);
      }
LABEL_9:
      ++v3;
      goto LABEL_10;
    }
    v5 -= v10;
    v4 += v10;
    if ( !v10 )
      goto LABEL_9;
LABEL_10:
    v11 = v3 > 2;
    if ( v5 <= 0 )
      v11 = 1;
    if ( v11 )
      return;
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(sa, 0x800u, "%s: send select failed, ret = %d", "send_api_result", v9);
    sub_1DD60(3, sa, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (00018C70) --------------------------------------------------------
int __fastcall sub_18C70(_DWORD *a1, int a2)
{
  bool v4; // zf
  _DWORD *v6; // r4
  char *v7; // r0
  char *v8; // r0
  char *v9; // r0
  char *v10; // r0
  int v11; // r4
  _DWORD *v12; // r5
  _QWORD *v13; // r0
  char *v14; // r0
  __int64 v15; // r0
  _QWORD *v16; // r0
  _QWORD *v17; // r0
  _QWORD *v18; // r0
  _QWORD *v19; // r0
  _QWORD *v20; // r0
  __int64 v21; // r0
  double *v22; // r0
  __int64 v23; // r0
  double *v24; // r0
  __int64 v25; // r0
  double *v26; // r0
  _QWORD *v27; // r0
  _QWORD *v28; // r0
  unsigned int v29; // r1
  int v30; // r0
  _DWORD *v31; // r2
  int v32; // r3
  int v33; // r12
  _QWORD *v34; // r0
  _QWORD *v35; // r0
  char *v36; // r6
  int v37; // r4
  int v38; // t1
  _QWORD *v39; // r0
  int v40; // r7
  _QWORD *v41; // r0
  int v42; // r8
  _DWORD *v43; // r4
  int v44; // r6
  int v45; // r4
  int v46; // r6
  _DWORD *v47; // r2
  int v48; // r3
  char *v49; // r0
  int v50; // r4
  int v51; // r6
  _DWORD *v52; // r2
  int v53; // r3
  char *v54; // r0
  int v55; // r4
  int v56; // r6
  _DWORD *v57; // r2
  int v58; // r3
  char *v59; // r0
  __int64 v60; // r0
  double *v61; // r0
  char *v62; // r0
  _QWORD *v63; // r0
  int v64; // r1
  _DWORD *v65; // r2
  int v66; // r3
  int v67; // r0
  _BOOL4 v68; // lr
  int v69; // r4
  _QWORD *v70; // r0
  __int64 v71; // r0
  double *v72; // r0
  _QWORD *v73; // r0
  _QWORD *v74; // r0
  int v75; // r6
  _DWORD *v76; // r2
  int v77; // r3
  __int64 v78; // r0
  _QWORD *v79; // r0
  int v80; // r4
  int v81; // r6
  _DWORD *v82; // r2
  int v83; // r3
  char *v84; // r0
  int v85; // r4
  int v86; // r6
  _DWORD *v87; // r2
  int v88; // r3
  __int64 v89; // r0
  _QWORD *v90; // r0
  int v91; // r4
  int v92; // r6
  _DWORD *v93; // r2
  int v94; // r3
  const char *v95; // r0
  char *v96; // r0
  int v97; // r4
  int v98; // r6
  _DWORD *v99; // r2
  int v100; // r3
  __int64 v101; // r0
  _QWORD *v102; // r0
  char *v103; // r0
  char *v104; // r0
  _QWORD *v105; // r0
  int v106; // r3
  int v107; // r0
  _QWORD *v108; // r0
  int v109; // r3
  int v110; // r0
  _QWORD *v111; // r0
  int v112; // r3
  int v113; // r0
  int *v114; // r0
  int *v115; // r0
  int v116; // [sp+14h] [bp-9E0h]
  __int64 i; // [sp+18h] [bp-9DCh]
  int v118; // [sp+24h] [bp-9D0h]
  __int64 v119; // [sp+28h] [bp-9CCh]
  _DWORD *v120; // [sp+38h] [bp-9BCh]
  __int16 v122; // [sp+5Ch] [bp-998h] BYREF
  double v123; // [sp+60h] [bp-994h] BYREF
  double v124; // [sp+68h] [bp-98Ch] BYREF
  double v125; // [sp+70h] [bp-984h] BYREF
  double v126; // [sp+78h] [bp-97Ch] BYREF
  char v127[4]; // [sp+80h] [bp-974h] BYREF
  int v128; // [sp+84h] [bp-970h]
  int v129; // [sp+88h] [bp-96Ch]
  int v130; // [sp+8Ch] [bp-968h]
  char s[32]; // [sp+90h] [bp-964h] BYREF
  char v132[64]; // [sp+B0h] [bp-944h] BYREF
  char v133[256]; // [sp+F0h] [bp-904h] BYREF
  char v134[2052]; // [sp+1F0h] [bp-804h] BYREF

  v123 = 0.0;
  v124 = 0.0;
  v125 = 0.0;
  v126 = 0.0;
  *(_DWORD *)v127 = 0;
  v128 = 0;
  v129 = 0;
  v130 = 0;
  memset(s, 0, sizeof(s));
  memset(v133, 0, sizeof(v133));
  v122 = 0;
  memset(v132, 0, sizeof(v132));
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( v4 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(v134, 0x800u, "%s: input bad api param\n", "get_stats_old");
      sub_1DD60(3, v134, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    sub_42680(&v122, 1u);
    if ( pthread_mutex_lock(&stru_76300) )
    {
      v114 = _errno_location();
      snprintf(
        v134,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v114,
        "api_new.c",
        "get_stats_old",
        979);
      sub_1DD60(3, v134, 1);
      sub_3C2EC(1);
    }
    sub_16A28(a1, 1, 70, *(const char **)(a2 + 8));
    v120 = sub_48E00();
    v6 = sub_48A70();
    v7 = (char *)sub_49004(a10);
    sub_49894(v6, "BMMiner", v7);
    v8 = (char *)sub_49004(byte_6A6D0);
    sub_49894(v6, "Miner", v8);
    v9 = (char *)sub_49004(byte_6A25C);
    sub_49894(v6, "CompileTime", v9);
    snprintf(v132, 0x40u, "%s", byte_6A35C);
    if ( byte_76324 )
      snprintf(v132, 0x40u, "%s", &byte_76324);
    v10 = (char *)sub_49004(v132);
    sub_49894(v6, "Type", v10);
    sub_49D54(v120, v6);
    if ( dword_74FE0 > 0 )
    {
      v118 = 0;
      v116 = 0;
      for ( i = 0; dword_74FE0 > (int)i; ++i )
      {
        v11 = sub_2DFF4(i);
        v12 = sub_48A70();
        v13 = sub_49250(i);
        sub_49894(v12, "STATS", v13);
        snprintf(v127, 0x10u, "BTM_SOC%d", (_DWORD)i);
        v14 = (char *)sub_49004(v127);
        sub_49894(v12, "ID", v14);
        LODWORD(v15) = sub_4ABAC(dbl_681C0);
        v16 = sub_49250(v15);
        sub_49894(v12, "Elapsed", v16);
        v17 = sub_49250(*(unsigned int *)(v11 + 292));
        sub_49894(v12, "Calls", v17);
        v18 = sub_49250(*(int *)(v11 + 296));
        sub_49894(v12, "Wait", v18);
        v19 = sub_49250(*(int *)(v11 + 304));
        sub_49894(v12, "Max", v19);
        v20 = sub_49250(*(int *)(v11 + 312));
        sub_49894(v12, "Min", v20);
        sscanf(byte_76424, "%lf", &v123);
        LODWORD(v21) = sub_4ABAC(v123 * 100.0);
        sub_4AB14(v21);
        v22 = sub_492D4();
        sub_49894(v12, "GHS 5s", v22);
        sscanf(&byte_76434[16], "%lf", &v125);
        LODWORD(v23) = sub_4ABAC(v125 * 100.0);
        sub_4AB14(v23);
        v24 = sub_492D4();
        sub_49894(v12, "GHS av", v24);
        sscanf(byte_76434, "%lf", &v124);
        LODWORD(v25) = sub_4ABAC(v124 * 100.0);
        sub_4AB14(v25);
        v26 = sub_492D4();
        sub_49894(v12, "rate_30m", v26);
        v27 = sub_49250(dword_68298);
        sub_49894(v12, "Mode", v27);
        v28 = sub_49250(dword_7631C);
        sub_49894(v12, "miner_count", v28);
        v29 = dword_7631C;
        if ( dword_7631C <= 0 )
        {
          if ( !dword_7631C )
            v29 = 1;
        }
        else
        {
          v30 = v116;
          v31 = &unk_76318;
          v32 = 0;
          do
          {
            v33 = v31[91];
            ++v32;
            v31 += 388;
            v30 += v33;
          }
          while ( v32 != dword_7631C && v32 != 4 );
          v116 = v30;
        }
        v116 = sub_4A548(v116, v29);
        LODWORD(v119) = v116;
        v34 = sub_49250(v116);
        sub_49894(v12, "frequency", v34);
        v35 = sub_49250(*(int *)&byte_76454[24]);
        sub_49894(v12, "fan_num", v35);
        if ( *(int *)&byte_76454[24] > 0 )
        {
          v36 = &byte_76454[28];
          v37 = 0;
          do
          {
            ++v37;
            memset(s, 0, sizeof(s));
            snprintf(s, 0x20u, "fan%d", v37);
            v38 = *(_DWORD *)v36;
            v36 += 4;
            v39 = sub_49250(v38);
            sub_49894(v12, s, v39);
          }
          while ( v37 < *(int *)&byte_76454[24] );
        }
        v40 = 0;
        v41 = sub_49250(dword_7631C);
        sub_49894(v12, "temp_num", v41);
        do
        {
          v42 = v40 + 1;
          if ( dword_7631C > 0 )
          {
            v43 = &unk_76318;
            v44 = 0;
            do
            {
              ++v44;
              if ( v43[90] == v40 )
              {
                memset(s, 0, sizeof(s));
                snprintf(s, 0x20u, "temp%d", v40 + 1);
                v106 = v43[170];
                v107 = v43[172];
                if ( v106 < v43[169] )
                  v106 = v43[169];
                if ( v106 < -255 )
                  v106 = -255;
                if ( v106 < v43[171] )
                  v106 = v43[171];
                if ( v106 >= v107 )
                  v107 = v106;
                v108 = sub_49250(v107);
                sub_49894(v12, s, v108);
                memset(s, 0, sizeof(s));
                snprintf(s, 0x20u, "temp2_%d", v40 + 1);
                v109 = v43[174];
                v110 = v43[176];
                if ( v109 < v43[173] )
                  v109 = v43[173];
                if ( v109 < -255 )
                  v109 = -255;
                if ( v109 < v43[175] )
                  v109 = v43[175];
                if ( v109 >= v110 )
                  v110 = v109;
                v111 = sub_49250(v110);
                sub_49894(v12, s, v111);
              }
              v43 += 388;
            }
            while ( dword_7631C > v44 );
          }
          ++v40;
        }
        while ( v42 != 4 );
        v45 = 0;
        do
        {
          v46 = v45 + 1;
          memset(s, 0, sizeof(s));
          memset(v133, 0, sizeof(v133));
          snprintf(s, 0x20u, "temp_pcb%d", v45 + 1);
          if ( dword_7631C > 0 )
          {
            if ( *(_DWORD *)&byte_76454[44] == v45 )
            {
              v48 = 0;
LABEL_37:
              snprintf(
                v133,
                0x100u,
                "%d-%d-%d-%d",
                *((_DWORD *)&unk_76318 + 388 * v48 + 169),
                *((_DWORD *)&unk_76318 + 388 * v48 + 170),
                *((_DWORD *)&unk_76318 + 388 * v48 + 171),
                *((_DWORD *)&unk_76318 + 388 * v48 + 172));
              goto LABEL_38;
            }
            v47 = &unk_76318;
            v48 = 0;
            while ( 1 )
            {
              ++v48;
              v47 += 388;
              if ( dword_7631C == v48 )
                goto LABEL_130;
              if ( v48 == 4 )
                break;
              if ( v47[90] == v45 )
                goto LABEL_37;
            }
            if ( dword_7631C > 4 )
              goto LABEL_37;
          }
LABEL_130:
          strcpy(v133, "0-0-0-0");
LABEL_38:
          ++v45;
          v49 = (char *)sub_49004(v133);
          sub_49894(v12, s, v49);
        }
        while ( v46 != 4 );
        v50 = 0;
        do
        {
          v51 = v50 + 1;
          memset(s, 0, sizeof(s));
          memset(v133, 0, sizeof(v133));
          snprintf(s, 0x20u, "temp_chip%d", v50 + 1);
          if ( dword_7631C > 0 )
          {
            if ( *(_DWORD *)&byte_76454[44] == v50 )
            {
              v53 = 0;
LABEL_46:
              snprintf(
                v133,
                0x100u,
                "%d-%d-%d-%d",
                *((_DWORD *)&unk_76318 + 388 * v53 + 173),
                *((_DWORD *)&unk_76318 + 388 * v53 + 174),
                *((_DWORD *)&unk_76318 + 388 * v53 + 175),
                *((_DWORD *)&unk_76318 + 388 * v53 + 176));
              goto LABEL_47;
            }
            v52 = &unk_76318;
            v53 = 0;
            while ( 1 )
            {
              ++v53;
              v52 += 388;
              if ( dword_7631C == v53 )
                goto LABEL_128;
              if ( v53 == 4 )
                break;
              if ( v52[90] == v50 )
                goto LABEL_46;
            }
            if ( dword_7631C > 4 )
              goto LABEL_46;
          }
LABEL_128:
          strcpy(v133, "0-0-0-0");
LABEL_47:
          ++v50;
          v54 = (char *)sub_49004(v133);
          sub_49894(v12, s, v54);
        }
        while ( v51 != 4 );
        v55 = 0;
        do
        {
          v56 = v55 + 1;
          memset(s, 0, sizeof(s));
          memset(v133, 0, sizeof(v133));
          snprintf(s, 0x20u, "temp_pic%d", v55 + 1);
          if ( dword_7631C > 0 )
          {
            if ( *(_DWORD *)&byte_76454[44] == v55 )
            {
              v58 = 0;
LABEL_55:
              snprintf(
                v133,
                0x100u,
                "%d-%d-%d-%d",
                *((_DWORD *)&unk_76318 + 388 * v58 + 165),
                *((_DWORD *)&unk_76318 + 388 * v58 + 166),
                *((_DWORD *)&unk_76318 + 388 * v58 + 167),
                *((_DWORD *)&unk_76318 + 388 * v58 + 168));
              goto LABEL_56;
            }
            v57 = &unk_76318;
            v58 = 0;
            while ( 1 )
            {
              ++v58;
              v57 += 388;
              if ( dword_7631C == v58 )
                goto LABEL_126;
              if ( v58 == 4 )
                break;
              if ( v57[90] == v55 )
                goto LABEL_55;
            }
            if ( dword_7631C > 4 )
              goto LABEL_55;
          }
LABEL_126:
          strcpy(v133, "0-0-0-0");
LABEL_56:
          ++v55;
          v59 = (char *)sub_49004(v133);
          sub_49894(v12, s, v59);
        }
        while ( v56 != 4 );
        sscanf(byte_76454, "%lf", &v126);
        LODWORD(v60) = sub_4ABAC(v126 * 100.0);
        sub_4AB14(v60);
        v61 = sub_492D4();
        sub_49894(v12, "total_rateideal", v61);
        v62 = (char *)sub_49004("GH");
        sub_49894(v12, "rate_unit", v62);
        HIDWORD(v119) = v116 >> 31;
        v63 = sub_49250(v119);
        sub_49894(v12, "total_freqavg", v63);
        if ( dword_7631C > 0 )
        {
          v64 = v118;
          v65 = &unk_76318;
          v66 = 0;
          do
          {
            ++v66;
            v67 = v65[100];
            v65 += 388;
            v68 = dword_7631C > v66;
            v64 += v67;
            if ( v66 > 3 )
              v68 = 0;
          }
          while ( v68 );
          v118 = v64;
        }
        v69 = 0;
        v70 = sub_49250(v118);
        sub_49894(v12, "total_acn", v70);
        LODWORD(v71) = sub_4ABAC(v125 * 100.0);
        sub_4AB14(v71);
        v72 = sub_492D4();
        sub_49894(v12, "total rate", v72);
        v73 = sub_49250(0);
        sub_49894(v12, "temp_max", v73);
        v74 = sub_49250(dword_76060);
        sub_49894(v12, "no_matching_work", v74);
        while ( 2 )
        {
          v75 = v69 + 1;
          memset(s, 0, sizeof(s));
          snprintf(s, 0x20u, "chain_acn%d", v69 + 1);
          if ( dword_7631C <= 0 )
          {
LABEL_124:
            v78 = 0;
          }
          else
          {
            if ( *(_DWORD *)&byte_76454[44] == v69 )
            {
              v77 = 0;
            }
            else
            {
              v76 = &unk_76318;
              v77 = 0;
              while ( 1 )
              {
                ++v77;
                v76 += 388;
                if ( dword_7631C == v77 )
                  goto LABEL_124;
                if ( v77 == 4 )
                  break;
                if ( v76[90] == v69 )
                  goto LABEL_70;
              }
              if ( dword_7631C <= 4 )
                goto LABEL_124;
            }
LABEL_70:
            v78 = *((int *)&unk_76318 + 388 * v77 + 100);
          }
          ++v69;
          v79 = sub_49250(v78);
          sub_49894(v12, s, v79);
          if ( v75 != 4 )
            continue;
          break;
        }
        v80 = 0;
        do
        {
          v81 = v80 + 1;
          memset(s, 0, sizeof(s));
          memset(v133, 0, sizeof(v133));
          snprintf(s, 0x20u, "chain_acs%d", v80 + 1);
          if ( dword_7631C <= 0 )
            goto LABEL_122;
          if ( *(_DWORD *)&byte_76454[44] == v80 )
          {
            v112 = 404;
            goto LABEL_81;
          }
          v82 = &unk_76318;
          v83 = 0;
          while ( 1 )
          {
            ++v83;
            v82 += 388;
            if ( v83 == dword_7631C )
              goto LABEL_122;
            if ( v83 == 4 )
              break;
            if ( v82[90] == v80 )
            {
              v112 = 1552 * v83 + 404;
              goto LABEL_81;
            }
          }
          if ( dword_7631C > 4 )
          {
            v112 = 6612;
LABEL_81:
            snprintf(v133, 0x100u, "%s", (const char *)&unk_76318 + v112);
          }
          else
          {
LABEL_122:
            v133[0] = 0;
          }
          ++v80;
          v84 = (char *)sub_49004(v133);
          sub_49894(v12, s, v84);
        }
        while ( v81 != 4 );
        v85 = 0;
        while ( 2 )
        {
          v86 = v85 + 1;
          memset(s, 0, sizeof(s));
          snprintf(s, 0x20u, "chain_hw%d", v85 + 1);
          if ( dword_7631C <= 0 )
          {
LABEL_120:
            v89 = 0;
          }
          else
          {
            if ( *(_DWORD *)&byte_76454[44] == v85 )
            {
              v88 = 0;
            }
            else
            {
              v87 = &unk_76318;
              v88 = 0;
              while ( 1 )
              {
                ++v88;
                v87 += 388;
                if ( dword_7631C == v88 )
                  goto LABEL_120;
                if ( v88 == 4 )
                  break;
                if ( v87[90] == v85 )
                  goto LABEL_90;
              }
              if ( dword_7631C <= 4 )
                goto LABEL_120;
            }
LABEL_90:
            v89 = *((int *)&unk_76318 + 388 * v88 + 177);
          }
          ++v85;
          v90 = sub_49250(v89);
          sub_49894(v12, s, v90);
          if ( v86 != 4 )
            continue;
          break;
        }
        v91 = 0;
        do
        {
          v92 = v91 + 1;
          memset(s, 0, sizeof(s));
          snprintf(s, 0x20u, "chain_rate%d", v91 + 1);
          if ( dword_7631C <= 0 )
            goto LABEL_131;
          if ( *(_DWORD *)&byte_76454[44] == v91 )
          {
            v113 = 384;
            goto LABEL_101;
          }
          v93 = &unk_76318;
          v94 = 0;
          while ( 1 )
          {
            ++v94;
            v93 += 388;
            if ( v94 == dword_7631C )
              goto LABEL_131;
            if ( v94 == 4 )
              break;
            if ( v93[90] == v91 )
            {
              v113 = 1552 * v94 + 384;
              goto LABEL_101;
            }
          }
          if ( dword_7631C <= 4 )
          {
LABEL_131:
            v95 = "";
          }
          else
          {
            v113 = 6592;
LABEL_101:
            v95 = (char *)&unk_76318 + v113;
          }
          v96 = (char *)sub_49004(v95);
          ++v91;
          sub_49894(v12, s, v96);
        }
        while ( v92 != 4 );
        v97 = 0;
        while ( 2 )
        {
          v98 = v97 + 1;
          memset(s, 0, sizeof(s));
          snprintf(s, 0x20u, "freq%d", v97 + 1);
          if ( dword_7631C <= 0 )
          {
LABEL_116:
            v101 = 0;
          }
          else
          {
            if ( *(_DWORD *)&byte_76454[44] != v97 )
            {
              v99 = &unk_76318;
              v100 = 0;
              while ( 1 )
              {
                ++v100;
                v99 += 388;
                if ( v100 == dword_7631C )
                  goto LABEL_116;
                if ( v100 == 4 )
                {
                  if ( dword_7631C > 4 )
                    goto LABEL_110;
                  goto LABEL_116;
                }
                if ( v99[90] == v97 )
                  goto LABEL_110;
              }
            }
            v100 = 0;
LABEL_110:
            v101 = *((int *)&unk_76318 + 388 * v100 + 91);
          }
          ++v97;
          v102 = sub_49250(v101);
          sub_49894(v12, s, v102);
          if ( v98 != 4 )
            continue;
          break;
        }
        v103 = (char *)sub_49004(byte_6A6D0);
        sub_49894(v12, "miner_version", v103);
        v104 = (char *)sub_49004(byte_77CF8);
        sub_49894(v12, "miner_id", v104);
        sub_49D54(v120, v12);
      }
    }
    sub_49894(a1, "STATS", v120);
    v105 = sub_49250(1);
    sub_49894(a1, "id", v105);
    if ( pthread_mutex_unlock(&stru_76300) )
    {
      v115 = _errno_location();
      snprintf(
        v134,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v115,
        "api_new.c",
        "get_stats_old",
        1254);
      sub_1DD60(3, v134, 1);
      sub_3C2EC(1);
    }
    off_67964();
    return 0;
  }
}
// 18F78: variable 'v15' is possibly undefined
// 19034: variable 'v21' is possibly undefined
// 19078: variable 'v23' is possibly undefined
// 190BC: variable 'v25' is possibly undefined
// 19594: variable 'v60' is possibly undefined
// 1967C: variable 'v71' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681C0: using guessed type double dbl_681C0;
// 68298: using guessed type int dword_68298;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 74FE0: using guessed type int dword_74FE0;
// 76060: using guessed type int dword_76060;
// 76300: using guessed type pthread_mutex_t stru_76300;
// 7631C: using guessed type int dword_7631C;
// 76324: using guessed type char byte_76324;

//----- (00019DF0) --------------------------------------------------------
int __fastcall sub_19DF0(_DWORD *a1, int a2)
{
  bool v2; // zf
  int v5; // r7
  int *v6; // r3
  int v7; // t1
  int v8; // r2
  __int64 v9; // kr00_8
  _DWORD *v10; // r5
  int v11; // r2
  int v12; // r4
  int v13; // r1
  int v14; // t1
  int v15; // r3
  int v16; // r4
  _QWORD *v17; // r0
  char *v18; // r0
  _QWORD *v19; // r0
  const char *v20; // r0
  char *v21; // r0
  char *v22; // r0
  __int64 v23; // r0
  double v24; // r0
  double v25; // d0
  double *v26; // r0
  double v27; // d9
  __int64 v28; // r0
  double *v29; // r0
  __int64 v30; // r0
  double *v31; // r0
  _QWORD *v32; // r0
  _QWORD *v33; // r0
  _QWORD *v34; // r0
  __int64 v35; // r0
  double *v36; // r0
  __int64 v37; // r0
  int v38; // r3
  _QWORD *v39; // r0
  _QWORD *v40; // r0
  __int64 v41; // r0
  double *v42; // r0
  _QWORD *v43; // r0
  __int64 v44; // r0
  _QWORD *v45; // r0
  __int64 v46; // r0
  _QWORD *v47; // r0
  _QWORD *v48; // r0
  _QWORD *v49; // r0
  int v50; // r3
  __int64 v51; // r0
  double v52; // d9
  double v53; // r0
  __int64 v54; // r0
  double *v55; // r0
  __int64 v56; // r0
  double v57; // d0
  double v58; // r0
  __int64 v59; // r0
  double v60; // r0
  double *v61; // r0
  __int64 v62; // r0
  _QWORD *v63; // r0
  _QWORD *v64; // r0
  int *v65; // r0
  int *v66; // r0
  int *v67; // r0
  int *v68; // r0
  int *v69; // r0
  _DWORD *v71; // [sp+1Ch] [bp-810h]
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      return -2147483646;
    snprintf(s, 0x800u, "%s: input bad api param\n", "get_devs_old");
    sub_1DD60(3, s, 0);
    return -2147483646;
  }
  if ( pthread_rwlock_rdlock(&stru_74FC0) )
  {
    v69 = _errno_location();
    snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v69, "api_new.c", "numascs", 1266);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( dword_74FE0 <= 0 )
  {
    if ( !pthread_rwlock_unlock(&stru_74FC0) )
    {
      off_67964();
      goto LABEL_47;
    }
LABEL_52:
    v67 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v67, "api_new.c", "numascs", 1271);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v5 = 0;
  v6 = (int *)dword_74F68;
  do
  {
    v7 = *v6++;
    v8 = **(_DWORD **)(v7 + 4);
    if ( v8 == 2 || v8 == 3 )
      ++v5;
  }
  while ( (int *)(dword_74F68 + 4 * dword_74FE0) != v6 );
  if ( pthread_rwlock_unlock(&stru_74FC0) )
    goto LABEL_52;
  off_67964();
  if ( !v5 )
  {
LABEL_47:
    sub_16A28(a1, 0, 10, "No ASCs");
    return 0;
  }
  sub_16A28(a1, 1, 9, *(const char **)(a2 + 8));
  v71 = sub_48E00();
  v9 = 0;
  do
  {
    v10 = sub_48A70();
    if ( pthread_rwlock_rdlock(&stru_74FC0) )
    {
      v65 = _errno_location();
      snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v65, "api_new.c", "ascdevice", 1279);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    if ( dword_74FE0 <= 0 )
    {
LABEL_48:
      if ( pthread_rwlock_unlock(&stru_74FC0) )
      {
        v66 = _errno_location();
        snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v66, "api_new.c", "ascdevice", 1287);
        sub_1DD60(3, s, 1);
        sub_3C2EC(1);
      }
      v12 = -1;
      off_67964();
    }
    else
    {
      v11 = 0;
      v12 = 0;
      v13 = dword_74F68 - 4;
      while ( 1 )
      {
        v14 = *(_DWORD *)(v13 + 4);
        v13 += 4;
        v15 = **(_DWORD **)(v14 + 4);
        if ( v15 == 2 || v15 == 3 )
          ++v11;
        if ( v11 == (_DWORD)v9 + 1 )
          break;
        if ( ++v12 == dword_74FE0 )
          goto LABEL_48;
      }
      if ( pthread_rwlock_unlock(&stru_74FC0) )
      {
        v68 = _errno_location();
        snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v68, "api_new.c", "ascdevice", 1292);
        sub_1DD60(3, s, 1);
        sub_3C2EC(1);
      }
      off_67964();
    }
    v16 = sub_2DFF4(v12);
    v17 = sub_49250(v9);
    sub_49894(v10, "ASC", v17);
    v18 = (char *)sub_49004(*(const char **)(*(_DWORD *)(v16 + 4) + 8));
    sub_49894(v10, "Name", v18);
    v19 = sub_49250(*(int *)(v16 + 8));
    sub_49894(v10, "ID", v19);
    if ( *(_DWORD *)(v16 + 32) == 1 )
      LOWORD(v20) = -19904;
    else
      LOWORD(v20) = -19920;
    HIWORD(v20) = 4;
    v21 = (char *)sub_49004(v20);
    sub_49894(v10, "Enabled", v21);
    v22 = (char *)sub_49004("Alive");
    sub_49894(v10, "Status", v22);
    LODWORD(v23) = sub_4ABAC(*(double *)(v16 + 176) * 100.0);
    LODWORD(v24) = sub_4AB14(v23);
    v25 = v24 / 100.0;
    v26 = sub_492D4();
    sub_49894(v10, "Tenperature", v26);
    v27 = *(double *)(v16 + 80);
    sub_2A7A0(v16);
    LODWORD(v28) = sub_4ABAC(v27 / v25 * 100.0);
    sub_4AB14(v28);
    v29 = sub_492D4();
    sub_49894(v10, "MHS av", v29);
    snprintf(s, 0x18u, "MHS %ds", dword_681D0);
    LODWORD(v30) = sub_4ABAC(*(double *)(v16 + 48) * 100.0);
    sub_4AB14(v30);
    v31 = sub_492D4();
    sub_49894(v10, s, v31);
    v32 = sub_49250(*(int *)(v16 + 36));
    sub_49894(v10, "Accepted", v32);
    v33 = sub_49250(*(int *)(v16 + 40));
    sub_49894(v10, "Rejected", v33);
    v34 = sub_49250(*(int *)(v16 + 44));
    sub_49894(v10, "Hardware Errors", v34);
    LODWORD(v35) = sub_4ABAC(*(double *)(v16 + 88) * 100.0);
    sub_4AB14(v35);
    v36 = sub_492D4();
    sub_49894(v10, "Utility", v36);
    v38 = *(_DWORD *)(v16 + 220);
    if ( v38 <= 0 )
      v37 = -1;
    else
      LODWORD(v37) = *(_DWORD *)(v16 + 216);
    if ( v38 > 0 )
      v37 = (int)v37;
    v39 = sub_49250(v37);
    sub_49894(v10, "Last Share Pool", v39);
    v40 = sub_49250(*(int *)(v16 + 220));
    sub_49894(v10, "Last Share Time", v40);
    LODWORD(v41) = sub_4ABAC(*(double *)(v16 + 80) * 100.0);
    sub_4AB14(v41);
    v42 = sub_492D4();
    sub_49894(v10, "Total MH", v42);
    v43 = sub_49250(*(_QWORD *)(v16 + 192));
    sub_49894(v10, "Diff1 Work", v43);
    LODWORD(v44) = sub_4ABAC(*(double *)(v16 + 200));
    v45 = sub_49250(v44);
    sub_49894(v10, "Difficulty Accepted", v45);
    LODWORD(v46) = sub_4ABAC(*(double *)(v16 + 208));
    v47 = sub_49250(v46);
    sub_49894(v10, "Difficulty Rejected", v47);
    v48 = sub_49250(*(int *)(v16 + 232));
    sub_49894(v10, "Last Share Difficulty", v48);
    v49 = sub_49250(*(int *)(v16 + 232));
    sub_49894(v10, "Last Valid Work", v49);
    v50 = *(_DWORD *)(v16 + 44);
    v51 = *(_QWORD *)(v16 + 192) + v50;
    if ( v51 )
    {
      v52 = (double)v50;
      LODWORD(v53) = sub_4AB14(v51);
      LODWORD(v54) = sub_4ABAC(v52 / v53 * 100.0);
      sub_4AB14(v54);
    }
    v55 = sub_492D4();
    sub_49894(v10, "Device Hardware%", v55);
    v56 = *(_QWORD *)(v16 + 192);
    if ( v56 )
    {
      LODWORD(v58) = sub_4AB14(v56);
      LODWORD(v59) = sub_4ABAC(*(double *)(v16 + 208) / v58 * 100.0);
      LODWORD(v60) = sub_4AB14(v59);
      v57 = v60 / 100.0;
    }
    else
    {
      v57 = 0.0;
    }
    v61 = sub_492D4();
    sub_49894(v10, "Device Rejected%", v61);
    sub_2A7A0(v16);
    LODWORD(v62) = sub_4ABAC(v57);
    v63 = sub_49250(v62);
    sub_49894(v10, "Device Elapsed", v63);
    sub_49D54(v71, v10);
    ++v9;
  }
  while ( v5 > (int)v9 );
  sub_49894(a1, "DEVS", v71);
  v64 = sub_49250(1);
  sub_49894(a1, "id", v64);
  return 0;
}
// 1A0FC: variable 'v23' is possibly undefined
// 1A104: variable 'v24' is possibly undefined
// 1A13C: variable 'v28' is possibly undefined
// 1A18C: variable 'v30' is possibly undefined
// 1A21C: variable 'v35' is possibly undefined
// 1A258: variable 'v37' is possibly undefined
// 1A2A0: variable 'v41' is possibly undefined
// 1A2E8: variable 'v44' is possibly undefined
// 1A308: variable 'v46' is possibly undefined
// 1A394: variable 'v53' is possibly undefined
// 1A3A4: variable 'v54' is possibly undefined
// 1A3E4: variable 'v58' is possibly undefined
// 1A3F4: variable 'v59' is possibly undefined
// 1A3FC: variable 'v60' is possibly undefined
// 1A428: variable 'v62' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681D0: using guessed type int dword_681D0;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 74F68: using guessed type int dword_74F68;
// 74FC0: using guessed type pthread_rwlock_t stru_74FC0;
// 74FE0: using guessed type int dword_74FE0;

//----- (0001A6C8) --------------------------------------------------------
int __fastcall sub_1A6C8(_DWORD *a1, const char **a2)
{
  int v4; // r4
  int v5; // r6
  char *v6; // r0
  _DWORD *v7; // r8
  int v8; // r4
  int v9; // r5
  int v10; // r3
  char *v11; // r0
  char *v12; // r7
  int v13; // r9
  _DWORD *v14; // r0
  int v15; // r4
  int v16; // r3
  _DWORD *v17; // r8
  char *v18; // r0
  _DWORD *v19; // r5
  char *v20; // r11
  int v21; // t1
  _QWORD *v22; // r0
  int *v23; // r0
  int *v24; // r0
  _DWORD *v25; // [sp+10h] [bp-83Ch]
  int v26; // [sp+14h] [bp-838h]
  _DWORD *v28; // [sp+28h] [bp-824h]
  _DWORD *v29; // [sp+2Ch] [bp-820h]
  __int16 v30; // [sp+34h] [bp-818h] BYREF
  char v31[4]; // [sp+38h] [bp-814h] BYREF
  int v32; // [sp+3Ch] [bp-810h]
  char v33[4]; // [sp+40h] [bp-80Ch] BYREF
  int v34; // [sp+44h] [bp-808h]
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  v34 = 0;
  *(_DWORD *)v31 = 0;
  v32 = 0;
  *(_DWORD *)v33 = 0;
  v30 = 0;
  if ( a2 )
  {
    sub_42680(&v30, 1u);
    sub_16DAC((int)a1, a2);
    sub_168E8(a1);
    if ( pthread_mutex_lock(&stru_76300) )
    {
      v23 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v23, "api_new.c", "get_rate", 625);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    v4 = dword_77D1C;
    v26 = dword_77D1C;
    if ( dword_77D1C >= 24 )
      v5 = 24;
    else
      v5 = dword_77D1C;
    v29 = sub_48E00();
    v28 = sub_48A70();
    snprintf(v33, 8u, "%s/s", &byte_76454[16]);
    v6 = (char *)sub_49004(v33);
    sub_49894(v28, "unit", v6);
    v7 = sub_48E00();
    if ( v4 > 0 )
    {
      v8 = 0;
      v9 = 15;
      do
      {
        v10 = v9;
        *(_DWORD *)v31 = 0;
        ++v8;
        v32 = 0;
        v9 += 15;
        snprintf(v31, 8u, "%dmin", v10);
        v11 = (char *)sub_49004(v31);
        sub_49D54(v7, v11);
      }
      while ( v8 < v5 );
    }
    sub_49894(v28, "xAxis", v7);
    v25 = sub_48E00();
    if ( dword_7631C > 0 )
    {
      v12 = &byte_76454[392];
      v13 = 0;
      do
      {
        v14 = sub_48A70();
        v15 = 0;
        v16 = *((_DWORD *)v12 - 87);
        v17 = v14;
        *(_DWORD *)v31 = 0;
        v32 = 0;
        snprintf(v31, 8u, "chain%d", v16);
        v18 = (char *)sub_49004(v31);
        sub_49894(v17, "name", v18);
        v19 = sub_48E00();
        if ( v26 > 0 )
        {
          v20 = v12;
          do
          {
            v21 = *((_DWORD *)v20 + 1);
            v20 += 4;
            ++v15;
            v22 = sub_49250(v21);
            sub_49D54(v19, v22);
          }
          while ( v5 > v15 );
        }
        ++v13;
        sub_49894(v17, "data", v19);
        sub_49D54(v25, v17);
        v12 += 1552;
      }
      while ( dword_7631C > v13 );
    }
    sub_49894(v28, "series", v25);
    sub_49D54(v29, v28);
    sub_49894(a1, "RATE", v29);
    if ( pthread_mutex_unlock(&stru_76300) )
    {
      v24 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v24, "api_new.c", "get_rate", 664);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    off_67964();
    return 0;
  }
  else if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(s, 0x800u, "%s: input bad api param\n", "get_rate");
    sub_1DD60(3, s, 0);
    return -2147483646;
  }
  else
  {
    return -2147483646;
  }
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 76300: using guessed type pthread_mutex_t stru_76300;
// 7631C: using guessed type int dword_7631C;
// 77D1C: using guessed type int dword_77D1C;

//----- (0001AA98) --------------------------------------------------------
int __fastcall sub_1AA98(_DWORD *a1, const char **a2)
{
  _DWORD *v5; // r10
  _DWORD *v6; // r6
  __int64 v7; // r0
  _QWORD *v8; // r0
  __int64 v9; // r0
  double *v10; // r0
  __int64 v11; // r0
  double *v12; // r0
  __int64 v13; // r0
  double *v14; // r0
  __int64 v15; // r0
  double *v16; // r0
  char *v17; // r0
  _QWORD *v18; // r0
  _QWORD *v19; // r0
  _DWORD *v20; // r8
  char **v21; // r4
  _DWORD *v22; // r5
  char *v23; // r0
  char *v24; // t1
  int *v25; // r0
  int *v26; // r0
  __int16 v27; // [sp+14h] [bp-82Ch] BYREF
  double v28; // [sp+18h] [bp-828h] BYREF
  double v29; // [sp+20h] [bp-820h] BYREF
  double v30; // [sp+28h] [bp-818h] BYREF
  double v31; // [sp+30h] [bp-810h] BYREF
  char v32[4]; // [sp+38h] [bp-808h] BYREF
  int v33; // [sp+3Ch] [bp-804h]
  char s[2048]; // [sp+40h] [bp-800h] BYREF

  v28 = 0.0;
  v33 = 0;
  *(_DWORD *)v32 = 0;
  v27 = 0;
  v29 = 0.0;
  v30 = 0.0;
  v31 = 0.0;
  if ( a2 )
  {
    sub_42680(&v27, 1u);
    sub_16DAC((int)a1, a2);
    if ( pthread_mutex_lock(&stru_76300) )
    {
      v25 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v25, "api_new.c", "get_summary", 345);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    sub_168E8(a1);
    v5 = sub_48E00();
    v6 = sub_48A70();
    if ( dword_76320 <= 1 )
    {
      if ( dword_76320 == 1 )
        sub_3D190();
      v7 = 0;
    }
    else
    {
      LODWORD(v7) = sub_4ABAC(dbl_681C0);
    }
    v8 = sub_49250(v7);
    sub_49894(v6, "elapsed", v8);
    sscanf(byte_76424, "%lf", &v28);
    LODWORD(v9) = sub_4ABAC(v28 * 100.0);
    sub_4AB14(v9);
    v10 = sub_492D4();
    sub_49894(v6, "rate_5s", v10);
    sscanf(byte_76434, "%lf", &v29);
    LODWORD(v11) = sub_4ABAC(v29 * 100.0);
    sub_4AB14(v11);
    v12 = sub_492D4();
    sub_49894(v6, "rate_30m", v12);
    sscanf(&byte_76434[16], "%lf", &v30);
    LODWORD(v13) = sub_4ABAC(v30 * 100.0);
    sub_4AB14(v13);
    v14 = sub_492D4();
    sub_49894(v6, "rate_avg", v14);
    sscanf(byte_76454, "%lf", &v31);
    LODWORD(v15) = sub_4ABAC(v31 * 100.0);
    sub_4AB14(v15);
    v16 = sub_492D4();
    sub_49894(v6, "rate_ideal", v16);
    snprintf(v32, 8u, "%s/s", &byte_76454[16]);
    v17 = (char *)sub_49004(v32);
    sub_49894(v6, "rate_unit", v17);
    v18 = sub_49250(dword_76060);
    sub_49894(v6, "hw_all", v18);
    v19 = sub_49250(*(__int64 *)&dword_68B00);
    sub_49894(v6, "bestshare", v19);
    v20 = sub_48E00();
    if ( v20 && off_673C8 )
    {
      v21 = &off_673C8;
      do
      {
        v22 = sub_48A70();
        v23 = (char *)sub_49004(*v21);
        sub_49894(v22, "type", v23);
        ((void (__fastcall *)(_DWORD *, char **))v21[1])(v22, v21);
        sub_49D54(v20, v22);
        v24 = v21[6];
        v21 += 6;
      }
      while ( v24 );
    }
    sub_49894(v6, "status", v20);
    sub_49D54(v5, v6);
    sub_49894(a1, "SUMMARY", v5);
    if ( pthread_mutex_unlock(&stru_76300) )
    {
      v26 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v26, "api_new.c", "get_summary", 398);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    off_67964();
    return 0;
  }
  else if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(s, 0x800u, "%s: input bad api param\n", "get_summary");
    sub_1DD60(3, s, 0);
    return -2147483646;
  }
  else
  {
    return -2147483646;
  }
}
// 1ABB8: variable 'v7' is possibly undefined
// 1ABF8: variable 'v9' is possibly undefined
// 1AC40: variable 'v11' is possibly undefined
// 1AC88: variable 'v13' is possibly undefined
// 1ACD0: variable 'v15' is possibly undefined
// 673C8: using guessed type char *off_673C8;
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681C0: using guessed type double dbl_681C0;
// 686E0: using guessed type char byte_686E0;
// 68B00: using guessed type int dword_68B00;
// 72D90: using guessed type char byte_72D90;
// 76060: using guessed type int dword_76060;
// 76300: using guessed type pthread_mutex_t stru_76300;
// 76320: using guessed type int dword_76320;

//----- (0001AF38) --------------------------------------------------------
int __fastcall sub_1AF38(_DWORD *a1, int a2)
{
  bool v2; // zf
  _DWORD *v6; // r4
  __int64 v7; // r0
  _QWORD *v8; // r0
  __int64 v9; // r0
  double *v10; // r0
  __int64 v11; // r0
  double *v12; // r0
  __int64 v13; // r0
  double *v14; // r0
  _QWORD *v15; // r0
  _QWORD *v16; // r0
  _QWORD *v17; // r0
  _QWORD *v18; // r0
  _QWORD *v19; // r0
  __int64 v20; // r0
  double v21; // r0
  double v22; // d7
  __int64 v23; // r0
  double v24; // r0
  __int64 v25; // r0
  double *v26; // r0
  _QWORD *v27; // r0
  _QWORD *v28; // r0
  _QWORD *v29; // r0
  _QWORD *v30; // r0
  _QWORD *v31; // r0
  _QWORD *v32; // r0
  __int64 v33; // r0
  double *v34; // r0
  double v35; // r0
  double v36; // d7
  __int64 v37; // r0
  double *v38; // r0
  __int64 v39; // r0
  double *v40; // r0
  __int64 v41; // r0
  double *v42; // r0
  __int64 v43; // r0
  double *v44; // r0
  _QWORD *v45; // r0
  __int64 v46; // r10
  double *v47; // r0
  double v48; // r0
  __int64 v49; // r0
  double *v50; // r0
  double v51; // d7
  __int64 v52; // r0
  double *v53; // r0
  double v54; // d7
  __int64 v55; // r0
  double *v56; // r0
  _QWORD *v57; // r0
  _QWORD *v58; // r0
  double v59; // d9
  double v60; // r0
  __int64 v61; // r0
  int *v62; // r0
  int *v63; // r0
  _DWORD *v64; // [sp+14h] [bp-828h]
  __int16 v65; // [sp+1Ch] [bp-820h] BYREF
  double v66; // [sp+20h] [bp-81Ch] BYREF
  double v67; // [sp+28h] [bp-814h] BYREF
  double v68; // [sp+30h] [bp-80Ch] BYREF
  char s[2052]; // [sp+38h] [bp-804h] BYREF

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  v66 = 0.0;
  v67 = 0.0;
  v68 = 0.0;
  v65 = 0;
  if ( v2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: input bad api param\n", "get_summary_old");
      sub_1DD60(3, s, 0);
      return -2147483646;
    }
    else
    {
      return -2147483646;
    }
  }
  else
  {
    sub_42680(&v65, 1u);
    if ( pthread_mutex_lock(&stru_76300) )
    {
      v63 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v63, "api_new.c", "get_summary_old", 749);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    sub_16A28(a1, 1, 11, *(const char **)(a2 + 8));
    v64 = sub_48E00();
    v6 = sub_48A70();
    LODWORD(v7) = sub_4ABAC(dbl_681C0);
    v8 = sub_49250(v7);
    sub_49894(v6, "Elapsed", v8);
    sscanf(byte_76424, "%lf", &v66);
    LODWORD(v9) = sub_4ABAC(v66 * 100.0);
    sub_4AB14(v9);
    v10 = sub_492D4();
    sub_49894(v6, "GHS 5s", v10);
    sscanf(&byte_76434[16], "%lf", &v68);
    LODWORD(v11) = sub_4ABAC(v68 * 100.0);
    sub_4AB14(v11);
    v12 = sub_492D4();
    sub_49894(v6, "GHS av", v12);
    sscanf(byte_76434, "%lf", &v67);
    LODWORD(v13) = sub_4ABAC(v67 * 100.0);
    sub_4AB14(v13);
    v14 = sub_492D4();
    sub_49894(v6, "GHS 30m", v14);
    v15 = sub_49250((unsigned int)dword_76074);
    sub_49894(v6, "Found Blocks", v15);
    v16 = sub_49250(*(__int64 *)&dword_74F88);
    sub_49894(v6, "Getwork", v16);
    v17 = sub_49250(qword_72EF0);
    sub_49894(v6, "Accepted", v17);
    v18 = sub_49250(qword_74FB8);
    sub_49894(v6, "Rejected", v18);
    v19 = sub_49250(dword_76060);
    sub_49894(v6, "Hardware Errors", v19);
    LODWORD(v20) = sub_4ABAC(dbl_74F28 + dbl_74FB0 + dbl_72EF8);
    *(_QWORD *)&dword_72DC8 = v20;
    LODWORD(v21) = sub_4AB14(qword_72EF0);
    v22 = v21;
    if ( dbl_681C0 != 0.0 )
      v22 = v21 / dbl_681C0;
    LODWORD(v23) = sub_4ABAC(v22 * 60.0 * 100.0);
    LODWORD(v24) = sub_4AB14(v23);
    LODWORD(v25) = sub_4ABAC(v24 / 100.0 * 100.0);
    sub_4AB14(v25);
    v26 = sub_492D4();
    sub_49894(v6, "Utility", v26);
    v27 = sub_49250(qword_75008);
    sub_49894(v6, "Discarded", v27);
    v28 = sub_49250(*(__int64 *)&dword_762C8);
    sub_49894(v6, "Stale", v28);
    v29 = sub_49250((unsigned int)dword_72F08);
    sub_49894(v6, "Get Failures", v29);
    v30 = sub_49250((unsigned int)dword_72F14);
    sub_49894(v6, "Local Work", v30);
    v31 = sub_49250((unsigned int)dword_72DAC);
    sub_49894(v6, "Remote Failures", v31);
    v32 = sub_49250((unsigned int)dword_761D8);
    sub_49894(v6, "Network Blocks", v32);
    LODWORD(v33) = sub_4ABAC(dbl_72D88 * 100.0);
    sub_4AB14(v33);
    v34 = sub_492D4();
    sub_49894(v6, "Total MH", v34);
    LODWORD(v35) = sub_4AB14(*(__int64 *)&dword_72DC8);
    v36 = v35;
    if ( dbl_681C0 != 0.0 )
      v36 = v35 / dbl_681C0;
    LODWORD(v37) = sub_4ABAC(v36 * 60.0 * 100.0);
    sub_4AB14(v37);
    v38 = sub_492D4();
    sub_49894(v6, "Work Utility", v38);
    LODWORD(v39) = sub_4ABAC(dbl_74F28 * 100.0);
    sub_4AB14(v39);
    v40 = sub_492D4();
    sub_49894(v6, "Difficulty Accepted", v40);
    LODWORD(v41) = sub_4ABAC(dbl_74FB0 * 100.0);
    sub_4AB14(v41);
    v42 = sub_492D4();
    sub_49894(v6, "Difficulty Rejected", v42);
    LODWORD(v43) = sub_4ABAC(dbl_72EF8 * 100.0);
    sub_4AB14(v43);
    v44 = sub_492D4();
    sub_49894(v6, "Difficulty Stale", v44);
    v45 = sub_49250(*(__int64 *)&dword_68B00);
    sub_49894(v6, "Best Share", v45);
    v46 = *(_QWORD *)&dword_72DC8 + dword_76060;
    if ( v46 )
    {
      v59 = (double)dword_76060;
      LODWORD(v60) = sub_4AB14(v46);
      LODWORD(v61) = sub_4ABAC(v59 / v60 * 100.0);
      sub_4AB14(v61);
    }
    v47 = sub_492D4();
    sub_49894(v6, "Device Hardware%", v47);
    if ( *(_QWORD *)&dword_72DC8 )
    {
      LODWORD(v48) = sub_4AB14(*(__int64 *)&dword_72DC8);
      LODWORD(v49) = sub_4ABAC(dbl_74FB0 / v48 * 100.0);
      sub_4AB14(v49);
    }
    v50 = sub_492D4();
    sub_49894(v6, "Device Rejected%", v50);
    v51 = dbl_74FB0 + dbl_74F28 + dbl_72EF8;
    if ( v51 != 0.0 )
    {
      LODWORD(v52) = sub_4ABAC(dbl_74FB0 / v51 * 100.0);
      sub_4AB14(v52);
    }
    v53 = sub_492D4();
    sub_49894(v6, "Pool Rejected%", v53);
    v54 = dbl_74F28 + dbl_74FB0 + dbl_72EF8;
    if ( v54 != 0.0 )
    {
      LODWORD(v55) = sub_4ABAC(dbl_72EF8 / v54 * 100.0);
      sub_4AB14(v55);
    }
    v56 = sub_492D4();
    sub_49894(v6, "Pool Stale%", v56);
    v57 = sub_49250(dword_76080);
    sub_49894(v6, "Last getwork", v57);
    sub_49D54(v64, v6);
    sub_49894(a1, "SUMMARY", v64);
    v58 = sub_49250(1);
    sub_49894(a1, "id", v58);
    if ( pthread_mutex_unlock(&stru_76300) )
    {
      v62 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v62,
        "api_new.c",
        "get_summary_old",
        821);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    off_67964();
    return 0;
  }
}
// 1B05C: variable 'v7' is possibly undefined
// 1B0CC: variable 'v9' is possibly undefined
// 1B114: variable 'v11' is possibly undefined
// 1B15C: variable 'v13' is possibly undefined
// 1B254: variable 'v20' is possibly undefined
// 1B264: variable 'v21' is possibly undefined
// 1B288: variable 'v23' is possibly undefined
// 1B290: variable 'v24' is possibly undefined
// 1B2A0: variable 'v25' is possibly undefined
// 1B3C4: variable 'v33' is possibly undefined
// 1B3F4: variable 'v35' is possibly undefined
// 1B41C: variable 'v37' is possibly undefined
// 1B450: variable 'v39' is possibly undefined
// 1B4A0: variable 'v41' is possibly undefined
// 1B4D4: variable 'v43' is possibly undefined
// 1B70C: variable 'v60' is possibly undefined
// 1B71C: variable 'v61' is possibly undefined
// 1B56C: variable 'v48' is possibly undefined
// 1B57C: variable 'v49' is possibly undefined
// 1B5D4: variable 'v52' is possibly undefined
// 1B62C: variable 'v55' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681C0: using guessed type double dbl_681C0;
// 686E0: using guessed type char byte_686E0;
// 68B00: using guessed type int dword_68B00;
// 72D88: using guessed type double dbl_72D88;
// 72D90: using guessed type char byte_72D90;
// 72DAC: using guessed type int dword_72DAC;
// 72DC8: using guessed type int dword_72DC8;
// 72EF0: using guessed type __int64 qword_72EF0;
// 72EF8: using guessed type double dbl_72EF8;
// 72F08: using guessed type int dword_72F08;
// 72F14: using guessed type int dword_72F14;
// 74F28: using guessed type double dbl_74F28;
// 74F88: using guessed type int dword_74F88;
// 74FB0: using guessed type double dbl_74FB0;
// 74FB8: using guessed type __int64 qword_74FB8;
// 75008: using guessed type __int64 qword_75008;
// 76060: using guessed type int dword_76060;
// 76074: using guessed type int dword_76074;
// 76080: using guessed type int dword_76080;
// 761D8: using guessed type int dword_761D8;
// 762C8: using guessed type int dword_762C8;
// 76300: using guessed type pthread_mutex_t stru_76300;

//----- (0001B804) --------------------------------------------------------
int sub_1B804()
{
  _DWORD *v0; // r5
  int *v1; // r10
  const char *v2; // r11
  _DWORD *v3; // r4
  struct addrinfo *v4; // r4
  struct addrinfo *i; // r3
  int v6; // r0
  int v7; // r5
  time_t v8; // r7
  int *v9; // r0
  char *v10; // r9
  int v11; // r6
  int v12; // r0
  ssize_t v13; // r3
  _DWORD *v14; // r0
  _DWORD *v15; // r5
  unsigned int *v16; // r0
  unsigned int *v17; // r6
  unsigned int v18; // r7
  unsigned int *v19; // r3
  unsigned int v20; // r2
  unsigned int v21; // r2
  _DWORD *v22; // r0
  char *v23; // r0
  char *v24; // r5
  unsigned int *v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r2
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r8
  int v31; // r0
  int v32; // r6
  size_t v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int *v37; // r4
  char **v38; // r6
  unsigned int v39; // r5
  int v40; // r1
  int v41; // r2
  int v42; // r3
  int v43; // lr
  const char *v44; // r7
  char *v45; // t1
  _DWORD *v46; // r0
  unsigned int *v47; // r3
  unsigned int v48; // r2
  unsigned int v49; // r2
  _DWORD *v50; // r0
  unsigned int *v51; // r3
  unsigned int v52; // r2
  unsigned int v53; // r2
  _DWORD *v54; // r0
  unsigned int v55; // r4
  _DWORD *v56; // r8
  _DWORD *v57; // r0
  bool v58; // zf
  _BOOL4 v59; // r2
  const char *v60; // r0
  char *v61; // r0
  char *v62; // r4
  unsigned int *v63; // r3
  unsigned int v64; // r2
  unsigned int v65; // r2
  unsigned int *v66; // r3
  unsigned int v67; // r2
  unsigned int v68; // r2
  int *v69; // r0
  char *v70; // r0
  _DWORD *v72; // r8
  _DWORD *v73; // r9
  unsigned int v74; // r6
  _DWORD *v75; // r0
  _DWORD *v76; // r7
  int v77; // r0
  int v78; // r5
  size_t v79; // r0
  int v80; // r0
  int v81; // r0
  int v82; // r0
  int *v83; // r8
  const char *v84; // r0
  _DWORD *v85; // r0
  int v86; // r3
  unsigned int v87; // r2
  unsigned int *v88; // r3
  unsigned int v89; // r1
  unsigned int v90; // r1
  int *v91; // r0
  char *v92; // r0
  unsigned int v93; // [sp+14h] [bp-AD50h]
  unsigned int protocol; // [sp+18h] [bp-AD4Ch]
  const char *v95; // [sp+1Ch] [bp-AD48h]
  int v96; // [sp+20h] [bp-AD44h]
  const char *v97; // [sp+24h] [bp-AD40h]
  _DWORD *v98; // [sp+2Ch] [bp-AD38h]
  _DWORD *v99; // [sp+30h] [bp-AD34h]
  _DWORD *v100; // [sp+40h] [bp-AD24h]
  int v101; // [sp+48h] [bp-AD1Ch] BYREF
  int fd; // [sp+4Ch] [bp-AD18h] BYREF
  socklen_t addr_len; // [sp+50h] [bp-AD14h] BYREF
  int v104; // [sp+54h] [bp-AD10h] BYREF
  int v105; // [sp+58h] [bp-AD0Ch] BYREF
  int v106; // [sp+5Ch] [bp-AD08h] BYREF
  struct addrinfo *pai; // [sp+60h] [bp-AD04h] BYREF
  int optval; // [sp+64h] [bp-AD00h] BYREF
  _DWORD v109[2]; // [sp+68h] [bp-ACFCh] BYREF
  char service[12]; // [sp+70h] [bp-ACF4h] BYREF
  char v111[4]; // [sp+7Ch] [bp-ACE8h] BYREF
  int v112; // [sp+80h] [bp-ACE4h]
  int v113; // [sp+84h] [bp-ACE0h]
  int v114; // [sp+88h] [bp-ACDCh]
  char s1[4]; // [sp+8Ch] [bp-ACD8h] BYREF
  _BOOL4 v116; // [sp+90h] [bp-ACD4h]
  _BOOL4 v117; // [sp+94h] [bp-ACD0h]
  _BOOL4 v118; // [sp+98h] [bp-ACCCh]
  _DWORD v119[5]; // [sp+9Ch] [bp-ACC8h] BYREF
  struct addrinfo v120; // [sp+B0h] [bp-ACB4h] BYREF
  struct sockaddr addr; // [sp+D0h] [bp-AC94h] BYREF
  char v122[16]; // [sp+150h] [bp-AC14h] BYREF
  char v123[252]; // [sp+24Ch] [bp-AB18h] BYREF
  char src[256]; // [sp+348h] [bp-AA1Ch] BYREF
  struct __jmp_buf_tag v125; // [sp+448h] [bp-A91Ch] BYREF
  char s[2048]; // [sp+560h] [bp-A804h] BYREF
  char v127[2016]; // [sp+D60h] [bp-A004h] BYREF
  char v128[2016]; // [sp+1560h] [bp-9804h] BYREF
  char v129[2016]; // [sp+1D60h] [bp-9004h] BYREF
  char v130[2016]; // [sp+2560h] [bp-8804h] BYREF
  char v131[2016]; // [sp+2D60h] [bp-8004h] BYREF
  char v132[2016]; // [sp+3560h] [bp-7804h] BYREF
  char v133[1952]; // [sp+3D60h] [bp-7004h] BYREF
  char v134[1952]; // [sp+4560h] [bp-6804h] BYREF
  char v135[1952]; // [sp+4D60h] [bp-6004h] BYREF
  char v136[1952]; // [sp+5560h] [bp-5804h] BYREF
  char v137[1952]; // [sp+5D60h] [bp-5004h] BYREF
  char v138[1952]; // [sp+6560h] [bp-4804h] BYREF
  char v139[1952]; // [sp+6D60h] [bp-4004h] BYREF
  char v140[2048]; // [sp+7560h] [bp-3804h] BYREF
  char v141[4096]; // [sp+7D60h] [bp-3004h] BYREF
  char v142[8196]; // [sp+8D60h] [bp-2004h] BYREF

  v101 = -1;
  fd = -1;
  v93 = 2;
  memset(v142, 0, 0x2000u);
  memset(v141, 0, sizeof(v141));
  v112 = 0;
  *(_DWORD *)v111 = 0;
  v113 = 0;
  v114 = 0;
  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    snprintf(s, 0x800u, "Start %s function\n", "api");
    sub_1DD60(5, s, 0);
  }
  v3 = (_DWORD *)_sigsetjmp(&v125, 0);
  if ( v3 )
  {
    sub_18328(&v101);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&v125);
    goto LABEL_194;
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&v125);
  sprintf(service, "%d", 4028);
  memset(&v120.ai_family, 0, 28);
  v120.ai_flags = 1;
  protocol = getaddrinfo("0.0.0.0", service, &v120, &pai);
  if ( protocol )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      goto LABEL_70;
    snprintf(v135, 0x800u, "%s: exec getaddrinfo() failed\n", "api_init_socket");
    sub_1DD60(3, v135, 0);
    goto LABEL_79;
  }
  v4 = pai;
  if ( pai )
  {
    for ( i = pai; ; i = pai )
    {
      v6 = socket(i->ai_family, 1, protocol);
      if ( v6 > 0 )
      {
        v7 = v6;
        goto LABEL_12;
      }
      v4 = v4->ai_next;
      if ( !v4 )
        break;
    }
    v7 = v6;
    if ( v6 == -1 )
    {
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
        goto LABEL_70;
      snprintf(v136, 0x800u, "%s: exec socket() failed\n", "api_init_socket");
      sub_1DD60(3, v136, 0);
      goto LABEL_79;
    }
  }
  else
  {
    v7 = 0;
  }
LABEL_12:
  optval = 1;
  setsockopt(v7, 1, 2, &optval, 4u);
  v8 = time(0);
  while ( bind(v7, v4->ai_addr, v4->ai_addrlen) < 0 )
  {
    v9 = _errno_location();
    v10 = strerror(*v9);
    if ( time(0) - v8 > 61 )
    {
      freeaddrinfo(pai);
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(v138, 0x800u, "api bind to port %d, failed (%s)", 4028, v10);
        sub_1DD60(3, v138, 0);
        goto LABEL_79;
      }
LABEL_70:
      if ( dword_67840 <= 2 )
      {
LABEL_73:
        if ( dword_67840 > 2 )
          goto LABEL_74;
      }
      else
      {
LABEL_71:
        snprintf(v127, 0x800u, "%s: init socket failed", "api");
        sub_1DD60(3, v127, 0);
        if ( !byte_72D90 && !byte_686E0 )
          goto LABEL_73;
LABEL_74:
        strcpy(v128, "cgminer restart");
        sub_1DD60(3, v128, 0);
      }
      _assert_fail((const char *)&word_55C44, "api_new.c", 0x741u, "api");
    }
    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
    {
      snprintf(v137, 0x800u, "%s: api bind to port %d failed, trying again in 30sec", "api_init_socket", 4028);
      sub_1DD60(4, v137, 0);
    }
    sleep(0x1Eu);
  }
  freeaddrinfo(pai);
  if ( listen(v7, 100) < 0 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      v91 = _errno_location();
      v92 = strerror(*v91);
      snprintf(v139, 0x800u, "%s: exec listen() failed (%s)", "api_init_socket", v92);
      sub_1DD60(3, v139, 0);
    }
    close(v7);
LABEL_79:
    if ( !byte_72D90 && !byte_686E0 )
      goto LABEL_70;
    goto LABEL_71;
  }
  if ( v7 == -2147483642 )
    goto LABEL_79;
  v1 = &dword_685A0;
  v95 = "get_version_old";
  v101 = v7;
  v2 = "api";
  v97 = "=";
  while ( 1 )
  {
    v11 = *((unsigned __int8 *)v1 + 20);
    if ( *((_BYTE *)v1 + 20) )
      break;
    addr_len = 128;
    v12 = accept(v101, &addr, &addr_len);
    fd = v12;
    if ( v12 < 0 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        v69 = _errno_location();
        v70 = strerror(*v69);
        snprintf(v129, 0x800u, "%s: exec accept failed (%s)", "api", v70);
        sub_1DD60(3, v129, 0);
      }
      break;
    }
    v106 = 2;
    v104 = 1;
    v105 = 5;
    setsockopt(v12, 1, 9, &v104, 4u);
    setsockopt(fd, 6, 1, &v104, 4u);
    setsockopt(fd, 6, 6, &v104, 4u);
    setsockopt(fd, 6, 4, &v105, 4u);
    setsockopt(fd, 6, 5, &v106, 4u);
    v109[1] = v11;
    v109[0] = 10;
    if ( setsockopt(fd, 1, 21, v109, 8u) )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(v130, 0x800u, "%s:setsocket SO_SNDTIMEO failed\n", v2);
        sub_1DD60(3, v130, 0);
      }
      close(fd);
    }
    if ( setsockopt(fd, 1, 20, v109, 8u) )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(v131, 0x800u, "%s:setsocket SO_RCVTIMEO failed\n", v2);
        sub_1DD60(3, v131, 0);
      }
      close(fd);
    }
    v13 = recv(fd, v142, 0xFFFu, 0);
    if ( v13 <= 0 )
    {
      v142[0] = 0;
      goto LABEL_24;
    }
    v1[1] = 0;
    v1[2] = 0;
    v1[3] = 0;
    v1[4] = 0;
    v142[v13] = 0;
    *(_DWORD *)v111 = 0;
    v112 = 0;
    v113 = 0;
    v114 = 0;
    *v1 = time(0);
    getnameinfo(&addr, 0x80u, (char *)v1 + 4, 0x10u, 0, 0, 1u);
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(v132, 0x800u, "connect_addr: %s", (const char *)v1 + 4);
      sub_1DD60(7, v132, 0);
    }
    v116 = 0;
    *(_DWORD *)s1 = 0;
    v117 = 0;
    v118 = 0;
    v14 = sub_47C50((int)v142, 0, v122);
    v15 = v14;
    if ( v14 && !*v14 )
    {
      v16 = (unsigned int *)sub_48AF4(v14, "command");
      v17 = v16;
      if ( v16 )
      {
        v18 = *v16;
        if ( *v16 == 1 )
        {
          v54 = (_DWORD *)sub_48AF4(v15, "new_api");
          if ( v54 )
            v18 = *v54 != 5;
          v55 = protocol;
          v96 = protocol;
          v56 = sub_48A70();
          while ( (unsigned int)sub_48E60(v17) > v55 )
          {
            v57 = sub_48E7C(v17, v55);
            v58 = v57 == 0;
            if ( v57 )
              v58 = v55 == 11;
            v59 = v58;
            if ( v58 )
              break;
            if ( *v57 == 2 )
            {
              *(_DWORD *)s1 = v59;
              v116 = v59;
              v117 = v59;
              v118 = v59;
              v60 = (const char *)sub_49028(v57);
              snprintf(s1, 0x10u, "%s", v60);
              if ( strcmp(s1, "reload") | v18 )
              {
                v99 = sub_48A70();
                sub_1836C(v99, s1, v18);
                sub_49894(v56, s1, v99);
              }
              else
              {
                v96 = 1;
              }
            }
            ++v55;
          }
          v61 = sub_45A6C(v56, 24576);
          v62 = v61;
          if ( v61 )
            sub_189CC(&fd, v61);
          free(v62);
          if ( v96 == 1 )
            sub_1836C(v56, "reload", 0);
          if ( v56 )
          {
            if ( v56[1] != -1 )
            {
              v63 = v56 + 1;
              __dmb(0xBu);
              do
              {
                v64 = __ldrex(v63);
                v65 = v64 - 1;
              }
              while ( __strex(v65, v63) );
              if ( !v65 )
                sub_4942C(v56);
            }
          }
          if ( v15[1] != -1 )
          {
            v66 = v15 + 1;
            __dmb(0xBu);
            do
            {
              v67 = __ldrex(v66);
              v68 = v67 - 1;
            }
            while ( __strex(v68, v66) );
            if ( !v68 )
              sub_4942C(v15);
          }
          goto LABEL_24;
        }
      }
      if ( v15[1] != -1 )
      {
        v19 = v15 + 1;
        __dmb(0xBu);
        do
        {
          v20 = __ldrex(v19);
          v21 = v20 - 1;
        }
        while ( __strex(v21, v19) );
        if ( !v21 )
          sub_4942C(v15);
      }
    }
    v3 = sub_48A70();
    v22 = sub_47C50((int)v142, 0, v123);
    v0 = v22;
    if ( !v22 || *v22 )
    {
      v93 = 2;
      snprintf(v111, 0x10u, "%s", v142);
      sub_1836C(v3, v111, 2u);
      goto LABEL_57;
    }
    v50 = (_DWORD *)sub_48AF4(v22, "command");
    if ( !v50 || *v50 != 2 )
    {
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      {
        if ( v0[1] != -1 )
          goto LABEL_113;
        goto LABEL_152;
      }
      snprintf(v140, 0x800u, "%s error: format error about command\n", v95 + 228);
      sub_1DD60(3, v140, 0);
      if ( v0[1] != -1 )
      {
LABEL_113:
        v51 = v0 + 1;
        __dmb(0xBu);
        do
        {
          v52 = __ldrex(v51);
          v53 = v52 - 1;
        }
        while ( __strex(v53, v51) );
        if ( !v53 )
          sub_4942C(v0);
      }
      if ( byte_72D90 || byte_686E0 )
      {
LABEL_119:
        snprintf(v133, 0x800u, "%s: input invaild param format", v2);
        sub_1DD60(3, v133, 0);
      }
      else
      {
LABEL_152:
        if ( dword_67840 > 2 )
          goto LABEL_119;
      }
      sub_16A28(v3, 0, 24, "Missing JSON 'command'");
      goto LABEL_57;
    }
    v84 = (const char *)sub_49028(v50);
    snprintf(v111, 0x10u, "%s", v84);
    v85 = (_DWORD *)sub_48AF4(v0, "new_api");
    if ( !v85 )
    {
LABEL_194:
      v86 = v0[1];
LABEL_185:
      if ( v86 == -1 )
      {
        v93 = 1;
        sub_1836C(v3, v111, 1u);
        goto LABEL_57;
      }
      v87 = 1;
      goto LABEL_188;
    }
    v86 = v0[1];
    if ( *v85 != 5 )
      goto LABEL_185;
    if ( v86 == -1 )
    {
      v93 = protocol;
      sub_1836C(v3, v111, protocol);
      goto LABEL_57;
    }
    v87 = protocol;
LABEL_188:
    v88 = v0 + 1;
    __dmb(0xBu);
    do
    {
      v89 = __ldrex(v88);
      v90 = v89 - 1;
    }
    while ( __strex(v90, v88) );
    v93 = v87;
    if ( v90 )
    {
      sub_1836C(v3, v111, v87);
    }
    else
    {
      sub_4942C(v0);
      sub_1836C(v3, v111, v93);
    }
LABEL_57:
    if ( v93 == 2 )
    {
      memset(v141, 0, sizeof(v141));
      if ( v3 )
      {
        v28 = (_DWORD *)sub_48AF4(v3, "STATUS");
        if ( v28 )
        {
          if ( *v28 == 1 )
          {
            v29 = sub_48E7C(v28, 0);
            v30 = v29;
            if ( v29 )
            {
              if ( !*v29 )
              {
                v31 = sub_48D5C(v29);
                v32 = sub_48DDC(v31);
                if ( v32 )
                {
                  v98 = v3;
                  do
                  {
                    v36 = sub_48DF4(v32);
                    v37 = (int *)sub_48DE8(v36);
                    if ( !v37 )
                      break;
                    v33 = strlen(v141);
                    *(_WORD *)stpcpy(&v141[v33], v32) = *(_WORD *)v97;
                    sub_18518(v141, v37);
                    *(_WORD *)&v141[strlen(v141)] = 44;
                    v34 = sub_48DF4(v32);
                    v35 = sub_48DA8(v30, v34);
                    v32 = sub_48DDC(v35);
                  }
                  while ( v32 );
                  v3 = v98;
                }
                v38 = (char **)v119;
                v140[strlen(v141) + 2047] = 124;
                memset(src, 0, sizeof(src));
                v39 = protocol;
                v40 = *((_DWORD *)v95 + 62);
                v41 = *((_DWORD *)v95 + 63);
                v42 = *((_DWORD *)v95 + 64);
                v43 = *((_DWORD *)v95 + 65);
                v119[0] = *((_DWORD *)v95 + 61);
                v119[1] = v40;
                v119[2] = v41;
                v119[3] = v42;
                v119[4] = v43;
                while ( 1 )
                {
                  v45 = *v38++;
                  v44 = v45;
                  v46 = (_DWORD *)sub_48AF4(v3, v45);
                  if ( v46 )
                  {
                    if ( *v46 == 1 )
                      break;
                  }
                  if ( ++v39 == 5 )
                    goto LABEL_101;
                }
                v72 = v46;
                if ( (v39 & 0xFFFFFFFB) == 0 )
                {
                  snprintf(src, 0x100u, "%s,", v44);
                  strcat(v141, src);
                }
                v73 = sub_48E60(v72);
                if ( (int)v73 > 0 )
                {
                  v74 = protocol;
                  do
                  {
                    v75 = sub_48E7C(v72, v74);
                    v76 = v75;
                    if ( v75 && !*v75 )
                    {
                      v77 = sub_48D5C(v75);
                      v78 = sub_48DDC(v77);
                      if ( v78 )
                      {
                        v100 = v72;
                        do
                        {
                          v82 = sub_48DF4(v78);
                          v83 = (int *)sub_48DE8(v82);
                          if ( !v83 )
                            break;
                          v79 = strlen(v141);
                          *(_WORD *)stpcpy(&v141[v79], v78) = *(_WORD *)v97;
                          sub_18518(v141, v83);
                          *(_WORD *)&v141[strlen(v141)] = 44;
                          v80 = sub_48DF4(v78);
                          v81 = sub_48DA8(v76, v80);
                          v78 = sub_48DDC(v81);
                        }
                        while ( v78 );
                        v72 = v100;
                      }
                      v140[strlen(v141) + 2047] = 124;
                      if ( (_DWORD *)((char *)v73 - 1) != (_DWORD *)v74 )
                        v141[strlen(v141)] = 44;
                    }
                    ++v74;
                  }
                  while ( v73 != (_DWORD *)v74 );
                }
              }
            }
          }
        }
      }
LABEL_101:
      sub_189CC(&fd, v141);
      if ( v3 )
      {
        if ( v3[1] != -1 )
        {
          v47 = v3 + 1;
          __dmb(0xBu);
          do
          {
            v48 = __ldrex(v47);
            v49 = v48 - 1;
          }
          while ( __strex(v49, v47) );
          if ( !v49 )
            sub_4942C(v3);
        }
      }
    }
    else
    {
      v23 = sub_45A6C(v3, 24576);
      v24 = v23;
      if ( v23 )
        sub_189CC(&fd, v23);
      if ( v3 && v3[1] != -1 )
      {
        v25 = v3 + 1;
        __dmb(0xBu);
        do
        {
          v26 = __ldrex(v25);
          v27 = v26 - 1;
        }
        while ( __strex(v27, v25) );
        if ( !v27 )
          sub_4942C(v3);
      }
      free(v24);
    }
LABEL_24:
    close(fd);
  }
  _pthread_unregister_cancel((__pthread_unwind_buf_t *)&v125);
  sub_18328(&v101);
  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    snprintf(v134, 0x800u, "End %s function !!!", "api");
    sub_1DD60(5, v134, 0);
  }
  return close(v101);
}
// 1BAF0: variable 'v1' is possibly undefined
// 1BC34: variable 'v2' is possibly undefined
// 1C1F0: variable 'v97' is possibly undefined
// 1C288: variable 'protocol' is possibly undefined
// 1C294: variable 'v95' is possibly undefined
// 1C9C8: variable 'v0' is possibly undefined
// 1262C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 51D00: using guessed type __int16 word_51D00;
// 55C44: using guessed type __int16 word_55C44;
// 67840: using guessed type int dword_67840;
// 685A0: using guessed type int dword_685A0;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (0001CB1C) --------------------------------------------------------
void *__fastcall sub_1CB1C(const char **a1, const char *a2, const char *a3, int a4)
{
  void *result; // r0
  int v6; // r3
  const char *v7; // r2
  signed int v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  char *v12; // r5
  const char *v13; // r3
  const char *v14; // r1
  __int64 v15; // r2
  int v16; // r0
  int v17; // r3
  int v18; // r2
  const char *v19; // r3
  char *v20; // r0
  int v21; // r1
  const char *v22; // r0
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = (void *)*((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (signed int)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (signed int)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x800u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v12 = (char *)calloc(v8, 0x10u);
  if ( !v12 )
  {
    snprintf(
      s,
      0x800u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  *(_DWORD *)&a1[13][4 * (_DWORD)(a1[12] + 0x3FFFFFFF)] = v12;
  v13 = a1[6];
  v14 = *a1;
  a1[7] = (const char *)v8;
  a1[8] = (const char *)v8;
  a1[6] = &v13[v8];
  *(_DWORD *)v12 = v14;
  *((_DWORD *)v12 + 1) = 0;
  *((_DWORD *)v12 + 2) = v12 + 16;
  if ( v8 > 2 )
  {
    HIDWORD(v15) = v12 + 32;
    do
    {
      LODWORD(v15) = HIDWORD(v15) - 32;
      *(_DWORD *)(HIDWORD(v15) - 16) = v14;
      *(_QWORD *)(HIDWORD(v15) - 12) = v15;
      HIDWORD(v15) += 16;
    }
    while ( (char *)HIDWORD(v15) != &v12[16 * v8] );
  }
  v16 = *((unsigned __int8 *)a1 + 44);
  v17 = 16 * (v8 + 0xFFFFFFF);
  *(_DWORD *)&v12[v17] = v14;
  a1[3] = v12;
  v18 = v17 - 16;
  v19 = &v12[v17];
  *((_DWORD *)v19 + 1) = &v12[v18];
  *((_DWORD *)v19 + 2) = 0;
  if ( v16 )
    a1[4] = v19;
  do
  {
    v20 = (char *)a1[15];
    v21 = (int)(a1[14] + 1);
    a1[14] = (const char *)v21;
    v22 = (const char *)realloc(v20, 4 * v21);
    a1[15] = v22;
    if ( !v22 )
    {
      snprintf(
        s,
        0x800u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    result = calloc(1u, (size_t)a1[5]);
    *((_DWORD *)v12 + 3) = result;
    if ( !result )
    {
      snprintf(s, 0x800u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    *(_DWORD *)&a1[15][4 * (_DWORD)(a1[14] + 0x3FFFFFFF)] = result;
    v12 = (char *)*((_DWORD *)v12 + 2);
  }
  while ( v12 );
  return result;
}

//----- (0001CE58) --------------------------------------------------------
_DWORD *__fastcall sub_1CE58(int a1)
{
  _DWORD *result; // r0
  const char *v3; // r3
  int v4; // r12
  char v5; // r1
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = calloc(1u, 0x40u);
  v3 = *(const char **)a1;
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc store for %s in %s %s():%d", v3, "klist.c", "k_new_store", 85);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_BYTE *)(a1 + 44);
  *result = v3;
  result[2] = v4;
  *((_BYTE *)result + 44) = v5;
  *((_BYTE *)result + 4) = 1;
  return result;
}

//----- (0001CF00) --------------------------------------------------------
_BYTE *__fastcall sub_1CF00(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8)
{
  _BYTE *v12; // r0
  _BYTE *v13; // r4
  pthread_mutex_t *v14; // r0
  pthread_mutex_t *v15; // r5
  int *v17; // r0
  int *v18; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a3 <= 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      a1,
      a3,
      "klist.c",
      "_k_new_list",
      100);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( a4 < 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      a1,
      a4,
      "klist.c",
      "_k_new_list",
      103);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v12 = calloc(1u, 0x40u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(s, 0x800u, "Failed to calloc list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 107);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v12[4] = 0;
  v14 = (pthread_mutex_t *)calloc(1u, 0x38u);
  v15 = v14;
  *((_DWORD *)v13 + 2) = v14;
  if ( !v14 )
  {
    snprintf(s, 0x800u, "Failed to calloc lock for list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 113);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( pthread_mutex_init(v14, 0) )
  {
    v18 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v18, "klist.c", "_k_new_list", 115);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v15[1], 0) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v17, "klist.c", "_k_new_list", 115);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  *(_DWORD *)v13 = a1;
  *((_DWORD *)v13 + 5) = a2;
  *((_DWORD *)v13 + 9) = a3;
  *((_DWORD *)v13 + 10) = a4;
  v13[44] = a5;
  sub_1CB1C((const char **)v13, a6, a7, a8);
  return v13;
}

//----- (0001D1B0) --------------------------------------------------------
int __fastcall sub_1D1B0(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r12
  int v6; // r3

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return 0;
    sub_1CB1C((const char **)a1, a2, a3, a4);
    v5 = *(_DWORD *)(a1 + 12);
    if ( !v5 )
      return 0;
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return v5;
}

//----- (0001D238) --------------------------------------------------------
int __fastcall sub_1D238(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = sub_1D1B0(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (0001D264) --------------------------------------------------------
int __fastcall sub_1D264(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      a3 = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = a3;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    --*(_DWORD *)(a1 + 28);
  }
  return result;
}

//----- (0001D32C) --------------------------------------------------------
const char *__fastcall sub_1D32C(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  int v7; // r3
  int v8; // r3
  __int64 v9; // r2
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_add_head",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a1 + 12);
  if ( v7 )
    *(_DWORD *)(v7 + 4) = a2;
  v8 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v8 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v9 = *(_QWORD *)(a1 + 28);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(a1 + 28) = v9;
  return result;
}

//----- (0001D400) --------------------------------------------------------
const char **__fastcall sub_1D400(const char **result, int a2, const char *a3, const char *a4, int a5)
{
  const char *v6; // r1
  const char *v7; // r3
  const char *v8; // r3
  const char *v9; // r3
  bool v10; // zf
  __int64 v11; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v6 = *(const char **)a2;
  if ( v6 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      v6,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( !*((_BYTE *)result + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v7 = result[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v7;
  v8 = result[4];
  if ( v8 )
    *((_DWORD *)v8 + 2) = a2;
  v9 = result[3];
  result[4] = (const char *)a2;
  v10 = v9 == 0;
  v11 = *(_QWORD *)(result + 7);
  if ( v10 )
    result[3] = (const char *)a2;
  LODWORD(v11) = v11 + 1;
  ++HIDWORD(v11);
  *(_QWORD *)(result + 7) = v11;
  return result;
}

//----- (0001D54C) --------------------------------------------------------
const char **__fastcall sub_1D54C(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  __int64 v9; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_before",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  v8 = *(_DWORD *)(a3 + 4);
  if ( v8 )
    *(_DWORD *)(v8 + 8) = a2;
  else
    result[3] = (const char *)a2;
  *(_DWORD *)(a3 + 4) = a2;
  v9 = *(_QWORD *)(result + 7);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(result + 7) = v9;
  return result;
}

//----- (0001D694) --------------------------------------------------------
const char **__fastcall sub_1D694(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  __int64 v9; // r2
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_after",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  v8 = *(_DWORD *)(a3 + 8);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a2;
  }
  else if ( *((_BYTE *)result + 44) )
  {
    result[4] = (const char *)a2;
  }
  *(_DWORD *)(a3 + 8) = a2;
  v9 = *(_QWORD *)(result + 7);
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)(result + 7) = v9;
  return result;
}

//----- (0001D7E8) --------------------------------------------------------
const char *__fastcall sub_1D7E8(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  __int64 v7; // r2
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *(const char **)a2;
  if ( *(_DWORD *)a2 != *(_DWORD *)a1 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_item",
      result,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v7 = *(_QWORD *)(a2 + 4);
  if ( (_DWORD)v7 )
  {
    *(_DWORD *)(v7 + 8) = HIDWORD(v7);
    HIDWORD(v7) = *(_DWORD *)(a2 + 8);
  }
  if ( HIDWORD(v7) )
    *(_DWORD *)(HIDWORD(v7) + 4) = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 12) == a2 )
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 16) == a2 )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}

//----- (0001D8D4) --------------------------------------------------------
const char *__fastcall sub_1D8D4(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r2
  const char *v10; // r3
  const char *v11; // r1
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( result != v8 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_head",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( a1[3] )
  {
    v9 = *(_DWORD *)(a2 + 12);
    v10 = a1[4];
    if ( v9 )
      *(_DWORD *)(v9 + 4) = v10;
    else
      *(_DWORD *)(a2 + 16) = v10;
    if ( v9 )
      v9 = *(_DWORD *)(a2 + 12);
    *((_DWORD *)a1[4] + 2) = v9;
    *(_DWORD *)(a2 + 12) = a1[3];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v11;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (0001DA44) --------------------------------------------------------
const char *__fastcall sub_1DA44(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  const char *v9; // r3
  int v10; // r2
  const char *v11; // r1
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( result != v8 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      result,
      "_k_list_transfer_to_tail",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v9 = a1[3];
  if ( v9 )
  {
    v10 = *(_DWORD *)(a2 + 16);
    if ( v10 )
      *(_DWORD *)(v10 + 8) = v9;
    else
      *(_DWORD *)(a2 + 12) = v9;
    if ( v10 )
      v10 = *(_DWORD *)(a2 + 16);
    *((_DWORD *)a1[3] + 1) = v10;
    *(_DWORD *)(a2 + 16) = a1[4];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    *(_DWORD *)(a2 + 28) += v11;
    a1[7] = 0;
    *(_DWORD *)(a2 + 32) += a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (0001DBB0) --------------------------------------------------------
int __fastcall sub_1DBB0(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}

//----- (0001DCCC) --------------------------------------------------------
int __fastcall sub_1DCCC(const char **ptr, const char *a2, const char *a3, int a4)
{
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      0x800u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  free(ptr);
  return 0;
}

//----- (0001DD60) --------------------------------------------------------
void __fastcall sub_1DD60(int a1, const char *a2, int a3)
{
  int v6; // r4
  struct tm *v7; // r0
  int v8; // r0
  FILE *v9; // r5
  size_t v10; // r0
  size_t v11; // r0
  int v12; // r7
  time_t timer; // [sp+1Ch] [bp-4Ch] BYREF
  __time_t v14; // [sp+20h] [bp-48h] BYREF
  int v15; // [sp+24h] [bp-44h]
  char s[64]; // [sp+28h] [bp-40h] BYREF

  if ( byte_72D90 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v14 = 0;
    v15 = 0;
    sub_206A0(&v14);
    timer = v14;
    v6 = v15 / 1000;
    v7 = localtime(&timer);
    snprintf(
      s,
      0x40u,
      " [%d-%02d-%02d %02d:%02d:%02d.%03d] ",
      v7->tm_year + 1900,
      v7->tm_mon + 1,
      v7->tm_mday,
      v7->tm_hour,
      v7->tm_min,
      v7->tm_sec,
      v6);
    v8 = fileno((FILE *)stderr);
    if ( !isatty(v8) )
    {
      fprintf((FILE *)stderr, "%s%s\n", s, a2);
      fflush((FILE *)stderr);
    }
    if ( byte_685B8 )
    {
      v9 = (FILE *)dword_685BC;
      if ( dword_685BC || (v9 = (FILE *)fopen64(&dword_685E0, &word_685C0), (dword_685BC = (int)v9) != 0) )
      {
        v10 = strlen(s);
        fwrite(s, v10, 1u, v9);
        v11 = strlen(a2);
        fwrite(a2, v11, 1u, (FILE *)dword_685BC);
        fwrite(&word_4C1E4, 1u, 1u, (FILE *)dword_685BC);
        fflush((FILE *)dword_685BC);
      }
    }
    if ( a1 == 3 )
      v12 = 0;
    else
      v12 = byte_76234 & 1;
    if ( !v12 )
      sub_1E04C(s, a2, a3);
  }
}
// 12830: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 4C1E4: using guessed type __int16 word_4C1E4;
// 68598: using guessed type int stderr;
// 685B8: using guessed type char byte_685B8;
// 685BC: using guessed type int dword_685BC;
// 685C0: using guessed type __int16 word_685C0;
// 685E0: using guessed type int dword_685E0;
// 72D90: using guessed type char byte_72D90;
// 76234: using guessed type char byte_76234;

//----- (0001DF40) --------------------------------------------------------
int __fastcall sub_1DF40(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  result = pthread_mutex_unlock(&stru_74FE4);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}
// 1DD60: using guessed type int __fastcall sub_1DD60(_DWORD, _DWORD, _DWORD);
// 74FE4: using guessed type pthread_mutex_t stru_74FE4;

//----- (0001DFB8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1DFB8(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { POP             {R4,PC} }
}
// 1DFBC: positive sp value 810 has been found
// 1DFBC: unbalanced stack, ignored a potential tail call

//----- (0001DFC0) --------------------------------------------------------
int sub_1DFC0()
{
  int result; // r0
  int *v1; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_lock(&stru_74FE4);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 52);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}
// 1DD60: using guessed type int __fastcall sub_1DD60(_DWORD, _DWORD, _DWORD);
// 74FE4: using guessed type pthread_mutex_t stru_74FE4;

//----- (0001E040) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1E040(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 1E048: positive sp value 814 has been found
// 1E048: unbalanced stack, ignored a potential tail call

//----- (0001E04C) --------------------------------------------------------
int __fastcall sub_1E04C(const char *a1, const char *a2, int a3)
{
  if ( a3 )
  {
    pthread_mutex_trylock(&stru_74FE4);
    sub_1DF40(41);
    off_67964();
  }
  sub_1DFC0();
  printf("%s%s%s", a1, a2, asc_4C1D0);
  sub_1DF40(54);
  return off_67964();
}
// 67964: using guessed type int (*off_67964)();
// 74FE4: using guessed type pthread_mutex_t stru_74FE4;

//----- (0001E0C4) --------------------------------------------------------
void __fastcall sub_1E0C4(int a1, const char *a2, int a3)
{
  int v6; // r0
  int v7; // r0

  if ( byte_72D90 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", a2);
      fflush((FILE *)stderr);
    }
    if ( a1 == 3 )
      v7 = 0;
    else
      v7 = byte_76234 & 1;
    if ( !v7 )
      sub_1E04C("", a2, a3);
  }
}
// 68598: using guessed type int stderr;
// 72D90: using guessed type char byte_72D90;
// 76234: using guessed type char byte_76234;

//----- (0001E240) --------------------------------------------------------
__int64 __fastcall sub_1E240(int a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // r3
  __int64 result; // r0

  v3 = *(_DWORD *)(a1 + 24);
  if ( v3 )
  {
    *a2 = *(_QWORD *)(v3 + 16);
    result = *(_QWORD *)(v3 + 24);
    *a3 = result;
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
    return 0;
  }
  return result;
}

//----- (0001E678) --------------------------------------------------------
int __fastcall sub_1E678(int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r0
  int *v4; // lr
  char *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r1
  int v9; // t1
  unsigned int v10; // lr
  char *v11; // r3
  unsigned int v12; // t1
  int *v13; // r0
  int **v14; // r3
  int *v15; // r2
  int *v16; // t1
  int v17; // r6
  int v18; // r3
  int v19; // r4
  int v20; // r10
  int v21; // r9
  int v22; // r5
  int v23; // r8
  int v24; // r7
  int v25; // r11
  int v26; // r2
  int v27; // r12
  int v28; // r3
  int v29; // lr
  int v30; // r1
  int **v31; // r1
  int *v32; // r3
  int *v33; // t1
  bool v34; // zf
  unsigned __int8 *v35; // [sp+4h] [bp-164h]
  int *v36; // [sp+8h] [bp-160h]
  unsigned __int8 *v37; // [sp+14h] [bp-154h]
  int *v38; // [sp+18h] [bp-150h]
  int *v39; // [sp+1Ch] [bp-14Ch] BYREF
  int v40; // [sp+20h] [bp-148h]
  int v41; // [sp+24h] [bp-144h]
  int v42; // [sp+28h] [bp-140h]
  int v43; // [sp+2Ch] [bp-13Ch]
  int v44; // [sp+30h] [bp-138h]
  int v45; // [sp+34h] [bp-134h]
  int v46; // [sp+38h] [bp-130h]
  int v47; // [sp+3Ch] [bp-12Ch] BYREF
  _DWORD v48[15]; // [sp+40h] [bp-128h] BYREF
  char v49; // [sp+7Ch] [bp-ECh] BYREF
  char v50; // [sp+100h] [bp-68h] BYREF

  if ( a3 > 0 )
  {
    v38 = (int *)(result + 136);
    v35 = a2;
    v37 = &a2[64 * a3];
    v39 = (int *)(result + 168);
    do
    {
      v3 = v35;
      v4 = &v47;
      v5 = (char *)v48;
      do
      {
        v6 = v3[1];
        v7 = v3[2];
        v8 = v3[3];
        v9 = *v3;
        v3 += 4;
        v4[1] = (v6 << 16) | (v7 << 8) | v8 | (v9 << 24);
        ++v4;
      }
      while ( &v49 != (char *)v4 );
      do
      {
        v10 = *((_DWORD *)v5 + 14);
        v11 = v5;
        v12 = *((_DWORD *)v5 + 1);
        v5 += 4;
        *((_DWORD *)v5 + 15) = (__ROR4__(v10, 19) ^ __ROR4__(v10, 17) ^ (v10 >> 10))
                             + *((_DWORD *)v11 + 9)
                             + *(_DWORD *)v11
                             + (__ROR4__(v12, 18) ^ __ROR4__(v12, 7) ^ (v12 >> 3));
      }
      while ( &v50 != v5 );
      v13 = v39;
      v14 = &v39;
      v15 = v38;
      do
      {
        v16 = (int *)*v15++;
        v14[1] = v16;
        ++v14;
      }
      while ( v13 != v15 );
      v36 = v15;
      v17 = 0;
      v18 = v47;
      v19 = v44;
      v20 = v45;
      v21 = v46;
      v22 = v40;
      v23 = v41;
      v24 = v42;
      v25 = v43;
      while ( 1 )
      {
        v26 = (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v19, 25)) + (v21 & ~v19 ^ v20 & v19) + v48[v17];
        v27 = dword_67844[v17++];
        v28 = v26 + v27 + v18;
        v29 = v25 + v28;
        v30 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v24 ^ v23) & v22 ^ v24 & v23) + v28;
        v25 = v24;
        v18 = v21;
        if ( v17 == 64 )
          break;
        v24 = v23;
        v21 = v20;
        v23 = v22;
        v20 = v19;
        v22 = v30;
        v19 = v29;
      }
      v40 = v30;
      v31 = &v39;
      v32 = v38;
      v47 = v21;
      v44 = v29;
      v45 = v19;
      v46 = v20;
      v41 = v22;
      v42 = v23;
      v43 = v24;
      do
      {
        result = *v32;
        v33 = v31[1];
        ++v31;
        *v32++ += (int)v33;
      }
      while ( v36 != v32 );
      v34 = v37 == v35 + 64;
      v35 += 64;
    }
    while ( !v34 );
  }
  return result;
}
// 67844: using guessed type _DWORD dword_67844[63];

//----- (0001E874) --------------------------------------------------------
_DWORD *__fastcall sub_1E874(_DWORD *result)
{
  _DWORD *v1; // r2
  _DWORD *v2; // r3
  int v3; // t1

  v1 = &unk_67940;
  v2 = result + 34;
  do
  {
    v3 = v1[1];
    ++v1;
    *v2++ = v3;
  }
  while ( v2 != result + 42 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (0001E8A4) --------------------------------------------------------
void *__fastcall sub_1E8A4(unsigned __int8 *a1, char *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r2
  unsigned __int8 *v8; // r0
  size_t v9; // r6
  void *result; // r0
  unsigned int v11; // r3
  size_t v12; // r5
  unsigned __int8 *v13; // r6
  int v14; // r3

  v4 = *((_DWORD *)a1 + 1);
  v7 = 64 - v4;
  v8 = &a1[v4 + 8];
  if ( v7 >= n )
    v9 = n;
  else
    v9 = v7;
  result = memcpy(v8, a2, v9);
  v11 = n + *((_DWORD *)a1 + 1);
  if ( v11 > 0x3F )
  {
    v12 = n - v9;
    v13 = (unsigned __int8 *)&a2[v9];
    sub_1E678((int)a1, a1 + 8, 1);
    sub_1E678((int)a1, v13, v12 >> 6);
    result = memcpy(a1 + 8, &v13[v12 & 0xFFFFFFC0], v12 & 0x3F);
    v14 = *(_DWORD *)a1;
    *((_DWORD *)a1 + 1) = v12 & 0x3F;
    *(_DWORD *)a1 = v14 + (((v12 >> 6) + 1) << 6);
  }
  else
  {
    *((_DWORD *)a1 + 1) = v11;
  }
  return result;
}

//----- (0001E950) --------------------------------------------------------
int __fastcall sub_1E950(_DWORD *a1, _BYTE *a2)
{
  int v2; // r8
  int v3; // r9
  int v4; // r10
  int v5; // r11
  int v6; // r3
  unsigned __int8 *v9; // r6
  bool v10; // cf
  int v11; // r2
  int v12; // r7
  size_t v13; // r2
  unsigned __int8 *v14; // r0
  int v15; // r3
  int v16; // r7
  int result; // r0
  int *v18; // r3
  int *v19; // r5
  int v20; // t1
  int v21; // [sp+4h] [bp-8h]

  v6 = a1[1];
  v9 = (unsigned __int8 *)(a1 + 2);
  v10 = (v6 & 0x3Fu) >= 0x38;
  if ( (v6 & 0x3Fu) >= 0x38 )
    v11 = 128;
  else
    v11 = 64;
  v12 = v6 + *a1;
  v13 = v11 - v6;
  v14 = &v9[v6];
  if ( (v6 & 0x3Fu) >= 0x38 )
    v15 = 124;
  else
    v15 = 60;
  v16 = 8 * v12;
  if ( !v10 )
    v2 = 61;
  v21 = v15;
  if ( v10 )
    v2 = 125;
  else
    v3 = 62;
  if ( v10 )
    v3 = 126;
  else
    v4 = 63;
  if ( v10 )
    v4 = 127;
  else
    v5 = 1;
  if ( v10 )
    v5 = 2;
  memset(v14, 0, v13);
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  v9[v4] = v16;
  v9[v3] = BYTE1(v16);
  v9[v2] = BYTE2(v16);
  v9[v21] = HIBYTE(v16);
  result = sub_1E678((int)a1, v9, v5);
  v18 = a1 + 34;
  v19 = a1 + 42;
  do
  {
    a2[3] = *v18;
    v20 = *v18++;
    a2[2] = BYTE1(v20);
    a2[1] = *((_WORD *)v18 - 1);
    *a2 = *((_BYTE *)v18 - 1);
    a2 += 4;
  }
  while ( v19 != v18 );
  return result;
}
// 1E9E4: variable 'v4' is possibly undefined
// 1E9EC: variable 'v3' is possibly undefined
// 1E9F0: variable 'v2' is possibly undefined
// 1E9FC: variable 'v5' is possibly undefined

//----- (0001EA3C) --------------------------------------------------------
int __fastcall sub_1EA3C(char *a1, size_t n, _BYTE *a3)
{
  _DWORD *v3; // r3
  char *v5; // r2
  int v6; // t1
  _DWORD v8[34]; // [sp+0h] [bp-ACh] BYREF
  char v9; // [sp+88h] [bp-24h] BYREF

  v3 = &unk_67940;
  v5 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *(_DWORD *)v5 = v6;
    v5 += 4;
  }
  while ( v3 != (_DWORD *)&unk_67960 );
  v8[0] = 0;
  v8[1] = 0;
  sub_1E8A4((unsigned __int8 *)v8, a1, n);
  return sub_1E950(v8, a3);
}

//----- (0001EAA0) --------------------------------------------------------
int sub_1EAA0()
{
  return 0;
}

//----- (0001EAA8) --------------------------------------------------------
int __fastcall sub_1EAA8(int a1, const char *a2, int a3)
{
  int v5; // r8
  int v6; // r9
  int v7; // r3
  int v8; // r9
  int v9; // r8
  fd_set *p_tv_usec; // r3
  const char *v12; // r1
  ssize_t v13; // r0
  bool v14; // cc
  __int64 v15; // r2
  unsigned int v16; // r12
  unsigned int v17; // r4
  __int64 v18; // kr00_8
  unsigned int v19; // r1
  __int64 v20; // kr10_8
  int v21; // [sp+Ch] [bp-820h]
  size_t n; // [sp+14h] [bp-818h]
  int v24; // [sp+1Ch] [bp-810h]
  struct timeval timeout; // [sp+20h] [bp-80Ch] BYREF
  fd_set writefds; // [sp+28h] [bp-804h] BYREF

  v5 = *(_DWORD *)(a1 + 588);
  if ( byte_72EC8 && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf((char *)&writefds, 0x800u, "SEND: %s", a2);
    sub_1DD60(7, (const char *)&writefds, 0);
  }
  n = a3 + 1;
  *(_WORD *)&a2[strlen(a2)] = 10;
  if ( a3 + 1 > 0 )
  {
    LOBYTE(v6) = v5 & 0x1F;
    v7 = v5 / 32;
    if ( v5 <= 0 )
      v6 = -(-v5 & 0x1F);
    v8 = 1 << v6;
    v9 = v5 + 1;
    v24 = v7;
    v21 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        timeout.tv_usec = 0;
        timeout.tv_sec = 1;
        while ( 1 )
        {
          p_tv_usec = (fd_set *)&timeout.tv_usec;
          do
          {
            p_tv_usec->__fds_bits[1] = 0;
            p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
          }
          while ( &writefds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
          writefds.__fds_bits[v24] |= v8;
          if ( select(v9, 0, &writefds, 0, &timeout) > 0 )
            break;
          if ( *_errno_location() != 4 )
            return 1;
        }
        v12 = &a2[v21];
        if ( *(_BYTE *)(a1 + 592) )
          break;
        v13 = send(*(_DWORD *)(a1 + 588), v12, n, 0x4000);
        if ( v13 >= 0 )
          goto LABEL_15;
LABEL_23:
        if ( *_errno_location() != 11 )
          return 2;
      }
      v13 = SSL_write(*(_DWORD *)(a1 + 596), v12, n);
      if ( v13 < 0 )
        goto LABEL_23;
LABEL_15:
      v14 = (int)(n - v13) <= 0;
      n -= v13;
      v21 += v13;
      if ( v14 )
      {
        v15 = v21;
        goto LABEL_18;
      }
    }
  }
  v15 = 0;
LABEL_18:
  v16 = *(_DWORD *)(a1 + 504);
  v17 = *(_DWORD *)(a1 + 508);
  v18 = *(_QWORD *)(a1 + 496) + 1LL;
  *(_DWORD *)(a1 + 496) = v18;
  v19 = *(_DWORD *)(a1 + 512);
  *(_DWORD *)(a1 + 500) = HIDWORD(v18);
  v20 = __PAIR64__(*(_DWORD *)(a1 + 516), v19) + v15;
  *(_QWORD *)(a1 + 504) = __PAIR64__(v17, v16) + v15;
  *(_QWORD *)(a1 + 512) = v20;
  return 0;
}
// 12608: using guessed type int __fastcall SSL_write(_DWORD, _DWORD, _DWORD);
// 4C1E4: using guessed type __int16 word_4C1E4;
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 72EC8: using guessed type char byte_72EC8;

//----- (0001ED38) --------------------------------------------------------
int __fastcall sub_1ED38(const char **a1, int a2, int a3)
{
  const char *v5; // r0
  size_t v6; // r0
  ssize_t v7; // r0
  int v8; // r3
  int v9; // r7
  bool v10; // zf
  int v12; // r4
  char s; // [sp+10h] [bp-C00h] BYREF
  char v14; // [sp+11h] [bp-BFFh]
  char v15; // [sp+12h] [bp-BFEh]
  char v16; // [sp+13h] [bp-BFDh]
  char buf[2048]; // [sp+410h] [bp-800h] BYREF

  v5 = a1[154];
  if ( a3 )
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", v5, a1[146]);
  else
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n", v5, a1[146], v5, a1[146]);
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(buf, 0x800u, "Sending proxy %s:%s - %s", a1[155], a1[156], &s);
    sub_1DD60(7, buf, 0);
  }
  v6 = strlen(&s);
  send(a2, &s, v6, 0);
  v7 = recv(a2, &s, 0xCu, 0);
  if ( v7 > 0 )
  {
    v8 = (unsigned __int8)byte_686E1;
    *(&s + v7) = 0;
    if ( v8 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(buf, 0x800u, "Received from proxy %s:%s - %s", a1[155], a1[156], &s);
      sub_1DD60(7, buf, 0);
    }
    v9 = strcmp(&s, "HTTP/1.1 200");
    if ( v9 && (v9 = strcmp(&s, "HTTP/1.0 200")) != 0 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
      {
        snprintf(buf, 0x800u, "HTTP Error from proxy %s:%s - %s", a1[155], a1[156], &s);
        sub_1DD60(4, buf, 0);
        return 0;
      }
    }
    else
    {
      while ( recv(a2, buf, 1u, 0) != -1 )
      {
        v10 = (unsigned __int8)buf[0] == 255;
        *(&s + v9++) = buf[0];
        if ( v10 )
          goto LABEL_27;
        if ( v9 == 4 )
        {
          while ( strncmp(&s, "\r\n\r\n", 4u) )
          {
            s = v14;
            v14 = v15;
            v15 = v16;
            if ( recv(a2, buf, 1u, 0) == -1 )
            {
              v16 = -1;
              goto LABEL_27;
            }
            v16 = buf[0];
            if ( (unsigned __int8)buf[0] == 255 )
              goto LABEL_27;
          }
          v12 = (unsigned __int8)byte_686E1;
          if ( !byte_686E1 )
            return 1;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
          {
            snprintf(buf, 0x800u, "Success negotiating with %s:%s HTTP proxy", a1[155], a1[156]);
            sub_1DD60(7, buf, 0);
          }
          return v12;
        }
      }
      *(&s + v9) = -1;
LABEL_27:
      if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
      {
        v12 = 0;
        snprintf(buf, 0x800u, "Couldn't read HTTP byte from proxy %s:%s", a1[155], a1[156]);
        sub_1DD60(4, buf, 0);
        return v12;
      }
    }
    return 0;
  }
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
    return 0;
  snprintf(buf, 0x800u, "Couldn't read from proxy %s:%s after sending CONNECT", a1[155], a1[156]);
  sub_1DD60(4, buf, 0);
  return 0;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (0001F1EC) --------------------------------------------------------
int __fastcall sub_1F1EC(int a1)
{
  _BYTE *v2; // r3
  int result; // r0

  v2 = *(_BYTE **)(a1 + 608);
  if ( v2 )
    *v2 = 0;
  result = *(_DWORD *)(a1 + 588);
  *(_BYTE *)(a1 + 659) = 0;
  *(_BYTE *)(a1 + 657) = 0;
  if ( result )
  {
    if ( *(_BYTE *)(a1 + 592) && *(_DWORD *)(a1 + 596) )
    {
      SSL_shutdown(*(_DWORD *)(a1 + 596));
      X509_free(*(_DWORD *)(a1 + 604));
      SSL_CTX_free(*(_DWORD *)(a1 + 600));
      SSL_free(*(_DWORD *)(a1 + 596));
      result = *(_DWORD *)(a1 + 588);
    }
    result = close(result);
  }
  *(_DWORD *)(a1 + 588) = 0;
  return result;
}
// 124DC: using guessed type int __fastcall SSL_CTX_free(_DWORD);
// 12980: using guessed type int __fastcall SSL_free(_DWORD);
// 12A7C: using guessed type int __fastcall SSL_shutdown(_DWORD);
// 12BFC: using guessed type int __fastcall X509_free(_DWORD);

//----- (0001F26C) --------------------------------------------------------
int __fastcall sub_1F26C(int a1)
{
  unsigned int v2; // r2

  v2 = fcntl(a1, 3, 0) & 0xFFFFF7FF;
  return fcntl(a1, 4, v2);
}

//----- (0001F294) --------------------------------------------------------
bool __fastcall sub_1F294(int a1, int a2)
{
  __time_t v2; // r1
  fd_set *p_tv_usec; // r3
  int v4; // r4
  struct timeval timeout; // [sp+8h] [bp-88h] BYREF
  fd_set readfds; // [sp+10h] [bp-80h] BYREF

  v2 = a2 & ~(a2 >> 31);
  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->__fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( &readfds.__fds_bits[31] != (__fd_mask *)p_tv_usec );
  timeout.tv_usec = 0;
  timeout.tv_sec = v2;
  LOBYTE(v4) = a1 & 0x1F;
  if ( a1 <= 0 )
    v4 = -(-a1 & 0x1F);
  readfds.__fds_bits[a1 / 32] |= 1 << v4;
  return select(a1 + 1, &readfds, 0, 0, &timeout) > 0;
}

//----- (0001F328) --------------------------------------------------------
_DWORD *__fastcall sub_1F328(_DWORD *a1, unsigned int a2)
{
  _DWORD *v4; // r0

  if ( !a1 || *a1 != 1 )
    return 0;
  if ( (unsigned int)sub_48E60(a1) >= a2 )
  {
    v4 = sub_48E7C(a1, a2);
    if ( v4 )
    {
      if ( *v4 == 2 )
        return sub_49028(v4);
    }
  }
  return 0;
}

//----- (0001F38C) --------------------------------------------------------
char *__fastcall sub_1F38C(_DWORD *a1, unsigned int a2)
{
  char *result; // r0

  result = (char *)sub_1F328(a1, a2);
  if ( result )
    return _strdup(result);
  return result;
}

//----- (0001F3A4) --------------------------------------------------------
void __fastcall __noreturn sub_1F3A4(const void *a1, const char *a2, const char *a3, int a4)
{
  int *v8; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v8 = _errno_location();
  snprintf(s, 0x800u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v8, a1, a2, a3, a4);
  sub_1DD60(3, s, 1);
  sub_3C2EC(1);
}

//----- (0001F400) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1F400(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  __asm { POP             {R4-R7,PC} }
}
// 1F408: positive sp value 814 has been found
// 1F408: unbalanced stack, ignored a potential tail call

//----- (0001F40C) --------------------------------------------------------
int __fastcall sub_1F40C(const char *a1, const char *a2, int a3)
{
  size_t v6; // r0
  int v7; // r3
  const char *v8; // r2
  const char *v9; // r0
  int v10; // t1
  int result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( a1 )
  {
    v6 = strlen(a1);
    if ( !v6 )
      return 1;
    v7 = *(unsigned __int8 *)a1;
    if ( (int)dword_4C28C[v7] >= 0 )
    {
      v8 = a1;
      v9 = &a1[v6 - 1];
      while ( v8 != v9 )
      {
        v10 = *(unsigned __int8 *)++v8;
        v7 = v10;
        if ( (int)dword_4C28C[v10] < 0 )
          goto LABEL_8;
      }
      return 1;
    }
LABEL_8:
    if ( byte_72D90 || (result = (unsigned __int8)byte_686E0, byte_686E0) || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "Invalid char 0x%x passed to valid_hex from in %s %s():%d", v7, "util.c", a2, a3);
LABEL_12:
      sub_1DD60(3, s, 0);
      return 0;
    }
  }
  else if ( byte_72D90 || (result = (unsigned __int8)byte_686E0, byte_686E0) || dword_67840 > 2 )
  {
    snprintf(s, 0x800u, "Null string passed to valid_hex from in %s %s():%d", "util.c", a2, a3);
    goto LABEL_12;
  }
  return result;
}
// 4C28C: using guessed type _DWORD dword_4C28C[256];
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0001F55C) --------------------------------------------------------
int __fastcall sub_1F55C(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_wrlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}

//----- (0001F5CC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1F5CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1F5D4: positive sp value 814 has been found
// 1F5D4: unbalanced stack, ignored a potential tail call

//----- (0001F5D8) --------------------------------------------------------
int __fastcall sub_1F5D8(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}

//----- (0001F648) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1F648(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1F650: positive sp value 814 has been found
// 1F650: unbalanced stack, ignored a potential tail call

//----- (0001F654) --------------------------------------------------------
int __fastcall sub_1F654(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}

//----- (0001F6C4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1F6C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1F6CC: positive sp value 814 has been found
// 1F6CC: unbalanced stack, ignored a potential tail call

//----- (0001F6D0) --------------------------------------------------------
void __fastcall __noreturn sub_1F6D0(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_3C2EC(1);
}

//----- (0001F728) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1F728(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// 1F730: positive sp value 814 has been found
// 1F730: unbalanced stack, ignored a potential tail call

//----- (0001F734) --------------------------------------------------------
int __fastcall sub_1F734(int a1)
{
  pthread_mutex_t *v1; // r5
  int result; // r0
  _BYTE *v4; // r3

  v1 = (pthread_mutex_t *)(a1 + 720);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 720)) )
    sub_1F6D0("clear_sock", 1788);
  while ( *(_DWORD *)(a1 + 588) && recv(*(_DWORD *)(a1 + 588), *(void **)(a1 + 608), 0x1FFCu, 0) > 0 )
    ;
  sub_1F654(v1, "clear_sock", 1797);
  result = off_67964();
  v4 = *(_BYTE **)(a1 + 608);
  if ( v4 )
    *v4 = 0;
  return result;
}
// 67964: using guessed type int (*off_67964)();

//----- (0001F7C4) --------------------------------------------------------
int __fastcall sub_1F7C4(int a1, char a2)
{
  pthread_mutex_t *v2; // r5

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_1F6D0("tq_freezethaw", 1106);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_1F654(v2, "tq_freezethaw", 1109);
  return off_67964();
}
// 67964: using guessed type int (*off_67964)();

//----- (0001F828) --------------------------------------------------------
void *__fastcall sub_1F828(size_t a1, const char *a2, const char *a3, int a4)
{
  size_t v4; // r4
  void *result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v4 = a1;
  if ( (a1 & 3) != 0 )
    v4 = (a1 & 0xFFFFFFFC) + 4;
  result = malloc(v4);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to malloc size %d from %s %s:%d", v4, a2, a3, a4);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}

//----- (0001F8A4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1F8A4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __asm { POP             {R4-R8,PC} }
}
// 1F8AC: positive sp value 810 has been found
// 1F8AC: unbalanced stack, ignored a potential tail call

//----- (0001F8B0) --------------------------------------------------------
void *__fastcall sub_1F8B0(size_t a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = calloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc memb %d size %d from %s %s:%d", a1, v5, a3, a4, a5);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}

//----- (0001F934) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1F934(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __asm { POP             {R4-R8,PC} }
}
// 1F93C: positive sp value 810 has been found
// 1F93C: unbalanced stack, ignored a potential tail call

//----- (0001F940) --------------------------------------------------------
void *__fastcall sub_1F940(void *a1, size_t a2, const char *a3, const char *a4, int a5)
{
  size_t v5; // r4
  void *result; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v5 = a2;
  if ( (a2 & 3) != 0 )
    v5 = (a2 & 0xFFFFFFFC) + 4;
  result = realloc(a1, v5);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to realloc size %d from %s %s:%d", v5, a3, a4, a5);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}

//----- (0001F9C4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1F9C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  __asm { POP             {R4-R7,PC} }
}
// 1F9D0: positive sp value 814 has been found
// 1F9D0: unbalanced stack, ignored a potential tail call

//----- (0001F9D4) --------------------------------------------------------
char *__fastcall sub_1F9D4(char *a1)
{
  char **v2; // r3
  char *result; // r0

  if ( !a1 )
    return "http:";
  v2 = &off_4C6A8;
  result = "http0:";
  while ( 1 )
  {
    v2 += 2;
    if ( v2[1] == a1 )
      break;
    result = v2[2];
    if ( !result )
      return "invalid";
  }
  return result;
}
// 4C6A8: using guessed type char *off_4C6A8;

//----- (0001FA20) --------------------------------------------------------
_BYTE *__fastcall sub_1FA20(_BYTE *result, int a2, int a3)
{
  int v3; // r4
  _BYTE *v4; // r1
  _BYTE *v5; // r12
  unsigned int v6; // t1

  if ( a3 <= 0 )
  {
    *result = 0;
  }
  else
  {
    v3 = a2 + a3 - 1;
    v4 = (_BYTE *)(a2 - 1);
    v5 = result + 2;
    do
    {
      v6 = (unsigned __int8)*++v4;
      v5 += 2;
      *(v5 - 4) = *((_BYTE *)&unk_4C28C + (v6 >> 4) + 1108);
      *(v5 - 3) = *((_BYTE *)&unk_4C28C + (*v4 & 0xF) + 1108);
    }
    while ( v4 != (_BYTE *)v3 );
    result += 2 * a3;
    *result = 0;
  }
  return result;
}

//----- (0001FA90) --------------------------------------------------------
_BYTE *__fastcall sub_1FA90(int a1, int a2)
{
  int v2; // r5
  int v4; // r0
  int v6; // r12
  _BYTE *result; // r0
  _BYTE *v8; // r5
  _BYTE *v9; // r2
  char *v10; // r12
  unsigned int v11; // t1

  v2 = 2 * a2;
  v4 = 2 * a2 + 1;
  v6 = v4 & 3;
  if ( v4 <= 0 )
    v6 = -(-v4 & 3);
  result = sub_1F8B0(4 - v6 + v4, 1u, "util.c", "bin2hex", 787);
  if ( a2 > 0 )
  {
    v9 = (_BYTE *)(a1 - 1);
    v10 = result + 2;
    do
    {
      v11 = (unsigned __int8)*++v9;
      v10 += 2;
      *(v10 - 4) = *((_BYTE *)&dword_4C28C[277] + (v11 >> 4));
      *(v10 - 3) = *((_BYTE *)&dword_4C28C[277] + (*v9 & 0xF));
    }
    while ( v9 != (_BYTE *)(a1 - 1 + a2) );
    v8 = &result[v2];
  }
  else
  {
    v8 = result;
  }
  *v8 = 0;
  return result;
}
// 4C28C: using guessed type _DWORD dword_4C28C[256];

//----- (0001FB44) --------------------------------------------------------
int __fastcall sub_1FB44(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4; // r3
  unsigned int v5; // r12
  int result; // r0
  unsigned __int8 *v7; // r1
  int v8; // r3
  int v9; // r4
  char v10[2052]; // [sp+0h] [bp-804h] BYREF

  if ( !*a2 )
    return !a3;
  if ( !a3 )
    return 0;
  if ( !a2[1] )
  {
LABEL_16:
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      strcpy(v10, "hex2bin str truncated");
      sub_1DD60(3, v10, 0);
    }
    return 0;
  }
  v4 = dword_4C28C[a2[1]];
  v5 = dword_4C28C[*a2];
  result = (v4 >> 31) | (v5 >> 31);
  if ( !result )
  {
    v7 = a2 + 4;
    do
    {
      --a3;
      *a1++ = v4 | (16 * v5);
      v8 = *(v7 - 2);
      if ( !*(v7 - 2) )
        return !a3;
      if ( !a3 )
        return result;
      v9 = *(v7 - 1);
      v7 += 2;
      if ( !v9 )
        goto LABEL_16;
      v5 = dword_4C28C[v8];
      v4 = dword_4C28C[v9];
    }
    while ( ((v5 | v4) & 0x80000000) == 0 );
  }
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
    return 0;
  strcpy(v10, "hex2bin scan failed");
  sub_1DD60(3, v10, 0);
  return 0;
}
// 4C28C: using guessed type _DWORD dword_4C28C[256];
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0001FCE8) --------------------------------------------------------
size_t __fastcall sub_1FCE8(_BYTE *a1, char *s)
{
  size_t result; // r0
  char v5; // r1
  char *v6; // r7
  unsigned int v7; // r12
  char *v8; // r6
  int v9; // t1
  unsigned int *v10; // r2
  unsigned int v11; // r3
  size_t *v12; // r3
  unsigned int *v13; // r2
  size_t *v14; // r5
  unsigned int v15; // t1
  int v16; // [sp+0h] [bp-20h] BYREF
  int v17; // [sp+4h] [bp-1Ch]
  unsigned int v18[5]; // [sp+8h] [bp-18h] BYREF
  unsigned int v19; // [sp+1Ch] [bp-4h] BYREF

  memset(v18, 0, sizeof(v18));
  v17 = 0;
  v19 = 0;
  result = strlen(s);
  if ( result )
  {
    v6 = s - 1;
    v7 = 0;
    v8 = &v6[result];
    while ( 1 )
    {
      v9 = (unsigned __int8)*++v6;
      v10 = &v19;
      v11 = *((_DWORD *)&unk_4C28C + v9 + 283);
      while ( 1 )
      {
        *v10-- = 58 * v7 + v11;
        v11 = (58LL * v7 + (unsigned __int64)v11) >> 32;
        if ( &v16 == (int *)v10 )
          break;
        v7 = *v10;
      }
      if ( v8 == v6 )
        break;
      v7 = v19;
    }
    v5 = v17;
    result = bswap32(v18[0]);
  }
  else
  {
    v5 = 0;
  }
  v12 = (size_t *)(a1 + 1);
  v13 = v18;
  *a1 = v5;
  v14 = (size_t *)(a1 + 25);
  while ( 1 )
  {
    *v12++ = result;
    if ( v12 == v14 )
      break;
    v15 = v13[1];
    ++v13;
    result = bswap32(v15);
  }
  return result;
}

//----- (0001FDC0) --------------------------------------------------------
int __fastcall sub_1FDC0(int a1, int a2)
{
  char v3; // r2
  int result; // r0
  int v5; // r2

  if ( a2 > 127 )
  {
    LOWORD(v5) = 16511;
    if ( a2 > 16511 )
    {
      HIWORD(v5) = 32;
      if ( a2 <= v5 )
        result = 4;
      else
        result = 5;
      if ( a2 <= v5 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (0001FE0C) --------------------------------------------------------
int __fastcall sub_1FE0C(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // r3
  unsigned int *v3; // r2
  unsigned int v4; // lr
  unsigned int v5; // t1
  unsigned int v6; // t1
  bool v7; // cf
  int v8; // r5
  unsigned int v10; // r7
  unsigned int v11; // lr
  unsigned int v12; // r12
  unsigned int v13; // r6
  unsigned int v14; // r7
  unsigned int v15; // r12
  unsigned int v16; // lr
  unsigned int v17; // r3
  unsigned int v18; // lr
  unsigned int v19; // r3
  unsigned int v20; // r6
  unsigned int v21; // r12
  unsigned int v22; // lr
  unsigned int v23; // r3
  unsigned int v24; // r12
  char *v25; // r7
  const char *v26; // r0
  char *v27; // r6
  const char *v28; // r3
  _DWORD v29[8]; // [sp+8h] [bp-844h] BYREF
  _DWORD v30[8]; // [sp+28h] [bp-824h] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  v2 = a1 + 8;
  v3 = a2 + 8;
  while ( 1 )
  {
    v5 = *--v2;
    v4 = v5;
    v6 = *--v3;
    v7 = v4 >= v6;
    if ( v4 > v6 )
      break;
    if ( !v7 || a1 == v2 )
    {
      v8 = 1;
      goto LABEL_7;
    }
  }
  v8 = 0;
LABEL_7:
  if ( !byte_686E1 )
    return v8;
  v10 = a1[7];
  v11 = a1[5];
  v12 = a1[4];
  v29[1] = bswap32(a1[6]);
  v13 = a1[2];
  v29[0] = bswap32(v10);
  v29[2] = bswap32(v11);
  v14 = a1[3];
  v29[3] = bswap32(v12);
  v15 = *a1;
  v16 = a1[1];
  v29[5] = bswap32(v13);
  v17 = a2[7];
  v29[6] = bswap32(v16);
  v18 = a2[6];
  v29[7] = bswap32(v15);
  v30[0] = bswap32(v17);
  v19 = a2[4];
  v20 = a2[3];
  v21 = bswap32(a2[5]);
  v30[1] = bswap32(v18);
  v22 = a2[2];
  v30[2] = v21;
  v30[3] = bswap32(v19);
  v23 = *a2;
  v24 = a2[1];
  v29[4] = bswap32(v14);
  v30[4] = bswap32(v20);
  v30[6] = bswap32(v24);
  v30[7] = bswap32(v23);
  v30[5] = bswap32(v22);
  v25 = sub_1FA90((int)v29, 32);
  v26 = sub_1FA90((int)v30, 32);
  v27 = (char *)v26;
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    v28 = "YES (hash <= target)";
    if ( !v8 )
      v28 = "no (false positive; hash > target)";
    snprintf(s, 0x800u, " Proof: %s\nTarget: %s\nTrgVal? %s", v25, v26, v28);
    sub_1DD60(7, s, 0);
  }
  free(v25);
  free(v27);
  return v8;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (0001FFFC) --------------------------------------------------------
char *sub_1FFFC()
{
  char *v0; // r4

  v0 = (char *)sub_1F8B0(1u, 0x58u, "util.c", "tq_new", 1075);
  *(_DWORD *)v0 = v0;
  *((_DWORD *)v0 + 1) = v0;
  pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
  pthread_cond_init((pthread_cond_t *)(v0 + 40), 0);
  return v0;
}

//----- (00020058) --------------------------------------------------------
void __fastcall sub_20058(char *a1)
{
  int v2; // r2
  _DWORD *v3; // r0
  _DWORD *v4; // r4
  _DWORD *v5; // r3
  bool v6; // zf

  if ( a1 )
  {
    v2 = **(_DWORD **)a1;
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = (_DWORD *)(v2 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v5 = (_DWORD *)v3[2];
        *(_DWORD *)(v2 + 4) = v5;
        *v5 = v2;
        free(v3);
        v3 = v4;
        v2 = v4[1];
        v6 = v4 + 1 == (_DWORD *)a1;
        v4 = (_DWORD *)(v2 - 4);
      }
      while ( !v6 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    free(a1);
  }
}

//----- (000200C0) --------------------------------------------------------
int __fastcall sub_200C0(int a1)
{
  return sub_1F7C4(a1, 1);
}

//----- (000200C8) --------------------------------------------------------
int __fastcall sub_200C8(int a1)
{
  return sub_1F7C4(a1, 0);
}

//----- (000200D0) --------------------------------------------------------
int __fastcall sub_200D0(int a1, int a2)
{
  _DWORD *v4; // r6
  _DWORD *v5; // r4
  _DWORD *v6; // r3
  int v7; // r8

  v4 = sub_1F8B0(1u, 0xCu, "util.c", "tq_push", 1127);
  *v4 = a2;
  v5 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_1F6D0("tq_push", 1131);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v7 = 0;
    free(v4);
  }
  else
  {
    v6 = *(_DWORD **)(a1 + 4);
    v7 = 1;
    *(_DWORD *)(a1 + 4) = v5;
    v4[1] = a1;
    v4[2] = v6;
    *v6 = v5;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_1F654((pthread_mutex_t *)(a1 + 12), "tq_push", 1144);
  off_67964();
  return v7;
}
// 67964: using guessed type int (*off_67964)();

//----- (000201A4) --------------------------------------------------------
int __fastcall sub_201A4(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r6
  int *v5; // r4
  _DWORD *v6; // r2
  int v7; // r1
  int v8; // r5
  pthread_cond_t *v10; // r0
  int v11; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_1F6D0("tq_pop", 1156);
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v10 = (pthread_cond_t *)(a1 + 40);
    if ( a2 )
      v11 = pthread_cond_timedwait(v10, v2, a2);
    else
      v11 = pthread_cond_wait(v10, v2);
    if ( v11 )
    {
      v8 = 0;
      goto LABEL_4;
    }
    if ( v5 == *(int **)a1 )
    {
      v8 = 0;
      goto LABEL_4;
    }
    v5 = *(int **)a1;
  }
  v6 = (_DWORD *)v5[1];
  v7 = *v5;
  v8 = *(v5 - 1);
  *(_DWORD *)(v7 + 4) = v6;
  *v6 = v7;
  *v5 = 0;
  v5[1] = 0;
  free(v5 - 1);
LABEL_4:
  sub_1F654(v2, "tq_pop", 1182);
  off_67964();
  return v8;
}
// 67964: using guessed type int (*off_67964)();

//----- (00020284) --------------------------------------------------------
int __fastcall sub_20284(int result)
{
  int v1; // r4
  pthread_t v2; // r0
  sem_t *v3; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      v3 = (sem_t *)(v1 + 16);
      *(_DWORD *)(v1 + 12) = 0;
    }
    else
    {
      v3 = (sem_t *)(v1 + 16);
    }
    return sem_destroy(v3);
  }
  return result;
}

//----- (000202C0) --------------------------------------------------------
_DWORD *__fastcall sub_202C0(_DWORD *result, int *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result - *a2;
  *a2 = v3;
  v4 = result[1] - v2;
  a2[1] = v4;
  if ( v4 < 0 )
  {
    LODWORD(v5) = v3 - 1;
    HIDWORD(v5) = v4 + 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (000202F4) --------------------------------------------------------
_DWORD *__fastcall sub_202F4(_DWORD *result, int *a2)
{
  int v2; // lr
  int v3; // r2
  int v4; // r3
  __int64 v5; // r2

  v2 = a2[1];
  v3 = *result + *a2;
  *a2 = v3;
  v4 = result[1] + v2;
  a2[1] = v4;
  if ( v4 > 999999 )
  {
    LODWORD(v5) = v3 + 1;
    HIDWORD(v5) = v4 - 1000000;
    *(_QWORD *)a2 = v5;
  }
  return result;
}

//----- (00020338) --------------------------------------------------------
bool __fastcall sub_20338(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (0002036C) --------------------------------------------------------
bool __fastcall sub_2036C(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (000203A0) --------------------------------------------------------
_DWORD *__fastcall sub_203A0(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1] / 1000;
  return result;
}

//----- (000203D0) --------------------------------------------------------
_DWORD *__fastcall sub_203D0(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = 1000 * a2[1];
  return result;
}

//----- (000203EC) --------------------------------------------------------
int __fastcall sub_203EC(_QWORD *a1)
{
  int result; // r0
  _DWORD v3[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v3);
  *a1 = __PAIR64__(v3[2], v3[0]);
  return result;
}
// 12818: using guessed type int __fastcall lldiv(_DWORD);

//----- (00020424) --------------------------------------------------------
int __fastcall sub_20424(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 12818: using guessed type int __fastcall lldiv(_DWORD);

//----- (00020464) --------------------------------------------------------
int __fastcall sub_20464(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000000 * v4[2];
  *a1 = v3;
  return result;
}
// 12818: using guessed type int __fastcall lldiv(_DWORD);

//----- (000204A4) --------------------------------------------------------
int __fastcall sub_204A4(_QWORD *a1)
{
  int result; // r0
  __int64 v3; // r2
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  LODWORD(v3) = v4[0];
  HIDWORD(v3) = 1000 * v4[2];
  *a1 = v3;
  return result;
}
// 12818: using guessed type int __fastcall lldiv(_DWORD);

//----- (000204E0) --------------------------------------------------------
_DWORD *__fastcall sub_204E0(_DWORD *result, _DWORD *a2)
{
  int v2; // r3
  __int64 v3; // r2
  int v4; // lr
  int v5; // r1

  v2 = result[1];
  LODWORD(v3) = *result + *a2;
  *result = v3;
  HIDWORD(v3) = v2 + a2[1];
  result[1] = HIDWORD(v3);
  if ( SHIDWORD(v3) <= 999999999 )
  {
    if ( v3 < 0 )
    {
      do
      {
        HIDWORD(v3) += 1000000000;
        LODWORD(v3) = v3 - 1;
      }
      while ( v3 < 0 );
      *(_QWORD *)result = v3;
    }
  }
  else
  {
    v4 = v3 + 1;
    v5 = HIDWORD(v3) - 1000000000;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
    {
      v5 = -2000000000;
      v4 = v3 + 2;
    }
    *result = v4;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
      v5 += HIDWORD(v3);
    result[1] = v5;
  }
  return result;
}

//----- (00020658) --------------------------------------------------------
const char *__fastcall sub_20658(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    *a1 = 0;
    return v3;
  }
}

//----- (000206A0) --------------------------------------------------------
__int64 __fastcall sub_206A0(__time_t *a1)
{
  int tv_nsec; // kr00_4
  __int64 result; // r0
  struct timespec v4; // [sp+0h] [bp-8h] BYREF

  clock_gettime(1, &v4);
  tv_nsec = v4.tv_nsec;
  result = 274877907LL * v4.tv_nsec;
  *a1 = v4.tv_sec;
  a1[1] = tv_nsec / 1000;
  return result;
}

//----- (000206E4) --------------------------------------------------------
int __fastcall sub_206E4(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (00020714) --------------------------------------------------------
int __fastcall sub_20714(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // r3
  int v4; // r1
  int result; // r0

  v3 = *a1 - *a2;
  *a3 = v3;
  v4 = a2[1];
  result = a1[1] - v4;
  if ( result >= 0 )
  {
    a3[1] = result;
  }
  else
  {
    v4 = 1000000000;
    --v3;
  }
  if ( result < 0 )
  {
    *a3 = v3;
    a3[1] = result + v4;
  }
  return result;
}

//----- (00020750) --------------------------------------------------------
int __fastcall sub_20750(struct timespec *tp)
{
  return clock_gettime(1, tp);
}

//----- (0002075C) --------------------------------------------------------
int __fastcall sub_2075C(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8; // [sp+0h] [bp-8h] BYREF

  sub_20464(&v8);
  v2 = *a1;
  v8.tv_nsec += a1[1];
  tv_nsec = v8.tv_nsec;
  v4 = v8.tv_sec + v2;
  v8.tv_sec += v2;
  if ( v8.tv_nsec <= 999999999 )
  {
    if ( v8.tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8.tv_sec = v4;
      v8.tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8.tv_nsec - 1000000000;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8.tv_sec = v5;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
      v6 += v8.tv_nsec;
    v8.tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, &v8, 0);
  while ( result == 4 );
  return result;
}

//----- (0002081C) --------------------------------------------------------
int __fastcall sub_2081C(int *a1)
{
  int v2; // r1
  int tv_nsec; // r3
  __time_t v4; // r2
  __time_t v5; // r12
  int v6; // r1
  int result; // r0
  struct timespec v8; // [sp+0h] [bp-8h] BYREF

  sub_20424(&v8);
  v2 = *a1;
  v8.tv_nsec += a1[1];
  tv_nsec = v8.tv_nsec;
  v4 = v8.tv_sec + v2;
  v8.tv_sec += v2;
  if ( v8.tv_nsec <= 999999999 )
  {
    if ( v8.tv_nsec < 0 )
    {
      do
      {
        tv_nsec += 1000000000;
        --v4;
      }
      while ( tv_nsec < 0 );
      v8.tv_sec = v4;
      v8.tv_nsec = tv_nsec;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v8.tv_nsec - 1000000000;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
    {
      v6 = -2000000000;
      v5 = v4 + 2;
    }
    v8.tv_sec = v5;
    if ( v8.tv_nsec - 1000000000 > 999999999 )
      v6 += v8.tv_nsec;
    v8.tv_nsec = v6;
  }
  do
    result = clock_nanosleep(1, 1, &v8, 0);
  while ( result == 4 );
  return result;
}

//----- (000208D4) --------------------------------------------------------
int sub_208D4()
{
  struct timespec v1; // [sp+0h] [bp-8h] BYREF

  clock_gettime(1, &v1);
  return sub_2075C(&v1.tv_sec);
}

//----- (00020934) --------------------------------------------------------
int __fastcall sub_20934(int result, _DWORD *a2)
{
  if ( *(_DWORD *)result - *a2 <= 60 )
    return 1000000;
  return result;
}

//----- (000209CC) --------------------------------------------------------
void sub_209CC()
{
  ;
}

//----- (00020A10) --------------------------------------------------------
int __fastcall sub_20A10(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r6
  char *v8; // r0
  char v9; // r5
  int v10; // r5
  char *v11; // r6
  size_t v12; // r0
  int v13; // r3
  int v14; // r7
  char *v16; // r0
  char v17[8]; // [sp+8h] [bp-10Ch] BYREF
  char s[260]; // [sp+10h] [bp-104h] BYREF

  v4 = a1;
  *a2 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = (char)v8;
  if ( v8 )
    v9 = 1;
  if ( !v7 )
    v9 = 0;
  if ( v7 < v8 )
    v10 = v9 & 1;
  else
    v10 = 0;
  if ( !v10 )
    v8 = (char *)v4;
  v11 = strchr(v8, 58);
  v12 = strlen(v4);
  if ( v11 )
  {
    v13 = v11 - v4;
    v14 = ~(v11 - v4) + v12;
    if ( v14 <= 0 )
      return 0;
    ++v11;
  }
  else
  {
    v13 = v12;
    v14 = 0;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v10 )
  {
    ++v4;
    v13 -= 2;
  }
  snprintf(s, 0xFEu, "%.*s", v13, v4);
  if ( v14 )
  {
    snprintf(v17, 6u, "%.*s", v14, v11);
    v16 = strpbrk(v17, "/#");
    if ( v16 )
      *v16 = 0;
  }
  else
  {
    strcpy(v17, "80");
  }
  *a3 = _strdup(v17);
  *a2 = _strdup(s);
  return 1;
}

//----- (00020B84) --------------------------------------------------------
char *__fastcall sub_20B84(char *s1, int a2)
{
  const char *v2; // r4
  int v4; // r5
  size_t v5; // r6
  char *v7; // r0
  char *v8; // r10
  char *v9; // r0
  const char *v10; // r1

  v2 = "http:";
  v4 = 0;
  v5 = 5;
  *(_DWORD *)(a2 + 184) = 0;
  while ( strncmp(s1, v2, v5) )
  {
    ++v4;
    v2 = (&off_4C6A8)[2 * v4];
    if ( !v2 )
      return s1;
    v5 = strlen((&off_4C6A8)[2 * v4]);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)sub_1F828(1 - v5 + v7 - s1, "util.c", "get_proxy", 748);
    v10 = &s1[v5];
    *(_DWORD *)(a2 + 184) = v9;
    s1 = v8 + 1;
    strcpy(v9, v10);
    sub_20A10(*(const char **)(a2 + 184), (_DWORD *)(a2 + 620), (char **)(a2 + 624));
    *(_DWORD *)(a2 + 180) = dword_4C28C[2 * v4 + 264];
  }
  return s1;
}
// 4C28C: using guessed type _DWORD dword_4C28C[256];
// 4C6A8: using guessed type char *off_4C6A8;

//----- (00020C5C) --------------------------------------------------------
bool __fastcall sub_20C5C(int a1)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(a1 + 608);
  return *v1 || sub_1F294(*(_DWORD *)(a1 + 588), (unsigned __int8)*v1);
}

//----- (00020C7C) --------------------------------------------------------
void **__fastcall sub_20C7C(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6)
{
  _DWORD *v7; // r6

  if ( a3 != a2 )
  {
    v7 = result;
    result = (void **)sub_1F940(*result, a3, a4, a5, a6);
    *v7 = result;
    if ( a3 > a2 )
      return (void **)memset((char *)result + a2, 0, a3 - a2);
  }
  return result;
}

//----- (00020CE8) --------------------------------------------------------
int __fastcall sub_20CE8(int a1, int *a2)
{
  unsigned int v2; // r3
  unsigned int v3; // r2
  bool v4; // cc
  int v5; // r12
  int v6; // r6
  char *v7; // r3
  int result; // r0
  char v9; // t1
  _DWORD v10[4]; // [sp+0h] [bp-18h] BYREF
  _DWORD v11[2]; // [sp+10h] [bp-8h]

  v2 = 0;
  v3 = 0;
  v11[0] = 0;
  memset(v10, 0, sizeof(v10));
  *(_DWORD *)((char *)v11 + 3) = 0;
  do
  {
    if ( (a1 & (1 << v2)) != 0 )
      *((_BYTE *)v10 + v3++) = v2;
    v4 = ++v2 > 0x1F;
    if ( v2 <= 0x1F )
      v4 = v3 > 0x16;
    v5 = !v4;
  }
  while ( !v4 );
  v6 = *a2;
  if ( v3 )
  {
    if ( v6 <= 0 )
    {
      result = v5;
    }
    else
    {
      v7 = (char *)v10;
      result = v5;
      do
      {
        v9 = *v7++;
        result |= 1 << v9;
      }
      while ( (char *)v10 + v3 != v7 && (char *)v10 + v6 != v7 );
    }
  }
  else
  {
    result = 0;
  }
  if ( v6 > v3 )
    *a2 = v3;
  return result;
}

//----- (00020DA8) --------------------------------------------------------
int __fastcall sub_20DA8(int a1, char *s)
{
  size_t v4; // r0
  size_t v5; // r1
  char *v6; // r2
  char *v7; // r0
  unsigned __int8 *v8; // r1
  unsigned __int8 v9; // t1
  int result; // r0
  char v11; // r2
  unsigned int v12; // [sp+Ch] [bp-814h] BYREF
  int v13; // [sp+10h] [bp-810h] BYREF
  unsigned __int8 v14[12]; // [sp+14h] [bp-80Ch] BYREF
  char sa[2048]; // [sp+20h] [bp-800h] BYREF

  qmemcpy(v14, "000000000", 9);
  v4 = strlen(s);
  v12 = 0;
  v13 = 8;
  if ( v4 )
  {
    v5 = 7 - v4;
    v6 = s - 1;
    v7 = &s[v4 - 1];
    v8 = &v14[v5];
    do
    {
      v9 = *++v6;
      *++v8 = v9;
    }
    while ( v6 != v7 );
  }
  v14[8] = 0;
  sub_1FB44(&v12, v14, 4);
  if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
  {
    snprintf(sa, 0x800u, "mask returned by pool is %s, swaped = 0x%x", s, v12);
    sub_1DD60(6, sa, 0);
  }
  v12 = ((v12 & 0xE0FF1F) >> 8) & 0xFF00 | ((v12 & 0xE0FF1F) << 8) & 0xFF0000 | ((v12 & 0xE0FF1F) << 24);
  result = sub_20CE8(v12, &v13);
  v12 = result;
  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    snprintf(sa, 0x800u, "real mask = 0x%x, bit_num = %d", result, v13);
    sub_1DD60(5, sa, 0);
    result = v12;
    if ( !v12 )
    {
      if ( byte_72D90 || byte_686E0 )
      {
LABEL_12:
        snprintf(sa, 0x800u, "Pool %d rolling mask do not match!", *(_DWORD *)a1);
        sub_1DD60(5, sa, 0);
LABEL_13:
        result = v12;
        *(_BYTE *)(a1 + 660) = 0;
        *(_DWORD *)(a1 + 664) = 1;
        *(_DWORD *)(a1 + 668) = result;
        return result;
      }
LABEL_17:
      if ( dword_67840 <= 4 )
        goto LABEL_13;
      goto LABEL_12;
    }
  }
  else if ( !result )
  {
    goto LABEL_17;
  }
  v11 = v13;
  *(_BYTE *)(a1 + 660) = 1;
  *(_DWORD *)(a1 + 668) = result;
  *(_DWORD *)(a1 + 664) = 1 << v11;
  return result;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00020FF0) --------------------------------------------------------
int __fastcall sub_20FF0(_DWORD *a1, int a2)
{
  _DWORD *v3; // r0
  _DWORD *v4; // r5
  _DWORD *v5; // r7
  _DWORD *v6; // r0
  int v7; // r6
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  int v12; // r0
  const char *v13; // r4
  int v14; // r0
  int v15; // r0
  int v16; // r0
  _DWORD *v17; // r9
  char *v18; // r0
  char v19[92]; // [sp+14h] [bp-900h] BYREF
  char v20[160]; // [sp+70h] [bp-8A4h] BYREF
  char s[2052]; // [sp+110h] [bp-804h] BYREF

  v3 = sub_47C50(a2, 0, v19);
  v4 = v3;
  if ( v3 )
  {
    v5 = (_DWORD *)sub_48AF4(v3, "result");
    v6 = (_DWORD *)sub_48AF4(v4, "error");
    if ( v5 && *v5 != 7 && (!v6 || *v6 == 7) && (v12 = sub_48D5C(v5), (v13 = (const char *)sub_48DDC(v12)) != 0) )
    {
      v7 = 0;
      do
      {
        v16 = sub_48DF4((int)v13);
        v17 = (_DWORD *)sub_48DE8(v16);
        if ( !v17 )
          break;
        if ( !strcasecmp(v13, "version-rolling") && strlen(v13) == 15 )
        {
          if ( *v17 != 5 )
          {
            if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
            {
              snprintf(s, 0x800u, "Pool %d don't support ab!", *a1);
              sub_1DD60(5, s, 0);
            }
            *((_BYTE *)a1 + 660) = 0;
            v7 = 1;
            a1[166] = 1;
            break;
          }
          if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
          {
            snprintf(s, 0x800u, "POOL %d support ab mode!", *a1);
            sub_1DD60(5, s, 0);
          }
        }
        else if ( !strcasecmp(v13, "version-rolling.mask") && strlen(v13) == 20 )
        {
          v7 = 1;
          v18 = (char *)sub_49028(v17);
          sub_20DA8((int)a1, v18);
        }
        else if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
        {
          snprintf(s, 0x800u, "JSON-RPC unexpected mining.configure value: %s", v13);
          sub_1DD60(3, s, 0);
        }
        v14 = sub_48DF4((int)v13);
        v15 = sub_48DA8(v5, v14);
        v13 = (const char *)sub_48DDC(v15);
      }
      while ( v13 );
    }
    else
    {
      v7 = 0;
    }
    if ( v4[1] != -1 )
    {
      v8 = v4 + 1;
      __dmb(0xBu);
      do
      {
        v9 = __ldrex(v8);
        v10 = v9 - 1;
      }
      while ( __strex(v10, v8) );
      if ( !v10 )
        sub_4942C(v4);
    }
    return v7;
  }
  if ( !byte_72D90 )
  {
    v7 = (unsigned __int8)byte_686E0;
    if ( !byte_686E0 && dword_67840 <= 5 )
      return v7;
  }
  snprintf(s, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v19, v20);
  sub_1DD60(6, s, 0);
  return 0;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00021338) --------------------------------------------------------
int __fastcall sub_21338(pthread_mutex_t *a1)
{
  int *v3; // r0
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
  {
    snprintf(s, 0x800u, "Closing socket for stratum pool %d", a1->__lock);
    sub_1DD60(6, s, 0);
  }
  if ( pthread_mutex_lock(a1 + 30) )
  {
    v4 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", "suspend_stratum", 3313);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  sub_1F1EC((int)a1);
  if ( pthread_mutex_unlock(a1 + 30) )
  {
    v3 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "util.c", "suspend_stratum", 3315);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return off_67964();
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0002149C) --------------------------------------------------------
int __fastcall sub_2149C(pthread_mutex_t *a1, const char *a2, int a3)
{
  int *v6; // r0
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_72EC8 && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "SEND: %s", a2);
    sub_1DD60(7, s, 0);
  }
  if ( pthread_mutex_lock(a1 + 30) )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "util.c", "stratum_send", 1711);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( a1[27].__size[9] )
  {
    v8 = sub_1EAA8((int)a1, a2, a3);
    if ( !pthread_mutex_unlock(a1 + 30) )
    {
      off_67964();
      switch ( v8 )
      {
        case 2:
          if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
          {
            strcpy(s, "Failed to send in stratum_send");
            sub_1DD60(7, s, 0);
            sub_21338(a1);
            return 0;
          }
          break;
        case 3:
          goto LABEL_12;
        case 1:
          if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
          {
            snprintf(s, 0x800u, "Write select failed on pool %d sock", a1->__lock);
            sub_1DD60(7, s, 0);
          }
          break;
        default:
          return v8 == 0;
      }
      sub_21338(a1);
      return 0;
    }
LABEL_7:
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", "stratum_send", 1717);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( pthread_mutex_unlock(a1 + 30) )
    goto LABEL_7;
  off_67964();
LABEL_12:
  result = (unsigned __int8)byte_686E1;
  if ( byte_686E1 )
  {
    if ( byte_72D90 || (result = (unsigned __int8)byte_686E0, byte_686E0) || dword_67840 > 6 )
    {
      strcpy(s, "Stratum send failed due to no pool stratum_active");
      sub_1DD60(7, s, 0);
      return 0;
    }
  }
  return result;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 72EC8: using guessed type char byte_72EC8;

//----- (00021850) --------------------------------------------------------
char *__fastcall sub_21850(int a1)
{
  char *v2; // r9
  signed int v3; // r6
  char *v4; // r0
  char *v5; // r5
  size_t v6; // r0
  size_t v7; // r7
  unsigned int v8; // lr
  __int64 v9; // kr08_8
  unsigned int v10; // r3
  unsigned int v11; // kr04_4
  int v12; // r1
  unsigned int v13; // r2
  __time_t tv_sec; // r7
  int v16; // r5
  int v17; // r9
  bool v18; // nf
  int v19; // r9
  bool v20; // cc
  char *v21; // r8
  size_t v22; // r11
  size_t v23; // r0
  size_t v24; // r10
  unsigned int v25; // r0
  size_t v26; // r11
  char *v27; // r0
  struct timespec tp[256]; // [sp+10h] [bp-2804h] BYREF
  struct timespec s[1024]; // [sp+810h] [bp-2004h] BYREF

  v2 = *(char **)(a1 + 608);
  if ( !strchr(v2, 10) )
  {
    clock_gettime(1, s);
    tv_sec = s[0].tv_sec;
    v16 = s[0].tv_nsec / 1000;
    if ( !sub_1F294(*(_DWORD *)(a1 + 588), 60) )
    {
      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        strcpy((char *)s, "Timed out waiting for data on socket_full");
        sub_1DD60(7, (const char *)s, 0);
      }
      goto LABEL_34;
    }
    while ( 1 )
    {
      memset(s, 0, sizeof(s));
      v17 = *(_BYTE *)(a1 + 592)
          ? SSL_read(*(_DWORD *)(a1 + 596), s, 8188)
          : recv(*(_DWORD *)(a1 + 588), s, 0x1FFCu, *(unsigned __int8 *)(a1 + 592));
      if ( !v17 )
        break;
      clock_gettime(1, tp);
      v18 = v17 < 0;
      v19 = (int)((double)(tp[0].tv_nsec / 1000 - v16) / 1000000.0 + (double)(tp[0].tv_sec - tv_sec));
      if ( v18 )
      {
        if ( *_errno_location() != 11 || !sub_1F294(*(_DWORD *)(a1 + 588), 60 - v19) )
        {
          if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
          {
            strcpy((char *)tp, "Failed to recv sock in recv_line");
            sub_1DD60(7, (const char *)tp, 0);
          }
          goto LABEL_40;
        }
      }
      else
      {
        v21 = *(char **)(a1 + 608);
        v22 = strlen((const char *)s);
        v23 = strlen(v21);
        v24 = v23;
        v25 = v22 + v23 + 1;
        if ( v25 >= *(_DWORD *)(a1 + 612) )
        {
          v26 = (v25 & 0xFFFFE000) + 0x2000;
          v27 = (char *)sub_1F940(v21, v26, "util.c", "recalloc_sock", 1826);
          *(_DWORD *)(a1 + 608) = v27;
          memset(&v27[v24], 0, v26 - v24);
          v21 = *(char **)(a1 + 608);
          *(_DWORD *)(a1 + 612) = v26;
        }
        strcat(v21, (const char *)s);
      }
      v20 = v19 <= 59;
      v2 = *(char **)(a1 + 608);
      if ( !v20 || strchr(*(const char **)(a1 + 608), 10) )
        goto LABEL_2;
    }
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      strcpy((char *)tp, "Socket closed waiting in recv_line");
      sub_1DD60(7, (const char *)tp, 0);
    }
LABEL_40:
    sub_21338((pthread_mutex_t *)a1);
    v2 = *(char **)(a1 + 608);
  }
LABEL_2:
  v3 = strlen(v2);
  v4 = strtok(v2, (const char *)&word_4C1E4);
  if ( !v4 )
  {
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      strcpy((char *)s, "Failed to parse a \\n terminated string in recv_line");
      sub_1DD60(7, (const char *)s, 0);
    }
LABEL_34:
    v5 = 0;
    sub_1F734(a1);
    return v5;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( (int)(v6 + 1) < v3 )
    memmove(*(void **)(a1 + 608), (const void *)(*(_DWORD *)(a1 + 608) + v6 + 1), v3 - v6 + 1);
  else
    **(_BYTE **)(a1 + 608) = 0;
  v8 = *(_DWORD *)(a1 + 532);
  v9 = *(_QWORD *)(a1 + 520) + 1LL;
  v10 = *(_DWORD *)(a1 + 536);
  v11 = *(_DWORD *)(a1 + 528);
  *(_DWORD *)(a1 + 520) = v9;
  *(_QWORD *)(a1 + 528) = __PAIR64__(v8, v11) + v7;
  v12 = (unsigned __int8)byte_72EC8;
  v13 = *(_DWORD *)(a1 + 540);
  *(_DWORD *)(a1 + 524) = HIDWORD(v9);
  *(_QWORD *)(a1 + 536) = __PAIR64__(v13, v10) + v7;
  if ( v12 && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf((char *)s, 0x800u, "RECVD: %s", v5);
    sub_1DD60(7, (const char *)s, 0);
  }
  return v5;
}
// 12764: using guessed type int __fastcall SSL_read(_DWORD, _DWORD, _DWORD);
// 4C1E4: using guessed type __int16 word_4C1E4;
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 72EC8: using guessed type char byte_72EC8;

//----- (00021DDC) --------------------------------------------------------
int __fastcall sub_21DDC(_DWORD *a1)
{
  int v2; // r2
  _DWORD *v3; // r7
  size_t v4; // r0
  int v5; // r8
  int v7; // r9
  const char *v8; // r1
  size_t v9; // r3
  void *v10; // r0
  _BYTE *v11; // r0
  int v12; // r2
  unsigned __int8 *v13; // r1
  int v14; // r3
  int v15; // r2
  unsigned int *v16; // r3
  unsigned int v17; // r2
  unsigned int v18; // r2
  char *v19; // r0
  char *v20; // r9
  _DWORD *v21; // r9
  _DWORD *v22; // r0
  char *v23; // r8
  unsigned int *v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r2
  int v27; // r2
  int *v28; // r0
  int *v29; // r0
  int *v30; // r0
  int *v31; // r0
  _DWORD *v32; // r0
  unsigned int i; // r8
  _DWORD *v34; // r0
  _DWORD *v35; // r10
  char *v36; // r10
  char *v37; // r8
  int v38; // r3
  const char *v39; // r0
  _DWORD *v40; // r0
  int v41; // r0
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  const char *v45; // [sp+4h] [bp-2928h]
  unsigned int v46; // [sp+10h] [bp-291Ch]
  char *v47; // [sp+10h] [bp-291Ch]
  _DWORD *v48; // [sp+18h] [bp-2914h]
  int v49; // [sp+18h] [bp-2914h]
  _DWORD *v50; // [sp+20h] [bp-290Ch]
  int v51[23]; // [sp+2Ch] [bp-2900h] BYREF
  char v52[160]; // [sp+88h] [bp-28A4h] BYREF
  char s[2040]; // [sp+128h] [bp-2804h] BYREF
  char v54[8196]; // [sp+928h] [bp-2004h] BYREF

  sub_1F734((int)a1);
  v2 = dword_72DBC;
  if ( a1[163] )
  {
    v45 = (const char *)a1[163];
    ++dword_72DBC;
    sprintf(
      v54,
      "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"%s/%s\", \"%s\"]}",
      v2,
      byte_6A35C,
      byte_6A25C,
      v45);
  }
  else
  {
    ++dword_72DBC;
    sprintf(v54, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"%s/%s\"]}", v2, byte_6A35C, byte_6A25C);
  }
  v3 = 0;
  v46 = 0;
  while ( 1 )
  {
    v4 = strlen(v54);
    if ( sub_1EAA8((int)a1, v54, v4) )
    {
      if ( !byte_686E1 )
      {
LABEL_6:
        if ( v3 )
        {
          v5 = 0;
          goto LABEL_36;
        }
        return 0;
      }
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
        goto LABEL_84;
      strcpy(s, "Failed to send s in initiate_stratum");
      sub_1DD60(7, s, 0);
      goto LABEL_45;
    }
    if ( !sub_1F294(a1[147], 60) )
    {
      if ( !byte_686E1 )
        goto LABEL_6;
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
        goto LABEL_84;
      strcpy(s, "Timed out waiting for response in initiate_stratum");
      sub_1DD60(7, s, 0);
LABEL_45:
      if ( !byte_686E1 )
        goto LABEL_6;
      if ( byte_72D90 )
      {
LABEL_47:
        strcpy(s, "Initiate stratum failed");
        sub_1DD60(7, s, 0);
        goto LABEL_6;
      }
LABEL_84:
      if ( !byte_686E0 && dword_67840 <= 6 )
        goto LABEL_6;
      goto LABEL_47;
    }
    v19 = sub_21850((int)a1);
    v20 = v19;
    if ( !v19 )
      goto LABEL_45;
    v3 = sub_47C50((int)v19, 0, (char *)v51);
    free(v20);
    if ( v3 )
      break;
    v46 ^= 1u;
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      snprintf(s, 0x800u, "JSON decode failed(%d): %s", v51[0], v52);
      sub_1DD60(6, s, 0);
    }
LABEL_65:
    if ( !v46 )
      goto LABEL_45;
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
    {
      v31 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v31, "util.c", "initiate_stratum", 3543);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v30 = _errno_location();
      snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v30, "util.c", "initiate_stratum", 3543);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    free((void *)a1[163]);
    free((void *)a1[157]);
    a1[157] = 0;
    a1[163] = 0;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v29 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v29,
        "util.c",
        "initiate_stratum",
        3547);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
    {
      v28 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v28, "util.c", "initiate_stratum", 3547);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    off_67964();
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      strcpy(s, "Failed to resume stratum, trying afresh");
      sub_1DD60(7, s, 0);
    }
    if ( v3 )
    {
      if ( v3[1] != -1 )
      {
        v24 = v3 + 1;
        __dmb(0xBu);
        do
        {
          v25 = __ldrex(v24);
          v26 = v25 - 1;
        }
        while ( __strex(v26, v24) );
        if ( !v26 )
          sub_4942C(v3);
      }
    }
    sub_1F734((int)a1);
    v27 = dword_72DBC++;
    sprintf(v54, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v27);
  }
  v21 = (_DWORD *)sub_48AF4(v3, "result");
  v22 = (_DWORD *)sub_48AF4(v3, "error");
  if ( !v21 || *v21 == 7 )
  {
    if ( v22 )
    {
LABEL_60:
      v23 = sub_45A6C(v22, 3);
    }
    else
    {
      v23 = (char *)malloc(0x11u);
      if ( v23 )
        strcpy(v23, "(unknown reason)");
    }
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      snprintf(s, 0x800u, "JSON-RPC decode failed: %s", v23);
      sub_1DD60(6, s, 0);
    }
    v46 ^= 1u;
    free(v23);
    goto LABEL_65;
  }
  if ( v22 && *v22 != 7 )
    goto LABEL_60;
  v32 = sub_48E7C(v21, 0);
  v48 = v32;
  if ( v32 )
  {
    if ( *v32 == 1 )
    {
      v50 = sub_48E60(v32);
      if ( (int)v50 > 0 )
      {
        for ( i = 0; v50 != (_DWORD *)i; ++i )
        {
          v34 = sub_48E7C(v48, i);
          v35 = v34;
          if ( !v34 || *v34 != 1 )
            break;
          v39 = (const char *)sub_1F328(v34, 0);
          if ( v39 && !strncasecmp(v39, "mining.notify", 0xDu) )
          {
            v36 = sub_1F38C(v35, 1u);
            if ( v36 )
              goto LABEL_110;
            break;
          }
        }
      }
    }
  }
  v36 = (char *)(unsigned __int8)byte_686E1;
  if ( byte_686E1 )
  {
    if ( byte_72D90 || (v36 = (char *)(unsigned __int8)byte_686E0, byte_686E0) || dword_67840 > 6 )
    {
      v36 = 0;
      strcpy(s, "Failed to get sessionid in initiate_stratum");
      sub_1DD60(7, s, 0);
    }
  }
LABEL_110:
  v37 = sub_1F38C(v21, 1u);
  v38 = sub_1F40C(v37, "initiate_stratum", 3485);
  if ( !v38 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      strcpy(s, "Failed to get valid nonce1 in initiate_stratum");
      sub_1DD60(6, s, 0);
    }
    v46 ^= 1u;
    free(v36);
    goto LABEL_65;
  }
  v49 = v38;
  v40 = sub_48E7C(v21, 2u);
  v41 = sub_49284((int)v40);
  if ( (unsigned int)(v41 - 2) > 0xE )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      strcpy(s, "Failed to get valid n2size in initiate_stratum");
      sub_1DD60(6, s, 0);
    }
    v46 ^= 1u;
    free(v36);
    free(v37);
    goto LABEL_65;
  }
  v7 = v41;
  v47 = v37;
  v5 = v49;
  if ( v36 )
  {
    v8 = (const char *)a1[163];
    if ( v8 )
    {
      if ( !strcmp(v36, v8) && (byte_72D90 || byte_686E0 || dword_67840 > 4) )
      {
        snprintf(s, 0x800u, "Pool %d successfully negotiated resume with the same session ID", *a1);
        sub_1DD60(5, s, 0);
      }
    }
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
    sub_1F6D0("initiate_stratum", 3505);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
  {
    v44 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v44, "util.c", "initiate_stratum", 3505);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  free((void *)a1[157]);
  free((void *)a1[163]);
  a1[163] = v36;
  a1[157] = v47;
  v9 = strlen(v47) >> 1;
  v10 = (void *)a1[158];
  a1[395] = v9;
  free(v10);
  v11 = sub_1F8B0(a1[395], 1u, "util.c", "initiate_stratum", 3512);
  v12 = a1[395];
  v13 = (unsigned __int8 *)a1[157];
  a1[158] = v11;
  sub_1FB44(v11, v13, v12);
  a1[162] = v7;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
  {
    v43 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v43, "util.c", "initiate_stratum", 3515);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
  {
    v42 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v42, "util.c", "initiate_stratum", 3515);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  off_67964();
  if ( v36 && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "Pool %d stratum session id: %s", *a1, (const char *)a1[163]);
    sub_1DD60(7, s, 0);
  }
  v14 = a1[144];
  *((_BYTE *)a1 + 657) = 1;
  if ( !v14 )
    a1[144] = a1[154];
  v15 = (unsigned __int8)byte_72EC8;
  *((_QWORD *)a1 + 229) = 0;
  *((_QWORD *)a1 + 230) = 0x3FF0000000000000LL;
  if ( v15 )
  {
    v5 = (unsigned __int8)byte_686E1;
    if ( byte_686E1 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
      {
        snprintf(
          s,
          0x800u,
          "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
          *a1,
          (const char *)a1[157],
          a1[162]);
        sub_1DD60(7, s, 0);
      }
    }
    else
    {
      v5 = v15;
    }
  }
LABEL_36:
  if ( v3[1] == -1 )
    return v5;
  v16 = v3 + 1;
  __dmb(0xBu);
  do
  {
    v17 = __ldrex(v16);
    v18 = v17 - 1;
  }
  while ( __strex(v18, v16) );
  if ( v18 )
    return v5;
  sub_4942C(v3);
  return v5;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 72DBC: using guessed type int dword_72DBC;
// 72EC8: using guessed type char byte_72EC8;

//----- (00022BB4) --------------------------------------------------------
time_t __fastcall sub_22BB4(_DWORD *a1, int a2)
{
  time_t result; // r0

  result = time(0);
  a1[62] = a2;
  a1[61] = result;
  switch ( a2 )
  {
    case 0:
      ++a1[63];
      break;
    case 1:
      ++a1[64];
      break;
    case 2:
      ++a1[65];
      break;
    case 3:
      ++a1[66];
      break;
    case 4:
      ++a1[67];
      break;
    case 5:
      ++a1[68];
      break;
    case 6:
      ++a1[69];
      break;
    case 7:
      ++a1[70];
      break;
    case 8:
      ++a1[71];
      break;
    case 9:
      ++a1[72];
      break;
    default:
      return result;
  }
  return result;
}
// 22BD8: control flows out of bounds to 22BDC

//----- (00022CA4) --------------------------------------------------------
char *__fastcall sub_22CA4(char *a1, char *s)
{
  size_t v4; // r0
  const char *v5; // r1
  char *v6; // r4
  size_t v7; // r4
  size_t v8; // r0
  char *v10; // r4

  v4 = strlen(s);
  if ( !v4 )
    return a1;
  v7 = v4 + 1;
  if ( a1 )
  {
    v8 = strlen(a1) + v7;
    if ( (v8 & 3) != 0 )
      v8 = (v8 & 0xFFFFFFFC) + 4;
    v6 = (char *)sub_1F828(v8, "util.c", "realloc_strcat", 3641);
    sprintf(v6, "%s%s", a1, s);
    free(a1);
    return v6;
  }
  if ( (v7 & 3) != 0 )
    v4 = v7 & 0xFFFFFFFC;
  else
    LOWORD(v5) = -12304;
  if ( (v7 & 3) != 0 )
    LOWORD(v5) = -12304;
  else
    v4 = v7;
  if ( (v7 & 3) != 0 )
    v4 += 4;
  HIWORD(v5) = 4;
  v10 = (char *)sub_1F828(v4, v5, "realloc_strcat", 3641);
  strcpy(v10, s);
  return v10;
}
// 22D50: variable 'v5' is possibly undefined

//----- (00022D78) --------------------------------------------------------
char *__fastcall sub_22D78(const char *a1)
{
  size_t v2; // r0
  char *v3; // r5
  char *v4; // r7
  char *v5; // r4
  char v6; // r3
  char v7; // r2
  int v8; // t1
  char *v10; // r2
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( !a1 )
  {
    v10 = (char *)malloc(7u);
    if ( !v10 )
    {
      snprintf(s, 0x800u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3666);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    strcpy(v10, "(null)");
  }
  v2 = strlen(a1);
  v3 = (char *)(a1 - 1);
  v4 = (char *)sub_1F828(4 * v2 + 5, "util.c", "str_text", 3671);
  v5 = v4;
  do
  {
    while ( 1 )
    {
      v8 = (unsigned __int8)*++v3;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) <= 0x5E )
        break;
      sprintf(v5, "0x%02x");
      v6 = *v3;
      v5 += 4;
      if ( !*v3 )
        goto LABEL_7;
    }
    *v5++ = v7;
    v6 = *v3;
  }
  while ( *v3 );
LABEL_7:
  *v5 = v6;
  return v4;
}

//----- (00022E98) --------------------------------------------------------
int __fastcall sub_22E98(const char *a1)
{
  char s[20]; // [sp+8h] [bp-14h] BYREF

  snprintf(s, 0x10u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (00022ED8) --------------------------------------------------------
int __fastcall sub_22ED8(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r4
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = sem_init(a1, 0, 0);
  v8 = result;
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}

//----- (00022F54) --------------------------------------------------------
int __fastcall sub_22F54(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  sub_22ED8((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1189);
  return pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (00022F9C) --------------------------------------------------------
int __fastcall sub_22F9C(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0

  result = sem_post(a1);
  if ( result )
    sub_1F3A4(a1, a2, a3, a4);
  return result;
}

//----- (00022FD4) --------------------------------------------------------
int __fastcall sub_22FD4(int a1)
{
  pthread_setcanceltype(1, 0);
  (*(void (__fastcall **)(_DWORD))(a1 + 16))(*(_DWORD *)(a1 + 20));
  sub_22F9C((sem_t *)a1, "util.c", "completion_thread", 3897);
  return 0;
}

//----- (00023018) --------------------------------------------------------
int __fastcall sub_23018(sem_t *sem, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v9; // r3
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  while ( 1 )
  {
    result = sem_wait(sem);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 != 4 )
    {
      snprintf(s, 0x800u, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v9, sem, a2, a3, a4);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
  }
  return result;
}

//----- (00023098) --------------------------------------------------------
int __fastcall sub_23098(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  __time_t tv_sec; // r10
  int v8; // r5
  int v9; // r3
  __time_t v10; // r2
  bool v11; // cc
  int v12; // r1
  __time_t v13; // r0
  int result; // r0
  struct timespec abstime; // [sp+18h] [bp-80Ch] BYREF
  struct timespec tp; // [sp+20h] [bp-804h] BYREF

  clock_gettime(1, &tp);
  tv_sec = tp.tv_sec;
  v8 = 1000 * (tp.tv_nsec / 1000);
  sub_20464(&abstime);
  while ( 1 )
  {
    v9 = v8 + abstime.tv_nsec;
    v10 = tv_sec + abstime.tv_sec;
    v11 = v8 + abstime.tv_nsec <= 999999999;
    abstime.tv_sec += tv_sec;
    abstime.tv_nsec += v8;
    if ( v11 )
    {
      if ( v9 < 0 )
      {
        do
        {
          v9 += 1000000000;
          --v10;
        }
        while ( v9 < 0 );
        abstime.tv_sec = v10;
        abstime.tv_nsec = v9;
      }
    }
    else
    {
      v12 = v9 - 1000000000;
      v13 = v10 + 1;
      if ( v9 - 1000000000 > 999999999 )
      {
        v12 = v9 - 2000000000;
        v13 = v10 + 2;
      }
      abstime.tv_sec = v13;
      abstime.tv_nsec = v12;
    }
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    result = *_errno_location();
    if ( result == 110 )
      break;
    if ( result != 4 )
    {
      snprintf((char *)&tp, 0x800u, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", result, a1, a3, a4, a5);
      sub_1DD60(3, (const char *)&tp, 1);
      sub_3C2EC(1);
    }
  }
  return result;
}

//----- (000231E0) --------------------------------------------------------
void sub_231E0()
{
  JUMPOUT(0x23168);
}
// 231E4: control flows out of bounds to 23168

//----- (000231E8) --------------------------------------------------------
int *__fastcall sub_231E8(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (00023220) --------------------------------------------------------
bool __fastcall sub_23220(int a1, int a2, int a3)
{
  sem_t *v6; // r4
  int v7; // r5
  pthread_t newthread[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = (sem_t *)sub_1F828(0x18u, "util.c", "cg_completion_timeout", 3908);
  sub_22ED8(v6, "util.c", "cg_completion_timeout", 3909);
  v6[1].__align = a1;
  *(&v6[1].__align + 1) = a2;
  pthread_create(newthread, 0, (void *(*)(void *))sub_22FD4, v6);
  v7 = sub_23098(v6, a3, "util.c", "cg_completion_timeout", 3915);
  if ( v7 )
  {
    pthread_cancel(newthread[0]);
    return v7 == 0;
  }
  else
  {
    pthread_join(newthread[0], 0);
    free(v6);
    return 1;
  }
}

//----- (000232EC) --------------------------------------------------------
void __fastcall sub_232EC(void *a1, const void *a2, size_t a3, int a4, int a5, int a6)
{
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( (int)(a3 - 1) < 0 )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      return;
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes from %s %s():%d", a3, a4, a5, a6);
LABEL_9:
    sub_1DD60(3, s, 0);
    return;
  }
  if ( !a1 )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      return;
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes to NULL from %s %s():%d", a3, a4, a5, a6);
    goto LABEL_9;
  }
  if ( a2 )
  {
    memcpy(a1, a2, a3);
    return;
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(s, 0x800u, "ERR: Asked to memcpy %u bytes from NULL from %s %s():%d", a3, a4, a5, a6);
    goto LABEL_9;
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (000235FC) --------------------------------------------------------
void __fastcall sub_235FC(void *a1, const void *a2)
{
  sub_232EC(a1, a2, 8u, (int)"util.c", (int)"copy_time", 1234);
}

//----- (00023630) --------------------------------------------------------
int __fastcall sub_23630(int a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r5
  int v6; // r6
  int v8; // r9
  unsigned int v9; // r4
  unsigned __int8 *v10; // r7
  char *v11; // r4
  char *v12; // r12
  char *v13; // r7
  char *v14; // r0
  int v15; // r3
  _DWORD *v16; // r0
  bool v17; // r4
  signed int v18; // r0
  char *v19; // r2
  int v20; // r3
  int v21; // t1
  void *v22; // r0
  const char *v23; // r3
  double v24; // d7
  int v25; // r4
  char *v26; // r1
  int v27; // r2
  char *v28; // r3
  size_t v29; // r1
  void *v30; // r0
  void *v31; // r0
  size_t v32; // r12
  int v33; // r8
  char *v34; // r7
  char *v35; // r7
  char *v36; // r5
  char *v37; // r7
  char *v38; // r7
  char *v39; // r4
  const char *v40; // r3
  int v41; // r2
  int v42; // r1
  int *v43; // r12
  int v44; // r0
  int v45; // r1
  int v46; // r2
  int v47; // r3
  int *v48; // r12
  int v49; // r0
  int v50; // r1
  int v51; // r2
  int v52; // r3
  int v53; // r0
  int v54; // r1
  int v55; // r2
  int v56; // r3
  int v57; // r12
  const char *v58; // r0
  char *v59; // r5
  const char *v60; // lr
  int v61; // r0
  int v62; // r1
  int v63; // r2
  int v64; // r3
  int *v65; // lr
  int v66; // r0
  int v67; // r1
  int v68; // r2
  int v69; // r3
  int v70; // r0
  int v71; // r1
  int v72; // r2
  int v73; // r3
  int v74; // r1
  void *v75; // r0
  signed int v76; // r4
  unsigned __int8 *v77; // r7
  int v78; // r6
  void *v79; // r0
  char *v80; // r3
  char v81[4]; // [sp+18h] [bp-964h] BYREF
  char *v82; // [sp+1Ch] [bp-960h]
  const char *v83; // [sp+20h] [bp-95Ch]
  int v84; // [sp+24h] [bp-958h]
  pthread_rwlock_t *v85; // [sp+28h] [bp-954h]
  pthread_mutex_t *v86; // [sp+2Ch] [bp-950h]
  char *v87; // [sp+30h] [bp-94Ch]
  const char *v88; // [sp+34h] [bp-948h]
  const char *v89; // [sp+38h] [bp-944h]
  const char *v90; // [sp+3Ch] [bp-940h]
  const char *v91; // [sp+40h] [bp-93Ch]
  char *v92; // [sp+44h] [bp-938h]
  char *v93; // [sp+48h] [bp-934h]
  size_t v94; // [sp+4Ch] [bp-930h]
  struct timeval *tv; // [sp+50h] [bp-92Ch]
  const char *v96; // [sp+54h] [bp-928h]
  const char *v97; // [sp+58h] [bp-924h]
  const char *v98; // [sp+5Ch] [bp-920h]
  const char *v99; // [sp+60h] [bp-91Ch]
  char *s; // [sp+64h] [bp-918h]
  void *ptr; // [sp+68h] [bp-914h]
  char *v102; // [sp+6Ch] [bp-910h]
  struct timeval v103; // [sp+74h] [bp-908h] BYREF
  _DWORD v104[9]; // [sp+158h] [bp-824h] BYREF
  int v105; // [sp+17Ch] [bp-800h]
  int v106; // [sp+180h] [bp-7FCh]
  int v107; // [sp+184h] [bp-7F8h]
  int v108; // [sp+188h] [bp-7F4h]
  __int16 v109; // [sp+18Ch] [bp-7F0h]
  char v110; // [sp+18Eh] [bp-7EEh]

  v4 = sub_48E7C(a2, 4u);
  v5 = v4;
  if ( v4 && *v4 == 1 )
  {
    v8 = (int)sub_48E60(v4);
    if ( v8 > 0 )
    {
      v9 = 0;
      v6 = 0;
      while ( 1 )
      {
        memset(&v103, 0, 0x20u);
        v10 = (unsigned __int8 *)sub_1F38C(v5, v9);
        if ( !v10 )
          return v6;
        v6 = sub_1FB44(&v103, v10, 32);
        if ( !v6 )
          break;
        ++v9;
        free(v10);
        if ( v8 == v9 )
          goto LABEL_21;
      }
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2
        || (v102 = (char *)v104,
            snprintf((char *)v104, 0x800u, "merkle %d: %s", v9, (const char *)v10),
            sub_1DD60(3, (const char *)v104, 0),
            !byte_72D90)
        && !byte_686E0 )
      {
        if ( dword_67840 <= 2 )
        {
LABEL_17:
          free(v10);
          return v6;
        }
        v102 = (char *)v104;
      }
      v11 = v102;
      v12 = v102;
      *(_DWORD *)v102 = *(_DWORD *)"Failed to convert merkle to merkle_bin in parse_notify";
      strcpy(v12 + 4, "ed to convert merkle to merkle_bin in parse_notify");
      sub_1DD60(3, v11, 0);
      goto LABEL_17;
    }
    v6 = 0;
LABEL_21:
    v13 = sub_1F38C(a2, 0);
    v99 = (const char *)sub_1F328(a2, 1u);
    ptr = sub_1F38C(a2, 2u);
    s = sub_1F38C(a2, 3u);
    v98 = (const char *)sub_1F328(a2, 5u);
    v97 = (const char *)sub_1F328(a2, 6u);
    v96 = (const char *)sub_1F328(a2, 7u);
    v14 = (char *)strtol(v96, 0, 16);
    if ( v14 )
      v15 = ((unsigned __int8)byte_6A7DD ^ 1) & 1;
    else
      v15 = 0;
    if ( v15 )
    {
      v102 = v14;
      v103.tv_usec = 0;
      tv = &v103;
      v103.tv_sec = 0;
      gettimeofday(&v103, 0);
      if ( (unsigned int)v102 > v103.tv_sec )
      {
        v103.tv_sec = (__time_t)v102;
        settimeofday(tv, 0);
        if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
        {
          v102 = (char *)v104;
          strcpy((char *)v104, "settime notify.ntime successfuly");
          sub_1DD60(5, (const char *)v104, 0);
        }
        byte_6A7DD = 1;
      }
    }
    v16 = sub_48E7C(a2, 8u);
    v17 = (char)v16;
    if ( v16 )
    {
      v17 = *sub_48E7C(a2, 8u) == 5;
      tv = (struct timeval *)v17;
    }
    else
    {
      tv = 0;
    }
    if ( v13 )
    {
      v18 = strlen(v13);
      if ( v18 )
      {
        v19 = v13;
        while ( 1 )
        {
          v21 = (unsigned __int8)*v19++;
          v20 = v21;
          if ( (unsigned int)(v21 - 32) > 0x5E )
            break;
          if ( v18 <= v19 - v13 )
          {
            if ( !sub_1F40C(v99, "parse_notify", 2027)
              || !sub_1F40C((const char *)ptr, "parse_notify", 2027)
              || !sub_1F40C(s, "parse_notify", 2028)
              || !sub_1F40C(v98, "parse_notify", 2028)
              || !sub_1F40C(v97, "parse_notify", 2028)
              || !sub_1F40C(v96, "parse_notify", 2029) )
            {
              goto LABEL_39;
            }
            v86 = (pthread_mutex_t *)(a1 + 212);
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
              sub_1F6D0("parse_notify", 2038);
            v85 = (pthread_rwlock_t *)(a1 + 236);
            sub_1F55C((pthread_rwlock_t *)(a1 + 236), "parse_notify", 2038);
            v22 = *(void **)(a1 + 688);
            v91 = (const char *)(a1 + 1728);
            free(v22);
            v23 = v99;
            *(_DWORD *)(a1 + 688) = v13;
            snprintf((char *)(a1 + 1728), 0x41u, "%s", v23);
            v102 = (char *)(strlen((const char *)ptr) >> 1);
            v90 = (const char *)(a1 + 1796);
            v94 = strlen(s) >> 1;
            snprintf((char *)(a1 + 1796), 9u, "%s", v98);
            v89 = (const char *)(a1 + 1808);
            snprintf((char *)(a1 + 1808), 9u, "%s", v97);
            v88 = (const char *)(a1 + 1820);
            snprintf((char *)(a1 + 1820), 9u, "%s", v96);
            *(_BYTE *)(a1 + 696) = v17;
            v24 = *(double *)(a1 + 1832);
            v25 = 0;
            v26 = v102;
            if ( v24 > 0.0 )
              *(double *)(a1 + 1840) = v24;
            v27 = *(_DWORD *)(a1 + 648);
            v28 = &v26[*(_DWORD *)(a1 + 1580)];
            v29 = v94;
            *(_DWORD *)(a1 + 1592) = v28;
            v87 = &v28[v29 + v27];
            *(_DWORD *)(a1 + 1588) = v87;
            while ( *(_DWORD *)(a1 + 1724) > v25 )
            {
              v30 = *(void **)(*(_DWORD *)(a1 + 692) + 4 * v25++);
              free(v30);
            }
            if ( v8 )
            {
              v75 = sub_1F940(*(void **)(a1 + 692), 4 * v8 + 1, "util.c", "parse_notify", 2059);
              v93 = &byte_72EC8;
              v76 = 0;
              *(_DWORD *)(a1 + 692) = v75;
              v83 = "util.c";
              v82 = &byte_686E1;
              v92 = v13;
              do
              {
                v84 = 4 * v76;
                if ( v76 >= v8 )
                {
                  v13 = v92;
                  *(_DWORD *)(a1 + 1724) = v8;
                  if ( v8 > 1 )
                    goto LABEL_69;
                  goto LABEL_68;
                }
                v77 = (unsigned __int8 *)sub_1F38C(v5, v76);
                v78 = *(_DWORD *)(a1 + 692);
                v79 = sub_1F828(0x20u, v83, "parse_notify", 2064);
                v80 = v93;
                *(_DWORD *)(v78 + 4 * v76) = v79;
                if ( *v80 && *v82 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
                {
                  snprintf((char *)v104, 0x800u, "merkle %d: %s", v76, v77);
                  sub_1DD60(7, (const char *)v104, 0);
                }
                ++v76;
                v6 = sub_1FB44(*(_BYTE **)(*(_DWORD *)(a1 + 692) + v84), v77, 32);
                free(v77);
              }
              while ( v6 );
              v13 = v92;
              if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
              {
                v60 = "Failed to convert merkle to merkle_bin in parse_notify";
                goto LABEL_146;
              }
              goto LABEL_137;
            }
            *(_DWORD *)(a1 + 1724) = 0;
            v93 = &byte_72EC8;
LABEL_68:
            ++*(_QWORD *)(a1 + 376);
LABEL_69:
            if ( tv )
              *(_QWORD *)(a1 + 640) = 0;
            snprintf(
              (char *)&v103,
              0xE1u,
              "%s%s%s%s%s%s%s",
              v90,
              v91,
              "0000000000000000000000000000000000000000000000000000000000000000",
              v88,
              v89,
              "00000000",
              off_68290);
            v6 = sub_1FB44((_BYTE *)(a1 + 1596), (unsigned __int8 *)&v103, 112);
            if ( v6 )
            {
              v6 = sub_1FB44(v81, (unsigned __int8 *)ptr, (int)v102);
              if ( v6 )
              {
                v6 = sub_1FB44(v81, (unsigned __int8 *)s, v94);
                if ( v6 )
                {
                  free(*(void **)(a1 + 1584));
                  v31 = sub_1F8B0((size_t)v87, 1u, "util.c", "parse_notify", 2121);
                  *(_DWORD *)(a1 + 1584) = v31;
                  sub_232EC(v31, v81, (size_t)v102, (int)"util.c", (int)"parse_notify", 2122);
                  v32 = *(_DWORD *)(a1 + 1580);
                  if ( v32 )
                  {
                    sub_232EC(
                      &v102[*(_DWORD *)(a1 + 1584)],
                      *(const void **)(a1 + 632),
                      v32,
                      (int)"util.c",
                      (int)"parse_notify",
                      2124);
                    v32 = *(_DWORD *)(a1 + 1580);
                  }
                  sub_232EC(
                    &v102[v32 + *(_DWORD *)(a1 + 648) + *(_DWORD *)(a1 + 1584)],
                    v81,
                    v94,
                    (int)"util.c",
                    (int)"parse_notify",
                    2125);
                  v33 = (unsigned __int8)byte_686E1;
                  if ( byte_686E1 )
                  {
                    v58 = sub_1FA90(*(_DWORD *)(a1 + 1584), *(_DWORD *)(a1 + 1588));
                    v59 = (char *)v58;
                    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
                    {
                      snprintf((char *)v104, 0x800u, "Pool %d coinbase %s", *(_DWORD *)a1, v58);
                      sub_1DD60(7, (const char *)v104, 0);
                    }
                    v6 = v33;
                    free(v59);
                  }
                  goto LABEL_77;
                }
                if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
                {
                  v43 = (int *)&unk_4DA3C;
LABEL_130:
                  v44 = *v43;
                  v45 = v43[1];
                  v46 = v43[2];
                  v47 = v43[3];
                  v48 = v43 + 4;
                  v104[0] = v44;
                  v104[1] = v45;
                  v104[2] = v46;
                  v104[3] = v47;
                  v49 = *v48;
                  v50 = v48[1];
                  v51 = v48[2];
                  v52 = v48[3];
                  v48 += 4;
                  v104[4] = v49;
                  v104[5] = v50;
                  v104[6] = v51;
                  v104[7] = v52;
                  v53 = *v48;
                  v54 = v48[1];
                  v55 = v48[2];
                  v56 = v48[3];
                  v57 = v48[4];
                  v104[8] = v53;
                  v105 = v54;
                  v106 = v55;
                  v107 = v56;
                  LOBYTE(v108) = v57;
                  sub_1DD60(3, (const char *)v104, 0);
                  goto LABEL_77;
                }
              }
              else if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
              {
                v43 = (int *)&unk_4DA08;
                goto LABEL_130;
              }
LABEL_137:
              v6 = 0;
              goto LABEL_77;
            }
            if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
              goto LABEL_137;
            v60 = "Failed to convert header to header_bin in parse_notify";
LABEL_146:
            v61 = *(_DWORD *)v60;
            v62 = *((_DWORD *)v60 + 1);
            v63 = *((_DWORD *)v60 + 2);
            v64 = *((_DWORD *)v60 + 3);
            v65 = (int *)(v60 + 16);
            v104[0] = v61;
            v104[1] = v62;
            v104[2] = v63;
            v104[3] = v64;
            v66 = *v65;
            v67 = v65[1];
            v68 = v65[2];
            v69 = v65[3];
            v65 += 4;
            v104[4] = v66;
            v104[5] = v67;
            v104[6] = v68;
            v104[7] = v69;
            v70 = *v65;
            v71 = v65[1];
            v72 = v65[2];
            v73 = v65[3];
            v65 += 4;
            v104[8] = v70;
            v105 = v71;
            v106 = v72;
            v107 = v73;
            v74 = v65[1];
            v108 = *v65;
            v109 = v74;
            v110 = BYTE2(v74);
            sub_1DD60(3, (const char *)v104, 0);
LABEL_77:
            sub_1F5D8(v85, "parse_notify", 2134);
            sub_1F654(v86, "parse_notify", 2134);
            off_67964();
            if ( !*v93 )
              goto LABEL_123;
            if ( !byte_686E1 )
              goto LABEL_98;
            if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
            {
              v102 = (char *)v104;
              snprintf((char *)v104, 0x800u, "job_id: %s", v13);
              sub_1DD60(7, (const char *)v104, 0);
              if ( byte_686E1 )
              {
                if ( !byte_72D90 )
                  goto LABEL_84;
LABEL_87:
                v34 = v102;
                snprintf(v102, 0x800u, "prev_hash: %s", v99);
                sub_1DD60(7, v34, 0);
                if ( byte_686E1 )
                {
                  if ( !byte_72D90 )
                    goto LABEL_89;
LABEL_92:
                  v35 = v102;
                  snprintf(v102, 0x800u, "coinbase1: %s", (const char *)ptr);
                  sub_1DD60(7, v35, 0);
                  if ( byte_686E1 )
                  {
                    if ( !byte_72D90 )
                      goto LABEL_94;
LABEL_97:
                    v36 = v102;
                    snprintf(v102, 0x800u, "coinbase2: %s", s);
                    sub_1DD60(7, v36, 0);
LABEL_98:
                    if ( byte_686E1 )
                    {
                      if ( !byte_72D90 )
                        goto LABEL_100;
                      goto LABEL_102;
                    }
LABEL_123:
                    free(ptr);
                    free(s);
                    v41 = dword_74F88;
                    v42 = dword_74F8C;
                    ++*(_DWORD *)(a1 + 116);
                    *(_QWORD *)&dword_74F88 = __PAIR64__(v42, v41) + 1;
                    if ( a1 == sub_2FB78() )
                      byte_76068 = 1;
                    return v6;
                  }
LABEL_115:
                  if ( !byte_686E1 )
                    goto LABEL_123;
                  if ( !byte_72D90 )
                  {
LABEL_117:
                    if ( !byte_686E0 && dword_67840 <= 6 )
                      goto LABEL_123;
                    v102 = (char *)v104;
                  }
                  v39 = v102;
                  v40 = "yes";
                  if ( !tv )
                    v40 = "no";
                  snprintf(v102, 0x800u, "clean: %s", v40);
                  sub_1DD60(7, v39, 0);
                  goto LABEL_123;
                }
LABEL_109:
                if ( !byte_686E1 )
                  goto LABEL_123;
                if ( !byte_72D90 )
                {
LABEL_111:
                  if ( !byte_686E0 && dword_67840 <= 6 )
                    goto LABEL_117;
                  v102 = (char *)v104;
                }
                v38 = v102;
                snprintf(v102, 0x800u, "ntime: %s", v96);
                sub_1DD60(7, v38, 0);
                goto LABEL_115;
              }
LABEL_103:
              if ( !byte_686E1 )
                goto LABEL_123;
              if ( !byte_72D90 )
                goto LABEL_105;
            }
            else
            {
LABEL_84:
              if ( byte_686E0 || dword_67840 > 6 )
              {
                v102 = (char *)v104;
                goto LABEL_87;
              }
LABEL_89:
              if ( byte_686E0 || dword_67840 > 6 )
              {
                v102 = (char *)v104;
                goto LABEL_92;
              }
LABEL_94:
              if ( byte_686E0 || dword_67840 > 6 )
              {
                v102 = (char *)v104;
                goto LABEL_97;
              }
LABEL_100:
              if ( byte_686E0 || dword_67840 > 6 )
              {
LABEL_102:
                v102 = (char *)v104;
                snprintf((char *)v104, 0x800u, "bbversion: %s", v98);
                sub_1DD60(7, (const char *)v104, 0);
                goto LABEL_103;
              }
LABEL_105:
              if ( !byte_686E0 && dword_67840 <= 6 )
                goto LABEL_111;
              v102 = (char *)v104;
            }
            v37 = v102;
            snprintf(v102, 0x800u, "nbit: %s", v97);
            sub_1DD60(7, v37, 0);
            goto LABEL_109;
          }
        }
        if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
        {
          snprintf(
            (char *)v104,
            0x800u,
            "Invalid char 0x%x passed to valid_ascii from in %s %s():%d",
            v20,
            "util.c",
            "parse_notify",
            2027);
          goto LABEL_38;
        }
        goto LABEL_39;
      }
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      {
LABEL_39:
        free(v13);
        free(ptr);
        free(s);
        return v6;
      }
      snprintf(
        (char *)v104,
        0x800u,
        "Zero length string passed to valid_ascii from in %s %s():%d",
        "util.c",
        "parse_notify",
        2027);
    }
    else
    {
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
        goto LABEL_39;
      snprintf(
        (char *)v104,
        0x800u,
        "Null string passed to valid_ascii from in %s %s():%d",
        "util.c",
        "parse_notify",
        2027);
    }
LABEL_38:
    sub_1DD60(3, (const char *)v104, 0);
    goto LABEL_39;
  }
  return 0;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 68290: using guessed type char *off_68290;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 6A7DD: using guessed type char byte_6A7DD;
// 72D90: using guessed type char byte_72D90;
// 72EC8: using guessed type char byte_72EC8;
// 74F88: using guessed type int dword_74F88;
// 74F8C: using guessed type int dword_74F8C;
// 76068: using guessed type char byte_76068;

//----- (00024798) --------------------------------------------------------
int __fastcall sub_24798(const char **a1, int a2, int a3)
{
  __int16 v6; // kr00_2
  unsigned int v7; // r10
  const char *v9; // r0
  const char *v10; // r10
  size_t v11; // r0
  size_t v12; // r8
  int v13; // r4
  unsigned int v14; // r10
  struct addrinfo *pai; // [sp+8h] [bp-A28h] BYREF
  char v16; // [sp+Ch] [bp-A24h] BYREF
  __int16 v17; // [sp+2Ch] [bp-A04h] BYREF
  char v18; // [sp+2Eh] [bp-A02h]
  char v19; // [sp+2Fh] [bp-A01h]
  int v20; // [sp+30h] [bp-A00h]
  char v21[8]; // [sp+34h] [bp-9FCh] BYREF
  _BYTE v22[500]; // [sp+3Ch] [bp-9F4h] BYREF
  struct addrinfo flags[64]; // [sp+230h] [bp-800h] BYREF

  v17 = 260;
  v6 = strtol(a1[146], 0, 10);
  v18 = HIBYTE(v6);
  v19 = v6;
  strcpy(v21, "CGMINER");
  v7 = bswap32(inet_addr(a1[154]));
  if ( v7 != -1 )
    goto LABEL_2;
  pai = (struct addrinfo *)&v16;
  memset(flags, 0, 0x20u);
  v9 = a1[154];
  flags[0].ai_family = 2;
  if ( !getaddrinfo(v9, 0, flags, &pai) )
  {
    v14 = *(_DWORD *)&pai->ai_addr->sa_data[2];
    freeaddrinfo(pai);
    v7 = bswap32(v14);
    if ( v7 != -1 )
    {
LABEL_2:
      HIBYTE(v20) = v7;
      LOBYTE(v20) = HIBYTE(v7);
      BYTE1(v20) = BYTE2(v7);
      BYTE2(v20) = BYTE1(v7);
      send(a2, &v17, 0x10u, 0);
      goto LABEL_3;
    }
LABEL_23:
    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
    {
      snprintf((char *)flags, 0x800u, "Invalid IP address specified for socks4 proxy: %s", a1[154]);
      goto LABEL_9;
    }
    return 0;
  }
  if ( !a3 )
    goto LABEL_23;
  v10 = a1[154];
  v20 = 0x1000000;
  v11 = strlen(v10);
  if ( v11 >= 0xFF )
    v12 = 255;
  else
    v12 = v11;
  sub_232EC(v22, v10, v12, (int)"util.c", (int)"socks4_negotiate", 2981);
  v22[v12] = 0;
  send(a2, &v17, v12 + 17, 0);
LABEL_3:
  if ( recv(a2, flags, 1u, 0) == -1
    || LOBYTE(flags[0].ai_flags)
    || recv(a2, flags, 1u, 0) == -1
    || LOBYTE(flags[0].ai_flags) != 90 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
    {
      snprintf((char *)flags, 0x800u, "Bad response from %s:%s SOCKS4 server", a1[155], a1[156]);
LABEL_9:
      sub_1DD60(4, (const char *)flags, 0);
      return 0;
    }
    return 0;
  }
  v13 = 6;
  do
  {
    recv(a2, flags, 1u, 0);
    --v13;
  }
  while ( v13 );
  return 1;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00024A54) --------------------------------------------------------
int __fastcall sub_24A54(pthread_mutex_t *a1)
{
  pthread_mutex_t *v1; // r4
  pthread_mutex_t *v2; // r11
  int kind; // r0
  unsigned int nusers; // r3
  int v5; // r0
  struct addrinfo *v6; // r6
  int v7; // r0
  int v8; // r7
  int v9; // r0
  int *v10; // r11
  int v12; // r5
  int v13; // r4
  char *v14; // r12
  int v15; // r0
  int v16; // r1
  int v17; // r2
  __int16 v18; // r3
  int v19; // r3
  char *v20; // r8
  int v21; // r10
  fd_set *p_ai_next; // r3
  int v23; // r0
  const char *v24; // r0
  unsigned int v25; // r3
  int v26; // r4
  int v27; // r3
  int inited; // r0
  int v29; // r0
  int v30; // r8
  int v31; // r0
  int v32; // r5
  int cert_store; // r0
  int v34; // r5
  int v35; // r0
  int v36; // r6
  int error; // r0
  int v38; // r0
  size_t v39; // r0
  int v40; // r2
  int *v41; // r0
  int *v42; // r0
  char *v43; // r0
  char *v44; // r5
  int v45; // r2
  int v46; // r2
  int current_cipher; // r0
  const char *v48; // r0
  int verify_result; // r0
  int v50; // r10
  bool v51; // cc
  int v52; // r6
  int peer_certificate; // r10
  size_t v54; // r0
  const char *v55; // r0
  const char *v56; // r6
  size_t v57; // r0
  size_t v58; // r4
  __int16 v59; // r0
  char *v60; // r12
  int v61; // r4
  int v62; // r6
  int v63; // r4
  int bio_X509; // [sp+14h] [bp-2858h]
  char *service; // [sp+20h] [bp-284Ch]
  char *name; // [sp+24h] [bp-2848h]
  pthread_mutex_t *v67; // [sp+2Ch] [bp-2840h]
  struct addrinfo *pai; // [sp+34h] [bp-2838h] BYREF
  socklen_t optlen; // [sp+38h] [bp-2834h] BYREF
  int optval; // [sp+3Ch] [bp-2830h] BYREF
  struct timeval timeout; // [sp+40h] [bp-282Ch] BYREF
  struct addrinfo s; // [sp+48h] [bp-2824h] BYREF
  fd_set writefds; // [sp+68h] [bp-2804h] BYREF
  char v74[8196]; // [sp+868h] [bp-2004h] BYREF

  v1 = a1 + 30;
  v2 = a1;
  if ( pthread_mutex_lock(a1 + 30) )
  {
    v41 = _errno_location();
    snprintf(
      v74,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v41,
      "util.c",
      "setup_stratum_socket",
      3101);
    sub_1DD60(3, v74, 1);
    sub_3C2EC(1);
  }
  kind = v2[24].__kind;
  v2[27].__size[9] = 0;
  if ( kind )
  {
    if ( v2[24].__size[16] && v2[24].__spins )
    {
      SSL_shutdown(v2[24].__spins);
      X509_free(v2[25].__count);
      SSL_CTX_free(v2[25].__lock);
      SSL_free(v2[24].__spins);
      kind = v2[24].__kind;
    }
    close(kind);
  }
  v2[24].__kind = 0;
  if ( pthread_mutex_unlock(v1) )
  {
    v42 = _errno_location();
    snprintf(
      v74,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v42,
      "util.c",
      "setup_stratum_socket",
      3119);
    sub_1DD60(3, v74, 1);
    sub_3C2EC(1);
  }
  off_67964();
  memset(&s, 0, sizeof(s));
  nusers = v2[7].__nusers;
  s.ai_socktype = 1;
  if ( nusers )
    goto LABEL_7;
  v24 = (const char *)dword_6A6B0;
  if ( !dword_6A6B0 )
  {
    name = (char *)v2[25].__nusers;
    goto LABEL_81;
  }
  v2[7].__nusers = dword_6A6B0;
  sub_20A10(v24, &v2[25].__spins, (char **)&v2[26]);
  v25 = v2[7].__nusers;
  v2[7].__kind = 3;
  name = (char *)v2[25].__nusers;
  if ( !v25 )
  {
LABEL_81:
    service = (char *)v2[24].__owner;
    v5 = getaddrinfo(name, service, &s, &pai);
    goto LABEL_8;
  }
LABEL_7:
  name = (char *)v2[25].__spins;
  service = (char *)v2[26].__lock;
  v5 = getaddrinfo(name, service, &s, &pai);
LABEL_8:
  if ( v5 )
  {
    if ( v2[4].__size[3] )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        snprintf(v74, 0x800u, "Failed to getaddrinfo for %s:%s", name, service);
        sub_1DD60(6, v74, 0);
      }
    }
    else
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
      {
        snprintf(v74, 0x800u, "Failed to resolve (?wrong URL) %s:%s", name, service);
        sub_1DD60(4, v74, 0);
      }
      v2[4].__size[3] = 1;
    }
    _res_init();
LABEL_37:
    if ( !byte_686E1 )
      return 0;
    goto LABEL_38;
  }
  v6 = pai;
  if ( !pai )
    goto LABEL_27;
  v67 = v2;
  while ( 1 )
  {
    while ( 1 )
    {
      v7 = socket(v6->ai_family, v6->ai_socktype, v6->ai_protocol);
      v8 = v7;
      if ( v7 != -1 )
        break;
      if ( !byte_686E1 || !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
        goto LABEL_25;
      v14 = v74;
      v15 = *(_DWORD *)"Failed socket";
      v16 = *(_DWORD *)"ed socket";
      v17 = *(_DWORD *)"ocket";
      v18 = *(_WORD *)"t";
LABEL_53:
      *(_DWORD *)v14 = v15;
      *((_DWORD *)v14 + 1) = v16;
      *((_DWORD *)v14 + 2) = v17;
      *((_WORD *)v14 + 6) = v18;
      sub_1DD60(7, v74, 0);
      v6 = v6->ai_next;
      if ( !v6 )
      {
LABEL_26:
        v2 = v67;
LABEL_27:
        if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
        {
          snprintf(v74, 0x800u, "Failed to connect to stratum on %s:%s", name, service);
          sub_1DD60(6, v74, 0);
        }
        freeaddrinfo(pai);
        if ( !byte_686E1 )
          return 0;
LABEL_38:
        v12 = 0;
LABEL_39:
        if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
        {
LABEL_42:
          strcpy((char *)&writefds, "Initiate stratum failed");
          sub_1DD60(7, (const char *)&writefds, 0);
        }
        if ( !v12 )
          return 0;
LABEL_44:
        v13 = 0;
        sub_21338(v2);
        return v13;
      }
    }
    v9 = fcntl(v7, 3, 0);
    fcntl(v8, 4, v9 | 0x800);
    if ( connect(v8, v6->ai_addr, v6->ai_addrlen) != -1 )
      break;
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    v10 = _errno_location();
    if ( *v10 != 115 )
    {
      close(v8);
      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        strcpy(v74, "Failed sock connect");
        sub_1DD60(7, v74, 0);
      }
      goto LABEL_25;
    }
    LOBYTE(v19) = v8 & 0x1F;
    if ( v8 <= 0 )
      v19 = -(-v8 & 0x1F);
    v20 = &v74[4 * (v8 / 32)];
    v21 = 1 << v19;
    while ( 1 )
    {
      p_ai_next = (fd_set *)&s.ai_next;
      do
      {
        p_ai_next->__fds_bits[1] = 0;
        p_ai_next = (fd_set *)((char *)p_ai_next + 4);
      }
      while ( &writefds.__fds_bits[31] != (__fd_mask *)p_ai_next );
      *((_DWORD *)v20 - 512) |= v21;
      v23 = select(v8 + 1, 0, &writefds, 0, &timeout);
      if ( v23 > 0 )
        break;
      if ( !v23 || *v10 != 4 )
        goto LABEL_62;
    }
    if ( (v21 & *((_DWORD *)v20 - 512)) != 0 )
    {
      optlen = 4;
      if ( !getsockopt(v8, 1, 4, &optval, &optlen) && !optval )
      {
        v2 = v67;
        if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
        {
          strcpy(v74, "Succeeded delayed connect");
          sub_1DD60(7, v74, 0);
        }
        goto LABEL_77;
      }
    }
LABEL_62:
    close(v8);
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      qmemcpy(v74, "Select timeout/f", 16);
      v14 = &v74[16];
      v15 = *(_DWORD *)"ailed connect";
      v16 = *(_DWORD *)"d connect";
      v17 = *(_DWORD *)"nnect";
      v18 = *(_WORD *)"t";
      goto LABEL_53;
    }
LABEL_25:
    v6 = v6->ai_next;
    if ( !v6 )
      goto LABEL_26;
  }
  v2 = v67;
  if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
  {
    strcpy(v74, "Succeeded immediate connect");
    sub_1DD60(4, v74, 0);
  }
LABEL_77:
  sub_1F26C(v8);
  freeaddrinfo(pai);
  if ( v2[7].__nusers )
  {
    switch ( v2[7].__kind )
    {
      case 0:
        v46 = 0;
        goto LABEL_165;
      case 1:
        v46 = 1;
LABEL_165:
        if ( !sub_1ED38((const char **)v2, v8, v46) )
          goto LABEL_37;
        break;
      case 2:
        v45 = 0;
        goto LABEL_150;
      case 3:
      case 5:
        LOWORD(writefds.__fds_bits[0]) = 261;
        BYTE2(writefds.__fds_bits[0]) = 0;
        if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
        {
          snprintf(
            v74,
            0x800u,
            "Attempting to negotiate with %s:%s SOCKS5 proxy",
            (const char *)v2[25].__spins,
            (const char *)v2[26].__lock);
          sub_1DD60(7, v74, 0);
        }
        send(v8, &writefds, 3u, 0);
        if ( recv(v8, v74, 1u, 0) == -1
          || v74[0] != 5
          || recv(v8, v74, 1u, 0) == -1
          || BYTE2(writefds.__fds_bits[0]) != (unsigned __int8)v74[0] )
        {
          if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
          {
LABEL_193:
            if ( !byte_686E1 || dword_67840 <= 6 )
              return 0;
            v12 = 0;
            goto LABEL_42;
          }
        }
        else
        {
          v56 = (const char *)v2[25].__nusers;
          writefds.__fds_bits[0] = 50331909;
          v57 = strlen(v56);
          if ( v57 >= 0xFF )
            v58 = 255;
          else
            v58 = v57;
          LOBYTE(writefds.__fds_bits[1]) = v58;
          sub_232EC((char *)&writefds.__fds_bits[1] + 1, v56, v58, (int)"util.c", (int)"socks5_negotiate", 2879);
          v59 = strtol((const char *)v2[24].__owner, 0, 10);
          v60 = &v74[v58];
          *(v60 - 2042) = v59;
          *(v60 - 2043) = HIBYTE(v59);
          send(v8, &writefds, v58 + 7, 0);
          if ( recv(v8, v74, 1u, 0) != -1 && v74[0] == 5 && recv(v8, v74, 1u, 0) != -1 )
          {
            v61 = (unsigned __int8)v74[0];
            if ( !v74[0] )
            {
              recv(v8, v74, 1u, 0);
              if ( recv(v8, v74, 1u, v61) != -1 )
              {
                if ( v74[0] == 1 )
                {
                  v26 = 4;
                  do
                  {
                    recv(v8, v74, 1u, 0);
                    --v26;
                  }
                  while ( v26 );
                  goto LABEL_91;
                }
                if ( v74[0] == 3 )
                {
                  v62 = 0;
                  if ( recv(v8, v74, 1u, 0) == -1 )
                    v63 = -1;
                  else
                    v63 = (unsigned __int8)v74[0];
                  while ( 1 )
                  {
                    v51 = v62++ < v63;
                    if ( !v51 )
                      break;
                    recv(v8, v74, 1u, 0);
                  }
LABEL_91:
                  recv(v8, v74, 1u, 0);
                  recv(v8, v74, 1u, 0);
                  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
                  {
                    snprintf(
                      v74,
                      0x800u,
                      "Success negotiating with %s:%s SOCKS5 proxy",
                      (const char *)v2[25].__spins,
                      (const char *)v2[26].__lock);
                    sub_1DD60(7, v74, 0);
                  }
                  break;
                }
              }
            }
          }
          if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
            goto LABEL_37;
        }
        snprintf(v74, 0x800u, "Bad response from %s:%s SOCKS5 server", v2[25].__spins, v2[26].__lock);
        sub_1DD60(4, v74, 0);
        goto LABEL_37;
      case 4:
        v45 = 1;
LABEL_150:
        if ( !sub_24798((const char **)v2, v8, v45) )
          goto LABEL_37;
        break;
      default:
        if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
          goto LABEL_193;
        snprintf(
          v74,
          0x800u,
          "Unsupported proxy type for %s:%s",
          (const char *)v2[25].__spins,
          (const char *)v2[26].__lock);
        sub_1DD60(4, v74, 0);
        goto LABEL_37;
    }
  }
  if ( !v2[25].__owner )
  {
    v2[25].__owner = (int)sub_1F8B0(0x2000u, 1u, "util.c", "setup_stratum_socket", 3257);
    v2[25].__kind = 0x2000;
  }
  v27 = (unsigned __int8)v2[24].__size[16];
  v2[24].__kind = v8;
  if ( v27 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
    {
      strcpy(v74, "start ssl connect\n");
      sub_1DD60(5, v74, 0);
    }
    OPENSSL_init_ssl(0, 0, 0);
    OPENSSL_init_crypto(12, 0, 0);
    inited = OPENSSL_init_ssl(2097154, 0, 0);
    v29 = TLS_client_method(inited);
    v30 = SSL_CTX_new(v29);
    v31 = BIO_s_mem();
    v32 = BIO_new(v31);
    BIO_write(
      v32,
      "-----BEGIN CERTIFICATE-----\n"
      "MIIC7zCCAdcCFFbqE9PJlIVF9gfzurkXzS6t7SPIMA0GCSqGSIb3DQEBCwUAMDQx\n"
      "CzAJBgNVBAYTAlNHMRMwEQYDVQQIDApTb21lLVN0YXRlMRAwDgYDVQQKDAdBTlRQ\n"
      "T09MMB4XDTI0MDgzMDAyNDAwMloXDTM0MDgyODAyNDAwMlowNDELMAkGA1UEBhMC\n"
      "U0cxEzARBgNVBAgMClNvbWUtU3RhdGUxEDAOBgNVBAoMB0FOVFBPT0wwggEiMA0G\n"
      "CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCeWq27wElC20BA1ro6WSp/vQkVMJvK\n"
      "dOPkWjARKZcz+SE3ruEGo/x/Wqt3uBfzzKlGuae4nbEfBEj1yNl6bCA847RNurV4\n"
      "t7c4n7pK969hGXi9P77ckBlG69xMKvk4hfDvpJBWxHD9GF7Zi2ntfxkH7lsFiLwK\n"
      "SaMtvdVIBDY6lOIPfKMdmYeJxbl5wWtXlXSF2cYvLcZa4s6TsT2ead8lLEy7jVR2\n"
      "4MPAbc+EdPlFIH96hSvJjGSO+27RqiiUwGzA8BSZTa7yXjypGuIhizsjPqQSc7rN\n"
      "qKr+0Cebblw7X0UxDvr/0LQSZTQj2lF9MZ1O7MyTq6sCQLTIehuUdZj5AgMBAAEw\n"
      "DQYJKoZIhvcNAQELBQADggEBAE7SpQFMU8fXKQUKmhYn+LbSLyYUJcYBFfyjicZt\n"
      "H6FjmzTqaHApzjj013kwMfKQ5ymWAyDSnf9fwZUTh8jzw9UaRXfvkSkw1OBY3WzH\n"
      "ROJb6MA4nOaahPDvVxoCV/Ypvky17BH0Vkt+p7gs+58dDDRAVg6C5iSueYXHUmAs\n"
      "6vxAKX1XnkIkTakxjJAx1h+i1FCCsuWrO1wwZLgivXnmltcVRxkPkrz7k+XsKfa7\n"
      "70HDg1PN1fL6L5pFQhb3NfVonYaVZAbsxMjnXVFGbsTrnc+1IfJ5rTBAbK67Sa2r\n"
      "uAJMOjhJj0foq2v9TmSVqCjpK++9ToviWuf+8/C7Kc/EJEk=\n"
      "-----END CERTIFICATE-----\n",
      1079);
    bio_X509 = PEM_read_bio_X509(v32, 0, 0);
    if ( !bio_X509 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        strcpy(v74, "unable to parse certificate in memory\n");
        sub_1DD60(3, v74, 0);
      }
      BIO_free(v32);
      goto LABEL_146;
    }
    cert_store = SSL_CTX_get_cert_store(v30);
    X509_STORE_add_cert(cert_store, bio_X509);
    BIO_free(v32);
    v34 = SSL_new(v30);
    SSL_set_fd(v34, v2[24].__kind);
    v35 = SSL_connect(v34);
    v36 = v35;
    if ( v35 != 1 )
    {
      if ( (byte_72D90 || byte_686E0 || dword_67840 > 2)
        && ((snprintf(v74, 0x800u, "unable to connect pool by ssl, connect ret %d\n", v35),
             sub_1DD60(3, v74, 0),
             byte_72D90)
         || byte_686E0)
        || dword_67840 > 2 )
      {
        error = SSL_get_error(v34, v36);
        snprintf(v74, 0x800u, "SSL error #%d in accept,program terminated\n", error);
        sub_1DD60(3, v74, 0);
      }
      goto LABEL_109;
    }
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      current_cipher = SSL_get_current_cipher(v34);
      v48 = (const char *)SSL_CIPHER_get_name(current_cipher);
      snprintf(v74, 0x800u, "Connected with %s encryption\n", v48);
      sub_1DD60(6, v74, 0);
    }
    verify_result = SSL_get_verify_result(v34);
    v50 = verify_result;
    v51 = verify_result != 0;
    if ( verify_result )
      v51 = (unsigned int)(verify_result - 9) > 1;
    v52 = v51;
    if ( v51 )
    {
      if ( (byte_72D90 || byte_686E0 || dword_67840 > 2)
        && ((v55 = (const char *)X509_verify_cert_error_string(verify_result),
             snprintf(v74, 0x800u, "Verify return code: %ld (%s)\n", v50, v55),
             sub_1DD60(3, v74, 0),
             byte_72D90)
         || byte_686E0)
        || dword_67840 > 2 )
      {
        strcpy(v74, "cert of pool is verify fail\n");
        sub_1DD60(3, v74, 0);
      }
      goto LABEL_185;
    }
    peer_certificate = SSL_get_peer_certificate(v34);
    if ( !peer_certificate
      || (v54 = strlen((const char *)v2[24].__lock), X509_check_host(peer_certificate, v2[24].__lock, v54, v52, v52) != 1) )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        strcpy(v74, "cert check fail\n");
        sub_1DD60(3, v74, 0);
      }
LABEL_185:
      SSL_shutdown(v34);
LABEL_109:
      X509_free(bio_X509);
      SSL_CTX_free(v30);
      SSL_free(v34);
LABEL_146:
      close(v8);
      v2[24].__kind = 0;
      goto LABEL_37;
    }
    v2[25].__lock = v30;
    v2[24].__spins = v34;
    v2[25].__count = bio_X509;
  }
  writefds.__fds_bits[0] = 45;
  *(_DWORD *)v74 = 30;
  timeout.tv_sec = 1;
  v38 = fcntl(v8, 3, 0);
  fcntl(v8, 4, v38 | 0x800);
  setsockopt(v8, 1, 9, &timeout, 4u);
  if ( !byte_762E0 )
    fcntl(v8, 2, 1);
  setsockopt(v8, 6, 1, &timeout, 4u);
  setsockopt(v8, 6, 6, &timeout, 4u);
  setsockopt(v8, 6, 4, &writefds, 4u);
  setsockopt(v8, 6, 5, v74, 4u);
  if ( byte_682C4 )
  {
    v40 = dword_72DBC++;
    sprintf(
      v74,
      "{\"id\":%d, \"method\":\"mining.configure\", \"params\":[[\"version-rolling\"],{\"version-rolling.mask\":\"%08x\","
      "\"version-rolling.min-bit-count\":%d}]}",
      v40,
      536862720,
      8);
    v2[27].__nusers = 1;
  }
  v39 = strlen(v74);
  if ( sub_1EAA8((int)v2, v74, v39) )
  {
    if ( !byte_686E1 )
      goto LABEL_44;
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
      goto LABEL_122;
    strcpy((char *)&writefds, "Failed to send s in initiate_stratum");
    sub_1DD60(7, (const char *)&writefds, 0);
    goto LABEL_121;
  }
  v13 = sub_1F294(v2[24].__kind, 60);
  if ( !v13 )
  {
    if ( !byte_686E1 )
      goto LABEL_44;
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
    {
LABEL_122:
      v12 = 1;
      goto LABEL_39;
    }
    strcpy((char *)&writefds, "Timed out waiting for response in initiate_stratum");
    sub_1DD60(7, (const char *)&writefds, 0);
LABEL_121:
    if ( !byte_686E1 )
      goto LABEL_44;
    goto LABEL_122;
  }
  v43 = sub_21850((int)v2);
  v44 = v43;
  if ( !v43 )
    goto LABEL_121;
  sub_20FF0(v2, (int)v43);
  free(v44);
  if ( !v2[24].__lock )
    v2[24].__lock = v2[25].__nusers;
  v2[27].__size[9] = 1;
  if ( !byte_72EC8 )
    return v13;
  v13 = (unsigned __int8)byte_686E1;
  if ( !byte_686E1 )
    return (unsigned __int8)byte_72EC8;
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
    return v13;
  snprintf(
    (char *)&writefds,
    0x800u,
    "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
    v2->__lock,
    (const char *)v2[26].__count,
    v2[27].__lock);
  sub_1DD60(7, (const char *)&writefds, 0);
  return v13;
}
// 250EC: control flows out of bounds to 250F0
// 12434: using guessed type int __fastcall X509_check_host(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 124AC: using guessed type int __fastcall TLS_client_method(_DWORD);
// 124DC: using guessed type int __fastcall SSL_CTX_free(_DWORD);
// 12530: using guessed type int __fastcall SSL_get_current_cipher(_DWORD);
// 12674: using guessed type int __fastcall SSL_set_fd(_DWORD, _DWORD);
// 126BC: using guessed type int __fastcall SSL_CIPHER_get_name(_DWORD);
// 12704: using guessed type int __fastcall SSL_new(_DWORD);
// 1277C: using guessed type int __fastcall BIO_new(_DWORD);
// 127D0: using guessed type int __fastcall SSL_CTX_get_cert_store(_DWORD);
// 12860: using guessed type int BIO_s_mem(void);
// 128B4: using guessed type int __fastcall X509_STORE_add_cert(_DWORD, _DWORD);
// 128D8: using guessed type int __fastcall SSL_connect(_DWORD);
// 12980: using guessed type int __fastcall SSL_free(_DWORD);
// 129E0: using guessed type int __fastcall BIO_write(_DWORD, _DWORD, _DWORD);
// 12A1C: using guessed type int __fastcall SSL_get_peer_certificate(_DWORD);
// 12A28: using guessed type int __fastcall SSL_get_verify_result(_DWORD);
// 12A4C: using guessed type int __fastcall OPENSSL_init_ssl(_DWORD, _DWORD, _DWORD);
// 12A7C: using guessed type int __fastcall SSL_shutdown(_DWORD);
// 12AC4: using guessed type int __fastcall X509_verify_cert_error_string(_DWORD);
// 12B18: using guessed type int __fastcall PEM_read_bio_X509(_DWORD, _DWORD, _DWORD);
// 12B24: using guessed type int __fastcall SSL_CTX_new(_DWORD);
// 12B48: using guessed type int __fastcall BIO_free(_DWORD);
// 12B6C: using guessed type int __fastcall OPENSSL_init_crypto(_DWORD, _DWORD, _DWORD);
// 12BFC: using guessed type int __fastcall X509_free(_DWORD);
// 12C44: using guessed type int __fastcall SSL_get_error(_DWORD, _DWORD);
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 682C4: using guessed type char byte_682C4;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 6A6B0: using guessed type int dword_6A6B0;
// 72D90: using guessed type char byte_72D90;
// 72DBC: using guessed type int dword_72DBC;
// 72EC8: using guessed type char byte_72EC8;
// 762E0: using guessed type char byte_762E0;

//----- (00026020) --------------------------------------------------------
int __fastcall sub_26020(pthread_mutex_t *a1)
{
  int v2; // r5

  if ( a1[27].__size[9] )
    sub_21338(a1);
  if ( sub_24A54(a1) && sub_21DDC(a1) && (!a1[24].__size[4] || sub_27070(a1)) && (v2 = sub_27468(a1)) != 0 )
  {
    sub_2FF84((int)a1);
  }
  else
  {
    v2 = 0;
    sub_31F20((int)a1);
  }
  return v2;
}
// 27070: using guessed type int __fastcall sub_27070(_DWORD);

//----- (000260AC) --------------------------------------------------------
int __fastcall sub_260AC(pthread_mutex_t *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  const char *nusers; // r6
  const char *v6; // r7
  char *v7; // r8
  char *v8; // r1
  _DWORD *v9; // r0
  int v10; // r2
  const char *owner; // r5
  unsigned int v12; // r3
  void *v13; // r0
  void *v14; // r0
  _DWORD *v16; // r0
  int *v17; // r0
  int *v18; // r0
  char s[264]; // [sp+10h] [bp-A2Ch] BYREF
  int v20; // [sp+118h] [bp-924h] BYREF
  char *v21; // [sp+11Ch] [bp-920h] BYREF
  char v22[256]; // [sp+120h] [bp-91Ch] BYREF
  char v23[12]; // [sp+220h] [bp-81Ch] BYREF

  memset(v22, 0, 0xFFu);
  v4 = sub_48E7C(a2, 0);
  nusers = (const char *)sub_49028(v4);
  if ( !nusers )
  {
    nusers = (const char *)a1[25].__nusers;
    goto LABEL_6;
  }
  v6 = (const char *)a1[25].__nusers;
  v7 = strchr(v6, 46);
  if ( !v7 )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request for pool without domain '%s'", v6);
    goto LABEL_20;
  }
  v8 = strchr(nusers, 46);
  if ( !v8 )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request to url without domain '%s'", nusers);
    goto LABEL_20;
  }
  if ( strcmp(v7, v8) )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      return 0;
    snprintf(v23, 0x800u, "Denied stratum reconnect request to non-matching domain url '%s'", v6);
LABEL_20:
    sub_1DD60(3, v23, 0);
    return 0;
  }
LABEL_6:
  v9 = sub_48E7C(a2, 1u);
  v10 = sub_49284((int)v9);
  if ( v10 )
  {
    owner = s;
    sprintf(s, "%d", v10);
  }
  else
  {
    v16 = sub_48E7C(a2, 1u);
    owner = (const char *)sub_49028(v16);
    if ( !owner )
      owner = (const char *)a1[24].__owner;
  }
  snprintf(v22, 0xFEu, "%s:%s", nusers, owner);
  if ( !sub_20A10(v22, &v20, &v21) )
    return 0;
  if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
  {
    snprintf(v23, 0x800u, "Stratum reconnect requested from pool %d to %s", a1->__lock, v22);
    sub_1DD60(4, v23, 0);
  }
  sub_31774(a1);
  if ( pthread_mutex_lock(a1 + 30) )
  {
    v17 = _errno_location();
    snprintf(v23, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v17, "util.c", "parse_reconnect", 2452);
    sub_1DD60(3, v23, 1);
    sub_3C2EC(1);
  }
  sub_1F1EC((int)a1);
  v12 = v20;
  v13 = (void *)a1[25].__nusers;
  a1[24].__lock = v20;
  a1[25].__nusers = v12;
  free(v13);
  v14 = (void *)a1[24].__owner;
  a1[24].__owner = (int)v21;
  free(v14);
  if ( pthread_mutex_unlock(a1 + 30) )
  {
    v18 = _errno_location();
    snprintf(v23, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "util.c", "parse_reconnect", 2461);
    sub_1DD60(3, v23, 1);
    sub_3C2EC(1);
  }
  off_67964();
  return sub_26020(a1);
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00026480) --------------------------------------------------------
int __fastcall sub_26480(pthread_mutex_t *a1, int a2)
{
  double v2; // d0
  _DWORD *v4; // r0
  _DWORD *v5; // r5
  _DWORD *v6; // r7
  _DWORD *v7; // r4
  _DWORD *v8; // r8
  const char *v9; // r0
  const char *v10; // r7
  unsigned int v11; // r4
  union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *i; // r6
  bool v13; // cf
  unsigned int v14; // r1
  _DWORD *v15; // r0
  int v16; // r4
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  const char *v21; // r4
  char *v22; // r0
  int v23; // r0
  int v24; // r0
  size_t v25; // r0
  _DWORD *v26; // r0
  char *v27; // r0
  _DWORD *v28; // r0
  double *v29; // r3
  double v30; // d9
  const char *v31; // r2
  int lock; // r3
  char *v33; // r9
  int v34; // r0
  int v35; // r0
  _DWORD *v36; // r0
  _DWORD *v37; // r0
  _DWORD *v38; // r0
  size_t v39; // r3
  void *owner; // r0
  void *v41; // r0
  int *v42; // r0
  int *v43; // r0
  int *v44; // r0
  int *v45; // r0
  int *v46; // r0
  int v47; // [sp+0h] [bp-211Ch]
  int v48; // [sp+14h] [bp-2108h]
  char v49[92]; // [sp+1Ch] [bp-2100h] BYREF
  char v50[160]; // [sp+78h] [bp-20A4h] BYREF
  char s[8196]; // [sp+118h] [bp-2004h] BYREF

  v4 = sub_47C50(a2, 0, v49);
  v5 = v4;
  if ( v4 )
  {
    v6 = (_DWORD *)sub_48AF4(v4, "method");
    if ( !v6 )
      goto LABEL_14;
    v7 = (_DWORD *)sub_48AF4(v5, "error");
    v8 = (_DWORD *)sub_48AF4(v5, "params");
    if ( v7 && *v7 != 7 )
    {
      v21 = sub_45A6C(v7, 3);
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        snprintf(s, 0x800u, "JSON-RPC method decode failed: %s", v21);
        sub_1DD60(6, s, 0);
      }
      v22 = (char *)v21;
      v16 = 0;
      free(v22);
      goto LABEL_15;
    }
    v9 = (const char *)sub_49028(v6);
    v10 = v9;
    if ( !v9 )
      goto LABEL_14;
    v11 = strncasecmp(v9, "mining.multi_version", 0x14u);
    if ( !v11 )
    {
      a1[27].__size[12] = 1;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        strcpy(s, "Pool support multi version");
        sub_1DD60(6, s, 0);
      }
      for ( i = (union $::__pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95 *)&a1[27].__spins; ; ++i )
      {
        v13 = v11 >= (unsigned int)sub_48E60(v8);
        v14 = v11++;
        if ( v13 )
          break;
        v15 = sub_48E7C(v8, v14);
        i->__spins = sub_49284((int)v15);
      }
      goto LABEL_50;
    }
    if ( !strncasecmp(v10, "mining.notify", 0xDu) )
    {
      v16 = sub_23630((int)a1, v8);
      if ( v16 )
      {
        a1[27].__size[11] = 1;
        goto LABEL_15;
      }
    }
    else
    {
      if ( strncasecmp(v10, "mining.set_version_mask", 0x17u) )
      {
        if ( !strncasecmp(v10, "mining.set_difficulty", 0x15u) )
        {
          v28 = sub_48E7C(v8, 0);
          sub_493C0((int)v28);
          if ( v2 == 0.0 )
            goto LABEL_14;
          if ( pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 212)) )
            sub_1F6D0("parse_diff", 2306);
          if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(&a1[9].__align + 5)) )
          {
            v44 = _errno_location();
            snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v44, "util.c", "parse_diff", 2306);
            sub_1DD60(3, s, 1);
            sub_3C2EC(1);
          }
          v29 = (double *)(&a1[76].__align + 4);
          v30 = *((double *)&a1[76].__align + 1);
          *((double *)&a1[76].__align + 1) = v2;
          if ( v30 <= 0.0 )
          {
            v30 = *v29;
            *v29 = v2;
          }
          if ( pthread_rwlock_unlock((pthread_rwlock_t *)(&a1[9].__align + 5)) )
          {
            v43 = _errno_location();
            snprintf(
              s,
              0x800u,
              "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
              *v43,
              "util.c",
              "parse_diff",
              2319);
            sub_1DD60(3, s, 1);
            sub_3C2EC(1);
          }
          if ( pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 212)) )
          {
            v42 = _errno_location();
            snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v42, "util.c", "parse_diff", 2319);
            sub_1DD60(3, s, 1);
            sub_3C2EC(1);
          }
          off_67964();
          if ( v2 == v30 )
          {
            v16 = (unsigned __int8)byte_686E1;
            if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
            {
              snprintf(s, 0x800u, "Pool %d difficulty set to %f", a1->__lock, v2);
              sub_1DD60(7, s, 0);
              goto LABEL_15;
            }
            goto LABEL_50;
          }
          if ( v2 != (double)(int)v2 )
          {
            if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
            {
              snprintf(s, 0x800u, "Pool %d difficulty changed to %.1f", a1->__lock, v2);
              v16 = 1;
              sub_1DD60(5, s, 0);
              goto LABEL_15;
            }
            goto LABEL_50;
          }
          if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
          {
            v47 = (int)v2;
            v31 = "Pool %d difficulty changed to %d";
            lock = a1->__lock;
LABEL_65:
            v16 = 1;
            snprintf(s, 0x800u, v31, lock, v47);
            sub_1DD60(5, s, 0);
            goto LABEL_15;
          }
        }
        else
        {
          if ( !strncasecmp(v10, "mining.set_extranonce", 0x15u) )
          {
            v33 = sub_1F38C(v8, 0);
            v16 = sub_1F40C(v33, "parse_extranonce", 2349);
            if ( v16 )
            {
              v36 = sub_48E7C(v8, 1u);
              v48 = sub_49284((int)v36);
              if ( !v48 )
              {
                if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
                {
                  strcpy(s, "Failed to get valid n2size in parse_extranonce");
                  sub_1DD60(6, s, 0);
                }
                v16 = 0;
                free(v33);
                goto LABEL_15;
              }
              if ( pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 212)) )
                sub_1F6D0("parse_extranonce", 2361);
              if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(&a1[9].__align + 5)) )
              {
                v46 = _errno_location();
                snprintf(
                  s,
                  0x800u,
                  "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                  *v46,
                  "util.c",
                  "parse_extranonce",
                  2361);
                sub_1DD60(3, s, 1);
                sub_3C2EC(1);
              }
              free((void *)a1[26].__count);
              a1[26].__count = (unsigned int)v33;
              v39 = strlen(v33) >> 1;
              owner = (void *)a1[26].__owner;
              a1[65].__spins = v39;
              free(owner);
              v41 = sub_1F8B0(a1[65].__spins, 1u, "util.c", "parse_extranonce", 2366);
              a1[26].__owner = (int)v41;
              if ( !v41 )
              {
                snprintf(
                  s,
                  0x800u,
                  "Failed to calloc pool->nonce1bin in %s %s():%d",
                  "util.c",
                  "parse_extranonce",
                  2368);
                sub_1DD60(3, s, 1);
                sub_3C2EC(1);
              }
              sub_1FB44((_BYTE *)a1[26].__owner, (unsigned __int8 *)a1[26].__count, a1[65].__spins);
              a1[27].__lock = v48;
              if ( pthread_rwlock_unlock((pthread_rwlock_t *)(&a1[9].__align + 5)) )
              {
                v45 = _errno_location();
                snprintf(
                  s,
                  0x800u,
                  "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                  *v45,
                  "util.c",
                  "parse_extranonce",
                  2371);
                sub_1DD60(3, s, 1);
                sub_3C2EC(1);
              }
              sub_1F654((pthread_mutex_t *)((char *)a1 + 212), "parse_extranonce", 2371);
              off_67964();
              if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
              {
                snprintf(s, 0x800u, "Pool %d extranonce change requested", a1->__lock);
                sub_1DD60(5, s, 0);
                goto LABEL_15;
              }
              goto LABEL_50;
            }
            if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
            {
              strcpy(s, "Failed to get valid nonce1 in parse_extranonce");
              sub_1DD60(6, s, 0);
              goto LABEL_15;
            }
            goto LABEL_14;
          }
          if ( !strncasecmp(v10, "client.reconnect", 0x10u) )
          {
            v16 = sub_260AC(a1, v8);
            goto LABEL_15;
          }
          if ( !strncasecmp(v10, "client.get_version", 0x12u) )
          {
            if ( sub_48AF4(v5, "id") )
            {
              v34 = sub_48AF4(v5, "id");
              v35 = sub_49284(v34);
              sprintf(s, "{\"id\": %d, \"result\": \"cgminer/1.0.0\", \"error\": null}", v35);
              goto LABEL_44;
            }
LABEL_14:
            v16 = 0;
LABEL_15:
            if ( v5[1] != -1 )
            {
              v17 = v5 + 1;
              __dmb(0xBu);
              do
              {
                v18 = __ldrex(v17);
                v19 = v18 - 1;
              }
              while ( __strex(v19, v17) );
              if ( !v19 )
                sub_4942C(v5);
            }
            return v16;
          }
          if ( strncasecmp(v10, "client.show_message", 0x13u) )
          {
            if ( !strncasecmp(v10, "mining.ping", 0xBu) )
            {
              if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
              {
                snprintf(s, 0x800u, "Pool %d ping", a1->__lock);
                sub_1DD60(6, s, 0);
              }
              if ( !sub_48AF4(v5, "id") )
              {
                v16 = 0;
                goto LABEL_15;
              }
              v23 = sub_48AF4(v5, "id");
              v24 = sub_49284(v23);
              sprintf(s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v24);
LABEL_44:
              v25 = strlen(s);
              v16 = sub_2149C(a1, s, v25);
              goto LABEL_15;
            }
            goto LABEL_14;
          }
          if ( !v8 )
            goto LABEL_14;
          if ( *v8 != 1 )
            goto LABEL_14;
          v37 = sub_48E7C(v8, 0);
          v38 = sub_49028(v37);
          if ( !v38 )
            goto LABEL_14;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
          {
            v31 = "Pool %d message: %s";
            v47 = (int)v38;
            lock = a1->__lock;
            goto LABEL_65;
          }
        }
LABEL_50:
        v16 = 1;
        goto LABEL_15;
      }
      v16 = 1;
      v26 = sub_48E7C(v8, 0);
      v27 = (char *)sub_49028(v26);
      sub_20DA8((int)a1, v27);
    }
    a1[27].__size[11] = v16;
    goto LABEL_15;
  }
  if ( byte_72D90 || (v16 = (unsigned __int8)byte_686E0, byte_686E0) || dword_67840 > 5 )
  {
    v16 = 0;
    snprintf(s, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v49, v50);
    sub_1DD60(6, s, 0);
  }
  return v16;
}
// 2692C: variable 'v2' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (0002705C) --------------------------------------------------------
int __fastcall sub_2705C(pthread_mutex_t *a1, int a2)
{
  if ( a2 )
    return sub_26480(a1, a2);
  else
    return 0;
}

//----- (00027070) --------------------------------------------------------
int __fastcall sub_27070(pthread_mutex_t *a1)
{
  int v2; // r2
  size_t v3; // r0
  int v4; // r7
  char *v5; // r5
  _BOOL4 v6; // r6
  _DWORD *v8; // r8
  _DWORD *v9; // r7
  _DWORD *v10; // r0
  _DWORD *v11; // r5
  const char *v12; // r7
  char *v13; // r5
  unsigned int *v14; // r3
  unsigned int v15; // r2
  unsigned int v16; // r2
  char v17[252]; // [sp+Ch] [bp-28FCh] BYREF
  char s[2040]; // [sp+108h] [bp-2800h] BYREF
  char v19[8192]; // [sp+908h] [bp-2000h] BYREF

  v2 = dword_72DBC++;
  sprintf(v19, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v2);
  v3 = strlen(v19);
  v4 = sub_2149C(a1, v19, v3);
  if ( v4 )
  {
    while ( 1 )
    {
      v6 = sub_1F294(a1[24].__kind, 2);
      if ( !v6 )
      {
        if ( byte_686E1 )
        {
          if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
          {
            v4 = (unsigned __int8)byte_686E1;
            strcpy(s, "Timed out waiting for response extranonce.subscribe");
            sub_1DD60(7, s, 0);
          }
          else
          {
            return (unsigned __int8)byte_686E1;
          }
        }
        return v4;
      }
      v5 = sub_21850((int)a1);
      if ( !v5 )
        return 0;
      if ( !sub_26480(a1, (int)v5) )
        break;
      free(v5);
    }
    v8 = sub_47C50((int)v5, 0, v17);
    free(v5);
    v9 = (_DWORD *)sub_48AF4(v8, "result");
    v10 = (_DWORD *)sub_48AF4(v8, "error");
    v11 = v10;
    if ( !v9 || *v9 == 6 )
    {
      if ( !v10 )
      {
        v13 = (char *)malloc(0x11u);
        if ( v13 )
          strcpy(v13, "(unknown reason)");
        goto LABEL_30;
      }
    }
    else if ( !v10 || *v10 == 7 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        v4 = v6;
        snprintf(s, 0x800u, "Stratum extranonce subscribe for pool %d", a1->__lock);
        sub_1DD60(6, s, 0);
        goto LABEL_35;
      }
LABEL_26:
      v4 = v6;
LABEL_35:
      if ( v8 )
      {
        if ( v8[1] != -1 )
        {
          v14 = v8 + 1;
          __dmb(0xBu);
          do
          {
            v15 = __ldrex(v14);
            v16 = v15 - 1;
          }
          while ( __strex(v16, v14) );
          if ( !v16 )
            sub_4942C(v8);
        }
      }
      return v4;
    }
    v12 = (const char *)sub_1F328(v10, 1u);
    if ( !v12 && (v12 = (const char *)sub_49028(v11)) == 0
      || strcmp(v12, "Method 'subscribe' not found for service 'mining.extranonce'")
      && strcmp(v12, "Unrecognized request provided") )
    {
      v13 = sub_45A6C(v11, 3);
LABEL_30:
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        snprintf(s, 0x800u, "Pool %d JSON extranonce subscribe failed: %s", a1->__lock, v13);
        sub_1DD60(6, s, 0);
      }
      v4 = 0;
      free(v13);
      goto LABEL_35;
    }
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      v4 = v6;
      snprintf(s, 0x800u, "Cannot subscribe to mining.extranonce for pool %d", a1->__lock);
      sub_1DD60(6, s, 0);
      goto LABEL_35;
    }
    goto LABEL_26;
  }
  return v4;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 72DBC: using guessed type int dword_72DBC;

//----- (00027468) --------------------------------------------------------
int __fastcall sub_27468(pthread_mutex_t *a1)
{
  const char *count; // r3
  int v3; // r2
  size_t v4; // r0
  int v5; // r9
  int v6; // r6
  char *v7; // r5
  _DWORD *v9; // r8
  _DWORD *v10; // r5
  _DWORD *v11; // r0
  char *v12; // r5
  unsigned int *v13; // r3
  unsigned int v14; // r2
  unsigned int v15; // r2
  int v16; // r3
  int v17; // r2
  size_t v18; // r0
  const char *owner; // [sp+0h] [bp-290Ch]
  char v20[252]; // [sp+Ch] [bp-2900h] BYREF
  char s[2040]; // [sp+108h] [bp-2804h] BYREF
  char v22[8196]; // [sp+908h] [bp-2004h] BYREF

  count = (const char *)a1[7].__count;
  v3 = dword_72DBC;
  owner = (const char *)a1[7].__owner;
  ++dword_72DBC;
  sprintf(v22, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v3, count, owner);
  v4 = strlen(v22);
  v5 = sub_2149C(a1, v22, v4);
  if ( v5 )
  {
    while ( 1 )
    {
      v7 = sub_21850((int)a1);
      if ( !v7 )
        return 0;
      v6 = sub_26480();
      if ( !v6 )
        break;
      free(v7);
    }
    v9 = sub_47C50((int)v7, 0, v20);
    free(v7);
    v10 = (_DWORD *)sub_48AF4(v9, "result");
    v11 = (_DWORD *)sub_48AF4(v9, "error");
    if ( !v10 || *v10 == 6 )
    {
      if ( !v11 )
      {
        v12 = (char *)malloc(0x11u);
        if ( v12 )
          strcpy(v12, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !v11 || *v11 == 7 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        snprintf(s, 0x800u, "Stratum authorisation success for pool %d", a1->__lock);
        sub_1DD60(6, s, 0);
      }
      v16 = dword_761E0;
      byte_686E2 = 1;
      a1[4].__size[3] = 1;
      if ( v16 )
      {
        v17 = dword_72DBC;
        v6 = v5;
        ++dword_72DBC;
        sprintf(v22, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v17, v16);
        v18 = strlen(v22);
        sub_2149C(a1, v22, v18);
      }
      else
      {
        v6 = v5;
      }
      goto LABEL_17;
    }
    v12 = sub_45A6C(v11, 3);
LABEL_13:
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      snprintf(s, 0x800u, "pool %d JSON stratum auth failed: %s", a1->__lock, v12);
      sub_1DD60(6, s, 0);
    }
    free(v12);
    sub_21338(a1);
LABEL_17:
    if ( v9 )
    {
      if ( v9[1] != -1 )
      {
        v13 = v9 + 1;
        __dmb(0xBu);
        do
        {
          v14 = __ldrex(v13);
          v15 = v14 - 1;
        }
        while ( __strex(v15, v13) );
        if ( !v15 )
          sub_4942C(v9);
      }
    }
    return v6;
  }
  return 0;
}
// 26480: using guessed type int sub_26480(void);
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E2: using guessed type char byte_686E2;
// 72D90: using guessed type char byte_72D90;
// 72DBC: using guessed type int dword_72DBC;
// 761E0: using guessed type int dword_761E0;

//----- (00027758) --------------------------------------------------------
int __fastcall sub_27758(int *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // r12
  int v4; // r3

  if ( *a2 > *a3 )
    return -1;
  if ( *a2 == *a3 && a2[1] > a3[1] )
    return -1;
  v3 = *a3 - *a2;
  *a1 = v3;
  v4 = a3[1] - a2[1];
  a1[1] = v4;
  if ( v4 < 0 )
  {
    *a1 = v3 - 1;
    a1[1] = v4 + 1000000;
  }
  return 0;
}

//----- (000277D4) --------------------------------------------------------
_BYTE *__fastcall sub_277D4(_BYTE *result, int a2)
{
  _BYTE *v2; // r12
  unsigned int v3; // r3
  char v4; // lr
  char v5; // t1
  char v6; // t1

  if ( a2 != 1 )
  {
    v2 = result - 1;
    v3 = 0;
    result += a2;
    do
    {
      ++v3;
      v5 = *++v2;
      v4 = v5;
      v6 = *--result;
      *v2 = v6;
      *result = v4;
    }
    while ( v3 < ~v3 + a2 );
  }
  return result;
}

//----- (00027814) --------------------------------------------------------
int __fastcall sub_27814(int result, char a2)
{
  unsigned int v2; // r1
  unsigned int v3; // r1
  int v4; // r1
  unsigned int v5; // r1
  unsigned int v6; // r1

  switch ( result )
  {
    case 1:
      return result;
    case 2:
      if ( (a2 & 0x80) != 0x80 )
        result = 1;
      break;
    case 4:
      v4 = a2 & 0xC0;
      if ( v4 == 128 )
        goto LABEL_29;
      if ( v4 != 192 )
      {
        if ( v4 == 64 )
          result = 2;
        else
          result = 1;
      }
      break;
    case 8:
      v5 = a2 & 0xE0;
      if ( v5 == 128 )
        goto LABEL_50;
      if ( v5 <= 0x80 )
      {
        if ( v5 == 64 )
          goto LABEL_29;
        if ( v5 == 96 )
          goto LABEL_49;
        if ( v5 != 32 )
          goto LABEL_9;
        goto LABEL_25;
      }
      if ( v5 == 192 )
        goto LABEL_48;
      if ( v5 != 224 )
      {
        if ( v5 != 160 )
          goto LABEL_9;
        goto LABEL_39;
      }
      break;
    case 16:
      v2 = a2 & 0xF0;
      if ( v2 == 128 )
      {
        result = 9;
      }
      else if ( v2 > 0x80 )
      {
        if ( v2 == 192 )
        {
          result = 13;
        }
        else if ( v2 <= 0xC0 )
        {
          switch ( v2 )
          {
            case 0xA0u:
              result = 11;
              break;
            case 0xB0u:
              result = 12;
              break;
            case 0x90u:
              result = 10;
              break;
            default:
              goto LABEL_9;
          }
        }
        else if ( v2 == 224 )
        {
          result = 15;
        }
        else if ( v2 != 240 )
        {
          if ( v2 != 208 )
            goto LABEL_9;
          result = 14;
        }
      }
      else if ( v2 == 64 )
      {
LABEL_50:
        result = 5;
      }
      else if ( v2 > 0x40 )
      {
        switch ( v2 )
        {
          case '`':
LABEL_48:
            result = 7;
            break;
          case 'p':
            result = 8;
            break;
          case 'P':
LABEL_39:
            result = 6;
            break;
          default:
            goto LABEL_9;
        }
      }
      else
      {
        switch ( v2 )
        {
          case 0x20u:
LABEL_29:
            result = 3;
            break;
          case 0x30u:
LABEL_49:
            result = 4;
            break;
          case 0x10u:
LABEL_25:
            result = 2;
            break;
          default:
            goto LABEL_9;
        }
      }
      break;
    case 32:
      v6 = (unsigned __int8)((a2 & 0xF8) - 8);
      if ( v6 > 0xF0 )
        goto LABEL_9;
      result = *((char *)&unk_4C28C + v6 + 2004);
      break;
    case 64:
      v3 = (unsigned __int8)((a2 & 0xFC) - 4);
      if ( v3 > 0xF8 )
LABEL_9:
        result = 1;
      else
        result = *((char *)&unk_4C28C + v3 + 2248);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 27820: control flows out of bounds to 27824

//----- (00027AFC) --------------------------------------------------------
void __fastcall sub_27AFC(int a1, char *a2, int a3)
{
  int v5; // r0
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // lr
  _DWORD *v14; // r12
  int v15; // r1
  int v16; // r2
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r3
  char v23; // r3
  char v24; // t1
  char v25; // t1
  char *v26; // r2
  _DWORD *v27; // r3
  char v28; // t1
  char v29; // r1
  _DWORD *v30; // r3
  char *v31; // r2
  char v32; // r1
  char v33; // t1
  char v34; // t1
  const char *v35; // r5
  char *v36; // r8
  char *v37; // r7
  char *v38; // r9
  char *v39; // r6
  unsigned int v40; // r0
  int v41; // r1
  size_t v42; // r0
  int v43; // r4
  size_t v44; // r0
  unsigned __int64 v45; // r2
  int i; // r4
  size_t v47; // r0
  size_t v48; // r0
  char *ptr; // [sp+20h] [bp-C7Ch]
  char *v51; // [sp+28h] [bp-C74h]
  __int64 v52; // [sp+2Ch] [bp-C70h]
  char *v53; // [sp+34h] [bp-C68h] BYREF
  _DWORD v54[3]; // [sp+38h] [bp-C64h] BYREF
  _DWORD v55[5]; // [sp+44h] [bp-C58h] BYREF
  int v56; // [sp+58h] [bp-C44h] BYREF
  _DWORD v57[2]; // [sp+5Ch] [bp-C40h] BYREF
  _DWORD v58[4]; // [sp+64h] [bp-C38h] BYREF
  int v59; // [sp+74h] [bp-C28h] BYREF
  _DWORD v60[3]; // [sp+78h] [bp-C24h] BYREF
  _DWORD v61[5]; // [sp+84h] [bp-C18h] BYREF
  char s[1024]; // [sp+98h] [bp-C04h] BYREF
  char v63[2052]; // [sp+498h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  v5 = *(_DWORD *)(a1 + 128);
  memset(v58, 0, sizeof(v58));
  v6 = *(_DWORD *)(a1 + 132);
  v7 = *(_DWORD *)(a1 + 136);
  v8 = *(_DWORD *)(a1 + 140);
  v54[0] = v5;
  v54[1] = v6;
  v54[2] = v7;
  v55[0] = v8;
  v9 = *(_DWORD *)(a1 + 144);
  v10 = *(_DWORD *)(a1 + 148);
  v11 = *(_DWORD *)(a1 + 152);
  v12 = *(_DWORD *)(a1 + 156);
  v13 = &v56;
  v59 = 0;
  v55[1] = v9;
  v55[2] = v10;
  v55[3] = v11;
  v55[4] = v12;
  v14 = (char **)((char *)&v53 + 3);
  v15 = *(_DWORD *)(a1 + 68);
  v16 = *(_DWORD *)(a1 + 72);
  v56 = *(_DWORD *)(a1 + 64);
  v57[0] = v15;
  v57[1] = v16;
  v17 = *(_DWORD *)(a1 + 196);
  v18 = *(_DWORD *)(a1 + 200);
  v19 = *(_DWORD *)(a1 + 204);
  v60[0] = *(_DWORD *)(a1 + 192);
  v60[1] = v17;
  v60[2] = v18;
  v61[0] = v19;
  v20 = *(_DWORD *)(a1 + 212);
  v21 = *(_DWORD *)(a1 + 216);
  v22 = *(_DWORD *)(a1 + 220);
  v61[1] = *(_DWORD *)(a1 + 208);
  v61[2] = v20;
  v61[3] = v21;
  v61[4] = v22;
  do
  {
    v24 = *((_BYTE *)v14 + 1);
    v14 = (_DWORD *)((char *)v14 + 1);
    v23 = v24;
    v25 = *((_BYTE *)v13 - 1);
    v13 = (int *)((char *)v13 - 1);
    *(_BYTE *)v14 = v25;
    *(_BYTE *)v13 = v23;
  }
  while ( v14 != (_DWORD *)((char *)v55 + 3) );
  v26 = (char *)&v56;
  v27 = v58;
  do
  {
    v28 = *((_BYTE *)v27 - 1);
    v27 = (_DWORD *)((char *)v27 - 1);
    v29 = *v26;
    *v26++ = v28;
    *(_BYTE *)v27 = v29;
  }
  while ( (_DWORD *)((char *)v57 + 2) != v27 );
  v30 = (int *)((char *)&v59 + 3);
  v31 = s;
  do
  {
    v33 = *((_BYTE *)v30 + 1);
    v30 = (_DWORD *)((char *)v30 + 1);
    v32 = v33;
    v34 = *--v31;
    *(_BYTE *)v30 = v34;
    *v31 = v32;
  }
  while ( v30 != (_DWORD *)((char *)v61 + 3) );
  ptr = sub_1FA90(a1, 128);
  v35 = "o";
  v36 = sub_1FA90((int)v54, 32);
  v37 = sub_1FA90((int)&v56, 12);
  v51 = sub_1FA90((int)a2, 4);
  v38 = sub_1FA90((int)a2, 5);
  v39 = sub_1FA90((int)v60, 32);
  v40 = sub_2A954((__int64 *)a1);
  HIDWORD(v52) = v41;
  if ( !a3 )
    v35 = "x";
  LODWORD(v52) = v40;
  sprintf(
    s,
    "%s %08x midstate %s data %s nonce %s hash %s diff %lld",
    v35,
    *(_DWORD *)(a1 + 340),
    v36,
    v37,
    v38,
    v39,
    v40,
    v41);
  if ( !strcmp((const char *)dword_688F0, "screen") )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(v63, 0x800u, s);
      sub_1DD60(3, v63, 0);
    }
  }
  else
  {
    v53 = &byte_72D90;
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(v63, 0x800u, s);
      sub_1DD60(3, v63, 0);
    }
    if ( dword_6A488 )
    {
      sprintf(
        s,
        "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
        v35,
        *(_DWORD *)(a1 + 340),
        ptr,
        v36,
        v37,
        v38,
        v39,
        v52);
      v42 = strlen(s);
      fwrite(s, v42, 1u, (FILE *)dword_6A488);
      fwrite(&word_4C1E4, 1u, 1u, (FILE *)dword_6A488);
      fflush((FILE *)dword_6A488);
      if ( a3 )
      {
        if ( dword_6A484 == 1 )
        {
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v51, v39);
          v48 = strlen(s);
          fwrite(s, v48, 1u, (FILE *)dword_6A48C[0]);
          fwrite(&word_4C1E4, 1u, 1u, (FILE *)dword_6A48C[0]);
          fflush((FILE *)dword_6A48C[0]);
        }
        else if ( ((dword_6A484 - 32) & 0xFFFFFFDF) == 0 )
        {
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v51, v39);
          v43 = sub_27814(dword_6A484, *a2);
          v44 = strlen(s);
          fwrite(s, v44, 1u, (FILE *)dword_6A48C[v43]);
          fwrite(&word_4C1E4, 1u, 1u, (FILE *)dword_6A48C[v43]);
          fflush((FILE *)dword_6A48C[v43]);
        }
        if ( byte_6A590 )
        {
          v45 = v52;
          for ( i = 0; i != 64; ++i )
          {
            v45 >>= 1;
            if ( !v45 )
              break;
          }
          if ( byte_686E1 && (*v53 || byte_686E0 || dword_67840 > 6) )
          {
            snprintf(v63, 0x800u, "work diff %lld diffnum %d", v52, i);
            sub_1DD60(7, v63, 0);
          }
          sprintf(s, "midstate %s data %s nonce %s hash %s", v36, v37, v51, v39);
          v47 = strlen(s);
          fwrite(s, v47, 1u, *((FILE **)&unk_6A594 + i));
          fwrite(&word_4C1E4, 1u, 1u, *((FILE **)&unk_6A594 + i));
          fflush(*((FILE **)&unk_6A594 + i));
        }
      }
    }
  }
  if ( ptr )
    free(ptr);
  if ( v36 )
    free(v36);
  if ( v37 )
    free(v37);
  if ( v51 )
    free(v51);
  if ( v38 )
    free(v38);
  if ( v39 )
    free(v39);
}
// 27CA4: variable 'v41' is possibly undefined
// 4C1E4: using guessed type __int16 word_4C1E4;
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 688F0: using guessed type int dword_688F0;
// 6A484: using guessed type int dword_6A484;
// 6A488: using guessed type int dword_6A488;
// 6A48C: using guessed type int dword_6A48C[65];
// 6A590: using guessed type char byte_6A590;
// 72D90: using guessed type char byte_72D90;

//----- (0002811C) --------------------------------------------------------
void __fastcall sub_2811C(int a1, char *a2, int a3)
{
  if ( dword_688F0 )
    sub_27AFC(a1, a2, a3);
}
// 688F0: using guessed type int dword_688F0;

//----- (00028134) --------------------------------------------------------
void __fastcall sub_28134(int a1, int a2, int a3)
{
  int v3; // [sp+0h] [bp-10h] BYREF
  char v4; // [sp+4h] [bp-Ch]

  if ( dword_688F0 )
  {
    v3 = a2;
    v4 = 0;
    sub_27AFC(a1, (char *)&v3, a3);
  }
}
// 688F0: using guessed type int dword_688F0;

//----- (000282A4) --------------------------------------------------------
int __fastcall sub_282A4(int result, unsigned int *a2, unsigned int a3)
{
  unsigned int v3; // r2
  unsigned int *v4; // r2
  unsigned int v5; // t1

  v3 = a3 >> 2;
  if ( v3 )
  {
    v4 = &a2[v3];
    result -= 4;
    do
    {
      v5 = *a2++;
      *(_DWORD *)(result + 4) = bswap32(v5);
      result += 4;
    }
    while ( a2 != v4 );
  }
  return result;
}

//----- (000282D0) --------------------------------------------------------
int __fastcall sub_282D0(_DWORD *a1)
{
  *a1 = 4;
  return 0;
}

//----- (000282E0) --------------------------------------------------------
int __fastcall sub_282E0(_DWORD *a1)
{
  *a1 = 3;
  return 0;
}

//----- (000282F0) --------------------------------------------------------
int __fastcall sub_282F0(_DWORD *a1)
{
  *a1 = 1;
  return 0;
}

//----- (00028300) --------------------------------------------------------
int __fastcall sub_28300(_BYTE *a1)
{
  *a1 = 1;
  byte_686E0 = 1;
  return 0;
}
// 686E0: using guessed type char byte_686E0;

//----- (0002831C) --------------------------------------------------------
int sub_2831C()
{
  return 0;
}

//----- (0002832C) --------------------------------------------------------
int sub_2832C()
{
  return 1;
}

//----- (00028334) --------------------------------------------------------
__int64 sub_28334()
{
  return 0xFFFFFFFFLL;
}

//----- (00028340) --------------------------------------------------------
int sub_28340()
{
  return 1;
}

//----- (0002834C) --------------------------------------------------------
int sub_2834C()
{
  return 0;
}

//----- (00028354) --------------------------------------------------------
int __fastcall sub_28354(int result)
{
  *(_QWORD *)(result + 208) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_QWORD *)(result + 200) = 0;
  return result;
}

//----- (00028370) --------------------------------------------------------
void __noreturn sub_28370(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vsnprintf(byte_686E8, 0x200u, a1, varg_r1);
  sub_1DD60(3, byte_686E8, 1);
  exit(1);
}

//----- (000283B8) --------------------------------------------------------
int __fastcall sub_283B8(int a1)
{
  sub_3E5BC(a1, &dword_688E8);
  return 0;
}
// 688E8: using guessed type int dword_688E8;

//----- (000283D0) --------------------------------------------------------
int __fastcall sub_283D0(int a1)
{
  sub_3E5BC(a1, &dword_688EC);
  return 0;
}
// 688EC: using guessed type int dword_688EC;

//----- (000283E8) --------------------------------------------------------
int __fastcall sub_283E8(int a1)
{
  sub_3E5BC(a1, &dword_688F0);
  return 0;
}
// 688F0: using guessed type int dword_688F0;

//----- (00028400) --------------------------------------------------------
int __fastcall sub_28400(int a1)
{
  sub_3E5BC(a1, &dword_688F4);
  return 0;
}
// 688F4: using guessed type int dword_688F4;

//----- (00028418) --------------------------------------------------------
int __fastcall sub_28418(int a1)
{
  sub_3E5BC(a1, &dword_688F8);
  return 0;
}
// 688F8: using guessed type int dword_688F8;

//----- (00028430) --------------------------------------------------------
int __fastcall sub_28430(int a1)
{
  sub_3E5BC(a1, dword_74FFC);
  return 0;
}
// 74FFC: using guessed type int dword_74FFC[3];

//----- (00028448) --------------------------------------------------------
_BYTE *__fastcall sub_28448(const char *a1)
{
  const char *v1; // r4
  size_t v2; // r0
  _BYTE *v3; // r5
  _DWORD *v4; // r0
  int v5; // r2
  _BYTE *v6; // r2
  int i; // r3
  bool v8; // zf
  _BYTE *v9; // r3
  char v10; // t1

  v1 = a1;
  v2 = strlen(a1);
  v3 = sub_1F828(2 * v2 + 1, "cgminer.c", "json_escape", 5991);
  v4 = sub_1F828(8u, "cgminer.c", "json_escape", 5992);
  *v4 = v3;
  v5 = dword_688FC;
  dword_688FC = (int)v4;
  v4[1] = v5;
  v6 = v3;
  for ( i = *(unsigned __int8 *)v1; *v1; i = *(unsigned __int8 *)v1 )
  {
    v8 = i == 34;
    if ( i != 34 )
      v8 = i == 92;
    v9 = v6 + 1;
    if ( v8 )
    {
      *v6 = 92;
      v6 += 2;
    }
    else
    {
      v9 = v6++;
    }
    v10 = *v1++;
    *v9 = v10;
  }
  *v6 = 0;
  return v3;
}
// 688FC: using guessed type int dword_688FC;

//----- (00028714) --------------------------------------------------------
void __fastcall __noreturn sub_28714(const char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_c5 mining support.\n", s);
  v2 = sub_3F558((const char *)dword_762F8, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 68594: using guessed type int stdout;
// 762F8: using guessed type int dword_762F8;

//----- (0002876C) --------------------------------------------------------
time_t __fastcall sub_2876C(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 1;
  sub_206A0((__time_t *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (000287A4) --------------------------------------------------------
time_t __fastcall sub_287A4(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 0;
  sub_206A0((__time_t *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (000287D8) --------------------------------------------------------
int __fastcall sub_287D8(unsigned __int64 a1, char *s, size_t maxlen, int a4)
{
  double v6; // d8
  int v8; // r1
  double v9; // r0
  __int16 v10; // [sp+1Ch] [bp-4h] BYREF

  v10 = 0;
  if ( a1 <= 0xDE0B6B3A763FFFFLL )
  {
    if ( a1 <= 0x38D7EA4C67FFFLL )
    {
      if ( a1 > 0xE8D4A50FFFLL )
      {
        LODWORD(a1) = sub_4AB70(a1, 0x3B9ACA00u);
        v10 = 84;
        v6 = (double)(int)a1 / 1000.0;
        if ( !a4 )
          return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
      }
      else if ( a1 <= 0x3B9AC9FF )
      {
        if ( a1 > 0xF423F )
        {
          LODWORD(a1) = sub_4AB70(a1, 0x3E8u);
          v10 = 77;
          v6 = (double)(int)a1 / 1000.0;
          if ( !a4 )
            return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
        }
        else
        {
          v6 = (double)(int)a1;
          if ( a1 <= 0x3E7 )
          {
            if ( !a4 )
              return snprintf(s, maxlen, "%d%s", (_DWORD)a1, (const char *)&v10);
          }
          else
          {
            v10 = 75;
            v6 = v6 / 1000.0;
            if ( !a4 )
              return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
          }
        }
      }
      else
      {
        LODWORD(a1) = sub_4AB70(a1, 0xF4240u);
        v10 = 71;
        v6 = (double)(int)a1 / 1000.0;
        if ( !a4 )
          return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
      }
    }
    else
    {
      LODWORD(a1) = sub_4AB70(a1, 0xE8D4A51000uLL);
      v10 = 80;
      v6 = (double)(int)a1 / 1000.0;
      if ( !a4 )
        return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
    }
  }
  else
  {
    LODWORD(a1) = sub_4AB70(a1, 0x38D7EA4C68000uLL);
    v10 = 69;
    v6 = (double)(int)a1 / 1000.0;
    if ( !a4 )
      return snprintf(s, maxlen, "%.3g%s", v6, (const char *)&v10);
  }
  if ( v6 > 0.0 )
  {
    v9 = log10(*(double *)&a1);
    floor(v9);
    v8 = (int)(3.0 - v6);
  }
  else
  {
    v8 = 3;
  }
  return snprintf(s, maxlen, "%*.*f%s", a4 + 1, v8, v6, (const char *)&v10);
}
// 28994: variable 'a1' is possibly undefined

//----- (00028A90) --------------------------------------------------------
int __fastcall sub_28A90(int a1)
{
  double v1; // d0
  int v3; // r4
  double v4; // d8
  unsigned __int64 v5; // r0
  int result; // r0
  double v7; // d7
  double v8; // d7
  double v9; // r0
  double v10; // d8
  double v11; // r0
  double v12; // d8
  double v13; // r0
  double v14; // d8
  double v15; // r0
  double v16; // d7

  v3 = *(_DWORD *)(a1 + 260);
  if ( v1 == 0.0 )
  {
    LODWORD(v9) = sub_4AB04(*(_QWORD *)(a1 + 184));
    v10 = v9 * 6.27710174e57;
    LODWORD(v11) = sub_4AB04(*(_QWORD *)(a1 + 176));
    v12 = v10 + v11 * 3.40282367e38;
    LODWORD(v13) = sub_4AB04(*(_QWORD *)(a1 + 168));
    v14 = v12 + v13 * 1.84467441e19;
    LODWORD(v15) = sub_4AB04(*(_QWORD *)(a1 + 160));
    v16 = v15 + v14;
    if ( v15 + v14 == 0.0 )
    {
      v4 = 2.69595353e67;
      v5 = -1;
    }
    else
    {
      v4 = 2.69595353e67 / v16;
      round();
      LODWORD(v5) = sub_4ABD0(2.69595353e67 / v16);
    }
    *(double *)(a1 + 376) = v4;
  }
  else
  {
    *(double *)(a1 + 376) = v1;
    v4 = v1;
    round();
    LODWORD(v5) = sub_4ABD0(v1);
  }
  *(double *)(v3 + 480) = v4;
  result = sub_287D8(v5, (char *)(*(_DWORD *)(a1 + 260) + 48), 8u, 0);
  v7 = *(double *)(v3 + 464);
  if ( v7 == v4 )
  {
    ++*(_DWORD *)(v3 + 488);
    goto LABEL_5;
  }
  if ( v7 <= v4 )
  {
    if ( v7 != 0.0 )
    {
LABEL_5:
      v8 = *(double *)(v3 + 472);
      if ( v8 != v4 )
        goto LABEL_6;
LABEL_15:
      ++*(_DWORD *)(v3 + 492);
      return result;
    }
    *(double *)(v3 + 464) = v4;
    *(_DWORD *)(v3 + 488) = 1;
  }
  else
  {
    *(double *)(v3 + 464) = v4;
    *(_DWORD *)(v3 + 488) = 1;
  }
  v8 = *(double *)(v3 + 472);
  if ( v8 == v4 )
    goto LABEL_15;
LABEL_6:
  if ( v8 < v4 )
  {
    *(double *)(v3 + 472) = v4;
    *(_DWORD *)(v3 + 492) = 1;
  }
  return result;
}
// 28AAC: variable 'v1' is possibly undefined
// 28ADC: variable 'v5' is possibly undefined
// 28B40: variable 'v9' is possibly undefined
// 28B54: variable 'v11' is possibly undefined
// 28B68: variable 'v13' is possibly undefined
// 28B74: variable 'v15' is possibly undefined
// 12770: using guessed type int round(void);

//----- (00028C30) --------------------------------------------------------
int __fastcall sub_28C30(int a1)
{
  int v2; // r1
  char *v3; // r2
  unsigned int v4; // t1
  char v6[28]; // [sp+0h] [bp-70h] BYREF
  char v7; // [sp+1Ch] [bp-54h] BYREF
  char v8[76]; // [sp+20h] [bp-50h] BYREF
  char v9; // [sp+6Ch] [bp-4h] BYREF

  v2 = a1 - 4;
  v3 = &v7;
  do
  {
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    *((_DWORD *)v3 + 1) = bswap32(v4);
    v3 += 4;
  }
  while ( v3 != &v9 );
  sub_1EA3C(v8, 0x50u, v6);
  return sub_1EA3C(v6, 0x20u, (_BYTE *)(a1 + 192));
}

//----- (00028C84) --------------------------------------------------------
void __fastcall sub_28C84(int a1)
{
  int v2; // r1
  int *v3; // r2
  unsigned int v4; // t1
  int v5; // [sp+4h] [bp-ECh] BYREF
  char v6[60]; // [sp+8h] [bp-E8h] BYREF
  char v7; // [sp+44h] [bp-ACh] BYREF
  _DWORD v8[34]; // [sp+48h] [bp-A8h] BYREF
  _BYTE v9[32]; // [sp+D0h] [bp-20h] BYREF

  v2 = a1 - 4;
  v3 = &v5;
  do
  {
    v4 = *(_DWORD *)(v2 + 4);
    v2 += 4;
    v3[1] = bswap32(v4);
    ++v3;
  }
  while ( v3 != (int *)&v7 );
  sub_1E874(v8);
  sub_1E8A4((unsigned __int8 *)v8, v6, 0x40u);
  sub_232EC((void *)(a1 + 128), v9, 0x20u, (int)"cgminer.c", (int)"calc_midstate", 2320);
}

//----- (00028CFC) --------------------------------------------------------
void sub_28CFC()
{
  int v0; // r4
  int v1; // r3
  const pthread_attr_t *v2; // r1
  char v3[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_72E60 > 0 )
  {
    v0 = 0;
    do
    {
      while ( 1 )
      {
        v1 = *(_DWORD *)(dword_72F04 + 4 * v0);
        if ( !*(_BYTE *)(v1 + 284) )
        {
          v2 = (const pthread_attr_t *)(unsigned __int8)byte_68A04;
          if ( !byte_68A04 )
          {
            *(_BYTE *)(v1 + 284) = 1;
            pthread_create((pthread_t *)(v1 + 280), v2, (void *(*)(void *))sub_33090, (void *)v1);
            if ( byte_686E1 )
            {
              if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
                break;
            }
          }
        }
        if ( dword_72E60 <= ++v0 )
          return;
      }
      snprintf(v3, 0x800u, "create test_pool_thread pool[%d]\n");
      ++v0;
      sub_1DD60(7, v3, 0);
    }
    while ( dword_72E60 > v0 );
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68A04: using guessed type char byte_68A04;
// 72D90: using guessed type char byte_72D90;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (00028E18) --------------------------------------------------------
int sub_28E18()
{
  pthread_t v0; // r0

  v0 = pthread_self();
  pthread_detach(v0);
  return 0;
}

//----- (00028E2C) --------------------------------------------------------
int __fastcall sub_28E2C(int a1)
{
  _DWORD *v1; // r6
  int v3; // r5
  char v5[16]; // [sp+0h] [bp-810h] BYREF
  char v6[2048]; // [sp+10h] [bp-800h] BYREF

  v1 = *(_DWORD **)(a1 + 36);
  v3 = v1[1];
  snprintf(v5, 0x10u, "%d/Miner", *(_DWORD *)a1);
  sub_22E98(v5);
  sub_2876C(a1);
  if ( (*(int (__fastcall **)(int))(v3 + 52))(a1) )
  {
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      strcpy(v6, "Waiting on sem in miner thread");
      sub_1DD60(7, v6, 0);
    }
    sub_23018((sem_t *)(a1 + 16), "cgminer.c", "miner_thread", 9891);
    v1[58] = time(0);
    (*(void (__fastcall **)(int))(v3 + 60))(a1);
    (*(void (__fastcall **)(int))(v3 + 88))(a1);
    return 0;
  }
  else
  {
    sub_22BB4(v1, 0);
    return 0;
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (00028F68) --------------------------------------------------------
void __noreturn sub_28F68()
{
  pthread_t v0; // r0

  v0 = pthread_self();
  pthread_detach(v0);
  pthread_setcanceltype(1, 0);
  sleep(7u);
  exit(1);
}

//----- (00028F90) --------------------------------------------------------
_DWORD *__fastcall sub_28F90(_DWORD *result)
{
  ++dword_74F24;
  *result = 1;
  return result;
}
// 74F24: using guessed type int dword_74F24;

//----- (00028FB0) --------------------------------------------------------
int __fastcall sub_28FB0(unsigned __int8 *a1)
{
  int v1; // r3

  v1 = a1[656];
  if ( a1[656] && a1[657] )
    return a1[659] ^ 1;
  return v1;
}

//----- (00028FD4) --------------------------------------------------------
int __fastcall sub_28FD4(int a1)
{
  int v1; // r7
  int v2; // r5
  int *v3; // r4
  int v4; // r6
  int v5; // r1
  int v6; // t1
  int v7; // r1

  v1 = *(_DWORD *)(a1 + 156);
  v2 = a1;
  if ( dword_72E60 > 0 )
  {
    v3 = (int *)dword_72F04;
    v4 = dword_72F04 + 4 * dword_72E60;
    do
    {
      v6 = *v3++;
      v5 = v6;
      if ( !*(_BYTE *)(v6 + 97)
        && *(_DWORD *)(v5 + 100) == 1
        && !sub_28FB0((unsigned __int8 *)v5)
        && *(_DWORD *)(v7 + 156) < v1 )
      {
        v2 = v7;
        v1 = *(_DWORD *)(v7 + 156);
      }
    }
    while ( v3 != (int *)v4 );
    v1 = *(_DWORD *)(v2 + 156);
  }
  *(_DWORD *)(v2 + 156) = v1 + 1;
  return v2;
}
// 29030: variable 'v7' is possibly undefined
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (0002905C) --------------------------------------------------------
int __fastcall sub_2905C(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(v3, 0x800u, "WTF No pool %d found!", a1);
    sub_1DD60(3, v3, 0);
  }
  return *(_DWORD *)(dword_72F04 + 4 * a1);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 72F04: using guessed type int dword_72F04;

//----- (000290E8) --------------------------------------------------------
int __fastcall sub_290E8(int a1)
{
  int v1; // r2
  int v2; // r1
  int v3; // r3
  int v4; // t1

  if ( dword_72E60 <= 0 )
    return sub_2905C(a1);
  v1 = dword_72F04;
  v2 = *(_DWORD *)dword_72F04;
  if ( *(_DWORD *)(*(_DWORD *)dword_72F04 + 4) != a1 )
  {
    v3 = 0;
    while ( ++v3 != dword_72E60 )
    {
      v4 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      v2 = v4;
      if ( *(_DWORD *)(v4 + 4) == a1 )
        return v2;
    }
    return sub_2905C(a1);
  }
  return v2;
}
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (00029150) --------------------------------------------------------
const char *__fastcall sub_29150(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_74F3C, &dword_74F38) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_74F3C > 0x17 || (unsigned int)dword_74F38 > 0x3B )
    return "Invalid time set.";
  byte_74F30 = 1;
  return 0;
}
// 74F30: using guessed type char byte_74F30;
// 74F38: using guessed type int dword_74F38;
// 74F3C: using guessed type int dword_74F3C;

//----- (000291BC) --------------------------------------------------------
char *__fastcall sub_291BC(char *a1)
{
  bool v2; // nf
  _DWORD *v4; // r0
  size_t v5; // r6
  size_t v6; // r6
  char *v7; // r4
  char v8[92]; // [sp+Ch] [bp-100h] BYREF
  char v9[164]; // [sp+68h] [bp-A4h] BYREF

  if ( !dword_68A08 )
    dword_68A08 = (int)_strdup(a1);
  v2 = dword_68A0C - 9 < 0;
  ++dword_68A0C;
  if ( !(v2 ^ __OFSUB__(dword_68A0C, 10) | (dword_68A0C == 10)) )
    return "Too many levels of JSON includes (limit 10) or a loop";
  v4 = sub_47FA8(a1, 0, v8);
  if ( v4 && !*v4 )
  {
    byte_68A10 = 1;
    return sub_292B8(v4, 1);
  }
  else
  {
    v5 = strlen(a1);
    v6 = v5 + strlen(v9) + 35;
    v7 = (char *)sub_1F828(v6, "cgminer.c", "load_config", 2187);
    snprintf(v7, v6, "JSON decode of file '%s' failed\n %s", a1, v9);
    return v7;
  }
}
// 68A08: using guessed type int dword_68A08;
// 68A0C: using guessed type int dword_68A0C;
// 68A10: using guessed type char byte_68A10;

//----- (000292B8) --------------------------------------------------------
char *__fastcall sub_292B8(_DWORD *a1, int a2)
{
  _DWORD *v3; // r4
  int v4; // r3
  const char *v5; // r0
  char *v6; // r10
  char *v7; // r5
  _DWORD *v8; // r0
  int v9; // r1
  int v10; // r3
  const char *v11; // r3
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _BYTE *v15; // r0
  int v16; // r0
  _DWORD *v17; // r10
  unsigned int v18; // r5
  _DWORD *v19; // r0
  int v20; // r0
  _DWORD *v22; // [sp+10h] [bp-814h]
  char *v23; // [sp+10h] [bp-814h]
  const char *v24; // [sp+14h] [bp-810h]
  char *v25; // [sp+14h] [bp-810h]
  _DWORD *v26; // [sp+18h] [bp-80Ch]
  const char *v27; // [sp+1Ch] [bp-808h]
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( a2 && !dword_68ADC )
    dword_68ADC = 1;
  if ( dword_67A6C == 16 )
    goto LABEL_28;
  if ( (dword_67A6C & 8) != 0 )
LABEL_53:
    _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x7E3u, "parse_config");
  v3 = &unk_67A84;
  while ( 1 )
  {
    v5 = (const char *)*(v3 - 7);
    if ( !v5 )
    {
      v4 = v3[1];
      if ( v4 == 16 )
        break;
      goto LABEL_8;
    }
    v6 = _strdup(v5);
    v7 = strtok(v6, "|");
    if ( !v7 )
      goto LABEL_27;
    while ( 2 )
    {
      if ( v7[1] != 45 )
        goto LABEL_12;
      v8 = (_DWORD *)sub_48AF4(a1, v7 + 2);
      if ( !v8 )
        goto LABEL_12;
      v9 = *(v3 - 6);
      v10 = *v8;
      if ( (v9 & 6) == 0 )
      {
LABEL_18:
        if ( (unsigned int)(v10 - 5) > 1 )
        {
          v11 = "Invalid value";
          goto LABEL_21;
        }
        v15 = (_BYTE *)*(v3 - 2);
        if ( (v9 & 1) == 0 )
        {
          if ( v10 == 5 )
            sub_3E4D8(v15);
          else
            sub_3E4E8(v15);
          goto LABEL_12;
        }
        v11 = (const char *)((int (__fastcall *)(_BYTE *))*(v3 - 5))(v15);
        goto LABEL_33;
      }
      if ( v10 == 2 )
      {
        v22 = sub_49028(v8);
        v16 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v22, *(v3 - 2));
        v11 = (const char *)v16;
        if ( *(v3 - 6) == 4 )
        {
          v24 = (const char *)v16;
          sub_3E5BC((int)v22, (_DWORD *)*(v3 - 2));
          v11 = v24;
        }
LABEL_33:
        if ( !v11 )
          goto LABEL_12;
        if ( a2 )
          goto LABEL_22;
LABEL_35:
        snprintf(byte_68A14, 0xC8u, "Parsing JSON option %s: %s", v7, v11);
        return byte_68A14;
      }
      if ( v10 != 1 )
        goto LABEL_18;
      v23 = v6;
      v17 = v8;
      v25 = v7;
      v18 = 0;
      if ( !sub_48E60(v8) )
      {
LABEL_46:
        v6 = v23;
        goto LABEL_12;
      }
      while ( 1 )
      {
        v19 = sub_48E7C(v17, v18);
        if ( !v19 )
          goto LABEL_46;
        if ( *v19 == 2 )
          break;
        if ( !*v19 )
        {
          v11 = (const char *)sub_292B8();
          goto LABEL_49;
        }
LABEL_45:
        if ( (unsigned int)sub_48E60(v17) <= ++v18 )
          goto LABEL_46;
      }
      v26 = sub_49028(v19);
      v20 = ((int (__fastcall *)(_DWORD *, _DWORD))*(v3 - 4))(v26, *(v3 - 2));
      v11 = (const char *)v20;
      if ( *(v3 - 6) == 4 )
      {
        v27 = (const char *)v20;
        sub_3E5BC((int)v26, (_DWORD *)*(v3 - 2));
        v11 = v27;
      }
LABEL_49:
      if ( !v11 )
        goto LABEL_45;
      v6 = v23;
      v7 = v25;
LABEL_21:
      if ( !a2 )
        goto LABEL_35;
LABEL_22:
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "Invalid config option %s: %s", v7, v11);
        sub_1DD60(3, s, 0);
      }
      dword_68ADC = -1;
LABEL_12:
      v7 = strtok(0, "|");
      if ( v7 )
        continue;
      break;
    }
LABEL_27:
    free(v6);
    v4 = v3[1];
    if ( v4 == 16 )
      break;
LABEL_8:
    v3 += 7;
    if ( (v4 & 8) != 0 )
      goto LABEL_53;
  }
LABEL_28:
  v12 = (_DWORD *)sub_48AF4(a1, "include");
  if ( !v12 || *v12 != 2 )
    return 0;
  v13 = sub_49028(v12);
  return (char *)sub_291BC(v13, 0);
}
// 291BC: using guessed type int __fastcall sub_291BC(_DWORD, _DWORD);
// 67840: using guessed type int dword_67840;
// 67A6C: using guessed type int dword_67A6C;
// 686E0: using guessed type char byte_686E0;
// 68ADC: using guessed type int dword_68ADC;
// 72D90: using guessed type char byte_72D90;

//----- (00029640) --------------------------------------------------------
int sub_29640()
{
  struct tm *v0; // r0
  int v1; // r12
  int v2; // r7
  int tm_min; // r6
  int tm_hour; // r4
  int v7; // r12
  _BOOL4 v8; // r7
  _BOOL4 v9; // r1
  _BOOL4 v10; // r5
  _BOOL4 v11; // r2
  time_t v12; // [sp+4h] [bp-10h] BYREF
  __time_t v13[2]; // [sp+8h] [bp-Ch] BYREF

  sub_206A0(v13);
  v12 = v13[0];
  v0 = localtime(&v12);
  v1 = (unsigned __int8)byte_76030;
  if ( byte_76030 )
  {
    v2 = (unsigned __int8)byte_74F30;
    tm_min = v0->tm_min;
    tm_hour = v0->tm_hour;
    if ( byte_74F30 )
    {
      if ( dword_74F3C > dword_7603C || (dword_74F38 > dword_76038 ? (v9 = dword_74F3C == dword_7603C) : (v9 = 0), v9) )
      {
        if ( dword_74F3C > tm_hour || (dword_74F38 > tm_min ? (v2 = dword_74F3C == tm_hour) : (v2 = 0), v2) )
        {
          if ( dword_7603C <= tm_hour )
          {
            v11 = dword_76038 > tm_min && dword_7603C == tm_hour;
            return !v11;
          }
          else
          {
            return 0;
          }
        }
      }
      else if ( dword_7603C > tm_hour || (dword_76038 > tm_min ? (v10 = dword_7603C == tm_hour) : (v10 = 0), v10) )
      {
        if ( dword_74F3C <= tm_hour )
          return dword_74F38 > tm_min && dword_74F3C == tm_hour;
      }
    }
    else if ( dword_7603C <= tm_hour && (dword_76038 <= tm_min || dword_7603C != tm_hour) )
    {
      byte_76030 = byte_74F30;
      return v1;
    }
    return v2;
  }
  v7 = v0->tm_hour;
  if ( v7 < dword_74F3C )
    return 1;
  v8 = v0->tm_min < dword_74F38;
  if ( v7 != dword_74F3C )
    return 0;
  return v8;
}
// 296B0: masking with 0x1 was optimized away because r1.4 <= 0x1
// 29754: masking with 0x1 was optimized away because r1.4 <= 0x1
// 74F30: using guessed type char byte_74F30;
// 74F38: using guessed type int dword_74F38;
// 74F3C: using guessed type int dword_74F3C;
// 76030: using guessed type char byte_76030;
// 76038: using guessed type int dword_76038;
// 7603C: using guessed type int dword_7603C;

//----- (000297CC) --------------------------------------------------------
char *__fastcall sub_297CC(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_3E5C8(a1, a2);
  if ( !result )
  {
    if ( *a2 < 100.0 )
    {
      return "Value out of range";
    }
    else if ( *a2 > 250.0 )
    {
      return "Value out of range";
    }
  }
  return result;
}

//----- (00029824) --------------------------------------------------------
char *__fastcall sub_29824(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_3E5C8(a1, a2);
  if ( !result )
  {
    if ( *a2 < 125.0 )
    {
      return "Value out of range";
    }
    else if ( *a2 > 500.0 )
    {
      return "Value out of range";
    }
  }
  return result;
}

//----- (0002987C) --------------------------------------------------------
void sub_2987C()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_68AE0 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      strcpy(v0, "config too fast, pool is changing, please wait\n");
      sub_1DD60(3, v0, 0);
    }
  }
  else if ( pthread_create((pthread_t *)&dword_68AE0, 0, (void *(*)(void *))sub_3D2A0, 0)
         && (byte_72D90 || byte_686E0 || dword_67840 > 2) )
  {
    strcpy(v0, "Failed to create pool_change_thread");
    sub_1DD60(3, v0, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 68AE0: using guessed type int dword_68AE0;
// 72D90: using guessed type char byte_72D90;

//----- (000299A8) --------------------------------------------------------
int __fastcall sub_299A8(int a1, int a2, int (__fastcall **a3)(int))
{
  int v6; // r3
  char v8[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
  {
    snprintf(v8, 0x800u, "Thread %d being disabled", a2);
    sub_1DD60(4, v8, 0);
  }
  v6 = (unsigned __int8)byte_686E1;
  *(_QWORD *)(*(_DWORD *)(a1 + 36) + 48) = 0;
  if ( v6 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy(v8, "Waiting on sem in miner thread");
    sub_1DD60(7, v8, 0);
  }
  sub_23018((sem_t *)(a1 + 16), "cgminer.c", "mt_disable", 9230);
  if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
  {
    snprintf(v8, 0x800u, "Thread %d being re-enabled", a2);
    sub_1DD60(4, v8, 0);
  }
  return (*a3)(a1);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (00029B50) --------------------------------------------------------
void sub_29B50()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Unable to set thread to low priority");
  sub_1DD60(6, v0, 0);
}

//----- (00029BA0) --------------------------------------------------------
void sub_29BA0()
{
  if ( !nice(10) && (byte_72D90 || byte_686E0 || dword_67840 > 5) )
    sub_29B50();
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00029BFC) --------------------------------------------------------
int __fastcall sub_29BFC(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_22E98("API");
  sub_29BA0();
  sub_1B804();
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}

//----- (00029C38) --------------------------------------------------------
char *__fastcall sub_29C38(const char *a1)
{
  char *result; // r0

  dword_68AE4 = 2;
  result = sub_3E6D8(a1, &dword_73F1C);
  if ( !result && (unsigned int)dword_73F1C > 0x270F )
    return "Value out of range";
  return result;
}
// 68AE4: using guessed type int dword_68AE4;
// 73F1C: using guessed type int dword_73F1C;

//----- (00029C80) --------------------------------------------------------
char *__fastcall sub_29C80(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && *a2 > 0x270Fu )
    return "Value out of range";
  return result;
}

//----- (00029CB0) --------------------------------------------------------
char *__fastcall sub_29CB0(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 0xFFFE )
    return "Value out of range";
  return result;
}

//----- (00029CE4) --------------------------------------------------------
char *__fastcall sub_29CE4(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && *a2 > 0x64u )
    return "Value out of range";
  return result;
}

//----- (00029D10) --------------------------------------------------------
char *__fastcall sub_29D10(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && (unsigned int)(*a2 - 42) > 0x14 )
    return "Value out of range";
  return result;
}

//----- (00029D40) --------------------------------------------------------
char *__fastcall sub_29D40(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && (unsigned int)(*a2 - 22) > 0x21 )
    return "Value out of range";
  return result;
}

//----- (00029D70) --------------------------------------------------------
char *__fastcall sub_29D70(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && (unsigned int)(*a2 - 42) > 0x2B )
    return "Value out of range";
  return result;
}

//----- (00029DA0) --------------------------------------------------------
char *__fastcall sub_29DA0(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && (unsigned int)(*a2 - 22) > 0x35 )
    return "Value out of range";
  return result;
}

//----- (00029DD0) --------------------------------------------------------
char *__fastcall sub_29DD0(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && (unsigned int)(*a2 - 32) > 0x1F )
    return "Value out of range";
  return result;
}

//----- (00029E00) --------------------------------------------------------
char *__fastcall sub_29E00(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && *a2 > 4u )
    return "Value out of range";
  return result;
}

//----- (00029E2C) --------------------------------------------------------
char *__fastcall sub_29E2C(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && *a2 > 0xC8u )
    return "Value out of range";
  return result;
}

//----- (00029E58) --------------------------------------------------------
char *__fastcall sub_29E58(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && *a2 > 0x1E00u )
    return "Value out of range";
  return result;
}

//----- (00029E84) --------------------------------------------------------
char *__fastcall sub_29E84(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 0xFE )
    return "Value out of range";
  return result;
}

//----- (00029EB4) --------------------------------------------------------
char *__fastcall sub_29EB4(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && *a2 > 0xFFu )
    return "Value out of range";
  return result;
}

//----- (00029EE0) --------------------------------------------------------
char *__fastcall sub_29EE0(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && (unsigned int)(*a2 - 1) > 9 )
    return "Value out of range";
  return result;
}

//----- (00029F10) --------------------------------------------------------
char *__fastcall sub_29F10(const char *a1, _DWORD *a2)
{
  char *result; // r0

  result = sub_3E6D8(a1, a2);
  if ( !result && *a2 > 0xAu )
    return "Value out of range";
  return result;
}

//----- (00029F3C) --------------------------------------------------------
int __fastcall sub_29F3C(_DWORD *a1, char *s1)
{
  char *v5; // r0
  int v6; // r1
  int v7; // r3
  char *v8; // r0
  int v9; // r1
  int v10; // r2
  char v11[2048]; // [sp+0h] [bp-800h] BYREF

  if ( !strncasecmp(s1, "stratum+tcp://", 0xEu) )
  {
    v8 = _strdup(s1);
    v9 = a1[154];
    a1[41] = v8;
    v10 = (unsigned __int8)byte_72D90;
    *((_BYTE *)a1 + 592) = 0;
    a1[144] = v9;
    *((_BYTE *)a1 + 656) = 1;
    if ( !v10 && !byte_686E0 && dword_67840 <= 4 )
      return 1;
    snprintf(v11, 0x800u, "Pool %d is tcp pool.", *a1);
    goto LABEL_8;
  }
  if ( strncasecmp(s1, "stratum+tls://", 0xEu) )
    return 0;
  v5 = _strdup(s1);
  v6 = a1[154];
  v7 = (unsigned __int8)byte_72D90;
  a1[41] = v5;
  a1[144] = v6;
  *((_BYTE *)a1 + 656) = 1;
  *((_BYTE *)a1 + 592) = 1;
  if ( v7 || byte_686E0 || dword_67840 > 4 )
  {
    snprintf(v11, 0x800u, "Pool %d is tls pool.", *a1);
LABEL_8:
    sub_1DD60(5, v11, 0);
  }
  return 1;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0002A090) --------------------------------------------------------
void __fastcall sub_2A090(const char *a1, const char *a2, int a3)
{
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  snprintf(s, 0x800u, "Free work called with NULL work from %s %s:%d", a1, a2, a3);
  sub_1DD60(3, s, 0);
}

//----- (0002A0D8) --------------------------------------------------------
double __fastcall sub_2A0D8(double a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double *v4; // r4
  double result; // r0

  v4 = (double *)LODWORD(a1);
  result = exp(a1);
  *v4 = (*v4 + v1 / v2 * (1.0 - 1.0 / (v2 / v3))) / (1.0 - 1.0 / (v2 / v3) + 1.0);
  return result;
}
// 2A0F8: variable 'v1' is possibly undefined
// 2A0F8: variable 'v2' is possibly undefined
// 2A0E8: variable 'v3' is possibly undefined

//----- (0002A128) --------------------------------------------------------
int sub_2A128()
{
  return 1;
}

//----- (0002A130) --------------------------------------------------------
int sub_2A130()
{
  return 1;
}

//----- (0002A144) --------------------------------------------------------
const char *__fastcall sub_2A144(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_7603C, &dword_76038) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( (unsigned int)dword_7603C > 0x17 || (unsigned int)dword_76038 > 0x3B )
    return "Invalid time set.";
  byte_76030 = 1;
  return 0;
}
// 76030: using guessed type char byte_76030;
// 76038: using guessed type int dword_76038;
// 7603C: using guessed type int dword_7603C;

//----- (0002A1B0) --------------------------------------------------------
int __fastcall sub_2A1B0(char *a1, size_t a2, time_t *a3)
{
  time_t v3; // r3
  int v6; // r4
  struct tm *v7; // r0
  time_t v9; // [sp+1Ch] [bp-8h] BYREF

  v3 = a3[1];
  v9 = *a3;
  v6 = v3 / 1000;
  v7 = localtime(&v9);
  return snprintf(
           a1,
           a2,
           "[%d-%02d-%02d %02d:%02d:%02d.%03d]",
           v7->tm_year + 1900,
           v7->tm_mon + 1,
           v7->tm_mday,
           v7->tm_hour,
           v7->tm_min,
           v7->tm_sec,
           v6);
}

//----- (0002A248) --------------------------------------------------------
void sub_2A248()
{
  unsigned int v0; // r4
  unsigned int **v1; // r7
  unsigned int **v2; // r5
  int v3; // t1
  unsigned int v4; // r3
  bool v5; // cf
  unsigned int **v6; // r8
  int v7; // t1
  unsigned int v8; // r6
  int v9; // r1
  int v10; // r1
  int v11; // r8
  unsigned int *v12; // t1
  char v13[2052]; // [sp+0h] [bp-804h] BYREF

  if ( dword_72E60 <= 0 )
  {
    v0 = 1;
  }
  else
  {
    v0 = -1;
    v1 = (unsigned int **)dword_72F04;
    v2 = (unsigned int **)dword_72F04;
    do
    {
      v3 = (int)*v2++;
      v4 = *(_DWORD *)(v3 + 56);
      v5 = 1;
      if ( v4 )
        v5 = v4 >= v0;
      if ( !v5 )
        v0 = v4;
    }
    while ( (unsigned int **)(dword_72F04 + 4 * dword_72E60) != v2 );
    if ( v0 == -1 )
    {
      v0 = 1;
    }
    else
    {
      v6 = (unsigned int **)dword_72F04;
      do
      {
        v7 = (int)*v6++;
        v8 = *(_DWORD *)(v7 + 56);
        if ( v8 )
        {
          sub_4A52C(v8, v0);
          if ( v9 )
          {
            do
              sub_4A52C(v8, --v0);
            while ( v10 );
          }
        }
      }
      while ( v2 != v6 );
    }
    v11 = dword_681BC;
    do
    {
      v12 = *v1++;
      v12[16] = sub_4A2D0(v12[16] * v11, v0);
      v12[15] = sub_4A2D0(v12[14], v0);
    }
    while ( v2 != v1 );
  }
  dword_681BC = v0;
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(v13, 0x800u, "Global quota greatest common denominator set to %lu", v0);
    sub_1DD60(7, v13, 0);
  }
}
// 2A2C8: variable 'v9' is possibly undefined
// 2A2E0: variable 'v10' is possibly undefined
// 67840: using guessed type int dword_67840;
// 681BC: using guessed type int dword_681BC;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (0002A3CC) --------------------------------------------------------
char *__fastcall sub_2A3CC(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0
  _BOOL4 v8; // r4
  int v9; // r3

  result = sub_3E6D8(a1, a2);
  if ( !result )
  {
    v8 = *a2 < a3;
    if ( *a2 > a4 )
      v9 = v8 | 1;
    else
      v9 = v8;
    if ( v9 )
      return "Value out of range";
  }
  return result;
}

//----- (0002A418) --------------------------------------------------------
int __fastcall sub_2A418(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (0002A448) --------------------------------------------------------
int __fastcall sub_2A448(int a1, char *a2)
{
  int result; // r0

  result = sub_20A10(a2, (_DWORD *)(a1 + 616), (char **)(a1 + 584));
  if ( result )
    return sub_29F3C((_DWORD *)a1, a2);
  return result;
}

//----- (0002A47C) --------------------------------------------------------
int __fastcall sub_2A47C(int a1, char *s1)
{
  char *v3; // r5
  char *v5; // r6

  v3 = sub_20B84(s1, a1);
  if ( !sub_2A448(a1, v3) )
  {
    sub_3E5BC((int)v3, (_DWORD *)(a1 + 164));
    if ( strncmp(v3, "http://", 7u) )
    {
      if ( strncmp(v3, "https://", 8u) )
      {
        v5 = (char *)sub_1F828(0x100u, "cgminer.c", "setup_url", 1070);
        strcpy(v5, "stratum+tcp://");
        strncat(v5, v3, 0xF2u);
        sub_2A448(a1, v5);
      }
    }
  }
  return *(_DWORD *)(a1 + 164);
}

//----- (0002A55C) --------------------------------------------------------
const char *__fastcall sub_2A55C(const char *a1)
{
  if ( !a1 || !*a1 )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(a1, 0, 10) > 0xC8 )
    return "Invalid value passed to set temp cutoff";
  dword_68AE8 = (int)a1;
  return 0;
}
// 68AE8: using guessed type int dword_68AE8;

//----- (0002A5B8) --------------------------------------------------------
void *__fastcall sub_2A5B8(void **a1)
{
  free(a1[72]);
  free(a1[77]);
  free(a1[82]);
  free(a1[80]);
  return memset(a1, 0, 0x1C0u);
}

//----- (0002A5F4) --------------------------------------------------------
char *__fastcall sub_2A5F4(int a1, int a2, int a3)
{
  int v6; // r7
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  char *result; // r0
  unsigned int v11[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = *(_DWORD *)(a1 + 340);
  sub_2A5B8((void **)a1);
  sub_232EC((void *)a1, (const void *)a2, 0x1C0u, (int)"cgminer.c", (int)"_copy_work", 5015);
  *(_DWORD *)(a1 + 340) = v6;
  v7 = *(const char **)(a2 + 288);
  if ( v7 )
    *(_DWORD *)(a1 + 288) = _strdup(v7);
  v8 = *(const char **)(a2 + 320);
  if ( v8 )
    *(_DWORD *)(a1 + 320) = _strdup(v8);
  v9 = *(const char **)(a2 + 308);
  if ( v9 )
  {
    if ( a3 )
    {
      *(_DWORD *)(a1 + 68) = bswap32(a3 + bswap32(*(_DWORD *)(a1 + 68)));
      sub_1FB44(v11, *(unsigned __int8 **)(a2 + 308), 4);
      v11[0] = bswap32(a3 + bswap32(v11[0]));
      *(_DWORD *)(a1 + 308) = sub_1FA90((int)v11, 4);
    }
    else
    {
      *(_DWORD *)(a1 + 308) = _strdup(v9);
    }
  }
  else if ( a3 )
  {
    *(_DWORD *)(a1 + 68) = bswap32(a3 + bswap32(*(_DWORD *)(a1 + 68)));
  }
  result = *(char **)(a2 + 328);
  if ( result )
  {
    result = _strdup(result);
    *(_DWORD *)(a1 + 328) = result;
  }
  *(_DWORD *)(a1 + 444) = *(_DWORD *)(a2 + 444);
  return result;
}

//----- (0002A70C) --------------------------------------------------------
void __fastcall sub_2A70C(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v4; // r5

  v4 = *a1;
  if ( *a1 )
  {
    sub_2A5B8(*a1);
    free(v4);
    *a1 = 0;
  }
  else if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    sub_2A090(a2, a3, a4);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0002A7A0) --------------------------------------------------------
void __fastcall sub_2A7A0(int a1)
{
  __time_t v1; // [sp-10h] [bp-10h] BYREF

  if ( *(_DWORD *)(a1 + 368) )
  {
    sub_206A0(&v1);
    sub_209CC();
  }
}

//----- (0002A804) --------------------------------------------------------
void sub_2A804()
{
  __time_t v0[3]; // [sp+0h] [bp-Ch] BYREF

  sub_206A0(v0);
  sub_209CC();
}

//----- (0002A82C) --------------------------------------------------------
void sub_2A82C()
{
  __time_t v0[3]; // [sp+0h] [bp-Ch] BYREF

  sub_206A0(v0);
  sub_209CC();
}

//----- (0002A854) --------------------------------------------------------
void __fastcall sub_2A854(int a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r4
  int v4; // r3
  char v5[1016]; // [sp+8h] [bp-C00h] BYREF
  char v6[2048]; // [sp+408h] [bp-800h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    v4 = (unsigned __int8)a2;
    --v2;
    a2 >>= 8;
    v3 = v4 + (v3 << 8);
  }
  while ( v2 );
  sub_1FA20(v5, a1, 128);
  if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(v6, 0x800u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, v5);
    sub_1DD60(3, v6, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0002A91C) --------------------------------------------------------
_BYTE *__fastcall sub_2A91C(_BYTE *result, unsigned int a2)
{
  void *v2; // r3
  _BYTE *v3; // r4

  v2 = (void *)*((_DWORD *)result + 77);
  *((_DWORD *)result + 17) = bswap32(a2);
  if ( v2 )
  {
    v3 = result;
    free(v2);
    result = sub_1FA90((int)(v3 + 68), 4);
    *((_DWORD *)v3 + 77) = result;
  }
  return result;
}

//----- (0002A954) --------------------------------------------------------
unsigned int __fastcall sub_2A954(__int64 *a1)
{
  double v2; // r0
  double v3; // d8
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d6
  double v8; // r0
  double v9; // d8

  if ( !a1 )
    return 0;
  LODWORD(v2) = sub_4AB04(a1[27]);
  v3 = v2 * 6.27710174e57;
  LODWORD(v4) = sub_4AB04(a1[26]);
  v5 = v3 + v4 * 3.40282367e38;
  LODWORD(v6) = sub_4AB04(a1[25]);
  v7 = v6;
  LODWORD(v8) = sub_4AB04(a1[24]);
  v9 = v8 + v5 + v7 * 1.84467441e19;
  if ( v9 == 0.0 )
    return 0;
  else
    return sub_4ABD0(2.69595353e67 / v9);
}
// 2A978: variable 'v2' is possibly undefined
// 2A98C: variable 'v4' is possibly undefined
// 2A998: variable 'v6' is possibly undefined
// 2A9AC: variable 'v8' is possibly undefined

//----- (0002AA08) --------------------------------------------------------
void __fastcall sub_2AA08(void ***a1, const char *a2, const char *a3, int a4)
{
  void **v5; // r1
  _DWORD *v9; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v5 = *a1;
  if ( *a1 )
  {
    if ( *((_BYTE *)v5 + 273) || v5[60] || *((_BYTE *)v5 + 272) )
    {
      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        strcpy(s, "Discarded cloned or rolled work");
        sub_1DD60(7, s, 0);
      }
    }
    else
    {
      v9 = v5[65];
      if ( v9 )
      {
        ++v9[31];
        --*((_DWORD *)v5[65] + 16);
        --*((_DWORD *)v5[65] + 17);
      }
      ++qword_75008;
      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        strcpy(s, "Discarded work");
        sub_1DD60(7, s, 0);
      }
    }
    sub_2A70C(a1, a2, a3, a4);
  }
  else if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(s, 0x800u, "Discard work called with NULL work from %s %s:%d", a2, a3, a4);
    sub_1DD60(3, s, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 75008: using guessed type __int64 qword_75008;

//----- (0002AC40) --------------------------------------------------------
int *__fastcall sub_2AC40(int *result)
{
  int v1; // r7
  int v2; // r5
  int *v3; // r2
  int v4; // lr
  int v5; // r1
  int v6; // t1
  int v7; // r3
  bool v8; // cc
  int v9; // r3
  int v10; // r6
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r7
  int v15; // r3

  v1 = dword_72E60;
  v2 = dword_72E60 - 1;
  if ( dword_72E60 > 0 )
  {
    v3 = (int *)dword_72F04;
    v4 = dword_72F04 + 4 * dword_72E60;
    do
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= result[1];
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( (int *)v4 != v3 );
  }
  v10 = *result;
  if ( *result < v2 )
  {
    v11 = v10 + 1;
    v12 = 4 * (v10 + 1);
    while ( 1 )
    {
      v13 = v12 - 4;
      v14 = *(_DWORD *)(dword_72F04 + v12);
      v12 += 4;
      *(_DWORD *)(dword_72F04 + v13) = v14;
      **(_DWORD **)(dword_72F04 + v13) = v10;
      v10 = v11;
      if ( v11 == v2 )
        break;
      ++v11;
    }
    v1 = dword_72E60;
  }
  *result = v1;
  v15 = dword_72E60;
  *((_BYTE *)result + 105) = 1;
  dword_72E60 = v15 - 1;
  return result;
}
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (0002ACFC) --------------------------------------------------------
void __fastcall sub_2ACFC(FILE *s)
{
  int v2; // r6
  const char *v3; // r11
  char *v4; // r0
  const char *v5; // r0
  const char *v6; // r0
  char *v7; // r2
  int v8; // r3
  const char *v9; // r10
  const char *v10; // r0
  _BYTE *v11; // r0
  const char *v12; // r0
  int v13; // r0
  int v14; // r4
  const char *v15; // r10
  char *v16; // r0
  const char *v17; // r0
  const char *v18; // r11
  char *v19; // r3
  const char *v20; // r0
  const char *v21; // r0
  const char **v22; // r4
  char *v23; // r8
  char *v24; // r11
  char *(__fastcall *v25)(const char *, _DWORD *); // r2
  bool v26; // zf
  int v27; // r3
  int v28; // r1
  int (__fastcall *v29)(_BYTE *); // r2
  bool v30; // zf
  const char **v31; // r3
  const char *v32; // r0
  int v33; // r1
  int v34; // r4
  int v35; // r5
  bool v36; // zf
  int v37; // [sp+14h] [bp-10h]
  const char *v38; // [sp+14h] [bp-10h]
  const char *v39; // [sp+18h] [bp-Ch]
  const char *v40; // [sp+18h] [bp-Ch]
  const char *v41; // [sp+1Ch] [bp-8h]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, s);
  if ( dword_72E60 > 0 )
  {
    v2 = 0;
    do
    {
      v13 = sub_290E8(v2);
      v8 = *(_DWORD *)(v13 + 56);
      v14 = v13;
      if ( v8 == 1 )
      {
        if ( v2 )
          v15 = (const char *)&word_51D00;
        else
          v15 = "";
        if ( *(_DWORD *)(v13 + 184) )
        {
          v16 = sub_1F9D4(*(char **)(v13 + 180));
          v40 = sub_28448(v16);
          v17 = *(const char **)(v14 + 184);
          if ( v17 )
          {
            v20 = sub_28448(v17);
            v19 = "|";
            v18 = v20;
            if ( !*(_DWORD *)(v14 + 184) )
              v19 = "";
          }
          else
          {
            v18 = "";
            v19 = "";
          }
        }
        else
        {
          v18 = "";
          v40 = "";
          v19 = "";
        }
        v38 = v19;
        v21 = sub_28448(*(const char **)(v14 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v15, v40, v18, v38, v21);
        if ( !*(_BYTE *)(v14 + 580) )
          goto LABEL_11;
      }
      else
      {
        if ( v2 )
          v3 = (const char *)&word_51D00;
        else
          v3 = "";
        if ( *(_DWORD *)(v13 + 184) )
        {
          v4 = sub_1F9D4(*(char **)(v13 + 180));
          v41 = sub_28448(v4);
          v5 = *(const char **)(v14 + 184);
          if ( v5 )
          {
            v6 = sub_28448(v5);
            v7 = "|";
            v8 = *(_DWORD *)(v14 + 56);
            v9 = v6;
            if ( !*(_DWORD *)(v14 + 184) )
              v7 = "";
          }
          else
          {
            v8 = *(_DWORD *)(v14 + 56);
            v9 = "";
            v7 = "";
          }
        }
        else
        {
          v9 = "";
          v41 = "";
          v7 = "";
        }
        v39 = v7;
        v37 = v8;
        v10 = sub_28448(*(const char **)(v14 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v3, v41, v9, v39, v37, v10);
        if ( !*(_BYTE *)(v14 + 580) )
          goto LABEL_11;
      }
      fwrite("\n\t\t\"extranonce-subscribe\" : true,", 1u, 0x21u, s);
LABEL_11:
      ++v2;
      v11 = sub_28448(*(const char **)(v14 + 172));
      fprintf(s, aUserS, v11);
      v12 = sub_28448(*(const char **)(v14 + 176));
      fprintf(s, "\n\t\t\"pass\" : \"%s\"\n\t}", v12);
    }
    while ( dword_72E60 > v2 );
  }
  fwrite("\n]\n", 1u, 3u, s);
  if ( dword_67A6C != 16 )
  {
    v22 = (const char **)&unk_67A84;
    while ( 1 )
    {
      v23 = _strdup(*(v22 - 7));
      v24 = strtok(v23, "|");
      if ( v24 )
        break;
LABEL_77:
      v22 += 7;
      free(v23);
      if ( *(v22 - 6) == (const char *)16 )
        goto LABEL_78;
    }
    while ( 1 )
    {
      if ( v24[1] == 45 && *(v22 - 1) != (const char *)&unk_762FC )
      {
        v28 = (int)*(v22 - 6);
        if ( (v28 & 1) == 0 )
          goto LABEL_72;
        v29 = (int (__fastcall *)(_BYTE *))*(v22 - 5);
        v30 = v29 == sub_3E4D8;
        if ( v29 != sub_3E4D8 )
          v30 = v29 == sub_3E4F8;
        if ( v30 && **(v22 - 2) == (v29 == sub_3E4D8) )
        {
          fprintf(s, ",\n\"%s\" : true", v24 + 2);
        }
        else
        {
LABEL_72:
          if ( (v28 & 2) == 0 )
            goto LABEL_73;
          v25 = (char *(__fastcall *)(const char *, _DWORD *))*(v22 - 4);
          v26 = v25 == sub_29C80;
          if ( v25 != sub_29C80 )
            v26 = v25 == sub_3E6D8;
          v27 = v26;
          if ( v25 == sub_29CB0 )
            v27 |= 1u;
          if ( v25 == sub_29F10 )
            v27 |= 1u;
          if ( v25 == sub_29EE0 )
            v27 |= 1u;
          if ( v25 == sub_29CE4 )
            v27 |= 1u;
          if ( v25 == sub_29EB4 )
            v27 |= 1u;
          if ( v25 == sub_29E84 )
            v27 |= 1u;
          if ( v25 == sub_29E58 )
            v27 |= 1u;
          if ( v25 == sub_29E2C )
            v27 |= 1u;
          if ( v25 == sub_29E00 )
            v27 |= 1u;
          if ( v25 == sub_29DD0 )
            v27 |= 1u;
          if ( v25 == sub_29DA0 )
            v27 |= 1u;
          if ( v25 == sub_29D70 )
            v27 |= 1u;
          if ( v25 == sub_29D40 )
            v27 |= 1u;
          if ( v25 == sub_29D10 )
            v27 |= 1u;
          if ( v27 )
          {
            fprintf(s, ",\n\"%s\" : \"%d\"", v24 + 2, *(_DWORD *)*(v22 - 2));
          }
          else
          {
            v36 = (char *)v25 == (char *)sub_29824;
            if ( (char *)v25 != (char *)sub_29824 )
              v36 = (char *)v25 == (char *)sub_297CC;
            if ( !v36 )
            {
LABEL_73:
              if ( (v28 & 6) != 0 )
              {
                v31 = (const char **)*(v22 - 2);
                if ( v31 != (const char **)&unk_68AFC )
                {
                  if ( *v31 )
                  {
                    v32 = sub_28448(*v31);
                    fprintf(s, ",\n\"%s\" : \"%s\"", v24 + 2, v32);
                  }
                }
              }
              goto LABEL_63;
            }
            fprintf(s, ",\n\"%s\" : \"%.1f\"", v24 + 2, *(float *)*(v22 - 2));
          }
        }
      }
LABEL_63:
      v24 = strtok(0, "|");
      if ( !v24 )
        goto LABEL_77;
    }
  }
LABEL_78:
  v33 = dword_68AE4;
  if ( dword_68AE4 == 4 )
  {
    fwrite(",\n\"balance\" : true", 1u, 0x12u, s);
    v33 = dword_68AE4;
  }
  if ( v33 == 3 )
  {
    fwrite(",\n\"load-balance\" : true", 1u, 0x17u, s);
    v33 = dword_68AE4;
  }
  if ( v33 == 1 )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, s);
    v33 = dword_68AE4;
  }
  if ( v33 == 2 )
    fprintf(s, ",\n\"rotate\" : \"%d\"", dword_73F1C);
  fwrite("\n}\n", 1u, 3u, s);
  v34 = dword_688FC;
  dword_688FC = 0;
  if ( v34 )
  {
    do
    {
      v35 = *(_DWORD *)(v34 + 4);
      free(*(void **)v34);
      free((void *)v34);
      v34 = v35;
    }
    while ( v35 );
  }
}
// 51D00: using guessed type __int16 word_51D00;
// 67A6C: using guessed type int dword_67A6C;
// 688FC: using guessed type int dword_688FC;
// 68AE4: using guessed type int dword_68AE4;
// 72E60: using guessed type int dword_72E60;
// 73F1C: using guessed type int dword_73F1C;

//----- (0002B2E4) --------------------------------------------------------
int sub_2B2E4()
{
  int result; // r0
  int *v1; // r2
  int v2; // r12
  int v3; // t1

  *(_DWORD *)dword_681C8 = 0;
  dword_681CC = 0;
  dword_68B00 = 0;
  dword_68B04 = 0;
  result = sub_287D8(0, dword_681C8, 8u, 0);
  if ( dword_72E60 > 0 )
  {
    result = 0;
    v1 = (int *)dword_72F04;
    v2 = dword_72F04 + 4 * dword_72E60;
    do
    {
      v3 = *v1++;
      *(_DWORD *)(v3 + 368) = 0;
      *(_DWORD *)(v3 + 372) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  return result;
}
// 681CC: using guessed type int dword_681CC;
// 68B00: using guessed type int dword_68B00;
// 68B04: using guessed type int dword_68B04;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (0002B370) --------------------------------------------------------
char *__fastcall sub_2B370(char *a1)
{
  size_t v2; // r0
  char *v3; // r12
  size_t v4; // lr
  char *v6; // r0

  if ( dword_74FFC && *(_BYTE *)dword_74FFC )
    return strcpy(a1, (const char *)dword_74FFC);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    strcpy((char *)stpcpy(a1, v6), "/");
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".bmminer/");
  mkdir(a1, 0x1FFu);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  *(_DWORD *)&a1[v4] = *(_DWORD *)"bmminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return *(char **)"bmminer.conf";
}
// 1262C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 74FFC: using guessed type int dword_74FFC;

//----- (0002B46C) --------------------------------------------------------
void sub_2B46C()
{
  dword_68A08 = (int)sub_1F828(0x1000u, "cgminer.c", "load_default_config", 2212);
  dword_68A0C = 0;
  sub_2B370((char *)dword_68A08);
  if ( access((const char *)dword_68A08, 4) )
  {
    free((void *)dword_68A08);
    dword_68A08 = 0;
  }
  else
  {
    sub_291BC((char *)dword_68A08);
  }
}
// 68A08: using guessed type int dword_68A08;
// 68A0C: using guessed type int dword_68A0C;

//----- (0002B4D0) --------------------------------------------------------
void __fastcall sub_2B4D0(void *a1)
{
  double v1; // d0
  __int64 v3; // r0
  __int64 v4; // r6
  double v5; // r0
  double v6; // d8
  __int64 v7; // r0
  __int64 v8; // kr00_8
  double v9; // r0
  double v10; // d8
  __int64 v11; // r0
  __int64 v12; // kr08_8
  double v13; // r0
  unsigned int v14; // r0
  int v15; // r1
  char *v16; // r6
  _DWORD v17[2]; // [sp+8h] [bp-824h] BYREF
  __int64 v18; // [sp+10h] [bp-81Ch]
  __int64 v19; // [sp+18h] [bp-814h]
  __int64 v20; // [sp+20h] [bp-80Ch]
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  if ( v1 == 0.0 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      v4 = 4294901760LL;
      strcpy(s, "Diff zero passed to set_target");
      sub_1DD60(3, s, 0);
      v14 = 0;
      v15 = 0;
      v8 = 0;
      v12 = 0;
    }
    else
    {
      v14 = 0;
      v4 = 4294901760LL;
      v15 = 0;
      v8 = 0;
      v12 = 0;
    }
  }
  else
  {
    LODWORD(v3) = sub_4ABD0(2.69595353e67 / v1 * 1.59309191e-58);
    v4 = v3;
    LODWORD(v5) = sub_4AB04(v3);
    v6 = 2.69595353e67 / v1 - v5 * 6.27710174e57;
    LODWORD(v7) = sub_4ABD0(v6 * 2.93873588e-39);
    v8 = v7;
    LODWORD(v9) = sub_4AB04(v7);
    v10 = v6 - v9 * 3.40282367e38;
    LODWORD(v11) = sub_4ABD0(v10 * 5.42101086e-20);
    v12 = v11;
    LODWORD(v13) = sub_4AB04(v11);
    v14 = sub_4ABD0(v10 - v13 * 1.84467441e19);
  }
  v20 = v4;
  v19 = v8;
  v18 = v12;
  v17[0] = v14;
  v17[1] = v15;
  if ( byte_686E1 )
  {
    v16 = sub_1FA90((int)v17, 32);
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(s, 0x800u, "Generated target %s", v16);
      sub_1DD60(7, s, 0);
    }
    free(v16);
  }
  sub_232EC(a1, v17, 0x20u, (int)"cgminer.c", (int)"set_target", 8396);
}
// 2B4EC: variable 'v1' is possibly undefined
// 2B508: variable 'v3' is possibly undefined
// 2B520: variable 'v5' is possibly undefined
// 2B534: variable 'v7' is possibly undefined
// 2B548: variable 'v9' is possibly undefined
// 2B55C: variable 'v11' is possibly undefined
// 2B56C: variable 'v13' is possibly undefined
// 2B59C: variable 'v15' is possibly undefined
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (0002B764) --------------------------------------------------------
int __fastcall sub_2B764(int a1)
{
  return dword_76080 - *(_DWORD *)(a1 + 232);
}
// 76080: using guessed type int dword_76080;

//----- (0002B77C) --------------------------------------------------------
bool __fastcall sub_2B77C(int a1, int a2)
{
  *(_DWORD *)(a1 + 76) = a2;
  sub_28C30(a1);
  return *(_DWORD *)(a1 + 220) == 0;
}

//----- (0002B79C) --------------------------------------------------------
bool __fastcall sub_2B79C(int a1, int a2)
{
  double v2; // d0
  unsigned __int64 v4; // r0

  *(_DWORD *)(a1 + 76) = a2;
  sub_28C30(a1);
  LODWORD(v4) = sub_4ABD0(4294901760.0 / v2);
  return *(_QWORD *)(a1 + 216) <= v4;
}
// 2B7BC: variable 'v2' is possibly undefined
// 2B7D4: variable 'v4' is possibly undefined

//----- (0002B7E8) --------------------------------------------------------
int __fastcall sub_2B7E8(int a1, int a2)
{
  _DWORD *v2; // r3
  int result; // r0
  char s[2056]; // [sp+8h] [bp-808h] BYREF

  v2 = *(_DWORD **)(a1 + 36);
  if ( v2[59] == a2 )
  {
    if ( byte_72D90 || (result = (unsigned __int8)byte_686E0, byte_686E0) || dword_67840 > 5 )
    {
      snprintf(s, 0x800u, "%s %d duplicate share detected as HW error", *(const char **)(v2[1] + 8), v2[2]);
      sub_1DD60(6, s, 0);
      return 0;
    }
  }
  else
  {
    v2[59] = a2;
    return 1;
  }
  return result;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0002B88C) --------------------------------------------------------
void __fastcall sub_2B88C(int *a1, int a2)
{
  _BYTE *v4; // r6
  int *v5; // r12
  int v6; // r0
  int v7; // r1
  _DWORD *v8; // lr
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r1
  int v18; // r2
  int v19; // r1
  int v20; // r3
  int v21; // r2
  int v22; // r1
  int v23; // r2
  int v24; // r3
  _BYTE *v25; // r11
  char *v26; // r8
  char *v27; // r7
  char *v28; // r6
  _BYTE *v29; // r10
  _BYTE *v30; // r9
  char *v31; // r5
  size_t v32; // r0
  _BYTE *ptr; // [sp+Ch] [bp-4A8h]
  _DWORD v34[8]; // [sp+10h] [bp-4A4h] BYREF
  _DWORD v35[8]; // [sp+30h] [bp-484h] BYREF
  _DWORD v36[8]; // [sp+50h] [bp-464h] BYREF
  _BYTE v37[64]; // [sp+70h] [bp-444h] BYREF
  char s[1028]; // [sp+B0h] [bp-404h] BYREF

  if ( !dword_68B08 )
    dword_68B08 = fopen64("/nvdata/worklog.txt", "wb");
  v4 = v37;
  memset(s, 0, 0x400u);
  v5 = a1;
  memset(&v35[3], 0, 20);
  do
  {
    v6 = *v5;
    v5 += 4;
    v7 = *(v5 - 3);
    v8 = v4;
    v9 = *(v5 - 2);
    v4 += 16;
    v10 = *(v5 - 1);
    *v8 = v6;
    v8[1] = v7;
    v8[2] = v9;
    v8[3] = v10;
  }
  while ( v5 != a1 + 16 );
  v11 = a1[33];
  v12 = a1[34];
  v13 = a1[35];
  v34[0] = a1[32];
  v34[1] = v11;
  v34[2] = v12;
  v34[3] = v13;
  v14 = a1[37];
  v15 = a1[38];
  v16 = a1[39];
  v34[4] = a1[36];
  v34[5] = v14;
  v34[6] = v15;
  v34[7] = v16;
  v17 = v5[1];
  v18 = v5[2];
  v35[0] = *v5;
  v35[1] = v17;
  v35[2] = v18;
  v19 = a1[49];
  v20 = a1[51];
  v21 = a1[50];
  v36[0] = a1[48];
  v36[1] = v19;
  v36[2] = v21;
  v36[3] = v20;
  v22 = a1[53];
  v23 = a1[54];
  v24 = a1[55];
  v36[4] = a1[52];
  v36[5] = v22;
  v36[6] = v23;
  v36[7] = v24;
  sub_277D4(v37, 64);
  sub_277D4(v34, 32);
  sub_277D4(v35, 12);
  sub_277D4(v36, 32);
  ptr = sub_1FA90((int)a1, 128);
  v25 = sub_1FA90((int)v37, 64);
  v26 = sub_1FA90((int)v34, 32);
  v27 = sub_1FA90((int)v35, 12);
  v28 = sub_1FA90(a2, 4);
  v29 = sub_1FA90(a2, 5);
  v30 = sub_1FA90((int)v36, 32);
  v31 = sub_1FA90((int)(a1 + 111), 4);
  sprintf(s, "midstate %s data %s nonce %s version %s \r\n", v26, v27, v28, v31);
  v32 = strlen(s);
  fwrite(s, v32, 1u, (FILE *)dword_68B08);
  fflush((FILE *)dword_68B08);
  if ( ptr )
    free(ptr);
  if ( v25 )
    free(v25);
  if ( v26 )
    free(v26);
  if ( v27 )
    free(v27);
  if ( v28 )
    free(v28);
  if ( v29 )
    free(v29);
  if ( v30 )
    free(v30);
  if ( v31 )
    free(v31);
}
// 12830: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 68B08: using guessed type int dword_68B08;

//----- (0002BB40) --------------------------------------------------------
void __fastcall sub_2BB40(int *a1, unsigned int a2)
{
  unsigned int v2; // [sp+0h] [bp-Ch] BYREF
  char v3; // [sp+4h] [bp-8h]

  v2 = bswap32(a2);
  v3 = 0;
  sub_2B88C(a1, (int)&v2);
}

//----- (0002BB68) --------------------------------------------------------
int __fastcall sub_2BB68(int *a1, unsigned int a2)
{
  unsigned int v5; // [sp+0h] [bp-Ch] BYREF
  char v6; // [sp+4h] [bp-8h]

  a1[19] = a2;
  sub_28C30((int)a1);
  if ( a1[55] )
    return 0;
  v5 = bswap32(a2);
  v6 = 0;
  sub_2B88C(a1, (int)&v5);
  return 1;
}

//----- (0002BBB4) --------------------------------------------------------
void __fastcall sub_2BBB4(int a1, int a2)
{
  int v4; // r5
  int v5; // r12
  int v6; // r1
  unsigned int v7; // r3
  unsigned int v8; // r2
  int v9; // r1
  unsigned int v10; // r3
  unsigned int v11; // r2
  int v12; // r1
  unsigned int v13; // r5
  int v14; // r6
  int v15; // r3
  int v16; // r1
  __int64 v17; // r2
  int v18; // r5
  int v19; // r2
  _DWORD *v20; // r3
  __int64 v21; // r2
  int v22; // r4
  _DWORD *v23; // r6
  int v24; // r7
  int v25; // r3
  unsigned int v26; // r4
  _DWORD *v27; // r5
  _DWORD *v28; // r11
  int v29; // r4
  char *v30; // r8
  unsigned int v31; // r1
  int v32; // r3
  _DWORD *v33; // r3
  unsigned int v34; // r2
  unsigned int v35; // r1
  bool v36; // cc
  int v37; // r2
  int v38; // r3
  void *v39; // r0
  void **v40; // r7
  void *v41; // r0
  unsigned int i; // [sp+4h] [bp-8h]

  ++*(_DWORD *)(a1 + 360);
  v4 = *(unsigned __int8 *)(a2 + 340);
  v5 = *(unsigned __int8 *)(a2 + 343);
  *(_DWORD *)(a2 + 364) = a2 + 340;
  *(_DWORD *)(a2 + 368) = 4;
  v6 = (v4 + 17973517 + (v5 << 24) + (*(unsigned __int8 *)(a2 + 342) << 16) + (*(unsigned __int8 *)(a2 + 341) << 8))
     ^ 0x7F76D;
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  v8 = (-17973517 - v6 - v7) ^ (v7 >> 13);
  v9 = (v6 - v7 - v8) ^ (v8 >> 12);
  v10 = (v7 - v8 - v9) ^ (v9 << 16);
  v11 = (v8 - v9 - v10) ^ (v10 >> 5);
  v12 = (v9 - v10 - v11) ^ (v11 >> 3);
  v13 = (v11 - v12 - ((v10 - v11 - v12) ^ (v12 << 10))) ^ (((v10 - v11 - v12) ^ (v12 << 10)) >> 15);
  *(_DWORD *)(a2 + 372) = v13;
  v14 = *(_DWORD *)(a1 + 352);
  if ( v14 )
  {
    v15 = *(_DWORD *)(v14 + 344);
    *(_DWORD *)(a2 + 352) = 0;
    v16 = a2 + 344;
    *(_DWORD *)(a2 + 344) = v15;
    *(_DWORD *)(a2 + 348) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16)
                          - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) + 8) = a2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) = a2 + 344;
  }
  else
  {
    *(_DWORD *)(a2 + 352) = 0;
    *(_DWORD *)(a2 + 348) = 0;
    *(_DWORD *)(a1 + 352) = a2;
    *(_DWORD *)(a2 + 344) = malloc(0x2Cu);
    v39 = *(void **)(*(_DWORD *)(a1 + 352) + 344);
    if ( !v39 )
      goto LABEL_31;
    memset(v39, 0, 0x2Cu);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) = *(_DWORD *)(a1 + 352) + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 4) = 32;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 8) = 5;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20) = 344;
    v40 = *(void ***)(*(_DWORD *)(a1 + 352) + 344);
    *v40 = malloc(0x180u);
    v41 = **(void ***)(*(_DWORD *)(a1 + 352) + 344);
    if ( !v41 )
      goto LABEL_31;
    memset(v41, 0, 0x180u);
    v16 = a2 + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 12);
  v17 = *(_QWORD *)*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344);
  v18 = 12 * (v13 & (HIDWORD(v17) - 1));
  ++*(_DWORD *)(v17 + v18 + 4);
  HIDWORD(v17) = *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18);
  *(_DWORD *)(a2 + 356) = 0;
  *(_DWORD *)(a2 + 360) = HIDWORD(v17);
  HIDWORD(v17) = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  v19 = *(_DWORD *)(HIDWORD(v17) + v18);
  v20 = (_DWORD *)(HIDWORD(v17) + v18);
  if ( v19 )
  {
    *(_DWORD *)(v19 + 12) = v16;
    v20 = (_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18);
  }
  *v20 = v16;
  v21 = *(_QWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v18 + 4);
  if ( (unsigned int)v21 >= 10 * (HIDWORD(v21) + 1) )
  {
    v22 = *(_DWORD *)(a2 + 344);
    if ( *(_DWORD *)(v22 + 36) != 1 )
    {
      v23 = calloc(24 * *(_DWORD *)(v22 + 4), 1u);
      if ( v23 )
      {
        v24 = 0;
        *(_DWORD *)(v22 + 24) = (((2 * *(_DWORD *)(v22 + 4) - 1) & *(_DWORD *)(v22 + 12)) != 0)
                              + (*(_DWORD *)(v22 + 12) >> (*(_BYTE *)(v22 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a2 + 344) + 28) = 0;
        v25 = *(_DWORD *)(a2 + 344);
        v26 = *(_DWORD *)(v25 + 4);
        if ( v26 )
        {
          for ( i = 0; i < v26; ++i )
          {
            v27 = *(_DWORD **)(*(_DWORD *)v25 + v24);
            if ( v27 )
            {
              while ( 1 )
              {
                v28 = (_DWORD *)v27[4];
                v29 = 3 * ((2 * v26 - 1) & v27[7]);
                v30 = (char *)&v23[v29];
                v31 = *((_DWORD *)v30 + 1) + 1;
                *((_DWORD *)v30 + 1) = v31;
                if ( v31 > *(_DWORD *)(v25 + 24) )
                {
                  ++*(_DWORD *)(v25 + 28);
                  *((_DWORD *)v30 + 2) = sub_4A2D0(*((_DWORD *)v30 + 1), *(_DWORD *)(*(_DWORD *)(a2 + 344) + 24));
                }
                v27[3] = 0;
                v27[4] = v23[v29];
                v32 = v23[v29];
                if ( v32 )
                  *(_DWORD *)(v32 + 12) = v27;
                v23[v29] = v27;
                v25 = *(_DWORD *)(a2 + 344);
                if ( !v28 )
                  break;
                v26 = *(_DWORD *)(v25 + 4);
                v27 = v28;
              }
              v26 = *(_DWORD *)(v25 + 4);
            }
            v24 += 12;
          }
        }
        free(*(void **)v25);
        *(_DWORD *)(*(_DWORD *)(a2 + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a2 + 344) + 8);
        **(_DWORD **)(a2 + 344) = v23;
        v33 = *(_DWORD **)(a2 + 344);
        v34 = v33[7];
        v35 = v33[3];
        v36 = v34 > v35 >> 1;
        if ( v34 <= v35 >> 1 )
          v37 = 0;
        else
          v37 = v33[8];
        if ( v36 )
          ++v37;
        v33[8] = v37;
        v38 = *(_DWORD *)(a2 + 344);
        if ( *(_DWORD *)(v38 + 32) > 1u )
          *(_DWORD *)(v38 + 36) = 1;
        return;
      }
LABEL_31:
      exit(-1);
    }
  }
}

//----- (0002BFEC) --------------------------------------------------------
int __fastcall sub_2BFEC(int a1, void *s2, size_t n, const void *a4, int a5, size_t na)
{
  int v6; // r5
  int v7; // r4

  v6 = a1;
  if ( a1 )
  {
    v7 = *(_DWORD *)(a1 + 352);
    while ( memcmp((const void *)(v6 + 128), s2, n) || memcmp((const void *)(v6 + a5), a4, na) )
    {
      v6 = v7;
      if ( !v7 )
        return v7;
      v7 = *(_DWORD *)(v7 + 352);
    }
  }
  return v6;
}

//----- (0002C05C) --------------------------------------------------------
int __fastcall sub_2C05C(int result, int a2)
{
  int v2; // r3

  if ( result )
  {
    v2 = *(_DWORD *)(result + 352);
    if ( a2 != *(_DWORD *)(result + 340) )
    {
      if ( v2 )
      {
        result = *(_DWORD *)(v2 + 352);
        while ( *(_DWORD *)(v2 + 340) != a2 )
        {
          v2 = result;
          if ( !result )
            return result;
          result = *(_DWORD *)(result + 352);
        }
      }
      return v2;
    }
  }
  return result;
}

//----- (0002C0A8) --------------------------------------------------------
void __fastcall sub_2C0A8(int a1, _DWORD *a2)
{
  int v2; // r12
  int v3; // r2
  int v4; // lr
  _DWORD *v5; // r12
  int v6; // r3
  int v7; // r4
  int v8; // r3
  _DWORD *v9; // r2
  int v10; // r3
  int v11; // r2
  int v12; // r2
  int v13; // r3

  v2 = *(_DWORD *)(a1 + 352);
  --*(_DWORD *)(a1 + 360);
  v3 = a2[87];
  if ( !v3 )
  {
    v7 = a2[88];
    v4 = *(_DWORD *)(v2 + 344);
    if ( !v7 )
    {
      free(*(void **)v4);
      free(*(void **)(*(_DWORD *)(a1 + 352) + 344));
      *(_DWORD *)(a1 + 352) = 0;
      return;
    }
    v6 = *(_DWORD *)(v4 + 20);
    v5 = a2 + 86;
    if ( a2 != (_DWORD *)(*(_DWORD *)(v4 + 16) - v6) )
      goto LABEL_17;
    goto LABEL_13;
  }
  v4 = *(_DWORD *)(v2 + 344);
  v5 = a2 + 86;
  v6 = *(_DWORD *)(v4 + 20);
  if ( a2 == (_DWORD *)(*(_DWORD *)(v4 + 16) - v6) )
  {
LABEL_13:
    *(_DWORD *)(v4 + 16) = v3 + v6;
    v3 = a2[87];
    if ( v3 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20);
      goto LABEL_3;
    }
    v7 = a2[88];
LABEL_17:
    *(_DWORD *)(a1 + 352) = v7;
    goto LABEL_4;
  }
LABEL_3:
  *(_DWORD *)(v3 + v6 + 8) = a2[88];
  v7 = *(_DWORD *)(a1 + 352);
LABEL_4:
  v8 = a2[88];
  v9 = *(_DWORD **)(v7 + 344);
  if ( v8 )
  {
    *(_DWORD *)(v8 + v9[5] + 4) = a2[87];
    v9 = *(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  }
  v10 = 12 * ((v9[1] - 1) & a2[93]);
  --*(_DWORD *)(*v9 + v10 + 4);
  v11 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
  if ( *(_DWORD **)(v11 + v10) == v5 )
    *(_DWORD *)(v11 + v10) = a2[90];
  v12 = a2[89];
  v13 = a2[90];
  if ( v12 )
  {
    *(_DWORD *)(v12 + 16) = v13;
    v13 = a2[90];
  }
  if ( v13 )
    *(_DWORD *)(v13 + 12) = a2[89];
  --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 12);
}

//----- (0002C218) --------------------------------------------------------
int __fastcall sub_2C218(int result)
{
  if ( *(_DWORD *)(result + 32) != 1 )
    return (*(int (**)(void))(*(_DWORD *)(result + 4) + 16))();
  return result;
}

//----- (0002C230) --------------------------------------------------------
void __fastcall __noreturn sub_2C230(int a1, int a2)
{
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  if ( !pthread_create(newthread, 0, (void *(*)(void *))sub_28F68, 0) )
  {
    if ( a2 )
      sub_2F420(0);
    if ( dword_68B0C > 0 )
    {
      kill(dword_68B0C, 15);
      dword_68B0C = 0;
    }
    pthread_cancel(newthread[0]);
    exit(a1);
  }
  exit(1);
}
// 68B0C: using guessed type int dword_68B0C;

//----- (0002C2B0) --------------------------------------------------------
void __noreturn sub_2C2B0()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  sub_23220((int)sub_2FA50, 0, 5000);
  strcpy(v0, "Shutdown signal received.");
  sub_1DD60(3, v0, 1);
  sub_2C230(0, 1);
}

//----- (0002C30C) --------------------------------------------------------
void __noreturn sub_2C30C()
{
  sigaction(15, &stru_72DD0, 0);
  sigaction(2, &stru_76084, 0);
  sigaction(6, &stru_76238, 0);
  sub_2C2B0();
}
// 72DD0: using guessed type struct sigaction stru_72DD0;
// 76084: using guessed type struct sigaction stru_76084;
// 76238: using guessed type struct sigaction stru_76238;

//----- (0002C350) --------------------------------------------------------
int __fastcall sub_2C350(char *a1, size_t a2, int a3)
{
  double v3; // d0
  double v7; // r0
  double v8; // d8
  unsigned __int64 v9; // r8
  int v10; // r1
  unsigned __int64 v11; // r0
  size_t v12; // r7
  char v14[16]; // [sp+28h] [bp-864h] BYREF
  char v15[16]; // [sp+38h] [bp-854h] BYREF
  char s[64]; // [sp+48h] [bp-844h] BYREF
  char v17[2052]; // [sp+88h] [bp-804h] BYREF

  sub_2A7A0(a3);
  LODWORD(v7) = sub_4AB14(*(_QWORD *)(a3 + 192));
  v8 = v7 / v3;
  LODWORD(v9) = sub_4ABD0(*(double *)(a3 + 48) * 1000000.0);
  HIDWORD(v9) = v10;
  LODWORD(v11) = sub_4ABD0(*(double *)(a3 + 80) / v3 * 1000000.0);
  sub_287D8(v11, v14, 0x10u, 4);
  sub_287D8(v9, v15, 0x10u, 4);
  snprintf(a1, a2, "%s%d ", *(const char **)(*(_DWORD *)(a3 + 4) + 8), *(_DWORD *)(a3 + 8));
  (*(void (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 20))(a1, a2, a3);
  v12 = strlen(a1);
  snprintf(
    s,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    dword_681D0,
    v15,
    v14,
    *(double *)(a3 + 200),
    *(double *)(a3 + 208),
    *(_DWORD *)(a3 + 44),
    v8 * 60.0);
  if ( v12 + strlen(s) >= a2 )
  {
    snprintf(v17, 0x800u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3182);
    sub_1DD60(3, v17, 1);
    sub_2C230(1);
  }
  strcat(a1, s);
  return (*(int (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 24))(a1, a2, a3);
}
// 2C394: variable 'v7' is possibly undefined
// 2C394: variable 'v3' is possibly undefined
// 2C3B8: variable 'v10' is possibly undefined
// 2C3D8: variable 'v11' is possibly undefined
// 1DD60: using guessed type int __fastcall sub_1DD60(_DWORD, _DWORD, _DWORD);
// 2C230: using guessed type void __fastcall __noreturn sub_2C230(_DWORD);
// 681D0: using guessed type int dword_681D0;

//----- (0002C524) --------------------------------------------------------
void __noreturn sub_2C524()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Failed to create restart thread");
  sub_1DD60(3, v0, 1);
  sub_2C230(1, 1);
}

//----- (0002C568) --------------------------------------------------------
int sub_2C568()
{
  int result; // r0
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  sub_206A0(dword_68AEC);
  result = pthread_create(newthread, 0, (void *(*)(void *))sub_34994, 0);
  if ( result )
    sub_2C524();
  return result;
}
// 68AEC: using guessed type __time_t dword_68AEC[2];

//----- (0002C5A8) --------------------------------------------------------
int __fastcall sub_2C5A8(_BYTE *a1)
{
  char *v2; // r4
  bool v3; // r4
  int v4; // r5
  FILE *v6; // r2
  char *v7; // r0
  char **v8; // r9
  int v9; // r11
  char *v10; // r0
  int v11; // r1
  int v12; // r12
  char *v13; // lr
  int v14; // r11
  char *v15; // r12
  _BOOL4 v16; // r2
  size_t v17; // r0
  size_t v18; // r10
  char *v19; // r9
  const char *v20; // r5
  const char *v21; // r6
  const char *v22; // r2
  char *v23; // r9
  const char *v24; // r5
  const char *v25; // r6
  const char *v26; // r2
  int v27; // r0
  const char *nptr; // [sp+14h] [bp-C20h]
  char *v29; // [sp+1Ch] [bp-C18h] BYREF
  int v30; // [sp+20h] [bp-C14h]
  int v31; // [sp+24h] [bp-C10h]
  char *src; // [sp+28h] [bp-C0Ch]
  char *v33; // [sp+2Ch] [bp-C08h]
  char s[1024]; // [sp+30h] [bp-C04h] BYREF
  char v35[2052]; // [sp+430h] [bp-804h] BYREF

  if ( !dword_68B10 )
  {
    if ( !dword_72DB0 )
    {
      strcpy(v35, "BENCHFILE Invalid benchfile NULL");
      sub_1DD60(3, v35, 1);
      sub_2C230(1, 1);
    }
    v6 = (FILE *)fopen64(dword_72DB0, "r");
    dword_68B10 = (int)v6;
    if ( v6 )
    {
      dword_68B14 = 0;
      if ( !fgets(s, 1024, v6) )
      {
        snprintf(v35, 0x800u, "BENCHFILE Failed to read benchfile '%s'", dword_72DB0);
        goto LABEL_13;
      }
      dword_68B18 = 0;
      while ( 1 )
      {
LABEL_3:
        v3 = s[0] != 35;
        if ( !s[0] )
          v3 = 0;
        v4 = dword_68B14 + 1;
        v2 = (char *)(s[0] != 47 && v3);
        ++dword_68B14;
        if ( v2 )
          break;
        if ( !fgets(s, 1024, (FILE *)dword_68B10) )
          goto LABEL_10;
      }
      v7 = s;
      v8 = &v29;
      v9 = 0;
      v29 = s;
      do
      {
        v10 = strchr(v7, 44);
        v8[1] = v10;
        v11 = v9 + 1;
        if ( !v10 )
        {
          snprintf(
            v35,
            0x800u,
            "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
            v4,
            v9 + 1,
            5);
          goto LABEL_13;
        }
        v12 = (int)*v8++;
        v13 = (char *)dword_4EA18[2 * v9];
        v14 = 8 * v9;
        v15 = &v10[-v12];
        v16 = v13 != v15;
        if ( !v13 )
          v16 = 0;
        if ( v16 )
        {
          snprintf(
            v35,
            0x800u,
            "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
            v4,
            v11,
            *(const char **)&aJsonEscape[v14 + 160],
            v15,
            v13);
          goto LABEL_13;
        }
        *v10 = 0;
        v7 = v10 + 1;
        v9 = v11;
        *v8 = v7;
      }
      while ( v11 != 4 );
      nptr = v33;
      v17 = strlen(v33);
      if ( v17 > 9 )
      {
        sprintf(v35, "0000000%c", (unsigned __int8)*v29);
        v18 = strlen(v35);
        v19 = &v35[v18];
        v20 = (const char *)(v31 + 56);
        v21 = (const char *)(v31 - 8);
        do
        {
          v22 = v20;
          v20 -= 8;
          sprintf(v19, "%.8s", v22);
          v19 += 8;
        }
        while ( v21 != v20 );
        v23 = &v35[v18 + 64];
        v24 = (const char *)(v30 + 56);
        v25 = (const char *)(v30 - 8);
        do
        {
          v26 = v24;
          v24 -= 8;
          sprintf(v23, "%.8s", v26);
          v23 += 8;
        }
        while ( v25 != v24 );
        v27 = strtol(nptr, 0, 10);
        sprintf(&v35[v18 + 128], "%08lx", v27);
        strcpy(&v35[v18 + 136], src);
        memset(a1, 0, 0x1C0u);
        sub_1FB44(a1, (unsigned __int8 *)v35, (int)(v18 + 144) >> 1);
        sub_28C84((int)a1);
        ++dword_68B18;
        return (int)v2;
      }
      snprintf(
        v35,
        0x800u,
        "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
        v4,
        5,
        "NonceTime",
        v17,
        10);
    }
    else
    {
      snprintf(v35, 0x800u, "BENCHFILE Failed to open benchfile '%s'", dword_72DB0);
    }
LABEL_13:
    sub_1DD60(3, v35, 1);
    sub_2C230(1, 1);
  }
  v2 = fgets(s, 1024, (FILE *)dword_68B10);
  if ( v2 )
    goto LABEL_3;
LABEL_10:
  if ( !dword_68B18 )
  {
    snprintf(v35, 0x800u, "BENCHFILE No work in benchfile '%s'", dword_72DB0);
    goto LABEL_13;
  }
  fclose((FILE *)dword_68B10);
  dword_68B10 = (int)v2;
  return sub_2C5A8(a1);
}
// 12830: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 4EA18: using guessed type _DWORD[10];
// 68B10: using guessed type int dword_68B10;
// 68B14: using guessed type int dword_68B14;
// 68B18: using guessed type int dword_68B18;
// 72DB0: using guessed type int dword_72DB0;

//----- (0002C9B4) --------------------------------------------------------
void __fastcall __noreturn sub_2C9B4(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_2C230(1, 1);
}

//----- (0002CA10) --------------------------------------------------------
int __fastcall sub_2CA10(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_mutex_init(a1, 0);
  if ( result )
    sub_2C9B4(a2, a3);
  return result;
}

//----- (0002CA38) --------------------------------------------------------
void __fastcall __noreturn sub_2CA38(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_2C230(1, 1);
}

//----- (0002CA94) --------------------------------------------------------
int __fastcall sub_2CA94(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_init(a1, 0);
  if ( result )
    sub_2CA38(a2, a3);
  return result;
}

//----- (0002CABC) --------------------------------------------------------
int __fastcall sub_2CABC(int a1, const char *a2, int a3)
{
  int result; // r0

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    sub_2C9B4(a2, a3);
  result = pthread_rwlock_init((pthread_rwlock_t *)(a1 + 24), 0);
  if ( result )
    sub_2CA38(a2, a3);
  return result;
}

//----- (0002CB04) --------------------------------------------------------
void __fastcall __noreturn sub_2CB04(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_2C230(1, 1);
}

//----- (0002CB60) --------------------------------------------------------
void __fastcall __noreturn sub_2CB60(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_2C230(1, 1);
}

//----- (0002CBBC) --------------------------------------------------------
void __fastcall __noreturn sub_2CBBC(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_2C230(1, 1);
}

//----- (0002CC18) --------------------------------------------------------
int __fastcall sub_2CC18(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    sub_2CB60("pool_tset", 815);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( pthread_mutex_unlock(v4) )
    sub_2CBBC("pool_tset", 820);
  off_67964();
  return v5;
}
// 67964: using guessed type int (*off_67964)();

//----- (0002CC84) --------------------------------------------------------
int __fastcall sub_2CC84(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_mutex_t *v4; // r0
  int v5; // r4

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    sub_2CB60("pool_tclear", 830);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( pthread_mutex_unlock(v4) )
    sub_2CBBC("pool_tclear", 835);
  off_67964();
  return v5;
}
// 67964: using guessed type int (*off_67964)();

//----- (0002CCEC) --------------------------------------------------------
int __fastcall sub_2CCEC(_DWORD *a1, int a2)
{
  int v4; // r6
  int v5; // r2
  int v6; // r3
  const char *v7; // r0
  int v9; // r7
  int *v10; // r12
  int v11; // r0
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int *v15; // r12
  int v16; // r0
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r12
  const char *v21; // r1
  size_t v22; // r2
  int v23; // r3
  __time_t v24[2]; // [sp+Ch] [bp-834h] BYREF
  __time_t v25[2]; // [sp+14h] [bp-82Ch] BYREF
  pthread_attr_t attr; // [sp+1Ch] [bp-824h] BYREF
  char s[2048]; // [sp+40h] [bp-800h] BYREF

  if ( *((_BYTE *)a1 + 752) )
  {
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(s, 0x800u, "Retrieving block template from pool %s", (const char *)a1[41]);
      sub_1DD60(7, s, 0);
    }
  }
  else if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
  {
    snprintf(s, 0x800u, "Testing pool %s", (const char *)a1[41]);
    sub_1DD60(6, s, 0);
  }
  v4 = *((unsigned __int8 *)a1 + 656);
  if ( *((_BYTE *)a1 + 656) )
    goto LABEL_38;
  if ( off_681D4 )
  {
    if ( *((_BYTE *)a1 + 99) )
      goto LABEL_15;
    if ( !byte_686E1 )
    {
      *((_BYTE *)a1 + 99) = v4;
      goto LABEL_15;
    }
    if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
    {
      strcpy(s, "Probing for GBT support");
      sub_1DD60(7, s, 0);
      v5 = *((unsigned __int8 *)a1 + 752);
      v6 = (unsigned __int8)byte_686E1;
      *((_BYTE *)a1 + 99) = 0;
      if ( !v5 )
      {
        if ( !*((_BYTE *)a1 + 916) )
        {
          if ( !v6 )
            goto LABEL_15;
          if ( byte_72D90 )
            goto LABEL_66;
LABEL_64:
          if ( byte_686E0 || dword_67840 > 6 )
            goto LABEL_66;
LABEL_15:
          sub_206A0(v24);
          sub_206A0(v25);
          v7 = (const char *)a1[144];
          if ( !v7 || byte_68B1C )
            goto LABEL_98;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
          {
            snprintf(s, 0x800u, "Testing pool %d stratum %s", *a1, (const char *)a1[144]);
            sub_1DD60(6, s, 0);
            v7 = (const char *)a1[144];
          }
          if ( !sub_20A10(v7, a1 + 154, (char **)a1 + 146) || !sub_21DDC(a1) )
          {
LABEL_98:
            if ( *((_BYTE *)a1 + 656) || *((_BYTE *)a1 + 916) || *((_BYTE *)a1 + 752) )
            {
              if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
              {
                snprintf(s, 0x800u, "FAILED to retrieve work from pool %u %s", *a1, (const char *)a1[41]);
                sub_1DD60(7, s, 0);
              }
              if ( !a2 && !*((_BYTE *)a1 + 97) && (byte_72D90 || byte_686E0 || dword_67840 > 3) )
              {
                snprintf(s, 0x800u, "Pool %u slow/down or URL or credentials invalid", *a1);
                v4 = 0;
                sub_1DD60(4, s, 0);
              }
            }
            else if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
            {
              v4 = 0;
              snprintf(
                s,
                0x800u,
                "No Stratum, GBT or Solo support in pool %d %s unable to use",
                *a1,
                (const char *)a1[41]);
              sub_1DD60(4, s, 0);
            }
            return v4;
          }
          if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
          {
            snprintf(s, 0x800u, "Switching pool %d %s to %s", *a1, (const char *)a1[41], (const char *)a1[144]);
            sub_1DD60(5, s, 0);
          }
          if ( !a1[41] )
            a1[41] = _strdup((const char *)a1[144]);
          *((_BYTE *)a1 + 656) = 1;
LABEL_38:
          v4 = sub_2CC18((int)a1, (_BYTE *)a1 + 658);
          if ( v4 )
            return *((unsigned __int8 *)a1 + 657);
          if ( !sub_24A54((pthread_mutex_t *)a1)
            || *((_BYTE *)a1 + 580) && !sub_27070((pthread_mutex_t *)a1)
            || !sub_21DDC(a1)
            || (v9 = sub_27468((pthread_mutex_t *)a1)) == 0 )
          {
            sub_2CC84((int)a1, (_BYTE *)a1 + 658);
            return v4;
          }
          byte_762C4 = 1;
          pthread_attr_init(&attr);
          pthread_attr_setstacksize(&attr, 0x100000u);
          if ( pthread_create(a1 + 178, &attr, (void *(*)(void *))sub_36B90, a1) )
          {
            v10 = (int *)&unk_5211C;
          }
          else
          {
            if ( !pthread_create(a1 + 179, &attr, (void *(*)(void *))sub_395C4, a1) )
              return v9;
            v10 = (int *)&unk_52140;
          }
          v11 = *v10;
          v12 = v10[1];
          v13 = v10[2];
          v14 = v10[3];
          v15 = v10 + 4;
          *(_DWORD *)s = v11;
          *(_DWORD *)&s[4] = v12;
          *(_DWORD *)&s[8] = v13;
          *(_DWORD *)&s[12] = v14;
          v16 = *v15;
          v17 = v15[1];
          v18 = v15[2];
          v19 = v15[3];
          v20 = v15[4];
          *(_DWORD *)&s[16] = v16;
          *(_DWORD *)&s[20] = v17;
          *(_DWORD *)&s[24] = v18;
          *(_DWORD *)&s[28] = v19;
          s[32] = v20;
          sub_1DD60(3, s, 1);
          sub_2C230(1, 1);
        }
        if ( !v6 )
          goto LABEL_15;
LABEL_55:
        if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
        {
          v21 = "GBT coinbase without append found, switching to GBT solo protocol";
          v22 = 66;
LABEL_59:
          memcpy(s, v21, v22);
          sub_1DD60(7, s, 0);
          goto LABEL_15;
        }
        goto LABEL_15;
      }
      if ( !v6 )
        goto LABEL_15;
    }
    else
    {
      v23 = *((unsigned __int8 *)a1 + 752);
      *((_BYTE *)a1 + 99) = v4;
      if ( !v23 )
      {
        if ( !*((_BYTE *)a1 + 916) )
        {
          if ( byte_72D90 )
          {
LABEL_66:
            v21 = "No GBT coinbase + append support found, pool unusable if it has no stratum";
            v22 = 75;
            goto LABEL_59;
          }
          goto LABEL_64;
        }
        goto LABEL_55;
      }
    }
    if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
    {
      strcpy(s, "GBT coinbase + append support found, switching to GBT protocol");
      sub_1DD60(7, s, 0);
    }
    goto LABEL_15;
  }
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
    return v4;
  strcpy(s, "CURL initialisation failed");
  sub_1DD60(3, s, 0);
  return v4;
}
// 67840: using guessed type int dword_67840;
// 681D4: using guessed type char *off_681D4;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68B1C: using guessed type char byte_68B1C;
// 72D90: using guessed type char byte_72D90;
// 762C4: using guessed type char byte_762C4;

//----- (0002D4CC) --------------------------------------------------------
int __fastcall sub_2D4CC(int a1, int a2)
{
  if ( pthread_mutex_lock(&stru_72D94) )
    sub_2CB60("inc_dev_status", 8863);
  dword_76064 = a1;
  dword_761DC = a2;
  if ( pthread_mutex_unlock(&stru_72D94) )
    sub_2CBBC("inc_dev_status", 8866);
  return off_67964();
}
// 67964: using guessed type int (*off_67964)();
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 76064: using guessed type int dword_76064;
// 761DC: using guessed type int dword_761DC;

//----- (0002D548) --------------------------------------------------------
int sub_2D548()
{
  if ( pthread_mutex_lock((pthread_mutex_t *)dword_68B20) )
    sub_2CB60("wake_gws", 5432);
  pthread_cond_signal(&stru_72E68);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_68B20) )
    sub_2CBBC("wake_gws", 5434);
  return off_67964();
}
// 67964: using guessed type int (*off_67964)();
// 68B20: using guessed type int dword_68B20;
// 72E68: using guessed type pthread_cond_t stru_72E68;

//----- (0002D5B0) --------------------------------------------------------
int __fastcall sub_2D5B0(int a1, unsigned int a2)
{
  unsigned int v4; // r4
  int v5; // r1
  __time_t v6; // r4
  int v7; // r1
  int v8; // r4
  __time_t v10[2]; // [sp+0h] [bp-10h] BYREF
  struct timespec abstime; // [sp+8h] [bp-8h] BYREF

  v4 = a2 / 0x3E8;
  sub_206A0(v10);
  v5 = 1000 * a2 - 1000000 * v4;
  v6 = v4 + v10[0];
  v7 = v5 + v10[1];
  if ( v7 > 999999 )
  {
    ++v6;
    v7 -= 1000000;
  }
  abstime.tv_sec = v6;
  abstime.tv_nsec = 1000 * v7;
  v8 = pthread_mutex_lock(&stru_74F6C);
  if ( v8 )
    sub_2CB60("restart_wait", 5485);
  if ( !*(_BYTE *)(a1 + 62) )
    v8 = pthread_cond_timedwait(&stru_76198, &stru_74F6C, &abstime);
  if ( pthread_mutex_unlock(&stru_74F6C) )
    sub_2CBBC("restart_wait", 5495);
  off_67964();
  return v8;
}
// 67964: using guessed type int (*off_67964)();
// 74F6C: using guessed type pthread_mutex_t stru_74F6C;
// 76198: using guessed type pthread_cond_t stru_76198;

//----- (0002D6AC) --------------------------------------------------------
void __fastcall __noreturn sub_2D6AC(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_2C230(1);
}
// 1DD60: using guessed type int __fastcall sub_1DD60(_DWORD, _DWORD, _DWORD);
// 2C230: using guessed type void __fastcall __noreturn sub_2C230(_DWORD);

//----- (0002D708) --------------------------------------------------------
int __fastcall sub_2D708(pthread_rwlock_t *a1, const char *a2, int a3)
{
  if ( pthread_rwlock_unlock(a1) )
    sub_2D6AC(a2, a3);
  return off_67964();
}
// 67964: using guessed type int (*off_67964)();

//----- (0002D740) --------------------------------------------------------
int sub_2D740()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_76148) )
    sub_2CB60("total_work_inc", 2329);
  if ( pthread_rwlock_wrlock(&rwlock) )
    sub_2CB04("total_work_inc", 2329);
  v0 = dword_68B24++;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_2D6AC("total_work_inc", 2331);
  if ( pthread_mutex_unlock(&stru_76148) )
    sub_2CBBC("total_work_inc", 2331);
  off_67964();
  return v0;
}
// 67964: using guessed type int (*off_67964)();
// 68B24: using guessed type int dword_68B24;
// 76148: using guessed type pthread_mutex_t stru_76148;

//----- (0002D7F0) --------------------------------------------------------
int __fastcall sub_2D7F0(int a1)
{
  int v2; // r1
  bool v3; // zf
  unsigned int v4; // r3
  int v5; // r0
  _BYTE *v6; // r5
  int result; // r0
  unsigned int v8[513]; // [sp+0h] [bp-804h] BYREF

  v2 = dword_72F14;
  v3 = byte_686E1 == 0;
  v4 = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + 1);
  v5 = *(_DWORD *)(a1 + 240) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  *(_DWORD *)(a1 + 240) = v5;
  *(_DWORD *)(a1 + 248) = 0;
  dword_72F14 = v2 + 1;
  if ( !v3 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy((char *)v8, "Successfully rolled work");
    sub_1DD60(7, (const char *)v8, 0);
  }
  v6 = *(_BYTE **)(a1 + 308);
  if ( v6 )
  {
    sub_1FB44(v8, *(unsigned __int8 **)(a1 + 308), 4);
    v8[0] = bswap32(bswap32(v8[0]) + 1);
    sub_1FA20(v6, (int)v8, 4);
  }
  result = sub_2D740();
  *(_DWORD *)(a1 + 340) = result;
  return result;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 72F14: using guessed type int dword_72F14;

//----- (0002D914) --------------------------------------------------------
_DWORD *sub_2D914()
{
  _DWORD *v0; // r4
  char v2[2048]; // [sp+8h] [bp-800h] BYREF

  v0 = sub_1F8B0(1u, 0x1C0u, "cgminer.c", "make_work", 2338);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc work in make_work");
    sub_1DD60(3, v2, 1);
    sub_2C230(1, 1);
  }
  v0[85] = sub_2D740();
  return v0;
}

//----- (0002D9AC) --------------------------------------------------------
_DWORD *__fastcall sub_2D9AC(int a1, int a2)
{
  _DWORD *v4; // r4

  v4 = sub_2D914();
  sub_2A5F4((int)v4, a1, a2);
  return v4;
}

//----- (0002D9D4) --------------------------------------------------------
_DWORD *__fastcall sub_2D9D4(int a1)
{
  _DWORD *v2; // r4
  int v3; // r3

  v2 = sub_2D914();
  sub_2A5F4((int)v2, a1, 0);
  *((_BYTE *)v2 + 273) = 1;
  sub_206A0(v2 + 104);
  v3 = v2[66];
  *((_BYTE *)v2 + 280) = 0;
  *((_BYTE *)v2 + 282) = 0;
  v2[66] = v3 - 1;
  return v2;
}

//----- (0002DA20) --------------------------------------------------------
int __fastcall sub_2DA20(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2CB04("add_queued", 9526);
  sub_2BBB4((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_2D6AC("add_queued", 9528);
  return off_67964();
}
// 67964: using guessed type int (*off_67964)();

//----- (0002DA8C) --------------------------------------------------------
void __fastcall sub_2DA8C(pthread_rwlock_t *a1, void **a2)
{
  pthread_rwlock_t *v2; // r4
  void **v4; // [sp+4h] [bp-8h] BYREF

  v2 = a1 + 10;
  v4 = a2;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2CB04("work_completed", 9678);
  sub_2C0A8((int)a1, v4);
  if ( pthread_rwlock_unlock(v2) )
    sub_2D6AC("work_completed", 9680);
  off_67964();
  sub_2A70C(&v4, "cgminer.c", "work_completed", 9682);
}
// 67964: using guessed type int (*off_67964)();

//----- (0002DB18) --------------------------------------------------------
_DWORD *__fastcall sub_2DB18(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r5
  _DWORD *v11; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2CB04("take_queued_work_bymidstate", 9691);
  v11 = (_DWORD *)sub_2BFEC(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
    sub_2C0A8((int)a1, v11);
  if ( pthread_rwlock_unlock(v6) )
    sub_2D6AC("take_queued_work_bymidstate", 9695);
  off_67964();
  return v11;
}
// 67964: using guessed type int (*off_67964)();

//----- (0002DBC4) --------------------------------------------------------
int __fastcall sub_2DBC4(pthread_rwlock_t *a1)
{
  int i; // r4
  int lock; // [sp+4h] [bp-10h]
  __time_t v5[3]; // [sp+8h] [bp-Ch] BYREF

  sub_206A0(v5);
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2CB04("age_queued_work", 9657);
  lock = a1[11].__lock;
  if ( lock )
  {
    for ( i = *(_DWORD *)(lock + 352); ; i = *(_DWORD *)(i + 352) )
    {
      sub_209CC();
      if ( !i )
        break;
    }
  }
  if ( pthread_rwlock_unlock(a1 + 10) )
    sub_2D6AC("age_queued_work", 9668);
  off_67964();
  return 0;
}
// 67964: using guessed type int (*off_67964)();

//----- (0002DCC0) --------------------------------------------------------
void __fastcall __noreturn sub_2DCC0(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_2C230(1);
}
// 1DD60: using guessed type int __fastcall sub_1DD60(_DWORD, _DWORD, _DWORD);
// 2C230: using guessed type void __fastcall __noreturn sub_2C230(_DWORD);

//----- (0002DD1C) --------------------------------------------------------
_DWORD *__fastcall sub_2DD1C(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r7
  _DWORD *lock; // r4
  int v6; // r5

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_2DCC0("clone_queued_work_byid", 9631);
  lock = (_DWORD *)a1[11].__lock;
  if ( lock )
  {
    v6 = lock[88];
    if ( a2 == lock[85] )
    {
      v6 = (int)lock;
    }
    else
    {
      if ( !v6 )
      {
        lock = 0;
        goto LABEL_10;
      }
      lock = *(_DWORD **)(v6 + 352);
      while ( a2 != *(_DWORD *)(v6 + 340) )
      {
        if ( !lock )
          goto LABEL_10;
        v6 = (int)lock;
        lock = (_DWORD *)lock[88];
      }
    }
    lock = sub_2D914();
    sub_2A5F4((int)lock, v6, 0);
  }
LABEL_10:
  if ( pthread_rwlock_unlock(v2) )
    sub_2D6AC("clone_queued_work_byid", 9635);
  off_67964();
  return lock;
}
// 67964: using guessed type int (*off_67964)();

//----- (0002DDE8) --------------------------------------------------------
_DWORD *__fastcall sub_2DDE8(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5
  _DWORD *v12; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_2DCC0("clone_queued_work_bymidstate", 9584);
  v11 = sub_2BFEC(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
  {
    v12 = sub_2D914();
    sub_2A5F4((int)v12, v11, 0);
  }
  else
  {
    v12 = 0;
  }
  if ( pthread_rwlock_unlock(v6) )
    sub_2D6AC("clone_queued_work_bymidstate", 9588);
  off_67964();
  return v12;
}
// 67964: using guessed type int (*off_67964)();

//----- (0002DEA4) --------------------------------------------------------
int __fastcall sub_2DEA4(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  int lock; // r4
  int v6; // r3

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_2DCC0("find_queued_work_byid", 9619);
  lock = a1[11].__lock;
  if ( lock )
  {
    v6 = *(_DWORD *)(lock + 352);
    if ( a2 != *(_DWORD *)(lock + 340) )
    {
      if ( v6 )
      {
        lock = *(_DWORD *)(v6 + 352);
        while ( a2 != *(_DWORD *)(v6 + 340) )
        {
          if ( !lock )
            goto LABEL_10;
          v6 = lock;
          lock = *(_DWORD *)(lock + 352);
        }
      }
      lock = v6;
    }
  }
LABEL_10:
  if ( pthread_rwlock_unlock(v2) )
    sub_2D6AC("find_queued_work_byid", 9621);
  off_67964();
  return lock;
}
// 67964: using guessed type int (*off_67964)();

//----- (0002DF58) --------------------------------------------------------
int __fastcall sub_2DF58(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_2DCC0("find_queued_work_bymidstate", 9572);
  v11 = sub_2BFEC(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( pthread_rwlock_unlock(v6) )
    sub_2D6AC("find_queued_work_bymidstate", 9574);
  off_67964();
  return v11;
}
// 67964: using guessed type int (*off_67964)();

//----- (0002DFF4) --------------------------------------------------------
int __fastcall sub_2DFF4(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_74FC0) )
    sub_2DCC0("get_devices", 636);
  v2 = *(_DWORD *)(dword_74F68 + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_74FC0) )
    sub_2D6AC("get_devices", 638);
  off_67964();
  return v2;
}
// 67964: using guessed type int (*off_67964)();
// 74F68: using guessed type int dword_74F68;
// 74FC0: using guessed type pthread_rwlock_t stru_74FC0;

//----- (0002E068) --------------------------------------------------------
int sub_2E068()
{
  int v0; // r12
  int v1; // r2
  double v2; // d9
  int v3; // r8
  int v4; // r6
  int v5; // r10
  double v6; // r0
  double v7; // d10
  double v8; // r0
  double v9; // d10
  double v10; // d8
  double v11; // d7
  __int64 v12; // r6
  __int64 v13; // kr08_8
  __int64 v14; // r0
  int v15; // r1
  double v16; // d9
  double v17; // r0
  int v18; // r8
  int v19; // r6
  int v20; // r3
  const char *v21; // r1
  __int64 v22; // r10
  __int64 v23; // r0
  int v24; // r1
  double v25; // d8
  double v26; // r0
  int v27; // r5
  int v28; // r0
  int v29; // r1
  int v30; // r3
  double v31; // d7
  unsigned int v33; // [sp+10h] [bp-91Ch]
  unsigned int v34; // [sp+14h] [bp-918h]
  char v35[256]; // [sp+28h] [bp-904h] BYREF
  char s[2052]; // [sp+128h] [bp-804h] BYREF

  v0 = dword_68B28 - dword_68B30;
  LOWORD(v1) = -30583;
  if ( dword_68B2C - dword_68B34 < 0 )
    --v0;
  HIWORD(v1) = -30584;
  v2 = dbl_681C0;
  v3 = v0 / 3600;
  v4 = v0 - 60 * (((int)(v0 + ((unsigned __int64)(v0 * (__int64)v1) >> 32)) >> 5) - (v0 >> 31));
  v5 = ((int)(v0 % 3600 + ((unsigned __int64)(v0 % 3600 * (__int64)v1) >> 32)) >> 5) - ((v0 % 3600) >> 31);
  LODWORD(v6) = sub_4AB14(*(__int64 *)&dword_72EF0);
  v7 = v6 / v2;
  LODWORD(v8) = sub_4AB14(*(__int64 *)&dword_72DC8);
  v9 = v7 * 60.0;
  v10 = v8 / v2 * 60.0;
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3
    || (strcpy(s, "\nSummary of runtime statistics:\n"), sub_1DD60(4, s, 0), !byte_72D90)
    && !byte_686E0
    && dword_67840 <= 3 )
  {
    if ( dword_72E60 == 1 )
      goto LABEL_156;
LABEL_8:
    if ( byte_72D90 || byte_686E0 )
      goto LABEL_10;
    goto LABEL_137;
  }
  snprintf(s, 0x800u, "Started at %s", byte_68B38);
  sub_1DD60(4, s, 0);
  if ( dword_72E60 != 1 )
    goto LABEL_8;
  if ( byte_72D90 || byte_686E0 )
    goto LABEL_157;
LABEL_156:
  if ( dword_67840 > 3 )
  {
LABEL_157:
    snprintf(s, 0x800u, "Pool: %s", *(const char **)(*(_DWORD *)dword_72F04 + 164));
    sub_1DD60(4, s, 0);
    goto LABEL_8;
  }
LABEL_137:
  if ( dword_67840 <= 3 )
  {
    v11 = dbl_72D88 / dbl_681C0;
    goto LABEL_139;
  }
LABEL_10:
  snprintf(s, 0x800u, "Runtime: %d hrs : %d mins : %d secs", v3, v5, v4);
  sub_1DD60(4, s, 0);
  v11 = dbl_72D88 / dbl_681C0;
  if ( byte_72D90 || byte_686E0 )
  {
LABEL_12:
    snprintf(s, 0x800u, "Average hashrate: %.1f Mhash/s", v11);
    sub_1DD60(4, s, 0);
    if ( byte_72D90 || byte_686E0 )
      goto LABEL_14;
    goto LABEL_189;
  }
LABEL_139:
  if ( dword_67840 > 3 )
    goto LABEL_12;
LABEL_189:
  if ( dword_67840 <= 3 )
    goto LABEL_190;
LABEL_14:
  snprintf(s, 0x800u, "Solved blocks: %d", dword_76074);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 )
  {
LABEL_190:
    if ( dword_67840 <= 3 )
      goto LABEL_158;
  }
  snprintf(s, 0x800u, "Best share difficulty: %s", dword_681C8);
  sub_1DD60(4, s, 0);
  if ( byte_72D90 || byte_686E0 )
  {
LABEL_18:
    snprintf(s, 0x800u, "Share submissions: %lld", *(_QWORD *)&dword_72EF0 + qword_74FB8);
    sub_1DD60(4, s, 0);
    if ( byte_72D90 || byte_686E0 )
      goto LABEL_20;
    goto LABEL_159;
  }
LABEL_158:
  if ( dword_67840 > 3 )
    goto LABEL_18;
LABEL_159:
  if ( dword_67840 <= 3 )
    goto LABEL_160;
LABEL_20:
  snprintf(s, 0x800u, "Accepted shares: %lld", *(_QWORD *)&dword_72EF0);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 )
  {
LABEL_160:
    if ( dword_67840 <= 3 )
      goto LABEL_161;
  }
  snprintf(s, 0x800u, "Rejected shares: %lld", qword_74FB8);
  sub_1DD60(4, s, 0);
  if ( byte_72D90 || byte_686E0 )
  {
LABEL_24:
    snprintf(s, 0x800u, "Accepted difficulty shares: %1.f", dbl_74F28);
    sub_1DD60(4, s, 0);
    if ( byte_72D90 || byte_686E0 )
      goto LABEL_26;
    goto LABEL_162;
  }
LABEL_161:
  if ( dword_67840 > 3 )
    goto LABEL_24;
LABEL_162:
  if ( dword_67840 <= 3 )
  {
    v12 = *(_QWORD *)&dword_72EF0;
    if ( *(_QWORD *)&dword_72EF0 )
      goto LABEL_164;
    goto LABEL_54;
  }
LABEL_26:
  snprintf(s, 0x800u, "Rejected difficulty shares: %1.f", dbl_74FB0);
  sub_1DD60(4, s, 0);
  v12 = *(_QWORD *)&dword_72EF0;
  if ( *(_QWORD *)&dword_72EF0 )
  {
    if ( !byte_72D90 )
      goto LABEL_28;
LABEL_29:
    v13 = qword_74FB8;
    HIDWORD(v14) = (unsigned __int64)(3 * qword_74FB8) >> 32;
    LODWORD(v14) = 96 * qword_74FB8;
    LODWORD(v16) = sub_4AB14(__PAIR64__((unsigned __int64)(96 * qword_74FB8) >> 32, 3 * (int)qword_74FB8) + v14 + qword_74FB8);
    HIDWORD(v16) = v15;
    LODWORD(v17) = sub_4AB14(v13 + v12);
    snprintf(s, 0x800u, "Reject ratio: %.1f%%", v16 / v17);
    sub_1DD60(4, s, 0);
LABEL_30:
    if ( byte_72D90 || byte_686E0 )
      goto LABEL_32;
    goto LABEL_145;
  }
LABEL_54:
  if ( !qword_74FB8 )
    goto LABEL_30;
  v12 = 0;
  if ( byte_72D90 )
    goto LABEL_29;
LABEL_28:
  if ( byte_686E0 )
    goto LABEL_29;
LABEL_164:
  if ( dword_67840 > 3 )
    goto LABEL_29;
LABEL_145:
  if ( dword_67840 <= 3 )
    goto LABEL_146;
LABEL_32:
  snprintf(s, 0x800u, "Hardware errors: %d", dword_76060);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
  {
LABEL_146:
    if ( dword_67840 <= 3 )
      goto LABEL_147;
    goto LABEL_36;
  }
  snprintf(s, 0x800u, "Utility (accepted shares / min): %.2f/min", v9);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
  {
LABEL_147:
    if ( dword_67840 <= 3 )
      goto LABEL_148;
    goto LABEL_38;
  }
LABEL_36:
  snprintf(s, 0x800u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v10);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
  {
LABEL_148:
    if ( dword_67840 <= 3 )
      goto LABEL_149;
    goto LABEL_40;
  }
LABEL_38:
  snprintf(s, 0x800u, "Stale submissions discarded due to new blocks: %lld", *(_QWORD *)&dword_762C8);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
  {
LABEL_149:
    if ( dword_67840 <= 3 )
      goto LABEL_150;
    goto LABEL_42;
  }
LABEL_40:
  snprintf(s, 0x800u, "Unable to get work from server occasions: %d", dword_72F08);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
  {
LABEL_150:
    if ( dword_67840 <= 3 )
      goto LABEL_151;
    goto LABEL_44;
  }
LABEL_42:
  snprintf(s, 0x800u, "Work items generated locally: %d", dword_72F14);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
  {
LABEL_151:
    if ( dword_67840 <= 3 )
      goto LABEL_152;
    goto LABEL_46;
  }
LABEL_44:
  snprintf(s, 0x800u, "Submitting work remotely delay occasions: %d", dword_72DAC);
  sub_1DD60(4, s, 0);
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
  {
LABEL_152:
    if ( dword_72E60 <= 1 )
      goto LABEL_141;
    goto LABEL_47;
  }
LABEL_46:
  snprintf(s, 0x800u, "New blocks detected on network: %d\n", dword_761D8);
  sub_1DD60(4, s, 0);
  if ( dword_72E60 > 1 )
  {
LABEL_47:
    v18 = 0;
    while ( 1 )
    {
      v19 = *(_DWORD *)(dword_72F04 + 4 * v18);
      if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
        break;
      v20 = *(_DWORD *)(v19 + 32);
      if ( v20 )
        goto LABEL_52;
LABEL_63:
      if ( !byte_686E0 )
      {
LABEL_110:
        if ( dword_67840 <= 3 )
          goto LABEL_111;
      }
LABEL_64:
      snprintf(s, 0x800u, " Share submissions: %lld", *(_QWORD *)(v19 + 8) + *(_QWORD *)(v19 + 16));
      sub_1DD60(4, s, 0);
      if ( byte_72D90 || byte_686E0 )
      {
LABEL_66:
        snprintf(s, 0x800u, " Accepted shares: %lld", *(_QWORD *)(v19 + 8));
        sub_1DD60(4, s, 0);
        if ( byte_72D90 || byte_686E0 )
          goto LABEL_68;
        goto LABEL_112;
      }
LABEL_111:
      if ( dword_67840 > 3 )
        goto LABEL_66;
LABEL_112:
      if ( dword_67840 <= 3 )
        goto LABEL_113;
LABEL_68:
      snprintf(s, 0x800u, " Rejected shares: %lld", *(_QWORD *)(v19 + 16));
      sub_1DD60(4, s, 0);
      if ( !byte_72D90 && !byte_686E0 )
      {
LABEL_113:
        if ( dword_67840 <= 3 )
          goto LABEL_114;
      }
      snprintf(s, 0x800u, " Accepted difficulty shares: %1.f", *(double *)(v19 + 72));
      sub_1DD60(4, s, 0);
      if ( byte_72D90 || byte_686E0 )
      {
LABEL_72:
        snprintf(s, 0x800u, " Rejected difficulty shares: %1.f", *(double *)(v19 + 80));
        sub_1DD60(4, s, 0);
        v22 = *(_QWORD *)(v19 + 8);
        if ( v22 )
          goto LABEL_75;
        goto LABEL_73;
      }
LABEL_114:
      if ( dword_67840 > 3 )
        goto LABEL_72;
      v22 = *(_QWORD *)(v19 + 8);
      if ( v22 )
      {
        if ( dword_67840 <= 3 )
          goto LABEL_117;
        goto LABEL_77;
      }
LABEL_73:
      if ( *(_QWORD *)(v19 + 16) )
      {
        v22 = 0;
LABEL_75:
        if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
        {
LABEL_117:
          if ( dword_67840 <= 3 )
            goto LABEL_118;
          goto LABEL_80;
        }
LABEL_77:
        v34 = *(_DWORD *)(v19 + 16);
        HIDWORD(v23) = (unsigned __int64)(3LL * *(_QWORD *)(v19 + 16)) >> 32;
        LODWORD(v23) = 96 * v34;
        v33 = *(_DWORD *)(v19 + 20);
        LODWORD(v25) = sub_4AB14(
                         __PAIR64__((unsigned __int64)(96LL * *(_QWORD *)(v19 + 16)) >> 32, 3 * v34)
                       + v23
                       + *(_QWORD *)(v19 + 16));
        HIDWORD(v25) = v24;
        LODWORD(v26) = sub_4AB14(__PAIR64__(v33, v34) + v22);
        snprintf(s, 0x800u, " Reject ratio: %.1f%%", v25 / v26);
        sub_1DD60(4, s, 0);
      }
      if ( !byte_72D90 && !byte_686E0 )
        goto LABEL_117;
LABEL_80:
      snprintf(s, 0x800u, " Items worked on: %d", *(_DWORD *)(v19 + 68));
      sub_1DD60(4, s, 0);
      if ( byte_72D90 || byte_686E0 )
      {
LABEL_82:
        snprintf(s, 0x800u, " Stale submissions discarded due to new blocks: %d", *(_DWORD *)(v19 + 120));
        sub_1DD60(4, s, 0);
        if ( byte_72D90 || byte_686E0 )
          goto LABEL_84;
        goto LABEL_119;
      }
LABEL_118:
      if ( dword_67840 > 3 )
        goto LABEL_82;
LABEL_119:
      if ( dword_67840 <= 3 )
        goto LABEL_120;
LABEL_84:
      snprintf(s, 0x800u, " Unable to get work from server occasions: %d", *(_DWORD *)(v19 + 128));
      sub_1DD60(4, s, 0);
      if ( !byte_72D90 && !byte_686E0 )
      {
LABEL_120:
        if ( dword_67840 <= 3 )
          goto LABEL_87;
      }
      snprintf(s, 0x800u, " Submitting work remotely delay occasions: %d\n", *(_DWORD *)(v19 + 132));
      sub_1DD60(4, s, 0);
LABEL_87:
      if ( dword_72E60 <= ++v18 )
        goto LABEL_88;
    }
    snprintf(s, 0x800u, "Pool: %s", *(const char **)(v19 + 164));
    sub_1DD60(4, s, 0);
    v20 = *(_DWORD *)(v19 + 32);
    if ( v20 )
    {
      if ( !byte_72D90 && !byte_686E0 )
      {
LABEL_52:
        if ( dword_67840 <= 3 )
          goto LABEL_110;
      }
      v21 = "S";
      if ( v20 <= 1 )
        v21 = "";
      snprintf(s, 0x800u, "SOLVED %d BLOCK%s!", v20, v21);
      sub_1DD60(4, s, 0);
    }
    if ( byte_72D90 )
      goto LABEL_64;
    goto LABEL_63;
  }
LABEL_88:
  if ( byte_72D90 || byte_686E0 )
    goto LABEL_90;
LABEL_141:
  if ( dword_67840 > 3 )
  {
LABEL_90:
    strcpy(s, "Summary of per device statistics:\n");
    sub_1DD60(4, s, 0);
  }
  if ( dword_74FE0 > 0 )
  {
    v27 = 0;
    do
    {
      v28 = sub_2DFF4(v27++);
      *(_DWORD *)(*(_DWORD *)(v28 + 4) + 20) = nullsub_1;
      *(_DWORD *)(*(_DWORD *)(v28 + 4) + 24) = nullsub_2;
      sub_2C350(v35, 0xFFu, v28);
      if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
      {
        snprintf(s, 0x800u, "%s", v35);
        sub_1DD60(4, s, 0);
      }
    }
    while ( dword_74FE0 > v27 );
  }
  v29 = dword_68B60;
  v30 = (unsigned __int8)byte_72D90;
  if ( dword_68B60 )
  {
    v31 = dbl_74F28;
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
    {
      if ( (double)dword_68B60 <= dbl_74F28 )
        goto LABEL_143;
      goto LABEL_103;
    }
    snprintf(s, 0x800u, "Mined %.0f accepted shares of %d requested\n", dbl_74F28, dword_68B60);
    sub_1DD60(4, s, 0);
    v31 = dbl_74F28;
    v29 = dword_68B60;
    v30 = (unsigned __int8)byte_72D90;
    if ( (double)dword_68B60 > dbl_74F28 )
    {
      if ( byte_72D90 )
      {
LABEL_105:
        snprintf(s, 0x800u, "WARNING - Mined only %.0f shares of %d requested.", v31, v29);
        sub_1DD60(4, s, 0);
        v30 = (unsigned __int8)byte_72D90;
        goto LABEL_106;
      }
LABEL_103:
      if ( !byte_686E0 && dword_67840 <= 3 )
      {
LABEL_143:
        if ( dword_67840 <= 3 )
          goto LABEL_109;
        goto LABEL_108;
      }
      goto LABEL_105;
    }
  }
LABEL_106:
  if ( !v30 && !byte_686E0 )
    goto LABEL_143;
LABEL_108:
  strcpy(s, " ");
  sub_1DD60(4, s, 0);
LABEL_109:
  fflush((FILE *)stderr);
  return fflush((FILE *)stdout);
}
// 2E124: variable 'v6' is possibly undefined
// 2E134: variable 'v8' is possibly undefined
// 2E56C: variable 'v15' is possibly undefined
// 2E594: variable 'v17' is possibly undefined
// 2EB5C: variable 'v24' is possibly undefined
// 2EB84: variable 'v26' is possibly undefined
// 1DD60: using guessed type int __fastcall sub_1DD60(_DWORD, _DWORD, _DWORD);
// 28328: using guessed type int nullsub_1();
// 2A120: using guessed type int nullsub_2();
// 67840: using guessed type int dword_67840;
// 681C0: using guessed type double dbl_681C0;
// 68594: using guessed type int stdout;
// 68598: using guessed type int stderr;
// 686E0: using guessed type char byte_686E0;
// 68B28: using guessed type int dword_68B28;
// 68B2C: using guessed type int dword_68B2C;
// 68B30: using guessed type int dword_68B30;
// 68B34: using guessed type int dword_68B34;
// 68B60: using guessed type int dword_68B60;
// 72D88: using guessed type double dbl_72D88;
// 72D90: using guessed type char byte_72D90;
// 72DAC: using guessed type int dword_72DAC;
// 72DC8: using guessed type int dword_72DC8;
// 72E60: using guessed type int dword_72E60;
// 72EF0: using guessed type int dword_72EF0;
// 72F04: using guessed type int dword_72F04;
// 72F08: using guessed type int dword_72F08;
// 72F14: using guessed type int dword_72F14;
// 74F28: using guessed type double dbl_74F28;
// 74FB0: using guessed type double dbl_74FB0;
// 74FB8: using guessed type __int64 qword_74FB8;
// 74FE0: using guessed type int dword_74FE0;
// 76060: using guessed type int dword_76060;
// 76074: using guessed type int dword_76074;
// 761D8: using guessed type int dword_761D8;
// 762C8: using guessed type int dword_762C8;

//----- (0002F420) --------------------------------------------------------
int __fastcall sub_2F420(int a1)
{
  int v2; // r5
  char *v3; // r0
  int result; // r0
  struct sysinfo info; // [sp+8h] [bp-844h] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  if ( !sysinfo(&info) )
  {
    dword_761D4 = info.uptime;
    result = sub_206A0(&dword_68B28);
    if ( a1 )
      return result;
    goto LABEL_8;
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
  {
    v2 = *_errno_location();
    v3 = strerror(v2);
    snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v2, v3);
    sub_1DD60(6, s, 0);
  }
  dword_761D4 = time(0);
  result = sub_206A0(&dword_68B28);
  if ( !a1 )
  {
LABEL_8:
    if ( !byte_761D0 )
    {
      if ( byte_686E2 )
        return sub_2E068();
    }
  }
  return result;
}
// 1DD60: using guessed type int __fastcall sub_1DD60(_DWORD, _DWORD, _DWORD);
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E2: using guessed type char byte_686E2;
// 68B28: using guessed type int dword_68B28;
// 72D90: using guessed type char byte_72D90;
// 761D0: using guessed type char byte_761D0;
// 761D4: using guessed type int dword_761D4;

//----- (0002F548) --------------------------------------------------------
void sub_2F548()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
  {
    snprintf(v0, 0x800u, "Attempting to restart %s", s);
    sub_1DD60(4, v0, 0);
  }
  sub_23220((int)sub_2FA50, 0, 5000);
  sub_2F420(1);
  if ( dword_68B0C > 0 )
  {
    kill(dword_68B0C, 15);
    dword_68B0C = 0;
  }
  execv(*(const char **)dword_68B64, (char *const *)dword_68B64);
  if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
  {
    strcpy(v0, "Failed to restart application");
    sub_1DD60(4, v0, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 68B0C: using guessed type int dword_68B0C;
// 68B64: using guessed type int dword_68B64;
// 72D90: using guessed type char byte_72D90;

//----- (0002F688) --------------------------------------------------------
int __fastcall sub_2F688(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_74F90) )
    sub_2DCC0("get_thread", 616);
  v2 = *(_DWORD *)(dword_73F20 + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_74F90) )
    sub_2D6AC("get_thread", 618);
  off_67964();
  return v2;
}
// 67964: using guessed type int (*off_67964)();
// 73F20: using guessed type int dword_73F20;
// 74F90: using guessed type pthread_rwlock_t stru_74F90;

//----- (0002F6FC) --------------------------------------------------------
int __fastcall sub_2F6FC(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(sub_2F688(a1) + 36) + 8);
}

//----- (0002F710) --------------------------------------------------------
bool sub_2F710()
{
  int v0; // r4
  int v1; // r0
  int v2; // r0
  int v3; // r3
  char v5[2048]; // [sp+0h] [bp-800h] BYREF

  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 5 )
  {
    if ( !byte_686E1 )
      goto LABEL_7;
    goto LABEL_28;
  }
  strcpy(v5, "Received kill message");
  sub_1DD60(6, v5, 1);
  if ( byte_686E1 )
  {
    if ( byte_72D90 || byte_686E0 )
    {
LABEL_6:
      strcpy(v5, "Killing off watchpool thread");
      sub_1DD60(7, v5, 1);
      goto LABEL_7;
    }
LABEL_28:
    if ( dword_67840 <= 6 )
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_7:
  sub_23220((int)sub_20284, dword_72DC0 + (dword_68B68 << 6), 1000);
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy(v5, "Killing off watchdog thread");
    sub_1DD60(7, v5, 1);
  }
  sub_23220((int)sub_20284, dword_72DC0 + (dword_68B6C << 6), 1000);
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy(v5, "Shutting down mining threads");
    sub_1DD60(7, v5, 1);
  }
  if ( dword_76228 > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      v2 = sub_2F688(v1);
      if ( v2 )
      {
        v3 = *(_DWORD *)(v2 + 36);
        if ( v3 )
          *(_BYTE *)(v3 + 364) = 1;
      }
    }
    while ( v0 < dword_76228 );
  }
  sleep(1u);
  sub_23220((int)sub_2FA68, 0, 3000);
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy(v5, "Killing off API thread");
    sub_1DD60(7, v5, 1);
  }
  return sub_23220((int)sub_20284, dword_72DC0 + (dword_68B70 << 6), 1000);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68B68: using guessed type int dword_68B68;
// 68B6C: using guessed type int dword_68B6C;
// 68B70: using guessed type int dword_68B70;
// 72D90: using guessed type char byte_72D90;
// 72DC0: using guessed type int dword_72DC0;
// 76228: using guessed type int dword_76228;

//----- (0002FA50) --------------------------------------------------------
bool sub_2FA50()
{
  _BOOL4 result; // r0

  if ( byte_686E2 )
    return sub_2F710();
  return result;
}
// 686E2: using guessed type char byte_686E2;

//----- (0002FA68) --------------------------------------------------------
void sub_2FA68()
{
  int i; // r4
  int v1; // r0
  int v2; // r5
  pthread_t v3; // r0
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy(v4, "Killing off mining threads");
    sub_1DD60(7, v4, 1);
  }
  if ( dword_76228 > 0 )
  {
    for ( i = 0; dword_76228 > i; ++i )
    {
      while ( 1 )
      {
        v1 = sub_2F688(i);
        v2 = v1;
        if ( v1 )
        {
          if ( *(_DWORD *)(v1 + 12) )
            break;
        }
        sub_20284(v1);
LABEL_8:
        if ( dword_76228 <= ++i )
          return;
      }
      sub_20284(v1);
      v3 = *(_DWORD *)(v2 + 12);
      if ( !v3 )
        goto LABEL_8;
      pthread_join(v3, 0);
    }
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 76228: using guessed type int dword_76228;

//----- (0002FB78) --------------------------------------------------------
int sub_2FB78()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_76148) )
    sub_2CB60("current_pool", 845);
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_2DCC0("current_pool", 845);
  if ( pthread_mutex_unlock(&stru_76148) )
    sub_2CBBC("current_pool", 845);
  v0 = dword_68B74;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_2D6AC("current_pool", 849);
  off_67964();
  return v0;
}
// 67964: using guessed type int (*off_67964)();
// 68B74: using guessed type int dword_68B74;
// 76148: using guessed type pthread_mutex_t stru_76148;

//----- (0002FC20) --------------------------------------------------------
int __fastcall sub_2FC20(int a1, int a2, int a3)
{
  int v6; // r1
  unsigned int v7; // r2
  unsigned int v8; // r12
  int v9; // r4
  int v11; // r0

  if ( pthread_mutex_lock(&stru_72D94) )
    sub_2CB60("inc_work_stats", 8926);
  v6 = *(_DWORD *)(a1 + 36);
  v7 = *(_DWORD *)(v6 + 192);
  v8 = *(_DWORD *)(v6 + 196);
  qword_72DC8 += a3;
  *(_QWORD *)(v6 + 192) = __PAIR64__(v8, v7) + a3;
  if ( a2 )
  {
    *(_QWORD *)(a2 + 40) += a3;
  }
  else
  {
    v11 = sub_2FB78();
    *(_QWORD *)(v11 + 40) += a3;
  }
  v9 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v9 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_72D94) )
    sub_2CBBC("inc_work_stats", 8940);
  return off_67964();
}
// 67964: using guessed type int (*off_67964)();
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 72DC8: using guessed type __int64 qword_72DC8;

//----- (0002FD10) --------------------------------------------------------
int sub_2FD10()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_76148) )
    sub_2CB60("cp_prio", 7488);
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_2DCC0("cp_prio", 7488);
  if ( pthread_mutex_unlock(&stru_76148) )
    sub_2CBBC("cp_prio", 7488);
  v0 = *(_DWORD *)(dword_68B74 + 4);
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_2D6AC("cp_prio", 7490);
  off_67964();
  return v0;
}
// 67964: using guessed type int (*off_67964)();
// 68B74: using guessed type int dword_68B74;
// 76148: using guessed type pthread_mutex_t stru_76148;

//----- (0002FDBC) --------------------------------------------------------
void __fastcall sub_2FDBC(_DWORD *a1)
{
  int v2; // r3
  int v3; // r5
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = dword_68AE4;
  a1[7] = 0;
  if ( v2 || (v3 = a1[1], v3 >= sub_2FD10()) )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      snprintf(s, 0x800u, "Pool %d %s alive", *a1, (const char *)a1[41]);
      sub_1DD60(6, s, 0);
    }
  }
  else if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
  {
    snprintf(s, 0x800u, "Pool %d %s alive, testing stability", *a1, (const char *)a1[41]);
    sub_1DD60(4, s, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 68AE4: using guessed type int dword_68AE4;
// 72D90: using guessed type char byte_72D90;

//----- (0002FEF4) --------------------------------------------------------
void __fastcall sub_2FEF4(_DWORD *a1)
{
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
  {
    snprintf(v2, 0x800u, "Stratum connection to pool %d resumed", *a1);
    sub_1DD60(6, v2, 0);
    sub_2FDBC(a1);
  }
  else
  {
    sub_2FDBC(a1);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0002FF84) --------------------------------------------------------
void __fastcall sub_2FF84(int a1)
{
  if ( sub_2CC84(a1, (_BYTE *)(a1 + 97)) )
    sub_2FEF4((_DWORD *)a1);
}

//----- (0002FFA8) --------------------------------------------------------
int __fastcall sub_2FFA8(int a1)
{
  int v3; // r4

  if ( *(_DWORD *)(a1 + 100) != 1 )
    return 0;
  if ( (unsigned int)(dword_68AE4 - 3) <= 1 || *(_BYTE *)(a1 + 656) && *(_BYTE *)(a1 + 97) )
    return 1;
  if ( a1 == sub_2FB78() )
    return 1;
  if ( *(_DWORD *)(a1 + 748) )
    return 1;
  if ( !dword_68AE4 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 < sub_2FD10() )
      return 1;
  }
  return (unsigned __int8)byte_68B78;
}
// 68AE4: using guessed type int dword_68AE4;
// 68B78: using guessed type char byte_68B78;

//----- (0003003C) --------------------------------------------------------
_BYTE *sub_3003C()
{
  _BYTE *v0; // r0
  int v1; // r12
  _BYTE *v2; // r4
  int v3; // r1
  _DWORD *v4; // r0
  int v5; // r2
  int v7; // r3
  int v8; // r1
  int *v9; // r0
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  int *v13; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v0 = sub_1F8B0(0x748u, 1u, "cgminer.c", "add_pool", 769);
  v1 = dword_72E60;
  v2 = v0;
  *(_DWORD *)v0 = dword_72E60;
  v3 = dword_72E60;
  v0[660] = 0;
  *((_DWORD *)v0 + 1) = v1;
  v4 = sub_1F940((void *)dword_72F04, 4 * (v3 + 2), "cgminer.c", "add_pool", 781);
  v5 = dword_72E60;
  dword_72F04 = (int)v4;
  ++dword_72E60;
  v4[v5] = v2;
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 188), 0) )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v9, "cgminer.c", "add_pool", 784);
    goto LABEL_11;
  }
  if ( pthread_cond_init((pthread_cond_t *)(v2 + 296), 0) )
  {
    strcpy(s, "Failed to pthread_cond_init in add_pool");
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 212), 0) )
  {
    v10 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v10, "cgminer.c", "add_pool", 791);
    goto LABEL_11;
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v2 + 236), 0) )
  {
    v11 = _errno_location();
    v8 = 791;
    v7 = *v11;
    goto LABEL_10;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)v2 + 30, 0) )
  {
    v12 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v12, "cgminer.c", "add_pool", 792);
    goto LABEL_11;
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v2 + 756), 0) )
  {
    v13 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v13, "cgminer.c", "add_pool", 793);
LABEL_11:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v2 + 780), 0) )
  {
    v7 = *_errno_location();
    v8 = 793;
LABEL_10:
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", v7, "cgminer.c", "add_pool", v8);
    goto LABEL_11;
  }
  *((_DWORD *)v2 + 34) = -1;
  *((_DWORD *)v2 + 46) = 0;
  *((_DWORD *)v2 + 40) = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  *((_DWORD *)v2 + 86) = v2 + 344;
  *((_DWORD *)v2 + 87) = v2 + 344;
  *((_DWORD *)v2 + 14) = 1;
  sub_2A248();
  v2[580] = 0;
  return v2;
}
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (00030288) --------------------------------------------------------
const char *__fastcall sub_30288(char *s)
{
  int v2; // r3
  _DWORD *v3; // r6
  char *v4; // r4
  char *v5; // r0
  char *v6; // r4

  if ( dword_68B7C || dword_68B80 )
    return "Use only user + pass or userpass, but not both";
  v2 = dword_68B84 + 1;
  dword_68B84 = v2;
  if ( v2 > dword_72E60 )
  {
    sub_3003C();
    v2 = dword_68B84;
  }
  v3 = *(_DWORD **)(dword_72F04 + 4 * (v2 + 0x3FFFFFFF));
  v4 = _strdup(s);
  sub_3E5BC((int)s, v3 + 42);
  v5 = strtok(v4, ":");
  v3[43] = v5;
  if ( !v5 )
    return "Failed to find : delimited user info";
  v6 = strtok(0, ":");
  v3[44] = v6;
  if ( v6 )
    return 0;
  v3[44] = calloc(1u, 1u);
  return v6;
}
// 68B7C: using guessed type int dword_68B7C;
// 68B80: using guessed type int dword_68B80;
// 68B84: using guessed type int dword_68B84;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (00030374) --------------------------------------------------------
const char *__fastcall sub_30374(const char *a1)
{
  int v2; // r3
  int v3; // r7
  size_t v5; // r6
  size_t v6; // r6
  char *v7; // r0
  int v8; // r8
  char s[48]; // [sp+8h] [bp-830h] BYREF
  char v10[2048]; // [sp+38h] [bp-800h] BYREF

  v2 = ++dword_68B7C;
  if ( dword_68B7C > dword_72E60 )
  {
    sub_3003C();
    v2 = dword_68B7C;
  }
  v3 = *(_DWORD *)(dword_72F04 + 4 * (v2 + 0x3FFFFFFF));
  if ( dword_68B88 == 1 )
  {
    memset(s, 0, 0x2Eu);
    if ( sub_1689C(s, 0x2Eu) )
      return "Failed to get modified IP address";
    v5 = strlen(a1);
    v6 = v5 + strlen(s) + 2;
    v7 = (char *)malloc(v6);
    v8 = (int)v7;
    if ( !v7 )
      return "Memory allocation failed";
    snprintf(v7, v6, "%s.%s", a1, s);
    sub_3E5BC(v8, (_DWORD *)(v3 + 172));
    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
    {
      snprintf(v10, 0x800u, "opt_bitmain_user_ip_cat %d ", dword_68B88);
      sub_1DD60(4, v10, 0);
    }
  }
  else
  {
    sub_3E5BC((int)a1, (_DWORD *)(v3 + 172));
  }
  return 0;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 68B7C: using guessed type int dword_68B7C;
// 68B88: using guessed type int dword_68B88;
// 72D90: using guessed type char byte_72D90;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (000304F0) --------------------------------------------------------
const char *__fastcall sub_304F0(const char *a1)
{
  if ( dword_68B84 )
    return "Use only user + pass or userpass, but not both";
  else
    return sub_30374(a1);
}
// 68B84: using guessed type int dword_68B84;

//----- (00030514) --------------------------------------------------------
int sub_30514()
{
  int v0; // r3

  v0 = ++dword_68B8C;
  if ( dword_68B8C > dword_72E60 )
  {
    sub_3003C();
    v0 = dword_68B8C;
  }
  return *(_DWORD *)(dword_72F04 + 4 * (v0 + 0x3FFFFFFF));
}
// 68B8C: using guessed type int dword_68B8C;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (0003077C) --------------------------------------------------------
const char *__fastcall sub_3077C(int a1)
{
  int v3; // r3

  if ( dword_68B84 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_68B80 + 1;
  dword_68B80 = v3;
  if ( v3 > dword_72E60 )
  {
    sub_3003C();
    v3 = dword_68B80;
  }
  sub_3E5BC(a1, (_DWORD *)(*(_DWORD *)(dword_72F04 + 4 * (v3 + 0x3FFFFFFF)) + 176));
  return 0;
}
// 68B80: using guessed type int dword_68B80;
// 68B84: using guessed type int dword_68B84;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (000307F8) --------------------------------------------------------
int sub_307F8()
{
  int v0; // r3
  int v1; // r4
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = ++dword_68B90;
  if ( dword_68B90 > dword_72E60 )
  {
    sub_3003C();
    v0 = dword_68B90;
  }
  v1 = *(_DWORD *)(dword_72F04 + 4 * (v0 + 0x3FFFFFFF));
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(v3, 0x800u, "Enable extranonce subscribe on %d", *(_DWORD *)v1);
    sub_1DD60(7, v3, 0);
  }
  sub_3E4D8((_BYTE *)(v1 + 580));
  return 0;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68B90: using guessed type int dword_68B90;
// 72D90: using guessed type char byte_72D90;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (000308D8) --------------------------------------------------------
void __fastcall sub_308D8(pthread_rwlock_t *a1)
{
  void **nr_readers; // r2
  int *v3; // r0
  void **v4; // [sp+14h] [bp-808h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v4 = 0;
  if ( a1 && !pthread_rwlock_trywrlock(a1 + 10) )
  {
    nr_readers = (void **)a1[11].__nr_readers;
    a1[11].__nr_readers = 0;
    v4 = nr_readers;
    if ( pthread_rwlock_unlock(a1 + 10) )
    {
      v3 = _errno_location();
      snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "cgminer.c", "flush_queue", 9718);
      sub_1DD60(3, s, 1);
      sub_2C230(1, 1);
    }
    off_67964();
    if ( v4 )
    {
      sub_2A70C(&v4, "cgminer.c", "flush_queue", 9722);
      if ( byte_686E1 )
      {
        if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
        {
          strcpy(s, "Discarded queued work item");
          sub_1DD60(7, s, 0);
        }
      }
    }
  }
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (00030A48) --------------------------------------------------------
int sub_30A48()
{
  int v0; // r4
  char *v1; // r0
  int *v2; // r3
  int *v3; // r12
  int v4; // lr
  int v5; // t1
  int result; // r0
  int v7; // r5
  int v8; // r4
  int *v9; // r0
  int *v10; // r0
  struct sysinfo info; // [sp+10h] [bp-840h] BYREF
  char s[2048]; // [sp+50h] [bp-800h] BYREF

  if ( sysinfo(&info) )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      v0 = *_errno_location();
      v1 = strerror(v0);
      snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
      sub_1DD60(6, s, 0);
    }
    dword_76194 = time(0);
  }
  else
  {
    dword_76194 = info.uptime;
  }
  sub_206A0(&dword_68B30);
  sub_235FC(&unk_68B94, &dword_68B30);
  v2 = (int *)&unk_68BA0;
  dbl_761C8 = 0.0;
  dbl_762D8 = 0.0;
  dbl_762D0 = 0.0;
  dbl_72EC0 = 0.0;
  dbl_72D88 = 0.0;
  *(_QWORD *)&dword_72ED0 = 0;
  do
  {
    *(_QWORD *)v2 = 0;
    v2 += 2;
  }
  while ( v2 != &dword_68C00 );
  dword_76064 = 0;
  dword_72F14 = 0;
  dword_76074 = 0;
  dword_74F88 = 0;
  dword_74F8C = 0;
  qword_72EF0 = 0;
  qword_74FB8 = 0;
  dword_762C8 = 0;
  dword_762CC = 0;
  qword_75008 = 0;
  dword_72DC8 = 0;
  dbl_74F28 = 0.0;
  dword_72DCC = 0;
  dword_68C00 = 0;
  dword_761DC = 0;
  dword_76060 = 0;
  dbl_74FB0 = 0.0;
  dbl_72EF8 = 0.0;
  dword_72F08 = 0;
  dword_72DAC = 0;
  dbl_681C0 = 1.0;
  *(_QWORD *)&dword_681D8 = 0x3FF0000000000000LL;
  dbl_681E0 = 1.0;
  if ( dword_72E60 > 0 )
  {
    v3 = (int *)dword_72F04;
    v4 = dword_72F04 + 4 * dword_72E60;
    do
    {
      v5 = *v3++;
      *(_DWORD *)(v5 + 116) = 0;
      *(_QWORD *)(v5 + 8) = 0;
      *(_QWORD *)(v5 + 16) = 0;
      *(_DWORD *)(v5 + 120) = 0;
      *(_DWORD *)(v5 + 124) = 0;
      *(_DWORD *)(v5 + 128) = 0;
      *(_DWORD *)(v5 + 132) = 0;
      *(_DWORD *)(v5 + 352) = 0;
      *(_QWORD *)(v5 + 40) = 0;
      *(_QWORD *)(v5 + 72) = 0;
      *(_QWORD *)(v5 + 80) = 0;
      *(_QWORD *)(v5 + 88) = 0;
      *(_DWORD *)(v5 + 360) = 0;
      *(_DWORD *)(v5 + 364) = 0;
    }
    while ( (int *)v4 != v3 );
  }
  result = sub_2B2E4();
  if ( dword_74FE0 > 0 )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = sub_2DFF4(v7);
      sub_235FC((void *)(v8 + 368), &dword_68B30);
      if ( pthread_mutex_lock(&stru_72ED8) )
        break;
      *(_QWORD *)(v8 + 80) = 0;
      *(_DWORD *)(v8 + 36) = 0;
      *(_DWORD *)(v8 + 40) = 0;
      *(_DWORD *)(v8 + 44) = 0;
      *(_QWORD *)(v8 + 88) = 0;
      *(_DWORD *)(v8 + 220) = 0;
      *(_QWORD *)(v8 + 200) = 0;
      *(_QWORD *)(v8 + 208) = 0;
      *(_QWORD *)(v8 + 224) = 0;
      *(_QWORD *)(v8 + 192) = 0;
      if ( pthread_mutex_unlock(&stru_72ED8) )
      {
        v10 = _errno_location();
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v10, "cgminer.c", "zero_stats", 6258);
LABEL_19:
        sub_1DD60(3, s, 1);
        sub_2C230(1, 1);
      }
      ++v7;
      off_67964();
      result = (*(int (__fastcall **)(int))(*(_DWORD *)(v8 + 4) + 96))(v8);
      if ( dword_74FE0 <= v7 )
        return result;
    }
    v9 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "cgminer.c", "zero_stats", 6245);
    goto LABEL_19;
  }
  return result;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681C0: using guessed type double dbl_681C0;
// 681D8: using guessed type int dword_681D8;
// 681E0: using guessed type double dbl_681E0;
// 686E0: using guessed type char byte_686E0;
// 68B30: using guessed type int dword_68B30;
// 68C00: using guessed type int dword_68C00;
// 72D88: using guessed type double dbl_72D88;
// 72D90: using guessed type char byte_72D90;
// 72DAC: using guessed type int dword_72DAC;
// 72DC8: using guessed type int dword_72DC8;
// 72DCC: using guessed type int dword_72DCC;
// 72E60: using guessed type int dword_72E60;
// 72EC0: using guessed type double dbl_72EC0;
// 72ED0: using guessed type int dword_72ED0;
// 72ED8: using guessed type pthread_mutex_t stru_72ED8;
// 72EF0: using guessed type __int64 qword_72EF0;
// 72EF8: using guessed type double dbl_72EF8;
// 72F04: using guessed type int dword_72F04;
// 72F08: using guessed type int dword_72F08;
// 72F14: using guessed type int dword_72F14;
// 74F28: using guessed type double dbl_74F28;
// 74F88: using guessed type int dword_74F88;
// 74F8C: using guessed type int dword_74F8C;
// 74FB0: using guessed type double dbl_74FB0;
// 74FB8: using guessed type __int64 qword_74FB8;
// 74FE0: using guessed type int dword_74FE0;
// 75008: using guessed type __int64 qword_75008;
// 76060: using guessed type int dword_76060;
// 76064: using guessed type int dword_76064;
// 76074: using guessed type int dword_76074;
// 76194: using guessed type int dword_76194;
// 761C8: using guessed type double dbl_761C8;
// 761DC: using guessed type int dword_761DC;
// 762C8: using guessed type int dword_762C8;
// 762CC: using guessed type int dword_762CC;
// 762D0: using guessed type double dbl_762D0;
// 762D8: using guessed type double dbl_762D8;

//----- (00030E60) --------------------------------------------------------
int __fastcall sub_30E60(int a1)
{
  int v2; // r12
  int v3; // r2
  int result; // r0
  int (__fastcall *v5)(int); // r3
  int *v6; // r0
  int *v7; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
  {
    snprintf(
      s,
      0x800u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_1DD60(6, s, 0);
  }
  if ( pthread_mutex_lock(&stru_72D94) )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "cgminer.c", "inc_hw_errors", 8836);
    goto LABEL_12;
  }
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)(v2 + 44) + 1;
  ++dword_76060;
  *(_DWORD *)(v2 + 44) = v3;
  if ( pthread_mutex_unlock(&stru_72D94) )
  {
    v7 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v7, "cgminer.c", "inc_hw_errors", 8839);
LABEL_12:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  result = off_67964();
  v5 = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84);
  if ( v5 )
    return v5(a1);
  return result;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 76060: using guessed type int dword_76060;

//----- (00030FE8) --------------------------------------------------------
int __fastcall sub_30FE8(int a1, int a2)
{
  int v4; // r12
  int v5; // r1
  int result; // r0
  int (__fastcall *v7)(int); // r3
  int *v8; // r0
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(
      s,
      0x800u,
      "%s%d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_1DD60(3, s, 0);
  }
  if ( pthread_mutex_lock(&stru_72D94) )
  {
    v8 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v8,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8850);
    goto LABEL_12;
  }
  v4 = *(_DWORD *)(a1 + 36);
  v5 = *(_DWORD *)(v4 + 44) + a2;
  dword_76060 += a2;
  *(_DWORD *)(v4 + 44) = v5;
  if ( pthread_mutex_unlock(&stru_72D94) )
  {
    v9 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v9,
      "cgminer.c",
      "inc_hw_errors_with_diff",
      8853);
LABEL_12:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  result = off_67964();
  v7 = *(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84);
  if ( v7 )
    return v7(a1);
  return result;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 76060: using guessed type int dword_76060;

//----- (0003117C) --------------------------------------------------------
unsigned __int64 __fastcall sub_3117C(int a1)
{
  double v2; // r0
  double v3; // d8
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d6
  double v8; // r0
  double v9; // d8
  int v10; // r1
  unsigned __int64 v11; // r6
  int v12; // r8
  unsigned __int64 *v13; // r3
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  int *v18; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  LODWORD(v2) = sub_4AB04(*(_QWORD *)(a1 + 216));
  v3 = v2 * 6.27710174e57;
  LODWORD(v4) = sub_4AB04(*(_QWORD *)(a1 + 208));
  v5 = v3 + v4 * 3.40282367e38;
  LODWORD(v6) = sub_4AB04(*(_QWORD *)(a1 + 200));
  v7 = v6;
  LODWORD(v8) = sub_4AB04(*(_QWORD *)(a1 + 192));
  v9 = v8 + v5 + v7 * 1.84467441e19;
  if ( v9 == 0.0 )
    v9 = 0.0;
  round();
  LODWORD(v11) = sub_4ABD0(2.69595353e67 / v9);
  HIDWORD(v11) = v10;
  if ( pthread_mutex_lock(&stru_76148) )
  {
    v15 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v15, "cgminer.c", "share_diff", 5214);
    goto LABEL_14;
  }
  v12 = pthread_rwlock_wrlock(&rwlock);
  if ( v12 )
  {
    v16 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v16, "cgminer.c", "share_diff", 5214);
    goto LABEL_14;
  }
  if ( qword_68B00 < v11 )
  {
    qword_68B00 = v11;
    v12 = 1;
    sub_287D8(v11, dword_681C8, 8u, 0);
  }
  v13 = (unsigned __int64 *)(*(_DWORD *)(a1 + 260) + 368);
  if ( *v13 < v11 )
    *v13 = v11;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "share_diff", 5228);
    goto LABEL_14;
  }
  if ( pthread_mutex_unlock(&stru_76148) )
  {
    v18 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "cgminer.c", "share_diff", 5228);
LABEL_14:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  off_67964();
  if ( v12 && (byte_72D90 || byte_686E0 || dword_67840 > 5) )
  {
    snprintf(s, 0x800u, "New best share: %s", dword_681C8);
    sub_1DD60(6, s, 0);
  }
  return v11;
}
// 311A0: variable 'v2' is possibly undefined
// 311B4: variable 'v4' is possibly undefined
// 311C0: variable 'v6' is possibly undefined
// 311D8: variable 'v8' is possibly undefined
// 31204: variable 'v10' is possibly undefined
// 12770: using guessed type int round(void);
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 68B00: using guessed type __int64 qword_68B00;
// 72D90: using guessed type char byte_72D90;
// 76148: using guessed type pthread_mutex_t stru_76148;

//----- (00031450) --------------------------------------------------------
int __fastcall sub_31450(int *a1, int a2)
{
  double v4; // d8
  unsigned __int64 v5; // r0
  double v6; // r0
  double v7; // d8
  double v8; // r0
  __int64 v9; // r0
  int v10; // r5
  double v11; // r0
  __int64 v12; // r0
  int v13; // r5
  double v14; // r0
  __int64 v15; // r0
  int v16; // r4
  int v18; // r12
  int v19; // r2
  bool v20; // zf
  int v21; // r2
  int *v22; // r0
  int *v23; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = dbl_681E8;
  v5 = sub_3117C(a2);
  *(_QWORD *)(a2 + 232) = v5;
  LODWORD(v6) = sub_4AB04(v5);
  if ( v4 <= v6 )
  {
    v18 = *(_DWORD *)(a2 + 260);
    v19 = (unsigned __int8)byte_72D90;
    *(_BYTE *)(a2 + 283) = 1;
    v20 = v19 == 0;
    v21 = dword_76074 + 1;
    ++*(_DWORD *)(v18 + 32);
    dword_76074 = v21;
    *(_BYTE *)(a2 + 282) = 1;
    if ( !v20 || byte_686E0 || dword_67840 > 4 )
    {
      snprintf(s, 0x800u, "Found block for pool %d!", **(_DWORD **)(a2 + 260));
      sub_1DD60(5, s, 0);
    }
  }
  if ( pthread_mutex_lock(&stru_72D94) )
  {
    v22 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v22, "cgminer.c", "update_work_stats", 8916);
    goto LABEL_10;
  }
  v7 = *(double *)(a2 + 224);
  LODWORD(v8) = sub_4AB14(qword_72DC8);
  LODWORD(v9) = sub_4ABAC(v8 + v7);
  qword_72DC8 = v9;
  v10 = *a1;
  LODWORD(v11) = sub_4AB14(*(_QWORD *)(*a1 + 192));
  LODWORD(v12) = sub_4ABAC(v11 + v7);
  *(_QWORD *)(v10 + 192) = v12;
  v13 = *(_DWORD *)(a2 + 260);
  LODWORD(v14) = sub_4AB14(*(_QWORD *)(v13 + 40));
  LODWORD(v15) = sub_4ABAC(v14 + *(double *)(a2 + 224));
  *(_QWORD *)(v13 + 40) = v15;
  v16 = *a1;
  *(_DWORD *)(v16 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_72D94) )
  {
    v23 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v23,
      "cgminer.c",
      "update_work_stats",
      8921);
LABEL_10:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  return off_67964();
}
// 3148C: variable 'v6' is possibly undefined
// 314C0: variable 'v8' is possibly undefined
// 314C8: variable 'v9' is possibly undefined
// 314E0: variable 'v11' is possibly undefined
// 314E8: variable 'v12' is possibly undefined
// 31504: variable 'v14' is possibly undefined
// 3150C: variable 'v15' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681E8: using guessed type double dbl_681E8;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 72DC8: using guessed type __int64 qword_72DC8;
// 76074: using guessed type int dword_76074;

//----- (0003167C) --------------------------------------------------------
int __fastcall sub_3167C(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // r5
  int v8; // r4
  char v10[2048]; // [sp+0h] [bp-800h] BYREF

  v5 = a4;
  v4 = a4 == 0;
  if ( a4 )
    a4 = 0;
  if ( !v4 )
    *v5 = a4;
  a2[19] = a3;
  sub_28C30((int)a2);
  if ( a2[55] )
  {
    sub_30E60(a1);
    return 0;
  }
  else
  {
    sub_31450((int *)(a1 + 36), (int)a2);
    v8 = sub_1FE0C(a2 + 48, a2 + 40);
    if ( !v8 )
    {
      if ( v5 )
        *v5 = 1;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        strcpy(v10, "Share above target");
        sub_1DD60(6, v10, 0);
      }
      else
      {
        return (unsigned __int8)byte_686E0;
      }
    }
    return v8;
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00031774) --------------------------------------------------------
void __fastcall sub_31774(_DWORD *a1)
{
  int v2; // r7
  _DWORD *v3; // r3
  int v4; // r4
  int v5; // r10
  int v6; // r1
  int v7; // r0
  int v8; // r2
  _DWORD *v9; // r12
  int v10; // r9
  _DWORD *v11; // r0
  int v12; // r2
  int v13; // r0
  _DWORD *v14; // lr
  int v15; // r0
  int v16; // r2
  int *v17; // r0
  int *v18; // r0
  void **v19; // [sp+14h] [bp-804h] BYREF
  char s[2048]; // [sp+18h] [bp-800h] BYREF

  v2 = pthread_mutex_lock((pthread_mutex_t *)dword_68B20);
  if ( v2 )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "clear_pool_work", 7468);
    goto LABEL_37;
  }
  v3 = (_DWORD *)dword_68C04;
  v19 = (void **)dword_68C04;
  if ( !dword_68C04 )
  {
    if ( !pthread_mutex_unlock((pthread_mutex_t *)dword_68B20) )
    {
      off_67964();
      return;
    }
    goto LABEL_38;
  }
  v4 = *(_DWORD *)(dword_68C04 + 352);
  if ( *(_DWORD **)(dword_68C04 + 260) == a1 )
    goto LABEL_6;
LABEL_4:
  v19 = (void **)v4;
  if ( v4 )
  {
    while ( 1 )
    {
      v3 = (_DWORD *)v4;
      v4 = *(_DWORD *)(v4 + 352);
      if ( (_DWORD *)v3[65] != a1 )
        goto LABEL_4;
LABEL_6:
      v5 = v3[87];
      v6 = dword_68C04;
      v7 = *(_DWORD *)(dword_68C04 + 344);
      if ( v5 )
        break;
      v10 = v3[88];
      if ( v10 )
      {
        v8 = *(_DWORD *)(v7 + 20);
        v9 = v3 + 86;
        if ( v3 != (_DWORD *)(*(_DWORD *)(v7 + 16) - v8) )
          goto LABEL_29;
LABEL_30:
        *(_DWORD *)(v7 + 16) = v5 + v8;
        v5 = v3[87];
        if ( v5 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)(v6 + 344) + 20);
          goto LABEL_8;
        }
        v10 = v3[88];
LABEL_29:
        v6 = v10;
        dword_68C04 = v10;
LABEL_9:
        v11 = *(_DWORD **)(v6 + 344);
        if ( v10 )
        {
          *(_DWORD *)(v10 + v11[5] + 4) = v3[87];
          v11 = *(_DWORD **)(v6 + 344);
        }
        v12 = 3 * ((v11[1] - 1) & v3[93]);
        --*(_DWORD *)(*v11 + 4 * v12 + 4);
        v13 = **(_DWORD **)(v6 + 344);
        v14 = *(_DWORD **)(v13 + 4 * v12);
        if ( v14 == v9 )
        {
          v6 = v3[90];
          *(_DWORD *)(v13 + 4 * v12) = v6;
        }
        v15 = v3[89];
        v16 = v3[90];
        if ( v14 == v9 )
          v6 = dword_68C04;
        if ( v15 )
        {
          *(_DWORD *)(v15 + 16) = v16;
          v16 = v3[90];
        }
        if ( v16 )
          *(_DWORD *)(v16 + 12) = v3[89];
        --*(_DWORD *)(*(_DWORD *)(v6 + 344) + 12);
        goto LABEL_20;
      }
      free(*(void **)v7);
      free(*(void **)(dword_68C04 + 344));
      dword_68C04 = 0;
LABEL_20:
      ++v2;
      sub_2A70C(&v19, "cgminer.c", "clear_pool_work", 7474);
      v19 = (void **)v4;
      if ( !v4 )
        goto LABEL_21;
    }
    v8 = *(_DWORD *)(v7 + 20);
    v9 = v3 + 86;
    if ( v3 == (_DWORD *)(*(_DWORD *)(v7 + 16) - v8) )
      goto LABEL_30;
LABEL_8:
    *(_DWORD *)(v5 + v8 + 8) = v3[88];
    v10 = v3[88];
    goto LABEL_9;
  }
LABEL_21:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_68B20) )
  {
LABEL_38:
    v18 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "cgminer.c", "clear_pool_work", 7478);
LABEL_37:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  off_67964();
  if ( v2 && (byte_72D90 || byte_686E0 || dword_67840 > 5) )
  {
    snprintf(s, 0x800u, "Cleared %d work items due to stratum disconnect on pool %d", v2, *a1);
    sub_1DD60(6, s, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 68B20: using guessed type int dword_68B20;
// 68C04: using guessed type int dword_68C04;
// 72D90: using guessed type char byte_72D90;

//----- (00031A9C) --------------------------------------------------------
int __fastcall sub_31A9C(int a1)
{
  int v2; // r9
  unsigned __int8 *v3; // r6
  int v4; // lr
  int v5; // r7
  int v6; // r11
  int v7; // r12
  int v8; // r1
  int *v9; // r2
  int v10; // r12
  int v11; // r0
  int v12; // t1
  int v13; // r3
  int v14; // r0
  _DWORD *v15; // r1
  unsigned __int8 *v16; // r5
  int v18; // r10
  int v19; // r8
  int v20; // r9
  int v21; // r3
  int v22; // r3
  int v23; // r12
  int *v24; // r0
  int *v25; // r0
  int v26; // r3
  int v27; // r12
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_76148) )
  {
    v22 = *_errno_location();
    v23 = 5307;
LABEL_51:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v22, "cgminer.c", "switch_pools", v23);
    goto LABEL_52;
  }
  v2 = pthread_rwlock_wrlock(&rwlock);
  if ( v2 )
  {
    v24 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v24, "cgminer.c", "switch_pools", 5307);
    goto LABEL_52;
  }
  v3 = (unsigned __int8 *)dword_68B74;
  v4 = dword_68AE4;
  v5 = *(_DWORD *)dword_68B74;
  if ( a1 )
  {
    v6 = *(_DWORD *)(a1 + 4);
    if ( v6 )
    {
      v7 = dword_72E60;
      if ( dword_72E60 > 0 )
      {
        v8 = dword_72F04;
        v9 = (int *)dword_72F04;
        v10 = dword_72F04 + 4 * dword_72E60;
        while ( 1 )
        {
          v12 = *v9++;
          v11 = v12;
          v13 = *(_DWORD *)(v12 + 4);
          if ( v13 < v6 )
            *(_DWORD *)(v11 + 4) = v13 + 1;
          if ( (int *)v10 == v9 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            switch ( v4 )
            {
              case 0:
              case 3:
              case 4:
                goto LABEL_15;
              case 1:
              case 2:
                goto LABEL_36;
              default:
                goto LABEL_49;
            }
          }
          v6 = *(_DWORD *)(a1 + 4);
        }
      }
      *(_DWORD *)(a1 + 4) = 0;
      switch ( v4 )
      {
        case 0:
        case 3:
        case 4:
          goto LABEL_14;
        case 1:
        case 2:
          goto LABEL_35;
        default:
          goto LABEL_22;
      }
    }
    switch ( dword_68AE4 )
    {
      case 0:
      case 3:
      case 4:
        goto LABEL_13;
      case 1:
      case 2:
LABEL_35:
        v8 = dword_72F04;
LABEL_36:
        if ( *(_BYTE *)(a1 + 97) )
          goto LABEL_39;
        v16 = *(unsigned __int8 **)(v8 + 4 * *(_DWORD *)a1);
        break;
      default:
        goto LABEL_22;
    }
  }
  else
  {
    switch ( dword_68AE4 )
    {
      case 0:
      case 3:
      case 4:
LABEL_13:
        v7 = dword_72E60;
LABEL_14:
        if ( v7 <= 0 )
          goto LABEL_22;
        do
        {
LABEL_15:
          v14 = sub_290E8(v2);
          if ( !*(_BYTE *)(v14 + 97) && *(_DWORD *)(v14 + 100) == 1 && !sub_28FB0((unsigned __int8 *)v14) )
          {
            v16 = *(unsigned __int8 **)(dword_72F04 + 4 * *v15);
            goto LABEL_23;
          }
          ++v2;
        }
        while ( dword_72E60 > v2 );
        v16 = *(unsigned __int8 **)(dword_72F04 + 4 * v5);
        break;
      case 1:
      case 2:
        v8 = dword_72F04;
LABEL_39:
        v18 = dword_72E60;
        if ( dword_72E60 <= 1 )
        {
LABEL_49:
          v16 = *(unsigned __int8 **)(v8 + 4 * v5);
        }
        else
        {
          v19 = v5;
          v20 = 1;
          while ( 1 )
          {
            if ( ++v19 >= v18 )
            {
              v21 = v8;
              v19 = 0;
            }
            else
            {
              v21 = v8 + 4 * v19;
            }
            v16 = *(unsigned __int8 **)v21;
            if ( !*(_BYTE *)(*(_DWORD *)v21 + 97) && *((_DWORD *)v16 + 25) == 1 && !sub_28FB0(v16) )
              break;
            if ( ++v20 == v18 )
              goto LABEL_49;
          }
        }
        break;
      default:
LABEL_22:
        v16 = *(unsigned __int8 **)(dword_72F04 + 4 * v5);
        break;
    }
  }
LABEL_23:
  dword_68B74 = (int)v16;
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v25 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v25, "cgminer.c", "switch_pools", 5388);
    goto LABEL_52;
  }
  if ( pthread_mutex_unlock(&stru_76148) )
  {
    v26 = *_errno_location();
    v27 = 5388;
LABEL_56:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v26, "cgminer.c", "switch_pools", v27);
LABEL_52:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  off_67964();
  if ( v3 != v16 && (unsigned int)(dword_68AE4 - 3) > 1 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
    {
      snprintf(s, 0x800u, "Switching to pool %d %s", *(_DWORD *)v16, *((const char **)v16 + 41));
      sub_1DD60(4, s, 0);
    }
    sub_31774(v3);
  }
  if ( pthread_mutex_lock(&mutex) )
  {
    v22 = *_errno_location();
    v23 = 5396;
    goto LABEL_51;
  }
  pthread_cond_broadcast(&cond);
  if ( pthread_mutex_unlock(&mutex) )
  {
    v26 = *_errno_location();
    v27 = 5398;
    goto LABEL_56;
  }
  return off_67964();
}
// 31B54: control flows out of bounds to 31B58
// 31B74: control flows out of bounds to 31B78
// 31C08: control flows out of bounds to 31C0C
// 31EF8: control flows out of bounds to 31EFC
// 31BD4: variable 'v15' is possibly undefined
// 31D88: variable 'v8' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 68AE4: using guessed type int dword_68AE4;
// 68B74: using guessed type int dword_68B74;
// 72D90: using guessed type char byte_72D90;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;
// 76148: using guessed type pthread_mutex_t stru_76148;

//----- (00031F20) --------------------------------------------------------
void __fastcall sub_31F20(int a1)
{
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( !sub_2CC18(a1, (_BYTE *)(a1 + 97)) )
  {
    sub_206A0((__time_t *)(a1 + 136));
    if ( a1 == sub_2FB78() )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
      {
        snprintf(s, 0x800u, "Pool %d %s not responding!", *(_DWORD *)a1, *(const char **)(a1 + 164));
        sub_1DD60(4, s, 0);
      }
      sub_31A9C(0);
    }
    else if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      snprintf(s, 0x800u, "Pool %d %s failed to return work", *(_DWORD *)a1, *(const char **)(a1 + 164));
      sub_1DD60(6, s, 0);
    }
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00032050) --------------------------------------------------------
void __noreturn sub_32050()
{
  int v0; // r11
  int v1; // r5
  _DWORD *v2; // r4
  __int64 v3; // r6
  double v4; // r0
  double v5; // d7
  double v6; // d6
  int v7; // r6
  int *v8; // r12
  int v9; // r7
  bool v10; // zf
  int *v11; // r12
  int v12; // r7
  int v13; // lr
  int v14; // r5
  int v15; // r1
  _DWORD *v16; // r3
  int v17; // r6
  int v18; // r7
  int v19; // r0
  int **v20; // r2
  int v21; // r12
  int v22; // r3
  int v23; // r3
  int v24; // r3
  int v25; // r1
  int v26; // r1
  int v27; // r3
  int v28; // r3
  __int64 v29; // r2
  int v30; // r6
  char *v31; // r1
  int v32; // r1
  int *v33; // r0
  int *v34; // r0
  int *v35; // r0
  const char *v36; // r12
  int v37; // r1
  int v38; // [sp+14h] [bp-838h]
  int v39; // [sp+14h] [bp-838h]
  pthread_mutex_t *mutex; // [sp+18h] [bp-834h]
  pthread_mutex_t *mutexa; // [sp+18h] [bp-834h]
  void **v42; // [sp+28h] [bp-824h]
  struct timespec tp; // [sp+30h] [bp-81Ch] BYREF
  __time_t v44[2]; // [sp+38h] [bp-814h] BYREF
  __time_t v45[2]; // [sp+40h] [bp-80Ch] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  pthread_setcanceltype(1, 0);
  sub_22E98("Watchpool");
  sub_29BA0();
  v0 = 0;
  sub_20750(&tp);
  while ( 1 )
  {
    if ( ++v0 >= 121 )
      v0 = 0;
    sub_206A0(v44);
    if ( dword_72E60 > 0 )
      break;
LABEL_19:
    if ( *(_BYTE *)(sub_2FB78() + 97) )
      sub_31A9C(0);
    if ( dword_68AE4 == 2 && v44[0] - dword_68C70 > 60 * dword_73F1C )
    {
      sub_206A0(&dword_68C70);
      sub_31A9C(0);
    }
    sub_2075C(&tp.tv_sec);
    sub_20750(&tp);
  }
  v1 = 0;
  while ( 1 )
  {
    v2 = *(_DWORD **)(dword_72F04 + 4 * v1);
    if ( !byte_68C50 && !dword_72DB0 )
      break;
LABEL_13:
    if ( v0 == 120 )
    {
      v3 = *((_QWORD *)v2 + 5);
      LODWORD(v4) = sub_4AB14(v3 - (int)v2[38]);
      v5 = *((double *)v2 + 18);
      v2[38] = v3;
      v6 = (v5 + v4 * 0.63) / 1.63;
      *((double *)v2 + 18) = v6;
      v2[39] = (int)v6;
    }
    if ( v2[25] && !*((_BYTE *)v2 + 284) )
    {
      if ( sub_2CCEC(v2, 1) )
      {
        if ( sub_2CC84((int)v2, (_BYTE *)v2 + 97) )
          sub_2FDBC(v2);
      }
      else
      {
        sub_206A0(v2 + 34);
      }
      if ( !*((_BYTE *)v2 + 97) && !dword_68AE4 )
      {
        v7 = v2[1];
        if ( v7 < sub_2FD10() && v44[0] - v2[34] > dword_681F0 )
        {
          if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
          {
            snprintf(s, 0x800u, "Pool %d %s stable for >%d seconds", *v2, (const char *)v2[41], dword_681F0);
            sub_1DD60(4, s, 0);
          }
          sub_31A9C(0);
        }
      }
    }
    if ( dword_72E60 <= ++v1 )
      goto LABEL_19;
  }
  mutex = (pthread_mutex_t *)(v2 + 47);
  sub_206A0(v45);
  if ( pthread_mutex_lock((pthread_mutex_t *)(v2 + 47)) )
  {
    v33 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v33, "cgminer.c", "reap_curl", 10248);
    goto LABEL_90;
  }
  v8 = (int *)v2[86];
  v9 = *v8;
  v10 = v2 + 86 == v8;
  v11 = v8 - 1;
  v12 = v9 - 4;
  if ( v10 )
  {
    if ( pthread_mutex_unlock(mutex) )
      goto LABEL_96;
    off_67964();
  }
  else
  {
    v13 = v2[72];
    if ( v13 > 1 )
    {
      v38 = v1;
      v14 = 0;
      while ( 1 )
      {
        if ( v45[0] - v11[3] > 300 )
        {
          v2[72] = v13 - 1;
          ++v14;
          v15 = v11[1];
          v16 = (_DWORD *)v11[2];
          *(_DWORD *)(v15 + 4) = v16;
          *v16 = v15;
          free(v11);
        }
        if ( v2 + 86 == (_DWORD *)(v12 + 4) )
          break;
        v13 = v2[72];
        v11 = (int *)v12;
        if ( v13 <= 1 )
        {
          v1 = v38;
          goto LABEL_41;
        }
        v12 = *(_DWORD *)(v12 + 4) - 4;
      }
      v30 = v14;
      v1 = v38;
      if ( pthread_mutex_unlock(mutex) )
      {
LABEL_96:
        v35 = _errno_location();
        v36 = "reap_curl";
        v37 = 10266;
LABEL_93:
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v35, "cgminer.c", v36, v37);
LABEL_90:
        sub_1DD60(3, s, 1);
        sub_2C230(1, 1);
      }
      off_67964();
      if ( v30 && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        v31 = "";
        if ( v30 != 1 )
          v31 = "s";
        snprintf(s, 0x800u, "Reaped %d curl%s from pool %d", v30, v31, *v2);
        sub_1DD60(7, s, 0);
      }
    }
  }
LABEL_41:
  mutexa = (pthread_mutex_t *)time(0);
  v39 = pthread_mutex_lock(&stru_68C54);
  if ( v39 )
  {
    v34 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v34,
      "cgminer.c",
      "prune_stratum_shares",
      10284);
    goto LABEL_90;
  }
  v17 = dword_68C6C;
  if ( !dword_68C6C )
  {
    if ( pthread_mutex_unlock(&stru_68C54) )
    {
LABEL_92:
      v35 = _errno_location();
      v36 = "prune_stratum_shares";
      v37 = 10297;
      goto LABEL_93;
    }
    off_67964();
    goto LABEL_13;
  }
  v18 = *(_DWORD *)(dword_68C6C + 8);
  if ( v2 == *(_DWORD **)(*(_DWORD *)(dword_68C6C + 36) + 260) )
    goto LABEL_46;
LABEL_44:
  if ( !v18 )
  {
LABEL_60:
    if ( pthread_mutex_unlock(&stru_68C54) )
      goto LABEL_92;
    off_67964();
    if ( v39 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
      {
        snprintf(s, 0x800u, "Lost %d shares due to no stratum share response from pool %d", v39, *v2);
        sub_1DD60(4, s, 0);
      }
      v29 = *(_QWORD *)&dword_762C8;
      v2[30] += v39;
      *(_QWORD *)&dword_762C8 = v29 + v39;
    }
    goto LABEL_13;
  }
  while ( 1 )
  {
    v17 = v18;
    v18 = *(_DWORD *)(v18 + 8);
    if ( v2 != *(_DWORD **)(*(_DWORD *)(v17 + 36) + 260) )
      goto LABEL_44;
LABEL_46:
    if ( (int)mutexa <= *(_DWORD *)(v17 + 44) + 120 )
      goto LABEL_44;
    v19 = *(_DWORD *)(v17 + 4);
    v20 = (int **)dword_68C6C;
    v21 = *(_DWORD *)dword_68C6C;
    if ( v19 )
      break;
    v32 = *(_DWORD *)(v17 + 8);
    if ( v32 )
    {
      v22 = *(_DWORD *)(v21 + 20);
      if ( v17 != *(_DWORD *)(v21 + 16) - v22 )
        goto LABEL_81;
LABEL_82:
      *(_DWORD *)(v21 + 16) = v19 + v22;
      v19 = *(_DWORD *)(v17 + 4);
      if ( !v19 )
      {
        v32 = *(_DWORD *)(v17 + 8);
LABEL_81:
        v20 = (int **)v32;
        dword_68C6C = v32;
LABEL_50:
        v23 = *(_DWORD *)(v17 + 8);
        if ( v23 )
          *(_DWORD *)(v23 + (*v20)[5] + 4) = *(_DWORD *)(v17 + 4);
        v24 = 3 * (((*v20)[1] - 1) & *(_DWORD *)(v17 + 28));
        v25 = **v20 + 12 * (((*v20)[1] - 1) & *(_DWORD *)(v17 + 28));
        --*(_DWORD *)(v25 + 4);
        v26 = **v20;
        if ( *(_DWORD *)(v26 + 4 * v24) == v17 )
          *(_DWORD *)(v26 + 4 * v24) = *(_DWORD *)(v17 + 16);
        v27 = *(_DWORD *)(v17 + 12);
        if ( v27 )
          *(_DWORD *)(v27 + 16) = *(_DWORD *)(v17 + 16);
        v28 = *(_DWORD *)(v17 + 16);
        if ( v28 )
          *(_DWORD *)(v28 + 12) = *(_DWORD *)(v17 + 12);
        --(*v20)[3];
        goto LABEL_59;
      }
      v22 = (*v20)[5];
LABEL_49:
      *(_DWORD *)(v19 + v22 + 8) = *(_DWORD *)(v17 + 8);
      goto LABEL_50;
    }
    v42 = (void **)dword_68C6C;
    free(*(void **)v21);
    free(*v42);
    dword_68C6C = 0;
LABEL_59:
    ++v39;
    sub_2A70C((void ***)(v17 + 36), "cgminer.c", "prune_stratum_shares", 10291);
    free((void *)v17);
    if ( !v18 )
      goto LABEL_60;
  }
  v22 = *(_DWORD *)(v21 + 20);
  if ( v17 == *(_DWORD *)(v21 + 16) - v22 )
    goto LABEL_82;
  goto LABEL_49;
}
// 32190: variable 'v4' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681F0: using guessed type int dword_681F0;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68AE4: using guessed type int dword_68AE4;
// 68C50: using guessed type char byte_68C50;
// 68C6C: using guessed type int dword_68C6C;
// 68C70: using guessed type int dword_68C70;
// 72D90: using guessed type char byte_72D90;
// 72DB0: using guessed type int dword_72DB0;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;
// 73F1C: using guessed type int dword_73F1C;
// 762C8: using guessed type int dword_762C8;

//----- (0003285C) --------------------------------------------------------
int *__fastcall sub_3285C(int a1)
{
  int v2; // r8
  int v3; // r4
  int v4; // r5
  double v5; // d8
  int v6; // r0
  void **v7; // r11
  int v8; // r1
  __int64 v9; // r2
  __int64 v11; // r2
  int *result; // r0
  double v13; // d6
  double v14; // d8
  __int64 v15; // r4
  int v16; // r8
  int *v17; // r0
  int *v18; // r0
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v2 = pthread_mutex_lock(&stru_68C54);
  if ( v2 )
  {
    v17 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v17,
      "cgminer.c",
      "clear_stratum_shares",
      7437);
    goto LABEL_36;
  }
  v3 = dword_68C6C;
  if ( !dword_68C6C )
  {
    if ( !pthread_mutex_unlock(&stru_68C54) )
      return (int *)off_67964();
    goto LABEL_37;
  }
  v4 = *(_DWORD *)(dword_68C6C + 8);
  v5 = 0.0;
  if ( *(_DWORD *)(*(_DWORD *)(dword_68C6C + 36) + 260) == a1 )
    goto LABEL_6;
LABEL_4:
  if ( v4 )
  {
    while ( 1 )
    {
      v3 = v4;
      v4 = *(_DWORD *)(v4 + 8);
      if ( *(_DWORD *)(*(_DWORD *)(v3 + 36) + 260) != a1 )
        goto LABEL_4;
LABEL_6:
      v6 = *(_DWORD *)(v3 + 4);
      v7 = (void **)dword_68C6C;
      v8 = *(_DWORD *)dword_68C6C;
      if ( v6 )
        break;
      LODWORD(v9) = *(_DWORD *)(v3 + 8);
      if ( (_DWORD)v9 )
      {
        HIDWORD(v9) = *(_DWORD *)(v8 + 20);
        if ( v3 != *(_DWORD *)(v8 + 16) - HIDWORD(v9) )
          goto LABEL_30;
LABEL_28:
        *(_DWORD *)(v8 + 16) = v6 + HIDWORD(v9);
        v6 = *(_DWORD *)(v3 + 4);
        if ( !v6 )
        {
          LODWORD(v9) = *(_DWORD *)(v3 + 8);
LABEL_30:
          HIDWORD(v9) = v9;
          v7 = (void **)v9;
          dword_68C6C = v9;
LABEL_9:
          LODWORD(v9) = *v7;
          if ( HIDWORD(v9) )
          {
            *(_DWORD *)(HIDWORD(v9) + *(_DWORD *)(v9 + 20) + 4) = *(_DWORD *)(v3 + 4);
            LODWORD(v9) = *v7;
          }
          HIDWORD(v9) = 3 * ((*(_DWORD *)(v9 + 4) - 1) & *(_DWORD *)(v3 + 28));
          --*(_DWORD *)(*(_DWORD *)v9 + 4 * HIDWORD(v9) + 4);
          LODWORD(v9) = *(_DWORD *)*v7;
          if ( *(_DWORD *)(v9 + 4 * HIDWORD(v9)) == v3 )
            *(_DWORD *)(v9 + 4 * HIDWORD(v9)) = *(_DWORD *)(v3 + 16);
          v11 = *(_QWORD *)(v3 + 12);
          if ( (_DWORD)v11 )
          {
            *(_DWORD *)(v11 + 16) = HIDWORD(v11);
            HIDWORD(v11) = *(_DWORD *)(v3 + 16);
          }
          if ( HIDWORD(v11) )
            *(_DWORD *)(HIDWORD(v11) + 12) = *(_DWORD *)(v3 + 12);
          --*((_DWORD *)*v7 + 3);
          goto LABEL_18;
        }
        HIDWORD(v9) = *((_DWORD *)*v7 + 5);
LABEL_8:
        *(_DWORD *)(v6 + HIDWORD(v9) + 8) = *(_DWORD *)(v3 + 8);
        HIDWORD(v9) = *(_DWORD *)(v3 + 8);
        goto LABEL_9;
      }
      free(*(void **)v8);
      free(*v7);
      dword_68C6C = 0;
LABEL_18:
      ++v2;
      v5 = v5 + *(double *)(*(_DWORD *)(v3 + 36) + 376);
      sub_2A70C((void ***)(v3 + 36), "cgminer.c", "clear_stratum_shares", 7445);
      --*(_DWORD *)(a1 + 748);
      free((void *)v3);
      if ( !v4 )
        goto LABEL_19;
    }
    v9 = *(_QWORD *)(v8 + 16);
    if ( v3 == (_DWORD)v9 - HIDWORD(v9) )
      goto LABEL_28;
    goto LABEL_8;
  }
LABEL_19:
  if ( pthread_mutex_unlock(&stru_68C54) )
  {
LABEL_37:
    v18 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v18,
      "cgminer.c",
      "clear_stratum_shares",
      7451);
LABEL_36:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  result = (int *)off_67964();
  if ( v2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
    {
      snprintf(s, 0x800u, "Lost %d shares due to stratum disconnect on pool %d", v2, *(_DWORD *)a1);
      sub_1DD60(4, s, 0);
    }
    result = &dword_762C8;
    v13 = *(double *)(a1 + 88) + v5;
    v14 = dbl_72EF8 + v5;
    v15 = *(_QWORD *)&dword_762C8 + v2;
    v16 = *(_DWORD *)(a1 + 120) + v2;
    *(double *)(a1 + 88) = v13;
    *(_QWORD *)&dword_762C8 = v15;
    *(_DWORD *)(a1 + 120) = v16;
    dbl_72EF8 = v14;
  }
  return result;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 68C6C: using guessed type int dword_68C6C;
// 72D90: using guessed type char byte_72D90;
// 72EF8: using guessed type double dbl_72EF8;
// 762C8: using guessed type int dword_762C8;

//----- (00032BF8) --------------------------------------------------------
int __fastcall sub_32BF8(int a1)
{
  int v2; // r2
  int v3; // r1
  int v4; // r3
  int v5; // r12
  int v6; // r0
  int v7; // r1
  int v8; // r6
  _DWORD *v9; // r2
  int v10; // r3
  int v11; // r2
  int v12; // r12
  int v13; // r2
  int v14; // r3
  int v16; // r0
  int *v17; // r0
  int *v18; // r0
  struct timespec abstime; // [sp+10h] [bp-810h] BYREF
  __time_t v20[2]; // [sp+18h] [bp-808h] BYREF
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_68B20) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "hash_pop", 8262);
    goto LABEL_58;
  }
  if ( !dword_68C04 || !*(_DWORD *)(*(_DWORD *)(dword_68C04 + 344) + 12) )
  {
    if ( !a1 )
      goto LABEL_35;
    do
    {
      sub_206A0(v20);
      abstime.tv_sec = v20[0] + 10;
      abstime.tv_nsec = 1000 * v20[1];
      pthread_cond_signal(&stru_72E68);
      if ( pthread_cond_timedwait((pthread_cond_t *)(dword_74F60 + 40), (pthread_mutex_t *)dword_68B20, &abstime) )
      {
        if ( !byte_68B78 )
        {
          byte_68B78 = 1;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
          {
            strcpy(s, "Waiting for work to be available from pools.");
            sub_1DD60(4, s, 0);
          }
        }
      }
    }
    while ( !dword_68C04 || !*(_DWORD *)(*(_DWORD *)(dword_68C04 + 344) + 12) );
  }
  if ( byte_68B78 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
    {
      strcpy(s, "Work available from pools, resuming.");
      sub_1DD60(4, s, 0);
    }
    v2 = dword_68C04;
    byte_68B78 = 0;
    if ( !dword_68C04 )
      goto LABEL_43;
  }
  else
  {
    v2 = dword_68C04;
  }
  v3 = *(_DWORD *)(v2 + 344);
  if ( *(_DWORD *)(v3 + 12) <= dword_68C78 || *(_BYTE *)(v2 + 273) || !*(_DWORD *)(v2 + 276) )
  {
    a1 = v2;
    goto LABEL_17;
  }
  a1 = *(_DWORD *)(v2 + 352);
  if ( !a1 )
LABEL_43:
    __und(0);
  while ( !*(_BYTE *)(a1 + 273) )
  {
    v16 = *(_DWORD *)(a1 + 352);
    if ( !*(_DWORD *)(a1 + 276) )
      break;
    a1 = *(_DWORD *)(a1 + 352);
    if ( !v16 )
      goto LABEL_43;
  }
LABEL_17:
  v4 = *(_DWORD *)(a1 + 348);
  if ( v4 )
  {
    v5 = *(_DWORD *)(v3 + 20);
    v6 = a1 + 344;
    if ( a1 != *(_DWORD *)(v3 + 16) - v5 )
    {
LABEL_19:
      v7 = dword_68C04;
      *(_DWORD *)(v4 + v5 + 8) = *(_DWORD *)(a1 + 352);
      v8 = *(_DWORD *)(a1 + 352);
LABEL_20:
      v9 = *(_DWORD **)(v7 + 344);
      if ( v8 )
      {
        *(_DWORD *)(v8 + v9[5] + 4) = *(_DWORD *)(a1 + 348);
        v9 = *(_DWORD **)(v7 + 344);
      }
      v10 = 12 * ((v9[1] - 1) & *(_DWORD *)(a1 + 372));
      --*(_DWORD *)(*v9 + v10 + 4);
      v11 = **(_DWORD **)(v7 + 344);
      v12 = *(_DWORD *)(v11 + v10);
      if ( v12 == v6 )
      {
        v7 = *(_DWORD *)(a1 + 360);
        *(_DWORD *)(v11 + v10) = v7;
      }
      v13 = *(_DWORD *)(a1 + 356);
      v14 = *(_DWORD *)(a1 + 360);
      if ( v12 == v6 )
        v7 = dword_68C04;
      if ( v13 )
      {
        *(_DWORD *)(v13 + 16) = v14;
        v14 = *(_DWORD *)(a1 + 360);
      }
      if ( v14 )
        *(_DWORD *)(v14 + 12) = *(_DWORD *)(a1 + 356);
      --*(_DWORD *)(*(_DWORD *)(v7 + 344) + 12);
      goto LABEL_31;
    }
LABEL_47:
    *(_DWORD *)(v3 + 16) = v4 + v5;
    v4 = *(_DWORD *)(a1 + 348);
    if ( v4 )
    {
      v5 = *(_DWORD *)(*(_DWORD *)(v2 + 344) + 20);
      goto LABEL_19;
    }
    v8 = *(_DWORD *)(a1 + 352);
LABEL_46:
    v7 = v8;
    dword_68C04 = v8;
    goto LABEL_20;
  }
  v8 = *(_DWORD *)(a1 + 352);
  if ( v8 )
  {
    v5 = *(_DWORD *)(v3 + 20);
    v6 = a1 + 344;
    if ( a1 != *(_DWORD *)(v3 + 16) - v5 )
      goto LABEL_46;
    goto LABEL_47;
  }
  free(*(void **)v3);
  free(*(void **)(dword_68C04 + 344));
  dword_68C04 = 0;
LABEL_31:
  if ( !*(_BYTE *)(a1 + 273) && *(_DWORD *)(a1 + 276) )
    --dword_68C78;
  pthread_cond_signal(&stru_72E68);
  pthread_cond_signal((pthread_cond_t *)(dword_74F60 + 40));
  dword_76080 = time(0);
LABEL_35:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_68B20) )
  {
    v18 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v18, "cgminer.c", "hash_pop", 8334);
LABEL_58:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  off_67964();
  return a1;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 68B20: using guessed type int dword_68B20;
// 68B78: using guessed type char byte_68B78;
// 68C04: using guessed type int dword_68C04;
// 68C78: using guessed type int dword_68C78;
// 72D90: using guessed type char byte_72D90;
// 72E68: using guessed type pthread_cond_t stru_72E68;
// 74F60: using guessed type int dword_74F60;
// 76080: using guessed type int dword_76080;

//----- (00033090) --------------------------------------------------------
int __fastcall sub_33090(_DWORD *a1)
{
  int v2; // r5
  pthread_t v4; // r0
  int v5; // r5
  int *v6; // r0
  int *v7; // r0
  int *v8; // r0
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( !*((_BYTE *)a1 + 107) )
  {
    v4 = pthread_self();
    pthread_detach(v4);
  }
  v2 = *((unsigned __int8 *)a1 + 105);
  if ( *((_BYTE *)a1 + 105) )
    return 0;
  while ( !sub_2CCEC(a1, 0) )
  {
    sub_31F20((int)a1);
    if ( *((_BYTE *)a1 + 107) )
      goto LABEL_16;
    sleep(0x1Eu);
    if ( *((_BYTE *)a1 + 105) )
      return 0;
  }
  sub_2CC84((int)a1, (_BYTE *)a1 + 97);
  if ( pthread_mutex_lock(&stru_76148) )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "cgminer.c", "test_pool_thread", 10867);
    goto LABEL_23;
  }
  if ( pthread_rwlock_wrlock(&rwlock) )
  {
    v7 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v7, "cgminer.c", "test_pool_thread", 10867);
    goto LABEL_23;
  }
  if ( !byte_68A04 )
  {
    v5 = *a1;
    dword_68B74 = (int)a1;
    byte_68A04 = 1;
    v2 = v5 != 0;
  }
  if ( pthread_rwlock_unlock(&rwlock) )
  {
    v8 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v8,
      "cgminer.c",
      "test_pool_thread",
      10881);
    goto LABEL_23;
  }
  if ( pthread_mutex_unlock(&stru_76148) )
  {
    v9 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v9,
      "cgminer.c",
      "test_pool_thread",
      10881);
LABEL_23:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  off_67964();
  if ( v2 && (byte_72D90 || byte_686E0 || dword_67840 > 4) )
  {
    snprintf(s, 0x800u, "Switching to pool %d %s - first alive pool", *a1, (const char *)a1[41]);
    sub_1DD60(5, s, 0);
  }
  sub_2FDBC(a1);
  sub_31A9C(0);
LABEL_16:
  *((_BYTE *)a1 + 284) = 0;
  return 0;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 68A04: using guessed type char byte_68A04;
// 68B74: using guessed type int dword_68B74;
// 72D90: using guessed type char byte_72D90;
// 76148: using guessed type pthread_mutex_t stru_76148;

//----- (00033320) --------------------------------------------------------
void __fastcall sub_33320(const char *a1, _DWORD *a2)
{
  int v4; // r10
  int v5; // r11
  char *v6; // r9
  char *v7; // r8
  char *v8; // r7
  signed int v9; // r4
  size_t v10; // r4
  const char *v11; // r12
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _DWORD *v16; // r12
  int v17; // r1
  int *v18; // r0
  int v19; // r3
  int v20; // [sp+20h] [bp-C0Ch]
  int v21; // [sp+24h] [bp-C08h]
  char s[1024]; // [sp+28h] [bp-C04h] BYREF
  _DWORD v23[5]; // [sp+428h] [bp-804h] BYREF
  __int16 v24; // [sp+43Ch] [bp-7F0h]

  if ( !dword_68900 )
    return;
  v21 = a2[64];
  v4 = *(_DWORD *)(sub_2F688(v21) + 36);
  v5 = a2[65];
  v20 = a2[108];
  v6 = sub_1FA90((int)(a2 + 40), 32);
  v7 = sub_1FA90((int)(a2 + 48), 32);
  v8 = sub_1FA90((int)a2, 128);
  v9 = snprintf(
         s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         v20,
         a1,
         v6,
         *(const char **)(v5 + 164),
         *(const char **)(*(_DWORD *)(v4 + 4) + 8),
         *(_DWORD *)(v4 + 8),
         v21,
         v7,
         v8);
  free(v6);
  free(v7);
  free(v8);
  if ( v9 >= 1024 )
  {
    s[1023] = 0;
    goto LABEL_5;
  }
  if ( v9 >= 0 )
  {
LABEL_5:
    if ( pthread_mutex_lock(&stru_68C7C) )
    {
      v18 = _errno_location();
      snprintf(
        (char *)v23,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v18,
        "cgminer.c",
        "sharelog",
        684);
    }
    else
    {
      v10 = fwrite(s, v9, 1u, (FILE *)dword_68900);
      fflush((FILE *)dword_68900);
      if ( !pthread_mutex_unlock(&stru_68C7C) )
      {
        off_67964();
        if ( v10 != 1 && (byte_72D90 || byte_686E0 || dword_67840 > 2) )
        {
          v11 = "sharelog fwrite error";
LABEL_12:
          v12 = *(_DWORD *)v11;
          v13 = *((_DWORD *)v11 + 1);
          v14 = *((_DWORD *)v11 + 2);
          v15 = *((_DWORD *)v11 + 3);
          v16 = v11 + 16;
          v23[0] = v12;
          v23[1] = v13;
          v23[2] = v14;
          v23[3] = v15;
          v17 = v16[1];
          v23[4] = *v16;
          v24 = v17;
          sub_1DD60(3, (const char *)v23, 0);
          return;
        }
        return;
      }
      v19 = *_errno_location();
      snprintf(
        (char *)v23,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        v19,
        "cgminer.c",
        "sharelog",
        687);
    }
    sub_1DD60(3, (const char *)v23, 1);
    sub_2C230(1, 1);
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    v11 = "sharelog printf error";
    goto LABEL_12;
  }
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 68900: using guessed type int dword_68900;
// 72D90: using guessed type char byte_72D90;

//----- (000335C8) --------------------------------------------------------
__int64 __fastcall sub_335C8(int a1, int a2)
{
  pthread_mutex_t *v2; // r8
  size_t v5; // r11
  int v6; // lr
  int v7; // r0
  int v8; // r3
  int v9; // r2
  int v10; // r5
  const void *v11; // r1
  int *v12; // r2
  char *v13; // r0
  unsigned int v14; // t1
  int v15; // r0
  char *v17; // r9
  const char *v18; // r0
  char *v19; // r8
  int *v20; // r0
  int *v21; // r0
  int *v22; // r0
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  __int64 v26; // [sp+18h] [bp-86Ch] BYREF
  _BYTE v27[28]; // [sp+20h] [bp-864h] BYREF
  char v28; // [sp+3Ch] [bp-848h] BYREF
  char v29[28]; // [sp+40h] [bp-844h] BYREF
  int v30; // [sp+5Ch] [bp-828h] BYREF
  _BYTE v31[32]; // [sp+60h] [bp-824h] BYREF
  char s[2052]; // [sp+80h] [bp-804h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
  {
    v20 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v20, "cgminer.c", "gen_stratum_work", 8440);
    goto LABEL_29;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v21 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v21, "cgminer.c", "gen_stratum_work", 8440);
    goto LABEL_29;
  }
  v5 = *(_DWORD *)(a1 + 648);
  v6 = *(_DWORD *)(a1 + 1584);
  v7 = *(_DWORD *)(a1 + 1592);
  v26 = *(_QWORD *)(a1 + 640);
  sub_232EC((void *)(v6 + v7), &v26, v5, (int)"cgminer.c", (int)"gen_stratum_work", 8445);
  v8 = *(_DWORD *)(a1 + 640);
  v9 = *(_DWORD *)(a1 + 644);
  ++*(_QWORD *)(a1 + 640);
  *(_DWORD *)(a2 + 296) = v8;
  *(_DWORD *)(a2 + 300) = v9;
  *(_DWORD *)(a2 + 304) = *(_DWORD *)(a1 + 648);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v22 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v22,
      "cgminer.c",
      "gen_stratum_work",
      8451);
    goto LABEL_29;
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v23 = _errno_location();
    snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v23, "cgminer.c", "gen_stratum_work", 8451);
    goto LABEL_29;
  }
  v10 = pthread_mutex_unlock(v2);
  if ( v10 )
  {
    v24 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v24,
      "cgminer.c",
      "gen_stratum_work",
      8451);
    goto LABEL_29;
  }
  sub_1EA3C(*(char **)(a1 + 1584), *(_DWORD *)(a1 + 1588), s);
  sub_1EA3C(s, 0x20u, v27);
  sub_232EC(v29, v27, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8455);
  if ( *(int *)(a1 + 1724) > 0 )
  {
    do
    {
      v11 = *(const void **)(*(_DWORD *)(a1 + 692) + 4 * v10++);
      sub_232EC(v31, v11, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8459);
      sub_1EA3C(v29, 0x40u, s);
      sub_1EA3C(s, 0x20u, v27);
      sub_232EC(v29, v27, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8461);
    }
    while ( *(_DWORD *)(a1 + 1724) > v10 );
  }
  v12 = (int *)&v28;
  v13 = (char *)&v26 + 4;
  do
  {
    v14 = v12[1];
    ++v12;
    *((_DWORD *)v13 + 1) = bswap32(v14);
    v13 += 4;
  }
  while ( &v30 != v12 );
  sub_232EC((void *)a2, (const void *)(a1 + 1596), 0x70u, (int)"cgminer.c", (int)"gen_stratum_work", 8470);
  sub_232EC((void *)(a2 + 36), v27, 0x20u, (int)"cgminer.c", (int)"gen_stratum_work", 8471);
  *(_QWORD *)(a2 + 312) = *(_QWORD *)(a1 + 1840);
  *(_DWORD *)(a2 + 288) = _strdup(*(const char **)(a1 + 688));
  *(_DWORD *)(a2 + 320) = _strdup(*(const char **)(a1 + 628));
  *(_DWORD *)(a2 + 308) = _strdup((const char *)(a1 + 1820));
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v25 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v25,
      "cgminer.c",
      "gen_stratum_work",
      8482);
LABEL_29:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  off_67964();
  if ( !byte_686E1 )
    goto LABEL_12;
  v17 = sub_1FA90(a2, 112);
  v18 = sub_1FA90((int)v27, 32);
  v19 = (char *)v18;
  if ( byte_686E1 )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
      goto LABEL_21;
    snprintf(s, 0x800u, "Generated stratum merkle %s", v18);
    sub_1DD60(7, s, 0);
    if ( !byte_686E1 )
      goto LABEL_27;
    if ( !byte_72D90 )
    {
LABEL_21:
      if ( !byte_686E0 && dword_67840 <= 6 )
        goto LABEL_24;
    }
    snprintf(s, 0x800u, "Generated stratum header %s", v17);
    sub_1DD60(7, s, 0);
    if ( byte_686E1 )
    {
      if ( byte_72D90 )
      {
LABEL_26:
        snprintf(
          s,
          0x800u,
          "Work job_id %s nonce2 %llu ntime %s",
          *(const char **)(a2 + 288),
          *(_QWORD *)(a2 + 296),
          *(const char **)(a2 + 308));
        sub_1DD60(7, s, 0);
        goto LABEL_27;
      }
LABEL_24:
      if ( !byte_686E0 && dword_67840 <= 6 )
        goto LABEL_27;
      goto LABEL_26;
    }
  }
LABEL_27:
  free(v17);
  free(v19);
LABEL_12:
  sub_28C84(a2);
  sub_2B4D0((void *)(a2 + 160));
  ++dword_72F14;
  if ( time(0) - dword_68C94 > 5 )
  {
    dword_68C94 = time(0);
    dword_68C98 = dword_72F14;
  }
  v15 = dword_68C9C;
  *(_BYTE *)(a2 + 284) = 1;
  *(_DWORD *)(a2 + 336) = v15;
  *(_DWORD *)(a2 + 248) = 0;
  *(_BYTE *)(a2 + 280) = 0;
  *(_BYTE *)(a2 + 440) = 83;
  *(_DWORD *)(a2 + 244) = 60;
  *(_DWORD *)(a2 + 260) = a1;
  sub_28A90(a2);
  return sub_206A0((__time_t *)(a2 + 264));
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68C94: using guessed type int dword_68C94;
// 68C98: using guessed type int dword_68C98;
// 68C9C: using guessed type int dword_68C9C;
// 72D90: using guessed type char byte_72D90;
// 72F14: using guessed type int dword_72F14;

//----- (00033BA8) --------------------------------------------------------
int __fastcall sub_33BA8(int *a1, int *a2, int a3, int a4, __int64 a5, unsigned int a6)
{
  pthread_mutex_t *v8; // r6
  unsigned int v11; // r2
  int v12; // r2
  unsigned int v14; // r1
  int v15; // [sp+Ch] [bp-8h]

  v8 = (pthread_mutex_t *)(a3 + 212);
  *a2 = (int)sub_2D914();
  v15 = *a1;
  if ( pthread_mutex_lock(v8) )
    sub_2CB60("get_work_by_nonce2", 8410);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a3 + 236)) )
    sub_2CB04("get_work_by_nonce2", 8410);
  v11 = bswap32(a6);
  *(_QWORD *)(a3 + 640) = a5;
  a6 = v11;
  sub_232EC((void *)(a3 + 1596), &a6, 4u, (int)"cgminer.c", (int)"get_work_by_nonce2", 8413);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a3 + 236)) )
    sub_2D6AC("get_work_by_nonce2", 8414);
  if ( pthread_mutex_unlock(v8) )
    sub_2CBBC("get_work_by_nonce2", 8414);
  off_67964();
  sub_335C8(a3, *a2);
  v12 = dword_68C9C;
  *(_DWORD *)(*a2 + 260) = a4;
  v14 = a6;
  *(_DWORD *)(*a2 + 256) = v15;
  *(_DWORD *)(*a2 + 336) = v12;
  ++*(_DWORD *)(*(_DWORD *)(*a2 + 260) + 68);
  *(_BYTE *)(*a2 + 272) = 1;
  *(_DWORD *)(*a2 + 444) = v14;
  return 1;
}
// 67964: using guessed type int (*off_67964)();
// 68C9C: using guessed type int dword_68C9C;

//----- (00033D04) --------------------------------------------------------
int __fastcall sub_33D04(int a1, int a2)
{
  int v2; // r5
  int v6; // r8
  int v7; // r9
  int v8; // r8
  const char *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // lr
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r2
  int *v21; // r0
  int *v22; // r0
  __time_t v23[2]; // [sp+10h] [bp-80Ch] BYREF
  _DWORD s[10]; // [sp+18h] [bp-804h] BYREF
  __int16 v25; // [sp+40h] [bp-7DCh]

  v2 = (unsigned __int8)byte_68C50;
  if ( !byte_68C50 )
  {
    if ( dword_72DB0 )
      return v2;
    if ( *(_DWORD *)(a1 + 336) != dword_68C9C )
    {
      v2 = (unsigned __int8)byte_686E1;
      if ( byte_686E1 )
      {
        if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
        {
          strcpy((char *)s, "Work stale due to block mismatch");
          sub_1DD60(7, (const char *)s, 0);
        }
        return v2;
      }
      return 1;
    }
    v6 = *(_DWORD *)(a1 + 276);
    v7 = *(_DWORD *)(a1 + 260);
    if ( v6 <= dword_681F4 )
      v6 = dword_681F8;
    if ( !a2 && *(_BYTE *)(v7 + 656) )
    {
      if ( !*(_BYTE *)(v7 + 657) || !*(_BYTE *)(v7 + 659) )
      {
        v2 = (unsigned __int8)byte_686E1;
        if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
        {
          strcpy((char *)s, "Work stale due to stratum inactive");
          sub_1DD60(7, (const char *)s, 0);
          return v2;
        }
        return 1;
      }
      if ( pthread_mutex_lock((pthread_mutex_t *)(v7 + 212)) )
        sub_2CB60("stale_work", 5153);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v7 + 236)) )
        sub_2DCC0("stale_work", 5153);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(v7 + 212)) )
      {
        v22 = _errno_location();
        snprintf(
          (char *)s,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v22,
          "cgminer.c",
          "stale_work",
          5153);
LABEL_56:
        sub_1DD60(3, (const char *)s, 1);
        sub_2C230(1, 1);
      }
      if ( strcmp(*(const char **)(a1 + 288), *(const char **)(v7 + 688)) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
        {
          off_67964();
          v2 = (unsigned __int8)byte_686E1;
          if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
          {
            v9 = "Work stale due to stratum job_id mismatch";
            goto LABEL_42;
          }
          return 1;
        }
        goto LABEL_55;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 236)) )
      {
LABEL_55:
        v21 = _errno_location();
        snprintf(
          (char *)s,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v21,
          "cgminer.c",
          "stale_work",
          5160);
        goto LABEL_56;
      }
      off_67964();
    }
    v8 = v6 - (int)(*(double *)(v7 + 448) * 5.0 + 1.0);
    sub_206A0(v23);
    if ( v8 < 5 )
      v8 = 5;
    if ( v8 <= v23[0] - *(_DWORD *)(a1 + 264) )
    {
      v2 = (unsigned __int8)byte_686E1;
      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        strcpy((char *)s, "Work stale due to expiry");
        sub_1DD60(7, (const char *)s, 0);
        return v2;
      }
      return 1;
    }
    if ( a2 | (unsigned __int8)byte_74F65 ^ 1
      || v7 == sub_2FB78()
      || *(_BYTE *)(a1 + 282)
      || (unsigned int)(dword_68AE4 - 3) <= 1 )
    {
      return v2;
    }
    v2 = (unsigned __int8)byte_686E1;
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      v9 = "Work stale due to fail only pool mismatch";
LABEL_42:
      v10 = *(_DWORD *)v9;
      v11 = *((_DWORD *)v9 + 1);
      v12 = *((_DWORD *)v9 + 2);
      v13 = *((_DWORD *)v9 + 3);
      v14 = (int *)(v9 + 16);
      s[0] = v10;
      s[1] = v11;
      s[2] = v12;
      s[3] = v13;
      v15 = *v14;
      v16 = v14[1];
      v17 = v14[2];
      v18 = v14[3];
      v14 += 4;
      s[4] = v15;
      s[5] = v16;
      s[6] = v17;
      s[7] = v18;
      v19 = v14[1];
      v20 = v14[2];
      s[8] = *v14;
      s[9] = v19;
      v25 = v20;
      sub_1DD60(7, (const char *)s, 0);
      return v2;
    }
    return 1;
  }
  return 0;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681F4: using guessed type int dword_681F4;
// 681F8: using guessed type int dword_681F8;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68AE4: using guessed type int dword_68AE4;
// 68C50: using guessed type char byte_68C50;
// 68C9C: using guessed type int dword_68C9C;
// 72D90: using guessed type char byte_72D90;
// 72DB0: using guessed type int dword_72DB0;
// 74F65: using guessed type char byte_74F65;

//----- (000341EC) --------------------------------------------------------
void **__fastcall sub_341EC(int a1, void *a2)
{
  _DWORD *v4; // r5
  time_t v5; // r9
  int v6; // r9
  int v7; // r3
  void **v8; // r0
  int v9; // r3
  void **v10; // r3
  void **result; // r0
  double v12; // d7
  int v13; // r2
  int v14; // r3
  int v15; // r3
  int v16; // r2
  char *v17; // r1
  int v18; // r3
  bool v19; // cc
  void **v20; // [sp+Ch] [bp-804h] BYREF
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v20 = 0;
  v4 = *(_DWORD **)(a1 + 36);
  sub_2876C(a1);
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy(s, "Popping work from get queue to get work");
    sub_1DD60(7, s, 0);
  }
  v5 = time(0);
  while ( !v20 )
  {
    v20 = (void **)sub_32BF8(1);
    if ( sub_33D04((int)v20, 0) )
    {
      sub_2AA08(&v20, "cgminer.c", "get_work", 8724);
      sub_2D548();
    }
  }
  v6 = time(0) - v5;
  v7 = (unsigned __int8)byte_686E1;
  if ( v6 <= 0 )
  {
LABEL_16:
    if ( !v7 )
      goto LABEL_20;
    goto LABEL_17;
  }
  if ( !byte_686E1 )
  {
    v4[58] += v6;
    goto LABEL_20;
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
  {
    snprintf(s, 0x800u, "Get work blocked for %ld seconds", v6);
    sub_1DD60(7, s, 0);
    v7 = (unsigned __int8)byte_686E1;
    v4[58] += v6;
    goto LABEL_16;
  }
  v4[58] += v6;
LABEL_17:
  if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
  {
    snprintf(s, 0x800u, "Got work from get queue to get work for thread %d", a2);
    sub_1DD60(7, s, 0);
  }
LABEL_20:
  v8 = v20;
  v9 = (unsigned __int8)byte_68C50;
  v20[64] = a2;
  if ( !v9 )
    goto LABEL_21;
  v14 = v4[95] + v4[96];
  v4[95] = v14;
  if ( v14 <= 0 )
  {
    v4[96] = 1;
LABEL_40:
    sub_232EC(v8, (char *)&unk_696A0 + 160 * v14, 0xA0u, (int)"cgminer.c", (int)"set_benchmark_work", 8705);
    goto LABEL_21;
  }
  if ( v14 <= 15 )
    goto LABEL_40;
  v15 = v4[94];
  v16 = -1;
  v17 = (char *)&unk_68CA0;
  v4[96] = -1;
  v18 = v15 + 1;
  v19 = v18 <= 15;
  if ( v18 > 15 )
    v18 = 0;
  else
    v16 = 5 * v18;
  v4[94] = v18;
  if ( v19 )
    v17 = (char *)&unk_68CA0 + 32 * v16;
  sub_232EC(v8, v17, 0xA0u, (int)"cgminer.c", (int)"set_benchmark_work", 8701);
LABEL_21:
  sub_287A4(a1);
  v10 = v20;
  *((_BYTE *)v20 + 272) = 1;
  result = v10;
  v12 = *(double *)(v4[1] + 104);
  if ( v12 > *((double *)v10 + 47) )
    v12 = *((double *)v10 + 47);
  *((double *)v10 + 28) = v12;
  v13 = v4[1];
  if ( *(double *)(v13 + 112) > v12 )
    v12 = *(double *)(v13 + 112);
  *((double *)v10 + 28) = v12;
  return result;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68C50: using guessed type char byte_68C50;
// 72D90: using guessed type char byte_72D90;

//----- (00034538) --------------------------------------------------------
void **__fastcall sub_34538(int a1, pthread_rwlock_t *a2, void *a3)
{
  void **v4; // r4

  v4 = sub_341EC(a1, a3);
  sub_2DA20(a2, (int)v4);
  return v4;
}

//----- (00034560) --------------------------------------------------------
void **__fastcall sub_34560(int a1)
{
  int v1; // r3
  void **v3; // r3
  void **v5; // [sp+4h] [bp-Ch] BYREF

  v1 = *(_DWORD *)(a1 + 356);
  if ( !v1 )
    return 0;
  v5 = *(void ***)(a1 + 356);
  if ( sub_33D04(v1, 0) )
  {
    sub_2AA08(&v5, "cgminer.c", "__get_queued", 9496);
    sub_2D548();
  }
  else
  {
    sub_2BBB4(a1, (int)v5);
  }
  v3 = v5;
  *(_DWORD *)(a1 + 356) = 0;
  return v3;
}

//----- (000345E0) --------------------------------------------------------
void **__fastcall sub_345E0(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r4
  void **v3; // r5

  v1 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_2CB04("get_queued", 9517);
  v3 = sub_34560((int)a1);
  if ( pthread_rwlock_unlock(v1) )
    sub_2D6AC("get_queued", 9519);
  off_67964();
  return v3;
}
// 67964: using guessed type int (*off_67964)();

//----- (0003464C) --------------------------------------------------------
void sub_3464C()
{
  int v0; // r6
  int v1; // r4
  void **v2; // r3
  int v3; // r1
  char *v4; // r9
  int v5; // r0
  int v6; // r2
  void **v7; // r12
  char *v8; // r8
  _DWORD *v9; // r0
  int v10; // r2
  int v11; // r0
  void **v12; // lr
  _DWORD *v13; // r0
  _DWORD *v14; // r2
  int v15; // r0
  int *v16; // r0
  int *v17; // r0
  void **v18; // [sp+14h] [bp-808h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v0 = pthread_mutex_lock((pthread_mutex_t *)dword_68B20);
  if ( v0 )
  {
    v16 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v16, "cgminer.c", "discard_stale", 5442);
    goto LABEL_39;
  }
  v18 = (void **)dword_68C04;
  if ( !dword_68C04 )
  {
    pthread_cond_signal(&stru_72E68);
    if ( !pthread_mutex_unlock((pthread_mutex_t *)dword_68B20) )
    {
      off_67964();
      return;
    }
    goto LABEL_41;
  }
  v1 = *(_DWORD *)(dword_68C04 + 352);
  if ( !sub_33D04(dword_68C04, 0) )
    goto LABEL_19;
LABEL_4:
  v2 = v18;
  v3 = dword_68C04;
  v4 = (char *)v18[87];
  v5 = *(_DWORD *)(dword_68C04 + 344);
  if ( v4 )
  {
    v6 = *(_DWORD *)(v5 + 20);
    v7 = v18 + 86;
    if ( v18 != (void **)(*(_DWORD *)(v5 + 16) - v6) )
    {
LABEL_6:
      *(_DWORD *)&v4[v6 + 8] = v2[88];
      v8 = (char *)v2[88];
LABEL_7:
      v9 = *(_DWORD **)(v3 + 344);
      if ( v8 )
      {
        *(_DWORD *)&v8[v9[5] + 4] = v2[87];
        v9 = *(_DWORD **)(v3 + 344);
      }
      v10 = 3 * ((v9[1] - 1) & (unsigned int)v2[93]);
      --*(_DWORD *)(*v9 + 4 * v10 + 4);
      v11 = **(_DWORD **)(v3 + 344);
      v12 = *(void ***)(v11 + 4 * v10);
      if ( v12 == v7 )
      {
        v3 = (int)v2[90];
        *(_DWORD *)(v11 + 4 * v10) = v3;
      }
      v13 = v2[89];
      v14 = v2[90];
      if ( v12 == v7 )
        v3 = dword_68C04;
      if ( v13 )
      {
        v13[4] = v14;
        v14 = v2[90];
      }
      if ( v14 )
        v14[3] = v2[89];
      --*(_DWORD *)(*(_DWORD *)(v3 + 344) + 12);
      goto LABEL_18;
    }
LABEL_25:
    *(_DWORD *)(v5 + 16) = &v4[v6];
    v4 = (char *)v2[87];
    if ( v4 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(v3 + 344) + 20);
      goto LABEL_6;
    }
    v8 = (char *)v2[88];
LABEL_24:
    v3 = (int)v8;
    dword_68C04 = (int)v8;
    goto LABEL_7;
  }
  v8 = (char *)v18[88];
  if ( v8 )
  {
    v6 = *(_DWORD *)(v5 + 20);
    v7 = v18 + 86;
    if ( v18 != (void **)(*(_DWORD *)(v5 + 16) - v6) )
      goto LABEL_24;
    goto LABEL_25;
  }
  free(*(void **)v5);
  free(*(void **)(dword_68C04 + 344));
  dword_68C04 = 0;
LABEL_18:
  ++v0;
  sub_2AA08(&v18, "cgminer.c", "discard_stale", 5449);
LABEL_19:
  while ( 1 )
  {
    v18 = (void **)v1;
    if ( !v1 )
      break;
    v15 = v1;
    v1 = *(_DWORD *)(v1 + 352);
    if ( sub_33D04(v15, 0) )
      goto LABEL_4;
  }
  pthread_cond_signal(&stru_72E68);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_68B20) )
  {
LABEL_41:
    v17 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "discard_stale", 5455);
LABEL_39:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  off_67964();
  if ( v0 && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "Discarded %d stales that didn't match current hash", v0);
    sub_1DD60(7, s, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68B20: using guessed type int dword_68B20;
// 68C04: using guessed type int dword_68C04;
// 72D90: using guessed type char byte_72D90;
// 72E68: using guessed type pthread_cond_t stru_72E68;

//----- (00034994) --------------------------------------------------------
int sub_34994()
{
  pthread_t v0; // r0
  int v1; // r8
  int v2; // r5
  int v3; // r3
  pthread_rwlock_t *v4; // r4

  v0 = pthread_self();
  pthread_detach(v0);
  sub_3464C();
  if ( pthread_rwlock_rdlock(&stru_74F90) )
    sub_2DCC0("restart_thread", 5508);
  v1 = dword_76228;
  v2 = pthread_rwlock_unlock(&stru_74F90);
  if ( v2 )
    sub_2D6AC("restart_thread", 5510);
  off_67964();
  if ( v1 > 0 )
  {
    do
    {
      v3 = *(_DWORD *)(dword_73F20 + 4 * v2);
      v4 = *(pthread_rwlock_t **)(v3 + 36);
      if ( v4 && !v4[1].__lock )
      {
        *(_BYTE *)(v3 + 62) = 1;
        sub_308D8(v4);
        if ( pthread_mutex_lock(&stru_76018) )
          sub_2CB60("restart_thread", 5529);
        (*(void (__fastcall **)(pthread_rwlock_t *))(v4->__nr_readers + 76))(v4);
        if ( pthread_mutex_unlock(&stru_76018) )
          sub_2CBBC("restart_thread", 5531);
        off_67964();
      }
      ++v2;
    }
    while ( v1 != v2 );
  }
  if ( pthread_mutex_lock(&stru_74F6C) )
    sub_2CB60("restart_thread", 5535);
  pthread_cond_broadcast(&stru_76198);
  if ( pthread_mutex_unlock(&stru_74F6C) )
    sub_2CBBC("restart_thread", 5537);
  off_67964();
  return 0;
}
// 67964: using guessed type int (*off_67964)();
// 73F20: using guessed type int dword_73F20;
// 74F6C: using guessed type pthread_mutex_t stru_74F6C;
// 74F90: using guessed type pthread_rwlock_t stru_74F90;
// 76018: using guessed type pthread_mutex_t stru_76018;
// 76198: using guessed type pthread_cond_t stru_76198;
// 76228: using guessed type int dword_76228;

//----- (00034B04) --------------------------------------------------------
void __fastcall sub_34B04(int a1, unsigned __int64 a2)
{
  double v3; // d0
  int v5; // r4
  char *v6; // r0
  int v7; // r11
  double v8; // d9
  int v9; // r6
  int v10; // r5
  double v11; // r0
  double v12; // r0
  double v13; // r0
  double v14; // r0
  double v15; // r0
  double v16; // d10
  int v17; // r3
  int *v18; // r11
  int v19; // r3
  int v20; // r8
  double v21; // r0
  double v22; // d8
  double v23; // r0
  int v24; // r10
  __int64 v25; // r0
  int v26; // r3
  double v27; // d5
  int v28; // r0
  int v29; // r5
  double v30; // r0
  int v31; // r1
  double v32; // r0
  double v33; // d10
  double v34; // d6
  double v35; // d5
  double v36; // d7
  double v37; // d7
  unsigned __int64 v38; // r0
  unsigned __int64 v39; // r0
  unsigned __int64 v40; // r0
  unsigned __int64 v41; // r0
  unsigned __int64 v42; // r0
  double v43; // r0
  double v44; // r0
  double v45; // r0
  double v46; // r0
  double v47; // r0
  double v48; // r0
  int *v49; // r0
  int *v50; // r0
  int v51; // r3
  int v52; // r12
  int v53; // r3
  int v54; // r12
  char v56[16]; // [sp+20h] [bp-884h] BYREF
  char v57[16]; // [sp+30h] [bp-874h] BYREF
  char v58[16]; // [sp+40h] [bp-864h] BYREF
  char v59[16]; // [sp+50h] [bp-854h] BYREF
  struct sysinfo info; // [sp+60h] [bp-844h] BYREF
  char s[2052]; // [sp+A0h] [bp-804h] BYREF

  if ( sysinfo(&info) )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      v5 = *_errno_location();
      v6 = strerror(v5);
      snprintf(s, 0x800u, "Failed to get sysinfo, errno:%u, reason:%s\n", v5, v6);
      sub_1DD60(6, s, 0);
    }
    dword_761D4 = time(0);
  }
  else
  {
    dword_761D4 = info.uptime;
  }
  sub_206A0(&dword_68B28);
  sub_209CC();
  v7 = dword_68B28;
  v8 = v3;
  if ( dword_681D0 > dword_68B28 - dword_6A0A0 )
  {
    if ( a1 < 0 )
      return;
    v24 = 0;
    sub_235FC(&unk_68B94, &dword_68B28);
  }
  else
  {
    dword_6A0A0 = dword_68B28;
    sub_235FC(&unk_68B94, &dword_68B28);
    if ( a1 < 0 )
    {
      v9 = pthread_mutex_lock(&stru_72ED8);
      if ( !v9 )
      {
        if ( dword_76228 > 0 )
        {
          do
          {
            while ( 1 )
            {
              v10 = *(_DWORD *)(sub_2F688(v9) + 36);
              sub_209CC();
              sub_235FC((void *)(v10 + 140), &dword_68B28);
              if ( v3 > 0.0 )
                break;
              if ( dword_76228 <= ++v9 )
                goto LABEL_15;
            }
            LODWORD(v11) = v10 + 48;
            v12 = sub_2A0D8(v11);
            LODWORD(v12) = v10 + 56;
            v13 = sub_2A0D8(v12);
            LODWORD(v13) = v10 + 64;
            v14 = sub_2A0D8(v13);
            LODWORD(v14) = v10 + 72;
            ++v9;
            v3 = 0.0;
            sub_2A0D8(v14);
          }
          while ( dword_76228 > v9 );
        }
LABEL_15:
        if ( pthread_mutex_unlock(&stru_72ED8) )
        {
          v53 = *_errno_location();
          v54 = 7176;
          goto LABEL_74;
        }
        off_67964();
        if ( !pthread_mutex_lock(&stru_72ED8) )
        {
          LODWORD(v15) = sub_4AB04(a2);
          v16 = v15;
          v17 = dword_68C00;
          dbl_72D88 = dbl_72D88 + v15;
          goto LABEL_18;
        }
LABEL_68:
        v49 = _errno_location();
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v49, "cgminer.c", "hashmeter", 7179);
        goto LABEL_69;
      }
      v51 = *_errno_location();
      v52 = 7161;
LABEL_72:
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v51, "cgminer.c", "hashmeter", v52);
      goto LABEL_69;
    }
    v24 = 1;
  }
  v28 = sub_2F688(a1);
  v29 = *(_DWORD *)(v28 + 36);
  sub_235FC((void *)(v28 + 44), &dword_68B28);
  *(_DWORD *)(v29 + 240) = v7;
  sub_209CC();
  sub_235FC((void *)(v29 + 140), &dword_68B28);
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    LODWORD(v30) = sub_4AB04(a2);
    snprintf(s, 0x800u, "[thread %d: %llu hashes, %.1f mhash/sec]", a1, a2, v30 / v3 / 1000000.0);
    sub_1DD60(7, s, 0);
  }
  LODWORD(a2) = sub_4AB70(a2, 0xF4240u);
  HIDWORD(a2) = v31;
  if ( pthread_mutex_lock(&stru_72ED8) )
  {
    v51 = *_errno_location();
    v52 = 7132;
    goto LABEL_72;
  }
  LODWORD(v32) = sub_4AB04(a2);
  v16 = v32;
  *(double *)(v29 + 80) = *(double *)(v29 + 80) + v32;
  if ( v3 > 0.0 )
  {
    LODWORD(v32) = v29 + 48;
    v43 = sub_2A0D8(v32);
    LODWORD(v43) = v29 + 56;
    v44 = sub_2A0D8(v43);
    LODWORD(v44) = v29 + 64;
    v45 = sub_2A0D8(v44);
    LODWORD(v45) = v29 + 72;
    sub_2A0D8(v45);
  }
  if ( pthread_mutex_unlock(&stru_72ED8) )
  {
    v53 = *_errno_location();
    v54 = 7139;
    goto LABEL_74;
  }
  off_67964();
  if ( ((unsigned __int8)v24 & (unsigned __int8)byte_76014) != 0 )
  {
    sub_2C350(s, 0x100u, v29);
    printf("%s          \r", s);
    fflush((FILE *)stdout);
    if ( pthread_mutex_lock(&stru_72ED8) )
      goto LABEL_68;
    v17 = dword_68C00;
    dbl_72D88 = dbl_72D88 + v16;
    goto LABEL_18;
  }
  if ( pthread_mutex_lock(&stru_72ED8) )
    goto LABEL_68;
  v17 = dword_68C00;
  dbl_72D88 = dbl_72D88 + v16;
  if ( v24 )
  {
LABEL_18:
    v18 = (int *)&unk_68BA0;
    v19 = v17 + 1;
    v20 = 0;
    v21 = 0.0;
    if ( v19 > 11 )
      v19 = 0;
    dword_68C00 = v19;
    do
    {
      v22 = *(double *)v18;
      v18 += 2;
      if ( v22 >= 0.0 )
      {
        LODWORD(v23) = sub_4AB04(*(__int64 *)&v21);
        ++v20;
        LODWORD(v21) = sub_4ABD0(v23 + v22);
      }
    }
    while ( v18 != &dword_68C00 );
    if ( v20 )
    {
      LODWORD(a2) = sub_4AB70(*(unsigned __int64 *)&v21, v20);
      HIDWORD(a2) = HIDWORD(v21);
    }
    if ( (double)dword_681D0 > 0.0 )
    {
      sub_4AB04(a2);
      LODWORD(v48) = &dbl_761C8;
      v21 = sub_2A0D8(v48);
      if ( v8 <= 0.0 )
        goto LABEL_28;
    }
    else if ( v8 <= 0.0 )
    {
LABEL_28:
      v24 = 1;
      LODWORD(v25) = sub_4ABD0(dbl_761C8 * 1000000.0);
      *(_QWORD *)&dword_76188 = v25;
      v26 = dword_68C00;
      v27 = 0.0;
      dbl_68BA8[dword_68C00 - 1] = 0.0;
      goto LABEL_44;
    }
    LODWORD(v21) = &dbl_762D8;
    v46 = sub_2A0D8(v21);
    LODWORD(v46) = &dbl_762D0;
    v47 = sub_2A0D8(v46);
    if ( v8 > 0.0 )
    {
      LODWORD(v47) = &dbl_72EC0;
      sub_2A0D8(v47);
    }
    goto LABEL_28;
  }
  v26 = dword_68C00;
  v27 = dbl_68BA8[dword_68C00 - 1];
LABEL_44:
  v33 = v16 + v27;
  v34 = (double)dword_761D4;
  v35 = dbl_681E0;
  v36 = (double)dword_76194;
  dbl_68BA8[v26 - 1] = v33;
  v37 = v34 - v36;
  dbl_681C0 = v37;
  if ( v37 - v35 > 86400.0 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "cgminer time error total_secs = %f last_total_secs = %f", v37, v35);
      sub_1DD60(3, s, 0);
    }
    if ( !pthread_mutex_unlock(&stru_72ED8) )
    {
      off_67964();
      sub_30A48();
      if ( !pthread_mutex_lock(&stru_72ED8) )
      {
        if ( !v24 )
          goto LABEL_51;
LABEL_56:
        LODWORD(v38) = sub_4ABD0(dbl_72D88 / dbl_681C0 * 1000000.0);
        sub_287D8(v38, v56, 0x10u, 4);
        dbl_6A0A8 = (double)((int)dbl_761C8 / 10) / 100.0;
        LODWORD(v39) = sub_4ABD0(dbl_761C8 * 1000000.0);
        sub_287D8(v39, v57, 0x10u, 4);
        LODWORD(v40) = sub_4ABD0(dbl_762D8 * 1000000.0);
        sub_287D8(v40, v58, 0x10u, 4);
        LODWORD(v41) = sub_4ABD0(dbl_762D0 * 1000000.0);
        sub_287D8(v41, v59, 0x10u, 4);
        LODWORD(v42) = sub_4ABD0(dbl_72EC0 * 1000000.0);
        sub_287D8(v42, s, 0x10u, 4);
        snprintf(
          byte_6A0B0,
          0x100u,
          "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
          dword_681D0,
          v57,
          v58,
          v59,
          s,
          v56);
        if ( !pthread_mutex_unlock(&stru_72ED8) )
        {
          off_67964();
          printf("%s          \r", byte_6A0B0);
          fflush((FILE *)stdout);
          return;
        }
        goto LABEL_70;
      }
      v51 = *_errno_location();
      v52 = 7229;
      goto LABEL_72;
    }
    v53 = *_errno_location();
    v54 = 7227;
LABEL_74:
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v53, "cgminer.c", "hashmeter", v54);
LABEL_69:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  dbl_681E0 = v37;
  if ( v24 )
    goto LABEL_56;
LABEL_51:
  if ( pthread_mutex_unlock(&stru_72ED8) )
  {
LABEL_70:
    v50 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v50, "cgminer.c", "hashmeter", 7270);
    goto LABEL_69;
  }
  off_67964();
}
// 34BF4: variable 'v3' is possibly undefined
// 34CBC: variable 'v11' is possibly undefined
// 34D6C: variable 'v15' is possibly undefined
// 34DB4: variable 'v21' is possibly undefined
// 34DC4: variable 'v23' is possibly undefined
// 34E44: variable 'v25' is possibly undefined
// 34F54: variable 'v30' is possibly undefined
// 34F9C: variable 'v31' is possibly undefined
// 34FC0: variable 'v32' is possibly undefined
// 351BC: variable 'v38' is possibly undefined
// 35214: variable 'v39' is possibly undefined
// 3523C: variable 'v40' is possibly undefined
// 35264: variable 'v41' is possibly undefined
// 3528C: variable 'v42' is possibly undefined
// 3542C: variable 'v48' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681C0: using guessed type double dbl_681C0;
// 681D0: using guessed type int dword_681D0;
// 681E0: using guessed type double dbl_681E0;
// 68594: using guessed type int stdout;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68B28: using guessed type int dword_68B28;
// 68BA8: using guessed type double dbl_68BA8[11];
// 68C00: using guessed type int dword_68C00;
// 6A0A0: using guessed type int dword_6A0A0;
// 6A0A8: using guessed type double dbl_6A0A8;
// 72D88: using guessed type double dbl_72D88;
// 72D90: using guessed type char byte_72D90;
// 72EC0: using guessed type double dbl_72EC0;
// 72ED8: using guessed type pthread_mutex_t stru_72ED8;
// 76014: using guessed type char byte_76014;
// 76188: using guessed type int dword_76188;
// 76194: using guessed type int dword_76194;
// 761C8: using guessed type double dbl_761C8;
// 761D4: using guessed type int dword_761D4;
// 76228: using guessed type int dword_76228;
// 762D0: using guessed type double dbl_762D0;
// 762D8: using guessed type double dbl_762D8;

//----- (00035C74) --------------------------------------------------------
void __fastcall sub_35C74(int a1)
{
  int v2; // r8
  int v3; // r3
  int v4; // r3
  int v5; // r9
  signed int v6; // r11
  unsigned __int64 v7; // r6
  int v8; // r3
  void **v9; // r3
  double v10; // d7
  void **v11; // r2
  int *v12; // r5
  void **v13; // r0
  __int64 v14; // r4
  int v15; // r4
  int v16; // r3
  int v17; // r1
  int v18; // r5
  bool v19; // nf
  int v20; // r4
  int v21; // r4
  int v22; // r3
  bool v23; // cc
  unsigned __int64 v24; // r2
  _BOOL4 v25; // r1
  int v26; // r3
  int v27; // r1
  unsigned int v28; // r0
  unsigned int v29; // r0
  unsigned int v30; // r0
  unsigned int v31; // r0
  int v32; // [sp+Ch] [bp-868h]
  _DWORD *v33; // [sp+10h] [bp-864h]
  _DWORD *v34; // [sp+14h] [bp-860h]
  unsigned int v35; // [sp+18h] [bp-85Ch]
  signed int v36; // [sp+24h] [bp-850h]
  void *v37; // [sp+28h] [bp-84Ch]
  int v38; // [sp+2Ch] [bp-848h]
  int v39; // [sp+2Ch] [bp-848h]
  int v40; // [sp+2Ch] [bp-848h]
  struct timespec *remaining; // [sp+30h] [bp-844h]
  unsigned int v42; // [sp+38h] [bp-83Ch]
  unsigned int v43; // [sp+44h] [bp-830h]
  void **v44; // [sp+4Ch] [bp-828h] BYREF
  int v45; // [sp+50h] [bp-824h] BYREF
  int v46; // [sp+54h] [bp-820h]
  __time_t v47; // [sp+58h] [bp-81Ch] BYREF
  int v48; // [sp+5Ch] [bp-818h]
  __time_t v49[2]; // [sp+60h] [bp-814h] BYREF
  __time_t v50[2]; // [sp+68h] [bp-80Ch] BYREF
  struct timespec requested_time; // [sp+70h] [bp-804h] BYREF

  v2 = *(_DWORD *)(a1 + 36);
  v32 = *(_DWORD *)(v2 + 4);
  v3 = dword_681D0 / 5;
  if ( (int)((unsigned __int64)(1717986919LL * dword_681D0) >> 32) >> 1 == dword_681D0 >> 31 )
    v3 = 1;
  v36 = v3;
  if ( *(_DWORD *)(a1 + 4) )
    v4 = *(unsigned __int8 *)(a1 + 8);
  else
    v4 = 1;
  v37 = *(void **)a1;
  remaining = (struct timespec *)v4;
  v35 = (*(int (__fastcall **)(int))(v32 + 48))(a1);
  sub_206A0(&v45);
  sub_206A0(v50);
  if ( *(_BYTE *)(v2 + 364) )
    goto LABEL_53;
  v5 = *(unsigned __int8 *)(v2 + 364);
  v6 = v5;
  v7 = 0;
  v8 = 1000000 * v36 + 1023;
  if ( 1000000 * v36 >= 0 )
    v8 = 1000000 * v36;
  v42 = v8 >> 10;
  do
  {
    v44 = sub_341EC(a1, v37);
    *(_BYTE *)(a1 + 62) = 0;
    *(_BYTE *)(v2 + 172) = 1;
    sub_206A0(v49);
    v44[62] = 0;
    *(_QWORD *)(v2 + 160) = 0;
    if ( !(*(int (__fastcall **)(int))(v32 + 56))(a1) )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf((char *)&requested_time, 0x800u, "work prepare failed, exiting mining thread %d", v37);
        sub_1DD60(3, (const char *)&requested_time, 0);
      }
      break;
    }
    v9 = v44;
    v34 = (_DWORD *)(v2 + 304);
    v10 = *(double *)(v32 + 104);
    v33 = (_DWORD *)(v2 + 312);
    if ( v10 > *((double *)v44 + 47) )
      v10 = *((double *)v44 + 47);
    *((double *)v44 + 28) = v10;
    if ( *(double *)(v32 + 112) > v10 )
      v10 = *(double *)(v32 + 112);
    *((double *)v9 + 28) = v10;
    while ( 1 )
    {
      sub_206A0(&v47);
      sub_202C0(&v47, &v45);
      sub_202F4(&v45, (int *)(v2 + 296));
      if ( sub_20338(&v45, v34) )
        sub_235FC(v34, &v45);
      if ( sub_2036C(&v45, v33) )
        sub_235FC(v33, &v45);
      v11 = v44;
      ++*(_DWORD *)(v2 + 292);
      v12 = (int *)v11[65];
      sub_202F4(&v45, v12 + 97);
      if ( sub_20338(&v45, v12 + 99) )
        sub_235FC(v12 + 99, &v45);
      if ( sub_2036C(&v45, v12 + 101) )
        sub_235FC(v12 + 101, &v45);
      v13 = v44;
      ++v12[96];
      sub_206A0((__time_t *)v13 + 106);
      pthread_setcancelstate(1, 0);
      sub_287A4(a1);
      v14 = ((__int64 (__fastcall *)(int, void **, char *, _DWORD))*(_DWORD *)(v32 + 64))(
              a1,
              v44,
              (char *)v44[62] + v35,
              0);
      sub_2876C(a1);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      sub_206A0(&v45);
      if ( v14 == -1 )
        break;
      v7 += v14;
      if ( *(_QWORD *)(v2 + 160) < v14 )
        *(_QWORD *)(v2 + 160) = v14;
      v15 = v46;
      v16 = v45;
      v17 = v45 - v47;
      v5 += v46 - v48 + (v46 - v48 < 0 ? 0xF4240 : 0);
      if ( v46 - v48 < 0 )
        --v17;
      v6 += v17;
      if ( v5 > 1000000 )
      {
        ++v6;
        v5 -= 1000000;
      }
      v18 = v45 - v49[0];
      if ( v46 - v49[1] < 0 )
        --v18;
      if ( v36 > v6 )
      {
        if ( v35 == -1 )
          goto LABEL_48;
        v27 = v5 + 1024;
        v38 = v45;
        if ( v5 + 1024 < 0 )
          v27 = v5 + 2047;
        v43 = (sub_4A548(1000000, v27 >> 10) + 16) * v36;
        v28 = sub_4A2D0(0xFFFFFC00, v43);
        v16 = v38;
        if ( v28 >= v35 )
          v35 = (v35 * v43) >> 10;
        else
          v35 = -1;
      }
      else if ( v36 < v6 )
      {
        v39 = v45;
        v29 = sub_4A2D0(v36 * v35, v6);
        v16 = v39;
        v35 = v29;
      }
      else if ( v5 > 100000 )
      {
        v40 = v45;
        v30 = sub_4A548(1000000 * v36 + v5, v42);
        v31 = sub_4A2D0(v35 << 10, v30);
        v16 = v40;
        v35 = v31;
      }
      v20 = v15 - v50[1];
      v19 = v20 < 0;
      v21 = v20 + (v20 < 0 ? 0xF4000 : 0);
      v22 = v16 - v50[0];
      if ( v19 )
      {
        --v22;
        v21 += 576;
      }
      if ( v7 )
      {
        v23 = v22 <= 0;
        if ( v22 <= 0 )
          v23 = v21 <= 200000;
        if ( !v23 )
          goto LABEL_43;
      }
      if ( dword_681D0 <= v22 )
      {
LABEL_43:
        v24 = v7;
        v7 = 0;
        sub_34B04((int)v37, v24);
        sub_235FC(v50, &v45);
        if ( *(_BYTE *)(a1 + 62) )
          goto LABEL_56;
      }
      else if ( *(_BYTE *)(a1 + 62) )
      {
LABEL_56:
        if ( !remaining )
        {
          v26 = *(_DWORD *)(a1 + 4);
          requested_time.tv_sec = 0;
          requested_time.tv_nsec = 250000000 * v26;
          nanosleep(&requested_time, 0);
        }
        goto LABEL_52;
      }
      if ( *(_BYTE *)(a1 + 60) || (v5 = *(_DWORD *)(v2 + 32)) != 0 )
      {
        v5 = 0;
        v6 = 0;
        sub_299A8(a1, (int)v37, (int (__fastcall **)(int))(v32 + 92));
      }
      else
      {
        v6 = 0;
      }
LABEL_48:
      v25 = *(_QWORD *)(v2 + 160) > 0xFFFFFFFD;
      if ( dword_681F4 < v18 )
        v25 = 1;
      if ( v25 || sub_33D04((int)v44, 0) )
        goto LABEL_52;
    }
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(
        (char *)&requested_time,
        0x800u,
        "%s %d failure, disabling!",
        *(const char **)(v32 + 8),
        *(_DWORD *)(v2 + 8));
      sub_1DD60(3, (const char *)&requested_time, 0);
    }
    *(_DWORD *)(v2 + 32) = 1;
    sub_22BB4((_DWORD *)v2, 1);
    *(_BYTE *)(v2 + 364) = 1;
LABEL_52:
    sub_2A70C(&v44, "cgminer.c", "hash_sole_work", 9428);
  }
  while ( !*(_BYTE *)(v2 + 364) );
LABEL_53:
  *(_DWORD *)(v2 + 32) = 1;
}
// 67840: using guessed type int dword_67840;
// 681D0: using guessed type int dword_681D0;
// 681F4: using guessed type int dword_681F4;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00036338) --------------------------------------------------------
void __noreturn sub_36338()
{
  int v0; // r4
  int v1; // r5
  int v2; // r3
  int v3; // r0
  int v4; // r4
  int v5; // r6
  int v6; // r1
  int v7; // r3
  int v8; // r3
  int *v9; // r3
  int v10; // r1
  int v11; // t1
  int v12; // r4
  int v13; // r0
  sem_t *v14; // r5
  int v15; // r3
  int *v16; // r0
  int *v17; // r0
  __time_t v18[2]; // [sp+28h] [bp-814h] BYREF
  char v19[8]; // [sp+30h] [bp-80Ch] BYREF
  char s[2052]; // [sp+38h] [bp-804h] BYREF

  pthread_setcanceltype(1, 0);
  sub_22E98("Watchdog");
  sub_29BA0();
  sub_206A0(&dword_68C70);
LABEL_2:
  while ( 1 )
  {
    v0 = 200;
    do
    {
      usleep(0x2710u);
      sub_3464C();
      --v0;
    }
    while ( v0 );
    sub_34B04(-1, 0);
    sub_206A0(v18);
    if ( byte_72E5C )
      goto LABEL_93;
    if ( byte_76030 || byte_74F30 )
    {
      if ( !sub_29640() )
      {
        if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
        {
          if ( !byte_76030 )
            goto LABEL_87;
          goto LABEL_52;
        }
        snprintf(s, 0x800u, "Pausing execution as per stop time %02d:%02d scheduled", dword_74F3C, dword_74F38);
        sub_1DD60(4, s, 0);
        if ( !byte_76030 )
        {
LABEL_87:
          strcpy(s, "Terminating execution as planned");
          sub_1DD60(3, s, 1);
          sub_2C230(0, 1);
        }
        if ( byte_72D90 || byte_686E0 )
        {
LABEL_53:
          snprintf(s, 0x800u, "Will restart execution as scheduled at %02d:%02d", dword_7603C, dword_76038);
          sub_1DD60(4, s, 0);
        }
        else
        {
LABEL_52:
          if ( dword_67840 > 3 )
            goto LABEL_53;
        }
        byte_72E5C = 1;
        if ( pthread_rwlock_rdlock(&stru_74F90) )
        {
          v16 = _errno_location();
          snprintf(
            s,
            0x800u,
            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
            *v16,
            "cgminer.c",
            "watchdog_thread",
            10521);
          goto LABEL_89;
        }
        if ( dword_76228 > 0 )
        {
          v9 = (int *)dword_73F20;
          v10 = dword_73F20 + 4 * dword_76228;
          do
          {
            v11 = *v9++;
            *(_BYTE *)(v11 + 60) = 1;
          }
          while ( (int *)v10 != v9 );
        }
        if ( pthread_rwlock_unlock(&stru_74F90) )
        {
          v17 = _errno_location();
          snprintf(
            s,
            0x800u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v17,
            "cgminer.c",
            "watchdog_thread",
            10528);
LABEL_89:
          sub_1DD60(3, s, 1);
          sub_2C230(1, 1);
        }
        off_67964();
        goto LABEL_8;
      }
      if ( byte_72E5C )
      {
LABEL_93:
        if ( !byte_76030 && !byte_74F30 || sub_29640() )
          break;
      }
    }
LABEL_8:
    if ( dword_74FE0 > 0 )
    {
      v1 = 0;
      while ( 1 )
      {
        v3 = sub_2DFF4(v1);
        v4 = v3;
        v5 = **(_DWORD **)(v3 + 152);
        if ( !v5 )
          goto LABEL_22;
        (*(void (**)(void))(*(_DWORD *)(v3 + 4) + 32))();
        snprintf(v19, 8u, "%s %d", *(const char **)(*(_DWORD *)(v4 + 4) + 8), *(_DWORD *)(v4 + 8));
        if ( *(_BYTE *)(v5 + 61) || *(_DWORD *)(v4 + 32) == 1 )
          goto LABEL_22;
        v6 = *(_DWORD *)(v4 + 96);
        v7 = v18[0] - *(_DWORD *)(v5 + 44);
        if ( !v6 )
        {
          if ( v7 <= 120 )
            goto LABEL_22;
          v2 = (unsigned __int8)byte_72D90;
          *(_QWORD *)(v4 + 48) = 0;
          *(_DWORD *)(v4 + 96) = 1;
          if ( v2 || byte_686E0 || dword_67840 > 2 )
          {
            snprintf(s, 0x800u, "%s: Idle for more than 60 seconds, declaring SICK!", v19);
            sub_1DD60(3, s, 0);
          }
          sub_206A0((__time_t *)(v5 + 52));
          sub_22BB4((_DWORD *)v4, 3);
          if ( !byte_681FC )
            goto LABEL_22;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
          {
            snprintf(s, 0x800u, "%s: Attempting to restart", v19);
            sub_1DD60(3, s, 0);
          }
LABEL_20:
          if ( *(_DWORD *)(v4 + 32) != 1 )
            (*(void (__fastcall **)(int))(*(_DWORD *)(v4 + 4) + 16))(v4);
          goto LABEL_22;
        }
        if ( v7 <= 119 )
        {
          if ( v6 != 4 && (byte_72D90 || byte_686E0 || dword_67840 > 2) )
          {
            snprintf(s, 0x800u, "%s: Recovered, declaring WELL!", v19);
            sub_1DD60(3, s, 0);
          }
          *(_DWORD *)(v4 + 96) = 0;
          *(_DWORD *)(v4 + 240) = time(0);
          goto LABEL_22;
        }
        if ( v6 != 1 )
          break;
        if ( v7 > 600 )
        {
          v8 = (unsigned __int8)byte_72D90;
          *(_DWORD *)(v4 + 96) = 2;
          if ( v8 || byte_686E0 || dword_67840 > 2 )
          {
            snprintf(s, 0x800u, "%s: Not responded for more than 10 minutes, declaring DEAD!", v19);
            sub_1DD60(3, s, 0);
          }
          sub_206A0((__time_t *)(v5 + 52));
          sub_22BB4((_DWORD *)v4, 4);
          goto LABEL_22;
        }
        if ( v18[0] - *(_DWORD *)(v5 + 52) > 60 )
          goto LABEL_43;
LABEL_22:
        if ( dword_74FE0 <= ++v1 )
          goto LABEL_2;
      }
      if ( v18[0] - *(_DWORD *)(v5 + 52) <= 60 || v6 != 2 )
        goto LABEL_22;
LABEL_43:
      sub_206A0((__time_t *)(v5 + 52));
      if ( byte_681FC )
        goto LABEL_20;
      goto LABEL_22;
    }
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
  {
    snprintf(s, 0x800u, "Restarting execution as per start time %02d:%02d scheduled", dword_7603C, dword_76038);
    sub_1DD60(4, s, 0);
    if ( !byte_74F30 )
      goto LABEL_66;
    if ( byte_72D90 || byte_686E0 )
    {
LABEL_80:
      snprintf(s, 0x800u, "Will pause execution as scheduled at %02d:%02d", dword_74F3C, dword_74F38);
      sub_1DD60(4, s, 0);
LABEL_66:
      v12 = 0;
      for ( byte_72E5C = 0; dword_76228 > v12; ++v12 )
      {
        v13 = sub_2F688(v12);
        v14 = (sem_t *)v13;
        if ( *(_DWORD *)(*(_DWORD *)(v13 + 36) + 32) != 1 )
        {
          v15 = (unsigned __int8)byte_686E1;
          *(_BYTE *)(v13 + 60) = 0;
          if ( v15 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
          {
            snprintf(s, 0x800u, "Pushing sem post to thread %d", *(_DWORD *)v13);
            sub_1DD60(7, s, 0);
          }
          sub_22F9C(v14 + 1, "cgminer.c", "watchdog_thread", 10555);
        }
      }
      goto LABEL_8;
    }
  }
  else if ( !byte_74F30 )
  {
    goto LABEL_66;
  }
  if ( dword_67840 <= 3 )
    goto LABEL_66;
  goto LABEL_80;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681FC: using guessed type char byte_681FC;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68C70: using guessed type int dword_68C70;
// 72D90: using guessed type char byte_72D90;
// 72E5C: using guessed type char byte_72E5C;
// 73F20: using guessed type int dword_73F20;
// 74F30: using guessed type char byte_74F30;
// 74F38: using guessed type int dword_74F38;
// 74F3C: using guessed type int dword_74F3C;
// 74F90: using guessed type pthread_rwlock_t stru_74F90;
// 74FE0: using guessed type int dword_74FE0;
// 76030: using guessed type char byte_76030;
// 76038: using guessed type int dword_76038;
// 7603C: using guessed type int dword_7603C;
// 76228: using guessed type int dword_76228;

//----- (00036B90) --------------------------------------------------------
int __fastcall sub_36B90(_DWORD *a1)
{
  pthread_t v2; // r0
  char *v3; // r0
  const struct timespec *v4; // r1
  int v5; // r5
  __int64 v6; // r6
  int v7; // r0
  int v8; // r1
  __int64 v9; // r2
  bool v10; // zf
  char v11; // r4
  int v12; // r4
  void ***v13; // r6
  void **v14; // r5
  time_t v15; // r0
  void **v16; // r3
  int v17; // r2
  void **v18; // r8
  size_t v19; // r0
  int v20; // r3
  int v21; // r12
  int v22; // r1
  void ***v23; // r5
  int v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r1
  int v27; // r3
  unsigned int v28; // r2
  unsigned int v29; // r1
  int v30; // r3
  unsigned int v31; // r4
  void **v32; // r3
  int v33; // r2
  void **v34; // r3
  char *v35; // r3
  int v36; // r1
  void ****v37; // r3
  __int64 v38; // r2
  time_t v39; // r0
  void **v40; // r2
  int v41; // r3
  int v42; // r0
  _DWORD *v44; // r7
  void **v45; // r3
  unsigned int v46; // r4
  int v47; // r11
  _DWORD *v48; // r5
  _DWORD *v49; // r8
  int v50; // r4
  char *v51; // r9
  unsigned int v52; // r3
  int v53; // r3
  void **v54; // r3
  void *v55; // r2
  unsigned int v56; // r1
  bool v57; // cc
  char *v58; // r2
  char *v59; // lr
  char *v60; // r12
  int v61; // r0
  int v62; // r1
  int v63; // r2
  int v64; // r3
  _DWORD *v65; // lr
  char *v66; // r12
  int v67; // r1
  int v68; // r2
  int v69; // r3
  void **v70; // r0
  void **v71; // r7
  void *v72; // r0
  int *v73; // r0
  int v74; // r3
  const char *v75; // r1
  int v76; // r3
  int v77; // r3
  int v78; // r3
  int v79; // r2
  int v80; // r1
  int v81; // r3
  int v82; // r3
  int v83; // r3
  int v84; // r3
  unsigned int v85; // [sp+20h] [bp-C7Ch]
  int v86; // [sp+24h] [bp-C78h]
  __int64 v87; // [sp+28h] [bp-C74h]
  _DWORD *v88; // [sp+4Ch] [bp-C50h]
  int v89; // [sp+54h] [bp-C48h] BYREF
  void **v90; // [sp+58h] [bp-C44h] BYREF
  int v91; // [sp+5Ch] [bp-C40h] BYREF
  __int64 v92; // [sp+60h] [bp-C3Ch] BYREF
  char v93[12]; // [sp+68h] [bp-C34h] BYREF
  char s[16]; // [sp+74h] [bp-C28h] BYREF
  char v95[20]; // [sp+84h] [bp-C18h] BYREF
  char v96[1024]; // [sp+98h] [bp-C04h] BYREF
  char v97[2052]; // [sp+498h] [bp-804h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(s, 0x10u, "%d/SStratum", *a1);
  sub_22E98(s);
  v3 = sub_1FFFC();
  a1[186] = v3;
  if ( !v3 )
  {
    v59 = " stratum_q in stratum_sthread";
    qmemcpy(v97, "Failed to create", 16);
    v60 = &v97[16];
LABEL_85:
    v61 = *(_DWORD *)v59;
    v62 = *((_DWORD *)v59 + 1);
    v63 = *((_DWORD *)v59 + 2);
    v64 = *((_DWORD *)v59 + 3);
    v65 = v59 + 16;
    *(_DWORD *)v60 = v61;
    *((_DWORD *)v60 + 1) = v62;
    *((_DWORD *)v60 + 2) = v63;
    *((_DWORD *)v60 + 3) = v64;
    v66 = v60 + 16;
    v67 = v65[1];
    v68 = v65[2];
    v69 = v65[3];
    *(_DWORD *)v66 = *v65;
    *((_DWORD *)v66 + 1) = v67;
    *((_DWORD *)v66 + 2) = v68;
    *((_WORD *)v66 + 6) = v69;
    sub_1DD60(3, v97, 1);
    sub_2C230(1, 1);
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    snprintf(
      v97,
      0x800u,
      "in %s , pool: %d, pool_url: %s, miner_name: %s",
      "stratum_sthread",
      *a1,
      (const char *)a1[41],
      (const char *)a1[43]);
    sub_1DD60(5, v97, 0);
    v3 = (char *)a1[186];
  }
  v4 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
  v5 = 0;
  v6 = 0;
  if ( *((_BYTE *)a1 + 105) )
    goto LABEL_48;
  do
  {
    v7 = sub_201A4((int)v3, v4);
    v90 = (void **)v7;
    if ( !v7 )
    {
      v59 = "Stratum q returned empty work";
      v60 = v97;
      goto LABEL_85;
    }
    if ( *(_DWORD *)(v7 + 304) > 8u )
    {
      if ( (byte_72D90 || byte_686E0 || dword_67840 > 2)
        && ((snprintf(
               v97,
               0x800u,
               "Pool %d asking for inappropriately long nonce2 length %d",
               *a1,
               *(_DWORD *)(v7 + 304)),
             sub_1DD60(3, v97, 0),
             byte_72D90)
         || byte_686E0)
        || dword_67840 > 2 )
      {
        strcpy(v97, "Not attempting to submit shares");
        sub_1DD60(3, v97, 0);
      }
      sub_2A70C(&v90, "cgminer.c", "stratum_sthread", 7726);
      goto LABEL_47;
    }
    v8 = *(_DWORD *)(v7 + 76);
    v9 = *(_QWORD *)(v7 + 296);
    v86 = v8;
    v10 = HIDWORD(v9) == HIDWORD(v6);
    v87 = v9;
    if ( HIDWORD(v9) == HIDWORD(v6) )
      v10 = (_DWORD)v9 == (_DWORD)v6;
    v89 = *(_DWORD *)(v7 + 76);
    v11 = v10;
    if ( v8 == v5 )
      v12 = v11 & 1;
    else
      v12 = 0;
    v92 = v9;
    if ( v12 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        snprintf(v97, 0x800u, "Filtering duplicate share to pool %d", *a1);
        sub_1DD60(6, v97, 0);
      }
      sub_2A70C(&v90, "cgminer.c", "stratum_sthread", 7738);
      goto LABEL_47;
    }
    if ( *(double *)(v7 + 312) < *((double *)a1 + 229) )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        snprintf(v97, 0x800u, "Filtering high hash share to pool %d", *a1);
        sub_1DD60(6, v97, 0);
      }
      sub_2A70C(&v90, "cgminer.c", "stratum_sthread", 7746);
      goto LABEL_47;
    }
    sub_1FA20(v93, (int)&v89, 4);
    sub_1FA20(v95, (int)&v92, (int)v90[76]);
    v13 = (void ***)sub_1F8B0(0x34u, 1u, "cgminer.c", "stratum_sthread", 7755);
    v14 = v90;
    v15 = time(0);
    v16 = v90;
    v13[11] = (void **)v15;
    v13[9] = v16;
    memset(v96, 0, sizeof(v96));
    if ( pthread_mutex_lock(&stru_68C54) )
    {
      v73 = _errno_location();
      snprintf(
        v97,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v73,
        "cgminer.c",
        "stratum_sthread",
        7764);
      goto LABEL_104;
    }
    v17 = dword_72DBC;
    v13[10] = (void **)dword_72DBC;
    dword_72DBC = v17 + 1;
    if ( pthread_mutex_unlock(&stru_68C54) )
    {
      v74 = *_errno_location();
      snprintf(
        v97,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        v74,
        "cgminer.c",
        "stratum_sthread",
        7767);
      goto LABEL_104;
    }
    off_67964();
    v91 = 0;
    sub_1FB44(&v91, (unsigned __int8 *)a1 + 1796, 4);
    if ( *((_BYTE *)a1 + 660) )
      snprintf(
        v96,
        0x400u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%08x\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        (const char *)v90[72],
        v95,
        (const char *)v90[77],
        v93,
        bswap32((unsigned int)v90[111] & ~v91),
        v13[10]);
    else
      snprintf(
        v96,
        0x400u,
        "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
        (const char *)a1[43],
        (const char *)v90[72],
        v95,
        (const char *)v90[77],
        v93,
        v13[10]);
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      snprintf(v97, 0x800u, "Submitting share %08lx to pool %d", v14[54], *a1);
      sub_1DD60(6, v97, 0);
    }
    while ( 1 )
    {
      v18 = v13[11];
      if ( (int)v18 + 119 < time(0) )
        goto LABEL_121;
      v19 = strlen(v96);
      if ( sub_2149C((pthread_mutex_t *)a1, v96, v19) )
      {
        if ( pthread_mutex_lock(&stru_68C54) )
        {
          v76 = *_errno_location();
          snprintf(
            v97,
            0x800u,
            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
            v76,
            "cgminer.c",
            "stratum_sthread",
            7811);
          goto LABEL_104;
        }
        v20 = *((unsigned __int8 *)v13 + 40);
        v21 = *((unsigned __int8 *)v13 + 43);
        v22 = *((unsigned __int8 *)v13 + 42);
        v13[5] = (void **)(v13 + 10);
        v23 = (void ***)dword_68C6C;
        v24 = v20 + 17973517 + (v21 << 24) + (v22 << 16) + (*((unsigned __int8 *)v13 + 41) << 8);
        v13[6] = (void **)4;
        v24 ^= 0x7F76Du;
        v25 = (-1622558010 - v24) ^ (v24 << 8);
        v26 = (-17973517 - v24 - v25) ^ (v25 >> 13);
        v27 = (v24 - v25 - v26) ^ (v26 >> 12);
        v28 = (v25 - v26 - v27) ^ (v27 << 16);
        v29 = (v26 - v27 - v28) ^ (v28 >> 5);
        v30 = (v27 - v28 - v29) ^ (v29 >> 3);
        v31 = (v29 - v30 - ((v28 - v29 - v30) ^ (v30 << 10))) ^ (((v28 - v29 - v30) ^ (v30 << 10)) >> 15);
        v13[7] = (void **)v31;
        if ( v23 )
        {
          v32 = *v23;
          v13[2] = 0;
          *v13 = v32;
          v13[1] = (void **)((_BYTE *)(*v23)[4] - (_BYTE *)(*v23)[5]);
          *((_DWORD *)(*v23)[4] + 2) = v13;
          (*v23)[4] = v13;
        }
        else
        {
          v13[2] = 0;
          v13[1] = 0;
          dword_68C6C = (int)v13;
          v70 = (void **)malloc(0x2Cu);
          *v13 = v70;
          if ( !v70 )
            goto LABEL_151;
          memset(v70, 0, 0x2Cu);
          (*v13)[4] = v13;
          (*v13)[1] = (void *)32;
          (*v13)[2] = (void *)5;
          (*v13)[5] = 0;
          v71 = *v13;
          *v71 = malloc(0x180u);
          v72 = **v13;
          if ( !v72 )
            goto LABEL_151;
          memset(v72, 0, 0x180u);
          v23 = v13;
          (*v13)[10] = (void *)-1609490463;
        }
        (*v23)[3] = (char *)(*v23)[3] + 1;
        v33 = 12 * (v31 & ((unsigned int)(*v23)[1] - 1));
        ++*(_DWORD *)((char *)**v23 + v33 + 4);
        v34 = *(void ***)((char *)**v23 + v33);
        v13[3] = 0;
        v13[4] = v34;
        v35 = (char *)**v23;
        v36 = *(_DWORD *)&v35[v33];
        v37 = (void ****)&v35[v33];
        if ( v36 )
        {
          *(_DWORD *)(v36 + 12) = v13;
          v37 = (void ****)((char *)**v23 + v33);
        }
        *v37 = v13;
        v38 = *(_QWORD *)((char *)**v23 + v33 + 4);
        if ( (unsigned int)v38 < 10 * (HIDWORD(v38) + 1) || (*v13)[9] == (void *)1 )
          goto LABEL_34;
        v44 = calloc(24 * (_DWORD)(*v13)[1], 1u);
        if ( v44 )
        {
          (*v13)[6] = (void *)((((2 * (_DWORD)(*v13)[1] - 1) & (unsigned int)(*v13)[3]) != 0)
                             + ((unsigned int)(*v13)[3] >> (*((_BYTE *)*v13 + 8) + 1)));
          (*v13)[7] = 0;
          v45 = *v13;
          v46 = (unsigned int)(*v13)[1];
          if ( v46 )
          {
            v47 = 0;
            v85 = 0;
            v88 = a1;
            do
            {
              v48 = *(_DWORD **)((char *)*v45 + v47);
              if ( v48 )
              {
                while ( 1 )
                {
                  v49 = (_DWORD *)v48[4];
                  v50 = 3 * ((2 * v46 - 1) & v48[7]);
                  v51 = (char *)&v44[v50];
                  v52 = *((_DWORD *)v51 + 1) + 1;
                  *((_DWORD *)v51 + 1) = v52;
                  if ( v52 > (unsigned int)(*v13)[6] )
                  {
                    (*v13)[7] = (char *)(*v13)[7] + 1;
                    *((_DWORD *)v51 + 2) = sub_4A2D0(*((_DWORD *)v51 + 1), (unsigned int)(*v13)[6]);
                  }
                  v48[3] = 0;
                  v48[4] = v44[v50];
                  v53 = v44[v50];
                  if ( v53 )
                    *(_DWORD *)(v53 + 12) = v48;
                  v44[v50] = v48;
                  v45 = *v13;
                  if ( !v49 )
                    break;
                  v46 = (unsigned int)v45[1];
                  v48 = v49;
                }
                v46 = (unsigned int)v45[1];
              }
              v47 += 12;
              ++v85;
            }
            while ( v85 < v46 );
            a1 = v88;
          }
          free(*v45);
          (*v13)[1] = (void *)(2 * (_DWORD)(*v13)[1]);
          (*v13)[2] = (char *)(*v13)[2] + 1;
          **v13 = v44;
          v54 = *v13;
          v55 = (*v13)[7];
          v56 = (unsigned int)(*v13)[3];
          v57 = (unsigned int)v55 > v56 >> 1;
          if ( (unsigned int)v55 <= v56 >> 1 )
            v58 = 0;
          else
            v58 = (char *)v54[8];
          if ( v57 )
            ++v58;
          v54[8] = v58;
          if ( (unsigned int)(*v13)[8] > 1 )
            (*v13)[9] = (void *)1;
LABEL_34:
          ++a1[187];
          if ( !pthread_mutex_unlock(&stru_68C54) )
          {
            off_67964();
            if ( sub_2CC84((int)a1, (_BYTE *)a1 + 96) )
            {
              if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 3 )
              {
                if ( !byte_686E1 )
                {
LABEL_40:
                  v39 = time(0);
                  v40 = v13[11];
                  v41 = (unsigned __int8)byte_686E1;
                  v13[12] = (void **)v39;
                  v42 = v39 - (_DWORD)v40;
                  if ( v42 > 0 )
                    v41 |= 1u;
                  if ( v41 && (byte_72D90 || byte_686E0 || dword_67840 > 5) )
                  {
                    snprintf(v97, 0x800u, "Pool %d stratum share submission lag time %d seconds", *a1, v42);
                    sub_1DD60(6, v97, 0);
                  }
                  goto LABEL_46;
                }
                goto LABEL_82;
              }
              snprintf(v97, 0x800u, "Pool %d communication resumed, submitting work", *a1);
              sub_1DD60(4, v97, 0);
            }
            if ( !byte_686E1 )
              goto LABEL_40;
            if ( byte_72D90 || byte_686E0 )
            {
LABEL_53:
              strcpy(v97, "Successfully submitted, adding to stratum_shares db");
              sub_1DD60(7, v97, 0);
              goto LABEL_40;
            }
LABEL_82:
            if ( dword_67840 <= 6 )
              goto LABEL_40;
            goto LABEL_53;
          }
          v77 = *_errno_location();
          snprintf(
            v97,
            0x800u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            v77,
            "cgminer.c",
            "stratum_sthread",
            7814);
LABEL_104:
          sub_1DD60(3, v97, 1);
          sub_2C230(1, 1);
        }
LABEL_151:
        exit(-1);
      }
      if ( !sub_2CC18((int)a1, (_BYTE *)a1 + 96) && sub_2FFA8((int)a1) )
      {
        if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
        {
          snprintf(v97, 0x800u, "Pool %d stratum share submission failure", *a1);
          sub_1DD60(4, v97, 0);
        }
        v81 = a1[33] + 1;
        ++dword_72DAC;
        a1[33] = v81;
      }
      if ( byte_74F84 )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      {
        v82 = *_errno_location();
        snprintf(
          v97,
          0x800u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          v82,
          "cgminer.c",
          "stratum_sthread",
          7836);
        goto LABEL_104;
      }
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
      {
        v83 = *_errno_location();
        snprintf(
          v97,
          0x800u,
          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          v83,
          "cgminer.c",
          "stratum_sthread",
          7836);
        goto LABEL_104;
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
      {
        v84 = *_errno_location();
        snprintf(
          v97,
          0x800u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v84,
          "cgminer.c",
          "stratum_sthread",
          7836);
        goto LABEL_104;
      }
      v75 = (const char *)a1[157];
      if ( !v75 || strcmp((const char *)v90[80], v75) )
      {
        if ( !pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        {
          off_67964();
          if ( byte_686E1 )
          {
            if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
              goto LABEL_123;
            strcpy(v97, "No matching session id for resubmitting stratum share");
            sub_1DD60(7, v97, 0);
LABEL_121:
            if ( byte_686E1 )
            {
              if ( !byte_72D90 )
                goto LABEL_123;
              goto LABEL_125;
            }
          }
          goto LABEL_126;
        }
LABEL_120:
        v78 = *_errno_location();
        snprintf(
          v97,
          0x800u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v78,
          "cgminer.c",
          "stratum_sthread",
          7838);
        goto LABEL_104;
      }
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        goto LABEL_120;
      off_67964();
      sleep(2u);
    }
    if ( byte_686E1 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
      {
        strcpy(v97, "Lowmem option prevents resubmitting stratum share");
        sub_1DD60(7, v97, 0);
        goto LABEL_121;
      }
LABEL_123:
      if ( byte_686E0 || dword_67840 > 6 )
      {
LABEL_125:
        strcpy(v97, "Failed to submit stratum share, discarding");
        sub_1DD60(7, v97, 0);
      }
    }
LABEL_126:
    sub_2A70C(&v90, "cgminer.c", "stratum_sthread", 7853);
    free(v13);
    v79 = dword_762C8;
    v80 = dword_762CC;
    ++a1[30];
    *(_QWORD *)&dword_762C8 = __PAIR64__(v80, v79) + 1;
LABEL_46:
    v5 = v86;
    v6 = v87;
LABEL_47:
    v4 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
    v3 = (char *)a1[186];
  }
  while ( !*((_BYTE *)a1 + 105) );
LABEL_48:
  sub_200C0((int)v3);
  return 0;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68C6C: using guessed type int dword_68C6C;
// 72D90: using guessed type char byte_72D90;
// 72DAC: using guessed type int dword_72DAC;
// 72DBC: using guessed type int dword_72DBC;
// 74F84: using guessed type char byte_74F84;
// 762C8: using guessed type int dword_762C8;
// 762CC: using guessed type int dword_762CC;

//----- (00037C80) --------------------------------------------------------
int __fastcall sub_37C80(int a1)
{
  _DWORD *v1; // r2
  int v2; // r1
  int v3; // r4
  size_t v4; // r5
  __int64 v6; // r2
  char *v7; // r6
  int v8; // r12
  int v9; // r12
  int v10; // r12
  unsigned int v11; // r7
  size_t v12; // r5
  int v13; // r3
  unsigned __int8 *v14; // r10
  int v15; // r0
  unsigned int v16; // r11
  unsigned int v17; // r7
  unsigned __int8 *v18; // r4
  unsigned int v19; // r1
  unsigned int v20; // r3
  int v21; // r2
  unsigned int v22; // r1
  unsigned int v23; // r3
  int v24; // r2
  unsigned int v25; // r1
  unsigned int v26; // r3
  size_t v27; // r3
  int v28; // r2
  unsigned int v29; // r1
  unsigned int v30; // r0
  int v31; // r2
  unsigned int v32; // r3
  unsigned int v33; // r1
  unsigned int v34; // r2
  unsigned int v35; // r7
  _DWORD *v36; // r2
  int v37; // r4
  int v38; // r8
  int v39; // r4
  int v40; // r3
  int v41; // r3
  char *v42; // r0
  int v43; // r7
  int v44; // r4
  int v45; // r5
  int v46; // r3
  int v47; // r10
  int v48; // r9
  int v49; // r2
  int v50; // r12
  unsigned int v51; // lr
  int v52; // r3
  int v53; // r0
  int v54; // r1
  int v55; // r0
  int v56; // r8
  bool v57; // zf
  int v58; // r3
  bool v59; // zf
  bool v60; // zf
  int v61; // r11
  int v62; // r10
  int v63; // r1
  int v64; // r2
  int v65; // r0
  int v66; // r3
  int v67; // r4
  _DWORD *v68; // r2
  int v69; // r3
  int v70; // r2
  __int64 v71; // r2
  unsigned int v72; // r8
  unsigned int v73; // lr
  unsigned __int8 *v74; // r11
  int v75; // r3
  int v76; // r7
  int v77; // r4
  int v78; // r0
  unsigned __int8 *v79; // r10
  int v80; // r1
  unsigned int v81; // r2
  unsigned int v82; // r7
  int v83; // r3
  unsigned int v84; // r1
  unsigned int v85; // r2
  int v86; // r3
  unsigned int v87; // r1
  unsigned int v88; // r2
  int v89; // r1
  unsigned int v90; // r2
  size_t v91; // lr
  int v92; // r3
  unsigned int v93; // r2
  unsigned int v94; // r12
  int v95; // r3
  unsigned int v96; // r1
  unsigned int v97; // r2
  unsigned int v98; // r3
  unsigned int v99; // r4
  int v100; // r3
  int v101; // r8
  __int64 v102; // r2
  int v103; // r3
  int v104; // r1
  int *v105; // r2
  __int64 v106; // r2
  int v107; // r3
  int v108; // r0
  signed int v109; // r7
  char v110; // r1
  int v111; // r2
  __int64 v112; // r0
  double v113; // r0
  double v114; // d8
  int v115; // kr00_4
  struct tm *v116; // r0
  int v117; // r11
  char *v118; // r3
  int v119; // t1
  int v120; // r1
  const char *v121; // r2
  int v122; // r12
  char *v123; // r3
  _DWORD *v124; // r8
  int v125; // r3
  int v126; // r10
  int v127; // r3
  unsigned int v128; // r4
  _DWORD *v129; // r5
  _DWORD *v130; // r6
  int v131; // r4
  char *v132; // r9
  unsigned int v133; // r3
  int v134; // r2
  int v135; // r3
  _DWORD *v136; // r3
  unsigned int v137; // r2
  unsigned int v138; // r1
  bool v139; // cc
  int v140; // r2
  int v141; // r3
  int v142; // r4
  int *v143; // r0
  int v144; // r3
  int *v145; // r0
  int *v146; // r0
  const char *v147; // lr
  int v148; // r3
  int v149; // r12
  int *v150; // r0
  int *v151; // r0
  int *v152; // r0
  int *v153; // r0
  char *v154; // r3
  void *v155; // r0
  void **v156; // r9
  void *v157; // r0
  unsigned __int64 v158; // r0
  int *v159; // r0
  int v160; // r3
  int *v161; // r0
  _DWORD *v162; // [sp+10h] [bp-88Ch]
  int v163; // [sp+14h] [bp-888h]
  int v164; // [sp+1Ch] [bp-880h]
  size_t v165; // [sp+24h] [bp-878h]
  unsigned int v166; // [sp+24h] [bp-878h]
  char *v167; // [sp+2Ch] [bp-870h]
  char *v168; // [sp+2Ch] [bp-870h]
  int v169; // [sp+30h] [bp-86Ch] BYREF
  _DWORD s2[8]; // [sp+34h] [bp-868h] BYREF
  char s[12]; // [sp+54h] [bp-848h] BYREF
  char v172; // [sp+60h] [bp-83Ch] BYREF
  time_t v173[513]; // [sp+98h] [bp-804h] BYREF

  v1 = *(_DWORD **)(a1 + 260);
  v2 = *(unsigned __int8 *)(a1 + 282);
  v169 = 0;
  v3 = v1[396];
  v162 = v1;
  v163 = v2;
  v4 = *(unsigned __int8 *)(v3 + 42);
  if ( v2 )
    return v163;
  v6 = *(_QWORD *)(a1 + 28);
  v7 = (char *)a1;
  v8 = *(_DWORD *)(a1 + 24);
  s2[0] = *(_DWORD *)(a1 + 32);
  HIDWORD(v6) = *(_DWORD *)(a1 + 20);
  s2[2] = v8;
  v9 = *(_DWORD *)(a1 + 16);
  s2[3] = HIDWORD(v6);
  HIDWORD(v6) = *(_DWORD *)(a1 + 12);
  s2[4] = v9;
  v10 = *(_DWORD *)(a1 + 8);
  s2[5] = HIDWORD(v6);
  HIDWORD(v6) = *(_DWORD *)(a1 + 4);
  s2[1] = v6;
  s2[6] = v10;
  s2[7] = HIDWORD(v6);
  sub_1FA20(s, (int)s2, 32);
  if ( v4 <= 4 )
  {
    sub_232EC(&v169, (const void *)(v3 + 43), v4, (int)"cgminer.c", (int)"test_work_current", 5713);
    --v169;
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(v162 + 53)) )
  {
    v145 = _errno_location();
    snprintf(
      (char *)v173,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v145,
      "cgminer.c",
      "test_work_current",
      5718);
    goto LABEL_204;
  }
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v162 + 59)) )
  {
    v146 = _errno_location();
    v147 = "test_work_current";
    v148 = *v146;
    v149 = 5718;
LABEL_223:
    snprintf((char *)v173, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", v148, "cgminer.c", v147, v149);
    goto LABEL_204;
  }
  if ( *((_BYTE *)v162 + 696) )
  {
    *((_BYTE *)v162 + 696) = 0;
    v7[280] = 1;
  }
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v162 + 59)) )
  {
    v150 = _errno_location();
    snprintf(
      (char *)v173,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v150,
      "cgminer.c",
      "test_work_current",
      5726);
    goto LABEL_204;
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(v162 + 53)) )
  {
    v151 = _errno_location();
    snprintf(
      (char *)v173,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v151,
      "cgminer.c",
      "test_work_current",
      5726);
    goto LABEL_204;
  }
  off_67964();
  v164 = pthread_rwlock_wrlock(&stru_6A1B0);
  if ( v164 )
  {
    v152 = _errno_location();
    v147 = "block_exists";
    v148 = *v152;
    v149 = 5639;
    goto LABEL_223;
  }
  v11 = -1640531527;
  v12 = strlen(s);
  LOWORD(v13) = -16657;
  if ( v12 <= 0xB )
  {
    HIWORD(v13) = -275;
    v15 = -1640531527;
    v16 = v12;
    v18 = (unsigned __int8 *)s;
  }
  else
  {
    v14 = (unsigned __int8 *)&v172;
    v15 = -1640531527;
    HIWORD(v13) = -275;
    v16 = v12;
    do
    {
      v16 -= 12;
      v17 = (*(v14 - 6) << 16) + (*(v14 - 7) << 8) + *(v14 - 8) + (*(v14 - 5) << 24) + v11;
      v18 = v14;
      v19 = (*(v14 - 10) << 16) + (*(v14 - 11) << 8) + *(v14 - 12) + (*(v14 - 9) << 24) - v17;
      v20 = (*(v14 - 2) << 16) + (*(v14 - 3) << 8) + *(v14 - 4) + (*(v14 - 1) << 24) + v13;
      v14 += 12;
      v21 = (v19 - v20 + v15) ^ (v20 >> 13);
      v22 = (v17 - v20 - v21) ^ (v21 << 8);
      v23 = (v20 - v21 - v22) ^ (v22 >> 13);
      v24 = (v21 - v22 - v23) ^ (v23 >> 12);
      v25 = (v22 - v23 - v24) ^ (v24 << 16);
      v26 = (v23 - v24 - v25) ^ (v25 >> 5);
      v15 = (v24 - v25 - v26) ^ (v26 >> 3);
      v11 = (v25 - v26 - v15) ^ (v15 << 10);
      v13 = (v26 - v15 - v11) ^ (v11 >> 15);
    }
    while ( v16 > 0xB );
  }
  v27 = v12 + v13;
  switch ( v16 )
  {
    case 1u:
      goto LABEL_26;
    case 2u:
      goto LABEL_25;
    case 3u:
      goto LABEL_24;
    case 4u:
      goto LABEL_23;
    case 5u:
      goto LABEL_22;
    case 6u:
      goto LABEL_21;
    case 7u:
      goto LABEL_20;
    case 8u:
      goto LABEL_19;
    case 9u:
      goto LABEL_18;
    case 0xAu:
      goto LABEL_17;
    case 0xBu:
      v27 += v18[10] << 24;
LABEL_17:
      v27 += v18[9] << 16;
LABEL_18:
      v27 += v18[8] << 8;
LABEL_19:
      v11 += v18[7] << 24;
LABEL_20:
      v11 += v18[6] << 16;
LABEL_21:
      v11 += v18[5] << 8;
LABEL_22:
      v11 += v18[4];
LABEL_23:
      v15 += v18[3] << 24;
LABEL_24:
      v15 += v18[2] << 16;
LABEL_25:
      v15 += v18[1] << 8;
LABEL_26:
      v15 += *v18;
      break;
    default:
      break;
  }
  v28 = (v15 - v11 - v27) ^ (v27 >> 13);
  v29 = (v11 - v27 - v28) ^ (v28 << 8);
  v30 = (v27 - v28 - v29) ^ (v29 >> 13);
  v31 = (v28 - v29 - v30) ^ (v30 >> 12);
  v32 = (v29 - v30 - v31) ^ (v31 << 16);
  v33 = (v30 - v31 - v32) ^ (v32 >> 5);
  v34 = v31 - v32 - v33;
  v35 = (v33 - (v34 ^ (v33 >> 3)) - ((v32 - v33 - (v34 ^ (v33 >> 3))) ^ ((v34 ^ (v33 >> 3)) << 10)))
      ^ (((v32 - v33 - (v34 ^ (v33 >> 3))) ^ ((v34 ^ (v33 >> 3)) << 10)) >> 15);
  if ( dword_6A1D0 )
  {
    v36 = *(_DWORD **)(dword_6A1D0 + 68);
    v37 = *(_DWORD *)(*v36 + 12 * ((v36[1] - 1) & v35));
    if ( v37 )
    {
      v38 = -v36[5];
      v39 = v37 - v36[5];
      if ( v39 )
      {
        while ( v35 != *(_DWORD *)(v39 + 96)
             || v12 != *(_DWORD *)(v39 + 92)
             || memcmp(*(const void **)(v39 + 88), s, v12) )
        {
          v40 = *(_DWORD *)(v39 + 84);
          if ( v40 )
          {
            v39 = v40 + v38;
            if ( v40 + v38 )
              continue;
          }
          goto LABEL_55;
        }
        if ( pthread_rwlock_unlock(&stru_6A1B0) )
          goto LABEL_234;
        off_67964();
        if ( !memcmp(v162 + 136, s2, 0x20u) )
        {
          v163 = 1;
        }
        else
        {
          if ( !memcmp(s2, &unk_6A1DC, 0x20u) )
          {
            if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
            {
              snprintf((char *)v173, 0x800u, "Pool %d now up to date at height %d", *v162, v169);
              sub_1DD60(6, (const char *)v173, 0);
            }
            v163 = 1;
            sub_232EC(v162 + 136, s2, 0x20u, (int)"cgminer.c", (int)"test_work_current", 5784);
            goto LABEL_46;
          }
          v41 = (unsigned __int8)byte_686E1;
          if ( byte_686E1 )
          {
            if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
            {
              snprintf((char *)v173, 0x800u, "Stale data from pool %d at height %d", *v162, v169);
              sub_1DD60(7, (const char *)v173, 0);
              goto LABEL_46;
            }
            v41 = 0;
          }
          v163 = v41;
        }
LABEL_46:
        if ( v7[280] )
        {
          v139 = (unsigned int)(dword_68AE4 - 3) > 1;
          *((_DWORD *)v7 + 84) = ++dword_68C9C;
          if ( !v139 || (v142 = *((_DWORD *)v7 + 65), v142 == sub_2FB78()) )
          {
            if ( v7[284] )
            {
              if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
              {
                snprintf((char *)v173, 0x800u, "Stratum from pool %d requested work restart", *v162);
                sub_1DD60(5, (const char *)v173, 0);
              }
            }
            else if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
            {
              v154 = "";
              if ( v7[324] )
                v154 = "GBT ";
              snprintf(
                (char *)v173,
                0x800u,
                "%sLONGPOLL from pool %d requested work restart",
                v154,
                **((_DWORD **)v7 + 65));
              sub_1DD60(5, (const char *)v173, 0);
            }
            sub_2C568();
          }
        }
        goto LABEL_54;
      }
    }
  }
LABEL_55:
  v42 = (char *)sub_1F8B0(0x68u, 1u, "cgminer.c", "block_exists", 5643);
  v43 = (int)v42;
  if ( !v42 )
  {
    strcpy((char *)v173, "block_exists OOM");
    sub_1DD60(3, (const char *)v173, 1);
    sub_2C230(1, 1);
  }
  v44 = (unsigned __int16)&dword_761D8;
  strcpy(v42, s);
  v45 = dword_6A1D0;
  v46 = dword_761D8;
  *(_DWORD *)(v43 + 100) = dword_761D8;
  dword_761D8 = v46 + 1;
  if ( !v45 || *(_DWORD *)(*(_DWORD *)(v45 + 68) + 12) <= 3u )
    goto LABEL_114;
  v47 = v45 + 68;
  v48 = 1;
  do
  {
    v49 = v47;
    v47 = 0;
    v50 = 0;
    v51 = 0;
    do
    {
      ++v51;
      if ( v48 )
      {
        v52 = *(_DWORD *)(v49 + 8);
        if ( v52 && (v53 = *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20), (v52 += v53) != 0) )
        {
          v54 = 1;
          do
          {
            if ( v54 == v48 )
            {
              v55 = v54;
              goto LABEL_68;
            }
            v52 = *(_DWORD *)(v52 + 8);
            ++v54;
            if ( !v52 )
              break;
            v52 += v53;
          }
          while ( v52 );
          v55 = v48;
        }
        else
        {
          v55 = v48;
          v54 = 1;
        }
      }
      else
      {
        v52 = v49;
        v55 = 0;
        v54 = 0;
      }
LABEL_68:
      v56 = v49;
      v49 = v52;
      while ( v54 )
      {
        v60 = v49 == 0;
        if ( v49 )
          v60 = v55 == 0;
        if ( v60 )
        {
          if ( v56 )
          {
            v44 = *(_DWORD *)(v56 + 8);
            if ( v44 )
              v44 += *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
            goto LABEL_91;
          }
        }
        else
        {
          v44 = *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
          if ( *(_DWORD *)(v56 - v44 + 100) - *(_DWORD *)(v49 - v44 + 100) > 0 )
          {
            v58 = *(_DWORD *)(v49 + 8);
            if ( v58 )
              v58 += v44;
LABEL_78:
            --v55;
            if ( !v50 )
            {
              v50 = v49;
              v49 = v58;
              goto LABEL_206;
            }
            v44 = v49 - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
            *(_DWORD *)(v50 + 8) = v44;
            if ( !v49 )
            {
              v50 = 0;
              v49 = v58;
              continue;
            }
            goto LABEL_82;
          }
          if ( v56 )
          {
            v144 = *(_DWORD *)(v56 + 8);
            if ( v144 )
              v44 += v144;
            else
              v44 = 0;
            goto LABEL_91;
          }
        }
        v44 = v56;
LABEL_91:
        --v54;
        if ( !v50 )
        {
          v50 = v56;
          v56 = v44;
LABEL_206:
          v47 = v50;
          if ( v50 )
          {
            v44 = 0;
            goto LABEL_83;
          }
          continue;
        }
        if ( !v56 )
        {
          *(_DWORD *)(v50 + 8) = 0;
          v50 = 0;
          v56 = v44;
          continue;
        }
        v58 = v49;
        v49 = v56;
        v61 = v56 - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
        v56 = v44;
        *(_DWORD *)(v50 + 8) = v61;
LABEL_82:
        v44 = v50 - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
        v50 = v49;
        v49 = v58;
LABEL_83:
        *(_DWORD *)(v50 + 4) = v44;
      }
      v57 = v55 == 0;
      if ( v55 )
        v57 = v49 == 0;
      if ( !v57 )
      {
        v58 = *(_DWORD *)(v49 + 8);
        v59 = v58 == 0;
        if ( v58 )
          v44 = *(_DWORD *)(v45 + 68);
        else
          v58 = v54;
        if ( !v59 )
        {
          v44 = *(_DWORD *)(v44 + 20);
          v58 += v44;
        }
        goto LABEL_78;
      }
    }
    while ( v49 );
    if ( v50 )
      *(_DWORD *)(v50 + 8) = 0;
    if ( v51 <= 1 )
      goto LABEL_101;
    v48 *= 2;
  }
  while ( v47 );
  v50 = 0;
LABEL_101:
  *(_DWORD *)(*(_DWORD *)(v45 + 68) + 16) = v50;
  v62 = v47 - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
  v63 = *(_DWORD *)(v62 + 72);
  dword_6A1D0 = v62;
  v164 = *(_DWORD *)(v62 + 100);
  if ( v63 )
  {
    v64 = *(_DWORD *)(v62 + 68);
    v65 = v62 + 68;
    v66 = *(_DWORD *)(v64 + 20);
    if ( v62 != *(_DWORD *)(v64 + 16) - v66 )
      goto LABEL_103;
LABEL_266:
    *(_DWORD *)(v64 + 16) = v63 + v66;
    v63 = *(_DWORD *)(v62 + 72);
    if ( !v63 )
    {
      v67 = *(_DWORD *)(v62 + 76);
      goto LABEL_269;
    }
    v66 = *(_DWORD *)(*(_DWORD *)(v62 + 68) + 20);
LABEL_103:
    v45 = v62;
    *(_DWORD *)(v63 + v66 + 8) = *(_DWORD *)(v62 + 76);
    v67 = *(_DWORD *)(v62 + 76);
LABEL_104:
    v68 = *(_DWORD **)(v45 + 68);
    if ( v67 )
    {
      *(_DWORD *)(v67 + v68[5] + 4) = *(_DWORD *)(v62 + 72);
      v68 = *(_DWORD **)(v45 + 68);
    }
    v69 = 12 * (*(_DWORD *)(v62 + 96) & (v68[1] - 1));
    --*(_DWORD *)(*v68 + v69 + 4);
    v70 = **(_DWORD **)(v45 + 68);
    if ( *(_DWORD *)(v70 + v69) == v65 )
      *(_DWORD *)(v70 + v69) = *(_DWORD *)(v62 + 84);
    v71 = *(_QWORD *)(v62 + 80);
    if ( (_DWORD)v71 )
    {
      *(_DWORD *)(v71 + 16) = HIDWORD(v71);
      HIDWORD(v71) = *(_DWORD *)(v62 + 84);
    }
    if ( HIDWORD(v71) )
      *(_DWORD *)(HIDWORD(v71) + 12) = *(_DWORD *)(v62 + 80);
    --*(_DWORD *)(*(_DWORD *)(v45 + 68) + 12);
  }
  else
  {
    v67 = *(_DWORD *)(v62 + 76);
    v64 = *(_DWORD *)(v62 + 68);
    if ( v67 )
    {
      v66 = *(_DWORD *)(v64 + 20);
      v65 = v62 + 68;
      if ( v62 == *(_DWORD *)(v64 + 16) - v66 )
        goto LABEL_266;
LABEL_269:
      v45 = v67;
      dword_6A1D0 = v67;
      goto LABEL_104;
    }
    v45 = 0;
    free(*(void **)v64);
    free(*(void **)(v62 + 68));
    dword_6A1D0 = 0;
  }
  free((void *)v62);
LABEL_114:
  LOWORD(v72) = 31161;
  v165 = strlen((const char *)v43);
  v73 = v165;
  if ( v165 <= 0xB )
  {
    HIWORD(v72) = -25033;
    v73 = v165;
    v89 = -17973521;
    v79 = (unsigned __int8 *)v43;
    v75 = v72;
  }
  else
  {
    HIWORD(v72) = -25033;
    v74 = (unsigned __int8 *)(v43 + 12);
    v167 = (char *)v43;
    v75 = v72;
    v76 = -17973521;
    do
    {
      v73 -= 12;
      v77 = *(v74 - 1);
      v78 = (*(v74 - 10) << 16) + (*(v74 - 11) << 8) + *(v74 - 12) + (*(v74 - 9) << 24);
      v79 = v74;
      v80 = (*(v74 - 2) << 16) + (*(v74 - 3) << 8) + *(v74 - 4);
      v81 = (*(v74 - 6) << 16) + (*(v74 - 7) << 8) + *(v74 - 8) + (*(v74 - 5) << 24) + v72;
      v74 += 12;
      v82 = v80 + (v77 << 24) + v76;
      v83 = (v78 - v81 - v82 + v75) ^ (v82 >> 13);
      v84 = (v81 - v82 - v83) ^ (v83 << 8);
      v85 = (v82 - v83 - v84) ^ (v84 >> 13);
      v86 = (v83 - v84 - v85) ^ (v85 >> 12);
      v87 = (v84 - v85 - v86) ^ (v86 << 16);
      v88 = (v85 - v86 - v87) ^ (v87 >> 5);
      v75 = (v86 - v87 - v88) ^ (v88 >> 3);
      v72 = (v87 - v88 - v75) ^ (v75 << 10);
      v76 = (v88 - v75 - v72) ^ (v72 >> 15);
    }
    while ( v73 > 0xB );
    v89 = (v88 - v75 - v72) ^ (v72 >> 15);
    v43 = (int)v167;
  }
  v90 = v73 - 1;
  v91 = v89 + v165;
  switch ( v90 )
  {
    case 0u:
      goto LABEL_129;
    case 1u:
      goto LABEL_128;
    case 2u:
      goto LABEL_127;
    case 3u:
      goto LABEL_126;
    case 4u:
      goto LABEL_125;
    case 5u:
      goto LABEL_124;
    case 6u:
      goto LABEL_123;
    case 7u:
      goto LABEL_122;
    case 8u:
      goto LABEL_121;
    case 9u:
      goto LABEL_120;
    case 0xAu:
      v91 += v79[10] << 24;
LABEL_120:
      v91 += v79[9] << 16;
LABEL_121:
      v91 += v79[8] << 8;
LABEL_122:
      v72 += v79[7] << 24;
LABEL_123:
      v72 += v79[6] << 16;
LABEL_124:
      v72 += v79[5] << 8;
LABEL_125:
      v72 += v79[4];
LABEL_126:
      v75 += v79[3] << 24;
LABEL_127:
      v75 += v79[2] << 16;
LABEL_128:
      v75 += v79[1] << 8;
LABEL_129:
      v75 += *v79;
      break;
    default:
      break;
  }
  *(_DWORD *)(v43 + 88) = v43;
  v92 = (v75 - v72 - v91) ^ (v91 >> 13);
  v93 = (v72 - v91 - v92) ^ (v92 << 8);
  v94 = (v91 - v92 - v93) ^ (v93 >> 13);
  v95 = (v92 - v93 - v94) ^ (v94 >> 12);
  v96 = (v93 - v94 - v95) ^ (v95 << 16);
  v97 = (v94 - v95 - v96) ^ (v96 >> 5);
  v98 = v95 - v96 - v97;
  v99 = (v97 - (v98 ^ (v97 >> 3)) - ((v96 - v97 - (v98 ^ (v97 >> 3))) ^ ((v98 ^ (v97 >> 3)) << 10)))
      ^ (((v96 - v97 - (v98 ^ (v97 >> 3))) ^ ((v98 ^ (v97 >> 3)) << 10)) >> 15);
  *(_DWORD *)(v43 + 96) = v99;
  *(_DWORD *)(v43 + 92) = strlen((const char *)v43);
  if ( v45 )
  {
    v100 = *(_DWORD *)(v45 + 68);
    *(_DWORD *)(v43 + 76) = 0;
    v101 = v43 + 68;
    *(_DWORD *)(v43 + 68) = v100;
    *(_DWORD *)(v43 + 72) = *(_DWORD *)(*(_DWORD *)(v45 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v45 + 68) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v45 + 68) + 16) + 8) = v43;
    *(_DWORD *)(*(_DWORD *)(v45 + 68) + 16) = v43 + 68;
    goto LABEL_132;
  }
  *(_DWORD *)(v43 + 76) = 0;
  *(_DWORD *)(v43 + 72) = 0;
  dword_6A1D0 = v43;
  v155 = malloc(0x2Cu);
  *(_DWORD *)(v43 + 68) = v155;
  if ( !v155 )
    goto LABEL_274;
  memset(v155, 0, 0x2Cu);
  v101 = v43 + 68;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 16) = v43 + 68;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 4) = 32;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 8) = 5;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 20) = 68;
  v156 = *(void ***)(v43 + 68);
  *v156 = malloc(0x180u);
  v157 = **(void ***)(v43 + 68);
  if ( !v157 )
    goto LABEL_274;
  memset(v157, 0, 0x180u);
  v45 = v43;
  *(_DWORD *)(*(_DWORD *)(v43 + 68) + 40) = -1609490463;
LABEL_132:
  ++*(_DWORD *)(*(_DWORD *)(v45 + 68) + 12);
  v102 = *(_QWORD *)*(_DWORD *)(v45 + 68);
  v103 = 12 * (v99 & (HIDWORD(v102) - 1));
  ++*(_DWORD *)(v102 + v103 + 4);
  LODWORD(v102) = *(_DWORD *)(**(_DWORD **)(v45 + 68) + v103);
  *(_DWORD *)(v43 + 80) = 0;
  *(_DWORD *)(v43 + 84) = v102;
  LODWORD(v102) = **(_DWORD **)(v45 + 68);
  v104 = *(_DWORD *)(v102 + v103);
  v105 = (int *)(v102 + v103);
  if ( v104 )
  {
    *(_DWORD *)(v104 + 12) = v101;
    v105 = (int *)(**(_DWORD **)(v45 + 68) + v103);
  }
  *v105 = v101;
  v106 = *(_QWORD *)(**(_DWORD **)(v45 + 68) + v103 + 4);
  if ( (unsigned int)v106 >= 10 * (HIDWORD(v106) + 1) )
  {
    v107 = *(_DWORD *)(v43 + 68);
    if ( *(_DWORD *)(v107 + 36) != 1 )
    {
      v124 = calloc(24 * *(_DWORD *)(v107 + 4), 1u);
      if ( v124 )
      {
        v125 = *(_DWORD *)(v43 + 68);
        v126 = 0;
        *(_DWORD *)(v125 + 24) = (((2 * *(_DWORD *)(v125 + 4) - 1) & *(_DWORD *)(v125 + 12)) != 0)
                               + (*(_DWORD *)(v125 + 12) >> (*(_BYTE *)(v125 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(v43 + 68) + 28) = 0;
        v127 = *(_DWORD *)(v43 + 68);
        v128 = *(_DWORD *)(v127 + 4);
        if ( v128 )
        {
          v166 = 0;
          v168 = v7;
          do
          {
            v129 = *(_DWORD **)(*(_DWORD *)v127 + v126);
            if ( v129 )
            {
              while ( 1 )
              {
                v130 = (_DWORD *)v129[4];
                v131 = 3 * ((2 * v128 - 1) & v129[7]);
                v132 = (char *)&v124[v131];
                v133 = *((_DWORD *)v132 + 1) + 1;
                *((_DWORD *)v132 + 1) = v133;
                v134 = *(_DWORD *)(v43 + 68);
                if ( v133 > *(_DWORD *)(v134 + 24) )
                {
                  ++*(_DWORD *)(v134 + 28);
                  *((_DWORD *)v132 + 2) = sub_4A2D0(*((_DWORD *)v132 + 1), *(_DWORD *)(*(_DWORD *)(v43 + 68) + 24));
                }
                v129[3] = 0;
                v129[4] = v124[v131];
                v135 = v124[v131];
                if ( v135 )
                  *(_DWORD *)(v135 + 12) = v129;
                v124[v131] = v129;
                v127 = *(_DWORD *)(v43 + 68);
                if ( !v130 )
                  break;
                v128 = *(_DWORD *)(v127 + 4);
                v129 = v130;
              }
              v128 = *(_DWORD *)(v127 + 4);
            }
            v126 += 12;
            ++v166;
          }
          while ( v166 < v128 );
          v7 = v168;
        }
        free(*(void **)v127);
        *(_DWORD *)(*(_DWORD *)(v43 + 68) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(v43 + 68) + 8);
        **(_DWORD **)(v43 + 68) = v124;
        v136 = *(_DWORD **)(v43 + 68);
        v137 = v136[7];
        v138 = v136[3];
        v139 = v137 > v138 >> 1;
        if ( v137 <= v138 >> 1 )
          v140 = 0;
        else
          v140 = v136[8];
        if ( v139 )
          ++v140;
        v136[8] = v140;
        v141 = *(_DWORD *)(v43 + 68);
        if ( *(_DWORD *)(v141 + 32) > 1u )
          *(_DWORD *)(v141 + 36) = 1;
        goto LABEL_136;
      }
LABEL_274:
      exit(-1);
    }
  }
LABEL_136:
  v108 = 8 * (29 - (unsigned __int8)v7[72]);
  v109 = bswap32(*((_DWORD *)v7 + 18)) & 0xFFFFFF;
  if ( v108 < 8 )
    LOBYTE(v108) = 8;
  v110 = 32 - v108;
  v111 = 0xFFFF << (v108 - 32);
  LODWORD(v112) = 0xFFFF << v108;
  HIDWORD(v112) = v111 | (0xFFFFu >> v110);
  LODWORD(v113) = sub_4AB04(v112);
  v114 = v113 / (double)v109;
  if ( v114 != dbl_681E8 )
  {
    LODWORD(v158) = sub_4ABD0(v114);
    sub_287D8(v158, byte_6A1D4, 8u, 0);
    dbl_681E8 = v114;
    if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
    {
      snprintf((char *)v173, 0x800u, "Network diff set to %s", byte_6A1D4);
      sub_1DD60(5, (const char *)v173, 0);
    }
  }
  if ( v164 && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf((char *)v173, 0x800u, "Deleted block %d from database", v164);
    sub_1DD60(7, (const char *)v173, 0);
  }
  if ( pthread_rwlock_unlock(&stru_6A1B0) )
  {
LABEL_234:
    v153 = _errno_location();
    snprintf(
      (char *)v173,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v153,
      "cgminer.c",
      "block_exists",
      5677);
    goto LABEL_204;
  }
  off_67964();
  if ( pthread_mutex_lock(&stru_76110) )
  {
    v159 = _errno_location();
    snprintf(
      (char *)v173,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v159,
      "cgminer.c",
      "set_curblock",
      5584);
    goto LABEL_204;
  }
  if ( pthread_rwlock_wrlock(&stru_76128) )
  {
    v161 = _errno_location();
    snprintf(
      (char *)v173,
      0x800u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v161,
      "cgminer.c",
      "set_curblock",
      5584);
LABEL_204:
    sub_1DD60(3, (const char *)v173, 1);
    sub_2C230(1, 1);
  }
  sub_206A0(&dword_72DB4);
  strcpy(byte_761E4, s);
  sub_232EC(&unk_6A1DC, s2, 0x20u, (int)"cgminer.c", (int)"set_curblock", 5587);
  v115 = dword_72DB8;
  v173[0] = dword_72DB4;
  v116 = localtime(v173);
  snprintf(byte_6A1FC, 0x20u, "[%02d:%02d:%02d.%03d]", v116->tm_hour, v116->tm_min, v116->tm_sec, v115 / 1000);
  if ( pthread_rwlock_unlock(&stru_76128) )
  {
    v143 = _errno_location();
    snprintf(
      (char *)v173,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v143,
      "cgminer.c",
      "set_curblock",
      5589);
    goto LABEL_204;
  }
  v117 = pthread_mutex_unlock(&stru_76110);
  if ( v117 )
  {
    v160 = *_errno_location();
    snprintf(
      (char *)v173,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      v160,
      "cgminer.c",
      "set_curblock",
      5589);
    goto LABEL_204;
  }
  off_67964();
  v118 = byte_761E4;
  do
  {
    v119 = (unsigned __int8)*v118++;
    if ( v119 != 48 )
      break;
    ++v117;
  }
  while ( v117 != 57 );
  strncpy(dest, &byte_761E4[v117], 8u);
  byte_6A224 = 0;
  if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
  {
    snprintf((char *)v173, 0x800u, "New block: %s... diff %s", byte_761E4, byte_6A1D4);
    sub_1DD60(6, (const char *)v173, 0);
  }
  if ( v164 && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf((char *)v173, 0x800u, "Deleted block %d from database", v164);
    sub_1DD60(7, (const char *)v173, 0);
  }
  sub_232EC(v162 + 136, s2, 0x20u, (int)"cgminer.c", (int)"test_work_current", 5734);
  if ( dword_761D8 != 1 )
  {
    v120 = (unsigned __int8)v7[280];
    *((_DWORD *)v7 + 84) = ++dword_68C9C;
    if ( v120 )
    {
      if ( v7[284] )
      {
        if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
        {
          v121 = "Stratum from pool %d detected new block at height %d";
          v122 = v169;
          v123 = (char *)*v162;
          goto LABEL_171;
        }
      }
      else if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        v123 = "";
        v122 = **((_DWORD **)v7 + 65);
        v121 = "%sLONGPOLL from pool %d detected new block";
        if ( v7[324] )
          v123 = "GBT ";
LABEL_171:
        snprintf((char *)v173, 0x800u, v121, v123, v122);
        sub_1DD60(7, (const char *)v173, 0);
      }
    }
    else if ( byte_762C4 )
    {
      if ( !*((_BYTE *)v162 + 916) && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        strcpy((char *)v173, "New block detected on network before pool notification");
        sub_1DD60(7, (const char *)v173, 0);
      }
    }
    else if ( !*((_BYTE *)v162 + 916) && byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      strcpy((char *)v173, "New block detected on network");
      sub_1DD60(7, (const char *)v173, 0);
    }
    sub_2C568();
    v163 = 1;
  }
LABEL_54:
  v7[280] = 0;
  return v163;
}
// 37EE0: control flows out of bounds to 37EE4
// 38634: control flows out of bounds to 38638
// 3887C: variable 'v113' is possibly undefined
// 39458: variable 'v158' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681E8: using guessed type double dbl_681E8;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68AE4: using guessed type int dword_68AE4;
// 68C9C: using guessed type int dword_68C9C;
// 6A1D0: using guessed type int dword_6A1D0;
// 6A224: using guessed type char byte_6A224;
// 72D90: using guessed type char byte_72D90;
// 72DB4: using guessed type int dword_72DB4;
// 72DB8: using guessed type int dword_72DB8;
// 76110: using guessed type pthread_mutex_t stru_76110;
// 761D8: using guessed type int dword_761D8;
// 762C4: using guessed type char byte_762C4;

//----- (000395C4) --------------------------------------------------------
int __fastcall sub_395C4(_DWORD *a1)
{
  int v2; // r9
  pthread_t v3; // r0
  int v4; // r10
  pthread_mutex_t *v5; // r0
  fd_set *v6; // r3
  int v7; // r3
  int v8; // r2
  bool v9; // nf
  int v10; // r1
  void ***v11; // r2
  int v12; // r0
  char *v13; // r4
  int v15; // r3
  int v16; // r2
  int v17; // r4
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  int v20; // r5
  _DWORD *v21; // r3
  unsigned int *v22; // r3
  unsigned int v23; // r2
  unsigned int v24; // r2
  void **v25; // r0
  void **v26; // r0
  char *v27; // r5
  int *v28; // r0
  const char *v29; // lr
  int v30; // r3
  int v31; // r12
  int *v32; // r0
  int *v33; // r0
  const char *v34; // lr
  int v35; // r3
  int v36; // r12
  int *v37; // r0
  int *v38; // r0
  int *v39; // r0
  int v40; // r5
  void **v41; // r11
  unsigned int v42; // r3
  unsigned int v43; // r2
  unsigned int v44; // r1
  int v45; // r3
  unsigned int v46; // r2
  unsigned int v47; // r1
  int v48; // r3
  unsigned int v49; // r3
  int v50; // r2
  int v51; // r1
  int v52; // r6
  int v53; // r7
  int v54; // r10
  _DWORD *v55; // r9
  char *v56; // r5
  unsigned int v57; // r4
  int v58; // r7
  int v59; // r3
  _DWORD *v60; // r5
  int v61; // r3
  int **v62; // r2
  int *v63; // r1
  int v64; // r3
  int v65; // r1
  int v66; // r1
  int v67; // r3
  int v68; // r6
  int v69; // r5
  time_t v70; // r0
  int v71; // r3
  int v72; // r0
  void ***v73; // r2
  int v74; // t1
  double v75; // d0
  unsigned int v76; // r6
  int v77; // r1
  char *v78; // r12
  _DWORD *v79; // r6
  unsigned int v80; // r3
  unsigned int v81; // r12
  double v82; // d5
  unsigned int v83; // kr00_4
  int v84; // r3
  int v85; // r2
  double v86; // d7
  double v87; // d5
  double v88; // d7
  size_t v89; // r0
  size_t v90; // lr
  double v91; // r0
  _DWORD *v92; // r3
  unsigned int *v93; // r3
  unsigned int v94; // r2
  unsigned int v95; // r2
  double v96; // d8
  unsigned int v97; // r0
  __int64 v98; // kr18_8
  double v99; // d6
  double v100; // d7
  unsigned int v101; // kr08_4
  double v102; // d6
  int v103; // r3
  int v104; // r2
  double v105; // d7
  int v106; // r2
  int v107; // r3
  _DWORD *v108; // r0
  const char *v109; // r0
  int *v110; // r0
  int v111; // r1
  int *v112; // r0
  unsigned int v113; // kr0C_4
  int v114; // r0
  unsigned __int64 v115; // kr20_8
  double v116; // d5
  double v117; // d7
  double v118; // d5
  double v119; // d7
  int v120; // r2
  time_t v121; // r0
  int v122; // r3
  int *v123; // r0
  int v124; // [sp+4h] [bp-A78h]
  _DWORD *v125; // [sp+20h] [bp-A5Ch]
  _DWORD *v126; // [sp+30h] [bp-A4Ch]
  char *v127; // [sp+30h] [bp-A4Ch]
  int v128; // [sp+30h] [bp-A4Ch]
  time_t *timer; // [sp+34h] [bp-A48h]
  time_t *timera; // [sp+34h] [bp-A48h]
  int v131; // [sp+38h] [bp-A44h]
  unsigned int v132; // [sp+38h] [bp-A44h]
  int v133; // [sp+38h] [bp-A44h]
  int v134; // [sp+3Ch] [bp-A40h]
  _DWORD *ptr; // [sp+40h] [bp-A3Ch]
  void *ptra; // [sp+40h] [bp-A3Ch]
  int v137; // [sp+44h] [bp-A38h]
  int s2; // [sp+48h] [bp-A34h] BYREF
  struct timeval timeout; // [sp+4Ch] [bp-A30h] BYREF
  char s[16]; // [sp+54h] [bp-A28h] BYREF
  char v141[20]; // [sp+64h] [bp-A18h] BYREF
  __int16 v142; // [sp+78h] [bp-A04h] BYREF
  __int16 v143; // [sp+7Ah] [bp-A02h] BYREF
  char v144[36]; // [sp+98h] [bp-9E4h] BYREF
  char v145[60]; // [sp+BCh] [bp-9C0h] BYREF
  char v146; // [sp+F8h] [bp-984h] BYREF
  fd_set readfds; // [sp+FCh] [bp-980h] BYREF
  int v148[23]; // [sp+17Ch] [bp-900h] BYREF
  char v149[160]; // [sp+1D8h] [bp-8A4h] BYREF
  void **v150[513]; // [sp+278h] [bp-804h] BYREF

  v2 = -1622558010;
  v3 = pthread_self();
  pthread_detach(v3);
  v4 = -17973517;
  snprintf(s, 0x10u, "%d/RStratum", *a1);
  sub_22E98(s);
  do
  {
LABEL_2:
    v5 = (pthread_mutex_t *)a1;
    if ( *((_BYTE *)a1 + 105) )
    {
LABEL_17:
      sub_21338(v5);
      return 0;
    }
    while ( 1 )
    {
      if ( !sub_20C5C((int)v5) && !sub_2FFA8((int)a1) )
      {
        sub_21338((pthread_mutex_t *)a1);
        sub_3285C((int)a1);
        sub_31774(a1);
        if ( sub_2FFA8((int)a1) )
          goto LABEL_65;
        while ( !a1[25] || a1 != (_DWORD *)sub_2FB78() && (unsigned int)(dword_68AE4 - 3) > 1 )
        {
          if ( pthread_mutex_lock(&mutex) )
          {
            v38 = _errno_location();
            v29 = "wait_lpcurrent";
            v30 = *v38;
            v31 = 10003;
            goto LABEL_86;
          }
          pthread_cond_wait(&cond, &mutex);
          if ( pthread_mutex_unlock(&mutex) )
          {
            v39 = _errno_location();
            v34 = "wait_lpcurrent";
            v35 = *v39;
            v36 = 10005;
LABEL_90:
            snprintf(
              (char *)v150,
              0x800u,
              "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
              v35,
              "cgminer.c",
              v34,
              v36);
LABEL_87:
            sub_1DD60(3, (const char *)v150, 1);
            sub_2C230(1, 1);
          }
          off_67964();
          if ( sub_2FFA8((int)a1) )
            break;
        }
LABEL_65:
        while ( !sub_26020((pthread_mutex_t *)a1) )
        {
          sub_31F20((int)a1);
          if ( *((_BYTE *)a1 + 105) )
            return 0;
          sub_208D4();
        }
      }
      v6 = (fd_set *)&v146;
      do
      {
        v6->__fds_bits[1] = 0;
        v6 = (fd_set *)((char *)v6 + 4);
      }
      while ( &readfds.__fds_bits[31] != (__fd_mask *)v6 );
      v7 = a1[147];
      timeout.tv_usec = 0;
      timeout.tv_sec = 90;
      v8 = v7 + 31;
      if ( v7 >= 0 )
        v8 = v7;
      v9 = -v7 < 0;
      v10 = -v7 & 0x1F;
      LOBYTE(v7) = v7 & 0x1F;
      v11 = &v150[(v8 >> 5) + 512];
      if ( !v9 )
        v7 = -v10;
      *(v11 - 607) = (void **)((unsigned int)*(v11 - 607) | (1 << v7));
      if ( !sub_20C5C((int)a1) )
      {
        v12 = select(a1[147] + 1, &readfds, 0, 0, &timeout);
        if ( v12 <= 0 )
        {
          v15 = (unsigned __int8)byte_72D90;
          if ( !byte_686E1 )
            goto LABEL_29;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
          {
            snprintf((char *)v150, 0x800u, "Stratum select failed on pool %d with value %d", *a1, v12);
            sub_1DD60(7, (const char *)v150, 0);
            v15 = (unsigned __int8)byte_72D90;
            goto LABEL_29;
          }
          goto LABEL_54;
        }
      }
      v13 = sub_21850((int)a1);
      if ( !v13 )
        break;
      sub_2FF84((int)a1);
      if ( sub_2705C((pthread_mutex_t *)a1, (int)v13) )
        goto LABEL_14;
      v18 = sub_47C50((int)v13, 0, (char *)v148);
      v125 = v18;
      if ( v18 )
      {
        v126 = (_DWORD *)sub_48AF4(v18, "result");
        timer = (time_t *)sub_48AF4(v125, "error");
        v19 = (_DWORD *)sub_48AF4(v125, "id");
        v20 = (int)v19;
        if ( !v19 || *v19 == 7 )
        {
          if ( timer )
          {
            v27 = sub_45A6C(timer, 3);
          }
          else
          {
            v27 = (char *)malloc(0x11u);
            if ( v27 )
              strcpy(v27, "(unknown reason)");
          }
          if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
          {
            snprintf((char *)v150, 0x800u, "JSON-RPC non method decode failed: %s", v27);
            sub_1DD60(6, (const char *)v150, 0);
          }
          free(v27);
          if ( v125[1] != -1 )
            goto LABEL_50;
        }
        else
        {
          if ( sub_48AF4(v126, "version-rolling.mask")
            || strstr(v13, "mining.configure")
            || strstr(v13, "mining.set_version_mask") )
          {
            goto LABEL_49;
          }
          v40 = sub_49284(v20);
          s2 = v40;
          if ( pthread_mutex_lock(&stru_68C54) )
            sub_2CB60("parse_stratum_response", 7362);
          v41 = (void **)dword_68C6C;
          v42 = ((v40 & 0xFF0000FF) + 17973517 + (v40 & 0xFF0000) + (v40 & 0xFF00)) ^ 0x7F76D;
          v43 = (v2 - v42) ^ (v42 << 8);
          v44 = (v4 - v42 - v43) ^ (v43 >> 13);
          v45 = (v42 - v43 - v44) ^ (v44 >> 12);
          v46 = (v43 - v44 - v45) ^ (v45 << 16);
          v47 = (v44 - v45 - v46) ^ (v46 >> 5);
          v48 = (v45 - v46 - v47) ^ (v47 >> 3);
          v49 = (v47 - v48 - ((v46 - v47 - v48) ^ (v48 << 10))) ^ (((v46 - v47 - v48) ^ (v48 << 10)) >> 15);
          if ( dword_68C6C )
          {
            ptr = **(_DWORD ***)dword_68C6C;
            v50 = ptr[3 * ((*(_DWORD *)(*(_DWORD *)dword_68C6C + 4) - 1) & v49)];
            if ( v50 )
            {
              v51 = *(_DWORD *)(*(_DWORD *)dword_68C6C + 20);
              v52 = -v51;
              v137 = v51;
              v53 = v50 - v51;
              if ( v50 != v51 )
              {
                v131 = v4;
                v54 = v2;
                v55 = *(_DWORD **)dword_68C6C;
                v56 = v13;
                v57 = v49;
                while ( v57 != *(_DWORD *)(v53 + 28)
                     || *(_DWORD *)(v53 + 24) != 4
                     || memcmp(*(const void **)(v53 + 20), &s2, 4u) )
                {
                  v58 = *(_DWORD *)(v53 + 16);
                  if ( v58 )
                  {
                    v53 = v58 + v52;
                    if ( v53 )
                      continue;
                  }
                  v2 = v54;
                  v4 = v131;
                  v13 = v56;
                  goto LABEL_181;
                }
                v59 = *(_DWORD *)(v53 + 4);
                v13 = v56;
                v60 = v55;
                v2 = v54;
                v4 = v131;
                if ( v59 )
                {
                  if ( v53 != v60[4] + v52 )
                    goto LABEL_108;
LABEL_214:
                  v60[4] = v59 + v137;
                  v59 = *(_DWORD *)(v53 + 4);
                  if ( !v59 )
                  {
                    v106 = *(_DWORD *)(v53 + 8);
                    goto LABEL_211;
                  }
                  v60 = *v41;
LABEL_108:
                  *(_DWORD *)(v59 + v60[5] + 8) = *(_DWORD *)(v53 + 8);
LABEL_109:
                  v61 = *(_DWORD *)(v53 + 8);
                  v62 = (int **)dword_68C6C;
                  v63 = *(int **)dword_68C6C;
                  if ( v61 )
                  {
                    *(_DWORD *)(v61 + v63[5] + 4) = *(_DWORD *)(v53 + 4);
                    v63 = *v62;
                  }
                  v64 = 12 * ((v63[1] - 1) & *(_DWORD *)(v53 + 28));
                  --*(_DWORD *)(*v63 + v64 + 4);
                  v65 = **v62;
                  if ( *(_DWORD *)(v65 + v64) == v53 )
                    *(_DWORD *)(v65 + v64) = *(_DWORD *)(v53 + 16);
                  v66 = *(_DWORD *)(v53 + 12);
                  v67 = *(_DWORD *)(v53 + 16);
                  if ( v66 )
                  {
                    *(_DWORD *)(v66 + 16) = v67;
                    v67 = *(_DWORD *)(v53 + 16);
                  }
                  if ( v67 )
                    *(_DWORD *)(v67 + 12) = *(_DWORD *)(v53 + 12);
                  --(*v62)[3];
                }
                else
                {
                  v106 = *(_DWORD *)(v53 + 8);
                  if ( v106 )
                  {
                    if ( v53 == v60[4] + v52 )
                      goto LABEL_214;
LABEL_211:
                    dword_68C6C = v106;
                    goto LABEL_109;
                  }
                  free(ptr);
                  free(*v41);
                  dword_68C6C = 0;
                }
                --a1[187];
                v68 = pthread_mutex_unlock(&stru_68C54);
                if ( v68 )
                  goto LABEL_212;
                off_67964();
                v69 = *(_DWORD *)(v53 + 36);
                v70 = time(0);
                v71 = (unsigned __int8)byte_686E1;
                v72 = v70 - *(_DWORD *)(v53 + 48);
                if ( v72 > 0 )
                  v71 = (unsigned __int8)byte_686E1 | 1;
                if ( v71 && (byte_72D90 || byte_686E0 || dword_67840 > 5) )
                {
                  snprintf(
                    (char *)v150,
                    0x800u,
                    "Pool %d stratum share result lag time %d seconds",
                    **(_DWORD **)(v69 + 260),
                    v72);
                  sub_1DD60(6, (const char *)v150, 0);
                }
                v73 = v150;
                v150[0] = (void **)bswap32(*(_DWORD *)(v69 + 220));
                v150[1] = (void **)bswap32(*(_DWORD *)(v69 + 216));
                v150[2] = (void **)bswap32(*(_DWORD *)(v69 + 212));
                v150[3] = (void **)bswap32(*(_DWORD *)(v69 + 208));
                v150[4] = (void **)bswap32(*(_DWORD *)(v69 + 204));
                v150[5] = (void **)bswap32(*(_DWORD *)(v69 + 200));
                v150[6] = (void **)bswap32(*(_DWORD *)(v69 + 196));
                v150[7] = (void **)bswap32(*(_DWORD *)(v69 + 192));
                do
                {
                  v74 = *(unsigned __int8 *)v73;
                  v73 = (void ***)((char *)v73 + 1);
                  if ( v74 )
                    break;
                  ++v68;
                }
                while ( v68 != 29 );
                v75 = *(double *)(v69 + 376);
                v76 = bswap32(*(unsigned int *)((char *)v150 + v68));
                round();
                v132 = sub_4ABD0(v75);
                v134 = v77;
                sub_287D8(*(_QWORD *)(v69 + 232), v144, 0x10u, 0);
                if ( *(_BYTE *)(v69 + 283) )
                  v78 = " BLOCK!";
                else
                  v78 = "";
                snprintf(v145, 0x40u, "%08lx Diff %s/%llu%s", v76, v144, v124, v132, v134, v78);
                v79 = *(_DWORD **)(v69 + 260);
                v133 = *(_DWORD *)(sub_2F688(*(_DWORD *)(v69 + 256)) + 36);
                if ( v126 && (*v126 == 5 || *(_BYTE *)(v69 + 324) && *v126 == 7) )
                {
                  if ( pthread_mutex_lock(&stru_72D94) )
                  {
                    v123 = _errno_location();
                    snprintf(
                      (char *)v150,
                      0x800u,
                      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                      *v123,
                      "cgminer.c",
                      "share_result",
                      3592);
                    goto LABEL_87;
                  }
                  v113 = qword_72EF0;
                  v114 = *(_DWORD *)(v133 + 36) + 1;
                  LODWORD(qword_72EF0) = qword_72EF0 + 1;
                  v115 = __PAIR64__(HIDWORD(qword_72EF0), v113) + 1;
                  *(_DWORD *)(v133 + 36) = v114;
                  HIDWORD(qword_72EF0) = HIDWORD(v115);
                  v116 = dbl_74F28;
                  ++*((_QWORD *)v79 + 1);
                  *(double *)(v133 + 200) = *(double *)(v133 + 200) + *(double *)(v69 + 376);
                  v117 = *(double *)(v69 + 376);
                  v118 = v116 + v117;
                  v119 = *((double *)v79 + 9) + v117;
                  dbl_74F28 = v118;
                  *((double *)v79 + 9) = v119;
                  if ( pthread_mutex_unlock(&stru_72D94) )
                  {
                    v110 = _errno_location();
                    v111 = 3602;
                    goto LABEL_226;
                  }
                  off_67964();
                  v120 = *v79;
                  v79[6] = 0;
                  *(_DWORD *)(v133 + 216) = v120;
                  v121 = time(0);
                  v122 = (unsigned __int8)byte_686E1;
                  *(_DWORD *)(v133 + 220) = v121;
                  *(_QWORD *)(v133 + 224) = *(_QWORD *)(v69 + 376);
                  v79[88] = v121;
                  *((_QWORD *)v79 + 45) = *(_QWORD *)(v69 + 376);
                  if ( v122 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
                  {
                    strcpy((char *)v150, "PROOF OF WORK RESULT: true (yay!!!)");
                    sub_1DD60(7, (const char *)v150, 0);
                  }
                  if ( !byte_76234 && !byte_761D0 )
                  {
                    if ( dword_72E60 <= 1 )
                    {
                      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
                      {
                        snprintf(
                          (char *)v150,
                          0x800u,
                          "Accepted %s %s %d %s%s",
                          v145,
                          *(const char **)(*(_DWORD *)(v133 + 4) + 8),
                          *(_DWORD *)(v133 + 8),
                          "",
                          "");
                        sub_1DD60(7, (const char *)v150, 0);
                      }
                    }
                    else if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
                    {
                      snprintf(
                        (char *)v150,
                        0x800u,
                        "Accepted %s %s %d pool %d %s%s",
                        v145,
                        *(const char **)(*(_DWORD *)(v133 + 4) + 8),
                        *(_DWORD *)(v133 + 8),
                        **(_DWORD **)(v69 + 260),
                        "",
                        "");
                      sub_1DD60(7, (const char *)v150, 0);
                    }
                  }
                  sub_33320("accept", (_DWORD *)v69);
                  if ( dword_68B60 && (double)dword_68B60 <= dbl_74F28 )
                  {
                    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
                    {
                      snprintf(
                        (char *)v150,
                        0x800u,
                        "Successfully mined %d accepted shares as requested and exiting.",
                        dword_68B60);
                      sub_1DD60(4, (const char *)v150, 0);
                    }
                    sub_2C2B0();
                  }
                  if ( v79[25] == 2 )
                  {
                    if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
                    {
                      snprintf((char *)v150, 0x800u, "Rejecting pool %d now accepting shares, re-enabling!", *v79);
                      sub_1DD60(4, (const char *)v150, 0);
                    }
                    if ( v79[25] != 1 )
                      sub_28F90(v79 + 25);
                    sub_31A9C(0);
                  }
                  if ( *(_BYTE *)(v69 + 283) )
                    sub_2C568();
                }
                else
                {
                  if ( pthread_mutex_lock(&stru_72D94) )
                  {
                    v112 = _errno_location();
                    snprintf(
                      (char *)v150,
                      0x800u,
                      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                      *v112,
                      "cgminer.c",
                      "share_result",
                      3655);
                    goto LABEL_87;
                  }
                  v81 = HIDWORD(qword_74FB8);
                  v80 = qword_74FB8;
                  v82 = dbl_74FB0;
                  ++*(_DWORD *)(v133 + 40);
                  v83 = v80;
                  v84 = v79[4];
                  qword_74FB8 = __PAIR64__(v81, v83) + 1;
                  v85 = v79[5];
                  v79[4] = v84 + 1;
                  v79[5] = __CFADD__(v84, 1) + v85;
                  *(double *)(v133 + 208) = *(double *)(v133 + 208) + *(double *)(v69 + 376);
                  v86 = *(double *)(v69 + 376);
                  v87 = v82 + v86;
                  v88 = *((double *)v79 + 10) + v86;
                  ++v79[6];
                  dbl_74FB0 = v87;
                  *((double *)v79 + 10) = v88;
                  if ( pthread_mutex_unlock(&stru_72D94) )
                  {
                    v110 = _errno_location();
                    v111 = 3663;
LABEL_226:
                    snprintf(
                      (char *)v150,
                      0x800u,
                      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                      *v110,
                      "cgminer.c",
                      "share_result",
                      v111);
                    goto LABEL_87;
                  }
                  off_67964();
                  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
                  {
                    strcpy((char *)v150, "PROOF OF WORK RESULT: false (booooo)");
                    sub_1DD60(7, (const char *)v150, 0);
                  }
                  if ( !byte_76234 && !byte_761D0 )
                  {
                    strcpy(v144, "reject");
                    memset(&v144[7], (unsigned __int8)byte_761D0, 0x1Du);
                    LOBYTE(v142) = byte_761D0;
                    if ( dword_72E60 > 1 )
                      snprintf(v141, 0x14u, "pool %d", **(_DWORD **)(v69 + 260));
                    else
                      v141[0] = byte_761D0;
                    if ( !*(_BYTE *)(v69 + 324) )
                      v126 = (_DWORD *)sub_48AF4(v125, "reject-reason");
                    if ( v126 )
                    {
                      timera = sub_49028(v126);
                      v89 = strlen((const char *)timera);
                      if ( v89 >= 0x1C )
                        v90 = 28;
                      else
                        v90 = v89;
                      v142 = 10272;
                      ptra = (void *)v90;
                      v127 = (char *)&v150[512] + v90;
                      sub_232EC(&v143, timera, v90, (int)"cgminer.c", (int)"share_result", 3703);
                      *(v127 - 2558) = 41;
                      *(v127 - 2557) = 0;
                      sub_232EC(&v144[7], timera, (size_t)ptra, (int)"cgminer.c", (int)"share_result", 3708);
                      v144[6] = 58;
                      *(v127 - 2521) = 0;
                    }
                    else
                    {
                      if ( timer )
                        v107 = *(_BYTE *)(v69 + 284) & 1;
                      else
                        v107 = 0;
                      if ( v107 )
                      {
                        if ( *timer == 1 )
                        {
                          v108 = sub_48E7C(timer, 1u);
                          if ( !v108 || *v108 != 2 )
                            goto LABEL_155;
                        }
                        else
                        {
                          if ( *timer != 2 )
                            goto LABEL_155;
                          v108 = timer;
                        }
                        v109 = (const char *)sub_49028(v108);
                        snprintf((char *)&v142, 0x1Fu, " (%s)", v109);
                      }
                    }
LABEL_155:
                    if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
                    {
                      snprintf(
                        (char *)v150,
                        0x800u,
                        "Rejected %s %s %d %s%s %s%s version 0x%x",
                        v145,
                        *(const char **)(*(_DWORD *)(v133 + 4) + 8),
                        *(_DWORD *)(v133 + 8),
                        v141,
                        (const char *)&v142,
                        "",
                        "",
                        *(_DWORD *)(v69 + 444));
                      sub_1DD60(5, (const char *)v150, 0);
                    }
                    sub_33320(v144, (_DWORD *)v69);
                  }
                  v128 = v79[6];
                  if ( v128 > 10 && !*(_BYTE *)(v69 + 281) )
                  {
                    if ( byte_72E98 )
                    {
                      if ( dword_74F24 > 1 )
                      {
                        LODWORD(v91) = sub_4AB14(qword_72EF0);
                        if ( (double)v128 > v91 / dbl_681C0 * 60.0 * 3.0 )
                        {
                          if ( byte_72D90 || byte_686E0 || dword_67840 > 3 )
                          {
                            snprintf(
                              (char *)v150,
                              0x800u,
                              "Pool %d rejected %d sequential shares, disabling!",
                              *v79,
                              v128);
                            sub_1DD60(4, (const char *)v150, 0);
                          }
                          if ( v79[25] == 1 )
                            --dword_74F24;
                          v79[25] = 2;
                          if ( v79 == (_DWORD *)sub_2FB78() )
                            sub_31A9C(0);
                          v79[6] = 0;
                        }
                      }
                    }
                  }
                }
                sub_2A70C((void ***)(v53 + 36), "cgminer.c", "parse_stratum_response", 7415);
                free((void *)v53);
                if ( v125[1] != -1 )
                {
                  v92 = v125;
                  __dmb(0xBu);
                  v93 = v92 + 1;
                  do
                  {
                    v94 = __ldrex(v93);
                    v95 = v94 - 1;
                  }
                  while ( __strex(v95, v93) );
                  if ( !v95 )
                    sub_4942C(v125);
                }
                goto LABEL_14;
              }
            }
          }
LABEL_181:
          if ( pthread_mutex_unlock(&stru_68C54) )
LABEL_212:
            sub_2CBBC("parse_stratum_response", 7370);
          off_67964();
          if ( !v126 )
          {
LABEL_49:
            if ( v125[1] == -1 )
              goto LABEL_59;
LABEL_50:
            v21 = v125;
            __dmb(0xBu);
            v22 = v21 + 1;
            do
            {
              v23 = __ldrex(v22);
              v24 = v23 - 1;
            }
            while ( __strex(v24, v22) );
            if ( !v24 )
              sub_4942C(v125);
            goto LABEL_59;
          }
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
            sub_2CB60("parse_stratum_response", 7382);
          if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
            sub_2DCC0("parse_stratum_response", 7382);
          if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
            sub_2CBBC("parse_stratum_response", 7382);
          v96 = *((double *)a1 + 230);
          sub_2D708((pthread_rwlock_t *)(a1 + 59), "parse_stratum_response", 7384);
          if ( *v126 == 5 )
          {
            if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
            {
              snprintf((char *)v150, 0x800u, "Accepted untracked stratum share from pool %d", *a1);
              sub_1DD60(5, (const char *)v150, 0);
            }
            if ( pthread_mutex_lock(&stru_72D94) )
              sub_2CB60("parse_stratum_response", 7392);
            v102 = *((double *)a1 + 9) + v96;
            ++qword_72EF0;
            v103 = a1[2];
            v104 = a1[3];
            v105 = dbl_74F28 + v96;
            *((double *)a1 + 9) = v102;
            a1[2] = v103 + 1;
            a1[3] = __CFADD__(v103, 1) + v104;
            dbl_74F28 = v105;
            if ( pthread_mutex_unlock(&stru_72D94) )
              sub_2CBBC("parse_stratum_response", 7397);
          }
          else
          {
            if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
            {
              snprintf((char *)v150, 0x800u, "Rejected untracked stratum share from pool %d", *a1);
              sub_1DD60(5, (const char *)v150, 0);
            }
            if ( pthread_mutex_lock(&stru_72D94) )
              sub_2CB60("parse_stratum_response", 7403);
            v97 = a1[5];
            v98 = qword_74FB8 + 1;
            v99 = *((double *)a1 + 10) + v96;
            v100 = dbl_74FB0 + v96;
            v101 = a1[4];
            LODWORD(qword_74FB8) = qword_74FB8 + 1;
            a1[4] = v101 + 1;
            *((double *)a1 + 10) = v99;
            a1[5] = (__PAIR64__(v97, v101) + 1) >> 32;
            HIDWORD(qword_74FB8) = HIDWORD(v98);
            dbl_74FB0 = v100;
            if ( pthread_mutex_unlock(&stru_72D94) )
              sub_2CBBC("parse_stratum_response", 7408);
          }
          off_67964();
          if ( v125[1] != -1 )
            goto LABEL_50;
        }
      }
      else if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
      {
        snprintf((char *)v150, 0x800u, "JSON decode failed(%d): %s", v148[0], v149);
        sub_1DD60(6, (const char *)v150, 0);
      }
LABEL_59:
      if ( !sub_20FF0(a1, (int)v13) )
      {
        if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
        {
          snprintf((char *)v150, 0x800u, "Unknown stratum msg: %s", v13);
          sub_1DD60(6, (const char *)v150, 0);
        }
        goto LABEL_16;
      }
LABEL_14:
      if ( *((_BYTE *)a1 + 696) )
      {
        v25 = (void **)sub_2D914();
        *((_BYTE *)a1 + 696) = 0;
        v150[0] = v25;
        sub_335C8((int)a1, (int)v25);
        v26 = v150[0];
        *((_BYTE *)v150[0] + 280) = 1;
        sub_37C80((int)v26);
        sub_2A70C(v150, "cgminer.c", "stratum_rthread", 7671);
      }
LABEL_16:
      free(v13);
      v5 = (pthread_mutex_t *)a1;
      if ( *((_BYTE *)a1 + 105) )
        goto LABEL_17;
    }
    v15 = (unsigned __int8)byte_72D90;
LABEL_29:
    if ( v15 || byte_686E0 )
    {
LABEL_31:
      snprintf((char *)v150, 0x800u, "Stratum connection to pool %d interrupted", *a1);
      sub_1DD60(5, (const char *)v150, 0);
      goto LABEL_32;
    }
LABEL_54:
    if ( dword_67840 > 4 )
      goto LABEL_31;
LABEL_32:
    v16 = dword_72F08;
    ++a1[32];
    dword_72F08 = v16 + 1;
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
    {
      v28 = _errno_location();
      v29 = "supports_resume";
      v30 = *v28;
      v31 = 7553;
LABEL_86:
      snprintf((char *)v150, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v30, "cgminer.c", v29, v31);
      goto LABEL_87;
    }
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v32 = _errno_location();
      snprintf(
        (char *)v150,
        0x800u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v32,
        "cgminer.c",
        "supports_resume",
        7553);
      goto LABEL_87;
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
    {
      v33 = _errno_location();
      v34 = "supports_resume";
      v35 = *v33;
      v36 = 7553;
      goto LABEL_90;
    }
    v17 = a1[163];
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v37 = _errno_location();
      snprintf(
        (char *)v150,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v37,
        "cgminer.c",
        "supports_resume",
        7555);
      goto LABEL_87;
    }
    off_67964();
    if ( !v17 || byte_74F84 )
      sub_3285C((int)a1);
    sub_31774(a1);
    if ( a1 == (_DWORD *)sub_2FB78() )
      sub_2C568();
  }
  while ( sub_26020((pthread_mutex_t *)a1) );
  while ( 1 )
  {
    sub_31F20((int)a1);
    if ( *((_BYTE *)a1 + 105) )
      return 0;
    sub_208D4();
    if ( sub_26020((pthread_mutex_t *)a1) )
      goto LABEL_2;
  }
}
// 3A218: variable 'v77' is possibly undefined
// 3A278: variable 'v124' is possibly undefined
// 3A680: variable 'v91' is possibly undefined
// 12770: using guessed type int round(void);
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681C0: using guessed type double dbl_681C0;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68AE4: using guessed type int dword_68AE4;
// 68B60: using guessed type int dword_68B60;
// 68C6C: using guessed type int dword_68C6C;
// 72D90: using guessed type char byte_72D90;
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 72E60: using guessed type int dword_72E60;
// 72E98: using guessed type char byte_72E98;
// 72EF0: using guessed type __int64 qword_72EF0;
// 72F08: using guessed type int dword_72F08;
// 74F24: using guessed type int dword_74F24;
// 74F28: using guessed type double dbl_74F28;
// 74F84: using guessed type char byte_74F84;
// 74FB0: using guessed type double dbl_74FB0;
// 74FB8: using guessed type __int64 qword_74FB8;
// 761D0: using guessed type char byte_761D0;
// 76234: using guessed type char byte_76234;

//----- (0003B058) --------------------------------------------------------
int __fastcall sub_3B058(int a1)
{
  pthread_mutex_t *v2; // r0
  int v3; // r0
  int v4; // r2
  int v5; // r4
  int v6; // r0
  unsigned int v7; // r3
  unsigned int v8; // r1
  int v9; // r0
  unsigned int v10; // r3
  unsigned int v11; // r1
  int v12; // r0
  unsigned int v13; // r5
  int v14; // r3
  int v15; // r7
  char *v16; // r8
  __int64 v17; // r2
  int v18; // r3
  int v19; // r1
  int *v20; // r2
  int v21; // r4
  __int64 v22; // r2
  int v23; // r5
  _DWORD *v24; // r7
  int v25; // r10
  int v26; // r0
  unsigned int v27; // r3
  char *v28; // r5
  unsigned int v29; // r4
  int v30; // r4
  char *v31; // r9
  unsigned int v32; // r3
  int v33; // r3
  _DWORD *v34; // r3
  unsigned int v35; // r2
  unsigned int v36; // r1
  bool v37; // cc
  int v38; // r2
  int v39; // r3
  int v40; // r6
  int v41; // r5
  char *v42; // r3
  _DWORD *v43; // r1
  unsigned int v44; // r7
  char *v45; // r12
  int v46; // lr
  int v47; // r2
  int v48; // lr
  char *v49; // r10
  bool v50; // zf
  int v51; // r12
  bool v52; // zf
  bool v53; // zf
  char *v54; // r11
  int v55; // r12
  char *v57; // r0
  void *v58; // r0
  int *v59; // r0
  int *v60; // r0
  unsigned int i; // [sp+14h] [bp-810h]
  char s[2052]; // [sp+20h] [bp-804h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "Pushing work from pool %d to hash queue", **(_DWORD **)(a1 + 260));
    sub_1DD60(7, s, 0);
  }
  *(_DWORD *)(a1 + 336) = dword_68C9C;
  sub_37C80(a1);
  v2 = (pthread_mutex_t *)dword_68B20;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 260) + 68);
  if ( pthread_mutex_lock(v2) )
  {
    v60 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v60, "cgminer.c", "hash_push", 5840);
LABEL_107:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  if ( !*(_BYTE *)(a1 + 273) && *(_DWORD *)(a1 + 276) )
    ++dword_68C78;
  v3 = dword_74F60;
  v4 = *(unsigned __int8 *)(dword_74F60 + 8);
  if ( *(_BYTE *)(dword_74F60 + 8) )
    goto LABEL_95;
  v5 = dword_68C04;
  v6 = (*(unsigned __int8 *)(a1 + 340)
      + 17973517
      + (*(unsigned __int8 *)(a1 + 343) << 24)
      + (*(unsigned __int8 *)(a1 + 342) << 16)
      + (*(unsigned __int8 *)(a1 + 341) << 8))
     ^ 0x7F76D;
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  *(_DWORD *)(a1 + 364) = a1 + 340;
  v8 = (-17973517 - v6 - v7) ^ (v7 >> 13);
  *(_DWORD *)(a1 + 368) = 4;
  v9 = (v6 - v7 - v8) ^ (v8 >> 12);
  v10 = (v7 - v8 - v9) ^ (v9 << 16);
  v11 = (v8 - v9 - v10) ^ (v10 >> 5);
  v12 = (v9 - v10 - v11) ^ (v11 >> 3);
  v13 = (v11 - v12 - ((v10 - v11 - v12) ^ (v12 << 10))) ^ (((v10 - v11 - v12) ^ (v12 << 10)) >> 15);
  *(_DWORD *)(a1 + 372) = v13;
  if ( v5 )
  {
    v14 = *(_DWORD *)(v5 + 344);
    v15 = a1 + 344;
    *(_DWORD *)(a1 + 352) = v4;
    *(_DWORD *)(a1 + 344) = v14;
    *(_DWORD *)(a1 + 348) = *(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) + 8) = a1;
    *(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) = a1 + 344;
    v16 = *(char **)(v5 + 344);
  }
  else
  {
    *(_DWORD *)(a1 + 352) = 0;
    *(_DWORD *)(a1 + 348) = 0;
    dword_68C04 = a1;
    v57 = (char *)malloc(0x2Cu);
    v16 = v57;
    *(_DWORD *)(a1 + 344) = v57;
    if ( !v57 )
      goto LABEL_109;
    memset(v57 + 12, 0, 0x20u);
    v15 = a1 + 344;
    *((_DWORD *)v16 + 1) = 32;
    *((_DWORD *)v16 + 4) = a1 + 344;
    *((_DWORD *)v16 + 2) = 5;
    *((_DWORD *)v16 + 5) = 344;
    v58 = calloc(0x180u, 1u);
    *(_DWORD *)v16 = v58;
    if ( !v58 )
      goto LABEL_109;
    v5 = a1;
    *((_DWORD *)v16 + 10) = -1609490463;
  }
  ++*((_DWORD *)v16 + 3);
  v17 = *(_QWORD *)*(_DWORD *)(v5 + 344);
  v18 = 12 * ((HIDWORD(v17) - 1) & v13);
  ++*(_DWORD *)(v17 + v18 + 4);
  LODWORD(v17) = *(_DWORD *)(**(_DWORD **)(v5 + 344) + v18);
  *(_DWORD *)(a1 + 356) = 0;
  *(_DWORD *)(a1 + 360) = v17;
  LODWORD(v17) = **(_DWORD **)(v5 + 344);
  v19 = *(_DWORD *)(v17 + v18);
  v20 = (int *)(v17 + v18);
  if ( v19 )
  {
    *(_DWORD *)(v19 + 12) = v15;
    v20 = (int *)(**(_DWORD **)(v5 + 344) + v18);
  }
  *v20 = v15;
  v21 = dword_68C04;
  v22 = *(_QWORD *)(**(_DWORD **)(dword_68C04 + 344) + v18 + 4);
  if ( (unsigned int)v22 >= 10 * (HIDWORD(v22) + 1) )
  {
    v23 = *(_DWORD *)(a1 + 344);
    if ( *(_DWORD *)(v23 + 36) != 1 )
    {
      v24 = calloc(24 * *(_DWORD *)(v23 + 4), 1u);
      if ( v24 )
      {
        v25 = 0;
        *(_DWORD *)(v23 + 24) = (((2 * *(_DWORD *)(v23 + 4) - 1) & *(_DWORD *)(v23 + 12)) != 0)
                              + (*(_DWORD *)(v23 + 12) >> (*(_BYTE *)(v23 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 28) = 0;
        v26 = *(_DWORD *)(a1 + 344);
        v27 = *(_DWORD *)(v26 + 4);
        if ( v27 )
        {
          for ( i = 0; i < v27; ++i )
          {
            v28 = *(char **)(*(_DWORD *)v26 + v25);
            if ( v28 )
            {
              v29 = v27;
              while ( 1 )
              {
                v16 = (char *)*((_DWORD *)v28 + 4);
                v30 = 3 * ((2 * v29 - 1) & *((_DWORD *)v28 + 7));
                v31 = (char *)&v24[v30];
                v32 = *((_DWORD *)v31 + 1) + 1;
                *((_DWORD *)v31 + 1) = v32;
                if ( v32 > *(_DWORD *)(v26 + 24) )
                {
                  ++*(_DWORD *)(v26 + 28);
                  *((_DWORD *)v31 + 2) = sub_4A2D0(*((_DWORD *)v31 + 1), *(_DWORD *)(*(_DWORD *)(a1 + 344) + 24));
                }
                *((_DWORD *)v28 + 3) = 0;
                *((_DWORD *)v28 + 4) = v24[v30];
                v33 = v24[v30];
                if ( v33 )
                  *(_DWORD *)(v33 + 12) = v28;
                v24[v30] = v28;
                v26 = *(_DWORD *)(a1 + 344);
                if ( !v16 )
                  break;
                v29 = *(_DWORD *)(v26 + 4);
                v28 = v16;
              }
              v27 = *(_DWORD *)(v26 + 4);
            }
            v25 += 12;
          }
        }
        free(*(void **)v26);
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 344) + 8);
        **(_DWORD **)(a1 + 344) = v24;
        v34 = *(_DWORD **)(a1 + 344);
        v21 = dword_68C04;
        v35 = v34[7];
        v36 = v34[3];
        v37 = v35 > v36 >> 1;
        if ( v35 <= v36 >> 1 )
          v38 = 0;
        else
          v38 = v34[8];
        if ( v37 )
          ++v38;
        v34[8] = v38;
        v39 = *(_DWORD *)(a1 + 344);
        if ( *(_DWORD *)(v39 + 32) > 1u )
          *(_DWORD *)(v39 + 36) = 1;
        v3 = dword_74F60;
        if ( !v21 )
          goto LABEL_95;
        goto LABEL_38;
      }
LABEL_109:
      exit(-1);
    }
  }
  v3 = dword_74F60;
LABEL_38:
  v40 = v21 + 344;
  v41 = 1;
  do
  {
    v42 = (char *)v40;
    v40 = 0;
    v43 = 0;
    v44 = 0;
    do
    {
      ++v44;
      if ( v41 )
      {
        v45 = (char *)*((_DWORD *)v42 + 2);
        if ( v45 && (v46 = *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20), (v45 += v46) != 0) )
        {
          v47 = 1;
          do
          {
            if ( v47 == v41 )
            {
              v48 = v47;
              goto LABEL_48;
            }
            v45 = (char *)*((_DWORD *)v45 + 2);
            ++v47;
            if ( !v45 )
              break;
            v45 += v46;
          }
          while ( v45 );
          v48 = v41;
        }
        else
        {
          v48 = v41;
          v47 = 1;
        }
      }
      else
      {
        v45 = v42;
        v48 = 0;
        v47 = 0;
      }
LABEL_48:
      v49 = v42;
      v42 = v45;
      while ( v47 )
      {
        v53 = v42 == 0;
        if ( v42 )
          v53 = v48 == 0;
        if ( v53 )
        {
          if ( v49 )
          {
            v16 = (char *)*((_DWORD *)v49 + 2);
            if ( v16 )
              v16 += *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
            goto LABEL_71;
          }
        }
        else
        {
          v16 = *(char **)(*(_DWORD *)(v21 + 344) + 20);
          if ( *(_DWORD *)(v49 - v16 + 264) - *(_DWORD *)(v42 - v16 + 264) > 0 )
          {
            v51 = *((_DWORD *)v42 + 2);
            if ( v51 )
              v51 += (int)v16;
LABEL_58:
            --v48;
            if ( !v43 )
            {
              v43 = v42;
              v42 = (char *)v51;
              goto LABEL_76;
            }
            v16 = &v42[-*(_DWORD *)(*(_DWORD *)(v21 + 344) + 20)];
            v43[2] = v16;
            if ( !v42 )
            {
              v43 = 0;
              v42 = (char *)v51;
              continue;
            }
            goto LABEL_62;
          }
          if ( v49 )
          {
            v55 = *((_DWORD *)v49 + 2);
            if ( v55 )
              v16 += v55;
            else
              v16 = 0;
            goto LABEL_71;
          }
        }
        v16 = v49;
LABEL_71:
        --v47;
        if ( !v43 )
        {
          v43 = v49;
          v49 = v16;
LABEL_76:
          v40 = (int)v43;
          if ( v43 )
          {
            v16 = 0;
            goto LABEL_63;
          }
          continue;
        }
        if ( !v49 )
        {
          v43[2] = 0;
          v43 = 0;
          v49 = v16;
          continue;
        }
        v51 = (int)v42;
        v42 = v49;
        v54 = &v49[-*(_DWORD *)(*(_DWORD *)(v21 + 344) + 20)];
        v49 = v16;
        v43[2] = v54;
LABEL_62:
        v16 = (char *)v43 - *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
        v43 = v42;
        v42 = (char *)v51;
LABEL_63:
        v43[1] = v16;
      }
      v50 = v48 == 0;
      if ( v48 )
        v50 = v42 == 0;
      if ( !v50 )
      {
        v51 = *((_DWORD *)v42 + 2);
        v52 = v51 == 0;
        if ( v51 )
          v16 = *(char **)(v21 + 344);
        else
          v51 = v47;
        if ( !v52 )
        {
          v16 = (char *)*((_DWORD *)v16 + 5);
          v51 += (int)v16;
        }
        goto LABEL_58;
      }
    }
    while ( v42 );
    if ( v43 )
      v43[2] = 0;
    if ( v44 <= 1 )
      goto LABEL_94;
    v41 *= 2;
  }
  while ( v40 );
  v43 = 0;
LABEL_94:
  *(_DWORD *)(*(_DWORD *)(v21 + 344) + 16) = v43;
  dword_68C04 = v40 - *(_DWORD *)(*(_DWORD *)(v21 + 344) + 20);
LABEL_95:
  pthread_cond_broadcast((pthread_cond_t *)(v3 + 40));
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_68B20) )
  {
    v59 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v59, "cgminer.c", "hash_push", 5858);
    goto LABEL_107;
  }
  return off_67964();
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68B20: using guessed type int dword_68B20;
// 68C04: using guessed type int dword_68C04;
// 68C78: using guessed type int dword_68C78;
// 68C9C: using guessed type int dword_68C9C;
// 72D90: using guessed type char byte_72D90;
// 74F60: using guessed type int dword_74F60;

//----- (0003B824) --------------------------------------------------------
void __fastcall sub_3B824(__time_t *a1)
{
  _DWORD *v1; // r4
  int v2; // r5
  double *v3; // r12
  __int64 v4; // kr08_8
  double v5; // d6
  double v6; // d5
  double v7; // d7
  _BYTE *v8; // r3
  int v9; // r0
  int *v10; // r0
  double *v11; // r0
  double v12; // d6
  double v13; // d7
  double v14; // d5
  int *v15; // r0
  int *v16; // r0
  int *v17; // r0
  void *arg[2]; // [sp+14h] [bp-80Ch] BYREF
  pthread_t v19; // [sp+1Ch] [bp-804h] BYREF
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  arg[0] = a1;
  v1 = (_DWORD *)a1[65];
  sub_206A0(a1 + 108);
  if ( byte_68C50 )
  {
    v2 = *(_DWORD *)(sub_2F688(*((_DWORD *)arg[0] + 64)) + 36);
    if ( pthread_mutex_lock(&stru_72D94) )
    {
      v10 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v10,
        "cgminer.c",
        "submit_work_async",
        8768);
    }
    else
    {
      v3 = (double *)arg[0];
      v4 = qword_72EF0;
      ++*(_DWORD *)(v2 + 36);
      qword_72EF0 = v4 + 1;
      v5 = dbl_74F28;
      ++*((_QWORD *)v1 + 1);
      *(double *)(v2 + 200) = *(double *)(v2 + 200) + v3[47];
      v6 = v3[47];
      v7 = *((double *)v1 + 9) + v6;
      dbl_74F28 = v5 + v6;
      *((double *)v1 + 9) = v7;
      if ( !pthread_mutex_unlock(&stru_72D94) )
      {
        off_67964();
        if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
        {
          snprintf(
            s,
            0x800u,
            "Accepted %s %d benchmark share nonce %08x",
            *(const char **)(*(_DWORD *)(v2 + 4) + 8),
            *(_DWORD *)(v2 + 8),
            *((_DWORD *)arg[0] + 19));
          sub_1DD60(5, s, 0);
        }
        return;
      }
      v15 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v15,
        "cgminer.c",
        "submit_work_async",
        8775);
    }
LABEL_51:
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
  if ( sub_33D04((int)arg[0], 1) )
  {
    if ( byte_681FD )
    {
      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        snprintf(s, 0x800u, "Pool %d stale share detected, submitting as user requested", *v1);
        sub_1DD60(7, s, 0);
      }
    }
    else
    {
      if ( !*((_BYTE *)v1 + 104) )
      {
        if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
        {
          snprintf(s, 0x800u, "Pool %d stale share detected, discarding", *v1);
          sub_1DD60(5, s, 0);
        }
        sub_33320("discard", (_DWORD *)arg[0]);
        if ( pthread_mutex_lock(&stru_72D94) )
        {
          v16 = _errno_location();
          snprintf(
            s,
            0x800u,
            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
            *v16,
            "cgminer.c",
            "submit_work_async",
            8796);
        }
        else
        {
          v11 = (double *)arg[0];
          v12 = *((double *)v1 + 11);
          v13 = dbl_72EF8;
          ++v1[30];
          v14 = v11[47];
          ++qword_762C8;
          *((double *)v1 + 11) = v12 + v14;
          dbl_72EF8 = v13 + v14;
          if ( !pthread_mutex_unlock(&stru_72D94) )
          {
            off_67964();
            sub_2A70C((void ***)arg, "cgminer.c", "submit_work_async", 8805);
            return;
          }
          v17 = _errno_location();
          snprintf(
            s,
            0x800u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v17,
            "cgminer.c",
            "submit_work_async",
            8803);
        }
        goto LABEL_51;
      }
      if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
      {
        snprintf(s, 0x800u, "Pool %d stale share detected, submitting as pool requested", *v1);
        sub_1DD60(5, s, 0);
      }
    }
    v8 = arg[0];
    *((_BYTE *)arg[0] + 281) = 1;
  }
  else
  {
    v8 = arg[0];
  }
  if ( v8[284] )
  {
    if ( byte_686E1 )
    {
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 6 )
      {
        v9 = v1[186];
        if ( !v9 )
        {
LABEL_16:
          if ( dword_67840 <= 3 )
          {
            if ( v1[186] )
            {
LABEL_18:
              sub_2A70C((void ***)arg, "cgminer.c", "submit_work_async", 8819);
              return;
            }
            goto LABEL_63;
          }
LABEL_32:
          strcpy(s, "Discarding work from removed pool");
          sub_1DD60(4, s, 0);
          if ( v1[186] )
            goto LABEL_18;
          if ( byte_72D90 || byte_686E0 )
          {
LABEL_35:
            snprintf(s, 0x800u, "Pushing pool %d work to stratum queue", *v1);
            sub_1DD60(5, s, 0);
            goto LABEL_18;
          }
LABEL_63:
          if ( dword_67840 <= 4 )
            goto LABEL_18;
          goto LABEL_35;
        }
        goto LABEL_29;
      }
      snprintf(s, 0x800u, "Pushing pool %d work to stratum queue", *v1);
      sub_1DD60(7, s, 0);
    }
    v9 = v1[186];
    if ( !v9 )
      goto LABEL_30;
    v8 = arg[0];
LABEL_29:
    if ( sub_200D0(v9, (int)v8) )
      return;
LABEL_30:
    if ( byte_72D90 || byte_686E0 )
      goto LABEL_32;
    goto LABEL_16;
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    strcpy(s, "Pushing submit work to work thread");
    sub_1DD60(5, s, 0);
    v8 = arg[0];
  }
  if ( pthread_create(&v19, 0, (void *(*)(void *))sub_28E18, v8) )
  {
    strcpy(s, "Failed to create submit_work_thread");
    sub_1DD60(3, s, 1);
    sub_2C230(1, 1);
  }
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681FD: using guessed type char byte_681FD;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68C50: using guessed type char byte_68C50;
// 72D90: using guessed type char byte_72D90;
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 72EF0: using guessed type __int64 qword_72EF0;
// 72EF8: using guessed type double dbl_72EF8;
// 74F28: using guessed type double dbl_74F28;
// 762C8: using guessed type __int64 qword_762C8;

//----- (0003BF78) --------------------------------------------------------
int __fastcall sub_3BF78(int a1, int a2)
{
  int v4; // r6
  __time_t *v6; // r5
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  sub_31450((int *)(a1 + 36), a2);
  v4 = sub_1FE0C((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160));
  if ( v4 )
  {
    v6 = sub_2D914();
    sub_2A5F4((int)v6, a2, 0);
    sub_3B824(v6);
    return v4;
  }
  else
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
    {
      snprintf(
        s,
        0x800u,
        "%s %s %d: Share above target",
        "submit_tested_work",
        *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
      sub_1DD60(6, s, 0);
    }
    return 0;
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (0003C064) --------------------------------------------------------
int __fastcall sub_3C064(int a1, int a2, unsigned int a3)
{
  int v6; // r5

  v6 = sub_2B7E8(a1, a3);
  if ( v6 && (*(_DWORD *)(a2 + 76) = a3, sub_28C30(a2), !*(_DWORD *)(a2 + 220)) )
  {
    sub_3BF78(a1, a2);
    if ( dword_72DB0 && byte_72E64 )
    {
      v6 = (unsigned __int8)byte_72E64;
      sub_2A854(a2, a3);
    }
  }
  else
  {
    v6 = 0;
    sub_30E60(a1);
  }
  return v6;
}
// 72DB0: using guessed type int dword_72DB0;
// 72E64: using guessed type char byte_72E64;

//----- (0003C0F8) --------------------------------------------------------
void __fastcall sub_3C0F8(int a1)
{
  __time_t *v2; // r4

  v2 = sub_2D914();
  sub_2A5F4((int)v2, a1, 0);
  sub_3B824(v2);
}

//----- (0003C120) --------------------------------------------------------
int __fastcall sub_3C120(int a1, int a2, int a3)
{
  __time_t *v4; // r5

  *(_DWORD *)(a2 + 76) = a3;
  v4 = sub_2D914();
  sub_2A5F4((int)v4, a2, 0);
  sub_3B824(v4);
  return 1;
}

//----- (0003C2EC) --------------------------------------------------------
void __fastcall __noreturn sub_3C2EC(int a1)
{
  sub_2C230(a1, 1);
}

//----- (0003C2F8) --------------------------------------------------------
int __fastcall sub_3C2F8(int a1, int a2, char *s1, const char *a4, const char *a5)
{
  char *v8; // r0
  size_t v9; // r5
  size_t v10; // r5
  char *v11; // r0
  const char *v12; // r12
  const char *v13; // r3
  int v14; // r2

  v8 = sub_20B84(s1, a1);
  *(_DWORD *)(a1 + 172) = a4;
  *(_DWORD *)(a1 + 164) = v8;
  *(_DWORD *)(a1 + 176) = a5;
  v9 = strlen(a4);
  v10 = v9 + strlen(a5) + 2;
  v11 = (char *)sub_1F828(v10, "cgminer.c", "add_pool_details", 10919);
  v12 = *(const char **)(a1 + 176);
  v13 = *(const char **)(a1 + 172);
  *(_DWORD *)(a1 + 168) = v11;
  snprintf(v11, v10, "%s:%s", v13, v12);
  v14 = *(_DWORD *)(a1 + 100);
  *(_BYTE *)(a1 + 284) = 1;
  *(_BYTE *)(a1 + 107) = a2 ^ 1;
  *(_BYTE *)(a1 + 97) = 1;
  if ( v14 != 1 )
    sub_28F90((_DWORD *)(a1 + 100));
  pthread_create((pthread_t *)(a1 + 280), 0, (void *(*)(void *))sub_33090, (void *)a1);
  if ( !a2 )
  {
    pthread_join(*(_DWORD *)(a1 + 280), 0);
    return (unsigned __int8)byte_68A04;
  }
  return a2;
}
// 68A04: using guessed type char byte_68A04;

//----- (0003C3EC) --------------------------------------------------------
int __fastcall sub_3C3EC(int result)
{
  if ( !*(_DWORD *)(result + 12) )
    *(_DWORD *)(result + 12) = 164680;
  if ( !*(_DWORD *)(result + 16) )
    *(_DWORD *)(result + 16) = 164644;
  if ( !*(_DWORD *)(result + 20) )
    *(_DWORD *)(result + 20) = 164648;
  if ( !*(_DWORD *)(result + 24) )
    *(_DWORD *)(result + 24) = 172320;
  if ( !*(_DWORD *)(result + 32) )
    *(_DWORD *)(result + 32) = 164652;
  if ( !*(_DWORD *)(result + 44) )
    *(_DWORD *)(result + 44) = 172328;
  if ( !*(_DWORD *)(result + 52) )
    *(_DWORD *)(result + 52) = 172336;
  if ( !*(_DWORD *)(result + 56) )
    *(_DWORD *)(result + 56) = 164672;
  if ( !*(_DWORD *)(result + 84) )
    *(_DWORD *)(result + 84) = 172344;
  if ( !*(_DWORD *)(result + 88) )
    *(_DWORD *)(result + 88) = 172348;
  if ( !*(_DWORD *)(result + 92) )
    *(_DWORD *)(result + 92) = 172352;
  if ( !*(_DWORD *)(result + 60) )
    *(_DWORD *)(result + 60) = sub_35C74;
  if ( !*(_DWORD *)(result + 76) )
    *(_DWORD *)(result + 76) = 164644;
  if ( !*(_DWORD *)(result + 80) )
    *(_DWORD *)(result + 80) = 164644;
  if ( !*(_DWORD *)(result + 72) )
    *(_DWORD *)(result + 72) = 164652;
  if ( !*(_DWORD *)(result + 96) )
    *(_DWORD *)(result + 96) = 164692;
  if ( *(double *)(result + 104) == 0.0 )
    *(_QWORD *)(result + 104) = 0x3FF0000000000000LL;
  return result;
}

//----- (0003C54C) --------------------------------------------------------
int __fastcall sub_3C54C(int result)
{
  *(_DWORD *)(result + 28) = sub_2834C;
  *(_DWORD *)(result + 12) = nullsub_4;
  *(_DWORD *)(result + 20) = nullsub_1;
  *(_DWORD *)(result + 24) = nullsub_2;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = sub_2A128;
  *(_DWORD *)(result + 48) = sub_28334;
  *(_DWORD *)(result + 52) = sub_2A130;
  *(_DWORD *)(result + 56) = sub_28340;
  *(_DWORD *)(result + 60) = nullsub_5;
  *(_DWORD *)(result + 84) = nullsub_6;
  *(_DWORD *)(result + 88) = nullsub_7;
  *(_DWORD *)(result + 92) = nullsub_8;
  *(_DWORD *)(result + 96) = sub_28354;
  *(_DWORD *)(result + 16) = nullsub_3;
  *(_DWORD *)(result + 36) = nullsub_3;
  *(_DWORD *)(result + 76) = nullsub_3;
  *(_DWORD *)(result + 80) = nullsub_3;
  *(_DWORD *)(result + 32) = sub_2832C;
  *(_DWORD *)(result + 72) = sub_2832C;
  *(_QWORD *)(result + 104) = 0x3FF0000000000000LL;
  *(_QWORD *)(result + 112) = 0x3FF0000000000000LL;
  return result;
}
// 28324: using guessed type int nullsub_3();
// 28328: using guessed type int nullsub_1();
// 28348: using guessed type int nullsub_4();
// 2A120: using guessed type int nullsub_2();
// 2A124: using guessed type int nullsub_5();
// 2A138: using guessed type int nullsub_6();
// 2A13C: using guessed type int nullsub_7();
// 2A140: using guessed type int nullsub_8();

//----- (0003C634) --------------------------------------------------------
int __fastcall sub_3C634(pthread_rwlock_t *a1)
{
  int v2; // r1
  int v3; // r3
  int v4; // r1
  int v5; // r2
  int nr_writers_queued; // r3
  int result; // r0

  a1[1].__lock = 0;
  if ( pthread_rwlock_wrlock(&stru_74FC0) )
    sub_2CB04("enable_device", 11329);
  v2 = dword_74F68;
  v3 = dword_6A228;
  a1->__lock = dword_6A228;
  *(_DWORD *)(v2 + 4 * v3) = a1;
  dword_6A228 = v3 + 1;
  if ( pthread_rwlock_unlock(&stru_74FC0) )
    sub_2D6AC("enable_device", 11331);
  off_67964();
  if ( byte_75010 )
    nr_writers_queued = a1[4].__nr_writers_queued;
  else
    nr_writers_queued = 25128;
  if ( byte_75010 )
    v5 = dword_6A22C;
  else
    HIWORD(nr_writers_queued) = 7;
  if ( byte_75010 )
  {
    nr_writers_queued += v5;
    dword_6A22C = nr_writers_queued;
  }
  else
  {
    v4 = *(_DWORD *)nr_writers_queued;
    v5 = a1[4].__nr_writers_queued;
  }
  if ( !byte_75010 )
    *(_DWORD *)nr_writers_queued = v5 + v4;
  result = pthread_rwlock_init(a1 + 10, 0);
  if ( result )
    sub_2CA38("enable_device", 11342);
  a1[11].__lock = 0;
  return result;
}
// 3C6D0: variable 'v5' is possibly undefined
// 3C6D8: variable 'v4' is possibly undefined
// 67964: using guessed type int (*off_67964)();
// 6A228: using guessed type int dword_6A228;
// 6A22C: using guessed type int dword_6A22C;
// 74F68: using guessed type int dword_74F68;
// 74FC0: using guessed type pthread_rwlock_t stru_74FC0;
// 75010: using guessed type char byte_75010;

//----- (0003C720) --------------------------------------------------------
int __fastcall sub_3C720(_DWORD *a1)
{
  unsigned int v1; // r5
  const char *v2; // r4
  size_t v3; // r0
  int v4; // r3
  size_t v5; // r6
  int v6; // r0
  unsigned __int8 *v7; // r9
  int v8; // lr
  int v9; // r2
  int v10; // r1
  int v11; // r4
  unsigned int v12; // r5
  unsigned int v13; // r3
  int v14; // r2
  unsigned int v15; // r1
  unsigned int v16; // r3
  int v17; // r2
  unsigned int v18; // r1
  unsigned int v19; // r3
  size_t v20; // r3
  int v21; // r0
  unsigned int v22; // r2
  unsigned int v23; // r7
  int v24; // r3
  unsigned int v25; // r2
  unsigned int v26; // r7
  int v27; // r3
  unsigned int v28; // r7
  _DWORD *v29; // r1
  int v30; // r2
  int v31; // r8
  int v32; // r5
  int v33; // r5
  int v34; // r3
  int v35; // r0
  int v36; // r2
  int v37; // r3
  int v38; // r1
  int result; // r0
  _DWORD *v40; // r5
  unsigned int v41; // r7
  size_t v42; // r0
  int v43; // r12
  unsigned int v44; // r11
  int v45; // r3
  unsigned __int8 *v46; // r10
  unsigned int v47; // r7
  unsigned __int8 *v48; // r2
  unsigned int v49; // r0
  unsigned int v50; // r1
  int v51; // r3
  unsigned int v52; // r0
  unsigned int v53; // r1
  int v54; // r3
  unsigned int v55; // r0
  unsigned int v56; // r1
  unsigned int v57; // r12
  int v58; // r3
  unsigned int v59; // r2
  unsigned int v60; // r1
  int v61; // r3
  unsigned int v62; // r2
  unsigned int v63; // r1
  int v64; // r3
  unsigned int v65; // r6
  int v66; // r7
  int v67; // r3
  _DWORD *v68; // r8
  __int64 v69; // r2
  int v70; // r3
  int v71; // r1
  _DWORD *v72; // r2
  __int64 v73; // r2
  int v74; // r3
  _DWORD *v75; // r8
  int v76; // r2
  int v77; // r10
  int v78; // r3
  unsigned int v79; // r6
  _DWORD *v80; // r7
  unsigned int v81; // r4
  _DWORD *v82; // r6
  int v83; // r4
  char *v84; // r9
  unsigned int v85; // r3
  int v86; // r2
  int v87; // r3
  _DWORD *v88; // r3
  unsigned int v89; // r2
  unsigned int v90; // r1
  bool v91; // cc
  int v92; // r2
  int v93; // r3
  unsigned __int8 *v94; // r11
  unsigned int v95; // r10
  void *v96; // r0
  void **v97; // r9
  void *v98; // r0
  const char *s2; // [sp+10h] [bp-Ch]
  char *s2a; // [sp+10h] [bp-Ch]
  char *s2b; // [sp+10h] [bp-Ch]

  v1 = -1640531527;
  v2 = *(const char **)(a1[1] + 8);
  s2 = v2;
  v3 = strlen(v2);
  v91 = v3 > 0xB;
  v4 = -17973521;
  v5 = v3;
  v6 = -1640531527;
  if ( v91 )
  {
    v7 = (unsigned __int8 *)(v2 + 12);
    v95 = v5;
    do
    {
      v8 = *(v7 - 6);
      v95 -= 12;
      v9 = *(v7 - 2);
      v10 = *(v7 - 10);
      v94 = v7;
      v11 = *(v7 - 7);
      v7 += 12;
      v12 = (v8 << 16) + (v11 << 8) + *(v7 - 20) + (*(v7 - 17) << 24) + v1;
      v13 = (v9 << 16) + (*(v7 - 15) << 8) + *(v7 - 16) + (*(v7 - 13) << 24) + v4;
      v14 = ((v10 << 16) + (*(v7 - 23) << 8) + *(v7 - 24) + (*(v7 - 21) << 24) - v12 - v13 + v6) ^ (v13 >> 13);
      v15 = (v12 - v13 - v14) ^ (v14 << 8);
      v16 = (v13 - v14 - v15) ^ (v15 >> 13);
      v17 = (v14 - v15 - v16) ^ (v16 >> 12);
      v18 = (v15 - v16 - v17) ^ (v17 << 16);
      v19 = (v16 - v17 - v18) ^ (v18 >> 5);
      v6 = (v17 - v18 - v19) ^ (v19 >> 3);
      v1 = (v18 - v19 - v6) ^ (v6 << 10);
      v4 = (v19 - v6 - v1) ^ (v1 >> 15);
    }
    while ( v95 > 0xB );
  }
  else
  {
    v94 = (unsigned __int8 *)v2;
    v95 = v5;
  }
  v20 = v5 + v4;
  switch ( v95 )
  {
    case 1u:
      goto LABEL_16;
    case 2u:
      goto LABEL_15;
    case 3u:
      goto LABEL_14;
    case 4u:
      goto LABEL_13;
    case 5u:
      goto LABEL_12;
    case 6u:
      goto LABEL_11;
    case 7u:
      goto LABEL_10;
    case 8u:
      goto LABEL_9;
    case 9u:
      goto LABEL_8;
    case 0xAu:
      goto LABEL_7;
    case 0xBu:
      v20 += v94[10] << 24;
LABEL_7:
      v20 += v94[9] << 16;
LABEL_8:
      v20 += v94[8] << 8;
LABEL_9:
      v1 += v94[7] << 24;
LABEL_10:
      v1 += v94[6] << 16;
LABEL_11:
      v1 += v94[5] << 8;
LABEL_12:
      v1 += v94[4];
LABEL_13:
      v6 += v94[3] << 24;
LABEL_14:
      v6 += v94[2] << 16;
LABEL_15:
      v6 += v94[1] << 8;
LABEL_16:
      v6 += *v94;
      break;
    default:
      break;
  }
  v21 = (v6 - v1 - v20) ^ (v20 >> 13);
  v22 = (v1 - v20 - v21) ^ (v21 << 8);
  v23 = (v20 - v21 - v22) ^ (v22 >> 13);
  v24 = (v21 - v22 - v23) ^ (v23 >> 12);
  v25 = (v22 - v23 - v24) ^ (v24 << 16);
  v26 = (v23 - v24 - v25) ^ (v25 >> 5);
  v27 = (v24 - v25 - v26) ^ (v26 >> 3);
  v28 = (v26 - v27 - ((v25 - v26 - v27) ^ (v27 << 10))) ^ (((v25 - v26 - v27) ^ (v27 << 10)) >> 15);
  if ( !dword_6A230
    || (v29 = *(_DWORD **)(dword_6A230 + 8), (v30 = *(_DWORD *)(*v29 + 12 * ((v29[1] - 1) & v28))) == 0)
    || (v31 = -v29[5], v32 = v30 - v29[5], v30 == v29[5]) )
  {
LABEL_46:
    v40 = sub_1F828(0x28u, "cgminer.c", "add_cgpu", 11376);
    sub_232EC(v40, *(const void **)(a1[1] + 8), 4u, (int)"cgminer.c", (int)"add_cgpu", 11377);
    v40[1] = 0;
    a1[2] = 0;
    v41 = -1640531527;
    v42 = strlen((const char *)v40);
    v43 = -17973521;
    s2a = (char *)v42;
    v44 = v42;
    v45 = -1640531527;
    if ( v42 <= 0xB )
    {
      v48 = (unsigned __int8 *)v40;
      v44 = v42;
    }
    else
    {
      v46 = (unsigned __int8 *)(v40 + 3);
      do
      {
        v44 -= 12;
        v47 = (*(v46 - 6) << 16) + (*(v46 - 7) << 8) + *(v46 - 8) + (*(v46 - 5) << 24) + v41;
        v48 = v46;
        v49 = (*(v46 - 10) << 16) + (*(v46 - 11) << 8) + *(v46 - 12) + (*(v46 - 9) << 24) - v47;
        v50 = (*(v46 - 2) << 16) + (*(v46 - 3) << 8) + *(v46 - 4) + (*(v46 - 1) << 24) + v43;
        v46 += 12;
        v51 = (v49 - v50 + v45) ^ (v50 >> 13);
        v52 = (v47 - v50 - v51) ^ (v51 << 8);
        v53 = (v50 - v51 - v52) ^ (v52 >> 13);
        v54 = (v51 - v52 - v53) ^ (v53 >> 12);
        v55 = (v52 - v53 - v54) ^ (v54 << 16);
        v56 = (v53 - v54 - v55) ^ (v55 >> 5);
        v45 = (v54 - v55 - v56) ^ (v56 >> 3);
        v41 = (v55 - v56 - v45) ^ (v45 << 10);
        v43 = (v56 - v45 - v41) ^ (v41 >> 15);
      }
      while ( v44 > 0xB );
    }
    v57 = (unsigned int)&s2a[v43];
    switch ( v44 )
    {
      case 1u:
        goto LABEL_60;
      case 2u:
        goto LABEL_59;
      case 3u:
        goto LABEL_58;
      case 4u:
        goto LABEL_57;
      case 5u:
        goto LABEL_56;
      case 6u:
        goto LABEL_55;
      case 7u:
        goto LABEL_54;
      case 8u:
        goto LABEL_53;
      case 9u:
        goto LABEL_52;
      case 0xAu:
        goto LABEL_51;
      case 0xBu:
        v57 += v48[10] << 24;
LABEL_51:
        v57 += v48[9] << 16;
LABEL_52:
        v57 += v48[8] << 8;
LABEL_53:
        v41 += v48[7] << 24;
LABEL_54:
        v41 += v48[6] << 16;
LABEL_55:
        v41 += v48[5] << 8;
LABEL_56:
        v41 += v48[4];
LABEL_57:
        v45 += v48[3] << 24;
LABEL_58:
        v45 += v48[2] << 16;
LABEL_59:
        v45 += v48[1] << 8;
LABEL_60:
        v45 += *v48;
        break;
      default:
        break;
    }
    v40[7] = v40;
    v58 = (v45 - v41 - v57) ^ (v57 >> 13);
    v59 = (v41 - v57 - v58) ^ (v58 << 8);
    v60 = (v57 - v58 - v59) ^ (v59 >> 13);
    v61 = (v58 - v59 - v60) ^ (v60 >> 12);
    v62 = (v59 - v60 - v61) ^ (v61 << 16);
    v63 = (v60 - v61 - v62) ^ (v62 >> 5);
    v64 = (v61 - v62 - v63) ^ (v63 >> 3);
    v65 = (v63 - v64 - ((v62 - v63 - v64) ^ (v64 << 10))) ^ (((v62 - v63 - v64) ^ (v64 << 10)) >> 15);
    v40[9] = v65;
    v66 = dword_6A230;
    v40[8] = strlen((const char *)v40);
    if ( v66 )
    {
      v67 = *(_DWORD *)(v66 + 8);
      v40[4] = 0;
      v68 = v40 + 2;
      v40[2] = v67;
      v40[3] = *(_DWORD *)(*(_DWORD *)(v66 + 8) + 16) - *(_DWORD *)(*(_DWORD *)(v66 + 8) + 20);
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v66 + 8) + 16) + 8) = v40;
      *(_DWORD *)(*(_DWORD *)(v66 + 8) + 16) = v40 + 2;
    }
    else
    {
      v40[4] = 0;
      v40[3] = 0;
      dword_6A230 = (int)v40;
      v96 = malloc(0x2Cu);
      v40[2] = v96;
      if ( !v96 )
        goto LABEL_96;
      memset(v96, 0, 0x2Cu);
      v68 = v40 + 2;
      *(_DWORD *)(v40[2] + 16) = v40 + 2;
      *(_DWORD *)(v40[2] + 4) = 32;
      *(_DWORD *)(v40[2] + 8) = 5;
      *(_DWORD *)(v40[2] + 20) = 8;
      v97 = (void **)v40[2];
      *v97 = malloc(0x180u);
      v98 = *(void **)v40[2];
      if ( !v98 )
        goto LABEL_96;
      memset(v98, 0, 0x180u);
      v66 = (int)v40;
      *(_DWORD *)(v40[2] + 40) = -1609490463;
    }
    ++*(_DWORD *)(*(_DWORD *)(v66 + 8) + 12);
    v69 = *(_QWORD *)*(_DWORD *)(v66 + 8);
    v70 = 12 * ((HIDWORD(v69) - 1) & v65);
    ++*(_DWORD *)(v69 + v70 + 4);
    LODWORD(v69) = *(_DWORD *)(**(_DWORD **)(v66 + 8) + v70);
    v40[5] = 0;
    v40[6] = v69;
    LODWORD(v69) = **(_DWORD **)(v66 + 8);
    v71 = *(_DWORD *)(v69 + v70);
    v72 = (_DWORD *)(v69 + v70);
    if ( v71 )
    {
      *(_DWORD *)(v71 + 12) = v68;
      v72 = (_DWORD *)(**(_DWORD **)(v66 + 8) + v70);
    }
    *v72 = v68;
    v73 = *(_QWORD *)(**(_DWORD **)(v66 + 8) + v70 + 4);
    if ( (unsigned int)v73 < 10 * (HIDWORD(v73) + 1) )
      goto LABEL_27;
    v74 = v40[2];
    if ( *(_DWORD *)(v74 + 36) == 1 )
      goto LABEL_27;
    v75 = calloc(24 * *(_DWORD *)(v74 + 4), 1u);
    if ( v75 )
    {
      v76 = v40[2];
      v77 = 0;
      *(_DWORD *)(v76 + 24) = (((2 * *(_DWORD *)(v76 + 4) - 1) & *(_DWORD *)(v76 + 12)) != 0)
                            + (*(_DWORD *)(v76 + 12) >> (*(_BYTE *)(v76 + 8) + 1));
      *(_DWORD *)(v40[2] + 28) = 0;
      v78 = v40[2];
      v79 = *(_DWORD *)(v78 + 4);
      if ( v79 )
      {
        for ( s2b = 0; (unsigned int)s2b < v79; ++s2b )
        {
          v80 = *(_DWORD **)(*(_DWORD *)v78 + v77);
          if ( v80 )
          {
            v81 = v79;
            while ( 1 )
            {
              v82 = (_DWORD *)v80[4];
              v83 = 3 * ((2 * v81 - 1) & v80[7]);
              v84 = (char *)&v75[v83];
              v85 = *((_DWORD *)v84 + 1) + 1;
              *((_DWORD *)v84 + 1) = v85;
              v86 = v40[2];
              if ( v85 > *(_DWORD *)(v86 + 24) )
              {
                ++*(_DWORD *)(v86 + 28);
                *((_DWORD *)v84 + 2) = sub_4A2D0(*((_DWORD *)v84 + 1), *(_DWORD *)(v40[2] + 24));
              }
              v80[3] = 0;
              v80[4] = v75[v83];
              v87 = v75[v83];
              if ( v87 )
                *(_DWORD *)(v87 + 12) = v80;
              v75[v83] = v80;
              v78 = v40[2];
              if ( !v82 )
                break;
              v81 = *(_DWORD *)(v78 + 4);
              v80 = v82;
            }
            v79 = *(_DWORD *)(v78 + 4);
          }
          v77 += 12;
        }
      }
      free(*(void **)v78);
      *(_DWORD *)(v40[2] + 4) *= 2;
      ++*(_DWORD *)(v40[2] + 8);
      *(_DWORD *)v40[2] = v75;
      v88 = (_DWORD *)v40[2];
      v89 = v88[7];
      v90 = v88[3];
      v91 = v89 > v90 >> 1;
      if ( v89 <= v90 >> 1 )
        v92 = 0;
      else
        v92 = v88[8];
      if ( v91 )
        ++v92;
      v88[8] = v92;
      v93 = v40[2];
      if ( *(_DWORD *)(v93 + 32) > 1u )
        *(_DWORD *)(v93 + 36) = 1;
      goto LABEL_27;
    }
LABEL_96:
    exit(-1);
  }
  while ( *(_DWORD *)(v32 + 36) != v28 || *(_DWORD *)(v32 + 32) != v5 || memcmp(*(const void **)(v32 + 28), s2, v5) )
  {
    v33 = *(_DWORD *)(v32 + 24);
    if ( v33 )
    {
      v32 = v33 + v31;
      if ( v32 )
        continue;
    }
    goto LABEL_46;
  }
  v34 = *(_DWORD *)(v32 + 4) + 1;
  *(_DWORD *)(v32 + 4) = v34;
  a1[2] = v34;
LABEL_27:
  if ( pthread_rwlock_wrlock(&stru_74FC0) )
    sub_2CB04("add_cgpu", 11382);
  dword_74F68 = (int)sub_1F940((void *)dword_74F68, 4 * (dword_74FE0 + dword_6A234 + 2), "cgminer.c", "add_cgpu", 11383);
  if ( pthread_rwlock_unlock(&stru_74FC0) )
    sub_2D6AC("add_cgpu", 11384);
  off_67964();
  if ( pthread_mutex_lock(&stru_72D94) )
    sub_2CB60("add_cgpu", 11386);
  a1[58] = time(0);
  if ( pthread_mutex_unlock(&stru_72D94) )
    sub_2CBBC("add_cgpu", 11388);
  v35 = off_67964();
  if ( byte_75010 )
    v37 = dword_6A234;
  else
    v37 = dword_74FE0;
  if ( byte_75010 )
  {
    v35 = dword_74FE0;
    v38 = v37 + 1;
    v36 = dword_74F68;
  }
  else
  {
    v38 = v37 + 1;
  }
  if ( byte_75010 )
    dword_6A234 = v38;
  else
    dword_74FE0 = v38;
  if ( byte_75010 )
    v37 += v35;
  else
    v36 = dword_74F68;
  result = 1;
  *(_DWORD *)(v36 + 4 * v37) = a1;
  if ( dword_74FE0 - dword_7606C > dword_6A238 )
    dword_6A238 = dword_74FE0 - dword_7606C;
  return result;
}
// 3C864: control flows out of bounds to 3C868
// 3CCA4: control flows out of bounds to 3CCA8
// 3CAF4: variable 'v36' is possibly undefined
// 67964: using guessed type int (*off_67964)();
// 6A230: using guessed type int dword_6A230;
// 6A234: using guessed type int dword_6A234;
// 6A238: using guessed type int dword_6A238;
// 72D94: using guessed type pthread_mutex_t stru_72D94;
// 74F68: using guessed type int dword_74F68;
// 74FC0: using guessed type pthread_rwlock_t stru_74FC0;
// 74FE0: using guessed type int dword_74FE0;
// 75010: using guessed type char byte_75010;
// 7606C: using guessed type int dword_7606C;

//----- (0003D12C) --------------------------------------------------------
_BYTE *__fastcall sub_3D12C(const void *a1)
{
  _BYTE *v2; // r5

  v2 = sub_1F828(0x78u, "cgminer.c", "copy_drv", 11412);
  sub_232EC(v2, a1, 0x78u, (int)"cgminer.c", (int)"copy_drv", 11413);
  v2[100] = 1;
  return v2;
}

//----- (0003D190) --------------------------------------------------------
void sub_3D190()
{
  int v0; // r4
  char *v1; // r0
  struct sysinfo v2; // [sp+0h] [bp-940h] BYREF
  char s[256]; // [sp+40h] [bp-900h] BYREF
  char v4[2048]; // [sp+140h] [bp-800h] BYREF

  if ( sysinfo(&v2) )
  {
    v0 = *_errno_location();
    v1 = strerror(v0);
    sprintf(v4, "Failed to get sysinfo, errno:%u, reason:%s\n", v0, v1);
    dword_76194 = time(0);
    dword_761D4 = dword_76194 + 1;
  }
  else
  {
    dword_76194 = v2.uptime;
    dword_761D4 = v2.uptime + 1;
    sprintf(s, "set_start_time_point total_tv_start_sys=%ld total_tv_end_sys=%ld\n", v2.uptime, v2.uptime + 1);
    if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
    {
      snprintf(v4, 0x800u, "%s", s);
      sub_1DD60(5, v4, 0);
    }
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 76194: using guessed type int dword_76194;
// 761D4: using guessed type int dword_761D4;

//----- (0003D2A0) --------------------------------------------------------
unsigned int sub_3D2A0()
{
  pthread_t v0; // r0
  int v1; // r1
  int v2; // r7
  int v3; // r6
  int v4; // r3
  int v5; // r10
  int v6; // r9
  int v7; // r8
  int v8; // r6
  int v9; // r8
  int v10; // r2
  int v11; // r3
  int v12; // r12
  int v13; // r1
  int *v14; // r11
  int v15; // r7
  int v16; // r6
  int v17; // r3
  size_t v18; // r0
  unsigned int result; // r0
  int v20; // r5
  int v21; // r7
  int v22; // [sp+18h] [bp-834h]
  pthread_attr_t attr; // [sp+24h] [bp-828h] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  v0 = pthread_self();
  pthread_detach(v0);
  pthread_mutex_lock((pthread_mutex_t *)&unk_6A23C);
  v1 = dword_72DC0 + (dword_68B68 << 6);
  if ( *(_DWORD *)(v1 + 12) )
  {
    sub_23220((int)sub_20284, v1, 1000);
    v22 = 1;
    usleep((__useconds_t)&loc_186A0);
  }
  else
  {
    v22 = 0;
  }
  if ( dword_68A08 )
    free((void *)dword_68A08);
  v2 = dword_72E60;
  if ( dword_72E60 > 0 )
  {
    v3 = 0;
    do
    {
      if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
      {
        snprintf(
          s,
          0x800u,
          "before add pool, pool->pool_no = %d, pool->rpc_url = %s\n",
          **(_DWORD **)(dword_72F04 + 4 * v3),
          *(const char **)(*(_DWORD *)(dword_72F04 + 4 * v3) + 164));
        sub_1DD60(7, s, 0);
      }
      ++v3;
    }
    while ( v2 != v3 );
  }
  sub_2B46C();
  v4 = dword_72E60;
  if ( dword_72E60 == v2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      strcpy(s, "Input pool error, try again\n");
      sub_1DD60(3, s, 0);
    }
    pthread_mutex_unlock((pthread_mutex_t *)&unk_6A23C);
  }
  else
  {
    byte_68A04 = 0;
    if ( dword_72E60 > v2 )
    {
      v5 = 4 * v2;
      v6 = v2;
      do
      {
        v7 = *(_DWORD *)(dword_72F04 + v5);
        if ( *(_DWORD *)(v7 + 100) != 1 )
          sub_28F90((_DWORD *)(v7 + 100));
        v4 = dword_72E60;
        ++v6;
        *(_BYTE *)(v7 + 97) = 1;
        v5 += 4;
      }
      while ( v4 > v6 );
    }
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(s, 0x800u, "total_pools = %d, need to remove %d pools\n", v4, v2);
      sub_1DD60(7, s, 0);
    }
    if ( dword_72E60 > 0 )
    {
      v8 = 0;
      do
      {
        if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
        {
          snprintf(
            s,
            0x800u,
            "after add pool, pool->pool_no = %d, pool->rpc_url = %s\n",
            **(_DWORD **)(dword_72F04 + 4 * v8),
            *(const char **)(*(_DWORD *)(dword_72F04 + 4 * v8) + 164));
          sub_1DD60(7, s, 0);
        }
        ++v8;
      }
      while ( dword_72E60 > v8 );
    }
    if ( v2 > 0 )
    {
      v9 = 0;
      do
      {
        v14 = *(int **)dword_72F04;
        if ( v14 == (int *)sub_2FB78() )
          sub_31A9C(0);
        ++v9;
        v10 = dword_68B7C;
        v11 = dword_68B8C;
        v12 = dword_74F24 - 1;
        v13 = dword_68B80 - 1;
        v14[25] = 0;
        dword_74F24 = v12;
        dword_68B80 = v13;
        dword_68B7C = v10 - 1;
        dword_68B8C = v11 - 1;
        sub_2AC40(v14);
      }
      while ( v2 != v9 );
    }
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(s, 0x800u, "total_pools after removed = %d\n", dword_72E60);
      sub_1DD60(7, s, 0);
    }
    if ( dword_72E60 > 0 )
    {
      v15 = 0;
      do
      {
        if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
        {
          snprintf(
            s,
            0x800u,
            "after reload pool, pool->pool_no = %d, pool->rpc_url = %s\n",
            **(_DWORD **)(dword_72F04 + 4 * v15),
            *(const char **)(*(_DWORD *)(dword_72F04 + 4 * v15) + 164));
          sub_1DD60(5, s, 0);
        }
        ++v15;
      }
      while ( dword_72E60 > v15 );
    }
    v16 = 0;
    sub_28CFC();
    do
    {
      ++v16;
      sleep(1u);
      if ( v16 == 8 )
        v17 = 0;
      else
        v17 = ((unsigned __int8)byte_68A04 ^ 1) & 1;
    }
    while ( v17 );
    sub_3D190();
    attr.__align = 25970;
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(s, 0x800u, "pool change success, send %s", attr.__size);
      sub_1DD60(7, s, 0);
    }
    v18 = strlen(attr.__size);
    sub_42680(&attr, v18);
    if ( byte_68A04 )
    {
      dword_6A254 = 1;
    }
    else
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        strcpy(s, "error pool input");
        sub_1DD60(3, s, 0);
      }
      if ( dword_72E60 > 0 )
      {
        v21 = 0;
        do
        {
          if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
          {
            snprintf(
              s,
              0x800u,
              "pool%d, url = %s, user = %s, pass = %s\n",
              **(_DWORD **)(dword_72F04 + 4 * v21),
              *(const char **)(*(_DWORD *)(dword_72F04 + 4 * v21) + 164),
              *(const char **)(*(_DWORD *)(dword_72F04 + 4 * v21) + 172),
              *(const char **)(*(_DWORD *)(dword_72F04 + 4 * v21) + 176));
            sub_1DD60(3, s, 0);
          }
          ++v21;
        }
        while ( dword_72E60 > v21 );
      }
    }
    dword_6A258 = 1;
    pthread_mutex_unlock((pthread_mutex_t *)&unk_6A23C);
  }
  if ( v22 )
  {
    v20 = dword_72DC0 + (dword_68B68 << 6);
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, 0x200000u);
    if ( sub_22F54(v20, &attr, (void *(*)(void *))sub_32050, 0) )
    {
      strcpy(s, "watchpool thread create failed");
      sub_1DD60(3, s, 1);
      sub_2C230(1, 0);
    }
    pthread_detach(*(_DWORD *)(v20 + 12));
  }
  result = sleep(1u);
  dword_68AE0 = 0;
  return result;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68A04: using guessed type char byte_68A04;
// 68A08: using guessed type int dword_68A08;
// 68AE0: using guessed type int dword_68AE0;
// 68B68: using guessed type int dword_68B68;
// 68B7C: using guessed type int dword_68B7C;
// 68B80: using guessed type int dword_68B80;
// 68B8C: using guessed type int dword_68B8C;
// 6A254: using guessed type int dword_6A254;
// 6A258: using guessed type int dword_6A258;
// 72D90: using guessed type char byte_72D90;
// 72DC0: using guessed type int dword_72DC0;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;
// 74F24: using guessed type int dword_74F24;

//----- (0003DA90) --------------------------------------------------------
void sub_3DA90()
{
  FILE *v0; // r6
  signed int v1; // r0
  char *v2; // r7
  unsigned __int8 *v3; // r4
  int v4; // r7
  char *v5; // r0
  size_t v6; // r0
  int v7; // r3
  size_t v8; // r0
  int v9; // r3
  bool v10; // zf
  int v11; // r5
  char v12[256]; // [sp+8h] [bp-900h] BYREF
  char s[2048]; // [sp+108h] [bp-800h] BYREF

  v0 = (FILE *)fopen64(dword_688F8, "rb");
  memset(v12, 0, sizeof(v12));
  if ( v0 )
  {
    v1 = fread(v12, 1u, 0x100u, v0);
    if ( v1 <= 0 )
    {
      v11 = (int)&byte_72D90;
      if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
        goto LABEL_24;
      snprintf(s, 0x800u, "Read miner version file %s error %d", (const char *)dword_688F8, v1);
      sub_1DD60(3, s, 0);
    }
    else
    {
      v2 = strchr(v12, 10);
      if ( v2 )
      {
        v3 = byte_6A6E0;
        sub_232EC(byte_6A25C, v12, v2 - v12, (int)"cgminer.c", (int)"read_version_file", 11643);
        v4 = stpcpy(v12, v2 + 1);
        v5 = strchr(v12, 10);
        if ( v5 )
          sub_232EC(byte_6A35C, v12, v5 - v12, (int)"cgminer.c", (int)"read_version_file", 11652);
        else
          memcpy(byte_6A35C, v12, v4 - (_DWORD)v12 + 1);
      }
      else
      {
        v3 = byte_6A6E0;
        strcpy(byte_6A25C, v12);
      }
      v6 = strlen(byte_6A25C) - 1;
      v7 = byte_6A6E0[v6 - 1156];
      if ( v7 == 10 )
      {
        byte_6A6E0[v6 - 1156] = 0;
        v6 = strlen(byte_6A25C) - 1;
        v7 = byte_6A6E0[v6 - 1156];
      }
      if ( v7 == 13 )
        byte_6A6E0[v6 - 1156] = 0;
      v8 = strlen(byte_6A35C) - 1;
      v9 = byte_6A6E0[v8 - 900];
      if ( v9 == 10 )
      {
        byte_6A6E0[v8 - 900] = 0;
        v8 = strlen(byte_6A35C) - 1;
        v9 = byte_6A6E0[v8 - 900];
      }
      v10 = v9 == 13;
      v11 = 11664;
      if ( v9 == 13 )
      {
        v3 = &byte_6A6E0[v8];
        LOBYTE(v9) = 0;
      }
      else
      {
        HIWORD(v11) = 7;
      }
      if ( v10 )
      {
        HIWORD(v11) = 7;
        *(v3 - 900) = v9;
      }
    }
  }
  else
  {
    v11 = (int)&byte_72D90;
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      goto LABEL_24;
    snprintf(s, 0x800u, "Open miner version file %s error", (const char *)dword_688F8);
    sub_1DD60(3, s, 0);
  }
  if ( *(_BYTE *)v11 || byte_686E0 )
    goto LABEL_23;
LABEL_24:
  if ( dword_67840 > 2 )
  {
LABEL_23:
    snprintf(s, 0x800u, "Miner compile time: %s type: %s", byte_6A25C, byte_6A35C);
    sub_1DD60(3, s, 0);
  }
}
// 1262C: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 12830: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 688F8: using guessed type int dword_688F8;
// 6A6E0: using guessed type unsigned __int8 byte_6A6E0[253];
// 72D90: using guessed type char byte_72D90;

//----- (0003DDB0) --------------------------------------------------------
void sub_3DDB0()
{
  int v0; // r6
  char *v1; // r8
  _DWORD *v2; // r0
  _DWORD *v3; // r7
  _DWORD *v4; // r0
  _DWORD *v5; // r8
  int v6; // r5
  _DWORD *v7; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  unsigned int v11; // r9
  char *v12; // r11
  _DWORD *v13; // r0
  _DWORD *v14; // r7
  _BOOL4 v15; // r3
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  char *v22; // r5
  const char *v23; // r0
  int v24; // r0
  int v25; // r9
  int v26; // r0
  const char *v27; // r1
  int v28; // r8
  int v29; // t1
  _DWORD *v30; // [sp+14h] [bp-1210h]
  _DWORD *v31; // [sp+18h] [bp-120Ch]
  char v32[92]; // [sp+24h] [bp-1200h] BYREF
  char v33[160]; // [sp+80h] [bp-11A4h] BYREF
  char v34[2048]; // [sp+120h] [bp-1104h] BYREF
  char s[2308]; // [sp+920h] [bp-904h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "START %s", "load_default_config_without_restart");
    sub_1DD60(7, s, 0);
  }
  if ( dword_68A08 )
    free((void *)dword_68A08);
  dword_68A08 = (int)sub_1F828(0x1000u, "cgminer.c", "load_default_config_without_restart", 11956);
  sub_2B370((char *)dword_68A08);
  v0 = access((const char *)dword_68A08, 4);
  if ( v0 )
  {
    free((void *)dword_68A08);
    dword_68A08 = 0;
    return;
  }
  v1 = (char *)dword_68A08;
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "start %s\n", "judge_load_config");
    sub_1DD60(7, s, 0);
  }
  memset(s, 0, 0x900u);
  if ( v1 )
  {
    v2 = sub_47FA8(v1, 0, v32);
    v3 = v2;
    if ( !v2 || *v2 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(v34, 0x800u, "%s: JSON decode of file '%s' failed\n %s", "judge_load_config", v1, v33);
        sub_1DD60(3, v34, 0);
      }
      return;
    }
    if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(v34, 0x800u, "%s: after json_load_file\n", "judge_load_config");
      sub_1DD60(7, v34, 0);
    }
    v4 = (_DWORD *)sub_48AF4(v3, "pools");
    v5 = v4;
    if ( !v4 || *v4 != 1 )
      goto LABEL_35;
    v30 = sub_48E60(v4);
    v11 = 0;
    v12 = s;
    v31 = v3;
    if ( sub_48E60(v5) )
    {
      do
      {
        v13 = sub_48E7C(v5, v11);
        v14 = v13;
        if ( !v13 )
          break;
        v15 = v11 == 3;
        if ( *v13 )
          v15 = 1;
        if ( v15 )
          break;
        v16 = (_DWORD *)sub_48AF4(v13, "url");
        if ( !v16 )
          break;
        if ( *v16 != 2 )
          break;
        v17 = sub_49028(v16);
        snprintf(v12, 0x100u, "%s", v17);
        v18 = (_DWORD *)sub_48AF4(v14, "user");
        if ( !v18 )
          break;
        if ( *v18 != 2 )
          break;
        v19 = sub_49028(v18);
        snprintf(v12 + 256, 0x100u, "%s", v19);
        v20 = (_DWORD *)sub_48AF4(v14, "pass");
        if ( !v20 || *v20 != 2 )
          break;
        v21 = sub_49028(v20);
        snprintf(v12 + 512, 0x100u, "%s", v21);
        if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
        {
          snprintf(v34, 0x800u, "%s\n%s\n%s\n", v12, v12 + 256, v12 + 512);
          sub_1DD60(7, v34, 0);
        }
        ++v11;
        v12 += 768;
      }
      while ( (unsigned int)sub_48E60(v5) > v11 );
    }
    v3 = v31;
    v22 = s;
    if ( v30 == (_DWORD *)dword_72E60 )
    {
      if ( (int)v30 <= 0 )
      {
LABEL_35:
        v6 = 0;
LABEL_36:
        v7 = (_DWORD *)sub_48AF4(v3, "bitmain-freq-level");
        if ( v7 )
        {
          if ( *v7 == 2 )
          {
            v23 = (const char *)sub_49028(v7);
            v24 = strtol(v23, 0, 10);
            if ( v24 != dword_68200 )
            {
              v6 |= 2u;
              dword_68200 = v24;
            }
          }
        }
        if ( v3[1] != -1 )
        {
          v8 = v3 + 1;
          __dmb(0xBu);
          do
          {
            v9 = __ldrex(v8);
            v10 = v9 - 1;
          }
          while ( __strex(v10, v8) );
          if ( !v10 )
            sub_4942C(v3);
        }
        if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
        {
          snprintf(v34, 0x800u, "ret = 0x%x", v6);
          sub_1DD60(7, v34, 0);
        }
        switch ( v6 )
        {
          case 2:
            sub_42680(&dword_68200, 4u);
            return;
          case 3:
            sub_42680(&dword_68200, 4u);
            break;
          case 1:
            break;
          default:
            return;
        }
        sub_2987C();
        return;
      }
      v25 = dword_72F04 - 4;
      while ( 1 )
      {
        v29 = *(_DWORD *)(v25 + 4);
        v25 += 4;
        v28 = v29;
        ++v0;
        if ( strcmp(*(const char **)(v29 + 164), v22) )
          break;
        v26 = strcmp(*(const char **)(v28 + 172), v22 + 256);
        v27 = v22 + 512;
        v22 += 768;
        if ( v26 || strcmp(*(const char **)(v28 + 176), v27) )
          break;
        if ( v30 == (_DWORD *)v0 )
          goto LABEL_35;
      }
    }
    v6 = 1;
    goto LABEL_36;
  }
  if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    snprintf(v34, 0x800u, "%s: bad param", "judge_load_config");
    sub_1DD60(3, v34, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 68200: using guessed type int dword_68200;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 68A08: using guessed type int dword_68A08;
// 72D90: using guessed type char byte_72D90;
// 72E60: using guessed type int dword_72E60;
// 72F04: using guessed type int dword_72F04;

//----- (0003E49C) --------------------------------------------------------
char *__fastcall sub_3E49C(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v4 + v5);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (0003E4D8) --------------------------------------------------------
int __fastcall sub_3E4D8(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0003E4E8) --------------------------------------------------------
int __fastcall sub_3E4E8(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (0003E4F8) --------------------------------------------------------
int __fastcall sub_3E4F8(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (0003E508) --------------------------------------------------------
char *__fastcall sub_3E508(const char *a1, _BYTE *a2)
{
  if ( !strcasecmp(a1, "yes") || !strcasecmp(a1, "true") )
  {
    *a2 = 1;
    return 0;
  }
  else if ( !strcasecmp(a1, "no") || !strcasecmp(a1, "false") )
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    return sub_3F040(a1);
  }
}

//----- (0003E59C) --------------------------------------------------------
char *__fastcall sub_3E59C(const char *a1, _BYTE *a2)
{
  char *result; // r0

  result = sub_3E508(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (0003E5BC) --------------------------------------------------------
int __fastcall sub_3E5BC(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (0003E5C8) --------------------------------------------------------
char *__fastcall sub_3E5C8(const char *a1, _DWORD *a2)
{
  int v2; // s0
  int *v5; // r5
  _BYTE *v6; // r3
  char *result; // r0
  _BYTE *v8; // [sp+4h] [bp-4h] BYREF

  v5 = _errno_location();
  *v5 = 0;
  strtof(a1, &v8);
  v6 = v8;
  *a2 = v2;
  if ( *v6 || !*a1 )
    return sub_3E49C("'%s' is not a number", a1);
  result = (char *)*v5;
  if ( *v5 )
    return sub_3E49C("'%s' is out of range", a1);
  return result;
}
// 3E5F8: variable 'v2' is possibly undefined
// 12914: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (0003E650) --------------------------------------------------------
char *__fastcall sub_3E650(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return sub_3E49C("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return sub_3E49C("'%s' is out of range", a1);
  return result;
}

//----- (0003E6D8) --------------------------------------------------------
char *__fastcall sub_3E6D8(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  result = sub_3E650(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (0003E7A0) --------------------------------------------------------
int __fastcall sub_3E7A0(_DWORD *a1)
{
  ++*a1;
  return 0;
}

//----- (0003E7B8) --------------------------------------------------------
void __fastcall __noreturn sub_3E7B8(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// 68594: using guessed type int stdout;

//----- (0003E7D8) --------------------------------------------------------
void __fastcall __noreturn sub_3E7D8(int a1)
{
  const char *v1; // r0

  v1 = (const char *)sub_3F558(dword_762F8, a1);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 3F558: using guessed type int __fastcall sub_3F558(_DWORD, _DWORD);
// 68594: using guessed type int stdout;
// 762F8: using guessed type int dword_762F8;

//----- (0003E818) --------------------------------------------------------
char *__fastcall sub_3E818(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( !v2 )
    v3 = "false";
  return strncpy(a1, v3, 0x50u);
}

//----- (0003E83C) --------------------------------------------------------
char *__fastcall sub_3E83C(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( !v2 )
    v3 = "true";
  return strncpy(a1, v3, 0x50u);
}

//----- (0003E860) --------------------------------------------------------
char *__fastcall sub_3E860(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  bool v5; // cc
  size_t v6; // r5
  char *v7; // r0
  const char *v8; // r1
  _BYTE *v9; // r4
  char *result; // r0

  v4 = strlen(*a2);
  v5 = v4 > 0x4E;
  v6 = v4;
  *a1 = 34;
  v7 = a1 + 1;
  v8 = *a2;
  if ( v5 )
  {
    result = strncpy(v7, v8, 0x4Eu);
    a1[79] = 34;
  }
  else
  {
    v9 = &a1[v6];
    result = strncpy(v7, v8, v6);
    v9[1] = 34;
    if ( v6 != 78 )
      v9[2] = 0;
  }
  return result;
}

//----- (0003E8C0) --------------------------------------------------------
int __fastcall sub_3E8C0(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%i", *a2);
}

//----- (0003E8D4) --------------------------------------------------------
int __fastcall sub_3E8D4(char *a1, float *a2)
{
  return snprintf(a1, 0x50u, "%.1f", *a2);
}

//----- (0003E900) --------------------------------------------------------
int __fastcall sub_3E900(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%u", *a2);
}

//----- (0003E914) --------------------------------------------------------
int __fastcall sub_3E914(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%li", *a2);
}

//----- (0003E928) --------------------------------------------------------
int __fastcall sub_3E928(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%lu", *a2);
}

//----- (0003E93C) --------------------------------------------------------
const char *__fastcall sub_3E93C(unsigned int *a1, size_t *a2)
{
  _DWORD *v2; // r12
  const char *v3; // r4
  int v5; // r4
  unsigned int v6; // lr

  *a1 = 0;
  if ( !dword_762EC )
    return 0;
  v2 = (_DWORD *)dword_762F4;
  if ( *(_DWORD *)(dword_762F4 + 4) == 8 )
  {
    v5 = 28;
    v6 = 1;
    do
    {
      *a1 = v6;
      if ( dword_762EC <= v6++ )
        return 0;
      v2 = (_DWORD *)(dword_762F4 + v5);
      v5 += 28;
    }
    while ( v2[1] == 8 );
  }
  v3 = (const char *)(*v2 + 1);
  *a2 = strcspn(v3, "|= ");
  return v3;
}
// 762EC: using guessed type int dword_762EC;
// 762F4: using guessed type int dword_762F4;

//----- (0003E9DC) --------------------------------------------------------
int __fastcall sub_3E9DC(int a1, size_t *a2)
{
  int v2; // r3
  size_t v3; // r0
  bool v4; // zf
  int v5; // r4

  v2 = *(unsigned __int8 *)(a1 + *a2);
  v3 = a1 + *a2;
  v4 = (v2 & 0xDF) == 0;
  if ( (v2 & 0xDF) != 0 )
    v4 = v2 == 61;
  if ( v4 )
    return 0;
  v5 = v3 + 2;
  *a2 = strcspn((const char *)(v3 + 2), "|= ");
  return v5;
}

//----- (0003EA24) --------------------------------------------------------
int __fastcall sub_3EA24(int a1, unsigned int *a2, size_t *a3)
{
  unsigned int v3; // r3
  _DWORD *v7; // r2
  int result; // r0
  const char *v9; // r4

  v3 = *a2;
  if ( *a2 >= dword_762EC )
    return 0;
  while ( 1 )
  {
    v7 = (_DWORD *)(dword_762F4 + 28 * v3);
    if ( v7[1] != 8 )
      break;
LABEL_6:
    *a2 = ++v3;
    if ( v3 >= dword_762EC )
      return 0;
  }
  if ( a1 )
  {
    result = sub_3E9DC(a1, a3);
    a1 = result;
    if ( result )
      return result;
    v3 = *a2;
    goto LABEL_6;
  }
  v9 = (const char *)(*v7 + 1);
  *a3 = strcspn(v9, "|= ");
  return (int)v9;
}
// 762EC: using guessed type int dword_762EC;
// 762F4: using guessed type int dword_762F4;

//----- (0003EADC) --------------------------------------------------------
int __fastcall sub_3EADC(const char **a1)
{
  __int64 v1; // r2
  bool v2; // cc
  _BYTE *v4; // r4
  int v5; // r0
  const char *v6; // r12
  unsigned int v7; // r3
  int v8; // r3
  bool v9; // zf
  int result; // r0
  int status; // [sp+Ch] [bp-4h] BYREF

  v1 = *(_QWORD *)a1;
  v2 = (unsigned int)a1[1] > 4;
  if ( a1[1] != (const char *)4 )
    v2 = (unsigned int)(a1[1] - 1) > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", (const char *)v1, HIDWORD(v1));
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", (const char *)v1);
  if ( *(_BYTE *)v1 != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)v1);
  v4 = (_BYTE *)(v1 + 1);
  v5 = strcspn((const char *)(v1 + 1), "|= ");
  for ( status = v5; ; v5 = status )
  {
    if ( *v4 == 45 )
    {
      if ( v5 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v6 = a1[1];
      ++dword_762E4;
    }
    else
    {
      if ( v5 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v5 + 1, v4 - 1);
      v6 = a1[1];
      v7 = (unsigned int)(v6 - 2) & 0xFFFFFFFD;
      if ( !v7 )
        v7 = dword_762F0;
      ++dword_762E8;
      if ( ((unsigned int)(v6 - 2) & 0xFFFFFFFD) == 0 )
        dword_762F0 = v7 + 1;
    }
    if ( v6 == (const char *)1 )
    {
      v8 = (unsigned __int8)v4[v5];
      v9 = v8 == 61;
      if ( v8 != 61 )
        v9 = v8 == 32;
      if ( v9 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, &v4[v5 + 1]);
    }
    result = sub_3E9DC((int)v4, (size_t *)&status);
    v4 = (_BYTE *)result;
    if ( !result )
      break;
  }
  return result;
}
// 762E4: using guessed type int dword_762E4;
// 762E8: using guessed type int dword_762E8;
// 762F0: using guessed type int dword_762F0;

//----- (0003EC50) --------------------------------------------------------
int __fastcall sub_3EC50(int *a1)
{
  char *v2; // r0
  int v3; // r3
  int *v4; // lr
  char *v5; // r12
  int v6; // r4
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  char *v11; // r12
  int result; // r0
  int v13; // r1
  int v14; // r2

  v2 = (char *)realloc((void *)dword_762F4, 28 * (dword_762EC + 1));
  v3 = dword_762EC;
  v4 = a1;
  v5 = v2;
  dword_762F4 = (int)v2;
  ++dword_762EC;
  v6 = 7 * v3;
  v7 = *v4;
  v8 = v4[1];
  v9 = v4[2];
  v10 = v4[3];
  v4 += 4;
  v11 = &v5[4 * v6];
  *(_DWORD *)v11 = v7;
  *((_DWORD *)v11 + 1) = v8;
  *((_DWORD *)v11 + 2) = v9;
  *((_DWORD *)v11 + 3) = v10;
  v11 += 16;
  result = *v4;
  v13 = v4[1];
  v14 = v4[2];
  *(_DWORD *)v11 = *v4;
  *((_DWORD *)v11 + 1) = v13;
  *((_DWORD *)v11 + 2) = v14;
  return result;
}
// 762EC: using guessed type int dword_762EC;
// 762F4: using guessed type int dword_762F4;

//----- (0003ECB4) --------------------------------------------------------
const char *__fastcall sub_3ECB4(unsigned int *a1, size_t *a2)
{
  const char *v4; // r0

  v4 = sub_3E93C(a1, a2);
  if ( !v4 )
    return 0;
  while ( *v4 != 45 )
  {
    v4 = (const char *)sub_3EA24((int)v4, a1, a2);
    if ( !v4 )
      return 0;
  }
  --*a2;
  return v4 + 1;
}

//----- (0003ED0C) --------------------------------------------------------
_BYTE *__fastcall sub_3ED0C(int a1, unsigned int *a2, size_t *a3)
{
  _BYTE *v5; // r0

  v5 = (_BYTE *)sub_3EA24(a1, a2, a3);
  if ( !v5 )
    return 0;
  while ( *v5 != 45 )
  {
    v5 = (_BYTE *)sub_3EA24((int)v5, a2, a3);
    if ( !v5 )
      return 0;
  }
  --*a3;
  return v5 + 1;
}

//----- (0003ED64) --------------------------------------------------------
const char *__fastcall sub_3ED64(unsigned int *a1)
{
  const char *result; // r0
  size_t v3; // [sp+4h] [bp-8h] BYREF

  v3 = 0;
  result = sub_3E93C(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (const char *)sub_3EA24((int)result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0003EDC4) --------------------------------------------------------
_BYTE *__fastcall sub_3EDC4(int a1, unsigned int *a2)
{
  _BYTE *result; // r0
  size_t v4; // [sp+4h] [bp-8h] BYREF

  v4 = 1;
  result = (_BYTE *)sub_3EA24(a1, a2, &v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = (_BYTE *)sub_3EA24((int)result, a2, &v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0003EE24) --------------------------------------------------------
int __fastcall sub_3EE24(
        const char *a1,
        const char *a2,
        const char *a3,
        const char *a4,
        const char *a5,
        const char *a6,
        const char *a7)
{
  const char *v8[8]; // [sp+4h] [bp-20h] BYREF

  v8[1] = a2;
  v8[0] = a1;
  v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  v8[5] = a6;
  v8[6] = a7;
  sub_3EADC(v8);
  return sub_3EC50((int *)v8);
}

//----- (0003EE68) --------------------------------------------------------
int __fastcall sub_3EE68(int result, int a2)
{
  const char **v3; // r4
  int v4; // r6
  const char *v5; // r3
  int v6[8]; // [sp+4h] [bp-20h] BYREF

  v3 = (const char **)result;
  v4 = dword_762EC;
  if ( a2 )
  {
    v6[0] = 0;
    memset(&v6[2], 0, 16);
    v6[6] = a2;
    v6[1] = 8;
    sub_3EC50(v6);
    v5 = v3[1];
    if ( v5 == (const char *)16 )
    {
LABEL_7:
      result = 7 * v4;
      *(_DWORD *)(dword_762F4 + 28 * v4 + 20) = dword_762EC - v4;
      return result;
    }
  }
  else
  {
    v5 = *(const char **)(result + 4);
    if ( v5 == (const char *)16 )
      return result;
  }
  do
  {
    if ( v5 == (const char *)8 )
    {
      result = sub_3EE68(*v3, v3[6]);
    }
    else
    {
      sub_3EADC(v3);
      result = sub_3EC50((int *)v3);
    }
    v3 += 7;
    v5 = v3[1];
  }
  while ( v5 != (const char *)16 );
  if ( a2 )
    goto LABEL_7;
  return result;
}
// 762EC: using guessed type int dword_762EC;
// 762F4: using guessed type int dword_762F4;

//----- (0003EF3C) --------------------------------------------------------
bool __fastcall sub_3EF3C(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  int v6; // r0
  int v8; // [sp+4h] [bp-8h] BYREF

  dword_762F8 = (int)*a2;
  v8 = 0;
  do
    v6 = sub_3F0A8(a1, a2, &v8, a3);
  while ( v6 == 1 );
  return v6 == 0;
}
// 762F8: using guessed type int dword_762F8;

//----- (0003EF98) --------------------------------------------------------
void sub_3EF98()
{
  free((void *)dword_762F4);
  dword_762F4 = 0;
}
// 762F4: using guessed type int dword_762F4;

//----- (0003EFB8) --------------------------------------------------------
int sub_3EFB8(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  return fputc(10, (FILE *)stderr);
}
// 68598: using guessed type int stderr;

//----- (0003F000) --------------------------------------------------------
void __noreturn sub_3F000(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 68598: using guessed type int stderr;

//----- (0003F040) --------------------------------------------------------
char *__fastcall sub_3F040(const char *a1)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", a1);
  return v3;
}

//----- (0003F070) --------------------------------------------------------
void *__fastcall sub_3F070(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(a2 + 4 * a3), (const void *)(a2 + 4 * a3 + 4), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (0003F0A8) --------------------------------------------------------
int __fastcall sub_3F0A8(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  bool v8; // zf
  int result; // r0
  const char **v10; // r6
  int *v11; // r3
  int v12; // r4
  int v13; // t1
  unsigned __int8 *v14; // r0
  int v15; // lr
  unsigned int v16; // r12
  int v17; // r1
  int v18; // r3
  char *v19; // r10
  int v20; // r3
  int v21; // r1
  char *v22; // r11
  int v23; // r10
  const char *v24; // r0
  int *v25; // r3
  const char *v26; // r7
  int *v27; // r11
  const char *v28; // r10
  size_t v29; // r4
  size_t v30; // lr
  int *v31; // r3
  const char *v32; // r11
  size_t v33; // r0
  int *v34; // r2
  const char *v35; // r11
  const char *v36; // r3
  size_t v37; // r10
  const char *v38; // [sp+8h] [bp-14h]
  int v39; // [sp+Ch] [bp-10h]
  unsigned int v40; // [sp+10h] [bp-Ch] BYREF
  size_t n[2]; // [sp+14h] [bp-8h] BYREF

  v8 = getenv("POSIXLY_CORRECT") == 0;
  result = (int)a2[1];
  if ( !v8 )
  {
    v10 = a2 + 1;
    if ( !result )
      return result;
    if ( *(_BYTE *)result != 45 )
      return 0;
    v12 = 1;
    if ( *(_BYTE *)(result + 1) == 45 )
      goto LABEL_23;
LABEL_15:
    v14 = (unsigned __int8 *)sub_3ED64(&v40);
    if ( v14 )
    {
      v15 = *a3 + 1;
      if ( *v14 == (unsigned __int8)(*v10)[v15] )
      {
LABEL_17:
        v16 = v40;
        v38 = (const char *)(v14 - 1);
        *a3 = v15;
        n[0] = 2;
        v17 = 28 * v16;
        v18 = dword_762F4 + 28 * v16;
        if ( *(_DWORD *)(v18 + 4) != 1 )
        {
LABEL_18:
          if ( v15 )
          {
            v19 = (char *)&(*v10)[v15 + 1];
            if ( *v19 )
            {
              *a3 = 0;
              goto LABEL_20;
            }
          }
          v19 = (char *)a2[v12 + 1];
          if ( v19 )
            goto LABEL_20;
          a4("%s: %.*s: %s", *a2, n[0], v38, "requires an argument");
          return -1;
        }
LABEL_37:
        v19 = 0;
        v22 = (char *)(*(int (__fastcall **)(_DWORD))(v18 + 8))(*(_DWORD *)(v18 + 20));
        goto LABEL_38;
      }
      while ( 1 )
      {
        v14 = sub_3EDC4((int)v14, &v40);
        if ( !v14 )
          break;
        v15 = *a3 + 1;
        if ( (unsigned __int8)(*v10)[v15] == *v14 )
          goto LABEL_17;
      }
    }
LABEL_36:
    v33 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v33, *v10, "unrecognized option");
    return -1;
  }
  if ( !result )
    return result;
  if ( *(_BYTE *)result == 45 )
  {
    v10 = a2 + 1;
    v12 = 1;
  }
  else
  {
    v11 = (int *)(a2 + 2);
    v12 = 1;
    do
    {
      v10 = (const char **)v11;
      v13 = *v11++;
      result = v13;
      ++v12;
      if ( !v13 )
        return result;
    }
    while ( *(_BYTE *)result != 45 );
  }
  if ( *(_BYTE *)(result + 1) != 45 )
    goto LABEL_15;
LABEL_23:
  v23 = *(unsigned __int8 *)(result + 2);
  if ( !*(_BYTE *)(result + 2) )
  {
    sub_3F070(a1, (int)a2, v12);
    return v23;
  }
  if ( *a3 )
    _assert_fail("*offset == 0", "ccan/opt/parse.c", 0x3Bu, "parse_one");
  v24 = sub_3ECB4(&v40, n);
  if ( !v24 )
    goto LABEL_36;
  v25 = a3;
  v26 = v24;
  v27 = v25;
  v39 = v12;
  while ( 1 )
  {
    v28 = *v10;
    v29 = n[0];
    if ( strncmp(*v10 + 2, v26, n[0]) )
      goto LABEL_35;
    v30 = v29 + 2;
    if ( v28[v29 + 2] == 61 )
      break;
    if ( !v28[v29 + 2] )
    {
      v16 = v40;
      v31 = v27;
      v32 = v26;
      a3 = v31;
      v12 = v39;
      v38 = v32 - 2;
      v17 = 28 * v40;
      n[0] = v30;
      v18 = dword_762F4 + 28 * v40;
      if ( *(_DWORD *)(v18 + 4) == 1 )
        goto LABEL_37;
      goto LABEL_34;
    }
LABEL_35:
    v26 = sub_3ED0C((int)v26, &v40, n);
    if ( !v26 )
      goto LABEL_36;
  }
  v16 = v40;
  v34 = v27;
  v35 = v26;
  a3 = v34;
  v36 = v28;
  v37 = v29 + 3;
  v12 = v39;
  v17 = 28 * v40;
  v19 = (char *)&v36[v37];
  n[0] = v30;
  v38 = v35 - 2;
  v18 = dword_762F4 + 28 * v40;
  if ( *(_DWORD *)(v18 + 4) == 1 )
  {
    if ( v19 )
    {
      a4("%s: %.*s: %s", *a2, v30, v38, "doesn't allow an argument");
      return -1;
    }
    goto LABEL_37;
  }
  if ( !v19 )
  {
LABEL_34:
    v15 = *a3;
    goto LABEL_18;
  }
LABEL_20:
  v20 = dword_762F4;
  v21 = dword_762F4 + v17;
  if ( *(_DWORD *)(v21 + 4) == 4 )
  {
    sub_3E5BC((int)v19, *(_DWORD **)(v21 + 20));
    v16 = v40;
    v20 = dword_762F4;
  }
  v22 = (char *)(*(int (__fastcall **)(char *, _DWORD))(v20 + 28 * v16 + 12))(v19, *(_DWORD *)(v20 + 28 * v16 + 20));
LABEL_38:
  if ( v22 )
  {
    a4("%s: %.*s: %s", *a2, n[0], v38, v22);
    free(v22);
    return -1;
  }
  else
  {
    if ( *a3 )
    {
      if ( !(*v10)[*a3 + 1] )
      {
        *a3 = 0;
        goto LABEL_42;
      }
    }
    else
    {
LABEL_42:
      sub_3F070(a1, (int)a2, v12);
      if ( v19 )
      {
        if ( *v10 == v19 )
          sub_3F070(a1, (int)a2, v12);
      }
    }
    return 1;
  }
}
// 762F4: using guessed type int dword_762F4;

//----- (0003F558) --------------------------------------------------------
char *__fastcall sub_3F558(const char *a1, const char *a2)
{
  size_t v3; // r7
  int v4; // r4
  unsigned int v5; // r8
  size_t v6; // r7
  size_t v7; // r0
  size_t v8; // r7
  size_t v9; // r5
  const char *v10; // r11
  char *v11; // r0
  char *v12; // r4
  int v13; // r0
  char *v14; // r1
  char *v15; // r4
  char *v16; // r7
  char *v17; // r12
  int v18; // r8
  int v19; // r0
  int v20; // r2
  char *v21; // r5
  int v22; // r7
  unsigned int v23; // r8
  int v24; // r2
  unsigned int v25; // r4
  unsigned int v26; // r4
  char *v27; // r3
  int v28; // r3
  const char *v29; // r2
  int v30; // r0
  unsigned int v31; // r4
  char *v32; // r3
  char *v33; // r0
  char *v34; // r0
  int v36; // r2
  int v37; // r3
  __int16 *v39; // [sp+0h] [bp-74h]
  const char *v40; // [sp+4h] [bp-70h]
  char *s; // [sp+8h] [bp-6Ch]
  char *v42; // [sp+10h] [bp-64h]
  char *v43; // [sp+14h] [bp-60h]
  unsigned int v44[22]; // [sp+1Ch] [bp-58h] BYREF

  v3 = dword_762E8 + 20 + strlen(a1);
  if ( a2 )
  {
    v3 += strlen(a2);
    if ( !dword_762EC )
      goto LABEL_13;
    v4 = dword_762F4;
  }
  else
  {
    if ( !dword_762EC )
    {
      a2 = "";
      goto LABEL_13;
    }
    v36 = 0;
    v4 = dword_762F4;
    v37 = dword_762F4;
    do
    {
      ++v36;
      if ( *(void (__fastcall __noreturn **)(int))(v37 + 8) == sub_3E7D8 )
      {
        a2 = *(const char **)(v37 + 20);
        if ( a2 )
        {
          v3 += strlen(*(const char **)(v37 + 20));
          goto LABEL_4;
        }
      }
      v37 += 28;
    }
    while ( v36 != dword_762EC );
    a2 = "";
  }
LABEL_4:
  v5 = 0;
  v40 = a2;
  do
  {
    while ( 1 )
    {
      v9 = v3 + 6;
      v10 = *(const char **)(v4 + 24);
      if ( *(_DWORD *)(v4 + 4) != 8 )
        break;
      ++v5;
      v3 += strlen(*(const char **)(v4 + 24)) + 3;
      v4 += 28;
      if ( v5 >= dword_762EC )
        goto LABEL_12;
    }
    if ( v10 != (const char *)&unk_762FC )
    {
      v6 = strlen(*(const char **)v4);
      v7 = v6 + v9 + strlen(v10);
      v8 = v7 + 118;
      if ( !*(_DWORD *)(v4 + 16) )
        v8 = v7 + 21;
      v3 = v8 + 1;
    }
    ++v5;
    v4 += 28;
  }
  while ( v5 < dword_762EC );
LABEL_12:
  a2 = v40;
LABEL_13:
  v11 = (char *)malloc(v3);
  v12 = v11;
  v43 = v11;
  if ( v11 )
  {
    v13 = sprintf(v11, "Usage: %s", a1);
    v14 = v12;
    v15 = &v12[v13];
    v16 = v15 + 3;
    strcpy(&v14[v13], " [-");
    v17 = (char *)sub_3ED64(v44);
    if ( v17 )
    {
      v18 = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_762F4 + 28 * v44[0] + 24) != &unk_762FC )
          v16[v18++] = *v17;
        v17 = sub_3EDC4((int)v17, v44);
      }
      while ( v17 );
      if ( v18 )
      {
        v15 = &v16[v18 + 1];
        *(_WORD *)&v16[v18] = 93;
      }
    }
    v19 = sprintf(v15, " %s", a2);
    v20 = dword_762EC;
    v39 = &word_4C1E4;
    v21 = &v15[v19 + 1];
    *(_WORD *)&v15[v19] = 10;
    if ( v20 )
    {
      v22 = 0;
      v23 = 0;
      do
      {
        v28 = dword_762F4 + v22;
        v29 = *(const char **)(dword_762F4 + v22 + 24);
        if ( v29 != (const char *)&unk_762FC )
        {
          if ( *(_DWORD *)(v28 + 4) == 8 )
          {
            v21 += sprintf(v21, "%s:\n", v29);
          }
          else
          {
            v30 = sprintf(v21, "%s", *(const char **)v28);
            v31 = v30;
            v32 = &v21[v30];
            if ( *(_DWORD *)(dword_762F4 + v22 + 4) == 2 )
            {
              v42 = &v21[v30];
              s = *(char **)(dword_762F4 + v22);
              v33 = strchr(s, 32);
              v32 = v42;
              if ( !v33 )
              {
                v34 = strchr(s, 61);
                v32 = v42;
                if ( !v34 )
                {
                  v31 += 6;
                  strcpy(v42, " <arg>");
                  v32 = &v21[v31];
                }
              }
            }
            if ( v31 > 0x13 )
              v24 = 1;
            else
              v24 = 20 - v31;
            v25 = sprintf(v32, "%.*s", v24, "                    ", v39) + v31;
            v26 = sprintf(&v21[v25], "%s", *(const char **)(dword_762F4 + v22 + 24)) + v25;
            v27 = &v21[v26];
            if ( *(_DWORD *)(dword_762F4 + v22 + 16) )
            {
              v44[20] = 3026478;
              (*(void (__fastcall **)(unsigned int *, _DWORD))(dword_762F4 + v22 + 16))(
                v44,
                *(_DWORD *)(dword_762F4 + v22 + 20));
              v27 = &v21[sprintf(&v21[v26], " (default: %s)", (const char *)v44) + v26];
            }
            *(_WORD *)v27 = *v39;
            v21 = v27 + 1;
          }
        }
        ++v23;
        v22 += 28;
      }
      while ( dword_762EC > v23 );
    }
    *v21 = 0;
  }
  return v43;
}
// 3F784: variable 'v39' is possibly undefined
// 4C1E4: using guessed type __int16 word_4C1E4;
// 563F8: using guessed type __int16 word_563F8;
// 762E8: using guessed type int dword_762E8;
// 762EC: using guessed type int dword_762EC;
// 762F4: using guessed type int dword_762F4;

//----- (0003F99C) --------------------------------------------------------
char *__fastcall sub_3F99C(char *result, __int16 a2, unsigned int a3)
{
  _DWORD *v3; // r3
  bool v4; // zf
  int v5; // r4
  char *v6; // r12
  char *v7; // r2
  char *v8; // r3

  if ( !a3 )
    return 0;
  if ( ((unsigned __int8)result & 3) != 0 )
  {
    if ( (unsigned __int8)*result == (unsigned __int8)a2 )
      return result;
    v3 = result + 1;
    while ( 1 )
    {
      --a3;
      result = (char *)v3;
      if ( !a3 )
        return 0;
      v4 = ((unsigned __int8)v3 & 3) == 0;
      v3 = (_DWORD *)((char *)v3 + 1);
      if ( v4 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
  }
  v5 = (unsigned __int16)(a2 << 8) | (unsigned __int8)a2 | (((unsigned __int16)(a2 << 8) | (unsigned __int8)a2) << 16);
  if ( a3 > 3 && (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) == 0 )
  {
    v6 = result + 4;
    while ( 1 )
    {
      a3 -= 4;
      result = v6;
      v6 += 4;
      if ( a3 <= 3 )
        break;
      if ( (((*(_DWORD *)result ^ v5) - 16843009) & ~(*(_DWORD *)result ^ v5) & 0x80808080) != 0 )
        goto LABEL_16;
    }
    if ( !a3 )
      return 0;
  }
LABEL_16:
  if ( (unsigned __int8)*result != (unsigned __int8)a2 )
  {
    v7 = &result[a3];
    v8 = result + 1;
    while ( 1 )
    {
      result = v8++;
      if ( result == v7 )
        break;
      if ( (unsigned __int8)*result == (unsigned __int8)a2 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (0003FAB0) --------------------------------------------------------
unsigned int __fastcall sub_3FAB0(int a1, unsigned int a2, int *a3)
{
  int v3; // r6
  int v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // r5
  unsigned int v10; // r7
  int v11; // r8
  unsigned int v12; // r4
  int v13; // r12
  int v14; // r5
  unsigned int v15; // r3
  int v16; // r6
  unsigned int v17; // r6
  unsigned int v18; // r7
  unsigned int result; // r0
  unsigned int v20; // r5
  bool v21; // zf

  v3 = 1;
  v4 = 1;
  v5 = 0;
  v6 = -1;
  while ( 1 )
  {
    v7 = v4 + v5;
    v8 = a1 + v6;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v4);
      v10 = *(unsigned __int8 *)(a1 + v7);
      if ( v10 >= v9 )
        break;
      v5 = v7;
      v4 = 1;
      v3 = v7 - v6;
      ++v7;
      v8 = a1 + v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( v10 == v9 )
    {
      v21 = v4++ == v3;
      if ( v21 )
      {
        v5 = v7;
        v4 = 1;
      }
    }
    else
    {
      v3 = 1;
      v6 = v5;
      v4 = 1;
      ++v5;
    }
  }
LABEL_5:
  v11 = 1;
  v12 = 0;
  v13 = 1;
  v14 = -1;
  *a3 = v3;
  while ( 1 )
  {
    v15 = v13 + v12;
    v16 = a1 + v14;
    if ( a2 <= v13 + v12 )
      break;
    while ( 1 )
    {
      v17 = *(unsigned __int8 *)(v16 + v13);
      v18 = *(unsigned __int8 *)(a1 + v15);
      if ( v18 <= v17 )
        break;
      v12 = v15;
      v13 = 1;
      v11 = v15 - v14;
      ++v15;
      v16 = a1 + v14;
      if ( a2 <= v15 )
        goto LABEL_9;
    }
    if ( v18 == v17 )
    {
      v21 = v13++ == v11;
      if ( v21 )
      {
        v12 = v15;
        v13 = 1;
      }
    }
    else
    {
      v11 = 1;
      v14 = v12;
      v13 = 1;
      ++v12;
    }
  }
LABEL_9:
  result = v6 + 1;
  v20 = v14 + 1;
  if ( v20 >= v6 + 1 )
  {
    *a3 = v11;
    return v20;
  }
  return result;
}

//----- (0003FBC0) --------------------------------------------------------
int __fastcall sub_3FBC0(int a1, int a2, char *s1, unsigned int a4)
{
  size_t v8; // r4
  size_t v9; // r6
  int *v10; // r3
  char *v11; // r1
  int v12; // r3
  int v13; // t1
  unsigned int v14; // r0
  unsigned int v15; // r3
  bool v16; // cf
  unsigned int v17; // r1
  unsigned int v18; // r1
  char *v19; // lr
  unsigned __int8 *v20; // r12
  int v21; // r9
  int v22; // t1
  int v23; // t1
  unsigned int v24; // lr
  unsigned __int8 *v25; // r1
  char *v26; // r8
  int v27; // r10
  int v28; // t1
  int v29; // t1
  int result; // r0
  size_t v31; // r3
  size_t v32; // r2
  unsigned int v33; // r10
  unsigned int v34; // r9
  int v35; // r3
  unsigned __int8 *v36; // r1
  size_t v37; // r3
  char *v38; // r12
  int v39; // r8
  int v40; // t1
  int v41; // t1
  unsigned __int8 *v42; // r3
  char *v43; // r1
  int v44; // lr
  int v45; // t1
  int v46; // t1
  unsigned int v47; // [sp+0h] [bp-424h]
  unsigned int v48; // [sp+4h] [bp-420h]
  int v49; // [sp+4h] [bp-420h]
  unsigned int v50; // [sp+Ch] [bp-418h]
  int v51[253]; // [sp+1Ch] [bp-408h] BYREF
  int v52; // [sp+41Ch] [bp-8h] BYREF

  v8 = a4 - 1;
  if ( a4 > 2 )
  {
    v9 = sub_3FAB0((int)s1, a4, v51);
    v48 = v51[0];
  }
  else
  {
    v9 = a4 - 1;
    v48 = 1;
    v51[0] = 1;
  }
  v10 = v51;
  do
  {
    v10[1] = a4;
    ++v10;
  }
  while ( v10 != &v52 );
  if ( a4 )
  {
    v11 = s1 - 1;
    v12 = v8;
    do
    {
      v13 = (unsigned __int8)*++v11;
      v51[v13 + 1] = v12;
      v16 = v12-- != 0;
    }
    while ( v16 );
  }
  v14 = memcmp(s1, &s1[v48], v9);
  if ( !v14 )
  {
    v47 = a2 - a4;
    v50 = a4 - v48;
    v15 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = v51[*(unsigned __int8 *)(a1 + v15 + v8) + 1];
        if ( v17 )
        {
          v16 = 1;
          if ( v14 )
            v16 = v17 >= v48;
          v14 = 0;
          if ( !v16 )
            v17 = v50;
          v15 += v17;
          goto LABEL_15;
        }
        v18 = v9 < v14 ? v14 : v9;
        if ( v18 < v8 )
          break;
LABEL_25:
        v24 = v9 - 1;
        if ( v9 > v14 && (v25 = (unsigned __int8 *)(a1 + v9 - 1 + v15), (unsigned __int8)s1[v9 - 1] == *v25) )
        {
          v26 = &s1[v9 - 1];
          while ( v24 - 1 != v14 - 1 )
          {
            v28 = (unsigned __int8)*--v26;
            v27 = v28;
            v29 = *--v25;
            if ( v27 != v29 )
              break;
            --v24;
          }
        }
        else
        {
          v24 = v9;
        }
        if ( v14 + 1 > v24 )
          return a1 + v15;
        v14 = v50;
        v15 += v48;
        if ( v47 < v15 )
          return 0;
      }
      v19 = &s1[v18];
      v20 = (unsigned __int8 *)(a1 + v18 + v15);
      if ( *v20 == (unsigned __int8)s1[v18] )
      {
        while ( ++v18 < v8 )
        {
          v22 = (unsigned __int8)*++v19;
          v21 = v22;
          v23 = *++v20;
          if ( v21 != v23 )
            goto LABEL_35;
        }
        goto LABEL_25;
      }
LABEL_35:
      v14 = 0;
      v15 += v18 + 1 - v9;
LABEL_15:
      if ( v47 < v15 )
        return 0;
    }
  }
  v31 = a4 - v9;
  v32 = v9 - 1;
  v33 = a2 - a4;
  if ( a4 - v9 < v9 )
    v31 = v9;
  v34 = 0;
  v49 = v31 + 1;
  while ( 1 )
  {
    result = a1 + v34;
    v35 = v51[*(unsigned __int8 *)(a1 + v34 + v8) + 1];
    if ( !v35 )
      break;
LABEL_52:
    v34 += v35;
LABEL_53:
    if ( v34 > v33 )
      return 0;
  }
  if ( v9 < v8 )
  {
    v36 = (unsigned __int8 *)(a1 + v9 + v34);
    if ( *v36 != (unsigned __int8)s1[v9] )
    {
      v37 = v9;
LABEL_55:
      v34 += v37 + 1 - v9;
      goto LABEL_53;
    }
    v38 = &s1[v9];
    v37 = v9;
    while ( ++v37 < v8 )
    {
      v40 = (unsigned __int8)*++v38;
      v39 = v40;
      v41 = *++v36;
      if ( v39 != v41 )
        goto LABEL_55;
    }
  }
  if ( !v9 )
    return result;
  v42 = (unsigned __int8 *)(a1 + v32 + v34);
  if ( *v42 != (unsigned __int8)s1[v32] )
  {
LABEL_51:
    v35 = v49;
    goto LABEL_52;
  }
  v43 = &s1[v32];
  while ( v43 != s1 )
  {
    v45 = (unsigned __int8)*--v43;
    v44 = v45;
    v46 = *--v42;
    if ( v44 != v46 )
      goto LABEL_51;
  }
  return result;
}

//----- (0003FEEC) --------------------------------------------------------
int __fastcall memmem(char *a1, unsigned int a2, char *a3, unsigned int a4)
{
  char *v6; // r5
  char *v9; // r0
  _BOOL4 v10; // r3
  unsigned int v11; // r7
  size_t v12; // r6
  unsigned int v13; // r0
  unsigned int v14; // r2
  size_t v15; // r12
  size_t v16; // r3
  char *v17; // lr
  char *v18; // r1
  int v19; // r8
  int v20; // t1
  int v21; // t1
  unsigned int v22; // lr
  char *v23; // r3
  char *v24; // r7
  int v25; // r9
  int v26; // t1
  int v27; // t1
  size_t v29; // r3
  size_t v30; // r9
  unsigned int v31; // r0
  unsigned int v32; // r7
  char *v33; // r2
  size_t v34; // r3
  char *v35; // r1
  int v36; // lr
  int v37; // t1
  int v38; // t1
  char *v39; // r3
  char *v40; // r2
  int v41; // r12
  int v42; // t1
  int v43; // t1
  int v44; // [sp+4h] [bp-20h]
  int v45; // [sp+8h] [bp-1Ch]
  int v46; // [sp+1Ch] [bp-8h] BYREF

  if ( !a4 )
    return (int)a1;
  if ( a4 > a2 )
    return 0;
  if ( a4 > 0x1F )
    return sub_3FBC0((int)a1, a2, a3, a4);
  v9 = sub_3F99C(a1, (unsigned __int8)*a3, a2);
  v6 = v9;
  v10 = a4 == 1;
  if ( !v9 )
    v10 = 1;
  if ( v10 )
    return (int)v6;
  v11 = a2 - (v9 - a1);
  if ( a4 > v11 )
    return 0;
  if ( a4 > 2 )
  {
    v12 = sub_3FAB0((int)a3, a4, &v46);
    v45 = v46;
  }
  else
  {
    v12 = a4 - 1;
    v45 = 1;
    v46 = 1;
  }
  v13 = memcmp(a3, &a3[v45], v12);
  if ( !v13 )
  {
    v14 = v11 - a4;
    v15 = 0;
    while ( 1 )
    {
      if ( v12 < v15 )
        v16 = v15;
      else
        v16 = v12;
      if ( a4 > v16 )
      {
        v17 = &a3[v16];
        v18 = &v6[v16 + v13];
        if ( a3[v16] != *v18 )
        {
LABEL_32:
          v15 = 0;
          v13 += 1 - v12 + v16;
          goto LABEL_29;
        }
        while ( a4 != ++v16 )
        {
          v20 = (unsigned __int8)*++v17;
          v19 = v20;
          v21 = (unsigned __int8)*++v18;
          if ( v19 != v21 )
            goto LABEL_32;
        }
      }
      v22 = v12 - 1;
      if ( v12 > v15 && (v23 = &v6[v12 - 1 + v13], a3[v12 - 1] == *v23) )
      {
        v24 = &a3[v12 - 1];
        while ( v22 - 1 != v15 - 1 )
        {
          v26 = (unsigned __int8)*--v24;
          v25 = v26;
          v27 = (unsigned __int8)*--v23;
          if ( v25 != v27 )
            break;
          --v22;
        }
      }
      else
      {
        v22 = v12;
      }
      if ( v15 + 1 > v22 )
      {
        v6 += v13;
        return (int)v6;
      }
      v15 = a4 - v45;
      v13 += v45;
LABEL_29:
      if ( v14 < v13 )
        return 0;
    }
  }
  v29 = a4 - v12;
  v30 = v12 - 1;
  v31 = v11 - a4;
  if ( a4 - v12 < v12 )
    v29 = v12;
  v32 = 0;
  v44 = v29 + 1;
  while ( 1 )
  {
    if ( a4 > v12 )
    {
      v33 = &v6[v12 + v32];
      if ( *v33 != a3[v12] )
      {
        v34 = v12;
LABEL_49:
        v32 += 1 - v12 + v34;
        goto LABEL_50;
      }
      v35 = &a3[v12];
      v34 = v12;
      while ( a4 != ++v34 )
      {
        v37 = (unsigned __int8)*++v35;
        v36 = v37;
        v38 = (unsigned __int8)*++v33;
        if ( v36 != v38 )
          goto LABEL_49;
      }
    }
    if ( !v12 )
      return (int)&v6[v32];
    v39 = &v6[v30 + v32];
    if ( *v39 == a3[v30] )
      break;
LABEL_52:
    v32 += v44;
LABEL_50:
    if ( v31 < v32 )
      return 0;
  }
  v40 = &a3[v30];
  while ( v40 != a3 )
  {
    v42 = (unsigned __int8)*--v40;
    v41 = v42;
    v43 = (unsigned __int8)*--v39;
    if ( v41 != v43 )
      goto LABEL_52;
  }
  return (int)&v6[v32];
}

//----- (000401D8) --------------------------------------------------------
void __fastcall sub_401D8(_DWORD *a1)
{
  unsigned int *v1; // r3
  unsigned int v2; // r2
  unsigned int v3; // r2

  v1 = a1 + 1;
  __dmb(0xBu);
  do
  {
    v2 = __ldrex(v1);
    v3 = v2 - 1;
  }
  while ( __strex(v3, v1) );
  if ( !v3 )
    sub_4942C(a1);
}

//----- (00040200) --------------------------------------------------------
int __fastcall sub_40200(unsigned __int8 *a1, int a2)
{
  int v3; // r8
  unsigned int v4; // r7
  size_t v5; // r10
  void *v6; // r0
  void *v7; // r0
  size_t v8; // r9
  unsigned __int8 *v9; // r4
  void *v10; // r0
  void *v11; // r0
  size_t v12; // r10
  void *v13; // r0
  void *v15[112]; // [sp+0h] [bp-9C0h] BYREF
  char s[2048]; // [sp+1C0h] [bp-800h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "got nonce sz %d", a2);
    sub_1DD60(7, s, 0);
  }
  v3 = *a1;
  v4 = *(_DWORD *)(a1 + 1);
  memcpy(v15, a1 + 5, sizeof(v15));
  v5 = a1[453];
  v6 = calloc(1u, v5);
  v7 = memcpy(v6, a1 + 454, v5);
  v8 = a1[v5 + 454];
  v9 = &a1[v5 + 455];
  v15[72] = v7;
  v10 = calloc(1u, v8);
  v11 = memcpy(v10, v9, v8);
  v12 = v9[v8];
  v15[77] = v11;
  v13 = calloc(1u, v12);
  v15[80] = memcpy(v13, &v9[v8 + 1], v12);
  v15[82] = calloc(1u, 1u);
  v15[65] = *(void **)(dword_72F04 + 4 * v3);
  v15[63] = *(void **)dword_73F20;
  v15[64] = **(void ***)dword_73F20;
  if ( sub_2B7E8(*(_DWORD *)dword_73F20, v4) && sub_2B77C((int)v15, v4) )
  {
    sub_3BF78(*(_DWORD *)dword_73F20, (int)v15);
    if ( dword_72DB0 && byte_72E64 )
    {
      sub_2A854((int)v15, v4);
      if ( byte_686E1 )
        goto LABEL_10;
    }
    else if ( byte_686E1 )
    {
LABEL_10:
      if ( byte_72D90 || byte_686E0 || dword_67840 > 6 )
      {
        snprintf(s, 0x800u, "%s nonce submited", "cb_bitmain_submit_nonce");
        sub_1DD60(7, s, 0);
      }
    }
    sub_2A5B8(v15);
    return 0;
  }
  sub_30E60(*(_DWORD *)dword_73F20);
  sub_2A5B8(v15);
  return -1;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;
// 72DB0: using guessed type int dword_72DB0;
// 72E64: using guessed type char byte_72E64;
// 72F04: using guessed type int dword_72F04;
// 73F20: using guessed type int dword_73F20;

//----- (00040484) --------------------------------------------------------
int __fastcall sub_40484(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  result = pthread_mutex_unlock(&stru_76300);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v3,
      "socketa_api.c",
      "cb_bitmain_api_stats",
      a1);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  return result;
}
// 76300: using guessed type pthread_mutex_t stru_76300;

//----- (00040500) --------------------------------------------------------
int __fastcall sub_40500(const char *a1, int a2)
{
  double v2; // d0
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  _DWORD *v7; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  _DWORD *v11; // r0
  unsigned int *v12; // r3
  unsigned int v13; // r2
  int *v14; // r0
  int *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  int *v18; // r0
  const char *v19; // r0
  _DWORD *v20; // r0
  int v21; // r0
  const char *v22; // r0
  int *v23; // r0
  const char *v24; // r0
  _DWORD *v25; // r0
  const char *v26; // r0
  _DWORD *v27; // r0
  const char *v28; // r0
  _DWORD *v29; // r0
  const char *v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  _DWORD *v33; // r7
  char *v34; // r8
  unsigned int v35; // r6
  bool v36; // cc
  unsigned int v37; // r1
  _DWORD *v38; // r0
  char *v39; // r6
  unsigned int v40; // r4
  _DWORD *v41; // r0
  bool v42; // zf
  _DWORD *v43; // r7
  _DWORD *v44; // r0
  _DWORD *v45; // r0
  _DWORD *v46; // r0
  const char *v47; // r0
  _DWORD *v48; // r0
  const char *v49; // r0
  _DWORD *v50; // r0
  _DWORD *v51; // r0
  const char *v52; // r0
  _DWORD *v53; // r0
  _DWORD *v54; // r8
  char *v55; // r9
  unsigned int v56; // r10
  _DWORD *v57; // r0
  bool v58; // zf
  _DWORD *v59; // r0
  const char *v60; // r0
  _DWORD *v61; // r0
  _DWORD *v62; // r0
  _DWORD *v63; // r8
  char *v64; // r9
  unsigned int v65; // r10
  _DWORD *v66; // r0
  bool v67; // zf
  _DWORD *v68; // r0
  _DWORD *v69; // r0
  _DWORD *v70; // r8
  char *v71; // r9
  unsigned int v72; // r10
  _DWORD *v73; // r0
  bool v74; // zf
  _DWORD *v75; // r0
  int v76; // r0
  unsigned int v77; // r8
  _DWORD *v78; // r0
  _DWORD *v79; // r10
  char *i; // r11
  unsigned int v81; // r1
  _DWORD *v82; // r0
  _DWORD *v83; // r0
  int v84; // r0
  _DWORD *v85; // r0
  _DWORD *v86; // r0
  const char *v87; // r0
  _DWORD *v88; // r0
  _DWORD *v89; // r0
  _DWORD *v90; // r0
  _DWORD *v91; // r0
  const char *v92; // r0
  _DWORD *v93; // r0
  _DWORD *v94; // r0
  _DWORD *v95; // r10
  unsigned int v96; // r7
  _DWORD *v97; // r0
  _DWORD *v98; // r9
  unsigned int v99; // r11
  _DWORD *v100; // r0
  int v101; // r0
  int v102; // r2
  const char *v103; // r0
  _DWORD *v104; // r0
  _DWORD *v105; // [sp+10h] [bp-91Ch]
  _DWORD *v106; // [sp+14h] [bp-918h]
  char v107[92]; // [sp+2Ch] [bp-900h] BYREF
  char v108[160]; // [sp+88h] [bp-8A4h] BYREF
  char s[2052]; // [sp+128h] [bp-804h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "%s(%d) : %s", "cb_bitmain_api_stats", a2, a1);
    sub_1DD60(7, s, 0);
  }
  v4 = sub_47C50((int)a1, 0, v107);
  v5 = v4;
  if ( !v4 || *v4 )
  {
    if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
      return -2;
    snprintf(s, 0x800u, "%s: load data is failed(%s)", "cb_bitmain_api_stats", v108);
    sub_1DD60(3, s, 0);
    return -2;
  }
  if ( pthread_mutex_lock(&stru_76300) )
  {
    v14 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v14,
      "socketa_api.c",
      "cb_bitmain_api_stats",
      153);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  memset(&unk_76318, 0, 0x1A10u);
  v7 = (_DWORD *)sub_48AF4(v5, "inited");
  if ( !v7 || *v7 != 3 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    if ( pthread_mutex_unlock(&stru_76300) )
    {
      v15 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v15,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        158);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    off_67964();
    if ( v5[1] == -1 )
      return -3;
    v8 = v5 + 1;
    __dmb(0xBu);
    do
    {
      v9 = __ldrex(v8);
      v10 = v9 - 1;
    }
    while ( __strex(v10, v8) );
    goto LABEL_22;
  }
  dword_76320 = sub_49284((int)v7);
  v11 = (_DWORD *)sub_48AF4(v5, "chain_num");
  if ( !v11 || *v11 != 3 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    if ( pthread_mutex_unlock(&stru_76300) )
    {
      v18 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v18,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        162);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    off_67964();
    if ( v5[1] == -1 )
      return -3;
    v12 = v5 + 1;
    __dmb(0xBu);
    do
    {
      v13 = __ldrex(v12);
      v10 = v13 - 1;
    }
    while ( __strex(v10, v12) );
LABEL_22:
    if ( !v10 )
      sub_4942C(v5);
    return -3;
  }
  dword_7631C = sub_49284((int)v11);
  v16 = (_DWORD *)sub_48AF4(v5, "real_miner_type");
  if ( v16 && *v16 == 2 )
  {
    v22 = (const char *)sub_49028(v16);
    snprintf(&byte_76324, 0x100u, "%s", v22);
  }
  v17 = (_DWORD *)sub_48AF4(v5, "rate_5s");
  if ( !v17 || *v17 != 2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    if ( pthread_mutex_unlock(&stru_76300) )
    {
      v23 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v23,
        "socketa_api.c",
        "cb_bitmain_api_stats",
        172);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
LABEL_51:
    off_67964();
    if ( v5[1] != -1 )
    {
      sub_401D8(v5);
      return -3;
    }
    return -3;
  }
  v19 = (const char *)sub_49028(v17);
  snprintf(byte_76424, 0x10u, "%s", v19);
  v20 = (_DWORD *)sub_48AF4(v5, "rate_30m");
  if ( !v20 || *v20 != 2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 176;
LABEL_61:
    sub_40484(v21);
    goto LABEL_51;
  }
  v24 = (const char *)sub_49028(v20);
  snprintf(byte_76434, 0x10u, "%s", v24);
  v25 = (_DWORD *)sub_48AF4(v5, "rate_avg");
  if ( !v25 || *v25 != 2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 180;
    goto LABEL_61;
  }
  v26 = (const char *)sub_49028(v25);
  snprintf(&byte_76434[16], 0x10u, "%s", v26);
  strncpy(byte_6A6B8, &byte_76434[16], 0x10u);
  v27 = (_DWORD *)sub_48AF4(v5, "rate_ideal");
  if ( !v27 || *v27 != 2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 185;
    goto LABEL_61;
  }
  v28 = (const char *)sub_49028(v27);
  snprintf(byte_76454, 0x10u, "%s", v28);
  v29 = (_DWORD *)sub_48AF4(v5, "rate_unit");
  if ( !v29 || *v29 != 2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 189;
    goto LABEL_61;
  }
  v30 = (const char *)sub_49028(v29);
  snprintf(&byte_76454[16], 8u, "%s", v30);
  v31 = (_DWORD *)sub_48AF4(v5, "fan_num");
  if ( !v31 || *v31 != 3 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 193;
    goto LABEL_61;
  }
  *(_DWORD *)&byte_76454[24] = sub_49284((int)v31);
  v32 = (_DWORD *)sub_48AF4(v5, "fan");
  v33 = v32;
  if ( !v32 || *v32 != 1 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 197;
    goto LABEL_61;
  }
  v34 = &byte_76454[24];
  v35 = 0;
  while ( 1 )
  {
    v36 = (unsigned int)sub_48E60(v33) > v35;
    v37 = v35++;
    if ( !v36 )
      break;
    v38 = sub_48E7C(v33, v37);
    if ( !v38 )
      break;
    if ( *v38 != 3 )
    {
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 199;
      goto LABEL_61;
    }
    *((_DWORD *)v34 + 1) = sub_49284((int)v38);
    v34 += 4;
  }
  v106 = (_DWORD *)sub_48AF4(v5, "chain");
  if ( !v106 || *v106 != 1 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 204;
    goto LABEL_61;
  }
  v39 = &byte_76454[544];
  v105 = v5;
  v40 = 0;
  dword_76060 = 0;
  while ( (unsigned int)sub_48E60(v106) > v40 )
  {
    v41 = sub_48E7C(v106, v40);
    v42 = v41 == 0;
    if ( v41 )
      v42 = v40 == 4;
    v43 = v41;
    if ( v42 )
      break;
    if ( *v41 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 210;
      goto LABEL_61;
    }
    v44 = (_DWORD *)sub_48AF4(v41, "index");
    if ( !v44 || *v44 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 213;
      goto LABEL_61;
    }
    *((_DWORD *)v39 - 125) = sub_49284((int)v44);
    v45 = (_DWORD *)sub_48AF4(v43, "freq_avg");
    if ( !v45 || *v45 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 217;
      goto LABEL_61;
    }
    *((_DWORD *)v39 - 124) = sub_49284((int)v45);
    v46 = (_DWORD *)sub_48AF4(v43, "rate_ideal");
    if ( !v46 || *v46 != 2 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 221;
      goto LABEL_61;
    }
    v47 = (const char *)sub_49028(v46);
    snprintf(v39 - 492, 0x10u, "%s", v47);
    v48 = (_DWORD *)sub_48AF4(v43, "rate_real");
    if ( !v48 || *v48 != 2 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 225;
      goto LABEL_61;
    }
    v49 = (const char *)sub_49028(v48);
    snprintf(v39 - 476, 0x10u, "%s", v49);
    v50 = (_DWORD *)sub_48AF4(v43, "asic_num");
    if ( !v50 || *v50 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 229;
      goto LABEL_61;
    }
    *((_DWORD *)v39 - 115) = sub_49284((int)v50);
    v51 = (_DWORD *)sub_48AF4(v43, "asic");
    if ( !v51 || *v51 != 2 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 233;
      goto LABEL_61;
    }
    v52 = (const char *)sub_49028(v51);
    snprintf(v39 - 456, 0x100u, "%s", v52);
    v53 = (_DWORD *)sub_48AF4(v43, "temp_pic");
    v54 = v53;
    if ( !v53 || *v53 != 1 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 237;
      goto LABEL_61;
    }
    v55 = v39 - 204;
    v56 = 0;
    while ( (unsigned int)sub_48E60(v54) > v56 )
    {
      v57 = sub_48E7C(v54, v56);
      v58 = v57 == 0;
      if ( v57 )
        v58 = v56 == 4;
      ++v56;
      if ( v58 )
        break;
      if ( *v57 != 3 )
      {
        v5 = v105;
        if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
        {
          snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
          sub_1DD60(3, s, 0);
        }
        v21 = 241;
        goto LABEL_61;
      }
      *((_DWORD *)v55 + 1) = sub_49284((int)v57);
      v55 += 4;
    }
    v62 = (_DWORD *)sub_48AF4(v43, "temp_pcb");
    v63 = v62;
    if ( !v62 || *v62 != 1 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 246;
      goto LABEL_61;
    }
    v64 = v39 - 188;
    v65 = 0;
    while ( (unsigned int)sub_48E60(v63) > v65 )
    {
      v66 = sub_48E7C(v63, v65);
      v67 = v66 == 0;
      if ( v66 )
        v67 = v65 == 4;
      ++v65;
      if ( v67 )
        break;
      if ( *v66 != 3 )
      {
        v5 = v105;
        if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
        {
          snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
          sub_1DD60(3, s, 0);
        }
        v21 = 250;
        goto LABEL_61;
      }
      *((_DWORD *)v64 + 1) = sub_49284((int)v66);
      v64 += 4;
    }
    v69 = (_DWORD *)sub_48AF4(v43, "temp_chip");
    v70 = v69;
    if ( !v69 || *v69 != 1 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 255;
      goto LABEL_61;
    }
    v71 = v39 - 172;
    v72 = 0;
    while ( (unsigned int)sub_48E60(v70) > v72 )
    {
      v73 = sub_48E7C(v70, v72);
      v74 = v73 == 0;
      if ( v73 )
        v74 = v72 == 4;
      ++v72;
      if ( v74 )
        break;
      if ( *v73 != 3 )
      {
        v5 = v105;
        if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
        {
          snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
          sub_1DD60(3, s, 0);
        }
        v21 = 259;
        goto LABEL_61;
      }
      *((_DWORD *)v71 + 1) = sub_49284((int)v73);
      v71 += 4;
    }
    v75 = (_DWORD *)sub_48AF4(v43, "hw");
    if ( !v75 || *v75 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 264;
      goto LABEL_61;
    }
    v76 = sub_49284((int)v75);
    *((_DWORD *)v39 - 38) = v76;
    v77 = 0;
    dword_77D1C = 0;
    dword_76060 += v76;
    v78 = (_DWORD *)sub_48AF4(v43, "rate_array");
    v79 = v78;
    if ( !v78 || *v78 != 1 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 270;
      goto LABEL_61;
    }
    for ( i = v39 - 152; ; i += 4 )
    {
      v36 = (unsigned int)sub_48E60(v79) > v77;
      v81 = v77++;
      if ( !v36 )
        break;
      v82 = sub_48E7C(v79, v81);
      if ( !v82 )
        break;
      if ( *v82 != 3 )
      {
        v5 = v105;
        if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
        {
          snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
          sub_1DD60(3, s, 0);
        }
        v21 = 272;
        goto LABEL_61;
      }
      *((_DWORD *)i + 1) = sub_49284((int)v82);
      ++dword_77D1C;
    }
    v83 = (_DWORD *)sub_48AF4(v43, "nonce");
    if ( !v83 || *v83 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 278;
      goto LABEL_61;
    }
    v84 = sub_49284((int)v83);
    *((_DWORD *)v39 - 13) = v84;
    dword_77D18 += v84;
    v85 = (_DWORD *)sub_48AF4(v43, "eeprom");
    if ( !v85 || (unsigned int)(*v85 - 5) > 1 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 283;
      goto LABEL_61;
    }
    *(v39 - 48) = *v85 == 5;
    v86 = (_DWORD *)sub_48AF4(v43, "sn");
    if ( !v86 || *v86 != 2 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 287;
      goto LABEL_61;
    }
    v87 = (const char *)sub_49028(v86);
    snprintf(v39 - 47, 0x20u, "%s", v87);
    v88 = (_DWORD *)sub_48AF4(v43, "eeprom_vol");
    if ( !v88 || *v88 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 291;
      goto LABEL_61;
    }
    *((_DWORD *)v39 - 2) = sub_49284((int)v88);
    v89 = (_DWORD *)sub_48AF4(v43, "eeprom_freq");
    if ( !v89 || *v89 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 295;
      goto LABEL_61;
    }
    *((_DWORD *)v39 - 3) = sub_49284((int)v89);
    v90 = (_DWORD *)sub_48AF4(v43, "eeprom_bin");
    if ( !v90 || *v90 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 299;
      goto LABEL_61;
    }
    *((_DWORD *)v39 - 1) = sub_49284((int)v90);
    v91 = (_DWORD *)sub_48AF4(v43, "eeprom_ft");
    if ( !v91 || *v91 != 2 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 303;
      goto LABEL_61;
    }
    v92 = (const char *)sub_49028(v91);
    snprintf(v39, 0x10u, "%s", v92);
    v93 = (_DWORD *)sub_48AF4(v43, "eeprom_code");
    if ( !v93 || *v93 != 3 )
    {
      v5 = v105;
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
        sub_1DD60(3, s, 0);
      }
      v21 = 307;
      goto LABEL_61;
    }
    *((_DWORD *)v39 + 4) = sub_49284((int)v93);
    v94 = (_DWORD *)sub_48AF4(v43, "tpl");
    v95 = v94;
    if ( v94 )
    {
      v96 = 0;
      *((_DWORD *)v39 + 5) = sub_48E60(v94);
      while ( (unsigned int)sub_48E60(v95) > v96 )
      {
        v97 = sub_48E7C(v95, v96);
        v98 = v97;
        if ( !v97 )
          break;
        if ( *v97 != 1 )
        {
          v5 = v105;
          if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
          {
            snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
            sub_1DD60(3, s, 0);
          }
          v21 = 317;
          goto LABEL_61;
        }
        v99 = 0;
        for ( *((_DWORD *)v39 + 6) = sub_48E60(v97);
              (unsigned int)sub_48E60(v98) > v99;
              *((_DWORD *)&unk_76318 + v102 + *((_DWORD *)v39 + 6) * v96 + 222) = v101 )
        {
          v100 = sub_48E7C(v98, v99);
          if ( !v100 )
            break;
          v101 = sub_49284((int)v100);
          v102 = 388 * v40 + v99++;
        }
        ++v96;
      }
    }
    ++v40;
    v39 += 1552;
  }
  v5 = v105;
  v59 = (_DWORD *)sub_48AF4(v105, "miner_version");
  if ( !v59 || *v59 != 2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 326;
    goto LABEL_61;
  }
  v60 = (const char *)sub_49028(v59);
  snprintf(src, 0x30u, "%s", v60);
  if ( strcmp(src, byte_6A6D0) )
    strncpy(byte_6A6D0, src, 0x100u);
  v61 = (_DWORD *)sub_48AF4(v105, "total_hash");
  if ( !v61 || *v61 != 4 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 332;
    goto LABEL_61;
  }
  sub_49330();
  dbl_77CF0 = v2;
  dbl_72D88 = v2 * 1000.0;
  v68 = (_DWORD *)sub_48AF4(v105, "miner_id");
  if ( !v68 || *v68 != 2 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 337;
    goto LABEL_61;
  }
  v103 = (const char *)sub_49028(v68);
  snprintf(byte_77CF8, 0x20u, "%s", v103);
  v104 = (_DWORD *)sub_48AF4(v105, "error_code");
  if ( !v104 || *v104 != 3 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s: load json failed", "cb_bitmain_api_stats");
      sub_1DD60(3, s, 0);
    }
    v21 = 341;
    goto LABEL_61;
  }
  dword_77D20 = sub_49284((int)v104);
  sub_40484(344);
  off_67964();
  if ( v105[1] != -1 )
    sub_401D8(v105);
  return 0;
}
// 41484: variable 'v2' is possibly undefined
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D88: using guessed type double dbl_72D88;
// 72D90: using guessed type char byte_72D90;
// 76060: using guessed type int dword_76060;
// 76300: using guessed type pthread_mutex_t stru_76300;
// 7631C: using guessed type int dword_7631C;
// 76320: using guessed type int dword_76320;
// 76324: using guessed type char byte_76324;
// 77CF0: using guessed type double dbl_77CF0;
// 77D18: using guessed type int dword_77D18;
// 77D1C: using guessed type int dword_77D1C;
// 77D20: using guessed type int dword_77D20;

//----- (00042448) --------------------------------------------------------
int __fastcall sub_42448(const char *a1, int a2)
{
  bool v2; // zf
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  if ( !v2 )
    return sub_40500(a1, a2);
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
    return -1;
  snprintf(s, 0x800u, "%s input err: data @ %p, len is %d", "cb_bitmain_api_stats", a1, a2);
  sub_1DD60(3, s, 0);
  return -1;
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (000424FC) --------------------------------------------------------
int __fastcall sub_424FC(const void *a1, size_t a2)
{
  char v5[2048]; // [sp+8h] [bp-800h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    strcpy(v5, "about to send detect");
    sub_1DD60(5, v5, 0);
  }
  return sub_44C58((int)aBitmainApiDete, a1, a2, v5);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (000425B8) --------------------------------------------------------
int __fastcall sub_425B8(const void *a1, size_t a2)
{
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    snprintf(s, 0x800u, "about to send job, size is %d", a2);
    sub_1DD60(7, s, 0);
  }
  return sub_44C58((int)aBitmainUpdateJ, a1, a2, s);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (00042680) --------------------------------------------------------
int __fastcall sub_42680(const void *a1, size_t a2)
{
  char v5[2048]; // [sp+8h] [bp-800h] BYREF

  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy(v5, "about to send a flush api semaphore");
    sub_1DD60(7, v5, 0);
  }
  return sub_44C58((int)aBitmainFlushAp_0, a1, a2, v5);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (00042754) --------------------------------------------------------
int __fastcall sub_42754(const void *a1, size_t a2)
{
  char v5[2048]; // [sp+8h] [bp-800h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    strcpy(v5, "about to send shutdown");
    sub_1DD60(5, v5, 0);
  }
  return sub_44C58((int)aBitmainShutdow, a1, a2, v5);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00042818) --------------------------------------------------------
int sub_42818()
{
  int v0; // r0
  int v1; // r5
  char *v2; // r4
  int *v4; // r0
  int *v5; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  if ( pthread_mutex_init(&stru_76300, 0) )
  {
    v4 = _errno_location();
    snprintf(
      s,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v4,
      "socketa_api.c",
      "cgminer_socket_init",
      506);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( pthread_mutex_init(&stru_77D28, 0) )
  {
    v5 = _errno_location();
    snprintf(
      s,
      0x800u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v5,
      "socketa_api.c",
      "cgminer_socket_init",
      507);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v0 = sub_44744((int)&off_55F30, 2);
  v1 = v0;
  if ( v0 )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      snprintf(s, 0x800u, "%s trans init failed: %d", "cgminer_socket_init", v0);
      sub_1DD60(3, s, 0);
    }
  }
  else
  {
    while ( 1 )
    {
      v2 = aBitmainApiDete;
      v1 = 0;
      do
      {
        v1 |= sub_44998((int)v2);
        if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
        {
          snprintf(s, 0x800u, "%s reg %s return: %d", "cgminer_socket_init", v2, v1);
          sub_1DD60(5, s, 0);
        }
        v2 += 132;
      }
      while ( v2 != (char *)&unk_684F0 );
      if ( !v1 )
        break;
      sleep(5u);
      if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
      {
        snprintf(s, 0x800u, "%s reg failed wait 5s", "cgminer_socket_init");
        sub_1DD60(3, s, 0);
      }
    }
  }
  return v1;
}
// 55F30: using guessed type int (*off_55F30)();
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;
// 76300: using guessed type pthread_mutex_t stru_76300;
// 77D28: using guessed type pthread_mutex_t stru_77D28;

//----- (00042A88) --------------------------------------------------------
int __fastcall sub_42A88(_DWORD *a1)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r5
  __int64 v4; // r6
  __int64 v5; // r8
  _QWORD *v6; // r0
  _QWORD *v7; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  unsigned int *v11; // r3
  unsigned int v12; // r2
  unsigned int v13; // r2
  const char *v14; // r0
  const char *v15; // r0
  char s[128]; // [sp+Ch] [bp-980h] BYREF
  char v17[92]; // [sp+8Ch] [bp-900h] BYREF
  char v18[160]; // [sp+E8h] [bp-8A4h] BYREF
  char v19[2052]; // [sp+188h] [bp-804h] BYREF

  memset(s, 0, sizeof(s));
  sub_2B370(s);
  v2 = sub_47FA8(s, 0, v17);
  v3 = v2;
  if ( v2 && !*v2 )
  {
    v9 = (_DWORD *)sub_48AF4(v2, "bitmain-work-mode");
    if ( v9 && *v9 == 2 )
    {
      v15 = (const char *)sub_49028(v9);
      v5 = strtol(v15, 0, 10);
    }
    else
    {
      v5 = -1;
    }
    v10 = (_DWORD *)sub_48AF4(v3, "bitmain-freq-level");
    if ( v10 && *v10 == 2 )
    {
      v14 = (const char *)sub_49028(v10);
      v4 = strtol(v14, 0, 10);
    }
    else
    {
      v4 = -1;
    }
    if ( v3[1] != -1 )
    {
      v11 = v3 + 1;
      __dmb(0xBu);
      do
      {
        v12 = __ldrex(v11);
        v13 = v12 - 1;
      }
      while ( __strex(v13, v11) );
      if ( !v13 )
        sub_4942C(v3);
    }
  }
  else if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
  {
    v4 = -1;
    v5 = -1;
    snprintf(v19, 0x800u, "%s: JSON decode of file '%s' failed\n %s", "load_conf_info", s, v18);
    sub_1DD60(3, v19, 0);
  }
  else
  {
    v4 = -1;
    v5 = -1;
  }
  v6 = sub_49250(v5);
  sub_49894(a1, "miner-mode", v6);
  v7 = sub_49250(v4);
  return sub_49894(a1, "freq-level", v7);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00042C84) --------------------------------------------------------
void sub_42C84()
{
  char v0[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    strcpy(v0, "cgminer call shutdown");
    sub_1DD60(5, v0, 0);
  }
  if ( sub_42754("shutdown", 8u) && (byte_72D90 || byte_686E0 || dword_67840 > 2) )
  {
    snprintf(v0, 0x800u, "%s: bitmain_shutdown failed.", "bitmain_c5_shutdown");
    sub_1DD60(3, v0, 0);
  }
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 72D90: using guessed type char byte_72D90;

//----- (00042D80) --------------------------------------------------------
int sub_42D80()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  snprintf(v1, 0x800u, "%s: api detect failed.", "bitmain_c5_prepare");
  sub_1DD60(3, v1, 0);
  return 0;
}

//----- (00042F10) --------------------------------------------------------
void __fastcall __noreturn sub_42F10(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "driver-btm-c5_socketa.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_3C2EC(1);
}

//----- (00042F74) --------------------------------------------------------
void __fastcall __noreturn sub_42F74(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "driver-btm-c5_socketa.c", a1, a2);
  sub_1DD60(3, s, 1);
  sub_3C2EC(1);
}

//----- (00042FD8) --------------------------------------------------------
_DWORD *sub_42FD8()
{
  _DWORD *v0; // r10
  __int64 v1; // r0
  _QWORD *v2; // r0
  __int64 v3; // r0
  double *v4; // r0
  __int64 v5; // r0
  double *v6; // r0
  __int64 v7; // r0
  double *v8; // r0
  __int64 v9; // r0
  double *v10; // r0
  char *v11; // r0
  _QWORD *v12; // r0
  _QWORD *v13; // r0
  _DWORD *v14; // r7
  char *v15; // r5
  int v16; // r4
  int v17; // t1
  _QWORD *v18; // r0
  double v19; // d7
  __int64 v20; // r0
  double *v21; // r0
  char *v22; // r4
  int v23; // r10
  _DWORD *v24; // r5
  char *v25; // r7
  int v26; // r9
  _QWORD *v27; // r0
  _QWORD *v28; // r0
  __int64 v29; // r0
  double *v30; // r0
  __int64 v31; // r0
  double *v32; // r0
  _QWORD *v33; // r0
  char *v34; // r0
  _DWORD *v35; // r8
  int v36; // t1
  _QWORD *v37; // r0
  char *v38; // r8
  int v39; // r7
  _DWORD *v40; // r9
  int v41; // t1
  _QWORD *v42; // r0
  char *v43; // r8
  _DWORD *v44; // r9
  int v45; // t1
  _QWORD *v46; // r0
  _QWORD *v47; // r0
  _DWORD *v48; // r2
  char *v49; // r0
  double v50; // d7
  __int64 v51; // r0
  double *v52; // r0
  _DWORD *v54; // r0
  int v55; // r7
  _DWORD *v56; // r11
  _DWORD *v57; // r0
  int v58; // r3
  _DWORD *v59; // r8
  int v60; // r5
  int v61; // r2
  _QWORD *v62; // r0
  _DWORD *v63; // [sp+4h] [bp-50h]
  _DWORD *v64; // [sp+14h] [bp-40h]
  _DWORD *v65; // [sp+18h] [bp-3Ch]
  _DWORD *v66; // [sp+1Ch] [bp-38h]
  double v67; // [sp+20h] [bp-34h] BYREF
  double v68; // [sp+28h] [bp-2Ch] BYREF
  double v69; // [sp+30h] [bp-24h] BYREF
  double v70; // [sp+38h] [bp-1Ch] BYREF
  double v71; // [sp+40h] [bp-14h] BYREF
  char s[4]; // [sp+48h] [bp-Ch] BYREF
  int v73; // [sp+4Ch] [bp-8h]

  v67 = 0.0;
  v68 = 0.0;
  v69 = 0.0;
  v70 = 0.0;
  v71 = 0.0;
  v73 = 0;
  *(_DWORD *)s = 0;
  if ( pthread_mutex_lock(&stru_76300) )
    sub_42F74("bitmain_api_stats", 433);
  v0 = sub_48A70();
  LODWORD(v1) = sub_4ABAC(dbl_681C0);
  v2 = sub_49250(v1);
  sub_49894(v0, "elapsed", v2);
  sscanf(byte_76424, "%lf", &v67);
  LODWORD(v3) = sub_4ABAC(v67 * 100.0);
  sub_4AB14(v3);
  v4 = sub_492D4();
  sub_49894(v0, "rate_5s", v4);
  sscanf(byte_76434, "%lf", &v68);
  LODWORD(v5) = sub_4ABAC(v68 * 100.0);
  sub_4AB14(v5);
  v6 = sub_492D4();
  sub_49894(v0, "rate_30m", v6);
  sscanf(&byte_76434[16], "%lf", &v69);
  LODWORD(v7) = sub_4ABAC(v69 * 100.0);
  sub_4AB14(v7);
  v8 = sub_492D4();
  sub_49894(v0, "rate_avg", v8);
  sscanf(byte_76454, "%lf", &v70);
  LODWORD(v9) = sub_4ABAC(v70 * 100.0);
  sub_4AB14(v9);
  v10 = sub_492D4();
  sub_49894(v0, "rate_ideal", v10);
  snprintf(s, 8u, "%s/s", &byte_76454[16]);
  v11 = (char *)sub_49004(s);
  sub_49894(v0, "rate_unit", v11);
  v12 = sub_49250(dword_7631C);
  sub_49894(v0, "chain_num", v12);
  v13 = sub_49250(*(int *)&byte_76454[24]);
  sub_49894(v0, "fan_num", v13);
  v14 = sub_48E00();
  if ( *(int *)&byte_76454[24] > 0 )
  {
    v15 = &byte_76454[28];
    v16 = 0;
    do
    {
      v17 = *(_DWORD *)v15;
      v15 += 4;
      ++v16;
      v18 = sub_49250(v17);
      sub_49D54(v14, v18);
    }
    while ( *(int *)&byte_76454[24] > v16 );
  }
  sub_49894(v0, "fan", v14);
  v19 = (double)dword_77D18;
  if ( (double)dword_77D18 <= 512.0 )
    v19 = 512.0;
  LODWORD(v20) = sub_4ABAC((double)dword_76060 / v19 * 10000.0);
  sub_4AB14(v20);
  v21 = sub_492D4();
  sub_49894(v0, "hwp_total", v21);
  sub_42A88(v0);
  v63 = sub_48E00();
  if ( dword_7631C > 0 )
  {
    v65 = v0;
    v22 = &byte_76454[52];
    v23 = 0;
    do
    {
      v24 = sub_48A70();
      v25 = v22 + 288;
      v26 = 0;
      v27 = sub_49250(*((int *)v22 - 2));
      sub_49894(v24, "index", v27);
      v28 = sub_49250(*((int *)v22 - 1));
      sub_49894(v24, "freq_avg", v28);
      sscanf(v22, "%lf", &v70);
      LODWORD(v29) = sub_4ABAC(v70 * 100.0);
      sub_4AB14(v29);
      v30 = sub_492D4();
      sub_49894(v24, "rate_ideal", v30);
      sscanf(v22 + 16, "%lf", &v71);
      LODWORD(v31) = sub_4ABAC(v71 * 100.0);
      sub_4AB14(v31);
      v32 = sub_492D4();
      sub_49894(v24, "rate_real", v32);
      v33 = sub_49250(*((int *)v22 + 8));
      sub_49894(v24, "asic_num", v33);
      v34 = (char *)sub_49004(v22 + 36);
      sub_49894(v24, "asic", v34);
      v35 = sub_48E00();
      do
      {
        v36 = *((_DWORD *)v25 + 1);
        v25 += 4;
        ++v26;
        v37 = sub_49250(v36);
        sub_49D54(v35, v37);
      }
      while ( v26 != 4 );
      sub_49894(v24, "temp_pic", v35);
      v38 = v22 + 304;
      v39 = 0;
      v40 = sub_48E00();
      do
      {
        v41 = *((_DWORD *)v38 + 1);
        v38 += 4;
        ++v39;
        v42 = sub_49250(v41);
        sub_49D54(v40, v42);
      }
      while ( v39 != 4 );
      sub_49894(v24, "temp_pcb", v40);
      v43 = v22 + 320;
      v44 = sub_48E00();
      do
      {
        v45 = *((_DWORD *)v43 + 1);
        v43 += 4;
        v46 = sub_49250(v45);
        sub_49D54(v44, v46);
        --v39;
      }
      while ( v39 );
      sub_49894(v24, "temp_chip", v44);
      v47 = sub_49250(*((int *)v22 + 85));
      sub_49894(v24, "hw", v47);
      if ( v22[444] )
        v48 = sub_49408();
      else
        v48 = sub_49414();
      sub_49894(v24, "eeprom_loaded", v48);
      v49 = (char *)sub_49004(v22 + 445);
      sub_49894(v24, "sn", v49);
      v50 = (double)*((int *)v22 + 110);
      if ( v50 <= 512.0 )
        v50 = 512.0;
      LODWORD(v51) = sub_4ABAC((double)*((int *)v22 + 85) * 512.0 / v50 * 10000.0);
      sub_4AB14(v51);
      v52 = sub_492D4();
      sub_49894(v24, "hwp", v52);
      if ( *((_DWORD *)v22 + 128) )
      {
        v54 = sub_48E00();
        v64 = v54;
        if ( *((int *)v22 + 128) > 0 )
        {
          v55 = 0;
          v56 = v54;
          v66 = v24;
          do
          {
            v57 = sub_48E00();
            v58 = *((_DWORD *)v22 + 129);
            v59 = v57;
            if ( v58 > 0 )
            {
              v60 = 0;
              do
              {
                v61 = 388 * v23 + v60++;
                v62 = sub_49250(*((int *)&unk_76318 + v61 + v55 * v58 + 222));
                sub_49D54(v59, v62);
                v58 = *((_DWORD *)v22 + 129);
              }
              while ( v58 > v60 );
            }
            sub_49D54(v56, v59);
            ++v55;
          }
          while ( *((_DWORD *)v22 + 128) > v55 );
          v24 = v66;
        }
        sub_49894(v24, "tpl", v64);
      }
      sub_49D54(v63, v24);
      ++v23;
      v22 += 1552;
    }
    while ( dword_7631C > v23 );
    v0 = v65;
  }
  sub_49894(v0, "chain", v63);
  if ( pthread_mutex_unlock(&stru_76300) )
    sub_42F10("bitmain_api_stats", 540);
  off_67964();
  return v0;
}
// 43040: variable 'v1' is possibly undefined
// 43080: variable 'v3' is possibly undefined
// 430C8: variable 'v5' is possibly undefined
// 43110: variable 'v7' is possibly undefined
// 43158: variable 'v9' is possibly undefined
// 4328C: variable 'v20' is possibly undefined
// 43370: variable 'v29' is possibly undefined
// 433B4: variable 'v31' is possibly undefined
// 43594: variable 'v51' is possibly undefined
// 67964: using guessed type int (*off_67964)();
// 681C0: using guessed type double dbl_681C0;
// 76060: using guessed type int dword_76060;
// 76300: using guessed type pthread_mutex_t stru_76300;
// 7631C: using guessed type int dword_7631C;
// 77D18: using guessed type int dword_77D18;

//----- (00043708) --------------------------------------------------------
__int64 sub_43708()
{
  __int64 v0; // r6

  v0 = qword_6A7E8;
  if ( qword_6A7E8 )
  {
    if ( pthread_mutex_lock(&stru_77D28) )
      sub_42F74("bitmain_c5_scanhash", 184);
    qword_6A7E8 = 0;
    if ( pthread_mutex_unlock(&stru_77D28) )
      sub_42F10("bitmain_c5_scanhash", 186);
    off_67964();
  }
  sub_208D4();
  return v0;
}
// 67964: using guessed type int (*off_67964)();
// 6A7E8: using guessed type __int64 qword_6A7E8;
// 77D28: using guessed type pthread_mutex_t stru_77D28;

//----- (000437A0) --------------------------------------------------------
int sub_437A0()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r9
  int result; // r0
  int *v3; // r0
  int *v4; // r0
  int *v5; // r0
  _BYTE v6[4]; // [sp+14h] [bp-808h] BYREF
  char v7[2040]; // [sp+18h] [bp-804h] BYREF

  v0 = calloc(1u, 0x188u);
  v1 = v0;
  if ( !v0 )
    _assert_fail("cgpu", "driver-btm-c5_socketa.c", 0x33u, "bitmain_c5_detect");
  v0[1] = &unk_684F0;
  v0[8] = 0;
  v0[37] = 1;
  if ( sub_42818() )
  {
    if ( byte_72D90 || byte_686E0 || dword_67840 > 2 )
    {
      strcpy(v7, "cgminer socket init failes.");
      sub_1DD60(3, v7, 0);
    }
  }
  else if ( byte_72D90 || byte_686E0 || dword_67840 > 5 )
  {
    strcpy(v7, "cgminer socket init succeeds.");
    sub_1DD60(6, v7, 0);
  }
  if ( dword_688F8 )
    sub_3DA90();
  v6[0] = 0;
  sub_208D4();
  while ( 1 )
  {
    sub_42680(v6, 1u);
    sub_208D4();
    if ( pthread_mutex_lock(&stru_76300) )
    {
      v3 = _errno_location();
      snprintf(
        v7,
        0x800u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v3,
        "driver-btm-c5_socketa.c",
        "bitmain_c5_detect",
        77);
      sub_1DD60(3, v7, 1);
      sub_3C2EC(1);
    }
    if ( dword_76320 )
      break;
    if ( pthread_mutex_unlock(&stru_76300) )
    {
      v4 = _errno_location();
      snprintf(
        v7,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v4,
        "driver-btm-c5_socketa.c",
        "bitmain_c5_detect",
        83);
      sub_1DD60(3, v7, 1);
      sub_3C2EC(1);
    }
    off_67964();
  }
  if ( pthread_mutex_unlock(&stru_76300) )
  {
    v5 = _errno_location();
    snprintf(
      v7,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v5,
      "driver-btm-c5_socketa.c",
      "bitmain_c5_detect",
      79);
    sub_1DD60(3, v7, 1);
    sub_3C2EC(1);
  }
  off_67964();
  if ( byte_72D90 || byte_686E0 || dword_67840 > 4 )
  {
    strcpy(v7, "bmminer init done!!!");
    sub_1DD60(5, v7, 0);
  }
  result = sub_3C720(v1);
  if ( !result )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-c5_socketa.c", 0x55u, "bitmain_c5_detect");
  return result;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 686E0: using guessed type char byte_686E0;
// 688F8: using guessed type int dword_688F8;
// 72D90: using guessed type char byte_72D90;
// 76300: using guessed type pthread_mutex_t stru_76300;
// 76320: using guessed type int dword_76320;

//----- (00043B30) --------------------------------------------------------
char *__fastcall sub_43B30(int a1, size_t *a2)
{
  pthread_mutex_t *v2; // r4
  pthread_rwlock_t *v4; // r11
  const char *v5; // r9
  int v6; // r6
  size_t v7; // r10
  const char *v8; // r8
  size_t v9; // r7
  size_t v10; // r4
  char *v11; // r0
  char *v12; // r7
  size_t v13; // r3
  size_t v14; // r10
  _DWORD **v15; // r5
  char *v16; // r3
  _DWORD **v17; // r6
  _DWORD *v18; // t1
  int v19; // r12
  int v20; // r0
  int v21; // r1
  int v22; // r12
  int v23; // r0
  int v24; // r1
  size_t v25; // r5
  size_t v26; // r10
  size_t v27; // r5
  size_t v28; // r10
  size_t v29; // r5
  int v30; // r1
  int v31; // r12
  int *v33; // r0
  int *v34; // r0
  int *v35; // r0
  int *v36; // r0
  int v38; // [sp+18h] [bp-814h]
  size_t v39; // [sp+1Ch] [bp-810h]
  int v40; // [sp+20h] [bp-80Ch] BYREF
  int v41; // [sp+24h] [bp-808h]
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 212);
  v40 = 0;
  v41 = 0;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
  {
    v35 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v35,
      "driver-btm-c5_socketa.c",
      "rebuild_job_buf",
      222);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v4 = (pthread_rwlock_t *)(a1 + 236);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 236)) )
  {
    v36 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v36,
      "driver-btm-c5_socketa.c",
      "rebuild_job_buf",
      222);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  if ( pthread_mutex_unlock(v2) )
  {
    v34 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v34,
      "driver-btm-c5_socketa.c",
      "rebuild_job_buf",
      222);
    sub_1DD60(3, s, 1);
    sub_3C2EC(1);
  }
  v5 = *(const char **)(a1 + 688);
  v6 = *(_DWORD *)(a1 + 1724);
  v7 = *(_DWORD *)(a1 + 1588);
  v8 = *(const char **)(a1 + 628);
  v9 = strlen(v5);
  v38 = 32 * v6;
  v10 = v7 + 1882 + 32 * v6 + v9 + strlen(v8);
  v11 = (char *)calloc(1u, v10);
  v12 = v11;
  if ( v11 )
  {
    memcpy(v11, (const void *)a1, 0x748u);
    memcpy(v12 + 1864, *(const void **)(a1 + 1584), v7);
    v13 = v7 + 1864;
    v39 = v7 + 1864;
    v14 = v7 + 1864;
    if ( v6 > 0 )
    {
      v15 = *(_DWORD ***)(a1 + 692);
      v16 = &v12[v13];
      v17 = &v15[v6];
      do
      {
        v18 = *v15++;
        v16 += 32;
        v19 = v18[1];
        v20 = v18[2];
        v21 = v18[3];
        *((_DWORD *)v16 - 8) = *v18;
        *((_DWORD *)v16 - 7) = v19;
        *((_DWORD *)v16 - 6) = v20;
        *((_DWORD *)v16 - 5) = v21;
        v22 = v18[5];
        v23 = v18[6];
        v24 = v18[7];
        *((_DWORD *)v16 - 4) = v18[4];
        *((_DWORD *)v16 - 3) = v22;
        *((_DWORD *)v16 - 2) = v23;
        *((_DWORD *)v16 - 1) = v24;
      }
      while ( v17 != v15 );
      v14 = v39 + v38;
    }
    v25 = strlen(v5) + 1;
    memcpy(&v12[v14], v5, v25);
    v26 = v25 + v14;
    v27 = strlen(v8);
    memcpy(&v12[v26], v8, v27 + 1);
    v28 = v26 + v27;
    v29 = v28 + 1;
    if ( pthread_rwlock_unlock(v4) )
    {
      v33 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v33,
        "driver-btm-c5_socketa.c",
        "rebuild_job_buf",
        258);
      sub_1DD60(3, s, 1);
      sub_3C2EC(1);
    }
    off_67964();
    sscanf(byte_6A6B8, "%.2lf", &v40);
    v30 = v41;
    v31 = (unsigned __int8)byte_686E1;
    *(_DWORD *)&v12[v29] = v40;
    *(_DWORD *)&v12[v29 + 4] = v30;
    *(double *)&v12[v28 + 9] = dbl_681E8;
    if ( v31 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
    {
      snprintf(s, 0x800u, "job buf total len:%d, offset:%d\n", v10, v28 + 17);
      sub_1DD60(7, s, 0);
    }
    *a2 = v10;
    return v12;
  }
  if ( !byte_72D90 && !byte_686E0 && dword_67840 <= 2 )
    return v12;
  snprintf(s, 0x800u, "malloc temp job data buf failed: %d\n", v10);
  sub_1DD60(3, s, 0);
  return 0;
}
// 67840: using guessed type int dword_67840;
// 67964: using guessed type int (*off_67964)();
// 681E8: using guessed type double dbl_681E8;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 72D90: using guessed type char byte_72D90;

//----- (00043F94) --------------------------------------------------------
void __fastcall sub_43F94(int a1)
{
  int v1; // r4
  void *v2; // r1
  int v3; // r0
  char *v4; // r0
  char *v5; // r4
  void **v6; // [sp+0h] [bp-80Ch] BYREF
  size_t v7; // [sp+4h] [bp-808h] BYREF
  char v8[2052]; // [sp+8h] [bp-804h] BYREF

  v1 = **(_DWORD **)(a1 + 152);
  if ( byte_686E1 && (byte_72D90 || byte_686E0 || dword_67840 > 6) )
  {
    strcpy(v8, "update job");
    sub_1DD60(7, v8, 0);
  }
  v2 = *(void **)v1;
  *(_BYTE *)(v1 + 63) = 0;
  *(_BYTE *)(v1 + 62) = 0;
  v6 = sub_341EC(v1, v2);
  sub_2AA08(&v6, "driver-btm-c5_socketa.c", "bitmain_c5_update", 288);
  v3 = sub_2FB78();
  if ( !*(_BYTE *)(v3 + 656) )
  {
    strcpy(v8, "Bitmain S9 has to use stratum pools");
    sub_1DD60(3, v8, 1);
    sub_3C2EC(1);
  }
  if ( dword_6A254 )
  {
    *(_BYTE *)(v3 + 696) = 1;
    dword_6A254 = 0;
  }
  v4 = sub_43B30(v3, &v7);
  v5 = v4;
  if ( v7 && sub_425B8(v4, v7) && (byte_72D90 || byte_686E0 || dword_67840 > 2) )
  {
    snprintf(v8, 0x800u, "%s: update job failed.", "bitmain_c5_update");
    sub_1DD60(3, v8, 0);
  }
  free(v5);
}
// 67840: using guessed type int dword_67840;
// 686E0: using guessed type char byte_686E0;
// 686E1: using guessed type char byte_686E1;
// 6A254: using guessed type int dword_6A254;
// 72D90: using guessed type char byte_72D90;

//----- (00044188) --------------------------------------------------------
int __fastcall sub_44188(int a1)
{
  pthread_t v2; // r0
  int v3; // r7
  int v4; // r4
  int v5; // r4
  _DWORD *v6; // r0
  int v7; // r11
  _DWORD *v8; // r10
  const char *v9; // r5
  int v10; // r0
  int v11; // r3
  size_t v12; // r0
  int v13; // r10
  size_t v14; // r0
  size_t v16; // r0
  int v17; // [sp+14h] [bp-200h] BYREF
  pthread_t newthread; // [sp+18h] [bp-1FCh] BYREF
  _BYTE v19[8]; // [sp+1Ch] [bp-1F8h] BYREF
  int v20; // [sp+24h] [bp-1F0h]
  int v21; // [sp+28h] [bp-1ECh]
  char src[4]; // [sp+2Ch] [bp-1E8h] BYREF
  int v23; // [sp+30h] [bp-1E4h]
  int v24; // [sp+34h] [bp-1E0h]
  int v25; // [sp+38h] [bp-1DCh]
  int v26; // [sp+3Ch] [bp-1D8h]
  int v27; // [sp+40h] [bp-1D4h]
  int v28; // [sp+44h] [bp-1D0h]
  int v29; // [sp+48h] [bp-1CCh]
  char s1[4]; // [sp+4Ch] [bp-1C8h] BYREF
  int v31; // [sp+50h] [bp-1C4h]
  int v32; // [sp+54h] [bp-1C0h]
  int v33; // [sp+58h] [bp-1BCh]
  int v34; // [sp+5Ch] [bp-1B8h]
  int v35; // [sp+60h] [bp-1B4h]
  int v36; // [sp+64h] [bp-1B0h]
  int v37; // [sp+68h] [bp-1ACh]
  pthread_attr_t attr; // [sp+6Ch] [bp-1A8h] BYREF
  _DWORD buf[32]; // [sp+90h] [bp-184h] BYREF
  char v40[4]; // [sp+110h] [bp-104h] BYREF
  _BYTE v41[252]; // [sp+114h] [bp-100h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v21 = 0;
  qmemcpy(v19, "ct_a/mai", sizeof(v19));
  v20 = *(unsigned __int16 *)"n";
  prctl(15, v19);
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  v3 = *(_DWORD *)(a1 + 8);
  while ( 1 )
  {
    memset(buf, 0, sizeof(buf));
    if ( recv(v3, buf, 0x80u, 0) <= 0 )
      return 0;
    *(_DWORD *)src = 0;
    v23 = 0;
    *(_DWORD *)s1 = 0;
    v31 = 0;
    v17 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    _isoc99_sscanf(buf, "%x%s%s", &v17, s1, src);
    v4 = strcmp(s1, "regist");
    if ( v4 )
    {
      v5 = dword_6A7F0 + 1;
      memcpy((char *)&unk_6A818 + 128 * dword_6A7F0, buf, 0x80u);
      dword_6A7F0 = v5;
    }
    else
    {
      v6 = calloc(0x98u, 1u);
      v7 = dword_6A7F4;
      v8 = v6;
      if ( !dword_6A7F4 )
        goto LABEL_18;
      v9 = s2;
      while ( 1 )
      {
        v10 = strcmp(src, v9);
        v9 += 136;
        if ( !v10 )
          break;
        if ( ++v4 == v7 )
          goto LABEL_11;
      }
      v11 = *((_DWORD *)&unk_6E818 + 34 * v4 + 33);
      v8[3] = *((_DWORD *)&unk_6E818 + 34 * v4);
      v8[37] = v11;
LABEL_11:
      if ( v7 == v4 )
      {
LABEL_18:
        *(_DWORD *)v40 = 0;
        memset(v41, 0, sizeof(v41));
        sprintf(v40, "%x %d %s %s %s", 63, 0, "reg_resp", "no_name", src);
        v16 = strlen(v40);
        send(v3, v40, v16 + 1, 0);
        free(v8);
      }
      else
      {
        *v8 = dword_68568;
        v12 = strlen(src);
        memcpy(v8 + 4, src, v12 + 1);
        v8[36] = 0;
        pthread_create(&newthread, &attr, (void *(*)(void *))sub_444BC, v8);
        while ( !v8[36] )
          usleep(0x2710u);
        v13 = *v8;
        *(_DWORD *)v40 = 0;
        if ( v13 != dword_68568 )
          dword_68568 = v13;
        memset(v41, 0, sizeof(v41));
        sprintf(v40, "%x %d %s %s %s", 63, v13, "reg_resp", "OK", src);
        v14 = strlen(v40);
        send(v3, v40, v14 + 1, 0);
        ++dword_68568;
      }
    }
  }
}
// 12548: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 68568: using guessed type int dword_68568;
// 6A7F0: using guessed type int dword_6A7F0;
// 6A7F4: using guessed type int dword_6A7F4;

//----- (000444BC) --------------------------------------------------------
int __fastcall sub_444BC(int a1)
{
  pthread_t v2; // r0
  unsigned int v3; // r2
  int v4; // r0
  int v5; // r4
  unsigned int i; // r3
  int v7; // r5
  size_t v8; // r0
  void *v9; // r6
  ssize_t v10; // r1
  int (__fastcall *v11)(void *, ssize_t); // r4
  size_t v12; // r0
  size_t n; // [sp+Ch] [bp-240h]
  int v15; // [sp+10h] [bp-23Ch] BYREF
  socklen_t v16; // [sp+14h] [bp-238h] BYREF
  char s[4]; // [sp+18h] [bp-234h] BYREF
  int v18; // [sp+1Ch] [bp-230h]
  int v19; // [sp+20h] [bp-22Ch]
  int v20; // [sp+24h] [bp-228h]
  struct sockaddr addr; // [sp+28h] [bp-224h] BYREF
  struct sockaddr v22; // [sp+38h] [bp-214h] BYREF
  char buf[4]; // [sp+48h] [bp-204h] BYREF
  char v24[252]; // [sp+4Ch] [bp-200h] BYREF
  char v25[4]; // [sp+148h] [bp-104h] BYREF
  _BYTE v26[252]; // [sp+14Ch] [bp-100h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *(_DWORD *)a1;
  *(_DWORD *)s = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  sprintf(s, "ct_a/fcb/%d", v3);
  prctl(15, s);
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  v4 = socket(2, 1, 0);
  v5 = v4;
  if ( v4 < 0 )
  {
    perror("socket error");
    return 0;
  }
  else
  {
    v15 = 1;
    if ( setsockopt(v4, 1, 2, &v15, 4u) < 0 )
    {
      perror("set sockopt err");
      return 0;
    }
    else
    {
      for ( i = *(_DWORD *)a1; ; *(_DWORD *)a1 = i )
      {
        *(_WORD *)addr.sa_data = __rev16(i);
        if ( bind(v5, &addr, 0x10u) >= 0 )
          break;
        perror("bind error");
        i = *(_DWORD *)a1 + 1;
      }
      if ( listen(v5, 5) < 0 )
      {
        perror("listen error");
      }
      else
      {
        v16 = 16;
        *(_DWORD *)(a1 + 144) = 1;
        v7 = accept(v5, &v22, &v16);
        if ( v7 >= 0 )
        {
          *(_DWORD *)buf = 0;
          memset(v24, 0, sizeof(v24));
          sprintf(buf, "%x %s\n", 63, (const char *)(a1 + 16));
          v8 = strlen(buf);
          send(v7, buf, v8 + 1, 0);
          n = *(_DWORD *)(a1 + 148);
          v9 = malloc(n);
          recv(v7, v9, n, 0);
          while ( 1 )
          {
            v10 = recv(v7, v9, *(_DWORD *)(a1 + 148), 0);
            if ( v10 > 0 )
            {
              v11 = *(int (__fastcall **)(void *, ssize_t))(a1 + 12);
              if ( v11 )
                v11 = (int (__fastcall *)(void *, ssize_t))v11(v9, v10);
            }
            else
            {
              v11 = 0;
            }
            *(_DWORD *)v25 = 0;
            memset(v26, 0, sizeof(v26));
            sprintf(v25, "%x %d %s %s", 63, v11, a1 + 16, "OK");
            v12 = strlen(v25);
            send(v7, v25, v12 + 1, 0);
          }
        }
        perror("accept error");
      }
      return 0;
    }
  }
}

//----- (00044744) --------------------------------------------------------
int __fastcall sub_44744(int a1, int a2)
{
  int v2; // r6
  char *v5; // r4
  char *v6; // r3
  char *v7; // r7
  char *v8; // r0
  int v9; // r0
  int v10; // r4
  ssize_t v11; // r0
  _BYTE *v12; // r3
  bool v13; // cc
  int *v14; // r12
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int *v19; // r12
  int v20; // r1
  ssize_t v21; // r0
  _BYTE *v22; // r3
  int *v23; // r12
  int v24; // r0
  int v25; // r1
  int v26; // r2
  int v27; // r3
  int *v28; // r12
  int v29; // r1
  _DWORD *v30; // r0
  pthread_t v32; // [sp+0h] [bp-338h] BYREF
  struct sockaddr addr; // [sp+4h] [bp-334h] BYREF
  pthread_attr_t attr; // [sp+14h] [bp-324h] BYREF
  int v35; // [sp+38h] [bp-300h] BYREF
  int v36; // [sp+3Ch] [bp-2FCh]
  int v37; // [sp+40h] [bp-2F8h]
  int v38; // [sp+44h] [bp-2F4h]
  int v39; // [sp+48h] [bp-2F0h]
  int v40; // [sp+4Ch] [bp-2ECh]
  _BYTE v41[232]; // [sp+50h] [bp-2E8h] BYREF
  _DWORD buf[128]; // [sp+138h] [bp-200h] BYREF
  _BYTE vars0[24]; // [sp+338h] [bp+0h] BYREF

  v2 = dword_6A7F8;
  if ( dword_6A7F8 )
    return -1;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x100000u);
  pthread_mutex_init(&stru_6A7FC, 0);
  if ( a2 )
  {
    v5 = (char *)(a1 + 4);
    v6 = s2;
    v7 = &v5[136 * a2];
    do
    {
      v8 = (char *)memcpy(v6, v5, 0x80u);
      v5 += 136;
      v6 = v8 + 136;
      v9 = *((_DWORD *)v5 - 35);
      *((_DWORD *)v6 - 2) = *((_DWORD *)v5 - 2);
      *((_DWORD *)v6 - 35) = v9;
    }
    while ( v5 != v7 );
  }
  *(_WORD *)&addr.sa_data[6] = 0;
  *(_DWORD *)&addr.sa_data[8] = 0;
  *(_WORD *)&addr.sa_data[12] = 0;
  dword_6A7F4 = a2;
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)addr.sa_data = 2646;
  v10 = socket(2, 1, 0);
  if ( v10 < 0 )
  {
    v2 = -4;
    perror("socket err:");
  }
  else
  {
    while ( connect(v10, &addr, 0x10u) < 0 )
    {
      perror("connect err:");
      sleep(1u);
    }
    memset(buf, 0, sizeof(buf));
    v11 = recv(v10, buf, 0x100u, 0);
    v13 = v11 <= 0;
    LOWORD(v14) = (unsigned __int16)"func1 func2 func3 func4";
    if ( v11 > 0 )
      v12 = vars0;
    HIWORD(v14) = (unsigned int)"func1 func2 func3 func4" >> 16;
    if ( v11 > 0 )
      v11 += (ssize_t)v12;
    if ( !v13 )
      *(_BYTE *)(v11 - 512) = 0;
    v15 = *v14;
    v16 = v14[1];
    v17 = v14[2];
    v18 = v14[3];
    v19 = v14 + 4;
    v35 = v15;
    v36 = v16;
    v37 = v17;
    v38 = v18;
    v20 = v19[1];
    v39 = *v19;
    v40 = v20;
    memset(v41, 0, sizeof(v41));
    send(v10, &v35, 0x18u, 0);
    v21 = recv(v10, buf, 0x100u, 0);
    LOWORD(v23) = (unsigned __int16)"3f heart-beats 22027";
    if ( v21 > 0 )
      v22 = vars0;
    HIWORD(v23) = (unsigned int)"3f heart-beats 22027" >> 16;
    if ( v21 > 0 )
      v22[v21 - 512] = 0;
    v24 = *v23;
    v25 = v23[1];
    v26 = v23[2];
    v27 = v23[3];
    v28 = v23 + 4;
    v35 = v24;
    v36 = v25;
    v37 = v26;
    v38 = v27;
    v29 = v28[1];
    v39 = *v28;
    LOBYTE(v40) = v29;
    send(v10, &v35, 0x15u, 0);
    dword_6A814 = v10;
    v30 = malloc(0xCu);
    v30[2] = v10;
    *v30 = 22026;
    pthread_create(&v32, &attr, (void *(*)(void *))sub_44188, v30);
    dword_6A7F8 = 1;
  }
  return v2;
}
// 44894: variable 'v12' is possibly undefined
// 448F8: variable 'v22' is possibly undefined
// 6A7F4: using guessed type int dword_6A7F4;
// 6A7F8: using guessed type int dword_6A7F8;
// 6A7FC: using guessed type pthread_mutex_t;
// 6A814: using guessed type int dword_6A814;

//----- (00044998) --------------------------------------------------------
int __fastcall sub_44998(int a1)
{
  pthread_mutex_t *v2; // r8
  int v3; // r9
  int v4; // r5
  size_t v5; // r0
  int v6; // r0
  int v7; // r5
  ssize_t v8; // r0
  unsigned int v9; // r3
  int result; // r0
  unsigned int v11; // [sp+10h] [bp-47Ch] BYREF
  int v12; // [sp+14h] [bp-478h] BYREF
  struct sockaddr addr; // [sp+18h] [bp-474h] BYREF
  _DWORD v14[8]; // [sp+28h] [bp-464h] BYREF
  _DWORD v15[8]; // [sp+48h] [bp-444h] BYREF
  _DWORD v16[8]; // [sp+68h] [bp-424h] BYREF
  _DWORD dest[32]; // [sp+88h] [bp-404h] BYREF
  _DWORD v18[32]; // [sp+108h] [bp-384h] BYREF
  char buf[4]; // [sp+188h] [bp-304h] BYREF
  _BYTE s[252]; // [sp+18Ch] [bp-300h] BYREF
  _DWORD v21[129]; // [sp+288h] [bp-204h] BYREF

  if ( !dword_6A7F8 )
    return -1;
  v2 = (pthread_mutex_t *)malloc(0x24u);
  pthread_mutex_init(v2, 0);
  v3 = dword_6A814;
  *(_DWORD *)buf = 0;
  memset(s, 0, sizeof(s));
  sprintf(buf, "%x regist %s", 63, (const char *)a1);
  v4 = dword_6A7F0;
  v5 = strlen(buf);
  send(v3, buf, v5 + 1, 0);
  memset(dest, 0, sizeof(dest));
  while ( dword_6A7F0 == v4 )
    usleep(0x3E8u);
  memcpy(dest, (char *)&unk_6A818 + 128 * v4, sizeof(dest));
  v11 = 0;
  v12 = 0;
  memset(v14, 0, sizeof(v14));
  memset(v15, 0, sizeof(v15));
  memset(v16, 0, sizeof(v16));
  _isoc99_sscanf(dest, "%x%d%s%s%s", &v12, &v11, v14, v15, v16);
  if ( !v11 )
    return -4;
  addr.sa_family = 2;
  memset(addr.sa_data, 0, sizeof(addr.sa_data));
  *(_DWORD *)&addr.sa_data[2] = inet_addr("127.0.0.1");
  *(_WORD *)addr.sa_data = __rev16(v11);
  v6 = socket(2, 1, 0);
  v7 = v6;
  if ( v6 < 0 )
  {
    perror("socket err:");
    return -4;
  }
  else if ( connect(v6, &addr, 0x10u) < 0 )
  {
    perror("connect err:");
    return -3;
  }
  else
  {
    memset(v21, 0, 512);
    v8 = recv(v7, v21, 0x200u, 0);
    if ( v8 > 0 )
      *((_BYTE *)v21 + v8) = 0;
    memset(&v18[1], 0, 0x7Cu);
    v18[0] = 2181967;
    send(v7, v18, 4u, 0);
    v9 = v11;
    result = 0;
    v2[1].__owner = v7;
    *(_DWORD *)(a1 + 128) = v2;
    v2[1].__lock = v9;
  }
  return result;
}
// 12548: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 6A7F0: using guessed type int dword_6A7F0;
// 6A7F8: using guessed type int dword_6A7F8;
// 6A814: using guessed type int dword_6A814;

//----- (00044C40) --------------------------------------------------------
int sub_44C40()
{
  return 0;
}

//----- (00044C58) --------------------------------------------------------
int __fastcall sub_44C58(int a1, const void *a2, size_t a3, _DWORD *a4)
{
  pthread_mutex_t *v4; // r5
  int v8; // r4
  ssize_t v9; // r0
  int v11; // [sp+8h] [bp-148h] BYREF
  int v12; // [sp+Ch] [bp-144h] BYREF
  int v13; // [sp+10h] [bp-140h] BYREF
  int v14; // [sp+14h] [bp-13Ch]
  int v15; // [sp+18h] [bp-138h]
  int v16; // [sp+1Ch] [bp-134h]
  int v17; // [sp+20h] [bp-130h]
  int v18; // [sp+24h] [bp-12Ch]
  int v19; // [sp+28h] [bp-128h]
  int v20; // [sp+2Ch] [bp-124h]
  int v21; // [sp+30h] [bp-120h] BYREF
  int v22; // [sp+34h] [bp-11Ch]
  int v23; // [sp+38h] [bp-118h]
  int v24; // [sp+3Ch] [bp-114h]
  int v25; // [sp+40h] [bp-110h]
  int v26; // [sp+44h] [bp-10Ch]
  int v27; // [sp+48h] [bp-108h]
  int v28; // [sp+4Ch] [bp-104h]
  _DWORD buf[64]; // [sp+50h] [bp-100h] BYREF

  if ( !dword_6A7F8 )
    return -1;
  v4 = *(pthread_mutex_t **)(a1 + 128);
  if ( !v4 )
    return -2;
  v8 = pthread_mutex_trylock(*(pthread_mutex_t **)(a1 + 128));
  if ( v8 )
    return -3;
  if ( send(v4[1].__owner, a2, a3, 0) <= 0 )
  {
    v8 = -4;
    pthread_mutex_unlock(v4);
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    v9 = recv(v4[1].__owner, buf, 0x100u, 0);
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v21 = 0;
    v22 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    if ( v9 > 0 )
      _isoc99_sscanf(buf, "%x%d%s%s", &v11, &v12, &v13, &v21);
    if ( a4 )
      *a4 = v12;
    pthread_mutex_unlock(v4);
  }
  return v8;
}
// 12548: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 6A7F8: using guessed type int dword_6A7F8;

//----- (00044DA4) --------------------------------------------------------
int sub_44DA4()
{
  return 0;
}

//----- (00044DAC) --------------------------------------------------------
int __fastcall sub_44DAC(void *src, size_t n, const void **a3)
{
  return sub_482A8(a3, src, n);
}

//----- (00044DC0) --------------------------------------------------------
int __fastcall sub_44DC0(void *src, size_t n, _DWORD *a3)
{
  int v4; // r12
  size_t v5; // r3

  v4 = a3[1];
  v5 = v4 + n;
  if ( v4 + n <= *a3 )
  {
    memcpy((void *)(a3[2] + v4), src, n);
    v5 = n + a3[1];
  }
  a3[1] = v5;
  return 0;
}

//----- (00044E04) --------------------------------------------------------
size_t __fastcall sub_44E04(const void *a1, size_t a2, FILE *s)
{
  size_t result; // r0

  result = fwrite(a1, a2, 1u, s) - 1;
  if ( result )
    return -1;
  return result;
}

//----- (00044E20) --------------------------------------------------------
int __fastcall sub_44E20(void *buf, size_t n, int *a3)
{
  int result; // r0

  result = n - write(*a3, buf, n);
  if ( result )
    return -1;
  return result;
}

//----- (00044E48) --------------------------------------------------------
int __fastcall sub_44E48(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (00044E54) --------------------------------------------------------
int __fastcall sub_44E54(char *a1, int a2, int (__fastcall *a3)(char *, int, int), int a4, unsigned int a5)
{
  unsigned int v9; // r8
  char *i; // r10
  char *v12; // r5
  bool v13; // zf
  int v14; // r1
  char *v15; // r0
  int v16; // r1
  unsigned int v17; // r3
  int v18; // [sp+0h] [bp-2Ch]
  int v19; // [sp+14h] [bp-18h] BYREF
  char s[20]; // [sp+18h] [bp-14h] BYREF

  v19 = 0;
  if ( a3("\"", 1, a4) )
    return -1;
  v9 = (unsigned int)&a1[a2];
  for ( i = a1; (unsigned int)i < v9; i = v12 )
  {
    v12 = sub_48830(i, v9 - (_DWORD)i, &v19);
    if ( !v12 )
      return -1;
    v13 = v19 == 34;
    if ( v19 != 34 )
      v13 = v19 == 92;
    v14 = v13;
    if ( v19 <= 31 )
      v14 |= 1u;
    if ( !v14 && ((v19 == 47) & (a5 >> 10)) == 0 && ((v19 > 127) & (a5 >> 6)) == 0 )
      continue;
    if ( a1 != i && a3(a1, i - a1, a4) )
      return -1;
    if ( i == v12 )
      return a3("\"", 1, a4);
    if ( v19 == 12 )
    {
      v16 = 2;
      v15 = "\\f";
      goto LABEL_26;
    }
    if ( v19 <= 12 )
    {
      switch ( v19 )
      {
        case 9:
          v15 = "\\t";
          v16 = 2;
          goto LABEL_26;
        case 10:
          v15 = "\\n";
          v16 = 2;
          goto LABEL_26;
        case 8:
          v15 = "\\b";
          v16 = 2;
          goto LABEL_26;
      }
LABEL_32:
      if ( v19 >= 0x10000 )
      {
        v17 = ((unsigned int)(v19 - 0x10000) >> 10) & 0x3FF | 0xD800;
        v18 = (v19 - 0x10000) & 0x3FF | 0xDC00;
        v19 -= 0x10000;
        snprintf(s, 0xDu, "\\u%04X\\u%04X", v17, v18);
        v15 = s;
        v16 = 12;
        goto LABEL_26;
      }
LABEL_33:
      snprintf(s, 0xDu, "\\u%04X");
      v15 = s;
      v16 = 6;
      goto LABEL_26;
    }
    if ( v19 == 34 )
    {
      v15 = "\\\"";
      v16 = 2;
      goto LABEL_26;
    }
    if ( v19 <= 34 )
    {
      if ( v19 == 13 )
      {
        v15 = "\\r";
        v16 = 2;
        goto LABEL_26;
      }
      goto LABEL_33;
    }
    if ( v19 == 47 )
    {
      v15 = "\\/";
      v16 = 2;
      goto LABEL_26;
    }
    if ( v19 != 92 )
      goto LABEL_32;
    v15 = "\\\\";
    v16 = 2;
LABEL_26:
    if ( a3(v15, v16, a4) )
      return -1;
    a1 = v12;
  }
  if ( a1 == i || !a3(a1, i - a1, a4) )
    return a3("\"", 1, a4);
  return -1;
}
// 44FF4: conditional instruction was optimized away because %var_18.4 is in (E..21)

//----- (000450DC) --------------------------------------------------------
int __fastcall sub_450DC(char a1, int a2, int a3, int (__fastcall *a4)(__int16 *, int, int), int a5)
{
  unsigned int v6; // r4
  int v7; // r5

  if ( (a1 & 0x1F) != 0 )
  {
    v6 = (a1 & 0x1F) * a2;
    if ( a4(&word_4C1E4, 1, a5) )
      return -1;
    if ( v6 )
    {
      while ( 1 )
      {
        v7 = v6 >= 0x20 ? 32 : v6;
        if ( a4((__int16 *)"                                ", v7, a5) )
          break;
        v6 -= v7;
        if ( !v6 )
          return 0;
      }
      return -1;
    }
    return 0;
  }
  if ( !a3 || (a1 & 0x20) != 0 )
    return 0;
  return a4((__int16 *)" ", 1, a5);
}
// 4C1E4: using guessed type __int16 word_4C1E4;

//----- (0004518C) --------------------------------------------------------
int __fastcall sub_4518C(int a1, const void *a2, char *s)
{
  void *v5; // r0

  snprintf(s, 0xBu, "%p", a2);
  if ( sub_46508(a1, s) )
    return -1;
  v5 = sub_49420();
  return sub_46274(a1, s, (int)v5);
}

//----- (000451E4) --------------------------------------------------------
int __fastcall sub_451E4(_DWORD *a1, int a2, int a3, int a4, int (__fastcall *a5)(__int16 *, int, int), int a6)
{
  _DWORD *v7; // r5
  int v8; // r8
  unsigned int v9; // r7
  char v11; // r9
  char *v12; // r3
  int v13; // r3
  int v14; // r6
  char *v16; // r5
  _DWORD *v17; // r0
  __int64 v18; // r0
  int v19; // r0
  int v20; // r1
  int v21; // r8
  int v22; // r6
  int v23; // r11
  int v24; // r9
  char *v25; // r10
  size_t v26; // r0
  int v27; // r0
  unsigned int v28; // r9
  int v29; // r8
  _DWORD *v30; // r3
  _DWORD *v31; // r11
  unsigned int v32; // r10
  _DWORD *v33; // r0
  char *v34; // r0
  char *v35; // r9
  unsigned int v36; // r7
  int v37; // r5
  char *v38; // r8
  int v39; // r11
  unsigned int v40; // r6
  char *v41; // r10
  char *v42; // t1
  int v43; // r9
  size_t v44; // r0
  int v45; // r8
  char *v46; // [sp+Ch] [bp-98h]
  _DWORD *v47; // [sp+Ch] [bp-98h]
  int v48; // [sp+Ch] [bp-98h]
  int v49; // [sp+10h] [bp-94h]
  int v50; // [sp+10h] [bp-94h]
  int v51; // [sp+14h] [bp-90h]
  int v52; // [sp+14h] [bp-90h]
  size_t nmemb; // [sp+18h] [bp-8Ch]
  int v54; // [sp+1Ch] [bp-88h]
  int v55; // [sp+20h] [bp-84h]
  void *base; // [sp+24h] [bp-80h]
  _DWORD *v57; // [sp+28h] [bp-7Ch]
  int v58; // [sp+28h] [bp-7Ch]
  char *v59; // [sp+2Ch] [bp-78h]
  unsigned int v60; // [sp+30h] [bp-74h]
  _DWORD *v61; // [sp+34h] [bp-70h]
  __int16 s[52]; // [sp+3Ch] [bp-68h] BYREF

  if ( !a1 )
    return -1;
  v7 = (_DWORD *)a4;
  v8 = a2 & 0x10000;
  v9 = a2 & 0xFFFEFFFF;
  v11 = a2;
  switch ( *a1 )
  {
    case 0:
      v12 = ":";
      if ( (a2 & 0x20) == 0 )
        v12 = ": ";
      v46 = v12;
      if ( (a2 & 0x20) != 0 )
        v13 = 1;
      else
        v13 = 2;
      v49 = v13;
      v14 = sub_4518C((int)v7, a1, (char *)s);
      if ( v14 )
        return -1;
      v51 = sub_48D5C(a1);
      if ( v8 )
      {
        if ( !v51 )
          goto LABEL_45;
      }
      else
      {
        if ( a5((__int16 *)"{", 1, a6) )
          return -1;
        if ( !v51 )
        {
          sub_46568(v7, (char *)s);
          return a5((__int16 *)"}", 1, a6);
        }
      }
      if ( sub_450DC(v9, a3 + 1, 0, a5, a6) )
        return -1;
      if ( (v11 & 0x80) == 0 )
      {
        v55 = v8;
        v21 = a3 + 1;
        v22 = v51;
        v23 = v49;
        v50 = a3;
        while ( 1 )
        {
          v24 = sub_48DA8(a1, v22);
          v25 = (char *)sub_48DDC(v22);
          v26 = strlen(v25);
          sub_44E54(v25, v26, (int (__fastcall *)(char *, int, int))a5, a6, v9);
          if ( a5((__int16 *)v46, v23, a6) )
            return -1;
          v27 = sub_48DE8(v22);
          if ( sub_451E4(v27, v9, v21, v7, a5, a6) )
            return -1;
          if ( !v24 )
          {
            v45 = v55;
            v14 = 0;
            if ( sub_450DC(v9, v50, 0, a5, a6) )
              return -1;
            goto LABEL_68;
          }
          if ( !a5(&word_51D00, 1, a6) )
          {
            v22 = v24;
            if ( !sub_450DC(v9, v21, 1, a5, a6) )
              continue;
          }
          return -1;
        }
      }
      v57 = sub_48AD8(a1);
      v34 = (char *)sub_48144((void *)(4 * (_DWORD)v57));
      base = v34;
      if ( !v34 )
        return -1;
      v60 = v9;
      v61 = v7;
      v35 = v34 - 4;
      v59 = v34 - 4;
      v36 = 0;
      v37 = v51;
      while ( 1 )
      {
        *((_DWORD *)v35 + 1) = sub_48DDC(v37);
        v35 += 4;
        v37 = sub_48DA8(a1, v37);
        if ( !v37 )
          break;
        ++v36;
      }
      nmemb = v36 + 1;
      v7 = v61;
      if ( v57 != (_DWORD *)(v36 + 1) )
        _assert_fail("i == size", "dump.c", 0x160u, "do_dump");
      qsort(base, nmemb, 4u, (__compar_fn_t)sub_44E48);
      v58 = v8;
      v38 = v59;
      v39 = a3 + 1;
      v40 = 0;
      v54 = a3;
      do
      {
        v42 = (char *)*((_DWORD *)v38 + 1);
        v38 += 4;
        v41 = v42;
        v43 = sub_48AF4(a1, v42);
        if ( !v43 )
          _assert_fail("value", "dump.c", 0x16Bu, "do_dump");
        v44 = strlen(v41);
        sub_44E54(v41, v44, (int (__fastcall *)(char *, int, int))a5, a6, v60);
        if ( a5((__int16 *)v46, v49, a6) || sub_451E4(v43, v60, v39, v61, a5, a6) )
        {
LABEL_64:
          v14 = -1;
          sub_4815C(base);
          return v14;
        }
        if ( v40 < v36 )
        {
          if ( a5(&word_51D00, 1, a6) || sub_450DC(v60, v39, 1, a5, a6) )
            goto LABEL_64;
        }
        else if ( sub_450DC(v60, v54, 0, a5, a6) )
        {
          goto LABEL_64;
        }
        ++v40;
      }
      while ( v40 != nmemb );
      v45 = v58;
      v14 = 0;
      sub_4815C(base);
LABEL_68:
      sub_46568(v7, (char *)s);
      if ( !v45 )
        return a5((__int16 *)"}", 1, a6);
      return v14;
    case 1:
      v14 = sub_4518C(a4, a1, (char *)s);
      if ( v14 )
        return -1;
      v47 = sub_48E60(a1);
      if ( v8 )
      {
        if ( !v47 )
        {
LABEL_45:
          sub_46568(v7, (char *)s);
          return v14;
        }
      }
      else
      {
        if ( a5((__int16 *)"[", 1, a6) )
          return -1;
        if ( !v47 )
        {
          sub_46568(v7, (char *)s);
          return a5(&word_563F8, 1, a6);
        }
      }
      v28 = sub_450DC(v9, a3 + 1, 0, a5, a6);
      if ( v28 )
        return -1;
      v52 = v8;
      v29 = a3 + 1;
      v30 = v47;
      v48 = a3;
      v31 = v30;
      v32 = (unsigned int)v30 - 1;
      break;
    case 2:
      v16 = (char *)sub_49028(a1);
      v17 = sub_49044(a1);
      return sub_44E54(v16, (int)v17, (int (__fastcall *)(char *, int, int))a5, a6, v9);
    case 3:
      v18 = sub_49284((int)a1);
      v19 = snprintf((char *)s, 0x64u, "%lld", v18);
      return a5(s, v19, a6);
    case 4:
      sub_49330();
      v20 = sub_484B0((char *)s, 0x64u, (unsigned __int16)v9 >> 11);
      if ( v20 < 0 )
        return -1;
      return a5(s, v20, a6);
    case 5:
      return a5((__int16 *)"true", 4, a6);
    case 6:
      return a5((__int16 *)"false", 5, a6);
    case 7:
      return a5((__int16 *)"null", 4, a6);
    default:
      return -1;
  }
  do
  {
    v33 = sub_48E7C(a1, v28);
    v14 = sub_451E4(v33, v9, v29, v7, a5, a6);
    if ( v14 )
      return -1;
    if ( v32 <= v28 )
    {
      if ( sub_450DC(v9, v48, 0, a5, a6) )
        return -1;
    }
    else if ( a5(&word_51D00, 1, a6) || sub_450DC(v9, v29, 1, a5, a6) )
    {
      return -1;
    }
    ++v28;
  }
  while ( v31 != (_DWORD *)v28 );
  sub_46568(v7, (char *)s);
  if ( !v52 )
    return a5(&word_563F8, 1, a6);
  return v14;
}
// 45214: control flows out of bounds to 45218
// 51D00: using guessed type __int16 word_51D00;
// 563F8: using guessed type __int16 word_563F8;

//----- (000459F4) --------------------------------------------------------
int __fastcall sub_459F4(_DWORD *a1, int (__fastcall *a2)(__int16 *, int, int), int a3, int a4)
{
  int v8; // r4
  _DWORD v10[8]; // [sp+Ch] [bp-20h] BYREF

  if ( (a4 & 0x200) == 0 && (!a1 || *a1 > 1u) || sub_461E0(v10) )
    return -1;
  v8 = sub_451E4(a1, a4, 0, (int)v10, a2, a3);
  sub_4625C((int)v10);
  return v8;
}

//----- (00045A6C) --------------------------------------------------------
_BYTE *__fastcall sub_45A6C(_DWORD *a1, int a2)
{
  _BYTE *v4; // r4
  const char *v6; // r0
  _DWORD v7[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = (_BYTE *)sub_48218(v7);
  if ( v4 )
    return 0;
  if ( !sub_459F4(a1, (int (__fastcall *)(__int16 *, int, int))sub_44DAC, (int)v7, a2) )
  {
    v6 = (const char *)sub_4828C((int)v7);
    v4 = sub_481C0(v6);
  }
  sub_4824C((int)v7);
  return v4;
}

//----- (00045B14) --------------------------------------------------------
int __fastcall sub_45B14(_DWORD *a1, int a2, int a3)
{
  return sub_459F4(a1, (int (__fastcall *)(__int16 *, int, int))sub_44E04, a2, a3);
}

//----- (00045B28) --------------------------------------------------------
int __fastcall sub_45B28(_DWORD *a1, int a2, int a3)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = (FILE *)fopen64(a2, "w");
  if ( !v5 )
    return -1;
  v6 = sub_459F4(a1, (int (__fastcall *)(__int16 *, int, int))sub_44E04, (int)v5, a3);
  if ( fclose(v5) )
    return -1;
  return v6;
}
// 12830: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00045B8C) --------------------------------------------------------
int __fastcall sub_45B8C(_DWORD *a1, int a2, int a3)
{
  int v4; // [sp+4h] [bp-8h] BYREF

  v4 = a2;
  return sub_459F4(a1, (int (__fastcall *)(__int16 *, int, int))sub_44E20, (int)&v4, a3);
}

//----- (00045BB8) --------------------------------------------------------
int __fastcall sub_45BB8(unsigned __int16 *a1, unsigned int a2, int a3)
{
  unsigned int v3; // r12
  unsigned __int16 *v4; // r4
  int v5; // r3
  int v6; // lr
  int v7; // r6
  int v8; // r5
  int v9; // r3
  int v10; // lr
  int v11; // r2
  int v12; // r3
  int v13; // r5
  int v14; // r2
  int v15; // r12
  int v16; // r2
  int v17; // lr
  int v18; // r3
  int v19; // r2
  int v20; // r2
  int v21; // r3
  unsigned __int16 *v22; // r4
  int v23; // r6
  int v24; // r5
  int v25; // r7
  int v26; // r2
  int v27; // r3
  int v28; // r12
  int v29; // lr
  int v30; // r2
  int v31; // lr
  int v32; // r3
  int v33; // r12
  int v34; // r2
  int v35; // r5
  int v36; // r2
  int v37; // r3
  int v38; // r2
  unsigned __int16 *v39; // r4
  int v40; // r6
  int v41; // r2
  int v42; // r7
  int v43; // r8
  int v44; // r3
  int v45; // r12
  int v46; // lr
  int v47; // r2
  int v48; // lr
  int v49; // r3
  int v50; // r12
  int v51; // r2
  int v52; // r5
  int v53; // r2
  int v54; // r3
  int v55; // r2
  int v56; // r12
  int v57; // r3
  int v58; // r12
  int v59; // lr
  int v60; // r3
  int v61; // r12
  int v62; // r12
  int v64; // r4

  v3 = a3 - 559038737 + a2;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
    if ( a2 <= 0xC )
    {
      v5 = a3 - 559038737 + a2;
      v6 = v5;
    }
    else
    {
      v4 = a1 + 6;
      v5 = a3 - 559038737 + a2;
      v6 = v5;
      do
      {
        a2 -= 12;
        v7 = *((_DWORD *)v4 - 3);
        v8 = *((_DWORD *)v4 - 2);
        a1 = v4;
        v9 = v5 + *((_DWORD *)v4 - 1);
        v4 += 6;
        v10 = v6 + v8;
        v11 = (v7 - v9 + v3) ^ __ROR4__(v9, 28);
        v12 = v10 + v9;
        v13 = v11 + v12;
        v14 = (v10 - v11) ^ __ROR4__(v11, 26);
        v15 = v14 + v13;
        v16 = (v12 - v14) ^ __ROR4__(v14, 24);
        v17 = v16 + v15;
        v18 = (v13 - v16) ^ __ROR4__(v16, 16);
        v19 = v15 - v18;
        v3 = v18 + v17;
        v20 = v19 ^ __ROR4__(v18, 13);
        v21 = v17 - v20;
        v6 = v20 + v3;
        v5 = v21 ^ __ROR4__(v20, 28);
      }
      while ( a2 > 0xC );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        v56 = (*(_DWORD *)a1 & 0xFFFFFF) + v3;
        goto LABEL_28;
      case 4u:
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 5u:
        v6 += *((unsigned __int8 *)a1 + 4);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 6u:
        v6 += a1[2];
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 7u:
        v56 = v3 + *(_DWORD *)a1;
        v6 += *((_DWORD *)a1 + 1) & 0xFFFFFF;
        goto LABEL_28;
      case 8u:
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 9u:
        v64 = *((unsigned __int8 *)a1 + 8);
        goto LABEL_35;
      case 0xAu:
        v64 = a1[4];
        goto LABEL_35;
      case 0xBu:
        v5 += *((_DWORD *)a1 + 2) & 0xFFFFFF;
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      case 0xCu:
        v64 = *((_DWORD *)a1 + 2);
LABEL_35:
        v5 += v64;
        v6 += *((_DWORD *)a1 + 1);
        v56 = v3 + *(_DWORD *)a1;
        goto LABEL_28;
      default:
        return v5;
    }
  }
  if ( ((unsigned __int8)a1 & 1) == 0 )
  {
    if ( a2 <= 0xC )
    {
      v5 = a3 - 559038737 + a2;
      v6 = v5;
    }
    else
    {
      v22 = a1 + 6;
      v5 = a3 - 559038737 + a2;
      v6 = v5;
      do
      {
        v23 = *(v22 - 1);
        a2 -= 12;
        v24 = *(v22 - 2);
        v25 = *(v22 - 5);
        a1 = v22;
        v26 = *(v22 - 6);
        v22 += 6;
        v27 = v24 + (v23 << 16) + v5;
        v28 = (v26 + (v25 << 16) - v27 + v3) ^ __ROR4__(v27, 28);
        v29 = *(v22 - 10) + (*(v22 - 9) << 16) + v6;
        v30 = v29 - v28;
        v31 = v29 + v27;
        v32 = v30 ^ __ROR4__(v28, 26);
        v33 = v28 + v31;
        v34 = (v31 - v32) ^ __ROR4__(v32, 24);
        v35 = v34 + v32 + v33;
        v36 = (v33 - v34) ^ __ROR4__(v34, 16);
        v37 = v32 + v33 - v36;
        v3 = v36 + v35;
        v38 = v37 ^ __ROR4__(v36, 13);
        v6 = v38 + v3;
        v5 = (v35 - v38) ^ __ROR4__(v38, 28);
      }
      while ( a2 > 0xC );
    }
    switch ( a2 )
    {
      case 1u:
        goto LABEL_27;
      case 2u:
        goto LABEL_32;
      case 3u:
        v3 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_32:
        v56 = *a1 + v3;
        goto LABEL_28;
      case 4u:
        goto LABEL_50;
      case 5u:
        v6 += *((unsigned __int8 *)a1 + 4);
LABEL_50:
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      case 6u:
        goto LABEL_44;
      case 7u:
        v6 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_44:
        v56 = *a1 + v3 + (a1[1] << 16);
        v6 += a1[2];
        goto LABEL_28;
      case 8u:
        goto LABEL_46;
      case 9u:
        v5 += *((unsigned __int8 *)a1 + 8);
LABEL_46:
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      case 0xAu:
        goto LABEL_48;
      case 0xBu:
        v5 += *((unsigned __int8 *)a1 + 10) << 16;
LABEL_48:
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        v5 += a1[4];
        goto LABEL_28;
      case 0xCu:
        v5 += a1[4] + (a1[5] << 16);
        v6 += a1[2] + (a1[3] << 16);
        v56 = *a1 + v3 + (a1[1] << 16);
        goto LABEL_28;
      default:
        return v5;
    }
  }
  if ( a2 > 0xC )
  {
    v39 = a1 + 6;
    v5 = a3 - 559038737 + a2;
    v6 = v5;
    do
    {
      v40 = *((unsigned __int8 *)v39 - 2);
      a2 -= 12;
      v41 = *((unsigned __int8 *)v39 - 10);
      v42 = *((unsigned __int8 *)v39 - 3);
      a1 = v39;
      v43 = *((unsigned __int8 *)v39 - 11);
      v39 += 6;
      v44 = (v40 << 16) + (v42 << 8) + *((unsigned __int8 *)v39 - 16) + (*((unsigned __int8 *)v39 - 13) << 24) + v5;
      v45 = ((v41 << 16)
           + (v43 << 8)
           + *((unsigned __int8 *)v39 - 24)
           + (*((unsigned __int8 *)v39 - 21) << 24)
           - v44
           + v3)
          ^ __ROR4__(v44, 28);
      v46 = (*((unsigned __int8 *)v39 - 18) << 16)
          + (*((unsigned __int8 *)v39 - 19) << 8)
          + *((unsigned __int8 *)v39 - 20)
          + (*((unsigned __int8 *)v39 - 17) << 24)
          + v6;
      v47 = v46 - v45;
      v48 = v46 + v44;
      v49 = v47 ^ __ROR4__(v45, 26);
      v50 = v45 + v48;
      v51 = (v48 - v49) ^ __ROR4__(v49, 24);
      v52 = v51 + v49 + v50;
      v53 = (v50 - v51) ^ __ROR4__(v51, 16);
      v54 = v49 + v50 - v53;
      v3 = v53 + v52;
      v55 = v54 ^ __ROR4__(v53, 13);
      v6 = v55 + v3;
      v5 = (v52 - v55) ^ __ROR4__(v55, 28);
    }
    while ( a2 > 0xC );
  }
  else
  {
    v5 = a3 - 559038737 + a2;
    v6 = v5;
  }
  switch ( a2 )
  {
    case 1u:
      goto LABEL_27;
    case 2u:
      goto LABEL_26;
    case 3u:
      goto LABEL_25;
    case 4u:
      goto LABEL_24;
    case 5u:
      goto LABEL_23;
    case 6u:
      goto LABEL_22;
    case 7u:
      goto LABEL_21;
    case 8u:
      goto LABEL_20;
    case 9u:
      goto LABEL_19;
    case 0xAu:
      goto LABEL_18;
    case 0xBu:
      goto LABEL_17;
    case 0xCu:
      v5 += *((unsigned __int8 *)a1 + 11) << 24;
LABEL_17:
      v5 += *((unsigned __int8 *)a1 + 10) << 16;
LABEL_18:
      v5 += *((unsigned __int8 *)a1 + 9) << 8;
LABEL_19:
      v5 += *((unsigned __int8 *)a1 + 8);
LABEL_20:
      v6 += *((unsigned __int8 *)a1 + 7) << 24;
LABEL_21:
      v6 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_22:
      v6 += *((unsigned __int8 *)a1 + 5) << 8;
LABEL_23:
      v6 += *((unsigned __int8 *)a1 + 4);
LABEL_24:
      v3 += *((unsigned __int8 *)a1 + 3) << 24;
LABEL_25:
      v3 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_26:
      v3 += *((unsigned __int8 *)a1 + 1) << 8;
LABEL_27:
      v56 = *(unsigned __int8 *)a1 + v3;
LABEL_28:
      v57 = (v5 ^ v6) - __ROR4__(v6, 18);
      v58 = (v56 ^ v57) - __ROR4__(v57, 21);
      v59 = (v6 ^ v58) - __ROR4__(v58, 7);
      v60 = (v57 ^ v59) - __ROR4__(v59, 16);
      v61 = (v58 ^ v60) - __ROR4__(v60, 28);
      v62 = (v59 ^ v61) - __ROR4__(v61, 18);
      v5 = (v60 ^ v62) - __ROR4__(v62, 8);
      break;
    default:
      return v5;
  }
  return v5;
}
// 45C68: control flows out of bounds to 45C6C
// 45D50: control flows out of bounds to 45D54
// 45E74: control flows out of bounds to 45E78

//----- (000460FC) --------------------------------------------------------
int __fastcall sub_460FC(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4

  v4 = *a2;
  if ( *a2 == a1 + 12 && v4 == a2[1] )
    return 0;
  while ( *(_DWORD *)(v4 + 16) != a4 || strcmp((const char *)(v4 + 24), s2) )
  {
    if ( a2[1] == v4 )
      return 0;
    v4 = *(_DWORD *)(v4 + 4);
  }
  return v4;
}

//----- (00046170) --------------------------------------------------------
void __fastcall sub_46170(int a1)
{
  _DWORD *v1; // r6
  _DWORD *v2; // r4
  int v3; // r0
  _DWORD *v4; // r5
  unsigned int *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r2
  void *v8; // r0

  v1 = (_DWORD *)(a1 + 12);
  v2 = *(_DWORD **)(a1 + 16);
  if ( v2 != (_DWORD *)(a1 + 12) )
  {
    do
    {
      v3 = v2[5];
      v4 = (_DWORD *)v2[1];
      if ( v3 )
      {
        v5 = (unsigned int *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 4) != -1 )
        {
          __dmb(0xBu);
          do
          {
            v6 = __ldrex(v5);
            v7 = v6 - 1;
          }
          while ( __strex(v7, v5) );
          if ( !v7 )
            sub_4942C();
        }
      }
      v8 = v2;
      v2 = v4;
      sub_4815C(v8);
    }
    while ( v4 != v1 );
  }
}
// 4942C: using guessed type int sub_4942C(void);

//----- (000461E0) --------------------------------------------------------
int __fastcall sub_461E0(_DWORD *a1)
{
  _DWORD *v2; // r0
  int v3; // r12
  _DWORD *v4; // r3
  _DWORD *v5; // r2

  *a1 = 0;
  a1[2] = 3;
  v2 = sub_48144((void *)0x40);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1[2];
  v4 = a1 + 3;
  a1[4] = a1 + 3;
  a1[3] = a1 + 3;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  if ( 1 << v3 )
  {
    v5 = (_DWORD *)((char *)v2 + (8 << v3));
    do
    {
      v2[1] = v4;
      *v2 = v4;
      v2 += 2;
    }
    while ( v2 != v5 );
  }
  return 0;
}

//----- (0004625C) --------------------------------------------------------
void __fastcall sub_4625C(int a1)
{
  sub_46170(a1);
  sub_4815C(*(void **)(a1 + 4));
}

//----- (00046274) --------------------------------------------------------
int __fastcall sub_46274(int a1, char *a2, int a3)
{
  int v4; // r8
  int v7; // r8
  _DWORD *v8; // r5
  _DWORD *v9; // r1
  _DWORD *v10; // r3
  _DWORD *v11; // r3
  int v12; // r8
  int v13; // lr
  _DWORD *v14; // r12
  int v15; // r0
  _DWORD *v16; // r2
  _DWORD *v17; // r0
  int v18; // r2
  size_t v19; // r10
  int v20; // r9
  int *v21; // r5
  int v22; // r0
  int v23; // r8
  _DWORD *v24; // r0
  unsigned int *v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r2
  void *v29; // r0
  _DWORD *v30; // r8
  int v31; // r3
  _DWORD *v32; // r2
  int v33; // r1
  int v34; // r3

  v4 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)a1 >> v4 )
  {
    v7 = v4 + 1;
    v8 = sub_48144((void *)(8 << v7));
    if ( !v8 )
      return -1;
    sub_4815C(*(void **)(a1 + 4));
    *(_DWORD *)(a1 + 4) = v8;
    *(_DWORD *)(a1 + 8) = v7;
    v9 = (_DWORD *)(a1 + 12);
    if ( 1 << v7 )
    {
      v10 = v8;
      do
      {
        v10[1] = v9;
        *v10 = v9;
        v10 += 2;
      }
      while ( (_DWORD *)((char *)v8 + (8 << v7)) != v10 );
    }
    v11 = *(_DWORD **)(a1 + 16);
    *(_DWORD *)(a1 + 12) = v9;
    v12 = ~(-1 << v7);
    *(_DWORD *)(a1 + 16) = v9;
    if ( v11 != v9 )
    {
      do
      {
        while ( 1 )
        {
          v14 = (_DWORD *)v11[1];
          v15 = v11[4] & v12;
          v16 = (_DWORD *)v8[2 * v15];
          v17 = &v8[2 * v15];
          if ( v16 == v9 && v9 == (_DWORD *)v17[1] )
            break;
          v13 = *v16;
          v11[1] = v16;
          *v11 = v13;
          *(_DWORD *)(*v16 + 4) = v11;
          *v16 = v11;
          *v17 = v11;
          v11 = v14;
          if ( v14 == v9 )
            goto LABEL_12;
        }
        v18 = *(_DWORD *)(a1 + 12);
        v11[1] = v9;
        *v11 = v18;
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = v11;
        *(_DWORD *)(a1 + 12) = v11;
        v17[1] = v11;
        *v17 = v11;
        v11 = v14;
      }
      while ( v14 != v9 );
LABEL_12:
      v8 = *(_DWORD **)(a1 + 4);
      v12 = ~(-1 << *(_DWORD *)(a1 + 8));
    }
  }
  else
  {
    v8 = *(_DWORD **)(a1 + 4);
    v12 = ~(-1 << v4);
  }
  v19 = strlen(a2);
  v20 = sub_45BB8((unsigned __int16 *)a2, v19, dword_72C18);
  v21 = &v8[2 * (v12 & v20)];
  v22 = sub_460FC(a1, v21, a2, v20);
  v23 = v22;
  if ( v22 )
  {
    v24 = *(_DWORD **)(v22 + 20);
    if ( v24 && v24[1] != -1 )
    {
      v25 = v24 + 1;
      __dmb(0xBu);
      do
      {
        v26 = __ldrex(v25);
        v27 = v26 - 1;
      }
      while ( __strex(v27, v25) );
      if ( !v27 )
        sub_4942C(v24);
    }
    *(_DWORD *)(v23 + 20) = a3;
    return 0;
  }
  v29 = sub_48144((void *)(v19 + 25));
  v30 = v29;
  if ( !v29 )
    return -1;
  *((_DWORD *)v29 + 4) = v20;
  strncpy((char *)v29 + 24, a2, v19 + 1);
  v31 = *v21;
  v32 = v30 + 2;
  v30[5] = a3;
  v30[1] = v30;
  *v30 = v30;
  v30[3] = v30 + 2;
  v30[2] = v30 + 2;
  if ( v31 == a1 + 12 && v31 == v21[1] )
  {
    *v30 = *(_DWORD *)(a1 + 12);
    v30[1] = v31;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = v30;
    *(_DWORD *)(a1 + 12) = v30;
    v21[1] = (int)v30;
    *v21 = (int)v30;
  }
  else
  {
    *v30 = *(_DWORD *)v31;
    v30[1] = v31;
    *(_DWORD *)(*(_DWORD *)v31 + 4) = v30;
    *(_DWORD *)v31 = v30;
    *v21 = (int)v30;
  }
  v33 = *(_DWORD *)(a1 + 20);
  v34 = *(_DWORD *)a1;
  v30[3] = a1 + 20;
  v30[2] = v33;
  *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4) = v32;
  *(_DWORD *)(a1 + 20) = v32;
  *(_DWORD *)a1 = v34 + 1;
  return 0;
}
// 72C18: using guessed type int dword_72C18;

//----- (00046508) --------------------------------------------------------
int __fastcall sub_46508(int a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = sub_45BB8((unsigned __int16 *)s, v4, dword_72C18);
  result = sub_460FC(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v5 & ~(-1 << *(_DWORD *)(a1 + 8)))), s, v5);
  if ( result )
    return *(_DWORD *)(result + 20);
  return result;
}
// 72C18: using guessed type int dword_72C18;

//----- (00046568) --------------------------------------------------------
int __fastcall sub_46568(_DWORD *a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int v6; // r9
  int v7; // r5
  int *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r4
  _DWORD *v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // r1
  int v15; // r2
  _DWORD *v16; // r0
  int v17; // r3
  unsigned int *v19; // r3
  unsigned int v20; // r2
  unsigned int v21; // r2
  bool v22; // zf

  v4 = strlen(s);
  v5 = sub_45BB8((unsigned __int16 *)s, v4, dword_72C18);
  v6 = a1[1];
  v7 = v5 & ~(-1 << a1[2]);
  v8 = (int *)(v6 + 8 * v7);
  v9 = (_DWORD *)sub_460FC((int)a1, v8, s, v5);
  v10 = v9;
  if ( !v9 )
    return -1;
  v11 = (_DWORD *)v8[1];
  v12 = v9[1];
  v13 = *v9;
  if ( v9 == *(_DWORD **)(v6 + 8 * v7) )
  {
    v22 = v9 == v11;
    if ( v9 == v11 )
      v11 = a1 + 3;
    else
      *(_DWORD *)(v6 + 8 * v7) = v12;
    if ( v22 )
    {
      v8[1] = (int)v11;
      *(_DWORD *)(v6 + 8 * v7) = v11;
    }
  }
  else if ( v9 == v11 )
  {
    v8[1] = v13;
  }
  *(_DWORD *)(v13 + 4) = v12;
  v14 = (int *)v9[1];
  v15 = v9[3];
  v16 = (_DWORD *)v9[5];
  *v14 = v13;
  v17 = v10[2];
  *(_DWORD *)(v17 + 4) = v15;
  *(_DWORD *)v10[3] = v17;
  if ( v16 && v16[1] != -1 )
  {
    v19 = v16 + 1;
    __dmb(0xBu);
    do
    {
      v20 = __ldrex(v19);
      v21 = v20 - 1;
    }
    while ( __strex(v21, v19) );
    if ( !v21 )
      sub_4942C(v16);
  }
  sub_4815C(v10);
  --*a1;
  return 0;
}
// 72C18: using guessed type int dword_72C18;

//----- (00046688) --------------------------------------------------------
int __fastcall sub_46688(_DWORD *a1)
{
  _DWORD *v2; // r2
  int result; // r0
  _DWORD *v4; // r3
  _DWORD *v5; // r1

  sub_46170((int)a1);
  v2 = a1 + 3;
  result = a1[2];
  if ( 1 << result )
  {
    v4 = (_DWORD *)a1[1];
    v5 = (_DWORD *)((char *)v4 + (8 << result));
    do
    {
      v4[1] = v2;
      *v4 = v2;
      v4 += 2;
    }
    while ( v4 != v5 );
  }
  a1[4] = v2;
  a1[3] = v2;
  a1[6] = a1 + 5;
  a1[5] = a1 + 5;
  *a1 = 0;
  return result;
}

//----- (000466E4) --------------------------------------------------------
int __fastcall sub_466E4(int a1)
{
  if ( *(_DWORD *)(a1 + 24) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a1 + 24);
}

//----- (000466FC) --------------------------------------------------------
int __fastcall sub_466FC(int a1, char *s)
{
  size_t v4; // r0
  int v5; // r0
  int result; // r0

  v4 = strlen(s);
  v5 = sub_45BB8((unsigned __int16 *)s, v4, dword_72C18);
  result = sub_460FC(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v5 & ~(-1 << *(_DWORD *)(a1 + 8)))), s, v5);
  if ( result )
    result += 8;
  return result;
}
// 72C18: using guessed type int dword_72C18;

//----- (0004675C) --------------------------------------------------------
int __fastcall sub_4675C(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 4) == a1 + 20 )
    return 0;
  else
    return *(_DWORD *)(a2 + 4);
}

//----- (00046774) --------------------------------------------------------
int __fastcall sub_46774(int a1)
{
  return a1 + 16;
}

//----- (0004677C) --------------------------------------------------------
int __fastcall sub_4677C(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (00046784) --------------------------------------------------------
void __fastcall sub_46784(int a1, int a2)
{
  _DWORD *v3; // r0
  unsigned int *v4; // r3
  unsigned int v5; // r2
  unsigned int v6; // r2

  v3 = *(_DWORD **)(a1 + 12);
  if ( !v3 )
    goto LABEL_6;
  if ( v3[1] == -1 )
    goto LABEL_6;
  v4 = v3 + 1;
  __dmb(0xBu);
  do
  {
    v5 = __ldrex(v4);
    v6 = v5 - 1;
  }
  while ( __strex(v6, v4) );
  if ( v6 )
  {
LABEL_6:
    *(_DWORD *)(a1 + 12) = a2;
  }
  else
  {
    sub_4942C(v3);
    *(_DWORD *)(a1 + 12) = a2;
  }
}

//----- (000467F0) --------------------------------------------------------
int __fastcall sub_467F0(int result)
{
  int v1; // r1
  unsigned __int8 v2; // r2
  int v3; // r3
  int v4; // r0
  int v5; // r5
  ssize_t v6; // r7
  int v7; // r5
  struct timeval v8; // [sp+0h] [bp-Ch] BYREF

  if ( !dword_72C18 )
  {
    v1 = result;
    result = 1;
    do
      v2 = __ldrex(algn_72C1C);
    while ( __strex(1u, algn_72C1C) );
    if ( v2 )
    {
      do
      {
        result = sched_yield();
        v3 = dword_72C18;
        __dmb(0xBu);
      }
      while ( !v3 );
    }
    else
    {
      if ( !v1 )
      {
        v4 = open64("/dev/urandom");
        v5 = v4;
        if ( v4 == -1 || (v6 = read(v4, &v8, 4u), close(v5), v6 != 4) )
        {
          gettimeofday(&v8, 0);
          v7 = v8.tv_usec ^ v8.tv_sec;
          result = getpid();
          v1 = result ^ v7;
        }
        else
        {
          result = LOBYTE(v8.tv_sec);
          v1 = HIBYTE(v8.tv_sec) | ((BYTE2(v8.tv_sec) | ((BYTE1(v8.tv_sec) | (LOBYTE(v8.tv_sec) << 8)) << 8)) << 8);
        }
        if ( !v1 )
          v1 = 1;
      }
      __dmb(0xBu);
      dword_72C18 = v1;
    }
  }
  return result;
}
// 128F0: using guessed type int __fastcall open64(_DWORD);
// 72C18: using guessed type int dword_72C18;
// 72C1C: using guessed type _BYTE[4];

//----- (000468EC) --------------------------------------------------------
int __fastcall sub_468EC(_DWORD *a1)
{
  int v1; // r2
  int v2; // r3
  bool v3; // zf

  v1 = a1[1];
  v2 = *(unsigned __int8 *)(*a1 + v1);
  v3 = v2 == 0;
  if ( *(_BYTE *)(*a1 + v1) )
    ++v1;
  else
    v2 = -1;
  if ( !v3 )
    a1[1] = v1;
  return v2;
}

//----- (00046910) --------------------------------------------------------
int __fastcall sub_46910(int a1)
{
  __int64 v1; // r2

  v1 = *(_QWORD *)(a1 + 4);
  if ( HIDWORD(v1) >= (unsigned int)v1 )
    return -1;
  LODWORD(v1) = HIDWORD(v1) + 1;
  HIDWORD(v1) = *(unsigned __int8 *)(*(_DWORD *)a1 + HIDWORD(v1));
  *(_DWORD *)(a1 + 8) = v1;
  return HIDWORD(v1);
}

//----- (00046934) --------------------------------------------------------
int __fastcall sub_46934(_DWORD *a1)
{
  unsigned int v1; // r3
  int (__fastcall *v3)(_DWORD *, int, _DWORD); // r3
  int v4; // r0
  int result; // r0

  v1 = a1[257];
  if ( v1 < a1[256] )
    goto LABEL_4;
  v3 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
  a1[257] = 0;
  v4 = v3(a1, 1024, a1[259]);
  a1[256] = v4;
  if ( (unsigned int)(v4 - 1) <= 0xFFFFFFFD )
  {
    v1 = a1[257];
LABEL_4:
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
    return result;
  }
  return -1;
}

//----- (00046990) --------------------------------------------------------
int sub_46990(int result, _DWORD *a2, int a3, const char *a4, ...)
{
  int v4; // r6
  const char *v7; // r0
  int v8; // r8
  int v9; // r7
  int v10; // r9
  char *v11; // r3
  char s[160]; // [sp+18h] [bp-144h] BYREF
  char v13[159]; // [sp+B8h] [bp-A4h] BYREF
  char v14; // [sp+157h] [bp-5h]
  const char *varg_r3; // [sp+17Ch] [bp+20h]
  va_list va; // [sp+180h] [bp+24h] BYREF

  va_start(va, a4);
  varg_r3 = a4;
  v4 = result;
  if ( result )
  {
    vsnprintf(s, 0xA0u, varg_r3, va);
    s[159] = 0;
    if ( a2 )
    {
      v7 = (const char *)sub_4828C((int)(a2 + 10));
      v8 = a2[6];
      v9 = a2[7];
      v10 = a2[9];
      if ( v7 && *v7 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v13, 0xA0u, "%s near '%s'", s, v7);
          v11 = v13;
          v14 = 0;
          return sub_4A21C(v4, v8, v9, v10, a3, "%s", v11);
        }
      }
      else
      {
        if ( a3 == 8 )
          LOBYTE(a3) = 6;
        if ( a2[5] != -2 )
        {
          snprintf(v13, 0xA0u, "%s near end of file", s);
          v11 = v13;
          v14 = 0;
          return sub_4A21C(v4, v8, v9, v10, a3, "%s", v11);
        }
      }
      v11 = s;
    }
    else
    {
      v9 = -1;
      v11 = s;
      v10 = 0;
      v8 = -1;
    }
    return sub_4A21C(v4, v8, v9, v10, a3, "%s", v11);
  }
  return result;
}

//----- (00046AC0) --------------------------------------------------------
void __fastcall sub_46AC0(int a1)
{
  if ( *(_DWORD *)(a1 + 60) == 256 )
  {
    sub_4815C(*(void **)(a1 + 64));
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 0;
    sub_4824C(a1 + 40);
  }
  else
  {
    sub_4824C(a1 + 40);
  }
}

//----- (00046B00) --------------------------------------------------------
int __fastcall sub_46B00(int *a1)
{
  _BYTE buf[5]; // [sp+7h] [bp-5h] BYREF

  if ( read(*a1, buf, 1u) == 1 )
    return buf[0];
  else
    return -1;
}

//----- (00046B2C) --------------------------------------------------------
int __fastcall sub_46B2C(_BYTE *a1)
{
  _BYTE *v1; // r3
  int result; // r0
  _BYTE *v3; // lr
  int v4; // r2
  int v5; // t1
  int v6; // r0
  int v7; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 0x135u, "decode_unicode_escape");
  v1 = a1;
  result = 0;
  v3 = v1 + 4;
  while ( 1 )
  {
    v5 = (unsigned __int8)*++v1;
    v4 = v5;
    v6 = 16 * result;
    v7 = v5 - 48;
    if ( (unsigned __int8)(v5 - 48) > 9u )
      break;
    result = v7 + v6;
LABEL_10:
    if ( v1 == v3 )
      return result;
  }
  if ( (unsigned int)(v4 - 97) <= 0x19 )
  {
    result = v4 - 87 + v6;
    goto LABEL_10;
  }
  if ( (unsigned int)(v4 - 65) <= 0x19 )
  {
    result = v4 - 55 + v6;
    goto LABEL_10;
  }
  return -1;
}

//----- (00046BC0) --------------------------------------------------------
_DWORD *__fastcall sub_46BC0(_DWORD *result, int a2)
{
  _DWORD *v2; // r4
  int v4; // r2
  int v5; // r3
  int v6; // r3

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    --result[9];
    if ( a2 == 10 )
    {
      v4 = result[8];
      --result[6];
      result[7] = v4;
    }
    else
    {
      result = (_DWORD *)sub_486DC((unsigned __int8)a2);
      if ( result )
        --v2[7];
    }
    v5 = v2[4];
    if ( !v5 )
      _assert_fail("stream->buffer_pos > 0", "load.c", 0xEEu, "stream_unget");
    v6 = v5 - 1;
    v2[4] = v6;
    if ( *((unsigned __int8 *)v2 + v6 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 0xF0u, "stream_unget");
  }
  return result;
}

//----- (00046C7C) --------------------------------------------------------
int __fastcall sub_46C7C(int a1, int a2)
{
  int v2; // r2
  int v4; // r3
  int v5; // r6
  int v6; // r1
  int v8; // r0
  int v9; // r5
  int v11; // r3
  int v12; // r2
  unsigned int v13; // r0
  unsigned int v14; // r8
  _BYTE *v15; // r6
  _BYTE *v16; // r9
  int v17; // r2
  char arg[4]; // [sp+0h] [bp-8h]

  v2 = *(_DWORD *)(a1 + 16);
  v4 = a1 + v2;
  v5 = *(unsigned __int8 *)(a1 + v2 + 8);
  if ( *(_BYTE *)(a1 + v2 + 8) )
  {
    v6 = v2 + 1;
    goto LABEL_8;
  }
  v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v9 = v8;
  if ( v8 == -1 )
  {
    *(_DWORD *)(a1 + 20) = -1;
    return v9;
  }
  *(_DWORD *)(a1 + 16) = v5;
  *(_BYTE *)(a1 + 8) = v8;
  if ( (unsigned int)(v8 - 128) <= 0x7F )
  {
    v13 = sub_486DC((unsigned __int8)v8);
    v14 = v13;
    if ( !v13 )
      goto LABEL_20;
    if ( v13 <= 1 )
      _assert_fail("count >= 2", "load.c", 0xBDu, "stream_get");
    v15 = (_BYTE *)(a1 + 9);
    v16 = (_BYTE *)(a1 + 8 + v13);
    do
      *v15++ = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    while ( v16 != v15 );
    if ( !sub_48748((char *)(a1 + 8), v14, 0) )
    {
LABEL_20:
      *(_DWORD *)arg = v9;
      v9 = -2;
      *(_DWORD *)(a1 + 20) = -2;
      sub_46990(a2, (_DWORD *)a1, 5, "unable to decode byte 0x%x", *(_DWORD *)arg);
      return v9;
    }
    *(_BYTE *)(a1 + v14 + 8) = 0;
    v17 = *(_DWORD *)(a1 + 16);
    v6 = v17 + 1;
    v4 = a1 + v17;
  }
  else
  {
    v6 = 1;
    v4 = a1;
    *(_BYTE *)(a1 + 9) = v5;
  }
LABEL_8:
  *(_DWORD *)(a1 + 16) = v6;
  v9 = *(unsigned __int8 *)(v4 + 8);
  ++*(_DWORD *)(a1 + 36);
  if ( v9 != 10 )
  {
    if ( sub_486DC(v9) )
      ++*(_DWORD *)(a1 + 28);
    return v9;
  }
  v11 = *(_DWORD *)(a1 + 24);
  v12 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = v11 + 1;
  *(_DWORD *)(a1 + 32) = v12;
  return 10;
}

//----- (00046E04) --------------------------------------------------------
int __fastcall sub_46E04(int a1, int a2)
{
  int v3; // r4

  v3 = *(_DWORD *)(a1 + 20);
  if ( !v3 )
    v3 = sub_46C7C(a1, a2);
  if ( (unsigned int)(v3 + 2) > 1 )
    sub_48374((const void **)(a1 + 40), v3);
  return v3;
}

//----- (00046E44) --------------------------------------------------------
_DWORD *__fastcall sub_46E44(_DWORD *result, int a2)
{
  _DWORD *v2; // r5
  char v4; // r1
  int v5; // r2

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    sub_46BC0(result, a2);
    result = (_DWORD *)sub_48398(v2 + 10, v4, v5);
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "load.c", 0x11Au, "lex_unget_unsave");
  }
  return result;
}
// 46E64: variable 'v4' is possibly undefined
// 46E64: variable 'v5' is possibly undefined

//----- (00046E90) --------------------------------------------------------
unsigned int __fastcall sub_46E90(int a1, int a2)
{
  const void **v2; // r7
  unsigned int v5; // r4
  bool v6; // cc
  int v7; // r3
  int v8; // r4
  bool v9; // zf
  _BOOL4 v10; // r2
  bool v11; // cc
  int v12; // r0
  const char *v13; // r4
  int v15; // r1
  int v16; // r0
  unsigned int v17; // r4
  int v18; // r0
  bool v19; // zf
  int v20; // r0
  bool v21; // zf
  const char *v22; // r4
  int *v23; // r7
  __int64 v24; // r0
  char i; // r1
  int v26; // r3
  int v27; // r2
  double v28; // r2
  int v29; // r8
  unsigned int v30; // r3
  unsigned int v31; // r4
  bool v32; // cc
  int v33; // r1
  _BYTE *v34; // r8
  unsigned __int8 *j; // r4
  int v36; // r3
  unsigned int v37; // r3
  int v38; // r0
  int v39; // r11
  int v40; // r0
  int v41; // r1
  int v42; // r0
  int v43; // r2
  const char *v44; // r3
  const char *v45; // r3
  char arg[4]; // [sp+0h] [bp-1Ch]
  int v47; // [sp+Ch] [bp-10h]
  double endptr; // [sp+10h] [bp-Ch] BYREF

  v2 = (const void **)(a1 + 40);
  sub_48278(a1 + 40);
  if ( *(_DWORD *)(a1 + 60) == 256 )
  {
    sub_4815C(*(void **)(a1 + 64));
    *(_DWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 0;
  }
  do
  {
    v5 = *(_DWORD *)(a1 + 20);
    if ( !v5 )
      v5 = sub_46C7C(a1, a2);
    v6 = v5 > 0x20;
    if ( v5 != 32 )
      v6 = v5 - 9 > 1;
    v7 = !v6;
  }
  while ( !v6 || v5 == 13 );
  if ( v5 == -1 )
  {
    *(_DWORD *)(a1 + 60) = v7;
    return v7;
  }
  if ( v5 == -2 )
    goto LABEL_35;
  sub_48374(v2, v5);
  if ( (((v5 & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_38;
  v9 = v5 == 44;
  if ( v5 != 44 )
    v9 = v5 == 58;
  v10 = v9;
  if ( v9 )
    goto LABEL_38;
  if ( v5 != 34 )
  {
    v11 = v5 > 0x2D;
    if ( v5 != 45 )
      v11 = v5 - 48 > 9;
    if ( !v11 )
    {
      *(_DWORD *)(a1 + 60) = -1;
      if ( v5 == 45 )
      {
        v42 = sub_46E04(a1, a2);
        v41 = v42;
        if ( v42 != 48 )
        {
          if ( (unsigned int)(v42 - 48) > 9 )
            goto LABEL_118;
          goto LABEL_58;
        }
      }
      else if ( v5 != 48 )
      {
        do
LABEL_58:
          v20 = sub_46E04(a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
        goto LABEL_59;
      }
      v20 = sub_46E04(a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
LABEL_117:
        v41 = v20;
LABEL_118:
        sub_46E44((_DWORD *)a1, v41);
        return *(_DWORD *)(a1 + 60);
      }
LABEL_59:
      if ( (*(_DWORD *)(a1 + 52) & 8) != 0 )
        goto LABEL_70;
      v21 = v20 == 46;
      if ( v20 != 46 )
        v21 = v20 == 69;
      if ( v21 )
      {
LABEL_70:
        if ( v20 == 46 )
        {
          v33 = *(_DWORD *)(a1 + 20);
          if ( !v33 )
            v33 = sub_46C7C(a1, a2);
          if ( (unsigned int)(v33 - 48) > 9 )
          {
            sub_46BC0((_DWORD *)a1, v33);
            return *(_DWORD *)(a1 + 60);
          }
          sub_48374(v2, v33);
          do
            v20 = sub_46E04(a1, a2);
          while ( (unsigned int)(v20 - 48) <= 9 );
        }
        if ( (v20 & 0xFFFFFFDF) != 0x45 )
          goto LABEL_72;
      }
      else if ( v20 != 101 )
      {
        sub_46E44((_DWORD *)a1, v20);
        v22 = (const char *)sub_4828C((int)v2);
        v23 = _errno_location();
        *v23 = 0;
        v24 = strtoll(v22, (char **)&endptr, 10);
        if ( *v23 == 34 )
        {
          if ( v24 >= 0 )
            LOWORD(v45) = 27112;
          else
            LOWORD(v45) = 27084;
          HIWORD(v45) = 5;
          sub_46990(a2, (_DWORD *)a1, 15, v45);
          return *(_DWORD *)(a1 + 60);
        }
        else
        {
          if ( (const char *)LODWORD(endptr) != &v22[*(_DWORD *)(a1 + 44)] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 0x21Du, "lex_scan_number");
          v8 = 257;
          *(_QWORD *)(a1 + 64) = v24;
          *(_DWORD *)(a1 + 60) = 257;
        }
        return v8;
      }
      v20 = sub_46E04(a1, a2);
      if ( ((v20 - 43) & 0xFFFFFFFD) == 0 )
        v20 = sub_46E04(a1, a2);
      if ( (unsigned int)(v20 - 48) <= 9 )
      {
        do
          v20 = sub_46E04(a1, a2);
        while ( (unsigned int)(v20 - 48) <= 9 );
LABEL_72:
        sub_46E44((_DWORD *)a1, v20);
        if ( sub_483C0((int)v2, &endptr) )
        {
          sub_46990(a2, (_DWORD *)a1, 15, "real number overflow");
          return *(_DWORD *)(a1 + 60);
        }
        else
        {
          v28 = endptr;
          v8 = 258;
          *(_DWORD *)(a1 + 60) = 258;
          *(double *)(a1 + 64) = v28;
        }
        return v8;
      }
      goto LABEL_117;
    }
    if ( (v5 & 0xFFFFFFDF) - 65 <= 0x19 )
    {
      do
        v12 = sub_46E04(a1, a2);
      while ( (v12 & 0xFFFFFFDF) - 65 <= 0x19 );
      sub_46E44((_DWORD *)a1, v12);
      v13 = (const char *)sub_4828C((int)v2);
      if ( !strcmp(v13, "true") )
      {
        v8 = 259;
        *(_DWORD *)(a1 + 60) = 259;
        return v8;
      }
      if ( strcmp(v13, "false") )
      {
        if ( !strcmp(v13, "null") )
        {
          v8 = 261;
          *(_DWORD *)(a1 + 60) = 261;
          return v8;
        }
        goto LABEL_35;
      }
      v5 = 260;
LABEL_38:
      *(_DWORD *)(a1 + 60) = v5;
      return v5;
    }
    for ( i = *(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8); i; i = *(_BYTE *)(a1 + v26 + 8) )
    {
      sub_48374(v2, i);
      v26 = *(_DWORD *)(a1 + 16) + 1;
      v27 = *(_DWORD *)(a1 + 36) + 1;
      *(_DWORD *)(a1 + 16) = v26;
      *(_DWORD *)(a1 + 36) = v27;
    }
LABEL_35:
    v8 = -1;
    *(_DWORD *)(a1 + 60) = -1;
    return v8;
  }
  *(_DWORD *)(a1 + 64) = v10;
  *(_DWORD *)(a1 + 60) = -1;
LABEL_40:
  v15 = a2;
  v16 = a1;
  while ( 1 )
  {
    v17 = sub_46E04(v16, v15);
LABEL_42:
    if ( v17 == 34 )
    {
      v34 = sub_48144((void *)(*(_DWORD *)(a1 + 44) + 1));
      if ( !v34 )
        goto LABEL_55;
      *(_DWORD *)(a1 + 64) = v34;
      for ( j = (unsigned __int8 *)(sub_4828C((int)v2) + 1); ; j += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v36 = *j;
            if ( v36 == 34 )
            {
              *v34 = 0;
              v8 = 256;
              v43 = *(_DWORD *)(a1 + 64);
              *(_DWORD *)(a1 + 60) = 256;
              *(_DWORD *)(a1 + 68) = &v34[-v43];
              return v8;
            }
            if ( v36 == 92 )
              break;
            *v34 = v36;
            ++j;
            ++v34;
          }
          v37 = j[1];
          if ( v37 != 117 )
            break;
          v38 = sub_46B2C(j + 1);
          v39 = v38;
          if ( v38 < 0 )
          {
            LOWORD(v44) = (unsigned __int16)"invalid Unicode escape '%.6s'";
            *(_DWORD *)arg = j;
LABEL_138:
            HIWORD(v44) = (unsigned int)"invalid Unicode escape '%.6s'" >> 16;
            sub_46990(a2, (_DWORD *)a1, 8, v44, *(_DWORD *)arg);
            goto LABEL_55;
          }
          v47 = v38 - 55296;
          if ( (unsigned int)(v38 - 55296) >= 0x400 )
          {
            if ( (unsigned int)(v38 - 56320) < 0x400 )
              goto LABEL_142;
            j += 6;
          }
          else
          {
            if ( j[6] != 92 || j[7] != 117 )
            {
LABEL_142:
              sub_46990(a2, (_DWORD *)a1, 8, "invalid Unicode '\\u%04X'", v38);
              goto LABEL_55;
            }
            v40 = sub_46B2C(j + 7);
            if ( v40 < 0 )
            {
              LOWORD(v44) = 26992;
              *(_DWORD *)arg = j + 6;
              goto LABEL_138;
            }
            j += 12;
            if ( (unsigned int)(v40 - 56320) >= 0x400 )
            {
              sub_46990(a2, (_DWORD *)a1, 8, "invalid Unicode '\\u%04X\\u%04X'", v39, v40);
              goto LABEL_55;
            }
            v39 = v40 - 56320 + (v47 << 10) + 0x10000;
          }
          if ( sub_485F0(v39, v34, &endptr) )
            _assert_fail((const char *)&word_55C44, "load.c", 0x1C4u, "lex_scan_string");
          v34 += LODWORD(endptr);
        }
        if ( v37 == 98 )
        {
          *v34 = 8;
        }
        else
        {
          if ( v37 <= 0x62 )
          {
            if ( v37 != 47 && v37 != 92 && v37 != 34 )
LABEL_130:
              _assert_fail((const char *)&word_55C44, "load.c", 0x1D0u, "lex_scan_string");
            goto LABEL_125;
          }
          if ( v37 == 110 )
          {
            *v34 = 10;
          }
          else
          {
            if ( v37 <= 0x6E )
            {
              if ( v37 != 102 )
                goto LABEL_130;
              LOBYTE(v37) = 12;
LABEL_125:
              *v34 = v37;
              goto LABEL_106;
            }
            if ( v37 == 114 )
            {
              *v34 = 13;
            }
            else
            {
              if ( v37 != 116 )
                goto LABEL_130;
              *v34 = 9;
            }
          }
        }
LABEL_106:
        ++v34;
      }
    }
    if ( v17 == -2 )
      goto LABEL_55;
    if ( v17 == -1 )
    {
      sub_46990(a2, (_DWORD *)a1, 6, "premature end of input");
      goto LABEL_55;
    }
    if ( v17 <= 0x1F )
      break;
    v15 = a2;
    v16 = a1;
    if ( v17 == 92 )
    {
      v18 = sub_46E04(a1, a2);
      if ( v18 == 117 )
      {
        v29 = 4;
        v17 = sub_46E04(a1, a2);
        while ( 1 )
        {
          v30 = v17 & 0xFFFFFFDF;
          v31 = v17 - 48;
          v30 -= 65;
          v32 = v30 > 5;
          if ( v30 > 5 )
            v32 = v31 > 9;
          if ( v32 )
            break;
          --v29;
          v17 = sub_46E04(a1, a2);
          if ( !v29 )
            goto LABEL_42;
        }
LABEL_54:
        sub_46990(a2, (_DWORD *)a1, 8, "invalid escape");
        goto LABEL_55;
      }
      v19 = v18 == 92;
      if ( v18 != 92 )
        v19 = (v18 & 0xFFFFFFBF) == 34;
      if ( !v19 && v18 != 47 && (v18 & 0xFFFFFFF7) != 0x66 && ((v18 - 114) & 0xFFFFFFFD) != 0 )
        goto LABEL_54;
      goto LABEL_40;
    }
  }
  sub_46E44((_DWORD *)a1, v17);
  if ( v17 == 10 )
    sub_46990(a2, (_DWORD *)a1, 8, "unexpected newline");
  else
    sub_46990(a2, (_DWORD *)a1, 8, "control character 0x%x", v17);
LABEL_55:
  sub_4815C(*(void **)(a1 + 64));
  v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  return v8;
}
// 55C44: using guessed type __int16 word_55C44;

//----- (000476A8) --------------------------------------------------------
_DWORD *__fastcall sub_476A8(int a1, int a2, int a3)
{
  unsigned int v5; // r3
  int v6; // r3
  _DWORD *v7; // r6
  _BYTE *v10; // r7
  size_t v11; // r9
  int v12; // r3
  void *v13; // r7
  size_t v14; // r2
  _DWORD *v15; // r2
  int v16; // r3
  unsigned int *v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r2
  int v20; // r3
  int v21; // r3
  _DWORD *v22; // r1
  unsigned int *v23; // r3
  unsigned int v24; // r2
  _DWORD *v25; // r0

  v5 = *(_DWORD *)(a1 + 56) + 1;
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 > 0x800 )
  {
    v7 = 0;
    sub_46990(a3, (_DWORD *)a1, 2, "maximum parsing depth reached");
    return v7;
  }
  v6 = *(_DWORD *)(a1 + 60);
  if ( v6 == 257 )
  {
    v7 = sub_49250(*(_QWORD *)(a1 + 64));
    goto LABEL_9;
  }
  if ( v6 <= 257 )
  {
    if ( v6 == 91 )
    {
      v7 = sub_48E00();
      if ( !v7 )
        return 0;
      sub_46E90(a1, a3);
      v20 = *(_DWORD *)(a1 + 60);
      if ( v20 == 93 )
        goto LABEL_10;
      if ( v20 )
      {
        while ( 1 )
        {
          v22 = (_DWORD *)sub_476A8(a1, a2, a3);
          if ( !v22 || sub_49D54(v7, v22) )
            break;
          sub_46E90(a1, a3);
          v21 = *(_DWORD *)(a1 + 60);
          if ( v21 != 44 )
          {
            if ( v21 == 93 )
              goto LABEL_10;
            goto LABEL_62;
          }
          sub_46E90(a1, a3);
          if ( !*(_DWORD *)(a1 + 60) )
            goto LABEL_62;
        }
      }
      else
      {
LABEL_62:
        sub_46990(a3, (_DWORD *)a1, 8, "']' expected");
      }
      if ( v7[1] == -1 )
        return 0;
      v23 = v7 + 1;
      __dmb(0xBu);
      do
      {
        v24 = __ldrex(v23);
        v19 = v24 - 1;
      }
      while ( __strex(v19, v23) );
    }
    else
    {
      if ( v6 <= 91 )
      {
        if ( v6 == -1 )
        {
          v7 = 0;
          sub_46990(a3, (_DWORD *)a1, 8, "invalid token");
          return v7;
        }
        goto LABEL_57;
      }
      if ( v6 != 123 )
      {
        if ( v6 != 256 )
          goto LABEL_57;
        v10 = *(_BYTE **)(a1 + 64);
        v11 = *(_DWORD *)(a1 + 68);
        if ( (a2 & 0x10) == 0 && memchr(*(const void **)(a1 + 64), 0, *(_DWORD *)(a1 + 68)) )
        {
          v7 = 0;
          sub_46990(a3, (_DWORD *)a1, 11, "\\u0000 is not allowed without JSON_ALLOW_NUL");
          return v7;
        }
        v7 = sub_48FB8(v10, v11);
        *(_DWORD *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 68) = 0;
        goto LABEL_9;
      }
      v7 = sub_48A70();
      if ( !v7 )
        return 0;
      sub_46E90(a1, a3);
      v12 = *(_DWORD *)(a1 + 60);
      if ( v12 == 125 )
        goto LABEL_10;
      if ( v12 == 256 )
      {
        v13 = *(void **)(a1 + 64);
        v14 = *(_DWORD *)(a1 + 68);
        *(_DWORD *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 68) = 0;
        if ( !v13 )
          return 0;
        while ( 1 )
        {
          if ( memchr(v13, 0, v14) )
          {
            sub_4815C(v13);
            sub_46990(a3, (_DWORD *)a1, 13, "NUL byte in object key not supported");
            goto LABEL_36;
          }
          if ( (a2 & 1) != 0 && sub_48AF4(v7, (char *)v13) )
          {
            sub_4815C(v13);
            sub_46990(a3, (_DWORD *)a1, 14, "duplicate object key");
            goto LABEL_36;
          }
          sub_46E90(a1, a3);
          if ( *(_DWORD *)(a1 + 60) != 58 )
          {
            sub_4815C(v13);
            sub_46990(a3, (_DWORD *)a1, 8, "':' expected");
            goto LABEL_36;
          }
          sub_46E90(a1, a3);
          v15 = (_DWORD *)sub_476A8(a1, a2, a3);
          if ( !v15 || sub_496EC(v7, (char *)v13, v15) )
          {
            sub_4815C(v13);
            goto LABEL_36;
          }
          sub_4815C(v13);
          sub_46E90(a1, a3);
          v16 = *(_DWORD *)(a1 + 60);
          if ( v16 != 44 )
            break;
          sub_46E90(a1, a3);
          if ( *(_DWORD *)(a1 + 60) != 256 )
            goto LABEL_63;
          v13 = *(void **)(a1 + 64);
          v14 = *(_DWORD *)(a1 + 68);
          *(_DWORD *)(a1 + 64) = 0;
          *(_DWORD *)(a1 + 68) = 0;
          if ( !v13 )
            return 0;
        }
        if ( v16 == 125 )
          goto LABEL_10;
        sub_46990(a3, (_DWORD *)a1, 8, "'}' expected");
      }
      else
      {
LABEL_63:
        sub_46990(a3, (_DWORD *)a1, 8, "string or '}' expected");
      }
LABEL_36:
      if ( v7[1] == -1 )
        return 0;
      v17 = v7 + 1;
      __dmb(0xBu);
      do
      {
        v18 = __ldrex(v17);
        v19 = v18 - 1;
      }
      while ( __strex(v19, v17) );
    }
    if ( !v19 )
    {
      v25 = v7;
      v7 = 0;
      sub_4942C(v25);
      return v7;
    }
    return 0;
  }
  if ( v6 == 259 )
  {
    v7 = sub_49408();
  }
  else if ( v6 < 259 )
  {
    v7 = sub_492D4();
  }
  else
  {
    if ( v6 != 260 )
    {
      if ( v6 == 261 )
      {
        v7 = sub_49420();
        goto LABEL_9;
      }
LABEL_57:
      v7 = 0;
      sub_46990(a3, (_DWORD *)a1, 8, "unexpected token");
      return v7;
    }
    v7 = sub_49414();
  }
LABEL_9:
  if ( v7 )
  {
LABEL_10:
    --*(_DWORD *)(a1 + 56);
    return v7;
  }
  return 0;
}

//----- (00047B4C) --------------------------------------------------------
_DWORD *__fastcall sub_47B4C(_DWORD *a1, int a2, int a3)
{
  _DWORD *v6; // r7
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  _DWORD *v11; // r0

  a1[14] = 0;
  sub_46E90((int)a1, a3);
  v6 = (_DWORD *)(a2 & 4);
  if ( (a2 & 4) == 0 && (a1[15] & 0xFFFFFFDF) != 0x5B )
  {
    sub_46990(a3, a1, 8, "'[' or '{' expected");
    return v6;
  }
  v6 = sub_476A8((int)a1, a2, a3);
  if ( v6 )
  {
    if ( (a2 & 2) != 0 || (sub_46E90((int)a1, a3), !a1[15]) )
    {
      if ( a3 )
        *(_DWORD *)(a3 + 8) = a1[9];
      return v6;
    }
    sub_46990(a3, a1, 7, "end of file expected");
    if ( v6[1] != -1 )
    {
      v8 = v6 + 1;
      __dmb(0xBu);
      do
      {
        v9 = __ldrex(v8);
        v10 = v9 - 1;
      }
      while ( __strex(v10, v8) );
      if ( !v10 )
      {
        v11 = v6;
        v6 = 0;
        sub_4942C(v11);
        return v6;
      }
    }
  }
  return 0;
}

//----- (00047C50) --------------------------------------------------------
_DWORD *__fastcall sub_47C50(int a1, int a2, char *a3)
{
  _DWORD *v6; // r4
  _DWORD v8[2]; // [sp+0h] [bp-54h] BYREF
  _DWORD v9[2]; // [sp+8h] [bp-4Ch] BYREF
  char v10; // [sp+10h] [bp-44h]
  int v11; // [sp+18h] [bp-3Ch]
  int v12; // [sp+1Ch] [bp-38h]
  int v13; // [sp+20h] [bp-34h]
  int v14; // [sp+24h] [bp-30h]
  int v15; // [sp+2Ch] [bp-28h]
  _DWORD v16[9]; // [sp+30h] [bp-24h] BYREF

  sub_4A1CC(a3, "<string>");
  if ( a1 )
  {
    v6 = 0;
    v8[0] = a1;
    v9[0] = sub_468EC;
    v8[1] = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v9[1] = v8;
    v13 = 1;
    if ( !sub_48218(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v6 = sub_47B4C(v9, a2, (int)a3);
      sub_46AC0((int)v9);
    }
  }
  else
  {
    v6 = 0;
    sub_46990((int)a3, 0, 4, "wrong arguments");
  }
  return v6;
}

//----- (00047D18) --------------------------------------------------------
_DWORD *__fastcall sub_47D18(int a1, int a2, int a3, char *a4)
{
  _DWORD *v8; // r4
  _DWORD v10[3]; // [sp+4h] [bp-54h] BYREF
  _DWORD v11[2]; // [sp+10h] [bp-48h] BYREF
  char v12; // [sp+18h] [bp-40h]
  int v13; // [sp+20h] [bp-38h]
  int v14; // [sp+24h] [bp-34h]
  int v15; // [sp+28h] [bp-30h]
  int v16; // [sp+2Ch] [bp-2Ch]
  int v17; // [sp+34h] [bp-24h]
  _DWORD v18[8]; // [sp+38h] [bp-20h] BYREF

  sub_4A1CC(a4, "<buffer>");
  if ( a1 )
  {
    v8 = 0;
    v10[0] = a1;
    v10[1] = a2;
    v11[0] = sub_46910;
    v10[2] = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v16 = 0;
    v17 = 0;
    v11[1] = v10;
    v15 = 1;
    if ( !sub_48218(v18) )
    {
      v18[3] = a3;
      v18[5] = -1;
      v8 = sub_47B4C(v11, a3, (int)a4);
      sub_46AC0((int)v11);
    }
  }
  else
  {
    v8 = 0;
    sub_46990((int)a4, 0, 4, "wrong arguments");
  }
  return v8;
}

//----- (00047DEC) --------------------------------------------------------
_DWORD *__fastcall sub_47DEC(int a1, int a2, char *a3)
{
  char *v6; // r1
  _DWORD *v7; // r4
  _DWORD v9[2]; // [sp+0h] [bp-4Ch] BYREF
  char v10; // [sp+8h] [bp-44h]
  int v11; // [sp+10h] [bp-3Ch]
  int v12; // [sp+14h] [bp-38h]
  int v13; // [sp+18h] [bp-34h]
  int v14; // [sp+1Ch] [bp-30h]
  int v15; // [sp+24h] [bp-28h]
  _DWORD v16[9]; // [sp+28h] [bp-24h] BYREF

  if ( stdin == a1 )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  sub_4A1CC(a3, v6);
  if ( a1 )
  {
    v7 = 0;
    v9[1] = a1;
    v9[0] = fgetc;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !sub_48218(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v7 = sub_47B4C(v9, a2, (int)a3);
      sub_46AC0((int)v9);
    }
  }
  else
  {
    v7 = 0;
    sub_46990((int)a3, 0, 4, "wrong arguments");
  }
  return v7;
}
// 68590: using guessed type int stdin;

//----- (00047ECC) --------------------------------------------------------
_DWORD *__fastcall sub_47ECC(int a1, int a2, char *a3)
{
  char *v4; // r1
  _DWORD *v6; // r4
  int v8; // [sp+4h] [bp-4Ch] BYREF
  _DWORD v9[2]; // [sp+8h] [bp-48h] BYREF
  char v10; // [sp+10h] [bp-40h]
  int v11; // [sp+18h] [bp-38h]
  int v12; // [sp+1Ch] [bp-34h]
  int v13; // [sp+20h] [bp-30h]
  int v14; // [sp+24h] [bp-2Ch]
  int v15; // [sp+2Ch] [bp-24h]
  _DWORD v16[8]; // [sp+30h] [bp-20h] BYREF

  v8 = a1;
  if ( a1 )
    v4 = "<stream>";
  else
    v4 = "<stdin>";
  sub_4A1CC(a3, v4);
  if ( v8 < 0 )
  {
    v6 = 0;
    sub_46990((int)a3, 0, 4, "wrong arguments");
  }
  else
  {
    v6 = 0;
    v9[0] = sub_46B00;
    v9[1] = &v8;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 1;
    if ( !sub_48218(v16) )
    {
      v16[3] = a2;
      v16[5] = -1;
      v6 = sub_47B4C(v9, a2, (int)a3);
      sub_46AC0((int)v9);
    }
  }
  return v6;
}

//----- (00047FA8) --------------------------------------------------------
_DWORD *__fastcall sub_47FA8(char *a1, int a2, char *a3)
{
  int v6; // r0
  FILE *v7; // r7
  _DWORD *v8; // r6
  int *v10; // r0
  char *v11; // r0

  sub_4A1CC(a3, a1);
  if ( a1 )
  {
    v6 = fopen64(a1, "rb");
    v7 = (FILE *)v6;
    if ( v6 )
    {
      v8 = sub_47DEC(v6, a2, a3);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      sub_46990((int)a3, 0, 3, "unable to open %s: %s", a1, v11);
    }
  }
  else
  {
    v8 = 0;
    sub_46990((int)a3, 0, 4, "wrong arguments");
  }
  return v8;
}
// 12830: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00048144) --------------------------------------------------------
void *__fastcall sub_48144(void *result)
{
  if ( result )
    return off_6856C((size_t)result);
  return result;
}
// 6856C: using guessed type void *(*off_6856C)(size_t size);

//----- (0004815C) --------------------------------------------------------
void __fastcall sub_4815C(void *a1)
{
  if ( a1 )
    off_68570(a1);
}
// 68570: using guessed type void (*off_68570)(void *ptr);

//----- (00048174) --------------------------------------------------------
_BYTE *__fastcall sub_48174(const void *a1, size_t a2)
{
  _BYTE *v2; // r5
  _BYTE *v5; // r0

  v2 = (_BYTE *)(a2 + 1);
  if ( a2 != -1 )
  {
    v5 = off_6856C(a2 + 1);
    v2 = v5;
    if ( v5 )
    {
      memcpy(v5, a1, a2);
      v2[a2] = 0;
    }
  }
  return v2;
}
// 6856C: using guessed type void *(*off_6856C)(size_t size);

//----- (000481C0) --------------------------------------------------------
_BYTE *__fastcall sub_481C0(const char *a1)
{
  size_t v2; // r1

  v2 = strlen(a1);
  return sub_48174(a1, v2);
}

//----- (000481DC) --------------------------------------------------------
int __fastcall sub_481DC(__int64 a1)
{
  *(_QWORD *)&off_6856C = a1;
  return a1;
}
// 6856C: using guessed type void *(*off_6856C)(size_t size);

//----- (000481EC) --------------------------------------------------------
_DWORD *__fastcall sub_481EC(_DWORD *result, _DWORD *a2)
{
  if ( result )
    *result = off_6856C;
  if ( a2 )
    *a2 = off_68570;
  return result;
}
// 6856C: using guessed type void *(*off_6856C)(size_t size);
// 68570: using guessed type void (*off_68570)(void *ptr);

//----- (00048218) --------------------------------------------------------
int __fastcall sub_48218(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = sub_48144((void *)0x10);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (0004824C) --------------------------------------------------------
void __fastcall sub_4824C(int a1)
{
  void *v2; // r0

  v2 = *(void **)a1;
  if ( v2 )
    sub_4815C(v2);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (00048278) --------------------------------------------------------
int __fastcall sub_48278(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (0004828C) --------------------------------------------------------
int __fastcall sub_4828C(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00048294) --------------------------------------------------------
int __fastcall sub_48294(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (000482A8) --------------------------------------------------------
int __fastcall sub_482A8(const void **a1, void *src, size_t n)
{
  unsigned int v4; // r3
  size_t v7; // r0
  char *v8; // r8
  unsigned int v9; // r3
  unsigned int v10; // r0
  void *v11; // r6
  char *v12; // r0
  char *v13; // r2
  size_t v15; // r5

  v4 = (unsigned int)a1[2];
  v7 = (size_t)a1[1];
  if ( v4 - v7 > n )
  {
    v8 = (char *)*a1;
LABEL_10:
    memcpy(&v8[v7], src, n);
    v13 = (char *)*a1;
    v15 = (size_t)a1[1] + n;
    a1[1] = (const void *)v15;
    v13[v15] = 0;
    return 0;
  }
  if ( !((n == -1) | (v4 >> 31)) && -2 - n >= v7 )
  {
    v9 = 2 * v4;
    v10 = n + 1 + v7;
    v11 = (void *)(v10 < v9 ? v9 : v10);
    v12 = (char *)sub_48144(v11);
    v8 = v12;
    if ( v12 )
    {
      memcpy(v12, *a1, (size_t)a1[1]);
      sub_4815C((void *)*a1);
      v7 = (size_t)a1[1];
      *a1 = v8;
      a1[2] = v11;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (00048374) --------------------------------------------------------
int __fastcall sub_48374(const void **a1, char a2)
{
  char v3; // [sp+7h] [bp-5h] BYREF

  v3 = a2;
  return sub_482A8(a1, &v3, 1u);
}

//----- (00048398) --------------------------------------------------------
int __fastcall sub_48398(int *a1, char a2, int a3)
{
  int v3; // r3
  bool v4; // zf
  int result; // r0

  v3 = a1[1];
  v4 = v3 == 0;
  if ( v3 )
  {
    a3 = *a1;
    --v3;
    a2 = 0;
    a1[1] = v3;
    result = *(unsigned __int8 *)(a3 + v3);
  }
  else
  {
    result = 0;
  }
  if ( !v4 )
    *(_BYTE *)(a3 + v3) = a2;
  return result;
}

//----- (000483C0) --------------------------------------------------------
int __fastcall sub_483C0(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-8h] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 0x4Eu, "jsonp_strtod");
  if ( (v2 > 1.79769313e308 || v2 < -1.79769313e308) && *v9 == 34 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 48440: variable 'v2' is possibly undefined

//----- (000484B0) --------------------------------------------------------
int __fastcall sub_484B0(char *a1, size_t a2, int a3)
{
  int v3; // s0
  int v4; // s1
  int v5; // r3
  unsigned int v8; // r0
  unsigned int v9; // r6
  int v10; // r1
  char *v11; // r0
  char *v12; // r5
  char *v13; // r0
  unsigned __int8 *v14; // r4
  int v15; // r3
  _BYTE *v16; // r5
  int v17; // t1
  size_t v18; // r2
  char *v20; // r3

  if ( a3 )
    v5 = a3;
  else
    v5 = 17;
  v8 = snprintf(a1, a2, "%.*g", v5, v3, v4);
  if ( a2 > v8 )
  {
    v9 = v8;
    v10 = *(unsigned __int8 *)localeconv()->decimal_point;
    if ( v10 != 46 )
    {
      v11 = strchr(a1, v10);
      if ( v11 )
        *v11 = 46;
    }
    v12 = strchr(a1, 46);
    v13 = strchr(a1, 101);
    if ( v12 )
    {
LABEL_9:
      if ( !v13 )
        return v9;
      goto LABEL_10;
    }
    if ( v13 )
    {
LABEL_10:
      v14 = (unsigned __int8 *)(v13 + 2);
      v15 = (unsigned __int8)v13[2];
      if ( v13[1] != 45 )
      {
        v16 = v13 + 1;
        if ( v15 != 48 )
        {
LABEL_13:
          if ( v14 != v16 )
          {
            v18 = v9 - (v14 - (unsigned __int8 *)a1);
            v9 -= v14 - v16;
            memmove(v16, v14, v18);
          }
          return v9;
        }
        do
LABEL_12:
          v17 = *++v14;
        while ( v17 == 48 );
        goto LABEL_13;
      }
      if ( v15 == 48 )
      {
        v16 = v13 + 2;
        goto LABEL_12;
      }
      return v9;
    }
    if ( v9 + 3 < a2 )
    {
      a1[v9] = 46;
      v20 = &a1[v9];
      v9 += 2;
      v20[1] = 48;
      a1[v9] = 0;
      v13 = strchr(a1, 101);
      goto LABEL_9;
    }
  }
  return -1;
}
// 484D8: variable 'v3' is possibly undefined
// 484D8: variable 'v4' is possibly undefined

//----- (000485F0) --------------------------------------------------------
int __fastcall sub_485F0(int a1, _BYTE *a2, _DWORD *a3)
{
  char v3; // r3
  char v5; // r3
  char v6; // r3
  int v7; // r12

  if ( a1 < 0 )
    return -1;
  if ( a1 <= 127 )
  {
    *a2 = a1;
    *a3 = 1;
    return 0;
  }
  else if ( a1 < 2048 )
  {
    v5 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 6) - 64;
    a2[1] = v5;
    *a3 = 2;
    return 0;
  }
  else if ( a1 < 0x10000 )
  {
    v6 = (a1 & 0x3F) + 0x80;
    v7 = (((unsigned int)a1 >> 6) & 0x3F) - 128;
    *a2 = (a1 >> 12) - 32;
    a2[1] = v7;
    a2[2] = v6;
    *a3 = 3;
    return 0;
  }
  else if ( a1 >= 1114112 )
  {
    return -1;
  }
  else
  {
    v3 = (a1 & 0x3F) + 0x80;
    *a2 = (a1 >> 18) - 16;
    a2[1] = (((unsigned int)a1 >> 12) & 0x3F) + 0x80;
    a2[2] = (((unsigned int)a1 >> 6) & 0x3F) + 0x80;
    a2[3] = v3;
    *a3 = 4;
    return 0;
  }
}

//----- (000486DC) --------------------------------------------------------
int __fastcall sub_486DC(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 0x41 )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(a1 + 16) <= 4u )
    return 4;
  return 0;
}

//----- (00048748) --------------------------------------------------------
int __fastcall sub_48748(char *a1, unsigned int a2, int *a3)
{
  char v3; // lr
  int v4; // lr
  int result; // r0
  int v6; // r3
  _BYTE *v7; // r0
  unsigned int v8; // r12
  int v9; // t1
  bool v10; // zf
  _BOOL4 v11; // r3
  _BOOL4 v12; // r1

  v3 = *a1;
  switch ( a2 )
  {
    case 2u:
      v4 = v3 & 0x1F;
      break;
    case 3u:
      v4 = v3 & 0xF;
      break;
    case 4u:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = a1 + 1;
  v8 = 1;
  while ( 1 )
  {
    ++v8;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v8 )
      break;
    v9 = (unsigned __int8)*++v7;
    LOBYTE(v6) = v9;
    if ( (v9 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) < 0x800 )
    return 0;
  v10 = v4 == 127;
  if ( v4 <= 127 )
    v10 = a2 == 2;
  result = v10;
  if ( v10 )
    return 0;
  v11 = a2 == 3;
  if ( v4 >= 2048 )
    v11 = 0;
  if ( !v11 )
  {
    v12 = a2 == 4;
    if ( v4 >= 0x10000 )
      v12 = 0;
    if ( !v12 )
    {
      result = 1;
      if ( a3 )
        *a3 = v4;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (00048830) --------------------------------------------------------
char *__fastcall sub_48830(char *result, int a2, _DWORD *a3)
{
  char *v4; // r4
  unsigned int v5; // r0
  unsigned int v6; // r1
  int v7; // r2
  unsigned int v8; // r6
  int v9; // [sp+4h] [bp-14h] BYREF

  if ( a2 )
  {
    v4 = result;
    v5 = sub_486DC((unsigned __int8)*result);
    v8 = v5;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v9 = v7;
LABEL_7:
        result = &v4[v8];
        if ( a3 )
          *a3 = v9;
        return result;
      }
      if ( v6 >= v5 && sub_48748(v4, v5, &v9) )
        goto LABEL_7;
    }
    return 0;
  }
  return result;
}
// 48860: variable 'v7' is possibly undefined
// 4886C: variable 'v6' is possibly undefined

//----- (000488AC) --------------------------------------------------------
int __fastcall sub_488AC(int a1, unsigned int a2)
{
  int v4; // r4
  unsigned int v5; // r5
  char *v6; // r0

  if ( !a2 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_486DC(*(unsigned __int8 *)(a1 + v4));
    v6 = (char *)(a1 + v4);
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( a2 - v4 < v5 )
        break;
      v4 = v5 + v4 - 1;
      if ( !sub_48748(v6, v5, 0) )
        break;
    }
    if ( a2 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (00048928) --------------------------------------------------------
_QWORD *__fastcall sub_48928(int a1)
{
  __int64 v1; // r4
  _QWORD *result; // r0

  if ( a1 && *(_DWORD *)a1 == 3 )
    v1 = *(_QWORD *)(a1 + 8);
  else
    v1 = 0;
  result = sub_48144((void *)0x10);
  if ( result )
  {
    result[1] = v1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (00048978) --------------------------------------------------------
void *__fastcall sub_48978(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // r12
  void *v4; // r5
  unsigned int v6; // r3
  unsigned int v7; // r12
  unsigned int v10; // r7
  void *v11; // r0

  v3 = a1[2];
  v4 = (void *)a1[4];
  if ( a2 + a1[3] <= v3 )
    return v4;
  v6 = 2 * v3;
  v7 = v3 + a2;
  if ( v6 < v7 )
    v10 = v7;
  else
    v10 = v6;
  v11 = sub_48144((void *)(4 * v10));
  if ( !v11 )
    return 0;
  a1[2] = v10;
  a1[4] = v11;
  if ( !a3 )
    return v4;
  memcpy(v11, v4, 4 * a1[3]);
  sub_4815C(v4);
  return (void *)a1[4];
}

//----- (00048A04) --------------------------------------------------------
_DWORD *__fastcall sub_48A04(_BYTE *a1, size_t a2, int a3)
{
  _BYTE *v3; // r5
  _DWORD *result; // r0

  v3 = a1;
  if ( !a1 )
    return 0;
  if ( !a3 )
  {
    v3 = sub_48174(a1, a2);
    if ( !v3 )
      return 0;
  }
  result = sub_48144((void *)0x10);
  if ( result )
  {
    result[2] = v3;
    result[3] = a2;
    *result = 2;
    result[1] = 1;
  }
  else
  {
    sub_4815C(v3);
    return 0;
  }
  return result;
}

//----- (00048A70) --------------------------------------------------------
_DWORD *sub_48A70()
{
  _DWORD *v0; // r4
  void *v2; // r0

  v0 = sub_48144((void *)0x24);
  if ( v0 )
  {
    if ( !dword_72C18 )
      sub_467F0(0);
    v0[1] = 1;
    *v0 = 0;
    if ( sub_461E0(v0 + 2) )
    {
      v2 = v0;
      v0 = 0;
      sub_4815C(v2);
    }
  }
  return v0;
}
// 72C18: using guessed type int dword_72C18;

//----- (00048AD8) --------------------------------------------------------
_DWORD *__fastcall sub_48AD8(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (00048AF4) --------------------------------------------------------
int __fastcall sub_48AF4(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_46508((int)(a1 + 2), a2);
}

//----- (00048B1C) --------------------------------------------------------
bool __fastcall sub_48B1C(int *a1, int *a2)
{
  int v2; // r3
  int v6; // r7
  int v7; // r2
  unsigned int v8; // r6
  int v9; // r1
  bool v10; // zf
  int v11; // r0
  int v12; // r8
  int v13; // r0
  int v14; // r1
  int v15; // r0
  char *v16; // r6
  int v17; // r7
  int v18; // r0
  char *v19; // r1
  int v20; // r6
  size_t v21; // r2

  v2 = *a1;
  if ( *a1 != *a2 )
    return 0;
  if ( a1 == a2 )
    return 1;
  switch ( v2 )
  {
    case 0:
      if ( a1[2] != a2[2] )
        return 0;
      v12 = (int)(a1 + 2);
      v13 = sub_466E4((int)(a1 + 2));
      if ( !v13 )
        return 1;
      while ( 1 )
      {
        v15 = sub_46774(v13);
        v16 = (char *)v15;
        if ( !v15 )
          break;
        v17 = v15 - 16;
        v18 = sub_4677C(v15 - 16);
        v19 = v16;
        v20 = v18;
        if ( !v18 )
          break;
        v14 = sub_48AF4(a2, v19);
        if ( !v14 || !sub_48B1C(v20, v14) )
          return 0;
        if ( !*a1 )
        {
          v13 = sub_4675C(v12, v17);
          if ( v13 )
            continue;
        }
        return 1;
      }
      return 1;
    case 1:
      v6 = a1[3];
      if ( v6 != a2[3] )
        return 0;
      if ( !v6 )
        return 1;
      v7 = *a1;
      v8 = 0;
      break;
    case 2:
      v21 = a1[3];
      return v21 == a2[3] && !memcmp((const void *)a1[2], (const void *)a2[2], v21);
    case 3:
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
    case 4:
      return *((double *)a1 + 1) == *((double *)a2 + 1);
    default:
      return 0;
  }
  while ( 1 )
  {
    if ( v2 == 1 && a1[3] > v8 )
      v11 = *(_DWORD *)(a1[4] + 4 * v8);
    else
      v11 = 0;
    if ( v7 != 1 || a2[3] <= v8 )
      return 0;
    v9 = *(_DWORD *)(a2[4] + 4 * v8);
    v10 = v9 == 0;
    if ( v9 )
      v10 = v11 == 0;
    if ( v10 || !sub_48B1C(v11, v9) )
      return 0;
    if ( v6 == ++v8 )
      break;
    v2 = *a1;
    v7 = *a2;
  }
  return 1;
}
// 48B50: control flows out of bounds to 48B54

//----- (00048CFC) --------------------------------------------------------
int __fastcall sub_48CFC(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return -1;
  else
    return sub_46568(a1 + 2, a2);
}

//----- (00048D5C) --------------------------------------------------------
int __fastcall sub_48D5C(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return sub_466E4((int)(a1 + 2));
}

//----- (00048D80) --------------------------------------------------------
int __fastcall sub_48D80(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_466FC((int)(a1 + 2), a2);
}

//----- (00048DA8) --------------------------------------------------------
int __fastcall sub_48DA8(_DWORD *a1, int a2)
{
  _BOOL4 v2; // r3

  if ( !a1 )
    return 0;
  v2 = a2 == 0;
  if ( *a1 )
    v2 = 1;
  if ( v2 )
    return 0;
  else
    return sub_4675C((int)(a1 + 2), a2);
}

//----- (00048DDC) --------------------------------------------------------
int __fastcall sub_48DDC(int a1)
{
  if ( a1 )
    return sub_46774(a1);
  return a1;
}

//----- (00048DE8) --------------------------------------------------------
int __fastcall sub_48DE8(int a1)
{
  if ( a1 )
    return sub_4677C(a1);
  return a1;
}

//----- (00048DF4) --------------------------------------------------------
int __fastcall sub_48DF4(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (00048E00) --------------------------------------------------------
_DWORD *sub_48E00()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r0
  void *v4; // r0

  v0 = sub_48144((void *)0x14);
  v1 = v0;
  if ( v0 )
  {
    *v0 = 1;
    v0[1] = 1;
    v0[3] = 0;
    v0[2] = 8;
    v2 = sub_48144((void *)0x20);
    v1[4] = v2;
    if ( !v2 )
    {
      v4 = v1;
      v1 = 0;
      sub_4815C(v4);
    }
  }
  return v1;
}

//----- (00048E60) --------------------------------------------------------
_DWORD *__fastcall sub_48E60(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (00048E7C) --------------------------------------------------------
_DWORD *__fastcall sub_48E7C(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (00048EB0) --------------------------------------------------------
int __fastcall sub_48EB0(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r4
  __int64 v5; // r0
  size_t v6; // r2
  unsigned int v7; // r3
  int v8; // r2
  int v9; // r12
  unsigned int *v10; // r2
  unsigned int v11; // r1

  if ( !a1 )
    return -1;
  v3 = *a1 != 1 || a2 == 0;
  if ( v3 || *a2 != 1 || !sub_48978(a1, a2[3], 1) )
    return -1;
  v5 = *(_QWORD *)(a2 + 3);
  v6 = a2[3];
  if ( (_DWORD)v5 )
  {
    v7 = 0;
    do
    {
      v8 = *(_DWORD *)(HIDWORD(v5) + 4 * v7);
      if ( v8 )
      {
        v9 = *(_DWORD *)(v8 + 4);
        v10 = (unsigned int *)(v8 + 4);
        if ( v9 != -1 )
        {
          do
            v11 = __ldrex(v10);
          while ( __strex(v11 + 1, v10) );
          __dmb(0xBu);
          v5 = *(_QWORD *)(a2 + 3);
        }
      }
      ++v7;
    }
    while ( (unsigned int)v5 > v7 );
    v6 = 4 * v5;
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), (const void *)HIDWORD(v5), v6);
  a1[3] += a2[3];
  return 0;
}

//----- (00048F88) --------------------------------------------------------
const char *__fastcall sub_48F88(const char *result)
{
  char *v1; // r4
  size_t v2; // r0

  if ( result )
  {
    v1 = (char *)result;
    v2 = strlen(result);
    return (const char *)sub_48A04(v1, v2, 0);
  }
  return result;
}

//----- (00048FB0) --------------------------------------------------------
_DWORD *__fastcall sub_48FB0(_BYTE *a1, size_t a2)
{
  return sub_48A04(a1, a2, 0);
}

//----- (00048FB8) --------------------------------------------------------
_DWORD *__fastcall sub_48FB8(_BYTE *a1, size_t a2)
{
  return sub_48A04(a1, a2, 1);
}

//----- (00048FC0) --------------------------------------------------------
_DWORD *__fastcall sub_48FC0(_BYTE *a1, size_t a2)
{
  if ( !a1 )
    return 0;
  if ( sub_488AC((int)a1, a2) )
    return sub_48A04(a1, a2, 0);
  return 0;
}

//----- (00049004) --------------------------------------------------------
const char *__fastcall sub_49004(const char *result)
{
  char *v1; // r4
  size_t v2; // r0

  if ( result )
  {
    v1 = (char *)result;
    v2 = strlen(result);
    return (const char *)sub_48FC0(v1, v2);
  }
  return result;
}

//----- (00049028) --------------------------------------------------------
_DWORD *__fastcall sub_49028(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (00049044) --------------------------------------------------------
_DWORD *__fastcall sub_49044(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (00049060) --------------------------------------------------------
int __fastcall sub_49060(int a1, const void *a2, size_t a3)
{
  _BYTE *v6; // r7

  if ( !a1 )
    return -1;
  if ( *(_DWORD *)a1 != 2 || a2 == 0 )
    return -1;
  v6 = sub_48174(a2, a3);
  if ( !v6 )
    return -1;
  sub_4815C(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 12) = a3;
  return 0;
}

//----- (000490C4) --------------------------------------------------------
int __fastcall sub_490C4(int a1, const char *a2)
{
  size_t v4; // r0

  if ( !a2 )
    return -1;
  v4 = strlen(a2);
  return sub_49060(a1, a2, v4);
}

//----- (000490F8) --------------------------------------------------------
int __fastcall sub_490F8(int a1, const void *a2, size_t a3)
{
  if ( a2 && sub_488AC((int)a2, a3) )
    return sub_49060(a1, a2, a3);
  else
    return -1;
}

//----- (0004913C) --------------------------------------------------------
int __fastcall sub_4913C(int a1, const char *a2)
{
  size_t v4; // r0

  if ( !a2 )
    return -1;
  v4 = strlen(a2);
  return sub_490F8(a1, a2, v4);
}

//----- (00049170) --------------------------------------------------------
_DWORD *__fastcall sub_49170(char *format, __gnuc_va_list arg)
{
  int v3; // r0
  size_t v4; // r4
  char *v5; // r0
  char *v6; // r7

  v3 = vsnprintf(0, 0, format, arg);
  v4 = v3;
  if ( !v3 )
    return sub_48FC0("", 0);
  v5 = (char *)sub_48144((void *)(v3 + 1));
  v6 = v5;
  if ( !v5 )
    return 0;
  vsnprintf(v5, v4 + 1, format, arg);
  if ( sub_488AC((int)v6, v4) )
    return sub_48A04(v6, v4, 1);
  sub_4815C(v6);
  return 0;
}

//----- (00049220) --------------------------------------------------------
_DWORD *sub_49220(char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  return sub_49170(a1, varg_r1);
}

//----- (00049250) --------------------------------------------------------
_QWORD *__fastcall sub_49250(__int64 a1)
{
  _QWORD *result; // r0

  result = sub_48144((void *)0x10);
  if ( result )
  {
    result[1] = a1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (00049284) --------------------------------------------------------
__int64 __fastcall sub_49284(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (000492AC) --------------------------------------------------------
int __fastcall sub_492AC(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (000492D4) --------------------------------------------------------
double *sub_492D4()
{
  double v0; // d0
  double *result; // r0

  if ( fabs(v0) > 1.79769313e308 )
    return 0;
  result = (double *)sub_48144((void *)0x10);
  if ( result )
  {
    result[1] = v0;
    *(_DWORD *)result = 4;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}
// 492E4: variable 'v0' is possibly undefined

//----- (00049330) --------------------------------------------------------
void sub_49330()
{
  ;
}

//----- (000493C0) --------------------------------------------------------
int __fastcall sub_493C0(int result)
{
  if ( result )
  {
    if ( *(_DWORD *)result == 3 )
      return sub_4AB14(*(_QWORD *)(result + 8));
  }
  return result;
}

//----- (00049408) --------------------------------------------------------
void *sub_49408()
{
  return &unk_68574;
}

//----- (00049414) --------------------------------------------------------
void *sub_49414()
{
  return &unk_6857C;
}

//----- (00049420) --------------------------------------------------------
void *sub_49420()
{
  return &unk_68584;
}

//----- (0004942C) --------------------------------------------------------
void __fastcall sub_4942C(_DWORD *a1)
{
  _DWORD *v2; // r0
  unsigned int v3; // r1
  unsigned int i; // r5
  int v5; // r3
  unsigned int *v6; // r2
  unsigned int v7; // r1
  unsigned int v8; // r1

  if ( a1 )
  {
    switch ( *a1 )
    {
      case 0:
        sub_4625C((int)(a1 + 2));
        sub_4815C(a1);
        return;
      case 1:
        v3 = a1[3];
        v2 = (_DWORD *)a1[4];
        if ( v3 )
        {
          for ( i = 0; i < v3; ++i )
          {
            v5 = v2[i];
            if ( v5 )
            {
              v6 = (unsigned int *)(v5 + 4);
              if ( *(_DWORD *)(v5 + 4) != -1 )
              {
                __dmb(0xBu);
                do
                {
                  v7 = __ldrex(v6);
                  v8 = v7 - 1;
                }
                while ( __strex(v8, v6) );
                if ( !v8 )
                  sub_4942C(v5);
                v2 = (_DWORD *)a1[4];
                v3 = a1[3];
              }
            }
          }
        }
        goto LABEL_4;
      case 2:
        v2 = (_DWORD *)a1[2];
LABEL_4:
        sub_4815C(v2);
        goto LABEL_5;
      case 3:
      case 4:
LABEL_5:
        sub_4815C(a1);
        break;
      default:
        return;
    }
  }
}
// 49444: control flows out of bounds to 49448

//----- (000494F8) --------------------------------------------------------
int __fastcall sub_494F8(_DWORD *a1)
{
  unsigned int v2; // r2
  unsigned int i; // r4
  _DWORD *v4; // r0
  unsigned int *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r2

  if ( !a1 || *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD **)(a1[4] + 4 * i);
      if ( v4 )
      {
        v5 = v4 + 1;
        if ( v4[1] != -1 )
        {
          __dmb(0xBu);
          do
          {
            v6 = __ldrex(v5);
            v7 = v6 - 1;
          }
          while ( __strex(v7, v5) );
          if ( !v7 )
            sub_4942C(v4);
          v2 = a1[3];
        }
      }
    }
  }
  a1[3] = 0;
  return 0;
}

//----- (00049588) --------------------------------------------------------
int __fastcall sub_49588(_DWORD *a1, int a2, _DWORD *a3)
{
  unsigned int *v4; // r3
  unsigned int v5; // r1
  unsigned int v6; // r1
  _BOOL4 v7; // r4

  if ( !a1 || *a1 || (a2 ? (v7 = a3 == 0) : (v7 = 1), v7) )
  {
    if ( !a3 )
      return -1;
    if ( a3[1] == -1 )
      return -1;
    v4 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v5 = __ldrex(v4);
      v6 = v5 - 1;
    }
    while ( __strex(v6, v4) );
    if ( v6 )
    {
      return -1;
    }
    else
    {
      sub_4942C(a3);
      return -1;
    }
  }
  else
  {
    sub_46784(a2, (int)a3);
    return 0;
  }
}

//----- (00049620) --------------------------------------------------------
int __fastcall sub_49620(_DWORD *a1, unsigned int a2)
{
  unsigned int v3; // r12
  int v5; // r6
  _DWORD *v6; // r0
  int v7; // r3
  unsigned int *v9; // r3
  unsigned int v10; // r2
  unsigned int v11; // r2

  if ( a1 )
  {
    if ( *a1 == 1 )
    {
      v3 = a1[3];
      if ( v3 > a2 )
      {
        v5 = 4 * a2;
        v6 = *(_DWORD **)(a1[4] + 4 * a2);
        if ( v6 && v6[1] != -1 )
        {
          v9 = v6 + 1;
          __dmb(0xBu);
          do
          {
            v10 = __ldrex(v9);
            v11 = v10 - 1;
          }
          while ( __strex(v11, v9) );
          if ( !v11 )
            sub_4942C(v6);
          v3 = a1[3];
          v7 = v3 - 1;
          if ( v3 - 1 <= a2 )
            goto LABEL_7;
        }
        else
        {
          v7 = v3 - 1;
          if ( v3 - 1 <= a2 )
          {
LABEL_7:
            a1[3] = v7;
            return 0;
          }
        }
        memmove((void *)(a1[4] + v5), (const void *)(a1[4] + v5 + 4), 4 * (~a2 + v3));
        v7 = a1[3] - 1;
        goto LABEL_7;
      }
    }
  }
  return -1;
}

//----- (000496EC) --------------------------------------------------------
int __fastcall sub_496EC(_DWORD *a1, char *a2, _DWORD *a3)
{
  bool v4; // zf
  int result; // r0
  _BOOL4 v6; // r3
  unsigned int *v7; // r3
  unsigned int v8; // r2
  unsigned int v9; // r2
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !a3 )
    return -1;
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( !v4 )
  {
    v6 = a3 == a1;
    if ( *a1 )
      v6 = 1;
    if ( !v6 )
    {
      result = sub_46274((int)(a1 + 2), a2, (int)a3);
      if ( !result )
        return result;
      if ( a3[1] != -1 )
      {
        v7 = a3 + 1;
        __dmb(0xBu);
        do
        {
          v8 = __ldrex(v7);
          v9 = v8 - 1;
        }
        while ( __strex(v9, v7) );
        goto LABEL_18;
      }
      return -1;
    }
  }
  if ( a3[1] == -1 )
    return -1;
  v10 = a3 + 1;
  __dmb(0xBu);
  do
  {
    v11 = __ldrex(v10);
    v9 = v11 - 1;
  }
  while ( __strex(v9, v10) );
LABEL_18:
  if ( v9 )
    return -1;
  sub_4942C(a3);
  return -1;
}

//----- (000497A8) --------------------------------------------------------
int __fastcall sub_497A8(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r9
  int i; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  int v10; // r0
  char *v11; // r4
  _DWORD *v12; // r8

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  for ( i = sub_466E4((int)(a2 + 2)); i; i = sub_4675C(v4, (int)(v11 - 16)) )
  {
    v10 = sub_46774(i);
    v11 = (char *)v10;
    if ( !v10 )
      break;
    v12 = (_DWORD *)sub_4677C(v10 - 16);
    if ( !v12 )
      break;
    if ( !sub_48AF4(a1, v11) )
    {
      v8 = v12 + 1;
      if ( v12[1] != -1 )
      {
        do
          v9 = __ldrex(v8);
        while ( __strex(v9 + 1, v8) );
        __dmb(0xBu);
      }
      sub_496EC(a1, v11, v12);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (00049894) --------------------------------------------------------
int __fastcall sub_49894(_DWORD *a1, char *a2, _DWORD *a3)
{
  size_t v6; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2

  if ( a2 )
  {
    v6 = strlen(a2);
    if ( sub_488AC((int)a2, v6) )
      return sub_496EC(a1, a2, a3);
  }
  if ( !a3 )
    return -1;
  if ( a3[1] == -1 )
    return -1;
  v8 = a3 + 1;
  __dmb(0xBu);
  do
  {
    v9 = __ldrex(v8);
    v10 = v9 - 1;
  }
  while ( __strex(v10, v8) );
  if ( v10 )
    return -1;
  sub_4942C(a3);
  return -1;
}

//----- (00049928) --------------------------------------------------------
int __fastcall sub_49928(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r8
  int v6; // r0
  unsigned int v8; // r1
  int v9; // r0
  char *v10; // r5
  _DWORD *v11; // r0
  unsigned int *v12; // r3

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  v6 = sub_466E4((int)(a2 + 2));
  if ( v6 )
  {
    while ( 1 )
    {
      v9 = sub_46774(v6);
      v10 = (char *)v9;
      if ( !v9 )
        break;
      v11 = (_DWORD *)sub_4677C(v9 - 16);
      v12 = v11 + 1;
      if ( !v11 )
        return 0;
      if ( v11[1] != -1 )
      {
        do
          v8 = __ldrex(v12);
        while ( __strex(v8 + 1, v12) );
        __dmb(0xBu);
      }
      if ( sub_496EC(a1, v10, v11) )
        return -1;
      if ( !*a2 )
      {
        v6 = sub_4675C(v4, (int)(v10 - 16));
        if ( v6 )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (00049A08) --------------------------------------------------------
int __fastcall sub_49A08(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v3; // r3
  int v4; // r9
  int i; // r0
  unsigned int *v7; // r3
  unsigned int v8; // r2
  int v9; // r0
  char *v10; // r4
  _DWORD *v11; // r6

  if ( !a1 )
    return -1;
  v3 = a2 == 0;
  if ( *a1 )
    v3 = 1;
  if ( v3 || *a2 )
    return -1;
  v4 = (int)(a2 + 2);
  for ( i = sub_466E4((int)(a2 + 2)); i; i = sub_4675C(v4, (int)(v10 - 16)) )
  {
    v9 = sub_46774(i);
    v10 = (char *)v9;
    if ( !v9 )
      break;
    v11 = (_DWORD *)sub_4677C(v9 - 16);
    if ( !v11 )
      break;
    if ( sub_48AF4(a1, v10) )
    {
      v7 = v11 + 1;
      if ( v11[1] != -1 )
      {
        do
          v8 = __ldrex(v7);
        while ( __strex(v8 + 1, v7) );
        __dmb(0xBu);
      }
      sub_496EC(a1, v10, v11);
    }
    if ( *a2 )
      break;
  }
  return 0;
}

//----- (00049AF8) --------------------------------------------------------
int __fastcall sub_49AF8(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  int v6; // r2
  unsigned int *v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r2
  char *v11; // r8
  char *v12; // r0
  int v13; // r7
  int v14; // r3
  unsigned int *v15; // r3
  unsigned int v16; // r2

  if ( !a3 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v6 = a3 == a1;
  if ( *a1 != 1 )
    v6 |= 1u;
  if ( v6 || a1[3] < a2 )
  {
LABEL_6:
    if ( a3[1] == -1 )
      return -1;
    v8 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v9 = __ldrex(v8);
      v10 = v9 - 1;
    }
    while ( __strex(v10, v8) );
LABEL_10:
    if ( !v10 )
    {
      sub_4942C(a3);
      return -1;
    }
    return -1;
  }
  v11 = (char *)sub_48978(a1, 1, 0);
  if ( !v11 )
  {
    if ( a3[1] == -1 )
      return -1;
    v15 = a3 + 1;
    __dmb(0xBu);
    do
    {
      v16 = __ldrex(v15);
      v10 = v16 - 1;
    }
    while ( __strex(v10, v15) );
    goto LABEL_10;
  }
  v12 = (char *)a1[4];
  v13 = 4 * (a2 + 1);
  if ( v12 == v11 )
  {
    memmove(&v12[v13], &v11[v13 - 4], 4 * (a1[3] - a2));
  }
  else
  {
    memcpy(v12, v11, v13 - 4);
    memcpy((void *)(a1[4] + v13), &v11[v13 - 4], 4 * (a1[3] - a2));
    sub_4815C(v11);
  }
  v14 = a1[3] + 1;
  *(_DWORD *)(a1[4] + v13 - 4) = a3;
  a1[3] = v14;
  return 0;
}

//----- (00049D54) --------------------------------------------------------
int __fastcall sub_49D54(_DWORD *a1, _DWORD *a2)
{
  _BOOL4 v4; // r5
  unsigned int *v6; // r3
  unsigned int v7; // r2
  unsigned int v8; // r2
  int v9; // r3
  unsigned int *v10; // r3
  unsigned int v11; // r2

  if ( !a2 )
    return -1;
  if ( !a1 )
    goto LABEL_6;
  v4 = a2 == a1;
  if ( *a1 != 1 )
    v4 = 1;
  if ( !v4 )
  {
    if ( sub_48978(a1, 1, 1) )
    {
      v9 = a1[3];
      *(_DWORD *)(a1[4] + 4 * v9) = a2;
      a1[3] = v9 + 1;
      return 0;
    }
    if ( a2[1] == -1 )
      return -1;
    v10 = a2 + 1;
    __dmb(0xBu);
    do
    {
      v11 = __ldrex(v10);
      v8 = v11 - 1;
    }
    while ( __strex(v8, v10) );
  }
  else
  {
LABEL_6:
    if ( a2[1] == -1 )
      return -1;
    v6 = a2 + 1;
    __dmb(0xBu);
    do
    {
      v7 = __ldrex(v6);
      v8 = v7 - 1;
    }
    while ( __strex(v8, v6) );
  }
  if ( v8 )
    return -1;
  sub_4942C(a2);
  return -1;
}

//----- (00049E30) --------------------------------------------------------
bool __fastcall sub_49E30(int *a1, int *a2)
{
  bool v2; // zf

  v2 = a2 == 0;
  if ( a2 )
    v2 = a1 == 0;
  return !v2 && sub_48B1C(a1, a2);
}

//----- (00049E48) --------------------------------------------------------
double *__fastcall sub_49E48(int a1)
{
  _DWORD *v2; // r7
  int i; // r0
  unsigned int v4; // r1
  int v5; // r0
  char *v6; // r5
  _DWORD *v7; // r0
  unsigned int *v8; // r3
  unsigned int v9; // r3
  unsigned int j; // r5
  _DWORD *v11; // r1
  unsigned int *v12; // r2
  unsigned int v13; // r3

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = sub_48A70();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = sub_466E4(a1 + 8); i; i = sub_4675C(a1 + 8, (int)(v6 - 16)) )
          {
            v5 = sub_46774(i);
            v6 = (char *)v5;
            if ( !v5 )
              break;
            v7 = (_DWORD *)sub_4677C(v5 - 16);
            v8 = v7 + 1;
            if ( !v7 )
              break;
            if ( v7[1] != -1 )
            {
              do
                v4 = __ldrex(v8);
              while ( __strex(v4 + 1, v8) );
              __dmb(0xBu);
            }
            sub_496EC(v2, v6, v7);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return (double *)v2;
      case 1:
        v2 = sub_48E00();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( v9 )
          {
            for ( j = 0; j < v9; ++j )
            {
              v11 = 0;
              if ( v9 > j )
              {
                v11 = *(_DWORD **)(*(_DWORD *)(a1 + 16) + 4 * j);
                v12 = v11 + 1;
                if ( v11 )
                {
                  if ( v11[1] != -1 )
                  {
                    do
                      v13 = __ldrex(v12);
                    while ( __strex(v13 + 1, v12) );
                    __dmb(0xBu);
                  }
                }
              }
              sub_49D54(v2, v11);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v9 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return (double *)v2;
      case 2:
        return (double *)sub_48A04(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (double *)sub_48928(a1);
      case 4:
        return sub_492D4();
      case 5:
      case 6:
      case 7:
        return (double *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 49E60: control flows out of bounds to 49E64

//----- (0004A004) --------------------------------------------------------
double *__fastcall sub_4A004(int a1)
{
  _DWORD *v2; // r6
  int i; // r5
  char *v4; // r7
  int v5; // r0
  _DWORD *v6; // r0
  unsigned int v7; // r3
  unsigned int j; // r5
  int v9; // r0
  _DWORD *v10; // r0

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        v2 = sub_48A70();
        if ( !v2 )
          return 0;
        if ( !*(_DWORD *)a1 )
        {
          for ( i = sub_466E4(a1 + 8); i; i = sub_4675C(a1 + 8, i) )
          {
            v4 = (char *)sub_46774(i);
            v5 = sub_4677C(i);
            v6 = (_DWORD *)sub_4A004(v5);
            sub_496EC(v2, v4, v6);
            if ( *(_DWORD *)a1 )
              break;
          }
        }
        return (double *)v2;
      case 1:
        v2 = sub_48E00();
        if ( !v2 )
          return 0;
        if ( *(_DWORD *)a1 == 1 )
        {
          v7 = *(_DWORD *)(a1 + 12);
          if ( v7 )
          {
            for ( j = 0; j < v7; ++j )
            {
              v9 = 0;
              if ( v7 > j )
                v9 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * j);
              v10 = (_DWORD *)sub_4A004(v9);
              sub_49D54(v2, v10);
              if ( *(_DWORD *)a1 != 1 )
                break;
              v7 = *(_DWORD *)(a1 + 12);
            }
          }
        }
        return (double *)v2;
      case 2:
        return (double *)sub_48A04(*(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      case 3:
        return (double *)sub_48928(a1);
      case 4:
        return sub_492D4();
      case 5:
      case 6:
      case 7:
        return (double *)a1;
      default:
        return 0;
    }
  }
  return 0;
}
// 4A01C: control flows out of bounds to 4A020

//----- (0004A168) --------------------------------------------------------
char *__fastcall sub_4A168(char *a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  if ( v4 <= 0x4F )
    return strncpy(a1 + 12, s, v4 + 1);
  *((_WORD *)a1 + 6) = 11822;
  a1[14] = 46;
  return strncpy(a1 + 15, &s[v4 - 76], 0x4Du);
}

//----- (0004A1CC) --------------------------------------------------------
char *__fastcall sub_4A1CC(char *result, char *a2)
{
  if ( result )
  {
    result[92] = 0;
    *((_DWORD *)result + 2) = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    if ( a2 )
      return sub_4A168(result, a2);
    else
      result[12] = 0;
  }
  return result;
}

//----- (0004A20C) --------------------------------------------------------
char *__fastcall sub_4A20C(char *a1, char *s)
{
  bool v2; // zf

  v2 = s == 0;
  if ( s )
    v2 = a1 == 0;
  if ( !v2 )
    return sub_4A168(a1, s);
  return a1;
}

//----- (0004A21C) --------------------------------------------------------
int sub_4A21C(int result, int a2, int a3, int a4, char a5, char *format, ...)
{
  int v6; // r4
  va_list va; // [sp+20h] [bp+14h] BYREF

  va_start(va, format);
  v6 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, va);
      *(_BYTE *)(v6 + 250) = 0;
      *(_BYTE *)(v6 + 251) = a5;
    }
  }
  return result;
}

//----- (0004A280) --------------------------------------------------------
int __fastcall sub_4A280(int result, int a2, int a3, int a4, char a5, char *format, __gnuc_va_list arg)
{
  int v7; // r4

  v7 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0x9Fu, format, arg);
      *(_BYTE *)(v7 + 250) = 0;
      *(_BYTE *)(v7 + 251) = a5;
    }
  }
  return result;
}

//----- (0004A2D0) --------------------------------------------------------
unsigned int __fastcall sub_4A2D0(unsigned int result, unsigned int a2)
{
  if ( a2 != 1 )
  {
    if ( !a2 )
      JUMPOUT(0x4ABA0);
    if ( result <= a2 )
    {
      return result == a2;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (*)(void))((char *)&loc_4A308 + 16 * (31 - (__clz(a2) - __clz(result)))))();
    }
    else
    {
      result >>= 31 - __clz(a2);
    }
  }
  return result;
}
// 4A528: control flows out of bounds to 4ABA0

//----- (0004A52C) --------------------------------------------------------
unsigned int __fastcall sub_4A52C(unsigned int a1, unsigned int a2)
{
  if ( !a2 )
    JUMPOUT(0x4A522);
  return sub_4A2D0(a1, a2);
}
// 4A52E: control flows out of bounds to 4A522

//----- (0004A548) --------------------------------------------------------
int __fastcall sub_4A548(int result, unsigned int a2)
{
  int v2; // r12
  unsigned int v3; // r3

  if ( !a2 )
    JUMPOUT(0x4ABA0);
  v2 = result ^ a2;
  if ( (a2 & 0x80000000) != 0 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v2 ^ result) < 0 )
      return -result;
  }
  else
  {
    v3 = result;
    if ( result < 0 )
      v3 = -result;
    if ( v3 <= a2 )
    {
      if ( v3 < a2 )
        result = 0;
      if ( v3 == a2 )
        return (v2 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_4A590 + 16 * (31 - (__clz(a2) - __clz(v3)))))(0);
    }
    else
    {
      result = v3 >> (31 - __clz(a2));
      if ( v2 < 0 )
        return -result;
    }
  }
  return result;
}
// 4A7D8: control flows out of bounds to 4ABA0

//----- (0004AB04) --------------------------------------------------------
int __fastcall sub_4AB04(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x4AB2A);
  return a1;
}
// 4AB12: control flows out of bounds to 4AB2A

//----- (0004AB14) --------------------------------------------------------
int __fastcall sub_4AB14(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (0004AB70) --------------------------------------------------------
int __fastcall sub_4AB70(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return sub_4AC10(a1, a2, &v3);
  if ( a1 )
    HIDWORD(a1) = -1;
  LODWORD(v3) = HIDWORD(a1);
  return raise(8);
}

//----- (0004ABAC) --------------------------------------------------------
unsigned int __fastcall sub_4ABAC(double a1)
{
  if ( a1 >= 0.0 )
    return sub_4ABD0(a1);
  HIDWORD(a1) ^= 0x80000000;
  return -sub_4ABD0(a1);
}

//----- (0004ABD0) --------------------------------------------------------
unsigned int __fastcall sub_4ABD0(double a1)
{
  return (unsigned int)(a1 - (double)(unsigned int)(a1 * 2.32830644e-10) * 4294967300.0);
}

//----- (0004AC10) --------------------------------------------------------
int __fastcall sub_4AC10(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  bool v3; // cf
  unsigned __int64 v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  unsigned __int64 v10; // r6
  unsigned __int64 v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = a1 >= a2;
  LODWORD(v4) = a1;
  if ( a1 < a2 )
    LODWORD(a1) = 0;
  HIDWORD(v4) = HIDWORD(a1);
  if ( !v3 )
    goto LABEL_16;
  v5 = __clz(HIDWORD(a2));
  if ( HIDWORD(a2) )
  {
    v6 = __clz(HIDWORD(a1));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(a1));
  v5 = __clz(a2) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = a2 << v7;
  if ( v4 >= a2 << v7 )
  {
    LODWORD(a1) = 1 << v7;
    v4 -= v10;
    HIDWORD(a1) = (1 << v8) | (1u >> v9);
  }
  else
  {
    a1 = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)a1, (_DWORD)v4);
    LODWORD(a1) = a1 + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(a1) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    a1 -= v4 << v7;
  }
LABEL_16:
  if ( a3 )
    *a3 = v4;
  return a1;
}

//----- (0004AD28) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_66EE0;
  v8 = &off_66EE4 - &off_66EE0;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 66EE0: using guessed type _UNKNOWN *off_66EE0;
// 66EE4: using guessed type _UNKNOWN *off_66EE4;

//----- (0004AD68) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=979 queued=587 decompiled=587 lumina nreq=0 worse=0 better=0
// ALL OK, 587 function(s) have been successfully decompiled
