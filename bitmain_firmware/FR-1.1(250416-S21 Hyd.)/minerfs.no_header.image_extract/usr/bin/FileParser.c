/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_106F4();
// void abort(void);
// int __fastcall ERR_get_error(_DWORD); weak
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int _gmon_start__(void); weak
// int fclose(FILE *stream);
// void *memset(void *s, int c, size_t n);
// int __fastcall RSA_verify(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int fseek(FILE *stream, int off, int whence);
// int __fastcall PEM_read_bio_RSA_PUBKEY(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall SHA256_Final(_DWORD, _DWORD); weak
// size_t strlen(const char *s);
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall fopen64(_DWORD, _DWORD); weak
// int __fastcall BIO_new_mem_buf(_DWORD, _DWORD); weak
// int printf(const char *format, ...);
// int __fastcall ERR_error_string(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
int j___xstat64();
// int _xstat64(void); weak
// int puts(const char *s);
// int __fastcall RSA_free(_DWORD); weak
// int __fastcall SHA256_Update(_DWORD, _DWORD, _DWORD); weak
// int __fastcall BIO_free(_DWORD); weak
// int __fastcall SHA256_Init(_DWORD); weak
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...); // idb
int sub_10868();
int deregister_tm_clones(); // idb
int register_tm_clones(); // idb
int sub_108DC();
int __fastcall sub_108F8(const char *a1);
int __fastcall sub_109A8(int a1);
int sub_10B9C();
int __fastcall sub_10C70(int a1, int a2, int a3, int a4);
int __fastcall sub_10DE8(FILE *a1, int a2, _DWORD *a3, char a4, char a5, char a6);
int __fastcall sub_11460(int a1);
__int64 __fastcall sub_11490(const void *a1);
int __fastcall sub_114C8(int a1, unsigned int a2);
unsigned __int64 __fastcall sub_11514(unsigned __int64 a1, char a2);
unsigned __int64 __fastcall sub_11598(int a1, int a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_116C8(unsigned __int8 *a1, unsigned int a2);
unsigned __int64 __fastcall sub_11A00(int a1, int a2);
unsigned __int64 __fastcall sub_11BE0(int a1, int a2);
_QWORD *__fastcall sub_11FBC(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6, __int64 a7);
_QWORD *__fastcall sub_120DC(_QWORD *a1, int a2, unsigned __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_12180(unsigned __int8 *a1, unsigned int a2);
int __fastcall sub_12C40(const char *a1, char *a2, const char *a3, _BYTE *a4, char a5, char a6, char a7);
int main(int, char **, char **); // idb
int __fastcall init(int a1, int a2, int a3);
int nullsub_1(); // weak
int sub_13BA4();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN *off_24F08 = (_UNKNOWN *)0x108F5; // weak
_UNKNOWN *off_24F0C = (_UNKNOWN *)0x108DD; // weak
_UNKNOWN unk_2507C; // weak
char byte_25838; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (000106E8) --------------------------------------------------------
int init_proc()
{
  return sub_10868();
}

//----- (000106F4) --------------------------------------------------------
void sub_106F4()
{
  JUMPOUT(0);
}
// 10700: control flows out of bounds to 0

//----- (000107E0) --------------------------------------------------------
// attributes: thunk
int j___xstat64()
{
  return _xstat64();
}
// 107E4: using guessed type int _xstat64(void);

//----- (00010838) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(main, v4, (char **)va, (void (*)())init, (void (*)())nullsub_1, a1, va);
  abort();
}
// 10842: positive sp value 4 has been found
// 10854: variable 'v4' is possibly undefined
// 13B64: using guessed type int init();
// 13BA0: using guessed type int nullsub_1();

//----- (00010868) --------------------------------------------------------
int sub_10868()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 1072C: using guessed type int _gmon_start__(void);

//----- (0001088C) --------------------------------------------------------
int deregister_tm_clones()
{
  return 153656;
}

//----- (000108B0) --------------------------------------------------------
int register_tm_clones()
{
  return 153656;
}

//----- (000108DC) --------------------------------------------------------
int sub_108DC()
{
  int result; // r0

  if ( !byte_25838 )
  {
    result = deregister_tm_clones();
    byte_25838 = 1;
  }
  return result;
}
// 25838: using guessed type char byte_25838;

//----- (000108F8) --------------------------------------------------------
int __fastcall sub_108F8(const char *a1)
{
  puts("Useage:\r");
  printf("\t%s [option] [paramaters]\n\n", a1);
  puts("\tOption:{-f} {-s} {-p} {-n} {-x} {-q}\n");
  puts("\t\t-f [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tOnly Check If Filename was Valided.\n");
  puts(
    "\t\t-s [minerType] [fileName] [rootPublicKeyFile]: \n"
    "\t\t\tCheck If Filename Was Valided, and Splite Bmu To \"/tmp/tmpfw/\"\n");
  puts("\t\t-p [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If Filename Was Valided, and Dump BmuComments\n");
  puts("\t\t-x [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If Filename Was FullSize BMU\n");
  puts("\t\t-n [nandBinFile]: \n\t\t\tSplite SigImg To Single File To \"/tmp/tmpNand/\"\n");
  puts("\t\t-q: \n\t\t\tGenerate A 256Bytes 0xff File To \"/tmp/256BFF\"\n");
  puts("\tReturns:");
  puts("\t\t0: \n\t\t\tWell Done!\n");
  return puts("\t\tOthers: \n\t\t\tSomething Wrong!\n");
}

//----- (000109A8) --------------------------------------------------------
int __fastcall sub_109A8(int a1)
{
  _BYTE v3[32768]; // [sp+Ch] [bp-8010h] BYREF
  FILE *s; // [sp+800Ch] [bp-10h]
  FILE *stream; // [sp+8010h] [bp-Ch]
  int i; // [sp+8014h] [bp-8h]

  memset(v3, 0, sizeof(v3));
  stream = (FILE *)fopen64(a1, "rb");
  if ( stream )
  {
    for ( i = 0; ; ++i )
    {
      if ( i > 14 )
      {
        if ( stream )
          fclose(stream);
        return 0;
      }
      fread(v3, *((_DWORD *)&unk_2507C + 33 * i), 1u, stream);
      s = (FILE *)fopen64((char *)&unk_2507C + 132 * i + 4, "wb");
      if ( !s )
        break;
      fwrite(v3, *((_DWORD *)&unk_2507C + 33 * i), 1u, s);
      if ( s )
        fclose(s);
      s = 0;
    }
    printf("Try To Write To File '%s' Failed!\n", (const char *)&unk_2507C + 132 * i + 4);
    if ( stream )
      fclose(stream);
    return 2;
  }
  else
  {
    puts("Load Nand Image File Failed!");
    return 1;
  }
}
// 10798: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00010B9C) --------------------------------------------------------
int sub_10B9C()
{
  FILE *ptr[64]; // [sp+0h] [bp-10Ch] BYREF
  FILE *stream; // [sp+100h] [bp-Ch]
  int i; // [sp+104h] [bp-8h]

  stream = (FILE *)fopen64("/tmp/256BFF", "wb");
  if ( stream )
  {
    memset(ptr, 0, sizeof(ptr));
    for ( i = 0; i <= 255; ++i )
      *((_BYTE *)ptr + i) = -1;
    fwrite(ptr, 0x100u, 1u, stream);
    fclose(stream);
    stream = 0;
    return 0;
  }
  else
  {
    puts("GenFile Failed!");
    return 1;
  }
}
// 10798: using guessed type int __fastcall fopen64(_DWORD, _DWORD);

//----- (00010C70) --------------------------------------------------------
int __fastcall sub_10C70(int a1, int a2, int a3, int a4)
{
  int v4; // r0
  const char *v5; // r0
  int v7; // r0
  int error; // r0
  const char *v9; // r0
  _BYTE v14[112]; // [sp+1Ch] [bp-A0h] BYREF
  _BYTE v15[32]; // [sp+8Ch] [bp-30h] BYREF
  int v16; // [sp+ACh] [bp-10h]
  int bio_RSA_PUBKEY; // [sp+B0h] [bp-Ch]
  int v18; // [sp+B4h] [bp-8h]

  v18 = BIO_new_mem_buf(a4, 1024);
  bio_RSA_PUBKEY = PEM_read_bio_RSA_PUBKEY(v18, 0, 0, 0);
  if ( bio_RSA_PUBKEY )
  {
    SHA256_Init(v14);
    SHA256_Update(v14, a1, a2);
    SHA256_Final(v15, v14);
    v7 = RSA_verify(672, v15, 32, a3, 256, bio_RSA_PUBKEY);
    v16 = v7;
    if ( bio_RSA_PUBKEY )
      v7 = RSA_free(bio_RSA_PUBKEY);
    if ( v18 )
      v7 = BIO_free(v18);
    if ( v16 == 1 )
    {
      return 0;
    }
    else
    {
      error = ERR_get_error(v7);
      v9 = (const char *)ERR_error_string(error, 0);
      printf("OpenSSL error: %s\n", v9);
      puts("Check miner.pem Failed!");
      return 13;
    }
  }
  else
  {
    v4 = ERR_get_error(0);
    v5 = (const char *)ERR_error_string(v4, 0);
    printf("OpenSSL error: %s\n", v5);
    puts("Read Root PubK Failed!");
    return 12;
  }
}
// 10714: using guessed type int __fastcall ERR_get_error(_DWORD);
// 10750: using guessed type int __fastcall RSA_verify(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10768: using guessed type int __fastcall PEM_read_bio_RSA_PUBKEY(_DWORD, _DWORD, _DWORD, _DWORD);
// 10774: using guessed type int __fastcall SHA256_Final(_DWORD, _DWORD);
// 107A4: using guessed type int __fastcall BIO_new_mem_buf(_DWORD, _DWORD);
// 107C8: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// 107FC: using guessed type int __fastcall RSA_free(_DWORD);
// 10808: using guessed type int __fastcall SHA256_Update(_DWORD, _DWORD, _DWORD);
// 10814: using guessed type int __fastcall BIO_free(_DWORD);
// 10820: using guessed type int __fastcall SHA256_Init(_DWORD);

//----- (00010DE8) --------------------------------------------------------
int __fastcall sub_10DE8(FILE *a1, int a2, _DWORD *a3, char a4, char a5, char a6)
{
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _BYTE v17[128]; // [sp+14h] [bp-520h] BYREF
  int v18; // [sp+94h] [bp-4A0h] BYREF
  int v19; // [sp+98h] [bp-49Ch]
  int v20; // [sp+9Ch] [bp-498h]
  int v21; // [sp+A0h] [bp-494h]
  int v22; // [sp+A4h] [bp-490h]
  int v23; // [sp+A8h] [bp-48Ch]
  int v24; // [sp+ACh] [bp-488h]
  int v25; // [sp+B0h] [bp-484h]
  _BYTE v26[16]; // [sp+B4h] [bp-480h] BYREF
  size_t v27[256]; // [sp+124h] [bp-410h] BYREF
  size_t n; // [sp+524h] [bp-10h]
  FILE *s; // [sp+528h] [bp-Ch]
  int v30; // [sp+52Ch] [bp-8h]

  memset(v27, 0, sizeof(v27));
  SHA256_Init(v26);
  v30 = 0;
  n = 0;
  s = 0;
  if ( a6 )
  {
    strcpy(v17, "/tmp/tmpfw/");
    memset(&v17[12], 0, 0x74u);
    switch ( a4 )
    {
      case 0:
        strcat(v17, "BOOT.bin");
        break;
      case 1:
        strcat(v17, "devicetree.dtb");
        break;
      case 2:
        strcat(v17, "uImage");
        break;
      case 3:
        strcat(v17, "minerfs.image.gz");
        break;
      case 4:
        strcat(v17, "update.image.gz");
        break;
      case 5:
        strcat(v17, "crl.tar.gz");
        break;
      case 6:
        strcat(v17, "miner.btm.tar.gz");
        break;
      case 7:
        strcat(v17, "reserve");
        break;
      case 9:
        strcat(v17, "datafile");
        break;
      default:
        break;
    }
    if ( a5 )
      strcat(v17, ".sig");
    printf("fileName:'%s', size:[%d]\r\n", v17, a2);
    s = (FILE *)fopen64(v17, "wb");
    if ( !s )
      printf("Create File '%s' Failed!\r\n", v17);
  }
  while ( (unsigned int)(a2 - v30) > 0x400 )
  {
    n = fread(v27, 1u, 0x400u, a1);
    v30 += n;
    SHA256_Update(v26, v27, 1024);
    if ( a6 && s )
      fwrite(v27, 1u, 0x400u, s);
  }
  n = fread(v27, 1u, a2 - v30, a1);
  SHA256_Update(v26, v27, n);
  if ( a6 && s )
    fwrite(v27, 1u, n, s);
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  SHA256_Final(&v18, v26);
  if ( a6 && s )
  {
    fclose(s);
    s = 0;
  }
  v6 = v19;
  v7 = v20;
  v8 = v21;
  *a3 = v18;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  v9 = v23;
  v10 = v24;
  v11 = v25;
  a3[4] = v22;
  a3[5] = v9;
  a3[6] = v10;
  a3[7] = v11;
  return v11;
}
// 10EA0: control flows out of bounds to 10EA4
// 10774: using guessed type int __fastcall SHA256_Final(_DWORD, _DWORD);
// 10798: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 10808: using guessed type int __fastcall SHA256_Update(_DWORD, _DWORD, _DWORD);
// 10820: using guessed type int __fastcall SHA256_Init(_DWORD);

//----- (00011460) --------------------------------------------------------
int __fastcall sub_11460(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00011490) --------------------------------------------------------
__int64 __fastcall sub_11490(const void *a1)
{
  __int64 dest; // [sp+8h] [bp-Ch] BYREF

  memcpy(&dest, a1, sizeof(dest));
  return dest;
}

//----- (000114C8) --------------------------------------------------------
int __fastcall sub_114C8(int a1, unsigned int a2)
{
  return (a2 >> 15) ^ a1;
}

//----- (00011514) --------------------------------------------------------
unsigned __int64 __fastcall sub_11514(unsigned __int64 a1, char a2)
{
  return (a1 >> a2) | (a1 << (-a2 & 0x3F));
}

//----- (00011598) --------------------------------------------------------
unsigned __int64 __fastcall sub_11598(int a1, int a2, __int64 a3, __int64 a4)
{
  int v4; // r1
  unsigned __int64 v5; // r2

  v4 = (a1 ^ a3) * HIDWORD(a4) + (a2 ^ HIDWORD(a3)) * a4;
  v5 = (unsigned int)a4 * (unsigned __int64)(a1 ^ (unsigned int)a3);
  HIDWORD(v5) += v4;
  return a4
       * (((a3 ^ v5 ^ (HIDWORD(v5) >> 15)) * a4) ^ ((unsigned int)(((a3 ^ v5 ^ (HIDWORD(v5) >> 15)) * a4) >> 32) >> 15));
}

//----- (000116C8) --------------------------------------------------------
unsigned __int64 __fastcall sub_116C8(unsigned __int8 *a1, unsigned int a2)
{
  unsigned __int64 v2; // r0
  __int64 v3; // r2
  int v4; // r0
  unsigned __int64 v5; // r0
  int v6; // r0
  int v7; // r1
  __int64 v9; // [sp+28h] [bp-74h]
  unsigned __int64 v12; // [sp+40h] [bp-5Ch]
  unsigned __int64 v13; // [sp+48h] [bp-54h]
  unsigned __int64 v14; // [sp+50h] [bp-4Ch]
  __int64 v15; // [sp+58h] [bp-44h]
  unsigned int v16; // [sp+74h] [bp-28h]

  if ( a2 <= 7 )
  {
    if ( a2 <= 3 )
    {
      if ( a2 )
      {
        v16 = a2 + 4 * a1[a2 - 1];
        v5 = 0x9AE16A3B2F90404FLL * (*a1 + (a1[a2 >> 1] << 8));
        v6 = sub_114C8(
               v5 ^ (-1748291289 * v16),
               HIDWORD(v5) ^ (-1012545444 * v16 + ((2546676007u * (unsigned __int64)v16) >> 32)));
        v3 = 797982799LL * (unsigned int)v6;
        HIDWORD(v3) += 797982799 * v7 - 1696503237 * v6;
      }
      else
      {
        return 0x9AE16A3B2F90404FLL;
      }
    }
    else
    {
      v9 = a2 + 8LL * (unsigned int)sub_11460((int)a1);
      v4 = sub_11460((int)&a1[a2 - 4]);
      return sub_11598(v9, SHIDWORD(v9), (unsigned int)v4, 2 * a2 - 0x651E95C4D06FBFB1LL);
    }
  }
  else
  {
    v15 = 2 * a2 - 0x651E95C4D06FBFB1LL;
    v14 = sub_11490(a1) - 0x651E95C4D06FBFB1LL;
    v13 = sub_11490(&a1[a2 - 8]);
    v12 = v14 + v15 * sub_11514(v13, 37);
    v2 = sub_11514(v14, 25);
    return sub_11598(v12, SHIDWORD(v12), (v2 + v13) * v15, v15);
  }
  return v3;
}
// 119B8: variable 'v7' is possibly undefined

//----- (00011A00) --------------------------------------------------------
unsigned __int64 __fastcall sub_11A00(int a1, int a2)
{
  __int64 v2; // r0
  __int64 v3; // r2
  __int64 v4; // r0
  __int64 v5; // r2
  unsigned __int64 v6; // r0
  __int64 v8; // [sp+8h] [bp-6Ch]
  unsigned __int64 v9; // [sp+18h] [bp-5Ch]
  __int64 v12; // [sp+30h] [bp-44h]
  unsigned __int64 v13; // [sp+38h] [bp-3Ch]
  __int64 v14; // [sp+40h] [bp-34h]
  __int64 v15; // [sp+48h] [bp-2Ch]
  __int64 v16; // [sp+50h] [bp-24h]

  v16 = (unsigned int)(2 * a2) - 0x651E95C4D06FBFB1LL;
  v2 = sub_11490((const void *)a1);
  v3 = 3197694579LL * (unsigned int)v2;
  HIDWORD(v3) += -1097272717 * HIDWORD(v2) - 1265453457 * v2;
  v15 = v3;
  v14 = sub_11490((const void *)(a1 + 8));
  v13 = sub_11490((const void *)(a1 + a2 - 8)) * v16;
  v4 = sub_11490((const void *)(a1 + a2 - 16));
  v5 = 797982799LL * (unsigned int)v4;
  HIDWORD(v5) += 797982799 * HIDWORD(v4) - 1696503237 * v4;
  v12 = v5;
  v6 = sub_11514(v15 + v14, 43);
  v9 = v6 + sub_11514(v13, 30) + v12;
  v8 = sub_11514(v14 - 0x651E95C4D06FBFB1LL, 18) + v15 + v13;
  return sub_11598(v9, SHIDWORD(v9), v8, v16);
}

//----- (00011BE0) --------------------------------------------------------
unsigned __int64 __fastcall sub_11BE0(int a1, int a2)
{
  __int64 v2; // r0
  __int64 v3; // r2
  __int64 v4; // r0
  __int64 v5; // r2
  unsigned __int64 v6; // r0
  unsigned __int64 v7; // r0
  __int64 v9; // [sp+10h] [bp-D4h]
  unsigned __int64 v10; // [sp+28h] [bp-BCh]
  __int64 v11; // [sp+50h] [bp-94h]
  __int64 v14; // [sp+70h] [bp-74h]
  unsigned __int64 v15; // [sp+78h] [bp-6Ch]
  __int64 v16; // [sp+80h] [bp-64h]
  __int64 v17; // [sp+88h] [bp-5Ch]
  unsigned __int64 v18; // [sp+90h] [bp-54h]
  unsigned __int64 v19; // [sp+98h] [bp-4Ch]
  __int64 v20; // [sp+A0h] [bp-44h]
  unsigned __int64 v21; // [sp+A8h] [bp-3Ch]
  __int64 v22; // [sp+B0h] [bp-34h]
  __int64 v23; // [sp+B8h] [bp-2Ch]
  __int64 v24; // [sp+C0h] [bp-24h]

  v24 = (unsigned int)(2 * a2) - 0x651E95C4D06FBFB1LL;
  v2 = sub_11490((const void *)a1);
  v3 = 797982799LL * (unsigned int)v2;
  HIDWORD(v3) += 797982799 * HIDWORD(v2) - 1696503237 * v2;
  v23 = v3;
  v22 = sub_11490((const void *)(a1 + 8));
  v21 = sub_11490((const void *)(a1 + a2 - 8)) * v24;
  v4 = sub_11490((const void *)(a1 + a2 - 16));
  v5 = 797982799LL * (unsigned int)v4;
  HIDWORD(v5) += 797982799 * HIDWORD(v4) - 1696503237 * v4;
  v20 = v5;
  v6 = sub_11514(v23 + v22, 43);
  v19 = v20 + v6 + sub_11514(v21, 30);
  v11 = sub_11514(v22 - 0x651E95C4D06FBFB1LL, 18) + v23 + v21;
  v18 = sub_11598(v19, SHIDWORD(v19), v11, v24);
  v17 = sub_11490((const void *)(a1 + 16)) * v24;
  v16 = sub_11490((const void *)(a1 + 24));
  v15 = (sub_11490((const void *)(a1 + a2 - 32)) + v19) * v24;
  v14 = (sub_11490((const void *)(a1 + a2 - 24)) + v18) * v24;
  v7 = sub_11514(v17 + v16, 43);
  v10 = v7 + sub_11514(v15, 30) + v14;
  v9 = sub_11514(v16 + v23, 18) + v17 + v15;
  return sub_11598(v10, SHIDWORD(v10), v9, v24);
}

//----- (00011FBC) --------------------------------------------------------
_QWORD *__fastcall sub_11FBC(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned __int64 a6,
        __int64 a7)
{
  unsigned __int64 v10; // [sp+40h] [bp-2Ch]
  unsigned __int64 v11; // [sp+48h] [bp-24h]
  unsigned __int64 v12; // [sp+88h] [bp+1Ch]
  unsigned __int64 v13; // [sp+88h] [bp+1Ch]
  unsigned __int64 v14; // [sp+90h] [bp+24h]

  v12 = a6 + a2;
  v14 = sub_11514(a7 + v12 + a5, 21);
  v11 = v12;
  v13 = v12 + a3 + a4;
  v10 = v14 + sub_11514(v13, 44) + v11;
  *a1 = v13 + a5;
  a1[1] = v10;
  return a1;
}

//----- (000120DC) --------------------------------------------------------
_QWORD *__fastcall sub_120DC(_QWORD *a1, int a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r4
  __int64 v6; // r6
  __int64 v7; // r0

  v4 = sub_11490((const void *)a2);
  v5 = sub_11490((const void *)(a2 + 8));
  v6 = sub_11490((const void *)(a2 + 16));
  v7 = sub_11490((const void *)(a2 + 24));
  sub_11FBC(a1, v4, v5, v6, v7, a3, a4);
  return a1;
}

//----- (00012180) --------------------------------------------------------
unsigned __int64 __fastcall sub_12180(unsigned __int8 *a1, unsigned int a2)
{
  __int64 v3; // r2
  int v4; // r0
  int v5; // r1
  __int64 v6; // r2
  unsigned __int64 v7; // r0
  __int64 v8; // r2
  unsigned __int64 v9; // r0
  __int64 v10; // r2
  __int64 v11; // r4
  unsigned __int64 v12; // r0
  unsigned __int64 v13; // r2
  __int64 v14; // r0
  unsigned __int8 *v15; // r4
  __int64 v16; // r0
  unsigned __int64 v17; // r4
  int v18; // r0
  int v19; // r1
  __int64 v20; // r2
  unsigned __int64 v21; // r0
  unsigned __int64 v23; // [sp+18h] [bp-1C4h]
  unsigned __int64 v24; // [sp+50h] [bp-18Ch]
  __int64 v25; // [sp+68h] [bp-174h]
  __int64 v26; // [sp+70h] [bp-16Ch]
  unsigned __int64 v27; // [sp+80h] [bp-15Ch]
  unsigned __int64 v28; // [sp+98h] [bp-144h]
  __int64 v29; // [sp+B0h] [bp-12Ch]
  unsigned __int64 v30; // [sp+C0h] [bp-11Ch]
  unsigned __int64 v31; // [sp+C8h] [bp-114h]
  unsigned __int64 v32; // [sp+D0h] [bp-10Ch]
  unsigned __int64 v33; // [sp+D8h] [bp-104h]
  unsigned __int64 v34; // [sp+118h] [bp-C4h]
  unsigned __int64 v35; // [sp+130h] [bp-ACh]
  unsigned __int64 v36; // [sp+138h] [bp-A4h]
  unsigned __int64 v37; // [sp+140h] [bp-9Ch]
  unsigned __int64 v38; // [sp+148h] [bp-94h]
  __int64 v39; // [sp+158h] [bp-84h] BYREF
  __int64 v40; // [sp+160h] [bp-7Ch]
  unsigned int v41; // [sp+168h] [bp-74h]
  unsigned __int8 *v42; // [sp+16Ch] [bp-70h]
  __int64 v43; // [sp+170h] [bp-6Ch] BYREF
  __int64 v44; // [sp+178h] [bp-64h]
  __int64 v45; // [sp+180h] [bp-5Ch] BYREF
  __int64 v46; // [sp+188h] [bp-54h]
  __int64 v47; // [sp+190h] [bp-4Ch]
  unsigned __int8 *v48; // [sp+198h] [bp-44h]
  unsigned __int8 *v49; // [sp+19Ch] [bp-40h]
  __int64 v50; // [sp+1A0h] [bp-3Ch]
  unsigned __int64 v51; // [sp+1A8h] [bp-34h]
  unsigned __int64 v52; // [sp+1B0h] [bp-2Ch]
  unsigned __int64 v53; // [sp+1B8h] [bp-24h]

  v42 = a1;
  v41 = a2;
  v50 = 81;
  if ( a2 <= 0x10 )
    return sub_116C8(v42, v41);
  if ( v41 <= 0x20 )
    return sub_11A00((int)v42, v41);
  if ( v41 <= 0x40 )
    return sub_11BE0((int)v42, v41);
  v3 = 3197694579LL * (unsigned int)v50;
  HIDWORD(v3) += -1265453457 * v50 - 1097272717 * HIDWORD(v50);
  v52 = v3 + 113;
  v4 = sub_114C8(797982799 * (v3 + 113) + 113, (0x9AE16A3B2F90404FLL * (v3 + 113) + 113) >> 32);
  v6 = 797982799LL * (unsigned int)v4;
  HIDWORD(v6) += 797982799 * v5 - 1696503237 * v4;
  v51 = v6;
  v45 = 0;
  v46 = 0;
  v43 = 0;
  v44 = 0;
  v53 = 0x9AE16A3B2F90404FLL * v50 + sub_11490(v42);
  v49 = &v42[(v41 - 1) & 0xFFFFFFC0];
  v48 = &v49[(((_BYTE)v41 - 1) & 0x3F) - 63];
  do
  {
    v38 = v53 + v52 + v45;
    v37 = v38 + sub_11490(v42 + 8);
    v7 = sub_11514(v37, 37);
    v8 = 3197694579LL * (unsigned int)v7;
    HIDWORD(v8) += -1097272717 * HIDWORD(v7) - 1265453457 * v7;
    v53 = v8;
    v36 = v46 + v52;
    v35 = v36 + sub_11490(v42 + 48);
    v9 = sub_11514(v35, 42);
    v10 = 3197694579LL * (unsigned int)v9;
    HIDWORD(v10) += -1097272717 * HIDWORD(v9) - 1265453457 * v9;
    v52 = v10;
    v53 ^= v44;
    v11 = v45;
    v26 = v11 + sub_11490(v42 + 40);
    v52 += v26;
    v12 = sub_11514(v43 + v51, 33);
    v13 = 3197694579LL * (unsigned int)v12;
    HIDWORD(v13) += -1097272717 * HIDWORD(v12) - 1265453457 * v12;
    v51 = v13;
    LODWORD(v13) = -1097272717 * v46;
    HIDWORD(v13) = -1097272717 * HIDWORD(v46)
                 - 1265453457 * v46
                 + ((3197694579u * (unsigned __int64)(unsigned int)v46) >> 32);
    sub_120DC(&v45, (int)v42, v13, v43 + v53);
    v34 = v44 + v51;
    v14 = sub_11490(v42 + 16);
    sub_120DC(&v43, (int)(v42 + 32), v34, v14 + v52);
    v24 = v51 ^ v53;
    v53 = v51;
    v51 ^= v24;
    v42 += 64;
  }
  while ( v42 != v49 );
  v47 = ((2 * (int)v51) & 0x1FELL) - 0x4B6D499041670D8DLL;
  v42 = v48;
  v43 += (v41 - 1) & 0x3FLL;
  v45 += v43;
  v43 += v45;
  v33 = v53 + v52 + v45;
  v32 = v33 + sub_11490(v48 + 8);
  v53 = sub_11514(v32, 37) * v47;
  v31 = v46 + v52;
  v30 = v31 + sub_11490(v42 + 48);
  v52 = sub_11514(v30, 42) * v47;
  v53 ^= 9 * v44;
  v29 = 9 * v45;
  v25 = v29 + sub_11490(v42 + 40);
  v52 += v25;
  v51 = sub_11514(v43 + v51, 33) * v47;
  sub_120DC(&v39, (int)v42, v47 * v46, v43 + v53);
  v45 = v39;
  v46 = v40;
  v15 = v42 + 32;
  v28 = v44 + v51;
  v16 = sub_11490(v42 + 16);
  sub_120DC(&v39, (int)v15, v28, v16 + v52);
  v43 = v39;
  v44 = v40;
  v23 = v51 ^ v53;
  v53 = v51;
  v51 ^= v23;
  v17 = sub_11598(v45, SHIDWORD(v45), v39, v47);
  v18 = sub_114C8(v52, HIDWORD(v52));
  v20 = 2546676007LL * (unsigned int)v18;
  HIDWORD(v20) += -1748291289 * v19 - 1012545444 * v18;
  v27 = v17 + v20 + v51;
  v21 = sub_11598(v46, SHIDWORD(v46), v44, v47);
  return sub_11598(v27, SHIDWORD(v27), v21 + v53, v47);
}
// 12294: variable 'v5' is possibly undefined
// 12B88: variable 'v19' is possibly undefined

//----- (00012C40) --------------------------------------------------------
int __fastcall sub_12C40(const char *a1, char *a2, const char *a3, _BYTE *a4, char a5, char a6, char a7)
{
  size_t v8; // r0
  int v9; // r0
  const char *v10; // r0
  int v11; // r0
  int error; // r0
  const char *v13; // r0
  _DWORD v19[65]; // [sp+1Ch] [bp-BF0h] BYREF
  _BYTE v20[12]; // [sp+120h] [bp-AECh] BYREF
  _DWORD v21[8]; // [sp+190h] [bp-A7Ch] BYREF
  _DWORD v22[64]; // [sp+1B0h] [bp-A5Ch] BYREF
  _BYTE v23[12]; // [sp+2B0h] [bp-95Ch] BYREF
  _OWORD v24[66]; // [sp+320h] [bp-8ECh] BYREF
  _DWORD v25[256]; // [sp+740h] [bp-4CCh] BYREF
  __int64 dest; // [sp+B40h] [bp-CCh] BYREF
  int v27; // [sp+B78h] [bp-94h]
  unsigned int v28; // [sp+BB0h] [bp-5Ch]
  int v29; // [sp+BB4h] [bp-58h]
  int v30; // [sp+BB8h] [bp-54h]
  int bio_RSA_PUBKEY; // [sp+BBCh] [bp-50h]
  int v32; // [sp+BC0h] [bp-4Ch]
  FILE *v33; // [sp+BC4h] [bp-48h]
  FILE *v34; // [sp+BC8h] [bp-44h]
  int v35; // [sp+BCCh] [bp-40h]
  size_t n; // [sp+BD0h] [bp-3Ch]
  FILE *v37; // [sp+BD4h] [bp-38h]
  unsigned int v38; // [sp+BD8h] [bp-34h]
  unsigned __int16 v39; // [sp+BDEh] [bp-2Eh]
  unsigned __int64 v40; // [sp+BE0h] [bp-2Ch]
  FILE *stream; // [sp+BE8h] [bp-24h]
  int v42; // [sp+BECh] [bp-20h]
  int m; // [sp+BF0h] [bp-1Ch]
  int k; // [sp+BF4h] [bp-18h]
  int j; // [sp+BF8h] [bp-14h]
  int v46; // [sp+BFCh] [bp-10h]
  int i; // [sp+C00h] [bp-Ch]
  unsigned __int8 v48; // [sp+C07h] [bp-5h]

  sub_13BA4();
  v42 = v27;
  if ( v27 >= 2048 )
  {
    stream = (FILE *)fopen64(a1, "rb");
    if ( stream )
    {
      fread(a4, 0x800u, 1u, stream);
      if ( *a4 == 38 )
      {
        printf("miner_type %s\n", a2);
        v8 = strlen(a2);
        v40 = sub_12180((unsigned __int8 *)a2, v8);
        memcpy(&dest, a4 + 2, sizeof(dest));
        printf("miner_type_hash %16llx, bmu_hash %16llx\n", v40, dest);
        if ( v40 == dest )
        {
          v48 = 0;
          v39 = _byteswap_ushort(*(_WORD *)(a4 + 11));
          if ( !a7 || (printf("content:%x\n", v39), (v39 & 0xFE00) == 0xFE00) )
          {
            for ( i = 0; i <= 15; ++i )
            {
              if ( (((int)v39 >> i) & 1) != 0 )
                ++v48;
            }
            if ( v48 == (unsigned __int8)a4[1304] )
            {
              v46 = ((unsigned __int8)a4[1304] + 9) << 8;
              v38 = _byteswap_ulong(*(_DWORD *)(a4 + 1305));
              for ( j = 0; j < v48; ++j )
              {
                v28 = _byteswap_ulong(*(_DWORD *)&a4[5 * j + 1310]);
                v46 += v28;
                printf("file[%d] size:[%d]\n", j, v28);
              }
              if ( v46 == v42 )
              {
                v37 = (FILE *)fopen64(a3, "r");
                if ( v37 )
                {
                  memset(v25, 0, sizeof(v25));
                  fread(v25, 0x400u, 1u, v37);
                  fclose(v37);
                  v37 = 0;
                  n = ((unsigned __int8)a4[22] << 8) | (unsigned __int8)a4[23];
                  v35 = sub_10C70((int)(a4 + 24), n, (int)(a4 + 1048), (int)v25);
                  if ( v35 )
                  {
                    printf("Check pem payload failed! ret:[%d]\n", v35);
                    if ( stream )
                      fclose(stream);
                    return v35;
                  }
                  else
                  {
                    v34 = (FILE *)fopen64("/usr/bin/fw_version", "w");
                    if ( v34 )
                    {
                      fwrite(a4 + 13, 1u, 8u, v34);
                      fclose(v34);
                    }
                    if ( a5 )
                    {
                      v33 = (FILE *)fopen64("/tmp/tmpfw/miner.pem", "w");
                      if ( !v33 )
                      {
                        puts("Dump Miner.pem Failed!\r");
                        return 15;
                      }
                      fwrite(a4 + 24, 1u, n, v33);
                      fclose(v33);
                      v33 = (FILE *)fopen64("/tmp/tmpfw/miner.pem.sig", "w");
                      if ( !v33 )
                      {
                        puts("Dump Miner.pem.sig Failed!\r");
                        return 16;
                      }
                      fwrite(a4 + 1048, 1u, 0x100u, v33);
                      fclose(v33);
                    }
                    memset(v24, 0, sizeof(v24));
                    SHA256_Init(v23);
                    SHA256_Update(v23, a4, 2048);
                    SHA256_Final(v24, v23);
                    for ( k = 0; k < v48; ++k )
                    {
                      v29 = _byteswap_ulong(*(_DWORD *)&a4[5 * k + 1310]);
                      sub_10DE8(stream, v29, &v24[2 * k + 2], a4[5 * k + 1309], 0, a5);
                    }
                    for ( m = 0; m < v48; ++m )
                      sub_10DE8(stream, 256, &v24[2 * v48 + 2 + 2 * m], a4[5 * m + 1309], 1, a5);
                    memset(v22, 0, sizeof(v22));
                    fseek(stream, -256, 2);
                    fread(v22, 0x100u, 1u, stream);
                    memset(v21, 0, sizeof(v21));
                    SHA256_Init(v20);
                    SHA256_Update(v20, v24, (v48 << 6) + 32);
                    SHA256_Final(v21, v20);
                    v32 = 0;
                    bio_RSA_PUBKEY = 0;
                    v32 = BIO_new_mem_buf(a4 + 24, 1024);
                    bio_RSA_PUBKEY = PEM_read_bio_RSA_PUBKEY(v32, 0, 0, 0);
                    if ( bio_RSA_PUBKEY )
                    {
                      v30 = RSA_verify(672, v21, 32, v22, 256, bio_RSA_PUBKEY);
                      if ( bio_RSA_PUBKEY )
                        RSA_free(bio_RSA_PUBKEY);
                      if ( v32 )
                        BIO_free(v32);
                      if ( v30 == 1 )
                      {
                        if ( stream )
                          fclose(stream);
                        stream = 0;
                        puts("All Done!\r");
                        if ( a6 )
                        {
                          puts("This Comment Of This Package:");
                          memset(v19, 0, 257);
                          memcpy(v19, a4 + 1360, 0x100u);
                          puts((const char *)v19);
                        }
                        return 0;
                      }
                      else
                      {
                        v11 = puts("Check File Sig failed!\r");
                        error = ERR_get_error(v11);
                        v13 = (const char *)ERR_error_string(error, 0);
                        printf("OpenSSL error: %s\n", v13);
                        return 18;
                      }
                    }
                    else
                    {
                      v9 = ERR_get_error(0);
                      v10 = (const char *)ERR_error_string(v9, 0);
                      printf("OpenSSL error: %s\n", v10);
                      puts("Load Pem Failed!");
                      return 17;
                    }
                  }
                }
                else
                {
                  printf("Cannot Open Root PublicKey '%s'!\n", a3);
                  if ( stream )
                    fclose(stream);
                  return 11;
                }
              }
              else
              {
                printf(
                  "Check FileSize Failed, FileSize Should Be [%d]Bytes, But It Was [%d] Bytes, And Total Says[%d]\n",
                  v38,
                  v42,
                  v46);
                if ( stream )
                  fclose(stream);
                return 10;
              }
            }
            else
            {
              printf("Content Doesn't Match![%d][%d]\n", (unsigned __int8)a4[1304], v48);
              if ( stream )
                fclose(stream);
              return 9;
            }
          }
          else
          {
            puts("This Package Was Not Full Package!");
            return 20;
          }
        }
        else
        {
          puts("input miner_type and bmu miner type donot match!");
          if ( stream )
            fclose(stream);
          return 30;
        }
      }
      else
      {
        printf("'%s' Not A Btmu File!\n", a1);
        fclose(stream);
        return 8;
      }
    }
    else
    {
      printf("Read File '%s' Failed!\n", a1);
      return 7;
    }
  }
  else
  {
    printf("File '%s' Not Enough %d, Something Wrong!\n", a1, 2048);
    return 6;
  }
}
// 12D18: conditional instruction was optimized away because %stream.4!=0
// 10714: using guessed type int __fastcall ERR_get_error(_DWORD);
// 10750: using guessed type int __fastcall RSA_verify(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10768: using guessed type int __fastcall PEM_read_bio_RSA_PUBKEY(_DWORD, _DWORD, _DWORD, _DWORD);
// 10774: using guessed type int __fastcall SHA256_Final(_DWORD, _DWORD);
// 10798: using guessed type int __fastcall fopen64(_DWORD, _DWORD);
// 107A4: using guessed type int __fastcall BIO_new_mem_buf(_DWORD, _DWORD);
// 107C8: using guessed type int __fastcall ERR_error_string(_DWORD, _DWORD);
// 107FC: using guessed type int __fastcall RSA_free(_DWORD);
// 10808: using guessed type int __fastcall SHA256_Update(_DWORD, _DWORD, _DWORD);
// 10814: using guessed type int __fastcall BIO_free(_DWORD);
// 10820: using guessed type int __fastcall SHA256_Init(_DWORD);

//----- (00013B64) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int (__fastcall **v7)(int, int, int); // r5
  int v8; // r6
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = (int (__fastcall **)(int, int, int))&off_24F08;
  v8 = &off_24F0C - &off_24F08;
  if ( v8 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v10 = *v7++;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 24F08: using guessed type _UNKNOWN *off_24F08;
// 24F0C: using guessed type _UNKNOWN *off_24F0C;

//----- (00013BA4) --------------------------------------------------------
int sub_13BA4()
{
  return j___xstat64();
}

//----- (00013BB0) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=80 queued=28 decompiled=28 lumina nreq=0 worse=0 better=0
// ALL OK, 28 function(s) have been successfully decompiled
