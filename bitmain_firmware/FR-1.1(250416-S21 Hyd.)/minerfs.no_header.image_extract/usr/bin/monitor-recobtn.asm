;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2025 Hex-Rays, <support@hex-rays.com>           |
; |                      License info: 48-2137-ACAB-99                      |
; |                              elf <elv@ven>                              |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : C4F43880F20CC0BD10DC2D592E9FB3BC83F2C41652735992BA9A216E42298F2C
; Input MD5    : 2D56CFB5FA1762ACFEC0564EA4973698
; Input CRC32  : E390764C
; Compiler     : GNU C++

; File Name   : /home/danielsokil/Lab/HashSource/hashsource_antminer_S21x/bitmain_firmware/FR-1.1(250416-S21 Hyd.)/minerfs.no_header.image_extract/usr/bin/monitor-recobtn
; Format      : ELF for ARM (Executable)
; Imagebase   : 10000
; Interpreter '/lib/ld-linux-armhf.so.3'
; Needed Library 'libc.so.6'
;
; Options     : EF_ARM_VFP_FLOAT
; EABI version: 5
;

; Processor       : ARM
; ARM architecture: ARMv7-A
; Target assembler: Generic assembler for ARM
; Byte sex        : Little endian


; Segment type: Pure code
AREA LOAD, CODE, ALIGN=0
; ORG 0x10000
CODE32
dword_10000 DCD 0x464C457F ; File format: \x7FELF
DCB 1                   ; File class: 32-bit
DCB 1                   ; Data encoding: little-endian
DCB 1                   ; File version
DCB 0                   ; OS/ABI: UNIX System V ABI
DCB 0                   ; ABI Version
DCB 0, 0, 0, 0, 0, 0, 0 ; Padding
DCW 2                   ; File type: Executable
DCW 0x28                ; Machine: ARM
DCD 1                   ; File version
DCD start+1             ; Entry point
DCD 0x34                ; PHT file offset
DCD 0x118C              ; SHT file offset
DCD 0x5000400           ; Processor-specific flags
DCW 0x34                ; ELF header size
DCW 0x20                ; PHT entry size
DCW 9                   ; Number of entries in PHT
DCW 0x28                ; SHT entry size
DCW 0x1A                ; Number of entries in SHT
DCW 0x19                ; SHT entry index for string table
; LOAD ends

; ELF32 Program Header
; PHT Entry 0

; Segment type: Pure code
AREA PHDR, CODE
; ORG 0x10034
CODE32
dword_10034 DCD 0x70000001 ; Type: EXIDX
DCD 0xCE8               ; File offset
DCD unk_10CE8           ; Virtual address
DCD 0x10CE8             ; Physical address
DCD 8                   ; Size in file image
DCD 8                   ; Size in memory image
DCD 4                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 1
DCD 6                   ; Type: PHDR
DCD 0x34                ; File offset
DCD dword_10034         ; Virtual address
DCD 0x10034             ; Physical address
DCD 0x120               ; Size in file image
DCD 0x120               ; Size in memory image
DCD 5                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 2
DCD 3                   ; Type: INTERP
DCD 0x154               ; File offset
DCD aLibLdLinuxArmh     ; Virtual address
DCD 0x10154             ; Physical address
DCD 0x19                ; Size in file image
DCD 0x19                ; Size in memory image
DCD 4                   ; Flags
DCD 1                   ; Alignment
; PHT Entry 3
DCD 1                   ; Type: LOAD
DCD 0                   ; File offset
DCD dword_10000         ; Virtual address
DCD 0x10000             ; Physical address
DCD 0xCF4               ; Size in file image
DCD 0xCF4               ; Size in memory image
DCD 5                   ; Flags
DCD 0x10000             ; Alignment
; PHT Entry 4
DCD 1                   ; Type: LOAD
DCD 0xF10               ; File offset
DCD off_20F10           ; Virtual address
DCD 0x20F10             ; Physical address
DCD 0x15C               ; Size in file image
DCD 0x160               ; Size in memory image
DCD 6                   ; Flags
DCD 0x10000             ; Alignment
; PHT Entry 5
DCD 2                   ; Type: DYNAMIC
DCD 0xF18               ; File offset
DCD stru_20F18          ; Virtual address
DCD 0x20F18             ; Physical address
DCD 0xE8                ; Size in file image
DCD 0xE8                ; Size in memory image
DCD 6                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 6
DCD 4                   ; Type: NOTE
DCD 0x170               ; File offset
DCD dword_10170         ; Virtual address
DCD 0x10170             ; Physical address
DCD 0x44                ; Size in file image
DCD 0x44                ; Size in memory image
DCD 4                   ; Flags
DCD 4                   ; Alignment
; PHT Entry 7
DCD 0x6474E551          ; Type: STACK
DCD 0                   ; File offset
DCD 0                   ; Virtual address
DCD 0                   ; Physical address
DCD 0                   ; Size in file image
DCD 0                   ; Size in memory image
DCD 6                   ; Flags
DCD 0x10                ; Alignment
; PHT Entry 8
DCD 0x6474E552          ; Type: RO-AFTER
DCD 0xF10               ; File offset
DCD off_20F10           ; Virtual address
DCD 0x20F10             ; Physical address
DCD 0xF0                ; Size in file image
DCD 0xF0                ; Size in memory image
DCD 4                   ; Flags
DCD 1                   ; Alignment
; PHDR ends


; Segment type: Pure code
AREA LOAD, CODE, ALIGN=0
; ORG 0x10154
CODE32
aLibLdLinuxArmh DCB "/lib/ld-linux-armhf.so.3",0
DCB 0, 0, 0
; ELF Note Entry
dword_10170 DCD 4       ; Name Size
DCD 0x10                ; Desc Size
DCD 1                   ; Type: NT_GNU_ABI_TAG
aGnu DCB "GNU",0        ; Name
DCD 0, 3, 2, 0          ; ABI: Linux 3.2.0
; ELF Note Entry
DCD 4                   ; Name Size
DCD 0x14                ; Desc Size
DCD 3                   ; Type: NT_GNU_BUILD_ID
aGnu_0 DCB "GNU",0      ; Name
DCB 0x58, 0x9E, 0xFE, 0x50, 0x28, 0x2E, 0x88 ; Desc
DCB 0xDE, 0x5F, 0x79, 0x60, 0xD4, 0xA3, 0x85
DCB 0x89, 0x15, 0xA0, 0x9E, 0xE6, 0x73
; ELF Hash Table
elf_hash_nbucket DCD 0x11
elf_hash_nchain DCD 0x16
elf_hash_bucket DCD 4, 0, 0x12, 0x11, 0x10, 0, 5, 0xA, 0x14
DCD 2, 0x15, 3, 0, 0xF, 0, 0xC, 0
elf_hash_chain DCD 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0xB
DCD 0, 9, 0xD, 0xE, 0, 8, 6, 0, 0x13
; ELF Symbol Table
Elf32_Sym <0>
Elf32_Sym <aSprintf+1 - byte_103B8, 0, \ ; "printf"
           0, 0x12, 0, 0>
Elf32_Sym <aIsoc99Fscanf - byte_103B8, \ ; "__isoc99_fscanf"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aExecvp - byte_103B8, 0, 0, \ ; "execvp"
           0x12, 0, 0>
Elf32_Sym <aUsleep+1 - byte_103B8, 0, 0,\ ; "sleep"
           0x12, 0, 0>
Elf32_Sym <aWait - byte_103B8, 0, 0, \ ; "wait"
           0x12, 0, 0>
Elf32_Sym <aFwrite - byte_103B8, 0, 0, \ ; "fwrite"
           0x12, 0, 0>
Elf32_Sym <aUsleep - byte_103B8, 0, 0, \ ; "usleep"
           0x12, 0, 0>
Elf32_Sym <aGettimeofday - byte_103B8, \ ; "gettimeofday"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aPuts - byte_103B8, 0, 0, \ ; "puts"
           0x12, 0, 0>
Elf32_Sym <aLibcStartMain - byte_103B8, \ ; "__libc_start_main"
           0, 0, 0x12, 0, 0>
Elf32_Sym <aSystem - byte_103B8, 0, 0, \ ; "system"
           0x12, 0, 0>
Elf32_Sym <aGmonStart - byte_103B8, 0, \ ; "__gmon_start__"
           0, 0x20, 0, 0>
Elf32_Sym <aExit - byte_103B8, 0, 0, \ ; "exit"
           0x12, 0, 0>
Elf32_Sym <aStrlen - byte_103B8, 0, 0, \ ; "strlen"
           0x12, 0, 0>
Elf32_Sym <aMemset - byte_103B8, 0, 0, \ ; "memset"
           0x12, 0, 0>
Elf32_Sym <aAccess - byte_103B8, 0, 0, \ ; "access"
           0x12, 0, 0>
Elf32_Sym <aFclose - byte_103B8, 0, 0, \ ; "fclose"
           0x12, 0, 0>
Elf32_Sym <aFork - byte_103B8, 0, 0, \ ; "fork"
           0x12, 0, 0>
Elf32_Sym <aSprintf - byte_103B8, 0, 0, \ ; "sprintf"
           0x12, 0, 0>
Elf32_Sym <aFopen64 - byte_103B8, 0, 0, \ ; "fopen64"
           0x12, 0, 0>
Elf32_Sym <aAbort - byte_103B8, 0, 0, \ ; "abort"
           0x12, 0, 0>
; ELF String Table
byte_103B8 DCB 0
aLibcSo6 DCB "libc.so.6",0
aExit DCB "exit",0
aSprintf DCB "sprintf",0
aWait DCB "wait",0
aPuts DCB "puts",0
aFork DCB "fork",0
aAbort DCB "abort",0
aStrlen DCB "strlen",0
aMemset DCB "memset",0
aIsoc99Fscanf DCB "__isoc99_fscanf",0
aFclose DCB "fclose",0
aSystem DCB "system",0
aExecvp DCB "execvp",0
aUsleep DCB "usleep",0
aFwrite DCB "fwrite",0
aGettimeofday DCB "gettimeofday",0
aFopen64 DCB "fopen64",0
aAccess DCB "access",0
aLibcStartMain DCB "__libc_start_main",0
aGmonStart DCB "__gmon_start__",0
aGlibc27 DCB "GLIBC_2.7",0
aGlibc24 DCB "GLIBC_2.4",0
DCB 0
; ELF GNU Symbol Version Table
DCW 0
DCW 2                   ; printf@@GLIBC_2.4
DCW 3                   ; __isoc99_fscanf@@GLIBC_2.7
DCW 2                   ; execvp@@GLIBC_2.4
DCW 2                   ; sleep@@GLIBC_2.4
DCW 2                   ; wait@@GLIBC_2.4
DCW 2                   ; fwrite@@GLIBC_2.4
DCW 2                   ; usleep@@GLIBC_2.4
DCW 2                   ; gettimeofday@@GLIBC_2.4
DCW 2                   ; puts@@GLIBC_2.4
DCW 2                   ; __libc_start_main@@GLIBC_2.4
DCW 2                   ; system@@GLIBC_2.4
DCW 0                   ; local  symbol: __gmon_start__
DCW 2                   ; exit@@GLIBC_2.4
DCW 2                   ; strlen@@GLIBC_2.4
DCW 2                   ; memset@@GLIBC_2.4
DCW 2                   ; access@@GLIBC_2.4
DCW 2                   ; fclose@@GLIBC_2.4
DCW 2                   ; fork@@GLIBC_2.4
DCW 2                   ; sprintf@@GLIBC_2.4
DCW 2                   ; fopen64@@GLIBC_2.4
DCW 2                   ; abort@@GLIBC_2.4
; ELF GNU Symbol Version Requirements
Elf32_Verneed <1, 2, \  ; "libc.so.6"
               aLibcSo6 - byte_103B8, \
               0x10, 0>
Elf32_Vernaux <0xD696917, 0, 3, \ ; "GLIBC_2.7"
               aGlibc27 - byte_103B8, \
               0x10>
Elf32_Vernaux <0xD696914, 0, 2, \ ; "GLIBC_2.4"
               aGlibc24 - byte_103B8, 0>
; ELF REL Relocation Table
Elf32_Rel <0x21060, 0xC15> ; R_ARM_GLOB_DAT __gmon_start__
; ELF JMPREL Relocation Table
Elf32_Rel <0x2100C, 0x116> ; R_ARM_JUMP_SLOT printf
Elf32_Rel <0x21010, 0x216> ; R_ARM_JUMP_SLOT __isoc99_fscanf
Elf32_Rel <0x21014, 0x316> ; R_ARM_JUMP_SLOT execvp
Elf32_Rel <0x21018, 0x416> ; R_ARM_JUMP_SLOT sleep
Elf32_Rel <0x2101C, 0x516> ; R_ARM_JUMP_SLOT wait
Elf32_Rel <0x21020, 0x616> ; R_ARM_JUMP_SLOT fwrite
Elf32_Rel <0x21024, 0x716> ; R_ARM_JUMP_SLOT usleep
Elf32_Rel <0x21028, 0x816> ; R_ARM_JUMP_SLOT gettimeofday
Elf32_Rel <0x2102C, 0x916> ; R_ARM_JUMP_SLOT puts
Elf32_Rel <0x21030, 0xA16> ; R_ARM_JUMP_SLOT __libc_start_main
Elf32_Rel <0x21034, 0xB16> ; R_ARM_JUMP_SLOT system
Elf32_Rel <0x21038, 0xC16> ; R_ARM_JUMP_SLOT __gmon_start__
Elf32_Rel <0x2103C, 0xD16> ; R_ARM_JUMP_SLOT exit
Elf32_Rel <0x21040, 0xE16> ; R_ARM_JUMP_SLOT strlen
Elf32_Rel <0x21044, 0xF16> ; R_ARM_JUMP_SLOT memset
Elf32_Rel <0x21048, 0x1016> ; R_ARM_JUMP_SLOT access
Elf32_Rel <0x2104C, 0x1116> ; R_ARM_JUMP_SLOT fclose
Elf32_Rel <0x21050, 0x1216> ; R_ARM_JUMP_SLOT fork
Elf32_Rel <0x21054, 0x1316> ; R_ARM_JUMP_SLOT sprintf
Elf32_Rel <0x21058, 0x1416> ; R_ARM_JUMP_SLOT fopen64
Elf32_Rel <0x2105C, 0x1516> ; R_ARM_JUMP_SLOT abort
; LOAD ends


; Segment type: Pure code
AREA .init, CODE
; ORG 0x10584
CODE32



; int init_proc()
EXPORT .init_proc
.init_proc
PUSH            {R3,LR}
BL              sub_108B0
POP             {R3,PC}
; End of function .init_proc

; .init ends


; Segment type: Pure code
AREA .plt, CODE
; ORG 0x10590
CODE32



; void sub_10590()
sub_10590
PUSH            {LR}
LDR             LR, =(_GLOBAL_OFFSET_TABLE_ - 0x105A0)
ADD             LR, PC, LR ; _GLOBAL_OFFSET_TABLE_
LDR             PC, [LR,#(off_21008 - 0x21000)]!
; End of function sub_10590

off_105A0 DCD _GLOBAL_OFFSET_TABLE_ - 0x105A0
; [0000000C BYTES: COLLAPSED FUNCTION printf]
; [0000000C BYTES: COLLAPSED FUNCTION __isoc99_fscanf]
; [0000000C BYTES: COLLAPSED FUNCTION execvp]
; [0000000C BYTES: COLLAPSED FUNCTION sleep]
; [0000000C BYTES: COLLAPSED FUNCTION wait]
; [0000000C BYTES: COLLAPSED FUNCTION fwrite]
; [0000000C BYTES: COLLAPSED FUNCTION usleep]
; [0000000C BYTES: COLLAPSED FUNCTION gettimeofday]
; [0000000C BYTES: COLLAPSED FUNCTION puts]
; [0000000C BYTES: COLLAPSED FUNCTION __libc_start_main]
; [0000000C BYTES: COLLAPSED FUNCTION system]
; [0000000C BYTES: COLLAPSED FUNCTION __gmon_start__]
; [0000000C BYTES: COLLAPSED FUNCTION exit]
; [0000000C BYTES: COLLAPSED FUNCTION strlen]
; [0000000C BYTES: COLLAPSED FUNCTION memset]
; [0000000C BYTES: COLLAPSED FUNCTION access]
; [0000000C BYTES: COLLAPSED FUNCTION fclose]
; [0000000C BYTES: COLLAPSED FUNCTION fork]
; [0000000C BYTES: COLLAPSED FUNCTION sprintf]
; [0000000C BYTES: COLLAPSED FUNCTION fopen64]
; [0000000C BYTES: COLLAPSED FUNCTION abort]

; Segment type: Pure code
AREA .text, CODE
; ORG 0x106A0
CODE32


; Attributes: noreturn

; int main(int, char **, char **)
main

var_14= -0x14
var_10= -0x10
tv= -0xC

PUSH            {R4-R11,LR}
MOVW            R2, #:lower16:a102222 ; "10:22:22"
MOV             R11, R0
MOV             R10, R1
MOVW            R0, #:lower16:aMonitorRecobtn ; "monitor-recobtn compile %s--%s\n"
MOVW            R1, #:lower16:aApr162025 ; "Apr 16 2025"
MOVW            R9, #:lower16:aDetectRecovery ; "Detect recovery button push off"
MOVW            R7, #0x4240
MOVW            R6, #0xC6C0
MOVW            R8, #0xA120
SUB             SP, SP, #0x14
MOVT            R2, #:upper16:a102222 ; "10:22:22"
MOVT            R1, #:upper16:aApr162025 ; "Apr 16 2025"
MOVT            R0, #:upper16:aMonitorRecobtn ; "monitor-recobtn compile %s--%s\n"
MOVT            R9, #:upper16:aDetectRecovery ; "Detect recovery button push off"
MOVT            R7, #0xF
MOVT            R6, #0x2D ; '-'
MOVT            R8, #7
BL              printf

loc_106EC
MOV             R0, #0
BL              sub_109C0
SUBS            R1, R0, #0 ; tz
BNE             loc_1082C

loc_106FC               ; tv
MOV             R0, SP
BL              gettimeofday
MOV             R0, #1
BL              sub_10940
MOV             R0, R9  ; s
BL              puts

loc_10714
MOV             R0, #0
BL              sub_109C0
CMP             R0, #1
BEQ             loc_10814

loc_10724               ; tz
MOV             R1, #0
ADD             R0, SP, #0x14+tv ; tv
BL              gettimeofday
LDR             R3, [SP,#0x14+tv]
LDR             R0, [SP,#0x14+var_14]
LDR             R1, [SP,#0x14+tv.tv_usec]
LDR             R2, [SP,#0x14+var_10]
SUB             R3, R3, R0
MLA             R3, R7, R3, R1
SUB             R3, R3, R2
CMP             R3, R6
BLE             loc_10838
MOV             R0, #aRecoveryButton ; "recovery button off over 3S, wait push "...
BL              puts
B               loc_10784

loc_10764
MOV             R0, #1
BL              sub_10940
MOV             R0, #1  ; seconds
BL              sleep
MOV             R0, R4
BL              sub_10940
MOV             R0, #1  ; seconds
BL              sleep

loc_10784
MOV             R0, #0
BL              sub_109C0
SUBS            R4, R0, #0
BEQ             loc_10764
MOV             R0, #aRecoveryButton_0 ; "recovery button on"
BL              puts
BL              fork
CMP             R0, #0
BLT             loc_10844
BEQ             loc_10854
MOV             R0, #0  ; stat_loc
MOVW            R5, #0x86A0
BL              wait
MOVW            R0, #:lower16:aChildComplete ; "child complete"
MOVT            R5, #1
MOVT            R0, #:upper16:aChildComplete ; "child complete"
MOV             R4, #0x64 ; 'd'
BL              puts

loc_107D0
MOV             R0, #1
BL              sub_10940
MOV             R0, R5  ; useconds
BL              usleep
MOV             R0, #0
BL              sub_10940
MOV             R0, R5  ; useconds
BL              usleep
SUBS            R4, R4, #1
BNE             loc_107D0
MOV             R0, #aRecoveryFactor ; "recovery factory complete"
BL              puts
MOV             R0, #0
BL              sub_109C0
CMP             R0, #1
BNE             loc_10724

loc_10814
MOV             R0, #0
BL              sub_10940
MOV             R0, #0
BL              sub_109C0
SUBS            R1, R0, #0
BEQ             loc_106FC

loc_1082C               ; seconds
MOV             R0, #1
BL              sleep
B               loc_106EC

loc_10838               ; useconds
MOV             R0, R8
BL              usleep
B               loc_10714

loc_10844
MOV             R0, #aErrorOccured ; "error occured."
BL              puts
B               loc_10714

loc_10854
BL              sub_10940
CMP             R11, #1
BLE             loc_10874
ADD             R1, R10, #4 ; argv
LDR             R0, [R10,#4] ; file
BL              execvp

loc_1086C               ; status
MOV             R0, #0
BL              exit

loc_10874               ; seconds
MOV             R0, #1
BL              sleep
B               loc_1086C
; End of function main

CODE16


; Attributes: noreturn

; void __noreturn start(void (*)(), int, int, int, ...)
EXPORT start
start

arg_0=  0

MOV.W           R11, #0
MOV.W           LR, #0
POP             {R1}    ; argc
MOV             R2, SP  ; ubp_av
PUSH            {R2}    ; stack_end
PUSH            {R0}    ; rtld_fini
LDR.W           R12, =(nullsub_1+1)
PUSH.W          {R12}   ; fini
LDR             R0, =main ; main
LDR             R3, =(init+1) ; init
BLX             __libc_start_main
BLX             abort
; End of function start

off_108A4 DCD nullsub_1+1
off_108A8 DCD main
off_108AC DCD init+1
CODE32



; int sub_108B0()
sub_108B0
LDR             R3, =(_GLOBAL_OFFSET_TABLE_ - 0x108C0)
LDR             R2, =(__gmon_start___ptr_0 - 0x21000)
ADD             R3, PC, R3 ; _GLOBAL_OFFSET_TABLE_
LDR             R2, [R3,R2] ; __imp___gmon_start__
CMP             R2, #0
BXEQ            LR
B               __gmon_start__
; End of function sub_108B0

off_108CC DCD _GLOBAL_OFFSET_TABLE_ - 0x108C0
off_108D0 DCD __gmon_start___ptr_0 - 0x21000
CODE16



; char *sub_108D4()
sub_108D4
MOVW            R0, #:lower16:byte_2106C
MOVW            R3, #:lower16:byte_2106C
MOVT            R0, #:upper16:byte_2106C
MOVT            R3, #:upper16:byte_2106C
CMP             R3, R0
BEQ             locret_108F4
MOV             R3, #0
CBZ             R3, locret_108F4
BX              R3

locret_108F4
BX              LR
; End of function sub_108D4

ALIGN 4



; __int64 sub_108F8()
sub_108F8
MOVW            R0, #:lower16:byte_2106C
MOVW            R1, #:lower16:byte_2106C
MOVT            R0, #:upper16:byte_2106C
MOVT            R1, #:upper16:byte_2106C
SUBS            R1, R1, R0
ASRS            R1, R1, #2
ADD.W           R1, R1, R1,LSR#31
ASRS            R1, R1, #1
BEQ             locret_10920
MOV             R3, #0
CBZ             R3, locret_10920
BX              R3

locret_10920
BX              LR
; End of function sub_108F8

ALIGN 4



; char *sub_10924()
sub_10924
PUSH            {R4,LR}
MOV             R4, #byte_2106C
LDRB            R3, [R4]
CBNZ            R3, locret_1093A
BL              sub_108D4
MOVS            R3, #1
STRB            R3, [R4]

locret_1093A
POP             {R4,PC}
; End of function sub_10924



; Attributes: thunk

sub_1093C
B               sub_108F8
; End of function sub_1093C

ALIGN 0x10
CODE32



; int __fastcall sub_10940(int)
sub_10940
PUSH            {R4,R5,LR}
MOVS            R5, R0
SUB             SP, SP, #0x44
MOVW            R4, #:lower16:aEchoDSysClassG ; "echo %d > /sys/class/gpio/gpio%d/value"
MOVNE           R5, #1
MOVT            R4, #:upper16:aEchoDSysClassG ; "echo %d > /sys/class/gpio/gpio%d/value"
MOV             R0, SP  ; s
MOV             R2, #0x40 ; '@' ; n
MOV             R1, #0  ; c
BL              memset
MOV             R2, R5
MOV             R1, R4  ; format
MOVW            R3, #0x3AD
MOV             R0, SP  ; s
BL              sprintf
MOV             R0, SP  ; command
BL              system
MOV             R2, R5
MOV             R1, R4  ; format
MOVW            R3, #0x3AE
MOV             R0, SP  ; s
BL              sprintf
MOV             R0, SP  ; command
BL              system
ADD             SP, SP, #0x44 ; 'D'
POP             {R4,R5,PC}
; End of function sub_10940




; bool __fastcall sub_109A8(const char *)
sub_109A8
PUSH            {R4,LR}
MOV             R1, #0  ; type
BL              access
CLZ             R0, R0
MOV             R0, R0,LSR#5
POP             {R4,PC}
; End of function sub_109A8




; int sub_109C0()
sub_109C0

var_44= -0x44
s= -0x40

PUSH            {R4,LR}
SUB             SP, SP, #0x48
MOV             R2, #0x40 ; '@' ; n
MOV             R1, #0  ; c
ADD             R0, SP, #0x48+s ; s
BL              memset
MOVW            R1, #:lower16:aSysClassGpioGp ; "/sys/class/gpio/gpio%d"
MOVW            R2, #0x399
MOVT            R1, #:upper16:aSysClassGpioGp ; "/sys/class/gpio/gpio%d"
ADD             R0, SP, #0x48+s ; s
BL              sprintf
ADD             R0, SP, #0x48+s ; name
MOV             R1, #0  ; type
BL              access
CMP             R0, #0
BEQ             loc_10A74
MOVW            R1, #:lower16:aW ; "w"
MOVW            R0, #:lower16:aSysClassGpioEx ; "/sys/class/gpio/export"
MOVT            R1, #:upper16:aW ; "w"
MOVT            R0, #:upper16:aSysClassGpioEx ; "/sys/class/gpio/export"
BL              fopen64
SUBS            R4, R0, #0
BEQ             loc_10ACC
MOVW            R1, #:lower16:(aSysClassGpioGp+0x14) ; "%d"
MOVW            R2, #0x399
MOVT            R1, #:upper16:(aSysClassGpioGp+0x14) ; format
ADD             R0, SP, #0x48+s ; s
BL              sprintf
ADD             R0, SP, #0x48+s ; s
BL              strlen
MOV             R3, R4  ; s
MOV             R1, R0  ; size
MOV             R2, #1  ; n
ADD             R0, SP, #0x48+s ; ptr
BL              fwrite
CMP             R0, #1
BEQ             loc_10A60
MOV             R0, #aFileWriteError ; "File Write Error!"
BL              puts

loc_10A60               ; stream
MOV             R0, R4
BL              fclose
MOV             R0, #0xFFFFFFFF
ADD             SP, SP, #0x48 ; 'H'
POP             {R4,PC}

loc_10A74
MOVW            R1, #:lower16:aSysClassGpioGp_0 ; "/sys/class/gpio/gpio%d/value"
MOVW            R2, #0x399
MOVT            R1, #:upper16:aSysClassGpioGp_0 ; "/sys/class/gpio/gpio%d/value"
ADD             R0, SP, #0x48+s ; s
BL              sprintf
MOVW            R1, #:lower16:aR ; "r"
ADD             R0, SP, #0x48+s
MOVT            R1, #:upper16:aR ; "r"
BL              fopen64
SUBS            R4, R0, #0
BEQ             loc_10AE4
MOVW            R1, #:lower16:(aSysClassGpioGp+0x14) ; "%d"
ADD             R2, SP, #0x48+var_44
MOVT            R1, #:upper16:(aSysClassGpioGp+0x14) ; "%d"
BL              __isoc99_fscanf
MOV             R0, R4  ; stream
BL              fclose
LDR             R0, [SP,#0x48+var_44]
MOVS            R0, R0
MOVNE           R0, #1

loc_10AC4
ADD             SP, SP, #0x48 ; 'H'
POP             {R4,PC}

loc_10ACC
MOV             R0, #aOpenReadGpioEx ; "Open read gpio/export"
BL              puts
MOV             R0, #0xFFFFFFFF
ADD             SP, SP, #0x48 ; 'H'
POP             {R4,PC}

loc_10AE4
MOV             R0, #aOpenReadRecove ; "Open read recovery button failure"
BL              puts
MOV             R0, #0xFFFFFFFF
B               loc_10AC4
; End of function sub_109C0

CODE16



; int __fastcall init(int, int, int)
init
PUSH.W          {R3-R9,LR}
MOV             R7, R0
LDR             R6, =(off_20F14 - 0x10B0A)
MOV             R8, R1
MOV             R9, R2
LDR             R5, =(off_20F10 - 0x10B10)
ADD             R6, PC  ; off_20F14
BLX             .init_proc
ADD             R5, PC  ; off_20F10
SUBS            R6, R6, R5
ASRS            R6, R6, #2
BEQ             locret_10B28
MOVS            R4, #0

loc_10B16
ADDS            R4, #1
LDR.W           R3, [R5],#4
MOV             R2, R9
MOV             R1, R8
MOV             R0, R7
BLX             R3
CMP             R6, R4
BNE             loc_10B16

locret_10B28
POP.W           {R3-R9,PC}
; End of function init

off_10B2C DCD off_20F14 - 0x10B0A
off_10B30 DCD off_20F10 - 0x10B10
; [00000002 BYTES: COLLAPSED FUNCTION nullsub_1]
ALIGN 4
; .text ends


; Segment type: Pure code
AREA .fini, CODE
; ORG 0x10B38
CODE32



; void term_proc()
EXPORT .term_proc
.term_proc
PUSH            {R3,LR}
POP             {R3,PC}
; End of function .term_proc

; .fini ends


; Segment type: Pure data
AREA .rodata, DATA, READONLY
; ORG 0x10B40
DCB    1
DCB    0
DCB    2
DCB    0
aEchoDSysClassG DCB "echo %d > /sys/class/gpio/gpio%d/v"
DCB "alue",0
ALIGN 4
aSysClassGpioGp DCB "/sys/class/gpio/gpio%d",0
ALIGN 4
aW DCB "w",0
ALIGN 4
aSysClassGpioEx DCB "/sys/class/gpio/export",0
ALIGN 0x10
aOpenReadGpioEx DCB "Open read gpio/export",0
ALIGN 4
aFileWriteError DCB "File Write Error!",0
ALIGN 4
aSysClassGpioGp_0 DCB "/sys/class/gpio/gpio%d/value",0
ALIGN 4
aR DCB "r",0
ALIGN 0x10
aOpenReadRecove DCB "Open read recovery button failure",0
ALIGN 4
a102222 DCB "10:22:22",0
ALIGN 0x10
aApr162025 DCB "Apr 16 2025",0
aMonitorRecobtn DCB "monitor-recobtn compile %s--%s",0xA
DCB 0
aDetectRecovery DCB "Detect recovery button push off",0
aRecoveryButton DCB "recovery button off over 3S, wait "
DCB "push on",0
ALIGN 4
aRecoveryButton_0 DCB "recovery button on",0
ALIGN 4
aErrorOccured DCB "error occured.",0
ALIGN 4
aChildComplete DCB "child complete",0
ALIGN 4
aRecoveryFactor DCB "recovery factory complete",0
ALIGN 4
; .rodata ends


; Segment type: Pure data
AREA .ARM.exidx, DATA, READONLY
; ORG 0x10CE8
unk_10CE8 DCB 0x98
DCB 0xFB
DCB 0xFF
DCB 0x7F ; 
DCB    1
DCB    0
DCB    0
DCB    0
; .ARM.exidx ends


; Segment type: Pure data
AREA .eh_frame, DATA, READONLY
; ORG 0x10CF0
DCB    0
DCB    0
DCB    0
DCB    0
; .eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
AREA .init_array, DATA
; ORG 0x20F10
off_20F10 DCD sub_1093C+1
; .init_array ends

; ELF Termination Function Table

; Segment type: Pure data
AREA .fini_array, DATA
; ORG 0x20F14
off_20F14 DCD sub_10924+1
; .fini_array ends

; ELF Dynamic Information

; Segment type: Pure data
AREA LOAD, DATA, ALIGN=0
; ORG 0x20F18
stru_20F18 Elf32_Dyn <1, <1>> ; DT_NEEDED libc.so.6
Elf32_Dyn <0xC, <0x10584>> ; DT_INIT
Elf32_Dyn <0xD, <0x10B38>> ; DT_FINI
Elf32_Dyn <0x19, <0x20F10>> ; DT_INIT_ARRAY
Elf32_Dyn <0x1B, <4>>   ; DT_INIT_ARRAYSZ
Elf32_Dyn <0x1A, <0x20F14>> ; DT_FINI_ARRAY
Elf32_Dyn <0x1C, <4>>   ; DT_FINI_ARRAYSZ
Elf32_Dyn <4, <0x101B4>> ; DT_HASH
Elf32_Dyn <5, <0x103B8>> ; DT_STRTAB
Elf32_Dyn <6, <0x10258>> ; DT_SYMTAB
Elf32_Dyn <0xA, <0xBF>> ; DT_STRSZ
Elf32_Dyn <0xB, <0x10>> ; DT_SYMENT
Elf32_Dyn <0x15, <0>>   ; DT_DEBUG
Elf32_Dyn <3, <0x21000>> ; DT_PLTGOT
Elf32_Dyn <2, <0xA8>>   ; DT_PLTRELSZ
Elf32_Dyn <0x14, <0x11>> ; DT_PLTREL
Elf32_Dyn <0x17, <0x104DC>> ; DT_JMPREL
Elf32_Dyn <0x11, <0x104D4>> ; DT_REL
Elf32_Dyn <0x12, <8>>   ; DT_RELSZ
Elf32_Dyn <0x13, <8>>   ; DT_RELENT
Elf32_Dyn <0x6FFFFFFE, <0x104A4>> ; DT_VERNEED
Elf32_Dyn <0x6FFFFFFF, <1>> ; DT_VERNEEDNUM
Elf32_Dyn <0x6FFFFFF0, <0x10478>> ; DT_VERSYM
Elf32_Dyn <0>           ; DT_NULL
ALIGN 0x40
; LOAD ends


; Segment type: Pure data
AREA .got, DATA
; ORG 0x21000
_GLOBAL_OFFSET_TABLE_ DCD stru_20F18
DCD 0
off_21008 DCD 0
printf_ptr DCD __imp_printf
__isoc99_fscanf_ptr DCD __imp___isoc99_fscanf
execvp_ptr DCD __imp_execvp
sleep_ptr DCD __imp_sleep
wait_ptr DCD __imp_wait
fwrite_ptr DCD __imp_fwrite
usleep_ptr DCD __imp_usleep
gettimeofday_ptr DCD __imp_gettimeofday
puts_ptr DCD __imp_puts
__libc_start_main_ptr DCD __imp___libc_start_main
system_ptr DCD __imp_system
__gmon_start___ptr DCD __imp___gmon_start__
exit_ptr DCD __imp_exit
strlen_ptr DCD __imp_strlen
memset_ptr DCD __imp_memset
access_ptr DCD __imp_access
fclose_ptr DCD __imp_fclose
fork_ptr DCD __imp_fork
sprintf_ptr DCD __imp_sprintf
fopen64_ptr DCD __imp_fopen64
abort_ptr DCD __imp_abort
__gmon_start___ptr_0 DCD __imp___gmon_start__
; .got ends


; Segment type: Pure data
AREA .data, DATA
; ORG 0x21064
ALIGN 8
DCB    0
DCB    0
DCB    0
DCB    0
; .data ends


; Segment type: Uninitialized
AREA .bss, DATA, ALIGN=0
; ORG 0x2106C
byte_2106C % 1
ALIGN 0x10
; .bss ends


; Segment type: Externs
; int printf(const char *format, ...)
IMPORT __imp_printf
IMPORT __imp___isoc99_fscanf
; int execvp(const char *file, char *const argv[])
IMPORT __imp_execvp
; unsigned int sleep(unsigned int seconds)
IMPORT __imp_sleep
; __pid_t wait(void *stat_loc)
IMPORT __imp_wait
; size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)
IMPORT __imp_fwrite
; int usleep(__useconds_t useconds)
IMPORT __imp_usleep
; int gettimeofday(struct timeval *tv, __timezone_ptr_t tz)
IMPORT __imp_gettimeofday
; int puts(const char *s)
IMPORT __imp_puts
; int __libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end)
IMPORT __imp___libc_start_main
; int system(const char *command)
IMPORT __imp_system
; void exit(int status)
IMPORT __imp_exit
; size_t strlen(const char *s)
IMPORT __imp_strlen
; void *memset(void *s, int c, size_t n)
IMPORT __imp_memset
; int access(const char *name, int type)
IMPORT __imp_access
; int fclose(FILE *stream)
IMPORT __imp_fclose
; __pid_t fork(void)
IMPORT __imp_fork
; int sprintf(char *s, const char *format, ...)
IMPORT __imp_sprintf
IMPORT __imp_fopen64
; void abort(void)
IMPORT __imp_abort
IMPORT __imp___gmon_start__, WEAK

END start
