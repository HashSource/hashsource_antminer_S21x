// Data types exported from: single_board_test_0be428078300f787_debug
// Generated by Ghidra

#ifndef SINGLE_BOARD_TEST_0BE428078300F787_DEBUG_TYPES_H
#define SINGLE_BOARD_TEST_0BE428078300F787_DEBUG_TYPES_H

#include <stdint.h>
#include <stdbool.h>

/* ==================== Enumerations ==================== */

typedef enum {
    DT_NULL = 0,
    DT_NEEDED = 1,
    DT_PLTRELSZ = 2,
    DT_PLTGOT = 3,
    DT_HASH = 4,
    DT_STRTAB = 5,
    DT_SYMTAB = 6,
    DT_RELA = 7,
    DT_RELASZ = 8,
    DT_RELAENT = 9,
    DT_STRSZ = 10,
    DT_SYMENT = 11,
    DT_INIT = 12,
    DT_FINI = 13,
    DT_SONAME = 14,
    DT_RPATH = 15,
    DT_SYMBOLIC = 16,
    DT_REL = 17,
    DT_RELSZ = 18,
    DT_RELENT = 19,
    DT_PLTREL = 20,
    DT_DEBUG = 21,
    DT_TEXTREL = 22,
    DT_JMPREL = 23,
    DT_BIND_NOW = 24,
    DT_INIT_ARRAY = 25,
    DT_FINI_ARRAY = 26,
    DT_INIT_ARRAYSZ = 27,
    DT_FINI_ARRAYSZ = 28,
    DT_RUNPATH = 29,
    DT_FLAGS = 30,
    DT_PREINIT_ARRAY = 32,
    DT_PREINIT_ARRAYSZ = 33,
    DT_RELRSZ = 35,
    DT_RELR = 36,
    DT_RELRENT = 37,
    DT_ANDROID_REL = 1610612751,
    DT_ANDROID_RELSZ = 1610612752,
    DT_ANDROID_RELA = 1610612753,
    DT_ANDROID_RELASZ = 1610612754,
    DT_ANDROID_RELR = 1879040000,
    DT_ANDROID_RELRSZ = 1879040001,
    DT_ANDROID_RELRENT = 1879040003,
    DT_GNU_PRELINKED = 1879047669,
    DT_GNU_CONFLICTSZ = 1879047670,
    DT_GNU_LIBLISTSZ = 1879047671,
    DT_CHECKSUM = 1879047672,
    DT_PLTPADSZ = 1879047673,
    DT_MOVEENT = 1879047674,
    DT_MOVESZ = 1879047675,
    DT_FEATURE_1 = 1879047676,
    DT_POSFLAG_1 = 1879047677,
    DT_SYMINSZ = 1879047678,
    DT_SYMINENT = 1879047679,
    DT_GNU_XHASH = 1879047924,
    DT_GNU_HASH = 1879047925,
    DT_TLSDESC_PLT = 1879047926,
    DT_TLSDESC_GOT = 1879047927,
    DT_GNU_CONFLICT = 1879047928,
    DT_GNU_LIBLIST = 1879047929,
    DT_CONFIG = 1879047930,
    DT_DEPAUDIT = 1879047931,
    DT_AUDIT = 1879047932,
    DT_PLTPAD = 1879047933,
    DT_MOVETAB = 1879047934,
    DT_SYMINFO = 1879047935,
    DT_VERSYM = 1879048176,
    DT_RELACOUNT = 1879048185,
    DT_RELCOUNT = 1879048186,
    DT_FLAGS_1 = 1879048187,
    DT_VERDEF = 1879048188,
    DT_VERDEFNUM = 1879048189,
    DT_VERNEED = 1879048190,
    DT_VERNEEDNUM = 1879048191,
    DT_AUXILIARY = 2147483645,
    DT_FILTER = 2147483647,
} Elf32_DynTag_ARM;

typedef enum {
    PT_NULL = 0,
    PT_LOAD = 1,
    PT_DYNAMIC = 2,
    PT_INTERP = 3,
    PT_NOTE = 4,
    PT_SHLIB = 5,
    PT_PHDR = 6,
    PT_TLS = 7,
    PT_GNU_EH_FRAME = 1685382480,
    PT_GNU_STACK = 1685382481,
    PT_GNU_RELRO = 1685382482,
    PT_ARM_EXIDX = 1879048192,
} Elf_ProgramHeaderType_ARM;

typedef enum {
    SHT_NULL = 0,
    SHT_PROGBITS = 1,
    SHT_SYMTAB = 2,
    SHT_STRTAB = 3,
    SHT_RELA = 4,
    SHT_HASH = 5,
    SHT_DYNAMIC = 6,
    SHT_NOTE = 7,
    SHT_NOBITS = 8,
    SHT_REL = 9,
    SHT_SHLIB = 10,
    SHT_DYNSYM = 11,
    SHT_INIT_ARRAY = 14,
    SHT_FINI_ARRAY = 15,
    SHT_PREINIT_ARRAY = 16,
    SHT_GROUP = 17,
    SHT_SYMTAB_SHNDX = 18,
    SHT_ANDROID_REL = 1610612737,
    SHT_ANDROID_RELA = 1610612738,
    SHT_GNU_ATTRIBUTES = 1879048181,
    SHT_GNU_HASH = 1879048182,
    SHT_GNU_LIBLIST = 1879048183,
    SHT_CHECKSUM = 1879048184,
    SHT_SUNW_move = 1879048186,
    SHT_SUNW_COMDAT = 1879048187,
    SHT_SUNW_syminfo = 1879048188,
    SHT_GNU_verdef = 1879048189,
    SHT_GNU_verneed = 1879048190,
    SHT_GNU_versym = 1879048191,
    SHT_ARM_EXIDX = 1879048193,
    SHT_ARM_PREEMPTMAP = 1879048194,
    SHT_ARM_ATTRIBUTES = 1879048195,
    SHT_ARM_DEBUGOVERLAY = 1879048196,
    SHT_ARM_OVERLAYSECTION = 1879048197,
} Elf_SectionHeaderType_ARM;

typedef enum {
    favorCompressionRatio = 0,
    favorDecompressionSpeed = 1,
} HCfavor_e;

typedef enum {
    LZ4F_noBlockChecksum = 0,
    LZ4F_blockChecksumEnabled = 1,
} LZ4F_blockChecksum_t;

typedef enum {
    LZ4B_COMPRESSED = 0,
    LZ4B_UNCOMPRESSED = 1,
} LZ4F_blockCompression_t;

typedef enum {
    LZ4F_blockLinked = 0,
    LZ4F_blockIndependent = 1,
} LZ4F_blockMode_t;

typedef enum {
    LZ4F_default = 0,
    LZ4F_max64KB = 4,
    LZ4F_max256KB = 5,
    LZ4F_max1MB = 6,
    LZ4F_max4MB = 7,
} LZ4F_blockSizeID_t;

typedef enum {
    LZ4F_noContentChecksum = 0,
    LZ4F_contentChecksumEnabled = 1,
} LZ4F_contentChecksum_t;

typedef enum {
    LZ4F_OK_NoError = 0,
    LZ4F_ERROR_GENERIC = 1,
    LZ4F_ERROR_maxBlockSize_invalid = 2,
    LZ4F_ERROR_blockMode_invalid = 3,
    LZ4F_ERROR_contentChecksumFlag_invalid = 4,
    LZ4F_ERROR_compressionLevel_invalid = 5,
    LZ4F_ERROR_headerVersion_wrong = 6,
    LZ4F_ERROR_blockChecksum_invalid = 7,
    LZ4F_ERROR_reservedFlag_set = 8,
    LZ4F_ERROR_allocation_failed = 9,
    LZ4F_ERROR_srcSize_tooLarge = 10,
    LZ4F_ERROR_dstMaxSize_tooSmall = 11,
    LZ4F_ERROR_frameHeader_incomplete = 12,
    LZ4F_ERROR_frameType_unknown = 13,
    LZ4F_ERROR_frameSize_wrong = 14,
    LZ4F_ERROR_srcPtr_wrong = 15,
    LZ4F_ERROR_decompressionFailed = 16,
    LZ4F_ERROR_headerChecksum_invalid = 17,
    LZ4F_ERROR_contentChecksum_invalid = 18,
    LZ4F_ERROR_frameDecoding_alreadyStarted = 19,
    LZ4F_ERROR_compressionState_uninitialized = 20,
    LZ4F_ERROR_parameter_null = 21,
    LZ4F_ERROR_maxCode = 22,
    _LZ4F_dummy_error_enum_for_c89_never_used = 23,
} LZ4F_errorCodes;

typedef enum {
    LZ4F_frame = 0,
    LZ4F_skippableFrame = 1,
} LZ4F_frameType_t;

typedef enum {
    notDone = 0,
    fromTmpBuffer = 1,
    fromSrcBuffer = 2,
} LZ4F_lastBlockStatus;

typedef enum {
    SWEEP_NO_ERR = 0,
    SWEEP_PT2_FAIL = 1,
    SWEEP_READ_EEPROM_FAIL = 2,
    SWEEP_MAX_CHAIN = 3,
    SWEEP_HAL_INIT_FAIL = 4,
    SWEEP_FAN_INIT_FAIL = 5,
    SWEEP_SENSOR_READ_FAIL = 6,
    SWEEP_OPEN_PATTERN_FILE_FAIL = 7,
    SWEEP_MEMORY_FULL = 8,
    SWEEP_PATTERN_WORK_NOT_ENOUGH = 9,
    SWEEP_ERR_POWER_NOT_CALIBRATE = 10,
    SWEEP_ERR_POWER_ON_ERR = 11,
    SWEEP_ERR_FIRST_FIND_ASIC = 12,
    SWEEP_ERR_SECOND_FIND_ASIC = 13,
    SWEEP_ERR_LEVEL_MATCH = 14,
    SWEEP_ERR_HEATING = 15,
    SWEEP_BASE_FREQ_ERR = 16,
    SWEEP_CAN_NOT_DROP = 17,
} SWEEP_ERROR_CODE;

typedef enum {
    HW_MODE = 0,
    SW_MODE = 1,
    PM_MODE = 2,
} SWEEP_MODE;

typedef enum {
    UIT_NONE = 0,
    UIT_PROMPT = 1,
    UIT_VERIFY = 2,
    UIT_BOOLEAN = 3,
    UIT_INFO = 4,
    UIT_ERROR = 5,
} UI_string_types;

typedef enum {
    XXH_aligned = 0,
    XXH_unaligned = 1,
} XXH_alignment;

typedef enum {
    XXH_bigEndian = 0,
    XXH_littleEndian = 1,
} XXH_endianess;

typedef enum {
    XXH_OK = 0,
    XXH_ERROR = 1,
} XXH_errorcode;

typedef enum {
    ns_s_qd = 0,
    ns_s_zn = 0,
    ns_s_an = 1,
    ns_s_pr = 1,
    ns_s_ns = 2,
    ns_s_ud = 2,
    ns_s_ar = 3,
    ns_s_max = 4,
} __ns_sect;

typedef enum {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_NONBLOCK = 2048,
    SOCK_CLOEXEC = 524288,
} __socket_type;

typedef enum {
    ERR_NOT_SUPPORTED = -5,
    ERR_API_LOCK_FAILED = -4,
    ERR_BAD_PARAM = -3,
    ERR_NOT_INITIALIZED = -2,
    ERR_COMMON = -1,
    BIT3000000 = 0,
    BITMAIN_LOG_ERR = 0,
    DIRECTION_IN = 0,
    ERR_NO = 0,
    FRONT_SIDE = 0,
    HARDWARE_VERSION = 0,
    HW_MODE = 0,
    IPPROTO_IP = 0,
    LZ4F_OK_NoError = 0,
    PTHREAD_CANCEL_ENABLE = 0,
    PWM_CTRL_FAN = 0,
    hashboard_cache_level = 0,
    BIT1500000 = 1,
    BITMAIN_LOG_WARNING = 1,
    DIRECTION_OUT = 1,
    FAN_SPEED = 1,
    IPPROTO_ICMP = 1,
    LZ4F_ERROR_GENERIC = 1,
    PTHREAD_CANCEL_DISABLE = 1,
    PWM_CTRL_POWER = 1,
    REAR_SIDE = 1,
    SW_MODE = 1,
    asic_cache_level = 1,
    BIT921600 = 2,
    BITMAIN_LOG_NOTICE = 2,
    BOTH_SIZE = 2,
    HASH_ON_PLUG = 2,
    IPPROTO_IGMP = 2,
    LZ4F_ERROR_maxBlockSize_invalid = 2,
    PM_MODE = 2,
    PWM_CTRL_MAX = 2,
    core_cache_level = 2,
    BIT600000 = 3,
    BITMAIN_LOG_INFO = 3,
    LZ4F_ERROR_blockMode_invalid = 3,
    WORK_FIFO_STATE = 3,
    BIT1200000 = 4,
    BITMAIN_LOG_DEBUG = 4,
    EDF_VERSION_4 = 4,
    IPPROTO_IPIP = 4,
    LZ4F_ERROR_contentChecksumFlag_invalid = 4,
    RETURN_NONCE = 4,
    BIT2500000 = 5,
    EDF_VERSION_5 = 5,
    LZ4F_ERROR_compressionLevel_invalid = 5,
    RETURN_NONCE_HI = 5,
    BIT460800 = 6,
    IPPROTO_TCP = 6,
    LZ4F_ERROR_headerVersion_wrong = 6,
    NONCE_NUMBER_IN_FIFO = 6,
    BIT230400 = 7,
    LZ4F_ERROR_blockChecksum_invalid = 7,
    NONCE_FIFO_INTERRUPT = 7,
    BIT57600 = 8,
    IPPROTO_EGP = 8,
    LZ4F_ERROR_reservedFlag_set = 8,
    TEMPERATURE_0_3 = 8,
    BIT38400 = 9,
    LZ4F_ERROR_allocation_failed = 9,
    TEMPERATURE_4_7 = 9,
    BIT19200 = 10,
    LZ4F_ERROR_srcSize_tooLarge = 10,
    TEMPERATURE_8_11 = 10,
    BIT9600 = 11,
    LZ4F_ERROR_dstMaxSize_tooSmall = 11,
    TEMPERATURE_12_15 = 11,
    IIC_COMMAND = 12,
    IPPROTO_PUP = 12,
    LZ4F_ERROR_frameHeader_incomplete = 12,
    LZ4F_ERROR_frameType_unknown = 13,
    RESET_HASH_BOARD = 13,
    BMC_COUNTER = 14,
    LZ4F_ERROR_frameSize_wrong = 14,
    FPGA_BT8D = 15,
    LZ4F_ERROR_srcPtr_wrong = 15,
    LZ4F_ERROR_decompressionFailed = 16,
    TW_WRITE_COMMAND = 16,
    IPPROTO_UDP = 17,
    LZ4F_ERROR_headerChecksum_invalid = 17,
    QN_WRITE_DATA_COMMAND = 17,
    LZ4F_ERROR_contentChecksum_invalid = 18,
    RESET_CHAIN = 18,
    FAN_CONTROL = 19,
    LZ4F_ERROR_frameDecoding_alreadyStarted = 19,
    LZ4F_ERROR_compressionState_uninitialized = 20,
    TIME_OUT_CONTROL = 20,
    LZ4F_ERROR_parameter_null = 21,
    TICKET_MASK_FPGA = 21,
    HASH_COUNTING_NUMBER_FPGA = 22,
    IPPROTO_IDP = 22,
    LZ4F_ERROR_maxCode = 22,
    FAN_CONTROL_1 = 23,
    _LZ4F_dummy_error_enum_for_c89_never_used = 23,
    SNO = 24,
    SOCKET_ID = 25,
    BC_WRITE_COMMAND = 26,
    BIT115200 = 26,
    BITDEFAULT = 26,
    FRIST_WORD = 27,
    BC_COMMAND_BUFFER = 28,
    BC_COMMAND_BUFFER_1 = 29,
    IPPROTO_TP = 29,
    BC_COMMAND_BUFFER_2 = 30,
    FPGA_CHIP_ID_ADDR = 31,
    FPGA_CHIP_ID_HI = 32,
    CRC_ERROR_CNT = 33,
    IPPROTO_DCCP = 33,
    I2C_SW_ID = 34,
    DHASH_ACC_CONTROL = 35,
    COINBASE_AND_NONCE2_LENGTH = 36,
    WORK_NONCE_2 = 37,
    WORK_NONCE_2_HI = 38,
    NONCE2_AND_JOBID_STORE_ADDRESS = 39,
    MERKLE_BIN_NUMBER = 40,
    IPPROTO_IPV6 = 41,
    JOB_START_ADDRESS = 41,
    JOB_LENGTH = 42,
    JOB_DATA_READY = 43,
    JOB_ID = 44,
    WORK_ENABLE = 45,
    BLOCK_HEADER_VERSION = 46,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    TIME_STAMP = 47,
    TARGET_BITS = 48,
    PRE_HEADER_HASH = 49,
    IPPROTO_ESP = 50,
    PRE_HEADER_HASH1 = 50,
    IPPROTO_AH = 51,
    PRE_HEADER_HASH2 = 51,
    PRE_HEADER_HASH3 = 52,
    PRE_HEADER_HASH4 = 53,
    PRE_HEADER_HASH5 = 54,
    PRE_HEADER_HASH6 = 55,
    PRE_HEADER_HASH7 = 56,
    BLOCK_VERSION_0 = 57,
    BLOCK_VERSION_1 = 58,
    BLOCK_VERSION_2 = 59,
    BLOCK_VERSION_3 = 60,
    BLOCK_VERSION_4 = 61,
    BLOCK_VERSION_5 = 62,
    BLOCK_VERSION_6 = 63,
    BLOCK_VERSION_7 = 64,
    CHAIN0_3_SEND_FIFO_STATUS = 65,
    CHAIN4_7_SEND_FIFO_STATUS = 66,
    CHAIN8_11_SEND_FIFO_STATUS = 67,
    CHAIN12_13_SEND_FIFO_STATUS = 68,
    CHAIN0_SEND_READY = 69,
    CHAIN0_SEND_BUFFER = 70,
    CHAIN1_SEND_READY = 71,
    CHAIN1_SEND_BUFFER = 72,
    CHAIN2_SEND_READY = 73,
    CHAIN2_SEND_BUFFER = 74,
    CHAIN3_SEND_READY = 75,
    CHAIN3_SEND_BUFFER = 76,
    CHAIN4_SEND_READY = 77,
    CHAIN4_SEND_BUFFER = 78,
    CHAIN5_SEND_READY = 79,
    CHAIN5_SEND_BUFFER = 80,
    CHAIN6_SEND_READY = 81,
    CHAIN6_SEND_BUFFER = 82,
    CHAIN7_SEND_READY = 83,
    CHAIN7_SEND_BUFFER = 84,
    CHAIN8_SEND_READY = 85,
    CHAIN8_SEND_BUFFER = 86,
    CHAIN9_SEND_READY = 87,
    CHAIN9_SEND_BUFFER = 88,
    RECEIVE_FIFO_0_1_STATUS = 89,
    RECEIVE_FIFO_2_3_STATUS = 90,
    RECEIVE_FIFO_4_5_STATUS = 91,
    IPPROTO_MTP = 92,
    RECEIVE_FIFO_6_7_STATUS = 92,
    RECEIVE_FIFO_8_9_STATUS = 93,
    IPPROTO_BEETPH = 94,
    RECEIVE_FIFO_10_11_STATUS = 94,
    RECEIVE_FIFO_12_13_STATUS = 95,
    CHAIN0_READ_ENABLE = 96,
    CHAIN0_READ_DATA = 97,
    CHAIN1_READ_ENABLE = 98,
    IPPROTO_ENCAP = 98,
    CHAIN1_READ_DATA = 99,
    CHAIN2_READ_ENABLE = 100,
    CHAIN2_READ_DATA = 101,
    CHAIN3_READ_ENABLE = 102,
    CHAIN3_READ_DATA = 103,
    IPPROTO_PIM = 103,
    CHAIN4_READ_ENABLE = 104,
    CHAIN4_READ_DATA = 105,
    CHAIN5_READ_ENABLE = 106,
    CHAIN5_READ_DATA = 107,
    CHAIN6_READ_ENABLE = 108,
    IPPROTO_COMP = 108,
    CHAIN6_READ_DATA = 109,
    CHAIN7_READ_ENABLE = 110,
    CHAIN7_READ_DATA = 111,
    CHAIN8_READ_ENABLE = 112,
    CHAIN8_READ_DATA = 113,
    CHAIN9_READ_ENABLE = 114,
    CHAIN9_READ_DATA = 115,
    CHAIN10_SEND_READY = 116,
    CHAIN10_SEND_BUFFER = 117,
    CHAIN11_SEND_READY = 118,
    CHAIN11_SEND_BUFFER = 119,
    CHAIN12_SEND_READY = 120,
    CHAIN12_SEND_BUFFER = 121,
    CHAIN13_SEND_READY = 122,
    CHAIN13_SEND_BUFFER = 123,
    CHAIN10_READ_ENABLE = 124,
    CHAIN10_READ_DATA = 125,
    CHAIN11_READ_ENABLE = 126,
    CHAIN11_READ_DATA = 127,
    CHAIN12_READ_ENABLE = 128,
    CHAIN12_READ_DATA = 129,
    CHAIN13_READ_ENABLE = 130,
    CHAIN13_READ_DATA = 131,
    IPPROTO_SCTP = 132,
    SEED_ADDRESS_0 = 132,
    SEED_ADDRESS_1 = 133,
    SEED_ADDRESS_2 = 134,
    SEED_ADDRESS_3 = 135,
    IPPROTO_UDPLITE = 136,
    SEED_ADDRESS_4 = 136,
    SEED_ADDRESS_5 = 137,
    SEED_ADDRESS_6 = 138,
    SEED_ADDRESS_7 = 139,
    FULL_NODES_ADDR = 140,
    NUM_MODE_ADDR = 141,
    CACHE_SAVE_ADDR = 142,
    CACHE_START_ADDR = 143,
    DS_START_ADDR = 144,
    DS_DONE_ADDR = 145,
    DATA_SAVE_ADDR = 146,
    UART0_STATUS_ADDR = 147,
    UART1_STATUS_ADDR = 148,
    UART2_STATUS_ADDR = 149,
    UART3_STATUS_ADDR = 150,
    UART4_STATUS_ADDR = 151,
    UART5_STATUS_ADDR = 152,
    UART6_STATUS_ADDR = 153,
    UART7_STATUS_ADDR = 154,
    UART8_STATUS_ADDR = 155,
    UART9_STATUS_ADDR = 156,
    UART10_STATUS_ADDR = 157,
    UART11_STATUS_ADDR = 158,
    UART12_STATUS_ADDR = 159,
    UART13_STATUS_ADDR = 160,
    UART14_STATUS_ADDR = 161,
    UART15_STATUS_ADDR = 162,
    UART16_STATUS_ADDR = 163,
    UART17_STATUS_ADDR = 164,
    UART18_STATUS_ADDR = 165,
    UART19_STATUS_ADDR = 166,
    UART20_STATUS_ADDR = 167,
    UART21_STATUS_ADDR = 168,
    UART22_STATUS_ADDR = 169,
    UART23_STATUS_ADDR = 170,
    UART24_STATUS_ADDR = 171,
    UART25_STATUS_ADDR = 172,
    UART26_STATUS_ADDR = 173,
    UART27_STATUS_ADDR = 174,
    UART28_STATUS_ADDR = 175,
    UART29_STATUS_ADDR = 176,
    UART30_STATUS_ADDR = 177,
    UART31_STATUS_ADDR = 178,
    UART_WORK_FLAG_ADDR = 179,
    DATA_SIZE_ADDR = 180,
    DATA_STORE_ADDR = 181,
    UART_CTRL_STATE_ADDR = 182,
    UART_DBG_WR_ADDR = 183,
    UART_DBG_RD_ADDR = 184,
    UART_DBG_STATUS_ADDR = 185,
    BIT_DIV_ADDR = 186,
    MAX_FPGA_INDEX = 187,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
} anon_enum_32;

typedef enum {
    EEPROM_NO_ERROR = 0,
    EEPROM_ERROR_COMMON = 2147483904,
    EEPROM_BAD_PARAM = 2147483905,
} bitmain_eeprom_error_code;

typedef enum {
    FAN1 = 0,
    FAN2 = 1,
    FAN3 = 2,
    FAN4 = 3,
    FAN5 = 4,
    FAN6 = 5,
    FAN_MAX = 6,
} bitmain_fan_id_e;

typedef enum {
    FRONT_SIDE = 0,
    REAR_SIDE = 1,
    BOTH_SIZE = 2,
} bitmain_fan_side_e;

typedef enum {
    HARDWARE_VERSION = 0,
    FAN_SPEED = 1,
    HASH_ON_PLUG = 2,
    WORK_FIFO_STATE = 3,
    RETURN_NONCE = 4,
    RETURN_NONCE_HI = 5,
    NONCE_NUMBER_IN_FIFO = 6,
    NONCE_FIFO_INTERRUPT = 7,
    TEMPERATURE_0_3 = 8,
    TEMPERATURE_4_7 = 9,
    TEMPERATURE_8_11 = 10,
    TEMPERATURE_12_15 = 11,
    IIC_COMMAND = 12,
    RESET_HASH_BOARD = 13,
    BMC_COUNTER = 14,
    FPGA_BT8D = 15,
    TW_WRITE_COMMAND = 16,
    QN_WRITE_DATA_COMMAND = 17,
    RESET_CHAIN = 18,
    FAN_CONTROL = 19,
    TIME_OUT_CONTROL = 20,
    TICKET_MASK_FPGA = 21,
    HASH_COUNTING_NUMBER_FPGA = 22,
    FAN_CONTROL_1 = 23,
    SNO = 24,
    SOCKET_ID = 25,
    BC_WRITE_COMMAND = 26,
    FRIST_WORD = 27,
    BC_COMMAND_BUFFER = 28,
    BC_COMMAND_BUFFER_1 = 29,
    BC_COMMAND_BUFFER_2 = 30,
    FPGA_CHIP_ID_ADDR = 31,
    FPGA_CHIP_ID_HI = 32,
    CRC_ERROR_CNT = 33,
    I2C_SW_ID = 34,
    DHASH_ACC_CONTROL = 35,
    COINBASE_AND_NONCE2_LENGTH = 36,
    WORK_NONCE_2 = 37,
    WORK_NONCE_2_HI = 38,
    NONCE2_AND_JOBID_STORE_ADDRESS = 39,
    MERKLE_BIN_NUMBER = 40,
    JOB_START_ADDRESS = 41,
    JOB_LENGTH = 42,
    JOB_DATA_READY = 43,
    JOB_ID = 44,
    WORK_ENABLE = 45,
    BLOCK_HEADER_VERSION = 46,
    TIME_STAMP = 47,
    TARGET_BITS = 48,
    PRE_HEADER_HASH = 49,
    PRE_HEADER_HASH1 = 50,
    PRE_HEADER_HASH2 = 51,
    PRE_HEADER_HASH3 = 52,
    PRE_HEADER_HASH4 = 53,
    PRE_HEADER_HASH5 = 54,
    PRE_HEADER_HASH6 = 55,
    PRE_HEADER_HASH7 = 56,
    BLOCK_VERSION_0 = 57,
    BLOCK_VERSION_1 = 58,
    BLOCK_VERSION_2 = 59,
    BLOCK_VERSION_3 = 60,
    BLOCK_VERSION_4 = 61,
    BLOCK_VERSION_5 = 62,
    BLOCK_VERSION_6 = 63,
    BLOCK_VERSION_7 = 64,
    CHAIN0_3_SEND_FIFO_STATUS = 65,
    CHAIN4_7_SEND_FIFO_STATUS = 66,
    CHAIN8_11_SEND_FIFO_STATUS = 67,
    CHAIN12_13_SEND_FIFO_STATUS = 68,
    CHAIN0_SEND_READY = 69,
    CHAIN0_SEND_BUFFER = 70,
    CHAIN1_SEND_READY = 71,
    CHAIN1_SEND_BUFFER = 72,
    CHAIN2_SEND_READY = 73,
    CHAIN2_SEND_BUFFER = 74,
    CHAIN3_SEND_READY = 75,
    CHAIN3_SEND_BUFFER = 76,
    CHAIN4_SEND_READY = 77,
    CHAIN4_SEND_BUFFER = 78,
    CHAIN5_SEND_READY = 79,
    CHAIN5_SEND_BUFFER = 80,
    CHAIN6_SEND_READY = 81,
    CHAIN6_SEND_BUFFER = 82,
    CHAIN7_SEND_READY = 83,
    CHAIN7_SEND_BUFFER = 84,
    CHAIN8_SEND_READY = 85,
    CHAIN8_SEND_BUFFER = 86,
    CHAIN9_SEND_READY = 87,
    CHAIN9_SEND_BUFFER = 88,
    RECEIVE_FIFO_0_1_STATUS = 89,
    RECEIVE_FIFO_2_3_STATUS = 90,
    RECEIVE_FIFO_4_5_STATUS = 91,
    RECEIVE_FIFO_6_7_STATUS = 92,
    RECEIVE_FIFO_8_9_STATUS = 93,
    RECEIVE_FIFO_10_11_STATUS = 94,
    RECEIVE_FIFO_12_13_STATUS = 95,
    CHAIN0_READ_ENABLE = 96,
    CHAIN0_READ_DATA = 97,
    CHAIN1_READ_ENABLE = 98,
    CHAIN1_READ_DATA = 99,
    CHAIN2_READ_ENABLE = 100,
    CHAIN2_READ_DATA = 101,
    CHAIN3_READ_ENABLE = 102,
    CHAIN3_READ_DATA = 103,
    CHAIN4_READ_ENABLE = 104,
    CHAIN4_READ_DATA = 105,
    CHAIN5_READ_ENABLE = 106,
    CHAIN5_READ_DATA = 107,
    CHAIN6_READ_ENABLE = 108,
    CHAIN6_READ_DATA = 109,
    CHAIN7_READ_ENABLE = 110,
    CHAIN7_READ_DATA = 111,
    CHAIN8_READ_ENABLE = 112,
    CHAIN8_READ_DATA = 113,
    CHAIN9_READ_ENABLE = 114,
    CHAIN9_READ_DATA = 115,
    CHAIN10_SEND_READY = 116,
    CHAIN10_SEND_BUFFER = 117,
    CHAIN11_SEND_READY = 118,
    CHAIN11_SEND_BUFFER = 119,
    CHAIN12_SEND_READY = 120,
    CHAIN12_SEND_BUFFER = 121,
    CHAIN13_SEND_READY = 122,
    CHAIN13_SEND_BUFFER = 123,
    CHAIN10_READ_ENABLE = 124,
    CHAIN10_READ_DATA = 125,
    CHAIN11_READ_ENABLE = 126,
    CHAIN11_READ_DATA = 127,
    CHAIN12_READ_ENABLE = 128,
    CHAIN12_READ_DATA = 129,
    CHAIN13_READ_ENABLE = 130,
    CHAIN13_READ_DATA = 131,
    SEED_ADDRESS_0 = 132,
    SEED_ADDRESS_1 = 133,
    SEED_ADDRESS_2 = 134,
    SEED_ADDRESS_3 = 135,
    SEED_ADDRESS_4 = 136,
    SEED_ADDRESS_5 = 137,
    SEED_ADDRESS_6 = 138,
    SEED_ADDRESS_7 = 139,
    FULL_NODES_ADDR = 140,
    NUM_MODE_ADDR = 141,
    CACHE_SAVE_ADDR = 142,
    CACHE_START_ADDR = 143,
    DS_START_ADDR = 144,
    DS_DONE_ADDR = 145,
    DATA_SAVE_ADDR = 146,
    UART0_STATUS_ADDR = 147,
    UART1_STATUS_ADDR = 148,
    UART2_STATUS_ADDR = 149,
    UART3_STATUS_ADDR = 150,
    UART4_STATUS_ADDR = 151,
    UART5_STATUS_ADDR = 152,
    UART6_STATUS_ADDR = 153,
    UART7_STATUS_ADDR = 154,
    UART8_STATUS_ADDR = 155,
    UART9_STATUS_ADDR = 156,
    UART10_STATUS_ADDR = 157,
    UART11_STATUS_ADDR = 158,
    UART12_STATUS_ADDR = 159,
    UART13_STATUS_ADDR = 160,
    UART14_STATUS_ADDR = 161,
    UART15_STATUS_ADDR = 162,
    UART16_STATUS_ADDR = 163,
    UART17_STATUS_ADDR = 164,
    UART18_STATUS_ADDR = 165,
    UART19_STATUS_ADDR = 166,
    UART20_STATUS_ADDR = 167,
    UART21_STATUS_ADDR = 168,
    UART22_STATUS_ADDR = 169,
    UART23_STATUS_ADDR = 170,
    UART24_STATUS_ADDR = 171,
    UART25_STATUS_ADDR = 172,
    UART26_STATUS_ADDR = 173,
    UART27_STATUS_ADDR = 174,
    UART28_STATUS_ADDR = 175,
    UART29_STATUS_ADDR = 176,
    UART30_STATUS_ADDR = 177,
    UART31_STATUS_ADDR = 178,
    UART_WORK_FLAG_ADDR = 179,
    DATA_SIZE_ADDR = 180,
    DATA_STORE_ADDR = 181,
    UART_CTRL_STATE_ADDR = 182,
    UART_DBG_WR_ADDR = 183,
    UART_DBG_RD_ADDR = 184,
    UART_DBG_STATUS_ADDR = 185,
    BIT_DIV_ADDR = 186,
    MAX_FPGA_INDEX = 187,
} bitmain_fpga_e;

typedef enum {
    DIRECTION_IN = 0,
    DIRECTION_OUT = 1,
} bitmain_gpio_direction_e;

typedef enum {
    S9_HARDWARE = 0,
    T9_PLUS_HARDWARE = 1,
    UNKNOWN_HARDWARE_TYPE = 2,
} bitmain_hardware_type_e;

typedef enum {
    HAL_KEY_PRESSED = 0,
    HAL_KEY_UP = 1,
} bitmain_key_status_e;

typedef enum {
    PIC_NO_ERROR = 0,
    PIC_ERROR_COMMON = 2147484160,
    PIC_BAD_PARAM = 2147484161,
    PIC_NOT_SUPPORT = 2147484162,
} bitmain_pic_error_code;

typedef enum {
    POWER_NO_ERROR = 0,
    POWER_ERROR_COMMON = 2147484416,
    POWER_BAD_PARAM = 2147484417,
    POWER_NOT_SUPPORT = 2147484418,
} bitmain_power_error_code;

typedef enum {
    PWM_CTRL_FAN = 0,
    PWM_CTRL_POWER = 1,
    PWM_CTRL_MAX = 2,
} bitmain_pwm_type_e;

typedef enum {
    TSENSOR_NO_ERROR = 0,
    TSENSOR_ERROR_COMMON = 2147485184,
    TSENSOR_BAD_PARAM = 2147485185,
} bitmain_tsensor_error_code;

typedef enum {
    BAUD = 0,
    UART_VMIN = 1,
    RESERVED = 2,
} bitmain_uart_conf_type_t;

typedef enum {
    hashboard_cache_level = 0,
    asic_cache_level = 1,
    core_cache_level = 2,
} cache_level_e;

typedef enum {
    dstage_getFrameHeader = 0,
    dstage_storeFrameHeader = 1,
    dstage_init = 2,
    dstage_getBlockHeader = 3,
    dstage_storeBlockHeader = 4,
    dstage_copyDirect = 5,
    dstage_getBlockChecksum = 6,
    dstage_getCBlock = 7,
    dstage_storeCBlock = 8,
    dstage_flushOut = 9,
    dstage_getSuffix = 10,
    dstage_storeSuffix = 11,
    dstage_getSFrameSize = 12,
    dstage_storeSFrameSize = 13,
    dstage_skipSkippable = 14,
} dStage_t;

typedef enum {
    noDictCtx = 0,
    usingDictCtxHc = 1,
} dictCtx_directive;

typedef enum {
    noDictIssue = 0,
    dictSmall = 1,
} dictIssue_directive;

typedef enum {
    noDict = 0,
    withPrefix64k = 1,
    usingExtDict = 2,
    usingDictCtx = 3,
} dict_directive;

typedef enum {
    decode_full_block = 0,
    partial_decode = 1,
} earlyEnd_directive;

typedef enum {
    POINT_CONVERSION_COMPRESSED = 2,
    POINT_CONVERSION_UNCOMPRESSED = 4,
    POINT_CONVERSION_HYBRID = 6,
} enum_301;

typedef enum {
    json_error_unknown = 0,
    json_error_out_of_memory = 1,
    json_error_stack_overflow = 2,
    json_error_cannot_open_file = 3,
    json_error_invalid_argument = 4,
    json_error_invalid_utf8 = 5,
    json_error_premature_end_of_input = 6,
    json_error_end_of_input_expected = 7,
    json_error_invalid_syntax = 8,
    json_error_invalid_format = 9,
    json_error_wrong_type = 10,
    json_error_null_character = 11,
    json_error_null_value = 12,
    json_error_null_byte_in_key = 13,
    json_error_duplicate_key = 14,
    json_error_numeric_overflow = 15,
    json_error_item_not_found = 16,
    json_error_index_out_of_range = 17,
} json_error_code;

typedef enum {
    JSON_OBJECT = 0,
    JSON_ARRAY = 1,
    JSON_STRING = 2,
    JSON_INTEGER = 3,
    JSON_REAL = 4,
    JSON_TRUE = 5,
    JSON_FALSE = 6,
    JSON_NULL = 7,
} json_type;

typedef enum {
    notLimited = 0,
    limitedOutput = 1,
    fillOutput = 2,
} limitedOutput_directive;

typedef enum {
    lz4hc = 0,
    lz4opt = 1,
} lz4hc_strat_e;

typedef enum {
    rep_untested = 0,
    rep_not = 1,
    rep_confirmed = 2,
} repeat_state_e;

typedef enum {
    clearedTable = 0,
    byPtr = 1,
    byU32 = 2,
    byU16 = 3,
} tableType_t;

typedef enum {
    UI_ON = 0,
    UI_OFF = 1,
    UI_FLICKER = 2,
} ui_status_e;

typedef enum {
    RED_LED = 1,
    GREEN_LED = 2,
    BEEP_1 = 16,
    RESET_KEY = 256,
    IP_REPORT_KEY = 257,
    PS2PL_RST_KEY = 258,
    UI_RESERVED = 259,
} ui_type_e;

/* ==================== Forward Declarations ==================== */

typedef struct ACCESS_DESCRIPTION_st ACCESS_DESCRIPTION_st;
typedef struct ASIdOrRange_st ASIdOrRange_st;
typedef struct ASIdentifierChoice_st ASIdentifierChoice_st;
typedef struct ASIdentifiers_st ASIdentifiers_st;
typedef struct ASN1_ENCODING_st ASN1_ENCODING_st;
typedef struct ASN1_ITEM_st ASN1_ITEM_st;
typedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE_st;
typedef struct ASN1_TLC_st ASN1_TLC_st;
typedef struct ASN1_VALUE_st ASN1_VALUE_st;
typedef struct ASRange_st ASRange_st;
typedef struct AUTHORITY_KEYID_st AUTHORITY_KEYID_st;
typedef struct BASIC_CONSTRAINTS_st BASIC_CONSTRAINTS_st;
typedef struct CMAC_CTX_st CMAC_CTX_st;
typedef struct CMS_CertificateChoices CMS_CertificateChoices;
typedef struct CMS_ContentInfo_st CMS_ContentInfo_st;
typedef struct CMS_RecipientInfo_st CMS_RecipientInfo_st;
typedef struct CMS_RevocationInfoChoice_st CMS_RevocationInfoChoice_st;
typedef struct CMS_SignerInfo_st CMS_SignerInfo_st;
typedef struct CONF_VALUE CONF_VALUE;
typedef struct DES_ks DES_ks;
typedef struct DIST_POINT_NAME_st DIST_POINT_NAME_st;
typedef struct DIST_POINT_st DIST_POINT_st;
typedef struct DSA_SIG_st DSA_SIG_st;
typedef struct ECDSA_SIG_st ECDSA_SIG_st;
typedef struct EC_builtin_curve EC_builtin_curve;
typedef struct EDIPartyName_st EDIPartyName_st;
typedef struct ENGINE_CMD_DEFN_st ENGINE_CMD_DEFN_st;
typedef struct ERR_string_data_st ERR_string_data_st;
typedef struct Elf32_Dyn_ARM Elf32_Dyn_ARM;
typedef struct Elf32_Ehdr Elf32_Ehdr;
typedef struct Elf32_Phdr Elf32_Phdr;
typedef struct Elf32_Rel Elf32_Rel;
typedef struct Elf32_Shdr Elf32_Shdr;
typedef struct Elf32_Sym Elf32_Sym;
typedef struct GENERAL_NAME_st GENERAL_NAME_st;
typedef struct GENERAL_SUBTREE_st GENERAL_SUBTREE_st;
typedef struct GnuBuildId GnuBuildId;
typedef struct IPAddressChoice_st IPAddressChoice_st;
typedef struct IPAddressFamily_st IPAddressFamily_st;
typedef struct IPAddressOrRange_st IPAddressOrRange_st;
typedef struct IPAddressRange_st IPAddressRange_st;
typedef struct ISSUING_DIST_POINT_st ISSUING_DIST_POINT_st;
typedef struct LZ4F_CDict_s LZ4F_CDict_s;
typedef struct LZ4F_CustomMem LZ4F_CustomMem;
typedef struct LZ4F_cctx_s LZ4F_cctx_s;
typedef struct LZ4F_compressOptions_t LZ4F_compressOptions_t;
typedef struct LZ4F_dctx_s LZ4F_dctx_s;
typedef struct LZ4F_decompressOptions_t LZ4F_decompressOptions_t;
typedef struct LZ4F_frameInfo_t LZ4F_frameInfo_t;
typedef struct LZ4F_preferences_t LZ4F_preferences_t;
typedef struct LZ4HC_CCtx_internal LZ4HC_CCtx_internal;
typedef struct LZ4HC_match_t LZ4HC_match_t;
typedef struct LZ4HC_optimal_t LZ4HC_optimal_t;
typedef struct LZ4_readFile_s LZ4_readFile_s;
typedef struct LZ4_streamDecode_t_internal LZ4_streamDecode_t_internal;
typedef struct LZ4_stream_t_internal LZ4_stream_t_internal;
typedef struct LZ4_writeFile_s LZ4_writeFile_s;
typedef struct MD4state_st MD4state_st;
typedef struct MD5state_st MD5state_st;
typedef struct NAME_CONSTRAINTS_st NAME_CONSTRAINTS_st;
typedef struct NOTICEREF_st NOTICEREF_st;
typedef struct Netscape_certificate_sequence Netscape_certificate_sequence;
typedef struct Netscape_spkac_st Netscape_spkac_st;
typedef struct Netscape_spki_st Netscape_spki_st;
typedef struct NoteAbiTag NoteAbiTag;
typedef struct PBE2PARAM_st PBE2PARAM_st;
typedef struct PBEPARAM_st PBEPARAM_st;
typedef struct PBKDF2PARAM_st PBKDF2PARAM_st;
typedef struct PID PID;
typedef struct PKCS12 PKCS12;
typedef struct PKCS12_MAC_DATA PKCS12_MAC_DATA;
typedef struct PKCS12_SAFEBAG PKCS12_SAFEBAG;
typedef struct PKEY_USAGE_PERIOD_st PKEY_USAGE_PERIOD_st;
typedef struct POLICYINFO_st POLICYINFO_st;
typedef struct POLICYQUALINFO_st POLICYQUALINFO_st;
typedef struct POLICY_CONSTRAINTS_st POLICY_CONSTRAINTS_st;
typedef struct POLICY_MAPPING_st POLICY_MAPPING_st;
typedef struct PROXY_CERT_INFO_EXTENSION_st PROXY_CERT_INFO_EXTENSION_st;
typedef struct PROXY_POLICY_st PROXY_POLICY_st;
typedef struct RIPEMD160state_st RIPEMD160state_st;
typedef struct SHA256state_st SHA256state_st;
typedef struct SHA512state_st SHA512state_st;
typedef struct SHAstate_st SHAstate_st;
typedef struct SXNET_ID_st SXNET_ID_st;
typedef struct SXNET_st SXNET_st;
typedef struct Sweep_Cfg Sweep_Cfg;
typedef struct USERNOTICE_st USERNOTICE_st;
typedef struct WHIRLPOOL_CTX WHIRLPOOL_CTX;
typedef struct X509V3_CONF_METHOD_st X509V3_CONF_METHOD_st;
typedef struct X509_POLICY_CACHE_st X509_POLICY_CACHE_st;
typedef struct X509_POLICY_LEVEL_st X509_POLICY_LEVEL_st;
typedef struct X509_POLICY_NODE_st X509_POLICY_NODE_st;
typedef struct X509_POLICY_TREE_st X509_POLICY_TREE_st;
typedef struct X509_VERIFY_PARAM_st X509_VERIFY_PARAM_st;
typedef struct X509_algor_st X509_algor_st;
typedef struct X509_crl_info_st X509_crl_info_st;
typedef struct X509_crl_st X509_crl_st;
typedef struct X509_extension_st X509_extension_st;
typedef struct X509_info_st X509_info_st;
typedef struct X509_name_entry_st X509_name_entry_st;
typedef struct X509_name_st X509_name_st;
typedef struct X509_pubkey_st X509_pubkey_st;
typedef struct X509_req_info_st X509_req_info_st;
typedef struct X509_req_st X509_req_st;
typedef struct X509_sig_st X509_sig_st;
typedef struct X509_val_st X509_val_st;
typedef struct XXH32_canonical_t XXH32_canonical_t;
typedef struct XXH32_state_s XXH32_state_s;
typedef struct XXH64_canonical_t XXH64_canonical_t;
typedef struct XXH64_state_s XXH64_state_s;
typedef struct _IO_FILE _IO_FILE;
typedef struct _IO_FILE _IO_FILE;
typedef struct _IO_marker _IO_marker;
typedef struct _IO_marker _IO_marker;
typedef struct __dirstream __dirstream;
typedef struct __dirstream __dirstream;
typedef struct __pthread_internal_slist __pthread_internal_slist;
typedef struct __pthread_internal_slist __pthread_internal_slist;
typedef struct __pthread_mutex_s __pthread_mutex_s;
typedef struct __pthread_mutex_s __pthread_mutex_s;
typedef struct __sigset_t __sigset_t;
typedef struct __sigset_t __sigset_t;
typedef struct __va_list __va_list;
typedef struct _asic_reg_conf _asic_reg_conf;
typedef struct _asic_status _asic_status;
typedef struct _config_ctx _config_ctx;
typedef struct _eeprom_data_format _eeprom_data_format;
typedef struct _fan_ctx _fan_ctx;
typedef struct _hash_board _hash_board;
typedef struct _pattern_bin _pattern_bin;
typedef struct _pattern_ops_t _pattern_ops_t;
typedef struct _pattern_runtime_ctx _pattern_runtime_ctx;
typedef struct _pattern_test_stats _pattern_test_stats;
typedef struct _pattern_work _pattern_work;
typedef struct _pitem _pitem;
typedef struct _pll_conf _pll_conf;
typedef struct _pqueue _pqueue;
typedef struct _ptx_err_msg_ _ptx_err_msg_;
typedef struct _sensor_ctx _sensor_ctx;
typedef struct _struct_1032 _struct_1032;
typedef struct _struct_1033 _struct_1033;
typedef struct _struct_1034 _struct_1034;
typedef struct _struct_1035 _struct_1035;
typedef struct _struct_1036 _struct_1036;
typedef struct _struct_1037 _struct_1037;
typedef struct _struct_16 _struct_16;
typedef struct _struct_19 _struct_19;
typedef struct _struct_621 _struct_621;
typedef struct _struct_647 _struct_647;
typedef struct _struct_651 _struct_651;
typedef struct _sweep_ctx _sweep_ctx;
typedef struct _temp_ctx _temp_ctx;
typedef struct _test_ctx _test_ctx;
typedef struct _test_speed _test_speed;
typedef struct _test_standard _test_standard;
typedef struct _work_cxt _work_cxt;
typedef struct addrinfo addrinfo;
typedef struct addrinfo addrinfo;
typedef struct aes_key_st aes_key_st;
typedef struct anon_struct_12_3_5124685d_for__timer anon_struct_12_3_5124685d_for__timer;
typedef struct anon_struct_12_3_9bedbd60_for__rt anon_struct_12_3_9bedbd60_for__rt;
typedef struct anon_struct_12_3_fe5e7108_for__sigsys anon_struct_12_3_fe5e7108_for__sigsys;
typedef struct anon_struct_16_11_6b887386_for_reg anon_struct_16_11_6b887386_for_reg;
typedef struct anon_struct_16_14_521757b1_for_nonce anon_struct_16_14_521757b1_for_nonce;
typedef struct anon_struct_1_5_2d401d3c_for_u anon_struct_1_5_2d401d3c_for_u;
typedef struct anon_struct_20_5_7a025f54_for__sigchld anon_struct_20_5_7a025f54_for__sigchld;
typedef struct anon_struct_2_2_c6ab8785_for_u anon_struct_2_2_c6ab8785_for_u;
typedef struct anon_struct_2_2_d78050c7_for_u anon_struct_2_2_d78050c7_for_u;
typedef struct anon_struct_2_3_d58cde66_for_u anon_struct_2_3_d58cde66_for_u;
typedef struct anon_struct_2_3_e7583c08_for_u anon_struct_2_3_e7583c08_for_u;
typedef struct anon_struct_2_4_bd7cc306_for_u anon_struct_2_4_bd7cc306_for_u;
typedef struct anon_struct_2_4_e5384816_for_u anon_struct_2_4_e5384816_for_u;
typedef struct anon_struct_2_5_1a639049_for_u anon_struct_2_5_1a639049_for_u;
typedef struct anon_struct_2_6_81fe2f07_for_u anon_struct_2_6_81fe2f07_for_u;
typedef struct anon_struct_48_8_df74bd48_for___data anon_struct_48_8_df74bd48_for___data;
typedef struct anon_struct_4_10_b75caf2b_for_u anon_struct_4_10_b75caf2b_for_u;
typedef struct anon_struct_4_11_bb44c716_for_u anon_struct_4_11_bb44c716_for_u;
typedef struct anon_struct_4_12_17032573_for_u anon_struct_4_12_17032573_for_u;
typedef struct anon_struct_4_13_422ceaf4_for_u anon_struct_4_13_422ceaf4_for_u;
typedef struct anon_struct_4_18_3f3fc8fd_for_u anon_struct_4_18_3f3fc8fd_for_u;
typedef struct anon_struct_4_18_a6851311_for_u anon_struct_4_18_a6851311_for_u;
typedef struct anon_struct_4_19_15a1c2d0_for_u anon_struct_4_19_15a1c2d0_for_u;
typedef struct anon_struct_4_1_397754f6_for_u anon_struct_4_1_397754f6_for_u;
typedef struct anon_struct_4_1_413bbfcc_for_u anon_struct_4_1_413bbfcc_for_u;
typedef struct anon_struct_4_2_84162d83_for_u anon_struct_4_2_84162d83_for_u;
typedef struct anon_struct_4_2_9e97f829_for_u anon_struct_4_2_9e97f829_for_u;
typedef struct anon_struct_4_3_30b46c24_for_u2 anon_struct_4_3_30b46c24_for_u2;
typedef struct anon_struct_4_3_4f6a2092_for_u anon_struct_4_3_4f6a2092_for_u;
typedef struct anon_struct_4_3_759a448f_for_u anon_struct_4_3_759a448f_for_u;
typedef struct anon_struct_4_3_b0bb6857_for_u anon_struct_4_3_b0bb6857_for_u;
typedef struct anon_struct_4_4_08564e81_for_u anon_struct_4_4_08564e81_for_u;
typedef struct anon_struct_4_4_a1dac117_for_u anon_struct_4_4_a1dac117_for_u;
typedef struct anon_struct_4_5_399a9cf7_for_u anon_struct_4_5_399a9cf7_for_u;
typedef struct anon_struct_4_5_b8274f34_for_u anon_struct_4_5_b8274f34_for_u;
typedef struct anon_struct_4_8_6d10a169_for_u anon_struct_4_8_6d10a169_for_u;
typedef struct anon_struct_4_8_ad5e9fc5_for_u anon_struct_4_8_ad5e9fc5_for_u;
typedef struct anon_struct_4_8_bac425d5_for_u anon_struct_4_8_bac425d5_for_u;
typedef struct anon_struct_4_8_fb3c3b36_for_u anon_struct_4_8_fb3c3b36_for_u;
typedef struct anon_struct_5_8_110e986d_for_u anon_struct_5_8_110e986d_for_u;
typedef struct anon_struct_5_8_15bfd022_for_u anon_struct_5_8_15bfd022_for_u;
typedef struct anon_struct_5_9_f9e27364_for_u anon_struct_5_9_f9e27364_for_u;
typedef struct anon_struct_8_2_0a3d7222_for__kill anon_struct_8_2_0a3d7222_for__kill;
typedef struct anon_struct_8_2_43e888f9_for_string anon_struct_8_2_43e888f9_for_string;
typedef struct anon_struct_8_2_686959ae_for__sigpoll anon_struct_8_2_686959ae_for__sigpoll;
typedef struct anon_struct_8_2_895adaa1_for__sigfault anon_struct_8_2_895adaa1_for__sigfault;
typedef struct anon_struct_9_9_23b62a12_for_u anon_struct_9_9_23b62a12_for_u;
typedef struct asic_register asic_register;
typedef struct asic_register_value_t asic_register_value_t;
typedef struct asic_val_t asic_val_t;
typedef struct asn1_object_st asn1_object_st;
typedef struct asn1_pctx_st asn1_pctx_st;
typedef struct asn1_string_st asn1_string_st;
typedef struct asn1_string_table_st asn1_string_table_st;
typedef struct asn1_type_st asn1_type_st;
typedef struct bf_key_st bf_key_st;
typedef struct bignum_ctx bignum_ctx;
typedef struct bignum_st bignum_st;
typedef struct bio_method_st bio_method_st;
typedef struct bio_st bio_st;
typedef struct bitmain_board_t bitmain_board_t;
typedef struct bitmain_chain_t bitmain_chain_t;
typedef struct bitmain_chain_tsensor bitmain_chain_tsensor;
typedef struct bitmain_eeprom_t bitmain_eeprom_t;
typedef struct bitmain_mac_t bitmain_mac_t;
typedef struct bitmain_pic_t bitmain_pic_t;
typedef struct bitmain_power_t bitmain_power_t;
typedef struct bitmain_sys_capability_t bitmain_sys_capability_t;
typedef struct bitmain_tsensor_t bitmain_tsensor_t;
typedef struct bitmain_uuid_t bitmain_uuid_t;
typedef struct bn_blinding_st bn_blinding_st;
typedef struct bn_gencb_st bn_gencb_st;
typedef struct bn_mont_ctx_st bn_mont_ctx_st;
typedef struct bn_recp_ctx_st bn_recp_ctx_st;
typedef struct buf_mem_st buf_mem_st;
typedef struct buffer buffer;
typedef struct buffer_data_t buffer_data_t;
typedef struct cParams_t cParams_t;
typedef struct callback_data_t callback_data_t;
typedef struct camellia_key_st camellia_key_st;
typedef struct cast_key_st cast_key_st;
typedef struct cert_st cert_st;
typedef struct chain_conf_info chain_conf_info;
typedef struct cisco_proto cisco_proto;
typedef struct clib_deque clib_deque;
typedef struct clib_iterator clib_iterator;
typedef struct clib_map clib_map;
typedef struct clib_object clib_object;
typedef struct clib_rb clib_rb;
typedef struct clib_rb_node clib_rb_node;
typedef struct comp_ctx_st comp_ctx_st;
typedef struct comp_method_st comp_method_st;
typedef struct conf_imodule_st conf_imodule_st;
typedef struct conf_method_st conf_method_st;
typedef struct conf_module_st conf_module_st;
typedef struct conf_st conf_st;
typedef struct crypto_ex_data_st crypto_ex_data_st;
typedef struct crypto_threadid_st crypto_threadid_st;
typedef struct ctrlboard_sensor ctrlboard_sensor;
typedef struct dh_method dh_method;
typedef struct dh_st dh_st;
typedef struct dhash_job_info_t dhash_job_info_t;
typedef struct dirent dirent;
typedef struct dirent dirent;
typedef struct display display;
typedef struct dsa_method dsa_method;
typedef struct dsa_st dsa_st;
typedef struct dso_meth_st dso_meth_st;
typedef struct dso_st dso_st;
typedef struct dtls1_bitmap_st dtls1_bitmap_st;
typedef struct dtls1_retransmit_state dtls1_retransmit_state;
typedef struct dtls1_state_st dtls1_state_st;
typedef struct dtls1_timeout_st dtls1_timeout_st;
typedef struct ec_group_st ec_group_st;
typedef struct ec_key_st ec_key_st;
typedef struct ec_method_st ec_method_st;
typedef struct ec_point_st ec_point_st;
typedef struct edf_v4_priv edf_v4_priv;
typedef struct edf_v5_priv edf_v5_priv;
typedef struct eeprom_data_t eeprom_data_t;
typedef struct engine_st engine_st;
typedef struct env_md_ctx_st env_md_ctx_st;
typedef struct env_md_st env_md_st;
typedef struct err_state_st err_state_st;
typedef struct evp_Encode_Ctx_st evp_Encode_Ctx_st;
typedef struct evp_cipher_ctx_st evp_cipher_ctx_st;
typedef struct evp_cipher_info_st evp_cipher_info_st;
typedef struct evp_cipher_st evp_cipher_st;
typedef struct evp_pkey_asn1_method_st evp_pkey_asn1_method_st;
typedef struct evp_pkey_ctx_st evp_pkey_ctx_st;
typedef struct evp_pkey_method_st evp_pkey_method_st;
typedef struct evp_pkey_st evp_pkey_st;
typedef struct fan fan;
typedef struct fan_conf_info fan_conf_info;
typedef struct fd_set fd_set;
typedef struct fd_set fd_set;
typedef struct filker_interval_t filker_interval_t;
typedef struct fr_proto fr_proto;
typedef struct fr_proto_pvc fr_proto_pvc;
typedef struct fr_proto_pvc_info fr_proto_pvc_info;
typedef struct gpio_callback_t gpio_callback_t;
typedef struct gpio_map_t gpio_map_t;
typedef struct hash_board hash_board;
typedef struct hashboard_qr_code hashboard_qr_code;
typedef struct hashboard_sn hashboard_sn;
typedef struct hashtable hashtable;
typedef struct hashtable_bucket hashtable_bucket;
typedef struct hashtable_list hashtable_list;
typedef struct hashtable_pair hashtable_pair;
typedef struct history_result history_result;
typedef struct hm_header_st hm_header_st;
typedef struct hmac_ctx_st hmac_ctx_st;
typedef struct hostent hostent;
typedef struct hostent hostent;
typedef struct i2c_value_t i2c_value_t;
typedef struct if_settings if_settings;
typedef struct ifmap ifmap;
typedef struct ifreq ifreq;
typedef struct iic_init_param_t iic_init_param_t;
typedef struct in6_addr in6_addr;
typedef struct in_addr in_addr;
typedef struct in_addr in_addr;
typedef struct json_array_t json_array_t;
typedef struct json_error_t json_error_t;
typedef struct json_integer_t json_integer_t;
typedef struct json_object_t json_object_t;
typedef struct json_real_t json_real_t;
typedef struct json_string_t json_string_t;
typedef struct json_t json_t;
typedef struct kssl_ctx_st kssl_ctx_st;
typedef struct lconv lconv;
typedef struct lconv lconv;
typedef struct lex_t lex_t;
typedef struct lhash_st_CONF_VALUE lhash_st_CONF_VALUE;
typedef struct lhash_st_OPENSSL_STRING lhash_st_OPENSSL_STRING;
typedef struct lhash_st_SSL_SESSION lhash_st_SSL_SESSION;
typedef struct local_config_info local_config_info;
typedef struct log_info_t log_info_t;
typedef struct mes_system_asic_reg mes_system_asic_reg;
typedef struct mes_system_config_file_info mes_system_config_file_info;
typedef struct mes_system_configs mes_system_configs;
typedef struct mes_system_data mes_system_data;
typedef struct mes_system_hw_info mes_system_hw_info;
typedef struct mes_system_pattern mes_system_pattern;
typedef struct mes_system_result mes_system_result;
typedef struct mes_system_rule mes_system_rule;
typedef struct mes_system_test_config mes_system_test_config;
typedef struct mes_system_test_loop mes_system_test_loop;
typedef struct mes_system_test_method mes_system_test_method;
typedef struct obj_name_st obj_name_st;
typedef struct ocsp_basic_response_st ocsp_basic_response_st;
typedef struct ocsp_cert_id_st ocsp_cert_id_st;
typedef struct ocsp_cert_status_st ocsp_cert_status_st;
typedef struct ocsp_crl_id_st ocsp_crl_id_st;
typedef struct ocsp_one_request_st ocsp_one_request_st;
typedef struct ocsp_req_ctx_st ocsp_req_ctx_st;
typedef struct ocsp_req_info_st ocsp_req_info_st;
typedef struct ocsp_request_st ocsp_request_st;
typedef struct ocsp_resp_bytes_st ocsp_resp_bytes_st;
typedef struct ocsp_responder_id_st ocsp_responder_id_st;
typedef struct ocsp_response_data_st ocsp_response_data_st;
typedef struct ocsp_response_st ocsp_response_st;
typedef struct ocsp_revoked_info_st ocsp_revoked_info_st;
typedef struct ocsp_service_locator_st ocsp_service_locator_st;
typedef struct ocsp_signature_st ocsp_signature_st;
typedef struct ocsp_single_response_st ocsp_single_response_st;
typedef struct op_sweep op_sweep;
typedef struct otherName_st otherName_st;
typedef struct pattern_info_new pattern_info_new;
typedef struct pattern_struct_in_file pattern_struct_in_file;
typedef struct pattern_struct_in_file pattern_struct_in_file;
typedef struct pattern_struct_in_file pattern_struct_in_file;
typedef struct pattern_struct_in_file pattern_struct_in_file;
typedef struct pic_sensor pic_sensor;
typedef struct pkcs12_bag_st pkcs12_bag_st;
typedef struct pkcs7_digest_st pkcs7_digest_st;
typedef struct pkcs7_enc_content_st pkcs7_enc_content_st;
typedef struct pkcs7_encrypted_st pkcs7_encrypted_st;
typedef struct pkcs7_enveloped_st pkcs7_enveloped_st;
typedef struct pkcs7_issuer_and_serial_st pkcs7_issuer_and_serial_st;
typedef struct pkcs7_recip_info_st pkcs7_recip_info_st;
typedef struct pkcs7_signed_st pkcs7_signed_st;
typedef struct pkcs7_signedandenveloped_st pkcs7_signedandenveloped_st;
typedef struct pkcs7_signer_info_st pkcs7_signer_info_st;
typedef struct pkcs7_st pkcs7_st;
typedef struct pkcs8_priv_key_info_st pkcs8_priv_key_info_st;
typedef struct pll_conf pll_conf;
typedef struct pll_divider_conf_t pll_divider_conf_t;
typedef struct pll_userdivider_t pll_userdivider_t;
typedef struct pllparameter_t pllparameter_t;
typedef struct power_temp_t power_temp_t;
typedef struct private_key_st private_key_st;
typedef struct pt1_ctx pt1_ctx;
typedef struct pwm_init_param_t pwm_init_param_t;
typedef struct rand_meth_st rand_meth_st;
typedef struct raw_hdlc_proto raw_hdlc_proto;
typedef struct rc2_key_st rc2_key_st;
typedef struct rc4_key_st rc4_key_st;
typedef struct record_pqueue_st record_pqueue_st;
typedef struct reg_buf reg_buf;
typedef struct reg_content reg_content;
typedef struct repair_mode repair_mode;
typedef struct rsa_meth_st rsa_meth_st;
typedef struct rsa_pss_params_st rsa_pss_params_st;
typedef struct rsa_st rsa_st;
typedef struct seed_key_st seed_key_st;
typedef struct sensor_info sensor_info;
typedef struct sess_cert_st sess_cert_st;
typedef struct sha2_context sha2_context;
typedef struct sigaction sigaction;
typedef struct sigaction sigaction;
typedef struct siginfo siginfo;
typedef struct siginfo_t siginfo_t;
typedef struct sockaddr sockaddr;
typedef struct sockaddr sockaddr;
typedef struct sockaddr_at sockaddr_at;
typedef struct sockaddr_ax25 sockaddr_ax25;
typedef struct sockaddr_dl sockaddr_dl;
typedef struct sockaddr_eon sockaddr_eon;
typedef struct sockaddr_in sockaddr_in;
typedef struct sockaddr_in6 sockaddr_in6;
typedef struct sockaddr_inarp sockaddr_inarp;
typedef struct sockaddr_ipx sockaddr_ipx;
typedef struct sockaddr_iso sockaddr_iso;
typedef struct sockaddr_ns sockaddr_ns;
typedef struct sockaddr_un sockaddr_un;
typedef struct sockaddr_x25 sockaddr_x25;
typedef struct srtp_protection_profile_st srtp_protection_profile_st;
typedef struct ssl2_state_st ssl2_state_st;
typedef struct ssl3_buf_freelist_st ssl3_buf_freelist_st;
typedef struct ssl3_buffer_st ssl3_buffer_st;
typedef struct ssl3_enc_method ssl3_enc_method;
typedef struct ssl3_record_st ssl3_record_st;
typedef struct ssl3_state_st ssl3_state_st;
typedef struct ssl_cipher_st ssl_cipher_st;
typedef struct ssl_comp_st ssl_comp_st;
typedef struct ssl_ctx_st ssl_ctx_st;
typedef struct ssl_ctx_st ssl_ctx_st;
typedef struct ssl_method_st ssl_method_st;
typedef struct ssl_session_st ssl_session_st;
typedef struct ssl_st ssl_st;
typedef struct ssl_st ssl_st;
typedef struct stack_st stack_st;
typedef struct stack_st_ACCESS_DESCRIPTION stack_st_ACCESS_DESCRIPTION;
typedef struct stack_st_ASIdOrRange stack_st_ASIdOrRange;
typedef struct stack_st_ASN1_INTEGER stack_st_ASN1_INTEGER;
typedef struct stack_st_ASN1_OBJECT stack_st_ASN1_OBJECT;
typedef struct stack_st_ASN1_TYPE stack_st_ASN1_TYPE;
typedef struct stack_st_CMS_RecipientInfo stack_st_CMS_RecipientInfo;
typedef struct stack_st_CMS_SignerInfo stack_st_CMS_SignerInfo;
typedef struct stack_st_CONF_VALUE stack_st_CONF_VALUE;
typedef struct stack_st_DIST_POINT stack_st_DIST_POINT;
typedef struct stack_st_GENERAL_NAME stack_st_GENERAL_NAME;
typedef struct stack_st_GENERAL_NAMES stack_st_GENERAL_NAMES;
typedef struct stack_st_GENERAL_SUBTREE stack_st_GENERAL_SUBTREE;
typedef struct stack_st_IPAddressFamily stack_st_IPAddressFamily;
typedef struct stack_st_IPAddressOrRange stack_st_IPAddressOrRange;
typedef struct stack_st_OCSP_ONEREQ stack_st_OCSP_ONEREQ;
typedef struct stack_st_OCSP_RESPID stack_st_OCSP_RESPID;
typedef struct stack_st_OCSP_SINGLERESP stack_st_OCSP_SINGLERESP;
typedef struct stack_st_OPENSSL_PSTRING stack_st_OPENSSL_PSTRING;
typedef struct stack_st_OPENSSL_STRING stack_st_OPENSSL_STRING;
typedef struct stack_st_PKCS12_SAFEBAG stack_st_PKCS12_SAFEBAG;
typedef struct stack_st_PKCS7 stack_st_PKCS7;
typedef struct stack_st_PKCS7_RECIP_INFO stack_st_PKCS7_RECIP_INFO;
typedef struct stack_st_PKCS7_SIGNER_INFO stack_st_PKCS7_SIGNER_INFO;
typedef struct stack_st_POLICYINFO stack_st_POLICYINFO;
typedef struct stack_st_POLICYQUALINFO stack_st_POLICYQUALINFO;
typedef struct stack_st_SRTP_PROTECTION_PROFILE stack_st_SRTP_PROTECTION_PROFILE;
typedef struct stack_st_SSL_CIPHER stack_st_SSL_CIPHER;
typedef struct stack_st_SSL_COMP stack_st_SSL_COMP;
typedef struct stack_st_SXNETID stack_st_SXNETID;
typedef struct stack_st_X509 stack_st_X509;
typedef struct stack_st_X509_ALGOR stack_st_X509_ALGOR;
typedef struct stack_st_X509_ATTRIBUTE stack_st_X509_ATTRIBUTE;
typedef struct stack_st_X509_CRL stack_st_X509_CRL;
typedef struct stack_st_X509_EXTENSION stack_st_X509_EXTENSION;
typedef struct stack_st_X509_INFO stack_st_X509_INFO;
typedef struct stack_st_X509_LOOKUP stack_st_X509_LOOKUP;
typedef struct stack_st_X509_NAME stack_st_X509_NAME;
typedef struct stack_st_X509_NAME_ENTRY stack_st_X509_NAME_ENTRY;
typedef struct stack_st_X509_OBJECT stack_st_X509_OBJECT;
typedef struct stack_st_X509_POLICY_NODE stack_st_X509_POLICY_NODE;
typedef struct stack_st_X509_REVOKED stack_st_X509_REVOKED;
typedef struct stack_st_void stack_st_void;
typedef struct stat stat;
typedef struct stat stat;
typedef struct strbuffer_t strbuffer_t;
typedef struct stream_t stream_t;
typedef struct string_data_t string_data_t;
typedef struct sweep_bad_asic_info_t sweep_bad_asic_info_t;
typedef struct sweep_err_state sweep_err_state;
typedef struct sweep_result_t sweep_result_t;
typedef struct sync_serial_settings sync_serial_settings;
typedef struct sysinfo sysinfo;
typedef struct sysinfo sysinfo;
typedef struct te1_settings te1_settings;
typedef struct temperature temperature;
typedef struct termios termios;
typedef struct test_info test_info;
typedef struct test_info_t test_info_t;
typedef struct test_loop test_loop;
typedef struct test_method test_method;
typedef struct test_pattern_new test_pattern_new;
typedef struct test_speed test_speed;
typedef struct test_standard test_standard;
typedef struct timespec timespec;
typedef struct timespec timespec;
typedef struct timeval timeval;
typedef struct timeval timeval;
typedef struct timezone timezone;
typedef struct timezone timezone;
typedef struct tls_session_ticket_ext_st tls_session_ticket_ext_st;
typedef struct tm tm;
typedef struct tm tm;
typedef struct tm.conflict tm.conflict;
typedef struct txt_db_st txt_db_st;
typedef struct ui_method_st ui_method_st;
typedef struct ui_st ui_st;
typedef struct ui_string_st ui_string_st;
typedef struct utsname utsname;
typedef struct v3_ext_ctx v3_ext_ctx;
typedef struct v3_ext_method v3_ext_method;
typedef struct work_format work_format;
typedef struct work_new work_new;
typedef struct x509_attributes_st x509_attributes_st;
typedef struct x509_cert_aux_st x509_cert_aux_st;
typedef struct x509_cinf_st x509_cinf_st;
typedef struct x509_crl_method_st x509_crl_method_st;
typedef struct x509_lookup_method_st x509_lookup_method_st;
typedef struct x509_lookup_st x509_lookup_st;
typedef struct x509_object_st x509_object_st;
typedef struct x509_purpose_st x509_purpose_st;
typedef struct x509_revoked_st x509_revoked_st;
typedef struct x509_st x509_st;
typedef struct x509_store_ctx_st x509_store_ctx_st;
typedef struct x509_store_st x509_store_st;
typedef struct x509_trust_st x509_trust_st;
typedef struct zhiju_eeprom_data_map zhiju_eeprom_data_map;
typedef struct zhiju_information zhiju_information;

/* ==================== Structures ==================== */

struct ACCESS_DESCRIPTION_st {
    ASN1_OBJECT * method;  // offset: 0x0
    GENERAL_NAME * location;  // offset: 0x4
}; // size: 0x8

struct ASIdOrRange_st {
    int type;  // offset: 0x0
    _union_929 u;  // offset: 0x4
}; // size: 0x8

struct ASIdentifierChoice_st {
    int type;  // offset: 0x0
    _union_933 u;  // offset: 0x4
}; // size: 0x8

struct ASIdentifiers_st {
    ASIdentifierChoice * asnum;  // offset: 0x0
    ASIdentifierChoice * * rdi;  // offset: 0x4
}; // size: 0x8

struct ASN1_ENCODING_st {
    uchar * enc;  // offset: 0x0
    long len;  // offset: 0x4
    int modified;  // offset: 0x8
}; // size: 0xc

struct ASN1_ITEM_st {
    char itype;  // offset: 0x0
    long utype;  // offset: 0x4
    ASN1_TEMPLATE * templates;  // offset: 0x8
    long tcount;  // offset: 0xc
    void * funcs;  // offset: 0x10
    long size;  // offset: 0x14
    char * sname;  // offset: 0x18
}; // size: 0x1c

struct ASN1_TEMPLATE_st {
    ulong flags;  // offset: 0x0
    long tag;  // offset: 0x4
    ulong offset;  // offset: 0x8
    char * field_name;  // offset: 0xc
    ASN1_ITEM_EXP * item;  // offset: 0x10
}; // size: 0x14

struct ASN1_TLC_st {
    char valid;  // offset: 0x0
    int ret;  // offset: 0x4
    long plen;  // offset: 0x8
    int ptag;  // offset: 0xc
    int pclass;  // offset: 0x10
    int hdrlen;  // offset: 0x14
}; // size: 0x18

struct ASN1_VALUE_st {
    // Empty structure
}; // size: 0x1

struct ASRange_st {
    ASN1_INTEGER * min;  // offset: 0x0
    ASN1_INTEGER * * max;  // offset: 0x4
}; // size: 0x8

struct AUTHORITY_KEYID_st {
    ASN1_OCTET_STRING * keyid;  // offset: 0x0
    GENERAL_NAMES * issuer;  // offset: 0x4
    ASN1_INTEGER * serial;  // offset: 0x8
}; // size: 0xc

struct BASIC_CONSTRAINTS_st {
    int ca;  // offset: 0x0
    ASN1_INTEGER * pathlen;  // offset: 0x4
}; // size: 0x8

struct CMAC_CTX_st {
    // Empty structure
}; // size: 0x1

struct CMS_CertificateChoices {
    // Empty structure
}; // size: 0x1

struct CMS_ContentInfo_st {
    // Empty structure
}; // size: 0x1

struct CMS_RecipientInfo_st {
    // Empty structure
}; // size: 0x1

struct CMS_RevocationInfoChoice_st {
    // Empty structure
}; // size: 0x1

struct CMS_SignerInfo_st {
    // Empty structure
}; // size: 0x1

struct CONF_VALUE {
    char * section;  // offset: 0x0
    char * name;  // offset: 0x4
    char * value;  // offset: 0x8
}; // size: 0xc

struct DES_ks {
    _union_24 ks[16];  // offset: 0x0
}; // size: 0x80

struct DIST_POINT_NAME_st {
    int type;  // offset: 0x0
    _union_859 name;  // offset: 0x4
    X509_NAME * dpname;  // offset: 0x8
}; // size: 0xc

struct DIST_POINT_st {
    DIST_POINT_NAME * distpoint;  // offset: 0x0
    ASN1_BIT_STRING * reasons;  // offset: 0x4
    GENERAL_NAMES * CRLissuer;  // offset: 0x8
    int dp_reasons;  // offset: 0xc
}; // size: 0x10

struct DSA_SIG_st {
    BIGNUM * r;  // offset: 0x0
    BIGNUM * s;  // offset: 0x4
}; // size: 0x8

struct ECDSA_SIG_st {
    BIGNUM * r;  // offset: 0x0
    BIGNUM * s;  // offset: 0x4
}; // size: 0x8

struct EC_builtin_curve {
    int nid;  // offset: 0x0
    char * comment;  // offset: 0x4
}; // size: 0x8

struct EDIPartyName_st {
    ASN1_STRING * nameAssigner;  // offset: 0x0
    ASN1_STRING * partyName;  // offset: 0x4
}; // size: 0x8

struct ENGINE_CMD_DEFN_st {
    uint cmd_num;  // offset: 0x0
    char * cmd_name;  // offset: 0x4
    char * cmd_desc;  // offset: 0x8
    uint cmd_flags;  // offset: 0xc
}; // size: 0x10

struct ERR_string_data_st {
    ulong error;  // offset: 0x0
    char * string;  // offset: 0x4
}; // size: 0x8

struct Elf32_Dyn_ARM {
    Elf32_DynTag_ARM d_tag;  // offset: 0x0
    dword d_val;  // offset: 0x4
}; // size: 0x8

struct Elf32_Ehdr {
    byte e_ident_magic_num;  // offset: 0x0
    string e_ident_magic_str;  // offset: 0x1
    byte e_ident_class;  // offset: 0x4
    byte e_ident_data;  // offset: 0x5
    byte e_ident_version;  // offset: 0x6
    byte e_ident_osabi;  // offset: 0x7
    byte e_ident_abiversion;  // offset: 0x8
    byte e_ident_pad[7];  // offset: 0x9
    word e_type;  // offset: 0x10
    word e_machine;  // offset: 0x12
    dword e_version;  // offset: 0x14
    dword e_entry;  // offset: 0x18
    dword e_phoff;  // offset: 0x1c
    dword e_shoff;  // offset: 0x20
    dword e_flags;  // offset: 0x24
    word e_ehsize;  // offset: 0x28
    word e_phentsize;  // offset: 0x2a
    word e_phnum;  // offset: 0x2c
    word e_shentsize;  // offset: 0x2e
    word e_shnum;  // offset: 0x30
    word e_shstrndx;  // offset: 0x32
}; // size: 0x34

struct Elf32_Phdr {
    Elf_ProgramHeaderType_ARM p_type;  // offset: 0x0
    dword p_offset;  // offset: 0x4
    dword p_vaddr;  // offset: 0x8
    dword p_paddr;  // offset: 0xc
    dword p_filesz;  // offset: 0x10
    dword p_memsz;  // offset: 0x14
    dword p_flags;  // offset: 0x18
    dword p_align;  // offset: 0x1c
}; // size: 0x20

struct Elf32_Rel {
    dword r_offset;  // offset: 0x0
    dword r_info;  // offset: 0x4
}; // size: 0x8

struct Elf32_Shdr {
    dword sh_name;  // offset: 0x0
    Elf_SectionHeaderType_ARM sh_type;  // offset: 0x4
    dword sh_flags;  // offset: 0x8
    dword sh_addr;  // offset: 0xc
    dword sh_offset;  // offset: 0x10
    dword sh_size;  // offset: 0x14
    dword sh_link;  // offset: 0x18
    dword sh_info;  // offset: 0x1c
    dword sh_addralign;  // offset: 0x20
    dword sh_entsize;  // offset: 0x24
}; // size: 0x28

struct Elf32_Sym {
    dword st_name;  // offset: 0x0
    dword st_value;  // offset: 0x4
    dword st_size;  // offset: 0x8
    byte st_info;  // offset: 0xc
    byte st_other;  // offset: 0xd
    word st_shndx;  // offset: 0xe
}; // size: 0x10

struct GENERAL_NAME_st {
    int type;  // offset: 0x0
    _union_851 d;  // offset: 0x4
}; // size: 0x8

struct GENERAL_SUBTREE_st {
    GENERAL_NAME * base;  // offset: 0x0
    ASN1_INTEGER * minimum;  // offset: 0x4
    ASN1_INTEGER * maximum;  // offset: 0x8
}; // size: 0xc

struct GnuBuildId {
    dword namesz;  // offset: 0x0
    dword descsz;  // offset: 0x4
    dword type;  // offset: 0x8
    string name;  // offset: 0xc
    byte hash[20];  // offset: 0x10
}; // size: 0x24

struct IPAddressChoice_st {
    int type;  // offset: 0x0
    _union_941 u;  // offset: 0x4
}; // size: 0x8

struct IPAddressFamily_st {
    ASN1_OCTET_STRING * addressFamily;  // offset: 0x0
    IPAddressChoice * ipAddressChoice;  // offset: 0x4
}; // size: 0x8

struct IPAddressOrRange_st {
    int type;  // offset: 0x0
    _union_937 u;  // offset: 0x4
}; // size: 0x8

struct IPAddressRange_st {
    ASN1_BIT_STRING * min;  // offset: 0x0
    ASN1_BIT_STRING * * max;  // offset: 0x4
}; // size: 0x8

struct ISSUING_DIST_POINT_st {
    DIST_POINT_NAME * distpoint;  // offset: 0x0
    int onlyuser;  // offset: 0x4
    int onlyCA;  // offset: 0x8
    ASN1_BIT_STRING * onlysomereasons;  // offset: 0xc
    int indirectCRL;  // offset: 0x10
    int onlyattr;  // offset: 0x14
}; // size: 0x18

struct LZ4F_CDict_s {
    LZ4F_CustomMem cmem;  // offset: 0x0
    void * dictContent;  // offset: 0x10
    LZ4_stream_t * fastCtx;  // offset: 0x14
    LZ4_streamHC_t * HCCtx;  // offset: 0x18
}; // size: 0x1c

struct LZ4F_CustomMem {
    LZ4F_AllocFunction customAlloc;  // offset: 0x0
    LZ4F_CallocFunction customCalloc;  // offset: 0x4
    LZ4F_FreeFunction customFree;  // offset: 0x8
    void * opaqueState;  // offset: 0xc
}; // size: 0x10

struct LZ4F_cctx_s {
    LZ4F_CustomMem cmem;  // offset: 0x0
    LZ4F_preferences_t prefs;  // offset: 0x10
    U32 version;  // offset: 0x48
    U32 cStage;  // offset: 0x4c
    LZ4F_CDict * cdict;  // offset: 0x50
    size_t maxBlockSize;  // offset: 0x54
    size_t maxBufferSize;  // offset: 0x58
    BYTE * tmpBuff;  // offset: 0x5c
    BYTE * tmpIn;  // offset: 0x60
    size_t tmpInSize;  // offset: 0x64
    U64 totalInSize;  // offset: 0x68
    XXH32_state_t xxh;  // offset: 0x70
    void * lz4CtxPtr;  // offset: 0xa0
    U16 lz4CtxAlloc;  // offset: 0xa4
    U16 lz4CtxState;  // offset: 0xa6
    LZ4F_blockCompression_t blockCompression;  // offset: 0xa8
}; // size: 0xb0

struct LZ4F_compressOptions_t {
    uint stableSrc;  // offset: 0x0
    uint reserved[3];  // offset: 0x4
}; // size: 0x10

struct LZ4F_dctx_s {
    LZ4F_CustomMem cmem;  // offset: 0x0
    LZ4F_frameInfo_t frameInfo;  // offset: 0x10
    U32 version;  // offset: 0x30
    dStage_t dStage;  // offset: 0x34
    U64 frameRemainingSize;  // offset: 0x38
    size_t maxBlockSize;  // offset: 0x40
    size_t maxBufferSize;  // offset: 0x44
    BYTE * tmpIn;  // offset: 0x48
    size_t tmpInSize;  // offset: 0x4c
    size_t tmpInTarget;  // offset: 0x50
    BYTE * tmpOutBuffer;  // offset: 0x54
    BYTE * dict;  // offset: 0x58
    size_t dictSize;  // offset: 0x5c
    BYTE * tmpOut;  // offset: 0x60
    size_t tmpOutSize;  // offset: 0x64
    size_t tmpOutStart;  // offset: 0x68
    XXH32_state_t xxh;  // offset: 0x6c
    XXH32_state_t blockChecksum;  // offset: 0x9c
    int skipChecksum;  // offset: 0xcc
    BYTE header[19];  // offset: 0xd0
}; // size: 0xe8

struct LZ4F_decompressOptions_t {
    uint stableDst;  // offset: 0x0
    uint skipChecksums;  // offset: 0x4
    uint reserved1;  // offset: 0x8
    uint reserved0;  // offset: 0xc
}; // size: 0x10

struct LZ4F_frameInfo_t {
    LZ4F_blockSizeID_t blockSizeID;  // offset: 0x0
    LZ4F_blockMode_t blockMode;  // offset: 0x4
    LZ4F_contentChecksum_t contentChecksumFlag;  // offset: 0x8
    LZ4F_frameType_t frameType;  // offset: 0xc
    ulonglong contentSize;  // offset: 0x10
    uint dictID;  // offset: 0x18
    LZ4F_blockChecksum_t blockChecksumFlag;  // offset: 0x1c
}; // size: 0x20

struct LZ4F_preferences_t {
    LZ4F_frameInfo_t frameInfo;  // offset: 0x0
    int compressionLevel;  // offset: 0x20
    uint autoFlush;  // offset: 0x24
    uint favorDecSpeed;  // offset: 0x28
    uint reserved[3];  // offset: 0x2c
}; // size: 0x38

struct LZ4HC_CCtx_internal {
    LZ4_u32 hashTable[32768];  // offset: 0x0
    LZ4_u16 chainTable[65536];  // offset: 0x20000
    LZ4_byte * end;  // offset: 0x40000
    LZ4_byte * prefixStart;  // offset: 0x40004
    LZ4_byte * dictStart;  // offset: 0x40008
    LZ4_u32 dictLimit;  // offset: 0x4000c
    LZ4_u32 lowLimit;  // offset: 0x40010
    LZ4_u32 nextToUpdate;  // offset: 0x40014
    short compressionLevel;  // offset: 0x40018
    LZ4_i8 favorDecSpeed;  // offset: 0x4001a
    LZ4_i8 dirty;  // offset: 0x4001b
    LZ4HC_CCtx_internal * dictCtx;  // offset: 0x4001c
}; // size: 0x40020

struct LZ4HC_match_t {
    int off;  // offset: 0x0
    int len;  // offset: 0x4
}; // size: 0x8

struct LZ4HC_optimal_t {
    int price;  // offset: 0x0
    int off;  // offset: 0x4
    int mlen;  // offset: 0x8
    int litlen;  // offset: 0xc
}; // size: 0x10

struct LZ4_readFile_s {
    LZ4F_dctx * dctxPtr;  // offset: 0x0
    FILE * fp;  // offset: 0x4
    LZ4_byte * srcBuf;  // offset: 0x8
    size_t srcBufNext;  // offset: 0xc
    size_t srcBufSize;  // offset: 0x10
    size_t srcBufMaxSize;  // offset: 0x14
}; // size: 0x18

struct LZ4_streamDecode_t_internal {
    LZ4_byte * externalDict;  // offset: 0x0
    LZ4_byte * prefixEnd;  // offset: 0x4
    size_t extDictSize;  // offset: 0x8
    size_t prefixSize;  // offset: 0xc
}; // size: 0x10

struct LZ4_stream_t_internal {
    LZ4_u32 hashTable[4096];  // offset: 0x0
    LZ4_byte * dictionary;  // offset: 0x4000
    LZ4_stream_t_internal * dictCtx;  // offset: 0x4004
    LZ4_u32 currentOffset;  // offset: 0x4008
    LZ4_u32 tableType;  // offset: 0x400c
    LZ4_u32 dictSize;  // offset: 0x4010
}; // size: 0x4014

struct LZ4_writeFile_s {
    LZ4F_cctx * cctxPtr;  // offset: 0x0
    FILE * fp;  // offset: 0x4
    LZ4_byte * dstBuf;  // offset: 0x8
    size_t maxWriteSize;  // offset: 0xc
    size_t dstBufMaxSize;  // offset: 0x10
    LZ4F_errorCode_t errCode;  // offset: 0x14
}; // size: 0x18

struct MD4state_st {
    uint A;  // offset: 0x0
    uint B;  // offset: 0x4
    uint C;  // offset: 0x8
    uint D;  // offset: 0xc
    uint Nl;  // offset: 0x10
    uint Nh;  // offset: 0x14
    uint data[16];  // offset: 0x18
    uint num;  // offset: 0x58
}; // size: 0x5c

struct MD5state_st {
    uint A;  // offset: 0x0
    uint B;  // offset: 0x4
    uint C;  // offset: 0x8
    uint D;  // offset: 0xc
    uint Nl;  // offset: 0x10
    uint Nh;  // offset: 0x14
    uint data[16];  // offset: 0x18
    uint num;  // offset: 0x58
}; // size: 0x5c

struct NAME_CONSTRAINTS_st {
    stack_st_GENERAL_SUBTREE * permittedSubtrees;  // offset: 0x0
    stack_st_GENERAL_SUBTREE * excludedSubtrees;  // offset: 0x4
}; // size: 0x8

struct NOTICEREF_st {
    ASN1_STRING * organization;  // offset: 0x0
    stack_st_ASN1_INTEGER * noticenos;  // offset: 0x4
}; // size: 0x8

struct Netscape_certificate_sequence {
    ASN1_OBJECT * type;  // offset: 0x0
    stack_st_X509 * certs;  // offset: 0x4
}; // size: 0x8

struct Netscape_spkac_st {
    X509_PUBKEY * pubkey;  // offset: 0x0
    ASN1_IA5STRING * challenge;  // offset: 0x4
}; // size: 0x8

struct Netscape_spki_st {
    NETSCAPE_SPKAC * spkac;  // offset: 0x0
    X509_ALGOR * sig_algor;  // offset: 0x4
    ASN1_BIT_STRING * signature;  // offset: 0x8
}; // size: 0xc

struct NoteAbiTag {
    dword namesz;  // offset: 0x0
    dword descsz;  // offset: 0x4
    dword type;  // offset: 0x8
    string name;  // offset: 0xc
    dword abiType;  // offset: 0x10
    dword requiredKernelVersion[3];  // offset: 0x14
}; // size: 0x20

struct PBE2PARAM_st {
    X509_ALGOR * keyfunc;  // offset: 0x0
    X509_ALGOR * encryption;  // offset: 0x4
}; // size: 0x8

struct PBEPARAM_st {
    ASN1_OCTET_STRING * salt;  // offset: 0x0
    ASN1_INTEGER * iter;  // offset: 0x4
}; // size: 0x8

struct PBKDF2PARAM_st {
    ASN1_TYPE * salt;  // offset: 0x0
    ASN1_INTEGER * iter;  // offset: 0x4
    ASN1_INTEGER * keylength;  // offset: 0x8
    X509_ALGOR * prf;  // offset: 0xc
}; // size: 0x10

struct PID {
    float max_limit;  // offset: 0x0
    float min_limit;  // offset: 0x4
    float target;  // offset: 0x8
    float feedback;  // offset: 0xc
    float startup_Kp;  // offset: 0x10
    float Kp;  // offset: 0x14
    float Ki;  // offset: 0x18
    float Kd;  // offset: 0x1c
    float e_0;  // offset: 0x20
    float e_1;  // offset: 0x24
    float e_2;  // offset: 0x28
}; // size: 0x2c

struct PKCS12 {
    ASN1_INTEGER * version;  // offset: 0x0
    PKCS12_MAC_DATA * mac;  // offset: 0x4
    PKCS7 * authsafes;  // offset: 0x8
}; // size: 0xc

struct PKCS12_MAC_DATA {
    X509_SIG * dinfo;  // offset: 0x0
    ASN1_OCTET_STRING * salt;  // offset: 0x4
    ASN1_INTEGER * iter;  // offset: 0x8
}; // size: 0xc

struct PKCS12_SAFEBAG {
    ASN1_OBJECT * type;  // offset: 0x0
    _union_984 value;  // offset: 0x4
    stack_st_X509_ATTRIBUTE * attrib;  // offset: 0x8
}; // size: 0xc

struct PKEY_USAGE_PERIOD_st {
    ASN1_GENERALIZEDTIME * notBefore;  // offset: 0x0
    ASN1_GENERALIZEDTIME * notAfter;  // offset: 0x4
}; // size: 0x8

struct POLICYINFO_st {
    ASN1_OBJECT * policyid;  // offset: 0x0
    stack_st_POLICYQUALINFO * qualifiers;  // offset: 0x4
}; // size: 0x8

struct POLICYQUALINFO_st {
    ASN1_OBJECT * pqualid;  // offset: 0x0
    _union_873 d;  // offset: 0x4
}; // size: 0x8

struct POLICY_CONSTRAINTS_st {
    ASN1_INTEGER * requireExplicitPolicy;  // offset: 0x0
    ASN1_INTEGER * inhibitPolicyMapping;  // offset: 0x4
}; // size: 0x8

struct POLICY_MAPPING_st {
    ASN1_OBJECT * issuerDomainPolicy;  // offset: 0x0
    ASN1_OBJECT * subjectDomainPolicy;  // offset: 0x4
}; // size: 0x8

struct PROXY_CERT_INFO_EXTENSION_st {
    ASN1_INTEGER * pcPathLengthConstraint;  // offset: 0x0
    PROXY_POLICY * proxyPolicy;  // offset: 0x4
}; // size: 0x8

struct PROXY_POLICY_st {
    ASN1_OBJECT * policyLanguage;  // offset: 0x0
    ASN1_OCTET_STRING * policy;  // offset: 0x4
}; // size: 0x8

struct RIPEMD160state_st {
    uint A;  // offset: 0x0
    uint B;  // offset: 0x4
    uint C;  // offset: 0x8
    uint D;  // offset: 0xc
    uint E;  // offset: 0x10
    uint Nl;  // offset: 0x14
    uint Nh;  // offset: 0x18
    uint data[16];  // offset: 0x1c
    uint num;  // offset: 0x5c
}; // size: 0x60

struct SHA256state_st {
    uint h[8];  // offset: 0x0
    uint Nl;  // offset: 0x20
    uint Nh;  // offset: 0x24
    uint data[16];  // offset: 0x28
    uint num;  // offset: 0x68
    uint md_len;  // offset: 0x6c
}; // size: 0x70

struct SHA512state_st {
    ulonglong h[8];  // offset: 0x0
    ulonglong Nl;  // offset: 0x40
    ulonglong Nh;  // offset: 0x48
    _union_320 u;  // offset: 0x50
    uint num;  // offset: 0xd0
    uint md_len;  // offset: 0xd4
}; // size: 0xd8

struct SHAstate_st {
    uint h0;  // offset: 0x0
    uint h1;  // offset: 0x4
    uint h2;  // offset: 0x8
    uint h3;  // offset: 0xc
    uint h4;  // offset: 0x10
    uint Nl;  // offset: 0x14
    uint Nh;  // offset: 0x18
    uint data[16];  // offset: 0x1c
    uint num;  // offset: 0x5c
}; // size: 0x60

struct SXNET_ID_st {
    ASN1_INTEGER * zone;  // offset: 0x0
    ASN1_OCTET_STRING * user;  // offset: 0x4
}; // size: 0x8

struct SXNET_st {
    ASN1_INTEGER * version;  // offset: 0x0
    stack_st_SXNETID * ids;  // offset: 0x4
}; // size: 0x8

struct Sweep_Cfg {
    int Force_Reset_Power_Mode;  // offset: 0x0
    _Bool Data_Reuse_Mode;  // offset: 0x4
    _Bool Force_PT2_Before_Sweep;  // offset: 0x5
    int Freq_Float_Percent;  // offset: 0x8
    _Bool Force_Local_Cfg_Level;  // offset: 0xc
    _Bool Force_Reset_Freq_Range;  // offset: 0xd
    int Sweep_Min_Freq;  // offset: 0x10
    int Sweep_Max_Freq;  // offset: 0x14
}; // size: 0x18

struct USERNOTICE_st {
    NOTICEREF * noticeref;  // offset: 0x0
    ASN1_STRING * exptext;  // offset: 0x4
}; // size: 0x8

struct WHIRLPOOL_CTX {
    _union_1015 H;  // offset: 0x0
    uchar data[64];  // offset: 0x40
    uint bitoff;  // offset: 0x80
    size_t bitlen[8];  // offset: 0x84
}; // size: 0xa8

struct X509V3_CONF_METHOD_st {
    _func_4287 * get_string;  // offset: 0x0
    _func_4288 * get_section;  // offset: 0x4
    _func_4289 * free_string;  // offset: 0x8
    _func_4290 * free_section;  // offset: 0xc
}; // size: 0x10

struct X509_POLICY_CACHE_st {
    // Empty structure
}; // size: 0x1

struct X509_POLICY_LEVEL_st {
    // Empty structure
}; // size: 0x1

struct X509_POLICY_NODE_st {
    // Empty structure
}; // size: 0x1

struct X509_POLICY_TREE_st {
    // Empty structure
}; // size: 0x1

struct X509_VERIFY_PARAM_st {
    char * name;  // offset: 0x0
    time_t check_time;  // offset: 0x4
    ulong inh_flags;  // offset: 0x8
    ulong flags;  // offset: 0xc
    int purpose;  // offset: 0x10
    int trust;  // offset: 0x14
    int depth;  // offset: 0x18
    stack_st_ASN1_OBJECT * policies;  // offset: 0x1c
}; // size: 0x20

struct X509_algor_st {
    ASN1_OBJECT * algorithm;  // offset: 0x0
    ASN1_TYPE * parameter;  // offset: 0x4
}; // size: 0x8

struct X509_crl_info_st {
    ASN1_INTEGER * version;  // offset: 0x0
    X509_ALGOR * sig_alg;  // offset: 0x4
    X509_NAME * issuer;  // offset: 0x8
    ASN1_TIME * lastUpdate;  // offset: 0xc
    ASN1_TIME * nextUpdate;  // offset: 0x10
    stack_st_X509_REVOKED * revoked;  // offset: 0x14
    stack_st_X509_EXTENSION * extensions;  // offset: 0x18
    ASN1_ENCODING enc;  // offset: 0x1c
}; // size: 0x28

struct X509_crl_st {
    X509_CRL_INFO * crl;  // offset: 0x0
    X509_ALGOR * sig_alg;  // offset: 0x4
    ASN1_BIT_STRING * signature;  // offset: 0x8
    int references;  // offset: 0xc
    int flags;  // offset: 0x10
    AUTHORITY_KEYID * akid;  // offset: 0x14
    ISSUING_DIST_POINT * idp;  // offset: 0x18
    int idp_flags;  // offset: 0x1c
    int idp_reasons;  // offset: 0x20
    ASN1_INTEGER * crl_number;  // offset: 0x24
    ASN1_INTEGER * base_crl_number;  // offset: 0x28
    uchar sha1_hash[20];  // offset: 0x2c
    stack_st_GENERAL_NAMES * issuers;  // offset: 0x40
    X509_CRL_METHOD * meth;  // offset: 0x44
    void * meth_data;  // offset: 0x48
}; // size: 0x4c

struct X509_extension_st {
    ASN1_OBJECT * object;  // offset: 0x0
    ASN1_BOOLEAN critical;  // offset: 0x4
    ASN1_OCTET_STRING * value;  // offset: 0x8
}; // size: 0xc

struct X509_info_st {
    X509 * x509;  // offset: 0x0
    X509_CRL * crl;  // offset: 0x4
    X509_PKEY * x_pkey;  // offset: 0x8
    EVP_CIPHER_INFO enc_cipher;  // offset: 0xc
    int enc_len;  // offset: 0x20
    char * enc_data;  // offset: 0x24
    int references;  // offset: 0x28
}; // size: 0x2c

struct X509_name_entry_st {
    ASN1_OBJECT * object;  // offset: 0x0
    ASN1_STRING * value;  // offset: 0x4
    int set;  // offset: 0x8
    int size;  // offset: 0xc
}; // size: 0x10

struct X509_name_st {
    stack_st_X509_NAME_ENTRY * entries;  // offset: 0x0
    int modified;  // offset: 0x4
    BUF_MEM * bytes;  // offset: 0x8
    uchar * canon_enc;  // offset: 0xc
    int canon_enclen;  // offset: 0x10
}; // size: 0x14

struct X509_pubkey_st {
    X509_ALGOR * algor;  // offset: 0x0
    ASN1_BIT_STRING * public_key;  // offset: 0x4
    EVP_PKEY * pkey;  // offset: 0x8
}; // size: 0xc

struct X509_req_info_st {
    ASN1_ENCODING enc;  // offset: 0x0
    ASN1_INTEGER * version;  // offset: 0xc
    X509_NAME * subject;  // offset: 0x10
    X509_PUBKEY * pubkey;  // offset: 0x14
    stack_st_X509_ATTRIBUTE * attributes;  // offset: 0x18
}; // size: 0x1c

struct X509_req_st {
    X509_REQ_INFO * req_info;  // offset: 0x0
    X509_ALGOR * sig_alg;  // offset: 0x4
    ASN1_BIT_STRING * signature;  // offset: 0x8
    int references;  // offset: 0xc
}; // size: 0x10

struct X509_sig_st {
    X509_ALGOR * algor;  // offset: 0x0
    ASN1_OCTET_STRING * digest;  // offset: 0x4
}; // size: 0x8

struct X509_val_st {
    ASN1_TIME * notBefore;  // offset: 0x0
    ASN1_TIME * notAfter;  // offset: 0x4
}; // size: 0x8

struct XXH32_canonical_t {
    uchar digest[4];  // offset: 0x0
}; // size: 0x4

struct XXH32_state_s {
    uint32_t total_len_32;  // offset: 0x0
    uint32_t large_len;  // offset: 0x4
    uint32_t v1;  // offset: 0x8
    uint32_t v2;  // offset: 0xc
    uint32_t v3;  // offset: 0x10
    uint32_t v4;  // offset: 0x14
    uint32_t mem32[4];  // offset: 0x18
    uint32_t memsize;  // offset: 0x28
    uint32_t reserved;  // offset: 0x2c
}; // size: 0x30

struct XXH64_canonical_t {
    uchar digest[8];  // offset: 0x0
}; // size: 0x8

struct XXH64_state_s {
    uint64_t total_len;  // offset: 0x0
    uint64_t v1;  // offset: 0x8
    uint64_t v2;  // offset: 0x10
    uint64_t v3;  // offset: 0x18
    uint64_t v4;  // offset: 0x20
    uint64_t mem64[4];  // offset: 0x28
    uint32_t memsize;  // offset: 0x48
    uint32_t reserved[2];  // offset: 0x4c
}; // size: 0x58

struct _IO_FILE {
    int _flags;  // offset: 0x0
    char * _IO_read_ptr;  // offset: 0x4
    char * _IO_read_end;  // offset: 0x8
    char * _IO_read_base;  // offset: 0xc
    char * _IO_write_base;  // offset: 0x10
    char * _IO_write_ptr;  // offset: 0x14
    char * _IO_write_end;  // offset: 0x18
    char * _IO_buf_base;  // offset: 0x1c
    char * _IO_buf_end;  // offset: 0x20
    char * _IO_save_base;  // offset: 0x24
    char * _IO_backup_base;  // offset: 0x28
    char * _IO_save_end;  // offset: 0x2c
    _IO_marker * _markers;  // offset: 0x30
    _IO_FILE * _chain;  // offset: 0x34
    int _fileno;  // offset: 0x38
    int _flags2;  // offset: 0x3c
    __off_t _old_offset;  // offset: 0x40
    ushort _cur_column;  // offset: 0x44
    char _vtable_offset;  // offset: 0x46
    char _shortbuf[1];  // offset: 0x47
    _IO_lock_t * _lock;  // offset: 0x48
    __off64_t _offset;  // offset: 0x50
    void * __pad1;  // offset: 0x58
    void * __pad2;  // offset: 0x5c
    void * __pad3;  // offset: 0x60
    void * __pad4;  // offset: 0x64
    size_t __pad5;  // offset: 0x68
    int _mode;  // offset: 0x6c
    char _unused2[40];  // offset: 0x70
}; // size: 0x98

struct _IO_FILE {
    int _flags;  // offset: 0x0
    char * _IO_read_ptr;  // offset: 0x4
    char * _IO_read_end;  // offset: 0x8
    char * _IO_read_base;  // offset: 0xc
    char * _IO_write_base;  // offset: 0x10
    char * _IO_write_ptr;  // offset: 0x14
    char * _IO_write_end;  // offset: 0x18
    char * _IO_buf_base;  // offset: 0x1c
    char * _IO_buf_end;  // offset: 0x20
    char * _IO_save_base;  // offset: 0x24
    char * _IO_backup_base;  // offset: 0x28
    char * _IO_save_end;  // offset: 0x2c
    _IO_marker * _markers;  // offset: 0x30
    _IO_FILE * _chain;  // offset: 0x34
    int _fileno;  // offset: 0x38
    int _flags2;  // offset: 0x3c
    __off_t _old_offset;  // offset: 0x40
    ushort _cur_column;  // offset: 0x44
    char _vtable_offset;  // offset: 0x46
    char _shortbuf[1];  // offset: 0x47
    _IO_lock_t * _lock;  // offset: 0x48
    __off64_t _offset;  // offset: 0x50
    void * __pad1;  // offset: 0x58
    void * __pad2;  // offset: 0x5c
    void * __pad3;  // offset: 0x60
    void * __pad4;  // offset: 0x64
    size_t __pad5;  // offset: 0x68
    int _mode;  // offset: 0x6c
    char _unused2[40];  // offset: 0x70
}; // size: 0x98

struct _IO_marker {
    _IO_marker * _next;  // offset: 0x0
    _IO_FILE * _sbuf;  // offset: 0x4
    int _pos;  // offset: 0x8
}; // size: 0xc

struct _IO_marker {
    _IO_marker * _next;  // offset: 0x0
    _IO_FILE * _sbuf;  // offset: 0x4
    int _pos;  // offset: 0x8
}; // size: 0xc

struct __dirstream {
    // Empty structure
}; // size: 0x1

struct __dirstream {
    // Empty structure
}; // size: 0x1

struct __pthread_internal_slist {
    __pthread_internal_slist * __next;  // offset: 0x0
}; // size: 0x4

struct __pthread_internal_slist {
    __pthread_internal_slist * __next;  // offset: 0x0
}; // size: 0x4

struct __pthread_mutex_s {
    int __lock;  // offset: 0x0
    uint __count;  // offset: 0x4
    int __owner;  // offset: 0x8
    int __kind;  // offset: 0xc
    uint __nusers;  // offset: 0x10
    anon_union_4_2_9a799d16_for___pthread_mutex_s_5 field_5;  // offset: 0x14
}; // size: 0x18

struct __pthread_mutex_s {
    int __lock;  // offset: 0x0
    uint __count;  // offset: 0x4
    int __owner;  // offset: 0x8
    int __kind;  // offset: 0xc
    uint __nusers;  // offset: 0x10
    _union_13 field_20;  // offset: 0x14
}; // size: 0x18

struct __sigset_t {
    ulong __val[32];  // offset: 0x0
}; // size: 0x80

struct __sigset_t {
    ulong __val[32];  // offset: 0x0
}; // size: 0x80

struct __va_list {
    void * __ap;  // offset: 0x0
}; // size: 0x4

struct _asic_reg_conf {
    uint32_t ccdly_sel;  // offset: 0x0
    uint32_t pwth_sel;  // offset: 0x4
    uint32_t swpf_mode;  // offset: 0x8
    uint32_t pulse_mode;  // offset: 0xc
    uint32_t clk_sel;  // offset: 0x10
    uint32_t ro_relay_en;  // offset: 0x14
    uint32_t co_relay_en;  // offset: 0x18
    uint32_t diode_vdd_mux_sel;  // offset: 0x1c
}; // size: 0x20

struct _asic_status {
    uint8_t[1280] asic_core_nonce_num[108];  // offset: 0x0
    uint16_t every_asic_got_nonce_num[108];  // offset: 0x21c00
    uint16_t every_asic_reg_ntick_nonce_num[108];  // offset: 0x21cd8
    uint16_t every_asic_reg_nonce_error_num[108];  // offset: 0x21db0
    uint16_t every_asic_reg_got_nonce_num[108];  // offset: 0x21e88
    _Bool ok_asic_list[108];  // offset: 0x21f60
    _Bool bad_asic_list[108];  // offset: 0x21fcc
    uint32_t valid_nonce_num;  // offset: 0x22038
}; // size: 0x2203c

struct _config_ctx {
    int chain;  // offset: 0x0
    int asics;  // offset: 0x4
    int domains;  // offset: 0x8
    int asics_in_domain;  // offset: 0xc
    int asic_domain_num;  // offset: 0x10
    int big_core;  // offset: 0x14
    int asic_small_cores;  // offset: 0x18
    int samll_core_num_in_big_core;  // offset: 0x1c
    int patter_num;  // offset: 0x20
    int abnormal_core;  // offset: 0x24
    int interval;  // offset: 0x28
    int freq_flex;  // offset: 0x2c
    asic_reg_conf reg;  // offset: 0x30
    test_speed.conflict speed;  // offset: 0x50
    hash_board.conflict board;  // offset: 0x58
    temp_ctx temp;  // offset: 0x98
    fan_ctx fan;  // offset: 0xa4
    test_standard.conflict standard;  // offset: 0xac
    test_ctx tests[11];  // offset: 0xbc
    int test_levels;  // offset: 0x16c
    int sweeped_res_index;  // offset: 0x170
}; // size: 0x174

struct _eeprom_data_format {
    _func_int_edf_ctx_p_uint8_t_ptr_size_t_int * load;  // offset: 0x0
    _func_uint32_t_edf_ctx_p * capability;  // offset: 0x4
    _func_int_edf_ctx_p_char_ptr_size_t_ptr * region_all_encode;  // offset: 0x8
    _func_int_edf_ctx_p_char_ptr_size_t_ptr_size_t_ptr * region_1_encode;  // offset: 0xc
    _func_int_edf_ctx_p_char_ptr_size_t_ptr_size_t_ptr * region_2_encode;  // offset: 0x10
    _func_int_edf_ctx_p_char_ptr_size_t_ptr_size_t_ptr * region_3_encode;  // offset: 0x14
    edf_u8_get version_get;  // offset: 0x18
    edf_u8_get enc_algorithm_get;  // offset: 0x1c
    edf_u8_set enc_algorithm_set;  // offset: 0x20
    edf_u8_get enc_key_version_get;  // offset: 0x24
    edf_u8_set enc_key_version_set;  // offset: 0x28
    edf_i8_array_get board_sn_get;  // offset: 0x2c
    edf_i8_array_set board_sn_set;  // offset: 0x30
    edf_i8_array_get chip_die_get;  // offset: 0x34
    edf_i8_array_set chip_die_set;  // offset: 0x38
    edf_i8_array_get chip_marking_get;  // offset: 0x3c
    edf_i8_array_set chip_marking_set;  // offset: 0x40
    edf_i8_array_get ft_version_get;  // offset: 0x44
    edf_i8_array_set ft_version_set;  // offset: 0x48
    edf_i8_array_get chip_tech_get;  // offset: 0x4c
    edf_i8_array_set chip_tech_set;  // offset: 0x50
    edf_u8_get chip_bin_get;  // offset: 0x54
    edf_u8_set chip_bin_set;  // offset: 0x58
    edf_u8_get asic_sensor_type_get;  // offset: 0x5c
    edf_u8_set asic_sensor_type_set;  // offset: 0x60
    edf_u8_array_get asic_sensor_addr_get;  // offset: 0x64
    edf_u8_array_set asic_sensor_addr_set;  // offset: 0x68
    edf_u8_get pic_sensor_type_get;  // offset: 0x6c
    edf_u8_set pic_sensor_type_set;  // offset: 0x70
    edf_u8_get pic_sensor_addr_get;  // offset: 0x74
    edf_u8_set pic_sensor_addr_set;  // offset: 0x78
    edf_u16_get pcb_version_get;  // offset: 0x7c
    edf_u16_set pcb_version_set;  // offset: 0x80
    edf_u16_get bom_version_get;  // offset: 0x84
    edf_u16_set bom_version_set;  // offset: 0x88
    edf_u8_get pt1_result_get;  // offset: 0x8c
    edf_u8_set pt1_result_set;  // offset: 0x90
    edf_u8_get pt1_count_get;  // offset: 0x94
    edf_u8_set pt1_count_set;  // offset: 0x98
    edf_u8_get pt2_result_get;  // offset: 0x9c
    edf_u8_set pt2_result_set;  // offset: 0xa0
    edf_u8_get pt2_count_get;  // offset: 0xa4
    edf_u8_set pt2_count_set;  // offset: 0xa8
    edf_i8_array_get board_name_get;  // offset: 0xac
    edf_i8_array_set board_name_set;  // offset: 0xb0
    edf_i8_array_get factory_job_get;  // offset: 0xb4
    edf_i8_array_set factory_job_set;  // offset: 0xb8
    edf_u16_get voltage_get;  // offset: 0xbc
    edf_u16_set voltage_set;  // offset: 0xc0
    edf_u16_get frequency_get;  // offset: 0xc4
    edf_u16_set frequency_set;  // offset: 0xc8
    edf_u16_get nonce_rate_get;  // offset: 0xcc
    edf_u16_set nonce_rate_set;  // offset: 0xd0
    edf_i8_get pcb_temp_in_get;  // offset: 0xd4
    edf_i8_set pcb_temp_in_set;  // offset: 0xd8
    edf_i8_get pcb_temp_out_get;  // offset: 0xdc
    edf_i8_set pcb_temp_out_set;  // offset: 0xe0
    edf_u8_get test_version_get;  // offset: 0xe4
    edf_u8_set test_version_set;  // offset: 0xe8
    edf_u8_get test_standard_get;  // offset: 0xec
    edf_u8_set test_standard_set;  // offset: 0xf0
    edf_u16_get sweep_hashrate_get;  // offset: 0xf4
    edf_u16_set sweep_hashrate_set;  // offset: 0xf8
    edf_u16_get sweep_freq_base_get;  // offset: 0xfc
    edf_u16_set sweep_freq_base_set;  // offset: 0x100
    edf_u8_get sweep_freq_step_get;  // offset: 0x104
    edf_u8_set sweep_freq_step_set;  // offset: 0x108
    edf_u8_array_get sweep_level_get;  // offset: 0x10c
    edf_u8_array_set sweep_level_set;  // offset: 0x110
    edf_u8_get sweep_result_get;  // offset: 0x114
    edf_u8_set sweep_result_set;  // offset: 0x118
    _func_void_edf_ctx_p * dump_data;  // offset: 0x11c
    _func_void_edf_ctx_p * destroy;  // offset: 0x120
    void * priv;  // offset: 0x124
}; // size: 0x128

struct _fan_ctx {
    int fan_speed;  // offset: 0x0
    int work_fan_speed;  // offset: 0x4
}; // size: 0x8

struct _hash_board {
    char asic_type[16];  // offset: 0x0
    uint32_t wait_temp;  // offset: 0x10
    sensor_ctx sensor;  // offset: 0x14
}; // size: 0x40

struct _pattern_bin {
    uchar midstate[8];  // offset: 0x0
    uint32_t nonce;  // offset: 0x8
}; // size: 0xc

struct _pattern_ops_t {
    char * type;  // offset: 0x0
    _func_int32_t_char_ptr * init;  // offset: 0x4
    _func_void * exit;  // offset: 0x8
    _func_void * clear_stats;  // offset: 0xc
    _func_void * reset;  // offset: 0x10
    _func_void_void_ptr_void_ptr * process_nonce;  // offset: 0x14
    _func_void_void_ptr_void_ptr * process_reg;  // offset: 0x18
    _func_int32_t_uint32_t_void_ptr * send_work;  // offset: 0x1c
    _func_void_ptr * get_stats;  // offset: 0x20
    _func_int32_t_uint32_t * is_unbalance_happen;  // offset: 0x24
    _func_int32_t_uint32_t * is_recv_nonce_enough;  // offset: 0x28
}; // size: 0x2c

struct _pattern_runtime_ctx {
    char * pattern_file_path;  // offset: 0x0
    void * private_data;  // offset: 0x4
    pattern_test_stats stats;  // offset: 0x8
    asic_status asic_stats;  // offset: 0x1314
    uint16_t last_succ_asic_nonce_num[108];  // offset: 0x23350
    sweep_ctx sweep;  // offset: 0x23428
    pattern_work * works[108];  // offset: 0x23478
    config_ctx * config;  // offset: 0x23628
    pattern_ops_t pt_ops;  // offset: 0x2362c
    int8_t tempval[4];  // offset: 0x23658
    uint32_t send_nonce_num;  // offset: 0x2365c
    uint32_t chain_status;  // offset: 0x23660
    uint8_t is_chain_unbalance;  // offset: 0x23664
    uint32_t recv_nonce;  // offset: 0x23668
    uint32_t read_temp;  // offset: 0x2366c
    uint32_t pause_recv_nonce;  // offset: 0x23670
    float nonce_rate;  // offset: 0x23674
}; // size: 0x23678

struct _pattern_test_stats {
    uint32_t[9] nonce_stats[108];  // offset: 0x0
    uint32_t nonce_num_asic[108];  // offset: 0xf30
    uint32_t nonce_num_chain;  // offset: 0x10e0
    uint32_t nonce_num_domain[64];  // offset: 0x10e4
    uint32_t nonce_num_domain_big[64];  // offset: 0x11e4
    uint32_t nonce_num_repeated;  // offset: 0x12e4
    uint32_t nonce_num_top_check_fail;  // offset: 0x12e8
    uint32_t nonce_num_crc_err;  // offset: 0x12ec
    uint32_t nonce_num_invalid;  // offset: 0x12f0
    uint32_t nonce_num_hw;  // offset: 0x12f4
    uint32_t nonce_num_extra;  // offset: 0x12f8
    uint32_t nonce_num_unknown_err;  // offset: 0x12fc
    uint32_t invalid_chain_num;  // offset: 0x1300
    uint32_t invalid_asic_num;  // offset: 0x1304
    float nonce_stdev;  // offset: 0x1308
}; // size: 0x130c

struct _pattern_work {
    uint32_t nonce_repeat;  // offset: 0x0
    pattern_bin pattern;  // offset: 0x4
}; // size: 0x10

struct _pitem {
    uchar priority[8];  // offset: 0x0
    void * data;  // offset: 0x8
    _pitem * next;  // offset: 0xc
}; // size: 0x10

struct _pll_conf {
    pllparameter_t pll_param;  // offset: 0x0
    uint8_t usr_divider;  // offset: 0x6
}; // size: 0x8

struct _pqueue {
    // Empty structure
}; // size: 0x1

struct _ptx_err_msg_ {
    int error_no;  // offset: 0x0
    char error_code[10];  // offset: 0x4
    char error_code_desc[20];  // offset: 0xe
}; // size: 0x24

struct _sensor_ctx {
    char senor_name[16];  // offset: 0x0
    uint32_t sensor_addr[4];  // offset: 0x10
    uint32_t sensor_i2c_addr;  // offset: 0x20
    uint32_t sensor_reg_addr;  // offset: 0x24
    int sensor_num;  // offset: 0x28
}; // size: 0x2c

struct _struct_1032 {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
}; // size: 0x8

struct _struct_1033 {
    int si_tid;  // offset: 0x0
    int si_overrun;  // offset: 0x4
    sigval_t si_sigval;  // offset: 0x8
}; // size: 0xc

struct _struct_1034 {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
    sigval_t si_sigval;  // offset: 0x8
}; // size: 0xc

struct _struct_1035 {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
    int si_status;  // offset: 0x8
    __clock_t si_utime;  // offset: 0xc
    __clock_t si_stime;  // offset: 0x10
}; // size: 0x14

struct _struct_1036 {
    void * si_addr;  // offset: 0x0
}; // size: 0x4

struct _struct_1037 {
    long si_band;  // offset: 0x0
    int si_fd;  // offset: 0x4
}; // size: 0x8

struct _struct_16 {
    int __lock;  // offset: 0x0
    uint __futex;  // offset: 0x4
    ulonglong __total_seq;  // offset: 0x8
    ulonglong __wakeup_seq;  // offset: 0x10
    ulonglong __woken_seq;  // offset: 0x18
    void * __mutex;  // offset: 0x20
    uint __nwaiters;  // offset: 0x24
    uint __broadcast_seq;  // offset: 0x28
}; // size: 0x30

struct _struct_19 {
    int __lock;  // offset: 0x0
    uint __nr_readers;  // offset: 0x4
    uint __readers_wakeup;  // offset: 0x8
    uint __writer_wakeup;  // offset: 0xc
    uint __nr_readers_queued;  // offset: 0x10
    uint __nr_writers_queued;  // offset: 0x14
    uchar __flags;  // offset: 0x18
    uchar __shared;  // offset: 0x19
    uchar __pad1;  // offset: 0x1a
    uchar __pad2;  // offset: 0x1b
    int __writer;  // offset: 0x1c
}; // size: 0x20

struct _struct_621 {
    int sess_connect;  // offset: 0x0
    int sess_connect_renegotiate;  // offset: 0x4
    int sess_connect_good;  // offset: 0x8
    int sess_accept;  // offset: 0xc
    int sess_accept_renegotiate;  // offset: 0x10
    int sess_accept_good;  // offset: 0x14
    int sess_miss;  // offset: 0x18
    int sess_timeout;  // offset: 0x1c
    int sess_cache_full;  // offset: 0x20
    int sess_hit;  // offset: 0x24
    int sess_cb_hit;  // offset: 0x28
}; // size: 0x2c

struct _struct_647 {
    uint conn_id_length;  // offset: 0x0
    uint cert_type;  // offset: 0x4
    uint cert_length;  // offset: 0x8
    uint csl;  // offset: 0xc
    uint clear;  // offset: 0x10
    uint enc;  // offset: 0x14
    uchar ccl[32];  // offset: 0x18
    uint cipher_spec_length;  // offset: 0x38
    uint session_id_length;  // offset: 0x3c
    uint clen;  // offset: 0x40
    uint rlen;  // offset: 0x44
}; // size: 0x48

struct _struct_651 {
    uchar cert_verify_md[128];  // offset: 0x0
    uchar finish_md[128];  // offset: 0x80
    int finish_md_len;  // offset: 0x100
    uchar peer_finish_md[128];  // offset: 0x104
    int peer_finish_md_len;  // offset: 0x184
    ulong message_size;  // offset: 0x188
    int message_type;  // offset: 0x18c
    SSL_CIPHER * new_cipher;  // offset: 0x190
    DH * dh;  // offset: 0x194
    EC_KEY * ecdh;  // offset: 0x198
    int next_state;  // offset: 0x19c
    int reuse_message;  // offset: 0x1a0
    int cert_req;  // offset: 0x1a4
    int ctype_num;  // offset: 0x1a8
    char ctype[9];  // offset: 0x1ac
    stack_st_X509_NAME * ca_names;  // offset: 0x1b8
    int use_rsa_tmp;  // offset: 0x1bc
    int key_block_length;  // offset: 0x1c0
    uchar * key_block;  // offset: 0x1c4
    EVP_CIPHER * new_sym_enc;  // offset: 0x1c8
    EVP_MD * new_hash;  // offset: 0x1cc
    int new_mac_pkey_type;  // offset: 0x1d0
    int new_mac_secret_size;  // offset: 0x1d4
    SSL_COMP * new_compression;  // offset: 0x1d8
    int cert_request;  // offset: 0x1dc
}; // size: 0x1e0

struct _sweep_ctx {
    uint32_t voltage;  // offset: 0x0
    uint32_t pre_open_core_voltage;  // offset: 0x4
    float range_freq[2];  // offset: 0x8
    float step;  // offset: 0x10
    float bias;  // offset: 0x14
    int eeprom_freq_step;  // offset: 0x18
    int mode;  // offset: 0x1c
    int reuse;  // offset: 0x20
    float sweep_online_min;  // offset: 0x24
    float sweep_online_max;  // offset: 0x28
    float sweep_online_avg;  // offset: 0x2c
    float sweep_online_var;  // offset: 0x30
    float sweep_online_nonce_rate;  // offset: 0x34
    uint64_t sweep_start_time;  // offset: 0x38
    uint64_t sweep_online_time;  // offset: 0x40
    uint64_t sweep_end_time;  // offset: 0x48
}; // size: 0x50

struct _temp_ctx {
    uint32_t temp_gap;  // offset: 0x0
    uint32_t wait_cool_time;  // offset: 0x4
    uint32_t cool_board_time;  // offset: 0x8
}; // size: 0xc

struct _test_ctx {
    int level;  // offset: 0x0
    int pre_open_core_voltage;  // offset: 0x4
    int voltage;  // offset: 0x8
    int freq;  // offset: 0xc
}; // size: 0x10

struct _test_speed {
    uint32_t baudrate;  // offset: 0x0
    uint32_t timeout;  // offset: 0x4
}; // size: 0x8

struct _test_standard {
    int invalid_core_num;  // offset: 0x0
    int least_nonce_per_core;  // offset: 0x4
    int asic_nonce_rate;  // offset: 0x8
    int nonce_rate;  // offset: 0xc
}; // size: 0x10

struct _work_cxt {
    uint8_t work_type;  // offset: 0x0
    uint8_t chain_id;  // offset: 0x1
    uint8_t reserved1[2];  // offset: 0x2
    uint32_t work_count;  // offset: 0x4
    uint8_t data[12];  // offset: 0x8
    uint8_t[32] midstate[16];  // offset: 0x14
}; // size: 0x214

struct addrinfo {
    int ai_flags;  // offset: 0x0
    int ai_family;  // offset: 0x4
    int ai_socktype;  // offset: 0x8
    int ai_protocol;  // offset: 0xc
    socklen_t ai_addrlen;  // offset: 0x10
    sockaddr * ai_addr;  // offset: 0x14
    char * ai_canonname;  // offset: 0x18
    addrinfo * ai_next;  // offset: 0x1c
}; // size: 0x20

struct addrinfo {
    int ai_flags;  // offset: 0x0
    int ai_family;  // offset: 0x4
    int ai_socktype;  // offset: 0x8
    int ai_protocol;  // offset: 0xc
    socklen_t ai_addrlen;  // offset: 0x10
    sockaddr * ai_addr;  // offset: 0x14
    char * ai_canonname;  // offset: 0x18
    addrinfo * ai_next;  // offset: 0x1c
}; // size: 0x20

struct aes_key_st {
    uint rd_key[60];  // offset: 0x0
    int rounds;  // offset: 0xf0
}; // size: 0xf4

struct anon_struct_12_3_5124685d_for__timer {
    int si_tid;  // offset: 0x0
    int si_overrun;  // offset: 0x4
    sigval_t si_sigval;  // offset: 0x8
}; // size: 0xc

struct anon_struct_12_3_9bedbd60_for__rt {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
    sigval_t si_sigval;  // offset: 0x8
}; // size: 0xc

struct anon_struct_12_3_fe5e7108_for__sigsys {
    void * _call_addr;  // offset: 0x0
    int _syscall;  // offset: 0x4
    uint _arch;  // offset: 0x8
}; // size: 0xc

struct anon_struct_16_11_6b887386_for_reg {
    uint32_t:4 chain_number;  // offset: 0x0
    uint32_t:2 reserved_0;  // offset: 0x0
    uint32_t:1 nonce_crc_indicator;  // offset: 0x0
    uint32_t:1 reserved_1;  // offset: 0x0
    uint32_t:8 register_address;  // offset: 0x1
    uint32_t:8 chip_address;  // offset: 0x2
    uint32_t:5 crc_value;  // offset: 0x3
    uint32_t:2 reg_type;  // offset: 0x3
    uint32_t:1 nonce_or_register_data;  // offset: 0x3
    uint32_t reg_data;  // offset: 0x4
    uint32_t reserved_2[2];  // offset: 0x8
}; // size: 0x10

struct anon_struct_16_14_521757b1_for_nonce {
    uint32_t:4 chain_number;  // offset: 0x0
    uint32_t:1 reserved_0;  // offset: 0x0
    uint32_t:1 err_flag;  // offset: 0x0
    uint32_t:1 nonce_crc_indicator;  // offset: 0x0
    uint32_t:1 nonce_indicator;  // offset: 0x0
    uint32_t:7 nonce_difficulty;  // offset: 0x1
    uint32_t:1 reserved_1;  // offset: 0x1
    uint32_t:15 work_id;  // offset: 0x2
    uint32_t:1 nonce_or_register_data;  // offset: 0x3
    uint32_t nonce;  // offset: 0x4
    uint32_t:8 reserved_2;  // offset: 0x8
    uint32_t:16 blk_version;  // offset: 0x9
    uint32_t:8 job_id;  // offset: 0xb
    uint32_t header;  // offset: 0xc
}; // size: 0x10

struct anon_struct_1_5_2d401d3c_for_u {
    uint8_t:1 _SWPF_MODE;  // offset: 0x0
    uint8_t:1 _RSVD1;  // offset: 0x0
    uint8_t:1 _RSVD2;  // offset: 0x0
    uint8_t:3 _PWTH_SEL;  // offset: 0x0
    uint8_t:2 _CCDLY_SEL;  // offset: 0x0
}; // size: 0x1

struct anon_struct_20_5_7a025f54_for__sigchld {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
    int si_status;  // offset: 0x8
    __clock_t si_utime;  // offset: 0xc
    __clock_t si_stime;  // offset: 0x10
}; // size: 0x14

struct anon_struct_2_2_c6ab8785_for_u {
    uint8_t _CORE_EN_I;  // offset: 0x0
    uint8_t _CORE_EN_N;  // offset: 0x1
}; // size: 0x2

struct anon_struct_2_2_d78050c7_for_u {
    uint16_t:5 _CLOCK_CTRL;  // offset: 0x0
    uint16_t:11 _RSVD1;  // offset: 0x0
}; // size: 0x2

struct anon_struct_2_3_d58cde66_for_u {
    uint16_t:2 _PM_SEL;  // offset: 0x0
    uint16_t:1 _PM_START;  // offset: 0x0
    uint16_t:13 _RSVD;  // offset: 0x0
}; // size: 0x2

struct anon_struct_2_3_e7583c08_for_u {
    uint16_t:8 _PULSE_WIDTH;  // offset: 0x0
    uint16_t:4 _OCV_DOUT;  // offset: 0x1
    uint16_t:4 _RSVD1;  // offset: 0x1
}; // size: 0x2

struct anon_struct_2_4_bd7cc306_for_u {
    uint16_t:1 _AUTO_CLK_EN;  // offset: 0x0
    uint16_t:4 _RSVD;  // offset: 0x0
    uint16_t:2 _MODE_MASK;  // offset: 0x0
    uint16_t:9 _RSVD1;  // offset: 0x0
}; // size: 0x2

struct anon_struct_2_4_e5384816_for_u {
    uint16_t:1 _SWPF_MODE;  // offset: 0x0
    uint16_t:2 _CLK_SEL;  // offset: 0x0
    uint16_t:1 _CLK_SEL_MASK;  // offset: 0x0
    uint16_t:12 _RSVD3;  // offset: 0x0
}; // size: 0x2

struct anon_struct_2_5_1a639049_for_u {
    uint16_t:1 _NONCE_BIN_OF_ENABLE;  // offset: 0x0
    uint16_t:1 _FAKE_NONCE;  // offset: 0x0
    uint16_t:2 _RSVD1;  // offset: 0x0
    uint16_t:1 _NONCE_BIN_OF;  // offset: 0x0
    uint16_t:11 _RSVD2;  // offset: 0x0
}; // size: 0x2

struct anon_struct_2_6_81fe2f07_for_u {
    uint16_t:1 _NONCE_BIN_OF_ENABLE;  // offset: 0x0
    uint16_t:1 _RSVD1;  // offset: 0x0
    uint16_t:1 _GOLDEN_TICKET_EN;  // offset: 0x0
    uint16_t:1 _RSVD2;  // offset: 0x0
    uint16_t:1 _NONCE_OF_STS;  // offset: 0x0
    uint16_t:11 _RSVD3;  // offset: 0x0
}; // size: 0x2

struct anon_struct_48_8_df74bd48_for___data {
    int __lock;  // offset: 0x0
    uint __futex;  // offset: 0x4
    ulonglong __total_seq;  // offset: 0x8
    ulonglong __wakeup_seq;  // offset: 0x10
    ulonglong __woken_seq;  // offset: 0x18
    void * __mutex;  // offset: 0x20
    uint __nwaiters;  // offset: 0x24
    uint __broadcast_seq;  // offset: 0x28
}; // size: 0x30

struct anon_struct_4_10_b75caf2b_for_u {
    uint32_t:8 _DATA;  // offset: 0x0
    uint32_t:8 _REG_ADDR;  // offset: 0x1
    uint32_t:1 _RW_CTRL;  // offset: 0x2
    uint32_t:7 _DEVICE_ADDR;  // offset: 0x2
    uint32_t:1 _REG_ADDR_VAILD;  // offset: 0x3
    uint32_t:1 _AUTO_READ_TEMP;  // offset: 0x3
    uint32_t:1 _AUTO_RET_TEMP;  // offset: 0x3
    uint32_t:3 _RSVD1;  // offset: 0x3
    uint32_t:1 _RW_FAIL;  // offset: 0x3
    uint32_t:1 _BUSY;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_11_bb44c716_for_u {
    uint32_t:8 _CFG0;  // offset: 0x0
    uint32_t:8 _CFGA;  // offset: 0x1
    uint32_t:1 _TS_CLK_SEL;  // offset: 0x2
    uint32_t:1 _TS_SOFT_RSTN;  // offset: 0x2
    uint32_t:6 _RSVD_1;  // offset: 0x2
    uint32_t:1 _TS_CLOAD;  // offset: 0x3
    uint32_t:3 _RSVD_2;  // offset: 0x3
    uint32_t:1 _RUN_EN;  // offset: 0x3
    uint32_t:1 _RUN_CTRL;  // offset: 0x3
    uint32_t:1 _RSVD_3;  // offset: 0x3
    uint32_t:1 _TS_PD;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_12_17032573_for_u {
    uint32_t:3 _POSTDIV2;  // offset: 0x0
    uint32_t:1 _RSVD1;  // offset: 0x0
    uint32_t:3 _POSTDIV1;  // offset: 0x0
    uint32_t:1 _RSVD2;  // offset: 0x0
    uint32_t:6 _REFDIV;  // offset: 0x1
    uint32_t:1 _CALEN;  // offset: 0x1
    uint32_t:1 _FASTCALEN;  // offset: 0x1
    uint32_t:12 _FBDIV;  // offset: 0x2
    uint32_t:1 _VCOSEL;  // offset: 0x3
    uint32_t:1 _BYPASS;  // offset: 0x3
    uint32_t:1 _PLLEN;  // offset: 0x3
    uint32_t:1 _LOCKED;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_13_422ceaf4_for_u {
    uint32_t:4 _TOP_DIV;  // offset: 0x0
    uint32_t:1 _RSVD1;  // offset: 0x0
    uint32_t:2 _TOP_ODDSET;  // offset: 0x0
    uint32_t:1 _TOPCLK_SEL;  // offset: 0x0
    uint32_t:9 _BT8D;  // offset: 0x1
    uint32_t:1 _RSVD2;  // offset: 0x2
    uint32_t:2 _USRC_ODDSET;  // offset: 0x2
    uint32_t:6 _USRC_DIV;  // offset: 0x2
    uint32_t:1 _BCLK_SEL;  // offset: 0x3
    uint32_t:2 _DSCLK_SEL;  // offset: 0x3
    uint32_t:1 _RSVD3;  // offset: 0x3
    uint32_t:1 _PDIVCLK_SEL;  // offset: 0x3
    uint32_t:1 _VCO_CLK_EN;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_18_3f3fc8fd_for_u {
    uint32_t:2 _RSVD1;  // offset: 0x0
    uint32_t:1 _FSW_CKEN;  // offset: 0x0
    uint32_t:1 _RI_DISA;  // offset: 0x0
    uint32_t:3 _RSVD2;  // offset: 0x0
    uint32_t:1 _RET_WORK_ERR_FLAG;  // offset: 0x0
    uint32_t:1 _PCE_EN;  // offset: 0x1
    uint32_t:1 _FORCE_CORE_EN;  // offset: 0x1
    uint32_t:3 _RSVD3;  // offset: 0x1
    uint32_t:1 _SOFT_INV_CLKO;  // offset: 0x1
    uint32_t:1 _RNTMO_EN;  // offset: 0x1
    uint32_t:1 _TVER_EN;  // offset: 0x1
    uint32_t:4 _RTST_M_EN;  // offset: 0x2
    uint32_t:1 _RVS_K0;  // offset: 0x2
    uint32_t:1 _SPAT_NOD;  // offset: 0x2
    uint32_t:1 _VERIFY_FIFO_FULL;  // offset: 0x2
    uint32_t:1 _CORE_SWPS;  // offset: 0x2
    uint32_t:4 _RTST_F_EN;  // offset: 0x3
    uint32_t:4 _RNO_EN;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_18_a6851311_for_u {
    uint32_t:1 _SWP_EN;  // offset: 0x0
    uint32_t:1 _SWP_TRIG;  // offset: 0x0
    uint32_t:1 _SWP_ONGOING;  // offset: 0x0
    uint32_t:1 _SWP_DONE_ALL;  // offset: 0x0
    uint32_t:3 _SWP_PAT_ADDR;  // offset: 0x0
    uint32_t:1 _SWP_ONE_PAT_DONE;  // offset: 0x0
    uint32_t:3 _CURR_PAT_ADDR;  // offset: 0x1
    uint32_t:1 _SWEEP_RESET;  // offset: 0x1
    uint32_t:1 _SWEEP_FAIL_LOCK_EN;  // offset: 0x1
    uint32_t:1 _ALL_CORE_CLK_SEL_CHANGE_ST;  // offset: 0x1
    uint32_t:2 _RSVD1;  // offset: 0x1
    uint32_t:8 _SWEEP_ST_ADDR;  // offset: 0x2
    uint32_t:3 _SWEEP_STATE;  // offset: 0x3
    uint32_t:1 _INC_DISABLE;  // offset: 0x3
    uint32_t:1 _EN_OR_MATCH_NONCES;  // offset: 0x3
    uint32_t:1 _CORE_CLK_CFG_DIS;  // offset: 0x3
    uint32_t:1 _OVERLAP_LOCK_EN;  // offset: 0x3
    uint32_t:1 _RSVD2;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_19_15a1c2d0_for_u {
    uint32_t:1 _PLL_VDD_OK;  // offset: 0x0
    uint32_t:1 _CORE_VDD_OK;  // offset: 0x0
    uint32_t:1 _PIN_MODE;  // offset: 0x0
    uint32_t:1 _TEST;  // offset: 0x0
    uint32_t:1 _P_CORE_EN;  // offset: 0x0
    uint32_t:1 _POR_EN;  // offset: 0x0
    uint32_t:1 _INV_CLKO;  // offset: 0x0
    uint32_t:1 _ADDR3;  // offset: 0x0
    uint32_t:4 _RI_CNT;  // offset: 0x1
    uint32_t:4 _BI_CNT;  // offset: 0x1
    uint32_t:1 _NRSTI_OK;  // offset: 0x2
    uint32_t:1 _NRSTI_PAD_OK;  // offset: 0x2
    uint32_t:2 _ADDR;  // offset: 0x2
    uint32_t:4 _DOMAIN_VDD_OK;  // offset: 0x2
    uint32_t:1 _FREE_POR_GLITCH;  // offset: 0x3
    uint32_t:1 _POR_GLITCH;  // offset: 0x3
    uint32_t:1 _NRSTI_GLITCH;  // offset: 0x3
    uint32_t:1 _RSVD2;  // offset: 0x3
    uint32_t:4 _CHECK_BEGIN;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_1_397754f6_for_u {
    uint32_t _tick_nonce_cnt;  // offset: 0x0
}; // size: 0x4

struct anon_struct_4_1_413bbfcc_for_u {
    uint32_t _ROSC_DIS_DATA;  // offset: 0x0
}; // size: 0x4

struct anon_struct_4_2_84162d83_for_u {
    uint32_t:4 _ANA_MUX_SEL;  // offset: 0x0
    uint32_t:28 _RSVD1;  // offset: 0x0
}; // size: 0x4

struct anon_struct_4_2_9e97f829_for_u {
    uint16_t _RETURN_NONCE_CNT;  // offset: 0x0
    uint16_t _RETURN_NONCE_CNT_MATCH;  // offset: 0x2
}; // size: 0x4

struct anon_struct_4_3_30b46c24_for_u2 {
    uint32_t:9 _DATA;  // offset: 0x0
    uint32_t:16 _CHIP_NONCE_OFFSET;  // offset: 0x1
    uint32_t:7 _CORE_ID;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_3_4f6a2092_for_u {
    uint32_t:17 _DATA;  // offset: 0x0
    uint32_t:8 _CHIP_ADDR;  // offset: 0x2
    uint32_t:7 _CORE_ID;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_3_759a448f_for_u {
    uint16_t _CNO;  // offset: 0x0
    uint16_t:15 _RSVD1;  // offset: 0x2
    uint16_t:1 _CNOV;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_3_b0bb6857_for_u {
    uint32_t:2 _CLK_EN;  // offset: 0x0
    uint32_t:29 _RSVD;  // offset: 0x0
    uint32_t:1 _CLK_SEL;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_4_08564e81_for_u {
    uint8_t _TM0;  // offset: 0x0
    uint8_t _TM1;  // offset: 0x1
    uint8_t _TM2;  // offset: 0x2
    uint8_t _TM3;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_4_a1dac117_for_u {
    uint32_t:2 _CORE_CLK_MODE_SEL;  // offset: 0x0
    uint32_t:1 _CLK_MODE_MARGIN;  // offset: 0x0
    uint32_t:1 _CORE_NUM_DEC_LOCK_EN;  // offset: 0x0
    uint32_t:28 _RSVD;  // offset: 0x0
}; // size: 0x4

struct anon_struct_4_5_399a9cf7_for_u {
    uint32_t:16 _VER_MASK;  // offset: 0x0
    uint32_t:12 _RSVD1;  // offset: 0x2
    uint32_t:2 _MIDSX_GEN;  // offset: 0x3
    uint32_t:1 _VER_FIX;  // offset: 0x3
    uint32_t:1 _MID_AUTO_GEN;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_5_b8274f34_for_u {
    uint32_t:1 _CO_RELAY_EN;  // offset: 0x0
    uint32_t:1 _RO_RELAY_EN;  // offset: 0x0
    uint32_t:1 _NONCE_GAP_EN;  // offset: 0x0
    uint32_t:13 _RSVD1;  // offset: 0x0
    uint32_t:16 _GAP_CNT;  // offset: 0x2
}; // size: 0x4

struct anon_struct_4_8_6d10a169_for_u {
    uint32_t:8 _REG_WDATA;  // offset: 0x0
    uint32_t:5 _REG_ADDR;  // offset: 0x1
    uint32_t:1 _RSVD1;  // offset: 0x1
    uint32_t:1 _RW_DONE;  // offset: 0x1
    uint32_t:1 _REG_WRITE;  // offset: 0x1
    uint32_t:8 _CORE_ID;  // offset: 0x2
    uint32_t:7 _NUM;  // offset: 0x3
    uint32_t:1 _ALL;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_8_ad5e9fc5_for_u {
    uint32_t:6 bt8d_c0;  // offset: 0x0
    uint32_t:2 reserved_0;  // offset: 0x0
    uint32_t:6 bt8d_c1;  // offset: 0x1
    uint32_t:2 reserved_1;  // offset: 0x1
    uint32_t:6 bt8d_c2;  // offset: 0x2
    uint32_t:2 reserved_2;  // offset: 0x2
    uint32_t:6 bt8d_c3;  // offset: 0x3
    uint32_t:2 reserved_3;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_8_bac425d5_for_u {
    uint32_t:4 _CO_DS;  // offset: 0x0
    uint32_t:4 _BO_DS;  // offset: 0x0
    uint32_t:4 _NRSTO_DS;  // offset: 0x1
    uint32_t:4 _CLKO_DS;  // offset: 0x1
    uint32_t:4 _R0_DS;  // offset: 0x2
    uint32_t:4 _RSVD0;  // offset: 0x2
    uint32_t:4 _RSVD1;  // offset: 0x3
    uint32_t:4 _RSVD2;  // offset: 0x3
}; // size: 0x4

struct anon_struct_4_8_fb3c3b36_for_u {
    uint32_t:4 _CORE_SRST;  // offset: 0x0
    uint32_t:4 _CORE_SRST_FAST;  // offset: 0x0
    uint32_t:1 _TVER_RESET;  // offset: 0x1
    uint32_t:1 _TOPCRTL_RESET;  // offset: 0x1
    uint32_t:1 _CHIP_RESET;  // offset: 0x1
    uint32_t:5 _RSVD;  // offset: 0x1
    uint32_t:8 _SRST_TIME;  // offset: 0x2
    uint32_t:8 _RSVD1;  // offset: 0x3
}; // size: 0x4

struct anon_struct_5_8_110e986d_for_u {
    uint8_t:4 _CMD;  // offset: 0x0
    uint8_t:1 _ALL;  // offset: 0x0
    uint8_t:3 _TYPE;  // offset: 0x0
    uint8_t _Length;  // offset: 0x1
    uint8_t _ADDR;  // offset: 0x2
    uint8_t _RSVD1;  // offset: 0x3
    uint8_t:5 _CRC5;  // offset: 0x4
    uint8_t:3 _RSVD2;  // offset: 0x4
}; // size: 0x5

struct anon_struct_5_8_15bfd022_for_u {
    uint8_t:4 _CMD;  // offset: 0x0
    uint8_t:1 _ALL;  // offset: 0x0
    uint8_t:3 _TYPE;  // offset: 0x0
    uint8_t _Length;  // offset: 0x1
    uint8_t _RSVD1;  // offset: 0x2
    uint8_t _RSVD2;  // offset: 0x3
    uint8_t:5 _CRC5;  // offset: 0x4
    uint8_t:3 _RSVD3;  // offset: 0x4
}; // size: 0x5

struct anon_struct_5_9_f9e27364_for_u {
    uint8_t:4 _CMD;  // offset: 0x0
    uint8_t:1 _ALL;  // offset: 0x0
    uint8_t:3 _TYPE;  // offset: 0x0
    uint8_t _Length;  // offset: 0x1
    uint8_t _ADDR;  // offset: 0x2
    uint8_t _REGADDR;  // offset: 0x3
    uint8_t:5 _CRC5;  // offset: 0x4
    uint8_t:2 _CMD_ID_G;  // offset: 0x4
    uint8_t:1 _RSVD;  // offset: 0x4
}; // size: 0x5

struct anon_struct_8_2_0a3d7222_for__kill {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_43e888f9_for_string {
    char * val;  // offset: 0x0
    size_t len;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_686959ae_for__sigpoll {
    long si_band;  // offset: 0x0
    int si_fd;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_895adaa1_for__sigfault {
    void * si_addr;  // offset: 0x0
    short si_addr_lsb;  // offset: 0x4
}; // size: 0x8

struct anon_struct_9_9_23b62a12_for_u {
    uint8_t:4 _CMD;  // offset: 0x0
    uint8_t:1 _ALL;  // offset: 0x0
    uint8_t:3 _TYPE;  // offset: 0x0
    uint8_t _Length;  // offset: 0x1
    uint8_t _ADDR;  // offset: 0x2
    uint8_t _REGADDR;  // offset: 0x3
    uint8_t _REGDATA[4];  // offset: 0x4
    uint8_t:5 _CRC5;  // offset: 0x8
    uint8_t:3 _RSVD;  // offset: 0x8
}; // size: 0x9

struct asic_register {
    uint32_t CCdly_Sel;  // offset: 0x0
    uint32_t Pwth_Sel;  // offset: 0x4
    uint32_t Swpf_Mode;  // offset: 0x8
    uint32_t Pulse_Mode;  // offset: 0xc
    uint32_t Clk_Sel;  // offset: 0x10
    uint32_t RO_Relay_En;  // offset: 0x14
    uint32_t CO_Relay_En;  // offset: 0x18
    uint32_t Diode_Vdd_Mux_Sel;  // offset: 0x1c
}; // size: 0x20

struct asic_register_value_t {
    uint32_t register_addr;  // offset: 0x0
    uint32_t register_value;  // offset: 0x4
}; // size: 0x8

struct asic_val_t {
    double max_asic_val;  // offset: 0x0
    double min_asic_val;  // offset: 0x8
    double avg_asic_val;  // offset: 0x10
    double asic_val[108];  // offset: 0x18
    int read_succ_size;  // offset: 0x378
    uint8_t asic_val_readover[108];  // offset: 0x37c
    int idx;  // offset: 0x3e8
}; // size: 0x3f0

struct asn1_object_st {
    char * sn;  // offset: 0x0
    char * * ln;  // offset: 0x4
    int nid;  // offset: 0x8
    int length;  // offset: 0xc
    uchar * data;  // offset: 0x10
    int flags;  // offset: 0x14
}; // size: 0x18

struct asn1_pctx_st {
    // Empty structure
}; // size: 0x1

struct asn1_string_st {
    int length;  // offset: 0x0
    int type;  // offset: 0x4
    uchar * data;  // offset: 0x8
    long flags;  // offset: 0xc
}; // size: 0x10

struct asn1_string_table_st {
    int nid;  // offset: 0x0
    long minsize;  // offset: 0x4
    long maxsize;  // offset: 0x8
    ulong mask;  // offset: 0xc
    ulong flags;  // offset: 0x10
}; // size: 0x14

struct asn1_type_st {
    int type;  // offset: 0x0
    _union_263 value;  // offset: 0x4
}; // size: 0x8

struct bf_key_st {
    uint P[18];  // offset: 0x0
    uint S[1024];  // offset: 0x48
}; // size: 0x1048

struct bignum_ctx {
    // Empty structure
}; // size: 0x1

struct bignum_st {
    ulong * d;  // offset: 0x0
    int top;  // offset: 0x4
    int dmax;  // offset: 0x8
    int neg;  // offset: 0xc
    int flags;  // offset: 0x10
}; // size: 0x14

struct bio_method_st {
    int type;  // offset: 0x0
    char * name;  // offset: 0x4
    _func_737 * bwrite;  // offset: 0x8
    _func_738 * bread;  // offset: 0xc
    _func_739 * bputs;  // offset: 0x10
    _func_740 * bgets;  // offset: 0x14
    _func_741 * ctrl;  // offset: 0x18
    _func_742 * create;  // offset: 0x1c
    _func_743 * destroy;  // offset: 0x20
    _func_744 * callback_ctrl;  // offset: 0x24
}; // size: 0x28

struct bio_st {
    BIO_METHOD * method;  // offset: 0x0
    _func_745 * callback;  // offset: 0x4
    char * cb_arg;  // offset: 0x8
    int init;  // offset: 0xc
    int shutdown;  // offset: 0x10
    int flags;  // offset: 0x14
    int retry_reason;  // offset: 0x18
    int num;  // offset: 0x1c
    void * ptr;  // offset: 0x20
    bio_st * next_bio;  // offset: 0x24
    bio_st * prev_bio;  // offset: 0x28
    int references;  // offset: 0x2c
    ulong num_read;  // offset: 0x30
    ulong num_write;  // offset: 0x34
    CRYPTO_EX_DATA ex_data;  // offset: 0x38
}; // size: 0x40

struct bitmain_board_t {
    uint32_t board_id;  // offset: 0x0
    uint32_t chain_num;  // offset: 0x4
    bitmain_chain_t chain[16];  // offset: 0x8
}; // size: 0x48

struct bitmain_chain_t {
    uint32_t chain_id;  // offset: 0x0
}; // size: 0x4

struct bitmain_chain_tsensor {
    uint8_t num;  // offset: 0x0
    bitmain_tsensor_t bitmain_tsensor[8];  // offset: 0x4
}; // size: 0x44

struct bitmain_eeprom_t {
    uint32_t eeprom_fd;  // offset: 0x0
    uint32_t chain_has_opened;  // offset: 0x4
}; // size: 0x8

struct bitmain_mac_t {
    uint8_t mac[6];  // offset: 0x0
}; // size: 0x6

struct bitmain_pic_t {
    uint32_t pic_fd;  // offset: 0x0
    uint32_t chain_has_opened;  // offset: 0x4
}; // size: 0x8

struct bitmain_power_t {
    uint32_t power_fd;  // offset: 0x0
    uint32_t power_open;  // offset: 0x4
    uint32_t power_version;  // offset: 0x8
    uint32_t power_fw_version;  // offset: 0xc
    _Bool power_Calibrated;  // offset: 0x10
    eeprom_data_t eeprom;  // offset: 0x18
}; // size: 0x178

struct bitmain_sys_capability_t {
    uint32_t board_num;  // offset: 0x0
    bitmain_board_t board[4];  // offset: 0x4
}; // size: 0x124

struct bitmain_tsensor_t {
    uint8_t slave_addr;  // offset: 0x0
    uint32_t tsensor_fd;  // offset: 0x4
}; // size: 0x8

struct bitmain_uuid_t {
    uint8_t uuid[16];  // offset: 0x0
}; // size: 0x10

struct bn_blinding_st {
    // Empty structure
}; // size: 0x1

struct bn_gencb_st {
    uint ver;  // offset: 0x0
    void * arg;  // offset: 0x4
    _union_181 cb;  // offset: 0x8
}; // size: 0xc

struct bn_mont_ctx_st {
    int ri;  // offset: 0x0
    BIGNUM RR;  // offset: 0x4
    BIGNUM N;  // offset: 0x18
    BIGNUM Ni;  // offset: 0x2c
    ulong n0[2];  // offset: 0x40
    int flags;  // offset: 0x48
}; // size: 0x4c

struct bn_recp_ctx_st {
    BIGNUM N;  // offset: 0x0
    BIGNUM Nr;  // offset: 0x14
    int num_bits;  // offset: 0x28
    int shift;  // offset: 0x2c
    int flags;  // offset: 0x30
}; // size: 0x34

struct buf_mem_st {
    size_t length;  // offset: 0x0
    char * data;  // offset: 0x4
    size_t max;  // offset: 0x8
}; // size: 0xc

struct buffer {
    size_t size;  // offset: 0x0
    size_t used;  // offset: 0x4
    char * data;  // offset: 0x8
}; // size: 0xc

struct buffer_data_t {
    char * data;  // offset: 0x0
    size_t len;  // offset: 0x4
    size_t pos;  // offset: 0x8
}; // size: 0xc

struct cParams_t {
    lz4hc_strat_e strat;  // offset: 0x0
    int nbSearches;  // offset: 0x4
    U32 targetLength;  // offset: 0x8
}; // size: 0xc

struct callback_data_t {
    char data[1024];  // offset: 0x0
    size_t len;  // offset: 0x400
    size_t pos;  // offset: 0x404
    json_load_callback_t callback;  // offset: 0x408
    void * arg;  // offset: 0x40c
}; // size: 0x410

struct camellia_key_st {
    _union_721 u;  // offset: 0x0
    int grand_rounds;  // offset: 0x110
}; // size: 0x118

struct cast_key_st {
    uint data[32];  // offset: 0x0
    int short_key;  // offset: 0x80
}; // size: 0x84

struct cert_st {
    // Empty structure
}; // size: 0x1

struct chain_conf_info {
    uint32_t chain_id;  // offset: 0x0
    uint32_t uart_index;  // offset: 0x4
    uint32_t plug;  // offset: 0x8
    uint32_t reset;  // offset: 0xc
}; // size: 0x10

struct cisco_proto {
    uint interval;  // offset: 0x0
    uint timeout;  // offset: 0x4
}; // size: 0x8

struct clib_deque {
    clib_object * * pElements;  // offset: 0x0
    int no_max_elements;  // offset: 0x4
    int head;  // offset: 0x8
    int tail;  // offset: 0xc
    int no_of_elements;  // offset: 0x10
    clib_compare compare_fn;  // offset: 0x14
    clib_destroy destruct_fn;  // offset: 0x18
}; // size: 0x1c

struct clib_iterator {
    _func_clib_object_ptr_clib_iterator_ptr * get_next;  // offset: 0x0
    _func_void_clib_iterator_ptr_void_ptr_size_t * replace_value;  // offset: 0x4
    _func_void_ptr_void_ptr * get_value;  // offset: 0x8
    void * pContainer;  // offset: 0xc
    int pCurrent;  // offset: 0x10
    void * pCurrentElement;  // offset: 0x14
}; // size: 0x18

struct clib_map {
    clib_rb * root;  // offset: 0x0
}; // size: 0x4

struct clib_object {
    void * raw_data;  // offset: 0x0
    size_t size;  // offset: 0x4
}; // size: 0x8

struct clib_rb {
    clib_rb_node * root;  // offset: 0x0
    clib_rb_node sentinel;  // offset: 0x4
    clib_destroy destruct_k_fn;  // offset: 0x1c
    clib_destroy destruct_v_fn;  // offset: 0x20
    clib_compare compare_fn;  // offset: 0x24
}; // size: 0x28

struct clib_rb_node {
    clib_rb_node * left;  // offset: 0x0
    clib_rb_node * right;  // offset: 0x4
    clib_rb_node * parent;  // offset: 0x8
    int color;  // offset: 0xc
    clib_object * key;  // offset: 0x10
    clib_object * value;  // offset: 0x14
}; // size: 0x18

struct comp_ctx_st {
    COMP_METHOD * meth;  // offset: 0x0
    ulong compress_in;  // offset: 0x4
    ulong compress_out;  // offset: 0x8
    ulong expand_in;  // offset: 0xc
    ulong expand_out;  // offset: 0x10
    CRYPTO_EX_DATA ex_data;  // offset: 0x14
}; // size: 0x1c

struct comp_method_st {
    int type;  // offset: 0x0
    char * name;  // offset: 0x4
    _func_711 * init;  // offset: 0x8
    _func_712 * finish;  // offset: 0xc
    _func_713 * compress;  // offset: 0x10
    _func_714 * expand;  // offset: 0x14
    _func_715 * ctrl;  // offset: 0x18
    _func_716 * callback_ctrl;  // offset: 0x1c
}; // size: 0x20

struct conf_imodule_st {
    // Empty structure
}; // size: 0x1

struct conf_method_st {
    char * name;  // offset: 0x0
    _func_3806 * create;  // offset: 0x4
    _func_3807 * init;  // offset: 0x8
    _func_3808 * destroy;  // offset: 0xc
    _func_3809 * destroy_data;  // offset: 0x10
    _func_3810 * load_bio;  // offset: 0x14
    _func_3811 * dump;  // offset: 0x18
    _func_3812 * is_number;  // offset: 0x1c
    _func_3813 * to_int;  // offset: 0x20
    _func_3814 * load;  // offset: 0x24
}; // size: 0x28

struct conf_module_st {
    // Empty structure
}; // size: 0x1

struct conf_st {
    CONF_METHOD * meth;  // offset: 0x0
    void * meth_data;  // offset: 0x4
    lhash_st_CONF_VALUE * data;  // offset: 0x8
}; // size: 0xc

struct crypto_ex_data_st {
    stack_st_void * sk;  // offset: 0x0
    int dummy;  // offset: 0x4
}; // size: 0x8

struct crypto_threadid_st {
    void * ptr;  // offset: 0x0
    ulong val;  // offset: 0x4
}; // size: 0x8

struct ctrlboard_sensor {
    char CtrlBoard_Sensor_Model[16];  // offset: 0x0
    uint32_t trlBoard_Sensor_Addr[2];  // offset: 0x10
}; // size: 0x18

struct dh_method {
    char * name;  // offset: 0x0
    _func_1843 * generate_key;  // offset: 0x4
    _func_1844 * compute_key;  // offset: 0x8
    _func_1845 * bn_mod_exp;  // offset: 0xc
    _func_1846 * init;  // offset: 0x10
    _func_1847 * finish;  // offset: 0x14
    int flags;  // offset: 0x18
    char * app_data;  // offset: 0x1c
    _func_1848 * generate_params;  // offset: 0x20
}; // size: 0x24

struct dh_st {
    int pad;  // offset: 0x0
    int version;  // offset: 0x4
    BIGNUM * p;  // offset: 0x8
    BIGNUM * g;  // offset: 0xc
    long length;  // offset: 0x10
    BIGNUM * pub_key;  // offset: 0x14
    BIGNUM * priv_key;  // offset: 0x18
    int flags;  // offset: 0x1c
    BN_MONT_CTX * method_mont_p;  // offset: 0x20
    BIGNUM * q;  // offset: 0x24
    BIGNUM * j;  // offset: 0x28
    uchar * seed;  // offset: 0x2c
    int seedlen;  // offset: 0x30
    BIGNUM * counter;  // offset: 0x34
    int references;  // offset: 0x38
    CRYPTO_EX_DATA ex_data;  // offset: 0x3c
    DH_METHOD * meth;  // offset: 0x44
    ENGINE * engine;  // offset: 0x48
}; // size: 0x4c

struct dhash_job_info_t {
    uint32_t mid_auto_gen;  // offset: 0x0
    uint32_t mid_state_num;  // offset: 0x4
    uint8_t * coinbase;  // offset: 0x8
    uint32_t coinbase_len;  // offset: 0xc
    uint8_t * merkle_bin;  // offset: 0x10
    uint32_t merkles_num;  // offset: 0x14
    uint32_t ntime;  // offset: 0x18
    uint32_t nbit;  // offset: 0x1c
    uint32_t job_id;  // offset: 0x20
    uint32_t bbversion;  // offset: 0x24
    uint32_t version_mask;  // offset: 0x28
    uint8_t * prev_hash;  // offset: 0x2c
    uint32_t prev_hash_len;  // offset: 0x30
    uint32_t nonce2_offset;  // offset: 0x34
    uint32_t nonce2_bytes_num;  // offset: 0x38
    uint64_t nonce2_start_value;  // offset: 0x40
    uint32_t send_work_timeout;  // offset: 0x48
    uint32_t new_block;  // offset: 0x4c
}; // size: 0x50

struct dirent {
    __ino_t d_ino;  // offset: 0x0
    __off_t d_off;  // offset: 0x4
    ushort d_reclen;  // offset: 0x8
    uchar d_type;  // offset: 0xa
    char d_name[256];  // offset: 0xb
}; // size: 0x10c

struct dirent {
    __ino_t d_ino;  // offset: 0x0
    __off_t d_off;  // offset: 0x4
    ushort d_reclen;  // offset: 0x8
    uchar d_type;  // offset: 0xa
    char d_name[256];  // offset: 0xb
}; // size: 0x10c

struct display {
    _Bool Display_result_Voltage_Domain;  // offset: 0x0
    _Bool Display_result_Every_Core;  // offset: 0x1
}; // size: 0x2

struct dsa_method {
    char * name;  // offset: 0x0
    _func_1875 * dsa_do_sign;  // offset: 0x4
    _func_1876 * dsa_sign_setup;  // offset: 0x8
    _func_1877 * dsa_do_verify;  // offset: 0xc
    _func_1878 * dsa_mod_exp;  // offset: 0x10
    _func_1879 * bn_mod_exp;  // offset: 0x14
    _func_1880 * init;  // offset: 0x18
    _func_1881 * finish;  // offset: 0x1c
    int flags;  // offset: 0x20
    char * app_data;  // offset: 0x24
    _func_1882 * dsa_paramgen;  // offset: 0x28
    _func_1883 * dsa_keygen;  // offset: 0x2c
}; // size: 0x30

struct dsa_st {
    int pad;  // offset: 0x0
    long version;  // offset: 0x4
    int write_params;  // offset: 0x8
    BIGNUM * p;  // offset: 0xc
    BIGNUM * q;  // offset: 0x10
    BIGNUM * g;  // offset: 0x14
    BIGNUM * pub_key;  // offset: 0x18
    BIGNUM * priv_key;  // offset: 0x1c
    BIGNUM * kinv;  // offset: 0x20
    BIGNUM * r;  // offset: 0x24
    int flags;  // offset: 0x28
    BN_MONT_CTX * method_mont_p;  // offset: 0x2c
    int references;  // offset: 0x30
    CRYPTO_EX_DATA ex_data;  // offset: 0x34
    DSA_METHOD * meth;  // offset: 0x3c
    ENGINE * engine;  // offset: 0x40
}; // size: 0x44

struct dso_meth_st {
    char * name;  // offset: 0x0
    _func_3874 * dso_load;  // offset: 0x4
    _func_3875 * dso_unload;  // offset: 0x8
    _func_3876 * dso_bind_var;  // offset: 0xc
    _func_3877 * dso_bind_func;  // offset: 0x10
    _func_3878 * dso_ctrl;  // offset: 0x14
    DSO_NAME_CONVERTER_FUNC dso_name_converter;  // offset: 0x18
    DSO_MERGER_FUNC dso_merger;  // offset: 0x1c
    _func_3879 * init;  // offset: 0x20
    _func_3880 * finish;  // offset: 0x24
    _func_3881 * pathbyaddr;  // offset: 0x28
    _func_3882 * globallookup;  // offset: 0x2c
}; // size: 0x30

struct dso_st {
    DSO_METHOD * meth;  // offset: 0x0
    stack_st_void * meth_data;  // offset: 0x4
    int references;  // offset: 0x8
    int flags;  // offset: 0xc
    CRYPTO_EX_DATA ex_data;  // offset: 0x10
    DSO_NAME_CONVERTER_FUNC name_converter;  // offset: 0x18
    DSO_MERGER_FUNC merger;  // offset: 0x1c
    char * filename;  // offset: 0x20
    char * loaded_filename;  // offset: 0x24
}; // size: 0x28

struct dtls1_bitmap_st {
    ulong map;  // offset: 0x0
    uchar max_seq_num[8];  // offset: 0x4
}; // size: 0xc

struct dtls1_retransmit_state {
    EVP_CIPHER_CTX * enc_write_ctx;  // offset: 0x0
    EVP_MD_CTX * write_hash;  // offset: 0x4
    COMP_CTX * compress;  // offset: 0x8
    SSL_SESSION * session;  // offset: 0xc
    ushort epoch;  // offset: 0x10
}; // size: 0x14

struct dtls1_state_st {
    uint send_cookie;  // offset: 0x0
    uchar cookie[256];  // offset: 0x4
    uchar rcvd_cookie[256];  // offset: 0x104
    uint cookie_len;  // offset: 0x204
    ushort r_epoch;  // offset: 0x208
    ushort w_epoch;  // offset: 0x20a
    DTLS1_BITMAP bitmap;  // offset: 0x20c
    DTLS1_BITMAP next_bitmap;  // offset: 0x218
    ushort handshake_write_seq;  // offset: 0x224
    ushort next_handshake_write_seq;  // offset: 0x226
    ushort handshake_read_seq;  // offset: 0x228
    uchar last_write_sequence[8];  // offset: 0x22a
    record_pqueue unprocessed_rcds;  // offset: 0x234
    record_pqueue processed_rcds;  // offset: 0x23c
    pqueue buffered_messages;  // offset: 0x244
    pqueue sent_messages;  // offset: 0x248
    record_pqueue buffered_app_data;  // offset: 0x24c
    uint mtu;  // offset: 0x254
    hm_header_st w_msg_hdr;  // offset: 0x258
    hm_header_st r_msg_hdr;  // offset: 0x284
    dtls1_timeout_st timeout;  // offset: 0x2b0
    timeval next_timeout;  // offset: 0x2bc
    ushort timeout_duration;  // offset: 0x2c4
    uchar alert_fragment[2];  // offset: 0x2c6
    uint alert_fragment_len;  // offset: 0x2c8
    uchar handshake_fragment[12];  // offset: 0x2cc
    uint handshake_fragment_len;  // offset: 0x2d8
    uint retransmitting;  // offset: 0x2dc
    uint change_cipher_spec_ok;  // offset: 0x2e0
    uint listen;  // offset: 0x2e4
}; // size: 0x2e8

struct dtls1_timeout_st {
    uint read_timeouts;  // offset: 0x0
    uint write_timeouts;  // offset: 0x4
    uint num_alerts;  // offset: 0x8
}; // size: 0xc

struct ec_group_st {
    // Empty structure
}; // size: 0x1

struct ec_key_st {
    // Empty structure
}; // size: 0x1

struct ec_method_st {
    // Empty structure
}; // size: 0x1

struct ec_point_st {
    // Empty structure
}; // size: 0x1

struct edf_v4_priv {
    uint8_t board_info_version;  // offset: 0x0
    uint8_t algorithm_and_key_version;  // offset: 0x1
    uint8_t board_sn[18];  // offset: 0x2
    uint8_t chip_die[3];  // offset: 0x14
    uint8_t chip_marking[14];  // offset: 0x17
    uint8_t chip_bin;  // offset: 0x25
    uint8_t ft_version[10];  // offset: 0x26
    uint16_t pcb_version;  // offset: 0x30
    uint16_t bom_version;  // offset: 0x32
    uint8_t asic_sensor_type;  // offset: 0x34
    uint8_t asic_sensor_addr[4];  // offset: 0x35
    uint8_t pic_sensor_type;  // offset: 0x39
    uint8_t pic_sensor_addr;  // offset: 0x3a
    uint8_t chip_tech[3];  // offset: 0x3b
    char board_name[9];  // offset: 0x3e
    uint8_t factory_job[24];  // offset: 0x47
    uint8_t pt1_result;  // offset: 0x5f
    uint8_t pt1_count;  // offset: 0x60
    uint8_t board_info_crc;  // offset: 0x61
    uint16_t voltage;  // offset: 0x62
    uint16_t frequency;  // offset: 0x64
    uint16_t nonce_rate;  // offset: 0x66
    int8_t pcb_temp_in;  // offset: 0x68
    int8_t pcb_temp_out;  // offset: 0x69
    uint8_t test_version;  // offset: 0x6a
    uint8_t test_standard;  // offset: 0x6b
    uint8_t pt2_result;  // offset: 0x6c
    uint8_t pt2_count;  // offset: 0x6d
    char data_padding2[3];  // offset: 0x6e
    uint8_t param_info_crc;  // offset: 0x71
}; // size: 0x72

struct edf_v5_priv {
    uint8_t board_info_version;  // offset: 0x0
    uint8_t algorithm_and_key_version;  // offset: 0x1
    uint8_t board_sn[18];  // offset: 0x2
    uint8_t chip_die[3];  // offset: 0x14
    uint8_t chip_marking[14];  // offset: 0x17
    uint8_t chip_bin;  // offset: 0x25
    uint8_t ft_version[10];  // offset: 0x26
    uint16_t pcb_version;  // offset: 0x30
    uint16_t bom_version;  // offset: 0x32
    uint8_t asic_sensor_type;  // offset: 0x34
    uint8_t asic_sensor_addr[4];  // offset: 0x35
    uint8_t pic_sensor_type;  // offset: 0x39
    uint8_t pic_sensor_addr;  // offset: 0x3a
    uint8_t chip_tech[3];  // offset: 0x3b
    char board_name[9];  // offset: 0x3e
    uint8_t factory_job[24];  // offset: 0x47
    uint8_t pt1_result;  // offset: 0x5f
    uint8_t pt1_count;  // offset: 0x60
    uint8_t board_info_crc;  // offset: 0x61
    uint16_t voltage;  // offset: 0x62
    uint16_t frequency;  // offset: 0x64
    uint16_t nonce_rate;  // offset: 0x66
    int8_t pcb_temp_in;  // offset: 0x68
    int8_t pcb_temp_out;  // offset: 0x69
    uint8_t test_version;  // offset: 0x6a
    uint8_t test_standard;  // offset: 0x6b
    uint8_t pt2_result;  // offset: 0x6c
    uint8_t pt2_count;  // offset: 0x6d
    char data_padding2[3];  // offset: 0x6e
    uint8_t param_info_crc;  // offset: 0x71
    uint16_t sweep_hashrate;  // offset: 0x72
    uint16_t sweep_freq_base;  // offset: 0x74
    uint8_t sweep_freq_step;  // offset: 0x76
    uint8_t sweep_level[128];  // offset: 0x77
    uint8_t sweep_result;  // offset: 0xf7
    char data_padding3[1];  // offset: 0xf8
    uint8_t sweep_info_crc;  // offset: 0xf9
}; // size: 0xfa

struct eeprom_data_t {
    char sn[18];  // offset: 0x0
    int num;  // offset: 0x14
    anon_union_160_2_9472fda9_for_eeprom_data_t_2 field_2;  // offset: 0x18
    double vol[20];  // offset: 0xb8
    int32_t c_date;  // offset: 0x158
}; // size: 0x160

struct engine_st {
    // Empty structure
}; // size: 0x1

struct env_md_ctx_st {
    EVP_MD * digest;  // offset: 0x0
    ENGINE * engine;  // offset: 0x4
    ulong flags;  // offset: 0x8
    void * md_data;  // offset: 0xc
    EVP_PKEY_CTX * pctx;  // offset: 0x10
    _func_1230 * update;  // offset: 0x14
}; // size: 0x18

struct env_md_st {
    int type;  // offset: 0x0
    int pkey_type;  // offset: 0x4
    int md_size;  // offset: 0x8
    ulong flags;  // offset: 0xc
    _func_1220 * init;  // offset: 0x10
    _func_1221 * update;  // offset: 0x14
    _func_1222 * final;  // offset: 0x18
    _func_1223 * copy;  // offset: 0x1c
    _func_1224 * cleanup;  // offset: 0x20
    _func_1225 * sign;  // offset: 0x24
    _func_1226 * verify;  // offset: 0x28
    int required_pkey_type[5];  // offset: 0x2c
    int block_size;  // offset: 0x40
    int ctx_size;  // offset: 0x44
    _func_1227 * md_ctrl;  // offset: 0x48
}; // size: 0x4c

struct err_state_st {
    CRYPTO_THREADID tid;  // offset: 0x0
    int err_flags[16];  // offset: 0x8
    ulong err_buffer[16];  // offset: 0x48
    char * err_data[16];  // offset: 0x88
    int err_data_flags[16];  // offset: 0xc8
    char * err_file[16];  // offset: 0x108
    int err_line[16];  // offset: 0x148
    int top;  // offset: 0x188
    int bottom;  // offset: 0x18c
}; // size: 0x190

struct evp_Encode_Ctx_st {
    int num;  // offset: 0x0
    int length;  // offset: 0x4
    uchar enc_data[80];  // offset: 0x8
    int line_num;  // offset: 0x58
    int expect_nl;  // offset: 0x5c
}; // size: 0x60

struct evp_cipher_ctx_st {
    EVP_CIPHER * cipher;  // offset: 0x0
    ENGINE * engine;  // offset: 0x4
    int encrypt;  // offset: 0x8
    int buf_len;  // offset: 0xc
    uchar oiv[16];  // offset: 0x10
    uchar iv[16];  // offset: 0x20
    uchar buf[32];  // offset: 0x30
    int num;  // offset: 0x50
    void * app_data;  // offset: 0x54
    int key_len;  // offset: 0x58
    ulong flags;  // offset: 0x5c
    void * cipher_data;  // offset: 0x60
    int final_used;  // offset: 0x64
    int block_mask;  // offset: 0x68
    uchar final[32];  // offset: 0x6c
}; // size: 0x8c

struct evp_cipher_info_st {
    EVP_CIPHER * cipher;  // offset: 0x0
    uchar iv[16];  // offset: 0x4
}; // size: 0x14

struct evp_cipher_st {
    int nid;  // offset: 0x0
    int block_size;  // offset: 0x4
    int key_len;  // offset: 0x8
    int iv_len;  // offset: 0xc
    ulong flags;  // offset: 0x10
    _func_1231 * init;  // offset: 0x14
    _func_1232 * do_cipher;  // offset: 0x18
    _func_1233 * cleanup;  // offset: 0x1c
    int ctx_size;  // offset: 0x20
    _func_1234 * set_asn1_parameters;  // offset: 0x24
    _func_1235 * get_asn1_parameters;  // offset: 0x28
    _func_1236 * ctrl;  // offset: 0x2c
    void * app_data;  // offset: 0x30
}; // size: 0x34

struct evp_pkey_asn1_method_st {
    // Empty structure
}; // size: 0x1

struct evp_pkey_ctx_st {
    // Empty structure
}; // size: 0x1

struct evp_pkey_method_st {
    // Empty structure
}; // size: 0x1

struct evp_pkey_st {
    int type;  // offset: 0x0
    int save_type;  // offset: 0x4
    int references;  // offset: 0x8
    EVP_PKEY_ASN1_METHOD * ameth;  // offset: 0xc
    ENGINE * engine;  // offset: 0x10
    _union_277 pkey;  // offset: 0x14
    int save_parameters;  // offset: 0x18
    stack_st_X509_ATTRIBUTE * attributes;  // offset: 0x1c
}; // size: 0x20

struct fan {
    uint32_t Fan_Speed;  // offset: 0x0
    uint32_t Work_Fan_Speed;  // offset: 0x4
    uint32_t Fan_Limit;  // offset: 0x8
}; // size: 0xc

struct fan_conf_info {
    bitmain_fan_id_e fan_id;  // offset: 0x0
    uint32_t fan_name;  // offset: 0x4
    uint32_t max_speed;  // offset: 0x8
}; // size: 0xc

struct fd_set {
    __fd_mask __fds_bits[32];  // offset: 0x0
}; // size: 0x80

struct fd_set {
    __fd_mask fds_bits[32];  // offset: 0x0
}; // size: 0x80

struct filker_interval_t {
    uint32_t interval;  // offset: 0x0
    uint32_t timeout;  // offset: 0x4
    uint32_t next_val;  // offset: 0x8
}; // size: 0xc

struct fr_proto {
    uint t391;  // offset: 0x0
    uint t392;  // offset: 0x4
    uint n391;  // offset: 0x8
    uint n392;  // offset: 0xc
    uint n393;  // offset: 0x10
    ushort lmi;  // offset: 0x14
    ushort dce;  // offset: 0x16
}; // size: 0x18

struct fr_proto_pvc {
    uint dlci;  // offset: 0x0
}; // size: 0x4

struct fr_proto_pvc_info {
    uint dlci;  // offset: 0x0
    char master[16];  // offset: 0x4
}; // size: 0x14

struct gpio_callback_t {
    bitmain_gpio_callback function;  // offset: 0x0
    uint32_t last;  // offset: 0x4
}; // size: 0x8

struct gpio_map_t {
    pthread_mutex_t ctrl_mutex;  // offset: 0x0
    clib_map * gpio_callback_map;  // offset: 0x18
}; // size: 0x1c

struct hash_board {
    char Miner_Type[16];  // offset: 0x0
    char Board_Name[16];  // offset: 0x10
    char Asic_Type[16];  // offset: 0x20
    uint32_t Asic_Num;  // offset: 0x30
    uint32_t Big_Core_Num;  // offset: 0x34
    uint32_t Small_Core_Num;  // offset: 0x38
    uint32_t Small_Core_Num_In_Big_Core;  // offset: 0x3c
    uint32_t Voltage_Domain;  // offset: 0x40
    uint32_t Asic_Num_Per_Voltage_Domain;  // offset: 0x44
    Sensor_Info Sensor_Info;  // offset: 0x48
    uint32_t Power_Version[16];  // offset: 0x84
    _Bool Has_Pic;  // offset: 0xc4
    _Bool Smooth_Voltage;  // offset: 0xc5
    uint32_t Inc_Freq_Delay;  // offset: 0xc8
    uint32_t Voltage_Adjust_Step;  // offset: 0xcc
    uint32_t Wait_Board_Temp;  // offset: 0xd0
}; // size: 0xd4

struct hashboard_qr_code {
    char factory_job[32];  // offset: 0x0
    char chip_die[16];  // offset: 0x20
    char chip_marking[16];  // offset: 0x30
    char chip_bin[16];  // offset: 0x40
    char chip_ftversion[16];  // offset: 0x50
    char temp_sensor_type[16];  // offset: 0x60
    char hashboard_ctrl_code[16];  // offset: 0x70
    char hashboard_index[16];  // offset: 0x80
}; // size: 0x90

struct hashboard_sn {
    char sn_len;  // offset: 0x0
    char board_sn[32];  // offset: 0x1
}; // size: 0x21

struct hashtable {
    size_t size;  // offset: 0x0
    hashtable_bucket * buckets;  // offset: 0x4
    size_t order;  // offset: 0x8
    hashtable_list list;  // offset: 0xc
    hashtable_list ordered_list;  // offset: 0x14
}; // size: 0x1c

struct hashtable_bucket {
    hashtable_list * first;  // offset: 0x0
    hashtable_list * last;  // offset: 0x4
}; // size: 0x8

struct hashtable_list {
    hashtable_list * prev;  // offset: 0x0
    hashtable_list * next;  // offset: 0x4
}; // size: 0x8

struct hashtable_pair {
    hashtable_list list;  // offset: 0x0
    hashtable_list ordered_list;  // offset: 0x8
    size_t hash;  // offset: 0x10
    json_t * value;  // offset: 0x14
    char key[1];  // offset: 0x18
}; // size: 0x1c

struct history_result {
    _Bool asic_ok;  // offset: 0x0
    _Bool nonce_rate_ok;  // offset: 0x1
    _Bool eeprom_ok;  // offset: 0x2
    _Bool pic_sensor_all_OK;  // offset: 0x3
    _Bool asic_sensor_all_OK;  // offset: 0x4
    _Bool ctrlboard_sensor_all_OK;  // offset: 0x5
    _Bool apw_power_ok;  // offset: 0x6
    _Bool pic_ok;  // offset: 0x7
    _Bool seep_ok;  // offset: 0x8
    double nonce_rate;  // offset: 0x10
    uint32_t level;  // offset: 0x18
    uint32_t voltage;  // offset: 0x1c
    uint32_t pre_open_core_voltage;  // offset: 0x20
    uint32_t frequence;  // offset: 0x24
    uint32_t valid_nonce_num;  // offset: 0x28
    uint32_t repeat_nonce_number;  // offset: 0x2c
    uint8_t[1280] asic_core_nonce_num[108];  // offset: 0x30
    uint16_t every_asic_got_nonce_num[108];  // offset: 0x21c30
    uint16_t every_asic_reg_ntick_nonce_num[108];  // offset: 0x21d08
    uint16_t every_asic_reg_nonce_error_num[108];  // offset: 0x21de0
    uint16_t every_asic_reg_got_nonce_num[108];  // offset: 0x21eb8
    _Bool ok_asic_list[108];  // offset: 0x21f90
    _Bool bad_asic_list[108];  // offset: 0x21ffc
    _Bool pic_sensor_OK[4];  // offset: 0x22068
    _Bool asic_sensor_OK[108];  // offset: 0x2206c
    _Bool ctrlboard_sensor_OK[2];  // offset: 0x220d8
    int8_t sensor_local_temperature_from_pic[4];  // offset: 0x220da
    int8_t sensor_local_temperature_from_ctrlboard[2];  // offset: 0x220de
    uint8_t test_standard;  // offset: 0x220e0
}; // size: 0x220e8

struct hm_header_st {
    uchar type;  // offset: 0x0
    ulong msg_len;  // offset: 0x4
    ushort seq;  // offset: 0x8
    ulong frag_off;  // offset: 0xc
    ulong frag_len;  // offset: 0x10
    uint is_ccs;  // offset: 0x14
    dtls1_retransmit_state saved_retransmit_state;  // offset: 0x18
}; // size: 0x2c

struct hmac_ctx_st {
    EVP_MD * md;  // offset: 0x0
    EVP_MD_CTX md_ctx;  // offset: 0x4
    EVP_MD_CTX i_ctx;  // offset: 0x1c
    EVP_MD_CTX o_ctx;  // offset: 0x34
    uint key_length;  // offset: 0x4c
    uchar key[128];  // offset: 0x50
}; // size: 0xd0

struct hostent {
    char * h_name;  // offset: 0x0
    char * * h_aliases;  // offset: 0x4
    int h_addrtype;  // offset: 0x8
    int h_length;  // offset: 0xc
    char * * h_addr_list;  // offset: 0x10
}; // size: 0x14

struct hostent {
    char * h_name;  // offset: 0x0
    char * * h_aliases;  // offset: 0x4
    int h_addrtype;  // offset: 0x8
    int h_length;  // offset: 0xc
    char * * h_addr_list;  // offset: 0x10
}; // size: 0x14

struct i2c_value_t {
    uint32_t master;  // offset: 0x0
    uint32_t slave;  // offset: 0x4
}; // size: 0x8

struct if_settings {
    uint type;  // offset: 0x0
    uint size;  // offset: 0x4
    anon_union_4_7_b62d2563_for_ifs_ifsu ifs_ifsu;  // offset: 0x8
}; // size: 0xc

struct ifmap {
    ulong mem_start;  // offset: 0x0
    ulong mem_end;  // offset: 0x4
    ushort base_addr;  // offset: 0x8
    uchar irq;  // offset: 0xa
    uchar dma;  // offset: 0xb
    uchar port;  // offset: 0xc
}; // size: 0x10

struct ifreq {
    anon_union_16_1_990b9991_for_ifr_ifrn ifr_ifrn;  // offset: 0x0
    anon_union_16_13_59db9508_for_ifr_ifru ifr_ifru;  // offset: 0x10
}; // size: 0x20

struct iic_init_param_t {
    uint32_t chain_id;  // offset: 0x0
    uint16_t master_addr;  // offset: 0x4
    uint8_t slave_high;  // offset: 0x6
    uint8_t slave_low;  // offset: 0x7
}; // size: 0x8

struct in6_addr {
    anon_union_16_3_a3f0114d_for___in6_u __in6_u;  // offset: 0x0
}; // size: 0x10

struct in_addr {
    in_addr_t s_addr;  // offset: 0x0
}; // size: 0x4

struct in_addr {
    in_addr_t s_addr;  // offset: 0x0
}; // size: 0x4

struct json_array_t {
    json_t json;  // offset: 0x0
    size_t size;  // offset: 0x8
    size_t entries;  // offset: 0xc
    json_t * * table;  // offset: 0x10
}; // size: 0x14

struct json_error_t {
    int line;  // offset: 0x0
    int column;  // offset: 0x4
    int position;  // offset: 0x8
    char source[80];  // offset: 0xc
    char text[160];  // offset: 0x5c
}; // size: 0xfc

struct json_integer_t {
    json_t json;  // offset: 0x0
    json_int_t value;  // offset: 0x8
}; // size: 0x10

struct json_object_t {
    json_t json;  // offset: 0x0
    hashtable_t hashtable;  // offset: 0x8
}; // size: 0x24

struct json_real_t {
    json_t json;  // offset: 0x0
    double value;  // offset: 0x8
}; // size: 0x10

struct json_string_t {
    json_t json;  // offset: 0x0
    char * value;  // offset: 0x8
    size_t length;  // offset: 0xc
}; // size: 0x10

struct json_t {
    json_type type;  // offset: 0x0
    size_t refcount;  // offset: 0x4
}; // size: 0x8

struct kssl_ctx_st {
    char * service_name;  // offset: 0x0
    char * service_host;  // offset: 0x4
    char * client_princ;  // offset: 0x8
    char * keytab_file;  // offset: 0xc
    char * cred_cache;  // offset: 0x10
    krb5_enctype enctype;  // offset: 0x14
    int length;  // offset: 0x18
    krb5_octet * key;  // offset: 0x1c
}; // size: 0x20

struct lconv {
    char * decimal_point;  // offset: 0x0
    char * thousands_sep;  // offset: 0x4
    char * grouping;  // offset: 0x8
    char * int_curr_symbol;  // offset: 0xc
    char * currency_symbol;  // offset: 0x10
    char * mon_decimal_point;  // offset: 0x14
    char * mon_thousands_sep;  // offset: 0x18
    char * mon_grouping;  // offset: 0x1c
    char * positive_sign;  // offset: 0x20
    char * negative_sign;  // offset: 0x24
    char int_frac_digits;  // offset: 0x28
    char frac_digits;  // offset: 0x29
    char p_cs_precedes;  // offset: 0x2a
    char p_sep_by_space;  // offset: 0x2b
    char n_cs_precedes;  // offset: 0x2c
    char n_sep_by_space;  // offset: 0x2d
    char p_sign_posn;  // offset: 0x2e
    char n_sign_posn;  // offset: 0x2f
    char int_p_cs_precedes;  // offset: 0x30
    char int_p_sep_by_space;  // offset: 0x31
    char int_n_cs_precedes;  // offset: 0x32
    char int_n_sep_by_space;  // offset: 0x33
    char int_p_sign_posn;  // offset: 0x34
    char int_n_sign_posn;  // offset: 0x35
}; // size: 0x38

struct lconv {
    char * decimal_point;  // offset: 0x0
    char * thousands_sep;  // offset: 0x4
    char * grouping;  // offset: 0x8
    char * int_curr_symbol;  // offset: 0xc
    char * currency_symbol;  // offset: 0x10
    char * mon_decimal_point;  // offset: 0x14
    char * mon_thousands_sep;  // offset: 0x18
    char * mon_grouping;  // offset: 0x1c
    char * positive_sign;  // offset: 0x20
    char * negative_sign;  // offset: 0x24
    char int_frac_digits;  // offset: 0x28
    char frac_digits;  // offset: 0x29
    char p_cs_precedes;  // offset: 0x2a
    char p_sep_by_space;  // offset: 0x2b
    char n_cs_precedes;  // offset: 0x2c
    char n_sep_by_space;  // offset: 0x2d
    char p_sign_posn;  // offset: 0x2e
    char n_sign_posn;  // offset: 0x2f
    char int_p_cs_precedes;  // offset: 0x30
    char int_p_sep_by_space;  // offset: 0x31
    char int_n_cs_precedes;  // offset: 0x32
    char int_n_sep_by_space;  // offset: 0x33
    char int_p_sign_posn;  // offset: 0x34
    char int_n_sign_posn;  // offset: 0x35
}; // size: 0x38

struct lex_t {
    stream_t stream;  // offset: 0x0
    strbuffer_t saved_text;  // offset: 0x28
    size_t flags;  // offset: 0x34
    size_t depth;  // offset: 0x38
    int token;  // offset: 0x3c
    anon_union_8_3_477c3ef1_for_value value;  // offset: 0x40
}; // size: 0x48

struct lhash_st_CONF_VALUE {
    int dummy;  // offset: 0x0
}; // size: 0x4

struct lhash_st_OPENSSL_STRING {
    int dummy;  // offset: 0x0
}; // size: 0x4

struct lhash_st_SSL_SESSION {
    int dummy;  // offset: 0x0
}; // size: 0x4

struct local_config_info {
    char Test_Process[16];  // offset: 0x0
    Hash_Board Hash_Board;  // offset: 0x10
    Test_Info Test_Info;  // offset: 0xe4
    Repair_Mode Repair_Mode;  // offset: 0x4a8
}; // size: 0x4b0

struct log_info_t {
    char path[128];  // offset: 0x0
    char compressed_path[128];  // offset: 0x80
    char encoded_path[128];  // offset: 0x100
    _Bool compressed;  // offset: 0x180
    _Bool encode;  // offset: 0x181
    char * data;  // offset: 0x184
    uint32_t origin_size;  // offset: 0x188
    uint32_t filter_size;  // offset: 0x18c
}; // size: 0x190

struct mes_system_asic_reg {
    uint32_t id;  // offset: 0x0
    uint32_t ccdly_sel;  // offset: 0x4
    uint32_t pwth_sel;  // offset: 0x8
    uint32_t swpf_mode;  // offset: 0xc
    uint32_t pulse_mode;  // offset: 0x10
    uint32_t clk_sel;  // offset: 0x14
    uint32_t ro_relay_en;  // offset: 0x18
    uint32_t co_relay_en;  // offset: 0x1c
    uint32_t diode_vdd_mux_sel;  // offset: 0x20
    mes_system_asic_reg * next;  // offset: 0x24
}; // size: 0x28

struct mes_system_config_file_info {
    char jsonrpc[24];  // offset: 0x0
    uint32_t id;  // offset: 0x18
    Mes_System_Result result;  // offset: 0x1c
}; // size: 0x68

struct mes_system_configs {
    char miner_type[24];  // offset: 0x0
    mes_system_hw_info * hw_info;  // offset: 0x18
    Mes_System_Rule rule;  // offset: 0x1c
    mes_system_test_config * test_config;  // offset: 0x2c
    mes_system_configs * next;  // offset: 0x30
}; // size: 0x34

struct mes_system_data {
    char version[24];  // offset: 0x0
    uint32_t pattern_id;  // offset: 0x18
    uint32_t asic_reg_id;  // offset: 0x1c
    uint32_t test_method_id;  // offset: 0x20
    uint32_t voltage_accuracy;  // offset: 0x24
    uint32_t fan_speed;  // offset: 0x28
    uint32_t test_loop_id[50];  // offset: 0x2c
    uint32_t test_loop_id_number;  // offset: 0xf4
    uint32_t pre_open_core_voltage;  // offset: 0xf8
    mes_system_data * next;  // offset: 0xfc
}; // size: 0x100

struct mes_system_hw_info {
    uint32_t id;  // offset: 0x0
    char board_name[24];  // offset: 0x4
    char asic_type[24];  // offset: 0x1c
    uint32_t asic_num;  // offset: 0x34
    uint32_t voltage_domain;  // offset: 0x38
    uint32_t asic_num_per_voltage_domain;  // offset: 0x3c
    uint32_t power_version[16];  // offset: 0x40
    mes_system_hw_info * next;  // offset: 0x80
}; // size: 0x84

struct mes_system_pattern {
    uint32_t id;  // offset: 0x0
    uint32_t pattern_number;  // offset: 0x4
    uint32_t invalid_core_num;  // offset: 0x8
    uint32_t most_hw_num;  // offset: 0xc
    uint32_t least_nonce_per_core;  // offset: 0x10
    uint32_t nonce_rate;  // offset: 0x14
    uint32_t midstate_number;  // offset: 0x18
    mes_system_pattern * next;  // offset: 0x1c
}; // size: 0x20

struct mes_system_result {
    char version[24];  // offset: 0x0
    char code[24];  // offset: 0x18
    char msg[24];  // offset: 0x30
    mes_system_configs * configs;  // offset: 0x48
}; // size: 0x4c

struct mes_system_rule {
    mes_system_pattern * pattern;  // offset: 0x0
    mes_system_asic_reg * asic_reg;  // offset: 0x4
    mes_system_test_method * test_method;  // offset: 0x8
    mes_system_test_loop * test_loop;  // offset: 0xc
}; // size: 0x10

struct mes_system_test_config {
    char hardware_version[24];  // offset: 0x0
    char bom_version[24];  // offset: 0x18
    char chip_technology[24];  // offset: 0x30
    char ft_version[24];  // offset: 0x48
    uint32_t bin;  // offset: 0x60
    mes_system_data * data;  // offset: 0x64
    mes_system_test_config * next;  // offset: 0x68
}; // size: 0x6c

struct mes_system_test_loop {
    uint32_t id;  // offset: 0x0
    uint32_t frequency;  // offset: 0x4
    uint32_t voltage;  // offset: 0x8
    mes_system_test_loop * next;  // offset: 0xc
}; // size: 0x10

struct mes_system_test_method {
    uint32_t id;  // offset: 0x0
    char method[24];  // offset: 0x4
    mes_system_test_method * next;  // offset: 0x1c
}; // size: 0x20

struct obj_name_st {
    int type;  // offset: 0x0
    int alias;  // offset: 0x4
    char * name;  // offset: 0x8
    char * data;  // offset: 0xc
}; // size: 0x10

struct ocsp_basic_response_st {
    OCSP_RESPDATA * tbsResponseData;  // offset: 0x0
    X509_ALGOR * signatureAlgorithm;  // offset: 0x4
    ASN1_BIT_STRING * signature;  // offset: 0x8
    stack_st_X509 * certs;  // offset: 0xc
}; // size: 0x10

struct ocsp_cert_id_st {
    X509_ALGOR * hashAlgorithm;  // offset: 0x0
    ASN1_OCTET_STRING * issuerNameHash;  // offset: 0x4
    ASN1_OCTET_STRING * issuerKeyHash;  // offset: 0x8
    ASN1_INTEGER * serialNumber;  // offset: 0xc
}; // size: 0x10

struct ocsp_cert_status_st {
    int type;  // offset: 0x0
    _union_965 value;  // offset: 0x4
}; // size: 0x8

struct ocsp_crl_id_st {
    ASN1_IA5STRING * crlUrl;  // offset: 0x0
    ASN1_INTEGER * crlNum;  // offset: 0x4
    ASN1_GENERALIZEDTIME * crlTime;  // offset: 0x8
}; // size: 0xc

struct ocsp_one_request_st {
    OCSP_CERTID * reqCert;  // offset: 0x0
    stack_st_X509_EXTENSION * singleRequestExtensions;  // offset: 0x4
}; // size: 0x8

struct ocsp_req_ctx_st {
    // Empty structure
}; // size: 0x1

struct ocsp_req_info_st {
    ASN1_INTEGER * version;  // offset: 0x0
    GENERAL_NAME * requestorName;  // offset: 0x4
    stack_st_OCSP_ONEREQ * requestList;  // offset: 0x8
    stack_st_X509_EXTENSION * requestExtensions;  // offset: 0xc
}; // size: 0x10

struct ocsp_request_st {
    OCSP_REQINFO * tbsRequest;  // offset: 0x0
    OCSP_SIGNATURE * optionalSignature;  // offset: 0x4
}; // size: 0x8

struct ocsp_resp_bytes_st {
    ASN1_OBJECT * responseType;  // offset: 0x0
    ASN1_OCTET_STRING * response;  // offset: 0x4
}; // size: 0x8

struct ocsp_responder_id_st {
    int type;  // offset: 0x0
    _union_961 value;  // offset: 0x4
}; // size: 0x8

struct ocsp_response_data_st {
    ASN1_INTEGER * version;  // offset: 0x0
    OCSP_RESPID * responderId;  // offset: 0x4
    ASN1_GENERALIZEDTIME * producedAt;  // offset: 0x8
    stack_st_OCSP_SINGLERESP * responses;  // offset: 0xc
    stack_st_X509_EXTENSION * responseExtensions;  // offset: 0x10
}; // size: 0x14

struct ocsp_response_st {
    ASN1_ENUMERATED * responseStatus;  // offset: 0x0
    OCSP_RESPBYTES * responseBytes;  // offset: 0x4
}; // size: 0x8

struct ocsp_revoked_info_st {
    ASN1_GENERALIZEDTIME * revocationTime;  // offset: 0x0
    ASN1_ENUMERATED * revocationReason;  // offset: 0x4
}; // size: 0x8

struct ocsp_service_locator_st {
    X509_NAME * issuer;  // offset: 0x0
    stack_st_ACCESS_DESCRIPTION * locator;  // offset: 0x4
}; // size: 0x8

struct ocsp_signature_st {
    X509_ALGOR * signatureAlgorithm;  // offset: 0x0
    ASN1_BIT_STRING * signature;  // offset: 0x4
    stack_st_X509 * certs;  // offset: 0x8
}; // size: 0xc

struct ocsp_single_response_st {
    OCSP_CERTID * certId;  // offset: 0x0
    OCSP_CERTSTATUS * certStatus;  // offset: 0x4
    ASN1_GENERALIZEDTIME * thisUpdate;  // offset: 0x8
    ASN1_GENERALIZEDTIME * nextUpdate;  // offset: 0xc
    stack_st_X509_EXTENSION * singleExtensions;  // offset: 0x10
}; // size: 0x14

struct op_sweep {
    _func_int_void_ptr_void_ptr * init;  // offset: 0x0
    _func_int_float_ptr_ptr_uint8_t_ptr_ptr * sweep;  // offset: 0x4
    _func_int_float_ptr_ptr_uint8_t_ptr_ptr * drop;  // offset: 0x8
    _func_int_varargs * stop;  // offset: 0xc
    _func_int_float_ptr_ptr * flush;  // offset: 0x10
    _func_int_varargs * check_status;  // offset: 0x14
}; // size: 0x18

struct otherName_st {
    ASN1_OBJECT * type_id;  // offset: 0x0
    ASN1_TYPE * value;  // offset: 0x4
}; // size: 0x8

struct pattern_info_new {
    work_new * works[108];  // offset: 0x0
}; // size: 0x1b0

struct pattern_struct_in_file {
    uchar midstate[8];  // offset: 0x0
    uint32_t nonce;  // offset: 0x8
}; // size: 0xc

struct pattern_struct_in_file {
    uchar midstate[8];  // offset: 0x0
    uint32_t nonce;  // offset: 0x8
}; // size: 0xc

struct pattern_struct_in_file {
    uchar midstate[8];  // offset: 0x0
    uint32_t nonce;  // offset: 0x8
}; // size: 0xc

struct pattern_struct_in_file {
    uchar midstate[8];  // offset: 0x0
    uint32_t nonce;  // offset: 0x8
}; // size: 0xc

struct pic_sensor {
    char Pic_Sensor_Model[16];  // offset: 0x0
    uint32_t Pic_Sensor_Addr[4];  // offset: 0x10
}; // size: 0x20

struct pkcs12_bag_st {
    ASN1_OBJECT * type;  // offset: 0x0
    _union_991 value;  // offset: 0x4
}; // size: 0x8

struct pkcs7_digest_st {
    ASN1_INTEGER * version;  // offset: 0x0
    X509_ALGOR * md;  // offset: 0x4
    pkcs7_st * contents;  // offset: 0x8
    ASN1_OCTET_STRING * digest;  // offset: 0xc
}; // size: 0x10

struct pkcs7_enc_content_st {
    ASN1_OBJECT * content_type;  // offset: 0x0
    X509_ALGOR * algorithm;  // offset: 0x4
    ASN1_OCTET_STRING * enc_data;  // offset: 0x8
    EVP_CIPHER * cipher;  // offset: 0xc
}; // size: 0x10

struct pkcs7_encrypted_st {
    ASN1_INTEGER * version;  // offset: 0x0
    PKCS7_ENC_CONTENT * enc_data;  // offset: 0x4
}; // size: 0x8

struct pkcs7_enveloped_st {
    ASN1_INTEGER * version;  // offset: 0x0
    stack_st_PKCS7_RECIP_INFO * recipientinfo;  // offset: 0x4
    PKCS7_ENC_CONTENT * enc_data;  // offset: 0x8
}; // size: 0xc

struct pkcs7_issuer_and_serial_st {
    X509_NAME * issuer;  // offset: 0x0
    ASN1_INTEGER * serial;  // offset: 0x4
}; // size: 0x8

struct pkcs7_recip_info_st {
    ASN1_INTEGER * version;  // offset: 0x0
    PKCS7_ISSUER_AND_SERIAL * issuer_and_serial;  // offset: 0x4
    X509_ALGOR * key_enc_algor;  // offset: 0x8
    ASN1_OCTET_STRING * enc_key;  // offset: 0xc
    X509 * cert;  // offset: 0x10
}; // size: 0x14

struct pkcs7_signed_st {
    ASN1_INTEGER * version;  // offset: 0x0
    stack_st_X509_ALGOR * md_algs;  // offset: 0x4
    stack_st_X509 * cert;  // offset: 0x8
    stack_st_X509_CRL * crl;  // offset: 0xc
    stack_st_PKCS7_SIGNER_INFO * signer_info;  // offset: 0x10
    pkcs7_st * contents;  // offset: 0x14
}; // size: 0x18

struct pkcs7_signedandenveloped_st {
    ASN1_INTEGER * version;  // offset: 0x0
    stack_st_X509_ALGOR * md_algs;  // offset: 0x4
    stack_st_X509 * cert;  // offset: 0x8
    stack_st_X509_CRL * crl;  // offset: 0xc
    stack_st_PKCS7_SIGNER_INFO * signer_info;  // offset: 0x10
    PKCS7_ENC_CONTENT * enc_data;  // offset: 0x14
    stack_st_PKCS7_RECIP_INFO * recipientinfo;  // offset: 0x18
}; // size: 0x1c

struct pkcs7_signer_info_st {
    ASN1_INTEGER * version;  // offset: 0x0
    PKCS7_ISSUER_AND_SERIAL * issuer_and_serial;  // offset: 0x4
    X509_ALGOR * digest_alg;  // offset: 0x8
    stack_st_X509_ATTRIBUTE * auth_attr;  // offset: 0xc
    X509_ALGOR * digest_enc_alg;  // offset: 0x10
    ASN1_OCTET_STRING * enc_digest;  // offset: 0x14
    stack_st_X509_ATTRIBUTE * unauth_attr;  // offset: 0x18
    EVP_PKEY * pkey;  // offset: 0x1c
}; // size: 0x20

struct pkcs7_st {
    uchar * asn1;  // offset: 0x0
    long length;  // offset: 0x4
    int state;  // offset: 0x8
    int detached;  // offset: 0xc
    ASN1_OBJECT * type;  // offset: 0x10
    _union_450 d;  // offset: 0x14
}; // size: 0x18

struct pkcs8_priv_key_info_st {
    int broken;  // offset: 0x0
    ASN1_INTEGER * version;  // offset: 0x4
    X509_ALGOR * pkeyalg;  // offset: 0x8
    ASN1_TYPE * pkey;  // offset: 0xc
    stack_st_X509_ATTRIBUTE * attributes;  // offset: 0x10
}; // size: 0x14

struct pll_conf {
    pllparameter_t pll_param;  // offset: 0x0
    uint8_t usr_divider;  // offset: 0x6
}; // size: 0x8

struct pll_divider_conf_t {
    uint8_t post_div1;  // offset: 0x0
    uint8_t post_div2;  // offset: 0x1
    uint32_t div_ret;  // offset: 0x4
}; // size: 0x8

struct pll_userdivider_t {
    uint8_t userdivider0;  // offset: 0x0
    uint8_t userdivider1;  // offset: 0x1
    uint8_t userdivider2;  // offset: 0x2
    uint8_t userdivider3;  // offset: 0x3
}; // size: 0x4

struct pllparameter_t {
    uint8_t postdiv1;  // offset: 0x0
    uint8_t postdiv2;  // offset: 0x1
    uint8_t refdiv;  // offset: 0x2
    uint16_t fbdiv;  // offset: 0x4
}; // size: 0x6

struct power_temp_t {
    int32_t temp_pfc;  // offset: 0x0
    int32_t temp_llc1;  // offset: 0x4
    int32_t temp_llc2;  // offset: 0x8
}; // size: 0xc

struct private_key_st {
    int version;  // offset: 0x0
    X509_ALGOR * enc_algor;  // offset: 0x4
    ASN1_OCTET_STRING * enc_pkey;  // offset: 0x8
    EVP_PKEY * dec_pkey;  // offset: 0xc
    int key_length;  // offset: 0x10
    char * key_data;  // offset: 0x14
    int key_free;  // offset: 0x18
    EVP_CIPHER_INFO cipher;  // offset: 0x1c
    int references;  // offset: 0x30
}; // size: 0x34

struct pt1_ctx {
    char factory_job[32];  // offset: 0x0
    char chip_die[16];  // offset: 0x20
    char chip_marking[16];  // offset: 0x30
    char chip_ftversion[16];  // offset: 0x40
    char temp_sensor_type[16];  // offset: 0x50
    char hashboard_ctrl_code[16];  // offset: 0x60
    char hashboard_index[16];  // offset: 0x70
    char chip_tech[3];  // offset: 0x80
    char board_name[9];  // offset: 0x83
    char board_sn[32];  // offset: 0x8c
    int chip_bin;  // offset: 0xac
}; // size: 0xb0

struct pwm_init_param_t {
    uint32_t freq;  // offset: 0x0
    uchar inited;  // offset: 0x4
}; // size: 0x8

struct rand_meth_st {
    _func_3912 * seed;  // offset: 0x0
    _func_3913 * bytes;  // offset: 0x4
    _func_3914 * cleanup;  // offset: 0x8
    _func_3915 * add;  // offset: 0xc
    _func_3916 * pseudorand;  // offset: 0x10
    _func_3917 * status;  // offset: 0x14
}; // size: 0x18

struct raw_hdlc_proto {
    ushort encoding;  // offset: 0x0
    ushort parity;  // offset: 0x2
}; // size: 0x4

struct rc2_key_st {
    uint data[64];  // offset: 0x0
}; // size: 0x100

struct rc4_key_st {
    uint x;  // offset: 0x0
    uint y;  // offset: 0x4
    uint data[256];  // offset: 0x8
}; // size: 0x408

struct record_pqueue_st {
    ushort epoch;  // offset: 0x0
    pqueue q;  // offset: 0x4
}; // size: 0x8

struct reg_buf {
    uint p_wr;  // offset: 0x0
    uint p_rd;  // offset: 0x4
    uint reg_value_num;  // offset: 0x8
    uint loop_back;  // offset: 0xc
    reg_content reg_buffer[4095];  // offset: 0x10
}; // size: 0x13ffc

struct reg_content {
    uint32_t reg_value;  // offset: 0x0
    uint32_t chip_address;  // offset: 0x4
    uint32_t reg_address;  // offset: 0x8
    uint32_t crc;  // offset: 0xc
    uint32_t chain_number;  // offset: 0x10
}; // size: 0x14

struct repair_mode {
    uint32_t Close_Power_Delay;  // offset: 0x0
    _Bool Clear_EEPROM_Data;  // offset: 0x4
    _Bool Enable_Repair;  // offset: 0x5
}; // size: 0x8

struct rsa_meth_st {
    char * name;  // offset: 0x0
    _func_1760 * rsa_pub_enc;  // offset: 0x4
    _func_1761 * rsa_pub_dec;  // offset: 0x8
    _func_1762 * rsa_priv_enc;  // offset: 0xc
    _func_1763 * rsa_priv_dec;  // offset: 0x10
    _func_1764 * rsa_mod_exp;  // offset: 0x14
    _func_1765 * bn_mod_exp;  // offset: 0x18
    _func_1766 * init;  // offset: 0x1c
    _func_1767 * finish;  // offset: 0x20
    int flags;  // offset: 0x24
    char * app_data;  // offset: 0x28
    _func_1768 * rsa_sign;  // offset: 0x2c
    _func_1769 * rsa_verify;  // offset: 0x30
    _func_1770 * rsa_keygen;  // offset: 0x34
}; // size: 0x38

struct rsa_pss_params_st {
    X509_ALGOR * hashAlgorithm;  // offset: 0x0
    X509_ALGOR * maskGenAlgorithm;  // offset: 0x4
    ASN1_INTEGER * saltLength;  // offset: 0x8
    ASN1_INTEGER * trailerField;  // offset: 0xc
}; // size: 0x10

struct rsa_st {
    int pad;  // offset: 0x0
    long version;  // offset: 0x4
    RSA_METHOD * meth;  // offset: 0x8
    ENGINE * engine;  // offset: 0xc
    BIGNUM * n;  // offset: 0x10
    BIGNUM * e;  // offset: 0x14
    BIGNUM * d;  // offset: 0x18
    BIGNUM * p;  // offset: 0x1c
    BIGNUM * q;  // offset: 0x20
    BIGNUM * dmp1;  // offset: 0x24
    BIGNUM * dmq1;  // offset: 0x28
    BIGNUM * iqmp;  // offset: 0x2c
    CRYPTO_EX_DATA ex_data;  // offset: 0x30
    int references;  // offset: 0x38
    int flags;  // offset: 0x3c
    BN_MONT_CTX * _method_mod_n;  // offset: 0x40
    BN_MONT_CTX * _method_mod_p;  // offset: 0x44
    BN_MONT_CTX * _method_mod_q;  // offset: 0x48
    char * bignum_data;  // offset: 0x4c
    BN_BLINDING * blinding;  // offset: 0x50
    BN_BLINDING * mt_blinding;  // offset: 0x54
}; // size: 0x58

struct seed_key_st {
    uint data[32];  // offset: 0x0
}; // size: 0x80

struct sensor_info {
    _Bool Read_Temperature_From_CtrlBoard;  // offset: 0x0
    _Bool Read_Temperature_From_Pic;  // offset: 0x1
    _Bool Read_Temperature_From_Asic;  // offset: 0x2
    Pic_Sensor Pic_Sensor;  // offset: 0x4
    CtrlBoard_Sensor CtrlBoard_Sensor;  // offset: 0x24
}; // size: 0x3c

struct sess_cert_st {
    // Empty structure
}; // size: 0x1

struct sha2_context {
    uint32_t total[2];  // offset: 0x0
    uint32_t state[8];  // offset: 0x8
    uchar buffer[64];  // offset: 0x28
    uchar ipad[64];  // offset: 0x68
    uchar opad[64];  // offset: 0xa8
}; // size: 0xe8

struct sigaction {
    anon_union_4_2_5ad2d23e_for___sigaction_handler __sigaction_handler;  // offset: 0x0
    __sigset_t sa_mask;  // offset: 0x4
    int sa_flags;  // offset: 0x84
    _func_void * sa_restorer;  // offset: 0x88
}; // size: 0x8c

struct sigaction {
    _union_1051 __sigaction_handler;  // offset: 0x0
    __sigset_t sa_mask;  // offset: 0x4
    int sa_flags;  // offset: 0x84
    _func_4849 * sa_restorer;  // offset: 0x88
}; // size: 0x8c

struct siginfo {
    int si_signo;  // offset: 0x0
    int si_errno;  // offset: 0x4
    int si_code;  // offset: 0x8
    _union_1031 _sifields;  // offset: 0xc
}; // size: 0x80

struct siginfo_t {
    int si_signo;  // offset: 0x0
    int si_errno;  // offset: 0x4
    int si_code;  // offset: 0x8
    anon_union_116_8_26c2b70a_for__sifields _sifields;  // offset: 0xc
}; // size: 0x80

struct sockaddr {
    sa_family_t sa_family;  // offset: 0x0
    char sa_data[14];  // offset: 0x2
}; // size: 0x10

struct sockaddr {
    sa_family_t sa_family;  // offset: 0x0
    char sa_data[14];  // offset: 0x2
}; // size: 0x10

struct sockaddr_at {
    // Empty structure
}; // size: 0x1

struct sockaddr_ax25 {
    // Empty structure
}; // size: 0x1

struct sockaddr_dl {
    // Empty structure
}; // size: 0x1

struct sockaddr_eon {
    // Empty structure
}; // size: 0x1

struct sockaddr_in {
    sa_family_t sin_family;  // offset: 0x0
    in_port_t sin_port;  // offset: 0x2
    in_addr sin_addr;  // offset: 0x4
    uchar sin_zero[8];  // offset: 0x8
}; // size: 0x10

struct sockaddr_in6 {
    sa_family_t sin6_family;  // offset: 0x0
    in_port_t sin6_port;  // offset: 0x2
    uint32_t sin6_flowinfo;  // offset: 0x4
    in6_addr sin6_addr;  // offset: 0x8
    uint32_t sin6_scope_id;  // offset: 0x18
}; // size: 0x1c

struct sockaddr_inarp {
    // Empty structure
}; // size: 0x1

struct sockaddr_ipx {
    // Empty structure
}; // size: 0x1

struct sockaddr_iso {
    // Empty structure
}; // size: 0x1

struct sockaddr_ns {
    // Empty structure
}; // size: 0x1

struct sockaddr_un {
    // Empty structure
}; // size: 0x1

struct sockaddr_x25 {
    // Empty structure
}; // size: 0x1

struct srtp_protection_profile_st {
    char * name;  // offset: 0x0
    ulong id;  // offset: 0x4
}; // size: 0x8

struct ssl2_state_st {
    int three_byte_header;  // offset: 0x0
    int clear_text;  // offset: 0x4
    int escape;  // offset: 0x8
    int ssl2_rollback;  // offset: 0xc
    uint wnum;  // offset: 0x10
    int wpend_tot;  // offset: 0x14
    uchar * wpend_buf;  // offset: 0x18
    int wpend_off;  // offset: 0x1c
    int wpend_len;  // offset: 0x20
    int wpend_ret;  // offset: 0x24
    int rbuf_left;  // offset: 0x28
    int rbuf_offs;  // offset: 0x2c
    uchar * rbuf;  // offset: 0x30
    uchar * wbuf;  // offset: 0x34
    uchar * write_ptr;  // offset: 0x38
    uint padding;  // offset: 0x3c
    uint rlength;  // offset: 0x40
    int ract_data_length;  // offset: 0x44
    uint wlength;  // offset: 0x48
    int wact_data_length;  // offset: 0x4c
    uchar * ract_data;  // offset: 0x50
    uchar * wact_data;  // offset: 0x54
    uchar * mac_data;  // offset: 0x58
    uchar * read_key;  // offset: 0x5c
    uchar * write_key;  // offset: 0x60
    uint challenge_length;  // offset: 0x64
    uchar challenge[32];  // offset: 0x68
    uint conn_id_length;  // offset: 0x88
    uchar conn_id[16];  // offset: 0x8c
    uint key_material_length;  // offset: 0x9c
    uchar key_material[48];  // offset: 0xa0
    ulong read_sequence;  // offset: 0xd0
    ulong write_sequence;  // offset: 0xd4
    _struct_647 tmp;  // offset: 0xd8
}; // size: 0x120

struct ssl3_buf_freelist_st {
    // Empty structure
}; // size: 0x1

struct ssl3_buffer_st {
    uchar * buf;  // offset: 0x0
    size_t len;  // offset: 0x4
    int offset;  // offset: 0x8
    int left;  // offset: 0xc
}; // size: 0x10

struct ssl3_enc_method {
    // Empty structure
}; // size: 0x1

struct ssl3_record_st {
    int type;  // offset: 0x0
    uint length;  // offset: 0x4
    uint off;  // offset: 0x8
    uchar * data;  // offset: 0xc
    uchar * input;  // offset: 0x10
    uchar * comp;  // offset: 0x14
    ulong epoch;  // offset: 0x18
    uchar seq_num[8];  // offset: 0x1c
}; // size: 0x24

struct ssl3_state_st {
    long flags;  // offset: 0x0
    int delay_buf_pop_ret;  // offset: 0x4
    uchar read_sequence[8];  // offset: 0x8
    int read_mac_secret_size;  // offset: 0x10
    uchar read_mac_secret[64];  // offset: 0x14
    uchar write_sequence[8];  // offset: 0x54
    int write_mac_secret_size;  // offset: 0x5c
    uchar write_mac_secret[64];  // offset: 0x60
    uchar server_random[32];  // offset: 0xa0
    uchar client_random[32];  // offset: 0xc0
    int need_empty_fragments;  // offset: 0xe0
    int empty_fragment_done;  // offset: 0xe4
    int init_extra;  // offset: 0xe8
    SSL3_BUFFER rbuf;  // offset: 0xec
    SSL3_BUFFER wbuf;  // offset: 0xfc
    SSL3_RECORD rrec;  // offset: 0x10c
    SSL3_RECORD wrec;  // offset: 0x130
    uchar alert_fragment[2];  // offset: 0x154
    uint alert_fragment_len;  // offset: 0x158
    uchar handshake_fragment[4];  // offset: 0x15c
    uint handshake_fragment_len;  // offset: 0x160
    uint wnum;  // offset: 0x164
    int wpend_tot;  // offset: 0x168
    int wpend_type;  // offset: 0x16c
    int wpend_ret;  // offset: 0x170
    uchar * wpend_buf;  // offset: 0x174
    BIO * handshake_buffer;  // offset: 0x178
    EVP_MD_CTX * * handshake_dgst;  // offset: 0x17c
    int change_cipher_spec;  // offset: 0x180
    int warn_alert;  // offset: 0x184
    int fatal_alert;  // offset: 0x188
    int alert_dispatch;  // offset: 0x18c
    uchar send_alert[2];  // offset: 0x190
    int renegotiate;  // offset: 0x194
    int total_renegotiations;  // offset: 0x198
    int num_renegotiations;  // offset: 0x19c
    int in_read_app_data;  // offset: 0x1a0
    void * client_opaque_prf_input;  // offset: 0x1a4
    size_t client_opaque_prf_input_len;  // offset: 0x1a8
    void * server_opaque_prf_input;  // offset: 0x1ac
    size_t server_opaque_prf_input_len;  // offset: 0x1b0
    _struct_651 tmp;  // offset: 0x1b4
    uchar previous_client_finished[64];  // offset: 0x394
    uchar previous_client_finished_len;  // offset: 0x3d4
    uchar previous_server_finished[64];  // offset: 0x3d5
    uchar previous_server_finished_len;  // offset: 0x415
    int send_connection_binding;  // offset: 0x418
    int next_proto_neg_seen;  // offset: 0x41c
}; // size: 0x420

struct ssl_cipher_st {
    int valid;  // offset: 0x0
    char * name;  // offset: 0x4
    ulong id;  // offset: 0x8
    ulong algorithm_mkey;  // offset: 0xc
    ulong algorithm_auth;  // offset: 0x10
    ulong algorithm_enc;  // offset: 0x14
    ulong algorithm_mac;  // offset: 0x18
    ulong algorithm_ssl;  // offset: 0x1c
    ulong algo_strength;  // offset: 0x20
    ulong algorithm2;  // offset: 0x24
    int strength_bits;  // offset: 0x28
    int alg_bits;  // offset: 0x2c
}; // size: 0x30

struct ssl_comp_st {
    int id;  // offset: 0x0
    char * name;  // offset: 0x4
    COMP_METHOD * method;  // offset: 0x8
}; // size: 0xc

struct ssl_ctx_st {
    // Empty structure
}; // size: 0x1

struct ssl_ctx_st {
    SSL_METHOD * method;  // offset: 0x0
    stack_st_SSL_CIPHER * cipher_list;  // offset: 0x4
    stack_st_SSL_CIPHER * cipher_list_by_id;  // offset: 0x8
    x509_store_st * cert_store;  // offset: 0xc
    lhash_st_SSL_SESSION * sessions;  // offset: 0x10
    ulong session_cache_size;  // offset: 0x14
    ssl_session_st * session_cache_head;  // offset: 0x18
    ssl_session_st * session_cache_tail;  // offset: 0x1c
    int session_cache_mode;  // offset: 0x20
    long session_timeout;  // offset: 0x24
    _func_3229 * new_session_cb;  // offset: 0x28
    _func_3230 * remove_session_cb;  // offset: 0x2c
    _func_3231 * get_session_cb;  // offset: 0x30
    _struct_621 stats;  // offset: 0x34
    int references;  // offset: 0x60
    _func_3232 * app_verify_callback;  // offset: 0x64
    void * app_verify_arg;  // offset: 0x68
    pem_password_cb * default_passwd_callback;  // offset: 0x6c
    void * default_passwd_callback_userdata;  // offset: 0x70
    _func_3233 * client_cert_cb;  // offset: 0x74
    _func_3234 * app_gen_cookie_cb;  // offset: 0x78
    _func_3235 * app_verify_cookie_cb;  // offset: 0x7c
    CRYPTO_EX_DATA ex_data;  // offset: 0x80
    EVP_MD * rsa_md5;  // offset: 0x88
    EVP_MD * md5;  // offset: 0x8c
    EVP_MD * sha1;  // offset: 0x90
    stack_st_X509 * extra_certs;  // offset: 0x94
    stack_st_SSL_COMP * comp_methods;  // offset: 0x98
    _func_3236 * info_callback;  // offset: 0x9c
    stack_st_X509_NAME * client_CA;  // offset: 0xa0
    ulong options;  // offset: 0xa4
    ulong mode;  // offset: 0xa8
    long max_cert_list;  // offset: 0xac
    cert_st * cert;  // offset: 0xb0
    int read_ahead;  // offset: 0xb4
    _func_3237 * msg_callback;  // offset: 0xb8
    void * msg_callback_arg;  // offset: 0xbc
    int verify_mode;  // offset: 0xc0
    uint sid_ctx_length;  // offset: 0xc4
    uchar sid_ctx[32];  // offset: 0xc8
    _func_3238 * default_verify_callback;  // offset: 0xe8
    GEN_SESSION_CB generate_session_id;  // offset: 0xec
    X509_VERIFY_PARAM * param;  // offset: 0xf0
    int quiet_shutdown;  // offset: 0xf4
    uint max_send_fragment;  // offset: 0xf8
    ENGINE * client_cert_engine;  // offset: 0xfc
    _func_3239 * tlsext_servername_callback;  // offset: 0x100
    void * tlsext_servername_arg;  // offset: 0x104
    uchar tlsext_tick_key_name[16];  // offset: 0x108
    uchar tlsext_tick_hmac_key[16];  // offset: 0x118
    uchar tlsext_tick_aes_key[16];  // offset: 0x128
    _func_3240 * tlsext_ticket_key_cb;  // offset: 0x138
    _func_3241 * tlsext_status_cb;  // offset: 0x13c
    void * tlsext_status_arg;  // offset: 0x140
    _func_3242 * tlsext_opaque_prf_input_callback;  // offset: 0x144
    void * tlsext_opaque_prf_input_callback_arg;  // offset: 0x148
    char * psk_identity_hint;  // offset: 0x14c
    _func_3243 * psk_client_callback;  // offset: 0x150
    _func_3244 * psk_server_callback;  // offset: 0x154
    uint freelist_max_len;  // offset: 0x158
    ssl3_buf_freelist_st * wbuf_freelist;  // offset: 0x15c
    ssl3_buf_freelist_st * rbuf_freelist;  // offset: 0x160
    _func_3245 * next_protos_advertised_cb;  // offset: 0x164
    void * next_protos_advertised_cb_arg;  // offset: 0x168
    _func_3246 * next_proto_select_cb;  // offset: 0x16c
    void * next_proto_select_cb_arg;  // offset: 0x170
    stack_st_SRTP_PROTECTION_PROFILE * srtp_profiles;  // offset: 0x174
}; // size: 0x178

struct ssl_method_st {
    int version;  // offset: 0x0
    _func_3195 * ssl_new;  // offset: 0x4
    _func_3196 * ssl_clear;  // offset: 0x8
    _func_3197 * ssl_free;  // offset: 0xc
    _func_3198 * ssl_accept;  // offset: 0x10
    _func_3199 * ssl_connect;  // offset: 0x14
    _func_3200 * ssl_read;  // offset: 0x18
    _func_3201 * ssl_peek;  // offset: 0x1c
    _func_3202 * ssl_write;  // offset: 0x20
    _func_3203 * ssl_shutdown;  // offset: 0x24
    _func_3204 * ssl_renegotiate;  // offset: 0x28
    _func_3205 * ssl_renegotiate_check;  // offset: 0x2c
    _func_3206 * ssl_get_message;  // offset: 0x30
    _func_3207 * ssl_read_bytes;  // offset: 0x34
    _func_3208 * ssl_write_bytes;  // offset: 0x38
    _func_3209 * ssl_dispatch_alert;  // offset: 0x3c
    _func_3210 * ssl_ctrl;  // offset: 0x40
    _func_3211 * ssl_ctx_ctrl;  // offset: 0x44
    _func_3212 * get_cipher_by_char;  // offset: 0x48
    _func_3213 * put_cipher_by_char;  // offset: 0x4c
    _func_3214 * ssl_pending;  // offset: 0x50
    _func_3215 * num_ciphers;  // offset: 0x54
    _func_3216 * get_cipher;  // offset: 0x58
    _func_3217 * get_ssl_method;  // offset: 0x5c
    _func_3218 * get_timeout;  // offset: 0x60
    ssl3_enc_method * ssl3_enc;  // offset: 0x64
    _func_3219 * ssl_version;  // offset: 0x68
    _func_3220 * ssl_callback_ctrl;  // offset: 0x6c
    _func_3222 * ssl_ctx_callback_ctrl;  // offset: 0x70
}; // size: 0x74

struct ssl_session_st {
    int ssl_version;  // offset: 0x0
    uint key_arg_length;  // offset: 0x4
    uchar key_arg[8];  // offset: 0x8
    int master_key_length;  // offset: 0x10
    uchar master_key[48];  // offset: 0x14
    uint session_id_length;  // offset: 0x44
    uchar session_id[32];  // offset: 0x48
    uint sid_ctx_length;  // offset: 0x68
    uchar sid_ctx[32];  // offset: 0x6c
    uint krb5_client_princ_len;  // offset: 0x8c
    uchar krb5_client_princ[256];  // offset: 0x90
    char * psk_identity_hint;  // offset: 0x190
    char * psk_identity;  // offset: 0x194
    int not_resumable;  // offset: 0x198
    sess_cert_st * sess_cert;  // offset: 0x19c
    X509 * peer;  // offset: 0x1a0
    long verify_result;  // offset: 0x1a4
    int references;  // offset: 0x1a8
    long timeout;  // offset: 0x1ac
    long time;  // offset: 0x1b0
    uint compress_meth;  // offset: 0x1b4
    SSL_CIPHER * cipher;  // offset: 0x1b8
    ulong cipher_id;  // offset: 0x1bc
    stack_st_SSL_CIPHER * ciphers;  // offset: 0x1c0
    CRYPTO_EX_DATA ex_data;  // offset: 0x1c4
    ssl_session_st * prev;  // offset: 0x1cc
    ssl_session_st * * next;  // offset: 0x1d0
    char * tlsext_hostname;  // offset: 0x1d4
    size_t tlsext_ecpointformatlist_length;  // offset: 0x1d8
    uchar * tlsext_ecpointformatlist;  // offset: 0x1dc
    size_t tlsext_ellipticcurvelist_length;  // offset: 0x1e0
    uchar * tlsext_ellipticcurvelist;  // offset: 0x1e4
    uchar * tlsext_tick;  // offset: 0x1e8
    size_t tlsext_ticklen;  // offset: 0x1ec
    long tlsext_tick_lifetime_hint;  // offset: 0x1f0
}; // size: 0x1f4

struct ssl_st {
    // Empty structure
}; // size: 0x1

struct ssl_st {
    int version;  // offset: 0x0
    int type;  // offset: 0x4
    SSL_METHOD * method;  // offset: 0x8
    BIO * rbio;  // offset: 0xc
    BIO * wbio;  // offset: 0x10
    BIO * bbio;  // offset: 0x14
    int rwstate;  // offset: 0x18
    int in_handshake;  // offset: 0x1c
    _func_3291 * handshake_func;  // offset: 0x20
    int server;  // offset: 0x24
    int new_session;  // offset: 0x28
    int quiet_shutdown;  // offset: 0x2c
    int shutdown;  // offset: 0x30
    int state;  // offset: 0x34
    int rstate;  // offset: 0x38
    BUF_MEM * init_buf;  // offset: 0x3c
    void * init_msg;  // offset: 0x40
    int init_num;  // offset: 0x44
    int init_off;  // offset: 0x48
    uchar * packet;  // offset: 0x4c
    uint packet_length;  // offset: 0x50
    ssl2_state_st * s2;  // offset: 0x54
    ssl3_state_st * s3;  // offset: 0x58
    dtls1_state_st * d1;  // offset: 0x5c
    int read_ahead;  // offset: 0x60
    _func_3292 * msg_callback;  // offset: 0x64
    void * msg_callback_arg;  // offset: 0x68
    int hit;  // offset: 0x6c
    X509_VERIFY_PARAM * param;  // offset: 0x70
    stack_st_SSL_CIPHER * cipher_list;  // offset: 0x74
    stack_st_SSL_CIPHER * cipher_list_by_id;  // offset: 0x78
    int mac_flags;  // offset: 0x7c
    EVP_CIPHER_CTX * enc_read_ctx;  // offset: 0x80
    EVP_MD_CTX * read_hash;  // offset: 0x84
    COMP_CTX * expand;  // offset: 0x88
    EVP_CIPHER_CTX * enc_write_ctx;  // offset: 0x8c
    EVP_MD_CTX * write_hash;  // offset: 0x90
    COMP_CTX * compress;  // offset: 0x94
    cert_st * cert;  // offset: 0x98
    uint sid_ctx_length;  // offset: 0x9c
    uchar sid_ctx[32];  // offset: 0xa0
    SSL_SESSION * session;  // offset: 0xc0
    GEN_SESSION_CB generate_session_id;  // offset: 0xc4
    int verify_mode;  // offset: 0xc8
    _func_3293 * verify_callback;  // offset: 0xcc
    _func_3294 * info_callback;  // offset: 0xd0
    int error;  // offset: 0xd4
    int error_code;  // offset: 0xd8
    KSSL_CTX * kssl_ctx;  // offset: 0xdc
    _func_3295 * psk_client_callback;  // offset: 0xe0
    _func_3296 * psk_server_callback;  // offset: 0xe4
    SSL_CTX * ctx;  // offset: 0xe8
    int debug;  // offset: 0xec
    long verify_result;  // offset: 0xf0
    CRYPTO_EX_DATA ex_data;  // offset: 0xf4
    stack_st_X509_NAME * client_CA;  // offset: 0xfc
    int references;  // offset: 0x100
    ulong options;  // offset: 0x104
    ulong mode;  // offset: 0x108
    long max_cert_list;  // offset: 0x10c
    int first_packet;  // offset: 0x110
    int client_version;  // offset: 0x114
    uint max_send_fragment;  // offset: 0x118
    _func_3297 * tlsext_debug_cb;  // offset: 0x11c
    void * tlsext_debug_arg;  // offset: 0x120
    char * tlsext_hostname;  // offset: 0x124
    int servername_done;  // offset: 0x128
    int tlsext_status_type;  // offset: 0x12c
    int tlsext_status_expected;  // offset: 0x130
    stack_st_OCSP_RESPID * tlsext_ocsp_ids;  // offset: 0x134
    X509_EXTENSIONS * tlsext_ocsp_exts;  // offset: 0x138
    uchar * tlsext_ocsp_resp;  // offset: 0x13c
    int tlsext_ocsp_resplen;  // offset: 0x140
    int tlsext_ticket_expected;  // offset: 0x144
    size_t tlsext_ecpointformatlist_length;  // offset: 0x148
    uchar * tlsext_ecpointformatlist;  // offset: 0x14c
    size_t tlsext_ellipticcurvelist_length;  // offset: 0x150
    uchar * tlsext_ellipticcurvelist;  // offset: 0x154
    void * tlsext_opaque_prf_input;  // offset: 0x158
    size_t tlsext_opaque_prf_input_len;  // offset: 0x15c
    TLS_SESSION_TICKET_EXT * tlsext_session_ticket;  // offset: 0x160
    tls_session_ticket_ext_cb_fn tls_session_ticket_ext_cb;  // offset: 0x164
    void * tls_session_ticket_ext_cb_arg;  // offset: 0x168
    tls_session_secret_cb_fn tls_session_secret_cb;  // offset: 0x16c
    void * tls_session_secret_cb_arg;  // offset: 0x170
    SSL_CTX * initial_ctx;  // offset: 0x174
    uchar * next_proto_negotiated;  // offset: 0x178
    uchar next_proto_negotiated_len;  // offset: 0x17c
    stack_st_SRTP_PROTECTION_PROFILE * srtp_profiles;  // offset: 0x180
    SRTP_PROTECTION_PROFILE * srtp_profile;  // offset: 0x184
    uint tlsext_heartbeat;  // offset: 0x188
    uint tlsext_hb_pending;  // offset: 0x18c
    uint tlsext_hb_seq;  // offset: 0x190
    int renegotiate;  // offset: 0x194
}; // size: 0x198

struct stack_st {
    int num;  // offset: 0x0
    char * * data;  // offset: 0x4
    int sorted;  // offset: 0x8
    int num_alloc;  // offset: 0xc
    _func_290 * comp;  // offset: 0x10
}; // size: 0x14

struct stack_st_ACCESS_DESCRIPTION {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_ASIdOrRange {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_ASN1_INTEGER {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_ASN1_OBJECT {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_ASN1_TYPE {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_CMS_RecipientInfo {
    // Empty structure
}; // size: 0x1

struct stack_st_CMS_SignerInfo {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_CONF_VALUE {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_DIST_POINT {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_GENERAL_NAME {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_GENERAL_NAMES {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_GENERAL_SUBTREE {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_IPAddressFamily {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_IPAddressOrRange {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_OCSP_ONEREQ {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_OCSP_RESPID {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_OCSP_SINGLERESP {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_OPENSSL_PSTRING {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_OPENSSL_STRING {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_PKCS12_SAFEBAG {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_PKCS7 {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_PKCS7_RECIP_INFO {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_PKCS7_SIGNER_INFO {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_POLICYINFO {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_POLICYQUALINFO {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_SRTP_PROTECTION_PROFILE {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_SSL_CIPHER {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_SSL_COMP {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_SXNETID {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509 {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_ALGOR {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_ATTRIBUTE {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_CRL {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_EXTENSION {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_INFO {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_LOOKUP {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_NAME {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_NAME_ENTRY {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_OBJECT {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_POLICY_NODE {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_X509_REVOKED {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stack_st_void {
    _STACK stack;  // offset: 0x0
}; // size: 0x14

struct stat {
    __dev_t st_dev;  // offset: 0x0
    ushort __pad1;  // offset: 0x8
    __ino_t st_ino;  // offset: 0xc
    __mode_t st_mode;  // offset: 0x10
    __nlink_t st_nlink;  // offset: 0x14
    __uid_t st_uid;  // offset: 0x18
    __gid_t st_gid;  // offset: 0x1c
    __dev_t st_rdev;  // offset: 0x20
    ushort __pad2;  // offset: 0x28
    __off_t st_size;  // offset: 0x2c
    __blksize_t st_blksize;  // offset: 0x30
    __blkcnt_t st_blocks;  // offset: 0x34
    timespec st_atim;  // offset: 0x38
    timespec st_mtim;  // offset: 0x40
    timespec st_ctim;  // offset: 0x48
    ulong __glibc_reserved4;  // offset: 0x50
    ulong __glibc_reserved5;  // offset: 0x54
}; // size: 0x58

struct stat {
    __dev_t st_dev;  // offset: 0x0
    ushort __pad1;  // offset: 0x8
    __ino_t st_ino;  // offset: 0xc
    __mode_t st_mode;  // offset: 0x10
    __nlink_t st_nlink;  // offset: 0x14
    __uid_t st_uid;  // offset: 0x18
    __gid_t st_gid;  // offset: 0x1c
    __dev_t st_rdev;  // offset: 0x20
    ushort __pad2;  // offset: 0x28
    __off_t st_size;  // offset: 0x2c
    __blksize_t st_blksize;  // offset: 0x30
    __blkcnt_t st_blocks;  // offset: 0x34
    timespec st_atim;  // offset: 0x38
    timespec st_mtim;  // offset: 0x40
    timespec st_ctim;  // offset: 0x48
    ulong __unused4;  // offset: 0x50
    ulong __unused5;  // offset: 0x54
}; // size: 0x58

struct strbuffer_t {
    char * value;  // offset: 0x0
    size_t length;  // offset: 0x4
    size_t size;  // offset: 0x8
}; // size: 0xc

struct stream_t {
    get_func get;  // offset: 0x0
    void * data;  // offset: 0x4
    char buffer[5];  // offset: 0x8
    size_t buffer_pos;  // offset: 0x10
    int state;  // offset: 0x14
    int line;  // offset: 0x18
    int column;  // offset: 0x1c
    int last_column;  // offset: 0x20
    size_t position;  // offset: 0x24
}; // size: 0x28

struct string_data_t {
    char * data;  // offset: 0x0
    size_t pos;  // offset: 0x4
}; // size: 0x8

struct sweep_bad_asic_info_t {
    int bad_asic_num;  // offset: 0x0
    int bad_asic_ids[12];  // offset: 0x4
}; // size: 0x34

struct sweep_err_state {
    int err_val;  // offset: 0x0
    _Bool consumed;  // offset: 0x4
}; // size: 0x8

struct sweep_result_t {
    uint16_t hashrate;  // offset: 0x0
    uint16_t freq_base;  // offset: 0x2
    uint8_t freq_step;  // offset: 0x4
    uint32_t freqs[256];  // offset: 0x8
    _Bool is_pass;  // offset: 0x408
}; // size: 0x40c

struct sync_serial_settings {
    uint clock_rate;  // offset: 0x0
    uint clock_type;  // offset: 0x4
    ushort loopback;  // offset: 0x8
}; // size: 0xc

struct sysinfo {
    __kernel_long_t uptime;  // offset: 0x0
    __kernel_ulong_t loads[3];  // offset: 0x4
    __kernel_ulong_t totalram;  // offset: 0x10
    __kernel_ulong_t freeram;  // offset: 0x14
    __kernel_ulong_t sharedram;  // offset: 0x18
    __kernel_ulong_t bufferram;  // offset: 0x1c
    __kernel_ulong_t totalswap;  // offset: 0x20
    __kernel_ulong_t freeswap;  // offset: 0x24
    __u16 procs;  // offset: 0x28
    __u16 pad;  // offset: 0x2a
    __kernel_ulong_t totalhigh;  // offset: 0x2c
    __kernel_ulong_t freehigh;  // offset: 0x30
    __u32 mem_unit;  // offset: 0x34
    char _f[8];  // offset: 0x38
}; // size: 0x40

struct sysinfo {
    long uptime;  // offset: 0x0
    ulong loads[3];  // offset: 0x4
    ulong totalram;  // offset: 0x10
    ulong freeram;  // offset: 0x14
    ulong sharedram;  // offset: 0x18
    ulong bufferram;  // offset: 0x1c
    ulong totalswap;  // offset: 0x20
    ulong freeswap;  // offset: 0x24
    ushort procs;  // offset: 0x28
    ushort pad;  // offset: 0x2a
    ulong totalhigh;  // offset: 0x2c
    ulong freehigh;  // offset: 0x30
    uint mem_unit;  // offset: 0x34
    char _f[8];  // offset: 0x38
}; // size: 0x40

struct te1_settings {
    uint clock_rate;  // offset: 0x0
    uint clock_type;  // offset: 0x4
    ushort loopback;  // offset: 0x8
    uint slot_map;  // offset: 0xc
}; // size: 0x10

struct temperature {
    int32_t Start_Temp_Gap_Pic;  // offset: 0x0
    uint32_t Max_Wait_Cooling_Down_Time;  // offset: 0x4
    uint32_t Time_For_Cooling_Hashboard;  // offset: 0x8
    int32_t Max_Board_Temp;  // offset: 0xc
}; // size: 0x10

struct termios {
    tcflag_t c_iflag;  // offset: 0x0
    tcflag_t c_oflag;  // offset: 0x4
    tcflag_t c_cflag;  // offset: 0x8
    tcflag_t c_lflag;  // offset: 0xc
    cc_t c_line;  // offset: 0x10
    cc_t c_cc[32];  // offset: 0x11
    speed_t c_ispeed;  // offset: 0x34
    speed_t c_ospeed;  // offset: 0x38
}; // size: 0x3c

struct test_info {
    _Bool Factory_Mode;  // offset: 0x0
    _Bool Bypass_Scan_Code_Gun;  // offset: 0x1
    int Max_PT1_Board_Poweron_Time;  // offset: 0x4
    Test_Method Test_Method;  // offset: 0x8
    Sweep_Cfg Sweep_Cfg;  // offset: 0x14
    Test_Standard Test_Standard;  // offset: 0x2c
    Test_Speed Test_Speed;  // offset: 0x364
    Asic_Register Asic_Register;  // offset: 0x36c
    Temperature Temperature;  // offset: 0x38c
    Fan Fan;  // offset: 0x39c
    Display Display;  // offset: 0x3a8
    _Bool Find_Stupid_Asic;  // offset: 0x3aa
    int Freq_Flex;  // offset: 0x3ac
    char Test_Config_Data_Version[16];  // offset: 0x3b0
    uint32_t Voltage_Accuracy;  // offset: 0x3c0
}; // size: 0x3c4

struct test_info_t {
    char file_path[128];  // offset: 0x0
    char test_type[128];  // offset: 0x80
    char sn[128];  // offset: 0x100
    char miner_type[128];  // offset: 0x180
    char fac[128];  // offset: 0x200
    char boardname[128];  // offset: 0x280
}; // size: 0x300

struct test_loop {
    uint32_t Level;  // offset: 0x0
    uint32_t Pre_Open_Core_Voltage;  // offset: 0x4
    uint32_t Voltage;  // offset: 0x8
    uint32_t Frequence;  // offset: 0xc
}; // size: 0x10

struct test_method {
    _Bool Software_Pattern;  // offset: 0x0
    _Bool Super_Software_Pattern;  // offset: 0x1
    _Bool Hardware_Pattern;  // offset: 0x2
    _Bool Autogen_Pattern;  // offset: 0x3
    uint32_t Midstate_Number;  // offset: 0x4
    _Bool Capture_Pattern;  // offset: 0x8
}; // size: 0xc

struct test_pattern_new {
    uchar midstate[8];  // offset: 0x0
    uint32_t nonce;  // offset: 0x8
}; // size: 0xc

struct test_speed {
    uint32_t Baudrate;  // offset: 0x0
    uint32_t Timeout;  // offset: 0x4
}; // size: 0x8

struct test_standard {
    uint32_t Pattern_Number;  // offset: 0x0
    uint32_t Invalid_Core_Number;  // offset: 0x4
    uint32_t Least_Nonce_Per_Core;  // offset: 0x8
    uint32_t Nonce_Rate;  // offset: 0xc
    uint32_t Most_HW_Num;  // offset: 0x10
    uint32_t Asic_Nonce_Rate;  // offset: 0x14
    Test_Loop Test_Loop[50];  // offset: 0x18
}; // size: 0x338

struct timespec {
    __time_t tv_sec;  // offset: 0x0
    __syscall_slong_t tv_nsec;  // offset: 0x4
}; // size: 0x8

struct timespec {
    __time_t tv_sec;  // offset: 0x0
    long tv_nsec;  // offset: 0x4
}; // size: 0x8

struct timeval {
    __time_t tv_sec;  // offset: 0x0
    __suseconds_t tv_usec;  // offset: 0x4
}; // size: 0x8

struct timeval {
    __time_t tv_sec;  // offset: 0x0
    __suseconds_t tv_usec;  // offset: 0x4
}; // size: 0x8

struct timezone {
    int tz_minuteswest;  // offset: 0x0
    int tz_dsttime;  // offset: 0x4
}; // size: 0x8

struct timezone {
    int tz_minuteswest;  // offset: 0x0
    int tz_dsttime;  // offset: 0x4
}; // size: 0x8

struct tls_session_ticket_ext_st {
    ushort length;  // offset: 0x0
    void * data;  // offset: 0x4
}; // size: 0x8

struct tm {
    int tm_sec;  // offset: 0x0
    int tm_min;  // offset: 0x4
    int tm_hour;  // offset: 0x8
    int tm_mday;  // offset: 0xc
    int tm_mon;  // offset: 0x10
    int tm_year;  // offset: 0x14
    int tm_wday;  // offset: 0x18
    int tm_yday;  // offset: 0x1c
    int tm_isdst;  // offset: 0x20
    long tm_gmtoff;  // offset: 0x24
    char * tm_zone;  // offset: 0x28
}; // size: 0x2c

struct tm {
    int tm_sec;  // offset: 0x0
    int tm_min;  // offset: 0x4
    int tm_hour;  // offset: 0x8
    int tm_mday;  // offset: 0xc
    int tm_mon;  // offset: 0x10
    int tm_year;  // offset: 0x14
    int tm_wday;  // offset: 0x18
    int tm_yday;  // offset: 0x1c
    int tm_isdst;  // offset: 0x20
    long tm_gmtoff;  // offset: 0x24
    char * tm_zone;  // offset: 0x28
}; // size: 0x2c

struct tm.conflict {
    int tm_sec;  // offset: 0x0
    int tm_min;  // offset: 0x4
    int tm_hour;  // offset: 0x8
    int tm_mday;  // offset: 0xc
    int tm_mon;  // offset: 0x10
    int tm_year;  // offset: 0x14
    int tm_wday;  // offset: 0x18
    int tm_yday;  // offset: 0x1c
    int tm_isdst;  // offset: 0x20
    long __tm_gmtoff;  // offset: 0x24
    char * __tm_zone;  // offset: 0x28
}; // size: 0x2c

struct txt_db_st {
    int num_fields;  // offset: 0x0
    stack_st_OPENSSL_PSTRING * data;  // offset: 0x4
    lhash_st_OPENSSL_STRING * * index;  // offset: 0x8
    _func_4786 * * qual;  // offset: 0xc
    long error;  // offset: 0x10
    long arg1;  // offset: 0x14
    long arg2;  // offset: 0x18
    OPENSSL_STRING * arg_row;  // offset: 0x1c
}; // size: 0x20

struct ui_method_st {
    // Empty structure
}; // size: 0x1

struct ui_st {
    // Empty structure
}; // size: 0x1

struct ui_string_st {
    // Empty structure
}; // size: 0x1

struct utsname {
    char sysname[65];  // offset: 0x0
    char nodename[65];  // offset: 0x41
    char release[65];  // offset: 0x82
    char version[65];  // offset: 0xc3
    char machine[65];  // offset: 0x104
    char domainname[65];  // offset: 0x145
}; // size: 0x186

struct v3_ext_ctx {
    int flags;  // offset: 0x0
    X509 * issuer_cert;  // offset: 0x4
    X509 * subject_cert;  // offset: 0x8
    X509_REQ * subject_req;  // offset: 0xc
    X509_CRL * crl;  // offset: 0x10
    X509V3_CONF_METHOD * db_meth;  // offset: 0x14
    void * db;  // offset: 0x18
}; // size: 0x1c

struct v3_ext_method {
    int ext_nid;  // offset: 0x0
    int ext_flags;  // offset: 0x4
    ASN1_ITEM_EXP * it;  // offset: 0x8
    X509V3_EXT_NEW ext_new;  // offset: 0xc
    X509V3_EXT_FREE ext_free;  // offset: 0x10
    X509V3_EXT_D2I d2i;  // offset: 0x14
    X509V3_EXT_I2D i2d;  // offset: 0x18
    X509V3_EXT_I2S i2s;  // offset: 0x1c
    X509V3_EXT_S2I s2i;  // offset: 0x20
    X509V3_EXT_I2V i2v;  // offset: 0x24
    X509V3_EXT_V2I v2i;  // offset: 0x28
    X509V3_EXT_I2R i2r;  // offset: 0x2c
    X509V3_EXT_R2I r2i;  // offset: 0x30
    void * usr_data;  // offset: 0x34
}; // size: 0x38

struct work_format {
    uint8_t work_type;  // offset: 0x0
    uint8_t chain_id;  // offset: 0x1
    uint8_t reserved1[2];  // offset: 0x2
    uint32_t work_count;  // offset: 0x4
    uint8_t data[12];  // offset: 0x8
    uint8_t[32] midstate[16];  // offset: 0x14
}; // size: 0x214

struct work_new {
    uint32_t is_nonce_return_back;  // offset: 0x0
    test_pattern_new pattern;  // offset: 0x4
}; // size: 0x10

struct x509_attributes_st {
    ASN1_OBJECT * object;  // offset: 0x0
    int single;  // offset: 0x4
    _union_336 value;  // offset: 0x8
}; // size: 0xc

struct x509_cert_aux_st {
    stack_st_ASN1_OBJECT * trust;  // offset: 0x0
    stack_st_ASN1_OBJECT * reject;  // offset: 0x4
    ASN1_UTF8STRING * alias;  // offset: 0x8
    ASN1_OCTET_STRING * keyid;  // offset: 0xc
    stack_st_X509_ALGOR * other;  // offset: 0x10
}; // size: 0x14

struct x509_cinf_st {
    ASN1_INTEGER * version;  // offset: 0x0
    ASN1_INTEGER * serialNumber;  // offset: 0x4
    X509_ALGOR * signature;  // offset: 0x8
    X509_NAME * issuer;  // offset: 0xc
    X509_VAL * validity;  // offset: 0x10
    X509_NAME * subject;  // offset: 0x14
    X509_PUBKEY * key;  // offset: 0x18
    ASN1_BIT_STRING * issuerUID;  // offset: 0x1c
    ASN1_BIT_STRING * subjectUID;  // offset: 0x20
    stack_st_X509_EXTENSION * extensions;  // offset: 0x24
    ASN1_ENCODING enc;  // offset: 0x28
}; // size: 0x34

struct x509_crl_method_st {
    // Empty structure
}; // size: 0x1

struct x509_lookup_method_st {
    char * name;  // offset: 0x0
    _func_1976 * new_item;  // offset: 0x4
    _func_1977 * free;  // offset: 0x8
    _func_1978 * init;  // offset: 0xc
    _func_1979 * shutdown;  // offset: 0x10
    _func_1980 * ctrl;  // offset: 0x14
    _func_1981 * get_by_subject;  // offset: 0x18
    _func_1982 * get_by_issuer_serial;  // offset: 0x1c
    _func_1983 * get_by_fingerprint;  // offset: 0x20
    _func_1984 * get_by_alias;  // offset: 0x24
}; // size: 0x28

struct x509_lookup_st {
    int init;  // offset: 0x0
    int skip;  // offset: 0x4
    X509_LOOKUP_METHOD * method;  // offset: 0x8
    char * method_data;  // offset: 0xc
    X509_STORE * store_ctx;  // offset: 0x10
}; // size: 0x14

struct x509_object_st {
    int type;  // offset: 0x0
    _union_387 data;  // offset: 0x4
}; // size: 0x8

struct x509_purpose_st {
    int purpose;  // offset: 0x0
    int trust;  // offset: 0x4
    int flags;  // offset: 0x8
    _func_4299 * check_purpose;  // offset: 0xc
    char * name;  // offset: 0x10
    char * sname;  // offset: 0x14
    void * usr_data;  // offset: 0x18
}; // size: 0x1c

struct x509_revoked_st {
    ASN1_INTEGER * serialNumber;  // offset: 0x0
    ASN1_TIME * revocationDate;  // offset: 0x4
    stack_st_X509_EXTENSION * extensions;  // offset: 0x8
    stack_st_GENERAL_NAME * issuer;  // offset: 0xc
    int reason;  // offset: 0x10
    int sequence;  // offset: 0x14
}; // size: 0x18

struct x509_st {
    X509_CINF * cert_info;  // offset: 0x0
    X509_ALGOR * sig_alg;  // offset: 0x4
    ASN1_BIT_STRING * signature;  // offset: 0x8
    int valid;  // offset: 0xc
    int references;  // offset: 0x10
    char * name;  // offset: 0x14
    CRYPTO_EX_DATA ex_data;  // offset: 0x18
    long ex_pathlen;  // offset: 0x20
    long ex_pcpathlen;  // offset: 0x24
    ulong ex_flags;  // offset: 0x28
    ulong ex_kusage;  // offset: 0x2c
    ulong ex_xkusage;  // offset: 0x30
    ulong ex_nscert;  // offset: 0x34
    ASN1_OCTET_STRING * skid;  // offset: 0x38
    AUTHORITY_KEYID * akid;  // offset: 0x3c
    X509_POLICY_CACHE * policy_cache;  // offset: 0x40
    stack_st_DIST_POINT * crldp;  // offset: 0x44
    stack_st_GENERAL_NAME * altname;  // offset: 0x48
    NAME_CONSTRAINTS * nc;  // offset: 0x4c
    stack_st_IPAddressFamily * rfc3779_addr;  // offset: 0x50
    ASIdentifiers_st * rfc3779_asid;  // offset: 0x54
    uchar sha1_hash[20];  // offset: 0x58
    X509_CERT_AUX * aux;  // offset: 0x6c
}; // size: 0x70

struct x509_store_ctx_st {
    X509_STORE * ctx;  // offset: 0x0
    int current_method;  // offset: 0x4
    X509 * cert;  // offset: 0x8
    stack_st_X509 * untrusted;  // offset: 0xc
    stack_st_X509_CRL * crls;  // offset: 0x10
    X509_VERIFY_PARAM * param;  // offset: 0x14
    void * other_ctx;  // offset: 0x18
    _func_1997 * verify;  // offset: 0x1c
    _func_1998 * verify_cb;  // offset: 0x20
    _func_1999 * get_issuer;  // offset: 0x24
    _func_2000 * check_issued;  // offset: 0x28
    _func_2001 * check_revocation;  // offset: 0x2c
    _func_2002 * get_crl;  // offset: 0x30
    _func_2003 * check_crl;  // offset: 0x34
    _func_2004 * cert_crl;  // offset: 0x38
    _func_2005 * check_policy;  // offset: 0x3c
    _func_2006 * lookup_certs;  // offset: 0x40
    _func_2007 * lookup_crls;  // offset: 0x44
    _func_2008 * cleanup;  // offset: 0x48
    int valid;  // offset: 0x4c
    int last_untrusted;  // offset: 0x50
    stack_st_X509 * chain;  // offset: 0x54
    X509_POLICY_TREE * tree;  // offset: 0x58
    int explicit_policy;  // offset: 0x5c
    int error_depth;  // offset: 0x60
    int error;  // offset: 0x64
    X509 * current_cert;  // offset: 0x68
    X509 * current_issuer;  // offset: 0x6c
    X509_CRL * current_crl;  // offset: 0x70
    int current_crl_score;  // offset: 0x74
    uint current_reasons;  // offset: 0x78
    X509_STORE_CTX * parent;  // offset: 0x7c
    CRYPTO_EX_DATA ex_data;  // offset: 0x80
}; // size: 0x88

struct x509_store_st {
    int cache;  // offset: 0x0
    stack_st_X509_OBJECT * objs;  // offset: 0x4
    stack_st_X509_LOOKUP * get_cert_methods;  // offset: 0x8
    X509_VERIFY_PARAM * param;  // offset: 0xc
    _func_1985 * verify;  // offset: 0x10
    _func_1986 * verify_cb;  // offset: 0x14
    _func_1987 * get_issuer;  // offset: 0x18
    _func_1988 * check_issued;  // offset: 0x1c
    _func_1989 * check_revocation;  // offset: 0x20
    _func_1990 * get_crl;  // offset: 0x24
    _func_1991 * check_crl;  // offset: 0x28
    _func_1992 * cert_crl;  // offset: 0x2c
    _func_1993 * lookup_certs;  // offset: 0x30
    _func_1994 * lookup_crls;  // offset: 0x34
    _func_1995 * cleanup;  // offset: 0x38
    CRYPTO_EX_DATA ex_data;  // offset: 0x3c
    int references;  // offset: 0x44
}; // size: 0x48

struct x509_trust_st {
    int trust;  // offset: 0x0
    int flags;  // offset: 0x4
    _func_1956 * check_trust;  // offset: 0x8
    char * name;  // offset: 0xc
    int arg1;  // offset: 0x10
    void * arg2;  // offset: 0x14
}; // size: 0x18

struct zhiju_eeprom_data_map {
    uint8_t algorithm_and_key_version;  // offset: 0x0
    uint8_t zhiju_information_length;  // offset: 0x1
    zhiju_information zhiju_information;  // offset: 0x2
}; // size: 0x47

struct zhiju_information {
    uint8_t zhiju_information_format_version;  // offset: 0x0
    uint8_t hashboard_sn[17];  // offset: 0x1
    uint8_t chip_die[2];  // offset: 0x12
    uint8_t chip_marking[13];  // offset: 0x14
    uint8_t chip_bin;  // offset: 0x21
    uint8_t chip_ft_program_version[9];  // offset: 0x22
    uint8_t asic_sensor;  // offset: 0x2b
    uint8_t asic_sensor_addr[4];  // offset: 0x2c
    uint8_t pic_sensor;  // offset: 0x30
    uint8_t pic_sensor_addr;  // offset: 0x31
    uint8_t pcb_version_v1;  // offset: 0x32
    uint8_t pcb_version_v2;  // offset: 0x33
    uint8_t bom_version_v1;  // offset: 0x34
    uint8_t bom_version_v2;  // offset: 0x35
    uint8_t chip_technology[2];  // offset: 0x36
    uint8_t voltage[2];  // offset: 0x38
    uint8_t frequency[2];  // offset: 0x3a
    uint8_t nonce_rate[2];  // offset: 0x3c
    int8_t pcb_temprature_in;  // offset: 0x3e
    int8_t pcb_temprature_out;  // offset: 0x3f
    uint8_t test_version;  // offset: 0x40
    uint8_t test_standard;  // offset: 0x41
    uint8_t reserve[2];  // offset: 0x42
    uint8_t zhiju_information_crc5;  // offset: 0x44
}; // size: 0x45

/* ==================== Unions ==================== */

union LZ4_streamDecode_u {
    char[32] minStateSize;
    LZ4_streamDecode_t_internal internal_donotuse;
}; // size: 0x20

union LZ4_streamHC_u {
    char[262200] minStateSize;
    LZ4HC_CCtx_internal internal_donotuse;
}; // size: 0x40038

union LZ4_stream_u {
    char[16416] minStateSize;
    LZ4_stream_t_internal internal_donotuse;
}; // size: 0x4020

union LZ4_unalign {
    U16 u16;
    U32 u32;
    reg_t uArch;
}; // size: 0x4

union _analog_mux_control_t {
    anon_struct_4_2_84162d83_for_u u;
    uint32_t v;
}; // size: 0x4

union _auto_clk_en_t {
    anon_struct_2_4_bd7cc306_for_u u;
    uint16_t v;
}; // size: 0x2

union _chain_inactive_t {
    anon_struct_5_8_15bfd022_for_u u;
    uint8_t[5] v;
}; // size: 0x5

union _chip_nonce_offset_t {
    anon_struct_4_3_759a448f_for_u u;
    uint32_t v;
}; // size: 0x4

union _clock_delay_ctrl_t {
    anon_struct_1_5_2d401d3c_for_u u;
    uint8_t v;
}; // size: 0x1

union _clock_select_ctrl_t {
    anon_struct_2_4_e5384816_for_u u;
    uint16_t v;
}; // size: 0x2

union _core_command_t {
    anon_struct_4_8_6d10a169_for_u u;
    uint8_t[4] v;
    uint32_t v_32;
}; // size: 0x4

union _core_enable_t {
    anon_struct_2_2_c6ab8785_for_u u;
    uint16_t v;
}; // size: 0x2

union _fast_UART_configuration_t {
    anon_struct_4_13_422ceaf4_for_u u;
    uint32_t v;
}; // size: 0x4

union _fpga_bt8d_t {
    anon_struct_4_8_ad5e9fc5_for_u u;
    uint32_t v;
}; // size: 0x4

union _frequency_sweep_control_t {
    anon_struct_4_18_a6851311_for_u u;
    uint32_t v;
}; // size: 0x4

union _general_i2c_command_t {
    anon_struct_4_10_b75caf2b_for_u u;
    uint32_t v;
}; // size: 0x4

union _get_status_t {
    anon_struct_5_9_f9e27364_for_u u;
    uint8_t[5] v;
}; // size: 0x5

union _hash_clock_ctrl_t {
    anon_struct_2_2_d78050c7_for_u u;
    uint16_t v;
}; // size: 0x2

union _io_driver_strength_cfg_t {
    anon_struct_4_8_bac425d5_for_u u;
    uint32_t v;
}; // size: 0x4

union _midstate_cal_register_t {
    anon_struct_4_5_399a9cf7_for_u u;
    uint32_t v;
}; // size: 0x4

union _misc_control_t {
    anon_struct_4_18_3f3fc8fd_for_u u;
    uint32_t v;
}; // size: 0x4

union _nonce_bin_overflow_control_t {
    anon_struct_2_6_81fe2f07_for_u u;
    uint16_t v;
}; // size: 0x2

union _nonce_bin_overflow_t {
    anon_struct_2_5_1a639049_for_u u;
    uint16_t v;
}; // size: 0x2

union _ocv_pulse_width_t {
    anon_struct_2_3_e7583c08_for_u u;
    uint16_t v;
}; // size: 0x2

union _ordered_clock_enable {
    anon_struct_4_3_b0bb6857_for_u u;
    uint32_t v;
}; // size: 0x4

union _pad_check {
    anon_struct_4_19_15a1c2d0_for_u u;
    uint32_t v;
}; // size: 0x4

union _pll_parameter_t {
    anon_struct_4_12_17032573_for_u u;
    uint32_t v;
}; // size: 0x4

union _process_monitor_ctrl_t {
    anon_struct_2_3_d58cde66_for_u u;
    uint16_t v;
}; // size: 0x2

union _return_nonce_128bit_t {
    anon_struct_16_14_521757b1_for_nonce nonce;
    anon_struct_16_11_6b887386_for_reg reg;
    uint32_t[4] buf;
}; // size: 0x10

union _returned_nonce_counter_t {
    anon_struct_4_2_9e97f829_for_u u;
    uint32_t v;
}; // size: 0x4

union _rosc_pad_dis_t {
    anon_struct_4_1_413bbfcc_for_u u;
    uint32_t v;
}; // size: 0x4

union _set_address_t {
    anon_struct_5_8_110e986d_for_u u;
    uint8_t[5] v;
}; // size: 0x5

union _set_config_t {
    anon_struct_9_9_23b62a12_for_u u;
    uint8_t[9] v;
}; // size: 0x9

union _soft_reset_control_t {
    anon_struct_4_8_fb3c3b36_for_u u;
    uint32_t v;
}; // size: 0x4

union _sweep_clk_mode_ctrl_t {
    anon_struct_4_4_a1dac117_for_u u;
    uint32_t v;
}; // size: 0x4

union _temp_ctrl_t_ {
    anon_struct_4_11_bb44c716_for_u u;
    uint32_t v;
}; // size: 0x4

union _tick_nonce_counter_t {
    anon_struct_4_1_397754f6_for_u u;
    uint32_t v;
}; // size: 0x4

union _ticket_mask_t {
    anon_struct_4_4_08564e81_for_u u;
    uint32_t v;
}; // size: 0x4

union _uart_relay_t {
    anon_struct_4_5_b8274f34_for_u u;
    uint32_t v;
}; // size: 0x4

union _union_1015 {
    uchar[64] c;
    double[8] q;
}; // size: 0x40

union _union_1031 {
    int[29] _pad;
    _struct_1032 _kill;
    _struct_1033 _timer;
    _struct_1034 _rt;
    _struct_1035 _sigchld;
    _struct_1036 _sigfault;
    _struct_1037 _sigpoll;
}; // size: 0x74

union _union_1051 {
    __sighandler_t sa_handler;
    _func_4848 * sa_sigaction;
}; // size: 0x4

union _union_13 {
    int __spins;
    __pthread_slist_t __list;
}; // size: 0x4

union _union_181 {
    _func_556 * cb_1;
    _func_557 * cb_2;
}; // size: 0x4

union _union_24 {
    DES_cblock cblock;
    uint[2] deslong;
}; // size: 0x8

union _union_263 {
    char * ptr;
    ASN1_BOOLEAN boolean;
    ASN1_STRING * asn1_string;
    ASN1_OBJECT * object;
    ASN1_INTEGER * integer;
    ASN1_ENUMERATED * enumerated;
    ASN1_BIT_STRING * bit_string;
    ASN1_OCTET_STRING * octet_string;
    ASN1_PRINTABLESTRING * printablestring;
    ASN1_T61STRING * t61string;
    ASN1_IA5STRING * ia5string;
    ASN1_GENERALSTRING * generalstring;
    ASN1_BMPSTRING * bmpstring;
    ASN1_UNIVERSALSTRING * universalstring;
    ASN1_UTCTIME * utctime;
    ASN1_GENERALIZEDTIME * generalizedtime;
    ASN1_VISIBLESTRING * visiblestring;
    ASN1_UTF8STRING * utf8string;
    ASN1_STRING * set;
    ASN1_STRING * sequence;
    ASN1_VALUE * asn1_value;
}; // size: 0x4

union _union_277 {
    char * ptr;
    rsa_st * rsa;
    dsa_st * dsa;
    dh_st * dh;
    ec_key_st * ec;
}; // size: 0x4

union _union_320 {
    ulonglong[16] d;
    uchar[128] p;
}; // size: 0x80

union _union_336 {
    char * ptr;
    stack_st_ASN1_TYPE * set;
    ASN1_TYPE * single;
}; // size: 0x4

union _union_387 {
    char * ptr;
    X509 * x509;
    X509_CRL * crl;
    EVP_PKEY * pkey;
}; // size: 0x4

union _union_450 {
    char * ptr;
    ASN1_OCTET_STRING * data;
    PKCS7_SIGNED * sign;
    PKCS7_ENVELOPE * enveloped;
    PKCS7_SIGN_ENVELOPE * signed_and_enveloped;
    PKCS7_DIGEST * digest;
    PKCS7_ENCRYPT * encrypted;
    ASN1_TYPE * other;
}; // size: 0x4

union _union_721 {
    double d;
    KEY_TABLE_TYPE rd_key;
}; // size: 0x110

union _union_851 {
    char * ptr;
    OTHERNAME * otherName;
    ASN1_IA5STRING * rfc822Name;
    ASN1_IA5STRING * dNSName;
    ASN1_TYPE * x400Address;
    X509_NAME * directoryName;
    EDIPARTYNAME * ediPartyName;
    ASN1_IA5STRING * uniformResourceIdentifier;
    ASN1_OCTET_STRING * iPAddress;
    ASN1_OBJECT * registeredID;
    ASN1_OCTET_STRING * ip;
    X509_NAME * dirn;
    ASN1_IA5STRING * ia5;
    ASN1_OBJECT * rid;
    ASN1_TYPE * other;
}; // size: 0x4

union _union_859 {
    GENERAL_NAMES * fullname;
    stack_st_X509_NAME_ENTRY * relativename;
}; // size: 0x4

union _union_873 {
    ASN1_IA5STRING * cpsuri;
    USERNOTICE * usernotice;
    ASN1_TYPE * other;
}; // size: 0x4

union _union_929 {
    ASN1_INTEGER * id;
    ASRange * range;
}; // size: 0x4

union _union_933 {
    ASN1_NULL * inherit;
    ASIdOrRanges * asIdsOrRanges;
}; // size: 0x4

union _union_937 {
    ASN1_BIT_STRING * addressPrefix;
    IPAddressRange * addressRange;
}; // size: 0x4

union _union_941 {
    ASN1_NULL * inherit;
    IPAddressOrRanges * addressesOrRanges;
}; // size: 0x4

union _union_961 {
    X509_NAME * byName;
    ASN1_OCTET_STRING * byKey;
}; // size: 0x4

union _union_965 {
    ASN1_NULL * good;
    OCSP_REVOKEDINFO * revoked;
    ASN1_NULL * unknown;
}; // size: 0x4

union _union_984 {
    pkcs12_bag_st * bag;
    pkcs8_priv_key_info_st * keybag;
    X509_SIG * shkeybag;
    stack_st_PKCS12_SAFEBAG * safes;
    ASN1_TYPE * other;
}; // size: 0x4

union _union_991 {
    ASN1_OCTET_STRING * x509cert;
    ASN1_OCTET_STRING * x509crl;
    ASN1_OCTET_STRING * octet;
    ASN1_IA5STRING * sdsicert;
    ASN1_TYPE * other;
}; // size: 0x4

union anon_union_116_8_26c2b70a_for__sifields {
    int[29] _pad;
    anon_struct_8_2_0a3d7222_for__kill _kill;
    anon_struct_12_3_5124685d_for__timer _timer;
    anon_struct_12_3_9bedbd60_for__rt _rt;
    anon_struct_20_5_7a025f54_for__sigchld _sigchld;
    anon_struct_8_2_895adaa1_for__sigfault _sigfault;
    anon_struct_8_2_686959ae_for__sigpoll _sigpoll;
    anon_struct_12_3_fe5e7108_for__sigsys _sigsys;
}; // size: 0x74

union anon_union_160_2_9472fda9_for_eeprom_data_t_2 {
    uchar[20] N;
    double[20] V;
}; // size: 0xa0

union anon_union_16_12_14072ea3_for_ifr_ifru {
    sockaddr ifru_addr;
    sockaddr ifru_dstaddr;
    sockaddr ifru_broadaddr;
    sockaddr ifru_netmask;
    sockaddr ifru_hwaddr;
    short ifru_flags;
    int ifru_ivalue;
    int ifru_mtu;
    ifmap ifru_map;
    char[16] ifru_slave;
    char[16] ifru_newname;
    __caddr_t ifru_data;
}; // size: 0x10

union anon_union_16_13_59db9508_for_ifr_ifru {
    sockaddr ifru_addr;
    sockaddr ifru_dstaddr;
    sockaddr ifru_broadaddr;
    sockaddr ifru_netmask;
    sockaddr ifru_hwaddr;
    short ifru_flags;
    int ifru_ivalue;
    int ifru_mtu;
    ifmap ifru_map;
    char[16] ifru_slave;
    char[16] ifru_newname;
    void * ifru_data;
    if_settings ifru_settings;
}; // size: 0x10

union anon_union_16_1_990b9991_for_ifr_ifrn {
    char[16] ifrn_name;
}; // size: 0x10

union anon_union_16_3_a3f0114d_for___in6_u {
    uint8_t[16] __u6_addr8;
    uint16_t[8] __u6_addr16;
    uint32_t[4] __u6_addr32;
}; // size: 0x10

union anon_union_4_2_5ad2d23e_for___sigaction_handler {
    __sighandler_t sa_handler;
    _func_void_int_siginfo_t_ptr_void_ptr * sa_sigaction;
}; // size: 0x4

union anon_union_4_2_94730053 {
    U32 u;
    BYTE[4] c;
}; // size: 0x4

union anon_union_4_2_94730053 {
    U32 u;
    BYTE[4] c;
}; // size: 0x4

union anon_union_4_2_9a799d16_for___pthread_mutex_s_5 {
    int __spins;
    __pthread_slist_t __list;
}; // size: 0x4

union anon_union_4_2_f9ecd746 {
    void * ptr;
    size_t i;
}; // size: 0x4

union anon_union_4_7_b62d2563_for_ifs_ifsu {
    raw_hdlc_proto * raw_hdlc;
    cisco_proto * cisco;
    fr_proto * fr;
    fr_proto_pvc * fr_pvc;
    fr_proto_pvc_info * fr_pvc_info;
    sync_serial_settings * sync;
    te1_settings * te1;
}; // size: 0x4

union anon_union_8_3_477c3ef1_for_value {
    anon_struct_8_2_43e888f9_for_string string;
    json_int_t integer;
    double real;
}; // size: 0x8

union nonce_format_t {
    anon_struct_4_3_4f6a2092_for_u u;
    anon_struct_4_3_30b46c24_for_u2 u2;
    uint32_t v;
}; // size: 0x4

union pthread_attr_t {
    char[36] __size;
    long __align;
}; // size: 0x24

union pthread_attr_t {
    char[36] __size;
    long __align;
}; // size: 0x24

union pthread_cond_t {
    anon_struct_48_8_df74bd48_for___data __data;
    char[48] __size;
    longlong __align;
}; // size: 0x30

union pthread_cond_t {
    _struct_16 __data;
    char[48] __size;
    longlong __align;
}; // size: 0x30

union pthread_mutex_t {
    __pthread_mutex_s __data;
    char[24] __size;
    long __align;
}; // size: 0x18

union pthread_mutex_t {
    __pthread_mutex_s __data;
    char[24] __size;
    long __align;
}; // size: 0x18

union pthread_mutexattr_t {
    char[4] __size;
    int __align;
}; // size: 0x4

union pthread_rwlock_t {
    _struct_19 __data;
    char[32] __size;
    long __align;
}; // size: 0x20

union pthread_rwlockattr_t {
    char[8] __size;
    long __align;
}; // size: 0x8

union sigval {
    int sival_int;
    void * sival_ptr;
}; // size: 0x4

union sigval {
    int sival_int;
    void * sival_ptr;
}; // size: 0x4

union unalign {
    U32 u32;
}; // size: 0x4

union unalign64 {
    U32 u32;
    U64 u64;
}; // size: 0x8

/* ==================== Type Definitions ==================== */

typedef ACCESS_DESCRIPTION_st ACCESS_DESCRIPTION;
typedef aes_key_st AES_KEY;
typedef ASIdOrRange_st ASIdOrRange;
typedef stack_st_ASIdOrRange ASIdOrRanges;
typedef ASIdentifierChoice_st ASIdentifierChoice;
typedef ASIdentifiers_st ASIdentifiers;
typedef asn1_string_st ASN1_BIT_STRING;
typedef asn1_string_st ASN1_BMPSTRING;
typedef int ASN1_BOOLEAN;
typedef ASN1_ENCODING_st ASN1_ENCODING;
typedef asn1_string_st ASN1_ENUMERATED;
typedef asn1_string_st ASN1_GENERALIZEDTIME;
typedef asn1_string_st ASN1_GENERALSTRING;
typedef asn1_string_st ASN1_IA5STRING;
typedef asn1_string_st ASN1_INTEGER;
typedef ASN1_ITEM_st ASN1_ITEM;
typedef ASN1_ITEM ASN1_ITEM_EXP;
typedef int ASN1_NULL;
typedef asn1_object_st ASN1_OBJECT;
typedef asn1_string_st ASN1_OCTET_STRING;
typedef asn1_pctx_st ASN1_PCTX;
typedef asn1_string_st ASN1_PRINTABLESTRING;
typedef stack_st_ASN1_TYPE ASN1_SEQUENCE_ANY;
typedef asn1_string_st ASN1_STRING;
typedef asn1_string_table_st ASN1_STRING_TABLE;
typedef asn1_string_st ASN1_T61STRING;
typedef ASN1_TEMPLATE_st ASN1_TEMPLATE;
typedef asn1_string_st ASN1_TIME;
typedef ASN1_TLC_st ASN1_TLC;
typedef asn1_type_st ASN1_TYPE;
typedef asn1_string_st ASN1_UNIVERSALSTRING;
typedef asn1_string_st ASN1_UTCTIME;
typedef asn1_string_st ASN1_UTF8STRING;
typedef ASN1_VALUE_st ASN1_VALUE;
typedef asn1_string_st ASN1_VISIBLESTRING;
typedef ASRange_st ASRange;
typedef stack_st_ACCESS_DESCRIPTION AUTHORITY_INFO_ACCESS;
typedef AUTHORITY_KEYID_st AUTHORITY_KEYID;
typedef asic_register Asic_Register;
typedef BASIC_CONSTRAINTS_st BASIC_CONSTRAINTS;
typedef bf_key_st BF_KEY;
typedef bignum_st BIGNUM;
typedef bio_st BIO;
typedef bio_method_st BIO_METHOD;
typedef bn_blinding_st BN_BLINDING;
typedef bignum_ctx BN_CTX;
typedef bn_gencb_st BN_GENCB;
typedef bn_mont_ctx_st BN_MONT_CTX;
typedef bn_recp_ctx_st BN_RECP_CTX;
typedef buf_mem_st BUF_MEM;
typedef uint8_t BYTE;
typedef camellia_key_st CAMELLIA_KEY;
typedef cast_key_st CAST_KEY;
typedef stack_st_POLICYINFO CERTIFICATEPOLICIES;
typedef CMAC_CTX_st CMAC_CTX;
typedef CMS_ContentInfo_st CMS_ContentInfo;
typedef CMS_RecipientInfo_st CMS_RecipientInfo;
typedef CMS_RevocationInfoChoice_st CMS_RevocationInfoChoice;
typedef CMS_SignerInfo_st CMS_SignerInfo;
typedef comp_ctx_st COMP_CTX;
typedef comp_method_st COMP_METHOD;
typedef conf_st CONF;
typedef conf_imodule_st CONF_IMODULE;
typedef conf_method_st CONF_METHOD;
typedef conf_module_st CONF_MODULE;
typedef stack_st_DIST_POINT CRL_DIST_POINTS;
typedef crypto_ex_data_st CRYPTO_EX_DATA;
typedef CRYPTO_EX_dup CRYPTO_EX_dup;
typedef CRYPTO_EX_free CRYPTO_EX_free;
typedef CRYPTO_EX_new CRYPTO_EX_new;
typedef crypto_threadid_st CRYPTO_THREADID;
typedef ctrlboard_sensor CtrlBoard_Sensor;
typedef uchar[8] DES_cblock;
typedef DES_ks DES_key_schedule;
typedef double DFtype;
typedef dh_st DH;
typedef dh_method DH_METHOD;
typedef __dirstream DIR;
typedef __dirstream DIR;
typedef DIST_POINT_st DIST_POINT;
typedef DIST_POINT_NAME_st DIST_POINT_NAME;
typedef longlong DItype;
typedef dsa_st DSA;
typedef dsa_method DSA_METHOD;
typedef DSA_SIG_st DSA_SIG;
typedef dso_st DSO;
typedef DSO_FUNC_TYPE * DSO_FUNC_TYPE;
typedef DSO_MERGER_FUNC * DSO_MERGER_FUNC;
typedef dso_meth_st DSO_METHOD;
typedef DSO_NAME_CONVERTER_FUNC * DSO_NAME_CONVERTER_FUNC;
typedef dtls1_bitmap_st DTLS1_BITMAP;
typedef display Display;
typedef ECDSA_SIG_st ECDSA_SIG;
typedef ec_group_st EC_GROUP;
typedef ec_key_st EC_KEY;
typedef ec_method_st EC_METHOD;
typedef ec_point_st EC_POINT;
typedef EDIPartyName_st EDIPARTYNAME;
typedef engine_st ENGINE;
typedef ENGINE_CIPHERS_PTR * ENGINE_CIPHERS_PTR;
typedef ENGINE_CMD_DEFN_st ENGINE_CMD_DEFN;
typedef ENGINE_CTRL_FUNC_PTR * ENGINE_CTRL_FUNC_PTR;
typedef ENGINE_DIGESTS_PTR * ENGINE_DIGESTS_PTR;
typedef ENGINE_GEN_INT_FUNC_PTR * ENGINE_GEN_INT_FUNC_PTR;
typedef ENGINE_LOAD_KEY_PTR * ENGINE_LOAD_KEY_PTR;
typedef ENGINE_PKEY_ASN1_METHS_PTR * ENGINE_PKEY_ASN1_METHS_PTR;
typedef ENGINE_PKEY_METHS_PTR * ENGINE_PKEY_METHS_PTR;
typedef ENGINE_SSL_CLIENT_CERT_PTR * ENGINE_SSL_CLIENT_CERT_PTR;
typedef err_state_st ERR_STATE;
typedef ERR_string_data_st ERR_STRING_DATA;
typedef evp_cipher_st EVP_CIPHER;
typedef evp_cipher_ctx_st EVP_CIPHER_CTX;
typedef evp_cipher_info_st EVP_CIPHER_INFO;
typedef evp_Encode_Ctx_st EVP_ENCODE_CTX;
typedef env_md_st EVP_MD;
typedef env_md_ctx_st EVP_MD_CTX;
typedef EVP_PBE_KEYGEN EVP_PBE_KEYGEN;
typedef evp_pkey_st EVP_PKEY;
typedef evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;
typedef evp_pkey_ctx_st EVP_PKEY_CTX;
typedef evp_pkey_method_st EVP_PKEY_METHOD;
typedef EVP_PKEY_gen_cb EVP_PKEY_gen_cb;
typedef stack_st_ASN1_OBJECT EXTENDED_KEY_USAGE;
typedef _IO_FILE FILE;
typedef _IO_FILE FILE;
typedef fan Fan;
typedef GENERAL_NAME_st GENERAL_NAME;
typedef stack_st_GENERAL_NAME GENERAL_NAMES;
typedef GENERAL_SUBTREE_st GENERAL_SUBTREE;
typedef GEN_SESSION_CB * GEN_SESSION_CB;
typedef hmac_ctx_st HMAC_CTX;
typedef hash_board Hash_Board;
typedef history_result History_Result;
typedef IPAddressChoice_st IPAddressChoice;
typedef IPAddressFamily_st IPAddressFamily;
typedef IPAddressOrRange_st IPAddressOrRange;
typedef stack_st_IPAddressOrRange IPAddressOrRanges;
typedef IPAddressRange_st IPAddressRange;
typedef ISSUING_DIST_POINT_st ISSUING_DIST_POINT;
typedef uint[68] KEY_TABLE_TYPE;
typedef kssl_ctx_st KSSL_CTX;
typedef LHASH_COMP_FN_TYPE * LHASH_COMP_FN_TYPE;
typedef LHASH_HASH_FN_TYPE * LHASH_HASH_FN_TYPE;
typedef _func_void_ptr_void_ptr_size_t * LZ4F_AllocFunction;
typedef LZ4F_CDict_s LZ4F_CDict;
typedef _func_void_ptr_void_ptr_size_t * LZ4F_CallocFunction;
typedef _func_void_void_ptr_void_ptr * LZ4F_FreeFunction;
typedef LZ4F_cctx_s LZ4F_cctx;
typedef LZ4F_cctx_s LZ4F_cctx_t;
typedef LZ4F_dctx_s LZ4F_dctx;
typedef size_t LZ4F_errorCode_t;
typedef uint8_t LZ4_byte;
typedef int8_t LZ4_i8;
typedef LZ4_readFile_s LZ4_readFile_t;
typedef LZ4_streamDecode_u LZ4_streamDecode_t;
typedef LZ4_streamHC_u LZ4_streamHC_t;
typedef LZ4_stream_u LZ4_stream_t;
typedef uint16_t LZ4_u16;
typedef uint32_t LZ4_u32;
typedef LZ4_writeFile_s LZ4_writeFile_t;
typedef local_config_info Local_Config_Info;
typedef MD4state_st MD4_CTX;
typedef MD5state_st MD5_CTX;
typedef mes_system_asic_reg Mes_System_Asic_Reg;
typedef mes_system_config_file_info Mes_System_Config_File_Info;
typedef mes_system_configs Mes_System_Configs;
typedef mes_system_data Mes_System_Data;
typedef mes_system_hw_info Mes_System_Hw_Info;
typedef mes_system_pattern Mes_System_Pattern;
typedef mes_system_result Mes_System_Result;
typedef mes_system_rule Mes_System_Rule;
typedef mes_system_test_config Mes_System_Test_Config;
typedef mes_system_test_loop Mes_System_Test_Loop;
typedef mes_system_test_method Mes_System_Test_Method;
typedef NAME_CONSTRAINTS_st NAME_CONSTRAINTS;
typedef Netscape_certificate_sequence NETSCAPE_CERT_SEQUENCE;
typedef Netscape_spkac_st NETSCAPE_SPKAC;
typedef Netscape_spki_st NETSCAPE_SPKI;
typedef NOTICEREF_st NOTICEREF;
typedef obj_name_st OBJ_NAME;
typedef ocsp_basic_response_st OCSP_BASICRESP;
typedef ocsp_cert_id_st OCSP_CERTID;
typedef ocsp_cert_status_st OCSP_CERTSTATUS;
typedef ocsp_crl_id_st OCSP_CRLID;
typedef ocsp_one_request_st OCSP_ONEREQ;
typedef ocsp_req_info_st OCSP_REQINFO;
typedef ocsp_request_st OCSP_REQUEST;
typedef ocsp_req_ctx_st OCSP_REQ_CTX;
typedef ocsp_resp_bytes_st OCSP_RESPBYTES;
typedef ocsp_response_data_st OCSP_RESPDATA;
typedef ocsp_responder_id_st OCSP_RESPID;
typedef ocsp_response_st OCSP_RESPONSE;
typedef ocsp_revoked_info_st OCSP_REVOKEDINFO;
typedef ocsp_service_locator_st OCSP_SERVICELOC;
typedef ocsp_signature_st OCSP_SIGNATURE;
typedef ocsp_single_response_st OCSP_SINGLERESP;
typedef char * OPENSSL_STRING;
typedef otherName_st OTHERNAME;
typedef PBE2PARAM_st PBE2PARAM;
typedef PBEPARAM_st PBEPARAM;
typedef PBKDF2PARAM_st PBKDF2PARAM;
typedef pkcs12_bag_st PKCS12_BAGS;
typedef pkcs7_st PKCS7;
typedef pkcs7_digest_st PKCS7_DIGEST;
typedef pkcs7_encrypted_st PKCS7_ENCRYPT;
typedef pkcs7_enc_content_st PKCS7_ENC_CONTENT;
typedef pkcs7_enveloped_st PKCS7_ENVELOPE;
typedef pkcs7_issuer_and_serial_st PKCS7_ISSUER_AND_SERIAL;
typedef pkcs7_recip_info_st PKCS7_RECIP_INFO;
typedef pkcs7_signed_st PKCS7_SIGNED;
typedef pkcs7_signer_info_st PKCS7_SIGNER_INFO;
typedef pkcs7_signedandenveloped_st PKCS7_SIGN_ENVELOPE;
typedef pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;
typedef PKEY_USAGE_PERIOD_st PKEY_USAGE_PERIOD;
typedef POLICYINFO_st POLICYINFO;
typedef POLICYQUALINFO_st POLICYQUALINFO;
typedef POLICY_CONSTRAINTS_st POLICY_CONSTRAINTS;
typedef POLICY_MAPPING_st POLICY_MAPPING;
typedef PROXY_CERT_INFO_EXTENSION_st PROXY_CERT_INFO_EXTENSION;
typedef PROXY_POLICY_st PROXY_POLICY;
typedef pic_sensor Pic_Sensor;
typedef rand_meth_st RAND_METHOD;
typedef rc2_key_st RC2_KEY;
typedef rc4_key_st RC4_KEY;
typedef RIPEMD160state_st RIPEMD160_CTX;
typedef rsa_st RSA;
typedef rsa_meth_st RSA_METHOD;
typedef rsa_pss_params_st RSA_PSS_PARAMS;
typedef repair_mode Repair_Mode;
typedef size_t Rvl_t;
typedef seed_key_st SEED_KEY_SCHEDULE;
typedef SHA256state_st SHA256_CTX;
typedef SHA512state_st SHA512_CTX;
typedef SHAstate_st SHA_CTX;
typedef srtp_protection_profile_st SRTP_PROTECTION_PROFILE;
typedef ssl_st SSL;
typedef ssl_st SSL;
typedef ssl3_buffer_st SSL3_BUFFER;
typedef ssl3_record_st SSL3_RECORD;
typedef ssl_cipher_st SSL_CIPHER;
typedef ssl_comp_st SSL_COMP;
typedef ssl_ctx_st SSL_CTX;
typedef ssl_ctx_st SSL_CTX;
typedef ssl_method_st SSL_METHOD;
typedef ssl_session_st SSL_SESSION;
typedef SXNET_st SXNET;
typedef SXNET_ID_st SXNETID;
typedef sensor_info Sensor_Info;
typedef tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;
typedef txt_db_st TXT_DB;
typedef temperature Temperature;
typedef test_info Test_Info;
typedef test_loop Test_Loop;
typedef test_method Test_Method;
typedef test_speed Test_Speed;
typedef test_standard Test_Standard;
typedef uint16_t U16;
typedef uint32_t U32;
typedef uint64_t U64;
typedef ulonglong UDItype;
typedef ui_st UI;
typedef ui_method_st UI_METHOD;
typedef ui_string_st UI_STRING;
typedef USERNOTICE_st USERNOTICE;
typedef uint USItype;
typedef x509_st X509;
typedef X509V3_CONF_METHOD_st X509V3_CONF_METHOD;
typedef v3_ext_ctx X509V3_CTX;
typedef X509V3_EXT_D2I * X509V3_EXT_D2I;
typedef X509V3_EXT_FREE * X509V3_EXT_FREE;
typedef X509V3_EXT_I2D * X509V3_EXT_I2D;
typedef X509V3_EXT_I2R * X509V3_EXT_I2R;
typedef X509V3_EXT_I2S * X509V3_EXT_I2S;
typedef X509V3_EXT_I2V * X509V3_EXT_I2V;
typedef v3_ext_method X509V3_EXT_METHOD;
typedef X509V3_EXT_NEW * X509V3_EXT_NEW;
typedef X509V3_EXT_R2I * X509V3_EXT_R2I;
typedef X509V3_EXT_S2I * X509V3_EXT_S2I;
typedef X509V3_EXT_V2I * X509V3_EXT_V2I;
typedef X509_algor_st X509_ALGOR;
typedef stack_st_X509_ALGOR X509_ALGORS;
typedef x509_attributes_st X509_ATTRIBUTE;
typedef x509_cert_aux_st X509_CERT_AUX;
typedef x509_cinf_st X509_CINF;
typedef X509_crl_st X509_CRL;
typedef X509_crl_info_st X509_CRL_INFO;
typedef x509_crl_method_st X509_CRL_METHOD;
typedef X509_extension_st X509_EXTENSION;
typedef stack_st_X509_EXTENSION X509_EXTENSIONS;
typedef X509_info_st X509_INFO;
typedef x509_lookup_st X509_LOOKUP;
typedef x509_lookup_method_st X509_LOOKUP_METHOD;
typedef X509_name_st X509_NAME;
typedef X509_name_entry_st X509_NAME_ENTRY;
typedef x509_object_st X509_OBJECT;
typedef private_key_st X509_PKEY;
typedef X509_POLICY_CACHE_st X509_POLICY_CACHE;
typedef X509_POLICY_LEVEL_st X509_POLICY_LEVEL;
typedef X509_POLICY_NODE_st X509_POLICY_NODE;
typedef X509_POLICY_TREE_st X509_POLICY_TREE;
typedef X509_pubkey_st X509_PUBKEY;
typedef x509_purpose_st X509_PURPOSE;
typedef X509_req_st X509_REQ;
typedef X509_req_info_st X509_REQ_INFO;
typedef x509_revoked_st X509_REVOKED;
typedef X509_sig_st X509_SIG;
typedef x509_store_st X509_STORE;
typedef x509_store_ctx_st X509_STORE_CTX;
typedef x509_trust_st X509_TRUST;
typedef X509_val_st X509_VAL;
typedef X509_VERIFY_PARAM_st X509_VERIFY_PARAM;
typedef dword XXH32_hash_t;
typedef XXH32_state_s XXH32_state_t;
typedef qword XXH64_hash_t;
typedef XXH64_state_s XXH64_state_t;
typedef bool _Bool;
typedef void _IO_lock_t;
typedef void _IO_lock_t;
typedef stack_st _STACK;
typedef int __blkcnt_t;
typedef long __blkcnt_t;
typedef int __blksize_t;
typedef long __blksize_t;
typedef char * __caddr_t;
typedef int __clock_t;
typedef long __clock_t;
typedef int __clockid_t;
typedef _func_int_void_ptr_void_ptr * __compar_fn_t;
typedef __compar_fn_t * __compar_fn_t;
typedef __u_quad_t __dev_t;
typedef __u_quad_t __dev_t;
typedef int __fd_mask;
typedef long __fd_mask;
typedef uint __gid_t;
typedef uint __gid_t;
typedef __va_list __gnuc_va_list;
typedef void * __gnuc_va_list;
typedef uint __ino_t;
typedef ulong __ino_t;
typedef int __kernel_long_t;
typedef uint __kernel_ulong_t;
typedef int __key_t;
typedef uint __mode_t;
typedef uint __mode_t;
typedef uint __nlink_t;
typedef uint __nlink_t;
typedef __quad_t __off64_t;
typedef __quad_t __off64_t;
typedef int __off_t;
typedef long __off_t;
typedef int __pid_t;
typedef int __pid_t;
typedef __pthread_internal_slist __pthread_slist_t;
typedef __pthread_internal_slist __pthread_slist_t;
typedef longlong __quad_t;
typedef longlong __quad_t;
typedef _func_void_int * __sighandler_t;
typedef __sighandler_t * __sighandler_t;
typedef uint __socklen_t;
typedef uint __socklen_t;
typedef int __ssize_t;
typedef int __ssize_t;
typedef int __suseconds_t;
typedef long __suseconds_t;
typedef int __syscall_slong_t;
typedef int __time_t;
typedef long __time_t;
typedef timezone * __timezone_ptr_t;
typedef word __u16;
typedef dword __u32;
typedef ulonglong __u_quad_t;
typedef ulonglong __u_quad_t;
typedef uint __uid_t;
typedef uint __uid_t;
typedef qword __uint64_t;
typedef uint __useconds_t;
typedef _analog_mux_control_t analog_mux_control_t;
typedef _asic_reg_conf asic_reg_conf;
typedef _asic_status asic_status;
typedef asn1_ps_func asn1_ps_func;
typedef _auto_clk_en_t auto_clk_en_t;
typedef bio_info_cb bio_info_cb;
typedef _func_void_uint32_t_uint8_t * bitmain_gpio_callback;
typedef _func_void_ui_type_e_bitmain_key_status_e * bitmain_key_callback;
typedef hashtable_bucket bucket_t;
typedef uchar cc_t;
typedef _chain_inactive_t chain_inactive_t;
typedef _chip_nonce_offset_t chip_nonce_offset_t;
typedef int clib_bool;
typedef _func_int_void_ptr_void_ptr * clib_compare;
typedef _func_void_void_ptr * clib_destroy;
typedef int clib_error;
typedef _clock_delay_ctrl_t clock_delay_ctrl_t;
typedef _clock_select_ctrl_t clock_select_ctrl_t;
typedef __clockid_t clockid_t;
typedef undefined[16] complex double;
typedef qword complex float;
typedef _func_int_void_ptr_char_ptr_char_ptr_int_int_int_LZ4F_CDict_ptr * compressFunc_t;
typedef conf_finish_func conf_finish_func;
typedef conf_init_func conf_init_func;
typedef _config_ctx config_ctx;
typedef uchar[8] const_DES_cblock;
typedef _core_command_t core_command_t;
typedef _core_enable_t core_enable_t;
typedef d2i_of_void d2i_of_void;
typedef _eeprom_data_format * edf_ctx_p;
typedef _eeprom_data_format * edf_ctx_p.conflict;
typedef _func_int_edf_ctx_p_char_ptr_size_t_ptr * edf_i8_array_get;
typedef _func_int_edf_ctx_p_char_ptr_size_t_ptr * edf_i8_array_set;
typedef _func_int_edf_ctx_p * edf_i8_get;
typedef _func_int_edf_ctx_p_int8_t * edf_i8_set;
typedef _func_eeprom_data_format_t_ptr * edf_submodule_init;
typedef _func_int_edf_ctx_p * edf_u16_get;
typedef _func_int_edf_ctx_p_uint16_t * edf_u16_set;
typedef _func_int_edf_ctx_p_uint8_t_ptr_size_t_ptr * edf_u8_array_get;
typedef _func_int_edf_ctx_p_uint8_t_ptr_size_t_ptr * edf_u8_array_set;
typedef _func_int_edf_ctx_p * edf_u8_get;
typedef _func_int_edf_ctx_p_uint8_t * edf_u8_set;
typedef _eeprom_data_format eeprom_data_format_t;
typedef _fan_ctx fan_ctx;
typedef _fast_UART_configuration_t fast_UART_configuration_t;
typedef _fpga_bt8d_t fpga_bt8d_t;
typedef _frequency_sweep_control_t frequency_sweep_control_t;
typedef _general_i2c_command_t general_i2c_command_t;
typedef _func_int_void_ptr * get_func;
typedef _get_status_t get_status_t;
typedef _hash_board hash_board.conflict;
typedef _hash_clock_ctrl_t hash_clock_ctrl_t;
typedef hashtable hashtable_t;
typedef i2d_of_void i2d_of_void;
typedef uint32_t in_addr_t;
typedef uint32_t in_addr_t;
typedef uint16_t in_port_t;
typedef sword int16_t;
typedef sdword int32_t;
typedef sqword int64_t;
typedef char int8_t;
typedef _io_driver_strength_cfg_t io_driver_strength_cfg_t;
typedef _func_int_char_ptr_size_t_void_ptr * json_dump_callback_t;
typedef _func_void_void_ptr * json_free_t;
typedef longlong json_int_t;
typedef _func_size_t_void_ptr_size_t_void_ptr * json_load_callback_t;
typedef _func_void_ptr_size_t * json_malloc_t;
typedef __key_t key_t;
typedef krb5_int32 krb5_enctype;
typedef int krb5_int32;
typedef uchar krb5_octet;
typedef hashtable_list list_t;
typedef _midstate_cal_register_t midstate_cal_register_t;
typedef _misc_control_t misc_control_t;
typedef __mode_t mode_t;
typedef _nonce_bin_overflow_control_t nonce_bin_overflow_control_t;
typedef _nonce_bin_overflow_t nonce_bin_overflow_t;
typedef _ocv_pulse_width_t ocv_pulse_width_t;
typedef _ordered_clock_enable ordered_clock_enable;
typedef _pad_check pad_check_t;
typedef hashtable_pair pair_t;
typedef _pattern_bin pattern_bin;
typedef _pattern_ops_t pattern_ops_t;
typedef _pattern_runtime_ctx pattern_runtime_ctx;
typedef _pattern_test_stats pattern_test_stats;
typedef _pattern_work pattern_work;
typedef pem_password_cb pem_password_cb;
typedef _pitem pitem;
typedef _pitem * piterator;
typedef _pll_parameter_t pll_parameter_t;
typedef enum_301 point_conversion_form_t;
typedef _pqueue * pqueue;
typedef _process_monitor_ctrl_t process_monitor_ctrl_t;
typedef _ptx_err_msg_ pt_err_msg;
typedef uint pthread_key_t;
typedef int pthread_once_t;
typedef uint pthread_t;
typedef ulong pthread_t;
typedef int ptrdiff_t;
typedef record_pqueue_st record_pqueue;
typedef size_t reg_t;
typedef _return_nonce_128bit_t return_nonce_128bit_t;
typedef _returned_nonce_counter_t returned_nonce_counter_t;
typedef _rosc_pad_dis_t rosc_pad_dis_t;
typedef ushort sa_family_t;
typedef ushort sa_family_t;
typedef _sensor_ctx sensor_ctx;
typedef _set_address_t set_address_t;
typedef _set_config_t set_config_t;
typedef siginfo siginfo_t;
typedef __sigset_t sigset_t;
typedef sigval sigval_t;
typedef sigval sigval_t;
typedef uint size_t;
typedef ulong size_t;
typedef uint sizetype;
typedef __socklen_t socklen_t;
typedef __socklen_t socklen_t;
typedef _soft_reset_control_t soft_reset_control_t;
typedef uint speed_t;
typedef __ssize_t ssize_t;
typedef __ssize_t ssize_t;
typedef _sweep_clk_mode_ctrl_t sweep_clk_mode_ctrl_t;
typedef _sweep_ctx sweep_ctx;
typedef uint tcflag_t;
typedef _temp_ctrl_t_ temp_ctrl_t;
typedef _temp_ctx temp_ctx;
typedef _test_ctx test_ctx;
typedef _test_speed test_speed.conflict;
typedef _test_standard test_standard.conflict;
typedef _tick_nonce_counter_t tick_nonce_counter_t;
typedef _ticket_mask_t ticket_mask_t;
typedef __time_t time_t;
typedef __time_t time_t;
typedef tls_session_secret_cb_fn * tls_session_secret_cb_fn;
typedef tls_session_ticket_ext_cb_fn * tls_session_ticket_ext_cb_fn;
typedef _uart_relay_t uart_relay_t;
typedef word uint16_t;
typedef ushort uint16_t;
typedef dword uint32_t;
typedef uint uint32_t;
typedef qword uint64_t;
typedef uchar uint8_t;
typedef uint uintptr_t;
typedef uintptr_t uptrval;
typedef __gnuc_va_list va_list;
typedef __gnuc_va_list va_list;
typedef _work_cxt work_cxt;

/* ==================== Function Prototypes ==================== */

_Bool APW_power_on(uint32_t voltage);
uint16_t ASIC_CRC16(uint8_t * pdata, uint32_t length);
uint8_t ASIC_CRC5(uint8_t * pdata, uint32_t length);
_Bool BTC_check_config_information(char * asic_type);
void BTC_check_register(return_nonce_128bit_t * reg_buf);
void BTC_cpugen_pattern_check_nonce(return_nonce_128bit_t * nonce_buf);
void BTC_mid_auto_gen_check_nonce(return_nonce_128bit_t * nonce_buf);
void BTC_software_pattern_check_nonce(return_nonce_128bit_t * nonce_buf);
int Base64decode(char * bufplain, char * bufcoded);
int Base64decode_len(char * bufcoded);
int Base64encode(char * encoded, char * string, int len);
int Base64encode_len(int len);
uint8_t CRC5_long(uint8_t * pdata, uint32_t length);
int CRYPTO_EX_dup(CRYPTO_EX_DATA * to, CRYPTO_EX_DATA * from, void * from_d, int idx, long argl, void * argp);
void CRYPTO_EX_free(void * parent, void * ptr, CRYPTO_EX_DATA * ad, int idx, long argl, void * argp);
int CRYPTO_EX_new(void * parent, void * ptr, CRYPTO_EX_DATA * ad, int idx, long argl, void * argp);
_Bool Check_EEPROM(uint32_t EEPROM_length);
_Bool Check_EEPROM_compat(uint32_t EEPROM_length);
void DSO_FUNC_TYPE(void);
char * DSO_MERGER_FUNC(DSO * param0, char * param1, char * param2);
char * DSO_NAME_CONVERTER_FUNC(DSO * param0, char * param1);
int ENGINE_CIPHERS_PTR(ENGINE * param0, EVP_CIPHER * * param1, int * * param2, int param3);
int ENGINE_CTRL_FUNC_PTR(ENGINE * param0, int param1, long param2, void * param3, f * f);
int ENGINE_DIGESTS_PTR(ENGINE * param0, EVP_MD * * param1, int * * param2, int param3);
int ENGINE_GEN_INT_FUNC_PTR(ENGINE * param0);
EVP_PKEY * ENGINE_LOAD_KEY_PTR(ENGINE * param0, char * param1, UI_METHOD * ui_method, void * callback_data);
int ENGINE_PKEY_ASN1_METHS_PTR(ENGINE * param0, EVP_PKEY_ASN1_METHOD * * param1, int * * param2, int param3);
int ENGINE_PKEY_METHS_PTR(ENGINE * param0, EVP_PKEY_METHOD * * param1, int * * param2, int param3);
int ENGINE_SSL_CLIENT_CERT_PTR(ENGINE * param0, SSL * ssl, stack_st_X509_NAME * ca_dn, X509 * * pcert, EVP_PKEY * * pkey, stack_st_X509 * * pother, UI_METHOD * ui_method, void * callback_data);
int EVP_PBE_KEYGEN(EVP_CIPHER_CTX * ctx, char * pass, int passlen, ASN1_TYPE * param, EVP_CIPHER * cipher, EVP_MD * md, int en_de);
int EVP_PKEY_gen_cb(EVP_PKEY_CTX * ctx);
int GEN_SESSION_CB(SSL * ssl, uchar * id, uint * id_len);
void * KDF(void * in, size_t inlen, void * out, size_t * outlen);
int LHASH_COMP_FN_TYPE(void * param0, void * param1);
ulong LHASH_HASH_FN_TYPE(void * param0);
void * LZ4F_calloc(size_t s, LZ4F_CustomMem cmem);
size_t LZ4F_compressBegin(LZ4F_cctx * cctxPtr, void * dstBuffer, size_t dstCapacity, LZ4F_preferences_t * preferencesPtr);
size_t LZ4F_compressBegin_usingCDict(LZ4F_cctx * cctxPtr, void * dstBuffer, size_t dstCapacity, LZ4F_CDict * cdict, LZ4F_preferences_t * preferencesPtr);
int LZ4F_compressBlock(void * ctx, char * src, char * dst, int srcSize, int dstCapacity, int level, LZ4F_CDict * cdict);
int LZ4F_compressBlockHC(void * ctx, char * src, char * dst, int srcSize, int dstCapacity, int level, LZ4F_CDict * cdict);
int LZ4F_compressBlockHC_continue(void * ctx, char * src, char * dst, int srcSize, int dstCapacity, int level, LZ4F_CDict * cdict);
int LZ4F_compressBlock_continue(void * ctx, char * src, char * dst, int srcSize, int dstCapacity, int level, LZ4F_CDict * cdict);
size_t LZ4F_compressBound(size_t srcSize, LZ4F_preferences_t * preferencesPtr);
size_t LZ4F_compressBound_internal(size_t srcSize, LZ4F_preferences_t * preferencesPtr, size_t alreadyBuffered);
size_t LZ4F_compressEnd(LZ4F_cctx * cctxPtr, void * dstBuffer, size_t dstCapacity, LZ4F_compressOptions_t * compressOptionsPtr);
size_t LZ4F_compressFrame(void * dstBuffer, size_t dstCapacity, void * srcBuffer, size_t srcSize, LZ4F_preferences_t * preferencesPtr);
size_t LZ4F_compressFrameBound(size_t srcSize, LZ4F_preferences_t * preferencesPtr);
size_t LZ4F_compressFrame_usingCDict(LZ4F_cctx * cctx, void * dstBuffer, size_t dstCapacity, void * srcBuffer, size_t srcSize, LZ4F_CDict * cdict, LZ4F_preferences_t * preferencesPtr);
size_t LZ4F_compressUpdate(LZ4F_cctx * cctxPtr, void * dstBuffer, size_t dstCapacity, void * srcBuffer, size_t srcSize, LZ4F_compressOptions_t * compressOptionsPtr);
size_t LZ4F_compressUpdateImpl(LZ4F_cctx * cctxPtr, void * dstBuffer, size_t dstCapacity, void * srcBuffer, size_t srcSize, LZ4F_compressOptions_t * compressOptionsPtr, LZ4F_blockCompression_t blockCompression);
int LZ4F_compressionLevel_max(void);
LZ4F_CDict * LZ4F_createCDict(void * dictBuffer, size_t dictSize);
LZ4F_CDict * LZ4F_createCDict_advanced(LZ4F_CustomMem cmem, void * dictBuffer, size_t dictSize);
LZ4F_errorCode_t LZ4F_createCompressionContext(LZ4F_cctx * * LZ4F_compressionContextPtr, uint version);
LZ4F_cctx * LZ4F_createCompressionContext_advanced(LZ4F_CustomMem customMem, uint version);
LZ4F_errorCode_t LZ4F_createDecompressionContext(LZ4F_dctx * * LZ4F_decompressionContextPtr, uint versionNumber);
LZ4F_dctx * LZ4F_createDecompressionContext_advanced(LZ4F_CustomMem customMem, uint version);
size_t LZ4F_decodeHeader(LZ4F_dctx * dctx, void * src, size_t srcSize);
size_t LZ4F_decompress(LZ4F_dctx * dctx, void * dstBuffer, size_t * dstSizePtr, void * srcBuffer, size_t * srcSizePtr, LZ4F_decompressOptions_t * decompressOptionsPtr);
size_t LZ4F_decompress_usingDict(LZ4F_dctx * dctx, void * dstBuffer, size_t * dstSizePtr, void * srcBuffer, size_t * srcSizePtr, void * dict, size_t dictSize, LZ4F_decompressOptions_t * decompressOptionsPtr);
int LZ4F_doNotCompressBlock(void * ctx, char * src, char * dst, int srcSize, int dstCapacity, int level, LZ4F_CDict * cdict);
size_t LZ4F_flush(LZ4F_cctx * cctxPtr, void * dstBuffer, size_t dstCapacity, LZ4F_compressOptions_t * compressOptionsPtr);
void LZ4F_free(void * p, LZ4F_CustomMem cmem);
void LZ4F_freeCDict(LZ4F_CDict * cdict);
LZ4F_errorCode_t LZ4F_freeCompressionContext(LZ4F_cctx * cctxPtr);
LZ4F_errorCode_t LZ4F_freeDecompressionContext(LZ4F_dctx * dctx);
size_t LZ4F_getBlockSize(LZ4F_blockSizeID_t blockSizeID);
LZ4F_errorCodes LZ4F_getErrorCode(size_t functionResult);
char * LZ4F_getErrorName(LZ4F_errorCode_t code);
LZ4F_errorCode_t LZ4F_getFrameInfo(LZ4F_dctx * dctx, LZ4F_frameInfo_t * frameInfoPtr, void * srcBuffer, size_t * srcSizePtr);
uint LZ4F_getVersion(void);
BYTE LZ4F_headerChecksum(void * header, size_t length);
size_t LZ4F_headerSize(void * src, size_t srcSize);
void LZ4F_initStream(void * ctx, LZ4F_CDict * cdict, int level, LZ4F_blockMode_t blockMode);
uint LZ4F_isError(LZ4F_errorCode_t code);
int LZ4F_localSaveDict(LZ4F_cctx_t * cctxPtr);
size_t LZ4F_makeBlock(void * dst, void * src, size_t srcSize, compressFunc_t compress, void * lz4ctx, int level, LZ4F_CDict * cdict, LZ4F_blockChecksum_t crcFlag);
void * LZ4F_malloc(size_t s, LZ4F_CustomMem cmem);
LZ4F_blockSizeID_t LZ4F_optimalBSID(LZ4F_blockSizeID_t requestedBSID, size_t srcSize);
size_t LZ4F_read(LZ4_readFile_t * lz4fRead, void * buf, size_t size);
LZ4F_errorCode_t LZ4F_readClose(LZ4_readFile_t * lz4fRead);
U32 LZ4F_readLE32(void * src);
U64 LZ4F_readLE64(void * src);
LZ4F_errorCode_t LZ4F_readOpen(LZ4_readFile_t * * lz4fRead, FILE * fp);
void LZ4F_resetDecompressionContext(LZ4F_dctx * dctx);
LZ4F_errorCode_t LZ4F_returnErrorCode(LZ4F_errorCodes code);
compressFunc_t LZ4F_selectCompression(LZ4F_blockMode_t blockMode, int level, LZ4F_blockCompression_t compressMode);
size_t LZ4F_uncompressedUpdate(LZ4F_cctx * cctxPtr, void * dstBuffer, size_t dstCapacity, void * srcBuffer, size_t srcSize, LZ4F_compressOptions_t * compressOptionsPtr);
void LZ4F_updateDict(LZ4F_dctx * dctx, BYTE * dstPtr, size_t dstSize, BYTE * dstBufferStart, uint withinTmp);
size_t LZ4F_write(LZ4_writeFile_t * lz4fWrite, void * buf, size_t size);
LZ4F_errorCode_t LZ4F_writeClose(LZ4_writeFile_t * lz4fWrite);
void LZ4F_writeLE32(void * dst, U32 value32);
void LZ4F_writeLE64(void * dst, U64 value64);
LZ4F_errorCode_t LZ4F_writeOpen(LZ4_writeFile_t * * lz4fWrite, FILE * fp, LZ4F_preferences_t * prefsPtr);
void LZ4HC_clearTables(LZ4HC_CCtx_internal * hc4);
int LZ4HC_compress_generic(LZ4HC_CCtx_internal * ctx, char * src, char * dst, int * srcSizePtr, int dstCapacity, int cLevel, limitedOutput_directive limit);
int LZ4HC_compress_generic_dictCtx(LZ4HC_CCtx_internal * ctx, char * src, char * dst, int * srcSizePtr, int dstCapacity, int cLevel, limitedOutput_directive limit);
int LZ4HC_compress_generic_noDictCtx(LZ4HC_CCtx_internal * ctx, char * src, char * dst, int * srcSizePtr, int dstCapacity, int cLevel, limitedOutput_directive limit);
int LZ4HC_compress_optimal(LZ4HC_CCtx_internal * ctx, char * source, char * dst, int * srcSizePtr, int dstCapacity, int nbSearches, size_t sufficient_len, limitedOutput_directive limit, int fullUpdate, dictCtx_directive dict, HCfavor_e favorDecSpeed);
uint LZ4HC_countPattern(BYTE * ip, BYTE * iEnd, U32 pattern32);
U32 LZ4HC_hashPtr(void * ptr);
void LZ4HC_init_internal(LZ4HC_CCtx_internal * hc4, BYTE * start);
int LZ4HC_protectDictEnd(U32 dictLimit, U32 matchIndex);
uint LZ4HC_reverseCountPattern(BYTE * ip, BYTE * iLow, U32 pattern);
U32 LZ4HC_rotatePattern(size_t rotate, U32 pattern);
void LZ4HC_setExternalDict(LZ4HC_CCtx_internal * ctxPtr, BYTE * newBlock);
uint LZ4_NbCommonBytes(reg_t val);
void LZ4_attach_HC_dictionary(LZ4_streamHC_t * working_stream, LZ4_streamHC_t * dictionary_stream);
void LZ4_attach_dictionary(LZ4_stream_t * workingStream, LZ4_stream_t * dictionaryStream);
int LZ4_compress(char * src, char * dest, int srcSize);
int LZ4_compressBound(int isize);
int LZ4_compressHC(char * src, char * dst, int srcSize);
int LZ4_compressHC2(char * src, char * dst, int srcSize, int cLevel);
int LZ4_compressHC2_continue(void * LZ4HC_Data, char * src, char * dst, int srcSize, int cLevel);
int LZ4_compressHC2_limitedOutput(char * src, char * dst, int srcSize, int maxDstSize, int cLevel);
int LZ4_compressHC2_limitedOutput_continue(void * LZ4HC_Data, char * src, char * dst, int srcSize, int dstCapacity, int cLevel);
int LZ4_compressHC2_limitedOutput_withStateHC(void * state, char * src, char * dst, int srcSize, int maxDstSize, int cLevel);
int LZ4_compressHC2_withStateHC(void * state, char * src, char * dst, int srcSize, int cLevel);
int LZ4_compressHC_continue(LZ4_streamHC_t * ctx, char * src, char * dst, int srcSize);
int LZ4_compressHC_continue_generic(LZ4_streamHC_t * LZ4_streamHCPtr, char * src, char * dst, int * srcSizePtr, int dstCapacity, limitedOutput_directive limit);
int LZ4_compressHC_limitedOutput(char * src, char * dst, int srcSize, int maxDstSize);
int LZ4_compressHC_limitedOutput_continue(LZ4_streamHC_t * ctx, char * src, char * dst, int srcSize, int maxDstSize);
int LZ4_compressHC_limitedOutput_withStateHC(void * state, char * src, char * dst, int srcSize, int maxDstSize);
int LZ4_compressHC_withStateHC(void * state, char * src, char * dst, int srcSize);
int LZ4_compress_HC(char * src, char * dst, int srcSize, int dstCapacity, int compressionLevel);
int LZ4_compress_HC_continue(LZ4_streamHC_t * LZ4_streamHCPtr, char * src, char * dst, int srcSize, int dstCapacity);
int LZ4_compress_HC_continue_destSize(LZ4_streamHC_t * LZ4_streamHCPtr, char * src, char * dst, int * srcSizePtr, int targetDestSize);
int LZ4_compress_HC_destSize(void * state, char * source, char * dest, int * sourceSizePtr, int targetDestSize, int cLevel);
int LZ4_compress_HC_extStateHC(void * state, char * src, char * dst, int srcSize, int dstCapacity, int compressionLevel);
int LZ4_compress_HC_extStateHC_fastReset(void * state, char * src, char * dst, int srcSize, int dstCapacity, int compressionLevel);
int LZ4_compress_continue(LZ4_stream_t * LZ4_stream, char * source, char * dest, int inputSize);
int LZ4_compress_default(char * src, char * dst, int srcSize, int maxOutputSize);
int LZ4_compress_destSize(char * src, char * dst, int * srcSizePtr, int targetDstSize);
int LZ4_compress_destSize_extState(LZ4_stream_t * state, char * src, char * dst, int * srcSizePtr, int targetDstSize);
int LZ4_compress_fast(char * source, char * dest, int inputSize, int maxOutputSize, int acceleration);
int LZ4_compress_fast_continue(LZ4_stream_t * LZ4_stream, char * source, char * dest, int inputSize, int maxOutputSize, int acceleration);
int LZ4_compress_fast_extState(void * state, char * source, char * dest, int inputSize, int maxOutputSize, int acceleration);
int LZ4_compress_fast_extState_fastReset(void * state, char * src, char * dst, int srcSize, int dstCapacity, int acceleration);
int LZ4_compress_forceExtDict(LZ4_stream_t * LZ4_dict, char * source, char * dest, int srcSize);
int LZ4_compress_limitedOutput(char * source, char * dest, int inputSize, int maxOutputSize);
int LZ4_compress_limitedOutput_continue(LZ4_stream_t * LZ4_stream, char * src, char * dst, int srcSize, int dstCapacity);
int LZ4_compress_limitedOutput_withState(void * state, char * src, char * dst, int srcSize, int dstSize);
int LZ4_compress_withState(void * state, char * src, char * dst, int srcSize);
void * LZ4_create(char * inputBuffer);
void * LZ4_createHC(char * inputBuffer);
LZ4_stream_t * LZ4_createStream(void);
LZ4_streamDecode_t * LZ4_createStreamDecode(void);
LZ4_streamHC_t * LZ4_createStreamHC(void);
int LZ4_decoderRingBufferSize(int maxBlockSize);
int LZ4_decompress_fast(char * source, char * dest, int originalSize);
int LZ4_decompress_fast_continue(LZ4_streamDecode_t * LZ4_streamDecode, char * source, char * dest, int originalSize);
int LZ4_decompress_fast_extDict(char * source, char * dest, int originalSize, void * dictStart, size_t dictSize);
int LZ4_decompress_fast_usingDict(char * source, char * dest, int originalSize, char * dictStart, int dictSize);
int LZ4_decompress_fast_withPrefix64k(char * source, char * dest, int originalSize);
int LZ4_decompress_safe(char * source, char * dest, int compressedSize, int maxDecompressedSize);
int LZ4_decompress_safe_continue(LZ4_streamDecode_t * LZ4_streamDecode, char * source, char * dest, int compressedSize, int maxOutputSize);
int LZ4_decompress_safe_forceExtDict(char * source, char * dest, int compressedSize, int maxOutputSize, void * dictStart, size_t dictSize);
int LZ4_decompress_safe_partial(char * src, char * dst, int compressedSize, int targetOutputSize, int dstCapacity);
int LZ4_decompress_safe_partial_forceExtDict(char * source, char * dest, int compressedSize, int targetOutputSize, int dstCapacity, void * dictStart, size_t dictSize);
int LZ4_decompress_safe_partial_usingDict(char * source, char * dest, int compressedSize, int targetOutputSize, int dstCapacity, char * dictStart, int dictSize);
int LZ4_decompress_safe_partial_withPrefix64k(char * source, char * dest, int compressedSize, int targetOutputSize, int dstCapacity);
int LZ4_decompress_safe_partial_withSmallPrefix(char * source, char * dest, int compressedSize, int targetOutputSize, int dstCapacity, size_t prefixSize);
int LZ4_decompress_safe_usingDict(char * source, char * dest, int compressedSize, int maxOutputSize, char * dictStart, int dictSize);
int LZ4_decompress_safe_withPrefix64k(char * source, char * dest, int compressedSize, int maxOutputSize);
int LZ4_decompress_safe_withSmallPrefix(char * source, char * dest, int compressedSize, int maxOutputSize, size_t prefixSize);
void LZ4_favorDecompressionSpeed(LZ4_streamHC_t * LZ4_streamHCPtr, int favor);
int LZ4_freeHC(void * LZ4HC_Data);
int LZ4_freeStream(LZ4_stream_t * LZ4_stream);
int LZ4_freeStreamDecode(LZ4_streamDecode_t * LZ4_stream);
int LZ4_freeStreamHC(LZ4_streamHC_t * LZ4_streamHCPtr);
BYTE * LZ4_getPositionOnHash(U32 h, void * tableBase, tableType_t tableType, BYTE * srcBase);
LZ4_stream_t * LZ4_initStream(void * buffer, size_t size);
LZ4_streamHC_t * LZ4_initStreamHC(void * buffer, size_t size);
int LZ4_isAligned(void * ptr, size_t alignment);
uint LZ4_isLittleEndian(void);
int LZ4_loadDict(LZ4_stream_t * LZ4_dict, char * dictionary, int dictSize);
int LZ4_loadDictHC(LZ4_streamHC_t * LZ4_streamHCPtr, char * dictionary, int dictSize);
U16 LZ4_read16(void * ptr);
U32 LZ4_read32(void * ptr);
U16 LZ4_readLE16(void * memPtr);
reg_t LZ4_read_ARCH(void * ptr);
void LZ4_renormDictT(LZ4_stream_t_internal * LZ4_dict, int nextSize);
void LZ4_resetStream(LZ4_stream_t * LZ4_stream);
void LZ4_resetStreamHC(LZ4_streamHC_t * LZ4_streamHCPtr, int compressionLevel);
void LZ4_resetStreamHC_fast(LZ4_streamHC_t * LZ4_streamHCPtr, int compressionLevel);
int LZ4_resetStreamState(void * state, char * inputBuffer);
int LZ4_resetStreamStateHC(void * state, char * inputBuffer);
void LZ4_resetStream_fast(LZ4_stream_t * ctx);
int LZ4_saveDict(LZ4_stream_t * LZ4_dict, char * safeBuffer, int dictSize);
int LZ4_saveDictHC(LZ4_streamHC_t * LZ4_streamHCPtr, char * safeBuffer, int dictSize);
void LZ4_setCompressionLevel(LZ4_streamHC_t * LZ4_streamHCPtr, int compressionLevel);
int LZ4_setStreamDecode(LZ4_streamDecode_t * LZ4_streamDecode, char * dictionary, int dictSize);
int LZ4_sizeofState(void);
int LZ4_sizeofStateHC(void);
int LZ4_sizeofStreamState(void);
int LZ4_sizeofStreamStateHC(void);
char * LZ4_slideInputBuffer(void * state);
char * LZ4_slideInputBufferHC(void * LZ4HC_Data);
size_t LZ4_streamHC_t_alignment(void);
size_t LZ4_stream_t_alignment(void);
int LZ4_uncompress(char * source, char * dest, int outputSize);
int LZ4_uncompress_unknownOutputSize(char * source, char * dest, int isize, int maxOutputSize);
int LZ4_versionNumber(void);
char * LZ4_versionString(void);
void LZ4_write16(void * memPtr, U16 value);
void LZ4_write32(void * memPtr, U32 value);
void LZ4_writeLE16(void * memPtr, U16 value);
int PT1_display_result_on_LCD(void);
int PT1_plus_display_result_on_LCD(void);
void * PT1_show_status_func(void * arg);
int PT2_display_result_on_LCD(uint32_t test_loop_index);
void * PT2_show_status_func(void * arg);
void SWEEP_display_result_on_LCD(void);
int Single_Board_DropLevel_Test(void);
int Single_Board_PT1_New_Test(void);
int Single_Board_PT1_Plus_Software_Pattern_Test(void);
int Single_Board_PT1_Plus_Test(void);
int Single_Board_PT1_Test(void);
int Single_Board_PT2_Autogen_Pattern_Test(void);
int Single_Board_PT2_Hardware_Pattern_Test(void);
int Single_Board_PT2_Software_Pattern_Test(void);
int Single_Board_PT2_Super_Software_Pattern_Test(void);
int Single_Board_PT2_Test(void);
int Single_Board_PT3_Test(void);
void Single_Board_Reset_Low_Test(void);
int Single_Board_Sweep_Test(void);
void * X509V3_EXT_D2I(void * param0, uchar * * param1, long param2);
void X509V3_EXT_FREE(void * param0);
int X509V3_EXT_I2D(void * param0, uchar * * param1);
int X509V3_EXT_I2R(v3_ext_method * method, void * ext, BIO * out, int indent);
char * X509V3_EXT_I2S(v3_ext_method * method, void * ext);
stack_st_CONF_VALUE * X509V3_EXT_I2V(v3_ext_method * method, void * ext, stack_st_CONF_VALUE * extlist);
void * X509V3_EXT_NEW(void);
void * X509V3_EXT_R2I(v3_ext_method * method, v3_ext_ctx * ctx, char * str);
void * X509V3_EXT_S2I(v3_ext_method * method, v3_ext_ctx * ctx, char * str);
void * X509V3_EXT_V2I(v3_ext_method * method, v3_ext_ctx * ctx, stack_st_CONF_VALUE * values);
uint XXH32(void * input, size_t len, uint seed);
U32 XXH32_avalanche(U32 h32);
void XXH32_canonicalFromHash(XXH32_canonical_t * dst, XXH32_hash_t hash);
void XXH32_copyState(XXH32_state_t * dstState, XXH32_state_t * srcState);
XXH32_state_t * XXH32_createState(void);
uint XXH32_digest(XXH32_state_t * state_in);
U32 XXH32_finalize(U32 h32, void * ptr, size_t len, XXH_endianess endian, XXH_alignment align);
XXH_errorcode XXH32_freeState(XXH32_state_t * statePtr);
XXH32_hash_t XXH32_hashFromCanonical(XXH32_canonical_t * src);
XXH_errorcode XXH32_reset(XXH32_state_t * statePtr, uint seed);
U32 XXH32_round(U32 seed, U32 input);
XXH_errorcode XXH32_update(XXH32_state_t * state_in, void * input, size_t len);
ulonglong XXH64(void * input, size_t len, ulonglong seed);
U64 XXH64_avalanche(U64 h64);
void XXH64_canonicalFromHash(XXH64_canonical_t * dst, XXH64_hash_t hash);
void XXH64_copyState(XXH64_state_t * dstState, XXH64_state_t * srcState);
XXH64_state_t * XXH64_createState(void);
ulonglong XXH64_digest(XXH64_state_t * state_in);
U64 XXH64_finalize(U64 h64, void * ptr, size_t len, XXH_endianess endian, XXH_alignment align);
XXH_errorcode XXH64_freeState(XXH64_state_t * statePtr);
XXH64_hash_t XXH64_hashFromCanonical(XXH64_canonical_t * src);
U64 XXH64_mergeRound(U64 acc, U64 val);
XXH_errorcode XXH64_reset(XXH64_state_t * statePtr, ulonglong seed);
U64 XXH64_round(U64 acc, U64 input);
XXH_errorcode XXH64_update(XXH64_state_t * state_in, void * input, size_t len);
void XXH_free(void * p);
int XXH_isLittleEndian(void);
void * XXH_malloc(size_t s);
void * XXH_memcpy(void * dest, void * src, size_t size);
U32 XXH_read32(void * ptr);
U64 XXH_read64(void * ptr);
U32 XXH_readBE32(void * ptr);
U64 XXH_readBE64(void * ptr);
uint XXH_versionNumber(void);
void __bin2hex(char * s, uchar * p, size_t len);
uint __bswap_32(uint __bsx);
void __child(void);
int __compar_fn_t(void * param0, void * param1);
void __destr_function(void * param0);
DItype __fixdfdi(DFtype a);
UDItype __fixunsdfdi(DFtype a);
void __func(int __status, void * __arg);
void __init_routine(void);
char * __json_array_string(json_t * val, uint entry);
void __left_rotate(clib_rb * pTree, clib_rb_node * x);
void __libc_csu_fini(void);
void __libc_csu_init(int argc, char * * argv, char * * envp);
void __parent(void);
void __prepare(void);
int __pthread_atfork(_func_void * prepare, _func_void * parent, _func_void * child);
void __right_rotate(clib_rb * pTree, clib_rb_node * x);
void __sighandler_t(int param0);
void * __start_routine(void * param0);
int __stat(char * file, stat * buf);
UDItype __udivmoddi4(UDItype n, UDItype d, UDItype * rp);
void _applog(int prio, char * str, _Bool force);
int32_t _bitmain_get_power_fw_version(int32_t fd);
int32_t _bitmain_pic_seek_1704(int32_t fd, uint32_t addr);
int32_t _bitmain_set_DA_conversion_N(int32_t fd, uint8_t N);
int32_t _bitmain_set_watchdog(int32_t fd, uint8_t ctrl);
int32_t _bitmain_set_watchdog_v2(int32_t fd, uint8_t ctrl);
int _func_1220(EVP_MD_CTX * ctx);
int _func_1221(EVP_MD_CTX * ctx, void * data, size_t count);
int _func_1222(EVP_MD_CTX * ctx, uchar * md);
int _func_1223(EVP_MD_CTX * to, EVP_MD_CTX * from);
int _func_1224(EVP_MD_CTX * ctx);
int _func_1225(int type, uchar * m, uint m_length, uchar * sigret, uint * siglen, void * key);
int _func_1226(int type, uchar * m, uint m_length, uchar * sigbuf, uint siglen, void * key);
int _func_1227(EVP_MD_CTX * ctx, int cmd, int p1, void * p2);
int _func_1230(EVP_MD_CTX * ctx, void * data, size_t count);
int _func_1231(EVP_CIPHER_CTX * ctx, uchar * key, uchar * iv, int enc);
int _func_1232(EVP_CIPHER_CTX * ctx, uchar * out, uchar * in, size_t inl);
int _func_1233(EVP_CIPHER_CTX * param0);
int _func_1234(EVP_CIPHER_CTX * param0, ASN1_TYPE * param1);
int _func_1235(EVP_CIPHER_CTX * param0, ASN1_TYPE * param1);
int _func_1236(EVP_CIPHER_CTX * param0, int type, int arg, void * ptr);
int _func_1760(int flen, uchar * from, uchar * to, RSA * rsa, int padding);
int _func_1761(int flen, uchar * from, uchar * to, RSA * rsa, int padding);
int _func_1762(int flen, uchar * from, uchar * to, RSA * rsa, int padding);
int _func_1763(int flen, uchar * from, uchar * to, RSA * rsa, int padding);
int _func_1764(BIGNUM * r0, BIGNUM * I, RSA * rsa, BN_CTX * ctx);
int _func_1765(BIGNUM * r, BIGNUM * a, BIGNUM * p, BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx);
int _func_1766(RSA * rsa);
int _func_1767(RSA * rsa);
int _func_1768(int type, uchar * m, uint m_length, uchar * sigret, uint * siglen, RSA * rsa);
int _func_1769(int dtype, uchar * m, uint m_length, uchar * sigbuf, uint siglen, RSA * rsa);
int _func_1770(RSA * rsa, int bits, BIGNUM * e, BN_GENCB * cb);
int _func_1843(DH * dh);
int _func_1844(uchar * key, BIGNUM * pub_key, DH * dh);
int _func_1845(DH * dh, BIGNUM * r, BIGNUM * a, BIGNUM * p, BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx);
int _func_1846(DH * dh);
int _func_1847(DH * dh);
int _func_1848(DH * dh, int prime_len, int generator, BN_GENCB * cb);
DSA_SIG * _func_1875(uchar * dgst, int dlen, DSA * dsa);
int _func_1876(DSA * dsa, BN_CTX * ctx_in, BIGNUM * * kinvp, BIGNUM * * rp);
int _func_1877(uchar * dgst, int dgst_len, DSA_SIG * sig, DSA * dsa);
int _func_1878(DSA * dsa, BIGNUM * rr, BIGNUM * a1, BIGNUM * p1, BIGNUM * a2, BIGNUM * p2, BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * in_mont);
int _func_1879(DSA * dsa, BIGNUM * r, BIGNUM * a, BIGNUM * p, BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx);
int _func_1880(DSA * dsa);
int _func_1881(DSA * dsa);
int _func_1882(DSA * dsa, int bits, uchar * seed, int seed_len, int * counter_ret, ulong * h_ret, BN_GENCB * cb);
int _func_1883(DSA * dsa);
int _func_1956(x509_trust_st * param0, X509 * param1, int param2);
int _func_1976(X509_LOOKUP * ctx);
void _func_1977(X509_LOOKUP * ctx);
int _func_1978(X509_LOOKUP * ctx);
int _func_1979(X509_LOOKUP * ctx);
int _func_1980(X509_LOOKUP * ctx, int cmd, char * argc, long argl, char * * ret);
int _func_1981(X509_LOOKUP * ctx, int type, X509_NAME * name, X509_OBJECT * ret);
int _func_1982(X509_LOOKUP * ctx, int type, X509_NAME * name, ASN1_INTEGER * serial, X509_OBJECT * ret);
int _func_1983(X509_LOOKUP * ctx, int type, uchar * bytes, int len, X509_OBJECT * ret);
int _func_1984(X509_LOOKUP * ctx, int type, char * str, int len, X509_OBJECT * ret);
int _func_1985(X509_STORE_CTX * ctx);
int _func_1986(int ok, X509_STORE_CTX * ctx);
int _func_1987(X509 * * issuer, X509_STORE_CTX * ctx, X509 * x);
int _func_1988(X509_STORE_CTX * ctx, X509 * x, X509 * issuer);
int _func_1989(X509_STORE_CTX * ctx);
int _func_1990(X509_STORE_CTX * ctx, X509_CRL * * crl, X509 * x);
int _func_1991(X509_STORE_CTX * ctx, X509_CRL * crl);
int _func_1992(X509_STORE_CTX * ctx, X509_CRL * crl, X509 * x);
stack_st_X509 * _func_1993(X509_STORE_CTX * ctx, X509_NAME * nm);
stack_st_X509_CRL * _func_1994(X509_STORE_CTX * ctx, X509_NAME * nm);
int _func_1995(X509_STORE_CTX * ctx);
int _func_1997(X509_STORE_CTX * ctx);
int _func_1998(int ok, X509_STORE_CTX * ctx);
int _func_1999(X509 * * issuer, X509_STORE_CTX * ctx, X509 * x);
int _func_2000(X509_STORE_CTX * ctx, X509 * x, X509 * issuer);
int _func_2001(X509_STORE_CTX * ctx);
int _func_2002(X509_STORE_CTX * ctx, X509_CRL * * crl, X509 * x);
int _func_2003(X509_STORE_CTX * ctx, X509_CRL * crl);
int _func_2004(X509_STORE_CTX * ctx, X509_CRL * crl, X509 * x);
int _func_2005(X509_STORE_CTX * ctx);
stack_st_X509 * _func_2006(X509_STORE_CTX * ctx, X509_NAME * nm);
stack_st_X509_CRL * _func_2007(X509_STORE_CTX * ctx, X509_NAME * nm);
int _func_2008(X509_STORE_CTX * ctx);
int _func_290(void * param0, void * param1);
int _func_3195(SSL * s);
void _func_3196(SSL * s);
void _func_3197(SSL * s);
int _func_3198(SSL * s);
int _func_3199(SSL * s);
int _func_3200(SSL * s, void * buf, int len);
int _func_3201(SSL * s, void * buf, int len);
int _func_3202(SSL * s, void * buf, int len);
int _func_3203(SSL * s);
int _func_3204(SSL * s);
int _func_3205(SSL * s);
long _func_3206(SSL * s, int st1, int stn, int mt, long max, int * ok);
int _func_3207(SSL * s, int type, uchar * buf, int len, int peek);
int _func_3208(SSL * s, int type, void * buf_, int len);
int _func_3209(SSL * s);
long _func_3210(SSL * s, int cmd, long larg, void * parg);
long _func_3211(SSL_CTX * ctx, int cmd, long larg, void * parg);
SSL_CIPHER * _func_3212(uchar * ptr);
int _func_3213(SSL_CIPHER * cipher, uchar * ptr);
int _func_3214(SSL * s);
int _func_3215(void);
SSL_CIPHER * _func_3216(uint ncipher);
ssl_method_st * _func_3217(int version);
long _func_3218(void);
int _func_3219(void);
long _func_3220(SSL * s, int cb_id, fp * fp);
long _func_3222(SSL_CTX * s, int cb_id, fp * fp);
int _func_3229(ssl_st * ssl, SSL_SESSION * sess);
void _func_3230(ssl_ctx_st * ctx, SSL_SESSION * sess);
SSL_SESSION * _func_3231(ssl_st * ssl, uchar * data, int len, int * copy);
int _func_3232(X509_STORE_CTX * param0, void * param1);
int _func_3233(SSL * ssl, X509 * * x509, EVP_PKEY * * pkey);
int _func_3234(SSL * ssl, uchar * cookie, uint * cookie_len);
int _func_3235(SSL * ssl, uchar * cookie, uint cookie_len);
void _func_3236(SSL * ssl, int type, int val);
void _func_3237(int write_p, int version, int content_type, void * buf, size_t len, SSL * ssl, void * arg);
int _func_3238(int ok, X509_STORE_CTX * ctx);
int _func_3239(SSL * param0, int * param1, void * param2);
int _func_3240(SSL * ssl, uchar * name, uchar * iv, EVP_CIPHER_CTX * ectx, HMAC_CTX * hctx, int enc);
int _func_3241(SSL * ssl, void * arg);
int _func_3242(SSL * param0, void * peerinput, size_t len, void * arg);
uint _func_3243(SSL * ssl, char * hint, char * identity, uint max_identity_len, uchar * psk, uint max_psk_len);
uint _func_3244(SSL * ssl, char * identity, uchar * psk, uint max_psk_len);
int _func_3245(SSL * s, uchar * * buf, uint * len, void * arg);
int _func_3246(SSL * s, uchar * * out, uchar * outlen, uchar * in, uint inlen, void * arg);
int _func_3291(SSL * param0);
void _func_3292(int write_p, int version, int content_type, void * buf, size_t len, SSL * ssl, void * arg);
int _func_3293(int ok, X509_STORE_CTX * ctx);
void _func_3294(SSL * ssl, int type, int val);
uint _func_3295(SSL * ssl, char * hint, char * identity, uint max_identity_len, uchar * psk, uint max_psk_len);
uint _func_3296(SSL * ssl, char * identity, uchar * psk, uint max_psk_len);
void _func_3297(SSL * s, int client_server, int type, uchar * data, int len, void * arg);
void _func_3517(void);
void _func_3520(void);
CONF * _func_3806(CONF_METHOD * meth);
int _func_3807(CONF * conf);
int _func_3808(CONF * conf);
int _func_3809(CONF * conf);
int _func_3810(CONF * conf, BIO * bp, long * eline);
int _func_3811(CONF * conf, BIO * bp);
int _func_3812(CONF * conf, char c);
int _func_3813(CONF * conf, char c);
int _func_3814(CONF * conf, char * name, long * eline);
int _func_3874(DSO * dso);
int _func_3875(DSO * dso);
void * _func_3876(DSO * dso, char * symname);
DSO_FUNC_TYPE _func_3877(DSO * dso, char * symname);
long _func_3878(DSO * dso, int cmd, long larg, void * parg);
int _func_3879(DSO * dso);
int _func_3880(DSO * dso);
int _func_3881(void * addr, char * path, int sz);
void * _func_3882(char * symname);
void _func_3912(void * buf, int num);
int _func_3913(uchar * buf, int num);
void _func_3914(void);
void _func_3915(void * buf, int num, double entropy);
int _func_3916(uchar * buf, int num);
int _func_3917(void);
char * _func_4287(void * db, char * section, char * value);
stack_st_CONF_VALUE * _func_4288(void * db, char * section);
void _func_4289(void * db, char * string);
void _func_4290(void * db, stack_st_CONF_VALUE * section);
int _func_4299(x509_purpose_st * param0, X509 * param1, int param2);
int _func_4786(OPENSSL_STRING * param0);
void _func_4848(int param0, siginfo_t * param1, void * param2);
void _func_4849(void);
void _func_556(int param0, int param1, void * param2);
int _func_557(int param0, int param1, BN_GENCB * param2);
int _func_711(COMP_CTX * ctx);
void _func_712(COMP_CTX * ctx);
int _func_713(COMP_CTX * ctx, uchar * out, uint olen, uchar * in, uint ilen);
int _func_714(COMP_CTX * ctx, uchar * out, uint olen, uchar * in, uint ilen);
long _func_715(void);
long _func_716(void);
int _func_737(BIO * param0, char * param1, int param2);
int _func_738(BIO * param0, char * param1, int param2);
int _func_739(BIO * param0, char * param1);
int _func_740(BIO * param0, char * param1, int param2);
long _func_741(BIO * param0, int param1, long param2, void * param3);
int _func_742(BIO * param0);
int _func_743(BIO * param0);
long _func_744(BIO * param0, int param1, bio_info_cb * param2);
long _func_745(bio_st * param0, int param1, char * param2, int param3, long param4, long param5);
clib_object * _func_clib_object_ptr_clib_iterator_ptr(clib_iterator * param0);
eeprom_data_format_t * _func_eeprom_data_format_t_ptr(void);
int32_t _func_int32_t_char_ptr(char * param0);
int32_t _func_int32_t_uint32_t(uint32_t param0);
int32_t _func_int32_t_uint32_t_void_ptr(uint32_t param0, void * param1);
int _func_int_char_ptr_size_t_void_ptr(char * param0, size_t param1, void * param2);
int _func_int_edf_ctx_p(edf_ctx_p param0);
int _func_int_edf_ctx_p_char_ptr_size_t_ptr(edf_ctx_p param0, char * param1, size_t * param2);
int _func_int_edf_ctx_p_char_ptr_size_t_ptr_size_t_ptr(edf_ctx_p.conflict param0, char * param1, size_t * param2, size_t * param3);
int _func_int_edf_ctx_p_int8_t(edf_ctx_p param0, int8_t param1);
int _func_int_edf_ctx_p_uint16_t(edf_ctx_p param0, uint16_t param1);
int _func_int_edf_ctx_p_uint8_t(edf_ctx_p param0, uint8_t param1);
int _func_int_edf_ctx_p_uint8_t_ptr_size_t_int(edf_ctx_p.conflict param0, uint8_t * param1, size_t param2, int param3);
int _func_int_edf_ctx_p_uint8_t_ptr_size_t_ptr(edf_ctx_p param0, uint8_t * param1, size_t * param2);
int _func_int_float_ptr_ptr(float * * param0);
int _func_int_float_ptr_ptr_uint8_t_ptr_ptr(float * * param0, uint8_t * * param1);
int _func_int_varargs(void);
int _func_int_void_ptr(void * param0);
int _func_int_void_ptr_char_ptr_char_ptr_int_int_int_LZ4F_CDict_ptr(void * param0, char * param1, char * param2, int param3, int param4, int param5, LZ4F_CDict * param6);
int _func_int_void_ptr_void_ptr(void * param0, void * param1);
size_t _func_size_t_void_ptr_size_t_void_ptr(void * param0, size_t param1, void * param2);
uint32_t _func_uint32_t_edf_ctx_p(edf_ctx_p.conflict param0);
void _func_void(void);
void _func_void_clib_iterator_ptr_void_ptr_size_t(clib_iterator * param0, void * param1, size_t param2);
void _func_void_edf_ctx_p(edf_ctx_p.conflict param0);
void _func_void_int(int param0);
void _func_void_int_char_ptr_ptr_char_ptr_ptr(int param0, char * * param1, char * * param2);
void _func_void_int_siginfo_t_ptr_void_ptr(int param0, siginfo_t * param1, void * param2);
void * _func_void_ptr(void);
void * _func_void_ptr_size_t(size_t param0);
void * _func_void_ptr_void_ptr(void * param0);
void * _func_void_ptr_void_ptr_size_t(void * param0, size_t param1);
void _func_void_ui_type_e_bitmain_key_status_e(ui_type_e param0, bitmain_key_status_e param1);
void _func_void_uint32_t_uint8_t(uint32_t param0, uint8_t param1);
void _func_void_void_ptr(void * param0);
void _func_void_void_ptr_void_ptr(void * param0, void * param1);
uint32_t _get_bt8d_control(void);
uint32_t _get_dhash_acc_control(void);
uint32_t _get_hardware_version(void);
uint32_t _get_hash_counting_number(void);
uint32_t _get_job_start_address(void);
uint32_t _get_nonce2_and_job_id_store_address(void);
uint32_t _get_nonce_fifo_interrupt(void);
float _get_power_ac_power(void);
int32_t _get_power_dc_voltage_v2(void);
int32_t _get_power_enable_status_v2(void);
int32_t _get_power_err_code(_Bool clean_cache, _Bool print);
int32_t _get_power_err_data(_Bool print, uint8_t * raw_data);
int32_t _get_power_reset_rc(void);
int32_t _get_power_uptime(void);
uint32_t _get_work_fifo_state(void);
int32_t _pic_write_iic(int32_t fd, uint8_t slave, uint8_t reg, uint8_t * data, int32_t size);
void _power_down(uint32_t chain, _Bool cooling);
void * _send_work_routine(void * args);
void _set_bt8d_control(uint32_t value);
void _set_coinbase_length_and_nonce2_length(uint32_t value);
void _set_dhash_acc_control(uint32_t value);
void _set_hardware_version(uint32_t value);
void _set_hash_counting_number(uint32_t value);
void _set_job_id(uint32_t value);
void _set_job_length(uint32_t value);
void _set_job_start_address(uint32_t value);
void _set_nonce2_and_job_id_store_address(uint32_t value);
void _set_nonce_fifo_interrupt(uint32_t value);
void _set_target_bits(uint32_t value);
void _set_ticket_mask(uint32_t value);
void _set_time_out_control(uint32_t value);
void _set_time_stamp(uint32_t value);
void _set_uart_relay(uint8_t address_interval);
_Bool access_temp_synopsys_reg(uint32_t chain);
void add_bad_asic_ids(int id);
void all_chain_reset_high(void);
void all_chain_reset_low(void);
int app_gen_cookie_cb(SSL * ssl, uchar * cookie, uint * cookie_len);
int32_t app_read_data_from_flash(uint8_t which_chain, uint8_t flash_add_h, uint8_t flash_add_l, uint8_t * data, int32_t size);
int app_verify_cookie_cb(SSL * ssl, uchar * cookie, uint cookie_len);
int32_t app_write_data_into_flash(uint8_t which_chain, uint8_t flash_add_h, uint8_t flash_add_l, uint8_t * data, int32_t size);
int asn1_ps_func(BIO * b, uchar * * pbuf, int * plen, void * parg);
int atexit(_func_void * func);
int base64_decode_file(FILE * f_in, FILE * f_out);
int base64_encode_file(FILE * f_in, FILE * f_out);
int32_t beeper_flicker(void);
int32_t beeper_off(void);
int32_t beeper_on(void);
char * bin2hex(uchar * p, size_t len);
void bio_info_cb(bio_st * param0, int param1, char * param2, int param3, long param4, long param5);
int64_t bitmain_clear_power_status(void);
double bitmain_convert_N_to_V(int32_t N);
double bitmain_convert_N_to_V_furmula(int32_t N);
int32_t bitmain_convert_V_to_N(double v);
int32_t bitmain_get_err_code(_Bool clean_cache, _Bool print);
int32_t bitmain_get_err_data(_Bool print, uint8_t * raw_data);
uint32_t bitmain_get_fw_version(void);
int32_t bitmain_get_history_power_status(void);
int32_t bitmain_get_miner_power(void);
float bitmain_get_power_ac_power(void);
int32_t bitmain_get_power_enable(void);
int32_t bitmain_get_power_enable_status(void);
int32_t bitmain_get_power_input_status(void);
int32_t bitmain_get_power_status(void);
int bitmain_get_power_temp(power_temp_t * p_power_temp);
int32_t bitmain_get_power_voltage(void);
int32_t bitmain_get_reset_rc(void);
double bitmain_get_sample_voltage(void);
int32_t bitmain_get_uptime(void);
uint32_t bitmain_get_voltage(void);
int32_t bitmain_power_close(void);
int32_t bitmain_power_get_calibration_date(void);
char * bitmain_power_get_sn(void);
int32_t bitmain_power_is_calibrated(_Bool * is_calibrated);
int32_t bitmain_power_off(void);
int32_t bitmain_power_on(void);
int32_t bitmain_power_open(void);
void bitmain_power_set_is_use_calibration_data(_Bool use);
int32_t bitmain_power_sw_ver(void);
int32_t bitmain_power_version(void);
int32_t bitmain_set_voltage(double v);
int32_t bitmain_set_voltage_by_n(uint8_t n);
int32_t bitmain_set_watchdog(uint8_t ctrl);
int bn_mod_exp(BIGNUM * r, BIGNUM * a, BIGNUM * p, BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx);
void board_reset(uint32_t board_id);
void board_reset_high(uint32_t board_id);
_Bool board_temp_protect_check(int8_t max_temp, int8_t min_temp);
int buffer_get(void * data);
_Bool build_eeprom_data_pt2(_Bool pass, uint8_t * eeprom_data, size_t * len_p, size_t * offset_p, pattern_runtime_ctx * runtime, float * matrix);
uchar c2hex(uchar value);
void calc_nonce_stats(pattern_test_stats * stats, asic_status * asic_stats);
uint32_t calculate_core_number(uint32_t actual_core_number);
uint32_t calculate_hardware_sweep_timeout(uint32_t freq, uint32_t max_nonce, uint32_t timeout_clock);
uint32_t calculate_hcn(void);
uint32_t calculate_how_many_nonce_per_asic_get(uint8_t which_asic, uint32_t core_number);
long callback(bio_st * param0, int param1, char * param2, int param3, long param4, long param5);
int callback(int ok, X509_STORE_CTX * ctx);
int callback_get(void * data);
void cancle_pause_recv_nonce(void);
int cb(void * data, size_t len, void * u);
int cb(char * str, size_t len, void * u);
RSA * cb(SSL * ssl, int is_export, int keylength);
void chain_reset(uint32_t chain_id);
void chain_reset_high(uint32_t chain_id);
void chain_reset_low(uint32_t chain_id);
_Bool check_PT1_EEPROM_marker(void);
_Bool check_asic_sensor_type(char * asic_sensor_type);
_Bool check_asic_val(asic_val_t * p_val, double max_val, _Bool logout);
_Bool check_chain(void);
int32_t check_chain_hwsweep_done(uint8_t which_chain);
_Bool check_chain_plug_status(void);
_Bool check_config_information(char * asic_type);
_Bool check_ctrlboard_sensor_type(char * ctrlboard_sensor_type);
int check_env_limit(void);
int check_hashboard_plug_in(void);
void check_hotplug_realtime(bitmain_sys_capability_t * capa);
uint32_t check_how_many_uart_data_in_fpga(uchar which_uart);
int check_hw(work_format * work, uint32_t which_midstate, uint32_t nonce);
void check_nonce(return_nonce_128bit_t * nonce_buf, pattern_runtime_ctx * ctx);
int check_nonce_rate(void);
_Bool check_pic_sensor_type(char * pic_sensor_type);
_Bool check_pt2_success(eeprom_data_format_t * efd);
int32_t check_read_back_data(uint8_t * send_data, uint8_t * read_back_data, uint32_t read_back_data_len);
_Bool check_scan_code_gun(void);
_Bool check_sn_qr_code_legality(hashboard_sn * sn, hashboard_qr_code * qr_code);
_Bool check_specific_chain(int chain);
int check_unbalance(void);
_Bool check_whether_MES_system_response_is_correct(void);
_Bool check_whether_MES_system_submit_result_is_correct(json_t * response);
_Bool check_whether_hashboard_plug_in_again(void);
int ck(X509_TRUST * param0, X509 * param1, int param2);
int ck(X509_PURPOSE * param0, X509 * param1, int param2);
void cleanup(EVP_PKEY_CTX * ctx);
void clear_all_thread(void);
void clear_bad_asic_ids(void);
void clear_cache_file(void);
int32_t clear_chain_hwsweep_one_pattern_done(uint8_t which_chain);
void clear_register_buf(void);
void clear_register_value_buf(void);
void clear_uart_rx_fifo(uint32_t chain_id);
void clear_uart_tx_fifo(uint32_t chain_id);
void clear_unupload_logs(void);
void clear_uploaded_logs(void);
void clib_get(void * destination, void * source, size_t size);
char * clib_strdup(char * ptr);
int client_cert_cb(SSL * ssl, X509 * * x509, EVP_PKEY * * pkey);
void close_pic(uint8_t which_chain);
int closer(UI * ui);
int cmp(void * param0, void * param1);
int cmp_func(char * param0, char * param1);
_Bool compare(float a, float b);
int compare_keys(void * key1, void * key2);
int compose_error_msg(char * sn, _Bool ok, int error_no, int error_info, char * send_msg);
int compress_file(FILE * f_in, FILE * f_out);
void conf_finish_func(CONF_IMODULE * md);
int conf_init_func(CONF_IMODULE * md, CONF * cnf);
_Bool convert_N_to_V(char * board_name, int32_t n, double * voltage);
_Bool convert_V_to_N(char * board_name, double voltage, uint32_t * N);
uint32_t convert_port_to_ui_type(uint32_t port);
uint32_t convert_ui_type_to_port(ui_type_e type);
int copy(EVP_PKEY_CTX * dst, EVP_PKEY_CTX * src);
void copy_v4_to_v5(eeprom_data_format_t * v4, eeprom_data_format_t * v5);
void copy_works_from_PT2_pattern(void * local_conf, pattern_info_new * p_info);
_Bool create_connection_to_MES_system_by_ip(void);
_Bool create_connection_to_MES_system_by_name(uint32_t which_process_to_connect_MES);
int create_connection_to_server_by_ip(char * host, int port);
int create_connection_to_server_by_name(char * host, int port);
void create_midstate_bin(void);
void create_new_log_file(char * test_type, char * sn, char * miner_type, char * board_name);
int32_t create_power_heart_beat_thread(void);
int create_socket(void);
int create_v5(eeprom_data_format_t * v5);
int ctrl(EVP_PKEY_CTX * ctx, int type, int p1, void * p2);
int ctrl_str(EVP_PKEY_CTX * ctx, char * type, char * value);
int ctxTypeID_to_size(int ctxTypeID);
void * d2i_of_void(void * * param0, uchar * * param1, long param2);
_Bool data_dec(uint32_t * buf, uint32_t len, uint8_t algorithm_type, uint8_t key_version);
_Bool data_enc(uint32_t * buf, uint32_t len, uint8_t algorithm_type, uint8_t key_version);
void debug_verify_properties(clib_rb * t);
void debug_verify_property_1(clib_rb * pTree, clib_rb_node * n);
void debug_verify_property_4(clib_rb * pTree, clib_rb_node * n);
void debug_verify_property_5_helper(clib_rb * pTree, clib_rb_node * n, int black_count, int * path_black_count);
int32_t decode_unicode_escape(char * str);
int decompress_file(FILE * f_in, FILE * f_out);
int decrypt(EVP_PKEY_CTX * ctx, uchar * out, size_t * outlen, uchar * in, size_t inlen);
int decrypt_init(EVP_PKEY_CTX * ctx);
clib_error delete_c_map(clib_map * x);
clib_error delete_c_rb(clib_rb * pTree);
void delete_clib_object(clib_object * inObject);
void delete_iterator_c_map(clib_iterator * pItr);
int derive(EVP_PKEY_CTX * ctx, uchar * key, size_t * keylen);
int derive_init(EVP_PKEY_CTX * ctx);
int32_t detect_scan_code_gun(void);
DH * dh(SSL * ssl, int is_export, int keylength);
uint32_t dhash_get_jobid_by_workid(uint32_t work_id);
int32_t dhash_get_midstate_by_workid(uint32_t work_id, uint8_t * midstate, uint32_t len);
uint64_t dhash_get_nonce2_by_workid(uint32_t work_id);
uint32_t dhash_get_version_by_workid(uint32_t work_id);
int32_t dhash_init(void);
int32_t dhash_send_job(dhash_job_info_t * job);
void dhash_set_timeout(uint32_t timeout);
int32_t dhash_uninit(void);
void disable_all_chain_reset(void);
int32_t disable_bypass_mode(void);
int32_t disable_chain_hwsweep_clock(uint8_t which_chain);
int32_t disable_dc_dc(uint8_t which_chain);
void disable_dhash_chip_work(void);
int32_t disable_dhash_fix_package_len(void);
int32_t disable_dhash_midstate_autogen(void);
int32_t disable_dhash_vil_mode(void);
int32_t disable_dhash_work_gen(void);
void disable_mid_auto_gen_rx(void);
int32_t disable_sync_header(void);
void display_main_page(void);
int do_PT2_summary_work(uint8_t test_loop_counter);
int32_t do_chain_chip_reset(uint8_t which_chain);
void do_core_reset(uint8_t * state);
void do_core_reset.conflict(void);
json_t * do_deep_copy(json_t * json, hashtable_t * parents);
int do_dump(json_t * json, size_t flags, int depth, hashtable_t * parents, json_dump_callback_t dump, void * data);
int do_object_update_recursive(json_t * object, json_t * other, hashtable_t * parents);
_Bool download_MES_system_Config_file(void);
void dump_config(config_ctx * ctx);
void dump_data(char * data, int len);
int dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void * data);
void dump_matrix_freq(float * matrix, int row, int cloumn);
void dump_matrix_state(uint8_t * state);
int dump_string(char * str, size_t len, json_dump_callback_t dump, void * data, size_t flags);
int dump_to_buffer(char * buffer, size_t size, void * data);
int dump_to_fd(char * buffer, size_t size, void * data);
int dump_to_file(char * buffer, size_t size, void * data);
int dump_to_strbuffer(char * buffer, size_t size, void * data);
_Bool easy_check_base_PT2_result(uint32_t test_loop_index);
eeprom_data_format_t * edf_create_ctx(int version);
eeprom_data_format_t * edf_get_ctx(int version);
eeprom_data_format_t * edf_load(uint8_t * src, size_t len);
int edf_v4_asic_sensor_addr_get(edf_ctx_p ctx, uint8_t * array, size_t * len);
int edf_v4_asic_sensor_addr_set(edf_ctx_p ctx, uint8_t * array, size_t * len);
int edf_v4_asic_sensor_type_get(edf_ctx_p ctx);
int edf_v4_asic_sensor_type_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_board_name_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_board_name_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_board_sn_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_board_sn_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_bom_version_get(edf_ctx_p ctx);
int edf_v4_bom_version_set(edf_ctx_p ctx, uint16_t val);
uint32_t edf_v4_capability(edf_ctx_p ctx);
int edf_v4_chip_bin_get(edf_ctx_p ctx);
int edf_v4_chip_bin_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_chip_die_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_chip_die_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_chip_marking_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_chip_marking_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_chip_tech_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_chip_tech_set(edf_ctx_p ctx, char * array, size_t * len);
void edf_v4_destroy(eeprom_data_format_t * ctx);
void edf_v4_dump_data(edf_ctx_p ctx);
int edf_v4_enc_algorithm_get(edf_ctx_p ctx);
int edf_v4_enc_algorithm_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_enc_key_version_get(edf_ctx_p ctx);
int edf_v4_enc_key_version_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_factory_job_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_factory_job_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_frequency_get(edf_ctx_p ctx);
int edf_v4_frequency_set(edf_ctx_p ctx, uint16_t val);
int edf_v4_ft_version_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v4_ft_version_set(edf_ctx_p ctx, char * array, size_t * len);
eeprom_data_format_t * edf_v4_init(void);
int edf_v4_load(edf_ctx_p ctx, uint8_t * src, size_t len, int flag);
int edf_v4_nonce_rate_get(edf_ctx_p ctx);
int edf_v4_nonce_rate_set(edf_ctx_p ctx, uint16_t val);
int edf_v4_pcb_temp_in_get(edf_ctx_p ctx);
int edf_v4_pcb_temp_in_set(edf_ctx_p ctx, int8_t val);
int edf_v4_pcb_temp_out_get(edf_ctx_p ctx);
int edf_v4_pcb_temp_out_set(edf_ctx_p ctx, int8_t val);
int edf_v4_pcb_version_get(edf_ctx_p ctx);
int edf_v4_pcb_version_set(edf_ctx_p ctx, uint16_t val);
int edf_v4_pic_sensor_addr_get(edf_ctx_p ctx);
int edf_v4_pic_sensor_addr_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_pic_sensor_type_get(edf_ctx_p ctx);
int edf_v4_pic_sensor_type_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_pt1_count_get(edf_ctx_p ctx);
int edf_v4_pt1_count_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_pt1_result_get(edf_ctx_p ctx);
int edf_v4_pt1_result_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_pt2_count_get(edf_ctx_p ctx);
int edf_v4_pt2_count_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_pt2_result_get(edf_ctx_p ctx);
int edf_v4_pt2_result_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_region_1_encode(edf_ctx_p ctx, char * dst, size_t * len, size_t * offset);
int edf_v4_region_2_encode(edf_ctx_p ctx, char * dst, size_t * len, size_t * offset);
int edf_v4_test_standard_get(edf_ctx_p ctx);
int edf_v4_test_standard_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_test_version_get(edf_ctx_p ctx);
int edf_v4_test_version_set(edf_ctx_p ctx, uint8_t val);
int edf_v4_version_get(edf_ctx_p ctx);
int edf_v4_voltage_get(edf_ctx_p ctx);
int edf_v4_voltage_set(edf_ctx_p ctx, uint16_t val);
int edf_v5_asic_sensor_addr_get(edf_ctx_p ctx, uint8_t * array, size_t * len);
int edf_v5_asic_sensor_addr_set(edf_ctx_p ctx, uint8_t * array, size_t * len);
int edf_v5_asic_sensor_type_get(edf_ctx_p ctx);
int edf_v5_asic_sensor_type_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_board_name_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_board_name_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_board_sn_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_board_sn_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_bom_version_get(edf_ctx_p ctx);
int edf_v5_bom_version_set(edf_ctx_p ctx, uint16_t val);
uint32_t edf_v5_capability(edf_ctx_p ctx);
int edf_v5_chip_bin_get(edf_ctx_p ctx);
int edf_v5_chip_bin_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_chip_die_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_chip_die_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_chip_marking_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_chip_marking_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_chip_tech_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_chip_tech_set(edf_ctx_p ctx, char * array, size_t * len);
void edf_v5_destroy(eeprom_data_format_t * ctx);
void edf_v5_dump_data(edf_ctx_p ctx);
int edf_v5_enc_algorithm_get(edf_ctx_p ctx);
int edf_v5_enc_algorithm_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_enc_key_version_get(edf_ctx_p ctx);
int edf_v5_enc_key_version_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_factory_job_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_factory_job_set(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_frequency_get(edf_ctx_p ctx);
int edf_v5_frequency_set(edf_ctx_p ctx, uint16_t val);
int edf_v5_ft_version_get(edf_ctx_p ctx, char * array, size_t * len);
int edf_v5_ft_version_set(edf_ctx_p ctx, char * array, size_t * len);
eeprom_data_format_t * edf_v5_init(void);
int edf_v5_load(edf_ctx_p ctx, uint8_t * src, size_t len, int flag);
int edf_v5_nonce_rate_get(edf_ctx_p ctx);
int edf_v5_nonce_rate_set(edf_ctx_p ctx, uint16_t val);
int edf_v5_pcb_temp_in_get(edf_ctx_p ctx);
int edf_v5_pcb_temp_in_set(edf_ctx_p ctx, int8_t val);
int edf_v5_pcb_temp_out_get(edf_ctx_p ctx);
int edf_v5_pcb_temp_out_set(edf_ctx_p ctx, int8_t val);
int edf_v5_pcb_version_get(edf_ctx_p ctx);
int edf_v5_pcb_version_set(edf_ctx_p ctx, uint16_t val);
int edf_v5_pic_sensor_addr_get(edf_ctx_p ctx);
int edf_v5_pic_sensor_addr_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_pic_sensor_type_get(edf_ctx_p ctx);
int edf_v5_pic_sensor_type_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_pt1_count_get(edf_ctx_p ctx);
int edf_v5_pt1_count_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_pt1_result_get(edf_ctx_p ctx);
int edf_v5_pt1_result_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_pt2_count_get(edf_ctx_p ctx);
int edf_v5_pt2_count_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_pt2_result_get(edf_ctx_p ctx);
int edf_v5_pt2_result_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_region_1_encode(edf_ctx_p ctx, char * dst, size_t * len, size_t * offset);
int edf_v5_region_2_encode(edf_ctx_p ctx, char * dst, size_t * len, size_t * offset);
int edf_v5_region_3_encode(edf_ctx_p ctx, char * dst, size_t * len, size_t * offset);
int edf_v5_sweep_freq_base_get(edf_ctx_p ctx);
int edf_v5_sweep_freq_base_set(edf_ctx_p ctx, uint16_t val);
int edf_v5_sweep_freq_step_get(edf_ctx_p ctx);
int edf_v5_sweep_freq_step_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_sweep_hashrate_get(edf_ctx_p ctx);
int edf_v5_sweep_hashrate_set(edf_ctx_p ctx, uint16_t val);
int edf_v5_sweep_level_get(edf_ctx_p ctx, uint8_t * array, size_t * len);
int edf_v5_sweep_level_set(edf_ctx_p ctx, uint8_t * array, size_t * len);
int edf_v5_sweep_result_get(edf_ctx_p ctx);
int edf_v5_sweep_result_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_test_standard_get(edf_ctx_p ctx);
int edf_v5_test_standard_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_test_version_get(edf_ctx_p ctx);
int edf_v5_test_version_set(edf_ctx_p ctx, uint8_t val);
int edf_v5_version_get(edf_ctx_p ctx);
int edf_v5_voltage_get(edf_ctx_p ctx);
int edf_v5_voltage_set(edf_ctx_p ctx, uint16_t val);
void eeprom_close(uint32_t which_chain);
int32_t eeprom_get_sweep_result(sweep_result_t * sweep_result, edf_ctx_p ctx);
int32_t eeprom_open(uint32_t which_chain);
int32_t eeprom_read(uint32_t which_chain, uint8_t addr, uint8_t * buf, uint32_t len);
int32_t eeprom_write(uint32_t which_chain, uint8_t addr, uint8_t * buf, uint32_t len);
clib_bool empty_c_rb(clib_rb * pTree);
void enable_all_chain_reset(void);
int32_t enable_asic_ordered_clock(uint8_t which_chain, uint32_t which_asic_address, _Bool is_enable);
int32_t enable_asic_pad_check(uint8_t which_chain, uint32_t which_asic_address, _Bool pad_check_enable);
int32_t enable_bypass_mode(void);
int32_t enable_chain_hwsweep_clock(uint8_t which_chain);
int32_t enable_chain_ordered_clock(uint8_t which_chain, _Bool is_enable);
int32_t enable_chain_pad_check(uint8_t which_chain, _Bool pad_check_enable);
int32_t enable_dc_dc(uint8_t which_chain);
int32_t enable_dhash_fix_package_len(void);
int32_t enable_dhash_midstate_autogen(void);
int32_t enable_dhash_vil_mode(void);
int32_t enable_dhash_work_gen(void);
void enable_mid_auto_gen_rx(void);
_Bool enable_power_calibration(void);
int32_t enable_sync_header(void);
void enable_work_send(void);
int32_t enbale_chain_hwsweep(uint8_t which_chain, uint8_t sweep_pattern_num);
int encrypt_init(EVP_PKEY_CTX * ctx);
int encryptfn(EVP_PKEY_CTX * ctx, uchar * out, size_t * outlen, uchar * in, size_t inlen);
void err_exit(char * err_info);
void error_set(json_error_t * error, lex_t * lex, json_error_code code, char * msg);
int32_t exec_power_cmd(int32_t fd, uint8_t * send_data, uint32_t send_data_len, uint8_t * read_back_data, uint32_t read_back_data_len);
int32_t exec_power_cmd_v2(int32_t fd, uint8_t * send_data, uint32_t send_data_len, uint8_t * read_back_data, uint32_t read_back_data_len);
clib_bool exists_c_map(clib_map * pMap, void * key);
void f(void * param0, int param1);
void f(void);
void fake_more_levels(void);
int32_t fan_get_max_num(void);
int32_t fan_get_max_speed(bitmain_fan_id_e id);
int32_t fan_get_realtime_speed(bitmain_fan_id_e id);
int32_t fan_init(void);
_Bool fan_protect_check(void);
_Bool fan_speed_check(void);
int32_t fan_turn_off(bitmain_fan_side_e side);
int32_t fan_turn_on(bitmain_fan_side_e side);
void fan_uninit(void);
int fd_get_func(int * fd);
_Bool find_APW_power_version(int32_t apw_power_version);
int find_bad_ri_asic(void);
clib_bool find_c_map(clib_map * pMap, void * key, void * * value);
clib_rb_node * find_c_rb(clib_rb * pTree, void * key);
int32_t find_index(uint32_t which_chain, uint8_t slave_addr);
uint32_t find_ng_asic_id(uint32_t * id_buf, uint32_t num);
uint8_t find_submit_history_result_index(uint8_t * history_result_index);
_Bool find_test_standard_position(char * miner_type, char * board_name, char * asic_type, char * hardware_version, char * bom_version, char * chip_technology, char * ft_version, uint32_t bin);
void fix_pattern_file(void);
void flip32(void * dest_p, void * src_p);
int flush_eeprom_data(float * matrix, int chain);
int32_t flush_nonce3_buffer(void);
int32_t flush_scanner_data(void);
int flusher(UI * ui);
void fn(EVP_MD * ciph, char * from, char * to, void * x);
void fn(OBJ_NAME * param0, void * arg);
void fp(bio_st * param0, int param1, char * param2, int param3, long param4, long param5);
void fp(void);
void fpga_chain_reset_all(void);
int32_t fpga_init(void);
int32_t fpga_read(uint32_t address, uint32_t * val);
void fpga_uninit(void);
int32_t fpga_write(uint32_t address, uint32_t val);
void free_func(char * param0, int param1, char * param2);
void gen_midstate_char(char * dst, uint64_t src);
int32_t generate_chain_inactive_command(chain_inactive_t * command);
int32_t generate_get_status_command(uint8_t mode, uint32_t which_asic_address, uint32_t register_address, get_status_t * command);
int32_t generate_set_address_command(uint32_t which_asic_address, set_address_t * command);
int32_t generate_set_config_command(uint8_t mode, uint32_t which_asic_address, uint32_t register_address, uint32_t register_data, set_config_t * command);
uint32_t get_QN_write_data_command(void);
long get_abs_seconds(char * date);
void get_all_fan_speed(void);
int32_t get_asic_clock_delay_control(uint8_t which_chain, uint32_t which_asic_address);
int32_t get_asic_core_register(uint8_t which_chain, uint32_t which_asic_address, uint8_t core_reg);
uint16_t get_asic_flag(char * asic_type);
int32_t get_asic_hash_clock_counter(uint8_t which_chain, uint32_t which_asic_address);
int32_t get_asic_hwsweep_nonce_returned_counter(uint8_t which_chain, uint32_t which_asic_address);
uint8_t get_asic_index_by_nonce(uint32_t nonce, uint32_t addr_interval);
uint8_t get_asic_index_by_nonce_v2(uint32_t nonce, uint32_t asic_num);
uint16_t get_asic_name(char * asic_type);
int32_t get_asic_nonce_bin_overflow_control(uint8_t which_chain, uint32_t which_asic_address);
void get_asic_nonce_status(void);
int32_t get_asic_one_core_register(uint8_t which_chain, uint32_t which_asic_address, uint8_t core_reg);
int32_t get_asic_process_monitor(uint8_t which_chain, uint32_t which_asic_address, uint8_t pm_sel);
float get_avg_matrix(float * matrix, int len);
uint32_t get_block_header_version(void);
int32_t get_bt8d_chain(uint32_t chain);
int get_bt8d_fpga_divider(int baud);
int32_t get_chain_asic_num(uint8_t which_chain);
int32_t get_chain_asic_synopsys_temp(uint8_t which_chain, uint32_t which_asic_address);
int32_t get_chain_core_register(uint8_t which_chain, uint8_t core_reg);
int32_t get_chain_error_flag(uint8_t which_chain);
int32_t get_chain_freq_minmax(_Bool is_max, edf_ctx_p ctx, int num);
int32_t get_chain_hash_clock_counter(uint8_t which_chain);
int32_t get_chain_hwsweep_group_pattern_status(uint8_t which_chain);
int32_t get_chain_hwsweep_nonce_returned_counter(uint8_t which_chain);
int32_t get_chain_hwsweep_single_pattern_status(uint8_t which_chain);
int32_t get_chain_one_core_register(uint8_t which_chain, uint8_t core_reg);
int32_t get_chain_process_monitor(uint8_t which_chain, uint8_t pm_sel);
uint8_t get_chip_bin(hashboard_qr_code * qr_code);
_Bool get_chip_ft_program_version(hashboard_qr_code * qr_code, uint8_t * ft_version);
_Bool get_chip_ft_program_version_ex(hashboard_qr_code * qr_code, uint8_t * ft_version);
void get_chip_technology(hashboard_qr_code * qr_code);
void get_conf(void * conf, sweep_ctx * sweep_info, int test_levels, int pt2_level, int chain, config_ctx * ctx, _Bool re_write_sweep_cfg);
int32_t get_core_hash_clock_counter(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address);
int32_t get_core_process_monitor(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint8_t pm_sel);
uint8_t get_coreid_by_nonce(uint32_t nonce);
uint32_t get_crc_count(void);
int32_t get_ctrlboard_temp_max(void);
int32_t get_ctrlboard_temp_min(void);
int32_t get_curr_pwm(void);
int get_env_temp(void);
int32_t get_eth_mac(int8_t * device, uint8_t * mac);
size_t get_file_size(char * filename);
void get_format_time(char * time_str);
uint32_t * get_fpga_map_mem_addr(void);
int get_freq_comp(int32_t freq);
float get_freq_matrix_max(float * matrix, int len);
float get_freq_matrix_min(float * matrix, int len);
void get_hardware_infor(hashboard_qr_code * qr_code);
bitmain_hardware_type_e get_hardware_type(void);
int32_t get_ip(char * ip);
uint32_t get_job_id(void);
uint32_t get_job_length(void);
void get_last_pattern_temp(uint8_t * temp, int cnt);
int32_t get_local_ip(char * ifname, char * ip);
int32_t get_mac(bitmain_mac_t * mac);
void get_match_level(test_ctx * level_info);
float get_matrix_freq_avg(float * matrix);
int8_t get_max_value(int8_t * data, uint8_t data_length);
int8_t get_min_value(int8_t * data, uint8_t data_length);
uint32_t get_min_value_uint32(uint32_t * data, uint8_t data_length);
clib_object * get_next_c_map(clib_iterator * pIterator);
uint32_t get_nonce_number_in_fifo(void);
int32_t get_pic_version(uint8_t which_chain);
int32_t get_pllparam_divider(float freq, pllparameter_t * pll_param, pll_userdivider_t * userdivider, float * pll_freq);
int32_t get_power_from_server(char * server_ip, int32_t port, uint32_t * power_result);
int get_pt1_test_permission(char * sn, char * response_msg);
int get_pt2_test_permission(char * sn, char * response_msg);
clib_error get_raw_clib_object(clib_object * inObject, void * * elem);
int32_t get_register_cache_value(cache_level_e level, uint8_t which_chain, uint32_t which_asic_address, uint32_t register_address, uint32_t * cache_value);
uint32_t get_register_info(uint32_t which_asic, uint32_t which_function, _Bool mode, char * asic_type);
uint32_t get_register_value(uint32_t which_asic, uint32_t which_function, _Bool mode, char * asic_type);
uint32_t get_register_value_with_ext_data(uint32_t which_asic, uint32_t which_function, _Bool mode, char * asic_type, void * ext_data);
uint32_t get_result(void);
uint32_t get_result_hw_sweep(void);
uint32_t get_result_super_software_pattern(void);
void get_return_nonce(uint32_t * buf);
void get_return_nonce_128bit(uint32_t * buf);
int32_t get_send_address_info(uint32_t which_uart, uint32_t * bit_shift_num, uint32_t * chain_send_fifo_status_addr, uint32_t * chain_send_ready_addr, uint32_t * chain_send_buffer_addr);
uint8_t get_sensor_type(hashboard_qr_code * qr_code);
SSL_SESSION * get_session_cb(ssl_st * ssl, uchar * data, int len, int * copy);
void get_succ_asic_nonce_num(uint16_t * data, int len);
void get_sweep_bad_asics(sweep_bad_asic_info_t * bad_asics);
void get_sweep_err_state(sweep_err_state * state);
float get_sweep_noncerate(void);
void get_system_capability(bitmain_sys_capability_t * info);
uint32_t get_target_bits(void);
void get_test_info(char * log_name, test_info_t * test_info);
char * get_test_type(char * log_name);
uint32_t get_ticket_mask(void);
int get_time_from_pool(char * server_name, int server_port);
int get_time_from_web(char * url);
uint32_t get_time_stamp(void);
int32_t get_uuid(bitmain_uuid_t * uuid);
void * get_value_c_map(void * pObject);
float get_var_matrix(float * matrix, int len);
void get_vco_pll_divider_conf(pllparameter_t target_pll_parameter, pll_divider_conf_t * pll_divider_conf, uint32_t * pll_divider_conf_count);
int32_t get_vol_comp(int32_t env_temp);
_Bool get_works_ex2(void);
int gpio_compare_e(void * left, void * right);
int32_t gpio_ctrl_ui(ui_type_e type, ui_status_e status);
int32_t gpio_direction(uint32_t port, bitmain_gpio_direction_e direction);
int32_t gpio_export(uint32_t port);
int32_t gpio_init(void);
void gpio_key_callback(uint32_t port, uint8_t val);
int32_t gpio_read(uint32_t port, uint8_t * val);
int32_t gpio_reg_callback(uint32_t port, bitmain_gpio_callback function);
void * gpio_thread_function(void * args);
int32_t gpio_unexport(uint32_t port);
void gpio_uninit(void);
int32_t gpio_unreg_callback(uint32_t port, bitmain_gpio_callback function);
int32_t gpio_write(uint32_t port, uint8_t val);
int32_t green_led_flicker(void);
int32_t green_led_off(void);
int32_t green_led_on(void);
int32_t hal_chain_max_num(void);
int32_t hal_chain_plug_addr(uint32_t chain_id);
int32_t hal_chain_reset_addr(uint32_t chain_id);
int32_t hal_chain_uart_addr(uint32_t chain_id);
int32_t hal_fan_addr(bitmain_fan_id_e id);
int32_t hal_fan_max_speed(bitmain_fan_id_e id);
int32_t hal_fan_number(void);
int32_t hal_key_ipreport_addr(void);
int32_t hal_key_reset_addr(void);
int32_t hal_led_green_addr(void);
int32_t hal_led_red_addr(void);
void handle_pipe(int sig);
ulong hash_func(char * param0);
uint32_t hashlittle(void * key, size_t length, uint32_t initval);
void hashtable_clear(hashtable_t * hashtable);
void hashtable_close(hashtable_t * hashtable);
int hashtable_del(hashtable_t * hashtable, char * key);
void hashtable_do_clear(hashtable_t * hashtable);
pair_t * hashtable_find_pair(hashtable_t * hashtable, bucket_t * bucket, char * key, size_t hash);
void * hashtable_get(hashtable_t * hashtable, char * key);
int hashtable_init(hashtable_t * hashtable);
void * hashtable_iter(hashtable_t * hashtable);
void * hashtable_iter_at(hashtable_t * hashtable, char * key);
void * hashtable_iter_key(void * iter);
void * hashtable_iter_next(hashtable_t * hashtable, void * iter);
void hashtable_iter_set(void * iter, json_t * value);
void * hashtable_iter_value(void * iter);
int hashtable_set(hashtable_t * hashtable, char * key, json_t * value);
void hexdump(char * name, void * p, int size);
int high_speed_uart_get_config(uint32_t chain_id, bitmain_uart_conf_type_t type, void * val, int32_t * size);
int high_speed_uart_set_config(uint32_t chain_id, bitmain_uart_conf_type_t type, void * val, int32_t size);
int hmac_get_url_message(char * port_name, char * user_id, char * key, char * payload, char * response_msg);
void hmac_sha256(uint8_t * out, uint8_t * data, size_t data_len, uint8_t * key, size_t key_len);
char * http_get(char * url, _Bool ver1_0, _Bool raw);
char * http_parse_result(char * lpbuf, _Bool ver1_0, _Bool raw);
int http_parse_url(char * url, char * host, char * file, int * port);
char * http_post(char * url, char * post_str);
void http_tcpclient_close(int socket);
int http_tcpclient_create(char * host, int port, _Bool ver_1_0);
int http_tcpclient_recv(int socket, char * lpbuff);
int http_tcpclient_send(int socket, char * buff, int size);
int i2c_compare_e(void * left, void * right);
int32_t i2c_init(int8_t * path2dev);
int32_t i2c_ioctl(int32_t ctx, uint16_t cmd, uint32_t arg);
int32_t i2c_read(int32_t ctx, void * data, uint32_t size);
int32_t i2c_read_reg(int32_t ctx, uint8_t * reg, uint32_t bytes, void * data, uint32_t size, _Bool reg_addr_valid);
int32_t i2c_select(int32_t ctx, uint32_t master_index);
void i2c_uninit(int32_t ctx);
int32_t i2c_write(int32_t ctx, void * data, uint32_t size);
int32_t i2c_write_reg(int32_t ctx, uint8_t * reg, uint32_t bytes, void * data, uint32_t size, _Bool reg_addr_valid);
int i2d_of_void(void * param0, uchar * * param1);
int32_t iic_init(iic_init_param_t * param);
int32_t iic_read(int32_t ctx, void * data, uint32_t size);
int32_t iic_read_reg(int32_t ctx, uint8_t * reg, uint32_t bytes, void * data, uint32_t size, _Bool reg_addr_valid);
void iic_uninit(int32_t ctx);
int32_t iic_write(int32_t ctx, void * data, uint32_t size);
int32_t iic_write_reg(int32_t ctx, uint8_t * reg, uint32_t bytes, void * data, uint32_t size, _Bool reg_addr_valid);
void inc_freq_online_pll(float * matrix, int len, float freq, uint8_t * state);
void inc_freq_with_adjust_voltage(uint8_t chain, uint8_t pll_id, uint32_t freq_start, uint32_t freq_end, float freq_step);
void inc_freq_with_fix(uint8_t chain, uint8_t pll_id, uint32_t freq_start, uint32_t freq_end, float freq_step, uint32_t env_temp);
void inc_freq_with_fixed_step_parallel(uint8_t chain, uint8_t pll_id, uint32_t freq_start, uint32_t freq_end, float freq_step);
void inc_freq_with_fixed_vco(uint8_t chain, uint8_t pll_id, float target_freq);
void inc_freq_with_matrix(float * matrix, int len);
void inc_freq_with_target(float * matrix, int len, float freq, int pll, uint8_t * state);
void inc_target_freq(uint32_t freq);
void inc_target_freq_from_to(uint32_t from_freq, uint32_t to_freq);
int init(EVP_PKEY_CTX * ctx);
_Bool init_MES_system_config_information(void);
_Bool init_dac(char * board_name, uint8_t which_chain);
_Bool init_dac53401_NBT2006_36(uint8_t which_chain);
_Bool init_fpga(void);
void init_history_result(uint32_t test_loop_counter);
_Bool init_pic(void);
void init_pid_parms(void);
void init_spuer_pattern(void);
clib_error insert_c_map(clib_map * pMap, void * key, size_t key_size, void * value, size_t value_size);
clib_error insert_c_rb(clib_rb * pTree, void * k, size_t key_size, void * v, size_t value_size);
void insert_to_bucket(hashtable_t * hashtable, bucket_t * bucket, list_t * list);
_Bool interrupted(void);
uchar is_bypass_mode_enable(void);
int32_t is_gpio_exist(uint32_t port);
_Bool is_power_protocal_v2(void);
_Bool is_power_status_with_64bits(void);
uchar is_sync_header_enable(void);
uchar is_work_fifo_ready(uint32_t chain);
json_t * json_array(void);
int json_array_append(json_t * array, json_t * value);
int json_array_append_new(json_t * json, json_t * value);
int json_array_clear(json_t * json);
int json_array_extend(json_t * json, json_t * other_json);
json_t * json_array_get(json_t * json, size_t index);
json_t * * json_array_grow(json_array_t * array, size_t amount, int copy);
int json_array_insert_new(json_t * json, size_t index, json_t * value);
int json_array_remove(json_t * json, size_t index);
int json_array_set_new(json_t * json, size_t index, json_t * value);
size_t json_array_size(json_t * json);
json_t * json_copy(json_t * json);
void json_decref(json_t * json);
json_t * json_deep_copy(json_t * json);
void json_delete(json_t * json);
int json_dump_callback(json_t * json, json_dump_callback_t callback, void * data, size_t flags);
int json_dump_file(json_t * json, char * path, size_t flags);
size_t json_dumpb(json_t * json, char * buffer, size_t size, size_t flags);
int json_dumpf(json_t * json, FILE * output, size_t flags);
int json_dumpfd(json_t * json, int output, size_t flags);
char * json_dumps(json_t * json, size_t flags);
int json_equal(json_t * json1, json_t * json2);
json_t * json_false(void);
void json_get_alloc_funcs(json_malloc_t * malloc_fn, json_free_t * free_fn);
json_t * json_incref(json_t * json);
json_t * json_integer(json_int_t value);
int json_integer_set(json_t * json, json_int_t value);
json_int_t json_integer_value(json_t * json);
json_t * json_load_callback(json_load_callback_t callback, void * arg, size_t flags, json_error_t * error);
json_t * json_load_file(char * path, size_t flags, json_error_t * error);
json_t * json_loadb(char * buffer, size_t buflen, size_t flags, json_error_t * error);
json_t * json_loadf(FILE * input, size_t flags, json_error_t * error);
json_t * json_loadfd(int input, size_t flags, json_error_t * error);
json_t * json_loads(char * string, size_t flags, json_error_t * error);
json_t * json_null(void);
double json_number_value(json_t * json);
json_t * json_object(void);
int json_object_clear(json_t * json);
int json_object_del(json_t * json, char * key);
json_t * json_object_get(json_t * json, char * key);
void * json_object_iter(json_t * json);
void * json_object_iter_at(json_t * json, char * key);
char * json_object_iter_key(void * iter);
void * json_object_iter_next(json_t * json, void * iter);
int json_object_iter_set_new(json_t * json, void * iter, json_t * value);
json_t * json_object_iter_value(void * iter);
void * json_object_key_to_iter(char * key);
void json_object_seed(size_t seed);
int json_object_set(json_t * object, char * key, json_t * value);
int json_object_set_new(json_t * json, char * key, json_t * value);
int json_object_set_new_nocheck(json_t * json, char * key, json_t * value);
size_t json_object_size(json_t * json);
int json_object_update(json_t * object, json_t * other);
int json_object_update_existing(json_t * object, json_t * other);
int json_object_update_missing(json_t * object, json_t * other);
int json_object_update_recursive(json_t * object, json_t * other);
json_t * json_real(double value);
int json_real_set(json_t * json, double value);
double json_real_value(json_t * json);
void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
json_t * json_sprintf(char * fmt);
json_t * json_string(char * value);
size_t json_string_length(json_t * json);
json_t * json_string_nocheck(char * value);
int json_string_set(json_t * json, char * value);
int json_string_set_nocheck(json_t * json, char * value);
int json_string_setn(json_t * json, char * value, size_t len);
int json_string_setn_nocheck(json_t * json, char * value, size_t len);
char * json_string_value(json_t * json);
json_t * json_stringn(char * value, size_t len);
json_t * json_stringn_nocheck(char * value, size_t len);
json_t * json_true(void);
json_t * json_vsprintf(char * fmt, va_list ap);
int jsonp_dtostr(char * buffer, size_t size, double value, int precision);
void jsonp_error_init(json_error_t * error, char * source);
void jsonp_error_set(json_error_t * error, int line, int column, size_t position, json_error_code code, char * msg);
void jsonp_error_set_source(json_error_t * error, char * source);
void jsonp_error_vset(json_error_t * error, int line, int column, size_t position, json_error_code code, char * msg, va_list ap);
void jsonp_free(void * ptr);
int jsonp_loop_check(hashtable_t * parents, json_t * json, char * key, size_t key_size);
void * jsonp_malloc(size_t size);
char * jsonp_strdup(char * str);
json_t * jsonp_stringn_nocheck_own(char * value, size_t len);
char * jsonp_strndup(char * str, size_t len);
int jsonp_strtod(strbuffer_t * strbuffer, double * out);
int32_t jump_from_loader_to_app(uint8_t which_chain);
int keygen(EVP_PKEY_CTX * ctx, EVP_PKEY * pkey);
int keygen_init(EVP_PKEY_CTX * ctx);
int32_t lcd_clear(int32_t ctx);
void lcd_clear_result(void);
void lcd_common_show(char * line1, char * line2, char * line3);
int32_t lcd_flush(int32_t ctx);
int32_t lcd_init(int8_t * path2dev);
int32_t lcd_show(int32_t line, char * data);
int32_t lcd_show_result(int32_t line, int8_t * data, uint32_t size);
int32_t lcd_uninit(int32_t ctx);
int32_t lcd_write(int32_t ctx, int8_t line, int8_t * data, uint32_t size);
int level_down_freq(int infreq, int * outfreq);
void lex_close(lex_t * lex);
int lex_get_save(lex_t * lex, json_error_t * error);
int lex_init(lex_t * lex, get_func get, size_t flags, void * data);
int lex_scan(lex_t * lex, json_error_t * error);
void lex_unget_unsave(lex_t * lex, int c);
int list_cb(char * elem, int len, void * usr);
char * load_board_info_from_format_v3(char * data, uint32_t len);
void log_to_file(char * str, char * str_time);
void log_to_filex(char * str, char * str_time);
void m(void * param0, int param1, char * param2, int param3, int param4);
int32_t main(int argc, char * * argv);
_Bool malloc_for_local_config_information(void);
int match_level(eeprom_data_format_t * ctx, pattern_runtime_ctx * runtime, float * matrix);
clib_rb_node * maximum_c_rb(clib_rb * pTree, clib_rb_node * x);
void memtest(void);
clib_rb_node * minimum_c_rb(clib_rb * pTree, clib_rb_node * x);
clib_map * new_c_map(clib_compare fn_c_k, clib_destroy fn_k_d, clib_destroy fn_v_d);
clib_rb * new_c_rb(clib_compare fn_c, clib_destroy fn_ed, clib_destroy fn_vd);
clib_object * new_clib_object(void * inObject, size_t obj_size);
clib_iterator * new_iterator_c_map(clib_map * pMap);
int new_session_cb(ssl_st * ssl, SSL_SESSION * sess);
void noblock_socket(int fd);
void online_mode_retry_test(int chain);
int32_t open_pic(uint8_t which_chain);
int opener(UI * ui);
int param_cmp(EVP_PKEY * a, EVP_PKEY * b);
int param_copy(EVP_PKEY * to, EVP_PKEY * from);
int param_decode(EVP_PKEY * pkey, uchar * * pder, int derlen);
int param_encode(EVP_PKEY * pkey, uchar * * pder);
int param_missing(EVP_PKEY * pk);
int param_print(BIO * out, EVP_PKEY * pkey, int indent, ASN1_PCTX * pctx);
int paramgen(EVP_PKEY_CTX * ctx, EVP_PKEY * pkey);
int paramgen_init(EVP_PKEY_CTX * ctx);
int paritition(char[128] * logs, int left, int right);
_Bool parse_MES_system_config_information(uint32_t which_information);
_Bool parse_all_MES_system_config_information(void);
int parse_bin_file_16midstate_sf(FILE * * fp, int asic, int core, int count);
int32_t parse_bin_file_to_pattern_ex(char * asic_pattern_file, uint32_t small_core_num, uint32_t pattern_num, work_new * work);
json_t * parse_json(lex_t * lex, size_t flags, json_error_t * error);
_Bool parse_local_config_file(char * config_file_path);
int32_t parse_scan_data(char * scan_data, hashboard_sn * sn, _Bool * sn_ok, hashboard_qr_code * qrcode, _Bool * qrcode_ok);
json_t * parse_value(lex_t * lex, size_t flags, json_error_t * error);
int pattern_test(float * matrix);
void pause_recv_nonce(void);
int pem_password_cb(char * buf, int size, int rwflag, void * userdata);
_Bool pf_check_specific_chain(int chain);
int pf_get_max_value(int8_t * data, int data_length);
int pf_get_min_value(int8_t * data, int data_length);
_Bool pf_init(uint32_t chain);
void pf_power_down(uint32_t chain);
_Bool pf_power_on(uint32_t voltage);
int32_t pic_get_voltage(uint8_t which_chain, int32_t * an, int32_t size);
void * pic_heart_beat_func(void * arg);
_Bool pic_power_on_hashboard(void);
int32_t pic_read_iic(uint8_t which_chain, uint8_t slave, uint8_t reg, uint8_t * data, int32_t max_size);
int32_t pic_write_iic(uint8_t which_chain, uint8_t slave, uint8_t reg, uint8_t * data, int32_t size);
float pid_calc(PID * pid, int pwm_percent_pid_current);
int pkey_bits(EVP_PKEY * pk);
int pkey_ctrl(EVP_PKEY * pkey, int op, long arg1, void * arg2);
void pkey_free(EVP_PKEY * pkey);
int pkey_size(EVP_PKEY * pk);
int32_t platform_init(void);
void platform_uninit(void);
int32_t pll_divider_cmp_func(void * pll_divider1, void * pll_divider2);
char * post_request(char * url, char * post_str);
void power_down(uint32_t chain);
void power_down_and_fan(uint32_t chain);
int32_t power_need_open(void);
_Bool prepare_MES_system_handshake_information(uint32_t which_information);
_Bool prepare_MES_system_submit_information(uint32_t test_loop_index, _Bool sweep_mode);
_Bool prepare_eeprom_data_pt1(_Bool pass, uint8_t * eeprom_data, size_t * len_p, size_t * offset_p);
_Bool prepare_eeprom_data_pt2(uint32_t test_loop_index, _Bool pass, uint8_t * eeprom_data, size_t * len_p, size_t * offset_p);
_Bool prepare_local_config_information(void);
_Bool prepare_pattern(void);
_Bool prepare_platform_environment(void);
_Bool prepare_test_process(void);
_Bool prepare_test_standard(void);
void print_MES_system_information(void);
void print_eeprom_data(void);
void print_eeprom_data_in_hex(uint8_t * buf, uint32_t buf_length);
void print_fan_speed(void);
void print_find_asic_result(void);
void print_history_result(uint32_t test_loop_counter);
void print_local_config_after_parse_MES_system_information(void);
void print_time_stamp(char * datetime, int len);
void print_works(void);
int priv_decode(EVP_PKEY * pk, PKCS8_PRIV_KEY_INFO * p8inf);
int priv_encode(PKCS8_PRIV_KEY_INFO * p8, EVP_PKEY * pk);
int priv_print(BIO * out, EVP_PKEY * pkey, int indent, ASN1_PCTX * pctx);
char * prompt_constructor(UI * ui, char * object_desc, char * object_name);
uint psk_client_callback(SSL * ssl, char * hint, char * identity, uint max_identity_len, uchar * psk, uint max_psk_len);
uint psk_server_callback(SSL * ssl, char * identity, uchar * psk, uint max_psk_len);
void * pt1_board_protect_func(void * args);
int pt_before_send_nonce(float * matrix);
void pt_clear_stats(void);
void pt_exit(void);
void * pt_get_stats(void);
int32_t pt_init(char * pattern_file_path, void * conf);
int32_t pt_is_recv_nonce_enough(uint32_t chain);
int32_t pt_is_unbalance_happen(uint32_t chain);
void * pt_power_monitor_thread(void);
void pt_process_nonce(return_nonce_128bit_t * return_nonce);
void pt_process_reg(return_nonce_128bit_t * return_nonce);
void pt_process_reg_normal(void * nonce);
void * pt_read_temp(void * arg);
void pt_reset(void);
int pt_send_nonce(float * last_matrix, float freq, uint8_t * state);
int32_t pt_send_work(uint32_t chain, void * args);
int pub_cmp(EVP_PKEY * a, EVP_PKEY * b);
int pub_decode(EVP_PKEY * pk, X509_PUBKEY * pub);
int pub_encode(X509_PUBKEY * pub, EVP_PKEY * pk);
int pub_print(BIO * out, EVP_PKEY * pkey, int indent, ASN1_PCTX * pctx);
int32_t pwm_get(int32_t ctx, uint32_t * duty);
int32_t pwm_init(bitmain_pwm_type_e type, uint32_t freq);
int32_t pwm_set(int32_t ctx, uint32_t duty);
void pwm_uninit(int32_t ctx);
int qual(OPENSSL_STRING * param0);
void r(void * param0, void * param1, int param2, char * param3, int param4, int param5);
_Bool read_board_info_from_eeprom(void);
_Bool read_chain_domain_voltage(_Bool logout);
_Bool read_compress_log_file(log_info_t * p_info);
_Bool read_dac(uint8_t which_chain, uint8_t which_dac, uint8_t which_reg, uint8_t * data, int32_t data_length);
int read_data(FILE * file, uint32_t offset, uint32_t len, uint8_t * data);
int read_eeprom(int chain, eeprom_data_format_t * * ctx);
_Bool read_encode_log_file(log_info_t * p_info);
void read_fpga_id(char * pFpgaID, int len);
int32_t read_ipreport_key_val(void);
_Bool read_log_file(log_info_t * p_info);
size_t read_long_length_no_check(BYTE * * pp);
int32_t read_reset_key_val(void);
_Bool read_temp_from_asic_once(_Bool logout);
void * read_temperature_from_CtrlBoard(void * arg);
void read_temperature_from_CtrlBoard_N_times(uint8_t N);
void * read_temperature_from_PIC(void * arg);
void read_temperature_from_PIC_N_times(uint8_t N);
void * read_temperature_from_asic(void * arg);
uint32_t read_uart_data_in_fpga(uint32_t which_uart, uint8_t * buf, uint32_t length);
int reader(UI * ui, UI_STRING * uis);
void * receive_function(void * arg);
char * receive_message_from_bitmain_MES_system(uint32_t * received_data_len);
void * recv_routine(void * arg);
int32_t recv_scan_data(char * recv_buffer, int32_t length);
int32_t red_led_flicker(void);
int32_t red_led_off(void);
int32_t red_led_on(void);
int refresh_log_list(char[128] * logs, char * prefix);
int32_t reg_key_callback(bitmain_key_callback function);
clib_error remove_c_map(clib_map * pMap, void * key);
clib_rb_node * remove_c_rb(clib_rb * pTree, void * key);
void remove_port_form_gpio_map(uint32_t port, clib_map * map);
void remove_session_cb(ssl_ctx_st * ctx, SSL_SESSION * sess);
void replace_raw_clib_object(clib_object * current_object, void * elem, size_t elem_size);
void replace_value_c_map(clib_iterator * pIterator, void * elem, size_t elem_size);
int32_t reset_asic_clock_order_ctrl0(uint8_t which_chain, uint32_t which_asic_address);
void reset_bad_asic_freq(float * matrix, int len, uint8_t * state);
int32_t reset_cache_value(uint8_t which_chain);
int32_t reset_chain_clock_order_ctrl0(uint8_t which_chain);
int32_t reset_chain_hwsweep(uint8_t which_chain);
void reset_crc_count(void);
void reset_fpga(uint32_t time);
_Bool reset_freq_range_from_eeprom(eeprom_data_format_t * efd, sweep_ctx * sweep, int asics);
void reset_global_variables(void);
int reset_hash_board(uint32_t chain);
int32_t reset_pic(uint8_t which_chain);
int32_t reset_register_cache_value_to_default(uint8_t which_chain);
void reset_registoer_buf(void);
void reset_runtime_info(int sweep_mode);
void rev(uchar * s, size_t l);
int32_t routine_init(void);
int run_sweep_test_after_PT2_test(void);
int run_sweep_test_after_by_PT2_info(int test_loop_counter);
int s2hex(uchar * dst, char * src, int inlen);
_Bool save_MES_system_config_information(uint32_t which_information);
_Bool save_MES_system_submit_result(void);
void save_exit(void);
_Bool save_mes_submit_result(_Bool pt1, char * msg);
void save_nonce(work_format * work, uint32_t which_midstate, uint32_t nonce);
_Bool save_software_commit_id(void);
_Bool scan_code_from_hashboard(void);
int32_t scan_hashboard_info(hashboard_sn * sn, hashboard_qr_code * qrcode, _Bool * sn_ok, _Bool * qrcode_ok, int32_t timeout);
void send_BC_command(uint32_t * value, int chain);
int32_t send_chain_inactive_command(uint8_t which_chain);
int32_t send_command(uint8_t which_chain, uint8_t * command, int32_t length);
int32_t send_get_status_command(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint32_t reg_address);
_Bool send_message_to_bitmain_MES_system(char * data, int32_t data_len);
void send_nonce(int fd, char * buf, int len);
int32_t send_pic_heart_beat(uint8_t which_chain);
int send_pt1_test_result(char * sn, _Bool ok, int error_no, int error_info, char * send_msg, char * response_msg);
int send_pt2_test_result(char * sn, _Bool ok, int error_no, int error_info, char * send_msg, char * response_msg);
int32_t send_set_address_command(uint8_t which_chain, uint32_t which_asic_address);
int32_t send_set_config_command(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint32_t reg_address, uint32_t reg_data);
int serch_ntc_table(int ntc);
void set_BC_baud(int baud);
void set_BC_nullen(int chain, _Bool enable_null_work);
void set_BC_nullen_all_chain(_Bool enable_null_work);
void set_BC_write_command(uint32_t value);
void set_TW_write_command(uint32_t * value, uint32_t len);
int32_t set_asic_analog_mux_control(uint8_t which_chain, uint32_t which_asic_address, uint8_t mux_sel);
int32_t set_asic_auto_read_temp(uint8_t which_chain, uint32_t which_asic_address, uint8_t sensor_addr, uint8_t data);
int32_t set_asic_chip_nonce_offset(uint8_t which_chain, uint32_t which_asic_address, _Bool is_valid, uint16_t chip_nonce_offset);
int32_t set_asic_clock_delay_control(uint8_t which_chain, uint32_t which_asic_address, uint8_t pwth_sel, uint8_t ccdly_sel, uint8_t swpf_mode);
int32_t set_asic_clock_order_ctrl0(uint8_t which_chain, uint32_t which_asic_address, uint32_t clock_order_ctrl0);
int32_t set_asic_clock_select_control(uint8_t which_chain, uint32_t which_asic_address, uint8_t pulse_mode, uint8_t clk_sel);
int32_t set_asic_core_auto_clk_en(uint8_t which_chain, uint32_t which_asic_address, uint8_t mode_mask, _Bool auto_clk_en);
int32_t set_asic_core_enable(uint8_t which_chain, uint32_t which_asic_address);
int32_t set_asic_core_enable_by_coreId(uint8_t which_chain, uint32_t which_asic_address, uint32_t which_core);
int32_t set_asic_core_nonce_overflow_control(uint8_t which_chain, uint32_t which_asic_address, _Bool is_enable_nonce_bin_overflow);
int32_t set_asic_core_nonce_overflow_enable(uint8_t which_chain, uint32_t which_asic_address, _Bool is_enable_nonce_bin_overflow);
int32_t set_asic_core_srst(uint8_t which_chain, uint32_t which_asic_address, _Bool is_active);
int32_t set_asic_core_srst_fast(uint8_t which_chain, uint32_t which_asic_address);
int32_t set_asic_force_core_en(uint8_t which_chain, uint32_t which_asic_address, _Bool is_enable);
int32_t set_asic_frequency(uint8_t which_chain, uint32_t which_asic_address, uint8_t which_pll, uint32_t frequency);
int32_t set_asic_hash_counting_number(uint8_t which_chain, uint32_t which_asic_address, uint32_t hash_counting_num);
int32_t set_asic_hwsweep_clk_mode_cfg0(uint8_t which_chain, uint32_t which_asic_address, uint32_t clk_mode_cfg0);
int32_t set_asic_hwsweep_clk_mode_cfg1(uint8_t which_chain, uint32_t which_asic_address, uint32_t clk_mode_cfg1);
int32_t set_asic_hwsweep_clk_mode_ctrl(uint8_t which_chain, uint32_t which_asic_address, uint8_t core_num_dec_lock_en, uint8_t clk_mode_margin, uint8_t core_clk_mode_sel);
int32_t set_asic_inv_clko_en(uint8_t which_chain, uint32_t which_asic_address, _Bool is_enable);
int32_t set_asic_iodriver_clko_ds(uint8_t which_chain, uint32_t which_asic_address, uint8_t clko_ds);
int32_t set_asic_ocv_pulse_width(uint8_t which_chain, uint32_t which_asic_address, uint8_t edge_sel);
int32_t set_asic_pce_en(uint8_t which_chain, uint32_t which_asic_address, _Bool is_pce_en);
int32_t set_asic_pllparameter(uint8_t which_chain, uint32_t which_asic_address, uint8_t which_pll, pllparameter_t pllparameter);
int32_t set_asic_pllparameter_postdivider(uint8_t which_chain, uint32_t which_asic_address, uint8_t which_pll, uint8_t postdiv1, uint8_t postdiv2);
int32_t set_asic_pllparameter_userdivider(uint8_t which_chain, uint32_t which_asic_address, uint8_t which_pll, pll_userdivider_t userdivider);
void set_asic_register_stage_1(void);
void set_asic_register_stage_2(void);
void set_asic_register_stage_3(void);
int32_t set_asic_register_to_get_domain_voltage(uint8_t which_chain, uint32_t which_asic_address, uint8_t which_domain);
int32_t set_asic_ri_disa(uint8_t which_chain, uint32_t which_asic_address, uint8_t ri_disa);
int32_t set_asic_rno_en(uint8_t which_chain, uint32_t which_asic_address, _Bool is_rno_en);
int32_t set_asic_rosc_pad_disable(uint8_t which_chain, uint32_t which_asic_address);
int32_t set_asic_temp_offset_by_iic(uint8_t which_chain, uint32_t which_asic_address, uint8_t sensor_addr, uint8_t sensor_register, uint8_t temp_offset);
int32_t set_asic_uart_relay(uint8_t which_chain, uint32_t which_asic_address, uint32_t gap_cnt, _Bool is_ro_relay, _Bool is_co_relay);
int32_t set_auto_clk_en(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint8_t mode_mask, _Bool auto_clk_en);
void set_block_header_version(uint32_t value, uint32_t num, uint32_t mask);
int32_t set_bt8d_all_chain(uint32_t baud);
int32_t set_bt8d_chain(uint32_t chain, uint32_t baud);
int32_t set_chain_adc_control_disable(uint8_t which_chain);
int32_t set_chain_analog_mux_control(uint8_t which_chain, uint8_t mux_sel);
int32_t set_chain_asic_address(uint8_t which_chain, uint32_t addr_interval);
int32_t set_chain_asic_address_ex(uint8_t which_chain, uint32_t addr_interval, uint32_t asic_num);
int32_t set_chain_asic_nonce_space_divide(uint8_t which_chain, uint32_t addr_interval, uint32_t asic_num);
int32_t set_chain_asic_synopsys_temp(uint8_t which_chain, uint32_t which_asic_address, _Bool ts_soft_rstn, _Bool ts_cload, _Bool run_en, _Bool ts_pd);
int32_t set_chain_auto_gen_midstate(uint8_t which_chain, _Bool is_auto_gen, uint8_t midsx_gen, uint16_t version_mask);
int32_t set_chain_baud(uint8_t which_chain, uint32_t baudrate);
int32_t set_chain_chip_nonce_offset(uint8_t which_chain, _Bool is_valid, uint16_t chip_nonce_offset);
int32_t set_chain_clock_delay_control(uint8_t which_chain, uint8_t pwth_sel, uint8_t ccdly_sel, uint8_t swpf_mode);
int32_t set_chain_clock_select_control(uint8_t which_chain, uint8_t pulse_mode, uint8_t clk_sel);
int32_t set_chain_core_auto_clk_en(uint8_t which_chain, uint8_t mode_mask, _Bool auto_clk_en);
int32_t set_chain_core_enable(uint8_t which_chain);
int32_t set_chain_core_enable_by_coreId(uint8_t which_chain, uint32_t which_core);
int32_t set_chain_core_nonce_overflow_control(uint8_t which_chain, _Bool is_enable_nonce_bin_overflow);
int32_t set_chain_core_nonce_overflow_enable(uint8_t which_chain, _Bool is_enable_nonce_bin_overflow);
int32_t set_chain_core_return_nonce(uint8_t which_chain, _Bool enable);
int32_t set_chain_core_srst(uint8_t which_chain, _Bool is_active);
int32_t set_chain_core_srst_fast(uint8_t which_chain);
int32_t set_chain_force_core_en(uint8_t which_chain, _Bool is_enable);
int32_t set_chain_frequency(uint8_t which_chain, uint8_t which_pll, uint32_t frequency);
int32_t set_chain_hash_counting_number(uint8_t which_chain, uint32_t hash_counting_num);
int32_t set_chain_hwsweep_clk_mode_cfg0(uint8_t which_chain, uint32_t clk_mode_cfg0);
int32_t set_chain_hwsweep_clk_mode_cfg1(uint8_t which_chain, uint32_t clk_mode_cfg1);
int32_t set_chain_hwsweep_clk_mode_ctrl(uint8_t which_chain, uint8_t core_num_dec_lock_en, uint8_t clk_mode_margin, uint8_t core_clk_mode_sel);
int32_t set_chain_hwsweep_nonce_return_timeout(uint8_t which_chain, uint32_t timeout);
int32_t set_chain_hwsweep_status_address(uint8_t which_chain, uint8_t sweep_st_addr);
int32_t set_chain_inactive(uint8_t which_chain);
int32_t set_chain_iodriver_clko_ds(uint8_t which_chain, uint8_t clko_ds);
int32_t set_chain_ocv_pulse_width(uint8_t which_chain, uint8_t edge_sel);
int32_t set_chain_pce_en(uint8_t which_chain, _Bool is_pce_en);
int32_t set_chain_pllparameter(uint8_t which_chain, uint8_t which_pll, pllparameter_t pllparameter);
int32_t set_chain_pllparameter_postdivider(uint8_t which_chain, uint8_t which_pll, uint8_t postdiv1, uint8_t postdiv2);
int32_t set_chain_pllparameter_userdivider(uint8_t which_chain, uint8_t which_pll, pll_userdivider_t userdivider);
int32_t set_chain_register_to_get_domain_voltage(uint8_t which_chain, uint8_t which_domain);
int32_t set_chain_ret_work_err(uint8_t which_chain, _Bool is_enable);
int32_t set_chain_ri_disa(uint8_t which_chain, uint8_t ri_disa);
int32_t set_chain_rno_en(uint8_t which_chain, _Bool is_rno_en);
int32_t set_chain_rosc_pad_disable(uint8_t which_chain);
int32_t set_chain_ticketmask(uint8_t which_chain, uint32_t ticketmask);
int32_t set_chain_top_verify(uint8_t which_chain, _Bool is_enable);
int32_t set_clock_delay_control(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint8_t pwth_sel, uint8_t ccdly_sel, uint8_t swpf_mode);
int32_t set_clock_select_control(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint8_t pulse_mode, uint8_t clk_sel);
int32_t set_clock_select_control_by_coreId(uint8_t which_chain, uint32_t which_asic_address, uint32_t which_core, uint8_t clk_sel);
int32_t set_coinbase_length(uint16_t len);
int32_t set_core_enable(uint8_t which_chain, uint8_t chip_mode, uint8_t core_mode, uint32_t which_asic_address, uint32_t which_core);
int32_t set_core_rec_nonce(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, _Bool enable);
int32_t set_core_srst(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, _Bool is_active);
int32_t set_core_srst_fast(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address);
_Bool set_dac53401_voltage(uint8_t which_chain, uint32_t voltage_N);
_Bool set_dac_voltage(char * board_name, uint8_t which_chain, double voltage);
_Bool set_dac_voltage_step_by_step(char * board_name, uint8_t which_chain, uint32_t pre_voltage, uint32_t target_voltage, uint8_t step_num);
int32_t set_dhash_midstate(uint32_t num);
int32_t set_dhash_new_block(void);
int32_t set_dhash_normal_block(void);
void set_env_temp(int env_temp);
void set_fan_pwm(uint8_t pwm_percent);
void set_freq(uint32_t chain, uint8_t mode, uint8_t chip_addr, uint8_t pll_id, pll_conf pll_config);
void set_freq_mix(uint32_t chain, uint8_t mode, uint8_t chip_addr, uint8_t pll_id, _pll_conf pll_config);
int32_t set_frequency(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint8_t which_pll, uint32_t frequency);
int32_t set_hardware_type(bitmain_hardware_type_e type);
void set_matrix(float nextfreq, float * * matrix, uint8_t * * state);
void set_matrix_state(uint8_t * * state, float * last_matrix, float * * matrix);
void set_merkle_bin_number(uint32_t value);
int32_t set_nonce2_length(uint16_t len);
int32_t set_nonce2_offset(uint16_t len);
int32_t set_nonce_bin_overflow(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, _Bool is_enable_nonce_bin_overflow);
int32_t set_nonce_bin_overflow_control(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, _Bool is_enable_nonce_bin_overflow);
int32_t set_ocv_pulse_width(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint8_t edge_sel);
_Bool set_pattern_test_voltage_by_step(uint32_t pre_voltage, uint32_t target_voltage, uint8_t step_num);
int32_t set_pllparameter(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint8_t which_pll, pllparameter_t pll_parameter);
void set_pre_header_hash(uint32_t * value);
void set_pwm_by_pid(int temp);
void set_pwm_by_temp(int temp);
void set_pwm_in_high_temp(int temp);
void set_pwth(void);
int32_t set_register_cache_value(cache_level_e level, uint8_t which_chain, uint32_t which_asic_address, uint32_t register_address, uint32_t cache_value);
void set_register_stage_1(void);
void set_register_stage_2(void);
void set_register_stage_3(float * matrix);
int32_t set_register_to_get_domain_voltage(uint8_t which_chain, uint8_t mode, uint32_t which_asic_address, uint8_t which_domain);
_Bool set_socket_feature(int32_t socket_fd);
_Bool set_socket_opt(int32_t socket_fd);
void set_succ_asic_nonce_state(uint8_t * state);
void set_sweep_cxt(sweep_ctx * ctx, int reuse_mode);
void set_sweep_err_state(int val, _Bool consumed);
_Bool set_time_based_notify_ntime(char * ntime);
void set_uart_relay(uint8_t address_interval);
void set_user_divider(uint32_t chain, uint8_t chip_addr, uint8_t pll_id);
void set_user_divider.conflict(uint32_t chain, uint8_t mode, uint8_t chip_addr, uint8_t pll_id);
_Bool set_voltage_by_N(char * board_name, uint8_t which_chain, uint32_t voltage_N);
_Bool set_voltage_by_step(uint32_t pre_voltage, uint32_t target_voltage, uint8_t step_num);
void set_work_nonce2(uint32_t * value);
void sha2(uchar * input, int ilen, uchar * output);
void sha2_finish(sha2_context * ctx, uchar * output);
void sha2_process(sha2_context * ctx, uchar * data);
void sha2_starts(sha2_context * ctx);
void sha2_update(sha2_context * ctx, uchar * input, int ilen);
void show_fan_speed_protect_and_exit(void);
void show_ng_asics(void);
void show_sweep_failed(void);
_Bool show_sweep_setup_err(int err_code);
void show_sweep_summary(float * matrix);
void show_temp_protect_and_power_down(void);
void sighandler(int sig);
int sign(EVP_PKEY_CTX * ctx, uchar * sig, size_t * siglen, uchar * tbs, size_t tbslen);
int sign_init(EVP_PKEY_CTX * ctx);
int signctx(EVP_PKEY_CTX * ctx, uchar * sig, size_t * siglen, EVP_MD_CTX * mctx);
int signctx_init(EVP_PKEY_CTX * ctx, EVP_MD_CTX * mctx);
int32_t skip_rows(FILE * asic_pattern_file_handle, int skip_count);
_Bool sock_connecting(void);
void * software_pattern_16_midstate_send_function(void * arg);
void * software_pattern_mid_auto_gen_send_function(void * arg);
void sort_files_by_time(char[128] * logs, int left, int right);
char * ssl_request(char * url, char * post_str);
int32_t start_dhash_work_gen(void);
void start_new_log(char * test_type, char * sn, char * miner_type, char * board_name);
void start_recv_nonce(void);
int start_recv_thread(void);
int start_temp_thread(void);
void start_upload_logs(void);
int32_t stop_dhash_work_gen(void);
void stop_generate_work_for_job(void);
void stop_recv_nonce(void);
void stop_threads(void);
int strbuffer_append_byte(strbuffer_t * strbuff, char byte);
int strbuffer_append_bytes(strbuffer_t * strbuff, char * data, size_t size);
void strbuffer_clear(strbuffer_t * strbuff);
void strbuffer_close(strbuffer_t * strbuff);
int strbuffer_init(strbuffer_t * strbuff);
char strbuffer_pop(strbuffer_t * strbuff);
char * strbuffer_steal_value(strbuffer_t * strbuff);
char * strbuffer_value(strbuffer_t * strbuff);
int stream_get(stream_t * stream, json_error_t * error);
void stream_unget(stream_t * stream, int c);
json_t * string_create(char * value, size_t len, int own);
int string_get(void * data);
void submit_cur_log(void);
_Bool submit_result_to_MES_system(void);
void submit_test_result_to_mes(void);
_Bool substr(char * src, uint32_t start, uint32_t length, char * dest);
int sw_check_status(void);
int sw_drop(float * * matrix, uint8_t * * state);
int sw_flush(float * * matrix);
int sw_init(void * conf, void * sweep);
void sw_nomalize_matrix(float * * matrix, int row, int column);
void sw_pt_clear_stats(void);
void sw_pt_exit(void);
void * sw_pt_get_stats(void);
int32_t sw_pt_init(char * pattern_file_path);
int32_t sw_pt_is_recv_nonce_enough(uint32_t chain);
int32_t sw_pt_is_unbalance_happen(uint32_t chain);
void sw_pt_process_nonce(void * return_nonce, void * arg);
void sw_pt_process_reg(void * return_nonce, void * arg);
void sw_pt_reset(void);
int32_t sw_pt_send_work(uint32_t chain, void * args);
int sw_stop(void);
int sw_sweep(float * * matrix, uint8_t * * state);
uint32_t swab32(uint32_t v);
int sweep_doing(void);
int sweep_droping(void);
void sweep_end_power_down(void);
int sweep_exit(void);
int sweep_flush(void);
int sweep_online_mode(float * last_matrix, float freq, int * trytime, _Bool reinit, uint8_t * state);
int sweep_over_mode(float * matrix);
void sweep_set_pwm_by_temp(void);
int sweep_setup(int type, int chain, void * conf, int test_levels, int pt2_level);
int32_t sync_time_from_network(void);
_Bool temp_sensor_check(void);
void test_singal(void);
int tls_session_secret_cb_fn(SSL * s, void * secret, int * secret_len, stack_st_SSL_CIPHER * peer_ciphers, SSL_CIPHER * * cipher, void * arg);
int tls_session_ticket_ext_cb_fn(SSL * s, uchar * data, int len, void * arg);
int transform_txt_to_bin(char * input_file, char * output_file);
clib_rb_node * tree_successor(clib_rb * pTree, clib_rb_node * x);
int32_t trigger_chain_hwsweep_pattern_test(uint8_t which_chain);
int32_t tsensor_close(uint32_t which_chain);
int32_t tsensor_open(uint32_t which_chain, uint8_t * slave_addr, uint8_t slave_num);
int32_t tsensor_read(uint32_t which_chain, uint8_t slave_addr, uint8_t reg_addr, uint8_t * buf, uint32_t len);
int32_t tsensor_write(uint32_t which_chain, uint8_t slave_addr, uint8_t reg_addr, uint8_t * buf, uint32_t len);
uchar twoc2hex(uchar high, uchar low);
int32_t uart_flush(uint32_t chain_id);
int32_t uart_flush_rx(uint32_t chain_id);
int32_t uart_flush_tx(uint32_t chain_id);
int32_t uart_get_config(uint32_t chain_id, bitmain_uart_conf_type_t type, void * val, int32_t * size);
int32_t uart_get_readable_byte_num(uint32_t chain_id);
int32_t uart_init(void);
int32_t uart_receive(uint32_t chain_id, void * data, uint32_t size, int32_t timeout);
int32_t uart_send(uint32_t chain_id, void * data, uint32_t size);
int32_t uart_set_config(uint32_t chain_id, bitmain_uart_conf_type_t type, void * val, int32_t size);
void uart_uninit(void);
int32_t ui_init(void);
void * ui_pull_function(void * args);
void ui_uninit(void);
_Bool ulltostr(char * str, size_t size, uint64_t num, int base);
int32_t unreg_key_callback(bitmain_key_callback function);
int32_t upgrade_pic(uint8_t which_chain, int8_t * file_path);
_Bool upload_logs(char * file_path);
void * upload_logs_func(void * arg);
size_t utf8_check_first(char byte);
size_t utf8_check_full(char * buffer, size_t size, int32_t * codepoint);
int utf8_check_string(char * string, size_t length);
int utf8_check_string_x(char * string, int length, int * p_err_pos);
int utf8_encode(int32_t codepoint, char * buffer, size_t * size);
char * utf8_iterate(char * buffer, size_t bufsize, int32_t * codepoint);
void utils_flip_swab(void * dest_p, void * src_p, uint32_t length);
int verify(EVP_PKEY_CTX * ctx, uchar * sig, size_t siglen, uchar * tbs, size_t tbslen);
int verify_cb(int param0, X509_STORE_CTX * param1);
int verify_init(EVP_PKEY_CTX * ctx);
int verify_recover(EVP_PKEY_CTX * ctx, uchar * sig, size_t * siglen, uchar * tbs, size_t tbslen);
int verify_recover_init(EVP_PKEY_CTX * ctx);
int verifyctx(EVP_PKEY_CTX * ctx, uchar * sig, int siglen, EVP_MD_CTX * mctx);
int verifyctx_init(EVP_PKEY_CTX * ctx, EVP_MD_CTX * mctx);
uchar wait4i2c_data(uint8_t * data);
uchar wait4i2c_ready(void);
int wait_board_temp(int8_t * tempval, int8_t sensor_num, int32_t target_temp);
_Bool wait_for_cool_down(uint8_t pic_sensor_number, uint32_t max_wait_time);
_Bool wait_for_cool_down_x(uint32_t max_wait_time);
_Bool waiting_cool_down(uint32_t max_wait_time, int8_t * temp, int8_t sensor_num, int gap);
_Bool write_EEPROM_PT1_marker(void);
int32_t write_asic_reg_with_addr(uint8_t chain, uint32_t asic, uint32_t reg, uint32_t data);
int32_t write_core_reg_with_addr(uint8_t chain, uint32_t asic, uint32_t corereg, uint32_t data);
_Bool write_dac(uint8_t which_chain, uint8_t which_dac, uint8_t which_reg, uint8_t * data, int32_t data_length);
int writer(UI * ui, UI_STRING * uis);
void * xnew(void);
void xxtea_decode(uint32_t * v, uint32_t n, uint32_t * key);
void xxtea_encode(uint32_t * v, uint32_t n, uint32_t * key);

#endif // SINGLE_BOARD_TEST_0BE428078300F787_DEBUG_TYPES_H
