//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <dirent.h>
#include <errno.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct __dirstream {
    int32_t e0;
};

struct dirent64 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_10948(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t *function_10968(int32_t nmemb, int32_t size);
int32_t function_10974(char *s1, char *s2);
int32_t function_10980(char *nptr, char **endptr, int32_t base);
int32_t function_1098c(struct _IO_FILE *stream);
void function_10998(int32_t *ptr);
char *function_109a4(char *s, int32_t n, struct _IO_FILE *stream);
int32_t *function_109b0(int32_t *ptr, int32_t size);
int32_t function_109bc(char *s1, char *s2);
int32_t function_109c8(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
int32_t function_109d4(int32_t fd, int32_t request, ...);
char *function_109e0(char *dest, char *src);
struct __dirstream *function_109ec(char *name);
int32_t function_109f8(char *file, int32_t oflag, ...);
int32_t *function_10a04(int32_t size);
int32_t function_10a10(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
char *function_10a1c(int32_t errnum);
void function_10a28(void);
void function_10a34(int32_t status);
int32_t function_10a40(char *nptr, char **endptr, int32_t base);
int32_t function_10a4c(char *s);
char *function_10a58(char *s, int32_t c);
int32_t function_10a64(struct _IO_FILE *stream, char *format, ...);
int32_t *function_10a70(void);
int32_t function_10a7c(char *s, int32_t maxlen, char *format, ...);
int32_t function_10a88(char *s, char *format, ...);
char *function_10a94(char *string);
int32_t *function_10aa0(int32_t *s, int32_t c, int32_t n);
int32_t function_10aac(struct _IO_FILE *stream);
int32_t function_10ab8(struct _IO_FILE *stream);
char *function_10ac4(char *s, int32_t c);
int32_t function_10ad0(int32_t c, struct _IO_FILE *stream);
int32_t function_10adc(char *s, char *format, ...);
struct dirent64 *function_10ae8(struct __dirstream *dirp);
struct _IO_FILE *function_10af4(char *filename, char *modes);
int32_t function_10b00(char *s1, char *s2, int32_t n);
void function_10b0c(void);
int32_t function_10b18(int32_t fd);
int32_t function_10b24(struct __dirstream *dirp);
int32_t function_10b30(int32_t *p_a1, int32_t i_a2, uint32_t i_a3);
int32_t function_10c74(int32_t i_a1, int32_t i_a2);
int32_t function_114c8(void);
int32_t function_114d4(void);
int32_t function_114f8(void);
int32_t function_1151c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11548(void);
int32_t function_11560(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_11566(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11572(void);
int32_t function_11574(int32_t i_a1);
int32_t function_11580(void);
int32_t function_11584(int32_t i_a1);
int32_t function_115e0(int32_t i_a1);
int32_t function_11618(int32_t i_a1, int32_t i_a2);
int32_t function_11660(int32_t i_a1, int32_t i_a2);
int32_t function_11718(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11854(void);
int32_t function_11df8(int32_t i_a1);
int32_t function_11f44(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_11fb8(int32_t i_a1);
int32_t function_12060(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_120a4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_22c0(void);
int32_t unknown_240(int32_t i_a1);

// --------------------- Global Variables ---------------------

char *x_g1[10] = {"dummy",   "Dummy bus",   "isa",   "ISA bus",
                  "i2c",     "I2C adapter", "smbus", "SMBus adapter",
                  "unknown", "N/A"}; // 0x126d8
int32_t i_g2 = 0x11549;       // 0x229e4
int32_t i_g3 = 1;             // 0x229ec
int32_t i_g4 = 0;             // 0x22b80
struct _IO_FILE *p_g5 = NULL; // 0x22b90
struct _IO_FILE *p_g6 = NULL; // 0x22b98
char *p_g7;                   // 0x22ba0
int32_t i_g8;
int32_t i_g9;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
char *__strdup(char *p_a1);
struct _IO_FILE *fopen64(char *p_a1, char *p_a2);
int32_t open64(char *p_a1, int32_t i_a2, ...);
struct dirent64 *readdir64(struct __dirstream *p_a1);

// ------------------------ Functions -------------------------

// Address range: 0x10948 - 0x10954
int32_t function_10948(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10948
    return function_114d4();
}

// Address range: 0x10968 - 0x10974
int32_t *function_10968(int32_t nmemb, int32_t size) {
    // 0x10968
    return calloc(nmemb, size);
}

// Address range: 0x10974 - 0x10980
int32_t function_10974(char *s1, char *s2) {
    // 0x10974
    return strcmp(s1, s2);
}

// Address range: 0x10980 - 0x1098c
int32_t function_10980(char *nptr, char **endptr, int32_t base) {
    // 0x10980
    return strtol(nptr, endptr, base);
}

// Address range: 0x1098c - 0x10998
int32_t function_1098c(struct _IO_FILE *stream) {
    // 0x1098c
    return fflush(stream);
}

// Address range: 0x10998 - 0x109a4
void function_10998(int32_t *ptr) {
    // 0x10998
    free(ptr);
}

// Address range: 0x109a4 - 0x109b0
char *function_109a4(char *s, int32_t n, struct _IO_FILE *stream) {
    // 0x109a4
    return fgets(s, n, stream);
}

// Address range: 0x109b0 - 0x109bc
int32_t *function_109b0(int32_t *ptr, int32_t size) {
    // 0x109b0
    return realloc(ptr, size);
}

// Address range: 0x109bc - 0x109c8
int32_t function_109bc(char *s1, char *s2) {
    // 0x109bc
    return strcasecmp(s1, s2);
}

// Address range: 0x109c8 - 0x109d4
int32_t function_109c8(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x109c8
    return fwrite(ptr, size, n, s);
}

// Address range: 0x109d4 - 0x109e0
int32_t function_109d4(int32_t fd, int32_t request, ...) {
    // 0x109d4
    return ioctl(fd, request);
}

// Address range: 0x109e0 - 0x109ec
char *function_109e0(char *dest, char *src) {
    // 0x109e0
    return strcpy(dest, src);
}

// Address range: 0x109ec - 0x109f8
struct __dirstream *function_109ec(char *name) {
    // 0x109ec
    return opendir(name);
}

// Address range: 0x109f8 - 0x10a04
int32_t function_109f8(char *file, int32_t oflag, ...) {
    // 0x109f8
    return open64(file, oflag);
}

// Address range: 0x10a04 - 0x10a10
int32_t *function_10a04(int32_t size) {
    // 0x10a04
    return malloc(size);
}

// Address range: 0x10a10 - 0x10a1c
int32_t function_10a10(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x10a10
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10a1c - 0x10a28
char *function_10a1c(int32_t errnum) {
    // 0x10a1c
    return strerror(errnum);
}

// Address range: 0x10a28 - 0x10a34
void function_10a28(void) {
    // 0x10a28
    __gmon_start__();
}

// Address range: 0x10a34 - 0x10a40
void function_10a34(int32_t status) {
    // 0x10a34
    exit(status);
}

// Address range: 0x10a40 - 0x10a4c
int32_t function_10a40(char *nptr, char **endptr, int32_t base) {
    // 0x10a40
    return strtoul(nptr, endptr, base);
}

// Address range: 0x10a4c - 0x10a58
int32_t function_10a4c(char *s) {
    // 0x10a4c
    return strlen(s);
}

// Address range: 0x10a58 - 0x10a64
char *function_10a58(char *s, int32_t c) {
    // 0x10a58
    return strchr(s, c);
}

// Address range: 0x10a64 - 0x10a70
int32_t function_10a64(struct _IO_FILE *stream, char *format, ...) {
    // 0x10a64
    return fprintf(stream, format);
}

// Address range: 0x10a70 - 0x10a7c
int32_t *function_10a70(void) {
    // 0x10a70
    return __errno_location();
}

// Address range: 0x10a7c - 0x10a88
int32_t function_10a7c(char *s, int32_t maxlen, char *format, ...) {
    // 0x10a7c
    return snprintf(s, maxlen, format);
}

// Address range: 0x10a88 - 0x10a94
int32_t function_10a88(char *s, char *format, ...) {
    // 0x10a88
    return sscanf(s, format);
}

// Address range: 0x10a94 - 0x10aa0
char *function_10a94(char *string) {
    // 0x10a94
    return __strdup(string);
}

// Address range: 0x10aa0 - 0x10aac
int32_t *function_10aa0(int32_t *s, int32_t c, int32_t n) {
    // 0x10aa0
    return memset(s, c, n);
}

// Address range: 0x10aac - 0x10ab8
int32_t function_10aac(struct _IO_FILE *stream) {
    // 0x10aac
    return fgetc(stream);
}

// Address range: 0x10ab8 - 0x10ac4
int32_t function_10ab8(struct _IO_FILE *stream) {
    // 0x10ab8
    return fclose(stream);
}

// Address range: 0x10ac4 - 0x10ad0
char *function_10ac4(char *s, int32_t c) {
    // 0x10ac4
    return strrchr(s, c);
}

// Address range: 0x10ad0 - 0x10adc
int32_t function_10ad0(int32_t c, struct _IO_FILE *stream) {
    // 0x10ad0
    return fputc(c, stream);
}

// Address range: 0x10adc - 0x10ae8
int32_t function_10adc(char *s, char *format, ...) {
    // 0x10adc
    return sprintf(s, format);
}

// Address range: 0x10ae8 - 0x10af4
struct dirent64 *function_10ae8(struct __dirstream *dirp) {
    // 0x10ae8
    return readdir64(dirp);
}

// Address range: 0x10af4 - 0x10b00
struct _IO_FILE *function_10af4(char *filename, char *modes) {
    // 0x10af4
    return fopen64(filename, modes);
}

// Address range: 0x10b00 - 0x10b0c
int32_t function_10b00(char *s1, char *s2, int32_t n) {
    // 0x10b00
    return strncmp(s1, s2, n);
}

// Address range: 0x10b0c - 0x10b18
void function_10b0c(void) {
    // 0x10b0c
    abort();
}

// Address range: 0x10b18 - 0x10b24
int32_t function_10b18(int32_t fd) {
    // 0x10b18
    return close(fd);
}

// Address range: 0x10b24 - 0x10b30
int32_t function_10b24(struct __dirstream *dirp) {
    // 0x10b24
    return closedir(dirp);
}

// Address range: 0x10b30 - 0x10c74
int32_t function_10b30(int32_t *p_a1, int32_t i_a2, uint32_t i_a3) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2 = __asm_ubfx(i_a3, 2, 1); // 0x10b68
    if (i_a2 == 0) {
        // 0x10c6c
        return i_v1;
    }
    struct _IO_FILE *p_v3 =
        (struct _IO_FILE *)*(int32_t *)(i_a3 % 2 == 0 ? 0x22b9c : 0x22b90);
    int32_t i_v4 = 0;
    uint16_t i_v5 = *(int16_t *)(i_v1 + 2); // 0x10b78
    int32_t i_v6;                           // 0x10b30
    int32_t i_v7 = i_v6;                    // 0x10b80
    if (i_v5 % 2 != 0) {
        i_v7 = __asm_ubfxne(i_a3, 1, 1);
    }
    int16_t *p_v8 = (int16_t *)(i_v1 + 4);
    int32_t i_v9 = i_v1; // 0x10b8c
    uint16_t i_v10;      // 0x10bac
    char *p_v11;         // 0x10bb4
    uint16_t i_v12;      // 0x10b90
    if ((i_a3 & 8) != 0) {
        // 0x10b90
        i_v12 = *p_v8;
        i_v10 = *(int16_t *)i_v1;
        p_v11 = i_v5 % 2 == 0 ? "write" : "read";
        i_v9 = fprintf(p_v3, "msg %u: addr 0x%02x, %s, len %u", i_v4,
                       (int32_t)i_v10, p_v11, (int32_t)i_v12);
    }
    int16_t i_v13 = *p_v8; // 0x10bc4
    int32_t i_v14;         // 0x10b30
    int32_t i_v15;         // 0x10b30
    int16_t i_v16;         // 0x10b30
    int32_t i_v17;         // 0x10b30
    int32_t i_v18;         // 0x10b30
    int32_t i_v19;         // 0x10b30
    int32_t i_v20;         // 0x10b30
    int32_t *p_v21;        // 0x10c20
    int32_t i_v22;         // 0x10b30
    uint32_t i_v23;        // 0x10c04
    int32_t i_v24;         // 0x10c0c
    int32_t i_v25;         // 0x10b30
    if ((i_v5 % 2 == 0 ? i_v2 : i_v7) % 2 == 0 || i_v13 == 0) {
        // 0x10c4c
        i_v19 = i_v9;
        i_v20 = 0;
        if ((i_a3 & 8) != 0) {
            // 0x10c54
            i_v19 = fputc(10, p_v3);
            i_v20 = 0;
        }
    } else {
        // 0x10bdc
        i_v16 = i_v13;
        if ((i_a3 & 8) != 0) {
            // 0x10be4
            fwrite((int32_t *)", buf ", 1, 6, p_v3);
            i_v16 = *p_v8;
        }
        // 0x10bfc
        p_v21 = (int32_t *)(i_v1 + 8);
        i_v22 = (int32_t) * (char *)*p_v21;
        i_v17 = i_v22;
        i_v18 = 1;
        i_v15 = 1;
        i_v14 = i_v22;
        if (i_v16 > 1) {
            fprintf(p_v3, "0x%02x ", i_v17);
            i_v23 = i_v18 % 0x10000;
            i_v24 = i_v18 + 1;
            i_v25 = (int32_t) * (char *)(*p_v21 + i_v23);
            i_v17 = i_v25;
            i_v18 = i_v24;
            i_v15 = i_v24;
            i_v14 = i_v25;
            while (i_v23 < (int32_t)*p_v8 - 1) {
                // 0x10c28
                fprintf(p_v3, "0x%02x ", i_v17);
                i_v23 = i_v18 % 0x10000;
                i_v24 = i_v18 + 1;
                i_v25 = (int32_t) * (char *)(*p_v21 + i_v23);
                i_v17 = i_v25;
                i_v18 = i_v24;
                i_v15 = i_v24;
                i_v14 = i_v25;
            }
        }
        // 0x10c38
        i_v19 = fprintf(p_v3, "0x%02x\n", i_v14);
        i_v20 = i_v15;
    }
    int32_t i_v26 = i_v19;
    int32_t i_v27 = i_v4 + 1;  // 0x10c60
    int32_t i_v28 = i_v1 + 12; // 0x10b74
    while (i_v27 != i_a2) {
        int32_t i_v29 = i_v28;
        i_v4 = i_v27;
        i_v5 = *(int16_t *)(i_v29 + 2);
        i_v7 = i_v20;
        if (i_v5 % 2 != 0) {
            i_v7 = __asm_ubfxne(i_a3, 1, 1);
        }
        p_v8 = (int16_t *)(i_v29 + 4);
        i_v9 = i_v26;
        if ((i_a3 & 8) != 0) {
            // 0x10b90
            i_v12 = *p_v8;
            i_v10 = *(int16_t *)i_v29;
            p_v11 = i_v5 % 2 == 0 ? "write" : "read";
            i_v9 = fprintf(p_v3, "msg %u: addr 0x%02x, %s, len %u", i_v4,
                           (int32_t)i_v10, p_v11, (int32_t)i_v12);
        }
        // 0x10bc4
        i_v13 = *p_v8;
        if ((i_v5 % 2 == 0 ? i_v2 : i_v7) % 2 == 0 || i_v13 == 0) {
            // 0x10c4c
            i_v19 = i_v9;
            i_v20 = 0;
            if ((i_a3 & 8) != 0) {
                // 0x10c54
                i_v19 = fputc(10, p_v3);
                i_v20 = 0;
            }
        } else {
            // 0x10bdc
            i_v16 = i_v13;
            if ((i_a3 & 8) != 0) {
                // 0x10be4
                fwrite((int32_t *)", buf ", 1, 6, p_v3);
                i_v16 = *p_v8;
            }
            // 0x10bfc
            p_v21 = (int32_t *)(i_v29 + 8);
            i_v22 = (int32_t) * (char *)*p_v21;
            i_v17 = i_v22;
            i_v18 = 1;
            i_v15 = 1;
            i_v14 = i_v22;
            if (i_v16 > 1) {
                fprintf(p_v3, "0x%02x ", i_v17);
                i_v23 = i_v18 % 0x10000;
                i_v24 = i_v18 + 1;
                i_v25 = (int32_t) * (char *)(*p_v21 + i_v23);
                i_v17 = i_v25;
                i_v18 = i_v24;
                i_v15 = i_v24;
                i_v14 = i_v25;
                while (i_v23 < (int32_t)*p_v8 - 1) {
                    // 0x10c28
                    fprintf(p_v3, "0x%02x ", i_v17);
                    i_v23 = i_v18 % 0x10000;
                    i_v24 = i_v18 + 1;
                    i_v25 = (int32_t) * (char *)(*p_v21 + i_v23);
                    i_v17 = i_v25;
                    i_v18 = i_v24;
                    i_v15 = i_v24;
                    i_v14 = i_v25;
                }
            }
            // 0x10c38
            i_v19 = fprintf(p_v3, "0x%02x\n", i_v14);
            i_v20 = i_v15;
        }
        // 0x10c60
        i_v26 = i_v19;
        i_v27 = i_v4 + 1;
        i_v28 = i_v29 + 12;
    }
    // 0x10c6c
    return i_v26;
}

// Address range: 0x10c74 - 0x114a4
int32_t function_10c74(int32_t i_a1, int32_t i_a2) {
    // 0x10c74
    int32_t i_v1;         // bp-40, 0x10c74
    int32_t i_v2 = &i_v1; // 0x10c84
    int32_t i_v3;         // bp-544, 0x10c74
    int32_t i_v4 = &i_v3; // 0x10c8c
    int32_t i_v5 = i_v4;  // 0x10c90
    *(int32_t *)(i_v5 + 8) = 0;
    i_v5 += 12;
    while (i_v5 != i_v2) {
        // 0x10c94
        *(int32_t *)(i_v5 + 8) = 0;
        i_v5 += 12;
    }
    int32_t i_v6;  // 0x10c74
    int32_t i_v7;  // 0x10c74
    int32_t i_v8;  // 0x10c74
    int32_t i_v9;  // 0x10c74
    int32_t i_v10; // 0x10c74
    int32_t i_v11; // 0x10c74
    if (i_a1 < 2) {
        // 0x10f9c
        i_v8 = 0;
        i_v9 = 1;
        i_v10 = 0;
        i_v11 = 0;
        i_v6 = 0;
        if (i_a1 == 1) {
        lab_0x10f88:
            // 0x10f88
            fwrite(
                (int32_t
                     *)"Usage: i2ctransfer [-f] [-y] [-v] [-V] [-a] I2CBUS "
                       "DESC [DATA] [DESC [DATA]]...\n  I2CBUS is an integer "
                       "or an I2C bus name\n  DESC describes the transfer in "
                       "the form: {r|w}LENGTH[@address]\n    1) "
                       "read/write-flag 2) LENGTH (range 0-65535) 3) I2C "
                       "address (use last one if omitted)\n  DATA are LENGTH "
                       "bytes for a write message. They can be shortened by a "
                       "suffix:\n    = (keep value constant until LENGTH)\n    "
                       "+ (increase value by 1 until LENGTH)\n    - (decrease "
                       "value by 1 until LENGTH)\n    p (use pseudo random "
                       "generator until LENGTH with value as seed)\n\nExample "
                       "(bus 0, read 8 byte at offset 0x64 from EEPROM at "
                       "0x50):\n  # i2ctransfer 0 w1@0x50 0x64 r8\nExample "
                       "(same EEPROM, at offset 0x42 write 0xff 0xfe ... "
                       "0xf0):\n  # i2ctransfer 0 w17@0x50 0x42 0xff-\n",
                1, 750, p_g5);
            // 0x10f94
            exit(1);
            // UNREACHABLE
        }
    } else {
        int32_t i_v12 = i_a2 + 4;          // 0x10cac
        int32_t i_v13 = *(int32_t *)i_v12; // 0x10cac
        int32_t i_v14 = 0;                 // 0x10cbc
        int32_t i_v15 = i_v12;             // 0x10cbc
        int32_t i_v16 = i_v13;             // 0x10cbc
        int32_t i_v17 = 0;                 // 0x10cbc
        int32_t i_v18 = 1;                 // 0x10cbc
        int32_t i_v19 = 0;                 // 0x10cbc
        int32_t i_v20 = 0;                 // 0x10cbc
        int32_t i_v21 = 0;                 // 0x10cbc
        i_v8 = 0;
        i_v9 = 1;
        i_v10 = 0;
        i_v11 = 0;
        i_v6 = 0;
        if (*(char *)i_v13 == 45) {
            int32_t i_v22; // 0x10c74
            while (true) {
                int32_t i_v23 = i_v21;
                int32_t i_v24 = i_v20;
                int32_t i_v25 = i_v19;
                int32_t i_v26 = i_v18;
                int32_t i_v27 = i_v17;
                i_v22 = i_v16;
                int32_t i_v28 = i_v14;
                unsigned char i_v29 = *(char *)(i_v22 + 1); // 0x10cd8
                i_g8 = (int32_t)i_v29 - 86;
                int32_t i_v30 = i_v28; // 0x10ce4
                int32_t i_v31 = 1;     // 0x10ce4
                int32_t i_v32 = i_v24; // 0x10ce4
                int32_t i_v33 = i_v23; // 0x10ce4
                int32_t i_v34;         // 0x10c74
                int32_t i_v35;         // 0x10c74
                int32_t i_v36;         // 0x10c74
                int32_t i_v37;         // 0x10c74
                int32_t i_v38;         // 0x10c74
                int32_t i_v39;         // 0x10c74
                switch (i_v29) {
                case 86: {
                    // 0x10f4c
                    i_v30 = 1;
                    i_v31 = i_v25;
                    i_v32 = i_v24;
                    i_v33 = i_v23;
                }
                case 102: {
                lab_0x10d80:;
                    int32_t i_v40 = i_v26 + 1; // 0x10d80
                    i_v35 = i_v30;
                    i_v36 = i_v27;
                    i_v37 = i_v40;
                    i_v38 = i_v31;
                    i_v39 = i_v32;
                    i_v34 = i_v33;
                    i_v7 = i_v30;
                    if (i_v40 == i_a1) {
                        goto lab_0x10f2c_2;
                    }
                    // break -> 0x10d8c
                    break;
                }
                case 121: {
                    // 0x10f54
                    i_v30 = i_v28;
                    i_v31 = i_v25;
                    i_v32 = i_v24;
                    i_v33 = 1;
                    // branch (via goto) -> 0x10d80
                    goto lab_0x10d80;
                }
                case 118: {
                    // 0x10f5c
                    i_v30 = i_v28;
                    i_v31 = i_v25;
                    i_v32 = 1;
                    i_v33 = i_v23;
                    // branch (via goto) -> 0x10d80
                    goto lab_0x10d80;
                }
                case 97: {
                    int32_t i_v41 = i_v26 + 1; // 0x10f1c
                    i_v35 = i_v28;
                    i_v36 = 1;
                    i_v37 = i_v41;
                    i_v38 = i_v25;
                    i_v39 = i_v24;
                    i_v34 = i_v23;
                    i_v7 = i_v28;
                    if (i_v41 == i_a1) {
                        goto lab_0x10f2c_2;
                    }
                    // break -> 0x10d8c
                    break;
                }
                default: {
                    // 0x10f64
                    fprintf(p_g5, "Error: Unsupported option \"%s\"!\n",
                            (char *)i_v22);
                    // 0x10f88
                    fwrite(
                        (int32_t
                             *)"Usage: i2ctransfer [-f] [-y] [-v] [-V] [-a] "
                               "I2CBUS DESC [DATA] [DESC [DATA]]...\n  I2CBUS "
                               "is an integer or an I2C bus name\n  DESC "
                               "describes the transfer in the form: "
                               "{r|w}LENGTH[@address]\n    1) read/write-flag "
                               "2) LENGTH (range 0-65535) 3) I2C address (use "
                               "last one if omitted)\n  DATA are LENGTH bytes "
                               "for a write message. They can be shortened by "
                               "a suffix:\n    = (keep value constant until "
                               "LENGTH)\n    + (increase value by 1 until "
                               "LENGTH)\n    - (decrease value by 1 until "
                               "LENGTH)\n    p (use pseudo random generator "
                               "until LENGTH with value as seed)\n\nExample "
                               "(bus 0, read 8 byte at offset 0x64 from EEPROM "
                               "at 0x50):\n  # i2ctransfer 0 w1@0x50 0x64 "
                               "r8\nExample (same EEPROM, at offset 0x42 write "
                               "0xff 0xfe ... 0xf0):\n  # i2ctransfer 0 "
                               "w17@0x50 0x42 0xff-\n",
                        1, 750, p_g5);
                    // 0x10f94
                    exit(1);
                    // UNREACHABLE
                }
                }
                int32_t i_v42 = i_v34;
                int32_t i_v43 = i_v39;
                int32_t i_v44 = i_v38;
                int32_t i_v45 = i_v37;
                int32_t i_v46 = i_v36;
                int32_t i_v47 = i_v35;
                int32_t i_v48 = i_v15 + 4;         // 0x10d8c
                int32_t i_v49 = *(int32_t *)i_v48; // 0x10d8c
                i_v14 = i_v47;
                i_v15 = i_v48;
                i_v16 = i_v49;
                i_v17 = i_v46;
                i_v18 = i_v45;
                i_v19 = i_v44;
                i_v20 = i_v43;
                i_v21 = i_v42;
                if (*(char *)i_v49 != 45) {
                    // 0x10d9c
                    i_v8 = i_v46;
                    i_v9 = i_v45;
                    i_v10 = i_v44;
                    i_v11 = i_v43;
                    i_v6 = i_v42;
                    if (i_v47 == 0) {
                        goto lab_0x10da4;
                    } else {
                        goto lab_0x10fb8;
                    }
                }
            }
            // 0x10f64
            fprintf(p_g5, "Error: Unsupported option \"%s\"!\n", (char *)i_v22);
            // 0x10f88
            fwrite(
                (int32_t
                     *)"Usage: i2ctransfer [-f] [-y] [-v] [-V] [-a] I2CBUS "
                       "DESC [DATA] [DESC [DATA]]...\n  I2CBUS is an integer "
                       "or an I2C bus name\n  DESC describes the transfer in "
                       "the form: {r|w}LENGTH[@address]\n    1) "
                       "read/write-flag 2) LENGTH (range 0-65535) 3) I2C "
                       "address (use last one if omitted)\n  DATA are LENGTH "
                       "bytes for a write message. They can be shortened by a "
                       "suffix:\n    = (keep value constant until LENGTH)\n    "
                       "+ (increase value by 1 until LENGTH)\n    - (decrease "
                       "value by 1 until LENGTH)\n    p (use pseudo random "
                       "generator until LENGTH with value as seed)\n\nExample "
                       "(bus 0, read 8 byte at offset 0x64 from EEPROM at "
                       "0x50):\n  # i2ctransfer 0 w1@0x50 0x64 r8\nExample "
                       "(same EEPROM, at offset 0x42 write 0xff 0xfe ... "
                       "0xf0):\n  # i2ctransfer 0 w17@0x50 0x42 0xff-\n",
                1, 750, p_g5);
            // 0x10f94
            exit(1);
            // UNREACHABLE
        }
    }
    goto lab_0x10da4;
lab_0x10f2c_2:
    // 0x10f2c
    if (i_v7 == 0) {
        goto lab_0x10f88;
    } else {
        goto lab_0x10fb8;
    }
lab_0x1107c:;
    // 0x1107c
    int32_t i_v79;         // 0x11030
    int32_t i_v75 = i_v79; // 0x11028
    int32_t i_v81;         // 0x10c74
    int32_t i_v76 = i_v81; // 0x11028
    int32_t i_v74 = i_v79; // 0x11028
    uint32_t i_v73;        // 0x11020
    if (i_v79 >= i_v73) {
        // break -> 0x11134
        goto lab_0x11134_2;
    }
    goto lab_0x1102c;
lab_0x110c8_2:;
    // 0x110c8
    int32_t *p_v68; // 0x10e4c
    fprintf(p_g5, "Error: faulty argument is '%s'\n", (char *)*p_v68);
    int32_t i_v65;         // 0x10c74
    int32_t i_v90 = i_v65; // 0x110dc
    goto lab_0x110e0;
lab_0x10f04:;
    // 0x10f04
    int32_t i_v83;             // 0x10c74
    int32_t i_v85 = i_v83;     // 0x10f08
    int32_t i_v84;             // 0x10c74
    int32_t i_v86 = i_v84;     // 0x10f08
    int32_t i_v87 = i_v65 + 1; // 0x10f08
    int32_t i_v88 = 0;         // 0x10f08
    goto lab_0x10f0c;
lab_0x10f0c:;
    int32_t i_v98 = i_v88;
    int32_t i_v95 = i_v87;
    int32_t i_v59; // 0x10c74
    int32_t i_v99 = i_v59 + 1;
    i_v59 = i_v99;
    int32_t i_v60 = i_v98; // 0x10e3c
    int32_t i_v61 = i_v95; // 0x10e3c
    int32_t i_v62 = i_v86; // 0x10e3c
    int32_t i_v63 = i_v85; // 0x10e3c
    int32_t i_v64;         // 0x10c74
    i_v64 += 4;
    int32_t i_v57; // 0x10c74
    int32_t i_v53; // bp-564, 0x10c74
    if (i_v99 >= i_a1) {
        // 0x112ac
        i_v57 = i_v95;
        if (i_v95 != 0 == i_v98 == 0) {
            if (i_v6 == 0) {
                // 0x112d4
                fwrite((int32_t *)"WARNING! This program can confuse your I2C "
                                  "bus, cause data loss and worse!\n",
                       1, 75, p_g5);
                fprintf(
                    p_g5,
                    "I will send the following messages to device file %s:\n",
                    &i_v53);
                function_10b30(&i_v3, i_v95, 13);
                fwrite((int32_t *)"Continue? [y/N] ", 1, 16, p_g5);
                fflush(p_g5);
                if (function_11fb8(0) == 0) {
                    // 0x11434
                    fwrite((int32_t *)"Aborting on user request.\n", 1, 26,
                           p_g5);
                    goto lab_0x113ac;
                } else {
                    goto lab_0x11348;
                }
            } else {
                goto lab_0x11348;
            }
        } else {
            goto lab_0x11410;
        }
    }
    goto lab_0x10e40;
lab_0x10e7c:;
    // 0x10e7c
    int32_t i_v69;                                        // 0x10e4c
    int32_t i_v100 = i_v69 + 1;                           // 0x10e64
    char *p_v55;                                          // bp-572, 0x10c74
    uint32_t i_v101 = strtoul((char *)i_v100, &p_v55, 0); // 0x10e88
    if (i_v101 >= 0x10000) {
        // 0x111c0
        fwrite((int32_t *)"Error: Length invalid\n", 1, 22, p_g5);
        goto lab_0x110c8_2;
    }
    int32_t i_v102 = (int32_t)p_v55; // 0x10e98
    if (i_v100 == i_v102) {
        // 0x111c0
        fwrite((int32_t *)"Error: Length invalid\n", 1, 22, p_g5);
        goto lab_0x110c8_2;
    }
    // 0x10ea4
    int32_t i_v89; // 0x10c74
    int32_t i_v103 = i_v89;
    int32_t i_v66;  // 0x10c74
    int32_t i_v104; // 0x10c74
    int32_t i_v52;  // 0x10dc8
    char *p_v105;   // 0x10e98
    switch (*p_v105) {
    case 0: {
        // 0x1118c
        i_v104 = i_v66;
        if (i_v66 == -1) {
            // 0x11198
            fwrite((int32_t *)"Error: No address given\n", 1, 24, p_g5);
            goto lab_0x110c8_2;
        }
        goto lab_0x10ed8;
    }
    case 64: {
        int32_t i_v106 = function_11660(i_v102 + 1, i_v8); // 0x10ec0
        if (i_v106 < 0) {
            goto lab_0x110c8_2;
        }
        // 0x10ed0
        i_v104 = i_v106;
        if (i_v10 == 0) {
            int32_t i_v107 = function_11f44(i_v52, i_v106, 0); // 0x11244
            i_v104 = i_v106;
            if (i_v107 != 0) {
                goto lab_0x110c8_2;
            }
        }
        goto lab_0x10ed8;
    }
    default: {
        // 0x11260
        fwrite((int32_t *)"Error: Unknown separator after length\n", 1, 38,
               p_g5);
        goto lab_0x110c8_2;
    }
    }
lab_0x10ed8:;
    int32_t i_v108 = i_v104;
    int32_t i_v109 = 12 * i_v65;    // 0x10ee0
    int32_t i_v110 = i_v109 + i_v4; // 0x10ef0
    *(int16_t *)i_v110 = (int16_t)i_v108;
    *(int16_t *)(i_v110 | 2) = (int16_t)i_v103;
    *(int16_t *)(i_v110 + 4) = (int16_t)i_v101;
    i_v83 = i_v108;
    int32_t i_v67; // 0x10c74
    i_v84 = i_v67;
    int32_t i_v58; // 0x10c74
    if (i_v101 == 0) {
        goto lab_0x10f04;
    } else {
        int32_t *p_v111 = malloc(i_v101); // 0x11144
        if (p_v111 == NULL) {
            // 0x11210
            fwrite((int32_t *)"Error: No memory for buffer\n", 1, 28, p_g5);
            goto lab_0x110c8_2;
        }
        // 0x11150
        memset(p_v111, 0, i_v101);
        *(int32_t *)(i_v109 + i_v58) = (int32_t)p_v111;
        i_v83 = i_v108;
        i_v84 = i_v67;
        i_v85 = i_v108;
        i_v86 = 0;
        i_v87 = i_v65;
        i_v88 = 1;
        if (i_v103 == 0) {
            goto lab_0x10f0c;
        } else {
            goto lab_0x10f04;
        }
    }
lab_0x10da4:;
    int32_t i_v50 = 4 * i_v9;                                   // 0x10da4
    int32_t i_v51 = function_11df8(*(int32_t *)(i_v50 + i_a2)); // 0x10db0
    if (i_v51 < 0) {
        // 0x10f94
        exit(1);
        // UNREACHABLE
    }
    // 0x10dbc
    i_v52 = function_11718(i_v51, &i_v53, 20, 0);
    if (i_v52 < 0) {
        // 0x10f94
        exit(1);
        // UNREACHABLE
    }
    // 0x10dd8
    if (ioctl(i_v52, 1797) < 0) {
        int32_t i_v54 = *__errno_location(); // 0x11484
        fprintf(p_g5,
                "Error: Could not get the adapter functionality matrix: %s\n",
                strerror(i_v54));
        // 0x10f94
        exit(1);
        // UNREACHABLE
    }
    // 0x10dec
    if ((int32_t)p_v55 % 2 == 0) {
        // 0x11450
        fprintf(p_g5, "Error: Adapter does not have %s capability\n",
                "I2C transfers");
        // 0x10f94
        exit(1);
        // UNREACHABLE
    }
    int32_t i_v56 = i_v9 + 1;
    i_v57 = 0;
    if (i_v56 < i_a1) {
        // 0x10e40
        i_v58 = i_v2 - 496;
        i_v59 = i_v56;
        i_v60 = 0;
        i_v61 = 0;
        i_v62 = 0;
        i_v63 = -1;
        i_v64 = i_a2 + 4 + i_v50;
        while (true) {
        lab_0x10e40:
            // 0x10e40
            i_v65 = i_v61;
            if (i_v65 > 42) {
                // break -> 0x11288
                break;
            }
            // 0x10e58
            i_v66 = i_v63;
            i_v67 = i_v62;
            p_v68 = (int32_t *)i_v64;
            i_v69 = *p_v68;
            char *p_v70 = (char *)i_v69;
            if (i_v60 == 1) {
                uint32_t i_v71 = strtoul(p_v70, &p_v55, 0); // 0x10fec
                if (i_v71 >= 255 == (i_v71 != 255)) {
                    // 0x111e8
                    fwrite((int32_t *)"Error: Invalid data byte\n", 1, 25,
                           p_g5);
                    goto lab_0x110c8_2;
                }
                // 0x10ff8
                if (i_v69 == (int32_t)p_v55) {
                    // 0x111e8
                    fwrite((int32_t *)"Error: Invalid data byte\n", 1, 25,
                           p_g5);
                    goto lab_0x110c8_2;
                }
                int32_t i_v72 = 12 * i_v65; // 0x1100c
                i_v73 = (int32_t) * (int16_t *)(i_v4 + 4 + i_v72);
                i_v74 = i_v67;
                if (i_v67 < i_v73) {
                    // 0x1102c
                    i_v75 = i_v67;
                    i_v76 = i_v71 % 256;
                    while (true) {
                    lab_0x1102c:;
                        int32_t i_v77 = i_v76;
                        int32_t i_v78 = *(int32_t *)(i_v72 + i_v58); // 0x1102c
                        i_v79 = i_v75 + 1;
                        *(char *)(i_v78 + i_v75) = (char)i_v77;
                        unsigned char i_v80 = *p_v55; // 0x1103c
                        i_v74 = i_v79;
                        switch (i_v80) {
                        case 0: {
                            goto lab_0x11134_2;
                        }
                        case 45: {
                            // 0x11098
                            i_v81 = (i_v77 + 255) % 256;
                            goto lab_0x1107c;
                        }
                        default: {
                            if (i_v80 < 45) {
                                if (i_v80 != 43) {
                                    // 0x110a4
                                    fwrite((int32_t *)"Error: Invalid data "
                                                      "byte suffix\n",
                                           1, 32, p_g5);
                                    goto lab_0x110c8_2;
                                }
                                // 0x1108c
                                i_v81 = (i_v77 + 1) % 256;
                                goto lab_0x1107c;
                            } else {
                                // 0x11054
                                i_v81 = i_v77;
                                switch (i_v80) {
                                case 61: {
                                    goto lab_0x1107c;
                                }
                                case 112: {
                                    uint32_t i_v82 =
                                        ((i_v77 ^ 27) + 13) % 256; // 0x1106c
                                    i_v81 = 2 * i_v82 & 254 | i_v82 / 128;
                                    goto lab_0x1107c;
                                }
                                default: {
                                    // 0x110a4
                                    fwrite((int32_t *)"Error: Invalid data "
                                                      "byte suffix\n",
                                           1, 32, p_g5);
                                    goto lab_0x110c8_2;
                                }
                                }
                            }
                        }
                        }
                    }
                }
            lab_0x11134_2:
                // 0x11134
                i_v83 = i_v66;
                i_v84 = i_v73;
                i_v85 = i_v66;
                i_v86 = i_v74;
                i_v87 = i_v65;
                i_v88 = 1;
                if (i_v74 == i_v73) {
                    goto lab_0x10f04;
                } else {
                    goto lab_0x10f0c;
                }
            } else {
                // 0x10e60
                i_v89 = 1;
                switch (*p_v70) {
                case 114: {
                    goto lab_0x10e7c;
                }
                case 119: {
                    // 0x10e7c
                    i_v89 = 0;
                    goto lab_0x10e7c;
                }
                default: {
                    // 0x11108
                    fwrite((int32_t *)"Error: Invalid direction\n", 1, 25,
                           p_g5);
                    goto lab_0x110c8_2;
                }
                }
            }
        }
        // 0x11288
        fprintf(p_g5, "Error: Too many messages (max: %d)\n", 42);
        i_v90 = i_v65;
        goto lab_0x110e0;
    } else {
        goto lab_0x11410;
    }
lab_0x11410:
    // 0x11410
    fwrite((int32_t *)"Error: Incomplete message\n", 1, 26, p_g5);
    i_v90 = i_v57;
    goto lab_0x110e0;
lab_0x110e0:
    // 0x110e0
    close(i_v52);
    int32_t i_v91 = i_v4; // 0x110e8
    int32_t i_v92 = 1;    // 0x110f0
    free((int32_t *)*(int32_t *)(i_v91 + 8));
    int32_t i_v93 = i_v92; // 0x11100
    i_v91 += 12;
    while (i_v92 <= i_v90) {
        // 0x110ec
        i_v92 = i_v93 + 1;
        free((int32_t *)*(int32_t *)(i_v91 + 8));
        i_v93 = i_v92;
        i_v91 += 12;
    }
    // 0x10f94
    exit(1);
    // UNREACHABLE
lab_0x10fb8:
    // 0x10fb8
    fprintf(p_g5, "i2ctransfer version %s\n", "4.1");
    exit(0);
    // UNREACHABLE
lab_0x11348:
    // 0x11348
    p_v55 = (char *)&i_v3;
    int32_t i_v94 = ioctl(i_v52, 1799); // 0x11360
    if (i_v94 < 0) {
        // 0x113e0
        fprintf(p_g5, "Error: Sending messages failed: %s\n",
                strerror(*__errno_location()));
        i_v90 = i_v95;
        goto lab_0x110e0;
    } else {
        if (i_v95 > i_v94) {
            // 0x11374
            fprintf(p_g5, "Warning: only %d/%d messages were sent\n", i_v94,
                    i_v95);
            // 0x11394
            function_10b30(&i_v3, i_v94, i_v11 == 0 ? 2 : 14);
            goto lab_0x113ac;
        } else {
            // 0x11394
            function_10b30(&i_v3, i_v94, i_v11 == 0 ? 2 : 14);
            goto lab_0x113ac;
        }
    }
lab_0x113ac:
    // 0x113ac
    close(i_v52);
    int32_t i_v96 = 0; // 0x113b8
    goto lab_0x113bc;
lab_0x113bc:;
    int32_t i_v97 = i_v96 + 1; // 0x113c4
    free((int32_t *)*(int32_t *)(i_v4 + 8 + 12 * i_v96));
    i_v96 = i_v97;
    if (i_v95 <= i_v97) {
        // 0x113d8
        exit(0);
        // UNREACHABLE
    }
    goto lab_0x113bc;
}

// Address range: 0x114a4 - 0x114c8
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x114a4
    int32_t i_v1; // 0x114a4
    __libc_start_main(0x10c74, i_a2, (char **)&i_v1, (void (*)())0x12061,
                      (void (*)())0x10c74, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x114c8 - 0x114cc
int32_t function_114c8(void) {
    // 0x114c8
    return 161;
}

// Address range: 0x114d4 - 0x114f0
int32_t function_114d4(void) {
    // 0x114d4
    if (i_g4 == 0) {
        int32_t i_v1; // 0x114d4
        return i_v1;
    }
    // 0x114ec
    __gmon_start__();
    return &i_g9;
}

// Address range: 0x114f8 - 0x11516
int32_t function_114f8(void) {
    // 0x114f8
    return 0x22b8c;
}

// Address range: 0x1151c - 0x11548
int32_t function_1151c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x1151c
    int32_t i_v1; // 0x1151c
    int32_t i_v2 = i_v1;
    bool i_v3; // 0x1151c
    if (!i_v3) {
        return i_a1;
    }
    if (i_v3) {
        return unknown_22c0();
    }
    bool i_v4; // 0x1151c
    if (!i_v3) {
        int32_t i_v5 = (i_v2 << i_v1) + i_v2;       // 0x1152c
        int32_t i_v6 = i_v5 & -1 - 0x400000 * i_v5; // 0x11530
        i_v4 = i_v6 < 0;
        if (i_v6 == 0) {
            return unknown_240((int32_t)&i_g9);
        }
    }
    // 0x11540
    if (i_v4 != i_v3) {
        __asm_svclt(0x4770);
    }
    return i_a1;
}

// Address range: 0x11548 - 0x11560
int32_t function_11548(void) {
    // 0x11548
    int32_t i_v1; // 0x11548
    if (*(char *)&p_g7 == 0) {
        int32_t i_v2 = function_114f8(); // 0x11556
        *(char *)&p_g7 = 1;
        i_v1 = i_v2;
    }
    // 0x1155e
    return i_v1;
}

// Address range: 0x11560 - 0x11564
int32_t function_11560(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x11560
    return i_a1;
}

// Address range: 0x11566 - 0x11572
int32_t function_11566(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11566
    bool i_v1; // 0x11566
    if (i_v1) {
        return i_a1;
    }
    int32_t i_v2 = i_a1; // 0x1156a
    int32_t i_v3;        // 0x11566
    int16_t i_v4 = i_v3; // 0x1156a
    if (i_v1) {
        *(int16_t *)i_v3 = i_v4;
    }
    return i_v2;
}

// Address range: 0x11572 - 0x11574
int32_t function_11572(void) {
    // 0x11572
    int32_t i_v1; // 0x11572
    return function_1151c(i_v1, i_v1, i_v1, i_v1);
}

// Address range: 0x11574 - 0x11580
int32_t function_11574(int32_t i_a1) {
    // 0x11574
    bool i_v1; // 0x11574
    if (i_v1) {
        return unknown_240(i_a1);
    }
    // 0x1157c
    return i_a1;
}

// Address range: 0x11580 - 0x11584
int32_t function_11580(void) {
    // 0x11580
    int32_t i_v1; // 0x11580
    return i_v1;
}

// Address range: 0x11584 - 0x115e0
int32_t function_11584(int32_t i_a1) {
    int32_t i_v1 = strlen((char *)i_a1); // 0x1158c
    int32_t i_v2 = i_v1 - 1;
    if (i_v2 < 0) {
        // 0x115d8
        return i_v2 + 2;
    }
    int32_t i_v3 = i_v2 + i_a1;
    char *p_v4 = (char *)i_v3;
    int32_t i_v5 = i_v2; // 0x11584
    int32_t i_v6;        // 0x11584
    int32_t i_v7;        // 0x11584
    switch (*p_v4) {
    case 32: {
    }
    case 10: {
        // 0x115ac
        *p_v4 = 0;
        if (i_v2 == 0) {
            // 0x115d8
            return 1;
        }
        // 0x115b8
        i_v6 = i_v3;
        i_v7 = i_v1 - 2;
        // break -> 0x115b8
        break;
    }
    default: {
        // 0x115d8
        return i_v5 + 2;
    }
    }
    int32_t i_v8; // 0x11584
    int32_t i_v9; // 0x115cc
    char *p_v10;  // 0x11584
    while (true) {
    lab_0x115b8:
        // 0x115b8
        i_v8 = i_v7;
        i_v9 = i_v6 - 1;
        p_v10 = (char *)i_v9;
        i_v5 = i_v8;
        switch (*p_v10) {
        case 32: {
            goto lab_0x115c8;
        }
        case 10: {
            goto lab_0x115c8;
        }
        default: {
            return i_v5 + 2;
        }
        }
    }
    // 0x115d8
    return i_v5 + 2;
lab_0x115c8:
    // 0x115c8
    *p_v10 = 0;
    i_v6 = i_v9;
    i_v7 = i_v8 - 1;
    i_v5 = -1;
    if (i_v8 == 0) {
        return i_v5 + 2;
    }
    goto lab_0x115b8;
}

// Address range: 0x115e0 - 0x11618
int32_t function_115e0(int32_t i_a1) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 4); // 0x115e8
    int32_t i_v2 = i_a1;                   // 0x115f4
    if (i_v1 == 0) {
        // 0x1160c
        free((int32_t *)i_a1);
        return &i_g9;
    }
    free((int32_t *)i_v1);
    int32_t i_v3 = *(int32_t *)(i_v2 + 20); // 0x11600
    i_v2 += 16;
    while (i_v3 != 0) {
        // 0x115f8
        free((int32_t *)i_v3);
        i_v3 = *(int32_t *)(i_v2 + 20);
        i_v2 += 16;
    }
    // 0x1160c
    free((int32_t *)i_a1);
    return &i_g9;
}

// Address range: 0x11618 - 0x11660
int32_t function_11618(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 16 * i_a2;                             // 0x11618
    int32_t *p_v2 = realloc((int32_t *)i_a1, i_v1 + 128); // 0x1162c
    int32_t i_v3 = (int32_t)p_v2;                         // 0x1162c
    if (p_v2 == NULL) {
        // 0x11654
        function_115e0(i_a1);
    } else {
        // 0x11638
        memset((int32_t *)(i_v1 + i_v3), 0, 128);
    }
    // 0x1164c
    return i_v3;
}

// Address range: 0x11660 - 0x11718
int32_t function_11660(int32_t i_a1, int32_t i_a2) {
    // 0x11660
    char *p_v1;                                    // bp-20, 0x11660
    int32_t i_v2 = strtol((char *)i_a1, &p_v1, 0); // 0x11678
    if ((char)i_v2 == 0 | *p_v1 != 0) {
        // 0x116d0
        fwrite((int32_t *)"Error: Chip address is not a number!\n", 1, 37,
               p_g5);
        // 0x116c8
        return -1;
    }
    int32_t i_v3 = i_a2 == 0 ? 119 : 127;
    int32_t i_v4 = i_a2 == 0 ? 3 : 0;
    int32_t i_v5 = i_v2; // 0x116c4
    if (i_v2 > i_v3 || i_v2 < i_v4) {
        // 0x116f8
        fprintf(p_g5, "Error: Chip address out of range (0x%02lx-0x%02lx)!\n",
                i_v4, i_v3);
        i_v5 = -2;
    }
    // 0x116c8
    return i_v5;
}

// Address range: 0x11718 - 0x11854
int32_t function_11718(int32_t i_a1, int32_t *p_a2, int32_t i_a3,
                       int32_t i_a4) {
    // 0x11718
    snprintf((char *)p_a2, i_a3, "/dev/i2c/%d", i_a1);
    *(char *)(i_a3 - 1 + (int32_t)p_a2) = 0;
    int32_t i_v1 = open64((char *)p_a2, 2); // 0x1175c
    if (i_v1 >= 0) {
        // 0x11768
        return i_v1;
    }
    int32_t i_v2 = *__errno_location(); // 0x11778
    int32_t i_v3 = i_v1;                // 0x11718
    switch (i_v2) {
    case 20: {
    }
    case 2: {
        // 0x117f4
        sprintf((char *)p_a2, "/dev/i2c-%d", i_a1);
        i_v3 = open64((char *)p_a2, 2);
        // break -> 0x11768
        break;
    }
    }
    // 0x11768
    return i_v3;
}

// Address range: 0x11854 - 0x11df8
int32_t function_11854(void) {
    // 0x11854
    int32_t i_v1; // 0x11854
    uint32_t i_v2 = i_v1;
    int32_t *p_v3 = calloc(8, 16); // 0x11864
    int32_t i_v4 = (int32_t)p_v3;  // 0x11864
    if (p_v3 == NULL) {
        // 0x119d0
        return i_v4;
    }
    struct _IO_FILE *p_v5 = fopen64("/proc/bus/i2c", "r"); // 0x11880
    struct dirent64 *p_v6;                                 // 0x11854
    int32_t i_v7;                                          // 0x11854
    int32_t i_v8;                                          // 0x11854
    int32_t i_v9;                                          // 0x11854
    int32_t i_v10;                                         // 0x11854
    int32_t i_v11;                                         // bp-296, 0x11854
    int32_t i_v12;                                         // bp-552, 0x11854
    struct __dirstream *p_v13;                             // 0x11aa0
    if (p_v5 == NULL) {
        struct _IO_FILE *p_v14 = fopen64("/proc/mounts", "r"); // 0x119e8
        if (p_v14 == NULL) {
            // 0x119d0
            return i_v4;
        }
        while (fgets((char *)&i_v11, 255, p_v14) != NULL) {
            // 0x119f8
            int32_t i_v15; // bp-808, 0x11854
            sscanf((char *)&i_v11, "%*[^ ] %[^ ] %[^ ] %*s\n", &i_v12, &i_v15);
            if (strcasecmp((char *)&i_v15, "sysfs") == 0) {
                // 0x11a50
                fclose(p_v14);
                int32_t i_v16 =
                    strlen((char *)&i_v12) + (int32_t)&i_v12; // 0x11a74
                *(int32_t *)i_v16 = 0x616c632f;
                *(int32_t *)(i_v16 + 4) = 0x692f7373;
                *(int32_t *)(i_v16 + 8) = 0x642d6332;
                *(int16_t *)(i_v16 + 12) = 0x7665;
                *(char *)(i_v16 + 14) = 0;
                p_v13 = opendir((char *)&i_v12);
                i_v9 = i_v4;
                if (p_v13 == NULL) {
                    return i_v9;
                } else {
                    struct dirent64 *p_v17 = readdir64(p_v13); // 0x11ab0
                    i_v8 = i_v4;
                    if (p_v17 == NULL) {
                        goto lab_0x11bf4;
                    } else {
                        // 0x11abc
                        p_v6 = p_v17;
                        i_v7 = i_v4;
                        i_v10 = 0;
                        goto lab_0x11abc_2;
                    }
                }
            }
        }
        // 0x11a40
        fclose(p_v14);
        // 0x119d0
        return i_v4;
    }
    // 0x11988
    int32_t i_v18;                                  // bp-928, 0x11854
    char *p_v19 = fgets((char *)&i_v18, 120, p_v5); // 0x11998
    int32_t i_v20 = 1;                              // 0x119ac
    int32_t i_v21 = i_v4;                           // 0x119ac
    int32_t i_v22 = 0;                              // 0x119ac
    if (p_v19 == NULL) {
        // 0x119b0
        fclose(p_v5);
        return i_v4;
    }
    int32_t i_v23; // 0x11854
    while (true) {
        int32_t i_v24 = i_v21;
        uint32_t i_v25 = i_v20;
        char *p_v26 = strrchr((char *)&i_v18, 9); // 0x118a0
        int32_t i_v27 = (int32_t)p_v26 + 1;       // 0x118a4
        *p_v26 = 0;
        int32_t i_v28 = function_11584(i_v27);    // 0x118b0
        char *p_v29 = strrchr((char *)&i_v18, 9); // 0x118c0
        int32_t i_v30 = (int32_t)p_v29 + 1;       // 0x118c4
        *p_v29 = 0;
        int32_t i_v31 = function_11584(i_v30);    // 0x118d0
        char *p_v32 = strrchr((char *)&i_v18, 9); // 0x118e0
        int32_t i_v33 = (int32_t)p_v32 + 1;       // 0x118e4
        *p_v32 = 0;
        int32_t i_v34 = function_11584(i_v33); // 0x118f4
        sscanf((char *)&i_v18, "i2c-%d", &i_v11);
        int32_t i_v35 = i_v24; // 0x11920
        if (i_v25 % 8 == 0) {
            // 0x11924
            i_v35 = function_11618(i_v24, i_v25);
            i_v9 = 0;
            if (i_v35 == 0) {
                // break -> 0x119d0
                break;
            }
        }
        int32_t i_v36 = i_v34 + i_v31; // 0x11904
        i_v21 = i_v35;
        int32_t *p_v37 = malloc(i_v36 + i_v28); // 0x11940
        i_v23 = i_v21;
        if (p_v37 == NULL) {
            goto lab_0x119c4;
        }
        int32_t i_v38 = i_v21 + i_v22;  // 0x11934
        int32_t i_v39 = (int32_t)p_v37; // 0x11940
        *(int32_t *)i_v38 = i_v11;
        char *p_v40 = strcpy((char *)p_v37, (char *)i_v30); // 0x1195c
        *(int32_t *)(i_v38 + 4) = (int32_t)p_v40;
        char *p_v41 = strcpy((char *)(i_v31 + i_v39), (char *)i_v33); // 0x1196c
        *(int32_t *)(i_v38 + 8) = (int32_t)p_v41;
        char *p_v42 = strcpy((char *)(i_v36 + i_v39), (char *)i_v27); // 0x11980
        *(int32_t *)(i_v38 + 12) = (int32_t)p_v42;
        char *p_v43 = fgets((char *)&i_v18, 120, p_v5); // 0x11998
        i_v20 = i_v25 + 1;
        i_v22 += 16;
        int32_t i_v44 = i_v21; // 0x119ac
        if (p_v43 == NULL) {
            // 0x119b0
            fclose(p_v5);
            return i_v44;
        }
    }
lab_0x119d0:
    // 0x119d0
    return i_v9;
lab_0x119c4:
    // 0x119c4
    function_115e0(i_v23);
    i_v9 = 0;
    return i_v9;
lab_0x11bf4:
    // 0x11bf4
    closedir(p_v13);
    i_v9 = i_v8;
    goto lab_0x119d0;
lab_0x11abc_2:;
    struct dirent64 *p_v45 = p_v6; // 0x11854
    int32_t i_v46 = i_v10;         // 0x11854
    int32_t i_v47 = i_v7;          // 0x11854
    goto lab_0x11abc_3;
lab_0x11abc_3:;
    int32_t i_v48 = i_v47;
    int32_t i_v49 = i_v46;
    int32_t i_v50 = (int32_t)p_v45;
    char *p_v51 = (char *)(i_v50 + 19); // 0x11abc
    if (*p_v51 == 46) {
        // 0x11c04
        switch (*(char *)(i_v50 + 20)) {
        case 0: {
            goto lab_0x11aac_2;
        }
        case 46: {
            // 0x11c18
            if (*(char *)(i_v50 + 21) == 0) {
                goto lab_0x11aac_2;
            } else {
                goto lab_0x11ac8;
            }
        }
        default: {
            goto lab_0x11ac8;
        }
        }
    } else {
        goto lab_0x11ac8;
    }
lab_0x11ac8:;
    // 0x11ac8
    struct dirent64 *p_v52;    // 0x11854
    struct _IO_FILE *p_v53;    // 0x11854
    struct __dirstream *p_v54; // 0x11cac
    if (snprintf((char *)&i_v11, 255, "%s/%s/name", &i_v12, p_v51) > 254) {
        // 0x11c28
        fprintf(p_g5, "%s: path truncated\n", &i_v11);
        goto lab_0x11aac_2;
    } else {
        struct _IO_FILE *p_v55 = fopen64((char *)&i_v11, "r"); // 0x11afc
        p_v53 = p_v55;
        if (p_v55 == NULL) {
            int32_t i_v56 = snprintf((char *)&i_v11, 255, "%s/%s/device/name",
                                     &i_v12, p_v51); // 0x11c60
            if (i_v56 > 254) {
                // 0x11c28
                fprintf(p_g5, "%s: path truncated\n", &i_v11);
                goto lab_0x11aac_2;
            } else {
                struct _IO_FILE *p_v57 =
                    fopen64((char *)&i_v11, "r"); // 0x11c78
                p_v53 = p_v57;
                if (p_v57 == NULL) {
                    // 0x11c84
                    if (snprintf((char *)&i_v11, 255, "%s/%s/device", &i_v12,
                                 p_v51) > 254) {
                        // 0x11c28
                        fprintf(p_g5, "%s: path truncated\n", &i_v11);
                        goto lab_0x11aac_2;
                    } else {
                        // 0x11ca8
                        p_v54 = opendir((char *)&i_v11);
                        if (p_v54 == NULL) {
                            goto lab_0x11aac_2;
                        } else {
                            struct dirent64 *p_v58 =
                                readdir64(p_v54); // 0x11cbc
                            p_v52 = p_v58;
                            if (p_v58 == NULL) {
                                goto lab_0x11aac_2;
                            } else {
                                goto lab_0x11cd8;
                            }
                        }
                    }
                } else {
                    goto lab_0x11b08;
                }
            }
        } else {
            goto lab_0x11b08;
        }
    }
lab_0x11aac_2:;
    struct dirent64 *p_v59 = readdir64(p_v13); // 0x11ab0
    p_v6 = p_v59;
    i_v7 = i_v48;
    i_v10 = i_v49;
    i_v8 = i_v48;
    if (p_v59 == NULL) {
        goto lab_0x11bf4;
    } else {
        goto lab_0x11abc_2;
    }
lab_0x11b08:;
    char *p_v60 = fgets((char *)&i_v18, 120, p_v53); // 0x11b18
    fclose(p_v53);
    if (p_v60 == NULL) {
        // 0x11dd8
        fprintf(p_g5, "%s: read error\n", &i_v11);
        goto lab_0x11aac_2;
    } else {
        char *p_v61 = strchr((char *)&i_v18, 10); // 0x11b38
        if (p_v61 == NULL) {
            goto lab_dec_label_pc_0x11b58;
        } else {
            *p_v61 = 0;
            goto lab_dec_label_pc_0x11b58;
        }
    }
lab_dec_label_pc_0x11b58:;
    int32_t i_v62; // 0x11854
    int32_t i_v63; // bp-956, 0x11854
    if (sscanf(p_v51, "i2c-%d", &i_v63) == 0) {
        goto lab_0x11aac_2;
    } else {
        int32_t i_v64 = strncmp((char *)&i_v18, "ISA ", 4); // 0x11b74
        i_v62 = 8;
        if (i_v64 == 0) {
            goto lab_0x11b84;
        } else {
            // 0x11d68
            int32_t i_v65; // bp-948, 0x11854
            int32_t i_v66 = function_11718(i_v63, &i_v65, 20, 1); // 0x11d78
            i_v62 = 32;
            if (i_v66 >= 0) {
                int32_t i_v67 =
                    ioctl(i_v66, 1797) >= 0
                        ? i_v2 % 2 == 0 ? (i_v2 & 0x7e0000) == 0 ? 0 : 24 : 16
                        : 32;
                close(i_v66);
                i_v62 = i_v67;
                goto lab_0x11b84;
            } else {
                goto lab_0x11b84;
            }
        }
    }
lab_0x11b84:;
    int32_t i_v68 = i_v49 + 1; // 0x11b84
    int32_t i_v69 = i_v48;     // 0x11b8c
    if (i_v68 % 8 == 0) {
        int32_t i_v70 = function_11618(i_v48, i_v68); // 0x11b98
        i_v9 = 0;
        i_v69 = i_v70;
        if (i_v70 == 0) {
            goto lab_0x119d0;
        } else {
            goto lab_0x11ba4;
        }
    } else {
        goto lab_0x11ba4;
    }
lab_0x11cd8:;
    int32_t i_v71 = (int32_t)p_v52;
    char *p_v72 = (char *)(i_v71 + 19); // 0x11cd8
    if (*p_v72 == 46) {
        // 0x11d44
        switch (*(char *)(i_v71 + 20)) {
        case 0: {
            goto lab_0x11cb8_2;
        }
        case 46: {
            // 0x11d58
            if (*(char *)(i_v71 + 21) == 0) {
                goto lab_0x11cb8_2;
            } else {
                goto lab_0x11ce8;
            }
        }
        default: {
            goto lab_0x11ce8;
        }
        }
    } else {
        goto lab_0x11ce8;
    }
lab_0x11ba4:;
    int32_t i_v73 = i_v69 + 16 * i_v49; // 0x11bac
    *(int32_t *)i_v73 = i_v63;
    char *p_v74 = __strdup((char *)&i_v18); // 0x11bb4
    *(int32_t *)(i_v73 + 4) = (int32_t)p_v74;
    i_v23 = i_v69;
    if (p_v74 == NULL) {
        goto lab_0x119c4;
    } else {
        int32_t i_v75 = *(int32_t *)(i_v62 + (int32_t)&x_g1);     // 0x11bd4
        int32_t i_v76 = *(int32_t *)(i_v62 + (int32_t)&x_g1 + 4); // 0x11bdc
        *(int32_t *)(i_v73 + 8) = i_v75;
        *(int32_t *)(i_v73 + 12) = i_v76;
        struct dirent64 *p_v77 = readdir64(p_v13); // 0x11be8
        p_v45 = p_v77;
        i_v46 = i_v68;
        i_v47 = i_v69;
        i_v8 = i_v69;
        if (p_v77 == NULL) {
            goto lab_0x11bf4;
        } else {
            goto lab_0x11abc_3;
        }
    }
lab_0x11ce8:
    // 0x11ce8
    if (strncmp(p_v72, "i2c-", 4) == 0) {
        int32_t i_v78 = snprintf((char *)&i_v11, 255, "%s/%s/device/%s/name",
                                 &i_v12, p_v51, p_v72); // 0x11d0c
        if (i_v78 < 255) {
            struct _IO_FILE *p_v79 = fopen64((char *)&i_v11, "r"); // 0x11dc8
            p_v53 = p_v79;
            if (p_v79 == NULL) {
                goto lab_0x11cb8_2;
            } else {
                goto lab_0x11b08;
            }
        } else {
            // 0x11d30
            fprintf(p_g5, "%s: path truncated\n", &i_v11);
            goto lab_0x11cb8_2;
        }
    } else {
        goto lab_0x11cb8_2;
    }
lab_0x11cb8_2:;
    struct dirent64 *p_v80 = readdir64(p_v54); // 0x11cbc
    p_v52 = p_v80;
    if (p_v80 == NULL) {
        goto lab_0x11aac_2;
    } else {
        goto lab_0x11cd8;
    }
}

// Address range: 0x11df8 - 0x11f44
int32_t function_11df8(int32_t i_a1) {
    char *p_v1 = (char *)i_a1;              // 0x11e0c
    char *p_v2;                             // bp-28, 0x11df8
    int32_t i_v3 = strtoul(p_v1, &p_v2, 0); // 0x11e0c
    if (!(((char)i_v3 == 0 | *p_v2 != 0))) {
        int32_t i_v4 = i_v3; // 0x11e30
        if (i_v3 >= 0x100000) {
            // 0x11ef4
            fwrite((int32_t *)"Error: I2C bus out of range!\n", 1, 29, p_g5);
            i_v4 = -2;
        }
        // 0x11e34
        return i_v4;
    }
    int32_t i_v5 = function_11854(); // 0x11e3c
    if (i_v5 == 0) {
        // 0x11f1c
        fwrite((int32_t *)"Error: Out of memory!\n", 1, 22, p_g5);
        // 0x11e34
        return -3;
    }
    int32_t i_v6 = *(int32_t *)(i_v5 + 4); // 0x11e48
    int32_t i_v7 = i_v6;                   // 0x11e58
    int32_t i_v8 = i_v5;                   // 0x11e58
    int32_t i_v9 = -1;                     // 0x11e58
    if (i_v6 == 0) {
        goto lab_0x11ecc;
    lab_0x11ecc:
        // 0x11ecc
        fwrite(
            (int32_t *)"Error: I2C bus name doesn't match any bus present!\n",
            1, 51, p_g5);
        // 0x11e90
        function_115e0(i_v5);
        return -1;
    }
    while (true) {
        int32_t i_v10 = i_v9;
        int32_t i_v11 = i_v8;
        int32_t i_v12 = i_v10; // 0x11e68
        if (strcmp((char *)i_v7, p_v1) == 0) {
            if (i_v10 >= 0) {
                // break -> 0x11ea4
                break;
            }
            // 0x11e74
            i_v12 = *(int32_t *)i_v11;
        }
        // 0x11e78
        i_v9 = i_v12;
        i_v7 = *(int32_t *)(i_v11 + 20);
        i_v8 = i_v11 + 16;
        if (i_v7 == 0) {
            // 0x11e88
            if (i_v9 == -1) {
                goto lab_0x11ecc;
            } else {
                goto lab_0x11e90;
            }
        }
    }
    // 0x11ea4
    fwrite((int32_t *)"Error: I2C bus name is not unique!\n", 1, 35, p_g5);
    i_v9 = -4;
lab_0x11e90:
    // 0x11e90
    function_115e0(i_v5);
    return i_v9;
}

// Address range: 0x11f44 - 0x11fb8
int32_t function_11f44(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x11f44
    if (ioctl(i_a1, i_a3 == 0 ? 1795 : 1798) >= 0) {
        // 0x11f70
        return 0;
    }
    int32_t *p_v1 = __errno_location(); // 0x11f84
    fprintf(p_g5, "Error: Could not set address to 0x%02x: %s\n", i_a2,
            strerror(*p_v1));
    return -*p_v1;
}

// Address range: 0x11fb8 - 0x12060
int32_t function_11fb8(int32_t i_a1) {
    // 0x11fb8
    int32_t i_v1; // bp-20, 0x11fb8
    if (fgets((char *)&i_v1, 2, p_g6) == NULL) {
        // 0x12030
        return 0;
    }
    uint32_t i_v2 = i_v1;       // 0x11fe4
    uint32_t i_v3 = i_v2 % 256; // 0x11fe4
    int32_t i_v4;               // 0x11fb8
    int32_t i_v5;               // 0x11fb8
    if (i_v3 == 89) {
        // 0x1204c
        i_v5 = 1;
        goto lab_0x1201c;
    } else {
        char i_v6 = i_v2;
        if (i_v3 < 89) {
            // 0x1203c
            i_v5 = i_a1;
            i_v4 = i_a1;
            switch (i_v6) {
            case 78: {
                // 0x12044
                i_v5 = 0;
                goto lab_0x1201c;
            }
            case 10: {
                return i_v4;
            }
            default: {
                goto lab_0x1201c;
            }
            }
        } else {
            // 0x11ff4
            i_v5 = i_a1;
            i_v4 = i_a1;
            switch (i_v6) {
            case 110: {
                // 0x12044
                i_v5 = 0;
                goto lab_0x1201c;
            }
            case 121: {
                // 0x1204c
                i_v5 = 1;
                goto lab_0x1201c;
            }
            case 10: {
                return i_v4;
            }
            default: {
                goto lab_0x1201c;
            }
            }
        }
    }
lab_0x1201c:
    // 0x1201c
    while (true) {
        uint32_t i_v7 = fgetc(p_g6); // 0x12020
        i_v4 = 0;
        if (i_v7 == -1) {
            // break -> 0x12030
            break;
        }
        // 0x12010
        i_v1 = 0x1000000 * i_v7 / 0x1000000;
        i_v4 = i_v5;
        if (i_v7 % 256 == 10) {
            // break -> 0x12030
            break;
        }
    }
    // 0x12030
    return i_v4;
}

// Address range: 0x12060 - 0x12098
int32_t function_12060(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_10948(i_a1, i_a2, i_a3, i_a4); // 0x12072
    return (int32_t)&i_g2 - 0x167e8 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x120a4 - 0x120ac
int32_t function_120a4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x120a4
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 63
