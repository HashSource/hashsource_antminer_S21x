//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_106f4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
void function_10714(void);
int32_t function_10720(int32_t i_a1);
int32_t function_1072c(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
void function_10738(void);
int32_t function_10744(struct _IO_FILE *stream);
int32_t *function_10750(int32_t *s, int32_t c, int32_t n);
int32_t function_1075c(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6);
int32_t function_10768(struct _IO_FILE *stream, int32_t off, int32_t whence);
int32_t function_10774(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10780(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4);
int32_t function_1078c(char *s);
int32_t *function_10798(int32_t *dest, int32_t *src, int32_t n);
struct _IO_FILE *function_107a4(char *filename, char *modes);
int32_t function_107b0(int32_t i_a1, int32_t i_a2);
char *function_107bc(char *dest, char *src);
int32_t function_107c8(char *format, ...);
int32_t function_107d4(int32_t i_a1, int32_t i_a2);
int32_t function_107e0(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
int32_t function_107ec(int32_t ver, char *filename, struct stat64 *stat_buf);
int32_t function_107fc(char *s);
int32_t function_10808(int32_t i_a1);
int32_t function_10814(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4);
int32_t function_10820(int32_t i_a1);
int32_t function_1082c(int32_t *p_a1);
int32_t function_10838(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *stream);
int32_t function_10868(int32_t i_a1);
int32_t function_10874(void);
int32_t function_10898(void);
int32_t function_108bc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_108e8(void);
int32_t function_10900(void);
int32_t function_10906(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10912(void);
int32_t function_10914(int32_t i_a1);
int32_t function_10920(void);
int32_t function_10924(int32_t i_a1);
int32_t function_109d0(int32_t *p_a1);
int32_t function_10bb4(void);
int32_t function_10c88(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_10e00(int32_t i_a1, uint32_t i_a2, int32_t i_a3, uint32_t i_a4,
                       uint32_t i_a5, uint32_t i_a6);
int32_t function_114a8(int32_t i_a1);
int32_t function_114dc(int32_t i_a1);
int32_t function_11514(uint32_t i_a1, int32_t i_a2);
int32_t function_11558(int64_t i_a1, int32_t i_a2, uint32_t i_a3);
int32_t function_115c4(int64_t i_a1, int32_t i_a2, int64_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6);
int32_t function_116d8(int32_t i_a1, uint32_t i_a2);
int32_t function_119fc(int32_t i_a1, int32_t i_a2);
int32_t function_11bd4(int32_t i_a1, int32_t i_a2);
int32_t function_11f3c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5);
int32_t function_12020(int32_t *p_a1, int32_t i_a2, int64_t i_a3, int32_t i_a4,
                       int32_t i_a5);
int32_t function_120c4(int32_t i_a1, uint32_t i_a2);
int32_t function_12910(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4, uint32_t i_a5, uint32_t i_a6,
                       uint32_t i_a7);
int32_t function_1348c(uint32_t i_a1, int32_t i_a2);
int32_t function_13870(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_138b4(int32_t i_a1, int32_t *p_a2);
int32_t function_138b8(void);
int32_t function_138c0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_22c0(void);
int32_t unknown_240(int32_t i_a1);

// --------------------- Global Variables ---------------------

int32_t i_g1 = -0x1cae0000; // 0x10884
int32_t i_g2 = 0x108e9;     // 0x24098
int32_t i_g3 = 256;         // 0x2420c
char *p_g4;                 // 0x249c8
uint32_t i_g5;
int32_t i_g6;
int32_t i_g7;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
int32_t __xstat64(int32_t i_a1, char *p_a2, struct stat64 *p_a3);
int32_t BIO_free(int32_t i_a1);
int32_t BIO_new_mem_buf(int32_t i_a1, int32_t i_a2);
int32_t ERR_error_string(int32_t i_a1, int32_t i_a2);
int32_t ERR_get_error(int32_t i_a1);
struct _IO_FILE *fopen64(char *p_a1, char *p_a2);
int32_t PEM_read_bio_RSA_PUBKEY(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                int32_t i_a4);
int32_t RSA_free(int32_t i_a1);
int32_t RSA_verify(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4,
                   int32_t i_a5, int32_t i_a6);
int32_t SHA256_Final(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                     int32_t *p_a4);
int32_t SHA256_Init(int32_t *p_a1);
int32_t SHA256_Update(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);

// ------------------------ Functions -------------------------

// Address range: 0x106f4 - 0x10700
int32_t function_106f4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x106f4
    return function_10874();
}

// Address range: 0x10714 - 0x10720
void function_10714(void) {
    // 0x10714
    abort();
}

// Address range: 0x10720 - 0x1072c
int32_t function_10720(int32_t i_a1) {
    // 0x10720
    return ERR_get_error(i_a1);
}

// Address range: 0x1072c - 0x10738
int32_t function_1072c(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x1072c
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10738 - 0x10744
void function_10738(void) {
    // 0x10738
    __gmon_start__();
}

// Address range: 0x10744 - 0x10750
int32_t function_10744(struct _IO_FILE *stream) {
    // 0x10744
    return fclose(stream);
}

// Address range: 0x10750 - 0x1075c
int32_t *function_10750(int32_t *s, int32_t c, int32_t n) {
    // 0x10750
    return memset(s, c, n);
}

// Address range: 0x1075c - 0x10768
int32_t function_1075c(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6) {
    // 0x1075c
    return RSA_verify(i_a1, p_a2, i_a3, i_a4, i_a5, i_a6);
}

// Address range: 0x10768 - 0x10774
int32_t function_10768(struct _IO_FILE *stream, int32_t off, int32_t whence) {
    // 0x10768
    return fseek(stream, off, whence);
}

// Address range: 0x10774 - 0x10780
int32_t function_10774(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10774
    return PEM_read_bio_RSA_PUBKEY(i_a1, i_a2, i_a3, i_a4);
}

// Address range: 0x10780 - 0x1078c
int32_t function_10780(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4) {
    // 0x10780
    return SHA256_Final(p_a1, p_a2, p_a3, p_a4);
}

// Address range: 0x1078c - 0x10798
int32_t function_1078c(char *s) {
    // 0x1078c
    return strlen(s);
}

// Address range: 0x10798 - 0x107a4
int32_t *function_10798(int32_t *dest, int32_t *src, int32_t n) {
    // 0x10798
    return memcpy(dest, src, n);
}

// Address range: 0x107a4 - 0x107b0
struct _IO_FILE *function_107a4(char *filename, char *modes) {
    // 0x107a4
    return fopen64(filename, modes);
}

// Address range: 0x107b0 - 0x107bc
int32_t function_107b0(int32_t i_a1, int32_t i_a2) {
    // 0x107b0
    return BIO_new_mem_buf(i_a1, i_a2);
}

// Address range: 0x107bc - 0x107c8
char *function_107bc(char *dest, char *src) {
    // 0x107bc
    return strcpy(dest, src);
}

// Address range: 0x107c8 - 0x107d4
int32_t function_107c8(char *format, ...) {
    // 0x107c8
    return printf(format);
}

// Address range: 0x107d4 - 0x107e0
int32_t function_107d4(int32_t i_a1, int32_t i_a2) {
    // 0x107d4
    return ERR_error_string(i_a1, i_a2);
}

// Address range: 0x107e0 - 0x107ec
int32_t function_107e0(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x107e0
    return fwrite(ptr, size, n, s);
}

// Address range: 0x107ec - 0x107fc
int32_t function_107ec(int32_t ver, char *filename, struct stat64 *stat_buf) {
    // 0x107ec
    return __xstat64(ver, filename, stat_buf);
}

// Address range: 0x107fc - 0x10808
int32_t function_107fc(char *s) {
    // 0x107fc
    return puts(s);
}

// Address range: 0x10808 - 0x10814
int32_t function_10808(int32_t i_a1) {
    // 0x10808
    return RSA_free(i_a1);
}

// Address range: 0x10814 - 0x10820
int32_t function_10814(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    // 0x10814
    return SHA256_Update(p_a1, i_a2, i_a3, p_a4);
}

// Address range: 0x10820 - 0x1082c
int32_t function_10820(int32_t i_a1) {
    // 0x10820
    return BIO_free(i_a1);
}

// Address range: 0x1082c - 0x10838
int32_t function_1082c(int32_t *p_a1) {
    // 0x1082c
    return SHA256_Init(p_a1);
}

// Address range: 0x10838 - 0x10844
int32_t function_10838(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *stream) {
    // 0x10838
    return fread(ptr, size, n, stream);
}

// Address range: 0x10844 - 0x10868
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x10844
    int32_t i_v1; // 0x10844
    __libc_start_main(0x1348c, i_a2, (char **)&i_v1, (void (*)())0x13871,
                      (void (*)())0x1348c, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x10868 - 0x1086c
int32_t function_10868(int32_t i_a1) {
    // 0x10868
    return i_a1 - 177;
}

// Address range: 0x10874 - 0x10890
int32_t function_10874(void) {
    int32_t i_v1 =
        *(int32_t *)((int32_t)&i_g1 + (int32_t) "p} {-n} {-x} {-q}\n" +
                     112); // 0x10880
    if (i_v1 == 0) {
        int32_t i_v2; // 0x10874
        return i_v2;
    }
    // 0x1088c
    __gmon_start__();
    return &i_g7;
}

// Address range: 0x10898 - 0x108b6
int32_t function_10898(void) {
    // 0x10898
    return (int32_t)&p_g4;
}

// Address range: 0x108bc - 0x108e8
int32_t function_108bc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x108bc
    bool i_v1; // 0x108bc
    if (i_v1) {
        // 0x108c4
        return unknown_22c0();
    }
    return i_a1;
}

// Address range: 0x108e8 - 0x10900
int32_t function_108e8(void) {
    // 0x108e8
    int32_t i_v1; // 0x108e8
    if (*(char *)&p_g4 == 0) {
        int32_t i_v2 = function_10898(); // 0x108f6
        *(char *)&p_g4 = 1;
        i_v1 = i_v2;
    }
    // 0x108fe
    return i_v1;
}

// Address range: 0x10900 - 0x10904
int32_t function_10900(void) {
    // 0x10900
    int32_t i_v1; // 0x10900
    return i_v1;
}

// Address range: 0x10906 - 0x10912
int32_t function_10906(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10906
    bool i_v1; // 0x10906
    if (i_v1) {
        return i_a1;
    }
    int32_t i_v2 = i_a1; // 0x1090a
    int32_t i_v3;        // 0x10906
    int16_t i_v4 = i_v3; // 0x1090a
    if (i_v1) {
        *(int16_t *)i_v3 = i_v4;
    }
    return i_v2;
}

// Address range: 0x10912 - 0x10914
int32_t function_10912(void) {
    // 0x10912
    int32_t i_v1; // 0x10912
    return function_108bc(i_v1, i_v1, i_v1, i_v1);
}

// Address range: 0x10914 - 0x10920
int32_t function_10914(int32_t i_a1) {
    // 0x10914
    bool i_v1; // 0x10914
    if (i_v1) {
        return unknown_240(i_a1);
    }
    // 0x1091c
    return i_a1;
}

// Address range: 0x10920 - 0x10924
int32_t function_10920(void) {
    // 0x10920
    int32_t i_v1; // 0x10920
    return i_v1;
}

// Address range: 0x10924 - 0x109d0
int32_t function_10924(int32_t i_a1) {
    // 0x10924
    puts("Useage:\r");
    printf("\t%s [option] [paramaters]\n\n", (char *)i_a1);
    puts("\tOption:{-f} {-s} {-p} {-n} {-x} {-q}\n");
    puts("\t\t-f [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tOnly "
         "Check If Filename was Valided.\n");
    puts("\t\t-s [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was Valided, and Splite Bmu To \"/tmp/tmpfw/\"\n");
    puts("\t\t-p [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was Valided, and Dump BmuComments\n");
    puts("\t\t-x [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was FullSize BMU\n");
    puts("\t\t-n [nandBinFile]: \n\t\t\tSplite SigImg To Single File To "
         "\"/tmp/tmpNand/\"\n");
    puts("\t\t-q: \n\t\t\tGenerate A 256Bytes 0xff File To \"/tmp/256BFF\"\n");
    puts("\tReturns:");
    puts("\t\t0: \n\t\t\tWell Done!\n");
    return puts("\t\tOthers: \n\t\t\tSomething Wrong!\n");
}

// Address range: 0x109d0 - 0x10bb4
int32_t function_109d0(int32_t *p_a1) {
    int32_t i_v1 = 0; // bp-32788, 0x109f8
    int32_t i_v2;     // bp-32784, 0x109d0
    memset(&i_v2, 0, 0x7ffc);
    struct _IO_FILE *p_v3 = fopen64((char *)p_a1, "rb"); // 0x10a24
    int32_t i_v4 = 0;                                    // 0x10a34
    if (p_v3 == NULL) {
        // 0x10a38
        puts("Load Nand Image File Failed!");
        // 0x10ba8
        return 1;
    }
    int32_t i_v5 = 132 * i_v4;                          // 0x10a74
    int32_t *p_v6 = (int32_t *)(i_v5 + (int32_t)&i_g3); // 0x10a7c
    fread(&i_v1, *p_v6, 1, p_v3);
    char *p_v7 = (char *)(i_v5 + (int32_t)&i_g3 + 4); // 0x10ac4
    struct _IO_FILE *p_v8 = fopen64(p_v7, "wb");      // 0x10ac4
    int32_t i_v9;                                     // 0x109d0
    while (p_v8 != NULL) {
        // 0x10b24
        fwrite(&i_v1, *p_v6, 1, p_v8);
        fclose(p_v8);
        i_v4++;
        if (i_v4 >= 15) {
            // 0x10b9c
            fclose(p_v3);
            i_v9 = 0;
            return i_v9;
        }
        i_v5 = 132 * i_v4;
        p_v6 = (int32_t *)(i_v5 + (int32_t)&i_g3);
        fread(&i_v1, *p_v6, 1, p_v3);
        p_v7 = (char *)(i_v5 + (int32_t)&i_g3 + 4);
        p_v8 = fopen64(p_v7, "wb");
    }
    // 0x10ad8
    printf("Try To Write To File '%s' Failed!\n", p_v7);
    fclose(p_v3);
    i_v9 = 2;
lab_0x10ba8:
    // 0x10ba8
    return i_v9;
}

// Address range: 0x10bb4 - 0x10c88
int32_t function_10bb4(void) {
    struct _IO_FILE *p_v1 = fopen64("/tmp/256BFF", "wb"); // 0x10bd0
    if (p_v1 == NULL) {
        // 0x10be4
        puts("GenFile Failed!");
        // 0x10c7c
        return 1;
    }
    int32_t i_v2 = 0; // bp-272, 0x10bfc
    int32_t i_v3;     // bp-268, 0x10bb4
    memset(&i_v3, 0, 252);
    for (int32_t i_v4 = 0; i_v4 < 256; i_v4++) {
        // 0x10c28
        *(char *)(i_v4 + (int32_t)&i_v2) = -1;
    }
    // 0x10c54
    fwrite(&i_v2, 256, 1, p_v1);
    fclose(p_v1);
    // 0x10c7c
    return 0;
}

// Address range: 0x10c88 - 0x10e00
int32_t function_10c88(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    int32_t i_v1 = BIO_new_mem_buf((int32_t)p_a4, 1024);   // 0x10cbc
    int32_t i_v2 = PEM_read_bio_RSA_PUBKEY(i_v1, 0, 0, 0); // 0x10cd4
    if (i_v2 == 0) {
        // 0x10ce8
        printf("OpenSSL error: %s\n",
               (char *)ERR_error_string(ERR_get_error(0), 0));
        puts("Read Root PubK Failed!");
        // 0x10df4
        return 12;
    }
    // 0x10d24
    int32_t i_v3; // bp-164, 0x10c88
    SHA256_Init(&i_v3);
    SHA256_Update(&i_v3, i_a1, i_a2, &i_v3);
    int32_t i_v4; // bp-52, 0x10c88
    SHA256_Final(&i_v4, &i_v3, &i_v3, &i_v4);
    int32_t i_v5 = RSA_verify(672, &i_v4, 32, i_a3, 256, i_v2); // 0x10d78
    int32_t i_v6 = RSA_free(i_v2);                              // 0x10d9c
    if (i_v1 != 0) {
        // 0x10da0
        i_v6 = BIO_free(i_v1);
    }
    int32_t i_v7 = 0; // 0x10db0
    if (i_v5 != 1) {
        // 0x10dbc
        printf("OpenSSL error: %s\n",
               (char *)ERR_error_string(ERR_get_error(i_v6), 0));
        puts("Check miner.pem Failed!");
        i_v7 = 13;
    }
    // 0x10df4
    return i_v7;
}

// Address range: 0x10e00 - 0x114a8
int32_t function_10e00(int32_t i_a1, uint32_t i_a2, int32_t i_a3, uint32_t i_a4,
                       uint32_t i_a5, uint32_t i_a6) {
    int32_t i_v1 = 0; // bp-1044, 0x10e20
    int32_t i_v2;     // bp-1040, 0x10e00
    memset(&i_v2, 0, 1020);
    int32_t i_v3; // bp-1156, 0x10e00
    SHA256_Init(&i_v3);
    struct _IO_FILE *p_v4 = NULL; // 0x10e74
    if (i_a6 % 256 != 0) {
        char *p_v5 = (char *)0x706d742f; // bp-1316, 0x10e90
        int32_t i_v6;                    // bp-1304, 0x10e00
        memset(&i_v6, 0, 116);
        i_g5 = i_a4 % 256;
        switch ((char)i_a4) {
        case 0: {
            int32_t i_v7 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x10f0c
            *(int32_t *)i_v7 = 0x544f4f42;
            *(int32_t *)(i_v7 + 4) = 0x6e69622e;
            *(char *)(i_v7 + 8) = 0;
            // break -> 0x111cc
            break;
        }
        case 1: {
            int32_t i_v8 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x10f58
            *(int32_t *)i_v8 = 0x69766564;
            *(int32_t *)(i_v8 + 4) = 0x72746563;
            *(int32_t *)(i_v8 + 8) = 0x642e6565;
            *(int16_t *)(i_v8 + 12) = 0x6274;
            *(char *)(i_v8 + 14) = 0;
            // break -> 0x111cc
            break;
        }
        case 2: {
            int32_t i_v9 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x10fb4
            *(int32_t *)i_v9 = 0x616d4975;
            *(int16_t *)(i_v9 + 4) = 0x6567;
            *(char *)(i_v9 + 6) = 0;
            // break -> 0x111cc
            break;
        }
        case 3: {
            int32_t i_v10 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x11004
            *(int32_t *)i_v10 = 0x656e696d;
            *(int32_t *)(i_v10 + 4) = 0x2e736672;
            *(int32_t *)(i_v10 + 8) = 0x67616d69;
            *(int32_t *)(i_v10 + 12) = 0x7a672e65;
            *(char *)(i_v10 + 16) = 0;
            // break -> 0x111cc
            break;
        }
        case 4: {
            int32_t i_v11 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x11060
            *(int32_t *)i_v11 = 0x61647075;
            *(int32_t *)(i_v11 + 4) = 0x692e6574;
            *(int32_t *)(i_v11 + 8) = 0x6567616d;
            *(int32_t *)(i_v11 + 12) = 0x7a672e;
            // break -> 0x111cc
            break;
        }
        case 5: {
            int32_t i_v12 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x110b4
            *(int32_t *)i_v12 = 0x2e6c7263;
            *(int32_t *)(i_v12 + 4) = 0x2e726174;
            *(int16_t *)(i_v12 + 8) = 0x7a67;
            *(char *)(i_v12 + 10) = 0;
            // break -> 0x111cc
            break;
        }
        case 6: {
            int32_t i_v13 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x11108
            *(int32_t *)i_v13 = 0x656e696d;
            *(int32_t *)(i_v13 + 4) = 0x74622e72;
            *(int32_t *)(i_v13 + 8) = 0x61742e6d;
            *(int32_t *)(i_v13 + 12) = 0x7a672e72;
            *(char *)(i_v13 + 16) = 0;
            // break -> 0x111cc
            break;
        }
        case 7: {
            int32_t i_v14 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x11164
            *(int32_t *)i_v14 = 0x65736572;
            *(int32_t *)(i_v14 + 4) = 0x657672;
            // break -> 0x111cc
            break;
        }
        case 9: {
            int32_t i_v15 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x111a8
            *(int32_t *)i_v15 = 0x61746164;
            *(int32_t *)(i_v15 + 4) = 0x656c6966;
            *(char *)(i_v15 + 8) = 0;
            // break -> 0x111cc
            break;
        }
        default: {
            // break -> 0x111cc
            break;
        }
        }
        char *p_v16 = (char *)&p_v5;
        if (i_a5 % 256 != 0) {
            int32_t i_v17 = strlen(p_v16) + (int32_t)&p_v5; // 0x11200
            *(int32_t *)i_v17 = 0x6769732e;
            *(char *)(i_v17 + 4) = 0;
        }
        // 0x1121c
        printf("fileName:'%s', size:[%d]\r\n", &p_v5, i_a2);
        struct _IO_FILE *p_v18 = fopen64(p_v16, "wb"); // 0x11254
        p_v4 = p_v18;
        if (p_v18 == NULL) {
            // 0x11268
            printf("Create File '%s' Failed!\r\n", &p_v5);
            p_v4 = NULL;
        }
    }
    struct _IO_FILE *p_v19 = (struct _IO_FILE *)i_a1;
    int32_t i_v20 = &i_v1;
    int32_t i_v21 = i_a2; // 0x11324
    if (i_a2 >= 1024 == (i_a2 != 1024)) {
        int32_t i_v22 = 0;                            // 0x112b4
        int32_t i_v23 = fread(&i_v1, 1, 1024, p_v19); // 0x112a0
        SHA256_Update(&i_v3, i_v20, 1024, &i_v3);
        if (i_a6 % 256 != 0 && p_v4 != NULL) {
            // 0x112f8
            fwrite(&i_v1, 1, 1024, p_v4);
        }
        // 0x11314
        i_v22 += i_v23;
        int32_t i_v24 = i_a2 - i_v22; // 0x1131c
        i_v21 = i_v24;
        while (i_v24 >= 1024 == (i_v24 != 1024)) {
            // 0x11288
            i_v23 = fread(&i_v1, 1, 1024, p_v19);
            SHA256_Update(&i_v3, i_v20, 1024, &i_v3);
            if (i_a6 % 256 != 0 && p_v4 != NULL) {
                // 0x112f8
                fwrite(&i_v1, 1, 1024, p_v4);
            }
            // 0x11314
            i_v22 += i_v23;
            i_v24 = i_a2 - i_v22;
            i_v21 = i_v24;
        }
    }
    int32_t i_v25 = fread(&i_v1, 1, i_v21, p_v19); // 0x11348
    SHA256_Update(&i_v3, i_v20, i_v25, &i_v3);
    int32_t i_v26; // bp-1188, 0x10e00
    if (i_a6 % 256 == 0 || p_v4 == NULL) {
        // 0x113ac
        i_v26 = 0;
        SHA256_Final(&i_v26, &i_v3, &i_v3, &i_v26);
    } else {
        // 0x11450
        fwrite(&i_v1, 1, i_v25, p_v4);
        i_v26 = 0;
        SHA256_Final(&i_v26, &i_v3, &i_v3, &i_v26);
        fclose(p_v4);
    }
    // 0x11460
    *(int32_t *)i_a3 = i_v26;
    *(int32_t *)(i_a3 + 4) = 0;
    *(int32_t *)(i_a3 + 8) = 0;
    *(int32_t *)(i_a3 + 12) = 0;
    *(int32_t *)(i_a3 + 16) = 0;
    *(int32_t *)(i_a3 + 20) = 0;
    *(int32_t *)(i_a3 + 24) = 0;
    *(int32_t *)(i_a3 + 28) = 0;
    return 0;
}

// Address range: 0x114a8 - 0x114dc
int32_t function_114a8(int32_t i_a1) {
    // 0x114a8
    int32_t i_v1; // bp-12, 0x114a8
    memcpy(&i_v1, (int32_t *)i_a1, 4);
    return i_v1;
}

// Address range: 0x114dc - 0x11514
int32_t function_114dc(int32_t i_a1) {
    // 0x114dc
    int32_t i_v1; // bp-16, 0x114dc
    memcpy(&i_v1, (int32_t *)i_a1, 8);
    return i_v1 >> 31;
}

// Address range: 0x11514 - 0x11558
int32_t function_11514(uint32_t i_a1, int32_t i_a2) {
    // 0x11514
    return i_a1 / 0x8000 ^ (int32_t)i_a1 >> 31;
}

// Address range: 0x11558 - 0x115c4
int32_t function_11558(int64_t i_a1, int32_t i_a2, uint32_t i_a3) {
    float64_t f_v1 = __asm_vldr((int32_t)i_a1); // 0x1156c
    uint32_t i_v2 = __asm_vmov(f_v1);           // 0x11574
    float64_t f_v3;                             // 0x11558
    float64_t f_v4 =
        __asm_vshl_u64(f_v1, __asm_vmov_32(f_v3, -i_a3 % 64)); // 0x115a0
    return i_v2 >> i_a3 | i_v2 << 32 - i_a3 | i_v2 >> i_a3 - 32 |
           __asm_vmov(f_v4);
}

// Address range: 0x115c4 - 0x116d8
int32_t function_115c4(int64_t i_a1, int32_t i_a2, int64_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6) {
    int64_t i_v1 = 0x100000000 * i_a3;
    int32_t i_v2 =
        ((int32_t)(((i_v1 ^ 0x100000000 * i_a1) >> 32) / 0x100000000) * i_a5 >>
             31 ^
         (int32_t)((i_v1 >> 32) / 0x100000000)) *
        i_a5; // 0x11658
    return (i_v2 >> 31 ^ i_v2 / 0x8000) * i_a5 / 0x80000000;
}

// Address range: 0x116d8 - 0x119fc
int32_t function_116d8(int32_t i_a1, uint32_t i_a2) {
    // 0x116d8
    int32_t i_v1; // 0x116d8
    if (i_a2 != 7 && i_a2 >= 7) {
        int32_t i_v2 = 2 * i_a2 + 0x2f90404f;             // 0x11718
        int32_t i_v3 = function_114dc(i_a1) + 0x2f90404f; // 0x1173c
        int32_t i_v4 = function_114dc(i_a2 + i_a1 - 8);   // 0x1175c
        int32_t i_v5 = i_v4 >> 31;
        int32_t i_v6 = i_v3 >> 31;
        int32_t i_v7 =
            function_11558((int64_t)i_v5, i_v4, 37) * i_v2 + i_v6; // 0x117a0
        int32_t i_v8 =
            (function_11558((int64_t)i_v6, i_v3, 25) + i_v5) * i_v2; // 0x117dc
        i_v1 = function_115c4((int64_t)(i_v7 >> 31), i_v7,
                              (int64_t)(i_v8 >> 31), i_v8, i_v2 >> 31, i_v2);
        // 0x119ec
        return i_v1;
    }
    if (i_a2 != 3 && i_a2 >= 3) {
        int32_t i_v9 = 2 * i_a2 + 0x2f90404f; // 0x1183c
        uint32_t i_v10 = __asm_vmov(
            __asm_vshl_i64(__asm_vldr(function_114a8(i_a1)), 3)); // 0x11874
        int32_t i_v11 = i_v10 + i_a2;                             // 0x11878
        i_v1 = function_115c4((int64_t)i_v11, i_v10 + (int32_t)(i_v11 < i_v10),
                              (int64_t)function_114a8(i_a2 + i_a1 - 4), 0,
                              i_v9 >> 31, i_v9);
        // 0x119ec
        return i_v1;
    }
    // 0x118cc
    i_v1 = 0x2f90404f;
    if (i_a2 != 0) {
        // 0x118d8
        int32_t i_v12; // 0x116d8
        uint32_t i_v13 = 256 * (int32_t) * (char *)(i_a2 / 2 + i_a1) |
                         (uint32_t)i_v12 % 256; // 0x11920
        uint32_t i_v14 =
            4 * (int32_t) * (char *)(i_a2 + i_a1 - 1) + i_a2; // 0x11934
        i_v1 =
            0x2f90404f * function_11514(0, -0x3c5a37a4 * i_v14 + i_v14 / 2 ^
                                               -0x651e95c5 * i_v13 + i_v13 / 6);
    }
    // 0x119ec
    return i_v1;
}

// Address range: 0x119fc - 0x11bd4
int32_t function_119fc(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 2 * i_a2 + 0x2f90404f;              // 0x11a30
    int32_t i_v2 = -0x41670d8d * function_114dc(i_a1); // 0x11a60
    int32_t i_v3 = function_114dc(i_a1 + 8);           // 0x11a80
    int32_t i_v4 = i_a2 + i_a1;
    int32_t i_v5 = function_114dc(i_v4 - 8) * i_v1;        // 0x11ac0
    int32_t i_v6 = 0x2f90404f * function_114dc(i_v4 - 16); // 0x11b08
    uint32_t i_v7 = i_v2 >> 31;
    int32_t i_v8 = i_v3 >> 31;
    int32_t i_v9 = i_v7 + i_v8;                                // 0x11b24
    int32_t i_v10 = i_v2 + i_v3 + (int32_t)(i_v9 < i_v7);      // 0x11b28
    uint32_t i_v11 = function_11558((int64_t)i_v9, i_v10, 43); // 0x11b30
    int32_t i_v12 = i_v5 >> 31;
    uint32_t i_v13 =
        function_11558((int64_t)i_v12, i_v5, 30) + i_v11; // 0x11b50
    int32_t i_v14 = i_v13 + (i_v6 >> 31);                 // 0x11b5c
    int32_t i_v15 = i_v8 + 0x2f90404f;                    // 0x11b78
    int32_t i_v16 =
        i_v3 - 0x651e95c5 + (int32_t)(i_v15 < 0x2f90404f);      // 0x11b7c
    uint32_t i_v17 = function_11558((int64_t)i_v15, i_v16, 18); // 0x11b84
    uint32_t i_v18 = i_v17 + i_v7;                              // 0x11b8c
    int32_t i_v19 = i_v18 + i_v12;                              // 0x11b98
    return function_115c4((int64_t)i_v14,
                          i_v6 + i_v5 + i_v10 + (int32_t)(i_v13 < i_v11) +
                              (int32_t)(i_v14 < i_v13),
                          (int64_t)i_v19,
                          i_v5 + i_v2 + i_v16 + (int32_t)(i_v18 < i_v17) +
                              (int32_t)(i_v19 < i_v18),
                          i_v1 >> 31, i_v1);
}

// Address range: 0x11bd4 - 0x11f3c
int32_t function_11bd4(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 2 * i_a2 + 0x2f90404f;             // 0x11c08
    int32_t i_v2 = 0x2f90404f * function_114dc(i_a1); // 0x11c38
    int32_t i_v3 = function_114dc(i_a1 + 8);          // 0x11c58
    int32_t i_v4 = i_a2 + i_a1;
    int32_t i_v5 = function_114dc(i_v4 - 8) * i_v1; // 0x11c98
    int32_t i_v6 = function_114dc(i_v4 - 16);       // 0x11cc0
    uint32_t i_v7 = i_v2 >> 31;
    int32_t i_v8 = i_v3 >> 31;
    int32_t i_v9 = i_v7 + i_v8; // 0x11cfc
    int32_t i_v10 = function_11558(
        (int64_t)i_v9, i_v2 + i_v3 + (int32_t)(i_v9 < i_v7), 43); // 0x11d08
    int32_t i_v11 = i_v5 >> 31;
    int32_t i_v12 = function_11558((int64_t)i_v11, i_v5, 30) + i_v10 +
                    (0x2f90404f * i_v6 >> 31); // 0x11d34
    int32_t i_v13 = i_v8 + 0x2f90404f;         // 0x11d54
    int32_t i_v14 =
        i_v3 - 0x651e95c5 + (int32_t)(i_v13 < 0x2f90404f);      // 0x11d58
    uint32_t i_v15 = function_11558((int64_t)i_v13, i_v14, 18); // 0x11d60
    uint32_t i_v16 = i_v15 + i_v7;                              // 0x11d68
    int32_t i_v17 = i_v16 + i_v11;                              // 0x11d74
    int32_t i_v18 = i_v1 >> 31;
    int32_t i_v19 = i_v12 >> 31;
    int32_t i_v20 =
        function_115c4((int64_t)i_v19, i_v12, (int64_t)i_v17,
                       i_v5 + i_v2 + i_v14 + (int32_t)(i_v16 < i_v15) +
                           (int32_t)(i_v17 < i_v16),
                       i_v18, i_v1);                            // 0x11d90
    int32_t i_v21 = function_114dc(i_a1 + 16) * i_v1;           // 0x11dc8
    int32_t i_v22 = function_114dc(i_a1 + 24);                  // 0x11de8
    int32_t i_v23 = (function_114dc(i_v4 - 32) + i_v19) * i_v1; // 0x11e2c
    int32_t i_v24 =
        (function_114dc(i_v4 - 24) + (i_v20 >> 31)) * i_v1; // 0x11e7c
    uint32_t i_v25 = i_v21 >> 31;
    uint32_t i_v26 = i_v22 >> 31;
    int32_t i_v27 = i_v25 + i_v26;                              // 0x11e98
    int32_t i_v28 = i_v21 + i_v22 + (int32_t)(i_v27 < i_v25);   // 0x11e9c
    uint32_t i_v29 = function_11558((int64_t)i_v27, i_v28, 43); // 0x11ea4
    int32_t i_v30 = i_v23 >> 31;
    uint32_t i_v31 =
        function_11558((int64_t)i_v30, i_v23, 30) + i_v29;      // 0x11ec4
    int32_t i_v32 = i_v31 + (i_v24 >> 31);                      // 0x11ed0
    int32_t i_v33 = i_v26 + i_v7;                               // 0x11ee0
    int32_t i_v34 = i_v22 + i_v2 + (int32_t)(i_v33 < i_v26);    // 0x11ee4
    uint32_t i_v35 = function_11558((int64_t)i_v33, i_v34, 18); // 0x11eec
    uint32_t i_v36 = i_v35 + i_v25;                             // 0x11ef4
    int32_t i_v37 = i_v36 + i_v30;                              // 0x11f00
    return function_115c4((int64_t)i_v32,
                          i_v24 + i_v23 + i_v28 + (int32_t)(i_v31 < i_v29) +
                              (int32_t)(i_v32 < i_v31),
                          (int64_t)i_v37,
                          i_v23 + i_v21 + i_v34 + (int32_t)(i_v36 < i_v35) +
                              (int32_t)(i_v37 < i_v36),
                          i_v18, i_v1);
}

// Address range: 0x11f3c - 0x12020
int32_t function_11f3c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5) {
    // 0x11f3c
    int64_t i_v1;                                                // 0x11f3c
    int32_t i_v2 = (i_a3 >> 31) + (int32_t)(i_v1 / 0x100000000); // 0x11f58
    uint32_t i_v3 = (int32_t)(i_v1 / 0x100000000);               // 0x11f64
    uint32_t i_v4 = i_v2 >> 31;                                  // 0x11f68
    uint32_t i_v5 = i_v4 + i_v3;                                 // 0x11f6c
    int32_t i_v6 = i_v1;                                         // 0x11f74
    uint32_t i_v7 = (int32_t)(i_v1 / 0x100000000);               // 0x11f74
    int32_t i_v8 = i_v5 + i_v7;                                  // 0x11f78
    int32_t i_v9 =
        function_11558((int64_t)i_v8,
                       (int32_t)i_v1 + i_v6 + i_v2 + (int32_t)(i_v5 < i_v3) +
                           (int32_t)(i_v8 < i_v5),
                       21); // 0x11f84
    int32_t i_v10 = (i_v4 + (i_a5 >> 31)) / 0x80000000 +
                    (int32_t)((uint64_t)i_v1 / 0x100000000); // 0x11fb0
    int32_t i_v11 = i_v10 >> 31;                             // 0x11fc0
    int32_t i_v12 =
        (i_v9 >> 31) + function_11558((int64_t)i_v11, i_v10, 44); // 0x11fcc
    uint32_t i_v13 = i_v11 + i_v7;                                // 0x11fe0
    uint32_t i_v14 = (i_v12 >> 31) + i_v4;                        // 0x11ff4
    *(int32_t *)i_a1 = i_v13;
    *(int32_t *)(i_a1 + 4) = i_v10 + i_v6 + (int32_t)(i_v13 < i_v7);
    *(int32_t *)(i_a1 + 8) = i_v14;
    *(int32_t *)(i_a1 + 12) = i_v12 + i_v4 + (int32_t)(i_v14 < i_v4);
    return i_a1;
}

// Address range: 0x12020 - 0x120c4
int32_t function_12020(int32_t *p_a1, int32_t i_a2, int64_t i_a3, int32_t i_a4,
                       int32_t i_a5) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2 = function_114dc(i_a2);     // 0x1203c
    int32_t i_v3 = function_114dc(i_a2 + 8); // 0x12054
    function_114dc(i_a2 + 16);
    function_114dc(i_a2 + 24);
    function_11f3c(i_v1, i_a2, i_v2, i_a2, i_v3);
    return i_v1;
}

// Address range: 0x120c4 - 0x12910
int32_t function_120c4(int32_t i_a1, uint32_t i_a2) {
    // 0x120c4
    if (i_a2 >= 16 != i_a2 != 16) {
        // 0x12900
        return function_116d8(i_a1, i_a2);
    }
    if (i_a2 >= 32 != i_a2 != 32) {
        // 0x12900
        return function_119fc(i_a1, i_a2);
    }
    if (i_a2 >= 64 != i_a2 != 64) {
        // 0x12900
        return function_11bd4(i_a1, i_a2);
    }
    int32_t i_v1 =
        0x2f90404f * function_11514(0x22096bdd, -0x6e6c7826); // 0x121fc
    int64_t i_v2;                                             // 0x120c4
    __asm_vstr(__asm_vmov_i32(0), (int32_t)i_v2);
    int32_t i_v3 = i_v2;
    __asm_vstr(__asm_vmov_i32(0), i_v3);
    __asm_vstr(__asm_vmov_i32(0), (int32_t)i_v2);
    int32_t i_v4 = i_v2; // 0x1222c
    __asm_vstr(__asm_vmov_i32(0), i_v4);
    int32_t i_v5 = function_114dc(i_a1);    // 0x12268
    int32_t i_v6 = (i_a2 - 1 & -64) + i_a1; // 0x12294
    uint32_t i_v7 = (i_a2 + 63) % 64;       // 0x122a4
    uint64_t i_v8 = 0x100000000 * i_v2 >> 32;
    int32_t i_v9 = i_v8;
    uint64_t i_v10 = i_v8 / 0x100000000;
    uint32_t i_v11 = (int32_t)i_v10;
    int32_t i_v12 = 2 * i_v3;
    int32_t i_v13 = -0x4b6d4991 * i_v11 + -0x41670d8d * i_v9 +
                    (int32_t)(0xbe98f273 * i_v10 / 0x100000000);
    int64_t i_v14 = -0x41670d8d00000000 * i_v10 / 0x100000000;
    uint64_t i_v15 = 0x100000000 * i_v2 >> 32;
    int32_t i_v16 = i_v15;
    uint32_t i_v17 = (int32_t)(i_v15 / 0x100000000);
    int32_t i_v18 = i_v5 >> 31;                              // 0x122b4
    int32_t i_v19 = 0x4e64b6d4;                              // 0x122b4
    int32_t i_v20 = 0;                                       // 0x122b4
    int32_t i_v21 = i_v1 >> 31;                              // 0x122b4
    int32_t i_v22 = i_a1;                                    // 0x122b4
    uint32_t i_v23 = i_v20 + i_v18;                          // 0x122c0
    int64_t i_v24;                                           // 0x120c4
    uint64_t i_v25 = 0x100000000 * i_v24 >> 32;              // 0x122c8
    uint32_t i_v26 = i_v23 + (int32_t)(i_v25 / 0x100000000); // 0x122cc
    int32_t i_v27 = function_114dc(i_v22 + 8) + i_v26;       // 0x122ec
    int32_t i_v28 =
        function_11558((int64_t)i_v27,
                       (int32_t)(i_v26 < i_v23) + (int32_t)i_v25 +
                           2 * (i_v19 + i_v18 + (int32_t)(i_v23 < i_v18)) +
                           (int32_t)(i_v27 < i_v26),
                       37);                             // 0x122f8
    uint32_t i_v29 = i_v20 + i_v11;                     // 0x12334
    int32_t i_v30 = function_114dc(i_v22 + 48) + i_v29; // 0x12354
    int32_t i_v31 = function_11558((int64_t)i_v30,
                                   i_v19 + i_v12 + (int32_t)(i_v29 < i_v11) +
                                       (int32_t)(i_v30 < i_v29),
                                   42); // 0x12360
    int64_t i_v32;                      // bp-88, 0x120c4
    i_v19 = (-0x41670d8d * i_v31 >> 31) + function_114dc(i_v22 + 40) +
            (int32_t)((0x100000000 * i_v32 >> 32) / 0x100000000);
    int64_t i_v33;                                   // bp-104, 0x120c4
    uint64_t i_v34 = 0x100000000 * i_v33 >> 32;      // 0x123dc
    uint32_t i_v35 = (int32_t)(i_v34 / 0x100000000); // 0x123dc
    int32_t i_v36 = i_v21 + i_v35;                   // 0x123e4
    int32_t i_v37 = -0x41670d8d * function_11558((int64_t)i_v36,
                                                 i_v21 + (int32_t)i_v34 +
                                                     (int32_t)(i_v36 < i_v35),
                                                 33); // 0x12410
    i_v21 = (-0x41670d8d * i_v28 ^ i_v4) >> 31;
    function_12020((int32_t *)&i_v32, i_v22, i_v14, i_v13,
                   i_v21 +
                       (int32_t)((0x100000000 * i_v33 >> 32) / 0x100000000));
    i_v18 = i_v37 >> 31;
    int32_t i_v38 = i_v18 + i_v17;              // 0x12484
    int32_t i_v39 = function_114dc(i_v22 + 16); // 0x12498
    i_v20 = i_v19 >> 31;
    function_12020((int32_t *)&i_v33, i_v22 + 32, (int64_t)i_v38,
                   i_v37 + i_v16 + (int32_t)(i_v38 < i_v17), i_v20 + i_v39);
    i_v22 += 64;
    while (i_v22 != i_v6) {
        // 0x122b8
        i_v23 = i_v20 + i_v18;
        i_v25 = 0x100000000 * i_v32 >> 32;
        i_v26 = i_v23 + (int32_t)(i_v25 / 0x100000000);
        i_v27 = function_114dc(i_v22 + 8) + i_v26;
        i_v28 =
            function_11558((int64_t)i_v27,
                           (int32_t)(i_v26 < i_v23) + (int32_t)i_v25 +
                               2 * (i_v19 + i_v18 + (int32_t)(i_v23 < i_v18)) +
                               (int32_t)(i_v27 < i_v26),
                           37);
        i_v29 = i_v20 + i_v11;
        i_v30 = function_114dc(i_v22 + 48) + i_v29;
        i_v31 = function_11558((int64_t)i_v30,
                               i_v19 + i_v12 + (int32_t)(i_v29 < i_v11) +
                                   (int32_t)(i_v30 < i_v29),
                               42);
        i_v19 = (-0x41670d8d * i_v31 >> 31) + function_114dc(i_v22 + 40) +
                (int32_t)((0x100000000 * i_v32 >> 32) / 0x100000000);
        i_v34 = 0x100000000 * i_v33 >> 32;
        i_v35 = (int32_t)(i_v34 / 0x100000000);
        i_v36 = i_v21 + i_v35;
        i_v37 = -0x41670d8d * function_11558((int64_t)i_v36,
                                             i_v21 + (int32_t)i_v34 +
                                                 (int32_t)(i_v36 < i_v35),
                                             33);
        i_v21 = (-0x41670d8d * i_v28 ^ i_v4) >> 31;
        function_12020(
            (int32_t *)&i_v32, i_v22, i_v14, i_v13,
            i_v21 + (int32_t)((0x100000000 * i_v33 >> 32) / 0x100000000));
        i_v18 = i_v37 >> 31;
        i_v38 = i_v18 + i_v17;
        i_v39 = function_114dc(i_v22 + 16);
        i_v20 = i_v19 >> 31;
        function_12020((int32_t *)&i_v33, i_v22 + 32, (int64_t)i_v38,
                       i_v37 + i_v16 + (int32_t)(i_v38 < i_v17), i_v20 + i_v39);
        i_v22 += 64;
    }
    int32_t i_v40 = i_v7 - 63 + i_v6;                          // 0x122b0
    uint32_t i_v41 = i_v21 % 256;                              // 0x12524
    uint32_t i_v42 = 2 * i_v41;                                // 0x1252c
    uint32_t i_v43 = i_v42 - 0x41670d8d;                       // 0x1254c
    int32_t i_v44 = i_v42 < i_v41 ? -0x4b6d4990 : -0x4b6d4991; // 0x12550
    int32_t i_v45 =
        (i_v7 + (int32_t)((0x100000000 * i_v33 >> 32) / 0x100000000)) /
        0x80000000;
    int32_t i_v46 =
        i_v45 + (int32_t)((0x100000000 * i_v32 >> 32) / 0x100000000); // 0x12598
    i_v32 = i_v46;
    int32_t i_v47 = i_v46 >> 31;
    i_v33 = i_v47 + i_v45;
    uint32_t i_v48 = i_v20 + i_v18;                    // 0x125c0
    uint32_t i_v49 = i_v47 + i_v48;                    // 0x125cc
    int32_t i_v50 = i_v49 + function_114dc(i_v40 + 8); // 0x125ec
    int32_t i_v51 =
        function_11558((int64_t)i_v50,
                       i_v46 + 2 * (i_v19 + i_v18 + (int32_t)(i_v48 < i_v18)) +
                           (int32_t)(i_v49 < i_v48) + (int32_t)(i_v50 < i_v49),
                       37);                             // 0x125f8
    uint32_t i_v52 = i_v20 + i_v11;                     // 0x12638
    int32_t i_v53 = function_114dc(i_v40 + 48) + i_v52; // 0x12658
    int32_t i_v54 = function_11558((int64_t)i_v53,
                                   i_v19 + i_v12 + (int32_t)(i_v52 < i_v11) +
                                       (int32_t)(i_v53 < i_v52),
                                   42); // 0x12664
    int32_t i_v55 =
        __asm_vmov(__asm_vshl_i64(__asm_vmov_2(i_v17, i_v16), 3)); // 0x126a8
    uint64_t i_v56 = 0x100000000 * i_v32 >> 32;                    // 0x126c4
    int32_t i_v57 = i_v56 / 0x100000000;                           // 0x126c4
    int32_t i_v58 = __asm_vmov(
        __asm_vshl_i64(__asm_vmov_2(i_v57, (int32_t)i_v56), 3)); // 0x126d0
    int32_t i_v59 = i_v58 + i_v54 * i_v43 / 0x80000000 + i_v57 +
                    function_114dc(i_v40 + 40);      // 0x12700
    uint64_t i_v60 = 0x100000000 * i_v33 >> 32;      // 0x1270c
    uint32_t i_v61 = (int32_t)(i_v60 / 0x100000000); // 0x1270c
    int32_t i_v62 = i_v21 + i_v61;                   // 0x12714
    int32_t i_v63 =
        function_11558((int64_t)i_v62,
                       i_v21 + (int32_t)i_v60 + (int32_t)(i_v62 < i_v61), 33) *
        i_v43;                               // 0x12744
    uint64_t i_v64 = i_v10 * (int64_t)i_v43; // 0x12774
    int32_t i_v65 = (i_v55 + i_v17 ^ i_v51 * i_v43) / 0x80000000;
    int64_t i_v66; // bp-128, 0x120c4
    function_12020((int32_t *)&i_v66, i_v40, 0x100000000 * i_v64 / 0x100000000,
                   (i_v44 + (int32_t)(i_v43 < 0xbe98f273)) * i_v11 +
                       i_v43 * i_v9 + (int32_t)(i_v64 / 0x100000000),
                   i_v65 +
                       (int32_t)((0x100000000 * i_v33 >> 32) / 0x100000000));
    i_v32 = 0x100000000 * i_v66 >> 32;
    int32_t i_v67 = i_v63 >> 31;
    int32_t i_v68 = i_v67 + i_v17;              // 0x127c4
    int32_t i_v69 = function_114dc(i_v40 + 16); // 0x127d8
    int32_t i_v70 = i_v59 >> 31;
    function_12020((int32_t *)&i_v66, i_v40 + 32, (int64_t)i_v68,
                   i_v63 + i_v16 + (int32_t)(i_v68 < i_v17), i_v69 + i_v70);
    int64_t i_v71 = 0x100000000 * i_v66;
    int64_t i_v72 = i_v71 >> 32; // 0x1280c
    i_v33 = i_v72;
    int32_t i_v73 = i_v32; // 0x1284c
    function_115c4(0x100000000 * i_v32 >> 63, i_v73, i_v71 >> 63,
                   (int32_t)i_v72, -1, i_v43);
    uint32_t i_v74 = function_11514(i_v70, i_v59); // 0x12874
    int32_t i_v75 = i_v2;                          // 0x128b4
    int64_t i_v76 = 0x100000000 * i_v2 >> 63;      // 0x128cc
    uint32_t i_v77 =
        function_115c4(i_v76, i_v75, i_v76, i_v75, -1, i_v43); // 0x128cc
    int32_t i_v78 = i_v77 + i_v67;                             // 0x128d4
    // 0x12900
    return function_115c4(
        0,
        -0x6834ced9 * i_v59 + i_v65 + i_v73 + -0x3c5a37a4 * i_v74 + i_v74 / 2,
        (int64_t)i_v78, i_v67 + i_v75 + (int32_t)(i_v78 < i_v77), -1, i_v43);
}

// Address range: 0x12910 - 0x1348c
int32_t function_12910(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4, uint32_t i_a5, uint32_t i_a6,
                       uint32_t i_a7) {
    // 0x12910
    int32_t i_v1; // bp-200, 0x12910
    function_138b4((int32_t)p_a1, &i_v1);
    int64_t i_v2;                                  // 0x12910
    uint32_t i_v3 = (int32_t)(i_v2 / 0x100000000); // 0x12940
    if (i_v3 <= 2047) {
        // 0x12958
        printf("File '%s' Not Enough %d, Something Wrong!\n", p_a1, 2048);
        // 0x13480
        return 6;
    }
    struct _IO_FILE *p_v4 = fopen64((char *)p_a1, "rb"); // 0x12980
    if (p_v4 == NULL) {
        // 0x12994
        printf("Read File '%s' Failed!\n", p_a1);
        // 0x13480
        return 7;
    }
    // 0x129ac
    fread(p_a4, 2048, 1, p_v4);
    int32_t i_v5; // 0x12910
    if ((char)i_v5 != 38) {
        // 0x129d0
        printf("'%s' Not A Btmu File!\n", p_a1);
        fclose(p_v4);
        // 0x13480
        return 8;
    }
    int32_t i_v6 = (int32_t)p_a4;
    printf("miner_type %s\n", p_a2);
    int32_t i_v7 =
        function_120c4((int32_t)p_a2, strlen((char *)p_a2)); // 0x12a20
    int32_t i_v8 = i_v6 + 2;                                 // 0x12a2c
    int32_t i_v9;                                            // bp-208, 0x12910
    memcpy(&i_v9, (int32_t *)i_v8, 8);
    printf("miner_type_hash %16llx, bmu_hash %16llx\n", (int64_t)i_v8,
           (int64_t)i_v7);
    int32_t i_v10 = i_v9; // 0x12a58
    if (i_v7 == i_v10 != (i_v10 ^ i_v7) > -1) {
        // 0x12a6c
        puts("input miner_type and bmu miner type donot match!");
        fclose(p_v4);
        // 0x13480
        return 30;
    }
    unsigned char i_v11 = *(char *)(i_v6 + 12); // 0x12ab0
    uint16_t i_v12 =
        256 * (int16_t) * (char *)(i_v6 + 11) | (int16_t)i_v11; // 0x12ab8
    int32_t i_v13 = i_v12;
    if (i_a7 % 256 != 0) {
        // 0x12ad0
        printf("content:%x\n", i_v13);
        if (i_v12 <= 0xfdff) {
            // 0x12af4
            puts("This Package Was Not Full Package!");
            // 0x13480
            return 20;
        }
    }
    uint32_t i_v14 = i_a5 % 256;
    unsigned char i_v15 = 0;
    for (int32_t i_v16 = 0; i_v16 < 16; i_v16++) {
        // 0x12b14
        i_v15 += (char)((1 << i_v16 & i_v13) != 0);
    }
    unsigned char i_v17 = *(char *)(i_v6 + 1304); // 0x12b54
    int32_t i_v18 = i_v17;
    if (i_v15 != i_v17) {
        // 0x12b64
        printf("Content Doesn't Match![%d][%d]\n", i_v18, (int32_t)i_v15);
        fclose(p_v4);
        // 0x13480
        return 9;
    }
    int32_t i_v19 = 256 * i_v18 + 2304;           // 0x12bac
    unsigned char i_v20 = *(char *)(i_v6 + 1305); // 0x12bb8
    unsigned char i_v21 = *(char *)(i_v6 + 1306); // 0x12bc4
    unsigned char i_v22 = *(char *)(i_v6 + 1307); // 0x12bd4
    unsigned char i_v23 = *(char *)(i_v6 + 1308); // 0x12be4
    uint32_t i_v24 = (int32_t)i_v15;              // 0x12cd8
    int32_t i_v25 = 0;                            // 0x12ce4
    int32_t i_v26 = i_v19;                        // 0x12ce4
    int32_t i_v27 = i_v19;                        // 0x12ce4
    if (i_v15 != 0) {
        int32_t i_v28 = 5 * i_v25 + i_v6;              // 0x12c10
        unsigned char i_v29 = *(char *)(i_v28 + 1310); // 0x12c1c
        unsigned char i_v30 = *(char *)(i_v28 + 1311); // 0x12c44
        unsigned char i_v31 = *(char *)(i_v28 + 1312); // 0x12c70
        unsigned char i_v32 = *(char *)(i_v28 + 1313); // 0x12c9c
        int32_t i_v33 = 0x10000 * (int32_t)i_v30 | 0x1000000 * (int32_t)i_v29 |
                        256 * (int32_t)i_v31 | (int32_t)i_v32; // 0x12ca0
        i_v26 += i_v33;
        printf("file[%d] size:[%d]\n", i_v25, i_v33);
        i_v25++;
        i_v27 = i_v26;
        while (i_v25 < i_v24) {
            // 0x12bfc
            i_v28 = 5 * i_v25 + i_v6;
            i_v29 = *(char *)(i_v28 + 1310);
            i_v30 = *(char *)(i_v28 + 1311);
            i_v31 = *(char *)(i_v28 + 1312);
            i_v32 = *(char *)(i_v28 + 1313);
            i_v33 = 0x10000 * (int32_t)i_v30 | 0x1000000 * (int32_t)i_v29 |
                    256 * (int32_t)i_v31 | (int32_t)i_v32;
            i_v26 += i_v33;
            printf("file[%d] size:[%d]\n", i_v25, i_v33);
            i_v25++;
            i_v27 = i_v26;
        }
    }
    // 0x12ce8
    if (i_v27 != i_v3) {
        // 0x12cf8
        printf("Check FileSize Failed, FileSize Should Be [%d]Bytes, But It "
               "Was [%d] Bytes, And Total Says[%d]\n",
               0x10000 * (int32_t)i_v21 | 0x1000000 * (int32_t)i_v20 |
                   256 * (int32_t)i_v22 | (int32_t)i_v23,
               i_v3, i_v27);
        fclose(p_v4);
        // 0x13480
        return 10;
    }
    struct _IO_FILE *p_v34 = fopen64((char *)p_a3, "r"); // 0x12d38
    if (p_v34 == NULL) {
        // 0x12d4c
        printf("Cannot Open Root PublicKey '%s'!\n", p_a3);
        fclose(p_v4);
        // 0x13480
        return 11;
    }
    int32_t i_v35 = 0; // bp-1232, 0x12d7c
    int32_t i_v36;     // bp-1228, 0x12910
    memset(&i_v36, 0, 1020);
    fread(&i_v35, 1024, 1, p_v34);
    fclose(p_v34);
    unsigned char i_v37 = *(char *)(i_v6 + 23); // 0x12dd8
    int32_t i_v38 =
        256 * (int32_t) * (char *)(i_v6 + 22) | (int32_t)i_v37;  // 0x12ddc
    int32_t i_v39 = i_v6 + 24;                                   // 0x12de8
    int32_t i_v40 = i_v6 + 1048;                                 // 0x12df8
    int32_t i_v41 = function_10c88(i_v39, i_v38, i_v40, &i_v35); // 0x12e08
    if (i_v41 != 0) {
        // 0x12e1c
        printf("Check pem payload failed! ret:[%d]\n", i_v41);
        fclose(p_v4);
        // 0x13480
        return i_v41;
    }
    struct _IO_FILE *p_v42 = fopen64("/usr/bin/fw_version", "w"); // 0x12e58
    if (p_v42 != NULL) {
        // 0x12e6c
        fwrite((int32_t *)(i_v6 + 13), 1, 8, p_v42);
        fclose(p_v42);
    }
    if (i_v14 != 0) {
        struct _IO_FILE *p_v43 =
            fopen64("/tmp/tmpfw/miner.pem", "w"); // 0x12ea8
        if (p_v43 == NULL) {
            // 0x12f04
            puts("Dump Miner.pem Failed!\r");
            // 0x13480
            return 15;
        }
        // 0x12ebc
        fwrite((int32_t *)i_v39, 1, i_v38, p_v43);
        fclose(p_v43);
        struct _IO_FILE *p_v44 =
            fopen64("/tmp/tmpfw/miner.pem.sig", "w"); // 0x12eec
        if (p_v44 == NULL) {
            // 0x12f40
            puts("Dump Miner.pem.sig Failed!\r");
            // 0x13480
            return 16;
        }
        // 0x12f18
        fwrite((int32_t *)i_v40, 1, 256, p_v44);
        fclose(p_v44);
    }
    // 0x12f54
    int32_t i_v45; // bp-2288, 0x12910
    memset(&i_v45, 0, 1056);
    int32_t i_v46; // bp-2400, 0x12910
    SHA256_Init(&i_v46);
    SHA256_Update(&i_v46, i_v6, 2048, &i_v46);
    SHA256_Final(&i_v45, &i_v46, &i_v46, &i_v45);
    int32_t i_v47 = &i_v45;
    if (i_v15 != 0) {
        int32_t i_v48 = i_v47 + 32;    // 0x13088
        int32_t i_v49 = (int32_t)p_v4; // 0x130dc
        for (int32_t i_v50 = 0; i_v50 < i_v24; i_v50++) {
            int32_t i_v51 = 5 * i_v50 + i_v6;              // 0x12fe4
            unsigned char i_v52 = *(char *)(i_v51 + 1310); // 0x12ff0
            unsigned char i_v53 = *(char *)(i_v51 + 1311); // 0x13018
            unsigned char i_v54 = *(char *)(i_v51 + 1312); // 0x13044
            unsigned char i_v55 = *(char *)(i_v51 + 1313); // 0x13070
            unsigned char i_v56 = *(char *)(i_v51 + 1309); // 0x130bc
            function_10e00(i_v49,
                           0x10000 * (int32_t)i_v53 |
                               0x1000000 * (int32_t)i_v52 |
                               256 * (int32_t)i_v54 | (int32_t)i_v55,
                           i_v48 + 32 * i_v50, (int32_t)i_v56, 0, i_v14);
        }
        int32_t i_v57 = 0;
        int32_t i_v58 = i_v57 + 1;
        unsigned char i_v59 = *(char *)(i_v6 + 1309 + 5 * i_v57); // 0x13150
        function_10e00(i_v49, 256, 32 * (i_v58 + i_v24) + i_v47, (int32_t)i_v59,
                       1, i_v14);
        while (i_v58 < i_v24) {
            // 0x1310c
            i_v57 = i_v58;
            i_v58 = i_v57 + 1;
            i_v59 = *(char *)(i_v6 + 1309 + 5 * i_v57);
            function_10e00(i_v49, 256, 32 * (i_v58 + i_v24) + i_v47,
                           (int32_t)i_v59, 1, i_v14);
        }
    }
    int32_t i_v60 = 0; // bp-2656, 0x13198
    int32_t i_v61;     // bp-2652, 0x12910
    memset(&i_v61, 0, 252);
    fseek(p_v4, -256, SEEK_END);
    fread(&i_v60, 256, 1, p_v4);
    int32_t i_v62 = 0; // bp-2688, 0x131e8
    int32_t i_v63;     // bp-2800, 0x12910
    SHA256_Init(&i_v63);
    SHA256_Update(&i_v63, i_v47, 64 * i_v24 | 32, &i_v63);
    SHA256_Final(&i_v62, &i_v63, &i_v63, &i_v62);
    int32_t i_v64 = BIO_new_mem_buf(i_v39, 1024);            // 0x132d4
    int32_t i_v65 = PEM_read_bio_RSA_PUBKEY(i_v64, 0, 0, 0); // 0x132ec
    if (i_v65 == 0) {
        // 0x13300
        printf("OpenSSL error: %s\n",
               (char *)ERR_error_string(ERR_get_error(0), 0));
        puts("Load Pem Failed!");
        // 0x13480
        return 17;
    }
    int32_t i_v66 =
        RSA_verify(672, &i_v62, 32, (int32_t)&i_v60, 256, i_v65); // 0x1336c
    RSA_free(i_v65);
    if (i_v64 != 0) {
        // 0x13394
        BIO_free(i_v64);
    }
    if (i_v66 != 1) {
        int32_t i_v67 =
            ERR_get_error(puts("Check File Sig failed!\r")); // 0x133b4
        printf("OpenSSL error: %s\n", (char *)ERR_error_string(i_v67, 0));
        // 0x13480
        return 18;
    }
    // 0x133f0
    fclose(p_v4);
    puts("All Done!\r");
    if (i_a6 % 256 != 0) {
        // 0x13418
        puts("This Comment Of This Package:");
        int32_t i_v68 = 0; // bp-3060, 0x13428
        int32_t i_v69;     // bp-3056, 0x12910
        memset(&i_v69, 0, 253);
        memcpy(&i_v68, (int32_t *)(i_v6 + 1360), 256);
        puts((char *)&i_v68);
    }
    // 0x13480
    return 0;
}

// Address range: 0x1348c - 0x13870
int32_t function_1348c(uint32_t i_a1, int32_t i_a2) {
    if (i_a1 <= 1) {
        // 0x134b0
        function_10924(i_a2);
        // 0x13864
        return 1;
    }
    int32_t *p_v1 = (int32_t *)(i_a2 + 4); // 0x134d0
    if (*(char *)*p_v1 != 45) {
        // 0x134e0
        function_10924(i_a2);
        // 0x13864
        return 2;
    }
    int32_t i_v2 = 0; // bp-272, 0x134fc
    int32_t i_v3;     // bp-268, 0x1348c
    memset(&i_v3, 0, 252);
    int32_t i_v4 = 0; // bp-400, 0x13518
    int32_t i_v5;     // bp-396, 0x1348c
    memset(&i_v5, 0, 124);
    int32_t i_v6 = 0; // bp-528, 0x13534
    int32_t i_v7;     // bp-524, 0x1348c
    memset(&i_v7, 0, 124);
    int32_t i_v8; // bp-2576, 0x1348c
    memset(&i_v8, 0, 2048);
    int32_t i_v9; // bp-2832, 0x1348c
    memset(&i_v9, 0, 253);
    int32_t i_v10 = 0; // 0x1348c
    switch (i_a1) {
    case 5: {
        int32_t *p_v11 = (int32_t *)(i_a2 + 8);  // 0x135b8
        uint32_t i_v12 = strlen((char *)*p_v11); // 0x135c0
        if (i_v12 != 255 && i_v12 >= 255) {
            // 0x135d0
            puts("fileName Too Long!");
            // 0x13864
            return 3;
        }
        // 0x135e4
        strcpy((char *)&i_v2, (char *)*p_v11);
        int32_t *p_v13 = (int32_t *)(i_a2 + 12); // 0x13608
        uint32_t i_v14 = strlen((char *)*p_v13); // 0x13610
        if (i_v14 != 127 && i_v14 >= 127) {
            // 0x13620
            puts("fileName Too Long!");
            // 0x13864
            return 3;
        }
        // 0x13634
        strcpy((char *)&i_v4, (char *)*p_v13);
        int32_t *p_v15 = (int32_t *)(i_a2 + 16); // 0x13658
        uint32_t i_v16 = strlen((char *)*p_v15); // 0x13660
        if (i_v16 != 127 && i_v16 >= 127) {
            // 0x13670
            puts("pemName Too Long!");
            // 0x13864
            return 4;
        }
        int32_t i_v17 = *p_v15; // 0x1368c
        strcpy((char *)&i_v6, (char *)i_v17);
        i_v10 = i_v17;
    }
    case 2: {
    lab_0x13734:;
        unsigned char i_v18 = *(char *)(*p_v1 + 1); // 0x1374c
        i_g6 = (int32_t)i_v18 - 102;
        char i_v19 = 0;    // 0x13758
        char i_v20 = 1;    // 0x13758
        int32_t i_v21 = 0; // 0x13758
        int32_t i_v22 = 0; // 0x13758
        char i_v23 = 0;    // 0x13758
        char i_v24 = 0;    // 0x13758
        int32_t i_v25;     // 0x1348c
        switch (i_v18) {
        case 120: {
            // 0x137c8
            i_v19 = 1;
            i_v20 = 0;
            i_v21 = 1;
        }
        case 112: {
        lab_0x137c8:
            // 0x137c8
            i_v22 = i_v21;
            i_v23 = i_v20;
            i_v24 = i_v19;
        }
        case 102: {
            int32_t i_v26 =
                function_12910(&i_v4, &i_v2, &i_v6, &i_v8, i_v22,
                               (int32_t)i_v23, (int32_t)i_v24); // 0x13810
            i_v25 = i_v26;
            // break -> 0x13864
            break;
        }
        case 115: {
            // 0x137c8
            i_v19 = 0;
            i_v20 = 0;
            i_v21 = 1;
            // branch (via goto) -> 0x137c8
            goto lab_0x137c8;
        }
        case 113: {
            // 0x13830
            i_v25 = function_10bb4();
            // break -> 0x13864
            break;
        }
        case 110: {
            // 0x1381c
            i_v25 = function_109d0(&i_v4);
            // break -> 0x13864
            break;
        }
        default: {
            // 0x1383c
            puts("Command Not Support!");
            function_10924(i_v10);
            i_v25 = 5;
            // break -> 0x13864
            break;
        }
        }
        // 0x13864
        return i_v25;
    }
    case 3: {
        int32_t *p_v27 = (int32_t *)(i_a2 + 8);  // 0x136b8
        uint32_t i_v28 = strlen((char *)*p_v27); // 0x136c0
        if (i_v28 != 127 && i_v28 >= 127) {
            // 0x136d0
            puts("fileName Too Long!");
            // 0x13864
            return 3;
        }
        int32_t i_v29 = *p_v27; // 0x136ec
        strcpy((char *)&i_v4, (char *)i_v29);
        i_v10 = i_v29;
        // branch (via goto) -> 0x13734
        goto lab_0x13734;
    }
    default: {
        // 0x13710
        puts("Param Err!");
        function_10924(0);
        // 0x13864
        return 3;
    }
    }
}

// Address range: 0x13870 - 0x138a8
int32_t function_13870(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_106f4(i_a1, i_a2, i_a3, i_a4); // 0x13882
    return (int32_t)&i_g2 - 0x17ff8 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x138b4 - 0x138b8
int32_t function_138b4(int32_t i_a1, int32_t *p_a2) {
    // 0x138b4
    return i_a1;
}

// Address range: 0x138b8 - 0x138be
int32_t function_138b8(void) {
    // 0x138b8
    int32_t i_v1; // 0x138b8
    return __xstat64(3, (char *)i_v1, (struct stat64 *)i_v1);
}

// Address range: 0x138c0 - 0x138c8
int32_t function_138c0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x138c0
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 59
