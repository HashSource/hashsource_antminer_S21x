//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct timezone {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_107b4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t *function_107d4(int32_t nmemb, int32_t size);
int32_t function_107e0(int32_t fd, int32_t level, int32_t optname,
                       int32_t *optval, int32_t optlen);
int32_t function_107ec(char *format, ...);
int32_t function_107f8(struct _IO_FILE *stream, char *format, ...);
struct _IO_FILE *function_10804(char *filename, char *modes);
void function_10810(int32_t *ptr);
void function_1081c(int32_t *s, int32_t n);
char *function_10828(struct in_addr x_a1);
int32_t function_10834(int32_t nfds, struct _TYPEDEF_fd_set *readfds,
                       struct _TYPEDEF_fd_set *writefds,
                       struct _TYPEDEF_fd_set *exceptfds,
                       struct timeval *timeout);
int32_t function_10840(int32_t fd, int32_t *buf, int32_t n, int32_t flags,
                       struct sockaddr *addr, int32_t *addr_len);
int16_t function_1084c(int16_t hostshort);
void function_10858(char *s);
int32_t function_10864(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
char *function_10870(char *dest, char *src);
int32_t function_1087c(int32_t fd, int32_t request, ...);
int32_t function_10888(int32_t useconds);
char *function_10894(char *dest, char *src);
int32_t function_108a0(struct timeval *tv, struct timezone *tz);
int32_t function_108ac(char *s);
int32_t function_108b8(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_108c4(char *command);
void function_108d0(void);
void function_108dc(int32_t status);
int32_t function_108e8(char *s);
int32_t function_108f4(int32_t fd, struct sockaddr *addr, int32_t len);
int32_t *function_10900(int32_t *s, int32_t c, int32_t n);
char *function_1090c(char *dest, char *src, int32_t n);
int32_t function_10918(char *name, int32_t type);
int32_t function_10924(struct _IO_FILE *stream);
int32_t function_10930(int32_t fd, int32_t *buf, int32_t n, int32_t flags,
                       struct sockaddr *addr, int32_t addr_len);
int32_t function_1093c(int32_t hostlong);
int32_t function_10948(char *s, char *format, ...);
int32_t function_10954(int32_t domain, int32_t type, int32_t protocol);
int32_t function_10960(char *s1, char *s2, int32_t n);
void function_1096c(void);
int32_t function_10978(int32_t fd);
int32_t function_109a8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_109b4(void);
int32_t function_109d8(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_109de(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_109fa(void);
int32_t function_10a22(void);
int32_t function_10a24(void);
int32_t function_10a28(void);
int32_t function_10a40(int32_t i_a1);
int32_t function_10af0(char *p_a1, int32_t *p_a2);
int32_t function_10bcc(int32_t i_a1, int32_t i_a2);
int32_t function_10d24(int32_t *p_a1, char *p_a2);
int32_t function_10e38(void);
int32_t function_10e60(void);
int32_t function_10e88(void);
int32_t function_10fa8(char *p_a1);
int32_t function_10fe4(void);
int32_t function_11054(void);
int32_t function_110bc(void);
int32_t function_11260(void);
int32_t function_113e4(char *p_a1);
int32_t function_11460(void);
int32_t function_11780(void);
int32_t function_1180c(int32_t i_a1, int32_t i_a2);
int32_t function_1189c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_118d8(void);
int32_t function_118dc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_250e1a(void);
int32_t unknown_54c3a(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0;              // 0x10666
int32_t i_g2 = 0x10a41;        // 0x21f10
int32_t i_g3 = 0;              // 0x2209c
int32_t i_g4 = -1;             // 0x220a8
char *p_g5;                    // 0x220ac
char *p_g6;                    // 0x220b4
int32_t i_g7 = 0;              // 0x220d4
struct timeval *p_g8 = NULL;   // 0x220d8
int32_t i_g9 = 0;              // 0x220da
int32_t i_g10 = 0;             // 0x220dc
struct sockaddr *p_g11 = NULL; // 0x220e8
int32_t i_g12 = 0;             // 0x220ea
int32_t i_g13 = 0;             // 0x220ec
int32_t i_g14;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());

// ------------------------ Functions -------------------------

// Address range: 0x107b4 - 0x107c0
int32_t function_107b4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x107b4
    return function_109b4();
}

// Address range: 0x107d4 - 0x107e0
int32_t *function_107d4(int32_t nmemb, int32_t size) {
    // 0x107d4
    return calloc(nmemb, size);
}

// Address range: 0x107e0 - 0x107ec
int32_t function_107e0(int32_t fd, int32_t level, int32_t optname,
                       int32_t *optval, int32_t optlen) {
    // 0x107e0
    return setsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x107ec - 0x107f8
int32_t function_107ec(char *format, ...) {
    // 0x107ec
    return printf(format);
}

// Address range: 0x107f8 - 0x10804
int32_t function_107f8(struct _IO_FILE *stream, char *format, ...) {
    // 0x107f8
    return fscanf(stream, format);
}

// Address range: 0x10804 - 0x10810
struct _IO_FILE *function_10804(char *filename, char *modes) {
    // 0x10804
    return fopen(filename, modes);
}

// Address range: 0x10810 - 0x1081c
void function_10810(int32_t *ptr) {
    // 0x10810
    free(ptr);
}

// Address range: 0x1081c - 0x10828
void function_1081c(int32_t *s, int32_t n) {
    // 0x1081c
    bzero(s, n);
}

// Address range: 0x10828 - 0x10834
char *function_10828(struct in_addr x_a1) {
    // 0x10828
    return inet_ntoa(x_a1);
}

// Address range: 0x10834 - 0x10840
int32_t function_10834(int32_t nfds, struct _TYPEDEF_fd_set *readfds,
                       struct _TYPEDEF_fd_set *writefds,
                       struct _TYPEDEF_fd_set *exceptfds,
                       struct timeval *timeout) {
    // 0x10834
    return select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x10840 - 0x1084c
int32_t function_10840(int32_t fd, int32_t *buf, int32_t n, int32_t flags,
                       struct sockaddr *addr, int32_t *addr_len) {
    // 0x10840
    return recvfrom(fd, buf, n, flags, addr, addr_len);
}

// Address range: 0x1084c - 0x10858
int16_t function_1084c(int16_t hostshort) {
    // 0x1084c
    return htons(hostshort);
}

// Address range: 0x10858 - 0x10864
void function_10858(char *s) {
    // 0x10858
    perror(s);
}

// Address range: 0x10864 - 0x10870
int32_t function_10864(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x10864
    return fwrite(ptr, size, n, s);
}

// Address range: 0x10870 - 0x1087c
char *function_10870(char *dest, char *src) {
    // 0x10870
    return strcat(dest, src);
}

// Address range: 0x1087c - 0x10888
int32_t function_1087c(int32_t fd, int32_t request, ...) {
    // 0x1087c
    return ioctl(fd, request);
}

// Address range: 0x10888 - 0x10894
int32_t function_10888(int32_t useconds) {
    // 0x10888
    return usleep(useconds);
}

// Address range: 0x10894 - 0x108a0
char *function_10894(char *dest, char *src) {
    // 0x10894
    return strcpy(dest, src);
}

// Address range: 0x108a0 - 0x108ac
int32_t function_108a0(struct timeval *tv, struct timezone *tz) {
    // 0x108a0
    return gettimeofday(tv, tz);
}

// Address range: 0x108ac - 0x108b8
int32_t function_108ac(char *s) {
    // 0x108ac
    return puts(s);
}

// Address range: 0x108b8 - 0x108c4
int32_t function_108b8(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x108b8
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x108c4 - 0x108d0
int32_t function_108c4(char *command) {
    // 0x108c4
    return system(command);
}

// Address range: 0x108d0 - 0x108dc
void function_108d0(void) {
    // 0x108d0
    __gmon_start__();
}

// Address range: 0x108dc - 0x108e8
void function_108dc(int32_t status) {
    // 0x108dc
    exit(status);
}

// Address range: 0x108e8 - 0x108f4
int32_t function_108e8(char *s) {
    // 0x108e8
    return strlen(s);
}

// Address range: 0x108f4 - 0x10900
int32_t function_108f4(int32_t fd, struct sockaddr *addr, int32_t len) {
    // 0x108f4
    return bind(fd, addr, len);
}

// Address range: 0x10900 - 0x1090c
int32_t *function_10900(int32_t *s, int32_t c, int32_t n) {
    // 0x10900
    return memset(s, c, n);
}

// Address range: 0x1090c - 0x10918
char *function_1090c(char *dest, char *src, int32_t n) {
    // 0x1090c
    return strncpy(dest, src, n);
}

// Address range: 0x10918 - 0x10924
int32_t function_10918(char *name, int32_t type) {
    // 0x10918
    return access(name, type);
}

// Address range: 0x10924 - 0x10930
int32_t function_10924(struct _IO_FILE *stream) {
    // 0x10924
    return fclose(stream);
}

// Address range: 0x10930 - 0x1093c
int32_t function_10930(int32_t fd, int32_t *buf, int32_t n, int32_t flags,
                       struct sockaddr *addr, int32_t addr_len) {
    // 0x10930
    return sendto(fd, buf, n, flags, addr, addr_len);
}

// Address range: 0x1093c - 0x10948
int32_t function_1093c(int32_t hostlong) {
    // 0x1093c
    return htonl(hostlong);
}

// Address range: 0x10948 - 0x10954
int32_t function_10948(char *s, char *format, ...) {
    // 0x10948
    return sprintf(s, format);
}

// Address range: 0x10954 - 0x10960
int32_t function_10954(int32_t domain, int32_t type, int32_t protocol) {
    // 0x10954
    return socket(domain, type, protocol);
}

// Address range: 0x10960 - 0x1096c
int32_t function_10960(char *s1, char *s2, int32_t n) {
    // 0x10960
    return strncmp(s1, s2, n);
}

// Address range: 0x1096c - 0x10978
void function_1096c(void) {
    // 0x1096c
    abort();
}

// Address range: 0x10978 - 0x10984
int32_t function_10978(int32_t fd) {
    // 0x10978
    return close(fd);
}

// Address range: 0x10984 - 0x109a8
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x10984
    int32_t i_v1; // 0x10984
    __libc_start_main(0x1180c, i_a2, (char **)&i_v1, (void (*)())0x1189d,
                      (void (*)())0x1180c, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x109a8 - 0x109ac
int32_t function_109a8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x109a8
    return i_a1;
}

// Address range: 0x109b4 - 0x109d0
int32_t function_109b4(void) {
    // 0x109b4
    if (i_g3 == 0) {
        int32_t i_v1; // 0x109b4
        return i_v1;
    }
    // 0x109cc
    __gmon_start__();
    return &i_g14;
}

// Address range: 0x109d8 - 0x109dc
int32_t function_109d8(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x109d8
    return i_a1;
}

// Address range: 0x109de - 0x109fa
int32_t function_109de(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x109de
    return i_a1 | 0x20000;
}

// Address range: 0x109fa - 0x10a22
int32_t function_109fa(void) {
    // 0x109fa
    float64_t f_v1; // 0x109fa
    __asm_vmax_f32(f_v1, f_v1);
    __asm_vhadd_s8(f_v1, f_v1);
    float128_t f_v2; // 0x109fa
    __asm_vaddw_s8(f_v2, f_v1);
    __asm_vaddl_s8(f_v1, f_v1);
    bool i_v3; // 0x109fa
    if (!i_v3) {
        function_250e1a();
    }
    int32_t i_v4 = unknown_54c3a(); // 0x10a0e
    __asm_vhadd_s8(f_v1, f_v1);
    __asm_vsubw_s8(f_v2, f_v1);
    int32_t i_v5 = i_v4; // 0x10a1e
    return i_v5;
}

// Address range: 0x10a22 - 0x10a24
int32_t function_10a22(void) {
    // 0x10a22
    int32_t i_v1; // 0x10a22
    return i_v1;
}

// Address range: 0x10a24 - 0x10a26
int32_t function_10a24(void) {
    // 0x10a24
    int32_t i_v1; // 0x10a24
    return i_v1;
}

// Address range: 0x10a28 - 0x10a40
int32_t function_10a28(void) {
    // 0x10a28
    int32_t i_v1; // 0x10a28
    if (*(char *)&p_g5 == 0) {
        // 0x10a36
        int32_t i_v2;                                    // 0x10a28
        int32_t i_v3 = function_109d8(i_v2, i_v2, i_v2); // 0x10a36
        *(char *)&p_g5 = 1;
        i_v1 = i_v3;
    }
    // 0x10a3e
    return i_v1;
}

// Address range: 0x10a40 - 0x10af0
int32_t function_10a40(int32_t i_a1) {
    int32_t i_v1; // bp-28, 0x10a40
    gettimeofday((struct timeval *)&i_v1, NULL);
    int32_t i_v2; // bp-20, 0x10a40
    int32_t i_v3; // 0x10a40
    sprintf((char *)&i_v2, "%ld", i_v3);
    int32_t *p_v4 = (int32_t *)i_a1; // 0x10a88
    memset(p_v4, 0, 10);
    uint32_t i_v5 = (6 - strlen((char *)&i_v2)) % 256; // 0x10ab0
    if (i_v5 != 0) {
        // 0x10abc
        memset(p_v4, 48, i_v5);
    }
    // 0x10ad0
    strcat((char *)i_a1, (char *)&i_v2);
    return i_a1;
}

// Address range: 0x10af0 - 0x10bcc
int32_t function_10af0(char *p_a1, int32_t *p_a2) {
    struct in_addr x_v1;                                    // 0x10ba0
    int32_t i_v2 = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0x10b10
    if (i_v2 == -1) {
        // 0x10b24
        perror("socket");
        // 0x10bc0
        return -1;
    }
    // 0x10b38
    int32_t i_v3; // bp-60, 0x10af0
    strncpy((char *)&i_v3, p_a1, 20);
    int32_t i_v4; // 0x10af0
    if (ioctl(i_v2, 0x8915) < 0) {
        // 0x10b74
        printf(":No Such Device %s/n", p_a1);
        i_v4 = -1;
    } else {
        // 0x10b8c
        x_v1 = (struct { int32_t e0; }){.e0 = 0};
        int32_t i_v5; // 0x10af0
        x_v1.e0 = i_v5;
        strcpy((char *)p_a2, inet_ntoa(x_v1));
        close(i_v2);
        i_v4 = 1;
    }
    // 0x10bc0
    return i_v4;
}

// Address range: 0x10bcc - 0x10d24
int32_t function_10bcc(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = calloc(40, 1);                           // 0x10be8
    int32_t i_v2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x10c00
    if (i_v2 < 0) {
        // 0x10c14
        perror("socket");
        exit(0);
        // UNREACHABLE
    }
    // 0x10c28
    int32_t i_v3; // bp-48, 0x10bcc
    strcpy((char *)&i_v3, (char *)i_a2);
    if (ioctl(i_v2, 0x8927) < 0) {
        // 0x10c58
        perror("ioctl");
        exit(0);
        // UNREACHABLE
    }
    // 0x10c6c
    close(i_v2);
    char i_v4; // 0x10bcc
    sprintf((char *)p_v1, "%02X:%02X:%02X:%02X:%02X:%02X", (int32_t)i_v4,
            (int32_t)i_v4, (int32_t)i_v4, (int32_t)i_v4, (int32_t)i_v4,
            (int32_t)(unsigned char)i_v4);
    *(int32_t *)i_a1 = 0x3d43414d;
    *(char *)(i_a1 + 4) = 0;
    char *p_v5 = (char *)i_a1; // 0x10ce0
    strcat(p_v5, (char *)p_v1);
    *(int16_t *)(strlen(p_v5) + i_a1) = 44;
    free(p_v1);
    return i_a1;
}

// Address range: 0x10d24 - 0x10e38
int32_t function_10d24(int32_t *p_a1, char *p_a2) {
    int32_t *p_v1 = calloc(40, 1);                           // 0x10d40
    int32_t i_v2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x10d58
    if (i_v2 < 0) {
        // 0x10d6c
        perror("socket");
        exit(0);
        // UNREACHABLE
    }
    // 0x10d80
    int32_t i_v3; // bp-48, 0x10d24
    strcpy((char *)&i_v3, p_a2);
    if (ioctl(i_v2, 0x8927) < 0) {
        // 0x10db0
        perror("ioctl");
        exit(0);
        // UNREACHABLE
    }
    // 0x10dc4
    close(i_v2);
    char i_v4; // 0x10d24
    sprintf((char *)p_v1, "%02X:%02X:%02X:%02X:%02X:%02X", (int32_t)i_v4,
            (int32_t)i_v4, (int32_t)i_v4, (int32_t)i_v4, (int32_t)i_v4,
            (int32_t)(unsigned char)i_v4);
    strcpy((char *)p_a1, (char *)p_v1);
    free(p_v1);
    return (int32_t)p_a1;
}

// Address range: 0x10e38 - 0x10e60
int32_t function_10e38(void) {
    // 0x10e38
    system("echo 0 >/sys/class/gpio/gpio941/value");
    return __asm_nop(system("echo 0 >/sys/class/gpio/gpio942/value"));
}

// Address range: 0x10e60 - 0x10e88
int32_t function_10e60(void) {
    // 0x10e60
    system("echo 1 >/sys/class/gpio/gpio941/value");
    return __asm_nop(system("echo 1 >/sys/class/gpio/gpio942/value"));
}

// Address range: 0x10e88 - 0x10fa8
int32_t function_10e88(void) {
    // 0x10e88
    if (function_10fa8("/sys/class/gpio/gpio943") == 0) {
        struct _IO_FILE *p_v1 = fopen("/sys/class/gpio/export", "w"); // 0x10ecc
        if (p_v1 == NULL) {
            // 0x10ee0
            puts("Open read gpio/export");
            // 0x10f9c
            return -1;
        }
        // 0x10ef4
        if (fwrite((int32_t *)"943", 3, 1, p_v1) != 1) {
            // 0x10f18
            puts("File Write Error!");
        }
        // 0x10f24
        fclose(p_v1);
    }
    struct _IO_FILE *p_v2 =
        fopen("/sys/class/gpio/gpio943/value", "r"); // 0x10f3c
    int32_t i_v3;                                    // 0x10e88
    if (p_v2 == NULL) {
        // 0x10f50
        puts("Open read recovery button failure");
        i_v3 = -1;
    } else {
        // 0x10f64
        int32_t i_v4; // bp-20, 0x10e88
        fscanf(p_v2, "%d", &i_v4);
        fclose(p_v2);
        i_v3 = i_v4 != 0;
    }
    // 0x10f9c
    return i_v3;
}

// Address range: 0x10fa8 - 0x10fe4
int32_t function_10fa8(char *p_a1) {
    // 0x10fa8
    return access(p_a1, F_OK) == 0;
}

// Address range: 0x10fe4 - 0x11054
int32_t function_10fe4(void) {
    int32_t i_v1 = 0; // 0x11030
    system("echo 1 >/sys/class/gpio/gpio942/value");
    usleep(0xc350);
    system("echo 0 >/sys/class/gpio/gpio942/value");
    int32_t i_v2 = usleep(0xc350); // 0x11028
    i_v1++;
    while (i_v1 == 2 || i_v1 < 2) {
        // 0x11004
        system("echo 1 >/sys/class/gpio/gpio942/value");
        usleep(0xc350);
        system("echo 0 >/sys/class/gpio/gpio942/value");
        i_v2 = usleep(0xc350);
        i_v1++;
    }
    // 0x11044
    __asm_nop(i_v2);
    return i_v1;
}

// Address range: 0x11054 - 0x110bc
int32_t function_11054(void) {
    int32_t i_v1; // 0x11090
    for (int32_t i_v2 = 0; i_v2 < 3; i_v2++) {
        // 0x1106c
        system("echo 1 >/sys/class/gpio/gpio941/value");
        usleep(0xc350);
        system("echo 0 >/sys/class/gpio/gpio941/value");
        i_v1 = usleep(0xc350);
    }
    // 0x110ac
    __asm_nop(i_v1);
    return 3;
}

// Address range: 0x110bc - 0x11260
int32_t function_110bc(void) {
    int32_t i_v1 = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0x110d4
    i_g4 = i_v1;
    if (i_v1 == -1) {
        // 0x110fc
        printf("socket error");
        // 0x11254
        return -1;
    }
    int32_t i_v2 = 1; // bp-16, 0x11114
    if (setsockopt(i_v1, SO_DEBUG, 6, &i_v2, 4) == -1) {
        // 0x11158
        printf("set socket error...");
        // 0x11254
        return -1;
    }
    // 0x1116c
    bzero((int32_t *)&p_g11, 16);
    *(int16_t *)&p_g11 = 2;
    i_g13 = htonl(-1);
    *(int16_t *)&i_g12 = htons(0x379b);
    bzero((int32_t *)&p_g8, 16);
    *(int16_t *)&p_g8 = 2;
    i_g10 = htonl(0);
    *(int16_t *)&i_g9 = htons(0x379c);
    int32_t i_v3 = bind(i_g4, (struct sockaddr *)&p_g8, 16); // 0x11230
    int32_t i_v4 = i_v3;                                     // 0x1123c
    if (i_v3 == -1) {
        // 0x11240
        printf("bind error...");
        i_v4 = 0;
    }
    // 0x11254
    return i_v4;
}

// Address range: 0x11260 - 0x113e4
int32_t function_11260(void) {
    // 0x11260
    int32_t i_v1; // bp-152, 0x11260
    memset(&i_v1, 0, 30);
    int32_t i_v2; // bp-192, 0x11260
    memset(&i_v2, 0, 40);
    int32_t i_v3; // bp-120, 0x11260
    memset(&i_v3, 0, 100);
    if (function_10af0("eth0", &i_v2) == 0) {
        // 0x112c8
        puts("get IP error");
    }
    // 0x112d4
    function_10d24(&i_v1, "eth0");
    int32_t i_v4 = strlen((char *)&i_v1); // 0x112f0
    strncpy((char *)&p_g6, (char *)&i_v1, i_v4);
    strcpy((char *)&i_v3, (char *)&i_v2);
    int32_t i_v5 = strlen((char *)&i_v3); // 0x11328
    *(int16_t *)(i_v5 + (int32_t)&i_v3) = 44;
    strcat((char *)&i_v3, (char *)&i_v1);
    int32_t i_v6 = strlen((char *)&i_v3); // 0x11374
    if (sendto(i_g4, &i_v3, i_v6, 0, (struct sockaddr *)&p_g11, 16) < 0) {
        // 0x113b0
        printf("send error....");
    } else {
        // 0x113c0
        printf("send ipmac:\n%s\n", &i_v3);
    }
    // 0x113d4
    return 1;
}

// Address range: 0x113e4 - 0x11460
int32_t function_113e4(char *p_a1) {
    int32_t i_v1 = sendto(i_g4, (int32_t *)p_a1, 10, 0,
                          (struct sockaddr *)&p_g11, 16); // 0x11420
    int32_t i_v2;                                         // 0x113e4
    if (i_v1 < 0) {
        // 0x11434
        i_v2 = printf("send error....");
    } else {
        // 0x11444
        i_v2 = printf("send ack OK!\n ");
    }
    // 0x11450
    __asm_nop(i_v2);
    return i_v1;
}

// Address range: 0x11460 - 0x11780
int32_t function_11460(void) {
    int32_t i_v1 = 2; // bp-160, 0x11470
    int32_t i_v2 = 0; // 0x114a4
    int32_t i_v3;     // bp-152, 0x11460
    *(int32_t *)(4 * i_v2 + (int32_t)&i_v3) = 0;
    i_v2++;
    while (i_v2 == 31 || i_v2 < 31) {
        // 0x11490
        *(int32_t *)(4 * i_v2 + (int32_t)&i_v3) = 0;
        i_v2++;
    }
    int32_t i_v4 = i_g4; // 0x114c0
    int32_t i_v5;        // bp-8, 0x11460
    int32_t i_v6 = (int32_t)&i_v5 - 144;
    int32_t *p_v7 =
        (int32_t *)(4 * ((i_v4 < 0 ? i_v4 + 31 : i_v4) >> 5) + i_v6); // 0x114e8
    int32_t i_v8 = -i_v4;                                             // 0x114f8
    *p_v7 = 1 << (i_v8 < 0 ? i_v4 % 32 : -((i_v8 % 32))) | *p_v7;
    int32_t *p_v9 = calloc(30, 1); // 0x11534
    int32_t i_v10 = select(i_g4 + 1, (struct _TYPEDEF_fd_set *)&i_v3, NULL,
                           NULL, (struct timeval *)&i_v1); // 0x11564
    int32_t i_v11;                                         // 0x11460
    int32_t i_v12;                                         // 0x11460
    switch (i_v10) {
    case -1: {
        // 0x11580
        exit(-1);
        // UNREACHABLE
    }
    case 0: {
        int32_t i_v13 = i_g7 + 1; // 0x11594
        i_g7 = i_v13;
        i_v11 = i_v13;
        // break -> 0x11728
        break;
    }
    default: {
        int32_t i_v14 = i_g4; // 0x115b0
        int32_t i_v15 =
            *(int32_t *)(4 * ((i_v14 < 0 ? i_v14 + 31 : i_v14) >> 5) +
                         i_v6); // 0x115d4
        int32_t i_v16 = -i_v14; // 0x115e4
        int32_t i_v17 = i_v10;  // 0x11604
        if ((1 << (i_v16 < 0 ? i_v14 % 32 : -((i_v16 % 32))) & i_v15) != 0) {
            int32_t i_v18 = 16; // bp-164, 0x1160c
            if (recvfrom(i_v14, p_v9, 30, 0, (struct sockaddr *)&p_g8, &i_v18) >
                0) {
                // 0x1167c
                printf("rev:\n%s\t", p_v9);
                i_g7 = 0;
                int32_t i_v19 = strlen((char *)&p_g6); // 0x116a4
                if (strncmp((char *)p_v9, (char *)&p_g6, i_v19) == 0) {
                    // 0x116cc
                    printf("send_ack(\"1\");");
                    function_10fe4();
                    function_113e4("OK");
                    free(p_v9);
                    i_v12 = 1;
                } else {
                    // 0x116f8
                    printf("send_ack(\"0\");");
                    function_11054();
                    function_113e4("FAILD");
                    free(p_v9);
                    i_v12 = 0;
                }
                // 0x11774
                return i_v12;
            }
            // 0x11650
            i_g7++;
            i_v17 = printf("read error....");
        }
        // 0x11724
        __asm_nop(i_v17);
        i_v11 = i_g7;
        // break -> 0x11728
        break;
    }
    }
    // 0x11728
    if (i_v11 == 5) {
        // 0x1173c
        i_g7 = 0;
        puts("Time Out");
        free(p_v9);
        i_v12 = 1;
    } else {
        // 0x11768
        free(p_v9);
        i_v12 = 0;
    }
    // 0x11774
    return i_v12;
}

// Address range: 0x11780 - 0x1180c
int32_t function_11780(void) {
    int32_t i_v1 = 0;
    for (int32_t i_v2 = 0; i_v2 < 5; i_v2++) {
        int32_t i_v3 = i_v1;
        int32_t i_v4 = i_v3; // 0x117b4
        if (function_10e88() == 0) {
            // 0x117b8
            usleep(0x4e20);
            i_v4 = i_v3 + 1;
        }
        // 0x117cc
        i_v1 = i_v4;
    }
    int32_t i_v5 = 0; // 0x117ec
    if (i_v1 == 5) {
        // 0x117f0
        function_10e60();
        i_v5 = 1;
    }
    // 0x11800
    return i_v5;
}

// Address range: 0x1180c - 0x1189c
int32_t function_1180c(int32_t i_a1, int32_t i_a2) {
    // 0x1180c
    printf("monitor-ipsig compile %s--%s\n", "Jan 14 2020", "18:22:32");
    function_110bc();
    while (true) {
        // 0x11850
        if (function_11780() == 1) {
            puts("Key Down!!!!!");
            function_11260();
            while (function_11460() != 1) {
                // 0x11860
                puts("Key Down!!!!!");
                function_11260();
            }
            // 0x11894
            __asm_nop(1);
        } else {
            // 0x11884
            usleep(0x61a80);
        }
    }
}

// Address range: 0x1189c - 0x118d0
int32_t function_1189c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_107b4(i_a1, i_a2, i_a3, i_a4); // 0x118ac
    int32_t i_v2 =
        (int32_t)&i_g1 + 0x118ac - (int32_t)&i_g2 >> 2 == 0 ? i_v1 : i_a1;
    return i_v2;
}

// Address range: 0x118d8 - 0x118da
int32_t function_118d8(void) {
    // 0x118d8
    int32_t i_v1; // 0x118d8
    return i_v1;
}

// Address range: 0x118dc - 0x118e4
int32_t function_118dc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x118dc
    return i_a1;
}

// Address range: 0x250e1a - 0x250e1b
int32_t function_250e1a(void) {
    // 0x250e1a
    int32_t i_v1; // 0x250e1a
    return i_v1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 66
