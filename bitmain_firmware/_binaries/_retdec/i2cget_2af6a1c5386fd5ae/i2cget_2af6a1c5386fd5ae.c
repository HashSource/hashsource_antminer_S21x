//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <dirent.h>
#include <errno.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct __dirstream {
    int32_t e0;
};

struct dirent64 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_109f0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t *function_10a10(int32_t nmemb, int32_t size);
int32_t function_10a1c(char *s1, char *s2);
int32_t function_10a28(char *nptr, char **endptr, int32_t base);
int32_t function_10a34(char *format, ...);
int32_t function_10a40(struct _IO_FILE *stream);
void function_10a4c(int32_t *ptr);
char *function_10a58(char *s, int32_t n, struct _IO_FILE *stream);
int32_t *function_10a64(int32_t *ptr, int32_t size);
int32_t function_10a70(char *s1, char *s2);
int32_t function_10a7c(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
int32_t function_10a88(int32_t fd, int32_t request, ...);
char *function_10a94(char *dest, char *src);
int32_t function_10aa0(int32_t i_a1, int32_t i_a2);
struct __dirstream *function_10aac(char *name);
int32_t function_10ab8(char *file, int32_t oflag, ...);
int32_t *function_10ac4(int32_t size);
int32_t function_10ad0(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
char *function_10adc(int32_t errnum);
void function_10ae8(void);
void function_10af4(int32_t status);
int32_t function_10b00(char *nptr, char **endptr, int32_t base);
int32_t function_10b0c(int32_t i_a1);
int32_t function_10b18(char *s);
char *function_10b24(char *s, int32_t c);
int32_t function_10b30(struct _IO_FILE *stream, char *format, ...);
int32_t *function_10b3c(void);
int32_t function_10b48(char *s, int32_t maxlen, char *format, ...);
int32_t function_10b54(char *s, char *format, ...);
char *function_10b60(char *string);
int32_t *function_10b6c(int32_t *s, int32_t c, int32_t n);
int32_t function_10b78(struct _IO_FILE *stream);
int32_t function_10b84(struct _IO_FILE *stream);
int32_t function_10b90(int32_t i_a1, int32_t i_a2);
char *function_10b9c(char *s, int32_t c);
int32_t function_10ba8(char *s, char *format, ...);
struct dirent64 *function_10bb4(struct __dirstream *dirp);
int32_t function_10bc0(int32_t i_a1, int32_t i_a2);
struct _IO_FILE *function_10bcc(char *filename, char *modes);
int32_t function_10bd8(char *s1, char *s2, int32_t n);
void function_10be4(void);
int32_t function_10bf0(int32_t fd);
int32_t function_10bfc(struct __dirstream *dirp);
int32_t function_10c08(uint32_t i_a1, int32_t i_a2);
int32_t function_113ac(int32_t i_a1);
int32_t function_113b8(void);
int32_t function_113dc(void);
int32_t function_11400(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_1142c(void);
int32_t function_11444(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_1144a(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11456(void);
int32_t function_11458(int32_t i_a1);
int32_t function_11464(void);
int32_t function_11468(void);
int32_t function_11494(int32_t i_a1);
int32_t function_114f0(int32_t i_a1);
int32_t function_11528(int32_t i_a1, int32_t i_a2);
int32_t function_11570(int32_t i_a1, int32_t i_a2);
int32_t function_11628(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11764(void);
int32_t function_11d08(int32_t i_a1);
int32_t function_11e54(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_11ec8(int32_t i_a1);
int32_t function_11f70(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11fb4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_22c0(void);
int32_t unknown_240(int32_t i_a1);

// --------------------- Global Variables ---------------------

char *x_g1[10] = {"dummy",   "Dummy bus",   "isa",   "ISA bus",
                  "i2c",     "I2C adapter", "smbus", "SMBus adapter",
                  "unknown", "N/A"}; // 0x1254c
int32_t i_g2 = 0x1142d;       // 0x22858
int32_t i_g3 = 0;             // 0x22a04
struct _IO_FILE *p_g4 = NULL; // 0x22a10
struct _IO_FILE *p_g5 = NULL; // 0x22a18
char *p_g6;                   // 0x22a1c
int32_t i_g7;
int32_t i_g8;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
char *__strdup(char *p_a1);
struct _IO_FILE *fopen64(char *p_a1, char *p_a2);
int32_t i2c_smbus_read_byte(int32_t i_a1);
int32_t i2c_smbus_read_byte_data(int32_t i_a1, int32_t i_a2);
int32_t i2c_smbus_read_word_data(int32_t i_a1, int32_t i_a2);
int32_t i2c_smbus_write_byte(int32_t i_a1, int32_t i_a2);
int32_t open64(char *p_a1, int32_t i_a2, ...);
struct dirent64 *readdir64(struct __dirstream *p_a1);

// ------------------------ Functions -------------------------

// Address range: 0x109f0 - 0x109fc
int32_t function_109f0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x109f0
    return function_113b8();
}

// Address range: 0x10a10 - 0x10a1c
int32_t *function_10a10(int32_t nmemb, int32_t size) {
    // 0x10a10
    return calloc(nmemb, size);
}

// Address range: 0x10a1c - 0x10a28
int32_t function_10a1c(char *s1, char *s2) {
    // 0x10a1c
    return strcmp(s1, s2);
}

// Address range: 0x10a28 - 0x10a34
int32_t function_10a28(char *nptr, char **endptr, int32_t base) {
    // 0x10a28
    return strtol(nptr, endptr, base);
}

// Address range: 0x10a34 - 0x10a40
int32_t function_10a34(char *format, ...) {
    // 0x10a34
    return printf(format);
}

// Address range: 0x10a40 - 0x10a4c
int32_t function_10a40(struct _IO_FILE *stream) {
    // 0x10a40
    return fflush(stream);
}

// Address range: 0x10a4c - 0x10a58
void function_10a4c(int32_t *ptr) {
    // 0x10a4c
    free(ptr);
}

// Address range: 0x10a58 - 0x10a64
char *function_10a58(char *s, int32_t n, struct _IO_FILE *stream) {
    // 0x10a58
    return fgets(s, n, stream);
}

// Address range: 0x10a64 - 0x10a70
int32_t *function_10a64(int32_t *ptr, int32_t size) {
    // 0x10a64
    return realloc(ptr, size);
}

// Address range: 0x10a70 - 0x10a7c
int32_t function_10a70(char *s1, char *s2) {
    // 0x10a70
    return strcasecmp(s1, s2);
}

// Address range: 0x10a7c - 0x10a88
int32_t function_10a7c(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x10a7c
    return fwrite(ptr, size, n, s);
}

// Address range: 0x10a88 - 0x10a94
int32_t function_10a88(int32_t fd, int32_t request, ...) {
    // 0x10a88
    return ioctl(fd, request);
}

// Address range: 0x10a94 - 0x10aa0
char *function_10a94(char *dest, char *src) {
    // 0x10a94
    return strcpy(dest, src);
}

// Address range: 0x10aa0 - 0x10aac
int32_t function_10aa0(int32_t i_a1, int32_t i_a2) {
    // 0x10aa0
    return i2c_smbus_write_byte(i_a1, i_a2);
}

// Address range: 0x10aac - 0x10ab8
struct __dirstream *function_10aac(char *name) {
    // 0x10aac
    return opendir(name);
}

// Address range: 0x10ab8 - 0x10ac4
int32_t function_10ab8(char *file, int32_t oflag, ...) {
    // 0x10ab8
    return open64(file, oflag);
}

// Address range: 0x10ac4 - 0x10ad0
int32_t *function_10ac4(int32_t size) {
    // 0x10ac4
    return malloc(size);
}

// Address range: 0x10ad0 - 0x10adc
int32_t function_10ad0(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x10ad0
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10adc - 0x10ae8
char *function_10adc(int32_t errnum) {
    // 0x10adc
    return strerror(errnum);
}

// Address range: 0x10ae8 - 0x10af4
void function_10ae8(void) {
    // 0x10ae8
    __gmon_start__();
}

// Address range: 0x10af4 - 0x10b00
void function_10af4(int32_t status) {
    // 0x10af4
    exit(status);
}

// Address range: 0x10b00 - 0x10b0c
int32_t function_10b00(char *nptr, char **endptr, int32_t base) {
    // 0x10b00
    return strtoul(nptr, endptr, base);
}

// Address range: 0x10b0c - 0x10b18
int32_t function_10b0c(int32_t i_a1) {
    // 0x10b0c
    return i2c_smbus_read_byte(i_a1);
}

// Address range: 0x10b18 - 0x10b24
int32_t function_10b18(char *s) {
    // 0x10b18
    return strlen(s);
}

// Address range: 0x10b24 - 0x10b30
char *function_10b24(char *s, int32_t c) {
    // 0x10b24
    return strchr(s, c);
}

// Address range: 0x10b30 - 0x10b3c
int32_t function_10b30(struct _IO_FILE *stream, char *format, ...) {
    // 0x10b30
    return fprintf(stream, format);
}

// Address range: 0x10b3c - 0x10b48
int32_t *function_10b3c(void) {
    // 0x10b3c
    return __errno_location();
}

// Address range: 0x10b48 - 0x10b54
int32_t function_10b48(char *s, int32_t maxlen, char *format, ...) {
    // 0x10b48
    return snprintf(s, maxlen, format);
}

// Address range: 0x10b54 - 0x10b60
int32_t function_10b54(char *s, char *format, ...) {
    // 0x10b54
    return sscanf(s, format);
}

// Address range: 0x10b60 - 0x10b6c
char *function_10b60(char *string) {
    // 0x10b60
    return __strdup(string);
}

// Address range: 0x10b6c - 0x10b78
int32_t *function_10b6c(int32_t *s, int32_t c, int32_t n) {
    // 0x10b6c
    return memset(s, c, n);
}

// Address range: 0x10b78 - 0x10b84
int32_t function_10b78(struct _IO_FILE *stream) {
    // 0x10b78
    return fgetc(stream);
}

// Address range: 0x10b84 - 0x10b90
int32_t function_10b84(struct _IO_FILE *stream) {
    // 0x10b84
    return fclose(stream);
}

// Address range: 0x10b90 - 0x10b9c
int32_t function_10b90(int32_t i_a1, int32_t i_a2) {
    // 0x10b90
    return i2c_smbus_read_word_data(i_a1, i_a2);
}

// Address range: 0x10b9c - 0x10ba8
char *function_10b9c(char *s, int32_t c) {
    // 0x10b9c
    return strrchr(s, c);
}

// Address range: 0x10ba8 - 0x10bb4
int32_t function_10ba8(char *s, char *format, ...) {
    // 0x10ba8
    return sprintf(s, format);
}

// Address range: 0x10bb4 - 0x10bc0
struct dirent64 *function_10bb4(struct __dirstream *dirp) {
    // 0x10bb4
    return readdir64(dirp);
}

// Address range: 0x10bc0 - 0x10bcc
int32_t function_10bc0(int32_t i_a1, int32_t i_a2) {
    // 0x10bc0
    return i2c_smbus_read_byte_data(i_a1, i_a2);
}

// Address range: 0x10bcc - 0x10bd8
struct _IO_FILE *function_10bcc(char *filename, char *modes) {
    // 0x10bcc
    return fopen64(filename, modes);
}

// Address range: 0x10bd8 - 0x10be4
int32_t function_10bd8(char *s1, char *s2, int32_t n) {
    // 0x10bd8
    return strncmp(s1, s2, n);
}

// Address range: 0x10be4 - 0x10bf0
void function_10be4(void) {
    // 0x10be4
    abort();
}

// Address range: 0x10bf0 - 0x10bfc
int32_t function_10bf0(int32_t fd) {
    // 0x10bf0
    return close(fd);
}

// Address range: 0x10bfc - 0x10c08
int32_t function_10bfc(struct __dirstream *dirp) {
    // 0x10bfc
    return closedir(dirp);
}

// Address range: 0x10c08 - 0x11388
int32_t function_10c08(uint32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 0; // 0x10c34
    int32_t i_v2 = 1; // 0x10c34
    int32_t i_v3 = 0; // 0x10c34
    int32_t i_v4 = 0; // 0x10c34
    int32_t i_v5 = 0; // 0x10c34
    int32_t i_v6;     // 0x10c08
    int32_t i_v7;     // 0x10c08
    int32_t i_v8;     // 0x10c08
    int32_t i_v9;     // 0x10c08
    int32_t i_v10;    // 0x10c08
    int32_t i_v11;    // 0x10cf4
    if (i_a1 >= 2) {
        int32_t i_v12 = i_a2 + 4;          // 0x10c38
        int32_t i_v13 = *(int32_t *)i_v12; // 0x10c38
        char *p_v14 = (char *)i_v13;       // 0x10c3c
        char *p_v15 = p_v14;               // 0x10c44
        int32_t i_v16 = i_v13;             // 0x10c44
        int32_t i_v17 = i_v12;             // 0x10c44
        int32_t i_v18 = 0;                 // 0x10c44
        int32_t i_v19 = 1;                 // 0x10c44
        int32_t i_v20 = 0;                 // 0x10c44
        int32_t i_v21 = 0;                 // 0x10c44
        int32_t i_v22 = 0;                 // 0x10c44
        i_v1 = 0;
        i_v2 = 1;
        i_v3 = 0;
        i_v4 = 0;
        i_v5 = 0;
        if (*p_v14 == 45) {
            while (true) {
                int32_t i_v23 = i_v22;
                int32_t i_v24 = i_v21;
                int32_t i_v25 = i_v20;
                i_v10 = i_v19;
                int32_t i_v26 = i_v18;
                unsigned char i_v27 = *(char *)(i_v16 + 1); // 0x10c48
                i_g7 = (int32_t)i_v27 - 86;
                int32_t i_v28 = 1;     // 0x10c54
                int32_t i_v29 = i_v24; // 0x10c54
                int32_t i_v30 = i_v25; // 0x10c54
                int32_t i_v31 = i_v26; // 0x10c54
                switch (i_v27) {
                case 86: {
                    // 0x10dc0
                    i_v28 = i_v23;
                    i_v29 = i_v24;
                    i_v30 = 1;
                    i_v31 = i_v26;
                }
                case 121: {
                lab_0x10cf0:
                    // 0x10cf0
                    i_v6 = i_v31;
                    i_v9 = i_v30;
                    i_v8 = i_v29;
                    i_v7 = i_v28;
                    i_v11 = i_v10 + 1;
                    if (i_v11 >= i_a1) {
                        goto lab_0x10d00_2;
                    }
                    // break -> 0x10c38
                    break;
                }
                case 102: {
                    // 0x10db0
                    i_v28 = i_v23;
                    i_v29 = 1;
                    i_v30 = i_v25;
                    i_v31 = i_v26;
                    // branch (via goto) -> 0x10cf0
                    goto lab_0x10cf0;
                }
                case 97: {
                    // 0x10db8
                    i_v28 = i_v23;
                    i_v29 = i_v24;
                    i_v30 = i_v25;
                    i_v31 = 1;
                    // branch (via goto) -> 0x10cf0
                    goto lab_0x10cf0;
                }
                default: {
                    // 0x10dc8
                    fprintf(p_g4, "Error: Unsupported option \"%s\"!\n", p_v15);
                    function_11468();
                    // UNREACHABLE
                }
                }
                int32_t i_v32 = i_v17 + 4;         // 0x10c38
                int32_t i_v33 = *(int32_t *)i_v32; // 0x10c38
                char *p_v34 = (char *)i_v33;       // 0x10c3c
                p_v15 = p_v34;
                i_v16 = i_v33;
                i_v17 = i_v32;
                i_v18 = i_v6;
                i_v19 = i_v11;
                i_v20 = i_v9;
                i_v21 = i_v8;
                i_v22 = i_v7;
                if (*p_v34 != 45) {
                    goto lab_0x10d00_2;
                }
            }
            // 0x10dc8
            fprintf(p_g4, "Error: Unsupported option \"%s\"!\n", p_v15);
            function_11468();
            // UNREACHABLE
        }
    }
    goto lab_0x10d08;
lab_0x10d00_2:
    // 0x10d00
    i_v1 = i_v6;
    i_v2 = i_v11;
    i_v3 = i_v8;
    i_v4 = i_v7;
    i_v5 = i_v10;
    if (i_v9 != 0) {
        // 0x10de4
        fprintf(p_g4, "i2cget version %s\n", "4.1");
        exit(0);
        // UNREACHABLE
    }
    goto lab_0x10d08;
lab_0x10d08:
    // 0x10d08
    if (i_v5 + 2 >= i_a1) {
        // 0x10e2c
        function_11468();
        // UNREACHABLE
    }
    int32_t i_v35 = 4 * i_v2 + i_a2;                   // 0x10d14
    int32_t i_v36 = function_11d08(*(int32_t *)i_v35); // 0x10d20
    if (i_v36 < 0) {
        // 0x10e2c
        function_11468();
        // UNREACHABLE
    }
    int32_t i_v37 = function_11570(*(int32_t *)(i_v35 + 4), i_v1); // 0x10d3c
    if (i_v37 < 0) {
        // 0x10e2c
        function_11468();
        // UNREACHABLE
    }
    int32_t i_v38 = 1;  // 0x10d5c
    int32_t i_v39 = -1; // 0x10d5c
    if (i_v5 + 3 < i_a1) {
        // 0x10e30
        char *p_v40; // bp-68, 0x10c08
        int32_t i_v41 =
            strtol((char *)*(int32_t *)(i_v35 + 8), &p_v40, 0); // 0x10e3c
        if (*p_v40 != 0) {
            // 0x10e0c
            fwrite((int32_t *)"Error: Data address invalid!\n", 1, 29, p_g4);
            // 0x10e2c
            function_11468();
            // UNREACHABLE
        }
        // 0x10e54
        i_v38 = 2;
        i_v39 = i_v41;
        if (i_v41 >= 255 == (i_v41 != 255)) {
            // 0x10e0c
            fwrite((int32_t *)"Error: Data address invalid!\n", 1, 29, p_g4);
            // 0x10e2c
            function_11468();
            // UNREACHABLE
        }
    }
    uint32_t i_v42 = i_v39;
    int32_t i_v43 = i_v38; // 0x10d68
    if (i_v5 + 4 < i_a1) {
        // 0x10d6c
        i_v43 = 1;
        switch (*(char *)*(int32_t *)(i_v35 + 12)) {
        case 99: {
            goto lab_0x10e68;
        }
        case 119: {
            // 0x10fb8
            i_v43 = 3;
            goto lab_0x10e68;
        }
        case 98: {
            // 0x10fb0
            i_v43 = 2;
            goto lab_0x10e68;
        }
        default: {
            // 0x10d8c
            fwrite((int32_t *)"Error: Invalid mode!\n", 1, 21, p_g4);
            function_11468();
            // UNREACHABLE
        }
        }
    } else {
        goto lab_0x10e68;
    }
lab_0x10e68:;
    // 0x10e68
    int32_t i_v44;                                        // bp-60, 0x10c08
    int32_t i_v45 = function_11628(i_v36, &i_v44, 20, 0); // 0x10e78
    if (i_v45 < 0) {
        // 0x10f90
        exit(1);
        // UNREACHABLE
    }
    // 0x10e84
    if (ioctl(i_v45, 1797) < 0) {
        int32_t i_v46 = *__errno_location(); // 0x112f4
        fprintf(p_g4,
                "Error: Could not get the adapter functionality matrix: %s\n",
                strerror(i_v46));
        // 0x10f90
        exit(1);
        // UNREACHABLE
    }
    // 0x10e98
    int32_t i_v47; // 0x10c08
    switch (i_v43) {
    case 2: {
        if ((i_v47 & 0x80000) == 0) {
            // 0x10fc8
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "SMBus read byte");
            // 0x10f90
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x10ee4
        break;
    }
    case 3: {
        if ((i_v47 & 0x200000) == 0) {
            // 0x11340
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "SMBus read word");
            // 0x10f90
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x10ee4
        break;
    }
    default: {
        if ((i_v47 & 0x20000) == 0) {
            // 0x11364
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "SMBus receive byte");
            // 0x10f90
            exit(1);
            // UNREACHABLE
        }
        if ((i_v47 & 0x40000) == 0 == (i_v42 != -1)) {
            // 0x10f70
            fprintf(p_g4, "Error: Adapter does not have %s capability\n",
                    "SMBus send byte");
            // 0x10f90
            exit(1);
            // UNREACHABLE
        }
        // break -> 0x10ee4
        break;
    }
    }
    // 0x10ee4
    if (function_11e54(i_v45, i_v37, i_v3) != 0) {
        // 0x10f90
        exit(1);
        // UNREACHABLE
    }
    if (i_v4 == 0) {
        // 0x110b0
        fwrite((int32_t *)"WARNING! This program can confuse your I2C bus, "
                          "cause data loss and worse!\n",
               1, 75, p_g4);
        uint32_t i_v48 = i_v37 - 80; // 0x110d4
        if (i_v48 != 0 && i_v48 >= 7 != i_v48 != 7 && i_v48 != 7 &&
            i_v48 >= 7) {
            // 0x112a4
            fwrite(
                (int32_t *)"STOP! EEPROMs are I2C devices, not SMBus devices. "
                           "Using PEC\non I2C devices may result in unexpected "
                           "results, such as\ntrashing the contents of "
                           "EEPROMs. We can't let you do that, sorry.\n",
                1, 184, p_g4);
            // 0x111bc
            exit(0);
            // UNREACHABLE
        }
        // 0x110ec
        fprintf(p_g4, "I will read from device file %s, chip address 0x%02x, ",
                &i_v44, i_v37);
        char *p_v49; // 0x10c08
        if (i_v42 < 0 ? i_v42 == 0 : i_v43 == 1) {
            // 0x11110
            fprintf(p_g4, "data address\n0x%02x", i_v42);
            fprintf(p_g4, ", using %s.\n", "write byte/read byte");
            p_v49 = (char *)0x120fc;
        } else {
            // 0x111c4
            if (i_v42 == -1) {
                // 0x111e4
                fwrite((int32_t *)"current data\naddress", 1, 20, p_g4);
            } else {
                // 0x11314
                fprintf(p_g4, "data address\n0x%02x", i_v42);
            }
            int32_t i_v50 = i_v43 == 2 ? (int32_t) "read byte data"
                                       : (int32_t) "read word data";
            fprintf(p_g4, ", using %s.\n", (char *)i_v50);
            p_v49 = "Y/n";
        }
        // 0x11178
        fprintf(p_g4, "Continue? [%s] ", p_v49);
        fflush(p_g4);
        if (function_11ec8(1) == 0) {
            // 0x111a4
            fwrite((int32_t *)"Aborting on user request.\n", 1, 26, p_g4);
            // 0x111bc
            exit(0);
            // UNREACHABLE
        }
    }
    int32_t i_v51; // 0x10c08
    if (i_v43 == 1) {
        if (i_v42 != -1) {
            // 0x11040
            if (i2c_smbus_write_byte(i_v45, i_v42 % 256) < 0) {
                // 0x112c0
                fwrite((int32_t *)"Warning - write failed\n", 1, 23, p_g4);
            }
        }
        // 0x11054
        i_v51 = i2c_smbus_read_byte(i_v45);
    } else {
        uint32_t i_v52 = i_v42 % 256;
        if (i_v43 == 3) {
            int32_t i_v53 = i2c_smbus_read_word_data(i_v45, i_v52); // 0x10f24
            close(i_v45);
            if (i_v53 >= 0) {
                // 0x10f40
                printf("0x%0*x\n", 4, i_v53);
                exit(0);
                // UNREACHABLE
            }
            // 0x11010
            fwrite((int32_t *)"Error: Read failed\n", 1, 19, p_g4);
            exit(2);
            // UNREACHABLE
        }
        // 0x10fec
        i_v51 = i2c_smbus_read_byte_data(i_v45, i_v52);
    }
    // 0x10ff8
    close(i_v45);
    if (i_v51 >= 0) {
        // 0x10f40
        printf("0x%0*x\n", 2, i_v51);
        exit(0);
        // UNREACHABLE
    }
    // 0x11010
    fwrite((int32_t *)"Error: Read failed\n", 1, 19, p_g4);
    exit(2);
    // UNREACHABLE
}

// Address range: 0x11388 - 0x113ac
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x11388
    int32_t i_v1; // 0x11388
    __libc_start_main(0x10c08, i_a2, (char **)&i_v1, (void (*)())0x11f71,
                      (void (*)())0x10c08, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x113ac - 0x113b0
int32_t function_113ac(int32_t i_a1) {
    // 0x113ac
    return i_a1;
}

// Address range: 0x113b8 - 0x113d4
int32_t function_113b8(void) {
    // 0x113b8
    if (i_g3 == 0) {
        int32_t i_v1; // 0x113b8
        return i_v1;
    }
    // 0x113d0
    __gmon_start__();
    return &i_g8;
}

// Address range: 0x113dc - 0x113fa
int32_t function_113dc(void) {
    // 0x113dc
    return (int32_t)&p_g4;
}

// Address range: 0x11400 - 0x1142c
int32_t function_11400(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11400
    int32_t i_v1; // 0x11400
    int32_t i_v2 = i_v1;
    bool i_v3; // 0x11400
    if (i_v3) {
        return i_a1;
    }
    if (i_v3) {
        return unknown_22c0();
    }
    bool i_v4; // 0x11400
    if (!i_v3) {
        int32_t i_v5 = (i_v2 << i_v1) + i_v2;       // 0x11410
        int32_t i_v6 = i_v5 & -1 - 0x400000 * i_v5; // 0x11414
        i_v4 = i_v6 < 0;
        if (i_v6 == 0) {
            return unknown_240((int32_t)&i_g8);
        }
    }
    // 0x11424
    if (i_v4 != i_v3) {
        __asm_svclt(0x4770);
    }
    return i_a1;
}

// Address range: 0x1142c - 0x11444
int32_t function_1142c(void) {
    // 0x1142c
    int32_t i_v1; // 0x1142c
    if (*(char *)&p_g6 == 0) {
        int32_t i_v2 = function_113dc(); // 0x1143a
        *(char *)&p_g6 = 1;
        i_v1 = i_v2;
    }
    // 0x11442
    return i_v1;
}

// Address range: 0x11444 - 0x11448
int32_t function_11444(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x11444
    return i_a1;
}

// Address range: 0x1144a - 0x11456
int32_t function_1144a(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x1144a
    bool i_v1; // 0x1144a
    if (i_v1) {
        return i_a1;
    }
    int32_t i_v2 = i_a1; // 0x1144e
    int32_t i_v3;        // 0x1144a
    int16_t i_v4 = i_v3; // 0x1144e
    if (i_v1) {
        *(int16_t *)i_v3 = i_v4;
    }
    return i_v2;
}

// Address range: 0x11456 - 0x11458
int32_t function_11456(void) {
    // 0x11456
    int32_t i_v1; // 0x11456
    return function_11400(i_v1, i_v1, i_v1, i_v1);
}

// Address range: 0x11458 - 0x11464
int32_t function_11458(int32_t i_a1) {
    // 0x11458
    bool i_v1; // 0x11458
    if (i_v1) {
        return unknown_240(i_a1);
    }
    // 0x11460
    return i_a1;
}

// Address range: 0x11464 - 0x11468
int32_t function_11464(void) {
    // 0x11464
    int32_t i_v1; // 0x11464
    return i_v1;
}

// Address range: 0x11468 - 0x11494
int32_t function_11468(void) {
    // 0x11468
    fwrite((int32_t *)"Usage: i2cget [-f] [-y] [-a] I2CBUS CHIP-ADDRESS "
                      "[DATA-ADDRESS [MODE]]\n  I2CBUS is an integer or an I2C "
                      "bus name\n  ADDRESS is an integer (0x03 - 0x77, or 0x00 "
                      "- 0x7f if -a is given)\n  MODE is one of:\n    b (read "
                      "byte data, default)\n    w (read word data)\n    c "
                      "(write byte/read byte)\n    Append p for SMBus PEC\n",
           1, 311, p_g4);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x11494 - 0x114f0
int32_t function_11494(int32_t i_a1) {
    int32_t i_v1 = strlen((char *)i_a1); // 0x1149c
    int32_t i_v2 = i_v1 - 1;
    if (i_v2 < 0) {
        // 0x114e8
        return i_v2 + 2;
    }
    int32_t i_v3 = i_v2 + i_a1;
    char *p_v4 = (char *)i_v3;
    int32_t i_v5 = i_v2; // 0x11494
    int32_t i_v6;        // 0x11494
    int32_t i_v7;        // 0x11494
    switch (*p_v4) {
    case 32: {
    }
    case 10: {
        // 0x114bc
        *p_v4 = 0;
        if (i_v2 == 0) {
            // 0x114e8
            return 1;
        }
        // 0x114c8
        i_v6 = i_v3;
        i_v7 = i_v1 - 2;
        // break -> 0x114c8
        break;
    }
    default: {
        // 0x114e8
        return i_v5 + 2;
    }
    }
    int32_t i_v8; // 0x11494
    int32_t i_v9; // 0x114dc
    char *p_v10;  // 0x11494
    while (true) {
    lab_0x114c8:
        // 0x114c8
        i_v8 = i_v7;
        i_v9 = i_v6 - 1;
        p_v10 = (char *)i_v9;
        i_v5 = i_v8;
        switch (*p_v10) {
        case 32: {
            goto lab_0x114d8;
        }
        case 10: {
            goto lab_0x114d8;
        }
        default: {
            return i_v5 + 2;
        }
        }
    }
    // 0x114e8
    return i_v5 + 2;
lab_0x114d8:
    // 0x114d8
    *p_v10 = 0;
    i_v6 = i_v9;
    i_v7 = i_v8 - 1;
    i_v5 = -1;
    if (i_v8 == 0) {
        return i_v5 + 2;
    }
    goto lab_0x114c8;
}

// Address range: 0x114f0 - 0x11528
int32_t function_114f0(int32_t i_a1) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 4); // 0x114f8
    int32_t i_v2 = i_a1;                   // 0x11504
    if (i_v1 == 0) {
        // 0x1151c
        free((int32_t *)i_a1);
        return &i_g8;
    }
    free((int32_t *)i_v1);
    int32_t i_v3 = *(int32_t *)(i_v2 + 20); // 0x11510
    i_v2 += 16;
    while (i_v3 != 0) {
        // 0x11508
        free((int32_t *)i_v3);
        i_v3 = *(int32_t *)(i_v2 + 20);
        i_v2 += 16;
    }
    // 0x1151c
    free((int32_t *)i_a1);
    return &i_g8;
}

// Address range: 0x11528 - 0x11570
int32_t function_11528(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 16 * i_a2;                             // 0x11528
    int32_t *p_v2 = realloc((int32_t *)i_a1, i_v1 + 128); // 0x1153c
    int32_t i_v3 = (int32_t)p_v2;                         // 0x1153c
    if (p_v2 == NULL) {
        // 0x11564
        function_114f0(i_a1);
    } else {
        // 0x11548
        memset((int32_t *)(i_v1 + i_v3), 0, 128);
    }
    // 0x1155c
    return i_v3;
}

// Address range: 0x11570 - 0x11628
int32_t function_11570(int32_t i_a1, int32_t i_a2) {
    // 0x11570
    char *p_v1;                                    // bp-20, 0x11570
    int32_t i_v2 = strtol((char *)i_a1, &p_v1, 0); // 0x11588
    if ((char)i_v2 == 0 | *p_v1 != 0) {
        // 0x115e0
        fwrite((int32_t *)"Error: Chip address is not a number!\n", 1, 37,
               p_g4);
        // 0x115d8
        return -1;
    }
    int32_t i_v3 = i_a2 == 0 ? 119 : 127;
    int32_t i_v4 = i_a2 == 0 ? 3 : 0;
    int32_t i_v5 = i_v2; // 0x115d4
    if (i_v2 > i_v3 || i_v2 < i_v4) {
        // 0x11608
        fprintf(p_g4, "Error: Chip address out of range (0x%02lx-0x%02lx)!\n",
                i_v4, i_v3);
        i_v5 = -2;
    }
    // 0x115d8
    return i_v5;
}

// Address range: 0x11628 - 0x11764
int32_t function_11628(int32_t i_a1, int32_t *p_a2, int32_t i_a3,
                       int32_t i_a4) {
    // 0x11628
    snprintf((char *)p_a2, i_a3, "/dev/i2c/%d", i_a1);
    *(char *)(i_a3 - 1 + (int32_t)p_a2) = 0;
    int32_t i_v1 = open64((char *)p_a2, 2); // 0x1166c
    if (i_v1 >= 0) {
        // 0x11678
        return i_v1;
    }
    int32_t i_v2 = *__errno_location(); // 0x11688
    int32_t i_v3 = i_v1;                // 0x11628
    switch (i_v2) {
    case 20: {
    }
    case 2: {
        // 0x11704
        sprintf((char *)p_a2, "/dev/i2c-%d", i_a1);
        i_v3 = open64((char *)p_a2, 2);
        // break -> 0x11678
        break;
    }
    }
    // 0x11678
    return i_v3;
}

// Address range: 0x11764 - 0x11d08
int32_t function_11764(void) {
    // 0x11764
    int32_t i_v1; // 0x11764
    uint32_t i_v2 = i_v1;
    int32_t *p_v3 = calloc(8, 16); // 0x11774
    int32_t i_v4 = (int32_t)p_v3;  // 0x11774
    if (p_v3 == NULL) {
        // 0x118e0
        return i_v4;
    }
    struct _IO_FILE *p_v5 = fopen64("/proc/bus/i2c", "r"); // 0x11790
    struct dirent64 *p_v6;                                 // 0x11764
    int32_t i_v7;                                          // 0x11764
    int32_t i_v8;                                          // 0x11764
    int32_t i_v9;                                          // 0x11764
    int32_t i_v10;                                         // 0x11764
    int32_t i_v11;                                         // bp-296, 0x11764
    int32_t i_v12;                                         // bp-552, 0x11764
    struct __dirstream *p_v13;                             // 0x119b0
    if (p_v5 == NULL) {
        struct _IO_FILE *p_v14 = fopen64("/proc/mounts", "r"); // 0x118f8
        if (p_v14 == NULL) {
            // 0x118e0
            return i_v4;
        }
        while (fgets((char *)&i_v11, 255, p_v14) != NULL) {
            // 0x11908
            int32_t i_v15; // bp-808, 0x11764
            sscanf((char *)&i_v11, "%*[^ ] %[^ ] %[^ ] %*s\n", &i_v12, &i_v15);
            if (strcasecmp((char *)&i_v15, "sysfs") == 0) {
                // 0x11960
                fclose(p_v14);
                int32_t i_v16 =
                    strlen((char *)&i_v12) + (int32_t)&i_v12; // 0x11984
                *(int32_t *)i_v16 = 0x616c632f;
                *(int32_t *)(i_v16 + 4) = 0x692f7373;
                *(int32_t *)(i_v16 + 8) = 0x642d6332;
                *(int16_t *)(i_v16 + 12) = 0x7665;
                *(char *)(i_v16 + 14) = 0;
                p_v13 = opendir((char *)&i_v12);
                i_v9 = i_v4;
                if (p_v13 == NULL) {
                    return i_v9;
                } else {
                    struct dirent64 *p_v17 = readdir64(p_v13); // 0x119c0
                    i_v8 = i_v4;
                    if (p_v17 == NULL) {
                        goto lab_0x11b04;
                    } else {
                        // 0x119cc
                        p_v6 = p_v17;
                        i_v7 = i_v4;
                        i_v10 = 0;
                        goto lab_0x119cc_2;
                    }
                }
            }
        }
        // 0x11950
        fclose(p_v14);
        // 0x118e0
        return i_v4;
    }
    // 0x11898
    int32_t i_v18;                                  // bp-928, 0x11764
    char *p_v19 = fgets((char *)&i_v18, 120, p_v5); // 0x118a8
    int32_t i_v20 = 1;                              // 0x118bc
    int32_t i_v21 = i_v4;                           // 0x118bc
    int32_t i_v22 = 0;                              // 0x118bc
    if (p_v19 == NULL) {
        // 0x118c0
        fclose(p_v5);
        return i_v4;
    }
    int32_t i_v23; // 0x11764
    while (true) {
        int32_t i_v24 = i_v21;
        uint32_t i_v25 = i_v20;
        char *p_v26 = strrchr((char *)&i_v18, 9); // 0x117b0
        *p_v26 = 0;
        char *p_v27 = strrchr((char *)&i_v18, 9); // 0x117d0
        *p_v27 = 0;
        char *p_v28 = strrchr((char *)&i_v18, 9); // 0x117f0
        *p_v28 = 0;
        sscanf((char *)&i_v18, "i2c-%d", &i_v11);
        int32_t i_v29 = i_v24; // 0x11830
        if (i_v25 % 8 == 0) {
            // 0x11834
            i_v29 = function_11528(i_v24, i_v25);
            i_v9 = 0;
            if (i_v29 == 0) {
                // break -> 0x118e0
                break;
            }
        }
        int32_t i_v30 = (int32_t)p_v26 + 1; // 0x117b4
        int32_t i_v31 = (int32_t)p_v27 + 1; // 0x117d4
        int32_t i_v32 = (int32_t)p_v28 + 1; // 0x117f4
        int32_t i_v33 = i_v32 + i_v31;      // 0x11814
        i_v21 = i_v29;
        int32_t *p_v34 = malloc(i_v33 + i_v30); // 0x11850
        i_v23 = i_v21;
        if (p_v34 == NULL) {
            goto lab_0x118d4;
        }
        int32_t i_v35 = i_v21 + i_v22;  // 0x11844
        int32_t i_v36 = (int32_t)p_v34; // 0x11850
        *(int32_t *)i_v35 = i_v11;
        char *p_v37 = strcpy((char *)p_v34, (char *)i_v31); // 0x1186c
        *(int32_t *)(i_v35 + 4) = (int32_t)p_v37;
        char *p_v38 = strcpy((char *)(i_v31 + i_v36), (char *)i_v32); // 0x1187c
        *(int32_t *)(i_v35 + 8) = (int32_t)p_v38;
        char *p_v39 = strcpy((char *)(i_v33 + i_v36), (char *)i_v30); // 0x11890
        *(int32_t *)(i_v35 + 12) = (int32_t)p_v39;
        char *p_v40 = fgets((char *)&i_v18, 120, p_v5); // 0x118a8
        i_v20 = i_v25 + 1;
        i_v22 += 16;
        int32_t i_v41 = i_v21; // 0x118bc
        if (p_v40 == NULL) {
            // 0x118c0
            fclose(p_v5);
            return i_v41;
        }
    }
lab_0x118e0:
    // 0x118e0
    return i_v9;
lab_0x118d4:
    // 0x118d4
    function_114f0(i_v23);
    i_v9 = 0;
    return i_v9;
lab_0x11b04:
    // 0x11b04
    closedir(p_v13);
    i_v9 = i_v8;
    goto lab_0x118e0;
lab_0x119cc_2:;
    struct dirent64 *p_v42 = p_v6; // 0x11764
    int32_t i_v43 = i_v10;         // 0x11764
    int32_t i_v44 = i_v7;          // 0x11764
    goto lab_0x119cc_3;
lab_0x119cc_3:;
    int32_t i_v45 = i_v44;
    int32_t i_v46 = i_v43;
    int32_t i_v47 = (int32_t)p_v42;
    char *p_v48 = (char *)(i_v47 + 19); // 0x119cc
    if (*p_v48 == 46) {
        // 0x11b14
        switch (*(char *)(i_v47 + 20)) {
        case 0: {
            goto lab_0x119bc_2;
        }
        case 46: {
            // 0x11b28
            if (*(char *)(i_v47 + 21) == 0) {
                goto lab_0x119bc_2;
            } else {
                goto lab_0x119d8;
            }
        }
        default: {
            goto lab_0x119d8;
        }
        }
    } else {
        goto lab_0x119d8;
    }
lab_0x119d8:;
    // 0x119d8
    struct dirent64 *p_v49;    // 0x11764
    struct _IO_FILE *p_v50;    // 0x11764
    struct __dirstream *p_v51; // 0x11bbc
    if (snprintf((char *)&i_v11, 255, "%s/%s/name", &i_v12, p_v48) > 254) {
        // 0x11b38
        fprintf(p_g4, "%s: path truncated\n", &i_v11);
        goto lab_0x119bc_2;
    } else {
        struct _IO_FILE *p_v52 = fopen64((char *)&i_v11, "r"); // 0x11a0c
        p_v50 = p_v52;
        if (p_v52 == NULL) {
            int32_t i_v53 = snprintf((char *)&i_v11, 255, "%s/%s/device/name",
                                     &i_v12, p_v48); // 0x11b70
            if (i_v53 > 254) {
                // 0x11b38
                fprintf(p_g4, "%s: path truncated\n", &i_v11);
                goto lab_0x119bc_2;
            } else {
                struct _IO_FILE *p_v54 =
                    fopen64((char *)&i_v11, "r"); // 0x11b88
                p_v50 = p_v54;
                if (p_v54 == NULL) {
                    // 0x11b94
                    if (snprintf((char *)&i_v11, 255, "%s/%s/device", &i_v12,
                                 p_v48) > 254) {
                        // 0x11b38
                        fprintf(p_g4, "%s: path truncated\n", &i_v11);
                        goto lab_0x119bc_2;
                    } else {
                        // 0x11bb8
                        p_v51 = opendir((char *)&i_v11);
                        if (p_v51 == NULL) {
                            goto lab_0x119bc_2;
                        } else {
                            struct dirent64 *p_v55 =
                                readdir64(p_v51); // 0x11bcc
                            p_v49 = p_v55;
                            if (p_v55 == NULL) {
                                goto lab_0x119bc_2;
                            } else {
                                goto lab_0x11be8;
                            }
                        }
                    }
                } else {
                    goto lab_0x11a18;
                }
            }
        } else {
            goto lab_0x11a18;
        }
    }
lab_0x119bc_2:;
    struct dirent64 *p_v56 = readdir64(p_v13); // 0x119c0
    p_v6 = p_v56;
    i_v7 = i_v45;
    i_v10 = i_v46;
    i_v8 = i_v45;
    if (p_v56 == NULL) {
        goto lab_0x11b04;
    } else {
        goto lab_0x119cc_2;
    }
lab_0x11a18:;
    char *p_v57 = fgets((char *)&i_v18, 120, p_v50); // 0x11a28
    fclose(p_v50);
    if (p_v57 == NULL) {
        // 0x11ce8
        fprintf(p_g4, "%s: read error\n", &i_v11);
        goto lab_0x119bc_2;
    } else {
        char *p_v58 = strchr((char *)&i_v18, 10); // 0x11a48
        if (p_v58 == NULL) {
            goto lab_dec_label_pc_0x11a68;
        } else {
            *p_v58 = 0;
            goto lab_dec_label_pc_0x11a68;
        }
    }
lab_dec_label_pc_0x11a68:;
    int32_t i_v59; // 0x11764
    int32_t i_v60; // bp-956, 0x11764
    if (sscanf(p_v48, "i2c-%d", &i_v60) == 0) {
        goto lab_0x119bc_2;
    } else {
        int32_t i_v61 = strncmp((char *)&i_v18, "ISA ", 4); // 0x11a84
        i_v59 = 8;
        if (i_v61 == 0) {
            goto lab_0x11a94;
        } else {
            // 0x11c78
            int32_t i_v62; // bp-948, 0x11764
            int32_t i_v63 = function_11628(i_v60, &i_v62, 20, 1); // 0x11c88
            i_v59 = 32;
            if (i_v63 >= 0) {
                int32_t i_v64 =
                    ioctl(i_v63, 1797) >= 0
                        ? i_v2 % 2 == 0 ? (i_v2 & 0x7e0000) == 0 ? 0 : 24 : 16
                        : 32;
                close(i_v63);
                i_v59 = i_v64;
                goto lab_0x11a94;
            } else {
                goto lab_0x11a94;
            }
        }
    }
lab_0x11a94:;
    int32_t i_v65 = i_v46 + 1; // 0x11a94
    int32_t i_v66 = i_v45;     // 0x11a9c
    if (i_v65 % 8 == 0) {
        int32_t i_v67 = function_11528(i_v45, i_v65); // 0x11aa8
        i_v9 = 0;
        i_v66 = i_v67;
        if (i_v67 == 0) {
            goto lab_0x118e0;
        } else {
            goto lab_0x11ab4;
        }
    } else {
        goto lab_0x11ab4;
    }
lab_0x11be8:;
    int32_t i_v68 = (int32_t)p_v49;
    char *p_v69 = (char *)(i_v68 + 19); // 0x11be8
    if (*p_v69 == 46) {
        // 0x11c54
        switch (*(char *)(i_v68 + 20)) {
        case 0: {
            goto lab_0x11bc8_2;
        }
        case 46: {
            // 0x11c68
            if (*(char *)(i_v68 + 21) == 0) {
                goto lab_0x11bc8_2;
            } else {
                goto lab_0x11bf8;
            }
        }
        default: {
            goto lab_0x11bf8;
        }
        }
    } else {
        goto lab_0x11bf8;
    }
lab_0x11ab4:;
    int32_t i_v70 = i_v66 + 16 * i_v46; // 0x11abc
    *(int32_t *)i_v70 = i_v60;
    char *p_v71 = __strdup((char *)&i_v18); // 0x11ac4
    *(int32_t *)(i_v70 + 4) = (int32_t)p_v71;
    i_v23 = i_v66;
    if (p_v71 == NULL) {
        goto lab_0x118d4;
    } else {
        int32_t i_v72 = *(int32_t *)(i_v59 + (int32_t)&x_g1);     // 0x11ae4
        int32_t i_v73 = *(int32_t *)(i_v59 + (int32_t)&x_g1 + 4); // 0x11aec
        *(int32_t *)(i_v70 + 8) = i_v72;
        *(int32_t *)(i_v70 + 12) = i_v73;
        struct dirent64 *p_v74 = readdir64(p_v13); // 0x11af8
        p_v42 = p_v74;
        i_v43 = i_v65;
        i_v44 = i_v66;
        i_v8 = i_v66;
        if (p_v74 == NULL) {
            goto lab_0x11b04;
        } else {
            goto lab_0x119cc_3;
        }
    }
lab_0x11bf8:
    // 0x11bf8
    if (strncmp(p_v69, "i2c-", 4) == 0) {
        int32_t i_v75 = snprintf((char *)&i_v11, 255, "%s/%s/device/%s/name",
                                 &i_v12, p_v48, p_v69); // 0x11c1c
        if (i_v75 < 255) {
            struct _IO_FILE *p_v76 = fopen64((char *)&i_v11, "r"); // 0x11cd8
            p_v50 = p_v76;
            if (p_v76 == NULL) {
                goto lab_0x11bc8_2;
            } else {
                goto lab_0x11a18;
            }
        } else {
            // 0x11c40
            fprintf(p_g4, "%s: path truncated\n", &i_v11);
            goto lab_0x11bc8_2;
        }
    } else {
        goto lab_0x11bc8_2;
    }
lab_0x11bc8_2:;
    struct dirent64 *p_v77 = readdir64(p_v51); // 0x11bcc
    p_v49 = p_v77;
    if (p_v77 == NULL) {
        goto lab_0x119bc_2;
    } else {
        goto lab_0x11be8;
    }
}

// Address range: 0x11d08 - 0x11e54
int32_t function_11d08(int32_t i_a1) {
    char *p_v1 = (char *)i_a1;              // 0x11d1c
    char *p_v2;                             // bp-28, 0x11d08
    int32_t i_v3 = strtoul(p_v1, &p_v2, 0); // 0x11d1c
    if (!(((char)i_v3 == 0 | *p_v2 != 0))) {
        int32_t i_v4 = i_v3; // 0x11d40
        if (i_v3 >= 0x100000) {
            // 0x11e04
            fwrite((int32_t *)"Error: I2C bus out of range!\n", 1, 29, p_g4);
            i_v4 = -2;
        }
        // 0x11d44
        return i_v4;
    }
    int32_t i_v5 = function_11764(); // 0x11d4c
    if (i_v5 == 0) {
        // 0x11e2c
        fwrite((int32_t *)"Error: Out of memory!\n", 1, 22, p_g4);
        // 0x11d44
        return -3;
    }
    int32_t i_v6 = *(int32_t *)(i_v5 + 4); // 0x11d58
    int32_t i_v7 = i_v6;                   // 0x11d68
    int32_t i_v8 = i_v5;                   // 0x11d68
    int32_t i_v9 = -1;                     // 0x11d68
    if (i_v6 == 0) {
        goto lab_0x11ddc;
    lab_0x11ddc:
        // 0x11ddc
        fwrite(
            (int32_t *)"Error: I2C bus name doesn't match any bus present!\n",
            1, 51, p_g4);
        // 0x11da0
        function_114f0(i_v5);
        return -1;
    }
    while (true) {
        int32_t i_v10 = i_v9;
        int32_t i_v11 = i_v8;
        int32_t i_v12 = i_v10; // 0x11d78
        if (strcmp((char *)i_v7, p_v1) == 0) {
            if (i_v10 >= 0) {
                // break -> 0x11db4
                break;
            }
            // 0x11d84
            i_v12 = *(int32_t *)i_v11;
        }
        // 0x11d88
        i_v9 = i_v12;
        i_v7 = *(int32_t *)(i_v11 + 20);
        i_v8 = i_v11 + 16;
        if (i_v7 == 0) {
            // 0x11d98
            if (i_v9 == -1) {
                goto lab_0x11ddc;
            } else {
                goto lab_0x11da0;
            }
        }
    }
    // 0x11db4
    fwrite((int32_t *)"Error: I2C bus name is not unique!\n", 1, 35, p_g4);
    i_v9 = -4;
lab_0x11da0:
    // 0x11da0
    function_114f0(i_v5);
    return i_v9;
}

// Address range: 0x11e54 - 0x11ec8
int32_t function_11e54(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x11e54
    if (ioctl(i_a1, i_a3 == 0 ? 1795 : 1798) >= 0) {
        // 0x11e80
        return 0;
    }
    int32_t *p_v1 = __errno_location(); // 0x11e94
    fprintf(p_g4, "Error: Could not set address to 0x%02x: %s\n", i_a2,
            strerror(*p_v1));
    return -*p_v1;
}

// Address range: 0x11ec8 - 0x11f70
int32_t function_11ec8(int32_t i_a1) {
    // 0x11ec8
    int32_t i_v1; // bp-20, 0x11ec8
    if (fgets((char *)&i_v1, 2, p_g5) == NULL) {
        // 0x11f40
        return 0;
    }
    uint32_t i_v2 = i_v1;       // 0x11ef4
    uint32_t i_v3 = i_v2 % 256; // 0x11ef4
    int32_t i_v4;               // 0x11ec8
    int32_t i_v5;               // 0x11ec8
    if (i_v3 == 89) {
        // 0x11f5c
        i_v5 = 1;
        goto lab_0x11f2c;
    } else {
        char i_v6 = i_v2;
        if (i_v3 < 89) {
            // 0x11f4c
            i_v5 = i_a1;
            i_v4 = i_a1;
            switch (i_v6) {
            case 78: {
                // 0x11f54
                i_v5 = 0;
                goto lab_0x11f2c;
            }
            case 10: {
                return i_v4;
            }
            default: {
                goto lab_0x11f2c;
            }
            }
        } else {
            // 0x11f04
            i_v5 = i_a1;
            i_v4 = i_a1;
            switch (i_v6) {
            case 110: {
                // 0x11f54
                i_v5 = 0;
                goto lab_0x11f2c;
            }
            case 121: {
                // 0x11f5c
                i_v5 = 1;
                goto lab_0x11f2c;
            }
            case 10: {
                return i_v4;
            }
            default: {
                goto lab_0x11f2c;
            }
            }
        }
    }
lab_0x11f2c:
    // 0x11f2c
    while (true) {
        uint32_t i_v7 = fgetc(p_g5); // 0x11f30
        i_v4 = 0;
        if (i_v7 == -1) {
            // break -> 0x11f40
            break;
        }
        // 0x11f20
        i_v1 = 0x1000000 * i_v7 / 0x1000000;
        i_v4 = i_v5;
        if (i_v7 % 256 == 10) {
            // break -> 0x11f40
            break;
        }
    }
    // 0x11f40
    return i_v4;
}

// Address range: 0x11f70 - 0x11fa8
int32_t function_11f70(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_109f0(i_a1, i_a2, i_a3, i_a4); // 0x11f82
    return (int32_t)&i_g2 - 0x166f8 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x11fb4 - 0x11fbc
int32_t function_11fb4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11fb4
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 67
