//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <errno.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_107c4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_107e4(char *format, ...);
int32_t function_107f0(struct _IO_FILE *stream);
int32_t function_107fc(struct _IO_FILE *fp);
int32_t function_10808(int32_t c, struct _IO_FILE *fp);
int32_t function_10814(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
int32_t function_10820(int32_t fd, int32_t request, ...);
int32_t function_1082c(int32_t useconds);
int32_t function_10838(int32_t i_a1, int32_t i_a2);
int32_t function_10844(char *file, int32_t oflag, ...);
char *function_10850(char *name);
int32_t function_1085c(char *s);
int32_t function_10868(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
char *function_10874(int32_t errnum);
void function_10880(void);
void function_1088c(int32_t status);
int32_t function_10898(char *nptr, char **endptr, int32_t base);
int32_t function_108a4(int32_t i_a1);
int32_t function_108b0(char *s);
int32_t function_108bc(int32_t argc, char **argv, char *shortopts);
int32_t function_108c8(struct _IO_FILE *stream, char *format, ...);
int32_t function_108d4(void);
int32_t *function_108e0(void);
int32_t function_108ec(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6, int32_t i_a7);
int32_t function_108f8(int32_t c, struct _IO_FILE *stream);
int32_t function_10904(int32_t ver, char *filename, struct stat64 *stat_buf);
void function_10910(void);
int32_t function_1091c(int32_t fd);
int32_t function_10928(int32_t i_a1, int32_t i_a2);
int32_t function_10d94(int32_t i_a1);
int32_t function_10da0(void);
int32_t function_10dc4(void);
int32_t function_10de8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10e20(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5);
int32_t function_10e2c(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_10e32(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10e3e(void);
int32_t function_10e40(int32_t i_a1);
int32_t function_10e4c(void);
int32_t function_10e50(int32_t i_a1);
int32_t function_10e80(char *p_a1, int32_t i_a2);
int32_t function_10eac(int32_t i_a1, int32_t i_a2);
int32_t function_10ec0(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_10ed8(int32_t i_a1, int32_t *p_a2, int32_t *p_a3);
int32_t function_10f30(void);
int32_t function_10f6c(int32_t *p_a1, uint32_t i_a2, int32_t i_a3,
                       int32_t i_a4);
int32_t function_11094(int32_t *p_a1, int32_t i_a2);
int32_t function_11158(int32_t i_a1, int32_t i_a2);
int32_t function_111b0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_11334(int32_t *p_a1);
int32_t function_11360(int32_t i_a1);
int32_t function_11380(int32_t i_a1, uint32_t i_a2);
int32_t function_11460(int32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t function_11520(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_11564(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_22c0(void);
int32_t unknown_240(int32_t i_a1);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0x10e15;       // 0x220a0
int32_t i_g2 = 0;             // 0x22210
char **p_g3 = NULL;           // 0x22220
struct _IO_FILE *p_g4 = NULL; // 0x22228
struct _IO_FILE *p_g5 = NULL; // 0x22230
struct _IO_FILE *p_g6 = NULL; // 0x22234
char *p_g7;                   // 0x22238
int32_t i_g8 = 0;             // 0x22240
int32_t i_g9;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
int32_t __xstat64(int32_t i_a1, char *p_a2, struct stat64 *p_a3);
int32_t i2c_smbus_read_byte(int32_t i_a1);
int32_t i2c_smbus_write_byte(int32_t i_a1, int32_t i_a2);
int32_t i2c_smbus_write_byte_data(void);
int32_t i2c_smbus_write_word_data(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                  int32_t i_a4, int32_t i_a5, int32_t i_a6,
                                  int32_t i_a7);
int32_t open64(char *p_a1, int32_t i_a2, ...);

// ------------------------ Functions -------------------------

// Address range: 0x107c4 - 0x107d0
int32_t function_107c4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x107c4
    return function_10da0();
}

// Address range: 0x107e4 - 0x107f0
int32_t function_107e4(char *format, ...) {
    // 0x107e4
    return printf(format);
}

// Address range: 0x107f0 - 0x107fc
int32_t function_107f0(struct _IO_FILE *stream) {
    // 0x107f0
    return fflush(stream);
}

// Address range: 0x107fc - 0x10808
int32_t function_107fc(struct _IO_FILE *fp) {
    // 0x107fc
    return _IO_getc(fp);
}

// Address range: 0x10808 - 0x10814
int32_t function_10808(int32_t c, struct _IO_FILE *fp) {
    // 0x10808
    return _IO_putc(c, fp);
}

// Address range: 0x10814 - 0x10820
int32_t function_10814(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x10814
    return fwrite(ptr, size, n, s);
}

// Address range: 0x10820 - 0x1082c
int32_t function_10820(int32_t fd, int32_t request, ...) {
    // 0x10820
    return ioctl(fd, request);
}

// Address range: 0x1082c - 0x10838
int32_t function_1082c(int32_t useconds) {
    // 0x1082c
    return usleep(useconds);
}

// Address range: 0x10838 - 0x10844
int32_t function_10838(int32_t i_a1, int32_t i_a2) {
    // 0x10838
    return i2c_smbus_write_byte(i_a1, i_a2);
}

// Address range: 0x10844 - 0x10850
int32_t function_10844(char *file, int32_t oflag, ...) {
    // 0x10844
    return open64(file, oflag);
}

// Address range: 0x10850 - 0x1085c
char *function_10850(char *name) {
    // 0x10850
    return getenv(name);
}

// Address range: 0x1085c - 0x10868
int32_t function_1085c(char *s) {
    // 0x1085c
    return puts(s);
}

// Address range: 0x10868 - 0x10874
int32_t function_10868(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x10868
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10874 - 0x10880
char *function_10874(int32_t errnum) {
    // 0x10874
    return strerror(errnum);
}

// Address range: 0x10880 - 0x1088c
void function_10880(void) {
    // 0x10880
    __gmon_start__();
}

// Address range: 0x1088c - 0x10898
void function_1088c(int32_t status) {
    // 0x1088c
    exit(status);
}

// Address range: 0x10898 - 0x108a4
int32_t function_10898(char *nptr, char **endptr, int32_t base) {
    // 0x10898
    return strtoul(nptr, endptr, base);
}

// Address range: 0x108a4 - 0x108b0
int32_t function_108a4(int32_t i_a1) {
    // 0x108a4
    return i2c_smbus_read_byte(i_a1);
}

// Address range: 0x108b0 - 0x108bc
int32_t function_108b0(char *s) {
    // 0x108b0
    return strlen(s);
}

// Address range: 0x108bc - 0x108c8
int32_t function_108bc(int32_t argc, char **argv, char *shortopts) {
    // 0x108bc
    return getopt(argc, argv, shortopts);
}

// Address range: 0x108c8 - 0x108d4
int32_t function_108c8(struct _IO_FILE *stream, char *format, ...) {
    // 0x108c8
    return fprintf(stream, format);
}

// Address range: 0x108d4 - 0x108e0
int32_t function_108d4(void) {
    // 0x108d4
    return i2c_smbus_write_byte_data();
}

// Address range: 0x108e0 - 0x108ec
int32_t *function_108e0(void) {
    // 0x108e0
    return __errno_location();
}

// Address range: 0x108ec - 0x108f8
int32_t function_108ec(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6, int32_t i_a7) {
    // 0x108ec
    return i2c_smbus_write_word_data(i_a1, i_a2, i_a3, i_a4, i_a5, i_a6, i_a7);
}

// Address range: 0x108f8 - 0x10904
int32_t function_108f8(int32_t c, struct _IO_FILE *stream) {
    // 0x108f8
    return fputc(c, stream);
}

// Address range: 0x10904 - 0x10910
int32_t function_10904(int32_t ver, char *filename, struct stat64 *stat_buf) {
    // 0x10904
    return __xstat64(ver, filename, stat_buf);
}

// Address range: 0x10910 - 0x1091c
void function_10910(void) {
    // 0x10910
    abort();
}

// Address range: 0x1091c - 0x10928
int32_t function_1091c(int32_t fd) {
    // 0x1091c
    return close(fd);
}

// Address range: 0x10928 - 0x10d70
int32_t function_10928(int32_t i_a1, int32_t i_a2) {
    // 0x10928
    i_g8 = 0;
    int32_t i_v1 = 0; // 0x10964
    int32_t i_v2 = 0; // 0x10964
    int32_t i_v3 = 0; // 0x10964
    int32_t i_v4 = 0; // 0x10964
    int32_t i_v5 = 0; // 0x10964
    int32_t i_v6 = 0; // 0x10964
    int32_t i_v7;     // 0x10928
    int32_t i_v8;     // 0x10928
    int32_t i_v9;     // 0x10928
    int32_t i_v10;    // 0x10928
    while (true) {
        // 0x10968
        i_v9 = i_v4;
        i_v10 = i_v1;
        int32_t i_v11 = i_v2; // 0x10928
        while (true) {
            // 0x10968
            i_v2 = i_v11;
            i_v8 = i_v3;
            while (true) {
            lab_0x10968_4:
                // 0x10968
                i_v3 = i_v8;
                int32_t i_v12 = i_v5; // 0x10928
                while (true) {
                lab_0x10968_2:
                    // 0x10968
                    i_v5 = i_v12;
                    int32_t i_v13 = i_v6; // 0x10928
                    while (true) {
                        // 0x10968
                        i_v6 = i_v13;
                        while (true) {
                        lab_0x10968:
                            // 0x10968
                            i_v4 = getopt(i_a1, (char **)i_a2, "1:8fr:qhw:xd");
                            switch (i_v4) {
                            case -1: {
                                goto lab_0x10a54;
                            }
                            case 102: {
                                goto lab_0x109e0;
                            }
                            default: {
                                if (i_v4 <= 102) {
                                    // break (via goto) -> 0x10990
                                    goto lab_0x10990;
                                }
                                switch (i_v4) {
                                case 113: {
                                    // 0x10a3c
                                    i_g8++;
                                    goto lab_0x10968;
                                }
                                case 120: {
                                    goto lab_0x10a2c;
                                }
                                case 104: {
                                    // 0x109d8
                                    function_10e50(203);
                                    // UNREACHABLE
                                }
                                default: {
                                    goto lab_0x109a8;
                                }
                                }
                            }
                            }
                        }
                    lab_0x109e0:
                        // 0x109e0
                        i_v13 = i_v6 + 1;
                    }
                lab_0x10990:
                    switch (i_v4) {
                    case 56: {
                        goto lab_0x10a1c;
                    }
                    case 100: {
                        // 0x10a14
                        i_v12 = i_v5 + 1;
                        goto lab_0x10968_2;
                    }
                    case 49: {
                        // 0x109e8
                        if (*p_g7 != 54 || strlen(p_g7) != 1) {
                            // 0x10a4c
                            function_10e50(182);
                            // UNREACHABLE
                        }
                        // 0x10a04
                        i_v7 = 2;
                        if (i_v3 != 0) {
                            // 0x10d50
                            function_10e80(
                                "EEPROM type switch (-8 or -16) used twice",
                                183);
                            // UNREACHABLE
                        }
                        goto lab_0x10968_3;
                    }
                    default: {
                        goto lab_0x109a8;
                    }
                    }
                }
            lab_0x10a1c:
                // 0x10a1c
                i_v7 = 1;
                if (i_v3 != 0) {
                    // 0x10d40
                    function_10e80("EEPROM type switch (-8 or -16) used twice",
                                   193);
                    // UNREACHABLE
                }
                goto lab_0x10968_3;
            }
        lab_0x10a2c:
            // 0x10a2c
            i_v11 = i_v2 + 1;
        }
    lab_0x109a8:
        if (i_v9 != 0) {
            // 0x10d60
            return function_10e80("Both read and write requested", 206);
        }
        // 0x109b0
        i_v1 = (int32_t)p_g7;
    }
lab_0x10a54:
    if (i_v9 == 0) {
        // 0x10d38
        function_10e50(214);
        // UNREACHABLE
    }
    int32_t i_v14 = (int32_t)p_g3; // 0x10a70
    int32_t i_v15;                 // 0x10928
    int32_t i_v16;                 // 0x10928
    switch (i_a1 - i_v14) {
    case 1: {
        int32_t i_v17 = *(int32_t *)(4 * i_v14 + i_a2); // 0x10b9c
        int32_t i_v18;                                  // bp-144, 0x10928
        if (__xstat64(3, (char *)i_v17, (struct stat64 *)&i_v18) == -1) {
            char *p_v19 = getenv("EEPROG_DEV"); // 0x10cb4
            i_v15 = *(int32_t *)(4 * (int32_t)p_g3 + i_a2);
            i_v16 = (int32_t)p_v19;
        } else {
            // 0x10bbc
            i_v15 = (int32_t)getenv("EEPROG_I2C_ADDR");
            i_v16 = *(int32_t *)(4 * (int32_t)p_g3 + i_a2);
        }
        // break -> 0x10ab4
        break;
    }
    case 2: {
        int32_t i_v20 = 4 * i_v14 + i_a2; // 0x10b84
        *(int32_t *)&p_g3 = i_v14 + 1;
        i_v15 = *(int32_t *)(i_v20 + 4);
        i_v16 = *(int32_t *)i_v20;
        // break -> 0x10ab4
        break;
    }
    case 0: {
        char *p_v21 = getenv("EEPROG_DEV"); // 0x10aa0
        i_v15 = (int32_t)getenv("EEPROG_I2C_ADDR");
        i_v16 = (int32_t)p_v21;
        // break -> 0x10ab4
        break;
    }
    default: {
        // 0x10a90
        function_10e50(238);
        // UNREACHABLE
    }
    }
    bool i_v22 = i_v15 == 0 | i_v16 == 0;
    if (i_v22) {
        // 0x10d30
        function_10e50(240);
        // UNREACHABLE
    }
    int32_t i_v23 = i_v3 == 0 ? 1 : i_v3;
    int32_t i_v24 = i_v22;
    int32_t i_v25 = strtoul((char *)i_v15, (char **)i_v24, i_v24); // 0x10ad0
    if (i_g8 == 0) {
        // 0x10bd4
        fprintf(p_g4, "eeprog %s, a 24Cxx EEPROM reader/writer\n", "0.7.5");
        if (i_g8 == 0) {
            // 0x10c04
            fwrite((int32_t *)"Copyright (c) 2003 by Stefano Barbato - All "
                              "rights reserved.\n",
                   1, 61, p_g4);
            if (i_g8 == 0) {
                int32_t i_v26 = i_v23 == 1 ? 8 : 16;
                fprintf(p_g4, "  Bus: %s, Address: 0x%x, Mode: %dbit\n",
                        (char *)i_v16, i_v25, i_v26);
            }
        }
    }
    if (i_v5 != 0) {
        // 0x10b60
        fwrite((int32_t *)"Dummy mode selected, nothing done.\n", 1, 35, p_g4);
        // 0x10b54
        return 0;
    }
    // 0x10af0
    int32_t i_v27; // bp-160, 0x10928
    if (function_111b0(i_v16, i_v25, i_v23, &i_v27) < 0) {
        // 0x10d20
        function_10e80("unable to open eeprom device file (check that the file "
                       "exists and that it's readable)",
                       254);
        // UNREACHABLE
    }
    int32_t i_v28; // bp-164, 0x10928
    int32_t i_v29; // bp-168, 0x10928
    switch (i_v9) {
    case 114: {
        if (i_v6 == 0) {
            // 0x10d18
            function_10f30();
        }
        // 0x10c6c
        i_v28 = 1;
        function_10ed8(i_v10, &i_v29, &i_v28);
        if (i_g8 == 0) {
            // 0x10cf4
            fprintf(p_g4, "  Reading %d bytes from 0x%x\n", i_v28, i_v29);
        }
        // 0x10c90
        function_10f6c(&i_v27, i_v29, i_v28, i_v2);
        // 0x10b4c
        function_11334(&i_v27);
        // 0x10b54
        return 0;
    }
    case 119: {
        if (i_v6 == 0) {
            // 0x10ccc
            function_10f30();
        }
        // 0x10b24
        function_10ed8(i_v10, &i_v29, &i_v28);
        if (i_g8 == 0) {
            // 0x10cd4
            fprintf(p_g4, "  Writing stdin starting at address 0x%x\n", i_v29);
        }
        // 0x10b40
        function_11094(&i_v27, i_v29);
        // 0x10b4c
        function_11334(&i_v27);
        // 0x10b54
        return 0;
    }
    }
    // 0x10c5c
    function_10e50(274);
    // UNREACHABLE
lab_0x10968_3:
    // 0x10968
    i_v8 = i_v7;
    goto lab_0x10968_4;
}

// Address range: 0x10d70 - 0x10d94
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x10d70
    int32_t i_v1; // 0x10d70
    __libc_start_main(0x10928, i_a2, (char **)&i_v1, (void (*)())0x11521,
                      (void (*)())0x10928, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x10d94 - 0x10d98
int32_t function_10d94(int32_t i_a1) {
    // 0x10d94
    return i_a1;
}

// Address range: 0x10da0 - 0x10dbc
int32_t function_10da0(void) {
    // 0x10da0
    if (i_g2 == 0) {
        int32_t i_v1; // 0x10da0
        return i_v1;
    }
    // 0x10db8
    __gmon_start__();
    return &i_g9;
}

// Address range: 0x10dc4 - 0x10de2
int32_t function_10dc4(void) {
    // 0x10dc4
    return 0x2221c;
}

// Address range: 0x10de8 - 0x10e20
int32_t function_10de8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10de8
    int32_t i_v1; // 0x10de8
    int32_t i_v2 = i_v1;
    bool i_v3; // 0x10de8
    if (i_v3) {
        return i_a1;
    }
    if (i_v3) {
        return unknown_22c0();
    }
    int32_t i_v4 = (i_v2 << i_v1) + i_v2; // 0x10df8
    bool i_v5;                            // 0x10de8
    int32_t i_v6;                         // 0x10de8
    if (i_v3) {
        // .thread
        i_v6 = i_v3 == !i_v3 ? i_v4 : 0;
    } else {
        int32_t i_v7 = i_v4 & -1 - 0x400000 * i_v4; // 0x10dfc
        i_v6 = i_v7 < 1 ? 0 : i_v4;
        i_v5 = i_v7 < 0;
        if (i_v7 == 0) {
            return unknown_240((int32_t)&i_g9);
        }
    }
    // 0x10e0c
    if (i_v5 != i_v3) {
        __asm_svclt(0x4770);
    }
    float64_t f_v8; // 0x10de8
    __asm_vqrshl_s8(f_v8, f_v8);
    __asm_vmvn_i32(0xc0000);
    if (!i_v3) {
        *(int32_t *)i_a4 = i_v6;
    }
    return i_a1;
}

// Address range: 0x10e20 - 0x10e2c
int32_t function_10e20(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5) {
    int32_t i_v1 = i_a1; // 0x10e20
    if (i_a4 == 0) {
        // 0x10e22
        i_v1 = function_10dc4();
        int32_t i_v2; // 0x10e20
        *(char *)i_v2 = 1;
    }
    // 0x10e2a
    return i_v1;
}

// Address range: 0x10e2c - 0x10e30
int32_t function_10e2c(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x10e2c
    return i_a1;
}

// Address range: 0x10e32 - 0x10e3e
int32_t function_10e32(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10e32
    bool i_v1; // 0x10e32
    if (i_v1) {
        return i_a1;
    }
    int32_t i_v2 = i_a1; // 0x10e36
    int32_t i_v3;        // 0x10e32
    int16_t i_v4 = i_v3; // 0x10e36
    if (i_v1) {
        *(int16_t *)i_v3 = i_v4;
    }
    return i_v2;
}

// Address range: 0x10e3e - 0x10e40
int32_t function_10e3e(void) {
    // 0x10e3e
    int32_t i_v1; // 0x10e3e
    return function_10de8(i_v1, i_v1, i_v1, i_v1);
}

// Address range: 0x10e40 - 0x10e4c
int32_t function_10e40(int32_t i_a1) {
    // 0x10e40
    bool i_v1; // 0x10e40
    if (i_v1) {
        return unknown_240(i_a1);
    }
    // 0x10e48
    return i_a1;
}

// Address range: 0x10e4c - 0x10e50
int32_t function_10e4c(void) {
    // 0x10e4c
    int32_t i_v1; // 0x10e4c
    return i_v1;
}

// Address range: 0x10e50 - 0x10e80
int32_t function_10e50(int32_t i_a1) {
    // 0x10e50
    fprintf(
        p_g4, "%s\n[line %d]\n",
        "eeprog 0.7.5, a 24Cxx EEPROM reader/writer\nCopyright (c) 2003 by "
        "Stefano Barbato - All rights reserved.\nUsage: eeprog [-fqxdh] "
        "[-16|-8] [ -r addr[:count] | -w addr ]  /dev/i2c-N  i2c-address\n\n  "
        "Address modes:\n\t-8\t\tUse 8bit address mode for 24c0x...24C16 "
        "[default]\n\t-16\t\tUse 16bit address mode for 24c32...24C256\n  "
        "Actions:\n\t-r addr[:count]\tRead [count] (1 if omitted) bytes from "
        "[addr]\n\t\t\tand print them to the standard output\n\t-w "
        "addr\t\tWrite input (stdin) at address [addr] of the "
        "EEPROM\n\t-h\t\tPrint this help\n  Options:\n\t-x\t\tSet hex output "
        "mode\n\t-d\t\tDummy mode, display what *would* have been "
        "done\n\t-f\t\tDisable warnings and don't ask "
        "confirmation\n\t-q\t\tQuiet mode\n\nThe following environment "
        "variables could be set instead of the command\nline "
        "arguments:\n\tEEPROG_DEV\t\tdevice "
        "name(/dev/"
        "i2c-N)\n\tEEPROG_I2C_ADDR\t\ti2c-address\n\n\tExamples\n\t1- read 64 "
        "bytes from the EEPROM at address 0x54 on bus 0 starting\n\t   at "
        "address 123 (decimal)\n\t\teeprog /dev/i2c-0 0x54 -r 123:64\n\t2- "
        "prints the hex codes of the first 32 bytes read from bus 1\n\t   at "
        "address 0x22\n\t\teeprog /dev/i2c-1 0x51 -x -r 0x22:0x20\n\t3- write "
        "the current timestamp at address 0x200 of the EEPROM on\n\t   bus 0 "
        "at address 0x33\n\t\tdate | eeprog /dev/i2c-0 0x33 -w 0x200\n",
        i_a1);
    exit(1);
    return &i_g9;
}

// Address range: 0x10e80 - 0x10eac
int32_t function_10e80(char *p_a1, int32_t i_a2) {
    // 0x10e80
    fprintf(p_g4, "Error at line %d: %s\n", i_a2, p_a1);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x10eac - 0x10ec0
int32_t function_10eac(int32_t i_a1, int32_t i_a2) {
    if (i_a1 == 0) {
        return 0;
    }
    // 0x10eb4
    function_10e50(i_a2);
    // UNREACHABLE
}

// Address range: 0x10ec0 - 0x10ed8
int32_t function_10ec0(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    if (i_a1 == 0) {
        return 0;
    }
    // 0x10ec8
    return function_10e80((char *)i_a2, i_a3);
}

// Address range: 0x10ed8 - 0x10f30
int32_t function_10ed8(int32_t i_a1, int32_t *p_a2, int32_t *p_a3) {
    // 0x10ed8
    char *p_v1;                                     // bp-20, 0x10ed8
    int32_t i_v2 = strtoul((char *)i_a1, &p_v1, 0); // 0x10ef0
    *p_a2 = i_v2;
    if (*p_v1 != 58) {
        // 0x10f08
        return i_v2;
    }
    char *p_v3 = (char *)((int32_t)p_v1 + 1); // 0x10f1c
    p_v1 = p_v3;
    int32_t i_v4 = strtoul(p_v3, NULL, 0); // 0x10f20
    *p_a3 = i_v4;
    return i_v4;
}

// Address range: 0x10f30 - 0x10f6c
int32_t function_10f30(void) {
    // 0x10f30
    fwrite(
        (int32_t
             *)"\n____________________________WARNING__________________________"
               "__\nErroneously writing to a system EEPROM (like DIMM SPD "
               "modules)\ncan break your system.  It will NOT boot anymore so "
               "you'll not\nbe able to fix it.\n\nReading from 8bit EEPROMs "
               "(like that in your DIMM) without using\nthe -8 switch can also "
               "UNEXPECTEDLY write to them, so be sure to\nuse the -8 command "
               "param when required.\n\nUse -f to disable this warning "
               "message\n\nPress ENTER to continue or hit CTRL-C to exit\n\n",
        1, 469, p_g4);
    _IO_getc(p_g5);
    return 1;
}

// Address range: 0x10f6c - 0x11094
int32_t function_10f6c(int32_t *p_a1, uint32_t i_a2, int32_t i_a3,
                       int32_t i_a4) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2 = function_11380(i_v1, i_a2 % 0x10000); // 0x10f84
    if (i_v2 < 0) {
        // 0x11084
        return function_10e80("read error", 125);
    }
    if (i_a4 == 0) {
        // 0x11060
        _IO_putc(i_v2, p_g6);
    } else {
        // 0x10f98
        printf("\n %.4x|  %.2x ", i_a2, i_v2);
    }
    int32_t i_v3 = i_a2; // 0x10fb8
    uint32_t i_v4 = 1;   // 0x10fb8
    int32_t i_v5 = i_a3; // 0x10fb8
    if (i_a3 == 1) {
        if (i_a4 == 0) {
            // 0x11018
            fflush(p_g6);
            return 0;
        }
    lab_0x1100c:
        // 0x1100c
        puts("\n");
        // 0x11018
        fflush(p_g6);
        return 0;
    }
    while (true) {
        int32_t i_v6 = function_11360(i_v1); // 0x10fc0
        if (i_v6 < 0) {
            // break (via goto) -> 0x11074
            goto lab_0x11074;
        }
        // 0x10fcc
        i_v5--;
        while (i_a4 != 0) {
            int32_t i_v7 = i_v3 + 1; // 0x10fd8
            if (i_v4 % 16 == 0) {
                // 0x1103c
                printf("\n %.4x|  ", i_v7);
            } else {
                if (i_v4 % 8 == 0) {
                    // 0x11050
                    printf("  ");
                }
            }
            // 0x10fe8
            printf("%.2x ", i_v6);
            if (i_v5 == 1) {
                goto lab_0x1100c;
            }
            i_v6 = function_11360(i_v1);
            if (i_v6 < 0) {
                // break (via goto) -> 0x11074
                goto lab_0x11074;
            }
            // 0x10fcc
            i_v3 = i_v7;
            i_v4++;
            i_v5--;
        }
        // 0x11030
        _IO_putc(i_v6, p_g6);
        if (i_v5 == 1) {
            // 0x11018
            fflush(p_g6);
            return 0;
        }
    }
lab_0x11074:
    // 0x11074
    function_10e80("read error", 133);
    // UNREACHABLE
}

// Address range: 0x11094 - 0x11158
int32_t function_11094(int32_t *p_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2;            // 0x110c0
    uint32_t i_v2 = _IO_getc(p_g5); // 0x110ec
    while (i_v2 != -1) {
        // 0x11100
        if (i_g8 == 0) {
            // 0x11108
            fputc(46, p_g4);
        }
        // 0x110c4
        fflush(p_g6);
        int32_t i_v3 = function_11460((int32_t)p_a1, i_v1 % 0x10000,
                                      i_v2 % 256); // 0x110d8
        i_v1++;
        if (i_v3 != 0) {
            // 0x11148
            function_10e80("write error", 160);
            // UNREACHABLE
        }
        i_v2 = _IO_getc(p_g5);
    }
    if (i_g8 == 0) {
        // 0x11120
        fwrite((int32_t *)"\n\n", 1, 2, p_g4);
    }
    // 0x11140
    return 0;
}

// Address range: 0x11158 - 0x111b0
int32_t function_11158(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i2c_smbus_write_byte_data(); // 0x11164
    if (i_v1 < 0) {
        // 0x11180
        fprintf(p_g4, "Error i2c_write_2b: %s\n",
                strerror(*__errno_location()));
    }
    // 0x11170
    usleep(0x1388);
    return i_v1;
}

// Address range: 0x111b0 - 0x11334
int32_t function_111b0(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    int32_t i_v1 = (int32_t)p_a4;
    int32_t *p_v2 = (int32_t *)(i_v1 + 4); // 0x111c0
    *p_v2 = 0;
    int32_t *p_v3 = (int32_t *)(i_v1 + 8); // 0x111c8
    *p_v3 = 0;
    *p_a4 = 0;
    int32_t i_v4 = open64((char *)i_a1, 2); // 0x111dc
    if (i_v4 < 1) {
        // 0x1125c
        return -1;
    }
    int32_t i_v5 = ioctl(i_v4, 1797); // 0x111f0
    if (i_v5 < 0) {
        // 0x1125c
        return i_v5;
    }
    int32_t i_v6; // 0x111b0
    if ((i_v6 & 0x20000) == 0) {
        // 0x1130c
        fwrite((int32_t *)"\nError: I2C_FUNC_SMBUS_READ_BYTE function is "
                          "required. Program halted.\n\n",
               1, 72, p_g4);
        exit(1);
        return &i_g9;
    }
    if ((i_v6 & 0x40000) == 0) {
        // 0x112e4
        fwrite((int32_t *)"\nError: I2C_FUNC_SMBUS_WRITE_BYTE function is "
                          "required. Program halted.\n\n",
               1, 73, p_g4);
        exit(1);
        // UNREACHABLE
    }
    // 0x11210
    if ((i_v6 & 0x80000) == 0) {
        // 0x112a4
        fwrite((int32_t *)(int32_t) "\nError: I2C_FUNC_SMBUS_READ_BYTE_DATA "
                                    "function is required. Program halted.\n\n",
               1, 77, p_g4);
        exit(1);
        // UNREACHABLE
    }
    // 0x11218
    if ((i_v6 & 0x100000) == 0) {
        // 0x1127c
        fwrite((int32_t *)(int32_t) "\nError: I2C_FUNC_SMBUS_WRITE_BYTE_DATA "
                                    "function is required. Program halted.\n\n",
               1, 78, p_g4);
        exit(1);
        // UNREACHABLE
    }
    // 0x11220
    if ((i_v6 & 0x200000) == 0) {
        // 0x112a4
        fwrite((int32_t *)(int32_t) "\nError: I2C_FUNC_SMBUS_READ_WORD_DATA "
                                    "function is required. Program halted.\n\n",
               1, 77, p_g4);
        exit(1);
        // UNREACHABLE
    }
    // 0x11228
    if ((i_v6 & 0x400000) == 0) {
        // 0x1127c
        fwrite((int32_t *)(int32_t) "\nError: I2C_FUNC_SMBUS_WRITE_WORD_DATA "
                                    "function is required. Program halted.\n\n",
               1, 78, p_g4);
        exit(1);
        // UNREACHABLE
    }
    int32_t i_v7 = ioctl(i_v4, 1795); // 0x1123c
    int32_t i_v8 = i_v7;              // 0x11244
    if (i_v7 >= 0) {
        // 0x11248
        *p_v3 = i_v4;
        *p_v2 = i_a2;
        *p_a4 = i_a1;
        *(int32_t *)(i_v1 + 12) = i_a3;
        i_v8 = 0;
    }
    // 0x1125c
    return i_v8;
}

// Address range: 0x11334 - 0x11360
int32_t function_11334(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t *p_v2 = (int32_t *)(i_v1 + 8); // 0x1133c
    close(*p_v2);
    *p_a1 = 0;
    *p_v2 = -1;
    *(int32_t *)(i_v1 + 12) = 0;
    return 0;
}

// Address range: 0x11360 - 0x11380
int32_t function_11360(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0x1136c
    ioctl(*p_v1, 0x1261);
    return i2c_smbus_read_byte(*p_v1);
}

// Address range: 0x11380 - 0x11460
int32_t function_11380(int32_t i_a1, uint32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0x11390
    ioctl(*p_v1, 0x1261);
    int32_t i_v2; // 0x11380
    switch (*(int32_t *)(i_a1 + 12)) {
    case 1: {
        int32_t i_v3 = i2c_smbus_write_byte(*p_v1, i_a2 % 256); // 0x113f0
        if (i_v3 < 0) {
            // 0x11430
            fprintf(p_g4, "Error i2c_write_1b: %s\n",
                    strerror(*__errno_location()));
        }
        // 0x113fc
        usleep(0x1388);
        i_v2 = i_v3;
        // break -> 0x113cc
        break;
    }
    case 2: {
        // 0x113b0
        i_v2 = *p_v1;
        // break -> 0x113cc
        break;
    }
    default: {
        // 0x11408
        fwrite((int32_t *)"ERR: unknown eeprom type\n", 1, 25, p_g4);
        // 0x113e0
        return -1;
    }
    }
    int32_t i_v4 = i_v2; // 0x113d4
    if (i_v2 >= 0) {
        // 0x113d8
        i_v4 = i2c_smbus_read_byte(*p_v1);
    }
    // 0x113e0
    return i_v4;
}

// Address range: 0x11460 - 0x11520
int32_t function_11460(int32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    // 0x11460
    int32_t i_v1; // 0x11490
    switch (*(int32_t *)(i_a1 + 12)) {
    case 1: {
        // 0x114a8
        return *(int32_t *)(i_a1 + 8);
    }
    case 2: {
        uint32_t i_v2 = i_a2 % 256;            // 0x11480
        int32_t i_v3 = *(int32_t *)(i_a1 + 8); // 0x11484
        int32_t i_v4;                          // 0x11460
        i_v1 = i2c_smbus_write_word_data(i_v3, i_a2 / 256, 256 * i_a3 | i_v2,
                                         i_v2, i_v4, i_v4, i_v4);
        if (i_v1 < 0) {
            // 0x114b0
            fprintf(p_g4, "Error i2c_write_3b: %s\n",
                    strerror(*__errno_location()));
        }
        // break -> 0x1149c
        break;
    }
    default: {
        // 0x114f8
        fwrite((int32_t *)"ERR: unknown eeprom type\n", 1, 25, p_g4);
        // 0x114a8
        return -1;
    }
    }
    // 0x1149c
    usleep(0x1388);
    // 0x114a8
    return i_v1;
}

// Address range: 0x11520 - 0x11558
int32_t function_11520(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_107c4(i_a1, i_a2, i_a3, i_a4); // 0x11532
    return (int32_t)&i_g1 - 0x15ca8 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x11564 - 0x1156c
int32_t function_11564(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11564
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 56
