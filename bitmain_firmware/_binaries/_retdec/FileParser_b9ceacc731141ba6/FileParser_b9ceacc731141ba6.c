//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_106c4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
void function_106e4(void);
int32_t function_106f0(int32_t i_a1);
int32_t function_106fc(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
void function_10708(void);
int32_t function_10714(struct _IO_FILE *stream);
int32_t *function_10720(int32_t *s, int32_t c, int32_t n);
int32_t function_1072c(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t *p_a4,
                       int32_t i_a5, int32_t i_a6);
int32_t function_10738(struct _IO_FILE *stream, int32_t off, int32_t whence);
int32_t function_10744(void);
int32_t function_10750(int32_t *p_a1, int32_t *p_a2, int32_t i_a3);
int32_t function_1075c(char *s);
int32_t *function_10768(int32_t *dest, int32_t *src, int32_t n);
struct _IO_FILE *function_10774(char *filename, char *modes);
int32_t function_10780(int32_t *p_a1, int32_t i_a2);
int32_t function_1078c(char *format, ...);
int32_t function_10798(int32_t i_a1, int32_t i_a2);
int32_t function_107a4(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
int32_t function_107b0(int32_t ver, char *filename, struct stat64 *stat_buf);
int32_t function_107bc(char *s);
int32_t function_107c8(int32_t i_a1);
int32_t function_107d4(int32_t *p_a1, int32_t *p_a2, int32_t i_a3);
int32_t function_107e0(int32_t i_a1);
int32_t function_107ec(int32_t *p_a1);
int32_t function_107f8(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *stream);
int32_t function_10804(int32_t i_a1, int32_t i_a2);
int32_t function_111e0(int32_t i_a1);
int32_t function_111ec(void);
int32_t function_11210(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_11260(void);
int32_t function_11278(void);
int32_t function_1127c(int32_t *p_a1);
int32_t function_1136c(int32_t i_a1, uint32_t i_a2, int32_t i_a3, char i_a4,
                       uint32_t i_a5, uint32_t i_a6);
int32_t function_11710(int32_t i_a1);
int32_t function_117b0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_117ec(void);
int32_t function_117f0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_240(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0x11279; // 0x21f08
int32_t i_g2 = 0;       // 0x2206c
char *p_g3;             // 0x22834
int32_t i_g4;
int32_t i_g5;
int32_t i_g6;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
int32_t __xstat64(int32_t i_a1, char *p_a2, struct stat64 *p_a3);
int32_t BIO_free(int32_t i_a1);
int32_t BIO_new_mem_buf(int32_t *p_a1, int32_t i_a2);
int32_t ERR_error_string(int32_t i_a1, int32_t i_a2);
int32_t ERR_get_error(int32_t i_a1);
struct _IO_FILE *fopen64(char *p_a1, char *p_a2);
int32_t PEM_read_bio_RSA_PUBKEY(void);
int32_t RSA_free(int32_t i_a1);
int32_t RSA_verify(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t *p_a4,
                   int32_t i_a5, int32_t i_a6);
int32_t SHA256_Final(int32_t *p_a1, int32_t *p_a2, int32_t i_a3);
int32_t SHA256_Init(int32_t *p_a1);
int32_t SHA256_Update(int32_t *p_a1, int32_t *p_a2, int32_t i_a3);

// ------------------------ Functions -------------------------

// Address range: 0x106c4 - 0x106d0
int32_t function_106c4(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x106c4
    return function_111ec();
}

// Address range: 0x106e4 - 0x106f0
void function_106e4(void) {
    // 0x106e4
    abort();
}

// Address range: 0x106f0 - 0x106fc
int32_t function_106f0(int32_t i_a1) {
    // 0x106f0
    return ERR_get_error(i_a1);
}

// Address range: 0x106fc - 0x10708
int32_t function_106fc(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x106fc
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10708 - 0x10714
void function_10708(void) {
    // 0x10708
    __gmon_start__();
}

// Address range: 0x10714 - 0x10720
int32_t function_10714(struct _IO_FILE *stream) {
    // 0x10714
    return fclose(stream);
}

// Address range: 0x10720 - 0x1072c
int32_t *function_10720(int32_t *s, int32_t c, int32_t n) {
    // 0x10720
    return memset(s, c, n);
}

// Address range: 0x1072c - 0x10738
int32_t function_1072c(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t *p_a4,
                       int32_t i_a5, int32_t i_a6) {
    // 0x1072c
    return RSA_verify(i_a1, p_a2, i_a3, p_a4, i_a5, i_a6);
}

// Address range: 0x10738 - 0x10744
int32_t function_10738(struct _IO_FILE *stream, int32_t off, int32_t whence) {
    // 0x10738
    return fseek(stream, off, whence);
}

// Address range: 0x10744 - 0x10750
int32_t function_10744(void) {
    // 0x10744
    return PEM_read_bio_RSA_PUBKEY();
}

// Address range: 0x10750 - 0x1075c
int32_t function_10750(int32_t *p_a1, int32_t *p_a2, int32_t i_a3) {
    // 0x10750
    return SHA256_Final(p_a1, p_a2, i_a3);
}

// Address range: 0x1075c - 0x10768
int32_t function_1075c(char *s) {
    // 0x1075c
    return strlen(s);
}

// Address range: 0x10768 - 0x10774
int32_t *function_10768(int32_t *dest, int32_t *src, int32_t n) {
    // 0x10768
    return memcpy(dest, src, n);
}

// Address range: 0x10774 - 0x10780
struct _IO_FILE *function_10774(char *filename, char *modes) {
    // 0x10774
    return fopen64(filename, modes);
}

// Address range: 0x10780 - 0x1078c
int32_t function_10780(int32_t *p_a1, int32_t i_a2) {
    // 0x10780
    return BIO_new_mem_buf(p_a1, i_a2);
}

// Address range: 0x1078c - 0x10798
int32_t function_1078c(char *format, ...) {
    // 0x1078c
    return printf(format);
}

// Address range: 0x10798 - 0x107a4
int32_t function_10798(int32_t i_a1, int32_t i_a2) {
    // 0x10798
    return ERR_error_string(i_a1, i_a2);
}

// Address range: 0x107a4 - 0x107b0
int32_t function_107a4(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x107a4
    return fwrite(ptr, size, n, s);
}

// Address range: 0x107b0 - 0x107bc
int32_t function_107b0(int32_t ver, char *filename, struct stat64 *stat_buf) {
    // 0x107b0
    return __xstat64(ver, filename, stat_buf);
}

// Address range: 0x107bc - 0x107c8
int32_t function_107bc(char *s) {
    // 0x107bc
    return puts(s);
}

// Address range: 0x107c8 - 0x107d4
int32_t function_107c8(int32_t i_a1) {
    // 0x107c8
    return RSA_free(i_a1);
}

// Address range: 0x107d4 - 0x107e0
int32_t function_107d4(int32_t *p_a1, int32_t *p_a2, int32_t i_a3) {
    // 0x107d4
    return SHA256_Update(p_a1, p_a2, i_a3);
}

// Address range: 0x107e0 - 0x107ec
int32_t function_107e0(int32_t i_a1) {
    // 0x107e0
    return BIO_free(i_a1);
}

// Address range: 0x107ec - 0x107f8
int32_t function_107ec(int32_t *p_a1) {
    // 0x107ec
    return SHA256_Init(p_a1);
}

// Address range: 0x107f8 - 0x10804
int32_t function_107f8(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *stream) {
    // 0x107f8
    return fread(ptr, size, n, stream);
}

// Address range: 0x10804 - 0x111bc
int32_t function_10804(int32_t i_a1, int32_t i_a2) {
    // 0x10804
    if (i_a1 < 2) {
        // 0x1092c
        function_11710(i_a2);
        // 0x108f4
        return 1;
    }
    int32_t i_v1 = *(int32_t *)(i_a2 + 4); // 0x1081c
    if (*(char *)i_v1 != 45) {
        // 0x108e8
        function_11710(i_a2);
        // 0x108f4
        return 2;
    }
    int32_t i_v2 = 0; // bp-4940, 0x10840
    int32_t i_v3;     // bp-4936, 0x10804
    memset(&i_v3, 0, 124);
    int32_t i_v4 = 0; // bp-4812, 0x10854
    int32_t i_v5;     // bp-4808, 0x10804
    memset(&i_v5, 0, 124);
    int32_t i_v6; // bp-2088, 0x10804
    memset(&i_v6, 0, 2048);
    int32_t i_v7 = 0;       // 0x10804
    int32_t i_v8;           // bp-3144, 0x10804
    int32_t i_v9;           // 0x10804
    int32_t i_v10;          // 0x10804
    int32_t i_v11;          // 0x10804
    struct _IO_FILE *p_v12; // 0x109f4
    int32_t i_v13;          // 0x10a30
    switch (i_a1) {
    case 5: {
        int32_t i_v14 = *(int32_t *)(i_a2 + 12); // 0x1093c
        uint32_t i_v15 = strlen((char *)i_v14);  // 0x10944
        if (i_v15 >= 127 == (i_v15 != 127)) {
            // 0x10988
            puts("fileName Too Long!");
            // 0x108f4
            return 3;
        }
        // 0x10950
        memcpy(&i_v2, (int32_t *)i_v14, i_v15 + 1);
        int32_t i_v16 = *(int32_t *)(i_a2 + 16); // 0x10960
        uint32_t i_v17 = strlen((char *)i_v16);  // 0x10968
        if (i_v17 >= 127 == (i_v17 != 127)) {
            // 0x10fc8
            puts("pemName Too Long!");
            // 0x108f4
            return 4;
        }
        // 0x10974
        memcpy(&i_v4, (int32_t *)i_v16, i_v17 + 1);
        i_v7 = i_v16;
    }
    case 2: {
    lab_0x10888:;
        unsigned char i_v18 = *(char *)(i_v1 + 1); // 0x10888
        i_g4 = (int32_t)i_v18 - 102;
        i_v10 = 0;
        i_v9 = 1;
        int32_t i_v19 = 0; // 0x10894
        switch (i_v18) {
        case 102: {
            // 0x10f80
            i_v10 = 0;
            i_v9 = 0;
            i_v19 = 0;
        }
        case 112: {
        lab_0x109c8:;
            // 0x109c8
            int32_t i_v20; // bp-5272, 0x10804
            __xstat64(3, (char *)&i_v2, (struct stat64 *)&i_v20);
            if (i_v11 < 2048) {
                // 0x10fac
                printf("File '%s' Not Enough %d, Something Wrong!\n", &i_v2,
                       2048);
                // 0x108f4
                return 6;
            }
            // 0x109e8
            p_v12 = fopen64((char *)&i_v2, "rb");
            if (p_v12 == NULL) {
                // 0x11050
                printf("Read File '%s' Failed!\n", &i_v2);
                // 0x108f4
                return 7;
            }
            // 0x10a00
            fread(&i_v6, 2048, 1, p_v12);
            if (i_v6 % 256 != 38) {
                // 0x10fdc
                printf("'%s' Not A Btmu File!\n", &i_v2);
                fclose(p_v12);
                // 0x108f4
                return 8;
            }
            // 0x10a24
            char i_v21;            // 0x10804
            int32_t i_v22 = i_v21; // 0x10a24
            i_v13 = 256 * i_v22 | (int32_t)i_v21;
            if (i_v19 != 0) {
                // 0x10ffc
                printf("content:%x\n", i_v13);
                if ((i_v22 & 254) != 254) {
                    // 0x11018
                    puts("This Package Was Not Full Package!");
                    // 0x108f4
                    return 20;
                }
            }
            // break -> 0x10a38
            break;
        }
        case 120: {
            // 0x10edc
            i_v10 = 1;
            i_v9 = 0;
            i_v19 = 1;
            // branch (via goto) -> 0x109c8
            goto lab_0x109c8;
        }
        case 115: {
            // 0x10ef0
            i_v10 = 1;
            i_v9 = 0;
            i_v19 = 0;
            // branch (via goto) -> 0x109c8
            goto lab_0x109c8;
        }
        case 113: {
            struct _IO_FILE *p_v23 = fopen64("/tmp/256BFF", "wb"); // 0x10f14
            if (p_v23 == NULL) {
                // 0x1108c
                puts("GenFile Failed!");
                // 0x108f4
                return 1;
            }
            // 0x10f20
            i_v8 = 0;
            int32_t i_v24; // bp-3140, 0x10804
            memset(&i_v24, 0, 252);
            int32_t i_v25;          // bp-3145, 0x10804
            int32_t i_v26 = &i_v25; // 0x10f4c
            i_v26++;
            *(char *)i_v26 = -1;
            int32_t i_v27; // bp-2889, 0x10804
            while (i_v26 != (int32_t)&i_v27) {
                // 0x10f50
                i_v26++;
                *(char *)i_v26 = -1;
            }
            // 0x10f5c
            fwrite(&i_v8, 256, 1, p_v23);
            fclose(p_v23);
            // 0x108f4
            return 0;
        }
        case 110: {
            // 0x108f4
            return function_1127c(&i_v2);
        }
        default: {
            // 0x10f90
            puts("Command Not Support!");
            function_11710(i_v7);
            // 0x108f4
            return 5;
        }
        }
        // break -> 0x10a38
        break;
    }
    case 3: {
        int32_t i_v28 = *(int32_t *)(i_a2 + 8); // 0x10904
        uint32_t i_v29 = strlen((char *)i_v28); // 0x1090c
        if (i_v29 >= 127 == (i_v29 != 127)) {
            // 0x10988
            puts("fileName Too Long!");
            // 0x108f4
            return 3;
        }
        // 0x10918
        memcpy(&i_v2, (int32_t *)i_v28, i_v29 + 1);
        i_v7 = i_v28;
        // branch (via goto) -> 0x10888
        goto lab_0x10888;
    }
    default: {
        // 0x1099c
        puts("Param Err!");
        function_11710(0);
        // 0x108f4
        return 3;
    }
    }
    int32_t i_v30 = (int32_t)p_v12; // 0x109f4
    int32_t i_v31 = 0;
    uint32_t i_v32 = 0;
    int32_t i_v33 = i_v32 + 1; // 0x10a48
    uint32_t i_v34 = (1 << i_v32 & i_v13) == 0 ? i_v31 : (i_v31 + 1) % 256;
    while (i_v33 != 16) {
        // 0x10a40
        i_v31 = i_v34;
        i_v32 = i_v33;
        i_v33 = i_v32 + 1;
        i_v34 = (1 << i_v32 & i_v13) == 0 ? i_v31 : (i_v31 + 1) % 256;
    }
    uint32_t i_v35 = i_v11 % 256; // 0x10a60
    if (i_v35 != i_v34) {
        // 0x11068
        printf("Content Doesn't Match![%d][%d]\n", i_v35, i_v34);
        fclose(p_v12);
        // 0x108f4
        return 9;
    }
    int32_t i_v36 = 256 * i_v34 + 2304; // 0x10a8c
    int32_t i_v37 = i_v36;              // 0x10ae8
    if (i_v34 != 0) {
        int32_t i_v38 = i_v36;  // 0x10acc
        int32_t i_v39;          // bp-778, 0x10804
        int32_t i_v40 = &i_v39; // 0x10804
        int32_t i_v41 = 0;
        int32_t i_v42 = i_v41 + 1;                  // 0x10ae0
        unsigned char i_v43 = *(char *)(i_v40 + 1); // 0x10aa8
        unsigned char i_v44 = *(char *)i_v40;       // 0x10aac
        unsigned char i_v45 = *(char *)(i_v40 + 2); // 0x10ab0
        unsigned char i_v46 = *(char *)(i_v40 + 3); // 0x10ab4
        int32_t i_v47 = 0x1000000 * (int32_t)i_v44 | 0x10000 * (int32_t)i_v43 |
                        (int32_t)i_v46 | 256 * (int32_t)i_v45; // 0x10ac4
        i_v38 += i_v47;
        printf("file[%d] size:[%d]\n", i_v41, i_v47);
        i_v40 += 5;
        i_v37 = i_v38;
        while (i_v42 < i_v34) {
            // 0x10aa8
            i_v41 = i_v42;
            i_v42 = i_v41 + 1;
            i_v43 = *(char *)(i_v40 + 1);
            i_v44 = *(char *)i_v40;
            i_v45 = *(char *)(i_v40 + 2);
            i_v46 = *(char *)(i_v40 + 3);
            i_v47 = 0x1000000 * (int32_t)i_v44 | 0x10000 * (int32_t)i_v43 |
                    (int32_t)i_v46 | 256 * (int32_t)i_v45;
            i_v38 += i_v47;
            printf("file[%d] size:[%d]\n", i_v41, i_v47);
            i_v40 += 5;
            i_v37 = i_v38;
        }
    }
    // 0x10aec
    if (i_v11 != i_v37) {
        // 0x1102c
        printf("Check FileSize Failed, FileSize Should Be [%d]Bytes, But It "
               "Was [%d] Bytes, And Total Says[%d]\n",
               llvm_bswap_i32(i_v11), i_v11, i_v37);
        fclose(p_v12);
        // 0x108f4
        return 10;
    }
    struct _IO_FILE *p_v48 = fopen64((char *)&i_v4, "r"); // 0x10b04
    if (p_v48 == NULL) {
        // 0x11118
        printf("Cannot Open Root PublicKey '%s'!\n", &i_v4);
        fclose(p_v12);
        // 0x108f4
        return 11;
    }
    int32_t i_v49 = 0; // bp-4168, 0x10b28
    int32_t i_v50;     // bp-4164, 0x10804
    memset(&i_v50, 0, 1020);
    fread(&i_v49, 1024, 1, p_v48);
    fclose(p_v48);
    int32_t i_v51 = BIO_new_mem_buf(&i_v49, 1024);           // 0x10b68
    int32_t i_v52 = PEM_read_bio_RSA_PUBKEY();               // 0x10b7c
    uint32_t i_v53 = __asm_rev16((uint32_t)i_v11 % 0x10000); // 0x10b84
    int32_t i_v54;                                           // 0x10804
    if (i_v52 == 0) {
        // 0x11138
        printf("OpenSSL error: %s\n",
               (char *)ERR_error_string(ERR_get_error(0), 0));
        puts("Read Root PubK Failed!");
        i_v54 = 12;
    } else {
        uint32_t i_v55 = i_v53 % 0x10000; // 0x10b88
        SHA256_Init(&i_v8);
        int32_t i_v56; // bp-2064, 0x10804
        SHA256_Update(&i_v8, &i_v56, i_v55);
        int32_t i_v57; // bp-4428, 0x10804
        SHA256_Final(&i_v57, &i_v8, i_v55);
        int32_t i_v58; // bp-1040, 0x10804
        int32_t i_v59 =
            RSA_verify(672, &i_v57, 32, &i_v58, 256, i_v52); // 0x10bd8
        int32_t i_v60 = RSA_free(i_v52);                     // 0x10bec
        if (i_v51 != 0) {
            // 0x10bf0
            i_v60 = BIO_free(i_v51);
        }
        if (i_v59 == 1) {
            if (i_v10 != 0) {
                struct _IO_FILE *p_v61 =
                    fopen64("/tmp/tmpfw/miner.pem", "w"); // 0x10c20
                if (p_v61 == NULL) {
                    // 0x111a8
                    puts("Dump Miner.pem Failed!\r");
                    // 0x108f4
                    return 15;
                }
                // 0x10c2c
                fwrite(&i_v56, 1, i_v55, p_v61);
                fclose(p_v61);
                struct _IO_FILE *p_v62 =
                    fopen64("/tmp/tmpfw/miner.pem.sig", "w"); // 0x10c58
                if (p_v62 == NULL) {
                    // 0x11198
                    puts("Dump Miner.pem.sig Failed!\r");
                    // 0x108f4
                    return 16;
                }
                // 0x10c64
                fwrite(&i_v58, 1, 256, p_v62);
                fclose(p_v62);
            }
            // 0x10c80
            memset(&i_v8, 0, 1056);
            int32_t i_v63; // bp-5164, 0x10804
            SHA256_Init(&i_v63);
            SHA256_Update(&i_v63, &i_v6, 2048);
            SHA256_Final(&i_v8, &i_v63, 2048);
            if (i_v34 != 0) {
                int32_t i_v64 = &i_v8;  // 0x10b94
                int32_t i_v65;          // bp-779, 0x10804
                int32_t i_v66 = &i_v65; // 0x10804
                uint32_t i_v67 = 1;
                unsigned char i_v68 = *(char *)(i_v66 + 2); // 0x10cd8
                unsigned char i_v69 = *(char *)(i_v66 + 1); // 0x10cdc
                unsigned char i_v70 = *(char *)(i_v66 + 4); // 0x10ce0
                unsigned char i_v71 = *(char *)(i_v66 + 3); // 0x10cec
                char i_v72 = *(char *)i_v66;                // 0x10cf8
                function_1136c(i_v30,
                               0x1000000 * (int32_t)i_v69 |
                                   0x10000 * (int32_t)i_v68 | (int32_t)i_v70 |
                                   256 * (int32_t)i_v71,
                               32 * i_v67 + i_v64, i_v72, 0, i_v10);
                int32_t i_v73 = i_v67 + 1; // 0x10d1c
                i_v66 += 5;
                while (i_v34 > i_v67) {
                    // 0x10cd8
                    i_v67 = i_v73;
                    i_v68 = *(char *)(i_v66 + 2);
                    i_v69 = *(char *)(i_v66 + 1);
                    i_v70 = *(char *)(i_v66 + 4);
                    i_v71 = *(char *)(i_v66 + 3);
                    i_v72 = *(char *)i_v66;
                    function_1136c(i_v30,
                                   0x1000000 * (int32_t)i_v69 |
                                       0x10000 * (int32_t)i_v68 |
                                       (int32_t)i_v70 | 256 * (int32_t)i_v71,
                                   32 * i_v67 + i_v64, i_v72, 0, i_v10);
                    i_v73 = i_v67 + 1;
                    i_v66 += 5;
                }
                // 0x10d30
                int32_t i_v74;          // bp-3112, 0x10804
                int32_t i_v75 = &i_v74; // 0x10d58
                int32_t i_v76 = 0;
                int32_t i_v77 = i_v76 + 1; // 0x10d5c
                char i_v78 =
                    *(char *)((int32_t)&i_v6 + 1309 + 5 * i_v76); // 0x10d30
                function_1136c(i_v30, 256, 32 * (i_v76 + i_v34) + i_v75, i_v78,
                               1, i_v10);
                while (i_v34 > i_v77) {
                    // 0x10d30
                    i_v76 = i_v77;
                    i_v77 = i_v76 + 1;
                    i_v78 = *(char *)((int32_t)&i_v6 + 1309 + 5 * i_v76);
                    function_1136c(i_v30, 256, 32 * (i_v76 + i_v34) + i_v75,
                                   i_v78, 1, i_v10);
                }
            }
            int32_t i_v79 = 0; // bp-4684, 0x10d80
            int32_t i_v80;     // bp-4680, 0x10804
            memset(&i_v80, 0, 252);
            fseek(p_v12, -256, SEEK_END);
            fread(&i_v79, 256, 1, p_v12);
            int32_t i_v81 = 0; // bp-5304, 0x10dc8
            int32_t i_v82;     // bp-5052, 0x10804
            SHA256_Init(&i_v82);
            int32_t i_v83 = 64 * i_v34 | 32; // 0x10ddc
            SHA256_Update(&i_v82, &i_v8, i_v83);
            SHA256_Final(&i_v81, &i_v82, i_v83);
            int32_t i_v84 = BIO_new_mem_buf(&i_v56, 1024); // 0x10e00
            int32_t i_v85 = PEM_read_bio_RSA_PUBKEY();     // 0x10e14
            if (i_v85 == 0) {
                // 0x11168
                printf("OpenSSL error: %s\n",
                       (char *)ERR_error_string(ERR_get_error(0), 0));
                puts("Load Pem Failed!");
                // 0x108f4
                return 17;
            }
            int32_t i_v86 =
                RSA_verify(672, &i_v81, 32, &i_v79, 256, i_v85); // 0x10e3c
            RSA_free(i_v85);
            if (i_v84 != 0) {
                // 0x10e54
                BIO_free(i_v84);
            }
            if (i_v86 != 1) {
                int32_t i_v87 =
                    ERR_get_error(puts("Check File Sig failed!\r")); // 0x110f8
                printf("OpenSSL error: %s\n",
                       (char *)ERR_error_string(i_v87, 0));
                // 0x108f4
                return 18;
            }
            // 0x10e64
            fclose(p_v12);
            puts("All Done!\r");
            if (i_v9 != 0) {
                // 0x10e84
                puts("This Comment Of This Package:");
                i_v57 = 0;
                int32_t i_v88; // bp-4424, 0x10804
                memset(&i_v88, 0, 253);
                int32_t i_v89; // bp-728, 0x10804
                memcpy(&i_v57, &i_v89, 256);
                puts((char *)&i_v57);
            }
            // 0x108f4
            return 0;
        }
        // 0x110a0
        printf("OpenSSL error: %s\n",
               (char *)ERR_error_string(ERR_get_error(i_v60), 0));
        puts("Check miner.pem Failed!");
        i_v54 = 13;
    }
    // 0x110cc
    printf("Check pem payload failed! ret:[%d]\n", i_v54);
    fclose(p_v12);
    // 0x108f4
    return i_v54;
}

// Address range: 0x111bc - 0x111e0
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x111bc
    int32_t i_v1; // 0x111bc
    __libc_start_main(0x10804, i_a2, (char **)&i_v1, (void (*)())0x117b1,
                      (void (*)())0x10804, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x111e0 - 0x111e4
int32_t function_111e0(int32_t i_a1) {
    // 0x111e0
    return i_a1;
}

// Address range: 0x111ec - 0x11208
int32_t function_111ec(void) {
    // 0x111ec
    if (i_g2 == 0) {
        int32_t i_v1; // 0x111ec
        return i_v1;
    }
    // 0x11204
    __gmon_start__();
    return &i_g6;
}

// Address range: 0x11210 - 0x11260
int32_t function_11210(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0x11210
    int32_t i_v1; // 0x11210
    int32_t i_v2 = i_v1;
    bool i_v3; // 0x11210
    if (i_v3) {
        return i_a1;
    }
    bool i_v4; // 0x11210
    if (!i_v3) {
        int32_t i_v5 = 0x100001 * i_v2 & -1 - 0x400000 * i_v2; // 0x11248
        i_v4 = i_v5 < 0;
        if (i_v5 == 0) {
            return unknown_240();
        }
    }
    // 0x11258
    if (i_v4 != i_v3) {
        __asm_svclt(0x4770);
    }
    return i_a1;
}

// Address range: 0x11260 - 0x11278
int32_t function_11260(void) {
    // 0x11260
    int32_t i_v1; // 0x11260
    if (*(char *)&p_g3 == 0) {
        // 0x1126e
        int32_t i_v2;                                       // 0x11260
        int32_t i_v3 = function_11210(i_v2, i_v2, i_v2, 0); // 0x1126e
        *(char *)&p_g3 = 1;
        i_v1 = i_v3;
    }
    // 0x11276
    return i_v1;
}

// Address range: 0x11278 - 0x1127a
int32_t function_11278(void) {
    // 0x11278
    int32_t i_v1; // 0x11278
    return i_v1;
}

// Address range: 0x1127c - 0x11364
int32_t function_1127c(int32_t *p_a1) {
    int32_t i_v1 = 0; // bp-32792, 0x11294
    int32_t i_v2;     // bp-32788, 0x1127c
    memset(&i_v2, 0, 0x7ffc);
    struct _IO_FILE *p_v3 = fopen64((char *)p_a1, "rb");        // 0x112ac
    int32_t i_v4 = (int32_t) "/tmp/tmpNand/devicetree.dtb.sig"; // 0x112b4
    if (p_v3 == NULL) {
        // 0x11350
        puts("Load Nand Image File Failed!");
        // 0x11338
        return 1;
    }
    int32_t *p_v5 = (int32_t *)(i_v4 - 4); // 0x112f0
    fread(&i_v1, *p_v5, 1, p_v3);
    char *p_v6 = (char *)i_v4;                   // 0x11304
    struct _IO_FILE *p_v7 = fopen64(p_v6, "wb"); // 0x11304
    int32_t i_v8;                                // 0x1127c
    while (p_v7 != NULL) {
        // 0x112cc
        i_v4 += 132;
        fwrite(&i_v1, *p_v5, 1, p_v7);
        fclose(p_v7);
        if (i_v4 == 0x22838) {
            // 0x11340
            fclose(p_v3);
            i_v8 = 0;
            return i_v8;
        }
        p_v5 = (int32_t *)(i_v4 - 4);
        fread(&i_v1, *p_v5, 1, p_v3);
        p_v6 = (char *)i_v4;
        p_v7 = fopen64(p_v6, "wb");
    }
    // 0x1131c
    printf("Try To Write To File '%s' Failed!\n", p_v6);
    fclose(p_v3);
    i_v8 = 2;
lab_0x11338:
    // 0x11338
    return i_v8;
}

// Address range: 0x1136c - 0x11710
int32_t function_1136c(int32_t i_a1, uint32_t i_a2, int32_t i_a3, char i_a4,
                       uint32_t i_a5, uint32_t i_a6) {
    int32_t i_v1 = 0; // bp-1064, 0x1139c
    int32_t i_v2;     // bp-1060, 0x1136c
    memset(&i_v2, 0, 1020);
    int32_t i_v3; // bp-1304, 0x1136c
    SHA256_Init(&i_v3);
    int32_t i_v4 = 0; // 0x113b4
    int32_t i_v5;     // bp-1180, 0x1136c
    int32_t i_v6;     // bp-1192, 0x1136c
    uint32_t i_v7;    // 0x1136c
    if (i_a6 % 256 == 0) {
        goto lab_0x11424;
    } else {
        int32_t i_v8 = i_a4;
        i_v7 = i_a5 % 256;
        i_v6 = 0x706d742f;
        memset(&i_v5, 0, 116);
        i_g5 = i_v8;
        switch (i_v8) {
        case 0: {
            goto lab_0x1162c;
        }
        case 7: {
            goto lab_0x1162c;
        }
        default: {
            if (i_v7 == 0) {
                goto lab_0x115c0;
            } else {
                goto lab_0x11600;
            }
        }
        }
    }
lab_0x11424:;
    struct _IO_FILE *p_v9 = (struct _IO_FILE *)i_a1;
    int32_t i_v10 = i_a2; // 0x11444
    if (i_a2 != 1024 && i_a2 >= 1024) {
        int32_t i_v11 = 0;                           // 0x11450
        int32_t i_v12 = fread(&i_v1, 1, 1024, p_v9); // 0x11448
        SHA256_Update(&i_v3, &i_v1, 1024);
        if (i_a6 % 2 != 0 && i_v4 != 0) {
            // 0x11474
            fwrite(&i_v1, 1, 1024, (struct _IO_FILE *)i_v4);
        }
        // 0x1142c
        i_v11 += i_v12;
        int32_t i_v13 = i_a2 - i_v11; // 0x11430
        i_v10 = i_v13;
        while (i_v13 != 1024 && i_v13 >= 1024) {
            // 0x11448
            i_v12 = fread(&i_v1, 1, 1024, p_v9);
            SHA256_Update(&i_v3, &i_v1, 1024);
            if (i_a6 % 2 != 0 && i_v4 != 0) {
                // 0x11474
                fwrite(&i_v1, 1, 1024, (struct _IO_FILE *)i_v4);
            }
            // 0x1142c
            i_v11 += i_v12;
            i_v13 = i_a2 - i_v11;
            i_v10 = i_v13;
        }
    }
    // 0x1148c
    int32_t i_v14; // bp-1176, 0x1136c
    int32_t i_v15 = &i_v14;
    int32_t i_v16 = fread(&i_v1, 1, i_v10, p_v9); // 0x11490
    SHA256_Update(&i_v3, &i_v1, i_v16);
    if (i_a6 % 256 == 0 || i_v4 == 0) {
        // 0x11518
        i_v6 = 0;
        *(int32_t *)(i_v15 - 8) = 0;
        *(int32_t *)(i_v15 - 4) = 0;
        i_v14 = 0;
        *(int32_t *)(i_v15 + 4) = 0;
        *(int32_t *)(i_v15 + 8) = 0;
        *(int32_t *)(i_v15 + 12) = 0;
        SHA256_Final(&i_v6, &i_v3, i_v15 - 12);
    } else {
        struct _IO_FILE *p_v17 = (struct _IO_FILE *)i_v4; // 0x114c8
        fwrite(&i_v1, 1, i_v16, p_v17);
        i_v6 = 0;
        *(int32_t *)(i_v15 - 8) = 0;
        *(int32_t *)(i_v15 - 4) = 0;
        i_v14 = 0;
        *(int32_t *)(i_v15 + 4) = 0;
        *(int32_t *)(i_v15 + 8) = 0;
        *(int32_t *)(i_v15 + 12) = 0;
        SHA256_Final(&i_v6, &i_v3, i_v15 - 12);
        fclose(p_v17);
    }
    // 0x11558
    *(int32_t *)i_a3 = i_v6;
    *(int32_t *)(i_a3 + 4) = 0;
    char *p_v18; // 0x1136c
    *(int32_t *)(i_a3 + 8) = (int32_t)p_v18;
    *(int32_t *)(i_a3 + 12) = i_v5;
    *(int32_t *)(i_a3 + 16) = i_v14;
    return 0;
lab_0x1162c:
    if (i_v7 == 0) {
        goto lab_0x115c0;
    } else {
        goto lab_0x11600;
    }
lab_0x115c0:
    // 0x115c0
    printf("fileName:'%s', size:[%d]\r\n", &i_v6, i_a2);
    struct _IO_FILE *p_v19 = fopen64((char *)&i_v6, "wb"); // 0x115e0
    int32_t i_v20 = (int32_t)p_v19;                        // 0x115e0
    p_v18 = (char *)0x2f7766;
    i_v4 = i_v20;
    if (p_v19 == NULL) {
        // 0x115ec
        printf("Create File '%s' Failed!\r\n", &i_v6);
        p_v18 = (char *)0x2f7766;
        i_v4 = i_v20;
    }
    goto lab_0x11424;
lab_0x11600:;
    int32_t i_v21 = strlen((char *)&i_v6) + (int32_t)&i_v6; // 0x11614
    *(int32_t *)i_v21 = 0x6769732e;
    *(char *)(i_v21 + 4) = 0;
    goto lab_0x115c0;
}

// Address range: 0x11710 - 0x117b0
int32_t function_11710(int32_t i_a1) {
    // 0x11710
    puts("Useage:\r");
    printf("\t%s [option] [paramaters]\n\n", (char *)i_a1);
    puts("\tOption:{-f} {-s} {-p} {-n} {-x} {-q}\n");
    puts("\t\t-f [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tOnly "
         "Check If Filename was Valided.\n");
    puts("\t\t-s [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was Valided, and Splite Bmu To \"/tmp/tmpfw/\"\n");
    puts("\t\t-p [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was Valided, and Dump BmuComments\n");
    puts("\t\t-x [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was FullSize BMU\n");
    puts("\t\t-n [nandBinFile]: \n\t\t\tSplite SigImg To Single File To "
         "\"/tmp/tmpNand/\"\n");
    puts("\t\t-q: \n\t\t\tGenerate A 256Bytes 0xff File To \"/tmp/256BFF\"\n");
    puts("\tReturns:");
    puts("\t\t0: \n\t\t\tWell Done!\n");
    return puts("\t\tOthers: \n\t\t\tSomething Wrong!\n");
}

// Address range: 0x117b0 - 0x117e4
int32_t function_117b0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_106c4(i_a1, i_a2, i_a3, i_a4); // 0x117c0
    return 0x21f0a - (int32_t)&i_g1 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x117ec - 0x117ee
int32_t function_117ec(void) {
    // 0x117ec
    int32_t i_v1; // 0x117ec
    return i_v1;
}

// Address range: 0x117f0 - 0x117f8
int32_t function_117f0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x117f0
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 38
