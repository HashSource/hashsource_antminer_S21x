//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct timezone {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_10774(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t *function_10794(int32_t nmemb, int32_t size);
int32_t function_107a0(int32_t fd, int32_t level, int32_t optname,
                       int32_t *optval, int32_t optlen);
int32_t function_107ac(char *format, ...);
int32_t function_107b8(struct _IO_FILE *stream, char *format, ...);
void function_107c4(int32_t *ptr);
int32_t *function_107d0(int32_t *dest, int32_t *src, int32_t n);
char *function_107dc(struct in_addr x_a1);
int32_t function_107e8(int32_t nfds, struct _TYPEDEF_fd_set *readfds,
                       struct _TYPEDEF_fd_set *writefds,
                       struct _TYPEDEF_fd_set *exceptfds,
                       struct timeval *timeout);
char *function_107f4(char *dest, char *src);
int32_t function_10800(int32_t fd, int32_t *buf, int32_t n, int32_t flags,
                       struct sockaddr *addr, int32_t *addr_len);
void function_1080c(char *s);
int32_t function_10818(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
char *function_10824(char *dest, char *src);
int32_t function_10830(int32_t fd, int32_t request, ...);
int32_t function_1083c(int32_t useconds);
char *function_10848(char *dest, char *src);
int32_t function_10854(struct timeval *tv, struct timezone *tz);
int32_t function_10860(char *s);
int32_t function_1086c(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_10878(char *command);
void function_10884(void);
void function_10890(int32_t status);
int32_t function_1089c(char *s);
int32_t function_108a8(int32_t fd, struct sockaddr *addr, int32_t len);
int32_t *function_108b4(int32_t *s, int32_t c, int32_t n);
char *function_108c0(char *dest, char *src, int32_t n);
int32_t function_108cc(char *name, int32_t type);
int32_t function_108d8(struct _IO_FILE *stream);
int32_t function_108e4(int32_t fd, int32_t *buf, int32_t n, int32_t flags,
                       struct sockaddr *addr, int32_t addr_len);
int32_t function_108f0(char *s, char *format, ...);
struct _IO_FILE *function_108fc(char *filename, char *modes);
int32_t function_10908(int32_t domain, int32_t type, int32_t protocol);
int32_t function_10914(char *s1, char *s2, int32_t n);
void function_10920(void);
int32_t function_1092c(int32_t fd);
int32_t function_10938(void);
int32_t function_109c4(int32_t i_a1);
int32_t function_109d0(void);
int32_t function_109f4(void);
int32_t function_10a18(void);
int32_t function_10a44(void);
int32_t function_10a5c(int32_t i_a1, int32_t i_a2);
int32_t function_10a62(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10a6e(void);
int32_t function_10a70(int32_t i_a1);
int32_t function_10a7c(void);
int32_t function_10a80(int32_t i_a1);
int32_t function_10b18(char *p_a1, int32_t *p_a2);
int32_t function_10bd4(int32_t i_a1, int32_t i_a2);
int32_t function_10cd8(int32_t *p_a1, char *p_a2);
int32_t function_10db8(int32_t i_a1);
int32_t function_10e1c(void);
int32_t function_10e34(void);
int32_t function_10f5c(int32_t i_a1);
int32_t function_11018(void);
int32_t function_1111c(void);
int32_t function_11274(char *p_a1);
int32_t function_112cc(void);
int32_t function_11514(void);
int32_t function_115ac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_115f0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_240(int32_t i_a1);

// --------------------- Global Variables ---------------------

int32_t i_g1 = 0x10a45;        // 0x2184c
int32_t i_g2 = 0;              // 0x219d4
int32_t i_g3 = -1;             // 0x219e0
char *p_g4;                    // 0x219e4
char *p_g5;                    // 0x219e8
int32_t i_g6 = 0;              // 0x21a08
struct timeval *p_g7 = NULL;   // 0x21a10
int32_t i_g8 = 0;              // 0x21a12
int32_t i_g9 = 0;              // 0x21a14
int32_t i_g10 = 0;             // 0x21a18
int32_t i_g11 = 0;             // 0x21a1c
struct sockaddr *p_g12 = NULL; // 0x21a20
int32_t i_g13 = 0;             // 0x21a22
int32_t i_g14 = 0;             // 0x21a24
int32_t i_g15 = 0;             // 0x21a28
int32_t i_g16 = 0;             // 0x21a2c
int32_t i_g17;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
struct _IO_FILE *fopen64(char *p_a1, char *p_a2);

// ------------------------ Functions -------------------------

// Address range: 0x10774 - 0x10780
int32_t function_10774(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10774
    return function_109d0();
}

// Address range: 0x10794 - 0x107a0
int32_t *function_10794(int32_t nmemb, int32_t size) {
    // 0x10794
    return calloc(nmemb, size);
}

// Address range: 0x107a0 - 0x107ac
int32_t function_107a0(int32_t fd, int32_t level, int32_t optname,
                       int32_t *optval, int32_t optlen) {
    // 0x107a0
    return setsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x107ac - 0x107b8
int32_t function_107ac(char *format, ...) {
    // 0x107ac
    return printf(format);
}

// Address range: 0x107b8 - 0x107c4
int32_t function_107b8(struct _IO_FILE *stream, char *format, ...) {
    // 0x107b8
    return fscanf(stream, format);
}

// Address range: 0x107c4 - 0x107d0
void function_107c4(int32_t *ptr) {
    // 0x107c4
    free(ptr);
}

// Address range: 0x107d0 - 0x107dc
int32_t *function_107d0(int32_t *dest, int32_t *src, int32_t n) {
    // 0x107d0
    return memcpy(dest, src, n);
}

// Address range: 0x107dc - 0x107e8
char *function_107dc(struct in_addr x_a1) {
    // 0x107dc
    return inet_ntoa(x_a1);
}

// Address range: 0x107e8 - 0x107f4
int32_t function_107e8(int32_t nfds, struct _TYPEDEF_fd_set *readfds,
                       struct _TYPEDEF_fd_set *writefds,
                       struct _TYPEDEF_fd_set *exceptfds,
                       struct timeval *timeout) {
    // 0x107e8
    return select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x107f4 - 0x10800
char *function_107f4(char *dest, char *src) {
    // 0x107f4
    return stpcpy(dest, src);
}

// Address range: 0x10800 - 0x1080c
int32_t function_10800(int32_t fd, int32_t *buf, int32_t n, int32_t flags,
                       struct sockaddr *addr, int32_t *addr_len) {
    // 0x10800
    return recvfrom(fd, buf, n, flags, addr, addr_len);
}

// Address range: 0x1080c - 0x10818
void function_1080c(char *s) {
    // 0x1080c
    perror(s);
}

// Address range: 0x10818 - 0x10824
int32_t function_10818(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x10818
    return fwrite(ptr, size, n, s);
}

// Address range: 0x10824 - 0x10830
char *function_10824(char *dest, char *src) {
    // 0x10824
    return strcat(dest, src);
}

// Address range: 0x10830 - 0x1083c
int32_t function_10830(int32_t fd, int32_t request, ...) {
    // 0x10830
    return ioctl(fd, request);
}

// Address range: 0x1083c - 0x10848
int32_t function_1083c(int32_t useconds) {
    // 0x1083c
    return usleep(useconds);
}

// Address range: 0x10848 - 0x10854
char *function_10848(char *dest, char *src) {
    // 0x10848
    return strcpy(dest, src);
}

// Address range: 0x10854 - 0x10860
int32_t function_10854(struct timeval *tv, struct timezone *tz) {
    // 0x10854
    return gettimeofday(tv, tz);
}

// Address range: 0x10860 - 0x1086c
int32_t function_10860(char *s) {
    // 0x10860
    return puts(s);
}

// Address range: 0x1086c - 0x10878
int32_t function_1086c(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x1086c
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10878 - 0x10884
int32_t function_10878(char *command) {
    // 0x10878
    return system(command);
}

// Address range: 0x10884 - 0x10890
void function_10884(void) {
    // 0x10884
    __gmon_start__();
}

// Address range: 0x10890 - 0x1089c
void function_10890(int32_t status) {
    // 0x10890
    exit(status);
}

// Address range: 0x1089c - 0x108a8
int32_t function_1089c(char *s) {
    // 0x1089c
    return strlen(s);
}

// Address range: 0x108a8 - 0x108b4
int32_t function_108a8(int32_t fd, struct sockaddr *addr, int32_t len) {
    // 0x108a8
    return bind(fd, addr, len);
}

// Address range: 0x108b4 - 0x108c0
int32_t *function_108b4(int32_t *s, int32_t c, int32_t n) {
    // 0x108b4
    return memset(s, c, n);
}

// Address range: 0x108c0 - 0x108cc
char *function_108c0(char *dest, char *src, int32_t n) {
    // 0x108c0
    return strncpy(dest, src, n);
}

// Address range: 0x108cc - 0x108d8
int32_t function_108cc(char *name, int32_t type) {
    // 0x108cc
    return access(name, type);
}

// Address range: 0x108d8 - 0x108e4
int32_t function_108d8(struct _IO_FILE *stream) {
    // 0x108d8
    return fclose(stream);
}

// Address range: 0x108e4 - 0x108f0
int32_t function_108e4(int32_t fd, int32_t *buf, int32_t n, int32_t flags,
                       struct sockaddr *addr, int32_t addr_len) {
    // 0x108e4
    return sendto(fd, buf, n, flags, addr, addr_len);
}

// Address range: 0x108f0 - 0x108fc
int32_t function_108f0(char *s, char *format, ...) {
    // 0x108f0
    return sprintf(s, format);
}

// Address range: 0x108fc - 0x10908
struct _IO_FILE *function_108fc(char *filename, char *modes) {
    // 0x108fc
    return fopen64(filename, modes);
}

// Address range: 0x10908 - 0x10914
int32_t function_10908(int32_t domain, int32_t type, int32_t protocol) {
    // 0x10908
    return socket(domain, type, protocol);
}

// Address range: 0x10914 - 0x10920
int32_t function_10914(char *s1, char *s2, int32_t n) {
    // 0x10914
    return strncmp(s1, s2, n);
}

// Address range: 0x10920 - 0x1092c
void function_10920(void) {
    // 0x10920
    abort();
}

// Address range: 0x1092c - 0x10938
int32_t function_1092c(int32_t fd) {
    // 0x1092c
    return close(fd);
}

// Address range: 0x10938 - 0x109a0
int32_t function_10938(void) {
    // 0x10938
    printf("monitor-ipsig compile %s--%s\n", "Feb 19 2025", "14:17:27");
    function_11018();
    while (true) {
    lab_0x1095c:
        // 0x1095c
        if (function_11514() != 1) {
            usleep(0x61a80);
            while (function_11514() != 1) {
                // 0x10968
                usleep(0x61a80);
            }
        }
        while (true) {
        lab_0x10980:
            // 0x10980
            puts("Key Down!!!!!");
            function_1111c();
            if (function_112cc() == 1) {
                goto lab_0x1095c;
            } else {
                goto lab_0x10980;
            }
        }
    }
}

// Address range: 0x109a0 - 0x109c4
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x109a0
    int32_t i_v1; // 0x109a0
    __libc_start_main(0x10938, i_a2, (char **)&i_v1, (void (*)())0x115ad,
                      (void (*)())0x10938, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x109c4 - 0x109c8
int32_t function_109c4(int32_t i_a1) {
    // 0x109c4
    return i_a1;
}

// Address range: 0x109d0 - 0x109ec
int32_t function_109d0(void) {
    // 0x109d0
    if (i_g2 == 0) {
        int32_t i_v1; // 0x109d0
        return i_v1;
    }
    // 0x109e8
    __gmon_start__();
    return &i_g17;
}

// Address range: 0x109f4 - 0x10a12
int32_t function_109f4(void) {
    // 0x109f4
    return (int32_t)&p_g4;
}

// Address range: 0x10a18 - 0x10a42
int32_t function_10a18(void) {
    // 0x10a18
    return (int32_t)&p_g4;
}

// Address range: 0x10a44 - 0x10a5c
int32_t function_10a44(void) {
    // 0x10a44
    int32_t i_v1; // 0x10a44
    if (*(char *)&p_g4 == 0) {
        int32_t i_v2 = function_109f4(); // 0x10a52
        *(char *)&p_g4 = 1;
        i_v1 = i_v2;
    }
    // 0x10a5a
    return i_v1;
}

// Address range: 0x10a5c - 0x10a60
int32_t function_10a5c(int32_t i_a1, int32_t i_a2) {
    // 0x10a5c
    return i_a1;
}

// Address range: 0x10a62 - 0x10a6e
int32_t function_10a62(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10a62
    bool i_v1; // 0x10a62
    if (i_v1) {
        return i_a1;
    }
    int32_t i_v2 = i_a1; // 0x10a66
    int32_t i_v3;        // 0x10a62
    int16_t i_v4 = i_v3; // 0x10a66
    if (i_v1) {
        *(int16_t *)i_v3 = i_v4;
    }
    return i_v2;
}

// Address range: 0x10a6e - 0x10a70
int32_t function_10a6e(void) {
    // 0x10a6e
    return function_10a18();
}

// Address range: 0x10a70 - 0x10a7c
int32_t function_10a70(int32_t i_a1) {
    // 0x10a70
    bool i_v1; // 0x10a70
    if (i_v1) {
        return unknown_240(i_a1);
    }
    // 0x10a78
    return i_a1;
}

// Address range: 0x10a7c - 0x10a80
int32_t function_10a7c(void) {
    // 0x10a7c
    int32_t i_v1; // 0x10a7c
    return i_v1;
}

// Address range: 0x10a80 - 0x10b18
int32_t function_10a80(int32_t i_a1) {
    // 0x10a80
    int32_t i_v1; // bp-16, 0x10a80
    gettimeofday((struct timeval *)&i_v1, NULL);
    int32_t i_v2; // bp-24, 0x10a80
    int32_t i_v3; // 0x10a80
    sprintf((char *)&i_v2, "%ld", i_v3);
    char *p_v4 = (char *)i_a1; // 0x10ab4
    *p_v4 = 0;
    *(char *)(i_a1 + 1) = 0;
    *(char *)(i_a1 + 2) = 0;
    *(char *)(i_a1 + 3) = 0;
    *(char *)(i_a1 + 4) = 0;
    *(char *)(i_a1 + 5) = 0;
    *(char *)(i_a1 + 6) = 0;
    *(char *)(i_a1 + 7) = 0;
    *(char *)(i_a1 + 8) = 0;
    *(char *)(i_a1 + 9) = 0;
    uint32_t i_v5 = (6 - strlen((char *)&i_v2)) % 256; // 0x10aec
    if (i_v5 != 0) {
        // 0x10af4
        memset((int32_t *)i_a1, 48, i_v5);
    }
    // 0x10b00
    strcat(p_v4, (char *)&i_v2);
    return i_a1;
}

// Address range: 0x10b18 - 0x10bd4
int32_t function_10b18(char *p_a1, int32_t *p_a2) {
    struct in_addr x_v1;                                    // 0x10b84
    int32_t i_v2 = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0x10b34
    if (i_v2 == -1) {
        // 0x10ba8
        perror("socket");
        // 0x10ba0
        return -1;
    }
    // 0x10b44
    int32_t i_v3; // bp-48, 0x10b18
    strncpy((char *)&i_v3, p_a1, 20);
    int32_t i_v4; // 0x10b18
    if (ioctl(i_v2, 0x8915) < 0) {
        // 0x10bbc
        printf(":No Such Device %s/n", p_a1);
        i_v4 = -1;
    } else {
        // 0x10b74
        x_v1 = (struct { int32_t e0; }){.e0 = 0};
        int32_t i_v5; // 0x10b18
        x_v1.e0 = i_v5;
        strcpy((char *)p_a2, inet_ntoa(x_v1));
        close(i_v2);
        i_v4 = 1;
    }
    // 0x10ba0
    return i_v4;
}

// Address range: 0x10bd4 - 0x10cd8
int32_t function_10bd4(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = calloc(40, 1);                           // 0x10bec
    int32_t i_v2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x10c00
    if (i_v2 < 0) {
        // 0x10cb0
        perror("socket");
        exit(0);
        // UNREACHABLE
    }
    // 0x10c0c
    int32_t i_v3; // bp-56, 0x10bd4
    strcpy((char *)&i_v3, (char *)i_a2);
    if (ioctl(i_v2, 0x8927) < 0) {
        // 0x10cc4
        perror("ioctl");
        exit(0);
        return &i_g17;
    }
    // 0x10c30
    close(i_v2);
    char i_v4; // 0x10bd4
    sprintf((char *)p_v1, "%02X:%02X:%02X:%02X:%02X:%02X",
            (int32_t)(unsigned char)i_v4, (int32_t)i_v4, (int32_t)i_v4,
            (int32_t)i_v4, (int32_t)i_v4, (int32_t)i_v4);
    *(int32_t *)i_a1 = 0x3d43414d;
    *(int16_t *)stpcpy((char *)(i_a1 + 4), (char *)p_v1) = 44;
    free(p_v1);
    return i_a1;
}

// Address range: 0x10cd8 - 0x10db8
int32_t function_10cd8(int32_t *p_a1, char *p_a2) {
    int32_t *p_v1 = calloc(40, 1);                           // 0x10cf0
    int32_t i_v2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x10d04
    if (i_v2 < 0) {
        // 0x10d90
        perror("socket");
        exit(0);
        // UNREACHABLE
    }
    // 0x10d10
    int32_t i_v3; // bp-56, 0x10cd8
    strcpy((char *)&i_v3, p_a2);
    if (ioctl(i_v2, 0x8927) < 0) {
        // 0x10da4
        perror("ioctl");
        exit(0);
        // UNREACHABLE
    }
    // 0x10d34
    close(i_v2);
    char i_v4; // 0x10cd8
    sprintf((char *)p_v1, "%02X:%02X:%02X:%02X:%02X:%02X",
            (int32_t)(unsigned char)i_v4, (int32_t)i_v4, (int32_t)i_v4,
            (int32_t)i_v4, (int32_t)i_v4, (int32_t)i_v4);
    strcpy((char *)p_a1, (char *)p_v1);
    free(p_v1);
    return (int32_t)p_a1;
}

// Address range: 0x10db8 - 0x10e1c
int32_t function_10db8(int32_t i_a1) {
    // 0x10db8
    int32_t i_v1; // bp-80, 0x10db8
    memset(&i_v1, 0, 64);
    sprintf((char *)&i_v1, "echo %d > /sys/class/gpio/gpio%d/value", i_a1, 434);
    system((char *)&i_v1);
    sprintf((char *)&i_v1, "echo %d > /sys/class/gpio/gpio%d/value", i_a1, 435);
    return system((char *)&i_v1);
}

// Address range: 0x10e1c - 0x10e34
int32_t function_10e1c(void) {
    // 0x10e1c
    int32_t i_v1; // 0x10e1c
    access((char *)i_v1, F_OK);
    return 0;
}

// Address range: 0x10e34 - 0x10f5c
int32_t function_10e34(void) {
    // 0x10e34
    int32_t i_v1; // bp-72, 0x10e34
    memset(&i_v1, 0, 64);
    sprintf((char *)&i_v1, "/sys/class/gpio/gpio%d", 406);
    if (access((char *)&i_v1, F_OK) != 0) {
        struct _IO_FILE *p_v2 =
            fopen64("/sys/class/gpio/export", "w"); // 0x10e84
        if (p_v2 == NULL) {
            // 0x10f34
            puts("Open read gpio/export");
            // 0x10f2c
            return 1;
        }
        // 0x10e90
        sprintf((char *)&i_v1, "%d", 406);
        if (fwrite(&i_v1, strlen((char *)&i_v1), 1, p_v2) != 1) {
            // 0x10ec8
            puts("File Write Error!");
        }
        // 0x10ed4
        fclose(p_v2);
    }
    // 0x10edc
    sprintf((char *)&i_v1, "/sys/class/gpio/gpio%d/value", 406);
    struct _IO_FILE *p_v3 = fopen64((char *)&i_v1, "r"); // 0x10efc
    int32_t i_v4;                                        // 0x10e34
    if (p_v3 == NULL) {
        // 0x10f48
        puts("Open read recovery button failure");
        i_v4 = 1;
    } else {
        // 0x10f08
        int32_t i_v5; // bp-76, 0x10e34
        fscanf(p_v3, "%d", &i_v5);
        fclose(p_v3);
        i_v4 = i_v5 != 0;
    }
    // 0x10f2c
    return i_v4;
}

// Address range: 0x10f5c - 0x11018
int32_t function_10f5c(int32_t i_a1) {
    // 0x10f5c
    int32_t i_v1; // bp-80, 0x10f5c
    memset(&i_v1, 0, 64);
    for (int32_t i_v2 = 3; i_v2 > 0; i_v2--) {
        // 0x10f7c
        int32_t i_v3; // 0x10f5c
        if (i_a1 == 0) {
            // 0x10fe8
            sprintf((char *)&i_v1, "echo %d > /sys/class/gpio/gpio%d/value", 1,
                    434);
            system((char *)&i_v1);
            usleep(0xc350);
            i_v3 = 434;
        } else {
            // 0x10f98
            sprintf((char *)&i_v1, "echo %d > /sys/class/gpio/gpio%d/value", 1,
                    435);
            system((char *)&i_v1);
            usleep(0xc350);
            i_v3 = 435;
        }
        // 0x10fb0
        sprintf((char *)&i_v1, "echo %d > /sys/class/gpio/gpio%d/value", 0,
                i_v3);
        system((char *)&i_v1);
        usleep(0xc350);
    }
    // 0x10fdc
    return 0;
}

// Address range: 0x11018 - 0x1111c
int32_t function_11018(void) {
    int32_t i_v1 = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0x11030
    i_g3 = i_v1;
    if (i_v1 == -1) {
        // 0x110e4
        printf("socket error");
        // 0x110dc
        return -1;
    }
    int32_t i_v2 = 1; // bp-20, 0x11058
    if (setsockopt(i_v1, SO_DEBUG, 6, &i_v2, 4) == -1) {
        // 0x110fc
        printf("set socket error...");
        // 0x110dc
        return -1;
    }
    // 0x11070
    *(int16_t *)&i_g13 = -0x64c9;
    i_g14 = -1;
    i_g15 = 0;
    i_g10 = 0;
    i_g16 = 0;
    i_g11 = 0;
    *(int16_t *)&i_g8 = -0x63c9;
    i_g9 = 0;
    *(int16_t *)&p_g12 = 2;
    *(int16_t *)&p_g7 = 2;
    int32_t i_v3 = bind(i_g3, (struct sockaddr *)&p_g7, 16); // 0x110d0
    int32_t i_v4 = i_v3;                                     // 0x110d8
    if (i_v3 == -1) {
        // 0x1110c
        printf("bind error...");
        i_v4 = 0;
    }
    // 0x110dc
    return i_v4;
}

// Address range: 0x1111c - 0x11274
int32_t function_1111c(void) {
    int32_t i_v1 = 0; // bp-188, 0x11138
    int32_t i_v2 = 0; // bp-156, 0x11158
    int32_t i_v3;     // bp-116, 0x1111c
    memset(&i_v3, 0, 100);
    if (function_10b18("eth0", &i_v2) == 0) {
        // 0x1124c
        puts("get IP error");
    }
    // 0x1119c
    function_10cd8(&i_v1, "eth0");
    int32_t i_v4 = strlen((char *)&i_v1); // 0x111b0
    int32_t i_v5 = i_v4 + 1;              // 0x111c4
    strncpy((char *)&p_g5, (char *)&i_v1, i_v4);
    char *p_v6 = stpcpy((char *)&i_v3, (char *)&i_v2); // 0x111d4
    int32_t i_v7 = (int32_t)p_v6;                      // 0x111d4
    *p_v6 = 44;
    memcpy((int32_t *)(i_v7 + 1), &i_v1, i_v5);
    int32_t i_v8 = sendto(i_g3, &i_v3, i_v5 - (int32_t)&i_v3 + i_v7, 0,
                          (struct sockaddr *)&p_g12, 16); // 0x11224
    if (i_v8 < 0) {
        // 0x1125c
        printf("send error....");
        return 1;
    }
    // 0x11230
    printf("send ipmac:\n%s\n", &i_v3);
    return 1;
}

// Address range: 0x11274 - 0x112cc
int32_t function_11274(char *p_a1) {
    int32_t i_v1 = sendto(i_g3, (int32_t *)p_a1, 10, 0,
                          (struct sockaddr *)&p_g12, 16); // 0x112a8
    int32_t i_v2 = i_v1 < 0 ? 0x11770 : i_v1 % 0x10000 | 0x10000;
    return printf(i_v1 >= 0 ? (char *)0x11790 : (char *)i_v2);
}

// Address range: 0x112cc - 0x11514
int32_t function_112cc(void) {
    int32_t i_v1 = 0;     // bp-156, 0x112e4
    int32_t i_v2 = 2;     // bp-160, 0x112ec
    int32_t i_v3 = &i_v1; // 0x112ec
    i_v3 += 4;
    *(int32_t *)i_v3 = 0;
    int32_t i_v4; // bp-28, 0x112cc
    while (i_v3 != (int32_t)&i_v4) {
        // 0x112f0
        i_v3 += 4;
        *(int32_t *)i_v3 = 0;
    }
    int32_t i_v5 = i_g3; // 0x11310
    int32_t i_v6;        // bp-24, 0x112cc
    int32_t i_v7 = (int32_t)&i_v6 - 128;
    int32_t *p_v8 =
        (int32_t *)(4 * ((i_v5 < 0 ? i_v5 + 31 : i_v5) >> 5) + i_v7); // 0x11344
    *p_v8 = 1 << i_v5 % 32 | *p_v8;
    int32_t *p_v9 = calloc(30, 1); // 0x11350
    int32_t i_v10;                 // bp-152, 0x112cc
    int32_t i_v11 = select(i_v5 + 1, (struct _TYPEDEF_fd_set *)&i_v10, NULL,
                           NULL, (struct timeval *)&i_v2); // 0x11370
    switch (i_v11) {
    case -1: {
        // 0x11430
        exit(-1);
        // UNREACHABLE
    }
    default: {
        int32_t i_v12 = i_g3; // 0x113b4
        if ((1 << i_v12 % 32 &
             *(int32_t *)(4 * ((i_v12 < 0 ? i_v12 + 31 : i_v12) >> 5) +
                          i_v7)) == 0) {
            // 0x113f4
            if (i_g6 != 5) {
                // 0x113a0
                free(p_v9);
                // 0x113ac
                return 0;
            }
            // 0x11408
            i_g6 = 0;
            puts("Time Out");
            free(p_v9);
            return 1;
        }
        int32_t i_v13 = 16; // bp-164, 0x11444
        if (recvfrom(i_v12, p_v9, 30, 0, (struct sockaddr *)&p_g7, &i_v13) >=
            1) {
            // 0x11468
            printf("rev:\n%s\t", p_v9);
            i_g6 = 0;
            int32_t i_v14 = strlen((char *)&p_g5); // 0x11488
            int32_t i_v15;                         // 0x112cc
            if (strncmp((char *)p_v9, (char *)&p_g5, i_v14) == 0) {
                // 0x114a4
                printf("send_ack(\"1\");");
                function_10f5c(1);
                function_11274("OK");
                free(p_v9);
                i_v15 = 1;
            } else {
                // 0x114d4
                printf("send_ack(\"0\");");
                function_10f5c(0);
                function_11274("FAILD");
                free(p_v9);
                i_v15 = 0;
            }
            // 0x113ac
            return i_v15;
        }
        // 0x11504
        printf("read error....");
    }
    case 0: {
        int32_t i_v16 = i_g6 + 1; // 0x11390
        i_g6 = i_v16;
        if (i_v16 != 5) {
            // 0x113a0
            free(p_v9);
            // 0x113ac
            return 0;
        }
        // 0x11408
        i_g6 = 0;
        puts("Time Out");
        free(p_v9);
        return 1;
    }
    }
}

// Address range: 0x11514 - 0x115ac
int32_t function_11514(void) {
    int32_t i_v1 = 0; // 0x1151c
    for (int32_t i_v2 = 5; i_v2 > 0; i_v2--) {
        int32_t i_v3 = i_v1;
        int32_t i_v4 = i_v3; // 0x11528
        if (function_10e34() == 0) {
            // 0x11544
            usleep(0x4e20);
            i_v4 = i_v3 + 1;
        }
        // 0x1152c
        i_v1 = i_v4;
    }
    // 0x11534
    if (i_v1 != 5) {
        // 0x11540
        return 0;
    }
    // 0x11560
    if (function_10e34() == 0) {
        usleep(1000);
        while (function_10e34() == 0) {
            // 0x1155c
            usleep(1000);
        }
    }
    for (int32_t i_v5 = 5; i_v5 > 0; i_v5--) {
        // 0x11574
        usleep(0x186a0);
        usleep(0x186a0);
    }
    // 0x11540
    return 1;
}

// Address range: 0x115ac - 0x115e4
int32_t function_115ac(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_10774(i_a1, i_a2, i_a3, i_a4); // 0x115be
    return (int32_t)&i_g1 - 0x15d34 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x115f0 - 0x115f8
int32_t function_115f0(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x115f0
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 63
